
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004e  00800100  0001692e  000169e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0001692e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d7e  0080014e  0080014e  00016a30  2**0
                  ALLOC
  3 .eeprom       00000857  00810000  00810000  00016a30  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000100  00000000  00000000  00017287  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00002625  00000000  00000000  00017387  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001352c  00000000  00000000  000199ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000dd8  00000000  00000000  0002ced8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000e32a  00000000  00000000  0002dcb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001270  00000000  00000000  0003bfdc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000547d  00000000  00000000  0003d24c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007d44  00000000  00000000  000426c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000750  00000000  00000000  0004a40d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 85 12 	jmp	0x250a	; 0x250a <__ctors_end>
       4:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
       8:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
       c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      10:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      14:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      18:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      1c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      20:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      24:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      28:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      2c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      30:	0c 94 56 13 	jmp	0x26ac	; 0x26ac <__vector_12>
      34:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      38:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      3c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      40:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      44:	0c 94 29 82 	jmp	0x10452	; 0x10452 <__vector_17>
      48:	0c 94 eb 14 	jmp	0x29d6	; 0x29d6 <__vector_18>
      4c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      50:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      54:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      58:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      5c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      60:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      64:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      68:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      6c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      70:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      74:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      78:	0c 94 f8 46 	jmp	0x8df0	; 0x8df0 <__vector_30>
      7c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      80:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      84:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      88:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__bad_interrupt>
      8c:	cc 13       	cpse	r28, r28
      8e:	ca 13       	cpse	r28, r26
      90:	ce 13       	cpse	r28, r30
      92:	d0 13       	cpse	r29, r16
      94:	d2 13       	cpse	r29, r18
      96:	d4 13       	cpse	r29, r20
      98:	d6 13       	cpse	r29, r22
      9a:	d8 13       	cpse	r29, r24
      9c:	da 13       	cpse	r29, r26
      9e:	dc 13       	cpse	r29, r28
      a0:	de 13       	cpse	r29, r30
      a2:	e0 13       	cpse	r30, r16
      a4:	e2 13       	cpse	r30, r18
      a6:	f0 13       	cpse	r31, r16
      a8:	e4 13       	cpse	r30, r20
      aa:	f0 13       	cpse	r31, r16
      ac:	e6 13       	cpse	r30, r22
      ae:	e8 13       	cpse	r30, r24
      b0:	f0 13       	cpse	r31, r16
      b2:	ea 13       	cpse	r30, r26
      b4:	ec 13       	cpse	r30, r28
      b6:	ee 13       	cpse	r30, r30
      b8:	f0 13       	cpse	r31, r16
      ba:	f0 13       	cpse	r31, r16
      bc:	e4 13       	cpse	r30, r20
      be:	d6 13       	cpse	r29, r22
      c0:	f0 13       	cpse	r31, r16
      c2:	d8 13       	cpse	r29, r24
      c4:	dc 13       	cpse	r29, r28
      c6:	e0 13       	cpse	r30, r16
      c8:	a9 50       	subi	r26, 0x09	; 9
      ca:	c1 50       	subi	r28, 0x01	; 1
      cc:	d3 50       	subi	r29, 0x03	; 3
      ce:	0a 51       	subi	r16, 0x1A	; 26
      d0:	39 51       	subi	r19, 0x19	; 25
      d2:	4f 51       	subi	r20, 0x1F	; 31
      d4:	8a 51       	subi	r24, 0x1A	; 26
      d6:	c2 51       	subi	r28, 0x12	; 18
      d8:	04 52       	subi	r16, 0x24	; 36
      da:	0c 52       	subi	r16, 0x2C	; 44
      dc:	2f 53       	subi	r18, 0x3F	; 63
      de:	3b 53       	subi	r19, 0x3B	; 59
      e0:	6d 53       	subi	r22, 0x3D	; 61
      e2:	aa 53       	subi	r26, 0x3A	; 58
      e4:	c7 53       	subi	r28, 0x37	; 55
      e6:	e1 53       	subi	r30, 0x31	; 49
      e8:	21 54       	subi	r18, 0x41	; 65
      ea:	1f 51       	subi	r17, 0x1F	; 31
      ec:	dc 51       	subi	r29, 0x1C	; 28
      ee:	86 53       	subi	r24, 0x36	; 54
      f0:	a8 51       	subi	r26, 0x18	; 24
      f2:	24 52       	subi	r18, 0x24	; 36
      f4:	73 52       	subi	r23, 0x23	; 35
      f6:	8f 52       	subi	r24, 0x2F	; 47
      f8:	a9 52       	subi	r26, 0x29	; 41
      fa:	f7 52       	subi	r31, 0x27	; 39
      fc:	15 53       	subi	r17, 0x35	; 53
      fe:	5b 54       	subi	r21, 0x4B	; 75
     100:	71 54       	subi	r23, 0x41	; 65
     102:	76 54       	subi	r23, 0x46	; 70
     104:	af 54       	subi	r26, 0x4F	; 79
     106:	de 54       	subi	r29, 0x4E	; 78
     108:	23 55       	subi	r18, 0x53	; 83
     10a:	41 55       	subi	r20, 0x51	; 81
     10c:	5f 55       	subi	r21, 0x5F	; 95
     10e:	99 55       	subi	r25, 0x59	; 89
     110:	fc 55       	subi	r31, 0x5C	; 92
     112:	40 5a       	subi	r20, 0xA0	; 160
     114:	c4 54       	subi	r28, 0x44	; 68
     116:	69 5a       	subi	r22, 0xA9	; 169
     118:	57 5b       	subi	r21, 0xB7	; 183
     11a:	13 5b       	subi	r17, 0xB3	; 179
     11c:	3e 5b       	subi	r19, 0xBE	; 190
     11e:	91 5b       	subi	r25, 0xB1	; 177
     120:	71 5b       	subi	r23, 0xB1	; 177
     122:	a8 5b       	subi	r26, 0xB8	; 184
     124:	c1 5b       	subi	r28, 0xB1	; 177
     126:	d3 5b       	subi	r29, 0xB3	; 179
     128:	83 5a       	subi	r24, 0xA3	; 163
     12a:	dc 5a       	subi	r29, 0xAC	; 172
     12c:	f9 5a       	subi	r31, 0xA9	; 169
     12e:	0c 56       	subi	r16, 0x6C	; 108
     130:	2c 56       	subi	r18, 0x6C	; 108
     132:	53 56       	subi	r21, 0x63	; 99
     134:	62 56       	subi	r22, 0x62	; 98
     136:	80 56       	subi	r24, 0x60	; 96
     138:	97 56       	subi	r25, 0x67	; 103
     13a:	c3 56       	subi	r28, 0x63	; 99
     13c:	da 56       	subi	r29, 0x6A	; 106
     13e:	06 57       	subi	r16, 0x76	; 118
     140:	26 57       	subi	r18, 0x76	; 118
     142:	57 57       	subi	r21, 0x77	; 119
     144:	66 57       	subi	r22, 0x76	; 118
     146:	bf 57       	subi	r27, 0x7F	; 127
     148:	36 58       	subi	r19, 0x86	; 134
     14a:	4a 58       	subi	r20, 0x8A	; 138
     14c:	25 59       	subi	r18, 0x95	; 149
     14e:	25 59       	subi	r18, 0x95	; 149
     150:	5e 58       	subi	r21, 0x8E	; 142
     152:	72 58       	subi	r23, 0x82	; 130
     154:	7a 58       	subi	r23, 0x8A	; 138
     156:	96 58       	subi	r25, 0x86	; 134
     158:	aa 58       	subi	r26, 0x8A	; 138
     15a:	b7 58       	subi	r27, 0x87	; 135
     15c:	ce 58       	subi	r28, 0x8E	; 142
     15e:	e5 58       	subi	r30, 0x85	; 133
     160:	03 59       	subi	r16, 0x93	; 147
     162:	28 59       	subi	r18, 0x98	; 152
     164:	3f 59       	subi	r19, 0x9F	; 159
     166:	56 59       	subi	r21, 0x96	; 150
     168:	6d 59       	subi	r22, 0x9D	; 157
     16a:	84 59       	subi	r24, 0x94	; 148
     16c:	9b 59       	subi	r25, 0x9B	; 155
     16e:	b2 59       	subi	r27, 0x92	; 146
     170:	c9 59       	subi	r28, 0x99	; 153
     172:	d8 59       	subi	r29, 0x98	; 152
     174:	ef 59       	subi	r30, 0x9F	; 159
     176:	12 5a       	subi	r17, 0xA2	; 162
     178:	bb 8f       	std	Y+27, r27	; 0x1b
     17a:	d7 8f       	std	Z+31, r29	; 0x1f
     17c:	ea 8f       	std	Y+26, r30	; 0x1a
     17e:	19 90       	ld	r1, Y+
     180:	42 90       	ld	r4, -Z
     182:	b5 90       	lpm	r11, Z+
     184:	c4 90       	lpm	r12, Z+
     186:	cd 90       	ld	r12, X+
     188:	09 91       	ld	r16, Y+
     18a:	30 91 77 91 	lds	r19, 0x9177
     18e:	81 91       	ld	r24, Z+
     190:	3c 91       	ld	r19, X
     192:	87 91       	elpm	r24, Z+
     194:	e7 8f       	std	Z+31, r30	; 0x1f
     196:	96 91       	elpm	r25, Z+
     198:	9c 91       	ld	r25, X
     19a:	31 94       	neg	r3
     19c:	35 94       	asr	r3
     19e:	51 94       	neg	r5
     1a0:	35 98       	cbi	0x06, 5	; 6
     1a2:	35 98       	cbi	0x06, 5	; 6
     1a4:	35 98       	cbi	0x06, 5	; 6
     1a6:	35 98       	cbi	0x06, 5	; 6
     1a8:	9a 94       	dec	r9
     1aa:	35 98       	cbi	0x06, 5	; 6
     1ac:	ba 94       	dec	r11
     1ae:	35 98       	cbi	0x06, 5	; 6
     1b0:	d7 94       	ror	r13
     1b2:	60 95       	com	r22
     1b4:	bb 95       	.word	0x95bb	; ????
     1b6:	de 95 7d 94 	call	0x7528fa	; 0x7528fa <__data_load_end+0x73bf7e>
     1ba:	35 98       	cbi	0x06, 5	; 6
     1bc:	73 95       	inc	r23
     1be:	f6 95       	lsr	r31
     1c0:	2e 96       	adiw	r28, 0x0e	; 14
     1c2:	46 96       	adiw	r24, 0x16	; 22
     1c4:	82 96       	adiw	r24, 0x22	; 34
     1c6:	92 96       	adiw	r26, 0x22	; 34
     1c8:	a3 97       	sbiw	r28, 0x23	; 35
     1ca:	b3 97       	sbiw	r30, 0x23	; 35
     1cc:	f8 97       	sbiw	r30, 0x38	; 56
     1ce:	17 98       	cbi	0x02, 7	; 2
     1d0:	29 98       	cbi	0x05, 1	; 5
     1d2:	2f 98       	cbi	0x05, 7	; 5
     1d4:	31 98       	cbi	0x06, 1	; 6
     1d6:	6f 98       	cbi	0x0d, 7	; 13
     1d8:	c4 98       	cbi	0x18, 4	; 24
     1da:	d3 98       	cbi	0x1a, 3	; 26
     1dc:	15 99       	sbic	0x02, 5	; 2
     1de:	27 99       	sbic	0x04, 7	; 4
     1e0:	3c 99       	sbic	0x07, 4	; 7
     1e2:	5f 99       	sbic	0x0b, 7	; 11
     1e4:	15 9a       	sbi	0x02, 5	; 2
     1e6:	1f 9a       	sbi	0x03, 7	; 3
     1e8:	f3 a0       	ldd	r15, Z+35	; 0x23
     1ea:	7e 9a       	sbi	0x0f, 6	; 15
     1ec:	8b 9b       	sbis	0x11, 3	; 17
     1ee:	da 9b       	sbis	0x1b, 2	; 27
     1f0:	20 9c       	mul	r2, r0
     1f2:	98 9c       	mul	r9, r8
     1f4:	29 9d       	mul	r18, r9
     1f6:	4c 9d       	mul	r20, r12
     1f8:	12 9e       	mul	r1, r18
     1fa:	3c 9e       	mul	r3, r28
     1fc:	f5 9e       	mul	r15, r21
     1fe:	0e 9f       	mul	r16, r30
     200:	18 a0       	ldd	r1, Y+32	; 0x20
     202:	86 9f       	mul	r24, r22
     204:	c8 9f       	mul	r28, r24
     206:	b2 a0       	ldd	r11, Z+34	; 0x22
     208:	e0 a0       	ldd	r14, Z+32	; 0x20
     20a:	f3 a0       	ldd	r15, Z+35	; 0x23
     20c:	1e a0       	ldd	r1, Y+38	; 0x26
     20e:	a1 a0       	ldd	r10, Z+33	; 0x21
     210:	e5 a0       	ldd	r14, Z+37	; 0x25
     212:	ec a0       	ldd	r14, Y+36	; 0x24
     214:	ee a2       	std	Y+38, r14	; 0x26
     216:	f4 a2       	std	Z+36, r15	; 0x24
     218:	f8 a2       	std	Y+32, r15	; 0x20
     21a:	0f a3       	std	Y+39, r16	; 0x27
     21c:	29 a3       	std	Y+33, r18	; 0x21
     21e:	2d a3       	std	Y+37, r18	; 0x25
     220:	58 a3       	std	Y+32, r21	; 0x20
     222:	72 a3       	std	Z+34, r23	; 0x22
     224:	78 a3       	std	Y+32, r23	; 0x20
     226:	80 a3       	std	Z+32, r24	; 0x20
     228:	83 a3       	std	Z+35, r24	; 0x23
     22a:	86 a3       	std	Z+38, r24	; 0x26
     22c:	89 a3       	std	Y+33, r24	; 0x21
     22e:	8c a3       	std	Y+36, r24	; 0x24
     230:	8f a3       	std	Y+39, r24	; 0x27
     232:	93 a3       	std	Z+35, r25	; 0x23
     234:	96 a3       	std	Z+38, r25	; 0x26
     236:	99 a3       	std	Y+33, r25	; 0x21
     238:	a1 a3       	std	Z+33, r26	; 0x21
     23a:	1a a4       	ldd	r1, Y+42	; 0x2a
     23c:	1d a4       	ldd	r1, Y+45	; 0x2d
     23e:	bd a4       	ldd	r11, Y+45	; 0x2d
     240:	cc a4       	ldd	r12, Y+44	; 0x2c
     242:	fd a4       	ldd	r15, Y+45	; 0x2d
     244:	0b a5       	ldd	r16, Y+43	; 0x2b
     246:	37 a5       	ldd	r19, Z+47	; 0x2f
     248:	dc a4       	ldd	r13, Y+44	; 0x2c
     24a:	e9 a4       	ldd	r14, Y+41	; 0x29
     24c:	f3 a4       	ldd	r15, Z+43	; 0x2b
     24e:	41 a5       	ldd	r20, Z+41	; 0x29
     250:	4e a5       	ldd	r20, Y+46	; 0x2e
     252:	59 a5       	ldd	r21, Y+41	; 0x29
     254:	5c a5       	ldd	r21, Y+44	; 0x2c
     256:	5f a5       	ldd	r21, Y+47	; 0x2f
     258:	62 a5       	ldd	r22, Z+42	; 0x2a
     25a:	65 a5       	ldd	r22, Z+45	; 0x2d
     25c:	68 a5       	ldd	r22, Y+40	; 0x28
     25e:	6b a5       	ldd	r22, Y+43	; 0x2b
     260:	6e a5       	ldd	r22, Y+46	; 0x2e
     262:	90 a5       	ldd	r25, Z+40	; 0x28
     264:	7e a5       	ldd	r23, Y+46	; 0x2e
     266:	71 a5       	ldd	r23, Z+41	; 0x29
     268:	89 a5       	ldd	r24, Y+41	; 0x29
     26a:	a7 a4       	ldd	r10, Z+47	; 0x2f

0000026c <__c.3002>:
     26c:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

0000027b <__c.2986>:
     27b:	57 61 74 63 68 44 6f 67 00                          WatchDog.

00000284 <__c.2984>:
     284:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

0000028d <__c.2982>:
     28d:	45 78 74 65 72 6e 61 6c 00                          External.

00000296 <__c.2980>:
     296:	50 6f 77 65 72 4f 6e 00                             PowerOn.

0000029e <__prodloc>:
     29e:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

000002aa <__prntloc>:
     2aa:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

000002b6 <__prntlmt>:
     2b6:	02 03 04 02 0f 0f                                   ......

000002bc <__prntstr>:
     2bc:	01 01 00 00 00 00                                   ......

000002c2 <__hostloc>:
     2c2:	01 0a 02 0a 03 0a                                   ......

000002c8 <MaxKeyHit>:
     2c8:	02 04 03 03 03 03 03 04 03 04                       ..........

000002d2 <strDispenserName1>:
     2d2:	4e 2f 41 00                                         N/A.

000002d6 <strDispenserName2>:
     2d6:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

000002df <strDispenserName3>:
     2df:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

000002ea <strDispenserName4>:
     2ea:	54 61 74 73 75 6e 6f 00                             Tatsuno.

000002f2 <strDispenserName5>:
     2f2:	4c 47 00                                            LG.

000002f5 <DefListDispenserName>:
     2f5:	d2 02 d6 02 df 02 ea 02 f2 02                       ..........

000002ff <__c.9953>:
     2ff:	53 65 63 74 6f 72 20 77 72 69 74 74 65 6e 00        Sector written.

0000030e <__c.9951>:
     30e:	57 72 69 74 65 20 73 65 63 74 6f 72 2e 2e 00        Write sector...

0000031d <__c.9945>:
     31d:	46 69 6c 6c 20 44 61 74 61 00                       Fill Data.

00000327 <__c.9942>:
     327:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     337:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

0000033f <__c.9937>:
     33f:	20 25 64 00                                          %d.

00000343 <__c.9935>:
     343:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     353:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

0000035b <__c.9933>:
     35b:	53 65 63 74 6f 72 3d 25 64 20 00                    Sector=%d .

00000366 <__c.9930>:
     366:	53 65 63 74 6f 72 20 52 65 61 64 00                 Sector Read.

00000372 <__c.9928>:
     372:	52 65 61 64 20 53 65 63 74 6f 72 2e 2e 00           Read Sector...

00000380 <__c.9923>:
     380:	43 6c 65 61 72 20 42 75 66 66 65 72 2e 2e 00        Clear Buffer...

0000038f <__c.9920>:
     38f:	4e 6f 74 20 49 6e 69 74 69 61 6c 69 7a 65 64 00     Not Initialized.

0000039f <__c.9918>:
     39f:	43 61 72 64 20 50 72 6f 74 65 63 74 65 64 00        Card Protected.

000003ae <__c.9916>:
     3ae:	4e 6f 74 20 49 6e 69 74 69 61 6c 69 7a 65 64 00     Not Initialized.

000003be <__c.9913>:
     3be:	49 6e 69 74 20 54 69 6d 65 6f 75 74 00              Init Timeout.

000003cb <__c.9911>:
     3cb:	49 6e 69 74 20 54 69 6d 65 6f 75 74 00              Init Timeout.

000003d8 <__c.9909>:
     3d8:	49 6e 69 74 20 46 61 69 6c 65 64 00                 Init Failed.

000003e4 <__c.9907>:
     3e4:	49 6e 69 74 69 61 6c 69 7a 65 64 20 20 00           Initialized  .

000003f2 <__c.9905>:
     3f2:	49 6e 69 74 69 61 6c 69 7a 65 64 20 20 20 00        Initialized   .

00000401 <__c.9902>:
     401:	49 6e 69 74 69 61 6c 69 7a 65 20 4d 4d 43 00        Initialize MMC.

00000410 <__c.9900>:
     410:	49 6e 69 74 69 61 6c 69 7a 65 20 4d 4d 43 2e 2e     Initialize MMC..
	...

00000421 <__c.9896>:
     421:	52 65 73 65 74 20 43 61 72 64 20 00                 Reset Card .

0000042d <__c.9894>:
     42d:	52 65 73 65 74 20 43 61 72 64 20 00                 Reset Card .

00000439 <__c.9891>:
     439:	43 61 72 64 20 46 6f 75 6e 64 20 00                 Card Found .

00000445 <__c.9889>:
     445:	43 61 72 64 20 50 72 65 73 65 6e 74 20 20 20 20     Card Present    
     455:	20 00                                                .

00000457 <__c.9882>:
     457:	4e 6f 43 61 72 64 20 46 6f 75 6e 64 00              NoCard Found.

00000464 <__c.9880>:
     464:	44 65 74 65 63 74 20 4d 4d 43 00                    Detect MMC.

0000046f <__c.9877>:
     46f:	50 4f 52 54 47 3d 25 2e 32 58 00                    PORTG=%.2X.

0000047a <__c.9866>:
     47a:	4d 72 2e 42 69 67 00                                Mr.Big.

00000481 <__c.9771>:
     481:	25 64 00                                            %d.

00000484 <__c.9769>:
     484:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     494:	73 25 73 25 73 3a 00                                s%s%s:.

0000049b <__c.9720>:
     49b:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     4ab:	3a 25 73 00                                         :%s.

000004af <__c.9692>:
     4af:	25 73 00                                            %s.

000004b2 <__c.9683>:
     4b2:	25 73 00                                            %s.

000004b5 <__c.9632>:
     4b5:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

000004bd <__c.9611>:
     4bd:	43 54 53 52 50 00                                   CTSRP.

000004c3 <__c.9587>:
     4c3:	3a 00                                               :.

000004c5 <__c.9433>:
     4c5:	4e 2f 41 00                                         N/A.

000004c9 <__c.9413>:
     4c9:	25 73 00                                            %s.

000004cc <__c.9408>:
	...

000004cd <__c.9281>:
     4cd:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

000004d7 <__c.9279>:
     4d7:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

000004e5 <__c.9271>:
     4e5:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

000004f0 <__c.9269>:
     4f0:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

000004ff <__c.9265>:
     4ff:	25 73 25 73 00                                      %s%s.

00000504 <__c.9263>:
     504:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

0000050d <__c.9261>:
     50d:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     51d:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

0000052b <__c.9259>:
     52b:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     53b:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

00000549 <__c.9257>:
     549:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

00000554 <__c.9255>:
     554:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

00000563 <__c.9253>:
     563:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

0000056e <__c.9251>:
     56e:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

0000057d <__c.9249>:
     57d:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

0000058a <__c.9247>:
     58a:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     59a:	73 00                                               s.

0000059c <__c.9245>:
     59c:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

000005a9 <__c.9241>:
     5a9:	4e 2f 41 00                                         N/A.

000005ad <__c.9237>:
     5ad:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     5bd:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     5cd:	20 20 20 20 20 20 00                                      .

000005d4 <__c.9235>:
     5d4:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     5e4:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     5f4:	41 48 28 52 50 29 00                                AH(RP).

000005fb <__c.9231>:
     5fb:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     60b:	20 00                                                .

0000060d <__c.9229>:
     60d:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     61d:	20 00                                                .

0000061f <__c.9227>:
     61f:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     62f:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     63f:	20 20 20 20 20 00                                        .

00000645 <__c.9225>:
     645:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     655:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     665:	20 20 20 20 20 00                                        .

0000066b <__c.9222>:
     66b:	25 64 00                                            %d.

0000066e <__c.9164>:
     66e:	25 73 00                                            %s.

00000671 <__c.9159>:
     671:	30 00                                               0.

00000673 <__c.9157>:
     673:	30 00                                               0.

00000675 <__c.8993>:
     675:	25 73 00                                            %s.

00000678 <__c.8991>:
     678:	25 73 00                                            %s.

0000067b <__c.8989>:
     67b:	25 73 00                                            %s.

0000067e <__c.8987>:
     67e:	25 73 00                                            %s.

00000681 <__c.8985>:
     681:	25 73 00                                            %s.

00000684 <__c.8789>:
     684:	25 73 00                                            %s.

00000687 <__c.8701>:
     687:	30 30 30 30 30 30 30 30 00                          00000000.

00000690 <__c.8620>:
     690:	4f 70 65 72 61 74 6f 72 3a 20 25 73 00              Operator: %s.

0000069d <__c.8615>:
     69d:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6ad:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6bd:	2d 00                                               -.

000006bf <__c.8606>:
     6bf:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     6cf:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     6df:	20 20 20 00                                            .

000006e3 <__c.8604>:
     6e3:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     6f3:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     703:	20 20 20 00                                            .

00000707 <__c.8452>:
     707:	20 20 20 20 20 4f 70 65 72 61 74 6f 72 3a 20 25          Operator: %
     717:	73 00                                               s.

00000719 <__c.8447>:
     719:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     729:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     739:	2d 2d 00                                            --.

0000073c <__c.8444>:
     73c:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     74c:	6d 74 3a 20 25 73 00                                mt: %s.

00000753 <__c.8441>:
     753:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     763:	73 63 3a 20 25 73 00                                sc: %s.

0000076a <__c.8438>:
     76a:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     77a:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     78a:	2d 2d 00                                            --.

0000078d <__c.8435>:
     78d:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     79d:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

000007a7 <__c.8432>:
     7a7:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     7b7:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

000007c0 <__c.8429>:
     7c0:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     7d0:	6d 20 3a 20 25 73 00                                m : %s.

000007d7 <__c.8426>:
     7d7:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     7e7:	20 20 3a 20 25 73 00                                  : %s.

000007ee <__c.8423>:
     7ee:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     7fe:	20 20 3a 20 25 73 00                                  : %s.

00000805 <__c.8420>:
     805:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     815:	20 20 3a 20 25 73 00                                  : %s.

0000081c <__c.8417>:
     81c:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     82c:	20 20 3a 20 25 73 00                                  : %s.

00000833 <__c.8414>:
     833:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     843:	20 20 3a 20 25 73 00                                  : %s.

0000084a <__c.8411>:
     84a:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     85a:	20 20 3a 20 25 73 00                                  : %s.

00000861 <__c.8408>:
     861:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     871:	20 20 3a 20 25 73 20 00                               : %s .

00000879 <__c.8405>:
     879:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     889:	20 20 3a 20 25 73 00                                  : %s.

00000890 <__c.8402>:
     890:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     8a0:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     8b0:	20 20 00                                              .

000008b3 <__c.8399>:
     8b3:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     8c3:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     8d3:	2d 2d 00                                            --.

000008d6 <__c.8396>:
     8d6:	20 20 20 20 2e 25 73 00                                 .%s.

000008de <__c.8392>:
     8de:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     8ee:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     8fe:	5f 29 00                                            _).

00000901 <__c.8387>:
     901:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     911:	20 20 20 20 20 20 00                                      .

00000918 <__c.8384>:
     918:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     928:	20 20 20 20 20 20 00                                      .

0000092f <__c.8381>:
     92f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     93f:	20 00                                                .

00000941 <__c.8379>:
     941:	20 20 00                                              .

00000944 <__c.8377>:
     944:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     954:	73 00                                               s.

00000956 <__c.8375>:
     956:	25 73 20 20 00                                      %s  .

0000095b <__c.8373>:
     95b:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     96b:	73 00                                               s.

0000096d <__c.8370>:
     96d:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     97d:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     98d:	20 20 00                                              .

00000990 <__c.8368>:
     990:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     9a0:	25 73 00                                            %s.

000009a3 <__c.8366>:
     9a3:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     9b3:	73 00                                               s.

000009b5 <__c.8363>:
     9b5:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     9c5:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     9d5:	2d 2d 00                                            --.

000009d8 <__c.8360>:
     9d8:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     9e8:	20 20 3a 20 25 73 00                                  : %s.

000009ef <__c.8357>:
     9ef:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     9ff:	20 20 3a 20 25 73 00                                  : %s.

00000a06 <__c.8354>:
	...

00000a07 <__c.8352>:
     a07:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     a17:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000a21 <__c.8349>:
     a21:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     a31:	20 20 3a 20 25 73 20 4c 00                            : %s L.

00000a3a <__c.8346>:
	...

00000a3b <__c.8344>:
     a3b:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     a4b:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000a55 <__c.8341>:
     a55:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     a65:	20 20 3a 20 25 73 00                                  : %s.

00000a6c <__c.8338>:
     a6c:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     a7c:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

00000a88 <__c.8335>:
     a88:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     a98:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     aa8:	2d 2d 00                                            --.

00000aab <__c.8332>:
     aab:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     abb:	25 73 20 00                                         %s .

00000abf <__c.8328>:
     abf:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     acf:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000ade <__c.8311>:
     ade:	20 00                                                .

00000ae0 <__c.8309>:
     ae0:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     af0:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     b00:	20 20 20 00                                            .

00000b04 <__c.7910>:
     b04:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     b14:	69 6f 6e 00                                         ion.

00000b18 <__c.7904>:
     b18:	50 72 6f 73 65 73 00                                Proses.

00000b1f <__c.7902>:
     b1f:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000b2c <__c.7897>:
     b2c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     b3c:	6e 74 65 72 00                                      nter.

00000b41 <__c.7895>:
     b41:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     b51:	6e 74 65 72 00                                      nter.

00000b56 <__c.7892>:
     b56:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     b66:	74 65 72 20 00                                      ter .

00000b6b <__c.7890>:
     b6b:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000b77 <__c.7888>:
     b77:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000b84 <__c.7885>:
     b84:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     b94:	6e 74 65 72 00                                      nter.

00000b99 <__c.7883>:
     b99:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     ba9:	6e 74 65 72 00                                      nter.

00000bae <__c.7880>:
     bae:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     bbe:	74 65 72 20 00                                      ter .

00000bc3 <__c.7878>:
     bc3:	5f 00                                               _.

00000bc5 <__c.7876>:
     bc5:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000bd5 <__c.7800>:
     bd5:	23 29 53 61 76 65 00                                #)Save.

00000bdc <__c.7798>:
     bdc:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000be9 <__c.7796>:
     be9:	25 64 00                                            %d.

00000bec <__c.7784>:
     bec:	25 64 00                                            %d.

00000bef <__c.7776>:
     bef:	23 29 53 61 76 65 00                                #)Save.

00000bf6 <__c.7774>:
     bf6:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000c03 <__c.7772>:
     c03:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     c13:	45 78 69 74 00                                      Exit.

00000c18 <__c.7770>:
     c18:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000c22 <__c.7768>:
     c22:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000c2c <__c.7715>:
     c2c:	25 2e 32 64 00                                      %.2d.

00000c31 <__c.7713>:
     c31:	25 64 00                                            %d.

00000c34 <__c.7696>:
     c34:	25 2e 32 64 00                                      %.2d.

00000c39 <__c.7694>:
     c39:	25 64 00                                            %d.

00000c3c <__c.7686>:
     c3c:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000c4c <__c.7684>:
     c4c:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000c5c <__c.7682>:
     c5c:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     c6c:	20 3a 00                                             :.

00000c6f <__c.7680>:
     c6f:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     c7f:	6c 3a 00                                            l:.

00000c82 <__c.7616>:
     c82:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     c92:	53 61 76 65 00                                      Save.

00000c97 <__c.7614>:
     c97:	54 49 4d 45 20 3a 20 00                             TIME : .

00000c9f <__c.7612>:
     c9f:	44 41 54 45 20 3a 20 00                             DATE : .

00000ca7 <__c.7562>:
     ca7:	25 64 00                                            %d.

00000caa <__c.7551>:
     caa:	25 64 00                                            %d.

00000cad <__c.7543>:
     cad:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     cbd:	53 61 76 65 00                                      Save.

00000cc2 <__c.7541>:
     cc2:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     cd2:	4e 36 3a 00                                         N6:.

00000cd6 <__c.7539>:
     cd6:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     ce6:	4e 35 3a 00                                         N5:.

00000cea <__c.7537>:
     cea:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000cfa <__c.7453>:
     cfa:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000d04 <__c.7451>:
     d04:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000d10 <__c.7448>:
     d10:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000d1e <__c.7445>:
     d1e:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000d27 <__c.7443>:
     d27:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000d30 <__c.7439>:
     d30:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     d40:	20 20 20 20 00                                          .

00000d45 <__c.7437>:
     d45:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     d55:	49 44 20 20 00                                      ID  .

00000d5a <__c.7435>:
     d5a:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     d6a:	20 20 20 20 00                                          .

00000d6f <__c.7423>:
     d6f:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     d7f:	2e 32 64 00                                         .2d.

00000d83 <__c.7417>:
     d83:	23 29 53 61 76 65 00                                #)Save.

00000d8a <__c.7415>:
     d8a:	2a 29 42 61 63 6b 00                                *)Back.

00000d91 <__c.7410>:
     d91:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     da1:	2e 32 64 00                                         .2d.

00000da5 <__c.7361>:
     da5:	25 2e 32 64 00                                      %.2d.

00000daa <__c.7355>:
     daa:	25 2e 32 64 00                                      %.2d.

00000daf <__c.7353>:
     daf:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     dbf:	45 78 69 74 00                                      Exit.

00000dc4 <__c.7351>:
     dc4:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     dd4:	53 61 76 65 00                                      Save.

00000dd9 <__c.7349>:
     dd9:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000de5 <__c.7347>:
     de5:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000df1 <__c.7313>:
     df1:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     e01:	67 65 20 00                                         ge .

00000e05 <__c.7311>:
     e05:	25 64 2e 25 73 00                                   %d.%s.

00000e0b <__c.7306>:
     e0b:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     e1b:	2d 00                                               -.

00000e1d <__c.7290>:
     e1d:	2a 29 45 78 69 74 00                                *)Exit.

00000e24 <__c.7288>:
     e24:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000e2e <__c.7286>:
     e2e:	31 29 49 44 00                                      1)ID.

00000e33 <__c.7271>:
     e33:	2a 29 45 78 69 74 00                                *)Exit.

00000e3a <__c.7266>:
     e3a:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     e4a:	2e 32 64 20 00                                      .2d .

00000e4f <__c.7257>:
     e4f:	25 2e 32 64 00                                      %.2d.

00000e54 <__c.7056>:
     e54:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000e5c <__c.7054>:
     e5c:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000e65 <__c.7052>:
     e65:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000e6e <__c.7050>:
     e6e:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000e7b <__c.7048>:
     e7b:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000e88 <__c.7046>:
     e88:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000e95 <__c.7044>:
     e95:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000ea2 <__c.6985>:
     ea2:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000eaf <__c.6980>:
     eaf:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000eb8 <__c.6978>:
     eb8:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     ec8:	20 20 20 20 00                                          .

00000ecd <__c.6973>:
     ecd:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000edb <__c.6971>:
     edb:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000ee6 <__c.6969>:
     ee6:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000ef1 <__c.6967>:
     ef1:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000efc <__c.6965>:
     efc:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000f07 <__c.6963>:
     f07:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     f17:	65 00                                               e.

00000f19 <__c.6961>:
     f19:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000f26 <__c.6959>:
     f26:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000f32 <__c.6912>:
     f32:	49 6e 76 61 6c 69 64 20 4f 6c 64 20 50 61 73 73     Invalid Old Pass
     f42:	77 6f 72 64 00                                      word.

00000f47 <__c.6910>:
     f47:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     f57:	20 20 20 20 00                                          .

00000f5c <__c.6908>:
     f5c:	49 6e 76 61 6c 69 64 20 4e 65 77 20 50 61 73 73     Invalid New Pass
     f6c:	77 6f 72 64 00                                      word.

00000f71 <__c.6906>:
     f71:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     f81:	20 20 20 20 00                                          .

00000f86 <__c.6904>:
     f86:	20 20 20 50 61 73 73 77 6f 72 64 20 53 61 76 65        Password Save
     f96:	64 20 20 20 00                                      d   .

00000f9b <__c.6902>:
     f9b:	20 20 20 20 20 43 6f 6d 70 6c 65 74 65 64 20 20          Completed  
     fab:	20 20 20 20 00                                          .

00000fb0 <__c.6898>:
     fb0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fc0:	6e 74 65 72 00                                      nter.

00000fc5 <__c.6895>:
     fc5:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     fd5:	6e 74 65 72 00                                      nter.

00000fda <__c.6892>:
     fda:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fea:	6e 74 65 72 00                                      nter.

00000fef <__c.6890>:
     fef:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     fff:	20 20 20 20 00                                          .

00001004 <__c.6886>:
    1004:	56 61 6c 69 64 61 74 69 6e 67 2e 2e 00              Validating...

00001011 <__c.6882>:
    1011:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1021:	6e 74 65 72 00                                      nter.

00001026 <__c.6879>:
    1026:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1036:	6e 74 65 72 00                                      nter.

0000103b <__c.6874>:
    103b:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    104b:	6e 74 65 72 00                                      nter.

00001050 <__c.6872>:
    1050:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
    1060:	20 20 20 20 00                                          .

00001065 <__c.6868>:
    1065:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1075:	6e 74 65 72 00                                      nter.

0000107a <__c.6865>:
    107a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    108a:	6e 74 65 72 00                                      nter.

0000108f <__c.6860>:
    108f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    109f:	6e 74 65 72 00                                      nter.

000010a4 <__c.6858>:
    10a4:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
    10b4:	20 20 20 20 00                                          .

000010b9 <__c.6854>:
    10b9:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    10c9:	6e 74 65 72 00                                      nter.

000010ce <__c.6852>:
    10ce:	4f 6c 64 3a 5f 00                                   Old:_.

000010d4 <__c.6850>:
    10d4:	2d 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 2d 00     -Administrator-.

000010e4 <__c.6848>:
    10e4:	2d 53 75 70 65 72 76 69 73 6f 72 2d 00              -Supervisor-.

000010f1 <__c.6840>:
    10f1:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

000010fe <__c.6838>:
    10fe:	32 2e 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 00     2.Administrator.

0000110e <__c.6836>:
    110e:	31 2e 53 75 70 65 72 76 69 73 6f 72 00              1.Supervisor.

0000111b <__c.6834>:
    111b:	2d 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72 64     -Change Password
    112b:	2d 00                                               -.

0000112d <__c.6831>:
    112d:	53 61 76 65 64 20 00                                Saved .

00001134 <__c.6825>:
    1134:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1144:	6e 74 65 72 00                                      nter.

00001149 <__c.6822>:
    1149:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1159:	6e 74 65 72 00                                      nter.

0000115e <__c.6817>:
    115e:	5b 2a 5d 4e 6f 20 20 20 20 5b 23 5d 59 65 73 00     [*]No    [#]Yes.

0000116e <__c.6815>:
    116e:	53 61 76 65 3f 00                                   Save?.

00001174 <__c.6813>:
    1174:	4e 65 77 20 4f 70 65 72 61 74 6f 72 3a 00           New Operator:.

00001182 <__c.6811>:
    1182:	25 73 00                                            %s.

00001185 <__c.6807>:
    1185:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1195:	6e 74 65 72 00                                      nter.

0000119a <__c.6805>:
    119a:	4e 65 77 20 3a 5f 20 20 20 20 20 20 20 20 20 20     New :_          
    11aa:	20 20 20 20 00                                          .

000011af <__c.6803>:
    11af:	4e 61 6d 65 3a 00                                   Name:.

000011b5 <__c.6801>:
    11b5:	25 73 00                                            %s.

000011b8 <__c.6792>:
    11b8:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    11c8:	20 00                                                .

000011ca <__c.6790>:
    11ca:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    11da:	64 00                                               d.

000011dc <__c.6788>:
    11dc:	31 2e 43 68 61 6e 67 65 20 4f 70 65 72 61 74 6f     1.Change Operato
    11ec:	72 00                                               r.

000011ee <__c.6706>:
    11ee:	2a 29 42 61 63 6b 00                                *)Back.

000011f5 <__c.6704>:
    11f5:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

00001204 <__c.6702>:
    1204:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

00001213 <__c.6700>:
    1213:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

00001222 <__c.6698>:
    1222:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 00        1.T.Volume:%d .

00001231 <__c.6693>:
    1231:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

00001242 <__c.6691>:
    1242:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

0000124e <__c.6689>:
    124e:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

0000125a <__c.6687>:
    125a:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

00001266 <__c.6670>:
    1266:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

00001276 <__c.6668>:
    1276:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

00001280 <__c.6666>:
    1280:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

0000128a <__c.6664>:
    128a:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

00001294 <__c.6624>:
    1294:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    12a4:	20 20 20 20 00                                          .

000012a9 <__c.6622>:
    12a9:	4e 65 77 3a 5f 00                                   New:_.

000012af <__c.6620>:
    12af:	4f 6c 64 3a 25 73 00                                Old:%s.

000012b6 <__c.6618>:
    12b6:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    12c6:	20 20 20 20 00                                          .

000012cb <__c.6616>:
    12cb:	4e 65 77 3a 5f 00                                   New:_.

000012d1 <__c.6614>:
    12d1:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    12e1:	65 20 20 20 00                                      e   .

000012e6 <__c.6612>:
    12e6:	4f 6c 64 3a 25 73 00                                Old:%s.

000012ed <__c.6609>:
    12ed:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

000012fb <__c.6607>:
    12fb:	32 29 25 73 00                                      2)%s.

00001300 <__c.6605>:
    1300:	31 29 25 73 00                                      1)%s.

00001305 <__c.6600>:
    1305:	2a 29 42 61 63 6b 00                                *)Back.

0000130c <__c.6595>:
    130c:	25 64 29 25 73 00                                   %d)%s.

00001312 <__c.6526>:
    1312:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    1322:	20 20 20 20 00                                          .

00001327 <__c.6524>:
    1327:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    1337:	20 20 20 20 00                                          .

0000133c <__c.6522>:
    133c:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    134c:	20 20 20 20 00                                          .

00001351 <__c.6520>:
    1351:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    1361:	20 20 20 20 00                                          .

00001366 <__c.6517>:
    1366:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    1376:	74 20 20 20 00                                      t   .

0000137b <__c.6515>:
    137b:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    138b:	74 20 20 20 00                                      t   .

00001390 <__c.6513>:
    1390:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    13a0:	74 20 20 20 00                                      t   .

000013a5 <__c.6511>:
    13a5:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    13b5:	6e 74 65 72 00                                      nter.

000013ba <__c.6426>:
    13ba:	2e 00                                               ..

000013bc <__c.6424>:
    13bc:	25 64 00                                            %d.

000013bf <__c.6422>:
    13bf:	20 20 20 00                                            .

000013c3 <__c.6420>:
    13c3:	2e 00                                               ..

000013c5 <__c.6418>:
    13c5:	25 64 00                                            %d.

000013c8 <__c.6416>:
    13c8:	20 20 20 00                                            .

000013cc <__c.6409>:
    13cc:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    13dc:	78 74 20 20 00                                      xt  .

000013e1 <__c.6407>:
    13e1:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    13f1:	2e 20 20 20 00                                      .   .

000013f6 <__c.6405>:
    13f6:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

00001407 <__c.6403>:
    1407:	53 65 72 76 65 72 20 49 50 00                       Server IP.

00001411 <__c.6314>:
    1411:	2e 00                                               ..

00001413 <__c.6312>:
    1413:	25 64 00                                            %d.

00001416 <__c.6310>:
    1416:	20 20 20 00                                            .

0000141a <__c.6308>:
    141a:	2e 00                                               ..

0000141c <__c.6306>:
    141c:	25 64 00                                            %d.

0000141f <__c.6304>:
    141f:	20 20 20 00                                            .

00001423 <__c.6297>:
    1423:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    1433:	78 74 20 20 00                                      xt  .

00001438 <__c.6295>:
    1438:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    1448:	2e 20 20 20 00                                      .   .

0000144d <__c.6293>:
    144d:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

0000145e <__c.6291>:
    145e:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

00001468 <__c.6249>:
    1468:	25 73 25 73 00                                      %s%s.

0000146d <__c.6245>:
    146d:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

0000147a <__c.6243>:
    147a:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

0000148a <__c.6239>:
    148a:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

00001498 <__c.6237>:
    1498:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

000014a6 <__c.6234>:
    14a6:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000014b5 <__c.6232>:
    14b5:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

000014c4 <__c.6228>:
    14c4:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    14d4:	20 20 20 20 00                                          .

000014d9 <__c.6226>:
    14d9:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    14e9:	20 20 20 20 00                                          .

000014ee <__c.6224>:
    14ee:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    14fe:	74 65 72 34 00                                      ter4.

00001503 <__c.6222>:
    1503:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    1513:	74 65 72 33 00                                      ter3.

00001518 <__c.6191>:
    1518:	25 73 25 73 00                                      %s%s.

0000151d <__c.6187>:
    151d:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

0000152a <__c.6185>:
    152a:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

0000153a <__c.6181>:
    153a:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

00001548 <__c.6179>:
    1548:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

00001556 <__c.6176>:
    1556:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

00001565 <__c.6174>:
    1565:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

00001574 <__c.6170>:
    1574:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1584:	20 20 20 20 00                                          .

00001589 <__c.6168>:
    1589:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    1599:	64 65 72 36 00                                      der6.

0000159e <__c.6166>:
    159e:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    15ae:	64 65 72 35 00                                      der5.

000015b3 <__c.6164>:
    15b3:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    15c3:	64 65 72 34 00                                      der4.

000015c8 <__c.6121>:
    15c8:	2a 29 45 78 69 74 00                                *)Exit.

000015cf <__c.6119>:
    15cf:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    15df:	20 20 20 20 00                                          .

000015e4 <__c.6117>:
    15e4:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    15f4:	20 20 20 20 00                                          .

000015f9 <__c.6115>:
    15f9:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    1609:	20 20 20 20 00                                          .

0000160e <__c.6113>:
    160e:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    161e:	72 76 65 72 00                                      rver.

00001623 <__c.6111>:
    1623:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    1633:	69 65 6e 74 00                                      ient.

00001638 <__c.6057>:
    1638:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    1648:	2e 2e 20 00                                         .. .

0000164c <__c.6052>:
    164c:	25 73 20 25 73 00                                   %s %s.

00001652 <__c.6050>:
    1652:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    1662:	65 72 00                                            er.

00001665 <__c.6046>:
    1665:	43 61 6e 63 65 6c 00                                Cancel.

0000166c <__c.6041>:
    166c:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    167c:	25 64 20 00                                         %d .

00001680 <__c.6036>:
    1680:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

0000168e <__c.6032>:
    168e:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

0000169c <__c.6030>:
    169c:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

000016a8 <__c.5958>:
    16a8:	2a 29 45 78 69 74 00                                *)Exit.

000016af <__c.5956>:
    16af:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

000016bd <__c.5954>:
    16bd:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

000016cb <__c.5952>:
    16cb:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

000016d9 <__c.5910>:
    16d9:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    16e9:	78 69 74 20 00                                      xit .

000016ee <__c.5908>:
    16ee:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    16fe:	20 20 20 20 00                                          .

00001703 <__c.5906>:
    1703:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    1713:	20 20 20 20 00                                          .

00001718 <__c.5904>:
    1718:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    1728:	20 20 20 20 00                                          .

0000172d <__c.5874>:
    172d:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    173d:	64 00                                               d.

0000173f <__c.5870>:
    173f:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    174f:	20 00                                                .

00001751 <__c.5867>:
    1751:	30 30 30 30 30 00                                   00000.

00001757 <__c.5865>:
    1757:	31 31 31 31 31 00                                   11111.

0000175d <__c.5861>:
    175d:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    176d:	6e 74 65 72 00                                      nter.

00001772 <__c.5858>:
    1772:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1782:	6e 74 65 72 00                                      nter.

00001787 <__c.5851>:
    1787:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1797:	6e 74 65 72 00                                      nter.

0000179c <__c.5849>:
    179c:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    17ac:	20 20 20 20 00                                          .

000017b1 <__c.5847>:
    17b1:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    17c1:	64 65 20 20 00                                      de  .

000017c6 <__c.5845>:
    17c6:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

000017d4 <__c.5841>:
    17d4:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    17e4:	20 20 20 20 00                                          .

000017e9 <__c.5838>:
	...

000017ea <__c.5836>:
    17ea:	25 73 00                                            %s.

000017ed <__c.5834>:
    17ed:	25 73 00                                            %s.

000017f0 <__c.5831>:
    17f0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1800:	6e 74 65 72 00                                      nter.

00001805 <__c.5828>:
    1805:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1815:	6e 74 65 72 00                                      nter.

0000181a <__c.5821>:
	...

0000181b <__c.5819>:
    181b:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    182b:	6e 74 65 72 00                                      nter.

00001830 <__c.5817>:
    1830:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    1840:	20 20 20 20 00                                          .

00001845 <__c.5815>:
    1845:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    1855:	65 20 20 20 00                                      e   .

0000185a <__c.5805>:
    185a:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    186a:	20 20 20 20 00                                          .

0000186f <__c.5803>:
    186f:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    187f:	64 20 20 20 00                                      d   .

00001884 <__c.5801>:
    1884:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    1894:	72 64 20 20 00                                      rd  .

00001899 <__c.5799>:
    1899:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    18a9:	76 65 6c 2d 00                                      vel-.

000018ae <__c.5740>:
    18ae:	25 73 25 73 00                                      %s%s.

000018b3 <__c.5712>:
    18b3:	25 73 00                                            %s.

000018b6 <__c.5679>:
    18b6:	25 63 00                                            %c.

000018b9 <__c.5677>:
    18b9:	32 30 25 73 00                                      20%s.

000018be <__c.5655>:
    18be:	25 73 00                                            %s.

000018c1 <__c.5607>:
    18c1:	34 32 36 34 36 33 36 00                             4264636.

000018c9 <__c.5604>:
    18c9:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18d9:	6e 74 65 72 00                                      nter.

000018de <__c.5602>:
    18de:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    18ee:	6e 74 65 72 00                                      nter.

000018f3 <__c.5598>:
    18f3:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1903:	6e 74 65 72 00                                      nter.

00001908 <__c.5596>:
    1908:	5f 00                                               _.

0000190a <__c.5594>:
    190a:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001914 <__c.5566>:
    1914:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001922 <__c.5493>:
    1922:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

0000192f <__c.5491>:
    192f:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

0000193c <__c.5487>:
    193c:	20 20 20 20 20 20 20 00                                    .

00001944 <__c.5484>:
    1944:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

00001950 <__c.5481>:
    1950:	25 73 00                                            %s.

00001953 <__c.5479>:
    1953:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

0000195d <__c.5476>:
    195d:	25 73 00                                            %s.

00001960 <__c.5473>:
    1960:	25 73 00                                            %s.

00001963 <__c.5471>:
    1963:	25 73 00                                            %s.

00001966 <__c.5469>:
    1966:	25 73 00                                            %s.

00001969 <__c.5465>:
    1969:	25 73 00                                            %s.

0000196c <__c.5461>:
    196c:	50 72 6f 73 65 73 00                                Proses.

00001973 <__c.5459>:
    1973:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

00001981 <__c.5456>:
    1981:	50 72 6f 73 65 73 00                                Proses.

00001988 <__c.5454>:
    1988:	49 44 3a 25 73 00                                   ID:%s.

0000198e <__c.5450>:
    198e:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    199e:	69 74 00                                            it.

000019a1 <__c.5448>:
    19a1:	46 49 50 25 73 00                                   FIP%s.

000019a7 <__c.5446>:
    19a7:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

000019b6 <__c.5437>:
    19b6:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    19c6:	6e 74 65 72 00                                      nter.

000019cb <__c.5435>:
    19cb:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    19db:	6e 74 65 72 00                                      nter.

000019e0 <__c.5432>:
    19e0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    19f0:	6e 74 65 72 00                                      nter.

000019f5 <__c.5430>:
    19f5:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

00001a05 <__c.5428>:
    1a05:	25 73 00                                            %s.

00001a08 <__c.5424>:
    1a08:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

00001a10 <__c.5419>:
    1a10:	25 64 2e 25 73 00                                   %d.%s.

00001a16 <__c.5417>:
    1a16:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

00001a22 <__c.5412>:
    1a22:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1a32:	6e 74 65 72 00                                      nter.

00001a37 <__c.5410>:
    1a37:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1a47:	6e 74 65 72 00                                      nter.

00001a4c <__c.5407>:
    1a4c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1a5c:	6e 74 65 72 00                                      nter.

00001a61 <__c.5405>:
    1a61:	5f 00                                               _.

00001a63 <__c.5403>:
    1a63:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

00001a70 <__c.5394>:
    1a70:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1a80:	20 20 20 20 00                                          .

00001a85 <__c.5392>:
    1a85:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    1a95:	54 65 73 74 00                                      Test.

00001a9a <__c.5390>:
    1a9a:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    1aaa:	68 65 72 20 00                                      her .

00001aaf <__c.5388>:
    1aaf:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    1abf:	74 20 20 20 00                                      t   .

00001ac4 <__c.5339>:
    1ac4:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

00001acf <__c.5333>:
    1acf:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1adf:	20 20 20 20 00                                          .

00001ae4 <__c.5331>:
    1ae4:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    1af4:	20 20 20 20 00                                          .

00001af9 <__c.5329>:
    1af9:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    1b09:	72 64 20 20 00                                      rd  .

00001b0e <__c.5327>:
    1b0e:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

00001b1f <__c.5294>:
    1b1f:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001b2d <__c.5292>:
    1b2d:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001b3b <__c.5285>:
    1b3b:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

00001b49 <__c.5283>:
    1b49:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

00001b53 <__c.5281>:
    1b53:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

00001b5d <__c.5279>:
    1b5d:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

00001b67 <__c.5277>:
    1b67:	25 73 3a 25 73 00                                   %s:%s.

00001b6d <__c.5270>:
    1b6d:	50 72 6f 73 65 73 00                                Proses.

00001b74 <__c.5268>:
    1b74:	49 44 3a 25 73 00                                   ID:%s.

00001b7a <__c.5264>:
    1b7a:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1b8a:	69 74 00                                            it.

00001b8d <__c.5262>:
    1b8d:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001b9c <__c.5259>:
    1b9c:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1bac:	69 74 00                                            it.

00001baf <__c.5257>:
    1baf:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001bbe <__c.5255>:
    1bbe:	46 49 50 3a 25 73 00                                FIP:%s.

00001bc5 <__c.5249>:
    1bc5:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1bd5:	20 00                                                .

00001bd7 <__c.5247>:
    1bd7:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1be7:	20 00                                                .

00001be9 <__c.5245>:
    1be9:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1bf9:	20 00                                                .

00001bfb <__c.5243>:
    1bfb:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1c0b:	20 00                                                .

00001c0d <__c.5208>:
    1c0d:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001c1b <__c.5206>:
    1c1b:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001c29 <__c.5200>:
    1c29:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1c39:	69 74 00                                            it.

00001c3c <__c.5198>:
    1c3c:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1c4c:	61 72 64 00                                         ard.

00001c50 <__c.5196>:
    1c50:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001c60 <__c.5192>:
    1c60:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1c70:	6b 73 69 20 00                                      ksi .

00001c75 <__c.5186>:
    1c75:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001c83 <__c.5143>:
    1c83:	25 2e 32 64 00                                      %.2d.

00001c88 <__c.5139>:
    1c88:	2a 29 45 78 69 74 00                                *)Exit.

00001c8f <__c.5137>:
    1c8f:	23 29 4f 4b 20 00                                   #)OK .

00001c95 <__c.5135>:
    1c95:	20 20 20 20 20 00                                        .

00001c9b <__c.5133>:
    1c9b:	46 49 50 3a 5f 00                                   FIP:_.

00001ca1 <__c.5128>:
    1ca1:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001cb1 <__c.5079>:
    1cb1:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001cc2 <__c.4936>:
    1cc2:	30 00                                               0.

00001cc4 <__c.4867>:
    1cc4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1cd4:	20 20 20 20 00                                          .

00001cd9 <__c.4862>:
    1cd9:	23 25 73 00                                         #%s.

00001cdd <__c.4860>:
    1cdd:	25 2e 32 64 00                                      %.2d.

00001ce2 <__c.4858>:
    1ce2:	40 46 49 50 3a 00                                   @FIP:.

00001ce8 <__c.4856>:
    1ce8:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1cf8:	20 20 20 20 00                                          .

00001cfd <__c.4852>:
    1cfd:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001d0d <__c.4828>:
    1d0d:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001d19 <__c.4817>:
    1d19:	25 73 20 25 73 00                                   %s %s.

00001d1f <__c.4789>:
    1d1f:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001d2d <__c.4787>:
    1d2d:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001d3a <__c.4785>:
    1d3a:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001d44 <__c.4783>:
    1d44:	43 6f 6e 6e 65 63 74 65 64 20 20 20 20 20 20 20     Connected       
    1d54:	20 20 20 20 00                                          .

00001d59 <__c.4778>:
    1d59:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1d69:	20 20 20 00                                            .

00001d6d <__c.4776>:
    1d6d:	25 73 00                                            %s.

00001d70 <__c.4771>:
    1d70:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001d7a <__c.4766>:
    1d7a:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001d8b <__c.4764>:
    1d8b:	43 6f 6e 6e 65 63 74 00                             Connect.

00001d93 <__c.4762>:
    1d93:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001da4 <__c.4734>:
    1da4:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1db4:	20 20 20 00                                            .

00001db8 <__c.4732>:
    1db8:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1dc8:	2e 2e 00                                            ...

00001dcb <__c.4693>:
    1dcb:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1ddb:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1deb:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1dfb:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1e0b:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1e1b:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1e2b:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1e3b:	0a 00                                               ..

00001e3d <__c.4691>:
    1e3d:	32 34 2f 30 32 2f 32 30 31 31 00                    24/02/2011.

00001e48 <__c.4689>:
    1e48:	32 2e 33 37 46 00                                   2.37F.

00001e4e <__c.4595>:
    1e4e:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001e5f <__c.4593>:
    1e5f:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1e6f:	69 00                                               i.

00001e71 <__c.4589>:
    1e71:	49 44 3a 20 25 73 00                                ID: %s.

00001e78 <__c.4587>:
    1e78:	25 73 00                                            %s.

00001e7b <__c.4585>:
    1e7b:	50 25 73 20 25 73 20 00                             P%s %s .

00001e83 <__c.4581>:
    1e83:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1e93:	20 20 00                                              .

00001e96 <__c.4578>:
    1e96:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1ea6:	61 73 69 6c 00                                      asil.

00001eab <__c.4574>:
    1eab:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1ebb:	6c 20 20 20 00                                      l   .

00001ec0 <__c.4570>:
    1ec0:	20 20 20 20 20 20 20 00                                    .

00001ec8 <__c.4567>:
    1ec8:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1ed8:	20 20 20 20 00                                          .

00001edd <__c.4565>:
    1edd:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1eed:	20 20 20 20 00                                          .

00001ef2 <__c.4563>:
    1ef2:	25 73 00                                            %s.

00001ef5 <__c.4561>:
    1ef5:	50 25 73 20 25 73 20 00                             P%s %s .

00001efd <__c.4558>:
    1efd:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1f0d:	6f 6e 20 20 00                                      on  .

00001f12 <__c.4555>:
    1f12:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1f22:	23 5d 4f 4b 00                                      #]OK.

00001f27 <__c.4553>:
    1f27:	25 73 20 00                                         %s .

00001f2b <__c.4551>:
    1f2b:	20 46 75 6c 6c 00                                    Full.

00001f31 <__c.4549>:
    1f31:	25 73 20 20 25 73 20 00                             %s  %s .

00001f39 <__c.4547>:
    1f39:	49 44 3a 20 25 73 00                                ID: %s.

00001f40 <__c.4545>:
    1f40:	25 73 20 00                                         %s .

00001f44 <__c.4541>:
    1f44:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1f54:	20 00                                                .

00001f56 <__c.4539>:
    1f56:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1f66:	20 00                                                .

00001f68 <__c.4537>:
    1f68:	25 73 20 00                                         %s .

00001f6c <__c.4535>:
    1f6c:	20 20 25 73 20 25 73 20 00                            %s %s .

00001f75 <__c.4533>:
    1f75:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1f85:	75 6e 74 00                                         unt.

00001f89 <__c.4531>:
    1f89:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1f99:	75 6d 65 00                                         ume.

00001f9d <__c.4529>:
    1f9d:	20 20 54 61 6e 6b 00                                  Tank.

00001fa4 <__c.4527>:
    1fa4:	20 20 25 73 20 25 73 20 00                            %s %s .

00001fad <__c.4525>:
    1fad:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1fbd:	75 6c 6c 00                                         ull.

00001fc1 <__c.4521>:
    1fc1:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1fd1:	20 20 20 20 00                                          .

00001fd6 <__c.4519>:
    1fd6:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1fe6:	20 20 20 20 00                                          .

00001feb <__c.4517>:
    1feb:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1ffb:	20 20 20 20 00                                          .

00002000 <__c.4515>:
    2000:	50 25 73 2d 25 73 20 00                             P%s-%s .

00002008 <__c.4513>:
    2008:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    2018:	20 20 20 20 00                                          .

0000201d <__c.4511>:
    201d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    202d:	20 20 20 20 00                                          .

00002032 <__c.4509>:
    2032:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    2042:	20 20 20 20 00                                          .

00002047 <__c.4507>:
    2047:	50 25 73 2d 25 73 20 00                             P%s-%s .

0000204f <__c.4504>:
    204f:	41 00                                               A.

00002051 <__c.4502>:
    2051:	41 00                                               A.

00002053 <__c.4500>:
    2053:	56 00                                               V.

00002055 <__c.4497>:
    2055:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    2065:	78 74 20 20 00                                      xt  .

0000206a <__c.4495>:
    206a:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    207a:	20 20 20 20 00                                          .

0000207f <__c.4493>:
    207f:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    208f:	20 20 20 20 00                                          .

00002094 <__c.4491>:
    2094:	50 25 73 2d 25 73 20 00                             P%s-%s .

0000209c <__c.4488>:
    209c:	25 73 00                                            %s.

0000209f <__c.4485>:
    209f:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    20af:	20 20 20 20 00                                          .

000020b4 <__c.4480>:
    20b4:	20 20 20 20 20 00                                        .

000020ba <__c.4478>:
    20ba:	25 64 2e 25 73 00                                   %d.%s.

000020c0 <__c.4476>:
    20c0:	25 73 00                                            %s.

000020c3 <__c.4474>:
    20c3:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

000020cc <__c.4470>:
    20cc:	25 2e 32 64 00                                      %.2d.

000020d1 <__c.4468>:
    20d1:	25 2e 32 64 00                                      %.2d.

000020d6 <__c.4464>:
    20d6:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    20e6:	23 5d 4f 4b 00                                      #]OK.

000020eb <__c.4462>:
    20eb:	25 73 20 25 73 00                                   %s %s.

000020f1 <__c.4460>:
    20f1:	25 73 00                                            %s.

000020f4 <__c.4458>:
    20f4:	25 73 00                                            %s.

000020f7 <__c.4456>:
    20f7:	25 73 00                                            %s.

000020fa <__c.4453>:
    20fa:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    210a:	20 20 20 20 00                                          .

0000210f <__c.4451>:
    210f:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    211f:	20 20 20 20 00                                          .

00002124 <__c.4448>:
    2124:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    2134:	20 20 20 20 00                                          .

00002139 <__c.4445>:
    2139:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    2149:	20 20 20 20 00                                          .

0000214e <__c.4443>:
    214e:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    215e:	20 20 20 20 00                                          .

00002163 <__c.4440>:
    2163:	20 20 20 20 20 20 20 00                                    .

0000216b <__c.4435>:
    216b:	50 72 6f 73 65 73 00                                Proses.

00002172 <__c.4433>:
    2172:	49 44 3a 25 73 00                                   ID:%s.

00002178 <__c.4431>:
    2178:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    2188:	20 20 20 00                                            .

0000218c <__c.4267>:
    218c:	25 2e 32 64 00                                      %.2d.

00002191 <__c.4219>:
    2191:	46 39 36 38 43 46 46 42 00                          F968CFFB.

0000219a <__c.4217>:
    219a:	25 73 00                                            %s.

0000219d <__c.4214>:
    219d:	25 73 25 73 25 73 00                                %s%s%s.

000021a4 <__c.4212>:
    21a4:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000021ad <__c.4209>:
    21ad:	25 73 25 73 00                                      %s%s.

000021b2 <__c.4206>:
    21b2:	25 73 00                                            %s.

000021b5 <__c.4204>:
    21b5:	46 30 30 30 30 30 30 30 45 31 32 33 34 35 36 46     F0000000E123456F
    21c5:	46 46 46 46 00                                      FFFF.

000021ca <__c.4202>:
    21ca:	25 73 25 73 25 64 00                                %s%s%d.

000021d1 <__c.4200>:
    21d1:	25 73 25 73 25 64 00                                %s%s%d.

000021d8 <__c.4197>:
    21d8:	25 73 00                                            %s.

000021db <__c.4194>:
    21db:	25 73 25 73 00                                      %s%s.

000021e0 <__c.4192>:
    21e0:	25 73 25 73 00                                      %s%s.

000021e5 <__c.4190>:
    21e5:	25 73 25 73 00                                      %s%s.

000021ea <__c.4187>:
    21ea:	25 73 25 73 00                                      %s%s.

000021ef <__c.4184>:
    21ef:	25 73 25 73 00                                      %s%s.

000021f4 <__c.4181>:
    21f4:	25 73 00                                            %s.

000021f7 <__c.4176>:
    21f7:	25 73 00                                            %s.

000021fa <__c.4173>:
    21fa:	25 2e 32 58 00                                      %.2X.

000021ff <__c.4171>:
    21ff:	25 2e 33 64 2e 25 2e 33 64 2e 25 2e 33 64 2e 25     %.3d.%.3d.%.3d.%
    220f:	2e 33 64 00                                         .3d.

00002213 <__c.4169>:
    2213:	25 2e 33 64 2e 25 2e 33 64 2e 25 2e 33 64 2e 25     %.3d.%.3d.%.3d.%
    2223:	2e 33 64 00                                         .3d.

00002227 <__c.4167>:
    2227:	25 2e 32 64 00                                      %.2d.

0000222c <__c.4165>:
    222c:	25 2e 32 64 00                                      %.2d.

00002231 <__c.4077>:
    2231:	25 73 20 25 73 00                                   %s %s.

00002237 <__c.4075>:
    2237:	32 2e 33 37 46 00                                   2.37F.

0000223d <__c.4073>:
    223d:	47 65 4e 69 55 73 00                                GeNiUs.

00002244 <__c.4059>:
    2244:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    2254:	20 20 20 20 00                                          .

00002259 <__c.4047>:
    2259:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    2269:	64 61 6c 6f 6e 65 00                                dalone.

00002270 <__c.3967>:
    2270:	3e 00                                               >.

00002272 <__c.3962>:
    2272:	25 2e 32 64 00                                      %.2d.

00002277 <__c.3960>:
    2277:	25 2e 32 64 00                                      %.2d.

0000227c <__c.3958>:
    227c:	30 00                                               0.

0000227e <__c.3956>:
    227e:	31 00                                               1.

00002280 <__c.3948>:
    2280:	25 64 00                                            %d.

00002283 <__c.3943>:
    2283:	25 2e 32 64 00                                      %.2d.

00002288 <__c.3938>:
    2288:	25 73 00                                            %s.

0000228b <__c.3933>:
    228b:	25 73 00                                            %s.

0000228e <__c.3928>:
    228e:	25 73 00                                            %s.

00002291 <__c.3926>:
    2291:	3c 00                                               <.

00002293 <__c.3858>:
    2293:	3c 4f 4b 3e 00                                      <OK>.

00002298 <__c.3853>:
    2298:	25 64 00                                            %d.

0000229b <__c.3851>:
    229b:	25 64 00                                            %d.

0000229e <__c.3840>:
    229e:	25 64 00                                            %d.

000022a1 <__c.3829>:
    22a1:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

000022aa <__c.3827>:
    22aa:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

000022b4 <__c.3643>:
    22b4:	25 73 00                                            %s.

000022b7 <__c.3585>:
    22b7:	25 73 00                                            %s.

000022ba <__c.3583>:
    22ba:	25 73 00                                            %s.

000022bd <__c.3581>:
    22bd:	25 73 00                                            %s.

000022c0 <__c.3579>:
    22c0:	25 73 00                                            %s.

000022c3 <__c.3577>:
    22c3:	25 2e 32 64 00                                      %.2d.

000022c8 <__c.3575>:
    22c8:	25 64 00                                            %d.

000022cb <__c.3573>:
    22cb:	25 73 00                                            %s.

000022ce <__c.3571>:
    22ce:	25 73 00                                            %s.

000022d1 <__c.3569>:
    22d1:	25 73 00                                            %s.

000022d4 <__c.3567>:
    22d4:	25 64 00                                            %d.

000022d7 <__c.3565>:
    22d7:	4e 2f 41 00                                         N/A.

000022db <__c.3466>:
    22db:	25 64 00                                            %d.

000022de <__c.3464>:
    22de:	25 73 00                                            %s.

000022e1 <__c.3462>:
    22e1:	25 73 00                                            %s.

000022e4 <__c.3379>:
    22e4:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    22f4:	6b 73 69 20 00                                      ksi .

000022f9 <__c.3376>:
    22f9:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    2309:	20 00                                                .

0000230b <__c.3373>:
    230b:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    231b:	69 7a 65 72 00                                      izer.

00002320 <__c.3361>:
    2320:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00002331 <__c.3358>:
    2331:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2341:	20 20 20 20 00                                          .

00002346 <__c.3355>:
    2346:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2356:	20 20 20 20 00                                          .

0000235b <__c.3353>:
    235b:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    236b:	20 20 20 20 00                                          .

00002370 <__c.3350>:
    2370:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    2380:	20 20 20 20 00                                          .

00002385 <__c.3347>:
    2385:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2395:	20 20 20 20 00                                          .

0000239a <__c.3344>:
    239a:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    23aa:	6b 73 69 20 00                                      ksi .

000023af <__c.3339>:
    23af:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

000023bc <__c.3336>:
    23bc:	34 33 35 36 41 33 31 41 00                          4356A31A.

000023c5 <__c.1750>:
    23c5:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23d5:	20 20 20 20 00                                          .

000023da <__c.1748>:
    23da:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23ea:	20 20 20 20 00                                          .

000023ef <__c.1746>:
    23ef:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23ff:	20 20 20 20 00                                          .

00002404 <__c.1744>:
    2404:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2414:	20 20 20 20 00                                          .

00002419 <__alphanum>:
    2419:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    2429:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    2439:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    2449:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    2459:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    2469:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    2479:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    2489:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

00002491 <__maxchar>:
    2491:	02 04 03 03 03 03 03 04 03 04                       ..........

0000249b <__c.1891>:
    249b:	4d 4d 43 20 57 72 69 74 65 20 46 61 69 6c 65 64     MMC Write Failed
	...

000024ac <__c.1888>:
    24ac:	57 72 69 74 65 20 53 75 63 65 73 73 66 75 6c 6c     Write Sucessfull
	...

000024bd <__c.1874>:
    24bd:	43 6d 64 20 52 65 73 70 6f 6e 73 65 20 4f 4b 00     Cmd Response OK.

000024cd <__c.1872>:
    24cd:	53 50 44 52 3d 25 2e 32 58 00                       SPDR=%.2X.

000024d7 <__c.1867>:
    24d7:	2d 6d 6d 63 5f 77 72 69 74 65 2d 00                 -mmc_write-.

000024e3 <__c.1830>:
    24e3:	52 65 61 64 20 52 65 73 70 6f 6e 73 65 20 46 61     Read Response Fa
    24f3:	69 6c 65 64 00                                      iled.

000024f8 <__c.1827>:
    24f8:	52 65 61 64 20 52 65 73 70 6f 6e 73 65 20 4f 4b     Read Response OK
	...

0000250a <__ctors_end>:
    250a:	11 24       	eor	r1, r1
    250c:	1f be       	out	0x3f, r1	; 63
    250e:	cf ef       	ldi	r28, 0xFF	; 255
    2510:	d0 e1       	ldi	r29, 0x10	; 16
    2512:	de bf       	out	0x3e, r29	; 62
    2514:	cd bf       	out	0x3d, r28	; 61

00002516 <__do_copy_data>:
    2516:	11 e0       	ldi	r17, 0x01	; 1
    2518:	a0 e0       	ldi	r26, 0x00	; 0
    251a:	b1 e0       	ldi	r27, 0x01	; 1
    251c:	ee e2       	ldi	r30, 0x2E	; 46
    251e:	f9 e6       	ldi	r31, 0x69	; 105
    2520:	01 e0       	ldi	r16, 0x01	; 1
    2522:	0b bf       	out	0x3b, r16	; 59
    2524:	02 c0       	rjmp	.+4      	; 0x252a <__do_copy_data+0x14>
    2526:	07 90       	elpm	r0, Z+
    2528:	0d 92       	st	X+, r0
    252a:	ae 34       	cpi	r26, 0x4E	; 78
    252c:	b1 07       	cpc	r27, r17
    252e:	d9 f7       	brne	.-10     	; 0x2526 <__do_copy_data+0x10>

00002530 <__do_clear_bss>:
    2530:	1e e0       	ldi	r17, 0x0E	; 14
    2532:	ae e4       	ldi	r26, 0x4E	; 78
    2534:	b1 e0       	ldi	r27, 0x01	; 1
    2536:	01 c0       	rjmp	.+2      	; 0x253a <.do_clear_bss_start>

00002538 <.do_clear_bss_loop>:
    2538:	1d 92       	st	X+, r1

0000253a <.do_clear_bss_start>:
    253a:	ac 3c       	cpi	r26, 0xCC	; 204
    253c:	b1 07       	cpc	r27, r17
    253e:	e1 f7       	brne	.-8      	; 0x2538 <.do_clear_bss_loop>
    2540:	0e 94 3d 13 	call	0x267a	; 0x267a <main>
    2544:	0c 94 95 b4 	jmp	0x1692a	; 0x1692a <_exit>

00002548 <__bad_interrupt>:
    2548:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000254c <systemOnReset>:
	};
}


void systemOnReset(){
     IsPowerOn=False;
    254c:	10 92 c3 02 	sts	0x02C3, r1
     if (MCUCSR & 1){   // Power-on Reset
    2550:	04 b6       	in	r0, 0x34	; 52
    2552:	00 fe       	sbrs	r0, 0
    2554:	0b c0       	rjmp	.+22     	; 0x256c <systemOnReset+0x20>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));//Wiznet Blm Ready
    2556:	14 be       	out	0x34, r1	; 52
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	61 e0       	ldi	r22, 0x01	; 1
    255c:	46 e9       	ldi	r20, 0x96	; 150
    255e:	52 e0       	ldi	r21, 0x02	; 2
    2560:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		 IsPowerOn=True;
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	80 93 c3 02 	sts	0x02C3, r24
    256a:	18 c0       	rjmp	.+48     	; 0x259c <systemOnReset+0x50>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    256c:	04 b6       	in	r0, 0x34	; 52
    256e:	01 fe       	sbrs	r0, 1
    2570:	06 c0       	rjmp	.+12     	; 0x257e <systemOnReset+0x32>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    2572:	14 be       	out	0x34, r1	; 52
    2574:	81 e0       	ldi	r24, 0x01	; 1
    2576:	61 e0       	ldi	r22, 0x01	; 1
    2578:	4d e8       	ldi	r20, 0x8D	; 141
    257a:	52 e0       	ldi	r21, 0x02	; 2
    257c:	0d c0       	rjmp	.+26     	; 0x2598 <systemOnReset+0x4c>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    257e:	04 b6       	in	r0, 0x34	; 52
    2580:	02 fe       	sbrs	r0, 2
    2582:	06 c0       	rjmp	.+12     	; 0x2590 <systemOnReset+0x44>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    2584:	14 be       	out	0x34, r1	; 52
    2586:	81 e0       	ldi	r24, 0x01	; 1
    2588:	61 e0       	ldi	r22, 0x01	; 1
    258a:	44 e8       	ldi	r20, 0x84	; 132
    258c:	52 e0       	ldi	r21, 0x02	; 2
    258e:	04 c0       	rjmp	.+8      	; 0x2598 <systemOnReset+0x4c>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    2590:	81 e0       	ldi	r24, 0x01	; 1
    2592:	61 e0       	ldi	r22, 0x01	; 1
    2594:	4b e7       	ldi	r20, 0x7B	; 123
    2596:	52 e0       	ldi	r21, 0x02	; 2
    2598:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
        };
     MCUCSR=0;		  
    259c:	14 be       	out	0x34, r1	; 52
    259e:	80 ee       	ldi	r24, 0xE0	; 224
    25a0:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    25a2:	20 e7       	ldi	r18, 0x70	; 112
    25a4:	31 e0       	ldi	r19, 0x01	; 1
    25a6:	f9 01       	movw	r30, r18
    25a8:	31 97       	sbiw	r30, 0x01	; 1
    25aa:	f1 f7       	brne	.-4      	; 0x25a8 <systemOnReset+0x5c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25ac:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25ae:	d9 f7       	brne	.-10     	; 0x25a6 <systemOnReset+0x5a>
	 _delay_ms(1200);
}
    25b0:	08 95       	ret

000025b2 <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    25b2:	0e 94 c7 a6 	call	0x14d8e	; 0x14d8e <lcd_init>
	lcd_clear();
    25b6:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	BackLightTrig();
    25ba:	0e 94 34 16 	call	0x2c68	; 0x2c68 <BackLightTrig>
	systemOnReset();
    25be:	0e 94 a6 12 	call	0x254c	; 0x254c <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    25c2:	84 e0       	ldi	r24, 0x04	; 4
    25c4:	61 e0       	ldi	r22, 0x01	; 1
    25c6:	4c e6       	ldi	r20, 0x6C	; 108
    25c8:	52 e0       	ldi	r21, 0x02	; 2
    25ca:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    25ce:	88 eb       	ldi	r24, 0xB8	; 184
    25d0:	9b e0       	ldi	r25, 0x0B	; 11
    25d2:	20 e7       	ldi	r18, 0x70	; 112
    25d4:	31 e0       	ldi	r19, 0x01	; 1
    25d6:	f9 01       	movw	r30, r18
    25d8:	31 97       	sbiw	r30, 0x01	; 1
    25da:	f1 f7       	brne	.-4      	; 0x25d8 <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25dc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25de:	d9 f7       	brne	.-10     	; 0x25d6 <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    25e0:	9f ef       	ldi	r25, 0xFF	; 255
    25e2:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    25e4:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    25e6:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    25e8:	98 bb       	out	0x18, r25	; 24
    25ea:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    25ec:	8d e0       	ldi	r24, 0x0D	; 13
    25ee:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    25f0:	89 e0       	ldi	r24, 0x09	; 9
    25f2:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    25f4:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    25f8:	8e e0       	ldi	r24, 0x0E	; 14
    25fa:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    25fc:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    25fe:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    2600:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    2602:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    2606:	80 ef       	ldi	r24, 0xF0	; 240
    2608:	80 93 61 00 	sts	0x0061, r24

  	spi_init(0,1);//Slave
    260c:	80 e0       	ldi	r24, 0x00	; 0
    260e:	61 e0       	ldi	r22, 0x01	; 1
    2610:	0e 94 bf a9 	call	0x1537e	; 0x1537e <spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    2614:	bb 9a       	sbi	0x17, 3	; 23
    2616:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    2618:	ba 98       	cbi	0x17, 2	; 23
    261a:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    261c:	b9 98       	cbi	0x17, 1	; 23
    261e:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    2620:	8e b5       	in	r24, 0x2e	; 46
    2622:	88 60       	ori	r24, 0x08	; 8
    2624:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    2626:	87 b7       	in	r24, 0x37	; 55
    2628:	80 61       	ori	r24, 0x10	; 16
    262a:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    262c:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    262e:	88 e0       	ldi	r24, 0x08	; 8
    2630:	9d e3       	ldi	r25, 0x3D	; 61
    2632:	9b bd       	out	0x2b, r25	; 43
    2634:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    2636:	8e b5       	in	r24, 0x2e	; 46
    2638:	83 60       	ori	r24, 0x03	; 3
    263a:	8e bd       	out	0x2e, r24	; 46

	SendSlaveCommand(SC_SLAVE,ST_NONE);
    263c:	81 e0       	ldi	r24, 0x01	; 1
    263e:	60 e0       	ldi	r22, 0x00	; 0
    2640:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
	
	InitComport();
    2644:	0e 94 17 a6 	call	0x14c2e	; 0x14c2e <InitComport>
	_LIGHT_SET;
    2648:	81 e0       	ldi	r24, 0x01	; 1
    264a:	80 93 b7 02 	sts	0x02B7, r24
    264e:	10 92 b8 02 	sts	0x02B8, r1
    2652:	80 91 65 00 	lds	r24, 0x0065
    2656:	8d 7f       	andi	r24, 0xFD	; 253
    2658:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    265c:	0e 94 27 4c 	call	0x984e	; 0x984e <InitPrinter>
    //InitializeConnection();
	lcd_clear(); 
    2660:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>


	spi_init(1, 0);         //Master
    2664:	81 e0       	ldi	r24, 0x01	; 1
    2666:	60 e0       	ldi	r22, 0x00	; 0
    2668:	0e 94 bf a9 	call	0x1537e	; 0x1537e <spi_init>
    spi_enable(SPI_MMC); //Enable SS 
    266c:	82 e0       	ldi	r24, 0x02	; 2
    266e:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    2672:	bb 98       	cbi	0x17, 3	; 23
    2674:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    2676:	ba 9a       	sbi	0x17, 2	; 23


}
    2678:	08 95       	ret

0000267a <main>:

//Master4 =1+20++2+1
void SystemInit();
//Program Utama
int main(){
	SystemInit();
    267a:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <SystemInit>
	while(1){
	FTestMMC();
    267e:	0e 94 df 1c 	call	0x39be	; 0x39be <FTestMMC>
    2682:	fd cf       	rjmp	.-6      	; 0x267e <main+0x4>

00002684 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    2684:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    2686:	e1 99       	sbic	0x1c, 1	; 28
    2688:	fe cf       	rjmp	.-4      	; 0x2686 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    268a:	3f bb       	out	0x1f, r19	; 31
    268c:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    268e:	e0 9a       	sbi	0x1c, 0	; 28
    2690:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    2692:	08 95       	ret

00002694 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    2694:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    2696:	e1 99       	sbic	0x1c, 1	; 28
    2698:	fe cf       	rjmp	.-4      	; 0x2696 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    269a:	3f bb       	out	0x1f, r19	; 31
    269c:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    269e:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	e2 9a       	sbi	0x1c, 2	; 28
    26a6:	e1 9a       	sbi	0x1c, 1	; 28
    26a8:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    26aa:	08 95       	ret

000026ac <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
    26ac:	1f 92       	push	r1
    26ae:	0f 92       	push	r0
    26b0:	0f b6       	in	r0, 0x3f	; 63
    26b2:	0f 92       	push	r0
    26b4:	11 24       	eor	r1, r1
    26b6:	2f 93       	push	r18
    26b8:	6f 93       	push	r22
    26ba:	7f 93       	push	r23
    26bc:	8f 93       	push	r24
    26be:	9f 93       	push	r25
	if(__key_light == 1){
    26c0:	80 91 b7 02 	lds	r24, 0x02B7
    26c4:	81 30       	cpi	r24, 0x01	; 1
    26c6:	59 f4       	brne	.+22     	; 0x26de <__vector_12+0x32>
		__key_lgtcnt++;
    26c8:	80 91 b8 02 	lds	r24, 0x02B8
    26cc:	8f 5f       	subi	r24, 0xFF	; 255
    26ce:	80 93 b8 02 	sts	0x02B8, r24
		if(__key_lgtcnt == 150){
    26d2:	86 39       	cpi	r24, 0x96	; 150
    26d4:	21 f4       	brne	.+8      	; 0x26de <__vector_12+0x32>
		   __key_light = 0; 
    26d6:	10 92 b7 02 	sts	0x02B7, r1
		   __key_lgtcnt = 0; 
    26da:	10 92 b8 02 	sts	0x02B8, r1
		   //sbi(PORTG, 1);
		   }
	}

	//Beep
	if (TimBeep>0){
    26de:	80 91 be 01 	lds	r24, 0x01BE
    26e2:	88 23       	and	r24, r24
    26e4:	31 f0       	breq	.+12     	; 0x26f2 <__vector_12+0x46>
	    TimBeep--;
    26e6:	81 50       	subi	r24, 0x01	; 1
    26e8:	80 93 be 01 	sts	0x01BE, r24
		DDRB=(DDRB|0b00100000);
    26ec:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
    26ee:	c5 98       	cbi	0x18, 5	; 24
    26f0:	05 c0       	rjmp	.+10     	; 0x26fc <__vector_12+0x50>
	    }
	else{PORTB=(PORTB|~PORTB);
    26f2:	98 b3       	in	r25, 0x18	; 24
    26f4:	88 b3       	in	r24, 0x18	; 24
    26f6:	80 95       	com	r24
    26f8:	89 2b       	or	r24, r25
    26fa:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
    26fc:	80 91 bc 01 	lds	r24, 0x01BC
    2700:	8f 5f       	subi	r24, 0xFF	; 255
    2702:	80 93 bc 01 	sts	0x01BC, r24
	//DisplaTicker
    TimTicker++;
    2706:	80 91 92 01 	lds	r24, 0x0192
    270a:	8f 5f       	subi	r24, 0xFF	; 255
    270c:	80 93 92 01 	sts	0x0192, r24
	TimPressed++;
    2710:	20 91 93 01 	lds	r18, 0x0193
    2714:	2f 5f       	subi	r18, 0xFF	; 255
    2716:	20 93 93 01 	sts	0x0193, r18
	if ((TimPressed%5)==0){
    271a:	82 2f       	mov	r24, r18
    271c:	65 e0       	ldi	r22, 0x05	; 5
    271e:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    2722:	99 23       	and	r25, r25
    2724:	71 f4       	brne	.+28     	; 0x2742 <__vector_12+0x96>
	    PORTE = PORTE^0x04;
    2726:	83 b1       	in	r24, 0x03	; 3
    2728:	94 e0       	ldi	r25, 0x04	; 4
    272a:	89 27       	eor	r24, r25
    272c:	83 b9       	out	0x03, r24	; 3
	    TimDisplay++;
    272e:	80 91 94 01 	lds	r24, 0x0194
    2732:	8f 5f       	subi	r24, 0xFF	; 255
    2734:	80 93 94 01 	sts	0x0194, r24
		TimPrintBusy++;
    2738:	80 91 b8 01 	lds	r24, 0x01B8
    273c:	8f 5f       	subi	r24, 0xFF	; 255
    273e:	80 93 b8 01 	sts	0x01B8, r24
	}
	if ((TimPressed%PRESSED_DELAY)==0){
    2742:	82 2f       	mov	r24, r18
    2744:	6a e0       	ldi	r22, 0x0A	; 10
    2746:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    274a:	99 23       	and	r25, r25
    274c:	29 f4       	brne	.+10     	; 0x2758 <__vector_12+0xac>
	     ProcTimeOut++;
    274e:	80 91 bd 01 	lds	r24, 0x01BD
    2752:	8f 5f       	subi	r24, 0xFF	; 255
    2754:	80 93 bd 01 	sts	0x01BD, r24
	}
	TimSend++;
    2758:	80 91 91 0e 	lds	r24, 0x0E91
    275c:	8f 5f       	subi	r24, 0xFF	; 255
    275e:	80 93 91 0e 	sts	0x0E91, r24
}
    2762:	9f 91       	pop	r25
    2764:	8f 91       	pop	r24
    2766:	7f 91       	pop	r23
    2768:	6f 91       	pop	r22
    276a:	2f 91       	pop	r18
    276c:	0f 90       	pop	r0
    276e:	0f be       	out	0x3f, r0	; 63
    2770:	0f 90       	pop	r0
    2772:	1f 90       	pop	r1
    2774:	18 95       	reti

00002776 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    2776:	86 e1       	ldi	r24, 0x16	; 22
    2778:	08 95       	ret

0000277a <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    277a:	e8 2f       	mov	r30, r24
    277c:	f0 e0       	ldi	r31, 0x00	; 0
    277e:	ee 31       	cpi	r30, 0x1E	; 30
    2780:	f1 05       	cpc	r31, r1
    2782:	70 f5       	brcc	.+92     	; 0x27e0 <GetPumpStatusLabel+0x66>
    2784:	ea 5b       	subi	r30, 0xBA	; 186
    2786:	ff 4f       	sbci	r31, 0xFF	; 255
    2788:	ee 0f       	add	r30, r30
    278a:	ff 1f       	adc	r31, r31
    278c:	05 90       	lpm	r0, Z+
    278e:	f4 91       	lpm	r31, Z+
    2790:	e0 2d       	mov	r30, r0
    2792:	09 94       	ijmp
    2794:	81 e3       	ldi	r24, 0x31	; 49
    2796:	08 95       	ret
    2798:	85 e4       	ldi	r24, 0x45	; 69
    279a:	08 95       	ret
    279c:	82 e3       	ldi	r24, 0x32	; 50
    279e:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    27a0:	83 e3       	ldi	r24, 0x33	; 51
    27a2:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    27a4:	84 e3       	ldi	r24, 0x34	; 52
    27a6:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    27a8:	85 e3       	ldi	r24, 0x35	; 53
    27aa:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    27ac:	89 e6       	ldi	r24, 0x69	; 105
    27ae:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    27b0:	8e e6       	ldi	r24, 0x6E	; 110
    27b2:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    27b4:	81 e6       	ldi	r24, 0x61	; 97
    27b6:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    27b8:	84 e6       	ldi	r24, 0x64	; 100
    27ba:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    27bc:	8f e4       	ldi	r24, 0x4F	; 79
    27be:	08 95       	ret
	 case PUMP_PEOT: 
	 	  Result='O';
		  break;
    27c0:	86 e4       	ldi	r24, 0x46	; 70
    27c2:	08 95       	ret
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    27c4:	83 e5       	ldi	r24, 0x53	; 83
    27c6:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    27c8:	8d e2       	ldi	r24, 0x2D	; 45
    27ca:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    27cc:	80 e5       	ldi	r24, 0x50	; 80
    27ce:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
    27d0:	89 e4       	ldi	r24, 0x49	; 73
    27d2:	08 95       	ret
     case PS_PRINTED:
	      Result='I';
 	      break;
    27d4:	86 e5       	ldi	r24, 0x56	; 86
    27d6:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    27d8:	84 e5       	ldi	r24, 0x54	; 84
    27da:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    27dc:	84 e7       	ldi	r24, 0x74	; 116
    27de:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    27e0:	88 e7       	ldi	r24, 0x78	; 120
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    27e2:	08 95       	ret

000027e4 <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    27e4:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
    27e8:	60 93 e0 0d 	sts	0x0DE0, r22
     IsControlPooling=True;
    27ec:	81 e0       	ldi	r24, 0x01	; 1
    27ee:	80 93 86 01 	sts	0x0186, r24
}
    27f2:	08 95       	ret

000027f4 <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    27f4:	28 2f       	mov	r18, r24


	 //uart(0,1,data);

     //EDC-MSG
     if (data==0x02){
    27f6:	82 30       	cpi	r24, 0x02	; 2
    27f8:	39 f4       	brne	.+14     	; 0x2808 <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    27fa:	81 e0       	ldi	r24, 0x01	; 1
    27fc:	80 93 ac 02 	sts	0x02AC, r24
		 nFlow=0;
    2800:	10 92 ab 02 	sts	0x02AB, r1
    2804:	10 92 aa 02 	sts	0x02AA, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    2808:	80 91 ac 02 	lds	r24, 0x02AC
    280c:	81 30       	cpi	r24, 0x01	; 1
    280e:	69 f4       	brne	.+26     	; 0x282a <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    2810:	80 91 aa 02 	lds	r24, 0x02AA
    2814:	90 91 ab 02 	lds	r25, 0x02AB
    2818:	fc 01       	movw	r30, r24
    281a:	ea 5d       	subi	r30, 0xDA	; 218
    281c:	f4 4f       	sbci	r31, 0xF4	; 244
    281e:	20 83       	st	Z, r18
		 nFlow++;
    2820:	01 96       	adiw	r24, 0x01	; 1
    2822:	90 93 ab 02 	sts	0x02AB, r25
    2826:	80 93 aa 02 	sts	0x02AA, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    282a:	23 30       	cpi	r18, 0x03	; 3
    282c:	41 f0       	breq	.+16     	; 0x283e <ScanEDCFlow+0x4a>
    282e:	80 91 aa 02 	lds	r24, 0x02AA
    2832:	90 91 ab 02 	lds	r25, 0x02AB
    2836:	8d 34       	cpi	r24, 0x4D	; 77
    2838:	91 05       	cpc	r25, r1
    283a:	08 f4       	brcc	.+2      	; 0x283e <ScanEDCFlow+0x4a>
    283c:	99 c0       	rjmp	.+306    	; 0x2970 <ScanEDCFlow+0x17c>
	     //for(i=0;i<nFlow;i++){uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    283e:	10 92 ac 02 	sts	0x02AC, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    2842:	30 91 28 0b 	lds	r19, 0x0B28
    2846:	30 51       	subi	r19, 0x10	; 16
    2848:	80 91 27 0b 	lds	r24, 0x0B27
    284c:	2a e0       	ldi	r18, 0x0A	; 10
    284e:	82 9f       	mul	r24, r18
    2850:	c0 01       	movw	r24, r0
    2852:	11 24       	eor	r1, r1
    2854:	38 0f       	add	r19, r24

		 if (EDCMsgCode==0x03){
    2856:	33 30       	cpi	r19, 0x03	; 3
    2858:	09 f0       	breq	.+2      	; 0x285c <ScanEDCFlow+0x68>
    285a:	65 c0       	rjmp	.+202    	; 0x2926 <ScanEDCFlow+0x132>
    285c:	e9 e2       	ldi	r30, 0x29	; 41
    285e:	fb e0       	ldi	r31, 0x0B	; 11
    2860:	a0 ea       	ldi	r26, 0xA0	; 160
    2862:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2864:	81 91       	ld	r24, Z+
    2866:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2868:	8b e0       	ldi	r24, 0x0B	; 11
    286a:	ef 32       	cpi	r30, 0x2F	; 47
    286c:	f8 07       	cpc	r31, r24
    286e:	d1 f7       	brne	.-12     	; 0x2864 <ScanEDCFlow+0x70>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2870:	10 92 a6 0e 	sts	0x0EA6, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2874:	80 81       	ld	r24, Z
    2876:	80 93 c2 07 	sts	0x07C2, r24
    287a:	81 81       	ldd	r24, Z+1	; 0x01
    287c:	80 93 c3 07 	sts	0x07C3, r24
	 }Dest[Length]=0;
    2880:	10 92 c4 07 	sts	0x07C4, r1
    2884:	32 96       	adiw	r30, 0x02	; 2
    2886:	ac eb       	ldi	r26, 0xBC	; 188
    2888:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    288a:	81 91       	ld	r24, Z+
    288c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    288e:	8b e0       	ldi	r24, 0x0B	; 11
    2890:	e0 34       	cpi	r30, 0x40	; 64
    2892:	f8 07       	cpc	r31, r24
    2894:	d1 f7       	brne	.-12     	; 0x288a <ScanEDCFlow+0x96>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2896:	10 92 cb 0e 	sts	0x0ECB, r1
    289a:	a2 e9       	ldi	r26, 0x92	; 146
    289c:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    289e:	81 91       	ld	r24, Z+
    28a0:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28a2:	8b e0       	ldi	r24, 0x0B	; 11
    28a4:	e3 35       	cpi	r30, 0x53	; 83
    28a6:	f8 07       	cpc	r31, r24
    28a8:	d1 f7       	brne	.-12     	; 0x289e <ScanEDCFlow+0xaa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28aa:	10 92 a5 0d 	sts	0x0DA5, r1
    28ae:	20 e0       	ldi	r18, 0x00	; 0
    28b0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28b2:	f9 01       	movw	r30, r18
    28b4:	e7 50       	subi	r30, 0x07	; 7
    28b6:	f8 4f       	sbci	r31, 0xF8	; 248
    28b8:	d9 01       	movw	r26, r18
    28ba:	aa 5d       	subi	r26, 0xDA	; 218
    28bc:	b4 4f       	sbci	r27, 0xF4	; 244
    28be:	9d 96       	adiw	r26, 0x2d	; 45
    28c0:	8c 91       	ld	r24, X
    28c2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28c4:	2f 5f       	subi	r18, 0xFF	; 255
    28c6:	3f 4f       	sbci	r19, 0xFF	; 255
    28c8:	26 30       	cpi	r18, 0x06	; 6
    28ca:	31 05       	cpc	r19, r1
    28cc:	91 f7       	brne	.-28     	; 0x28b2 <ScanEDCFlow+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28ce:	10 92 ff 07 	sts	0x07FF, r1
    28d2:	20 e0       	ldi	r18, 0x00	; 0
    28d4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28d6:	f9 01       	movw	r30, r18
    28d8:	e4 5a       	subi	r30, 0xA4	; 164
    28da:	f8 4f       	sbci	r31, 0xF8	; 248
    28dc:	d9 01       	movw	r26, r18
    28de:	aa 5d       	subi	r26, 0xDA	; 218
    28e0:	b4 4f       	sbci	r27, 0xF4	; 244
    28e2:	d3 96       	adiw	r26, 0x33	; 51
    28e4:	8c 91       	ld	r24, X
    28e6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28e8:	2f 5f       	subi	r18, 0xFF	; 255
    28ea:	3f 4f       	sbci	r19, 0xFF	; 255
    28ec:	2a 30       	cpi	r18, 0x0A	; 10
    28ee:	31 05       	cpc	r19, r1
    28f0:	91 f7       	brne	.-28     	; 0x28d6 <ScanEDCFlow+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28f2:	10 92 66 07 	sts	0x0766, r1
    28f6:	20 e0       	ldi	r18, 0x00	; 0
    28f8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28fa:	f9 01       	movw	r30, r18
    28fc:	e8 53       	subi	r30, 0x38	; 56
    28fe:	f2 4f       	sbci	r31, 0xF2	; 242
    2900:	d9 01       	movw	r26, r18
    2902:	aa 5d       	subi	r26, 0xDA	; 218
    2904:	b4 4f       	sbci	r27, 0xF4	; 244
    2906:	dd 96       	adiw	r26, 0x3d	; 61
    2908:	8c 91       	ld	r24, X
    290a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    290c:	2f 5f       	subi	r18, 0xFF	; 255
    290e:	3f 4f       	sbci	r19, 0xFF	; 255
    2910:	2e 30       	cpi	r18, 0x0E	; 14
    2912:	31 05       	cpc	r19, r1
    2914:	91 f7       	brne	.-28     	; 0x28fa <ScanEDCFlow+0x106>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2916:	10 92 d6 0d 	sts	0x0DD6, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    291a:	81 e0       	ldi	r24, 0x01	; 1
    291c:	80 93 9b 01 	sts	0x019B, r24
			 IsPrintApprovalCode=True;
    2920:	80 93 9c 01 	sts	0x019C, r24
    2924:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    2926:	34 30       	cpi	r19, 0x04	; 4
    2928:	19 f5       	brne	.+70     	; 0x2970 <ScanEDCFlow+0x17c>
    292a:	e9 e2       	ldi	r30, 0x29	; 41
    292c:	fb e0       	ldi	r31, 0x0B	; 11
    292e:	a9 ef       	ldi	r26, 0xF9	; 249
    2930:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2932:	81 91       	ld	r24, Z+
    2934:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2936:	8b e0       	ldi	r24, 0x0B	; 11
    2938:	ef 32       	cpi	r30, 0x2F	; 47
    293a:	f8 07       	cpc	r31, r24
    293c:	d1 f7       	brne	.-12     	; 0x2932 <ScanEDCFlow+0x13e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    293e:	10 92 ff 07 	sts	0x07FF, r1
    2942:	ac e5       	ldi	r26, 0x5C	; 92
    2944:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2946:	81 91       	ld	r24, Z+
    2948:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    294a:	8b e0       	ldi	r24, 0x0B	; 11
    294c:	e9 33       	cpi	r30, 0x39	; 57
    294e:	f8 07       	cpc	r31, r24
    2950:	d1 f7       	brne	.-12     	; 0x2946 <ScanEDCFlow+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2952:	10 92 66 07 	sts	0x0766, r1
    2956:	a8 ec       	ldi	r26, 0xC8	; 200
    2958:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    295a:	81 91       	ld	r24, Z+
    295c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    295e:	8b e0       	ldi	r24, 0x0B	; 11
    2960:	e7 34       	cpi	r30, 0x47	; 71
    2962:	f8 07       	cpc	r31, r24
    2964:	d1 f7       	brne	.-12     	; 0x295a <ScanEDCFlow+0x166>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2966:	10 92 d6 0d 	sts	0x0DD6, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    296a:	81 e0       	ldi	r24, 0x01	; 1
    296c:	80 93 9d 01 	sts	0x019D, r24
    2970:	08 95       	ret

00002972 <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    2972:	08 95       	ret

00002974 <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    2974:	98 2f       	mov	r25, r24
    2976:	e8 e7       	ldi	r30, 0x78	; 120
    2978:	f8 e0       	ldi	r31, 0x08	; 8
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    297a:	80 81       	ld	r24, Z
    297c:	81 83       	std	Z+1, r24	; 0x01
    297e:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    2980:	88 e0       	ldi	r24, 0x08	; 8
    2982:	e5 36       	cpi	r30, 0x65	; 101
    2984:	f8 07       	cpc	r31, r24
    2986:	c9 f7       	brne	.-14     	; 0x297a <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    2988:	9f 01       	movw	r18, r30
    298a:	2f 5f       	subi	r18, 0xFF	; 255
    298c:	3f 4f       	sbci	r19, 0xFF	; 255
    298e:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    2990:	84 85       	ldd	r24, Z+12	; 0x0c
    2992:	82 30       	cpi	r24, 0x02	; 2
    2994:	f9 f4       	brne	.+62     	; 0x29d4 <ScanRFIDFlow+0x60>
    2996:	80 91 67 08 	lds	r24, 0x0867
    299a:	8a 30       	cpi	r24, 0x0A	; 10
    299c:	d9 f4       	brne	.+54     	; 0x29d4 <ScanRFIDFlow+0x60>
    299e:	93 30       	cpi	r25, 0x03	; 3
    29a0:	c9 f4       	brne	.+50     	; 0x29d4 <ScanRFIDFlow+0x60>
    29a2:	f9 01       	movw	r30, r18
    29a4:	3a 96       	adiw	r30, 0x0a	; 10
    29a6:	a6 e6       	ldi	r26, 0x66	; 102
    29a8:	be e0       	ldi	r27, 0x0E	; 14
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    29aa:	80 81       	ld	r24, Z
    29ac:	8d 93       	st	X+, r24
    29ae:	31 97       	sbiw	r30, 0x01	; 1
    29b0:	88 e0       	ldi	r24, 0x08	; 8
    29b2:	e8 36       	cpi	r30, 0x68	; 104
    29b4:	f8 07       	cpc	r31, r24
    29b6:	c9 f7       	brne	.-14     	; 0x29aa <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    29b8:	10 92 6e 0e 	sts	0x0E6E, r1
	    IsRFIDDetected=True;
    29bc:	81 e0       	ldi	r24, 0x01	; 1
    29be:	80 93 9a 01 	sts	0x019A, r24
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    29c2:	80 93 b7 02 	sts	0x02B7, r24
	 __key_lgtcnt = 0; 
    29c6:	10 92 b8 02 	sts	0x02B8, r1
	 PORTG=PORTG&0b11111101;
    29ca:	80 91 65 00 	lds	r24, 0x0065
    29ce:	8d 7f       	andi	r24, 0xFD	; 253
    29d0:	80 93 65 00 	sts	0x0065, r24
    29d4:	08 95       	ret

000029d6 <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    29d6:	1f 92       	push	r1
    29d8:	0f 92       	push	r0
    29da:	0f b6       	in	r0, 0x3f	; 63
    29dc:	0f 92       	push	r0
    29de:	11 24       	eor	r1, r1
    29e0:	8f 93       	push	r24
    29e2:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    29e4:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    29e6:	80 91 b4 01 	lds	r24, 0x01B4
    29ea:	81 30       	cpi	r24, 0x01	; 1
    29ec:	21 f0       	breq	.+8      	; 0x29f6 <__vector_18+0x20>
    29ee:	80 91 b6 01 	lds	r24, 0x01B6
    29f2:	81 30       	cpi	r24, 0x01	; 1
    29f4:	51 f4       	brne	.+20     	; 0x2a0a <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    29f6:	93 31       	cpi	r25, 0x13	; 19
    29f8:	21 f4       	brne	.+8      	; 0x2a02 <__vector_18+0x2c>
    29fa:	81 e0       	ldi	r24, 0x01	; 1
    29fc:	80 93 b5 01 	sts	0x01B5, r24
    2a00:	04 c0       	rjmp	.+8      	; 0x2a0a <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    2a02:	91 31       	cpi	r25, 0x11	; 17
    2a04:	11 f4       	brne	.+4      	; 0x2a0a <__vector_18+0x34>
    2a06:	10 92 b5 01 	sts	0x01B5, r1
	}
}
    2a0a:	9f 91       	pop	r25
    2a0c:	8f 91       	pop	r24
    2a0e:	0f 90       	pop	r0
    2a10:	0f be       	out	0x3f, r0	; 63
    2a12:	0f 90       	pop	r0
    2a14:	1f 90       	pop	r1
    2a16:	18 95       	reti

00002a18 <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    2a18:	80 e0       	ldi	r24, 0x00	; 0
    2a1a:	08 95       	ret

00002a1c <ConfigProtocol>:
	 }
	 uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    2a1c:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    2a1e:	80 91 a8 02 	lds	r24, 0x02A8
    2a22:	89 36       	cpi	r24, 0x69	; 105
    2a24:	e9 f4       	brne	.+58     	; 0x2a60 <ConfigProtocol+0x44>
    2a26:	80 91 a7 02 	lds	r24, 0x02A7
    2a2a:	83 34       	cpi	r24, 0x43	; 67
    2a2c:	c9 f4       	brne	.+50     	; 0x2a60 <ConfigProtocol+0x44>
    2a2e:	80 91 a6 02 	lds	r24, 0x02A6
    2a32:	8f 36       	cpi	r24, 0x6F	; 111
    2a34:	a9 f4       	brne	.+42     	; 0x2a60 <ConfigProtocol+0x44>
    2a36:	80 91 a5 02 	lds	r24, 0x02A5
    2a3a:	8e 36       	cpi	r24, 0x6E	; 110
    2a3c:	89 f4       	brne	.+34     	; 0x2a60 <ConfigProtocol+0x44>
    2a3e:	80 91 a4 02 	lds	r24, 0x02A4
    2a42:	86 36       	cpi	r24, 0x66	; 102
    2a44:	69 f4       	brne	.+26     	; 0x2a60 <ConfigProtocol+0x44>
    2a46:	80 91 a3 02 	lds	r24, 0x02A3
    2a4a:	8f 33       	cpi	r24, 0x3F	; 63
    2a4c:	49 f4       	brne	.+18     	; 0x2a60 <ConfigProtocol+0x44>
    2a4e:	80 91 a2 02 	lds	r24, 0x02A2
    2a52:	8d 30       	cpi	r24, 0x0D	; 13
    2a54:	29 f4       	brne	.+10     	; 0x2a60 <ConfigProtocol+0x44>
    2a56:	2a 30       	cpi	r18, 0x0A	; 10
    2a58:	19 f4       	brne	.+6      	; 0x2a60 <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    2a5a:	82 e0       	ldi	r24, 0x02	; 2
    2a5c:	80 93 b2 01 	sts	0x01B2, r24
	}

	if (IsConfigFlow==True){        
    2a60:	80 91 87 01 	lds	r24, 0x0187
    2a64:	81 30       	cpi	r24, 0x01	; 1
    2a66:	69 f4       	brne	.+26     	; 0x2a82 <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    2a68:	80 91 8b 01 	lds	r24, 0x018B
    2a6c:	90 91 8c 01 	lds	r25, 0x018C
    2a70:	fc 01       	movw	r30, r24
    2a72:	ea 5d       	subi	r30, 0xDA	; 218
    2a74:	f4 4f       	sbci	r31, 0xF4	; 244
    2a76:	20 83       	st	Z, r18
	    char_count++; 
    2a78:	01 96       	adiw	r24, 0x01	; 1
    2a7a:	90 93 8c 01 	sts	0x018C, r25
    2a7e:	80 93 8b 01 	sts	0x018B, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    2a82:	80 91 a2 02 	lds	r24, 0x02A2
    2a86:	84 30       	cpi	r24, 0x04	; 4
    2a88:	51 f4       	brne	.+20     	; 0x2a9e <ConfigProtocol+0x82>
    2a8a:	20 34       	cpi	r18, 0x40	; 64
    2a8c:	e9 f4       	brne	.+58     	; 0x2ac8 <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    2a8e:	81 e0       	ldi	r24, 0x01	; 1
    2a90:	80 93 87 01 	sts	0x0187, r24
		 char_count=0;
    2a94:	10 92 8c 01 	sts	0x018C, r1
    2a98:	10 92 8b 01 	sts	0x018B, r1
    2a9c:	15 c0       	rjmp	.+42     	; 0x2ac8 <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    2a9e:	85 30       	cpi	r24, 0x05	; 5
    2aa0:	99 f4       	brne	.+38     	; 0x2ac8 <ConfigProtocol+0xac>
    2aa2:	20 35       	cpi	r18, 0x50	; 80
    2aa4:	89 f4       	brne	.+34     	; 0x2ac8 <ConfigProtocol+0xac>
	     transLength=char_count;
    2aa6:	80 91 8b 01 	lds	r24, 0x018B
    2aaa:	90 91 8c 01 	lds	r25, 0x018C
    2aae:	90 93 8e 01 	sts	0x018E, r25
    2ab2:	80 93 8d 01 	sts	0x018D, r24
		 char_count=0;
    2ab6:	10 92 8c 01 	sts	0x018C, r1
    2aba:	10 92 8b 01 	sts	0x018B, r1
	     IsConfigFlow=False;
    2abe:	10 92 87 01 	sts	0x0187, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    2ac2:	81 e0       	ldi	r24, 0x01	; 1
    2ac4:	80 93 b2 01 	sts	0x01B2, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    2ac8:	80 91 a7 02 	lds	r24, 0x02A7
    2acc:	80 93 a8 02 	sts	0x02A8, r24
	Conflow[5]=Conflow[4];
    2ad0:	80 91 a6 02 	lds	r24, 0x02A6
    2ad4:	80 93 a7 02 	sts	0x02A7, r24
	Conflow[4]=Conflow[3];
    2ad8:	80 91 a5 02 	lds	r24, 0x02A5
    2adc:	80 93 a6 02 	sts	0x02A6, r24
	Conflow[3]=Conflow[2];
    2ae0:	80 91 a4 02 	lds	r24, 0x02A4
    2ae4:	80 93 a5 02 	sts	0x02A5, r24
	Conflow[2]=Conflow[1];
    2ae8:	80 91 a3 02 	lds	r24, 0x02A3
    2aec:	80 93 a4 02 	sts	0x02A4, r24
	Conflow[1]=Conflow[0];
    2af0:	80 91 a2 02 	lds	r24, 0x02A2
    2af4:	80 93 a3 02 	sts	0x02A3, r24
	Conflow[0]=dataIn;
    2af8:	20 93 a2 02 	sts	0x02A2, r18

}
    2afc:	08 95       	ret

00002afe <system_beep>:
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    2afe:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    2b00:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    2b02:	80 93 be 01 	sts	0x01BE, r24
}
    2b06:	08 95       	ret

00002b08 <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2b08:	08 95       	ret

00002b0a <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2b0a:	8f 70       	andi	r24, 0x0F	; 15
    2b0c:	08 95       	ret

00002b0e <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    2b0e:	82 95       	swap	r24
    2b10:	8f 70       	andi	r24, 0x0F	; 15
    2b12:	08 95       	ret

00002b14 <Str>:
char Str(char H){
    2b14:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2b16:	8a 30       	cpi	r24, 0x0A	; 10
    2b18:	10 f4       	brcc	.+4      	; 0x2b1e <Str+0xa>
    2b1a:	80 5d       	subi	r24, 0xD0	; 208
    2b1c:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2b1e:	8a 50       	subi	r24, 0x0A	; 10
    2b20:	86 30       	cpi	r24, 0x06	; 6
    2b22:	10 f0       	brcs	.+4      	; 0x2b28 <Str+0x14>
    2b24:	80 e0       	ldi	r24, 0x00	; 0
    2b26:	08 95       	ret
    2b28:	89 2f       	mov	r24, r25
    2b2a:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2b2c:	08 95       	ret

00002b2e <charToHex>:

void charToHex(char X, char *Result){
    2b2e:	28 2f       	mov	r18, r24
    2b30:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2b32:	98 2f       	mov	r25, r24
    2b34:	92 95       	swap	r25
    2b36:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2b38:	9a 30       	cpi	r25, 0x0A	; 10
    2b3a:	18 f4       	brcc	.+6      	; 0x2b42 <charToHex+0x14>
    2b3c:	89 2f       	mov	r24, r25
    2b3e:	80 5d       	subi	r24, 0xD0	; 208
    2b40:	08 c0       	rjmp	.+16     	; 0x2b52 <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2b42:	89 2f       	mov	r24, r25
    2b44:	8a 50       	subi	r24, 0x0A	; 10
    2b46:	86 30       	cpi	r24, 0x06	; 6
    2b48:	10 f0       	brcs	.+4      	; 0x2b4e <charToHex+0x20>
    2b4a:	80 e0       	ldi	r24, 0x00	; 0
    2b4c:	02 c0       	rjmp	.+4      	; 0x2b52 <charToHex+0x24>
    2b4e:	89 2f       	mov	r24, r25
    2b50:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2b52:	80 83       	st	Z, r24
	lcd_print(1,1,lcdteks);
}

char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2b54:	92 2f       	mov	r25, r18
    2b56:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2b58:	9a 30       	cpi	r25, 0x0A	; 10
    2b5a:	18 f4       	brcc	.+6      	; 0x2b62 <charToHex+0x34>
    2b5c:	89 2f       	mov	r24, r25
    2b5e:	80 5d       	subi	r24, 0xD0	; 208
    2b60:	08 c0       	rjmp	.+16     	; 0x2b72 <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2b62:	89 2f       	mov	r24, r25
    2b64:	8a 50       	subi	r24, 0x0A	; 10
    2b66:	86 30       	cpi	r24, 0x06	; 6
    2b68:	10 f0       	brcs	.+4      	; 0x2b6e <charToHex+0x40>
    2b6a:	80 e0       	ldi	r24, 0x00	; 0
    2b6c:	02 c0       	rjmp	.+4      	; 0x2b72 <charToHex+0x44>
    2b6e:	89 2f       	mov	r24, r25
    2b70:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2b72:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2b74:	12 82       	std	Z+2, r1	; 0x02
	 
}
    2b76:	08 95       	ret

00002b78 <strToInt>:

char strToInt(char *str){
    2b78:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    2b7a:	80 81       	ld	r24, Z
    2b7c:	2a e0       	ldi	r18, 0x0A	; 10
    2b7e:	82 9f       	mul	r24, r18
    2b80:	90 01       	movw	r18, r0
    2b82:	11 24       	eor	r1, r1
    2b84:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    2b86:	82 0f       	add	r24, r18
    2b88:	08 95       	ret

00002b8a <intToStr>:

void intToStr(char X, char *str){
    2b8a:	58 2f       	mov	r21, r24
    2b8c:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    2b8e:	64 e6       	ldi	r22, 0x64	; 100
    2b90:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    2b94:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    2b96:	85 2f       	mov	r24, r21
    2b98:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    2b9c:	89 2f       	mov	r24, r25
    2b9e:	6a e0       	ldi	r22, 0x0A	; 10
    2ba0:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    2ba4:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    2ba6:	8c e9       	ldi	r24, 0x9C	; 156
    2ba8:	9f ef       	ldi	r25, 0xFF	; 255
    2baa:	a8 9f       	mul	r26, r24
    2bac:	80 2d       	mov	r24, r0
    2bae:	11 24       	eor	r1, r1
    2bb0:	85 0f       	add	r24, r21
    2bb2:	26 ef       	ldi	r18, 0xF6	; 246
    2bb4:	3f ef       	ldi	r19, 0xFF	; 255
    2bb6:	42 9f       	mul	r20, r18
    2bb8:	90 2d       	mov	r25, r0
    2bba:	11 24       	eor	r1, r1
    2bbc:	98 0f       	add	r25, r24
	 if (X>=100){
    2bbe:	54 36       	cpi	r21, 0x64	; 100
    2bc0:	40 f0       	brcs	.+16     	; 0x2bd2 <intToStr+0x48>
	     str[0]=('0'+R);
    2bc2:	a0 5d       	subi	r26, 0xD0	; 208
    2bc4:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    2bc6:	40 5d       	subi	r20, 0xD0	; 208
    2bc8:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    2bca:	90 5d       	subi	r25, 0xD0	; 208
    2bcc:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    2bce:	13 82       	std	Z+3, r1	; 0x03
    2bd0:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    2bd2:	5b 30       	cpi	r21, 0x0B	; 11
    2bd4:	18 f4       	brcc	.+6      	; 0x2bdc <intToStr+0x52>
	     str[0]=('0'+S);
    2bd6:	90 5d       	subi	r25, 0xD0	; 208
    2bd8:	90 83       	st	Z, r25
	     str[1]=0;
    2bda:	11 82       	std	Z+1, r1	; 0x01
    2bdc:	08 95       	ret

00002bde <UpdateClientIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
	 */
}
    2bde:	08 95       	ret

00002be0 <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
		 */
}
    2be0:	08 95       	ret

00002be2 <UpdateIFT_ID>:
void UpdateIFT_ID(){
    /* char IdIFT;
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
	 */
}
    2be2:	08 95       	ret

00002be4 <UpdateSeqNum>:
/*
     if (SeqNum<100)SeqNum++;
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 
    2be4:	08 95       	ret

00002be6 <ViewCardID>:
}




void ViewCardID(){//+12345678 -->12345678
    2be6:	20 e0       	ldi	r18, 0x00	; 0
    2be8:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    2bea:	f9 01       	movw	r30, r18
    2bec:	ee 56       	subi	r30, 0x6E	; 110
    2bee:	f2 4f       	sbci	r31, 0xF2	; 242
    2bf0:	d9 01       	movw	r26, r18
    2bf2:	aa 59       	subi	r26, 0x9A	; 154
    2bf4:	b1 4f       	sbci	r27, 0xF1	; 241
    2bf6:	8c 91       	ld	r24, X
    2bf8:	80 83       	st	Z, r24
    2bfa:	2f 5f       	subi	r18, 0xFF	; 255
    2bfc:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2bfe:	28 30       	cpi	r18, 0x08	; 8
    2c00:	31 05       	cpc	r19, r1
    2c02:	99 f7       	brne	.-26     	; 0x2bea <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2c04:	10 92 9a 0d 	sts	0x0D9A, r1
}
    2c08:	08 95       	ret

00002c0a <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    2c0a:	cf 93       	push	r28
    2c0c:	df 93       	push	r29
    2c0e:	db 01       	movw	r26, r22
    2c10:	ec 01       	movw	r28, r24
    2c12:	20 e0       	ldi	r18, 0x00	; 0
    2c14:	30 e0       	ldi	r19, 0x00	; 0
    2c16:	07 c0       	rjmp	.+14     	; 0x2c26 <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    2c18:	fd 01       	movw	r30, r26
    2c1a:	e2 0f       	add	r30, r18
    2c1c:	f3 1f       	adc	r31, r19
    2c1e:	89 91       	ld	r24, Y+
    2c20:	80 83       	st	Z, r24
    2c22:	2f 5f       	subi	r18, 0xFF	; 255
    2c24:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2c26:	24 17       	cp	r18, r20
    2c28:	b8 f3       	brcs	.-18     	; 0x2c18 <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2c2a:	a4 0f       	add	r26, r20
    2c2c:	b1 1d       	adc	r27, r1
    2c2e:	1c 92       	st	X, r1
}
    2c30:	df 91       	pop	r29
    2c32:	cf 91       	pop	r28
    2c34:	08 95       	ret

00002c36 <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2c36:	cf 93       	push	r28
    2c38:	df 93       	push	r29
    2c3a:	db 01       	movw	r26, r22
    2c3c:	ec 01       	movw	r28, r24
    2c3e:	c4 0f       	add	r28, r20
    2c40:	d1 1d       	adc	r29, r1
    2c42:	40 e0       	ldi	r20, 0x00	; 0
    2c44:	50 e0       	ldi	r21, 0x00	; 0
    2c46:	07 c0       	rjmp	.+14     	; 0x2c56 <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2c48:	fd 01       	movw	r30, r26
    2c4a:	e4 0f       	add	r30, r20
    2c4c:	f5 1f       	adc	r31, r21
    2c4e:	89 91       	ld	r24, Y+
    2c50:	80 83       	st	Z, r24
    2c52:	4f 5f       	subi	r20, 0xFF	; 255
    2c54:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2c56:	42 17       	cp	r20, r18
    2c58:	b8 f3       	brcs	.-18     	; 0x2c48 <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2c5a:	a2 0f       	add	r26, r18
    2c5c:	b1 1d       	adc	r27, r1
    2c5e:	1c 92       	st	X, r1
}
    2c60:	df 91       	pop	r29
    2c62:	cf 91       	pop	r28
    2c64:	08 95       	ret

00002c66 <TestLocalAccount>:

void TestLocalAccount(){

}
    2c66:	08 95       	ret

00002c68 <BackLightTrig>:
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    2c68:	81 e0       	ldi	r24, 0x01	; 1
    2c6a:	80 93 b7 02 	sts	0x02B7, r24
	 __key_lgtcnt = 0; 
    2c6e:	10 92 b8 02 	sts	0x02B8, r1
	 PORTG=PORTG&0b11111101;
    2c72:	e5 e6       	ldi	r30, 0x65	; 101
    2c74:	f0 e0       	ldi	r31, 0x00	; 0
    2c76:	80 81       	ld	r24, Z
    2c78:	8d 7f       	andi	r24, 0xFD	; 253
    2c7a:	80 83       	st	Z, r24
}
    2c7c:	08 95       	ret

00002c7e <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2c7e:	82 30       	cpi	r24, 0x02	; 2
    2c80:	59 f0       	breq	.+22     	; 0x2c98 <GetBaudrate+0x1a>
    2c82:	82 30       	cpi	r24, 0x02	; 2
    2c84:	18 f0       	brcs	.+6      	; 0x2c8c <GetBaudrate+0xe>
    2c86:	83 30       	cpi	r24, 0x03	; 3
    2c88:	21 f4       	brne	.+8      	; 0x2c92 <GetBaudrate+0x14>
    2c8a:	09 c0       	rjmp	.+18     	; 0x2c9e <GetBaudrate+0x20>
    2c8c:	20 e8       	ldi	r18, 0x80	; 128
    2c8e:	35 e2       	ldi	r19, 0x25	; 37
    2c90:	08 c0       	rjmp	.+16     	; 0x2ca2 <GetBaudrate+0x24>
    2c92:	20 e0       	ldi	r18, 0x00	; 0
    2c94:	30 e0       	ldi	r19, 0x00	; 0
    2c96:	05 c0       	rjmp	.+10     	; 0x2ca2 <GetBaudrate+0x24>
    2c98:	20 e0       	ldi	r18, 0x00	; 0
    2c9a:	3b e4       	ldi	r19, 0x4B	; 75
    2c9c:	02 c0       	rjmp	.+4      	; 0x2ca2 <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2c9e:	2b e9       	ldi	r18, 0x9B	; 155
    2ca0:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2ca2:	c9 01       	movw	r24, r18
    2ca4:	08 95       	ret

00002ca6 <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2ca6:	e1 99       	sbic	0x1c, 1	; 28
    2ca8:	fe cf       	rjmp	.-4      	; 0x2ca6 <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2caa:	84 e4       	ldi	r24, 0x44	; 68
    2cac:	91 e0       	ldi	r25, 0x01	; 1
    2cae:	9f bb       	out	0x1f, r25	; 31
    2cb0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2cb2:	e0 9a       	sbi	0x1c, 0	; 28
    2cb4:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2cb6:	80 93 4e 01 	sts	0x014E, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2cba:	e1 99       	sbic	0x1c, 1	; 28
    2cbc:	fe cf       	rjmp	.-4      	; 0x2cba <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2cbe:	89 e4       	ldi	r24, 0x49	; 73
    2cc0:	91 e0       	ldi	r25, 0x01	; 1
    2cc2:	9f bb       	out	0x1f, r25	; 31
    2cc4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2cc6:	e0 9a       	sbi	0x1c, 0	; 28
    2cc8:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2cca:	80 93 4f 01 	sts	0x014F, r24
}
    2cce:	08 95       	ret

00002cd0 <InitStandalone>:
	      RunInitStandalone=False;
	      break;
	 }
  }
  */
}
    2cd0:	08 95       	ret

00002cd2 <DisplayQueueFIP>:


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2cd2:	08 95       	ret

00002cd4 <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2cd4:	08 95       	ret

00002cd6 <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2cd6:	86 27       	eor	r24, r22
    2cd8:	08 95       	ret

00002cda <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2cda:	08 95       	ret

00002cdc <GeniusCalc>:


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
	 Result=0;
     switch(cOption){
    2cdc:	88 23       	and	r24, r24
    2cde:	19 f0       	breq	.+6      	; 0x2ce6 <GeniusCalc+0xa>
    2ce0:	81 30       	cpi	r24, 0x01	; 1
    2ce2:	49 f5       	brne	.+82     	; 0x2d36 <GeniusCalc+0x5a>
    2ce4:	11 c0       	rjmp	.+34     	; 0x2d08 <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2ce6:	26 2f       	mov	r18, r22
    2ce8:	30 e0       	ldi	r19, 0x00	; 0
    2cea:	24 0f       	add	r18, r20
    2cec:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2cee:	c9 01       	movw	r24, r18
    2cf0:	6a e0       	ldi	r22, 0x0A	; 10
    2cf2:	70 e0       	ldi	r23, 0x00	; 0
    2cf4:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    2cf8:	48 2f       	mov	r20, r24
    2cfa:	c9 01       	movw	r24, r18
    2cfc:	6a e0       	ldi	r22, 0x0A	; 10
    2cfe:	70 e0       	ldi	r23, 0x00	; 0
    2d00:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    2d04:	46 0f       	add	r20, r22
    2d06:	18 c0       	rjmp	.+48     	; 0x2d38 <GeniusCalc+0x5c>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2d08:	66 23       	and	r22, r22
    2d0a:	09 f4       	brne	.+2      	; 0x2d0e <GeniusCalc+0x32>
    2d0c:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2d0e:	44 23       	and	r20, r20
    2d10:	09 f4       	brne	.+2      	; 0x2d14 <GeniusCalc+0x38>
    2d12:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2d14:	46 9f       	mul	r20, r22
    2d16:	90 01       	movw	r18, r0
    2d18:	11 24       	eor	r1, r1
    2d1a:	c9 01       	movw	r24, r18
    2d1c:	6a e0       	ldi	r22, 0x0A	; 10
    2d1e:	70 e0       	ldi	r23, 0x00	; 0
    2d20:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    2d24:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2d26:	c9 01       	movw	r24, r18
    2d28:	6a e0       	ldi	r22, 0x0A	; 10
    2d2a:	70 e0       	ldi	r23, 0x00	; 0
    2d2c:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    2d30:	64 2f       	mov	r22, r20
    2d32:	48 2f       	mov	r20, r24
    2d34:	d8 cf       	rjmp	.-80     	; 0x2ce6 <GeniusCalc+0xa>
    2d36:	40 e0       	ldi	r20, 0x00	; 0
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2d38:	84 2f       	mov	r24, r20
    2d3a:	08 95       	ret

00002d3c <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2d3c:	81 e0       	ldi	r24, 0x01	; 1
    2d3e:	08 95       	ret

00002d40 <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2d40:	ff 92       	push	r15
    2d42:	0f 93       	push	r16
    2d44:	1f 93       	push	r17
    2d46:	cf 93       	push	r28
    2d48:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d4a:	f0 90 4e 01 	lds	r15, 0x014E
    2d4e:	ec 01       	movw	r28, r24
    2d50:	00 e0       	ldi	r16, 0x00	; 0
    2d52:	10 e0       	ldi	r17, 0x00	; 0
    2d54:	09 c0       	rjmp	.+18     	; 0x2d68 <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2d56:	8e e0       	ldi	r24, 0x0E	; 14
    2d58:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    2d5c:	98 81       	ld	r25, Y
    2d5e:	98 17       	cp	r25, r24
    2d60:	09 f4       	brne	.+2      	; 0x2d64 <CountNoPumpSatus+0x24>
		      Result++;		  
    2d62:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d64:	0f 5f       	subi	r16, 0xFF	; 255
    2d66:	21 96       	adiw	r28, 0x01	; 1
    2d68:	0f 15       	cp	r16, r15
    2d6a:	a8 f3       	brcs	.-22     	; 0x2d56 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2d6c:	81 2f       	mov	r24, r17
    2d6e:	df 91       	pop	r29
    2d70:	cf 91       	pop	r28
    2d72:	1f 91       	pop	r17
    2d74:	0f 91       	pop	r16
    2d76:	ff 90       	pop	r15
    2d78:	08 95       	ret

00002d7a <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2d7a:	08 95       	ret

00002d7c <FLockPump>:
char FLockPump(){

}
    2d7c:	08 95       	ret

00002d7e <FMenuSettingPassword>:
char FMenuSettingPassword(){
     char Result;
   //_menu_password();
   Result=MENU_DONE;
   return Result;
}
    2d7e:	81 e0       	ldi	r24, 0x01	; 1
    2d80:	08 95       	ret

00002d82 <menu_product>:
   return Result;
}

void menu_product(){

}
    2d82:	08 95       	ret

00002d84 <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2d84:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2d86:	80 81       	ld	r24, Z
    2d88:	84 17       	cp	r24, r20
    2d8a:	18 f4       	brcc	.+6      	; 0x2d92 <IncValue+0xe>
	     (*Value)++;
    2d8c:	8f 5f       	subi	r24, 0xFF	; 255
    2d8e:	80 83       	st	Z, r24
    2d90:	08 95       	ret
	 }else *Value=MinValue;
    2d92:	60 83       	st	Z, r22
    2d94:	08 95       	ret

00002d96 <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2d96:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2d98:	80 81       	ld	r24, Z
    2d9a:	68 17       	cp	r22, r24
    2d9c:	18 f4       	brcc	.+6      	; 0x2da4 <DecValue+0xe>
	     (*Value)--;
    2d9e:	81 50       	subi	r24, 0x01	; 1
    2da0:	80 83       	st	Z, r24
    2da2:	08 95       	ret
	 }else *Value=MaxValue;
    2da4:	40 83       	st	Z, r20
    2da6:	08 95       	ret

00002da8 <zeroIP>:
		 
		}

	}
}
void zeroIP(unsigned char Val,char *StrResult){
    2da8:	58 2f       	mov	r21, r24
    2daa:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2dac:	84 36       	cpi	r24, 0x64	; 100
    2dae:	00 f1       	brcs	.+64     	; 0x2df0 <zeroIP+0x48>
	    R=(Val/100);
    2db0:	64 e6       	ldi	r22, 0x64	; 100
    2db2:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    2db6:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2db8:	85 2f       	mov	r24, r21
    2dba:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    2dbe:	89 2f       	mov	r24, r25
    2dc0:	6a e0       	ldi	r22, 0x0A	; 10
    2dc2:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2dc6:	40 5d       	subi	r20, 0xD0	; 208
    2dc8:	40 83       	st	Z, r20
    2dca:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2dcc:	80 5d       	subi	r24, 0xD0	; 208
    2dce:	81 83       	std	Z+1, r24	; 0x01
    2dd0:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2dd2:	50 5d       	subi	r21, 0xD0	; 208
    2dd4:	2c e9       	ldi	r18, 0x9C	; 156
    2dd6:	3f ef       	ldi	r19, 0xFF	; 255
    2dd8:	42 9f       	mul	r20, r18
    2dda:	40 2d       	mov	r20, r0
    2ddc:	11 24       	eor	r1, r1
    2dde:	45 0f       	add	r20, r21
    2de0:	26 ef       	ldi	r18, 0xF6	; 246
    2de2:	3f ef       	ldi	r19, 0xFF	; 255
    2de4:	82 9f       	mul	r24, r18
    2de6:	80 2d       	mov	r24, r0
    2de8:	11 24       	eor	r1, r1
    2dea:	84 0f       	add	r24, r20
    2dec:	82 83       	std	Z+2, r24	; 0x02
    2dee:	10 c0       	rjmp	.+32     	; 0x2e10 <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2df0:	8a 50       	subi	r24, 0x0A	; 10
    2df2:	8a 35       	cpi	r24, 0x5A	; 90
    2df4:	78 f4       	brcc	.+30     	; 0x2e14 <zeroIP+0x6c>
        StrResult[0]='0';
    2df6:	80 e3       	ldi	r24, 0x30	; 48
    2df8:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2dfa:	85 2f       	mov	r24, r21
    2dfc:	6a e0       	ldi	r22, 0x0A	; 10
    2dfe:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    2e02:	80 5d       	subi	r24, 0xD0	; 208
    2e04:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2e06:	85 2f       	mov	r24, r21
    2e08:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    2e0c:	90 5d       	subi	r25, 0xD0	; 208
    2e0e:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2e10:	13 82       	std	Z+3, r1	; 0x03
    2e12:	08 95       	ret
		}
     else
	 if (Val<10){
    2e14:	5a 30       	cpi	r21, 0x0A	; 10
    2e16:	30 f4       	brcc	.+12     	; 0x2e24 <zeroIP+0x7c>
	    StrResult[0]='0';
    2e18:	80 e3       	ldi	r24, 0x30	; 48
    2e1a:	80 83       	st	Z, r24
		StrResult[1]='0';
    2e1c:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2e1e:	50 5d       	subi	r21, 0xD0	; 208
    2e20:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2e22:	13 82       	std	Z+3, r1	; 0x03
    2e24:	08 95       	ret

00002e26 <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2e26:	81 30       	cpi	r24, 0x01	; 1
    2e28:	29 f0       	breq	.+10     	; 0x2e34 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2e2a:	82 30       	cpi	r24, 0x02	; 2
    2e2c:	19 f0       	breq	.+6      	; 0x2e34 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2e2e:	83 30       	cpi	r24, 0x03	; 3
    2e30:	09 f0       	breq	.+2      	; 0x2e34 <GetLocAccStatus+0xe>
    2e32:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2e34:	08 95       	ret

00002e36 <FTestRemZero>:
	     RemZeroLead(strTest);  
		 uart_print(0,1,strTest);

	while (1){};
  #endif
}
    2e36:	08 95       	ret

00002e38 <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e38:	cf 93       	push	r28
    2e3a:	df 93       	push	r29
    2e3c:	eb 01       	movw	r28, r22
    2e3e:	da 01       	movw	r26, r20
    2e40:	a8 0f       	add	r26, r24
    2e42:	b9 1f       	adc	r27, r25
    2e44:	40 e0       	ldi	r20, 0x00	; 0
    2e46:	50 e0       	ldi	r21, 0x00	; 0
    2e48:	07 c0       	rjmp	.+14     	; 0x2e58 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e4a:	fe 01       	movw	r30, r28
    2e4c:	e4 0f       	add	r30, r20
    2e4e:	f5 1f       	adc	r31, r21
    2e50:	8d 91       	ld	r24, X+
    2e52:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e54:	4f 5f       	subi	r20, 0xFF	; 255
    2e56:	5f 4f       	sbci	r21, 0xFF	; 255
    2e58:	42 17       	cp	r20, r18
    2e5a:	53 07       	cpc	r21, r19
    2e5c:	b0 f3       	brcs	.-20     	; 0x2e4a <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e5e:	c2 0f       	add	r28, r18
    2e60:	d3 1f       	adc	r29, r19
    2e62:	18 82       	st	Y, r1
}
    2e64:	df 91       	pop	r29
    2e66:	cf 91       	pop	r28
    2e68:	08 95       	ret

00002e6a <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e6a:	0f 93       	push	r16
    2e6c:	1f 93       	push	r17
    2e6e:	cf 93       	push	r28
    2e70:	df 93       	push	r29
    2e72:	8c 01       	movw	r16, r24
    2e74:	db 01       	movw	r26, r22
    2e76:	eb 01       	movw	r28, r22
    2e78:	c4 0f       	add	r28, r20
    2e7a:	d5 1f       	adc	r29, r21
    2e7c:	60 e0       	ldi	r22, 0x00	; 0
    2e7e:	70 e0       	ldi	r23, 0x00	; 0
    2e80:	07 c0       	rjmp	.+14     	; 0x2e90 <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2e82:	f8 01       	movw	r30, r16
    2e84:	e6 0f       	add	r30, r22
    2e86:	f7 1f       	adc	r31, r23
    2e88:	80 81       	ld	r24, Z
    2e8a:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e8c:	6f 5f       	subi	r22, 0xFF	; 255
    2e8e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e90:	62 17       	cp	r22, r18
    2e92:	73 07       	cpc	r23, r19
    2e94:	b0 f3       	brcs	.-20     	; 0x2e82 <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2e96:	a4 0f       	add	r26, r20
    2e98:	b5 1f       	adc	r27, r21
    2e9a:	a2 0f       	add	r26, r18
    2e9c:	b3 1f       	adc	r27, r19
    2e9e:	1c 92       	st	X, r1
}
    2ea0:	df 91       	pop	r29
    2ea2:	cf 91       	pop	r28
    2ea4:	1f 91       	pop	r17
    2ea6:	0f 91       	pop	r16
    2ea8:	08 95       	ret

00002eaa <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2eaa:	fb 01       	movw	r30, r22
    2eac:	e8 0f       	add	r30, r24
    2eae:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2eb0:	80 81       	ld	r24, Z
    2eb2:	08 95       	ret

00002eb4 <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2eb4:	80 91 26 0b 	lds	r24, 0x0B26
    2eb8:	81 30       	cpi	r24, 0x01	; 1
    2eba:	51 f4       	brne	.+20     	; 0x2ed0 <procMessage00+0x1c>
    2ebc:	80 91 8d 01 	lds	r24, 0x018D
    2ec0:	90 91 8e 01 	lds	r25, 0x018E
    2ec4:	8f 97       	sbiw	r24, 0x2f	; 47
    2ec6:	21 f4       	brne	.+8      	; 0x2ed0 <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2ec8:	80 91 4b 0b 	lds	r24, 0x0B4B
    2ecc:	80 53       	subi	r24, 0x30	; 48
    2ece:	08 95       	ret
    2ed0:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2ed2:	08 95       	ret

00002ed4 <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2ed4:	90 91 4d 0b 	lds	r25, 0x0B4D
    2ed8:	20 e0       	ldi	r18, 0x00	; 0
    2eda:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2edc:	f9 01       	movw	r30, r18
    2ede:	e5 56       	subi	r30, 0x65	; 101
    2ee0:	f7 4f       	sbci	r31, 0xF7	; 247
    2ee2:	d9 01       	movw	r26, r18
    2ee4:	aa 5d       	subi	r26, 0xDA	; 218
    2ee6:	b4 4f       	sbci	r27, 0xF4	; 244
    2ee8:	97 96       	adiw	r26, 0x27	; 39
    2eea:	8c 91       	ld	r24, X
    2eec:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2eee:	2f 5f       	subi	r18, 0xFF	; 255
    2ef0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef2:	24 31       	cpi	r18, 0x14	; 20
    2ef4:	31 05       	cpc	r19, r1
    2ef6:	91 f7       	brne	.-28     	; 0x2edc <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ef8:	10 92 af 08 	sts	0x08AF, r1
    2efc:	20 e0       	ldi	r18, 0x00	; 0
    2efe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f00:	f9 01       	movw	r30, r18
    2f02:	e4 55       	subi	r30, 0x54	; 84
    2f04:	f8 4f       	sbci	r31, 0xF8	; 248
    2f06:	d9 01       	movw	r26, r18
    2f08:	aa 5d       	subi	r26, 0xDA	; 218
    2f0a:	b4 4f       	sbci	r27, 0xF4	; 244
    2f0c:	db 96       	adiw	r26, 0x3b	; 59
    2f0e:	8c 91       	ld	r24, X
    2f10:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f12:	2f 5f       	subi	r18, 0xFF	; 255
    2f14:	3f 4f       	sbci	r19, 0xFF	; 255
    2f16:	24 31       	cpi	r18, 0x14	; 20
    2f18:	31 05       	cpc	r19, r1
    2f1a:	91 f7       	brne	.-28     	; 0x2f00 <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f1c:	10 92 c0 07 	sts	0x07C0, r1
    2f20:	20 e0       	ldi	r18, 0x00	; 0
    2f22:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f24:	f9 01       	movw	r30, r18
    2f26:	eb 5d       	subi	r30, 0xDB	; 219
    2f28:	f7 4f       	sbci	r31, 0xF7	; 247
    2f2a:	d9 01       	movw	r26, r18
    2f2c:	ab 58       	subi	r26, 0x8B	; 139
    2f2e:	b4 4f       	sbci	r27, 0xF4	; 244
    2f30:	8c 91       	ld	r24, X
    2f32:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f34:	2f 5f       	subi	r18, 0xFF	; 255
    2f36:	3f 4f       	sbci	r19, 0xFF	; 255
    2f38:	24 31       	cpi	r18, 0x14	; 20
    2f3a:	31 05       	cpc	r19, r1
    2f3c:	99 f7       	brne	.-26     	; 0x2f24 <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f3e:	10 92 39 08 	sts	0x0839, r1
    2f42:	20 e0       	ldi	r18, 0x00	; 0
    2f44:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f46:	f9 01       	movw	r30, r18
    2f48:	ed 51       	subi	r30, 0x1D	; 29
    2f4a:	f2 4f       	sbci	r31, 0xF2	; 242
    2f4c:	d9 01       	movw	r26, r18
    2f4e:	a7 57       	subi	r26, 0x77	; 119
    2f50:	b4 4f       	sbci	r27, 0xF4	; 244
    2f52:	8c 91       	ld	r24, X
    2f54:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f56:	2f 5f       	subi	r18, 0xFF	; 255
    2f58:	3f 4f       	sbci	r19, 0xFF	; 255
    2f5a:	24 31       	cpi	r18, 0x14	; 20
    2f5c:	31 05       	cpc	r19, r1
    2f5e:	99 f7       	brne	.-26     	; 0x2f46 <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f60:	10 92 f7 0d 	sts	0x0DF7, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    2f64:	89 2f       	mov	r24, r25
    2f66:	80 53       	subi	r24, 0x30	; 48
    2f68:	08 95       	ret

00002f6a <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2f6a:	20 e0       	ldi	r18, 0x00	; 0
    2f6c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f6e:	f9 01       	movw	r30, r18
    2f70:	ee 56       	subi	r30, 0x6E	; 110
    2f72:	f2 4f       	sbci	r31, 0xF2	; 242
    2f74:	d9 01       	movw	r26, r18
    2f76:	aa 5d       	subi	r26, 0xDA	; 218
    2f78:	b4 4f       	sbci	r27, 0xF4	; 244
    2f7a:	95 96       	adiw	r26, 0x25	; 37
    2f7c:	8c 91       	ld	r24, X
    2f7e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f80:	2f 5f       	subi	r18, 0xFF	; 255
    2f82:	3f 4f       	sbci	r19, 0xFF	; 255
    2f84:	24 31       	cpi	r18, 0x14	; 20
    2f86:	31 05       	cpc	r19, r1
    2f88:	91 f7       	brne	.-28     	; 0x2f6e <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f8a:	10 92 a6 0d 	sts	0x0DA6, r1
    2f8e:	20 e0       	ldi	r18, 0x00	; 0
    2f90:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f92:	f9 01       	movw	r30, r18
    2f94:	e3 5d       	subi	r30, 0xD3	; 211
    2f96:	fc 4f       	sbci	r31, 0xFC	; 252
    2f98:	d9 01       	movw	r26, r18
    2f9a:	aa 5d       	subi	r26, 0xDA	; 218
    2f9c:	b4 4f       	sbci	r27, 0xF4	; 244
    2f9e:	d9 96       	adiw	r26, 0x39	; 57
    2fa0:	8c 91       	ld	r24, X
    2fa2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fa4:	2f 5f       	subi	r18, 0xFF	; 255
    2fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fa8:	2e 31       	cpi	r18, 0x1E	; 30
    2faa:	31 05       	cpc	r19, r1
    2fac:	91 f7       	brne	.-28     	; 0x2f92 <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fae:	10 92 4b 03 	sts	0x034B, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fb2:	80 91 7d 0b 	lds	r24, 0x0B7D
    2fb6:	80 93 93 03 	sts	0x0393, r24
	 }Dest[Length]=0;
    2fba:	10 92 94 03 	sts	0x0394, r1
    2fbe:	20 e0       	ldi	r18, 0x00	; 0
    2fc0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fc2:	f9 01       	movw	r30, r18
    2fc4:	e2 5c       	subi	r30, 0xC2	; 194
    2fc6:	f7 4f       	sbci	r31, 0xF7	; 247
    2fc8:	d9 01       	movw	r26, r18
    2fca:	a2 58       	subi	r26, 0x82	; 130
    2fcc:	b4 4f       	sbci	r27, 0xF4	; 244
    2fce:	8c 91       	ld	r24, X
    2fd0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fd2:	2f 5f       	subi	r18, 0xFF	; 255
    2fd4:	3f 4f       	sbci	r19, 0xFF	; 255
    2fd6:	28 30       	cpi	r18, 0x08	; 8
    2fd8:	31 05       	cpc	r19, r1
    2fda:	99 f7       	brne	.-26     	; 0x2fc2 <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fdc:	10 92 46 08 	sts	0x0846, r1
    2fe0:	20 e0       	ldi	r18, 0x00	; 0
    2fe2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fe4:	f9 01       	movw	r30, r18
    2fe6:	e9 57       	subi	r30, 0x79	; 121
    2fe8:	fc 4f       	sbci	r31, 0xFC	; 252
    2fea:	d9 01       	movw	r26, r18
    2fec:	aa 57       	subi	r26, 0x7A	; 122
    2fee:	b4 4f       	sbci	r27, 0xF4	; 244
    2ff0:	8c 91       	ld	r24, X
    2ff2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ff4:	2f 5f       	subi	r18, 0xFF	; 255
    2ff6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff8:	2a 30       	cpi	r18, 0x0A	; 10
    2ffa:	31 05       	cpc	r19, r1
    2ffc:	99 f7       	brne	.-26     	; 0x2fe4 <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ffe:	10 92 91 03 	sts	0x0391, r1
    3002:	20 e0       	ldi	r18, 0x00	; 0
    3004:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3006:	f9 01       	movw	r30, r18
    3008:	e6 50       	subi	r30, 0x06	; 6
    300a:	f2 4f       	sbci	r31, 0xF2	; 242
    300c:	d9 01       	movw	r26, r18
    300e:	a0 57       	subi	r26, 0x70	; 112
    3010:	b4 4f       	sbci	r27, 0xF4	; 244
    3012:	8c 91       	ld	r24, X
    3014:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3016:	2f 5f       	subi	r18, 0xFF	; 255
    3018:	3f 4f       	sbci	r19, 0xFF	; 255
    301a:	2a 30       	cpi	r18, 0x0A	; 10
    301c:	31 05       	cpc	r19, r1
    301e:	99 f7       	brne	.-26     	; 0x3006 <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3020:	10 92 04 0e 	sts	0x0E04, r1
    3024:	20 e0       	ldi	r18, 0x00	; 0
    3026:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3028:	f9 01       	movw	r30, r18
    302a:	e8 53       	subi	r30, 0x38	; 56
    302c:	f2 4f       	sbci	r31, 0xF2	; 242
    302e:	d9 01       	movw	r26, r18
    3030:	a6 56       	subi	r26, 0x66	; 102
    3032:	b4 4f       	sbci	r27, 0xF4	; 244
    3034:	8c 91       	ld	r24, X
    3036:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3038:	2f 5f       	subi	r18, 0xFF	; 255
    303a:	3f 4f       	sbci	r19, 0xFF	; 255
    303c:	23 31       	cpi	r18, 0x13	; 19
    303e:	31 05       	cpc	r19, r1
    3040:	99 f7       	brne	.-26     	; 0x3028 <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3042:	10 92 db 0d 	sts	0x0DDB, r1
    3046:	20 e0       	ldi	r18, 0x00	; 0
    3048:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    304a:	f9 01       	movw	r30, r18
    304c:	e4 54       	subi	r30, 0x44	; 68
    304e:	f2 4f       	sbci	r31, 0xF2	; 242
    3050:	d9 01       	movw	r26, r18
    3052:	a3 55       	subi	r26, 0x53	; 83
    3054:	b4 4f       	sbci	r27, 0xF4	; 244
    3056:	8c 91       	ld	r24, X
    3058:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    305a:	2f 5f       	subi	r18, 0xFF	; 255
    305c:	3f 4f       	sbci	r19, 0xFF	; 255
    305e:	27 30       	cpi	r18, 0x07	; 7
    3060:	31 05       	cpc	r19, r1
    3062:	99 f7       	brne	.-26     	; 0x304a <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3064:	10 92 c3 0d 	sts	0x0DC3, r1
    3068:	20 e0       	ldi	r18, 0x00	; 0
    306a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    306c:	f9 01       	movw	r30, r18
    306e:	ec 53       	subi	r30, 0x3C	; 60
    3070:	fd 4f       	sbci	r31, 0xFD	; 253
    3072:	d9 01       	movw	r26, r18
    3074:	ac 54       	subi	r26, 0x4C	; 76
    3076:	b4 4f       	sbci	r27, 0xF4	; 244
    3078:	8c 91       	ld	r24, X
    307a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    307c:	2f 5f       	subi	r18, 0xFF	; 255
    307e:	3f 4f       	sbci	r19, 0xFF	; 255
    3080:	24 30       	cpi	r18, 0x04	; 4
    3082:	31 05       	cpc	r19, r1
    3084:	99 f7       	brne	.-26     	; 0x306c <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3086:	10 92 c8 02 	sts	0x02C8, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    308a:	80 e0       	ldi	r24, 0x00	; 0
    308c:	08 95       	ret

0000308e <procMessage81>:
uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    308e:	cf 93       	push	r28
    3090:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    3092:	80 91 4b 0b 	lds	r24, 0x0B4B
    3096:	89 35       	cpi	r24, 0x59	; 89
    3098:	11 f4       	brne	.+4      	; 0x309e <procMessage81+0x10>
    309a:	90 e8       	ldi	r25, 0x80	; 128
    309c:	01 c0       	rjmp	.+2      	; 0x30a0 <procMessage81+0x12>
    309e:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    30a0:	80 91 4c 0b 	lds	r24, 0x0B4C
    30a4:	89 35       	cpi	r24, 0x59	; 89
    30a6:	09 f4       	brne	.+2      	; 0x30aa <procMessage81+0x1c>
    30a8:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    30aa:	80 91 4d 0b 	lds	r24, 0x0B4D
    30ae:	89 35       	cpi	r24, 0x59	; 89
    30b0:	09 f4       	brne	.+2      	; 0x30b4 <procMessage81+0x26>
    30b2:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    30b4:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    30b6:	80 91 4e 0b 	lds	r24, 0x0B4E
    30ba:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    30bc:	81 31       	cpi	r24, 0x11	; 17
    30be:	08 f4       	brcc	.+2      	; 0x30c2 <procMessage81+0x34>
    30c0:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    30c2:	c0 91 8f 01 	lds	r28, 0x018F
    30c6:	d0 91 90 01 	lds	r29, 0x0190
    30ca:	20 e0       	ldi	r18, 0x00	; 0
    30cc:	30 e0       	ldi	r19, 0x00	; 0
    30ce:	0b c0       	rjmp	.+22     	; 0x30e6 <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30d0:	f9 01       	movw	r30, r18
    30d2:	eb 50       	subi	r30, 0x0B	; 11
    30d4:	fc 4f       	sbci	r31, 0xFC	; 252
    30d6:	d9 01       	movw	r26, r18
    30d8:	aa 5d       	subi	r26, 0xDA	; 218
    30da:	b4 4f       	sbci	r27, 0xF4	; 244
    30dc:	9c 96       	adiw	r26, 0x2c	; 44
    30de:	8c 91       	ld	r24, X
    30e0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30e2:	2f 5f       	subi	r18, 0xFF	; 255
    30e4:	3f 4f       	sbci	r19, 0xFF	; 255
    30e6:	2c 17       	cp	r18, r28
    30e8:	3d 07       	cpc	r19, r29
    30ea:	90 f3       	brcs	.-28     	; 0x30d0 <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30ec:	cb 50       	subi	r28, 0x0B	; 11
    30ee:	dc 4f       	sbci	r29, 0xFC	; 252
    30f0:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    30f2:	89 2f       	mov	r24, r25
    30f4:	df 91       	pop	r29
    30f6:	cf 91       	pop	r28
    30f8:	08 95       	ret

000030fa <FillChar>:
	 if(CutType== 1) { uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    30fa:	20 e0       	ldi	r18, 0x00	; 0
    30fc:	30 e0       	ldi	r19, 0x00	; 0
    30fe:	06 c0       	rjmp	.+12     	; 0x310c <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    3100:	fc 01       	movw	r30, r24
    3102:	e2 0f       	add	r30, r18
    3104:	f3 1f       	adc	r31, r19
    3106:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    3108:	2f 5f       	subi	r18, 0xFF	; 255
    310a:	3f 4f       	sbci	r19, 0xFF	; 255
    310c:	26 17       	cp	r18, r22
    310e:	37 07       	cpc	r19, r23
    3110:	b8 f3       	brcs	.-18     	; 0x3100 <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    3112:	08 95       	ret

00003114 <ProcMessage91>:

void ProcMessage91(){
    3114:	20 e0       	ldi	r18, 0x00	; 0
    3116:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3118:	f9 01       	movw	r30, r18
    311a:	e0 56       	subi	r30, 0x60	; 96
    311c:	f1 4f       	sbci	r31, 0xF1	; 241
    311e:	d9 01       	movw	r26, r18
    3120:	aa 5d       	subi	r26, 0xDA	; 218
    3122:	b4 4f       	sbci	r27, 0xF4	; 244
    3124:	95 96       	adiw	r26, 0x25	; 37
    3126:	8c 91       	ld	r24, X
    3128:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    312a:	2f 5f       	subi	r18, 0xFF	; 255
    312c:	3f 4f       	sbci	r19, 0xFF	; 255
    312e:	26 30       	cpi	r18, 0x06	; 6
    3130:	31 05       	cpc	r19, r1
    3132:	91 f7       	brne	.-28     	; 0x3118 <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3134:	10 92 a6 0e 	sts	0x0EA6, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3138:	80 91 51 0b 	lds	r24, 0x0B51
    313c:	80 93 c2 07 	sts	0x07C2, r24
    3140:	80 91 52 0b 	lds	r24, 0x0B52
    3144:	80 93 c3 07 	sts	0x07C3, r24
	 }Dest[Length]=0;
    3148:	10 92 c4 07 	sts	0x07C4, r1
    314c:	20 e0       	ldi	r18, 0x00	; 0
    314e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3150:	f9 01       	movw	r30, r18
    3152:	eb 5e       	subi	r30, 0xEB	; 235
    3154:	f7 4f       	sbci	r31, 0xF7	; 247
    3156:	d9 01       	movw	r26, r18
    3158:	aa 5d       	subi	r26, 0xDA	; 218
    315a:	b4 4f       	sbci	r27, 0xF4	; 244
    315c:	9d 96       	adiw	r26, 0x2d	; 45
    315e:	8c 91       	ld	r24, X
    3160:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3162:	2f 5f       	subi	r18, 0xFF	; 255
    3164:	3f 4f       	sbci	r19, 0xFF	; 255
    3166:	2f 30       	cpi	r18, 0x0F	; 15
    3168:	31 05       	cpc	r19, r1
    316a:	91 f7       	brne	.-28     	; 0x3150 <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    316c:	10 92 24 08 	sts	0x0824, r1
    3170:	20 e0       	ldi	r18, 0x00	; 0
    3172:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3174:	f9 01       	movw	r30, r18
    3176:	e9 55       	subi	r30, 0x59	; 89
    3178:	fa 4f       	sbci	r31, 0xFA	; 250
    317a:	d9 01       	movw	r26, r18
    317c:	aa 5d       	subi	r26, 0xDA	; 218
    317e:	b4 4f       	sbci	r27, 0xF4	; 244
    3180:	dc 96       	adiw	r26, 0x3c	; 60
    3182:	8c 91       	ld	r24, X
    3184:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3186:	2f 5f       	subi	r18, 0xFF	; 255
    3188:	3f 4f       	sbci	r19, 0xFF	; 255
    318a:	26 30       	cpi	r18, 0x06	; 6
    318c:	31 05       	cpc	r19, r1
    318e:	91 f7       	brne	.-28     	; 0x3174 <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3190:	10 92 ad 05 	sts	0x05AD, r1
    3194:	20 e0       	ldi	r18, 0x00	; 0
    3196:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3198:	f9 01       	movw	r30, r18
    319a:	e2 58       	subi	r30, 0x82	; 130
    319c:	fc 4f       	sbci	r31, 0xFC	; 252
    319e:	d9 01       	movw	r26, r18
    31a0:	a8 59       	subi	r26, 0x98	; 152
    31a2:	b4 4f       	sbci	r27, 0xF4	; 244
    31a4:	8c 91       	ld	r24, X
    31a6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31a8:	2f 5f       	subi	r18, 0xFF	; 255
    31aa:	3f 4f       	sbci	r19, 0xFF	; 255
    31ac:	28 30       	cpi	r18, 0x08	; 8
    31ae:	31 05       	cpc	r19, r1
    31b0:	99 f7       	brne	.-26     	; 0x3198 <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31b2:	10 92 86 03 	sts	0x0386, r1
    31b6:	20 e0       	ldi	r18, 0x00	; 0
    31b8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31ba:	f9 01       	movw	r30, r18
    31bc:	e4 54       	subi	r30, 0x44	; 68
    31be:	f2 4f       	sbci	r31, 0xF2	; 242
    31c0:	d9 01       	movw	r26, r18
    31c2:	a0 59       	subi	r26, 0x90	; 144
    31c4:	b4 4f       	sbci	r27, 0xF4	; 244
    31c6:	8c 91       	ld	r24, X
    31c8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31ca:	2f 5f       	subi	r18, 0xFF	; 255
    31cc:	3f 4f       	sbci	r19, 0xFF	; 255
    31ce:	28 30       	cpi	r18, 0x08	; 8
    31d0:	31 05       	cpc	r19, r1
    31d2:	99 f7       	brne	.-26     	; 0x31ba <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31d4:	10 92 c4 0d 	sts	0x0DC4, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31d8:	80 91 78 0b 	lds	r24, 0x0B78
    31dc:	80 93 93 03 	sts	0x0393, r24
	 }Dest[Length]=0;
    31e0:	10 92 94 03 	sts	0x0394, r1
    31e4:	20 e0       	ldi	r18, 0x00	; 0
    31e6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31e8:	f9 01       	movw	r30, r18
    31ea:	eb 5f       	subi	r30, 0xFB	; 251
    31ec:	fc 4f       	sbci	r31, 0xFC	; 252
    31ee:	d9 01       	movw	r26, r18
    31f0:	a7 58       	subi	r26, 0x87	; 135
    31f2:	b4 4f       	sbci	r27, 0xF4	; 244
    31f4:	8c 91       	ld	r24, X
    31f6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31f8:	2f 5f       	subi	r18, 0xFF	; 255
    31fa:	3f 4f       	sbci	r19, 0xFF	; 255
    31fc:	29 30       	cpi	r18, 0x09	; 9
    31fe:	31 05       	cpc	r19, r1
    3200:	99 f7       	brne	.-26     	; 0x31e8 <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3202:	10 92 0e 03 	sts	0x030E, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    3206:	08 95       	ret

00003208 <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    3208:	1f 93       	push	r17
   if (STX==0x01){
    320a:	81 30       	cpi	r24, 0x01	; 1
    320c:	09 f0       	breq	.+2      	; 0x3210 <IdentifyMessage+0x8>
    320e:	5f c0       	rjmp	.+190    	; 0x32ce <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    3210:	6f 32       	cpi	r22, 0x2F	; 47
    3212:	71 05       	cpc	r23, r1
    3214:	21 f0       	breq	.+8      	; 0x321e <IdentifyMessage+0x16>
    3216:	80 91 14 01 	lds	r24, 0x0114
    321a:	88 23       	and	r24, r24
    321c:	21 f4       	brne	.+8      	; 0x3226 <IdentifyMessage+0x1e>
    321e:	81 e0       	ldi	r24, 0x01	; 1
    3220:	80 93 a0 01 	sts	0x01A0, r24
    3224:	4a c0       	rjmp	.+148    	; 0x32ba <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    3226:	6c 36       	cpi	r22, 0x6C	; 108
    3228:	71 05       	cpc	r23, r1
    322a:	11 f0       	breq	.+4      	; 0x3230 <IdentifyMessage+0x28>
    322c:	89 30       	cpi	r24, 0x09	; 9
    322e:	21 f4       	brne	.+8      	; 0x3238 <IdentifyMessage+0x30>
    3230:	81 e0       	ldi	r24, 0x01	; 1
    3232:	80 93 a5 01 	sts	0x01A5, r24
    3236:	41 c0       	rjmp	.+130    	; 0x32ba <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    3238:	92 e0       	ldi	r25, 0x02	; 2
    323a:	67 36       	cpi	r22, 0x67	; 103
    323c:	79 07       	cpc	r23, r25
    323e:	11 f0       	breq	.+4      	; 0x3244 <IdentifyMessage+0x3c>
    3240:	8b 30       	cpi	r24, 0x0B	; 11
    3242:	21 f4       	brne	.+8      	; 0x324c <IdentifyMessage+0x44>
    3244:	81 e0       	ldi	r24, 0x01	; 1
    3246:	80 93 a2 01 	sts	0x01A2, r24
    324a:	37 c0       	rjmp	.+110    	; 0x32ba <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    324c:	61 39       	cpi	r22, 0x91	; 145
    324e:	71 05       	cpc	r23, r1
    3250:	11 f0       	breq	.+4      	; 0x3256 <IdentifyMessage+0x4e>
    3252:	87 31       	cpi	r24, 0x17	; 23
    3254:	21 f4       	brne	.+8      	; 0x325e <IdentifyMessage+0x56>
    3256:	81 e0       	ldi	r24, 0x01	; 1
    3258:	80 93 a4 01 	sts	0x01A4, r24
    325c:	2e c0       	rjmp	.+92     	; 0x32ba <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    325e:	66 3e       	cpi	r22, 0xE6	; 230
    3260:	71 05       	cpc	r23, r1
    3262:	11 f0       	breq	.+4      	; 0x3268 <IdentifyMessage+0x60>
    3264:	89 33       	cpi	r24, 0x39	; 57
    3266:	21 f4       	brne	.+8      	; 0x3270 <IdentifyMessage+0x68>
    3268:	81 e0       	ldi	r24, 0x01	; 1
    326a:	80 93 a7 01 	sts	0x01A7, r24
    326e:	25 c0       	rjmp	.+74     	; 0x32ba <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    3270:	91 e0       	ldi	r25, 0x01	; 1
    3272:	68 39       	cpi	r22, 0x98	; 152
    3274:	79 07       	cpc	r23, r25
    3276:	11 f0       	breq	.+4      	; 0x327c <IdentifyMessage+0x74>
    3278:	83 36       	cpi	r24, 0x63	; 99
    327a:	21 f4       	brne	.+8      	; 0x3284 <IdentifyMessage+0x7c>
    327c:	81 e0       	ldi	r24, 0x01	; 1
    327e:	80 93 a1 01 	sts	0x01A1, r24
    3282:	1b c0       	rjmp	.+54     	; 0x32ba <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    3284:	91 e0       	ldi	r25, 0x01	; 1
    3286:	66 3b       	cpi	r22, 0xB6	; 182
    3288:	79 07       	cpc	r23, r25
    328a:	11 f0       	breq	.+4      	; 0x3290 <IdentifyMessage+0x88>
    328c:	81 35       	cpi	r24, 0x51	; 81
    328e:	21 f4       	brne	.+8      	; 0x3298 <IdentifyMessage+0x90>
    3290:	81 e0       	ldi	r24, 0x01	; 1
    3292:	80 93 a8 01 	sts	0x01A8, r24
    3296:	11 c0       	rjmp	.+34     	; 0x32ba <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    3298:	6c 35       	cpi	r22, 0x5C	; 92
    329a:	71 05       	cpc	r23, r1
    329c:	11 f0       	breq	.+4      	; 0x32a2 <IdentifyMessage+0x9a>
    329e:	8b 35       	cpi	r24, 0x5B	; 91
    32a0:	21 f4       	brne	.+8      	; 0x32aa <IdentifyMessage+0xa2>
    32a2:	81 e0       	ldi	r24, 0x01	; 1
    32a4:	80 93 a9 01 	sts	0x01A9, r24
    32a8:	08 c0       	rjmp	.+16     	; 0x32ba <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    32aa:	66 35       	cpi	r22, 0x56	; 86
    32ac:	71 05       	cpc	r23, r1
    32ae:	11 f0       	breq	.+4      	; 0x32b4 <IdentifyMessage+0xac>
    32b0:	85 31       	cpi	r24, 0x15	; 21
    32b2:	19 f4       	brne	.+6      	; 0x32ba <IdentifyMessage+0xb2>
    32b4:	81 e0       	ldi	r24, 0x01	; 1
    32b6:	80 93 a3 01 	sts	0x01A3, r24
        //EDC AdvanZ Respond
		if (IsMessage91==True){
    32ba:	10 91 a9 01 	lds	r17, 0x01A9
    32be:	11 30       	cpi	r17, 0x01	; 1
    32c0:	31 f4       	brne	.+12     	; 0x32ce <IdentifyMessage+0xc6>
		    IsMessage91=False;
    32c2:	10 92 a9 01 	sts	0x01A9, r1
		    ProcMessage91();
    32c6:	0e 94 8a 18 	call	0x3114	; 0x3114 <ProcMessage91>
			IsSendMessageEDC=True;
    32ca:	10 93 99 01 	sts	0x0199, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  uart_print(1,0,SerialSend);
	 }
}
    32ce:	1f 91       	pop	r17
    32d0:	08 95       	ret

000032d2 <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    32d2:	fc 01       	movw	r30, r24
    32d4:	dc 01       	movw	r26, r24
    32d6:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    32d8:	90 e2       	ldi	r25, 0x20	; 32
    32da:	02 c0       	rjmp	.+4      	; 0x32e0 <Tab+0xe>
    32dc:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    32de:	8f 5f       	subi	r24, 0xFF	; 255
    32e0:	86 17       	cp	r24, r22
    32e2:	e0 f3       	brcs	.-8      	; 0x32dc <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    32e4:	e6 0f       	add	r30, r22
    32e6:	f1 1d       	adc	r31, r1
    32e8:	10 82       	st	Z, r1
}
    32ea:	08 95       	ret

000032ec <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    32ec:	dc 01       	movw	r26, r24
    32ee:	20 e0       	ldi	r18, 0x00	; 0
    32f0:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    32f2:	9c 91       	ld	r25, X
    32f4:	90 53       	subi	r25, 0x30	; 48
    32f6:	9a 30       	cpi	r25, 0x0A	; 10
    32f8:	08 f0       	brcs	.+2      	; 0x32fc <StrToRaw+0x10>
    32fa:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    32fc:	11 96       	adiw	r26, 0x01	; 1
    32fe:	8c 91       	ld	r24, X
    3300:	11 97       	sbiw	r26, 0x01	; 1
    3302:	80 53       	subi	r24, 0x30	; 48
    3304:	8a 30       	cpi	r24, 0x0A	; 10
    3306:	08 f0       	brcs	.+2      	; 0x330a <StrToRaw+0x1e>
    3308:	80 e0       	ldi	r24, 0x00	; 0
    330a:	fb 01       	movw	r30, r22
    330c:	e2 0f       	add	r30, r18
    330e:	f3 1f       	adc	r31, r19
    3310:	8f 70       	andi	r24, 0x0F	; 15
    3312:	92 95       	swap	r25
    3314:	90 7f       	andi	r25, 0xF0	; 240
    3316:	98 2b       	or	r25, r24
    3318:	90 83       	st	Z, r25
    331a:	2f 5f       	subi	r18, 0xFF	; 255
    331c:	3f 4f       	sbci	r19, 0xFF	; 255
    331e:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    3320:	26 30       	cpi	r18, 0x06	; 6
    3322:	31 05       	cpc	r19, r1
    3324:	31 f7       	brne	.-52     	; 0x32f2 <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    3326:	08 95       	ret

00003328 <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    3328:	cf 93       	push	r28
    332a:	df 93       	push	r29
    332c:	eb 01       	movw	r28, r22
    332e:	db 01       	movw	r26, r22
    3330:	20 e0       	ldi	r18, 0x00	; 0
    3332:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    3334:	fc 01       	movw	r30, r24
    3336:	e2 0f       	add	r30, r18
    3338:	f3 1f       	adc	r31, r19
    333a:	e0 81       	ld	r30, Z
    333c:	4e 2f       	mov	r20, r30
    333e:	42 95       	swap	r20
    3340:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3342:	4a 30       	cpi	r20, 0x0A	; 10
    3344:	10 f0       	brcs	.+4      	; 0x334a <RawToStr+0x22>
    3346:	40 e3       	ldi	r20, 0x30	; 48
    3348:	01 c0       	rjmp	.+2      	; 0x334c <RawToStr+0x24>
	    Result='0'+X;
    334a:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    334c:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    334e:	ea 30       	cpi	r30, 0x0A	; 10
    3350:	10 f0       	brcs	.+4      	; 0x3356 <RawToStr+0x2e>
    3352:	e0 e3       	ldi	r30, 0x30	; 48
    3354:	01 c0       	rjmp	.+2      	; 0x3358 <RawToStr+0x30>
	    Result='0'+X;
    3356:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    3358:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    335a:	11 96       	adiw	r26, 0x01	; 1
    335c:	ec 93       	st	X, r30
    335e:	11 97       	sbiw	r26, 0x01	; 1
    3360:	2f 5f       	subi	r18, 0xFF	; 255
    3362:	3f 4f       	sbci	r19, 0xFF	; 255
    3364:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    3366:	26 30       	cpi	r18, 0x06	; 6
    3368:	31 05       	cpc	r19, r1
    336a:	21 f7       	brne	.-56     	; 0x3334 <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    336c:	1c 86       	std	Y+12, r1	; 0x0c
}
    336e:	df 91       	pop	r29
    3370:	cf 91       	pop	r28
    3372:	08 95       	ret

00003374 <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xC;//,xA,xB;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    3374:	86 17       	cp	r24, r22
    3376:	08 f4       	brcc	.+2      	; 0x337a <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    3378:	86 5f       	subi	r24, 0xF6	; 246
    337a:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    337c:	80 5d       	subi	r24, 0xD0	; 208
    337e:	08 95       	ret

00003380 <CalcPlus>:

char CalcPlus(char A, char B){
    3380:	80 56       	subi	r24, 0x60	; 96
    3382:	86 0f       	add	r24, r22
    3384:	6a e0       	ldi	r22, 0x0A	; 10
    3386:	0e 94 08 b4 	call	0x16810	; 0x16810 <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    338a:	89 2f       	mov	r24, r25
    338c:	80 5d       	subi	r24, 0xD0	; 208
    338e:	08 95       	ret

00003390 <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3390:	8a 30       	cpi	r24, 0x0A	; 10
    3392:	10 f0       	brcs	.+4      	; 0x3398 <Chr+0x8>
    3394:	80 e3       	ldi	r24, 0x30	; 48
    3396:	08 95       	ret
	    Result='0'+X;
    3398:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    339a:	08 95       	ret

0000339c <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    339c:	80 53       	subi	r24, 0x30	; 48
    339e:	8a 30       	cpi	r24, 0x0A	; 10
    33a0:	08 f0       	brcs	.+2      	; 0x33a4 <Ord+0x8>
    33a2:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    33a4:	08 95       	ret

000033a6 <FTestCalculation>:
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
*/
}
    33a6:	08 95       	ret

000033a8 <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    33a8:	48 2f       	mov	r20, r24
    33aa:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    33ac:	18 16       	cp	r1, r24
    33ae:	64 f4       	brge	.+24     	; 0x33c8 <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    33b0:	56 2f       	mov	r21, r22
    33b2:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    33b4:	90 e2       	ldi	r25, 0x20	; 32
    33b6:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    33b8:	8a 2f       	mov	r24, r26
    33ba:	85 1b       	sub	r24, r21
    33bc:	84 17       	cp	r24, r20
    33be:	d8 f3       	brcs	.-10     	; 0x33b6 <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    33c0:	e4 0f       	add	r30, r20
    33c2:	f1 1d       	adc	r31, r1
    33c4:	10 82       	st	Z, r1
    33c6:	08 95       	ret
     }else{
	 strTab[0]=' ';
    33c8:	80 e2       	ldi	r24, 0x20	; 32
    33ca:	80 83       	st	Z, r24
	 strTab[1]=0;
    33cc:	11 82       	std	Z+1, r1	; 0x01
    33ce:	08 95       	ret

000033d0 <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    33d0:	86 30       	cpi	r24, 0x06	; 6
    33d2:	51 f1       	breq	.+84     	; 0x3428 <GetBorderValue+0x58>
    33d4:	87 30       	cpi	r24, 0x07	; 7
    33d6:	70 f4       	brcc	.+28     	; 0x33f4 <GetBorderValue+0x24>
    33d8:	83 30       	cpi	r24, 0x03	; 3
    33da:	11 f1       	breq	.+68     	; 0x3420 <GetBorderValue+0x50>
    33dc:	84 30       	cpi	r24, 0x04	; 4
    33de:	28 f4       	brcc	.+10     	; 0x33ea <GetBorderValue+0x1a>
    33e0:	81 30       	cpi	r24, 0x01	; 1
    33e2:	c1 f0       	breq	.+48     	; 0x3414 <GetBorderValue+0x44>
    33e4:	82 30       	cpi	r24, 0x02	; 2
    33e6:	c1 f4       	brne	.+48     	; 0x3418 <GetBorderValue+0x48>
    33e8:	19 c0       	rjmp	.+50     	; 0x341c <GetBorderValue+0x4c>
    33ea:	84 30       	cpi	r24, 0x04	; 4
    33ec:	d9 f0       	breq	.+54     	; 0x3424 <GetBorderValue+0x54>
    33ee:	85 30       	cpi	r24, 0x05	; 5
    33f0:	99 f4       	brne	.+38     	; 0x3418 <GetBorderValue+0x48>
    33f2:	22 c0       	rjmp	.+68     	; 0x3438 <GetBorderValue+0x68>
    33f4:	89 30       	cpi	r24, 0x09	; 9
    33f6:	f1 f0       	breq	.+60     	; 0x3434 <GetBorderValue+0x64>
    33f8:	8a 30       	cpi	r24, 0x0A	; 10
    33fa:	28 f4       	brcc	.+10     	; 0x3406 <GetBorderValue+0x36>
    33fc:	87 30       	cpi	r24, 0x07	; 7
    33fe:	b1 f0       	breq	.+44     	; 0x342c <GetBorderValue+0x5c>
    3400:	88 30       	cpi	r24, 0x08	; 8
    3402:	51 f4       	brne	.+20     	; 0x3418 <GetBorderValue+0x48>
    3404:	15 c0       	rjmp	.+42     	; 0x3430 <GetBorderValue+0x60>
    3406:	8b 30       	cpi	r24, 0x0B	; 11
    3408:	d9 f0       	breq	.+54     	; 0x3440 <GetBorderValue+0x70>
    340a:	8b 30       	cpi	r24, 0x0B	; 11
    340c:	b8 f0       	brcs	.+46     	; 0x343c <GetBorderValue+0x6c>
    340e:	8c 30       	cpi	r24, 0x0C	; 12
    3410:	19 f4       	brne	.+6      	; 0x3418 <GetBorderValue+0x48>
    3412:	18 c0       	rjmp	.+48     	; 0x3444 <GetBorderValue+0x74>
    3414:	8a ed       	ldi	r24, 0xDA	; 218
    3416:	08 95       	ret
    3418:	80 e0       	ldi	r24, 0x00	; 0
    341a:	08 95       	ret
    341c:	82 ec       	ldi	r24, 0xC2	; 194
    341e:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    3420:	8f eb       	ldi	r24, 0xBF	; 191
    3422:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    3424:	83 ec       	ldi	r24, 0xC3	; 195
    3426:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    3428:	84 eb       	ldi	r24, 0xB4	; 180
    342a:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    342c:	80 ec       	ldi	r24, 0xC0	; 192
    342e:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    3430:	81 ec       	ldi	r24, 0xC1	; 193
    3432:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    3434:	89 ed       	ldi	r24, 0xD9	; 217
    3436:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    3438:	85 ec       	ldi	r24, 0xC5	; 197
    343a:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    343c:	83 eb       	ldi	r24, 0xB3	; 179
    343e:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    3440:	84 ec       	ldi	r24, 0xC4	; 196
    3442:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    3444:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    3446:	08 95       	ret

00003448 <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    3448:	bf 92       	push	r11
    344a:	cf 92       	push	r12
    344c:	df 92       	push	r13
    344e:	ef 92       	push	r14
    3450:	ff 92       	push	r15
    3452:	0f 93       	push	r16
    3454:	1f 93       	push	r17
    3456:	cf 93       	push	r28
    3458:	df 93       	push	r29
    345a:	b8 2e       	mov	r11, r24
    345c:	8b 01       	movw	r16, r22
    345e:	e4 2e       	mov	r14, r20
    3460:	69 01       	movw	r12, r18
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    3462:	f9 01       	movw	r30, r18
    3464:	c0 81       	ld	r28, Z
    3466:	d1 81       	ldd	r29, Z+1	; 0x01
    3468:	0c 0f       	add	r16, r28
    346a:	1d 1f       	adc	r17, r29
    346c:	ff 24       	eor	r15, r15
    346e:	07 c0       	rjmp	.+14     	; 0x347e <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    3470:	8b 2d       	mov	r24, r11
    3472:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <GetBorderValue>
    3476:	f8 01       	movw	r30, r16
    3478:	81 93       	st	Z+, r24
    347a:	8f 01       	movw	r16, r30
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    347c:	f3 94       	inc	r15
    347e:	fe 14       	cp	r15, r14
    3480:	b8 f3       	brcs	.-18     	; 0x3470 <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    3482:	ce 0d       	add	r28, r14
    3484:	d1 1d       	adc	r29, r1
    3486:	f6 01       	movw	r30, r12
    3488:	d1 83       	std	Z+1, r29	; 0x01
    348a:	c0 83       	st	Z, r28
}
    348c:	df 91       	pop	r29
    348e:	cf 91       	pop	r28
    3490:	1f 91       	pop	r17
    3492:	0f 91       	pop	r16
    3494:	ff 90       	pop	r15
    3496:	ef 90       	pop	r14
    3498:	df 90       	pop	r13
    349a:	cf 90       	pop	r12
    349c:	bf 90       	pop	r11
    349e:	08 95       	ret

000034a0 <TestUserInput>:
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
  */
}
    34a0:	08 95       	ret

000034a2 <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    34a2:	08 95       	ret

000034a4 <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    34a4:	08 95       	ret

000034a6 <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    34a6:	08 95       	ret

000034a8 <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    34a8:	08 95       	ret

000034aa <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    34aa:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    34ac:	28 2f       	mov	r18, r24
    34ae:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    34b0:	82 2f       	mov	r24, r18
    34b2:	86 95       	lsr	r24
    34b4:	86 95       	lsr	r24
    34b6:	86 95       	lsr	r24
    34b8:	a8 2f       	mov	r26, r24
    34ba:	b0 e0       	ldi	r27, 0x00	; 0
    34bc:	af 51       	subi	r26, 0x1F	; 31
    34be:	b2 4f       	sbci	r27, 0xF2	; 242
    34c0:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    34c2:	62 30       	cpi	r22, 0x02	; 2
    34c4:	59 f4       	brne	.+22     	; 0x34dc <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    34c6:	27 70       	andi	r18, 0x07	; 7
    34c8:	81 e0       	ldi	r24, 0x01	; 1
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	02 c0       	rjmp	.+4      	; 0x34d2 <SetIncomingTransStatus+0x28>
    34ce:	88 0f       	add	r24, r24
    34d0:	99 1f       	adc	r25, r25
    34d2:	2a 95       	dec	r18
    34d4:	e2 f7       	brpl	.-8      	; 0x34ce <SetIncomingTransStatus+0x24>
    34d6:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    34d8:	4c 93       	st	X, r20
    34da:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    34dc:	63 30       	cpi	r22, 0x03	; 3
    34de:	b1 f4       	brne	.+44     	; 0x350c <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    34e0:	27 70       	andi	r18, 0x07	; 7
    34e2:	8e ef       	ldi	r24, 0xFE	; 254
    34e4:	90 e0       	ldi	r25, 0x00	; 0
    34e6:	01 c0       	rjmp	.+2      	; 0x34ea <SetIncomingTransStatus+0x40>
    34e8:	88 0f       	add	r24, r24
    34ea:	2a 95       	dec	r18
    34ec:	ea f7       	brpl	.-6      	; 0x34e8 <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    34ee:	e6 95       	lsr	r30
    34f0:	e6 95       	lsr	r30
    34f2:	e6 95       	lsr	r30
    34f4:	f0 e0       	ldi	r31, 0x00	; 0
    34f6:	ef 51       	subi	r30, 0x1F	; 31
    34f8:	f2 4f       	sbci	r31, 0xF2	; 242
    34fa:	28 2f       	mov	r18, r24
    34fc:	30 e0       	ldi	r19, 0x00	; 0
    34fe:	20 95       	com	r18
    3500:	30 95       	com	r19
    3502:	35 95       	asr	r19
    3504:	27 95       	ror	r18
    3506:	82 2b       	or	r24, r18
    3508:	84 23       	and	r24, r20
    350a:	80 83       	st	Z, r24
    350c:	08 95       	ret

0000350e <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    350e:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    3510:	e8 2f       	mov	r30, r24
    3512:	e6 95       	lsr	r30
    3514:	e6 95       	lsr	r30
    3516:	e6 95       	lsr	r30
    3518:	f0 e0       	ldi	r31, 0x00	; 0
    351a:	ef 51       	subi	r30, 0x1F	; 31
    351c:	f2 4f       	sbci	r31, 0xF2	; 242
    351e:	90 81       	ld	r25, Z
    3520:	29 2f       	mov	r18, r25
    3522:	30 e0       	ldi	r19, 0x00	; 0
    3524:	87 70       	andi	r24, 0x07	; 7
    3526:	02 c0       	rjmp	.+4      	; 0x352c <GetIncomingTransStatus+0x1e>
    3528:	35 95       	asr	r19
    352a:	27 95       	ror	r18
    352c:	8a 95       	dec	r24
    352e:	e2 f7       	brpl	.-8      	; 0x3528 <GetIncomingTransStatus+0x1a>
    3530:	21 30       	cpi	r18, 0x01	; 1
    3532:	31 05       	cpc	r19, r1
    3534:	11 f4       	brne	.+4      	; 0x353a <GetIncomingTransStatus+0x2c>
    3536:	82 e0       	ldi	r24, 0x02	; 2
    3538:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    353a:	23 2b       	or	r18, r19
    353c:	11 f4       	brne	.+4      	; 0x3542 <GetIncomingTransStatus+0x34>
    353e:	83 e0       	ldi	r24, 0x03	; 3
    3540:	08 95       	ret
    3542:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    3544:	08 95       	ret

00003546 <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    3546:	df 93       	push	r29
    3548:	cf 93       	push	r28
    354a:	00 d0       	rcall	.+0      	; 0x354c <SetDispenser+0x6>
    354c:	00 d0       	rcall	.+0      	; 0x354e <SetDispenser+0x8>
    354e:	0f 92       	push	r0
    3550:	cd b7       	in	r28, 0x3d	; 61
    3552:	de b7       	in	r29, 0x3e	; 62
    3554:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3556:	e1 99       	sbic	0x1c, 1	; 28
    3558:	fe cf       	rjmp	.-4      	; 0x3556 <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    355a:	27 e3       	ldi	r18, 0x37	; 55
    355c:	31 e0       	ldi	r19, 0x01	; 1
    355e:	3f bb       	out	0x1f, r19	; 31
    3560:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3562:	e0 9a       	sbi	0x1c, 0	; 28
    3564:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    3566:	89 17       	cp	r24, r25
    3568:	51 f0       	breq	.+20     	; 0x357e <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    356a:	e1 99       	sbic	0x1c, 1	; 28
    356c:	fe cf       	rjmp	.-4      	; 0x356a <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    356e:	3f bb       	out	0x1f, r19	; 31
    3570:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    3572:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3574:	0f b6       	in	r0, 0x3f	; 63
    3576:	f8 94       	cli
    3578:	e2 9a       	sbi	0x1c, 2	; 28
    357a:	e1 9a       	sbi	0x1c, 1	; 28
    357c:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    357e:	91 30       	cpi	r25, 0x01	; 1
    3580:	19 f0       	breq	.+6      	; 0x3588 <SetDispenser+0x42>
    3582:	92 30       	cpi	r25, 0x02	; 2
    3584:	71 f4       	brne	.+28     	; 0x35a2 <SetDispenser+0x5c>
    3586:	08 c0       	rjmp	.+16     	; 0x3598 <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    3588:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    358a:	83 e0       	ldi	r24, 0x03	; 3
    358c:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    358e:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3590:	82 e0       	ldi	r24, 0x02	; 2
    3592:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    3594:	1d 82       	std	Y+5, r1	; 0x05
    3596:	05 c0       	rjmp	.+10     	; 0x35a2 <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    3598:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    359a:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    359c:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    359e:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    35a0:	9d 83       	std	Y+5, r25	; 0x05
    35a2:	29 e3       	ldi	r18, 0x39	; 57
    35a4:	30 e0       	ldi	r19, 0x00	; 0
    35a6:	fe 01       	movw	r30, r28
    35a8:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    35aa:	e1 99       	sbic	0x1c, 1	; 28
    35ac:	fe cf       	rjmp	.-4      	; 0x35aa <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    35ae:	3f bb       	out	0x1f, r19	; 31
    35b0:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    35b2:	e0 9a       	sbi	0x1c, 0	; 28
    35b4:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    35b6:	90 81       	ld	r25, Z
    35b8:	89 17       	cp	r24, r25
    35ba:	51 f0       	breq	.+20     	; 0x35d0 <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    35bc:	e1 99       	sbic	0x1c, 1	; 28
    35be:	fe cf       	rjmp	.-4      	; 0x35bc <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    35c0:	3f bb       	out	0x1f, r19	; 31
    35c2:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    35c4:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    35c6:	0f b6       	in	r0, 0x3f	; 63
    35c8:	f8 94       	cli
    35ca:	e2 9a       	sbi	0x1c, 2	; 28
    35cc:	e1 9a       	sbi	0x1c, 1	; 28
    35ce:	0f be       	out	0x3f, r0	; 63
    35d0:	2f 5f       	subi	r18, 0xFF	; 255
    35d2:	3f 4f       	sbci	r19, 0xFF	; 255
    35d4:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    35d6:	80 e0       	ldi	r24, 0x00	; 0
    35d8:	2e 33       	cpi	r18, 0x3E	; 62
    35da:	38 07       	cpc	r19, r24
    35dc:	31 f7       	brne	.-52     	; 0x35aa <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    35de:	0f 90       	pop	r0
    35e0:	0f 90       	pop	r0
    35e2:	0f 90       	pop	r0
    35e4:	0f 90       	pop	r0
    35e6:	0f 90       	pop	r0
    35e8:	cf 91       	pop	r28
    35ea:	df 91       	pop	r29
    35ec:	08 95       	ret

000035ee <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    35ee:	df 93       	push	r29
    35f0:	cf 93       	push	r28
    35f2:	cd b7       	in	r28, 0x3d	; 61
    35f4:	de b7       	in	r29, 0x3e	; 62
    35f6:	62 97       	sbiw	r28, 0x12	; 18
    35f8:	0f b6       	in	r0, 0x3f	; 63
    35fa:	f8 94       	cli
    35fc:	de bf       	out	0x3e, r29	; 62
    35fe:	0f be       	out	0x3f, r0	; 63
    3600:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3602:	20 91 c3 03 	lds	r18, 0x03C3
    3606:	2f 83       	std	Y+7, r18	; 0x07
    3608:	20 91 c4 03 	lds	r18, 0x03C4
    360c:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    360e:	20 91 c6 03 	lds	r18, 0x03C6
    3612:	2c 83       	std	Y+4, r18	; 0x04
    3614:	20 91 c7 03 	lds	r18, 0x03C7
    3618:	2d 83       	std	Y+5, r18	; 0x05
    361a:	20 91 c9 03 	lds	r18, 0x03C9
    361e:	29 83       	std	Y+1, r18	; 0x01
    3620:	20 91 ca 03 	lds	r18, 0x03CA
    3624:	2a 83       	std	Y+2, r18	; 0x02
    3626:	20 91 7d 08 	lds	r18, 0x087D
    362a:	2a 87       	std	Y+10, r18	; 0x0a
    362c:	20 91 7e 08 	lds	r18, 0x087E
    3630:	2b 87       	std	Y+11, r18	; 0x0b
    3632:	20 91 80 08 	lds	r18, 0x0880
    3636:	2d 87       	std	Y+13, r18	; 0x0d
    3638:	20 91 81 08 	lds	r18, 0x0881
    363c:	2e 87       	std	Y+14, r18	; 0x0e
    363e:	20 91 83 08 	lds	r18, 0x0883
    3642:	28 8b       	std	Y+16, r18	; 0x10
    3644:	20 91 84 08 	lds	r18, 0x0884
    3648:	29 8b       	std	Y+17, r18	; 0x11
    364a:	1a 8a       	std	Y+18, r1	; 0x12
    364c:	1f 86       	std	Y+15, r1	; 0x0f
    364e:	1c 86       	std	Y+12, r1	; 0x0c
    3650:	1b 82       	std	Y+3, r1	; 0x03
    3652:	1e 82       	std	Y+6, r1	; 0x06
    3654:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    3656:	2d b7       	in	r18, 0x3d	; 61
    3658:	3e b7       	in	r19, 0x3e	; 62
    365a:	20 51       	subi	r18, 0x10	; 16
    365c:	30 40       	sbci	r19, 0x00	; 0
    365e:	0f b6       	in	r0, 0x3f	; 63
    3660:	f8 94       	cli
    3662:	3e bf       	out	0x3e, r19	; 62
    3664:	0f be       	out	0x3f, r0	; 63
    3666:	2d bf       	out	0x3d, r18	; 61
    3668:	ed b7       	in	r30, 0x3d	; 61
    366a:	fe b7       	in	r31, 0x3e	; 62
    366c:	31 96       	adiw	r30, 0x01	; 1
    366e:	ad b7       	in	r26, 0x3d	; 61
    3670:	be b7       	in	r27, 0x3e	; 62
    3672:	12 96       	adiw	r26, 0x02	; 2
    3674:	9c 93       	st	X, r25
    3676:	8e 93       	st	-X, r24
    3678:	11 97       	sbiw	r26, 0x01	; 1
    367a:	8b e9       	ldi	r24, 0x9B	; 155
    367c:	94 e0       	ldi	r25, 0x04	; 4
    367e:	93 83       	std	Z+3, r25	; 0x03
    3680:	82 83       	std	Z+2, r24	; 0x02
    3682:	ce 01       	movw	r24, r28
    3684:	01 96       	adiw	r24, 0x01	; 1
    3686:	95 83       	std	Z+5, r25	; 0x05
    3688:	84 83       	std	Z+4, r24	; 0x04
    368a:	ce 01       	movw	r24, r28
    368c:	04 96       	adiw	r24, 0x04	; 4
    368e:	97 83       	std	Z+7, r25	; 0x07
    3690:	86 83       	std	Z+6, r24	; 0x06
    3692:	ce 01       	movw	r24, r28
    3694:	07 96       	adiw	r24, 0x07	; 7
    3696:	91 87       	std	Z+9, r25	; 0x09
    3698:	80 87       	std	Z+8, r24	; 0x08
    369a:	ce 01       	movw	r24, r28
    369c:	0a 96       	adiw	r24, 0x0a	; 10
    369e:	93 87       	std	Z+11, r25	; 0x0b
    36a0:	82 87       	std	Z+10, r24	; 0x0a
    36a2:	ce 01       	movw	r24, r28
    36a4:	0d 96       	adiw	r24, 0x0d	; 13
    36a6:	95 87       	std	Z+13, r25	; 0x0d
    36a8:	84 87       	std	Z+12, r24	; 0x0c
    36aa:	ce 01       	movw	r24, r28
    36ac:	40 96       	adiw	r24, 0x10	; 16
    36ae:	97 87       	std	Z+15, r25	; 0x0f
    36b0:	86 87       	std	Z+14, r24	; 0x0e
    36b2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    36b6:	2d b7       	in	r18, 0x3d	; 61
    36b8:	3e b7       	in	r19, 0x3e	; 62
    36ba:	20 5f       	subi	r18, 0xF0	; 240
    36bc:	3f 4f       	sbci	r19, 0xFF	; 255
    36be:	0f b6       	in	r0, 0x3f	; 63
    36c0:	f8 94       	cli
    36c2:	3e bf       	out	0x3e, r19	; 62
    36c4:	0f be       	out	0x3f, r0	; 63
    36c6:	2d bf       	out	0x3d, r18	; 61
}
    36c8:	62 96       	adiw	r28, 0x12	; 18
    36ca:	0f b6       	in	r0, 0x3f	; 63
    36cc:	f8 94       	cli
    36ce:	de bf       	out	0x3e, r29	; 62
    36d0:	0f be       	out	0x3f, r0	; 63
    36d2:	cd bf       	out	0x3d, r28	; 61
    36d4:	cf 91       	pop	r28
    36d6:	df 91       	pop	r29
    36d8:	08 95       	ret

000036da <leadingZero>:
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    36da:	00 d0       	rcall	.+0      	; 0x36dc <leadingZero+0x2>
    36dc:	00 d0       	rcall	.+0      	; 0x36de <leadingZero+0x4>
    36de:	00 d0       	rcall	.+0      	; 0x36e0 <leadingZero+0x6>
    36e0:	ed b7       	in	r30, 0x3d	; 61
    36e2:	fe b7       	in	r31, 0x3e	; 62
    36e4:	31 96       	adiw	r30, 0x01	; 1
    36e6:	ad b7       	in	r26, 0x3d	; 61
    36e8:	be b7       	in	r27, 0x3e	; 62
    36ea:	12 96       	adiw	r26, 0x02	; 2
    36ec:	7c 93       	st	X, r23
    36ee:	6e 93       	st	-X, r22
    36f0:	11 97       	sbiw	r26, 0x01	; 1
    36f2:	2f e4       	ldi	r18, 0x4F	; 79
    36f4:	3e e0       	ldi	r19, 0x0E	; 14
    36f6:	33 83       	std	Z+3, r19	; 0x03
    36f8:	22 83       	std	Z+2, r18	; 0x02
    36fa:	84 83       	std	Z+4, r24	; 0x04
    36fc:	15 82       	std	Z+5, r1	; 0x05
    36fe:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    3702:	8d b7       	in	r24, 0x3d	; 61
    3704:	9e b7       	in	r25, 0x3e	; 62
    3706:	06 96       	adiw	r24, 0x06	; 6
    3708:	0f b6       	in	r0, 0x3f	; 63
    370a:	f8 94       	cli
    370c:	9e bf       	out	0x3e, r25	; 62
    370e:	0f be       	out	0x3f, r0	; 63
    3710:	8d bf       	out	0x3d, r24	; 61

}
    3712:	08 95       	ret

00003714 <FTestChar>:
		TimTicker++;
	}

}

char FTestChar(){
    3714:	0f 93       	push	r16
    3716:	1f 93       	push	r17
    3718:	df 93       	push	r29
    371a:	cf 93       	push	r28
    371c:	cd b7       	in	r28, 0x3d	; 61
    371e:	de b7       	in	r29, 0x3e	; 62
    3720:	64 97       	sbiw	r28, 0x14	; 20
    3722:	0f b6       	in	r0, 0x3f	; 63
    3724:	f8 94       	cli
    3726:	de bf       	out	0x3e, r29	; 62
    3728:	0f be       	out	0x3f, r0	; 63
    372a:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    372c:	8d b7       	in	r24, 0x3d	; 61
    372e:	9e b7       	in	r25, 0x3e	; 62
    3730:	08 97       	sbiw	r24, 0x08	; 8
    3732:	0f b6       	in	r0, 0x3f	; 63
    3734:	f8 94       	cli
    3736:	9e bf       	out	0x3e, r25	; 62
    3738:	0f be       	out	0x3f, r0	; 63
    373a:	8d bf       	out	0x3d, r24	; 61
    373c:	ed b7       	in	r30, 0x3d	; 61
    373e:	fe b7       	in	r31, 0x3e	; 62
    3740:	31 96       	adiw	r30, 0x01	; 1
    3742:	8e 01       	movw	r16, r28
    3744:	0f 5f       	subi	r16, 0xFF	; 255
    3746:	1f 4f       	sbci	r17, 0xFF	; 255
    3748:	ad b7       	in	r26, 0x3d	; 61
    374a:	be b7       	in	r27, 0x3e	; 62
    374c:	12 96       	adiw	r26, 0x02	; 2
    374e:	1c 93       	st	X, r17
    3750:	0e 93       	st	-X, r16
    3752:	11 97       	sbiw	r26, 0x01	; 1
    3754:	8d e0       	ldi	r24, 0x0D	; 13
    3756:	9d e1       	ldi	r25, 0x1D	; 29
    3758:	93 83       	std	Z+3, r25	; 0x03
    375a:	82 83       	std	Z+2, r24	; 0x02
    375c:	15 82       	std	Z+5, r1	; 0x05
    375e:	14 82       	std	Z+4, r1	; 0x04
    3760:	17 82       	std	Z+7, r1	; 0x07
    3762:	16 82       	std	Z+6, r1	; 0x06
    3764:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
     lcd_print(1,1,lcdteks);
    3768:	8d b7       	in	r24, 0x3d	; 61
    376a:	9e b7       	in	r25, 0x3e	; 62
    376c:	08 96       	adiw	r24, 0x08	; 8
    376e:	0f b6       	in	r0, 0x3f	; 63
    3770:	f8 94       	cli
    3772:	9e bf       	out	0x3e, r25	; 62
    3774:	0f be       	out	0x3f, r0	; 63
    3776:	8d bf       	out	0x3d, r24	; 61
    3778:	81 e0       	ldi	r24, 0x01	; 1
    377a:	61 e0       	ldi	r22, 0x01	; 1
    377c:	a8 01       	movw	r20, r16
    377e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    3782:	88 ee       	ldi	r24, 0xE8	; 232
    3784:	9d ef       	ldi	r25, 0xFD	; 253
    3786:	29 e1       	ldi	r18, 0x19	; 25
    3788:	30 e0       	ldi	r19, 0x00	; 0
    378a:	f9 01       	movw	r30, r18
    378c:	31 97       	sbiw	r30, 0x01	; 1
    378e:	f1 f7       	brne	.-4      	; 0x378c <FTestChar+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3790:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3792:	d9 f7       	brne	.-10     	; 0x378a <FTestChar+0x76>
	 if (i==0xFF)Result=MENU_DONE;
	 i++;
     _delay_ms(6500);
  return Result;
}
    3794:	80 e0       	ldi	r24, 0x00	; 0
    3796:	64 96       	adiw	r28, 0x14	; 20
    3798:	0f b6       	in	r0, 0x3f	; 63
    379a:	f8 94       	cli
    379c:	de bf       	out	0x3e, r29	; 62
    379e:	0f be       	out	0x3f, r0	; 63
    37a0:	cd bf       	out	0x3d, r28	; 61
    37a2:	cf 91       	pop	r28
    37a4:	df 91       	pop	r29
    37a6:	1f 91       	pop	r17
    37a8:	0f 91       	pop	r16
    37aa:	08 95       	ret

000037ac <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    37ac:	0f 93       	push	r16
    37ae:	1f 93       	push	r17
    37b0:	df 93       	push	r29
    37b2:	cf 93       	push	r28
    37b4:	cd b7       	in	r28, 0x3d	; 61
    37b6:	de b7       	in	r29, 0x3e	; 62
    37b8:	a8 97       	sbiw	r28, 0x28	; 40
    37ba:	0f b6       	in	r0, 0x3f	; 63
    37bc:	f8 94       	cli
    37be:	de bf       	out	0x3e, r29	; 62
    37c0:	0f be       	out	0x3f, r0	; 63
    37c2:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    37c4:	80 91 01 01 	lds	r24, 0x0101
    37c8:	81 30       	cpi	r24, 0x01	; 1
    37ca:	09 f0       	breq	.+2      	; 0x37ce <DisplayPumpStatus+0x22>
    37cc:	4a c0       	rjmp	.+148    	; 0x3862 <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    37ce:	10 92 01 01 	sts	0x0101, r1
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    37d2:	80 93 b7 02 	sts	0x02B7, r24
	 __key_lgtcnt = 0; 
    37d6:	10 92 b8 02 	sts	0x02B8, r1
	 PORTG=PORTG&0b11111101;
    37da:	80 91 65 00 	lds	r24, 0x0065
    37de:	8d 7f       	andi	r24, 0xFD	; 253
    37e0:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    37e4:	80 91 4e 01 	lds	r24, 0x014E
    37e8:	48 2f       	mov	r20, r24
    37ea:	50 e0       	ldi	r21, 0x00	; 0
    37ec:	20 e0       	ldi	r18, 0x00	; 0
    37ee:	30 e0       	ldi	r19, 0x00	; 0
    37f0:	be 01       	movw	r22, r28
    37f2:	6f 5f       	subi	r22, 0xFF	; 255
    37f4:	7f 4f       	sbci	r23, 0xFF	; 255
    37f6:	0a c0       	rjmp	.+20     	; 0x380c <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    37f8:	fb 01       	movw	r30, r22
    37fa:	e2 0f       	add	r30, r18
    37fc:	f3 1f       	adc	r31, r19
    37fe:	d9 01       	movw	r26, r18
    3800:	ae 5f       	subi	r26, 0xFE	; 254
    3802:	be 4f       	sbci	r27, 0xFE	; 254
    3804:	8c 91       	ld	r24, X
    3806:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3808:	2f 5f       	subi	r18, 0xFF	; 255
    380a:	3f 4f       	sbci	r19, 0xFF	; 255
    380c:	24 17       	cp	r18, r20
    380e:	35 07       	cpc	r19, r21
    3810:	98 f3       	brcs	.-26     	; 0x37f8 <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3812:	46 0f       	add	r20, r22
    3814:	57 1f       	adc	r21, r23
    3816:	da 01       	movw	r26, r20
    3818:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    381a:	00 d0       	rcall	.+0      	; 0x381c <DisplayPumpStatus+0x70>
    381c:	00 d0       	rcall	.+0      	; 0x381e <DisplayPumpStatus+0x72>
    381e:	00 d0       	rcall	.+0      	; 0x3820 <DisplayPumpStatus+0x74>
    3820:	ed b7       	in	r30, 0x3d	; 61
    3822:	fe b7       	in	r31, 0x3e	; 62
    3824:	31 96       	adiw	r30, 0x01	; 1
    3826:	8e 01       	movw	r16, r28
    3828:	0b 5e       	subi	r16, 0xEB	; 235
    382a:	1f 4f       	sbci	r17, 0xFF	; 255
    382c:	ad b7       	in	r26, 0x3d	; 61
    382e:	be b7       	in	r27, 0x3e	; 62
    3830:	12 96       	adiw	r26, 0x02	; 2
    3832:	1c 93       	st	X, r17
    3834:	0e 93       	st	-X, r16
    3836:	11 97       	sbiw	r26, 0x01	; 1
    3838:	84 eb       	ldi	r24, 0xB4	; 180
    383a:	92 e2       	ldi	r25, 0x22	; 34
    383c:	93 83       	std	Z+3, r25	; 0x03
    383e:	82 83       	std	Z+2, r24	; 0x02
    3840:	75 83       	std	Z+5, r23	; 0x05
    3842:	64 83       	std	Z+4, r22	; 0x04
    3844:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
         lcd_print(4,1,lcdteks);
    3848:	ed b7       	in	r30, 0x3d	; 61
    384a:	fe b7       	in	r31, 0x3e	; 62
    384c:	36 96       	adiw	r30, 0x06	; 6
    384e:	0f b6       	in	r0, 0x3f	; 63
    3850:	f8 94       	cli
    3852:	fe bf       	out	0x3e, r31	; 62
    3854:	0f be       	out	0x3f, r0	; 63
    3856:	ed bf       	out	0x3d, r30	; 61
    3858:	84 e0       	ldi	r24, 0x04	; 4
    385a:	61 e0       	ldi	r22, 0x01	; 1
    385c:	a8 01       	movw	r20, r16
    385e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
     	 }
}
    3862:	a8 96       	adiw	r28, 0x28	; 40
    3864:	0f b6       	in	r0, 0x3f	; 63
    3866:	f8 94       	cli
    3868:	de bf       	out	0x3e, r29	; 62
    386a:	0f be       	out	0x3f, r0	; 63
    386c:	cd bf       	out	0x3d, r28	; 61
    386e:	cf 91       	pop	r28
    3870:	df 91       	pop	r29
    3872:	1f 91       	pop	r17
    3874:	0f 91       	pop	r16
    3876:	08 95       	ret

00003878 <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    3878:	80 91 76 02 	lds	r24, 0x0276
    387c:	81 30       	cpi	r24, 0x01	; 1
    387e:	49 f0       	breq	.+18     	; 0x3892 <FViewFreeMessage+0x1a>
    3880:	81 30       	cpi	r24, 0x01	; 1
    3882:	28 f0       	brcs	.+10     	; 0x388e <FViewFreeMessage+0x16>
    3884:	82 30       	cpi	r24, 0x02	; 2
    3886:	19 f1       	breq	.+70     	; 0x38ce <FViewFreeMessage+0x56>
    3888:	83 30       	cpi	r24, 0x03	; 3
    388a:	71 f5       	brne	.+92     	; 0x38e8 <FViewFreeMessage+0x70>
    388c:	29 c0       	rjmp	.+82     	; 0x38e0 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    388e:	81 e0       	ldi	r24, 0x01	; 1
    3890:	23 c0       	rjmp	.+70     	; 0x38d8 <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    3892:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    3896:	81 e0       	ldi	r24, 0x01	; 1
    3898:	61 e0       	ldi	r22, 0x01	; 1
    389a:	4b e9       	ldi	r20, 0x9B	; 155
    389c:	58 e0       	ldi	r21, 0x08	; 8
    389e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    38a2:	82 e0       	ldi	r24, 0x02	; 2
    38a4:	61 e0       	ldi	r22, 0x01	; 1
    38a6:	4c ea       	ldi	r20, 0xAC	; 172
    38a8:	57 e0       	ldi	r21, 0x07	; 7
    38aa:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    38ae:	83 e0       	ldi	r24, 0x03	; 3
    38b0:	61 e0       	ldi	r22, 0x01	; 1
    38b2:	45 e2       	ldi	r20, 0x25	; 37
    38b4:	58 e0       	ldi	r21, 0x08	; 8
    38b6:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    38ba:	84 e0       	ldi	r24, 0x04	; 4
    38bc:	61 e0       	ldi	r22, 0x01	; 1
    38be:	43 ee       	ldi	r20, 0xE3	; 227
    38c0:	5d e0       	ldi	r21, 0x0D	; 13
    38c2:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	      TimDisplay=0;
    38c6:	10 92 94 01 	sts	0x0194, r1
	      stFreeMessage=fmDelayViewMesage;
    38ca:	82 e0       	ldi	r24, 0x02	; 2
    38cc:	05 c0       	rjmp	.+10     	; 0x38d8 <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    38ce:	80 91 94 01 	lds	r24, 0x0194
    38d2:	8b 30       	cpi	r24, 0x0B	; 11
    38d4:	48 f0       	brcs	.+18     	; 0x38e8 <FViewFreeMessage+0x70>
    38d6:	83 e0       	ldi	r24, 0x03	; 3
    38d8:	80 93 76 02 	sts	0x0276, r24
    38dc:	80 e0       	ldi	r24, 0x00	; 0
    38de:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    38e0:	10 92 76 02 	sts	0x0276, r1
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	08 95       	ret
    38e8:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    38ea:	08 95       	ret

000038ec <DisplayScreenIdle>:
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
		break;
	 }
}

void DisplayScreenIdle(void){
    38ec:	cf 92       	push	r12
    38ee:	df 92       	push	r13
    38f0:	ef 92       	push	r14
    38f2:	ff 92       	push	r15
    38f4:	0f 93       	push	r16
    38f6:	1f 93       	push	r17
    38f8:	df 93       	push	r29
    38fa:	cf 93       	push	r28
    38fc:	cd b7       	in	r28, 0x3d	; 61
    38fe:	de b7       	in	r29, 0x3e	; 62
    3900:	a8 97       	sbiw	r28, 0x28	; 40
    3902:	0f b6       	in	r0, 0x3f	; 63
    3904:	f8 94       	cli
    3906:	de bf       	out	0x3e, r29	; 62
    3908:	0f be       	out	0x3f, r0	; 63
    390a:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    390c:	00 d0       	rcall	.+0      	; 0x390e <DisplayScreenIdle+0x22>
    390e:	00 d0       	rcall	.+0      	; 0x3910 <DisplayScreenIdle+0x24>
    3910:	6e 01       	movw	r12, r28
    3912:	08 94       	sec
    3914:	c1 1c       	adc	r12, r1
    3916:	d1 1c       	adc	r13, r1
    3918:	ad b7       	in	r26, 0x3d	; 61
    391a:	be b7       	in	r27, 0x3e	; 62
    391c:	12 96       	adiw	r26, 0x02	; 2
    391e:	dc 92       	st	X, r13
    3920:	ce 92       	st	-X, r12
    3922:	11 97       	sbiw	r26, 0x01	; 1
    3924:	8d e3       	ldi	r24, 0x3D	; 61
    3926:	92 e2       	ldi	r25, 0x22	; 34
    3928:	14 96       	adiw	r26, 0x04	; 4
    392a:	9c 93       	st	X, r25
    392c:	8e 93       	st	-X, r24
    392e:	13 97       	sbiw	r26, 0x03	; 3
    3930:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    3934:	2b e0       	ldi	r18, 0x0B	; 11
    3936:	e2 2e       	mov	r14, r18
    3938:	f1 2c       	mov	r15, r1
    393a:	ec 0e       	add	r14, r28
    393c:	fd 1e       	adc	r15, r29
    393e:	ed b7       	in	r30, 0x3d	; 61
    3940:	fe b7       	in	r31, 0x3e	; 62
    3942:	f2 82       	std	Z+2, r15	; 0x02
    3944:	e1 82       	std	Z+1, r14	; 0x01
    3946:	87 e3       	ldi	r24, 0x37	; 55
    3948:	92 e2       	ldi	r25, 0x22	; 34
    394a:	94 83       	std	Z+4, r25	; 0x04
    394c:	83 83       	std	Z+3, r24	; 0x03
    394e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    3952:	00 d0       	rcall	.+0      	; 0x3954 <DisplayScreenIdle+0x68>
    3954:	00 d0       	rcall	.+0      	; 0x3956 <DisplayScreenIdle+0x6a>
    3956:	ed b7       	in	r30, 0x3d	; 61
    3958:	fe b7       	in	r31, 0x3e	; 62
    395a:	31 96       	adiw	r30, 0x01	; 1
    395c:	8e 01       	movw	r16, r28
    395e:	0b 5e       	subi	r16, 0xEB	; 235
    3960:	1f 4f       	sbci	r17, 0xFF	; 255
    3962:	ad b7       	in	r26, 0x3d	; 61
    3964:	be b7       	in	r27, 0x3e	; 62
    3966:	12 96       	adiw	r26, 0x02	; 2
    3968:	1c 93       	st	X, r17
    396a:	0e 93       	st	-X, r16
    396c:	11 97       	sbiw	r26, 0x01	; 1
    396e:	81 e3       	ldi	r24, 0x31	; 49
    3970:	92 e2       	ldi	r25, 0x22	; 34
    3972:	93 83       	std	Z+3, r25	; 0x03
    3974:	82 83       	std	Z+2, r24	; 0x02
    3976:	d5 82       	std	Z+5, r13	; 0x05
    3978:	c4 82       	std	Z+4, r12	; 0x04
    397a:	f7 82       	std	Z+7, r15	; 0x07
    397c:	e6 82       	std	Z+6, r14	; 0x06
    397e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	lcd_clear();
    3982:	ed b7       	in	r30, 0x3d	; 61
    3984:	fe b7       	in	r31, 0x3e	; 62
    3986:	38 96       	adiw	r30, 0x08	; 8
    3988:	0f b6       	in	r0, 0x3f	; 63
    398a:	f8 94       	cli
    398c:	fe bf       	out	0x3e, r31	; 62
    398e:	0f be       	out	0x3f, r0	; 63
    3990:	ed bf       	out	0x3d, r30	; 61
    3992:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	lcd_print(1,1,lcdteks);
    3996:	81 e0       	ldi	r24, 0x01	; 1
    3998:	61 e0       	ldi	r22, 0x01	; 1
    399a:	a8 01       	movw	r20, r16
    399c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
}
    39a0:	a8 96       	adiw	r28, 0x28	; 40
    39a2:	0f b6       	in	r0, 0x3f	; 63
    39a4:	f8 94       	cli
    39a6:	de bf       	out	0x3e, r29	; 62
    39a8:	0f be       	out	0x3f, r0	; 63
    39aa:	cd bf       	out	0x3d, r28	; 61
    39ac:	cf 91       	pop	r28
    39ae:	df 91       	pop	r29
    39b0:	1f 91       	pop	r17
    39b2:	0f 91       	pop	r16
    39b4:	ff 90       	pop	r15
    39b6:	ef 90       	pop	r14
    39b8:	df 90       	pop	r13
    39ba:	cf 90       	pop	r12
    39bc:	08 95       	ret

000039be <FTestMMC>:
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpLabel, 8);     
}


//----------------MMC--------------
void FTestMMC(){
    39be:	af 92       	push	r10
    39c0:	bf 92       	push	r11
    39c2:	df 92       	push	r13
    39c4:	ef 92       	push	r14
    39c6:	ff 92       	push	r15
    39c8:	0f 93       	push	r16
    39ca:	1f 93       	push	r17
    39cc:	df 93       	push	r29
    39ce:	cf 93       	push	r28
    39d0:	cd b7       	in	r28, 0x3d	; 61
    39d2:	de b7       	in	r29, 0x3e	; 62
    39d4:	c6 54       	subi	r28, 0x46	; 70
    39d6:	d0 40       	sbci	r29, 0x00	; 0
    39d8:	0f b6       	in	r0, 0x3f	; 63
    39da:	f8 94       	cli
    39dc:	de bf       	out	0x3e, r29	; 62
    39de:	0f be       	out	0x3f, r0	; 63
    39e0:	cd bf       	out	0x3d, r28	; 61
static char IsCardExist,IsCardProtected,CardState=CS_NONE;
unsigned int i;
       char strSend[50],lcdteks[20];
     
     //Card Detection
	 if (((PING&0b00010000)>>4)==0){ 
    39e2:	80 91 63 00 	lds	r24, 0x0063
    39e6:	90 91 c6 01 	lds	r25, 0x01C6
    39ea:	84 fd       	sbrc	r24, 4
    39ec:	09 c0       	rjmp	.+18     	; 0x3a00 <FTestMMC+0x42>
	       if (IsCardExist==False){		       
    39ee:	99 23       	and	r25, r25
    39f0:	19 f4       	brne	.+6      	; 0x39f8 <FTestMMC+0x3a>
			   CardState=CS_INSERTED;
    39f2:	81 e0       	ldi	r24, 0x01	; 1
    39f4:	80 93 c4 01 	sts	0x01C4, r24
		   }IsCardExist=True;                  
    39f8:	81 e0       	ldi	r24, 0x01	; 1
    39fa:	80 93 c6 01 	sts	0x01C6, r24
    39fe:	07 c0       	rjmp	.+14     	; 0x3a0e <FTestMMC+0x50>
     }
     else{ 
	     if (IsCardExist==True){
    3a00:	91 30       	cpi	r25, 0x01	; 1
    3a02:	19 f4       	brne	.+6      	; 0x3a0a <FTestMMC+0x4c>
		     CardState=CS_REMOVED;
    3a04:	82 e0       	ldi	r24, 0x02	; 2
    3a06:	80 93 c4 01 	sts	0x01C4, r24
		 }
	     IsCardExist=False;	 
    3a0a:	10 92 c6 01 	sts	0x01C6, r1
	 }

     //WriteProtect Detection
	 if (((PING&0b00001000)>>3)==0)//0000 0101
    3a0e:	80 91 63 00 	lds	r24, 0x0063
    3a12:	83 fd       	sbrc	r24, 3
    3a14:	03 c0       	rjmp	.+6      	; 0x3a1c <FTestMMC+0x5e>
	       IsCardProtected=False;
    3a16:	10 92 c5 01 	sts	0x01C5, r1
    3a1a:	03 c0       	rjmp	.+6      	; 0x3a22 <FTestMMC+0x64>
     else IsCardProtected=True;
    3a1c:	81 e0       	ldi	r24, 0x01	; 1
    3a1e:	80 93 c5 01 	sts	0x01C5, r24

	 sprintf_P(lcdteks,PSTR("PORTG=%.2X"),PING);
    3a22:	20 91 63 00 	lds	r18, 0x0063
    3a26:	00 d0       	rcall	.+0      	; 0x3a28 <FTestMMC+0x6a>
    3a28:	00 d0       	rcall	.+0      	; 0x3a2a <FTestMMC+0x6c>
    3a2a:	00 d0       	rcall	.+0      	; 0x3a2c <FTestMMC+0x6e>
    3a2c:	ed b7       	in	r30, 0x3d	; 61
    3a2e:	fe b7       	in	r31, 0x3e	; 62
    3a30:	31 96       	adiw	r30, 0x01	; 1
    3a32:	8e 01       	movw	r16, r28
    3a34:	0f 5f       	subi	r16, 0xFF	; 255
    3a36:	1f 4f       	sbci	r17, 0xFF	; 255
    3a38:	ad b7       	in	r26, 0x3d	; 61
    3a3a:	be b7       	in	r27, 0x3e	; 62
    3a3c:	12 96       	adiw	r26, 0x02	; 2
    3a3e:	1c 93       	st	X, r17
    3a40:	0e 93       	st	-X, r16
    3a42:	11 97       	sbiw	r26, 0x01	; 1
    3a44:	8f e6       	ldi	r24, 0x6F	; 111
    3a46:	94 e0       	ldi	r25, 0x04	; 4
    3a48:	93 83       	std	Z+3, r25	; 0x03
    3a4a:	82 83       	std	Z+2, r24	; 0x02
    3a4c:	24 83       	std	Z+4, r18	; 0x04
    3a4e:	15 82       	std	Z+5, r1	; 0x05
    3a50:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 lcd_print(1,1,lcdteks); 
    3a54:	2d b7       	in	r18, 0x3d	; 61
    3a56:	3e b7       	in	r19, 0x3e	; 62
    3a58:	2a 5f       	subi	r18, 0xFA	; 250
    3a5a:	3f 4f       	sbci	r19, 0xFF	; 255
    3a5c:	0f b6       	in	r0, 0x3f	; 63
    3a5e:	f8 94       	cli
    3a60:	3e bf       	out	0x3e, r19	; 62
    3a62:	0f be       	out	0x3f, r0	; 63
    3a64:	2d bf       	out	0x3d, r18	; 61
    3a66:	81 e0       	ldi	r24, 0x01	; 1
    3a68:	61 e0       	ldi	r22, 0x01	; 1
    3a6a:	a8 01       	movw	r20, r16
    3a6c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	 
     //Bypassed
	 IsCardExist=True;   
    3a70:	01 e0       	ldi	r16, 0x01	; 1
    3a72:	00 93 c6 01 	sts	0x01C6, r16
	 IsCardProtected=False;
    3a76:	10 92 c5 01 	sts	0x01C5, r1
	 //CardState=CS_INSERTED;

     //PORT CD:
	 switch(stTestMMC){
    3a7a:	80 91 15 01 	lds	r24, 0x0115
    3a7e:	85 30       	cpi	r24, 0x05	; 5
    3a80:	09 f4       	brne	.+2      	; 0x3a84 <FTestMMC+0xc6>
    3a82:	7e c0       	rjmp	.+252    	; 0x3b80 <FTestMMC+0x1c2>
    3a84:	86 30       	cpi	r24, 0x06	; 6
    3a86:	90 f4       	brcc	.+36     	; 0x3aac <FTestMMC+0xee>
    3a88:	82 30       	cpi	r24, 0x02	; 2
    3a8a:	09 f4       	brne	.+2      	; 0x3a8e <FTestMMC+0xd0>
    3a8c:	42 c0       	rjmp	.+132    	; 0x3b12 <FTestMMC+0x154>
    3a8e:	83 30       	cpi	r24, 0x03	; 3
    3a90:	30 f4       	brcc	.+12     	; 0x3a9e <FTestMMC+0xe0>
    3a92:	88 23       	and	r24, r24
    3a94:	09 f1       	breq	.+66     	; 0x3ad8 <FTestMMC+0x11a>
    3a96:	81 30       	cpi	r24, 0x01	; 1
    3a98:	09 f0       	breq	.+2      	; 0x3a9c <FTestMMC+0xde>
    3a9a:	00 c2       	rjmp	.+1024   	; 0x3e9c <FTestMMC+0x4de>
    3a9c:	38 c0       	rjmp	.+112    	; 0x3b0e <FTestMMC+0x150>
    3a9e:	83 30       	cpi	r24, 0x03	; 3
    3aa0:	09 f4       	brne	.+2      	; 0x3aa4 <FTestMMC+0xe6>
    3aa2:	47 c0       	rjmp	.+142    	; 0x3b32 <FTestMMC+0x174>
    3aa4:	84 30       	cpi	r24, 0x04	; 4
    3aa6:	09 f0       	breq	.+2      	; 0x3aaa <FTestMMC+0xec>
    3aa8:	f9 c1       	rjmp	.+1010   	; 0x3e9c <FTestMMC+0x4de>
    3aaa:	58 c0       	rjmp	.+176    	; 0x3b5c <FTestMMC+0x19e>
    3aac:	88 30       	cpi	r24, 0x08	; 8
    3aae:	09 f4       	brne	.+2      	; 0x3ab2 <FTestMMC+0xf4>
    3ab0:	2c c1       	rjmp	.+600    	; 0x3d0a <FTestMMC+0x34c>
    3ab2:	89 30       	cpi	r24, 0x09	; 9
    3ab4:	38 f4       	brcc	.+14     	; 0x3ac4 <FTestMMC+0x106>
    3ab6:	86 30       	cpi	r24, 0x06	; 6
    3ab8:	09 f4       	brne	.+2      	; 0x3abc <FTestMMC+0xfe>
    3aba:	9b c0       	rjmp	.+310    	; 0x3bf2 <FTestMMC+0x234>
    3abc:	87 30       	cpi	r24, 0x07	; 7
    3abe:	09 f0       	breq	.+2      	; 0x3ac2 <FTestMMC+0x104>
    3ac0:	ed c1       	rjmp	.+986    	; 0x3e9c <FTestMMC+0x4de>
    3ac2:	fa c0       	rjmp	.+500    	; 0x3cb8 <FTestMMC+0x2fa>
    3ac4:	8a 30       	cpi	r24, 0x0A	; 10
    3ac6:	09 f4       	brne	.+2      	; 0x3aca <FTestMMC+0x10c>
    3ac8:	bc c1       	rjmp	.+888    	; 0x3e42 <FTestMMC+0x484>
    3aca:	8a 30       	cpi	r24, 0x0A	; 10
    3acc:	08 f4       	brcc	.+2      	; 0x3ad0 <FTestMMC+0x112>
    3ace:	a6 c1       	rjmp	.+844    	; 0x3e1c <FTestMMC+0x45e>
    3ad0:	8b 30       	cpi	r24, 0x0B	; 11
    3ad2:	09 f0       	breq	.+2      	; 0x3ad6 <FTestMMC+0x118>
    3ad4:	e3 c1       	rjmp	.+966    	; 0x3e9c <FTestMMC+0x4de>
    3ad6:	40 c0       	rjmp	.+128    	; 0x3b58 <FTestMMC+0x19a>
	 case tmDisplayDetectMMC:
	      lcd_clear();
    3ad8:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("Detect MMC")); 
    3adc:	81 e0       	ldi	r24, 0x01	; 1
    3ade:	61 e0       	ldi	r22, 0x01	; 1
    3ae0:	44 e6       	ldi	r20, 0x64	; 100
    3ae2:	54 e0       	ldi	r21, 0x04	; 4
    3ae4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  PORTG=PORTG|0b00001100;//PullUp
    3ae8:	80 91 65 00 	lds	r24, 0x0065
    3aec:	8c 60       	ori	r24, 0x0C	; 12
    3aee:	80 93 65 00 	sts	0x0065, r24
		  DDRG=DDRG&0b11110011;//Input		  
    3af2:	80 91 64 00 	lds	r24, 0x0064
    3af6:	83 7f       	andi	r24, 0xF3	; 243
    3af8:	80 93 64 00 	sts	0x0064, r24
		  lcd_printf(2,1,PSTR("NoCard Found")); 
    3afc:	82 e0       	ldi	r24, 0x02	; 2
    3afe:	61 e0       	ldi	r22, 0x01	; 1
    3b00:	47 e5       	ldi	r20, 0x57	; 87
    3b02:	54 e0       	ldi	r21, 0x04	; 4
    3b04:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stTestMMC=tmScanMMCExist;
    3b08:	00 93 15 01 	sts	0x0115, r16
    3b0c:	c7 c1       	rjmp	.+910    	; 0x3e9c <FTestMMC+0x4de>
	      break;
	 case tmScanMMCExist:
	      //DetectPortG.4
		  if (IsCardExist==True){
                stTestMMC=tmDisplayPresent;
    3b0e:	82 e0       	ldi	r24, 0x02	; 2
    3b10:	c3 c1       	rjmp	.+902    	; 0x3e98 <FTestMMC+0x4da>
		  }else lcd_printf(2,1,PSTR("NoCard Found")); 
	      break;
     case tmDisplayPresent:
		  lcd_printf(2,1,PSTR("Card Present     ")); 
    3b12:	82 e0       	ldi	r24, 0x02	; 2
    3b14:	61 e0       	ldi	r22, 0x01	; 1
    3b16:	45 e4       	ldi	r20, 0x45	; 69
    3b18:	54 e0       	ldi	r21, 0x04	; 4
    3b1a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  uart_printf(0,1,PSTR("Card Found "));
    3b1e:	80 e0       	ldi	r24, 0x00	; 0
    3b20:	61 e0       	ldi	r22, 0x01	; 1
    3b22:	49 e3       	ldi	r20, 0x39	; 57
    3b24:	54 e0       	ldi	r21, 0x04	; 4
    3b26:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
		  TimDisplay=0;
    3b2a:	10 92 94 01 	sts	0x0194, r1
          stTestMMC=tmDelayDisplayPresent;
    3b2e:	83 e0       	ldi	r24, 0x03	; 3
    3b30:	b3 c1       	rjmp	.+870    	; 0x3e98 <FTestMMC+0x4da>
	      break;
     case tmDelayDisplayPresent:
	      if (TimDisplay>5){
    3b32:	80 91 94 01 	lds	r24, 0x0194
    3b36:	86 30       	cpi	r24, 0x06	; 6
    3b38:	08 f4       	brcc	.+2      	; 0x3b3c <FTestMMC+0x17e>
    3b3a:	b0 c1       	rjmp	.+864    	; 0x3e9c <FTestMMC+0x4de>
			  lcd_printf(2,1, PSTR("Reset Card ")); 
    3b3c:	82 e0       	ldi	r24, 0x02	; 2
    3b3e:	61 e0       	ldi	r22, 0x01	; 1
    3b40:	4d e2       	ldi	r20, 0x2D	; 45
    3b42:	54 e0       	ldi	r21, 0x04	; 4
    3b44:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			  uart_printf(0,1,PSTR("Reset Card "));
    3b48:	80 e0       	ldi	r24, 0x00	; 0
    3b4a:	61 e0       	ldi	r22, 0x01	; 1
    3b4c:	41 e2       	ldi	r20, 0x21	; 33
    3b4e:	54 e0       	ldi	r21, 0x04	; 4
    3b50:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
		      stTestMMC=tmResetCard;
    3b54:	8b e0       	ldi	r24, 0x0B	; 11
    3b56:	a0 c1       	rjmp	.+832    	; 0x3e98 <FTestMMC+0x4da>
		  }
	      break;
     case tmResetCard:
	      //mmc_reset();
		  stTestMMC=tmDisplayInit;
    3b58:	84 e0       	ldi	r24, 0x04	; 4
    3b5a:	9e c1       	rjmp	.+828    	; 0x3e98 <FTestMMC+0x4da>
	      break;
	 case tmDisplayInit:
	      lcd_clear();
    3b5c:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(4,1,PSTR("Initialize MMC.."));
    3b60:	84 e0       	ldi	r24, 0x04	; 4
    3b62:	61 e0       	ldi	r22, 0x01	; 1
    3b64:	40 e1       	ldi	r20, 0x10	; 16
    3b66:	54 e0       	ldi	r21, 0x04	; 4
    3b68:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  uart_printf(0,1,PSTR("Initialize MMC"));
    3b6c:	80 e0       	ldi	r24, 0x00	; 0
    3b6e:	61 e0       	ldi	r22, 0x01	; 1
    3b70:	41 e0       	ldi	r20, 0x01	; 1
    3b72:	54 e0       	ldi	r21, 0x04	; 4
    3b74:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
		  TimDisplay=0;
    3b78:	10 92 94 01 	sts	0x0194, r1
		  stTestMMC=tmInitialize;
    3b7c:	85 e0       	ldi	r24, 0x05	; 5
    3b7e:	8c c1       	rjmp	.+792    	; 0x3e98 <FTestMMC+0x4da>
			  mmc_init();

			  IsWrite=True;
			  stTestMMC=tmWaitInstruction;
		  }*/
	      if (mmc_init()==0){
    3b80:	0e 94 84 b0 	call	0x16108	; 0x16108 <mmc_init>
    3b84:	88 23       	and	r24, r24
    3b86:	f9 f4       	brne	.+62     	; 0x3bc6 <FTestMMC+0x208>
		      CardState=CS_INITIALIZED;
    3b88:	83 e0       	ldi	r24, 0x03	; 3
    3b8a:	80 93 c4 01 	sts	0x01C4, r24
		      lcd_printf(4,1,PSTR("Initialized   "));    
    3b8e:	84 e0       	ldi	r24, 0x04	; 4
    3b90:	61 e0       	ldi	r22, 0x01	; 1
    3b92:	42 ef       	ldi	r20, 0xF2	; 242
    3b94:	53 e0       	ldi	r21, 0x03	; 3
    3b96:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			  uart_printf(0,1,PSTR("Initialized  "));
    3b9a:	80 e0       	ldi	r24, 0x00	; 0
    3b9c:	61 e0       	ldi	r22, 0x01	; 1
    3b9e:	44 ee       	ldi	r20, 0xE4	; 228
    3ba0:	53 e0       	ldi	r21, 0x03	; 3
    3ba2:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>

			  IsWrite=True;
    3ba6:	81 e0       	ldi	r24, 0x01	; 1
    3ba8:	90 e0       	ldi	r25, 0x00	; 0
    3baa:	a0 e0       	ldi	r26, 0x00	; 0
    3bac:	b0 e0       	ldi	r27, 0x00	; 0
    3bae:	80 93 17 0e 	sts	0x0E17, r24
    3bb2:	90 93 18 0e 	sts	0x0E18, r25
    3bb6:	a0 93 19 0e 	sts	0x0E19, r26
    3bba:	b0 93 1a 0e 	sts	0x0E1A, r27
			  stTestMMC=tmWaitInstruction;
    3bbe:	86 e0       	ldi	r24, 0x06	; 6
    3bc0:	80 93 15 01 	sts	0x0115, r24
    3bc4:	06 c0       	rjmp	.+12     	; 0x3bd2 <FTestMMC+0x214>
		  }else uart_printf(0,1,PSTR("Init Failed"));
    3bc6:	80 e0       	ldi	r24, 0x00	; 0
    3bc8:	61 e0       	ldi	r22, 0x01	; 1
    3bca:	48 ed       	ldi	r20, 0xD8	; 216
    3bcc:	53 e0       	ldi	r21, 0x03	; 3
    3bce:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>

		  if (TimDisplay>5){
    3bd2:	80 91 94 01 	lds	r24, 0x0194
    3bd6:	86 30       	cpi	r24, 0x06	; 6
    3bd8:	08 f4       	brcc	.+2      	; 0x3bdc <FTestMMC+0x21e>
    3bda:	60 c1       	rjmp	.+704    	; 0x3e9c <FTestMMC+0x4de>
		      lcd_printf(4,1,PSTR("Init Timeout"));    
    3bdc:	84 e0       	ldi	r24, 0x04	; 4
    3bde:	61 e0       	ldi	r22, 0x01	; 1
    3be0:	4b ec       	ldi	r20, 0xCB	; 203
    3be2:	53 e0       	ldi	r21, 0x03	; 3
    3be4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			  uart_printf(0,1,PSTR("Init Timeout"));
    3be8:	80 e0       	ldi	r24, 0x00	; 0
    3bea:	61 e0       	ldi	r22, 0x01	; 1
    3bec:	4e eb       	ldi	r20, 0xBE	; 190
    3bee:	53 e0       	ldi	r21, 0x03	; 3
    3bf0:	5e c0       	rjmp	.+188    	; 0x3cae <FTestMMC+0x2f0>
			  stTestMMC=tmDisplayDetectMMC;
		  }
	      break;
     case tmWaitInstruction:
	      if (IsRead==True){		      
    3bf2:	80 91 dc 0d 	lds	r24, 0x0DDC
    3bf6:	90 91 dd 0d 	lds	r25, 0x0DDD
    3bfa:	a0 91 de 0d 	lds	r26, 0x0DDE
    3bfe:	b0 91 df 0d 	lds	r27, 0x0DDF
    3c02:	01 97       	sbiw	r24, 0x01	; 1
    3c04:	a1 05       	cpc	r26, r1
    3c06:	b1 05       	cpc	r27, r1
    3c08:	e1 f4       	brne	.+56     	; 0x3c42 <FTestMMC+0x284>
		      if (CardState==CS_INITIALIZED){
    3c0a:	80 91 c4 01 	lds	r24, 0x01C4
    3c0e:	83 30       	cpi	r24, 0x03	; 3
    3c10:	81 f4       	brne	.+32     	; 0x3c32 <FTestMMC+0x274>
			      ActiveSector=200;			      
    3c12:	88 ec       	ldi	r24, 0xC8	; 200
    3c14:	90 e0       	ldi	r25, 0x00	; 0
    3c16:	a0 e0       	ldi	r26, 0x00	; 0
    3c18:	b0 e0       	ldi	r27, 0x00	; 0
    3c1a:	80 93 c0 01 	sts	0x01C0, r24
    3c1e:	90 93 c1 01 	sts	0x01C1, r25
    3c22:	a0 93 c2 01 	sts	0x01C2, r26
    3c26:	b0 93 c3 01 	sts	0x01C3, r27
			      stTestMMC=tmReadSector; 
    3c2a:	87 e0       	ldi	r24, 0x07	; 7
    3c2c:	80 93 15 01 	sts	0x0115, r24
    3c30:	08 c0       	rjmp	.+16     	; 0x3c42 <FTestMMC+0x284>
			  }else {
			      uart_printf(0,1,PSTR("Not Initialized"));
    3c32:	80 e0       	ldi	r24, 0x00	; 0
    3c34:	61 e0       	ldi	r22, 0x01	; 1
    3c36:	4e ea       	ldi	r20, 0xAE	; 174
    3c38:	53 e0       	ldi	r21, 0x03	; 3
    3c3a:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
			      stTestMMC=tmDisplayDetectMMC;
    3c3e:	10 92 15 01 	sts	0x0115, r1
			  }
		  }
		  //--------------------------------------------------
	      if (IsWrite==True){
    3c42:	80 91 17 0e 	lds	r24, 0x0E17
    3c46:	90 91 18 0e 	lds	r25, 0x0E18
    3c4a:	a0 91 19 0e 	lds	r26, 0x0E19
    3c4e:	b0 91 1a 0e 	lds	r27, 0x0E1A
    3c52:	01 97       	sbiw	r24, 0x01	; 1
    3c54:	a1 05       	cpc	r26, r1
    3c56:	b1 05       	cpc	r27, r1
    3c58:	09 f0       	breq	.+2      	; 0x3c5c <FTestMMC+0x29e>
    3c5a:	20 c1       	rjmp	.+576    	; 0x3e9c <FTestMMC+0x4de>
		      if (IsCardProtected==True){
    3c5c:	80 91 c5 01 	lds	r24, 0x01C5
    3c60:	81 30       	cpi	r24, 0x01	; 1
    3c62:	79 f4       	brne	.+30     	; 0x3c82 <FTestMMC+0x2c4>
			      IsWrite=False;
    3c64:	10 92 17 0e 	sts	0x0E17, r1
    3c68:	10 92 18 0e 	sts	0x0E18, r1
    3c6c:	10 92 19 0e 	sts	0x0E19, r1
    3c70:	10 92 1a 0e 	sts	0x0E1A, r1
			      uart_printf(0,1,PSTR("Card Protected"));
    3c74:	80 e0       	ldi	r24, 0x00	; 0
    3c76:	61 e0       	ldi	r22, 0x01	; 1
    3c78:	4f e9       	ldi	r20, 0x9F	; 159
    3c7a:	53 e0       	ldi	r21, 0x03	; 3
    3c7c:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
    3c80:	0d c1       	rjmp	.+538    	; 0x3e9c <FTestMMC+0x4de>
			  }
			  else{
			      if (CardState==CS_INITIALIZED){
    3c82:	80 91 c4 01 	lds	r24, 0x01C4
    3c86:	83 30       	cpi	r24, 0x03	; 3
    3c88:	71 f4       	brne	.+28     	; 0x3ca6 <FTestMMC+0x2e8>
				      ActiveSector=200;			      
    3c8a:	88 ec       	ldi	r24, 0xC8	; 200
    3c8c:	90 e0       	ldi	r25, 0x00	; 0
    3c8e:	a0 e0       	ldi	r26, 0x00	; 0
    3c90:	b0 e0       	ldi	r27, 0x00	; 0
    3c92:	80 93 c0 01 	sts	0x01C0, r24
    3c96:	90 93 c1 01 	sts	0x01C1, r25
    3c9a:	a0 93 c2 01 	sts	0x01C2, r26
    3c9e:	b0 93 c3 01 	sts	0x01C3, r27
				      stTestMMC=tmFillData; 
    3ca2:	89 e0       	ldi	r24, 0x09	; 9
    3ca4:	f9 c0       	rjmp	.+498    	; 0x3e98 <FTestMMC+0x4da>
				  }else {
				      uart_printf(0,1,PSTR("Not Initialized"));
    3ca6:	80 e0       	ldi	r24, 0x00	; 0
    3ca8:	61 e0       	ldi	r22, 0x01	; 1
    3caa:	4f e8       	ldi	r20, 0x8F	; 143
    3cac:	53 e0       	ldi	r21, 0x03	; 3
    3cae:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
				      stTestMMC=tmDisplayDetectMMC;
    3cb2:	10 92 15 01 	sts	0x0115, r1
    3cb6:	f2 c0       	rjmp	.+484    	; 0x3e9c <FTestMMC+0x4de>
				  }
              }
		  }
	      break;
     case tmReadSector:
	      uart_printf(0,1,PSTR("Clear Buffer.."));
    3cb8:	80 e0       	ldi	r24, 0x00	; 0
    3cba:	61 e0       	ldi	r22, 0x01	; 1
    3cbc:	40 e8       	ldi	r20, 0x80	; 128
    3cbe:	53 e0       	ldi	r21, 0x03	; 3
    3cc0:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
    3cc4:	80 e0       	ldi	r24, 0x00	; 0
    3cc6:	90 e0       	ldi	r25, 0x00	; 0
		  
		  for (i=0;i<512;i++){
		       MMC_Buffer[i]=0;		       
    3cc8:	fc 01       	movw	r30, r24
    3cca:	e3 5e       	subi	r30, 0xE3	; 227
    3ccc:	f6 4f       	sbci	r31, 0xF6	; 246
    3cce:	10 82       	st	Z, r1
		  }
	      break;
     case tmReadSector:
	      uart_printf(0,1,PSTR("Clear Buffer.."));
		  
		  for (i=0;i<512;i++){
    3cd0:	01 96       	adiw	r24, 0x01	; 1
    3cd2:	32 e0       	ldi	r19, 0x02	; 2
    3cd4:	80 30       	cpi	r24, 0x00	; 0
    3cd6:	93 07       	cpc	r25, r19
    3cd8:	b9 f7       	brne	.-18     	; 0x3cc8 <FTestMMC+0x30a>
		       MMC_Buffer[i]=0;		       
		  }
		  uart_printf(0,1,PSTR("Read Sector.."));
    3cda:	80 e0       	ldi	r24, 0x00	; 0
    3cdc:	61 e0       	ldi	r22, 0x01	; 1
    3cde:	42 e7       	ldi	r20, 0x72	; 114
    3ce0:	53 e0       	ldi	r21, 0x03	; 3
    3ce2:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
		  //mmc_readsingleblock(ActiveSector);
		  mmc_read(ActiveSector);
    3ce6:	60 91 c0 01 	lds	r22, 0x01C0
    3cea:	70 91 c1 01 	lds	r23, 0x01C1
    3cee:	80 91 c2 01 	lds	r24, 0x01C2
    3cf2:	90 91 c3 01 	lds	r25, 0x01C3
    3cf6:	0e 94 28 ad 	call	0x15a50	; 0x15a50 <mmc_read>
	      uart_printf(0,1,PSTR("Sector Read"));
    3cfa:	80 e0       	ldi	r24, 0x00	; 0
    3cfc:	61 e0       	ldi	r22, 0x01	; 1
    3cfe:	46 e6       	ldi	r20, 0x66	; 102
    3d00:	53 e0       	ldi	r21, 0x03	; 3
    3d02:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
          stTestMMC=tmDisplayData;
    3d06:	88 e0       	ldi	r24, 0x08	; 8
    3d08:	c7 c0       	rjmp	.+398    	; 0x3e98 <FTestMMC+0x4da>
	      break;
     case tmDisplayData:
	      sprintf_P(strSend,PSTR("Sector=%d "),ActiveSector);
    3d0a:	8d b7       	in	r24, 0x3d	; 61
    3d0c:	9e b7       	in	r25, 0x3e	; 62
    3d0e:	08 97       	sbiw	r24, 0x08	; 8
    3d10:	0f b6       	in	r0, 0x3f	; 63
    3d12:	f8 94       	cli
    3d14:	9e bf       	out	0x3e, r25	; 62
    3d16:	0f be       	out	0x3f, r0	; 63
    3d18:	8d bf       	out	0x3d, r24	; 61
    3d1a:	ed b7       	in	r30, 0x3d	; 61
    3d1c:	fe b7       	in	r31, 0x3e	; 62
    3d1e:	31 96       	adiw	r30, 0x01	; 1
    3d20:	8e 01       	movw	r16, r28
    3d22:	0b 5e       	subi	r16, 0xEB	; 235
    3d24:	1f 4f       	sbci	r17, 0xFF	; 255
    3d26:	ad b7       	in	r26, 0x3d	; 61
    3d28:	be b7       	in	r27, 0x3e	; 62
    3d2a:	12 96       	adiw	r26, 0x02	; 2
    3d2c:	1c 93       	st	X, r17
    3d2e:	0e 93       	st	-X, r16
    3d30:	11 97       	sbiw	r26, 0x01	; 1
    3d32:	8b e5       	ldi	r24, 0x5B	; 91
    3d34:	93 e0       	ldi	r25, 0x03	; 3
    3d36:	93 83       	std	Z+3, r25	; 0x03
    3d38:	82 83       	std	Z+2, r24	; 0x02
    3d3a:	80 91 c0 01 	lds	r24, 0x01C0
    3d3e:	90 91 c1 01 	lds	r25, 0x01C1
    3d42:	a0 91 c2 01 	lds	r26, 0x01C2
    3d46:	b0 91 c3 01 	lds	r27, 0x01C3
    3d4a:	84 83       	std	Z+4, r24	; 0x04
    3d4c:	95 83       	std	Z+5, r25	; 0x05
    3d4e:	a6 83       	std	Z+6, r26	; 0x06
    3d50:	b7 83       	std	Z+7, r27	; 0x07
    3d52:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  uart_print(0,1,strSend);
    3d56:	2d b7       	in	r18, 0x3d	; 61
    3d58:	3e b7       	in	r19, 0x3e	; 62
    3d5a:	28 5f       	subi	r18, 0xF8	; 248
    3d5c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d5e:	0f b6       	in	r0, 0x3f	; 63
    3d60:	f8 94       	cli
    3d62:	3e bf       	out	0x3e, r19	; 62
    3d64:	0f be       	out	0x3f, r0	; 63
    3d66:	2d bf       	out	0x3d, r18	; 61
    3d68:	80 e0       	ldi	r24, 0x00	; 0
    3d6a:	61 e0       	ldi	r22, 0x01	; 1
    3d6c:	a8 01       	movw	r20, r16
    3d6e:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
		  uart_printf(0,1,PSTR("-----------------------"));
    3d72:	80 e0       	ldi	r24, 0x00	; 0
    3d74:	61 e0       	ldi	r22, 0x01	; 1
    3d76:	43 e4       	ldi	r20, 0x43	; 67
    3d78:	53 e0       	ldi	r21, 0x03	; 3
    3d7a:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
    3d7e:	ee 24       	eor	r14, r14
    3d80:	ff 24       	eor	r15, r15
		  for (i=0;i<512;i++){
		       sprintf_P(strSend,PSTR(" %d"),MMC_Buffer[i]);
    3d82:	d0 2e       	mov	r13, r16
    3d84:	01 2f       	mov	r16, r17
    3d86:	3f e3       	ldi	r19, 0x3F	; 63
    3d88:	a3 2e       	mov	r10, r19
    3d8a:	33 e0       	ldi	r19, 0x03	; 3
    3d8c:	b3 2e       	mov	r11, r19
    3d8e:	f7 01       	movw	r30, r14
    3d90:	e3 5e       	subi	r30, 0xE3	; 227
    3d92:	f6 4f       	sbci	r31, 0xF6	; 246
    3d94:	80 81       	ld	r24, Z
    3d96:	00 d0       	rcall	.+0      	; 0x3d98 <FTestMMC+0x3da>
    3d98:	00 d0       	rcall	.+0      	; 0x3d9a <FTestMMC+0x3dc>
    3d9a:	00 d0       	rcall	.+0      	; 0x3d9c <FTestMMC+0x3de>
    3d9c:	ed b7       	in	r30, 0x3d	; 61
    3d9e:	fe b7       	in	r31, 0x3e	; 62
    3da0:	31 96       	adiw	r30, 0x01	; 1
    3da2:	ad b7       	in	r26, 0x3d	; 61
    3da4:	be b7       	in	r27, 0x3e	; 62
    3da6:	11 96       	adiw	r26, 0x01	; 1
    3da8:	dc 92       	st	X, r13
    3daa:	11 97       	sbiw	r26, 0x01	; 1
    3dac:	12 96       	adiw	r26, 0x02	; 2
    3dae:	0c 93       	st	X, r16
    3db0:	b3 82       	std	Z+3, r11	; 0x03
    3db2:	a2 82       	std	Z+2, r10	; 0x02
    3db4:	84 83       	std	Z+4, r24	; 0x04
    3db6:	15 82       	std	Z+5, r1	; 0x05
    3db8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		       if (i%20==0)uart_print(0,1,strSend);
    3dbc:	c7 01       	movw	r24, r14
    3dbe:	64 e1       	ldi	r22, 0x14	; 20
    3dc0:	70 e0       	ldi	r23, 0x00	; 0
    3dc2:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    3dc6:	2d b7       	in	r18, 0x3d	; 61
    3dc8:	3e b7       	in	r19, 0x3e	; 62
    3dca:	2a 5f       	subi	r18, 0xFA	; 250
    3dcc:	3f 4f       	sbci	r19, 0xFF	; 255
    3dce:	0f b6       	in	r0, 0x3f	; 63
    3dd0:	f8 94       	cli
    3dd2:	3e bf       	out	0x3e, r19	; 62
    3dd4:	0f be       	out	0x3f, r0	; 63
    3dd6:	2d bf       	out	0x3d, r18	; 61
    3dd8:	89 2b       	or	r24, r25
    3dda:	19 f4       	brne	.+6      	; 0x3de2 <FTestMMC+0x424>
    3ddc:	80 e0       	ldi	r24, 0x00	; 0
    3dde:	61 e0       	ldi	r22, 0x01	; 1
    3de0:	02 c0       	rjmp	.+4      	; 0x3de6 <FTestMMC+0x428>
			   else uart_print(0,0,strSend);
    3de2:	80 e0       	ldi	r24, 0x00	; 0
    3de4:	60 e0       	ldi	r22, 0x00	; 0
    3de6:	4d 2d       	mov	r20, r13
    3de8:	50 2f       	mov	r21, r16
    3dea:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
	      break;
     case tmDisplayData:
	      sprintf_P(strSend,PSTR("Sector=%d "),ActiveSector);
		  uart_print(0,1,strSend);
		  uart_printf(0,1,PSTR("-----------------------"));
		  for (i=0;i<512;i++){
    3dee:	08 94       	sec
    3df0:	e1 1c       	adc	r14, r1
    3df2:	f1 1c       	adc	r15, r1
    3df4:	30 e0       	ldi	r19, 0x00	; 0
    3df6:	e3 16       	cp	r14, r19
    3df8:	32 e0       	ldi	r19, 0x02	; 2
    3dfa:	f3 06       	cpc	r15, r19
    3dfc:	41 f6       	brne	.-112    	; 0x3d8e <FTestMMC+0x3d0>
		       sprintf_P(strSend,PSTR(" %d"),MMC_Buffer[i]);
		       if (i%20==0)uart_print(0,1,strSend);
			   else uart_print(0,0,strSend);
		  }
		  uart_printf(0,1,PSTR("-----------------------"));
    3dfe:	80 e0       	ldi	r24, 0x00	; 0
    3e00:	61 e0       	ldi	r22, 0x01	; 1
    3e02:	47 e2       	ldi	r20, 0x27	; 39
    3e04:	53 e0       	ldi	r21, 0x03	; 3
    3e06:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
          IsRead=False;
    3e0a:	10 92 dc 0d 	sts	0x0DDC, r1
    3e0e:	10 92 dd 0d 	sts	0x0DDD, r1
    3e12:	10 92 de 0d 	sts	0x0DDE, r1
    3e16:	10 92 df 0d 	sts	0x0DDF, r1
    3e1a:	3d c0       	rjmp	.+122    	; 0x3e96 <FTestMMC+0x4d8>
		  stTestMMC=tmWaitInstruction;
	      break;
     case tmFillData:
	      uart_printf(0,1,PSTR("Fill Data"));
    3e1c:	80 e0       	ldi	r24, 0x00	; 0
    3e1e:	61 e0       	ldi	r22, 0x01	; 1
    3e20:	4d e1       	ldi	r20, 0x1D	; 29
    3e22:	53 e0       	ldi	r21, 0x03	; 3
    3e24:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
    3e28:	80 e0       	ldi	r24, 0x00	; 0
    3e2a:	90 e0       	ldi	r25, 0x00	; 0
	      for (i=0;i<512;i++){
		       MMC_Buffer[i]=i;
    3e2c:	fc 01       	movw	r30, r24
    3e2e:	e3 5e       	subi	r30, 0xE3	; 227
    3e30:	f6 4f       	sbci	r31, 0xF6	; 246
    3e32:	80 83       	st	Z, r24
          IsRead=False;
		  stTestMMC=tmWaitInstruction;
	      break;
     case tmFillData:
	      uart_printf(0,1,PSTR("Fill Data"));
	      for (i=0;i<512;i++){
    3e34:	01 96       	adiw	r24, 0x01	; 1
    3e36:	a2 e0       	ldi	r26, 0x02	; 2
    3e38:	80 30       	cpi	r24, 0x00	; 0
    3e3a:	9a 07       	cpc	r25, r26
    3e3c:	b9 f7       	brne	.-18     	; 0x3e2c <FTestMMC+0x46e>
		       MMC_Buffer[i]=i;
		  }
		  stTestMMC=tmWriteSector;
    3e3e:	8a e0       	ldi	r24, 0x0A	; 10
    3e40:	2b c0       	rjmp	.+86     	; 0x3e98 <FTestMMC+0x4da>
	      break;
     case tmWriteSector:
	      uart_printf(0,1,PSTR("Write sector.."));
    3e42:	80 e0       	ldi	r24, 0x00	; 0
    3e44:	61 e0       	ldi	r22, 0x01	; 1
    3e46:	4e e0       	ldi	r20, 0x0E	; 14
    3e48:	53 e0       	ldi	r21, 0x03	; 3
    3e4a:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
		  mmc_write(ActiveSector);
    3e4e:	60 91 c0 01 	lds	r22, 0x01C0
    3e52:	70 91 c1 01 	lds	r23, 0x01C1
    3e56:	80 91 c2 01 	lds	r24, 0x01C2
    3e5a:	90 91 c3 01 	lds	r25, 0x01C3
    3e5e:	0e 94 29 ae 	call	0x15c52	; 0x15c52 <mmc_write>
		  //mmc_readsingleblock(ActiveSector);
	      uart_printf(0,1,PSTR("Sector written"));
    3e62:	80 e0       	ldi	r24, 0x00	; 0
    3e64:	61 e0       	ldi	r22, 0x01	; 1
    3e66:	4f ef       	ldi	r20, 0xFF	; 255
    3e68:	52 e0       	ldi	r21, 0x02	; 2
    3e6a:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
          IsWrite=False;
    3e6e:	10 92 17 0e 	sts	0x0E17, r1
    3e72:	10 92 18 0e 	sts	0x0E18, r1
    3e76:	10 92 19 0e 	sts	0x0E19, r1
    3e7a:	10 92 1a 0e 	sts	0x0E1A, r1
		  IsRead=True;
    3e7e:	81 e0       	ldi	r24, 0x01	; 1
    3e80:	90 e0       	ldi	r25, 0x00	; 0
    3e82:	a0 e0       	ldi	r26, 0x00	; 0
    3e84:	b0 e0       	ldi	r27, 0x00	; 0
    3e86:	80 93 dc 0d 	sts	0x0DDC, r24
    3e8a:	90 93 dd 0d 	sts	0x0DDD, r25
    3e8e:	a0 93 de 0d 	sts	0x0DDE, r26
    3e92:	b0 93 df 0d 	sts	0x0DDF, r27
		  stTestMMC=tmWaitInstruction;
    3e96:	86 e0       	ldi	r24, 0x06	; 6
    3e98:	80 93 15 01 	sts	0x0115, r24
	      break;
	 }
}
    3e9c:	ca 5b       	subi	r28, 0xBA	; 186
    3e9e:	df 4f       	sbci	r29, 0xFF	; 255
    3ea0:	0f b6       	in	r0, 0x3f	; 63
    3ea2:	f8 94       	cli
    3ea4:	de bf       	out	0x3e, r29	; 62
    3ea6:	0f be       	out	0x3f, r0	; 63
    3ea8:	cd bf       	out	0x3d, r28	; 61
    3eaa:	cf 91       	pop	r28
    3eac:	df 91       	pop	r29
    3eae:	1f 91       	pop	r17
    3eb0:	0f 91       	pop	r16
    3eb2:	ff 90       	pop	r15
    3eb4:	ef 90       	pop	r14
    3eb6:	df 90       	pop	r13
    3eb8:	bf 90       	pop	r11
    3eba:	af 90       	pop	r10
    3ebc:	08 95       	ret

00003ebe <MasterReset>:
	 }
}

#define DEF_OPERATOR_NAME "Mr.Big"

void MasterReset(){
    3ebe:	df 92       	push	r13
    3ec0:	ef 92       	push	r14
    3ec2:	ff 92       	push	r15
    3ec4:	0f 93       	push	r16
    3ec6:	1f 93       	push	r17
    3ec8:	df 93       	push	r29
    3eca:	cf 93       	push	r28
    3ecc:	cd b7       	in	r28, 0x3d	; 61
    3ece:	de b7       	in	r29, 0x3e	; 62
    3ed0:	ec 97       	sbiw	r28, 0x3c	; 60
    3ed2:	0f b6       	in	r0, 0x3f	; 63
    3ed4:	f8 94       	cli
    3ed6:	de bf       	out	0x3e, r29	; 62
    3ed8:	0f be       	out	0x3f, r0	; 63
    3eda:	cd bf       	out	0x3d, r28	; 61
     char strEEP[50];
	 char xArray[10];
     //Restore All Stored EEPROM data to the Default
     sprintf_P(strEEP,PSTR(DEF_OPERATOR_NAME));
    3edc:	00 d0       	rcall	.+0      	; 0x3ede <MasterReset+0x20>
    3ede:	00 d0       	rcall	.+0      	; 0x3ee0 <MasterReset+0x22>
    3ee0:	8e 01       	movw	r16, r28
    3ee2:	05 5f       	subi	r16, 0xF5	; 245
    3ee4:	1f 4f       	sbci	r17, 0xFF	; 255
    3ee6:	ed b7       	in	r30, 0x3d	; 61
    3ee8:	fe b7       	in	r31, 0x3e	; 62
    3eea:	12 83       	std	Z+2, r17	; 0x02
    3eec:	01 83       	std	Z+1, r16	; 0x01
    3eee:	8a e7       	ldi	r24, 0x7A	; 122
    3ef0:	94 e0       	ldi	r25, 0x04	; 4
    3ef2:	94 83       	std	Z+4, r25	; 0x04
    3ef4:	83 83       	std	Z+3, r24	; 0x03
    3ef6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3efa:	0f 90       	pop	r0
    3efc:	0f 90       	pop	r0
    3efe:	0f 90       	pop	r0
    3f00:	0f 90       	pop	r0
    3f02:	85 e1       	ldi	r24, 0x15	; 21
    3f04:	90 e0       	ldi	r25, 0x00	; 0
    3f06:	b8 01       	movw	r22, r16
    3f08:	43 e1       	ldi	r20, 0x13	; 19
    3f0a:	50 e0       	ldi	r21, 0x00	; 0
    3f0c:	2a e4       	ldi	r18, 0x4A	; 74
    3f0e:	33 e1       	ldi	r19, 0x13	; 19
    3f10:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefOperatorName, sizeof(DefOperatorName));

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=70; 
    3f14:	60 ec       	ldi	r22, 0xC0	; 192
    3f16:	d6 2e       	mov	r13, r22
    3f18:	d9 82       	std	Y+1, r13	; 0x01
    3f1a:	58 ea       	ldi	r21, 0xA8	; 168
    3f1c:	e5 2e       	mov	r14, r21
    3f1e:	ea 82       	std	Y+2, r14	; 0x02
    3f20:	40 e1       	ldi	r20, 0x10	; 16
    3f22:	f4 2e       	mov	r15, r20
    3f24:	fb 82       	std	Y+3, r15	; 0x03
    3f26:	86 e4       	ldi	r24, 0x46	; 70
    3f28:	8c 83       	std	Y+4, r24	; 0x04
    3f2a:	88 e2       	ldi	r24, 0x28	; 40
    3f2c:	90 e0       	ldi	r25, 0x00	; 0
    3f2e:	8e 01       	movw	r16, r28
    3f30:	0f 5f       	subi	r16, 0xFF	; 255
    3f32:	1f 4f       	sbci	r17, 0xFF	; 255
    3f34:	b8 01       	movw	r22, r16
    3f36:	44 e0       	ldi	r20, 0x04	; 4
    3f38:	50 e0       	ldi	r21, 0x00	; 0
    3f3a:	2a e4       	ldi	r18, 0x4A	; 74
    3f3c:	33 e1       	ldi	r19, 0x13	; 19
    3f3e:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefClientIP, 4);

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=180; 
    3f42:	d9 82       	std	Y+1, r13	; 0x01
    3f44:	ea 82       	std	Y+2, r14	; 0x02
    3f46:	fb 82       	std	Y+3, r15	; 0x03
    3f48:	84 eb       	ldi	r24, 0xB4	; 180
    3f4a:	8c 83       	std	Y+4, r24	; 0x04
    3f4c:	8c e2       	ldi	r24, 0x2C	; 44
    3f4e:	90 e0       	ldi	r25, 0x00	; 0
    3f50:	b8 01       	movw	r22, r16
    3f52:	44 e0       	ldi	r20, 0x04	; 4
    3f54:	50 e0       	ldi	r21, 0x00	; 0
    3f56:	2a e4       	ldi	r18, 0x4A	; 74
    3f58:	33 e1       	ldi	r19, 0x13	; 19
    3f5a:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f5e:	e1 99       	sbic	0x1c, 1	; 28
    3f60:	fe cf       	rjmp	.-4      	; 0x3f5e <MasterReset+0xa0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f62:	80 e3       	ldi	r24, 0x30	; 48
    3f64:	90 e0       	ldi	r25, 0x00	; 0
    3f66:	9f bb       	out	0x1f, r25	; 31
    3f68:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f6a:	81 e0       	ldi	r24, 0x01	; 1
    3f6c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3f6e:	0f b6       	in	r0, 0x3f	; 63
    3f70:	f8 94       	cli
    3f72:	e2 9a       	sbi	0x1c, 2	; 28
    3f74:	e1 9a       	sbi	0x1c, 1	; 28
    3f76:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f78:	e1 99       	sbic	0x1c, 1	; 28
    3f7a:	fe cf       	rjmp	.-4      	; 0x3f78 <MasterReset+0xba>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f7c:	81 e3       	ldi	r24, 0x31	; 49
    3f7e:	90 e0       	ldi	r25, 0x00	; 0
    3f80:	9f bb       	out	0x1f, r25	; 31
    3f82:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f84:	87 e0       	ldi	r24, 0x07	; 7
    3f86:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3f88:	0f b6       	in	r0, 0x3f	; 63
    3f8a:	f8 94       	cli
    3f8c:	e2 9a       	sbi	0x1c, 2	; 28
    3f8e:	e1 9a       	sbi	0x1c, 1	; 28
    3f90:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f92:	e1 99       	sbic	0x1c, 1	; 28
    3f94:	fe cf       	rjmp	.-4      	; 0x3f92 <MasterReset+0xd4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f96:	82 e3       	ldi	r24, 0x32	; 50
    3f98:	90 e0       	ldi	r25, 0x00	; 0
    3f9a:	9f bb       	out	0x1f, r25	; 31
    3f9c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f9e:	85 e0       	ldi	r24, 0x05	; 5
    3fa0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3fa2:	0f b6       	in	r0, 0x3f	; 63
    3fa4:	f8 94       	cli
    3fa6:	e2 9a       	sbi	0x1c, 2	; 28
    3fa8:	e1 9a       	sbi	0x1c, 1	; 28
    3faa:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3fac:	e1 99       	sbic	0x1c, 1	; 28
    3fae:	fe cf       	rjmp	.-4      	; 0x3fac <MasterReset+0xee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3fb0:	83 e3       	ldi	r24, 0x33	; 51
    3fb2:	90 e0       	ldi	r25, 0x00	; 0
    3fb4:	9f bb       	out	0x1f, r25	; 31
    3fb6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3fb8:	82 e0       	ldi	r24, 0x02	; 2
    3fba:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3fbc:	0f b6       	in	r0, 0x3f	; 63
    3fbe:	f8 94       	cli
    3fc0:	e2 9a       	sbi	0x1c, 2	; 28
    3fc2:	e1 9a       	sbi	0x1c, 1	; 28
    3fc4:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3fc6:	e1 99       	sbic	0x1c, 1	; 28
    3fc8:	fe cf       	rjmp	.-4      	; 0x3fc6 <MasterReset+0x108>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3fca:	84 e3       	ldi	r24, 0x34	; 52
    3fcc:	90 e0       	ldi	r25, 0x00	; 0
    3fce:	9f bb       	out	0x1f, r25	; 31
    3fd0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3fd2:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3fd4:	0f b6       	in	r0, 0x3f	; 63
    3fd6:	f8 94       	cli
    3fd8:	e2 9a       	sbi	0x1c, 2	; 28
    3fda:	e1 9a       	sbi	0x1c, 1	; 28
    3fdc:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3fde:	e1 99       	sbic	0x1c, 1	; 28
    3fe0:	fe cf       	rjmp	.-4      	; 0x3fde <MasterReset+0x120>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3fe2:	85 e3       	ldi	r24, 0x35	; 53
    3fe4:	90 e0       	ldi	r25, 0x00	; 0
    3fe6:	9f bb       	out	0x1f, r25	; 31
    3fe8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3fea:	83 e0       	ldi	r24, 0x03	; 3
    3fec:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3fee:	0f b6       	in	r0, 0x3f	; 63
    3ff0:	f8 94       	cli
    3ff2:	e2 9a       	sbi	0x1c, 2	; 28
    3ff4:	e1 9a       	sbi	0x1c, 1	; 28
    3ff6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3ff8:	e1 99       	sbic	0x1c, 1	; 28
    3ffa:	fe cf       	rjmp	.-4      	; 0x3ff8 <MasterReset+0x13a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3ffc:	86 e3       	ldi	r24, 0x36	; 54
    3ffe:	90 e0       	ldi	r25, 0x00	; 0
    4000:	9f bb       	out	0x1f, r25	; 31
    4002:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    4004:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    4006:	0f b6       	in	r0, 0x3f	; 63
    4008:	f8 94       	cli
    400a:	e2 9a       	sbi	0x1c, 2	; 28
    400c:	e1 9a       	sbi	0x1c, 1	; 28
    400e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    4010:	e1 99       	sbic	0x1c, 1	; 28
    4012:	fe cf       	rjmp	.-4      	; 0x4010 <MasterReset+0x152>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4014:	87 e3       	ldi	r24, 0x37	; 55
    4016:	90 e0       	ldi	r25, 0x00	; 0
    4018:	9f bb       	out	0x1f, r25	; 31
    401a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    401c:	81 e0       	ldi	r24, 0x01	; 1
    401e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    4020:	0f b6       	in	r0, 0x3f	; 63
    4022:	f8 94       	cli
    4024:	e2 9a       	sbi	0x1c, 2	; 28
    4026:	e1 9a       	sbi	0x1c, 1	; 28
    4028:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    402a:	e1 99       	sbic	0x1c, 1	; 28
    402c:	fe cf       	rjmp	.-4      	; 0x402a <MasterReset+0x16c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    402e:	88 e3       	ldi	r24, 0x38	; 56
    4030:	90 e0       	ldi	r25, 0x00	; 0
    4032:	9f bb       	out	0x1f, r25	; 31
    4034:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    4036:	81 e0       	ldi	r24, 0x01	; 1
    4038:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    403a:	0f b6       	in	r0, 0x3f	; 63
    403c:	f8 94       	cli
    403e:	e2 9a       	sbi	0x1c, 2	; 28
    4040:	e1 9a       	sbi	0x1c, 1	; 28
    4042:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    4044:	e1 99       	sbic	0x1c, 1	; 28
    4046:	fe cf       	rjmp	.-4      	; 0x4044 <MasterReset+0x186>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4048:	89 e3       	ldi	r24, 0x39	; 57
    404a:	90 e0       	ldi	r25, 0x00	; 0
    404c:	9f bb       	out	0x1f, r25	; 31
    404e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    4050:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    4052:	0f b6       	in	r0, 0x3f	; 63
    4054:	f8 94       	cli
    4056:	e2 9a       	sbi	0x1c, 2	; 28
    4058:	e1 9a       	sbi	0x1c, 1	; 28
    405a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    405c:	e1 99       	sbic	0x1c, 1	; 28
    405e:	fe cf       	rjmp	.-4      	; 0x405c <MasterReset+0x19e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4060:	8a e3       	ldi	r24, 0x3A	; 58
    4062:	90 e0       	ldi	r25, 0x00	; 0
    4064:	9f bb       	out	0x1f, r25	; 31
    4066:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    4068:	83 e0       	ldi	r24, 0x03	; 3
    406a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    406c:	0f b6       	in	r0, 0x3f	; 63
    406e:	f8 94       	cli
    4070:	e2 9a       	sbi	0x1c, 2	; 28
    4072:	e1 9a       	sbi	0x1c, 1	; 28
    4074:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    4076:	e1 99       	sbic	0x1c, 1	; 28
    4078:	fe cf       	rjmp	.-4      	; 0x4076 <MasterReset+0x1b8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    407a:	8b e3       	ldi	r24, 0x3B	; 59
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	9f bb       	out	0x1f, r25	; 31
    4080:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    4082:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    4084:	0f b6       	in	r0, 0x3f	; 63
    4086:	f8 94       	cli
    4088:	e2 9a       	sbi	0x1c, 2	; 28
    408a:	e1 9a       	sbi	0x1c, 1	; 28
    408c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    408e:	e1 99       	sbic	0x1c, 1	; 28
    4090:	fe cf       	rjmp	.-4      	; 0x408e <MasterReset+0x1d0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4092:	8c e3       	ldi	r24, 0x3C	; 60
    4094:	90 e0       	ldi	r25, 0x00	; 0
    4096:	9f bb       	out	0x1f, r25	; 31
    4098:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    409a:	82 e0       	ldi	r24, 0x02	; 2
    409c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    409e:	0f b6       	in	r0, 0x3f	; 63
    40a0:	f8 94       	cli
    40a2:	e2 9a       	sbi	0x1c, 2	; 28
    40a4:	e1 9a       	sbi	0x1c, 1	; 28
    40a6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    40a8:	e1 99       	sbic	0x1c, 1	; 28
    40aa:	fe cf       	rjmp	.-4      	; 0x40a8 <MasterReset+0x1ea>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    40ac:	8d e3       	ldi	r24, 0x3D	; 61
    40ae:	90 e0       	ldi	r25, 0x00	; 0
    40b0:	9f bb       	out	0x1f, r25	; 31
    40b2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    40b4:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    40b6:	0f b6       	in	r0, 0x3f	; 63
    40b8:	f8 94       	cli
    40ba:	e2 9a       	sbi	0x1c, 2	; 28
    40bc:	e1 9a       	sbi	0x1c, 1	; 28
    40be:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    40c0:	e1 99       	sbic	0x1c, 1	; 28
    40c2:	fe cf       	rjmp	.-4      	; 0x40c0 <MasterReset+0x202>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    40c4:	8e e3       	ldi	r24, 0x3E	; 62
    40c6:	90 e0       	ldi	r25, 0x00	; 0
    40c8:	9f bb       	out	0x1f, r25	; 31
    40ca:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    40cc:	8c e2       	ldi	r24, 0x2C	; 44
    40ce:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    40d0:	0f b6       	in	r0, 0x3f	; 63
    40d2:	f8 94       	cli
    40d4:	e2 9a       	sbi	0x1c, 2	; 28
    40d6:	e1 9a       	sbi	0x1c, 1	; 28
    40d8:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    40da:	e1 99       	sbic	0x1c, 1	; 28
    40dc:	fe cf       	rjmp	.-4      	; 0x40da <MasterReset+0x21c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    40de:	8f e3       	ldi	r24, 0x3F	; 63
    40e0:	90 e0       	ldi	r25, 0x00	; 0
    40e2:	9f bb       	out	0x1f, r25	; 31
    40e4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    40e6:	9e e2       	ldi	r25, 0x2E	; 46
    40e8:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    40ea:	0f b6       	in	r0, 0x3f	; 63
    40ec:	f8 94       	cli
    40ee:	e2 9a       	sbi	0x1c, 2	; 28
    40f0:	e1 9a       	sbi	0x1c, 1	; 28
    40f2:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefDecimalTotalVolume,2);
	 eeprom_write_byte(&DefDecimalTotalMoney,0);
	 eeprom_write_byte(&DefDecimalMark,',');
	 eeprom_write_byte(&DefCurrencyMark,'.');

	 xArray[0]=',';	 xArray[1]='.'; 	 xArray[2]=' ';	 xArray[3]='/';  xArray[4]='-'; 
    40f4:	8c e2       	ldi	r24, 0x2C	; 44
    40f6:	89 83       	std	Y+1, r24	; 0x01
    40f8:	9a 83       	std	Y+2, r25	; 0x02
    40fa:	80 e2       	ldi	r24, 0x20	; 32
    40fc:	8b 83       	std	Y+3, r24	; 0x03
    40fe:	8f e2       	ldi	r24, 0x2F	; 47
    4100:	8c 83       	std	Y+4, r24	; 0x04
    4102:	8d e2       	ldi	r24, 0x2D	; 45
    4104:	8d 83       	std	Y+5, r24	; 0x05
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    4106:	80 e4       	ldi	r24, 0x40	; 64
    4108:	90 e0       	ldi	r25, 0x00	; 0
    410a:	8e 01       	movw	r16, r28
    410c:	0f 5f       	subi	r16, 0xFF	; 255
    410e:	1f 4f       	sbci	r17, 0xFF	; 255
    4110:	b8 01       	movw	r22, r16
    4112:	45 e0       	ldi	r20, 0x05	; 5
    4114:	50 e0       	ldi	r21, 0x00	; 0
    4116:	2a e4       	ldi	r18, 0x4A	; 74
    4118:	33 e1       	ldi	r19, 0x13	; 19
    411a:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefMarkMap, 5);

	 xArray[0]=1;	 xArray[1]=2; 	 xArray[2]=0;	 xArray[3]=0; xArray[4]=0;	 xArray[5]=0; xArray[6]=0;	 	 
    411e:	81 e0       	ldi	r24, 0x01	; 1
    4120:	89 83       	std	Y+1, r24	; 0x01
    4122:	82 e0       	ldi	r24, 0x02	; 2
    4124:	8a 83       	std	Y+2, r24	; 0x02
    4126:	1b 82       	std	Y+3, r1	; 0x03
    4128:	1c 82       	std	Y+4, r1	; 0x04
    412a:	1d 82       	std	Y+5, r1	; 0x05
    412c:	1e 82       	std	Y+6, r1	; 0x06
    412e:	1f 82       	std	Y+7, r1	; 0x07
    4130:	85 e4       	ldi	r24, 0x45	; 69
    4132:	90 e0       	ldi	r25, 0x00	; 0
    4134:	b8 01       	movw	r22, r16
    4136:	48 e0       	ldi	r20, 0x08	; 8
    4138:	50 e0       	ldi	r21, 0x00	; 0
    413a:	2a e4       	ldi	r18, 0x4A	; 74
    413c:	33 e1       	ldi	r19, 0x13	; 19
    413e:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpMap, 8);
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpLabel, 8);     
}
    4142:	8d e4       	ldi	r24, 0x4D	; 77
    4144:	90 e0       	ldi	r25, 0x00	; 0
    4146:	b8 01       	movw	r22, r16
    4148:	48 e0       	ldi	r20, 0x08	; 8
    414a:	50 e0       	ldi	r21, 0x00	; 0
    414c:	2a e4       	ldi	r18, 0x4A	; 74
    414e:	33 e1       	ldi	r19, 0x13	; 19
    4150:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    4154:	ec 96       	adiw	r28, 0x3c	; 60
    4156:	0f b6       	in	r0, 0x3f	; 63
    4158:	f8 94       	cli
    415a:	de bf       	out	0x3e, r29	; 62
    415c:	0f be       	out	0x3f, r0	; 63
    415e:	cd bf       	out	0x3d, r28	; 61
    4160:	cf 91       	pop	r28
    4162:	df 91       	pop	r29
    4164:	1f 91       	pop	r17
    4166:	0f 91       	pop	r16
    4168:	ff 90       	pop	r15
    416a:	ef 90       	pop	r14
    416c:	df 90       	pop	r13
    416e:	08 95       	ret

00004170 <procMessage21>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    4170:	af 92       	push	r10
    4172:	bf 92       	push	r11
    4174:	cf 92       	push	r12
    4176:	df 92       	push	r13
    4178:	ef 92       	push	r14
    417a:	ff 92       	push	r15
    417c:	0f 93       	push	r16
    417e:	1f 93       	push	r17
    4180:	df 93       	push	r29
    4182:	cf 93       	push	r28
    4184:	cd b7       	in	r28, 0x3d	; 61
    4186:	de b7       	in	r29, 0x3e	; 62
    4188:	2b 97       	sbiw	r28, 0x0b	; 11
    418a:	0f b6       	in	r0, 0x3f	; 63
    418c:	f8 94       	cli
    418e:	de bf       	out	0x3e, r29	; 62
    4190:	0f be       	out	0x3f, r0	; 63
    4192:	cd bf       	out	0x3d, r28	; 61
    4194:	09 e0       	ldi	r16, 0x09	; 9
    4196:	11 e0       	ldi	r17, 0x01	; 1
    4198:	eb e4       	ldi	r30, 0x4B	; 75
    419a:	ee 2e       	mov	r14, r30
    419c:	eb e0       	ldi	r30, 0x0B	; 11
    419e:	fe 2e       	mov	r15, r30
    41a0:	6e 01       	movw	r12, r28
    41a2:	08 94       	sec
    41a4:	c1 1c       	adc	r12, r1
    41a6:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    41a8:	7b e0       	ldi	r23, 0x0B	; 11
    41aa:	a7 2e       	mov	r10, r23
    41ac:	b1 2c       	mov	r11, r1
    41ae:	ac 0e       	add	r10, r28
    41b0:	bd 1e       	adc	r11, r29
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    41b2:	f6 01       	movw	r30, r12
    41b4:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    41b6:	8d 91       	ld	r24, X+
    41b8:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    41ba:	ea 15       	cp	r30, r10
    41bc:	fb 05       	cpc	r31, r11
    41be:	d9 f7       	brne	.-10     	; 0x41b6 <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    41c0:	1b 86       	std	Y+11, r1	; 0x0b
    41c2:	c8 01       	movw	r24, r16
    41c4:	b6 01       	movw	r22, r12
    41c6:	4b e0       	ldi	r20, 0x0B	; 11
    41c8:	50 e0       	ldi	r21, 0x00	; 0
    41ca:	2a e4       	ldi	r18, 0x4A	; 74
    41cc:	33 e1       	ldi	r19, 0x13	; 19
    41ce:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    41d2:	05 5f       	subi	r16, 0xF5	; 245
    41d4:	1f 4f       	sbci	r17, 0xFF	; 255
    41d6:	8a e0       	ldi	r24, 0x0A	; 10
    41d8:	90 e0       	ldi	r25, 0x00	; 0
    41da:	e8 0e       	add	r14, r24
    41dc:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    41de:	91 e0       	ldi	r25, 0x01	; 1
    41e0:	05 33       	cpi	r16, 0x35	; 53
    41e2:	19 07       	cpc	r17, r25
    41e4:	31 f7       	brne	.-52     	; 0x41b2 <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    41e6:	80 e0       	ldi	r24, 0x00	; 0
    41e8:	2b 96       	adiw	r28, 0x0b	; 11
    41ea:	0f b6       	in	r0, 0x3f	; 63
    41ec:	f8 94       	cli
    41ee:	de bf       	out	0x3e, r29	; 62
    41f0:	0f be       	out	0x3f, r0	; 63
    41f2:	cd bf       	out	0x3d, r28	; 61
    41f4:	cf 91       	pop	r28
    41f6:	df 91       	pop	r29
    41f8:	1f 91       	pop	r17
    41fa:	0f 91       	pop	r16
    41fc:	ff 90       	pop	r15
    41fe:	ef 90       	pop	r14
    4200:	df 90       	pop	r13
    4202:	cf 90       	pop	r12
    4204:	bf 90       	pop	r11
    4206:	af 90       	pop	r10
    4208:	08 95       	ret

0000420a <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){//Find FIP Addr based on PumpID respectively: 
    420a:	ff 92       	push	r15
    420c:	0f 93       	push	r16
    420e:	1f 93       	push	r17
    4210:	df 93       	push	r29
    4212:	cf 93       	push	r28
    4214:	cd b7       	in	r28, 0x3d	; 61
    4216:	de b7       	in	r29, 0x3e	; 62
    4218:	28 97       	sbiw	r28, 0x08	; 8
    421a:	0f b6       	in	r0, 0x3f	; 63
    421c:	f8 94       	cli
    421e:	de bf       	out	0x3e, r29	; 62
    4220:	0f be       	out	0x3f, r0	; 63
    4222:	cd bf       	out	0x3d, r28	; 61
    4224:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4226:	8e 01       	movw	r16, r28
    4228:	0f 5f       	subi	r16, 0xFF	; 255
    422a:	1f 4f       	sbci	r17, 0xFF	; 255
    422c:	c8 01       	movw	r24, r16
    422e:	65 e4       	ldi	r22, 0x45	; 69
    4230:	70 e0       	ldi	r23, 0x00	; 0
    4232:	48 e0       	ldi	r20, 0x08	; 8
    4234:	50 e0       	ldi	r21, 0x00	; 0
    4236:	22 e4       	ldi	r18, 0x42	; 66
    4238:	33 e1       	ldi	r19, 0x13	; 19
    423a:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    423e:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     //FIP1..FIP8
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    4240:	9e 01       	movw	r18, r28
    4242:	27 5f       	subi	r18, 0xF7	; 247
    4244:	3f 4f       	sbci	r19, 0xFF	; 255
    4246:	9e 2f       	mov	r25, r30
    4248:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    424a:	80 81       	ld	r24, Z
    424c:	8f 15       	cp	r24, r15
    424e:	19 f4       	brne	.+6      	; 0x4256 <GetFIPAddr+0x4c>
		     Result=i+1;
    4250:	89 2f       	mov	r24, r25
    4252:	8f 5f       	subi	r24, 0xFF	; 255
    4254:	05 c0       	rjmp	.+10     	; 0x4260 <GetFIPAddr+0x56>
			 break;
    4256:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){//Find FIP Addr based on PumpID respectively: 
char i,PPumpID[8],Result;     //FIP1..FIP8
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    4258:	e2 17       	cp	r30, r18
    425a:	f3 07       	cpc	r31, r19
    425c:	a1 f7       	brne	.-24     	; 0x4246 <GetFIPAddr+0x3c>
    425e:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    4260:	28 96       	adiw	r28, 0x08	; 8
    4262:	0f b6       	in	r0, 0x3f	; 63
    4264:	f8 94       	cli
    4266:	de bf       	out	0x3e, r29	; 62
    4268:	0f be       	out	0x3f, r0	; 63
    426a:	cd bf       	out	0x3d, r28	; 61
    426c:	cf 91       	pop	r28
    426e:	df 91       	pop	r29
    4270:	1f 91       	pop	r17
    4272:	0f 91       	pop	r16
    4274:	ff 90       	pop	r15
    4276:	08 95       	ret

00004278 <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    4278:	ff 92       	push	r15
    427a:	0f 93       	push	r16
    427c:	1f 93       	push	r17
    427e:	cf 93       	push	r28
    4280:	df 93       	push	r29
    4282:	28 2f       	mov	r18, r24
    4284:	f6 2e       	mov	r15, r22
char strSend[20],iPumpID; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    4286:	80 31       	cpi	r24, 0x10	; 16
    4288:	08 f0       	brcs	.+2      	; 0x428c <UpdateStandaloneStatus+0x14>
    428a:	4e c0       	rjmp	.+156    	; 0x4328 <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    428c:	e1 99       	sbic	0x1c, 1	; 28
    428e:	fe cf       	rjmp	.-4      	; 0x428c <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4290:	87 e3       	ldi	r24, 0x37	; 55
    4292:	91 e0       	ldi	r25, 0x01	; 1
    4294:	9f bb       	out	0x1f, r25	; 31
    4296:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4298:	e0 9a       	sbi	0x1c, 0	; 28
    429a:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    429c:	80 93 50 01 	sts	0x0150, r24
	     switch(DispenserBrand){
    42a0:	81 50       	subi	r24, 0x01	; 1
    42a2:	82 30       	cpi	r24, 0x02	; 2
    42a4:	08 f4       	brcc	.+2      	; 0x42a8 <UpdateStandaloneStatus+0x30>
    42a6:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    42a8:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
		 if (iAddr>0){
    42ac:	88 23       	and	r24, r24
    42ae:	e1 f1       	breq	.+120    	; 0x4328 <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    42b0:	81 50       	subi	r24, 0x01	; 1
    42b2:	c8 2f       	mov	r28, r24
    42b4:	d0 e0       	ldi	r29, 0x00	; 0
    42b6:	80 e1       	ldi	r24, 0x10	; 16
    42b8:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    42bc:	8e 01       	movw	r16, r28
    42be:	0e 5f       	subi	r16, 0xFE	; 254
    42c0:	1e 4f       	sbci	r17, 0xFE	; 254
    42c2:	f8 01       	movw	r30, r16
    42c4:	90 81       	ld	r25, Z
    42c6:	98 17       	cp	r25, r24
    42c8:	b1 f0       	breq	.+44     	; 0x42f6 <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    42ca:	f0 e1       	ldi	r31, 0x10	; 16
    42cc:	ff 16       	cp	r15, r31
    42ce:	21 f0       	breq	.+8      	; 0x42d8 <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    42d0:	fe 01       	movw	r30, r28
    42d2:	ef 5a       	subi	r30, 0xAF	; 175
    42d4:	fe 4f       	sbci	r31, 0xFE	; 254
    42d6:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    42d8:	8f 2d       	mov	r24, r15
    42da:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    42de:	8e 01       	movw	r16, r28
    42e0:	0e 5f       	subi	r16, 0xFE	; 254
    42e2:	1e 4f       	sbci	r17, 0xFE	; 254
    42e4:	f8 01       	movw	r30, r16
    42e6:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    42e8:	f5 e1       	ldi	r31, 0x15	; 21
    42ea:	ff 16       	cp	r15, r31
    42ec:	c1 f4       	brne	.+48     	; 0x431e <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    42ee:	cf 5a       	subi	r28, 0xAF	; 175
    42f0:	de 4f       	sbci	r29, 0xFE	; 254
    42f2:	88 81       	ld	r24, Y
    42f4:	10 c0       	rjmp	.+32     	; 0x4316 <UpdateStandaloneStatus+0x9e>
    42f6:	fe 01       	movw	r30, r28
    42f8:	ef 5a       	subi	r30, 0xAF	; 175
    42fa:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED){
    42fc:	81 e1       	ldi	r24, 0x11	; 17
    42fe:	f8 16       	cp	r15, r24
    4300:	11 f4       	brne	.+4      	; 0x4306 <UpdateStandaloneStatus+0x8e>
				 //New

				     //if (CurrentPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY))
			             strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    4302:	80 81       	ld	r24, Z
    4304:	08 c0       	rjmp	.+16     	; 0x4316 <UpdateStandaloneStatus+0x9e>
					 //    CurrentPumpStatus[iAddr]=PUMP_OFF;
					 //    strPumpStatus[iAddr]=GetPumpStatusLabel(PUMP_OFF);
					 //}

				  }
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    4306:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    4308:	8b e0       	ldi	r24, 0x0B	; 11
    430a:	f8 16       	cp	r15, r24
    430c:	21 f0       	breq	.+8      	; 0x4316 <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    430e:	f4 e1       	ldi	r31, 0x14	; 20
    4310:	ff 16       	cp	r15, r31
    4312:	29 f4       	brne	.+10     	; 0x431e <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    4314:	84 e1       	ldi	r24, 0x14	; 20
    4316:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    431a:	f8 01       	movw	r30, r16
    431c:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    431e:	10 92 12 01 	sts	0x0112, r1
	     IsNewPumpStatus=True;		 
    4322:	81 e0       	ldi	r24, 0x01	; 1
    4324:	80 93 01 01 	sts	0x0101, r24
		 }		 
	 }
}
    4328:	df 91       	pop	r29
    432a:	cf 91       	pop	r28
    432c:	1f 91       	pop	r17
    432e:	0f 91       	pop	r16
    4330:	ff 90       	pop	r15
    4332:	08 95       	ret

00004334 <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    4334:	1f 93       	push	r17
    4336:	df 93       	push	r29
    4338:	cf 93       	push	r28
    433a:	cd b7       	in	r28, 0x3d	; 61
    433c:	de b7       	in	r29, 0x3e	; 62
    433e:	28 97       	sbiw	r28, 0x08	; 8
    4340:	0f b6       	in	r0, 0x3f	; 63
    4342:	f8 94       	cli
    4344:	de bf       	out	0x3e, r29	; 62
    4346:	0f be       	out	0x3f, r0	; 63
    4348:	cd bf       	out	0x3d, r28	; 61
    434a:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    434c:	ce 01       	movw	r24, r28
    434e:	01 96       	adiw	r24, 0x01	; 1
    4350:	65 e4       	ldi	r22, 0x45	; 69
    4352:	70 e0       	ldi	r23, 0x00	; 0
    4354:	48 e0       	ldi	r20, 0x08	; 8
    4356:	50 e0       	ldi	r21, 0x00	; 0
    4358:	22 e4       	ldi	r18, 0x42	; 66
    435a:	33 e1       	ldi	r19, 0x13	; 19
    435c:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    4360:	81 2f       	mov	r24, r17
    4362:	81 50       	subi	r24, 0x01	; 1
    4364:	87 30       	cpi	r24, 0x07	; 7
    4366:	10 f0       	brcs	.+4      	; 0x436c <GetPumpID+0x38>
    4368:	80 e0       	ldi	r24, 0x00	; 0
    436a:	04 c0       	rjmp	.+8      	; 0x4374 <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    436c:	fe 01       	movw	r30, r28
    436e:	e1 0f       	add	r30, r17
    4370:	f1 1d       	adc	r31, r1
    4372:	80 81       	ld	r24, Z
	 }
   return Result;
}
    4374:	28 96       	adiw	r28, 0x08	; 8
    4376:	0f b6       	in	r0, 0x3f	; 63
    4378:	f8 94       	cli
    437a:	de bf       	out	0x3e, r29	; 62
    437c:	0f be       	out	0x3f, r0	; 63
    437e:	cd bf       	out	0x3d, r28	; 61
    4380:	cf 91       	pop	r28
    4382:	df 91       	pop	r29
    4384:	1f 91       	pop	r17
    4386:	08 95       	ret

00004388 <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    4388:	0f 93       	push	r16
    438a:	1f 93       	push	r17
    438c:	df 93       	push	r29
    438e:	cf 93       	push	r28
    4390:	00 d0       	rcall	.+0      	; 0x4392 <GetTotalizerData+0xa>
    4392:	00 d0       	rcall	.+0      	; 0x4394 <GetTotalizerData+0xc>
    4394:	00 d0       	rcall	.+0      	; 0x4396 <GetTotalizerData+0xe>
    4396:	cd b7       	in	r28, 0x3d	; 61
    4398:	de b7       	in	r29, 0x3e	; 62
    439a:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    439c:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    439e:	21 50       	subi	r18, 0x01	; 1
    43a0:	26 30       	cpi	r18, 0x06	; 6
    43a2:	08 f4       	brcc	.+2      	; 0x43a6 <GetTotalizerData+0x1e>
    43a4:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    43a6:	88 23       	and	r24, r24
    43a8:	d9 f4       	brne	.+54     	; 0x43e0 <GetTotalizerData+0x58>
    43aa:	64 e2       	ldi	r22, 0x24	; 36
    43ac:	46 9f       	mul	r20, r22
    43ae:	b0 01       	movw	r22, r0
    43b0:	11 24       	eor	r1, r1
    43b2:	29 2f       	mov	r18, r25
    43b4:	30 e0       	ldi	r19, 0x00	; 0
    43b6:	80 e2       	ldi	r24, 0x20	; 32
    43b8:	91 e0       	ldi	r25, 0x01	; 1
    43ba:	fc 01       	movw	r30, r24
    43bc:	2e 9f       	mul	r18, r30
    43be:	c0 01       	movw	r24, r0
    43c0:	2f 9f       	mul	r18, r31
    43c2:	90 0d       	add	r25, r0
    43c4:	3e 9f       	mul	r19, r30
    43c6:	90 0d       	add	r25, r0
    43c8:	11 24       	eor	r1, r1
    43ca:	68 0f       	add	r22, r24
    43cc:	79 1f       	adc	r23, r25
    43ce:	86 e0       	ldi	r24, 0x06	; 6
    43d0:	58 9f       	mul	r21, r24
    43d2:	c0 01       	movw	r24, r0
    43d4:	11 24       	eor	r1, r1
    43d6:	68 0f       	add	r22, r24
    43d8:	79 1f       	adc	r23, r25
    43da:	6d 53       	subi	r22, 0x3D	; 61
    43dc:	7c 4f       	sbci	r23, 0xFC	; 252
    43de:	1c c0       	rjmp	.+56     	; 0x4418 <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    43e0:	81 30       	cpi	r24, 0x01	; 1
    43e2:	11 f5       	brne	.+68     	; 0x4428 <GetTotalizerData+0xa0>
    43e4:	64 e2       	ldi	r22, 0x24	; 36
    43e6:	46 9f       	mul	r20, r22
    43e8:	b0 01       	movw	r22, r0
    43ea:	11 24       	eor	r1, r1
    43ec:	29 2f       	mov	r18, r25
    43ee:	30 e0       	ldi	r19, 0x00	; 0
    43f0:	80 e2       	ldi	r24, 0x20	; 32
    43f2:	91 e0       	ldi	r25, 0x01	; 1
    43f4:	fc 01       	movw	r30, r24
    43f6:	2e 9f       	mul	r18, r30
    43f8:	c0 01       	movw	r24, r0
    43fa:	2f 9f       	mul	r18, r31
    43fc:	90 0d       	add	r25, r0
    43fe:	3e 9f       	mul	r19, r30
    4400:	90 0d       	add	r25, r0
    4402:	11 24       	eor	r1, r1
    4404:	68 0f       	add	r22, r24
    4406:	79 1f       	adc	r23, r25
    4408:	86 e0       	ldi	r24, 0x06	; 6
    440a:	58 9f       	mul	r21, r24
    440c:	c0 01       	movw	r24, r0
    440e:	11 24       	eor	r1, r1
    4410:	68 0f       	add	r22, r24
    4412:	79 1f       	adc	r23, r25
    4414:	6d 5f       	subi	r22, 0xFD	; 253
    4416:	79 4f       	sbci	r23, 0xF9	; 249
    4418:	ce 01       	movw	r24, r28
    441a:	01 96       	adiw	r24, 0x01	; 1
    441c:	46 e0       	ldi	r20, 0x06	; 6
    441e:	50 e0       	ldi	r21, 0x00	; 0
    4420:	22 e4       	ldi	r18, 0x42	; 66
    4422:	33 e1       	ldi	r19, 0x13	; 19
    4424:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    4428:	ce 01       	movw	r24, r28
    442a:	01 96       	adiw	r24, 0x01	; 1
    442c:	b8 01       	movw	r22, r16
    442e:	0e 94 94 19 	call	0x3328	; 0x3328 <RawToStr>
}
    4432:	26 96       	adiw	r28, 0x06	; 6
    4434:	0f b6       	in	r0, 0x3f	; 63
    4436:	f8 94       	cli
    4438:	de bf       	out	0x3e, r29	; 62
    443a:	0f be       	out	0x3f, r0	; 63
    443c:	cd bf       	out	0x3d, r28	; 61
    443e:	cf 91       	pop	r28
    4440:	df 91       	pop	r29
    4442:	1f 91       	pop	r17
    4444:	0f 91       	pop	r16
    4446:	08 95       	ret

00004448 <SaveToEEPROM>:
     return Result;
}



char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    4448:	ef 92       	push	r14
    444a:	ff 92       	push	r15
    444c:	0f 93       	push	r16
    444e:	1f 93       	push	r17
    4450:	df 93       	push	r29
    4452:	cf 93       	push	r28
    4454:	cd b7       	in	r28, 0x3d	; 61
    4456:	de b7       	in	r29, 0x3e	; 62
    4458:	ac 97       	sbiw	r28, 0x2c	; 44
    445a:	0f b6       	in	r0, 0x3f	; 63
    445c:	f8 94       	cli
    445e:	de bf       	out	0x3e, r29	; 62
    4460:	0f be       	out	0x3f, r0	; 63
    4462:	cd bf       	out	0x3d, r28	; 61
    4464:	9a a7       	std	Y+42, r25	; 0x2a
    4466:	89 a7       	std	Y+41, r24	; 0x29
    4468:	7c a7       	std	Y+44, r23	; 0x2c
    446a:	6b a7       	std	Y+43, r22	; 0x2b
    446c:	7a 01       	movw	r14, r20
    446e:	8e 01       	movw	r16, r28
    4470:	05 5d       	subi	r16, 0xD5	; 213
    4472:	1f 4f       	sbci	r17, 0xFF	; 255
    4474:	c8 01       	movw	r24, r16
    4476:	be 01       	movw	r22, r28
    4478:	6f 5f       	subi	r22, 0xFF	; 255
    447a:	7f 4f       	sbci	r23, 0xFF	; 255
    447c:	22 e4       	ldi	r18, 0x42	; 66
    447e:	33 e1       	ldi	r19, 0x13	; 19
    4480:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    4484:	c8 01       	movw	r24, r16
    4486:	be 01       	movw	r22, r28
    4488:	67 5d       	subi	r22, 0xD7	; 215
    448a:	7f 4f       	sbci	r23, 0xFF	; 255
    448c:	a7 01       	movw	r20, r14
    448e:	2a e4       	ldi	r18, 0x4A	; 74
    4490:	33 e1       	ldi	r19, 0x13	; 19
    4492:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    4496:	ac 96       	adiw	r28, 0x2c	; 44
    4498:	0f b6       	in	r0, 0x3f	; 63
    449a:	f8 94       	cli
    449c:	de bf       	out	0x3e, r29	; 62
    449e:	0f be       	out	0x3f, r0	; 63
    44a0:	cd bf       	out	0x3d, r28	; 61
    44a2:	cf 91       	pop	r28
    44a4:	df 91       	pop	r29
    44a6:	1f 91       	pop	r17
    44a8:	0f 91       	pop	r16
    44aa:	ff 90       	pop	r15
    44ac:	ef 90       	pop	r14
    44ae:	08 95       	ret

000044b0 <_scr_pump>:

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    44b0:	8f 92       	push	r8
    44b2:	9f 92       	push	r9
    44b4:	af 92       	push	r10
    44b6:	bf 92       	push	r11
    44b8:	cf 92       	push	r12
    44ba:	df 92       	push	r13
    44bc:	ef 92       	push	r14
    44be:	ff 92       	push	r15
    44c0:	0f 93       	push	r16
    44c2:	1f 93       	push	r17
    44c4:	df 93       	push	r29
    44c6:	cf 93       	push	r28
    44c8:	cd b7       	in	r28, 0x3d	; 61
    44ca:	de b7       	in	r29, 0x3e	; 62
    44cc:	6c 97       	sbiw	r28, 0x1c	; 28
    44ce:	0f b6       	in	r0, 0x3f	; 63
    44d0:	f8 94       	cli
    44d2:	de bf       	out	0x3e, r29	; 62
    44d4:	0f be       	out	0x3f, r0	; 63
    44d6:	cd bf       	out	0x3d, r28	; 61
	 //char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    44d8:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    44dc:	84 ec       	ldi	r24, 0xC4	; 196
    44de:	99 e0       	ldi	r25, 0x09	; 9
    44e0:	01 97       	sbiw	r24, 0x01	; 1
    44e2:	f1 f7       	brne	.-4      	; 0x44e0 <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    44e4:	8e 01       	movw	r16, r28
    44e6:	0f 5f       	subi	r16, 0xFF	; 255
    44e8:	1f 4f       	sbci	r17, 0xFF	; 255
    44ea:	c8 01       	movw	r24, r16
    44ec:	65 e4       	ldi	r22, 0x45	; 69
    44ee:	70 e0       	ldi	r23, 0x00	; 0
    44f0:	48 e0       	ldi	r20, 0x08	; 8
    44f2:	50 e0       	ldi	r21, 0x00	; 0
    44f4:	22 e4       	ldi	r18, 0x42	; 66
    44f6:	33 e1       	ldi	r19, 0x13	; 19
    44f8:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    44fc:	78 01       	movw	r14, r16
    44fe:	01 e0       	ldi	r16, 0x01	; 1
    4500:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    4502:	b9 e0       	ldi	r27, 0x09	; 9
    4504:	cb 2e       	mov	r12, r27
    4506:	d1 2c       	mov	r13, r1
    4508:	cc 0e       	add	r12, r28
    450a:	dd 1e       	adc	r13, r29
    450c:	aa e3       	ldi	r26, 0x3A	; 58
    450e:	8a 2e       	mov	r8, r26
    4510:	ae e0       	ldi	r26, 0x0E	; 14
    4512:	9a 2e       	mov	r9, r26
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    4514:	f5 e0       	ldi	r31, 0x05	; 5
    4516:	af 2e       	mov	r10, r31
    4518:	b1 2c       	mov	r11, r1
    451a:	ac 0e       	add	r10, r28
    451c:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    451e:	8d b7       	in	r24, 0x3d	; 61
    4520:	9e b7       	in	r25, 0x3e	; 62
    4522:	0c 97       	sbiw	r24, 0x0c	; 12
    4524:	0f b6       	in	r0, 0x3f	; 63
    4526:	f8 94       	cli
    4528:	9e bf       	out	0x3e, r25	; 62
    452a:	0f be       	out	0x3f, r0	; 63
    452c:	8d bf       	out	0x3d, r24	; 61
    452e:	ed b7       	in	r30, 0x3d	; 61
    4530:	fe b7       	in	r31, 0x3e	; 62
    4532:	31 96       	adiw	r30, 0x01	; 1
    4534:	ad b7       	in	r26, 0x3d	; 61
    4536:	be b7       	in	r27, 0x3e	; 62
    4538:	12 96       	adiw	r26, 0x02	; 2
    453a:	dc 92       	st	X, r13
    453c:	ce 92       	st	-X, r12
    453e:	11 97       	sbiw	r26, 0x01	; 1
    4540:	93 82       	std	Z+3, r9	; 0x03
    4542:	82 82       	std	Z+2, r8	; 0x02
    4544:	15 83       	std	Z+5, r17	; 0x05
    4546:	04 83       	std	Z+4, r16	; 0x04
    4548:	d7 01       	movw	r26, r14
    454a:	8c 91       	ld	r24, X
    454c:	86 83       	std	Z+6, r24	; 0x06
    454e:	17 82       	std	Z+7, r1	; 0x07
    4550:	0c 5f       	subi	r16, 0xFC	; 252
    4552:	1f 4f       	sbci	r17, 0xFF	; 255
    4554:	11 87       	std	Z+9, r17	; 0x09
    4556:	00 87       	std	Z+8, r16	; 0x08
    4558:	04 50       	subi	r16, 0x04	; 4
    455a:	10 40       	sbci	r17, 0x00	; 0
    455c:	14 96       	adiw	r26, 0x04	; 4
    455e:	8c 91       	ld	r24, X
    4560:	82 87       	std	Z+10, r24	; 0x0a
    4562:	13 86       	std	Z+11, r1	; 0x0b
    4564:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    4568:	8d b7       	in	r24, 0x3d	; 61
    456a:	9e b7       	in	r25, 0x3e	; 62
    456c:	0c 96       	adiw	r24, 0x0c	; 12
    456e:	0f b6       	in	r0, 0x3f	; 63
    4570:	f8 94       	cli
    4572:	9e bf       	out	0x3e, r25	; 62
    4574:	0f be       	out	0x3f, r0	; 63
    4576:	8d bf       	out	0x3d, r24	; 61
    4578:	80 2f       	mov	r24, r16
    457a:	61 e0       	ldi	r22, 0x01	; 1
    457c:	a6 01       	movw	r20, r12
    457e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    4582:	08 94       	sec
    4584:	e1 1c       	adc	r14, r1
    4586:	f1 1c       	adc	r15, r1
    4588:	0f 5f       	subi	r16, 0xFF	; 255
    458a:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    458c:	ea 14       	cp	r14, r10
    458e:	fb 04       	cpc	r15, r11
    4590:	31 f6       	brne	.-116    	; 0x451e <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    4592:	84 e0       	ldi	r24, 0x04	; 4
    4594:	6f e0       	ldi	r22, 0x0F	; 15
    4596:	43 e3       	ldi	r20, 0x33	; 51
    4598:	5e e0       	ldi	r21, 0x0E	; 14
    459a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
}
    459e:	6c 96       	adiw	r28, 0x1c	; 28
    45a0:	0f b6       	in	r0, 0x3f	; 63
    45a2:	f8 94       	cli
    45a4:	de bf       	out	0x3e, r29	; 62
    45a6:	0f be       	out	0x3f, r0	; 63
    45a8:	cd bf       	out	0x3d, r28	; 61
    45aa:	cf 91       	pop	r28
    45ac:	df 91       	pop	r29
    45ae:	1f 91       	pop	r17
    45b0:	0f 91       	pop	r16
    45b2:	ff 90       	pop	r15
    45b4:	ef 90       	pop	r14
    45b6:	df 90       	pop	r13
    45b8:	cf 90       	pop	r12
    45ba:	bf 90       	pop	r11
    45bc:	af 90       	pop	r10
    45be:	9f 90       	pop	r9
    45c0:	8f 90       	pop	r8
    45c2:	08 95       	ret

000045c4 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    45c4:	df 92       	push	r13
    45c6:	ef 92       	push	r14
    45c8:	ff 92       	push	r15
    45ca:	0f 93       	push	r16
    45cc:	1f 93       	push	r17
    45ce:	df 93       	push	r29
    45d0:	cf 93       	push	r28
    45d2:	00 d0       	rcall	.+0      	; 0x45d4 <SelectMark+0x10>
    45d4:	00 d0       	rcall	.+0      	; 0x45d6 <SelectMark+0x12>
    45d6:	0f 92       	push	r0
    45d8:	cd b7       	in	r28, 0x3d	; 61
    45da:	de b7       	in	r29, 0x3e	; 62
    45dc:	d8 2e       	mov	r13, r24
    45de:	8e 01       	movw	r16, r28
    45e0:	0f 5f       	subi	r16, 0xFF	; 255
    45e2:	1f 4f       	sbci	r17, 0xFF	; 255
    45e4:	c8 01       	movw	r24, r16
    45e6:	60 e4       	ldi	r22, 0x40	; 64
    45e8:	70 e0       	ldi	r23, 0x00	; 0
    45ea:	45 e0       	ldi	r20, 0x05	; 5
    45ec:	50 e0       	ldi	r21, 0x00	; 0
    45ee:	22 e4       	ldi	r18, 0x42	; 66
    45f0:	33 e1       	ldi	r19, 0x13	; 19
    45f2:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    45f6:	ed 2d       	mov	r30, r13
    45f8:	21 e0       	ldi	r18, 0x01	; 1
    45fa:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    45fc:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    45fe:	d8 01       	movw	r26, r16
    4600:	8c 91       	ld	r24, X
    4602:	d8 16       	cp	r13, r24
    4604:	49 f4       	brne	.+18     	; 0x4618 <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    4606:	c9 01       	movw	r24, r18
    4608:	65 e0       	ldi	r22, 0x05	; 5
    460a:	70 e0       	ldi	r23, 0x00	; 0
    460c:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    4610:	f7 01       	movw	r30, r14
    4612:	e8 0f       	add	r30, r24
    4614:	f9 1f       	adc	r31, r25
    4616:	e0 81       	ld	r30, Z
    4618:	0f 5f       	subi	r16, 0xFF	; 255
    461a:	1f 4f       	sbci	r17, 0xFF	; 255
    461c:	2f 5f       	subi	r18, 0xFF	; 255
    461e:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    4620:	26 30       	cpi	r18, 0x06	; 6
    4622:	31 05       	cpc	r19, r1
    4624:	61 f7       	brne	.-40     	; 0x45fe <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    4626:	8e 2f       	mov	r24, r30
    4628:	0f 90       	pop	r0
    462a:	0f 90       	pop	r0
    462c:	0f 90       	pop	r0
    462e:	0f 90       	pop	r0
    4630:	0f 90       	pop	r0
    4632:	cf 91       	pop	r28
    4634:	df 91       	pop	r29
    4636:	1f 91       	pop	r17
    4638:	0f 91       	pop	r16
    463a:	ff 90       	pop	r15
    463c:	ef 90       	pop	r14
    463e:	df 90       	pop	r13
    4640:	08 95       	ret

00004642 <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    4642:	cf 92       	push	r12
    4644:	df 92       	push	r13
    4646:	ef 92       	push	r14
    4648:	ff 92       	push	r15
    464a:	0f 93       	push	r16
    464c:	1f 93       	push	r17
    464e:	df 93       	push	r29
    4650:	cf 93       	push	r28
    4652:	cd b7       	in	r28, 0x3d	; 61
    4654:	de b7       	in	r29, 0x3e	; 62
    4656:	2f 97       	sbiw	r28, 0x0f	; 15
    4658:	0f b6       	in	r0, 0x3f	; 63
    465a:	f8 94       	cli
    465c:	de bf       	out	0x3e, r29	; 62
    465e:	0f be       	out	0x3f, r0	; 63
    4660:	cd bf       	out	0x3d, r28	; 61
    4662:	e8 2e       	mov	r14, r24
    4664:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    4666:	8f 70       	andi	r24, 0x0F	; 15
    4668:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
     if (FIPAddr>0){
    466c:	88 23       	and	r24, r24
    466e:	09 f4       	brne	.+2      	; 0x4672 <GenerateStandaloneTransData+0x30>
    4670:	2d c1       	rjmp	.+602    	; 0x48cc <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    4672:	81 50       	subi	r24, 0x01	; 1
    4674:	c8 2e       	mov	r12, r24
    4676:	dd 24       	eor	r13, r13
    4678:	85 e3       	ldi	r24, 0x35	; 53
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	c8 9e       	mul	r12, r24
    467e:	f0 01       	movw	r30, r0
    4680:	c9 9e       	mul	r12, r25
    4682:	f0 0d       	add	r31, r0
    4684:	d8 9e       	mul	r13, r24
    4686:	f0 0d       	add	r31, r0
    4688:	11 24       	eor	r1, r1
    468a:	ef 54       	subi	r30, 0x4F	; 79
    468c:	fa 4f       	sbci	r31, 0xFA	; 250
    468e:	80 81       	ld	r24, Z
    4690:	08 0f       	add	r16, r24
    4692:	11 1d       	adc	r17, r1
    4694:	d8 01       	movw	r26, r16
    4696:	2c 91       	ld	r18, X
    4698:	ce 01       	movw	r24, r28
    469a:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    469c:	22 23       	and	r18, r18
    469e:	69 f0       	breq	.+26     	; 0x46ba <GenerateStandaloneTransData+0x78>
    46a0:	6d e0       	ldi	r22, 0x0D	; 13
    46a2:	26 9f       	mul	r18, r22
    46a4:	b0 01       	movw	r22, r0
    46a6:	11 24       	eor	r1, r1
    46a8:	62 55       	subi	r22, 0x52	; 82
    46aa:	7f 4f       	sbci	r23, 0xFF	; 255
    46ac:	4d e0       	ldi	r20, 0x0D	; 13
    46ae:	50 e0       	ldi	r21, 0x00	; 0
    46b0:	22 e4       	ldi	r18, 0x42	; 66
    46b2:	33 e1       	ldi	r19, 0x13	; 19
    46b4:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    46b8:	10 c0       	rjmp	.+32     	; 0x46da <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    46ba:	00 d0       	rcall	.+0      	; 0x46bc <GenerateStandaloneTransData+0x7a>
    46bc:	00 d0       	rcall	.+0      	; 0x46be <GenerateStandaloneTransData+0x7c>
    46be:	ed b7       	in	r30, 0x3d	; 61
    46c0:	fe b7       	in	r31, 0x3e	; 62
    46c2:	92 83       	std	Z+2, r25	; 0x02
    46c4:	81 83       	std	Z+1, r24	; 0x01
    46c6:	87 ed       	ldi	r24, 0xD7	; 215
    46c8:	92 e2       	ldi	r25, 0x22	; 34
    46ca:	94 83       	std	Z+4, r25	; 0x04
    46cc:	83 83       	std	Z+3, r24	; 0x03
    46ce:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    46d2:	0f 90       	pop	r0
    46d4:	0f 90       	pop	r0
    46d6:	0f 90       	pop	r0
    46d8:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    46da:	e1 99       	sbic	0x1c, 1	; 28
    46dc:	fe cf       	rjmp	.-4      	; 0x46da <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    46de:	80 e0       	ldi	r24, 0x00	; 0
    46e0:	90 e0       	ldi	r25, 0x00	; 0
    46e2:	9f bb       	out	0x1f, r25	; 31
    46e4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    46e6:	e0 9a       	sbi	0x1c, 0	; 28
    46e8:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    46ea:	00 d0       	rcall	.+0      	; 0x46ec <GenerateStandaloneTransData+0xaa>
    46ec:	00 d0       	rcall	.+0      	; 0x46ee <GenerateStandaloneTransData+0xac>
    46ee:	00 d0       	rcall	.+0      	; 0x46f0 <GenerateStandaloneTransData+0xae>
    46f0:	ad b7       	in	r26, 0x3d	; 61
    46f2:	be b7       	in	r27, 0x3e	; 62
    46f4:	11 96       	adiw	r26, 0x01	; 1
    46f6:	81 e8       	ldi	r24, 0x81	; 129
    46f8:	9e e0       	ldi	r25, 0x0E	; 14
    46fa:	ed b7       	in	r30, 0x3d	; 61
    46fc:	fe b7       	in	r31, 0x3e	; 62
    46fe:	92 83       	std	Z+2, r25	; 0x02
    4700:	81 83       	std	Z+1, r24	; 0x01
    4702:	84 ed       	ldi	r24, 0xD4	; 212
    4704:	92 e2       	ldi	r25, 0x22	; 34
    4706:	13 96       	adiw	r26, 0x03	; 3
    4708:	9c 93       	st	X, r25
    470a:	8e 93       	st	-X, r24
    470c:	12 97       	sbiw	r26, 0x02	; 2
    470e:	85 e3       	ldi	r24, 0x35	; 53
    4710:	90 e0       	ldi	r25, 0x00	; 0
    4712:	c8 9e       	mul	r12, r24
    4714:	80 01       	movw	r16, r0
    4716:	c9 9e       	mul	r12, r25
    4718:	10 0d       	add	r17, r0
    471a:	d8 9e       	mul	r13, r24
    471c:	10 0d       	add	r17, r0
    471e:	11 24       	eor	r1, r1
    4720:	f8 01       	movw	r30, r16
    4722:	ef 54       	subi	r30, 0x4F	; 79
    4724:	fa 4f       	sbci	r31, 0xFA	; 250
    4726:	82 81       	ldd	r24, Z+2	; 0x02
    4728:	14 96       	adiw	r26, 0x04	; 4
    472a:	8c 93       	st	X, r24
    472c:	14 97       	sbiw	r26, 0x04	; 4
    472e:	15 96       	adiw	r26, 0x05	; 5
    4730:	1c 92       	st	X, r1
    4732:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    4736:	ed b7       	in	r30, 0x3d	; 61
    4738:	fe b7       	in	r31, 0x3e	; 62
    473a:	31 96       	adiw	r30, 0x01	; 1
    473c:	80 ea       	ldi	r24, 0xA0	; 160
    473e:	9e e0       	ldi	r25, 0x0E	; 14
    4740:	ad b7       	in	r26, 0x3d	; 61
    4742:	be b7       	in	r27, 0x3e	; 62
    4744:	12 96       	adiw	r26, 0x02	; 2
    4746:	9c 93       	st	X, r25
    4748:	8e 93       	st	-X, r24
    474a:	11 97       	sbiw	r26, 0x01	; 1
    474c:	81 ed       	ldi	r24, 0xD1	; 209
    474e:	92 e2       	ldi	r25, 0x22	; 34
    4750:	93 83       	std	Z+3, r25	; 0x03
    4752:	82 83       	std	Z+2, r24	; 0x02
    4754:	c8 01       	movw	r24, r16
    4756:	8c 54       	subi	r24, 0x4C	; 76
    4758:	9a 4f       	sbci	r25, 0xFA	; 250
    475a:	95 83       	std	Z+5, r25	; 0x05
    475c:	84 83       	std	Z+4, r24	; 0x04
    475e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    4762:	ed b7       	in	r30, 0x3d	; 61
    4764:	fe b7       	in	r31, 0x3e	; 62
    4766:	31 96       	adiw	r30, 0x01	; 1
    4768:	87 e7       	ldi	r24, 0x77	; 119
    476a:	97 e0       	ldi	r25, 0x07	; 7
    476c:	ad b7       	in	r26, 0x3d	; 61
    476e:	be b7       	in	r27, 0x3e	; 62
    4770:	12 96       	adiw	r26, 0x02	; 2
    4772:	9c 93       	st	X, r25
    4774:	8e 93       	st	-X, r24
    4776:	11 97       	sbiw	r26, 0x01	; 1
    4778:	8e ec       	ldi	r24, 0xCE	; 206
    477a:	92 e2       	ldi	r25, 0x22	; 34
    477c:	93 83       	std	Z+3, r25	; 0x03
    477e:	82 83       	std	Z+2, r24	; 0x02
    4780:	c8 01       	movw	r24, r16
    4782:	85 54       	subi	r24, 0x45	; 69
    4784:	9a 4f       	sbci	r25, 0xFA	; 250
    4786:	95 83       	std	Z+5, r25	; 0x05
    4788:	84 83       	std	Z+4, r24	; 0x04
    478a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    478e:	ed b7       	in	r30, 0x3d	; 61
    4790:	fe b7       	in	r31, 0x3e	; 62
    4792:	31 96       	adiw	r30, 0x01	; 1
    4794:	86 e5       	ldi	r24, 0x56	; 86
    4796:	93 e0       	ldi	r25, 0x03	; 3
    4798:	ad b7       	in	r26, 0x3d	; 61
    479a:	be b7       	in	r27, 0x3e	; 62
    479c:	12 96       	adiw	r26, 0x02	; 2
    479e:	9c 93       	st	X, r25
    47a0:	8e 93       	st	-X, r24
    47a2:	11 97       	sbiw	r26, 0x01	; 1
    47a4:	8b ec       	ldi	r24, 0xCB	; 203
    47a6:	92 e2       	ldi	r25, 0x22	; 34
    47a8:	93 83       	std	Z+3, r25	; 0x03
    47aa:	82 83       	std	Z+2, r24	; 0x02
    47ac:	c8 01       	movw	r24, r16
    47ae:	8c 53       	subi	r24, 0x3C	; 60
    47b0:	9a 4f       	sbci	r25, 0xFA	; 250
    47b2:	95 83       	std	Z+5, r25	; 0x05
    47b4:	84 83       	std	Z+4, r24	; 0x04
    47b6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    47ba:	ed b7       	in	r30, 0x3d	; 61
    47bc:	fe b7       	in	r31, 0x3e	; 62
    47be:	31 96       	adiw	r30, 0x01	; 1
    47c0:	80 e0       	ldi	r24, 0x00	; 0
    47c2:	99 e0       	ldi	r25, 0x09	; 9
    47c4:	ad b7       	in	r26, 0x3d	; 61
    47c6:	be b7       	in	r27, 0x3e	; 62
    47c8:	12 96       	adiw	r26, 0x02	; 2
    47ca:	9c 93       	st	X, r25
    47cc:	8e 93       	st	-X, r24
    47ce:	11 97       	sbiw	r26, 0x01	; 1
    47d0:	88 ec       	ldi	r24, 0xC8	; 200
    47d2:	92 e2       	ldi	r25, 0x22	; 34
    47d4:	93 83       	std	Z+3, r25	; 0x03
    47d6:	82 83       	std	Z+2, r24	; 0x02
    47d8:	f4 82       	std	Z+4, r15	; 0x04
    47da:	15 82       	std	Z+5, r1	; 0x05
    47dc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    47e0:	ed b7       	in	r30, 0x3d	; 61
    47e2:	fe b7       	in	r31, 0x3e	; 62
    47e4:	31 96       	adiw	r30, 0x01	; 1
    47e6:	82 ec       	ldi	r24, 0xC2	; 194
    47e8:	97 e0       	ldi	r25, 0x07	; 7
    47ea:	ad b7       	in	r26, 0x3d	; 61
    47ec:	be b7       	in	r27, 0x3e	; 62
    47ee:	12 96       	adiw	r26, 0x02	; 2
    47f0:	9c 93       	st	X, r25
    47f2:	8e 93       	st	-X, r24
    47f4:	11 97       	sbiw	r26, 0x01	; 1
    47f6:	83 ec       	ldi	r24, 0xC3	; 195
    47f8:	92 e2       	ldi	r25, 0x22	; 34
    47fa:	93 83       	std	Z+3, r25	; 0x03
    47fc:	82 83       	std	Z+2, r24	; 0x02
    47fe:	e4 82       	std	Z+4, r14	; 0x04
    4800:	15 82       	std	Z+5, r1	; 0x05
    4802:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    4806:	ed b7       	in	r30, 0x3d	; 61
    4808:	fe b7       	in	r31, 0x3e	; 62
    480a:	31 96       	adiw	r30, 0x01	; 1
    480c:	85 e1       	ldi	r24, 0x15	; 21
    480e:	98 e0       	ldi	r25, 0x08	; 8
    4810:	ad b7       	in	r26, 0x3d	; 61
    4812:	be b7       	in	r27, 0x3e	; 62
    4814:	12 96       	adiw	r26, 0x02	; 2
    4816:	9c 93       	st	X, r25
    4818:	8e 93       	st	-X, r24
    481a:	11 97       	sbiw	r26, 0x01	; 1
    481c:	80 ec       	ldi	r24, 0xC0	; 192
    481e:	92 e2       	ldi	r25, 0x22	; 34
    4820:	93 83       	std	Z+3, r25	; 0x03
    4822:	82 83       	std	Z+2, r24	; 0x02
    4824:	ce 01       	movw	r24, r28
    4826:	01 96       	adiw	r24, 0x01	; 1
    4828:	95 83       	std	Z+5, r25	; 0x05
    482a:	84 83       	std	Z+4, r24	; 0x04
    482c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    4830:	ed b7       	in	r30, 0x3d	; 61
    4832:	fe b7       	in	r31, 0x3e	; 62
    4834:	31 96       	adiw	r30, 0x01	; 1
    4836:	87 ea       	ldi	r24, 0xA7	; 167
    4838:	95 e0       	ldi	r25, 0x05	; 5
    483a:	ad b7       	in	r26, 0x3d	; 61
    483c:	be b7       	in	r27, 0x3e	; 62
    483e:	12 96       	adiw	r26, 0x02	; 2
    4840:	9c 93       	st	X, r25
    4842:	8e 93       	st	-X, r24
    4844:	11 97       	sbiw	r26, 0x01	; 1
    4846:	8d eb       	ldi	r24, 0xBD	; 189
    4848:	92 e2       	ldi	r25, 0x22	; 34
    484a:	93 83       	std	Z+3, r25	; 0x03
    484c:	82 83       	std	Z+2, r24	; 0x02
    484e:	c8 01       	movw	r24, r16
    4850:	83 53       	subi	r24, 0x33	; 51
    4852:	9a 4f       	sbci	r25, 0xFA	; 250
    4854:	95 83       	std	Z+5, r25	; 0x05
    4856:	84 83       	std	Z+4, r24	; 0x04
    4858:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    485c:	ed b7       	in	r30, 0x3d	; 61
    485e:	fe b7       	in	r31, 0x3e	; 62
    4860:	31 96       	adiw	r30, 0x01	; 1
    4862:	8e e7       	ldi	r24, 0x7E	; 126
    4864:	93 e0       	ldi	r25, 0x03	; 3
    4866:	ad b7       	in	r26, 0x3d	; 61
    4868:	be b7       	in	r27, 0x3e	; 62
    486a:	12 96       	adiw	r26, 0x02	; 2
    486c:	9c 93       	st	X, r25
    486e:	8e 93       	st	-X, r24
    4870:	11 97       	sbiw	r26, 0x01	; 1
    4872:	8a eb       	ldi	r24, 0xBA	; 186
    4874:	92 e2       	ldi	r25, 0x22	; 34
    4876:	93 83       	std	Z+3, r25	; 0x03
    4878:	82 83       	std	Z+2, r24	; 0x02
    487a:	c8 01       	movw	r24, r16
    487c:	8c 52       	subi	r24, 0x2C	; 44
    487e:	9a 4f       	sbci	r25, 0xFA	; 250
    4880:	95 83       	std	Z+5, r25	; 0x05
    4882:	84 83       	std	Z+4, r24	; 0x04
    4884:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    4888:	ed b7       	in	r30, 0x3d	; 61
    488a:	fe b7       	in	r31, 0x3e	; 62
    488c:	31 96       	adiw	r30, 0x01	; 1
    488e:	8c eb       	ldi	r24, 0xBC	; 188
    4890:	9d e0       	ldi	r25, 0x0D	; 13
    4892:	ad b7       	in	r26, 0x3d	; 61
    4894:	be b7       	in	r27, 0x3e	; 62
    4896:	12 96       	adiw	r26, 0x02	; 2
    4898:	9c 93       	st	X, r25
    489a:	8e 93       	st	-X, r24
    489c:	11 97       	sbiw	r26, 0x01	; 1
    489e:	87 eb       	ldi	r24, 0xB7	; 183
    48a0:	92 e2       	ldi	r25, 0x22	; 34
    48a2:	93 83       	std	Z+3, r25	; 0x03
    48a4:	82 83       	std	Z+2, r24	; 0x02
    48a6:	03 52       	subi	r16, 0x23	; 35
    48a8:	1a 4f       	sbci	r17, 0xFA	; 250
    48aa:	15 83       	std	Z+5, r17	; 0x05
    48ac:	04 83       	std	Z+4, r16	; 0x04
    48ae:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>

		 MOPType=MOP_CASH;
    48b2:	10 92 ba 01 	sts	0x01BA, r1
	     IsPrinting=True;	 
    48b6:	81 e0       	ldi	r24, 0x01	; 1
    48b8:	80 93 ae 01 	sts	0x01AE, r24
    48bc:	ed b7       	in	r30, 0x3d	; 61
    48be:	fe b7       	in	r31, 0x3e	; 62
    48c0:	36 96       	adiw	r30, 0x06	; 6
    48c2:	0f b6       	in	r0, 0x3f	; 63
    48c4:	f8 94       	cli
    48c6:	fe bf       	out	0x3e, r31	; 62
    48c8:	0f be       	out	0x3f, r0	; 63
    48ca:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    48cc:	2f 96       	adiw	r28, 0x0f	; 15
    48ce:	0f b6       	in	r0, 0x3f	; 63
    48d0:	f8 94       	cli
    48d2:	de bf       	out	0x3e, r29	; 62
    48d4:	0f be       	out	0x3f, r0	; 63
    48d6:	cd bf       	out	0x3d, r28	; 61
    48d8:	cf 91       	pop	r28
    48da:	df 91       	pop	r29
    48dc:	1f 91       	pop	r17
    48de:	0f 91       	pop	r16
    48e0:	ff 90       	pop	r15
    48e2:	ef 90       	pop	r14
    48e4:	df 90       	pop	r13
    48e6:	cf 90       	pop	r12
    48e8:	08 95       	ret

000048ea <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    48ea:	ef 92       	push	r14
    48ec:	ff 92       	push	r15
    48ee:	0f 93       	push	r16
    48f0:	1f 93       	push	r17
    48f2:	df 93       	push	r29
    48f4:	cf 93       	push	r28
    48f6:	00 d0       	rcall	.+0      	; 0x48f8 <PrintStandalone+0xe>
    48f8:	00 d0       	rcall	.+0      	; 0x48fa <PrintStandalone+0x10>
    48fa:	00 d0       	rcall	.+0      	; 0x48fc <PrintStandalone+0x12>
    48fc:	cd b7       	in	r28, 0x3d	; 61
    48fe:	de b7       	in	r29, 0x3e	; 62
    4900:	f8 2e       	mov	r15, r24
    4902:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    4904:	0e 94 9a 21 	call	0x4334	; 0x4334 <GetPumpID>
    4908:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    490a:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
    490e:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    4910:	88 23       	and	r24, r24
    4912:	99 f1       	breq	.+102    	; 0x497a <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    4914:	01 30       	cpi	r16, 0x01	; 1
    4916:	69 f0       	breq	.+26     	; 0x4932 <PrintStandalone+0x48>
    4918:	ee 20       	and	r14, r14
    491a:	79 f1       	breq	.+94     	; 0x497a <PrintStandalone+0x90>
    491c:	80 e1       	ldi	r24, 0x10	; 16
    491e:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    4922:	11 50       	subi	r17, 0x01	; 1
    4924:	e1 2f       	mov	r30, r17
    4926:	f0 e0       	ldi	r31, 0x00	; 0
    4928:	ee 5f       	subi	r30, 0xFE	; 254
    492a:	fe 4f       	sbci	r31, 0xFE	; 254
    492c:	90 81       	ld	r25, Z
    492e:	98 17       	cp	r25, r24
    4930:	21 f5       	brne	.+72     	; 0x497a <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4932:	66 e0       	ldi	r22, 0x06	; 6
    4934:	f6 9e       	mul	r15, r22
    4936:	b0 01       	movw	r22, r0
    4938:	11 24       	eor	r1, r1
    493a:	61 5b       	subi	r22, 0xB1	; 177
    493c:	7f 4f       	sbci	r23, 0xFF	; 255
    493e:	ce 01       	movw	r24, r28
    4940:	01 96       	adiw	r24, 0x01	; 1
    4942:	46 e0       	ldi	r20, 0x06	; 6
    4944:	50 e0       	ldi	r21, 0x00	; 0
    4946:	22 e4       	ldi	r18, 0x42	; 66
    4948:	33 e1       	ldi	r19, 0x13	; 19
    494a:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    494e:	ef 2d       	mov	r30, r15
    4950:	f0 e0       	ldi	r31, 0x00	; 0
    4952:	e0 59       	subi	r30, 0x90	; 144
    4954:	fe 4f       	sbci	r31, 0xFE	; 254
    4956:	80 81       	ld	r24, Z
    4958:	81 30       	cpi	r24, 0x01	; 1
    495a:	19 f0       	breq	.+6      	; 0x4962 <PrintStandalone+0x78>
    495c:	00 23       	and	r16, r16
    495e:	29 f0       	breq	.+10     	; 0x496a <PrintStandalone+0x80>
    4960:	0c c0       	rjmp	.+24     	; 0x497a <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    4962:	01 30       	cpi	r16, 0x01	; 1
    4964:	11 f4       	brne	.+4      	; 0x496a <PrintStandalone+0x80>
    4966:	00 93 81 01 	sts	0x0181, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    496a:	8e 2d       	mov	r24, r14
    496c:	be 01       	movw	r22, r28
    496e:	6f 5f       	subi	r22, 0xFF	; 255
    4970:	7f 4f       	sbci	r23, 0xFF	; 255
    4972:	0e 94 21 23 	call	0x4642	; 0x4642 <GenerateStandaloneTransData>
    4976:	81 e1       	ldi	r24, 0x11	; 17
    4978:	01 c0       	rjmp	.+2      	; 0x497c <PrintStandalone+0x92>
    497a:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    497c:	26 96       	adiw	r28, 0x06	; 6
    497e:	0f b6       	in	r0, 0x3f	; 63
    4980:	f8 94       	cli
    4982:	de bf       	out	0x3e, r29	; 62
    4984:	0f be       	out	0x3f, r0	; 63
    4986:	cd bf       	out	0x3d, r28	; 61
    4988:	cf 91       	pop	r28
    498a:	df 91       	pop	r29
    498c:	1f 91       	pop	r17
    498e:	0f 91       	pop	r16
    4990:	ff 90       	pop	r15
    4992:	ef 90       	pop	r14
    4994:	08 95       	ret

00004996 <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    4996:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    4998:	dc 01       	movw	r26, r24
    499a:	0d 90       	ld	r0, X+
    499c:	00 20       	and	r0, r0
    499e:	e9 f7       	brne	.-6      	; 0x499a <SumChecksum+0x4>
    49a0:	11 97       	sbiw	r26, 0x01	; 1
    49a2:	a8 1b       	sub	r26, r24
    49a4:	b9 0b       	sbc	r27, r25
    49a6:	20 e0       	ldi	r18, 0x00	; 0
    49a8:	30 e0       	ldi	r19, 0x00	; 0
    49aa:	90 e0       	ldi	r25, 0x00	; 0
    49ac:	06 c0       	rjmp	.+12     	; 0x49ba <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    49ae:	e4 0f       	add	r30, r20
    49b0:	f5 1f       	adc	r31, r21
    49b2:	80 81       	ld	r24, Z
    49b4:	28 0f       	add	r18, r24
    49b6:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    49b8:	9f 5f       	subi	r25, 0xFF	; 255
    49ba:	e9 2f       	mov	r30, r25
    49bc:	f0 e0       	ldi	r31, 0x00	; 0
    49be:	ea 17       	cp	r30, r26
    49c0:	fb 07       	cpc	r31, r27
    49c2:	a8 f3       	brcs	.-22     	; 0x49ae <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    49c4:	c9 01       	movw	r24, r18
    49c6:	6f ef       	ldi	r22, 0xFF	; 255
    49c8:	70 e0       	ldi	r23, 0x00	; 0
    49ca:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
	 if (Result==0)Result=255;
    49ce:	88 23       	and	r24, r24
    49d0:	09 f4       	brne	.+2      	; 0x49d4 <SumChecksum+0x3e>
    49d2:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    49d4:	08 95       	ret

000049d6 <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    49d6:	ff 92       	push	r15
    49d8:	0f 93       	push	r16
    49da:	1f 93       	push	r17
    49dc:	df 93       	push	r29
    49de:	cf 93       	push	r28
    49e0:	cd b7       	in	r28, 0x3d	; 61
    49e2:	de b7       	in	r29, 0x3e	; 62
    49e4:	2a 97       	sbiw	r28, 0x0a	; 10
    49e6:	0f b6       	in	r0, 0x3f	; 63
    49e8:	f8 94       	cli
    49ea:	de bf       	out	0x3e, r29	; 62
    49ec:	0f be       	out	0x3f, r0	; 63
    49ee:	cd bf       	out	0x3d, r28	; 61
    49f0:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    49f2:	00 d0       	rcall	.+0      	; 0x49f4 <IsGeniusCommand+0x1e>
    49f4:	00 d0       	rcall	.+0      	; 0x49f6 <IsGeniusCommand+0x20>
    49f6:	8e 01       	movw	r16, r28
    49f8:	0f 5f       	subi	r16, 0xFF	; 255
    49fa:	1f 4f       	sbci	r17, 0xFF	; 255
    49fc:	ed b7       	in	r30, 0x3d	; 61
    49fe:	fe b7       	in	r31, 0x3e	; 62
    4a00:	12 83       	std	Z+2, r17	; 0x02
    4a02:	01 83       	std	Z+1, r16	; 0x01
    4a04:	8d eb       	ldi	r24, 0xBD	; 189
    4a06:	94 e0       	ldi	r25, 0x04	; 4
    4a08:	94 83       	std	Z+4, r25	; 0x04
    4a0a:	83 83       	std	Z+3, r24	; 0x03
    4a0c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    4a10:	d8 01       	movw	r26, r16
    4a12:	0d 90       	ld	r0, X+
    4a14:	00 20       	and	r0, r0
    4a16:	e9 f7       	brne	.-6      	; 0x4a12 <IsGeniusCommand+0x3c>
    4a18:	11 97       	sbiw	r26, 0x01	; 1
    4a1a:	a0 1b       	sub	r26, r16
    4a1c:	b1 0b       	sbc	r27, r17
    4a1e:	90 e0       	ldi	r25, 0x00	; 0
    4a20:	0f 90       	pop	r0
    4a22:	0f 90       	pop	r0
    4a24:	0f 90       	pop	r0
    4a26:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    4a28:	98 01       	movw	r18, r16
    4a2a:	08 c0       	rjmp	.+16     	; 0x4a3c <IsGeniusCommand+0x66>
    4a2c:	e2 0f       	add	r30, r18
    4a2e:	f3 1f       	adc	r31, r19
    4a30:	80 81       	ld	r24, Z
    4a32:	8f 15       	cp	r24, r15
    4a34:	11 f4       	brne	.+4      	; 0x4a3a <IsGeniusCommand+0x64>
    4a36:	81 e0       	ldi	r24, 0x01	; 1
    4a38:	07 c0       	rjmp	.+14     	; 0x4a48 <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    4a3a:	9f 5f       	subi	r25, 0xFF	; 255
    4a3c:	e9 2f       	mov	r30, r25
    4a3e:	f0 e0       	ldi	r31, 0x00	; 0
    4a40:	ea 17       	cp	r30, r26
    4a42:	fb 07       	cpc	r31, r27
    4a44:	98 f3       	brcs	.-26     	; 0x4a2c <IsGeniusCommand+0x56>
    4a46:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    4a48:	2a 96       	adiw	r28, 0x0a	; 10
    4a4a:	0f b6       	in	r0, 0x3f	; 63
    4a4c:	f8 94       	cli
    4a4e:	de bf       	out	0x3e, r29	; 62
    4a50:	0f be       	out	0x3f, r0	; 63
    4a52:	cd bf       	out	0x3d, r28	; 61
    4a54:	cf 91       	pop	r28
    4a56:	df 91       	pop	r29
    4a58:	1f 91       	pop	r17
    4a5a:	0f 91       	pop	r16
    4a5c:	ff 90       	pop	r15
    4a5e:	08 95       	ret

00004a60 <Pos>:
  */
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    4a60:	0f 93       	push	r16
    4a62:	1f 93       	push	r17
    4a64:	cf 93       	push	r28
    4a66:	df 93       	push	r29
    4a68:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    4a6a:	fb 01       	movw	r30, r22
    4a6c:	01 90       	ld	r0, Z+
    4a6e:	00 20       	and	r0, r0
    4a70:	e9 f7       	brne	.-6      	; 0x4a6c <Pos+0xc>
    4a72:	31 97       	sbiw	r30, 0x01	; 1
    4a74:	1e 2f       	mov	r17, r30
    4a76:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    4a78:	fc 01       	movw	r30, r24
    4a7a:	01 90       	ld	r0, Z+
    4a7c:	00 20       	and	r0, r0
    4a7e:	e9 f7       	brne	.-6      	; 0x4a7a <Pos+0x1a>
    4a80:	31 97       	sbiw	r30, 0x01	; 1
    4a82:	0e 2f       	mov	r16, r30
    4a84:	08 1b       	sub	r16, r24
    4a86:	db 01       	movw	r26, r22
    4a88:	60 e0       	ldi	r22, 0x00	; 0
    4a8a:	18 c0       	rjmp	.+48     	; 0x4abc <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    4a8c:	9c 91       	ld	r25, X
    4a8e:	fa 01       	movw	r30, r20
    4a90:	80 81       	ld	r24, Z
    4a92:	98 17       	cp	r25, r24
    4a94:	89 f4       	brne	.+34     	; 0x4ab8 <Pos+0x58>
    4a96:	ed 01       	movw	r28, r26
    4a98:	20 e0       	ldi	r18, 0x00	; 0
    4a9a:	30 e0       	ldi	r19, 0x00	; 0
    4a9c:	09 c0       	rjmp	.+18     	; 0x4ab0 <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    4a9e:	fa 01       	movw	r30, r20
    4aa0:	e2 0f       	add	r30, r18
    4aa2:	f3 1f       	adc	r31, r19
    4aa4:	90 81       	ld	r25, Z
    4aa6:	89 91       	ld	r24, Y+
    4aa8:	2f 5f       	subi	r18, 0xFF	; 255
    4aaa:	3f 4f       	sbci	r19, 0xFF	; 255
    4aac:	98 17       	cp	r25, r24
    4aae:	21 f4       	brne	.+8      	; 0x4ab8 <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    4ab0:	20 17       	cp	r18, r16
    4ab2:	a8 f3       	brcs	.-22     	; 0x4a9e <Pos+0x3e>
    4ab4:	86 2f       	mov	r24, r22
    4ab6:	05 c0       	rjmp	.+10     	; 0x4ac2 <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    4ab8:	6f 5f       	subi	r22, 0xFF	; 255
    4aba:	11 96       	adiw	r26, 0x01	; 1
    4abc:	61 17       	cp	r22, r17
    4abe:	30 f3       	brcs	.-52     	; 0x4a8c <Pos+0x2c>
    4ac0:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    4ac2:	90 e0       	ldi	r25, 0x00	; 0
    4ac4:	df 91       	pop	r29
    4ac6:	cf 91       	pop	r28
    4ac8:	1f 91       	pop	r17
    4aca:	0f 91       	pop	r16
    4acc:	08 95       	ret

00004ace <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    4ace:	7f 92       	push	r7
    4ad0:	8f 92       	push	r8
    4ad2:	9f 92       	push	r9
    4ad4:	af 92       	push	r10
    4ad6:	bf 92       	push	r11
    4ad8:	cf 92       	push	r12
    4ada:	df 92       	push	r13
    4adc:	ef 92       	push	r14
    4ade:	ff 92       	push	r15
    4ae0:	0f 93       	push	r16
    4ae2:	1f 93       	push	r17
    4ae4:	cf 93       	push	r28
    4ae6:	df 93       	push	r29
    4ae8:	5c 01       	movw	r10, r24
    4aea:	6b 01       	movw	r12, r22
    4aec:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    4aee:	ec 01       	movw	r28, r24
    4af0:	09 90       	ld	r0, Y+
    4af2:	00 20       	and	r0, r0
    4af4:	e9 f7       	brne	.-6      	; 0x4af0 <CreateReport+0x22>
    4af6:	21 97       	sbiw	r28, 0x01	; 1
    4af8:	c8 1b       	sub	r28, r24
    4afa:	d9 0b       	sbc	r29, r25
    4afc:	cb 32       	cpi	r28, 0x2B	; 43
    4afe:	d1 05       	cpc	r29, r1
    4b00:	10 f0       	brcs	.+4      	; 0x4b06 <CreateReport+0x38>
    4b02:	ca e2       	ldi	r28, 0x2A	; 42
    4b04:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    4b06:	f4 01       	movw	r30, r8
    4b08:	00 81       	ld	r16, Z
    4b0a:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4b0c:	76 01       	movw	r14, r12
    4b0e:	e0 0e       	add	r14, r16
    4b10:	f1 1e       	adc	r15, r17
    4b12:	8a e0       	ldi	r24, 0x0A	; 10
    4b14:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <GetBorderValue>
    4b18:	78 2e       	mov	r7, r24
    4b1a:	f7 01       	movw	r30, r14
    4b1c:	80 83       	st	Z, r24
     iPos++;
    4b1e:	98 01       	movw	r18, r16
    4b20:	2f 5f       	subi	r18, 0xFF	; 255
    4b22:	3f 4f       	sbci	r19, 0xFF	; 255
    4b24:	d7 01       	movw	r26, r14
    4b26:	90 e0       	ldi	r25, 0x00	; 0
    4b28:	07 c0       	rjmp	.+14     	; 0x4b38 <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    4b2a:	ea 0d       	add	r30, r10
    4b2c:	fb 1d       	adc	r31, r11
    4b2e:	80 81       	ld	r24, Z
    4b30:	8c 93       	st	X, r24
		  iPos++;
    4b32:	2f 5f       	subi	r18, 0xFF	; 255
    4b34:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    4b36:	9f 5f       	subi	r25, 0xFF	; 255
    4b38:	e9 2f       	mov	r30, r25
    4b3a:	f0 e0       	ldi	r31, 0x00	; 0
    4b3c:	11 96       	adiw	r26, 0x01	; 1
    4b3e:	ec 17       	cp	r30, r28
    4b40:	fd 07       	cpc	r31, r29
    4b42:	98 f3       	brcs	.-26     	; 0x4b2a <CreateReport+0x5c>
    4b44:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    4b46:	ca 32       	cpi	r28, 0x2A	; 42
    4b48:	d1 05       	cpc	r29, r1
    4b4a:	91 f0       	breq	.+36     	; 0x4b70 <CreateReport+0xa2>
    4b4c:	f6 01       	movw	r30, r12
    4b4e:	e2 0f       	add	r30, r18
    4b50:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    4b52:	4a e2       	ldi	r20, 0x2A	; 42
    4b54:	50 e0       	ldi	r21, 0x00	; 0
    4b56:	4c 1b       	sub	r20, r28
    4b58:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    4b5a:	70 e2       	ldi	r23, 0x20	; 32
    4b5c:	03 c0       	rjmp	.+6      	; 0x4b64 <CreateReport+0x96>
    4b5e:	71 93       	st	Z+, r23
		      iPos++;
    4b60:	2f 5f       	subi	r18, 0xFF	; 255
    4b62:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    4b64:	82 2f       	mov	r24, r18
    4b66:	86 1b       	sub	r24, r22
    4b68:	90 e0       	ldi	r25, 0x00	; 0
    4b6a:	84 17       	cp	r24, r20
    4b6c:	95 07       	cpc	r25, r21
    4b6e:	b8 f3       	brcs	.-18     	; 0x4b5e <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4b70:	f6 01       	movw	r30, r12
    4b72:	e2 0f       	add	r30, r18
    4b74:	f3 1f       	adc	r31, r19
    4b76:	70 82       	st	Z, r7
     iPos++;
    4b78:	c9 01       	movw	r24, r18
    4b7a:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    4b7c:	c8 0e       	add	r12, r24
    4b7e:	d9 1e       	adc	r13, r25
    4b80:	2d e0       	ldi	r18, 0x0D	; 13
    4b82:	f6 01       	movw	r30, r12
    4b84:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    4b86:	01 96       	adiw	r24, 0x01	; 1
    4b88:	f4 01       	movw	r30, r8
    4b8a:	91 83       	std	Z+1, r25	; 0x01
    4b8c:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//uart_print(0,1,strSend);
}
    4b8e:	df 91       	pop	r29
    4b90:	cf 91       	pop	r28
    4b92:	1f 91       	pop	r17
    4b94:	0f 91       	pop	r16
    4b96:	ff 90       	pop	r15
    4b98:	ef 90       	pop	r14
    4b9a:	df 90       	pop	r13
    4b9c:	cf 90       	pop	r12
    4b9e:	bf 90       	pop	r11
    4ba0:	af 90       	pop	r10
    4ba2:	9f 90       	pop	r9
    4ba4:	8f 90       	pop	r8
    4ba6:	7f 90       	pop	r7
    4ba8:	08 95       	ret

00004baa <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    4baa:	38 2f       	mov	r19, r24
    4bac:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    4bae:	81 50       	subi	r24, 0x01	; 1
    4bb0:	86 30       	cpi	r24, 0x06	; 6
    4bb2:	68 f5       	brcc	.+90     	; 0x4c0e <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    4bb4:	fb 01       	movw	r30, r22
    4bb6:	01 90       	ld	r0, Z+
    4bb8:	00 20       	and	r0, r0
    4bba:	e9 f7       	brne	.-6      	; 0x4bb6 <AddList+0xc>
    4bbc:	31 97       	sbiw	r30, 0x01	; 1
    4bbe:	e6 1b       	sub	r30, r22
    4bc0:	f7 0b       	sbc	r31, r23
    4bc2:	7e 2f       	mov	r23, r30
	     if (Length>0){
    4bc4:	ee 23       	and	r30, r30
    4bc6:	11 f4       	brne	.+4      	; 0x4bcc <AddList+0x22>
    4bc8:	20 e0       	ldi	r18, 0x00	; 0
    4bca:	14 c0       	rjmp	.+40     	; 0x4bf4 <AddList+0x4a>
    4bcc:	80 e0       	ldi	r24, 0x00	; 0
    4bce:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    4bd0:	63 2f       	mov	r22, r19
    4bd2:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4bd4:	fa 01       	movw	r30, r20
    4bd6:	e8 0f       	add	r30, r24
    4bd8:	f9 1f       	adc	r31, r25
    4bda:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4bdc:	3a 30       	cpi	r19, 0x0A	; 10
    4bde:	10 f0       	brcs	.+4      	; 0x4be4 <AddList+0x3a>
    4be0:	20 e3       	ldi	r18, 0x30	; 48
    4be2:	01 c0       	rjmp	.+2      	; 0x4be6 <AddList+0x3c>
	    Result='0'+X;
    4be4:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4be6:	e2 17       	cp	r30, r18
    4be8:	91 f0       	breq	.+36     	; 0x4c0e <AddList+0x64>
    4bea:	28 2f       	mov	r18, r24
    4bec:	2f 5f       	subi	r18, 0xFF	; 255
    4bee:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    4bf0:	87 17       	cp	r24, r23
    4bf2:	80 f3       	brcs	.-32     	; 0x4bd4 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4bf4:	62 2f       	mov	r22, r18
    4bf6:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4bf8:	3a 30       	cpi	r19, 0x0A	; 10
    4bfa:	10 f0       	brcs	.+4      	; 0x4c00 <AddList+0x56>
    4bfc:	80 e3       	ldi	r24, 0x30	; 48
    4bfe:	02 c0       	rjmp	.+4      	; 0x4c04 <AddList+0x5a>
	    Result='0'+X;
    4c00:	83 2f       	mov	r24, r19
    4c02:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4c04:	fa 01       	movw	r30, r20
    4c06:	e6 0f       	add	r30, r22
    4c08:	f7 1f       	adc	r31, r23
    4c0a:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    4c0c:	11 82       	std	Z+1, r1	; 0x01
    4c0e:	08 95       	ret

00004c10 <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    4c10:	dc 01       	movw	r26, r24
    4c12:	0d 90       	ld	r0, X+
    4c14:	00 20       	and	r0, r0
    4c16:	e9 f7       	brne	.-6      	; 0x4c12 <ClearList+0x2>
    4c18:	11 97       	sbiw	r26, 0x01	; 1
    4c1a:	a8 1b       	sub	r26, r24
    4c1c:	b9 0b       	sbc	r27, r25
    4c1e:	20 e0       	ldi	r18, 0x00	; 0
    4c20:	30 e0       	ldi	r19, 0x00	; 0
    4c22:	06 c0       	rjmp	.+12     	; 0x4c30 <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4c24:	fc 01       	movw	r30, r24
    4c26:	e2 0f       	add	r30, r18
    4c28:	f3 1f       	adc	r31, r19
    4c2a:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4c2c:	2f 5f       	subi	r18, 0xFF	; 255
    4c2e:	3f 4f       	sbci	r19, 0xFF	; 255
    4c30:	2a 17       	cp	r18, r26
    4c32:	3b 07       	cpc	r19, r27
    4c34:	b8 f3       	brcs	.-18     	; 0x4c24 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    4c36:	08 95       	ret

00004c38 <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    4c38:	6f 92       	push	r6
    4c3a:	7f 92       	push	r7
    4c3c:	8f 92       	push	r8
    4c3e:	9f 92       	push	r9
    4c40:	bf 92       	push	r11
    4c42:	cf 92       	push	r12
    4c44:	df 92       	push	r13
    4c46:	ef 92       	push	r14
    4c48:	ff 92       	push	r15
    4c4a:	0f 93       	push	r16
    4c4c:	1f 93       	push	r17
    4c4e:	df 93       	push	r29
    4c50:	cf 93       	push	r28
    4c52:	cd b7       	in	r28, 0x3d	; 61
    4c54:	de b7       	in	r29, 0x3e	; 62
    4c56:	64 97       	sbiw	r28, 0x14	; 20
    4c58:	0f b6       	in	r0, 0x3f	; 63
    4c5a:	f8 94       	cli
    4c5c:	de bf       	out	0x3e, r29	; 62
    4c5e:	0f be       	out	0x3f, r0	; 63
    4c60:	cd bf       	out	0x3d, r28	; 61
    4c62:	7c 01       	movw	r14, r24
    4c64:	6a 01       	movw	r12, r20
    4c66:	bb 24       	eor	r11, r11
    4c68:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    4c6a:	06 2f       	mov	r16, r22
    4c6c:	10 e0       	ldi	r17, 0x00	; 0
    4c6e:	00 53       	subi	r16, 0x30	; 48
    4c70:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    4c72:	3e 01       	movw	r6, r28
    4c74:	08 94       	sec
    4c76:	61 1c       	adc	r6, r1
    4c78:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    4c7a:	82 e0       	ldi	r24, 0x02	; 2
    4c7c:	88 2e       	mov	r8, r24
    4c7e:	91 2c       	mov	r9, r1
    4c80:	8c 0e       	add	r8, r28
    4c82:	9d 1e       	adc	r9, r29
    4c84:	24 c0       	rjmp	.+72     	; 0x4cce <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    4c86:	11 97       	sbiw	r26, 0x01	; 1
    4c88:	a4 1b       	sub	r26, r20
    4c8a:	b5 0b       	sbc	r27, r21
    4c8c:	ae 0d       	add	r26, r14
    4c8e:	bf 1d       	adc	r27, r15
    4c90:	8c 91       	ld	r24, X
    4c92:	90 e0       	ldi	r25, 0x00	; 0
    4c94:	c0 97       	sbiw	r24, 0x30	; 48
    4c96:	bc 01       	movw	r22, r24
    4c98:	60 9f       	mul	r22, r16
    4c9a:	c0 01       	movw	r24, r0
    4c9c:	61 9f       	mul	r22, r17
    4c9e:	90 0d       	add	r25, r0
    4ca0:	70 9f       	mul	r23, r16
    4ca2:	90 0d       	add	r25, r0
    4ca4:	11 24       	eor	r1, r1
    4ca6:	23 2f       	mov	r18, r19
    4ca8:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    4caa:	82 2f       	mov	r24, r18
    4cac:	6a e0       	ldi	r22, 0x0A	; 10
    4cae:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    4cb2:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    4cb4:	f3 01       	movw	r30, r6
    4cb6:	e4 0f       	add	r30, r20
    4cb8:	f5 1f       	adc	r31, r21
    4cba:	82 2f       	mov	r24, r18
    4cbc:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    4cc0:	90 5d       	subi	r25, 0xD0	; 208
    4cc2:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4cc4:	48 0d       	add	r20, r8
    4cc6:	59 1d       	adc	r21, r9
    4cc8:	fa 01       	movw	r30, r20
    4cca:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    4ccc:	b3 94       	inc	r11
    4cce:	4b 2d       	mov	r20, r11
    4cd0:	50 e0       	ldi	r21, 0x00	; 0
    4cd2:	d7 01       	movw	r26, r14
    4cd4:	0d 90       	ld	r0, X+
    4cd6:	00 20       	and	r0, r0
    4cd8:	e9 f7       	brne	.-6      	; 0x4cd4 <CalcSegmen+0x9c>
    4cda:	11 97       	sbiw	r26, 0x01	; 1
    4cdc:	ae 19       	sub	r26, r14
    4cde:	bf 09       	sbc	r27, r15
    4ce0:	4a 17       	cp	r20, r26
    4ce2:	5b 07       	cpc	r21, r27
    4ce4:	80 f2       	brcs	.-96     	; 0x4c86 <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    4ce6:	33 23       	and	r19, r19
    4ce8:	89 f0       	breq	.+34     	; 0x4d0c <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    4cea:	fe 01       	movw	r30, r28
    4cec:	31 96       	adiw	r30, 0x01	; 1
    4cee:	df 01       	movw	r26, r30
    4cf0:	0d 90       	ld	r0, X+
    4cf2:	00 20       	and	r0, r0
    4cf4:	e9 f7       	brne	.-6      	; 0x4cf0 <CalcSegmen+0xb8>
    4cf6:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    4cf8:	ae 1b       	sub	r26, r30
    4cfa:	b0 e0       	ldi	r27, 0x00	; 0
    4cfc:	ea 0f       	add	r30, r26
    4cfe:	fb 1f       	adc	r31, r27
    4d00:	30 5d       	subi	r19, 0xD0	; 208
    4d02:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4d04:	ac 0f       	add	r26, r28
    4d06:	bd 1f       	adc	r27, r29
    4d08:	12 96       	adiw	r26, 0x02	; 2
    4d0a:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    4d0c:	de 01       	movw	r26, r28
    4d0e:	11 96       	adiw	r26, 0x01	; 1
    4d10:	fd 01       	movw	r30, r26
    4d12:	01 90       	ld	r0, Z+
    4d14:	00 20       	and	r0, r0
    4d16:	e9 f7       	brne	.-6      	; 0x4d12 <CalcSegmen+0xda>
    4d18:	31 97       	sbiw	r30, 0x01	; 1
    4d1a:	9e 2f       	mov	r25, r30
    4d1c:	9a 1b       	sub	r25, r26
    4d1e:	a9 0f       	add	r26, r25
    4d20:	b1 1d       	adc	r27, r1
    4d22:	f6 01       	movw	r30, r12
    4d24:	02 c0       	rjmp	.+4      	; 0x4d2a <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    4d26:	8c 91       	ld	r24, X
    4d28:	81 93       	st	Z+, r24
    4d2a:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    4d2c:	ac 17       	cp	r26, r28
    4d2e:	bd 07       	cpc	r27, r29
    4d30:	d1 f7       	brne	.-12     	; 0x4d26 <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    4d32:	c9 0e       	add	r12, r25
    4d34:	d1 1c       	adc	r13, r1
    4d36:	f6 01       	movw	r30, r12
    4d38:	10 82       	st	Z, r1
}
    4d3a:	64 96       	adiw	r28, 0x14	; 20
    4d3c:	0f b6       	in	r0, 0x3f	; 63
    4d3e:	f8 94       	cli
    4d40:	de bf       	out	0x3e, r29	; 62
    4d42:	0f be       	out	0x3f, r0	; 63
    4d44:	cd bf       	out	0x3d, r28	; 61
    4d46:	cf 91       	pop	r28
    4d48:	df 91       	pop	r29
    4d4a:	1f 91       	pop	r17
    4d4c:	0f 91       	pop	r16
    4d4e:	ff 90       	pop	r15
    4d50:	ef 90       	pop	r14
    4d52:	df 90       	pop	r13
    4d54:	cf 90       	pop	r12
    4d56:	bf 90       	pop	r11
    4d58:	9f 90       	pop	r9
    4d5a:	8f 90       	pop	r8
    4d5c:	7f 90       	pop	r7
    4d5e:	6f 90       	pop	r6
    4d60:	08 95       	ret

00004d62 <GetMinusPos>:
	      break;	 
	 }
*/
}

char GetMinusPos(char *strNumber){
    4d62:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    4d64:	dc 01       	movw	r26, r24
    4d66:	0d 90       	ld	r0, X+
    4d68:	00 20       	and	r0, r0
    4d6a:	e9 f7       	brne	.-6      	; 0x4d66 <GetMinusPos+0x4>
    4d6c:	11 97       	sbiw	r26, 0x01	; 1
    4d6e:	a8 1b       	sub	r26, r24
    4d70:	b9 0b       	sbc	r27, r25
    4d72:	20 e0       	ldi	r18, 0x00	; 0
    4d74:	0a c0       	rjmp	.+20     	; 0x4d8a <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    4d76:	e4 0f       	add	r30, r20
    4d78:	f5 1f       	adc	r31, r21
    4d7a:	80 81       	ld	r24, Z
    4d7c:	92 2f       	mov	r25, r18
    4d7e:	9f 5f       	subi	r25, 0xFF	; 255
    4d80:	8d 32       	cpi	r24, 0x2D	; 45
    4d82:	11 f4       	brne	.+4      	; 0x4d88 <GetMinusPos+0x26>
		     Result=i+1;
    4d84:	89 2f       	mov	r24, r25
    4d86:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    4d88:	29 2f       	mov	r18, r25
    4d8a:	e2 2f       	mov	r30, r18
    4d8c:	f0 e0       	ldi	r31, 0x00	; 0
    4d8e:	ea 17       	cp	r30, r26
    4d90:	fb 07       	cpc	r31, r27
    4d92:	88 f3       	brcs	.-30     	; 0x4d76 <GetMinusPos+0x14>
    4d94:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    4d96:	08 95       	ret

00004d98 <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    4d98:	0e 94 b1 26 	call	0x4d62	; 0x4d62 <GetMinusPos>
    4d9c:	81 11       	cpse	r24, r1
    4d9e:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    4da0:	08 95       	ret

00004da2 <RemoveMinus>:

void RemoveMinus(char *strNumber){
    4da2:	cf 93       	push	r28
    4da4:	df 93       	push	r29
    4da6:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    4da8:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <IsMinus>
    4dac:	81 30       	cpi	r24, 0x01	; 1
    4dae:	19 f5       	brne	.+70     	; 0x4df6 <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    4db0:	ce 01       	movw	r24, r28
    4db2:	0e 94 b1 26 	call	0x4d62	; 0x4d62 <GetMinusPos>
		 Length=strlen(strNumber);
    4db6:	de 01       	movw	r26, r28
    4db8:	0d 90       	ld	r0, X+
    4dba:	00 20       	and	r0, r0
    4dbc:	e9 f7       	brne	.-6      	; 0x4db8 <RemoveMinus+0x16>
    4dbe:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    4dc0:	ac 1b       	sub	r26, r28
    4dc2:	b0 e0       	ldi	r27, 0x00	; 0
    4dc4:	90 e0       	ldi	r25, 0x00	; 0
    4dc6:	a8 1b       	sub	r26, r24
    4dc8:	b9 0b       	sbc	r27, r25
    4dca:	ae 01       	movw	r20, r28
    4dcc:	48 0f       	add	r20, r24
    4dce:	59 1f       	adc	r21, r25
    4dd0:	20 e0       	ldi	r18, 0x00	; 0
    4dd2:	30 e0       	ldi	r19, 0x00	; 0
    4dd4:	0a c0       	rjmp	.+20     	; 0x4dea <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4dd6:	be 01       	movw	r22, r28
    4dd8:	62 0f       	add	r22, r18
    4dda:	73 1f       	adc	r23, r19
    4ddc:	fa 01       	movw	r30, r20
    4dde:	81 91       	ld	r24, Z+
    4de0:	af 01       	movw	r20, r30
    4de2:	fb 01       	movw	r30, r22
    4de4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4de6:	2f 5f       	subi	r18, 0xFF	; 255
    4de8:	3f 4f       	sbci	r19, 0xFF	; 255
    4dea:	2a 17       	cp	r18, r26
    4dec:	3b 07       	cpc	r19, r27
    4dee:	98 f3       	brcs	.-26     	; 0x4dd6 <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4df0:	ac 0f       	add	r26, r28
    4df2:	bd 1f       	adc	r27, r29
    4df4:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    4df6:	df 91       	pop	r29
    4df8:	cf 91       	pop	r28
    4dfa:	08 95       	ret

00004dfc <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    4dfc:	ac 01       	movw	r20, r24
    4dfe:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    4e00:	fc 01       	movw	r30, r24
    4e02:	01 90       	ld	r0, Z+
    4e04:	00 20       	and	r0, r0
    4e06:	e9 f7       	brne	.-6      	; 0x4e02 <IsMoreThan+0x6>
    4e08:	31 97       	sbiw	r30, 0x01	; 1
    4e0a:	7e 2f       	mov	r23, r30
    4e0c:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    4e0e:	a6 2f       	mov	r26, r22
    4e10:	b2 2f       	mov	r27, r18
    4e12:	fd 01       	movw	r30, r26
    4e14:	01 90       	ld	r0, Z+
    4e16:	00 20       	and	r0, r0
    4e18:	e9 f7       	brne	.-6      	; 0x4e14 <IsMoreThan+0x18>
    4e1a:	31 97       	sbiw	r30, 0x01	; 1
    4e1c:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    4e1e:	e7 17       	cp	r30, r23
    4e20:	48 f1       	brcs	.+82     	; 0x4e74 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    4e22:	7e 17       	cp	r23, r30
    4e24:	49 f5       	brne	.+82     	; 0x4e78 <IsMoreThan+0x7c>
    4e26:	86 2f       	mov	r24, r22
    4e28:	92 2f       	mov	r25, r18
    4e2a:	9c 01       	movw	r18, r24
    4e2c:	d9 01       	movw	r26, r18
    4e2e:	20 e0       	ldi	r18, 0x00	; 0
    4e30:	30 e0       	ldi	r19, 0x00	; 0
    4e32:	1d c0       	rjmp	.+58     	; 0x4e6e <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4e34:	fa 01       	movw	r30, r20
    4e36:	e2 0f       	add	r30, r18
    4e38:	f3 1f       	adc	r31, r19
    4e3a:	e0 81       	ld	r30, Z
    4e3c:	e0 53       	subi	r30, 0x30	; 48
    4e3e:	ea 30       	cpi	r30, 0x0A	; 10
    4e40:	10 f0       	brcs	.+4      	; 0x4e46 <IsMoreThan+0x4a>
    4e42:	60 e0       	ldi	r22, 0x00	; 0
    4e44:	01 c0       	rjmp	.+2      	; 0x4e48 <IsMoreThan+0x4c>
    4e46:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    4e48:	8c 91       	ld	r24, X
    4e4a:	80 53       	subi	r24, 0x30	; 48
    4e4c:	8a 30       	cpi	r24, 0x0A	; 10
    4e4e:	10 f0       	brcs	.+4      	; 0x4e54 <IsMoreThan+0x58>
    4e50:	90 e0       	ldi	r25, 0x00	; 0
    4e52:	01 c0       	rjmp	.+2      	; 0x4e56 <IsMoreThan+0x5a>
    4e54:	98 2f       	mov	r25, r24
    4e56:	96 17       	cp	r25, r22
    4e58:	68 f0       	brcs	.+26     	; 0x4e74 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4e5a:	ea 30       	cpi	r30, 0x0A	; 10
    4e5c:	08 f0       	brcs	.+2      	; 0x4e60 <IsMoreThan+0x64>
    4e5e:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    4e60:	8a 30       	cpi	r24, 0x0A	; 10
    4e62:	10 f4       	brcc	.+4      	; 0x4e68 <IsMoreThan+0x6c>
    4e64:	e8 17       	cp	r30, r24
    4e66:	40 f0       	brcs	.+16     	; 0x4e78 <IsMoreThan+0x7c>
    4e68:	2f 5f       	subi	r18, 0xFF	; 255
    4e6a:	3f 4f       	sbci	r19, 0xFF	; 255
    4e6c:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    4e6e:	27 17       	cp	r18, r23
    4e70:	08 f3       	brcs	.-62     	; 0x4e34 <IsMoreThan+0x38>
    4e72:	02 c0       	rjmp	.+4      	; 0x4e78 <IsMoreThan+0x7c>
    4e74:	81 e0       	ldi	r24, 0x01	; 1
    4e76:	08 95       	ret
    4e78:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    4e7a:	08 95       	ret

00004e7c <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    4e7c:	fc 01       	movw	r30, r24
    4e7e:	01 90       	ld	r0, Z+
    4e80:	00 20       	and	r0, r0
    4e82:	e9 f7       	brne	.-6      	; 0x4e7e <IsZerroAll+0x2>
    4e84:	31 97       	sbiw	r30, 0x01	; 1
    4e86:	e8 1b       	sub	r30, r24
    4e88:	dc 01       	movw	r26, r24
    4e8a:	ae 0f       	add	r26, r30
    4e8c:	b1 1d       	adc	r27, r1
    4e8e:	90 e0       	ldi	r25, 0x00	; 0
    4e90:	20 e0       	ldi	r18, 0x00	; 0
    4e92:	06 c0       	rjmp	.+12     	; 0x4ea0 <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    4e94:	8c 91       	ld	r24, X
    4e96:	80 33       	cpi	r24, 0x30	; 48
    4e98:	09 f4       	brne	.+2      	; 0x4e9c <IsZerroAll+0x20>
    4e9a:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    4e9c:	9f 5f       	subi	r25, 0xFF	; 255
    4e9e:	11 97       	sbiw	r26, 0x01	; 1
    4ea0:	9e 17       	cp	r25, r30
    4ea2:	c0 f3       	brcs	.-16     	; 0x4e94 <IsZerroAll+0x18>
    4ea4:	80 e0       	ldi	r24, 0x00	; 0
    4ea6:	2e 17       	cp	r18, r30
    4ea8:	09 f4       	brne	.+2      	; 0x4eac <IsZerroAll+0x30>
    4eaa:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    4eac:	08 95       	ret

00004eae <PstrCopy>:
void CarriegeReturn(){
     uart(_COM_PRINTER, 1, 0x0D);     
     uart(_COM_PRINTER, 1, 0x0A);
}

void PstrCopy(char *Dest,char *Source){
    4eae:	cf 93       	push	r28
    4eb0:	df 93       	push	r29
    4eb2:	20 e0       	ldi	r18, 0x00	; 0
    4eb4:	08 c0       	rjmp	.+16     	; 0x4ec6 <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    4eb6:	fb 01       	movw	r30, r22
    4eb8:	ec 0f       	add	r30, r28
    4eba:	fd 1f       	adc	r31, r29
    4ebc:	e4 91       	lpm	r30, Z+
    4ebe:	c8 0f       	add	r28, r24
    4ec0:	d9 1f       	adc	r29, r25
    4ec2:	e8 83       	st	Y, r30
     uart(_COM_PRINTER, 1, 0x0A);
}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4ec4:	2f 5f       	subi	r18, 0xFF	; 255
    4ec6:	c2 2f       	mov	r28, r18
    4ec8:	d0 e0       	ldi	r29, 0x00	; 0
    4eca:	fb 01       	movw	r30, r22
    4ecc:	01 90       	ld	r0, Z+
    4ece:	00 20       	and	r0, r0
    4ed0:	e9 f7       	brne	.-6      	; 0x4ecc <PstrCopy+0x1e>
    4ed2:	31 97       	sbiw	r30, 0x01	; 1
    4ed4:	e6 1b       	sub	r30, r22
    4ed6:	f7 0b       	sbc	r31, r23
    4ed8:	ce 17       	cp	r28, r30
    4eda:	df 07       	cpc	r29, r31
    4edc:	60 f3       	brcs	.-40     	; 0x4eb6 <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    4ede:	df 91       	pop	r29
    4ee0:	cf 91       	pop	r28
    4ee2:	08 95       	ret

00004ee4 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4ee4:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4ee6:	dc 01       	movw	r26, r24
    4ee8:	0d 90       	ld	r0, X+
    4eea:	00 20       	and	r0, r0
    4eec:	e9 f7       	brne	.-6      	; 0x4ee8 <SpaceOnly+0x4>
    4eee:	11 97       	sbiw	r26, 0x01	; 1
    4ef0:	a8 1b       	sub	r26, r24
    4ef2:	b9 0b       	sbc	r27, r25
    4ef4:	90 e0       	ldi	r25, 0x00	; 0
    4ef6:	20 e0       	ldi	r18, 0x00	; 0
    4ef8:	30 e0       	ldi	r19, 0x00	; 0
    4efa:	09 c0       	rjmp	.+18     	; 0x4f0e <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    4efc:	fa 01       	movw	r30, r20
    4efe:	e2 0f       	add	r30, r18
    4f00:	f3 1f       	adc	r31, r19
    4f02:	80 81       	ld	r24, Z
    4f04:	80 32       	cpi	r24, 0x20	; 32
    4f06:	09 f0       	breq	.+2      	; 0x4f0a <SpaceOnly+0x26>
    4f08:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4f0a:	2f 5f       	subi	r18, 0xFF	; 255
    4f0c:	3f 4f       	sbci	r19, 0xFF	; 255
    4f0e:	2a 17       	cp	r18, r26
    4f10:	3b 07       	cpc	r19, r27
    4f12:	a0 f3       	brcs	.-24     	; 0x4efc <SpaceOnly+0x18>
    4f14:	80 e0       	ldi	r24, 0x00	; 0
    4f16:	99 23       	and	r25, r25
    4f18:	09 f4       	brne	.+2      	; 0x4f1c <SpaceOnly+0x38>
    4f1a:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    4f1c:	08 95       	ret

00004f1e <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    4f1e:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    4f20:	e1 99       	sbic	0x1c, 1	; 28
    4f22:	fe cf       	rjmp	.-4      	; 0x4f20 <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4f24:	8e e3       	ldi	r24, 0x3E	; 62
    4f26:	90 e0       	ldi	r25, 0x00	; 0
    4f28:	9f bb       	out	0x1f, r25	; 31
    4f2a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4f2c:	e0 9a       	sbi	0x1c, 0	; 28
    4f2e:	5d b3       	in	r21, 0x1d	; 29
    4f30:	40 e0       	ldi	r20, 0x00	; 0
    4f32:	08 c0       	rjmp	.+16     	; 0x4f44 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    4f34:	f9 01       	movw	r30, r18
    4f36:	e8 0f       	add	r30, r24
    4f38:	f9 1f       	adc	r31, r25
    4f3a:	80 81       	ld	r24, Z
    4f3c:	85 17       	cp	r24, r21
    4f3e:	09 f4       	brne	.+2      	; 0x4f42 <RemDecimal+0x24>
		     strDecimal[i]=0;
    4f40:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    4f42:	4f 5f       	subi	r20, 0xFF	; 255
    4f44:	84 2f       	mov	r24, r20
    4f46:	90 e0       	ldi	r25, 0x00	; 0
    4f48:	f9 01       	movw	r30, r18
    4f4a:	01 90       	ld	r0, Z+
    4f4c:	00 20       	and	r0, r0
    4f4e:	e9 f7       	brne	.-6      	; 0x4f4a <RemDecimal+0x2c>
    4f50:	31 97       	sbiw	r30, 0x01	; 1
    4f52:	e2 1b       	sub	r30, r18
    4f54:	f3 0b       	sbc	r31, r19
    4f56:	8e 17       	cp	r24, r30
    4f58:	9f 07       	cpc	r25, r31
    4f5a:	60 f3       	brcs	.-40     	; 0x4f34 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    4f5c:	08 95       	ret

00004f5e <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    4f5e:	cf 92       	push	r12
    4f60:	df 92       	push	r13
    4f62:	ef 92       	push	r14
    4f64:	ff 92       	push	r15
    4f66:	0f 93       	push	r16
    4f68:	1f 93       	push	r17
    4f6a:	df 93       	push	r29
    4f6c:	cf 93       	push	r28
    4f6e:	cd b7       	in	r28, 0x3d	; 61
    4f70:	de b7       	in	r29, 0x3e	; 62
    4f72:	67 97       	sbiw	r28, 0x17	; 23
    4f74:	0f b6       	in	r0, 0x3f	; 63
    4f76:	f8 94       	cli
    4f78:	de bf       	out	0x3e, r29	; 62
    4f7a:	0f be       	out	0x3f, r0	; 63
    4f7c:	cd bf       	out	0x3d, r28	; 61
    4f7e:	7c 01       	movw	r14, r24
    4f80:	d6 2e       	mov	r13, r22
    4f82:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    4f84:	00 d0       	rcall	.+0      	; 0x4f86 <GetProductPrice+0x28>
    4f86:	00 d0       	rcall	.+0      	; 0x4f88 <GetProductPrice+0x2a>
    4f88:	ad b7       	in	r26, 0x3d	; 61
    4f8a:	be b7       	in	r27, 0x3e	; 62
    4f8c:	12 96       	adiw	r26, 0x02	; 2
    4f8e:	9c 93       	st	X, r25
    4f90:	8e 93       	st	-X, r24
    4f92:	11 97       	sbiw	r26, 0x01	; 1
    4f94:	8c ec       	ldi	r24, 0xCC	; 204
    4f96:	94 e0       	ldi	r25, 0x04	; 4
    4f98:	14 96       	adiw	r26, 0x04	; 4
    4f9a:	9c 93       	st	X, r25
    4f9c:	8e 93       	st	-X, r24
    4f9e:	13 97       	sbiw	r26, 0x03	; 3
    4fa0:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4fa4:	0f 90       	pop	r0
    4fa6:	0f 90       	pop	r0
    4fa8:	0f 90       	pop	r0
    4faa:	0f 90       	pop	r0
    4fac:	8e 01       	movw	r16, r28
    4fae:	09 5f       	subi	r16, 0xF9	; 249
    4fb0:	1f 4f       	sbci	r17, 0xFF	; 255
    4fb2:	c8 01       	movw	r24, r16
    4fb4:	65 e4       	ldi	r22, 0x45	; 69
    4fb6:	70 e0       	ldi	r23, 0x00	; 0
    4fb8:	48 e0       	ldi	r20, 0x08	; 8
    4fba:	50 e0       	ldi	r21, 0x00	; 0
    4fbc:	22 e4       	ldi	r18, 0x42	; 66
    4fbe:	33 e1       	ldi	r19, 0x13	; 19
    4fc0:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    4fc4:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4fc6:	9e 01       	movw	r18, r28
    4fc8:	21 5f       	subi	r18, 0xF1	; 241
    4fca:	3f 4f       	sbci	r19, 0xFF	; 255
    4fcc:	9e 2f       	mov	r25, r30
    4fce:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    4fd0:	80 81       	ld	r24, Z
    4fd2:	8d 15       	cp	r24, r13
    4fd4:	11 f4       	brne	.+4      	; 0x4fda <GetProductPrice+0x7c>
    4fd6:	89 2f       	mov	r24, r25
    4fd8:	05 c0       	rjmp	.+10     	; 0x4fe4 <GetProductPrice+0x86>
    4fda:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4fdc:	e2 17       	cp	r30, r18
    4fde:	f3 07       	cpc	r31, r19
    4fe0:	a9 f7       	brne	.-22     	; 0x4fcc <GetProductPrice+0x6e>
    4fe2:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4fe4:	b5 e0       	ldi	r27, 0x05	; 5
    4fe6:	bc 15       	cp	r27, r12
    4fe8:	08 f4       	brcc	.+2      	; 0x4fec <GetProductPrice+0x8e>
    4fea:	41 c0       	rjmp	.+130    	; 0x506e <GetProductPrice+0x110>
    4fec:	66 e0       	ldi	r22, 0x06	; 6
    4fee:	86 9f       	mul	r24, r22
    4ff0:	b0 01       	movw	r22, r0
    4ff2:	11 24       	eor	r1, r1
    4ff4:	6b 5a       	subi	r22, 0xAB	; 171
    4ff6:	7f 4f       	sbci	r23, 0xFF	; 255
    4ff8:	ce 01       	movw	r24, r28
    4ffa:	01 96       	adiw	r24, 0x01	; 1
    4ffc:	46 e0       	ldi	r20, 0x06	; 6
    4ffe:	50 e0       	ldi	r21, 0x00	; 0
    5000:	22 e4       	ldi	r18, 0x42	; 66
    5002:	33 e1       	ldi	r19, 0x13	; 19
    5004:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    5008:	8e 01       	movw	r16, r28
    500a:	01 5f       	subi	r16, 0xF1	; 241
    500c:	1f 4f       	sbci	r17, 0xFF	; 255
    500e:	fe 01       	movw	r30, r28
    5010:	ec 0d       	add	r30, r12
    5012:	f1 1d       	adc	r31, r1
    5014:	60 81       	ld	r22, Z
    5016:	89 e0       	ldi	r24, 0x09	; 9
    5018:	68 9f       	mul	r22, r24
    501a:	b0 01       	movw	r22, r0
    501c:	11 24       	eor	r1, r1
    501e:	64 58       	subi	r22, 0x84	; 132
    5020:	7f 4f       	sbci	r23, 0xFF	; 255
    5022:	c8 01       	movw	r24, r16
    5024:	49 e0       	ldi	r20, 0x09	; 9
    5026:	50 e0       	ldi	r21, 0x00	; 0
    5028:	22 e4       	ldi	r18, 0x42	; 66
    502a:	33 e1       	ldi	r19, 0x13	; 19
    502c:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    5030:	c8 01       	movw	r24, r16
    5032:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    5036:	00 d0       	rcall	.+0      	; 0x5038 <GetProductPrice+0xda>
    5038:	00 d0       	rcall	.+0      	; 0x503a <GetProductPrice+0xdc>
    503a:	00 d0       	rcall	.+0      	; 0x503c <GetProductPrice+0xde>
    503c:	ed b7       	in	r30, 0x3d	; 61
    503e:	fe b7       	in	r31, 0x3e	; 62
    5040:	31 96       	adiw	r30, 0x01	; 1
    5042:	ad b7       	in	r26, 0x3d	; 61
    5044:	be b7       	in	r27, 0x3e	; 62
    5046:	12 96       	adiw	r26, 0x02	; 2
    5048:	fc 92       	st	X, r15
    504a:	ee 92       	st	-X, r14
    504c:	11 97       	sbiw	r26, 0x01	; 1
    504e:	89 ec       	ldi	r24, 0xC9	; 201
    5050:	94 e0       	ldi	r25, 0x04	; 4
    5052:	93 83       	std	Z+3, r25	; 0x03
    5054:	82 83       	std	Z+2, r24	; 0x02
    5056:	15 83       	std	Z+5, r17	; 0x05
    5058:	04 83       	std	Z+4, r16	; 0x04
    505a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    505e:	ed b7       	in	r30, 0x3d	; 61
    5060:	fe b7       	in	r31, 0x3e	; 62
    5062:	36 96       	adiw	r30, 0x06	; 6
    5064:	0f b6       	in	r0, 0x3f	; 63
    5066:	f8 94       	cli
    5068:	fe bf       	out	0x3e, r31	; 62
    506a:	0f be       	out	0x3f, r0	; 63
    506c:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    506e:	67 96       	adiw	r28, 0x17	; 23
    5070:	0f b6       	in	r0, 0x3f	; 63
    5072:	f8 94       	cli
    5074:	de bf       	out	0x3e, r29	; 62
    5076:	0f be       	out	0x3f, r0	; 63
    5078:	cd bf       	out	0x3d, r28	; 61
    507a:	cf 91       	pop	r28
    507c:	df 91       	pop	r29
    507e:	1f 91       	pop	r17
    5080:	0f 91       	pop	r16
    5082:	ff 90       	pop	r15
    5084:	ef 90       	pop	r14
    5086:	df 90       	pop	r13
    5088:	cf 90       	pop	r12
    508a:	08 95       	ret

0000508c <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    508c:	df 93       	push	r29
    508e:	cf 93       	push	r28
    5090:	cd b7       	in	r28, 0x3d	; 61
    5092:	de b7       	in	r29, 0x3e	; 62
    5094:	2b 97       	sbiw	r28, 0x0b	; 11
    5096:	0f b6       	in	r0, 0x3f	; 63
    5098:	f8 94       	cli
    509a:	de bf       	out	0x3e, r29	; 62
    509c:	0f be       	out	0x3f, r0	; 63
    509e:	cd bf       	out	0x3d, r28	; 61
    50a0:	98 2f       	mov	r25, r24
    50a2:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    50a4:	fb 01       	movw	r30, r22
    50a6:	80 85       	ldd	r24, Z+8	; 0x08
    50a8:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    50aa:	81 85       	ldd	r24, Z+9	; 0x09
    50ac:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    50ae:	87 81       	ldd	r24, Z+7	; 0x07
    50b0:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    50b2:	85 81       	ldd	r24, Z+5	; 0x05
    50b4:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    50b6:	86 81       	ldd	r24, Z+6	; 0x06
    50b8:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    50ba:	84 81       	ldd	r24, Z+4	; 0x04
    50bc:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    50be:	99 23       	and	r25, r25
    50c0:	19 f0       	breq	.+6      	; 0x50c8 <FormatDate+0x3c>
    50c2:	91 30       	cpi	r25, 0x01	; 1
    50c4:	59 f4       	brne	.+22     	; 0x50dc <FormatDate+0x50>
    50c6:	0f c0       	rjmp	.+30     	; 0x50e6 <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    50c8:	fb 01       	movw	r30, r22
    50ca:	80 81       	ld	r24, Z
    50cc:	8f 83       	std	Y+7, r24	; 0x07
    50ce:	81 81       	ldd	r24, Z+1	; 0x01
    50d0:	88 87       	std	Y+8, r24	; 0x08
    50d2:	82 81       	ldd	r24, Z+2	; 0x02
    50d4:	89 87       	std	Y+9, r24	; 0x09
    50d6:	83 81       	ldd	r24, Z+3	; 0x03
    50d8:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    50da:	1b 86       	std	Y+11, r1	; 0x0b
    50dc:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    50de:	ae 01       	movw	r20, r28
    50e0:	4f 5f       	subi	r20, 0xFF	; 255
    50e2:	5f 4f       	sbci	r21, 0xFF	; 255
    50e4:	0f c0       	rjmp	.+30     	; 0x5104 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    50e6:	fb 01       	movw	r30, r22
    50e8:	82 81       	ldd	r24, Z+2	; 0x02
    50ea:	8f 83       	std	Y+7, r24	; 0x07
    50ec:	83 81       	ldd	r24, Z+3	; 0x03
    50ee:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    50f0:	19 86       	std	Y+9, r1	; 0x09
    50f2:	f4 cf       	rjmp	.-24     	; 0x50dc <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    50f4:	f9 01       	movw	r30, r18
    50f6:	ea 0f       	add	r30, r26
    50f8:	fb 1f       	adc	r31, r27
    50fa:	a4 0f       	add	r26, r20
    50fc:	b5 1f       	adc	r27, r21
    50fe:	8c 91       	ld	r24, X
    5100:	80 83       	st	Z, r24
    5102:	9f 5f       	subi	r25, 0xFF	; 255
    5104:	a9 2f       	mov	r26, r25
    5106:	b0 e0       	ldi	r27, 0x00	; 0
    5108:	fa 01       	movw	r30, r20
    510a:	01 90       	ld	r0, Z+
    510c:	00 20       	and	r0, r0
    510e:	e9 f7       	brne	.-6      	; 0x510a <FormatDate+0x7e>
    5110:	31 97       	sbiw	r30, 0x01	; 1
    5112:	e4 1b       	sub	r30, r20
    5114:	f5 0b       	sbc	r31, r21
    5116:	ae 17       	cp	r26, r30
    5118:	bf 07       	cpc	r27, r31
    511a:	60 f3       	brcs	.-40     	; 0x50f4 <FormatDate+0x68>
}
    511c:	2b 96       	adiw	r28, 0x0b	; 11
    511e:	0f b6       	in	r0, 0x3f	; 63
    5120:	f8 94       	cli
    5122:	de bf       	out	0x3e, r29	; 62
    5124:	0f be       	out	0x3f, r0	; 63
    5126:	cd bf       	out	0x3d, r28	; 61
    5128:	cf 91       	pop	r28
    512a:	df 91       	pop	r29
    512c:	08 95       	ret

0000512e <RemZeroLead>:

	while (1){};
  #endif
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    512e:	cf 93       	push	r28
    5130:	df 93       	push	r29
    5132:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    5134:	fc 01       	movw	r30, r24
    5136:	01 90       	ld	r0, Z+
    5138:	00 20       	and	r0, r0
    513a:	e9 f7       	brne	.-6      	; 0x5136 <RemZeroLead+0x8>
    513c:	31 97       	sbiw	r30, 0x01	; 1
    513e:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    5140:	e2 30       	cpi	r30, 0x02	; 2
    5142:	d0 f1       	brcs	.+116    	; 0x51b8 <RemZeroLead+0x8a>
    5144:	88 81       	ld	r24, Y
    5146:	80 33       	cpi	r24, 0x30	; 48
    5148:	b9 f5       	brne	.+110    	; 0x51b8 <RemZeroLead+0x8a>
    514a:	4c 2f       	mov	r20, r28
    514c:	de 01       	movw	r26, r28
    514e:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    5150:	8c 91       	ld	r24, X
    5152:	80 33       	cpi	r24, 0x30	; 48
    5154:	69 f4       	brne	.+26     	; 0x5170 <RemZeroLead+0x42>
    5156:	11 96       	adiw	r26, 0x01	; 1
    5158:	8c 91       	ld	r24, X
    515a:	11 97       	sbiw	r26, 0x01	; 1
    515c:	80 33       	cpi	r24, 0x30	; 48
    515e:	11 f4       	brne	.+4      	; 0x5164 <RemZeroLead+0x36>
    5160:	9f 5f       	subi	r25, 0xFF	; 255
    5162:	06 c0       	rjmp	.+12     	; 0x5170 <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    5164:	8e 32       	cpi	r24, 0x2E	; 46
    5166:	11 f0       	breq	.+4      	; 0x516c <RemZeroLead+0x3e>
    5168:	8c 32       	cpi	r24, 0x2C	; 44
    516a:	41 f4       	brne	.+16     	; 0x517c <RemZeroLead+0x4e>
    516c:	91 50       	subi	r25, 0x01	; 1
    516e:	06 c0       	rjmp	.+12     	; 0x517c <RemZeroLead+0x4e>
    5170:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    5172:	8a 2f       	mov	r24, r26
    5174:	84 1b       	sub	r24, r20
    5176:	8e 17       	cp	r24, r30
    5178:	58 f3       	brcs	.-42     	; 0x5150 <RemZeroLead+0x22>
    517a:	01 c0       	rjmp	.+2      	; 0x517e <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    517c:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    517e:	9e 17       	cp	r25, r30
    5180:	10 f0       	brcs	.+4      	; 0x5186 <RemZeroLead+0x58>
    5182:	9e 2f       	mov	r25, r30
    5184:	91 50       	subi	r25, 0x01	; 1
    5186:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    5188:	89 2f       	mov	r24, r25
    518a:	90 e0       	ldi	r25, 0x00	; 0
    518c:	2e 2f       	mov	r18, r30
    518e:	30 e0       	ldi	r19, 0x00	; 0
    5190:	28 1b       	sub	r18, r24
    5192:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    5194:	be 01       	movw	r22, r28
    5196:	68 0f       	add	r22, r24
    5198:	79 1f       	adc	r23, r25
    519a:	09 c0       	rjmp	.+18     	; 0x51ae <RemZeroLead+0x80>
    519c:	fe 01       	movw	r30, r28
    519e:	ea 0f       	add	r30, r26
    51a0:	fb 1f       	adc	r31, r27
    51a2:	a6 0f       	add	r26, r22
    51a4:	b7 1f       	adc	r27, r23
    51a6:	8c 91       	ld	r24, X
    51a8:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    51aa:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    51ac:	4f 5f       	subi	r20, 0xFF	; 255
    51ae:	a4 2f       	mov	r26, r20
    51b0:	b0 e0       	ldi	r27, 0x00	; 0
    51b2:	a2 17       	cp	r26, r18
    51b4:	b3 07       	cpc	r27, r19
    51b6:	94 f3       	brlt	.-28     	; 0x519c <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    51b8:	df 91       	pop	r29
    51ba:	cf 91       	pop	r28
    51bc:	08 95       	ret

000051be <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    51be:	cf 93       	push	r28
    51c0:	df 93       	push	r29
    51c2:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    51c4:	fc 01       	movw	r30, r24
    51c6:	01 90       	ld	r0, Z+
    51c8:	00 20       	and	r0, r0
    51ca:	e9 f7       	brne	.-6      	; 0x51c6 <RemSpaceLead+0x8>
    51cc:	31 97       	sbiw	r30, 0x01	; 1
    51ce:	6e 2f       	mov	r22, r30
    51d0:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    51d2:	62 30       	cpi	r22, 0x02	; 2
    51d4:	e0 f1       	brcs	.+120    	; 0x524e <RemSpaceLead+0x90>
    51d6:	88 81       	ld	r24, Y
    51d8:	80 32       	cpi	r24, 0x20	; 32
    51da:	c9 f5       	brne	.+114    	; 0x524e <RemSpaceLead+0x90>
    51dc:	4c 2f       	mov	r20, r28
    51de:	fe 01       	movw	r30, r28
    51e0:	90 e0       	ldi	r25, 0x00	; 0
    51e2:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    51e4:	80 81       	ld	r24, Z
    51e6:	80 32       	cpi	r24, 0x20	; 32
    51e8:	41 f4       	brne	.+16     	; 0x51fa <RemSpaceLead+0x3c>
    51ea:	81 81       	ldd	r24, Z+1	; 0x01
    51ec:	80 32       	cpi	r24, 0x20	; 32
    51ee:	21 f4       	brne	.+8      	; 0x51f8 <RemSpaceLead+0x3a>
    51f0:	22 23       	and	r18, r18
    51f2:	19 f4       	brne	.+6      	; 0x51fa <RemSpaceLead+0x3c>
    51f4:	9f 5f       	subi	r25, 0xFF	; 255
    51f6:	01 c0       	rjmp	.+2      	; 0x51fa <RemSpaceLead+0x3c>
    51f8:	21 e0       	ldi	r18, 0x01	; 1
    51fa:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    51fc:	8e 2f       	mov	r24, r30
    51fe:	84 1b       	sub	r24, r20
    5200:	86 17       	cp	r24, r22
    5202:	80 f3       	brcs	.-32     	; 0x51e4 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    5204:	39 2f       	mov	r19, r25
    5206:	3f 5f       	subi	r19, 0xFF	; 255
    5208:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    520a:	43 2f       	mov	r20, r19
    520c:	50 e0       	ldi	r21, 0x00	; 0
    520e:	09 c0       	rjmp	.+18     	; 0x5222 <RemSpaceLead+0x64>
    5210:	fe 01       	movw	r30, r28
    5212:	e8 0f       	add	r30, r24
    5214:	f9 1f       	adc	r31, r25
    5216:	df 01       	movw	r26, r30
    5218:	a4 0f       	add	r26, r20
    521a:	b5 1f       	adc	r27, r21
    521c:	8c 91       	ld	r24, X
    521e:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    5220:	2f 5f       	subi	r18, 0xFF	; 255
    5222:	82 2f       	mov	r24, r18
    5224:	90 e0       	ldi	r25, 0x00	; 0
    5226:	fe 01       	movw	r30, r28
    5228:	01 90       	ld	r0, Z+
    522a:	00 20       	and	r0, r0
    522c:	e9 f7       	brne	.-6      	; 0x5228 <RemSpaceLead+0x6a>
    522e:	31 97       	sbiw	r30, 0x01	; 1
    5230:	ec 1b       	sub	r30, r28
    5232:	fd 0b       	sbc	r31, r29
    5234:	8e 17       	cp	r24, r30
    5236:	9f 07       	cpc	r25, r31
    5238:	58 f3       	brcs	.-42     	; 0x5210 <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    523a:	86 2f       	mov	r24, r22
    523c:	83 1b       	sub	r24, r19
    523e:	05 c0       	rjmp	.+10     	; 0x524a <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    5240:	fe 01       	movw	r30, r28
    5242:	e8 0f       	add	r30, r24
    5244:	f1 1d       	adc	r31, r1
    5246:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    5248:	8f 5f       	subi	r24, 0xFF	; 255
    524a:	86 17       	cp	r24, r22
    524c:	c8 f3       	brcs	.-14     	; 0x5240 <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    524e:	df 91       	pop	r29
    5250:	cf 91       	pop	r28
    5252:	08 95       	ret

00005254 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    5254:	0f 93       	push	r16
    5256:	1f 93       	push	r17
    5258:	cf 93       	push	r28
    525a:	df 93       	push	r29
    525c:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    525e:	dc 01       	movw	r26, r24
    5260:	0d 90       	ld	r0, X+
    5262:	00 20       	and	r0, r0
    5264:	e9 f7       	brne	.-6      	; 0x5260 <RemSpaceLag+0xc>
    5266:	11 97       	sbiw	r26, 0x01	; 1
    5268:	a8 1b       	sub	r26, r24
    526a:	b0 e0       	ldi	r27, 0x00	; 0
    526c:	20 e0       	ldi	r18, 0x00	; 0
    526e:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    5270:	6a 2f       	mov	r22, r26
    5272:	70 e0       	ldi	r23, 0x00	; 0
    5274:	8b 01       	movw	r16, r22
    5276:	01 50       	subi	r16, 0x01	; 1
    5278:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    527a:	a1 50       	subi	r26, 0x01	; 1
    527c:	16 c0       	rjmp	.+44     	; 0x52aa <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    527e:	ab 01       	movw	r20, r22
    5280:	48 1b       	sub	r20, r24
    5282:	59 0b       	sbc	r21, r25
    5284:	fe 01       	movw	r30, r28
    5286:	e4 0f       	add	r30, r20
    5288:	f5 1f       	adc	r31, r21
    528a:	32 97       	sbiw	r30, 0x02	; 2
    528c:	80 81       	ld	r24, Z
    528e:	80 32       	cpi	r24, 0x20	; 32
    5290:	89 f4       	brne	.+34     	; 0x52b4 <RemSpaceLag+0x60>
    5292:	fa 01       	movw	r30, r20
    5294:	31 97       	sbiw	r30, 0x01	; 1
    5296:	ec 0f       	add	r30, r28
    5298:	fd 1f       	adc	r31, r29
    529a:	2f 5f       	subi	r18, 0xFF	; 255
    529c:	3f 4f       	sbci	r19, 0xFF	; 255
    529e:	80 81       	ld	r24, Z
    52a0:	80 32       	cpi	r24, 0x20	; 32
    52a2:	41 f4       	brne	.+16     	; 0x52b4 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    52a4:	10 82       	st	Z, r1
    52a6:	ba 2f       	mov	r27, r26
    52a8:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    52aa:	82 2f       	mov	r24, r18
    52ac:	90 e0       	ldi	r25, 0x00	; 0
    52ae:	80 17       	cp	r24, r16
    52b0:	91 07       	cpc	r25, r17
    52b2:	2c f3       	brlt	.-54     	; 0x527e <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    52b4:	fe 01       	movw	r30, r28
    52b6:	eb 0f       	add	r30, r27
    52b8:	f1 1d       	adc	r31, r1
    52ba:	80 81       	ld	r24, Z
    52bc:	80 32       	cpi	r24, 0x20	; 32
    52be:	09 f4       	brne	.+2      	; 0x52c2 <RemSpaceLag+0x6e>
    52c0:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    52c2:	88 81       	ld	r24, Y
    52c4:	80 32       	cpi	r24, 0x20	; 32
    52c6:	09 f4       	brne	.+2      	; 0x52ca <RemSpaceLag+0x76>
    52c8:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    52ca:	fe 01       	movw	r30, r28
    52cc:	01 90       	ld	r0, Z+
    52ce:	00 20       	and	r0, r0
    52d0:	e9 f7       	brne	.-6      	; 0x52cc <RemSpaceLag+0x78>
    52d2:	31 97       	sbiw	r30, 0x01	; 1
    52d4:	ec 1b       	sub	r30, r28
    52d6:	fd 0b       	sbc	r31, r29
    52d8:	ec 0f       	add	r30, r28
    52da:	fd 1f       	adc	r31, r29
    52dc:	10 82       	st	Z, r1
}
    52de:	df 91       	pop	r29
    52e0:	cf 91       	pop	r28
    52e2:	1f 91       	pop	r17
    52e4:	0f 91       	pop	r16
    52e6:	08 95       	ret

000052e8 <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    52e8:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    52ea:	10 91 5f 0b 	lds	r17, 0x0B5F
    52ee:	20 e0       	ldi	r18, 0x00	; 0
    52f0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    52f2:	f9 01       	movw	r30, r18
    52f4:	ea 5d       	subi	r30, 0xDA	; 218
    52f6:	f4 4f       	sbci	r31, 0xF4	; 244
    52f8:	d9 01       	movw	r26, r18
    52fa:	ae 56       	subi	r26, 0x6E	; 110
    52fc:	b2 4f       	sbci	r27, 0xF2	; 242
    52fe:	95 96       	adiw	r26, 0x25	; 37
    5300:	8c 91       	ld	r24, X
    5302:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5304:	2f 5f       	subi	r18, 0xFF	; 255
    5306:	3f 4f       	sbci	r19, 0xFF	; 255
    5308:	24 31       	cpi	r18, 0x14	; 20
    530a:	31 05       	cpc	r19, r1
    530c:	91 f7       	brne	.-28     	; 0x52f2 <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    530e:	10 92 3a 0b 	sts	0x0B3A, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    5312:	82 e9       	ldi	r24, 0x92	; 146
    5314:	9d e0       	ldi	r25, 0x0D	; 13
    5316:	0e 94 df 28 	call	0x51be	; 0x51be <RemSpaceLead>
    531a:	20 e0       	ldi	r18, 0x00	; 0
    531c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    531e:	f9 01       	movw	r30, r18
    5320:	e3 5d       	subi	r30, 0xD3	; 211
    5322:	fc 4f       	sbci	r31, 0xFC	; 252
    5324:	d9 01       	movw	r26, r18
    5326:	aa 5d       	subi	r26, 0xDA	; 218
    5328:	b4 4f       	sbci	r27, 0xF4	; 244
    532a:	dc 96       	adiw	r26, 0x3c	; 60
    532c:	8c 91       	ld	r24, X
    532e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5330:	2f 5f       	subi	r18, 0xFF	; 255
    5332:	3f 4f       	sbci	r19, 0xFF	; 255
    5334:	28 32       	cpi	r18, 0x28	; 40
    5336:	31 05       	cpc	r19, r1
    5338:	91 f7       	brne	.-28     	; 0x531e <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    533a:	10 92 55 03 	sts	0x0355, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    533e:	8d e2       	ldi	r24, 0x2D	; 45
    5340:	93 e0       	ldi	r25, 0x03	; 3
    5342:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
    5346:	20 e0       	ldi	r18, 0x00	; 0
    5348:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    534a:	f9 01       	movw	r30, r18
    534c:	ec 59       	subi	r30, 0x9C	; 156
    534e:	fc 4f       	sbci	r31, 0xFC	; 252
    5350:	d9 01       	movw	r26, r18
    5352:	a2 54       	subi	r26, 0x42	; 66
    5354:	b4 4f       	sbci	r27, 0xF4	; 244
    5356:	8c 91       	ld	r24, X
    5358:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    535a:	2f 5f       	subi	r18, 0xFF	; 255
    535c:	3f 4f       	sbci	r19, 0xFF	; 255
    535e:	29 31       	cpi	r18, 0x19	; 25
    5360:	31 05       	cpc	r19, r1
    5362:	99 f7       	brne	.-26     	; 0x534a <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    5364:	10 92 7d 03 	sts	0x037D, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    5368:	84 e6       	ldi	r24, 0x64	; 100
    536a:	93 e0       	ldi	r25, 0x03	; 3
    536c:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5370:	80 91 d7 0b 	lds	r24, 0x0BD7
    5374:	80 93 ee 02 	sts	0x02EE, r24
	 }Dest[Length]=0;
    5378:	10 92 ef 02 	sts	0x02EF, r1
    537c:	20 e0       	ldi	r18, 0x00	; 0
    537e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5380:	f9 01       	movw	r30, r18
    5382:	eb 5f       	subi	r30, 0xFB	; 251
    5384:	f1 4f       	sbci	r31, 0xF1	; 241
    5386:	d9 01       	movw	r26, r18
    5388:	a8 52       	subi	r26, 0x28	; 40
    538a:	b4 4f       	sbci	r27, 0xF4	; 244
    538c:	8c 91       	ld	r24, X
    538e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5390:	2f 5f       	subi	r18, 0xFF	; 255
    5392:	3f 4f       	sbci	r19, 0xFF	; 255
    5394:	2d 30       	cpi	r18, 0x0D	; 13
    5396:	31 05       	cpc	r19, r1
    5398:	99 f7       	brne	.-26     	; 0x5380 <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    539a:	10 92 12 0e 	sts	0x0E12, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    539e:	85 e0       	ldi	r24, 0x05	; 5
    53a0:	9e e0       	ldi	r25, 0x0E	; 14
    53a2:	0e 94 df 28 	call	0x51be	; 0x51be <RemSpaceLead>
    53a6:	20 e0       	ldi	r18, 0x00	; 0
    53a8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    53aa:	f9 01       	movw	r30, r18
    53ac:	ed 5f       	subi	r30, 0xFD	; 253
    53ae:	f6 4f       	sbci	r31, 0xF6	; 246
    53b0:	d9 01       	movw	r26, r18
    53b2:	ab 51       	subi	r26, 0x1B	; 27
    53b4:	b4 4f       	sbci	r27, 0xF4	; 244
    53b6:	8c 91       	ld	r24, X
    53b8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    53ba:	2f 5f       	subi	r18, 0xFF	; 255
    53bc:	3f 4f       	sbci	r19, 0xFF	; 255
    53be:	2a 30       	cpi	r18, 0x0A	; 10
    53c0:	31 05       	cpc	r19, r1
    53c2:	99 f7       	brne	.-26     	; 0x53aa <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    53c4:	10 92 0d 09 	sts	0x090D, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    53c8:	83 e0       	ldi	r24, 0x03	; 3
    53ca:	99 e0       	ldi	r25, 0x09	; 9
    53cc:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
    53d0:	20 e0       	ldi	r18, 0x00	; 0
    53d2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    53d4:	f9 01       	movw	r30, r18
    53d6:	ee 57       	subi	r30, 0x7E	; 126
    53d8:	f8 4f       	sbci	r31, 0xF8	; 248
    53da:	d9 01       	movw	r26, r18
    53dc:	a1 51       	subi	r26, 0x11	; 17
    53de:	b4 4f       	sbci	r27, 0xF4	; 244
    53e0:	8c 91       	ld	r24, X
    53e2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    53e4:	2f 5f       	subi	r18, 0xFF	; 255
    53e6:	3f 4f       	sbci	r19, 0xFF	; 255
    53e8:	24 31       	cpi	r18, 0x14	; 20
    53ea:	31 05       	cpc	r19, r1
    53ec:	99 f7       	brne	.-26     	; 0x53d4 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    53ee:	10 92 96 07 	sts	0x0796, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    53f2:	82 e8       	ldi	r24, 0x82	; 130
    53f4:	97 e0       	ldi	r25, 0x07	; 7
    53f6:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		 uart_print(0,1,strCompName);
		 
uart_print(0,1,strCardID);
*/	
     return Result;
}
    53fa:	81 2f       	mov	r24, r17
    53fc:	8f 52       	subi	r24, 0x2F	; 47
    53fe:	1f 91       	pop	r17
    5400:	08 95       	ret

00005402 <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    5402:	20 e0       	ldi	r18, 0x00	; 0
    5404:	30 e0       	ldi	r19, 0x00	; 0
    5406:	06 c0       	rjmp	.+12     	; 0x5414 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    5408:	fc 01       	movw	r30, r24
    540a:	e2 0f       	add	r30, r18
    540c:	f3 1f       	adc	r31, r19
    540e:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    5410:	2f 5f       	subi	r18, 0xFF	; 255
    5412:	3f 4f       	sbci	r19, 0xFF	; 255
    5414:	fc 01       	movw	r30, r24
    5416:	01 90       	ld	r0, Z+
    5418:	00 20       	and	r0, r0
    541a:	e9 f7       	brne	.-6      	; 0x5416 <clearString+0x14>
    541c:	31 97       	sbiw	r30, 0x01	; 1
    541e:	e8 1b       	sub	r30, r24
    5420:	f9 0b       	sbc	r31, r25
    5422:	2e 17       	cp	r18, r30
    5424:	3f 07       	cpc	r19, r31
    5426:	80 f3       	brcs	.-32     	; 0x5408 <clearString+0x6>
	    str[i]=0;
	 }
}
    5428:	08 95       	ret

0000542a <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    542a:	bf 92       	push	r11
    542c:	cf 92       	push	r12
    542e:	df 92       	push	r13
    5430:	ef 92       	push	r14
    5432:	ff 92       	push	r15
    5434:	0f 93       	push	r16
    5436:	1f 93       	push	r17
    5438:	df 93       	push	r29
    543a:	cf 93       	push	r28
    543c:	cd b7       	in	r28, 0x3d	; 61
    543e:	de b7       	in	r29, 0x3e	; 62
    5440:	6e 97       	sbiw	r28, 0x1e	; 30
    5442:	0f b6       	in	r0, 0x3f	; 63
    5444:	f8 94       	cli
    5446:	de bf       	out	0x3e, r29	; 62
    5448:	0f be       	out	0x3f, r0	; 63
    544a:	cd bf       	out	0x3d, r28	; 61
    544c:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    544e:	fc 01       	movw	r30, r24
    5450:	01 90       	ld	r0, Z+
    5452:	00 20       	and	r0, r0
    5454:	e9 f7       	brne	.-6      	; 0x5450 <AddZeroLead+0x26>
    5456:	31 97       	sbiw	r30, 0x01	; 1
    5458:	2e 2f       	mov	r18, r30
    545a:	28 1b       	sub	r18, r24

	 if (Size>Length){
    545c:	26 17       	cp	r18, r22
    545e:	e0 f5       	brcc	.+120    	; 0x54d8 <AddZeroLead+0xae>
    5460:	7e 01       	movw	r14, r28
    5462:	08 94       	sec
    5464:	e1 1c       	adc	r14, r1
    5466:	f1 1c       	adc	r15, r1
    5468:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    546a:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    546c:	90 e3       	ldi	r25, 0x30	; 48
    546e:	01 c0       	rjmp	.+2      	; 0x5472 <AddZeroLead+0x48>
    5470:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5472:	8e 2f       	mov	r24, r30
    5474:	8b 19       	sub	r24, r11
    5476:	86 17       	cp	r24, r22
    5478:	d8 f3       	brcs	.-10     	; 0x5470 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    547a:	46 2f       	mov	r20, r22
    547c:	50 e0       	ldi	r21, 0x00	; 0
    547e:	ce 01       	movw	r24, r28
    5480:	01 96       	adiw	r24, 0x01	; 1
    5482:	fc 01       	movw	r30, r24
    5484:	e4 0f       	add	r30, r20
    5486:	f5 1f       	adc	r31, r21
    5488:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    548a:	76 2f       	mov	r23, r22
    548c:	72 1b       	sub	r23, r18
    548e:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5490:	30 e0       	ldi	r19, 0x00	; 0
    5492:	24 1b       	sub	r18, r20
    5494:	35 0b       	sbc	r19, r21
    5496:	0c c0       	rjmp	.+24     	; 0x54b0 <AddZeroLead+0x86>
    5498:	e7 2f       	mov	r30, r23
    549a:	f0 e0       	ldi	r31, 0x00	; 0
    549c:	d6 01       	movw	r26, r12
    549e:	ae 0f       	add	r26, r30
    54a0:	bf 1f       	adc	r27, r31
    54a2:	e0 0f       	add	r30, r16
    54a4:	f1 1f       	adc	r31, r17
    54a6:	e2 0f       	add	r30, r18
    54a8:	f3 1f       	adc	r31, r19
    54aa:	80 81       	ld	r24, Z
    54ac:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    54ae:	7f 5f       	subi	r23, 0xFF	; 255
    54b0:	76 17       	cp	r23, r22
    54b2:	90 f3       	brcs	.-28     	; 0x5498 <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    54b4:	4c 0d       	add	r20, r12
    54b6:	5d 1d       	adc	r21, r13
    54b8:	da 01       	movw	r26, r20
    54ba:	1c 92       	st	X, r1
    54bc:	f8 01       	movw	r30, r16
    54be:	04 c0       	rjmp	.+8      	; 0x54c8 <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    54c0:	d7 01       	movw	r26, r14
    54c2:	8d 91       	ld	r24, X+
    54c4:	7d 01       	movw	r14, r26
    54c6:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    54c8:	8e 2d       	mov	r24, r14
    54ca:	8b 19       	sub	r24, r11
    54cc:	86 17       	cp	r24, r22
    54ce:	c0 f3       	brcs	.-16     	; 0x54c0 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    54d0:	06 0f       	add	r16, r22
    54d2:	11 1d       	adc	r17, r1
    54d4:	f8 01       	movw	r30, r16
    54d6:	10 82       	st	Z, r1
	 }
}
    54d8:	6e 96       	adiw	r28, 0x1e	; 30
    54da:	0f b6       	in	r0, 0x3f	; 63
    54dc:	f8 94       	cli
    54de:	de bf       	out	0x3e, r29	; 62
    54e0:	0f be       	out	0x3f, r0	; 63
    54e2:	cd bf       	out	0x3d, r28	; 61
    54e4:	cf 91       	pop	r28
    54e6:	df 91       	pop	r29
    54e8:	1f 91       	pop	r17
    54ea:	0f 91       	pop	r16
    54ec:	ff 90       	pop	r15
    54ee:	ef 90       	pop	r14
    54f0:	df 90       	pop	r13
    54f2:	cf 90       	pop	r12
    54f4:	bf 90       	pop	r11
    54f6:	08 95       	ret

000054f8 <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    54f8:	0f 93       	push	r16
    54fa:	1f 93       	push	r17
    54fc:	cf 93       	push	r28
    54fe:	df 93       	push	r29
    5500:	18 2f       	mov	r17, r24
    5502:	06 2f       	mov	r16, r22
    5504:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    5506:	ca 01       	movw	r24, r20
    5508:	6d e0       	ldi	r22, 0x0D	; 13
    550a:	0e 94 15 2a 	call	0x542a	; 0x542a <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    550e:	81 2f       	mov	r24, r17
    5510:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
    5514:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    5516:	88 23       	and	r24, r24
    5518:	39 f0       	breq	.+14     	; 0x5528 <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    551a:	41 50       	subi	r20, 0x01	; 1
    551c:	81 e0       	ldi	r24, 0x01	; 1
    551e:	61 e0       	ldi	r22, 0x01	; 1
    5520:	20 2f       	mov	r18, r16
    5522:	8e 01       	movw	r16, r28
    5524:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    5528:	df 91       	pop	r29
    552a:	cf 91       	pop	r28
    552c:	1f 91       	pop	r17
    552e:	0f 91       	pop	r16
    5530:	08 95       	ret

00005532 <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    5532:	0f 93       	push	r16
    5534:	1f 93       	push	r17
    5536:	cf 93       	push	r28
    5538:	df 93       	push	r29
    553a:	18 2f       	mov	r17, r24
    553c:	06 2f       	mov	r16, r22
    553e:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    5540:	ca 01       	movw	r24, r20
    5542:	6b e0       	ldi	r22, 0x0B	; 11
    5544:	0e 94 15 2a 	call	0x542a	; 0x542a <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    5548:	81 2f       	mov	r24, r17
    554a:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
    554e:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    5550:	88 23       	and	r24, r24
    5552:	39 f0       	breq	.+14     	; 0x5562 <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    5554:	41 50       	subi	r20, 0x01	; 1
    5556:	80 e0       	ldi	r24, 0x00	; 0
    5558:	61 e0       	ldi	r22, 0x01	; 1
    555a:	20 2f       	mov	r18, r16
    555c:	8e 01       	movw	r16, r28
    555e:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    5562:	df 91       	pop	r29
    5564:	cf 91       	pop	r28
    5566:	1f 91       	pop	r17
    5568:	0f 91       	pop	r16
    556a:	08 95       	ret

0000556c <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    556c:	ef 92       	push	r14
    556e:	ff 92       	push	r15
    5570:	0f 93       	push	r16
    5572:	1f 93       	push	r17
    5574:	08 2f       	mov	r16, r24
    5576:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    5578:	cb 01       	movw	r24, r22
    557a:	6a e0       	ldi	r22, 0x0A	; 10
    557c:	0e 94 15 2a 	call	0x542a	; 0x542a <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    5580:	00 d0       	rcall	.+0      	; 0x5582 <GetTransactionMoney+0x16>
    5582:	00 d0       	rcall	.+0      	; 0x5584 <GetTransactionMoney+0x18>
    5584:	00 d0       	rcall	.+0      	; 0x5586 <GetTransactionMoney+0x1a>
    5586:	ed b7       	in	r30, 0x3d	; 61
    5588:	fe b7       	in	r31, 0x3e	; 62
    558a:	31 96       	adiw	r30, 0x01	; 1
    558c:	ad b7       	in	r26, 0x3d	; 61
    558e:	be b7       	in	r27, 0x3e	; 62
    5590:	12 96       	adiw	r26, 0x02	; 2
    5592:	fc 92       	st	X, r15
    5594:	ee 92       	st	-X, r14
    5596:	11 97       	sbiw	r26, 0x01	; 1
    5598:	8f ea       	ldi	r24, 0xAF	; 175
    559a:	94 e0       	ldi	r25, 0x04	; 4
    559c:	93 83       	std	Z+3, r25	; 0x03
    559e:	82 83       	std	Z+2, r24	; 0x02
    55a0:	10 e0       	ldi	r17, 0x00	; 0
    55a2:	0f 70       	andi	r16, 0x0F	; 15
    55a4:	10 70       	andi	r17, 0x00	; 0
    55a6:	85 e3       	ldi	r24, 0x35	; 53
    55a8:	90 e0       	ldi	r25, 0x00	; 0
    55aa:	9c 01       	movw	r18, r24
    55ac:	02 9f       	mul	r16, r18
    55ae:	c0 01       	movw	r24, r0
    55b0:	03 9f       	mul	r16, r19
    55b2:	90 0d       	add	r25, r0
    55b4:	12 9f       	mul	r17, r18
    55b6:	90 0d       	add	r25, r0
    55b8:	11 24       	eor	r1, r1
    55ba:	83 52       	subi	r24, 0x23	; 35
    55bc:	9a 4f       	sbci	r25, 0xFA	; 250
    55be:	95 83       	std	Z+5, r25	; 0x05
    55c0:	84 83       	std	Z+4, r24	; 0x04
    55c2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    55c6:	8d b7       	in	r24, 0x3d	; 61
    55c8:	9e b7       	in	r25, 0x3e	; 62
    55ca:	06 96       	adiw	r24, 0x06	; 6
    55cc:	0f b6       	in	r0, 0x3f	; 63
    55ce:	f8 94       	cli
    55d0:	9e bf       	out	0x3e, r25	; 62
    55d2:	0f be       	out	0x3f, r0	; 63
    55d4:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    55d6:	1f 91       	pop	r17
    55d8:	0f 91       	pop	r16
    55da:	ff 90       	pop	r15
    55dc:	ef 90       	pop	r14
    55de:	08 95       	ret

000055e0 <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    55e0:	ef 92       	push	r14
    55e2:	ff 92       	push	r15
    55e4:	0f 93       	push	r16
    55e6:	1f 93       	push	r17
    55e8:	08 2f       	mov	r16, r24
    55ea:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    55ec:	cb 01       	movw	r24, r22
    55ee:	6a e0       	ldi	r22, 0x0A	; 10
    55f0:	0e 94 15 2a 	call	0x542a	; 0x542a <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    55f4:	00 d0       	rcall	.+0      	; 0x55f6 <GetTransactionVolume+0x16>
    55f6:	00 d0       	rcall	.+0      	; 0x55f8 <GetTransactionVolume+0x18>
    55f8:	00 d0       	rcall	.+0      	; 0x55fa <GetTransactionVolume+0x1a>
    55fa:	ed b7       	in	r30, 0x3d	; 61
    55fc:	fe b7       	in	r31, 0x3e	; 62
    55fe:	31 96       	adiw	r30, 0x01	; 1
    5600:	ad b7       	in	r26, 0x3d	; 61
    5602:	be b7       	in	r27, 0x3e	; 62
    5604:	12 96       	adiw	r26, 0x02	; 2
    5606:	fc 92       	st	X, r15
    5608:	ee 92       	st	-X, r14
    560a:	11 97       	sbiw	r26, 0x01	; 1
    560c:	82 eb       	ldi	r24, 0xB2	; 178
    560e:	94 e0       	ldi	r25, 0x04	; 4
    5610:	93 83       	std	Z+3, r25	; 0x03
    5612:	82 83       	std	Z+2, r24	; 0x02
    5614:	10 e0       	ldi	r17, 0x00	; 0
    5616:	0f 70       	andi	r16, 0x0F	; 15
    5618:	10 70       	andi	r17, 0x00	; 0
    561a:	85 e3       	ldi	r24, 0x35	; 53
    561c:	90 e0       	ldi	r25, 0x00	; 0
    561e:	9c 01       	movw	r18, r24
    5620:	02 9f       	mul	r16, r18
    5622:	c0 01       	movw	r24, r0
    5624:	03 9f       	mul	r16, r19
    5626:	90 0d       	add	r25, r0
    5628:	12 9f       	mul	r17, r18
    562a:	90 0d       	add	r25, r0
    562c:	11 24       	eor	r1, r1
    562e:	8c 52       	subi	r24, 0x2C	; 44
    5630:	9a 4f       	sbci	r25, 0xFA	; 250
    5632:	95 83       	std	Z+5, r25	; 0x05
    5634:	84 83       	std	Z+4, r24	; 0x04
    5636:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    563a:	8d b7       	in	r24, 0x3d	; 61
    563c:	9e b7       	in	r25, 0x3e	; 62
    563e:	06 96       	adiw	r24, 0x06	; 6
    5640:	0f b6       	in	r0, 0x3f	; 63
    5642:	f8 94       	cli
    5644:	9e bf       	out	0x3e, r25	; 62
    5646:	0f be       	out	0x3f, r0	; 63
    5648:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    564a:	1f 91       	pop	r17
    564c:	0f 91       	pop	r16
    564e:	ff 90       	pop	r15
    5650:	ef 90       	pop	r14
    5652:	08 95       	ret

00005654 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    5654:	af 92       	push	r10
    5656:	bf 92       	push	r11
    5658:	cf 92       	push	r12
    565a:	df 92       	push	r13
    565c:	ef 92       	push	r14
    565e:	ff 92       	push	r15
    5660:	0f 93       	push	r16
    5662:	1f 93       	push	r17
    5664:	df 93       	push	r29
    5666:	cf 93       	push	r28
    5668:	cd b7       	in	r28, 0x3d	; 61
    566a:	de b7       	in	r29, 0x3e	; 62
    566c:	65 97       	sbiw	r28, 0x15	; 21
    566e:	0f b6       	in	r0, 0x3f	; 63
    5670:	f8 94       	cli
    5672:	de bf       	out	0x3e, r29	; 62
    5674:	0f be       	out	0x3f, r0	; 63
    5676:	cd bf       	out	0x3d, r28	; 61
    5678:	d8 2e       	mov	r13, r24
    567a:	c6 2e       	mov	r12, r22
    567c:	b4 2e       	mov	r11, r20
    567e:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    5680:	d8 01       	movw	r26, r16
    5682:	0d 90       	ld	r0, X+
    5684:	00 20       	and	r0, r0
    5686:	e9 f7       	brne	.-6      	; 0x5682 <SetTotalizerData+0x2e>
    5688:	11 97       	sbiw	r26, 0x01	; 1
    568a:	a0 1b       	sub	r26, r16
    568c:	b1 0b       	sbc	r27, r17
    568e:	97 e0       	ldi	r25, 0x07	; 7
    5690:	e9 2e       	mov	r14, r25
    5692:	f1 2c       	mov	r15, r1
    5694:	ec 0e       	add	r14, r28
    5696:	fd 1e       	adc	r15, r29
    5698:	ad 30       	cpi	r26, 0x0D	; 13
    569a:	b1 05       	cpc	r27, r1
    569c:	58 f5       	brcc	.+86     	; 0x56f4 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    569e:	00 d0       	rcall	.+0      	; 0x56a0 <SetTotalizerData+0x4c>
    56a0:	00 d0       	rcall	.+0      	; 0x56a2 <SetTotalizerData+0x4e>
    56a2:	00 d0       	rcall	.+0      	; 0x56a4 <SetTotalizerData+0x50>
    56a4:	ed b7       	in	r30, 0x3d	; 61
    56a6:	fe b7       	in	r31, 0x3e	; 62
    56a8:	31 96       	adiw	r30, 0x01	; 1
    56aa:	ad b7       	in	r26, 0x3d	; 61
    56ac:	be b7       	in	r27, 0x3e	; 62
    56ae:	12 96       	adiw	r26, 0x02	; 2
    56b0:	fc 92       	st	X, r15
    56b2:	ee 92       	st	-X, r14
    56b4:	11 97       	sbiw	r26, 0x01	; 1
    56b6:	84 e8       	ldi	r24, 0x84	; 132
    56b8:	96 e0       	ldi	r25, 0x06	; 6
    56ba:	93 83       	std	Z+3, r25	; 0x03
    56bc:	82 83       	std	Z+2, r24	; 0x02
    56be:	15 83       	std	Z+5, r17	; 0x05
    56c0:	04 83       	std	Z+4, r16	; 0x04
    56c2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    56c6:	f7 01       	movw	r30, r14
    56c8:	01 90       	ld	r0, Z+
    56ca:	00 20       	and	r0, r0
    56cc:	e9 f7       	brne	.-6      	; 0x56c8 <SetTotalizerData+0x74>
    56ce:	31 97       	sbiw	r30, 0x01	; 1
    56d0:	ee 19       	sub	r30, r14
    56d2:	ff 09       	sbc	r31, r15
    56d4:	6d b7       	in	r22, 0x3d	; 61
    56d6:	7e b7       	in	r23, 0x3e	; 62
    56d8:	6a 5f       	subi	r22, 0xFA	; 250
    56da:	7f 4f       	sbci	r23, 0xFF	; 255
    56dc:	0f b6       	in	r0, 0x3f	; 63
    56de:	f8 94       	cli
    56e0:	7e bf       	out	0x3e, r23	; 62
    56e2:	0f be       	out	0x3f, r0	; 63
    56e4:	6d bf       	out	0x3d, r22	; 61
    56e6:	3c 97       	sbiw	r30, 0x0c	; 12
    56e8:	a0 f4       	brcc	.+40     	; 0x5712 <SetTotalizerData+0xbe>
    56ea:	c7 01       	movw	r24, r14
    56ec:	6c e0       	ldi	r22, 0x0C	; 12
    56ee:	0e 94 15 2a 	call	0x542a	; 0x542a <AddZeroLead>
    56f2:	0f c0       	rjmp	.+30     	; 0x5712 <SetTotalizerData+0xbe>
    56f4:	8a 2f       	mov	r24, r26
    56f6:	8c 50       	subi	r24, 0x0C	; 12
    56f8:	f8 01       	movw	r30, r16
    56fa:	e8 0f       	add	r30, r24
    56fc:	f1 1d       	adc	r31, r1
    56fe:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5700:	9e 01       	movw	r18, r28
    5702:	2d 5e       	subi	r18, 0xED	; 237
    5704:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    5706:	81 91       	ld	r24, Z+
    5708:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    570a:	a2 17       	cp	r26, r18
    570c:	b3 07       	cpc	r27, r19
    570e:	d9 f7       	brne	.-10     	; 0x5706 <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    5710:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    5712:	0b 2d       	mov	r16, r11
    5714:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    5716:	1a 2d       	mov	r17, r10
    5718:	11 50       	subi	r17, 0x01	; 1
    571a:	16 30       	cpi	r17, 0x06	; 6
    571c:	08 f0       	brcs	.+2      	; 0x5720 <SetTotalizerData+0xcc>
    571e:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    5720:	ce 01       	movw	r24, r28
    5722:	07 96       	adiw	r24, 0x07	; 7
    5724:	7e 01       	movw	r14, r28
    5726:	08 94       	sec
    5728:	e1 1c       	adc	r14, r1
    572a:	f1 1c       	adc	r15, r1
    572c:	b7 01       	movw	r22, r14
    572e:	0e 94 76 19 	call	0x32ec	; 0x32ec <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    5732:	dd 20       	and	r13, r13
    5734:	d9 f4       	brne	.+54     	; 0x576c <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    5736:	84 e2       	ldi	r24, 0x24	; 36
    5738:	08 9f       	mul	r16, r24
    573a:	c0 01       	movw	r24, r0
    573c:	11 24       	eor	r1, r1
    573e:	4c 2d       	mov	r20, r12
    5740:	50 e0       	ldi	r21, 0x00	; 0
    5742:	20 e2       	ldi	r18, 0x20	; 32
    5744:	31 e0       	ldi	r19, 0x01	; 1
    5746:	d9 01       	movw	r26, r18
    5748:	4a 9f       	mul	r20, r26
    574a:	90 01       	movw	r18, r0
    574c:	4b 9f       	mul	r20, r27
    574e:	30 0d       	add	r19, r0
    5750:	5a 9f       	mul	r21, r26
    5752:	30 0d       	add	r19, r0
    5754:	11 24       	eor	r1, r1
    5756:	82 0f       	add	r24, r18
    5758:	93 1f       	adc	r25, r19
    575a:	26 e0       	ldi	r18, 0x06	; 6
    575c:	12 9f       	mul	r17, r18
    575e:	90 01       	movw	r18, r0
    5760:	11 24       	eor	r1, r1
    5762:	82 0f       	add	r24, r18
    5764:	93 1f       	adc	r25, r19
    5766:	8d 53       	subi	r24, 0x3D	; 61
    5768:	9c 4f       	sbci	r25, 0xFC	; 252
    576a:	1d c0       	rjmp	.+58     	; 0x57a6 <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    576c:	b1 e0       	ldi	r27, 0x01	; 1
    576e:	db 16       	cp	r13, r27
    5770:	09 f5       	brne	.+66     	; 0x57b4 <SetTotalizerData+0x160>
    5772:	84 e2       	ldi	r24, 0x24	; 36
    5774:	08 9f       	mul	r16, r24
    5776:	c0 01       	movw	r24, r0
    5778:	11 24       	eor	r1, r1
    577a:	4c 2d       	mov	r20, r12
    577c:	50 e0       	ldi	r21, 0x00	; 0
    577e:	20 e2       	ldi	r18, 0x20	; 32
    5780:	31 e0       	ldi	r19, 0x01	; 1
    5782:	b9 01       	movw	r22, r18
    5784:	46 9f       	mul	r20, r22
    5786:	90 01       	movw	r18, r0
    5788:	47 9f       	mul	r20, r23
    578a:	30 0d       	add	r19, r0
    578c:	56 9f       	mul	r21, r22
    578e:	30 0d       	add	r19, r0
    5790:	11 24       	eor	r1, r1
    5792:	82 0f       	add	r24, r18
    5794:	93 1f       	adc	r25, r19
    5796:	26 e0       	ldi	r18, 0x06	; 6
    5798:	12 9f       	mul	r17, r18
    579a:	90 01       	movw	r18, r0
    579c:	11 24       	eor	r1, r1
    579e:	82 0f       	add	r24, r18
    57a0:	93 1f       	adc	r25, r19
    57a2:	8d 5f       	subi	r24, 0xFD	; 253
    57a4:	99 4f       	sbci	r25, 0xF9	; 249
    57a6:	b7 01       	movw	r22, r14
    57a8:	46 e0       	ldi	r20, 0x06	; 6
    57aa:	50 e0       	ldi	r21, 0x00	; 0
    57ac:	2a e4       	ldi	r18, 0x4A	; 74
    57ae:	33 e1       	ldi	r19, 0x13	; 19
    57b0:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
}
    57b4:	65 96       	adiw	r28, 0x15	; 21
    57b6:	0f b6       	in	r0, 0x3f	; 63
    57b8:	f8 94       	cli
    57ba:	de bf       	out	0x3e, r29	; 62
    57bc:	0f be       	out	0x3f, r0	; 63
    57be:	cd bf       	out	0x3d, r28	; 61
    57c0:	cf 91       	pop	r28
    57c2:	df 91       	pop	r29
    57c4:	1f 91       	pop	r17
    57c6:	0f 91       	pop	r16
    57c8:	ff 90       	pop	r15
    57ca:	ef 90       	pop	r14
    57cc:	df 90       	pop	r13
    57ce:	cf 90       	pop	r12
    57d0:	bf 90       	pop	r11
    57d2:	af 90       	pop	r10
    57d4:	08 95       	ret

000057d6 <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    57d6:	4f 92       	push	r4
    57d8:	5f 92       	push	r5
    57da:	7f 92       	push	r7
    57dc:	8f 92       	push	r8
    57de:	9f 92       	push	r9
    57e0:	af 92       	push	r10
    57e2:	bf 92       	push	r11
    57e4:	cf 92       	push	r12
    57e6:	df 92       	push	r13
    57e8:	ef 92       	push	r14
    57ea:	ff 92       	push	r15
    57ec:	0f 93       	push	r16
    57ee:	1f 93       	push	r17
    57f0:	df 93       	push	r29
    57f2:	cf 93       	push	r28
    57f4:	cd b7       	in	r28, 0x3d	; 61
    57f6:	de b7       	in	r29, 0x3e	; 62
    57f8:	2f 97       	sbiw	r28, 0x0f	; 15
    57fa:	0f b6       	in	r0, 0x3f	; 63
    57fc:	f8 94       	cli
    57fe:	de bf       	out	0x3e, r29	; 62
    5800:	0f be       	out	0x3f, r0	; 63
    5802:	cd bf       	out	0x3d, r28	; 61
    5804:	77 24       	eor	r7, r7
    5806:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    5808:	4e 01       	movw	r8, r28
    580a:	08 94       	sec
    580c:	81 1c       	adc	r8, r1
    580e:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5810:	20 e1       	ldi	r18, 0x10	; 16
    5812:	42 2e       	mov	r4, r18
    5814:	51 2c       	mov	r5, r1
    5816:	4c 0e       	add	r4, r28
    5818:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    581a:	87 2d       	mov	r24, r7
    581c:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
		  if (FIPAddr>0){
    5820:	88 23       	and	r24, r24
    5822:	91 f1       	breq	.+100    	; 0x5888 <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    5824:	a8 2e       	mov	r10, r24
    5826:	aa 94       	dec	r10
    5828:	bb 24       	eor	r11, r11
    582a:	b3 94       	inc	r11
    582c:	2a c0       	rjmp	.+84     	; 0x5882 <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    582e:	f7 01       	movw	r30, r14
    5830:	11 92       	st	Z+, r1
    5832:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5834:	e4 15       	cp	r30, r4
    5836:	f5 05       	cpc	r31, r5
    5838:	d1 f7       	brne	.-12     	; 0x582e <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    583a:	80 e0       	ldi	r24, 0x00	; 0
    583c:	61 e0       	ldi	r22, 0x01	; 1
    583e:	4a 2d       	mov	r20, r10
    5840:	2b 2d       	mov	r18, r11
    5842:	84 01       	movw	r16, r8
    5844:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    5848:	80 e0       	ldi	r24, 0x00	; 0
    584a:	60 e0       	ldi	r22, 0x00	; 0
    584c:	4a 2d       	mov	r20, r10
    584e:	2b 2d       	mov	r18, r11
    5850:	0e 94 2a 2b 	call	0x5654	; 0x5654 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    5854:	f6 01       	movw	r30, r12
    5856:	11 92       	st	Z+, r1
    5858:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    585a:	ee 15       	cp	r30, r14
    585c:	ff 05       	cpc	r31, r15
    585e:	d1 f7       	brne	.-12     	; 0x5854 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    5860:	81 e0       	ldi	r24, 0x01	; 1
    5862:	61 e0       	ldi	r22, 0x01	; 1
    5864:	4a 2d       	mov	r20, r10
    5866:	2b 2d       	mov	r18, r11
    5868:	84 01       	movw	r16, r8
    586a:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    586e:	81 e0       	ldi	r24, 0x01	; 1
    5870:	60 e0       	ldi	r22, 0x00	; 0
    5872:	4a 2d       	mov	r20, r10
    5874:	2b 2d       	mov	r18, r11
    5876:	0e 94 2a 2b 	call	0x5654	; 0x5654 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    587a:	b3 94       	inc	r11
    587c:	f7 e0       	ldi	r31, 0x07	; 7
    587e:	bf 16       	cp	r11, r31
    5880:	19 f0       	breq	.+6      	; 0x5888 <SaveTotalizerCurrentToLast+0xb2>
    5882:	64 01       	movw	r12, r8
    5884:	74 01       	movw	r14, r8
    5886:	d3 cf       	rjmp	.-90     	; 0x582e <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    5888:	73 94       	inc	r7
    588a:	81 e1       	ldi	r24, 0x11	; 17
    588c:	78 16       	cp	r7, r24
    588e:	29 f6       	brne	.-118    	; 0x581a <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    5890:	2f 96       	adiw	r28, 0x0f	; 15
    5892:	0f b6       	in	r0, 0x3f	; 63
    5894:	f8 94       	cli
    5896:	de bf       	out	0x3e, r29	; 62
    5898:	0f be       	out	0x3f, r0	; 63
    589a:	cd bf       	out	0x3d, r28	; 61
    589c:	cf 91       	pop	r28
    589e:	df 91       	pop	r29
    58a0:	1f 91       	pop	r17
    58a2:	0f 91       	pop	r16
    58a4:	ff 90       	pop	r15
    58a6:	ef 90       	pop	r14
    58a8:	df 90       	pop	r13
    58aa:	cf 90       	pop	r12
    58ac:	bf 90       	pop	r11
    58ae:	af 90       	pop	r10
    58b0:	9f 90       	pop	r9
    58b2:	8f 90       	pop	r8
    58b4:	7f 90       	pop	r7
    58b6:	5f 90       	pop	r5
    58b8:	4f 90       	pop	r4
    58ba:	08 95       	ret

000058bc <ResetTotalizer>:
}

//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    58bc:	af 92       	push	r10
    58be:	bf 92       	push	r11
    58c0:	cf 92       	push	r12
    58c2:	df 92       	push	r13
    58c4:	ef 92       	push	r14
    58c6:	ff 92       	push	r15
    58c8:	0f 93       	push	r16
    58ca:	1f 93       	push	r17
    58cc:	df 93       	push	r29
    58ce:	cf 93       	push	r28
    58d0:	cd b7       	in	r28, 0x3d	; 61
    58d2:	de b7       	in	r29, 0x3e	; 62
    58d4:	29 97       	sbiw	r28, 0x09	; 9
    58d6:	0f b6       	in	r0, 0x3f	; 63
    58d8:	f8 94       	cli
    58da:	de bf       	out	0x3e, r29	; 62
    58dc:	0f be       	out	0x3f, r0	; 63
    58de:	cd bf       	out	0x3d, r28	; 61
    58e0:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    58e2:	00 d0       	rcall	.+0      	; 0x58e4 <ResetTotalizer+0x28>
    58e4:	00 d0       	rcall	.+0      	; 0x58e6 <ResetTotalizer+0x2a>
    58e6:	6e 01       	movw	r12, r28
    58e8:	08 94       	sec
    58ea:	c1 1c       	adc	r12, r1
    58ec:	d1 1c       	adc	r13, r1
    58ee:	ed b7       	in	r30, 0x3d	; 61
    58f0:	fe b7       	in	r31, 0x3e	; 62
    58f2:	d2 82       	std	Z+2, r13	; 0x02
    58f4:	c1 82       	std	Z+1, r12	; 0x01
    58f6:	87 e8       	ldi	r24, 0x87	; 135
    58f8:	96 e0       	ldi	r25, 0x06	; 6
    58fa:	94 83       	std	Z+4, r25	; 0x04
    58fc:	83 83       	std	Z+3, r24	; 0x03
    58fe:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    5902:	ee 24       	eor	r14, r14
    5904:	e3 94       	inc	r14
    5906:	0f 90       	pop	r0
    5908:	0f 90       	pop	r0
    590a:	0f 90       	pop	r0
    590c:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    590e:	8e 2d       	mov	r24, r14
    5910:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
		  if (FIPAddr>0){
    5914:	88 23       	and	r24, r24
    5916:	a9 f0       	breq	.+42     	; 0x5942 <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    5918:	b8 2e       	mov	r11, r24
    591a:	ba 94       	dec	r11
    591c:	ff 24       	eor	r15, r15
    591e:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    5920:	80 e0       	ldi	r24, 0x00	; 0
    5922:	6a 2d       	mov	r22, r10
    5924:	4b 2d       	mov	r20, r11
    5926:	2f 2d       	mov	r18, r15
    5928:	86 01       	movw	r16, r12
    592a:	0e 94 2a 2b 	call	0x5654	; 0x5654 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    592e:	81 e0       	ldi	r24, 0x01	; 1
    5930:	6a 2d       	mov	r22, r10
    5932:	4b 2d       	mov	r20, r11
    5934:	2f 2d       	mov	r18, r15
    5936:	0e 94 2a 2b 	call	0x5654	; 0x5654 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    593a:	f3 94       	inc	r15
    593c:	f7 e0       	ldi	r31, 0x07	; 7
    593e:	ff 16       	cp	r15, r31
    5940:	79 f7       	brne	.-34     	; 0x5920 <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    5942:	e3 94       	inc	r14
    5944:	81 e1       	ldi	r24, 0x11	; 17
    5946:	e8 16       	cp	r14, r24
    5948:	11 f7       	brne	.-60     	; 0x590e <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    594a:	29 96       	adiw	r28, 0x09	; 9
    594c:	0f b6       	in	r0, 0x3f	; 63
    594e:	f8 94       	cli
    5950:	de bf       	out	0x3e, r29	; 62
    5952:	0f be       	out	0x3f, r0	; 63
    5954:	cd bf       	out	0x3d, r28	; 61
    5956:	cf 91       	pop	r28
    5958:	df 91       	pop	r29
    595a:	1f 91       	pop	r17
    595c:	0f 91       	pop	r16
    595e:	ff 90       	pop	r15
    5960:	ef 90       	pop	r14
    5962:	df 90       	pop	r13
    5964:	cf 90       	pop	r12
    5966:	bf 90       	pop	r11
    5968:	af 90       	pop	r10
    596a:	08 95       	ret

0000596c <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    596c:	cf 93       	push	r28
    596e:	df 93       	push	r29
    5970:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5972:	dc 01       	movw	r26, r24
    5974:	0d 90       	ld	r0, X+
    5976:	00 20       	and	r0, r0
    5978:	e9 f7       	brne	.-6      	; 0x5974 <AddZeroLag+0x8>
    597a:	11 97       	sbiw	r26, 0x01	; 1
    597c:	a8 1b       	sub	r26, r24
    597e:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5980:	a6 17       	cp	r26, r22
    5982:	60 f4       	brcc	.+24     	; 0x599c <AddZeroLag+0x30>
    5984:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    5986:	90 e3       	ldi	r25, 0x30	; 48
    5988:	fe 01       	movw	r30, r28
    598a:	e8 0f       	add	r30, r24
    598c:	f1 1d       	adc	r31, r1
    598e:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5990:	8f 5f       	subi	r24, 0xFF	; 255
    5992:	86 17       	cp	r24, r22
    5994:	c8 f3       	brcs	.-14     	; 0x5988 <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    5996:	c6 0f       	add	r28, r22
    5998:	d1 1d       	adc	r29, r1
    599a:	18 82       	st	Y, r1
  }
}
    599c:	df 91       	pop	r29
    599e:	cf 91       	pop	r28
    59a0:	08 95       	ret

000059a2 <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    59a2:	3f 92       	push	r3
    59a4:	4f 92       	push	r4
    59a6:	5f 92       	push	r5
    59a8:	6f 92       	push	r6
    59aa:	7f 92       	push	r7
    59ac:	8f 92       	push	r8
    59ae:	9f 92       	push	r9
    59b0:	af 92       	push	r10
    59b2:	bf 92       	push	r11
    59b4:	cf 92       	push	r12
    59b6:	df 92       	push	r13
    59b8:	ef 92       	push	r14
    59ba:	ff 92       	push	r15
    59bc:	0f 93       	push	r16
    59be:	1f 93       	push	r17
    59c0:	df 93       	push	r29
    59c2:	cf 93       	push	r28
    59c4:	cd b7       	in	r28, 0x3d	; 61
    59c6:	de b7       	in	r29, 0x3e	; 62
    59c8:	c8 55       	subi	r28, 0x58	; 88
    59ca:	d0 40       	sbci	r29, 0x00	; 0
    59cc:	0f b6       	in	r0, 0x3f	; 63
    59ce:	f8 94       	cli
    59d0:	de bf       	out	0x3e, r29	; 62
    59d2:	0f be       	out	0x3f, r0	; 63
    59d4:	cd bf       	out	0x3d, r28	; 61
    59d6:	68 2e       	mov	r6, r24
    59d8:	67 96       	adiw	r28, 0x17	; 23
    59da:	7f af       	std	Y+63, r23	; 0x3f
    59dc:	6e af       	std	Y+62, r22	; 0x3e
    59de:	67 97       	sbiw	r28, 0x17	; 23
    59e0:	69 96       	adiw	r28, 0x19	; 25
    59e2:	5f af       	std	Y+63, r21	; 0x3f
    59e4:	4e af       	std	Y+62, r20	; 0x3e
    59e6:	69 97       	sbiw	r28, 0x19	; 25
    59e8:	59 01       	movw	r10, r18
    59ea:	fe 01       	movw	r30, r28
    59ec:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    59ee:	ce 01       	movw	r24, r28
    59f0:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    59f2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    59f4:	e8 17       	cp	r30, r24
    59f6:	f9 07       	cpc	r31, r25
    59f8:	e1 f7       	brne	.-8      	; 0x59f2 <StrCalc+0x50>
	     strMemory[i]=data;
    59fa:	ce 01       	movw	r24, r28
    59fc:	89 96       	adiw	r24, 0x29	; 41
    59fe:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5a00:	e8 17       	cp	r30, r24
    5a02:	f9 07       	cpc	r31, r25
    5a04:	e1 f7       	brne	.-8      	; 0x59fe <StrCalc+0x5c>
    5a06:	fe 01       	movw	r30, r28
    5a08:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    5a0a:	cf 01       	movw	r24, r30
    5a0c:	44 96       	adiw	r24, 0x14	; 20
    5a0e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5a10:	e8 17       	cp	r30, r24
    5a12:	f9 07       	cpc	r31, r25
    5a14:	e1 f7       	brne	.-8      	; 0x5a0e <StrCalc+0x6c>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    5a16:	00 d0       	rcall	.+0      	; 0x5a18 <StrCalc+0x76>
    5a18:	00 d0       	rcall	.+0      	; 0x5a1a <StrCalc+0x78>
    5a1a:	00 d0       	rcall	.+0      	; 0x5a1c <StrCalc+0x7a>
    5a1c:	ed b7       	in	r30, 0x3d	; 61
    5a1e:	fe b7       	in	r31, 0x3e	; 62
    5a20:	31 96       	adiw	r30, 0x01	; 1
    5a22:	8e 01       	movw	r16, r28
    5a24:	0f 5f       	subi	r16, 0xFF	; 255
    5a26:	1f 4f       	sbci	r17, 0xFF	; 255
    5a28:	ad b7       	in	r26, 0x3d	; 61
    5a2a:	be b7       	in	r27, 0x3e	; 62
    5a2c:	12 96       	adiw	r26, 0x02	; 2
    5a2e:	1c 93       	st	X, r17
    5a30:	0e 93       	st	-X, r16
    5a32:	11 97       	sbiw	r26, 0x01	; 1
    5a34:	81 e8       	ldi	r24, 0x81	; 129
    5a36:	96 e0       	ldi	r25, 0x06	; 6
    5a38:	93 83       	std	Z+3, r25	; 0x03
    5a3a:	82 83       	std	Z+2, r24	; 0x02
    5a3c:	67 96       	adiw	r28, 0x17	; 23
    5a3e:	2e ad       	ldd	r18, Y+62	; 0x3e
    5a40:	3f ad       	ldd	r19, Y+63	; 0x3f
    5a42:	67 97       	sbiw	r28, 0x17	; 23
    5a44:	35 83       	std	Z+5, r19	; 0x05
    5a46:	24 83       	std	Z+4, r18	; 0x04
    5a48:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    5a4c:	ed b7       	in	r30, 0x3d	; 61
    5a4e:	fe b7       	in	r31, 0x3e	; 62
    5a50:	31 96       	adiw	r30, 0x01	; 1
    5a52:	ce 01       	movw	r24, r28
    5a54:	45 96       	adiw	r24, 0x15	; 21
    5a56:	ad b7       	in	r26, 0x3d	; 61
    5a58:	be b7       	in	r27, 0x3e	; 62
    5a5a:	12 96       	adiw	r26, 0x02	; 2
    5a5c:	9c 93       	st	X, r25
    5a5e:	8e 93       	st	-X, r24
    5a60:	11 97       	sbiw	r26, 0x01	; 1
    5a62:	8e e7       	ldi	r24, 0x7E	; 126
    5a64:	96 e0       	ldi	r25, 0x06	; 6
    5a66:	93 83       	std	Z+3, r25	; 0x03
    5a68:	82 83       	std	Z+2, r24	; 0x02
    5a6a:	69 96       	adiw	r28, 0x19	; 25
    5a6c:	2e ad       	ldd	r18, Y+62	; 0x3e
    5a6e:	3f ad       	ldd	r19, Y+63	; 0x3f
    5a70:	69 97       	sbiw	r28, 0x19	; 25
    5a72:	35 83       	std	Z+5, r19	; 0x05
    5a74:	24 83       	std	Z+4, r18	; 0x04
    5a76:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>

     if (IsMinus(tmpA)==True){
    5a7a:	8d b7       	in	r24, 0x3d	; 61
    5a7c:	9e b7       	in	r25, 0x3e	; 62
    5a7e:	06 96       	adiw	r24, 0x06	; 6
    5a80:	0f b6       	in	r0, 0x3f	; 63
    5a82:	f8 94       	cli
    5a84:	9e bf       	out	0x3e, r25	; 62
    5a86:	0f be       	out	0x3f, r0	; 63
    5a88:	8d bf       	out	0x3d, r24	; 61
    5a8a:	c8 01       	movw	r24, r16
    5a8c:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <IsMinus>
    5a90:	81 30       	cpi	r24, 0x01	; 1
    5a92:	21 f0       	breq	.+8      	; 0x5a9c <StrCalc+0xfa>
    5a94:	65 96       	adiw	r28, 0x15	; 21
    5a96:	1f ae       	std	Y+63, r1	; 0x3f
    5a98:	65 97       	sbiw	r28, 0x15	; 21
    5a9a:	07 c0       	rjmp	.+14     	; 0x5aaa <StrCalc+0x108>
	     RemoveMinus(tmpA);
    5a9c:	c8 01       	movw	r24, r16
    5a9e:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <RemoveMinus>
    5aa2:	91 e0       	ldi	r25, 0x01	; 1
    5aa4:	65 96       	adiw	r28, 0x15	; 21
    5aa6:	9f af       	std	Y+63, r25	; 0x3f
    5aa8:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    5aaa:	8e 01       	movw	r16, r28
    5aac:	0b 5e       	subi	r16, 0xEB	; 235
    5aae:	1f 4f       	sbci	r17, 0xFF	; 255
    5ab0:	c8 01       	movw	r24, r16
    5ab2:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <IsMinus>
    5ab6:	81 30       	cpi	r24, 0x01	; 1
    5ab8:	21 f0       	breq	.+8      	; 0x5ac2 <StrCalc+0x120>
    5aba:	64 96       	adiw	r28, 0x14	; 20
    5abc:	1f ae       	std	Y+63, r1	; 0x3f
    5abe:	64 97       	sbiw	r28, 0x14	; 20
    5ac0:	07 c0       	rjmp	.+14     	; 0x5ad0 <StrCalc+0x12e>
	     RemoveMinus(tmpB);
    5ac2:	c8 01       	movw	r24, r16
    5ac4:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <RemoveMinus>
    5ac8:	a1 e0       	ldi	r26, 0x01	; 1
    5aca:	64 96       	adiw	r28, 0x14	; 20
    5acc:	af af       	std	Y+63, r26	; 0x3f
    5ace:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    5ad0:	fe 01       	movw	r30, r28
    5ad2:	31 96       	adiw	r30, 0x01	; 1
    5ad4:	df 01       	movw	r26, r30
    5ad6:	0d 90       	ld	r0, X+
    5ad8:	00 20       	and	r0, r0
    5ada:	e9 f7       	brne	.-6      	; 0x5ad6 <StrCalc+0x134>
    5adc:	cd 01       	movw	r24, r26
    5ade:	01 97       	sbiw	r24, 0x01	; 1
    5ae0:	8e 1b       	sub	r24, r30
    5ae2:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    5ae4:	de 01       	movw	r26, r28
    5ae6:	55 96       	adiw	r26, 0x15	; 21
    5ae8:	fd 01       	movw	r30, r26
    5aea:	01 90       	ld	r0, Z+
    5aec:	00 20       	and	r0, r0
    5aee:	e9 f7       	brne	.-6      	; 0x5aea <StrCalc+0x148>
    5af0:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    5af2:	1e 2f       	mov	r17, r30
    5af4:	1a 1b       	sub	r17, r26
    5af6:	18 17       	cp	r17, r24
    5af8:	08 f4       	brcc	.+2      	; 0x5afc <StrCalc+0x15a>
    5afa:	18 2f       	mov	r17, r24
    5afc:	1f 5f       	subi	r17, 0xFF	; 255
    5afe:	7e 01       	movw	r14, r28
    5b00:	08 94       	sec
    5b02:	e1 1c       	adc	r14, r1
    5b04:	f1 1c       	adc	r15, r1
    5b06:	c7 01       	movw	r24, r14
    5b08:	61 2f       	mov	r22, r17
    5b0a:	0e 94 15 2a 	call	0x542a	; 0x542a <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    5b0e:	f5 e1       	ldi	r31, 0x15	; 21
    5b10:	cf 2e       	mov	r12, r31
    5b12:	d1 2c       	mov	r13, r1
    5b14:	cc 0e       	add	r12, r28
    5b16:	dd 1e       	adc	r13, r29
    5b18:	c6 01       	movw	r24, r12
    5b1a:	61 2f       	mov	r22, r17
    5b1c:	0e 94 15 2a 	call	0x542a	; 0x542a <AddZeroLead>
	 uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    5b20:	f7 01       	movw	r30, r14
    5b22:	01 90       	ld	r0, Z+
    5b24:	00 20       	and	r0, r0
    5b26:	e9 f7       	brne	.-6      	; 0x5b22 <StrCalc+0x180>
    5b28:	31 97       	sbiw	r30, 0x01	; 1
    5b2a:	7e 2e       	mov	r7, r30
    5b2c:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    5b2e:	f6 01       	movw	r30, r12
    5b30:	01 90       	ld	r0, Z+
    5b32:	00 20       	and	r0, r0
    5b34:	e9 f7       	brne	.-6      	; 0x5b30 <StrCalc+0x18e>
    5b36:	31 97       	sbiw	r30, 0x01	; 1
    5b38:	9e 2e       	mov	r9, r30
    5b3a:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    5b3c:	c6 01       	movw	r24, r12
    5b3e:	b7 01       	movw	r22, r14
    5b40:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <IsMoreThan>
    5b44:	81 30       	cpi	r24, 0x01	; 1
    5b46:	11 f0       	breq	.+4      	; 0x5b4c <StrCalc+0x1aa>
    5b48:	80 e0       	ldi	r24, 0x00	; 0
    5b4a:	42 c0       	rjmp	.+132    	; 0x5bd0 <StrCalc+0x22e>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    5b4c:	00 d0       	rcall	.+0      	; 0x5b4e <StrCalc+0x1ac>
    5b4e:	00 d0       	rcall	.+0      	; 0x5b50 <StrCalc+0x1ae>
    5b50:	00 d0       	rcall	.+0      	; 0x5b52 <StrCalc+0x1b0>
    5b52:	ed b7       	in	r30, 0x3d	; 61
    5b54:	fe b7       	in	r31, 0x3e	; 62
    5b56:	31 96       	adiw	r30, 0x01	; 1
    5b58:	8e 01       	movw	r16, r28
    5b5a:	07 5d       	subi	r16, 0xD7	; 215
    5b5c:	1f 4f       	sbci	r17, 0xFF	; 255
    5b5e:	ad b7       	in	r26, 0x3d	; 61
    5b60:	be b7       	in	r27, 0x3e	; 62
    5b62:	12 96       	adiw	r26, 0x02	; 2
    5b64:	1c 93       	st	X, r17
    5b66:	0e 93       	st	-X, r16
    5b68:	11 97       	sbiw	r26, 0x01	; 1
    5b6a:	8b e7       	ldi	r24, 0x7B	; 123
    5b6c:	96 e0       	ldi	r25, 0x06	; 6
    5b6e:	93 83       	std	Z+3, r25	; 0x03
    5b70:	82 83       	std	Z+2, r24	; 0x02
    5b72:	f5 82       	std	Z+5, r15	; 0x05
    5b74:	e4 82       	std	Z+4, r14	; 0x04
    5b76:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    5b7a:	ed b7       	in	r30, 0x3d	; 61
    5b7c:	fe b7       	in	r31, 0x3e	; 62
    5b7e:	31 96       	adiw	r30, 0x01	; 1
    5b80:	ad b7       	in	r26, 0x3d	; 61
    5b82:	be b7       	in	r27, 0x3e	; 62
    5b84:	12 96       	adiw	r26, 0x02	; 2
    5b86:	fc 92       	st	X, r15
    5b88:	ee 92       	st	-X, r14
    5b8a:	11 97       	sbiw	r26, 0x01	; 1
    5b8c:	88 e7       	ldi	r24, 0x78	; 120
    5b8e:	96 e0       	ldi	r25, 0x06	; 6
    5b90:	93 83       	std	Z+3, r25	; 0x03
    5b92:	82 83       	std	Z+2, r24	; 0x02
    5b94:	d5 82       	std	Z+5, r13	; 0x05
    5b96:	c4 82       	std	Z+4, r12	; 0x04
    5b98:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    5b9c:	ed b7       	in	r30, 0x3d	; 61
    5b9e:	fe b7       	in	r31, 0x3e	; 62
    5ba0:	31 96       	adiw	r30, 0x01	; 1
    5ba2:	ad b7       	in	r26, 0x3d	; 61
    5ba4:	be b7       	in	r27, 0x3e	; 62
    5ba6:	12 96       	adiw	r26, 0x02	; 2
    5ba8:	dc 92       	st	X, r13
    5baa:	ce 92       	st	-X, r12
    5bac:	11 97       	sbiw	r26, 0x01	; 1
    5bae:	85 e7       	ldi	r24, 0x75	; 117
    5bb0:	96 e0       	ldi	r25, 0x06	; 6
    5bb2:	93 83       	std	Z+3, r25	; 0x03
    5bb4:	82 83       	std	Z+2, r24	; 0x02
    5bb6:	15 83       	std	Z+5, r17	; 0x05
    5bb8:	04 83       	std	Z+4, r16	; 0x04
    5bba:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    5bbe:	81 e0       	ldi	r24, 0x01	; 1
    5bc0:	ed b7       	in	r30, 0x3d	; 61
    5bc2:	fe b7       	in	r31, 0x3e	; 62
    5bc4:	36 96       	adiw	r30, 0x06	; 6
    5bc6:	0f b6       	in	r0, 0x3f	; 63
    5bc8:	f8 94       	cli
    5bca:	fe bf       	out	0x3e, r31	; 62
    5bcc:	0f be       	out	0x3f, r0	; 63
    5bce:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    5bd0:	66 20       	and	r6, r6
    5bd2:	39 f5       	brne	.+78     	; 0x5c22 <StrCalc+0x280>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5bd4:	81 30       	cpi	r24, 0x01	; 1
    5bd6:	99 f4       	brne	.+38     	; 0x5bfe <StrCalc+0x25c>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    5bd8:	65 96       	adiw	r28, 0x15	; 21
    5bda:	ff ad       	ldd	r31, Y+63	; 0x3f
    5bdc:	65 97       	sbiw	r28, 0x15	; 21
    5bde:	f1 30       	cpi	r31, 0x01	; 1
    5be0:	39 f4       	brne	.+14     	; 0x5bf0 <StrCalc+0x24e>
    5be2:	64 96       	adiw	r28, 0x14	; 20
    5be4:	2f ad       	ldd	r18, Y+63	; 0x3f
    5be6:	64 97       	sbiw	r28, 0x14	; 20
    5be8:	21 30       	cpi	r18, 0x01	; 1
    5bea:	09 f0       	breq	.+2      	; 0x5bee <StrCalc+0x24c>
    5bec:	9e c1       	rjmp	.+828    	; 0x5f2a <StrCalc+0x588>
    5bee:	42 c0       	rjmp	.+132    	; 0x5c74 <StrCalc+0x2d2>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    5bf0:	64 96       	adiw	r28, 0x14	; 20
    5bf2:	3f ad       	ldd	r19, Y+63	; 0x3f
    5bf4:	64 97       	sbiw	r28, 0x14	; 20
    5bf6:	31 30       	cpi	r19, 0x01	; 1
    5bf8:	09 f0       	breq	.+2      	; 0x5bfc <StrCalc+0x25a>
    5bfa:	8e c1       	rjmp	.+796    	; 0x5f18 <StrCalc+0x576>
    5bfc:	92 c1       	rjmp	.+804    	; 0x5f22 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5bfe:	65 96       	adiw	r28, 0x15	; 21
    5c00:	8f ad       	ldd	r24, Y+63	; 0x3f
    5c02:	65 97       	sbiw	r28, 0x15	; 21
    5c04:	81 30       	cpi	r24, 0x01	; 1
    5c06:	39 f4       	brne	.+14     	; 0x5c16 <StrCalc+0x274>
    5c08:	64 96       	adiw	r28, 0x14	; 20
    5c0a:	9f ad       	ldd	r25, Y+63	; 0x3f
    5c0c:	64 97       	sbiw	r28, 0x14	; 20
    5c0e:	91 30       	cpi	r25, 0x01	; 1
    5c10:	09 f0       	breq	.+2      	; 0x5c14 <StrCalc+0x272>
    5c12:	8b c1       	rjmp	.+790    	; 0x5f2a <StrCalc+0x588>
    5c14:	81 c1       	rjmp	.+770    	; 0x5f18 <StrCalc+0x576>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    5c16:	64 96       	adiw	r28, 0x14	; 20
    5c18:	af ad       	ldd	r26, Y+63	; 0x3f
    5c1a:	64 97       	sbiw	r28, 0x14	; 20
    5c1c:	a1 30       	cpi	r26, 0x01	; 1
    5c1e:	51 f5       	brne	.+84     	; 0x5c74 <StrCalc+0x2d2>
    5c20:	80 c1       	rjmp	.+768    	; 0x5f22 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    5c22:	b1 e0       	ldi	r27, 0x01	; 1
    5c24:	6b 16       	cp	r6, r27
    5c26:	31 f5       	brne	.+76     	; 0x5c74 <StrCalc+0x2d2>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5c28:	81 30       	cpi	r24, 0x01	; 1
    5c2a:	91 f4       	brne	.+36     	; 0x5c50 <StrCalc+0x2ae>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5c2c:	65 96       	adiw	r28, 0x15	; 21
    5c2e:	ef ad       	ldd	r30, Y+63	; 0x3f
    5c30:	65 97       	sbiw	r28, 0x15	; 21
    5c32:	e1 30       	cpi	r30, 0x01	; 1
    5c34:	31 f4       	brne	.+12     	; 0x5c42 <StrCalc+0x2a0>
    5c36:	64 96       	adiw	r28, 0x14	; 20
    5c38:	ff ad       	ldd	r31, Y+63	; 0x3f
    5c3a:	64 97       	sbiw	r28, 0x14	; 20
    5c3c:	f1 30       	cpi	r31, 0x01	; 1
    5c3e:	d1 f4       	brne	.+52     	; 0x5c74 <StrCalc+0x2d2>
    5c40:	74 c1       	rjmp	.+744    	; 0x5f2a <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5c42:	64 96       	adiw	r28, 0x14	; 20
    5c44:	2f ad       	ldd	r18, Y+63	; 0x3f
    5c46:	64 97       	sbiw	r28, 0x14	; 20
    5c48:	21 30       	cpi	r18, 0x01	; 1
    5c4a:	09 f0       	breq	.+2      	; 0x5c4e <StrCalc+0x2ac>
    5c4c:	6a c1       	rjmp	.+724    	; 0x5f22 <StrCalc+0x580>
    5c4e:	64 c1       	rjmp	.+712    	; 0x5f18 <StrCalc+0x576>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5c50:	65 96       	adiw	r28, 0x15	; 21
    5c52:	3f ad       	ldd	r19, Y+63	; 0x3f
    5c54:	65 97       	sbiw	r28, 0x15	; 21
    5c56:	31 30       	cpi	r19, 0x01	; 1
    5c58:	39 f4       	brne	.+14     	; 0x5c68 <StrCalc+0x2c6>
    5c5a:	64 96       	adiw	r28, 0x14	; 20
    5c5c:	8f ad       	ldd	r24, Y+63	; 0x3f
    5c5e:	64 97       	sbiw	r28, 0x14	; 20
    5c60:	81 30       	cpi	r24, 0x01	; 1
    5c62:	09 f0       	breq	.+2      	; 0x5c66 <StrCalc+0x2c4>
    5c64:	59 c1       	rjmp	.+690    	; 0x5f18 <StrCalc+0x576>
    5c66:	61 c1       	rjmp	.+706    	; 0x5f2a <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    5c68:	64 96       	adiw	r28, 0x14	; 20
    5c6a:	9f ad       	ldd	r25, Y+63	; 0x3f
    5c6c:	64 97       	sbiw	r28, 0x14	; 20
    5c6e:	91 30       	cpi	r25, 0x01	; 1
    5c70:	09 f0       	breq	.+2      	; 0x5c74 <StrCalc+0x2d2>
    5c72:	57 c1       	rjmp	.+686    	; 0x5f22 <StrCalc+0x580>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    5c74:	62 96       	adiw	r28, 0x12	; 18
    5c76:	1f ae       	std	Y+63, r1	; 0x3f
    5c78:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    5c7a:	e7 2c       	mov	r14, r7
    5c7c:	ff 24       	eor	r15, r15
    5c7e:	67 01       	movw	r12, r14
    5c80:	08 94       	sec
    5c82:	c1 08       	sbc	r12, r1
    5c84:	d1 08       	sbc	r13, r1
    5c86:	ae 01       	movw	r20, r28
    5c88:	43 5c       	subi	r20, 0xC3	; 195
    5c8a:	5f 4f       	sbci	r21, 0xFF	; 255
    5c8c:	4c 0d       	add	r20, r12
    5c8e:	5d 1d       	adc	r21, r13
    5c90:	ce 01       	movw	r24, r28
    5c92:	01 96       	adiw	r24, 0x01	; 1
    5c94:	8c 01       	movw	r16, r24
    5c96:	0c 0d       	add	r16, r12
    5c98:	1d 1d       	adc	r17, r13
    5c9a:	be 01       	movw	r22, r28
    5c9c:	69 0d       	add	r22, r9
    5c9e:	71 1d       	adc	r23, r1
    5ca0:	6c 5e       	subi	r22, 0xEC	; 236
    5ca2:	7f 4f       	sbci	r23, 0xFF	; 255
    5ca4:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    5ca6:	2c 01       	movw	r4, r24
    5ca8:	e9 e3       	ldi	r30, 0x39	; 57
    5caa:	8e 2e       	mov	r8, r30
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5cac:	9a e0       	ldi	r25, 0x0A	; 10
    5cae:	52 c0       	rjmp	.+164    	; 0x5d54 <StrCalc+0x3b2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5cb0:	d8 01       	movw	r26, r16
    5cb2:	8c 91       	ld	r24, X
    5cb4:	80 53       	subi	r24, 0x30	; 48
    5cb6:	8a 30       	cpi	r24, 0x0A	; 10
    5cb8:	10 f0       	brcs	.+4      	; 0x5cbe <StrCalc+0x31c>
    5cba:	20 e0       	ldi	r18, 0x00	; 0
    5cbc:	01 c0       	rjmp	.+2      	; 0x5cc0 <StrCalc+0x31e>
    5cbe:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    5cc0:	fb 01       	movw	r30, r22
    5cc2:	30 81       	ld	r19, Z
    5cc4:	30 53       	subi	r19, 0x30	; 48
    5cc6:	3a 30       	cpi	r19, 0x0A	; 10
    5cc8:	10 f4       	brcc	.+4      	; 0x5cce <StrCalc+0x32c>
    5cca:	23 17       	cp	r18, r19
    5ccc:	40 f0       	brcs	.+16     	; 0x5cde <StrCalc+0x33c>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5cce:	8a 30       	cpi	r24, 0x0A	; 10
    5cd0:	08 f0       	brcs	.+2      	; 0x5cd4 <StrCalc+0x332>
    5cd2:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5cd4:	3a 30       	cpi	r19, 0x0A	; 10
    5cd6:	08 f0       	brcs	.+2      	; 0x5cda <StrCalc+0x338>
    5cd8:	30 e0       	ldi	r19, 0x00	; 0
    5cda:	83 1b       	sub	r24, r19
    5cdc:	2d c0       	rjmp	.+90     	; 0x5d38 <StrCalc+0x396>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5cde:	8a 30       	cpi	r24, 0x0A	; 10
    5ce0:	10 f4       	brcc	.+4      	; 0x5ce6 <StrCalc+0x344>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    5ce2:	83 17       	cp	r24, r19
    5ce4:	80 f5       	brcc	.+96     	; 0x5d46 <StrCalc+0x3a4>
    5ce6:	29 2d       	mov	r18, r9
    5ce8:	0a c0       	rjmp	.+20     	; 0x5cfe <StrCalc+0x35c>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    5cea:	f6 01       	movw	r30, r12
    5cec:	e2 1b       	sub	r30, r18
    5cee:	f1 09       	sbc	r31, r1
    5cf0:	d2 01       	movw	r26, r4
    5cf2:	ae 0f       	add	r26, r30
    5cf4:	bf 1f       	adc	r27, r31
    5cf6:	8c 91       	ld	r24, X
    5cf8:	80 33       	cpi	r24, 0x30	; 48
    5cfa:	29 f4       	brne	.+10     	; 0x5d06 <StrCalc+0x364>
    5cfc:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    5cfe:	2f 5f       	subi	r18, 0xFF	; 255
    5d00:	27 15       	cp	r18, r7
    5d02:	98 f3       	brcs	.-26     	; 0x5cea <StrCalc+0x348>
    5d04:	10 c0       	rjmp	.+32     	; 0x5d26 <StrCalc+0x384>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5d06:	28 2f       	mov	r18, r24
    5d08:	20 53       	subi	r18, 0x30	; 48
    5d0a:	2a 30       	cpi	r18, 0x0A	; 10
    5d0c:	08 f0       	brcs	.+2      	; 0x5d10 <StrCalc+0x36e>
    5d0e:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5d10:	82 2f       	mov	r24, r18
    5d12:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5d14:	8a 30       	cpi	r24, 0x0A	; 10
    5d16:	10 f0       	brcs	.+4      	; 0x5d1c <StrCalc+0x37a>
    5d18:	80 e3       	ldi	r24, 0x30	; 48
    5d1a:	02 c0       	rjmp	.+4      	; 0x5d20 <StrCalc+0x37e>
	    Result='0'+X;
    5d1c:	82 2f       	mov	r24, r18
    5d1e:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5d20:	e4 0d       	add	r30, r4
    5d22:	f5 1d       	adc	r31, r5
    5d24:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5d26:	f8 01       	movw	r30, r16
    5d28:	20 81       	ld	r18, Z
    5d2a:	20 53       	subi	r18, 0x30	; 48
    5d2c:	2a 30       	cpi	r18, 0x0A	; 10
    5d2e:	08 f0       	brcs	.+2      	; 0x5d32 <StrCalc+0x390>
    5d30:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5d32:	89 2f       	mov	r24, r25
    5d34:	83 1b       	sub	r24, r19
    5d36:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5d38:	8a 30       	cpi	r24, 0x0A	; 10
    5d3a:	10 f0       	brcs	.+4      	; 0x5d40 <StrCalc+0x39e>
    5d3c:	80 e3       	ldi	r24, 0x30	; 48
    5d3e:	01 c0       	rjmp	.+2      	; 0x5d42 <StrCalc+0x3a0>
	    Result='0'+X;
    5d40:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5d42:	da 01       	movw	r26, r20
    5d44:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    5d46:	93 94       	inc	r9
    5d48:	41 50       	subi	r20, 0x01	; 1
    5d4a:	50 40       	sbci	r21, 0x00	; 0
    5d4c:	01 50       	subi	r16, 0x01	; 1
    5d4e:	10 40       	sbci	r17, 0x00	; 0
    5d50:	61 50       	subi	r22, 0x01	; 1
    5d52:	70 40       	sbci	r23, 0x00	; 0
    5d54:	97 14       	cp	r9, r7
    5d56:	08 f4       	brcc	.+2      	; 0x5d5a <StrCalc+0x3b8>
    5d58:	ab cf       	rjmp	.-170    	; 0x5cb0 <StrCalc+0x30e>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    5d5a:	8e 01       	movw	r16, r28
    5d5c:	03 5c       	subi	r16, 0xC3	; 195
    5d5e:	1f 4f       	sbci	r17, 0xFF	; 255
    5d60:	e0 0e       	add	r14, r16
    5d62:	f1 1e       	adc	r15, r17
    5d64:	f7 01       	movw	r30, r14
    5d66:	10 82       	st	Z, r1
       RemZeroLead(Result);
    5d68:	c8 01       	movw	r24, r16
    5d6a:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    5d6e:	f8 01       	movw	r30, r16
    5d70:	01 90       	ld	r0, Z+
    5d72:	00 20       	and	r0, r0
    5d74:	e9 f7       	brne	.-6      	; 0x5d70 <StrCalc+0x3ce>
    5d76:	31 97       	sbiw	r30, 0x01	; 1
    5d78:	3e 2f       	mov	r19, r30
    5d7a:	30 1b       	sub	r19, r16
    5d7c:	d8 01       	movw	r26, r16
    5d7e:	20 e0       	ldi	r18, 0x00	; 0
    5d80:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    5d82:	4d e2       	ldi	r20, 0x2D	; 45
    5d84:	13 c0       	rjmp	.+38     	; 0x5dac <StrCalc+0x40a>
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    5d86:	22 23       	and	r18, r18
    5d88:	51 f4       	brne	.+20     	; 0x5d9e <StrCalc+0x3fc>
    5d8a:	62 96       	adiw	r28, 0x12	; 18
    5d8c:	ff ad       	ldd	r31, Y+63	; 0x3f
    5d8e:	62 97       	sbiw	r28, 0x12	; 18
    5d90:	f1 30       	cpi	r31, 0x01	; 1
    5d92:	29 f4       	brne	.+10     	; 0x5d9e <StrCalc+0x3fc>
			     strC[iPos]='-';
    5d94:	f5 01       	movw	r30, r10
    5d96:	e9 0f       	add	r30, r25
    5d98:	f1 1d       	adc	r31, r1
    5d9a:	40 83       	st	Z, r20
				 iPos++;
    5d9c:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    5d9e:	f5 01       	movw	r30, r10
    5da0:	e9 0f       	add	r30, r25
    5da2:	f1 1d       	adc	r31, r1
    5da4:	8d 91       	ld	r24, X+
    5da6:	80 83       	st	Z, r24
			 iPos++;
    5da8:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5daa:	2f 5f       	subi	r18, 0xFF	; 255
    5dac:	23 17       	cp	r18, r19
    5dae:	58 f3       	brcs	.-42     	; 0x5d86 <StrCalc+0x3e4>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    5db0:	f5 01       	movw	r30, r10
    5db2:	e9 0f       	add	r30, r25
    5db4:	f1 1d       	adc	r31, r1
    5db6:	10 82       	st	Z, r1
    5db8:	a0 c0       	rjmp	.+320    	; 0x5efa <StrCalc+0x558>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    5dba:	7d e3       	ldi	r23, 0x3D	; 61
    5dbc:	e7 2e       	mov	r14, r23
    5dbe:	f1 2c       	mov	r15, r1
    5dc0:	ec 0e       	add	r14, r28
    5dc2:	fd 1e       	adc	r15, r29
    5dc4:	ae 01       	movw	r20, r28
    5dc6:	49 0d       	add	r20, r9
    5dc8:	51 1d       	adc	r21, r1
    5dca:	4c 5e       	subi	r20, 0xEC	; 236
    5dcc:	5f 4f       	sbci	r21, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    5dce:	07 2d       	mov	r16, r7
    5dd0:	10 e0       	ldi	r17, 0x00	; 0
    5dd2:	48 01       	movw	r8, r16
    5dd4:	08 94       	sec
    5dd6:	81 08       	sbc	r8, r1
    5dd8:	91 08       	sbc	r9, r1
    5dda:	ce 01       	movw	r24, r28
    5ddc:	01 96       	adiw	r24, 0x01	; 1
    5dde:	6c 01       	movw	r12, r24
    5de0:	c8 0c       	add	r12, r8
    5de2:	d9 1c       	adc	r13, r9
    5de4:	30 e0       	ldi	r19, 0x00	; 0
    5de6:	20 e0       	ldi	r18, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5de8:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5dea:	60 e3       	ldi	r22, 0x30	; 48
    5dec:	36 2e       	mov	r3, r22
    5dee:	47 c0       	rjmp	.+142    	; 0x5e7e <StrCalc+0x4dc>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5df0:	d6 01       	movw	r26, r12
    5df2:	9c 91       	ld	r25, X
    5df4:	90 53       	subi	r25, 0x30	; 48
    5df6:	9a 30       	cpi	r25, 0x0A	; 10
    5df8:	08 f0       	brcs	.+2      	; 0x5dfc <StrCalc+0x45a>
    5dfa:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    5dfc:	fa 01       	movw	r30, r20
    5dfe:	80 81       	ld	r24, Z
    5e00:	80 53       	subi	r24, 0x30	; 48
    5e02:	8a 30       	cpi	r24, 0x0A	; 10
    5e04:	08 f0       	brcs	.+2      	; 0x5e08 <StrCalc+0x466>
    5e06:	80 e0       	ldi	r24, 0x00	; 0
    5e08:	89 0f       	add	r24, r25
			 if (newC<10){
    5e0a:	8a 30       	cpi	r24, 0x0A	; 10
    5e0c:	18 f4       	brcc	.+6      	; 0x5e14 <StrCalc+0x472>
			     Result[i]=Chr(newC);
    5e0e:	80 5d       	subi	r24, 0xD0	; 208
    5e10:	d7 01       	movw	r26, r14
    5e12:	28 c0       	rjmp	.+80     	; 0x5e64 <StrCalc+0x4c2>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5e14:	6a e0       	ldi	r22, 0x0A	; 10
    5e16:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5e1a:	9a 30       	cpi	r25, 0x0A	; 10
    5e1c:	10 f0       	brcs	.+4      	; 0x5e22 <StrCalc+0x480>
    5e1e:	90 e3       	ldi	r25, 0x30	; 48
    5e20:	01 c0       	rjmp	.+2      	; 0x5e24 <StrCalc+0x482>
	    Result='0'+X;
    5e22:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5e24:	f7 01       	movw	r30, r14
    5e26:	90 83       	st	Z, r25
    5e28:	83 2f       	mov	r24, r19
    5e2a:	0e c0       	rjmp	.+28     	; 0x5e48 <StrCalc+0x4a6>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5e2c:	d4 01       	movw	r26, r8
    5e2e:	a8 1b       	sub	r26, r24
    5e30:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5e32:	f2 01       	movw	r30, r4
    5e34:	ea 0f       	add	r30, r26
    5e36:	fb 1f       	adc	r31, r27
    5e38:	90 81       	ld	r25, Z
    5e3a:	90 53       	subi	r25, 0x30	; 48
    5e3c:	9a 30       	cpi	r25, 0x0A	; 10
    5e3e:	08 f0       	brcs	.+2      	; 0x5e42 <StrCalc+0x4a0>
    5e40:	79 c0       	rjmp	.+242    	; 0x5f34 <StrCalc+0x592>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5e42:	99 30       	cpi	r25, 0x09	; 9
    5e44:	29 f4       	brne	.+10     	; 0x5e50 <StrCalc+0x4ae>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5e46:	30 82       	st	Z, r3
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    5e48:	8f 5f       	subi	r24, 0xFF	; 255
    5e4a:	87 15       	cp	r24, r7
    5e4c:	78 f3       	brcs	.-34     	; 0x5e2c <StrCalc+0x48a>
    5e4e:	0d c0       	rjmp	.+26     	; 0x5e6a <StrCalc+0x4c8>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5e50:	89 2f       	mov	r24, r25
    5e52:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5e54:	8a 30       	cpi	r24, 0x0A	; 10
    5e56:	10 f0       	brcs	.+4      	; 0x5e5c <StrCalc+0x4ba>
    5e58:	80 e3       	ldi	r24, 0x30	; 48
    5e5a:	02 c0       	rjmp	.+4      	; 0x5e60 <StrCalc+0x4be>
	    Result='0'+X;
    5e5c:	89 2f       	mov	r24, r25
    5e5e:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5e60:	a4 0d       	add	r26, r4
    5e62:	b5 1d       	adc	r27, r5
    5e64:	8c 93       	st	X, r24
    5e66:	20 e0       	ldi	r18, 0x00	; 0
    5e68:	01 c0       	rjmp	.+2      	; 0x5e6c <StrCalc+0x4ca>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    5e6a:	21 e0       	ldi	r18, 0x01	; 1
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    5e6c:	3f 5f       	subi	r19, 0xFF	; 255
    5e6e:	08 94       	sec
    5e70:	e1 1c       	adc	r14, r1
    5e72:	f1 1c       	adc	r15, r1
    5e74:	41 50       	subi	r20, 0x01	; 1
    5e76:	50 40       	sbci	r21, 0x00	; 0
    5e78:	08 94       	sec
    5e7a:	c1 08       	sbc	r12, r1
    5e7c:	d1 08       	sbc	r13, r1
    5e7e:	37 15       	cp	r19, r7
    5e80:	08 f4       	brcc	.+2      	; 0x5e84 <StrCalc+0x4e2>
    5e82:	b6 cf       	rjmp	.-148    	; 0x5df0 <StrCalc+0x44e>
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    5e84:	20 5d       	subi	r18, 0xD0	; 208
				 }//EndFor j                
			   }//End else
			 }//EndFor

		  //Result[lenA]==Chr(zMin); ???
		  Result[lenA]=Chr(zMin);
    5e86:	de 01       	movw	r26, r28
    5e88:	dd 96       	adiw	r26, 0x3d	; 61
    5e8a:	fd 01       	movw	r30, r26
    5e8c:	e0 0f       	add	r30, r16
    5e8e:	f1 1f       	adc	r31, r17
    5e90:	20 83       	st	Z, r18
		  Result[lenA+1]=0;
    5e92:	0c 0f       	add	r16, r28
    5e94:	1d 1f       	adc	r17, r29
    5e96:	f8 01       	movw	r30, r16
    5e98:	16 ae       	std	Z+62, r1	; 0x3e
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    5e9a:	fd 01       	movw	r30, r26
    5e9c:	01 90       	ld	r0, Z+
    5e9e:	00 20       	and	r0, r0
    5ea0:	e9 f7       	brne	.-6      	; 0x5e9c <StrCalc+0x4fa>
    5ea2:	31 97       	sbiw	r30, 0x01	; 1
    5ea4:	5e 2f       	mov	r21, r30
    5ea6:	5a 1b       	sub	r21, r26
    5ea8:	25 2f       	mov	r18, r21
    5eaa:	30 e0       	ldi	r19, 0x00	; 0
    5eac:	21 50       	subi	r18, 0x01	; 1
    5eae:	30 40       	sbci	r19, 0x00	; 0
    5eb0:	2a 0f       	add	r18, r26
    5eb2:	3b 1f       	adc	r19, r27
    5eb4:	40 e0       	ldi	r20, 0x00	; 0
    5eb6:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    5eb8:	6d e2       	ldi	r22, 0x2D	; 45
    5eba:	16 c0       	rjmp	.+44     	; 0x5ee8 <StrCalc+0x546>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    5ebc:	44 23       	and	r20, r20
    5ebe:	51 f4       	brne	.+20     	; 0x5ed4 <StrCalc+0x532>
    5ec0:	63 96       	adiw	r28, 0x13	; 19
    5ec2:	ff ad       	ldd	r31, Y+63	; 0x3f
    5ec4:	63 97       	sbiw	r28, 0x13	; 19
    5ec6:	f1 30       	cpi	r31, 0x01	; 1
    5ec8:	29 f4       	brne	.+10     	; 0x5ed4 <StrCalc+0x532>
			     strC[iPos]='-';
    5eca:	f5 01       	movw	r30, r10
    5ecc:	e9 0f       	add	r30, r25
    5ece:	f1 1d       	adc	r31, r1
    5ed0:	60 83       	st	Z, r22
				 iPos++;
    5ed2:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    5ed4:	f5 01       	movw	r30, r10
    5ed6:	e9 0f       	add	r30, r25
    5ed8:	f1 1d       	adc	r31, r1
    5eda:	d9 01       	movw	r26, r18
    5edc:	8c 91       	ld	r24, X
    5ede:	80 83       	st	Z, r24
			 iPos++;
    5ee0:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5ee2:	4f 5f       	subi	r20, 0xFF	; 255
    5ee4:	21 50       	subi	r18, 0x01	; 1
    5ee6:	30 40       	sbci	r19, 0x00	; 0
    5ee8:	45 17       	cp	r20, r21
    5eea:	40 f3       	brcs	.-48     	; 0x5ebc <StrCalc+0x51a>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    5eec:	f5 01       	movw	r30, r10
    5eee:	e9 0f       	add	r30, r25
    5ef0:	f1 1d       	adc	r31, r1
    5ef2:	10 82       	st	Z, r1

       RemZeroLead(strC);
    5ef4:	c5 01       	movw	r24, r10
    5ef6:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    5efa:	b2 e0       	ldi	r27, 0x02	; 2
    5efc:	6b 16       	cp	r6, r27
    5efe:	e1 f4       	brne	.+56     	; 0x5f38 <StrCalc+0x596>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    5f00:	67 96       	adiw	r28, 0x17	; 23
    5f02:	8e ad       	ldd	r24, Y+62	; 0x3e
    5f04:	9f ad       	ldd	r25, Y+63	; 0x3f
    5f06:	67 97       	sbiw	r28, 0x17	; 23
    5f08:	69 96       	adiw	r28, 0x19	; 25
    5f0a:	6e ad       	ldd	r22, Y+62	; 0x3e
    5f0c:	7f ad       	ldd	r23, Y+63	; 0x3f
    5f0e:	69 97       	sbiw	r28, 0x19	; 25
    5f10:	a5 01       	movw	r20, r10
    5f12:	0e 94 b5 2f 	call	0x5f6a	; 0x5f6a <CalcMultiply>
    5f16:	10 c0       	rjmp	.+32     	; 0x5f38 <StrCalc+0x596>
	 }
}
    5f18:	e1 e0       	ldi	r30, 0x01	; 1
    5f1a:	62 96       	adiw	r28, 0x12	; 18
    5f1c:	ef af       	std	Y+63, r30	; 0x3f
    5f1e:	62 97       	sbiw	r28, 0x12	; 18
    5f20:	ac ce       	rjmp	.-680    	; 0x5c7a <StrCalc+0x2d8>
    5f22:	63 96       	adiw	r28, 0x13	; 19
    5f24:	1f ae       	std	Y+63, r1	; 0x3f
    5f26:	63 97       	sbiw	r28, 0x13	; 19
    5f28:	48 cf       	rjmp	.-368    	; 0x5dba <StrCalc+0x418>
    5f2a:	f1 e0       	ldi	r31, 0x01	; 1
    5f2c:	63 96       	adiw	r28, 0x13	; 19
    5f2e:	ff af       	std	Y+63, r31	; 0x3f
    5f30:	63 97       	sbiw	r28, 0x13	; 19
    5f32:	43 cf       	rjmp	.-378    	; 0x5dba <StrCalc+0x418>
    5f34:	90 e0       	ldi	r25, 0x00	; 0
    5f36:	8c cf       	rjmp	.-232    	; 0x5e50 <StrCalc+0x4ae>
    5f38:	c8 5a       	subi	r28, 0xA8	; 168
    5f3a:	df 4f       	sbci	r29, 0xFF	; 255
    5f3c:	0f b6       	in	r0, 0x3f	; 63
    5f3e:	f8 94       	cli
    5f40:	de bf       	out	0x3e, r29	; 62
    5f42:	0f be       	out	0x3f, r0	; 63
    5f44:	cd bf       	out	0x3d, r28	; 61
    5f46:	cf 91       	pop	r28
    5f48:	df 91       	pop	r29
    5f4a:	1f 91       	pop	r17
    5f4c:	0f 91       	pop	r16
    5f4e:	ff 90       	pop	r15
    5f50:	ef 90       	pop	r14
    5f52:	df 90       	pop	r13
    5f54:	cf 90       	pop	r12
    5f56:	bf 90       	pop	r11
    5f58:	af 90       	pop	r10
    5f5a:	9f 90       	pop	r9
    5f5c:	8f 90       	pop	r8
    5f5e:	7f 90       	pop	r7
    5f60:	6f 90       	pop	r6
    5f62:	5f 90       	pop	r5
    5f64:	4f 90       	pop	r4
    5f66:	3f 90       	pop	r3
    5f68:	08 95       	ret

00005f6a <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    5f6a:	4f 92       	push	r4
    5f6c:	5f 92       	push	r5
    5f6e:	6f 92       	push	r6
    5f70:	7f 92       	push	r7
    5f72:	8f 92       	push	r8
    5f74:	9f 92       	push	r9
    5f76:	af 92       	push	r10
    5f78:	bf 92       	push	r11
    5f7a:	cf 92       	push	r12
    5f7c:	df 92       	push	r13
    5f7e:	ef 92       	push	r14
    5f80:	ff 92       	push	r15
    5f82:	0f 93       	push	r16
    5f84:	1f 93       	push	r17
    5f86:	df 93       	push	r29
    5f88:	cf 93       	push	r28
    5f8a:	cd b7       	in	r28, 0x3d	; 61
    5f8c:	de b7       	in	r29, 0x3e	; 62
    5f8e:	a8 97       	sbiw	r28, 0x28	; 40
    5f90:	0f b6       	in	r0, 0x3f	; 63
    5f92:	f8 94       	cli
    5f94:	de bf       	out	0x3e, r29	; 62
    5f96:	0f be       	out	0x3f, r0	; 63
    5f98:	cd bf       	out	0x3d, r28	; 61
    5f9a:	3c 01       	movw	r6, r24
    5f9c:	6b 01       	movw	r12, r22
    5f9e:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    5fa0:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
     RemZeroLead(strB);
    5fa4:	c6 01       	movw	r24, r12
    5fa6:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
	 lenB=strlen(strB);
    5faa:	d6 01       	movw	r26, r12
    5fac:	0d 90       	ld	r0, X+
    5fae:	00 20       	and	r0, r0
    5fb0:	e9 f7       	brne	.-6      	; 0x5fac <CalcMultiply+0x42>
    5fb2:	11 97       	sbiw	r26, 0x01	; 1
    5fb4:	8a 2e       	mov	r8, r26
    5fb6:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    5fb8:	00 d0       	rcall	.+0      	; 0x5fba <CalcMultiply+0x50>
    5fba:	00 d0       	rcall	.+0      	; 0x5fbc <CalcMultiply+0x52>
    5fbc:	8e 01       	movw	r16, r28
    5fbe:	0f 5f       	subi	r16, 0xFF	; 255
    5fc0:	1f 4f       	sbci	r17, 0xFF	; 255
    5fc2:	ad b7       	in	r26, 0x3d	; 61
    5fc4:	be b7       	in	r27, 0x3e	; 62
    5fc6:	12 96       	adiw	r26, 0x02	; 2
    5fc8:	1c 93       	st	X, r17
    5fca:	0e 93       	st	-X, r16
    5fcc:	11 97       	sbiw	r26, 0x01	; 1
    5fce:	83 e7       	ldi	r24, 0x73	; 115
    5fd0:	96 e0       	ldi	r25, 0x06	; 6
    5fd2:	14 96       	adiw	r26, 0x04	; 4
    5fd4:	9c 93       	st	X, r25
    5fd6:	8e 93       	st	-X, r24
    5fd8:	13 97       	sbiw	r26, 0x03	; 3
    5fda:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    5fde:	a5 e1       	ldi	r26, 0x15	; 21
    5fe0:	ea 2e       	mov	r14, r26
    5fe2:	f1 2c       	mov	r15, r1
    5fe4:	ec 0e       	add	r14, r28
    5fe6:	fd 1e       	adc	r15, r29
    5fe8:	ed b7       	in	r30, 0x3d	; 61
    5fea:	fe b7       	in	r31, 0x3e	; 62
    5fec:	f2 82       	std	Z+2, r15	; 0x02
    5fee:	e1 82       	std	Z+1, r14	; 0x01
    5ff0:	81 e7       	ldi	r24, 0x71	; 113
    5ff2:	96 e0       	ldi	r25, 0x06	; 6
    5ff4:	94 83       	std	Z+4, r25	; 0x04
    5ff6:	83 83       	std	Z+3, r24	; 0x03
    5ff8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    5ffc:	bb 24       	eor	r11, r11
    5ffe:	0f 90       	pop	r0
    6000:	0f 90       	pop	r0
    6002:	0f 90       	pop	r0
    6004:	0f 90       	pop	r0
    6006:	a0 2e       	mov	r10, r16
    6008:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    600a:	08 2d       	mov	r16, r8
    600c:	10 e0       	ldi	r17, 0x00	; 0
    600e:	01 50       	subi	r16, 0x01	; 1
    6010:	10 40       	sbci	r17, 0x00	; 0
    6012:	1f c0       	rjmp	.+62     	; 0x6052 <CalcMultiply+0xe8>
    6014:	f8 01       	movw	r30, r16
    6016:	e8 1b       	sub	r30, r24
    6018:	f9 0b       	sbc	r31, r25
    601a:	ec 0d       	add	r30, r12
    601c:	fd 1d       	adc	r31, r13
    601e:	c3 01       	movw	r24, r6
    6020:	60 81       	ld	r22, Z
    6022:	a7 01       	movw	r20, r14
    6024:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    6028:	f7 01       	movw	r30, r14
    602a:	01 90       	ld	r0, Z+
    602c:	00 20       	and	r0, r0
    602e:	e9 f7       	brne	.-6      	; 0x602a <CalcMultiply+0xc0>
    6030:	31 97       	sbiw	r30, 0x01	; 1
    6032:	ee 19       	sub	r30, r14
    6034:	ff 09       	sbc	r31, r15
    6036:	6b 2d       	mov	r22, r11
    6038:	6e 0f       	add	r22, r30
    603a:	c7 01       	movw	r24, r14
    603c:	0e 94 b6 2c 	call	0x596c	; 0x596c <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    6040:	81 e0       	ldi	r24, 0x01	; 1
    6042:	6a 2d       	mov	r22, r10
    6044:	79 2d       	mov	r23, r9
    6046:	a7 01       	movw	r20, r14
    6048:	2a 2d       	mov	r18, r10
    604a:	39 2d       	mov	r19, r9
    604c:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    6050:	b3 94       	inc	r11
    6052:	f6 01       	movw	r30, r12
    6054:	01 90       	ld	r0, Z+
    6056:	00 20       	and	r0, r0
    6058:	e9 f7       	brne	.-6      	; 0x6054 <CalcMultiply+0xea>
    605a:	31 97       	sbiw	r30, 0x01	; 1
    605c:	ec 19       	sub	r30, r12
    605e:	fd 09       	sbc	r31, r13
    6060:	8b 2d       	mov	r24, r11
    6062:	90 e0       	ldi	r25, 0x00	; 0
    6064:	8e 17       	cp	r24, r30
    6066:	9f 07       	cpc	r25, r31
    6068:	a8 f2       	brcs	.-86     	; 0x6014 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    606a:	00 d0       	rcall	.+0      	; 0x606c <CalcMultiply+0x102>
    606c:	00 d0       	rcall	.+0      	; 0x606e <CalcMultiply+0x104>
    606e:	00 d0       	rcall	.+0      	; 0x6070 <CalcMultiply+0x106>
    6070:	ed b7       	in	r30, 0x3d	; 61
    6072:	fe b7       	in	r31, 0x3e	; 62
    6074:	31 96       	adiw	r30, 0x01	; 1
    6076:	ad b7       	in	r26, 0x3d	; 61
    6078:	be b7       	in	r27, 0x3e	; 62
    607a:	12 96       	adiw	r26, 0x02	; 2
    607c:	5c 92       	st	X, r5
    607e:	4e 92       	st	-X, r4
    6080:	11 97       	sbiw	r26, 0x01	; 1
    6082:	8e e6       	ldi	r24, 0x6E	; 110
    6084:	96 e0       	ldi	r25, 0x06	; 6
    6086:	93 83       	std	Z+3, r25	; 0x03
    6088:	82 83       	std	Z+2, r24	; 0x02
    608a:	a4 82       	std	Z+4, r10	; 0x04
    608c:	95 82       	std	Z+5, r9	; 0x05
    608e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    6092:	ed b7       	in	r30, 0x3d	; 61
    6094:	fe b7       	in	r31, 0x3e	; 62
    6096:	36 96       	adiw	r30, 0x06	; 6
    6098:	0f b6       	in	r0, 0x3f	; 63
    609a:	f8 94       	cli
    609c:	fe bf       	out	0x3e, r31	; 62
    609e:	0f be       	out	0x3f, r0	; 63
    60a0:	ed bf       	out	0x3d, r30	; 61
}
    60a2:	a8 96       	adiw	r28, 0x28	; 40
    60a4:	0f b6       	in	r0, 0x3f	; 63
    60a6:	f8 94       	cli
    60a8:	de bf       	out	0x3e, r29	; 62
    60aa:	0f be       	out	0x3f, r0	; 63
    60ac:	cd bf       	out	0x3d, r28	; 61
    60ae:	cf 91       	pop	r28
    60b0:	df 91       	pop	r29
    60b2:	1f 91       	pop	r17
    60b4:	0f 91       	pop	r16
    60b6:	ff 90       	pop	r15
    60b8:	ef 90       	pop	r14
    60ba:	df 90       	pop	r13
    60bc:	cf 90       	pop	r12
    60be:	bf 90       	pop	r11
    60c0:	af 90       	pop	r10
    60c2:	9f 90       	pop	r9
    60c4:	8f 90       	pop	r8
    60c6:	7f 90       	pop	r7
    60c8:	6f 90       	pop	r6
    60ca:	5f 90       	pop	r5
    60cc:	4f 90       	pop	r4
    60ce:	08 95       	ret

000060d0 <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    60d0:	cf 92       	push	r12
    60d2:	df 92       	push	r13
    60d4:	ef 92       	push	r14
    60d6:	ff 92       	push	r15
    60d8:	0f 93       	push	r16
    60da:	1f 93       	push	r17
    60dc:	df 93       	push	r29
    60de:	cf 93       	push	r28
    60e0:	cd b7       	in	r28, 0x3d	; 61
    60e2:	de b7       	in	r29, 0x3e	; 62
    60e4:	64 97       	sbiw	r28, 0x14	; 20
    60e6:	0f b6       	in	r0, 0x3f	; 63
    60e8:	f8 94       	cli
    60ea:	de bf       	out	0x3e, r29	; 62
    60ec:	0f be       	out	0x3f, r0	; 63
    60ee:	cd bf       	out	0x3d, r28	; 61
    60f0:	d8 2e       	mov	r13, r24
    60f2:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    60f4:	a8 2f       	mov	r26, r24
    60f6:	b9 2f       	mov	r27, r25
    60f8:	fd 01       	movw	r30, r26
    60fa:	01 90       	ld	r0, Z+
    60fc:	00 20       	and	r0, r0
    60fe:	e9 f7       	brne	.-6      	; 0x60fa <NormalizeOverflow+0x2a>
    6100:	31 97       	sbiw	r30, 0x01	; 1
    6102:	4e 2f       	mov	r20, r30
    6104:	48 1b       	sub	r20, r24
    6106:	20 e0       	ldi	r18, 0x00	; 0
    6108:	30 e0       	ldi	r19, 0x00	; 0
    610a:	7e 01       	movw	r14, r28
    610c:	08 94       	sec
    610e:	e1 1c       	adc	r14, r1
    6110:	f1 1c       	adc	r15, r1
    6112:	04 2f       	mov	r16, r20
    6114:	10 e0       	ldi	r17, 0x00	; 0
    6116:	0e c0       	rjmp	.+28     	; 0x6134 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    6118:	f7 01       	movw	r30, r14
    611a:	e2 0f       	add	r30, r18
    611c:	f3 1f       	adc	r31, r19
    611e:	c8 01       	movw	r24, r16
    6120:	82 1b       	sub	r24, r18
    6122:	93 0b       	sbc	r25, r19
    6124:	64 2f       	mov	r22, r20
    6126:	70 e0       	ldi	r23, 0x00	; 0
    6128:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    612c:	60 5d       	subi	r22, 0xD0	; 208
    612e:	60 83       	st	Z, r22
    6130:	2f 5f       	subi	r18, 0xFF	; 255
    6132:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    6134:	24 17       	cp	r18, r20
    6136:	80 f3       	brcs	.-32     	; 0x6118 <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    6138:	0e 0d       	add	r16, r14
    613a:	1f 1d       	adc	r17, r15
    613c:	f8 01       	movw	r30, r16
    613e:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    6140:	81 e0       	ldi	r24, 0x01	; 1
    6142:	b7 01       	movw	r22, r14
    6144:	4d 2d       	mov	r20, r13
    6146:	5c 2d       	mov	r21, r12
    6148:	2d 2d       	mov	r18, r13
    614a:	3c 2d       	mov	r19, r12
    614c:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>
}
    6150:	64 96       	adiw	r28, 0x14	; 20
    6152:	0f b6       	in	r0, 0x3f	; 63
    6154:	f8 94       	cli
    6156:	de bf       	out	0x3e, r29	; 62
    6158:	0f be       	out	0x3f, r0	; 63
    615a:	cd bf       	out	0x3d, r28	; 61
    615c:	cf 91       	pop	r28
    615e:	df 91       	pop	r29
    6160:	1f 91       	pop	r17
    6162:	0f 91       	pop	r16
    6164:	ff 90       	pop	r15
    6166:	ef 90       	pop	r14
    6168:	df 90       	pop	r13
    616a:	cf 90       	pop	r12
    616c:	08 95       	ret

0000616e <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    616e:	bf 92       	push	r11
    6170:	cf 92       	push	r12
    6172:	df 92       	push	r13
    6174:	ef 92       	push	r14
    6176:	ff 92       	push	r15
    6178:	0f 93       	push	r16
    617a:	1f 93       	push	r17
    617c:	df 93       	push	r29
    617e:	cf 93       	push	r28
    6180:	cd b7       	in	r28, 0x3d	; 61
    6182:	de b7       	in	r29, 0x3e	; 62
    6184:	e2 97       	sbiw	r28, 0x32	; 50
    6186:	0f b6       	in	r0, 0x3f	; 63
    6188:	f8 94       	cli
    618a:	de bf       	out	0x3e, r29	; 62
    618c:	0f be       	out	0x3f, r0	; 63
    618e:	cd bf       	out	0x3d, r28	; 61
    6190:	8c 01       	movw	r16, r24
     char i,Length,strAdded[50];
     Length=strlen(String);
    6192:	fc 01       	movw	r30, r24
    6194:	01 90       	ld	r0, Z+
    6196:	00 20       	and	r0, r0
    6198:	e9 f7       	brne	.-6      	; 0x6194 <AddSpaceLead+0x26>
    619a:	31 97       	sbiw	r30, 0x01	; 1
    619c:	2e 2f       	mov	r18, r30
    619e:	28 1b       	sub	r18, r24

	 if (Size>Length){
    61a0:	26 17       	cp	r18, r22
    61a2:	e0 f5       	brcc	.+120    	; 0x621c <AddSpaceLead+0xae>
    61a4:	7e 01       	movw	r14, r28
    61a6:	08 94       	sec
    61a8:	e1 1c       	adc	r14, r1
    61aa:	f1 1c       	adc	r15, r1
    61ac:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    61ae:	be 2c       	mov	r11, r14
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    61b0:	90 e2       	ldi	r25, 0x20	; 32
    61b2:	01 c0       	rjmp	.+2      	; 0x61b6 <AddSpaceLead+0x48>
    61b4:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    61b6:	8e 2f       	mov	r24, r30
    61b8:	8b 19       	sub	r24, r11
    61ba:	86 17       	cp	r24, r22
    61bc:	d8 f3       	brcs	.-10     	; 0x61b4 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    61be:	46 2f       	mov	r20, r22
    61c0:	50 e0       	ldi	r21, 0x00	; 0
    61c2:	ce 01       	movw	r24, r28
    61c4:	01 96       	adiw	r24, 0x01	; 1
    61c6:	fc 01       	movw	r30, r24
    61c8:	e4 0f       	add	r30, r20
    61ca:	f5 1f       	adc	r31, r21
    61cc:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    61ce:	76 2f       	mov	r23, r22
    61d0:	72 1b       	sub	r23, r18
    61d2:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    61d4:	30 e0       	ldi	r19, 0x00	; 0
    61d6:	24 1b       	sub	r18, r20
    61d8:	35 0b       	sbc	r19, r21
    61da:	0c c0       	rjmp	.+24     	; 0x61f4 <AddSpaceLead+0x86>
    61dc:	e7 2f       	mov	r30, r23
    61de:	f0 e0       	ldi	r31, 0x00	; 0
    61e0:	d6 01       	movw	r26, r12
    61e2:	ae 0f       	add	r26, r30
    61e4:	bf 1f       	adc	r27, r31
    61e6:	e0 0f       	add	r30, r16
    61e8:	f1 1f       	adc	r31, r17
    61ea:	e2 0f       	add	r30, r18
    61ec:	f3 1f       	adc	r31, r19
    61ee:	80 81       	ld	r24, Z
    61f0:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    61f2:	7f 5f       	subi	r23, 0xFF	; 255
    61f4:	76 17       	cp	r23, r22
    61f6:	90 f3       	brcs	.-28     	; 0x61dc <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    61f8:	4c 0d       	add	r20, r12
    61fa:	5d 1d       	adc	r21, r13
    61fc:	da 01       	movw	r26, r20
    61fe:	1c 92       	st	X, r1
    6200:	f8 01       	movw	r30, r16
    6202:	04 c0       	rjmp	.+8      	; 0x620c <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    6204:	d7 01       	movw	r26, r14
    6206:	8d 91       	ld	r24, X+
    6208:	7d 01       	movw	r14, r26
    620a:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    620c:	8e 2d       	mov	r24, r14
    620e:	8b 19       	sub	r24, r11
    6210:	86 17       	cp	r24, r22
    6212:	c0 f3       	brcs	.-16     	; 0x6204 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    6214:	06 0f       	add	r16, r22
    6216:	11 1d       	adc	r17, r1
    6218:	f8 01       	movw	r30, r16
    621a:	10 82       	st	Z, r1
	 }
}
    621c:	e2 96       	adiw	r28, 0x32	; 50
    621e:	0f b6       	in	r0, 0x3f	; 63
    6220:	f8 94       	cli
    6222:	de bf       	out	0x3e, r29	; 62
    6224:	0f be       	out	0x3f, r0	; 63
    6226:	cd bf       	out	0x3d, r28	; 61
    6228:	cf 91       	pop	r28
    622a:	df 91       	pop	r29
    622c:	1f 91       	pop	r17
    622e:	0f 91       	pop	r16
    6230:	ff 90       	pop	r15
    6232:	ef 90       	pop	r14
    6234:	df 90       	pop	r13
    6236:	cf 90       	pop	r12
    6238:	bf 90       	pop	r11
    623a:	08 95       	ret

0000623c <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    623c:	cf 93       	push	r28
    623e:	df 93       	push	r29
    6240:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    6242:	dc 01       	movw	r26, r24
    6244:	0d 90       	ld	r0, X+
    6246:	00 20       	and	r0, r0
    6248:	e9 f7       	brne	.-6      	; 0x6244 <AddSpaceLag+0x8>
    624a:	11 97       	sbiw	r26, 0x01	; 1
    624c:	a8 1b       	sub	r26, r24
    624e:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    6250:	a6 17       	cp	r26, r22
    6252:	60 f4       	brcc	.+24     	; 0x626c <AddSpaceLag+0x30>
    6254:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    6256:	90 e2       	ldi	r25, 0x20	; 32
    6258:	fe 01       	movw	r30, r28
    625a:	e8 0f       	add	r30, r24
    625c:	f1 1d       	adc	r31, r1
    625e:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    6260:	8f 5f       	subi	r24, 0xFF	; 255
    6262:	86 17       	cp	r24, r22
    6264:	c8 f3       	brcs	.-14     	; 0x6258 <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    6266:	c6 0f       	add	r28, r22
    6268:	d1 1d       	adc	r29, r1
    626a:	18 82       	st	Y, r1
  }
}
    626c:	df 91       	pop	r29
    626e:	cf 91       	pop	r28
    6270:	08 95       	ret

00006272 <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
    6272:	8f 92       	push	r8
    6274:	9f 92       	push	r9
    6276:	af 92       	push	r10
    6278:	bf 92       	push	r11
    627a:	cf 92       	push	r12
    627c:	df 92       	push	r13
    627e:	ef 92       	push	r14
    6280:	ff 92       	push	r15
    6282:	0f 93       	push	r16
    6284:	1f 93       	push	r17
    6286:	df 93       	push	r29
    6288:	cf 93       	push	r28
    628a:	cd b7       	in	r28, 0x3d	; 61
    628c:	de b7       	in	r29, 0x3e	; 62
    628e:	c5 56       	subi	r28, 0x65	; 101
    6290:	d0 40       	sbci	r29, 0x00	; 0
    6292:	0f b6       	in	r0, 0x3f	; 63
    6294:	f8 94       	cli
    6296:	de bf       	out	0x3e, r29	; 62
    6298:	0f be       	out	0x3f, r0	; 63
    629a:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 uart_printf(1,0,PSTR("<"));
    629c:	81 e0       	ldi	r24, 0x01	; 1
    629e:	60 e0       	ldi	r22, 0x00	; 0
    62a0:	41 e9       	ldi	r20, 0x91	; 145
    62a2:	52 e2       	ldi	r21, 0x22	; 34
    62a4:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
    62a8:	07 e2       	ldi	r16, 0x27	; 39
    62aa:	12 e0       	ldi	r17, 0x02	; 2
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    62ac:	6e 01       	movw	r12, r28
    62ae:	08 94       	sec
    62b0:	c1 1c       	adc	r12, r1
    62b2:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
    62b4:	ba e2       	ldi	r27, 0x2A	; 42
    62b6:	eb 2e       	mov	r14, r27
    62b8:	f1 2c       	mov	r15, r1
    62ba:	ec 0e       	add	r14, r28
    62bc:	fd 1e       	adc	r15, r29
    62be:	ae e8       	ldi	r26, 0x8E	; 142
    62c0:	aa 2e       	mov	r10, r26
    62c2:	a2 e2       	ldi	r26, 0x22	; 34
    62c4:	ba 2e       	mov	r11, r26
    62c6:	c6 01       	movw	r24, r12
    62c8:	b8 01       	movw	r22, r16
    62ca:	49 e2       	ldi	r20, 0x29	; 41
    62cc:	50 e0       	ldi	r21, 0x00	; 0
    62ce:	22 e4       	ldi	r18, 0x42	; 66
    62d0:	33 e1       	ldi	r19, 0x13	; 19
    62d2:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    62d6:	00 d0       	rcall	.+0      	; 0x62d8 <SendConfigParamater+0x66>
    62d8:	00 d0       	rcall	.+0      	; 0x62da <SendConfigParamater+0x68>
    62da:	00 d0       	rcall	.+0      	; 0x62dc <SendConfigParamater+0x6a>
    62dc:	ed b7       	in	r30, 0x3d	; 61
    62de:	fe b7       	in	r31, 0x3e	; 62
    62e0:	31 96       	adiw	r30, 0x01	; 1
    62e2:	ad b7       	in	r26, 0x3d	; 61
    62e4:	be b7       	in	r27, 0x3e	; 62
    62e6:	12 96       	adiw	r26, 0x02	; 2
    62e8:	fc 92       	st	X, r15
    62ea:	ee 92       	st	-X, r14
    62ec:	11 97       	sbiw	r26, 0x01	; 1
    62ee:	b3 82       	std	Z+3, r11	; 0x03
    62f0:	a2 82       	std	Z+2, r10	; 0x02
    62f2:	d5 82       	std	Z+5, r13	; 0x05
    62f4:	c4 82       	std	Z+4, r12	; 0x04
    62f6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  AddSpaceLag(strSend,40);
    62fa:	ed b7       	in	r30, 0x3d	; 61
    62fc:	fe b7       	in	r31, 0x3e	; 62
    62fe:	36 96       	adiw	r30, 0x06	; 6
    6300:	0f b6       	in	r0, 0x3f	; 63
    6302:	f8 94       	cli
    6304:	fe bf       	out	0x3e, r31	; 62
    6306:	0f be       	out	0x3f, r0	; 63
    6308:	ed bf       	out	0x3d, r30	; 61
    630a:	c7 01       	movw	r24, r14
    630c:	68 e2       	ldi	r22, 0x28	; 40
    630e:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
		  uart_print(1,0,strSend);
    6312:	81 e0       	ldi	r24, 0x01	; 1
    6314:	60 e0       	ldi	r22, 0x00	; 0
    6316:	a7 01       	movw	r20, r14
    6318:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
    631c:	07 5d       	subi	r16, 0xD7	; 215
    631e:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
    6320:	f3 e0       	ldi	r31, 0x03	; 3
    6322:	01 3c       	cpi	r16, 0xC1	; 193
    6324:	1f 07       	cpc	r17, r31
    6326:	79 f6       	brne	.-98     	; 0x62c6 <SendConfigParamater+0x54>
    6328:	0b eb       	ldi	r16, 0xBB	; 187
    632a:	10 e0       	ldi	r17, 0x00	; 0
    632c:	6e 01       	movw	r12, r28
    632e:	08 94       	sec
    6330:	c1 1c       	adc	r12, r1
    6332:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
    6334:	fa e2       	ldi	r31, 0x2A	; 42
    6336:	ef 2e       	mov	r14, r31
    6338:	f1 2c       	mov	r15, r1
    633a:	ec 0e       	add	r14, r28
    633c:	fd 1e       	adc	r15, r29
    633e:	eb e8       	ldi	r30, 0x8B	; 139
    6340:	ae 2e       	mov	r10, r30
    6342:	e2 e2       	ldi	r30, 0x22	; 34
    6344:	be 2e       	mov	r11, r30
    6346:	c6 01       	movw	r24, r12
    6348:	b8 01       	movw	r22, r16
    634a:	4d e0       	ldi	r20, 0x0D	; 13
    634c:	50 e0       	ldi	r21, 0x00	; 0
    634e:	22 e4       	ldi	r18, 0x42	; 66
    6350:	33 e1       	ldi	r19, 0x13	; 19
    6352:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    6356:	00 d0       	rcall	.+0      	; 0x6358 <SendConfigParamater+0xe6>
    6358:	00 d0       	rcall	.+0      	; 0x635a <SendConfigParamater+0xe8>
    635a:	00 d0       	rcall	.+0      	; 0x635c <SendConfigParamater+0xea>
    635c:	ed b7       	in	r30, 0x3d	; 61
    635e:	fe b7       	in	r31, 0x3e	; 62
    6360:	31 96       	adiw	r30, 0x01	; 1
    6362:	ad b7       	in	r26, 0x3d	; 61
    6364:	be b7       	in	r27, 0x3e	; 62
    6366:	12 96       	adiw	r26, 0x02	; 2
    6368:	fc 92       	st	X, r15
    636a:	ee 92       	st	-X, r14
    636c:	11 97       	sbiw	r26, 0x01	; 1
    636e:	b3 82       	std	Z+3, r11	; 0x03
    6370:	a2 82       	std	Z+2, r10	; 0x02
    6372:	d5 82       	std	Z+5, r13	; 0x05
    6374:	c4 82       	std	Z+4, r12	; 0x04
    6376:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 AddSpaceLag(strSend,12);
    637a:	ed b7       	in	r30, 0x3d	; 61
    637c:	fe b7       	in	r31, 0x3e	; 62
    637e:	36 96       	adiw	r30, 0x06	; 6
    6380:	0f b6       	in	r0, 0x3f	; 63
    6382:	f8 94       	cli
    6384:	fe bf       	out	0x3e, r31	; 62
    6386:	0f be       	out	0x3f, r0	; 63
    6388:	ed bf       	out	0x3d, r30	; 61
    638a:	c7 01       	movw	r24, r14
    638c:	6c e0       	ldi	r22, 0x0C	; 12
    638e:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
		 uart_print(1,0,strSend);
    6392:	81 e0       	ldi	r24, 0x01	; 1
    6394:	60 e0       	ldi	r22, 0x00	; 0
    6396:	a7 01       	movw	r20, r14
    6398:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
    639c:	03 5f       	subi	r16, 0xF3	; 243
    639e:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
    63a0:	f1 e0       	ldi	r31, 0x01	; 1
    63a2:	09 30       	cpi	r16, 0x09	; 9
    63a4:	1f 07       	cpc	r17, r31
    63a6:	79 f6       	brne	.-98     	; 0x6346 <SendConfigParamater+0xd4>
    63a8:	05 e8       	ldi	r16, 0x85	; 133
    63aa:	10 e0       	ldi	r17, 0x00	; 0
    63ac:	6e 01       	movw	r12, r28
    63ae:	08 94       	sec
    63b0:	c1 1c       	adc	r12, r1
    63b2:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
    63b4:	7a e2       	ldi	r23, 0x2A	; 42
    63b6:	e7 2e       	mov	r14, r23
    63b8:	f1 2c       	mov	r15, r1
    63ba:	ec 0e       	add	r14, r28
    63bc:	fd 1e       	adc	r15, r29
    63be:	68 e8       	ldi	r22, 0x88	; 136
    63c0:	a6 2e       	mov	r10, r22
    63c2:	62 e2       	ldi	r22, 0x22	; 34
    63c4:	b6 2e       	mov	r11, r22
    63c6:	c6 01       	movw	r24, r12
    63c8:	b8 01       	movw	r22, r16
    63ca:	49 e0       	ldi	r20, 0x09	; 9
    63cc:	50 e0       	ldi	r21, 0x00	; 0
    63ce:	22 e4       	ldi	r18, 0x42	; 66
    63d0:	33 e1       	ldi	r19, 0x13	; 19
    63d2:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    63d6:	00 d0       	rcall	.+0      	; 0x63d8 <SendConfigParamater+0x166>
    63d8:	00 d0       	rcall	.+0      	; 0x63da <SendConfigParamater+0x168>
    63da:	00 d0       	rcall	.+0      	; 0x63dc <SendConfigParamater+0x16a>
    63dc:	ed b7       	in	r30, 0x3d	; 61
    63de:	fe b7       	in	r31, 0x3e	; 62
    63e0:	31 96       	adiw	r30, 0x01	; 1
    63e2:	ad b7       	in	r26, 0x3d	; 61
    63e4:	be b7       	in	r27, 0x3e	; 62
    63e6:	12 96       	adiw	r26, 0x02	; 2
    63e8:	fc 92       	st	X, r15
    63ea:	ee 92       	st	-X, r14
    63ec:	11 97       	sbiw	r26, 0x01	; 1
    63ee:	b3 82       	std	Z+3, r11	; 0x03
    63f0:	a2 82       	std	Z+2, r10	; 0x02
    63f2:	d5 82       	std	Z+5, r13	; 0x05
    63f4:	c4 82       	std	Z+4, r12	; 0x04
    63f6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 AddSpaceLag(strSend,5);
    63fa:	ed b7       	in	r30, 0x3d	; 61
    63fc:	fe b7       	in	r31, 0x3e	; 62
    63fe:	36 96       	adiw	r30, 0x06	; 6
    6400:	0f b6       	in	r0, 0x3f	; 63
    6402:	f8 94       	cli
    6404:	fe bf       	out	0x3e, r31	; 62
    6406:	0f be       	out	0x3f, r0	; 63
    6408:	ed bf       	out	0x3d, r30	; 61
    640a:	c7 01       	movw	r24, r14
    640c:	65 e0       	ldi	r22, 0x05	; 5
    640e:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
		 uart_print(1,0,strSend);
    6412:	81 e0       	ldi	r24, 0x01	; 1
    6414:	60 e0       	ldi	r22, 0x00	; 0
    6416:	a7 01       	movw	r20, r14
    6418:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
    641c:	07 5f       	subi	r16, 0xF7	; 247
    641e:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
    6420:	f0 e0       	ldi	r31, 0x00	; 0
    6422:	0b 3b       	cpi	r16, 0xBB	; 187
    6424:	1f 07       	cpc	r17, r31
    6426:	79 f6       	brne	.-98     	; 0x63c6 <SendConfigParamater+0x154>
    6428:	05 e4       	ldi	r16, 0x45	; 69
    642a:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
    642c:	5a e2       	ldi	r21, 0x2A	; 42
    642e:	e5 2e       	mov	r14, r21
    6430:	f1 2c       	mov	r15, r1
    6432:	ec 0e       	add	r14, r28
    6434:	fd 1e       	adc	r15, r29
    6436:	43 e8       	ldi	r20, 0x83	; 131
    6438:	c4 2e       	mov	r12, r20
    643a:	42 e2       	ldi	r20, 0x22	; 34
    643c:	d4 2e       	mov	r13, r20
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    643e:	e1 99       	sbic	0x1c, 1	; 28
    6440:	fe cf       	rjmp	.-4      	; 0x643e <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6442:	1f bb       	out	0x1f, r17	; 31
    6444:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6446:	e0 9a       	sbi	0x1c, 0	; 28
    6448:	8d b3       	in	r24, 0x1d	; 29
		 uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
    644a:	84 36       	cpi	r24, 0x64	; 100
    644c:	08 f0       	brcs	.+2      	; 0x6450 <SendConfigParamater+0x1de>
    644e:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
    6450:	00 d0       	rcall	.+0      	; 0x6452 <SendConfigParamater+0x1e0>
    6452:	00 d0       	rcall	.+0      	; 0x6454 <SendConfigParamater+0x1e2>
    6454:	00 d0       	rcall	.+0      	; 0x6456 <SendConfigParamater+0x1e4>
    6456:	ed b7       	in	r30, 0x3d	; 61
    6458:	fe b7       	in	r31, 0x3e	; 62
    645a:	31 96       	adiw	r30, 0x01	; 1
    645c:	ad b7       	in	r26, 0x3d	; 61
    645e:	be b7       	in	r27, 0x3e	; 62
    6460:	12 96       	adiw	r26, 0x02	; 2
    6462:	fc 92       	st	X, r15
    6464:	ee 92       	st	-X, r14
    6466:	11 97       	sbiw	r26, 0x01	; 1
    6468:	d3 82       	std	Z+3, r13	; 0x03
    646a:	c2 82       	std	Z+2, r12	; 0x02
    646c:	84 83       	std	Z+4, r24	; 0x04
    646e:	15 82       	std	Z+5, r1	; 0x05
    6470:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  AddSpaceLag(strSend,2);
    6474:	ed b7       	in	r30, 0x3d	; 61
    6476:	fe b7       	in	r31, 0x3e	; 62
    6478:	36 96       	adiw	r30, 0x06	; 6
    647a:	0f b6       	in	r0, 0x3f	; 63
    647c:	f8 94       	cli
    647e:	fe bf       	out	0x3e, r31	; 62
    6480:	0f be       	out	0x3f, r0	; 63
    6482:	ed bf       	out	0x3d, r30	; 61
    6484:	c7 01       	movw	r24, r14
    6486:	62 e0       	ldi	r22, 0x02	; 2
    6488:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
		 uart_print(1,0,strSend);
    648c:	81 e0       	ldi	r24, 0x01	; 1
    648e:	60 e0       	ldi	r22, 0x00	; 0
    6490:	a7 01       	movw	r20, r14
    6492:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
    6496:	0f 5f       	subi	r16, 0xFF	; 255
    6498:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
    649a:	f0 e0       	ldi	r31, 0x00	; 0
    649c:	0d 34       	cpi	r16, 0x4D	; 77
    649e:	1f 07       	cpc	r17, r31
    64a0:	71 f6       	brne	.-100    	; 0x643e <SendConfigParamater+0x1cc>
    64a2:	35 e5       	ldi	r19, 0x55	; 85
    64a4:	e3 2e       	mov	r14, r19
    64a6:	30 e0       	ldi	r19, 0x00	; 0
    64a8:	f3 2e       	mov	r15, r19
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
    64aa:	2a e2       	ldi	r18, 0x2A	; 42
    64ac:	a2 2e       	mov	r10, r18
    64ae:	b1 2c       	mov	r11, r1
    64b0:	ac 0e       	add	r10, r28
    64b2:	bd 1e       	adc	r11, r29
    64b4:	90 e8       	ldi	r25, 0x80	; 128
    64b6:	89 2e       	mov	r8, r25
    64b8:	92 e2       	ldi	r25, 0x22	; 34
    64ba:	99 2e       	mov	r9, r25
    64bc:	37 c0       	rjmp	.+110    	; 0x652c <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    64be:	e1 99       	sbic	0x1c, 1	; 28
    64c0:	fe cf       	rjmp	.-4      	; 0x64be <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    64c2:	1f bb       	out	0x1f, r17	; 31
    64c4:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    64c6:	e0 9a       	sbi	0x1c, 0	; 28
    64c8:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
    64ca:	8a 30       	cpi	r24, 0x0A	; 10
    64cc:	08 f0       	brcs	.+2      	; 0x64d0 <SendConfigParamater+0x25e>
    64ce:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
    64d0:	00 d0       	rcall	.+0      	; 0x64d2 <SendConfigParamater+0x260>
    64d2:	00 d0       	rcall	.+0      	; 0x64d4 <SendConfigParamater+0x262>
    64d4:	00 d0       	rcall	.+0      	; 0x64d6 <SendConfigParamater+0x264>
    64d6:	ed b7       	in	r30, 0x3d	; 61
    64d8:	fe b7       	in	r31, 0x3e	; 62
    64da:	31 96       	adiw	r30, 0x01	; 1
    64dc:	ad b7       	in	r26, 0x3d	; 61
    64de:	be b7       	in	r27, 0x3e	; 62
    64e0:	12 96       	adiw	r26, 0x02	; 2
    64e2:	bc 92       	st	X, r11
    64e4:	ae 92       	st	-X, r10
    64e6:	11 97       	sbiw	r26, 0x01	; 1
    64e8:	93 82       	std	Z+3, r9	; 0x03
    64ea:	82 82       	std	Z+2, r8	; 0x02
    64ec:	84 83       	std	Z+4, r24	; 0x04
    64ee:	15 82       	std	Z+5, r1	; 0x05
    64f0:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			   uart_print(1,0,strSend);
    64f4:	ed b7       	in	r30, 0x3d	; 61
    64f6:	fe b7       	in	r31, 0x3e	; 62
    64f8:	36 96       	adiw	r30, 0x06	; 6
    64fa:	0f b6       	in	r0, 0x3f	; 63
    64fc:	f8 94       	cli
    64fe:	fe bf       	out	0x3e, r31	; 62
    6500:	0f be       	out	0x3f, r0	; 63
    6502:	ed bf       	out	0x3d, r30	; 61
    6504:	81 e0       	ldi	r24, 0x01	; 1
    6506:	60 e0       	ldi	r22, 0x00	; 0
    6508:	a5 01       	movw	r20, r10
    650a:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
    650e:	d3 94       	inc	r13
    6510:	0f 5f       	subi	r16, 0xFF	; 255
    6512:	1f 4f       	sbci	r17, 0xFF	; 255
    6514:	f6 e0       	ldi	r31, 0x06	; 6
    6516:	df 16       	cp	r13, r31
    6518:	91 f6       	brne	.-92     	; 0x64be <SendConfigParamater+0x24c>
    651a:	86 e0       	ldi	r24, 0x06	; 6
    651c:	90 e0       	ldi	r25, 0x00	; 0
    651e:	e8 0e       	add	r14, r24
    6520:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
    6522:	95 e8       	ldi	r25, 0x85	; 133
    6524:	e9 16       	cp	r14, r25
    6526:	90 e0       	ldi	r25, 0x00	; 0
    6528:	f9 06       	cpc	r15, r25
    652a:	19 f0       	breq	.+6      	; 0x6532 <SendConfigParamater+0x2c0>
    652c:	87 01       	movw	r16, r14
    652e:	dd 24       	eor	r13, r13
    6530:	c6 cf       	rjmp	.-116    	; 0x64be <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6532:	e1 99       	sbic	0x1c, 1	; 28
    6534:	fe cf       	rjmp	.-4      	; 0x6532 <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6536:	81 ec       	ldi	r24, 0xC1	; 193
    6538:	93 e0       	ldi	r25, 0x03	; 3
    653a:	9f bb       	out	0x1f, r25	; 31
    653c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    653e:	e0 9a       	sbi	0x1c, 0	; 28
    6540:	8d b3       	in	r24, 0x1d	; 29
    6542:	9e 01       	movw	r18, r28
    6544:	26 5d       	subi	r18, 0xD6	; 214
    6546:	3f 4f       	sbci	r19, 0xFF	; 255
			   uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
    6548:	81 30       	cpi	r24, 0x01	; 1
    654a:	79 f4       	brne	.+30     	; 0x656a <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
    654c:	00 d0       	rcall	.+0      	; 0x654e <SendConfigParamater+0x2dc>
    654e:	00 d0       	rcall	.+0      	; 0x6550 <SendConfigParamater+0x2de>
    6550:	ad b7       	in	r26, 0x3d	; 61
    6552:	be b7       	in	r27, 0x3e	; 62
    6554:	12 96       	adiw	r26, 0x02	; 2
    6556:	3c 93       	st	X, r19
    6558:	2e 93       	st	-X, r18
    655a:	11 97       	sbiw	r26, 0x01	; 1
    655c:	8e e7       	ldi	r24, 0x7E	; 126
    655e:	92 e2       	ldi	r25, 0x22	; 34
    6560:	14 96       	adiw	r26, 0x04	; 4
    6562:	9c 93       	st	X, r25
    6564:	8e 93       	st	-X, r24
    6566:	13 97       	sbiw	r26, 0x03	; 3
    6568:	0a c0       	rjmp	.+20     	; 0x657e <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
    656a:	00 d0       	rcall	.+0      	; 0x656c <SendConfigParamater+0x2fa>
    656c:	00 d0       	rcall	.+0      	; 0x656e <SendConfigParamater+0x2fc>
    656e:	ed b7       	in	r30, 0x3d	; 61
    6570:	fe b7       	in	r31, 0x3e	; 62
    6572:	32 83       	std	Z+2, r19	; 0x02
    6574:	21 83       	std	Z+1, r18	; 0x01
    6576:	8c e7       	ldi	r24, 0x7C	; 124
    6578:	92 e2       	ldi	r25, 0x22	; 34
    657a:	94 83       	std	Z+4, r25	; 0x04
    657c:	83 83       	std	Z+3, r24	; 0x03
    657e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    6582:	0f 90       	pop	r0
    6584:	0f 90       	pop	r0
    6586:	0f 90       	pop	r0
    6588:	0f 90       	pop	r0
	 }uart_print(1,0,strSend);
    658a:	81 e0       	ldi	r24, 0x01	; 1
    658c:	60 e0       	ldi	r22, 0x00	; 0
    658e:	ae 01       	movw	r20, r28
    6590:	46 5d       	subi	r20, 0xD6	; 214
    6592:	5f 4f       	sbci	r21, 0xFF	; 255
    6594:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6598:	e1 99       	sbic	0x1c, 1	; 28
    659a:	fe cf       	rjmp	.-4      	; 0x6598 <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    659c:	80 e0       	ldi	r24, 0x00	; 0
    659e:	90 e0       	ldi	r25, 0x00	; 0
    65a0:	9f bb       	out	0x1f, r25	; 31
    65a2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    65a4:	e0 9a       	sbi	0x1c, 0	; 28
    65a6:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
    65a8:	00 d0       	rcall	.+0      	; 0x65aa <SendConfigParamater+0x338>
    65aa:	00 d0       	rcall	.+0      	; 0x65ac <SendConfigParamater+0x33a>
    65ac:	00 d0       	rcall	.+0      	; 0x65ae <SendConfigParamater+0x33c>
    65ae:	ed b7       	in	r30, 0x3d	; 61
    65b0:	fe b7       	in	r31, 0x3e	; 62
    65b2:	31 96       	adiw	r30, 0x01	; 1
    65b4:	8e 01       	movw	r16, r28
    65b6:	06 5d       	subi	r16, 0xD6	; 214
    65b8:	1f 4f       	sbci	r17, 0xFF	; 255
    65ba:	ad b7       	in	r26, 0x3d	; 61
    65bc:	be b7       	in	r27, 0x3e	; 62
    65be:	12 96       	adiw	r26, 0x02	; 2
    65c0:	1c 93       	st	X, r17
    65c2:	0e 93       	st	-X, r16
    65c4:	11 97       	sbiw	r26, 0x01	; 1
    65c6:	87 e7       	ldi	r24, 0x77	; 119
    65c8:	92 e2       	ldi	r25, 0x22	; 34
    65ca:	93 83       	std	Z+3, r25	; 0x03
    65cc:	82 83       	std	Z+2, r24	; 0x02
    65ce:	24 83       	std	Z+4, r18	; 0x04
    65d0:	15 82       	std	Z+5, r1	; 0x05
    65d2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
     uart_print(1,0,strSend);
    65d6:	ed b7       	in	r30, 0x3d	; 61
    65d8:	fe b7       	in	r31, 0x3e	; 62
    65da:	36 96       	adiw	r30, 0x06	; 6
    65dc:	0f b6       	in	r0, 0x3f	; 63
    65de:	f8 94       	cli
    65e0:	fe bf       	out	0x3e, r31	; 62
    65e2:	0f be       	out	0x3f, r0	; 63
    65e4:	ed bf       	out	0x3d, r30	; 61
    65e6:	81 e0       	ldi	r24, 0x01	; 1
    65e8:	60 e0       	ldi	r22, 0x00	; 0
    65ea:	a8 01       	movw	r20, r16
    65ec:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
    65f0:	8d e4       	ldi	r24, 0x4D	; 77
    65f2:	e8 2e       	mov	r14, r24
    65f4:	80 e0       	ldi	r24, 0x00	; 0
    65f6:	f8 2e       	mov	r15, r24
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
    65f8:	d0 2e       	mov	r13, r16
    65fa:	01 2f       	mov	r16, r17
    65fc:	b2 e7       	ldi	r27, 0x72	; 114
    65fe:	ab 2e       	mov	r10, r27
    6600:	b2 e2       	ldi	r27, 0x22	; 34
    6602:	bb 2e       	mov	r11, r27
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6604:	e1 99       	sbic	0x1c, 1	; 28
    6606:	fe cf       	rjmp	.-4      	; 0x6604 <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6608:	ff ba       	out	0x1f, r15	; 31
    660a:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    660c:	e0 9a       	sbi	0x1c, 0	; 28
    660e:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
    6610:	84 36       	cpi	r24, 0x64	; 100
    6612:	08 f0       	brcs	.+2      	; 0x6616 <SendConfigParamater+0x3a4>
    6614:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
    6616:	00 d0       	rcall	.+0      	; 0x6618 <SendConfigParamater+0x3a6>
    6618:	00 d0       	rcall	.+0      	; 0x661a <SendConfigParamater+0x3a8>
    661a:	00 d0       	rcall	.+0      	; 0x661c <SendConfigParamater+0x3aa>
    661c:	ed b7       	in	r30, 0x3d	; 61
    661e:	fe b7       	in	r31, 0x3e	; 62
    6620:	31 96       	adiw	r30, 0x01	; 1
    6622:	ad b7       	in	r26, 0x3d	; 61
    6624:	be b7       	in	r27, 0x3e	; 62
    6626:	11 96       	adiw	r26, 0x01	; 1
    6628:	dc 92       	st	X, r13
    662a:	11 97       	sbiw	r26, 0x01	; 1
    662c:	12 96       	adiw	r26, 0x02	; 2
    662e:	0c 93       	st	X, r16
    6630:	b3 82       	std	Z+3, r11	; 0x03
    6632:	a2 82       	std	Z+2, r10	; 0x02
    6634:	84 83       	std	Z+4, r24	; 0x04
    6636:	15 82       	std	Z+5, r1	; 0x05
    6638:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  AddSpaceLag(strSend,2);
    663c:	ed b7       	in	r30, 0x3d	; 61
    663e:	fe b7       	in	r31, 0x3e	; 62
    6640:	36 96       	adiw	r30, 0x06	; 6
    6642:	0f b6       	in	r0, 0x3f	; 63
    6644:	f8 94       	cli
    6646:	fe bf       	out	0x3e, r31	; 62
    6648:	0f be       	out	0x3f, r0	; 63
    664a:	ed bf       	out	0x3d, r30	; 61
    664c:	8d 2d       	mov	r24, r13
    664e:	90 2f       	mov	r25, r16
    6650:	62 e0       	ldi	r22, 0x02	; 2
    6652:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
		 uart_print(1,0,strSend);
    6656:	81 e0       	ldi	r24, 0x01	; 1
    6658:	60 e0       	ldi	r22, 0x00	; 0
    665a:	4d 2d       	mov	r20, r13
    665c:	50 2f       	mov	r21, r16
    665e:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
    6662:	08 94       	sec
    6664:	e1 1c       	adc	r14, r1
    6666:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
    6668:	f5 e5       	ldi	r31, 0x55	; 85
    666a:	ef 16       	cp	r14, r31
    666c:	f0 e0       	ldi	r31, 0x00	; 0
    666e:	ff 06       	cpc	r15, r31
    6670:	49 f6       	brne	.-110    	; 0x6604 <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 uart_printf(1,1,PSTR(">"));
    6672:	81 e0       	ldi	r24, 0x01	; 1
    6674:	61 e0       	ldi	r22, 0x01	; 1
    6676:	40 e7       	ldi	r20, 0x70	; 112
    6678:	52 e2       	ldi	r21, 0x22	; 34
    667a:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
	 //End
}
    667e:	cb 59       	subi	r28, 0x9B	; 155
    6680:	df 4f       	sbci	r29, 0xFF	; 255
    6682:	0f b6       	in	r0, 0x3f	; 63
    6684:	f8 94       	cli
    6686:	de bf       	out	0x3e, r29	; 62
    6688:	0f be       	out	0x3f, r0	; 63
    668a:	cd bf       	out	0x3d, r28	; 61
    668c:	cf 91       	pop	r28
    668e:	df 91       	pop	r29
    6690:	1f 91       	pop	r17
    6692:	0f 91       	pop	r16
    6694:	ff 90       	pop	r15
    6696:	ef 90       	pop	r14
    6698:	df 90       	pop	r13
    669a:	cf 90       	pop	r12
    669c:	bf 90       	pop	r11
    669e:	af 90       	pop	r10
    66a0:	9f 90       	pop	r9
    66a2:	8f 90       	pop	r8
    66a4:	08 95       	ret

000066a6 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    66a6:	0f 93       	push	r16
    66a8:	1f 93       	push	r17
    66aa:	df 93       	push	r29
    66ac:	cf 93       	push	r28
    66ae:	cd b7       	in	r28, 0x3d	; 61
    66b0:	de b7       	in	r29, 0x3e	; 62
    66b2:	2c 97       	sbiw	r28, 0x0c	; 12
    66b4:	0f b6       	in	r0, 0x3f	; 63
    66b6:	f8 94       	cli
    66b8:	de bf       	out	0x3e, r29	; 62
    66ba:	0f be       	out	0x3f, r0	; 63
    66bc:	cd bf       	out	0x3d, r28	; 61
    66be:	48 2f       	mov	r20, r24
    66c0:	8b 01       	movw	r16, r22
    66c2:	fe 01       	movw	r30, r28
    66c4:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    66c6:	9e 01       	movw	r18, r28
    66c8:	23 5f       	subi	r18, 0xF3	; 243
    66ca:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    66cc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    66ce:	e2 17       	cp	r30, r18
    66d0:	f3 07       	cpc	r31, r19
    66d2:	e1 f7       	brne	.-8      	; 0x66cc <GetProductName+0x26>
    66d4:	ce 01       	movw	r24, r28
    66d6:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    66d8:	44 23       	and	r20, r20
    66da:	69 f0       	breq	.+26     	; 0x66f6 <GetProductName+0x50>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    66dc:	6d e0       	ldi	r22, 0x0D	; 13
    66de:	46 9f       	mul	r20, r22
    66e0:	b0 01       	movw	r22, r0
    66e2:	11 24       	eor	r1, r1
    66e4:	62 55       	subi	r22, 0x52	; 82
    66e6:	7f 4f       	sbci	r23, 0xFF	; 255
    66e8:	4a e0       	ldi	r20, 0x0A	; 10
    66ea:	50 e0       	ldi	r21, 0x00	; 0
    66ec:	22 e4       	ldi	r18, 0x42	; 66
    66ee:	33 e1       	ldi	r19, 0x13	; 19
    66f0:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    66f4:	14 c0       	rjmp	.+40     	; 0x671e <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    66f6:	00 d0       	rcall	.+0      	; 0x66f8 <GetProductName+0x52>
    66f8:	00 d0       	rcall	.+0      	; 0x66fa <GetProductName+0x54>
    66fa:	ad b7       	in	r26, 0x3d	; 61
    66fc:	be b7       	in	r27, 0x3e	; 62
    66fe:	12 96       	adiw	r26, 0x02	; 2
    6700:	9c 93       	st	X, r25
    6702:	8e 93       	st	-X, r24
    6704:	11 97       	sbiw	r26, 0x01	; 1
    6706:	85 ec       	ldi	r24, 0xC5	; 197
    6708:	94 e0       	ldi	r25, 0x04	; 4
    670a:	14 96       	adiw	r26, 0x04	; 4
    670c:	9c 93       	st	X, r25
    670e:	8e 93       	st	-X, r24
    6710:	13 97       	sbiw	r26, 0x03	; 3
    6712:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    6716:	0f 90       	pop	r0
    6718:	0f 90       	pop	r0
    671a:	0f 90       	pop	r0
    671c:	0f 90       	pop	r0

     Length=strlen(SProductName);
    671e:	de 01       	movw	r26, r28
    6720:	11 96       	adiw	r26, 0x01	; 1
    6722:	fd 01       	movw	r30, r26
    6724:	01 90       	ld	r0, Z+
    6726:	00 20       	and	r0, r0
    6728:	e9 f7       	brne	.-6      	; 0x6724 <GetProductName+0x7e>
    672a:	31 97       	sbiw	r30, 0x01	; 1
    672c:	ea 1b       	sub	r30, r26
    672e:	eb 30       	cpi	r30, 0x0B	; 11
    6730:	08 f0       	brcs	.+2      	; 0x6734 <GetProductName+0x8e>
    6732:	ea e0       	ldi	r30, 0x0A	; 10
    6734:	ae 01       	movw	r20, r28
    6736:	4f 5f       	subi	r20, 0xFF	; 255
    6738:	5f 4f       	sbci	r21, 0xFF	; 255
    673a:	98 01       	movw	r18, r16
    673c:	ba 01       	movw	r22, r20
    673e:	06 c0       	rjmp	.+12     	; 0x674c <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    6740:	db 01       	movw	r26, r22
    6742:	8d 91       	ld	r24, X+
    6744:	bd 01       	movw	r22, r26
    6746:	d9 01       	movw	r26, r18
    6748:	8d 93       	st	X+, r24
    674a:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    674c:	86 2f       	mov	r24, r22
    674e:	84 1b       	sub	r24, r20
    6750:	8e 17       	cp	r24, r30
    6752:	b0 f3       	brcs	.-20     	; 0x6740 <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    6754:	c8 01       	movw	r24, r16
    6756:	8e 0f       	add	r24, r30
    6758:	91 1d       	adc	r25, r1
    675a:	fc 01       	movw	r30, r24
    675c:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    675e:	c8 01       	movw	r24, r16
    6760:	6a e0       	ldi	r22, 0x0A	; 10
    6762:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
}
    6766:	2c 96       	adiw	r28, 0x0c	; 12
    6768:	0f b6       	in	r0, 0x3f	; 63
    676a:	f8 94       	cli
    676c:	de bf       	out	0x3e, r29	; 62
    676e:	0f be       	out	0x3f, r0	; 63
    6770:	cd bf       	out	0x3d, r28	; 61
    6772:	cf 91       	pop	r28
    6774:	df 91       	pop	r29
    6776:	1f 91       	pop	r17
    6778:	0f 91       	pop	r16
    677a:	08 95       	ret

0000677c <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    677c:	2f 92       	push	r2
    677e:	3f 92       	push	r3
    6780:	4f 92       	push	r4
    6782:	5f 92       	push	r5
    6784:	6f 92       	push	r6
    6786:	7f 92       	push	r7
    6788:	8f 92       	push	r8
    678a:	9f 92       	push	r9
    678c:	af 92       	push	r10
    678e:	bf 92       	push	r11
    6790:	cf 92       	push	r12
    6792:	df 92       	push	r13
    6794:	ef 92       	push	r14
    6796:	ff 92       	push	r15
    6798:	0f 93       	push	r16
    679a:	1f 93       	push	r17
    679c:	df 93       	push	r29
    679e:	cf 93       	push	r28
    67a0:	cd b7       	in	r28, 0x3d	; 61
    67a2:	de b7       	in	r29, 0x3e	; 62
    67a4:	c0 5b       	subi	r28, 0xB0	; 176
    67a6:	d0 40       	sbci	r29, 0x00	; 0
    67a8:	0f b6       	in	r0, 0x3f	; 63
    67aa:	f8 94       	cli
    67ac:	de bf       	out	0x3e, r29	; 62
    67ae:	0f be       	out	0x3f, r0	; 63
    67b0:	cd bf       	out	0x3d, r28	; 61
    67b2:	e8 2e       	mov	r14, r24
    67b4:	fe 01       	movw	r30, r28
    67b6:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67b8:	ce 01       	movw	r24, r28
    67ba:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    67bc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67be:	e8 17       	cp	r30, r24
    67c0:	f9 07       	cpc	r31, r25
    67c2:	e1 f7       	brne	.-8      	; 0x67bc <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    67c4:	ce 01       	movw	r24, r28
    67c6:	85 96       	adiw	r24, 0x25	; 37
    67c8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67ca:	e8 17       	cp	r30, r24
    67cc:	f9 07       	cpc	r31, r25
    67ce:	e1 f7       	brne	.-8      	; 0x67c8 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    67d0:	ce 01       	movw	r24, r28
    67d2:	c4 96       	adiw	r24, 0x34	; 52
    67d4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67d6:	e8 17       	cp	r30, r24
    67d8:	f9 07       	cpc	r31, r25
    67da:	e1 f7       	brne	.-8      	; 0x67d4 <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    67dc:	cf 01       	movw	r24, r30
    67de:	3f 01       	movw	r6, r30
    67e0:	0f 96       	adiw	r24, 0x0f	; 15
    67e2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67e4:	e8 17       	cp	r30, r24
    67e6:	f9 07       	cpc	r31, r25
    67e8:	e1 f7       	brne	.-8      	; 0x67e2 <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    67ea:	8e 2d       	mov	r24, r14
    67ec:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
    67f0:	96 e0       	ldi	r25, 0x06	; 6
    67f2:	89 9f       	mul	r24, r25
    67f4:	b0 01       	movw	r22, r0
    67f6:	11 24       	eor	r1, r1
    67f8:	61 5b       	subi	r22, 0xB1	; 177
    67fa:	7f 4f       	sbci	r23, 0xFF	; 255
    67fc:	8e 01       	movw	r16, r28
    67fe:	0f 5f       	subi	r16, 0xFF	; 255
    6800:	1f 4f       	sbci	r17, 0xFF	; 255
    6802:	c8 01       	movw	r24, r16
    6804:	46 e0       	ldi	r20, 0x06	; 6
    6806:	50 e0       	ldi	r21, 0x00	; 0
    6808:	22 e4       	ldi	r18, 0x42	; 66
    680a:	33 e1       	ldi	r19, 0x13	; 19
    680c:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    6810:	2e 2c       	mov	r2, r14
    6812:	33 24       	eor	r3, r3
    6814:	91 01       	movw	r18, r2
    6816:	2f 70       	andi	r18, 0x0F	; 15
    6818:	30 70       	andi	r19, 0x00	; 0
    681a:	85 e3       	ldi	r24, 0x35	; 53
    681c:	90 e0       	ldi	r25, 0x00	; 0
    681e:	28 9f       	mul	r18, r24
    6820:	f0 01       	movw	r30, r0
    6822:	29 9f       	mul	r18, r25
    6824:	f0 0d       	add	r31, r0
    6826:	38 9f       	mul	r19, r24
    6828:	f0 0d       	add	r31, r0
    682a:	11 24       	eor	r1, r1
    682c:	ef 54       	subi	r30, 0x4F	; 79
    682e:	fa 4f       	sbci	r31, 0xFA	; 250
    6830:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    6832:	4f 2c       	mov	r4, r15
    6834:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    6836:	04 0d       	add	r16, r4
    6838:	15 1d       	adc	r17, r5
    683a:	d8 01       	movw	r26, r16
    683c:	8c 91       	ld	r24, X
    683e:	67 e6       	ldi	r22, 0x67	; 103
    6840:	77 e0       	ldi	r23, 0x07	; 7
    6842:	0e 94 53 33 	call	0x66a6	; 0x66a6 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    6846:	97 e0       	ldi	r25, 0x07	; 7
    6848:	89 2e       	mov	r8, r25
    684a:	91 2c       	mov	r9, r1
    684c:	8c 0e       	add	r8, r28
    684e:	9d 1e       	adc	r9, r29
    6850:	8e 2d       	mov	r24, r14
    6852:	b4 01       	movw	r22, r8
    6854:	0e 94 f0 2a 	call	0x55e0	; 0x55e0 <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    6858:	86 e1       	ldi	r24, 0x16	; 22
    685a:	a8 2e       	mov	r10, r24
    685c:	b1 2c       	mov	r11, r1
    685e:	ac 0e       	add	r10, r28
    6860:	bd 1e       	adc	r11, r29
    6862:	8e 2d       	mov	r24, r14
    6864:	b5 01       	movw	r22, r10
    6866:	0e 94 b6 2a 	call	0x556c	; 0x556c <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    686a:	05 e2       	ldi	r16, 0x25	; 37
    686c:	c0 2e       	mov	r12, r16
    686e:	d1 2c       	mov	r13, r1
    6870:	cc 0e       	add	r12, r28
    6872:	dd 1e       	adc	r13, r29
    6874:	8e 2d       	mov	r24, r14
    6876:	6f 2d       	mov	r22, r15
    6878:	a6 01       	movw	r20, r12
    687a:	0e 94 99 2a 	call	0x5532	; 0x5532 <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    687e:	8e 2d       	mov	r24, r14
    6880:	6f 2d       	mov	r22, r15
    6882:	a3 01       	movw	r20, r6
    6884:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    6888:	13 e4       	ldi	r17, 0x43	; 67
    688a:	e1 2e       	mov	r14, r17
    688c:	f1 2c       	mov	r15, r1
    688e:	ec 0e       	add	r14, r28
    6890:	fd 1e       	adc	r15, r29
    6892:	c7 01       	movw	r24, r14
    6894:	0e 94 f7 1a 	call	0x35ee	; 0x35ee <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    6898:	ed b7       	in	r30, 0x3d	; 61
    689a:	fe b7       	in	r31, 0x3e	; 62
    689c:	74 97       	sbiw	r30, 0x14	; 20
    689e:	0f b6       	in	r0, 0x3f	; 63
    68a0:	f8 94       	cli
    68a2:	fe bf       	out	0x3e, r31	; 62
    68a4:	0f be       	out	0x3f, r0	; 63
    68a6:	ed bf       	out	0x3d, r30	; 61
    68a8:	31 96       	adiw	r30, 0x01	; 1
    68aa:	8e 01       	movw	r16, r28
    68ac:	09 5a       	subi	r16, 0xA9	; 169
    68ae:	1f 4f       	sbci	r17, 0xFF	; 255
    68b0:	ad b7       	in	r26, 0x3d	; 61
    68b2:	be b7       	in	r27, 0x3e	; 62
    68b4:	12 96       	adiw	r26, 0x02	; 2
    68b6:	1c 93       	st	X, r17
    68b8:	0e 93       	st	-X, r16
    68ba:	11 97       	sbiw	r26, 0x01	; 1
    68bc:	84 e8       	ldi	r24, 0x84	; 132
    68be:	94 e0       	ldi	r25, 0x04	; 4
    68c0:	93 83       	std	Z+3, r25	; 0x03
    68c2:	82 83       	std	Z+2, r24	; 0x02
    68c4:	35 82       	std	Z+5, r3	; 0x05
    68c6:	24 82       	std	Z+4, r2	; 0x04
    68c8:	57 82       	std	Z+7, r5	; 0x07
    68ca:	46 82       	std	Z+6, r4	; 0x06
    68cc:	87 e6       	ldi	r24, 0x67	; 103
    68ce:	97 e0       	ldi	r25, 0x07	; 7
    68d0:	91 87       	std	Z+9, r25	; 0x09
    68d2:	80 87       	std	Z+8, r24	; 0x08
    68d4:	f3 86       	std	Z+11, r15	; 0x0b
    68d6:	e2 86       	std	Z+10, r14	; 0x0a
    68d8:	95 86       	std	Z+13, r9	; 0x0d
    68da:	84 86       	std	Z+12, r8	; 0x0c
    68dc:	b7 86       	std	Z+15, r11	; 0x0f
    68de:	a6 86       	std	Z+14, r10	; 0x0e
    68e0:	d1 8a       	std	Z+17, r13	; 0x11
    68e2:	c0 8a       	std	Z+16, r12	; 0x10
    68e4:	62 8a       	std	Z+18, r6	; 0x12
    68e6:	73 8a       	std	Z+19, r7	; 0x13
    68e8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 cSum=SumChecksum(strSend);
    68ec:	ad b7       	in	r26, 0x3d	; 61
    68ee:	be b7       	in	r27, 0x3e	; 62
    68f0:	54 96       	adiw	r26, 0x14	; 20
    68f2:	0f b6       	in	r0, 0x3f	; 63
    68f4:	f8 94       	cli
    68f6:	be bf       	out	0x3e, r27	; 62
    68f8:	0f be       	out	0x3f, r0	; 63
    68fa:	ad bf       	out	0x3d, r26	; 61
    68fc:	c8 01       	movw	r24, r16
    68fe:	0e 94 cb 24 	call	0x4996	; 0x4996 <SumChecksum>
    6902:	e8 2e       	mov	r14, r24
	 uart_print(1,0,strSend);
    6904:	81 e0       	ldi	r24, 0x01	; 1
    6906:	60 e0       	ldi	r22, 0x00	; 0
    6908:	a8 01       	movw	r20, r16
    690a:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
    690e:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6910:	c8 01       	movw	r24, r16
    6912:	f9 2e       	mov	r15, r25
    6914:	ce 01       	movw	r24, r28
    6916:	8f 54       	subi	r24, 0x4F	; 79
    6918:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    691a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    691c:	e8 17       	cp	r30, r24
    691e:	f9 07       	cpc	r31, r25
    6920:	e1 f7       	brne	.-8      	; 0x691a <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    6922:	00 d0       	rcall	.+0      	; 0x6924 <GeniusSendLastTransaction+0x1a8>
    6924:	00 d0       	rcall	.+0      	; 0x6926 <GeniusSendLastTransaction+0x1aa>
    6926:	00 d0       	rcall	.+0      	; 0x6928 <GeniusSendLastTransaction+0x1ac>
    6928:	ed b7       	in	r30, 0x3d	; 61
    692a:	fe b7       	in	r31, 0x3e	; 62
    692c:	31 96       	adiw	r30, 0x01	; 1
    692e:	ad b7       	in	r26, 0x3d	; 61
    6930:	be b7       	in	r27, 0x3e	; 62
    6932:	11 96       	adiw	r26, 0x01	; 1
    6934:	0c 93       	st	X, r16
    6936:	11 97       	sbiw	r26, 0x01	; 1
    6938:	12 96       	adiw	r26, 0x02	; 2
    693a:	fc 92       	st	X, r15
    693c:	81 e8       	ldi	r24, 0x81	; 129
    693e:	94 e0       	ldi	r25, 0x04	; 4
    6940:	93 83       	std	Z+3, r25	; 0x03
    6942:	82 83       	std	Z+2, r24	; 0x02
    6944:	e4 82       	std	Z+4, r14	; 0x04
    6946:	15 82       	std	Z+5, r1	; 0x05
    6948:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 uart_print(1,1,strSend);	 
    694c:	ed b7       	in	r30, 0x3d	; 61
    694e:	fe b7       	in	r31, 0x3e	; 62
    6950:	36 96       	adiw	r30, 0x06	; 6
    6952:	0f b6       	in	r0, 0x3f	; 63
    6954:	f8 94       	cli
    6956:	fe bf       	out	0x3e, r31	; 62
    6958:	0f be       	out	0x3f, r0	; 63
    695a:	ed bf       	out	0x3d, r30	; 61
    695c:	81 e0       	ldi	r24, 0x01	; 1
    695e:	61 e0       	ldi	r22, 0x01	; 1
    6960:	40 2f       	mov	r20, r16
    6962:	5f 2d       	mov	r21, r15
    6964:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
}
    6968:	c0 55       	subi	r28, 0x50	; 80
    696a:	df 4f       	sbci	r29, 0xFF	; 255
    696c:	0f b6       	in	r0, 0x3f	; 63
    696e:	f8 94       	cli
    6970:	de bf       	out	0x3e, r29	; 62
    6972:	0f be       	out	0x3f, r0	; 63
    6974:	cd bf       	out	0x3d, r28	; 61
    6976:	cf 91       	pop	r28
    6978:	df 91       	pop	r29
    697a:	1f 91       	pop	r17
    697c:	0f 91       	pop	r16
    697e:	ff 90       	pop	r15
    6980:	ef 90       	pop	r14
    6982:	df 90       	pop	r13
    6984:	cf 90       	pop	r12
    6986:	bf 90       	pop	r11
    6988:	af 90       	pop	r10
    698a:	9f 90       	pop	r9
    698c:	8f 90       	pop	r8
    698e:	7f 90       	pop	r7
    6990:	6f 90       	pop	r6
    6992:	5f 90       	pop	r5
    6994:	4f 90       	pop	r4
    6996:	3f 90       	pop	r3
    6998:	2f 90       	pop	r2
    699a:	08 95       	ret

0000699c <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    699c:	80 91 c8 01 	lds	r24, 0x01C8
    69a0:	83 30       	cpi	r24, 0x03	; 3
    69a2:	61 f1       	breq	.+88     	; 0x69fc <systemGeniusProtocol+0x60>
    69a4:	84 30       	cpi	r24, 0x04	; 4
    69a6:	28 f4       	brcc	.+10     	; 0x69b2 <systemGeniusProtocol+0x16>
    69a8:	81 30       	cpi	r24, 0x01	; 1
    69aa:	81 f0       	breq	.+32     	; 0x69cc <systemGeniusProtocol+0x30>
    69ac:	82 30       	cpi	r24, 0x02	; 2
    69ae:	c0 f4       	brcc	.+48     	; 0x69e0 <systemGeniusProtocol+0x44>
    69b0:	09 c0       	rjmp	.+18     	; 0x69c4 <systemGeniusProtocol+0x28>
    69b2:	85 30       	cpi	r24, 0x05	; 5
    69b4:	09 f4       	brne	.+2      	; 0x69b8 <systemGeniusProtocol+0x1c>
    69b6:	43 c0       	rjmp	.+134    	; 0x6a3e <systemGeniusProtocol+0xa2>
    69b8:	85 30       	cpi	r24, 0x05	; 5
    69ba:	a0 f1       	brcs	.+104    	; 0x6a24 <systemGeniusProtocol+0x88>
    69bc:	86 30       	cpi	r24, 0x06	; 6
    69be:	09 f0       	breq	.+2      	; 0x69c2 <systemGeniusProtocol+0x26>
    69c0:	58 c0       	rjmp	.+176    	; 0x6a72 <systemGeniusProtocol+0xd6>
    69c2:	45 c0       	rjmp	.+138    	; 0x6a4e <systemGeniusProtocol+0xb2>
	 case gpInitScan:
	      iPumpID=1;
    69c4:	81 e0       	ldi	r24, 0x01	; 1
    69c6:	80 93 c7 01 	sts	0x01C7, r24
    69ca:	3e c0       	rjmp	.+124    	; 0x6a48 <systemGeniusProtocol+0xac>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    69cc:	80 91 bf 01 	lds	r24, 0x01BF
    69d0:	0e 94 87 1a 	call	0x350e	; 0x350e <GetIncomingTransStatus>
    69d4:	82 30       	cpi	r24, 0x02	; 2
    69d6:	09 f0       	breq	.+2      	; 0x69da <systemGeniusProtocol+0x3e>
    69d8:	4c c0       	rjmp	.+152    	; 0x6a72 <systemGeniusProtocol+0xd6>
		      IsTotalizerReceived=False;
    69da:	10 92 b1 01 	sts	0x01B1, r1
    69de:	34 c0       	rjmp	.+104    	; 0x6a48 <systemGeniusProtocol+0xac>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    69e0:	90 91 c7 01 	lds	r25, 0x01C7
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    69e4:	85 e0       	ldi	r24, 0x05	; 5
    69e6:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
    69ea:	90 93 e0 0d 	sts	0x0DE0, r25
     IsControlPooling=True;
    69ee:	81 e0       	ldi	r24, 0x01	; 1
    69f0:	80 93 86 01 	sts	0x0186, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    69f4:	10 92 91 0e 	sts	0x0E91, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    69f8:	83 e0       	ldi	r24, 0x03	; 3
    69fa:	26 c0       	rjmp	.+76     	; 0x6a48 <systemGeniusProtocol+0xac>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    69fc:	80 91 b1 01 	lds	r24, 0x01B1
    6a00:	81 30       	cpi	r24, 0x01	; 1
    6a02:	59 f4       	brne	.+22     	; 0x6a1a <systemGeniusProtocol+0x7e>
    6a04:	90 91 f9 0d 	lds	r25, 0x0DF9
    6a08:	80 91 c7 01 	lds	r24, 0x01C7
    6a0c:	98 17       	cp	r25, r24
    6a0e:	29 f4       	brne	.+10     	; 0x6a1a <systemGeniusProtocol+0x7e>
		      IsTotalizerReceived=False;
    6a10:	10 92 b1 01 	sts	0x01B1, r1
			  stGeniusProtocol=gpSendTransactionData;
    6a14:	84 e0       	ldi	r24, 0x04	; 4
    6a16:	80 93 c8 01 	sts	0x01C8, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    6a1a:	80 91 91 0e 	lds	r24, 0x0E91
    6a1e:	85 31       	cpi	r24, 0x15	; 21
    6a20:	40 f1       	brcs	.+80     	; 0x6a72 <systemGeniusProtocol+0xd6>
    6a22:	11 c0       	rjmp	.+34     	; 0x6a46 <systemGeniusProtocol+0xaa>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    6a24:	80 91 c7 01 	lds	r24, 0x01C7
    6a28:	0e 94 be 33 	call	0x677c	; 0x677c <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    6a2c:	80 91 c7 01 	lds	r24, 0x01C7
    6a30:	63 e0       	ldi	r22, 0x03	; 3
    6a32:	0e 94 55 1a 	call	0x34aa	; 0x34aa <SetIncomingTransStatus>
		  
		  TimSend=0;
    6a36:	10 92 91 0e 	sts	0x0E91, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    6a3a:	85 e0       	ldi	r24, 0x05	; 5
    6a3c:	05 c0       	rjmp	.+10     	; 0x6a48 <systemGeniusProtocol+0xac>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    6a3e:	80 91 91 0e 	lds	r24, 0x0E91
    6a42:	82 30       	cpi	r24, 0x02	; 2
    6a44:	b0 f0       	brcs	.+44     	; 0x6a72 <systemGeniusProtocol+0xd6>
    6a46:	86 e0       	ldi	r24, 0x06	; 6
    6a48:	80 93 c8 01 	sts	0x01C8, r24
    6a4c:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    6a4e:	20 91 c7 01 	lds	r18, 0x01C7
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a52:	e1 99       	sbic	0x1c, 1	; 28
    6a54:	fe cf       	rjmp	.-4      	; 0x6a52 <systemGeniusProtocol+0xb6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a56:	84 e4       	ldi	r24, 0x44	; 68
    6a58:	91 e0       	ldi	r25, 0x01	; 1
    6a5a:	9f bb       	out	0x1f, r25	; 31
    6a5c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a5e:	e0 9a       	sbi	0x1c, 0	; 28
    6a60:	8d b3       	in	r24, 0x1d	; 29
    6a62:	82 17       	cp	r24, r18
    6a64:	30 f0       	brcs	.+12     	; 0x6a72 <systemGeniusProtocol+0xd6>
		      iPumpID++;
    6a66:	2f 5f       	subi	r18, 0xFF	; 255
    6a68:	20 93 c7 01 	sts	0x01C7, r18
              stGeniusProtocol=gpScanNewTransaction;
    6a6c:	81 e0       	ldi	r24, 0x01	; 1
    6a6e:	80 93 c8 01 	sts	0x01C8, r24
    6a72:	08 95       	ret

00006a74 <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    6a74:	ef 92       	push	r14
    6a76:	ff 92       	push	r15
    6a78:	0f 93       	push	r16
    6a7a:	1f 93       	push	r17
    6a7c:	18 2f       	mov	r17, r24
    6a7e:	09 2f       	mov	r16, r25
    6a80:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    6a82:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
	 RemSpaceLead(Source);
    6a86:	81 2f       	mov	r24, r17
    6a88:	90 2f       	mov	r25, r16
    6a8a:	0e 94 df 28 	call	0x51be	; 0x51be <RemSpaceLead>
	 srcLength=strlen(Source);
    6a8e:	a1 2f       	mov	r26, r17
    6a90:	b0 2f       	mov	r27, r16
    6a92:	fd 01       	movw	r30, r26
    6a94:	01 90       	ld	r0, Z+
    6a96:	00 20       	and	r0, r0
    6a98:	e9 f7       	brne	.-6      	; 0x6a94 <StrAlignCenter+0x20>
    6a9a:	31 97       	sbiw	r30, 0x01	; 1
    6a9c:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    6a9e:	c7 01       	movw	r24, r14
    6aa0:	8e 1b       	sub	r24, r30
    6aa2:	91 09       	sbc	r25, r1
    6aa4:	96 95       	lsr	r25
    6aa6:	87 95       	ror	r24
    6aa8:	e8 0f       	add	r30, r24
    6aaa:	81 2f       	mov	r24, r17
    6aac:	90 2f       	mov	r25, r16
    6aae:	6e 2f       	mov	r22, r30
    6ab0:	0e 94 b7 30 	call	0x616e	; 0x616e <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    6ab4:	81 2f       	mov	r24, r17
    6ab6:	90 2f       	mov	r25, r16
    6ab8:	6e 2d       	mov	r22, r14
    6aba:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
}
    6abe:	1f 91       	pop	r17
    6ac0:	0f 91       	pop	r16
    6ac2:	ff 90       	pop	r15
    6ac4:	ef 90       	pop	r14
    6ac6:	08 95       	ret

00006ac8 <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    6ac8:	bf 92       	push	r11
    6aca:	cf 92       	push	r12
    6acc:	df 92       	push	r13
    6ace:	ef 92       	push	r14
    6ad0:	ff 92       	push	r15
    6ad2:	0f 93       	push	r16
    6ad4:	1f 93       	push	r17
    6ad6:	df 93       	push	r29
    6ad8:	cf 93       	push	r28
    6ada:	cd b7       	in	r28, 0x3d	; 61
    6adc:	de b7       	in	r29, 0x3e	; 62
    6ade:	6e 97       	sbiw	r28, 0x1e	; 30
    6ae0:	0f b6       	in	r0, 0x3f	; 63
    6ae2:	f8 94       	cli
    6ae4:	de bf       	out	0x3e, r29	; 62
    6ae6:	0f be       	out	0x3f, r0	; 63
    6ae8:	cd bf       	out	0x3d, r28	; 61
    6aea:	8c 01       	movw	r16, r24
    6aec:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    6aee:	fc 01       	movw	r30, r24
    6af0:	01 90       	ld	r0, Z+
    6af2:	00 20       	and	r0, r0
    6af4:	e9 f7       	brne	.-6      	; 0x6af0 <AddCharLead+0x28>
    6af6:	31 97       	sbiw	r30, 0x01	; 1
    6af8:	2e 2f       	mov	r18, r30
    6afa:	28 1b       	sub	r18, r24

	 if (Size>Length){
    6afc:	24 17       	cp	r18, r20
    6afe:	d0 f5       	brcc	.+116    	; 0x6b74 <AddCharLead+0xac>
    6b00:	ae 01       	movw	r20, r28
    6b02:	4f 5f       	subi	r20, 0xFF	; 255
    6b04:	5f 4f       	sbci	r21, 0xFF	; 255
    6b06:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    6b08:	b4 2e       	mov	r11, r20
    6b0a:	01 c0       	rjmp	.+2      	; 0x6b0e <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    6b0c:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    6b0e:	8e 2f       	mov	r24, r30
    6b10:	8b 19       	sub	r24, r11
    6b12:	8e 15       	cp	r24, r14
    6b14:	d8 f3       	brcs	.-10     	; 0x6b0c <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    6b16:	6e 2d       	mov	r22, r14
    6b18:	70 e0       	ldi	r23, 0x00	; 0
    6b1a:	ce 01       	movw	r24, r28
    6b1c:	01 96       	adiw	r24, 0x01	; 1
    6b1e:	fc 01       	movw	r30, r24
    6b20:	e6 0f       	add	r30, r22
    6b22:	f7 1f       	adc	r31, r23
    6b24:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    6b26:	fe 2c       	mov	r15, r14
    6b28:	f2 1a       	sub	r15, r18
    6b2a:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    6b2c:	30 e0       	ldi	r19, 0x00	; 0
    6b2e:	26 1b       	sub	r18, r22
    6b30:	37 0b       	sbc	r19, r23
    6b32:	0c c0       	rjmp	.+24     	; 0x6b4c <AddCharLead+0x84>
    6b34:	ef 2d       	mov	r30, r15
    6b36:	f0 e0       	ldi	r31, 0x00	; 0
    6b38:	d6 01       	movw	r26, r12
    6b3a:	ae 0f       	add	r26, r30
    6b3c:	bf 1f       	adc	r27, r31
    6b3e:	e0 0f       	add	r30, r16
    6b40:	f1 1f       	adc	r31, r17
    6b42:	e2 0f       	add	r30, r18
    6b44:	f3 1f       	adc	r31, r19
    6b46:	80 81       	ld	r24, Z
    6b48:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    6b4a:	f3 94       	inc	r15
    6b4c:	fe 14       	cp	r15, r14
    6b4e:	90 f3       	brcs	.-28     	; 0x6b34 <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    6b50:	6c 0d       	add	r22, r12
    6b52:	7d 1d       	adc	r23, r13
    6b54:	db 01       	movw	r26, r22
    6b56:	1c 92       	st	X, r1
    6b58:	f8 01       	movw	r30, r16
    6b5a:	04 c0       	rjmp	.+8      	; 0x6b64 <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    6b5c:	da 01       	movw	r26, r20
    6b5e:	8d 91       	ld	r24, X+
    6b60:	ad 01       	movw	r20, r26
    6b62:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    6b64:	84 2f       	mov	r24, r20
    6b66:	8b 19       	sub	r24, r11
    6b68:	8e 15       	cp	r24, r14
    6b6a:	c0 f3       	brcs	.-16     	; 0x6b5c <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    6b6c:	0e 0d       	add	r16, r14
    6b6e:	11 1d       	adc	r17, r1
    6b70:	f8 01       	movw	r30, r16
    6b72:	10 82       	st	Z, r1
	 }
}
    6b74:	6e 96       	adiw	r28, 0x1e	; 30
    6b76:	0f b6       	in	r0, 0x3f	; 63
    6b78:	f8 94       	cli
    6b7a:	de bf       	out	0x3e, r29	; 62
    6b7c:	0f be       	out	0x3f, r0	; 63
    6b7e:	cd bf       	out	0x3d, r28	; 61
    6b80:	cf 91       	pop	r28
    6b82:	df 91       	pop	r29
    6b84:	1f 91       	pop	r17
    6b86:	0f 91       	pop	r16
    6b88:	ff 90       	pop	r15
    6b8a:	ef 90       	pop	r14
    6b8c:	df 90       	pop	r13
    6b8e:	cf 90       	pop	r12
    6b90:	bf 90       	pop	r11
    6b92:	08 95       	ret

00006b94 <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    6b94:	cf 93       	push	r28
    6b96:	df 93       	push	r29
    6b98:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    6b9a:	dc 01       	movw	r26, r24
    6b9c:	0d 90       	ld	r0, X+
    6b9e:	00 20       	and	r0, r0
    6ba0:	e9 f7       	brne	.-6      	; 0x6b9c <AddCharLag+0x8>
    6ba2:	11 97       	sbiw	r26, 0x01	; 1
    6ba4:	a8 1b       	sub	r26, r24
    6ba6:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    6ba8:	a4 17       	cp	r26, r20
    6baa:	58 f4       	brcc	.+22     	; 0x6bc2 <AddCharLag+0x2e>
    6bac:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    6bae:	fe 01       	movw	r30, r28
    6bb0:	e8 0f       	add	r30, r24
    6bb2:	f1 1d       	adc	r31, r1
    6bb4:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    6bb6:	8f 5f       	subi	r24, 0xFF	; 255
    6bb8:	84 17       	cp	r24, r20
    6bba:	c8 f3       	brcs	.-14     	; 0x6bae <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    6bbc:	c4 0f       	add	r28, r20
    6bbe:	d1 1d       	adc	r29, r1
    6bc0:	18 82       	st	Y, r1
  }

}
    6bc2:	df 91       	pop	r29
    6bc4:	cf 91       	pop	r28
    6bc6:	08 95       	ret

00006bc8 <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    6bc8:	cf 92       	push	r12
    6bca:	df 92       	push	r13
    6bcc:	ef 92       	push	r14
    6bce:	ff 92       	push	r15
    6bd0:	0f 93       	push	r16
    6bd2:	1f 93       	push	r17
    6bd4:	cf 93       	push	r28
    6bd6:	df 93       	push	r29
    6bd8:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    6bda:	dc 01       	movw	r26, r24
    6bdc:	0d 90       	ld	r0, X+
    6bde:	00 20       	and	r0, r0
    6be0:	e9 f7       	brne	.-6      	; 0x6bdc <CountTotalizerSatus+0x14>
    6be2:	8d 01       	movw	r16, r26
    6be4:	01 50       	subi	r16, 0x01	; 1
    6be6:	10 40       	sbci	r17, 0x00	; 0
    6be8:	08 1b       	sub	r16, r24
    6bea:	19 0b       	sbc	r17, r25
    6bec:	cc 24       	eor	r12, r12
    6bee:	dd 24       	eor	r13, r13
    6bf0:	0a c0       	rjmp	.+20     	; 0x6c06 <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    6bf2:	84 e1       	ldi	r24, 0x14	; 20
    6bf4:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    6bf8:	ce 0d       	add	r28, r14
    6bfa:	df 1d       	adc	r29, r15
    6bfc:	98 81       	ld	r25, Y
    6bfe:	98 17       	cp	r25, r24
    6c00:	09 f4       	brne	.+2      	; 0x6c04 <CountTotalizerSatus+0x3c>
		      Result++;		  
    6c02:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    6c04:	c3 94       	inc	r12
    6c06:	cc 2d       	mov	r28, r12
    6c08:	d0 e0       	ldi	r29, 0x00	; 0
    6c0a:	c0 17       	cp	r28, r16
    6c0c:	d1 07       	cpc	r29, r17
    6c0e:	88 f3       	brcs	.-30     	; 0x6bf2 <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    6c10:	8d 2d       	mov	r24, r13
    6c12:	df 91       	pop	r29
    6c14:	cf 91       	pop	r28
    6c16:	1f 91       	pop	r17
    6c18:	0f 91       	pop	r16
    6c1a:	ff 90       	pop	r15
    6c1c:	ef 90       	pop	r14
    6c1e:	df 90       	pop	r13
    6c20:	cf 90       	pop	r12
    6c22:	08 95       	ret

00006c24 <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    6c24:	1f 93       	push	r17
    6c26:	df 93       	push	r29
    6c28:	cf 93       	push	r28
    6c2a:	cd b7       	in	r28, 0x3d	; 61
    6c2c:	de b7       	in	r29, 0x3e	; 62
    6c2e:	64 97       	sbiw	r28, 0x14	; 20
    6c30:	0f b6       	in	r0, 0x3f	; 63
    6c32:	f8 94       	cli
    6c34:	de bf       	out	0x3e, r29	; 62
    6c36:	0f be       	out	0x3f, r0	; 63
    6c38:	cd bf       	out	0x3d, r28	; 61
    6c3a:	16 2f       	mov	r17, r22
    6c3c:	50 e0       	ldi	r21, 0x00	; 0
    6c3e:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    6c40:	be 01       	movw	r22, r28
    6c42:	6f 5f       	subi	r22, 0xFF	; 255
    6c44:	7f 4f       	sbci	r23, 0xFF	; 255
    6c46:	0c c0       	rjmp	.+24     	; 0x6c60 <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    6c48:	28 0f       	add	r18, r24
    6c4a:	39 1f       	adc	r19, r25
    6c4c:	d9 01       	movw	r26, r18
    6c4e:	2c 91       	ld	r18, X
    6c50:	21 17       	cp	r18, r17
    6c52:	29 f0       	breq	.+10     	; 0x6c5e <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    6c54:	fb 01       	movw	r30, r22
    6c56:	e4 0f       	add	r30, r20
    6c58:	f1 1d       	adc	r31, r1
    6c5a:	20 83       	st	Z, r18
			 iAdd++;
    6c5c:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    6c5e:	5f 5f       	subi	r21, 0xFF	; 255
    6c60:	25 2f       	mov	r18, r21
    6c62:	30 e0       	ldi	r19, 0x00	; 0
    6c64:	fc 01       	movw	r30, r24
    6c66:	01 90       	ld	r0, Z+
    6c68:	00 20       	and	r0, r0
    6c6a:	e9 f7       	brne	.-6      	; 0x6c66 <RemoveChar+0x42>
    6c6c:	31 97       	sbiw	r30, 0x01	; 1
    6c6e:	e8 1b       	sub	r30, r24
    6c70:	f9 0b       	sbc	r31, r25
    6c72:	2e 17       	cp	r18, r30
    6c74:	3f 07       	cpc	r19, r31
    6c76:	40 f3       	brcs	.-48     	; 0x6c48 <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    6c78:	9e 01       	movw	r18, r28
    6c7a:	2f 5f       	subi	r18, 0xFF	; 255
    6c7c:	3f 4f       	sbci	r19, 0xFF	; 255
    6c7e:	f9 01       	movw	r30, r18
    6c80:	e4 0f       	add	r30, r20
    6c82:	f1 1d       	adc	r31, r1
    6c84:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    6c86:	00 d0       	rcall	.+0      	; 0x6c88 <RemoveChar+0x64>
    6c88:	00 d0       	rcall	.+0      	; 0x6c8a <RemoveChar+0x66>
    6c8a:	00 d0       	rcall	.+0      	; 0x6c8c <RemoveChar+0x68>
    6c8c:	ed b7       	in	r30, 0x3d	; 61
    6c8e:	fe b7       	in	r31, 0x3e	; 62
    6c90:	31 96       	adiw	r30, 0x01	; 1
    6c92:	ad b7       	in	r26, 0x3d	; 61
    6c94:	be b7       	in	r27, 0x3e	; 62
    6c96:	12 96       	adiw	r26, 0x02	; 2
    6c98:	9c 93       	st	X, r25
    6c9a:	8e 93       	st	-X, r24
    6c9c:	11 97       	sbiw	r26, 0x01	; 1
    6c9e:	83 eb       	ldi	r24, 0xB3	; 179
    6ca0:	98 e1       	ldi	r25, 0x18	; 24
    6ca2:	93 83       	std	Z+3, r25	; 0x03
    6ca4:	82 83       	std	Z+2, r24	; 0x02
    6ca6:	35 83       	std	Z+5, r19	; 0x05
    6ca8:	24 83       	std	Z+4, r18	; 0x04
    6caa:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    6cae:	ed b7       	in	r30, 0x3d	; 61
    6cb0:	fe b7       	in	r31, 0x3e	; 62
    6cb2:	36 96       	adiw	r30, 0x06	; 6
    6cb4:	0f b6       	in	r0, 0x3f	; 63
    6cb6:	f8 94       	cli
    6cb8:	fe bf       	out	0x3e, r31	; 62
    6cba:	0f be       	out	0x3f, r0	; 63
    6cbc:	ed bf       	out	0x3d, r30	; 61
}
    6cbe:	64 96       	adiw	r28, 0x14	; 20
    6cc0:	0f b6       	in	r0, 0x3f	; 63
    6cc2:	f8 94       	cli
    6cc4:	de bf       	out	0x3e, r29	; 62
    6cc6:	0f be       	out	0x3f, r0	; 63
    6cc8:	cd bf       	out	0x3d, r28	; 61
    6cca:	cf 91       	pop	r28
    6ccc:	df 91       	pop	r29
    6cce:	1f 91       	pop	r17
    6cd0:	08 95       	ret

00006cd2 <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    6cd2:	8f 92       	push	r8
    6cd4:	9f 92       	push	r9
    6cd6:	bf 92       	push	r11
    6cd8:	cf 92       	push	r12
    6cda:	df 92       	push	r13
    6cdc:	ef 92       	push	r14
    6cde:	ff 92       	push	r15
    6ce0:	0f 93       	push	r16
    6ce2:	1f 93       	push	r17
    6ce4:	df 93       	push	r29
    6ce6:	cf 93       	push	r28
    6ce8:	cd b7       	in	r28, 0x3d	; 61
    6cea:	de b7       	in	r29, 0x3e	; 62
    6cec:	2f 97       	sbiw	r28, 0x0f	; 15
    6cee:	0f b6       	in	r0, 0x3f	; 63
    6cf0:	f8 94       	cli
    6cf2:	de bf       	out	0x3e, r29	; 62
    6cf4:	0f be       	out	0x3f, r0	; 63
    6cf6:	cd bf       	out	0x3d, r28	; 61
    6cf8:	6c 01       	movw	r12, r24
    6cfa:	bb 24       	eor	r11, r11
    6cfc:	40 e0       	ldi	r20, 0x00	; 0
    6cfe:	4e 01       	movw	r8, r28
    6d00:	08 94       	sec
    6d02:	81 1c       	adc	r8, r1
    6d04:	91 1c       	adc	r9, r1
    6d06:	12 c0       	rjmp	.+36     	; 0x6d2c <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    6d08:	86 01       	movw	r16, r12
    6d0a:	0e 0d       	add	r16, r14
    6d0c:	1f 1d       	adc	r17, r15
    6d0e:	d8 01       	movw	r26, r16
    6d10:	6c 91       	ld	r22, X
    6d12:	60 53       	subi	r22, 0x30	; 48
    6d14:	80 e0       	ldi	r24, 0x00	; 0
    6d16:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <GeniusCalc>
    6d1a:	e8 0c       	add	r14, r8
    6d1c:	f9 1c       	adc	r15, r9
    6d1e:	80 5d       	subi	r24, 0xD0	; 208
    6d20:	f7 01       	movw	r30, r14
    6d22:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    6d24:	d8 01       	movw	r26, r16
    6d26:	4c 91       	ld	r20, X
    6d28:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    6d2a:	b3 94       	inc	r11
    6d2c:	eb 2c       	mov	r14, r11
    6d2e:	ff 24       	eor	r15, r15
    6d30:	d6 01       	movw	r26, r12
    6d32:	0d 90       	ld	r0, X+
    6d34:	00 20       	and	r0, r0
    6d36:	e9 f7       	brne	.-6      	; 0x6d32 <WrapCode+0x60>
    6d38:	11 97       	sbiw	r26, 0x01	; 1
    6d3a:	ac 19       	sub	r26, r12
    6d3c:	bd 09       	sbc	r27, r13
    6d3e:	ea 16       	cp	r14, r26
    6d40:	fb 06       	cpc	r15, r27
    6d42:	10 f3       	brcs	.-60     	; 0x6d08 <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    6d44:	a8 0d       	add	r26, r8
    6d46:	b9 1d       	adc	r27, r9
    6d48:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    6d4a:	00 d0       	rcall	.+0      	; 0x6d4c <WrapCode+0x7a>
    6d4c:	00 d0       	rcall	.+0      	; 0x6d4e <WrapCode+0x7c>
    6d4e:	00 d0       	rcall	.+0      	; 0x6d50 <WrapCode+0x7e>
    6d50:	ed b7       	in	r30, 0x3d	; 61
    6d52:	fe b7       	in	r31, 0x3e	; 62
    6d54:	31 96       	adiw	r30, 0x01	; 1
    6d56:	ad b7       	in	r26, 0x3d	; 61
    6d58:	be b7       	in	r27, 0x3e	; 62
    6d5a:	12 96       	adiw	r26, 0x02	; 2
    6d5c:	dc 92       	st	X, r13
    6d5e:	ce 92       	st	-X, r12
    6d60:	11 97       	sbiw	r26, 0x01	; 1
    6d62:	8e eb       	ldi	r24, 0xBE	; 190
    6d64:	98 e1       	ldi	r25, 0x18	; 24
    6d66:	93 83       	std	Z+3, r25	; 0x03
    6d68:	82 83       	std	Z+2, r24	; 0x02
    6d6a:	95 82       	std	Z+5, r9	; 0x05
    6d6c:	84 82       	std	Z+4, r8	; 0x04
    6d6e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    6d72:	ed b7       	in	r30, 0x3d	; 61
    6d74:	fe b7       	in	r31, 0x3e	; 62
    6d76:	36 96       	adiw	r30, 0x06	; 6
    6d78:	0f b6       	in	r0, 0x3f	; 63
    6d7a:	f8 94       	cli
    6d7c:	fe bf       	out	0x3e, r31	; 62
    6d7e:	0f be       	out	0x3f, r0	; 63
    6d80:	ed bf       	out	0x3d, r30	; 61
}
    6d82:	2f 96       	adiw	r28, 0x0f	; 15
    6d84:	0f b6       	in	r0, 0x3f	; 63
    6d86:	f8 94       	cli
    6d88:	de bf       	out	0x3e, r29	; 62
    6d8a:	0f be       	out	0x3f, r0	; 63
    6d8c:	cd bf       	out	0x3d, r28	; 61
    6d8e:	cf 91       	pop	r28
    6d90:	df 91       	pop	r29
    6d92:	1f 91       	pop	r17
    6d94:	0f 91       	pop	r16
    6d96:	ff 90       	pop	r15
    6d98:	ef 90       	pop	r14
    6d9a:	df 90       	pop	r13
    6d9c:	cf 90       	pop	r12
    6d9e:	bf 90       	pop	r11
    6da0:	9f 90       	pop	r9
    6da2:	8f 90       	pop	r8
    6da4:	08 95       	ret

00006da6 <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    6da6:	8f 92       	push	r8
    6da8:	9f 92       	push	r9
    6daa:	af 92       	push	r10
    6dac:	bf 92       	push	r11
    6dae:	df 92       	push	r13
    6db0:	ef 92       	push	r14
    6db2:	ff 92       	push	r15
    6db4:	0f 93       	push	r16
    6db6:	1f 93       	push	r17
    6db8:	df 93       	push	r29
    6dba:	cf 93       	push	r28
    6dbc:	cd b7       	in	r28, 0x3d	; 61
    6dbe:	de b7       	in	r29, 0x3e	; 62
    6dc0:	2d 97       	sbiw	r28, 0x0d	; 13
    6dc2:	0f b6       	in	r0, 0x3f	; 63
    6dc4:	f8 94       	cli
    6dc6:	de bf       	out	0x3e, r29	; 62
    6dc8:	0f be       	out	0x3f, r0	; 63
    6dca:	cd bf       	out	0x3d, r28	; 61
    6dcc:	9c 01       	movw	r18, r24
    6dce:	7b 01       	movw	r14, r22
    6dd0:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    6dd2:	dc 01       	movw	r26, r24
    6dd4:	15 96       	adiw	r26, 0x05	; 5
    6dd6:	8c 91       	ld	r24, X
    6dd8:	90 e0       	ldi	r25, 0x00	; 0
    6dda:	c0 97       	sbiw	r24, 0x30	; 48
    6ddc:	68 e0       	ldi	r22, 0x08	; 8
    6dde:	70 e0       	ldi	r23, 0x00	; 0
    6de0:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    6de4:	f7 01       	movw	r30, r14
    6de6:	e8 0f       	add	r30, r24
    6de8:	f1 1d       	adc	r31, r1
    6dea:	80 81       	ld	r24, Z
    6dec:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    6dee:	f9 01       	movw	r30, r18
    6df0:	86 81       	ldd	r24, Z+6	; 0x06
    6df2:	90 e0       	ldi	r25, 0x00	; 0
    6df4:	c0 97       	sbiw	r24, 0x30	; 48
    6df6:	68 e0       	ldi	r22, 0x08	; 8
    6df8:	70 e0       	ldi	r23, 0x00	; 0
    6dfa:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    6dfe:	f7 01       	movw	r30, r14
    6e00:	e8 0f       	add	r30, r24
    6e02:	f1 1d       	adc	r31, r1
    6e04:	80 81       	ld	r24, Z
    6e06:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    6e08:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    6e0a:	8d b7       	in	r24, 0x3d	; 61
    6e0c:	9e b7       	in	r25, 0x3e	; 62
    6e0e:	08 97       	sbiw	r24, 0x08	; 8
    6e10:	0f b6       	in	r0, 0x3f	; 63
    6e12:	f8 94       	cli
    6e14:	9e bf       	out	0x3e, r25	; 62
    6e16:	0f be       	out	0x3f, r0	; 63
    6e18:	8d bf       	out	0x3d, r24	; 61
    6e1a:	ed b7       	in	r30, 0x3d	; 61
    6e1c:	fe b7       	in	r31, 0x3e	; 62
    6e1e:	31 96       	adiw	r30, 0x01	; 1
    6e20:	8e 01       	movw	r16, r28
    6e22:	0c 5f       	subi	r16, 0xFC	; 252
    6e24:	1f 4f       	sbci	r17, 0xFF	; 255
    6e26:	ad b7       	in	r26, 0x3d	; 61
    6e28:	be b7       	in	r27, 0x3e	; 62
    6e2a:	12 96       	adiw	r26, 0x02	; 2
    6e2c:	1c 93       	st	X, r17
    6e2e:	0e 93       	st	-X, r16
    6e30:	11 97       	sbiw	r26, 0x01	; 1
    6e32:	8e ea       	ldi	r24, 0xAE	; 174
    6e34:	98 e1       	ldi	r25, 0x18	; 24
    6e36:	93 83       	std	Z+3, r25	; 0x03
    6e38:	82 83       	std	Z+2, r24	; 0x02
    6e3a:	35 83       	std	Z+5, r19	; 0x05
    6e3c:	24 83       	std	Z+4, r18	; 0x04
    6e3e:	ce 01       	movw	r24, r28
    6e40:	01 96       	adiw	r24, 0x01	; 1
    6e42:	97 83       	std	Z+7, r25	; 0x07
    6e44:	86 83       	std	Z+6, r24	; 0x06
    6e46:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    6e4a:	dd 24       	eor	r13, r13
    6e4c:	ed b7       	in	r30, 0x3d	; 61
    6e4e:	fe b7       	in	r31, 0x3e	; 62
    6e50:	38 96       	adiw	r30, 0x08	; 8
    6e52:	0f b6       	in	r0, 0x3f	; 63
    6e54:	f8 94       	cli
    6e56:	fe bf       	out	0x3e, r31	; 62
    6e58:	0f be       	out	0x3f, r0	; 63
    6e5a:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    6e5c:	48 01       	movw	r8, r16
    6e5e:	13 c0       	rjmp	.+38     	; 0x6e86 <GenerateKeyStamp+0xe0>
    6e60:	f4 01       	movw	r30, r8
    6e62:	e0 0f       	add	r30, r16
    6e64:	f1 1f       	adc	r31, r17
    6e66:	60 81       	ld	r22, Z
    6e68:	60 53       	subi	r22, 0x30	; 48
    6e6a:	f7 01       	movw	r30, r14
    6e6c:	e0 0f       	add	r30, r16
    6e6e:	f1 1f       	adc	r31, r17
    6e70:	40 81       	ld	r20, Z
    6e72:	40 53       	subi	r20, 0x30	; 48
    6e74:	81 e0       	ldi	r24, 0x01	; 1
    6e76:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <GeniusCalc>
    6e7a:	0a 0d       	add	r16, r10
    6e7c:	1b 1d       	adc	r17, r11
    6e7e:	80 5d       	subi	r24, 0xD0	; 208
    6e80:	d8 01       	movw	r26, r16
    6e82:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    6e84:	d3 94       	inc	r13
    6e86:	0d 2d       	mov	r16, r13
    6e88:	10 e0       	ldi	r17, 0x00	; 0
    6e8a:	d7 01       	movw	r26, r14
    6e8c:	0d 90       	ld	r0, X+
    6e8e:	00 20       	and	r0, r0
    6e90:	e9 f7       	brne	.-6      	; 0x6e8c <GenerateKeyStamp+0xe6>
    6e92:	11 97       	sbiw	r26, 0x01	; 1
    6e94:	ae 19       	sub	r26, r14
    6e96:	bf 09       	sbc	r27, r15
    6e98:	0a 17       	cp	r16, r26
    6e9a:	1b 07       	cpc	r17, r27
    6e9c:	08 f3       	brcs	.-62     	; 0x6e60 <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    6e9e:	aa 0d       	add	r26, r10
    6ea0:	bb 1d       	adc	r27, r11
    6ea2:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    6ea4:	c5 01       	movw	r24, r10
    6ea6:	0e 94 69 36 	call	0x6cd2	; 0x6cd2 <WrapCode>
}
    6eaa:	2d 96       	adiw	r28, 0x0d	; 13
    6eac:	0f b6       	in	r0, 0x3f	; 63
    6eae:	f8 94       	cli
    6eb0:	de bf       	out	0x3e, r29	; 62
    6eb2:	0f be       	out	0x3f, r0	; 63
    6eb4:	cd bf       	out	0x3d, r28	; 61
    6eb6:	cf 91       	pop	r28
    6eb8:	df 91       	pop	r29
    6eba:	1f 91       	pop	r17
    6ebc:	0f 91       	pop	r16
    6ebe:	ff 90       	pop	r15
    6ec0:	ef 90       	pop	r14
    6ec2:	df 90       	pop	r13
    6ec4:	bf 90       	pop	r11
    6ec6:	af 90       	pop	r10
    6ec8:	9f 90       	pop	r9
    6eca:	8f 90       	pop	r8
    6ecc:	08 95       	ret

00006ece <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    6ece:	af 92       	push	r10
    6ed0:	bf 92       	push	r11
    6ed2:	cf 92       	push	r12
    6ed4:	df 92       	push	r13
    6ed6:	ef 92       	push	r14
    6ed8:	ff 92       	push	r15
    6eda:	0f 93       	push	r16
    6edc:	1f 93       	push	r17
    6ede:	df 93       	push	r29
    6ee0:	cf 93       	push	r28
    6ee2:	cd b7       	in	r28, 0x3d	; 61
    6ee4:	de b7       	in	r29, 0x3e	; 62
    6ee6:	28 97       	sbiw	r28, 0x08	; 8
    6ee8:	0f b6       	in	r0, 0x3f	; 63
    6eea:	f8 94       	cli
    6eec:	de bf       	out	0x3e, r29	; 62
    6eee:	0f be       	out	0x3f, r0	; 63
    6ef0:	cd bf       	out	0x3d, r28	; 61
    6ef2:	7c 01       	movw	r14, r24
    6ef4:	c6 2e       	mov	r12, r22
    6ef6:	5a 01       	movw	r10, r20
	    sprintf_P(strSend,PSTR("Date[%s]"),srcDate);
		uart_print(1,1,strSend);
     #endif
    

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-2,2);
    6ef8:	fc 01       	movw	r30, r24
    6efa:	01 90       	ld	r0, Z+
    6efc:	00 20       	and	r0, r0
    6efe:	e9 f7       	brne	.-6      	; 0x6efa <GenerateGeniusCode+0x2c>
    6f00:	e8 1b       	sub	r30, r24
    6f02:	f9 0b       	sbc	r31, r25
    6f04:	33 97       	sbiw	r30, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    6f06:	e8 0f       	add	r30, r24
    6f08:	f9 1f       	adc	r31, r25
    6f0a:	80 81       	ld	r24, Z
    6f0c:	89 83       	std	Y+1, r24	; 0x01
    6f0e:	81 81       	ldd	r24, Z+1	; 0x01
    6f10:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    6f12:	1b 82       	std	Y+3, r1	; 0x03
    #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("Year:[%s]"),AddYear);
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    6f14:	00 d0       	rcall	.+0      	; 0x6f16 <GenerateGeniusCode+0x48>
    6f16:	00 d0       	rcall	.+0      	; 0x6f18 <GenerateGeniusCode+0x4a>
    6f18:	00 d0       	rcall	.+0      	; 0x6f1a <GenerateGeniusCode+0x4c>
    6f1a:	ed b7       	in	r30, 0x3d	; 61
    6f1c:	fe b7       	in	r31, 0x3e	; 62
    6f1e:	31 96       	adiw	r30, 0x01	; 1
    6f20:	8e 01       	movw	r16, r28
    6f22:	0c 5f       	subi	r16, 0xFC	; 252
    6f24:	1f 4f       	sbci	r17, 0xFF	; 255
    6f26:	ad b7       	in	r26, 0x3d	; 61
    6f28:	be b7       	in	r27, 0x3e	; 62
    6f2a:	12 96       	adiw	r26, 0x02	; 2
    6f2c:	1c 93       	st	X, r17
    6f2e:	0e 93       	st	-X, r16
    6f30:	11 97       	sbiw	r26, 0x01	; 1
    6f32:	89 eb       	ldi	r24, 0xB9	; 185
    6f34:	98 e1       	ldi	r25, 0x18	; 24
    6f36:	93 83       	std	Z+3, r25	; 0x03
    6f38:	82 83       	std	Z+2, r24	; 0x02
    6f3a:	ce 01       	movw	r24, r28
    6f3c:	01 96       	adiw	r24, 0x01	; 1
    6f3e:	95 83       	std	Z+5, r25	; 0x05
    6f40:	84 83       	std	Z+4, r24	; 0x04
    6f42:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    6f46:	d7 01       	movw	r26, r14
    6f48:	0d 90       	ld	r0, X+
    6f4a:	00 20       	and	r0, r0
    6f4c:	e9 f7       	brne	.-6      	; 0x6f48 <GenerateGeniusCode+0x7a>
    6f4e:	9d 01       	movw	r18, r26
    6f50:	21 50       	subi	r18, 0x01	; 1
    6f52:	30 40       	sbci	r19, 0x00	; 0
    6f54:	2e 19       	sub	r18, r14
    6f56:	3f 09       	sbc	r19, r15
    6f58:	d8 01       	movw	r26, r16
    6f5a:	0d 90       	ld	r0, X+
    6f5c:	00 20       	and	r0, r0
    6f5e:	e9 f7       	brne	.-6      	; 0x6f5a <GenerateGeniusCode+0x8c>
    6f60:	11 97       	sbiw	r26, 0x01	; 1
    6f62:	a0 1b       	sub	r26, r16
    6f64:	b1 0b       	sbc	r27, r17
    6f66:	22 50       	subi	r18, 0x02	; 2
    6f68:	30 40       	sbci	r19, 0x00	; 0
    6f6a:	b7 01       	movw	r22, r14
    6f6c:	62 0f       	add	r22, r18
    6f6e:	73 1f       	adc	r23, r19
    6f70:	2e 5f       	subi	r18, 0xFE	; 254
    6f72:	3f 4f       	sbci	r19, 0xFF	; 255
    6f74:	40 e0       	ldi	r20, 0x00	; 0
    6f76:	50 e0       	ldi	r21, 0x00	; 0
    6f78:	ed b7       	in	r30, 0x3d	; 61
    6f7a:	fe b7       	in	r31, 0x3e	; 62
    6f7c:	36 96       	adiw	r30, 0x06	; 6
    6f7e:	0f b6       	in	r0, 0x3f	; 63
    6f80:	f8 94       	cli
    6f82:	fe bf       	out	0x3e, r31	; 62
    6f84:	0f be       	out	0x3f, r0	; 63
    6f86:	ed bf       	out	0x3d, r30	; 61
    6f88:	09 c0       	rjmp	.+18     	; 0x6f9c <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    6f8a:	f8 01       	movw	r30, r16
    6f8c:	e4 0f       	add	r30, r20
    6f8e:	f5 1f       	adc	r31, r21
    6f90:	80 81       	ld	r24, Z
    6f92:	fb 01       	movw	r30, r22
    6f94:	81 93       	st	Z+, r24
    6f96:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    6f98:	4f 5f       	subi	r20, 0xFF	; 255
    6f9a:	5f 4f       	sbci	r21, 0xFF	; 255
    6f9c:	4a 17       	cp	r20, r26
    6f9e:	5b 07       	cpc	r21, r27
    6fa0:	a0 f3       	brcs	.-24     	; 0x6f8a <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    6fa2:	ae 0d       	add	r26, r14
    6fa4:	bf 1d       	adc	r27, r15
    6fa6:	a2 0f       	add	r26, r18
    6fa8:	b3 1f       	adc	r27, r19
    6faa:	12 97       	sbiw	r26, 0x02	; 2
    6fac:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("NewDate[%s]"),srcDate);
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    6fae:	00 d0       	rcall	.+0      	; 0x6fb0 <GenerateGeniusCode+0xe2>
    6fb0:	00 d0       	rcall	.+0      	; 0x6fb2 <GenerateGeniusCode+0xe4>
    6fb2:	00 d0       	rcall	.+0      	; 0x6fb4 <GenerateGeniusCode+0xe6>
    6fb4:	ed b7       	in	r30, 0x3d	; 61
    6fb6:	fe b7       	in	r31, 0x3e	; 62
    6fb8:	31 96       	adiw	r30, 0x01	; 1
    6fba:	ad b7       	in	r26, 0x3d	; 61
    6fbc:	be b7       	in	r27, 0x3e	; 62
    6fbe:	12 96       	adiw	r26, 0x02	; 2
    6fc0:	bc 92       	st	X, r11
    6fc2:	ae 92       	st	-X, r10
    6fc4:	11 97       	sbiw	r26, 0x01	; 1
    6fc6:	86 eb       	ldi	r24, 0xB6	; 182
    6fc8:	98 e1       	ldi	r25, 0x18	; 24
    6fca:	93 83       	std	Z+3, r25	; 0x03
    6fcc:	82 83       	std	Z+2, r24	; 0x02
    6fce:	c4 82       	std	Z+4, r12	; 0x04
    6fd0:	15 82       	std	Z+5, r1	; 0x05
    6fd2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    6fd6:	dd 24       	eor	r13, r13
    6fd8:	d3 94       	inc	r13
    6fda:	ed b7       	in	r30, 0x3d	; 61
    6fdc:	fe b7       	in	r31, 0x3e	; 62
    6fde:	36 96       	adiw	r30, 0x06	; 6
    6fe0:	0f b6       	in	r0, 0x3f	; 63
    6fe2:	f8 94       	cli
    6fe4:	fe bf       	out	0x3e, r31	; 62
    6fe6:	0f be       	out	0x3f, r0	; 63
    6fe8:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    6fea:	f0 ed       	ldi	r31, 0xD0	; 208
    6fec:	cf 0e       	add	r12, r31
    6fee:	0f c0       	rjmp	.+30     	; 0x700e <GenerateGeniusCode+0x140>
    6ff0:	f7 01       	movw	r30, r14
    6ff2:	e0 0f       	add	r30, r16
    6ff4:	f1 1f       	adc	r31, r17
    6ff6:	40 81       	ld	r20, Z
    6ff8:	40 53       	subi	r20, 0x30	; 48
    6ffa:	80 e0       	ldi	r24, 0x00	; 0
    6ffc:	6c 2d       	mov	r22, r12
    6ffe:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <GeniusCalc>
    7002:	0a 0d       	add	r16, r10
    7004:	1b 1d       	adc	r17, r11
    7006:	80 5d       	subi	r24, 0xD0	; 208
    7008:	d8 01       	movw	r26, r16
    700a:	8c 93       	st	X, r24
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    700c:	d3 94       	inc	r13
    700e:	0d 2d       	mov	r16, r13
    7010:	10 e0       	ldi	r17, 0x00	; 0
    7012:	d7 01       	movw	r26, r14
    7014:	0d 90       	ld	r0, X+
    7016:	00 20       	and	r0, r0
    7018:	e9 f7       	brne	.-6      	; 0x7014 <GenerateGeniusCode+0x146>
    701a:	11 97       	sbiw	r26, 0x01	; 1
    701c:	ae 19       	sub	r26, r14
    701e:	bf 09       	sbc	r27, r15
    7020:	0a 17       	cp	r16, r26
    7022:	1b 07       	cpc	r17, r27
    7024:	28 f3       	brcs	.-54     	; 0x6ff0 <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    7026:	aa 0d       	add	r26, r10
    7028:	bb 1d       	adc	r27, r11
    702a:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    702c:	c5 01       	movw	r24, r10
    702e:	0e 94 69 36 	call	0x6cd2	; 0x6cd2 <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif
}
    7032:	28 96       	adiw	r28, 0x08	; 8
    7034:	0f b6       	in	r0, 0x3f	; 63
    7036:	f8 94       	cli
    7038:	de bf       	out	0x3e, r29	; 62
    703a:	0f be       	out	0x3f, r0	; 63
    703c:	cd bf       	out	0x3d, r28	; 61
    703e:	cf 91       	pop	r28
    7040:	df 91       	pop	r29
    7042:	1f 91       	pop	r17
    7044:	0f 91       	pop	r16
    7046:	ff 90       	pop	r15
    7048:	ef 90       	pop	r14
    704a:	df 90       	pop	r13
    704c:	cf 90       	pop	r12
    704e:	bf 90       	pop	r11
    7050:	af 90       	pop	r10
    7052:	08 95       	ret

00007054 <GeneratePrintInit>:





void GeneratePrintInit(){//Create Initialize Print 
    7054:	cf 92       	push	r12
    7056:	df 92       	push	r13
    7058:	ef 92       	push	r14
    705a:	ff 92       	push	r15
    705c:	0f 93       	push	r16
    705e:	1f 93       	push	r17
    7060:	df 93       	push	r29
    7062:	cf 93       	push	r28
    7064:	cd b7       	in	r28, 0x3d	; 61
    7066:	de b7       	in	r29, 0x3e	; 62
    7068:	62 97       	sbiw	r28, 0x12	; 18
    706a:	0f b6       	in	r0, 0x3f	; 63
    706c:	f8 94       	cli
    706e:	de bf       	out	0x3e, r29	; 62
    7070:	0f be       	out	0x3f, r0	; 63
    7072:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    7074:	00 d0       	rcall	.+0      	; 0x7076 <GeneratePrintInit+0x22>
    7076:	00 d0       	rcall	.+0      	; 0x7078 <GeneratePrintInit+0x24>
    7078:	6e 01       	movw	r12, r28
    707a:	08 94       	sec
    707c:	c1 1c       	adc	r12, r1
    707e:	d1 1c       	adc	r13, r1
    7080:	ad b7       	in	r26, 0x3d	; 61
    7082:	be b7       	in	r27, 0x3e	; 62
    7084:	12 96       	adiw	r26, 0x02	; 2
    7086:	dc 92       	st	X, r13
    7088:	ce 92       	st	-X, r12
    708a:	11 97       	sbiw	r26, 0x01	; 1
    708c:	88 e4       	ldi	r24, 0x48	; 72
    708e:	9e e1       	ldi	r25, 0x1E	; 30
    7090:	14 96       	adiw	r26, 0x04	; 4
    7092:	9c 93       	st	X, r25
    7094:	8e 93       	st	-X, r24
    7096:	13 97       	sbiw	r26, 0x03	; 3
    7098:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    709c:	37 e0       	ldi	r19, 0x07	; 7
    709e:	e3 2e       	mov	r14, r19
    70a0:	f1 2c       	mov	r15, r1
    70a2:	ec 0e       	add	r14, r28
    70a4:	fd 1e       	adc	r15, r29
    70a6:	ed b7       	in	r30, 0x3d	; 61
    70a8:	fe b7       	in	r31, 0x3e	; 62
    70aa:	f2 82       	std	Z+2, r15	; 0x02
    70ac:	e1 82       	std	Z+1, r14	; 0x01
    70ae:	8d e3       	ldi	r24, 0x3D	; 61
    70b0:	9e e1       	ldi	r25, 0x1E	; 30
    70b2:	94 83       	std	Z+4, r25	; 0x04
    70b4:	83 83       	std	Z+3, r24	; 0x03
    70b6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    70ba:	00 d0       	rcall	.+0      	; 0x70bc <GeneratePrintInit+0x68>
    70bc:	00 d0       	rcall	.+0      	; 0x70be <GeneratePrintInit+0x6a>
    70be:	ed b7       	in	r30, 0x3d	; 61
    70c0:	fe b7       	in	r31, 0x3e	; 62
    70c2:	31 96       	adiw	r30, 0x01	; 1
    70c4:	05 ef       	ldi	r16, 0xF5	; 245
    70c6:	13 e0       	ldi	r17, 0x03	; 3
    70c8:	ad b7       	in	r26, 0x3d	; 61
    70ca:	be b7       	in	r27, 0x3e	; 62
    70cc:	12 96       	adiw	r26, 0x02	; 2
    70ce:	1c 93       	st	X, r17
    70d0:	0e 93       	st	-X, r16
    70d2:	11 97       	sbiw	r26, 0x01	; 1
    70d4:	8b ec       	ldi	r24, 0xCB	; 203
    70d6:	9d e1       	ldi	r25, 0x1D	; 29
    70d8:	93 83       	std	Z+3, r25	; 0x03
    70da:	82 83       	std	Z+2, r24	; 0x02
    70dc:	d5 82       	std	Z+5, r13	; 0x05
    70de:	c4 82       	std	Z+4, r12	; 0x04
    70e0:	f7 82       	std	Z+7, r15	; 0x07
    70e2:	e6 82       	std	Z+6, r14	; 0x06
    70e4:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 uart_print(0,1,PrintBuffer);
    70e8:	ed b7       	in	r30, 0x3d	; 61
    70ea:	fe b7       	in	r31, 0x3e	; 62
    70ec:	38 96       	adiw	r30, 0x08	; 8
    70ee:	0f b6       	in	r0, 0x3f	; 63
    70f0:	f8 94       	cli
    70f2:	fe bf       	out	0x3e, r31	; 62
    70f4:	0f be       	out	0x3f, r0	; 63
    70f6:	ed bf       	out	0x3d, r30	; 61
    70f8:	80 e0       	ldi	r24, 0x00	; 0
    70fa:	61 e0       	ldi	r22, 0x01	; 1
    70fc:	a8 01       	movw	r20, r16
    70fe:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    7102:	f8 01       	movw	r30, r16
    7104:	01 90       	ld	r0, Z+
    7106:	00 20       	and	r0, r0
    7108:	e9 f7       	brne	.-6      	; 0x7104 <GeneratePrintInit+0xb0>
    710a:	31 97       	sbiw	r30, 0x01	; 1
    710c:	e0 1b       	sub	r30, r16
    710e:	f1 0b       	sbc	r31, r17
    7110:	f0 93 90 01 	sts	0x0190, r31
    7114:	e0 93 8f 01 	sts	0x018F, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    7118:	80 e3       	ldi	r24, 0x30	; 48
    711a:	80 93 b7 01 	sts	0x01B7, r24
	 IsFreePrinting=True;
    711e:	81 e0       	ldi	r24, 0x01	; 1
    7120:	80 93 aa 01 	sts	0x01AA, r24
}
    7124:	62 96       	adiw	r28, 0x12	; 18
    7126:	0f b6       	in	r0, 0x3f	; 63
    7128:	f8 94       	cli
    712a:	de bf       	out	0x3e, r29	; 62
    712c:	0f be       	out	0x3f, r0	; 63
    712e:	cd bf       	out	0x3d, r28	; 61
    7130:	cf 91       	pop	r28
    7132:	df 91       	pop	r29
    7134:	1f 91       	pop	r17
    7136:	0f 91       	pop	r16
    7138:	ff 90       	pop	r15
    713a:	ef 90       	pop	r14
    713c:	df 90       	pop	r13
    713e:	cf 90       	pop	r12
    7140:	08 95       	ret

00007142 <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    7142:	9f 92       	push	r9
    7144:	af 92       	push	r10
    7146:	bf 92       	push	r11
    7148:	cf 92       	push	r12
    714a:	df 92       	push	r13
    714c:	ef 92       	push	r14
    714e:	ff 92       	push	r15
    7150:	0f 93       	push	r16
    7152:	1f 93       	push	r17
    7154:	df 93       	push	r29
    7156:	cf 93       	push	r28
    7158:	cd b7       	in	r28, 0x3d	; 61
    715a:	de b7       	in	r29, 0x3e	; 62
    715c:	64 97       	sbiw	r28, 0x14	; 20
    715e:	0f b6       	in	r0, 0x3f	; 63
    7160:	f8 94       	cli
    7162:	de bf       	out	0x3e, r29	; 62
    7164:	0f be       	out	0x3f, r0	; 63
    7166:	cd bf       	out	0x3d, r28	; 61
    7168:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    716a:	e1 99       	sbic	0x1c, 1	; 28
    716c:	fe cf       	rjmp	.-4      	; 0x716a <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    716e:	8f e3       	ldi	r24, 0x3F	; 63
    7170:	90 e0       	ldi	r25, 0x00	; 0
    7172:	9f bb       	out	0x1f, r25	; 31
    7174:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7176:	e0 9a       	sbi	0x1c, 0	; 28
    7178:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    717a:	e1 99       	sbic	0x1c, 1	; 28
    717c:	fe cf       	rjmp	.-4      	; 0x717a <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    717e:	8e e3       	ldi	r24, 0x3E	; 62
    7180:	90 e0       	ldi	r25, 0x00	; 0
    7182:	9f bb       	out	0x1f, r25	; 31
    7184:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7186:	e0 9a       	sbi	0x1c, 0	; 28
    7188:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    718a:	f6 01       	movw	r30, r12
    718c:	01 90       	ld	r0, Z+
    718e:	00 20       	and	r0, r0
    7190:	e9 f7       	brne	.-6      	; 0x718c <FormatCurrency+0x4a>
    7192:	31 97       	sbiw	r30, 0x01	; 1
    7194:	ee 2e       	mov	r14, r30
    7196:	ec 18       	sub	r14, r12
    7198:	fe 01       	movw	r30, r28
    719a:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    719c:	ce 01       	movw	r24, r28
    719e:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    71a0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    71a2:	e8 17       	cp	r30, r24
    71a4:	f9 07       	cpc	r31, r25
    71a6:	e1 f7       	brne	.-8      	; 0x71a0 <FormatCurrency+0x5e>
    71a8:	f6 01       	movw	r30, r12
    71aa:	fe 2c       	mov	r15, r14
    71ac:	80 e0       	ldi	r24, 0x00	; 0
    71ae:	20 e0       	ldi	r18, 0x00	; 0
    71b0:	09 c0       	rjmp	.+18     	; 0x71c4 <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    71b2:	90 81       	ld	r25, Z
    71b4:	93 17       	cp	r25, r19
    71b6:	09 f4       	brne	.+2      	; 0x71ba <FormatCurrency+0x78>
    71b8:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    71ba:	99 15       	cp	r25, r9
    71bc:	09 f4       	brne	.+2      	; 0x71c0 <FormatCurrency+0x7e>
    71be:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    71c0:	8f 5f       	subi	r24, 0xFF	; 255
    71c2:	31 96       	adiw	r30, 0x01	; 1
    71c4:	8e 15       	cp	r24, r14
    71c6:	a8 f3       	brcs	.-22     	; 0x71b2 <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    71c8:	22 23       	and	r18, r18
    71ca:	09 f0       	breq	.+2      	; 0x71ce <FormatCurrency+0x8c>
    71cc:	5e c0       	rjmp	.+188    	; 0x728a <FormatCurrency+0x148>
    71ce:	83 e0       	ldi	r24, 0x03	; 3
    71d0:	8f 15       	cp	r24, r15
    71d2:	08 f0       	brcs	.+2      	; 0x71d6 <FormatCurrency+0x94>
    71d4:	5a c0       	rjmp	.+180    	; 0x728a <FormatCurrency+0x148>
    71d6:	40 e0       	ldi	r20, 0x00	; 0
    71d8:	20 e0       	ldi	r18, 0x00	; 0
    71da:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    71dc:	af 2c       	mov	r10, r15
    71de:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    71e0:	8e 01       	movw	r16, r28
    71e2:	0f 5f       	subi	r16, 0xFF	; 255
    71e4:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    71e6:	c5 01       	movw	r24, r10
    71e8:	82 1b       	sub	r24, r18
    71ea:	93 0b       	sbc	r25, r19
    71ec:	63 e0       	ldi	r22, 0x03	; 3
    71ee:	70 e0       	ldi	r23, 0x00	; 0
    71f0:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    71f4:	89 2b       	or	r24, r25
    71f6:	49 f4       	brne	.+18     	; 0x720a <FormatCurrency+0xc8>
    71f8:	2f 15       	cp	r18, r15
    71fa:	38 f4       	brcc	.+14     	; 0x720a <FormatCurrency+0xc8>
    71fc:	22 23       	and	r18, r18
    71fe:	29 f0       	breq	.+10     	; 0x720a <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    7200:	f8 01       	movw	r30, r16
    7202:	e4 0f       	add	r30, r20
    7204:	f1 1d       	adc	r31, r1
    7206:	90 82       	st	Z, r9
		        iPos++;
    7208:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    720a:	d8 01       	movw	r26, r16
    720c:	a4 0f       	add	r26, r20
    720e:	b1 1d       	adc	r27, r1
    7210:	f6 01       	movw	r30, r12
    7212:	e2 0f       	add	r30, r18
    7214:	f3 1f       	adc	r31, r19
    7216:	80 81       	ld	r24, Z
    7218:	8c 93       	st	X, r24
			    iPos++;
    721a:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    721c:	f8 01       	movw	r30, r16
    721e:	e4 0f       	add	r30, r20
    7220:	f1 1d       	adc	r31, r1
    7222:	10 82       	st	Z, r1
    7224:	2f 5f       	subi	r18, 0xFF	; 255
    7226:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    7228:	2f 15       	cp	r18, r15
    722a:	e8 f2       	brcs	.-70     	; 0x71e6 <FormatCurrency+0xa4>
    722c:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    722e:	9e 01       	movw	r18, r28
    7230:	2f 5f       	subi	r18, 0xFF	; 255
    7232:	3f 4f       	sbci	r19, 0xFF	; 255
    7234:	0e c0       	rjmp	.+28     	; 0x7252 <FormatCurrency+0x110>
    7236:	d9 01       	movw	r26, r18
    7238:	a4 0f       	add	r26, r20
    723a:	b1 1d       	adc	r27, r1
    723c:	f6 01       	movw	r30, r12
    723e:	e9 0f       	add	r30, r25
    7240:	f1 1d       	adc	r31, r1
    7242:	80 81       	ld	r24, Z
    7244:	8c 93       	st	X, r24
			    iPos++;
    7246:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    7248:	f9 01       	movw	r30, r18
    724a:	e4 0f       	add	r30, r20
    724c:	f1 1d       	adc	r31, r1
    724e:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    7250:	9f 5f       	subi	r25, 0xFF	; 255
    7252:	9e 15       	cp	r25, r14
    7254:	80 f3       	brcs	.-32     	; 0x7236 <FormatCurrency+0xf4>
    7256:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    7258:	9e 01       	movw	r18, r28
    725a:	2f 5f       	subi	r18, 0xFF	; 255
    725c:	3f 4f       	sbci	r19, 0xFF	; 255
    725e:	09 c0       	rjmp	.+18     	; 0x7272 <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    7260:	f6 01       	movw	r30, r12
    7262:	ea 0f       	add	r30, r26
    7264:	fb 1f       	adc	r31, r27
    7266:	a2 0f       	add	r26, r18
    7268:	b3 1f       	adc	r27, r19
    726a:	8c 91       	ld	r24, X
    726c:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    726e:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    7270:	9f 5f       	subi	r25, 0xFF	; 255
    7272:	a9 2f       	mov	r26, r25
    7274:	b0 e0       	ldi	r27, 0x00	; 0
    7276:	f9 01       	movw	r30, r18
    7278:	01 90       	ld	r0, Z+
    727a:	00 20       	and	r0, r0
    727c:	e9 f7       	brne	.-6      	; 0x7278 <FormatCurrency+0x136>
    727e:	31 97       	sbiw	r30, 0x01	; 1
    7280:	e2 1b       	sub	r30, r18
    7282:	f3 0b       	sbc	r31, r19
    7284:	ae 17       	cp	r26, r30
    7286:	bf 07       	cpc	r27, r31
    7288:	58 f3       	brcs	.-42     	; 0x7260 <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    728a:	64 96       	adiw	r28, 0x14	; 20
    728c:	0f b6       	in	r0, 0x3f	; 63
    728e:	f8 94       	cli
    7290:	de bf       	out	0x3e, r29	; 62
    7292:	0f be       	out	0x3f, r0	; 63
    7294:	cd bf       	out	0x3d, r28	; 61
    7296:	cf 91       	pop	r28
    7298:	df 91       	pop	r29
    729a:	1f 91       	pop	r17
    729c:	0f 91       	pop	r16
    729e:	ff 90       	pop	r15
    72a0:	ef 90       	pop	r14
    72a2:	df 90       	pop	r13
    72a4:	cf 90       	pop	r12
    72a6:	bf 90       	pop	r11
    72a8:	af 90       	pop	r10
    72aa:	9f 90       	pop	r9
    72ac:	08 95       	ret

000072ae <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    72ae:	ef 92       	push	r14
    72b0:	ff 92       	push	r15
    72b2:	0f 93       	push	r16
    72b4:	1f 93       	push	r17
    72b6:	df 93       	push	r29
    72b8:	cf 93       	push	r28
    72ba:	cd b7       	in	r28, 0x3d	; 61
    72bc:	de b7       	in	r29, 0x3e	; 62
    72be:	64 97       	sbiw	r28, 0x14	; 20
    72c0:	0f b6       	in	r0, 0x3f	; 63
    72c2:	f8 94       	cli
    72c4:	de bf       	out	0x3e, r29	; 62
    72c6:	0f be       	out	0x3f, r0	; 63
    72c8:	cd bf       	out	0x3d, r28	; 61
    72ca:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    72cc:	66 23       	and	r22, r22
    72ce:	09 f4       	brne	.+2      	; 0x72d2 <FormatDecimal+0x24>
    72d0:	56 c0       	rjmp	.+172    	; 0x737e <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    72d2:	e1 99       	sbic	0x1c, 1	; 28
    72d4:	fe cf       	rjmp	.-4      	; 0x72d2 <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    72d6:	8e e3       	ldi	r24, 0x3E	; 62
    72d8:	90 e0       	ldi	r25, 0x00	; 0
    72da:	9f bb       	out	0x1f, r25	; 31
    72dc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    72de:	e0 9a       	sbi	0x1c, 0	; 28
    72e0:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    72e2:	f8 01       	movw	r30, r16
    72e4:	01 90       	ld	r0, Z+
    72e6:	00 20       	and	r0, r0
    72e8:	e9 f7       	brne	.-6      	; 0x72e4 <FormatDecimal+0x36>
    72ea:	31 97       	sbiw	r30, 0x01	; 1
    72ec:	3e 2f       	mov	r19, r30
    72ee:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    72f0:	63 17       	cp	r22, r19
    72f2:	b8 f5       	brcc	.+110    	; 0x7362 <FormatDecimal+0xb4>
    72f4:	f3 2e       	mov	r15, r19
    72f6:	f6 1a       	sub	r15, r22
    72f8:	b8 01       	movw	r22, r16
    72fa:	d8 01       	movw	r26, r16
    72fc:	20 e0       	ldi	r18, 0x00	; 0
    72fe:	90 e0       	ldi	r25, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    7300:	ae 01       	movw	r20, r28
    7302:	4f 5f       	subi	r20, 0xFF	; 255
    7304:	5f 4f       	sbci	r21, 0xFF	; 255
    7306:	0e c0       	rjmp	.+28     	; 0x7324 <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    7308:	2f 15       	cp	r18, r15
    730a:	29 f4       	brne	.+10     	; 0x7316 <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    730c:	fa 01       	movw	r30, r20
    730e:	e9 0f       	add	r30, r25
    7310:	f1 1d       	adc	r31, r1
    7312:	e0 82       	st	Z, r14
				 iPos++;
    7314:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    7316:	fa 01       	movw	r30, r20
    7318:	e9 0f       	add	r30, r25
    731a:	f1 1d       	adc	r31, r1
    731c:	8d 91       	ld	r24, X+
    731e:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    7320:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    7322:	2f 5f       	subi	r18, 0xFF	; 255
    7324:	23 17       	cp	r18, r19
    7326:	80 f3       	brcs	.-32     	; 0x7308 <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    7328:	9e 01       	movw	r18, r28
    732a:	2f 5f       	subi	r18, 0xFF	; 255
    732c:	3f 4f       	sbci	r19, 0xFF	; 255
    732e:	f9 01       	movw	r30, r18
    7330:	e9 0f       	add	r30, r25
    7332:	f1 1d       	adc	r31, r1
    7334:	10 82       	st	Z, r1
		 
         //uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    7336:	f9 01       	movw	r30, r18
    7338:	01 90       	ld	r0, Z+
    733a:	00 20       	and	r0, r0
    733c:	e9 f7       	brne	.-6      	; 0x7338 <FormatDecimal+0x8a>
    733e:	31 97       	sbiw	r30, 0x01	; 1
    7340:	9e 2f       	mov	r25, r30
    7342:	92 1b       	sub	r25, r18
    7344:	d9 01       	movw	r26, r18
    7346:	04 c0       	rjmp	.+8      	; 0x7350 <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    7348:	8d 91       	ld	r24, X+
    734a:	fb 01       	movw	r30, r22
    734c:	81 93       	st	Z+, r24
    734e:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    7350:	8a 2f       	mov	r24, r26
    7352:	82 1b       	sub	r24, r18
    7354:	89 17       	cp	r24, r25
    7356:	c0 f3       	brcs	.-16     	; 0x7348 <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    7358:	09 0f       	add	r16, r25
    735a:	11 1d       	adc	r17, r1
    735c:	f8 01       	movw	r30, r16
    735e:	10 82       	st	Z, r1
    7360:	0e c0       	rjmp	.+28     	; 0x737e <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    7362:	6f 5f       	subi	r22, 0xFF	; 255
    7364:	c8 01       	movw	r24, r16
    7366:	0e 94 15 2a 	call	0x542a	; 0x542a <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    736a:	f8 01       	movw	r30, r16
    736c:	01 90       	ld	r0, Z+
    736e:	00 20       	and	r0, r0
    7370:	e9 f7       	brne	.-6      	; 0x736c <FormatDecimal+0xbe>
    7372:	31 97       	sbiw	r30, 0x01	; 1
    7374:	3e 2f       	mov	r19, r30
    7376:	30 1b       	sub	r19, r16
    7378:	ff 24       	eor	r15, r15
    737a:	f3 94       	inc	r15
    737c:	bd cf       	rjmp	.-134    	; 0x72f8 <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //uart_print(1,1,strRawData); 
}
    737e:	64 96       	adiw	r28, 0x14	; 20
    7380:	0f b6       	in	r0, 0x3f	; 63
    7382:	f8 94       	cli
    7384:	de bf       	out	0x3e, r29	; 62
    7386:	0f be       	out	0x3f, r0	; 63
    7388:	cd bf       	out	0x3d, r28	; 61
    738a:	cf 91       	pop	r28
    738c:	df 91       	pop	r29
    738e:	1f 91       	pop	r17
    7390:	0f 91       	pop	r16
    7392:	ff 90       	pop	r15
    7394:	ef 90       	pop	r14
    7396:	08 95       	ret

00007398 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    7398:	68 2f       	mov	r22, r24
    739a:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    739c:	0e 94 57 39 	call	0x72ae	; 0x72ae <FormatDecimal>
}
    73a0:	08 95       	ret

000073a2 <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    73a2:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    73a4:	e1 99       	sbic	0x1c, 1	; 28
    73a6:	fe cf       	rjmp	.-4      	; 0x73a4 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    73a8:	8c e3       	ldi	r24, 0x3C	; 60
    73aa:	90 e0       	ldi	r25, 0x00	; 0
    73ac:	9f bb       	out	0x1f, r25	; 31
    73ae:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73b0:	e0 9a       	sbi	0x1c, 0	; 28
    73b2:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    73b4:	c9 01       	movw	r24, r18
    73b6:	0e 94 57 39 	call	0x72ae	; 0x72ae <FormatDecimal>
}
    73ba:	08 95       	ret

000073bc <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    73bc:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    73be:	e1 99       	sbic	0x1c, 1	; 28
    73c0:	fe cf       	rjmp	.-4      	; 0x73be <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    73c2:	8d e3       	ldi	r24, 0x3D	; 61
    73c4:	90 e0       	ldi	r25, 0x00	; 0
    73c6:	9f bb       	out	0x1f, r25	; 31
    73c8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73ca:	e0 9a       	sbi	0x1c, 0	; 28
    73cc:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    73ce:	c9 01       	movw	r24, r18
    73d0:	0e 94 57 39 	call	0x72ae	; 0x72ae <FormatDecimal>
}
    73d4:	08 95       	ret

000073d6 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    73d6:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    73d8:	e1 99       	sbic	0x1c, 1	; 28
    73da:	fe cf       	rjmp	.-4      	; 0x73d8 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    73dc:	8a e3       	ldi	r24, 0x3A	; 58
    73de:	90 e0       	ldi	r25, 0x00	; 0
    73e0:	9f bb       	out	0x1f, r25	; 31
    73e2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73e4:	e0 9a       	sbi	0x1c, 0	; 28
    73e6:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    73e8:	c9 01       	movw	r24, r18
    73ea:	0e 94 57 39 	call	0x72ae	; 0x72ae <FormatDecimal>
}
    73ee:	08 95       	ret

000073f0 <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    73f0:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    73f2:	e1 99       	sbic	0x1c, 1	; 28
    73f4:	fe cf       	rjmp	.-4      	; 0x73f2 <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    73f6:	8b e3       	ldi	r24, 0x3B	; 59
    73f8:	90 e0       	ldi	r25, 0x00	; 0
    73fa:	9f bb       	out	0x1f, r25	; 31
    73fc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73fe:	e0 9a       	sbi	0x1c, 0	; 28
    7400:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    7402:	c9 01       	movw	r24, r18
    7404:	0e 94 57 39 	call	0x72ae	; 0x72ae <FormatDecimal>
}
    7408:	08 95       	ret

0000740a <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    740a:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    740c:	e1 99       	sbic	0x1c, 1	; 28
    740e:	fe cf       	rjmp	.-4      	; 0x740c <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7410:	89 e3       	ldi	r24, 0x39	; 57
    7412:	90 e0       	ldi	r25, 0x00	; 0
    7414:	9f bb       	out	0x1f, r25	; 31
    7416:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7418:	e0 9a       	sbi	0x1c, 0	; 28
    741a:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    741c:	c9 01       	movw	r24, r18
    741e:	0e 94 57 39 	call	0x72ae	; 0x72ae <FormatDecimal>
}
    7422:	08 95       	ret

00007424 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    7424:	2f 92       	push	r2
    7426:	3f 92       	push	r3
    7428:	4f 92       	push	r4
    742a:	5f 92       	push	r5
    742c:	6f 92       	push	r6
    742e:	7f 92       	push	r7
    7430:	8f 92       	push	r8
    7432:	9f 92       	push	r9
    7434:	af 92       	push	r10
    7436:	bf 92       	push	r11
    7438:	cf 92       	push	r12
    743a:	df 92       	push	r13
    743c:	ef 92       	push	r14
    743e:	ff 92       	push	r15
    7440:	0f 93       	push	r16
    7442:	1f 93       	push	r17
    7444:	df 93       	push	r29
    7446:	cf 93       	push	r28
    7448:	cd b7       	in	r28, 0x3d	; 61
    744a:	de b7       	in	r29, 0x3e	; 62
    744c:	c8 5f       	subi	r28, 0xF8	; 248
    744e:	d0 40       	sbci	r29, 0x00	; 0
    7450:	0f b6       	in	r0, 0x3f	; 63
    7452:	f8 94       	cli
    7454:	de bf       	out	0x3e, r29	; 62
    7456:	0f be       	out	0x3f, r0	; 63
    7458:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char iTotal;//,PadLength;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    745a:	10 91 f1 01 	lds	r17, 0x01F1
    745e:	16 30       	cpi	r17, 0x06	; 6
    7460:	09 f4       	brne	.+2      	; 0x7464 <systemGenerateReport+0x40>
    7462:	5d c2       	rjmp	.+1210   	; 0x791e <systemGenerateReport+0x4fa>
    7464:	17 30       	cpi	r17, 0x07	; 7
    7466:	98 f4       	brcc	.+38     	; 0x748e <systemGenerateReport+0x6a>
    7468:	12 30       	cpi	r17, 0x02	; 2
    746a:	09 f4       	brne	.+2      	; 0x746e <systemGenerateReport+0x4a>
    746c:	a7 c0       	rjmp	.+334    	; 0x75bc <systemGenerateReport+0x198>
    746e:	13 30       	cpi	r17, 0x03	; 3
    7470:	38 f4       	brcc	.+14     	; 0x7480 <systemGenerateReport+0x5c>
    7472:	11 23       	and	r17, r17
    7474:	31 f1       	breq	.+76     	; 0x74c2 <systemGenerateReport+0x9e>
    7476:	11 30       	cpi	r17, 0x01	; 1
    7478:	11 f0       	breq	.+4      	; 0x747e <systemGenerateReport+0x5a>
    747a:	0c 94 2b 45 	jmp	0x8a56	; 0x8a56 <systemGenerateReport+0x1632>
    747e:	2d c0       	rjmp	.+90     	; 0x74da <systemGenerateReport+0xb6>
    7480:	14 30       	cpi	r17, 0x04	; 4
    7482:	09 f4       	brne	.+2      	; 0x7486 <systemGenerateReport+0x62>
    7484:	c8 c1       	rjmp	.+912    	; 0x7816 <systemGenerateReport+0x3f2>
    7486:	15 30       	cpi	r17, 0x05	; 5
    7488:	08 f0       	brcs	.+2      	; 0x748c <systemGenerateReport+0x68>
    748a:	4c c7       	rjmp	.+3736   	; 0x8324 <systemGenerateReport+0xf00>
    748c:	bb c1       	rjmp	.+886    	; 0x7804 <systemGenerateReport+0x3e0>
    748e:	19 30       	cpi	r17, 0x09	; 9
    7490:	09 f4       	brne	.+2      	; 0x7494 <systemGenerateReport+0x70>
    7492:	48 c7       	rjmp	.+3728   	; 0x8324 <systemGenerateReport+0xf00>
    7494:	1a 30       	cpi	r17, 0x0A	; 10
    7496:	40 f4       	brcc	.+16     	; 0x74a8 <systemGenerateReport+0x84>
    7498:	17 30       	cpi	r17, 0x07	; 7
    749a:	09 f4       	brne	.+2      	; 0x749e <systemGenerateReport+0x7a>
    749c:	aa c2       	rjmp	.+1364   	; 0x79f2 <systemGenerateReport+0x5ce>
    749e:	18 30       	cpi	r17, 0x08	; 8
    74a0:	11 f0       	breq	.+4      	; 0x74a6 <systemGenerateReport+0x82>
    74a2:	0c 94 2b 45 	jmp	0x8a56	; 0x8a56 <systemGenerateReport+0x1632>
    74a6:	b3 c2       	rjmp	.+1382   	; 0x7a0e <systemGenerateReport+0x5ea>
    74a8:	1b 30       	cpi	r17, 0x0B	; 11
    74aa:	11 f4       	brne	.+4      	; 0x74b0 <systemGenerateReport+0x8c>
    74ac:	0c 94 1e 45 	jmp	0x8a3c	; 0x8a3c <systemGenerateReport+0x1618>
    74b0:	1b 30       	cpi	r17, 0x0B	; 11
    74b2:	08 f4       	brcc	.+2      	; 0x74b6 <systemGenerateReport+0x92>
    74b4:	3e c7       	rjmp	.+3708   	; 0x8332 <systemGenerateReport+0xf0e>
    74b6:	1c 30       	cpi	r17, 0x0C	; 12
    74b8:	11 f0       	breq	.+4      	; 0x74be <systemGenerateReport+0x9a>
    74ba:	0c 94 2b 45 	jmp	0x8a56	; 0x8a56 <systemGenerateReport+0x1632>
    74be:	0c 94 26 45 	jmp	0x8a4c	; 0x8a4c <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    74c2:	80 91 88 01 	lds	r24, 0x0188
    74c6:	81 30       	cpi	r24, 0x01	; 1
    74c8:	11 f0       	breq	.+4      	; 0x74ce <systemGenerateReport+0xaa>
    74ca:	0c 94 2b 45 	jmp	0x8a56	; 0x8a56 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    74ce:	10 92 88 01 	sts	0x0188, r1
			  IsFinishPrintingTotalizer=False;
    74d2:	10 92 89 01 	sts	0x0189, r1
    74d6:	0c 94 23 45 	jmp	0x8a46	; 0x8a46 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    74da:	10 93 f0 01 	sts	0x01F0, r17
		  xNozzle=1;
    74de:	10 93 ef 01 	sts	0x01EF, r17
		  RepPos=0;
    74e2:	10 92 e0 01 	sts	0x01E0, r1
    74e6:	10 92 df 01 	sts	0x01DF, r1
    74ea:	e5 ef       	ldi	r30, 0xF5	; 245
    74ec:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    74ee:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    74f0:	85 e0       	ldi	r24, 0x05	; 5
    74f2:	e6 38       	cpi	r30, 0x86	; 134
    74f4:	f8 07       	cpc	r31, r24
    74f6:	d9 f7       	brne	.-10     	; 0x74ee <systemGenerateReport+0xca>
    74f8:	fe 01       	movw	r30, r28
    74fa:	eb 55       	subi	r30, 0x5B	; 91
    74fc:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    74fe:	ce 01       	movw	r24, r28
    7500:	8b 50       	subi	r24, 0x0B	; 11
    7502:	9f 4f       	sbci	r25, 0xFF	; 255
    7504:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7506:	e8 17       	cp	r30, r24
    7508:	f9 07       	cpc	r31, r25
    750a:	e1 f7       	brne	.-8      	; 0x7504 <systemGenerateReport+0xe0>
    750c:	fe 01       	movw	r30, r28
    750e:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    7510:	cf 01       	movw	r24, r30
    7512:	0f 96       	adiw	r24, 0x0f	; 15
    7514:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7516:	e8 17       	cp	r30, r24
    7518:	f9 07       	cpc	r31, r25
    751a:	e1 f7       	brne	.-8      	; 0x7514 <systemGenerateReport+0xf0>
    751c:	fe 01       	movw	r30, r28
    751e:	ea 5b       	subi	r30, 0xBA	; 186
    7520:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7522:	cf 01       	movw	r24, r30
    7524:	0f 96       	adiw	r24, 0x0f	; 15
    7526:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7528:	e8 17       	cp	r30, r24
    752a:	f9 07       	cpc	r31, r25
    752c:	e1 f7       	brne	.-8      	; 0x7526 <systemGenerateReport+0x102>
    752e:	e0 e0       	ldi	r30, 0x00	; 0
    7530:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
    7532:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7534:	98 e0       	ldi	r25, 0x08	; 8
    7536:	e4 31       	cpi	r30, 0x14	; 20
    7538:	f9 07       	cpc	r31, r25
    753a:	d9 f7       	brne	.-10     	; 0x7532 <systemGenerateReport+0x10e>
    753c:	e1 eb       	ldi	r30, 0xB1	; 177
    753e:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
    7540:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7542:	a8 e0       	ldi	r26, 0x08	; 8
    7544:	e5 3c       	cpi	r30, 0xC5	; 197
    7546:	fa 07       	cpc	r31, r26
    7548:	d9 f7       	brne	.-10     	; 0x7540 <systemGenerateReport+0x11c>
    754a:	ee e3       	ldi	r30, 0x3E	; 62
    754c:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    754e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7550:	be e0       	ldi	r27, 0x0E	; 14
    7552:	ed 34       	cpi	r30, 0x4D	; 77
    7554:	fb 07       	cpc	r31, r27
    7556:	d9 f7       	brne	.-10     	; 0x754e <systemGenerateReport+0x12a>
    7558:	ee e0       	ldi	r30, 0x0E	; 14
    755a:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    755c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    755e:	89 e0       	ldi	r24, 0x09	; 9
    7560:	ed 31       	cpi	r30, 0x1D	; 29
    7562:	f8 07       	cpc	r31, r24
    7564:	d9 f7       	brne	.-10     	; 0x755c <systemGenerateReport+0x138>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7566:	e1 99       	sbic	0x1c, 1	; 28
    7568:	fe cf       	rjmp	.-4      	; 0x7566 <systemGenerateReport+0x142>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    756a:	8f e3       	ldi	r24, 0x3F	; 63
    756c:	91 e0       	ldi	r25, 0x01	; 1
    756e:	9f bb       	out	0x1f, r25	; 31
    7570:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7572:	e0 9a       	sbi	0x1c, 0	; 28
    7574:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    7576:	00 d0       	rcall	.+0      	; 0x7578 <systemGenerateReport+0x154>
    7578:	00 d0       	rcall	.+0      	; 0x757a <systemGenerateReport+0x156>
    757a:	00 d0       	rcall	.+0      	; 0x757c <systemGenerateReport+0x158>
    757c:	ed b7       	in	r30, 0x3d	; 61
    757e:	fe b7       	in	r31, 0x3e	; 62
    7580:	31 96       	adiw	r30, 0x01	; 1
    7582:	81 e8       	ldi	r24, 0x81	; 129
    7584:	9e e0       	ldi	r25, 0x0E	; 14
    7586:	ad b7       	in	r26, 0x3d	; 61
    7588:	be b7       	in	r27, 0x3e	; 62
    758a:	12 96       	adiw	r26, 0x02	; 2
    758c:	9c 93       	st	X, r25
    758e:	8e 93       	st	-X, r24
    7590:	11 97       	sbiw	r26, 0x01	; 1
    7592:	8b e6       	ldi	r24, 0x6B	; 107
    7594:	96 e0       	ldi	r25, 0x06	; 6
    7596:	93 83       	std	Z+3, r25	; 0x03
    7598:	82 83       	std	Z+2, r24	; 0x02
    759a:	24 83       	std	Z+4, r18	; 0x04
    759c:	15 82       	std	Z+5, r1	; 0x05
    759e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    75a2:	82 e0       	ldi	r24, 0x02	; 2
    75a4:	80 93 f1 01 	sts	0x01F1, r24
    75a8:	ed b7       	in	r30, 0x3d	; 61
    75aa:	fe b7       	in	r31, 0x3e	; 62
    75ac:	36 96       	adiw	r30, 0x06	; 6
    75ae:	0f b6       	in	r0, 0x3f	; 63
    75b0:	f8 94       	cli
    75b2:	fe bf       	out	0x3e, r31	; 62
    75b4:	0f be       	out	0x3f, r0	; 63
    75b6:	ed bf       	out	0x3d, r30	; 61
    75b8:	0c 94 2b 45 	jmp	0x8a56	; 0x8a56 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    75bc:	ce 01       	movw	r24, r28
    75be:	8b 5a       	subi	r24, 0xAB	; 171
    75c0:	9f 4f       	sbci	r25, 0xFF	; 255
    75c2:	63 e4       	ldi	r22, 0x43	; 67
    75c4:	78 e0       	ldi	r23, 0x08	; 8
    75c6:	44 e1       	ldi	r20, 0x14	; 20
    75c8:	50 e0       	ldi	r21, 0x00	; 0
    75ca:	22 e4       	ldi	r18, 0x42	; 66
    75cc:	33 e1       	ldi	r19, 0x13	; 19
    75ce:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    75d2:	81 e0       	ldi	r24, 0x01	; 1
    75d4:	65 ef       	ldi	r22, 0xF5	; 245
    75d6:	73 e0       	ldi	r23, 0x03	; 3
    75d8:	41 e0       	ldi	r20, 0x01	; 1
    75da:	2f ed       	ldi	r18, 0xDF	; 223
    75dc:	31 e0       	ldi	r19, 0x01	; 1
    75de:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    75e2:	8b e0       	ldi	r24, 0x0B	; 11
    75e4:	65 ef       	ldi	r22, 0xF5	; 245
    75e6:	73 e0       	ldi	r23, 0x03	; 3
    75e8:	4a e2       	ldi	r20, 0x2A	; 42
    75ea:	2f ed       	ldi	r18, 0xDF	; 223
    75ec:	31 e0       	ldi	r19, 0x01	; 1
    75ee:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    75f2:	83 e0       	ldi	r24, 0x03	; 3
    75f4:	65 ef       	ldi	r22, 0xF5	; 245
    75f6:	73 e0       	ldi	r23, 0x03	; 3
    75f8:	41 e0       	ldi	r20, 0x01	; 1
    75fa:	2f ed       	ldi	r18, 0xDF	; 223
    75fc:	31 e0       	ldi	r19, 0x01	; 1
    75fe:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7602:	8c e0       	ldi	r24, 0x0C	; 12
    7604:	65 ef       	ldi	r22, 0xF5	; 245
    7606:	73 e0       	ldi	r23, 0x03	; 3
    7608:	41 e0       	ldi	r20, 0x01	; 1
    760a:	2f ed       	ldi	r18, 0xDF	; 223
    760c:	31 e0       	ldi	r19, 0x01	; 1
    760e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    7612:	00 d0       	rcall	.+0      	; 0x7614 <systemGenerateReport+0x1f0>
    7614:	00 d0       	rcall	.+0      	; 0x7616 <systemGenerateReport+0x1f2>
    7616:	00 d0       	rcall	.+0      	; 0x7618 <systemGenerateReport+0x1f4>
    7618:	ed b7       	in	r30, 0x3d	; 61
    761a:	fe b7       	in	r31, 0x3e	; 62
    761c:	31 96       	adiw	r30, 0x01	; 1
    761e:	8e 01       	movw	r16, r28
    7620:	0b 55       	subi	r16, 0x5B	; 91
    7622:	1f 4f       	sbci	r17, 0xFF	; 255
    7624:	ad b7       	in	r26, 0x3d	; 61
    7626:	be b7       	in	r27, 0x3e	; 62
    7628:	12 96       	adiw	r26, 0x02	; 2
    762a:	1c 93       	st	X, r17
    762c:	0e 93       	st	-X, r16
    762e:	11 97       	sbiw	r26, 0x01	; 1
    7630:	85 e4       	ldi	r24, 0x45	; 69
    7632:	96 e0       	ldi	r25, 0x06	; 6
    7634:	93 83       	std	Z+3, r25	; 0x03
    7636:	82 83       	std	Z+2, r24	; 0x02
    7638:	81 e8       	ldi	r24, 0x81	; 129
    763a:	9e e0       	ldi	r25, 0x0E	; 14
    763c:	95 83       	std	Z+5, r25	; 0x05
    763e:	84 83       	std	Z+4, r24	; 0x04
    7640:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    7644:	ed b7       	in	r30, 0x3d	; 61
    7646:	fe b7       	in	r31, 0x3e	; 62
    7648:	36 96       	adiw	r30, 0x06	; 6
    764a:	0f b6       	in	r0, 0x3f	; 63
    764c:	f8 94       	cli
    764e:	fe bf       	out	0x3e, r31	; 62
    7650:	0f be       	out	0x3f, r0	; 63
    7652:	ed bf       	out	0x3d, r30	; 61
    7654:	c8 01       	movw	r24, r16
    7656:	65 ef       	ldi	r22, 0xF5	; 245
    7658:	73 e0       	ldi	r23, 0x03	; 3
    765a:	4f ed       	ldi	r20, 0xDF	; 223
    765c:	51 e0       	ldi	r21, 0x01	; 1
    765e:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    7662:	84 e0       	ldi	r24, 0x04	; 4
    7664:	65 ef       	ldi	r22, 0xF5	; 245
    7666:	73 e0       	ldi	r23, 0x03	; 3
    7668:	41 e0       	ldi	r20, 0x01	; 1
    766a:	2f ed       	ldi	r18, 0xDF	; 223
    766c:	31 e0       	ldi	r19, 0x01	; 1
    766e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7672:	8b e0       	ldi	r24, 0x0B	; 11
    7674:	65 ef       	ldi	r22, 0xF5	; 245
    7676:	73 e0       	ldi	r23, 0x03	; 3
    7678:	4a e2       	ldi	r20, 0x2A	; 42
    767a:	2f ed       	ldi	r18, 0xDF	; 223
    767c:	31 e0       	ldi	r19, 0x01	; 1
    767e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7682:	86 e0       	ldi	r24, 0x06	; 6
    7684:	65 ef       	ldi	r22, 0xF5	; 245
    7686:	73 e0       	ldi	r23, 0x03	; 3
    7688:	41 e0       	ldi	r20, 0x01	; 1
    768a:	2f ed       	ldi	r18, 0xDF	; 223
    768c:	31 e0       	ldi	r19, 0x01	; 1
    768e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7692:	8c e0       	ldi	r24, 0x0C	; 12
    7694:	65 ef       	ldi	r22, 0xF5	; 245
    7696:	73 e0       	ldi	r23, 0x03	; 3
    7698:	41 e0       	ldi	r20, 0x01	; 1
    769a:	2f ed       	ldi	r18, 0xDF	; 223
    769c:	31 e0       	ldi	r19, 0x01	; 1
    769e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    76a2:	e1 99       	sbic	0x1c, 1	; 28
    76a4:	fe cf       	rjmp	.-4      	; 0x76a2 <systemGenerateReport+0x27e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    76a6:	80 e0       	ldi	r24, 0x00	; 0
    76a8:	90 e0       	ldi	r25, 0x00	; 0
    76aa:	9f bb       	out	0x1f, r25	; 31
    76ac:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    76ae:	e0 9a       	sbi	0x1c, 0	; 28
    76b0:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    76b2:	00 d0       	rcall	.+0      	; 0x76b4 <systemGenerateReport+0x290>
    76b4:	00 d0       	rcall	.+0      	; 0x76b6 <systemGenerateReport+0x292>
    76b6:	00 d0       	rcall	.+0      	; 0x76b8 <systemGenerateReport+0x294>
    76b8:	ed b7       	in	r30, 0x3d	; 61
    76ba:	fe b7       	in	r31, 0x3e	; 62
    76bc:	31 96       	adiw	r30, 0x01	; 1
    76be:	8e 01       	movw	r16, r28
    76c0:	0b 55       	subi	r16, 0x5B	; 91
    76c2:	1f 4f       	sbci	r17, 0xFF	; 255
    76c4:	ad b7       	in	r26, 0x3d	; 61
    76c6:	be b7       	in	r27, 0x3e	; 62
    76c8:	12 96       	adiw	r26, 0x02	; 2
    76ca:	1c 93       	st	X, r17
    76cc:	0e 93       	st	-X, r16
    76ce:	11 97       	sbiw	r26, 0x01	; 1
    76d0:	8f e1       	ldi	r24, 0x1F	; 31
    76d2:	96 e0       	ldi	r25, 0x06	; 6
    76d4:	93 83       	std	Z+3, r25	; 0x03
    76d6:	82 83       	std	Z+2, r24	; 0x02
    76d8:	24 83       	std	Z+4, r18	; 0x04
    76da:	15 82       	std	Z+5, r1	; 0x05
    76dc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    76e0:	ed b7       	in	r30, 0x3d	; 61
    76e2:	fe b7       	in	r31, 0x3e	; 62
    76e4:	36 96       	adiw	r30, 0x06	; 6
    76e6:	0f b6       	in	r0, 0x3f	; 63
    76e8:	f8 94       	cli
    76ea:	fe bf       	out	0x3e, r31	; 62
    76ec:	0f be       	out	0x3f, r0	; 63
    76ee:	ed bf       	out	0x3d, r30	; 61
    76f0:	c8 01       	movw	r24, r16
    76f2:	65 ef       	ldi	r22, 0xF5	; 245
    76f4:	73 e0       	ldi	r23, 0x03	; 3
    76f6:	4f ed       	ldi	r20, 0xDF	; 223
    76f8:	51 e0       	ldi	r21, 0x01	; 1
    76fa:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    76fe:	00 d0       	rcall	.+0      	; 0x7700 <systemGenerateReport+0x2dc>
    7700:	00 d0       	rcall	.+0      	; 0x7702 <systemGenerateReport+0x2de>
    7702:	00 d0       	rcall	.+0      	; 0x7704 <systemGenerateReport+0x2e0>
    7704:	ed b7       	in	r30, 0x3d	; 61
    7706:	fe b7       	in	r31, 0x3e	; 62
    7708:	31 96       	adiw	r30, 0x01	; 1
    770a:	ad b7       	in	r26, 0x3d	; 61
    770c:	be b7       	in	r27, 0x3e	; 62
    770e:	12 96       	adiw	r26, 0x02	; 2
    7710:	1c 93       	st	X, r17
    7712:	0e 93       	st	-X, r16
    7714:	11 97       	sbiw	r26, 0x01	; 1
    7716:	8d e0       	ldi	r24, 0x0D	; 13
    7718:	96 e0       	ldi	r25, 0x06	; 6
    771a:	93 83       	std	Z+3, r25	; 0x03
    771c:	82 83       	std	Z+2, r24	; 0x02
    771e:	ce 01       	movw	r24, r28
    7720:	8b 5a       	subi	r24, 0xAB	; 171
    7722:	9f 4f       	sbci	r25, 0xFF	; 255
    7724:	95 83       	std	Z+5, r25	; 0x05
    7726:	84 83       	std	Z+4, r24	; 0x04
    7728:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    772c:	ed b7       	in	r30, 0x3d	; 61
    772e:	fe b7       	in	r31, 0x3e	; 62
    7730:	36 96       	adiw	r30, 0x06	; 6
    7732:	0f b6       	in	r0, 0x3f	; 63
    7734:	f8 94       	cli
    7736:	fe bf       	out	0x3e, r31	; 62
    7738:	0f be       	out	0x3f, r0	; 63
    773a:	ed bf       	out	0x3d, r30	; 61
    773c:	c8 01       	movw	r24, r16
    773e:	65 ef       	ldi	r22, 0xF5	; 245
    7740:	73 e0       	ldi	r23, 0x03	; 3
    7742:	4f ed       	ldi	r20, 0xDF	; 223
    7744:	51 e0       	ldi	r21, 0x01	; 1
    7746:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    774a:	00 d0       	rcall	.+0      	; 0x774c <systemGenerateReport+0x328>
    774c:	00 d0       	rcall	.+0      	; 0x774e <systemGenerateReport+0x32a>
    774e:	00 d0       	rcall	.+0      	; 0x7750 <systemGenerateReport+0x32c>
    7750:	ed b7       	in	r30, 0x3d	; 61
    7752:	fe b7       	in	r31, 0x3e	; 62
    7754:	31 96       	adiw	r30, 0x01	; 1
    7756:	ad b7       	in	r26, 0x3d	; 61
    7758:	be b7       	in	r27, 0x3e	; 62
    775a:	12 96       	adiw	r26, 0x02	; 2
    775c:	1c 93       	st	X, r17
    775e:	0e 93       	st	-X, r16
    7760:	11 97       	sbiw	r26, 0x01	; 1
    7762:	8b ef       	ldi	r24, 0xFB	; 251
    7764:	95 e0       	ldi	r25, 0x05	; 5
    7766:	93 83       	std	Z+3, r25	; 0x03
    7768:	82 83       	std	Z+2, r24	; 0x02
    776a:	87 e9       	ldi	r24, 0x97	; 151
    776c:	97 e0       	ldi	r25, 0x07	; 7
    776e:	95 83       	std	Z+5, r25	; 0x05
    7770:	84 83       	std	Z+4, r24	; 0x04
    7772:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    7776:	ed b7       	in	r30, 0x3d	; 61
    7778:	fe b7       	in	r31, 0x3e	; 62
    777a:	36 96       	adiw	r30, 0x06	; 6
    777c:	0f b6       	in	r0, 0x3f	; 63
    777e:	f8 94       	cli
    7780:	fe bf       	out	0x3e, r31	; 62
    7782:	0f be       	out	0x3f, r0	; 63
    7784:	ed bf       	out	0x3d, r30	; 61
    7786:	c8 01       	movw	r24, r16
    7788:	65 ef       	ldi	r22, 0xF5	; 245
    778a:	73 e0       	ldi	r23, 0x03	; 3
    778c:	4f ed       	ldi	r20, 0xDF	; 223
    778e:	51 e0       	ldi	r21, 0x01	; 1
    7790:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7794:	87 e0       	ldi	r24, 0x07	; 7
    7796:	65 ef       	ldi	r22, 0xF5	; 245
    7798:	73 e0       	ldi	r23, 0x03	; 3
    779a:	41 e0       	ldi	r20, 0x01	; 1
    779c:	2f ed       	ldi	r18, 0xDF	; 223
    779e:	31 e0       	ldi	r19, 0x01	; 1
    77a0:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    77a4:	8b e0       	ldi	r24, 0x0B	; 11
    77a6:	65 ef       	ldi	r22, 0xF5	; 245
    77a8:	73 e0       	ldi	r23, 0x03	; 3
    77aa:	4a e2       	ldi	r20, 0x2A	; 42
    77ac:	2f ed       	ldi	r18, 0xDF	; 223
    77ae:	31 e0       	ldi	r19, 0x01	; 1
    77b0:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    77b4:	89 e0       	ldi	r24, 0x09	; 9
    77b6:	65 ef       	ldi	r22, 0xF5	; 245
    77b8:	73 e0       	ldi	r23, 0x03	; 3
    77ba:	41 e0       	ldi	r20, 0x01	; 1
    77bc:	2f ed       	ldi	r18, 0xDF	; 223
    77be:	31 e0       	ldi	r19, 0x01	; 1
    77c0:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    77c4:	8c e0       	ldi	r24, 0x0C	; 12
    77c6:	65 ef       	ldi	r22, 0xF5	; 245
    77c8:	73 e0       	ldi	r23, 0x03	; 3
    77ca:	41 e0       	ldi	r20, 0x01	; 1
    77cc:	2f ed       	ldi	r18, 0xDF	; 223
    77ce:	31 e0       	ldi	r19, 0x01	; 1
    77d0:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    77d4:	81 ee       	ldi	r24, 0xE1	; 225
    77d6:	91 e0       	ldi	r25, 0x01	; 1
    77d8:	0e 94 08 26 	call	0x4c10	; 0x4c10 <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    77dc:	80 e8       	ldi	r24, 0x80	; 128
    77de:	80 93 b7 01 	sts	0x01B7, r24
		  LengthMessage81=RepPos+1;
    77e2:	80 91 df 01 	lds	r24, 0x01DF
    77e6:	90 91 e0 01 	lds	r25, 0x01E0
    77ea:	01 96       	adiw	r24, 0x01	; 1
    77ec:	90 93 90 01 	sts	0x0190, r25
    77f0:	80 93 8f 01 	sts	0x018F, r24
		  IsFreePrinting=True;
    77f4:	81 e0       	ldi	r24, 0x01	; 1
    77f6:	80 93 aa 01 	sts	0x01AA, r24
          IsBusyFreePrinting=True;
    77fa:	80 93 b6 01 	sts	0x01B6, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    77fe:	83 e0       	ldi	r24, 0x03	; 3
    7800:	0c 94 23 45 	jmp	0x8a46	; 0x8a46 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    7804:	80 91 b6 01 	lds	r24, 0x01B6
    7808:	88 23       	and	r24, r24
    780a:	11 f0       	breq	.+4      	; 0x7810 <systemGenerateReport+0x3ec>
    780c:	0c 94 2b 45 	jmp	0x8a56	; 0x8a56 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    7810:	84 e0       	ldi	r24, 0x04	; 4
    7812:	0c 94 23 45 	jmp	0x8a46	; 0x8a46 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    7816:	10 92 e0 01 	sts	0x01E0, r1
    781a:	10 92 df 01 	sts	0x01DF, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    781e:	81 e0       	ldi	r24, 0x01	; 1
    7820:	65 ef       	ldi	r22, 0xF5	; 245
    7822:	73 e0       	ldi	r23, 0x03	; 3
    7824:	41 e0       	ldi	r20, 0x01	; 1
    7826:	2f ed       	ldi	r18, 0xDF	; 223
    7828:	31 e0       	ldi	r19, 0x01	; 1
    782a:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    782e:	8b e0       	ldi	r24, 0x0B	; 11
    7830:	65 ef       	ldi	r22, 0xF5	; 245
    7832:	73 e0       	ldi	r23, 0x03	; 3
    7834:	4a e2       	ldi	r20, 0x2A	; 42
    7836:	2f ed       	ldi	r18, 0xDF	; 223
    7838:	31 e0       	ldi	r19, 0x01	; 1
    783a:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    783e:	83 e0       	ldi	r24, 0x03	; 3
    7840:	65 ef       	ldi	r22, 0xF5	; 245
    7842:	73 e0       	ldi	r23, 0x03	; 3
    7844:	41 e0       	ldi	r20, 0x01	; 1
    7846:	2f ed       	ldi	r18, 0xDF	; 223
    7848:	31 e0       	ldi	r19, 0x01	; 1
    784a:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    784e:	8c e0       	ldi	r24, 0x0C	; 12
    7850:	65 ef       	ldi	r22, 0xF5	; 245
    7852:	73 e0       	ldi	r23, 0x03	; 3
    7854:	41 e0       	ldi	r20, 0x01	; 1
    7856:	2f ed       	ldi	r18, 0xDF	; 223
    7858:	31 e0       	ldi	r19, 0x01	; 1
    785a:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    785e:	e1 99       	sbic	0x1c, 1	; 28
    7860:	fe cf       	rjmp	.-4      	; 0x785e <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7862:	81 ec       	ldi	r24, 0xC1	; 193
    7864:	93 e0       	ldi	r25, 0x03	; 3
    7866:	9f bb       	out	0x1f, r25	; 31
    7868:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    786a:	e0 9a       	sbi	0x1c, 0	; 28
    786c:	8d b3       	in	r24, 0x1d	; 29
    786e:	9e 01       	movw	r18, r28
    7870:	2b 55       	subi	r18, 0x5B	; 91
    7872:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    7874:	81 30       	cpi	r24, 0x01	; 1
    7876:	79 f4       	brne	.+30     	; 0x7896 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    7878:	00 d0       	rcall	.+0      	; 0x787a <systemGenerateReport+0x456>
    787a:	00 d0       	rcall	.+0      	; 0x787c <systemGenerateReport+0x458>
    787c:	ad b7       	in	r26, 0x3d	; 61
    787e:	be b7       	in	r27, 0x3e	; 62
    7880:	12 96       	adiw	r26, 0x02	; 2
    7882:	3c 93       	st	X, r19
    7884:	2e 93       	st	-X, r18
    7886:	11 97       	sbiw	r26, 0x01	; 1
    7888:	84 ed       	ldi	r24, 0xD4	; 212
    788a:	95 e0       	ldi	r25, 0x05	; 5
    788c:	14 96       	adiw	r26, 0x04	; 4
    788e:	9c 93       	st	X, r25
    7890:	8e 93       	st	-X, r24
    7892:	13 97       	sbiw	r26, 0x03	; 3
    7894:	0a c0       	rjmp	.+20     	; 0x78aa <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    7896:	00 d0       	rcall	.+0      	; 0x7898 <systemGenerateReport+0x474>
    7898:	00 d0       	rcall	.+0      	; 0x789a <systemGenerateReport+0x476>
    789a:	ed b7       	in	r30, 0x3d	; 61
    789c:	fe b7       	in	r31, 0x3e	; 62
    789e:	32 83       	std	Z+2, r19	; 0x02
    78a0:	21 83       	std	Z+1, r18	; 0x01
    78a2:	8d ea       	ldi	r24, 0xAD	; 173
    78a4:	95 e0       	ldi	r25, 0x05	; 5
    78a6:	94 83       	std	Z+4, r25	; 0x04
    78a8:	83 83       	std	Z+3, r24	; 0x03
    78aa:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    78ae:	0f 90       	pop	r0
    78b0:	0f 90       	pop	r0
    78b2:	0f 90       	pop	r0
    78b4:	0f 90       	pop	r0
    78b6:	ce 01       	movw	r24, r28
    78b8:	8b 55       	subi	r24, 0x5B	; 91
    78ba:	9f 4f       	sbci	r25, 0xFF	; 255
    78bc:	65 ef       	ldi	r22, 0xF5	; 245
    78be:	73 e0       	ldi	r23, 0x03	; 3
    78c0:	4f ed       	ldi	r20, 0xDF	; 223
    78c2:	51 e0       	ldi	r21, 0x01	; 1
    78c4:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    78c8:	87 e0       	ldi	r24, 0x07	; 7
    78ca:	65 ef       	ldi	r22, 0xF5	; 245
    78cc:	73 e0       	ldi	r23, 0x03	; 3
    78ce:	41 e0       	ldi	r20, 0x01	; 1
    78d0:	2f ed       	ldi	r18, 0xDF	; 223
    78d2:	31 e0       	ldi	r19, 0x01	; 1
    78d4:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    78d8:	8b e0       	ldi	r24, 0x0B	; 11
    78da:	65 ef       	ldi	r22, 0xF5	; 245
    78dc:	73 e0       	ldi	r23, 0x03	; 3
    78de:	4a e2       	ldi	r20, 0x2A	; 42
    78e0:	2f ed       	ldi	r18, 0xDF	; 223
    78e2:	31 e0       	ldi	r19, 0x01	; 1
    78e4:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    78e8:	89 e0       	ldi	r24, 0x09	; 9
    78ea:	65 ef       	ldi	r22, 0xF5	; 245
    78ec:	73 e0       	ldi	r23, 0x03	; 3
    78ee:	41 e0       	ldi	r20, 0x01	; 1
    78f0:	2f ed       	ldi	r18, 0xDF	; 223
    78f2:	31 e0       	ldi	r19, 0x01	; 1
    78f4:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
          
		  cmdPrint=0b00000000;
    78f8:	10 92 b7 01 	sts	0x01B7, r1
		  LengthMessage81=RepPos+1;
    78fc:	80 91 df 01 	lds	r24, 0x01DF
    7900:	90 91 e0 01 	lds	r25, 0x01E0
    7904:	01 96       	adiw	r24, 0x01	; 1
    7906:	90 93 90 01 	sts	0x0190, r25
    790a:	80 93 8f 01 	sts	0x018F, r24

		  IsFreePrinting=True;
    790e:	81 e0       	ldi	r24, 0x01	; 1
    7910:	80 93 aa 01 	sts	0x01AA, r24
	      IsBusyFreePrinting=True;
    7914:	80 93 b6 01 	sts	0x01B6, r24

		  stGenerateReport=grWaitLabelPrinted;
    7918:	85 e0       	ldi	r24, 0x05	; 5
    791a:	0c 94 23 45 	jmp	0x8a46	; 0x8a46 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    791e:	80 91 f0 01 	lds	r24, 0x01F0
    7922:	81 50       	subi	r24, 0x01	; 1
    7924:	88 30       	cpi	r24, 0x08	; 8
    7926:	10 f0       	brcs	.+4      	; 0x792c <systemGenerateReport+0x508>
    7928:	0c 94 2b 45 	jmp	0x8a56	; 0x8a56 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    792c:	ce 01       	movw	r24, r28
    792e:	07 96       	adiw	r24, 0x07	; 7
    7930:	65 e4       	ldi	r22, 0x45	; 69
    7932:	70 e0       	ldi	r23, 0x00	; 0
    7934:	48 e0       	ldi	r20, 0x08	; 8
    7936:	50 e0       	ldi	r21, 0x00	; 0
    7938:	22 e4       	ldi	r18, 0x42	; 66
    793a:	33 e1       	ldi	r19, 0x13	; 19
    793c:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    7940:	90 91 f0 01 	lds	r25, 0x01F0
    7944:	fe 01       	movw	r30, r28
    7946:	e9 0f       	add	r30, r25
    7948:	f1 1d       	adc	r31, r1
    794a:	86 81       	ldd	r24, Z+6	; 0x06
    794c:	80 93 ed 01 	sts	0x01ED, r24
			  if (PumpNum>0){
    7950:	88 23       	and	r24, r24
    7952:	09 f4       	brne	.+2      	; 0x7956 <systemGenerateReport+0x532>
    7954:	4b c0       	rjmp	.+150    	; 0x79ec <systemGenerateReport+0x5c8>
    7956:	91 9f       	mul	r25, r17
    7958:	b0 01       	movw	r22, r0
    795a:	11 24       	eor	r1, r1
    795c:	61 5b       	subi	r22, 0xB1	; 177
    795e:	7f 4f       	sbci	r23, 0xFF	; 255
    7960:	ce 01       	movw	r24, r28
    7962:	01 96       	adiw	r24, 0x01	; 1
    7964:	46 e0       	ldi	r20, 0x06	; 6
    7966:	50 e0       	ldi	r21, 0x00	; 0
    7968:	22 e4       	ldi	r18, 0x42	; 66
    796a:	33 e1       	ldi	r19, 0x13	; 19
    796c:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    7970:	80 91 ef 01 	lds	r24, 0x01EF
    7974:	fe 01       	movw	r30, r28
    7976:	e8 0f       	add	r30, r24
    7978:	f1 1d       	adc	r31, r1
    797a:	80 81       	ld	r24, Z
    797c:	80 93 ee 01 	sts	0x01EE, r24
    7980:	67 e6       	ldi	r22, 0x67	; 103
    7982:	c6 2e       	mov	r12, r22
    7984:	67 e0       	ldi	r22, 0x07	; 7
    7986:	d6 2e       	mov	r13, r22

				  if (xGrade>0){
    7988:	88 23       	and	r24, r24
    798a:	99 f0       	breq	.+38     	; 0x79b2 <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    798c:	b6 01       	movw	r22, r12
    798e:	0e 94 53 33 	call	0x66a6	; 0x66a6 <GetProductName>
                      GradeUsed=xGrade;
    7992:	80 91 ee 01 	lds	r24, 0x01EE
    7996:	80 93 eb 01 	sts	0x01EB, r24
					  xGrade=xNozzle;//
    799a:	80 91 ef 01 	lds	r24, 0x01EF
    799e:	80 93 ee 01 	sts	0x01EE, r24
					  PumpNozzle=xNozzle;
    79a2:	80 93 ec 01 	sts	0x01EC, r24
					  xNozzle++;
    79a6:	8f 5f       	subi	r24, 0xFF	; 255
    79a8:	80 93 ef 01 	sts	0x01EF, r24
					  stGenerateReport=grCreateReportTotalizer;
    79ac:	88 e0       	ldi	r24, 0x08	; 8
    79ae:	0c 94 23 45 	jmp	0x8a46	; 0x8a46 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    79b2:	00 d0       	rcall	.+0      	; 0x79b4 <systemGenerateReport+0x590>
    79b4:	00 d0       	rcall	.+0      	; 0x79b6 <systemGenerateReport+0x592>
    79b6:	ad b7       	in	r26, 0x3d	; 61
    79b8:	be b7       	in	r27, 0x3e	; 62
    79ba:	12 96       	adiw	r26, 0x02	; 2
    79bc:	dc 92       	st	X, r13
    79be:	ce 92       	st	-X, r12
    79c0:	11 97       	sbiw	r26, 0x01	; 1
    79c2:	89 ea       	ldi	r24, 0xA9	; 169
    79c4:	95 e0       	ldi	r25, 0x05	; 5
    79c6:	14 96       	adiw	r26, 0x04	; 4
    79c8:	9c 93       	st	X, r25
    79ca:	8e 93       	st	-X, r24
    79cc:	13 97       	sbiw	r26, 0x03	; 3
    79ce:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
					   xNozzle++;
    79d2:	80 91 ef 01 	lds	r24, 0x01EF
    79d6:	8f 5f       	subi	r24, 0xFF	; 255
    79d8:	80 93 ef 01 	sts	0x01EF, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    79dc:	0f 90       	pop	r0
    79de:	0f 90       	pop	r0
    79e0:	0f 90       	pop	r0
    79e2:	0f 90       	pop	r0
    79e4:	87 30       	cpi	r24, 0x07	; 7
    79e6:	10 f4       	brcc	.+4      	; 0x79ec <systemGenerateReport+0x5c8>
    79e8:	0c 94 2b 45 	jmp	0x8a56	; 0x8a56 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    79ec:	87 e0       	ldi	r24, 0x07	; 7
    79ee:	0c 94 23 45 	jmp	0x8a46	; 0x8a46 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    79f2:	81 e0       	ldi	r24, 0x01	; 1
    79f4:	80 93 ef 01 	sts	0x01EF, r24
	      xPump++;
    79f8:	80 91 f0 01 	lds	r24, 0x01F0
    79fc:	8f 5f       	subi	r24, 0xFF	; 255
    79fe:	80 93 f0 01 	sts	0x01F0, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    7a02:	89 30       	cpi	r24, 0x09	; 9
    7a04:	08 f4       	brcc	.+2      	; 0x7a08 <systemGenerateReport+0x5e4>
    7a06:	93 c4       	rjmp	.+2342   	; 0x832e <systemGenerateReport+0xf0a>
    7a08:	8a e0       	ldi	r24, 0x0A	; 10
    7a0a:	0c 94 23 45 	jmp	0x8a46	; 0x8a46 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    7a0e:	10 92 e0 01 	sts	0x01E0, r1
    7a12:	10 92 df 01 	sts	0x01DF, r1
    7a16:	e5 ef       	ldi	r30, 0xF5	; 245
    7a18:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7a1a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a1c:	b5 e0       	ldi	r27, 0x05	; 5
    7a1e:	e6 38       	cpi	r30, 0x86	; 134
    7a20:	fb 07       	cpc	r31, r27
    7a22:	d9 f7       	brne	.-10     	; 0x7a1a <systemGenerateReport+0x5f6>
    7a24:	fe 01       	movw	r30, r28
    7a26:	eb 55       	subi	r30, 0x5B	; 91
    7a28:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7a2a:	ce 01       	movw	r24, r28
    7a2c:	8b 50       	subi	r24, 0x0B	; 11
    7a2e:	9f 4f       	sbci	r25, 0xFF	; 255
    7a30:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a32:	e8 17       	cp	r30, r24
    7a34:	f9 07       	cpc	r31, r25
    7a36:	e1 f7       	brne	.-8      	; 0x7a30 <systemGenerateReport+0x60c>
    7a38:	ee e3       	ldi	r30, 0x3E	; 62
    7a3a:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    7a3c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a3e:	8e e0       	ldi	r24, 0x0E	; 14
    7a40:	ed 34       	cpi	r30, 0x4D	; 77
    7a42:	f8 07       	cpc	r31, r24
    7a44:	d9 f7       	brne	.-10     	; 0x7a3c <systemGenerateReport+0x618>
    7a46:	ee e0       	ldi	r30, 0x0E	; 14
    7a48:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    7a4a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a4c:	99 e0       	ldi	r25, 0x09	; 9
    7a4e:	ed 31       	cpi	r30, 0x1D	; 29
    7a50:	f9 07       	cpc	r31, r25
    7a52:	d9 f7       	brne	.-10     	; 0x7a4a <systemGenerateReport+0x626>
    7a54:	fe 01       	movw	r30, r28
    7a56:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    7a58:	ce 01       	movw	r24, r28
    7a5a:	88 96       	adiw	r24, 0x28	; 40
    7a5c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a5e:	e8 17       	cp	r30, r24
    7a60:	f9 07       	cpc	r31, r25
    7a62:	e1 f7       	brne	.-8      	; 0x7a5c <systemGenerateReport+0x638>
	     strMemory[i]=data;
    7a64:	ce 01       	movw	r24, r28
    7a66:	c7 96       	adiw	r24, 0x37	; 55
    7a68:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a6a:	e8 17       	cp	r30, r24
    7a6c:	f9 07       	cpc	r31, r25
    7a6e:	e1 f7       	brne	.-8      	; 0x7a68 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    7a70:	cf 01       	movw	r24, r30
    7a72:	0f 96       	adiw	r24, 0x0f	; 15
    7a74:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a76:	e8 17       	cp	r30, r24
    7a78:	f9 07       	cpc	r31, r25
    7a7a:	e1 f7       	brne	.-8      	; 0x7a74 <systemGenerateReport+0x650>
    7a7c:	fe 01       	movw	r30, r28
    7a7e:	ea 5b       	subi	r30, 0xBA	; 186
    7a80:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7a82:	cf 01       	movw	r24, r30
    7a84:	ee 2e       	mov	r14, r30
    7a86:	d9 2e       	mov	r13, r25
    7a88:	0f 96       	adiw	r24, 0x0f	; 15
    7a8a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a8c:	e8 17       	cp	r30, r24
    7a8e:	f9 07       	cpc	r31, r25
    7a90:	e1 f7       	brne	.-8      	; 0x7a8a <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    7a92:	80 91 ed 01 	lds	r24, 0x01ED
    7a96:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
		  if (FIPAddr>0){
    7a9a:	88 23       	and	r24, r24
    7a9c:	49 f1       	breq	.+82     	; 0x7af0 <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    7a9e:	f8 2e       	mov	r15, r24
    7aa0:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    7aa2:	80 e0       	ldi	r24, 0x00	; 0
    7aa4:	60 e0       	ldi	r22, 0x00	; 0
    7aa6:	4f 2d       	mov	r20, r15
    7aa8:	20 91 ec 01 	lds	r18, 0x01EC
    7aac:	8e 01       	movw	r16, r28
    7aae:	07 5e       	subi	r16, 0xE7	; 231
    7ab0:	1f 4f       	sbci	r17, 0xFF	; 255
    7ab2:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    7ab6:	81 e0       	ldi	r24, 0x01	; 1
    7ab8:	60 e0       	ldi	r22, 0x00	; 0
    7aba:	4f 2d       	mov	r20, r15
    7abc:	20 91 ec 01 	lds	r18, 0x01EC
    7ac0:	8e 01       	movw	r16, r28
    7ac2:	08 5d       	subi	r16, 0xD8	; 216
    7ac4:	1f 4f       	sbci	r17, 0xFF	; 255
    7ac6:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    7aca:	80 e0       	ldi	r24, 0x00	; 0
    7acc:	61 e0       	ldi	r22, 0x01	; 1
    7ace:	4f 2d       	mov	r20, r15
    7ad0:	20 91 ec 01 	lds	r18, 0x01EC
    7ad4:	8e 01       	movw	r16, r28
    7ad6:	09 5c       	subi	r16, 0xC9	; 201
    7ad8:	1f 4f       	sbci	r17, 0xFF	; 255
    7ada:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    7ade:	81 e0       	ldi	r24, 0x01	; 1
    7ae0:	61 e0       	ldi	r22, 0x01	; 1
    7ae2:	4f 2d       	mov	r20, r15
    7ae4:	20 91 ec 01 	lds	r18, 0x01EC
    7ae8:	0e 2d       	mov	r16, r14
    7aea:	1d 2d       	mov	r17, r13
    7aec:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    7af0:	80 e0       	ldi	r24, 0x00	; 0
    7af2:	be 01       	movw	r22, r28
    7af4:	69 5c       	subi	r22, 0xC9	; 201
    7af6:	7f 4f       	sbci	r23, 0xFF	; 255
    7af8:	ae 01       	movw	r20, r28
    7afa:	47 5e       	subi	r20, 0xE7	; 231
    7afc:	5f 4f       	sbci	r21, 0xFF	; 255
    7afe:	2e e0       	ldi	r18, 0x0E	; 14
    7b00:	39 e0       	ldi	r19, 0x09	; 9
    7b02:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    7b06:	8e e0       	ldi	r24, 0x0E	; 14
    7b08:	99 e0       	ldi	r25, 0x09	; 9
    7b0a:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <IsMinus>
    7b0e:	81 30       	cpi	r24, 0x01	; 1
    7b10:	21 f4       	brne	.+8      	; 0x7b1a <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    7b12:	8e e0       	ldi	r24, 0x0E	; 14
    7b14:	99 e0       	ldi	r25, 0x09	; 9
    7b16:	0e 94 68 30 	call	0x60d0	; 0x60d0 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7b1a:	e1 99       	sbic	0x1c, 1	; 28
    7b1c:	fe cf       	rjmp	.-4      	; 0x7b1a <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7b1e:	57 e3       	ldi	r21, 0x37	; 55
    7b20:	85 2e       	mov	r8, r21
    7b22:	51 e0       	ldi	r21, 0x01	; 1
    7b24:	95 2e       	mov	r9, r21
    7b26:	9f ba       	out	0x1f, r9	; 31
    7b28:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7b2a:	e0 9a       	sbi	0x1c, 0	; 28
    7b2c:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    7b2e:	82 30       	cpi	r24, 0x02	; 2
    7b30:	79 f4       	brne	.+30     	; 0x7b50 <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7b32:	8e 01       	movw	r16, r28
    7b34:	01 5f       	subi	r16, 0xF1	; 241
    7b36:	1f 4f       	sbci	r17, 0xFF	; 255
    7b38:	c8 01       	movw	r24, r16
    7b3a:	60 91 ed 01 	lds	r22, 0x01ED
    7b3e:	40 91 ec 01 	lds	r20, 0x01EC
    7b42:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    7b46:	82 e0       	ldi	r24, 0x02	; 2
    7b48:	b8 01       	movw	r22, r16
    7b4a:	4e e0       	ldi	r20, 0x0E	; 14
    7b4c:	59 e0       	ldi	r21, 0x09	; 9
    7b4e:	07 c0       	rjmp	.+14     	; 0x7b5e <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7b50:	80 e0       	ldi	r24, 0x00	; 0
    7b52:	be 01       	movw	r22, r28
    7b54:	6a 5b       	subi	r22, 0xBA	; 186
    7b56:	7f 4f       	sbci	r23, 0xFF	; 255
    7b58:	ae 01       	movw	r20, r28
    7b5a:	48 5d       	subi	r20, 0xD8	; 216
    7b5c:	5f 4f       	sbci	r21, 0xFF	; 255
    7b5e:	2e e3       	ldi	r18, 0x3E	; 62
    7b60:	3e e0       	ldi	r19, 0x0E	; 14
    7b62:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    7b66:	8e e3       	ldi	r24, 0x3E	; 62
    7b68:	9e e0       	ldi	r25, 0x0E	; 14
    7b6a:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <IsMinus>
    7b6e:	81 30       	cpi	r24, 0x01	; 1
    7b70:	21 f4       	brne	.+8      	; 0x7b7a <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    7b72:	8e e3       	ldi	r24, 0x3E	; 62
    7b74:	9e e0       	ldi	r25, 0x0E	; 14
    7b76:	0e 94 68 30 	call	0x60d0	; 0x60d0 <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    7b7a:	80 91 eb 01 	lds	r24, 0x01EB
    7b7e:	61 ee       	ldi	r22, 0xE1	; 225
    7b80:	71 e0       	ldi	r23, 0x01	; 1
    7b82:	0e 94 d5 25 	call	0x4baa	; 0x4baa <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    7b86:	81 e0       	ldi	r24, 0x01	; 1
    7b88:	60 e0       	ldi	r22, 0x00	; 0
    7b8a:	78 e0       	ldi	r23, 0x08	; 8
    7b8c:	4e e0       	ldi	r20, 0x0E	; 14
    7b8e:	59 e0       	ldi	r21, 0x09	; 9
    7b90:	9b 01       	movw	r18, r22
    7b92:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    7b96:	81 e0       	ldi	r24, 0x01	; 1
    7b98:	61 eb       	ldi	r22, 0xB1	; 177
    7b9a:	78 e0       	ldi	r23, 0x08	; 8
    7b9c:	4e e3       	ldi	r20, 0x3E	; 62
    7b9e:	5e e0       	ldi	r21, 0x0E	; 14
    7ba0:	9b 01       	movw	r18, r22
    7ba2:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>


		  RemZeroLead(strDeltaMoney);
    7ba6:	8e e3       	ldi	r24, 0x3E	; 62
    7ba8:	9e e0       	ldi	r25, 0x0E	; 14
    7baa:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    7bae:	46 e4       	ldi	r20, 0x46	; 70
    7bb0:	c4 2e       	mov	r12, r20
    7bb2:	d1 2c       	mov	r13, r1
    7bb4:	cc 0e       	add	r12, r28
    7bb6:	dd 1e       	adc	r13, r29
    7bb8:	c6 01       	movw	r24, r12
    7bba:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		  RemZeroLead(strLastMoney);
    7bbe:	38 e2       	ldi	r19, 0x28	; 40
    7bc0:	e3 2e       	mov	r14, r19
    7bc2:	f1 2c       	mov	r15, r1
    7bc4:	ec 0e       	add	r14, r28
    7bc6:	fd 1e       	adc	r15, r29
    7bc8:	c7 01       	movw	r24, r14
    7bca:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    7bce:	8e e0       	ldi	r24, 0x0E	; 14
    7bd0:	99 e0       	ldi	r25, 0x09	; 9
    7bd2:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    7bd6:	27 e3       	ldi	r18, 0x37	; 55
    7bd8:	a2 2e       	mov	r10, r18
    7bda:	b1 2c       	mov	r11, r1
    7bdc:	ac 0e       	add	r10, r28
    7bde:	bd 1e       	adc	r11, r29
    7be0:	c5 01       	movw	r24, r10
    7be2:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
          RemZeroLead(strLastVolume);
    7be6:	8e 01       	movw	r16, r28
    7be8:	07 5e       	subi	r16, 0xE7	; 231
    7bea:	1f 4f       	sbci	r17, 0xFF	; 255
    7bec:	c8 01       	movw	r24, r16
    7bee:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    7bf2:	8e e3       	ldi	r24, 0x3E	; 62
    7bf4:	9e e0       	ldi	r25, 0x0E	; 14
    7bf6:	0e 94 de 39 	call	0x73bc	; 0x73bc <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    7bfa:	c6 01       	movw	r24, r12
    7bfc:	0e 94 de 39 	call	0x73bc	; 0x73bc <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    7c00:	c7 01       	movw	r24, r14
    7c02:	0e 94 de 39 	call	0x73bc	; 0x73bc <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    7c06:	8e e0       	ldi	r24, 0x0E	; 14
    7c08:	99 e0       	ldi	r25, 0x09	; 9
    7c0a:	0e 94 d1 39 	call	0x73a2	; 0x73a2 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    7c0e:	c8 01       	movw	r24, r16
    7c10:	0e 94 d1 39 	call	0x73a2	; 0x73a2 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    7c14:	c5 01       	movw	r24, r10
    7c16:	0e 94 d1 39 	call	0x73a2	; 0x73a2 <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    7c1a:	8e e3       	ldi	r24, 0x3E	; 62
    7c1c:	9e e0       	ldi	r25, 0x0E	; 14
    7c1e:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    7c22:	c6 01       	movw	r24, r12
    7c24:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
		  FormatCurrency(strLastMoney);
    7c28:	c7 01       	movw	r24, r14
    7c2a:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    7c2e:	8e e0       	ldi	r24, 0x0E	; 14
    7c30:	99 e0       	ldi	r25, 0x09	; 9
    7c32:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
		  FormatCurrency(strLastVolume);
    7c36:	c8 01       	movw	r24, r16
    7c38:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    7c3c:	c5 01       	movw	r24, r10
    7c3e:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    7c42:	81 e0       	ldi	r24, 0x01	; 1
    7c44:	65 ef       	ldi	r22, 0xF5	; 245
    7c46:	73 e0       	ldi	r23, 0x03	; 3
    7c48:	41 e0       	ldi	r20, 0x01	; 1
    7c4a:	2f ed       	ldi	r18, 0xDF	; 223
    7c4c:	31 e0       	ldi	r19, 0x01	; 1
    7c4e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7c52:	8b e0       	ldi	r24, 0x0B	; 11
    7c54:	65 ef       	ldi	r22, 0xF5	; 245
    7c56:	73 e0       	ldi	r23, 0x03	; 3
    7c58:	4a e2       	ldi	r20, 0x2A	; 42
    7c5a:	2f ed       	ldi	r18, 0xDF	; 223
    7c5c:	31 e0       	ldi	r19, 0x01	; 1
    7c5e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7c62:	83 e0       	ldi	r24, 0x03	; 3
    7c64:	65 ef       	ldi	r22, 0xF5	; 245
    7c66:	73 e0       	ldi	r23, 0x03	; 3
    7c68:	41 e0       	ldi	r20, 0x01	; 1
    7c6a:	2f ed       	ldi	r18, 0xDF	; 223
    7c6c:	31 e0       	ldi	r19, 0x01	; 1
    7c6e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7c72:	8c e0       	ldi	r24, 0x0C	; 12
    7c74:	65 ef       	ldi	r22, 0xF5	; 245
    7c76:	73 e0       	ldi	r23, 0x03	; 3
    7c78:	41 e0       	ldi	r20, 0x01	; 1
    7c7a:	2f ed       	ldi	r18, 0xDF	; 223
    7c7c:	31 e0       	ldi	r19, 0x01	; 1
    7c7e:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7c82:	e1 99       	sbic	0x1c, 1	; 28
    7c84:	fe cf       	rjmp	.-4      	; 0x7c82 <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7c86:	9f ba       	out	0x1f, r9	; 31
    7c88:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7c8a:	e0 9a       	sbi	0x1c, 0	; 28
    7c8c:	8d b3       	in	r24, 0x1d	; 29
    7c8e:	97 e6       	ldi	r25, 0x67	; 103
    7c90:	c9 2e       	mov	r12, r25
    7c92:	97 e0       	ldi	r25, 0x07	; 7
    7c94:	d9 2e       	mov	r13, r25
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    7c96:	82 30       	cpi	r24, 0x02	; 2
    7c98:	09 f0       	breq	.+2      	; 0x7c9c <systemGenerateReport+0x878>
    7c9a:	84 c0       	rjmp	.+264    	; 0x7da4 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    7c9c:	0f e0       	ldi	r16, 0x0F	; 15
    7c9e:	e0 2e       	mov	r14, r16
    7ca0:	f1 2c       	mov	r15, r1
    7ca2:	ec 0e       	add	r14, r28
    7ca4:	fd 1e       	adc	r15, r29
    7ca6:	c7 01       	movw	r24, r14
    7ca8:	60 91 ed 01 	lds	r22, 0x01ED
    7cac:	40 91 ec 01 	lds	r20, 0x01EC
    7cb0:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    7cb4:	00 d0       	rcall	.+0      	; 0x7cb6 <systemGenerateReport+0x892>
    7cb6:	00 d0       	rcall	.+0      	; 0x7cb8 <systemGenerateReport+0x894>
    7cb8:	00 d0       	rcall	.+0      	; 0x7cba <systemGenerateReport+0x896>
    7cba:	ed b7       	in	r30, 0x3d	; 61
    7cbc:	fe b7       	in	r31, 0x3e	; 62
    7cbe:	31 96       	adiw	r30, 0x01	; 1
    7cc0:	8e 01       	movw	r16, r28
    7cc2:	0f 56       	subi	r16, 0x6F	; 111
    7cc4:	1f 4f       	sbci	r17, 0xFF	; 255
    7cc6:	ad b7       	in	r26, 0x3d	; 61
    7cc8:	be b7       	in	r27, 0x3e	; 62
    7cca:	12 96       	adiw	r26, 0x02	; 2
    7ccc:	1c 93       	st	X, r17
    7cce:	0e 93       	st	-X, r16
    7cd0:	11 97       	sbiw	r26, 0x01	; 1
    7cd2:	8c e9       	ldi	r24, 0x9C	; 156
    7cd4:	95 e0       	ldi	r25, 0x05	; 5
    7cd6:	93 83       	std	Z+3, r25	; 0x03
    7cd8:	82 83       	std	Z+2, r24	; 0x02
    7cda:	f5 82       	std	Z+5, r15	; 0x05
    7cdc:	e4 82       	std	Z+4, r14	; 0x04
    7cde:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    7ce2:	d6 01       	movw	r26, r12
    7ce4:	0d 90       	ld	r0, X+
    7ce6:	00 20       	and	r0, r0
    7ce8:	e9 f7       	brne	.-6      	; 0x7ce4 <systemGenerateReport+0x8c0>
    7cea:	11 97       	sbiw	r26, 0x01	; 1
    7cec:	ac 19       	sub	r26, r12
    7cee:	bd 09       	sbc	r27, r13
    7cf0:	f8 01       	movw	r30, r16
    7cf2:	01 90       	ld	r0, Z+
    7cf4:	00 20       	and	r0, r0
    7cf6:	e9 f7       	brne	.-6      	; 0x7cf2 <systemGenerateReport+0x8ce>
    7cf8:	31 97       	sbiw	r30, 0x01	; 1
    7cfa:	0e 1b       	sub	r16, r30
    7cfc:	0a 1b       	sub	r16, r26
    7cfe:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7d00:	ed b7       	in	r30, 0x3d	; 61
    7d02:	fe b7       	in	r31, 0x3e	; 62
    7d04:	36 96       	adiw	r30, 0x06	; 6
    7d06:	0f b6       	in	r0, 0x3f	; 63
    7d08:	f8 94       	cli
    7d0a:	fe bf       	out	0x3e, r31	; 62
    7d0c:	0f be       	out	0x3f, r0	; 63
    7d0e:	ed bf       	out	0x3d, r30	; 61
    7d10:	fe 01       	movw	r30, r28
    7d12:	e3 58       	subi	r30, 0x83	; 131
    7d14:	ff 4f       	sbci	r31, 0xFF	; 255
    7d16:	10 16       	cp	r1, r16
    7d18:	74 f4       	brge	.+28     	; 0x7d36 <systemGenerateReport+0x912>
    7d1a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7d1c:	90 e2       	ldi	r25, 0x20	; 32
    7d1e:	02 c0       	rjmp	.+4      	; 0x7d24 <systemGenerateReport+0x900>
    7d20:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7d22:	8f 5f       	subi	r24, 0xFF	; 255
    7d24:	80 17       	cp	r24, r16
    7d26:	e0 f3       	brcs	.-8      	; 0x7d20 <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7d28:	fe 01       	movw	r30, r28
    7d2a:	e3 58       	subi	r30, 0x83	; 131
    7d2c:	ff 4f       	sbci	r31, 0xFF	; 255
    7d2e:	e0 0f       	add	r30, r16
    7d30:	f1 1d       	adc	r31, r1
    7d32:	10 82       	st	Z, r1
    7d34:	03 c0       	rjmp	.+6      	; 0x7d3c <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    7d36:	80 e2       	ldi	r24, 0x20	; 32
    7d38:	80 83       	st	Z, r24
	 strTab[1]=0;
    7d3a:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    7d3c:	8d b7       	in	r24, 0x3d	; 61
    7d3e:	9e b7       	in	r25, 0x3e	; 62
    7d40:	0e 97       	sbiw	r24, 0x0e	; 14
    7d42:	0f b6       	in	r0, 0x3f	; 63
    7d44:	f8 94       	cli
    7d46:	9e bf       	out	0x3e, r25	; 62
    7d48:	0f be       	out	0x3f, r0	; 63
    7d4a:	8d bf       	out	0x3d, r24	; 61
    7d4c:	ed b7       	in	r30, 0x3d	; 61
    7d4e:	fe b7       	in	r31, 0x3e	; 62
    7d50:	31 96       	adiw	r30, 0x01	; 1
    7d52:	ce 01       	movw	r24, r28
    7d54:	8b 55       	subi	r24, 0x5B	; 91
    7d56:	9f 4f       	sbci	r25, 0xFF	; 255
    7d58:	ad b7       	in	r26, 0x3d	; 61
    7d5a:	be b7       	in	r27, 0x3e	; 62
    7d5c:	12 96       	adiw	r26, 0x02	; 2
    7d5e:	9c 93       	st	X, r25
    7d60:	8e 93       	st	-X, r24
    7d62:	11 97       	sbiw	r26, 0x01	; 1
    7d64:	8a e8       	ldi	r24, 0x8A	; 138
    7d66:	95 e0       	ldi	r25, 0x05	; 5
    7d68:	93 83       	std	Z+3, r25	; 0x03
    7d6a:	82 83       	std	Z+2, r24	; 0x02
    7d6c:	80 91 ed 01 	lds	r24, 0x01ED
    7d70:	84 83       	std	Z+4, r24	; 0x04
    7d72:	15 82       	std	Z+5, r1	; 0x05
    7d74:	80 91 ec 01 	lds	r24, 0x01EC
    7d78:	86 83       	std	Z+6, r24	; 0x06
    7d7a:	17 82       	std	Z+7, r1	; 0x07
    7d7c:	87 e6       	ldi	r24, 0x67	; 103
    7d7e:	97 e0       	ldi	r25, 0x07	; 7
    7d80:	91 87       	std	Z+9, r25	; 0x09
    7d82:	80 87       	std	Z+8, r24	; 0x08
    7d84:	ce 01       	movw	r24, r28
    7d86:	83 58       	subi	r24, 0x83	; 131
    7d88:	9f 4f       	sbci	r25, 0xFF	; 255
    7d8a:	93 87       	std	Z+11, r25	; 0x0b
    7d8c:	82 87       	std	Z+10, r24	; 0x0a
    7d8e:	ce 01       	movw	r24, r28
    7d90:	8f 56       	subi	r24, 0x6F	; 111
    7d92:	9f 4f       	sbci	r25, 0xFF	; 255
    7d94:	95 87       	std	Z+13, r25	; 0x0d
    7d96:	84 87       	std	Z+12, r24	; 0x0c
    7d98:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    7d9c:	ed b7       	in	r30, 0x3d	; 61
    7d9e:	fe b7       	in	r31, 0x3e	; 62
    7da0:	3e 96       	adiw	r30, 0x0e	; 14
    7da2:	27 c0       	rjmp	.+78     	; 0x7df2 <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    7da4:	8d b7       	in	r24, 0x3d	; 61
    7da6:	9e b7       	in	r25, 0x3e	; 62
    7da8:	0a 97       	sbiw	r24, 0x0a	; 10
    7daa:	0f b6       	in	r0, 0x3f	; 63
    7dac:	f8 94       	cli
    7dae:	9e bf       	out	0x3e, r25	; 62
    7db0:	0f be       	out	0x3f, r0	; 63
    7db2:	8d bf       	out	0x3d, r24	; 61
    7db4:	ed b7       	in	r30, 0x3d	; 61
    7db6:	fe b7       	in	r31, 0x3e	; 62
    7db8:	31 96       	adiw	r30, 0x01	; 1
    7dba:	ce 01       	movw	r24, r28
    7dbc:	8b 55       	subi	r24, 0x5B	; 91
    7dbe:	9f 4f       	sbci	r25, 0xFF	; 255
    7dc0:	ad b7       	in	r26, 0x3d	; 61
    7dc2:	be b7       	in	r27, 0x3e	; 62
    7dc4:	12 96       	adiw	r26, 0x02	; 2
    7dc6:	9c 93       	st	X, r25
    7dc8:	8e 93       	st	-X, r24
    7dca:	11 97       	sbiw	r26, 0x01	; 1
    7dcc:	8d e7       	ldi	r24, 0x7D	; 125
    7dce:	95 e0       	ldi	r25, 0x05	; 5
    7dd0:	93 83       	std	Z+3, r25	; 0x03
    7dd2:	82 83       	std	Z+2, r24	; 0x02
    7dd4:	80 91 ed 01 	lds	r24, 0x01ED
    7dd8:	84 83       	std	Z+4, r24	; 0x04
    7dda:	15 82       	std	Z+5, r1	; 0x05
    7ddc:	80 91 ec 01 	lds	r24, 0x01EC
    7de0:	86 83       	std	Z+6, r24	; 0x06
    7de2:	17 82       	std	Z+7, r1	; 0x07
    7de4:	d1 86       	std	Z+9, r13	; 0x09
    7de6:	c0 86       	std	Z+8, r12	; 0x08
    7de8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    7dec:	ed b7       	in	r30, 0x3d	; 61
    7dee:	fe b7       	in	r31, 0x3e	; 62
    7df0:	3a 96       	adiw	r30, 0x0a	; 10
    7df2:	0f b6       	in	r0, 0x3f	; 63
    7df4:	f8 94       	cli
    7df6:	fe bf       	out	0x3e, r31	; 62
    7df8:	0f be       	out	0x3f, r0	; 63
    7dfa:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    7dfc:	ce 01       	movw	r24, r28
    7dfe:	8b 55       	subi	r24, 0x5B	; 91
    7e00:	9f 4f       	sbci	r25, 0xFF	; 255
    7e02:	65 ef       	ldi	r22, 0xF5	; 245
    7e04:	73 e0       	ldi	r23, 0x03	; 3
    7e06:	4f ed       	ldi	r20, 0xDF	; 223
    7e08:	51 e0       	ldi	r21, 0x01	; 1
    7e0a:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    7e0e:	84 e0       	ldi	r24, 0x04	; 4
    7e10:	65 ef       	ldi	r22, 0xF5	; 245
    7e12:	73 e0       	ldi	r23, 0x03	; 3
    7e14:	41 e0       	ldi	r20, 0x01	; 1
    7e16:	2f ed       	ldi	r18, 0xDF	; 223
    7e18:	31 e0       	ldi	r19, 0x01	; 1
    7e1a:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7e1e:	8b e0       	ldi	r24, 0x0B	; 11
    7e20:	65 ef       	ldi	r22, 0xF5	; 245
    7e22:	73 e0       	ldi	r23, 0x03	; 3
    7e24:	4a e2       	ldi	r20, 0x2A	; 42
    7e26:	2f ed       	ldi	r18, 0xDF	; 223
    7e28:	31 e0       	ldi	r19, 0x01	; 1
    7e2a:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7e2e:	86 e0       	ldi	r24, 0x06	; 6
    7e30:	65 ef       	ldi	r22, 0xF5	; 245
    7e32:	73 e0       	ldi	r23, 0x03	; 3
    7e34:	41 e0       	ldi	r20, 0x01	; 1
    7e36:	2f ed       	ldi	r18, 0xDF	; 223
    7e38:	31 e0       	ldi	r19, 0x01	; 1
    7e3a:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    7e3e:	8c e0       	ldi	r24, 0x0C	; 12
    7e40:	65 ef       	ldi	r22, 0xF5	; 245
    7e42:	73 e0       	ldi	r23, 0x03	; 3
    7e44:	41 e0       	ldi	r20, 0x01	; 1
    7e46:	2f ed       	ldi	r18, 0xDF	; 223
    7e48:	31 e0       	ldi	r19, 0x01	; 1
    7e4a:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    7e4e:	de 01       	movw	r26, r28
    7e50:	d7 96       	adiw	r26, 0x37	; 55
    7e52:	fd 01       	movw	r30, r26
    7e54:	01 90       	ld	r0, Z+
    7e56:	00 20       	and	r0, r0
    7e58:	e9 f7       	brne	.-6      	; 0x7e54 <systemGenerateReport+0xa30>
    7e5a:	9a 2f       	mov	r25, r26
    7e5c:	9e 1b       	sub	r25, r30
    7e5e:	9e 5e       	subi	r25, 0xEE	; 238
    7e60:	de 01       	movw	r26, r28
    7e62:	a7 59       	subi	r26, 0x97	; 151
    7e64:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7e66:	19 16       	cp	r1, r25
    7e68:	7c f4       	brge	.+30     	; 0x7e88 <systemGenerateReport+0xa64>
    7e6a:	fd 01       	movw	r30, r26
    7e6c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7e6e:	20 e2       	ldi	r18, 0x20	; 32
    7e70:	02 c0       	rjmp	.+4      	; 0x7e76 <systemGenerateReport+0xa52>
    7e72:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7e74:	8f 5f       	subi	r24, 0xFF	; 255
    7e76:	89 17       	cp	r24, r25
    7e78:	e0 f3       	brcs	.-8      	; 0x7e72 <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7e7a:	fe 01       	movw	r30, r28
    7e7c:	e7 59       	subi	r30, 0x97	; 151
    7e7e:	ff 4f       	sbci	r31, 0xFF	; 255
    7e80:	e9 0f       	add	r30, r25
    7e82:	f1 1d       	adc	r31, r1
    7e84:	10 82       	st	Z, r1
    7e86:	04 c0       	rjmp	.+8      	; 0x7e90 <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    7e88:	80 e2       	ldi	r24, 0x20	; 32
    7e8a:	8c 93       	st	X, r24
	 strTab[1]=0;
    7e8c:	11 96       	adiw	r26, 0x01	; 1
    7e8e:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    7e90:	de 01       	movw	r26, r28
    7e92:	aa 5b       	subi	r26, 0xBA	; 186
    7e94:	bf 4f       	sbci	r27, 0xFF	; 255
    7e96:	fd 01       	movw	r30, r26
    7e98:	01 90       	ld	r0, Z+
    7e9a:	00 20       	and	r0, r0
    7e9c:	e9 f7       	brne	.-6      	; 0x7e98 <systemGenerateReport+0xa74>
    7e9e:	ae 1b       	sub	r26, r30
    7ea0:	a0 5f       	subi	r26, 0xF0	; 240
    7ea2:	fe 01       	movw	r30, r28
    7ea4:	e3 58       	subi	r30, 0x83	; 131
    7ea6:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7ea8:	1a 16       	cp	r1, r26
    7eaa:	74 f4       	brge	.+28     	; 0x7ec8 <systemGenerateReport+0xaa4>
    7eac:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7eae:	90 e2       	ldi	r25, 0x20	; 32
    7eb0:	02 c0       	rjmp	.+4      	; 0x7eb6 <systemGenerateReport+0xa92>
    7eb2:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7eb4:	8f 5f       	subi	r24, 0xFF	; 255
    7eb6:	8a 17       	cp	r24, r26
    7eb8:	e0 f3       	brcs	.-8      	; 0x7eb2 <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7eba:	fe 01       	movw	r30, r28
    7ebc:	e3 58       	subi	r30, 0x83	; 131
    7ebe:	ff 4f       	sbci	r31, 0xFF	; 255
    7ec0:	ea 0f       	add	r30, r26
    7ec2:	f1 1d       	adc	r31, r1
    7ec4:	10 82       	st	Z, r1
    7ec6:	03 c0       	rjmp	.+6      	; 0x7ece <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    7ec8:	80 e2       	ldi	r24, 0x20	; 32
    7eca:	80 83       	st	Z, r24
	 strTab[1]=0;
    7ecc:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7ece:	e1 99       	sbic	0x1c, 1	; 28
    7ed0:	fe cf       	rjmp	.-4      	; 0x7ece <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7ed2:	11 ec       	ldi	r17, 0xC1	; 193
    7ed4:	e1 2e       	mov	r14, r17
    7ed6:	13 e0       	ldi	r17, 0x03	; 3
    7ed8:	f1 2e       	mov	r15, r17
    7eda:	ff ba       	out	0x1f, r15	; 31
    7edc:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7ede:	e0 9a       	sbi	0x1c, 0	; 28
    7ee0:	8d b3       	in	r24, 0x1d	; 29
    7ee2:	9e 01       	movw	r18, r28
    7ee4:	2b 55       	subi	r18, 0x5B	; 91
    7ee6:	3f 4f       	sbci	r19, 0xFF	; 255
    7ee8:	ae 01       	movw	r20, r28
    7eea:	49 5c       	subi	r20, 0xC9	; 201
    7eec:	5f 4f       	sbci	r21, 0xFF	; 255
    7eee:	de 01       	movw	r26, r28
    7ef0:	a7 59       	subi	r26, 0x97	; 151
    7ef2:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7ef4:	81 30       	cpi	r24, 0x01	; 1
    7ef6:	49 f5       	brne	.+82     	; 0x7f4a <systemGenerateReport+0xb26>
    7ef8:	8d b7       	in	r24, 0x3d	; 61
    7efa:	9e b7       	in	r25, 0x3e	; 62
    7efc:	0c 97       	sbiw	r24, 0x0c	; 12
    7efe:	0f b6       	in	r0, 0x3f	; 63
    7f00:	f8 94       	cli
    7f02:	9e bf       	out	0x3e, r25	; 62
    7f04:	0f be       	out	0x3f, r0	; 63
    7f06:	8d bf       	out	0x3d, r24	; 61
    7f08:	6d b7       	in	r22, 0x3d	; 61
    7f0a:	7e b7       	in	r23, 0x3e	; 62
    7f0c:	6f 5f       	subi	r22, 0xFF	; 255
    7f0e:	7f 4f       	sbci	r23, 0xFF	; 255
    7f10:	ed b7       	in	r30, 0x3d	; 61
    7f12:	fe b7       	in	r31, 0x3e	; 62
    7f14:	32 83       	std	Z+2, r19	; 0x02
    7f16:	21 83       	std	Z+1, r18	; 0x01
    7f18:	8e e6       	ldi	r24, 0x6E	; 110
    7f1a:	95 e0       	ldi	r25, 0x05	; 5
    7f1c:	fb 01       	movw	r30, r22
    7f1e:	93 83       	std	Z+3, r25	; 0x03
    7f20:	82 83       	std	Z+2, r24	; 0x02
    7f22:	b5 83       	std	Z+5, r27	; 0x05
    7f24:	a4 83       	std	Z+4, r26	; 0x04
    7f26:	57 83       	std	Z+7, r21	; 0x07
    7f28:	46 83       	std	Z+6, r20	; 0x06
    7f2a:	ce 01       	movw	r24, r28
    7f2c:	83 58       	subi	r24, 0x83	; 131
    7f2e:	9f 4f       	sbci	r25, 0xFF	; 255
    7f30:	91 87       	std	Z+9, r25	; 0x09
    7f32:	80 87       	std	Z+8, r24	; 0x08
    7f34:	ce 01       	movw	r24, r28
    7f36:	8a 5b       	subi	r24, 0xBA	; 186
    7f38:	9f 4f       	sbci	r25, 0xFF	; 255
    7f3a:	93 87       	std	Z+11, r25	; 0x0b
    7f3c:	82 87       	std	Z+10, r24	; 0x0a
    7f3e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    7f42:	8d b7       	in	r24, 0x3d	; 61
    7f44:	9e b7       	in	r25, 0x3e	; 62
    7f46:	0c 96       	adiw	r24, 0x0c	; 12
    7f48:	1c c0       	rjmp	.+56     	; 0x7f82 <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    7f4a:	ed b7       	in	r30, 0x3d	; 61
    7f4c:	fe b7       	in	r31, 0x3e	; 62
    7f4e:	38 97       	sbiw	r30, 0x08	; 8
    7f50:	0f b6       	in	r0, 0x3f	; 63
    7f52:	f8 94       	cli
    7f54:	fe bf       	out	0x3e, r31	; 62
    7f56:	0f be       	out	0x3f, r0	; 63
    7f58:	ed bf       	out	0x3d, r30	; 61
    7f5a:	6d b7       	in	r22, 0x3d	; 61
    7f5c:	7e b7       	in	r23, 0x3e	; 62
    7f5e:	6f 5f       	subi	r22, 0xFF	; 255
    7f60:	7f 4f       	sbci	r23, 0xFF	; 255
    7f62:	32 83       	std	Z+2, r19	; 0x02
    7f64:	21 83       	std	Z+1, r18	; 0x01
    7f66:	83 e6       	ldi	r24, 0x63	; 99
    7f68:	95 e0       	ldi	r25, 0x05	; 5
    7f6a:	fb 01       	movw	r30, r22
    7f6c:	93 83       	std	Z+3, r25	; 0x03
    7f6e:	82 83       	std	Z+2, r24	; 0x02
    7f70:	b5 83       	std	Z+5, r27	; 0x05
    7f72:	a4 83       	std	Z+4, r26	; 0x04
    7f74:	57 83       	std	Z+7, r21	; 0x07
    7f76:	46 83       	std	Z+6, r20	; 0x06
    7f78:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    7f7c:	8d b7       	in	r24, 0x3d	; 61
    7f7e:	9e b7       	in	r25, 0x3e	; 62
    7f80:	08 96       	adiw	r24, 0x08	; 8
    7f82:	0f b6       	in	r0, 0x3f	; 63
    7f84:	f8 94       	cli
    7f86:	9e bf       	out	0x3e, r25	; 62
    7f88:	0f be       	out	0x3f, r0	; 63
    7f8a:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    7f8c:	ce 01       	movw	r24, r28
    7f8e:	8b 55       	subi	r24, 0x5B	; 91
    7f90:	9f 4f       	sbci	r25, 0xFF	; 255
    7f92:	65 ef       	ldi	r22, 0xF5	; 245
    7f94:	73 e0       	ldi	r23, 0x03	; 3
    7f96:	4f ed       	ldi	r20, 0xDF	; 223
    7f98:	51 e0       	ldi	r21, 0x01	; 1
    7f9a:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    7f9e:	de 01       	movw	r26, r28
    7fa0:	59 96       	adiw	r26, 0x19	; 25
    7fa2:	fd 01       	movw	r30, r26
    7fa4:	01 90       	ld	r0, Z+
    7fa6:	00 20       	and	r0, r0
    7fa8:	e9 f7       	brne	.-6      	; 0x7fa4 <systemGenerateReport+0xb80>
    7faa:	9a 2f       	mov	r25, r26
    7fac:	9e 1b       	sub	r25, r30
    7fae:	9e 5e       	subi	r25, 0xEE	; 238
    7fb0:	de 01       	movw	r26, r28
    7fb2:	a7 59       	subi	r26, 0x97	; 151
    7fb4:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7fb6:	19 16       	cp	r1, r25
    7fb8:	7c f4       	brge	.+30     	; 0x7fd8 <systemGenerateReport+0xbb4>
    7fba:	fd 01       	movw	r30, r26
    7fbc:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7fbe:	20 e2       	ldi	r18, 0x20	; 32
    7fc0:	02 c0       	rjmp	.+4      	; 0x7fc6 <systemGenerateReport+0xba2>
    7fc2:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7fc4:	8f 5f       	subi	r24, 0xFF	; 255
    7fc6:	89 17       	cp	r24, r25
    7fc8:	e0 f3       	brcs	.-8      	; 0x7fc2 <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7fca:	fe 01       	movw	r30, r28
    7fcc:	e7 59       	subi	r30, 0x97	; 151
    7fce:	ff 4f       	sbci	r31, 0xFF	; 255
    7fd0:	e9 0f       	add	r30, r25
    7fd2:	f1 1d       	adc	r31, r1
    7fd4:	10 82       	st	Z, r1
    7fd6:	04 c0       	rjmp	.+8      	; 0x7fe0 <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    7fd8:	80 e2       	ldi	r24, 0x20	; 32
    7fda:	8c 93       	st	X, r24
	 strTab[1]=0;
    7fdc:	11 96       	adiw	r26, 0x01	; 1
    7fde:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    7fe0:	de 01       	movw	r26, r28
    7fe2:	98 96       	adiw	r26, 0x28	; 40
    7fe4:	fd 01       	movw	r30, r26
    7fe6:	01 90       	ld	r0, Z+
    7fe8:	00 20       	and	r0, r0
    7fea:	e9 f7       	brne	.-6      	; 0x7fe6 <systemGenerateReport+0xbc2>
    7fec:	ae 1b       	sub	r26, r30
    7fee:	a0 5f       	subi	r26, 0xF0	; 240
    7ff0:	fe 01       	movw	r30, r28
    7ff2:	e3 58       	subi	r30, 0x83	; 131
    7ff4:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7ff6:	1a 16       	cp	r1, r26
    7ff8:	74 f4       	brge	.+28     	; 0x8016 <systemGenerateReport+0xbf2>
    7ffa:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7ffc:	90 e2       	ldi	r25, 0x20	; 32
    7ffe:	02 c0       	rjmp	.+4      	; 0x8004 <systemGenerateReport+0xbe0>
    8000:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    8002:	8f 5f       	subi	r24, 0xFF	; 255
    8004:	8a 17       	cp	r24, r26
    8006:	e0 f3       	brcs	.-8      	; 0x8000 <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    8008:	fe 01       	movw	r30, r28
    800a:	e3 58       	subi	r30, 0x83	; 131
    800c:	ff 4f       	sbci	r31, 0xFF	; 255
    800e:	ea 0f       	add	r30, r26
    8010:	f1 1d       	adc	r31, r1
    8012:	10 82       	st	Z, r1
    8014:	03 c0       	rjmp	.+6      	; 0x801c <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    8016:	80 e2       	ldi	r24, 0x20	; 32
    8018:	80 83       	st	Z, r24
	 strTab[1]=0;
    801a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    801c:	e1 99       	sbic	0x1c, 1	; 28
    801e:	fe cf       	rjmp	.-4      	; 0x801c <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8020:	ff ba       	out	0x1f, r15	; 31
    8022:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8024:	e0 9a       	sbi	0x1c, 0	; 28
    8026:	8d b3       	in	r24, 0x1d	; 29
    8028:	9e 01       	movw	r18, r28
    802a:	2b 55       	subi	r18, 0x5B	; 91
    802c:	3f 4f       	sbci	r19, 0xFF	; 255
    802e:	ae 01       	movw	r20, r28
    8030:	47 5e       	subi	r20, 0xE7	; 231
    8032:	5f 4f       	sbci	r21, 0xFF	; 255
    8034:	de 01       	movw	r26, r28
    8036:	a7 59       	subi	r26, 0x97	; 151
    8038:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    803a:	81 30       	cpi	r24, 0x01	; 1
    803c:	31 f5       	brne	.+76     	; 0x808a <systemGenerateReport+0xc66>
    803e:	ed b7       	in	r30, 0x3d	; 61
    8040:	fe b7       	in	r31, 0x3e	; 62
    8042:	3c 97       	sbiw	r30, 0x0c	; 12
    8044:	0f b6       	in	r0, 0x3f	; 63
    8046:	f8 94       	cli
    8048:	fe bf       	out	0x3e, r31	; 62
    804a:	0f be       	out	0x3f, r0	; 63
    804c:	ed bf       	out	0x3d, r30	; 61
    804e:	6d b7       	in	r22, 0x3d	; 61
    8050:	7e b7       	in	r23, 0x3e	; 62
    8052:	6f 5f       	subi	r22, 0xFF	; 255
    8054:	7f 4f       	sbci	r23, 0xFF	; 255
    8056:	32 83       	std	Z+2, r19	; 0x02
    8058:	21 83       	std	Z+1, r18	; 0x01
    805a:	84 e5       	ldi	r24, 0x54	; 84
    805c:	95 e0       	ldi	r25, 0x05	; 5
    805e:	fb 01       	movw	r30, r22
    8060:	93 83       	std	Z+3, r25	; 0x03
    8062:	82 83       	std	Z+2, r24	; 0x02
    8064:	b5 83       	std	Z+5, r27	; 0x05
    8066:	a4 83       	std	Z+4, r26	; 0x04
    8068:	57 83       	std	Z+7, r21	; 0x07
    806a:	46 83       	std	Z+6, r20	; 0x06
    806c:	ce 01       	movw	r24, r28
    806e:	83 58       	subi	r24, 0x83	; 131
    8070:	9f 4f       	sbci	r25, 0xFF	; 255
    8072:	91 87       	std	Z+9, r25	; 0x09
    8074:	80 87       	std	Z+8, r24	; 0x08
    8076:	ce 01       	movw	r24, r28
    8078:	88 96       	adiw	r24, 0x28	; 40
    807a:	93 87       	std	Z+11, r25	; 0x0b
    807c:	82 87       	std	Z+10, r24	; 0x0a
    807e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    8082:	8d b7       	in	r24, 0x3d	; 61
    8084:	9e b7       	in	r25, 0x3e	; 62
    8086:	0c 96       	adiw	r24, 0x0c	; 12
    8088:	1c c0       	rjmp	.+56     	; 0x80c2 <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    808a:	ed b7       	in	r30, 0x3d	; 61
    808c:	fe b7       	in	r31, 0x3e	; 62
    808e:	38 97       	sbiw	r30, 0x08	; 8
    8090:	0f b6       	in	r0, 0x3f	; 63
    8092:	f8 94       	cli
    8094:	fe bf       	out	0x3e, r31	; 62
    8096:	0f be       	out	0x3f, r0	; 63
    8098:	ed bf       	out	0x3d, r30	; 61
    809a:	6d b7       	in	r22, 0x3d	; 61
    809c:	7e b7       	in	r23, 0x3e	; 62
    809e:	6f 5f       	subi	r22, 0xFF	; 255
    80a0:	7f 4f       	sbci	r23, 0xFF	; 255
    80a2:	32 83       	std	Z+2, r19	; 0x02
    80a4:	21 83       	std	Z+1, r18	; 0x01
    80a6:	89 e4       	ldi	r24, 0x49	; 73
    80a8:	95 e0       	ldi	r25, 0x05	; 5
    80aa:	fb 01       	movw	r30, r22
    80ac:	93 83       	std	Z+3, r25	; 0x03
    80ae:	82 83       	std	Z+2, r24	; 0x02
    80b0:	b5 83       	std	Z+5, r27	; 0x05
    80b2:	a4 83       	std	Z+4, r26	; 0x04
    80b4:	57 83       	std	Z+7, r21	; 0x07
    80b6:	46 83       	std	Z+6, r20	; 0x06
    80b8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    80bc:	8d b7       	in	r24, 0x3d	; 61
    80be:	9e b7       	in	r25, 0x3e	; 62
    80c0:	08 96       	adiw	r24, 0x08	; 8
    80c2:	0f b6       	in	r0, 0x3f	; 63
    80c4:	f8 94       	cli
    80c6:	9e bf       	out	0x3e, r25	; 62
    80c8:	0f be       	out	0x3f, r0	; 63
    80ca:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    80cc:	ce 01       	movw	r24, r28
    80ce:	8b 55       	subi	r24, 0x5B	; 91
    80d0:	9f 4f       	sbci	r25, 0xFF	; 255
    80d2:	65 ef       	ldi	r22, 0xF5	; 245
    80d4:	73 e0       	ldi	r23, 0x03	; 3
    80d6:	4f ed       	ldi	r20, 0xDF	; 223
    80d8:	51 e0       	ldi	r21, 0x01	; 1
    80da:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>
    80de:	8e 01       	movw	r16, r28
    80e0:	07 59       	subi	r16, 0x97	; 151
    80e2:	1f 4f       	sbci	r17, 0xFF	; 255
    80e4:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    80e6:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    80e8:	d8 01       	movw	r26, r16
    80ea:	c8 01       	movw	r24, r16
    80ec:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    80ee:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    80f0:	e8 17       	cp	r30, r24
    80f2:	f9 07       	cpc	r31, r25
    80f4:	e1 f7       	brne	.-8      	; 0x80ee <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    80f6:	1c 96       	adiw	r26, 0x0c	; 12
    80f8:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    80fa:	e1 99       	sbic	0x1c, 1	; 28
    80fc:	fe cf       	rjmp	.-4      	; 0x80fa <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    80fe:	ff ba       	out	0x1f, r15	; 31
    8100:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8102:	e0 9a       	sbi	0x1c, 0	; 28
    8104:	8d b3       	in	r24, 0x1d	; 29
    8106:	9e 01       	movw	r18, r28
    8108:	2b 55       	subi	r18, 0x5B	; 91
    810a:	3f 4f       	sbci	r19, 0xFF	; 255
    810c:	de 01       	movw	r26, r28
    810e:	a7 59       	subi	r26, 0x97	; 151
    8110:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    8112:	81 30       	cpi	r24, 0x01	; 1
    8114:	71 f4       	brne	.+28     	; 0x8132 <systemGenerateReport+0xd0e>
    8116:	00 d0       	rcall	.+0      	; 0x8118 <systemGenerateReport+0xcf4>
    8118:	00 d0       	rcall	.+0      	; 0x811a <systemGenerateReport+0xcf6>
    811a:	00 d0       	rcall	.+0      	; 0x811c <systemGenerateReport+0xcf8>
    811c:	4d b7       	in	r20, 0x3d	; 61
    811e:	5e b7       	in	r21, 0x3e	; 62
    8120:	4f 5f       	subi	r20, 0xFF	; 255
    8122:	5f 4f       	sbci	r21, 0xFF	; 255
    8124:	ed b7       	in	r30, 0x3d	; 61
    8126:	fe b7       	in	r31, 0x3e	; 62
    8128:	32 83       	std	Z+2, r19	; 0x02
    812a:	21 83       	std	Z+1, r18	; 0x01
    812c:	8b e2       	ldi	r24, 0x2B	; 43
    812e:	95 e0       	ldi	r25, 0x05	; 5
    8130:	0d c0       	rjmp	.+26     	; 0x814c <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    8132:	00 d0       	rcall	.+0      	; 0x8134 <systemGenerateReport+0xd10>
    8134:	00 d0       	rcall	.+0      	; 0x8136 <systemGenerateReport+0xd12>
    8136:	00 d0       	rcall	.+0      	; 0x8138 <systemGenerateReport+0xd14>
    8138:	4d b7       	in	r20, 0x3d	; 61
    813a:	5e b7       	in	r21, 0x3e	; 62
    813c:	4f 5f       	subi	r20, 0xFF	; 255
    813e:	5f 4f       	sbci	r21, 0xFF	; 255
    8140:	ed b7       	in	r30, 0x3d	; 61
    8142:	fe b7       	in	r31, 0x3e	; 62
    8144:	32 83       	std	Z+2, r19	; 0x02
    8146:	21 83       	std	Z+1, r18	; 0x01
    8148:	8d e0       	ldi	r24, 0x0D	; 13
    814a:	95 e0       	ldi	r25, 0x05	; 5
    814c:	fa 01       	movw	r30, r20
    814e:	93 83       	std	Z+3, r25	; 0x03
    8150:	82 83       	std	Z+2, r24	; 0x02
    8152:	b5 83       	std	Z+5, r27	; 0x05
    8154:	a4 83       	std	Z+4, r26	; 0x04
    8156:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    815a:	8d b7       	in	r24, 0x3d	; 61
    815c:	9e b7       	in	r25, 0x3e	; 62
    815e:	06 96       	adiw	r24, 0x06	; 6
    8160:	0f b6       	in	r0, 0x3f	; 63
    8162:	f8 94       	cli
    8164:	9e bf       	out	0x3e, r25	; 62
    8166:	0f be       	out	0x3f, r0	; 63
    8168:	8d bf       	out	0x3d, r24	; 61
    816a:	ce 01       	movw	r24, r28
    816c:	8b 55       	subi	r24, 0x5B	; 91
    816e:	9f 4f       	sbci	r25, 0xFF	; 255
    8170:	65 ef       	ldi	r22, 0xF5	; 245
    8172:	73 e0       	ldi	r23, 0x03	; 3
    8174:	4f ed       	ldi	r20, 0xDF	; 223
    8176:	51 e0       	ldi	r21, 0x01	; 1
    8178:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    817c:	ee e0       	ldi	r30, 0x0E	; 14
    817e:	f9 e0       	ldi	r31, 0x09	; 9
    8180:	01 90       	ld	r0, Z+
    8182:	00 20       	and	r0, r0
    8184:	e9 f7       	brne	.-6      	; 0x8180 <systemGenerateReport+0xd5c>
    8186:	31 97       	sbiw	r30, 0x01	; 1
    8188:	ee 50       	subi	r30, 0x0E	; 14
    818a:	f9 40       	sbci	r31, 0x09	; 9
    818c:	97 e1       	ldi	r25, 0x17	; 23
    818e:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    8190:	19 16       	cp	r1, r25
    8192:	84 f4       	brge	.+32     	; 0x81b4 <systemGenerateReport+0xd90>
    8194:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    8196:	20 e2       	ldi	r18, 0x20	; 32
    8198:	04 c0       	rjmp	.+8      	; 0x81a2 <systemGenerateReport+0xd7e>
    819a:	d8 01       	movw	r26, r16
    819c:	2d 93       	st	X+, r18
    819e:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    81a0:	8f 5f       	subi	r24, 0xFF	; 255
    81a2:	89 17       	cp	r24, r25
    81a4:	d0 f3       	brcs	.-12     	; 0x819a <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    81a6:	fe 01       	movw	r30, r28
    81a8:	e7 59       	subi	r30, 0x97	; 151
    81aa:	ff 4f       	sbci	r31, 0xFF	; 255
    81ac:	e9 0f       	add	r30, r25
    81ae:	f1 1d       	adc	r31, r1
    81b0:	10 82       	st	Z, r1
    81b2:	06 c0       	rjmp	.+12     	; 0x81c0 <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    81b4:	fe 01       	movw	r30, r28
    81b6:	e7 59       	subi	r30, 0x97	; 151
    81b8:	ff 4f       	sbci	r31, 0xFF	; 255
    81ba:	80 e2       	ldi	r24, 0x20	; 32
    81bc:	80 83       	st	Z, r24
	 strTab[1]=0;
    81be:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    81c0:	ee e3       	ldi	r30, 0x3E	; 62
    81c2:	fe e0       	ldi	r31, 0x0E	; 14
    81c4:	01 90       	ld	r0, Z+
    81c6:	00 20       	and	r0, r0
    81c8:	e9 f7       	brne	.-6      	; 0x81c4 <systemGenerateReport+0xda0>
    81ca:	31 97       	sbiw	r30, 0x01	; 1
    81cc:	ee 53       	subi	r30, 0x3E	; 62
    81ce:	fe 40       	sbci	r31, 0x0E	; 14
    81d0:	9f e0       	ldi	r25, 0x0F	; 15
    81d2:	9e 1b       	sub	r25, r30
    81d4:	fe 01       	movw	r30, r28
    81d6:	e3 58       	subi	r30, 0x83	; 131
    81d8:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    81da:	19 16       	cp	r1, r25
    81dc:	74 f4       	brge	.+28     	; 0x81fa <systemGenerateReport+0xdd6>
    81de:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    81e0:	20 e2       	ldi	r18, 0x20	; 32
    81e2:	02 c0       	rjmp	.+4      	; 0x81e8 <systemGenerateReport+0xdc4>
    81e4:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    81e6:	8f 5f       	subi	r24, 0xFF	; 255
    81e8:	89 17       	cp	r24, r25
    81ea:	e0 f3       	brcs	.-8      	; 0x81e4 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    81ec:	fe 01       	movw	r30, r28
    81ee:	e3 58       	subi	r30, 0x83	; 131
    81f0:	ff 4f       	sbci	r31, 0xFF	; 255
    81f2:	e9 0f       	add	r30, r25
    81f4:	f1 1d       	adc	r31, r1
    81f6:	10 82       	st	Z, r1
    81f8:	03 c0       	rjmp	.+6      	; 0x8200 <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    81fa:	80 e2       	ldi	r24, 0x20	; 32
    81fc:	80 83       	st	Z, r24
	 strTab[1]=0;
    81fe:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8200:	e1 99       	sbic	0x1c, 1	; 28
    8202:	fe cf       	rjmp	.-4      	; 0x8200 <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8204:	ff ba       	out	0x1f, r15	; 31
    8206:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8208:	e0 9a       	sbi	0x1c, 0	; 28
    820a:	8d b3       	in	r24, 0x1d	; 29
    820c:	9e 01       	movw	r18, r28
    820e:	2b 55       	subi	r18, 0x5B	; 91
    8210:	3f 4f       	sbci	r19, 0xFF	; 255
    8212:	4e e0       	ldi	r20, 0x0E	; 14
    8214:	59 e0       	ldi	r21, 0x09	; 9
    8216:	de 01       	movw	r26, r28
    8218:	a7 59       	subi	r26, 0x97	; 151
    821a:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    821c:	81 30       	cpi	r24, 0x01	; 1
    821e:	31 f5       	brne	.+76     	; 0x826c <systemGenerateReport+0xe48>
    8220:	ed b7       	in	r30, 0x3d	; 61
    8222:	fe b7       	in	r31, 0x3e	; 62
    8224:	3c 97       	sbiw	r30, 0x0c	; 12
    8226:	0f b6       	in	r0, 0x3f	; 63
    8228:	f8 94       	cli
    822a:	fe bf       	out	0x3e, r31	; 62
    822c:	0f be       	out	0x3f, r0	; 63
    822e:	ed bf       	out	0x3d, r30	; 61
    8230:	6d b7       	in	r22, 0x3d	; 61
    8232:	7e b7       	in	r23, 0x3e	; 62
    8234:	6f 5f       	subi	r22, 0xFF	; 255
    8236:	7f 4f       	sbci	r23, 0xFF	; 255
    8238:	32 83       	std	Z+2, r19	; 0x02
    823a:	21 83       	std	Z+1, r18	; 0x01
    823c:	84 e0       	ldi	r24, 0x04	; 4
    823e:	95 e0       	ldi	r25, 0x05	; 5
    8240:	fb 01       	movw	r30, r22
    8242:	93 83       	std	Z+3, r25	; 0x03
    8244:	82 83       	std	Z+2, r24	; 0x02
    8246:	b5 83       	std	Z+5, r27	; 0x05
    8248:	a4 83       	std	Z+4, r26	; 0x04
    824a:	57 83       	std	Z+7, r21	; 0x07
    824c:	46 83       	std	Z+6, r20	; 0x06
    824e:	ce 01       	movw	r24, r28
    8250:	83 58       	subi	r24, 0x83	; 131
    8252:	9f 4f       	sbci	r25, 0xFF	; 255
    8254:	91 87       	std	Z+9, r25	; 0x09
    8256:	80 87       	std	Z+8, r24	; 0x08
    8258:	8e e3       	ldi	r24, 0x3E	; 62
    825a:	9e e0       	ldi	r25, 0x0E	; 14
    825c:	93 87       	std	Z+11, r25	; 0x0b
    825e:	82 87       	std	Z+10, r24	; 0x0a
    8260:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    8264:	8d b7       	in	r24, 0x3d	; 61
    8266:	9e b7       	in	r25, 0x3e	; 62
    8268:	0c 96       	adiw	r24, 0x0c	; 12
    826a:	1c c0       	rjmp	.+56     	; 0x82a4 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    826c:	ed b7       	in	r30, 0x3d	; 61
    826e:	fe b7       	in	r31, 0x3e	; 62
    8270:	38 97       	sbiw	r30, 0x08	; 8
    8272:	0f b6       	in	r0, 0x3f	; 63
    8274:	f8 94       	cli
    8276:	fe bf       	out	0x3e, r31	; 62
    8278:	0f be       	out	0x3f, r0	; 63
    827a:	ed bf       	out	0x3d, r30	; 61
    827c:	6d b7       	in	r22, 0x3d	; 61
    827e:	7e b7       	in	r23, 0x3e	; 62
    8280:	6f 5f       	subi	r22, 0xFF	; 255
    8282:	7f 4f       	sbci	r23, 0xFF	; 255
    8284:	32 83       	std	Z+2, r19	; 0x02
    8286:	21 83       	std	Z+1, r18	; 0x01
    8288:	8f ef       	ldi	r24, 0xFF	; 255
    828a:	94 e0       	ldi	r25, 0x04	; 4
    828c:	fb 01       	movw	r30, r22
    828e:	93 83       	std	Z+3, r25	; 0x03
    8290:	82 83       	std	Z+2, r24	; 0x02
    8292:	b5 83       	std	Z+5, r27	; 0x05
    8294:	a4 83       	std	Z+4, r26	; 0x04
    8296:	57 83       	std	Z+7, r21	; 0x07
    8298:	46 83       	std	Z+6, r20	; 0x06
    829a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    829e:	8d b7       	in	r24, 0x3d	; 61
    82a0:	9e b7       	in	r25, 0x3e	; 62
    82a2:	08 96       	adiw	r24, 0x08	; 8
    82a4:	0f b6       	in	r0, 0x3f	; 63
    82a6:	f8 94       	cli
    82a8:	9e bf       	out	0x3e, r25	; 62
    82aa:	0f be       	out	0x3f, r0	; 63
    82ac:	8d bf       	out	0x3d, r24	; 61
    82ae:	ce 01       	movw	r24, r28
    82b0:	8b 55       	subi	r24, 0x5B	; 91
    82b2:	9f 4f       	sbci	r25, 0xFF	; 255
    82b4:	65 ef       	ldi	r22, 0xF5	; 245
    82b6:	73 e0       	ldi	r23, 0x03	; 3
    82b8:	4f ed       	ldi	r20, 0xDF	; 223
    82ba:	51 e0       	ldi	r21, 0x01	; 1
    82bc:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    82c0:	87 e0       	ldi	r24, 0x07	; 7
    82c2:	65 ef       	ldi	r22, 0xF5	; 245
    82c4:	73 e0       	ldi	r23, 0x03	; 3
    82c6:	41 e0       	ldi	r20, 0x01	; 1
    82c8:	2f ed       	ldi	r18, 0xDF	; 223
    82ca:	31 e0       	ldi	r19, 0x01	; 1
    82cc:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    82d0:	8b e0       	ldi	r24, 0x0B	; 11
    82d2:	65 ef       	ldi	r22, 0xF5	; 245
    82d4:	73 e0       	ldi	r23, 0x03	; 3
    82d6:	4a e2       	ldi	r20, 0x2A	; 42
    82d8:	2f ed       	ldi	r18, 0xDF	; 223
    82da:	31 e0       	ldi	r19, 0x01	; 1
    82dc:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    82e0:	89 e0       	ldi	r24, 0x09	; 9
    82e2:	65 ef       	ldi	r22, 0xF5	; 245
    82e4:	73 e0       	ldi	r23, 0x03	; 3
    82e6:	41 e0       	ldi	r20, 0x01	; 1
    82e8:	2f ed       	ldi	r18, 0xDF	; 223
    82ea:	31 e0       	ldi	r19, 0x01	; 1
    82ec:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    82f0:	8c e0       	ldi	r24, 0x0C	; 12
    82f2:	65 ef       	ldi	r22, 0xF5	; 245
    82f4:	73 e0       	ldi	r23, 0x03	; 3
    82f6:	41 e0       	ldi	r20, 0x01	; 1
    82f8:	2f ed       	ldi	r18, 0xDF	; 223
    82fa:	31 e0       	ldi	r19, 0x01	; 1
    82fc:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>


          cmdPrint=0b00000000;
    8300:	10 92 b7 01 	sts	0x01B7, r1
		  LengthMessage81=RepPos+1;
    8304:	80 91 df 01 	lds	r24, 0x01DF
    8308:	90 91 e0 01 	lds	r25, 0x01E0
    830c:	01 96       	adiw	r24, 0x01	; 1
    830e:	90 93 90 01 	sts	0x0190, r25
    8312:	80 93 8f 01 	sts	0x018F, r24

		  IsFreePrinting=True;
    8316:	81 e0       	ldi	r24, 0x01	; 1
    8318:	80 93 aa 01 	sts	0x01AA, r24
	      IsBusyFreePrinting=True;
    831c:	80 93 b6 01 	sts	0x01B6, r24

	      stGenerateReport=grWaitPrinted2;
    8320:	89 e0       	ldi	r24, 0x09	; 9
    8322:	91 c3       	rjmp	.+1826   	; 0x8a46 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    8324:	80 91 b6 01 	lds	r24, 0x01B6
    8328:	88 23       	and	r24, r24
    832a:	09 f0       	breq	.+2      	; 0x832e <systemGenerateReport+0xf0a>
    832c:	94 c3       	rjmp	.+1832   	; 0x8a56 <systemGenerateReport+0x1632>
    832e:	86 e0       	ldi	r24, 0x06	; 6
    8330:	8a c3       	rjmp	.+1812   	; 0x8a46 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    8332:	10 92 e0 01 	sts	0x01E0, r1
    8336:	10 92 df 01 	sts	0x01DF, r1
    833a:	e5 ef       	ldi	r30, 0xF5	; 245
    833c:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    833e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8340:	95 e0       	ldi	r25, 0x05	; 5
    8342:	e6 38       	cpi	r30, 0x86	; 134
    8344:	f9 07       	cpc	r31, r25
    8346:	d9 f7       	brne	.-10     	; 0x833e <systemGenerateReport+0xf1a>
    8348:	fe 01       	movw	r30, r28
    834a:	eb 55       	subi	r30, 0x5B	; 91
    834c:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    834e:	ce 01       	movw	r24, r28
    8350:	8b 50       	subi	r24, 0x0B	; 11
    8352:	9f 4f       	sbci	r25, 0xFF	; 255
    8354:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8356:	e8 17       	cp	r30, r24
    8358:	f9 07       	cpc	r31, r25
    835a:	e1 f7       	brne	.-8      	; 0x8354 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    835c:	81 eb       	ldi	r24, 0xB1	; 177
    835e:	98 e0       	ldi	r25, 0x08	; 8
    8360:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    8364:	00 e0       	ldi	r16, 0x00	; 0
    8366:	18 e0       	ldi	r17, 0x08	; 8
    8368:	c8 01       	movw	r24, r16
    836a:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    836e:	81 eb       	ldi	r24, 0xB1	; 177
    8370:	98 e0       	ldi	r25, 0x08	; 8
    8372:	0e 94 de 39 	call	0x73bc	; 0x73bc <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    8376:	81 eb       	ldi	r24, 0xB1	; 177
    8378:	98 e0       	ldi	r25, 0x08	; 8
    837a:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    837e:	c8 01       	movw	r24, r16
    8380:	0e 94 d1 39 	call	0x73a2	; 0x73a2 <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    8384:	c8 01       	movw	r24, r16
    8386:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    838a:	81 e0       	ldi	r24, 0x01	; 1
    838c:	65 ef       	ldi	r22, 0xF5	; 245
    838e:	73 e0       	ldi	r23, 0x03	; 3
    8390:	41 e0       	ldi	r20, 0x01	; 1
    8392:	2f ed       	ldi	r18, 0xDF	; 223
    8394:	31 e0       	ldi	r19, 0x01	; 1
    8396:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    839a:	8b e0       	ldi	r24, 0x0B	; 11
    839c:	65 ef       	ldi	r22, 0xF5	; 245
    839e:	73 e0       	ldi	r23, 0x03	; 3
    83a0:	4a e2       	ldi	r20, 0x2A	; 42
    83a2:	2f ed       	ldi	r18, 0xDF	; 223
    83a4:	31 e0       	ldi	r19, 0x01	; 1
    83a6:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    83aa:	83 e0       	ldi	r24, 0x03	; 3
    83ac:	65 ef       	ldi	r22, 0xF5	; 245
    83ae:	73 e0       	ldi	r23, 0x03	; 3
    83b0:	41 e0       	ldi	r20, 0x01	; 1
    83b2:	2f ed       	ldi	r18, 0xDF	; 223
    83b4:	31 e0       	ldi	r19, 0x01	; 1
    83b6:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    83ba:	8c e0       	ldi	r24, 0x0C	; 12
    83bc:	65 ef       	ldi	r22, 0xF5	; 245
    83be:	73 e0       	ldi	r23, 0x03	; 3
    83c0:	41 e0       	ldi	r20, 0x01	; 1
    83c2:	2f ed       	ldi	r18, 0xDF	; 223
    83c4:	31 e0       	ldi	r19, 0x01	; 1
    83c6:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    83ca:	d8 01       	movw	r26, r16
    83cc:	0d 90       	ld	r0, X+
    83ce:	00 20       	and	r0, r0
    83d0:	e9 f7       	brne	.-6      	; 0x83cc <systemGenerateReport+0xfa8>
    83d2:	8d 01       	movw	r16, r26
    83d4:	01 50       	subi	r16, 0x01	; 1
    83d6:	10 40       	sbci	r17, 0x00	; 0
    83d8:	00 50       	subi	r16, 0x00	; 0
    83da:	18 40       	sbci	r17, 0x08	; 8
    83dc:	91 e1       	ldi	r25, 0x11	; 17
    83de:	90 1b       	sub	r25, r16
    83e0:	de 01       	movw	r26, r28
    83e2:	a7 59       	subi	r26, 0x97	; 151
    83e4:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    83e6:	19 16       	cp	r1, r25
    83e8:	7c f4       	brge	.+30     	; 0x8408 <systemGenerateReport+0xfe4>
    83ea:	fd 01       	movw	r30, r26
    83ec:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    83ee:	20 e2       	ldi	r18, 0x20	; 32
    83f0:	02 c0       	rjmp	.+4      	; 0x83f6 <systemGenerateReport+0xfd2>
    83f2:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    83f4:	8f 5f       	subi	r24, 0xFF	; 255
    83f6:	89 17       	cp	r24, r25
    83f8:	e0 f3       	brcs	.-8      	; 0x83f2 <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    83fa:	fe 01       	movw	r30, r28
    83fc:	e7 59       	subi	r30, 0x97	; 151
    83fe:	ff 4f       	sbci	r31, 0xFF	; 255
    8400:	e9 0f       	add	r30, r25
    8402:	f1 1d       	adc	r31, r1
    8404:	10 82       	st	Z, r1
    8406:	04 c0       	rjmp	.+8      	; 0x8410 <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    8408:	80 e2       	ldi	r24, 0x20	; 32
    840a:	8c 93       	st	X, r24
	 strTab[1]=0;
    840c:	11 96       	adiw	r26, 0x01	; 1
    840e:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    8410:	e1 eb       	ldi	r30, 0xB1	; 177
    8412:	f8 e0       	ldi	r31, 0x08	; 8
    8414:	01 90       	ld	r0, Z+
    8416:	00 20       	and	r0, r0
    8418:	e9 f7       	brne	.-6      	; 0x8414 <systemGenerateReport+0xff0>
    841a:	31 97       	sbiw	r30, 0x01	; 1
    841c:	e1 5b       	subi	r30, 0xB1	; 177
    841e:	f8 40       	sbci	r31, 0x08	; 8
    8420:	9f e0       	ldi	r25, 0x0F	; 15
    8422:	9e 1b       	sub	r25, r30
    8424:	fe 01       	movw	r30, r28
    8426:	e3 58       	subi	r30, 0x83	; 131
    8428:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    842a:	19 16       	cp	r1, r25
    842c:	74 f4       	brge	.+28     	; 0x844a <systemGenerateReport+0x1026>
    842e:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    8430:	20 e2       	ldi	r18, 0x20	; 32
    8432:	02 c0       	rjmp	.+4      	; 0x8438 <systemGenerateReport+0x1014>
    8434:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    8436:	8f 5f       	subi	r24, 0xFF	; 255
    8438:	89 17       	cp	r24, r25
    843a:	e0 f3       	brcs	.-8      	; 0x8434 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    843c:	fe 01       	movw	r30, r28
    843e:	e3 58       	subi	r30, 0x83	; 131
    8440:	ff 4f       	sbci	r31, 0xFF	; 255
    8442:	e9 0f       	add	r30, r25
    8444:	f1 1d       	adc	r31, r1
    8446:	10 82       	st	Z, r1
    8448:	03 c0       	rjmp	.+6      	; 0x8450 <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    844a:	80 e2       	ldi	r24, 0x20	; 32
    844c:	80 83       	st	Z, r24
	 strTab[1]=0;
    844e:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8450:	e1 99       	sbic	0x1c, 1	; 28
    8452:	fe cf       	rjmp	.-4      	; 0x8450 <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8454:	e1 ec       	ldi	r30, 0xC1	; 193
    8456:	f3 e0       	ldi	r31, 0x03	; 3
    8458:	ff bb       	out	0x1f, r31	; 31
    845a:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    845c:	e0 9a       	sbi	0x1c, 0	; 28
    845e:	8d b3       	in	r24, 0x1d	; 29
    8460:	9e 01       	movw	r18, r28
    8462:	2b 55       	subi	r18, 0x5B	; 91
    8464:	3f 4f       	sbci	r19, 0xFF	; 255
    8466:	40 e0       	ldi	r20, 0x00	; 0
    8468:	58 e0       	ldi	r21, 0x08	; 8
    846a:	de 01       	movw	r26, r28
    846c:	a7 59       	subi	r26, 0x97	; 151
    846e:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    8470:	81 30       	cpi	r24, 0x01	; 1
    8472:	41 f5       	brne	.+80     	; 0x84c4 <systemGenerateReport+0x10a0>
    8474:	8d b7       	in	r24, 0x3d	; 61
    8476:	9e b7       	in	r25, 0x3e	; 62
    8478:	0c 97       	sbiw	r24, 0x0c	; 12
    847a:	0f b6       	in	r0, 0x3f	; 63
    847c:	f8 94       	cli
    847e:	9e bf       	out	0x3e, r25	; 62
    8480:	0f be       	out	0x3f, r0	; 63
    8482:	8d bf       	out	0x3d, r24	; 61
    8484:	6d b7       	in	r22, 0x3d	; 61
    8486:	7e b7       	in	r23, 0x3e	; 62
    8488:	6f 5f       	subi	r22, 0xFF	; 255
    848a:	7f 4f       	sbci	r23, 0xFF	; 255
    848c:	ed b7       	in	r30, 0x3d	; 61
    848e:	fe b7       	in	r31, 0x3e	; 62
    8490:	32 83       	std	Z+2, r19	; 0x02
    8492:	21 83       	std	Z+1, r18	; 0x01
    8494:	80 ef       	ldi	r24, 0xF0	; 240
    8496:	94 e0       	ldi	r25, 0x04	; 4
    8498:	fb 01       	movw	r30, r22
    849a:	93 83       	std	Z+3, r25	; 0x03
    849c:	82 83       	std	Z+2, r24	; 0x02
    849e:	b5 83       	std	Z+5, r27	; 0x05
    84a0:	a4 83       	std	Z+4, r26	; 0x04
    84a2:	57 83       	std	Z+7, r21	; 0x07
    84a4:	46 83       	std	Z+6, r20	; 0x06
    84a6:	ce 01       	movw	r24, r28
    84a8:	83 58       	subi	r24, 0x83	; 131
    84aa:	9f 4f       	sbci	r25, 0xFF	; 255
    84ac:	91 87       	std	Z+9, r25	; 0x09
    84ae:	80 87       	std	Z+8, r24	; 0x08
    84b0:	81 eb       	ldi	r24, 0xB1	; 177
    84b2:	98 e0       	ldi	r25, 0x08	; 8
    84b4:	93 87       	std	Z+11, r25	; 0x0b
    84b6:	82 87       	std	Z+10, r24	; 0x0a
    84b8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    84bc:	8d b7       	in	r24, 0x3d	; 61
    84be:	9e b7       	in	r25, 0x3e	; 62
    84c0:	0c 96       	adiw	r24, 0x0c	; 12
    84c2:	1c c0       	rjmp	.+56     	; 0x84fc <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    84c4:	ed b7       	in	r30, 0x3d	; 61
    84c6:	fe b7       	in	r31, 0x3e	; 62
    84c8:	38 97       	sbiw	r30, 0x08	; 8
    84ca:	0f b6       	in	r0, 0x3f	; 63
    84cc:	f8 94       	cli
    84ce:	fe bf       	out	0x3e, r31	; 62
    84d0:	0f be       	out	0x3f, r0	; 63
    84d2:	ed bf       	out	0x3d, r30	; 61
    84d4:	6d b7       	in	r22, 0x3d	; 61
    84d6:	7e b7       	in	r23, 0x3e	; 62
    84d8:	6f 5f       	subi	r22, 0xFF	; 255
    84da:	7f 4f       	sbci	r23, 0xFF	; 255
    84dc:	32 83       	std	Z+2, r19	; 0x02
    84de:	21 83       	std	Z+1, r18	; 0x01
    84e0:	85 ee       	ldi	r24, 0xE5	; 229
    84e2:	94 e0       	ldi	r25, 0x04	; 4
    84e4:	fb 01       	movw	r30, r22
    84e6:	93 83       	std	Z+3, r25	; 0x03
    84e8:	82 83       	std	Z+2, r24	; 0x02
    84ea:	b5 83       	std	Z+5, r27	; 0x05
    84ec:	a4 83       	std	Z+4, r26	; 0x04
    84ee:	57 83       	std	Z+7, r21	; 0x07
    84f0:	46 83       	std	Z+6, r20	; 0x06
    84f2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    84f6:	8d b7       	in	r24, 0x3d	; 61
    84f8:	9e b7       	in	r25, 0x3e	; 62
    84fa:	08 96       	adiw	r24, 0x08	; 8
    84fc:	0f b6       	in	r0, 0x3f	; 63
    84fe:	f8 94       	cli
    8500:	9e bf       	out	0x3e, r25	; 62
    8502:	0f be       	out	0x3f, r0	; 63
    8504:	8d bf       	out	0x3d, r24	; 61
    8506:	ce 01       	movw	r24, r28
    8508:	8b 55       	subi	r24, 0x5B	; 91
    850a:	9f 4f       	sbci	r25, 0xFF	; 255
    850c:	65 ef       	ldi	r22, 0xF5	; 245
    850e:	73 e0       	ldi	r23, 0x03	; 3
    8510:	4f ed       	ldi	r20, 0xDF	; 223
    8512:	51 e0       	ldi	r21, 0x01	; 1
    8514:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    8518:	84 e0       	ldi	r24, 0x04	; 4
    851a:	65 ef       	ldi	r22, 0xF5	; 245
    851c:	73 e0       	ldi	r23, 0x03	; 3
    851e:	41 e0       	ldi	r20, 0x01	; 1
    8520:	2f ed       	ldi	r18, 0xDF	; 223
    8522:	31 e0       	ldi	r19, 0x01	; 1
    8524:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    8528:	8b e0       	ldi	r24, 0x0B	; 11
    852a:	65 ef       	ldi	r22, 0xF5	; 245
    852c:	73 e0       	ldi	r23, 0x03	; 3
    852e:	4a e2       	ldi	r20, 0x2A	; 42
    8530:	2f ed       	ldi	r18, 0xDF	; 223
    8532:	31 e0       	ldi	r19, 0x01	; 1
    8534:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    8538:	86 e0       	ldi	r24, 0x06	; 6
    853a:	65 ef       	ldi	r22, 0xF5	; 245
    853c:	73 e0       	ldi	r23, 0x03	; 3
    853e:	41 e0       	ldi	r20, 0x01	; 1
    8540:	2f ed       	ldi	r18, 0xDF	; 223
    8542:	31 e0       	ldi	r19, 0x01	; 1
    8544:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    8548:	8c e0       	ldi	r24, 0x0C	; 12
    854a:	65 ef       	ldi	r22, 0xF5	; 245
    854c:	73 e0       	ldi	r23, 0x03	; 3
    854e:	41 e0       	ldi	r20, 0x01	; 1
    8550:	2f ed       	ldi	r18, 0xDF	; 223
    8552:	31 e0       	ldi	r19, 0x01	; 1
    8554:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    8558:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    855a:	b8 e2       	ldi	r27, 0x28	; 40
    855c:	2b 2e       	mov	r2, r27
    855e:	31 2c       	mov	r3, r1
    8560:	2c 0e       	add	r2, r28
    8562:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    8564:	a7 e3       	ldi	r26, 0x37	; 55
    8566:	6a 2e       	mov	r6, r26
    8568:	71 2c       	mov	r7, r1
    856a:	6c 0e       	add	r6, r28
    856c:	7d 1e       	adc	r7, r29
    856e:	d3 01       	movw	r26, r6
    8570:	1f 96       	adiw	r26, 0x0f	; 15
    8572:	cb 50       	subi	r28, 0x0B	; 11
    8574:	df 4f       	sbci	r29, 0xFF	; 255
    8576:	b9 83       	std	Y+1, r27	; 0x01
    8578:	a8 83       	st	Y, r26
    857a:	c5 5f       	subi	r28, 0xF5	; 245
    857c:	d0 40       	sbci	r29, 0x00	; 0
    857e:	f6 e4       	ldi	r31, 0x46	; 70
    8580:	4f 2e       	mov	r4, r31
    8582:	51 2c       	mov	r5, r1
    8584:	4c 0e       	add	r4, r28
    8586:	5d 1e       	adc	r5, r29
    8588:	f2 01       	movw	r30, r4
    858a:	3f 96       	adiw	r30, 0x0f	; 15
    858c:	c9 50       	subi	r28, 0x09	; 9
    858e:	df 4f       	sbci	r29, 0xFF	; 255
    8590:	f9 83       	std	Y+1, r31	; 0x01
    8592:	e8 83       	st	Y, r30
    8594:	c7 5f       	subi	r28, 0xF7	; 247
    8596:	d0 40       	sbci	r29, 0x00	; 0
    8598:	ed e7       	ldi	r30, 0x7D	; 125
    859a:	8e 2e       	mov	r8, r30
    859c:	91 2c       	mov	r9, r1
    859e:	8c 0e       	add	r8, r28
    85a0:	9d 1e       	adc	r9, r29
    85a2:	e3 c1       	rjmp	.+966    	; 0x896a <systemGenerateReport+0x1546>
    85a4:	f5 01       	movw	r30, r10
    85a6:	ef 51       	subi	r30, 0x1F	; 31
    85a8:	fe 4f       	sbci	r31, 0xFE	; 254
    85aa:	80 81       	ld	r24, Z
    85ac:	80 53       	subi	r24, 0x30	; 48
    85ae:	8a 30       	cpi	r24, 0x0A	; 10
    85b0:	08 f0       	brcs	.+2      	; 0x85b4 <systemGenerateReport+0x1190>
    85b2:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    85b4:	80 93 ee 01 	sts	0x01EE, r24
			  if (xGrade>0){
    85b8:	88 23       	and	r24, r24
    85ba:	09 f4       	brne	.+2      	; 0x85be <systemGenerateReport+0x119a>
    85bc:	d5 c1       	rjmp	.+938    	; 0x8968 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    85be:	67 e6       	ldi	r22, 0x67	; 103
    85c0:	77 e0       	ldi	r23, 0x07	; 7
    85c2:	0e 94 53 33 	call	0x66a6	; 0x66a6 <GetProductName>
    85c6:	e0 e0       	ldi	r30, 0x00	; 0
    85c8:	f8 e0       	ldi	r31, 0x08	; 8
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    85ca:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    85cc:	88 e0       	ldi	r24, 0x08	; 8
    85ce:	e4 31       	cpi	r30, 0x14	; 20
    85d0:	f8 07       	cpc	r31, r24
    85d2:	d9 f7       	brne	.-10     	; 0x85ca <systemGenerateReport+0x11a6>
    85d4:	e1 eb       	ldi	r30, 0xB1	; 177
    85d6:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
    85d8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    85da:	98 e0       	ldi	r25, 0x08	; 8
    85dc:	e5 3c       	cpi	r30, 0xC5	; 197
    85de:	f9 07       	cpc	r31, r25
    85e0:	d9 f7       	brne	.-10     	; 0x85d8 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    85e2:	81 e0       	ldi	r24, 0x01	; 1
    85e4:	80 93 f0 01 	sts	0x01F0, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    85e8:	79 e1       	ldi	r23, 0x19	; 25
    85ea:	c7 2e       	mov	r12, r23
    85ec:	d1 2c       	mov	r13, r1
    85ee:	cc 0e       	add	r12, r28
    85f0:	dd 1e       	adc	r13, r29
    85f2:	e6 c0       	rjmp	.+460    	; 0x87c0 <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    85f4:	ce 01       	movw	r24, r28
    85f6:	07 96       	adiw	r24, 0x07	; 7
    85f8:	65 e4       	ldi	r22, 0x45	; 69
    85fa:	70 e0       	ldi	r23, 0x00	; 0
    85fc:	48 e0       	ldi	r20, 0x08	; 8
    85fe:	50 e0       	ldi	r21, 0x00	; 0
    8600:	22 e4       	ldi	r18, 0x42	; 66
    8602:	33 e1       	ldi	r19, 0x13	; 19
    8604:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    8608:	80 91 f0 01 	lds	r24, 0x01F0
    860c:	fe 01       	movw	r30, r28
    860e:	e8 0f       	add	r30, r24
    8610:	f1 1d       	adc	r31, r1
    8612:	86 81       	ldd	r24, Z+6	; 0x06
    8614:	80 93 ed 01 	sts	0x01ED, r24
					  if (PumpNum>0){
    8618:	88 23       	and	r24, r24
    861a:	09 f4       	brne	.+2      	; 0x861e <systemGenerateReport+0x11fa>
    861c:	cc c0       	rjmp	.+408    	; 0x87b6 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    861e:	81 e0       	ldi	r24, 0x01	; 1
    8620:	c3 c0       	rjmp	.+390    	; 0x87a8 <systemGenerateReport+0x1384>
    8622:	60 91 f0 01 	lds	r22, 0x01F0
    8626:	a6 e0       	ldi	r26, 0x06	; 6
    8628:	6a 9f       	mul	r22, r26
    862a:	b0 01       	movw	r22, r0
    862c:	11 24       	eor	r1, r1
    862e:	61 5b       	subi	r22, 0xB1	; 177
    8630:	7f 4f       	sbci	r23, 0xFF	; 255
    8632:	ce 01       	movw	r24, r28
    8634:	01 96       	adiw	r24, 0x01	; 1
    8636:	46 e0       	ldi	r20, 0x06	; 6
    8638:	50 e0       	ldi	r21, 0x00	; 0
    863a:	22 e4       	ldi	r18, 0x42	; 66
    863c:	33 e1       	ldi	r19, 0x13	; 19
    863e:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    8642:	80 91 ef 01 	lds	r24, 0x01EF
    8646:	fe 01       	movw	r30, r28
    8648:	e8 0f       	add	r30, r24
    864a:	f1 1d       	adc	r31, r1
    864c:	90 81       	ld	r25, Z
    864e:	80 91 ee 01 	lds	r24, 0x01EE
    8652:	98 17       	cp	r25, r24
    8654:	09 f0       	breq	.+2      	; 0x8658 <systemGenerateReport+0x1234>
    8656:	a5 c0       	rjmp	.+330    	; 0x87a2 <systemGenerateReport+0x137e>
    8658:	ee e3       	ldi	r30, 0x3E	; 62
    865a:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    865c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    865e:	be e0       	ldi	r27, 0x0E	; 14
    8660:	ed 34       	cpi	r30, 0x4D	; 77
    8662:	fb 07       	cpc	r31, r27
    8664:	d9 f7       	brne	.-10     	; 0x865c <systemGenerateReport+0x1238>
    8666:	ee e0       	ldi	r30, 0x0E	; 14
    8668:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    866a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    866c:	89 e0       	ldi	r24, 0x09	; 9
    866e:	ed 31       	cpi	r30, 0x1D	; 29
    8670:	f8 07       	cpc	r31, r24
    8672:	d9 f7       	brne	.-10     	; 0x866a <systemGenerateReport+0x1246>
    8674:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    8676:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8678:	e2 15       	cp	r30, r2
    867a:	f3 05       	cpc	r31, r3
    867c:	e1 f7       	brne	.-8      	; 0x8676 <systemGenerateReport+0x1252>
    867e:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    8680:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8682:	e6 15       	cp	r30, r6
    8684:	f7 05       	cpc	r31, r7
    8686:	e1 f7       	brne	.-8      	; 0x8680 <systemGenerateReport+0x125c>
    8688:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    868a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    868c:	cb 50       	subi	r28, 0x0B	; 11
    868e:	df 4f       	sbci	r29, 0xFF	; 255
    8690:	a8 81       	ld	r26, Y
    8692:	b9 81       	ldd	r27, Y+1	; 0x01
    8694:	c5 5f       	subi	r28, 0xF5	; 245
    8696:	d0 40       	sbci	r29, 0x00	; 0
    8698:	ea 17       	cp	r30, r26
    869a:	fb 07       	cpc	r31, r27
    869c:	b1 f7       	brne	.-20     	; 0x868a <systemGenerateReport+0x1266>
    869e:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    86a0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    86a2:	c9 50       	subi	r28, 0x09	; 9
    86a4:	df 4f       	sbci	r29, 0xFF	; 255
    86a6:	88 81       	ld	r24, Y
    86a8:	99 81       	ldd	r25, Y+1	; 0x01
    86aa:	c7 5f       	subi	r28, 0xF7	; 247
    86ac:	d0 40       	sbci	r29, 0x00	; 0
    86ae:	e8 17       	cp	r30, r24
    86b0:	f9 07       	cpc	r31, r25
    86b2:	b1 f7       	brne	.-20     	; 0x86a0 <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    86b4:	80 91 ef 01 	lds	r24, 0x01EF
    86b8:	80 93 ec 01 	sts	0x01EC, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    86bc:	80 91 ed 01 	lds	r24, 0x01ED
    86c0:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
								  if (FIPAddr>0){
    86c4:	88 23       	and	r24, r24
    86c6:	11 f1       	breq	.+68     	; 0x870c <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    86c8:	f8 2e       	mov	r15, r24
    86ca:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    86cc:	80 e0       	ldi	r24, 0x00	; 0
    86ce:	60 e0       	ldi	r22, 0x00	; 0
    86d0:	4f 2d       	mov	r20, r15
    86d2:	20 91 ec 01 	lds	r18, 0x01EC
    86d6:	86 01       	movw	r16, r12
    86d8:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    86dc:	81 e0       	ldi	r24, 0x01	; 1
    86de:	60 e0       	ldi	r22, 0x00	; 0
    86e0:	4f 2d       	mov	r20, r15
    86e2:	20 91 ec 01 	lds	r18, 0x01EC
    86e6:	81 01       	movw	r16, r2
    86e8:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    86ec:	80 e0       	ldi	r24, 0x00	; 0
    86ee:	61 e0       	ldi	r22, 0x01	; 1
    86f0:	4f 2d       	mov	r20, r15
    86f2:	20 91 ec 01 	lds	r18, 0x01EC
    86f6:	83 01       	movw	r16, r6
    86f8:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    86fc:	81 e0       	ldi	r24, 0x01	; 1
    86fe:	61 e0       	ldi	r22, 0x01	; 1
    8700:	4f 2d       	mov	r20, r15
    8702:	20 91 ec 01 	lds	r18, 0x01EC
    8706:	82 01       	movw	r16, r4
    8708:	0e 94 c4 21 	call	0x4388	; 0x4388 <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    870c:	80 e0       	ldi	r24, 0x00	; 0
    870e:	b3 01       	movw	r22, r6
    8710:	a6 01       	movw	r20, r12
    8712:	2e e0       	ldi	r18, 0x0E	; 14
    8714:	39 e0       	ldi	r19, 0x09	; 9
    8716:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    871a:	8e e0       	ldi	r24, 0x0E	; 14
    871c:	99 e0       	ldi	r25, 0x09	; 9
    871e:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <IsMinus>
    8722:	81 30       	cpi	r24, 0x01	; 1
    8724:	21 f4       	brne	.+8      	; 0x872e <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    8726:	8e e0       	ldi	r24, 0x0E	; 14
    8728:	99 e0       	ldi	r25, 0x09	; 9
    872a:	0e 94 68 30 	call	0x60d0	; 0x60d0 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    872e:	e1 99       	sbic	0x1c, 1	; 28
    8730:	fe cf       	rjmp	.-4      	; 0x872e <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8732:	a7 e3       	ldi	r26, 0x37	; 55
    8734:	b1 e0       	ldi	r27, 0x01	; 1
    8736:	bf bb       	out	0x1f, r27	; 31
    8738:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    873a:	e0 9a       	sbi	0x1c, 0	; 28
    873c:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    873e:	82 30       	cpi	r24, 0x02	; 2
    8740:	79 f4       	brne	.+30     	; 0x8760 <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    8742:	ce 01       	movw	r24, r28
    8744:	0f 96       	adiw	r24, 0x0f	; 15
    8746:	60 91 ed 01 	lds	r22, 0x01ED
    874a:	40 91 ec 01 	lds	r20, 0x01EC
    874e:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    8752:	82 e0       	ldi	r24, 0x02	; 2
    8754:	be 01       	movw	r22, r28
    8756:	61 5f       	subi	r22, 0xF1	; 241
    8758:	7f 4f       	sbci	r23, 0xFF	; 255
    875a:	4e e0       	ldi	r20, 0x0E	; 14
    875c:	59 e0       	ldi	r21, 0x09	; 9
    875e:	03 c0       	rjmp	.+6      	; 0x8766 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    8760:	80 e0       	ldi	r24, 0x00	; 0
    8762:	b2 01       	movw	r22, r4
    8764:	a1 01       	movw	r20, r2
    8766:	2e e3       	ldi	r18, 0x3E	; 62
    8768:	3e e0       	ldi	r19, 0x0E	; 14
    876a:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    876e:	8e e3       	ldi	r24, 0x3E	; 62
    8770:	9e e0       	ldi	r25, 0x0E	; 14
    8772:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <IsMinus>
    8776:	81 30       	cpi	r24, 0x01	; 1
    8778:	21 f4       	brne	.+8      	; 0x8782 <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    877a:	8e e3       	ldi	r24, 0x3E	; 62
    877c:	9e e0       	ldi	r25, 0x0E	; 14
    877e:	0e 94 68 30 	call	0x60d0	; 0x60d0 <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    8782:	81 e0       	ldi	r24, 0x01	; 1
    8784:	60 e0       	ldi	r22, 0x00	; 0
    8786:	78 e0       	ldi	r23, 0x08	; 8
    8788:	4e e0       	ldi	r20, 0x0E	; 14
    878a:	59 e0       	ldi	r21, 0x09	; 9
    878c:	9b 01       	movw	r18, r22
    878e:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    8792:	81 e0       	ldi	r24, 0x01	; 1
    8794:	61 eb       	ldi	r22, 0xB1	; 177
    8796:	78 e0       	ldi	r23, 0x08	; 8
    8798:	4e e3       	ldi	r20, 0x3E	; 62
    879a:	5e e0       	ldi	r21, 0x0E	; 14
    879c:	9b 01       	movw	r18, r22
    879e:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    87a2:	80 91 ef 01 	lds	r24, 0x01EF
    87a6:	8f 5f       	subi	r24, 0xFF	; 255
    87a8:	80 93 ef 01 	sts	0x01EF, r24
    87ac:	80 91 ef 01 	lds	r24, 0x01EF
    87b0:	87 30       	cpi	r24, 0x07	; 7
    87b2:	08 f4       	brcc	.+2      	; 0x87b6 <systemGenerateReport+0x1392>
    87b4:	36 cf       	rjmp	.-404    	; 0x8622 <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    87b6:	80 91 f0 01 	lds	r24, 0x01F0
    87ba:	8f 5f       	subi	r24, 0xFF	; 255
    87bc:	80 93 f0 01 	sts	0x01F0, r24
    87c0:	80 91 f0 01 	lds	r24, 0x01F0
    87c4:	89 30       	cpi	r24, 0x09	; 9
    87c6:	08 f4       	brcc	.+2      	; 0x87ca <systemGenerateReport+0x13a6>
    87c8:	15 cf       	rjmp	.-470    	; 0x85f4 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    87ca:	81 eb       	ldi	r24, 0xB1	; 177
    87cc:	98 e0       	ldi	r25, 0x08	; 8
    87ce:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    87d2:	00 e0       	ldi	r16, 0x00	; 0
    87d4:	18 e0       	ldi	r17, 0x08	; 8
    87d6:	c8 01       	movw	r24, r16
    87d8:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    87dc:	81 eb       	ldi	r24, 0xB1	; 177
    87de:	98 e0       	ldi	r25, 0x08	; 8
    87e0:	0e 94 de 39 	call	0x73bc	; 0x73bc <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    87e4:	81 eb       	ldi	r24, 0xB1	; 177
    87e6:	98 e0       	ldi	r25, 0x08	; 8
    87e8:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    87ec:	c8 01       	movw	r24, r16
    87ee:	0e 94 d1 39 	call	0x73a2	; 0x73a2 <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    87f2:	c8 01       	movw	r24, r16
    87f4:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    87f8:	e7 e6       	ldi	r30, 0x67	; 103
    87fa:	f7 e0       	ldi	r31, 0x07	; 7
    87fc:	01 90       	ld	r0, Z+
    87fe:	00 20       	and	r0, r0
    8800:	e9 f7       	brne	.-6      	; 0x87fc <systemGenerateReport+0x13d8>
    8802:	31 97       	sbiw	r30, 0x01	; 1
    8804:	e7 56       	subi	r30, 0x67	; 103
    8806:	f7 40       	sbci	r31, 0x07	; 7
    8808:	d8 01       	movw	r26, r16
    880a:	0d 90       	ld	r0, X+
    880c:	00 20       	and	r0, r0
    880e:	e9 f7       	brne	.-6      	; 0x880a <systemGenerateReport+0x13e6>
    8810:	8d 01       	movw	r16, r26
    8812:	01 50       	subi	r16, 0x01	; 1
    8814:	10 40       	sbci	r17, 0x00	; 0
    8816:	00 50       	subi	r16, 0x00	; 0
    8818:	18 40       	sbci	r17, 0x08	; 8
    881a:	8e 2f       	mov	r24, r30
    881c:	81 95       	neg	r24
    881e:	80 1b       	sub	r24, r16
    8820:	8b 5e       	subi	r24, 0xEB	; 235
    8822:	de 01       	movw	r26, r28
    8824:	a7 59       	subi	r26, 0x97	; 151
    8826:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    8828:	18 16       	cp	r1, r24
    882a:	7c f4       	brge	.+30     	; 0x884a <systemGenerateReport+0x1426>
    882c:	fd 01       	movw	r30, r26
    882e:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    8830:	20 e2       	ldi	r18, 0x20	; 32
    8832:	02 c0       	rjmp	.+4      	; 0x8838 <systemGenerateReport+0x1414>
    8834:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    8836:	9f 5f       	subi	r25, 0xFF	; 255
    8838:	98 17       	cp	r25, r24
    883a:	e0 f3       	brcs	.-8      	; 0x8834 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    883c:	fe 01       	movw	r30, r28
    883e:	e7 59       	subi	r30, 0x97	; 151
    8840:	ff 4f       	sbci	r31, 0xFF	; 255
    8842:	e8 0f       	add	r30, r24
    8844:	f1 1d       	adc	r31, r1
    8846:	10 82       	st	Z, r1
    8848:	04 c0       	rjmp	.+8      	; 0x8852 <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    884a:	80 e2       	ldi	r24, 0x20	; 32
    884c:	8c 93       	st	X, r24
	 strTab[1]=0;
    884e:	11 96       	adiw	r26, 0x01	; 1
    8850:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    8852:	e1 eb       	ldi	r30, 0xB1	; 177
    8854:	f8 e0       	ldi	r31, 0x08	; 8
    8856:	01 90       	ld	r0, Z+
    8858:	00 20       	and	r0, r0
    885a:	e9 f7       	brne	.-6      	; 0x8856 <systemGenerateReport+0x1432>
    885c:	31 97       	sbiw	r30, 0x01	; 1
    885e:	e1 5b       	subi	r30, 0xB1	; 177
    8860:	f8 40       	sbci	r31, 0x08	; 8
    8862:	9f e0       	ldi	r25, 0x0F	; 15
    8864:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    8866:	19 16       	cp	r1, r25
    8868:	6c f4       	brge	.+26     	; 0x8884 <systemGenerateReport+0x1460>
    886a:	f4 01       	movw	r30, r8
    886c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    886e:	20 e2       	ldi	r18, 0x20	; 32
    8870:	02 c0       	rjmp	.+4      	; 0x8876 <systemGenerateReport+0x1452>
    8872:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    8874:	8f 5f       	subi	r24, 0xFF	; 255
    8876:	89 17       	cp	r24, r25
    8878:	e0 f3       	brcs	.-8      	; 0x8872 <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    887a:	f4 01       	movw	r30, r8
    887c:	e9 0f       	add	r30, r25
    887e:	f1 1d       	adc	r31, r1
    8880:	10 82       	st	Z, r1
    8882:	04 c0       	rjmp	.+8      	; 0x888c <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    8884:	80 e2       	ldi	r24, 0x20	; 32
    8886:	f4 01       	movw	r30, r8
    8888:	80 83       	st	Z, r24
	 strTab[1]=0;
    888a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    888c:	e1 99       	sbic	0x1c, 1	; 28
    888e:	fe cf       	rjmp	.-4      	; 0x888c <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8890:	81 ec       	ldi	r24, 0xC1	; 193
    8892:	93 e0       	ldi	r25, 0x03	; 3
    8894:	9f bb       	out	0x1f, r25	; 31
    8896:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8898:	e0 9a       	sbi	0x1c, 0	; 28
    889a:	8d b3       	in	r24, 0x1d	; 29
    889c:	9e 01       	movw	r18, r28
    889e:	2b 55       	subi	r18, 0x5B	; 91
    88a0:	3f 4f       	sbci	r19, 0xFF	; 255
    88a2:	40 e0       	ldi	r20, 0x00	; 0
    88a4:	58 e0       	ldi	r21, 0x08	; 8
    88a6:	67 e6       	ldi	r22, 0x67	; 103
    88a8:	c6 2e       	mov	r12, r22
    88aa:	67 e0       	ldi	r22, 0x07	; 7
    88ac:	d6 2e       	mov	r13, r22
    88ae:	de 01       	movw	r26, r28
    88b0:	a7 59       	subi	r26, 0x97	; 151
    88b2:	bf 4f       	sbci	r27, 0xFF	; 255
    88b4:	b5 01       	movw	r22, r10
    88b6:	6f 5f       	subi	r22, 0xFF	; 255
    88b8:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    88ba:	81 30       	cpi	r24, 0x01	; 1
    88bc:	39 f5       	brne	.+78     	; 0x890c <systemGenerateReport+0x14e8>
    88be:	ed b7       	in	r30, 0x3d	; 61
    88c0:	fe b7       	in	r31, 0x3e	; 62
    88c2:	70 97       	sbiw	r30, 0x10	; 16
    88c4:	0f b6       	in	r0, 0x3f	; 63
    88c6:	f8 94       	cli
    88c8:	fe bf       	out	0x3e, r31	; 62
    88ca:	0f be       	out	0x3f, r0	; 63
    88cc:	ed bf       	out	0x3d, r30	; 61
    88ce:	0d b7       	in	r16, 0x3d	; 61
    88d0:	1e b7       	in	r17, 0x3e	; 62
    88d2:	0f 5f       	subi	r16, 0xFF	; 255
    88d4:	1f 4f       	sbci	r17, 0xFF	; 255
    88d6:	32 83       	std	Z+2, r19	; 0x02
    88d8:	21 83       	std	Z+1, r18	; 0x01
    88da:	87 ed       	ldi	r24, 0xD7	; 215
    88dc:	94 e0       	ldi	r25, 0x04	; 4
    88de:	f8 01       	movw	r30, r16
    88e0:	93 83       	std	Z+3, r25	; 0x03
    88e2:	82 83       	std	Z+2, r24	; 0x02
    88e4:	75 83       	std	Z+5, r23	; 0x05
    88e6:	64 83       	std	Z+4, r22	; 0x04
    88e8:	d7 82       	std	Z+7, r13	; 0x07
    88ea:	c6 82       	std	Z+6, r12	; 0x06
    88ec:	b1 87       	std	Z+9, r27	; 0x09
    88ee:	a0 87       	std	Z+8, r26	; 0x08
    88f0:	53 87       	std	Z+11, r21	; 0x0b
    88f2:	42 87       	std	Z+10, r20	; 0x0a
    88f4:	95 86       	std	Z+13, r9	; 0x0d
    88f6:	84 86       	std	Z+12, r8	; 0x0c
    88f8:	81 eb       	ldi	r24, 0xB1	; 177
    88fa:	98 e0       	ldi	r25, 0x08	; 8
    88fc:	97 87       	std	Z+15, r25	; 0x0f
    88fe:	86 87       	std	Z+14, r24	; 0x0e
    8900:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    8904:	8d b7       	in	r24, 0x3d	; 61
    8906:	9e b7       	in	r25, 0x3e	; 62
    8908:	40 96       	adiw	r24, 0x10	; 16
    890a:	20 c0       	rjmp	.+64     	; 0x894c <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    890c:	ed b7       	in	r30, 0x3d	; 61
    890e:	fe b7       	in	r31, 0x3e	; 62
    8910:	3c 97       	sbiw	r30, 0x0c	; 12
    8912:	0f b6       	in	r0, 0x3f	; 63
    8914:	f8 94       	cli
    8916:	fe bf       	out	0x3e, r31	; 62
    8918:	0f be       	out	0x3f, r0	; 63
    891a:	ed bf       	out	0x3d, r30	; 61
    891c:	0d b7       	in	r16, 0x3d	; 61
    891e:	1e b7       	in	r17, 0x3e	; 62
    8920:	0f 5f       	subi	r16, 0xFF	; 255
    8922:	1f 4f       	sbci	r17, 0xFF	; 255
    8924:	32 83       	std	Z+2, r19	; 0x02
    8926:	21 83       	std	Z+1, r18	; 0x01
    8928:	8d ec       	ldi	r24, 0xCD	; 205
    892a:	94 e0       	ldi	r25, 0x04	; 4
    892c:	f8 01       	movw	r30, r16
    892e:	93 83       	std	Z+3, r25	; 0x03
    8930:	82 83       	std	Z+2, r24	; 0x02
    8932:	75 83       	std	Z+5, r23	; 0x05
    8934:	64 83       	std	Z+4, r22	; 0x04
    8936:	d7 82       	std	Z+7, r13	; 0x07
    8938:	c6 82       	std	Z+6, r12	; 0x06
    893a:	b1 87       	std	Z+9, r27	; 0x09
    893c:	a0 87       	std	Z+8, r26	; 0x08
    893e:	53 87       	std	Z+11, r21	; 0x0b
    8940:	42 87       	std	Z+10, r20	; 0x0a
    8942:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    8946:	8d b7       	in	r24, 0x3d	; 61
    8948:	9e b7       	in	r25, 0x3e	; 62
    894a:	0c 96       	adiw	r24, 0x0c	; 12
    894c:	0f b6       	in	r0, 0x3f	; 63
    894e:	f8 94       	cli
    8950:	9e bf       	out	0x3e, r25	; 62
    8952:	0f be       	out	0x3f, r0	; 63
    8954:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    8956:	ce 01       	movw	r24, r28
    8958:	8b 55       	subi	r24, 0x5B	; 91
    895a:	9f 4f       	sbci	r25, 0xFF	; 255
    895c:	65 ef       	ldi	r22, 0xF5	; 245
    895e:	73 e0       	ldi	r23, 0x03	; 3
    8960:	4f ed       	ldi	r20, 0xDF	; 223
    8962:	51 e0       	ldi	r21, 0x01	; 1
    8964:	0e 94 67 25 	call	0x4ace	; 0x4ace <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    8968:	e3 94       	inc	r14
    896a:	e1 ee       	ldi	r30, 0xE1	; 225
    896c:	f1 e0       	ldi	r31, 0x01	; 1
    896e:	01 90       	ld	r0, Z+
    8970:	00 20       	and	r0, r0
    8972:	e9 f7       	brne	.-6      	; 0x896e <systemGenerateReport+0x154a>
    8974:	31 97       	sbiw	r30, 0x01	; 1
    8976:	e1 5e       	subi	r30, 0xE1	; 225
    8978:	f1 40       	sbci	r31, 0x01	; 1
    897a:	ae 2c       	mov	r10, r14
    897c:	bb 24       	eor	r11, r11
    897e:	ae 16       	cp	r10, r30
    8980:	bf 06       	cpc	r11, r31
    8982:	08 f4       	brcc	.+2      	; 0x8986 <systemGenerateReport+0x1562>
    8984:	0f ce       	rjmp	.-994    	; 0x85a4 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    8986:	87 e0       	ldi	r24, 0x07	; 7
    8988:	65 ef       	ldi	r22, 0xF5	; 245
    898a:	73 e0       	ldi	r23, 0x03	; 3
    898c:	41 e0       	ldi	r20, 0x01	; 1
    898e:	2f ed       	ldi	r18, 0xDF	; 223
    8990:	31 e0       	ldi	r19, 0x01	; 1
    8992:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    8996:	8b e0       	ldi	r24, 0x0B	; 11
    8998:	65 ef       	ldi	r22, 0xF5	; 245
    899a:	73 e0       	ldi	r23, 0x03	; 3
    899c:	4a e2       	ldi	r20, 0x2A	; 42
    899e:	2f ed       	ldi	r18, 0xDF	; 223
    89a0:	31 e0       	ldi	r19, 0x01	; 1
    89a2:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    89a6:	89 e0       	ldi	r24, 0x09	; 9
    89a8:	65 ef       	ldi	r22, 0xF5	; 245
    89aa:	73 e0       	ldi	r23, 0x03	; 3
    89ac:	41 e0       	ldi	r20, 0x01	; 1
    89ae:	2f ed       	ldi	r18, 0xDF	; 223
    89b0:	31 e0       	ldi	r19, 0x01	; 1
    89b2:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    89b6:	8c e0       	ldi	r24, 0x0C	; 12
    89b8:	65 ef       	ldi	r22, 0xF5	; 245
    89ba:	73 e0       	ldi	r23, 0x03	; 3
    89bc:	41 e0       	ldi	r20, 0x01	; 1
    89be:	2f ed       	ldi	r18, 0xDF	; 223
    89c0:	31 e0       	ldi	r19, 0x01	; 1
    89c2:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    89c6:	8c e0       	ldi	r24, 0x0C	; 12
    89c8:	65 ef       	ldi	r22, 0xF5	; 245
    89ca:	73 e0       	ldi	r23, 0x03	; 3
    89cc:	41 e0       	ldi	r20, 0x01	; 1
    89ce:	2f ed       	ldi	r18, 0xDF	; 223
    89d0:	31 e0       	ldi	r19, 0x01	; 1
    89d2:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    89d6:	8c e0       	ldi	r24, 0x0C	; 12
    89d8:	65 ef       	ldi	r22, 0xF5	; 245
    89da:	73 e0       	ldi	r23, 0x03	; 3
    89dc:	41 e0       	ldi	r20, 0x01	; 1
    89de:	2f ed       	ldi	r18, 0xDF	; 223
    89e0:	31 e0       	ldi	r19, 0x01	; 1
    89e2:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    89e6:	8c e0       	ldi	r24, 0x0C	; 12
    89e8:	65 ef       	ldi	r22, 0xF5	; 245
    89ea:	73 e0       	ldi	r23, 0x03	; 3
    89ec:	41 e0       	ldi	r20, 0x01	; 1
    89ee:	2f ed       	ldi	r18, 0xDF	; 223
    89f0:	31 e0       	ldi	r19, 0x01	; 1
    89f2:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    89f6:	8c e0       	ldi	r24, 0x0C	; 12
    89f8:	65 ef       	ldi	r22, 0xF5	; 245
    89fa:	73 e0       	ldi	r23, 0x03	; 3
    89fc:	41 e0       	ldi	r20, 0x01	; 1
    89fe:	2f ed       	ldi	r18, 0xDF	; 223
    8a00:	31 e0       	ldi	r19, 0x01	; 1
    8a02:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>
    8a06:	8c e0       	ldi	r24, 0x0C	; 12
    8a08:	65 ef       	ldi	r22, 0xF5	; 245
    8a0a:	73 e0       	ldi	r23, 0x03	; 3
    8a0c:	41 e0       	ldi	r20, 0x01	; 1
    8a0e:	2f ed       	ldi	r18, 0xDF	; 223
    8a10:	31 e0       	ldi	r19, 0x01	; 1
    8a12:	0e 94 24 1a 	call	0x3448	; 0x3448 <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    8a16:	80 e3       	ldi	r24, 0x30	; 48
    8a18:	80 93 b7 01 	sts	0x01B7, r24
		  LengthMessage81=RepPos+1;
    8a1c:	80 91 df 01 	lds	r24, 0x01DF
    8a20:	90 91 e0 01 	lds	r25, 0x01E0
    8a24:	01 96       	adiw	r24, 0x01	; 1
    8a26:	90 93 90 01 	sts	0x0190, r25
    8a2a:	80 93 8f 01 	sts	0x018F, r24
		  IsFreePrinting=True;
    8a2e:	81 e0       	ldi	r24, 0x01	; 1
    8a30:	80 93 aa 01 	sts	0x01AA, r24
	      IsBusyFreePrinting=True; 
    8a34:	80 93 b6 01 	sts	0x01B6, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    8a38:	8b e0       	ldi	r24, 0x0B	; 11
    8a3a:	05 c0       	rjmp	.+10     	; 0x8a46 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    8a3c:	80 91 b6 01 	lds	r24, 0x01B6
    8a40:	88 23       	and	r24, r24
    8a42:	49 f4       	brne	.+18     	; 0x8a56 <systemGenerateReport+0x1632>
    8a44:	8c e0       	ldi	r24, 0x0C	; 12
    8a46:	80 93 f1 01 	sts	0x01F1, r24
    8a4a:	05 c0       	rjmp	.+10     	; 0x8a56 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    8a4c:	81 e0       	ldi	r24, 0x01	; 1
    8a4e:	80 93 89 01 	sts	0x0189, r24
          stGenerateReport=grScanAction;
    8a52:	10 92 f1 01 	sts	0x01F1, r1
	      break;
	 }
}
    8a56:	c8 50       	subi	r28, 0x08	; 8
    8a58:	df 4f       	sbci	r29, 0xFF	; 255
    8a5a:	0f b6       	in	r0, 0x3f	; 63
    8a5c:	f8 94       	cli
    8a5e:	de bf       	out	0x3e, r29	; 62
    8a60:	0f be       	out	0x3f, r0	; 63
    8a62:	cd bf       	out	0x3d, r28	; 61
    8a64:	cf 91       	pop	r28
    8a66:	df 91       	pop	r29
    8a68:	1f 91       	pop	r17
    8a6a:	0f 91       	pop	r16
    8a6c:	ff 90       	pop	r15
    8a6e:	ef 90       	pop	r14
    8a70:	df 90       	pop	r13
    8a72:	cf 90       	pop	r12
    8a74:	bf 90       	pop	r11
    8a76:	af 90       	pop	r10
    8a78:	9f 90       	pop	r9
    8a7a:	8f 90       	pop	r8
    8a7c:	7f 90       	pop	r7
    8a7e:	6f 90       	pop	r6
    8a80:	5f 90       	pop	r5
    8a82:	4f 90       	pop	r4
    8a84:	3f 90       	pop	r3
    8a86:	2f 90       	pop	r2
    8a88:	08 95       	ret

00008a8a <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 

void UpdateCardID(){
    8a8a:	cf 93       	push	r28
    8a8c:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    8a8e:	e6 e6       	ldi	r30, 0x66	; 102
    8a90:	fe e0       	ldi	r31, 0x0E	; 14
    8a92:	01 90       	ld	r0, Z+
    8a94:	00 20       	and	r0, r0
    8a96:	e9 f7       	brne	.-6      	; 0x8a92 <UpdateCardID+0x8>
    8a98:	31 97       	sbiw	r30, 0x01	; 1
    8a9a:	e6 56       	subi	r30, 0x66	; 102
    8a9c:	fe 40       	sbci	r31, 0x0E	; 14
    8a9e:	a2 e9       	ldi	r26, 0x92	; 146
    8aa0:	bd e0       	ldi	r27, 0x0D	; 13
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 

void UpdateCardID(){
    8aa2:	f0 e0       	ldi	r31, 0x00	; 0
    8aa4:	ef 01       	movw	r28, r30
    8aa6:	ce 5a       	subi	r28, 0xAE	; 174
    8aa8:	d1 4f       	sbci	r29, 0xF1	; 241
    8aaa:	20 e0       	ldi	r18, 0x00	; 0
    8aac:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    8aae:	44 e1       	ldi	r20, 0x14	; 20
    8ab0:	50 e0       	ldi	r21, 0x00	; 0
    8ab2:	4e 1b       	sub	r20, r30
    8ab4:	5f 0b       	sbc	r21, r31
    8ab6:	90 e2       	ldi	r25, 0x20	; 32
    8ab8:	24 17       	cp	r18, r20
    8aba:	35 07       	cpc	r19, r21
    8abc:	14 f4       	brge	.+4      	; 0x8ac2 <UpdateCardID+0x38>
    8abe:	9c 93       	st	X, r25
    8ac0:	02 c0       	rjmp	.+4      	; 0x8ac6 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    8ac2:	88 81       	ld	r24, Y
    8ac4:	8c 93       	st	X, r24
    8ac6:	2f 5f       	subi	r18, 0xFF	; 255
    8ac8:	3f 4f       	sbci	r19, 0xFF	; 255
    8aca:	11 96       	adiw	r26, 0x01	; 1
    8acc:	21 96       	adiw	r28, 0x01	; 1
} 

void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    8ace:	24 31       	cpi	r18, 0x14	; 20
    8ad0:	31 05       	cpc	r19, r1
    8ad2:	91 f7       	brne	.-28     	; 0x8ab8 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    8ad4:	10 92 a6 0d 	sts	0x0DA6, r1

}
    8ad8:	df 91       	pop	r29
    8ada:	cf 91       	pop	r28
    8adc:	08 95       	ret

00008ade <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    8ade:	cf 92       	push	r12
    8ae0:	df 92       	push	r13
    8ae2:	ef 92       	push	r14
    8ae4:	ff 92       	push	r15
    8ae6:	0f 93       	push	r16
    8ae8:	1f 93       	push	r17
    8aea:	df 93       	push	r29
    8aec:	cf 93       	push	r28
    8aee:	cd b7       	in	r28, 0x3d	; 61
    8af0:	de b7       	in	r29, 0x3e	; 62
    8af2:	27 97       	sbiw	r28, 0x07	; 7
    8af4:	0f b6       	in	r0, 0x3f	; 63
    8af6:	f8 94       	cli
    8af8:	de bf       	out	0x3e, r29	; 62
    8afa:	0f be       	out	0x3f, r0	; 63
    8afc:	cd bf       	out	0x3d, r28	; 61
    8afe:	6c 01       	movw	r12, r24
    8b00:	fe 01       	movw	r30, r28
    8b02:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b04:	ce 01       	movw	r24, r28
    8b06:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    8b08:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b0a:	e8 17       	cp	r30, r24
    8b0c:	f9 07       	cpc	r31, r25
    8b0e:	e1 f7       	brne	.-8      	; 0x8b08 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8b10:	8e 01       	movw	r16, r28
    8b12:	0f 5f       	subi	r16, 0xFF	; 255
    8b14:	1f 4f       	sbci	r17, 0xFF	; 255
    8b16:	c8 01       	movw	r24, r16
    8b18:	68 e3       	ldi	r22, 0x38	; 56
    8b1a:	71 e0       	ldi	r23, 0x01	; 1
    8b1c:	47 e0       	ldi	r20, 0x07	; 7
    8b1e:	50 e0       	ldi	r21, 0x00	; 0
    8b20:	22 e4       	ldi	r18, 0x42	; 66
    8b22:	33 e1       	ldi	r19, 0x13	; 19
    8b24:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    8b28:	f8 01       	movw	r30, r16
    8b2a:	01 90       	ld	r0, Z+
    8b2c:	00 20       	and	r0, r0
    8b2e:	e9 f7       	brne	.-6      	; 0x8b2a <GenerateTransactionNum+0x4c>
    8b30:	31 97       	sbiw	r30, 0x01	; 1
    8b32:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    8b34:	f0 e0       	ldi	r31, 0x00	; 0
    8b36:	0e 0f       	add	r16, r30
    8b38:	1f 1f       	adc	r17, r31
    8b3a:	31 97       	sbiw	r30, 0x01	; 1
    8b3c:	76 01       	movw	r14, r12
    8b3e:	ee 0e       	add	r14, r30
    8b40:	ff 1e       	adc	r15, r31
    8b42:	31 96       	adiw	r30, 0x01	; 1
    8b44:	61 e0       	ldi	r22, 0x01	; 1
    8b46:	19 c0       	rjmp	.+50     	; 0x8b7a <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    8b48:	d8 01       	movw	r26, r16
    8b4a:	2c 91       	ld	r18, X
    8b4c:	20 53       	subi	r18, 0x30	; 48
    8b4e:	30 e0       	ldi	r19, 0x00	; 0
    8b50:	26 0f       	add	r18, r22
    8b52:	31 1d       	adc	r19, r1
    8b54:	c9 01       	movw	r24, r18
    8b56:	6a e0       	ldi	r22, 0x0A	; 10
    8b58:	70 e0       	ldi	r23, 0x00	; 0
    8b5a:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    8b5e:	48 2f       	mov	r20, r24
    8b60:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    8b62:	c9 01       	movw	r24, r18
    8b64:	6a e0       	ldi	r22, 0x0A	; 10
    8b66:	70 e0       	ldi	r23, 0x00	; 0
    8b68:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    8b6c:	d8 01       	movw	r26, r16
    8b6e:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    8b70:	d7 01       	movw	r26, r14
    8b72:	4c 93       	st	X, r20
    8b74:	08 94       	sec
    8b76:	e1 08       	sbc	r14, r1
    8b78:	f1 08       	sbc	r15, r1
    8b7a:	01 50       	subi	r16, 0x01	; 1
    8b7c:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    8b7e:	0c 17       	cp	r16, r28
    8b80:	1d 07       	cpc	r17, r29
    8b82:	11 f7       	brne	.-60     	; 0x8b48 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    8b84:	ce 0e       	add	r12, r30
    8b86:	df 1e       	adc	r13, r31
    8b88:	d6 01       	movw	r26, r12
    8b8a:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    8b8c:	be 01       	movw	r22, r28
    8b8e:	6f 5f       	subi	r22, 0xFF	; 255
    8b90:	7f 4f       	sbci	r23, 0xFF	; 255
    8b92:	e6 0f       	add	r30, r22
    8b94:	f7 1f       	adc	r31, r23
    8b96:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8b98:	88 e3       	ldi	r24, 0x38	; 56
    8b9a:	91 e0       	ldi	r25, 0x01	; 1
    8b9c:	47 e0       	ldi	r20, 0x07	; 7
    8b9e:	50 e0       	ldi	r21, 0x00	; 0
    8ba0:	2a e4       	ldi	r18, 0x4A	; 74
    8ba2:	33 e1       	ldi	r19, 0x13	; 19
    8ba4:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    8ba8:	27 96       	adiw	r28, 0x07	; 7
    8baa:	0f b6       	in	r0, 0x3f	; 63
    8bac:	f8 94       	cli
    8bae:	de bf       	out	0x3e, r29	; 62
    8bb0:	0f be       	out	0x3f, r0	; 63
    8bb2:	cd bf       	out	0x3d, r28	; 61
    8bb4:	cf 91       	pop	r28
    8bb6:	df 91       	pop	r29
    8bb8:	1f 91       	pop	r17
    8bba:	0f 91       	pop	r16
    8bbc:	ff 90       	pop	r15
    8bbe:	ef 90       	pop	r14
    8bc0:	df 90       	pop	r13
    8bc2:	cf 90       	pop	r12
    8bc4:	08 95       	ret

00008bc6 <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    8bc6:	8f 92       	push	r8
    8bc8:	9f 92       	push	r9
    8bca:	af 92       	push	r10
    8bcc:	bf 92       	push	r11
    8bce:	cf 92       	push	r12
    8bd0:	df 92       	push	r13
    8bd2:	ef 92       	push	r14
    8bd4:	ff 92       	push	r15
    8bd6:	0f 93       	push	r16
    8bd8:	1f 93       	push	r17
    8bda:	df 93       	push	r29
    8bdc:	cf 93       	push	r28
    8bde:	cd b7       	in	r28, 0x3d	; 61
    8be0:	de b7       	in	r29, 0x3e	; 62
    8be2:	a7 97       	sbiw	r28, 0x27	; 39
    8be4:	0f b6       	in	r0, 0x3f	; 63
    8be6:	f8 94       	cli
    8be8:	de bf       	out	0x3e, r29	; 62
    8bea:	0f be       	out	0x3f, r0	; 63
    8bec:	cd bf       	out	0x3d, r28	; 61
    8bee:	79 01       	movw	r14, r18
    8bf0:	48 01       	movw	r8, r16
    8bf2:	e6 2f       	mov	r30, r22
    8bf4:	f0 e0       	ldi	r31, 0x00	; 0
    8bf6:	31 97       	sbiw	r30, 0x01	; 1
    8bf8:	e8 0f       	add	r30, r24
    8bfa:	f9 1f       	adc	r31, r25
    8bfc:	9e 01       	movw	r18, r28
    8bfe:	26 5f       	subi	r18, 0xF6	; 246
    8c00:	3f 4f       	sbci	r19, 0xFF	; 255
    8c02:	d9 01       	movw	r26, r18
    8c04:	03 c0       	rjmp	.+6      	; 0x8c0c <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    8c06:	80 81       	ld	r24, Z
    8c08:	8d 93       	st	X+, r24
    8c0a:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    8c0c:	8a 2f       	mov	r24, r26
    8c0e:	82 1b       	sub	r24, r18
    8c10:	86 17       	cp	r24, r22
    8c12:	c8 f3       	brcs	.-14     	; 0x8c06 <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    8c14:	c6 2e       	mov	r12, r22
    8c16:	dd 24       	eor	r13, r13
    8c18:	ea e0       	ldi	r30, 0x0A	; 10
    8c1a:	ae 2e       	mov	r10, r30
    8c1c:	b1 2c       	mov	r11, r1
    8c1e:	ac 0e       	add	r10, r28
    8c20:	bd 1e       	adc	r11, r29
    8c22:	f5 01       	movw	r30, r10
    8c24:	ec 0d       	add	r30, r12
    8c26:	fd 1d       	adc	r31, r13
    8c28:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    8c2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    8c2c:	fa 01       	movw	r30, r20
    8c2e:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8c30:	8b 85       	ldd	r24, Y+11	; 0x0b
    8c32:	89 83       	std	Y+1, r24	; 0x01
    8c34:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c36:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    8c38:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    8c3a:	ce 01       	movw	r24, r28
    8c3c:	01 96       	adiw	r24, 0x01	; 1
    8c3e:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
	 *GPumpID=xPumpID;
    8c42:	f7 01       	movw	r30, r14
    8c44:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    8c46:	00 d0       	rcall	.+0      	; 0x8c48 <GetParameter+0x82>
    8c48:	00 d0       	rcall	.+0      	; 0x8c4a <GetParameter+0x84>
    8c4a:	77 e0       	ldi	r23, 0x07	; 7
    8c4c:	e7 2e       	mov	r14, r23
    8c4e:	f1 2c       	mov	r15, r1
    8c50:	ec 0e       	add	r14, r28
    8c52:	fd 1e       	adc	r15, r29
    8c54:	ed b7       	in	r30, 0x3d	; 61
    8c56:	fe b7       	in	r31, 0x3e	; 62
    8c58:	f2 82       	std	Z+2, r15	; 0x02
    8c5a:	e1 82       	std	Z+1, r14	; 0x01
    8c5c:	83 ec       	ldi	r24, 0xC3	; 195
    8c5e:	94 e0       	ldi	r25, 0x04	; 4
    8c60:	94 83       	std	Z+4, r25	; 0x04
    8c62:	83 83       	std	Z+3, r24	; 0x03
    8c64:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    8c68:	0f 90       	pop	r0
    8c6a:	0f 90       	pop	r0
    8c6c:	0f 90       	pop	r0
    8c6e:	0f 90       	pop	r0
    8c70:	c7 01       	movw	r24, r14
    8c72:	b5 01       	movw	r22, r10
    8c74:	0e 94 30 25 	call	0x4a60	; 0x4a60 <Pos>
    8c78:	8c 15       	cp	r24, r12
    8c7a:	9d 05       	cpc	r25, r13
    8c7c:	4c f5       	brge	.+82     	; 0x8cd0 <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    8c7e:	c7 01       	movw	r24, r14
    8c80:	b5 01       	movw	r22, r10
    8c82:	0e 94 30 25 	call	0x4a60	; 0x4a60 <Pos>
    8c86:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    8c88:	c7 01       	movw	r24, r14
    8c8a:	b5 01       	movw	r22, r10
    8c8c:	0e 94 30 25 	call	0x4a60	; 0x4a60 <Pos>
    8c90:	a6 01       	movw	r20, r12
    8c92:	40 1b       	sub	r20, r16
    8c94:	51 0b       	sbc	r21, r17
    8c96:	d5 01       	movw	r26, r10
    8c98:	a8 0f       	add	r26, r24
    8c9a:	b9 1f       	adc	r27, r25
    8c9c:	20 e0       	ldi	r18, 0x00	; 0
    8c9e:	30 e0       	ldi	r19, 0x00	; 0
    8ca0:	be 01       	movw	r22, r28
    8ca2:	6c 5f       	subi	r22, 0xFC	; 252
    8ca4:	7f 4f       	sbci	r23, 0xFF	; 255
    8ca6:	07 c0       	rjmp	.+14     	; 0x8cb6 <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ca8:	fb 01       	movw	r30, r22
    8caa:	e2 0f       	add	r30, r18
    8cac:	f3 1f       	adc	r31, r19
    8cae:	8c 91       	ld	r24, X
    8cb0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8cb2:	2f 5f       	subi	r18, 0xFF	; 255
    8cb4:	3f 4f       	sbci	r19, 0xFF	; 255
    8cb6:	11 96       	adiw	r26, 0x01	; 1
    8cb8:	24 17       	cp	r18, r20
    8cba:	35 07       	cpc	r19, r21
    8cbc:	a8 f3       	brcs	.-22     	; 0x8ca8 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8cbe:	46 0f       	add	r20, r22
    8cc0:	57 1f       	adc	r21, r23
    8cc2:	fa 01       	movw	r30, r20
    8cc4:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    8cc6:	cb 01       	movw	r24, r22
    8cc8:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
	     *GeniCSum=xCsum;
    8ccc:	f4 01       	movw	r30, r8
    8cce:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 uart_print(1,1,strSend);
*/
}
    8cd0:	a7 96       	adiw	r28, 0x27	; 39
    8cd2:	0f b6       	in	r0, 0x3f	; 63
    8cd4:	f8 94       	cli
    8cd6:	de bf       	out	0x3e, r29	; 62
    8cd8:	0f be       	out	0x3f, r0	; 63
    8cda:	cd bf       	out	0x3d, r28	; 61
    8cdc:	cf 91       	pop	r28
    8cde:	df 91       	pop	r29
    8ce0:	1f 91       	pop	r17
    8ce2:	0f 91       	pop	r16
    8ce4:	ff 90       	pop	r15
    8ce6:	ef 90       	pop	r14
    8ce8:	df 90       	pop	r13
    8cea:	cf 90       	pop	r12
    8cec:	bf 90       	pop	r11
    8cee:	af 90       	pop	r10
    8cf0:	9f 90       	pop	r9
    8cf2:	8f 90       	pop	r8
    8cf4:	08 95       	ret

00008cf6 <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    8cf6:	ff 92       	push	r15
    8cf8:	0f 93       	push	r16
    8cfa:	1f 93       	push	r17
    8cfc:	df 93       	push	r29
    8cfe:	cf 93       	push	r28
    8d00:	cd b7       	in	r28, 0x3d	; 61
    8d02:	de b7       	in	r29, 0x3e	; 62
    8d04:	67 97       	sbiw	r28, 0x17	; 23
    8d06:	0f b6       	in	r0, 0x3f	; 63
    8d08:	f8 94       	cli
    8d0a:	de bf       	out	0x3e, r29	; 62
    8d0c:	0f be       	out	0x3f, r0	; 63
    8d0e:	cd bf       	out	0x3d, r28	; 61
    8d10:	f8 2e       	mov	r15, r24
	 char i,GeniCmd,GeniPumpID,GeniCSum;//,sCmd[7];
	 char strSend[20];

    //uart(1,1,dataIn);

	if (dataIn==0x0D){	
    8d12:	8d e0       	ldi	r24, 0x0D	; 13
    8d14:	f8 16       	cp	r15, r24
    8d16:	09 f0       	breq	.+2      	; 0x8d1a <GeniusProtocol+0x24>
    8d18:	45 c0       	rjmp	.+138    	; 0x8da4 <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    8d1a:	8b ec       	ldi	r24, 0xCB	; 203
    8d1c:	91 e0       	ldi	r25, 0x01	; 1
    8d1e:	60 91 ca 01 	lds	r22, 0x01CA
    8d22:	ae 01       	movw	r20, r28
    8d24:	4f 5f       	subi	r20, 0xFF	; 255
    8d26:	5f 4f       	sbci	r21, 0xFF	; 255
    8d28:	9e 01       	movw	r18, r28
    8d2a:	2e 5f       	subi	r18, 0xFE	; 254
    8d2c:	3f 4f       	sbci	r19, 0xFF	; 255
    8d2e:	8e 01       	movw	r16, r28
    8d30:	0d 5f       	subi	r16, 0xFD	; 253
    8d32:	1f 4f       	sbci	r17, 0xFF	; 255
    8d34:	0e 94 e3 45 	call	0x8bc6	; 0x8bc6 <GetParameter>
		FlowLength=0;
    8d38:	10 92 ca 01 	sts	0x01CA, r1
		IsGeniusFlow=False;
    8d3c:	10 92 c9 01 	sts	0x01C9, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    8d40:	ad b7       	in	r26, 0x3d	; 61
    8d42:	be b7       	in	r27, 0x3e	; 62
    8d44:	18 97       	sbiw	r26, 0x08	; 8
    8d46:	0f b6       	in	r0, 0x3f	; 63
    8d48:	f8 94       	cli
    8d4a:	be bf       	out	0x3e, r27	; 62
    8d4c:	0f be       	out	0x3f, r0	; 63
    8d4e:	ad bf       	out	0x3d, r26	; 61
    8d50:	ed b7       	in	r30, 0x3d	; 61
    8d52:	fe b7       	in	r31, 0x3e	; 62
    8d54:	31 96       	adiw	r30, 0x01	; 1
    8d56:	8e 01       	movw	r16, r28
    8d58:	0c 5f       	subi	r16, 0xFC	; 252
    8d5a:	1f 4f       	sbci	r17, 0xFF	; 255
    8d5c:	12 96       	adiw	r26, 0x02	; 2
    8d5e:	1c 93       	st	X, r17
    8d60:	0e 93       	st	-X, r16
    8d62:	11 97       	sbiw	r26, 0x01	; 1
    8d64:	85 eb       	ldi	r24, 0xB5	; 181
    8d66:	94 e0       	ldi	r25, 0x04	; 4
    8d68:	93 83       	std	Z+3, r25	; 0x03
    8d6a:	82 83       	std	Z+2, r24	; 0x02
    8d6c:	89 81       	ldd	r24, Y+1	; 0x01
    8d6e:	84 83       	std	Z+4, r24	; 0x04
    8d70:	15 82       	std	Z+5, r1	; 0x05
    8d72:	8a 81       	ldd	r24, Y+2	; 0x02
    8d74:	86 83       	std	Z+6, r24	; 0x06
    8d76:	17 82       	std	Z+7, r1	; 0x07
    8d78:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		//uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    8d7c:	8d b7       	in	r24, 0x3d	; 61
    8d7e:	9e b7       	in	r25, 0x3e	; 62
    8d80:	08 96       	adiw	r24, 0x08	; 8
    8d82:	0f b6       	in	r0, 0x3f	; 63
    8d84:	f8 94       	cli
    8d86:	9e bf       	out	0x3e, r25	; 62
    8d88:	0f be       	out	0x3f, r0	; 63
    8d8a:	8d bf       	out	0x3d, r24	; 61
    8d8c:	c8 01       	movw	r24, r16
    8d8e:	0e 94 cb 24 	call	0x4996	; 0x4996 <SumChecksum>
    8d92:	9b 81       	ldd	r25, Y+3	; 0x03
    8d94:	89 17       	cp	r24, r25
    8d96:	31 f4       	brne	.+12     	; 0x8da4 <GeniusProtocol+0xae>
		     switch(GeniCmd){
    8d98:	89 81       	ldd	r24, Y+1	; 0x01
    8d9a:	84 35       	cpi	r24, 0x54	; 84
    8d9c:	19 f4       	brne	.+6      	; 0x8da4 <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    8d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    8da0:	0e 94 be 33 	call	0x677c	; 0x677c <GeniusSendLastTransaction>
    8da4:	ed ed       	ldi	r30, 0xDD	; 221
    8da6:	f1 e0       	ldi	r31, 0x01	; 1
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    8da8:	80 81       	ld	r24, Z
    8daa:	81 83       	std	Z+1, r24	; 0x01
    8dac:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    8dae:	91 e0       	ldi	r25, 0x01	; 1
    8db0:	ea 3c       	cpi	r30, 0xCA	; 202
    8db2:	f9 07       	cpc	r31, r25
    8db4:	c9 f7       	brne	.-14     	; 0x8da8 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    8db6:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    8db8:	8f 2d       	mov	r24, r15
    8dba:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <IsGeniusCommand>
    8dbe:	81 30       	cpi	r24, 0x01	; 1
    8dc0:	11 f4       	brne	.+4      	; 0x8dc6 <GeniusProtocol+0xd0>
    8dc2:	80 93 c9 01 	sts	0x01C9, r24
	if (IsGeniusFlow==True)FlowLength++;
    8dc6:	80 91 c9 01 	lds	r24, 0x01C9
    8dca:	81 30       	cpi	r24, 0x01	; 1
    8dcc:	29 f4       	brne	.+10     	; 0x8dd8 <GeniusProtocol+0xe2>
    8dce:	80 91 ca 01 	lds	r24, 0x01CA
    8dd2:	8f 5f       	subi	r24, 0xFF	; 255
    8dd4:	80 93 ca 01 	sts	0x01CA, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    8dd8:	67 96       	adiw	r28, 0x17	; 23
    8dda:	0f b6       	in	r0, 0x3f	; 63
    8ddc:	f8 94       	cli
    8dde:	de bf       	out	0x3e, r29	; 62
    8de0:	0f be       	out	0x3f, r0	; 63
    8de2:	cd bf       	out	0x3d, r28	; 61
    8de4:	cf 91       	pop	r28
    8de6:	df 91       	pop	r29
    8de8:	1f 91       	pop	r17
    8dea:	0f 91       	pop	r16
    8dec:	ff 90       	pop	r15
    8dee:	08 95       	ret

00008df0 <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    8df0:	1f 92       	push	r1
    8df2:	0f 92       	push	r0
    8df4:	0f b6       	in	r0, 0x3f	; 63
    8df6:	0f 92       	push	r0
    8df8:	0b b6       	in	r0, 0x3b	; 59
    8dfa:	0f 92       	push	r0
    8dfc:	11 24       	eor	r1, r1
    8dfe:	1f 93       	push	r17
    8e00:	2f 93       	push	r18
    8e02:	3f 93       	push	r19
    8e04:	4f 93       	push	r20
    8e06:	5f 93       	push	r21
    8e08:	6f 93       	push	r22
    8e0a:	7f 93       	push	r23
    8e0c:	8f 93       	push	r24
    8e0e:	9f 93       	push	r25
    8e10:	af 93       	push	r26
    8e12:	bf 93       	push	r27
    8e14:	ef 93       	push	r30
    8e16:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    8e18:	10 91 9c 00 	lds	r17, 0x009C
    //Not Successfull!
	//NewPacket
	if (IsNewPacket==True){
    8e1c:	80 91 8a 01 	lds	r24, 0x018A
    8e20:	81 30       	cpi	r24, 0x01	; 1
    8e22:	51 f4       	brne	.+20     	; 0x8e38 <__vector_30+0x48>
	    if (dataTX1==0x01){
    8e24:	11 30       	cpi	r17, 0x01	; 1
    8e26:	41 f4       	brne	.+16     	; 0x8e38 <__vector_30+0x48>
		    char_count=0;
    8e28:	10 92 8c 01 	sts	0x018C, r1
    8e2c:	10 92 8b 01 	sts	0x018B, r1
            IsNewPacket=False;
    8e30:	10 92 8a 01 	sts	0x018A, r1
			IsAdvanZProtocol=True;
    8e34:	10 93 a1 02 	sts	0x02A1, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    8e38:	80 91 a1 02 	lds	r24, 0x02A1
    8e3c:	81 30       	cpi	r24, 0x01	; 1
    8e3e:	69 f4       	brne	.+26     	; 0x8e5a <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
    8e40:	80 91 8b 01 	lds	r24, 0x018B
    8e44:	90 91 8c 01 	lds	r25, 0x018C
    8e48:	fc 01       	movw	r30, r24
    8e4a:	ea 5d       	subi	r30, 0xDA	; 218
    8e4c:	f4 4f       	sbci	r31, 0xF4	; 244
    8e4e:	10 83       	st	Z, r17
	    char_count++; 
    8e50:	01 96       	adiw	r24, 0x01	; 1
    8e52:	90 93 8c 01 	sts	0x018C, r25
    8e56:	80 93 8b 01 	sts	0x018B, r24
	}

	if (dataTX1==0x02){
    8e5a:	12 30       	cpi	r17, 0x02	; 2
    8e5c:	b1 f5       	brne	.+108    	; 0x8eca <__vector_30+0xda>
		transLength=char_count;
    8e5e:	60 91 8b 01 	lds	r22, 0x018B
    8e62:	70 91 8c 01 	lds	r23, 0x018C
    8e66:	70 93 8e 01 	sts	0x018E, r23
    8e6a:	60 93 8d 01 	sts	0x018D, r22
		char_count=0;
    8e6e:	10 92 8c 01 	sts	0x018C, r1
    8e72:	10 92 8b 01 	sts	0x018B, r1
		IsAdvanZProtocol=False;
    8e76:	10 92 a1 02 	sts	0x02A1, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    8e7a:	20 91 4a 0b 	lds	r18, 0x0B4A
    8e7e:	20 51       	subi	r18, 0x10	; 16
    8e80:	80 91 49 0b 	lds	r24, 0x0B49
    8e84:	3a e0       	ldi	r19, 0x0A	; 10
    8e86:	83 9f       	mul	r24, r19
    8e88:	c0 01       	movw	r24, r0
    8e8a:	11 24       	eor	r1, r1
    8e8c:	28 0f       	add	r18, r24
    8e8e:	20 93 14 01 	sts	0x0114, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    8e92:	80 91 26 0b 	lds	r24, 0x0B26
    8e96:	0e 94 04 19 	call	0x3208	; 0x3208 <IdentifyMessage>
		IsNewPacket=True;
    8e9a:	21 e0       	ldi	r18, 0x01	; 1
    8e9c:	20 93 8a 01 	sts	0x018A, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    8ea0:	80 91 49 0b 	lds	r24, 0x0B49
    8ea4:	88 33       	cpi	r24, 0x38	; 56
    8ea6:	89 f4       	brne	.+34     	; 0x8eca <__vector_30+0xda>
    8ea8:	80 91 4a 0b 	lds	r24, 0x0B4A
    8eac:	81 33       	cpi	r24, 0x31	; 49
    8eae:	69 f4       	brne	.+26     	; 0x8eca <__vector_30+0xda>
		   LengthMessage81=transLength-12-44;
    8eb0:	80 91 8d 01 	lds	r24, 0x018D
    8eb4:	90 91 8e 01 	lds	r25, 0x018E
    8eb8:	c8 97       	sbiw	r24, 0x38	; 56
    8eba:	90 93 90 01 	sts	0x0190, r25
    8ebe:	80 93 8f 01 	sts	0x018F, r24
		   IsMessage81=True;
    8ec2:	20 93 a8 01 	sts	0x01A8, r18
		   IsCompleteFilling=True;
    8ec6:	20 93 ab 01 	sts	0x01AB, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)
    8eca:	80 91 8a 01 	lds	r24, 0x018A
    8ece:	81 30       	cpi	r24, 0x01	; 1
    8ed0:	19 f0       	breq	.+6      	; 0x8ed8 <__vector_30+0xe8>
	    ConfigProtocol(dataTX1);
    8ed2:	81 2f       	mov	r24, r17
    8ed4:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))
    8ed8:	80 91 00 01 	lds	r24, 0x0100
    8edc:	82 30       	cpi	r24, 0x02	; 2
    8ede:	39 f4       	brne	.+14     	; 0x8eee <__vector_30+0xfe>
    8ee0:	80 91 8a 01 	lds	r24, 0x018A
    8ee4:	81 30       	cpi	r24, 0x01	; 1
    8ee6:	19 f0       	breq	.+6      	; 0x8eee <__vector_30+0xfe>
	     GeniusProtocol(dataTX1);		
    8ee8:	81 2f       	mov	r24, r17
    8eea:	0e 94 7b 46 	call	0x8cf6	; 0x8cf6 <GeniusProtocol>
    //uart(0,1,dataTX1);
	//uart(1,1,spi(dataTX1)); //Testing SPI
}
    8eee:	ff 91       	pop	r31
    8ef0:	ef 91       	pop	r30
    8ef2:	bf 91       	pop	r27
    8ef4:	af 91       	pop	r26
    8ef6:	9f 91       	pop	r25
    8ef8:	8f 91       	pop	r24
    8efa:	7f 91       	pop	r23
    8efc:	6f 91       	pop	r22
    8efe:	5f 91       	pop	r21
    8f00:	4f 91       	pop	r20
    8f02:	3f 91       	pop	r19
    8f04:	2f 91       	pop	r18
    8f06:	1f 91       	pop	r17
    8f08:	0f 90       	pop	r0
    8f0a:	0b be       	out	0x3b, r0	; 59
    8f0c:	0f 90       	pop	r0
    8f0e:	0f be       	out	0x3f, r0	; 63
    8f10:	0f 90       	pop	r0
    8f12:	1f 90       	pop	r1
    8f14:	18 95       	reti

00008f16 <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    8f16:	0f 93       	push	r16
    8f18:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    8f1a:	80 91 26 0b 	lds	r24, 0x0B26
    8f1e:	81 30       	cpi	r24, 0x01	; 1
    8f20:	09 f0       	breq	.+2      	; 0x8f24 <procMessage99+0xe>
    8f22:	2e c2       	rjmp	.+1116   	; 0x9380 <procMessage99+0x46a>
    8f24:	80 91 8d 01 	lds	r24, 0x018D
    8f28:	90 91 8e 01 	lds	r25, 0x018E
    8f2c:	8a 57       	subi	r24, 0x7A	; 122
    8f2e:	91 40       	sbci	r25, 0x01	; 1
    8f30:	08 f4       	brcc	.+2      	; 0x8f34 <procMessage99+0x1e>
    8f32:	26 c2       	rjmp	.+1100   	; 0x9380 <procMessage99+0x46a>
    8f34:	20 e0       	ldi	r18, 0x00	; 0
    8f36:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8f38:	f9 01       	movw	r30, r18
    8f3a:	e0 56       	subi	r30, 0x60	; 96
    8f3c:	f1 4f       	sbci	r31, 0xF1	; 241
    8f3e:	d9 01       	movw	r26, r18
    8f40:	aa 5d       	subi	r26, 0xDA	; 218
    8f42:	b4 4f       	sbci	r27, 0xF4	; 244
    8f44:	95 96       	adiw	r26, 0x25	; 37
    8f46:	8c 91       	ld	r24, X
    8f48:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8f4a:	2f 5f       	subi	r18, 0xFF	; 255
    8f4c:	3f 4f       	sbci	r19, 0xFF	; 255
    8f4e:	26 30       	cpi	r18, 0x06	; 6
    8f50:	31 05       	cpc	r19, r1
    8f52:	91 f7       	brne	.-28     	; 0x8f38 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8f54:	10 92 a6 0e 	sts	0x0EA6, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8f58:	80 91 51 0b 	lds	r24, 0x0B51
    8f5c:	80 93 81 0e 	sts	0x0E81, r24
	 }Dest[Length]=0;
    8f60:	10 92 82 0e 	sts	0x0E82, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    8f64:	80 53       	subi	r24, 0x30	; 48
    8f66:	80 93 bb 01 	sts	0x01BB, r24
    8f6a:	20 e0       	ldi	r18, 0x00	; 0
    8f6c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8f6e:	f9 01       	movw	r30, r18
    8f70:	e9 58       	subi	r30, 0x89	; 137
    8f72:	f8 4f       	sbci	r31, 0xF8	; 248
    8f74:	d9 01       	movw	r26, r18
    8f76:	aa 5d       	subi	r26, 0xDA	; 218
    8f78:	b4 4f       	sbci	r27, 0xF4	; 244
    8f7a:	9c 96       	adiw	r26, 0x2c	; 44
    8f7c:	8c 91       	ld	r24, X
    8f7e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8f80:	2f 5f       	subi	r18, 0xFF	; 255
    8f82:	3f 4f       	sbci	r19, 0xFF	; 255
    8f84:	2a 30       	cpi	r18, 0x0A	; 10
    8f86:	31 05       	cpc	r19, r1
    8f88:	91 f7       	brne	.-28     	; 0x8f6e <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8f8a:	10 92 81 07 	sts	0x0781, r1
    8f8e:	20 e0       	ldi	r18, 0x00	; 0
    8f90:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8f92:	f9 01       	movw	r30, r18
    8f94:	ea 5a       	subi	r30, 0xAA	; 170
    8f96:	fc 4f       	sbci	r31, 0xFC	; 252
    8f98:	d9 01       	movw	r26, r18
    8f9a:	aa 5d       	subi	r26, 0xDA	; 218
    8f9c:	b4 4f       	sbci	r27, 0xF4	; 244
    8f9e:	d6 96       	adiw	r26, 0x36	; 54
    8fa0:	8c 91       	ld	r24, X
    8fa2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8fa4:	2f 5f       	subi	r18, 0xFF	; 255
    8fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    8fa8:	28 30       	cpi	r18, 0x08	; 8
    8faa:	31 05       	cpc	r19, r1
    8fac:	91 f7       	brne	.-28     	; 0x8f92 <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8fae:	10 92 5e 03 	sts	0x035E, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8fb2:	80 91 64 0b 	lds	r24, 0x0B64
    8fb6:	80 93 00 09 	sts	0x0900, r24
    8fba:	80 91 65 0b 	lds	r24, 0x0B65
    8fbe:	80 93 01 09 	sts	0x0901, r24
	 }Dest[Length]=0;
    8fc2:	10 92 02 09 	sts	0x0902, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8fc6:	80 91 66 0b 	lds	r24, 0x0B66
    8fca:	80 93 c2 07 	sts	0x07C2, r24
    8fce:	80 91 67 0b 	lds	r24, 0x0B67
    8fd2:	80 93 c3 07 	sts	0x07C3, r24
	 }Dest[Length]=0;
    8fd6:	10 92 c4 07 	sts	0x07C4, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8fda:	80 91 68 0b 	lds	r24, 0x0B68
    8fde:	80 93 7a 08 	sts	0x087A, r24
    8fe2:	80 91 69 0b 	lds	r24, 0x0B69
    8fe6:	80 93 7b 08 	sts	0x087B, r24
	 }Dest[Length]=0;
    8fea:	10 92 7c 08 	sts	0x087C, r1
    8fee:	20 e0       	ldi	r18, 0x00	; 0
    8ff0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ff2:	f9 01       	movw	r30, r18
    8ff4:	eb 5e       	subi	r30, 0xEB	; 235
    8ff6:	f7 4f       	sbci	r31, 0xF7	; 247
    8ff8:	d9 01       	movw	r26, r18
    8ffa:	a6 59       	subi	r26, 0x96	; 150
    8ffc:	b4 4f       	sbci	r27, 0xF4	; 244
    8ffe:	8c 91       	ld	r24, X
    9000:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9002:	2f 5f       	subi	r18, 0xFF	; 255
    9004:	3f 4f       	sbci	r19, 0xFF	; 255
    9006:	2f 30       	cpi	r18, 0x0F	; 15
    9008:	31 05       	cpc	r19, r1
    900a:	99 f7       	brne	.-26     	; 0x8ff2 <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    900c:	10 92 24 08 	sts	0x0824, r1
    9010:	20 e0       	ldi	r18, 0x00	; 0
    9012:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9014:	f9 01       	movw	r30, r18
    9016:	e9 55       	subi	r30, 0x59	; 89
    9018:	fa 4f       	sbci	r31, 0xFA	; 250
    901a:	d9 01       	movw	r26, r18
    901c:	a7 58       	subi	r26, 0x87	; 135
    901e:	b4 4f       	sbci	r27, 0xF4	; 244
    9020:	8c 91       	ld	r24, X
    9022:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9024:	2f 5f       	subi	r18, 0xFF	; 255
    9026:	3f 4f       	sbci	r19, 0xFF	; 255
    9028:	28 30       	cpi	r18, 0x08	; 8
    902a:	31 05       	cpc	r19, r1
    902c:	99 f7       	brne	.-26     	; 0x9014 <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    902e:	10 92 af 05 	sts	0x05AF, r1
    9032:	20 e0       	ldi	r18, 0x00	; 0
    9034:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9036:	f9 01       	movw	r30, r18
    9038:	e2 58       	subi	r30, 0x82	; 130
    903a:	fc 4f       	sbci	r31, 0xFC	; 252
    903c:	d9 01       	movw	r26, r18
    903e:	af 57       	subi	r26, 0x7F	; 127
    9040:	b4 4f       	sbci	r27, 0xF4	; 244
    9042:	8c 91       	ld	r24, X
    9044:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9046:	2f 5f       	subi	r18, 0xFF	; 255
    9048:	3f 4f       	sbci	r19, 0xFF	; 255
    904a:	28 30       	cpi	r18, 0x08	; 8
    904c:	31 05       	cpc	r19, r1
    904e:	99 f7       	brne	.-26     	; 0x9036 <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9050:	10 92 86 03 	sts	0x0386, r1
    9054:	20 e0       	ldi	r18, 0x00	; 0
    9056:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9058:	f9 01       	movw	r30, r18
    905a:	e4 54       	subi	r30, 0x44	; 68
    905c:	f2 4f       	sbci	r31, 0xF2	; 242
    905e:	d9 01       	movw	r26, r18
    9060:	a7 57       	subi	r26, 0x77	; 119
    9062:	b4 4f       	sbci	r27, 0xF4	; 244
    9064:	8c 91       	ld	r24, X
    9066:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9068:	2f 5f       	subi	r18, 0xFF	; 255
    906a:	3f 4f       	sbci	r19, 0xFF	; 255
    906c:	2a 30       	cpi	r18, 0x0A	; 10
    906e:	31 05       	cpc	r19, r1
    9070:	99 f7       	brne	.-26     	; 0x9058 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9072:	10 92 c6 0d 	sts	0x0DC6, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    9076:	80 91 93 0b 	lds	r24, 0x0B93
    907a:	80 53       	subi	r24, 0x30	; 48
    907c:	80 93 ba 01 	sts	0x01BA, r24
    9080:	20 e0       	ldi	r18, 0x00	; 0
    9082:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9084:	f9 01       	movw	r30, r18
    9086:	ea 57       	subi	r30, 0x7A	; 122
    9088:	fa 4f       	sbci	r31, 0xFA	; 250
    908a:	d9 01       	movw	r26, r18
    908c:	ac 56       	subi	r26, 0x6C	; 108
    908e:	b4 4f       	sbci	r27, 0xF4	; 244
    9090:	8c 91       	ld	r24, X
    9092:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9094:	2f 5f       	subi	r18, 0xFF	; 255
    9096:	3f 4f       	sbci	r19, 0xFF	; 255
    9098:	24 31       	cpi	r18, 0x14	; 20
    909a:	31 05       	cpc	r19, r1
    909c:	99 f7       	brne	.-26     	; 0x9084 <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    909e:	10 92 9a 05 	sts	0x059A, r1
    90a2:	20 e0       	ldi	r18, 0x00	; 0
    90a4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    90a6:	f9 01       	movw	r30, r18
    90a8:	ee 56       	subi	r30, 0x6E	; 110
    90aa:	f2 4f       	sbci	r31, 0xF2	; 242
    90ac:	d9 01       	movw	r26, r18
    90ae:	a8 55       	subi	r26, 0x58	; 88
    90b0:	b4 4f       	sbci	r27, 0xF4	; 244
    90b2:	8c 91       	ld	r24, X
    90b4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    90b6:	2f 5f       	subi	r18, 0xFF	; 255
    90b8:	3f 4f       	sbci	r19, 0xFF	; 255
    90ba:	24 31       	cpi	r18, 0x14	; 20
    90bc:	31 05       	cpc	r19, r1
    90be:	99 f7       	brne	.-26     	; 0x90a6 <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    90c0:	10 92 a6 0d 	sts	0x0DA6, r1
    90c4:	20 e0       	ldi	r18, 0x00	; 0
    90c6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    90c8:	f9 01       	movw	r30, r18
    90ca:	e3 5d       	subi	r30, 0xD3	; 211
    90cc:	fc 4f       	sbci	r31, 0xFC	; 252
    90ce:	d9 01       	movw	r26, r18
    90d0:	a4 54       	subi	r26, 0x44	; 68
    90d2:	b4 4f       	sbci	r27, 0xF4	; 244
    90d4:	8c 91       	ld	r24, X
    90d6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    90d8:	2f 5f       	subi	r18, 0xFF	; 255
    90da:	3f 4f       	sbci	r19, 0xFF	; 255
    90dc:	28 32       	cpi	r18, 0x28	; 40
    90de:	31 05       	cpc	r19, r1
    90e0:	99 f7       	brne	.-26     	; 0x90c8 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    90e2:	10 92 55 03 	sts	0x0355, r1
    90e6:	20 e0       	ldi	r18, 0x00	; 0
    90e8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    90ea:	f9 01       	movw	r30, r18
    90ec:	ec 59       	subi	r30, 0x9C	; 156
    90ee:	fc 4f       	sbci	r31, 0xFC	; 252
    90f0:	d9 01       	movw	r26, r18
    90f2:	ac 51       	subi	r26, 0x1C	; 28
    90f4:	b4 4f       	sbci	r27, 0xF4	; 244
    90f6:	8c 91       	ld	r24, X
    90f8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    90fa:	2f 5f       	subi	r18, 0xFF	; 255
    90fc:	3f 4f       	sbci	r19, 0xFF	; 255
    90fe:	29 31       	cpi	r18, 0x19	; 25
    9100:	31 05       	cpc	r19, r1
    9102:	99 f7       	brne	.-26     	; 0x90ea <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9104:	10 92 7d 03 	sts	0x037D, r1
    9108:	20 e0       	ldi	r18, 0x00	; 0
    910a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    910c:	f9 01       	movw	r30, r18
    910e:	eb 5f       	subi	r30, 0xFB	; 251
    9110:	f1 4f       	sbci	r31, 0xF1	; 241
    9112:	d9 01       	movw	r26, r18
    9114:	a3 50       	subi	r26, 0x03	; 3
    9116:	b4 4f       	sbci	r27, 0xF4	; 244
    9118:	8c 91       	ld	r24, X
    911a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    911c:	2f 5f       	subi	r18, 0xFF	; 255
    911e:	3f 4f       	sbci	r19, 0xFF	; 255
    9120:	2d 30       	cpi	r18, 0x0D	; 13
    9122:	31 05       	cpc	r19, r1
    9124:	99 f7       	brne	.-26     	; 0x910c <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9126:	10 92 12 0e 	sts	0x0E12, r1
    912a:	20 e0       	ldi	r18, 0x00	; 0
    912c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    912e:	f9 01       	movw	r30, r18
    9130:	eb 56       	subi	r30, 0x6B	; 107
    9132:	fc 4f       	sbci	r31, 0xFC	; 252
    9134:	d9 01       	movw	r26, r18
    9136:	a6 5f       	subi	r26, 0xF6	; 246
    9138:	b3 4f       	sbci	r27, 0xF3	; 243
    913a:	8c 91       	ld	r24, X
    913c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    913e:	2f 5f       	subi	r18, 0xFF	; 255
    9140:	3f 4f       	sbci	r19, 0xFF	; 255
    9142:	2d 30       	cpi	r18, 0x0D	; 13
    9144:	31 05       	cpc	r19, r1
    9146:	99 f7       	brne	.-26     	; 0x912e <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9148:	10 92 a2 03 	sts	0x03A2, r1
    914c:	20 e0       	ldi	r18, 0x00	; 0
    914e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9150:	f9 01       	movw	r30, r18
    9152:	ee 50       	subi	r30, 0x0E	; 14
    9154:	f7 4f       	sbci	r31, 0xF7	; 247
    9156:	d9 01       	movw	r26, r18
    9158:	a9 5e       	subi	r26, 0xE9	; 233
    915a:	b3 4f       	sbci	r27, 0xF3	; 243
    915c:	8c 91       	ld	r24, X
    915e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9160:	2f 5f       	subi	r18, 0xFF	; 255
    9162:	3f 4f       	sbci	r19, 0xFF	; 255
    9164:	2d 30       	cpi	r18, 0x0D	; 13
    9166:	31 05       	cpc	r19, r1
    9168:	99 f7       	brne	.-26     	; 0x9150 <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    916a:	10 92 ff 08 	sts	0x08FF, r1
    916e:	20 e0       	ldi	r18, 0x00	; 0
    9170:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9172:	f9 01       	movw	r30, r18
    9174:	eb 53       	subi	r30, 0x3B	; 59
    9176:	f8 4f       	sbci	r31, 0xF8	; 248
    9178:	d9 01       	movw	r26, r18
    917a:	ac 5d       	subi	r26, 0xDC	; 220
    917c:	b3 4f       	sbci	r27, 0xF3	; 243
    917e:	8c 91       	ld	r24, X
    9180:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9182:	2f 5f       	subi	r18, 0xFF	; 255
    9184:	3f 4f       	sbci	r19, 0xFF	; 255
    9186:	23 31       	cpi	r18, 0x13	; 19
    9188:	31 05       	cpc	r19, r1
    918a:	99 f7       	brne	.-26     	; 0x9172 <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    918c:	10 92 d8 07 	sts	0x07D8, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9190:	80 91 37 0c 	lds	r24, 0x0C37
    9194:	80 93 9d 0e 	sts	0x0E9D, r24
    9198:	80 91 38 0c 	lds	r24, 0x0C38
    919c:	80 93 9e 0e 	sts	0x0E9E, r24
	 }Dest[Length]=0;
    91a0:	10 92 9f 0e 	sts	0x0E9F, r1
    91a4:	20 e0       	ldi	r18, 0x00	; 0
    91a6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    91a8:	f9 01       	movw	r30, r18
    91aa:	e3 5e       	subi	r30, 0xE3	; 227
    91ac:	f4 4f       	sbci	r31, 0xF4	; 244
    91ae:	d9 01       	movw	r26, r18
    91b0:	a7 5c       	subi	r26, 0xC7	; 199
    91b2:	b3 4f       	sbci	r27, 0xF3	; 243
    91b4:	8c 91       	ld	r24, X
    91b6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    91b8:	2f 5f       	subi	r18, 0xFF	; 255
    91ba:	3f 4f       	sbci	r19, 0xFF	; 255
    91bc:	28 30       	cpi	r18, 0x08	; 8
    91be:	31 05       	cpc	r19, r1
    91c0:	99 f7       	brne	.-26     	; 0x91a8 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    91c2:	10 92 25 0b 	sts	0x0B25, r1
    91c6:	20 e0       	ldi	r18, 0x00	; 0
    91c8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    91ca:	f9 01       	movw	r30, r18
    91cc:	ec 53       	subi	r30, 0x3C	; 60
    91ce:	fd 4f       	sbci	r31, 0xFD	; 253
    91d0:	d9 01       	movw	r26, r18
    91d2:	af 5b       	subi	r26, 0xBF	; 191
    91d4:	b3 4f       	sbci	r27, 0xF3	; 243
    91d6:	8c 91       	ld	r24, X
    91d8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    91da:	2f 5f       	subi	r18, 0xFF	; 255
    91dc:	3f 4f       	sbci	r19, 0xFF	; 255
    91de:	28 30       	cpi	r18, 0x08	; 8
    91e0:	31 05       	cpc	r19, r1
    91e2:	99 f7       	brne	.-26     	; 0x91ca <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    91e4:	10 92 cc 02 	sts	0x02CC, r1
    91e8:	20 e0       	ldi	r18, 0x00	; 0
    91ea:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    91ec:	f9 01       	movw	r30, r18
    91ee:	e0 51       	subi	r30, 0x10	; 16
    91f0:	fd 4f       	sbci	r31, 0xFD	; 253
    91f2:	d9 01       	movw	r26, r18
    91f4:	a7 5b       	subi	r26, 0xB7	; 183
    91f6:	b3 4f       	sbci	r27, 0xF3	; 243
    91f8:	8c 91       	ld	r24, X
    91fa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    91fc:	2f 5f       	subi	r18, 0xFF	; 255
    91fe:	3f 4f       	sbci	r19, 0xFF	; 255
    9200:	24 31       	cpi	r18, 0x14	; 20
    9202:	31 05       	cpc	r19, r1
    9204:	99 f7       	brne	.-26     	; 0x91ec <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9206:	10 92 04 03 	sts	0x0304, r1
    920a:	20 e0       	ldi	r18, 0x00	; 0
    920c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    920e:	f9 01       	movw	r30, r18
    9210:	e3 53       	subi	r30, 0x33	; 51
    9212:	fd 4f       	sbci	r31, 0xFD	; 253
    9214:	d9 01       	movw	r26, r18
    9216:	a3 5a       	subi	r26, 0xA3	; 163
    9218:	b3 4f       	sbci	r27, 0xF3	; 243
    921a:	8c 91       	ld	r24, X
    921c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    921e:	2f 5f       	subi	r18, 0xFF	; 255
    9220:	3f 4f       	sbci	r19, 0xFF	; 255
    9222:	2e 31       	cpi	r18, 0x1E	; 30
    9224:	31 05       	cpc	r19, r1
    9226:	99 f7       	brne	.-26     	; 0x920e <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9228:	10 92 eb 02 	sts	0x02EB, r1
    922c:	20 e0       	ldi	r18, 0x00	; 0
    922e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9230:	f9 01       	movw	r30, r18
    9232:	e2 5c       	subi	r30, 0xC2	; 194
    9234:	f7 4f       	sbci	r31, 0xF7	; 247
    9236:	d9 01       	movw	r26, r18
    9238:	a5 58       	subi	r26, 0x85	; 133
    923a:	b3 4f       	sbci	r27, 0xF3	; 243
    923c:	8c 91       	ld	r24, X
    923e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9240:	2f 5f       	subi	r18, 0xFF	; 255
    9242:	3f 4f       	sbci	r19, 0xFF	; 255
    9244:	28 30       	cpi	r18, 0x08	; 8
    9246:	31 05       	cpc	r19, r1
    9248:	99 f7       	brne	.-26     	; 0x9230 <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    924a:	10 92 46 08 	sts	0x0846, r1
    924e:	20 e0       	ldi	r18, 0x00	; 0
    9250:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9252:	f9 01       	movw	r30, r18
    9254:	e9 57       	subi	r30, 0x79	; 121
    9256:	fc 4f       	sbci	r31, 0xFC	; 252
    9258:	d9 01       	movw	r26, r18
    925a:	ad 57       	subi	r26, 0x7D	; 125
    925c:	b3 4f       	sbci	r27, 0xF3	; 243
    925e:	8c 91       	ld	r24, X
    9260:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9262:	2f 5f       	subi	r18, 0xFF	; 255
    9264:	3f 4f       	sbci	r19, 0xFF	; 255
    9266:	2a 30       	cpi	r18, 0x0A	; 10
    9268:	31 05       	cpc	r19, r1
    926a:	99 f7       	brne	.-26     	; 0x9252 <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    926c:	10 92 91 03 	sts	0x0391, r1
    9270:	20 e0       	ldi	r18, 0x00	; 0
    9272:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9274:	f9 01       	movw	r30, r18
    9276:	e6 50       	subi	r30, 0x06	; 6
    9278:	f2 4f       	sbci	r31, 0xF2	; 242
    927a:	d9 01       	movw	r26, r18
    927c:	a3 57       	subi	r26, 0x73	; 115
    927e:	b3 4f       	sbci	r27, 0xF3	; 243
    9280:	8c 91       	ld	r24, X
    9282:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9284:	2f 5f       	subi	r18, 0xFF	; 255
    9286:	3f 4f       	sbci	r19, 0xFF	; 255
    9288:	2a 30       	cpi	r18, 0x0A	; 10
    928a:	31 05       	cpc	r19, r1
    928c:	99 f7       	brne	.-26     	; 0x9274 <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    928e:	10 92 04 0e 	sts	0x0E04, r1
    9292:	20 e0       	ldi	r18, 0x00	; 0
    9294:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9296:	f9 01       	movw	r30, r18
    9298:	ec 51       	subi	r30, 0x1C	; 28
    929a:	f8 4f       	sbci	r31, 0xF8	; 248
    929c:	d9 01       	movw	r26, r18
    929e:	a9 56       	subi	r26, 0x69	; 105
    92a0:	b3 4f       	sbci	r27, 0xF3	; 243
    92a2:	8c 91       	ld	r24, X
    92a4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    92a6:	2f 5f       	subi	r18, 0xFF	; 255
    92a8:	3f 4f       	sbci	r19, 0xFF	; 255
    92aa:	24 31       	cpi	r18, 0x14	; 20
    92ac:	31 05       	cpc	r19, r1
    92ae:	99 f7       	brne	.-26     	; 0x9296 <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    92b0:	10 92 f8 07 	sts	0x07F8, r1
    92b4:	20 e0       	ldi	r18, 0x00	; 0
    92b6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    92b8:	f9 01       	movw	r30, r18
    92ba:	e5 5a       	subi	r30, 0xA5	; 165
    92bc:	f7 4f       	sbci	r31, 0xF7	; 247
    92be:	d9 01       	movw	r26, r18
    92c0:	a5 55       	subi	r26, 0x55	; 85
    92c2:	b3 4f       	sbci	r27, 0xF3	; 243
    92c4:	8c 91       	ld	r24, X
    92c6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    92c8:	2f 5f       	subi	r18, 0xFF	; 255
    92ca:	3f 4f       	sbci	r19, 0xFF	; 255
    92cc:	2a 30       	cpi	r18, 0x0A	; 10
    92ce:	31 05       	cpc	r19, r1
    92d0:	99 f7       	brne	.-26     	; 0x92b8 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    92d2:	10 92 65 08 	sts	0x0865, r1
    92d6:	20 e0       	ldi	r18, 0x00	; 0
    92d8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    92da:	f9 01       	movw	r30, r18
    92dc:	ed 55       	subi	r30, 0x5D	; 93
    92de:	fc 4f       	sbci	r31, 0xFC	; 252
    92e0:	d9 01       	movw	r26, r18
    92e2:	ab 54       	subi	r26, 0x4B	; 75
    92e4:	b3 4f       	sbci	r27, 0xF3	; 243
    92e6:	8c 91       	ld	r24, X
    92e8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    92ea:	2f 5f       	subi	r18, 0xFF	; 255
    92ec:	3f 4f       	sbci	r19, 0xFF	; 255
    92ee:	28 30       	cpi	r18, 0x08	; 8
    92f0:	31 05       	cpc	r19, r1
    92f2:	99 f7       	brne	.-26     	; 0x92da <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    92f4:	10 92 ab 03 	sts	0x03AB, r1
    92f8:	20 e0       	ldi	r18, 0x00	; 0
    92fa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    92fc:	f9 01       	movw	r30, r18
    92fe:	ee 56       	subi	r30, 0x6E	; 110
    9300:	f1 4f       	sbci	r31, 0xF1	; 241
    9302:	d9 01       	movw	r26, r18
    9304:	a3 54       	subi	r26, 0x43	; 67
    9306:	b3 4f       	sbci	r27, 0xF3	; 243
    9308:	8c 91       	ld	r24, X
    930a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    930c:	2f 5f       	subi	r18, 0xFF	; 255
    930e:	3f 4f       	sbci	r19, 0xFF	; 255
    9310:	2a 30       	cpi	r18, 0x0A	; 10
    9312:	31 05       	cpc	r19, r1
    9314:	99 f7       	brne	.-26     	; 0x92fc <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9316:	10 92 9c 0e 	sts	0x0E9C, r1
    931a:	20 e0       	ldi	r18, 0x00	; 0
    931c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    931e:	f9 01       	movw	r30, r18
    9320:	e5 5e       	subi	r30, 0xE5	; 229
    9322:	f1 4f       	sbci	r31, 0xF1	; 241
    9324:	d9 01       	movw	r26, r18
    9326:	a9 53       	subi	r26, 0x39	; 57
    9328:	b3 4f       	sbci	r27, 0xF3	; 243
    932a:	8c 91       	ld	r24, X
    932c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    932e:	2f 5f       	subi	r18, 0xFF	; 255
    9330:	3f 4f       	sbci	r19, 0xFF	; 255
    9332:	24 31       	cpi	r18, 0x14	; 20
    9334:	31 05       	cpc	r19, r1
    9336:	99 f7       	brne	.-26     	; 0x931e <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9338:	10 92 2f 0e 	sts	0x0E2F, r1
    933c:	20 e0       	ldi	r18, 0x00	; 0
    933e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9340:	f9 01       	movw	r30, r18
    9342:	ea 52       	subi	r30, 0x2A	; 42
    9344:	fc 4f       	sbci	r31, 0xFC	; 252
    9346:	d9 01       	movw	r26, r18
    9348:	a5 52       	subi	r26, 0x25	; 37
    934a:	b3 4f       	sbci	r27, 0xF3	; 243
    934c:	8c 91       	ld	r24, X
    934e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9350:	2f 5f       	subi	r18, 0xFF	; 255
    9352:	3f 4f       	sbci	r19, 0xFF	; 255
    9354:	2e 31       	cpi	r18, 0x1E	; 30
    9356:	31 05       	cpc	r19, r1
    9358:	99 f7       	brne	.-26     	; 0x9340 <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    935a:	10 92 f4 03 	sts	0x03F4, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    935e:	80 91 91 01 	lds	r24, 0x0191
    9362:	88 23       	and	r24, r24
    9364:	69 f0       	breq	.+26     	; 0x9380 <procMessage99+0x46a>
    9366:	00 91 5f 03 	lds	r16, 0x035F
    936a:	10 e0       	ldi	r17, 0x00	; 0
    936c:	82 ec       	ldi	r24, 0xC2	; 194
    936e:	97 e0       	ldi	r25, 0x07	; 7
    9370:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
    9374:	08 17       	cp	r16, r24
    9376:	19 07       	cpc	r17, r25
    9378:	19 f4       	brne	.+6      	; 0x9380 <procMessage99+0x46a>
	        IsCompleteFilling=True;
    937a:	81 e0       	ldi	r24, 0x01	; 1
    937c:	80 93 ab 01 	sts	0x01AB, r24
	   }

	  }
     return Result;     
}
    9380:	80 e0       	ldi	r24, 0x00	; 0
    9382:	1f 91       	pop	r17
    9384:	0f 91       	pop	r16
    9386:	08 95       	ret

00009388 <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
    9388:	8f 92       	push	r8
    938a:	9f 92       	push	r9
    938c:	af 92       	push	r10
    938e:	bf 92       	push	r11
    9390:	cf 92       	push	r12
    9392:	df 92       	push	r13
    9394:	ef 92       	push	r14
    9396:	ff 92       	push	r15
    9398:	0f 93       	push	r16
    939a:	1f 93       	push	r17
    939c:	df 93       	push	r29
    939e:	cf 93       	push	r28
    93a0:	cd b7       	in	r28, 0x3d	; 61
    93a2:	de b7       	in	r29, 0x3e	; 62
    93a4:	c6 54       	subi	r28, 0x46	; 70
    93a6:	d0 40       	sbci	r29, 0x00	; 0
    93a8:	0f b6       	in	r0, 0x3f	; 63
    93aa:	f8 94       	cli
    93ac:	de bf       	out	0x3e, r29	; 62
    93ae:	0f be       	out	0x3f, r0	; 63
    93b0:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
    93b2:	00 d0       	rcall	.+0      	; 0x93b4 <SaveConfigParameter+0x2c>
    93b4:	00 d0       	rcall	.+0      	; 0x93b6 <SaveConfigParameter+0x2e>
    93b6:	00 d0       	rcall	.+0      	; 0x93b8 <SaveConfigParameter+0x30>
    93b8:	ed b7       	in	r30, 0x3d	; 61
    93ba:	fe b7       	in	r31, 0x3e	; 62
    93bc:	31 96       	adiw	r30, 0x01	; 1
    93be:	8e 01       	movw	r16, r28
    93c0:	0f 5f       	subi	r16, 0xFF	; 255
    93c2:	1f 4f       	sbci	r17, 0xFF	; 255
    93c4:	ad b7       	in	r26, 0x3d	; 61
    93c6:	be b7       	in	r27, 0x3e	; 62
    93c8:	12 96       	adiw	r26, 0x02	; 2
    93ca:	1c 93       	st	X, r17
    93cc:	0e 93       	st	-X, r16
    93ce:	11 97       	sbiw	r26, 0x01	; 1
    93d0:	8a ea       	ldi	r24, 0xAA	; 170
    93d2:	92 e2       	ldi	r25, 0x22	; 34
    93d4:	93 83       	std	Z+3, r25	; 0x03
    93d6:	82 83       	std	Z+2, r24	; 0x02
    93d8:	80 91 8d 01 	lds	r24, 0x018D
    93dc:	90 91 8e 01 	lds	r25, 0x018E
    93e0:	95 83       	std	Z+5, r25	; 0x05
    93e2:	84 83       	std	Z+4, r24	; 0x04
    93e4:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 uart_print(1,1,strSend);
    93e8:	ed b7       	in	r30, 0x3d	; 61
    93ea:	fe b7       	in	r31, 0x3e	; 62
    93ec:	36 96       	adiw	r30, 0x06	; 6
    93ee:	0f b6       	in	r0, 0x3f	; 63
    93f0:	f8 94       	cli
    93f2:	fe bf       	out	0x3e, r31	; 62
    93f4:	0f be       	out	0x3f, r0	; 63
    93f6:	ed bf       	out	0x3d, r30	; 61
    93f8:	81 e0       	ldi	r24, 0x01	; 1
    93fa:	61 e0       	ldi	r22, 0x01	; 1
    93fc:	a8 01       	movw	r20, r16
    93fe:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
    9402:	81 e0       	ldi	r24, 0x01	; 1
    9404:	61 e0       	ldi	r22, 0x01	; 1
    9406:	41 ea       	ldi	r20, 0xA1	; 161
    9408:	52 e2       	ldi	r21, 0x22	; 34
    940a:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
    940e:	07 e2       	ldi	r16, 0x27	; 39
    9410:	12 e0       	ldi	r17, 0x02	; 2
    9412:	b6 e2       	ldi	r27, 0x26	; 38
    9414:	eb 2e       	mov	r14, r27
    9416:	bb e0       	ldi	r27, 0x0B	; 11
    9418:	fb 2e       	mov	r15, r27
    941a:	a5 e1       	ldi	r26, 0x15	; 21
    941c:	aa 2e       	mov	r10, r26
    941e:	b1 2c       	mov	r11, r1
    9420:	ac 0e       	add	r10, r28
    9422:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9424:	fd e3       	ldi	r31, 0x3D	; 61
    9426:	cf 2e       	mov	r12, r31
    9428:	d1 2c       	mov	r13, r1
    942a:	cc 0e       	add	r12, r28
    942c:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
    942e:	d7 01       	movw	r26, r14
    9430:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9432:	8d 91       	ld	r24, X+
    9434:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9436:	ec 15       	cp	r30, r12
    9438:	fd 05       	cpc	r31, r13
    943a:	d9 f7       	brne	.-10     	; 0x9432 <SaveConfigParameter+0xaa>
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
    943c:	1d ae       	std	Y+61, r1	; 0x3d
    943e:	c8 01       	movw	r24, r16
    9440:	b5 01       	movw	r22, r10
    9442:	49 e2       	ldi	r20, 0x29	; 41
    9444:	50 e0       	ldi	r21, 0x00	; 0
    9446:	2a e4       	ldi	r18, 0x4A	; 74
    9448:	33 e1       	ldi	r19, 0x13	; 19
    944a:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    944e:	07 5d       	subi	r16, 0xD7	; 215
    9450:	1f 4f       	sbci	r17, 0xFF	; 255
    9452:	88 e2       	ldi	r24, 0x28	; 40
    9454:	90 e0       	ldi	r25, 0x00	; 0
    9456:	e8 0e       	add	r14, r24
    9458:	f9 1e       	adc	r15, r25
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
    945a:	93 e0       	ldi	r25, 0x03	; 3
    945c:	01 3c       	cpi	r16, 0xC1	; 193
    945e:	19 07       	cpc	r17, r25
    9460:	31 f7       	brne	.-52     	; 0x942e <SaveConfigParameter+0xa6>
    9462:	0b eb       	ldi	r16, 0xBB	; 187
    9464:	10 e0       	ldi	r17, 0x00	; 0
    9466:	e6 eb       	ldi	r30, 0xB6	; 182
    9468:	ee 2e       	mov	r14, r30
    946a:	ec e0       	ldi	r30, 0x0C	; 12
    946c:	fe 2e       	mov	r15, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    946e:	75 e1       	ldi	r23, 0x15	; 21
    9470:	c7 2e       	mov	r12, r23
    9472:	d1 2c       	mov	r13, r1
    9474:	cc 0e       	add	r12, r28
    9476:	dd 1e       	adc	r13, r29
    9478:	61 e2       	ldi	r22, 0x21	; 33
    947a:	86 2e       	mov	r8, r22
    947c:	91 2c       	mov	r9, r1
    947e:	8c 0e       	add	r8, r28
    9480:	9d 1e       	adc	r9, r29
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
    9482:	d7 01       	movw	r26, r14
    9484:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9486:	8d 91       	ld	r24, X+
    9488:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    948a:	e8 15       	cp	r30, r8
    948c:	f9 05       	cpc	r31, r9
    948e:	d9 f7       	brne	.-10     	; 0x9486 <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9490:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
    9492:	c6 01       	movw	r24, r12
    9494:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
    9498:	f6 01       	movw	r30, r12
    949a:	01 90       	ld	r0, Z+
    949c:	00 20       	and	r0, r0
    949e:	e9 f7       	brne	.-6      	; 0x949a <SaveConfigParameter+0x112>
    94a0:	31 97       	sbiw	r30, 0x01	; 1
    94a2:	10 82       	st	Z, r1
    94a4:	c8 01       	movw	r24, r16
    94a6:	b6 01       	movw	r22, r12
    94a8:	4d e0       	ldi	r20, 0x0D	; 13
    94aa:	50 e0       	ldi	r21, 0x00	; 0
    94ac:	2a e4       	ldi	r18, 0x4A	; 74
    94ae:	33 e1       	ldi	r19, 0x13	; 19
    94b0:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    94b4:	03 5f       	subi	r16, 0xF3	; 243
    94b6:	1f 4f       	sbci	r17, 0xFF	; 255
    94b8:	ac e0       	ldi	r26, 0x0C	; 12
    94ba:	b0 e0       	ldi	r27, 0x00	; 0
    94bc:	ea 0e       	add	r14, r26
    94be:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
    94c0:	b1 e0       	ldi	r27, 0x01	; 1
    94c2:	09 30       	cpi	r16, 0x09	; 9
    94c4:	1b 07       	cpc	r17, r27
    94c6:	e9 f6       	brne	.-70     	; 0x9482 <SaveConfigParameter+0xfa>
    94c8:	05 e8       	ldi	r16, 0x85	; 133
    94ca:	10 e0       	ldi	r17, 0x00	; 0
    94cc:	5e ef       	ldi	r21, 0xFE	; 254
    94ce:	e5 2e       	mov	r14, r21
    94d0:	5c e0       	ldi	r21, 0x0C	; 12
    94d2:	f5 2e       	mov	r15, r21
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    94d4:	45 e1       	ldi	r20, 0x15	; 21
    94d6:	c4 2e       	mov	r12, r20
    94d8:	d1 2c       	mov	r13, r1
    94da:	cc 0e       	add	r12, r28
    94dc:	dd 1e       	adc	r13, r29
    94de:	3a e1       	ldi	r19, 0x1A	; 26
    94e0:	83 2e       	mov	r8, r19
    94e2:	91 2c       	mov	r9, r1
    94e4:	8c 0e       	add	r8, r28
    94e6:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
    94e8:	d7 01       	movw	r26, r14
    94ea:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    94ec:	8d 91       	ld	r24, X+
    94ee:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    94f0:	e8 15       	cp	r30, r8
    94f2:	f9 05       	cpc	r31, r9
    94f4:	d9 f7       	brne	.-10     	; 0x94ec <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    94f6:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
    94f8:	c6 01       	movw	r24, r12
    94fa:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
    94fe:	c8 01       	movw	r24, r16
    9500:	b6 01       	movw	r22, r12
    9502:	49 e0       	ldi	r20, 0x09	; 9
    9504:	50 e0       	ldi	r21, 0x00	; 0
    9506:	2a e4       	ldi	r18, 0x4A	; 74
    9508:	33 e1       	ldi	r19, 0x13	; 19
    950a:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    950e:	07 5f       	subi	r16, 0xF7	; 247
    9510:	1f 4f       	sbci	r17, 0xFF	; 255
    9512:	e5 e0       	ldi	r30, 0x05	; 5
    9514:	f0 e0       	ldi	r31, 0x00	; 0
    9516:	ee 0e       	add	r14, r30
    9518:	ff 1e       	adc	r15, r31
		// uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
    951a:	f0 e0       	ldi	r31, 0x00	; 0
    951c:	0b 3b       	cpi	r16, 0xBB	; 187
    951e:	1f 07       	cpc	r17, r31
    9520:	19 f7       	brne	.-58     	; 0x94e8 <SaveConfigParameter+0x160>
    9522:	0c e1       	ldi	r16, 0x1C	; 28
    9524:	1d e0       	ldi	r17, 0x0D	; 13
    9526:	25 e4       	ldi	r18, 0x45	; 69
    9528:	e2 2e       	mov	r14, r18
    952a:	20 e0       	ldi	r18, 0x00	; 0
    952c:	f2 2e       	mov	r15, r18
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
    952e:	95 e1       	ldi	r25, 0x15	; 21
    9530:	c9 2e       	mov	r12, r25
    9532:	d1 2c       	mov	r13, r1
    9534:	cc 0e       	add	r12, r28
    9536:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
    9538:	4e 01       	movw	r8, r28
    953a:	08 94       	sec
    953c:	81 1c       	adc	r8, r1
    953e:	91 1c       	adc	r9, r1
    9540:	8e e9       	ldi	r24, 0x9E	; 158
    9542:	a8 2e       	mov	r10, r24
    9544:	82 e2       	ldi	r24, 0x22	; 34
    9546:	b8 2e       	mov	r11, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9548:	d8 01       	movw	r26, r16
    954a:	8c 91       	ld	r24, X
    954c:	8d 8b       	std	Y+21, r24	; 0x15
    954e:	11 96       	adiw	r26, 0x01	; 1
    9550:	8c 91       	ld	r24, X
    9552:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
    9554:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
    9556:	c6 01       	movw	r24, r12
    9558:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
    955c:	c6 01       	movw	r24, r12
    955e:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9562:	e1 99       	sbic	0x1c, 1	; 28
    9564:	fe cf       	rjmp	.-4      	; 0x9562 <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9566:	ff ba       	out	0x1f, r15	; 31
    9568:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
    956a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    956c:	0f b6       	in	r0, 0x3f	; 63
    956e:	f8 94       	cli
    9570:	e2 9a       	sbi	0x1c, 2	; 28
    9572:	e1 9a       	sbi	0x1c, 1	; 28
    9574:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
    9576:	00 d0       	rcall	.+0      	; 0x9578 <SaveConfigParameter+0x1f0>
    9578:	00 d0       	rcall	.+0      	; 0x957a <SaveConfigParameter+0x1f2>
    957a:	00 d0       	rcall	.+0      	; 0x957c <SaveConfigParameter+0x1f4>
    957c:	ed b7       	in	r30, 0x3d	; 61
    957e:	fe b7       	in	r31, 0x3e	; 62
    9580:	31 96       	adiw	r30, 0x01	; 1
    9582:	ad b7       	in	r26, 0x3d	; 61
    9584:	be b7       	in	r27, 0x3e	; 62
    9586:	12 96       	adiw	r26, 0x02	; 2
    9588:	9c 92       	st	X, r9
    958a:	8e 92       	st	-X, r8
    958c:	11 97       	sbiw	r26, 0x01	; 1
    958e:	b3 82       	std	Z+3, r11	; 0x03
    9590:	a2 82       	std	Z+2, r10	; 0x02
    9592:	84 83       	std	Z+4, r24	; 0x04
    9594:	15 82       	std	Z+5, r1	; 0x05
    9596:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    959a:	0e 5f       	subi	r16, 0xFE	; 254
    959c:	1f 4f       	sbci	r17, 0xFF	; 255
    959e:	08 94       	sec
    95a0:	e1 1c       	adc	r14, r1
    95a2:	f1 1c       	adc	r15, r1
		// uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
    95a4:	ed b7       	in	r30, 0x3d	; 61
    95a6:	fe b7       	in	r31, 0x3e	; 62
    95a8:	36 96       	adiw	r30, 0x06	; 6
    95aa:	0f b6       	in	r0, 0x3f	; 63
    95ac:	f8 94       	cli
    95ae:	fe bf       	out	0x3e, r31	; 62
    95b0:	0f be       	out	0x3f, r0	; 63
    95b2:	ed bf       	out	0x3d, r30	; 61
    95b4:	fd e0       	ldi	r31, 0x0D	; 13
    95b6:	0c 32       	cpi	r16, 0x2C	; 44
    95b8:	1f 07       	cpc	r17, r31
    95ba:	09 f0       	breq	.+2      	; 0x95be <SaveConfigParameter+0x236>
    95bc:	c5 cf       	rjmp	.-118    	; 0x9548 <SaveConfigParameter+0x1c0>
    95be:	45 e5       	ldi	r20, 0x55	; 85
    95c0:	50 e0       	ldi	r21, 0x00	; 0
    95c2:	b8 01       	movw	r22, r16
    95c4:	1d c0       	rjmp	.+58     	; 0x9600 <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    95c6:	90 81       	ld	r25, Z
    95c8:	90 53       	subi	r25, 0x30	; 48
    95ca:	9a 30       	cpi	r25, 0x0A	; 10
    95cc:	08 f0       	brcs	.+2      	; 0x95d0 <SaveConfigParameter+0x248>
    95ce:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    95d0:	e1 99       	sbic	0x1c, 1	; 28
    95d2:	fe cf       	rjmp	.-4      	; 0x95d0 <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    95d4:	3f bb       	out	0x1f, r19	; 31
    95d6:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    95d8:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    95da:	0f b6       	in	r0, 0x3f	; 63
    95dc:	f8 94       	cli
    95de:	e2 9a       	sbi	0x1c, 2	; 28
    95e0:	e1 9a       	sbi	0x1c, 1	; 28
    95e2:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
    95e4:	8f 5f       	subi	r24, 0xFF	; 255
    95e6:	31 96       	adiw	r30, 0x01	; 1
    95e8:	2f 5f       	subi	r18, 0xFF	; 255
    95ea:	3f 4f       	sbci	r19, 0xFF	; 255
    95ec:	86 30       	cpi	r24, 0x06	; 6
    95ee:	59 f7       	brne	.-42     	; 0x95c6 <SaveConfigParameter+0x23e>
    95f0:	4a 5f       	subi	r20, 0xFA	; 250
    95f2:	5f 4f       	sbci	r21, 0xFF	; 255
    95f4:	6a 5f       	subi	r22, 0xFA	; 250
    95f6:	7f 4f       	sbci	r23, 0xFF	; 255
		// uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
    95f8:	80 e0       	ldi	r24, 0x00	; 0
    95fa:	45 38       	cpi	r20, 0x85	; 133
    95fc:	58 07       	cpc	r21, r24
    95fe:	21 f0       	breq	.+8      	; 0x9608 <SaveConfigParameter+0x280>
    9600:	fb 01       	movw	r30, r22
    9602:	9a 01       	movw	r18, r20
    9604:	80 e0       	ldi	r24, 0x00	; 0
    9606:	df cf       	rjmp	.-66     	; 0x95c6 <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    9608:	80 91 5c 0d 	lds	r24, 0x0D5C
    960c:	80 53       	subi	r24, 0x30	; 48
    960e:	8a 30       	cpi	r24, 0x0A	; 10
    9610:	10 f0       	brcs	.+4      	; 0x9616 <SaveConfigParameter+0x28e>
    9612:	20 e0       	ldi	r18, 0x00	; 0
    9614:	03 c0       	rjmp	.+6      	; 0x961c <SaveConfigParameter+0x294>
    9616:	81 11       	cpse	r24, r1
    9618:	81 e0       	ldi	r24, 0x01	; 1
    961a:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    961c:	e1 99       	sbic	0x1c, 1	; 28
    961e:	fe cf       	rjmp	.-4      	; 0x961c <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9620:	81 ec       	ldi	r24, 0xC1	; 193
    9622:	93 e0       	ldi	r25, 0x03	; 3
    9624:	9f bb       	out	0x1f, r25	; 31
    9626:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9628:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    962a:	0f b6       	in	r0, 0x3f	; 63
    962c:	f8 94       	cli
    962e:	e2 9a       	sbi	0x1c, 2	; 28
    9630:	e1 9a       	sbi	0x1c, 1	; 28
    9632:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9634:	80 91 5d 0d 	lds	r24, 0x0D5D
    9638:	8d 8b       	std	Y+21, r24	; 0x15
    963a:	80 91 5e 0d 	lds	r24, 0x0D5E
    963e:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
    9640:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
    9642:	8e 01       	movw	r16, r28
    9644:	0b 5e       	subi	r16, 0xEB	; 235
    9646:	1f 4f       	sbci	r17, 0xFF	; 255
    9648:	c8 01       	movw	r24, r16
    964a:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
    964e:	c8 01       	movw	r24, r16
    9650:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
    9654:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9656:	e1 99       	sbic	0x1c, 1	; 28
    9658:	fe cf       	rjmp	.-4      	; 0x9656 <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    965a:	80 e0       	ldi	r24, 0x00	; 0
    965c:	90 e0       	ldi	r25, 0x00	; 0
    965e:	9f bb       	out	0x1f, r25	; 31
    9660:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9662:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    9664:	0f b6       	in	r0, 0x3f	; 63
    9666:	f8 94       	cli
    9668:	e2 9a       	sbi	0x1c, 2	; 28
    966a:	e1 9a       	sbi	0x1c, 1	; 28
    966c:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
    966e:	00 d0       	rcall	.+0      	; 0x9670 <SaveConfigParameter+0x2e8>
    9670:	00 d0       	rcall	.+0      	; 0x9672 <SaveConfigParameter+0x2ea>
    9672:	00 d0       	rcall	.+0      	; 0x9674 <SaveConfigParameter+0x2ec>
    9674:	ed b7       	in	r30, 0x3d	; 61
    9676:	fe b7       	in	r31, 0x3e	; 62
    9678:	31 96       	adiw	r30, 0x01	; 1
    967a:	8e 01       	movw	r16, r28
    967c:	0f 5f       	subi	r16, 0xFF	; 255
    967e:	1f 4f       	sbci	r17, 0xFF	; 255
    9680:	ad b7       	in	r26, 0x3d	; 61
    9682:	be b7       	in	r27, 0x3e	; 62
    9684:	12 96       	adiw	r26, 0x02	; 2
    9686:	1c 93       	st	X, r17
    9688:	0e 93       	st	-X, r16
    968a:	11 97       	sbiw	r26, 0x01	; 1
    968c:	8b e9       	ldi	r24, 0x9B	; 155
    968e:	92 e2       	ldi	r25, 0x22	; 34
    9690:	93 83       	std	Z+3, r25	; 0x03
    9692:	82 83       	std	Z+2, r24	; 0x02
    9694:	24 83       	std	Z+4, r18	; 0x04
    9696:	15 82       	std	Z+5, r1	; 0x05
    9698:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    969c:	bf e5       	ldi	r27, 0x5F	; 95
    969e:	eb 2e       	mov	r14, r27
    96a0:	bd e0       	ldi	r27, 0x0D	; 13
    96a2:	fb 2e       	mov	r15, r27
    96a4:	ad e4       	ldi	r26, 0x4D	; 77
    96a6:	ca 2e       	mov	r12, r26
    96a8:	a0 e0       	ldi	r26, 0x00	; 0
    96aa:	da 2e       	mov	r13, r26
    96ac:	ed b7       	in	r30, 0x3d	; 61
    96ae:	fe b7       	in	r31, 0x3e	; 62
    96b0:	36 96       	adiw	r30, 0x06	; 6
    96b2:	0f b6       	in	r0, 0x3f	; 63
    96b4:	f8 94       	cli
    96b6:	fe bf       	out	0x3e, r31	; 62
    96b8:	0f be       	out	0x3f, r0	; 63
    96ba:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
    96bc:	f5 e1       	ldi	r31, 0x15	; 21
    96be:	af 2e       	mov	r10, r31
    96c0:	b1 2c       	mov	r11, r1
    96c2:	ac 0e       	add	r10, r28
    96c4:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
    96c6:	48 01       	movw	r8, r16
    96c8:	08 e9       	ldi	r16, 0x98	; 152
    96ca:	12 e2       	ldi	r17, 0x22	; 34
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    96cc:	d7 01       	movw	r26, r14
    96ce:	8c 91       	ld	r24, X
    96d0:	8d 8b       	std	Y+21, r24	; 0x15
    96d2:	11 96       	adiw	r26, 0x01	; 1
    96d4:	8c 91       	ld	r24, X
    96d6:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
    96d8:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
    96da:	c5 01       	movw	r24, r10
    96dc:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
    96e0:	c5 01       	movw	r24, r10
    96e2:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    96e6:	e1 99       	sbic	0x1c, 1	; 28
    96e8:	fe cf       	rjmp	.-4      	; 0x96e6 <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    96ea:	df ba       	out	0x1f, r13	; 31
    96ec:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
    96ee:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    96f0:	0f b6       	in	r0, 0x3f	; 63
    96f2:	f8 94       	cli
    96f4:	e2 9a       	sbi	0x1c, 2	; 28
    96f6:	e1 9a       	sbi	0x1c, 1	; 28
    96f8:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
    96fa:	00 d0       	rcall	.+0      	; 0x96fc <SaveConfigParameter+0x374>
    96fc:	00 d0       	rcall	.+0      	; 0x96fe <SaveConfigParameter+0x376>
    96fe:	00 d0       	rcall	.+0      	; 0x9700 <SaveConfigParameter+0x378>
    9700:	ed b7       	in	r30, 0x3d	; 61
    9702:	fe b7       	in	r31, 0x3e	; 62
    9704:	31 96       	adiw	r30, 0x01	; 1
    9706:	ad b7       	in	r26, 0x3d	; 61
    9708:	be b7       	in	r27, 0x3e	; 62
    970a:	11 96       	adiw	r26, 0x01	; 1
    970c:	8c 92       	st	X, r8
    970e:	11 97       	sbiw	r26, 0x01	; 1
    9710:	12 96       	adiw	r26, 0x02	; 2
    9712:	9c 92       	st	X, r9
    9714:	13 83       	std	Z+3, r17	; 0x03
    9716:	02 83       	std	Z+2, r16	; 0x02
    9718:	84 83       	std	Z+4, r24	; 0x04
    971a:	15 82       	std	Z+5, r1	; 0x05
    971c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    9720:	e2 e0       	ldi	r30, 0x02	; 2
    9722:	f0 e0       	ldi	r31, 0x00	; 0
    9724:	ee 0e       	add	r14, r30
    9726:	ff 1e       	adc	r15, r31
    9728:	08 94       	sec
    972a:	c1 1c       	adc	r12, r1
    972c:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
    972e:	8d b7       	in	r24, 0x3d	; 61
    9730:	9e b7       	in	r25, 0x3e	; 62
    9732:	06 96       	adiw	r24, 0x06	; 6
    9734:	0f b6       	in	r0, 0x3f	; 63
    9736:	f8 94       	cli
    9738:	9e bf       	out	0x3e, r25	; 62
    973a:	0f be       	out	0x3f, r0	; 63
    973c:	8d bf       	out	0x3d, r24	; 61
    973e:	9f e6       	ldi	r25, 0x6F	; 111
    9740:	e9 16       	cp	r14, r25
    9742:	9d e0       	ldi	r25, 0x0D	; 13
    9744:	f9 06       	cpc	r15, r25
    9746:	09 f0       	breq	.+2      	; 0x974a <SaveConfigParameter+0x3c2>
    9748:	c1 cf       	rjmp	.-126    	; 0x96cc <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 uart_print(1,1,strSend); 
	 }    
	 uart_printf(1,1,PSTR("<OK>")); 
    974a:	81 e0       	ldi	r24, 0x01	; 1
    974c:	61 e0       	ldi	r22, 0x01	; 1
    974e:	43 e9       	ldi	r20, 0x93	; 147
    9750:	52 e2       	ldi	r21, 0x22	; 34
    9752:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
}
    9756:	ca 5b       	subi	r28, 0xBA	; 186
    9758:	df 4f       	sbci	r29, 0xFF	; 255
    975a:	0f b6       	in	r0, 0x3f	; 63
    975c:	f8 94       	cli
    975e:	de bf       	out	0x3e, r29	; 62
    9760:	0f be       	out	0x3f, r0	; 63
    9762:	cd bf       	out	0x3d, r28	; 61
    9764:	cf 91       	pop	r28
    9766:	df 91       	pop	r29
    9768:	1f 91       	pop	r17
    976a:	0f 91       	pop	r16
    976c:	ff 90       	pop	r15
    976e:	ef 90       	pop	r14
    9770:	df 90       	pop	r13
    9772:	cf 90       	pop	r12
    9774:	bf 90       	pop	r11
    9776:	af 90       	pop	r10
    9778:	9f 90       	pop	r9
    977a:	8f 90       	pop	r8
    977c:	08 95       	ret

0000977e <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
    977e:	80 91 a9 02 	lds	r24, 0x02A9
    9782:	81 30       	cpi	r24, 0x01	; 1
    9784:	c1 f0       	breq	.+48     	; 0x97b6 <systemConfigProtocol+0x38>
    9786:	81 30       	cpi	r24, 0x01	; 1
    9788:	18 f0       	brcs	.+6      	; 0x9790 <systemConfigProtocol+0x12>
    978a:	82 30       	cpi	r24, 0x02	; 2
    978c:	e9 f4       	brne	.+58     	; 0x97c8 <systemConfigProtocol+0x4a>
    978e:	18 c0       	rjmp	.+48     	; 0x97c0 <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
    9790:	80 91 b2 01 	lds	r24, 0x01B2
    9794:	81 30       	cpi	r24, 0x01	; 1
    9796:	31 f0       	breq	.+12     	; 0x97a4 <systemConfigProtocol+0x26>
    9798:	82 30       	cpi	r24, 0x02	; 2
    979a:	51 f4       	brne	.+20     	; 0x97b0 <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
    979c:	10 92 b2 01 	sts	0x01B2, r1
			   stConfigProtocol=cpSendingParameter;
    97a0:	81 e0       	ldi	r24, 0x01	; 1
    97a2:	03 c0       	rjmp	.+6      	; 0x97aa <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
    97a4:	10 92 b2 01 	sts	0x01B2, r1
			   stConfigProtocol=cpSavingParameter;
    97a8:	82 e0       	ldi	r24, 0x02	; 2
    97aa:	80 93 a9 02 	sts	0x02A9, r24
    97ae:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
    97b0:	10 92 b2 01 	sts	0x01B2, r1
    97b4:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
    97b6:	0e 94 39 31 	call	0x6272	; 0x6272 <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
    97ba:	10 92 a9 02 	sts	0x02A9, r1
    97be:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
    97c0:	0e 94 c4 49 	call	0x9388	; 0x9388 <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
    97c4:	10 92 a9 02 	sts	0x02A9, r1
    97c8:	08 95       	ret

000097ca <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    97ca:	0f 93       	push	r16
    97cc:	1f 93       	push	r17
    97ce:	df 93       	push	r29
    97d0:	cf 93       	push	r28
    97d2:	00 d0       	rcall	.+0      	; 0x97d4 <GetMessageID+0xa>
    97d4:	0f 92       	push	r0
    97d6:	cd b7       	in	r28, 0x3d	; 61
    97d8:	de b7       	in	r29, 0x3e	; 62
    97da:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    97dc:	80 81       	ld	r24, Z
    97de:	89 83       	std	Y+1, r24	; 0x01
    97e0:	81 81       	ldd	r24, Z+1	; 0x01
    97e2:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    97e4:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    97e6:	8e 01       	movw	r16, r28
    97e8:	0f 5f       	subi	r16, 0xFF	; 255
    97ea:	1f 4f       	sbci	r17, 0xFF	; 255
    97ec:	c8 01       	movw	r24, r16
    97ee:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
	 Result=atoi(strMsgID);
    97f2:	c8 01       	movw	r24, r16
    97f4:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
  return Result;
}
    97f8:	0f 90       	pop	r0
    97fa:	0f 90       	pop	r0
    97fc:	0f 90       	pop	r0
    97fe:	cf 91       	pop	r28
    9800:	df 91       	pop	r29
    9802:	1f 91       	pop	r17
    9804:	0f 91       	pop	r16
    9806:	08 95       	ret

00009808 <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    9808:	1f 93       	push	r17
    980a:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    980c:	89 31       	cpi	r24, 0x19	; 25
    980e:	59 f4       	brne	.+22     	; 0x9826 <SendPrint+0x1e>
	     if (zSend==xSendLead)uart(_COM_PRINTER,1,xSendLead);
    9810:	40 91 ff 01 	lds	r20, 0x01FF
    9814:	46 17       	cp	r20, r22
    9816:	19 f4       	brne	.+6      	; 0x981e <SendPrint+0x16>
    9818:	80 e0       	ldi	r24, 0x00	; 0
    981a:	61 e0       	ldi	r22, 0x01	; 1
    981c:	07 c0       	rjmp	.+14     	; 0x982c <SendPrint+0x24>
		 else uart(_COM_PRINTER,1,' ');	 
    981e:	80 e0       	ldi	r24, 0x00	; 0
    9820:	61 e0       	ldi	r22, 0x01	; 1
    9822:	40 e2       	ldi	r20, 0x20	; 32
    9824:	03 c0       	rjmp	.+6      	; 0x982c <SendPrint+0x24>
	 } 
	 else uart(_COM_PRINTER,1,xSend);
    9826:	80 e0       	ldi	r24, 0x00	; 0
    9828:	61 e0       	ldi	r22, 0x01	; 1
    982a:	41 2f       	mov	r20, r17
    982c:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
	 zSend=xSend;
    9830:	10 93 ff 01 	sts	0x01FF, r17
}
    9834:	1f 91       	pop	r17
    9836:	08 95       	ret

00009838 <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     uart(_COM_PRINTER, 1, 0x0D);     
    9838:	80 e0       	ldi	r24, 0x00	; 0
    983a:	61 e0       	ldi	r22, 0x01	; 1
    983c:	4d e0       	ldi	r20, 0x0D	; 13
    983e:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
     uart(_COM_PRINTER, 1, 0x0A);
    9842:	80 e0       	ldi	r24, 0x00	; 0
    9844:	61 e0       	ldi	r22, 0x01	; 1
    9846:	4a e0       	ldi	r20, 0x0A	; 10
    9848:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
}
    984c:	08 95       	ret

0000984e <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    984e:	e1 99       	sbic	0x1c, 1	; 28
    9850:	fe cf       	rjmp	.-4      	; 0x984e <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9852:	80 e3       	ldi	r24, 0x30	; 48
    9854:	90 e0       	ldi	r25, 0x00	; 0
    9856:	9f bb       	out	0x1f, r25	; 31
    9858:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    985a:	e0 9a       	sbi	0x1c, 0	; 28
    985c:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    985e:	81 30       	cpi	r24, 0x01	; 1
    9860:	71 f5       	brne	.+92     	; 0x98be <InitPrinter+0x70>
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x7C);uart(_COM_PRINTER, 1, 0x00);
    9862:	80 e0       	ldi	r24, 0x00	; 0
    9864:	61 e0       	ldi	r22, 0x01	; 1
    9866:	4d e1       	ldi	r20, 0x1D	; 29
    9868:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    986c:	80 e0       	ldi	r24, 0x00	; 0
    986e:	61 e0       	ldi	r22, 0x01	; 1
    9870:	4c e7       	ldi	r20, 0x7C	; 124
    9872:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    9876:	80 e0       	ldi	r24, 0x00	; 0
    9878:	61 e0       	ldi	r22, 0x01	; 1
    987a:	40 e0       	ldi	r20, 0x00	; 0
    987c:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		//Double Strike ON : 1B 47 01
		uart(_COM_PRINTER, 1, 0x1B);uart(_COM_PRINTER, 1, 0x47);uart(_COM_PRINTER, 1, 0x01);
    9880:	80 e0       	ldi	r24, 0x00	; 0
    9882:	61 e0       	ldi	r22, 0x01	; 1
    9884:	4b e1       	ldi	r20, 0x1B	; 27
    9886:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    988a:	80 e0       	ldi	r24, 0x00	; 0
    988c:	61 e0       	ldi	r22, 0x01	; 1
    988e:	47 e4       	ldi	r20, 0x47	; 71
    9890:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    9894:	80 e0       	ldi	r24, 0x00	; 0
    9896:	61 e0       	ldi	r22, 0x01	; 1
    9898:	41 e0       	ldi	r20, 0x01	; 1
    989a:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x01);   
    989e:	80 e0       	ldi	r24, 0x00	; 0
    98a0:	61 e0       	ldi	r22, 0x01	; 1
    98a2:	4d e1       	ldi	r20, 0x1D	; 29
    98a4:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    98a8:	80 e0       	ldi	r24, 0x00	; 0
    98aa:	61 e0       	ldi	r22, 0x01	; 1
    98ac:	41 e2       	ldi	r20, 0x21	; 33
    98ae:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    98b2:	80 e0       	ldi	r24, 0x00	; 0
    98b4:	61 e0       	ldi	r22, 0x01	; 1
    98b6:	41 e0       	ldi	r20, 0x01	; 1
    98b8:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    98bc:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    98be:	82 30       	cpi	r24, 0x02	; 2
    98c0:	69 f5       	brne	.+90     	; 0x991c <InitPrinter+0xce>
        //Print Density 0%
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x7C);uart(_COM_PRINTER, 1, 0x04);
    98c2:	80 e0       	ldi	r24, 0x00	; 0
    98c4:	61 e0       	ldi	r22, 0x01	; 1
    98c6:	4d e1       	ldi	r20, 0x1D	; 29
    98c8:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    98cc:	80 e0       	ldi	r24, 0x00	; 0
    98ce:	61 e0       	ldi	r22, 0x01	; 1
    98d0:	4c e7       	ldi	r20, 0x7C	; 124
    98d2:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    98d6:	80 e0       	ldi	r24, 0x00	; 0
    98d8:	61 e0       	ldi	r22, 0x01	; 1
    98da:	44 e0       	ldi	r20, 0x04	; 4
    98dc:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		//Double Strike OFF : 1B 47 00
		uart(_COM_PRINTER, 1, 0x1B);uart(_COM_PRINTER, 1, 0x47);uart(_COM_PRINTER, 1, 0x00);
    98e0:	80 e0       	ldi	r24, 0x00	; 0
    98e2:	61 e0       	ldi	r22, 0x01	; 1
    98e4:	4b e1       	ldi	r20, 0x1B	; 27
    98e6:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    98ea:	80 e0       	ldi	r24, 0x00	; 0
    98ec:	61 e0       	ldi	r22, 0x01	; 1
    98ee:	47 e4       	ldi	r20, 0x47	; 71
    98f0:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    98f4:	80 e0       	ldi	r24, 0x00	; 0
    98f6:	61 e0       	ldi	r22, 0x01	; 1
    98f8:	40 e0       	ldi	r20, 0x00	; 0
    98fa:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);   
    98fe:	80 e0       	ldi	r24, 0x00	; 0
    9900:	61 e0       	ldi	r22, 0x01	; 1
    9902:	4d e1       	ldi	r20, 0x1D	; 29
    9904:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    9908:	80 e0       	ldi	r24, 0x00	; 0
    990a:	61 e0       	ldi	r22, 0x01	; 1
    990c:	41 e2       	ldi	r20, 0x21	; 33
    990e:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    9912:	80 e0       	ldi	r24, 0x00	; 0
    9914:	61 e0       	ldi	r22, 0x01	; 1
    9916:	40 e0       	ldi	r20, 0x00	; 0
    9918:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    991c:	08 95       	ret

0000991e <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    991e:	e1 99       	sbic	0x1c, 1	; 28
    9920:	fe cf       	rjmp	.-4      	; 0x991e <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9922:	80 e3       	ldi	r24, 0x30	; 48
    9924:	90 e0       	ldi	r25, 0x00	; 0
    9926:	9f bb       	out	0x1f, r25	; 31
    9928:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    992a:	e0 9a       	sbi	0x1c, 0	; 28
    992c:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    992e:	82 30       	cpi	r24, 0x02	; 2
    9930:	79 f4       	brne	.+30     	; 0x9950 <PrintNormalHeight+0x32>
	     uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);
    9932:	80 e0       	ldi	r24, 0x00	; 0
    9934:	61 e0       	ldi	r22, 0x01	; 1
    9936:	4d e1       	ldi	r20, 0x1D	; 29
    9938:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    993c:	80 e0       	ldi	r24, 0x00	; 0
    993e:	61 e0       	ldi	r22, 0x01	; 1
    9940:	41 e2       	ldi	r20, 0x21	; 33
    9942:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    9946:	80 e0       	ldi	r24, 0x00	; 0
    9948:	61 e0       	ldi	r22, 0x01	; 1
    994a:	40 e0       	ldi	r20, 0x00	; 0
    994c:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    9950:	08 95       	ret

00009952 <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9952:	e1 99       	sbic	0x1c, 1	; 28
    9954:	fe cf       	rjmp	.-4      	; 0x9952 <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9956:	80 e3       	ldi	r24, 0x30	; 48
    9958:	90 e0       	ldi	r25, 0x00	; 0
    995a:	9f bb       	out	0x1f, r25	; 31
    995c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    995e:	e0 9a       	sbi	0x1c, 0	; 28
    9960:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9962:	82 30       	cpi	r24, 0x02	; 2
    9964:	79 f4       	brne	.+30     	; 0x9984 <PrintDoubleHeight+0x32>
	     uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x01);
    9966:	80 e0       	ldi	r24, 0x00	; 0
    9968:	61 e0       	ldi	r22, 0x01	; 1
    996a:	4d e1       	ldi	r20, 0x1D	; 29
    996c:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    9970:	80 e0       	ldi	r24, 0x00	; 0
    9972:	61 e0       	ldi	r22, 0x01	; 1
    9974:	41 e2       	ldi	r20, 0x21	; 33
    9976:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    997a:	80 e0       	ldi	r24, 0x00	; 0
    997c:	61 e0       	ldi	r22, 0x01	; 1
    997e:	41 e0       	ldi	r20, 0x01	; 1
    9980:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    9984:	08 95       	ret

00009986 <PaperCut>:

	 return Result;
}


void PaperCut(){
    9986:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9988:	e1 99       	sbic	0x1c, 1	; 28
    998a:	fe cf       	rjmp	.-4      	; 0x9988 <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    998c:	83 e3       	ldi	r24, 0x33	; 51
    998e:	90 e0       	ldi	r25, 0x00	; 0
    9990:	9f bb       	out	0x1f, r25	; 31
    9992:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9994:	e0 9a       	sbi	0x1c, 0	; 28
    9996:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&DefPrintAutoCut);
     uart(_COM_PRINTER, 1, 0x1B);
    9998:	80 e0       	ldi	r24, 0x00	; 0
    999a:	61 e0       	ldi	r22, 0x01	; 1
    999c:	4b e1       	ldi	r20, 0x1B	; 27
    999e:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
	 if(CutType== 1) { uart(_COM_PRINTER, 1, 0x6D);}
    99a2:	11 30       	cpi	r17, 0x01	; 1
    99a4:	21 f4       	brne	.+8      	; 0x99ae <PaperCut+0x28>
    99a6:	80 e0       	ldi	r24, 0x00	; 0
    99a8:	61 e0       	ldi	r22, 0x01	; 1
    99aa:	4d e6       	ldi	r20, 0x6D	; 109
    99ac:	05 c0       	rjmp	.+10     	; 0x99b8 <PaperCut+0x32>
	 if(CutType== 2) {uart(_COM_PRINTER, 1, 0x69);}
    99ae:	12 30       	cpi	r17, 0x02	; 2
    99b0:	29 f4       	brne	.+10     	; 0x99bc <PaperCut+0x36>
    99b2:	80 e0       	ldi	r24, 0x00	; 0
    99b4:	61 e0       	ldi	r22, 0x01	; 1
    99b6:	49 e6       	ldi	r20, 0x69	; 105
    99b8:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>

}
    99bc:	1f 91       	pop	r17
    99be:	08 95       	ret

000099c0 <IFTSendMessage>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void IFTSendMessage(char MsgCode){//<STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode]
    99c0:	af 92       	push	r10
    99c2:	bf 92       	push	r11
    99c4:	cf 92       	push	r12
    99c6:	df 92       	push	r13
    99c8:	ef 92       	push	r14
    99ca:	ff 92       	push	r15
    99cc:	0f 93       	push	r16
    99ce:	df 93       	push	r29
    99d0:	cf 93       	push	r28
    99d2:	cd b7       	in	r28, 0x3d	; 61
    99d4:	de b7       	in	r29, 0x3e	; 62
    99d6:	c0 54       	subi	r28, 0x40	; 64
    99d8:	d0 40       	sbci	r29, 0x00	; 0
    99da:	0f b6       	in	r0, 0x3f	; 63
    99dc:	f8 94       	cli
    99de:	de bf       	out	0x3e, r29	; 62
    99e0:	0f be       	out	0x3f, r0	; 63
    99e2:	cd bf       	out	0x3d, r28	; 61
    99e4:	08 2f       	mov	r16, r24
	 char strSeqNum[3];
	 char ReadIP[4];
	 char strSend[60];

     //STX
     uart(1, 1,0x01);
    99e6:	81 e0       	ldi	r24, 0x01	; 1
    99e8:	61 e0       	ldi	r22, 0x01	; 1
    99ea:	41 e0       	ldi	r20, 0x01	; 1
    99ec:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    99f0:	e1 99       	sbic	0x1c, 1	; 28
    99f2:	fe cf       	rjmp	.-4      	; 0x99f0 <IFTSendMessage+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    99f4:	80 e0       	ldi	r24, 0x00	; 0
    99f6:	90 e0       	ldi	r25, 0x00	; 0
    99f8:	9f bb       	out	0x1f, r25	; 31
    99fa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    99fc:	e0 9a       	sbi	0x1c, 0	; 28
    99fe:	8d b3       	in	r24, 0x1d	; 29
	 //[IFTID]
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strSend,PSTR("%.2d"),IdIFT);
    9a00:	00 d0       	rcall	.+0      	; 0x9a02 <IFTSendMessage+0x42>
    9a02:	00 d0       	rcall	.+0      	; 0x9a04 <IFTSendMessage+0x44>
    9a04:	00 d0       	rcall	.+0      	; 0x9a06 <IFTSendMessage+0x46>
    9a06:	ed b7       	in	r30, 0x3d	; 61
    9a08:	fe b7       	in	r31, 0x3e	; 62
    9a0a:	31 96       	adiw	r30, 0x01	; 1
    9a0c:	95 e0       	ldi	r25, 0x05	; 5
    9a0e:	c9 2e       	mov	r12, r25
    9a10:	d1 2c       	mov	r13, r1
    9a12:	cc 0e       	add	r12, r28
    9a14:	dd 1e       	adc	r13, r29
    9a16:	ad b7       	in	r26, 0x3d	; 61
    9a18:	be b7       	in	r27, 0x3e	; 62
    9a1a:	12 96       	adiw	r26, 0x02	; 2
    9a1c:	dc 92       	st	X, r13
    9a1e:	ce 92       	st	-X, r12
    9a20:	11 97       	sbiw	r26, 0x01	; 1
    9a22:	2c e2       	ldi	r18, 0x2C	; 44
    9a24:	32 e2       	ldi	r19, 0x22	; 34
    9a26:	33 83       	std	Z+3, r19	; 0x03
    9a28:	22 83       	std	Z+2, r18	; 0x02
    9a2a:	64 e6       	ldi	r22, 0x64	; 100
    9a2c:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
    9a30:	94 83       	std	Z+4, r25	; 0x04
    9a32:	15 82       	std	Z+5, r1	; 0x05
    9a34:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 uart_print(1, 0,strSend);
    9a38:	8d b7       	in	r24, 0x3d	; 61
    9a3a:	9e b7       	in	r25, 0x3e	; 62
    9a3c:	06 96       	adiw	r24, 0x06	; 6
    9a3e:	0f b6       	in	r0, 0x3f	; 63
    9a40:	f8 94       	cli
    9a42:	9e bf       	out	0x3e, r25	; 62
    9a44:	0f be       	out	0x3f, r0	; 63
    9a46:	8d bf       	out	0x3d, r24	; 61
    9a48:	81 e0       	ldi	r24, 0x01	; 1
    9a4a:	60 e0       	ldi	r22, 0x00	; 0
    9a4c:	a6 01       	movw	r20, r12
    9a4e:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
     //[Seq]
	 SeqNum=((SeqNum+1)%100);
    9a52:	80 91 b0 01 	lds	r24, 0x01B0
    9a56:	90 e0       	ldi	r25, 0x00	; 0
    9a58:	01 96       	adiw	r24, 0x01	; 1
    9a5a:	64 e6       	ldi	r22, 0x64	; 100
    9a5c:	70 e0       	ldi	r23, 0x00	; 0
    9a5e:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    9a62:	80 93 b0 01 	sts	0x01B0, r24
	 sprintf_P(strSend,PSTR("%.2d"),SeqNum);	 
    9a66:	00 d0       	rcall	.+0      	; 0x9a68 <IFTSendMessage+0xa8>
    9a68:	00 d0       	rcall	.+0      	; 0x9a6a <IFTSendMessage+0xaa>
    9a6a:	00 d0       	rcall	.+0      	; 0x9a6c <IFTSendMessage+0xac>
    9a6c:	ed b7       	in	r30, 0x3d	; 61
    9a6e:	fe b7       	in	r31, 0x3e	; 62
    9a70:	31 96       	adiw	r30, 0x01	; 1
    9a72:	ad b7       	in	r26, 0x3d	; 61
    9a74:	be b7       	in	r27, 0x3e	; 62
    9a76:	12 96       	adiw	r26, 0x02	; 2
    9a78:	dc 92       	st	X, r13
    9a7a:	ce 92       	st	-X, r12
    9a7c:	11 97       	sbiw	r26, 0x01	; 1
    9a7e:	27 e2       	ldi	r18, 0x27	; 39
    9a80:	32 e2       	ldi	r19, 0x22	; 34
    9a82:	33 83       	std	Z+3, r19	; 0x03
    9a84:	22 83       	std	Z+2, r18	; 0x02
    9a86:	84 83       	std	Z+4, r24	; 0x04
    9a88:	15 82       	std	Z+5, r1	; 0x05
    9a8a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 uart_print(1, 0,strSend);
    9a8e:	8d b7       	in	r24, 0x3d	; 61
    9a90:	9e b7       	in	r25, 0x3e	; 62
    9a92:	06 96       	adiw	r24, 0x06	; 6
    9a94:	0f b6       	in	r0, 0x3f	; 63
    9a96:	f8 94       	cli
    9a98:	9e bf       	out	0x3e, r25	; 62
    9a9a:	0f be       	out	0x3f, r0	; 63
    9a9c:	8d bf       	out	0x3d, r24	; 61
    9a9e:	81 e0       	ldi	r24, 0x01	; 1
    9aa0:	60 e0       	ldi	r22, 0x00	; 0
    9aa2:	a6 01       	movw	r20, r12
    9aa4:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9aa8:	7e 01       	movw	r14, r28
    9aaa:	08 94       	sec
    9aac:	e1 1c       	adc	r14, r1
    9aae:	f1 1c       	adc	r15, r1
    9ab0:	c7 01       	movw	r24, r14
    9ab2:	68 e2       	ldi	r22, 0x28	; 40
    9ab4:	70 e0       	ldi	r23, 0x00	; 0
    9ab6:	44 e0       	ldi	r20, 0x04	; 4
    9ab8:	50 e0       	ldi	r21, 0x00	; 0
    9aba:	22 e4       	ldi	r18, 0x42	; 66
    9abc:	33 e1       	ldi	r19, 0x13	; 19
    9abe:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	 //[ClientIP]
     eeprom_read_block((void*)&ReadIP,(const void*)&DefClientIP,4);
	 sprintf_P(strSend,PSTR("%.3d.%.3d.%.3d.%.3d"),ReadIP[0],ReadIP[1],ReadIP[2],ReadIP[3]);
    9ac2:	ad b7       	in	r26, 0x3d	; 61
    9ac4:	be b7       	in	r27, 0x3e	; 62
    9ac6:	1c 97       	sbiw	r26, 0x0c	; 12
    9ac8:	0f b6       	in	r0, 0x3f	; 63
    9aca:	f8 94       	cli
    9acc:	be bf       	out	0x3e, r27	; 62
    9ace:	0f be       	out	0x3f, r0	; 63
    9ad0:	ad bf       	out	0x3d, r26	; 61
    9ad2:	ed b7       	in	r30, 0x3d	; 61
    9ad4:	fe b7       	in	r31, 0x3e	; 62
    9ad6:	31 96       	adiw	r30, 0x01	; 1
    9ad8:	12 96       	adiw	r26, 0x02	; 2
    9ada:	dc 92       	st	X, r13
    9adc:	ce 92       	st	-X, r12
    9ade:	11 97       	sbiw	r26, 0x01	; 1
    9ae0:	83 e1       	ldi	r24, 0x13	; 19
    9ae2:	92 e2       	ldi	r25, 0x22	; 34
    9ae4:	93 83       	std	Z+3, r25	; 0x03
    9ae6:	82 83       	std	Z+2, r24	; 0x02
    9ae8:	89 81       	ldd	r24, Y+1	; 0x01
    9aea:	84 83       	std	Z+4, r24	; 0x04
    9aec:	15 82       	std	Z+5, r1	; 0x05
    9aee:	8a 81       	ldd	r24, Y+2	; 0x02
    9af0:	86 83       	std	Z+6, r24	; 0x06
    9af2:	17 82       	std	Z+7, r1	; 0x07
    9af4:	8b 81       	ldd	r24, Y+3	; 0x03
    9af6:	80 87       	std	Z+8, r24	; 0x08
    9af8:	11 86       	std	Z+9, r1	; 0x09
    9afa:	8c 81       	ldd	r24, Y+4	; 0x04
    9afc:	82 87       	std	Z+10, r24	; 0x0a
    9afe:	13 86       	std	Z+11, r1	; 0x0b
    9b00:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 uart_print(1, 0,strSend);
    9b04:	8d b7       	in	r24, 0x3d	; 61
    9b06:	9e b7       	in	r25, 0x3e	; 62
    9b08:	0c 96       	adiw	r24, 0x0c	; 12
    9b0a:	0f b6       	in	r0, 0x3f	; 63
    9b0c:	f8 94       	cli
    9b0e:	9e bf       	out	0x3e, r25	; 62
    9b10:	0f be       	out	0x3f, r0	; 63
    9b12:	8d bf       	out	0x3d, r24	; 61
    9b14:	81 e0       	ldi	r24, 0x01	; 1
    9b16:	60 e0       	ldi	r22, 0x00	; 0
    9b18:	a6 01       	movw	r20, r12
    9b1a:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
    9b1e:	c7 01       	movw	r24, r14
    9b20:	6c e2       	ldi	r22, 0x2C	; 44
    9b22:	70 e0       	ldi	r23, 0x00	; 0
    9b24:	44 e0       	ldi	r20, 0x04	; 4
    9b26:	50 e0       	ldi	r21, 0x00	; 0
    9b28:	22 e4       	ldi	r18, 0x42	; 66
    9b2a:	33 e1       	ldi	r19, 0x13	; 19
    9b2c:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	 //[ServerIP]
     eeprom_read_block((void*)&ReadIP,(const void*)&DefServerIP,4);
	 sprintf_P(strSend,PSTR("%.3d.%.3d.%.3d.%.3d"),ReadIP[0],ReadIP[1],ReadIP[2],ReadIP[3]);
    9b30:	ad b7       	in	r26, 0x3d	; 61
    9b32:	be b7       	in	r27, 0x3e	; 62
    9b34:	1c 97       	sbiw	r26, 0x0c	; 12
    9b36:	0f b6       	in	r0, 0x3f	; 63
    9b38:	f8 94       	cli
    9b3a:	be bf       	out	0x3e, r27	; 62
    9b3c:	0f be       	out	0x3f, r0	; 63
    9b3e:	ad bf       	out	0x3d, r26	; 61
    9b40:	ed b7       	in	r30, 0x3d	; 61
    9b42:	fe b7       	in	r31, 0x3e	; 62
    9b44:	31 96       	adiw	r30, 0x01	; 1
    9b46:	12 96       	adiw	r26, 0x02	; 2
    9b48:	dc 92       	st	X, r13
    9b4a:	ce 92       	st	-X, r12
    9b4c:	11 97       	sbiw	r26, 0x01	; 1
    9b4e:	8f ef       	ldi	r24, 0xFF	; 255
    9b50:	91 e2       	ldi	r25, 0x21	; 33
    9b52:	93 83       	std	Z+3, r25	; 0x03
    9b54:	82 83       	std	Z+2, r24	; 0x02
    9b56:	89 81       	ldd	r24, Y+1	; 0x01
    9b58:	84 83       	std	Z+4, r24	; 0x04
    9b5a:	15 82       	std	Z+5, r1	; 0x05
    9b5c:	8a 81       	ldd	r24, Y+2	; 0x02
    9b5e:	86 83       	std	Z+6, r24	; 0x06
    9b60:	17 82       	std	Z+7, r1	; 0x07
    9b62:	8b 81       	ldd	r24, Y+3	; 0x03
    9b64:	80 87       	std	Z+8, r24	; 0x08
    9b66:	11 86       	std	Z+9, r1	; 0x09
    9b68:	8c 81       	ldd	r24, Y+4	; 0x04
    9b6a:	82 87       	std	Z+10, r24	; 0x0a
    9b6c:	13 86       	std	Z+11, r1	; 0x0b
    9b6e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 uart_print(1, 0,strSend);
    9b72:	8d b7       	in	r24, 0x3d	; 61
    9b74:	9e b7       	in	r25, 0x3e	; 62
    9b76:	0c 96       	adiw	r24, 0x0c	; 12
    9b78:	0f b6       	in	r0, 0x3f	; 63
    9b7a:	f8 94       	cli
    9b7c:	9e bf       	out	0x3e, r25	; 62
    9b7e:	0f be       	out	0x3f, r0	; 63
    9b80:	8d bf       	out	0x3d, r24	; 61
    9b82:	81 e0       	ldi	r24, 0x01	; 1
    9b84:	60 e0       	ldi	r22, 0x00	; 0
    9b86:	a6 01       	movw	r20, r12
    9b88:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
	 //[MsgCode]
	 sprintf_P(strSend,PSTR("%.2X"),MsgCode);	 
    9b8c:	00 d0       	rcall	.+0      	; 0x9b8e <IFTSendMessage+0x1ce>
    9b8e:	00 d0       	rcall	.+0      	; 0x9b90 <IFTSendMessage+0x1d0>
    9b90:	00 d0       	rcall	.+0      	; 0x9b92 <IFTSendMessage+0x1d2>
    9b92:	ed b7       	in	r30, 0x3d	; 61
    9b94:	fe b7       	in	r31, 0x3e	; 62
    9b96:	31 96       	adiw	r30, 0x01	; 1
    9b98:	ad b7       	in	r26, 0x3d	; 61
    9b9a:	be b7       	in	r27, 0x3e	; 62
    9b9c:	12 96       	adiw	r26, 0x02	; 2
    9b9e:	dc 92       	st	X, r13
    9ba0:	ce 92       	st	-X, r12
    9ba2:	11 97       	sbiw	r26, 0x01	; 1
    9ba4:	8a ef       	ldi	r24, 0xFA	; 250
    9ba6:	91 e2       	ldi	r25, 0x21	; 33
    9ba8:	93 83       	std	Z+3, r25	; 0x03
    9baa:	82 83       	std	Z+2, r24	; 0x02
    9bac:	04 83       	std	Z+4, r16	; 0x04
    9bae:	15 82       	std	Z+5, r1	; 0x05
    9bb0:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 uart_print(1, 0,strSend);
    9bb4:	8d b7       	in	r24, 0x3d	; 61
    9bb6:	9e b7       	in	r25, 0x3e	; 62
    9bb8:	06 96       	adiw	r24, 0x06	; 6
    9bba:	0f b6       	in	r0, 0x3f	; 63
    9bbc:	f8 94       	cli
    9bbe:	9e bf       	out	0x3e, r25	; 62
    9bc0:	0f be       	out	0x3f, r0	; 63
    9bc2:	8d bf       	out	0x3d, r24	; 61
    9bc4:	81 e0       	ldi	r24, 0x01	; 1
    9bc6:	60 e0       	ldi	r22, 0x00	; 0
    9bc8:	a6 01       	movw	r20, r12
    9bca:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>

     switch(MsgCode){
    9bce:	02 33       	cpi	r16, 0x32	; 50
    9bd0:	09 f4       	brne	.+2      	; 0x9bd4 <IFTSendMessage+0x214>
    9bd2:	7f c0       	rjmp	.+254    	; 0x9cd2 <IFTSendMessage+0x312>
    9bd4:	03 33       	cpi	r16, 0x33	; 51
    9bd6:	70 f4       	brcc	.+28     	; 0x9bf4 <IFTSendMessage+0x234>
    9bd8:	02 32       	cpi	r16, 0x22	; 34
    9bda:	91 f1       	breq	.+100    	; 0x9c40 <IFTSendMessage+0x280>
    9bdc:	03 32       	cpi	r16, 0x23	; 35
    9bde:	20 f4       	brcc	.+8      	; 0x9be8 <IFTSendMessage+0x228>
    9be0:	04 30       	cpi	r16, 0x04	; 4
    9be2:	09 f0       	breq	.+2      	; 0x9be6 <IFTSendMessage+0x226>
    9be4:	1d c2       	rjmp	.+1082   	; 0xa020 <IFTSendMessage+0x660>
    9be6:	19 c0       	rjmp	.+50     	; 0x9c1a <IFTSendMessage+0x25a>
    9be8:	04 32       	cpi	r16, 0x24	; 36
    9bea:	d9 f1       	breq	.+118    	; 0x9c62 <IFTSendMessage+0x2a2>
    9bec:	08 32       	cpi	r16, 0x28	; 40
    9bee:	09 f0       	breq	.+2      	; 0x9bf2 <IFTSendMessage+0x232>
    9bf0:	17 c2       	rjmp	.+1070   	; 0xa020 <IFTSendMessage+0x660>
    9bf2:	53 c0       	rjmp	.+166    	; 0x9c9a <IFTSendMessage+0x2da>
    9bf4:	00 39       	cpi	r16, 0x90	; 144
    9bf6:	09 f4       	brne	.+2      	; 0x9bfa <IFTSendMessage+0x23a>
    9bf8:	78 c1       	rjmp	.+752    	; 0x9eea <IFTSendMessage+0x52a>
    9bfa:	01 39       	cpi	r16, 0x91	; 145
    9bfc:	38 f4       	brcc	.+14     	; 0x9c0c <IFTSendMessage+0x24c>
    9bfe:	06 35       	cpi	r16, 0x56	; 86
    9c00:	09 f4       	brne	.+2      	; 0x9c04 <IFTSendMessage+0x244>
    9c02:	d7 c0       	rjmp	.+430    	; 0x9db2 <IFTSendMessage+0x3f2>
    9c04:	08 35       	cpi	r16, 0x58	; 88
    9c06:	09 f0       	breq	.+2      	; 0x9c0a <IFTSendMessage+0x24a>
    9c08:	0b c2       	rjmp	.+1046   	; 0xa020 <IFTSendMessage+0x660>
    9c0a:	e8 c0       	rjmp	.+464    	; 0x9ddc <IFTSendMessage+0x41c>
    9c0c:	02 39       	cpi	r16, 0x92	; 146
    9c0e:	09 f4       	brne	.+2      	; 0x9c12 <IFTSendMessage+0x252>
    9c10:	8d c1       	rjmp	.+794    	; 0x9f2c <IFTSendMessage+0x56c>
    9c12:	08 39       	cpi	r16, 0x98	; 152
    9c14:	09 f0       	breq	.+2      	; 0x9c18 <IFTSendMessage+0x258>
    9c16:	04 c2       	rjmp	.+1032   	; 0xa020 <IFTSendMessage+0x660>
    9c18:	e0 c1       	rjmp	.+960    	; 0x9fda <IFTSendMessage+0x61a>
	 case MSG_04://Transaction Number
	      sprintf_P(strSend,PSTR("%s"),strTranNo);
    9c1a:	00 d0       	rcall	.+0      	; 0x9c1c <IFTSendMessage+0x25c>
    9c1c:	00 d0       	rcall	.+0      	; 0x9c1e <IFTSendMessage+0x25e>
    9c1e:	00 d0       	rcall	.+0      	; 0x9c20 <IFTSendMessage+0x260>
    9c20:	ed b7       	in	r30, 0x3d	; 61
    9c22:	fe b7       	in	r31, 0x3e	; 62
    9c24:	31 96       	adiw	r30, 0x01	; 1
    9c26:	ad b7       	in	r26, 0x3d	; 61
    9c28:	be b7       	in	r27, 0x3e	; 62
    9c2a:	12 96       	adiw	r26, 0x02	; 2
    9c2c:	dc 92       	st	X, r13
    9c2e:	ce 92       	st	-X, r12
    9c30:	11 97       	sbiw	r26, 0x01	; 1
    9c32:	87 ef       	ldi	r24, 0xF7	; 247
    9c34:	91 e2       	ldi	r25, 0x21	; 33
    9c36:	93 83       	std	Z+3, r25	; 0x03
    9c38:	82 83       	std	Z+2, r24	; 0x02
    9c3a:	80 ea       	ldi	r24, 0xA0	; 160
    9c3c:	9e e0       	ldi	r25, 0x0E	; 14
    9c3e:	df c1       	rjmp	.+958    	; 0x9ffe <IFTSendMessage+0x63e>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_10://No Additional Parameter
	      break;
	 case MSG_22://strCardID
	      UpdateCardID();
    9c40:	0e 94 45 45 	call	0x8a8a	; 0x8a8a <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s"),strCardID);
    9c44:	00 d0       	rcall	.+0      	; 0x9c46 <IFTSendMessage+0x286>
    9c46:	00 d0       	rcall	.+0      	; 0x9c48 <IFTSendMessage+0x288>
    9c48:	00 d0       	rcall	.+0      	; 0x9c4a <IFTSendMessage+0x28a>
    9c4a:	ed b7       	in	r30, 0x3d	; 61
    9c4c:	fe b7       	in	r31, 0x3e	; 62
    9c4e:	31 96       	adiw	r30, 0x01	; 1
    9c50:	ad b7       	in	r26, 0x3d	; 61
    9c52:	be b7       	in	r27, 0x3e	; 62
    9c54:	12 96       	adiw	r26, 0x02	; 2
    9c56:	dc 92       	st	X, r13
    9c58:	ce 92       	st	-X, r12
    9c5a:	11 97       	sbiw	r26, 0x01	; 1
    9c5c:	84 ef       	ldi	r24, 0xF4	; 244
    9c5e:	91 e2       	ldi	r25, 0x21	; 33
    9c60:	b8 c0       	rjmp	.+368    	; 0x9dd2 <IFTSendMessage+0x412>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_24://strCardID, FIP_ID
	      UpdateCardID();
    9c62:	0e 94 45 45 	call	0x8a8a	; 0x8a8a <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strCardID,strFIP_ID);
    9c66:	ad b7       	in	r26, 0x3d	; 61
    9c68:	be b7       	in	r27, 0x3e	; 62
    9c6a:	18 97       	sbiw	r26, 0x08	; 8
    9c6c:	0f b6       	in	r0, 0x3f	; 63
    9c6e:	f8 94       	cli
    9c70:	be bf       	out	0x3e, r27	; 62
    9c72:	0f be       	out	0x3f, r0	; 63
    9c74:	ad bf       	out	0x3d, r26	; 61
    9c76:	ed b7       	in	r30, 0x3d	; 61
    9c78:	fe b7       	in	r31, 0x3e	; 62
    9c7a:	31 96       	adiw	r30, 0x01	; 1
    9c7c:	12 96       	adiw	r26, 0x02	; 2
    9c7e:	dc 92       	st	X, r13
    9c80:	ce 92       	st	-X, r12
    9c82:	11 97       	sbiw	r26, 0x01	; 1
    9c84:	8f ee       	ldi	r24, 0xEF	; 239
    9c86:	91 e2       	ldi	r25, 0x21	; 33
    9c88:	93 83       	std	Z+3, r25	; 0x03
    9c8a:	82 83       	std	Z+2, r24	; 0x02
    9c8c:	82 e9       	ldi	r24, 0x92	; 146
    9c8e:	9d e0       	ldi	r25, 0x0D	; 13
    9c90:	95 83       	std	Z+5, r25	; 0x05
    9c92:	84 83       	std	Z+4, r24	; 0x04
    9c94:	82 ec       	ldi	r24, 0xC2	; 194
    9c96:	97 e0       	ldi	r25, 0x07	; 7
    9c98:	41 c1       	rjmp	.+642    	; 0x9f1c <IFTSendMessage+0x55c>
	      uart_print(1, 0,strSend);
	      break;

	 case MSG_28://strCardID, FIP_ID
	      UpdateCardID();
    9c9a:	0e 94 45 45 	call	0x8a8a	; 0x8a8a <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strCardID);
    9c9e:	ad b7       	in	r26, 0x3d	; 61
    9ca0:	be b7       	in	r27, 0x3e	; 62
    9ca2:	18 97       	sbiw	r26, 0x08	; 8
    9ca4:	0f b6       	in	r0, 0x3f	; 63
    9ca6:	f8 94       	cli
    9ca8:	be bf       	out	0x3e, r27	; 62
    9caa:	0f be       	out	0x3f, r0	; 63
    9cac:	ad bf       	out	0x3d, r26	; 61
    9cae:	ed b7       	in	r30, 0x3d	; 61
    9cb0:	fe b7       	in	r31, 0x3e	; 62
    9cb2:	31 96       	adiw	r30, 0x01	; 1
    9cb4:	12 96       	adiw	r26, 0x02	; 2
    9cb6:	dc 92       	st	X, r13
    9cb8:	ce 92       	st	-X, r12
    9cba:	11 97       	sbiw	r26, 0x01	; 1
    9cbc:	8a ee       	ldi	r24, 0xEA	; 234
    9cbe:	91 e2       	ldi	r25, 0x21	; 33
    9cc0:	93 83       	std	Z+3, r25	; 0x03
    9cc2:	82 83       	std	Z+2, r24	; 0x02
    9cc4:	82 ec       	ldi	r24, 0xC2	; 194
    9cc6:	97 e0       	ldi	r25, 0x07	; 7
    9cc8:	95 83       	std	Z+5, r25	; 0x05
    9cca:	84 83       	std	Z+4, r24	; 0x04
    9ccc:	82 e9       	ldi	r24, 0x92	; 146
    9cce:	9d e0       	ldi	r25, 0x0D	; 13
    9cd0:	25 c1       	rjmp	.+586    	; 0x9f1c <IFTSendMessage+0x55c>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_32://Change MOP
	      UpdateCardID();
    9cd2:	0e 94 45 45 	call	0x8a8a	; 0x8a8a <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strPaymentType);
    9cd6:	ad b7       	in	r26, 0x3d	; 61
    9cd8:	be b7       	in	r27, 0x3e	; 62
    9cda:	18 97       	sbiw	r26, 0x08	; 8
    9cdc:	0f b6       	in	r0, 0x3f	; 63
    9cde:	f8 94       	cli
    9ce0:	be bf       	out	0x3e, r27	; 62
    9ce2:	0f be       	out	0x3f, r0	; 63
    9ce4:	ad bf       	out	0x3d, r26	; 61
    9ce6:	ed b7       	in	r30, 0x3d	; 61
    9ce8:	fe b7       	in	r31, 0x3e	; 62
    9cea:	31 96       	adiw	r30, 0x01	; 1
    9cec:	12 96       	adiw	r26, 0x02	; 2
    9cee:	dc 92       	st	X, r13
    9cf0:	ce 92       	st	-X, r12
    9cf2:	11 97       	sbiw	r26, 0x01	; 1
    9cf4:	85 ee       	ldi	r24, 0xE5	; 229
    9cf6:	91 e2       	ldi	r25, 0x21	; 33
    9cf8:	93 83       	std	Z+3, r25	; 0x03
    9cfa:	82 83       	std	Z+2, r24	; 0x02
    9cfc:	82 ec       	ldi	r24, 0xC2	; 194
    9cfe:	97 e0       	ldi	r25, 0x07	; 7
    9d00:	95 83       	std	Z+5, r25	; 0x05
    9d02:	84 83       	std	Z+4, r24	; 0x04
    9d04:	89 e5       	ldi	r24, 0x59	; 89
    9d06:	97 e0       	ldi	r25, 0x07	; 7
    9d08:	97 83       	std	Z+7, r25	; 0x07
    9d0a:	86 83       	std	Z+6, r24	; 0x06
    9d0c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	      uart_print(1,0,strSend);
    9d10:	8d b7       	in	r24, 0x3d	; 61
    9d12:	9e b7       	in	r25, 0x3e	; 62
    9d14:	08 96       	adiw	r24, 0x08	; 8
    9d16:	0f b6       	in	r0, 0x3f	; 63
    9d18:	f8 94       	cli
    9d1a:	9e bf       	out	0x3e, r25	; 62
    9d1c:	0f be       	out	0x3f, r0	; 63
    9d1e:	8d bf       	out	0x3d, r24	; 61
    9d20:	81 e0       	ldi	r24, 0x01	; 1
    9d22:	60 e0       	ldi	r22, 0x00	; 0
    9d24:	a6 01       	movw	r20, r12
    9d26:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
		  sprintf_P(strSend,PSTR("%s%s"),strRef1,strRef2);
    9d2a:	ad b7       	in	r26, 0x3d	; 61
    9d2c:	be b7       	in	r27, 0x3e	; 62
    9d2e:	18 97       	sbiw	r26, 0x08	; 8
    9d30:	0f b6       	in	r0, 0x3f	; 63
    9d32:	f8 94       	cli
    9d34:	be bf       	out	0x3e, r27	; 62
    9d36:	0f be       	out	0x3f, r0	; 63
    9d38:	ad bf       	out	0x3d, r26	; 61
    9d3a:	ed b7       	in	r30, 0x3d	; 61
    9d3c:	fe b7       	in	r31, 0x3e	; 62
    9d3e:	31 96       	adiw	r30, 0x01	; 1
    9d40:	12 96       	adiw	r26, 0x02	; 2
    9d42:	dc 92       	st	X, r13
    9d44:	ce 92       	st	-X, r12
    9d46:	11 97       	sbiw	r26, 0x01	; 1
    9d48:	80 ee       	ldi	r24, 0xE0	; 224
    9d4a:	91 e2       	ldi	r25, 0x21	; 33
    9d4c:	93 83       	std	Z+3, r25	; 0x03
    9d4e:	82 83       	std	Z+2, r24	; 0x02
    9d50:	87 ea       	ldi	r24, 0xA7	; 167
    9d52:	9e e0       	ldi	r25, 0x0E	; 14
    9d54:	95 83       	std	Z+5, r25	; 0x05
    9d56:	84 83       	std	Z+4, r24	; 0x04
    9d58:	87 ea       	ldi	r24, 0xA7	; 167
    9d5a:	9d e0       	ldi	r25, 0x0D	; 13
    9d5c:	97 83       	std	Z+7, r25	; 0x07
    9d5e:	86 83       	std	Z+6, r24	; 0x06
    9d60:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  uart_print(1,0,strSend);
    9d64:	8d b7       	in	r24, 0x3d	; 61
    9d66:	9e b7       	in	r25, 0x3e	; 62
    9d68:	08 96       	adiw	r24, 0x08	; 8
    9d6a:	0f b6       	in	r0, 0x3f	; 63
    9d6c:	f8 94       	cli
    9d6e:	9e bf       	out	0x3e, r25	; 62
    9d70:	0f be       	out	0x3f, r0	; 63
    9d72:	8d bf       	out	0x3d, r24	; 61
    9d74:	81 e0       	ldi	r24, 0x01	; 1
    9d76:	60 e0       	ldi	r22, 0x00	; 0
    9d78:	a6 01       	movw	r20, r12
    9d7a:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
		  sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    9d7e:	ad b7       	in	r26, 0x3d	; 61
    9d80:	be b7       	in	r27, 0x3e	; 62
    9d82:	18 97       	sbiw	r26, 0x08	; 8
    9d84:	0f b6       	in	r0, 0x3f	; 63
    9d86:	f8 94       	cli
    9d88:	be bf       	out	0x3e, r27	; 62
    9d8a:	0f be       	out	0x3f, r0	; 63
    9d8c:	ad bf       	out	0x3d, r26	; 61
    9d8e:	ed b7       	in	r30, 0x3d	; 61
    9d90:	fe b7       	in	r31, 0x3e	; 62
    9d92:	31 96       	adiw	r30, 0x01	; 1
    9d94:	12 96       	adiw	r26, 0x02	; 2
    9d96:	dc 92       	st	X, r13
    9d98:	ce 92       	st	-X, r12
    9d9a:	11 97       	sbiw	r26, 0x01	; 1
    9d9c:	8b ed       	ldi	r24, 0xDB	; 219
    9d9e:	91 e2       	ldi	r25, 0x21	; 33
    9da0:	93 83       	std	Z+3, r25	; 0x03
    9da2:	82 83       	std	Z+2, r24	; 0x02
    9da4:	86 e8       	ldi	r24, 0x86	; 134
    9da6:	98 e0       	ldi	r25, 0x08	; 8
    9da8:	95 83       	std	Z+5, r25	; 0x05
    9daa:	84 83       	std	Z+4, r24	; 0x04
    9dac:	8e ea       	ldi	r24, 0xAE	; 174
    9dae:	93 e0       	ldi	r25, 0x03	; 3
    9db0:	b5 c0       	rjmp	.+362    	; 0x9f1c <IFTSendMessage+0x55c>
		  uart_print(1,0,strSend);
	      break;

	 case MSG_56://strCardID, FIP_ID
	      UpdateCardID();
    9db2:	0e 94 45 45 	call	0x8a8a	; 0x8a8a <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s"),strCardID);
    9db6:	00 d0       	rcall	.+0      	; 0x9db8 <IFTSendMessage+0x3f8>
    9db8:	00 d0       	rcall	.+0      	; 0x9dba <IFTSendMessage+0x3fa>
    9dba:	00 d0       	rcall	.+0      	; 0x9dbc <IFTSendMessage+0x3fc>
    9dbc:	ed b7       	in	r30, 0x3d	; 61
    9dbe:	fe b7       	in	r31, 0x3e	; 62
    9dc0:	31 96       	adiw	r30, 0x01	; 1
    9dc2:	ad b7       	in	r26, 0x3d	; 61
    9dc4:	be b7       	in	r27, 0x3e	; 62
    9dc6:	12 96       	adiw	r26, 0x02	; 2
    9dc8:	dc 92       	st	X, r13
    9dca:	ce 92       	st	-X, r12
    9dcc:	11 97       	sbiw	r26, 0x01	; 1
    9dce:	88 ed       	ldi	r24, 0xD8	; 216
    9dd0:	91 e2       	ldi	r25, 0x21	; 33
    9dd2:	93 83       	std	Z+3, r25	; 0x03
    9dd4:	82 83       	std	Z+2, r24	; 0x02
    9dd6:	82 e9       	ldi	r24, 0x92	; 146
    9dd8:	9d e0       	ldi	r25, 0x0D	; 13
    9dda:	11 c1       	rjmp	.+546    	; 0x9ffe <IFTSendMessage+0x63e>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_58://Request Local Account Transaction
	      UpdateCardID();
    9ddc:	0e 94 45 45 	call	0x8a8a	; 0x8a8a <UpdateCardID>
		  AddSpaceLead(strBalanceValue,13);
    9de0:	80 e3       	ldi	r24, 0x30	; 48
    9de2:	a8 2e       	mov	r10, r24
    9de4:	8e e0       	ldi	r24, 0x0E	; 14
    9de6:	b8 2e       	mov	r11, r24
    9de8:	c5 01       	movw	r24, r10
    9dea:	6d e0       	ldi	r22, 0x0D	; 13
    9dec:	0e 94 b7 30 	call	0x616e	; 0x616e <AddSpaceLead>
		  AddSpaceLead(strOdometer,10);
    9df0:	0c ec       	ldi	r16, 0xCC	; 204
    9df2:	e0 2e       	mov	r14, r16
    9df4:	03 e0       	ldi	r16, 0x03	; 3
    9df6:	f0 2e       	mov	r15, r16
    9df8:	c7 01       	movw	r24, r14
    9dfa:	6a e0       	ldi	r22, 0x0A	; 10
    9dfc:	0e 94 b7 30 	call	0x616e	; 0x616e <AddSpaceLead>
		  CardType=0;
    9e00:	10 92 92 03 	sts	0x0392, r1
		  sprintf_P(strSend,PSTR("%s%s%d"),strCardID,strFIP_ID,NozzleID);
    9e04:	ad b7       	in	r26, 0x3d	; 61
    9e06:	be b7       	in	r27, 0x3e	; 62
    9e08:	1a 97       	sbiw	r26, 0x0a	; 10
    9e0a:	0f b6       	in	r0, 0x3f	; 63
    9e0c:	f8 94       	cli
    9e0e:	be bf       	out	0x3e, r27	; 62
    9e10:	0f be       	out	0x3f, r0	; 63
    9e12:	ad bf       	out	0x3d, r26	; 61
    9e14:	ed b7       	in	r30, 0x3d	; 61
    9e16:	fe b7       	in	r31, 0x3e	; 62
    9e18:	31 96       	adiw	r30, 0x01	; 1
    9e1a:	12 96       	adiw	r26, 0x02	; 2
    9e1c:	dc 92       	st	X, r13
    9e1e:	ce 92       	st	-X, r12
    9e20:	11 97       	sbiw	r26, 0x01	; 1
    9e22:	81 ed       	ldi	r24, 0xD1	; 209
    9e24:	91 e2       	ldi	r25, 0x21	; 33
    9e26:	93 83       	std	Z+3, r25	; 0x03
    9e28:	82 83       	std	Z+2, r24	; 0x02
    9e2a:	82 e9       	ldi	r24, 0x92	; 146
    9e2c:	9d e0       	ldi	r25, 0x0D	; 13
    9e2e:	95 83       	std	Z+5, r25	; 0x05
    9e30:	84 83       	std	Z+4, r24	; 0x04
    9e32:	82 ec       	ldi	r24, 0xC2	; 194
    9e34:	97 e0       	ldi	r25, 0x07	; 7
    9e36:	97 83       	std	Z+7, r25	; 0x07
    9e38:	86 83       	std	Z+6, r24	; 0x06
    9e3a:	80 91 76 07 	lds	r24, 0x0776
    9e3e:	80 87       	std	Z+8, r24	; 0x08
    9e40:	11 86       	std	Z+9, r1	; 0x09
    9e42:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  uart_print(1,0,strSend);
    9e46:	8d b7       	in	r24, 0x3d	; 61
    9e48:	9e b7       	in	r25, 0x3e	; 62
    9e4a:	0a 96       	adiw	r24, 0x0a	; 10
    9e4c:	0f b6       	in	r0, 0x3f	; 63
    9e4e:	f8 94       	cli
    9e50:	9e bf       	out	0x3e, r25	; 62
    9e52:	0f be       	out	0x3f, r0	; 63
    9e54:	8d bf       	out	0x3d, r24	; 61
    9e56:	81 e0       	ldi	r24, 0x01	; 1
    9e58:	60 e0       	ldi	r22, 0x00	; 0
    9e5a:	a6 01       	movw	r20, r12
    9e5c:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
		  sprintf_P(strSend,PSTR("%s%s%d"),strBalanceType,strBalanceValue,CardType);
    9e60:	ad b7       	in	r26, 0x3d	; 61
    9e62:	be b7       	in	r27, 0x3e	; 62
    9e64:	1a 97       	sbiw	r26, 0x0a	; 10
    9e66:	0f b6       	in	r0, 0x3f	; 63
    9e68:	f8 94       	cli
    9e6a:	be bf       	out	0x3e, r27	; 62
    9e6c:	0f be       	out	0x3f, r0	; 63
    9e6e:	ad bf       	out	0x3d, r26	; 61
    9e70:	ed b7       	in	r30, 0x3d	; 61
    9e72:	fe b7       	in	r31, 0x3e	; 62
    9e74:	31 96       	adiw	r30, 0x01	; 1
    9e76:	12 96       	adiw	r26, 0x02	; 2
    9e78:	dc 92       	st	X, r13
    9e7a:	ce 92       	st	-X, r12
    9e7c:	11 97       	sbiw	r26, 0x01	; 1
    9e7e:	8a ec       	ldi	r24, 0xCA	; 202
    9e80:	91 e2       	ldi	r25, 0x21	; 33
    9e82:	93 83       	std	Z+3, r25	; 0x03
    9e84:	82 83       	std	Z+2, r24	; 0x02
    9e86:	8c ea       	ldi	r24, 0xAC	; 172
    9e88:	93 e0       	ldi	r25, 0x03	; 3
    9e8a:	95 83       	std	Z+5, r25	; 0x05
    9e8c:	84 83       	std	Z+4, r24	; 0x04
    9e8e:	b7 82       	std	Z+7, r11	; 0x07
    9e90:	a6 82       	std	Z+6, r10	; 0x06
    9e92:	80 91 92 03 	lds	r24, 0x0392
    9e96:	80 87       	std	Z+8, r24	; 0x08
    9e98:	11 86       	std	Z+9, r1	; 0x09
    9e9a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  uart_print(1,0,strSend);
    9e9e:	8d b7       	in	r24, 0x3d	; 61
    9ea0:	9e b7       	in	r25, 0x3e	; 62
    9ea2:	0a 96       	adiw	r24, 0x0a	; 10
    9ea4:	0f b6       	in	r0, 0x3f	; 63
    9ea6:	f8 94       	cli
    9ea8:	9e bf       	out	0x3e, r25	; 62
    9eaa:	0f be       	out	0x3f, r0	; 63
    9eac:	8d bf       	out	0x3d, r24	; 61
    9eae:	81 e0       	ldi	r24, 0x01	; 1
    9eb0:	60 e0       	ldi	r22, 0x00	; 0
    9eb2:	a6 01       	movw	r20, r12
    9eb4:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
		  uart_printf(1,0,PSTR("F0000000E123456FFFFF"));
    9eb8:	81 e0       	ldi	r24, 0x01	; 1
    9eba:	60 e0       	ldi	r22, 0x00	; 0
    9ebc:	45 eb       	ldi	r20, 0xB5	; 181
    9ebe:	51 e2       	ldi	r21, 0x21	; 33
    9ec0:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
		  sprintf_P(strSend,PSTR("%s"),strOdometer);
    9ec4:	00 d0       	rcall	.+0      	; 0x9ec6 <IFTSendMessage+0x506>
    9ec6:	00 d0       	rcall	.+0      	; 0x9ec8 <IFTSendMessage+0x508>
    9ec8:	00 d0       	rcall	.+0      	; 0x9eca <IFTSendMessage+0x50a>
    9eca:	ed b7       	in	r30, 0x3d	; 61
    9ecc:	fe b7       	in	r31, 0x3e	; 62
    9ece:	31 96       	adiw	r30, 0x01	; 1
    9ed0:	ad b7       	in	r26, 0x3d	; 61
    9ed2:	be b7       	in	r27, 0x3e	; 62
    9ed4:	12 96       	adiw	r26, 0x02	; 2
    9ed6:	dc 92       	st	X, r13
    9ed8:	ce 92       	st	-X, r12
    9eda:	11 97       	sbiw	r26, 0x01	; 1
    9edc:	82 eb       	ldi	r24, 0xB2	; 178
    9ede:	91 e2       	ldi	r25, 0x21	; 33
    9ee0:	93 83       	std	Z+3, r25	; 0x03
    9ee2:	82 83       	std	Z+2, r24	; 0x02
    9ee4:	f5 82       	std	Z+5, r15	; 0x05
    9ee6:	e4 82       	std	Z+4, r14	; 0x04
    9ee8:	8c c0       	rjmp	.+280    	; 0xa002 <IFTSendMessage+0x642>
		  uart_print(1,0,strSend);
		  break;
	 case MSG_90://Request EDC
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    9eea:	ad b7       	in	r26, 0x3d	; 61
    9eec:	be b7       	in	r27, 0x3e	; 62
    9eee:	18 97       	sbiw	r26, 0x08	; 8
    9ef0:	0f b6       	in	r0, 0x3f	; 63
    9ef2:	f8 94       	cli
    9ef4:	be bf       	out	0x3e, r27	; 62
    9ef6:	0f be       	out	0x3f, r0	; 63
    9ef8:	ad bf       	out	0x3d, r26	; 61
    9efa:	ed b7       	in	r30, 0x3d	; 61
    9efc:	fe b7       	in	r31, 0x3e	; 62
    9efe:	31 96       	adiw	r30, 0x01	; 1
    9f00:	12 96       	adiw	r26, 0x02	; 2
    9f02:	dc 92       	st	X, r13
    9f04:	ce 92       	st	-X, r12
    9f06:	11 97       	sbiw	r26, 0x01	; 1
    9f08:	8d ea       	ldi	r24, 0xAD	; 173
    9f0a:	91 e2       	ldi	r25, 0x21	; 33
    9f0c:	93 83       	std	Z+3, r25	; 0x03
    9f0e:	82 83       	std	Z+2, r24	; 0x02
    9f10:	82 ec       	ldi	r24, 0xC2	; 194
    9f12:	97 e0       	ldi	r25, 0x07	; 7
    9f14:	95 83       	std	Z+5, r25	; 0x05
    9f16:	84 83       	std	Z+4, r24	; 0x04
    9f18:	87 ea       	ldi	r24, 0xA7	; 167
    9f1a:	9e e0       	ldi	r25, 0x0E	; 14
    9f1c:	97 83       	std	Z+7, r25	; 0x07
    9f1e:	86 83       	std	Z+6, r24	; 0x06
    9f20:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	      uart_print(1, 0,strSend);
    9f24:	8d b7       	in	r24, 0x3d	; 61
    9f26:	9e b7       	in	r25, 0x3e	; 62
    9f28:	08 96       	adiw	r24, 0x08	; 8
    9f2a:	70 c0       	rjmp	.+224    	; 0xa00c <IFTSendMessage+0x64c>
	      break;
	 case MSG_92://EDC Approval
		  sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    9f2c:	ad b7       	in	r26, 0x3d	; 61
    9f2e:	be b7       	in	r27, 0x3e	; 62
    9f30:	1c 97       	sbiw	r26, 0x0c	; 12
    9f32:	0f b6       	in	r0, 0x3f	; 63
    9f34:	f8 94       	cli
    9f36:	be bf       	out	0x3e, r27	; 62
    9f38:	0f be       	out	0x3f, r0	; 63
    9f3a:	ad bf       	out	0x3d, r26	; 61
    9f3c:	ed b7       	in	r30, 0x3d	; 61
    9f3e:	fe b7       	in	r31, 0x3e	; 62
    9f40:	31 96       	adiw	r30, 0x01	; 1
    9f42:	12 96       	adiw	r26, 0x02	; 2
    9f44:	dc 92       	st	X, r13
    9f46:	ce 92       	st	-X, r12
    9f48:	11 97       	sbiw	r26, 0x01	; 1
    9f4a:	84 ea       	ldi	r24, 0xA4	; 164
    9f4c:	91 e2       	ldi	r25, 0x21	; 33
    9f4e:	93 83       	std	Z+3, r25	; 0x03
    9f50:	82 83       	std	Z+2, r24	; 0x02
    9f52:	80 ea       	ldi	r24, 0xA0	; 160
    9f54:	9e e0       	ldi	r25, 0x0E	; 14
    9f56:	95 83       	std	Z+5, r25	; 0x05
    9f58:	84 83       	std	Z+4, r24	; 0x04
    9f5a:	82 ec       	ldi	r24, 0xC2	; 194
    9f5c:	97 e0       	ldi	r25, 0x07	; 7
    9f5e:	97 83       	std	Z+7, r25	; 0x07
    9f60:	86 83       	std	Z+6, r24	; 0x06
    9f62:	8c eb       	ldi	r24, 0xBC	; 188
    9f64:	9e e0       	ldi	r25, 0x0E	; 14
    9f66:	91 87       	std	Z+9, r25	; 0x09
    9f68:	80 87       	std	Z+8, r24	; 0x08
    9f6a:	82 e9       	ldi	r24, 0x92	; 146
    9f6c:	9d e0       	ldi	r25, 0x0D	; 13
    9f6e:	93 87       	std	Z+11, r25	; 0x0b
    9f70:	82 87       	std	Z+10, r24	; 0x0a
    9f72:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	      uart_print(1,0,strSend);	    
    9f76:	8d b7       	in	r24, 0x3d	; 61
    9f78:	9e b7       	in	r25, 0x3e	; 62
    9f7a:	0c 96       	adiw	r24, 0x0c	; 12
    9f7c:	0f b6       	in	r0, 0x3f	; 63
    9f7e:	f8 94       	cli
    9f80:	9e bf       	out	0x3e, r25	; 62
    9f82:	0f be       	out	0x3f, r0	; 63
    9f84:	8d bf       	out	0x3d, r24	; 61
    9f86:	81 e0       	ldi	r24, 0x01	; 1
    9f88:	60 e0       	ldi	r22, 0x00	; 0
    9f8a:	a6 01       	movw	r20, r12
    9f8c:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
		  sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    9f90:	ad b7       	in	r26, 0x3d	; 61
    9f92:	be b7       	in	r27, 0x3e	; 62
    9f94:	1a 97       	sbiw	r26, 0x0a	; 10
    9f96:	0f b6       	in	r0, 0x3f	; 63
    9f98:	f8 94       	cli
    9f9a:	be bf       	out	0x3e, r27	; 62
    9f9c:	0f be       	out	0x3f, r0	; 63
    9f9e:	ad bf       	out	0x3d, r26	; 61
    9fa0:	ed b7       	in	r30, 0x3d	; 61
    9fa2:	fe b7       	in	r31, 0x3e	; 62
    9fa4:	31 96       	adiw	r30, 0x01	; 1
    9fa6:	12 96       	adiw	r26, 0x02	; 2
    9fa8:	dc 92       	st	X, r13
    9faa:	ce 92       	st	-X, r12
    9fac:	11 97       	sbiw	r26, 0x01	; 1
    9fae:	8d e9       	ldi	r24, 0x9D	; 157
    9fb0:	91 e2       	ldi	r25, 0x21	; 33
    9fb2:	93 83       	std	Z+3, r25	; 0x03
    9fb4:	82 83       	std	Z+2, r24	; 0x02
    9fb6:	89 ef       	ldi	r24, 0xF9	; 249
    9fb8:	97 e0       	ldi	r25, 0x07	; 7
    9fba:	95 83       	std	Z+5, r25	; 0x05
    9fbc:	84 83       	std	Z+4, r24	; 0x04
    9fbe:	8c e5       	ldi	r24, 0x5C	; 92
    9fc0:	97 e0       	ldi	r25, 0x07	; 7
    9fc2:	97 83       	std	Z+7, r25	; 0x07
    9fc4:	86 83       	std	Z+6, r24	; 0x06
    9fc6:	88 ec       	ldi	r24, 0xC8	; 200
    9fc8:	9d e0       	ldi	r25, 0x0D	; 13
    9fca:	91 87       	std	Z+9, r25	; 0x09
    9fcc:	80 87       	std	Z+8, r24	; 0x08
    9fce:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	      uart_print(1,0,strSend);
    9fd2:	8d b7       	in	r24, 0x3d	; 61
    9fd4:	9e b7       	in	r25, 0x3e	; 62
    9fd6:	0a 96       	adiw	r24, 0x0a	; 10
    9fd8:	19 c0       	rjmp	.+50     	; 0xa00c <IFTSendMessage+0x64c>
	      break;	 
	 case MSG_98://Request Transaction Info
	      sprintf_P(strSend,PSTR("%s"),strFIP_ID);
    9fda:	00 d0       	rcall	.+0      	; 0x9fdc <IFTSendMessage+0x61c>
    9fdc:	00 d0       	rcall	.+0      	; 0x9fde <IFTSendMessage+0x61e>
    9fde:	00 d0       	rcall	.+0      	; 0x9fe0 <IFTSendMessage+0x620>
    9fe0:	ed b7       	in	r30, 0x3d	; 61
    9fe2:	fe b7       	in	r31, 0x3e	; 62
    9fe4:	31 96       	adiw	r30, 0x01	; 1
    9fe6:	ad b7       	in	r26, 0x3d	; 61
    9fe8:	be b7       	in	r27, 0x3e	; 62
    9fea:	12 96       	adiw	r26, 0x02	; 2
    9fec:	dc 92       	st	X, r13
    9fee:	ce 92       	st	-X, r12
    9ff0:	11 97       	sbiw	r26, 0x01	; 1
    9ff2:	8a e9       	ldi	r24, 0x9A	; 154
    9ff4:	91 e2       	ldi	r25, 0x21	; 33
    9ff6:	93 83       	std	Z+3, r25	; 0x03
    9ff8:	82 83       	std	Z+2, r24	; 0x02
    9ffa:	82 ec       	ldi	r24, 0xC2	; 194
    9ffc:	97 e0       	ldi	r25, 0x07	; 7
    9ffe:	95 83       	std	Z+5, r25	; 0x05
    a000:	84 83       	std	Z+4, r24	; 0x04
    a002:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	      uart_print(1, 0,strSend);
    a006:	8d b7       	in	r24, 0x3d	; 61
    a008:	9e b7       	in	r25, 0x3e	; 62
    a00a:	06 96       	adiw	r24, 0x06	; 6
    a00c:	0f b6       	in	r0, 0x3f	; 63
    a00e:	f8 94       	cli
    a010:	9e bf       	out	0x3e, r25	; 62
    a012:	0f be       	out	0x3f, r0	; 63
    a014:	8d bf       	out	0x3d, r24	; 61
    a016:	81 e0       	ldi	r24, 0x01	; 1
    a018:	60 e0       	ldi	r22, 0x00	; 0
    a01a:	a6 01       	movw	r20, r12
    a01c:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
	      break;

	 }     
     //[Checksum]
	 uart_printf(1,0,PSTR("F968CFFB"));
    a020:	81 e0       	ldi	r24, 0x01	; 1
    a022:	60 e0       	ldi	r22, 0x00	; 0
    a024:	41 e9       	ldi	r20, 0x91	; 145
    a026:	51 e2       	ldi	r21, 0x21	; 33
    a028:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
	 //ETX
	 uart(1, 1,0x02);
    a02c:	81 e0       	ldi	r24, 0x01	; 1
    a02e:	61 e0       	ldi	r22, 0x01	; 1
    a030:	42 e0       	ldi	r20, 0x02	; 2
    a032:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
}
    a036:	c0 5c       	subi	r28, 0xC0	; 192
    a038:	df 4f       	sbci	r29, 0xFF	; 255
    a03a:	0f b6       	in	r0, 0x3f	; 63
    a03c:	f8 94       	cli
    a03e:	de bf       	out	0x3e, r29	; 62
    a040:	0f be       	out	0x3f, r0	; 63
    a042:	cd bf       	out	0x3d, r28	; 61
    a044:	cf 91       	pop	r28
    a046:	df 91       	pop	r29
    a048:	0f 91       	pop	r16
    a04a:	ff 90       	pop	r15
    a04c:	ef 90       	pop	r14
    a04e:	df 90       	pop	r13
    a050:	cf 90       	pop	r12
    a052:	bf 90       	pop	r11
    a054:	af 90       	pop	r10
    a056:	08 95       	ret

0000a058 <sendMessage98>:
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
	uart_print(1, 0,strSend);
	uart(1, 1,0x02);
*/
    sprintf_P(strFIP_ID,PSTR("%.2d"),GetPumpID(FIPAddr));
    a058:	0e 94 9a 21 	call	0x4334	; 0x4334 <GetPumpID>
    a05c:	00 d0       	rcall	.+0      	; 0xa05e <sendMessage98+0x6>
    a05e:	00 d0       	rcall	.+0      	; 0xa060 <sendMessage98+0x8>
    a060:	00 d0       	rcall	.+0      	; 0xa062 <sendMessage98+0xa>
    a062:	ed b7       	in	r30, 0x3d	; 61
    a064:	fe b7       	in	r31, 0x3e	; 62
    a066:	31 96       	adiw	r30, 0x01	; 1
    a068:	22 ec       	ldi	r18, 0xC2	; 194
    a06a:	37 e0       	ldi	r19, 0x07	; 7
    a06c:	ad b7       	in	r26, 0x3d	; 61
    a06e:	be b7       	in	r27, 0x3e	; 62
    a070:	12 96       	adiw	r26, 0x02	; 2
    a072:	3c 93       	st	X, r19
    a074:	2e 93       	st	-X, r18
    a076:	11 97       	sbiw	r26, 0x01	; 1
    a078:	2c e8       	ldi	r18, 0x8C	; 140
    a07a:	31 e2       	ldi	r19, 0x21	; 33
    a07c:	33 83       	std	Z+3, r19	; 0x03
    a07e:	22 83       	std	Z+2, r18	; 0x02
    a080:	84 83       	std	Z+4, r24	; 0x04
    a082:	15 82       	std	Z+5, r1	; 0x05
    a084:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	IFTSendMessage(MSG_98);
    a088:	8d b7       	in	r24, 0x3d	; 61
    a08a:	9e b7       	in	r25, 0x3e	; 62
    a08c:	06 96       	adiw	r24, 0x06	; 6
    a08e:	0f b6       	in	r0, 0x3f	; 63
    a090:	f8 94       	cli
    a092:	9e bf       	out	0x3e, r25	; 62
    a094:	0f be       	out	0x3f, r0	; 63
    a096:	8d bf       	out	0x3d, r24	; 61
    a098:	88 e9       	ldi	r24, 0x98	; 152
    a09a:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
	IsBusyMsg11=True;
    a09e:	81 e0       	ldi	r24, 0x01	; 1
    a0a0:	80 93 af 01 	sts	0x01AF, r24
}
    a0a4:	08 95       	ret

0000a0a6 <sendMessage94>:
	sprintf_P(strSend,PSTR("E9445512"));
    //uart_print(0, 0,strSend);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_94);
    a0a6:	84 e9       	ldi	r24, 0x94	; 148
    a0a8:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0ac:	08 95       	ret

0000a0ae <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    //uart_print(0, 0,strSend);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_92);
    a0ae:	82 e9       	ldi	r24, 0x92	; 146
    a0b0:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0b4:	08 95       	ret

0000a0b6 <sendMessage90>:
    uart_print(1, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_90);
    a0b6:	80 e9       	ldi	r24, 0x90	; 144
    a0b8:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0bc:	08 95       	ret

0000a0be <sendMessage58>:
	CardType=0;
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_58);
    a0be:	88 e5       	ldi	r24, 0x58	; 88
    a0c0:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0c4:	08 95       	ret

0000a0c6 <sendMessage56>:
    uart_print(1, 0,strSend);	

	uart_printf(1,0,PSTR("AF968CFFB"));
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_56);
    a0c6:	86 e5       	ldi	r24, 0x56	; 86
    a0c8:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0cc:	08 95       	ret

0000a0ce <sendMessage32>:
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    uart_print(1, 0,strSend);
	sprintf_P(strSend,PSTR("F968CFFB"));
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
*/IFTSendMessage(MSG_32);
    a0ce:	82 e3       	ldi	r24, 0x32	; 50
    a0d0:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0d4:	08 95       	ret

0000a0d6 <sendMessage28>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_28);
    a0d6:	88 e2       	ldi	r24, 0x28	; 40
    a0d8:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0dc:	08 95       	ret

0000a0de <sendMessage24>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_24);
    a0de:	84 e2       	ldi	r24, 0x24	; 36
    a0e0:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0e4:	08 95       	ret

0000a0e6 <sendMessage22>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_22);
    a0e6:	82 e2       	ldi	r24, 0x22	; 34
    a0e8:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0ec:	08 95       	ret

0000a0ee <sendMessage10>:
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	IsNewPacket=True;
	*/
	IsNewPacket=True;
    a0ee:	81 e0       	ldi	r24, 0x01	; 1
    a0f0:	80 93 8a 01 	sts	0x018A, r24
	IFTSendMessage(MSG_10);
    a0f4:	80 e1       	ldi	r24, 0x10	; 16
    a0f6:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a0fa:	08 95       	ret

0000a0fc <sendMessage04>:
	 UpdateServerIP();//ReadDestIP
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
     uart_print(1, 0,strSend);
	 uart(1, 1,0x02);
	 */IFTSendMessage(MSG_04);
    a0fc:	84 e0       	ldi	r24, 0x04	; 4
    a0fe:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <IFTSendMessage>
}
    a102:	08 95       	ret

0000a104 <FreePrinting>:
	 } 
	 else uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
    a104:	0f 93       	push	r16
    a106:	1f 93       	push	r17
    a108:	df 93       	push	r29
    a10a:	cf 93       	push	r28
    a10c:	cd b7       	in	r28, 0x3d	; 61
    a10e:	de b7       	in	r29, 0x3e	; 62
    a110:	64 97       	sbiw	r28, 0x14	; 20
    a112:	0f b6       	in	r0, 0x3f	; 63
    a114:	f8 94       	cli
    a116:	de bf       	out	0x3e, r29	; 62
    a118:	0f be       	out	0x3f, r0	; 63
    a11a:	cd bf       	out	0x3d, r28	; 61
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static unsigned int iSend=0,LSend=0,iLoop=0;
       char strOperatorName[20];

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
    a11c:	20 91 aa 01 	lds	r18, 0x01AA
    a120:	21 30       	cpi	r18, 0x01	; 1
    a122:	31 f4       	brne	.+12     	; 0xa130 <FreePrinting+0x2c>
    a124:	80 91 16 01 	lds	r24, 0x0116
    a128:	81 30       	cpi	r24, 0x01	; 1
    a12a:	11 f0       	breq	.+4      	; 0xa130 <FreePrinting+0x2c>
	     stFreePrinting=fpInit;
    a12c:	20 93 16 01 	sts	0x0116, r18
	 }
	 switch (stFreePrinting){
    a130:	80 91 16 01 	lds	r24, 0x0116
    a134:	90 e0       	ldi	r25, 0x00	; 0
    a136:	fc 01       	movw	r30, r24
    a138:	31 97       	sbiw	r30, 0x01	; 1
    a13a:	eb 31       	cpi	r30, 0x1B	; 27
    a13c:	f1 05       	cpc	r31, r1
    a13e:	08 f0       	brcs	.+2      	; 0xa142 <FreePrinting+0x3e>
    a140:	87 c3       	rjmp	.+1806   	; 0xa850 <FreePrinting+0x74c>
    a142:	ec 59       	subi	r30, 0x9C	; 156
    a144:	ff 4f       	sbci	r31, 0xFF	; 255
    a146:	ee 0f       	add	r30, r30
    a148:	ff 1f       	adc	r31, r31
    a14a:	05 90       	lpm	r0, Z+
    a14c:	f4 91       	lpm	r31, Z+
    a14e:	e0 2d       	mov	r30, r0
    a150:	09 94       	ijmp
     case fpInit:
	      //uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
    a152:	21 30       	cpi	r18, 0x01	; 1
    a154:	09 f0       	breq	.+2      	; 0xa158 <FreePrinting+0x54>
    a156:	7c c3       	rjmp	.+1784   	; 0xa850 <FreePrinting+0x74c>
		      IsFreePrinting=False;
    a158:	10 92 aa 01 	sts	0x01AA, r1
			  IsBusyFreePrinting=True;
    a15c:	20 93 b6 01 	sts	0x01B6, r18
			  IsBusyPrint=False;
    a160:	10 92 b5 01 	sts	0x01B5, r1
			  iPrinted=0,iFooter=0;
    a164:	10 92 fe 01 	sts	0x01FE, r1
    a168:	10 92 fc 01 	sts	0x01FC, r1

			  PrintCopy=(cmdPrint&0x0F);
    a16c:	80 91 b7 01 	lds	r24, 0x01B7
    a170:	8f 70       	andi	r24, 0x0F	; 15
    a172:	80 93 fb 01 	sts	0x01FB, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
    a176:	82 e0       	ldi	r24, 0x02	; 2
    a178:	80 93 16 01 	sts	0x0116, r24
			  InitPrinter();
    a17c:	0e 94 27 4c 	call	0x984e	; 0x984e <InitPrinter>
    a180:	67 c3       	rjmp	.+1742   	; 0xa850 <FreePrinting+0x74c>
			  }
	      break;
     case fpInitHeader:
	      //uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
    a182:	10 92 fd 01 	sts	0x01FD, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
    a186:	80 91 b7 01 	lds	r24, 0x01B7
    a18a:	88 1f       	adc	r24, r24
    a18c:	88 27       	eor	r24, r24
    a18e:	88 1f       	adc	r24, r24
    a190:	90 e0       	ldi	r25, 0x00	; 0
    a192:	81 30       	cpi	r24, 0x01	; 1
    a194:	91 05       	cpc	r25, r1
    a196:	21 f1       	breq	.+72     	; 0xa1e0 <FreePrinting+0xdc>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
    a198:	89 2b       	or	r24, r25
    a19a:	09 f0       	breq	.+2      	; 0xa19e <FreePrinting+0x9a>
    a19c:	59 c3       	rjmp	.+1714   	; 0xa850 <FreePrinting+0x74c>
    a19e:	85 e0       	ldi	r24, 0x05	; 5
    a1a0:	80 93 16 01 	sts	0x0116, r24
    a1a4:	55 c3       	rjmp	.+1706   	; 0xa850 <FreePrinting+0x74c>
    a1a6:	60 91 fd 01 	lds	r22, 0x01FD
    a1aa:	89 e2       	ldi	r24, 0x29	; 41
    a1ac:	68 9f       	mul	r22, r24
    a1ae:	b0 01       	movw	r22, r0
    a1b0:	11 24       	eor	r1, r1
    a1b2:	69 5d       	subi	r22, 0xD9	; 217
    a1b4:	7d 4f       	sbci	r23, 0xFD	; 253
    a1b6:	85 ec       	ldi	r24, 0xC5	; 197
    a1b8:	98 e0       	ldi	r25, 0x08	; 8
    a1ba:	48 e2       	ldi	r20, 0x28	; 40
    a1bc:	50 e0       	ldi	r21, 0x00	; 0
    a1be:	22 e4       	ldi	r18, 0x42	; 66
    a1c0:	33 e1       	ldi	r19, 0x13	; 19
    a1c2:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	      break;
     case fpLoadHeader:
	      //uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
    a1c6:	80 91 fd 01 	lds	r24, 0x01FD
    a1ca:	8f 5f       	subi	r24, 0xFF	; 255
    a1cc:	80 93 fd 01 	sts	0x01FD, r24
		  if (iHeader<6){
    a1d0:	86 30       	cpi	r24, 0x06	; 6
    a1d2:	28 f7       	brcc	.-54     	; 0xa19e <FreePrinting+0x9a>
		      if (SpaceOnly(strPrint)==True){
    a1d4:	85 ec       	ldi	r24, 0xC5	; 197
    a1d6:	98 e0       	ldi	r25, 0x08	; 8
    a1d8:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    a1dc:	81 30       	cpi	r24, 0x01	; 1
    a1de:	11 f4       	brne	.+4      	; 0xa1e4 <FreePrinting+0xe0>
			      stFreePrinting=fpLoadHeader;
    a1e0:	83 e0       	ldi	r24, 0x03	; 3
    a1e2:	de cf       	rjmp	.-68     	; 0xa1a0 <FreePrinting+0x9c>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
    a1e4:	84 e0       	ldi	r24, 0x04	; 4
    a1e6:	80 93 16 01 	sts	0x0116, r24
			      iSend=0;
    a1ea:	10 92 f7 01 	sts	0x01F7, r1
    a1ee:	10 92 f6 01 	sts	0x01F6, r1
				  iLoop=0;
    a1f2:	10 92 f3 01 	sts	0x01F3, r1
    a1f6:	10 92 f2 01 	sts	0x01F2, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    a1fa:	80 91 fd 01 	lds	r24, 0x01FD
    a1fe:	81 30       	cpi	r24, 0x01	; 1
    a200:	19 f4       	brne	.+6      	; 0xa208 <FreePrinting+0x104>
    a202:	0e 94 a9 4c 	call	0x9952	; 0x9952 <PrintDoubleHeight>
    a206:	24 c3       	rjmp	.+1608   	; 0xa850 <FreePrinting+0x74c>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    a208:	82 30       	cpi	r24, 0x02	; 2
    a20a:	09 f0       	breq	.+2      	; 0xa20e <FreePrinting+0x10a>
    a20c:	21 c3       	rjmp	.+1602   	; 0xa850 <FreePrinting+0x74c>
    a20e:	0e 94 8f 4c 	call	0x991e	; 0x991e <PrintNormalHeight>
    a212:	1e c3       	rjmp	.+1596   	; 0xa850 <FreePrinting+0x74c>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
    a214:	80 91 f6 01 	lds	r24, 0x01F6
    a218:	90 91 f7 01 	lds	r25, 0x01F7
    a21c:	88 97       	sbiw	r24, 0x28	; 40
    a21e:	68 f4       	brcc	.+26     	; 0xa23a <FreePrinting+0x136>
		      iLoop++;
    a220:	80 91 f2 01 	lds	r24, 0x01F2
    a224:	90 91 f3 01 	lds	r25, 0x01F3
    a228:	01 96       	adiw	r24, 0x01	; 1
    a22a:	90 93 f3 01 	sts	0x01F3, r25
    a22e:	80 93 f2 01 	sts	0x01F2, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //uart(_COM_PRINTER,1,strPrint[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
    a232:	10 92 b8 01 	sts	0x01B8, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
    a236:	82 e1       	ldi	r24, 0x12	; 18
    a238:	b3 cf       	rjmp	.-154    	; 0xa1a0 <FreePrinting+0x9c>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
    a23a:	83 e0       	ldi	r24, 0x03	; 3
    a23c:	62 c2       	rjmp	.+1220   	; 0xa702 <FreePrinting+0x5fe>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    a23e:	80 91 b5 01 	lds	r24, 0x01B5
    a242:	88 23       	and	r24, r24
    a244:	09 f0       	breq	.+2      	; 0xa248 <FreePrinting+0x144>
    a246:	7c c2       	rjmp	.+1272   	; 0xa740 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    a248:	e0 91 f6 01 	lds	r30, 0x01F6
    a24c:	f0 91 f7 01 	lds	r31, 0x01F7
    a250:	eb 53       	subi	r30, 0x3B	; 59
    a252:	f7 4f       	sbci	r31, 0xF7	; 247
    a254:	61 e0       	ldi	r22, 0x01	; 1
    a256:	40 81       	ld	r20, Z
    a258:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    a25c:	80 91 f6 01 	lds	r24, 0x01F6
    a260:	90 91 f7 01 	lds	r25, 0x01F7
    a264:	01 96       	adiw	r24, 0x01	; 1
    a266:	90 93 f7 01 	sts	0x01F7, r25
    a26a:	80 93 f6 01 	sts	0x01F6, r24
		      stFreePrinting=fpPrintHeader;
    a26e:	84 e0       	ldi	r24, 0x04	; 4
    a270:	65 c2       	rjmp	.+1226   	; 0xa73c <FreePrinting+0x638>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     case fpInitMessage:
	      //uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
    a272:	10 92 f7 01 	sts	0x01F7, r1
    a276:	10 92 f6 01 	sts	0x01F6, r1
    a27a:	10 92 f3 01 	sts	0x01F3, r1
    a27e:	10 92 f2 01 	sts	0x01F2, r1
          stFreePrinting=fpPrintMessage; 
    a282:	08 e0       	ldi	r16, 0x08	; 8
    a284:	00 93 16 01 	sts	0x0116, r16
		  CarriegeReturn();
    a288:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
    a28c:	80 91 fe 01 	lds	r24, 0x01FE
    a290:	88 23       	and	r24, r24
    a292:	11 f0       	breq	.+4      	; 0xa298 <FreePrinting+0x194>
    a294:	86 e0       	ldi	r24, 0x06	; 6
    a296:	84 cf       	rjmp	.-248    	; 0xa1a0 <FreePrinting+0x9c>
		  else stFreePrinting=fpPrintMessage; 
    a298:	00 93 16 01 	sts	0x0116, r16
    a29c:	d9 c2       	rjmp	.+1458   	; 0xa850 <FreePrinting+0x74c>
	      break;
     case fpInitDuplicate:
	      //uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    a29e:	80 91 fe 01 	lds	r24, 0x01FE
    a2a2:	25 ec       	ldi	r18, 0xC5	; 197
    a2a4:	38 e0       	ldi	r19, 0x08	; 8
    a2a6:	88 23       	and	r24, r24
    a2a8:	79 f0       	breq	.+30     	; 0xa2c8 <FreePrinting+0x1c4>
    a2aa:	00 d0       	rcall	.+0      	; 0xa2ac <FreePrinting+0x1a8>
    a2ac:	00 d0       	rcall	.+0      	; 0xa2ae <FreePrinting+0x1aa>
    a2ae:	ad b7       	in	r26, 0x3d	; 61
    a2b0:	be b7       	in	r27, 0x3e	; 62
    a2b2:	12 96       	adiw	r26, 0x02	; 2
    a2b4:	3c 93       	st	X, r19
    a2b6:	2e 93       	st	-X, r18
    a2b8:	11 97       	sbiw	r26, 0x01	; 1
    a2ba:	83 ee       	ldi	r24, 0xE3	; 227
    a2bc:	96 e0       	ldi	r25, 0x06	; 6
    a2be:	14 96       	adiw	r26, 0x04	; 4
    a2c0:	9c 93       	st	X, r25
    a2c2:	8e 93       	st	-X, r24
    a2c4:	13 97       	sbiw	r26, 0x03	; 3
    a2c6:	0a c0       	rjmp	.+20     	; 0xa2dc <FreePrinting+0x1d8>
          else           sprintf_P(strPrint,PSTR("                                   "));
    a2c8:	00 d0       	rcall	.+0      	; 0xa2ca <FreePrinting+0x1c6>
    a2ca:	00 d0       	rcall	.+0      	; 0xa2cc <FreePrinting+0x1c8>
    a2cc:	ed b7       	in	r30, 0x3d	; 61
    a2ce:	fe b7       	in	r31, 0x3e	; 62
    a2d0:	32 83       	std	Z+2, r19	; 0x02
    a2d2:	21 83       	std	Z+1, r18	; 0x01
    a2d4:	8f eb       	ldi	r24, 0xBF	; 191
    a2d6:	96 e0       	ldi	r25, 0x06	; 6
    a2d8:	94 83       	std	Z+4, r25	; 0x04
    a2da:	83 83       	std	Z+3, r24	; 0x03
    a2dc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    a2e0:	0f 90       	pop	r0
    a2e2:	0f 90       	pop	r0
    a2e4:	0f 90       	pop	r0
    a2e6:	0f 90       	pop	r0
		  iSend=0;
    a2e8:	10 92 f7 01 	sts	0x01F7, r1
    a2ec:	10 92 f6 01 	sts	0x01F6, r1
		  iLoop=0;
    a2f0:	10 92 f3 01 	sts	0x01F3, r1
    a2f4:	10 92 f2 01 	sts	0x01F2, r1
		  LSend=strlen(strPrint);
    a2f8:	e5 ec       	ldi	r30, 0xC5	; 197
    a2fa:	f8 e0       	ldi	r31, 0x08	; 8
    a2fc:	01 90       	ld	r0, Z+
    a2fe:	00 20       	and	r0, r0
    a300:	e9 f7       	brne	.-6      	; 0xa2fc <FreePrinting+0x1f8>
    a302:	31 97       	sbiw	r30, 0x01	; 1
    a304:	e5 5c       	subi	r30, 0xC5	; 197
    a306:	f8 40       	sbci	r31, 0x08	; 8
    a308:	f0 93 f5 01 	sts	0x01F5, r31
    a30c:	e0 93 f4 01 	sts	0x01F4, r30
          stFreePrinting=fpPrintDuplicate; 
    a310:	87 e0       	ldi	r24, 0x07	; 7
    a312:	46 cf       	rjmp	.-372    	; 0xa1a0 <FreePrinting+0x9c>
	      break;
     case fpPrintDuplicate:
	      //uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
    a314:	20 91 f6 01 	lds	r18, 0x01F6
    a318:	30 91 f7 01 	lds	r19, 0x01F7
    a31c:	80 91 f4 01 	lds	r24, 0x01F4
    a320:	90 91 f5 01 	lds	r25, 0x01F5
    a324:	28 17       	cp	r18, r24
    a326:	39 07       	cpc	r19, r25
    a328:	68 f4       	brcc	.+26     	; 0xa344 <FreePrinting+0x240>
		      iLoop++;
    a32a:	80 91 f2 01 	lds	r24, 0x01F2
    a32e:	90 91 f3 01 	lds	r25, 0x01F3
    a332:	01 96       	adiw	r24, 0x01	; 1
    a334:	90 93 f3 01 	sts	0x01F3, r25
    a338:	80 93 f2 01 	sts	0x01F2, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //uart(_COM_PRINTER,1,strPrint[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
    a33c:	10 92 b8 01 	sts	0x01B8, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
    a340:	85 e1       	ldi	r24, 0x15	; 21
    a342:	2e cf       	rjmp	.-420    	; 0xa1a0 <FreePrinting+0x9c>
				 }
			  }
          else {
		     iSend=0;
    a344:	10 92 f7 01 	sts	0x01F7, r1
    a348:	10 92 f6 01 	sts	0x01F6, r1
		     stFreePrinting=fpPrintMessage;
    a34c:	88 e0       	ldi	r24, 0x08	; 8
    a34e:	d9 c1       	rjmp	.+946    	; 0xa702 <FreePrinting+0x5fe>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    a350:	80 91 b5 01 	lds	r24, 0x01B5
    a354:	88 23       	and	r24, r24
    a356:	09 f0       	breq	.+2      	; 0xa35a <FreePrinting+0x256>
    a358:	f3 c1       	rjmp	.+998    	; 0xa740 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    a35a:	e0 91 f6 01 	lds	r30, 0x01F6
    a35e:	f0 91 f7 01 	lds	r31, 0x01F7
    a362:	eb 53       	subi	r30, 0x3B	; 59
    a364:	f7 4f       	sbci	r31, 0xF7	; 247
    a366:	61 e0       	ldi	r22, 0x01	; 1
    a368:	40 81       	ld	r20, Z
    a36a:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    a36e:	80 91 f6 01 	lds	r24, 0x01F6
    a372:	90 91 f7 01 	lds	r25, 0x01F7
    a376:	01 96       	adiw	r24, 0x01	; 1
    a378:	90 93 f7 01 	sts	0x01F7, r25
    a37c:	80 93 f6 01 	sts	0x01F6, r24
		      stFreePrinting=fpPrintDuplicate;
    a380:	87 e0       	ldi	r24, 0x07	; 7
    a382:	dc c1       	rjmp	.+952    	; 0xa73c <FreePrinting+0x638>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
    a384:	20 91 f6 01 	lds	r18, 0x01F6
    a388:	30 91 f7 01 	lds	r19, 0x01F7
    a38c:	80 91 8f 01 	lds	r24, 0x018F
    a390:	90 91 90 01 	lds	r25, 0x0190
    a394:	28 17       	cp	r18, r24
    a396:	39 07       	cpc	r19, r25
    a398:	68 f4       	brcc	.+26     	; 0xa3b4 <FreePrinting+0x2b0>
		      iLoop++;
    a39a:	80 91 f2 01 	lds	r24, 0x01F2
    a39e:	90 91 f3 01 	lds	r25, 0x01F3
    a3a2:	01 96       	adiw	r24, 0x01	; 1
    a3a4:	90 93 f3 01 	sts	0x01F3, r25
    a3a8:	80 93 f2 01 	sts	0x01F2, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
    a3ac:	10 92 b8 01 	sts	0x01B8, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
    a3b0:	83 e1       	ldi	r24, 0x13	; 19
    a3b2:	f6 ce       	rjmp	.-532    	; 0xa1a0 <FreePrinting+0x9c>
				 }
			  }
          else stFreePrinting=fpLoadEndLine;//fpInitFooter;
    a3b4:	86 e1       	ldi	r24, 0x16	; 22
    a3b6:	f4 ce       	rjmp	.-536    	; 0xa1a0 <FreePrinting+0x9c>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    a3b8:	80 91 b5 01 	lds	r24, 0x01B5
    a3bc:	88 23       	and	r24, r24
    a3be:	09 f0       	breq	.+2      	; 0xa3c2 <FreePrinting+0x2be>
    a3c0:	bf c1       	rjmp	.+894    	; 0xa740 <FreePrinting+0x63c>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
    a3c2:	e0 91 f6 01 	lds	r30, 0x01F6
    a3c6:	f0 91 f7 01 	lds	r31, 0x01F7
    a3ca:	eb 50       	subi	r30, 0x0B	; 11
    a3cc:	fc 4f       	sbci	r31, 0xFC	; 252
    a3ce:	80 81       	ld	r24, Z
    a3d0:	61 81       	ldd	r22, Z+1	; 0x01
    a3d2:	0e 94 04 4c 	call	0x9808	; 0x9808 <SendPrint>
			     // uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
    a3d6:	e0 91 f6 01 	lds	r30, 0x01F6
    a3da:	f0 91 f7 01 	lds	r31, 0x01F7
    a3de:	eb 50       	subi	r30, 0x0B	; 11
    a3e0:	fc 4f       	sbci	r31, 0xFC	; 252
    a3e2:	80 81       	ld	r24, Z
    a3e4:	8d 30       	cpi	r24, 0x0D	; 13
    a3e6:	19 f0       	breq	.+6      	; 0xa3ee <FreePrinting+0x2ea>
    a3e8:	81 81       	ldd	r24, Z+1	; 0x01
    a3ea:	8a 30       	cpi	r24, 0x0A	; 10
    a3ec:	11 f4       	brne	.+4      	; 0xa3f2 <FreePrinting+0x2ee>
			     CarriegeReturn();
    a3ee:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
             iSend++;
    a3f2:	80 91 f6 01 	lds	r24, 0x01F6
    a3f6:	90 91 f7 01 	lds	r25, 0x01F7
    a3fa:	01 96       	adiw	r24, 0x01	; 1
    a3fc:	90 93 f7 01 	sts	0x01F7, r25
    a400:	80 93 f6 01 	sts	0x01F6, r24
		     stFreePrinting=fpPrintMessage;
    a404:	88 e0       	ldi	r24, 0x08	; 8
    a406:	9a c1       	rjmp	.+820    	; 0xa73c <FreePrinting+0x638>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
    a408:	10 92 f3 01 	sts	0x01F3, r1
    a40c:	10 92 f2 01 	sts	0x01F2, r1
		  iMargin=0;
    a410:	10 92 fa 01 	sts	0x01FA, r1
		  stFreePrinting=fpPrintMargin;
    a414:	8a e0       	ldi	r24, 0x0A	; 10
    a416:	c4 ce       	rjmp	.-632    	; 0xa1a0 <FreePrinting+0x9c>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
    a418:	80 91 fa 01 	lds	r24, 0x01FA
    a41c:	85 30       	cpi	r24, 0x05	; 5
    a41e:	90 f4       	brcc	.+36     	; 0xa444 <FreePrinting+0x340>
		      iMargin++;
    a420:	8f 5f       	subi	r24, 0xFF	; 255
    a422:	80 93 fa 01 	sts	0x01FA, r24
		      iLoop++;
    a426:	80 91 f2 01 	lds	r24, 0x01F2
    a42a:	90 91 f3 01 	lds	r25, 0x01F3
    a42e:	01 96       	adiw	r24, 0x01	; 1
    a430:	90 93 f3 01 	sts	0x01F3, r25
    a434:	80 93 f2 01 	sts	0x01F2, r24
	          if ((iLoop%PRINT_DELAY)==0)uart(_COM_PRINTER,1,' ');
    a438:	80 e0       	ldi	r24, 0x00	; 0
    a43a:	61 e0       	ldi	r22, 0x01	; 1
    a43c:	40 e2       	ldi	r20, 0x20	; 32
    a43e:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    a442:	06 c2       	rjmp	.+1036   	; 0xa850 <FreePrinting+0x74c>
			 }
          else stFreePrinting=fpPrintMessage;
    a444:	88 e0       	ldi	r24, 0x08	; 8
    a446:	ac ce       	rjmp	.-680    	; 0xa1a0 <FreePrinting+0x9c>
    a448:	8e 01       	movw	r16, r28
    a44a:	0f 5f       	subi	r16, 0xFF	; 255
    a44c:	1f 4f       	sbci	r17, 0xFF	; 255
    a44e:	c8 01       	movw	r24, r16
    a450:	65 e1       	ldi	r22, 0x15	; 21
    a452:	70 e0       	ldi	r23, 0x00	; 0
    a454:	42 e1       	ldi	r20, 0x12	; 18
    a456:	50 e0       	ldi	r21, 0x00	; 0
    a458:	22 e4       	ldi	r18, 0x42	; 66
    a45a:	33 e1       	ldi	r19, 0x13	; 19
    a45c:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    a460:	c8 01       	movw	r24, r16
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    a462:	9e 01       	movw	r18, r28
    a464:	20 5f       	subi	r18, 0xF0	; 240
    a466:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    a468:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    a46a:	82 17       	cp	r24, r18
    a46c:	93 07       	cpc	r25, r19
    a46e:	e1 f7       	brne	.-8      	; 0xa468 <FreePrinting+0x364>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    a470:	18 8a       	std	Y+16, r1	; 0x10
     
     //Added Operator Name:
	 case fpLoadEndLine:
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
          StrPosCopy(strOperatorName,strOperatorName,0,15);
          if (strlen(strOperatorName)>0){
    a472:	89 81       	ldd	r24, Y+1	; 0x01
    a474:	88 23       	and	r24, r24
    a476:	09 f4       	brne	.+2      	; 0xa47a <FreePrinting+0x376>
    a478:	2e c1       	rjmp	.+604    	; 0xa6d6 <FreePrinting+0x5d2>
		  	  if (SpaceOnly(strOperatorName)!=True){
    a47a:	ce 01       	movw	r24, r28
    a47c:	01 96       	adiw	r24, 0x01	; 1
    a47e:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    a482:	81 30       	cpi	r24, 0x01	; 1
    a484:	09 f4       	brne	.+2      	; 0xa488 <FreePrinting+0x384>
    a486:	27 c1       	rjmp	.+590    	; 0xa6d6 <FreePrinting+0x5d2>
			      sprintf_P(strPrint,PSTR("---------------------------------"));
    a488:	00 d0       	rcall	.+0      	; 0xa48a <FreePrinting+0x386>
    a48a:	00 d0       	rcall	.+0      	; 0xa48c <FreePrinting+0x388>
    a48c:	05 ec       	ldi	r16, 0xC5	; 197
    a48e:	18 e0       	ldi	r17, 0x08	; 8
    a490:	ad b7       	in	r26, 0x3d	; 61
    a492:	be b7       	in	r27, 0x3e	; 62
    a494:	12 96       	adiw	r26, 0x02	; 2
    a496:	1c 93       	st	X, r17
    a498:	0e 93       	st	-X, r16
    a49a:	11 97       	sbiw	r26, 0x01	; 1
    a49c:	8d e9       	ldi	r24, 0x9D	; 157
    a49e:	96 e0       	ldi	r25, 0x06	; 6
    a4a0:	14 96       	adiw	r26, 0x04	; 4
    a4a2:	9c 93       	st	X, r25
    a4a4:	8e 93       	st	-X, r24
    a4a6:	13 97       	sbiw	r26, 0x03	; 3
    a4a8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			      //AddSpaceLead(strPrint,(strlen(strPrint)+PRINT_MARGIN));
			      iSend=0;
    a4ac:	10 92 f7 01 	sts	0x01F7, r1
    a4b0:	10 92 f6 01 	sts	0x01F6, r1
				  iLoop=0;
    a4b4:	10 92 f3 01 	sts	0x01F3, r1
    a4b8:	10 92 f2 01 	sts	0x01F2, r1
				  LSend=strlen(strPrint);
    a4bc:	f8 01       	movw	r30, r16
    a4be:	01 90       	ld	r0, Z+
    a4c0:	00 20       	and	r0, r0
    a4c2:	e9 f7       	brne	.-6      	; 0xa4be <FreePrinting+0x3ba>
    a4c4:	8f 01       	movw	r16, r30
    a4c6:	01 50       	subi	r16, 0x01	; 1
    a4c8:	10 40       	sbci	r17, 0x00	; 0
    a4ca:	05 5c       	subi	r16, 0xC5	; 197
    a4cc:	18 40       	sbci	r17, 0x08	; 8
    a4ce:	10 93 f5 01 	sts	0x01F5, r17
    a4d2:	00 93 f4 01 	sts	0x01F4, r16
				  stFreePrinting=fpPrintEndLine;	
    a4d6:	87 e1       	ldi	r24, 0x17	; 23
    a4d8:	80 93 16 01 	sts	0x0116, r24
    a4dc:	0f 90       	pop	r0
    a4de:	0f 90       	pop	r0
    a4e0:	0f 90       	pop	r0
    a4e2:	0f 90       	pop	r0
    a4e4:	b5 c1       	rjmp	.+874    	; 0xa850 <FreePrinting+0x74c>
			   }else stFreePrinting=piLoadFooter;
		  }else stFreePrinting=piLoadFooter;
	      break;

	 case fpPrintEndLine:
		  if (iSend<LSend){
    a4e6:	20 91 f6 01 	lds	r18, 0x01F6
    a4ea:	30 91 f7 01 	lds	r19, 0x01F7
    a4ee:	80 91 f4 01 	lds	r24, 0x01F4
    a4f2:	90 91 f5 01 	lds	r25, 0x01F5
    a4f6:	28 17       	cp	r18, r24
    a4f8:	39 07       	cpc	r19, r25
    a4fa:	68 f4       	brcc	.+26     	; 0xa516 <FreePrinting+0x412>
		      iLoop++;
    a4fc:	80 91 f2 01 	lds	r24, 0x01F2
    a500:	90 91 f3 01 	lds	r25, 0x01F3
    a504:	01 96       	adiw	r24, 0x01	; 1
    a506:	90 93 f3 01 	sts	0x01F3, r25
    a50a:	80 93 f2 01 	sts	0x01F2, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
    a50e:	10 92 b8 01 	sts	0x01B8, r1
				  stFreePrinting=fpCheckPrintEndLine;
    a512:	88 e1       	ldi	r24, 0x18	; 24
    a514:	45 ce       	rjmp	.-886    	; 0xa1a0 <FreePrinting+0x9c>
				}
			  }
          else {
			  CarriegeReturn();
    a516:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			  stFreePrinting=fpLoadOperatorName;
    a51a:	89 e1       	ldi	r24, 0x19	; 25
    a51c:	41 ce       	rjmp	.-894    	; 0xa1a0 <FreePrinting+0x9c>
			  }
	      break;
	 case fpCheckPrintEndLine:
	      if (IsBusyPrint==False){
    a51e:	80 91 b5 01 	lds	r24, 0x01B5
    a522:	88 23       	and	r24, r24
    a524:	09 f0       	breq	.+2      	; 0xa528 <FreePrinting+0x424>
    a526:	0c c1       	rjmp	.+536    	; 0xa740 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    a528:	e0 91 f6 01 	lds	r30, 0x01F6
    a52c:	f0 91 f7 01 	lds	r31, 0x01F7
    a530:	eb 53       	subi	r30, 0x3B	; 59
    a532:	f7 4f       	sbci	r31, 0xF7	; 247
    a534:	61 e0       	ldi	r22, 0x01	; 1
    a536:	40 81       	ld	r20, Z
    a538:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    a53c:	80 91 f6 01 	lds	r24, 0x01F6
    a540:	90 91 f7 01 	lds	r25, 0x01F7
    a544:	01 96       	adiw	r24, 0x01	; 1
    a546:	90 93 f7 01 	sts	0x01F7, r25
    a54a:	80 93 f6 01 	sts	0x01F6, r24
		      stFreePrinting=fpPrintEndLine;
    a54e:	87 e1       	ldi	r24, 0x17	; 23
    a550:	f5 c0       	rjmp	.+490    	; 0xa73c <FreePrinting+0x638>
    a552:	8e 01       	movw	r16, r28
    a554:	0f 5f       	subi	r16, 0xFF	; 255
    a556:	1f 4f       	sbci	r17, 0xFF	; 255
    a558:	c8 01       	movw	r24, r16
    a55a:	65 e1       	ldi	r22, 0x15	; 21
    a55c:	70 e0       	ldi	r23, 0x00	; 0
    a55e:	42 e1       	ldi	r20, 0x12	; 18
    a560:	50 e0       	ldi	r21, 0x00	; 0
    a562:	22 e4       	ldi	r18, 0x42	; 66
    a564:	33 e1       	ldi	r19, 0x13	; 19
    a566:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    a56a:	c8 01       	movw	r24, r16
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    a56c:	9e 01       	movw	r18, r28
    a56e:	20 5f       	subi	r18, 0xF0	; 240
    a570:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    a572:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    a574:	82 17       	cp	r24, r18
    a576:	93 07       	cpc	r25, r19
    a578:	e1 f7       	brne	.-8      	; 0xa572 <FreePrinting+0x46e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    a57a:	18 8a       	std	Y+16, r1	; 0x10
	      break;

	 case fpLoadOperatorName:
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);
		  sprintf_P(strPrint,PSTR("Operator: %s"),strOperatorName);
    a57c:	00 d0       	rcall	.+0      	; 0xa57e <FreePrinting+0x47a>
    a57e:	00 d0       	rcall	.+0      	; 0xa580 <FreePrinting+0x47c>
    a580:	00 d0       	rcall	.+0      	; 0xa582 <FreePrinting+0x47e>
    a582:	ed b7       	in	r30, 0x3d	; 61
    a584:	fe b7       	in	r31, 0x3e	; 62
    a586:	31 96       	adiw	r30, 0x01	; 1
    a588:	05 ec       	ldi	r16, 0xC5	; 197
    a58a:	18 e0       	ldi	r17, 0x08	; 8
    a58c:	ad b7       	in	r26, 0x3d	; 61
    a58e:	be b7       	in	r27, 0x3e	; 62
    a590:	12 96       	adiw	r26, 0x02	; 2
    a592:	1c 93       	st	X, r17
    a594:	0e 93       	st	-X, r16
    a596:	11 97       	sbiw	r26, 0x01	; 1
    a598:	80 e9       	ldi	r24, 0x90	; 144
    a59a:	96 e0       	ldi	r25, 0x06	; 6
    a59c:	93 83       	std	Z+3, r25	; 0x03
    a59e:	82 83       	std	Z+2, r24	; 0x02
    a5a0:	ce 01       	movw	r24, r28
    a5a2:	01 96       	adiw	r24, 0x01	; 1
    a5a4:	95 83       	std	Z+5, r25	; 0x05
    a5a6:	84 83       	std	Z+4, r24	; 0x04
    a5a8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	      iSend=0;
    a5ac:	10 92 f7 01 	sts	0x01F7, r1
    a5b0:	10 92 f6 01 	sts	0x01F6, r1
		  iLoop=0;
    a5b4:	10 92 f3 01 	sts	0x01F3, r1
    a5b8:	10 92 f2 01 	sts	0x01F2, r1
		  LSend=strlen(strPrint);
    a5bc:	f8 01       	movw	r30, r16
    a5be:	01 90       	ld	r0, Z+
    a5c0:	00 20       	and	r0, r0
    a5c2:	e9 f7       	brne	.-6      	; 0xa5be <FreePrinting+0x4ba>
    a5c4:	8f 01       	movw	r16, r30
    a5c6:	01 50       	subi	r16, 0x01	; 1
    a5c8:	10 40       	sbci	r17, 0x00	; 0
    a5ca:	05 5c       	subi	r16, 0xC5	; 197
    a5cc:	18 40       	sbci	r17, 0x08	; 8
    a5ce:	10 93 f5 01 	sts	0x01F5, r17
    a5d2:	00 93 f4 01 	sts	0x01F4, r16
		  stFreePrinting=fpPrintOperatorName;	
    a5d6:	8a e1       	ldi	r24, 0x1A	; 26
    a5d8:	80 93 16 01 	sts	0x0116, r24
    a5dc:	8d b7       	in	r24, 0x3d	; 61
    a5de:	9e b7       	in	r25, 0x3e	; 62
    a5e0:	06 96       	adiw	r24, 0x06	; 6
    a5e2:	0f b6       	in	r0, 0x3f	; 63
    a5e4:	f8 94       	cli
    a5e6:	9e bf       	out	0x3e, r25	; 62
    a5e8:	0f be       	out	0x3f, r0	; 63
    a5ea:	8d bf       	out	0x3d, r24	; 61
    a5ec:	31 c1       	rjmp	.+610    	; 0xa850 <FreePrinting+0x74c>
	      break;
	 case fpPrintOperatorName:
		  if (iSend<LSend){
    a5ee:	20 91 f6 01 	lds	r18, 0x01F6
    a5f2:	30 91 f7 01 	lds	r19, 0x01F7
    a5f6:	80 91 f4 01 	lds	r24, 0x01F4
    a5fa:	90 91 f5 01 	lds	r25, 0x01F5
    a5fe:	28 17       	cp	r18, r24
    a600:	39 07       	cpc	r19, r25
    a602:	68 f4       	brcc	.+26     	; 0xa61e <FreePrinting+0x51a>
		      iLoop++;
    a604:	80 91 f2 01 	lds	r24, 0x01F2
    a608:	90 91 f3 01 	lds	r25, 0x01F3
    a60c:	01 96       	adiw	r24, 0x01	; 1
    a60e:	90 93 f3 01 	sts	0x01F3, r25
    a612:	80 93 f2 01 	sts	0x01F2, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
    a616:	10 92 b8 01 	sts	0x01B8, r1
				  stFreePrinting=fpCheckPrintOperatorName;
    a61a:	8b e1       	ldi	r24, 0x1B	; 27
    a61c:	c1 cd       	rjmp	.-1150   	; 0xa1a0 <FreePrinting+0x9c>
				}
			  }
          else {
			  CarriegeReturn();
    a61e:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			  CarriegeReturn();
    a622:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			  stFreePrinting=fpInitFooter;
    a626:	8b e0       	ldi	r24, 0x0B	; 11
    a628:	bb cd       	rjmp	.-1162   	; 0xa1a0 <FreePrinting+0x9c>
			  }
	      break;
	 case fpCheckPrintOperatorName:
	      if (IsBusyPrint==False){
    a62a:	80 91 b5 01 	lds	r24, 0x01B5
    a62e:	88 23       	and	r24, r24
    a630:	09 f0       	breq	.+2      	; 0xa634 <FreePrinting+0x530>
    a632:	86 c0       	rjmp	.+268    	; 0xa740 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    a634:	e0 91 f6 01 	lds	r30, 0x01F6
    a638:	f0 91 f7 01 	lds	r31, 0x01F7
    a63c:	eb 53       	subi	r30, 0x3B	; 59
    a63e:	f7 4f       	sbci	r31, 0xF7	; 247
    a640:	61 e0       	ldi	r22, 0x01	; 1
    a642:	40 81       	ld	r20, Z
    a644:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    a648:	80 91 f6 01 	lds	r24, 0x01F6
    a64c:	90 91 f7 01 	lds	r25, 0x01F7
    a650:	01 96       	adiw	r24, 0x01	; 1
    a652:	90 93 f7 01 	sts	0x01F7, r25
    a656:	80 93 f6 01 	sts	0x01F6, r24
		      stFreePrinting=fpPrintOperatorName;
    a65a:	8a e1       	ldi	r24, 0x1A	; 26
    a65c:	6f c0       	rjmp	.+222    	; 0xa73c <FreePrinting+0x638>
			  }
	      break;

     case fpInitFooter:
	      //uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
    a65e:	80 91 b7 01 	lds	r24, 0x01B7
    a662:	86 ff       	sbrs	r24, 6
    a664:	06 c0       	rjmp	.+12     	; 0xa672 <FreePrinting+0x56e>
		      stFreePrinting=fpLoadFooter;
    a666:	8c e0       	ldi	r24, 0x0C	; 12
    a668:	80 93 16 01 	sts	0x0116, r24
			  iFooter=0;
    a66c:	10 92 fc 01 	sts	0x01FC, r1
    a670:	ef c0       	rjmp	.+478    	; 0xa850 <FreePrinting+0x74c>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
    a672:	80 e1       	ldi	r24, 0x10	; 16
    a674:	95 cd       	rjmp	.-1238   	; 0xa1a0 <FreePrinting+0x9c>
    a676:	60 91 fc 01 	lds	r22, 0x01FC
    a67a:	89 e2       	ldi	r24, 0x29	; 41
    a67c:	68 9f       	mul	r22, r24
    a67e:	b0 01       	movw	r22, r0
    a680:	11 24       	eor	r1, r1
    a682:	63 5e       	subi	r22, 0xE3	; 227
    a684:	7c 4f       	sbci	r23, 0xFC	; 252
    a686:	85 ec       	ldi	r24, 0xC5	; 197
    a688:	98 e0       	ldi	r25, 0x08	; 8
    a68a:	48 e2       	ldi	r20, 0x28	; 40
    a68c:	50 e0       	ldi	r21, 0x00	; 0
    a68e:	22 e4       	ldi	r18, 0x42	; 66
    a690:	33 e1       	ldi	r19, 0x13	; 19
    a692:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    a696:	80 91 fc 01 	lds	r24, 0x01FC
    a69a:	8f 5f       	subi	r24, 0xFF	; 255
    a69c:	80 93 fc 01 	sts	0x01FC, r24
		  if (iFooter<4){
    a6a0:	84 30       	cpi	r24, 0x04	; 4
    a6a2:	90 f4       	brcc	.+36     	; 0xa6c8 <FreePrinting+0x5c4>
		      if (SpaceOnly(strPrint)==True){
    a6a4:	85 ec       	ldi	r24, 0xC5	; 197
    a6a6:	98 e0       	ldi	r25, 0x08	; 8
    a6a8:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    a6ac:	81 30       	cpi	r24, 0x01	; 1
    a6ae:	11 f4       	brne	.+4      	; 0xa6b4 <FreePrinting+0x5b0>
			      stFreePrinting=fpLoadFooter;
    a6b0:	8c e0       	ldi	r24, 0x0C	; 12
    a6b2:	76 cd       	rjmp	.-1300   	; 0xa1a0 <FreePrinting+0x9c>
				  }
			  else{
			      iSend=0;
    a6b4:	10 92 f7 01 	sts	0x01F7, r1
    a6b8:	10 92 f6 01 	sts	0x01F6, r1
				  iLoop=0;
    a6bc:	10 92 f3 01 	sts	0x01F3, r1
    a6c0:	10 92 f2 01 	sts	0x01F2, r1
				  stFreePrinting=fpPrintFooter;
    a6c4:	8d e0       	ldi	r24, 0x0D	; 13
    a6c6:	6c cd       	rjmp	.-1320   	; 0xa1a0 <FreePrinting+0x9c>
			      }
		  }else{
		    CarriegeReturn();
    a6c8:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			iPrinted++;
    a6cc:	80 91 fe 01 	lds	r24, 0x01FE
    a6d0:	8f 5f       	subi	r24, 0xFF	; 255
    a6d2:	80 93 fe 01 	sts	0x01FE, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
    a6d6:	8e e0       	ldi	r24, 0x0E	; 14
    a6d8:	63 cd       	rjmp	.-1338   	; 0xa1a0 <FreePrinting+0x9c>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
    a6da:	80 91 f6 01 	lds	r24, 0x01F6
    a6de:	90 91 f7 01 	lds	r25, 0x01F7
    a6e2:	88 97       	sbiw	r24, 0x28	; 40
    a6e4:	68 f4       	brcc	.+26     	; 0xa700 <FreePrinting+0x5fc>
		      iLoop++;
    a6e6:	80 91 f2 01 	lds	r24, 0x01F2
    a6ea:	90 91 f3 01 	lds	r25, 0x01F3
    a6ee:	01 96       	adiw	r24, 0x01	; 1
    a6f0:	90 93 f3 01 	sts	0x01F3, r25
    a6f4:	80 93 f2 01 	sts	0x01F2, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //uart(_COM_PRINTER,1,strPrint[iSend]);
		        //iSend++;
				TimPrintBusy=0;
    a6f8:	10 92 b8 01 	sts	0x01B8, r1
				stFreePrinting=fpCheckPrintStatusFooter;
    a6fc:	84 e1       	ldi	r24, 0x14	; 20
    a6fe:	50 cd       	rjmp	.-1376   	; 0xa1a0 <FreePrinting+0x9c>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
    a700:	8c e0       	ldi	r24, 0x0C	; 12
    a702:	80 93 16 01 	sts	0x0116, r24
			  CarriegeReturn();
    a706:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    a70a:	a2 c0       	rjmp	.+324    	; 0xa850 <FreePrinting+0x74c>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    a70c:	80 91 b5 01 	lds	r24, 0x01B5
    a710:	88 23       	and	r24, r24
    a712:	b1 f4       	brne	.+44     	; 0xa740 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    a714:	e0 91 f6 01 	lds	r30, 0x01F6
    a718:	f0 91 f7 01 	lds	r31, 0x01F7
    a71c:	eb 53       	subi	r30, 0x3B	; 59
    a71e:	f7 4f       	sbci	r31, 0xF7	; 247
    a720:	61 e0       	ldi	r22, 0x01	; 1
    a722:	40 81       	ld	r20, Z
    a724:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    a728:	80 91 f6 01 	lds	r24, 0x01F6
    a72c:	90 91 f7 01 	lds	r25, 0x01F7
    a730:	01 96       	adiw	r24, 0x01	; 1
    a732:	90 93 f7 01 	sts	0x01F7, r25
    a736:	80 93 f6 01 	sts	0x01F6, r24
		      stFreePrinting=fpPrintFooter;
    a73a:	8d e0       	ldi	r24, 0x0D	; 13
    a73c:	80 93 16 01 	sts	0x0116, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    a740:	80 91 b8 01 	lds	r24, 0x01B8
    a744:	8b 30       	cpi	r24, 0x0B	; 11
    a746:	08 f4       	brcc	.+2      	; 0xa74a <FreePrinting+0x646>
    a748:	83 c0       	rjmp	.+262    	; 0xa850 <FreePrinting+0x74c>
		      IsPrintERROR=True;
    a74a:	81 e0       	ldi	r24, 0x01	; 1
    a74c:	80 93 b3 01 	sts	0x01B3, r24
		      stFreePrinting=fpFinishFreePrinting;
    a750:	81 e1       	ldi	r24, 0x11	; 17
    a752:	26 cd       	rjmp	.-1460   	; 0xa1a0 <FreePrinting+0x9c>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
    a754:	10 92 f9 01 	sts	0x01F9, r1
		  iSend=0;
    a758:	10 92 f7 01 	sts	0x01F7, r1
    a75c:	10 92 f6 01 	sts	0x01F6, r1
		  if (iPrinted<PrintCopy)
    a760:	90 91 fe 01 	lds	r25, 0x01FE
    a764:	80 91 fb 01 	lds	r24, 0x01FB
    a768:	98 17       	cp	r25, r24
    a76a:	28 f4       	brcc	.+10     	; 0xa776 <FreePrinting+0x672>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a76c:	e1 99       	sbic	0x1c, 1	; 28
    a76e:	fe cf       	rjmp	.-4      	; 0xa76c <FreePrinting+0x668>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a770:	82 e3       	ldi	r24, 0x32	; 50
    a772:	90 e0       	ldi	r25, 0x00	; 0
    a774:	04 c0       	rjmp	.+8      	; 0xa77e <FreePrinting+0x67a>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a776:	e1 99       	sbic	0x1c, 1	; 28
    a778:	fe cf       	rjmp	.-4      	; 0xa776 <FreePrinting+0x672>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a77a:	81 e3       	ldi	r24, 0x31	; 49
    a77c:	90 e0       	ldi	r25, 0x00	; 0
    a77e:	9f bb       	out	0x1f, r25	; 31
    a780:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a782:	e0 9a       	sbi	0x1c, 0	; 28
    a784:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    a786:	80 93 f8 01 	sts	0x01F8, r24

          stFreePrinting=fpScrollPaper;
    a78a:	8f e0       	ldi	r24, 0x0F	; 15
    a78c:	09 cd       	rjmp	.-1518   	; 0xa1a0 <FreePrinting+0x9c>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
    a78e:	90 91 f9 01 	lds	r25, 0x01F9
    a792:	80 91 f8 01 	lds	r24, 0x01F8
    a796:	89 17       	cp	r24, r25
    a798:	18 f4       	brcc	.+6      	; 0xa7a0 <FreePrinting+0x69c>
    a79a:	80 e1       	ldi	r24, 0x10	; 16
    a79c:	80 93 16 01 	sts	0x0116, r24
		  iSend++;
    a7a0:	80 91 f6 01 	lds	r24, 0x01F6
    a7a4:	90 91 f7 01 	lds	r25, 0x01F7
    a7a8:	01 96       	adiw	r24, 0x01	; 1
    a7aa:	90 93 f7 01 	sts	0x01F7, r25
    a7ae:	80 93 f6 01 	sts	0x01F6, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
    a7b2:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			  iScroll++;
    a7b6:	80 91 f9 01 	lds	r24, 0x01F9
    a7ba:	8f 5f       	subi	r24, 0xFF	; 255
    a7bc:	80 93 f9 01 	sts	0x01F9, r24
    a7c0:	47 c0       	rjmp	.+142    	; 0xa850 <FreePrinting+0x74c>
			  }
	      break;
     case fpPaperCut:
		  //uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
    a7c2:	90 91 fe 01 	lds	r25, 0x01FE
    a7c6:	80 91 fb 01 	lds	r24, 0x01FB
    a7ca:	98 17       	cp	r25, r24
    a7cc:	20 f4       	brcc	.+8      	; 0xa7d6 <FreePrinting+0x6d2>
		      CarriegeReturn();
    a7ce:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
              stFreePrinting=fpInitHeader;
    a7d2:	82 e0       	ldi	r24, 0x02	; 2
    a7d4:	07 c0       	rjmp	.+14     	; 0xa7e4 <FreePrinting+0x6e0>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
    a7d6:	80 91 00 01 	lds	r24, 0x0100
    a7da:	81 30       	cpi	r24, 0x01	; 1
    a7dc:	11 f4       	brne	.+4      	; 0xa7e2 <FreePrinting+0x6de>
    a7de:	0e 94 7e 50 	call	0xa0fc	; 0xa0fc <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
    a7e2:	81 e1       	ldi	r24, 0x11	; 17
    a7e4:	80 93 16 01 	sts	0x0116, r24
			  }
          
		  if (((cmdPrint&0b00100000)>>5)==1){
    a7e8:	80 91 b7 01 	lds	r24, 0x01B7
    a7ec:	85 ff       	sbrs	r24, 5
    a7ee:	30 c0       	rjmp	.+96     	; 0xa850 <FreePrinting+0x74c>
		      if (iPrinted==0){
    a7f0:	80 91 fe 01 	lds	r24, 0x01FE
    a7f4:	88 23       	and	r24, r24
    a7f6:	31 f4       	brne	.+12     	; 0xa804 <FreePrinting+0x700>
			      CarriegeReturn();_delay_ms(50);
    a7f8:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    a7fc:	84 ed       	ldi	r24, 0xD4	; 212
    a7fe:	90 e3       	ldi	r25, 0x30	; 48
    a800:	01 97       	sbiw	r24, 0x01	; 1
    a802:	f1 f7       	brne	.-4      	; 0xa800 <FreePrinting+0x6fc>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
    a804:	90 91 fe 01 	lds	r25, 0x01FE
    a808:	80 91 fb 01 	lds	r24, 0x01FB
    a80c:	98 17       	cp	r25, r24
    a80e:	b1 f4       	brne	.+44     	; 0xa83c <FreePrinting+0x738>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				  CarriegeReturn();_delay_ms(50);
    a810:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    a814:	04 ed       	ldi	r16, 0xD4	; 212
    a816:	10 e3       	ldi	r17, 0x30	; 48
    a818:	c8 01       	movw	r24, r16
    a81a:	01 97       	sbiw	r24, 0x01	; 1
    a81c:	f1 f7       	brne	.-4      	; 0xa81a <FreePrinting+0x716>
				  CarriegeReturn();_delay_ms(50);
    a81e:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    a822:	c8 01       	movw	r24, r16
    a824:	01 97       	sbiw	r24, 0x01	; 1
    a826:	f1 f7       	brne	.-4      	; 0xa824 <FreePrinting+0x720>
				  CarriegeReturn();_delay_ms(50);
    a828:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    a82c:	c8 01       	movw	r24, r16
    a82e:	01 97       	sbiw	r24, 0x01	; 1
    a830:	f1 f7       	brne	.-4      	; 0xa82e <FreePrinting+0x72a>
				  CarriegeReturn();_delay_ms(50);
    a832:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    a836:	c8 01       	movw	r24, r16
    a838:	01 97       	sbiw	r24, 0x01	; 1
    a83a:	f1 f7       	brne	.-4      	; 0xa838 <FreePrinting+0x734>
				   //}
				 }
		      PaperCut();
    a83c:	0e 94 c3 4c 	call	0x9986	; 0x9986 <PaperCut>
    a840:	07 c0       	rjmp	.+14     	; 0xa850 <FreePrinting+0x74c>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
    a842:	10 92 b6 01 	sts	0x01B6, r1
	      stFreePrinting=fpInit;
    a846:	81 e0       	ldi	r24, 0x01	; 1
    a848:	80 93 16 01 	sts	0x0116, r24
		  iPrinted=0;
    a84c:	10 92 fe 01 	sts	0x01FE, r1
	      break;
	 }//EndCase
}
    a850:	64 96       	adiw	r28, 0x14	; 20
    a852:	0f b6       	in	r0, 0x3f	; 63
    a854:	f8 94       	cli
    a856:	de bf       	out	0x3e, r29	; 62
    a858:	0f be       	out	0x3f, r0	; 63
    a85a:	cd bf       	out	0x3d, r28	; 61
    a85c:	cf 91       	pop	r28
    a85e:	df 91       	pop	r29
    a860:	1f 91       	pop	r17
    a862:	0f 91       	pop	r16
    a864:	08 95       	ret

0000a866 <PrintIdle>:
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
    a866:	ef 92       	push	r14
    a868:	ff 92       	push	r15
    a86a:	0f 93       	push	r16
    a86c:	1f 93       	push	r17
    a86e:	df 93       	push	r29
    a870:	cf 93       	push	r28
    a872:	cd b7       	in	r28, 0x3d	; 61
    a874:	de b7       	in	r29, 0x3e	; 62
    a876:	64 97       	sbiw	r28, 0x14	; 20
    a878:	0f b6       	in	r0, 0x3f	; 63
    a87a:	f8 94       	cli
    a87c:	de bf       	out	0x3e, r29	; 62
    a87e:	0f be       	out	0x3f, r0	; 63
    a880:	cd bf       	out	0x3d, r28	; 61
		uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
    a882:	80 91 ae 01 	lds	r24, 0x01AE
    a886:	81 30       	cpi	r24, 0x01	; 1
    a888:	31 f4       	brne	.+12     	; 0xa896 <PrintIdle+0x30>
    a88a:	80 91 0f 02 	lds	r24, 0x020F
    a88e:	88 23       	and	r24, r24
    a890:	11 f0       	breq	.+4      	; 0xa896 <PrintIdle+0x30>
	     stPrintIdle=piIdle;
    a892:	10 92 0f 02 	sts	0x020F, r1
	 }

     switch(stPrintIdle){
    a896:	80 91 0f 02 	lds	r24, 0x020F
    a89a:	e8 2f       	mov	r30, r24
    a89c:	f0 e0       	ldi	r31, 0x00	; 0
    a89e:	e8 31       	cpi	r30, 0x18	; 24
    a8a0:	f1 05       	cpc	r31, r1
    a8a2:	08 f0       	brcs	.+2      	; 0xa8a6 <PrintIdle+0x40>
    a8a4:	96 c7       	rjmp	.+3884   	; 0xb7d2 <PrintIdle+0xf6c>
    a8a6:	e1 58       	subi	r30, 0x81	; 129
    a8a8:	ff 4f       	sbci	r31, 0xFF	; 255
    a8aa:	ee 0f       	add	r30, r30
    a8ac:	ff 1f       	adc	r31, r31
    a8ae:	05 90       	lpm	r0, Z+
    a8b0:	f4 91       	lpm	r31, Z+
    a8b2:	e0 2d       	mov	r30, r0
    a8b4:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
    a8b6:	80 91 ae 01 	lds	r24, 0x01AE
    a8ba:	81 30       	cpi	r24, 0x01	; 1
    a8bc:	09 f0       	breq	.+2      	; 0xa8c0 <PrintIdle+0x5a>
    a8be:	89 c7       	rjmp	.+3858   	; 0xb7d2 <PrintIdle+0xf6c>
		      IsPrinting=False;
    a8c0:	10 92 ae 01 	sts	0x01AE, r1
			  IsBusyIdlePrinting=True;
    a8c4:	80 93 b4 01 	sts	0x01B4, r24
			  IsBusyPrint=False;
    a8c8:	10 92 b5 01 	sts	0x01B5, r1
			  iPrinted=0;
    a8cc:	10 92 01 02 	sts	0x0201, r1
			  PrintCopy=0;
    a8d0:	10 92 00 02 	sts	0x0200, r1
		      stPrintIdle=piInit;
    a8d4:	80 93 0f 02 	sts	0x020F, r24
			  InitPrinter();
    a8d8:	0e 94 27 4c 	call	0x984e	; 0x984e <InitPrinter>
			  IsSignedField=False;
    a8dc:	10 92 08 02 	sts	0x0208, r1
    a8e0:	78 c7       	rjmp	.+3824   	; 0xb7d2 <PrintIdle+0xf6c>
			  }
	      break;
	 case piInit:
	      iHeader=0;
    a8e2:	10 92 0e 02 	sts	0x020E, r1
		  CarriegeReturn();
    a8e6:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    a8ea:	1d c0       	rjmp	.+58     	; 0xa926 <PrintIdle+0xc0>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    a8ec:	60 91 0e 02 	lds	r22, 0x020E
    a8f0:	89 e2       	ldi	r24, 0x29	; 41
    a8f2:	68 9f       	mul	r22, r24
    a8f4:	b0 01       	movw	r22, r0
    a8f6:	11 24       	eor	r1, r1
    a8f8:	69 5d       	subi	r22, 0xD9	; 217
    a8fa:	7d 4f       	sbci	r23, 0xFD	; 253
    a8fc:	85 ec       	ldi	r24, 0xC5	; 197
    a8fe:	98 e0       	ldi	r25, 0x08	; 8
    a900:	49 e2       	ldi	r20, 0x29	; 41
    a902:	50 e0       	ldi	r21, 0x00	; 0
    a904:	22 e4       	ldi	r18, 0x42	; 66
    a906:	33 e1       	ldi	r19, 0x13	; 19
    a908:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
    a90c:	80 91 0e 02 	lds	r24, 0x020E
    a910:	8f 5f       	subi	r24, 0xFF	; 255
    a912:	80 93 0e 02 	sts	0x020E, r24
		  if (iHeader<6){
    a916:	86 30       	cpi	r24, 0x06	; 6
    a918:	00 f5       	brcc	.+64     	; 0xa95a <PrintIdle+0xf4>
		      if (SpaceOnly(strPrint)==True){
    a91a:	85 ec       	ldi	r24, 0xC5	; 197
    a91c:	98 e0       	ldi	r25, 0x08	; 8
    a91e:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    a922:	81 30       	cpi	r24, 0x01	; 1
    a924:	11 f4       	brne	.+4      	; 0xa92a <PrintIdle+0xc4>
			      stPrintIdle=piLoadHeader;
    a926:	82 e0       	ldi	r24, 0x02	; 2
    a928:	29 c7       	rjmp	.+3666   	; 0xb77c <PrintIdle+0xf16>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
    a92a:	83 e0       	ldi	r24, 0x03	; 3
    a92c:	80 93 0f 02 	sts	0x020F, r24
			      iSend=0;
    a930:	10 92 07 02 	sts	0x0207, r1
    a934:	10 92 06 02 	sts	0x0206, r1
				  iLoop=0;
    a938:	10 92 03 02 	sts	0x0203, r1
    a93c:	10 92 02 02 	sts	0x0202, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    a940:	80 91 0e 02 	lds	r24, 0x020E
    a944:	81 30       	cpi	r24, 0x01	; 1
    a946:	19 f4       	brne	.+6      	; 0xa94e <PrintIdle+0xe8>
    a948:	0e 94 a9 4c 	call	0x9952	; 0x9952 <PrintDoubleHeight>
    a94c:	42 c7       	rjmp	.+3716   	; 0xb7d2 <PrintIdle+0xf6c>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    a94e:	82 30       	cpi	r24, 0x02	; 2
    a950:	09 f0       	breq	.+2      	; 0xa954 <PrintIdle+0xee>
    a952:	3f c7       	rjmp	.+3710   	; 0xb7d2 <PrintIdle+0xf6c>
    a954:	0e 94 8f 4c 	call	0x991e	; 0x991e <PrintNormalHeight>
    a958:	3c c7       	rjmp	.+3704   	; 0xb7d2 <PrintIdle+0xf6c>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
    a95a:	84 e0       	ldi	r24, 0x04	; 4
    a95c:	0f c7       	rjmp	.+3614   	; 0xb77c <PrintIdle+0xf16>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
    a95e:	80 91 06 02 	lds	r24, 0x0206
    a962:	90 91 07 02 	lds	r25, 0x0207
    a966:	88 97       	sbiw	r24, 0x28	; 40
    a968:	68 f4       	brcc	.+26     	; 0xa984 <PrintIdle+0x11e>
		      iLoop++;
    a96a:	80 91 02 02 	lds	r24, 0x0202
    a96e:	90 91 03 02 	lds	r25, 0x0203
    a972:	01 96       	adiw	r24, 0x01	; 1
    a974:	90 93 03 02 	sts	0x0203, r25
    a978:	80 93 02 02 	sts	0x0202, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    a97c:	10 92 b8 01 	sts	0x01B8, r1
				 stPrintIdle=piCheckPrintStatusHeader;
    a980:	8b e0       	ldi	r24, 0x0B	; 11
    a982:	fc c6       	rjmp	.+3576   	; 0xb77c <PrintIdle+0xf16>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
    a984:	82 e0       	ldi	r24, 0x02	; 2
    a986:	8e c6       	rjmp	.+3356   	; 0xb6a4 <PrintIdle+0xe3e>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    a988:	80 91 b5 01 	lds	r24, 0x01B5
    a98c:	88 23       	and	r24, r24
    a98e:	09 f0       	breq	.+2      	; 0xa992 <PrintIdle+0x12c>
    a990:	ed c6       	rjmp	.+3546   	; 0xb76c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    a992:	e0 91 06 02 	lds	r30, 0x0206
    a996:	f0 91 07 02 	lds	r31, 0x0207
    a99a:	eb 53       	subi	r30, 0x3B	; 59
    a99c:	f7 4f       	sbci	r31, 0xF7	; 247
    a99e:	61 e0       	ldi	r22, 0x01	; 1
    a9a0:	40 81       	ld	r20, Z
    a9a2:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    a9a6:	80 91 06 02 	lds	r24, 0x0206
    a9aa:	90 91 07 02 	lds	r25, 0x0207
    a9ae:	01 96       	adiw	r24, 0x01	; 1
    a9b0:	90 93 07 02 	sts	0x0207, r25
    a9b4:	80 93 06 02 	sts	0x0206, r24
		      stPrintIdle=piPrintHeader;
    a9b8:	83 e0       	ldi	r24, 0x03	; 3
    a9ba:	d6 c6       	rjmp	.+3500   	; 0xb768 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
    a9bc:	80 91 01 02 	lds	r24, 0x0201
    a9c0:	88 23       	and	r24, r24
    a9c2:	21 f4       	brne	.+8      	; 0xa9cc <PrintIdle+0x166>
    a9c4:	80 91 81 01 	lds	r24, 0x0181
    a9c8:	81 30       	cpi	r24, 0x01	; 1
    a9ca:	a9 f4       	brne	.+42     	; 0xa9f6 <PrintIdle+0x190>
		      IsReprintTicket=False;
    a9cc:	10 92 81 01 	sts	0x0181, r1
		      CarriegeReturn(); 
    a9d0:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    a9d4:	00 d0       	rcall	.+0      	; 0xa9d6 <PrintIdle+0x170>
    a9d6:	00 d0       	rcall	.+0      	; 0xa9d8 <PrintIdle+0x172>
    a9d8:	85 ec       	ldi	r24, 0xC5	; 197
    a9da:	98 e0       	ldi	r25, 0x08	; 8
    a9dc:	ad b7       	in	r26, 0x3d	; 61
    a9de:	be b7       	in	r27, 0x3e	; 62
    a9e0:	12 96       	adiw	r26, 0x02	; 2
    a9e2:	9c 93       	st	X, r25
    a9e4:	8e 93       	st	-X, r24
    a9e6:	11 97       	sbiw	r26, 0x01	; 1
    a9e8:	80 ee       	ldi	r24, 0xE0	; 224
    a9ea:	9a e0       	ldi	r25, 0x0A	; 10
    a9ec:	14 96       	adiw	r26, 0x04	; 4
    a9ee:	9c 93       	st	X, r25
    a9f0:	8e 93       	st	-X, r24
    a9f2:	13 97       	sbiw	r26, 0x03	; 3
    a9f4:	0c c0       	rjmp	.+24     	; 0xaa0e <PrintIdle+0x1a8>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
    a9f6:	00 d0       	rcall	.+0      	; 0xa9f8 <PrintIdle+0x192>
    a9f8:	00 d0       	rcall	.+0      	; 0xa9fa <PrintIdle+0x194>
    a9fa:	85 ec       	ldi	r24, 0xC5	; 197
    a9fc:	98 e0       	ldi	r25, 0x08	; 8
    a9fe:	ed b7       	in	r30, 0x3d	; 61
    aa00:	fe b7       	in	r31, 0x3e	; 62
    aa02:	92 83       	std	Z+2, r25	; 0x02
    aa04:	81 83       	std	Z+1, r24	; 0x01
    aa06:	8e ed       	ldi	r24, 0xDE	; 222
    aa08:	9a e0       	ldi	r25, 0x0A	; 10
    aa0a:	94 83       	std	Z+4, r25	; 0x04
    aa0c:	83 83       	std	Z+3, r24	; 0x03
    aa0e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    aa12:	0f 90       	pop	r0
    aa14:	0f 90       	pop	r0
    aa16:	0f 90       	pop	r0
    aa18:	0f 90       	pop	r0
		      }
		  iSend=0;
    aa1a:	10 92 07 02 	sts	0x0207, r1
    aa1e:	10 92 06 02 	sts	0x0206, r1
		  iLoop=0;
    aa22:	10 92 03 02 	sts	0x0203, r1
    aa26:	10 92 02 02 	sts	0x0202, r1
		  LSend=strlen(strPrint);
    aa2a:	e5 ec       	ldi	r30, 0xC5	; 197
    aa2c:	f8 e0       	ldi	r31, 0x08	; 8
    aa2e:	01 90       	ld	r0, Z+
    aa30:	00 20       	and	r0, r0
    aa32:	e9 f7       	brne	.-6      	; 0xaa2e <PrintIdle+0x1c8>
    aa34:	31 97       	sbiw	r30, 0x01	; 1
    aa36:	e5 5c       	subi	r30, 0xC5	; 197
    aa38:	f8 40       	sbci	r31, 0x08	; 8
    aa3a:	f0 93 05 02 	sts	0x0205, r31
    aa3e:	e0 93 04 02 	sts	0x0204, r30
          stPrintIdle=piPrintDuplicate; 
    aa42:	85 e0       	ldi	r24, 0x05	; 5
    aa44:	9b c6       	rjmp	.+3382   	; 0xb77c <PrintIdle+0xf16>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
    aa46:	20 91 06 02 	lds	r18, 0x0206
    aa4a:	30 91 07 02 	lds	r19, 0x0207
    aa4e:	80 91 04 02 	lds	r24, 0x0204
    aa52:	90 91 05 02 	lds	r25, 0x0205
    aa56:	28 17       	cp	r18, r24
    aa58:	39 07       	cpc	r19, r25
    aa5a:	68 f4       	brcc	.+26     	; 0xaa76 <PrintIdle+0x210>
		      iLoop++;
    aa5c:	80 91 02 02 	lds	r24, 0x0202
    aa60:	90 91 03 02 	lds	r25, 0x0203
    aa64:	01 96       	adiw	r24, 0x01	; 1
    aa66:	90 93 03 02 	sts	0x0203, r25
    aa6a:	80 93 02 02 	sts	0x0202, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    aa6e:	10 92 b8 01 	sts	0x01B8, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
    aa72:	86 e0       	ldi	r24, 0x06	; 6
    aa74:	83 c6       	rjmp	.+3334   	; 0xb77c <PrintIdle+0xf16>
				 }
			  }
          else {
		     iSend=0;
    aa76:	10 92 07 02 	sts	0x0207, r1
    aa7a:	10 92 06 02 	sts	0x0206, r1
		     stPrintIdle=piInitMessage;
    aa7e:	87 e0       	ldi	r24, 0x07	; 7
    aa80:	7d c6       	rjmp	.+3322   	; 0xb77c <PrintIdle+0xf16>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    aa82:	80 91 b5 01 	lds	r24, 0x01B5
    aa86:	88 23       	and	r24, r24
    aa88:	09 f0       	breq	.+2      	; 0xaa8c <PrintIdle+0x226>
    aa8a:	70 c6       	rjmp	.+3296   	; 0xb76c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    aa8c:	e0 91 06 02 	lds	r30, 0x0206
    aa90:	f0 91 07 02 	lds	r31, 0x0207
    aa94:	eb 53       	subi	r30, 0x3B	; 59
    aa96:	f7 4f       	sbci	r31, 0xF7	; 247
    aa98:	61 e0       	ldi	r22, 0x01	; 1
    aa9a:	40 81       	ld	r20, Z
    aa9c:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
    aaa0:	84 ec       	ldi	r24, 0xC4	; 196
    aaa2:	99 e0       	ldi	r25, 0x09	; 9
    aaa4:	01 97       	sbiw	r24, 0x01	; 1
    aaa6:	f1 f7       	brne	.-4      	; 0xaaa4 <PrintIdle+0x23e>
			  _delay_ms(10);
		      iSend++;
    aaa8:	80 91 06 02 	lds	r24, 0x0206
    aaac:	90 91 07 02 	lds	r25, 0x0207
    aab0:	01 96       	adiw	r24, 0x01	; 1
    aab2:	90 93 07 02 	sts	0x0207, r25
    aab6:	80 93 06 02 	sts	0x0206, r24
		      stPrintIdle=piPrintDuplicate;
    aaba:	85 e0       	ldi	r24, 0x05	; 5
    aabc:	55 c6       	rjmp	.+3242   	; 0xb768 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
    aabe:	10 92 07 02 	sts	0x0207, r1
    aac2:	10 92 06 02 	sts	0x0206, r1
    aac6:	10 92 03 02 	sts	0x0203, r1
    aaca:	10 92 02 02 	sts	0x0202, r1
		  iMessage=0;
    aace:	10 92 0a 02 	sts	0x020A, r1
		  switch(MOPType){
    aad2:	80 91 ba 01 	lds	r24, 0x01BA
    aad6:	83 30       	cpi	r24, 0x03	; 3
    aad8:	81 f0       	breq	.+32     	; 0xaafa <PrintIdle+0x294>
    aada:	84 30       	cpi	r24, 0x04	; 4
    aadc:	28 f4       	brcc	.+10     	; 0xaae8 <PrintIdle+0x282>
    aade:	81 30       	cpi	r24, 0x01	; 1
    aae0:	61 f0       	breq	.+24     	; 0xaafa <PrintIdle+0x294>
    aae2:	82 30       	cpi	r24, 0x02	; 2
    aae4:	40 f4       	brcc	.+16     	; 0xaaf6 <PrintIdle+0x290>
    aae6:	10 c0       	rjmp	.+32     	; 0xab08 <PrintIdle+0x2a2>
    aae8:	88 30       	cpi	r24, 0x08	; 8
    aaea:	49 f0       	breq	.+18     	; 0xaafe <PrintIdle+0x298>
    aaec:	89 30       	cpi	r24, 0x09	; 9
    aaee:	61 f0       	breq	.+24     	; 0xab08 <PrintIdle+0x2a2>
    aaf0:	87 30       	cpi	r24, 0x07	; 7
    aaf2:	51 f4       	brne	.+20     	; 0xab08 <PrintIdle+0x2a2>
    aaf4:	02 c0       	rjmp	.+4      	; 0xaafa <PrintIdle+0x294>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
    aaf6:	8a e0       	ldi	r24, 0x0A	; 10
    aaf8:	03 c0       	rjmp	.+6      	; 0xab00 <PrintIdle+0x29a>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
    aafa:	84 e1       	ldi	r24, 0x14	; 20
    aafc:	01 c0       	rjmp	.+2      	; 0xab00 <PrintIdle+0x29a>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
    aafe:	8c e0       	ldi	r24, 0x0C	; 12
    ab00:	80 93 09 02 	sts	0x0209, r24
			   PrintCopy=2;
    ab04:	82 e0       	ldi	r24, 0x02	; 2
    ab06:	04 c0       	rjmp	.+8      	; 0xab10 <PrintIdle+0x2aa>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
    ab08:	8a e0       	ldi	r24, 0x0A	; 10
    ab0a:	80 93 09 02 	sts	0x0209, r24
			   PrintCopy=1;
    ab0e:	81 e0       	ldi	r24, 0x01	; 1
    ab10:	80 93 00 02 	sts	0x0200, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
    ab14:	80 91 f0 02 	lds	r24, 0x02F0
    ab18:	88 23       	and	r24, r24
    ab1a:	49 f0       	breq	.+18     	; 0xab2e <PrintIdle+0x2c8>
    ab1c:	80 ef       	ldi	r24, 0xF0	; 240
    ab1e:	92 e0       	ldi	r25, 0x02	; 2
    ab20:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    ab24:	88 23       	and	r24, r24
    ab26:	19 f4       	brne	.+6      	; 0xab2e <PrintIdle+0x2c8>
		       MessageLine=33;
    ab28:	81 e2       	ldi	r24, 0x21	; 33
    ab2a:	80 93 09 02 	sts	0x0209, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
    ab2e:	88 e0       	ldi	r24, 0x08	; 8
    ab30:	25 c6       	rjmp	.+3146   	; 0xb77c <PrintIdle+0xf16>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
    ab32:	80 91 01 02 	lds	r24, 0x0201
    ab36:	88 23       	and	r24, r24
    ab38:	09 f0       	breq	.+2      	; 0xab3c <PrintIdle+0x2d6>
    ab3a:	c9 c4       	rjmp	.+2450   	; 0xb4ce <PrintIdle+0xc68>

		      FormatDate(DATE_LONG_YEAR,strDate);
    ab3c:	67 e7       	ldi	r22, 0x77	; 119
    ab3e:	77 e0       	ldi	r23, 0x07	; 7
    ab40:	0e 94 46 28 	call	0x508c	; 0x508c <FormatDate>
              RemZeroLead(strIslandID);
    ab44:	80 e0       	ldi	r24, 0x00	; 0
    ab46:	99 e0       	ldi	r25, 0x09	; 9
    ab48:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
			  RemZeroLead(strFIP_ID);
    ab4c:	82 ec       	ldi	r24, 0xC2	; 194
    ab4e:	97 e0       	ldi	r25, 0x07	; 7
    ab50:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		      RemZeroLead(strPrice);              
    ab54:	87 ea       	ldi	r24, 0xA7	; 167
    ab56:	95 e0       	ldi	r25, 0x05	; 5
    ab58:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
              if (IFType==IT_SLAVE)
    ab5c:	80 91 00 01 	lds	r24, 0x0100
    ab60:	81 30       	cpi	r24, 0x01	; 1
    ab62:	21 f4       	brne	.+8      	; 0xab6c <PrintIdle+0x306>
			      RemZeroLead(strVolume);
    ab64:	8e e7       	ldi	r24, 0x7E	; 126
    ab66:	93 e0       	ldi	r25, 0x03	; 3
    ab68:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
              RemZeroLead(strAmount);
    ab6c:	8c eb       	ldi	r24, 0xBC	; 188
    ab6e:	9d e0       	ldi	r25, 0x0D	; 13
    ab70:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>

			  RemDecimal(strPrice);
    ab74:	87 ea       	ldi	r24, 0xA7	; 167
    ab76:	95 e0       	ldi	r25, 0x05	; 5
    ab78:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <RemDecimal>
			  RemDecimal(strAmount);
    ab7c:	8c eb       	ldi	r24, 0xBC	; 188
    ab7e:	9d e0       	ldi	r25, 0x0D	; 13
    ab80:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <RemDecimal>
	  
			  FormatCurrency(strPrice);
    ab84:	87 ea       	ldi	r24, 0xA7	; 167
    ab86:	95 e0       	ldi	r25, 0x05	; 5
    ab88:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
			  FormatCurrency(strAmount);
    ab8c:	8c eb       	ldi	r24, 0xBC	; 188
    ab8e:	9d e0       	ldi	r25, 0x0D	; 13
    ab90:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
              if (IFType==IT_SLAVE){
    ab94:	80 91 00 01 	lds	r24, 0x0100
    ab98:	81 30       	cpi	r24, 0x01	; 1
    ab9a:	09 f0       	breq	.+2      	; 0xab9e <PrintIdle+0x338>
    ab9c:	98 c4       	rjmp	.+2352   	; 0xb4ce <PrintIdle+0xc68>
		          RemSpaceLag(strCardID);
    ab9e:	82 e9       	ldi	r24, 0x92	; 146
    aba0:	9d e0       	ldi	r25, 0x0D	; 13
    aba2:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
    aba6:	8d e2       	ldi	r24, 0x2D	; 45
    aba8:	93 e0       	ldi	r25, 0x03	; 3
    abaa:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
    abae:	86 e8       	ldi	r24, 0x86	; 134
    abb0:	95 e0       	ldi	r25, 0x05	; 5
    abb2:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
    abb6:	8d ec       	ldi	r24, 0xCD	; 205
    abb8:	92 e0       	ldi	r25, 0x02	; 2
    abba:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
    abbe:	8b e1       	ldi	r24, 0x1B	; 27
    abc0:	9e e0       	ldi	r25, 0x0E	; 14
    abc2:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
    abc6:	86 ed       	ldi	r24, 0xD6	; 214
    abc8:	93 e0       	ldi	r25, 0x03	; 3
    abca:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
    abce:	83 ea       	ldi	r24, 0xA3	; 163
    abd0:	93 e0       	ldi	r25, 0x03	; 3
    abd2:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
    abd6:	8a ef       	ldi	r24, 0xFA	; 250
    abd8:	9d e0       	ldi	r25, 0x0D	; 13
    abda:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
    abde:	87 e8       	ldi	r24, 0x87	; 135
    abe0:	93 e0       	ldi	r25, 0x03	; 3
    abe2:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
    abe6:	8a ef       	ldi	r24, 0xFA	; 250
    abe8:	9d e0       	ldi	r25, 0x0D	; 13
    abea:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
    abee:	87 e8       	ldi	r24, 0x87	; 135
    abf0:	93 e0       	ldi	r25, 0x03	; 3
    abf2:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
    abf6:	6b c4       	rjmp	.+2262   	; 0xb4ce <PrintIdle+0xc68>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
    abf8:	80 91 0a 02 	lds	r24, 0x020A
    abfc:	e8 2f       	mov	r30, r24
    abfe:	f0 e0       	ldi	r31, 0x00	; 0
    ac00:	e5 32       	cpi	r30, 0x25	; 37
    ac02:	f1 05       	cpc	r31, r1
    ac04:	08 f0       	brcs	.+2      	; 0xac08 <PrintIdle+0x3a2>
    ac06:	26 c4       	rjmp	.+2124   	; 0xb454 <PrintIdle+0xbee>
    ac08:	e9 56       	subi	r30, 0x69	; 105
    ac0a:	ff 4f       	sbci	r31, 0xFF	; 255
    ac0c:	ee 0f       	add	r30, r30
    ac0e:	ff 1f       	adc	r31, r31
    ac10:	05 90       	lpm	r0, Z+
    ac12:	f4 91       	lpm	r31, Z+
    ac14:	e0 2d       	mov	r30, r0
    ac16:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
    ac18:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
    ac1c:	8d b7       	in	r24, 0x3d	; 61
    ac1e:	9e b7       	in	r25, 0x3e	; 62
    ac20:	08 97       	sbiw	r24, 0x08	; 8
    ac22:	0f b6       	in	r0, 0x3f	; 63
    ac24:	f8 94       	cli
    ac26:	9e bf       	out	0x3e, r25	; 62
    ac28:	0f be       	out	0x3f, r0	; 63
    ac2a:	8d bf       	out	0x3d, r24	; 61
    ac2c:	ed b7       	in	r30, 0x3d	; 61
    ac2e:	fe b7       	in	r31, 0x3e	; 62
    ac30:	31 96       	adiw	r30, 0x01	; 1
    ac32:	85 ec       	ldi	r24, 0xC5	; 197
    ac34:	98 e0       	ldi	r25, 0x08	; 8
    ac36:	ad b7       	in	r26, 0x3d	; 61
    ac38:	be b7       	in	r27, 0x3e	; 62
    ac3a:	12 96       	adiw	r26, 0x02	; 2
    ac3c:	9c 93       	st	X, r25
    ac3e:	8e 93       	st	-X, r24
    ac40:	11 97       	sbiw	r26, 0x01	; 1
    ac42:	8f eb       	ldi	r24, 0xBF	; 191
    ac44:	9a e0       	ldi	r25, 0x0A	; 10
    ac46:	93 83       	std	Z+3, r25	; 0x03
    ac48:	82 83       	std	Z+2, r24	; 0x02
    ac4a:	81 e8       	ldi	r24, 0x81	; 129
    ac4c:	9e e0       	ldi	r25, 0x0E	; 14
    ac4e:	95 83       	std	Z+5, r25	; 0x05
    ac50:	84 83       	std	Z+4, r24	; 0x04
    ac52:	80 ea       	ldi	r24, 0xA0	; 160
    ac54:	9e e0       	ldi	r25, 0x0E	; 14
    ac56:	1f c0       	rjmp	.+62     	; 0xac96 <PrintIdle+0x430>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
    ac58:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
    ac5c:	8d b7       	in	r24, 0x3d	; 61
    ac5e:	9e b7       	in	r25, 0x3e	; 62
    ac60:	08 97       	sbiw	r24, 0x08	; 8
    ac62:	0f b6       	in	r0, 0x3f	; 63
    ac64:	f8 94       	cli
    ac66:	9e bf       	out	0x3e, r25	; 62
    ac68:	0f be       	out	0x3f, r0	; 63
    ac6a:	8d bf       	out	0x3d, r24	; 61
    ac6c:	ed b7       	in	r30, 0x3d	; 61
    ac6e:	fe b7       	in	r31, 0x3e	; 62
    ac70:	31 96       	adiw	r30, 0x01	; 1
    ac72:	85 ec       	ldi	r24, 0xC5	; 197
    ac74:	98 e0       	ldi	r25, 0x08	; 8
    ac76:	ad b7       	in	r26, 0x3d	; 61
    ac78:	be b7       	in	r27, 0x3e	; 62
    ac7a:	12 96       	adiw	r26, 0x02	; 2
    ac7c:	9c 93       	st	X, r25
    ac7e:	8e 93       	st	-X, r24
    ac80:	11 97       	sbiw	r26, 0x01	; 1
    ac82:	8b ea       	ldi	r24, 0xAB	; 171
    ac84:	9a e0       	ldi	r25, 0x0A	; 10
    ac86:	93 83       	std	Z+3, r25	; 0x03
    ac88:	82 83       	std	Z+2, r24	; 0x02
    ac8a:	87 e7       	ldi	r24, 0x77	; 119
    ac8c:	97 e0       	ldi	r25, 0x07	; 7
    ac8e:	95 83       	std	Z+5, r25	; 0x05
    ac90:	84 83       	std	Z+4, r24	; 0x04
    ac92:	86 e5       	ldi	r24, 0x56	; 86
    ac94:	93 e0       	ldi	r25, 0x03	; 3
    ac96:	97 83       	std	Z+7, r25	; 0x07
    ac98:	86 83       	std	Z+6, r24	; 0x06
    ac9a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    ac9e:	ed b7       	in	r30, 0x3d	; 61
    aca0:	fe b7       	in	r31, 0x3e	; 62
    aca2:	38 96       	adiw	r30, 0x08	; 8
    aca4:	b9 c3       	rjmp	.+1906   	; 0xb418 <PrintIdle+0xbb2>
		       break;
		  case 2:
		       CarriegeReturn();
    aca6:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    acaa:	00 d0       	rcall	.+0      	; 0xacac <PrintIdle+0x446>
    acac:	00 d0       	rcall	.+0      	; 0xacae <PrintIdle+0x448>
    acae:	85 ec       	ldi	r24, 0xC5	; 197
    acb0:	98 e0       	ldi	r25, 0x08	; 8
    acb2:	ad b7       	in	r26, 0x3d	; 61
    acb4:	be b7       	in	r27, 0x3e	; 62
    acb6:	12 96       	adiw	r26, 0x02	; 2
    acb8:	9c 93       	st	X, r25
    acba:	8e 93       	st	-X, r24
    acbc:	11 97       	sbiw	r26, 0x01	; 1
    acbe:	88 e8       	ldi	r24, 0x88	; 136
    acc0:	9a e0       	ldi	r25, 0x0A	; 10
    acc2:	be c3       	rjmp	.+1916   	; 0xb440 <PrintIdle+0xbda>
		       break;
		  case 3:
		       CarriegeReturn();
    acc4:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
    acc8:	ed b7       	in	r30, 0x3d	; 61
    acca:	fe b7       	in	r31, 0x3e	; 62
    accc:	38 97       	sbiw	r30, 0x08	; 8
    acce:	0f b6       	in	r0, 0x3f	; 63
    acd0:	f8 94       	cli
    acd2:	fe bf       	out	0x3e, r31	; 62
    acd4:	0f be       	out	0x3f, r0	; 63
    acd6:	ed bf       	out	0x3d, r30	; 61
    acd8:	31 96       	adiw	r30, 0x01	; 1
    acda:	85 ec       	ldi	r24, 0xC5	; 197
    acdc:	98 e0       	ldi	r25, 0x08	; 8
    acde:	ad b7       	in	r26, 0x3d	; 61
    ace0:	be b7       	in	r27, 0x3e	; 62
    ace2:	12 96       	adiw	r26, 0x02	; 2
    ace4:	9c 93       	st	X, r25
    ace6:	8e 93       	st	-X, r24
    ace8:	11 97       	sbiw	r26, 0x01	; 1
    acea:	8c e6       	ldi	r24, 0x6C	; 108
    acec:	9a e0       	ldi	r25, 0x0A	; 10
    acee:	93 83       	std	Z+3, r25	; 0x03
    acf0:	82 83       	std	Z+2, r24	; 0x02
    acf2:	80 e0       	ldi	r24, 0x00	; 0
    acf4:	99 e0       	ldi	r25, 0x09	; 9
    acf6:	95 83       	std	Z+5, r25	; 0x05
    acf8:	84 83       	std	Z+4, r24	; 0x04
    acfa:	82 ec       	ldi	r24, 0xC2	; 194
    acfc:	97 e0       	ldi	r25, 0x07	; 7
    acfe:	cb cf       	rjmp	.-106    	; 0xac96 <PrintIdle+0x430>
		       break;
		  case 4:
		       CarriegeReturn();
    ad00:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
    ad04:	00 d0       	rcall	.+0      	; 0xad06 <PrintIdle+0x4a0>
    ad06:	00 d0       	rcall	.+0      	; 0xad08 <PrintIdle+0x4a2>
    ad08:	00 d0       	rcall	.+0      	; 0xad0a <PrintIdle+0x4a4>
    ad0a:	ed b7       	in	r30, 0x3d	; 61
    ad0c:	fe b7       	in	r31, 0x3e	; 62
    ad0e:	31 96       	adiw	r30, 0x01	; 1
    ad10:	85 ec       	ldi	r24, 0xC5	; 197
    ad12:	98 e0       	ldi	r25, 0x08	; 8
    ad14:	ad b7       	in	r26, 0x3d	; 61
    ad16:	be b7       	in	r27, 0x3e	; 62
    ad18:	12 96       	adiw	r26, 0x02	; 2
    ad1a:	9c 93       	st	X, r25
    ad1c:	8e 93       	st	-X, r24
    ad1e:	11 97       	sbiw	r26, 0x01	; 1
    ad20:	85 e5       	ldi	r24, 0x55	; 85
    ad22:	9a e0       	ldi	r25, 0x0A	; 10
    ad24:	93 83       	std	Z+3, r25	; 0x03
    ad26:	82 83       	std	Z+2, r24	; 0x02
    ad28:	85 e1       	ldi	r24, 0x15	; 21
    ad2a:	98 e0       	ldi	r25, 0x08	; 8
    ad2c:	6e c3       	rjmp	.+1756   	; 0xb40a <PrintIdle+0xba4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ad2e:	e1 99       	sbic	0x1c, 1	; 28
    ad30:	fe cf       	rjmp	.-4      	; 0xad2e <PrintIdle+0x4c8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ad32:	81 ec       	ldi	r24, 0xC1	; 193
    ad34:	93 e0       	ldi	r25, 0x03	; 3
    ad36:	9f bb       	out	0x1f, r25	; 31
    ad38:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ad3a:	e0 9a       	sbi	0x1c, 0	; 28
    ad3c:	8d b3       	in	r24, 0x1d	; 29
    ad3e:	05 ec       	ldi	r16, 0xC5	; 197
    ad40:	18 e0       	ldi	r17, 0x08	; 8
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    ad42:	81 30       	cpi	r24, 0x01	; 1
    ad44:	a9 f4       	brne	.+42     	; 0xad70 <PrintIdle+0x50a>
			   	   CarriegeReturn();
    ad46:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
    ad4a:	00 d0       	rcall	.+0      	; 0xad4c <PrintIdle+0x4e6>
    ad4c:	00 d0       	rcall	.+0      	; 0xad4e <PrintIdle+0x4e8>
    ad4e:	00 d0       	rcall	.+0      	; 0xad50 <PrintIdle+0x4ea>
    ad50:	ed b7       	in	r30, 0x3d	; 61
    ad52:	fe b7       	in	r31, 0x3e	; 62
    ad54:	31 96       	adiw	r30, 0x01	; 1
    ad56:	ad b7       	in	r26, 0x3d	; 61
    ad58:	be b7       	in	r27, 0x3e	; 62
    ad5a:	12 96       	adiw	r26, 0x02	; 2
    ad5c:	1c 93       	st	X, r17
    ad5e:	0e 93       	st	-X, r16
    ad60:	11 97       	sbiw	r26, 0x01	; 1
    ad62:	8b e3       	ldi	r24, 0x3B	; 59
    ad64:	9a e0       	ldi	r25, 0x0A	; 10
    ad66:	93 83       	std	Z+3, r25	; 0x03
    ad68:	82 83       	std	Z+2, r24	; 0x02
    ad6a:	87 ea       	ldi	r24, 0xA7	; 167
    ad6c:	95 e0       	ldi	r25, 0x05	; 5
    ad6e:	4d c3       	rjmp	.+1690   	; 0xb40a <PrintIdle+0xba4>
			   }else sprintf_P(strPrint,PSTR(""));
    ad70:	00 d0       	rcall	.+0      	; 0xad72 <PrintIdle+0x50c>
    ad72:	00 d0       	rcall	.+0      	; 0xad74 <PrintIdle+0x50e>
    ad74:	ad b7       	in	r26, 0x3d	; 61
    ad76:	be b7       	in	r27, 0x3e	; 62
    ad78:	12 96       	adiw	r26, 0x02	; 2
    ad7a:	1c 93       	st	X, r17
    ad7c:	0e 93       	st	-X, r16
    ad7e:	11 97       	sbiw	r26, 0x01	; 1
    ad80:	8a e3       	ldi	r24, 0x3A	; 58
    ad82:	9a e0       	ldi	r25, 0x0A	; 10
    ad84:	5d c3       	rjmp	.+1722   	; 0xb440 <PrintIdle+0xbda>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
    ad86:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
    ad8a:	00 d0       	rcall	.+0      	; 0xad8c <PrintIdle+0x526>
    ad8c:	00 d0       	rcall	.+0      	; 0xad8e <PrintIdle+0x528>
    ad8e:	00 d0       	rcall	.+0      	; 0xad90 <PrintIdle+0x52a>
    ad90:	ed b7       	in	r30, 0x3d	; 61
    ad92:	fe b7       	in	r31, 0x3e	; 62
    ad94:	31 96       	adiw	r30, 0x01	; 1
    ad96:	85 ec       	ldi	r24, 0xC5	; 197
    ad98:	98 e0       	ldi	r25, 0x08	; 8
    ad9a:	ad b7       	in	r26, 0x3d	; 61
    ad9c:	be b7       	in	r27, 0x3e	; 62
    ad9e:	12 96       	adiw	r26, 0x02	; 2
    ada0:	9c 93       	st	X, r25
    ada2:	8e 93       	st	-X, r24
    ada4:	11 97       	sbiw	r26, 0x01	; 1
    ada6:	81 e2       	ldi	r24, 0x21	; 33
    ada8:	9a e0       	ldi	r25, 0x0A	; 10
    adaa:	93 83       	std	Z+3, r25	; 0x03
    adac:	82 83       	std	Z+2, r24	; 0x02
    adae:	8e e7       	ldi	r24, 0x7E	; 126
    adb0:	93 e0       	ldi	r25, 0x03	; 3
    adb2:	2b c3       	rjmp	.+1622   	; 0xb40a <PrintIdle+0xba4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    adb4:	e1 99       	sbic	0x1c, 1	; 28
    adb6:	fe cf       	rjmp	.-4      	; 0xadb4 <PrintIdle+0x54e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    adb8:	81 ec       	ldi	r24, 0xC1	; 193
    adba:	93 e0       	ldi	r25, 0x03	; 3
    adbc:	9f bb       	out	0x1f, r25	; 31
    adbe:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    adc0:	e0 9a       	sbi	0x1c, 0	; 28
    adc2:	8d b3       	in	r24, 0x1d	; 29
    adc4:	05 ec       	ldi	r16, 0xC5	; 197
    adc6:	18 e0       	ldi	r17, 0x08	; 8
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    adc8:	81 30       	cpi	r24, 0x01	; 1
    adca:	a9 f4       	brne	.+42     	; 0xadf6 <PrintIdle+0x590>
			   	   CarriegeReturn();
    adcc:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
    add0:	00 d0       	rcall	.+0      	; 0xadd2 <PrintIdle+0x56c>
    add2:	00 d0       	rcall	.+0      	; 0xadd4 <PrintIdle+0x56e>
    add4:	00 d0       	rcall	.+0      	; 0xadd6 <PrintIdle+0x570>
    add6:	ed b7       	in	r30, 0x3d	; 61
    add8:	fe b7       	in	r31, 0x3e	; 62
    adda:	31 96       	adiw	r30, 0x01	; 1
    addc:	ad b7       	in	r26, 0x3d	; 61
    adde:	be b7       	in	r27, 0x3e	; 62
    ade0:	12 96       	adiw	r26, 0x02	; 2
    ade2:	1c 93       	st	X, r17
    ade4:	0e 93       	st	-X, r16
    ade6:	11 97       	sbiw	r26, 0x01	; 1
    ade8:	87 e0       	ldi	r24, 0x07	; 7
    adea:	9a e0       	ldi	r25, 0x0A	; 10
    adec:	93 83       	std	Z+3, r25	; 0x03
    adee:	82 83       	std	Z+2, r24	; 0x02
    adf0:	8c eb       	ldi	r24, 0xBC	; 188
    adf2:	9d e0       	ldi	r25, 0x0D	; 13
    adf4:	0a c3       	rjmp	.+1556   	; 0xb40a <PrintIdle+0xba4>
			   }else sprintf_P(strPrint,PSTR(""));
    adf6:	00 d0       	rcall	.+0      	; 0xadf8 <PrintIdle+0x592>
    adf8:	00 d0       	rcall	.+0      	; 0xadfa <PrintIdle+0x594>
    adfa:	ad b7       	in	r26, 0x3d	; 61
    adfc:	be b7       	in	r27, 0x3e	; 62
    adfe:	12 96       	adiw	r26, 0x02	; 2
    ae00:	1c 93       	st	X, r17
    ae02:	0e 93       	st	-X, r16
    ae04:	11 97       	sbiw	r26, 0x01	; 1
    ae06:	86 e0       	ldi	r24, 0x06	; 6
    ae08:	9a e0       	ldi	r25, 0x0A	; 10
    ae0a:	1a c3       	rjmp	.+1588   	; 0xb440 <PrintIdle+0xbda>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
    ae0c:	03 e0       	ldi	r16, 0x03	; 3
    ae0e:	19 e0       	ldi	r17, 0x09	; 9
    ae10:	80 91 03 09 	lds	r24, 0x0903
    ae14:	88 23       	and	r24, r24
    ae16:	09 f4       	brne	.+2      	; 0xae1a <PrintIdle+0x5b4>
    ae18:	18 c2       	rjmp	.+1072   	; 0xb24a <PrintIdle+0x9e4>
    ae1a:	c8 01       	movw	r24, r16
    ae1c:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    ae20:	88 23       	and	r24, r24
    ae22:	09 f0       	breq	.+2      	; 0xae26 <PrintIdle+0x5c0>
    ae24:	12 c2       	rjmp	.+1060   	; 0xb24a <PrintIdle+0x9e4>
			       CarriegeReturn();
    ae26:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
    ae2a:	00 d0       	rcall	.+0      	; 0xae2c <PrintIdle+0x5c6>
    ae2c:	00 d0       	rcall	.+0      	; 0xae2e <PrintIdle+0x5c8>
    ae2e:	00 d0       	rcall	.+0      	; 0xae30 <PrintIdle+0x5ca>
    ae30:	ed b7       	in	r30, 0x3d	; 61
    ae32:	fe b7       	in	r31, 0x3e	; 62
    ae34:	31 96       	adiw	r30, 0x01	; 1
    ae36:	85 ec       	ldi	r24, 0xC5	; 197
    ae38:	98 e0       	ldi	r25, 0x08	; 8
    ae3a:	ad b7       	in	r26, 0x3d	; 61
    ae3c:	be b7       	in	r27, 0x3e	; 62
    ae3e:	12 96       	adiw	r26, 0x02	; 2
    ae40:	9c 93       	st	X, r25
    ae42:	8e 93       	st	-X, r24
    ae44:	11 97       	sbiw	r26, 0x01	; 1
    ae46:	8f ee       	ldi	r24, 0xEF	; 239
    ae48:	99 e0       	ldi	r25, 0x09	; 9
    ae4a:	1f c0       	rjmp	.+62     	; 0xae8a <PrintIdle+0x624>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
    ae4c:	0c ec       	ldi	r16, 0xCC	; 204
    ae4e:	13 e0       	ldi	r17, 0x03	; 3
    ae50:	80 91 cc 03 	lds	r24, 0x03CC
    ae54:	88 23       	and	r24, r24
    ae56:	09 f4       	brne	.+2      	; 0xae5a <PrintIdle+0x5f4>
    ae58:	f8 c1       	rjmp	.+1008   	; 0xb24a <PrintIdle+0x9e4>
    ae5a:	c8 01       	movw	r24, r16
    ae5c:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    ae60:	88 23       	and	r24, r24
    ae62:	09 f0       	breq	.+2      	; 0xae66 <PrintIdle+0x600>
    ae64:	f2 c1       	rjmp	.+996    	; 0xb24a <PrintIdle+0x9e4>
			       CarriegeReturn();
    ae66:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
    ae6a:	00 d0       	rcall	.+0      	; 0xae6c <PrintIdle+0x606>
    ae6c:	00 d0       	rcall	.+0      	; 0xae6e <PrintIdle+0x608>
    ae6e:	00 d0       	rcall	.+0      	; 0xae70 <PrintIdle+0x60a>
    ae70:	ed b7       	in	r30, 0x3d	; 61
    ae72:	fe b7       	in	r31, 0x3e	; 62
    ae74:	31 96       	adiw	r30, 0x01	; 1
    ae76:	85 ec       	ldi	r24, 0xC5	; 197
    ae78:	98 e0       	ldi	r25, 0x08	; 8
    ae7a:	ad b7       	in	r26, 0x3d	; 61
    ae7c:	be b7       	in	r27, 0x3e	; 62
    ae7e:	12 96       	adiw	r26, 0x02	; 2
    ae80:	9c 93       	st	X, r25
    ae82:	8e 93       	st	-X, r24
    ae84:	11 97       	sbiw	r26, 0x01	; 1
    ae86:	88 ed       	ldi	r24, 0xD8	; 216
    ae88:	99 e0       	ldi	r25, 0x09	; 9
    ae8a:	93 83       	std	Z+3, r25	; 0x03
    ae8c:	82 83       	std	Z+2, r24	; 0x02
    ae8e:	15 83       	std	Z+5, r17	; 0x05
    ae90:	04 83       	std	Z+4, r16	; 0x04
    ae92:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				   ClearMem(strOdometer);
    ae96:	ed b7       	in	r30, 0x3d	; 61
    ae98:	fe b7       	in	r31, 0x3e	; 62
    ae9a:	36 96       	adiw	r30, 0x06	; 6
    ae9c:	0f b6       	in	r0, 0x3f	; 63
    ae9e:	f8 94       	cli
    aea0:	fe bf       	out	0x3e, r31	; 62
    aea2:	0f be       	out	0x3f, r0	; 63
    aea4:	ed bf       	out	0x3d, r30	; 61
    aea6:	c8 01       	movw	r24, r16
    aea8:	0e 94 e6 a7 	call	0x14fcc	; 0x14fcc <ClearMem>
    aeac:	d3 c2       	rjmp	.+1446   	; 0xb454 <PrintIdle+0xbee>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
    aeae:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    aeb2:	00 d0       	rcall	.+0      	; 0xaeb4 <PrintIdle+0x64e>
    aeb4:	00 d0       	rcall	.+0      	; 0xaeb6 <PrintIdle+0x650>
    aeb6:	85 ec       	ldi	r24, 0xC5	; 197
    aeb8:	98 e0       	ldi	r25, 0x08	; 8
    aeba:	ad b7       	in	r26, 0x3d	; 61
    aebc:	be b7       	in	r27, 0x3e	; 62
    aebe:	12 96       	adiw	r26, 0x02	; 2
    aec0:	9c 93       	st	X, r25
    aec2:	8e 93       	st	-X, r24
    aec4:	11 97       	sbiw	r26, 0x01	; 1
    aec6:	85 eb       	ldi	r24, 0xB5	; 181
    aec8:	99 e0       	ldi	r25, 0x09	; 9
    aeca:	ba c2       	rjmp	.+1396   	; 0xb440 <PrintIdle+0xbda>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
    aecc:	80 91 ba 01 	lds	r24, 0x01BA
    aed0:	81 30       	cpi	r24, 0x01	; 1
    aed2:	21 f0       	breq	.+8      	; 0xaedc <PrintIdle+0x676>
    aed4:	83 30       	cpi	r24, 0x03	; 3
    aed6:	11 f0       	breq	.+4      	; 0xaedc <PrintIdle+0x676>
    aed8:	86 30       	cpi	r24, 0x06	; 6
    aeda:	b9 f4       	brne	.+46     	; 0xaf0a <PrintIdle+0x6a4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    aedc:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
    aee0:	00 d0       	rcall	.+0      	; 0xaee2 <PrintIdle+0x67c>
    aee2:	00 d0       	rcall	.+0      	; 0xaee4 <PrintIdle+0x67e>
    aee4:	00 d0       	rcall	.+0      	; 0xaee6 <PrintIdle+0x680>
    aee6:	ed b7       	in	r30, 0x3d	; 61
    aee8:	fe b7       	in	r31, 0x3e	; 62
    aeea:	31 96       	adiw	r30, 0x01	; 1
    aeec:	85 ec       	ldi	r24, 0xC5	; 197
    aeee:	98 e0       	ldi	r25, 0x08	; 8
    aef0:	ad b7       	in	r26, 0x3d	; 61
    aef2:	be b7       	in	r27, 0x3e	; 62
    aef4:	12 96       	adiw	r26, 0x02	; 2
    aef6:	9c 93       	st	X, r25
    aef8:	8e 93       	st	-X, r24
    aefa:	11 97       	sbiw	r26, 0x01	; 1
    aefc:	83 ea       	ldi	r24, 0xA3	; 163
    aefe:	99 e0       	ldi	r25, 0x09	; 9
    af00:	93 83       	std	Z+3, r25	; 0x03
    af02:	82 83       	std	Z+2, r24	; 0x02
    af04:	82 e9       	ldi	r24, 0x92	; 146
    af06:	9d e0       	ldi	r25, 0x0D	; 13
    af08:	18 c0       	rjmp	.+48     	; 0xaf3a <PrintIdle+0x6d4>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
    af0a:	87 30       	cpi	r24, 0x07	; 7
    af0c:	f1 f4       	brne	.+60     	; 0xaf4a <PrintIdle+0x6e4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    af0e:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
    af12:	00 d0       	rcall	.+0      	; 0xaf14 <PrintIdle+0x6ae>
    af14:	00 d0       	rcall	.+0      	; 0xaf16 <PrintIdle+0x6b0>
    af16:	00 d0       	rcall	.+0      	; 0xaf18 <PrintIdle+0x6b2>
    af18:	ed b7       	in	r30, 0x3d	; 61
    af1a:	fe b7       	in	r31, 0x3e	; 62
    af1c:	31 96       	adiw	r30, 0x01	; 1
    af1e:	85 ec       	ldi	r24, 0xC5	; 197
    af20:	98 e0       	ldi	r25, 0x08	; 8
    af22:	ad b7       	in	r26, 0x3d	; 61
    af24:	be b7       	in	r27, 0x3e	; 62
    af26:	12 96       	adiw	r26, 0x02	; 2
    af28:	9c 93       	st	X, r25
    af2a:	8e 93       	st	-X, r24
    af2c:	11 97       	sbiw	r26, 0x01	; 1
    af2e:	80 e9       	ldi	r24, 0x90	; 144
    af30:	99 e0       	ldi	r25, 0x09	; 9
    af32:	93 83       	std	Z+3, r25	; 0x03
    af34:	82 83       	std	Z+2, r24	; 0x02
    af36:	81 e5       	ldi	r24, 0x51	; 81
    af38:	9e e0       	ldi	r25, 0x0E	; 14
    af3a:	95 83       	std	Z+5, r25	; 0x05
    af3c:	84 83       	std	Z+4, r24	; 0x04
    af3e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				   IsSignedField=True;
    af42:	81 e0       	ldi	r24, 0x01	; 1
    af44:	80 93 08 02 	sts	0x0208, r24
    af48:	64 c2       	rjmp	.+1224   	; 0xb412 <PrintIdle+0xbac>
    af4a:	05 ec       	ldi	r16, 0xC5	; 197
    af4c:	18 e0       	ldi	r17, 0x08	; 8
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    af4e:	88 30       	cpi	r24, 0x08	; 8
    af50:	09 f0       	breq	.+2      	; 0xaf54 <PrintIdle+0x6ee>
    af52:	a9 cf       	rjmp	.-174    	; 0xaea6 <PrintIdle+0x640>
			       CarriegeReturn();
    af54:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
    af58:	00 d0       	rcall	.+0      	; 0xaf5a <PrintIdle+0x6f4>
    af5a:	00 d0       	rcall	.+0      	; 0xaf5c <PrintIdle+0x6f6>
    af5c:	ad b7       	in	r26, 0x3d	; 61
    af5e:	be b7       	in	r27, 0x3e	; 62
    af60:	12 96       	adiw	r26, 0x02	; 2
    af62:	1c 93       	st	X, r17
    af64:	0e 93       	st	-X, r16
    af66:	11 97       	sbiw	r26, 0x01	; 1
    af68:	8d e6       	ldi	r24, 0x6D	; 109
    af6a:	99 e0       	ldi	r25, 0x09	; 9
    af6c:	14 96       	adiw	r26, 0x04	; 4
    af6e:	9c 93       	st	X, r25
    af70:	8e 93       	st	-X, r24
    af72:	13 97       	sbiw	r26, 0x03	; 3
    af74:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				   IsSignedField=False;
    af78:	10 92 08 02 	sts	0x0208, r1
    af7c:	67 c2       	rjmp	.+1230   	; 0xb44c <PrintIdle+0xbe6>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
    af7e:	80 91 ba 01 	lds	r24, 0x01BA
    af82:	81 30       	cpi	r24, 0x01	; 1
    af84:	99 f4       	brne	.+38     	; 0xafac <PrintIdle+0x746>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    af86:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
    af8a:	00 d0       	rcall	.+0      	; 0xaf8c <PrintIdle+0x726>
    af8c:	00 d0       	rcall	.+0      	; 0xaf8e <PrintIdle+0x728>
    af8e:	00 d0       	rcall	.+0      	; 0xaf90 <PrintIdle+0x72a>
    af90:	ed b7       	in	r30, 0x3d	; 61
    af92:	fe b7       	in	r31, 0x3e	; 62
    af94:	31 96       	adiw	r30, 0x01	; 1
    af96:	85 ec       	ldi	r24, 0xC5	; 197
    af98:	98 e0       	ldi	r25, 0x08	; 8
    af9a:	ad b7       	in	r26, 0x3d	; 61
    af9c:	be b7       	in	r27, 0x3e	; 62
    af9e:	12 96       	adiw	r26, 0x02	; 2
    afa0:	9c 93       	st	X, r25
    afa2:	8e 93       	st	-X, r24
    afa4:	11 97       	sbiw	r26, 0x01	; 1
    afa6:	8b e5       	ldi	r24, 0x5B	; 91
    afa8:	99 e0       	ldi	r25, 0x09	; 9
    afaa:	3a c0       	rjmp	.+116    	; 0xb020 <PrintIdle+0x7ba>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
    afac:	83 30       	cpi	r24, 0x03	; 3
    afae:	e9 f5       	brne	.+122    	; 0xb02a <PrintIdle+0x7c4>
			       if (IsPrintApprovalCode==True){
    afb0:	80 91 9c 01 	lds	r24, 0x019C
    afb4:	81 30       	cpi	r24, 0x01	; 1
    afb6:	11 f5       	brne	.+68     	; 0xaffc <PrintIdle+0x796>
				       IsPrintApprovalCode=False;
    afb8:	10 92 9c 01 	sts	0x019C, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
    afbc:	00 d0       	rcall	.+0      	; 0xafbe <PrintIdle+0x758>
    afbe:	00 d0       	rcall	.+0      	; 0xafc0 <PrintIdle+0x75a>
    afc0:	00 d0       	rcall	.+0      	; 0xafc2 <PrintIdle+0x75c>
    afc2:	ed b7       	in	r30, 0x3d	; 61
    afc4:	fe b7       	in	r31, 0x3e	; 62
    afc6:	31 96       	adiw	r30, 0x01	; 1
    afc8:	8d e2       	ldi	r24, 0x2D	; 45
    afca:	93 e0       	ldi	r25, 0x03	; 3
    afcc:	ad b7       	in	r26, 0x3d	; 61
    afce:	be b7       	in	r27, 0x3e	; 62
    afd0:	12 96       	adiw	r26, 0x02	; 2
    afd2:	9c 93       	st	X, r25
    afd4:	8e 93       	st	-X, r24
    afd6:	11 97       	sbiw	r26, 0x01	; 1
    afd8:	86 e5       	ldi	r24, 0x56	; 86
    afda:	99 e0       	ldi	r25, 0x09	; 9
    afdc:	93 83       	std	Z+3, r25	; 0x03
    afde:	82 83       	std	Z+2, r24	; 0x02
    afe0:	89 ef       	ldi	r24, 0xF9	; 249
    afe2:	97 e0       	ldi	r25, 0x07	; 7
    afe4:	95 83       	std	Z+5, r25	; 0x05
    afe6:	84 83       	std	Z+4, r24	; 0x04
    afe8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    afec:	ed b7       	in	r30, 0x3d	; 61
    afee:	fe b7       	in	r31, 0x3e	; 62
    aff0:	36 96       	adiw	r30, 0x06	; 6
    aff2:	0f b6       	in	r0, 0x3f	; 63
    aff4:	f8 94       	cli
    aff6:	fe bf       	out	0x3e, r31	; 62
    aff8:	0f be       	out	0x3f, r0	; 63
    affa:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    affc:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
    b000:	00 d0       	rcall	.+0      	; 0xb002 <PrintIdle+0x79c>
    b002:	00 d0       	rcall	.+0      	; 0xb004 <PrintIdle+0x79e>
    b004:	00 d0       	rcall	.+0      	; 0xb006 <PrintIdle+0x7a0>
    b006:	ed b7       	in	r30, 0x3d	; 61
    b008:	fe b7       	in	r31, 0x3e	; 62
    b00a:	31 96       	adiw	r30, 0x01	; 1
    b00c:	85 ec       	ldi	r24, 0xC5	; 197
    b00e:	98 e0       	ldi	r25, 0x08	; 8
    b010:	ad b7       	in	r26, 0x3d	; 61
    b012:	be b7       	in	r27, 0x3e	; 62
    b014:	12 96       	adiw	r26, 0x02	; 2
    b016:	9c 93       	st	X, r25
    b018:	8e 93       	st	-X, r24
    b01a:	11 97       	sbiw	r26, 0x01	; 1
    b01c:	84 e4       	ldi	r24, 0x44	; 68
    b01e:	99 e0       	ldi	r25, 0x09	; 9
    b020:	93 83       	std	Z+3, r25	; 0x03
    b022:	82 83       	std	Z+2, r24	; 0x02
    b024:	8d e2       	ldi	r24, 0x2D	; 45
    b026:	93 e0       	ldi	r25, 0x03	; 3
    b028:	f0 c1       	rjmp	.+992    	; 0xb40a <PrintIdle+0xba4>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
    b02a:	87 30       	cpi	r24, 0x07	; 7
    b02c:	79 f4       	brne	.+30     	; 0xb04c <PrintIdle+0x7e6>
			       CarriegeReturn();
    b02e:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
    b032:	00 d0       	rcall	.+0      	; 0xb034 <PrintIdle+0x7ce>
    b034:	00 d0       	rcall	.+0      	; 0xb036 <PrintIdle+0x7d0>
    b036:	85 ec       	ldi	r24, 0xC5	; 197
    b038:	98 e0       	ldi	r25, 0x08	; 8
    b03a:	ad b7       	in	r26, 0x3d	; 61
    b03c:	be b7       	in	r27, 0x3e	; 62
    b03e:	12 96       	adiw	r26, 0x02	; 2
    b040:	9c 93       	st	X, r25
    b042:	8e 93       	st	-X, r24
    b044:	11 97       	sbiw	r26, 0x01	; 1
    b046:	81 e4       	ldi	r24, 0x41	; 65
    b048:	99 e0       	ldi	r25, 0x09	; 9
    b04a:	fa c1       	rjmp	.+1012   	; 0xb440 <PrintIdle+0xbda>
    b04c:	05 ec       	ldi	r16, 0xC5	; 197
    b04e:	18 e0       	ldi	r17, 0x08	; 8
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b050:	88 30       	cpi	r24, 0x08	; 8
    b052:	09 f0       	breq	.+2      	; 0xb056 <PrintIdle+0x7f0>
    b054:	28 cf       	rjmp	.-432    	; 0xaea6 <PrintIdle+0x640>
			       CarriegeReturn();
    b056:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
    b05a:	00 d0       	rcall	.+0      	; 0xb05c <PrintIdle+0x7f6>
    b05c:	00 d0       	rcall	.+0      	; 0xb05e <PrintIdle+0x7f8>
    b05e:	ed b7       	in	r30, 0x3d	; 61
    b060:	fe b7       	in	r31, 0x3e	; 62
    b062:	12 83       	std	Z+2, r17	; 0x02
    b064:	01 83       	std	Z+1, r16	; 0x01
    b066:	8f e2       	ldi	r24, 0x2F	; 47
    b068:	99 e0       	ldi	r25, 0x09	; 9
    b06a:	25 c0       	rjmp	.+74     	; 0xb0b6 <PrintIdle+0x850>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
    b06c:	80 91 08 02 	lds	r24, 0x0208
    b070:	05 ec       	ldi	r16, 0xC5	; 197
    b072:	18 e0       	ldi	r17, 0x08	; 8
    b074:	81 30       	cpi	r24, 0x01	; 1
    b076:	09 f0       	breq	.+2      	; 0xb07a <PrintIdle+0x814>
    b078:	16 cf       	rjmp	.-468    	; 0xaea6 <PrintIdle+0x640>
			       CarriegeReturn();
    b07a:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b07e:	00 d0       	rcall	.+0      	; 0xb080 <PrintIdle+0x81a>
    b080:	00 d0       	rcall	.+0      	; 0xb082 <PrintIdle+0x81c>
    b082:	ad b7       	in	r26, 0x3d	; 61
    b084:	be b7       	in	r27, 0x3e	; 62
    b086:	12 96       	adiw	r26, 0x02	; 2
    b088:	1c 93       	st	X, r17
    b08a:	0e 93       	st	-X, r16
    b08c:	11 97       	sbiw	r26, 0x01	; 1
    b08e:	88 e1       	ldi	r24, 0x18	; 24
    b090:	99 e0       	ldi	r25, 0x09	; 9
    b092:	d6 c1       	rjmp	.+940    	; 0xb440 <PrintIdle+0xbda>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
    b094:	80 91 08 02 	lds	r24, 0x0208
    b098:	05 ec       	ldi	r16, 0xC5	; 197
    b09a:	18 e0       	ldi	r17, 0x08	; 8
    b09c:	81 30       	cpi	r24, 0x01	; 1
    b09e:	09 f0       	breq	.+2      	; 0xb0a2 <PrintIdle+0x83c>
    b0a0:	02 cf       	rjmp	.-508    	; 0xaea6 <PrintIdle+0x640>
			       CarriegeReturn();
    b0a2:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b0a6:	00 d0       	rcall	.+0      	; 0xb0a8 <PrintIdle+0x842>
    b0a8:	00 d0       	rcall	.+0      	; 0xb0aa <PrintIdle+0x844>
    b0aa:	ed b7       	in	r30, 0x3d	; 61
    b0ac:	fe b7       	in	r31, 0x3e	; 62
    b0ae:	12 83       	std	Z+2, r17	; 0x02
    b0b0:	01 83       	std	Z+1, r16	; 0x01
    b0b2:	81 e0       	ldi	r24, 0x01	; 1
    b0b4:	99 e0       	ldi	r25, 0x09	; 9
    b0b6:	94 83       	std	Z+4, r25	; 0x04
    b0b8:	83 83       	std	Z+3, r24	; 0x03
    b0ba:	c6 c1       	rjmp	.+908    	; 0xb448 <PrintIdle+0xbe2>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
    b0bc:	80 91 08 02 	lds	r24, 0x0208
    b0c0:	05 ec       	ldi	r16, 0xC5	; 197
    b0c2:	18 e0       	ldi	r17, 0x08	; 8
    b0c4:	81 30       	cpi	r24, 0x01	; 1
    b0c6:	09 f0       	breq	.+2      	; 0xb0ca <PrintIdle+0x864>
    b0c8:	ee ce       	rjmp	.-548    	; 0xaea6 <PrintIdle+0x640>
			       CarriegeReturn();
    b0ca:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
    b0ce:	00 d0       	rcall	.+0      	; 0xb0d0 <PrintIdle+0x86a>
    b0d0:	00 d0       	rcall	.+0      	; 0xb0d2 <PrintIdle+0x86c>
    b0d2:	ad b7       	in	r26, 0x3d	; 61
    b0d4:	be b7       	in	r27, 0x3e	; 62
    b0d6:	12 96       	adiw	r26, 0x02	; 2
    b0d8:	1c 93       	st	X, r17
    b0da:	0e 93       	st	-X, r16
    b0dc:	11 97       	sbiw	r26, 0x01	; 1
    b0de:	8e ed       	ldi	r24, 0xDE	; 222
    b0e0:	98 e0       	ldi	r25, 0x08	; 8
    b0e2:	ae c1       	rjmp	.+860    	; 0xb440 <PrintIdle+0xbda>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
    b0e4:	80 91 08 02 	lds	r24, 0x0208
    b0e8:	81 30       	cpi	r24, 0x01	; 1
    b0ea:	09 f0       	breq	.+2      	; 0xb0ee <PrintIdle+0x888>
    b0ec:	ae c0       	rjmp	.+348    	; 0xb24a <PrintIdle+0x9e4>
			       IsSignedField=False;
    b0ee:	10 92 08 02 	sts	0x0208, r1
    b0f2:	ab c0       	rjmp	.+342    	; 0xb24a <PrintIdle+0x9e4>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
    b0f4:	80 91 ba 01 	lds	r24, 0x01BA
    b0f8:	05 ec       	ldi	r16, 0xC5	; 197
    b0fa:	18 e0       	ldi	r17, 0x08	; 8
    b0fc:	88 23       	and	r24, r24
    b0fe:	09 f4       	brne	.+2      	; 0xb102 <PrintIdle+0x89c>
    b100:	d2 ce       	rjmp	.-604    	; 0xaea6 <PrintIdle+0x640>
			       CarriegeReturn();
    b102:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
    b106:	00 d0       	rcall	.+0      	; 0xb108 <PrintIdle+0x8a2>
    b108:	00 d0       	rcall	.+0      	; 0xb10a <PrintIdle+0x8a4>
    b10a:	00 d0       	rcall	.+0      	; 0xb10c <PrintIdle+0x8a6>
    b10c:	ed b7       	in	r30, 0x3d	; 61
    b10e:	fe b7       	in	r31, 0x3e	; 62
    b110:	31 96       	adiw	r30, 0x01	; 1
    b112:	ad b7       	in	r26, 0x3d	; 61
    b114:	be b7       	in	r27, 0x3e	; 62
    b116:	12 96       	adiw	r26, 0x02	; 2
    b118:	1c 93       	st	X, r17
    b11a:	0e 93       	st	-X, r16
    b11c:	11 97       	sbiw	r26, 0x01	; 1
    b11e:	86 ed       	ldi	r24, 0xD6	; 214
    b120:	98 e0       	ldi	r25, 0x08	; 8
    b122:	93 83       	std	Z+3, r25	; 0x03
    b124:	82 83       	std	Z+2, r24	; 0x02
    b126:	86 e8       	ldi	r24, 0x86	; 134
    b128:	95 e0       	ldi	r25, 0x05	; 5
    b12a:	6f c1       	rjmp	.+734    	; 0xb40a <PrintIdle+0xba4>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
    b12c:	80 91 ba 01 	lds	r24, 0x01BA
    b130:	05 ec       	ldi	r16, 0xC5	; 197
    b132:	18 e0       	ldi	r17, 0x08	; 8
    b134:	88 23       	and	r24, r24
    b136:	09 f4       	brne	.+2      	; 0xb13a <PrintIdle+0x8d4>
    b138:	b6 ce       	rjmp	.-660    	; 0xaea6 <PrintIdle+0x640>
			       CarriegeReturn();
    b13a:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
    b13e:	00 d0       	rcall	.+0      	; 0xb140 <PrintIdle+0x8da>
    b140:	00 d0       	rcall	.+0      	; 0xb142 <PrintIdle+0x8dc>
    b142:	ad b7       	in	r26, 0x3d	; 61
    b144:	be b7       	in	r27, 0x3e	; 62
    b146:	12 96       	adiw	r26, 0x02	; 2
    b148:	1c 93       	st	X, r17
    b14a:	0e 93       	st	-X, r16
    b14c:	11 97       	sbiw	r26, 0x01	; 1
    b14e:	83 eb       	ldi	r24, 0xB3	; 179
    b150:	98 e0       	ldi	r25, 0x08	; 8
    b152:	76 c1       	rjmp	.+748    	; 0xb440 <PrintIdle+0xbda>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
    b154:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
    b158:	00 d0       	rcall	.+0      	; 0xb15a <PrintIdle+0x8f4>
    b15a:	00 d0       	rcall	.+0      	; 0xb15c <PrintIdle+0x8f6>
    b15c:	85 ec       	ldi	r24, 0xC5	; 197
    b15e:	98 e0       	ldi	r25, 0x08	; 8
    b160:	ed b7       	in	r30, 0x3d	; 61
    b162:	fe b7       	in	r31, 0x3e	; 62
    b164:	92 83       	std	Z+2, r25	; 0x02
    b166:	81 83       	std	Z+1, r24	; 0x01
    b168:	80 e9       	ldi	r24, 0x90	; 144
    b16a:	98 e0       	ldi	r25, 0x08	; 8
    b16c:	a4 cf       	rjmp	.-184    	; 0xb0b6 <PrintIdle+0x850>
		       break; 			            
		  case 22:
		       CarriegeReturn();
    b16e:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
    b172:	00 d0       	rcall	.+0      	; 0xb174 <PrintIdle+0x90e>
    b174:	00 d0       	rcall	.+0      	; 0xb176 <PrintIdle+0x910>
    b176:	00 d0       	rcall	.+0      	; 0xb178 <PrintIdle+0x912>
    b178:	ed b7       	in	r30, 0x3d	; 61
    b17a:	fe b7       	in	r31, 0x3e	; 62
    b17c:	31 96       	adiw	r30, 0x01	; 1
    b17e:	85 ec       	ldi	r24, 0xC5	; 197
    b180:	98 e0       	ldi	r25, 0x08	; 8
    b182:	ad b7       	in	r26, 0x3d	; 61
    b184:	be b7       	in	r27, 0x3e	; 62
    b186:	12 96       	adiw	r26, 0x02	; 2
    b188:	9c 93       	st	X, r25
    b18a:	8e 93       	st	-X, r24
    b18c:	11 97       	sbiw	r26, 0x01	; 1
    b18e:	89 e7       	ldi	r24, 0x79	; 121
    b190:	98 e0       	ldi	r25, 0x08	; 8
    b192:	93 83       	std	Z+3, r25	; 0x03
    b194:	82 83       	std	Z+2, r24	; 0x02
    b196:	80 ef       	ldi	r24, 0xF0	; 240
    b198:	92 e0       	ldi	r25, 0x02	; 2
    b19a:	37 c1       	rjmp	.+622    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 23:
		       CarriegeReturn();
    b19c:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
    b1a0:	00 d0       	rcall	.+0      	; 0xb1a2 <PrintIdle+0x93c>
    b1a2:	00 d0       	rcall	.+0      	; 0xb1a4 <PrintIdle+0x93e>
    b1a4:	00 d0       	rcall	.+0      	; 0xb1a6 <PrintIdle+0x940>
    b1a6:	ed b7       	in	r30, 0x3d	; 61
    b1a8:	fe b7       	in	r31, 0x3e	; 62
    b1aa:	31 96       	adiw	r30, 0x01	; 1
    b1ac:	85 ec       	ldi	r24, 0xC5	; 197
    b1ae:	98 e0       	ldi	r25, 0x08	; 8
    b1b0:	ad b7       	in	r26, 0x3d	; 61
    b1b2:	be b7       	in	r27, 0x3e	; 62
    b1b4:	12 96       	adiw	r26, 0x02	; 2
    b1b6:	9c 93       	st	X, r25
    b1b8:	8e 93       	st	-X, r24
    b1ba:	11 97       	sbiw	r26, 0x01	; 1
    b1bc:	81 e6       	ldi	r24, 0x61	; 97
    b1be:	98 e0       	ldi	r25, 0x08	; 8
    b1c0:	93 83       	std	Z+3, r25	; 0x03
    b1c2:	82 83       	std	Z+2, r24	; 0x02
    b1c4:	8d ec       	ldi	r24, 0xCD	; 205
    b1c6:	92 e0       	ldi	r25, 0x02	; 2
    b1c8:	20 c1       	rjmp	.+576    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
    b1ca:	0b e1       	ldi	r16, 0x1B	; 27
    b1cc:	1e e0       	ldi	r17, 0x0E	; 14
    b1ce:	80 91 1b 0e 	lds	r24, 0x0E1B
    b1d2:	88 23       	and	r24, r24
    b1d4:	d1 f1       	breq	.+116    	; 0xb24a <PrintIdle+0x9e4>
    b1d6:	c8 01       	movw	r24, r16
    b1d8:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    b1dc:	88 23       	and	r24, r24
    b1de:	a9 f5       	brne	.+106    	; 0xb24a <PrintIdle+0x9e4>
		           CarriegeReturn();
    b1e0:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
    b1e4:	00 d0       	rcall	.+0      	; 0xb1e6 <PrintIdle+0x980>
    b1e6:	00 d0       	rcall	.+0      	; 0xb1e8 <PrintIdle+0x982>
    b1e8:	00 d0       	rcall	.+0      	; 0xb1ea <PrintIdle+0x984>
    b1ea:	ed b7       	in	r30, 0x3d	; 61
    b1ec:	fe b7       	in	r31, 0x3e	; 62
    b1ee:	31 96       	adiw	r30, 0x01	; 1
    b1f0:	85 ec       	ldi	r24, 0xC5	; 197
    b1f2:	98 e0       	ldi	r25, 0x08	; 8
    b1f4:	ad b7       	in	r26, 0x3d	; 61
    b1f6:	be b7       	in	r27, 0x3e	; 62
    b1f8:	12 96       	adiw	r26, 0x02	; 2
    b1fa:	9c 93       	st	X, r25
    b1fc:	8e 93       	st	-X, r24
    b1fe:	11 97       	sbiw	r26, 0x01	; 1
    b200:	8a e4       	ldi	r24, 0x4A	; 74
    b202:	98 e0       	ldi	r25, 0x08	; 8
    b204:	1d c0       	rjmp	.+58     	; 0xb240 <PrintIdle+0x9da>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
    b206:	06 ed       	ldi	r16, 0xD6	; 214
    b208:	13 e0       	ldi	r17, 0x03	; 3
    b20a:	80 91 d6 03 	lds	r24, 0x03D6
    b20e:	88 23       	and	r24, r24
    b210:	e1 f0       	breq	.+56     	; 0xb24a <PrintIdle+0x9e4>
    b212:	c8 01       	movw	r24, r16
    b214:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    b218:	88 23       	and	r24, r24
    b21a:	b9 f4       	brne	.+46     	; 0xb24a <PrintIdle+0x9e4>
		           CarriegeReturn();
    b21c:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
    b220:	00 d0       	rcall	.+0      	; 0xb222 <PrintIdle+0x9bc>
    b222:	00 d0       	rcall	.+0      	; 0xb224 <PrintIdle+0x9be>
    b224:	00 d0       	rcall	.+0      	; 0xb226 <PrintIdle+0x9c0>
    b226:	ed b7       	in	r30, 0x3d	; 61
    b228:	fe b7       	in	r31, 0x3e	; 62
    b22a:	31 96       	adiw	r30, 0x01	; 1
    b22c:	85 ec       	ldi	r24, 0xC5	; 197
    b22e:	98 e0       	ldi	r25, 0x08	; 8
    b230:	ad b7       	in	r26, 0x3d	; 61
    b232:	be b7       	in	r27, 0x3e	; 62
    b234:	12 96       	adiw	r26, 0x02	; 2
    b236:	9c 93       	st	X, r25
    b238:	8e 93       	st	-X, r24
    b23a:	11 97       	sbiw	r26, 0x01	; 1
    b23c:	83 e3       	ldi	r24, 0x33	; 51
    b23e:	98 e0       	ldi	r25, 0x08	; 8
    b240:	93 83       	std	Z+3, r25	; 0x03
    b242:	82 83       	std	Z+2, r24	; 0x02
    b244:	15 83       	std	Z+5, r17	; 0x05
    b246:	04 83       	std	Z+4, r16	; 0x04
    b248:	e2 c0       	rjmp	.+452    	; 0xb40e <PrintIdle+0xba8>
			   }else ClearMem(strPrint);
    b24a:	85 ec       	ldi	r24, 0xC5	; 197
    b24c:	98 e0       	ldi	r25, 0x08	; 8
    b24e:	2c ce       	rjmp	.-936    	; 0xaea8 <PrintIdle+0x642>
		       break;
		  case 26:
		       CarriegeReturn();
    b250:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
    b254:	00 d0       	rcall	.+0      	; 0xb256 <PrintIdle+0x9f0>
    b256:	00 d0       	rcall	.+0      	; 0xb258 <PrintIdle+0x9f2>
    b258:	00 d0       	rcall	.+0      	; 0xb25a <PrintIdle+0x9f4>
    b25a:	ed b7       	in	r30, 0x3d	; 61
    b25c:	fe b7       	in	r31, 0x3e	; 62
    b25e:	31 96       	adiw	r30, 0x01	; 1
    b260:	85 ec       	ldi	r24, 0xC5	; 197
    b262:	98 e0       	ldi	r25, 0x08	; 8
    b264:	ad b7       	in	r26, 0x3d	; 61
    b266:	be b7       	in	r27, 0x3e	; 62
    b268:	12 96       	adiw	r26, 0x02	; 2
    b26a:	9c 93       	st	X, r25
    b26c:	8e 93       	st	-X, r24
    b26e:	11 97       	sbiw	r26, 0x01	; 1
    b270:	8c e1       	ldi	r24, 0x1C	; 28
    b272:	98 e0       	ldi	r25, 0x08	; 8
    b274:	93 83       	std	Z+3, r25	; 0x03
    b276:	82 83       	std	Z+2, r24	; 0x02
    b278:	84 ec       	ldi	r24, 0xC4	; 196
    b27a:	92 e0       	ldi	r25, 0x02	; 2
    b27c:	c6 c0       	rjmp	.+396    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 27:
		       CarriegeReturn();
    b27e:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
    b282:	00 d0       	rcall	.+0      	; 0xb284 <PrintIdle+0xa1e>
    b284:	00 d0       	rcall	.+0      	; 0xb286 <PrintIdle+0xa20>
    b286:	00 d0       	rcall	.+0      	; 0xb288 <PrintIdle+0xa22>
    b288:	ed b7       	in	r30, 0x3d	; 61
    b28a:	fe b7       	in	r31, 0x3e	; 62
    b28c:	31 96       	adiw	r30, 0x01	; 1
    b28e:	85 ec       	ldi	r24, 0xC5	; 197
    b290:	98 e0       	ldi	r25, 0x08	; 8
    b292:	ad b7       	in	r26, 0x3d	; 61
    b294:	be b7       	in	r27, 0x3e	; 62
    b296:	12 96       	adiw	r26, 0x02	; 2
    b298:	9c 93       	st	X, r25
    b29a:	8e 93       	st	-X, r24
    b29c:	11 97       	sbiw	r26, 0x01	; 1
    b29e:	85 e0       	ldi	r24, 0x05	; 5
    b2a0:	98 e0       	ldi	r25, 0x08	; 8
    b2a2:	93 83       	std	Z+3, r25	; 0x03
    b2a4:	82 83       	std	Z+2, r24	; 0x02
    b2a6:	8d e1       	ldi	r24, 0x1D	; 29
    b2a8:	9b e0       	ldi	r25, 0x0B	; 11
    b2aa:	af c0       	rjmp	.+350    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 28:
		       CarriegeReturn();
    b2ac:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
    b2b0:	00 d0       	rcall	.+0      	; 0xb2b2 <PrintIdle+0xa4c>
    b2b2:	00 d0       	rcall	.+0      	; 0xb2b4 <PrintIdle+0xa4e>
    b2b4:	00 d0       	rcall	.+0      	; 0xb2b6 <PrintIdle+0xa50>
    b2b6:	ed b7       	in	r30, 0x3d	; 61
    b2b8:	fe b7       	in	r31, 0x3e	; 62
    b2ba:	31 96       	adiw	r30, 0x01	; 1
    b2bc:	85 ec       	ldi	r24, 0xC5	; 197
    b2be:	98 e0       	ldi	r25, 0x08	; 8
    b2c0:	ad b7       	in	r26, 0x3d	; 61
    b2c2:	be b7       	in	r27, 0x3e	; 62
    b2c4:	12 96       	adiw	r26, 0x02	; 2
    b2c6:	9c 93       	st	X, r25
    b2c8:	8e 93       	st	-X, r24
    b2ca:	11 97       	sbiw	r26, 0x01	; 1
    b2cc:	8e ee       	ldi	r24, 0xEE	; 238
    b2ce:	97 e0       	ldi	r25, 0x07	; 7
    b2d0:	93 83       	std	Z+3, r25	; 0x03
    b2d2:	82 83       	std	Z+2, r24	; 0x02
    b2d4:	8e e3       	ldi	r24, 0x3E	; 62
    b2d6:	98 e0       	ldi	r25, 0x08	; 8
    b2d8:	98 c0       	rjmp	.+304    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 29:
		       CarriegeReturn();
    b2da:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
    b2de:	00 d0       	rcall	.+0      	; 0xb2e0 <PrintIdle+0xa7a>
    b2e0:	00 d0       	rcall	.+0      	; 0xb2e2 <PrintIdle+0xa7c>
    b2e2:	00 d0       	rcall	.+0      	; 0xb2e4 <PrintIdle+0xa7e>
    b2e4:	ed b7       	in	r30, 0x3d	; 61
    b2e6:	fe b7       	in	r31, 0x3e	; 62
    b2e8:	31 96       	adiw	r30, 0x01	; 1
    b2ea:	85 ec       	ldi	r24, 0xC5	; 197
    b2ec:	98 e0       	ldi	r25, 0x08	; 8
    b2ee:	ad b7       	in	r26, 0x3d	; 61
    b2f0:	be b7       	in	r27, 0x3e	; 62
    b2f2:	12 96       	adiw	r26, 0x02	; 2
    b2f4:	9c 93       	st	X, r25
    b2f6:	8e 93       	st	-X, r24
    b2f8:	11 97       	sbiw	r26, 0x01	; 1
    b2fa:	87 ed       	ldi	r24, 0xD7	; 215
    b2fc:	97 e0       	ldi	r25, 0x07	; 7
    b2fe:	93 83       	std	Z+3, r25	; 0x03
    b300:	82 83       	std	Z+2, r24	; 0x02
    b302:	82 e9       	ldi	r24, 0x92	; 146
    b304:	9e e0       	ldi	r25, 0x0E	; 14
    b306:	81 c0       	rjmp	.+258    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 30:
		       CarriegeReturn();
    b308:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
    b30c:	00 d0       	rcall	.+0      	; 0xb30e <PrintIdle+0xaa8>
    b30e:	00 d0       	rcall	.+0      	; 0xb310 <PrintIdle+0xaaa>
    b310:	00 d0       	rcall	.+0      	; 0xb312 <PrintIdle+0xaac>
    b312:	ed b7       	in	r30, 0x3d	; 61
    b314:	fe b7       	in	r31, 0x3e	; 62
    b316:	31 96       	adiw	r30, 0x01	; 1
    b318:	85 ec       	ldi	r24, 0xC5	; 197
    b31a:	98 e0       	ldi	r25, 0x08	; 8
    b31c:	ad b7       	in	r26, 0x3d	; 61
    b31e:	be b7       	in	r27, 0x3e	; 62
    b320:	12 96       	adiw	r26, 0x02	; 2
    b322:	9c 93       	st	X, r25
    b324:	8e 93       	st	-X, r24
    b326:	11 97       	sbiw	r26, 0x01	; 1
    b328:	80 ec       	ldi	r24, 0xC0	; 192
    b32a:	97 e0       	ldi	r25, 0x07	; 7
    b32c:	93 83       	std	Z+3, r25	; 0x03
    b32e:	82 83       	std	Z+2, r24	; 0x02
    b330:	83 ea       	ldi	r24, 0xA3	; 163
    b332:	93 e0       	ldi	r25, 0x03	; 3
    b334:	6a c0       	rjmp	.+212    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 31:
		       CarriegeReturn();
    b336:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
    b33a:	00 d0       	rcall	.+0      	; 0xb33c <PrintIdle+0xad6>
    b33c:	00 d0       	rcall	.+0      	; 0xb33e <PrintIdle+0xad8>
    b33e:	00 d0       	rcall	.+0      	; 0xb340 <PrintIdle+0xada>
    b340:	ed b7       	in	r30, 0x3d	; 61
    b342:	fe b7       	in	r31, 0x3e	; 62
    b344:	31 96       	adiw	r30, 0x01	; 1
    b346:	85 ec       	ldi	r24, 0xC5	; 197
    b348:	98 e0       	ldi	r25, 0x08	; 8
    b34a:	ad b7       	in	r26, 0x3d	; 61
    b34c:	be b7       	in	r27, 0x3e	; 62
    b34e:	12 96       	adiw	r26, 0x02	; 2
    b350:	9c 93       	st	X, r25
    b352:	8e 93       	st	-X, r24
    b354:	11 97       	sbiw	r26, 0x01	; 1
    b356:	87 ea       	ldi	r24, 0xA7	; 167
    b358:	97 e0       	ldi	r25, 0x07	; 7
    b35a:	93 83       	std	Z+3, r25	; 0x03
    b35c:	82 83       	std	Z+2, r24	; 0x02
    b35e:	8a ef       	ldi	r24, 0xFA	; 250
    b360:	9d e0       	ldi	r25, 0x0D	; 13
    b362:	53 c0       	rjmp	.+166    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 32:
		       CarriegeReturn();
    b364:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
    b368:	00 d0       	rcall	.+0      	; 0xb36a <PrintIdle+0xb04>
    b36a:	00 d0       	rcall	.+0      	; 0xb36c <PrintIdle+0xb06>
    b36c:	00 d0       	rcall	.+0      	; 0xb36e <PrintIdle+0xb08>
    b36e:	ed b7       	in	r30, 0x3d	; 61
    b370:	fe b7       	in	r31, 0x3e	; 62
    b372:	31 96       	adiw	r30, 0x01	; 1
    b374:	85 ec       	ldi	r24, 0xC5	; 197
    b376:	98 e0       	ldi	r25, 0x08	; 8
    b378:	ad b7       	in	r26, 0x3d	; 61
    b37a:	be b7       	in	r27, 0x3e	; 62
    b37c:	12 96       	adiw	r26, 0x02	; 2
    b37e:	9c 93       	st	X, r25
    b380:	8e 93       	st	-X, r24
    b382:	11 97       	sbiw	r26, 0x01	; 1
    b384:	8d e8       	ldi	r24, 0x8D	; 141
    b386:	97 e0       	ldi	r25, 0x07	; 7
    b388:	93 83       	std	Z+3, r25	; 0x03
    b38a:	82 83       	std	Z+2, r24	; 0x02
    b38c:	87 e8       	ldi	r24, 0x87	; 135
    b38e:	93 e0       	ldi	r25, 0x03	; 3
    b390:	3c c0       	rjmp	.+120    	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
    b392:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b396:	00 d0       	rcall	.+0      	; 0xb398 <PrintIdle+0xb32>
    b398:	00 d0       	rcall	.+0      	; 0xb39a <PrintIdle+0xb34>
    b39a:	85 ec       	ldi	r24, 0xC5	; 197
    b39c:	98 e0       	ldi	r25, 0x08	; 8
    b39e:	ad b7       	in	r26, 0x3d	; 61
    b3a0:	be b7       	in	r27, 0x3e	; 62
    b3a2:	12 96       	adiw	r26, 0x02	; 2
    b3a4:	9c 93       	st	X, r25
    b3a6:	8e 93       	st	-X, r24
    b3a8:	11 97       	sbiw	r26, 0x01	; 1
    b3aa:	8a e6       	ldi	r24, 0x6A	; 106
    b3ac:	97 e0       	ldi	r25, 0x07	; 7
    b3ae:	48 c0       	rjmp	.+144    	; 0xb440 <PrintIdle+0xbda>
		       break;
		  case 34:
		       CarriegeReturn();
    b3b0:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
    b3b4:	00 d0       	rcall	.+0      	; 0xb3b6 <PrintIdle+0xb50>
    b3b6:	00 d0       	rcall	.+0      	; 0xb3b8 <PrintIdle+0xb52>
    b3b8:	00 d0       	rcall	.+0      	; 0xb3ba <PrintIdle+0xb54>
    b3ba:	ed b7       	in	r30, 0x3d	; 61
    b3bc:	fe b7       	in	r31, 0x3e	; 62
    b3be:	31 96       	adiw	r30, 0x01	; 1
    b3c0:	85 ec       	ldi	r24, 0xC5	; 197
    b3c2:	98 e0       	ldi	r25, 0x08	; 8
    b3c4:	ad b7       	in	r26, 0x3d	; 61
    b3c6:	be b7       	in	r27, 0x3e	; 62
    b3c8:	12 96       	adiw	r26, 0x02	; 2
    b3ca:	9c 93       	st	X, r25
    b3cc:	8e 93       	st	-X, r24
    b3ce:	11 97       	sbiw	r26, 0x01	; 1
    b3d0:	83 e5       	ldi	r24, 0x53	; 83
    b3d2:	97 e0       	ldi	r25, 0x07	; 7
    b3d4:	93 83       	std	Z+3, r25	; 0x03
    b3d6:	82 83       	std	Z+2, r24	; 0x02
    b3d8:	84 ee       	ldi	r24, 0xE4	; 228
    b3da:	97 e0       	ldi	r25, 0x07	; 7
    b3dc:	16 c0       	rjmp	.+44     	; 0xb40a <PrintIdle+0xba4>
		       break;
		  case 35:
		       CarriegeReturn();
    b3de:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
    b3e2:	00 d0       	rcall	.+0      	; 0xb3e4 <PrintIdle+0xb7e>
    b3e4:	00 d0       	rcall	.+0      	; 0xb3e6 <PrintIdle+0xb80>
    b3e6:	00 d0       	rcall	.+0      	; 0xb3e8 <PrintIdle+0xb82>
    b3e8:	ed b7       	in	r30, 0x3d	; 61
    b3ea:	fe b7       	in	r31, 0x3e	; 62
    b3ec:	31 96       	adiw	r30, 0x01	; 1
    b3ee:	85 ec       	ldi	r24, 0xC5	; 197
    b3f0:	98 e0       	ldi	r25, 0x08	; 8
    b3f2:	ad b7       	in	r26, 0x3d	; 61
    b3f4:	be b7       	in	r27, 0x3e	; 62
    b3f6:	12 96       	adiw	r26, 0x02	; 2
    b3f8:	9c 93       	st	X, r25
    b3fa:	8e 93       	st	-X, r24
    b3fc:	11 97       	sbiw	r26, 0x01	; 1
    b3fe:	8c e3       	ldi	r24, 0x3C	; 60
    b400:	97 e0       	ldi	r25, 0x07	; 7
    b402:	93 83       	std	Z+3, r25	; 0x03
    b404:	82 83       	std	Z+2, r24	; 0x02
    b406:	8b e5       	ldi	r24, 0x5B	; 91
    b408:	98 e0       	ldi	r25, 0x08	; 8
    b40a:	95 83       	std	Z+5, r25	; 0x05
    b40c:	84 83       	std	Z+4, r24	; 0x04
    b40e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    b412:	ed b7       	in	r30, 0x3d	; 61
    b414:	fe b7       	in	r31, 0x3e	; 62
    b416:	36 96       	adiw	r30, 0x06	; 6
    b418:	0f b6       	in	r0, 0x3f	; 63
    b41a:	f8 94       	cli
    b41c:	fe bf       	out	0x3e, r31	; 62
    b41e:	0f be       	out	0x3f, r0	; 63
    b420:	ed bf       	out	0x3d, r30	; 61
    b422:	18 c0       	rjmp	.+48     	; 0xb454 <PrintIdle+0xbee>
		       break;
		  case 36:
		       CarriegeReturn();
    b424:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b428:	00 d0       	rcall	.+0      	; 0xb42a <PrintIdle+0xbc4>
    b42a:	00 d0       	rcall	.+0      	; 0xb42c <PrintIdle+0xbc6>
    b42c:	85 ec       	ldi	r24, 0xC5	; 197
    b42e:	98 e0       	ldi	r25, 0x08	; 8
    b430:	ad b7       	in	r26, 0x3d	; 61
    b432:	be b7       	in	r27, 0x3e	; 62
    b434:	12 96       	adiw	r26, 0x02	; 2
    b436:	9c 93       	st	X, r25
    b438:	8e 93       	st	-X, r24
    b43a:	11 97       	sbiw	r26, 0x01	; 1
    b43c:	89 e1       	ldi	r24, 0x19	; 25
    b43e:	97 e0       	ldi	r25, 0x07	; 7
    b440:	14 96       	adiw	r26, 0x04	; 4
    b442:	9c 93       	st	X, r25
    b444:	8e 93       	st	-X, r24
    b446:	13 97       	sbiw	r26, 0x03	; 3
    b448:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    b44c:	0f 90       	pop	r0
    b44e:	0f 90       	pop	r0
    b450:	0f 90       	pop	r0
    b452:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
    b454:	10 92 03 02 	sts	0x0203, r1
    b458:	10 92 02 02 	sts	0x0202, r1
    b45c:	10 92 07 02 	sts	0x0207, r1
    b460:	10 92 06 02 	sts	0x0206, r1
    b464:	e5 ec       	ldi	r30, 0xC5	; 197
    b466:	f8 e0       	ldi	r31, 0x08	; 8
    b468:	01 90       	ld	r0, Z+
    b46a:	00 20       	and	r0, r0
    b46c:	e9 f7       	brne	.-6      	; 0xb468 <PrintIdle+0xc02>
    b46e:	31 97       	sbiw	r30, 0x01	; 1
    b470:	e5 5c       	subi	r30, 0xC5	; 197
    b472:	f8 40       	sbci	r31, 0x08	; 8
    b474:	f0 93 05 02 	sts	0x0205, r31
    b478:	e0 93 04 02 	sts	0x0204, r30
          stPrintIdle=piPrintMessage;
    b47c:	8a e0       	ldi	r24, 0x0A	; 10
    b47e:	7e c1       	rjmp	.+764    	; 0xb77c <PrintIdle+0xf16>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
    b480:	20 91 06 02 	lds	r18, 0x0206
    b484:	30 91 07 02 	lds	r19, 0x0207
    b488:	80 91 04 02 	lds	r24, 0x0204
    b48c:	90 91 05 02 	lds	r25, 0x0205
    b490:	28 17       	cp	r18, r24
    b492:	39 07       	cpc	r19, r25
    b494:	68 f4       	brcc	.+26     	; 0xb4b0 <PrintIdle+0xc4a>
		      iLoop++;
    b496:	80 91 02 02 	lds	r24, 0x0202
    b49a:	90 91 03 02 	lds	r25, 0x0203
    b49e:	01 96       	adiw	r24, 0x01	; 1
    b4a0:	90 93 03 02 	sts	0x0203, r25
    b4a4:	80 93 02 02 	sts	0x0202, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    b4a8:	10 92 b8 01 	sts	0x01B8, r1
				 stPrintIdle=piCheckPrintStatusMessage;
    b4ac:	8c e0       	ldi	r24, 0x0C	; 12
    b4ae:	66 c1       	rjmp	.+716    	; 0xb77c <PrintIdle+0xf16>
				 }
			  }
          else{iMessage++;
    b4b0:	80 91 0a 02 	lds	r24, 0x020A
    b4b4:	8f 5f       	subi	r24, 0xFF	; 255
    b4b6:	80 93 0a 02 	sts	0x020A, r24
		      if (iMessage>MessageLine){
    b4ba:	90 91 09 02 	lds	r25, 0x0209
    b4be:	98 17       	cp	r25, r24
    b4c0:	30 f4       	brcc	.+12     	; 0xb4ce <PrintIdle+0xc68>
			      iFooter=0;				  
    b4c2:	10 92 0d 02 	sts	0x020D, r1
				  CarriegeReturn();
    b4c6:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
				  stPrintIdle=piLoadOperatorName;//piLoadFooter;
    b4ca:	85 e1       	ldi	r24, 0x15	; 21
    b4cc:	57 c1       	rjmp	.+686    	; 0xb77c <PrintIdle+0xf16>
			  }
			  else stPrintIdle=piLoadMessage;
    b4ce:	89 e0       	ldi	r24, 0x09	; 9
    b4d0:	55 c1       	rjmp	.+682    	; 0xb77c <PrintIdle+0xf16>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    b4d2:	80 91 b5 01 	lds	r24, 0x01B5
    b4d6:	88 23       	and	r24, r24
    b4d8:	09 f0       	breq	.+2      	; 0xb4dc <PrintIdle+0xc76>
    b4da:	48 c1       	rjmp	.+656    	; 0xb76c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    b4dc:	e0 91 06 02 	lds	r30, 0x0206
    b4e0:	f0 91 07 02 	lds	r31, 0x0207
    b4e4:	eb 53       	subi	r30, 0x3B	; 59
    b4e6:	f7 4f       	sbci	r31, 0xF7	; 247
    b4e8:	61 e0       	ldi	r22, 0x01	; 1
    b4ea:	40 81       	ld	r20, Z
    b4ec:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    b4f0:	80 91 06 02 	lds	r24, 0x0206
    b4f4:	90 91 07 02 	lds	r25, 0x0207
    b4f8:	01 96       	adiw	r24, 0x01	; 1
    b4fa:	90 93 07 02 	sts	0x0207, r25
    b4fe:	80 93 06 02 	sts	0x0206, r24
		      stPrintIdle=piPrintMessage;
    b502:	8a e0       	ldi	r24, 0x0A	; 10
    b504:	31 c1       	rjmp	.+610    	; 0xb768 <PrintIdle+0xf02>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    b506:	8e 01       	movw	r16, r28
    b508:	0f 5f       	subi	r16, 0xFF	; 255
    b50a:	1f 4f       	sbci	r17, 0xFF	; 255
    b50c:	c8 01       	movw	r24, r16
    b50e:	65 e1       	ldi	r22, 0x15	; 21
    b510:	70 e0       	ldi	r23, 0x00	; 0
    b512:	42 e1       	ldi	r20, 0x12	; 18
    b514:	50 e0       	ldi	r21, 0x00	; 0
    b516:	22 e4       	ldi	r18, 0x42	; 66
    b518:	33 e1       	ldi	r19, 0x13	; 19
    b51a:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b51e:	ce 01       	movw	r24, r28
    b520:	40 96       	adiw	r24, 0x10	; 16
	    Dest[i]=Source[IdxSource+i];
    b522:	0f 5f       	subi	r16, 0xFF	; 255
    b524:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b526:	08 17       	cp	r16, r24
    b528:	19 07       	cpc	r17, r25
    b52a:	d9 f7       	brne	.-10     	; 0xb522 <PrintIdle+0xcbc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b52c:	18 8a       	std	Y+16, r1	; 0x10
	//Added Operator Name:
	 case piLoadOperatorName:
	      //CheckEmpty
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);
		  if (strlen(strOperatorName)>0){
    b52e:	89 81       	ldd	r24, Y+1	; 0x01
    b530:	88 23       	and	r24, r24
    b532:	09 f4       	brne	.+2      	; 0xb536 <PrintIdle+0xcd0>
    b534:	95 c0       	rjmp	.+298    	; 0xb660 <PrintIdle+0xdfa>
			  if (SpaceOnly(strOperatorName)!=True){		      				  
    b536:	7e 01       	movw	r14, r28
    b538:	08 94       	sec
    b53a:	e1 1c       	adc	r14, r1
    b53c:	f1 1c       	adc	r15, r1
    b53e:	c7 01       	movw	r24, r14
    b540:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    b544:	81 30       	cpi	r24, 0x01	; 1
    b546:	09 f4       	brne	.+2      	; 0xb54a <PrintIdle+0xce4>
    b548:	8b c0       	rjmp	.+278    	; 0xb660 <PrintIdle+0xdfa>
				  sprintf_P(strPrint,PSTR("     Operator: %s"),strOperatorName);			   
    b54a:	00 d0       	rcall	.+0      	; 0xb54c <PrintIdle+0xce6>
    b54c:	00 d0       	rcall	.+0      	; 0xb54e <PrintIdle+0xce8>
    b54e:	00 d0       	rcall	.+0      	; 0xb550 <PrintIdle+0xcea>
    b550:	ed b7       	in	r30, 0x3d	; 61
    b552:	fe b7       	in	r31, 0x3e	; 62
    b554:	31 96       	adiw	r30, 0x01	; 1
    b556:	05 ec       	ldi	r16, 0xC5	; 197
    b558:	18 e0       	ldi	r17, 0x08	; 8
    b55a:	ad b7       	in	r26, 0x3d	; 61
    b55c:	be b7       	in	r27, 0x3e	; 62
    b55e:	12 96       	adiw	r26, 0x02	; 2
    b560:	1c 93       	st	X, r17
    b562:	0e 93       	st	-X, r16
    b564:	11 97       	sbiw	r26, 0x01	; 1
    b566:	87 e0       	ldi	r24, 0x07	; 7
    b568:	97 e0       	ldi	r25, 0x07	; 7
    b56a:	93 83       	std	Z+3, r25	; 0x03
    b56c:	82 83       	std	Z+2, r24	; 0x02
    b56e:	f5 82       	std	Z+5, r15	; 0x05
    b570:	e4 82       	std	Z+4, r14	; 0x04
    b572:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			      iSend=0;iLoop=0;
    b576:	10 92 07 02 	sts	0x0207, r1
    b57a:	10 92 06 02 	sts	0x0206, r1
    b57e:	10 92 03 02 	sts	0x0203, r1
    b582:	10 92 02 02 	sts	0x0202, r1
				  LSend=strlen(strPrint);
    b586:	f8 01       	movw	r30, r16
    b588:	01 90       	ld	r0, Z+
    b58a:	00 20       	and	r0, r0
    b58c:	e9 f7       	brne	.-6      	; 0xb588 <PrintIdle+0xd22>
    b58e:	8f 01       	movw	r16, r30
    b590:	01 50       	subi	r16, 0x01	; 1
    b592:	10 40       	sbci	r17, 0x00	; 0
    b594:	05 5c       	subi	r16, 0xC5	; 197
    b596:	18 40       	sbci	r17, 0x08	; 8
    b598:	10 93 05 02 	sts	0x0205, r17
    b59c:	00 93 04 02 	sts	0x0204, r16
				  stPrintIdle=piPrintOperatorName;
    b5a0:	86 e1       	ldi	r24, 0x16	; 22
    b5a2:	80 93 0f 02 	sts	0x020F, r24
    b5a6:	8d b7       	in	r24, 0x3d	; 61
    b5a8:	9e b7       	in	r25, 0x3e	; 62
    b5aa:	06 96       	adiw	r24, 0x06	; 6
    b5ac:	0f b6       	in	r0, 0x3f	; 63
    b5ae:	f8 94       	cli
    b5b0:	9e bf       	out	0x3e, r25	; 62
    b5b2:	0f be       	out	0x3f, r0	; 63
    b5b4:	8d bf       	out	0x3d, r24	; 61
    b5b6:	0d c1       	rjmp	.+538    	; 0xb7d2 <PrintIdle+0xf6c>
			  }else stPrintIdle=piLoadFooter;
          }  
          else stPrintIdle=piLoadFooter;
	      break;
	 case piPrintOperatorName:
		  if (iSend<LSend){
    b5b8:	20 91 06 02 	lds	r18, 0x0206
    b5bc:	30 91 07 02 	lds	r19, 0x0207
    b5c0:	80 91 04 02 	lds	r24, 0x0204
    b5c4:	90 91 05 02 	lds	r25, 0x0205
    b5c8:	28 17       	cp	r18, r24
    b5ca:	39 07       	cpc	r19, r25
    b5cc:	68 f4       	brcc	.+26     	; 0xb5e8 <PrintIdle+0xd82>
		      iLoop++;
    b5ce:	80 91 02 02 	lds	r24, 0x0202
    b5d2:	90 91 03 02 	lds	r25, 0x0203
    b5d6:	01 96       	adiw	r24, 0x01	; 1
    b5d8:	90 93 03 02 	sts	0x0203, r25
    b5dc:	80 93 02 02 	sts	0x0202, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
    b5e0:	10 92 b8 01 	sts	0x01B8, r1
				  stPrintIdle=piCheckPrintOperatorName;
    b5e4:	87 e1       	ldi	r24, 0x17	; 23
    b5e6:	ca c0       	rjmp	.+404    	; 0xb77c <PrintIdle+0xf16>
				}
			  }
          else {
			  CarriegeReturn();
    b5e8:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
			  CarriegeReturn();
    b5ec:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    b5f0:	37 c0       	rjmp	.+110    	; 0xb660 <PrintIdle+0xdfa>
			  stPrintIdle=piLoadFooter;
			  }
	      break;
	 case piCheckPrintOperatorName:
	      if (IsBusyPrint==False){
    b5f2:	80 91 b5 01 	lds	r24, 0x01B5
    b5f6:	88 23       	and	r24, r24
    b5f8:	09 f0       	breq	.+2      	; 0xb5fc <PrintIdle+0xd96>
    b5fa:	b8 c0       	rjmp	.+368    	; 0xb76c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    b5fc:	e0 91 06 02 	lds	r30, 0x0206
    b600:	f0 91 07 02 	lds	r31, 0x0207
    b604:	eb 53       	subi	r30, 0x3B	; 59
    b606:	f7 4f       	sbci	r31, 0xF7	; 247
    b608:	61 e0       	ldi	r22, 0x01	; 1
    b60a:	40 81       	ld	r20, Z
    b60c:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    b610:	80 91 06 02 	lds	r24, 0x0206
    b614:	90 91 07 02 	lds	r25, 0x0207
    b618:	01 96       	adiw	r24, 0x01	; 1
    b61a:	90 93 07 02 	sts	0x0207, r25
    b61e:	80 93 06 02 	sts	0x0206, r24
		      stPrintIdle=piPrintOperatorName;
    b622:	86 e1       	ldi	r24, 0x16	; 22
    b624:	a1 c0       	rjmp	.+322    	; 0xb768 <PrintIdle+0xf02>
    b626:	60 91 0d 02 	lds	r22, 0x020D
    b62a:	89 e2       	ldi	r24, 0x29	; 41
    b62c:	68 9f       	mul	r22, r24
    b62e:	b0 01       	movw	r22, r0
    b630:	11 24       	eor	r1, r1
    b632:	63 5e       	subi	r22, 0xE3	; 227
    b634:	7c 4f       	sbci	r23, 0xFC	; 252
    b636:	85 ec       	ldi	r24, 0xC5	; 197
    b638:	98 e0       	ldi	r25, 0x08	; 8
    b63a:	48 e2       	ldi	r20, 0x28	; 40
    b63c:	50 e0       	ldi	r21, 0x00	; 0
    b63e:	22 e4       	ldi	r18, 0x42	; 66
    b640:	33 e1       	ldi	r19, 0x13	; 19
    b642:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>

	 	       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    b646:	80 91 0d 02 	lds	r24, 0x020D
    b64a:	8f 5f       	subi	r24, 0xFF	; 255
    b64c:	80 93 0d 02 	sts	0x020D, r24
		  if (iFooter<=4){
    b650:	85 30       	cpi	r24, 0x05	; 5
    b652:	90 f4       	brcc	.+36     	; 0xb678 <PrintIdle+0xe12>
		      if (SpaceOnly(strPrint)==True){
    b654:	85 ec       	ldi	r24, 0xC5	; 197
    b656:	98 e0       	ldi	r25, 0x08	; 8
    b658:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <SpaceOnly>
    b65c:	81 30       	cpi	r24, 0x01	; 1
    b65e:	11 f4       	brne	.+4      	; 0xb664 <PrintIdle+0xdfe>
			      stPrintIdle=piLoadFooter;
    b660:	8e e0       	ldi	r24, 0x0E	; 14
    b662:	8c c0       	rjmp	.+280    	; 0xb77c <PrintIdle+0xf16>
				  }
			  else{
			      iSend=0;
    b664:	10 92 07 02 	sts	0x0207, r1
    b668:	10 92 06 02 	sts	0x0206, r1
				  iLoop=0;
    b66c:	10 92 03 02 	sts	0x0203, r1
    b670:	10 92 02 02 	sts	0x0202, r1
				  stPrintIdle=piPrintFooter;
    b674:	8f e0       	ldi	r24, 0x0F	; 15
    b676:	82 c0       	rjmp	.+260    	; 0xb77c <PrintIdle+0xf16>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
    b678:	81 e1       	ldi	r24, 0x11	; 17
    b67a:	80 c0       	rjmp	.+256    	; 0xb77c <PrintIdle+0xf16>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
    b67c:	80 91 06 02 	lds	r24, 0x0206
    b680:	90 91 07 02 	lds	r25, 0x0207
    b684:	88 97       	sbiw	r24, 0x28	; 40
    b686:	68 f4       	brcc	.+26     	; 0xb6a2 <PrintIdle+0xe3c>
		      iLoop++;
    b688:	80 91 02 02 	lds	r24, 0x0202
    b68c:	90 91 03 02 	lds	r25, 0x0203
    b690:	01 96       	adiw	r24, 0x01	; 1
    b692:	90 93 03 02 	sts	0x0203, r25
    b696:	80 93 02 02 	sts	0x0202, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
    b69a:	10 92 b8 01 	sts	0x01B8, r1
				stPrintIdle=piCheckPrintStatusFooter;
    b69e:	8d e0       	ldi	r24, 0x0D	; 13
    b6a0:	6d c0       	rjmp	.+218    	; 0xb77c <PrintIdle+0xf16>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
    b6a2:	8e e0       	ldi	r24, 0x0E	; 14
    b6a4:	80 93 0f 02 	sts	0x020F, r24
			  CarriegeReturn();
    b6a8:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
    b6ac:	92 c0       	rjmp	.+292    	; 0xb7d2 <PrintIdle+0xf6c>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    b6ae:	80 91 b5 01 	lds	r24, 0x01B5
    b6b2:	88 23       	and	r24, r24
    b6b4:	09 f0       	breq	.+2      	; 0xb6b8 <PrintIdle+0xe52>
    b6b6:	5a c0       	rjmp	.+180    	; 0xb76c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
    b6b8:	e0 91 06 02 	lds	r30, 0x0206
    b6bc:	f0 91 07 02 	lds	r31, 0x0207
    b6c0:	eb 53       	subi	r30, 0x3B	; 59
    b6c2:	f7 4f       	sbci	r31, 0xF7	; 247
    b6c4:	61 e0       	ldi	r22, 0x01	; 1
    b6c6:	40 81       	ld	r20, Z
    b6c8:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		      iSend++;
    b6cc:	80 91 06 02 	lds	r24, 0x0206
    b6d0:	90 91 07 02 	lds	r25, 0x0207
    b6d4:	01 96       	adiw	r24, 0x01	; 1
    b6d6:	90 93 07 02 	sts	0x0207, r25
    b6da:	80 93 06 02 	sts	0x0206, r24
		      stPrintIdle=piPrintFooter;
    b6de:	8f e0       	ldi	r24, 0x0F	; 15
    b6e0:	43 c0       	rjmp	.+134    	; 0xb768 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
    b6e2:	90 91 01 02 	lds	r25, 0x0201
    b6e6:	9f 5f       	subi	r25, 0xFF	; 255
    b6e8:	90 93 01 02 	sts	0x0201, r25
		  iScroll=0;
    b6ec:	10 92 0c 02 	sts	0x020C, r1
		  iLoop=0;
    b6f0:	10 92 03 02 	sts	0x0203, r1
    b6f4:	10 92 02 02 	sts	0x0202, r1
		  if (iPrinted<PrintCopy){
    b6f8:	80 91 00 02 	lds	r24, 0x0200
    b6fc:	98 17       	cp	r25, r24
    b6fe:	28 f4       	brcc	.+10     	; 0xb70a <PrintIdle+0xea4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b700:	e1 99       	sbic	0x1c, 1	; 28
    b702:	fe cf       	rjmp	.-4      	; 0xb700 <PrintIdle+0xe9a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b704:	82 e3       	ldi	r24, 0x32	; 50
    b706:	90 e0       	ldi	r25, 0x00	; 0
    b708:	04 c0       	rjmp	.+8      	; 0xb712 <PrintIdle+0xeac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b70a:	e1 99       	sbic	0x1c, 1	; 28
    b70c:	fe cf       	rjmp	.-4      	; 0xb70a <PrintIdle+0xea4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b70e:	81 e3       	ldi	r24, 0x31	; 49
    b710:	90 e0       	ldi	r25, 0x00	; 0
    b712:	9f bb       	out	0x1f, r25	; 31
    b714:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b716:	e0 9a       	sbi	0x1c, 0	; 28
    b718:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    b71a:	80 93 0b 02 	sts	0x020B, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
    b71e:	80 e1       	ldi	r24, 0x10	; 16
    b720:	2d c0       	rjmp	.+90     	; 0xb77c <PrintIdle+0xf16>
	      break;
     case piScrollPaper:
	      iLoop++;
    b722:	80 91 02 02 	lds	r24, 0x0202
    b726:	90 91 03 02 	lds	r25, 0x0203
    b72a:	01 96       	adiw	r24, 0x01	; 1
    b72c:	90 93 03 02 	sts	0x0203, r25
    b730:	80 93 02 02 	sts	0x0202, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
    b734:	10 92 b8 01 	sts	0x01B8, r1
			  stPrintIdle=piCheckPrintStatusScroll;
    b738:	82 e1       	ldi	r24, 0x12	; 18
    b73a:	80 93 0f 02 	sts	0x020F, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
    b73e:	90 91 0c 02 	lds	r25, 0x020C
    b742:	80 91 0b 02 	lds	r24, 0x020B
    b746:	89 17       	cp	r24, r25
    b748:	08 f0       	brcs	.+2      	; 0xb74c <PrintIdle+0xee6>
    b74a:	43 c0       	rjmp	.+134    	; 0xb7d2 <PrintIdle+0xf6c>
    b74c:	83 e1       	ldi	r24, 0x13	; 19
    b74e:	16 c0       	rjmp	.+44     	; 0xb77c <PrintIdle+0xf16>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
    b750:	80 91 b5 01 	lds	r24, 0x01B5
    b754:	88 23       	and	r24, r24
    b756:	51 f4       	brne	.+20     	; 0xb76c <PrintIdle+0xf06>
		      iScroll++;
    b758:	80 91 0c 02 	lds	r24, 0x020C
    b75c:	8f 5f       	subi	r24, 0xFF	; 255
    b75e:	80 93 0c 02 	sts	0x020C, r24
		      CarriegeReturn();
    b762:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
    b766:	80 e1       	ldi	r24, 0x10	; 16
    b768:	80 93 0f 02 	sts	0x020F, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    b76c:	80 91 b8 01 	lds	r24, 0x01B8
    b770:	8b 30       	cpi	r24, 0x0B	; 11
    b772:	78 f1       	brcs	.+94     	; 0xb7d2 <PrintIdle+0xf6c>
		      IsPrintERROR=True;
    b774:	81 e0       	ldi	r24, 0x01	; 1
    b776:	80 93 b3 01 	sts	0x01B3, r24
		      stPrintIdle=piFinishPrintIdle;
    b77a:	84 e1       	ldi	r24, 0x14	; 20
    b77c:	80 93 0f 02 	sts	0x020F, r24
    b780:	28 c0       	rjmp	.+80     	; 0xb7d2 <PrintIdle+0xf6c>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
    b782:	90 91 01 02 	lds	r25, 0x0201
    b786:	80 91 00 02 	lds	r24, 0x0200
    b78a:	98 17       	cp	r25, r24
    b78c:	10 f0       	brcs	.+4      	; 0xb792 <PrintIdle+0xf2c>
		      stPrintIdle=piFinishPrintIdle;
    b78e:	84 e1       	ldi	r24, 0x14	; 20
    b790:	05 c0       	rjmp	.+10     	; 0xb79c <PrintIdle+0xf36>
			  }
		  else {CarriegeReturn();
    b792:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		        CarriegeReturn();
    b796:	0e 94 1c 4c 	call	0x9838	; 0x9838 <CarriegeReturn>
		        stPrintIdle=piInit;
    b79a:	81 e0       	ldi	r24, 0x01	; 1
    b79c:	80 93 0f 02 	sts	0x020F, r24
		       }
		  PaperCut();
    b7a0:	0e 94 c3 4c 	call	0x9986	; 0x9986 <PaperCut>
    b7a4:	16 c0       	rjmp	.+44     	; 0xb7d2 <PrintIdle+0xf6c>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
    b7a6:	80 91 00 01 	lds	r24, 0x0100
    b7aa:	81 30       	cpi	r24, 0x01	; 1
    b7ac:	19 f0       	breq	.+6      	; 0xb7b4 <PrintIdle+0xf4e>
    b7ae:	82 30       	cpi	r24, 0x02	; 2
    b7b0:	61 f4       	brne	.+24     	; 0xb7ca <PrintIdle+0xf64>
    b7b2:	03 c0       	rjmp	.+6      	; 0xb7ba <PrintIdle+0xf54>
		  case IT_SLAVE:
		       sendMessage04();
    b7b4:	0e 94 7e 50 	call	0xa0fc	; 0xa0fc <sendMessage04>
    b7b8:	08 c0       	rjmp	.+16     	; 0xb7ca <PrintIdle+0xf64>
		       break;
		  case IT_STANDALONE:		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
    b7ba:	82 ec       	ldi	r24, 0xC2	; 194
    b7bc:	97 e0       	ldi	r25, 0x07	; 7
    b7be:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
    b7c2:	8f 70       	andi	r24, 0x0F	; 15
    b7c4:	61 e1       	ldi	r22, 0x11	; 17
    b7c6:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
			   //CurrentPumpStatus[FIPAddr]=PUMP_OFF;
			   //strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);			   
			   //IsNewPumpStatus=True;//UpdateDisplay
		       break;
		  }
		  IsBusyIdlePrinting=False;
    b7ca:	10 92 b4 01 	sts	0x01B4, r1
          stPrintIdle=piIdle;
    b7ce:	10 92 0f 02 	sts	0x020F, r1
	      break;	 
	 }
}
    b7d2:	64 96       	adiw	r28, 0x14	; 20
    b7d4:	0f b6       	in	r0, 0x3f	; 63
    b7d6:	f8 94       	cli
    b7d8:	de bf       	out	0x3e, r29	; 62
    b7da:	0f be       	out	0x3f, r0	; 63
    b7dc:	cd bf       	out	0x3d, r28	; 61
    b7de:	cf 91       	pop	r28
    b7e0:	df 91       	pop	r29
    b7e2:	1f 91       	pop	r17
    b7e4:	0f 91       	pop	r16
    b7e6:	ff 90       	pop	r15
    b7e8:	ef 90       	pop	r14
    b7ea:	08 95       	ret

0000b7ec <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
    b7ec:	0e 94 82 50 	call	0xa104	; 0xa104 <FreePrinting>
	 PrintIdle();
    b7f0:	0e 94 33 54 	call	0xa866	; 0xa866 <PrintIdle>
}
    b7f4:	08 95       	ret

0000b7f6 <procMessage11>:
}




void procMessage11(){
    b7f6:	af 92       	push	r10
    b7f8:	bf 92       	push	r11
    b7fa:	cf 92       	push	r12
    b7fc:	df 92       	push	r13
    b7fe:	ef 92       	push	r14
    b800:	ff 92       	push	r15
    b802:	0f 93       	push	r16
    b804:	1f 93       	push	r17
    b806:	df 93       	push	r29
    b808:	cf 93       	push	r28
    b80a:	cd b7       	in	r28, 0x3d	; 61
    b80c:	de b7       	in	r29, 0x3e	; 62
    b80e:	c5 55       	subi	r28, 0x55	; 85
    b810:	d0 40       	sbci	r29, 0x00	; 0
    b812:	0f b6       	in	r0, 0x3f	; 63
    b814:	f8 94       	cli
    b816:	de bf       	out	0x3e, r29	; 62
    b818:	0f be       	out	0x3f, r0	; 63
    b81a:	cd bf       	out	0x3d, r28	; 61
    b81c:	20 e0       	ldi	r18, 0x00	; 0
    b81e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b820:	ae 01       	movw	r20, r28
    b822:	46 5f       	subi	r20, 0xF6	; 246
    b824:	5f 4f       	sbci	r21, 0xFF	; 255
    b826:	fa 01       	movw	r30, r20
    b828:	e2 0f       	add	r30, r18
    b82a:	f3 1f       	adc	r31, r19
    b82c:	d9 01       	movw	r26, r18
    b82e:	aa 5d       	subi	r26, 0xDA	; 218
    b830:	b4 4f       	sbci	r27, 0xF4	; 244
    b832:	9b 96       	adiw	r26, 0x2b	; 43
    b834:	8c 91       	ld	r24, X
    b836:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b838:	2f 5f       	subi	r18, 0xFF	; 255
    b83a:	3f 4f       	sbci	r19, 0xFF	; 255
    b83c:	2a 30       	cpi	r18, 0x0A	; 10
    b83e:	31 05       	cpc	r19, r1
    b840:	91 f7       	brne	.-28     	; 0xb826 <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b842:	fa 01       	movw	r30, r20
    b844:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    b846:	81 e0       	ldi	r24, 0x01	; 1
    b848:	ba 01       	movw	r22, r20
    b84a:	0e 94 46 28 	call	0x508c	; 0x508c <FormatDate>
    b84e:	20 e0       	ldi	r18, 0x00	; 0
    b850:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b852:	ae 01       	movw	r20, r28
    b854:	4c 5e       	subi	r20, 0xEC	; 236
    b856:	5f 4f       	sbci	r21, 0xFF	; 255
    b858:	fa 01       	movw	r30, r20
    b85a:	e2 0f       	add	r30, r18
    b85c:	f3 1f       	adc	r31, r19
    b85e:	d9 01       	movw	r26, r18
    b860:	aa 5d       	subi	r26, 0xDA	; 218
    b862:	b4 4f       	sbci	r27, 0xF4	; 244
    b864:	d6 96       	adiw	r26, 0x36	; 54
    b866:	8c 91       	ld	r24, X
    b868:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b86a:	2f 5f       	subi	r18, 0xFF	; 255
    b86c:	3f 4f       	sbci	r19, 0xFF	; 255
    b86e:	28 30       	cpi	r18, 0x08	; 8
    b870:	31 05       	cpc	r19, r1
    b872:	91 f7       	brne	.-28     	; 0xb858 <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b874:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    b876:	81 e0       	ldi	r24, 0x01	; 1
    b878:	be 01       	movw	r22, r28
    b87a:	66 5f       	subi	r22, 0xF6	; 246
    b87c:	7f 4f       	sbci	r23, 0xFF	; 255
    b87e:	0e 94 b4 aa 	call	0x15568	; 0x15568 <_datetime>
	  
     clearString(buffHeader);
    b882:	8e 01       	movw	r16, r28
    b884:	03 5d       	subi	r16, 0xD3	; 211
    b886:	1f 4f       	sbci	r17, 0xFF	; 255
    b888:	c8 01       	movw	r24, r16
    b88a:	0e 94 01 2a 	call	0x5402	; 0x5402 <clearString>
    b88e:	20 e0       	ldi	r18, 0x00	; 0
    b890:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b892:	f8 01       	movw	r30, r16
    b894:	e2 0f       	add	r30, r18
    b896:	f3 1f       	adc	r31, r19
    b898:	d9 01       	movw	r26, r18
    b89a:	aa 5d       	subi	r26, 0xDA	; 218
    b89c:	b4 4f       	sbci	r27, 0xF4	; 244
    b89e:	de 96       	adiw	r26, 0x3e	; 62
    b8a0:	8c 91       	ld	r24, X
    b8a2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b8a4:	2f 5f       	subi	r18, 0xFF	; 255
    b8a6:	3f 4f       	sbci	r19, 0xFF	; 255
    b8a8:	28 32       	cpi	r18, 0x28	; 40
    b8aa:	31 05       	cpc	r19, r1
    b8ac:	91 f7       	brne	.-28     	; 0xb892 <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b8ae:	fe 01       	movw	r30, r28
    b8b0:	eb 5a       	subi	r30, 0xAB	; 171
    b8b2:	ff 4f       	sbci	r31, 0xFF	; 255
    b8b4:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    b8b6:	87 e2       	ldi	r24, 0x27	; 39
    b8b8:	92 e0       	ldi	r25, 0x02	; 2
    b8ba:	b8 01       	movw	r22, r16
    b8bc:	48 e2       	ldi	r20, 0x28	; 40
    b8be:	50 e0       	ldi	r21, 0x00	; 0
    b8c0:	2a e4       	ldi	r18, 0x4A	; 74
    b8c2:	33 e1       	ldi	r19, 0x13	; 19
    b8c4:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    b8c8:	20 e0       	ldi	r18, 0x00	; 0
    b8ca:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b8cc:	be 01       	movw	r22, r28
    b8ce:	63 5d       	subi	r22, 0xD3	; 211
    b8d0:	7f 4f       	sbci	r23, 0xFF	; 255
    b8d2:	fb 01       	movw	r30, r22
    b8d4:	e2 0f       	add	r30, r18
    b8d6:	f3 1f       	adc	r31, r19
    b8d8:	d9 01       	movw	r26, r18
    b8da:	a4 57       	subi	r26, 0x74	; 116
    b8dc:	b4 4f       	sbci	r27, 0xF4	; 244
    b8de:	8c 91       	ld	r24, X
    b8e0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b8e2:	2f 5f       	subi	r18, 0xFF	; 255
    b8e4:	3f 4f       	sbci	r19, 0xFF	; 255
    b8e6:	28 32       	cpi	r18, 0x28	; 40
    b8e8:	31 05       	cpc	r19, r1
    b8ea:	99 f7       	brne	.-26     	; 0xb8d2 <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b8ec:	fe 01       	movw	r30, r28
    b8ee:	eb 5a       	subi	r30, 0xAB	; 171
    b8f0:	ff 4f       	sbci	r31, 0xFF	; 255
    b8f2:	10 82       	st	Z, r1
    b8f4:	80 e5       	ldi	r24, 0x50	; 80
    b8f6:	92 e0       	ldi	r25, 0x02	; 2
    b8f8:	48 e2       	ldi	r20, 0x28	; 40
    b8fa:	50 e0       	ldi	r21, 0x00	; 0
    b8fc:	2a e4       	ldi	r18, 0x4A	; 74
    b8fe:	33 e1       	ldi	r19, 0x13	; 19
    b900:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    b904:	20 e0       	ldi	r18, 0x00	; 0
    b906:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b908:	be 01       	movw	r22, r28
    b90a:	63 5d       	subi	r22, 0xD3	; 211
    b90c:	7f 4f       	sbci	r23, 0xFF	; 255
    b90e:	fb 01       	movw	r30, r22
    b910:	e2 0f       	add	r30, r18
    b912:	f3 1f       	adc	r31, r19
    b914:	d9 01       	movw	r26, r18
    b916:	ac 54       	subi	r26, 0x4C	; 76
    b918:	b4 4f       	sbci	r27, 0xF4	; 244
    b91a:	8c 91       	ld	r24, X
    b91c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b91e:	2f 5f       	subi	r18, 0xFF	; 255
    b920:	3f 4f       	sbci	r19, 0xFF	; 255
    b922:	28 32       	cpi	r18, 0x28	; 40
    b924:	31 05       	cpc	r19, r1
    b926:	99 f7       	brne	.-26     	; 0xb90e <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b928:	fe 01       	movw	r30, r28
    b92a:	eb 5a       	subi	r30, 0xAB	; 171
    b92c:	ff 4f       	sbci	r31, 0xFF	; 255
    b92e:	10 82       	st	Z, r1
    b930:	89 e7       	ldi	r24, 0x79	; 121
    b932:	92 e0       	ldi	r25, 0x02	; 2
    b934:	48 e2       	ldi	r20, 0x28	; 40
    b936:	50 e0       	ldi	r21, 0x00	; 0
    b938:	2a e4       	ldi	r18, 0x4A	; 74
    b93a:	33 e1       	ldi	r19, 0x13	; 19
    b93c:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    b940:	20 e0       	ldi	r18, 0x00	; 0
    b942:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b944:	be 01       	movw	r22, r28
    b946:	63 5d       	subi	r22, 0xD3	; 211
    b948:	7f 4f       	sbci	r23, 0xFF	; 255
    b94a:	fb 01       	movw	r30, r22
    b94c:	e2 0f       	add	r30, r18
    b94e:	f3 1f       	adc	r31, r19
    b950:	d9 01       	movw	r26, r18
    b952:	a4 52       	subi	r26, 0x24	; 36
    b954:	b4 4f       	sbci	r27, 0xF4	; 244
    b956:	8c 91       	ld	r24, X
    b958:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b95a:	2f 5f       	subi	r18, 0xFF	; 255
    b95c:	3f 4f       	sbci	r19, 0xFF	; 255
    b95e:	28 32       	cpi	r18, 0x28	; 40
    b960:	31 05       	cpc	r19, r1
    b962:	99 f7       	brne	.-26     	; 0xb94a <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b964:	fe 01       	movw	r30, r28
    b966:	eb 5a       	subi	r30, 0xAB	; 171
    b968:	ff 4f       	sbci	r31, 0xFF	; 255
    b96a:	10 82       	st	Z, r1
    b96c:	82 ea       	ldi	r24, 0xA2	; 162
    b96e:	92 e0       	ldi	r25, 0x02	; 2
    b970:	48 e2       	ldi	r20, 0x28	; 40
    b972:	50 e0       	ldi	r21, 0x00	; 0
    b974:	2a e4       	ldi	r18, 0x4A	; 74
    b976:	33 e1       	ldi	r19, 0x13	; 19
    b978:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    b97c:	20 e0       	ldi	r18, 0x00	; 0
    b97e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b980:	be 01       	movw	r22, r28
    b982:	63 5d       	subi	r22, 0xD3	; 211
    b984:	7f 4f       	sbci	r23, 0xFF	; 255
    b986:	fb 01       	movw	r30, r22
    b988:	e2 0f       	add	r30, r18
    b98a:	f3 1f       	adc	r31, r19
    b98c:	d9 01       	movw	r26, r18
    b98e:	ac 5f       	subi	r26, 0xFC	; 252
    b990:	b3 4f       	sbci	r27, 0xF3	; 243
    b992:	8c 91       	ld	r24, X
    b994:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b996:	2f 5f       	subi	r18, 0xFF	; 255
    b998:	3f 4f       	sbci	r19, 0xFF	; 255
    b99a:	28 32       	cpi	r18, 0x28	; 40
    b99c:	31 05       	cpc	r19, r1
    b99e:	99 f7       	brne	.-26     	; 0xb986 <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b9a0:	fe 01       	movw	r30, r28
    b9a2:	eb 5a       	subi	r30, 0xAB	; 171
    b9a4:	ff 4f       	sbci	r31, 0xFF	; 255
    b9a6:	10 82       	st	Z, r1
    b9a8:	8b ec       	ldi	r24, 0xCB	; 203
    b9aa:	92 e0       	ldi	r25, 0x02	; 2
    b9ac:	48 e2       	ldi	r20, 0x28	; 40
    b9ae:	50 e0       	ldi	r21, 0x00	; 0
    b9b0:	2a e4       	ldi	r18, 0x4A	; 74
    b9b2:	33 e1       	ldi	r19, 0x13	; 19
    b9b4:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    b9b8:	20 e0       	ldi	r18, 0x00	; 0
    b9ba:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b9bc:	be 01       	movw	r22, r28
    b9be:	63 5d       	subi	r22, 0xD3	; 211
    b9c0:	7f 4f       	sbci	r23, 0xFF	; 255
    b9c2:	fb 01       	movw	r30, r22
    b9c4:	e2 0f       	add	r30, r18
    b9c6:	f3 1f       	adc	r31, r19
    b9c8:	d9 01       	movw	r26, r18
    b9ca:	a4 5d       	subi	r26, 0xD4	; 212
    b9cc:	b3 4f       	sbci	r27, 0xF3	; 243
    b9ce:	8c 91       	ld	r24, X
    b9d0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b9d2:	2f 5f       	subi	r18, 0xFF	; 255
    b9d4:	3f 4f       	sbci	r19, 0xFF	; 255
    b9d6:	28 32       	cpi	r18, 0x28	; 40
    b9d8:	31 05       	cpc	r19, r1
    b9da:	99 f7       	brne	.-26     	; 0xb9c2 <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b9dc:	fe 01       	movw	r30, r28
    b9de:	eb 5a       	subi	r30, 0xAB	; 171
    b9e0:	ff 4f       	sbci	r31, 0xFF	; 255
    b9e2:	10 82       	st	Z, r1
    b9e4:	84 ef       	ldi	r24, 0xF4	; 244
    b9e6:	92 e0       	ldi	r25, 0x02	; 2
    b9e8:	48 e2       	ldi	r20, 0x28	; 40
    b9ea:	50 e0       	ldi	r21, 0x00	; 0
    b9ec:	2a e4       	ldi	r18, 0x4A	; 74
    b9ee:	33 e1       	ldi	r19, 0x13	; 19
    b9f0:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    b9f4:	20 e0       	ldi	r18, 0x00	; 0
    b9f6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b9f8:	be 01       	movw	r22, r28
    b9fa:	63 5d       	subi	r22, 0xD3	; 211
    b9fc:	7f 4f       	sbci	r23, 0xFF	; 255
    b9fe:	fb 01       	movw	r30, r22
    ba00:	e2 0f       	add	r30, r18
    ba02:	f3 1f       	adc	r31, r19
    ba04:	d9 01       	movw	r26, r18
    ba06:	ac 5a       	subi	r26, 0xAC	; 172
    ba08:	b3 4f       	sbci	r27, 0xF3	; 243
    ba0a:	8c 91       	ld	r24, X
    ba0c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba0e:	2f 5f       	subi	r18, 0xFF	; 255
    ba10:	3f 4f       	sbci	r19, 0xFF	; 255
    ba12:	28 32       	cpi	r18, 0x28	; 40
    ba14:	31 05       	cpc	r19, r1
    ba16:	99 f7       	brne	.-26     	; 0xb9fe <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba18:	fe 01       	movw	r30, r28
    ba1a:	eb 5a       	subi	r30, 0xAB	; 171
    ba1c:	ff 4f       	sbci	r31, 0xFF	; 255
    ba1e:	10 82       	st	Z, r1
    ba20:	8d e1       	ldi	r24, 0x1D	; 29
    ba22:	93 e0       	ldi	r25, 0x03	; 3
    ba24:	48 e2       	ldi	r20, 0x28	; 40
    ba26:	50 e0       	ldi	r21, 0x00	; 0
    ba28:	2a e4       	ldi	r18, 0x4A	; 74
    ba2a:	33 e1       	ldi	r19, 0x13	; 19
    ba2c:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    ba30:	20 e0       	ldi	r18, 0x00	; 0
    ba32:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba34:	be 01       	movw	r22, r28
    ba36:	63 5d       	subi	r22, 0xD3	; 211
    ba38:	7f 4f       	sbci	r23, 0xFF	; 255
    ba3a:	fb 01       	movw	r30, r22
    ba3c:	e2 0f       	add	r30, r18
    ba3e:	f3 1f       	adc	r31, r19
    ba40:	d9 01       	movw	r26, r18
    ba42:	a4 58       	subi	r26, 0x84	; 132
    ba44:	b3 4f       	sbci	r27, 0xF3	; 243
    ba46:	8c 91       	ld	r24, X
    ba48:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba4a:	2f 5f       	subi	r18, 0xFF	; 255
    ba4c:	3f 4f       	sbci	r19, 0xFF	; 255
    ba4e:	28 32       	cpi	r18, 0x28	; 40
    ba50:	31 05       	cpc	r19, r1
    ba52:	99 f7       	brne	.-26     	; 0xba3a <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba54:	fe 01       	movw	r30, r28
    ba56:	eb 5a       	subi	r30, 0xAB	; 171
    ba58:	ff 4f       	sbci	r31, 0xFF	; 255
    ba5a:	10 82       	st	Z, r1
    ba5c:	86 e4       	ldi	r24, 0x46	; 70
    ba5e:	93 e0       	ldi	r25, 0x03	; 3
    ba60:	48 e2       	ldi	r20, 0x28	; 40
    ba62:	50 e0       	ldi	r21, 0x00	; 0
    ba64:	2a e4       	ldi	r18, 0x4A	; 74
    ba66:	33 e1       	ldi	r19, 0x13	; 19
    ba68:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    ba6c:	20 e0       	ldi	r18, 0x00	; 0
    ba6e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba70:	be 01       	movw	r22, r28
    ba72:	63 5d       	subi	r22, 0xD3	; 211
    ba74:	7f 4f       	sbci	r23, 0xFF	; 255
    ba76:	fb 01       	movw	r30, r22
    ba78:	e2 0f       	add	r30, r18
    ba7a:	f3 1f       	adc	r31, r19
    ba7c:	d9 01       	movw	r26, r18
    ba7e:	ac 55       	subi	r26, 0x5C	; 92
    ba80:	b3 4f       	sbci	r27, 0xF3	; 243
    ba82:	8c 91       	ld	r24, X
    ba84:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba86:	2f 5f       	subi	r18, 0xFF	; 255
    ba88:	3f 4f       	sbci	r19, 0xFF	; 255
    ba8a:	28 32       	cpi	r18, 0x28	; 40
    ba8c:	31 05       	cpc	r19, r1
    ba8e:	99 f7       	brne	.-26     	; 0xba76 <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba90:	fe 01       	movw	r30, r28
    ba92:	eb 5a       	subi	r30, 0xAB	; 171
    ba94:	ff 4f       	sbci	r31, 0xFF	; 255
    ba96:	10 82       	st	Z, r1
    ba98:	8f e6       	ldi	r24, 0x6F	; 111
    ba9a:	93 e0       	ldi	r25, 0x03	; 3
    ba9c:	48 e2       	ldi	r20, 0x28	; 40
    ba9e:	50 e0       	ldi	r21, 0x00	; 0
    baa0:	2a e4       	ldi	r18, 0x4A	; 74
    baa2:	33 e1       	ldi	r19, 0x13	; 19
    baa4:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    baa8:	20 e0       	ldi	r18, 0x00	; 0
    baaa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    baac:	be 01       	movw	r22, r28
    baae:	63 5d       	subi	r22, 0xD3	; 211
    bab0:	7f 4f       	sbci	r23, 0xFF	; 255
    bab2:	fb 01       	movw	r30, r22
    bab4:	e2 0f       	add	r30, r18
    bab6:	f3 1f       	adc	r31, r19
    bab8:	d9 01       	movw	r26, r18
    baba:	a4 53       	subi	r26, 0x34	; 52
    babc:	b3 4f       	sbci	r27, 0xF3	; 243
    babe:	8c 91       	ld	r24, X
    bac0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bac2:	2f 5f       	subi	r18, 0xFF	; 255
    bac4:	3f 4f       	sbci	r19, 0xFF	; 255
    bac6:	28 32       	cpi	r18, 0x28	; 40
    bac8:	31 05       	cpc	r19, r1
    baca:	99 f7       	brne	.-26     	; 0xbab2 <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bacc:	fe 01       	movw	r30, r28
    bace:	eb 5a       	subi	r30, 0xAB	; 171
    bad0:	ff 4f       	sbci	r31, 0xFF	; 255
    bad2:	10 82       	st	Z, r1
    bad4:	88 e9       	ldi	r24, 0x98	; 152
    bad6:	93 e0       	ldi	r25, 0x03	; 3
    bad8:	48 e2       	ldi	r20, 0x28	; 40
    bada:	50 e0       	ldi	r21, 0x00	; 0
    badc:	2a e4       	ldi	r18, 0x4A	; 74
    bade:	33 e1       	ldi	r19, 0x13	; 19
    bae0:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    bae4:	0b eb       	ldi	r16, 0xBB	; 187
    bae6:	10 e0       	ldi	r17, 0x00	; 0
    bae8:	6c e0       	ldi	r22, 0x0C	; 12
    baea:	e6 2e       	mov	r14, r22
    baec:	6d e0       	ldi	r22, 0x0D	; 13
    baee:	f6 2e       	mov	r15, r22
    baf0:	50 e2       	ldi	r21, 0x20	; 32
    baf2:	c5 2e       	mov	r12, r21
    baf4:	d1 2c       	mov	r13, r1
    baf6:	cc 0e       	add	r12, r28
    baf8:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bafa:	4c e2       	ldi	r20, 0x2C	; 44
    bafc:	a4 2e       	mov	r10, r20
    bafe:	b1 2c       	mov	r11, r1
    bb00:	ac 0e       	add	r10, r28
    bb02:	bd 1e       	adc	r11, r29
    bb04:	f6 01       	movw	r30, r12
    bb06:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    bb08:	8d 91       	ld	r24, X+
    bb0a:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb0c:	ea 15       	cp	r30, r10
    bb0e:	fb 05       	cpc	r31, r11
    bb10:	d9 f7       	brne	.-10     	; 0xbb08 <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb12:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    bb14:	c6 01       	movw	r24, r12
    bb16:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
    bb1a:	c8 01       	movw	r24, r16
    bb1c:	b6 01       	movw	r22, r12
    bb1e:	4c e0       	ldi	r20, 0x0C	; 12
    bb20:	50 e0       	ldi	r21, 0x00	; 0
    bb22:	2a e4       	ldi	r18, 0x4A	; 74
    bb24:	33 e1       	ldi	r19, 0x13	; 19
    bb26:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    bb2a:	03 5f       	subi	r16, 0xF3	; 243
    bb2c:	1f 4f       	sbci	r17, 0xFF	; 255
    bb2e:	8c e0       	ldi	r24, 0x0C	; 12
    bb30:	90 e0       	ldi	r25, 0x00	; 0
    bb32:	e8 0e       	add	r14, r24
    bb34:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bb36:	91 e0       	ldi	r25, 0x01	; 1
    bb38:	09 30       	cpi	r16, 0x09	; 9
    bb3a:	19 07       	cpc	r17, r25
    bb3c:	19 f7       	brne	.-58     	; 0xbb04 <procMessage11+0x30e>
    bb3e:	05 e8       	ldi	r16, 0x85	; 133
    bb40:	10 e0       	ldi	r17, 0x00	; 0
    bb42:	34 e5       	ldi	r19, 0x54	; 84
    bb44:	e3 2e       	mov	r14, r19
    bb46:	3d e0       	ldi	r19, 0x0D	; 13
    bb48:	f3 2e       	mov	r15, r19
    bb4a:	6e 01       	movw	r12, r28
    bb4c:	08 94       	sec
    bb4e:	c1 1c       	adc	r12, r1
    bb50:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb52:	29 e0       	ldi	r18, 0x09	; 9
    bb54:	a2 2e       	mov	r10, r18
    bb56:	b1 2c       	mov	r11, r1
    bb58:	ac 0e       	add	r10, r28
    bb5a:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bb5c:	f6 01       	movw	r30, r12
    bb5e:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb60:	8d 91       	ld	r24, X+
    bb62:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb64:	ea 15       	cp	r30, r10
    bb66:	fb 05       	cpc	r31, r11
    bb68:	d9 f7       	brne	.-10     	; 0xbb60 <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb6a:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    bb6c:	c6 01       	movw	r24, r12
    bb6e:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    bb72:	c6 01       	movw	r24, r12
    bb74:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		RemDecimal(strProductPrice);
    bb78:	c6 01       	movw	r24, r12
    bb7a:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <RemDecimal>
    bb7e:	c8 01       	movw	r24, r16
    bb80:	b6 01       	movw	r22, r12
    bb82:	48 e0       	ldi	r20, 0x08	; 8
    bb84:	50 e0       	ldi	r21, 0x00	; 0
    bb86:	2a e4       	ldi	r18, 0x4A	; 74
    bb88:	33 e1       	ldi	r19, 0x13	; 19
    bb8a:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    bb8e:	07 5f       	subi	r16, 0xF7	; 247
    bb90:	1f 4f       	sbci	r17, 0xFF	; 255
    bb92:	e8 e0       	ldi	r30, 0x08	; 8
    bb94:	f0 e0       	ldi	r31, 0x00	; 0
    bb96:	ee 0e       	add	r14, r30
    bb98:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    bb9a:	f0 e0       	ldi	r31, 0x00	; 0
    bb9c:	0b 3b       	cpi	r16, 0xBB	; 187
    bb9e:	1f 07       	cpc	r17, r31
    bba0:	e9 f6       	brne	.-70     	; 0xbb5c <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    bba2:	cb 5a       	subi	r28, 0xAB	; 171
    bba4:	df 4f       	sbci	r29, 0xFF	; 255
    bba6:	0f b6       	in	r0, 0x3f	; 63
    bba8:	f8 94       	cli
    bbaa:	de bf       	out	0x3e, r29	; 62
    bbac:	0f be       	out	0x3f, r0	; 63
    bbae:	cd bf       	out	0x3d, r28	; 61
    bbb0:	cf 91       	pop	r28
    bbb2:	df 91       	pop	r29
    bbb4:	1f 91       	pop	r17
    bbb6:	0f 91       	pop	r16
    bbb8:	ff 90       	pop	r15
    bbba:	ef 90       	pop	r14
    bbbc:	df 90       	pop	r13
    bbbe:	cf 90       	pop	r12
    bbc0:	bf 90       	pop	r11
    bbc2:	af 90       	pop	r10
    bbc4:	08 95       	ret

0000bbc6 <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    bbc6:	cf 92       	push	r12
    bbc8:	df 92       	push	r13
    bbca:	ef 92       	push	r14
    bbcc:	ff 92       	push	r15
    bbce:	0f 93       	push	r16
    bbd0:	1f 93       	push	r17
    bbd2:	df 93       	push	r29
    bbd4:	cf 93       	push	r28
    bbd6:	cd b7       	in	r28, 0x3d	; 61
    bbd8:	de b7       	in	r29, 0x3e	; 62
    bbda:	64 97       	sbiw	r28, 0x14	; 20
    bbdc:	0f b6       	in	r0, 0x3f	; 63
    bbde:	f8 94       	cli
    bbe0:	de bf       	out	0x3e, r29	; 62
    bbe2:	0f be       	out	0x3f, r0	; 63
    bbe4:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    bbe6:	e3 ec       	ldi	r30, 0xC3	; 195
    bbe8:	ee 2e       	mov	r14, r30
    bbea:	e3 e0       	ldi	r30, 0x03	; 3
    bbec:	fe 2e       	mov	r15, r30
    bbee:	7d e7       	ldi	r23, 0x7D	; 125
    bbf0:	c7 2e       	mov	r12, r23
    bbf2:	78 e0       	ldi	r23, 0x08	; 8
    bbf4:	d7 2e       	mov	r13, r23
    bbf6:	80 e0       	ldi	r24, 0x00	; 0
    bbf8:	b7 01       	movw	r22, r14
    bbfa:	a6 01       	movw	r20, r12
    bbfc:	0e 94 b4 aa 	call	0x15568	; 0x15568 <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    bc00:	8d b7       	in	r24, 0x3d	; 61
    bc02:	9e b7       	in	r25, 0x3e	; 62
    bc04:	08 97       	sbiw	r24, 0x08	; 8
    bc06:	0f b6       	in	r0, 0x3f	; 63
    bc08:	f8 94       	cli
    bc0a:	9e bf       	out	0x3e, r25	; 62
    bc0c:	0f be       	out	0x3f, r0	; 63
    bc0e:	8d bf       	out	0x3d, r24	; 61
    bc10:	ed b7       	in	r30, 0x3d	; 61
    bc12:	fe b7       	in	r31, 0x3e	; 62
    bc14:	31 96       	adiw	r30, 0x01	; 1
    bc16:	8e 01       	movw	r16, r28
    bc18:	0f 5f       	subi	r16, 0xFF	; 255
    bc1a:	1f 4f       	sbci	r17, 0xFF	; 255
    bc1c:	ad b7       	in	r26, 0x3d	; 61
    bc1e:	be b7       	in	r27, 0x3e	; 62
    bc20:	12 96       	adiw	r26, 0x02	; 2
    bc22:	1c 93       	st	X, r17
    bc24:	0e 93       	st	-X, r16
    bc26:	11 97       	sbiw	r26, 0x01	; 1
    bc28:	89 e1       	ldi	r24, 0x19	; 25
    bc2a:	9d e1       	ldi	r25, 0x1D	; 29
    bc2c:	93 83       	std	Z+3, r25	; 0x03
    bc2e:	82 83       	std	Z+2, r24	; 0x02
    bc30:	f5 82       	std	Z+5, r15	; 0x05
    bc32:	e4 82       	std	Z+4, r14	; 0x04
    bc34:	d7 82       	std	Z+7, r13	; 0x07
    bc36:	c6 82       	std	Z+6, r12	; 0x06
    bc38:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    bc3c:	8d b7       	in	r24, 0x3d	; 61
    bc3e:	9e b7       	in	r25, 0x3e	; 62
    bc40:	08 96       	adiw	r24, 0x08	; 8
    bc42:	0f b6       	in	r0, 0x3f	; 63
    bc44:	f8 94       	cli
    bc46:	9e bf       	out	0x3e, r25	; 62
    bc48:	0f be       	out	0x3f, r0	; 63
    bc4a:	8d bf       	out	0x3d, r24	; 61
    bc4c:	82 e0       	ldi	r24, 0x02	; 2
    bc4e:	61 e0       	ldi	r22, 0x01	; 1
    bc50:	a8 01       	movw	r20, r16
    bc52:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
}
    bc56:	64 96       	adiw	r28, 0x14	; 20
    bc58:	0f b6       	in	r0, 0x3f	; 63
    bc5a:	f8 94       	cli
    bc5c:	de bf       	out	0x3e, r29	; 62
    bc5e:	0f be       	out	0x3f, r0	; 63
    bc60:	cd bf       	out	0x3d, r28	; 61
    bc62:	cf 91       	pop	r28
    bc64:	df 91       	pop	r29
    bc66:	1f 91       	pop	r17
    bc68:	0f 91       	pop	r16
    bc6a:	ff 90       	pop	r15
    bc6c:	ef 90       	pop	r14
    bc6e:	df 90       	pop	r13
    bc70:	cf 90       	pop	r12
    bc72:	08 95       	ret

0000bc74 <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    bc74:	df 92       	push	r13
    bc76:	ef 92       	push	r14
    bc78:	ff 92       	push	r15
    bc7a:	0f 93       	push	r16
    bc7c:	1f 93       	push	r17
    bc7e:	df 93       	push	r29
    bc80:	cf 93       	push	r28
    bc82:	cd b7       	in	r28, 0x3d	; 61
    bc84:	de b7       	in	r29, 0x3e	; 62
    bc86:	64 97       	sbiw	r28, 0x14	; 20
    bc88:	0f b6       	in	r0, 0x3f	; 63
    bc8a:	f8 94       	cli
    bc8c:	de bf       	out	0x3e, r29	; 62
    bc8e:	0f be       	out	0x3f, r0	; 63
    bc90:	cd bf       	out	0x3d, r28	; 61
    bc92:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    bc94:	80 91 52 02 	lds	r24, 0x0252
    bc98:	87 30       	cpi	r24, 0x07	; 7
    bc9a:	09 f4       	brne	.+2      	; 0xbc9e <FCloseShift+0x2a>
    bc9c:	a0 c1       	rjmp	.+832    	; 0xbfde <FCloseShift+0x36a>
    bc9e:	88 30       	cpi	r24, 0x08	; 8
    bca0:	78 f4       	brcc	.+30     	; 0xbcc0 <FCloseShift+0x4c>
    bca2:	84 30       	cpi	r24, 0x04	; 4
    bca4:	09 f4       	brne	.+2      	; 0xbca8 <FCloseShift+0x34>
    bca6:	68 c0       	rjmp	.+208    	; 0xbd78 <FCloseShift+0x104>
    bca8:	85 30       	cpi	r24, 0x05	; 5
    bcaa:	18 f4       	brcc	.+6      	; 0xbcb2 <FCloseShift+0x3e>
    bcac:	88 23       	and	r24, r24
    bcae:	c1 f0       	breq	.+48     	; 0xbce0 <FCloseShift+0x6c>
    bcb0:	1c c2       	rjmp	.+1080   	; 0xc0ea <FCloseShift+0x476>
    bcb2:	85 30       	cpi	r24, 0x05	; 5
    bcb4:	09 f4       	brne	.+2      	; 0xbcb8 <FCloseShift+0x44>
    bcb6:	a6 c0       	rjmp	.+332    	; 0xbe04 <FCloseShift+0x190>
    bcb8:	86 30       	cpi	r24, 0x06	; 6
    bcba:	09 f0       	breq	.+2      	; 0xbcbe <FCloseShift+0x4a>
    bcbc:	16 c2       	rjmp	.+1068   	; 0xc0ea <FCloseShift+0x476>
    bcbe:	a8 c0       	rjmp	.+336    	; 0xbe10 <FCloseShift+0x19c>
    bcc0:	8a 30       	cpi	r24, 0x0A	; 10
    bcc2:	09 f4       	brne	.+2      	; 0xbcc6 <FCloseShift+0x52>
    bcc4:	d0 c1       	rjmp	.+928    	; 0xc066 <FCloseShift+0x3f2>
    bcc6:	8b 30       	cpi	r24, 0x0B	; 11
    bcc8:	20 f4       	brcc	.+8      	; 0xbcd2 <FCloseShift+0x5e>
    bcca:	88 30       	cpi	r24, 0x08	; 8
    bccc:	09 f0       	breq	.+2      	; 0xbcd0 <FCloseShift+0x5c>
    bcce:	0d c2       	rjmp	.+1050   	; 0xc0ea <FCloseShift+0x476>
    bcd0:	8c c1       	rjmp	.+792    	; 0xbfea <FCloseShift+0x376>
    bcd2:	8b 30       	cpi	r24, 0x0B	; 11
    bcd4:	09 f4       	brne	.+2      	; 0xbcd8 <FCloseShift+0x64>
    bcd6:	05 c2       	rjmp	.+1034   	; 0xc0e2 <FCloseShift+0x46e>
    bcd8:	8c 30       	cpi	r24, 0x0C	; 12
    bcda:	09 f0       	breq	.+2      	; 0xbcde <FCloseShift+0x6a>
    bcdc:	06 c2       	rjmp	.+1036   	; 0xc0ea <FCloseShift+0x476>
    bcde:	cc c1       	rjmp	.+920    	; 0xc078 <FCloseShift+0x404>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bce0:	e1 99       	sbic	0x1c, 1	; 28
    bce2:	fe cf       	rjmp	.-4      	; 0xbce0 <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bce4:	89 e4       	ldi	r24, 0x49	; 73
    bce6:	91 e0       	ldi	r25, 0x01	; 1
    bce8:	9f bb       	out	0x1f, r25	; 31
    bcea:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    bcec:	e0 9a       	sbi	0x1c, 0	; 28
    bcee:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    bcf0:	80 93 4f 01 	sts	0x014F, r24
		  IsPumpBusy=False;
    bcf4:	10 92 51 02 	sts	0x0251, r1
    bcf8:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    bcfa:	dd 24       	eor	r13, r13
    bcfc:	d3 94       	inc	r13
    bcfe:	36 c0       	rjmp	.+108    	; 0xbd6c <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    bd00:	0f 2d       	mov	r16, r15
    bd02:	10 e0       	ldi	r17, 0x00	; 0
    bd04:	f8 01       	movw	r30, r16
    bd06:	ee 5f       	subi	r30, 0xFE	; 254
    bd08:	fe 4f       	sbci	r31, 0xFE	; 254
    bd0a:	e0 80       	ld	r14, Z
    bd0c:	8e e0       	ldi	r24, 0x0E	; 14
    bd0e:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    bd12:	e8 16       	cp	r14, r24
    bd14:	81 f0       	breq	.+32     	; 0xbd36 <FCloseShift+0xc2>
    bd16:	86 e0       	ldi	r24, 0x06	; 6
    bd18:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    bd1c:	e8 16       	cp	r14, r24
    bd1e:	59 f0       	breq	.+22     	; 0xbd36 <FCloseShift+0xc2>
    bd20:	89 e0       	ldi	r24, 0x09	; 9
    bd22:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    bd26:	e8 16       	cp	r14, r24
    bd28:	31 f0       	breq	.+12     	; 0xbd36 <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    bd2a:	8f 2d       	mov	r24, r15
    bd2c:	0e 94 9a 21 	call	0x4334	; 0x4334 <GetPumpID>
    bd30:	66 e0       	ldi	r22, 0x06	; 6
    bd32:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    bd36:	84 e1       	ldi	r24, 0x14	; 20
    bd38:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    bd3c:	f8 01       	movw	r30, r16
    bd3e:	ee 5f       	subi	r30, 0xFE	; 254
    bd40:	fe 4f       	sbci	r31, 0xFE	; 254
    bd42:	90 81       	ld	r25, Z
    bd44:	98 17       	cp	r25, r24
    bd46:	31 f4       	brne	.+12     	; 0xbd54 <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    bd48:	8f 2d       	mov	r24, r15
    bd4a:	0e 94 9a 21 	call	0x4334	; 0x4334 <GetPumpID>
    bd4e:	66 e0       	ldi	r22, 0x06	; 6
    bd50:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    bd54:	89 e0       	ldi	r24, 0x09	; 9
    bd56:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    bd5a:	0e 5f       	subi	r16, 0xFE	; 254
    bd5c:	1e 4f       	sbci	r17, 0xFE	; 254
    bd5e:	d8 01       	movw	r26, r16
    bd60:	9c 91       	ld	r25, X
    bd62:	98 17       	cp	r25, r24
    bd64:	11 f4       	brne	.+4      	; 0xbd6a <FCloseShift+0xf6>
			       IsPumpBusy=True;
    bd66:	d0 92 51 02 	sts	0x0251, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    bd6a:	f3 94       	inc	r15
    bd6c:	80 91 4f 01 	lds	r24, 0x014F
    bd70:	f8 16       	cp	r15, r24
    bd72:	30 f2       	brcs	.-116    	; 0xbd00 <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    bd74:	84 e0       	ldi	r24, 0x04	; 4
    bd76:	b2 c1       	rjmp	.+868    	; 0xc0dc <FCloseShift+0x468>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    bd78:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    bd7c:	81 e0       	ldi	r24, 0x01	; 1
    bd7e:	61 e0       	ldi	r22, 0x01	; 1
    bd80:	4c e9       	ldi	r20, 0x9C	; 156
    bd82:	56 e1       	ldi	r21, 0x16	; 22
    bd84:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    bd88:	00 91 4f 01 	lds	r16, 0x014F
    bd8c:	10 e0       	ldi	r17, 0x00	; 0
    bd8e:	82 e0       	ldi	r24, 0x02	; 2
    bd90:	91 e0       	ldi	r25, 0x01	; 1
    bd92:	0e 94 e4 35 	call	0x6bc8	; 0x6bc8 <CountTotalizerSatus>
    bd96:	00 d0       	rcall	.+0      	; 0xbd98 <FCloseShift+0x124>
    bd98:	00 d0       	rcall	.+0      	; 0xbd9a <FCloseShift+0x126>
    bd9a:	00 d0       	rcall	.+0      	; 0xbd9c <FCloseShift+0x128>
    bd9c:	ed b7       	in	r30, 0x3d	; 61
    bd9e:	fe b7       	in	r31, 0x3e	; 62
    bda0:	31 96       	adiw	r30, 0x01	; 1
    bda2:	7e 01       	movw	r14, r28
    bda4:	08 94       	sec
    bda6:	e1 1c       	adc	r14, r1
    bda8:	f1 1c       	adc	r15, r1
    bdaa:	ad b7       	in	r26, 0x3d	; 61
    bdac:	be b7       	in	r27, 0x3e	; 62
    bdae:	12 96       	adiw	r26, 0x02	; 2
    bdb0:	fc 92       	st	X, r15
    bdb2:	ee 92       	st	-X, r14
    bdb4:	11 97       	sbiw	r26, 0x01	; 1
    bdb6:	2e e8       	ldi	r18, 0x8E	; 142
    bdb8:	36 e1       	ldi	r19, 0x16	; 22
    bdba:	33 83       	std	Z+3, r19	; 0x03
    bdbc:	22 83       	std	Z+2, r18	; 0x02
    bdbe:	08 1b       	sub	r16, r24
    bdc0:	11 09       	sbc	r17, r1
    bdc2:	15 83       	std	Z+5, r17	; 0x05
    bdc4:	04 83       	std	Z+4, r16	; 0x04
    bdc6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    bdca:	ed b7       	in	r30, 0x3d	; 61
    bdcc:	fe b7       	in	r31, 0x3e	; 62
    bdce:	36 96       	adiw	r30, 0x06	; 6
    bdd0:	0f b6       	in	r0, 0x3f	; 63
    bdd2:	f8 94       	cli
    bdd4:	fe bf       	out	0x3e, r31	; 62
    bdd6:	0f be       	out	0x3f, r0	; 63
    bdd8:	ed bf       	out	0x3d, r30	; 61
    bdda:	82 e0       	ldi	r24, 0x02	; 2
    bddc:	61 e0       	ldi	r22, 0x01	; 1
    bdde:	a7 01       	movw	r20, r14
    bde0:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>


          IsNewPumpStatus=True;
    bde4:	11 e0       	ldi	r17, 0x01	; 1
    bde6:	10 93 01 01 	sts	0x0101, r17
		  DisplayPumpStatus(); 
    bdea:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    bdee:	95 e0       	ldi	r25, 0x05	; 5
    bdf0:	90 93 b0 05 	sts	0x05B0, r25
	 PoolMsg=plMsg;
    bdf4:	82 e1       	ldi	r24, 0x12	; 18
    bdf6:	80 93 e0 0d 	sts	0x0DE0, r24
     IsControlPooling=True;
    bdfa:	10 93 86 01 	sts	0x0186, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    bdfe:	90 93 52 02 	sts	0x0252, r25
    be02:	73 c1       	rjmp	.+742    	; 0xc0ea <FCloseShift+0x476>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    be04:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <DisplayPumpStatus>
		  TimDisplay=0;         
    be08:	10 92 94 01 	sts	0x0194, r1
          stCloseShift=csWaitTotalizerComplete;
    be0c:	86 e0       	ldi	r24, 0x06	; 6
    be0e:	66 c1       	rjmp	.+716    	; 0xc0dc <FCloseShift+0x468>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    be10:	81 e0       	ldi	r24, 0x01	; 1
    be12:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    be16:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    be18:	80 91 01 01 	lds	r24, 0x0101
    be1c:	81 30       	cpi	r24, 0x01	; 1
    be1e:	89 f5       	brne	.+98     	; 0xbe82 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    be20:	00 91 4f 01 	lds	r16, 0x014F
    be24:	10 e0       	ldi	r17, 0x00	; 0
    be26:	82 e0       	ldi	r24, 0x02	; 2
    be28:	91 e0       	ldi	r25, 0x01	; 1
    be2a:	0e 94 e4 35 	call	0x6bc8	; 0x6bc8 <CountTotalizerSatus>
    be2e:	00 d0       	rcall	.+0      	; 0xbe30 <FCloseShift+0x1bc>
    be30:	00 d0       	rcall	.+0      	; 0xbe32 <FCloseShift+0x1be>
    be32:	00 d0       	rcall	.+0      	; 0xbe34 <FCloseShift+0x1c0>
    be34:	ed b7       	in	r30, 0x3d	; 61
    be36:	fe b7       	in	r31, 0x3e	; 62
    be38:	31 96       	adiw	r30, 0x01	; 1
    be3a:	7e 01       	movw	r14, r28
    be3c:	08 94       	sec
    be3e:	e1 1c       	adc	r14, r1
    be40:	f1 1c       	adc	r15, r1
    be42:	ad b7       	in	r26, 0x3d	; 61
    be44:	be b7       	in	r27, 0x3e	; 62
    be46:	12 96       	adiw	r26, 0x02	; 2
    be48:	fc 92       	st	X, r15
    be4a:	ee 92       	st	-X, r14
    be4c:	11 97       	sbiw	r26, 0x01	; 1
    be4e:	20 e8       	ldi	r18, 0x80	; 128
    be50:	36 e1       	ldi	r19, 0x16	; 22
    be52:	33 83       	std	Z+3, r19	; 0x03
    be54:	22 83       	std	Z+2, r18	; 0x02
    be56:	08 1b       	sub	r16, r24
    be58:	11 09       	sbc	r17, r1
    be5a:	15 83       	std	Z+5, r17	; 0x05
    be5c:	04 83       	std	Z+4, r16	; 0x04
    be5e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  lcd_print(2,1,lcdteks);
    be62:	ed b7       	in	r30, 0x3d	; 61
    be64:	fe b7       	in	r31, 0x3e	; 62
    be66:	36 96       	adiw	r30, 0x06	; 6
    be68:	0f b6       	in	r0, 0x3f	; 63
    be6a:	f8 94       	cli
    be6c:	fe bf       	out	0x3e, r31	; 62
    be6e:	0f be       	out	0x3f, r0	; 63
    be70:	ed bf       	out	0x3d, r30	; 61
    be72:	82 e0       	ldi	r24, 0x02	; 2
    be74:	61 e0       	ldi	r22, 0x01	; 1
    be76:	a7 01       	movw	r20, r14
    be78:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    be7c:	85 e0       	ldi	r24, 0x05	; 5
    be7e:	80 93 52 02 	sts	0x0252, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    be82:	82 e0       	ldi	r24, 0x02	; 2
    be84:	91 e0       	ldi	r25, 0x01	; 1
    be86:	0e 94 e4 35 	call	0x6bc8	; 0x6bc8 <CountTotalizerSatus>
    be8a:	90 91 4f 01 	lds	r25, 0x014F
    be8e:	89 17       	cp	r24, r25
    be90:	a0 f0       	brcs	.+40     	; 0xbeba <FCloseShift+0x246>
    be92:	80 91 94 01 	lds	r24, 0x0194
    be96:	86 30       	cpi	r24, 0x06	; 6
    be98:	80 f0       	brcs	.+32     	; 0xbeba <FCloseShift+0x246>
    be9a:	10 e0       	ldi	r17, 0x00	; 0
    be9c:	07 c0       	rjmp	.+14     	; 0xbeac <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    be9e:	81 2f       	mov	r24, r17
    bea0:	0e 94 9a 21 	call	0x4334	; 0x4334 <GetPumpID>
    bea4:	66 e0       	ldi	r22, 0x06	; 6
    bea6:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    beaa:	1f 5f       	subi	r17, 0xFF	; 255
    beac:	80 91 4f 01 	lds	r24, 0x014F
    beb0:	18 17       	cp	r17, r24
    beb2:	a8 f3       	brcs	.-22     	; 0xbe9e <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    beb4:	88 e0       	ldi	r24, 0x08	; 8
    beb6:	80 93 52 02 	sts	0x0252, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    beba:	80 91 94 01 	lds	r24, 0x0194
    bebe:	80 31       	cpi	r24, 0x10	; 16
    bec0:	08 f4       	brcc	.+2      	; 0xbec4 <FCloseShift+0x250>
    bec2:	64 c0       	rjmp	.+200    	; 0xbf8c <FCloseShift+0x318>
    bec4:	80 91 51 02 	lds	r24, 0x0251
    bec8:	81 30       	cpi	r24, 0x01	; 1
    beca:	09 f4       	brne	.+2      	; 0xbece <FCloseShift+0x25a>
    becc:	5f c0       	rjmp	.+190    	; 0xbf8c <FCloseShift+0x318>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    bece:	82 e0       	ldi	r24, 0x02	; 2
    bed0:	91 e0       	ldi	r25, 0x01	; 1
    bed2:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <CountNoPumpSatus>
    bed6:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bed8:	e1 99       	sbic	0x1c, 1	; 28
    beda:	fe cf       	rjmp	.-4      	; 0xbed8 <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bedc:	89 e4       	ldi	r24, 0x49	; 73
    bede:	91 e0       	ldi	r25, 0x01	; 1
    bee0:	9f bb       	out	0x1f, r25	; 31
    bee2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    bee4:	e0 9a       	sbi	0x1c, 0	; 28
    bee6:	8d b3       	in	r24, 0x1d	; 29
    bee8:	28 17       	cp	r18, r24
    beea:	08 f4       	brcc	.+2      	; 0xbeee <FCloseShift+0x27a>
    beec:	4f c0       	rjmp	.+158    	; 0xbf8c <FCloseShift+0x318>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    beee:	00 91 4f 01 	lds	r16, 0x014F
    bef2:	10 e0       	ldi	r17, 0x00	; 0
    bef4:	82 e0       	ldi	r24, 0x02	; 2
    bef6:	91 e0       	ldi	r25, 0x01	; 1
    bef8:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <CountNoPumpSatus>
    befc:	00 d0       	rcall	.+0      	; 0xbefe <FCloseShift+0x28a>
    befe:	00 d0       	rcall	.+0      	; 0xbf00 <FCloseShift+0x28c>
    bf00:	00 d0       	rcall	.+0      	; 0xbf02 <FCloseShift+0x28e>
    bf02:	ed b7       	in	r30, 0x3d	; 61
    bf04:	fe b7       	in	r31, 0x3e	; 62
    bf06:	31 96       	adiw	r30, 0x01	; 1
    bf08:	7e 01       	movw	r14, r28
    bf0a:	08 94       	sec
    bf0c:	e1 1c       	adc	r14, r1
    bf0e:	f1 1c       	adc	r15, r1
    bf10:	ad b7       	in	r26, 0x3d	; 61
    bf12:	be b7       	in	r27, 0x3e	; 62
    bf14:	12 96       	adiw	r26, 0x02	; 2
    bf16:	fc 92       	st	X, r15
    bf18:	ee 92       	st	-X, r14
    bf1a:	11 97       	sbiw	r26, 0x01	; 1
    bf1c:	2c e6       	ldi	r18, 0x6C	; 108
    bf1e:	36 e1       	ldi	r19, 0x16	; 22
    bf20:	33 83       	std	Z+3, r19	; 0x03
    bf22:	22 83       	std	Z+2, r18	; 0x02
    bf24:	08 1b       	sub	r16, r24
    bf26:	11 09       	sbc	r17, r1
    bf28:	15 83       	std	Z+5, r17	; 0x05
    bf2a:	04 83       	std	Z+4, r16	; 0x04
    bf2c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    bf30:	ed b7       	in	r30, 0x3d	; 61
    bf32:	fe b7       	in	r31, 0x3e	; 62
    bf34:	36 96       	adiw	r30, 0x06	; 6
    bf36:	0f b6       	in	r0, 0x3f	; 63
    bf38:	f8 94       	cli
    bf3a:	fe bf       	out	0x3e, r31	; 62
    bf3c:	0f be       	out	0x3f, r0	; 63
    bf3e:	ed bf       	out	0x3d, r30	; 61
    bf40:	83 e0       	ldi	r24, 0x03	; 3
    bf42:	61 e0       	ldi	r22, 0x01	; 1
    bf44:	a7 01       	movw	r20, r14
    bf46:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    bf4a:	10 e0       	ldi	r17, 0x00	; 0
    bf4c:	11 c0       	rjmp	.+34     	; 0xbf70 <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    bf4e:	84 e1       	ldi	r24, 0x14	; 20
    bf50:	0e 94 bd 13 	call	0x277a	; 0x277a <GetPumpStatusLabel>
    bf54:	e1 2f       	mov	r30, r17
    bf56:	f0 e0       	ldi	r31, 0x00	; 0
    bf58:	ee 5f       	subi	r30, 0xFE	; 254
    bf5a:	fe 4f       	sbci	r31, 0xFE	; 254
    bf5c:	90 81       	ld	r25, Z
    bf5e:	98 17       	cp	r25, r24
    bf60:	31 f4       	brne	.+12     	; 0xbf6e <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    bf62:	81 2f       	mov	r24, r17
    bf64:	0e 94 9a 21 	call	0x4334	; 0x4334 <GetPumpID>
    bf68:	66 e0       	ldi	r22, 0x06	; 6
    bf6a:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    bf6e:	1f 5f       	subi	r17, 0xFF	; 255
    bf70:	80 91 4f 01 	lds	r24, 0x014F
    bf74:	18 17       	cp	r17, r24
    bf76:	58 f3       	brcs	.-42     	; 0xbf4e <FCloseShift+0x2da>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    bf78:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    bf7a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    bf7c:	81 e0       	ldi	r24, 0x01	; 1
    bf7e:	80 93 be 01 	sts	0x01BE, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    bf82:	10 92 94 01 	sts	0x0194, r1
			  stCloseShift=csNoPumpFound;		     
    bf86:	87 e0       	ldi	r24, 0x07	; 7
    bf88:	80 93 52 02 	sts	0x0252, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    bf8c:	f7 ee       	ldi	r31, 0xE7	; 231
    bf8e:	df 16       	cp	r13, r31
    bf90:	09 f0       	breq	.+2      	; 0xbf94 <FCloseShift+0x320>
    bf92:	ab c0       	rjmp	.+342    	; 0xc0ea <FCloseShift+0x476>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    bf94:	00 d0       	rcall	.+0      	; 0xbf96 <FCloseShift+0x322>
    bf96:	00 d0       	rcall	.+0      	; 0xbf98 <FCloseShift+0x324>
    bf98:	8e 01       	movw	r16, r28
    bf9a:	0f 5f       	subi	r16, 0xFF	; 255
    bf9c:	1f 4f       	sbci	r17, 0xFF	; 255
    bf9e:	ad b7       	in	r26, 0x3d	; 61
    bfa0:	be b7       	in	r27, 0x3e	; 62
    bfa2:	12 96       	adiw	r26, 0x02	; 2
    bfa4:	1c 93       	st	X, r17
    bfa6:	0e 93       	st	-X, r16
    bfa8:	11 97       	sbiw	r26, 0x01	; 1
    bfaa:	85 e6       	ldi	r24, 0x65	; 101
    bfac:	96 e1       	ldi	r25, 0x16	; 22
    bfae:	14 96       	adiw	r26, 0x04	; 4
    bfb0:	9c 93       	st	X, r25
    bfb2:	8e 93       	st	-X, r24
    bfb4:	13 97       	sbiw	r26, 0x03	; 3
    bfb6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    bfba:	0f 90       	pop	r0
    bfbc:	0f 90       	pop	r0
    bfbe:	0f 90       	pop	r0
    bfc0:	0f 90       	pop	r0
    bfc2:	83 e0       	ldi	r24, 0x03	; 3
    bfc4:	61 e0       	ldi	r22, 0x01	; 1
    bfc6:	a8 01       	movw	r20, r16
    bfc8:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    bfcc:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    bfce:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    bfd0:	81 e0       	ldi	r24, 0x01	; 1
    bfd2:	80 93 be 01 	sts	0x01BE, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    bfd6:	10 92 94 01 	sts	0x0194, r1
			  stCloseShift=csNoPumpFound;		     		  
    bfda:	87 e0       	ldi	r24, 0x07	; 7
    bfdc:	7f c0       	rjmp	.+254    	; 0xc0dc <FCloseShift+0x468>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    bfde:	80 91 94 01 	lds	r24, 0x0194
    bfe2:	8b 30       	cpi	r24, 0x0B	; 11
    bfe4:	08 f4       	brcc	.+2      	; 0xbfe8 <FCloseShift+0x374>
    bfe6:	81 c0       	rjmp	.+258    	; 0xc0ea <FCloseShift+0x476>
    bfe8:	78 c0       	rjmp	.+240    	; 0xc0da <FCloseShift+0x466>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    bfea:	81 e0       	ldi	r24, 0x01	; 1
    bfec:	61 e0       	ldi	r22, 0x01	; 1
    bfee:	42 e5       	ldi	r20, 0x52	; 82
    bff0:	56 e1       	ldi	r21, 0x16	; 22
    bff2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    bff6:	03 ec       	ldi	r16, 0xC3	; 195
    bff8:	13 e0       	ldi	r17, 0x03	; 3
    bffa:	fd e7       	ldi	r31, 0x7D	; 125
    bffc:	ef 2e       	mov	r14, r31
    bffe:	f8 e0       	ldi	r31, 0x08	; 8
    c000:	ff 2e       	mov	r15, r31
    c002:	80 e0       	ldi	r24, 0x00	; 0
    c004:	b8 01       	movw	r22, r16
    c006:	a7 01       	movw	r20, r14
    c008:	0e 94 b4 aa 	call	0x15568	; 0x15568 <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    c00c:	ed b7       	in	r30, 0x3d	; 61
    c00e:	fe b7       	in	r31, 0x3e	; 62
    c010:	38 97       	sbiw	r30, 0x08	; 8
    c012:	0f b6       	in	r0, 0x3f	; 63
    c014:	f8 94       	cli
    c016:	fe bf       	out	0x3e, r31	; 62
    c018:	0f be       	out	0x3f, r0	; 63
    c01a:	ed bf       	out	0x3d, r30	; 61
    c01c:	31 96       	adiw	r30, 0x01	; 1
    c01e:	87 e9       	ldi	r24, 0x97	; 151
    c020:	97 e0       	ldi	r25, 0x07	; 7
    c022:	ad b7       	in	r26, 0x3d	; 61
    c024:	be b7       	in	r27, 0x3e	; 62
    c026:	12 96       	adiw	r26, 0x02	; 2
    c028:	9c 93       	st	X, r25
    c02a:	8e 93       	st	-X, r24
    c02c:	11 97       	sbiw	r26, 0x01	; 1
    c02e:	8c e4       	ldi	r24, 0x4C	; 76
    c030:	96 e1       	ldi	r25, 0x16	; 22
    c032:	93 83       	std	Z+3, r25	; 0x03
    c034:	82 83       	std	Z+2, r24	; 0x02
    c036:	15 83       	std	Z+5, r17	; 0x05
    c038:	04 83       	std	Z+4, r16	; 0x04
    c03a:	f7 82       	std	Z+7, r15	; 0x07
    c03c:	e6 82       	std	Z+6, r14	; 0x06
    c03e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  IsGenerateReport=True;
    c042:	81 e0       	ldi	r24, 0x01	; 1
    c044:	80 93 88 01 	sts	0x0188, r24
		  IsFinishPrintingTotalizer=False;
    c048:	10 92 89 01 	sts	0x0189, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    c04c:	8a e0       	ldi	r24, 0x0A	; 10
    c04e:	80 93 52 02 	sts	0x0252, r24
    c052:	80 e0       	ldi	r24, 0x00	; 0
    c054:	ed b7       	in	r30, 0x3d	; 61
    c056:	fe b7       	in	r31, 0x3e	; 62
    c058:	38 96       	adiw	r30, 0x08	; 8
    c05a:	0f b6       	in	r0, 0x3f	; 63
    c05c:	f8 94       	cli
    c05e:	fe bf       	out	0x3e, r31	; 62
    c060:	0f be       	out	0x3f, r0	; 63
    c062:	ed bf       	out	0x3d, r30	; 61
    c064:	43 c0       	rjmp	.+134    	; 0xc0ec <FCloseShift+0x478>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    c066:	80 91 89 01 	lds	r24, 0x0189
    c06a:	81 30       	cpi	r24, 0x01	; 1
    c06c:	09 f0       	breq	.+2      	; 0xc070 <FCloseShift+0x3fc>
    c06e:	3d c0       	rjmp	.+122    	; 0xc0ea <FCloseShift+0x476>
		      IsFinishPrintingTotalizer=False;
    c070:	10 92 89 01 	sts	0x0189, r1
		      stCloseShift=csDumpShift;
    c074:	8c e0       	ldi	r24, 0x0C	; 12
    c076:	32 c0       	rjmp	.+100    	; 0xc0dc <FCloseShift+0x468>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    c078:	81 e0       	ldi	r24, 0x01	; 1
    c07a:	61 e0       	ldi	r22, 0x01	; 1
    c07c:	48 e3       	ldi	r20, 0x38	; 56
    c07e:	56 e1       	ldi	r21, 0x16	; 22
    c080:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    c084:	12 30       	cpi	r17, 0x02	; 2
    c086:	71 f4       	brne	.+28     	; 0xc0a4 <FCloseShift+0x430>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c088:	e1 99       	sbic	0x1c, 1	; 28
    c08a:	fe cf       	rjmp	.-4      	; 0xc088 <FCloseShift+0x414>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c08c:	2f e3       	ldi	r18, 0x3F	; 63
    c08e:	31 e0       	ldi	r19, 0x01	; 1
    c090:	3f bb       	out	0x1f, r19	; 31
    c092:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c094:	e0 9a       	sbi	0x1c, 0	; 28
    c096:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c098:	e1 99       	sbic	0x1c, 1	; 28
    c09a:	fe cf       	rjmp	.-4      	; 0xc098 <FCloseShift+0x424>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c09c:	3f bb       	out	0x1f, r19	; 31
    c09e:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    c0a0:	8f 5f       	subi	r24, 0xFF	; 255
    c0a2:	09 c0       	rjmp	.+18     	; 0xc0b6 <FCloseShift+0x442>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    c0a4:	11 30       	cpi	r17, 0x01	; 1
    c0a6:	69 f4       	brne	.+26     	; 0xc0c2 <FCloseShift+0x44e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c0a8:	e1 99       	sbic	0x1c, 1	; 28
    c0aa:	fe cf       	rjmp	.-4      	; 0xc0a8 <FCloseShift+0x434>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c0ac:	8f e3       	ldi	r24, 0x3F	; 63
    c0ae:	91 e0       	ldi	r25, 0x01	; 1
    c0b0:	9f bb       	out	0x1f, r25	; 31
    c0b2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c0b4:	81 e0       	ldi	r24, 0x01	; 1
    c0b6:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c0b8:	0f b6       	in	r0, 0x3f	; 63
    c0ba:	f8 94       	cli
    c0bc:	e2 9a       	sbi	0x1c, 2	; 28
    c0be:	e1 9a       	sbi	0x1c, 1	; 28
    c0c0:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    c0c2:	0e 94 eb 2b 	call	0x57d6	; 0x57d6 <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c0c6:	83 e4       	ldi	r24, 0x43	; 67
    c0c8:	98 e0       	ldi	r25, 0x08	; 8
    c0ca:	67 e9       	ldi	r22, 0x97	; 151
    c0cc:	77 e0       	ldi	r23, 0x07	; 7
    c0ce:	44 e1       	ldi	r20, 0x14	; 20
    c0d0:	50 e0       	ldi	r21, 0x00	; 0
    c0d2:	2a e4       	ldi	r18, 0x4A	; 74
    c0d4:	33 e1       	ldi	r19, 0x13	; 19
    c0d6:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    c0da:	8b e0       	ldi	r24, 0x0B	; 11
    c0dc:	80 93 52 02 	sts	0x0252, r24
    c0e0:	04 c0       	rjmp	.+8      	; 0xc0ea <FCloseShift+0x476>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    c0e2:	10 92 52 02 	sts	0x0252, r1
    c0e6:	81 e0       	ldi	r24, 0x01	; 1
    c0e8:	01 c0       	rjmp	.+2      	; 0xc0ec <FCloseShift+0x478>
    c0ea:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    c0ec:	64 96       	adiw	r28, 0x14	; 20
    c0ee:	0f b6       	in	r0, 0x3f	; 63
    c0f0:	f8 94       	cli
    c0f2:	de bf       	out	0x3e, r29	; 62
    c0f4:	0f be       	out	0x3f, r0	; 63
    c0f6:	cd bf       	out	0x3d, r28	; 61
    c0f8:	cf 91       	pop	r28
    c0fa:	df 91       	pop	r29
    c0fc:	1f 91       	pop	r17
    c0fe:	0f 91       	pop	r16
    c100:	ff 90       	pop	r15
    c102:	ef 90       	pop	r14
    c104:	df 90       	pop	r13
    c106:	08 95       	ret

0000c108 <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    c108:	2f 92       	push	r2
    c10a:	3f 92       	push	r3
    c10c:	4f 92       	push	r4
    c10e:	5f 92       	push	r5
    c110:	6f 92       	push	r6
    c112:	7f 92       	push	r7
    c114:	8f 92       	push	r8
    c116:	9f 92       	push	r9
    c118:	bf 92       	push	r11
    c11a:	cf 92       	push	r12
    c11c:	df 92       	push	r13
    c11e:	ef 92       	push	r14
    c120:	ff 92       	push	r15
    c122:	0f 93       	push	r16
    c124:	1f 93       	push	r17
    c126:	df 93       	push	r29
    c128:	cf 93       	push	r28
    c12a:	cd b7       	in	r28, 0x3d	; 61
    c12c:	de b7       	in	r29, 0x3e	; 62
    c12e:	6d 97       	sbiw	r28, 0x1d	; 29
    c130:	0f b6       	in	r0, 0x3f	; 63
    c132:	f8 94       	cli
    c134:	de bf       	out	0x3e, r29	; 62
    c136:	0f be       	out	0x3f, r0	; 63
    c138:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c13a:	e1 99       	sbic	0x1c, 1	; 28
    c13c:	fe cf       	rjmp	.-4      	; 0xc13a <_menu_host+0x32>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c13e:	21 ec       	ldi	r18, 0xC1	; 193
    c140:	33 e0       	ldi	r19, 0x03	; 3
    c142:	3f bb       	out	0x1f, r19	; 31
    c144:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c146:	e0 9a       	sbi	0x1c, 0	; 28
    c148:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    c14a:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c14c:	e1 99       	sbic	0x1c, 1	; 28
    c14e:	fe cf       	rjmp	.-4      	; 0xc14c <_menu_host+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c150:	87 e3       	ldi	r24, 0x37	; 55
    c152:	90 e0       	ldi	r25, 0x00	; 0
    c154:	9f bb       	out	0x1f, r25	; 31
    c156:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c158:	e0 9a       	sbi	0x1c, 0	; 28
    c15a:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&DefShowDateTime);
    c15c:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c15e:	e1 99       	sbic	0x1c, 1	; 28
    c160:	fe cf       	rjmp	.-4      	; 0xc15e <_menu_host+0x56>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c162:	a8 e3       	ldi	r26, 0x38	; 56
    c164:	b0 e0       	ldi	r27, 0x00	; 0
    c166:	bf bb       	out	0x1f, r27	; 31
    c168:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c16a:	e0 9a       	sbi	0x1c, 0	; 28
    c16c:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    c16e:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c170:	e1 99       	sbic	0x1c, 1	; 28
    c172:	fe cf       	rjmp	.-4      	; 0xc170 <_menu_host+0x68>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c174:	60 e0       	ldi	r22, 0x00	; 0
    c176:	26 2e       	mov	r2, r22
    c178:	60 e0       	ldi	r22, 0x00	; 0
    c17a:	36 2e       	mov	r3, r22
    c17c:	3f ba       	out	0x1f, r3	; 31
    c17e:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c180:	e0 9a       	sbi	0x1c, 0	; 28
    c182:	bd b2       	in	r11, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);


	lcd_clear();_delay_ms(10);
    c184:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    c188:	84 ec       	ldi	r24, 0xC4	; 196
    c18a:	99 e0       	ldi	r25, 0x09	; 9
    c18c:	01 97       	sbiw	r24, 0x01	; 1
    c18e:	f1 f7       	brne	.-4      	; 0xc18c <_menu_host+0x84>
	lcd_printf(1, 1, PSTR("1)Money :"));
    c190:	81 e0       	ldi	r24, 0x01	; 1
    c192:	61 e0       	ldi	r22, 0x01	; 1
    c194:	42 e2       	ldi	r20, 0x22	; 34
    c196:	5c e0       	ldi	r21, 0x0C	; 12
    c198:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    c19c:	82 e0       	ldi	r24, 0x02	; 2
    c19e:	61 e0       	ldi	r22, 0x01	; 1
    c1a0:	48 e1       	ldi	r20, 0x18	; 24
    c1a2:	5c e0       	ldi	r21, 0x0C	; 12
    c1a4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    c1a8:	83 e0       	ldi	r24, 0x03	; 3
    c1aa:	61 e0       	ldi	r22, 0x01	; 1
    c1ac:	43 e0       	ldi	r20, 0x03	; 3
    c1ae:	5c e0       	ldi	r21, 0x0C	; 12
    c1b0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    c1b4:	00 d0       	rcall	.+0      	; 0xc1b6 <_menu_host+0xae>
    c1b6:	00 d0       	rcall	.+0      	; 0xc1b8 <_menu_host+0xb0>
    c1b8:	00 d0       	rcall	.+0      	; 0xc1ba <_menu_host+0xb2>
    c1ba:	ed b7       	in	r30, 0x3d	; 61
    c1bc:	fe b7       	in	r31, 0x3e	; 62
    c1be:	31 96       	adiw	r30, 0x01	; 1
    c1c0:	8e 01       	movw	r16, r28
    c1c2:	06 5f       	subi	r16, 0xF6	; 246
    c1c4:	1f 4f       	sbci	r17, 0xFF	; 255
    c1c6:	ad b7       	in	r26, 0x3d	; 61
    c1c8:	be b7       	in	r27, 0x3e	; 62
    c1ca:	12 96       	adiw	r26, 0x02	; 2
    c1cc:	1c 93       	st	X, r17
    c1ce:	0e 93       	st	-X, r16
    c1d0:	11 97       	sbiw	r26, 0x01	; 1
    c1d2:	86 ef       	ldi	r24, 0xF6	; 246
    c1d4:	9b e0       	ldi	r25, 0x0B	; 11
    c1d6:	93 83       	std	Z+3, r25	; 0x03
    c1d8:	82 83       	std	Z+2, r24	; 0x02
    c1da:	b4 82       	std	Z+4, r11	; 0x04
    c1dc:	15 82       	std	Z+5, r1	; 0x05
    c1de:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	lcd_print(4, 1,lcdteks);
    c1e2:	ed b7       	in	r30, 0x3d	; 61
    c1e4:	fe b7       	in	r31, 0x3e	; 62
    c1e6:	36 96       	adiw	r30, 0x06	; 6
    c1e8:	0f b6       	in	r0, 0x3f	; 63
    c1ea:	f8 94       	cli
    c1ec:	fe bf       	out	0x3e, r31	; 62
    c1ee:	0f be       	out	0x3f, r0	; 63
    c1f0:	ed bf       	out	0x3d, r30	; 61
    c1f2:	84 e0       	ldi	r24, 0x04	; 4
    c1f4:	61 e0       	ldi	r22, 0x01	; 1
    c1f6:	a8 01       	movw	r20, r16
    c1f8:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    c1fc:	84 e0       	ldi	r24, 0x04	; 4
    c1fe:	6f e0       	ldi	r22, 0x0F	; 15
    c200:	4f ee       	ldi	r20, 0xEF	; 239
    c202:	5b e0       	ldi	r21, 0x0B	; 11
    c204:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    c208:	52 ec       	ldi	r21, 0xC2	; 194
    c20a:	e5 2e       	mov	r14, r21
    c20c:	52 e0       	ldi	r21, 0x02	; 2
    c20e:	f5 2e       	mov	r15, r21
    c210:	6e 01       	movw	r12, r28
    c212:	08 94       	sec
    c214:	c1 1c       	adc	r12, r1
    c216:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		sprintf_P(__buff,PSTR("%d"),__value[__i]);
    c218:	45 e0       	ldi	r20, 0x05	; 5
    c21a:	84 2e       	mov	r8, r20
    c21c:	91 2c       	mov	r9, r1
    c21e:	8c 0e       	add	r8, r28
    c220:	9d 1e       	adc	r9, r29
    c222:	3c ee       	ldi	r19, 0xEC	; 236
    c224:	63 2e       	mov	r6, r19
    c226:	3b e0       	ldi	r19, 0x0B	; 11
    c228:	73 2e       	mov	r7, r19
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
	lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    c22a:	f7 01       	movw	r30, r14
    c22c:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    c22e:	08 94       	sec
    c230:	e1 1c       	adc	r14, r1
    c232:	f1 1c       	adc	r15, r1
    c234:	f7 01       	movw	r30, r14
    c236:	14 91       	lpm	r17, Z+
		sprintf_P(__buff,PSTR("%d"),__value[__i]);
    c238:	00 d0       	rcall	.+0      	; 0xc23a <_menu_host+0x132>
    c23a:	00 d0       	rcall	.+0      	; 0xc23c <_menu_host+0x134>
    c23c:	00 d0       	rcall	.+0      	; 0xc23e <_menu_host+0x136>
    c23e:	ed b7       	in	r30, 0x3d	; 61
    c240:	fe b7       	in	r31, 0x3e	; 62
    c242:	31 96       	adiw	r30, 0x01	; 1
    c244:	ad b7       	in	r26, 0x3d	; 61
    c246:	be b7       	in	r27, 0x3e	; 62
    c248:	12 96       	adiw	r26, 0x02	; 2
    c24a:	9c 92       	st	X, r9
    c24c:	8e 92       	st	-X, r8
    c24e:	11 97       	sbiw	r26, 0x01	; 1
    c250:	73 82       	std	Z+3, r7	; 0x03
    c252:	62 82       	std	Z+2, r6	; 0x02
    c254:	d6 01       	movw	r26, r12
    c256:	8d 91       	ld	r24, X+
    c258:	6d 01       	movw	r12, r26
    c25a:	84 83       	std	Z+4, r24	; 0x04
    c25c:	15 82       	std	Z+5, r1	; 0x05
    c25e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		//_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
    c262:	ed b7       	in	r30, 0x3d	; 61
    c264:	fe b7       	in	r31, 0x3e	; 62
    c266:	36 96       	adiw	r30, 0x06	; 6
    c268:	0f b6       	in	r0, 0x3f	; 63
    c26a:	f8 94       	cli
    c26c:	fe bf       	out	0x3e, r31	; 62
    c26e:	0f be       	out	0x3f, r0	; 63
    c270:	ed bf       	out	0x3d, r30	; 61
    c272:	80 2f       	mov	r24, r16
    c274:	61 2f       	mov	r22, r17
    c276:	a4 01       	movw	r20, r8
    c278:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    c27c:	08 94       	sec
    c27e:	e1 1c       	adc	r14, r1
    c280:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
	lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    c282:	f8 ec       	ldi	r31, 0xC8	; 200
    c284:	ef 16       	cp	r14, r31
    c286:	f2 e0       	ldi	r31, 0x02	; 2
    c288:	ff 06       	cpc	r15, r31
    c28a:	79 f6       	brne	.-98     	; 0xc22a <_menu_host+0x122>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    c28c:	2a e0       	ldi	r18, 0x0A	; 10
    c28e:	82 2e       	mov	r8, r18
    c290:	91 2c       	mov	r9, r1
    c292:	8c 0e       	add	r8, r28
    c294:	9d 1e       	adc	r9, r29
    c296:	9c ed       	ldi	r25, 0xDC	; 220
    c298:	49 2e       	mov	r4, r25
    c29a:	9b e0       	ldi	r25, 0x0B	; 11
    c29c:	59 2e       	mov	r5, r25
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    c29e:	6e 01       	movw	r12, r28
    c2a0:	08 94       	sec
    c2a2:	c1 1c       	adc	r12, r1
    c2a4:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    c2a6:	85 e0       	ldi	r24, 0x05	; 5
    c2a8:	e8 2e       	mov	r14, r24
    c2aa:	f1 2c       	mov	r15, r1
    c2ac:	ec 0e       	add	r14, r28
    c2ae:	fd 1e       	adc	r15, r29
    c2b0:	09 ee       	ldi	r16, 0xE9	; 233
    c2b2:	60 2e       	mov	r6, r16
    c2b4:	0b e0       	ldi	r16, 0x0B	; 11
    c2b6:	70 2e       	mov	r7, r16
		//_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    c2b8:	81 e0       	ldi	r24, 0x01	; 1
    c2ba:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    c2be:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    c2c0:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    c2c4:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    c2c6:	17 3e       	cpi	r17, 0xE7	; 231
    c2c8:	09 f4       	brne	.+2      	; 0xc2cc <_menu_host+0x1c4>
    c2ca:	a9 c0       	rjmp	.+338    	; 0xc41e <_menu_host+0x316>
			return;
		if(__key==_KEY_ENTER){
    c2cc:	17 3b       	cpi	r17, 0xB7	; 183
    c2ce:	09 f0       	breq	.+2      	; 0xc2d2 <_menu_host+0x1ca>
    c2d0:	32 c0       	rjmp	.+100    	; 0xc336 <_menu_host+0x22e>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    c2d2:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c2d4:	e1 99       	sbic	0x1c, 1	; 28
    c2d6:	fe cf       	rjmp	.-4      	; 0xc2d4 <_menu_host+0x1cc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c2d8:	21 ec       	ldi	r18, 0xC1	; 193
    c2da:	33 e0       	ldi	r19, 0x03	; 3
    c2dc:	3f bb       	out	0x1f, r19	; 31
    c2de:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    c2e0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c2e2:	0f b6       	in	r0, 0x3f	; 63
    c2e4:	f8 94       	cli
    c2e6:	e2 9a       	sbi	0x1c, 2	; 28
    c2e8:	e1 9a       	sbi	0x1c, 1	; 28
    c2ea:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefShowDateTime, __value[1]);
    c2ec:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c2ee:	e1 99       	sbic	0x1c, 1	; 28
    c2f0:	fe cf       	rjmp	.-4      	; 0xc2ee <_menu_host+0x1e6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c2f2:	a7 e3       	ldi	r26, 0x37	; 55
    c2f4:	b0 e0       	ldi	r27, 0x00	; 0
    c2f6:	bf bb       	out	0x1f, r27	; 31
    c2f8:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    c2fa:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c2fc:	0f b6       	in	r0, 0x3f	; 63
    c2fe:	f8 94       	cli
    c300:	e2 9a       	sbi	0x1c, 2	; 28
    c302:	e1 9a       	sbi	0x1c, 1	; 28
    c304:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    c306:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c308:	e1 99       	sbic	0x1c, 1	; 28
    c30a:	fe cf       	rjmp	.-4      	; 0xc308 <_menu_host+0x200>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c30c:	e8 e3       	ldi	r30, 0x38	; 56
    c30e:	f0 e0       	ldi	r31, 0x00	; 0
    c310:	ff bb       	out	0x1f, r31	; 31
    c312:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    c314:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c316:	0f b6       	in	r0, 0x3f	; 63
    c318:	f8 94       	cli
    c31a:	e2 9a       	sbi	0x1c, 2	; 28
    c31c:	e1 9a       	sbi	0x1c, 1	; 28
    c31e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c320:	e1 99       	sbic	0x1c, 1	; 28
    c322:	fe cf       	rjmp	.-4      	; 0xc320 <_menu_host+0x218>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c324:	3f ba       	out	0x1f, r3	; 31
    c326:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    c328:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    c32a:	0f b6       	in	r0, 0x3f	; 63
    c32c:	f8 94       	cli
    c32e:	e2 9a       	sbi	0x1c, 2	; 28
    c330:	e1 9a       	sbi	0x1c, 1	; 28
    c332:	0f be       	out	0x3f, r0	; 63
    c334:	74 c0       	rjmp	.+232    	; 0xc41e <_menu_host+0x316>
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    c336:	81 53       	subi	r24, 0x31	; 49
    c338:	83 30       	cpi	r24, 0x03	; 3
    c33a:	08 f0       	brcs	.+2      	; 0xc33e <_menu_host+0x236>
    c33c:	40 c0       	rjmp	.+128    	; 0xc3be <_menu_host+0x2b6>
			if(__value[__num - 0x31] == 1)
    c33e:	a9 2f       	mov	r26, r25
    c340:	b0 e0       	ldi	r27, 0x00	; 0
    c342:	d1 97       	sbiw	r26, 0x31	; 49
    c344:	f6 01       	movw	r30, r12
    c346:	ea 0f       	add	r30, r26
    c348:	fb 1f       	adc	r31, r27
    c34a:	80 81       	ld	r24, Z
    c34c:	81 30       	cpi	r24, 0x01	; 1
    c34e:	11 f4       	brne	.+4      	; 0xc354 <_menu_host+0x24c>
				__value[__num - 0x31] = 0;
    c350:	10 82       	st	Z, r1
    c352:	02 c0       	rjmp	.+4      	; 0xc358 <_menu_host+0x250>
			else
				__value[__num - 0x31]++;
    c354:	8f 5f       	subi	r24, 0xFF	; 255
    c356:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    c358:	29 2f       	mov	r18, r25
    c35a:	30 e0       	ldi	r19, 0x00	; 0
    c35c:	21 53       	subi	r18, 0x31	; 49
    c35e:	30 40       	sbci	r19, 0x00	; 0
    c360:	22 0f       	add	r18, r18
    c362:	33 1f       	adc	r19, r19
    c364:	c9 01       	movw	r24, r18
    c366:	8e 53       	subi	r24, 0x3E	; 62
    c368:	9d 4f       	sbci	r25, 0xFD	; 253
    c36a:	fc 01       	movw	r30, r24
    c36c:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    c36e:	2d 53       	subi	r18, 0x3D	; 61
    c370:	3d 4f       	sbci	r19, 0xFD	; 253
    c372:	f9 01       	movw	r30, r18
    c374:	14 91       	lpm	r17, Z+
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    c376:	00 d0       	rcall	.+0      	; 0xc378 <_menu_host+0x270>
    c378:	00 d0       	rcall	.+0      	; 0xc37a <_menu_host+0x272>
    c37a:	00 d0       	rcall	.+0      	; 0xc37c <_menu_host+0x274>
    c37c:	2d b7       	in	r18, 0x3d	; 61
    c37e:	3e b7       	in	r19, 0x3e	; 62
    c380:	2f 5f       	subi	r18, 0xFF	; 255
    c382:	3f 4f       	sbci	r19, 0xFF	; 255
    c384:	ed b7       	in	r30, 0x3d	; 61
    c386:	fe b7       	in	r31, 0x3e	; 62
    c388:	f2 82       	std	Z+2, r15	; 0x02
    c38a:	e1 82       	std	Z+1, r14	; 0x01
    c38c:	f9 01       	movw	r30, r18
    c38e:	73 82       	std	Z+3, r7	; 0x03
    c390:	62 82       	std	Z+2, r6	; 0x02
    c392:	ac 0d       	add	r26, r12
    c394:	bd 1d       	adc	r27, r13
    c396:	8c 91       	ld	r24, X
    c398:	84 83       	std	Z+4, r24	; 0x04
    c39a:	15 82       	std	Z+5, r1	; 0x05
    c39c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			//_f_inttostr(__buff, __value[__num - 0x31]);
			lcd_print(__x, __y, __buff);
    c3a0:	2d b7       	in	r18, 0x3d	; 61
    c3a2:	3e b7       	in	r19, 0x3e	; 62
    c3a4:	2a 5f       	subi	r18, 0xFA	; 250
    c3a6:	3f 4f       	sbci	r19, 0xFF	; 255
    c3a8:	0f b6       	in	r0, 0x3f	; 63
    c3aa:	f8 94       	cli
    c3ac:	3e bf       	out	0x3e, r19	; 62
    c3ae:	0f be       	out	0x3f, r0	; 63
    c3b0:	2d bf       	out	0x3d, r18	; 61
    c3b2:	80 2f       	mov	r24, r16
    c3b4:	61 2f       	mov	r22, r17
    c3b6:	a7 01       	movw	r20, r14
    c3b8:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    c3bc:	7d cf       	rjmp	.-262    	; 0xc2b8 <_menu_host+0x1b0>
		}else
		if (__num=='4'){
    c3be:	94 33       	cpi	r25, 0x34	; 52
    c3c0:	09 f0       	breq	.+2      	; 0xc3c4 <_menu_host+0x2bc>
    c3c2:	7a cf       	rjmp	.-268    	; 0xc2b8 <_menu_host+0x1b0>
		    if (TermID<=99)TermID++;
    c3c4:	33 e6       	ldi	r19, 0x63	; 99
    c3c6:	3b 15       	cp	r19, r11
    c3c8:	18 f4       	brcc	.+6      	; 0xc3d0 <_menu_host+0x2c8>
    c3ca:	bb 24       	eor	r11, r11
    c3cc:	b3 94       	inc	r11
    c3ce:	01 c0       	rjmp	.+2      	; 0xc3d2 <_menu_host+0x2ca>
    c3d0:	b3 94       	inc	r11
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    c3d2:	00 d0       	rcall	.+0      	; 0xc3d4 <_menu_host+0x2cc>
    c3d4:	00 d0       	rcall	.+0      	; 0xc3d6 <_menu_host+0x2ce>
    c3d6:	00 d0       	rcall	.+0      	; 0xc3d8 <_menu_host+0x2d0>
    c3d8:	ed b7       	in	r30, 0x3d	; 61
    c3da:	fe b7       	in	r31, 0x3e	; 62
    c3dc:	31 96       	adiw	r30, 0x01	; 1
    c3de:	ad b7       	in	r26, 0x3d	; 61
    c3e0:	be b7       	in	r27, 0x3e	; 62
    c3e2:	12 96       	adiw	r26, 0x02	; 2
    c3e4:	9c 92       	st	X, r9
    c3e6:	8e 92       	st	-X, r8
    c3e8:	11 97       	sbiw	r26, 0x01	; 1
    c3ea:	53 82       	std	Z+3, r5	; 0x03
    c3ec:	42 82       	std	Z+2, r4	; 0x02
    c3ee:	b4 82       	std	Z+4, r11	; 0x04
    c3f0:	15 82       	std	Z+5, r1	; 0x05
    c3f2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    c3f6:	ed b7       	in	r30, 0x3d	; 61
    c3f8:	fe b7       	in	r31, 0x3e	; 62
    c3fa:	36 96       	adiw	r30, 0x06	; 6
    c3fc:	0f b6       	in	r0, 0x3f	; 63
    c3fe:	f8 94       	cli
    c400:	fe bf       	out	0x3e, r31	; 62
    c402:	0f be       	out	0x3f, r0	; 63
    c404:	ed bf       	out	0x3d, r30	; 61
    c406:	84 e0       	ldi	r24, 0x04	; 4
    c408:	61 e0       	ldi	r22, 0x01	; 1
    c40a:	a4 01       	movw	r20, r8
    c40c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    c410:	84 e0       	ldi	r24, 0x04	; 4
    c412:	6f e0       	ldi	r22, 0x0F	; 15
    c414:	45 ed       	ldi	r20, 0xD5	; 213
    c416:	5b e0       	ldi	r21, 0x0B	; 11
    c418:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    c41c:	4d cf       	rjmp	.-358    	; 0xc2b8 <_menu_host+0x1b0>
		 
		}

	}
}
    c41e:	6d 96       	adiw	r28, 0x1d	; 29
    c420:	0f b6       	in	r0, 0x3f	; 63
    c422:	f8 94       	cli
    c424:	de bf       	out	0x3e, r29	; 62
    c426:	0f be       	out	0x3f, r0	; 63
    c428:	cd bf       	out	0x3d, r28	; 61
    c42a:	cf 91       	pop	r28
    c42c:	df 91       	pop	r29
    c42e:	1f 91       	pop	r17
    c430:	0f 91       	pop	r16
    c432:	ff 90       	pop	r15
    c434:	ef 90       	pop	r14
    c436:	df 90       	pop	r13
    c438:	cf 90       	pop	r12
    c43a:	bf 90       	pop	r11
    c43c:	9f 90       	pop	r9
    c43e:	8f 90       	pop	r8
    c440:	7f 90       	pop	r7
    c442:	6f 90       	pop	r6
    c444:	5f 90       	pop	r5
    c446:	4f 90       	pop	r4
    c448:	3f 90       	pop	r3
    c44a:	2f 90       	pop	r2
    c44c:	08 95       	ret

0000c44e <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    c44e:	0e 94 84 60 	call	0xc108	; 0xc108 <_menu_host>
	 return MENU_DONE;
}
    c452:	81 e0       	ldi	r24, 0x01	; 1
    c454:	08 95       	ret

0000c456 <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    c456:	2f 92       	push	r2
    c458:	3f 92       	push	r3
    c45a:	4f 92       	push	r4
    c45c:	5f 92       	push	r5
    c45e:	6f 92       	push	r6
    c460:	7f 92       	push	r7
    c462:	8f 92       	push	r8
    c464:	9f 92       	push	r9
    c466:	af 92       	push	r10
    c468:	bf 92       	push	r11
    c46a:	cf 92       	push	r12
    c46c:	df 92       	push	r13
    c46e:	ef 92       	push	r14
    c470:	ff 92       	push	r15
    c472:	0f 93       	push	r16
    c474:	1f 93       	push	r17
    c476:	df 93       	push	r29
    c478:	cf 93       	push	r28
    c47a:	cd b7       	in	r28, 0x3d	; 61
    c47c:	de b7       	in	r29, 0x3e	; 62
    c47e:	2c 97       	sbiw	r28, 0x0c	; 12
    c480:	0f b6       	in	r0, 0x3f	; 63
    c482:	f8 94       	cli
    c484:	de bf       	out	0x3e, r29	; 62
    c486:	0f be       	out	0x3f, r0	; 63
    c488:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c48a:	e1 99       	sbic	0x1c, 1	; 28
    c48c:	fe cf       	rjmp	.-4      	; 0xc48a <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c48e:	20 e3       	ldi	r18, 0x30	; 48
    c490:	30 e0       	ldi	r19, 0x00	; 0
    c492:	3f bb       	out	0x1f, r19	; 31
    c494:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c496:	e0 9a       	sbi	0x1c, 0	; 28
    c498:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c49a:	e1 99       	sbic	0x1c, 1	; 28
    c49c:	fe cf       	rjmp	.-4      	; 0xc49a <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c49e:	65 e3       	ldi	r22, 0x35	; 53
    c4a0:	70 e0       	ldi	r23, 0x00	; 0
    c4a2:	7f bb       	out	0x1f, r23	; 31
    c4a4:	6e bb       	out	0x1e, r22	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c4a6:	e0 9a       	sbi	0x1c, 0	; 28
    c4a8:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c4aa:	e1 99       	sbic	0x1c, 1	; 28
    c4ac:	fe cf       	rjmp	.-4      	; 0xc4aa <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4ae:	84 e3       	ldi	r24, 0x34	; 52
    c4b0:	90 e0       	ldi	r25, 0x00	; 0
    c4b2:	9f bb       	out	0x1f, r25	; 31
    c4b4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c4b6:	e0 9a       	sbi	0x1c, 0	; 28
    c4b8:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c4ba:	e1 99       	sbic	0x1c, 1	; 28
    c4bc:	fe cf       	rjmp	.-4      	; 0xc4ba <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4be:	a3 e3       	ldi	r26, 0x33	; 51
    c4c0:	b0 e0       	ldi	r27, 0x00	; 0
    c4c2:	bf bb       	out	0x1f, r27	; 31
    c4c4:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c4c6:	e0 9a       	sbi	0x1c, 0	; 28
    c4c8:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c4ca:	e1 99       	sbic	0x1c, 1	; 28
    c4cc:	fe cf       	rjmp	.-4      	; 0xc4ca <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4ce:	e1 e3       	ldi	r30, 0x31	; 49
    c4d0:	f0 e0       	ldi	r31, 0x00	; 0
    c4d2:	ff bb       	out	0x1f, r31	; 31
    c4d4:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c4d6:	e0 9a       	sbi	0x1c, 0	; 28
    c4d8:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c4da:	e1 99       	sbic	0x1c, 1	; 28
    c4dc:	fe cf       	rjmp	.-4      	; 0xc4da <_menu_printer+0x84>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4de:	62 e3       	ldi	r22, 0x32	; 50
    c4e0:	70 e0       	ldi	r23, 0x00	; 0
    c4e2:	7f bb       	out	0x1f, r23	; 31
    c4e4:	6e bb       	out	0x1e, r22	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c4e6:	e0 9a       	sbi	0x1c, 0	; 28
    c4e8:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    c4ea:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&DefPrintSize);
    c4ec:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&DefPrintLogo);
    c4ee:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&DefPrintAutoCut);
    c4f0:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    c4f2:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    c4f4:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    c4f6:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    c4fa:	81 e0       	ldi	r24, 0x01	; 1
    c4fc:	61 e0       	ldi	r22, 0x01	; 1
    c4fe:	4f e6       	ldi	r20, 0x6F	; 111
    c500:	5c e0       	ldi	r21, 0x0C	; 12
    c502:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    c506:	82 e0       	ldi	r24, 0x02	; 2
    c508:	61 e0       	ldi	r22, 0x01	; 1
    c50a:	4c e5       	ldi	r20, 0x5C	; 92
    c50c:	5c e0       	ldi	r21, 0x0C	; 12
    c50e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    c512:	83 e0       	ldi	r24, 0x03	; 3
    c514:	61 e0       	ldi	r22, 0x01	; 1
    c516:	4c e4       	ldi	r20, 0x4C	; 76
    c518:	5c e0       	ldi	r21, 0x0C	; 12
    c51a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    c51e:	84 e0       	ldi	r24, 0x04	; 4
    c520:	61 e0       	ldi	r22, 0x01	; 1
    c522:	4c e3       	ldi	r20, 0x3C	; 60
    c524:	5c e0       	ldi	r21, 0x0C	; 12
    c526:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    c52a:	0a ea       	ldi	r16, 0xAA	; 170
    c52c:	12 e0       	ldi	r17, 0x02	; 2
    c52e:	4e 01       	movw	r8, r28
    c530:	08 94       	sec
    c532:	81 1c       	adc	r8, r1
    c534:	91 1c       	adc	r9, r1
    c536:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
        sprintf_P(__buff,PSTR("%d"),__value[__i]);
    c538:	97 e0       	ldi	r25, 0x07	; 7
    c53a:	c9 2e       	mov	r12, r25
    c53c:	d1 2c       	mov	r13, r1
    c53e:	cc 0e       	add	r12, r28
    c540:	dd 1e       	adc	r13, r29
    c542:	89 e3       	ldi	r24, 0x39	; 57
    c544:	28 2e       	mov	r2, r24
    c546:	8c e0       	ldi	r24, 0x0C	; 12
    c548:	38 2e       	mov	r3, r24
		//_f_inttostr(__buff, __value[__i]);
		if(__i == 4) sprintf_P(__buff,PSTR("%.2d"),__value[__i]);
    c54a:	b4 e3       	ldi	r27, 0x34	; 52
    c54c:	4b 2e       	mov	r4, r27
    c54e:	bc e0       	ldi	r27, 0x0C	; 12
    c550:	5b 2e       	mov	r5, r27
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    c552:	f8 01       	movw	r30, r16
    c554:	74 90       	lpm	r7, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    c556:	0f 5f       	subi	r16, 0xFF	; 255
    c558:	1f 4f       	sbci	r17, 0xFF	; 255
    c55a:	f8 01       	movw	r30, r16
    c55c:	a4 90       	lpm	r10, Z+
    c55e:	01 50       	subi	r16, 0x01	; 1
    c560:	10 40       	sbci	r17, 0x00	; 0
        sprintf_P(__buff,PSTR("%d"),__value[__i]);
    c562:	d7 01       	movw	r26, r14
    c564:	bc 90       	ld	r11, X
    c566:	00 d0       	rcall	.+0      	; 0xc568 <_menu_printer+0x112>
    c568:	00 d0       	rcall	.+0      	; 0xc56a <_menu_printer+0x114>
    c56a:	00 d0       	rcall	.+0      	; 0xc56c <_menu_printer+0x116>
    c56c:	ed b7       	in	r30, 0x3d	; 61
    c56e:	fe b7       	in	r31, 0x3e	; 62
    c570:	31 96       	adiw	r30, 0x01	; 1
    c572:	ad b7       	in	r26, 0x3d	; 61
    c574:	be b7       	in	r27, 0x3e	; 62
    c576:	12 96       	adiw	r26, 0x02	; 2
    c578:	dc 92       	st	X, r13
    c57a:	ce 92       	st	-X, r12
    c57c:	11 97       	sbiw	r26, 0x01	; 1
    c57e:	33 82       	std	Z+3, r3	; 0x03
    c580:	22 82       	std	Z+2, r2	; 0x02
    c582:	b4 82       	std	Z+4, r11	; 0x04
    c584:	15 82       	std	Z+5, r1	; 0x05
    c586:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		//_f_inttostr(__buff, __value[__i]);
		if(__i == 4) sprintf_P(__buff,PSTR("%.2d"),__value[__i]);
    c58a:	8e 2d       	mov	r24, r14
    c58c:	88 19       	sub	r24, r8
    c58e:	ed b7       	in	r30, 0x3d	; 61
    c590:	fe b7       	in	r31, 0x3e	; 62
    c592:	36 96       	adiw	r30, 0x06	; 6
    c594:	0f b6       	in	r0, 0x3f	; 63
    c596:	f8 94       	cli
    c598:	fe bf       	out	0x3e, r31	; 62
    c59a:	0f be       	out	0x3f, r0	; 63
    c59c:	ed bf       	out	0x3d, r30	; 61
    c59e:	84 30       	cpi	r24, 0x04	; 4
    c5a0:	d1 f4       	brne	.+52     	; 0xc5d6 <_menu_printer+0x180>
    c5a2:	00 d0       	rcall	.+0      	; 0xc5a4 <_menu_printer+0x14e>
    c5a4:	00 d0       	rcall	.+0      	; 0xc5a6 <_menu_printer+0x150>
    c5a6:	00 d0       	rcall	.+0      	; 0xc5a8 <_menu_printer+0x152>
    c5a8:	ed b7       	in	r30, 0x3d	; 61
    c5aa:	fe b7       	in	r31, 0x3e	; 62
    c5ac:	31 96       	adiw	r30, 0x01	; 1
    c5ae:	ad b7       	in	r26, 0x3d	; 61
    c5b0:	be b7       	in	r27, 0x3e	; 62
    c5b2:	12 96       	adiw	r26, 0x02	; 2
    c5b4:	dc 92       	st	X, r13
    c5b6:	ce 92       	st	-X, r12
    c5b8:	11 97       	sbiw	r26, 0x01	; 1
    c5ba:	53 82       	std	Z+3, r5	; 0x03
    c5bc:	42 82       	std	Z+2, r4	; 0x02
    c5be:	b4 82       	std	Z+4, r11	; 0x04
    c5c0:	15 82       	std	Z+5, r1	; 0x05
    c5c2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    c5c6:	ed b7       	in	r30, 0x3d	; 61
    c5c8:	fe b7       	in	r31, 0x3e	; 62
    c5ca:	36 96       	adiw	r30, 0x06	; 6
    c5cc:	0f b6       	in	r0, 0x3f	; 63
    c5ce:	f8 94       	cli
    c5d0:	fe bf       	out	0x3e, r31	; 62
    c5d2:	0f be       	out	0x3f, r0	; 63
    c5d4:	ed bf       	out	0x3d, r30	; 61
		//_f_punctuation(__buff, 0, 2, 0);
		lcd_print(__x, __y, __buff);
    c5d6:	87 2d       	mov	r24, r7
    c5d8:	6a 2d       	mov	r22, r10
    c5da:	a6 01       	movw	r20, r12
    c5dc:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    c5e0:	0e 5f       	subi	r16, 0xFE	; 254
    c5e2:	1f 4f       	sbci	r17, 0xFF	; 255
    c5e4:	08 94       	sec
    c5e6:	e1 1c       	adc	r14, r1
    c5e8:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    c5ea:	f2 e0       	ldi	r31, 0x02	; 2
    c5ec:	06 3b       	cpi	r16, 0xB6	; 182
    c5ee:	1f 07       	cpc	r17, r31
    c5f0:	09 f0       	breq	.+2      	; 0xc5f4 <_menu_printer+0x19e>
    c5f2:	af cf       	rjmp	.-162    	; 0xc552 <_menu_printer+0xfc>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    c5f4:	2e 01       	movw	r4, r28
    c5f6:	08 94       	sec
    c5f8:	41 1c       	adc	r4, r1
    c5fa:	51 1c       	adc	r5, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    c5fc:	a7 e0       	ldi	r26, 0x07	; 7
    c5fe:	ea 2e       	mov	r14, r26
    c600:	f1 2c       	mov	r15, r1
    c602:	ec 0e       	add	r14, r28
    c604:	fd 1e       	adc	r15, r29
    c606:	f1 e3       	ldi	r31, 0x31	; 49
    c608:	6f 2e       	mov	r6, r31
    c60a:	fc e0       	ldi	r31, 0x0C	; 12
    c60c:	7f 2e       	mov	r7, r31
			//_f_inttostr(__buff, __value[__num - 0x31]);
			if((__num == 0x35)||(__num == 0x36))
			   sprintf_P(__buff,PSTR("%.2d"),__value[__num - 0x31]);
    c60e:	ec e2       	ldi	r30, 0x2C	; 44
    c610:	2e 2e       	mov	r2, r30
    c612:	ec e0       	ldi	r30, 0x0C	; 12
    c614:	3e 2e       	mov	r3, r30
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    c616:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&DefPrintSize, __value[1]);
    c618:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&DefPrintLogo, __value[2]);
    c61a:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
    c61c:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    c61e:	cd 80       	ldd	r12, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    c620:	de 80       	ldd	r13, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    c622:	81 e0       	ldi	r24, 0x01	; 1
    c624:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    c628:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    c62a:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    c62e:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    c630:	17 3e       	cpi	r17, 0xE7	; 231
    c632:	09 f4       	brne	.+2      	; 0xc636 <_menu_printer+0x1e0>
    c634:	b1 c0       	rjmp	.+354    	; 0xc798 <_menu_printer+0x342>
			return;
		if(__key==_KEY_ENTER){
    c636:	17 3b       	cpi	r17, 0xB7	; 183
    c638:	09 f0       	breq	.+2      	; 0xc63c <_menu_printer+0x1e6>
    c63a:	48 c0       	rjmp	.+144    	; 0xc6cc <_menu_printer+0x276>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c63c:	e1 99       	sbic	0x1c, 1	; 28
    c63e:	fe cf       	rjmp	.-4      	; 0xc63c <_menu_printer+0x1e6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c640:	20 e3       	ldi	r18, 0x30	; 48
    c642:	30 e0       	ldi	r19, 0x00	; 0
    c644:	3f bb       	out	0x1f, r19	; 31
    c646:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    c648:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    c64a:	0f b6       	in	r0, 0x3f	; 63
    c64c:	f8 94       	cli
    c64e:	e2 9a       	sbi	0x1c, 2	; 28
    c650:	e1 9a       	sbi	0x1c, 1	; 28
    c652:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c654:	e1 99       	sbic	0x1c, 1	; 28
    c656:	fe cf       	rjmp	.-4      	; 0xc654 <_menu_printer+0x1fe>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c658:	65 e3       	ldi	r22, 0x35	; 53
    c65a:	70 e0       	ldi	r23, 0x00	; 0
    c65c:	7f bb       	out	0x1f, r23	; 31
    c65e:	6e bb       	out	0x1e, r22	; 30
#endif
    EEDR = __value;
    c660:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    c662:	0f b6       	in	r0, 0x3f	; 63
    c664:	f8 94       	cli
    c666:	e2 9a       	sbi	0x1c, 2	; 28
    c668:	e1 9a       	sbi	0x1c, 1	; 28
    c66a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c66c:	e1 99       	sbic	0x1c, 1	; 28
    c66e:	fe cf       	rjmp	.-4      	; 0xc66c <_menu_printer+0x216>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c670:	84 e3       	ldi	r24, 0x34	; 52
    c672:	90 e0       	ldi	r25, 0x00	; 0
    c674:	9f bb       	out	0x1f, r25	; 31
    c676:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c678:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    c67a:	0f b6       	in	r0, 0x3f	; 63
    c67c:	f8 94       	cli
    c67e:	e2 9a       	sbi	0x1c, 2	; 28
    c680:	e1 9a       	sbi	0x1c, 1	; 28
    c682:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c684:	e1 99       	sbic	0x1c, 1	; 28
    c686:	fe cf       	rjmp	.-4      	; 0xc684 <_menu_printer+0x22e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c688:	a3 e3       	ldi	r26, 0x33	; 51
    c68a:	b0 e0       	ldi	r27, 0x00	; 0
    c68c:	bf bb       	out	0x1f, r27	; 31
    c68e:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    c690:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    c692:	0f b6       	in	r0, 0x3f	; 63
    c694:	f8 94       	cli
    c696:	e2 9a       	sbi	0x1c, 2	; 28
    c698:	e1 9a       	sbi	0x1c, 1	; 28
    c69a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c69c:	e1 99       	sbic	0x1c, 1	; 28
    c69e:	fe cf       	rjmp	.-4      	; 0xc69c <_menu_printer+0x246>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c6a0:	e1 e3       	ldi	r30, 0x31	; 49
    c6a2:	f0 e0       	ldi	r31, 0x00	; 0
    c6a4:	ff bb       	out	0x1f, r31	; 31
    c6a6:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    c6a8:	cd ba       	out	0x1d, r12	; 29

    __asm__ __volatile__ (
    c6aa:	0f b6       	in	r0, 0x3f	; 63
    c6ac:	f8 94       	cli
    c6ae:	e2 9a       	sbi	0x1c, 2	; 28
    c6b0:	e1 9a       	sbi	0x1c, 1	; 28
    c6b2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c6b4:	e1 99       	sbic	0x1c, 1	; 28
    c6b6:	fe cf       	rjmp	.-4      	; 0xc6b4 <_menu_printer+0x25e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c6b8:	22 e3       	ldi	r18, 0x32	; 50
    c6ba:	30 e0       	ldi	r19, 0x00	; 0
    c6bc:	3f bb       	out	0x1f, r19	; 31
    c6be:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    c6c0:	dd ba       	out	0x1d, r13	; 29

    __asm__ __volatile__ (
    c6c2:	0f b6       	in	r0, 0x3f	; 63
    c6c4:	f8 94       	cli
    c6c6:	e2 9a       	sbi	0x1c, 2	; 28
    c6c8:	e1 9a       	sbi	0x1c, 1	; 28
    c6ca:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    c6cc:	80 2f       	mov	r24, r16
    c6ce:	81 53       	subi	r24, 0x31	; 49
    c6d0:	86 30       	cpi	r24, 0x06	; 6
    c6d2:	08 f0       	brcs	.+2      	; 0xc6d6 <_menu_printer+0x280>
    c6d4:	a6 cf       	rjmp	.-180    	; 0xc622 <_menu_printer+0x1cc>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    c6d6:	a0 2f       	mov	r26, r16
    c6d8:	b0 e0       	ldi	r27, 0x00	; 0
    c6da:	d1 97       	sbiw	r26, 0x31	; 49
    c6dc:	fd 01       	movw	r30, r26
    c6de:	ea 54       	subi	r30, 0x4A	; 74
    c6e0:	fd 4f       	sbci	r31, 0xFD	; 253
    c6e2:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    c6e4:	fd 01       	movw	r30, r26
    c6e6:	e4 54       	subi	r30, 0x44	; 68
    c6e8:	fd 4f       	sbci	r31, 0xFD	; 253
    c6ea:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    c6ec:	f2 01       	movw	r30, r4
    c6ee:	ea 0f       	add	r30, r26
    c6f0:	fb 1f       	adc	r31, r27
    c6f2:	80 81       	ld	r24, Z
    c6f4:	82 17       	cp	r24, r18
    c6f6:	11 f4       	brne	.+4      	; 0xc6fc <_menu_printer+0x2a6>
				__value[__num - 0x31] = __start;
    c6f8:	90 83       	st	Z, r25
    c6fa:	02 c0       	rjmp	.+4      	; 0xc700 <_menu_printer+0x2aa>
			else
				__value[__num - 0x31]++;
    c6fc:	8f 5f       	subi	r24, 0xFF	; 255
    c6fe:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    c700:	9d 01       	movw	r18, r26
    c702:	22 0f       	add	r18, r18
    c704:	33 1f       	adc	r19, r19
    c706:	c9 01       	movw	r24, r18
    c708:	86 55       	subi	r24, 0x56	; 86
    c70a:	9d 4f       	sbci	r25, 0xFD	; 253
    c70c:	fc 01       	movw	r30, r24
    c70e:	c4 90       	lpm	r12, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    c710:	25 55       	subi	r18, 0x55	; 85
    c712:	3d 4f       	sbci	r19, 0xFD	; 253
    c714:	f9 01       	movw	r30, r18
    c716:	d4 90       	lpm	r13, Z+
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    c718:	a4 0d       	add	r26, r4
    c71a:	b5 1d       	adc	r27, r5
    c71c:	1c 91       	ld	r17, X
    c71e:	00 d0       	rcall	.+0      	; 0xc720 <_menu_printer+0x2ca>
    c720:	00 d0       	rcall	.+0      	; 0xc722 <_menu_printer+0x2cc>
    c722:	00 d0       	rcall	.+0      	; 0xc724 <_menu_printer+0x2ce>
    c724:	ed b7       	in	r30, 0x3d	; 61
    c726:	fe b7       	in	r31, 0x3e	; 62
    c728:	31 96       	adiw	r30, 0x01	; 1
    c72a:	ad b7       	in	r26, 0x3d	; 61
    c72c:	be b7       	in	r27, 0x3e	; 62
    c72e:	12 96       	adiw	r26, 0x02	; 2
    c730:	fc 92       	st	X, r15
    c732:	ee 92       	st	-X, r14
    c734:	11 97       	sbiw	r26, 0x01	; 1
    c736:	73 82       	std	Z+3, r7	; 0x03
    c738:	62 82       	std	Z+2, r6	; 0x02
    c73a:	14 83       	std	Z+4, r17	; 0x04
    c73c:	15 82       	std	Z+5, r1	; 0x05
    c73e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			//_f_inttostr(__buff, __value[__num - 0x31]);
			if((__num == 0x35)||(__num == 0x36))
    c742:	05 53       	subi	r16, 0x35	; 53
    c744:	ed b7       	in	r30, 0x3d	; 61
    c746:	fe b7       	in	r31, 0x3e	; 62
    c748:	36 96       	adiw	r30, 0x06	; 6
    c74a:	0f b6       	in	r0, 0x3f	; 63
    c74c:	f8 94       	cli
    c74e:	fe bf       	out	0x3e, r31	; 62
    c750:	0f be       	out	0x3f, r0	; 63
    c752:	ed bf       	out	0x3d, r30	; 61
    c754:	02 30       	cpi	r16, 0x02	; 2
    c756:	d0 f4       	brcc	.+52     	; 0xc78c <_menu_printer+0x336>
			   sprintf_P(__buff,PSTR("%.2d"),__value[__num - 0x31]);
    c758:	00 d0       	rcall	.+0      	; 0xc75a <_menu_printer+0x304>
    c75a:	00 d0       	rcall	.+0      	; 0xc75c <_menu_printer+0x306>
    c75c:	00 d0       	rcall	.+0      	; 0xc75e <_menu_printer+0x308>
    c75e:	ed b7       	in	r30, 0x3d	; 61
    c760:	fe b7       	in	r31, 0x3e	; 62
    c762:	31 96       	adiw	r30, 0x01	; 1
    c764:	ad b7       	in	r26, 0x3d	; 61
    c766:	be b7       	in	r27, 0x3e	; 62
    c768:	12 96       	adiw	r26, 0x02	; 2
    c76a:	fc 92       	st	X, r15
    c76c:	ee 92       	st	-X, r14
    c76e:	11 97       	sbiw	r26, 0x01	; 1
    c770:	33 82       	std	Z+3, r3	; 0x03
    c772:	22 82       	std	Z+2, r2	; 0x02
    c774:	14 83       	std	Z+4, r17	; 0x04
    c776:	15 82       	std	Z+5, r1	; 0x05
    c778:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    c77c:	ed b7       	in	r30, 0x3d	; 61
    c77e:	fe b7       	in	r31, 0x3e	; 62
    c780:	36 96       	adiw	r30, 0x06	; 6
    c782:	0f b6       	in	r0, 0x3f	; 63
    c784:	f8 94       	cli
    c786:	fe bf       	out	0x3e, r31	; 62
    c788:	0f be       	out	0x3f, r0	; 63
    c78a:	ed bf       	out	0x3d, r30	; 61
				//_f_punctuation(__buff, 0, 2, 0);

			lcd_print(__x, __y, __buff);
    c78c:	8c 2d       	mov	r24, r12
    c78e:	6d 2d       	mov	r22, r13
    c790:	a7 01       	movw	r20, r14
    c792:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    c796:	3f cf       	rjmp	.-386    	; 0xc616 <_menu_printer+0x1c0>
		}
	}
}
    c798:	2c 96       	adiw	r28, 0x0c	; 12
    c79a:	0f b6       	in	r0, 0x3f	; 63
    c79c:	f8 94       	cli
    c79e:	de bf       	out	0x3e, r29	; 62
    c7a0:	0f be       	out	0x3f, r0	; 63
    c7a2:	cd bf       	out	0x3d, r28	; 61
    c7a4:	cf 91       	pop	r28
    c7a6:	df 91       	pop	r29
    c7a8:	1f 91       	pop	r17
    c7aa:	0f 91       	pop	r16
    c7ac:	ff 90       	pop	r15
    c7ae:	ef 90       	pop	r14
    c7b0:	df 90       	pop	r13
    c7b2:	cf 90       	pop	r12
    c7b4:	bf 90       	pop	r11
    c7b6:	af 90       	pop	r10
    c7b8:	9f 90       	pop	r9
    c7ba:	8f 90       	pop	r8
    c7bc:	7f 90       	pop	r7
    c7be:	6f 90       	pop	r6
    c7c0:	5f 90       	pop	r5
    c7c2:	4f 90       	pop	r4
    c7c4:	3f 90       	pop	r3
    c7c6:	2f 90       	pop	r2
    c7c8:	08 95       	ret

0000c7ca <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    c7ca:	0e 94 2b 62 	call	0xc456	; 0xc456 <_menu_printer>
	 return MENU_DONE;
}
    c7ce:	81 e0       	ldi	r24, 0x01	; 1
    c7d0:	08 95       	ret

0000c7d2 <_menu_pumpprodinput>:
				*/
		}
	}
}

void _menu_pumpprodinput(unsigned char __select){
    c7d2:	6f 92       	push	r6
    c7d4:	7f 92       	push	r7
    c7d6:	8f 92       	push	r8
    c7d8:	9f 92       	push	r9
    c7da:	af 92       	push	r10
    c7dc:	bf 92       	push	r11
    c7de:	cf 92       	push	r12
    c7e0:	df 92       	push	r13
    c7e2:	ef 92       	push	r14
    c7e4:	ff 92       	push	r15
    c7e6:	0f 93       	push	r16
    c7e8:	1f 93       	push	r17
    c7ea:	df 93       	push	r29
    c7ec:	cf 93       	push	r28
    c7ee:	cd b7       	in	r28, 0x3d	; 61
    c7f0:	de b7       	in	r29, 0x3e	; 62
    c7f2:	a7 97       	sbiw	r28, 0x27	; 39
    c7f4:	0f b6       	in	r0, 0x3f	; 63
    c7f6:	f8 94       	cli
    c7f8:	de bf       	out	0x3e, r29	; 62
    c7fa:	0f be       	out	0x3f, r0	; 63
    c7fc:	cd bf       	out	0x3d, r28	; 61
    c7fe:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    c800:	8e 01       	movw	r16, r28
    c802:	04 5f       	subi	r16, 0xF4	; 244
    c804:	1f 4f       	sbci	r17, 0xFF	; 255
    c806:	c8 01       	movw	r24, r16
    c808:	65 e4       	ldi	r22, 0x45	; 69
    c80a:	70 e0       	ldi	r23, 0x00	; 0
    c80c:	48 e0       	ldi	r20, 0x08	; 8
    c80e:	50 e0       	ldi	r21, 0x00	; 0
    c810:	22 e4       	ldi	r18, 0x42	; 66
    c812:	33 e1       	ldi	r19, 0x13	; 19
    c814:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    c818:	86 e0       	ldi	r24, 0x06	; 6
    c81a:	b8 9e       	mul	r11, r24
    c81c:	40 01       	movw	r8, r0
    c81e:	11 24       	eor	r1, r1
    c820:	85 e5       	ldi	r24, 0x55	; 85
    c822:	90 e0       	ldi	r25, 0x00	; 0
    c824:	88 0e       	add	r8, r24
    c826:	99 1e       	adc	r9, r25
    c828:	b6 e0       	ldi	r27, 0x06	; 6
    c82a:	cb 2e       	mov	r12, r27
    c82c:	d1 2c       	mov	r13, r1
    c82e:	cc 0e       	add	r12, r28
    c830:	dd 1e       	adc	r13, r29
    c832:	c6 01       	movw	r24, r12
    c834:	b4 01       	movw	r22, r8
    c836:	46 e0       	ldi	r20, 0x06	; 6
    c838:	50 e0       	ldi	r21, 0x00	; 0
    c83a:	22 e4       	ldi	r18, 0x42	; 66
    c83c:	33 e1       	ldi	r19, 0x13	; 19
    c83e:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>

	lcd_clear();_delay_ms(10);
    c842:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    c846:	84 ec       	ldi	r24, 0xC4	; 196
    c848:	99 e0       	ldi	r25, 0x09	; 9
    c84a:	01 97       	sbiw	r24, 0x01	; 1
    c84c:	f1 f7       	brne	.-4      	; 0xc84a <_menu_pumpprodinput+0x78>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    c84e:	00 d0       	rcall	.+0      	; 0xc850 <_menu_pumpprodinput+0x7e>
    c850:	00 d0       	rcall	.+0      	; 0xc852 <_menu_pumpprodinput+0x80>
    c852:	00 d0       	rcall	.+0      	; 0xc854 <_menu_pumpprodinput+0x82>
    c854:	ed b7       	in	r30, 0x3d	; 61
    c856:	fe b7       	in	r31, 0x3e	; 62
    c858:	31 96       	adiw	r30, 0x01	; 1
    c85a:	a4 e1       	ldi	r26, 0x14	; 20
    c85c:	ea 2e       	mov	r14, r26
    c85e:	f1 2c       	mov	r15, r1
    c860:	ec 0e       	add	r14, r28
    c862:	fd 1e       	adc	r15, r29
    c864:	ad b7       	in	r26, 0x3d	; 61
    c866:	be b7       	in	r27, 0x3e	; 62
    c868:	12 96       	adiw	r26, 0x02	; 2
    c86a:	fc 92       	st	X, r15
    c86c:	ee 92       	st	-X, r14
    c86e:	11 97       	sbiw	r26, 0x01	; 1
    c870:	8a ee       	ldi	r24, 0xEA	; 234
    c872:	9c e0       	ldi	r25, 0x0C	; 12
    c874:	93 83       	std	Z+3, r25	; 0x03
    c876:	82 83       	std	Z+2, r24	; 0x02
    c878:	0b 0d       	add	r16, r11
    c87a:	11 1d       	adc	r17, r1
    c87c:	d8 01       	movw	r26, r16
    c87e:	8c 91       	ld	r24, X
    c880:	84 83       	std	Z+4, r24	; 0x04
    c882:	15 82       	std	Z+5, r1	; 0x05
    c884:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    lcd_print(1, 1,lcdteks);
    c888:	ed b7       	in	r30, 0x3d	; 61
    c88a:	fe b7       	in	r31, 0x3e	; 62
    c88c:	36 96       	adiw	r30, 0x06	; 6
    c88e:	0f b6       	in	r0, 0x3f	; 63
    c890:	f8 94       	cli
    c892:	fe bf       	out	0x3e, r31	; 62
    c894:	0f be       	out	0x3f, r0	; 63
    c896:	ed bf       	out	0x3d, r30	; 61
    c898:	81 e0       	ldi	r24, 0x01	; 1
    c89a:	61 e0       	ldi	r22, 0x01	; 1
    c89c:	a7 01       	movw	r20, r14
    c89e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    c8a2:	82 e0       	ldi	r24, 0x02	; 2
    c8a4:	61 e0       	ldi	r22, 0x01	; 1
    c8a6:	46 ed       	ldi	r20, 0xD6	; 214
    c8a8:	5c e0       	ldi	r21, 0x0C	; 12
    c8aa:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    c8ae:	83 e0       	ldi	r24, 0x03	; 3
    c8b0:	61 e0       	ldi	r22, 0x01	; 1
    c8b2:	42 ec       	ldi	r20, 0xC2	; 194
    c8b4:	5c e0       	ldi	r21, 0x0C	; 12
    c8b6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    c8ba:	84 e0       	ldi	r24, 0x04	; 4
    c8bc:	61 e0       	ldi	r22, 0x01	; 1
    c8be:	4d ea       	ldi	r20, 0xAD	; 173
    c8c0:	5c e0       	ldi	r21, 0x0C	; 12
    c8c2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    c8c6:	ee e9       	ldi	r30, 0x9E	; 158
    c8c8:	ee 2e       	mov	r14, r30
    c8ca:	e2 e0       	ldi	r30, 0x02	; 2
    c8cc:	fe 2e       	mov	r15, r30

	for(i=0;i<6;i++){
		__x = pgm_read_byte(&__prodloc[i][0]);
		__y = pgm_read_byte(&__prodloc[i][1]);

        sprintf_P(__buff,PSTR("%d"),__pump_prod[i]);
    c8ce:	5e 01       	movw	r10, r28
    c8d0:	08 94       	sec
    c8d2:	a1 1c       	adc	r10, r1
    c8d4:	b1 1c       	adc	r11, r1
    c8d6:	7a ea       	ldi	r23, 0xAA	; 170
    c8d8:	67 2e       	mov	r6, r23
    c8da:	7c e0       	ldi	r23, 0x0C	; 12
    c8dc:	77 2e       	mov	r7, r23
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(i=0;i<6;i++){
		__x = pgm_read_byte(&__prodloc[i][0]);
    c8de:	f7 01       	movw	r30, r14
    c8e0:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[i][1]);
    c8e2:	08 94       	sec
    c8e4:	e1 1c       	adc	r14, r1
    c8e6:	f1 1c       	adc	r15, r1
    c8e8:	f7 01       	movw	r30, r14
    c8ea:	14 91       	lpm	r17, Z+

        sprintf_P(__buff,PSTR("%d"),__pump_prod[i]);
    c8ec:	00 d0       	rcall	.+0      	; 0xc8ee <_menu_pumpprodinput+0x11c>
    c8ee:	00 d0       	rcall	.+0      	; 0xc8f0 <_menu_pumpprodinput+0x11e>
    c8f0:	00 d0       	rcall	.+0      	; 0xc8f2 <_menu_pumpprodinput+0x120>
    c8f2:	ed b7       	in	r30, 0x3d	; 61
    c8f4:	fe b7       	in	r31, 0x3e	; 62
    c8f6:	31 96       	adiw	r30, 0x01	; 1
    c8f8:	ad b7       	in	r26, 0x3d	; 61
    c8fa:	be b7       	in	r27, 0x3e	; 62
    c8fc:	12 96       	adiw	r26, 0x02	; 2
    c8fe:	bc 92       	st	X, r11
    c900:	ae 92       	st	-X, r10
    c902:	11 97       	sbiw	r26, 0x01	; 1
    c904:	73 82       	std	Z+3, r7	; 0x03
    c906:	62 82       	std	Z+2, r6	; 0x02
    c908:	d6 01       	movw	r26, r12
    c90a:	8d 91       	ld	r24, X+
    c90c:	6d 01       	movw	r12, r26
    c90e:	84 83       	std	Z+4, r24	; 0x04
    c910:	15 82       	std	Z+5, r1	; 0x05
    c912:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		lcd_print(__x+1, __y, __buff);
    c916:	ed b7       	in	r30, 0x3d	; 61
    c918:	fe b7       	in	r31, 0x3e	; 62
    c91a:	36 96       	adiw	r30, 0x06	; 6
    c91c:	0f b6       	in	r0, 0x3f	; 63
    c91e:	f8 94       	cli
    c920:	fe bf       	out	0x3e, r31	; 62
    c922:	0f be       	out	0x3f, r0	; 63
    c924:	ed bf       	out	0x3d, r30	; 61
    c926:	80 2f       	mov	r24, r16
    c928:	8f 5f       	subi	r24, 0xFF	; 255
    c92a:	61 2f       	mov	r22, r17
    c92c:	a5 01       	movw	r20, r10
    c92e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    c932:	08 94       	sec
    c934:	e1 1c       	adc	r14, r1
    c936:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(i=0;i<6;i++){
    c938:	fa ea       	ldi	r31, 0xAA	; 170
    c93a:	ef 16       	cp	r14, r31
    c93c:	f2 e0       	ldi	r31, 0x02	; 2
    c93e:	ff 06       	cpc	r15, r31
    c940:	71 f6       	brne	.-100    	; 0xc8de <_menu_pumpprodinput+0x10c>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    c942:	66 e0       	ldi	r22, 0x06	; 6
    c944:	c6 2e       	mov	r12, r22
    c946:	d1 2c       	mov	r13, r1
    c948:	cc 0e       	add	r12, r28
    c94a:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__pump_prod[__num - 0x31]);
    c94c:	7e 01       	movw	r14, r28
    c94e:	08 94       	sec
    c950:	e1 1c       	adc	r14, r1
    c952:	f1 1c       	adc	r15, r1
    c954:	57 ea       	ldi	r21, 0xA7	; 167
    c956:	a5 2e       	mov	r10, r21
    c958:	5c e0       	ldi	r21, 0x0C	; 12
    c95a:	b5 2e       	mov	r11, r21
		//lcd_print(2+(i%2),(i/2)*6,lcdteks);
	}

	while(1){
		
		__key = _key_scan(1);
    c95c:	81 e0       	ldi	r24, 0x01	; 1
    c95e:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    c962:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    c964:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    c968:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    c96a:	17 3e       	cpi	r17, 0xE7	; 231
    c96c:	09 f4       	brne	.+2      	; 0xc970 <_menu_pumpprodinput+0x19e>
    c96e:	50 c0       	rjmp	.+160    	; 0xca10 <_menu_pumpprodinput+0x23e>
			return;
		if(__key == _KEY_ENTER){
    c970:	17 3b       	cpi	r17, 0xB7	; 183
    c972:	59 f4       	brne	.+22     	; 0xc98a <_menu_pumpprodinput+0x1b8>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c974:	c4 01       	movw	r24, r8
    c976:	be 01       	movw	r22, r28
    c978:	6a 5f       	subi	r22, 0xFA	; 250
    c97a:	7f 4f       	sbci	r23, 0xFF	; 255
    c97c:	46 e0       	ldi	r20, 0x06	; 6
    c97e:	50 e0       	ldi	r21, 0x00	; 0
    c980:	2a e4       	ldi	r18, 0x4A	; 74
    c982:	33 e1       	ldi	r19, 0x13	; 19
    c984:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    c988:	43 c0       	rjmp	.+134    	; 0xca10 <_menu_pumpprodinput+0x23e>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    c98a:	81 53       	subi	r24, 0x31	; 49
    c98c:	86 30       	cpi	r24, 0x06	; 6
    c98e:	30 f7       	brcc	.-52     	; 0xc95c <_menu_pumpprodinput+0x18a>
			if(__pump_prod[__num - '1'] == 6)
    c990:	a9 2f       	mov	r26, r25
    c992:	b0 e0       	ldi	r27, 0x00	; 0
    c994:	d1 97       	sbiw	r26, 0x31	; 49
    c996:	f6 01       	movw	r30, r12
    c998:	ea 0f       	add	r30, r26
    c99a:	fb 1f       	adc	r31, r27
    c99c:	80 81       	ld	r24, Z
    c99e:	86 30       	cpi	r24, 0x06	; 6
    c9a0:	11 f4       	brne	.+4      	; 0xc9a6 <_menu_pumpprodinput+0x1d4>
				__pump_prod[__num - '1'] = 0;
    c9a2:	10 82       	st	Z, r1
    c9a4:	02 c0       	rjmp	.+4      	; 0xc9aa <_menu_pumpprodinput+0x1d8>
			else
				__pump_prod[__num - '1']++;
    c9a6:	8f 5f       	subi	r24, 0xFF	; 255
    c9a8:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    c9aa:	29 2f       	mov	r18, r25
    c9ac:	30 e0       	ldi	r19, 0x00	; 0
    c9ae:	21 53       	subi	r18, 0x31	; 49
    c9b0:	30 40       	sbci	r19, 0x00	; 0
    c9b2:	22 0f       	add	r18, r18
    c9b4:	33 1f       	adc	r19, r19
    c9b6:	c9 01       	movw	r24, r18
    c9b8:	82 56       	subi	r24, 0x62	; 98
    c9ba:	9d 4f       	sbci	r25, 0xFD	; 253
    c9bc:	fc 01       	movw	r30, r24
    c9be:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    c9c0:	21 56       	subi	r18, 0x61	; 97
    c9c2:	3d 4f       	sbci	r19, 0xFD	; 253
    c9c4:	f9 01       	movw	r30, r18
    c9c6:	14 91       	lpm	r17, Z+
			sprintf_P(__buff,PSTR("%d"),__pump_prod[__num - 0x31]);
    c9c8:	00 d0       	rcall	.+0      	; 0xc9ca <_menu_pumpprodinput+0x1f8>
    c9ca:	00 d0       	rcall	.+0      	; 0xc9cc <_menu_pumpprodinput+0x1fa>
    c9cc:	00 d0       	rcall	.+0      	; 0xc9ce <_menu_pumpprodinput+0x1fc>
    c9ce:	2d b7       	in	r18, 0x3d	; 61
    c9d0:	3e b7       	in	r19, 0x3e	; 62
    c9d2:	2f 5f       	subi	r18, 0xFF	; 255
    c9d4:	3f 4f       	sbci	r19, 0xFF	; 255
    c9d6:	ed b7       	in	r30, 0x3d	; 61
    c9d8:	fe b7       	in	r31, 0x3e	; 62
    c9da:	f2 82       	std	Z+2, r15	; 0x02
    c9dc:	e1 82       	std	Z+1, r14	; 0x01
    c9de:	f9 01       	movw	r30, r18
    c9e0:	b3 82       	std	Z+3, r11	; 0x03
    c9e2:	a2 82       	std	Z+2, r10	; 0x02
    c9e4:	ac 0d       	add	r26, r12
    c9e6:	bd 1d       	adc	r27, r13
    c9e8:	8c 91       	ld	r24, X
    c9ea:	84 83       	std	Z+4, r24	; 0x04
    c9ec:	15 82       	std	Z+5, r1	; 0x05
    c9ee:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			//_f_inttostr(__buff, __pump_prod[__num - 0x31]);
			lcd_print(__x+1, __y, __buff);
    c9f2:	8d b7       	in	r24, 0x3d	; 61
    c9f4:	9e b7       	in	r25, 0x3e	; 62
    c9f6:	06 96       	adiw	r24, 0x06	; 6
    c9f8:	0f b6       	in	r0, 0x3f	; 63
    c9fa:	f8 94       	cli
    c9fc:	9e bf       	out	0x3e, r25	; 62
    c9fe:	0f be       	out	0x3f, r0	; 63
    ca00:	8d bf       	out	0x3d, r24	; 61
    ca02:	80 2f       	mov	r24, r16
    ca04:	8f 5f       	subi	r24, 0xFF	; 255
    ca06:	61 2f       	mov	r22, r17
    ca08:	a7 01       	movw	r20, r14
    ca0a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    ca0e:	a6 cf       	rjmp	.-180    	; 0xc95c <_menu_pumpprodinput+0x18a>
		}
	}
}
    ca10:	a7 96       	adiw	r28, 0x27	; 39
    ca12:	0f b6       	in	r0, 0x3f	; 63
    ca14:	f8 94       	cli
    ca16:	de bf       	out	0x3e, r29	; 62
    ca18:	0f be       	out	0x3f, r0	; 63
    ca1a:	cd bf       	out	0x3d, r28	; 61
    ca1c:	cf 91       	pop	r28
    ca1e:	df 91       	pop	r29
    ca20:	1f 91       	pop	r17
    ca22:	0f 91       	pop	r16
    ca24:	ff 90       	pop	r15
    ca26:	ef 90       	pop	r14
    ca28:	df 90       	pop	r13
    ca2a:	cf 90       	pop	r12
    ca2c:	bf 90       	pop	r11
    ca2e:	af 90       	pop	r10
    ca30:	9f 90       	pop	r9
    ca32:	8f 90       	pop	r8
    ca34:	7f 90       	pop	r7
    ca36:	6f 90       	pop	r6
    ca38:	08 95       	ret

0000ca3a <_menu_pumpprod>:
}

void _menu_pumpprod(void){
	char KeyPressed,KeyChar;
	while(1){
		lcd_clear();
    ca3a:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		_scr_pump();
    ca3e:	0e 94 58 22 	call	0x44b0	; 0x44b0 <_scr_pump>
		while(1){
			KeyPressed=_key_scan(1);
    ca42:	81 e0       	ldi	r24, 0x01	; 1
    ca44:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		    KeyChar=_key_btn(KeyPressed);
    ca48:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    ca4c:	98 2f       	mov	r25, r24

			if ((KeyChar>='1')&&(KeyChar<='8')){
    ca4e:	81 53       	subi	r24, 0x31	; 49
    ca50:	88 30       	cpi	r24, 0x08	; 8
    ca52:	18 f4       	brcc	.+6      	; 0xca5a <_menu_pumpprod+0x20>
			     _menu_pumpprodinput(KeyChar-'1');
    ca54:	0e 94 e9 63 	call	0xc7d2	; 0xc7d2 <_menu_pumpprodinput>
    ca58:	f0 cf       	rjmp	.-32     	; 0xca3a <_menu_pumpprod>
				break;
			}else if (KeyChar=='*'){
    ca5a:	9a 32       	cpi	r25, 0x2A	; 42
    ca5c:	91 f7       	brne	.-28     	; 0xca42 <_menu_pumpprod+0x8>
			if(__key == _KEY_CANCEL)
				return;
				*/
		}
	}
}
    ca5e:	08 95       	ret

0000ca60 <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    ca60:	6f 92       	push	r6
    ca62:	7f 92       	push	r7
    ca64:	8f 92       	push	r8
    ca66:	9f 92       	push	r9
    ca68:	af 92       	push	r10
    ca6a:	bf 92       	push	r11
    ca6c:	cf 92       	push	r12
    ca6e:	df 92       	push	r13
    ca70:	ef 92       	push	r14
    ca72:	ff 92       	push	r15
    ca74:	1f 93       	push	r17
    ca76:	df 93       	push	r29
    ca78:	cf 93       	push	r28
    ca7a:	cd b7       	in	r28, 0x3d	; 61
    ca7c:	de b7       	in	r29, 0x3e	; 62
    ca7e:	2d 97       	sbiw	r28, 0x0d	; 13
    ca80:	0f b6       	in	r0, 0x3f	; 63
    ca82:	f8 94       	cli
    ca84:	de bf       	out	0x3e, r29	; 62
    ca86:	0f be       	out	0x3f, r0	; 63
    ca88:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ca8a:	36 e0       	ldi	r19, 0x06	; 6
    ca8c:	c3 2e       	mov	r12, r19
    ca8e:	d1 2c       	mov	r13, r1
    ca90:	cc 0e       	add	r12, r28
    ca92:	dd 1e       	adc	r13, r29
    ca94:	c6 01       	movw	r24, r12
    ca96:	6d e4       	ldi	r22, 0x4D	; 77
    ca98:	70 e0       	ldi	r23, 0x00	; 0
    ca9a:	48 e0       	ldi	r20, 0x08	; 8
    ca9c:	50 e0       	ldi	r21, 0x00	; 0
    ca9e:	22 e4       	ldi	r18, 0x42	; 66
    caa0:	33 e1       	ldi	r19, 0x13	; 19
    caa2:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    caa6:	83 e6       	ldi	r24, 0x63	; 99
    caa8:	80 93 47 01 	sts	0x0147, r24
	lcd_clear();_delay_ms(10);
    caac:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    cab0:	84 ec       	ldi	r24, 0xC4	; 196
    cab2:	99 e0       	ldi	r25, 0x09	; 9
    cab4:	01 97       	sbiw	r24, 0x01	; 1
    cab6:	f1 f7       	brne	.-4      	; 0xcab4 <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    cab8:	81 e0       	ldi	r24, 0x01	; 1
    caba:	61 e0       	ldi	r22, 0x01	; 1
    cabc:	45 ee       	ldi	r20, 0xE5	; 229
    cabe:	5d e0       	ldi	r21, 0x0D	; 13
    cac0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    cac4:	82 e0       	ldi	r24, 0x02	; 2
    cac6:	61 e0       	ldi	r22, 0x01	; 1
    cac8:	49 ed       	ldi	r20, 0xD9	; 217
    caca:	5d e0       	ldi	r21, 0x0D	; 13
    cacc:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    cad0:	83 e0       	ldi	r24, 0x03	; 3
    cad2:	61 e0       	ldi	r22, 0x01	; 1
    cad4:	44 ec       	ldi	r20, 0xC4	; 196
    cad6:	5d e0       	ldi	r21, 0x0D	; 13
    cad8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    cadc:	84 e0       	ldi	r24, 0x04	; 4
    cade:	61 e0       	ldi	r22, 0x01	; 1
    cae0:	4f ea       	ldi	r20, 0xAF	; 175
    cae2:	5d e0       	ldi	r21, 0x0D	; 13
    cae4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    cae8:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    caea:	5e 01       	movw	r10, r28
    caec:	08 94       	sec
    caee:	a1 1c       	adc	r10, r1
    caf0:	b1 1c       	adc	r11, r1
    caf2:	2a ea       	ldi	r18, 0xAA	; 170
    caf4:	62 2e       	mov	r6, r18
    caf6:	2d e0       	ldi	r18, 0x0D	; 13
    caf8:	72 2e       	mov	r7, r18
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    cafa:	9e e0       	ldi	r25, 0x0E	; 14
    cafc:	89 2e       	mov	r8, r25
    cafe:	91 2c       	mov	r9, r1
    cb00:	8c 0e       	add	r8, r28
    cb02:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    cb04:	1e 2d       	mov	r17, r14
    cb06:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    cb08:	00 d0       	rcall	.+0      	; 0xcb0a <FMenuPumpLabel+0xaa>
    cb0a:	00 d0       	rcall	.+0      	; 0xcb0c <FMenuPumpLabel+0xac>
    cb0c:	00 d0       	rcall	.+0      	; 0xcb0e <FMenuPumpLabel+0xae>
    cb0e:	ed b7       	in	r30, 0x3d	; 61
    cb10:	fe b7       	in	r31, 0x3e	; 62
    cb12:	31 96       	adiw	r30, 0x01	; 1
    cb14:	ad b7       	in	r26, 0x3d	; 61
    cb16:	be b7       	in	r27, 0x3e	; 62
    cb18:	12 96       	adiw	r26, 0x02	; 2
    cb1a:	bc 92       	st	X, r11
    cb1c:	ae 92       	st	-X, r10
    cb1e:	11 97       	sbiw	r26, 0x01	; 1
    cb20:	73 82       	std	Z+3, r7	; 0x03
    cb22:	62 82       	std	Z+2, r6	; 0x02
    cb24:	d7 01       	movw	r26, r14
    cb26:	8d 91       	ld	r24, X+
    cb28:	7d 01       	movw	r14, r26
    cb2a:	84 83       	std	Z+4, r24	; 0x04
    cb2c:	15 82       	std	Z+5, r1	; 0x05
    cb2e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    cb32:	ed b7       	in	r30, 0x3d	; 61
    cb34:	fe b7       	in	r31, 0x3e	; 62
    cb36:	36 96       	adiw	r30, 0x06	; 6
    cb38:	0f b6       	in	r0, 0x3f	; 63
    cb3a:	f8 94       	cli
    cb3c:	fe bf       	out	0x3e, r31	; 62
    cb3e:	0f be       	out	0x3f, r0	; 63
    cb40:	ed bf       	out	0x3d, r30	; 61
    cb42:	61 2f       	mov	r22, r17
    cb44:	66 95       	lsr	r22
    cb46:	66 95       	lsr	r22
    cb48:	66 0f       	add	r22, r22
    cb4a:	66 0f       	add	r22, r22
    cb4c:	66 0f       	add	r22, r22
    cb4e:	6b 5f       	subi	r22, 0xFB	; 251
    cb50:	13 70       	andi	r17, 0x03	; 3
    cb52:	81 2f       	mov	r24, r17
    cb54:	8f 5f       	subi	r24, 0xFF	; 255
    cb56:	a5 01       	movw	r20, r10
    cb58:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    cb5c:	e8 14       	cp	r14, r8
    cb5e:	f9 04       	cpc	r15, r9
    cb60:	89 f6       	brne	.-94     	; 0xcb04 <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    cb62:	86 e0       	ldi	r24, 0x06	; 6
    cb64:	c8 2e       	mov	r12, r24
    cb66:	d1 2c       	mov	r13, r1
    cb68:	cc 0e       	add	r12, r28
    cb6a:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    cb6c:	7e 01       	movw	r14, r28
    cb6e:	08 94       	sec
    cb70:	e1 1c       	adc	r14, r1
    cb72:	f1 1c       	adc	r15, r1
    cb74:	15 ea       	ldi	r17, 0xA5	; 165
    cb76:	a1 2e       	mov	r10, r17
    cb78:	1d e0       	ldi	r17, 0x0D	; 13
    cb7a:	b1 2e       	mov	r11, r17
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    cb7c:	81 e0       	ldi	r24, 0x01	; 1
    cb7e:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    cb82:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    cb84:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    cb88:	17 3e       	cpi	r17, 0xE7	; 231
    cb8a:	09 f4       	brne	.+2      	; 0xcb8e <FMenuPumpLabel+0x12e>
    cb8c:	4b c0       	rjmp	.+150    	; 0xcc24 <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    cb8e:	17 3b       	cpi	r17, 0xB7	; 183
    cb90:	61 f4       	brne	.+24     	; 0xcbaa <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    cb92:	8d e4       	ldi	r24, 0x4D	; 77
    cb94:	90 e0       	ldi	r25, 0x00	; 0
    cb96:	be 01       	movw	r22, r28
    cb98:	6a 5f       	subi	r22, 0xFA	; 250
    cb9a:	7f 4f       	sbci	r23, 0xFF	; 255
    cb9c:	48 e0       	ldi	r20, 0x08	; 8
    cb9e:	50 e0       	ldi	r21, 0x00	; 0
    cba0:	2a e4       	ldi	r18, 0x4A	; 74
    cba2:	33 e1       	ldi	r19, 0x13	; 19
    cba4:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
    cba8:	3d c0       	rjmp	.+122    	; 0xcc24 <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    cbaa:	18 2f       	mov	r17, r24
    cbac:	11 53       	subi	r17, 0x31	; 49
    cbae:	18 30       	cpi	r17, 0x08	; 8
    cbb0:	28 f7       	brcc	.-54     	; 0xcb7c <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    cbb2:	a1 2f       	mov	r26, r17
    cbb4:	b0 e0       	ldi	r27, 0x00	; 0
    cbb6:	f6 01       	movw	r30, r12
    cbb8:	ea 0f       	add	r30, r26
    cbba:	fb 1f       	adc	r31, r27
    cbbc:	90 81       	ld	r25, Z
    cbbe:	80 91 47 01 	lds	r24, 0x0147
    cbc2:	98 17       	cp	r25, r24
    cbc4:	11 f4       	brne	.+4      	; 0xcbca <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    cbc6:	10 82       	st	Z, r1
    cbc8:	02 c0       	rjmp	.+4      	; 0xcbce <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    cbca:	9f 5f       	subi	r25, 0xFF	; 255
    cbcc:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    cbce:	00 d0       	rcall	.+0      	; 0xcbd0 <FMenuPumpLabel+0x170>
    cbd0:	00 d0       	rcall	.+0      	; 0xcbd2 <FMenuPumpLabel+0x172>
    cbd2:	00 d0       	rcall	.+0      	; 0xcbd4 <FMenuPumpLabel+0x174>
    cbd4:	2d b7       	in	r18, 0x3d	; 61
    cbd6:	3e b7       	in	r19, 0x3e	; 62
    cbd8:	2f 5f       	subi	r18, 0xFF	; 255
    cbda:	3f 4f       	sbci	r19, 0xFF	; 255
    cbdc:	ed b7       	in	r30, 0x3d	; 61
    cbde:	fe b7       	in	r31, 0x3e	; 62
    cbe0:	f2 82       	std	Z+2, r15	; 0x02
    cbe2:	e1 82       	std	Z+1, r14	; 0x01
    cbe4:	f9 01       	movw	r30, r18
    cbe6:	b3 82       	std	Z+3, r11	; 0x03
    cbe8:	a2 82       	std	Z+2, r10	; 0x02
    cbea:	ac 0d       	add	r26, r12
    cbec:	bd 1d       	adc	r27, r13
    cbee:	8c 91       	ld	r24, X
    cbf0:	84 83       	std	Z+4, r24	; 0x04
    cbf2:	15 82       	std	Z+5, r1	; 0x05
    cbf4:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    cbf8:	8d b7       	in	r24, 0x3d	; 61
    cbfa:	9e b7       	in	r25, 0x3e	; 62
    cbfc:	06 96       	adiw	r24, 0x06	; 6
    cbfe:	0f b6       	in	r0, 0x3f	; 63
    cc00:	f8 94       	cli
    cc02:	9e bf       	out	0x3e, r25	; 62
    cc04:	0f be       	out	0x3f, r0	; 63
    cc06:	8d bf       	out	0x3d, r24	; 61
    cc08:	61 2f       	mov	r22, r17
    cc0a:	66 95       	lsr	r22
    cc0c:	66 95       	lsr	r22
    cc0e:	66 0f       	add	r22, r22
    cc10:	66 0f       	add	r22, r22
    cc12:	66 0f       	add	r22, r22
    cc14:	6b 5f       	subi	r22, 0xFB	; 251
    cc16:	13 70       	andi	r17, 0x03	; 3
    cc18:	81 2f       	mov	r24, r17
    cc1a:	8f 5f       	subi	r24, 0xFF	; 255
    cc1c:	a7 01       	movw	r20, r14
    cc1e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    cc22:	ac cf       	rjmp	.-168    	; 0xcb7c <FMenuPumpLabel+0x11c>
		}
	}
}
    cc24:	2d 96       	adiw	r28, 0x0d	; 13
    cc26:	0f b6       	in	r0, 0x3f	; 63
    cc28:	f8 94       	cli
    cc2a:	de bf       	out	0x3e, r29	; 62
    cc2c:	0f be       	out	0x3f, r0	; 63
    cc2e:	cd bf       	out	0x3d, r28	; 61
    cc30:	cf 91       	pop	r28
    cc32:	df 91       	pop	r29
    cc34:	1f 91       	pop	r17
    cc36:	ff 90       	pop	r15
    cc38:	ef 90       	pop	r14
    cc3a:	df 90       	pop	r13
    cc3c:	cf 90       	pop	r12
    cc3e:	bf 90       	pop	r11
    cc40:	af 90       	pop	r10
    cc42:	9f 90       	pop	r9
    cc44:	8f 90       	pop	r8
    cc46:	7f 90       	pop	r7
    cc48:	6f 90       	pop	r6
    cc4a:	08 95       	ret

0000cc4c <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
    cc4c:	df 92       	push	r13
    cc4e:	ef 92       	push	r14
    cc50:	ff 92       	push	r15
    cc52:	0f 93       	push	r16
    cc54:	1f 93       	push	r17
    cc56:	df 93       	push	r29
    cc58:	cf 93       	push	r28
    cc5a:	cd b7       	in	r28, 0x3d	; 61
    cc5c:	de b7       	in	r29, 0x3e	; 62
    cc5e:	64 97       	sbiw	r28, 0x14	; 20
    cc60:	0f b6       	in	r0, 0x3f	; 63
    cc62:	f8 94       	cli
    cc64:	de bf       	out	0x3e, r29	; 62
    cc66:	0f be       	out	0x3f, r0	; 63
    cc68:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
    cc6a:	80 91 28 02 	lds	r24, 0x0228
    cc6e:	82 30       	cpi	r24, 0x02	; 2
    cc70:	09 f4       	brne	.+2      	; 0xcc74 <FSettingDec+0x28>
    cc72:	c7 c0       	rjmp	.+398    	; 0xce02 <FSettingDec+0x1b6>
    cc74:	83 30       	cpi	r24, 0x03	; 3
    cc76:	30 f4       	brcc	.+12     	; 0xcc84 <FSettingDec+0x38>
    cc78:	88 23       	and	r24, r24
    cc7a:	71 f0       	breq	.+28     	; 0xcc98 <FSettingDec+0x4c>
    cc7c:	81 30       	cpi	r24, 0x01	; 1
    cc7e:	09 f0       	breq	.+2      	; 0xcc82 <FSettingDec+0x36>
    cc80:	b9 c1       	rjmp	.+882    	; 0xcff4 <FSettingDec+0x3a8>
    cc82:	92 c0       	rjmp	.+292    	; 0xcda8 <FSettingDec+0x15c>
    cc84:	84 30       	cpi	r24, 0x04	; 4
    cc86:	09 f4       	brne	.+2      	; 0xcc8a <FSettingDec+0x3e>
    cc88:	ad c1       	rjmp	.+858    	; 0xcfe4 <FSettingDec+0x398>
    cc8a:	84 30       	cpi	r24, 0x04	; 4
    cc8c:	08 f4       	brcc	.+2      	; 0xcc90 <FSettingDec+0x44>
    cc8e:	68 c1       	rjmp	.+720    	; 0xcf60 <FSettingDec+0x314>
    cc90:	85 30       	cpi	r24, 0x05	; 5
    cc92:	09 f0       	breq	.+2      	; 0xcc96 <FSettingDec+0x4a>
    cc94:	af c1       	rjmp	.+862    	; 0xcff4 <FSettingDec+0x3a8>
    cc96:	aa c1       	rjmp	.+852    	; 0xcfec <FSettingDec+0x3a0>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
    cc98:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    cc9c:	e1 99       	sbic	0x1c, 1	; 28
    cc9e:	fe cf       	rjmp	.-4      	; 0xcc9c <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cca0:	89 e3       	ldi	r24, 0x39	; 57
    cca2:	90 e0       	ldi	r25, 0x00	; 0
    cca4:	9f bb       	out	0x1f, r25	; 31
    cca6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    cca8:	e0 9a       	sbi	0x1c, 0	; 28
    ccaa:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ccac:	e1 99       	sbic	0x1c, 1	; 28
    ccae:	fe cf       	rjmp	.-4      	; 0xccac <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ccb0:	8a e3       	ldi	r24, 0x3A	; 58
    ccb2:	90 e0       	ldi	r25, 0x00	; 0
    ccb4:	9f bb       	out	0x1f, r25	; 31
    ccb6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ccb8:	e0 9a       	sbi	0x1c, 0	; 28
    ccba:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ccbc:	e1 99       	sbic	0x1c, 1	; 28
    ccbe:	fe cf       	rjmp	.-4      	; 0xccbc <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ccc0:	8b e3       	ldi	r24, 0x3B	; 59
    ccc2:	90 e0       	ldi	r25, 0x00	; 0
    ccc4:	9f bb       	out	0x1f, r25	; 31
    ccc6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ccc8:	e0 9a       	sbi	0x1c, 0	; 28
    ccca:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
    cccc:	00 d0       	rcall	.+0      	; 0xccce <FSettingDec+0x82>
    ccce:	00 d0       	rcall	.+0      	; 0xccd0 <FSettingDec+0x84>
    ccd0:	00 d0       	rcall	.+0      	; 0xccd2 <FSettingDec+0x86>
    ccd2:	ed b7       	in	r30, 0x3d	; 61
    ccd4:	fe b7       	in	r31, 0x3e	; 62
    ccd6:	31 96       	adiw	r30, 0x01	; 1
    ccd8:	8e 01       	movw	r16, r28
    ccda:	0f 5f       	subi	r16, 0xFF	; 255
    ccdc:	1f 4f       	sbci	r17, 0xFF	; 255
    ccde:	ad b7       	in	r26, 0x3d	; 61
    cce0:	be b7       	in	r27, 0x3e	; 62
    cce2:	12 96       	adiw	r26, 0x02	; 2
    cce4:	1c 93       	st	X, r17
    cce6:	0e 93       	st	-X, r16
    cce8:	11 97       	sbiw	r26, 0x01	; 1
    ccea:	8a e5       	ldi	r24, 0x5A	; 90
    ccec:	92 e1       	ldi	r25, 0x12	; 18
    ccee:	93 83       	std	Z+3, r25	; 0x03
    ccf0:	82 83       	std	Z+2, r24	; 0x02
    ccf2:	24 83       	std	Z+4, r18	; 0x04
    ccf4:	15 82       	std	Z+5, r1	; 0x05
    ccf6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(1,1,lcdteks);
    ccfa:	8d b7       	in	r24, 0x3d	; 61
    ccfc:	9e b7       	in	r25, 0x3e	; 62
    ccfe:	06 96       	adiw	r24, 0x06	; 6
    cd00:	0f b6       	in	r0, 0x3f	; 63
    cd02:	f8 94       	cli
    cd04:	9e bf       	out	0x3e, r25	; 62
    cd06:	0f be       	out	0x3f, r0	; 63
    cd08:	8d bf       	out	0x3d, r24	; 61
    cd0a:	81 e0       	ldi	r24, 0x01	; 1
    cd0c:	61 e0       	ldi	r22, 0x01	; 1
    cd0e:	a8 01       	movw	r20, r16
    cd10:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
    cd14:	00 d0       	rcall	.+0      	; 0xcd16 <FSettingDec+0xca>
    cd16:	00 d0       	rcall	.+0      	; 0xcd18 <FSettingDec+0xcc>
    cd18:	00 d0       	rcall	.+0      	; 0xcd1a <FSettingDec+0xce>
    cd1a:	ed b7       	in	r30, 0x3d	; 61
    cd1c:	fe b7       	in	r31, 0x3e	; 62
    cd1e:	31 96       	adiw	r30, 0x01	; 1
    cd20:	ad b7       	in	r26, 0x3d	; 61
    cd22:	be b7       	in	r27, 0x3e	; 62
    cd24:	12 96       	adiw	r26, 0x02	; 2
    cd26:	1c 93       	st	X, r17
    cd28:	0e 93       	st	-X, r16
    cd2a:	11 97       	sbiw	r26, 0x01	; 1
    cd2c:	8e e4       	ldi	r24, 0x4E	; 78
    cd2e:	92 e1       	ldi	r25, 0x12	; 18
    cd30:	93 83       	std	Z+3, r25	; 0x03
    cd32:	82 83       	std	Z+2, r24	; 0x02
    cd34:	e4 82       	std	Z+4, r14	; 0x04
    cd36:	15 82       	std	Z+5, r1	; 0x05
    cd38:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    cd3c:	8d b7       	in	r24, 0x3d	; 61
    cd3e:	9e b7       	in	r25, 0x3e	; 62
    cd40:	06 96       	adiw	r24, 0x06	; 6
    cd42:	0f b6       	in	r0, 0x3f	; 63
    cd44:	f8 94       	cli
    cd46:	9e bf       	out	0x3e, r25	; 62
    cd48:	0f be       	out	0x3f, r0	; 63
    cd4a:	8d bf       	out	0x3d, r24	; 61
    cd4c:	82 e0       	ldi	r24, 0x02	; 2
    cd4e:	61 e0       	ldi	r22, 0x01	; 1
    cd50:	a8 01       	movw	r20, r16
    cd52:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
    cd56:	00 d0       	rcall	.+0      	; 0xcd58 <FSettingDec+0x10c>
    cd58:	00 d0       	rcall	.+0      	; 0xcd5a <FSettingDec+0x10e>
    cd5a:	00 d0       	rcall	.+0      	; 0xcd5c <FSettingDec+0x110>
    cd5c:	ed b7       	in	r30, 0x3d	; 61
    cd5e:	fe b7       	in	r31, 0x3e	; 62
    cd60:	31 96       	adiw	r30, 0x01	; 1
    cd62:	ad b7       	in	r26, 0x3d	; 61
    cd64:	be b7       	in	r27, 0x3e	; 62
    cd66:	12 96       	adiw	r26, 0x02	; 2
    cd68:	1c 93       	st	X, r17
    cd6a:	0e 93       	st	-X, r16
    cd6c:	11 97       	sbiw	r26, 0x01	; 1
    cd6e:	82 e4       	ldi	r24, 0x42	; 66
    cd70:	92 e1       	ldi	r25, 0x12	; 18
    cd72:	93 83       	std	Z+3, r25	; 0x03
    cd74:	82 83       	std	Z+2, r24	; 0x02
    cd76:	f4 82       	std	Z+4, r15	; 0x04
    cd78:	15 82       	std	Z+5, r1	; 0x05
    cd7a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    cd7e:	8d b7       	in	r24, 0x3d	; 61
    cd80:	9e b7       	in	r25, 0x3e	; 62
    cd82:	06 96       	adiw	r24, 0x06	; 6
    cd84:	0f b6       	in	r0, 0x3f	; 63
    cd86:	f8 94       	cli
    cd88:	9e bf       	out	0x3e, r25	; 62
    cd8a:	0f be       	out	0x3f, r0	; 63
    cd8c:	8d bf       	out	0x3d, r24	; 61
    cd8e:	83 e0       	ldi	r24, 0x03	; 3
    cd90:	61 e0       	ldi	r22, 0x01	; 1
    cd92:	a8 01       	movw	r20, r16
    cd94:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
    cd98:	84 e0       	ldi	r24, 0x04	; 4
    cd9a:	61 e0       	ldi	r22, 0x01	; 1
    cd9c:	41 e3       	ldi	r20, 0x31	; 49
    cd9e:	52 e1       	ldi	r21, 0x12	; 18
    cda0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
    cda4:	81 e0       	ldi	r24, 0x01	; 1
    cda6:	1f c1       	rjmp	.+574    	; 0xcfe6 <FSettingDec+0x39a>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
    cda8:	81 e0       	ldi	r24, 0x01	; 1
    cdaa:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    cdae:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
    cdb2:	98 2f       	mov	r25, r24
    cdb4:	91 53       	subi	r25, 0x31	; 49
    cdb6:	93 30       	cpi	r25, 0x03	; 3
    cdb8:	e0 f4       	brcc	.+56     	; 0xcdf2 <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
    cdba:	29 2f       	mov	r18, r25
    cdbc:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    cdbe:	e1 99       	sbic	0x1c, 1	; 28
    cdc0:	fe cf       	rjmp	.-4      	; 0xcdbe <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cdc2:	c9 01       	movw	r24, r18
    cdc4:	87 5c       	subi	r24, 0xC7	; 199
    cdc6:	9f 4f       	sbci	r25, 0xFF	; 255
    cdc8:	9f bb       	out	0x1f, r25	; 31
    cdca:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    cdcc:	e0 9a       	sbi	0x1c, 0	; 28
    cdce:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    cdd0:	e1 99       	sbic	0x1c, 1	; 28
    cdd2:	fe cf       	rjmp	.-4      	; 0xcdd0 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cdd4:	27 5c       	subi	r18, 0xC7	; 199
    cdd6:	3f 4f       	sbci	r19, 0xFF	; 255
    cdd8:	3f bb       	out	0x1f, r19	; 31
    cdda:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
    cddc:	90 e0       	ldi	r25, 0x00	; 0
    cdde:	01 96       	adiw	r24, 0x01	; 1
    cde0:	83 70       	andi	r24, 0x03	; 3
    cde2:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
    cde4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    cde6:	0f b6       	in	r0, 0x3f	; 63
    cde8:	f8 94       	cli
    cdea:	e2 9a       	sbi	0x1c, 2	; 28
    cdec:	e1 9a       	sbi	0x1c, 1	; 28
    cdee:	0f be       	out	0x3f, r0	; 63
    cdf0:	f6 c0       	rjmp	.+492    	; 0xcfde <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
    cdf2:	8a 32       	cpi	r24, 0x2A	; 42
    cdf4:	11 f4       	brne	.+4      	; 0xcdfa <FSettingDec+0x1ae>
    cdf6:	85 e0       	ldi	r24, 0x05	; 5
    cdf8:	f6 c0       	rjmp	.+492    	; 0xcfe6 <FSettingDec+0x39a>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
    cdfa:	83 32       	cpi	r24, 0x23	; 35
    cdfc:	09 f0       	breq	.+2      	; 0xce00 <FSettingDec+0x1b4>
    cdfe:	fa c0       	rjmp	.+500    	; 0xcff4 <FSettingDec+0x3a8>
    ce00:	f1 c0       	rjmp	.+482    	; 0xcfe4 <FSettingDec+0x398>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ce02:	e1 99       	sbic	0x1c, 1	; 28
    ce04:	fe cf       	rjmp	.-4      	; 0xce02 <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ce06:	8c e3       	ldi	r24, 0x3C	; 60
    ce08:	90 e0       	ldi	r25, 0x00	; 0
    ce0a:	9f bb       	out	0x1f, r25	; 31
    ce0c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ce0e:	e0 9a       	sbi	0x1c, 0	; 28
    ce10:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ce12:	e1 99       	sbic	0x1c, 1	; 28
    ce14:	fe cf       	rjmp	.-4      	; 0xce12 <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ce16:	8d e3       	ldi	r24, 0x3D	; 61
    ce18:	90 e0       	ldi	r25, 0x00	; 0
    ce1a:	9f bb       	out	0x1f, r25	; 31
    ce1c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ce1e:	e0 9a       	sbi	0x1c, 0	; 28
    ce20:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ce22:	e1 99       	sbic	0x1c, 1	; 28
    ce24:	fe cf       	rjmp	.-4      	; 0xce22 <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ce26:	8e e3       	ldi	r24, 0x3E	; 62
    ce28:	90 e0       	ldi	r25, 0x00	; 0
    ce2a:	9f bb       	out	0x1f, r25	; 31
    ce2c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ce2e:	e0 9a       	sbi	0x1c, 0	; 28
    ce30:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ce32:	e1 99       	sbic	0x1c, 1	; 28
    ce34:	fe cf       	rjmp	.-4      	; 0xce32 <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ce36:	8f e3       	ldi	r24, 0x3F	; 63
    ce38:	90 e0       	ldi	r25, 0x00	; 0
    ce3a:	9f bb       	out	0x1f, r25	; 31
    ce3c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ce3e:	e0 9a       	sbi	0x1c, 0	; 28
    ce40:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d "),PDecimalConfig[0]);
    ce42:	00 d0       	rcall	.+0      	; 0xce44 <FSettingDec+0x1f8>
    ce44:	00 d0       	rcall	.+0      	; 0xce46 <FSettingDec+0x1fa>
    ce46:	00 d0       	rcall	.+0      	; 0xce48 <FSettingDec+0x1fc>
    ce48:	ed b7       	in	r30, 0x3d	; 61
    ce4a:	fe b7       	in	r31, 0x3e	; 62
    ce4c:	31 96       	adiw	r30, 0x01	; 1
    ce4e:	8e 01       	movw	r16, r28
    ce50:	0f 5f       	subi	r16, 0xFF	; 255
    ce52:	1f 4f       	sbci	r17, 0xFF	; 255
    ce54:	ad b7       	in	r26, 0x3d	; 61
    ce56:	be b7       	in	r27, 0x3e	; 62
    ce58:	12 96       	adiw	r26, 0x02	; 2
    ce5a:	1c 93       	st	X, r17
    ce5c:	0e 93       	st	-X, r16
    ce5e:	11 97       	sbiw	r26, 0x01	; 1
    ce60:	82 e2       	ldi	r24, 0x22	; 34
    ce62:	92 e1       	ldi	r25, 0x12	; 18
    ce64:	93 83       	std	Z+3, r25	; 0x03
    ce66:	82 83       	std	Z+2, r24	; 0x02
    ce68:	24 83       	std	Z+4, r18	; 0x04
    ce6a:	15 82       	std	Z+5, r1	; 0x05
    ce6c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(1,1,lcdteks);
    ce70:	8d b7       	in	r24, 0x3d	; 61
    ce72:	9e b7       	in	r25, 0x3e	; 62
    ce74:	06 96       	adiw	r24, 0x06	; 6
    ce76:	0f b6       	in	r0, 0x3f	; 63
    ce78:	f8 94       	cli
    ce7a:	9e bf       	out	0x3e, r25	; 62
    ce7c:	0f be       	out	0x3f, r0	; 63
    ce7e:	8d bf       	out	0x3d, r24	; 61
    ce80:	81 e0       	ldi	r24, 0x01	; 1
    ce82:	61 e0       	ldi	r22, 0x01	; 1
    ce84:	a8 01       	movw	r20, r16
    ce86:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
    ce8a:	00 d0       	rcall	.+0      	; 0xce8c <FSettingDec+0x240>
    ce8c:	00 d0       	rcall	.+0      	; 0xce8e <FSettingDec+0x242>
    ce8e:	00 d0       	rcall	.+0      	; 0xce90 <FSettingDec+0x244>
    ce90:	ed b7       	in	r30, 0x3d	; 61
    ce92:	fe b7       	in	r31, 0x3e	; 62
    ce94:	31 96       	adiw	r30, 0x01	; 1
    ce96:	ad b7       	in	r26, 0x3d	; 61
    ce98:	be b7       	in	r27, 0x3e	; 62
    ce9a:	12 96       	adiw	r26, 0x02	; 2
    ce9c:	1c 93       	st	X, r17
    ce9e:	0e 93       	st	-X, r16
    cea0:	11 97       	sbiw	r26, 0x01	; 1
    cea2:	83 e1       	ldi	r24, 0x13	; 19
    cea4:	92 e1       	ldi	r25, 0x12	; 18
    cea6:	93 83       	std	Z+3, r25	; 0x03
    cea8:	82 83       	std	Z+2, r24	; 0x02
    ceaa:	e4 82       	std	Z+4, r14	; 0x04
    ceac:	15 82       	std	Z+5, r1	; 0x05
    ceae:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    ceb2:	8d b7       	in	r24, 0x3d	; 61
    ceb4:	9e b7       	in	r25, 0x3e	; 62
    ceb6:	06 96       	adiw	r24, 0x06	; 6
    ceb8:	0f b6       	in	r0, 0x3f	; 63
    ceba:	f8 94       	cli
    cebc:	9e bf       	out	0x3e, r25	; 62
    cebe:	0f be       	out	0x3f, r0	; 63
    cec0:	8d bf       	out	0x3d, r24	; 61
    cec2:	82 e0       	ldi	r24, 0x02	; 2
    cec4:	61 e0       	ldi	r22, 0x01	; 1
    cec6:	a8 01       	movw	r20, r16
    cec8:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
    cecc:	00 d0       	rcall	.+0      	; 0xcece <FSettingDec+0x282>
    cece:	00 d0       	rcall	.+0      	; 0xced0 <FSettingDec+0x284>
    ced0:	00 d0       	rcall	.+0      	; 0xced2 <FSettingDec+0x286>
    ced2:	ed b7       	in	r30, 0x3d	; 61
    ced4:	fe b7       	in	r31, 0x3e	; 62
    ced6:	31 96       	adiw	r30, 0x01	; 1
    ced8:	ad b7       	in	r26, 0x3d	; 61
    ceda:	be b7       	in	r27, 0x3e	; 62
    cedc:	12 96       	adiw	r26, 0x02	; 2
    cede:	1c 93       	st	X, r17
    cee0:	0e 93       	st	-X, r16
    cee2:	11 97       	sbiw	r26, 0x01	; 1
    cee4:	84 e0       	ldi	r24, 0x04	; 4
    cee6:	92 e1       	ldi	r25, 0x12	; 18
    cee8:	93 83       	std	Z+3, r25	; 0x03
    ceea:	82 83       	std	Z+2, r24	; 0x02
    ceec:	d4 82       	std	Z+4, r13	; 0x04
    ceee:	15 82       	std	Z+5, r1	; 0x05
    cef0:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    cef4:	8d b7       	in	r24, 0x3d	; 61
    cef6:	9e b7       	in	r25, 0x3e	; 62
    cef8:	06 96       	adiw	r24, 0x06	; 6
    cefa:	0f b6       	in	r0, 0x3f	; 63
    cefc:	f8 94       	cli
    cefe:	9e bf       	out	0x3e, r25	; 62
    cf00:	0f be       	out	0x3f, r0	; 63
    cf02:	8d bf       	out	0x3d, r24	; 61
    cf04:	83 e0       	ldi	r24, 0x03	; 3
    cf06:	61 e0       	ldi	r22, 0x01	; 1
    cf08:	a8 01       	movw	r20, r16
    cf0a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
    cf0e:	00 d0       	rcall	.+0      	; 0xcf10 <FSettingDec+0x2c4>
    cf10:	00 d0       	rcall	.+0      	; 0xcf12 <FSettingDec+0x2c6>
    cf12:	00 d0       	rcall	.+0      	; 0xcf14 <FSettingDec+0x2c8>
    cf14:	ed b7       	in	r30, 0x3d	; 61
    cf16:	fe b7       	in	r31, 0x3e	; 62
    cf18:	31 96       	adiw	r30, 0x01	; 1
    cf1a:	ad b7       	in	r26, 0x3d	; 61
    cf1c:	be b7       	in	r27, 0x3e	; 62
    cf1e:	12 96       	adiw	r26, 0x02	; 2
    cf20:	1c 93       	st	X, r17
    cf22:	0e 93       	st	-X, r16
    cf24:	11 97       	sbiw	r26, 0x01	; 1
    cf26:	85 ef       	ldi	r24, 0xF5	; 245
    cf28:	91 e1       	ldi	r25, 0x11	; 17
    cf2a:	93 83       	std	Z+3, r25	; 0x03
    cf2c:	82 83       	std	Z+2, r24	; 0x02
    cf2e:	f4 82       	std	Z+4, r15	; 0x04
    cf30:	15 82       	std	Z+5, r1	; 0x05
    cf32:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    cf36:	8d b7       	in	r24, 0x3d	; 61
    cf38:	9e b7       	in	r25, 0x3e	; 62
    cf3a:	06 96       	adiw	r24, 0x06	; 6
    cf3c:	0f b6       	in	r0, 0x3f	; 63
    cf3e:	f8 94       	cli
    cf40:	9e bf       	out	0x3e, r25	; 62
    cf42:	0f be       	out	0x3f, r0	; 63
    cf44:	8d bf       	out	0x3d, r24	; 61
    cf46:	84 e0       	ldi	r24, 0x04	; 4
    cf48:	61 e0       	ldi	r22, 0x01	; 1
    cf4a:	a8 01       	movw	r20, r16
    cf4c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
    cf50:	84 e0       	ldi	r24, 0x04	; 4
    cf52:	6e e0       	ldi	r22, 0x0E	; 14
    cf54:	4e ee       	ldi	r20, 0xEE	; 238
    cf56:	51 e1       	ldi	r21, 0x11	; 17
    cf58:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
    cf5c:	83 e0       	ldi	r24, 0x03	; 3
    cf5e:	43 c0       	rjmp	.+134    	; 0xcfe6 <FSettingDec+0x39a>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
    cf60:	81 e0       	ldi	r24, 0x01	; 1
    cf62:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    cf66:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    cf6a:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    cf6c:	98 2f       	mov	r25, r24
    cf6e:	91 53       	subi	r25, 0x31	; 49
    cf70:	92 30       	cpi	r25, 0x02	; 2
    cf72:	b0 f4       	brcc	.+44     	; 0xcfa0 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
    cf74:	29 2f       	mov	r18, r25
    cf76:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    cf78:	e1 99       	sbic	0x1c, 1	; 28
    cf7a:	fe cf       	rjmp	.-4      	; 0xcf78 <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cf7c:	c9 01       	movw	r24, r18
    cf7e:	84 5c       	subi	r24, 0xC4	; 196
    cf80:	9f 4f       	sbci	r25, 0xFF	; 255
    cf82:	9f bb       	out	0x1f, r25	; 31
    cf84:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    cf86:	e0 9a       	sbi	0x1c, 0	; 28
    cf88:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    cf8a:	e1 99       	sbic	0x1c, 1	; 28
    cf8c:	fe cf       	rjmp	.-4      	; 0xcf8a <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cf8e:	24 5c       	subi	r18, 0xC4	; 196
    cf90:	3f 4f       	sbci	r19, 0xFF	; 255
    cf92:	3f bb       	out	0x1f, r19	; 31
    cf94:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
    cf96:	90 e0       	ldi	r25, 0x00	; 0
    cf98:	01 96       	adiw	r24, 0x01	; 1
    cf9a:	83 70       	andi	r24, 0x03	; 3
    cf9c:	90 70       	andi	r25, 0x00	; 0
    cf9e:	16 c0       	rjmp	.+44     	; 0xcfcc <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
    cfa0:	83 53       	subi	r24, 0x33	; 51
    cfa2:	82 30       	cpi	r24, 0x02	; 2
    cfa4:	d0 f4       	brcc	.+52     	; 0xcfda <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
    cfa6:	09 2f       	mov	r16, r25
    cfa8:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    cfaa:	e1 99       	sbic	0x1c, 1	; 28
    cfac:	fe cf       	rjmp	.-4      	; 0xcfaa <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cfae:	c8 01       	movw	r24, r16
    cfb0:	84 5c       	subi	r24, 0xC4	; 196
    cfb2:	9f 4f       	sbci	r25, 0xFF	; 255
    cfb4:	9f bb       	out	0x1f, r25	; 31
    cfb6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    cfb8:	e0 9a       	sbi	0x1c, 0	; 28
    cfba:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
    cfbc:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    cfc0:	e1 99       	sbic	0x1c, 1	; 28
    cfc2:	fe cf       	rjmp	.-4      	; 0xcfc0 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cfc4:	04 5c       	subi	r16, 0xC4	; 196
    cfc6:	1f 4f       	sbci	r17, 0xFF	; 255
    cfc8:	1f bb       	out	0x1f, r17	; 31
    cfca:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    cfcc:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    cfce:	0f b6       	in	r0, 0x3f	; 63
    cfd0:	f8 94       	cli
    cfd2:	e2 9a       	sbi	0x1c, 2	; 28
    cfd4:	e1 9a       	sbi	0x1c, 1	; 28
    cfd6:	0f be       	out	0x3f, r0	; 63
    cfd8:	05 c0       	rjmp	.+10     	; 0xcfe4 <FSettingDec+0x398>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
    cfda:	2a 32       	cpi	r18, 0x2A	; 42
    cfdc:	59 f4       	brne	.+22     	; 0xcff4 <FSettingDec+0x3a8>
    cfde:	10 92 28 02 	sts	0x0228, r1
    cfe2:	08 c0       	rjmp	.+16     	; 0xcff4 <FSettingDec+0x3a8>
		          stSettingDecimal=sdTestInput;
				  }*/
          break;
     case sdTestInput:
	      //if (TestUserInput()==MENU_DONE)
		  stSettingDecimal=sdInitDisplay2;
    cfe4:	82 e0       	ldi	r24, 0x02	; 2
    cfe6:	80 93 28 02 	sts	0x0228, r24
    cfea:	04 c0       	rjmp	.+8      	; 0xcff4 <FSettingDec+0x3a8>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
    cfec:	10 92 28 02 	sts	0x0228, r1
    cff0:	81 e0       	ldi	r24, 0x01	; 1
    cff2:	01 c0       	rjmp	.+2      	; 0xcff6 <FSettingDec+0x3aa>
    cff4:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
    cff6:	64 96       	adiw	r28, 0x14	; 20
    cff8:	0f b6       	in	r0, 0x3f	; 63
    cffa:	f8 94       	cli
    cffc:	de bf       	out	0x3e, r29	; 62
    cffe:	0f be       	out	0x3f, r0	; 63
    d000:	cd bf       	out	0x3d, r28	; 61
    d002:	cf 91       	pop	r28
    d004:	df 91       	pop	r29
    d006:	1f 91       	pop	r17
    d008:	0f 91       	pop	r16
    d00a:	ff 90       	pop	r15
    d00c:	ef 90       	pop	r14
    d00e:	df 90       	pop	r13
    d010:	08 95       	ret

0000d012 <FMenuShift>:
static char stMenuShift=msInitMenuShift;
     char SubMenu,KeyChar,KeyPressed;
     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    d012:	80 91 53 02 	lds	r24, 0x0253
    d016:	82 30       	cpi	r24, 0x02	; 2
    d018:	09 f4       	brne	.+2      	; 0xd01c <FMenuShift+0xa>
    d01a:	48 c0       	rjmp	.+144    	; 0xd0ac <FMenuShift+0x9a>
    d01c:	83 30       	cpi	r24, 0x03	; 3
    d01e:	30 f4       	brcc	.+12     	; 0xd02c <FMenuShift+0x1a>
    d020:	88 23       	and	r24, r24
    d022:	69 f0       	breq	.+26     	; 0xd03e <FMenuShift+0x2c>
    d024:	81 30       	cpi	r24, 0x01	; 1
    d026:	09 f0       	breq	.+2      	; 0xd02a <FMenuShift+0x18>
    d028:	50 c0       	rjmp	.+160    	; 0xd0ca <FMenuShift+0xb8>
    d02a:	25 c0       	rjmp	.+74     	; 0xd076 <FMenuShift+0x64>
    d02c:	84 30       	cpi	r24, 0x04	; 4
    d02e:	09 f4       	brne	.+2      	; 0xd032 <FMenuShift+0x20>
    d030:	4c c0       	rjmp	.+152    	; 0xd0ca <FMenuShift+0xb8>
    d032:	84 30       	cpi	r24, 0x04	; 4
    d034:	e8 f1       	brcs	.+122    	; 0xd0b0 <FMenuShift+0x9e>
    d036:	85 30       	cpi	r24, 0x05	; 5
    d038:	09 f0       	breq	.+2      	; 0xd03c <FMenuShift+0x2a>
    d03a:	47 c0       	rjmp	.+142    	; 0xd0ca <FMenuShift+0xb8>
    d03c:	42 c0       	rjmp	.+132    	; 0xd0c2 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    d03e:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    d042:	81 e0       	ldi	r24, 0x01	; 1
    d044:	61 e0       	ldi	r22, 0x01	; 1
    d046:	4b ec       	ldi	r20, 0xCB	; 203
    d048:	56 e1       	ldi	r21, 0x16	; 22
    d04a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    d04e:	82 e0       	ldi	r24, 0x02	; 2
    d050:	61 e0       	ldi	r22, 0x01	; 1
    d052:	4d eb       	ldi	r20, 0xBD	; 189
    d054:	56 e1       	ldi	r21, 0x16	; 22
    d056:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    d05a:	83 e0       	ldi	r24, 0x03	; 3
    d05c:	61 e0       	ldi	r22, 0x01	; 1
    d05e:	4f ea       	ldi	r20, 0xAF	; 175
    d060:	56 e1       	ldi	r21, 0x16	; 22
    d062:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    d066:	84 e0       	ldi	r24, 0x04	; 4
    d068:	61 e0       	ldi	r22, 0x01	; 1
    d06a:	48 ea       	ldi	r20, 0xA8	; 168
    d06c:	56 e1       	ldi	r21, 0x16	; 22
    d06e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stMenuShift=msSelectShift;
    d072:	81 e0       	ldi	r24, 0x01	; 1
    d074:	18 c0       	rjmp	.+48     	; 0xd0a6 <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    d076:	81 e0       	ldi	r24, 0x01	; 1
    d078:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    d07c:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
          switch(KeyChar){
    d080:	82 33       	cpi	r24, 0x32	; 50
    d082:	61 f0       	breq	.+24     	; 0xd09c <FMenuShift+0x8a>
    d084:	83 33       	cpi	r24, 0x33	; 51
    d086:	28 f4       	brcc	.+10     	; 0xd092 <FMenuShift+0x80>
    d088:	8a 32       	cpi	r24, 0x2A	; 42
    d08a:	61 f0       	breq	.+24     	; 0xd0a4 <FMenuShift+0x92>
    d08c:	81 33       	cpi	r24, 0x31	; 49
    d08e:	e9 f4       	brne	.+58     	; 0xd0ca <FMenuShift+0xb8>
    d090:	03 c0       	rjmp	.+6      	; 0xd098 <FMenuShift+0x86>
    d092:	83 33       	cpi	r24, 0x33	; 51
    d094:	d1 f4       	brne	.+52     	; 0xd0ca <FMenuShift+0xb8>
    d096:	04 c0       	rjmp	.+8      	; 0xd0a0 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    d098:	82 e0       	ldi	r24, 0x02	; 2
    d09a:	05 c0       	rjmp	.+10     	; 0xd0a6 <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    d09c:	83 e0       	ldi	r24, 0x03	; 3
    d09e:	03 c0       	rjmp	.+6      	; 0xd0a6 <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    d0a0:	84 e0       	ldi	r24, 0x04	; 4
    d0a2:	01 c0       	rjmp	.+2      	; 0xd0a6 <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    d0a4:	85 e0       	ldi	r24, 0x05	; 5
    d0a6:	80 93 53 02 	sts	0x0253, r24
    d0aa:	09 c0       	rjmp	.+18     	; 0xd0be <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    d0ac:	82 e0       	ldi	r24, 0x02	; 2
    d0ae:	01 c0       	rjmp	.+2      	; 0xd0b2 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    d0b0:	81 e0       	ldi	r24, 0x01	; 1
    d0b2:	0e 94 3a 5e 	call	0xbc74	; 0xbc74 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    d0b6:	81 30       	cpi	r24, 0x01	; 1
    d0b8:	41 f4       	brne	.+16     	; 0xd0ca <FMenuShift+0xb8>
    d0ba:	10 92 53 02 	sts	0x0253, r1
    d0be:	80 e0       	ldi	r24, 0x00	; 0
    d0c0:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    d0c2:	10 92 53 02 	sts	0x0253, r1
    d0c6:	81 e0       	ldi	r24, 0x01	; 1
    d0c8:	08 95       	ret
    d0ca:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    d0cc:	08 95       	ret

0000d0ce <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    d0ce:	84 e0       	ldi	r24, 0x04	; 4
    d0d0:	61 e0       	ldi	r22, 0x01	; 1
    d0d2:	44 e4       	ldi	r20, 0x44	; 68
    d0d4:	52 e2       	ldi	r21, 0x22	; 34
    d0d6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d0da:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d0dc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d0de:	85 e0       	ldi	r24, 0x05	; 5
    d0e0:	80 93 be 01 	sts	0x01BE, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    d0e4:	81 e0       	ldi	r24, 0x01	; 1
    d0e6:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		__num = _key_btn(__key);
    d0ea:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    d0ee:	80 53       	subi	r24, 0x30	; 48
    d0f0:	8a 30       	cpi	r24, 0x0A	; 10
    d0f2:	20 f0       	brcs	.+8      	; 0xd0fc <system_stop+0x2e>
    d0f4:	80 91 9e 01 	lds	r24, 0x019E
    d0f8:	81 30       	cpi	r24, 0x01	; 1
    d0fa:	a1 f7       	brne	.-24     	; 0xd0e4 <system_stop+0x16>
    d0fc:	08 95       	ret

0000d0fe <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    d0fe:	84 e0       	ldi	r24, 0x04	; 4
    d100:	61 e0       	ldi	r22, 0x01	; 1
    d102:	49 e5       	ldi	r20, 0x59	; 89
    d104:	52 e2       	ldi	r21, 0x22	; 34
    d106:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d10a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d10c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d10e:	81 e0       	ldi	r24, 0x01	; 1
    d110:	80 93 be 01 	sts	0x01BE, r24
    d114:	80 e5       	ldi	r24, 0x50	; 80
    d116:	93 ec       	ldi	r25, 0xC3	; 195
    d118:	01 97       	sbiw	r24, 0x01	; 1
    d11a:	f1 f7       	brne	.-4      	; 0xd118 <systemForceType+0x1a>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d11c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d11e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d120:	82 e0       	ldi	r24, 0x02	; 2
    d122:	80 93 be 01 	sts	0x01BE, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    d126:	81 e0       	ldi	r24, 0x01	; 1
    d128:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    d12c:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    d130:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    d132:	81 53       	subi	r24, 0x31	; 49
    d134:	82 30       	cpi	r24, 0x02	; 2
    d136:	b8 f7       	brcc	.-18     	; 0xd126 <systemForceType+0x28>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    d138:	89 2f       	mov	r24, r25
    d13a:	08 95       	ret

0000d13c <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    d13c:	8f 92       	push	r8
    d13e:	9f 92       	push	r9
    d140:	af 92       	push	r10
    d142:	bf 92       	push	r11
    d144:	cf 92       	push	r12
    d146:	df 92       	push	r13
    d148:	ef 92       	push	r14
    d14a:	ff 92       	push	r15
    d14c:	0f 93       	push	r16
    d14e:	1f 93       	push	r17
    d150:	df 93       	push	r29
    d152:	cf 93       	push	r28
    d154:	cd b7       	in	r28, 0x3d	; 61
    d156:	de b7       	in	r29, 0x3e	; 62
    d158:	c2 54       	subi	r28, 0x42	; 66
    d15a:	d0 40       	sbci	r29, 0x00	; 0
    d15c:	0f b6       	in	r0, 0x3f	; 63
    d15e:	f8 94       	cli
    d160:	de bf       	out	0x3e, r29	; 62
    d162:	0f be       	out	0x3f, r0	; 63
    d164:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    d166:	de 01       	movw	r26, r28
    d168:	53 96       	adiw	r26, 0x13	; 19
    d16a:	e7 e1       	ldi	r30, 0x17	; 23
    d16c:	f1 e0       	ldi	r31, 0x01	; 1
    d16e:	80 e3       	ldi	r24, 0x30	; 48
    d170:	01 90       	ld	r0, Z+
    d172:	0d 92       	st	X+, r0
    d174:	81 50       	subi	r24, 0x01	; 1
    d176:	e1 f7       	brne	.-8      	; 0xd170 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    d178:	8e 01       	movw	r16, r28
    d17a:	0f 5f       	subi	r16, 0xFF	; 255
    d17c:	1f 4f       	sbci	r17, 0xFF	; 255
    d17e:	b8 01       	movw	r22, r16
    d180:	ae 01       	movw	r20, r28
    d182:	46 5f       	subi	r20, 0xF6	; 246
    d184:	5f 4f       	sbci	r21, 0xFF	; 255
    d186:	0e 94 b4 aa 	call	0x15568	; 0x15568 <_datetime>
    d18a:	85 e1       	ldi	r24, 0x15	; 21
    d18c:	88 2e       	mov	r8, r24
    d18e:	91 2c       	mov	r9, r1
    d190:	8c 0e       	add	r8, r28
    d192:	9d 1e       	adc	r9, r29
    d194:	d4 01       	movw	r26, r8
    d196:	20 e0       	ldi	r18, 0x00	; 0
    d198:	30 e0       	ldi	r19, 0x00	; 0
    d19a:	40 e0       	ldi	r20, 0x00	; 0
    d19c:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    d19e:	22 30       	cpi	r18, 0x02	; 2
    d1a0:	31 05       	cpc	r19, r1
    d1a2:	19 f0       	breq	.+6      	; 0xd1aa <_menu_datetime+0x6e>
    d1a4:	24 30       	cpi	r18, 0x04	; 4
    d1a6:	31 05       	cpc	r19, r1
    d1a8:	11 f4       	brne	.+4      	; 0xd1ae <_menu_datetime+0x72>
			__ii++;
    d1aa:	4f 5f       	subi	r20, 0xFF	; 255
    d1ac:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    d1ae:	f8 01       	movw	r30, r16
    d1b0:	e4 0f       	add	r30, r20
    d1b2:	f5 1f       	adc	r31, r21
    d1b4:	80 81       	ld	r24, Z
    d1b6:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    d1b8:	2f 5f       	subi	r18, 0xFF	; 255
    d1ba:	3f 4f       	sbci	r19, 0xFF	; 255
    d1bc:	14 96       	adiw	r26, 0x04	; 4
    d1be:	26 30       	cpi	r18, 0x06	; 6
    d1c0:	31 05       	cpc	r19, r1
    d1c2:	19 f0       	breq	.+6      	; 0xd1ca <_menu_datetime+0x8e>
    d1c4:	4f 5f       	subi	r20, 0xFF	; 255
    d1c6:	5f 4f       	sbci	r21, 0xFF	; 255
    d1c8:	ea cf       	rjmp	.-44     	; 0xd19e <_menu_datetime+0x62>
    d1ca:	0d e2       	ldi	r16, 0x2D	; 45
    d1cc:	a0 2e       	mov	r10, r16
    d1ce:	b1 2c       	mov	r11, r1
    d1d0:	ac 0e       	add	r10, r28
    d1d2:	bd 1e       	adc	r11, r29
    d1d4:	d5 01       	movw	r26, r10
    d1d6:	40 e0       	ldi	r20, 0x00	; 0
    d1d8:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    d1da:	1a e0       	ldi	r17, 0x0A	; 10
    d1dc:	e1 2e       	mov	r14, r17
    d1de:	f1 2c       	mov	r15, r1
    d1e0:	ec 0e       	add	r14, r28
    d1e2:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    d1e4:	28 30       	cpi	r18, 0x08	; 8
    d1e6:	31 05       	cpc	r19, r1
    d1e8:	19 f0       	breq	.+6      	; 0xd1f0 <_menu_datetime+0xb4>
    d1ea:	2a 30       	cpi	r18, 0x0A	; 10
    d1ec:	31 05       	cpc	r19, r1
    d1ee:	11 f4       	brne	.+4      	; 0xd1f4 <_menu_datetime+0xb8>
			__ii++;
    d1f0:	4f 5f       	subi	r20, 0xFF	; 255
    d1f2:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    d1f4:	f7 01       	movw	r30, r14
    d1f6:	e4 0f       	add	r30, r20
    d1f8:	f5 1f       	adc	r31, r21
    d1fa:	80 81       	ld	r24, Z
    d1fc:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    d1fe:	2f 5f       	subi	r18, 0xFF	; 255
    d200:	3f 4f       	sbci	r19, 0xFF	; 255
    d202:	14 96       	adiw	r26, 0x04	; 4
    d204:	2c 30       	cpi	r18, 0x0C	; 12
    d206:	31 05       	cpc	r19, r1
    d208:	19 f0       	breq	.+6      	; 0xd210 <_menu_datetime+0xd4>
    d20a:	4f 5f       	subi	r20, 0xFF	; 255
    d20c:	5f 4f       	sbci	r21, 0xFF	; 255
    d20e:	ea cf       	rjmp	.-44     	; 0xd1e4 <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    d210:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    d214:	84 ec       	ldi	r24, 0xC4	; 196
    d216:	99 e0       	ldi	r25, 0x09	; 9
    d218:	01 97       	sbiw	r24, 0x01	; 1
    d21a:	f1 f7       	brne	.-4      	; 0xd218 <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    d21c:	81 e0       	ldi	r24, 0x01	; 1
    d21e:	61 e0       	ldi	r22, 0x01	; 1
    d220:	4f e9       	ldi	r20, 0x9F	; 159
    d222:	5c e0       	ldi	r21, 0x0C	; 12
    d224:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    d228:	82 e0       	ldi	r24, 0x02	; 2
    d22a:	61 e0       	ldi	r22, 0x01	; 1
    d22c:	47 e9       	ldi	r20, 0x97	; 151
    d22e:	5c e0       	ldi	r21, 0x0C	; 12
    d230:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	lcd_print(1, 8, __date);
    d234:	81 e0       	ldi	r24, 0x01	; 1
    d236:	68 e0       	ldi	r22, 0x08	; 8
    d238:	8e 01       	movw	r16, r28
    d23a:	0f 5f       	subi	r16, 0xFF	; 255
    d23c:	1f 4f       	sbci	r17, 0xFF	; 255
    d23e:	a8 01       	movw	r20, r16
    d240:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	lcd_print(2, 8, __time);
    d244:	82 e0       	ldi	r24, 0x02	; 2
    d246:	68 e0       	ldi	r22, 0x08	; 8
    d248:	a7 01       	movw	r20, r14
    d24a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    d24e:	84 e0       	ldi	r24, 0x04	; 4
    d250:	61 e0       	ldi	r22, 0x01	; 1
    d252:	42 e8       	ldi	r20, 0x82	; 130
    d254:	5c e0       	ldi	r21, 0x0C	; 12
    d256:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    d25a:	8b 89       	ldd	r24, Y+19	; 0x13
    d25c:	6c 89       	ldd	r22, Y+20	; 0x14
    d25e:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
	CURSOR_SHOW;
    d262:	8f e0       	ldi	r24, 0x0F	; 15
    d264:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
    d268:	ee 24       	eor	r14, r14
    d26a:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    d26c:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    d26e:	81 e0       	ldi	r24, 0x01	; 1
    d270:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    d274:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    d276:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    d27a:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    d27c:	80 53       	subi	r24, 0x30	; 48
    d27e:	8a 30       	cpi	r24, 0x0A	; 10
    d280:	08 f0       	brcs	.+2      	; 0xd284 <_menu_datetime+0x148>
    d282:	72 c0       	rjmp	.+228    	; 0xd368 <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    d284:	e1 14       	cp	r14, r1
    d286:	f1 04       	cpc	r15, r1
    d288:	81 f0       	breq	.+32     	; 0xd2aa <_menu_datetime+0x16e>
    d28a:	82 e0       	ldi	r24, 0x02	; 2
    d28c:	e8 16       	cp	r14, r24
    d28e:	f1 04       	cpc	r15, r1
    d290:	61 f0       	breq	.+24     	; 0xd2aa <_menu_datetime+0x16e>
    d292:	96 e0       	ldi	r25, 0x06	; 6
    d294:	e9 16       	cp	r14, r25
    d296:	f1 04       	cpc	r15, r1
    d298:	41 f0       	breq	.+16     	; 0xd2aa <_menu_datetime+0x16e>
    d29a:	a8 e0       	ldi	r26, 0x08	; 8
    d29c:	ea 16       	cp	r14, r26
    d29e:	f1 04       	cpc	r15, r1
    d2a0:	21 f0       	breq	.+8      	; 0xd2aa <_menu_datetime+0x16e>
    d2a2:	ba e0       	ldi	r27, 0x0A	; 10
    d2a4:	eb 16       	cp	r14, r27
    d2a6:	f1 04       	cpc	r15, r1
    d2a8:	81 f4       	brne	.+32     	; 0xd2ca <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    d2aa:	84 2f       	mov	r24, r20
    d2ac:	90 e0       	ldi	r25, 0x00	; 0
    d2ae:	c0 97       	sbiw	r24, 0x30	; 48
    d2b0:	f7 01       	movw	r30, r14
    d2b2:	ee 0f       	add	r30, r30
    d2b4:	ff 1f       	adc	r31, r31
    d2b6:	ee 0f       	add	r30, r30
    d2b8:	ff 1f       	adc	r31, r31
    d2ba:	ec 0d       	add	r30, r12
    d2bc:	fd 1d       	adc	r31, r13
    d2be:	25 89       	ldd	r18, Z+21	; 0x15
    d2c0:	30 e0       	ldi	r19, 0x00	; 0
    d2c2:	28 17       	cp	r18, r24
    d2c4:	39 07       	cpc	r19, r25
    d2c6:	84 f5       	brge	.+96     	; 0xd328 <_menu_datetime+0x1ec>
    d2c8:	4f c0       	rjmp	.+158    	; 0xd368 <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    d2ca:	81 e0       	ldi	r24, 0x01	; 1
    d2cc:	e8 16       	cp	r14, r24
    d2ce:	f1 04       	cpc	r15, r1
    d2d0:	61 f4       	brne	.+24     	; 0xd2ea <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    d2d2:	2d 89       	ldd	r18, Y+21	; 0x15
    d2d4:	30 e0       	ldi	r19, 0x00	; 0
    d2d6:	2f 52       	subi	r18, 0x2F	; 47
    d2d8:	30 40       	sbci	r19, 0x00	; 0
    d2da:	8e 89       	ldd	r24, Y+22	; 0x16
    d2dc:	90 e0       	ldi	r25, 0x00	; 0
    d2de:	82 17       	cp	r24, r18
    d2e0:	93 07       	cpc	r25, r19
    d2e2:	14 f5       	brge	.+68     	; 0xd328 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    d2e4:	42 33       	cpi	r20, 0x32	; 50
    d2e6:	00 f1       	brcs	.+64     	; 0xd328 <_menu_datetime+0x1ec>
    d2e8:	3f c0       	rjmp	.+126    	; 0xd368 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    d2ea:	93 e0       	ldi	r25, 0x03	; 3
    d2ec:	e9 16       	cp	r14, r25
    d2ee:	f1 04       	cpc	r15, r1
    d2f0:	61 f4       	brne	.+24     	; 0xd30a <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    d2f2:	2d 8d       	ldd	r18, Y+29	; 0x1d
    d2f4:	30 e0       	ldi	r19, 0x00	; 0
    d2f6:	2f 52       	subi	r18, 0x2F	; 47
    d2f8:	30 40       	sbci	r19, 0x00	; 0
    d2fa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    d2fc:	90 e0       	ldi	r25, 0x00	; 0
    d2fe:	82 17       	cp	r24, r18
    d300:	93 07       	cpc	r25, r19
    d302:	94 f4       	brge	.+36     	; 0xd328 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    d304:	43 33       	cpi	r20, 0x33	; 51
    d306:	80 f0       	brcs	.+32     	; 0xd328 <_menu_datetime+0x1ec>
    d308:	2f c0       	rjmp	.+94     	; 0xd368 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    d30a:	a7 e0       	ldi	r26, 0x07	; 7
    d30c:	ea 16       	cp	r14, r26
    d30e:	f1 04       	cpc	r15, r1
    d310:	59 f4       	brne	.+22     	; 0xd328 <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    d312:	2d a5       	ldd	r18, Y+45	; 0x2d
    d314:	30 e0       	ldi	r19, 0x00	; 0
    d316:	2f 52       	subi	r18, 0x2F	; 47
    d318:	30 40       	sbci	r19, 0x00	; 0
    d31a:	8e a5       	ldd	r24, Y+46	; 0x2e
    d31c:	90 e0       	ldi	r25, 0x00	; 0
    d31e:	82 17       	cp	r24, r18
    d320:	93 07       	cpc	r25, r19
    d322:	14 f4       	brge	.+4      	; 0xd328 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    d324:	44 33       	cpi	r20, 0x34	; 52
    d326:	00 f5       	brcc	.+64     	; 0xd368 <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    d328:	f7 01       	movw	r30, r14
    d32a:	ee 0f       	add	r30, r30
    d32c:	ff 1f       	adc	r31, r31
    d32e:	ee 0f       	add	r30, r30
    d330:	ff 1f       	adc	r31, r31
    d332:	ec 0d       	add	r30, r12
    d334:	fd 1d       	adc	r31, r13
    d336:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    d338:	84 2f       	mov	r24, r20
    d33a:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
			__i++;
    d33e:	08 94       	sec
    d340:	e1 1c       	adc	r14, r1
    d342:	f1 1c       	adc	r15, r1
    d344:	bc e0       	ldi	r27, 0x0C	; 12
    d346:	eb 16       	cp	r14, r27
    d348:	f1 04       	cpc	r15, r1
    d34a:	1c f0       	brlt	.+6      	; 0xd352 <_menu_datetime+0x216>
    d34c:	7b e0       	ldi	r23, 0x0B	; 11
    d34e:	e7 2e       	mov	r14, r23
    d350:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    d352:	f7 01       	movw	r30, r14
    d354:	ee 0f       	add	r30, r30
    d356:	ff 1f       	adc	r31, r31
    d358:	ee 0f       	add	r30, r30
    d35a:	ff 1f       	adc	r31, r31
    d35c:	ec 0d       	add	r30, r12
    d35e:	fd 1d       	adc	r31, r13
    d360:	82 89       	ldd	r24, Z+18	; 0x12
    d362:	63 89       	ldd	r22, Z+19	; 0x13
    d364:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    d368:	1b 37       	cpi	r17, 0x7B	; 123
    d36a:	59 f4       	brne	.+22     	; 0xd382 <_menu_datetime+0x246>
			__i++;
    d36c:	08 94       	sec
    d36e:	e1 1c       	adc	r14, r1
    d370:	f1 1c       	adc	r15, r1
    d372:	8c e0       	ldi	r24, 0x0C	; 12
    d374:	e8 16       	cp	r14, r24
    d376:	f1 04       	cpc	r15, r1
    d378:	6c f0       	brlt	.+26     	; 0xd394 <_menu_datetime+0x258>
    d37a:	5b e0       	ldi	r21, 0x0B	; 11
    d37c:	e5 2e       	mov	r14, r21
    d37e:	f1 2c       	mov	r15, r1
    d380:	09 c0       	rjmp	.+18     	; 0xd394 <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    d382:	17 37       	cpi	r17, 0x77	; 119
    d384:	99 f4       	brne	.+38     	; 0xd3ac <_menu_datetime+0x270>
			__i--;
    d386:	08 94       	sec
    d388:	e1 08       	sbc	r14, r1
    d38a:	f1 08       	sbc	r15, r1
    d38c:	f7 fe       	sbrs	r15, 7
    d38e:	02 c0       	rjmp	.+4      	; 0xd394 <_menu_datetime+0x258>
    d390:	ee 24       	eor	r14, r14
    d392:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    d394:	f7 01       	movw	r30, r14
    d396:	ee 0f       	add	r30, r30
    d398:	ff 1f       	adc	r31, r31
    d39a:	ee 0f       	add	r30, r30
    d39c:	ff 1f       	adc	r31, r31
    d39e:	ec 0d       	add	r30, r12
    d3a0:	fd 1d       	adc	r31, r13
    d3a2:	82 89       	ldd	r24, Z+18	; 0x12
    d3a4:	63 89       	ldd	r22, Z+19	; 0x13
    d3a6:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
    d3aa:	61 cf       	rjmp	.-318    	; 0xd26e <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    d3ac:	17 3e       	cpi	r17, 0xE7	; 231
    d3ae:	09 f4       	brne	.+2      	; 0xd3b2 <_menu_datetime+0x276>
    d3b0:	49 c0       	rjmp	.+146    	; 0xd444 <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    d3b2:	17 3b       	cpi	r17, 0xB7	; 183
    d3b4:	09 f0       	breq	.+2      	; 0xd3b8 <_menu_datetime+0x27c>
    d3b6:	5b cf       	rjmp	.-330    	; 0xd26e <_menu_datetime+0x132>
    d3b8:	20 e0       	ldi	r18, 0x00	; 0
    d3ba:	30 e0       	ldi	r19, 0x00	; 0
    d3bc:	40 e0       	ldi	r20, 0x00	; 0
    d3be:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    d3c0:	be 01       	movw	r22, r28
    d3c2:	6f 5f       	subi	r22, 0xFF	; 255
    d3c4:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    d3c6:	22 30       	cpi	r18, 0x02	; 2
    d3c8:	31 05       	cpc	r19, r1
    d3ca:	19 f0       	breq	.+6      	; 0xd3d2 <_menu_datetime+0x296>
    d3cc:	24 30       	cpi	r18, 0x04	; 4
    d3ce:	31 05       	cpc	r19, r1
    d3d0:	11 f4       	brne	.+4      	; 0xd3d6 <_menu_datetime+0x29a>
					__ii++;
    d3d2:	4f 5f       	subi	r20, 0xFF	; 255
    d3d4:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    d3d6:	fb 01       	movw	r30, r22
    d3d8:	e4 0f       	add	r30, r20
    d3da:	f5 1f       	adc	r31, r21
    d3dc:	d4 01       	movw	r26, r8
    d3de:	8c 91       	ld	r24, X
    d3e0:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    d3e2:	2f 5f       	subi	r18, 0xFF	; 255
    d3e4:	3f 4f       	sbci	r19, 0xFF	; 255
    d3e6:	84 e0       	ldi	r24, 0x04	; 4
    d3e8:	90 e0       	ldi	r25, 0x00	; 0
    d3ea:	88 0e       	add	r8, r24
    d3ec:	99 1e       	adc	r9, r25
    d3ee:	26 30       	cpi	r18, 0x06	; 6
    d3f0:	31 05       	cpc	r19, r1
    d3f2:	19 f0       	breq	.+6      	; 0xd3fa <_menu_datetime+0x2be>
    d3f4:	4f 5f       	subi	r20, 0xFF	; 255
    d3f6:	5f 4f       	sbci	r21, 0xFF	; 255
    d3f8:	e6 cf       	rjmp	.-52     	; 0xd3c6 <_menu_datetime+0x28a>
    d3fa:	60 e0       	ldi	r22, 0x00	; 0
    d3fc:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    d3fe:	ae 01       	movw	r20, r28
    d400:	46 5f       	subi	r20, 0xF6	; 246
    d402:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    d404:	28 30       	cpi	r18, 0x08	; 8
    d406:	31 05       	cpc	r19, r1
    d408:	19 f0       	breq	.+6      	; 0xd410 <_menu_datetime+0x2d4>
    d40a:	2a 30       	cpi	r18, 0x0A	; 10
    d40c:	31 05       	cpc	r19, r1
    d40e:	11 f4       	brne	.+4      	; 0xd414 <_menu_datetime+0x2d8>
					__ii++;
    d410:	6f 5f       	subi	r22, 0xFF	; 255
    d412:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    d414:	fa 01       	movw	r30, r20
    d416:	e6 0f       	add	r30, r22
    d418:	f7 1f       	adc	r31, r23
    d41a:	d5 01       	movw	r26, r10
    d41c:	8c 91       	ld	r24, X
    d41e:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    d420:	2f 5f       	subi	r18, 0xFF	; 255
    d422:	3f 4f       	sbci	r19, 0xFF	; 255
    d424:	84 e0       	ldi	r24, 0x04	; 4
    d426:	90 e0       	ldi	r25, 0x00	; 0
    d428:	a8 0e       	add	r10, r24
    d42a:	b9 1e       	adc	r11, r25
    d42c:	2c 30       	cpi	r18, 0x0C	; 12
    d42e:	31 05       	cpc	r19, r1
    d430:	19 f0       	breq	.+6      	; 0xd438 <_menu_datetime+0x2fc>
    d432:	6f 5f       	subi	r22, 0xFF	; 255
    d434:	7f 4f       	sbci	r23, 0xFF	; 255
    d436:	e6 cf       	rjmp	.-52     	; 0xd404 <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    d438:	81 e0       	ldi	r24, 0x01	; 1
    d43a:	be 01       	movw	r22, r28
    d43c:	6f 5f       	subi	r22, 0xFF	; 255
    d43e:	7f 4f       	sbci	r23, 0xFF	; 255
    d440:	0e 94 b4 aa 	call	0x15568	; 0x15568 <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    d444:	8c e0       	ldi	r24, 0x0C	; 12
    d446:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
}
    d44a:	ce 5b       	subi	r28, 0xBE	; 190
    d44c:	df 4f       	sbci	r29, 0xFF	; 255
    d44e:	0f b6       	in	r0, 0x3f	; 63
    d450:	f8 94       	cli
    d452:	de bf       	out	0x3e, r29	; 62
    d454:	0f be       	out	0x3f, r0	; 63
    d456:	cd bf       	out	0x3d, r28	; 61
    d458:	cf 91       	pop	r28
    d45a:	df 91       	pop	r29
    d45c:	1f 91       	pop	r17
    d45e:	0f 91       	pop	r16
    d460:	ff 90       	pop	r15
    d462:	ef 90       	pop	r14
    d464:	df 90       	pop	r13
    d466:	cf 90       	pop	r12
    d468:	bf 90       	pop	r11
    d46a:	af 90       	pop	r10
    d46c:	9f 90       	pop	r9
    d46e:	8f 90       	pop	r8
    d470:	08 95       	ret

0000d472 <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    d472:	0e 94 9e 68 	call	0xd13c	; 0xd13c <_menu_datetime>
     return MENU_DONE;
}
    d476:	81 e0       	ldi	r24, 0x01	; 1
    d478:	08 95       	ret

0000d47a <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    d47a:	4f 92       	push	r4
    d47c:	5f 92       	push	r5
    d47e:	6f 92       	push	r6
    d480:	7f 92       	push	r7
    d482:	8f 92       	push	r8
    d484:	9f 92       	push	r9
    d486:	af 92       	push	r10
    d488:	bf 92       	push	r11
    d48a:	cf 92       	push	r12
    d48c:	df 92       	push	r13
    d48e:	ef 92       	push	r14
    d490:	ff 92       	push	r15
    d492:	0f 93       	push	r16
    d494:	1f 93       	push	r17
    d496:	df 93       	push	r29
    d498:	cf 93       	push	r28
    d49a:	cd b7       	in	r28, 0x3d	; 61
    d49c:	de b7       	in	r29, 0x3e	; 62
    d49e:	a2 97       	sbiw	r28, 0x22	; 34
    d4a0:	0f b6       	in	r0, 0x3f	; 63
    d4a2:	f8 94       	cli
    d4a4:	de bf       	out	0x3e, r29	; 62
    d4a6:	0f be       	out	0x3f, r0	; 63
    d4a8:	cd bf       	out	0x3d, r28	; 61
    d4aa:	7c 01       	movw	r14, r24
    d4ac:	6b 01       	movw	r12, r22

       char KeyPressed=0,KeyChar;
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];

       switch(stEnterFIP){
    d4ae:	80 91 75 02 	lds	r24, 0x0275
    d4b2:	81 30       	cpi	r24, 0x01	; 1
    d4b4:	09 f4       	brne	.+2      	; 0xd4b8 <menu_FIP+0x3e>
    d4b6:	cf c0       	rjmp	.+414    	; 0xd656 <menu_FIP+0x1dc>
    d4b8:	81 30       	cpi	r24, 0x01	; 1
    d4ba:	20 f0       	brcs	.+8      	; 0xd4c4 <menu_FIP+0x4a>
    d4bc:	82 30       	cpi	r24, 0x02	; 2
    d4be:	09 f0       	breq	.+2      	; 0xd4c2 <menu_FIP+0x48>
    d4c0:	4c c1       	rjmp	.+664    	; 0xd75a <menu_FIP+0x2e0>
    d4c2:	49 c1       	rjmp	.+658    	; 0xd756 <menu_FIP+0x2dc>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d4c4:	8e 01       	movw	r16, r28
    d4c6:	09 5f       	subi	r16, 0xF9	; 249
    d4c8:	1f 4f       	sbci	r17, 0xFF	; 255
    d4ca:	c8 01       	movw	r24, r16
    d4cc:	65 e4       	ldi	r22, 0x45	; 69
    d4ce:	70 e0       	ldi	r23, 0x00	; 0
    d4d0:	48 e0       	ldi	r20, 0x08	; 8
    d4d2:	50 e0       	ldi	r21, 0x00	; 0
    d4d4:	22 e4       	ldi	r18, 0x42	; 66
    d4d6:	33 e1       	ldi	r19, 0x13	; 19
    d4d8:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    d4dc:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    d4e0:	f8 01       	movw	r30, r16
    d4e2:	20 e0       	ldi	r18, 0x00	; 0
    d4e4:	30 e0       	ldi	r19, 0x00	; 0
    d4e6:	07 c0       	rjmp	.+14     	; 0xd4f6 <menu_FIP+0x7c>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    d4e8:	80 81       	ld	r24, Z
    d4ea:	84 36       	cpi	r24, 0x64	; 100
    d4ec:	08 f0       	brcs	.+2      	; 0xd4f0 <menu_FIP+0x76>
    d4ee:	10 82       	st	Z, r1
    d4f0:	2f 5f       	subi	r18, 0xFF	; 255
    d4f2:	3f 4f       	sbci	r19, 0xFF	; 255
    d4f4:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    d4f6:	28 30       	cpi	r18, 0x08	; 8
    d4f8:	31 05       	cpc	r19, r1
    d4fa:	b0 f3       	brcs	.-20     	; 0xd4e8 <menu_FIP+0x6e>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    d4fc:	10 92 73 02 	sts	0x0273, r1
    d500:	10 92 72 02 	sts	0x0272, r1
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    d504:	5e 01       	movw	r10, r28
    d506:	08 94       	sec
    d508:	a1 1c       	adc	r10, r1
    d50a:	b1 1c       	adc	r11, r1
    d50c:	5f e4       	ldi	r21, 0x4F	; 79
    d50e:	c5 2e       	mov	r12, r21
    d510:	5e e0       	ldi	r21, 0x0E	; 14
    d512:	d5 2e       	mov	r13, r21
    d514:	47 e0       	ldi	r20, 0x07	; 7
    d516:	44 2e       	mov	r4, r20
    d518:	51 2c       	mov	r5, r1
    d51a:	4c 0e       	add	r4, r28
    d51c:	5d 1e       	adc	r5, r29
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    d51e:	34 e0       	ldi	r19, 0x04	; 4
    d520:	e3 2e       	mov	r14, r19
    d522:	f1 2c       	mov	r15, r1
    d524:	ec 0e       	add	r14, r28
    d526:	fd 1e       	adc	r15, r29
    d528:	2b e0       	ldi	r18, 0x0B	; 11
    d52a:	62 2e       	mov	r6, r18
    d52c:	71 2c       	mov	r7, r1
    d52e:	6c 0e       	add	r6, r28
    d530:	7d 1e       	adc	r7, r29
    d532:	8e 01       	movw	r16, r28
    d534:	01 5f       	subi	r16, 0xF1	; 241
    d536:	1f 4f       	sbci	r17, 0xFF	; 255
    d538:	91 ea       	ldi	r25, 0xA1	; 161
    d53a:	89 2e       	mov	r8, r25
    d53c:	9c e1       	ldi	r25, 0x1C	; 28
    d53e:	99 2e       	mov	r9, r25
    d540:	64 c0       	rjmp	.+200    	; 0xd60a <menu_FIP+0x190>
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    d542:	00 d0       	rcall	.+0      	; 0xd544 <menu_FIP+0xca>
    d544:	00 d0       	rcall	.+0      	; 0xd546 <menu_FIP+0xcc>
    d546:	00 d0       	rcall	.+0      	; 0xd548 <menu_FIP+0xce>
    d548:	2d b7       	in	r18, 0x3d	; 61
    d54a:	3e b7       	in	r19, 0x3e	; 62
    d54c:	2f 5f       	subi	r18, 0xFF	; 255
    d54e:	3f 4f       	sbci	r19, 0xFF	; 255
    d550:	ed b7       	in	r30, 0x3d	; 61
    d552:	fe b7       	in	r31, 0x3e	; 62
    d554:	b2 82       	std	Z+2, r11	; 0x02
    d556:	a1 82       	std	Z+1, r10	; 0x01
    d558:	f9 01       	movw	r30, r18
    d55a:	d3 82       	std	Z+3, r13	; 0x03
    d55c:	c2 82       	std	Z+2, r12	; 0x02
    d55e:	a4 0d       	add	r26, r4
    d560:	b5 1d       	adc	r27, r5
    d562:	8c 91       	ld	r24, X
    d564:	84 83       	std	Z+4, r24	; 0x04
    d566:	15 82       	std	Z+5, r1	; 0x05
    d568:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    d56c:	ad b7       	in	r26, 0x3d	; 61
    d56e:	be b7       	in	r27, 0x3e	; 62
    d570:	11 96       	adiw	r26, 0x01	; 1
    d572:	ed b7       	in	r30, 0x3d	; 61
    d574:	fe b7       	in	r31, 0x3e	; 62
    d576:	f2 82       	std	Z+2, r15	; 0x02
    d578:	e1 82       	std	Z+1, r14	; 0x01
    d57a:	13 96       	adiw	r26, 0x03	; 3
    d57c:	dc 92       	st	X, r13
    d57e:	ce 92       	st	-X, r12
    d580:	12 97       	sbiw	r26, 0x02	; 2
    d582:	e0 91 72 02 	lds	r30, 0x0272
    d586:	f0 91 73 02 	lds	r31, 0x0273
    d58a:	e6 0d       	add	r30, r6
    d58c:	f7 1d       	adc	r31, r7
    d58e:	80 81       	ld	r24, Z
    d590:	14 96       	adiw	r26, 0x04	; 4
    d592:	8c 93       	st	X, r24
    d594:	14 97       	sbiw	r26, 0x04	; 4
    d596:	15 96       	adiw	r26, 0x05	; 5
    d598:	1c 92       	st	X, r1
    d59a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    d59e:	80 91 72 02 	lds	r24, 0x0272
    d5a2:	90 91 73 02 	lds	r25, 0x0273
    d5a6:	00 d0       	rcall	.+0      	; 0xd5a8 <menu_FIP+0x12e>
    d5a8:	00 d0       	rcall	.+0      	; 0xd5aa <menu_FIP+0x130>
    d5aa:	00 d0       	rcall	.+0      	; 0xd5ac <menu_FIP+0x132>
    d5ac:	ed b7       	in	r30, 0x3d	; 61
    d5ae:	fe b7       	in	r31, 0x3e	; 62
    d5b0:	31 96       	adiw	r30, 0x01	; 1
    d5b2:	ad b7       	in	r26, 0x3d	; 61
    d5b4:	be b7       	in	r27, 0x3e	; 62
    d5b6:	12 96       	adiw	r26, 0x02	; 2
    d5b8:	1c 93       	st	X, r17
    d5ba:	0e 93       	st	-X, r16
    d5bc:	11 97       	sbiw	r26, 0x01	; 1
    d5be:	93 82       	std	Z+3, r9	; 0x03
    d5c0:	82 82       	std	Z+2, r8	; 0x02
    d5c2:	01 96       	adiw	r24, 0x01	; 1
    d5c4:	95 83       	std	Z+5, r25	; 0x05
    d5c6:	84 83       	std	Z+4, r24	; 0x04
    d5c8:	b7 82       	std	Z+7, r11	; 0x07
    d5ca:	a6 82       	std	Z+6, r10	; 0x06
    d5cc:	04 96       	adiw	r24, 0x04	; 4
    d5ce:	91 87       	std	Z+9, r25	; 0x09
    d5d0:	80 87       	std	Z+8, r24	; 0x08
    d5d2:	f3 86       	std	Z+11, r15	; 0x0b
    d5d4:	e2 86       	std	Z+10, r14	; 0x0a
    d5d6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			    lcd_print((iLoop+1),1,lcdteks);
    d5da:	ed b7       	in	r30, 0x3d	; 61
    d5dc:	fe b7       	in	r31, 0x3e	; 62
    d5de:	3c 96       	adiw	r30, 0x0c	; 12
    d5e0:	0f b6       	in	r0, 0x3f	; 63
    d5e2:	f8 94       	cli
    d5e4:	fe bf       	out	0x3e, r31	; 62
    d5e6:	0f be       	out	0x3f, r0	; 63
    d5e8:	ed bf       	out	0x3d, r30	; 61
    d5ea:	80 91 72 02 	lds	r24, 0x0272
    d5ee:	8f 5f       	subi	r24, 0xFF	; 255
    d5f0:	61 e0       	ldi	r22, 0x01	; 1
    d5f2:	a8 01       	movw	r20, r16
    d5f4:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    d5f8:	80 91 72 02 	lds	r24, 0x0272
    d5fc:	90 91 73 02 	lds	r25, 0x0273
    d600:	01 96       	adiw	r24, 0x01	; 1
    d602:	90 93 73 02 	sts	0x0273, r25
    d606:	80 93 72 02 	sts	0x0272, r24
    d60a:	a0 91 72 02 	lds	r26, 0x0272
    d60e:	b0 91 73 02 	lds	r27, 0x0273
    d612:	a4 30       	cpi	r26, 0x04	; 4
    d614:	b1 05       	cpc	r27, r1
    d616:	08 f4       	brcc	.+2      	; 0xd61a <menu_FIP+0x1a0>
    d618:	94 cf       	rjmp	.-216    	; 0xd542 <menu_FIP+0xc8>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    d61a:	81 e0       	ldi	r24, 0x01	; 1
    d61c:	6f e0       	ldi	r22, 0x0F	; 15
    d61e:	4b e9       	ldi	r20, 0x9B	; 155
    d620:	5c e1       	ldi	r21, 0x1C	; 28
    d622:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    d626:	82 e0       	ldi	r24, 0x02	; 2
    d628:	6f e0       	ldi	r22, 0x0F	; 15
    d62a:	45 e9       	ldi	r20, 0x95	; 149
    d62c:	5c e1       	ldi	r21, 0x1C	; 28
    d62e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    d632:	83 e0       	ldi	r24, 0x03	; 3
    d634:	6f e0       	ldi	r22, 0x0F	; 15
    d636:	4f e8       	ldi	r20, 0x8F	; 143
    d638:	5c e1       	ldi	r21, 0x1C	; 28
    d63a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    d63e:	84 e0       	ldi	r24, 0x04	; 4
    d640:	6f e0       	ldi	r22, 0x0F	; 15
    d642:	48 e8       	ldi	r20, 0x88	; 136
    d644:	5c e1       	ldi	r21, 0x1C	; 28
    d646:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		    iLoop=0;
    d64a:	10 92 73 02 	sts	0x0273, r1
    d64e:	10 92 72 02 	sts	0x0272, r1
		    stEnterFIP=efFIPInput;
    d652:	81 e0       	ldi	r24, 0x01	; 1
    d654:	7d c0       	rjmp	.+250    	; 0xd750 <menu_FIP+0x2d6>
	        break;
	   case efFIPInput:
		    iLoop++;
    d656:	80 91 72 02 	lds	r24, 0x0272
    d65a:	90 91 73 02 	lds	r25, 0x0273
    d65e:	01 96       	adiw	r24, 0x01	; 1
    d660:	90 93 73 02 	sts	0x0273, r25
    d664:	80 93 72 02 	sts	0x0272, r24
		    KeyPressed=_key_scan(1);
    d668:	81 e0       	ldi	r24, 0x01	; 1
    d66a:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    d66e:	08 2f       	mov	r16, r24
		    KeyChar=_key_btn(KeyPressed);
    d670:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    d674:	98 2f       	mov	r25, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    d676:	18 2f       	mov	r17, r24
    d678:	11 53       	subi	r17, 0x31	; 49
    d67a:	18 30       	cpi	r17, 0x08	; 8
    d67c:	60 f4       	brcc	.+24     	; 0xd696 <menu_FIP+0x21c>
		 	     if (KeyCharLast!=KeyChar){
    d67e:	80 91 4b 01 	lds	r24, 0x014B
    d682:	89 17       	cp	r24, r25
    d684:	41 f0       	breq	.+16     	; 0xd696 <menu_FIP+0x21c>
				     KeyCharLast=KeyChar;
    d686:	90 93 4b 01 	sts	0x014B, r25
				     iLoop=1000;
    d68a:	88 ee       	ldi	r24, 0xE8	; 232
    d68c:	93 e0       	ldi	r25, 0x03	; 3
    d68e:	90 93 73 02 	sts	0x0273, r25
    d692:	80 93 72 02 	sts	0x0272, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    d696:	80 91 72 02 	lds	r24, 0x0272
    d69a:	90 91 73 02 	lds	r25, 0x0273
    d69e:	60 ed       	ldi	r22, 0xD0	; 208
    d6a0:	77 e0       	ldi	r23, 0x07	; 7
    d6a2:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    d6a6:	89 2b       	or	r24, r25
    d6a8:	39 f4       	brne	.+14     	; 0xd6b8 <menu_FIP+0x23e>
		        lcd_xy(1,19);_lcd('_'); 
    d6aa:	81 e0       	ldi	r24, 0x01	; 1
    d6ac:	63 e1       	ldi	r22, 0x13	; 19
    d6ae:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
    d6b2:	8f e5       	ldi	r24, 0x5F	; 95
    d6b4:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
			   }
           if ((iLoop%2000)==1000){
    d6b8:	80 91 72 02 	lds	r24, 0x0272
    d6bc:	90 91 73 02 	lds	r25, 0x0273
    d6c0:	60 ed       	ldi	r22, 0xD0	; 208
    d6c2:	77 e0       	ldi	r23, 0x07	; 7
    d6c4:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    d6c8:	88 5e       	subi	r24, 0xE8	; 232
    d6ca:	93 40       	sbci	r25, 0x03	; 3
    d6cc:	41 f4       	brne	.+16     	; 0xd6de <menu_FIP+0x264>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    d6ce:	81 e0       	ldi	r24, 0x01	; 1
    d6d0:	63 e1       	ldi	r22, 0x13	; 19
    d6d2:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
    d6d6:	80 91 4b 01 	lds	r24, 0x014B
    d6da:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    d6de:	18 30       	cpi	r17, 0x08	; 8
    d6e0:	30 f0       	brcs	.+12     	; 0xd6ee <menu_FIP+0x274>
    d6e2:	07 3b       	cpi	r16, 0xB7	; 183
    d6e4:	91 f5       	brne	.+100    	; 0xd74a <menu_FIP+0x2d0>
    d6e6:	80 91 4b 01 	lds	r24, 0x014B
    d6ea:	80 32       	cpi	r24, 0x20	; 32
    d6ec:	b1 f1       	breq	.+108    	; 0xd75a <menu_FIP+0x2e0>
		         FIP_Used=FIP[KeyCharLast-'1'];
    d6ee:	80 91 4b 01 	lds	r24, 0x014B
    d6f2:	fe 01       	movw	r30, r28
    d6f4:	ba 97       	sbiw	r30, 0x2a	; 42
    d6f6:	e8 0f       	add	r30, r24
    d6f8:	f1 1d       	adc	r31, r1
    d6fa:	20 81       	ld	r18, Z
    d6fc:	20 93 74 02 	sts	0x0274, r18
				 if (FIP_Used<=99){
    d700:	24 36       	cpi	r18, 0x64	; 100
    d702:	f0 f4       	brcc	.+60     	; 0xd740 <menu_FIP+0x2c6>
                     //leadingZero(FIP_Used,sFIPUsed);
					 //xFIP[0]=FIP_Used;
					 *xFIP=FIP_Used;
    d704:	d7 01       	movw	r26, r14
    d706:	2c 93       	st	X, r18
					 sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
    d708:	00 d0       	rcall	.+0      	; 0xd70a <menu_FIP+0x290>
    d70a:	00 d0       	rcall	.+0      	; 0xd70c <menu_FIP+0x292>
    d70c:	00 d0       	rcall	.+0      	; 0xd70e <menu_FIP+0x294>
    d70e:	ed b7       	in	r30, 0x3d	; 61
    d710:	fe b7       	in	r31, 0x3e	; 62
    d712:	31 96       	adiw	r30, 0x01	; 1
    d714:	ad b7       	in	r26, 0x3d	; 61
    d716:	be b7       	in	r27, 0x3e	; 62
    d718:	12 96       	adiw	r26, 0x02	; 2
    d71a:	dc 92       	st	X, r13
    d71c:	ce 92       	st	-X, r12
    d71e:	11 97       	sbiw	r26, 0x01	; 1
    d720:	83 e8       	ldi	r24, 0x83	; 131
    d722:	9c e1       	ldi	r25, 0x1C	; 28
    d724:	93 83       	std	Z+3, r25	; 0x03
    d726:	82 83       	std	Z+2, r24	; 0x02
    d728:	24 83       	std	Z+4, r18	; 0x04
    d72a:	15 82       	std	Z+5, r1	; 0x05
    d72c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    d730:	ed b7       	in	r30, 0x3d	; 61
    d732:	fe b7       	in	r31, 0x3e	; 62
    d734:	36 96       	adiw	r30, 0x06	; 6
    d736:	0f b6       	in	r0, 0x3f	; 63
    d738:	f8 94       	cli
    d73a:	fe bf       	out	0x3e, r31	; 62
    d73c:	0f be       	out	0x3f, r0	; 63
    d73e:	ed bf       	out	0x3d, r30	; 61

					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    d740:	82 e0       	ldi	r24, 0x02	; 2
    d742:	80 93 75 02 	sts	0x0275, r24
    d746:	80 e0       	ldi	r24, 0x00	; 0
    d748:	09 c0       	rjmp	.+18     	; 0xd75c <menu_FIP+0x2e2>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    d74a:	07 3e       	cpi	r16, 0xE7	; 231
    d74c:	31 f4       	brne	.+12     	; 0xd75a <menu_FIP+0x2e0>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    d74e:	82 e0       	ldi	r24, 0x02	; 2
    d750:	80 93 75 02 	sts	0x0275, r24
    d754:	03 c0       	rjmp	.+6      	; 0xd75c <menu_FIP+0x2e2>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    d756:	10 92 75 02 	sts	0x0275, r1
    d75a:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    d75c:	a2 96       	adiw	r28, 0x22	; 34
    d75e:	0f b6       	in	r0, 0x3f	; 63
    d760:	f8 94       	cli
    d762:	de bf       	out	0x3e, r29	; 62
    d764:	0f be       	out	0x3f, r0	; 63
    d766:	cd bf       	out	0x3d, r28	; 61
    d768:	cf 91       	pop	r28
    d76a:	df 91       	pop	r29
    d76c:	1f 91       	pop	r17
    d76e:	0f 91       	pop	r16
    d770:	ff 90       	pop	r15
    d772:	ef 90       	pop	r14
    d774:	df 90       	pop	r13
    d776:	cf 90       	pop	r12
    d778:	bf 90       	pop	r11
    d77a:	af 90       	pop	r10
    d77c:	9f 90       	pop	r9
    d77e:	8f 90       	pop	r8
    d780:	7f 90       	pop	r7
    d782:	6f 90       	pop	r6
    d784:	5f 90       	pop	r5
    d786:	4f 90       	pop	r4
    d788:	08 95       	ret

0000d78a <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    d78a:	0f 93       	push	r16
    d78c:	1f 93       	push	r17
static char FIP_Used=0;
       char lcdteks[20],Result=MENU_NONE;
       char KeyPressed=0,KeyChar,FIPResult;

     Result=MENU_NONE;
	 switch(stEtransaction){
    d78e:	80 91 6b 02 	lds	r24, 0x026B
    d792:	85 30       	cpi	r24, 0x05	; 5
    d794:	09 f4       	brne	.+2      	; 0xd798 <FMenuEDCTransaction+0xe>
    d796:	96 c0       	rjmp	.+300    	; 0xd8c4 <FMenuEDCTransaction+0x13a>
    d798:	86 30       	cpi	r24, 0x06	; 6
    d79a:	90 f4       	brcc	.+36     	; 0xd7c0 <FMenuEDCTransaction+0x36>
    d79c:	82 30       	cpi	r24, 0x02	; 2
    d79e:	09 f4       	brne	.+2      	; 0xd7a2 <FMenuEDCTransaction+0x18>
    d7a0:	52 c0       	rjmp	.+164    	; 0xd846 <FMenuEDCTransaction+0xbc>
    d7a2:	83 30       	cpi	r24, 0x03	; 3
    d7a4:	30 f4       	brcc	.+12     	; 0xd7b2 <FMenuEDCTransaction+0x28>
    d7a6:	88 23       	and	r24, r24
    d7a8:	f1 f0       	breq	.+60     	; 0xd7e6 <FMenuEDCTransaction+0x5c>
    d7aa:	81 30       	cpi	r24, 0x01	; 1
    d7ac:	09 f0       	breq	.+2      	; 0xd7b0 <FMenuEDCTransaction+0x26>
    d7ae:	d2 c0       	rjmp	.+420    	; 0xd954 <FMenuEDCTransaction+0x1ca>
    d7b0:	36 c0       	rjmp	.+108    	; 0xd81e <FMenuEDCTransaction+0x94>
    d7b2:	83 30       	cpi	r24, 0x03	; 3
    d7b4:	09 f4       	brne	.+2      	; 0xd7b8 <FMenuEDCTransaction+0x2e>
    d7b6:	57 c0       	rjmp	.+174    	; 0xd866 <FMenuEDCTransaction+0xdc>
    d7b8:	84 30       	cpi	r24, 0x04	; 4
    d7ba:	09 f0       	breq	.+2      	; 0xd7be <FMenuEDCTransaction+0x34>
    d7bc:	cb c0       	rjmp	.+406    	; 0xd954 <FMenuEDCTransaction+0x1ca>
    d7be:	7c c0       	rjmp	.+248    	; 0xd8b8 <FMenuEDCTransaction+0x12e>
    d7c0:	88 30       	cpi	r24, 0x08	; 8
    d7c2:	09 f4       	brne	.+2      	; 0xd7c6 <FMenuEDCTransaction+0x3c>
    d7c4:	b7 c0       	rjmp	.+366    	; 0xd934 <FMenuEDCTransaction+0x1aa>
    d7c6:	89 30       	cpi	r24, 0x09	; 9
    d7c8:	38 f4       	brcc	.+14     	; 0xd7d8 <FMenuEDCTransaction+0x4e>
    d7ca:	86 30       	cpi	r24, 0x06	; 6
    d7cc:	09 f4       	brne	.+2      	; 0xd7d0 <FMenuEDCTransaction+0x46>
    d7ce:	8d c0       	rjmp	.+282    	; 0xd8ea <FMenuEDCTransaction+0x160>
    d7d0:	87 30       	cpi	r24, 0x07	; 7
    d7d2:	09 f0       	breq	.+2      	; 0xd7d6 <FMenuEDCTransaction+0x4c>
    d7d4:	bf c0       	rjmp	.+382    	; 0xd954 <FMenuEDCTransaction+0x1ca>
    d7d6:	8b c0       	rjmp	.+278    	; 0xd8ee <FMenuEDCTransaction+0x164>
    d7d8:	89 30       	cpi	r24, 0x09	; 9
    d7da:	09 f4       	brne	.+2      	; 0xd7de <FMenuEDCTransaction+0x54>
    d7dc:	b1 c0       	rjmp	.+354    	; 0xd940 <FMenuEDCTransaction+0x1b6>
    d7de:	8a 30       	cpi	r24, 0x0A	; 10
    d7e0:	09 f0       	breq	.+2      	; 0xd7e4 <FMenuEDCTransaction+0x5a>
    d7e2:	b8 c0       	rjmp	.+368    	; 0xd954 <FMenuEDCTransaction+0x1ca>
    d7e4:	b3 c0       	rjmp	.+358    	; 0xd94c <FMenuEDCTransaction+0x1c2>
	 case etInit:
	      lcd_clear();
    d7e6:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    d7ea:	81 e0       	ldi	r24, 0x01	; 1
    d7ec:	61 e0       	ldi	r22, 0x01	; 1
    d7ee:	4e e0       	ldi	r20, 0x0E	; 14
    d7f0:	5b e1       	ldi	r21, 0x1B	; 27
    d7f2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    d7f6:	81 e0       	ldi	r24, 0x01	; 1
    d7f8:	61 e0       	ldi	r22, 0x01	; 1
    d7fa:	49 ef       	ldi	r20, 0xF9	; 249
    d7fc:	5a e1       	ldi	r21, 0x1A	; 26
    d7fe:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    d802:	82 e0       	ldi	r24, 0x02	; 2
    d804:	61 e0       	ldi	r22, 0x01	; 1
    d806:	44 ee       	ldi	r20, 0xE4	; 228
    d808:	5a e1       	ldi	r21, 0x1A	; 26
    d80a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    d80e:	84 e0       	ldi	r24, 0x04	; 4
    d810:	61 e0       	ldi	r22, 0x01	; 1
    d812:	4f ec       	ldi	r20, 0xCF	; 207
    d814:	5a e1       	ldi	r21, 0x1A	; 26
    d816:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stEtransaction=etInputEDC;
    d81a:	81 e0       	ldi	r24, 0x01	; 1
    d81c:	63 c0       	rjmp	.+198    	; 0xd8e4 <FMenuEDCTransaction+0x15a>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    d81e:	81 e0       	ldi	r24, 0x01	; 1
    d820:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    d824:	08 2f       	mov	r16, r24
		  KeyChar=_key_btn(KeyPressed);
    d826:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    d82a:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    d82c:	81 53       	subi	r24, 0x31	; 49
    d82e:	82 30       	cpi	r24, 0x02	; 2
    d830:	30 f4       	brcc	.+12     	; 0xd83e <FMenuEDCTransaction+0xb4>
		       EDCType=KeyChar-'0';
    d832:	90 53       	subi	r25, 0x30	; 48
    d834:	90 93 14 08 	sts	0x0814, r25
		       stEtransaction=etSelectFIP;
    d838:	82 e0       	ldi	r24, 0x02	; 2
    d83a:	80 93 6b 02 	sts	0x026B, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    d83e:	07 3e       	cpi	r16, 0xE7	; 231
    d840:	09 f0       	breq	.+2      	; 0xd844 <FMenuEDCTransaction+0xba>
    d842:	88 c0       	rjmp	.+272    	; 0xd954 <FMenuEDCTransaction+0x1ca>
    d844:	81 c0       	rjmp	.+258    	; 0xd948 <FMenuEDCTransaction+0x1be>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    d846:	80 e0       	ldi	r24, 0x00	; 0
    d848:	90 e0       	ldi	r25, 0x00	; 0
    d84a:	62 ec       	ldi	r22, 0xC2	; 194
    d84c:	77 e0       	ldi	r23, 0x07	; 7
    d84e:	0e 94 3d 6a 	call	0xd47a	; 0xd47a <menu_FIP>
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    d852:	88 23       	and	r24, r24
    d854:	11 f4       	brne	.+4      	; 0xd85a <FMenuEDCTransaction+0xd0>
    d856:	83 e0       	ldi	r24, 0x03	; 3
    d858:	45 c0       	rjmp	.+138    	; 0xd8e4 <FMenuEDCTransaction+0x15a>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    d85a:	82 30       	cpi	r24, 0x02	; 2
    d85c:	09 f0       	breq	.+2      	; 0xd860 <FMenuEDCTransaction+0xd6>
    d85e:	7a c0       	rjmp	.+244    	; 0xd954 <FMenuEDCTransaction+0x1ca>
    d860:	10 92 6b 02 	sts	0x026B, r1
    d864:	77 c0       	rjmp	.+238    	; 0xd954 <FMenuEDCTransaction+0x1ca>
    d866:	e7 ea       	ldi	r30, 0xA7	; 167
    d868:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    d86a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    d86c:	8e e0       	ldi	r24, 0x0E	; 14
    d86e:	ec 3b       	cpi	r30, 0xBC	; 188
    d870:	f8 07       	cpc	r31, r24
    d872:	d9 f7       	brne	.-10     	; 0xd86a <FMenuEDCTransaction+0xe0>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    d874:	80 91 14 08 	lds	r24, 0x0814
    d878:	81 30       	cpi	r24, 0x01	; 1
    d87a:	19 f4       	brne	.+6      	; 0xd882 <FMenuEDCTransaction+0xf8>
		      AddSpaceLag(strRef1,20);
    d87c:	cf 01       	movw	r24, r30
    d87e:	45 97       	sbiw	r24, 0x15	; 21
    d880:	16 c0       	rjmp	.+44     	; 0xd8ae <FMenuEDCTransaction+0x124>
          }
		  else
	      if (EDCType==2){
    d882:	82 30       	cpi	r24, 0x02	; 2
    d884:	b9 f4       	brne	.+46     	; 0xd8b4 <FMenuEDCTransaction+0x12a>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    d886:	00 d0       	rcall	.+0      	; 0xd888 <FMenuEDCTransaction+0xfe>
    d888:	00 d0       	rcall	.+0      	; 0xd88a <FMenuEDCTransaction+0x100>
    d88a:	8f 01       	movw	r16, r30
    d88c:	05 51       	subi	r16, 0x15	; 21
    d88e:	10 40       	sbci	r17, 0x00	; 0
    d890:	ed b7       	in	r30, 0x3d	; 61
    d892:	fe b7       	in	r31, 0x3e	; 62
    d894:	12 83       	std	Z+2, r17	; 0x02
    d896:	01 83       	std	Z+1, r16	; 0x01
    d898:	84 ec       	ldi	r24, 0xC4	; 196
    d89a:	9a e1       	ldi	r25, 0x1A	; 26
    d89c:	94 83       	std	Z+4, r25	; 0x04
    d89e:	83 83       	std	Z+3, r24	; 0x03
    d8a0:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  AddSpaceLag(strRef1,20);
    d8a4:	0f 90       	pop	r0
    d8a6:	0f 90       	pop	r0
    d8a8:	0f 90       	pop	r0
    d8aa:	0f 90       	pop	r0
    d8ac:	c8 01       	movw	r24, r16
    d8ae:	64 e1       	ldi	r22, 0x14	; 20
    d8b0:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    d8b4:	84 e0       	ldi	r24, 0x04	; 4
    d8b6:	16 c0       	rjmp	.+44     	; 0xd8e4 <FMenuEDCTransaction+0x15a>
	      break;
     case etSendingMessage90:
          sendMessage90();
    d8b8:	0e 94 5b 50 	call	0xa0b6	; 0xa0b6 <sendMessage90>
		  TimSend=0;
    d8bc:	10 92 91 0e 	sts	0x0E91, r1
          stEtransaction=etWaitReply;
    d8c0:	85 e0       	ldi	r24, 0x05	; 5
    d8c2:	10 c0       	rjmp	.+32     	; 0xd8e4 <FMenuEDCTransaction+0x15a>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
    d8c4:	80 91 91 0e 	lds	r24, 0x0E91
    d8c8:	85 31       	cpi	r24, 0x15	; 21
    d8ca:	18 f0       	brcs	.+6      	; 0xd8d2 <FMenuEDCTransaction+0x148>
    d8cc:	88 e0       	ldi	r24, 0x08	; 8
    d8ce:	80 93 6b 02 	sts	0x026B, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    d8d2:	80 91 a9 01 	lds	r24, 0x01A9
    d8d6:	81 30       	cpi	r24, 0x01	; 1
    d8d8:	21 f0       	breq	.+8      	; 0xd8e2 <FMenuEDCTransaction+0x158>
    d8da:	80 91 a5 01 	lds	r24, 0x01A5
    d8de:	81 30       	cpi	r24, 0x01	; 1
    d8e0:	c9 f5       	brne	.+114    	; 0xd954 <FMenuEDCTransaction+0x1ca>
		       stEtransaction=etSuccesEDC;
    d8e2:	86 e0       	ldi	r24, 0x06	; 6
    d8e4:	80 93 6b 02 	sts	0x026B, r24
    d8e8:	35 c0       	rjmp	.+106    	; 0xd954 <FMenuEDCTransaction+0x1ca>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    d8ea:	87 e0       	ldi	r24, 0x07	; 7
    d8ec:	fb cf       	rjmp	.-10     	; 0xd8e4 <FMenuEDCTransaction+0x15a>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    d8ee:	80 91 a5 01 	lds	r24, 0x01A5
    d8f2:	81 30       	cpi	r24, 0x01	; 1
    d8f4:	19 f5       	brne	.+70     	; 0xd93c <FMenuEDCTransaction+0x1b2>
		      IsMessage09=False;
    d8f6:	10 92 a5 01 	sts	0x01A5, r1
	          procMessage09();
    d8fa:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <procMessage09>
		      lcd_clear();
    d8fe:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
    d902:	81 e0       	ldi	r24, 0x01	; 1
    d904:	61 e0       	ldi	r22, 0x01	; 1
    d906:	4b e9       	ldi	r20, 0x9B	; 155
    d908:	58 e0       	ldi	r21, 0x08	; 8
    d90a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
    d90e:	82 e0       	ldi	r24, 0x02	; 2
    d910:	61 e0       	ldi	r22, 0x01	; 1
    d912:	4c ea       	ldi	r20, 0xAC	; 172
    d914:	57 e0       	ldi	r21, 0x07	; 7
    d916:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
    d91a:	83 e0       	ldi	r24, 0x03	; 3
    d91c:	61 e0       	ldi	r22, 0x01	; 1
    d91e:	45 e2       	ldi	r20, 0x25	; 37
    d920:	58 e0       	ldi	r21, 0x08	; 8
    d922:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
    d926:	84 e0       	ldi	r24, 0x04	; 4
    d928:	61 e0       	ldi	r22, 0x01	; 1
    d92a:	43 ee       	ldi	r20, 0xE3	; 227
    d92c:	5d e0       	ldi	r21, 0x0D	; 13
    d92e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    d932:	02 c0       	rjmp	.+4      	; 0xd938 <FMenuEDCTransaction+0x1ae>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    d934:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  TimDisplay=0;
    d938:	10 92 94 01 	sts	0x0194, r1
		  stEtransaction=etDelayExit;
    d93c:	89 e0       	ldi	r24, 0x09	; 9
    d93e:	d2 cf       	rjmp	.-92     	; 0xd8e4 <FMenuEDCTransaction+0x15a>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    d940:	80 91 94 01 	lds	r24, 0x0194
    d944:	89 30       	cpi	r24, 0x09	; 9
    d946:	30 f0       	brcs	.+12     	; 0xd954 <FMenuEDCTransaction+0x1ca>
    d948:	8a e0       	ldi	r24, 0x0A	; 10
    d94a:	cc cf       	rjmp	.-104    	; 0xd8e4 <FMenuEDCTransaction+0x15a>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    d94c:	10 92 6b 02 	sts	0x026B, r1
    d950:	81 e0       	ldi	r24, 0x01	; 1
    d952:	01 c0       	rjmp	.+2      	; 0xd956 <FMenuEDCTransaction+0x1cc>
    d954:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    d956:	1f 91       	pop	r17
    d958:	0f 91       	pop	r16
    d95a:	08 95       	ret

0000d95c <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
    d95c:	cf 92       	push	r12
    d95e:	df 92       	push	r13
    d960:	ef 92       	push	r14
    d962:	ff 92       	push	r15
    d964:	0f 93       	push	r16
    d966:	1f 93       	push	r17
    d968:	df 93       	push	r29
    d96a:	cf 93       	push	r28
    d96c:	cd b7       	in	r28, 0x3d	; 61
    d96e:	de b7       	in	r29, 0x3e	; 62
    d970:	64 97       	sbiw	r28, 0x14	; 20
    d972:	0f b6       	in	r0, 0x3f	; 63
    d974:	f8 94       	cli
    d976:	de bf       	out	0x3e, r29	; 62
    d978:	0f be       	out	0x3f, r0	; 63
    d97a:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyPressed=0,KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
    d97c:	00 91 6e 02 	lds	r16, 0x026E
    d980:	07 30       	cpi	r16, 0x07	; 7
    d982:	09 f4       	brne	.+2      	; 0xd986 <FMenuLoyalty+0x2a>
    d984:	04 c1       	rjmp	.+520    	; 0xdb8e <FMenuLoyalty+0x232>
    d986:	08 30       	cpi	r16, 0x08	; 8
    d988:	98 f4       	brcc	.+38     	; 0xd9b0 <FMenuLoyalty+0x54>
    d98a:	03 30       	cpi	r16, 0x03	; 3
    d98c:	09 f4       	brne	.+2      	; 0xd990 <FMenuLoyalty+0x34>
    d98e:	5b c0       	rjmp	.+182    	; 0xda46 <FMenuLoyalty+0xea>
    d990:	04 30       	cpi	r16, 0x04	; 4
    d992:	38 f4       	brcc	.+14     	; 0xd9a2 <FMenuLoyalty+0x46>
    d994:	01 30       	cpi	r16, 0x01	; 1
    d996:	09 f4       	brne	.+2      	; 0xd99a <FMenuLoyalty+0x3e>
    d998:	42 c0       	rjmp	.+132    	; 0xda1e <FMenuLoyalty+0xc2>
    d99a:	02 30       	cpi	r16, 0x02	; 2
    d99c:	08 f0       	brcs	.+2      	; 0xd9a0 <FMenuLoyalty+0x44>
    d99e:	61 c0       	rjmp	.+194    	; 0xda62 <FMenuLoyalty+0x106>
    d9a0:	20 c0       	rjmp	.+64     	; 0xd9e2 <FMenuLoyalty+0x86>
    d9a2:	05 30       	cpi	r16, 0x05	; 5
    d9a4:	09 f4       	brne	.+2      	; 0xd9a8 <FMenuLoyalty+0x4c>
    d9a6:	a2 c0       	rjmp	.+324    	; 0xdaec <FMenuLoyalty+0x190>
    d9a8:	06 30       	cpi	r16, 0x06	; 6
    d9aa:	08 f0       	brcs	.+2      	; 0xd9ae <FMenuLoyalty+0x52>
    d9ac:	ba c0       	rjmp	.+372    	; 0xdb22 <FMenuLoyalty+0x1c6>
    d9ae:	8c c0       	rjmp	.+280    	; 0xdac8 <FMenuLoyalty+0x16c>
    d9b0:	0b 30       	cpi	r16, 0x0B	; 11
    d9b2:	09 f4       	brne	.+2      	; 0xd9b6 <FMenuLoyalty+0x5a>
    d9b4:	36 c1       	rjmp	.+620    	; 0xdc22 <FMenuLoyalty+0x2c6>
    d9b6:	0c 30       	cpi	r16, 0x0C	; 12
    d9b8:	38 f4       	brcc	.+14     	; 0xd9c8 <FMenuLoyalty+0x6c>
    d9ba:	09 30       	cpi	r16, 0x09	; 9
    d9bc:	09 f4       	brne	.+2      	; 0xd9c0 <FMenuLoyalty+0x64>
    d9be:	f0 c0       	rjmp	.+480    	; 0xdba0 <FMenuLoyalty+0x244>
    d9c0:	0a 30       	cpi	r16, 0x0A	; 10
    d9c2:	08 f0       	brcs	.+2      	; 0xd9c6 <FMenuLoyalty+0x6a>
    d9c4:	10 c1       	rjmp	.+544    	; 0xdbe6 <FMenuLoyalty+0x28a>
    d9c6:	e6 c0       	rjmp	.+460    	; 0xdb94 <FMenuLoyalty+0x238>
    d9c8:	0d 30       	cpi	r16, 0x0D	; 13
    d9ca:	09 f4       	brne	.+2      	; 0xd9ce <FMenuLoyalty+0x72>
    d9cc:	ee c1       	rjmp	.+988    	; 0xddaa <FMenuLoyalty+0x44e>
    d9ce:	0d 30       	cpi	r16, 0x0D	; 13
    d9d0:	08 f4       	brcc	.+2      	; 0xd9d4 <FMenuLoyalty+0x78>
    d9d2:	f5 c1       	rjmp	.+1002   	; 0xddbe <FMenuLoyalty+0x462>
    d9d4:	0e 30       	cpi	r16, 0x0E	; 14
    d9d6:	09 f4       	brne	.+2      	; 0xd9da <FMenuLoyalty+0x7e>
    d9d8:	04 c2       	rjmp	.+1032   	; 0xdde2 <FMenuLoyalty+0x486>
    d9da:	0f 30       	cpi	r16, 0x0F	; 15
    d9dc:	09 f0       	breq	.+2      	; 0xd9e0 <FMenuLoyalty+0x84>
    d9de:	0d c2       	rjmp	.+1050   	; 0xddfa <FMenuLoyalty+0x49e>
    d9e0:	06 c2       	rjmp	.+1036   	; 0xddee <FMenuLoyalty+0x492>
	 case mlInit:
	      lcd_clear();
    d9e2:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
    d9e6:	81 e0       	ldi	r24, 0x01	; 1
    d9e8:	61 e0       	ldi	r22, 0x01	; 1
    d9ea:	4b ef       	ldi	r20, 0xFB	; 251
    d9ec:	5b e1       	ldi	r21, 0x1B	; 27
    d9ee:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
    d9f2:	81 e0       	ldi	r24, 0x01	; 1
    d9f4:	61 e0       	ldi	r22, 0x01	; 1
    d9f6:	49 ee       	ldi	r20, 0xE9	; 233
    d9f8:	5b e1       	ldi	r21, 0x1B	; 27
    d9fa:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
    d9fe:	82 e0       	ldi	r24, 0x02	; 2
    da00:	61 e0       	ldi	r22, 0x01	; 1
    da02:	47 ed       	ldi	r20, 0xD7	; 215
    da04:	5b e1       	ldi	r21, 0x1B	; 27
    da06:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
    da0a:	84 e0       	ldi	r24, 0x04	; 4
    da0c:	61 e0       	ldi	r22, 0x01	; 1
    da0e:	45 ec       	ldi	r20, 0xC5	; 197
    da10:	5b e1       	ldi	r21, 0x1B	; 27
    da12:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  IsLoyaltyUpdate=False;
    da16:	10 92 6c 02 	sts	0x026C, r1
		  stLoyalty=mlLoyaltySelect;
    da1a:	81 e0       	ldi	r24, 0x01	; 1
    da1c:	08 c0       	rjmp	.+16     	; 0xda2e <FMenuLoyalty+0xd2>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
    da1e:	81 e0       	ldi	r24, 0x01	; 1
    da20:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  if (KeyPressed==_KEY_1){
    da24:	8e 3e       	cpi	r24, 0xEE	; 238
    da26:	31 f4       	brne	.+12     	; 0xda34 <FMenuLoyalty+0xd8>
		      IsLoyaltyUpdate=False;
    da28:	10 92 6c 02 	sts	0x026C, r1
		      stLoyalty=mlShowEnquiry;
    da2c:	84 e0       	ldi	r24, 0x04	; 4
    da2e:	80 93 6e 02 	sts	0x026E, r24
    da32:	e3 c1       	rjmp	.+966    	; 0xddfa <FMenuLoyalty+0x49e>
			  }
		  else
		  if (KeyPressed==_KEY_2){
    da34:	8e 3d       	cpi	r24, 0xDE	; 222
    da36:	19 f4       	brne	.+6      	; 0xda3e <FMenuLoyalty+0xe2>
		      IsLoyaltyUpdate=True;
    da38:	00 93 6c 02 	sts	0x026C, r16
    da3c:	69 c0       	rjmp	.+210    	; 0xdb10 <FMenuLoyalty+0x1b4>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
    da3e:	87 3e       	cpi	r24, 0xE7	; 231
    da40:	09 f4       	brne	.+2      	; 0xda44 <FMenuLoyalty+0xe8>
    da42:	d3 c1       	rjmp	.+934    	; 0xddea <FMenuLoyalty+0x48e>
    da44:	da c1       	rjmp	.+948    	; 0xddfa <FMenuLoyalty+0x49e>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
    da46:	8d e6       	ldi	r24, 0x6D	; 109
    da48:	92 e0       	ldi	r25, 0x02	; 2
    da4a:	62 ec       	ldi	r22, 0xC2	; 194
    da4c:	77 e0       	ldi	r23, 0x07	; 7
    da4e:	0e 94 3d 6a 	call	0xd47a	; 0xd47a <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
    da52:	88 23       	and	r24, r24
    da54:	11 f4       	brne	.+4      	; 0xda5a <FMenuLoyalty+0xfe>
    da56:	82 e0       	ldi	r24, 0x02	; 2
    da58:	ea cf       	rjmp	.-44     	; 0xda2e <FMenuLoyalty+0xd2>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
    da5a:	82 30       	cpi	r24, 0x02	; 2
    da5c:	09 f0       	breq	.+2      	; 0xda60 <FMenuLoyalty+0x104>
    da5e:	cd c1       	rjmp	.+922    	; 0xddfa <FMenuLoyalty+0x49e>
    da60:	59 c0       	rjmp	.+178    	; 0xdb14 <FMenuLoyalty+0x1b8>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
    da62:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
    da66:	00 d0       	rcall	.+0      	; 0xda68 <FMenuLoyalty+0x10c>
    da68:	00 d0       	rcall	.+0      	; 0xda6a <FMenuLoyalty+0x10e>
    da6a:	00 d0       	rcall	.+0      	; 0xda6c <FMenuLoyalty+0x110>
    da6c:	ed b7       	in	r30, 0x3d	; 61
    da6e:	fe b7       	in	r31, 0x3e	; 62
    da70:	31 96       	adiw	r30, 0x01	; 1
    da72:	8e 01       	movw	r16, r28
    da74:	0f 5f       	subi	r16, 0xFF	; 255
    da76:	1f 4f       	sbci	r17, 0xFF	; 255
    da78:	ad b7       	in	r26, 0x3d	; 61
    da7a:	be b7       	in	r27, 0x3e	; 62
    da7c:	12 96       	adiw	r26, 0x02	; 2
    da7e:	1c 93       	st	X, r17
    da80:	0e 93       	st	-X, r16
    da82:	11 97       	sbiw	r26, 0x01	; 1
    da84:	8e eb       	ldi	r24, 0xBE	; 190
    da86:	9b e1       	ldi	r25, 0x1B	; 27
    da88:	93 83       	std	Z+3, r25	; 0x03
    da8a:	82 83       	std	Z+2, r24	; 0x02
    da8c:	82 ec       	ldi	r24, 0xC2	; 194
    da8e:	97 e0       	ldi	r25, 0x07	; 7
    da90:	95 83       	std	Z+5, r25	; 0x05
    da92:	84 83       	std	Z+4, r24	; 0x04
    da94:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    da98:	8d b7       	in	r24, 0x3d	; 61
    da9a:	9e b7       	in	r25, 0x3e	; 62
    da9c:	06 96       	adiw	r24, 0x06	; 6
    da9e:	0f b6       	in	r0, 0x3f	; 63
    daa0:	f8 94       	cli
    daa2:	9e bf       	out	0x3e, r25	; 62
    daa4:	0f be       	out	0x3f, r0	; 63
    daa6:	8d bf       	out	0x3d, r24	; 61
    daa8:	81 e0       	ldi	r24, 0x01	; 1
    daaa:	61 e0       	ldi	r22, 0x01	; 1
    daac:	4f ea       	ldi	r20, 0xAF	; 175
    daae:	5b e1       	ldi	r21, 0x1B	; 27
    dab0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_print(2,1,lcdteks);
    dab4:	82 e0       	ldi	r24, 0x02	; 2
    dab6:	61 e0       	ldi	r22, 0x01	; 1
    dab8:	a8 01       	movw	r20, r16
    daba:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    dabe:	84 e0       	ldi	r24, 0x04	; 4
    dac0:	61 e0       	ldi	r22, 0x01	; 1
    dac2:	4c e9       	ldi	r20, 0x9C	; 156
    dac4:	5b e1       	ldi	r21, 0x1B	; 27
    dac6:	0c c0       	rjmp	.+24     	; 0xdae0 <FMenuLoyalty+0x184>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
    dac8:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    dacc:	81 e0       	ldi	r24, 0x01	; 1
    dace:	61 e0       	ldi	r22, 0x01	; 1
    dad0:	4d e8       	ldi	r20, 0x8D	; 141
    dad2:	5b e1       	ldi	r21, 0x1B	; 27
    dad4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    dad8:	84 e0       	ldi	r24, 0x04	; 4
    dada:	61 e0       	ldi	r22, 0x01	; 1
    dadc:	4a e7       	ldi	r20, 0x7A	; 122
    dade:	5b e1       	ldi	r21, 0x1B	; 27
    dae0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  IsRFIDDetected=False;
    dae4:	10 92 9a 01 	sts	0x019A, r1
		  stLoyalty=mlInputRFID;
    dae8:	85 e0       	ldi	r24, 0x05	; 5
    daea:	a1 cf       	rjmp	.-190    	; 0xda2e <FMenuLoyalty+0xd2>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
    daec:	80 91 9a 01 	lds	r24, 0x019A
    daf0:	81 30       	cpi	r24, 0x01	; 1
    daf2:	29 f4       	brne	.+10     	; 0xdafe <FMenuLoyalty+0x1a2>
		      IsRFIDDetected=False;
    daf4:	10 92 9a 01 	sts	0x019A, r1
		      stLoyalty=mlShowProsesRFID;
    daf8:	86 e0       	ldi	r24, 0x06	; 6
    dafa:	80 93 6e 02 	sts	0x026E, r24
		  }
	 	  KeyPressed=_key_scan(1);
    dafe:	81 e0       	ldi	r24, 0x01	; 1
    db00:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  if (KeyPressed==_KEY_CANCEL){
    db04:	87 3e       	cpi	r24, 0xE7	; 231
    db06:	49 f4       	brne	.+18     	; 0xdb1a <FMenuLoyalty+0x1be>
		      if (IsLoyaltyUpdate==True)
    db08:	80 91 6c 02 	lds	r24, 0x026C
    db0c:	81 30       	cpi	r24, 0x01	; 1
    db0e:	11 f4       	brne	.+4      	; 0xdb14 <FMenuLoyalty+0x1b8>
			       stLoyalty=mlSelectFIP;
    db10:	83 e0       	ldi	r24, 0x03	; 3
    db12:	8d cf       	rjmp	.-230    	; 0xda2e <FMenuLoyalty+0xd2>
			  else stLoyalty=mlInit;
    db14:	10 92 6e 02 	sts	0x026E, r1
    db18:	70 c1       	rjmp	.+736    	; 0xddfa <FMenuLoyalty+0x49e>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
    db1a:	87 3b       	cpi	r24, 0xB7	; 183
    db1c:	09 f0       	breq	.+2      	; 0xdb20 <FMenuLoyalty+0x1c4>
    db1e:	6d c1       	rjmp	.+730    	; 0xddfa <FMenuLoyalty+0x49e>
    db20:	64 c1       	rjmp	.+712    	; 0xddea <FMenuLoyalty+0x48e>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
    db22:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
    db26:	00 d0       	rcall	.+0      	; 0xdb28 <FMenuLoyalty+0x1cc>
    db28:	00 d0       	rcall	.+0      	; 0xdb2a <FMenuLoyalty+0x1ce>
    db2a:	00 d0       	rcall	.+0      	; 0xdb2c <FMenuLoyalty+0x1d0>
    db2c:	ed b7       	in	r30, 0x3d	; 61
    db2e:	fe b7       	in	r31, 0x3e	; 62
    db30:	31 96       	adiw	r30, 0x01	; 1
    db32:	8e 01       	movw	r16, r28
    db34:	0f 5f       	subi	r16, 0xFF	; 255
    db36:	1f 4f       	sbci	r17, 0xFF	; 255
    db38:	ad b7       	in	r26, 0x3d	; 61
    db3a:	be b7       	in	r27, 0x3e	; 62
    db3c:	12 96       	adiw	r26, 0x02	; 2
    db3e:	1c 93       	st	X, r17
    db40:	0e 93       	st	-X, r16
    db42:	11 97       	sbiw	r26, 0x01	; 1
    db44:	84 e7       	ldi	r24, 0x74	; 116
    db46:	9b e1       	ldi	r25, 0x1B	; 27
    db48:	93 83       	std	Z+3, r25	; 0x03
    db4a:	82 83       	std	Z+2, r24	; 0x02
    db4c:	86 e6       	ldi	r24, 0x66	; 102
    db4e:	9e e0       	ldi	r25, 0x0E	; 14
    db50:	95 83       	std	Z+5, r25	; 0x05
    db52:	84 83       	std	Z+4, r24	; 0x04
    db54:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
    db58:	8d b7       	in	r24, 0x3d	; 61
    db5a:	9e b7       	in	r25, 0x3e	; 62
    db5c:	06 96       	adiw	r24, 0x06	; 6
    db5e:	0f b6       	in	r0, 0x3f	; 63
    db60:	f8 94       	cli
    db62:	9e bf       	out	0x3e, r25	; 62
    db64:	0f be       	out	0x3f, r0	; 63
    db66:	8d bf       	out	0x3d, r24	; 61
    db68:	81 e0       	ldi	r24, 0x01	; 1
    db6a:	61 e0       	ldi	r22, 0x01	; 1
    db6c:	a8 01       	movw	r20, r16
    db6e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
    db72:	82 e0       	ldi	r24, 0x02	; 2
    db74:	61 e0       	ldi	r22, 0x01	; 1
    db76:	4d e6       	ldi	r20, 0x6D	; 109
    db78:	5b e1       	ldi	r21, 0x1B	; 27
    db7a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
    db7e:	80 91 6c 02 	lds	r24, 0x026C
    db82:	81 30       	cpi	r24, 0x01	; 1
    db84:	11 f4       	brne	.+4      	; 0xdb8a <FMenuLoyalty+0x22e>
    db86:	88 e0       	ldi	r24, 0x08	; 8
    db88:	52 cf       	rjmp	.-348    	; 0xda2e <FMenuLoyalty+0xd2>
		  else stLoyalty=mlSendMessage22;
    db8a:	87 e0       	ldi	r24, 0x07	; 7
    db8c:	50 cf       	rjmp	.-352    	; 0xda2e <FMenuLoyalty+0xd2>
	      break;
     case mlSendMessage22:
	      sendMessage22();
    db8e:	0e 94 73 50 	call	0xa0e6	; 0xa0e6 <sendMessage22>
    db92:	02 c0       	rjmp	.+4      	; 0xdb98 <FMenuLoyalty+0x23c>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
    db94:	0e 94 6f 50 	call	0xa0de	; 0xa0de <sendMessage24>
		  TimSend=0;		  
    db98:	10 92 91 0e 	sts	0x0E91, r1
          stLoyalty=mlWaitReply;
    db9c:	89 e0       	ldi	r24, 0x09	; 9
    db9e:	47 cf       	rjmp	.-370    	; 0xda2e <FMenuLoyalty+0xd2>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
    dba0:	80 91 91 0e 	lds	r24, 0x0E91
    dba4:	8f 31       	cpi	r24, 0x1F	; 31
    dba6:	18 f0       	brcs	.+6      	; 0xdbae <FMenuLoyalty+0x252>
		      stLoyalty=mlNoConnection;
    dba8:	8c e0       	ldi	r24, 0x0C	; 12
    dbaa:	80 93 6e 02 	sts	0x026E, r24
	      if (IsMessage23==True){
    dbae:	80 91 a4 01 	lds	r24, 0x01A4
    dbb2:	81 30       	cpi	r24, 0x01	; 1
    dbb4:	39 f4       	brne	.+14     	; 0xdbc4 <FMenuLoyalty+0x268>
		      IsMessage23=False;
    dbb6:	10 92 a4 01 	sts	0x01A4, r1
			  procMessage23();
    dbba:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <procMessage23>
			  stLoyalty=mlDispEnquiry;
    dbbe:	8b e0       	ldi	r24, 0x0B	; 11
    dbc0:	80 93 6e 02 	sts	0x026E, r24
		  }
	      if (IsMessage09==True){
    dbc4:	80 91 a5 01 	lds	r24, 0x01A5
    dbc8:	81 30       	cpi	r24, 0x01	; 1
    dbca:	39 f4       	brne	.+14     	; 0xdbda <FMenuLoyalty+0x27e>
		      IsMessage09=False;
    dbcc:	10 92 a5 01 	sts	0x01A5, r1
	          procMessage09();
    dbd0:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
    dbd4:	8a e0       	ldi	r24, 0x0A	; 10
    dbd6:	80 93 6e 02 	sts	0x026E, r24
		  }
	      if (IsMessage99==True){
    dbda:	80 91 a1 01 	lds	r24, 0x01A1
    dbde:	81 30       	cpi	r24, 0x01	; 1
    dbe0:	09 f0       	breq	.+2      	; 0xdbe4 <FMenuLoyalty+0x288>
    dbe2:	0b c1       	rjmp	.+534    	; 0xddfa <FMenuLoyalty+0x49e>
    dbe4:	1c c0       	rjmp	.+56     	; 0xdc1e <FMenuLoyalty+0x2c2>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
    dbe6:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    dbea:	81 e0       	ldi	r24, 0x01	; 1
    dbec:	61 e0       	ldi	r22, 0x01	; 1
    dbee:	4b e9       	ldi	r20, 0x9B	; 155
    dbf0:	58 e0       	ldi	r21, 0x08	; 8
    dbf2:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    dbf6:	82 e0       	ldi	r24, 0x02	; 2
    dbf8:	61 e0       	ldi	r22, 0x01	; 1
    dbfa:	4c ea       	ldi	r20, 0xAC	; 172
    dbfc:	57 e0       	ldi	r21, 0x07	; 7
    dbfe:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    dc02:	83 e0       	ldi	r24, 0x03	; 3
    dc04:	61 e0       	ldi	r22, 0x01	; 1
    dc06:	45 e2       	ldi	r20, 0x25	; 37
    dc08:	58 e0       	ldi	r21, 0x08	; 8
    dc0a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    dc0e:	84 e0       	ldi	r24, 0x04	; 4
    dc10:	61 e0       	ldi	r22, 0x01	; 1
    dc12:	43 ee       	ldi	r20, 0xE3	; 227
    dc14:	5d e0       	ldi	r21, 0x0D	; 13
    dc16:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  TimDisplay=0;
    dc1a:	10 92 94 01 	sts	0x0194, r1
		  stLoyalty=mlDelayExitLoyalty;
    dc1e:	8e e0       	ldi	r24, 0x0E	; 14
    dc20:	06 cf       	rjmp	.-500    	; 0xda2e <FMenuLoyalty+0xd2>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
    dc22:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
    dc26:	e2 e9       	ldi	r30, 0x92	; 146
    dc28:	ce 2e       	mov	r12, r30
    dc2a:	ed e0       	ldi	r30, 0x0D	; 13
    dc2c:	de 2e       	mov	r13, r30
    dc2e:	c6 01       	movw	r24, r12
    dc30:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
    dc34:	7d e2       	ldi	r23, 0x2D	; 45
    dc36:	e7 2e       	mov	r14, r23
    dc38:	73 e0       	ldi	r23, 0x03	; 3
    dc3a:	f7 2e       	mov	r15, r23
    dc3c:	c7 01       	movw	r24, r14
    dc3e:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
    dc42:	ad b7       	in	r26, 0x3d	; 61
    dc44:	be b7       	in	r27, 0x3e	; 62
    dc46:	18 97       	sbiw	r26, 0x08	; 8
    dc48:	0f b6       	in	r0, 0x3f	; 63
    dc4a:	f8 94       	cli
    dc4c:	be bf       	out	0x3e, r27	; 62
    dc4e:	0f be       	out	0x3f, r0	; 63
    dc50:	ad bf       	out	0x3d, r26	; 61
    dc52:	ed b7       	in	r30, 0x3d	; 61
    dc54:	fe b7       	in	r31, 0x3e	; 62
    dc56:	31 96       	adiw	r30, 0x01	; 1
    dc58:	8e 01       	movw	r16, r28
    dc5a:	0f 5f       	subi	r16, 0xFF	; 255
    dc5c:	1f 4f       	sbci	r17, 0xFF	; 255
    dc5e:	12 96       	adiw	r26, 0x02	; 2
    dc60:	1c 93       	st	X, r17
    dc62:	0e 93       	st	-X, r16
    dc64:	11 97       	sbiw	r26, 0x01	; 1
    dc66:	87 e6       	ldi	r24, 0x67	; 103
    dc68:	9b e1       	ldi	r25, 0x1B	; 27
    dc6a:	93 83       	std	Z+3, r25	; 0x03
    dc6c:	82 83       	std	Z+2, r24	; 0x02
    dc6e:	d5 82       	std	Z+5, r13	; 0x05
    dc70:	c4 82       	std	Z+4, r12	; 0x04
    dc72:	f7 82       	std	Z+7, r15	; 0x07
    dc74:	e6 82       	std	Z+6, r14	; 0x06
    dc76:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    dc7a:	8d b7       	in	r24, 0x3d	; 61
    dc7c:	9e b7       	in	r25, 0x3e	; 62
    dc7e:	08 96       	adiw	r24, 0x08	; 8
    dc80:	0f b6       	in	r0, 0x3f	; 63
    dc82:	f8 94       	cli
    dc84:	9e bf       	out	0x3e, r25	; 62
    dc86:	0f be       	out	0x3f, r0	; 63
    dc88:	8d bf       	out	0x3d, r24	; 61
    dc8a:	81 e0       	ldi	r24, 0x01	; 1
    dc8c:	61 e0       	ldi	r22, 0x01	; 1
    dc8e:	a8 01       	movw	r20, r16
    dc90:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    dc94:	6e e3       	ldi	r22, 0x3E	; 62
    dc96:	e6 2e       	mov	r14, r22
    dc98:	68 e0       	ldi	r22, 0x08	; 8
    dc9a:	f6 2e       	mov	r15, r22
    dc9c:	c7 01       	movw	r24, r14
    dc9e:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
    dca2:	00 d0       	rcall	.+0      	; 0xdca4 <FMenuLoyalty+0x348>
    dca4:	00 d0       	rcall	.+0      	; 0xdca6 <FMenuLoyalty+0x34a>
    dca6:	00 d0       	rcall	.+0      	; 0xdca8 <FMenuLoyalty+0x34c>
    dca8:	ed b7       	in	r30, 0x3d	; 61
    dcaa:	fe b7       	in	r31, 0x3e	; 62
    dcac:	31 96       	adiw	r30, 0x01	; 1
    dcae:	ad b7       	in	r26, 0x3d	; 61
    dcb0:	be b7       	in	r27, 0x3e	; 62
    dcb2:	12 96       	adiw	r26, 0x02	; 2
    dcb4:	1c 93       	st	X, r17
    dcb6:	0e 93       	st	-X, r16
    dcb8:	11 97       	sbiw	r26, 0x01	; 1
    dcba:	8d e5       	ldi	r24, 0x5D	; 93
    dcbc:	9b e1       	ldi	r25, 0x1B	; 27
    dcbe:	93 83       	std	Z+3, r25	; 0x03
    dcc0:	82 83       	std	Z+2, r24	; 0x02
    dcc2:	f5 82       	std	Z+5, r15	; 0x05
    dcc4:	e4 82       	std	Z+4, r14	; 0x04
    dcc6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    dcca:	8d b7       	in	r24, 0x3d	; 61
    dccc:	9e b7       	in	r25, 0x3e	; 62
    dcce:	06 96       	adiw	r24, 0x06	; 6
    dcd0:	0f b6       	in	r0, 0x3f	; 63
    dcd2:	f8 94       	cli
    dcd4:	9e bf       	out	0x3e, r25	; 62
    dcd6:	0f be       	out	0x3f, r0	; 63
    dcd8:	8d bf       	out	0x3d, r24	; 61
    dcda:	82 e0       	ldi	r24, 0x02	; 2
    dcdc:	61 e0       	ldi	r22, 0x01	; 1
    dcde:	a8 01       	movw	r20, r16
    dce0:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    dce4:	c7 01       	movw	r24, r14
    dce6:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
    dcea:	00 d0       	rcall	.+0      	; 0xdcec <FMenuLoyalty+0x390>
    dcec:	00 d0       	rcall	.+0      	; 0xdcee <FMenuLoyalty+0x392>
    dcee:	00 d0       	rcall	.+0      	; 0xdcf0 <FMenuLoyalty+0x394>
    dcf0:	ed b7       	in	r30, 0x3d	; 61
    dcf2:	fe b7       	in	r31, 0x3e	; 62
    dcf4:	31 96       	adiw	r30, 0x01	; 1
    dcf6:	ad b7       	in	r26, 0x3d	; 61
    dcf8:	be b7       	in	r27, 0x3e	; 62
    dcfa:	12 96       	adiw	r26, 0x02	; 2
    dcfc:	1c 93       	st	X, r17
    dcfe:	0e 93       	st	-X, r16
    dd00:	11 97       	sbiw	r26, 0x01	; 1
    dd02:	83 e5       	ldi	r24, 0x53	; 83
    dd04:	9b e1       	ldi	r25, 0x1B	; 27
    dd06:	93 83       	std	Z+3, r25	; 0x03
    dd08:	82 83       	std	Z+2, r24	; 0x02
    dd0a:	87 e8       	ldi	r24, 0x87	; 135
    dd0c:	93 e0       	ldi	r25, 0x03	; 3
    dd0e:	95 83       	std	Z+5, r25	; 0x05
    dd10:	84 83       	std	Z+4, r24	; 0x04
    dd12:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    dd16:	8d b7       	in	r24, 0x3d	; 61
    dd18:	9e b7       	in	r25, 0x3e	; 62
    dd1a:	06 96       	adiw	r24, 0x06	; 6
    dd1c:	0f b6       	in	r0, 0x3f	; 63
    dd1e:	f8 94       	cli
    dd20:	9e bf       	out	0x3e, r25	; 62
    dd22:	0f be       	out	0x3f, r0	; 63
    dd24:	8d bf       	out	0x3d, r24	; 61
    dd26:	83 e0       	ldi	r24, 0x03	; 3
    dd28:	61 e0       	ldi	r22, 0x01	; 1
    dd2a:	a8 01       	movw	r20, r16
    dd2c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    dd30:	c7 01       	movw	r24, r14
    dd32:	0e 94 2a 29 	call	0x5254	; 0x5254 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
    dd36:	00 d0       	rcall	.+0      	; 0xdd38 <FMenuLoyalty+0x3dc>
    dd38:	00 d0       	rcall	.+0      	; 0xdd3a <FMenuLoyalty+0x3de>
    dd3a:	00 d0       	rcall	.+0      	; 0xdd3c <FMenuLoyalty+0x3e0>
    dd3c:	ed b7       	in	r30, 0x3d	; 61
    dd3e:	fe b7       	in	r31, 0x3e	; 62
    dd40:	31 96       	adiw	r30, 0x01	; 1
    dd42:	ad b7       	in	r26, 0x3d	; 61
    dd44:	be b7       	in	r27, 0x3e	; 62
    dd46:	12 96       	adiw	r26, 0x02	; 2
    dd48:	1c 93       	st	X, r17
    dd4a:	0e 93       	st	-X, r16
    dd4c:	11 97       	sbiw	r26, 0x01	; 1
    dd4e:	89 e4       	ldi	r24, 0x49	; 73
    dd50:	9b e1       	ldi	r25, 0x1B	; 27
    dd52:	93 83       	std	Z+3, r25	; 0x03
    dd54:	82 83       	std	Z+2, r24	; 0x02
    dd56:	8a ef       	ldi	r24, 0xFA	; 250
    dd58:	9d e0       	ldi	r25, 0x0D	; 13
    dd5a:	95 83       	std	Z+5, r25	; 0x05
    dd5c:	84 83       	std	Z+4, r24	; 0x04
    dd5e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    dd62:	8d b7       	in	r24, 0x3d	; 61
    dd64:	9e b7       	in	r25, 0x3e	; 62
    dd66:	06 96       	adiw	r24, 0x06	; 6
    dd68:	0f b6       	in	r0, 0x3f	; 63
    dd6a:	f8 94       	cli
    dd6c:	9e bf       	out	0x3e, r25	; 62
    dd6e:	0f be       	out	0x3f, r0	; 63
    dd70:	8d bf       	out	0x3d, r24	; 61
    dd72:	84 e0       	ldi	r24, 0x04	; 4
    dd74:	61 e0       	ldi	r22, 0x01	; 1
    dd76:	a8 01       	movw	r20, r16
    dd78:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  TimDisplay=0;
    dd7c:	10 92 94 01 	sts	0x0194, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    dd80:	e1 99       	sbic	0x1c, 1	; 28
    dd82:	fe cf       	rjmp	.-4      	; 0xdd80 <FMenuLoyalty+0x424>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    dd84:	88 e3       	ldi	r24, 0x38	; 56
    dd86:	90 e0       	ldi	r25, 0x00	; 0
    dd88:	9f bb       	out	0x1f, r25	; 31
    dd8a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    dd8c:	e0 9a       	sbi	0x1c, 0	; 28
    dd8e:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
    dd90:	81 30       	cpi	r24, 0x01	; 1
    dd92:	09 f0       	breq	.+2      	; 0xdd96 <FMenuLoyalty+0x43a>
    dd94:	44 cf       	rjmp	.-376    	; 0xdc1e <FMenuLoyalty+0x2c2>
		      stLoyalty=mlPressAnyKey;
    dd96:	8d e0       	ldi	r24, 0x0D	; 13
    dd98:	80 93 6e 02 	sts	0x026E, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
    dd9c:	82 e0       	ldi	r24, 0x02	; 2
    dd9e:	61 e0       	ldi	r22, 0x01	; 1
    dda0:	4b e3       	ldi	r20, 0x3B	; 59
    dda2:	5b e1       	ldi	r21, 0x1B	; 27
    dda4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    dda8:	28 c0       	rjmp	.+80     	; 0xddfa <FMenuLoyalty+0x49e>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
    ddaa:	81 e0       	ldi	r24, 0x01	; 1
    ddac:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    ddb0:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
	      switch(KeyChar){		  
    ddb4:	83 32       	cpi	r24, 0x23	; 35
    ddb6:	c9 f0       	breq	.+50     	; 0xddea <FMenuLoyalty+0x48e>
    ddb8:	8a 32       	cpi	r24, 0x2A	; 42
    ddba:	f9 f4       	brne	.+62     	; 0xddfa <FMenuLoyalty+0x49e>
    ddbc:	16 c0       	rjmp	.+44     	; 0xddea <FMenuLoyalty+0x48e>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
    ddbe:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
    ddc2:	82 e0       	ldi	r24, 0x02	; 2
    ddc4:	61 e0       	ldi	r22, 0x01	; 1
    ddc6:	4d e2       	ldi	r20, 0x2D	; 45
    ddc8:	5b e1       	ldi	r21, 0x1B	; 27
    ddca:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
    ddce:	83 e0       	ldi	r24, 0x03	; 3
    ddd0:	61 e0       	ldi	r22, 0x01	; 1
    ddd2:	4f e1       	ldi	r20, 0x1F	; 31
    ddd4:	5b e1       	ldi	r21, 0x1B	; 27
    ddd6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  TimDisplay=5;
    ddda:	85 e0       	ldi	r24, 0x05	; 5
    dddc:	80 93 94 01 	sts	0x0194, r24
    dde0:	1e cf       	rjmp	.-452    	; 0xdc1e <FMenuLoyalty+0x2c2>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
    dde2:	80 91 94 01 	lds	r24, 0x0194
    dde6:	8a 30       	cpi	r24, 0x0A	; 10
    dde8:	40 f0       	brcs	.+16     	; 0xddfa <FMenuLoyalty+0x49e>
    ddea:	8f e0       	ldi	r24, 0x0F	; 15
    ddec:	20 ce       	rjmp	.-960    	; 0xda2e <FMenuLoyalty+0xd2>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
    ddee:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	      stLoyalty=mlInit;
    ddf2:	10 92 6e 02 	sts	0x026E, r1
    ddf6:	81 e0       	ldi	r24, 0x01	; 1
    ddf8:	01 c0       	rjmp	.+2      	; 0xddfc <FMenuLoyalty+0x4a0>
    ddfa:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
    ddfc:	64 96       	adiw	r28, 0x14	; 20
    ddfe:	0f b6       	in	r0, 0x3f	; 63
    de00:	f8 94       	cli
    de02:	de bf       	out	0x3e, r29	; 62
    de04:	0f be       	out	0x3f, r0	; 63
    de06:	cd bf       	out	0x3d, r28	; 61
    de08:	cf 91       	pop	r28
    de0a:	df 91       	pop	r29
    de0c:	1f 91       	pop	r17
    de0e:	0f 91       	pop	r16
    de10:	ff 90       	pop	r15
    de12:	ef 90       	pop	r14
    de14:	df 90       	pop	r13
    de16:	cf 90       	pop	r12
    de18:	08 95       	ret

0000de1a <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    de1a:	ef 92       	push	r14
    de1c:	ff 92       	push	r15
    de1e:	0f 93       	push	r16
    de20:	1f 93       	push	r17
    de22:	cf 93       	push	r28
    de24:	df 93       	push	r29
    de26:	ec 01       	movw	r28, r24
    de28:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    de2a:	08 81       	ld	r16, Y
    de2c:	00 53       	subi	r16, 0x30	; 48
    de2e:	10 e0       	ldi	r17, 0x00	; 0
    de30:	04 c0       	rjmp	.+8      	; 0xde3a <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    de32:	ce 01       	movw	r24, r28
    de34:	0e 94 69 36 	call	0x6cd2	; 0x6cd2 <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    de38:	1f 5f       	subi	r17, 0xFF	; 255
    de3a:	10 17       	cp	r17, r16
    de3c:	d0 f3       	brcs	.-12     	; 0xde32 <ValidateRestoreCode+0x18>
	 //uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    de3e:	ce 01       	movw	r24, r28
    de40:	b7 01       	movw	r22, r14
    de42:	0e 94 f3 b0 	call	0x161e6	; 0x161e6 <strcmp>
    de46:	00 97       	sbiw	r24, 0x00	; 0
    de48:	11 f0       	breq	.+4      	; 0xde4e <ValidateRestoreCode+0x34>
    de4a:	82 e0       	ldi	r24, 0x02	; 2
    de4c:	01 c0       	rjmp	.+2      	; 0xde50 <ValidateRestoreCode+0x36>
    de4e:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    de50:	df 91       	pop	r29
    de52:	cf 91       	pop	r28
    de54:	1f 91       	pop	r17
    de56:	0f 91       	pop	r16
    de58:	ff 90       	pop	r15
    de5a:	ef 90       	pop	r14
    de5c:	08 95       	ret

0000de5e <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    de5e:	ef 92       	push	r14
    de60:	ff 92       	push	r15
    de62:	0f 93       	push	r16
    de64:	1f 93       	push	r17
    de66:	df 93       	push	r29
    de68:	cf 93       	push	r28
    de6a:	cd b7       	in	r28, 0x3d	; 61
    de6c:	de b7       	in	r29, 0x3e	; 62
    de6e:	2a 97       	sbiw	r28, 0x0a	; 10
    de70:	0f b6       	in	r0, 0x3f	; 63
    de72:	f8 94       	cli
    de74:	de bf       	out	0x3e, r29	; 62
    de76:	0f be       	out	0x3f, r0	; 63
    de78:	cd bf       	out	0x3d, r28	; 61
    de7a:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    de7c:	fb 01       	movw	r30, r22
    de7e:	01 90       	ld	r0, Z+
    de80:	00 20       	and	r0, r0
    de82:	e9 f7       	brne	.-6      	; 0xde7e <ValidateGeniusCode+0x20>
    de84:	39 97       	sbiw	r30, 0x09	; 9
    de86:	e6 17       	cp	r30, r22
    de88:	f7 07       	cpc	r31, r23
    de8a:	11 f0       	breq	.+4      	; 0xde90 <ValidateGeniusCode+0x32>
    de8c:	80 e0       	ldi	r24, 0x00	; 0
    de8e:	11 c0       	rjmp	.+34     	; 0xdeb2 <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    de90:	fb 01       	movw	r30, r22
    de92:	60 81       	ld	r22, Z
    de94:	8e 01       	movw	r16, r28
    de96:	0f 5f       	subi	r16, 0xFF	; 255
    de98:	1f 4f       	sbci	r17, 0xFF	; 255
    de9a:	a8 01       	movw	r20, r16
    de9c:	0e 94 67 37 	call	0x6ece	; 0x6ece <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    dea0:	c8 01       	movw	r24, r16
    dea2:	b7 01       	movw	r22, r14
    dea4:	0e 94 f3 b0 	call	0x161e6	; 0x161e6 <strcmp>
    dea8:	00 97       	sbiw	r24, 0x00	; 0
    deaa:	11 f0       	breq	.+4      	; 0xdeb0 <ValidateGeniusCode+0x52>
    deac:	82 e0       	ldi	r24, 0x02	; 2
    deae:	01 c0       	rjmp	.+2      	; 0xdeb2 <ValidateGeniusCode+0x54>
    deb0:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    deb2:	2a 96       	adiw	r28, 0x0a	; 10
    deb4:	0f b6       	in	r0, 0x3f	; 63
    deb6:	f8 94       	cli
    deb8:	de bf       	out	0x3e, r29	; 62
    deba:	0f be       	out	0x3f, r0	; 63
    debc:	cd bf       	out	0x3d, r28	; 61
    debe:	cf 91       	pop	r28
    dec0:	df 91       	pop	r29
    dec2:	1f 91       	pop	r17
    dec4:	0f 91       	pop	r16
    dec6:	ff 90       	pop	r15
    dec8:	ef 90       	pop	r14
    deca:	08 95       	ret

0000decc <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    decc:	ff 92       	push	r15
    dece:	0f 93       	push	r16
    ded0:	1f 93       	push	r17
    ded2:	df 93       	push	r29
    ded4:	cf 93       	push	r28
    ded6:	cd b7       	in	r28, 0x3d	; 61
    ded8:	de b7       	in	r29, 0x3e	; 62
    deda:	64 97       	sbiw	r28, 0x14	; 20
    dedc:	0f b6       	in	r0, 0x3f	; 63
    dede:	f8 94       	cli
    dee0:	de bf       	out	0x3e, r29	; 62
    dee2:	0f be       	out	0x3f, r0	; 63
    dee4:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    dee6:	10 92 37 02 	sts	0x0237, r1
     switch(stClientIP){
    deea:	80 91 49 01 	lds	r24, 0x0149
    deee:	82 30       	cpi	r24, 0x02	; 2
    def0:	09 f4       	brne	.+2      	; 0xdef4 <FMenuSettingServerIP+0x28>
    def2:	7b c0       	rjmp	.+246    	; 0xdfea <FMenuSettingServerIP+0x11e>
    def4:	83 30       	cpi	r24, 0x03	; 3
    def6:	20 f4       	brcc	.+8      	; 0xdf00 <FMenuSettingServerIP+0x34>
    def8:	81 30       	cpi	r24, 0x01	; 1
    defa:	09 f0       	breq	.+2      	; 0xdefe <FMenuSettingServerIP+0x32>
    defc:	62 c2       	rjmp	.+1220   	; 0xe3c2 <FMenuSettingServerIP+0x4f6>
    defe:	07 c0       	rjmp	.+14     	; 0xdf0e <FMenuSettingServerIP+0x42>
    df00:	83 30       	cpi	r24, 0x03	; 3
    df02:	09 f4       	brne	.+2      	; 0xdf06 <FMenuSettingServerIP+0x3a>
    df04:	59 c2       	rjmp	.+1202   	; 0xe3b8 <FMenuSettingServerIP+0x4ec>
    df06:	84 30       	cpi	r24, 0x04	; 4
    df08:	09 f0       	breq	.+2      	; 0xdf0c <FMenuSettingServerIP+0x40>
    df0a:	5b c2       	rjmp	.+1206   	; 0xe3c2 <FMenuSettingServerIP+0x4f6>
    df0c:	47 c2       	rjmp	.+1166   	; 0xe39c <FMenuSettingServerIP+0x4d0>
		  case cipInit:
			   lcd_clear();
    df0e:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    df12:	81 e0       	ldi	r24, 0x01	; 1
    df14:	61 e0       	ldi	r22, 0x01	; 1
    df16:	47 e0       	ldi	r20, 0x07	; 7
    df18:	54 e1       	ldi	r21, 0x14	; 20
    df1a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    df1e:	80 e3       	ldi	r24, 0x30	; 48
    df20:	92 e0       	ldi	r25, 0x02	; 2
    df22:	6c e2       	ldi	r22, 0x2C	; 44
    df24:	70 e0       	ldi	r23, 0x00	; 0
    df26:	44 e0       	ldi	r20, 0x04	; 4
    df28:	50 e0       	ldi	r21, 0x00	; 0
    df2a:	22 e4       	ldi	r18, 0x42	; 66
    df2c:	33 e1       	ldi	r19, 0x13	; 19
    df2e:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    df32:	8d b7       	in	r24, 0x3d	; 61
    df34:	9e b7       	in	r25, 0x3e	; 62
    df36:	0c 97       	sbiw	r24, 0x0c	; 12
    df38:	0f b6       	in	r0, 0x3f	; 63
    df3a:	f8 94       	cli
    df3c:	9e bf       	out	0x3e, r25	; 62
    df3e:	0f be       	out	0x3f, r0	; 63
    df40:	8d bf       	out	0x3d, r24	; 61
    df42:	ed b7       	in	r30, 0x3d	; 61
    df44:	fe b7       	in	r31, 0x3e	; 62
    df46:	31 96       	adiw	r30, 0x01	; 1
    df48:	8e 01       	movw	r16, r28
    df4a:	0f 5f       	subi	r16, 0xFF	; 255
    df4c:	1f 4f       	sbci	r17, 0xFF	; 255
    df4e:	ad b7       	in	r26, 0x3d	; 61
    df50:	be b7       	in	r27, 0x3e	; 62
    df52:	12 96       	adiw	r26, 0x02	; 2
    df54:	1c 93       	st	X, r17
    df56:	0e 93       	st	-X, r16
    df58:	11 97       	sbiw	r26, 0x01	; 1
    df5a:	86 ef       	ldi	r24, 0xF6	; 246
    df5c:	93 e1       	ldi	r25, 0x13	; 19
    df5e:	93 83       	std	Z+3, r25	; 0x03
    df60:	82 83       	std	Z+2, r24	; 0x02
    df62:	80 91 30 02 	lds	r24, 0x0230
    df66:	84 83       	std	Z+4, r24	; 0x04
    df68:	15 82       	std	Z+5, r1	; 0x05
    df6a:	80 91 31 02 	lds	r24, 0x0231
    df6e:	86 83       	std	Z+6, r24	; 0x06
    df70:	17 82       	std	Z+7, r1	; 0x07
    df72:	80 91 32 02 	lds	r24, 0x0232
    df76:	80 87       	std	Z+8, r24	; 0x08
    df78:	11 86       	std	Z+9, r1	; 0x09
    df7a:	80 91 33 02 	lds	r24, 0x0233
    df7e:	82 87       	std	Z+10, r24	; 0x0a
    df80:	13 86       	std	Z+11, r1	; 0x0b
    df82:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    df86:	ed b7       	in	r30, 0x3d	; 61
    df88:	fe b7       	in	r31, 0x3e	; 62
    df8a:	3c 96       	adiw	r30, 0x0c	; 12
    df8c:	0f b6       	in	r0, 0x3f	; 63
    df8e:	f8 94       	cli
    df90:	fe bf       	out	0x3e, r31	; 62
    df92:	0f be       	out	0x3f, r0	; 63
    df94:	ed bf       	out	0x3d, r30	; 61
    df96:	82 e0       	ldi	r24, 0x02	; 2
    df98:	61 e0       	ldi	r22, 0x01	; 1
    df9a:	a8 01       	movw	r20, r16
    df9c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    dfa0:	83 e0       	ldi	r24, 0x03	; 3
    dfa2:	61 e0       	ldi	r22, 0x01	; 1
    dfa4:	41 ee       	ldi	r20, 0xE1	; 225
    dfa6:	53 e1       	ldi	r21, 0x13	; 19
    dfa8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    dfac:	84 e0       	ldi	r24, 0x04	; 4
    dfae:	61 e0       	ldi	r22, 0x01	; 1
    dfb0:	4c ec       	ldi	r20, 0xCC	; 204
    dfb2:	53 e1       	ldi	r21, 0x13	; 19
    dfb4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
               iLoop=0;
    dfb8:	10 92 2f 02 	sts	0x022F, r1
    dfbc:	10 92 2e 02 	sts	0x022E, r1
			   y=3,x=8;
    dfc0:	83 e0       	ldi	r24, 0x03	; 3
    dfc2:	80 93 35 02 	sts	0x0235, r24
    dfc6:	88 e0       	ldi	r24, 0x08	; 8
    dfc8:	80 93 36 02 	sts	0x0236, r24
			   iInput=0; iBlok=0;
    dfcc:	10 92 34 02 	sts	0x0234, r1
    dfd0:	10 92 2d 02 	sts	0x022D, r1
    dfd4:	10 92 2c 02 	sts	0x022C, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dfd8:	80 e3       	ldi	r24, 0x30	; 48
    dfda:	80 93 39 02 	sts	0x0239, r24
    dfde:	80 93 3a 02 	sts	0x023A, r24
    dfe2:	80 93 3b 02 	sts	0x023B, r24
			   stClientIP=cipInputIP; 
    dfe6:	82 e0       	ldi	r24, 0x02	; 2
    dfe8:	e4 c1       	rjmp	.+968    	; 0xe3b2 <FMenuSettingServerIP+0x4e6>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    dfea:	80 91 2e 02 	lds	r24, 0x022E
    dfee:	90 91 2f 02 	lds	r25, 0x022F
    dff2:	01 96       	adiw	r24, 0x01	; 1
    dff4:	90 93 2f 02 	sts	0x022F, r25
    dff8:	80 93 2e 02 	sts	0x022E, r24
			   if ((iLoop%2000)==0){
    dffc:	60 ed       	ldi	r22, 0xD0	; 208
    dffe:	77 e0       	ldi	r23, 0x07	; 7
    e000:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    e004:	89 2b       	or	r24, r25
    e006:	81 f4       	brne	.+32     	; 0xe028 <FMenuSettingServerIP+0x15c>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    e008:	80 91 2c 02 	lds	r24, 0x022C
    e00c:	90 91 2d 02 	lds	r25, 0x022D
    e010:	88 0f       	add	r24, r24
    e012:	99 1f       	adc	r25, r25
    e014:	88 0f       	add	r24, r24
    e016:	99 1f       	adc	r25, r25
    e018:	60 91 36 02 	lds	r22, 0x0236
    e01c:	68 0f       	add	r22, r24
    e01e:	80 91 35 02 	lds	r24, 0x0235
    e022:	4f e5       	ldi	r20, 0x5F	; 95
    e024:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    e028:	80 91 2e 02 	lds	r24, 0x022E
    e02c:	90 91 2f 02 	lds	r25, 0x022F
    e030:	60 ed       	ldi	r22, 0xD0	; 208
    e032:	77 e0       	ldi	r23, 0x07	; 7
    e034:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    e038:	88 5e       	subi	r24, 0xE8	; 232
    e03a:	93 40       	sbci	r25, 0x03	; 3
    e03c:	81 f4       	brne	.+32     	; 0xe05e <FMenuSettingServerIP+0x192>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    e03e:	80 91 2c 02 	lds	r24, 0x022C
    e042:	90 91 2d 02 	lds	r25, 0x022D
    e046:	88 0f       	add	r24, r24
    e048:	99 1f       	adc	r25, r25
    e04a:	88 0f       	add	r24, r24
    e04c:	99 1f       	adc	r25, r25
    e04e:	60 91 36 02 	lds	r22, 0x0236
    e052:	68 0f       	add	r22, r24
    e054:	80 91 35 02 	lds	r24, 0x0235
    e058:	40 e2       	ldi	r20, 0x20	; 32
    e05a:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    e05e:	81 e0       	ldi	r24, 0x01	; 1
    e060:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    e064:	f8 2e       	mov	r15, r24
			   keyChar=_key_btn(keyPressed);
    e066:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    e06a:	28 2f       	mov	r18, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    e06c:	80 53       	subi	r24, 0x30	; 48
    e06e:	8a 30       	cpi	r24, 0x0A	; 10
    e070:	08 f0       	brcs	.+2      	; 0xe074 <FMenuSettingServerIP+0x1a8>
    e072:	d6 c0       	rjmp	.+428    	; 0xe220 <FMenuSettingServerIP+0x354>
    e074:	80 e5       	ldi	r24, 0x50	; 80
    e076:	93 ec       	ldi	r25, 0xC3	; 195
    e078:	01 97       	sbiw	r24, 0x01	; 1
    e07a:	f1 f7       	brne	.-4      	; 0xe078 <FMenuSettingServerIP+0x1ac>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    e07c:	80 91 34 02 	lds	r24, 0x0234
    e080:	e8 2f       	mov	r30, r24
    e082:	f0 e0       	ldi	r31, 0x00	; 0
    e084:	e7 5c       	subi	r30, 0xC7	; 199
    e086:	fd 4f       	sbci	r31, 0xFD	; 253
    e088:	20 83       	st	Z, r18
				   iInput++;                    
    e08a:	8f 5f       	subi	r24, 0xFF	; 255
    e08c:	80 93 34 02 	sts	0x0234, r24
				   for (i=1;i<(iInput+1);i++){
    e090:	81 e0       	ldi	r24, 0x01	; 1
    e092:	1c c0       	rjmp	.+56     	; 0xe0cc <FMenuSettingServerIP+0x200>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    e094:	80 91 36 02 	lds	r24, 0x0236
    e098:	68 0f       	add	r22, r24
    e09a:	63 50       	subi	r22, 0x03	; 3
    e09c:	80 91 2c 02 	lds	r24, 0x022C
    e0a0:	90 91 2d 02 	lds	r25, 0x022D
    e0a4:	88 0f       	add	r24, r24
    e0a6:	99 1f       	adc	r25, r25
    e0a8:	88 0f       	add	r24, r24
    e0aa:	99 1f       	adc	r25, r25
    e0ac:	68 0f       	add	r22, r24
    e0ae:	80 91 35 02 	lds	r24, 0x0235
    e0b2:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
    e0b6:	e0 91 38 02 	lds	r30, 0x0238
    e0ba:	f0 e0       	ldi	r31, 0x00	; 0
    e0bc:	e8 5c       	subi	r30, 0xC8	; 200
    e0be:	fd 4f       	sbci	r31, 0xFD	; 253
    e0c0:	80 81       	ld	r24, Z
    e0c2:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    e0c6:	80 91 38 02 	lds	r24, 0x0238
    e0ca:	8f 5f       	subi	r24, 0xFF	; 255
    e0cc:	80 93 38 02 	sts	0x0238, r24
    e0d0:	70 91 34 02 	lds	r23, 0x0234
    e0d4:	60 91 38 02 	lds	r22, 0x0238
    e0d8:	27 2f       	mov	r18, r23
    e0da:	30 e0       	ldi	r19, 0x00	; 0
    e0dc:	86 2f       	mov	r24, r22
    e0de:	90 e0       	ldi	r25, 0x00	; 0
    e0e0:	28 17       	cp	r18, r24
    e0e2:	39 07       	cpc	r19, r25
    e0e4:	bc f6       	brge	.-82     	; 0xe094 <FMenuSettingServerIP+0x1c8>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    e0e6:	73 30       	cpi	r23, 0x03	; 3
    e0e8:	08 f4       	brcc	.+2      	; 0xe0ec <FMenuSettingServerIP+0x220>
    e0ea:	91 c0       	rjmp	.+290    	; 0xe20e <FMenuSettingServerIP+0x342>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    e0ec:	40 91 2c 02 	lds	r20, 0x022C
    e0f0:	50 91 2d 02 	lds	r21, 0x022D
    e0f4:	fa 01       	movw	r30, r20
    e0f6:	e0 5d       	subi	r30, 0xD0	; 208
    e0f8:	fd 4f       	sbci	r31, 0xFD	; 253
    e0fa:	20 91 3b 02 	lds	r18, 0x023B
    e0fe:	20 5d       	subi	r18, 0xD0	; 208
    e100:	80 91 39 02 	lds	r24, 0x0239
    e104:	34 e6       	ldi	r19, 0x64	; 100
    e106:	83 9f       	mul	r24, r19
    e108:	c0 01       	movw	r24, r0
    e10a:	11 24       	eor	r1, r1
    e10c:	28 0f       	add	r18, r24
    e10e:	80 91 3a 02 	lds	r24, 0x023A
    e112:	3a e0       	ldi	r19, 0x0A	; 10
    e114:	83 9f       	mul	r24, r19
    e116:	c0 01       	movw	r24, r0
    e118:	11 24       	eor	r1, r1
    e11a:	28 0f       	add	r18, r24
    e11c:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    e11e:	80 e3       	ldi	r24, 0x30	; 48
    e120:	80 93 39 02 	sts	0x0239, r24
    e124:	80 93 3a 02 	sts	0x023A, r24
    e128:	80 93 3b 02 	sts	0x023B, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    e12c:	44 0f       	add	r20, r20
    e12e:	55 1f       	adc	r21, r21
    e130:	44 0f       	add	r20, r20
    e132:	55 1f       	adc	r21, r21
    e134:	60 91 36 02 	lds	r22, 0x0236
    e138:	64 0f       	add	r22, r20
    e13a:	67 1b       	sub	r22, r23
    e13c:	80 91 35 02 	lds	r24, 0x0235
    e140:	48 ec       	ldi	r20, 0xC8	; 200
    e142:	53 e1       	ldi	r21, 0x13	; 19
    e144:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    e148:	00 d0       	rcall	.+0      	; 0xe14a <FMenuSettingServerIP+0x27e>
    e14a:	00 d0       	rcall	.+0      	; 0xe14c <FMenuSettingServerIP+0x280>
    e14c:	00 d0       	rcall	.+0      	; 0xe14e <FMenuSettingServerIP+0x282>
    e14e:	ad b7       	in	r26, 0x3d	; 61
    e150:	be b7       	in	r27, 0x3e	; 62
    e152:	11 96       	adiw	r26, 0x01	; 1
    e154:	8e 01       	movw	r16, r28
    e156:	0f 5f       	subi	r16, 0xFF	; 255
    e158:	1f 4f       	sbci	r17, 0xFF	; 255
    e15a:	ed b7       	in	r30, 0x3d	; 61
    e15c:	fe b7       	in	r31, 0x3e	; 62
    e15e:	12 83       	std	Z+2, r17	; 0x02
    e160:	01 83       	std	Z+1, r16	; 0x01
    e162:	85 ec       	ldi	r24, 0xC5	; 197
    e164:	93 e1       	ldi	r25, 0x13	; 19
    e166:	13 96       	adiw	r26, 0x03	; 3
    e168:	9c 93       	st	X, r25
    e16a:	8e 93       	st	-X, r24
    e16c:	12 97       	sbiw	r26, 0x02	; 2
    e16e:	e0 91 2c 02 	lds	r30, 0x022C
    e172:	f0 91 2d 02 	lds	r31, 0x022D
    e176:	e0 5d       	subi	r30, 0xD0	; 208
    e178:	fd 4f       	sbci	r31, 0xFD	; 253
    e17a:	80 81       	ld	r24, Z
    e17c:	14 96       	adiw	r26, 0x04	; 4
    e17e:	8c 93       	st	X, r24
    e180:	14 97       	sbiw	r26, 0x04	; 4
    e182:	15 96       	adiw	r26, 0x05	; 5
    e184:	1c 92       	st	X, r1
    e186:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    e18a:	f8 01       	movw	r30, r16
    e18c:	01 90       	ld	r0, Z+
    e18e:	00 20       	and	r0, r0
    e190:	e9 f7       	brne	.-6      	; 0xe18c <FMenuSettingServerIP+0x2c0>
    e192:	31 97       	sbiw	r30, 0x01	; 1
    e194:	e0 1b       	sub	r30, r16
    e196:	f1 0b       	sbc	r31, r17
    e198:	8d b7       	in	r24, 0x3d	; 61
    e19a:	9e b7       	in	r25, 0x3e	; 62
    e19c:	06 96       	adiw	r24, 0x06	; 6
    e19e:	0f b6       	in	r0, 0x3f	; 63
    e1a0:	f8 94       	cli
    e1a2:	9e bf       	out	0x3e, r25	; 62
    e1a4:	0f be       	out	0x3f, r0	; 63
    e1a6:	8d bf       	out	0x3d, r24	; 61
    e1a8:	60 91 36 02 	lds	r22, 0x0236
    e1ac:	6f 5f       	subi	r22, 0xFF	; 255
    e1ae:	80 91 2c 02 	lds	r24, 0x022C
    e1b2:	90 91 2d 02 	lds	r25, 0x022D
    e1b6:	88 0f       	add	r24, r24
    e1b8:	99 1f       	adc	r25, r25
    e1ba:	88 0f       	add	r24, r24
    e1bc:	99 1f       	adc	r25, r25
    e1be:	68 0f       	add	r22, r24
    e1c0:	6e 1b       	sub	r22, r30
    e1c2:	80 91 35 02 	lds	r24, 0x0235
    e1c6:	a8 01       	movw	r20, r16
    e1c8:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    e1cc:	80 91 2c 02 	lds	r24, 0x022C
    e1d0:	90 91 2d 02 	lds	r25, 0x022D
    e1d4:	00 97       	sbiw	r24, 0x00	; 0
    e1d6:	81 f0       	breq	.+32     	; 0xe1f8 <FMenuSettingServerIP+0x32c>
    e1d8:	60 91 36 02 	lds	r22, 0x0236
    e1dc:	6f 5f       	subi	r22, 0xFF	; 255
    e1de:	81 50       	subi	r24, 0x01	; 1
    e1e0:	90 4c       	sbci	r25, 0xC0	; 192
    e1e2:	88 0f       	add	r24, r24
    e1e4:	99 1f       	adc	r25, r25
    e1e6:	88 0f       	add	r24, r24
    e1e8:	99 1f       	adc	r25, r25
    e1ea:	68 0f       	add	r22, r24
    e1ec:	80 91 35 02 	lds	r24, 0x0235
    e1f0:	43 ec       	ldi	r20, 0xC3	; 195
    e1f2:	53 e1       	ldi	r21, 0x13	; 19
    e1f4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					   iInput=0;
    e1f8:	10 92 34 02 	sts	0x0234, r1
					   iBlok++;
    e1fc:	80 91 2c 02 	lds	r24, 0x022C
    e200:	90 91 2d 02 	lds	r25, 0x022D
    e204:	01 96       	adiw	r24, 0x01	; 1
    e206:	90 93 2d 02 	sts	0x022D, r25
    e20a:	80 93 2c 02 	sts	0x022C, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    e20e:	80 91 2c 02 	lds	r24, 0x022C
    e212:	90 91 2d 02 	lds	r25, 0x022D
    e216:	04 97       	sbiw	r24, 0x04	; 4
    e218:	18 f0       	brcs	.+6      	; 0xe220 <FMenuSettingServerIP+0x354>
    e21a:	84 e0       	ldi	r24, 0x04	; 4
    e21c:	80 93 49 01 	sts	0x0149, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    e220:	97 ee       	ldi	r25, 0xE7	; 231
    e222:	f9 16       	cp	r15, r25
    e224:	09 f4       	brne	.+2      	; 0xe228 <FMenuSettingServerIP+0x35c>
    e226:	c4 c0       	rjmp	.+392    	; 0xe3b0 <FMenuSettingServerIP+0x4e4>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    e228:	a7 eb       	ldi	r26, 0xB7	; 183
    e22a:	fa 16       	cp	r15, r26
    e22c:	09 f0       	breq	.+2      	; 0xe230 <FMenuSettingServerIP+0x364>
    e22e:	c9 c0       	rjmp	.+402    	; 0xe3c2 <FMenuSettingServerIP+0x4f6>
			       //NextInput
			       if (iBlok<4){
    e230:	40 91 2c 02 	lds	r20, 0x022C
    e234:	50 91 2d 02 	lds	r21, 0x022D
    e238:	44 30       	cpi	r20, 0x04	; 4
    e23a:	51 05       	cpc	r21, r1
    e23c:	08 f0       	brcs	.+2      	; 0xe240 <FMenuSettingServerIP+0x374>
    e23e:	a6 c0       	rjmp	.+332    	; 0xe38c <FMenuSettingServerIP+0x4c0>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    e240:	80 91 34 02 	lds	r24, 0x0234
    e244:	81 30       	cpi	r24, 0x01	; 1
    e246:	41 f4       	brne	.+16     	; 0xe258 <FMenuSettingServerIP+0x38c>
    e248:	fa 01       	movw	r30, r20
    e24a:	e0 5d       	subi	r30, 0xD0	; 208
    e24c:	fd 4f       	sbci	r31, 0xFD	; 253
    e24e:	80 91 39 02 	lds	r24, 0x0239
    e252:	80 53       	subi	r24, 0x30	; 48
    e254:	80 83       	st	Z, r24
    e256:	22 c0       	rjmp	.+68     	; 0xe29c <FMenuSettingServerIP+0x3d0>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    e258:	82 30       	cpi	r24, 0x02	; 2
    e25a:	49 f4       	brne	.+18     	; 0xe26e <FMenuSettingServerIP+0x3a2>
    e25c:	fa 01       	movw	r30, r20
    e25e:	e0 5d       	subi	r30, 0xD0	; 208
    e260:	fd 4f       	sbci	r31, 0xFD	; 253
    e262:	20 91 3a 02 	lds	r18, 0x023A
    e266:	20 51       	subi	r18, 0x10	; 16
    e268:	80 91 39 02 	lds	r24, 0x0239
    e26c:	11 c0       	rjmp	.+34     	; 0xe290 <FMenuSettingServerIP+0x3c4>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    e26e:	83 30       	cpi	r24, 0x03	; 3
    e270:	a9 f4       	brne	.+42     	; 0xe29c <FMenuSettingServerIP+0x3d0>
    e272:	fa 01       	movw	r30, r20
    e274:	e0 5d       	subi	r30, 0xD0	; 208
    e276:	fd 4f       	sbci	r31, 0xFD	; 253
    e278:	20 91 3b 02 	lds	r18, 0x023B
    e27c:	20 5d       	subi	r18, 0xD0	; 208
    e27e:	80 91 39 02 	lds	r24, 0x0239
    e282:	34 e6       	ldi	r19, 0x64	; 100
    e284:	83 9f       	mul	r24, r19
    e286:	c0 01       	movw	r24, r0
    e288:	11 24       	eor	r1, r1
    e28a:	28 0f       	add	r18, r24
    e28c:	80 91 3a 02 	lds	r24, 0x023A
    e290:	3a e0       	ldi	r19, 0x0A	; 10
    e292:	83 9f       	mul	r24, r19
    e294:	c0 01       	movw	r24, r0
    e296:	11 24       	eor	r1, r1
    e298:	28 0f       	add	r18, r24
    e29a:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    e29c:	80 e3       	ldi	r24, 0x30	; 48
    e29e:	80 93 39 02 	sts	0x0239, r24
    e2a2:	80 93 3a 02 	sts	0x023A, r24
    e2a6:	80 93 3b 02 	sts	0x023B, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    e2aa:	60 91 36 02 	lds	r22, 0x0236
    e2ae:	63 50       	subi	r22, 0x03	; 3
    e2b0:	44 0f       	add	r20, r20
    e2b2:	55 1f       	adc	r21, r21
    e2b4:	44 0f       	add	r20, r20
    e2b6:	55 1f       	adc	r21, r21
    e2b8:	64 0f       	add	r22, r20
    e2ba:	80 91 35 02 	lds	r24, 0x0235
    e2be:	4f eb       	ldi	r20, 0xBF	; 191
    e2c0:	53 e1       	ldi	r21, 0x13	; 19
    e2c2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    e2c6:	00 d0       	rcall	.+0      	; 0xe2c8 <FMenuSettingServerIP+0x3fc>
    e2c8:	00 d0       	rcall	.+0      	; 0xe2ca <FMenuSettingServerIP+0x3fe>
    e2ca:	00 d0       	rcall	.+0      	; 0xe2cc <FMenuSettingServerIP+0x400>
    e2cc:	ad b7       	in	r26, 0x3d	; 61
    e2ce:	be b7       	in	r27, 0x3e	; 62
    e2d0:	11 96       	adiw	r26, 0x01	; 1
    e2d2:	8e 01       	movw	r16, r28
    e2d4:	0f 5f       	subi	r16, 0xFF	; 255
    e2d6:	1f 4f       	sbci	r17, 0xFF	; 255
    e2d8:	ed b7       	in	r30, 0x3d	; 61
    e2da:	fe b7       	in	r31, 0x3e	; 62
    e2dc:	12 83       	std	Z+2, r17	; 0x02
    e2de:	01 83       	std	Z+1, r16	; 0x01
    e2e0:	8c eb       	ldi	r24, 0xBC	; 188
    e2e2:	93 e1       	ldi	r25, 0x13	; 19
    e2e4:	13 96       	adiw	r26, 0x03	; 3
    e2e6:	9c 93       	st	X, r25
    e2e8:	8e 93       	st	-X, r24
    e2ea:	12 97       	sbiw	r26, 0x02	; 2
    e2ec:	e0 91 2c 02 	lds	r30, 0x022C
    e2f0:	f0 91 2d 02 	lds	r31, 0x022D
    e2f4:	e0 5d       	subi	r30, 0xD0	; 208
    e2f6:	fd 4f       	sbci	r31, 0xFD	; 253
    e2f8:	80 81       	ld	r24, Z
    e2fa:	14 96       	adiw	r26, 0x04	; 4
    e2fc:	8c 93       	st	X, r24
    e2fe:	14 97       	sbiw	r26, 0x04	; 4
    e300:	15 96       	adiw	r26, 0x05	; 5
    e302:	1c 92       	st	X, r1
    e304:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    e308:	f8 01       	movw	r30, r16
    e30a:	01 90       	ld	r0, Z+
    e30c:	00 20       	and	r0, r0
    e30e:	e9 f7       	brne	.-6      	; 0xe30a <FMenuSettingServerIP+0x43e>
    e310:	31 97       	sbiw	r30, 0x01	; 1
    e312:	e0 1b       	sub	r30, r16
    e314:	f1 0b       	sbc	r31, r17
    e316:	8d b7       	in	r24, 0x3d	; 61
    e318:	9e b7       	in	r25, 0x3e	; 62
    e31a:	06 96       	adiw	r24, 0x06	; 6
    e31c:	0f b6       	in	r0, 0x3f	; 63
    e31e:	f8 94       	cli
    e320:	9e bf       	out	0x3e, r25	; 62
    e322:	0f be       	out	0x3f, r0	; 63
    e324:	8d bf       	out	0x3d, r24	; 61
    e326:	60 91 36 02 	lds	r22, 0x0236
    e32a:	6f 5f       	subi	r22, 0xFF	; 255
    e32c:	80 91 2c 02 	lds	r24, 0x022C
    e330:	90 91 2d 02 	lds	r25, 0x022D
    e334:	88 0f       	add	r24, r24
    e336:	99 1f       	adc	r25, r25
    e338:	88 0f       	add	r24, r24
    e33a:	99 1f       	adc	r25, r25
    e33c:	68 0f       	add	r22, r24
    e33e:	6e 1b       	sub	r22, r30
    e340:	80 91 35 02 	lds	r24, 0x0235
    e344:	a8 01       	movw	r20, r16
    e346:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    e34a:	80 91 2c 02 	lds	r24, 0x022C
    e34e:	90 91 2d 02 	lds	r25, 0x022D
    e352:	00 97       	sbiw	r24, 0x00	; 0
    e354:	81 f0       	breq	.+32     	; 0xe376 <FMenuSettingServerIP+0x4aa>
    e356:	60 91 36 02 	lds	r22, 0x0236
    e35a:	6f 5f       	subi	r22, 0xFF	; 255
    e35c:	81 50       	subi	r24, 0x01	; 1
    e35e:	90 4c       	sbci	r25, 0xC0	; 192
    e360:	88 0f       	add	r24, r24
    e362:	99 1f       	adc	r25, r25
    e364:	88 0f       	add	r24, r24
    e366:	99 1f       	adc	r25, r25
    e368:	68 0f       	add	r22, r24
    e36a:	80 91 35 02 	lds	r24, 0x0235
    e36e:	4a eb       	ldi	r20, 0xBA	; 186
    e370:	53 e1       	ldi	r21, 0x13	; 19
    e372:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				       iInput=0;
    e376:	10 92 34 02 	sts	0x0234, r1
					   iBlok++;	   
    e37a:	80 91 2c 02 	lds	r24, 0x022C
    e37e:	90 91 2d 02 	lds	r25, 0x022D
    e382:	01 96       	adiw	r24, 0x01	; 1
    e384:	90 93 2d 02 	sts	0x022D, r25
    e388:	80 93 2c 02 	sts	0x022C, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    e38c:	80 91 2c 02 	lds	r24, 0x022C
    e390:	90 91 2d 02 	lds	r25, 0x022D
    e394:	04 97       	sbiw	r24, 0x04	; 4
    e396:	a8 f0       	brcs	.+42     	; 0xe3c2 <FMenuSettingServerIP+0x4f6>
    e398:	84 e0       	ldi	r24, 0x04	; 4
    e39a:	0b c0       	rjmp	.+22     	; 0xe3b2 <FMenuSettingServerIP+0x4e6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    e39c:	8c e2       	ldi	r24, 0x2C	; 44
    e39e:	90 e0       	ldi	r25, 0x00	; 0
    e3a0:	60 e3       	ldi	r22, 0x30	; 48
    e3a2:	72 e0       	ldi	r23, 0x02	; 2
    e3a4:	44 e0       	ldi	r20, 0x04	; 4
    e3a6:	50 e0       	ldi	r21, 0x00	; 0
    e3a8:	2a e4       	ldi	r18, 0x4A	; 74
    e3aa:	33 e1       	ldi	r19, 0x13	; 19
    e3ac:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    e3b0:	83 e0       	ldi	r24, 0x03	; 3
    e3b2:	80 93 49 01 	sts	0x0149, r24
    e3b6:	05 c0       	rjmp	.+10     	; 0xe3c2 <FMenuSettingServerIP+0x4f6>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    e3b8:	81 e0       	ldi	r24, 0x01	; 1
    e3ba:	80 93 49 01 	sts	0x0149, r24
			   Result=MENU_DONE;
    e3be:	80 93 37 02 	sts	0x0237, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    e3c2:	80 91 37 02 	lds	r24, 0x0237
    e3c6:	64 96       	adiw	r28, 0x14	; 20
    e3c8:	0f b6       	in	r0, 0x3f	; 63
    e3ca:	f8 94       	cli
    e3cc:	de bf       	out	0x3e, r29	; 62
    e3ce:	0f be       	out	0x3f, r0	; 63
    e3d0:	cd bf       	out	0x3d, r28	; 61
    e3d2:	cf 91       	pop	r28
    e3d4:	df 91       	pop	r29
    e3d6:	1f 91       	pop	r17
    e3d8:	0f 91       	pop	r16
    e3da:	ff 90       	pop	r15
    e3dc:	08 95       	ret

0000e3de <FMenuSettingClientIP>:





char FMenuSettingClientIP(){
    e3de:	ff 92       	push	r15
    e3e0:	0f 93       	push	r16
    e3e2:	1f 93       	push	r17
    e3e4:	df 93       	push	r29
    e3e6:	cf 93       	push	r28
    e3e8:	cd b7       	in	r28, 0x3d	; 61
    e3ea:	de b7       	in	r29, 0x3e	; 62
    e3ec:	64 97       	sbiw	r28, 0x14	; 20
    e3ee:	0f b6       	in	r0, 0x3f	; 63
    e3f0:	f8 94       	cli
    e3f2:	de bf       	out	0x3e, r29	; 62
    e3f4:	0f be       	out	0x3f, r0	; 63
    e3f6:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    e3f8:	10 92 47 02 	sts	0x0247, r1
	 switch(stClientIP){
    e3fc:	80 91 4a 01 	lds	r24, 0x014A
    e400:	82 30       	cpi	r24, 0x02	; 2
    e402:	09 f4       	brne	.+2      	; 0xe406 <FMenuSettingClientIP+0x28>
    e404:	7b c0       	rjmp	.+246    	; 0xe4fc <FMenuSettingClientIP+0x11e>
    e406:	83 30       	cpi	r24, 0x03	; 3
    e408:	20 f4       	brcc	.+8      	; 0xe412 <FMenuSettingClientIP+0x34>
    e40a:	81 30       	cpi	r24, 0x01	; 1
    e40c:	09 f0       	breq	.+2      	; 0xe410 <FMenuSettingClientIP+0x32>
    e40e:	62 c2       	rjmp	.+1220   	; 0xe8d4 <FMenuSettingClientIP+0x4f6>
    e410:	07 c0       	rjmp	.+14     	; 0xe420 <FMenuSettingClientIP+0x42>
    e412:	83 30       	cpi	r24, 0x03	; 3
    e414:	09 f4       	brne	.+2      	; 0xe418 <FMenuSettingClientIP+0x3a>
    e416:	59 c2       	rjmp	.+1202   	; 0xe8ca <FMenuSettingClientIP+0x4ec>
    e418:	84 30       	cpi	r24, 0x04	; 4
    e41a:	09 f0       	breq	.+2      	; 0xe41e <FMenuSettingClientIP+0x40>
    e41c:	5b c2       	rjmp	.+1206   	; 0xe8d4 <FMenuSettingClientIP+0x4f6>
    e41e:	47 c2       	rjmp	.+1166   	; 0xe8ae <FMenuSettingClientIP+0x4d0>
		  case cipInit:
			   lcd_clear();
    e420:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    e424:	81 e0       	ldi	r24, 0x01	; 1
    e426:	61 e0       	ldi	r22, 0x01	; 1
    e428:	4e e5       	ldi	r20, 0x5E	; 94
    e42a:	54 e1       	ldi	r21, 0x14	; 20
    e42c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e430:	80 e4       	ldi	r24, 0x40	; 64
    e432:	92 e0       	ldi	r25, 0x02	; 2
    e434:	68 e2       	ldi	r22, 0x28	; 40
    e436:	70 e0       	ldi	r23, 0x00	; 0
    e438:	44 e0       	ldi	r20, 0x04	; 4
    e43a:	50 e0       	ldi	r21, 0x00	; 0
    e43c:	22 e4       	ldi	r18, 0x42	; 66
    e43e:	33 e1       	ldi	r19, 0x13	; 19
    e440:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    e444:	8d b7       	in	r24, 0x3d	; 61
    e446:	9e b7       	in	r25, 0x3e	; 62
    e448:	0c 97       	sbiw	r24, 0x0c	; 12
    e44a:	0f b6       	in	r0, 0x3f	; 63
    e44c:	f8 94       	cli
    e44e:	9e bf       	out	0x3e, r25	; 62
    e450:	0f be       	out	0x3f, r0	; 63
    e452:	8d bf       	out	0x3d, r24	; 61
    e454:	ed b7       	in	r30, 0x3d	; 61
    e456:	fe b7       	in	r31, 0x3e	; 62
    e458:	31 96       	adiw	r30, 0x01	; 1
    e45a:	8e 01       	movw	r16, r28
    e45c:	0f 5f       	subi	r16, 0xFF	; 255
    e45e:	1f 4f       	sbci	r17, 0xFF	; 255
    e460:	ad b7       	in	r26, 0x3d	; 61
    e462:	be b7       	in	r27, 0x3e	; 62
    e464:	12 96       	adiw	r26, 0x02	; 2
    e466:	1c 93       	st	X, r17
    e468:	0e 93       	st	-X, r16
    e46a:	11 97       	sbiw	r26, 0x01	; 1
    e46c:	8d e4       	ldi	r24, 0x4D	; 77
    e46e:	94 e1       	ldi	r25, 0x14	; 20
    e470:	93 83       	std	Z+3, r25	; 0x03
    e472:	82 83       	std	Z+2, r24	; 0x02
    e474:	80 91 40 02 	lds	r24, 0x0240
    e478:	84 83       	std	Z+4, r24	; 0x04
    e47a:	15 82       	std	Z+5, r1	; 0x05
    e47c:	80 91 41 02 	lds	r24, 0x0241
    e480:	86 83       	std	Z+6, r24	; 0x06
    e482:	17 82       	std	Z+7, r1	; 0x07
    e484:	80 91 42 02 	lds	r24, 0x0242
    e488:	80 87       	std	Z+8, r24	; 0x08
    e48a:	11 86       	std	Z+9, r1	; 0x09
    e48c:	80 91 43 02 	lds	r24, 0x0243
    e490:	82 87       	std	Z+10, r24	; 0x0a
    e492:	13 86       	std	Z+11, r1	; 0x0b
    e494:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    e498:	ed b7       	in	r30, 0x3d	; 61
    e49a:	fe b7       	in	r31, 0x3e	; 62
    e49c:	3c 96       	adiw	r30, 0x0c	; 12
    e49e:	0f b6       	in	r0, 0x3f	; 63
    e4a0:	f8 94       	cli
    e4a2:	fe bf       	out	0x3e, r31	; 62
    e4a4:	0f be       	out	0x3f, r0	; 63
    e4a6:	ed bf       	out	0x3d, r30	; 61
    e4a8:	82 e0       	ldi	r24, 0x02	; 2
    e4aa:	61 e0       	ldi	r22, 0x01	; 1
    e4ac:	a8 01       	movw	r20, r16
    e4ae:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    e4b2:	83 e0       	ldi	r24, 0x03	; 3
    e4b4:	61 e0       	ldi	r22, 0x01	; 1
    e4b6:	48 e3       	ldi	r20, 0x38	; 56
    e4b8:	54 e1       	ldi	r21, 0x14	; 20
    e4ba:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    e4be:	84 e0       	ldi	r24, 0x04	; 4
    e4c0:	61 e0       	ldi	r22, 0x01	; 1
    e4c2:	43 e2       	ldi	r20, 0x23	; 35
    e4c4:	54 e1       	ldi	r21, 0x14	; 20
    e4c6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
               iLoop=0;
    e4ca:	10 92 3f 02 	sts	0x023F, r1
    e4ce:	10 92 3e 02 	sts	0x023E, r1
			   y=3,x=8;
    e4d2:	83 e0       	ldi	r24, 0x03	; 3
    e4d4:	80 93 45 02 	sts	0x0245, r24
    e4d8:	88 e0       	ldi	r24, 0x08	; 8
    e4da:	80 93 46 02 	sts	0x0246, r24
			   iInput=0; iBlok=0;
    e4de:	10 92 44 02 	sts	0x0244, r1
    e4e2:	10 92 3d 02 	sts	0x023D, r1
    e4e6:	10 92 3c 02 	sts	0x023C, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    e4ea:	80 e3       	ldi	r24, 0x30	; 48
    e4ec:	80 93 49 02 	sts	0x0249, r24
    e4f0:	80 93 4a 02 	sts	0x024A, r24
    e4f4:	80 93 4b 02 	sts	0x024B, r24
			   stClientIP=cipInputIP; 
    e4f8:	82 e0       	ldi	r24, 0x02	; 2
    e4fa:	e4 c1       	rjmp	.+968    	; 0xe8c4 <FMenuSettingClientIP+0x4e6>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    e4fc:	80 91 3e 02 	lds	r24, 0x023E
    e500:	90 91 3f 02 	lds	r25, 0x023F
    e504:	01 96       	adiw	r24, 0x01	; 1
    e506:	90 93 3f 02 	sts	0x023F, r25
    e50a:	80 93 3e 02 	sts	0x023E, r24
			   if ((iLoop%2000)==0){
    e50e:	60 ed       	ldi	r22, 0xD0	; 208
    e510:	77 e0       	ldi	r23, 0x07	; 7
    e512:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    e516:	89 2b       	or	r24, r25
    e518:	81 f4       	brne	.+32     	; 0xe53a <FMenuSettingClientIP+0x15c>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    e51a:	80 91 3c 02 	lds	r24, 0x023C
    e51e:	90 91 3d 02 	lds	r25, 0x023D
    e522:	88 0f       	add	r24, r24
    e524:	99 1f       	adc	r25, r25
    e526:	88 0f       	add	r24, r24
    e528:	99 1f       	adc	r25, r25
    e52a:	60 91 46 02 	lds	r22, 0x0246
    e52e:	68 0f       	add	r22, r24
    e530:	80 91 45 02 	lds	r24, 0x0245
    e534:	4f e5       	ldi	r20, 0x5F	; 95
    e536:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    e53a:	80 91 3e 02 	lds	r24, 0x023E
    e53e:	90 91 3f 02 	lds	r25, 0x023F
    e542:	60 ed       	ldi	r22, 0xD0	; 208
    e544:	77 e0       	ldi	r23, 0x07	; 7
    e546:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    e54a:	88 5e       	subi	r24, 0xE8	; 232
    e54c:	93 40       	sbci	r25, 0x03	; 3
    e54e:	81 f4       	brne	.+32     	; 0xe570 <FMenuSettingClientIP+0x192>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    e550:	80 91 3c 02 	lds	r24, 0x023C
    e554:	90 91 3d 02 	lds	r25, 0x023D
    e558:	88 0f       	add	r24, r24
    e55a:	99 1f       	adc	r25, r25
    e55c:	88 0f       	add	r24, r24
    e55e:	99 1f       	adc	r25, r25
    e560:	60 91 46 02 	lds	r22, 0x0246
    e564:	68 0f       	add	r22, r24
    e566:	80 91 45 02 	lds	r24, 0x0245
    e56a:	40 e2       	ldi	r20, 0x20	; 32
    e56c:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    e570:	81 e0       	ldi	r24, 0x01	; 1
    e572:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    e576:	f8 2e       	mov	r15, r24
			   keyChar=_key_btn(keyPressed);
    e578:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    e57c:	28 2f       	mov	r18, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    e57e:	80 53       	subi	r24, 0x30	; 48
    e580:	8a 30       	cpi	r24, 0x0A	; 10
    e582:	08 f0       	brcs	.+2      	; 0xe586 <FMenuSettingClientIP+0x1a8>
    e584:	d6 c0       	rjmp	.+428    	; 0xe732 <FMenuSettingClientIP+0x354>
    e586:	80 e5       	ldi	r24, 0x50	; 80
    e588:	93 ec       	ldi	r25, 0xC3	; 195
    e58a:	01 97       	sbiw	r24, 0x01	; 1
    e58c:	f1 f7       	brne	.-4      	; 0xe58a <FMenuSettingClientIP+0x1ac>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    e58e:	80 91 44 02 	lds	r24, 0x0244
    e592:	e8 2f       	mov	r30, r24
    e594:	f0 e0       	ldi	r31, 0x00	; 0
    e596:	e7 5b       	subi	r30, 0xB7	; 183
    e598:	fd 4f       	sbci	r31, 0xFD	; 253
    e59a:	20 83       	st	Z, r18
				   iInput++;                    
    e59c:	8f 5f       	subi	r24, 0xFF	; 255
    e59e:	80 93 44 02 	sts	0x0244, r24
				   for (i=1;i<(iInput+1);i++){
    e5a2:	81 e0       	ldi	r24, 0x01	; 1
    e5a4:	1c c0       	rjmp	.+56     	; 0xe5de <FMenuSettingClientIP+0x200>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    e5a6:	80 91 46 02 	lds	r24, 0x0246
    e5aa:	68 0f       	add	r22, r24
    e5ac:	63 50       	subi	r22, 0x03	; 3
    e5ae:	80 91 3c 02 	lds	r24, 0x023C
    e5b2:	90 91 3d 02 	lds	r25, 0x023D
    e5b6:	88 0f       	add	r24, r24
    e5b8:	99 1f       	adc	r25, r25
    e5ba:	88 0f       	add	r24, r24
    e5bc:	99 1f       	adc	r25, r25
    e5be:	68 0f       	add	r22, r24
    e5c0:	80 91 45 02 	lds	r24, 0x0245
    e5c4:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
    e5c8:	e0 91 48 02 	lds	r30, 0x0248
    e5cc:	f0 e0       	ldi	r31, 0x00	; 0
    e5ce:	e8 5b       	subi	r30, 0xB8	; 184
    e5d0:	fd 4f       	sbci	r31, 0xFD	; 253
    e5d2:	80 81       	ld	r24, Z
    e5d4:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    e5d8:	80 91 48 02 	lds	r24, 0x0248
    e5dc:	8f 5f       	subi	r24, 0xFF	; 255
    e5de:	80 93 48 02 	sts	0x0248, r24
    e5e2:	70 91 44 02 	lds	r23, 0x0244
    e5e6:	60 91 48 02 	lds	r22, 0x0248
    e5ea:	27 2f       	mov	r18, r23
    e5ec:	30 e0       	ldi	r19, 0x00	; 0
    e5ee:	86 2f       	mov	r24, r22
    e5f0:	90 e0       	ldi	r25, 0x00	; 0
    e5f2:	28 17       	cp	r18, r24
    e5f4:	39 07       	cpc	r19, r25
    e5f6:	bc f6       	brge	.-82     	; 0xe5a6 <FMenuSettingClientIP+0x1c8>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    e5f8:	73 30       	cpi	r23, 0x03	; 3
    e5fa:	08 f4       	brcc	.+2      	; 0xe5fe <FMenuSettingClientIP+0x220>
    e5fc:	91 c0       	rjmp	.+290    	; 0xe720 <FMenuSettingClientIP+0x342>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    e5fe:	40 91 3c 02 	lds	r20, 0x023C
    e602:	50 91 3d 02 	lds	r21, 0x023D
    e606:	fa 01       	movw	r30, r20
    e608:	e0 5c       	subi	r30, 0xC0	; 192
    e60a:	fd 4f       	sbci	r31, 0xFD	; 253
    e60c:	20 91 4b 02 	lds	r18, 0x024B
    e610:	20 5d       	subi	r18, 0xD0	; 208
    e612:	80 91 49 02 	lds	r24, 0x0249
    e616:	34 e6       	ldi	r19, 0x64	; 100
    e618:	83 9f       	mul	r24, r19
    e61a:	c0 01       	movw	r24, r0
    e61c:	11 24       	eor	r1, r1
    e61e:	28 0f       	add	r18, r24
    e620:	80 91 4a 02 	lds	r24, 0x024A
    e624:	3a e0       	ldi	r19, 0x0A	; 10
    e626:	83 9f       	mul	r24, r19
    e628:	c0 01       	movw	r24, r0
    e62a:	11 24       	eor	r1, r1
    e62c:	28 0f       	add	r18, r24
    e62e:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    e630:	80 e3       	ldi	r24, 0x30	; 48
    e632:	80 93 49 02 	sts	0x0249, r24
    e636:	80 93 4a 02 	sts	0x024A, r24
    e63a:	80 93 4b 02 	sts	0x024B, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    e63e:	44 0f       	add	r20, r20
    e640:	55 1f       	adc	r21, r21
    e642:	44 0f       	add	r20, r20
    e644:	55 1f       	adc	r21, r21
    e646:	60 91 46 02 	lds	r22, 0x0246
    e64a:	64 0f       	add	r22, r20
    e64c:	67 1b       	sub	r22, r23
    e64e:	80 91 45 02 	lds	r24, 0x0245
    e652:	4f e1       	ldi	r20, 0x1F	; 31
    e654:	54 e1       	ldi	r21, 0x14	; 20
    e656:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    e65a:	00 d0       	rcall	.+0      	; 0xe65c <FMenuSettingClientIP+0x27e>
    e65c:	00 d0       	rcall	.+0      	; 0xe65e <FMenuSettingClientIP+0x280>
    e65e:	00 d0       	rcall	.+0      	; 0xe660 <FMenuSettingClientIP+0x282>
    e660:	ad b7       	in	r26, 0x3d	; 61
    e662:	be b7       	in	r27, 0x3e	; 62
    e664:	11 96       	adiw	r26, 0x01	; 1
    e666:	8e 01       	movw	r16, r28
    e668:	0f 5f       	subi	r16, 0xFF	; 255
    e66a:	1f 4f       	sbci	r17, 0xFF	; 255
    e66c:	ed b7       	in	r30, 0x3d	; 61
    e66e:	fe b7       	in	r31, 0x3e	; 62
    e670:	12 83       	std	Z+2, r17	; 0x02
    e672:	01 83       	std	Z+1, r16	; 0x01
    e674:	8c e1       	ldi	r24, 0x1C	; 28
    e676:	94 e1       	ldi	r25, 0x14	; 20
    e678:	13 96       	adiw	r26, 0x03	; 3
    e67a:	9c 93       	st	X, r25
    e67c:	8e 93       	st	-X, r24
    e67e:	12 97       	sbiw	r26, 0x02	; 2
    e680:	e0 91 3c 02 	lds	r30, 0x023C
    e684:	f0 91 3d 02 	lds	r31, 0x023D
    e688:	e0 5c       	subi	r30, 0xC0	; 192
    e68a:	fd 4f       	sbci	r31, 0xFD	; 253
    e68c:	80 81       	ld	r24, Z
    e68e:	14 96       	adiw	r26, 0x04	; 4
    e690:	8c 93       	st	X, r24
    e692:	14 97       	sbiw	r26, 0x04	; 4
    e694:	15 96       	adiw	r26, 0x05	; 5
    e696:	1c 92       	st	X, r1
    e698:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    e69c:	f8 01       	movw	r30, r16
    e69e:	01 90       	ld	r0, Z+
    e6a0:	00 20       	and	r0, r0
    e6a2:	e9 f7       	brne	.-6      	; 0xe69e <FMenuSettingClientIP+0x2c0>
    e6a4:	31 97       	sbiw	r30, 0x01	; 1
    e6a6:	e0 1b       	sub	r30, r16
    e6a8:	f1 0b       	sbc	r31, r17
    e6aa:	8d b7       	in	r24, 0x3d	; 61
    e6ac:	9e b7       	in	r25, 0x3e	; 62
    e6ae:	06 96       	adiw	r24, 0x06	; 6
    e6b0:	0f b6       	in	r0, 0x3f	; 63
    e6b2:	f8 94       	cli
    e6b4:	9e bf       	out	0x3e, r25	; 62
    e6b6:	0f be       	out	0x3f, r0	; 63
    e6b8:	8d bf       	out	0x3d, r24	; 61
    e6ba:	60 91 46 02 	lds	r22, 0x0246
    e6be:	6f 5f       	subi	r22, 0xFF	; 255
    e6c0:	80 91 3c 02 	lds	r24, 0x023C
    e6c4:	90 91 3d 02 	lds	r25, 0x023D
    e6c8:	88 0f       	add	r24, r24
    e6ca:	99 1f       	adc	r25, r25
    e6cc:	88 0f       	add	r24, r24
    e6ce:	99 1f       	adc	r25, r25
    e6d0:	68 0f       	add	r22, r24
    e6d2:	6e 1b       	sub	r22, r30
    e6d4:	80 91 45 02 	lds	r24, 0x0245
    e6d8:	a8 01       	movw	r20, r16
    e6da:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    e6de:	80 91 3c 02 	lds	r24, 0x023C
    e6e2:	90 91 3d 02 	lds	r25, 0x023D
    e6e6:	00 97       	sbiw	r24, 0x00	; 0
    e6e8:	81 f0       	breq	.+32     	; 0xe70a <FMenuSettingClientIP+0x32c>
    e6ea:	60 91 46 02 	lds	r22, 0x0246
    e6ee:	6f 5f       	subi	r22, 0xFF	; 255
    e6f0:	81 50       	subi	r24, 0x01	; 1
    e6f2:	90 4c       	sbci	r25, 0xC0	; 192
    e6f4:	88 0f       	add	r24, r24
    e6f6:	99 1f       	adc	r25, r25
    e6f8:	88 0f       	add	r24, r24
    e6fa:	99 1f       	adc	r25, r25
    e6fc:	68 0f       	add	r22, r24
    e6fe:	80 91 45 02 	lds	r24, 0x0245
    e702:	4a e1       	ldi	r20, 0x1A	; 26
    e704:	54 e1       	ldi	r21, 0x14	; 20
    e706:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					   iInput=0;
    e70a:	10 92 44 02 	sts	0x0244, r1
					   iBlok++;
    e70e:	80 91 3c 02 	lds	r24, 0x023C
    e712:	90 91 3d 02 	lds	r25, 0x023D
    e716:	01 96       	adiw	r24, 0x01	; 1
    e718:	90 93 3d 02 	sts	0x023D, r25
    e71c:	80 93 3c 02 	sts	0x023C, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    e720:	80 91 3c 02 	lds	r24, 0x023C
    e724:	90 91 3d 02 	lds	r25, 0x023D
    e728:	04 97       	sbiw	r24, 0x04	; 4
    e72a:	18 f0       	brcs	.+6      	; 0xe732 <FMenuSettingClientIP+0x354>
    e72c:	84 e0       	ldi	r24, 0x04	; 4
    e72e:	80 93 4a 01 	sts	0x014A, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    e732:	97 ee       	ldi	r25, 0xE7	; 231
    e734:	f9 16       	cp	r15, r25
    e736:	09 f4       	brne	.+2      	; 0xe73a <FMenuSettingClientIP+0x35c>
    e738:	c4 c0       	rjmp	.+392    	; 0xe8c2 <FMenuSettingClientIP+0x4e4>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    e73a:	a7 eb       	ldi	r26, 0xB7	; 183
    e73c:	fa 16       	cp	r15, r26
    e73e:	09 f0       	breq	.+2      	; 0xe742 <FMenuSettingClientIP+0x364>
    e740:	c9 c0       	rjmp	.+402    	; 0xe8d4 <FMenuSettingClientIP+0x4f6>
			       //NextInput
			       if (iBlok<4){
    e742:	40 91 3c 02 	lds	r20, 0x023C
    e746:	50 91 3d 02 	lds	r21, 0x023D
    e74a:	44 30       	cpi	r20, 0x04	; 4
    e74c:	51 05       	cpc	r21, r1
    e74e:	08 f0       	brcs	.+2      	; 0xe752 <FMenuSettingClientIP+0x374>
    e750:	a6 c0       	rjmp	.+332    	; 0xe89e <FMenuSettingClientIP+0x4c0>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    e752:	80 91 44 02 	lds	r24, 0x0244
    e756:	81 30       	cpi	r24, 0x01	; 1
    e758:	41 f4       	brne	.+16     	; 0xe76a <FMenuSettingClientIP+0x38c>
    e75a:	fa 01       	movw	r30, r20
    e75c:	e0 5c       	subi	r30, 0xC0	; 192
    e75e:	fd 4f       	sbci	r31, 0xFD	; 253
    e760:	80 91 49 02 	lds	r24, 0x0249
    e764:	80 53       	subi	r24, 0x30	; 48
    e766:	80 83       	st	Z, r24
    e768:	22 c0       	rjmp	.+68     	; 0xe7ae <FMenuSettingClientIP+0x3d0>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    e76a:	82 30       	cpi	r24, 0x02	; 2
    e76c:	49 f4       	brne	.+18     	; 0xe780 <FMenuSettingClientIP+0x3a2>
    e76e:	fa 01       	movw	r30, r20
    e770:	e0 5c       	subi	r30, 0xC0	; 192
    e772:	fd 4f       	sbci	r31, 0xFD	; 253
    e774:	20 91 4a 02 	lds	r18, 0x024A
    e778:	20 51       	subi	r18, 0x10	; 16
    e77a:	80 91 49 02 	lds	r24, 0x0249
    e77e:	11 c0       	rjmp	.+34     	; 0xe7a2 <FMenuSettingClientIP+0x3c4>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    e780:	83 30       	cpi	r24, 0x03	; 3
    e782:	a9 f4       	brne	.+42     	; 0xe7ae <FMenuSettingClientIP+0x3d0>
    e784:	fa 01       	movw	r30, r20
    e786:	e0 5c       	subi	r30, 0xC0	; 192
    e788:	fd 4f       	sbci	r31, 0xFD	; 253
    e78a:	20 91 4b 02 	lds	r18, 0x024B
    e78e:	20 5d       	subi	r18, 0xD0	; 208
    e790:	80 91 49 02 	lds	r24, 0x0249
    e794:	34 e6       	ldi	r19, 0x64	; 100
    e796:	83 9f       	mul	r24, r19
    e798:	c0 01       	movw	r24, r0
    e79a:	11 24       	eor	r1, r1
    e79c:	28 0f       	add	r18, r24
    e79e:	80 91 4a 02 	lds	r24, 0x024A
    e7a2:	3a e0       	ldi	r19, 0x0A	; 10
    e7a4:	83 9f       	mul	r24, r19
    e7a6:	c0 01       	movw	r24, r0
    e7a8:	11 24       	eor	r1, r1
    e7aa:	28 0f       	add	r18, r24
    e7ac:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    e7ae:	80 e3       	ldi	r24, 0x30	; 48
    e7b0:	80 93 49 02 	sts	0x0249, r24
    e7b4:	80 93 4a 02 	sts	0x024A, r24
    e7b8:	80 93 4b 02 	sts	0x024B, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    e7bc:	60 91 46 02 	lds	r22, 0x0246
    e7c0:	63 50       	subi	r22, 0x03	; 3
    e7c2:	44 0f       	add	r20, r20
    e7c4:	55 1f       	adc	r21, r21
    e7c6:	44 0f       	add	r20, r20
    e7c8:	55 1f       	adc	r21, r21
    e7ca:	64 0f       	add	r22, r20
    e7cc:	80 91 45 02 	lds	r24, 0x0245
    e7d0:	46 e1       	ldi	r20, 0x16	; 22
    e7d2:	54 e1       	ldi	r21, 0x14	; 20
    e7d4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    e7d8:	00 d0       	rcall	.+0      	; 0xe7da <FMenuSettingClientIP+0x3fc>
    e7da:	00 d0       	rcall	.+0      	; 0xe7dc <FMenuSettingClientIP+0x3fe>
    e7dc:	00 d0       	rcall	.+0      	; 0xe7de <FMenuSettingClientIP+0x400>
    e7de:	ad b7       	in	r26, 0x3d	; 61
    e7e0:	be b7       	in	r27, 0x3e	; 62
    e7e2:	11 96       	adiw	r26, 0x01	; 1
    e7e4:	8e 01       	movw	r16, r28
    e7e6:	0f 5f       	subi	r16, 0xFF	; 255
    e7e8:	1f 4f       	sbci	r17, 0xFF	; 255
    e7ea:	ed b7       	in	r30, 0x3d	; 61
    e7ec:	fe b7       	in	r31, 0x3e	; 62
    e7ee:	12 83       	std	Z+2, r17	; 0x02
    e7f0:	01 83       	std	Z+1, r16	; 0x01
    e7f2:	83 e1       	ldi	r24, 0x13	; 19
    e7f4:	94 e1       	ldi	r25, 0x14	; 20
    e7f6:	13 96       	adiw	r26, 0x03	; 3
    e7f8:	9c 93       	st	X, r25
    e7fa:	8e 93       	st	-X, r24
    e7fc:	12 97       	sbiw	r26, 0x02	; 2
    e7fe:	e0 91 3c 02 	lds	r30, 0x023C
    e802:	f0 91 3d 02 	lds	r31, 0x023D
    e806:	e0 5c       	subi	r30, 0xC0	; 192
    e808:	fd 4f       	sbci	r31, 0xFD	; 253
    e80a:	80 81       	ld	r24, Z
    e80c:	14 96       	adiw	r26, 0x04	; 4
    e80e:	8c 93       	st	X, r24
    e810:	14 97       	sbiw	r26, 0x04	; 4
    e812:	15 96       	adiw	r26, 0x05	; 5
    e814:	1c 92       	st	X, r1
    e816:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    e81a:	f8 01       	movw	r30, r16
    e81c:	01 90       	ld	r0, Z+
    e81e:	00 20       	and	r0, r0
    e820:	e9 f7       	brne	.-6      	; 0xe81c <FMenuSettingClientIP+0x43e>
    e822:	31 97       	sbiw	r30, 0x01	; 1
    e824:	e0 1b       	sub	r30, r16
    e826:	f1 0b       	sbc	r31, r17
    e828:	8d b7       	in	r24, 0x3d	; 61
    e82a:	9e b7       	in	r25, 0x3e	; 62
    e82c:	06 96       	adiw	r24, 0x06	; 6
    e82e:	0f b6       	in	r0, 0x3f	; 63
    e830:	f8 94       	cli
    e832:	9e bf       	out	0x3e, r25	; 62
    e834:	0f be       	out	0x3f, r0	; 63
    e836:	8d bf       	out	0x3d, r24	; 61
    e838:	60 91 46 02 	lds	r22, 0x0246
    e83c:	6f 5f       	subi	r22, 0xFF	; 255
    e83e:	80 91 3c 02 	lds	r24, 0x023C
    e842:	90 91 3d 02 	lds	r25, 0x023D
    e846:	88 0f       	add	r24, r24
    e848:	99 1f       	adc	r25, r25
    e84a:	88 0f       	add	r24, r24
    e84c:	99 1f       	adc	r25, r25
    e84e:	68 0f       	add	r22, r24
    e850:	6e 1b       	sub	r22, r30
    e852:	80 91 45 02 	lds	r24, 0x0245
    e856:	a8 01       	movw	r20, r16
    e858:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    e85c:	80 91 3c 02 	lds	r24, 0x023C
    e860:	90 91 3d 02 	lds	r25, 0x023D
    e864:	00 97       	sbiw	r24, 0x00	; 0
    e866:	81 f0       	breq	.+32     	; 0xe888 <FMenuSettingClientIP+0x4aa>
    e868:	60 91 46 02 	lds	r22, 0x0246
    e86c:	6f 5f       	subi	r22, 0xFF	; 255
    e86e:	81 50       	subi	r24, 0x01	; 1
    e870:	90 4c       	sbci	r25, 0xC0	; 192
    e872:	88 0f       	add	r24, r24
    e874:	99 1f       	adc	r25, r25
    e876:	88 0f       	add	r24, r24
    e878:	99 1f       	adc	r25, r25
    e87a:	68 0f       	add	r22, r24
    e87c:	80 91 45 02 	lds	r24, 0x0245
    e880:	41 e1       	ldi	r20, 0x11	; 17
    e882:	54 e1       	ldi	r21, 0x14	; 20
    e884:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				       iInput=0;
    e888:	10 92 44 02 	sts	0x0244, r1
					   iBlok++;	   
    e88c:	80 91 3c 02 	lds	r24, 0x023C
    e890:	90 91 3d 02 	lds	r25, 0x023D
    e894:	01 96       	adiw	r24, 0x01	; 1
    e896:	90 93 3d 02 	sts	0x023D, r25
    e89a:	80 93 3c 02 	sts	0x023C, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    e89e:	80 91 3c 02 	lds	r24, 0x023C
    e8a2:	90 91 3d 02 	lds	r25, 0x023D
    e8a6:	04 97       	sbiw	r24, 0x04	; 4
    e8a8:	a8 f0       	brcs	.+42     	; 0xe8d4 <FMenuSettingClientIP+0x4f6>
    e8aa:	84 e0       	ldi	r24, 0x04	; 4
    e8ac:	0b c0       	rjmp	.+22     	; 0xe8c4 <FMenuSettingClientIP+0x4e6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    e8ae:	88 e2       	ldi	r24, 0x28	; 40
    e8b0:	90 e0       	ldi	r25, 0x00	; 0
    e8b2:	60 e4       	ldi	r22, 0x40	; 64
    e8b4:	72 e0       	ldi	r23, 0x02	; 2
    e8b6:	44 e0       	ldi	r20, 0x04	; 4
    e8b8:	50 e0       	ldi	r21, 0x00	; 0
    e8ba:	2a e4       	ldi	r18, 0x4A	; 74
    e8bc:	33 e1       	ldi	r19, 0x13	; 19
    e8be:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    e8c2:	83 e0       	ldi	r24, 0x03	; 3
    e8c4:	80 93 4a 01 	sts	0x014A, r24
    e8c8:	05 c0       	rjmp	.+10     	; 0xe8d4 <FMenuSettingClientIP+0x4f6>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    e8ca:	81 e0       	ldi	r24, 0x01	; 1
    e8cc:	80 93 4a 01 	sts	0x014A, r24
		       Result=MENU_DONE;
    e8d0:	80 93 47 02 	sts	0x0247, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    e8d4:	80 91 47 02 	lds	r24, 0x0247
    e8d8:	64 96       	adiw	r28, 0x14	; 20
    e8da:	0f b6       	in	r0, 0x3f	; 63
    e8dc:	f8 94       	cli
    e8de:	de bf       	out	0x3e, r29	; 62
    e8e0:	0f be       	out	0x3f, r0	; 63
    e8e2:	cd bf       	out	0x3d, r28	; 61
    e8e4:	cf 91       	pop	r28
    e8e6:	df 91       	pop	r29
    e8e8:	1f 91       	pop	r17
    e8ea:	0f 91       	pop	r16
    e8ec:	ff 90       	pop	r15
    e8ee:	08 95       	ret

0000e8f0 <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    e8f0:	df 93       	push	r29
    e8f2:	cf 93       	push	r28
    e8f4:	cd b7       	in	r28, 0x3d	; 61
    e8f6:	de b7       	in	r29, 0x3e	; 62
    e8f8:	28 97       	sbiw	r28, 0x08	; 8
    e8fa:	0f b6       	in	r0, 0x3f	; 63
    e8fc:	f8 94       	cli
    e8fe:	de bf       	out	0x3e, r29	; 62
    e900:	0f be       	out	0x3f, r0	; 63
    e902:	cd bf       	out	0x3d, r28	; 61
    e904:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    e906:	80 91 85 01 	lds	r24, 0x0185
    e90a:	88 23       	and	r24, r24
    e90c:	a1 f4       	brne	.+40     	; 0xe936 <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    e90e:	3d e2       	ldi	r19, 0x2D	; 45
    e910:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    e912:	80 e6       	ldi	r24, 0x60	; 96
    e914:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    e916:	2c e7       	ldi	r18, 0x7C	; 124
    e918:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    e91a:	9f e2       	ldi	r25, 0x2F	; 47
    e91c:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    e91e:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    e920:	84 ea       	ldi	r24, 0xA4	; 164
    e922:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    e924:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    e926:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    e928:	47 70       	andi	r20, 0x07	; 7
    e92a:	fe 01       	movw	r30, r28
    e92c:	e4 0f       	add	r30, r20
    e92e:	f1 1d       	adc	r31, r1
    e930:	85 2f       	mov	r24, r21
    e932:	41 81       	ldd	r20, Z+1	; 0x01
    e934:	08 c0       	rjmp	.+16     	; 0xe946 <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    e936:	80 91 85 01 	lds	r24, 0x0185
    e93a:	81 30       	cpi	r24, 0x01	; 1
    e93c:	31 f4       	brne	.+12     	; 0xe94a <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    e93e:	10 92 85 01 	sts	0x0185, r1
	          lcd_put(x,y,'X');     
    e942:	85 2f       	mov	r24, r21
    e944:	48 e5       	ldi	r20, 0x58	; 88
    e946:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			  }

}
    e94a:	28 96       	adiw	r28, 0x08	; 8
    e94c:	0f b6       	in	r0, 0x3f	; 63
    e94e:	f8 94       	cli
    e950:	de bf       	out	0x3e, r29	; 62
    e952:	0f be       	out	0x3f, r0	; 63
    e954:	cd bf       	out	0x3d, r28	; 61
    e956:	cf 91       	pop	r28
    e958:	df 91       	pop	r29
    e95a:	08 95       	ret

0000e95c <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    e95c:	0f 93       	push	r16
    e95e:	1f 93       	push	r17
    e960:	df 93       	push	r29
    e962:	cf 93       	push	r28
    e964:	cd b7       	in	r28, 0x3d	; 61
    e966:	de b7       	in	r29, 0x3e	; 62
    e968:	6a 97       	sbiw	r28, 0x1a	; 26
    e96a:	0f b6       	in	r0, 0x3f	; 63
    e96c:	f8 94       	cli
    e96e:	de bf       	out	0x3e, r29	; 62
    e970:	0f be       	out	0x3f, r0	; 63
    e972:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
	   char i,lcdteks[20];
	   char KeyChar,Addr=0,PPoolingSetting[6];
     
	 Result=MENU_NONE;
     switch(stPumpPooling){
    e974:	80 91 24 02 	lds	r24, 0x0224
    e978:	82 30       	cpi	r24, 0x02	; 2
    e97a:	09 f4       	brne	.+2      	; 0xe97e <FSettingPumpPooling+0x22>
    e97c:	1b c1       	rjmp	.+566    	; 0xebb4 <FSettingPumpPooling+0x258>
    e97e:	83 30       	cpi	r24, 0x03	; 3
    e980:	30 f4       	brcc	.+12     	; 0xe98e <FSettingPumpPooling+0x32>
    e982:	88 23       	and	r24, r24
    e984:	59 f0       	breq	.+22     	; 0xe99c <FSettingPumpPooling+0x40>
    e986:	81 30       	cpi	r24, 0x01	; 1
    e988:	09 f0       	breq	.+2      	; 0xe98c <FSettingPumpPooling+0x30>
    e98a:	17 c2       	rjmp	.+1070   	; 0xedba <FSettingPumpPooling+0x45e>
    e98c:	09 c1       	rjmp	.+530    	; 0xeba0 <FSettingPumpPooling+0x244>
    e98e:	83 30       	cpi	r24, 0x03	; 3
    e990:	09 f4       	brne	.+2      	; 0xe994 <FSettingPumpPooling+0x38>
    e992:	04 c2       	rjmp	.+1032   	; 0xed9c <FSettingPumpPooling+0x440>
    e994:	84 30       	cpi	r24, 0x04	; 4
    e996:	09 f0       	breq	.+2      	; 0xe99a <FSettingPumpPooling+0x3e>
    e998:	10 c2       	rjmp	.+1056   	; 0xedba <FSettingPumpPooling+0x45e>
    e99a:	0b c2       	rjmp	.+1046   	; 0xedb2 <FSettingPumpPooling+0x456>
	 case ppInitMenu:
          lcd_clear();
    e99c:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    e9a0:	20 e0       	ldi	r18, 0x00	; 0
    e9a2:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    e9a4:	ae 01       	movw	r20, r28
    e9a6:	4f 5f       	subi	r20, 0xFF	; 255
    e9a8:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e9aa:	e1 99       	sbic	0x1c, 1	; 28
    e9ac:	fe cf       	rjmp	.-4      	; 0xe9aa <FSettingPumpPooling+0x4e>
    e9ae:	c9 01       	movw	r24, r18
    e9b0:	8c 5b       	subi	r24, 0xBC	; 188
    e9b2:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e9b4:	9f bb       	out	0x1f, r25	; 31
    e9b6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e9b8:	e0 9a       	sbi	0x1c, 0	; 28
    e9ba:	8d b3       	in	r24, 0x1d	; 29
    e9bc:	fa 01       	movw	r30, r20
    e9be:	e2 0f       	add	r30, r18
    e9c0:	f3 1f       	adc	r31, r19
    e9c2:	80 83       	st	Z, r24
    e9c4:	2f 5f       	subi	r18, 0xFF	; 255
    e9c6:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 Result=MENU_NONE;
     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    e9c8:	26 30       	cpi	r18, 0x06	; 6
    e9ca:	31 05       	cpc	r19, r1
    e9cc:	71 f7       	brne	.-36     	; 0xe9aa <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    e9ce:	00 d0       	rcall	.+0      	; 0xe9d0 <FSettingPumpPooling+0x74>
    e9d0:	00 d0       	rcall	.+0      	; 0xe9d2 <FSettingPumpPooling+0x76>
    e9d2:	00 d0       	rcall	.+0      	; 0xe9d4 <FSettingPumpPooling+0x78>
    e9d4:	ed b7       	in	r30, 0x3d	; 61
    e9d6:	fe b7       	in	r31, 0x3e	; 62
    e9d8:	31 96       	adiw	r30, 0x01	; 1
    e9da:	8e 01       	movw	r16, r28
    e9dc:	09 5f       	subi	r16, 0xF9	; 249
    e9de:	1f 4f       	sbci	r17, 0xFF	; 255
    e9e0:	ad b7       	in	r26, 0x3d	; 61
    e9e2:	be b7       	in	r27, 0x3e	; 62
    e9e4:	12 96       	adiw	r26, 0x02	; 2
    e9e6:	1c 93       	st	X, r17
    e9e8:	0e 93       	st	-X, r16
    e9ea:	11 97       	sbiw	r26, 0x01	; 1
    e9ec:	85 e9       	ldi	r24, 0x95	; 149
    e9ee:	9e e0       	ldi	r25, 0x0E	; 14
    e9f0:	93 83       	std	Z+3, r25	; 0x03
    e9f2:	82 83       	std	Z+2, r24	; 0x02
    e9f4:	89 81       	ldd	r24, Y+1	; 0x01
    e9f6:	84 83       	std	Z+4, r24	; 0x04
    e9f8:	15 82       	std	Z+5, r1	; 0x05
    e9fa:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    e9fe:	ed b7       	in	r30, 0x3d	; 61
    ea00:	fe b7       	in	r31, 0x3e	; 62
    ea02:	36 96       	adiw	r30, 0x06	; 6
    ea04:	0f b6       	in	r0, 0x3f	; 63
    ea06:	f8 94       	cli
    ea08:	fe bf       	out	0x3e, r31	; 62
    ea0a:	0f be       	out	0x3f, r0	; 63
    ea0c:	ed bf       	out	0x3d, r30	; 61
    ea0e:	81 e0       	ldi	r24, 0x01	; 1
    ea10:	61 e0       	ldi	r22, 0x01	; 1
    ea12:	a8 01       	movw	r20, r16
    ea14:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    ea18:	00 d0       	rcall	.+0      	; 0xea1a <FSettingPumpPooling+0xbe>
    ea1a:	00 d0       	rcall	.+0      	; 0xea1c <FSettingPumpPooling+0xc0>
    ea1c:	00 d0       	rcall	.+0      	; 0xea1e <FSettingPumpPooling+0xc2>
    ea1e:	ed b7       	in	r30, 0x3d	; 61
    ea20:	fe b7       	in	r31, 0x3e	; 62
    ea22:	31 96       	adiw	r30, 0x01	; 1
    ea24:	ad b7       	in	r26, 0x3d	; 61
    ea26:	be b7       	in	r27, 0x3e	; 62
    ea28:	12 96       	adiw	r26, 0x02	; 2
    ea2a:	1c 93       	st	X, r17
    ea2c:	0e 93       	st	-X, r16
    ea2e:	11 97       	sbiw	r26, 0x01	; 1
    ea30:	88 e8       	ldi	r24, 0x88	; 136
    ea32:	9e e0       	ldi	r25, 0x0E	; 14
    ea34:	93 83       	std	Z+3, r25	; 0x03
    ea36:	82 83       	std	Z+2, r24	; 0x02
    ea38:	8a 81       	ldd	r24, Y+2	; 0x02
    ea3a:	84 83       	std	Z+4, r24	; 0x04
    ea3c:	15 82       	std	Z+5, r1	; 0x05
    ea3e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    ea42:	ed b7       	in	r30, 0x3d	; 61
    ea44:	fe b7       	in	r31, 0x3e	; 62
    ea46:	36 96       	adiw	r30, 0x06	; 6
    ea48:	0f b6       	in	r0, 0x3f	; 63
    ea4a:	f8 94       	cli
    ea4c:	fe bf       	out	0x3e, r31	; 62
    ea4e:	0f be       	out	0x3f, r0	; 63
    ea50:	ed bf       	out	0x3d, r30	; 61
    ea52:	82 e0       	ldi	r24, 0x02	; 2
    ea54:	61 e0       	ldi	r22, 0x01	; 1
    ea56:	a8 01       	movw	r20, r16
    ea58:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    ea5c:	00 d0       	rcall	.+0      	; 0xea5e <FSettingPumpPooling+0x102>
    ea5e:	00 d0       	rcall	.+0      	; 0xea60 <FSettingPumpPooling+0x104>
    ea60:	00 d0       	rcall	.+0      	; 0xea62 <FSettingPumpPooling+0x106>
    ea62:	ed b7       	in	r30, 0x3d	; 61
    ea64:	fe b7       	in	r31, 0x3e	; 62
    ea66:	31 96       	adiw	r30, 0x01	; 1
    ea68:	ad b7       	in	r26, 0x3d	; 61
    ea6a:	be b7       	in	r27, 0x3e	; 62
    ea6c:	12 96       	adiw	r26, 0x02	; 2
    ea6e:	1c 93       	st	X, r17
    ea70:	0e 93       	st	-X, r16
    ea72:	11 97       	sbiw	r26, 0x01	; 1
    ea74:	8b e7       	ldi	r24, 0x7B	; 123
    ea76:	9e e0       	ldi	r25, 0x0E	; 14
    ea78:	93 83       	std	Z+3, r25	; 0x03
    ea7a:	82 83       	std	Z+2, r24	; 0x02
    ea7c:	8b 81       	ldd	r24, Y+3	; 0x03
    ea7e:	84 83       	std	Z+4, r24	; 0x04
    ea80:	15 82       	std	Z+5, r1	; 0x05
    ea82:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    ea86:	ed b7       	in	r30, 0x3d	; 61
    ea88:	fe b7       	in	r31, 0x3e	; 62
    ea8a:	36 96       	adiw	r30, 0x06	; 6
    ea8c:	0f b6       	in	r0, 0x3f	; 63
    ea8e:	f8 94       	cli
    ea90:	fe bf       	out	0x3e, r31	; 62
    ea92:	0f be       	out	0x3f, r0	; 63
    ea94:	ed bf       	out	0x3d, r30	; 61
    ea96:	83 e0       	ldi	r24, 0x03	; 3
    ea98:	61 e0       	ldi	r22, 0x01	; 1
    ea9a:	a8 01       	movw	r20, r16
    ea9c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    eaa0:	00 d0       	rcall	.+0      	; 0xeaa2 <FSettingPumpPooling+0x146>
    eaa2:	00 d0       	rcall	.+0      	; 0xeaa4 <FSettingPumpPooling+0x148>
    eaa4:	00 d0       	rcall	.+0      	; 0xeaa6 <FSettingPumpPooling+0x14a>
    eaa6:	ed b7       	in	r30, 0x3d	; 61
    eaa8:	fe b7       	in	r31, 0x3e	; 62
    eaaa:	31 96       	adiw	r30, 0x01	; 1
    eaac:	ad b7       	in	r26, 0x3d	; 61
    eaae:	be b7       	in	r27, 0x3e	; 62
    eab0:	12 96       	adiw	r26, 0x02	; 2
    eab2:	1c 93       	st	X, r17
    eab4:	0e 93       	st	-X, r16
    eab6:	11 97       	sbiw	r26, 0x01	; 1
    eab8:	8e e6       	ldi	r24, 0x6E	; 110
    eaba:	9e e0       	ldi	r25, 0x0E	; 14
    eabc:	93 83       	std	Z+3, r25	; 0x03
    eabe:	82 83       	std	Z+2, r24	; 0x02
    eac0:	8c 81       	ldd	r24, Y+4	; 0x04
    eac2:	84 83       	std	Z+4, r24	; 0x04
    eac4:	15 82       	std	Z+5, r1	; 0x05
    eac6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    eaca:	ed b7       	in	r30, 0x3d	; 61
    eacc:	fe b7       	in	r31, 0x3e	; 62
    eace:	36 96       	adiw	r30, 0x06	; 6
    ead0:	0f b6       	in	r0, 0x3f	; 63
    ead2:	f8 94       	cli
    ead4:	fe bf       	out	0x3e, r31	; 62
    ead6:	0f be       	out	0x3f, r0	; 63
    ead8:	ed bf       	out	0x3d, r30	; 61
    eada:	84 e0       	ldi	r24, 0x04	; 4
    eadc:	61 e0       	ldi	r22, 0x01	; 1
    eade:	a8 01       	movw	r20, r16
    eae0:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    eae4:	00 d0       	rcall	.+0      	; 0xeae6 <FSettingPumpPooling+0x18a>
    eae6:	00 d0       	rcall	.+0      	; 0xeae8 <FSettingPumpPooling+0x18c>
    eae8:	00 d0       	rcall	.+0      	; 0xeaea <FSettingPumpPooling+0x18e>
    eaea:	ed b7       	in	r30, 0x3d	; 61
    eaec:	fe b7       	in	r31, 0x3e	; 62
    eaee:	31 96       	adiw	r30, 0x01	; 1
    eaf0:	ad b7       	in	r26, 0x3d	; 61
    eaf2:	be b7       	in	r27, 0x3e	; 62
    eaf4:	12 96       	adiw	r26, 0x02	; 2
    eaf6:	1c 93       	st	X, r17
    eaf8:	0e 93       	st	-X, r16
    eafa:	11 97       	sbiw	r26, 0x01	; 1
    eafc:	85 e6       	ldi	r24, 0x65	; 101
    eafe:	9e e0       	ldi	r25, 0x0E	; 14
    eb00:	93 83       	std	Z+3, r25	; 0x03
    eb02:	82 83       	std	Z+2, r24	; 0x02
    eb04:	8d 81       	ldd	r24, Y+5	; 0x05
    eb06:	84 83       	std	Z+4, r24	; 0x04
    eb08:	15 82       	std	Z+5, r1	; 0x05
    eb0a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    eb0e:	ed b7       	in	r30, 0x3d	; 61
    eb10:	fe b7       	in	r31, 0x3e	; 62
    eb12:	36 96       	adiw	r30, 0x06	; 6
    eb14:	0f b6       	in	r0, 0x3f	; 63
    eb16:	f8 94       	cli
    eb18:	fe bf       	out	0x3e, r31	; 62
    eb1a:	0f be       	out	0x3f, r0	; 63
    eb1c:	ed bf       	out	0x3d, r30	; 61
    eb1e:	81 e0       	ldi	r24, 0x01	; 1
    eb20:	6d e0       	ldi	r22, 0x0D	; 13
    eb22:	a8 01       	movw	r20, r16
    eb24:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    eb28:	00 d0       	rcall	.+0      	; 0xeb2a <FSettingPumpPooling+0x1ce>
    eb2a:	00 d0       	rcall	.+0      	; 0xeb2c <FSettingPumpPooling+0x1d0>
    eb2c:	00 d0       	rcall	.+0      	; 0xeb2e <FSettingPumpPooling+0x1d2>
    eb2e:	ed b7       	in	r30, 0x3d	; 61
    eb30:	fe b7       	in	r31, 0x3e	; 62
    eb32:	31 96       	adiw	r30, 0x01	; 1
    eb34:	ad b7       	in	r26, 0x3d	; 61
    eb36:	be b7       	in	r27, 0x3e	; 62
    eb38:	12 96       	adiw	r26, 0x02	; 2
    eb3a:	1c 93       	st	X, r17
    eb3c:	0e 93       	st	-X, r16
    eb3e:	11 97       	sbiw	r26, 0x01	; 1
    eb40:	8c e5       	ldi	r24, 0x5C	; 92
    eb42:	9e e0       	ldi	r25, 0x0E	; 14
    eb44:	93 83       	std	Z+3, r25	; 0x03
    eb46:	82 83       	std	Z+2, r24	; 0x02
    eb48:	8e 81       	ldd	r24, Y+6	; 0x06
    eb4a:	84 83       	std	Z+4, r24	; 0x04
    eb4c:	15 82       	std	Z+5, r1	; 0x05
    eb4e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    eb52:	ed b7       	in	r30, 0x3d	; 61
    eb54:	fe b7       	in	r31, 0x3e	; 62
    eb56:	36 96       	adiw	r30, 0x06	; 6
    eb58:	0f b6       	in	r0, 0x3f	; 63
    eb5a:	f8 94       	cli
    eb5c:	fe bf       	out	0x3e, r31	; 62
    eb5e:	0f be       	out	0x3f, r0	; 63
    eb60:	ed bf       	out	0x3d, r30	; 61
    eb62:	82 e0       	ldi	r24, 0x02	; 2
    eb64:	6d e0       	ldi	r22, 0x0D	; 13
    eb66:	a8 01       	movw	r20, r16
    eb68:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    eb6c:	00 d0       	rcall	.+0      	; 0xeb6e <FSettingPumpPooling+0x212>
    eb6e:	00 d0       	rcall	.+0      	; 0xeb70 <FSettingPumpPooling+0x214>
    eb70:	ad b7       	in	r26, 0x3d	; 61
    eb72:	be b7       	in	r27, 0x3e	; 62
    eb74:	12 96       	adiw	r26, 0x02	; 2
    eb76:	1c 93       	st	X, r17
    eb78:	0e 93       	st	-X, r16
    eb7a:	11 97       	sbiw	r26, 0x01	; 1
    eb7c:	84 e5       	ldi	r24, 0x54	; 84
    eb7e:	9e e0       	ldi	r25, 0x0E	; 14
    eb80:	14 96       	adiw	r26, 0x04	; 4
    eb82:	9c 93       	st	X, r25
    eb84:	8e 93       	st	-X, r24
    eb86:	13 97       	sbiw	r26, 0x03	; 3
    eb88:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
    eb8c:	0f 90       	pop	r0
    eb8e:	0f 90       	pop	r0
    eb90:	0f 90       	pop	r0
    eb92:	0f 90       	pop	r0
    eb94:	84 e0       	ldi	r24, 0x04	; 4
    eb96:	6d e0       	ldi	r22, 0x0D	; 13
    eb98:	a8 01       	movw	r20, r16
    eb9a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    eb9e:	08 c0       	rjmp	.+16     	; 0xebb0 <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    eba0:	10 92 83 01 	sts	0x0183, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    eba4:	83 e0       	ldi	r24, 0x03	; 3
    eba6:	6e e0       	ldi	r22, 0x0E	; 14
    eba8:	40 91 82 01 	lds	r20, 0x0182
    ebac:	0e 94 78 74 	call	0xe8f0	; 0xe8f0 <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    ebb0:	82 e0       	ldi	r24, 0x02	; 2
    ebb2:	f1 c0       	rjmp	.+482    	; 0xed96 <FSettingPumpPooling+0x43a>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    ebb4:	80 91 83 01 	lds	r24, 0x0183
    ebb8:	81 30       	cpi	r24, 0x01	; 1
    ebba:	11 f4       	brne	.+4      	; 0xebc0 <FSettingPumpPooling+0x264>
    ebbc:	80 93 24 02 	sts	0x0224, r24

          KeyChar=_key_btn(_key_scan(1));
    ebc0:	81 e0       	ldi	r24, 0x01	; 1
    ebc2:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    ebc6:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    ebca:	48 2f       	mov	r20, r24
    ebcc:	41 53       	subi	r20, 0x31	; 49
    ebce:	46 30       	cpi	r20, 0x06	; 6
    ebd0:	10 f0       	brcs	.+4      	; 0xebd6 <FSettingPumpPooling+0x27a>
    ebd2:	40 e0       	ldi	r20, 0x00	; 0
    ebd4:	04 c0       	rjmp	.+8      	; 0xebde <FSettingPumpPooling+0x282>
		      Addr=KeyChar-'1';
			  TimSend=0;
    ebd6:	10 92 91 0e 	sts	0x0E91, r1
			  IsStandaloneAcknoledge=False;
    ebda:	10 92 84 01 	sts	0x0184, r1
          }
		  switch(KeyChar){
    ebde:	83 33       	cpi	r24, 0x33	; 51
    ebe0:	09 f4       	brne	.+2      	; 0xebe4 <FSettingPumpPooling+0x288>
    ebe2:	67 c0       	rjmp	.+206    	; 0xecb2 <FSettingPumpPooling+0x356>
    ebe4:	84 33       	cpi	r24, 0x34	; 52
    ebe6:	48 f4       	brcc	.+18     	; 0xebfa <FSettingPumpPooling+0x29e>
    ebe8:	81 33       	cpi	r24, 0x31	; 49
    ebea:	89 f0       	breq	.+34     	; 0xec0e <FSettingPumpPooling+0x2b2>
    ebec:	82 33       	cpi	r24, 0x32	; 50
    ebee:	08 f0       	brcs	.+2      	; 0xebf2 <FSettingPumpPooling+0x296>
    ebf0:	3d c0       	rjmp	.+122    	; 0xec6c <FSettingPumpPooling+0x310>
    ebf2:	8a 32       	cpi	r24, 0x2A	; 42
    ebf4:	09 f0       	breq	.+2      	; 0xebf8 <FSettingPumpPooling+0x29c>
    ebf6:	e1 c0       	rjmp	.+450    	; 0xedba <FSettingPumpPooling+0x45e>
    ebf8:	cd c0       	rjmp	.+410    	; 0xed94 <FSettingPumpPooling+0x438>
    ebfa:	85 33       	cpi	r24, 0x35	; 53
    ebfc:	09 f4       	brne	.+2      	; 0xec00 <FSettingPumpPooling+0x2a4>
    ebfe:	91 c0       	rjmp	.+290    	; 0xed22 <FSettingPumpPooling+0x3c6>
    ec00:	85 33       	cpi	r24, 0x35	; 53
    ec02:	08 f4       	brcc	.+2      	; 0xec06 <FSettingPumpPooling+0x2aa>
    ec04:	78 c0       	rjmp	.+240    	; 0xecf6 <FSettingPumpPooling+0x39a>
    ec06:	86 33       	cpi	r24, 0x36	; 54
    ec08:	09 f0       	breq	.+2      	; 0xec0c <FSettingPumpPooling+0x2b0>
    ec0a:	d7 c0       	rjmp	.+430    	; 0xedba <FSettingPumpPooling+0x45e>
    ec0c:	a0 c0       	rjmp	.+320    	; 0xed4e <FSettingPumpPooling+0x3f2>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    ec0e:	24 2f       	mov	r18, r20
    ec10:	30 e0       	ldi	r19, 0x00	; 0
    ec12:	fe 01       	movw	r30, r28
    ec14:	31 96       	adiw	r30, 0x01	; 1
    ec16:	e2 0f       	add	r30, r18
    ec18:	f3 1f       	adc	r31, r19
    ec1a:	80 81       	ld	r24, Z
    ec1c:	90 e0       	ldi	r25, 0x00	; 0
    ec1e:	01 96       	adiw	r24, 0x01	; 1
    ec20:	61 e1       	ldi	r22, 0x11	; 17
    ec22:	70 e0       	ldi	r23, 0x00	; 0
    ec24:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    ec28:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    ec2a:	88 23       	and	r24, r24
    ec2c:	11 f4       	brne	.+4      	; 0xec32 <FSettingPumpPooling+0x2d6>
    ec2e:	81 e0       	ldi	r24, 0x01	; 1
    ec30:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    ec32:	2c 0f       	add	r18, r28
    ec34:	3d 1f       	adc	r19, r29
    ec36:	f9 01       	movw	r30, r18
    ec38:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ec3a:	85 e1       	ldi	r24, 0x15	; 21
    ec3c:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
    ec40:	20 93 e0 0d 	sts	0x0DE0, r18
     IsControlPooling=True;
    ec44:	81 e0       	ldi	r24, 0x01	; 1
    ec46:	80 93 86 01 	sts	0x0186, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ec4a:	e1 99       	sbic	0x1c, 1	; 28
    ec4c:	fe cf       	rjmp	.-4      	; 0xec4a <FSettingPumpPooling+0x2ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ec4e:	84 2f       	mov	r24, r20
    ec50:	90 e0       	ldi	r25, 0x00	; 0
    ec52:	8c 5b       	subi	r24, 0xBC	; 188
    ec54:	9e 4f       	sbci	r25, 0xFE	; 254
    ec56:	9f bb       	out	0x1f, r25	; 31
    ec58:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    ec5a:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    ec5c:	0f b6       	in	r0, 0x3f	; 63
    ec5e:	f8 94       	cli
    ec60:	e2 9a       	sbi	0x1c, 2	; 28
    ec62:	e1 9a       	sbi	0x1c, 1	; 28
    ec64:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    ec66:	20 93 4e 01 	sts	0x014E, r18
    ec6a:	21 c0       	rjmp	.+66     	; 0xecae <FSettingPumpPooling+0x352>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    ec6c:	fe 01       	movw	r30, r28
    ec6e:	e4 0f       	add	r30, r20
    ec70:	f1 1d       	adc	r31, r1
    ec72:	81 81       	ldd	r24, Z+1	; 0x01
    ec74:	90 e0       	ldi	r25, 0x00	; 0
    ec76:	01 96       	adiw	r24, 0x01	; 1
    ec78:	65 e1       	ldi	r22, 0x15	; 21
    ec7a:	70 e0       	ldi	r23, 0x00	; 0
    ec7c:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    ec80:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ec82:	84 e1       	ldi	r24, 0x14	; 20
    ec84:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
    ec88:	20 93 e0 0d 	sts	0x0DE0, r18
     IsControlPooling=True;
    ec8c:	81 e0       	ldi	r24, 0x01	; 1
    ec8e:	80 93 86 01 	sts	0x0186, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ec92:	e1 99       	sbic	0x1c, 1	; 28
    ec94:	fe cf       	rjmp	.-4      	; 0xec92 <FSettingPumpPooling+0x336>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ec96:	84 2f       	mov	r24, r20
    ec98:	90 e0       	ldi	r25, 0x00	; 0
    ec9a:	8c 5b       	subi	r24, 0xBC	; 188
    ec9c:	9e 4f       	sbci	r25, 0xFE	; 254
    ec9e:	9f bb       	out	0x1f, r25	; 31
    eca0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    eca2:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    eca4:	0f b6       	in	r0, 0x3f	; 63
    eca6:	f8 94       	cli
    eca8:	e2 9a       	sbi	0x1c, 2	; 28
    ecaa:	e1 9a       	sbi	0x1c, 1	; 28
    ecac:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    ecae:	83 e0       	ldi	r24, 0x03	; 3
    ecb0:	72 c0       	rjmp	.+228    	; 0xed96 <FSettingPumpPooling+0x43a>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    ecb2:	24 2f       	mov	r18, r20
    ecb4:	30 e0       	ldi	r19, 0x00	; 0
    ecb6:	fe 01       	movw	r30, r28
    ecb8:	31 96       	adiw	r30, 0x01	; 1
    ecba:	e2 0f       	add	r30, r18
    ecbc:	f3 1f       	adc	r31, r19
    ecbe:	80 81       	ld	r24, Z
    ecc0:	90 e0       	ldi	r25, 0x00	; 0
    ecc2:	01 96       	adiw	r24, 0x01	; 1
    ecc4:	65 e1       	ldi	r22, 0x15	; 21
    ecc6:	70 e0       	ldi	r23, 0x00	; 0
    ecc8:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    eccc:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    ecce:	88 23       	and	r24, r24
    ecd0:	11 f4       	brne	.+4      	; 0xecd6 <FSettingPumpPooling+0x37a>
    ecd2:	81 e0       	ldi	r24, 0x01	; 1
    ecd4:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    ecd6:	2c 0f       	add	r18, r28
    ecd8:	3d 1f       	adc	r19, r29
    ecda:	d9 01       	movw	r26, r18
    ecdc:	11 96       	adiw	r26, 0x01	; 1
    ecde:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ece0:	86 e1       	ldi	r24, 0x16	; 22
    ece2:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
    ece6:	20 93 e0 0d 	sts	0x0DE0, r18
     IsControlPooling=True;
    ecea:	81 e0       	ldi	r24, 0x01	; 1
    ecec:	80 93 86 01 	sts	0x0186, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ecf0:	e1 99       	sbic	0x1c, 1	; 28
    ecf2:	fe cf       	rjmp	.-4      	; 0xecf0 <FSettingPumpPooling+0x394>
    ecf4:	d0 cf       	rjmp	.-96     	; 0xec96 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    ecf6:	fe 01       	movw	r30, r28
    ecf8:	e4 0f       	add	r30, r20
    ecfa:	f1 1d       	adc	r31, r1
    ecfc:	81 81       	ldd	r24, Z+1	; 0x01
    ecfe:	90 e0       	ldi	r25, 0x00	; 0
    ed00:	01 96       	adiw	r24, 0x01	; 1
    ed02:	65 e1       	ldi	r22, 0x15	; 21
    ed04:	70 e0       	ldi	r23, 0x00	; 0
    ed06:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    ed0a:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ed0c:	87 e1       	ldi	r24, 0x17	; 23
    ed0e:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
    ed12:	20 93 e0 0d 	sts	0x0DE0, r18
     IsControlPooling=True;
    ed16:	81 e0       	ldi	r24, 0x01	; 1
    ed18:	80 93 86 01 	sts	0x0186, r24
    ed1c:	e1 99       	sbic	0x1c, 1	; 28
    ed1e:	fe cf       	rjmp	.-4      	; 0xed1c <FSettingPumpPooling+0x3c0>
    ed20:	ba cf       	rjmp	.-140    	; 0xec96 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    ed22:	fe 01       	movw	r30, r28
    ed24:	e4 0f       	add	r30, r20
    ed26:	f1 1d       	adc	r31, r1
    ed28:	81 81       	ldd	r24, Z+1	; 0x01
    ed2a:	90 e0       	ldi	r25, 0x00	; 0
    ed2c:	01 96       	adiw	r24, 0x01	; 1
    ed2e:	69 e2       	ldi	r22, 0x29	; 41
    ed30:	70 e0       	ldi	r23, 0x00	; 0
    ed32:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
    ed36:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ed38:	88 e1       	ldi	r24, 0x18	; 24
    ed3a:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
    ed3e:	20 93 e0 0d 	sts	0x0DE0, r18
     IsControlPooling=True;
    ed42:	81 e0       	ldi	r24, 0x01	; 1
    ed44:	80 93 86 01 	sts	0x0186, r24
    ed48:	e1 99       	sbic	0x1c, 1	; 28
    ed4a:	fe cf       	rjmp	.-4      	; 0xed48 <FSettingPumpPooling+0x3ec>
    ed4c:	a4 cf       	rjmp	.-184    	; 0xec96 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    ed4e:	fe 01       	movw	r30, r28
    ed50:	e4 0f       	add	r30, r20
    ed52:	f1 1d       	adc	r31, r1
    ed54:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ed56:	e1 99       	sbic	0x1c, 1	; 28
    ed58:	fe cf       	rjmp	.-4      	; 0xed56 <FSettingPumpPooling+0x3fa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ed5a:	84 e4       	ldi	r24, 0x44	; 68
    ed5c:	91 e0       	ldi	r25, 0x01	; 1
    ed5e:	9f bb       	out	0x1f, r25	; 31
    ed60:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ed62:	e0 9a       	sbi	0x1c, 0	; 28
    ed64:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ed66:	e1 99       	sbic	0x1c, 1	; 28
    ed68:	fe cf       	rjmp	.-4      	; 0xed66 <FSettingPumpPooling+0x40a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ed6a:	84 2f       	mov	r24, r20
    ed6c:	90 e0       	ldi	r25, 0x00	; 0
    ed6e:	8c 5b       	subi	r24, 0xBC	; 188
    ed70:	9e 4f       	sbci	r25, 0xFE	; 254
    ed72:	9f bb       	out	0x1f, r25	; 31
    ed74:	8e bb       	out	0x1e, r24	; 30
    ed76:	82 2f       	mov	r24, r18
    ed78:	90 e0       	ldi	r25, 0x00	; 0
    ed7a:	70 e0       	ldi	r23, 0x00	; 0
    ed7c:	6f 5f       	subi	r22, 0xFF	; 255
    ed7e:	7f 4f       	sbci	r23, 0xFF	; 255
    ed80:	01 96       	adiw	r24, 0x01	; 1
    ed82:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
#endif
    EEDR = __value;
    ed86:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    ed88:	0f b6       	in	r0, 0x3f	; 63
    ed8a:	f8 94       	cli
    ed8c:	e2 9a       	sbi	0x1c, 2	; 28
    ed8e:	e1 9a       	sbi	0x1c, 1	; 28
    ed90:	0f be       	out	0x3f, r0	; 63
    ed92:	0c c0       	rjmp	.+24     	; 0xedac <FSettingPumpPooling+0x450>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    ed94:	84 e0       	ldi	r24, 0x04	; 4
    ed96:	80 93 24 02 	sts	0x0224, r24
    ed9a:	0f c0       	rjmp	.+30     	; 0xedba <FSettingPumpPooling+0x45e>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    ed9c:	80 91 84 01 	lds	r24, 0x0184
    eda0:	81 30       	cpi	r24, 0x01	; 1
    eda2:	21 f0       	breq	.+8      	; 0xedac <FSettingPumpPooling+0x450>
    eda4:	80 91 91 0e 	lds	r24, 0x0E91
    eda8:	86 30       	cpi	r24, 0x06	; 6
    edaa:	38 f0       	brcs	.+14     	; 0xedba <FSettingPumpPooling+0x45e>
    edac:	10 92 24 02 	sts	0x0224, r1
    edb0:	04 c0       	rjmp	.+8      	; 0xedba <FSettingPumpPooling+0x45e>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    edb2:	10 92 24 02 	sts	0x0224, r1
    edb6:	81 e0       	ldi	r24, 0x01	; 1
    edb8:	01 c0       	rjmp	.+2      	; 0xedbc <FSettingPumpPooling+0x460>
    edba:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    edbc:	6a 96       	adiw	r28, 0x1a	; 26
    edbe:	0f b6       	in	r0, 0x3f	; 63
    edc0:	f8 94       	cli
    edc2:	de bf       	out	0x3e, r29	; 62
    edc4:	0f be       	out	0x3f, r0	; 63
    edc6:	cd bf       	out	0x3d, r28	; 61
    edc8:	cf 91       	pop	r28
    edca:	df 91       	pop	r29
    edcc:	1f 91       	pop	r17
    edce:	0f 91       	pop	r16
    edd0:	08 95       	ret

0000edd2 <DisplayTicker>:
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
	 lcd_print(2, 1, lcdteks);
}

void DisplayTicker(){
    if (TimTicker>(TICKER_DELAY*2+1)){
    edd2:	80 91 92 01 	lds	r24, 0x0192
    edd6:	86 31       	cpi	r24, 0x16	; 22
    edd8:	38 f0       	brcs	.+14     	; 0xede8 <DisplayTicker+0x16>
	    lcd_put(4, 1, '>');
    edda:	84 e0       	ldi	r24, 0x04	; 4
    eddc:	61 e0       	ldi	r22, 0x01	; 1
    edde:	4e e3       	ldi	r20, 0x3E	; 62
    ede0:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
		TimTicker=0;
    ede4:	10 92 92 01 	sts	0x0192, r1
	}
    if (TimTicker==TICKER_DELAY){
    ede8:	80 91 92 01 	lds	r24, 0x0192
    edec:	8a 30       	cpi	r24, 0x0A	; 10
    edee:	51 f4       	brne	.+20     	; 0xee04 <DisplayTicker+0x32>
	    lcd_put(4, 1, '<');
    edf0:	84 e0       	ldi	r24, 0x04	; 4
    edf2:	61 e0       	ldi	r22, 0x01	; 1
    edf4:	4c e3       	ldi	r20, 0x3C	; 60
    edf6:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
		TimTicker++;
    edfa:	80 91 92 01 	lds	r24, 0x0192
    edfe:	8f 5f       	subi	r24, 0xFF	; 255
    ee00:	80 93 92 01 	sts	0x0192, r24
    ee04:	08 95       	ret

0000ee06 <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    ee06:	6f 92       	push	r6
    ee08:	7f 92       	push	r7
    ee0a:	8f 92       	push	r8
    ee0c:	9f 92       	push	r9
    ee0e:	af 92       	push	r10
    ee10:	bf 92       	push	r11
    ee12:	cf 92       	push	r12
    ee14:	df 92       	push	r13
    ee16:	ff 92       	push	r15
    ee18:	0f 93       	push	r16
    ee1a:	1f 93       	push	r17
    ee1c:	df 93       	push	r29
    ee1e:	cf 93       	push	r28
    ee20:	cd b7       	in	r28, 0x3d	; 61
    ee22:	de b7       	in	r29, 0x3e	; 62
    ee24:	67 97       	sbiw	r28, 0x17	; 23
    ee26:	0f b6       	in	r0, 0x3f	; 63
    ee28:	f8 94       	cli
    ee2a:	de bf       	out	0x3e, r29	; 62
    ee2c:	0f be       	out	0x3f, r0	; 63
    ee2e:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    ee30:	80 91 8b 02 	lds	r24, 0x028B
    ee34:	90 91 8c 02 	lds	r25, 0x028C
    ee38:	01 96       	adiw	r24, 0x01	; 1
    ee3a:	90 93 8c 02 	sts	0x028C, r25
    ee3e:	80 93 8b 02 	sts	0x028B, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    ee42:	62 e3       	ldi	r22, 0x32	; 50
    ee44:	70 e0       	ldi	r23, 0x00	; 0
    ee46:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    ee4a:	89 2b       	or	r24, r25
    ee4c:	29 f5       	brne	.+74     	; 0xee98 <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    ee4e:	80 91 00 01 	lds	r24, 0x0100
    ee52:	82 30       	cpi	r24, 0x02	; 2
    ee54:	11 f4       	brne	.+4      	; 0xee5a <DisplayIdle+0x54>
    ee56:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ee5a:	e1 99       	sbic	0x1c, 1	; 28
    ee5c:	fe cf       	rjmp	.-4      	; 0xee5a <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ee5e:	87 e3       	ldi	r24, 0x37	; 55
    ee60:	90 e0       	ldi	r25, 0x00	; 0
    ee62:	9f bb       	out	0x1f, r25	; 31
    ee64:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ee66:	e0 9a       	sbi	0x1c, 0	; 28
    ee68:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&DefShowDateTime)) DisplayDateTime();
    ee6a:	88 23       	and	r24, r24
    ee6c:	19 f0       	breq	.+6      	; 0xee74 <DisplayIdle+0x6e>
    ee6e:	0e 94 e3 5d 	call	0xbbc6	; 0xbbc6 <DisplayDateTime>
    ee72:	02 c0       	rjmp	.+4      	; 0xee78 <DisplayIdle+0x72>
       else DisplayTicker();
    ee74:	0e 94 e9 76 	call	0xedd2	; 0xedd2 <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    ee78:	80 91 00 01 	lds	r24, 0x0100
    ee7c:	82 30       	cpi	r24, 0x02	; 2
    ee7e:	61 f4       	brne	.+24     	; 0xee98 <DisplayIdle+0x92>
    ee80:	80 91 83 01 	lds	r24, 0x0183
    ee84:	81 30       	cpi	r24, 0x01	; 1
    ee86:	41 f4       	brne	.+16     	; 0xee98 <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    ee88:	10 92 83 01 	sts	0x0183, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    ee8c:	84 e0       	ldi	r24, 0x04	; 4
    ee8e:	62 e1       	ldi	r22, 0x12	; 18
    ee90:	40 91 82 01 	lds	r20, 0x0182
    ee94:	0e 94 78 74 	call	0xe8f0	; 0xe8f0 <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    ee98:	f0 90 8a 02 	lds	r15, 0x028A
    ee9c:	ff 20       	and	r15, r15
    ee9e:	29 f0       	breq	.+10     	; 0xeeaa <DisplayIdle+0xa4>
    eea0:	81 e0       	ldi	r24, 0x01	; 1
    eea2:	f8 16       	cp	r15, r24
    eea4:	09 f0       	breq	.+2      	; 0xeea8 <DisplayIdle+0xa2>
    eea6:	58 c0       	rjmp	.+176    	; 0xef58 <DisplayIdle+0x152>
    eea8:	2f c0       	rjmp	.+94     	; 0xef08 <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    eeaa:	f0 90 b4 01 	lds	r15, 0x01B4
    eeae:	91 e0       	ldi	r25, 0x01	; 1
    eeb0:	f9 16       	cp	r15, r25
    eeb2:	09 f0       	breq	.+2      	; 0xeeb6 <DisplayIdle+0xb0>
    eeb4:	51 c0       	rjmp	.+162    	; 0xef58 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    eeb6:	00 d0       	rcall	.+0      	; 0xeeb8 <DisplayIdle+0xb2>
    eeb8:	00 d0       	rcall	.+0      	; 0xeeba <DisplayIdle+0xb4>
    eeba:	00 d0       	rcall	.+0      	; 0xeebc <DisplayIdle+0xb6>
    eebc:	ed b7       	in	r30, 0x3d	; 61
    eebe:	fe b7       	in	r31, 0x3e	; 62
    eec0:	31 96       	adiw	r30, 0x01	; 1
    eec2:	8e 01       	movw	r16, r28
    eec4:	0c 5f       	subi	r16, 0xFC	; 252
    eec6:	1f 4f       	sbci	r17, 0xFF	; 255
    eec8:	ad b7       	in	r26, 0x3d	; 61
    eeca:	be b7       	in	r27, 0x3e	; 62
    eecc:	12 96       	adiw	r26, 0x02	; 2
    eece:	1c 93       	st	X, r17
    eed0:	0e 93       	st	-X, r16
    eed2:	11 97       	sbiw	r26, 0x01	; 1
    eed4:	8d ef       	ldi	r24, 0xFD	; 253
    eed6:	9c e1       	ldi	r25, 0x1C	; 28
    eed8:	93 83       	std	Z+3, r25	; 0x03
    eeda:	82 83       	std	Z+2, r24	; 0x02
    eedc:	82 ec       	ldi	r24, 0xC2	; 194
    eede:	97 e0       	ldi	r25, 0x07	; 7
    eee0:	95 83       	std	Z+5, r25	; 0x05
    eee2:	84 83       	std	Z+4, r24	; 0x04
    eee4:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    eee8:	ed b7       	in	r30, 0x3d	; 61
    eeea:	fe b7       	in	r31, 0x3e	; 62
    eeec:	36 96       	adiw	r30, 0x06	; 6
    eeee:	0f b6       	in	r0, 0x3f	; 63
    eef0:	f8 94       	cli
    eef2:	fe bf       	out	0x3e, r31	; 62
    eef4:	0f be       	out	0x3f, r0	; 63
    eef6:	ed bf       	out	0x3d, r30	; 61
    eef8:	83 e0       	ldi	r24, 0x03	; 3
    eefa:	61 e0       	ldi	r22, 0x01	; 1
    eefc:	a8 01       	movw	r20, r16
    eefe:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			   stDispIdle=diWaitNoBusy;
    ef02:	f0 92 8a 02 	sts	0x028A, r15
    ef06:	28 c0       	rjmp	.+80     	; 0xef58 <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    ef08:	80 91 b4 01 	lds	r24, 0x01B4
    ef0c:	88 23       	and	r24, r24
    ef0e:	21 f5       	brne	.+72     	; 0xef58 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    ef10:	00 d0       	rcall	.+0      	; 0xef12 <DisplayIdle+0x10c>
    ef12:	00 d0       	rcall	.+0      	; 0xef14 <DisplayIdle+0x10e>
    ef14:	8e 01       	movw	r16, r28
    ef16:	0c 5f       	subi	r16, 0xFC	; 252
    ef18:	1f 4f       	sbci	r17, 0xFF	; 255
    ef1a:	ad b7       	in	r26, 0x3d	; 61
    ef1c:	be b7       	in	r27, 0x3e	; 62
    ef1e:	12 96       	adiw	r26, 0x02	; 2
    ef20:	1c 93       	st	X, r17
    ef22:	0e 93       	st	-X, r16
    ef24:	11 97       	sbiw	r26, 0x01	; 1
    ef26:	88 ee       	ldi	r24, 0xE8	; 232
    ef28:	9c e1       	ldi	r25, 0x1C	; 28
    ef2a:	14 96       	adiw	r26, 0x04	; 4
    ef2c:	9c 93       	st	X, r25
    ef2e:	8e 93       	st	-X, r24
    ef30:	13 97       	sbiw	r26, 0x03	; 3
    ef32:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    ef36:	0f 90       	pop	r0
    ef38:	0f 90       	pop	r0
    ef3a:	0f 90       	pop	r0
    ef3c:	0f 90       	pop	r0
    ef3e:	83 e0       	ldi	r24, 0x03	; 3
    ef40:	61 e0       	ldi	r22, 0x01	; 1
    ef42:	a8 01       	movw	r20, r16
    ef44:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			   stDispIdle=diScan;
    ef48:	10 92 8a 02 	sts	0x028A, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    ef4c:	80 91 91 01 	lds	r24, 0x0191
    ef50:	88 23       	and	r24, r24
    ef52:	11 f0       	breq	.+4      	; 0xef58 <DisplayIdle+0x152>
    ef54:	f0 92 98 01 	sts	0x0198, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    ef58:	80 91 98 01 	lds	r24, 0x0198
    ef5c:	81 30       	cpi	r24, 0x01	; 1
    ef5e:	09 f0       	breq	.+2      	; 0xef62 <DisplayIdle+0x15c>
    ef60:	69 c0       	rjmp	.+210    	; 0xf034 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    ef62:	10 92 98 01 	sts	0x0198, r1
		 if (nLocalAccount>0){
    ef66:	80 91 91 01 	lds	r24, 0x0191
    ef6a:	88 23       	and	r24, r24
    ef6c:	09 f4       	brne	.+2      	; 0xef70 <DisplayIdle+0x16a>
    ef6e:	5c c0       	rjmp	.+184    	; 0xf028 <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    ef70:	83 e0       	ldi	r24, 0x03	; 3
    ef72:	61 e0       	ldi	r22, 0x01	; 1
    ef74:	42 ee       	ldi	r20, 0xE2	; 226
    ef76:	5c e1       	ldi	r21, 0x1C	; 28
    ef78:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    ef7c:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    ef7e:	5e 01       	movw	r10, r28
    ef80:	08 94       	sec
    ef82:	a1 1c       	adc	r10, r1
    ef84:	b1 1c       	adc	r11, r1
    ef86:	bd ed       	ldi	r27, 0xDD	; 221
    ef88:	6b 2e       	mov	r6, r27
    ef8a:	bc e1       	ldi	r27, 0x1C	; 28
    ef8c:	7b 2e       	mov	r7, r27
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    ef8e:	a4 e0       	ldi	r26, 0x04	; 4
    ef90:	ca 2e       	mov	r12, r26
    ef92:	d1 2c       	mov	r13, r1
    ef94:	cc 0e       	add	r12, r28
    ef96:	dd 1e       	adc	r13, r29
    ef98:	f9 ed       	ldi	r31, 0xD9	; 217
    ef9a:	8f 2e       	mov	r8, r31
    ef9c:	fc e1       	ldi	r31, 0x1C	; 28
    ef9e:	9f 2e       	mov	r9, r31
    efa0:	3d c0       	rjmp	.+122    	; 0xf01c <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    efa2:	0f 2d       	mov	r16, r15
    efa4:	10 e0       	ldi	r17, 0x00	; 0
    efa6:	00 d0       	rcall	.+0      	; 0xefa8 <DisplayIdle+0x1a2>
    efa8:	00 d0       	rcall	.+0      	; 0xefaa <DisplayIdle+0x1a4>
    efaa:	00 d0       	rcall	.+0      	; 0xefac <DisplayIdle+0x1a6>
    efac:	ad b7       	in	r26, 0x3d	; 61
    efae:	be b7       	in	r27, 0x3e	; 62
    efb0:	11 96       	adiw	r26, 0x01	; 1
    efb2:	ed b7       	in	r30, 0x3d	; 61
    efb4:	fe b7       	in	r31, 0x3e	; 62
    efb6:	b2 82       	std	Z+2, r11	; 0x02
    efb8:	a1 82       	std	Z+1, r10	; 0x01
    efba:	13 96       	adiw	r26, 0x03	; 3
    efbc:	7c 92       	st	X, r7
    efbe:	6e 92       	st	-X, r6
    efc0:	12 97       	sbiw	r26, 0x02	; 2
    efc2:	f8 01       	movw	r30, r16
    efc4:	e1 5a       	subi	r30, 0xA1	; 161
    efc6:	fc 4f       	sbci	r31, 0xFC	; 252
    efc8:	80 81       	ld	r24, Z
    efca:	14 96       	adiw	r26, 0x04	; 4
    efcc:	8c 93       	st	X, r24
    efce:	14 97       	sbiw	r26, 0x04	; 4
    efd0:	15 96       	adiw	r26, 0x05	; 5
    efd2:	1c 92       	st	X, r1
    efd4:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    efd8:	ed b7       	in	r30, 0x3d	; 61
    efda:	fe b7       	in	r31, 0x3e	; 62
    efdc:	31 96       	adiw	r30, 0x01	; 1
    efde:	ad b7       	in	r26, 0x3d	; 61
    efe0:	be b7       	in	r27, 0x3e	; 62
    efe2:	12 96       	adiw	r26, 0x02	; 2
    efe4:	dc 92       	st	X, r13
    efe6:	ce 92       	st	-X, r12
    efe8:	11 97       	sbiw	r26, 0x01	; 1
    efea:	93 82       	std	Z+3, r9	; 0x03
    efec:	82 82       	std	Z+2, r8	; 0x02
    efee:	b5 82       	std	Z+5, r11	; 0x05
    eff0:	a4 82       	std	Z+4, r10	; 0x04
    eff2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    eff6:	ed b7       	in	r30, 0x3d	; 61
    eff8:	fe b7       	in	r31, 0x3e	; 62
    effa:	36 96       	adiw	r30, 0x06	; 6
    effc:	0f b6       	in	r0, 0x3f	; 63
    effe:	f8 94       	cli
    f000:	fe bf       	out	0x3e, r31	; 62
    f002:	0f be       	out	0x3f, r0	; 63
    f004:	ed bf       	out	0x3d, r30	; 61
    f006:	b8 01       	movw	r22, r16
    f008:	66 0f       	add	r22, r22
    f00a:	77 1f       	adc	r23, r23
    f00c:	60 0f       	add	r22, r16
    f00e:	71 1f       	adc	r23, r17
    f010:	6a 5f       	subi	r22, 0xFA	; 250
    f012:	83 e0       	ldi	r24, 0x03	; 3
    f014:	a6 01       	movw	r20, r12
    f016:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    f01a:	f3 94       	inc	r15
    f01c:	80 91 91 01 	lds	r24, 0x0191
    f020:	f8 16       	cp	r15, r24
    f022:	08 f4       	brcc	.+2      	; 0xf026 <DisplayIdle+0x220>
    f024:	be cf       	rjmp	.-132    	; 0xefa2 <DisplayIdle+0x19c>
    f026:	06 c0       	rjmp	.+12     	; 0xf034 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    f028:	83 e0       	ldi	r24, 0x03	; 3
    f02a:	61 e0       	ldi	r22, 0x01	; 1
    f02c:	44 ec       	ldi	r20, 0xC4	; 196
    f02e:	5c e1       	ldi	r21, 0x1C	; 28
    f030:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    f034:	80 91 ab 01 	lds	r24, 0x01AB
    f038:	81 30       	cpi	r24, 0x01	; 1
    f03a:	c1 f4       	brne	.+48     	; 0xf06c <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    f03c:	10 92 ab 01 	sts	0x01AB, r1
	     if (nLocalAccount>0){
    f040:	90 91 91 01 	lds	r25, 0x0191
    f044:	99 23       	and	r25, r25
    f046:	91 f0       	breq	.+36     	; 0xf06c <DisplayIdle+0x266>
    f048:	ef e5       	ldi	r30, 0x5F	; 95
    f04a:	f3 e0       	ldi	r31, 0x03	; 3
			 for(i=0;i<nLocalAccount;i++){//Shift data
    f04c:	29 2f       	mov	r18, r25
    f04e:	30 e0       	ldi	r19, 0x00	; 0
    f050:	2e 0f       	add	r18, r30
    f052:	3f 1f       	adc	r19, r31
    f054:	02 c0       	rjmp	.+4      	; 0xf05a <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    f056:	81 81       	ldd	r24, Z+1	; 0x01
    f058:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    f05a:	e2 17       	cp	r30, r18
    f05c:	f3 07       	cpc	r31, r19
    f05e:	d9 f7       	brne	.-10     	; 0xf056 <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    f060:	91 50       	subi	r25, 0x01	; 1
    f062:	90 93 91 01 	sts	0x0191, r25
             IsViewFillingFIP=True; 
    f066:	81 e0       	ldi	r24, 0x01	; 1
    f068:	80 93 98 01 	sts	0x0198, r24
		 }
	 }
}
    f06c:	67 96       	adiw	r28, 0x17	; 23
    f06e:	0f b6       	in	r0, 0x3f	; 63
    f070:	f8 94       	cli
    f072:	de bf       	out	0x3e, r29	; 62
    f074:	0f be       	out	0x3f, r0	; 63
    f076:	cd bf       	out	0x3d, r28	; 61
    f078:	cf 91       	pop	r28
    f07a:	df 91       	pop	r29
    f07c:	1f 91       	pop	r17
    f07e:	0f 91       	pop	r16
    f080:	ff 90       	pop	r15
    f082:	df 90       	pop	r13
    f084:	cf 90       	pop	r12
    f086:	bf 90       	pop	r11
    f088:	af 90       	pop	r10
    f08a:	9f 90       	pop	r9
    f08c:	8f 90       	pop	r8
    f08e:	7f 90       	pop	r7
    f090:	6f 90       	pop	r6
    f092:	08 95       	ret

0000f094 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	spi_init(1, 0);         //Master
    f094:	81 e0       	ldi	r24, 0x01	; 1
    f096:	60 e0       	ldi	r22, 0x00	; 0
    f098:	0e 94 bf a9 	call	0x1537e	; 0x1537e <spi_init>
    spi_enable(SPI_SLAVE); //Enable SS 
    f09c:	81 e0       	ldi	r24, 0x01	; 1
    f09e:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    f0a2:	bb 98       	cbi	0x17, 3	; 23
    f0a4:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    f0a6:	ba 9a       	sbi	0x17, 2	; 23
}
    f0a8:	08 95       	ret

0000f0aa <systemSlave>:




void systemSlave(){
    spi_enable(SPI_NONE);	
    f0aa:	80 e0       	ldi	r24, 0x00	; 0
    f0ac:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
  	spi_init(0, 1);         //Slave
    f0b0:	80 e0       	ldi	r24, 0x00	; 0
    f0b2:	61 e0       	ldi	r22, 0x01	; 1
    f0b4:	0e 94 bf a9 	call	0x1537e	; 0x1537e <spi_init>
	sbi(DDRB,3);             //MISO Output
    f0b8:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    f0ba:	bb 9a       	sbi	0x17, 3	; 23
    f0bc:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    f0be:	ba 98       	cbi	0x17, 2	; 23
    f0c0:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    f0c2:	b9 98       	cbi	0x17, 1	; 23
    f0c4:	c1 9a       	sbi	0x18, 1	; 24
}
    f0c6:	08 95       	ret

0000f0c8 <EDCSendByte>:
    spi_enable(SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    f0c8:	1f 93       	push	r17
    f0ca:	18 2f       	mov	r17, r24
     systemMaster();	 
    f0cc:	0e 94 4a 78 	call	0xf094	; 0xf094 <systemMaster>
     spi(EDCData);
    f0d0:	81 2f       	mov	r24, r17
    f0d2:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
     systemSlave();
    f0d6:	0e 94 55 78 	call	0xf0aa	; 0xf0aa <systemSlave>
}
    f0da:	1f 91       	pop	r17
    f0dc:	08 95       	ret

0000f0de <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    f0de:	cf 92       	push	r12
    f0e0:	df 92       	push	r13
    f0e2:	ef 92       	push	r14
    f0e4:	ff 92       	push	r15
    f0e6:	0f 93       	push	r16
    f0e8:	1f 93       	push	r17
    f0ea:	df 93       	push	r29
    f0ec:	cf 93       	push	r28
    f0ee:	cd b7       	in	r28, 0x3d	; 61
    f0f0:	de b7       	in	r29, 0x3e	; 62
    f0f2:	ec 97       	sbiw	r28, 0x3c	; 60
    f0f4:	0f b6       	in	r0, 0x3f	; 63
    f0f6:	f8 94       	cli
    f0f8:	de bf       	out	0x3e, r29	; 62
    f0fa:	0f be       	out	0x3f, r0	; 63
    f0fc:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //uart_printf(0,0,PSTR("StrStatus:"));uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    f0fe:	8d b7       	in	r24, 0x3d	; 61
    f100:	9e b7       	in	r25, 0x3e	; 62
    f102:	42 97       	sbiw	r24, 0x12	; 18
    f104:	0f b6       	in	r0, 0x3f	; 63
    f106:	f8 94       	cli
    f108:	9e bf       	out	0x3e, r25	; 62
    f10a:	0f be       	out	0x3f, r0	; 63
    f10c:	8d bf       	out	0x3d, r24	; 61
    f10e:	ed b7       	in	r30, 0x3d	; 61
    f110:	fe b7       	in	r31, 0x3e	; 62
    f112:	31 96       	adiw	r30, 0x01	; 1
    f114:	8e 01       	movw	r16, r28
    f116:	0f 5f       	subi	r16, 0xFF	; 255
    f118:	1f 4f       	sbci	r17, 0xFF	; 255
    f11a:	ad b7       	in	r26, 0x3d	; 61
    f11c:	be b7       	in	r27, 0x3e	; 62
    f11e:	12 96       	adiw	r26, 0x02	; 2
    f120:	1c 93       	st	X, r17
    f122:	0e 93       	st	-X, r16
    f124:	11 97       	sbiw	r26, 0x01	; 1
    f126:	81 eb       	ldi	r24, 0xB1	; 177
    f128:	9c e1       	ldi	r25, 0x1C	; 28
    f12a:	93 83       	std	Z+3, r25	; 0x03
    f12c:	82 83       	std	Z+2, r24	; 0x02
    f12e:	80 ea       	ldi	r24, 0xA0	; 160
    f130:	9e e0       	ldi	r25, 0x0E	; 14
    f132:	95 83       	std	Z+5, r25	; 0x05
    f134:	84 83       	std	Z+4, r24	; 0x04
    f136:	82 ec       	ldi	r24, 0xC2	; 194
    f138:	97 e0       	ldi	r25, 0x07	; 7
    f13a:	97 83       	std	Z+7, r25	; 0x07
    f13c:	86 83       	std	Z+6, r24	; 0x06
    f13e:	85 e1       	ldi	r24, 0x15	; 21
    f140:	98 e0       	ldi	r25, 0x08	; 8
    f142:	91 87       	std	Z+9, r25	; 0x09
    f144:	80 87       	std	Z+8, r24	; 0x08
    f146:	87 ea       	ldi	r24, 0xA7	; 167
    f148:	95 e0       	ldi	r25, 0x05	; 5
    f14a:	93 87       	std	Z+11, r25	; 0x0b
    f14c:	82 87       	std	Z+10, r24	; 0x0a
    f14e:	8e e7       	ldi	r24, 0x7E	; 126
    f150:	93 e0       	ldi	r25, 0x03	; 3
    f152:	95 87       	std	Z+13, r25	; 0x0d
    f154:	84 87       	std	Z+12, r24	; 0x0c
    f156:	8c eb       	ldi	r24, 0xBC	; 188
    f158:	9d e0       	ldi	r25, 0x0D	; 13
    f15a:	97 87       	std	Z+15, r25	; 0x0f
    f15c:	86 87       	std	Z+14, r24	; 0x0e
    f15e:	83 e9       	ldi	r24, 0x93	; 147
    f160:	93 e0       	ldi	r25, 0x03	; 3
    f162:	91 8b       	std	Z+17, r25	; 0x11
    f164:	80 8b       	std	Z+16, r24	; 0x10
    f166:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    f16a:	8d b7       	in	r24, 0x3d	; 61
    f16c:	9e b7       	in	r25, 0x3e	; 62
    f16e:	42 96       	adiw	r24, 0x12	; 18
    f170:	0f b6       	in	r0, 0x3f	; 63
    f172:	f8 94       	cli
    f174:	9e bf       	out	0x3e, r25	; 62
    f176:	0f be       	out	0x3f, r0	; 63
    f178:	8d bf       	out	0x3d, r24	; 61
    f17a:	82 e0       	ldi	r24, 0x02	; 2
    f17c:	0e 94 64 78 	call	0xf0c8	; 0xf0c8 <EDCSendByte>
    f180:	ff 24       	eor	r15, r15
    f182:	92 e0       	ldi	r25, 0x02	; 2
    f184:	e9 2e       	mov	r14, r25
    f186:	84 ed       	ldi	r24, 0xD4	; 212
    f188:	c8 2e       	mov	r12, r24
    f18a:	80 e3       	ldi	r24, 0x30	; 48
    f18c:	d8 2e       	mov	r13, r24
    f18e:	0a c0       	rjmp	.+20     	; 0xf1a4 <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    f190:	a0 0f       	add	r26, r16
    f192:	b1 1f       	adc	r27, r17
    f194:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    f196:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    f198:	0e 94 64 78 	call	0xf0c8	; 0xf0c8 <EDCSendByte>
    f19c:	c6 01       	movw	r24, r12
    f19e:	01 97       	sbiw	r24, 0x01	; 1
    f1a0:	f1 f7       	brne	.-4      	; 0xf19e <SendEDCMessage+0xc0>
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    f1a2:	f3 94       	inc	r15
    f1a4:	f8 01       	movw	r30, r16
    f1a6:	01 90       	ld	r0, Z+
    f1a8:	00 20       	and	r0, r0
    f1aa:	e9 f7       	brne	.-6      	; 0xf1a6 <SendEDCMessage+0xc8>
    f1ac:	31 97       	sbiw	r30, 0x01	; 1
    f1ae:	e0 1b       	sub	r30, r16
    f1b0:	f1 0b       	sbc	r31, r17
    f1b2:	af 2d       	mov	r26, r15
    f1b4:	b0 e0       	ldi	r27, 0x00	; 0
    f1b6:	ae 17       	cp	r26, r30
    f1b8:	bf 07       	cpc	r27, r31
    f1ba:	50 f3       	brcs	.-44     	; 0xf190 <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //uart(0,1,SerialEDC[i]);
		  _delay_ms(SPI_EDC_DELAY);//min:8
	 }
     EDCSendByte(0x03);
    f1bc:	83 e0       	ldi	r24, 0x03	; 3
    f1be:	0e 94 64 78 	call	0xf0c8	; 0xf0c8 <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    f1c2:	83 e0       	ldi	r24, 0x03	; 3
    f1c4:	8e 25       	eor	r24, r14
    f1c6:	0e 94 64 78 	call	0xf0c8	; 0xf0c8 <EDCSendByte>
}
    f1ca:	ec 96       	adiw	r28, 0x3c	; 60
    f1cc:	0f b6       	in	r0, 0x3f	; 63
    f1ce:	f8 94       	cli
    f1d0:	de bf       	out	0x3e, r29	; 62
    f1d2:	0f be       	out	0x3f, r0	; 63
    f1d4:	cd bf       	out	0x3d, r28	; 61
    f1d6:	cf 91       	pop	r28
    f1d8:	df 91       	pop	r29
    f1da:	1f 91       	pop	r17
    f1dc:	0f 91       	pop	r16
    f1de:	ff 90       	pop	r15
    f1e0:	ef 90       	pop	r14
    f1e2:	df 90       	pop	r13
    f1e4:	cf 90       	pop	r12
    f1e6:	08 95       	ret

0000f1e8 <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    f1e8:	0f 93       	push	r16
    f1ea:	1f 93       	push	r17
    f1ec:	18 2f       	mov	r17, r24
    f1ee:	06 2f       	mov	r16, r22
	 systemMaster();
    f1f0:	0e 94 4a 78 	call	0xf094	; 0xf094 <systemMaster>
	 spi(0x05);
    f1f4:	85 e0       	ldi	r24, 0x05	; 5
    f1f6:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	 spi(SlaveCommand);
    f1fa:	81 2f       	mov	r24, r17
    f1fc:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	 spi(SlaveMessage);
    f200:	80 2f       	mov	r24, r16
    f202:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	 spi(0x06);
    f206:	86 e0       	ldi	r24, 0x06	; 6
    f208:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	 systemSlave();
    f20c:	0e 94 55 78 	call	0xf0aa	; 0xf0aa <systemSlave>
}
    f210:	1f 91       	pop	r17
    f212:	0f 91       	pop	r16
    f214:	08 95       	ret

0000f216 <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    f216:	9f 92       	push	r9
    f218:	af 92       	push	r10
    f21a:	bf 92       	push	r11
    f21c:	cf 92       	push	r12
    f21e:	df 92       	push	r13
    f220:	ef 92       	push	r14
    f222:	ff 92       	push	r15
    f224:	0f 93       	push	r16
    f226:	1f 93       	push	r17
    f228:	df 93       	push	r29
    f22a:	cf 93       	push	r28
    f22c:	cd b7       	in	r28, 0x3d	; 61
    f22e:	de b7       	in	r29, 0x3e	; 62
    f230:	64 97       	sbiw	r28, 0x14	; 20
    f232:	0f b6       	in	r0, 0x3f	; 63
    f234:	f8 94       	cli
    f236:	de bf       	out	0x3e, r29	; 62
    f238:	0f be       	out	0x3f, r0	; 63
    f23a:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    f23c:	80 91 23 02 	lds	r24, 0x0223
    f240:	85 30       	cpi	r24, 0x05	; 5
    f242:	09 f4       	brne	.+2      	; 0xf246 <FSettingPumpID+0x30>
    f244:	85 c1       	rjmp	.+778    	; 0xf550 <FSettingPumpID+0x33a>
    f246:	86 30       	cpi	r24, 0x06	; 6
    f248:	90 f4       	brcc	.+36     	; 0xf26e <FSettingPumpID+0x58>
    f24a:	82 30       	cpi	r24, 0x02	; 2
    f24c:	09 f4       	brne	.+2      	; 0xf250 <FSettingPumpID+0x3a>
    f24e:	8f c0       	rjmp	.+286    	; 0xf36e <FSettingPumpID+0x158>
    f250:	83 30       	cpi	r24, 0x03	; 3
    f252:	30 f4       	brcc	.+12     	; 0xf260 <FSettingPumpID+0x4a>
    f254:	88 23       	and	r24, r24
    f256:	f1 f0       	breq	.+60     	; 0xf294 <FSettingPumpID+0x7e>
    f258:	81 30       	cpi	r24, 0x01	; 1
    f25a:	09 f0       	breq	.+2      	; 0xf25e <FSettingPumpID+0x48>
    f25c:	6c c2       	rjmp	.+1240   	; 0xf736 <FSettingPumpID+0x520>
    f25e:	2d c0       	rjmp	.+90     	; 0xf2ba <FSettingPumpID+0xa4>
    f260:	83 30       	cpi	r24, 0x03	; 3
    f262:	09 f4       	brne	.+2      	; 0xf266 <FSettingPumpID+0x50>
    f264:	51 c1       	rjmp	.+674    	; 0xf508 <FSettingPumpID+0x2f2>
    f266:	84 30       	cpi	r24, 0x04	; 4
    f268:	09 f0       	breq	.+2      	; 0xf26c <FSettingPumpID+0x56>
    f26a:	65 c2       	rjmp	.+1226   	; 0xf736 <FSettingPumpID+0x520>
    f26c:	6a c1       	rjmp	.+724    	; 0xf542 <FSettingPumpID+0x32c>
    f26e:	88 30       	cpi	r24, 0x08	; 8
    f270:	09 f4       	brne	.+2      	; 0xf274 <FSettingPumpID+0x5e>
    f272:	f9 c1       	rjmp	.+1010   	; 0xf666 <FSettingPumpID+0x450>
    f274:	89 30       	cpi	r24, 0x09	; 9
    f276:	38 f4       	brcc	.+14     	; 0xf286 <FSettingPumpID+0x70>
    f278:	86 30       	cpi	r24, 0x06	; 6
    f27a:	09 f4       	brne	.+2      	; 0xf27e <FSettingPumpID+0x68>
    f27c:	98 c1       	rjmp	.+816    	; 0xf5ae <FSettingPumpID+0x398>
    f27e:	87 30       	cpi	r24, 0x07	; 7
    f280:	09 f0       	breq	.+2      	; 0xf284 <FSettingPumpID+0x6e>
    f282:	59 c2       	rjmp	.+1202   	; 0xf736 <FSettingPumpID+0x520>
    f284:	3e c2       	rjmp	.+1148   	; 0xf702 <FSettingPumpID+0x4ec>
    f286:	89 30       	cpi	r24, 0x09	; 9
    f288:	09 f4       	brne	.+2      	; 0xf28c <FSettingPumpID+0x76>
    f28a:	43 c2       	rjmp	.+1158   	; 0xf712 <FSettingPumpID+0x4fc>
    f28c:	8a 30       	cpi	r24, 0x0A	; 10
    f28e:	09 f0       	breq	.+2      	; 0xf292 <FSettingPumpID+0x7c>
    f290:	52 c2       	rjmp	.+1188   	; 0xf736 <FSettingPumpID+0x520>
    f292:	45 c2       	rjmp	.+1162   	; 0xf71e <FSettingPumpID+0x508>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    f294:	80 91 00 01 	lds	r24, 0x0100
    f298:	82 30       	cpi	r24, 0x02	; 2
    f29a:	21 f4       	brne	.+8      	; 0xf2a4 <FSettingPumpID+0x8e>
    f29c:	8f e1       	ldi	r24, 0x1F	; 31
    f29e:	60 e0       	ldi	r22, 0x00	; 0
    f2a0:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    f2a4:	89 e1       	ldi	r24, 0x19	; 25
    f2a6:	92 e0       	ldi	r25, 0x02	; 2
    f2a8:	65 e4       	ldi	r22, 0x45	; 69
    f2aa:	70 e0       	ldi	r23, 0x00	; 0
    f2ac:	48 e0       	ldi	r20, 0x08	; 8
    f2ae:	50 e0       	ldi	r21, 0x00	; 0
    f2b0:	22 e4       	ldi	r18, 0x42	; 66
    f2b2:	33 e1       	ldi	r19, 0x13	; 19
    f2b4:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    f2b8:	49 c1       	rjmp	.+658    	; 0xf54c <FSettingPumpID+0x336>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    f2ba:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    f2be:	e9 e1       	ldi	r30, 0x19	; 25
    f2c0:	ee 2e       	mov	r14, r30
    f2c2:	e2 e0       	ldi	r30, 0x02	; 2
    f2c4:	fe 2e       	mov	r15, r30
    f2c6:	01 e0       	ldi	r16, 0x01	; 1
    f2c8:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    f2ca:	6e 01       	movw	r12, r28
    f2cc:	08 94       	sec
    f2ce:	c1 1c       	adc	r12, r1
    f2d0:	d1 1c       	adc	r13, r1
    f2d2:	71 e9       	ldi	r23, 0x91	; 145
    f2d4:	a7 2e       	mov	r10, r23
    f2d6:	7d e0       	ldi	r23, 0x0D	; 13
    f2d8:	b7 2e       	mov	r11, r23
    f2da:	8d b7       	in	r24, 0x3d	; 61
    f2dc:	9e b7       	in	r25, 0x3e	; 62
    f2de:	0c 97       	sbiw	r24, 0x0c	; 12
    f2e0:	0f b6       	in	r0, 0x3f	; 63
    f2e2:	f8 94       	cli
    f2e4:	9e bf       	out	0x3e, r25	; 62
    f2e6:	0f be       	out	0x3f, r0	; 63
    f2e8:	8d bf       	out	0x3d, r24	; 61
    f2ea:	ed b7       	in	r30, 0x3d	; 61
    f2ec:	fe b7       	in	r31, 0x3e	; 62
    f2ee:	31 96       	adiw	r30, 0x01	; 1
    f2f0:	ad b7       	in	r26, 0x3d	; 61
    f2f2:	be b7       	in	r27, 0x3e	; 62
    f2f4:	12 96       	adiw	r26, 0x02	; 2
    f2f6:	dc 92       	st	X, r13
    f2f8:	ce 92       	st	-X, r12
    f2fa:	11 97       	sbiw	r26, 0x01	; 1
    f2fc:	b3 82       	std	Z+3, r11	; 0x03
    f2fe:	a2 82       	std	Z+2, r10	; 0x02
    f300:	15 83       	std	Z+5, r17	; 0x05
    f302:	04 83       	std	Z+4, r16	; 0x04
    f304:	d7 01       	movw	r26, r14
    f306:	8c 91       	ld	r24, X
    f308:	86 83       	std	Z+6, r24	; 0x06
    f30a:	17 82       	std	Z+7, r1	; 0x07
    f30c:	0c 5f       	subi	r16, 0xFC	; 252
    f30e:	1f 4f       	sbci	r17, 0xFF	; 255
    f310:	11 87       	std	Z+9, r17	; 0x09
    f312:	00 87       	std	Z+8, r16	; 0x08
    f314:	04 50       	subi	r16, 0x04	; 4
    f316:	10 40       	sbci	r17, 0x00	; 0
    f318:	14 96       	adiw	r26, 0x04	; 4
    f31a:	8c 91       	ld	r24, X
    f31c:	82 87       	std	Z+10, r24	; 0x0a
    f31e:	13 86       	std	Z+11, r1	; 0x0b
    f320:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    f324:	ed b7       	in	r30, 0x3d	; 61
    f326:	fe b7       	in	r31, 0x3e	; 62
    f328:	3c 96       	adiw	r30, 0x0c	; 12
    f32a:	0f b6       	in	r0, 0x3f	; 63
    f32c:	f8 94       	cli
    f32e:	fe bf       	out	0x3e, r31	; 62
    f330:	0f be       	out	0x3f, r0	; 63
    f332:	ed bf       	out	0x3d, r30	; 61
    f334:	80 2f       	mov	r24, r16
    f336:	61 e0       	ldi	r22, 0x01	; 1
    f338:	a6 01       	movw	r20, r12
    f33a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    f33e:	08 94       	sec
    f340:	e1 1c       	adc	r14, r1
    f342:	f1 1c       	adc	r15, r1
    f344:	0f 5f       	subi	r16, 0xFF	; 255
    f346:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    f348:	fd e1       	ldi	r31, 0x1D	; 29
    f34a:	ef 16       	cp	r14, r31
    f34c:	f2 e0       	ldi	r31, 0x02	; 2
    f34e:	ff 06       	cpc	r15, r31
    f350:	21 f6       	brne	.-120    	; 0xf2da <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    f352:	83 e0       	ldi	r24, 0x03	; 3
    f354:	6f e0       	ldi	r22, 0x0F	; 15
    f356:	4a e8       	ldi	r20, 0x8A	; 138
    f358:	5d e0       	ldi	r21, 0x0D	; 13
    f35a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    f35e:	84 e0       	ldi	r24, 0x04	; 4
    f360:	6f e0       	ldi	r22, 0x0F	; 15
    f362:	43 e8       	ldi	r20, 0x83	; 131
    f364:	5d e0       	ldi	r21, 0x0D	; 13
    f366:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          stMenuPumpID=mpSelectInput;
    f36a:	82 e0       	ldi	r24, 0x02	; 2
    f36c:	cf c1       	rjmp	.+926    	; 0xf70c <FSettingPumpID+0x4f6>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    f36e:	81 e0       	ldi	r24, 0x01	; 1
    f370:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
    f374:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    f376:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
    f37a:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    f37c:	81 53       	subi	r24, 0x31	; 49
    f37e:	88 30       	cpi	r24, 0x08	; 8
    f380:	08 f0       	brcs	.+2      	; 0xf384 <FSettingPumpID+0x16e>
    f382:	85 c0       	rjmp	.+266    	; 0xf48e <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    f384:	80 91 00 01 	lds	r24, 0x0100
    f388:	81 30       	cpi	r24, 0x01	; 1
    f38a:	19 f0       	breq	.+6      	; 0xf392 <FSettingPumpID+0x17c>
    f38c:	82 30       	cpi	r24, 0x02	; 2
    f38e:	a1 f5       	brne	.+104    	; 0xf3f8 <FSettingPumpID+0x1e2>
    f390:	17 c0       	rjmp	.+46     	; 0xf3c0 <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    f392:	80 91 22 02 	lds	r24, 0x0222
    f396:	88 23       	and	r24, r24
    f398:	41 f4       	brne	.+16     	; 0xf3aa <FSettingPumpID+0x194>
    f39a:	e9 2f       	mov	r30, r25
    f39c:	f0 e0       	ldi	r31, 0x00	; 0
    f39e:	e8 51       	subi	r30, 0x18	; 24
    f3a0:	fe 4f       	sbci	r31, 0xFE	; 254
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    f3a2:	80 81       	ld	r24, Z
    f3a4:	83 36       	cpi	r24, 0x63	; 99
    f3a6:	c8 f4       	brcc	.+50     	; 0xf3da <FSettingPumpID+0x1c4>
    f3a8:	16 c0       	rjmp	.+44     	; 0xf3d6 <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    f3aa:	81 30       	cpi	r24, 0x01	; 1
    f3ac:	29 f5       	brne	.+74     	; 0xf3f8 <FSettingPumpID+0x1e2>
    f3ae:	e9 2f       	mov	r30, r25
    f3b0:	f0 e0       	ldi	r31, 0x00	; 0
    f3b2:	e8 51       	subi	r30, 0x18	; 24
    f3b4:	fe 4f       	sbci	r31, 0xFE	; 254
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    f3b6:	80 81       	ld	r24, Z
    f3b8:	88 23       	and	r24, r24
    f3ba:	d1 f4       	brne	.+52     	; 0xf3f0 <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    f3bc:	83 e6       	ldi	r24, 0x63	; 99
    f3be:	1b c0       	rjmp	.+54     	; 0xf3f6 <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    f3c0:	80 91 22 02 	lds	r24, 0x0222
    f3c4:	88 23       	and	r24, r24
    f3c6:	59 f4       	brne	.+22     	; 0xf3de <FSettingPumpID+0x1c8>
    f3c8:	e9 2f       	mov	r30, r25
    f3ca:	f0 e0       	ldi	r31, 0x00	; 0
    f3cc:	e8 51       	subi	r30, 0x18	; 24
    f3ce:	fe 4f       	sbci	r31, 0xFE	; 254
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    f3d0:	80 81       	ld	r24, Z
    f3d2:	80 31       	cpi	r24, 0x10	; 16
    f3d4:	10 f4       	brcc	.+4      	; 0xf3da <FSettingPumpID+0x1c4>
	     (*Value)++;
    f3d6:	8f 5f       	subi	r24, 0xFF	; 255
    f3d8:	0e c0       	rjmp	.+28     	; 0xf3f6 <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    f3da:	10 82       	st	Z, r1
    f3dc:	0d c0       	rjmp	.+26     	; 0xf3f8 <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    f3de:	81 30       	cpi	r24, 0x01	; 1
    f3e0:	59 f4       	brne	.+22     	; 0xf3f8 <FSettingPumpID+0x1e2>
    f3e2:	e9 2f       	mov	r30, r25
    f3e4:	f0 e0       	ldi	r31, 0x00	; 0
    f3e6:	e8 51       	subi	r30, 0x18	; 24
    f3e8:	fe 4f       	sbci	r31, 0xFE	; 254
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    f3ea:	80 81       	ld	r24, Z
    f3ec:	88 23       	and	r24, r24
    f3ee:	11 f0       	breq	.+4      	; 0xf3f4 <FSettingPumpID+0x1de>
	     (*Value)--;
    f3f0:	81 50       	subi	r24, 0x01	; 1
    f3f2:	01 c0       	rjmp	.+2      	; 0xf3f6 <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    f3f4:	80 e1       	ldi	r24, 0x10	; 16
    f3f6:	80 83       	st	Z, r24
    f3f8:	69 e1       	ldi	r22, 0x19	; 25
    f3fa:	e6 2e       	mov	r14, r22
    f3fc:	62 e0       	ldi	r22, 0x02	; 2
    f3fe:	f6 2e       	mov	r15, r22
    f400:	01 e0       	ldi	r16, 0x01	; 1
    f402:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    f404:	6e 01       	movw	r12, r28
    f406:	08 94       	sec
    f408:	c1 1c       	adc	r12, r1
    f40a:	d1 1c       	adc	r13, r1
    f40c:	5f e6       	ldi	r21, 0x6F	; 111
    f40e:	a5 2e       	mov	r10, r21
    f410:	5d e0       	ldi	r21, 0x0D	; 13
    f412:	b5 2e       	mov	r11, r21
    f414:	8d b7       	in	r24, 0x3d	; 61
    f416:	9e b7       	in	r25, 0x3e	; 62
    f418:	0c 97       	sbiw	r24, 0x0c	; 12
    f41a:	0f b6       	in	r0, 0x3f	; 63
    f41c:	f8 94       	cli
    f41e:	9e bf       	out	0x3e, r25	; 62
    f420:	0f be       	out	0x3f, r0	; 63
    f422:	8d bf       	out	0x3d, r24	; 61
    f424:	ed b7       	in	r30, 0x3d	; 61
    f426:	fe b7       	in	r31, 0x3e	; 62
    f428:	31 96       	adiw	r30, 0x01	; 1
    f42a:	ad b7       	in	r26, 0x3d	; 61
    f42c:	be b7       	in	r27, 0x3e	; 62
    f42e:	12 96       	adiw	r26, 0x02	; 2
    f430:	dc 92       	st	X, r13
    f432:	ce 92       	st	-X, r12
    f434:	11 97       	sbiw	r26, 0x01	; 1
    f436:	b3 82       	std	Z+3, r11	; 0x03
    f438:	a2 82       	std	Z+2, r10	; 0x02
    f43a:	15 83       	std	Z+5, r17	; 0x05
    f43c:	04 83       	std	Z+4, r16	; 0x04
    f43e:	d7 01       	movw	r26, r14
    f440:	8c 91       	ld	r24, X
    f442:	86 83       	std	Z+6, r24	; 0x06
    f444:	17 82       	std	Z+7, r1	; 0x07
    f446:	0c 5f       	subi	r16, 0xFC	; 252
    f448:	1f 4f       	sbci	r17, 0xFF	; 255
    f44a:	11 87       	std	Z+9, r17	; 0x09
    f44c:	00 87       	std	Z+8, r16	; 0x08
    f44e:	04 50       	subi	r16, 0x04	; 4
    f450:	10 40       	sbci	r17, 0x00	; 0
    f452:	14 96       	adiw	r26, 0x04	; 4
    f454:	8c 91       	ld	r24, X
    f456:	82 87       	std	Z+10, r24	; 0x0a
    f458:	13 86       	std	Z+11, r1	; 0x0b
    f45a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    f45e:	ed b7       	in	r30, 0x3d	; 61
    f460:	fe b7       	in	r31, 0x3e	; 62
    f462:	3c 96       	adiw	r30, 0x0c	; 12
    f464:	0f b6       	in	r0, 0x3f	; 63
    f466:	f8 94       	cli
    f468:	fe bf       	out	0x3e, r31	; 62
    f46a:	0f be       	out	0x3f, r0	; 63
    f46c:	ed bf       	out	0x3d, r30	; 61
    f46e:	80 2f       	mov	r24, r16
    f470:	61 e0       	ldi	r22, 0x01	; 1
    f472:	a6 01       	movw	r20, r12
    f474:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    f478:	08 94       	sec
    f47a:	e1 1c       	adc	r14, r1
    f47c:	f1 1c       	adc	r15, r1
    f47e:	0f 5f       	subi	r16, 0xFF	; 255
    f480:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    f482:	fd e1       	ldi	r31, 0x1D	; 29
    f484:	ef 16       	cp	r14, r31
    f486:	f2 e0       	ldi	r31, 0x02	; 2
    f488:	ff 06       	cpc	r15, r31
    f48a:	21 f6       	brne	.-120    	; 0xf414 <FSettingPumpID+0x1fe>
    f48c:	2b c0       	rjmp	.+86     	; 0xf4e4 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    f48e:	93 32       	cpi	r25, 0x23	; 35
    f490:	21 f5       	brne	.+72     	; 0xf4da <FSettingPumpID+0x2c4>
    f492:	40 e0       	ldi	r20, 0x00	; 0
    f494:	20 e0       	ldi	r18, 0x00	; 0
    f496:	30 e0       	ldi	r19, 0x00	; 0
    f498:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    f49a:	f9 01       	movw	r30, r18
    f49c:	e7 5e       	subi	r30, 0xE7	; 231
    f49e:	fd 4f       	sbci	r31, 0xFD	; 253
    f4a0:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    f4a2:	ee 23       	and	r30, r30
    f4a4:	69 f0       	breq	.+26     	; 0xf4c0 <FSettingPumpID+0x2aa>
    f4a6:	a9 e1       	ldi	r26, 0x19	; 25
    f4a8:	b2 e0       	ldi	r27, 0x02	; 2
    f4aa:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    f4ac:	59 17       	cp	r21, r25
    f4ae:	21 f0       	breq	.+8      	; 0xf4b8 <FSettingPumpID+0x2a2>
    f4b0:	8c 91       	ld	r24, X
    f4b2:	e8 17       	cp	r30, r24
    f4b4:	09 f4       	brne	.+2      	; 0xf4b8 <FSettingPumpID+0x2a2>
						       PumpCount++;
    f4b6:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    f4b8:	9f 5f       	subi	r25, 0xFF	; 255
    f4ba:	11 96       	adiw	r26, 0x01	; 1
    f4bc:	98 30       	cpi	r25, 0x08	; 8
    f4be:	b1 f7       	brne	.-20     	; 0xf4ac <FSettingPumpID+0x296>
    f4c0:	2f 5f       	subi	r18, 0xFF	; 255
    f4c2:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    f4c4:	28 30       	cpi	r18, 0x08	; 8
    f4c6:	31 05       	cpc	r19, r1
    f4c8:	39 f7       	brne	.-50     	; 0xf498 <FSettingPumpID+0x282>
    f4ca:	40 93 17 02 	sts	0x0217, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    f4ce:	44 23       	and	r20, r20
    f4d0:	11 f0       	breq	.+4      	; 0xf4d6 <FSettingPumpID+0x2c0>
    f4d2:	83 e0       	ldi	r24, 0x03	; 3
    f4d4:	05 c0       	rjmp	.+10     	; 0xf4e0 <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    f4d6:	85 e0       	ldi	r24, 0x05	; 5
    f4d8:	03 c0       	rjmp	.+6      	; 0xf4e0 <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    f4da:	9a 32       	cpi	r25, 0x2A	; 42
    f4dc:	19 f4       	brne	.+6      	; 0xf4e4 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    f4de:	8a e0       	ldi	r24, 0x0A	; 10
    f4e0:	80 93 23 02 	sts	0x0223, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    f4e4:	8b e7       	ldi	r24, 0x7B	; 123
    f4e6:	98 16       	cp	r9, r24
    f4e8:	09 f0       	breq	.+2      	; 0xf4ec <FSettingPumpID+0x2d6>
    f4ea:	25 c1       	rjmp	.+586    	; 0xf736 <FSettingPumpID+0x520>
		      if (IsShift==False)IsShift=True;
    f4ec:	80 91 22 02 	lds	r24, 0x0222
    f4f0:	88 23       	and	r24, r24
    f4f2:	21 f4       	brne	.+8      	; 0xf4fc <FSettingPumpID+0x2e6>
    f4f4:	81 e0       	ldi	r24, 0x01	; 1
    f4f6:	80 93 22 02 	sts	0x0222, r24
    f4fa:	1d c1       	rjmp	.+570    	; 0xf736 <FSettingPumpID+0x520>
			  else
			  if (IsShift==True)IsShift=False;
    f4fc:	81 30       	cpi	r24, 0x01	; 1
    f4fe:	09 f0       	breq	.+2      	; 0xf502 <FSettingPumpID+0x2ec>
    f500:	1a c1       	rjmp	.+564    	; 0xf736 <FSettingPumpID+0x520>
    f502:	10 92 22 02 	sts	0x0222, r1
    f506:	17 c1       	rjmp	.+558    	; 0xf736 <FSettingPumpID+0x520>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    f508:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    f50c:	81 e0       	ldi	r24, 0x01	; 1
    f50e:	61 e0       	ldi	r22, 0x01	; 1
    f510:	4a e5       	ldi	r20, 0x5A	; 90
    f512:	5d e0       	ldi	r21, 0x0D	; 13
    f514:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    f518:	82 e0       	ldi	r24, 0x02	; 2
    f51a:	61 e0       	ldi	r22, 0x01	; 1
    f51c:	45 e4       	ldi	r20, 0x45	; 69
    f51e:	5d e0       	ldi	r21, 0x0D	; 13
    f520:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    f524:	83 e0       	ldi	r24, 0x03	; 3
    f526:	61 e0       	ldi	r22, 0x01	; 1
    f528:	40 e3       	ldi	r20, 0x30	; 48
    f52a:	5d e0       	ldi	r21, 0x0D	; 13
    f52c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    f530:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    f532:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    f534:	82 e0       	ldi	r24, 0x02	; 2
    f536:	80 93 be 01 	sts	0x01BE, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    f53a:	10 92 94 01 	sts	0x0194, r1
	      stMenuPumpID=mpDisplayFailed;
    f53e:	84 e0       	ldi	r24, 0x04	; 4
    f540:	e5 c0       	rjmp	.+458    	; 0xf70c <FSettingPumpID+0x4f6>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    f542:	80 91 94 01 	lds	r24, 0x0194
    f546:	87 30       	cpi	r24, 0x07	; 7
    f548:	08 f4       	brcc	.+2      	; 0xf54c <FSettingPumpID+0x336>
    f54a:	f5 c0       	rjmp	.+490    	; 0xf736 <FSettingPumpID+0x520>
    f54c:	81 e0       	ldi	r24, 0x01	; 1
    f54e:	de c0       	rjmp	.+444    	; 0xf70c <FSettingPumpID+0x4f6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    f550:	85 e4       	ldi	r24, 0x45	; 69
    f552:	90 e0       	ldi	r25, 0x00	; 0
    f554:	69 e1       	ldi	r22, 0x19	; 25
    f556:	72 e0       	ldi	r23, 0x02	; 2
    f558:	48 e0       	ldi	r20, 0x08	; 8
    f55a:	50 e0       	ldi	r21, 0x00	; 0
    f55c:	2a e4       	ldi	r18, 0x4A	; 74
    f55e:	33 e1       	ldi	r19, 0x13	; 19
    f560:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    f564:	80 91 00 01 	lds	r24, 0x0100
    f568:	82 30       	cpi	r24, 0x02	; 2
    f56a:	e9 f4       	brne	.+58     	; 0xf5a6 <FSettingPumpID+0x390>
		      //SendConfig to Slave
			  lcd_clear();
    f56c:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    f570:	81 e0       	ldi	r24, 0x01	; 1
    f572:	61 e0       	ldi	r22, 0x01	; 1
    f574:	47 e2       	ldi	r20, 0x27	; 39
    f576:	5d e0       	ldi	r21, 0x0D	; 13
    f578:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    f57c:	82 e0       	ldi	r24, 0x02	; 2
    f57e:	61 e0       	ldi	r22, 0x01	; 1
    f580:	4e e1       	ldi	r20, 0x1E	; 30
    f582:	5d e0       	ldi	r21, 0x0D	; 13
    f584:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			  Idx=0;
    f588:	10 92 21 02 	sts	0x0221, r1
			  PumpCount=0;
    f58c:	10 92 17 02 	sts	0x0217, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    f590:	89 e1       	ldi	r24, 0x19	; 25
    f592:	92 e0       	ldi	r25, 0x02	; 2
    f594:	65 e4       	ldi	r22, 0x45	; 69
    f596:	70 e0       	ldi	r23, 0x00	; 0
    f598:	48 e0       	ldi	r20, 0x08	; 8
    f59a:	50 e0       	ldi	r21, 0x00	; 0
    f59c:	22 e4       	ldi	r18, 0x42	; 66
    f59e:	33 e1       	ldi	r19, 0x13	; 19
    f5a0:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
    f5a4:	b2 c0       	rjmp	.+356    	; 0xf70a <FSettingPumpID+0x4f4>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    f5a6:	81 30       	cpi	r24, 0x01	; 1
    f5a8:	09 f0       	breq	.+2      	; 0xf5ac <FSettingPumpID+0x396>
    f5aa:	c5 c0       	rjmp	.+394    	; 0xf736 <FSettingPumpID+0x520>
    f5ac:	b6 c0       	rjmp	.+364    	; 0xf71a <FSettingPumpID+0x504>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    f5ae:	10 92 84 01 	sts	0x0184, r1
	      if (PPumpId[Idx]!=0){
    f5b2:	90 91 21 02 	lds	r25, 0x0221
    f5b6:	29 2f       	mov	r18, r25
    f5b8:	30 e0       	ldi	r19, 0x00	; 0
    f5ba:	f9 01       	movw	r30, r18
    f5bc:	e7 5e       	subi	r30, 0xE7	; 231
    f5be:	fd 4f       	sbci	r31, 0xFD	; 253
    f5c0:	60 81       	ld	r22, Z
    f5c2:	66 23       	and	r22, r22
    f5c4:	81 f0       	breq	.+32     	; 0xf5e6 <FSettingPumpID+0x3d0>
		      PumpCount++;
    f5c6:	80 91 17 02 	lds	r24, 0x0217
    f5ca:	8f 5f       	subi	r24, 0xFF	; 255
    f5cc:	80 93 17 02 	sts	0x0217, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    f5d0:	6f 70       	andi	r22, 0x0F	; 15
    f5d2:	44 e0       	ldi	r20, 0x04	; 4
    f5d4:	22 0f       	add	r18, r18
    f5d6:	33 1f       	adc	r19, r19
    f5d8:	4a 95       	dec	r20
    f5da:	e1 f7       	brne	.-8      	; 0xf5d4 <FSettingPumpID+0x3be>
    f5dc:	62 2b       	or	r22, r18
    f5de:	60 93 18 02 	sts	0x0218, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    f5e2:	8d e1       	ldi	r24, 0x1D	; 29
    f5e4:	02 c0       	rjmp	.+4      	; 0xf5ea <FSettingPumpID+0x3d4>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    f5e6:	8e e1       	ldi	r24, 0x1E	; 30
    f5e8:	69 2f       	mov	r22, r25
    f5ea:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    f5ee:	e0 91 21 02 	lds	r30, 0x0221
    f5f2:	f0 e0       	ldi	r31, 0x00	; 0
    f5f4:	ad b7       	in	r26, 0x3d	; 61
    f5f6:	be b7       	in	r27, 0x3e	; 62
    f5f8:	18 97       	sbiw	r26, 0x08	; 8
    f5fa:	0f b6       	in	r0, 0x3f	; 63
    f5fc:	f8 94       	cli
    f5fe:	be bf       	out	0x3e, r27	; 62
    f600:	0f be       	out	0x3f, r0	; 63
    f602:	ad bf       	out	0x3d, r26	; 61
    f604:	2d b7       	in	r18, 0x3d	; 61
    f606:	3e b7       	in	r19, 0x3e	; 62
    f608:	2f 5f       	subi	r18, 0xFF	; 255
    f60a:	3f 4f       	sbci	r19, 0xFF	; 255
    f60c:	8e 01       	movw	r16, r28
    f60e:	0f 5f       	subi	r16, 0xFF	; 255
    f610:	1f 4f       	sbci	r17, 0xFF	; 255
    f612:	12 96       	adiw	r26, 0x02	; 2
    f614:	1c 93       	st	X, r17
    f616:	0e 93       	st	-X, r16
    f618:	11 97       	sbiw	r26, 0x01	; 1
    f61a:	80 e1       	ldi	r24, 0x10	; 16
    f61c:	9d e0       	ldi	r25, 0x0D	; 13
    f61e:	d9 01       	movw	r26, r18
    f620:	13 96       	adiw	r26, 0x03	; 3
    f622:	9c 93       	st	X, r25
    f624:	8e 93       	st	-X, r24
    f626:	12 97       	sbiw	r26, 0x02	; 2
    f628:	31 96       	adiw	r30, 0x01	; 1
    f62a:	15 96       	adiw	r26, 0x05	; 5
    f62c:	fc 93       	st	X, r31
    f62e:	ee 93       	st	-X, r30
    f630:	14 97       	sbiw	r26, 0x04	; 4
    f632:	31 97       	sbiw	r30, 0x01	; 1
    f634:	e7 5e       	subi	r30, 0xE7	; 231
    f636:	fd 4f       	sbci	r31, 0xFD	; 253
    f638:	80 81       	ld	r24, Z
    f63a:	16 96       	adiw	r26, 0x06	; 6
    f63c:	8c 93       	st	X, r24
    f63e:	16 97       	sbiw	r26, 0x06	; 6
    f640:	17 96       	adiw	r26, 0x07	; 7
    f642:	1c 92       	st	X, r1
    f644:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    f648:	ed b7       	in	r30, 0x3d	; 61
    f64a:	fe b7       	in	r31, 0x3e	; 62
    f64c:	38 96       	adiw	r30, 0x08	; 8
    f64e:	0f b6       	in	r0, 0x3f	; 63
    f650:	f8 94       	cli
    f652:	fe bf       	out	0x3e, r31	; 62
    f654:	0f be       	out	0x3f, r0	; 63
    f656:	ed bf       	out	0x3d, r30	; 61
    f658:	83 e0       	ldi	r24, 0x03	; 3
    f65a:	61 e0       	ldi	r22, 0x01	; 1
    f65c:	a8 01       	movw	r20, r16
    f65e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    f662:	88 e0       	ldi	r24, 0x08	; 8
    f664:	53 c0       	rjmp	.+166    	; 0xf70c <FSettingPumpID+0x4f6>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    f666:	81 e0       	ldi	r24, 0x01	; 1
    f668:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    f66c:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  if (KeyChar=='*'){
    f670:	8a 32       	cpi	r24, 0x2A	; 42
    f672:	79 f4       	brne	.+30     	; 0xf692 <FSettingPumpID+0x47c>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    f674:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    f676:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    f678:	82 e0       	ldi	r24, 0x02	; 2
    f67a:	80 93 be 01 	sts	0x01BE, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    f67e:	61 e0       	ldi	r22, 0x01	; 1
    f680:	44 e0       	ldi	r20, 0x04	; 4
    f682:	5d e0       	ldi	r21, 0x0D	; 13
    f684:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			  TimDisplay=0;
    f688:	10 92 94 01 	sts	0x0194, r1
		      stMenuPumpID=mpDelayExitPumpId;
    f68c:	89 e0       	ldi	r24, 0x09	; 9
    f68e:	80 93 23 02 	sts	0x0223, r24
			  }
          if (IsStandaloneAcknoledge==True){
    f692:	80 91 84 01 	lds	r24, 0x0184
    f696:	81 30       	cpi	r24, 0x01	; 1
    f698:	09 f0       	breq	.+2      	; 0xf69c <FSettingPumpID+0x486>
    f69a:	4d c0       	rjmp	.+154    	; 0xf736 <FSettingPumpID+0x520>
		      Idx++;
    f69c:	80 91 21 02 	lds	r24, 0x0221
    f6a0:	8f 5f       	subi	r24, 0xFF	; 255
    f6a2:	80 93 21 02 	sts	0x0221, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    f6a6:	88 30       	cpi	r24, 0x08	; 8
    f6a8:	10 f5       	brcc	.+68     	; 0xf6ee <FSettingPumpID+0x4d8>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    f6aa:	20 91 17 02 	lds	r18, 0x0217
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f6ae:	e1 99       	sbic	0x1c, 1	; 28
    f6b0:	fe cf       	rjmp	.-4      	; 0xf6ae <FSettingPumpID+0x498>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f6b2:	84 e4       	ldi	r24, 0x44	; 68
    f6b4:	91 e0       	ldi	r25, 0x01	; 1
    f6b6:	9f bb       	out	0x1f, r25	; 31
    f6b8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    f6ba:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    f6bc:	0f b6       	in	r0, 0x3f	; 63
    f6be:	f8 94       	cli
    f6c0:	e2 9a       	sbi	0x1c, 2	; 28
    f6c2:	e1 9a       	sbi	0x1c, 1	; 28
    f6c4:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f6c6:	e1 99       	sbic	0x1c, 1	; 28
    f6c8:	fe cf       	rjmp	.-4      	; 0xf6c6 <FSettingPumpID+0x4b0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f6ca:	9f bb       	out	0x1f, r25	; 31
    f6cc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f6ce:	e0 9a       	sbi	0x1c, 0	; 28
    f6d0:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    f6d2:	90 93 4e 01 	sts	0x014E, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    f6d6:	85 e1       	ldi	r24, 0x15	; 21
    f6d8:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
    f6dc:	90 93 e0 0d 	sts	0x0DE0, r25
     IsControlPooling=True;
    f6e0:	81 e0       	ldi	r24, 0x01	; 1
    f6e2:	80 93 86 01 	sts	0x0186, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    f6e6:	10 92 94 01 	sts	0x0194, r1
				  stMenuPumpID=mpDelaySaveConfig;
    f6ea:	87 e0       	ldi	r24, 0x07	; 7
    f6ec:	0f c0       	rjmp	.+30     	; 0xf70c <FSettingPumpID+0x4f6>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    f6ee:	82 e0       	ldi	r24, 0x02	; 2
    f6f0:	61 e0       	ldi	r22, 0x01	; 1
    f6f2:	4a ef       	ldi	r20, 0xFA	; 250
    f6f4:	5c e0       	ldi	r21, 0x0C	; 12
    f6f6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					TimDisplay=0;
    f6fa:	10 92 94 01 	sts	0x0194, r1
				    stMenuPumpID=mpDelayExitPumpId;
    f6fe:	89 e0       	ldi	r24, 0x09	; 9
    f700:	05 c0       	rjmp	.+10     	; 0xf70c <FSettingPumpID+0x4f6>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    f702:	80 91 94 01 	lds	r24, 0x0194
    f706:	83 30       	cpi	r24, 0x03	; 3
    f708:	b0 f0       	brcs	.+44     	; 0xf736 <FSettingPumpID+0x520>
    f70a:	86 e0       	ldi	r24, 0x06	; 6
    f70c:	80 93 23 02 	sts	0x0223, r24
    f710:	12 c0       	rjmp	.+36     	; 0xf736 <FSettingPumpID+0x520>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    f712:	80 91 94 01 	lds	r24, 0x0194
    f716:	89 30       	cpi	r24, 0x09	; 9
    f718:	70 f0       	brcs	.+28     	; 0xf736 <FSettingPumpID+0x520>
    f71a:	8a e0       	ldi	r24, 0x0A	; 10
    f71c:	f7 cf       	rjmp	.-18     	; 0xf70c <FSettingPumpID+0x4f6>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    f71e:	80 91 00 01 	lds	r24, 0x0100
    f722:	82 30       	cpi	r24, 0x02	; 2
    f724:	21 f4       	brne	.+8      	; 0xf72e <FSettingPumpID+0x518>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    f726:	80 e2       	ldi	r24, 0x20	; 32
    f728:	60 e0       	ldi	r22, 0x00	; 0
    f72a:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    f72e:	10 92 23 02 	sts	0x0223, r1
    f732:	81 e0       	ldi	r24, 0x01	; 1
    f734:	01 c0       	rjmp	.+2      	; 0xf738 <FSettingPumpID+0x522>
    f736:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    f738:	64 96       	adiw	r28, 0x14	; 20
    f73a:	0f b6       	in	r0, 0x3f	; 63
    f73c:	f8 94       	cli
    f73e:	de bf       	out	0x3e, r29	; 62
    f740:	0f be       	out	0x3f, r0	; 63
    f742:	cd bf       	out	0x3d, r28	; 61
    f744:	cf 91       	pop	r28
    f746:	df 91       	pop	r29
    f748:	1f 91       	pop	r17
    f74a:	0f 91       	pop	r16
    f74c:	ff 90       	pop	r15
    f74e:	ef 90       	pop	r14
    f750:	df 90       	pop	r13
    f752:	cf 90       	pop	r12
    f754:	bf 90       	pop	r11
    f756:	af 90       	pop	r10
    f758:	9f 90       	pop	r9
    f75a:	08 95       	ret

0000f75c <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    f75c:	0e 94 0b 79 	call	0xf216	; 0xf216 <FSettingPumpID>
    f760:	81 30       	cpi	r24, 0x01	; 1
    f762:	e1 f7       	brne	.-8      	; 0xf75c <_menu_pumpid>
	       break;
	   }	   
	}
}
    f764:	08 95       	ret

0000f766 <_menu_pump>:
        lcd_printf(4,15,PSTR("*)Exit"));
}



void _menu_pump(void){
    f766:	cf 93       	push	r28
    f768:	df 93       	push	r29
    f76a:	c4 ec       	ldi	r28, 0xC4	; 196
    f76c:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    f76e:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    f772:	ce 01       	movw	r24, r28
    f774:	01 97       	sbiw	r24, 0x01	; 1
    f776:	f1 f7       	brne	.-4      	; 0xf774 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    f778:	81 e0       	ldi	r24, 0x01	; 1
    f77a:	61 e0       	ldi	r22, 0x01	; 1
    f77c:	4e e2       	ldi	r20, 0x2E	; 46
    f77e:	5e e0       	ldi	r21, 0x0E	; 14
    f780:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    f784:	82 e0       	ldi	r24, 0x02	; 2
    f786:	61 e0       	ldi	r22, 0x01	; 1
    f788:	44 e2       	ldi	r20, 0x24	; 36
    f78a:	5e e0       	ldi	r21, 0x0E	; 14
    f78c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    f790:	84 e0       	ldi	r24, 0x04	; 4
    f792:	61 e0       	ldi	r22, 0x01	; 1
    f794:	4d e1       	ldi	r20, 0x1D	; 29
    f796:	5e e0       	ldi	r21, 0x0E	; 14
    f798:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>

		while(1){
			__key = _key_scan(1);
    f79c:	81 e0       	ldi	r24, 0x01	; 1
    f79e:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
			if(__key == _KEY_CANCEL)
    f7a2:	87 3e       	cpi	r24, 0xE7	; 231
    f7a4:	51 f0       	breq	.+20     	; 0xf7ba <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    f7a6:	8e 3e       	cpi	r24, 0xEE	; 238
    f7a8:	19 f4       	brne	.+6      	; 0xf7b0 <_menu_pump+0x4a>
				_menu_pumpid();
    f7aa:	0e 94 ae 7b 	call	0xf75c	; 0xf75c <_menu_pumpid>
    f7ae:	df cf       	rjmp	.-66     	; 0xf76e <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    f7b0:	8e 3d       	cpi	r24, 0xDE	; 222
    f7b2:	a1 f7       	brne	.-24     	; 0xf79c <_menu_pump+0x36>
				_menu_pumpprod();
    f7b4:	0e 94 1d 65 	call	0xca3a	; 0xca3a <_menu_pumpprod>
    f7b8:	da cf       	rjmp	.-76     	; 0xf76e <_menu_pump+0x8>
				break;
			}
		}
	}
}
    f7ba:	df 91       	pop	r29
    f7bc:	cf 91       	pop	r28
    f7be:	08 95       	ret

0000f7c0 <FMenuPumpType>:





void FMenuPumpType(){
    f7c0:	cf 92       	push	r12
    f7c2:	df 92       	push	r13
    f7c4:	ef 92       	push	r14
    f7c6:	ff 92       	push	r15
    f7c8:	0f 93       	push	r16
    f7ca:	1f 93       	push	r17
    f7cc:	df 93       	push	r29
    f7ce:	cf 93       	push	r28
    f7d0:	cd b7       	in	r28, 0x3d	; 61
    f7d2:	de b7       	in	r29, 0x3e	; 62
    f7d4:	a8 97       	sbiw	r28, 0x28	; 40
    f7d6:	0f b6       	in	r0, 0x3f	; 63
    f7d8:	f8 94       	cli
    f7da:	de bf       	out	0x3e, r29	; 62
    f7dc:	0f be       	out	0x3f, r0	; 63
    f7de:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    f7e0:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    f7e4:	81 e0       	ldi	r24, 0x01	; 1
    f7e6:	61 e0       	ldi	r22, 0x01	; 1
    f7e8:	4b e0       	ldi	r20, 0x0B	; 11
    f7ea:	5e e0       	ldi	r21, 0x0E	; 14
    f7ec:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f7f0:	e1 99       	sbic	0x1c, 1	; 28
    f7f2:	fe cf       	rjmp	.-4      	; 0xf7f0 <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f7f4:	87 e3       	ldi	r24, 0x37	; 55
    f7f6:	91 e0       	ldi	r25, 0x01	; 1
    f7f8:	9f bb       	out	0x1f, r25	; 31
    f7fa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f7fc:	e0 9a       	sbi	0x1c, 0	; 28
    f7fe:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    f800:	03 30       	cpi	r16, 0x03	; 3
    f802:	08 f0       	brcs	.+2      	; 0xf806 <FMenuPumpType+0x46>
    f804:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    f806:	10 e0       	ldi	r17, 0x00	; 0
    f808:	f8 01       	movw	r30, r16
    f80a:	ee 0f       	add	r30, r30
    f80c:	ff 1f       	adc	r31, r31
    f80e:	eb 50       	subi	r30, 0x0B	; 11
    f810:	fd 4f       	sbci	r31, 0xFD	; 253
    f812:	65 91       	lpm	r22, Z+
    f814:	74 91       	lpm	r23, Z+
    f816:	f5 e1       	ldi	r31, 0x15	; 21
    f818:	cf 2e       	mov	r12, r31
    f81a:	d1 2c       	mov	r13, r1
    f81c:	cc 0e       	add	r12, r28
    f81e:	dd 1e       	adc	r13, r29
    f820:	c6 01       	movw	r24, r12
    f822:	0e 94 ec b0 	call	0x161d8	; 0x161d8 <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    f826:	8d b7       	in	r24, 0x3d	; 61
    f828:	9e b7       	in	r25, 0x3e	; 62
    f82a:	08 97       	sbiw	r24, 0x08	; 8
    f82c:	0f b6       	in	r0, 0x3f	; 63
    f82e:	f8 94       	cli
    f830:	9e bf       	out	0x3e, r25	; 62
    f832:	0f be       	out	0x3f, r0	; 63
    f834:	8d bf       	out	0x3d, r24	; 61
    f836:	ed b7       	in	r30, 0x3d	; 61
    f838:	fe b7       	in	r31, 0x3e	; 62
    f83a:	31 96       	adiw	r30, 0x01	; 1
    f83c:	7e 01       	movw	r14, r28
    f83e:	08 94       	sec
    f840:	e1 1c       	adc	r14, r1
    f842:	f1 1c       	adc	r15, r1
    f844:	ad b7       	in	r26, 0x3d	; 61
    f846:	be b7       	in	r27, 0x3e	; 62
    f848:	12 96       	adiw	r26, 0x02	; 2
    f84a:	fc 92       	st	X, r15
    f84c:	ee 92       	st	-X, r14
    f84e:	11 97       	sbiw	r26, 0x01	; 1
    f850:	85 e0       	ldi	r24, 0x05	; 5
    f852:	9e e0       	ldi	r25, 0x0E	; 14
    f854:	93 83       	std	Z+3, r25	; 0x03
    f856:	82 83       	std	Z+2, r24	; 0x02
    f858:	0f 5f       	subi	r16, 0xFF	; 255
    f85a:	1f 4f       	sbci	r17, 0xFF	; 255
    f85c:	15 83       	std	Z+5, r17	; 0x05
    f85e:	04 83       	std	Z+4, r16	; 0x04
    f860:	d7 82       	std	Z+7, r13	; 0x07
    f862:	c6 82       	std	Z+6, r12	; 0x06
    f864:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			   lcd_print(2,1,lcdteks);
    f868:	8d b7       	in	r24, 0x3d	; 61
    f86a:	9e b7       	in	r25, 0x3e	; 62
    f86c:	08 96       	adiw	r24, 0x08	; 8
    f86e:	0f b6       	in	r0, 0x3f	; 63
    f870:	f8 94       	cli
    f872:	9e bf       	out	0x3e, r25	; 62
    f874:	0f be       	out	0x3f, r0	; 63
    f876:	8d bf       	out	0x3d, r24	; 61
    f878:	82 e0       	ldi	r24, 0x02	; 2
    f87a:	61 e0       	ldi	r22, 0x01	; 1
    f87c:	a7 01       	movw	r20, r14
    f87e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    f882:	84 e0       	ldi	r24, 0x04	; 4
    f884:	61 e0       	ldi	r22, 0x01	; 1
    f886:	41 ef       	ldi	r20, 0xF1	; 241
    f888:	5d e0       	ldi	r21, 0x0D	; 13
    f88a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   if (IFType==IT_STANDALONE)
    f88e:	80 91 00 01 	lds	r24, 0x0100
    f892:	82 30       	cpi	r24, 0x02	; 2
    f894:	21 f4       	brne	.+8      	; 0xf89e <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    f896:	8f e1       	ldi	r24, 0x1F	; 31
    f898:	60 e0       	ldi	r22, 0x00	; 0
    f89a:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    f89e:	81 e0       	ldi	r24, 0x01	; 1
    f8a0:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    f8a4:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>

			   if (KeyChar=='#'){
    f8a8:	83 32       	cpi	r24, 0x23	; 35
    f8aa:	09 f0       	breq	.+2      	; 0xf8ae <FMenuPumpType+0xee>
    f8ac:	2d c0       	rjmp	.+90     	; 0xf908 <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f8ae:	e1 99       	sbic	0x1c, 1	; 28
    f8b0:	fe cf       	rjmp	.-4      	; 0xf8ae <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f8b2:	07 e3       	ldi	r16, 0x37	; 55
    f8b4:	11 e0       	ldi	r17, 0x01	; 1
    f8b6:	1f bb       	out	0x1f, r17	; 31
    f8b8:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f8ba:	e0 9a       	sbi	0x1c, 0	; 28
    f8bc:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    f8be:	82 30       	cpi	r24, 0x02	; 2
    f8c0:	20 f4       	brcc	.+8      	; 0xf8ca <FMenuPumpType+0x10a>
				        DispenserBrand++;
    f8c2:	8f 5f       	subi	r24, 0xFF	; 255
    f8c4:	80 93 50 01 	sts	0x0150, r24
    f8c8:	02 c0       	rjmp	.+4      	; 0xf8ce <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    f8ca:	10 92 50 01 	sts	0x0150, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    f8ce:	80 91 50 01 	lds	r24, 0x0150
    f8d2:	0e 94 a3 1a 	call	0x3546	; 0x3546 <SetDispenser>
			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    f8d6:	80 91 50 01 	lds	r24, 0x0150
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f8da:	e1 99       	sbic	0x1c, 1	; 28
    f8dc:	fe cf       	rjmp	.-4      	; 0xf8da <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f8de:	1f bb       	out	0x1f, r17	; 31
    f8e0:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    f8e2:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f8e4:	0f b6       	in	r0, 0x3f	; 63
    f8e6:	f8 94       	cli
    f8e8:	e2 9a       	sbi	0x1c, 2	; 28
    f8ea:	e1 9a       	sbi	0x1c, 1	; 28
    f8ec:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f8ee:	e1 99       	sbic	0x1c, 1	; 28
    f8f0:	fe cf       	rjmp	.-4      	; 0xf8ee <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f8f2:	1f bb       	out	0x1f, r17	; 31
    f8f4:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f8f6:	e0 9a       	sbi	0x1c, 0	; 28
    f8f8:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    f8fa:	8c e1       	ldi	r24, 0x1C	; 28
    f8fc:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    f900:	81 e0       	ldi	r24, 0x01	; 1
    f902:	80 93 13 01 	sts	0x0113, r24
    f906:	0c c0       	rjmp	.+24     	; 0xf920 <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    f908:	8a 32       	cpi	r24, 0x2A	; 42
    f90a:	09 f0       	breq	.+2      	; 0xf90e <FMenuPumpType+0x14e>
    f90c:	c8 cf       	rjmp	.-112    	; 0xf89e <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    f90e:	80 91 00 01 	lds	r24, 0x0100
    f912:	82 30       	cpi	r24, 0x02	; 2
    f914:	51 f4       	brne	.+20     	; 0xf92a <FMenuPumpType+0x16a>
    f916:	80 e2       	ldi	r24, 0x20	; 32
    f918:	60 e0       	ldi	r22, 0x00	; 0
    f91a:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
    f91e:	05 c0       	rjmp	.+10     	; 0xf92a <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    f920:	80 91 13 01 	lds	r24, 0x0113
    f924:	81 30       	cpi	r24, 0x01	; 1
    f926:	e1 f7       	brne	.-8      	; 0xf920 <FMenuPumpType+0x160>
    f928:	5b cf       	rjmp	.-330    	; 0xf7e0 <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    f92a:	a8 96       	adiw	r28, 0x28	; 40
    f92c:	0f b6       	in	r0, 0x3f	; 63
    f92e:	f8 94       	cli
    f930:	de bf       	out	0x3e, r29	; 62
    f932:	0f be       	out	0x3f, r0	; 63
    f934:	cd bf       	out	0x3d, r28	; 61
    f936:	cf 91       	pop	r28
    f938:	df 91       	pop	r29
    f93a:	1f 91       	pop	r17
    f93c:	0f 91       	pop	r16
    f93e:	ff 90       	pop	r15
    f940:	ef 90       	pop	r14
    f942:	df 90       	pop	r13
    f944:	cf 90       	pop	r12
    f946:	08 95       	ret

0000f948 <FSettingPump>:
	      break;
	 
	 }
*/
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    f948:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
    f94c:	84 ec       	ldi	r24, 0xC4	; 196
    f94e:	99 e0       	ldi	r25, 0x09	; 9
    f950:	01 97       	sbiw	r24, 0x01	; 1
    f952:	f1 f7       	brne	.-4      	; 0xf950 <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    f954:	81 e0       	ldi	r24, 0x01	; 1
    f956:	61 e0       	ldi	r22, 0x01	; 1
    f958:	4a e8       	ldi	r20, 0x8A	; 138
    f95a:	52 e1       	ldi	r21, 0x12	; 18
    f95c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    f960:	82 e0       	ldi	r24, 0x02	; 2
    f962:	61 e0       	ldi	r22, 0x01	; 1
    f964:	40 e8       	ldi	r20, 0x80	; 128
    f966:	52 e1       	ldi	r21, 0x12	; 18
    f968:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		if (IFType==IT_STANDALONE){
    f96c:	80 91 00 01 	lds	r24, 0x0100
    f970:	82 30       	cpi	r24, 0x02	; 2
    f972:	61 f4       	brne	.+24     	; 0xf98c <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    f974:	83 e0       	ldi	r24, 0x03	; 3
    f976:	61 e0       	ldi	r22, 0x01	; 1
    f978:	46 e7       	ldi	r20, 0x76	; 118
    f97a:	52 e1       	ldi	r21, 0x12	; 18
    f97c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    f980:	84 e0       	ldi	r24, 0x04	; 4
    f982:	61 e0       	ldi	r22, 0x01	; 1
    f984:	46 e6       	ldi	r20, 0x66	; 102
    f986:	52 e1       	ldi	r21, 0x12	; 18
    f988:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    f98c:	81 e0       	ldi	r24, 0x01	; 1
    f98e:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
			if(__key == _KEY_CANCEL)
    f992:	87 3e       	cpi	r24, 0xE7	; 231
    f994:	d9 f0       	breq	.+54     	; 0xf9cc <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    f996:	8e 3e       	cpi	r24, 0xEE	; 238
    f998:	19 f4       	brne	.+6      	; 0xf9a0 <FSettingPump+0x58>
				_menu_pumpid();
    f99a:	0e 94 ae 7b 	call	0xf75c	; 0xf75c <_menu_pumpid>
    f99e:	16 c0       	rjmp	.+44     	; 0xf9cc <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    f9a0:	8e 3d       	cpi	r24, 0xDE	; 222
    f9a2:	19 f4       	brne	.+6      	; 0xf9aa <FSettingPump+0x62>
				_menu_pumpprod();
    f9a4:	0e 94 1d 65 	call	0xca3a	; 0xca3a <_menu_pumpprod>
    f9a8:	11 c0       	rjmp	.+34     	; 0xf9cc <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    f9aa:	8e 3b       	cpi	r24, 0xBE	; 190
    f9ac:	39 f4       	brne	.+14     	; 0xf9bc <FSettingPump+0x74>
    f9ae:	80 91 00 01 	lds	r24, 0x0100
    f9b2:	82 30       	cpi	r24, 0x02	; 2
    f9b4:	59 f7       	brne	.-42     	; 0xf98c <FSettingPump+0x44>
			    FMenuPumpLabel();
    f9b6:	0e 94 30 65 	call	0xca60	; 0xca60 <FMenuPumpLabel>
    f9ba:	08 c0       	rjmp	.+16     	; 0xf9cc <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    f9bc:	8d 3e       	cpi	r24, 0xED	; 237
    f9be:	31 f7       	brne	.-52     	; 0xf98c <FSettingPump+0x44>
    f9c0:	80 91 00 01 	lds	r24, 0x0100
    f9c4:	82 30       	cpi	r24, 0x02	; 2
    f9c6:	11 f7       	brne	.-60     	; 0xf98c <FSettingPump+0x44>
			    FMenuPumpType();
    f9c8:	0e 94 e0 7b 	call	0xf7c0	; 0xf7c0 <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    f9cc:	81 e0       	ldi	r24, 0x01	; 1
    f9ce:	08 95       	ret

0000f9d0 <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
    f9d0:	af 92       	push	r10
    f9d2:	bf 92       	push	r11
    f9d4:	cf 92       	push	r12
    f9d6:	df 92       	push	r13
    f9d8:	ef 92       	push	r14
    f9da:	ff 92       	push	r15
    f9dc:	0f 93       	push	r16
    f9de:	1f 93       	push	r17
    f9e0:	df 93       	push	r29
    f9e2:	cf 93       	push	r28
    f9e4:	cd b7       	in	r28, 0x3d	; 61
    f9e6:	de b7       	in	r29, 0x3e	; 62
    f9e8:	64 97       	sbiw	r28, 0x14	; 20
    f9ea:	0f b6       	in	r0, 0x3f	; 63
    f9ec:	f8 94       	cli
    f9ee:	de bf       	out	0x3e, r29	; 62
    f9f0:	0f be       	out	0x3f, r0	; 63
    f9f2:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f9f4:	e1 99       	sbic	0x1c, 1	; 28
    f9f6:	fe cf       	rjmp	.-4      	; 0xf9f4 <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f9f8:	06 e3       	ldi	r16, 0x36	; 54
    f9fa:	a0 2e       	mov	r10, r16
    f9fc:	01 e0       	ldi	r16, 0x01	; 1
    f9fe:	b0 2e       	mov	r11, r16
    fa00:	bf ba       	out	0x1f, r11	; 31
    fa02:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    fa04:	e0 9a       	sbi	0x1c, 0	; 28
    fa06:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0,KeyPressed;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
    fa08:	90 93 00 01 	sts	0x0100, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    fa0c:	e1 99       	sbic	0x1c, 1	; 28
    fa0e:	fe cf       	rjmp	.-4      	; 0xfa0c <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fa10:	17 e3       	ldi	r17, 0x37	; 55
    fa12:	c1 2e       	mov	r12, r17
    fa14:	11 e0       	ldi	r17, 0x01	; 1
    fa16:	d1 2e       	mov	r13, r17
    fa18:	df ba       	out	0x1f, r13	; 31
    fa1a:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    fa1c:	e0 9a       	sbi	0x1c, 0	; 28
    fa1e:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    fa20:	80 93 50 01 	sts	0x0150, r24

	//SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);

    //Send Msg10
	if  (IFType==IT_SLAVE){
    fa24:	91 30       	cpi	r25, 0x01	; 1
    fa26:	09 f0       	breq	.+2      	; 0xfa2a <InitializeConnection+0x5a>
    fa28:	5f c0       	rjmp	.+190    	; 0xfae8 <InitializeConnection+0x118>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
    fa2a:	81 e0       	ldi	r24, 0x01	; 1
    fa2c:	60 e0       	ldi	r22, 0x00	; 0
    fa2e:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
		 char_count=0;
    fa32:	10 92 8c 01 	sts	0x018C, r1
    fa36:	10 92 8b 01 	sts	0x018B, r1
		 if (IsPowerOn==True){
    fa3a:	80 91 c3 02 	lds	r24, 0x02C3
    fa3e:	81 30       	cpi	r24, 0x01	; 1
    fa40:	59 f4       	brne	.+22     	; 0xfa58 <InitializeConnection+0x88>
		     IsPowerOn=False;
    fa42:	10 92 c3 02 	sts	0x02C3, r1
    fa46:	8f ef       	ldi	r24, 0xFF	; 255
    fa48:	9f ef       	ldi	r25, 0xFF	; 255
    fa4a:	29 e1       	ldi	r18, 0x19	; 25
    fa4c:	30 e0       	ldi	r19, 0x00	; 0
    fa4e:	f9 01       	movw	r30, r18
    fa50:	31 97       	sbiw	r30, 0x01	; 1
    fa52:	f1 f7       	brne	.-4      	; 0xfa50 <InitializeConnection+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    fa54:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    fa56:	d9 f7       	brne	.-10     	; 0xfa4e <InitializeConnection+0x7e>
		     _delay_ms(8000);
			 }
         sendMessage10();
    fa58:	0e 94 77 50 	call	0xa0ee	; 0xa0ee <sendMessage10>
         sendMessage10();
    fa5c:	0e 94 77 50 	call	0xa0ee	; 0xa0ee <sendMessage10>
         sendMessage10();
    fa60:	0e 94 77 50 	call	0xa0ee	; 0xa0ee <sendMessage10>
         

         lcd_printf(4,1,PSTR("Connect         "));
    fa64:	84 e0       	ldi	r24, 0x04	; 4
    fa66:	61 e0       	ldi	r22, 0x01	; 1
    fa68:	43 e9       	ldi	r20, 0x93	; 147
    fa6a:	5d e1       	ldi	r21, 0x1D	; 29
    fa6c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
    fa70:	84 e0       	ldi	r24, 0x04	; 4
    fa72:	61 e0       	ldi	r22, 0x01	; 1
    fa74:	4b e8       	ldi	r20, 0x8B	; 139
    fa76:	5d e1       	ldi	r21, 0x1D	; 29
    fa78:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
    fa7c:	10 92 a2 01 	sts	0x01A2, r1
    fa80:	ee 24       	eor	r14, r14
    fa82:	ff 24       	eor	r15, r15
    fa84:	10 e0       	ldi	r17, 0x00	; 0
    fa86:	00 e0       	ldi	r16, 0x00	; 0
    fa88:	2b c0       	rjmp	.+86     	; 0xfae0 <InitializeConnection+0x110>
		  //SlaveIdentification		  
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
    fa8a:	61 2f       	mov	r22, r17
    fa8c:	68 5f       	subi	r22, 0xF8	; 248
    fa8e:	84 e0       	ldi	r24, 0x04	; 4
    fa90:	4e e2       	ldi	r20, 0x2E	; 46
    fa92:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
                tConnect++;
    fa96:	08 94       	sec
    fa98:	e1 1c       	adc	r14, r1
    fa9a:	f1 1c       	adc	r15, r1
				__key_lgtcnt=0;
    fa9c:	10 92 b8 02 	sts	0x02B8, r1
			    if ((tConnect%200)==0)iCon++;
    faa0:	c7 01       	movw	r24, r14
    faa2:	68 ec       	ldi	r22, 0xC8	; 200
    faa4:	70 e0       	ldi	r23, 0x00	; 0
    faa6:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    faaa:	89 2b       	or	r24, r25
    faac:	09 f4       	brne	.+2      	; 0xfab0 <InitializeConnection+0xe0>
    faae:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>8){
    fab0:	19 30       	cpi	r17, 0x09	; 9
    fab2:	70 f0       	brcs	.+28     	; 0xfad0 <InitializeConnection+0x100>
			        lcd_printf(4,1,PSTR("Connect         "));
    fab4:	84 e0       	ldi	r24, 0x04	; 4
    fab6:	61 e0       	ldi	r22, 0x01	; 1
    fab8:	4a e7       	ldi	r20, 0x7A	; 122
    faba:	5d e1       	ldi	r21, 0x1D	; 29
    fabc:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					
				    sendMessage10();
    fac0:	0e 94 77 50 	call	0xa0ee	; 0xa0ee <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
    fac4:	81 e0       	ldi	r24, 0x01	; 1
    fac6:	60 e0       	ldi	r22, 0x00	; 0
    fac8:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
    facc:	0f 5f       	subi	r16, 0xFF	; 255
    face:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
    fad0:	04 30       	cpi	r16, 0x04	; 4
    fad2:	30 f0       	brcs	.+12     	; 0xfae0 <InitializeConnection+0x110>
			        //IsErrorTCPIP=True;
				    IsAdvanzStartupInfo=False;		
    fad4:	10 92 ac 01 	sts	0x01AC, r1
					IFType=IT_STANDALONE;
    fad8:	82 e0       	ldi	r24, 0x02	; 2
    fada:	80 93 00 01 	sts	0x0100, r24
    fade:	04 c0       	rjmp	.+8      	; 0xfae8 <InitializeConnection+0x118>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification		  
		 while (IsMessage11==False){
    fae0:	80 91 a2 01 	lds	r24, 0x01A2
    fae4:	88 23       	and	r24, r24
    fae6:	89 f2       	breq	.-94     	; 0xfa8a <InitializeConnection+0xba>

			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
    fae8:	80 91 00 01 	lds	r24, 0x0100
    faec:	82 30       	cpi	r24, 0x02	; 2
    faee:	09 f0       	breq	.+2      	; 0xfaf2 <InitializeConnection+0x122>
    faf0:	74 c0       	rjmp	.+232    	; 0xfbda <InitializeConnection+0x20a>
        IsStandAloneDetected=False;		
    faf2:	10 92 9e 01 	sts	0x019E, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    faf6:	60 91 50 01 	lds	r22, 0x0150
    fafa:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
    fafe:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
    fb02:	81 e0       	ldi	r24, 0x01	; 1
    fb04:	61 e0       	ldi	r22, 0x01	; 1
    fb06:	40 e7       	ldi	r20, 0x70	; 112
    fb08:	5d e1       	ldi	r21, 0x1D	; 29
    fb0a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    fb0e:	e1 99       	sbic	0x1c, 1	; 28
    fb10:	fe cf       	rjmp	.-4      	; 0xfb0e <InitializeConnection+0x13e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fb12:	df ba       	out	0x1f, r13	; 31
    fb14:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    fb16:	e0 9a       	sbi	0x1c, 0	; 28
    fb18:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
    fb1a:	e8 2f       	mov	r30, r24
    fb1c:	f0 e0       	ldi	r31, 0x00	; 0
    fb1e:	ee 0f       	add	r30, r30
    fb20:	ff 1f       	adc	r31, r31
    fb22:	eb 50       	subi	r30, 0x0B	; 11
    fb24:	fd 4f       	sbci	r31, 0xFD	; 253
    fb26:	65 91       	lpm	r22, Z+
    fb28:	74 91       	lpm	r23, Z+
    fb2a:	8e 01       	movw	r16, r28
    fb2c:	0f 5f       	subi	r16, 0xFF	; 255
    fb2e:	1f 4f       	sbci	r17, 0xFF	; 255
    fb30:	c8 01       	movw	r24, r16
    fb32:	0e 94 ec b0 	call	0x161d8	; 0x161d8 <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
    fb36:	00 d0       	rcall	.+0      	; 0xfb38 <InitializeConnection+0x168>
    fb38:	00 d0       	rcall	.+0      	; 0xfb3a <InitializeConnection+0x16a>
    fb3a:	00 d0       	rcall	.+0      	; 0xfb3c <InitializeConnection+0x16c>
    fb3c:	ed b7       	in	r30, 0x3d	; 61
    fb3e:	fe b7       	in	r31, 0x3e	; 62
    fb40:	31 96       	adiw	r30, 0x01	; 1
    fb42:	ad b7       	in	r26, 0x3d	; 61
    fb44:	be b7       	in	r27, 0x3e	; 62
    fb46:	12 96       	adiw	r26, 0x02	; 2
    fb48:	1c 93       	st	X, r17
    fb4a:	0e 93       	st	-X, r16
    fb4c:	11 97       	sbiw	r26, 0x01	; 1
    fb4e:	8d e6       	ldi	r24, 0x6D	; 109
    fb50:	9d e1       	ldi	r25, 0x1D	; 29
    fb52:	93 83       	std	Z+3, r25	; 0x03
    fb54:	82 83       	std	Z+2, r24	; 0x02
    fb56:	15 83       	std	Z+5, r17	; 0x05
    fb58:	04 83       	std	Z+4, r16	; 0x04
    fb5a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	    lcd_print(2,1,lcdteks);
    fb5e:	8d b7       	in	r24, 0x3d	; 61
    fb60:	9e b7       	in	r25, 0x3e	; 62
    fb62:	06 96       	adiw	r24, 0x06	; 6
    fb64:	0f b6       	in	r0, 0x3f	; 63
    fb66:	f8 94       	cli
    fb68:	9e bf       	out	0x3e, r25	; 62
    fb6a:	0f be       	out	0x3f, r0	; 63
    fb6c:	8d bf       	out	0x3d, r24	; 61
    fb6e:	82 e0       	ldi	r24, 0x02	; 2
    fb70:	61 e0       	ldi	r22, 0x01	; 1
    fb72:	a8 01       	movw	r20, r16
    fb74:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
    fb78:	00 e0       	ldi	r16, 0x00	; 0
    fb7a:	10 e0       	ldi	r17, 0x00	; 0
    fb7c:	ff 24       	eor	r15, r15
    fb7e:	dd 24       	eor	r13, r13
    fb80:	28 c0       	rjmp	.+80     	; 0xfbd2 <InitializeConnection+0x202>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
    fb82:	ef 2c       	mov	r14, r15
    fb84:	e3 94       	inc	r14
    fb86:	84 e0       	ldi	r24, 0x04	; 4
    fb88:	6e 2d       	mov	r22, r14
    fb8a:	4e e2       	ldi	r20, 0x2E	; 46
    fb8c:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
		       tConnect++;
    fb90:	0f 5f       	subi	r16, 0xFF	; 255
    fb92:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
    fb94:	c8 01       	movw	r24, r16
    fb96:	64 e6       	ldi	r22, 0x64	; 100
    fb98:	70 e0       	ldi	r23, 0x00	; 0
    fb9a:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
    fb9e:	89 2b       	or	r24, r25
    fba0:	09 f4       	brne	.+2      	; 0xfba4 <InitializeConnection+0x1d4>
    fba2:	fe 2c       	mov	r15, r14
		       if (iCon>16){
    fba4:	90 e1       	ldi	r25, 0x10	; 16
    fba6:	9f 15       	cp	r25, r15
    fba8:	88 f4       	brcc	.+34     	; 0xfbcc <InitializeConnection+0x1fc>
			       __key_lgtcnt=0;
    fbaa:	10 92 b8 02 	sts	0x02B8, r1
			       lcd_printf(4,1,PSTR("                   "));
    fbae:	84 e0       	ldi	r24, 0x04	; 4
    fbb0:	61 e0       	ldi	r22, 0x01	; 1
    fbb2:	49 e5       	ldi	r20, 0x59	; 89
    fbb4:	5d e1       	ldi	r21, 0x1D	; 29
    fbb6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    fbba:	82 e0       	ldi	r24, 0x02	; 2
    fbbc:	60 91 50 01 	lds	r22, 0x0150
    fbc0:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
    fbc4:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
    fbc8:	d3 94       	inc	r13
    fbca:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
    fbcc:	a3 e0       	ldi	r26, 0x03	; 3
    fbce:	ad 15       	cp	r26, r13
    fbd0:	20 f0       	brcs	.+8      	; 0xfbda <InitializeConnection+0x20a>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
    fbd2:	80 91 9e 01 	lds	r24, 0x019E
    fbd6:	88 23       	and	r24, r24
    fbd8:	a1 f2       	breq	.-88     	; 0xfb82 <InitializeConnection+0x1b2>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
    fbda:	80 91 a2 01 	lds	r24, 0x01A2
    fbde:	81 30       	cpi	r24, 0x01	; 1
    fbe0:	b9 f4       	brne	.+46     	; 0xfc10 <InitializeConnection+0x240>
	   lcd_printf(4,1,PSTR("Connected           "));
    fbe2:	84 e0       	ldi	r24, 0x04	; 4
    fbe4:	61 e0       	ldi	r22, 0x01	; 1
    fbe6:	44 e4       	ldi	r20, 0x44	; 68
    fbe8:	5d e1       	ldi	r21, 0x1D	; 29
    fbea:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    fbee:	e1 99       	sbic	0x1c, 1	; 28
    fbf0:	fe cf       	rjmp	.-4      	; 0xfbee <InitializeConnection+0x21e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fbf2:	bf ba       	out	0x1f, r11	; 31
    fbf4:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    fbf6:	11 e0       	ldi	r17, 0x01	; 1
    fbf8:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    fbfa:	0f b6       	in	r0, 0x3f	; 63
    fbfc:	f8 94       	cli
    fbfe:	e2 9a       	sbi	0x1c, 2	; 28
    fc00:	e1 9a       	sbi	0x1c, 1	; 28
    fc02:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
    fc04:	10 93 00 01 	sts	0x0100, r17
	   //IsErrorTCPIP=False;
	   procMessage11();
    fc08:	0e 94 fb 5b 	call	0xb7f6	; 0xb7f6 <procMessage11>
	   IsAdvanzStartupInfo=True;
    fc0c:	10 93 ac 01 	sts	0x01AC, r17
	}
	if(IsStandAloneDetected==True){
    fc10:	80 91 9e 01 	lds	r24, 0x019E
    fc14:	81 30       	cpi	r24, 0x01	; 1
    fc16:	99 f4       	brne	.+38     	; 0xfc3e <InitializeConnection+0x26e>
	   lcd_printf(4,1,PSTR("PumpFound"));
    fc18:	84 e0       	ldi	r24, 0x04	; 4
    fc1a:	61 e0       	ldi	r22, 0x01	; 1
    fc1c:	4a e3       	ldi	r20, 0x3A	; 58
    fc1e:	5d e1       	ldi	r21, 0x1D	; 29
    fc20:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    fc24:	e1 99       	sbic	0x1c, 1	; 28
    fc26:	fe cf       	rjmp	.-4      	; 0xfc24 <InitializeConnection+0x254>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fc28:	bf ba       	out	0x1f, r11	; 31
    fc2a:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    fc2c:	82 e0       	ldi	r24, 0x02	; 2
    fc2e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    fc30:	0f b6       	in	r0, 0x3f	; 63
    fc32:	f8 94       	cli
    fc34:	e2 9a       	sbi	0x1c, 2	; 28
    fc36:	e1 9a       	sbi	0x1c, 1	; 28
    fc38:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
    fc3a:	80 93 00 01 	sts	0x0100, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    fc3e:	e1 99       	sbic	0x1c, 1	; 28
    fc40:	fe cf       	rjmp	.-4      	; 0xfc3e <InitializeConnection+0x26e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fc42:	85 e3       	ldi	r24, 0x35	; 53
    fc44:	91 e0       	ldi	r25, 0x01	; 1
    fc46:	9f bb       	out	0x1f, r25	; 31
    fc48:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    fc4a:	e0 9a       	sbi	0x1c, 0	; 28
    fc4c:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
    fc4e:	81 30       	cpi	r24, 0x01	; 1
    fc50:	11 f4       	brne	.+4      	; 0xfc56 <InitializeConnection+0x286>
    fc52:	0e 94 2a 38 	call	0x7054	; 0x7054 <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
    fc56:	80 91 9e 01 	lds	r24, 0x019E
    fc5a:	88 23       	and	r24, r24
    fc5c:	09 f0       	breq	.+2      	; 0xfc60 <InitializeConnection+0x290>
    fc5e:	38 c0       	rjmp	.+112    	; 0xfcd0 <InitializeConnection+0x300>
    fc60:	80 91 a2 01 	lds	r24, 0x01A2
    fc64:	88 23       	and	r24, r24
    fc66:	09 f0       	breq	.+2      	; 0xfc6a <InitializeConnection+0x29a>
    fc68:	33 c0       	rjmp	.+102    	; 0xfcd0 <InitializeConnection+0x300>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
    fc6a:	82 e0       	ldi	r24, 0x02	; 2
    fc6c:	61 e0       	ldi	r22, 0x01	; 1
    fc6e:	4d e2       	ldi	r20, 0x2D	; 45
    fc70:	5d e1       	ldi	r21, 0x1D	; 29
    fc72:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
    fc76:	83 e0       	ldi	r24, 0x03	; 3
    fc78:	61 e0       	ldi	r22, 0x01	; 1
    fc7a:	4f e1       	ldi	r20, 0x1F	; 31
    fc7c:	5d e1       	ldi	r21, 0x1D	; 29
    fc7e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
    fc82:	80 e2       	ldi	r24, 0x20	; 32
    fc84:	9e e4       	ldi	r25, 0x4E	; 78
    fc86:	29 e1       	ldi	r18, 0x19	; 25
    fc88:	30 e0       	ldi	r19, 0x00	; 0
    fc8a:	f9 01       	movw	r30, r18
    fc8c:	31 97       	sbiw	r30, 0x01	; 1
    fc8e:	f1 f7       	brne	.-4      	; 0xfc8c <InitializeConnection+0x2bc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    fc90:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    fc92:	d9 f7       	brne	.-10     	; 0xfc8a <InitializeConnection+0x2ba>
		 _delay_ms(2000);
		 ForceType=systemForceType();
    fc94:	0e 94 7f 68 	call	0xd0fe	; 0xd0fe <systemForceType>
		 if (ForceType=='1'){
    fc98:	81 33       	cpi	r24, 0x31	; 49
    fc9a:	29 f4       	brne	.+10     	; 0xfca6 <InitializeConnection+0x2d6>
		     IFType=IT_SLAVE;
    fc9c:	81 e0       	ldi	r24, 0x01	; 1
    fc9e:	80 93 00 01 	sts	0x0100, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
    fca2:	60 e0       	ldi	r22, 0x00	; 0
    fca4:	07 c0       	rjmp	.+14     	; 0xfcb4 <InitializeConnection+0x2e4>
         }
		 else
		 if (ForceType=='2'){
    fca6:	82 33       	cpi	r24, 0x32	; 50
    fca8:	39 f4       	brne	.+14     	; 0xfcb8 <InitializeConnection+0x2e8>
		     IFType=IT_STANDALONE;
    fcaa:	82 e0       	ldi	r24, 0x02	; 2
    fcac:	80 93 00 01 	sts	0x0100, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    fcb0:	60 91 50 01 	lds	r22, 0x0150
    fcb4:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
    fcb8:	80 91 00 01 	lds	r24, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    fcbc:	e1 99       	sbic	0x1c, 1	; 28
    fcbe:	fe cf       	rjmp	.-4      	; 0xfcbc <InitializeConnection+0x2ec>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fcc0:	bf ba       	out	0x1f, r11	; 31
    fcc2:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    fcc4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    fcc6:	0f b6       	in	r0, 0x3f	; 63
    fcc8:	f8 94       	cli
    fcca:	e2 9a       	sbi	0x1c, 2	; 28
    fccc:	e1 9a       	sbi	0x1c, 1	; 28
    fcce:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    fcd0:	e1 99       	sbic	0x1c, 1	; 28
    fcd2:	fe cf       	rjmp	.-4      	; 0xfcd0 <InitializeConnection+0x300>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fcd4:	84 e4       	ldi	r24, 0x44	; 68
    fcd6:	91 e0       	ldi	r25, 0x01	; 1
    fcd8:	9f bb       	out	0x1f, r25	; 31
    fcda:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    fcdc:	e0 9a       	sbi	0x1c, 0	; 28
    fcde:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    fce0:	80 93 4e 01 	sts	0x014E, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    fce4:	e1 99       	sbic	0x1c, 1	; 28
    fce6:	fe cf       	rjmp	.-4      	; 0xfce4 <InitializeConnection+0x314>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fce8:	89 e4       	ldi	r24, 0x49	; 73
    fcea:	91 e0       	ldi	r25, 0x01	; 1
    fcec:	9f bb       	out	0x1f, r25	; 31
    fcee:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    fcf0:	e0 9a       	sbi	0x1c, 0	; 28
    fcf2:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    fcf4:	80 93 4f 01 	sts	0x014F, r24
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
	//SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
}
    fcf8:	64 96       	adiw	r28, 0x14	; 20
    fcfa:	0f b6       	in	r0, 0x3f	; 63
    fcfc:	f8 94       	cli
    fcfe:	de bf       	out	0x3e, r29	; 62
    fd00:	0f be       	out	0x3f, r0	; 63
    fd02:	cd bf       	out	0x3d, r28	; 61
    fd04:	cf 91       	pop	r28
    fd06:	df 91       	pop	r29
    fd08:	1f 91       	pop	r17
    fd0a:	0f 91       	pop	r16
    fd0c:	ff 90       	pop	r15
    fd0e:	ef 90       	pop	r14
    fd10:	df 90       	pop	r13
    fd12:	cf 90       	pop	r12
    fd14:	bf 90       	pop	r11
    fd16:	af 90       	pop	r10
    fd18:	08 95       	ret

0000fd1a <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    fd1a:	2f 92       	push	r2
    fd1c:	3f 92       	push	r3
    fd1e:	4f 92       	push	r4
    fd20:	5f 92       	push	r5
    fd22:	6f 92       	push	r6
    fd24:	7f 92       	push	r7
    fd26:	8f 92       	push	r8
    fd28:	9f 92       	push	r9
    fd2a:	af 92       	push	r10
    fd2c:	bf 92       	push	r11
    fd2e:	cf 92       	push	r12
    fd30:	df 92       	push	r13
    fd32:	ef 92       	push	r14
    fd34:	ff 92       	push	r15
    fd36:	0f 93       	push	r16
    fd38:	1f 93       	push	r17
    fd3a:	df 93       	push	r29
    fd3c:	cf 93       	push	r28
    fd3e:	cd b7       	in	r28, 0x3d	; 61
    fd40:	de b7       	in	r29, 0x3e	; 62
    fd42:	e1 97       	sbiw	r28, 0x31	; 49
    fd44:	0f b6       	in	r0, 0x3f	; 63
    fd46:	f8 94       	cli
    fd48:	de bf       	out	0x3e, r29	; 62
    fd4a:	0f be       	out	0x3f, r0	; 63
    fd4c:	cd bf       	out	0x3d, r28	; 61
    fd4e:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    fd50:	dc 01       	movw	r26, r24
    fd52:	12 96       	adiw	r26, 0x02	; 2
    fd54:	8c 91       	ld	r24, X
    fd56:	12 97       	sbiw	r26, 0x02	; 2
    fd58:	89 83       	std	Y+1, r24	; 0x01
    fd5a:	13 96       	adiw	r26, 0x03	; 3
    fd5c:	8c 91       	ld	r24, X
    fd5e:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    fd60:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    fd62:	8e 01       	movw	r16, r28
    fd64:	0f 5f       	subi	r16, 0xFF	; 255
    fd66:	1f 4f       	sbci	r17, 0xFF	; 255
    fd68:	c8 01       	movw	r24, r16
    fd6a:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    fd6e:	c8 01       	movw	r24, r16
    fd70:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
    fd74:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    fd76:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
    fd7a:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    fd7c:	88 23       	and	r24, r24
    fd7e:	09 f4       	brne	.+2      	; 0xfd82 <StoreStandaloneTransData+0x68>
    fd80:	1a c2       	rjmp	.+1076   	; 0x101b6 <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    fd82:	f7 01       	movw	r30, r14
    fd84:	f4 81       	ldd	r31, Z+4	; 0x04
    fd86:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    fd88:	d7 01       	movw	r26, r14
    fd8a:	15 96       	adiw	r26, 0x05	; 5
    fd8c:	2c 90       	ld	r2, X
    fd8e:	34 e0       	ldi	r19, 0x04	; 4
    fd90:	83 2e       	mov	r8, r19
    fd92:	91 2c       	mov	r9, r1
    fd94:	8c 0e       	add	r8, r28
    fd96:	9d 1e       	adc	r9, r29
    fd98:	f4 01       	movw	r30, r8
    fd9a:	ce 01       	movw	r24, r28
    fd9c:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    fd9e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    fda0:	e8 17       	cp	r30, r24
    fda2:	f9 07       	cpc	r31, r25
    fda4:	e1 f7       	brne	.-8      	; 0xfd9e <StoreStandaloneTransData+0x84>
    fda6:	2d e1       	ldi	r18, 0x1D	; 29
    fda8:	62 2e       	mov	r6, r18
    fdaa:	71 2c       	mov	r7, r1
    fdac:	6c 0e       	add	r6, r28
    fdae:	7d 1e       	adc	r7, r29
    fdb0:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    fdb2:	ce 01       	movw	r24, r28
    fdb4:	87 96       	adiw	r24, 0x27	; 39
    fdb6:	f9 01       	movw	r30, r18
    fdb8:	11 92       	st	Z+, r1
    fdba:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    fdbc:	e8 17       	cp	r30, r24
    fdbe:	f9 07       	cpc	r31, r25
    fdc0:	d1 f7       	brne	.-12     	; 0xfdb6 <StoreStandaloneTransData+0x9c>
    fdc2:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    fdc4:	ce 01       	movw	r24, r28
    fdc6:	c1 96       	adiw	r24, 0x31	; 49
    fdc8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    fdca:	e8 17       	cp	r30, r24
    fdcc:	f9 07       	cpc	r31, r25
    fdce:	e1 f7       	brne	.-8      	; 0xfdc8 <StoreStandaloneTransData+0xae>
    fdd0:	a7 01       	movw	r20, r14
    fdd2:	d7 01       	movw	r26, r14
    fdd4:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fdd6:	be 01       	movw	r22, r28
    fdd8:	66 5f       	subi	r22, 0xF6	; 246
    fdda:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    fddc:	16 96       	adiw	r26, 0x06	; 6
    fdde:	8c 91       	ld	r24, X
    fde0:	16 97       	sbiw	r26, 0x06	; 6
    fde2:	81 93       	st	Z+, r24
    fde4:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fde6:	e6 17       	cp	r30, r22
    fde8:	f7 07       	cpc	r31, r23
    fdea:	c1 f7       	brne	.-16     	; 0xfddc <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    fdec:	1a 86       	std	Y+10, r1	; 0x0a
    fdee:	d7 01       	movw	r26, r14
    fdf0:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fdf2:	be 01       	movw	r22, r28
    fdf4:	6b 5d       	subi	r22, 0xDB	; 219
    fdf6:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    fdf8:	1c 96       	adiw	r26, 0x0c	; 12
    fdfa:	8c 91       	ld	r24, X
    fdfc:	1c 97       	sbiw	r26, 0x0c	; 12
    fdfe:	81 93       	st	Z+, r24
    fe00:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fe02:	e6 17       	cp	r30, r22
    fe04:	f7 07       	cpc	r31, r23
    fe06:	c1 f7       	brne	.-16     	; 0xfdf8 <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    fe08:	1d a2       	std	Y+37, r1	; 0x25
    fe0a:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fe0c:	be 01       	movw	r22, r28
    fe0e:	69 5d       	subi	r22, 0xD9	; 217
    fe10:	7f 4f       	sbci	r23, 0xFF	; 255
    fe12:	9e 01       	movw	r18, r28
    fe14:	21 5d       	subi	r18, 0xD1	; 209
    fe16:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    fe18:	da 01       	movw	r26, r20
    fe1a:	54 96       	adiw	r26, 0x14	; 20
    fe1c:	8c 91       	ld	r24, X
    fe1e:	81 93       	st	Z+, r24
    fe20:	4f 5f       	subi	r20, 0xFF	; 255
    fe22:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fe24:	e2 17       	cp	r30, r18
    fe26:	f3 07       	cpc	r31, r19
    fe28:	b9 f7       	brne	.-18     	; 0xfe18 <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    fe2a:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    fe2c:	f7 01       	movw	r30, r14
    fe2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    fe30:	80 53       	subi	r24, 0x30	; 48
    fe32:	8a 30       	cpi	r24, 0x0A	; 10
    fe34:	98 f4       	brcc	.+38     	; 0xfe5c <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //uart_print(1,1,strSend);
		 if  (TransDigit==8){
    fe36:	88 30       	cpi	r24, 0x08	; 8
    fe38:	89 f4       	brne	.+34     	; 0xfe5c <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    fe3a:	fb 01       	movw	r30, r22
    fe3c:	01 90       	ld	r0, Z+
    fe3e:	00 20       	and	r0, r0
    fe40:	e9 f7       	brne	.-6      	; 0xfe3c <StoreStandaloneTransData+0x122>
    fe42:	e6 1b       	sub	r30, r22
    fe44:	f7 0b       	sbc	r31, r23
    fe46:	32 97       	sbiw	r30, 0x02	; 2
    fe48:	80 e0       	ldi	r24, 0x00	; 0
    fe4a:	90 e0       	ldi	r25, 0x00	; 0
    fe4c:	01 c0       	rjmp	.+2      	; 0xfe50 <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fe4e:	01 96       	adiw	r24, 0x01	; 1
    fe50:	8e 17       	cp	r24, r30
    fe52:	9f 07       	cpc	r25, r31
    fe54:	e0 f3       	brcs	.-8      	; 0xfe4e <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    fe56:	ec 0f       	add	r30, r28
    fe58:	fd 1f       	adc	r31, r29
    fe5a:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    fe5c:	94 e0       	ldi	r25, 0x04	; 4
    fe5e:	e9 2e       	mov	r14, r25
    fe60:	f1 2c       	mov	r15, r1
    fe62:	ec 0e       	add	r14, r28
    fe64:	fd 1e       	adc	r15, r29
    fe66:	c7 01       	movw	r24, r14
    fe68:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		 RemZeroLead(strPVolume);
    fe6c:	8d e1       	ldi	r24, 0x1D	; 29
    fe6e:	a8 2e       	mov	r10, r24
    fe70:	b1 2c       	mov	r11, r1
    fe72:	ac 0e       	add	r10, r28
    fe74:	bd 1e       	adc	r11, r29
    fe76:	c5 01       	movw	r24, r10
    fe78:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		 RemZeroLead(strPMoney);
    fe7c:	8e 01       	movw	r16, r28
    fe7e:	09 5d       	subi	r16, 0xD9	; 217
    fe80:	1f 4f       	sbci	r17, 0xFF	; 255
    fe82:	c8 01       	movw	r24, r16
    fe84:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    fe88:	c8 01       	movw	r24, r16
    fe8a:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
    fe8e:	89 2b       	or	r24, r25
    fe90:	09 f0       	breq	.+2      	; 0xfe94 <StoreStandaloneTransData+0x17a>
    fe92:	46 c1       	rjmp	.+652    	; 0x10120 <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    fe94:	83 2d       	mov	r24, r3
    fe96:	8f 70       	andi	r24, 0x0F	; 15
    fe98:	63 e1       	ldi	r22, 0x13	; 19
    fe9a:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
    fe9e:	8b c1       	rjmp	.+790    	; 0x101b6 <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    fea0:	e1 99       	sbic	0x1c, 1	; 28
    fea2:	fe cf       	rjmp	.-4      	; 0xfea0 <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fea4:	8f e3       	ldi	r24, 0x3F	; 63
    fea6:	91 e0       	ldi	r25, 0x01	; 1
    fea8:	9f bb       	out	0x1f, r25	; 31
    feaa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    feac:	e0 9a       	sbi	0x1c, 0	; 28
    feae:	2d b3       	in	r18, 0x1d	; 29
			 //uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    feb0:	00 d0       	rcall	.+0      	; 0xfeb2 <StoreStandaloneTransData+0x198>
    feb2:	00 d0       	rcall	.+0      	; 0xfeb4 <StoreStandaloneTransData+0x19a>
    feb4:	00 d0       	rcall	.+0      	; 0xfeb6 <StoreStandaloneTransData+0x19c>
    feb6:	ed b7       	in	r30, 0x3d	; 61
    feb8:	fe b7       	in	r31, 0x3e	; 62
    feba:	31 96       	adiw	r30, 0x01	; 1
    febc:	81 e8       	ldi	r24, 0x81	; 129
    febe:	9e e0       	ldi	r25, 0x0E	; 14
    fec0:	ad b7       	in	r26, 0x3d	; 61
    fec2:	be b7       	in	r27, 0x3e	; 62
    fec4:	12 96       	adiw	r26, 0x02	; 2
    fec6:	9c 93       	st	X, r25
    fec8:	8e 93       	st	-X, r24
    feca:	11 97       	sbiw	r26, 0x01	; 1
    fecc:	8b ed       	ldi	r24, 0xDB	; 219
    fece:	92 e2       	ldi	r25, 0x22	; 34
    fed0:	93 83       	std	Z+3, r25	; 0x03
    fed2:	82 83       	std	Z+2, r24	; 0x02
    fed4:	24 83       	std	Z+4, r18	; 0x04
    fed6:	15 82       	std	Z+5, r1	; 0x05
    fed8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    fedc:	e0 ea       	ldi	r30, 0xA0	; 160
    fede:	fe e0       	ldi	r31, 0x0E	; 14
    fee0:	df 01       	movw	r26, r30
    fee2:	0d 90       	ld	r0, X+
    fee4:	00 20       	and	r0, r0
    fee6:	e9 f7       	brne	.-6      	; 0xfee2 <StoreStandaloneTransData+0x1c8>
    fee8:	9d 01       	movw	r18, r26
    feea:	21 50       	subi	r18, 0x01	; 1
    feec:	30 40       	sbci	r19, 0x00	; 0
    feee:	2e 1b       	sub	r18, r30
    fef0:	3f 0b       	sbc	r19, r31
    fef2:	85 e3       	ldi	r24, 0x35	; 53
    fef4:	90 e0       	ldi	r25, 0x00	; 0
    fef6:	c8 9e       	mul	r12, r24
    fef8:	d0 01       	movw	r26, r0
    fefa:	c9 9e       	mul	r12, r25
    fefc:	b0 0d       	add	r27, r0
    fefe:	d8 9e       	mul	r13, r24
    ff00:	b0 0d       	add	r27, r0
    ff02:	11 24       	eor	r1, r1
    ff04:	ac 54       	subi	r26, 0x4C	; 76
    ff06:	ba 4f       	sbci	r27, 0xFA	; 250
    ff08:	4d b7       	in	r20, 0x3d	; 61
    ff0a:	5e b7       	in	r21, 0x3e	; 62
    ff0c:	4a 5f       	subi	r20, 0xFA	; 250
    ff0e:	5f 4f       	sbci	r21, 0xFF	; 255
    ff10:	0f b6       	in	r0, 0x3f	; 63
    ff12:	f8 94       	cli
    ff14:	5e bf       	out	0x3e, r21	; 62
    ff16:	0f be       	out	0x3f, r0	; 63
    ff18:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ff1a:	a9 01       	movw	r20, r18
    ff1c:	4e 0f       	add	r20, r30
    ff1e:	5f 1f       	adc	r21, r31
    ff20:	02 c0       	rjmp	.+4      	; 0xff26 <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    ff22:	81 91       	ld	r24, Z+
    ff24:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ff26:	e4 17       	cp	r30, r20
    ff28:	f5 07       	cpc	r31, r21
    ff2a:	d9 f7       	brne	.-10     	; 0xff22 <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ff2c:	85 e3       	ldi	r24, 0x35	; 53
    ff2e:	90 e0       	ldi	r25, 0x00	; 0
    ff30:	dc 01       	movw	r26, r24
    ff32:	ca 9e       	mul	r12, r26
    ff34:	c0 01       	movw	r24, r0
    ff36:	cb 9e       	mul	r12, r27
    ff38:	90 0d       	add	r25, r0
    ff3a:	da 9e       	mul	r13, r26
    ff3c:	90 0d       	add	r25, r0
    ff3e:	11 24       	eor	r1, r1
    ff40:	fc 01       	movw	r30, r24
    ff42:	ef 54       	subi	r30, 0x4F	; 79
    ff44:	fa 4f       	sbci	r31, 0xFA	; 250
    ff46:	e2 0f       	add	r30, r18
    ff48:	f3 1f       	adc	r31, r19
    ff4a:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    ff4c:	fe 01       	movw	r30, r28
    ff4e:	3b 96       	adiw	r30, 0x0b	; 11
    ff50:	df 01       	movw	r26, r30
    ff52:	0d 90       	ld	r0, X+
    ff54:	00 20       	and	r0, r0
    ff56:	e9 f7       	brne	.-6      	; 0xff52 <StoreStandaloneTransData+0x238>
    ff58:	11 97       	sbiw	r26, 0x01	; 1
    ff5a:	ae 1b       	sub	r26, r30
    ff5c:	bf 0b       	sbc	r27, r31
    ff5e:	bf 01       	movw	r22, r30
    ff60:	9c 01       	movw	r18, r24
    ff62:	25 54       	subi	r18, 0x45	; 69
    ff64:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ff66:	af 01       	movw	r20, r30
    ff68:	4a 0f       	add	r20, r26
    ff6a:	5b 1f       	adc	r21, r27
    ff6c:	06 c0       	rjmp	.+12     	; 0xff7a <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    ff6e:	fb 01       	movw	r30, r22
    ff70:	81 91       	ld	r24, Z+
    ff72:	bf 01       	movw	r22, r30
    ff74:	f9 01       	movw	r30, r18
    ff76:	81 93       	st	Z+, r24
    ff78:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ff7a:	64 17       	cp	r22, r20
    ff7c:	75 07       	cpc	r23, r21
    ff7e:	b9 f7       	brne	.-18     	; 0xff6e <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ff80:	85 e3       	ldi	r24, 0x35	; 53
    ff82:	90 e0       	ldi	r25, 0x00	; 0
    ff84:	9c 01       	movw	r18, r24
    ff86:	c2 9e       	mul	r12, r18
    ff88:	c0 01       	movw	r24, r0
    ff8a:	c3 9e       	mul	r12, r19
    ff8c:	90 0d       	add	r25, r0
    ff8e:	d2 9e       	mul	r13, r18
    ff90:	90 0d       	add	r25, r0
    ff92:	11 24       	eor	r1, r1
    ff94:	fc 01       	movw	r30, r24
    ff96:	ef 54       	subi	r30, 0x4F	; 79
    ff98:	fa 4f       	sbci	r31, 0xFA	; 250
    ff9a:	ea 0f       	add	r30, r26
    ff9c:	fb 1f       	adc	r31, r27
    ff9e:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    ffa0:	fe 01       	movw	r30, r28
    ffa2:	74 96       	adiw	r30, 0x14	; 20
    ffa4:	df 01       	movw	r26, r30
    ffa6:	0d 90       	ld	r0, X+
    ffa8:	00 20       	and	r0, r0
    ffaa:	e9 f7       	brne	.-6      	; 0xffa6 <StoreStandaloneTransData+0x28c>
    ffac:	11 97       	sbiw	r26, 0x01	; 1
    ffae:	ae 1b       	sub	r26, r30
    ffb0:	bf 0b       	sbc	r27, r31
    ffb2:	bf 01       	movw	r22, r30
    ffb4:	9c 01       	movw	r18, r24
    ffb6:	2c 53       	subi	r18, 0x3C	; 60
    ffb8:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ffba:	af 01       	movw	r20, r30
    ffbc:	4a 0f       	add	r20, r26
    ffbe:	5b 1f       	adc	r21, r27
    ffc0:	06 c0       	rjmp	.+12     	; 0xffce <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    ffc2:	fb 01       	movw	r30, r22
    ffc4:	81 91       	ld	r24, Z+
    ffc6:	bf 01       	movw	r22, r30
    ffc8:	f9 01       	movw	r30, r18
    ffca:	81 93       	st	Z+, r24
    ffcc:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ffce:	64 17       	cp	r22, r20
    ffd0:	75 07       	cpc	r23, r21
    ffd2:	b9 f7       	brne	.-18     	; 0xffc2 <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ffd4:	85 e3       	ldi	r24, 0x35	; 53
    ffd6:	90 e0       	ldi	r25, 0x00	; 0
    ffd8:	c8 9e       	mul	r12, r24
    ffda:	70 01       	movw	r14, r0
    ffdc:	c9 9e       	mul	r12, r25
    ffde:	f0 0c       	add	r15, r0
    ffe0:	d8 9e       	mul	r13, r24
    ffe2:	f0 0c       	add	r15, r0
    ffe4:	11 24       	eor	r1, r1
    ffe6:	87 01       	movw	r16, r14
    ffe8:	0f 54       	subi	r16, 0x4F	; 79
    ffea:	1a 4f       	sbci	r17, 0xFA	; 250
    ffec:	a0 0f       	add	r26, r16
    ffee:	b1 1f       	adc	r27, r17
    fff0:	53 96       	adiw	r26, 0x13	; 19
    fff2:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    fff4:	f0 ed       	ldi	r31, 0xD0	; 208
    fff6:	2f 0e       	add	r2, r31
    fff8:	d8 01       	movw	r26, r16
    fffa:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    fffc:	b9 a9       	ldd	r27, Y+49	; 0x31
    fffe:	b0 53       	subi	r27, 0x30	; 48
   10000:	f8 01       	movw	r30, r16
   10002:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
   10004:	81 e8       	ldi	r24, 0x81	; 129
   10006:	9e e0       	ldi	r25, 0x0E	; 14
   10008:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
   1000c:	d8 01       	movw	r26, r16
   1000e:	12 96       	adiw	r26, 0x02	; 2
   10010:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
   10012:	fe 01       	movw	r30, r28
   10014:	34 96       	adiw	r30, 0x04	; 4
   10016:	df 01       	movw	r26, r30
   10018:	0d 90       	ld	r0, X+
   1001a:	00 20       	and	r0, r0
   1001c:	e9 f7       	brne	.-6      	; 0x10018 <StoreStandaloneTransData+0x2fe>
   1001e:	11 97       	sbiw	r26, 0x01	; 1
   10020:	ae 1b       	sub	r26, r30
   10022:	bf 0b       	sbc	r27, r31
   10024:	97 01       	movw	r18, r14
   10026:	23 53       	subi	r18, 0x33	; 51
   10028:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1002a:	af 01       	movw	r20, r30
   1002c:	4a 0f       	add	r20, r26
   1002e:	5b 1f       	adc	r21, r27
   10030:	06 c0       	rjmp	.+12     	; 0x1003e <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
   10032:	f4 01       	movw	r30, r8
   10034:	81 91       	ld	r24, Z+
   10036:	4f 01       	movw	r8, r30
   10038:	f9 01       	movw	r30, r18
   1003a:	81 93       	st	Z+, r24
   1003c:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1003e:	84 16       	cp	r8, r20
   10040:	95 06       	cpc	r9, r21
   10042:	b9 f7       	brne	.-18     	; 0x10032 <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10044:	85 e3       	ldi	r24, 0x35	; 53
   10046:	90 e0       	ldi	r25, 0x00	; 0
   10048:	9c 01       	movw	r18, r24
   1004a:	c2 9e       	mul	r12, r18
   1004c:	c0 01       	movw	r24, r0
   1004e:	c3 9e       	mul	r12, r19
   10050:	90 0d       	add	r25, r0
   10052:	d2 9e       	mul	r13, r18
   10054:	90 0d       	add	r25, r0
   10056:	11 24       	eor	r1, r1
   10058:	fc 01       	movw	r30, r24
   1005a:	ef 54       	subi	r30, 0x4F	; 79
   1005c:	fa 4f       	sbci	r31, 0xFA	; 250
   1005e:	ea 0f       	add	r30, r26
   10060:	fb 1f       	adc	r31, r27
   10062:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
   10064:	fe 01       	movw	r30, r28
   10066:	7d 96       	adiw	r30, 0x1d	; 29
   10068:	df 01       	movw	r26, r30
   1006a:	0d 90       	ld	r0, X+
   1006c:	00 20       	and	r0, r0
   1006e:	e9 f7       	brne	.-6      	; 0x1006a <StoreStandaloneTransData+0x350>
   10070:	11 97       	sbiw	r26, 0x01	; 1
   10072:	ae 1b       	sub	r26, r30
   10074:	bf 0b       	sbc	r27, r31
   10076:	9c 01       	movw	r18, r24
   10078:	2c 52       	subi	r18, 0x2C	; 44
   1007a:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1007c:	af 01       	movw	r20, r30
   1007e:	4a 0f       	add	r20, r26
   10080:	5b 1f       	adc	r21, r27
   10082:	06 c0       	rjmp	.+12     	; 0x10090 <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
   10084:	f3 01       	movw	r30, r6
   10086:	81 91       	ld	r24, Z+
   10088:	3f 01       	movw	r6, r30
   1008a:	f9 01       	movw	r30, r18
   1008c:	81 93       	st	Z+, r24
   1008e:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10090:	64 16       	cp	r6, r20
   10092:	75 06       	cpc	r7, r21
   10094:	b9 f7       	brne	.-18     	; 0x10084 <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10096:	85 e3       	ldi	r24, 0x35	; 53
   10098:	90 e0       	ldi	r25, 0x00	; 0
   1009a:	9c 01       	movw	r18, r24
   1009c:	c2 9e       	mul	r12, r18
   1009e:	c0 01       	movw	r24, r0
   100a0:	c3 9e       	mul	r12, r19
   100a2:	90 0d       	add	r25, r0
   100a4:	d2 9e       	mul	r13, r18
   100a6:	90 0d       	add	r25, r0
   100a8:	11 24       	eor	r1, r1
   100aa:	fc 01       	movw	r30, r24
   100ac:	ef 54       	subi	r30, 0x4F	; 79
   100ae:	fa 4f       	sbci	r31, 0xFA	; 250
   100b0:	ea 0f       	add	r30, r26
   100b2:	fb 1f       	adc	r31, r27
   100b4:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
   100b6:	fe 01       	movw	r30, r28
   100b8:	b7 96       	adiw	r30, 0x27	; 39
   100ba:	df 01       	movw	r26, r30
   100bc:	0d 90       	ld	r0, X+
   100be:	00 20       	and	r0, r0
   100c0:	e9 f7       	brne	.-6      	; 0x100bc <StoreStandaloneTransData+0x3a2>
   100c2:	11 97       	sbiw	r26, 0x01	; 1
   100c4:	ae 1b       	sub	r26, r30
   100c6:	bf 0b       	sbc	r27, r31
   100c8:	9c 01       	movw	r18, r24
   100ca:	23 52       	subi	r18, 0x23	; 35
   100cc:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   100ce:	af 01       	movw	r20, r30
   100d0:	4a 0f       	add	r20, r26
   100d2:	5b 1f       	adc	r21, r27
   100d4:	06 c0       	rjmp	.+12     	; 0x100e2 <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
   100d6:	f2 01       	movw	r30, r4
   100d8:	81 91       	ld	r24, Z+
   100da:	2f 01       	movw	r4, r30
   100dc:	f9 01       	movw	r30, r18
   100de:	81 93       	st	Z+, r24
   100e0:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   100e2:	44 16       	cp	r4, r20
   100e4:	55 06       	cpc	r5, r21
   100e6:	b9 f7       	brne	.-18     	; 0x100d6 <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   100e8:	85 e3       	ldi	r24, 0x35	; 53
   100ea:	90 e0       	ldi	r25, 0x00	; 0
   100ec:	c8 9e       	mul	r12, r24
   100ee:	f0 01       	movw	r30, r0
   100f0:	c9 9e       	mul	r12, r25
   100f2:	f0 0d       	add	r31, r0
   100f4:	d8 9e       	mul	r13, r24
   100f6:	f0 0d       	add	r31, r0
   100f8:	11 24       	eor	r1, r1
   100fa:	ef 54       	subi	r30, 0x4F	; 79
   100fc:	fa 4f       	sbci	r31, 0xFA	; 250
   100fe:	ea 0f       	add	r30, r26
   10100:	fb 1f       	adc	r31, r27
   10102:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
   10104:	83 2d       	mov	r24, r3
   10106:	8f 70       	andi	r24, 0x0F	; 15
   10108:	60 e1       	ldi	r22, 0x10	; 16
   1010a:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
   1010e:	83 2d       	mov	r24, r3
   10110:	62 e0       	ldi	r22, 0x02	; 2
   10112:	0e 94 55 1a 	call	0x34aa	; 0x34aa <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
   10116:	8b e0       	ldi	r24, 0x0B	; 11
   10118:	63 2d       	mov	r22, r3
   1011a:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
   1011e:	4b c0       	rjmp	.+150    	; 0x101b6 <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
   10120:	da 94       	dec	r13
   10122:	cd 2c       	mov	r12, r13
   10124:	dd 24       	eor	r13, r13
   10126:	f6 01       	movw	r30, r12
   10128:	ef 58       	subi	r30, 0x8F	; 143
   1012a:	fe 4f       	sbci	r31, 0xFE	; 254
   1012c:	81 e0       	ldi	r24, 0x01	; 1
   1012e:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
   10130:	c7 01       	movw	r24, r14
   10132:	0e 94 05 3a 	call	0x740a	; 0x740a <FormatPrice>
			 FormatMoney(strPMoney);
   10136:	c8 01       	movw	r24, r16
   10138:	0e 94 f8 39 	call	0x73f0	; 0x73f0 <FormatMoney>
			 FormatVolume(strPVolume);
   1013c:	c5 01       	movw	r24, r10
   1013e:	0e 94 eb 39 	call	0x73d6	; 0x73d6 <FormatVolume>

			 //uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
   10142:	80 ea       	ldi	r24, 0xA0	; 160
   10144:	9e e0       	ldi	r25, 0x0E	; 14
   10146:	0e 94 6f 45 	call	0x8ade	; 0x8ade <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
   1014a:	00 d0       	rcall	.+0      	; 0x1014c <StoreStandaloneTransData+0x432>
   1014c:	00 d0       	rcall	.+0      	; 0x1014e <StoreStandaloneTransData+0x434>
   1014e:	00 d0       	rcall	.+0      	; 0x10150 <StoreStandaloneTransData+0x436>
   10150:	ed b7       	in	r30, 0x3d	; 61
   10152:	fe b7       	in	r31, 0x3e	; 62
   10154:	31 96       	adiw	r30, 0x01	; 1
   10156:	ce 01       	movw	r24, r28
   10158:	0b 96       	adiw	r24, 0x0b	; 11
   1015a:	ad b7       	in	r26, 0x3d	; 61
   1015c:	be b7       	in	r27, 0x3e	; 62
   1015e:	12 96       	adiw	r26, 0x02	; 2
   10160:	9c 93       	st	X, r25
   10162:	8e 93       	st	-X, r24
   10164:	11 97       	sbiw	r26, 0x01	; 1
   10166:	81 ee       	ldi	r24, 0xE1	; 225
   10168:	92 e2       	ldi	r25, 0x22	; 34
   1016a:	93 83       	std	Z+3, r25	; 0x03
   1016c:	82 83       	std	Z+2, r24	; 0x02
   1016e:	83 ec       	ldi	r24, 0xC3	; 195
   10170:	93 e0       	ldi	r25, 0x03	; 3
   10172:	95 83       	std	Z+5, r25	; 0x05
   10174:	84 83       	std	Z+4, r24	; 0x04
   10176:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
   1017a:	ed b7       	in	r30, 0x3d	; 61
   1017c:	fe b7       	in	r31, 0x3e	; 62
   1017e:	31 96       	adiw	r30, 0x01	; 1
   10180:	ce 01       	movw	r24, r28
   10182:	44 96       	adiw	r24, 0x14	; 20
   10184:	ad b7       	in	r26, 0x3d	; 61
   10186:	be b7       	in	r27, 0x3e	; 62
   10188:	12 96       	adiw	r26, 0x02	; 2
   1018a:	9c 93       	st	X, r25
   1018c:	8e 93       	st	-X, r24
   1018e:	11 97       	sbiw	r26, 0x01	; 1
   10190:	8e ed       	ldi	r24, 0xDE	; 222
   10192:	92 e2       	ldi	r25, 0x22	; 34
   10194:	93 83       	std	Z+3, r25	; 0x03
   10196:	82 83       	std	Z+2, r24	; 0x02
   10198:	8d e7       	ldi	r24, 0x7D	; 125
   1019a:	98 e0       	ldi	r25, 0x08	; 8
   1019c:	95 83       	std	Z+5, r25	; 0x05
   1019e:	84 83       	std	Z+4, r24	; 0x04
   101a0:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   101a4:	ed b7       	in	r30, 0x3d	; 61
   101a6:	fe b7       	in	r31, 0x3e	; 62
   101a8:	36 96       	adiw	r30, 0x06	; 6
   101aa:	0f b6       	in	r0, 0x3f	; 63
   101ac:	f8 94       	cli
   101ae:	fe bf       	out	0x3e, r31	; 62
   101b0:	0f be       	out	0x3f, r0	; 63
   101b2:	ed bf       	out	0x3d, r30	; 61
   101b4:	75 ce       	rjmp	.-790    	; 0xfea0 <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //uart_print(0,1,strRawTransData);
}
   101b6:	e1 96       	adiw	r28, 0x31	; 49
   101b8:	0f b6       	in	r0, 0x3f	; 63
   101ba:	f8 94       	cli
   101bc:	de bf       	out	0x3e, r29	; 62
   101be:	0f be       	out	0x3f, r0	; 63
   101c0:	cd bf       	out	0x3d, r28	; 61
   101c2:	cf 91       	pop	r28
   101c4:	df 91       	pop	r29
   101c6:	1f 91       	pop	r17
   101c8:	0f 91       	pop	r16
   101ca:	ff 90       	pop	r15
   101cc:	ef 90       	pop	r14
   101ce:	df 90       	pop	r13
   101d0:	cf 90       	pop	r12
   101d2:	bf 90       	pop	r11
   101d4:	af 90       	pop	r10
   101d6:	9f 90       	pop	r9
   101d8:	8f 90       	pop	r8
   101da:	7f 90       	pop	r7
   101dc:	6f 90       	pop	r6
   101de:	5f 90       	pop	r5
   101e0:	4f 90       	pop	r4
   101e2:	3f 90       	pop	r3
   101e4:	2f 90       	pop	r2
   101e6:	08 95       	ret

000101e8 <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
   101e8:	2f 92       	push	r2
   101ea:	3f 92       	push	r3
   101ec:	4f 92       	push	r4
   101ee:	5f 92       	push	r5
   101f0:	7f 92       	push	r7
   101f2:	8f 92       	push	r8
   101f4:	9f 92       	push	r9
   101f6:	af 92       	push	r10
   101f8:	bf 92       	push	r11
   101fa:	cf 92       	push	r12
   101fc:	df 92       	push	r13
   101fe:	ef 92       	push	r14
   10200:	ff 92       	push	r15
   10202:	0f 93       	push	r16
   10204:	1f 93       	push	r17
   10206:	df 93       	push	r29
   10208:	cf 93       	push	r28
   1020a:	cd b7       	in	r28, 0x3d	; 61
   1020c:	de b7       	in	r29, 0x3e	; 62
   1020e:	a1 97       	sbiw	r28, 0x21	; 33
   10210:	0f b6       	in	r0, 0x3f	; 63
   10212:	f8 94       	cli
   10214:	de bf       	out	0x3e, r29	; 62
   10216:	0f be       	out	0x3f, r0	; 63
   10218:	cd bf       	out	0x3d, r28	; 61
   1021a:	8c 01       	movw	r16, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1021c:	fc 01       	movw	r30, r24
   1021e:	82 81       	ldd	r24, Z+2	; 0x02
   10220:	89 83       	std	Y+1, r24	; 0x01
   10222:	83 81       	ldd	r24, Z+3	; 0x03
   10224:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
   10226:	1b 82       	std	Y+3, r1	; 0x03
	 //    uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
   10228:	ce 01       	movw	r24, r28
   1022a:	01 96       	adiw	r24, 0x01	; 1
   1022c:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
   10230:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
   10232:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
	 if (FIPAddr>0){
   10236:	88 23       	and	r24, r24
   10238:	09 f4       	brne	.+2      	; 0x1023c <StoreStandaloneTotalizerData+0x54>
   1023a:	44 c0       	rjmp	.+136    	; 0x102c4 <StoreStandaloneTotalizerData+0xdc>
	     FIPAddr=FIPAddr-1;
   1023c:	78 2e       	mov	r7, r24
   1023e:	7a 94       	dec	r7
   10240:	e0 e1       	ldi	r30, 0x10	; 16
   10242:	ee 2e       	mov	r14, r30
   10244:	f1 2c       	mov	r15, r1
   10246:	e0 0e       	add	r14, r16
   10248:	f1 1e       	adc	r15, r17
   1024a:	dd 24       	eor	r13, r13
   1024c:	d3 94       	inc	r13
   1024e:	74 e0       	ldi	r23, 0x04	; 4
   10250:	87 2e       	mov	r8, r23
   10252:	91 2c       	mov	r9, r1
   10254:	8c 0e       	add	r8, r28
   10256:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10258:	60 e1       	ldi	r22, 0x10	; 16
   1025a:	26 2e       	mov	r2, r22
   1025c:	31 2c       	mov	r3, r1
   1025e:	2c 0e       	add	r2, r28
   10260:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10262:	53 e1       	ldi	r21, 0x13	; 19
   10264:	a5 2e       	mov	r10, r21
   10266:	b1 2c       	mov	r11, r1
   10268:	ac 0e       	add	r10, r28
   1026a:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1026c:	4f e1       	ldi	r20, 0x1F	; 31
   1026e:	44 2e       	mov	r4, r20
   10270:	51 2c       	mov	r5, r1
   10272:	4c 0e       	add	r4, r28
   10274:	5d 1e       	adc	r5, r29
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
   10276:	d7 01       	movw	r26, r14
   10278:	1c 97       	sbiw	r26, 0x0c	; 12
   1027a:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1027c:	8d 91       	ld	r24, X+
   1027e:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10280:	e2 15       	cp	r30, r2
   10282:	f3 05       	cpc	r31, r3
   10284:	d9 f7       	brne	.-10     	; 0x1027c <StoreStandaloneTotalizerData+0x94>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10286:	18 8a       	std	Y+16, r1	; 0x10
   10288:	f5 01       	movw	r30, r10
   1028a:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1028c:	8d 91       	ld	r24, X+
   1028e:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10290:	e4 15       	cp	r30, r4
   10292:	f5 05       	cpc	r31, r5
   10294:	d9 f7       	brne	.-10     	; 0x1028c <StoreStandaloneTotalizerData+0xa4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10296:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
   10298:	80 e0       	ldi	r24, 0x00	; 0
   1029a:	61 e0       	ldi	r22, 0x01	; 1
   1029c:	47 2d       	mov	r20, r7
   1029e:	2d 2d       	mov	r18, r13
   102a0:	84 01       	movw	r16, r8
   102a2:	0e 94 2a 2b 	call	0x5654	; 0x5654 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
   102a6:	81 e0       	ldi	r24, 0x01	; 1
   102a8:	61 e0       	ldi	r22, 0x01	; 1
   102aa:	47 2d       	mov	r20, r7
   102ac:	2d 2d       	mov	r18, r13
   102ae:	85 01       	movw	r16, r10
   102b0:	0e 94 2a 2b 	call	0x5654	; 0x5654 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
   102b4:	d3 94       	inc	r13
   102b6:	88 e1       	ldi	r24, 0x18	; 24
   102b8:	90 e0       	ldi	r25, 0x00	; 0
   102ba:	e8 0e       	add	r14, r24
   102bc:	f9 1e       	adc	r15, r25
   102be:	97 e0       	ldi	r25, 0x07	; 7
   102c0:	d9 16       	cp	r13, r25
   102c2:	c9 f6       	brne	.-78     	; 0x10276 <StoreStandaloneTotalizerData+0x8e>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
   102c4:	8d e0       	ldi	r24, 0x0D	; 13
   102c6:	6c 2d       	mov	r22, r12
   102c8:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
   102cc:	8c 2d       	mov	r24, r12
   102ce:	8f 70       	andi	r24, 0x0F	; 15
   102d0:	64 e1       	ldi	r22, 0x14	; 20
   102d2:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
}
   102d6:	a1 96       	adiw	r28, 0x21	; 33
   102d8:	0f b6       	in	r0, 0x3f	; 63
   102da:	f8 94       	cli
   102dc:	de bf       	out	0x3e, r29	; 62
   102de:	0f be       	out	0x3f, r0	; 63
   102e0:	cd bf       	out	0x3d, r28	; 61
   102e2:	cf 91       	pop	r28
   102e4:	df 91       	pop	r29
   102e6:	1f 91       	pop	r17
   102e8:	0f 91       	pop	r16
   102ea:	ff 90       	pop	r15
   102ec:	ef 90       	pop	r14
   102ee:	df 90       	pop	r13
   102f0:	cf 90       	pop	r12
   102f2:	bf 90       	pop	r11
   102f4:	af 90       	pop	r10
   102f6:	9f 90       	pop	r9
   102f8:	8f 90       	pop	r8
   102fa:	7f 90       	pop	r7
   102fc:	5f 90       	pop	r5
   102fe:	4f 90       	pop	r4
   10300:	3f 90       	pop	r3
   10302:	2f 90       	pop	r2
   10304:	08 95       	ret

00010306 <ScanStandaloneFlow>:
	 spi(SlaveMessage);
	 spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
   10306:	0f 93       	push	r16
   10308:	1f 93       	push	r17
   1030a:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
   1030c:	80 91 b2 02 	lds	r24, 0x02B2
   10310:	80 93 b3 02 	sts	0x02B3, r24
	  zDataFlow[3]=zDataFlow[2];
   10314:	80 91 b1 02 	lds	r24, 0x02B1
   10318:	80 93 b2 02 	sts	0x02B2, r24
	  zDataFlow[2]=zDataFlow[1];
   1031c:	80 91 b0 02 	lds	r24, 0x02B0
   10320:	80 93 b1 02 	sts	0x02B1, r24
      zDataFlow[1]=zDataFlow[0];
   10324:	90 91 af 02 	lds	r25, 0x02AF
   10328:	90 93 b0 02 	sts	0x02B0, r25
      zDataFlow[0]=data;
   1032c:	00 93 af 02 	sts	0x02AF, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
   10330:	87 30       	cpi	r24, 0x07	; 7
   10332:	79 f4       	brne	.+30     	; 0x10352 <ScanStandaloneFlow+0x4c>
   10334:	08 30       	cpi	r16, 0x08	; 8
   10336:	69 f4       	brne	.+26     	; 0x10352 <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
   10338:	19 2f       	mov	r17, r25
   1033a:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
   1033c:	89 2f       	mov	r24, r25
   1033e:	82 95       	swap	r24
   10340:	8f 70       	andi	r24, 0x0F	; 15
   10342:	61 2f       	mov	r22, r17
   10344:	0e 94 3c 21 	call	0x4278	; 0x4278 <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
   10348:	1e 30       	cpi	r17, 0x0E	; 14
   1034a:	19 f0       	breq	.+6      	; 0x10352 <ScanStandaloneFlow+0x4c>
   1034c:	81 e0       	ldi	r24, 0x01	; 1
   1034e:	80 93 9e 01 	sts	0x019E, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
   10352:	80 91 9f 01 	lds	r24, 0x019F
   10356:	81 30       	cpi	r24, 0x01	; 1
   10358:	69 f4       	brne	.+26     	; 0x10374 <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
   1035a:	80 91 ad 02 	lds	r24, 0x02AD
   1035e:	90 91 ae 02 	lds	r25, 0x02AE
   10362:	fc 01       	movw	r30, r24
   10364:	e1 5f       	subi	r30, 0xF1	; 241
   10366:	fc 4f       	sbci	r31, 0xFC	; 252
   10368:	00 83       	st	Z, r16
		  iFlow++;
   1036a:	01 96       	adiw	r24, 0x01	; 1
   1036c:	90 93 ae 02 	sts	0x02AE, r25
   10370:	80 93 ad 02 	sts	0x02AD, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
   10374:	80 91 b0 02 	lds	r24, 0x02B0
   10378:	85 30       	cpi	r24, 0x05	; 5
   1037a:	61 f4       	brne	.+24     	; 0x10394 <ScanStandaloneFlow+0x8e>
   1037c:	80 91 af 02 	lds	r24, 0x02AF
   10380:	80 35       	cpi	r24, 0x50	; 80
   10382:	41 f5       	brne	.+80     	; 0x103d4 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
   10384:	81 e0       	ldi	r24, 0x01	; 1
   10386:	80 93 9f 01 	sts	0x019F, r24
		  iFlow=0;
   1038a:	10 92 ae 02 	sts	0x02AE, r1
   1038e:	10 92 ad 02 	sts	0x02AD, r1
   10392:	20 c0       	rjmp	.+64     	; 0x103d4 <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
   10394:	86 30       	cpi	r24, 0x06	; 6
   10396:	f1 f4       	brne	.+60     	; 0x103d4 <ScanStandaloneFlow+0xce>
   10398:	80 91 af 02 	lds	r24, 0x02AF
   1039c:	80 36       	cpi	r24, 0x60	; 96
   1039e:	d1 f4       	brne	.+52     	; 0x103d4 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
   103a0:	10 92 9f 01 	sts	0x019F, r1
	      strStandReceived[iFlow]=0;
   103a4:	e0 91 ad 02 	lds	r30, 0x02AD
   103a8:	f0 91 ae 02 	lds	r31, 0x02AE
   103ac:	e1 5f       	subi	r30, 0xF1	; 241
   103ae:	fc 4f       	sbci	r31, 0xFC	; 252
   103b0:	10 82       	st	Z, r1

		  //uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
   103b2:	8f e0       	ldi	r24, 0x0F	; 15
   103b4:	93 e0       	ldi	r25, 0x03	; 3
   103b6:	0e 94 e5 4b 	call	0x97ca	; 0x97ca <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
   103ba:	81 30       	cpi	r24, 0x01	; 1
   103bc:	29 f4       	brne	.+10     	; 0x103c8 <ScanStandaloneFlow+0xc2>
   103be:	8f e0       	ldi	r24, 0x0F	; 15
   103c0:	93 e0       	ldi	r25, 0x03	; 3
   103c2:	0e 94 8d 7e 	call	0xfd1a	; 0xfd1a <StoreStandaloneTransData>
   103c6:	06 c0       	rjmp	.+12     	; 0x103d4 <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
   103c8:	82 30       	cpi	r24, 0x02	; 2
   103ca:	21 f4       	brne	.+8      	; 0x103d4 <ScanStandaloneFlow+0xce>
   103cc:	8f e0       	ldi	r24, 0x0F	; 15
   103ce:	93 e0       	ldi	r25, 0x03	; 3
   103d0:	0e 94 f4 80 	call	0x101e8	; 0x101e8 <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
   103d4:	80 91 b2 02 	lds	r24, 0x02B2
   103d8:	89 30       	cpi	r24, 0x09	; 9
   103da:	c1 f5       	brne	.+112    	; 0x1044c <ScanStandaloneFlow+0x146>
   103dc:	80 91 af 02 	lds	r24, 0x02AF
   103e0:	8a 30       	cpi	r24, 0x0A	; 10
   103e2:	a1 f5       	brne	.+104    	; 0x1044c <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
   103e4:	90 91 b0 02 	lds	r25, 0x02B0
   103e8:	90 93 f9 0d 	sts	0x0DF9, r25
	      AcknoledgeCommand=zDataFlow[2];	  
   103ec:	80 91 b1 02 	lds	r24, 0x02B1
   103f0:	80 93 a6 05 	sts	0x05A6, r24
		  switch(AcknoledgeCommand){
   103f4:	89 31       	cpi	r24, 0x19	; 25
   103f6:	51 f0       	breq	.+20     	; 0x1040c <ScanStandaloneFlow+0x106>
   103f8:	8a 31       	cpi	r24, 0x1A	; 26
   103fa:	18 f4       	brcc	.+6      	; 0x10402 <ScanStandaloneFlow+0xfc>
   103fc:	85 30       	cpi	r24, 0x05	; 5
   103fe:	19 f5       	brne	.+70     	; 0x10446 <ScanStandaloneFlow+0x140>
   10400:	17 c0       	rjmp	.+46     	; 0x10430 <ScanStandaloneFlow+0x12a>
   10402:	8a 31       	cpi	r24, 0x1A	; 26
   10404:	c9 f0       	breq	.+50     	; 0x10438 <ScanStandaloneFlow+0x132>
   10406:	8c 31       	cpi	r24, 0x1C	; 28
   10408:	f1 f4       	brne	.+60     	; 0x10446 <ScanStandaloneFlow+0x140>
   1040a:	1a c0       	rjmp	.+52     	; 0x10440 <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
   1040c:	90 93 82 01 	sts	0x0182, r25
			   IsNewPoolingSequence=True;
   10410:	81 e0       	ldi	r24, 0x01	; 1
   10412:	80 93 83 01 	sts	0x0183, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
   10416:	80 91 86 01 	lds	r24, 0x0186
   1041a:	81 30       	cpi	r24, 0x01	; 1
   1041c:	a1 f4       	brne	.+40     	; 0x10446 <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
   1041e:	10 92 86 01 	sts	0x0186, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
   10422:	80 91 b0 05 	lds	r24, 0x05B0
   10426:	60 91 e0 0d 	lds	r22, 0x0DE0
   1042a:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
   1042e:	0b c0       	rjmp	.+22     	; 0x10446 <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
   10430:	81 e0       	ldi	r24, 0x01	; 1
   10432:	80 93 b1 01 	sts	0x01B1, r24
   10436:	07 c0       	rjmp	.+14     	; 0x10446 <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
   10438:	81 e0       	ldi	r24, 0x01	; 1
   1043a:	80 93 85 01 	sts	0x0185, r24
   1043e:	03 c0       	rjmp	.+6      	; 0x10446 <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
   10440:	81 e0       	ldi	r24, 0x01	; 1
   10442:	80 93 13 01 	sts	0x0113, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
   10446:	81 e0       	ldi	r24, 0x01	; 1
   10448:	80 93 84 01 	sts	0x0184, r24
	  }
}
   1044c:	1f 91       	pop	r17
   1044e:	0f 91       	pop	r16
   10450:	08 95       	ret

00010452 <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
   10452:	1f 92       	push	r1
   10454:	0f 92       	push	r0
   10456:	0f b6       	in	r0, 0x3f	; 63
   10458:	0f 92       	push	r0
   1045a:	0b b6       	in	r0, 0x3b	; 59
   1045c:	0f 92       	push	r0
   1045e:	11 24       	eor	r1, r1
   10460:	1f 93       	push	r17
   10462:	2f 93       	push	r18
   10464:	3f 93       	push	r19
   10466:	4f 93       	push	r20
   10468:	5f 93       	push	r21
   1046a:	6f 93       	push	r22
   1046c:	7f 93       	push	r23
   1046e:	8f 93       	push	r24
   10470:	9f 93       	push	r25
   10472:	af 93       	push	r26
   10474:	bf 93       	push	r27
   10476:	ef 93       	push	r30
   10478:	ff 93       	push	r31
char dataSPI;
//char Reply=0;
    //uart(0,1,SPDR);
	dataSPI=SPDR;
   1047a:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
   1047c:	81 2f       	mov	r24, r17
   1047e:	0e 94 ba 14 	call	0x2974	; 0x2974 <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
   10482:	80 91 00 01 	lds	r24, 0x0100
   10486:	81 30       	cpi	r24, 0x01	; 1
   10488:	21 f4       	brne	.+8      	; 0x10492 <__vector_17+0x40>
   1048a:	81 2f       	mov	r24, r17
   1048c:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <ScanEDCFlow>
   10490:	05 c0       	rjmp	.+10     	; 0x1049c <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
   10492:	82 30       	cpi	r24, 0x02	; 2
   10494:	19 f4       	brne	.+6      	; 0x1049c <__vector_17+0x4a>
   10496:	81 2f       	mov	r24, r17
   10498:	0e 94 83 81 	call	0x10306	; 0x10306 <ScanStandaloneFlow>
}
   1049c:	ff 91       	pop	r31
   1049e:	ef 91       	pop	r30
   104a0:	bf 91       	pop	r27
   104a2:	af 91       	pop	r26
   104a4:	9f 91       	pop	r25
   104a6:	8f 91       	pop	r24
   104a8:	7f 91       	pop	r23
   104aa:	6f 91       	pop	r22
   104ac:	5f 91       	pop	r21
   104ae:	4f 91       	pop	r20
   104b0:	3f 91       	pop	r19
   104b2:	2f 91       	pop	r18
   104b4:	1f 91       	pop	r17
   104b6:	0f 90       	pop	r0
   104b8:	0b be       	out	0x3b, r0	; 59
   104ba:	0f 90       	pop	r0
   104bc:	0f be       	out	0x3f, r0	; 63
   104be:	0f 90       	pop	r0
   104c0:	1f 90       	pop	r1
   104c2:	18 95       	reti

000104c4 <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
   104c4:	8f 92       	push	r8
   104c6:	9f 92       	push	r9
   104c8:	af 92       	push	r10
   104ca:	bf 92       	push	r11
   104cc:	cf 92       	push	r12
   104ce:	df 92       	push	r13
   104d0:	ef 92       	push	r14
   104d2:	ff 92       	push	r15
   104d4:	0f 93       	push	r16
   104d6:	1f 93       	push	r17
   104d8:	cf 93       	push	r28
   104da:	df 93       	push	r29
   104dc:	f8 2e       	mov	r15, r24
   104de:	96 2e       	mov	r9, r22
   104e0:	d4 2e       	mov	r13, r20
   104e2:	e9 01       	movw	r28, r18
   104e4:	58 01       	movw	r10, r16
   104e6:	8e 2c       	mov	r8, r14
	 static char iHit=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;//,KeyByte=0;
	 static unsigned int iLoop=0,KeyTimeout;//,TimerPressed=0,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
   104e8:	10 91 88 02 	lds	r17, 0x0288
   104ec:	12 30       	cpi	r17, 0x02	; 2
   104ee:	09 f4       	brne	.+2      	; 0x104f2 <UserInput+0x2e>
   104f0:	29 c2       	rjmp	.+1106   	; 0x10944 <UserInput+0x480>
   104f2:	13 30       	cpi	r17, 0x03	; 3
   104f4:	30 f4       	brcc	.+12     	; 0x10502 <UserInput+0x3e>
   104f6:	11 23       	and	r17, r17
   104f8:	59 f0       	breq	.+22     	; 0x10510 <UserInput+0x4c>
   104fa:	11 30       	cpi	r17, 0x01	; 1
   104fc:	09 f0       	breq	.+2      	; 0x10500 <UserInput+0x3c>
   104fe:	f2 c2       	rjmp	.+1508   	; 0x10ae4 <UserInput+0x620>
   10500:	2c c0       	rjmp	.+88     	; 0x1055a <UserInput+0x96>
   10502:	13 30       	cpi	r17, 0x03	; 3
   10504:	09 f4       	brne	.+2      	; 0x10508 <UserInput+0x44>
   10506:	73 c2       	rjmp	.+1254   	; 0x109ee <UserInput+0x52a>
   10508:	14 30       	cpi	r17, 0x04	; 4
   1050a:	09 f0       	breq	.+2      	; 0x1050e <UserInput+0x4a>
   1050c:	eb c2       	rjmp	.+1494   	; 0x10ae4 <UserInput+0x620>
   1050e:	ec c2       	rjmp	.+1496   	; 0x10ae8 <UserInput+0x624>
	 case uiInit:
	      iLoop=0;
   10510:	10 92 7a 02 	sts	0x027A, r1
   10514:	10 92 79 02 	sts	0x0279, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
   10518:	60 93 87 02 	sts	0x0287, r22
   1051c:	40 93 86 02 	sts	0x0286, r20
          iValuePos=0;
   10520:	10 92 85 02 	sts	0x0285, r1
		  KeyTimeout=0;
   10524:	10 92 78 02 	sts	0x0278, r1
   10528:	10 92 77 02 	sts	0x0277, r1
		  IsSameKey=False;
   1052c:	10 92 7e 02 	sts	0x027E, r1
		  IsNextKey=False;
   10530:	10 92 7d 02 	sts	0x027D, r1
		  IsNewKey=False;
   10534:	10 92 7c 02 	sts	0x027C, r1
		  IsShifted=True;
   10538:	91 e0       	ldi	r25, 0x01	; 1
   1053a:	90 93 7f 02 	sts	0x027F, r25
		  zKeyChar=' ';
   1053e:	80 e2       	ldi	r24, 0x20	; 32
   10540:	80 93 84 02 	sts	0x0284, r24
		  iHit=0;
   10544:	10 92 80 02 	sts	0x0280, r1
		  IsFirst=False;
   10548:	10 92 7b 02 	sts	0x027B, r1
		  IsDelete=False;
   1054c:	10 92 81 02 	sts	0x0281, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
   10550:	90 93 88 02 	sts	0x0288, r25
   10554:	b5 e0       	ldi	r27, 0x05	; 5
   10556:	eb 2e       	mov	r14, r27
   10558:	cb c2       	rjmp	.+1430   	; 0x10af0 <UserInput+0x62c>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
   1055a:	81 e0       	ldi	r24, 0x01	; 1
   1055c:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   10560:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
   10562:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
   10566:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
   10568:	2b e7       	ldi	r18, 0x7B	; 123
   1056a:	c2 16       	cp	r12, r18
   1056c:	59 f4       	brne	.+22     	; 0x10584 <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
   1056e:	80 91 7f 02 	lds	r24, 0x027F
   10572:	88 23       	and	r24, r24
   10574:	19 f4       	brne	.+6      	; 0x1057c <UserInput+0xb8>
   10576:	10 93 7f 02 	sts	0x027F, r17
   1057a:	04 c0       	rjmp	.+8      	; 0x10584 <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
   1057c:	81 30       	cpi	r24, 0x01	; 1
   1057e:	11 f4       	brne	.+4      	; 0x10584 <UserInput+0xc0>
   10580:	10 92 7f 02 	sts	0x027F, r1
			  }
          
		  if (IsSameKey==True){
   10584:	80 91 7e 02 	lds	r24, 0x027E
   10588:	81 30       	cpi	r24, 0x01	; 1
   1058a:	e9 f4       	brne	.+58     	; 0x105c6 <UserInput+0x102>
		      KeyTimeout++;
   1058c:	80 91 77 02 	lds	r24, 0x0277
   10590:	90 91 78 02 	lds	r25, 0x0278
   10594:	01 96       	adiw	r24, 0x01	; 1
   10596:	90 93 78 02 	sts	0x0278, r25
   1059a:	80 93 77 02 	sts	0x0277, r24
              if (KeyTimeout>1000){
   1059e:	89 5e       	subi	r24, 0xE9	; 233
   105a0:	93 40       	sbci	r25, 0x03	; 3
   105a2:	88 f0       	brcs	.+34     	; 0x105c6 <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
   105a4:	f5 e0       	ldi	r31, 0x05	; 5
   105a6:	ff 16       	cp	r15, r31
   105a8:	39 f4       	brne	.+14     	; 0x105b8 <UserInput+0xf4>
   105aa:	80 91 87 02 	lds	r24, 0x0287
   105ae:	60 91 86 02 	lds	r22, 0x0286
   105b2:	4a e2       	ldi	r20, 0x2A	; 42
   105b4:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>

		          IsNextKey=True;
   105b8:	81 e0       	ldi	r24, 0x01	; 1
   105ba:	80 93 7d 02 	sts	0x027D, r24
				  iLoop=0;
   105be:	10 92 7a 02 	sts	0x027A, r1
   105c2:	10 92 79 02 	sts	0x0279, r1
			     }
              }
            
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
   105c6:	8e 2d       	mov	r24, r14
   105c8:	80 53       	subi	r24, 0x30	; 48
   105ca:	8a 30       	cpi	r24, 0x0A	; 10
   105cc:	20 f4       	brcc	.+8      	; 0x105d6 <UserInput+0x112>
   105ce:	80 91 85 02 	lds	r24, 0x0285
   105d2:	88 15       	cp	r24, r8
   105d4:	40 f0       	brcs	.+16     	; 0x105e6 <UserInput+0x122>
   105d6:	80 91 7d 02 	lds	r24, 0x027D
   105da:	81 30       	cpi	r24, 0x01	; 1
   105dc:	21 f0       	breq	.+8      	; 0x105e6 <UserInput+0x122>
   105de:	ee 24       	eor	r14, r14
   105e0:	00 e0       	ldi	r16, 0x00	; 0
   105e2:	10 e0       	ldi	r17, 0x00	; 0
   105e4:	be c0       	rjmp	.+380    	; 0x10762 <UserInput+0x29e>
   105e6:	84 e2       	ldi	r24, 0x24	; 36
   105e8:	94 ef       	ldi	r25, 0xF4	; 244
   105ea:	01 97       	sbiw	r24, 0x01	; 1
   105ec:	f1 f7       	brne	.-4      	; 0x105ea <UserInput+0x126>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
   105ee:	80 91 85 02 	lds	r24, 0x0285
   105f2:	fe 01       	movw	r30, r28
   105f4:	e8 0f       	add	r30, r24
   105f6:	f1 1d       	adc	r31, r1
   105f8:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
   105fa:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
   105fc:	8f 2d       	mov	r24, r15
   105fe:	81 50       	subi	r24, 0x01	; 1
   10600:	82 30       	cpi	r24, 0x02	; 2
   10602:	30 f0       	brcs	.+12     	; 0x10610 <UserInput+0x14c>
   10604:	24 e0       	ldi	r18, 0x04	; 4
   10606:	f2 16       	cp	r15, r18
   10608:	19 f0       	breq	.+6      	; 0x10610 <UserInput+0x14c>
   1060a:	00 e0       	ldi	r16, 0x00	; 0
   1060c:	10 e0       	ldi	r17, 0x00	; 0
   1060e:	04 c0       	rjmp	.+8      	; 0x10618 <UserInput+0x154>
			        NumbValue=atoi(strResult);
   10610:	ce 01       	movw	r24, r28
   10612:	0e 94 ce b0 	call	0x1619c	; 0x1619c <atoi>
   10616:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
   10618:	83 e0       	ldi	r24, 0x03	; 3
   1061a:	f8 16       	cp	r15, r24
   1061c:	21 f0       	breq	.+8      	; 0x10626 <UserInput+0x162>
   1061e:	e5 e0       	ldi	r30, 0x05	; 5
   10620:	fe 16       	cp	r15, r30
   10622:	09 f0       	breq	.+2      	; 0x10626 <UserInput+0x162>
   10624:	63 c0       	rjmp	.+198    	; 0x106ec <UserInput+0x228>
			       if (KeyChar!=zKeyChar){
   10626:	80 91 84 02 	lds	r24, 0x0284
   1062a:	e8 16       	cp	r14, r24
   1062c:	71 f0       	breq	.+28     	; 0x1064a <UserInput+0x186>
					   IsSameKey=False;
   1062e:	10 92 7e 02 	sts	0x027E, r1
					   IsNewKey=True;
   10632:	81 e0       	ldi	r24, 0x01	; 1
   10634:	80 93 7c 02 	sts	0x027C, r24
				       iHit=0;
   10638:	10 92 80 02 	sts	0x0280, r1
					   iLoop=1000;
   1063c:	88 ee       	ldi	r24, 0xE8	; 232
   1063e:	93 e0       	ldi	r25, 0x03	; 3
   10640:	90 93 7a 02 	sts	0x027A, r25
   10644:	80 93 79 02 	sts	0x0279, r24
   10648:	51 c0       	rjmp	.+162    	; 0x106ec <UserInput+0x228>
				   }
                   else{
				   if (IsNewKey==True){
   1064a:	80 91 7c 02 	lds	r24, 0x027C
   1064e:	81 30       	cpi	r24, 0x01	; 1
   10650:	71 f4       	brne	.+28     	; 0x1066e <UserInput+0x1aa>
					   IsNewKey=False;
   10652:	10 92 7c 02 	sts	0x027C, r1
					   yChar--;
   10656:	80 91 86 02 	lds	r24, 0x0286
   1065a:	81 50       	subi	r24, 0x01	; 1
   1065c:	80 93 86 02 	sts	0x0286, r24
					   if (iValuePos>0) iValuePos--;
   10660:	80 91 85 02 	lds	r24, 0x0285
   10664:	88 23       	and	r24, r24
   10666:	19 f0       	breq	.+6      	; 0x1066e <UserInput+0x1aa>
   10668:	81 50       	subi	r24, 0x01	; 1
   1066a:	80 93 85 02 	sts	0x0285, r24
					   }
				   KeyTimeout=0;
   1066e:	10 92 78 02 	sts	0x0278, r1
   10672:	10 92 77 02 	sts	0x0277, r1
				   IsSameKey=True;
   10676:	81 e0       	ldi	r24, 0x01	; 1
   10678:	80 93 7e 02 	sts	0x027E, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) 
   1067c:	80 91 80 02 	lds	r24, 0x0280
   10680:	e0 91 84 02 	lds	r30, 0x0284
   10684:	f0 e0       	ldi	r31, 0x00	; 0
   10686:	e8 56       	subi	r30, 0x68	; 104
   10688:	fd 4f       	sbci	r31, 0xFD	; 253
   1068a:	e4 91       	lpm	r30, Z+
   1068c:	8e 17       	cp	r24, r30
   1068e:	20 f4       	brcc	.+8      	; 0x10698 <UserInput+0x1d4>
				        iHit++;
   10690:	8f 5f       	subi	r24, 0xFF	; 255
   10692:	80 93 80 02 	sts	0x0280, r24
   10696:	02 c0       	rjmp	.+4      	; 0x1069c <UserInput+0x1d8>
                   else iHit=0;
   10698:	10 92 80 02 	sts	0x0280, r1
				   iLoop=1000;
   1069c:	88 ee       	ldi	r24, 0xE8	; 232
   1069e:	93 e0       	ldi	r25, 0x03	; 3
   106a0:	90 93 7a 02 	sts	0x027A, r25
   106a4:	80 93 79 02 	sts	0x0279, r24

                   zAlphaChar=AlphaChar;
   106a8:	80 91 82 02 	lds	r24, 0x0282
   106ac:	80 93 83 02 	sts	0x0283, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
   106b0:	80 91 7f 02 	lds	r24, 0x027F
   106b4:	6c 2d       	mov	r22, r12
   106b6:	40 91 80 02 	lds	r20, 0x0280
   106ba:	0e 94 9e a8 	call	0x1513c	; 0x1513c <_table_alphanum>
   106be:	80 93 82 02 	sts	0x0282, r24
                   
				   if (IsNextKey==True){
   106c2:	80 91 7d 02 	lds	r24, 0x027D
   106c6:	81 30       	cpi	r24, 0x01	; 1
   106c8:	41 f4       	brne	.+16     	; 0x106da <UserInput+0x216>
                       AlphaChar=zAlphaChar;       
   106ca:	80 91 83 02 	lds	r24, 0x0283
   106ce:	80 93 82 02 	sts	0x0282, r24
					   IsNextKey=False;
   106d2:	10 92 7d 02 	sts	0x027D, r1
					   IsSameKey=False;
   106d6:	10 92 7e 02 	sts	0x027E, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
   106da:	80 91 85 02 	lds	r24, 0x0285
   106de:	fe 01       	movw	r30, r28
   106e0:	e8 0f       	add	r30, r24
   106e2:	f1 1d       	adc	r31, r1
   106e4:	80 91 82 02 	lds	r24, 0x0282
   106e8:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
   106ea:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
   106ec:	f2 e0       	ldi	r31, 0x02	; 2
   106ee:	ff 16       	cp	r15, r31
   106f0:	71 f4       	brne	.+28     	; 0x1070e <UserInput+0x24a>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
   106f2:	a0 16       	cp	r10, r16
   106f4:	b1 06       	cpc	r11, r17
   106f6:	18 f4       	brcc	.+6      	; 0x106fe <UserInput+0x23a>
   106f8:	a1 14       	cp	r10, r1
   106fa:	b1 04       	cpc	r11, r1
   106fc:	71 f5       	brne	.+92     	; 0x1075a <UserInput+0x296>
				     iValuePos++;
   106fe:	80 91 85 02 	lds	r24, 0x0285
   10702:	8f 5f       	subi	r24, 0xFF	; 255
   10704:	80 93 85 02 	sts	0x0285, r24
					 stUserInput=uiInputDisp;
   10708:	83 e0       	ldi	r24, 0x03	; 3
   1070a:	80 93 88 02 	sts	0x0288, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
   1070e:	a0 16       	cp	r10, r16
   10710:	b1 06       	cpc	r11, r17
   10712:	18 f4       	brcc	.+6      	; 0x1071a <UserInput+0x256>
   10714:	a1 14       	cp	r10, r1
   10716:	b1 04       	cpc	r11, r1
   10718:	01 f5       	brne	.+64     	; 0x1075a <UserInput+0x296>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
   1071a:	21 e0       	ldi	r18, 0x01	; 1
   1071c:	f2 16       	cp	r15, r18
   1071e:	49 f0       	breq	.+18     	; 0x10732 <UserInput+0x26e>
   10720:	83 e0       	ldi	r24, 0x03	; 3
   10722:	f8 16       	cp	r15, r24
   10724:	31 f0       	breq	.+12     	; 0x10732 <UserInput+0x26e>
   10726:	e4 e0       	ldi	r30, 0x04	; 4
   10728:	fe 16       	cp	r15, r30
   1072a:	19 f0       	breq	.+6      	; 0x10732 <UserInput+0x26e>
   1072c:	f5 e0       	ldi	r31, 0x05	; 5
   1072e:	ff 16       	cp	r15, r31
   10730:	a1 f4       	brne	.+40     	; 0x1075a <UserInput+0x296>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
   10732:	80 91 7e 02 	lds	r24, 0x027E
   10736:	88 23       	and	r24, r24
   10738:	69 f4       	brne	.+26     	; 0x10754 <UserInput+0x290>
					      IsFirst=True;
   1073a:	81 e0       	ldi	r24, 0x01	; 1
   1073c:	80 93 7b 02 	sts	0x027B, r24
					      iValuePos++;
   10740:	80 91 85 02 	lds	r24, 0x0285
   10744:	8f 5f       	subi	r24, 0xFF	; 255
   10746:	80 93 85 02 	sts	0x0285, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
   1074a:	80 91 86 02 	lds	r24, 0x0286
   1074e:	8f 5f       	subi	r24, 0xFF	; 255
   10750:	80 93 86 02 	sts	0x0286, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
   10754:	83 e0       	ldi	r24, 0x03	; 3
   10756:	80 93 88 02 	sts	0x0288, r24
				  }
			   }
              zKeyChar=KeyChar;
   1075a:	e0 92 84 02 	sts	0x0284, r14
   1075e:	a4 e0       	ldi	r26, 0x04	; 4
   10760:	ea 2e       	mov	r14, r26
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
   10762:	9f 2d       	mov	r25, r15
   10764:	91 50       	subi	r25, 0x01	; 1
   10766:	92 30       	cpi	r25, 0x02	; 2
   10768:	18 f0       	brcs	.+6      	; 0x10770 <UserInput+0x2ac>
   1076a:	24 e0       	ldi	r18, 0x04	; 4
   1076c:	f2 16       	cp	r15, r18
   1076e:	71 f4       	brne	.+28     	; 0x1078c <UserInput+0x2c8>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
   10770:	a0 16       	cp	r10, r16
   10772:	b1 06       	cpc	r11, r17
   10774:	20 f0       	brcs	.+8      	; 0x1077e <UserInput+0x2ba>
   10776:	80 91 85 02 	lds	r24, 0x0285
   1077a:	88 15       	cp	r24, r8
   1077c:	39 f4       	brne	.+14     	; 0x1078c <UserInput+0x2c8>
			           if (MaxValue>0)system_beep(1);
   1077e:	ab 28       	or	r10, r11
   10780:	29 f0       	breq	.+10     	; 0x1078c <UserInput+0x2c8>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10782:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10784:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10786:	81 e0       	ldi	r24, 0x01	; 1
   10788:	80 93 be 01 	sts	0x01BE, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
   1078c:	87 ee       	ldi	r24, 0xE7	; 231
   1078e:	c8 16       	cp	r12, r24
   10790:	71 f4       	brne	.+28     	; 0x107ae <UserInput+0x2ea>
		      if (iValuePos>0){
   10792:	80 91 85 02 	lds	r24, 0x0285
   10796:	88 23       	and	r24, r24
   10798:	41 f0       	breq	.+16     	; 0x107aa <UserInput+0x2e6>
			      iLoop=1999;
   1079a:	8f ec       	ldi	r24, 0xCF	; 207
   1079c:	97 e0       	ldi	r25, 0x07	; 7
   1079e:	90 93 7a 02 	sts	0x027A, r25
   107a2:	80 93 79 02 	sts	0x0279, r24
				  stUserInput=uiClearDisplay;
   107a6:	82 e0       	ldi	r24, 0x02	; 2
   107a8:	26 c0       	rjmp	.+76     	; 0x107f6 <UserInput+0x332>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
   107aa:	81 e0       	ldi	r24, 0x01	; 1
   107ac:	21 c0       	rjmp	.+66     	; 0x107f0 <UserInput+0x32c>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
   107ae:	e7 eb       	ldi	r30, 0xB7	; 183
   107b0:	ce 16       	cp	r12, r30
   107b2:	19 f5       	brne	.+70     	; 0x107fa <UserInput+0x336>
		      strResult[iValuePos]=0;
   107b4:	80 91 85 02 	lds	r24, 0x0285
   107b8:	fe 01       	movw	r30, r28
   107ba:	e8 0f       	add	r30, r24
   107bc:	f1 1d       	adc	r31, r1
   107be:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
   107c0:	92 30       	cpi	r25, 0x02	; 2
   107c2:	a8 f4       	brcc	.+42     	; 0x107ee <UserInput+0x32a>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
   107c4:	88 23       	and	r24, r24
   107c6:	81 f4       	brne	.+32     	; 0x107e8 <UserInput+0x324>
   107c8:	00 d0       	rcall	.+0      	; 0x107ca <UserInput+0x306>
   107ca:	00 d0       	rcall	.+0      	; 0x107cc <UserInput+0x308>
   107cc:	ed b7       	in	r30, 0x3d	; 61
   107ce:	fe b7       	in	r31, 0x3e	; 62
   107d0:	d2 83       	std	Z+2, r29	; 0x02
   107d2:	c1 83       	std	Z+1, r28	; 0x01
   107d4:	82 ec       	ldi	r24, 0xC2	; 194
   107d6:	9c e1       	ldi	r25, 0x1C	; 28
   107d8:	94 83       	std	Z+4, r25	; 0x04
   107da:	83 83       	std	Z+3, r24	; 0x03
   107dc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   107e0:	0f 90       	pop	r0
   107e2:	0f 90       	pop	r0
   107e4:	0f 90       	pop	r0
   107e6:	0f 90       	pop	r0
			       RemZeroLead(strResult);
   107e8:	ce 01       	movw	r24, r28
   107ea:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
   107ee:	83 e0       	ldi	r24, 0x03	; 3
   107f0:	80 93 89 02 	sts	0x0289, r24
		      stUserInput=uiFinished;
   107f4:	84 e0       	ldi	r24, 0x04	; 4
   107f6:	80 93 88 02 	sts	0x0288, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
   107fa:	80 91 79 02 	lds	r24, 0x0279
   107fe:	90 91 7a 02 	lds	r25, 0x027A
   10802:	60 ed       	ldi	r22, 0xD0	; 208
   10804:	77 e0       	ldi	r23, 0x07	; 7
   10806:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
   1080a:	89 2b       	or	r24, r25
   1080c:	09 f0       	breq	.+2      	; 0x10810 <UserInput+0x34c>
   1080e:	4b c0       	rjmp	.+150    	; 0x108a6 <UserInput+0x3e2>
		      if (IsSameKey==True)
   10810:	80 91 7e 02 	lds	r24, 0x027E
   10814:	81 30       	cpi	r24, 0x01	; 1
   10816:	c9 f4       	brne	.+50     	; 0x1084a <UserInput+0x386>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
   10818:	20 91 85 02 	lds	r18, 0x0285
   1081c:	82 2f       	mov	r24, r18
   1081e:	90 e0       	ldi	r25, 0x00	; 0
   10820:	01 97       	sbiw	r24, 0x01	; 1
   10822:	8d 0d       	add	r24, r13
   10824:	91 1d       	adc	r25, r1
   10826:	64 e1       	ldi	r22, 0x14	; 20
   10828:	70 e0       	ldi	r23, 0x00	; 0
   1082a:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   1082e:	36 2f       	mov	r19, r22
   10830:	82 2f       	mov	r24, r18
   10832:	64 e1       	ldi	r22, 0x14	; 20
   10834:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
   10838:	6d 2d       	mov	r22, r13
   1083a:	69 0f       	add	r22, r25
   1083c:	89 2d       	mov	r24, r9
   1083e:	83 0f       	add	r24, r19
   10840:	40 91 82 02 	lds	r20, 0x0282
   10844:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
   10848:	2e c0       	rjmp	.+92     	; 0x108a6 <UserInput+0x3e2>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
   1084a:	f5 e0       	ldi	r31, 0x05	; 5
   1084c:	ff 16       	cp	r15, r31
   1084e:	61 f4       	brne	.+24     	; 0x10868 <UserInput+0x3a4>
   10850:	80 91 85 02 	lds	r24, 0x0285
   10854:	88 23       	and	r24, r24
   10856:	41 f0       	breq	.+16     	; 0x10868 <UserInput+0x3a4>
   10858:	60 91 86 02 	lds	r22, 0x0286
   1085c:	61 50       	subi	r22, 0x01	; 1
   1085e:	80 91 87 02 	lds	r24, 0x0287
   10862:	4a e2       	ldi	r20, 0x2A	; 42
   10864:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
   10868:	20 91 85 02 	lds	r18, 0x0285
   1086c:	82 2f       	mov	r24, r18
   1086e:	90 e0       	ldi	r25, 0x00	; 0
   10870:	01 97       	sbiw	r24, 0x01	; 1
   10872:	8d 0d       	add	r24, r13
   10874:	91 1d       	adc	r25, r1
   10876:	64 e1       	ldi	r22, 0x14	; 20
   10878:	70 e0       	ldi	r23, 0x00	; 0
   1087a:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   1087e:	36 2f       	mov	r19, r22
   10880:	82 2f       	mov	r24, r18
   10882:	64 e1       	ldi	r22, 0x14	; 20
   10884:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
   10888:	6d 2d       	mov	r22, r13
   1088a:	69 0f       	add	r22, r25
   1088c:	89 2d       	mov	r24, r9
   1088e:	83 0f       	add	r24, r19
   10890:	4f e5       	ldi	r20, 0x5F	; 95
   10892:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>

				  if (IsFirst==True){
   10896:	80 91 7b 02 	lds	r24, 0x027B
   1089a:	81 30       	cpi	r24, 0x01	; 1
   1089c:	21 f4       	brne	.+8      	; 0x108a6 <UserInput+0x3e2>
				      IsFirst=False;
   1089e:	10 92 7b 02 	sts	0x027B, r1
				      zKeyChar=0;
   108a2:	10 92 84 02 	sts	0x0284, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
   108a6:	80 91 79 02 	lds	r24, 0x0279
   108aa:	90 91 7a 02 	lds	r25, 0x027A
   108ae:	60 ed       	ldi	r22, 0xD0	; 208
   108b0:	77 e0       	ldi	r23, 0x07	; 7
   108b2:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
   108b6:	88 5e       	subi	r24, 0xE8	; 232
   108b8:	93 40       	sbci	r25, 0x03	; 3
   108ba:	d1 f5       	brne	.+116    	; 0x10930 <UserInput+0x46c>
		      if (IsSameKey==True){
   108bc:	80 91 7e 02 	lds	r24, 0x027E
   108c0:	81 30       	cpi	r24, 0x01	; 1
   108c2:	f9 f4       	brne	.+62     	; 0x10902 <UserInput+0x43e>
			      if (TypeUI!=UI_NUM_PASSWORD)
   108c4:	84 e0       	ldi	r24, 0x04	; 4
   108c6:	f8 16       	cp	r15, r24
   108c8:	b1 f0       	breq	.+44     	; 0x108f6 <UserInput+0x432>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
   108ca:	80 91 85 02 	lds	r24, 0x0285
   108ce:	90 e0       	ldi	r25, 0x00	; 0
   108d0:	01 97       	sbiw	r24, 0x01	; 1
   108d2:	8d 0d       	add	r24, r13
   108d4:	91 1d       	adc	r25, r1
   108d6:	64 e1       	ldi	r22, 0x14	; 20
   108d8:	70 e0       	ldi	r23, 0x00	; 0
   108da:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   108de:	26 2f       	mov	r18, r22
   108e0:	80 91 86 02 	lds	r24, 0x0286
   108e4:	65 e1       	ldi	r22, 0x15	; 21
   108e6:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
   108ea:	89 2d       	mov	r24, r9
   108ec:	82 0f       	add	r24, r18
   108ee:	69 2f       	mov	r22, r25
   108f0:	40 91 82 02 	lds	r20, 0x0282
   108f4:	1b c0       	rjmp	.+54     	; 0x1092c <UserInput+0x468>
					   
				  else lcd_put(xChar,yChar,'*'); 
   108f6:	80 91 87 02 	lds	r24, 0x0287
   108fa:	60 91 86 02 	lds	r22, 0x0286
   108fe:	4a e2       	ldi	r20, 0x2A	; 42
   10900:	15 c0       	rjmp	.+42     	; 0x1092c <UserInput+0x468>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
   10902:	20 91 85 02 	lds	r18, 0x0285
   10906:	82 2f       	mov	r24, r18
   10908:	90 e0       	ldi	r25, 0x00	; 0
   1090a:	01 97       	sbiw	r24, 0x01	; 1
   1090c:	8d 0d       	add	r24, r13
   1090e:	91 1d       	adc	r25, r1
   10910:	64 e1       	ldi	r22, 0x14	; 20
   10912:	70 e0       	ldi	r23, 0x00	; 0
   10914:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   10918:	36 2f       	mov	r19, r22
   1091a:	82 2f       	mov	r24, r18
   1091c:	64 e1       	ldi	r22, 0x14	; 20
   1091e:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
   10922:	d9 0e       	add	r13, r25
   10924:	89 2d       	mov	r24, r9
   10926:	83 0f       	add	r24, r19
   10928:	6d 2d       	mov	r22, r13
   1092a:	40 e2       	ldi	r20, 0x20	; 32
   1092c:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			  }
          iLoop++;
   10930:	80 91 79 02 	lds	r24, 0x0279
   10934:	90 91 7a 02 	lds	r25, 0x027A
   10938:	01 96       	adiw	r24, 0x01	; 1
   1093a:	90 93 7a 02 	sts	0x027A, r25
   1093e:	80 93 79 02 	sts	0x0279, r24
   10942:	d6 c0       	rjmp	.+428    	; 0x10af0 <UserInput+0x62c>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
   10944:	e2 e0       	ldi	r30, 0x02	; 2
   10946:	8e 17       	cp	r24, r30
   10948:	99 f4       	brne	.+38     	; 0x10970 <UserInput+0x4ac>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
   1094a:	60 91 86 02 	lds	r22, 0x0286
   1094e:	80 91 85 02 	lds	r24, 0x0285
   10952:	68 1b       	sub	r22, r24
   10954:	80 91 87 02 	lds	r24, 0x0287
   10958:	40 e2       	ldi	r20, 0x20	; 32
   1095a:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
		      strResult[iValuePos]=0;
   1095e:	80 91 85 02 	lds	r24, 0x0285
   10962:	c8 0f       	add	r28, r24
   10964:	d1 1d       	adc	r29, r1
   10966:	18 82       	st	Y, r1
		      iValuePos--;
   10968:	81 50       	subi	r24, 0x01	; 1
   1096a:	80 93 85 02 	sts	0x0285, r24
   1096e:	33 c0       	rjmp	.+102    	; 0x109d6 <UserInput+0x512>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
   10970:	f1 e0       	ldi	r31, 0x01	; 1
   10972:	8f 17       	cp	r24, r31
   10974:	49 f0       	breq	.+18     	; 0x10988 <UserInput+0x4c4>
   10976:	23 e0       	ldi	r18, 0x03	; 3
   10978:	82 17       	cp	r24, r18
   1097a:	31 f0       	breq	.+12     	; 0x10988 <UserInput+0x4c4>
   1097c:	84 e0       	ldi	r24, 0x04	; 4
   1097e:	f8 16       	cp	r15, r24
   10980:	19 f0       	breq	.+6      	; 0x10988 <UserInput+0x4c4>
   10982:	e5 e0       	ldi	r30, 0x05	; 5
   10984:	fe 16       	cp	r15, r30
   10986:	39 f5       	brne	.+78     	; 0x109d6 <UserInput+0x512>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
   10988:	20 91 85 02 	lds	r18, 0x0285
   1098c:	82 2f       	mov	r24, r18
   1098e:	90 e0       	ldi	r25, 0x00	; 0
   10990:	01 97       	sbiw	r24, 0x01	; 1
   10992:	8d 0d       	add	r24, r13
   10994:	91 1d       	adc	r25, r1
   10996:	64 e1       	ldi	r22, 0x14	; 20
   10998:	70 e0       	ldi	r23, 0x00	; 0
   1099a:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   1099e:	36 2f       	mov	r19, r22
   109a0:	82 2f       	mov	r24, r18
   109a2:	64 e1       	ldi	r22, 0x14	; 20
   109a4:	0e 94 fc b3 	call	0x167f8	; 0x167f8 <__udivmodqi4>
   109a8:	d9 0e       	add	r13, r25
   109aa:	89 2d       	mov	r24, r9
   109ac:	83 0f       	add	r24, r19
   109ae:	6d 2d       	mov	r22, r13
   109b0:	40 e2       	ldi	r20, 0x20	; 32
   109b2:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			  
		      strResult[iValuePos]=0;
   109b6:	80 91 85 02 	lds	r24, 0x0285
   109ba:	c8 0f       	add	r28, r24
   109bc:	d1 1d       	adc	r29, r1
   109be:	18 82       	st	Y, r1
		      iValuePos--;
   109c0:	81 50       	subi	r24, 0x01	; 1
   109c2:	80 93 85 02 	sts	0x0285, r24
			  yChar--;
   109c6:	80 91 86 02 	lds	r24, 0x0286
   109ca:	81 50       	subi	r24, 0x01	; 1
   109cc:	80 93 86 02 	sts	0x0286, r24
			  IsDelete=True;
   109d0:	81 e0       	ldi	r24, 0x01	; 1
   109d2:	80 93 81 02 	sts	0x0281, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
   109d6:	80 91 85 02 	lds	r24, 0x0285
   109da:	88 23       	and	r24, r24
   109dc:	19 f4       	brne	.+6      	; 0x109e4 <UserInput+0x520>
   109de:	f5 e0       	ldi	r31, 0x05	; 5
   109e0:	ef 2e       	mov	r14, r31
   109e2:	01 c0       	rjmp	.+2      	; 0x109e6 <UserInput+0x522>
   109e4:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
   109e6:	83 e0       	ldi	r24, 0x03	; 3
   109e8:	80 93 88 02 	sts	0x0288, r24
   109ec:	81 c0       	rjmp	.+258    	; 0x10af0 <UserInput+0x62c>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
   109ee:	f5 e0       	ldi	r31, 0x05	; 5
   109f0:	8f 17       	cp	r24, r31
   109f2:	19 f5       	brne	.+70     	; 0x10a3a <UserInput+0x576>
			  if (iValuePos>0){
   109f4:	80 91 85 02 	lds	r24, 0x0285
   109f8:	88 23       	and	r24, r24
   109fa:	a9 f0       	breq	.+42     	; 0x10a26 <UserInput+0x562>
                  lcd_put(xChar,(yChar-2),'*');
   109fc:	60 91 86 02 	lds	r22, 0x0286
   10a00:	62 50       	subi	r22, 0x02	; 2
   10a02:	80 91 87 02 	lds	r24, 0x0287
   10a06:	4a e2       	ldi	r20, 0x2A	; 42
   10a08:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			      if (IsDelete==True){
   10a0c:	80 91 81 02 	lds	r24, 0x0281
   10a10:	60 91 86 02 	lds	r22, 0x0286
   10a14:	81 30       	cpi	r24, 0x01	; 1
   10a16:	71 f0       	breq	.+28     	; 0x10a34 <UserInput+0x570>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
   10a18:	61 50       	subi	r22, 0x01	; 1
   10a1a:	80 91 85 02 	lds	r24, 0x0285
   10a1e:	c8 0f       	add	r28, r24
   10a20:	d1 1d       	adc	r29, r1
   10a22:	21 97       	sbiw	r28, 0x01	; 1
   10a24:	4d c0       	rjmp	.+154    	; 0x10ac0 <UserInput+0x5fc>
			      }
			  else{ if(IsDelete==True){
   10a26:	80 91 81 02 	lds	r24, 0x0281
   10a2a:	60 91 86 02 	lds	r22, 0x0286
   10a2e:	81 30       	cpi	r24, 0x01	; 1
   10a30:	09 f0       	breq	.+2      	; 0x10a34 <UserInput+0x570>
   10a32:	45 c0       	rjmp	.+138    	; 0x10abe <UserInput+0x5fa>
			           IsDelete=False;
   10a34:	10 92 81 02 	sts	0x0281, r1
   10a38:	4c c0       	rjmp	.+152    	; 0x10ad2 <UserInput+0x60e>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
   10a3a:	22 e0       	ldi	r18, 0x02	; 2
   10a3c:	82 17       	cp	r24, r18
   10a3e:	a1 f4       	brne	.+40     	; 0x10a68 <UserInput+0x5a4>
   10a40:	10 e0       	ldi	r17, 0x00	; 0
   10a42:	0d c0       	rjmp	.+26     	; 0x10a5e <UserInput+0x59a>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
   10a44:	60 91 86 02 	lds	r22, 0x0286
   10a48:	68 1b       	sub	r22, r24
   10a4a:	61 0f       	add	r22, r17
   10a4c:	fe 01       	movw	r30, r28
   10a4e:	e1 0f       	add	r30, r17
   10a50:	f1 1d       	adc	r31, r1
   10a52:	80 91 87 02 	lds	r24, 0x0287
   10a56:	40 81       	ld	r20, Z
   10a58:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
   10a5c:	1f 5f       	subi	r17, 0xFF	; 255
   10a5e:	80 91 85 02 	lds	r24, 0x0285
   10a62:	18 17       	cp	r17, r24
   10a64:	78 f3       	brcs	.-34     	; 0x10a44 <UserInput+0x580>
   10a66:	3b c0       	rjmp	.+118    	; 0x10ade <UserInput+0x61a>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
   10a68:	81 e0       	ldi	r24, 0x01	; 1
   10a6a:	f8 16       	cp	r15, r24
   10a6c:	19 f0       	breq	.+6      	; 0x10a74 <UserInput+0x5b0>
   10a6e:	e3 e0       	ldi	r30, 0x03	; 3
   10a70:	fe 16       	cp	r15, r30
   10a72:	51 f5       	brne	.+84     	; 0x10ac8 <UserInput+0x604>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
   10a74:	20 91 85 02 	lds	r18, 0x0285
   10a78:	4d 2d       	mov	r20, r13
   10a7a:	50 e0       	ldi	r21, 0x00	; 0
   10a7c:	22 23       	and	r18, r18
   10a7e:	c1 f0       	breq	.+48     	; 0x10ab0 <UserInput+0x5ec>
   10a80:	30 e0       	ldi	r19, 0x00	; 0
   10a82:	f9 01       	movw	r30, r18
   10a84:	31 97       	sbiw	r30, 0x01	; 1
   10a86:	cf 01       	movw	r24, r30
   10a88:	84 0f       	add	r24, r20
   10a8a:	95 1f       	adc	r25, r21
   10a8c:	65 e1       	ldi	r22, 0x15	; 21
   10a8e:	70 e0       	ldi	r23, 0x00	; 0
   10a90:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   10a94:	46 2f       	mov	r20, r22
   10a96:	cf 01       	movw	r24, r30
   10a98:	64 e1       	ldi	r22, 0x14	; 20
   10a9a:	70 e0       	ldi	r23, 0x00	; 0
   10a9c:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   10aa0:	d8 0e       	add	r13, r24
   10aa2:	c2 0f       	add	r28, r18
   10aa4:	d3 1f       	adc	r29, r19
   10aa6:	21 97       	sbiw	r28, 0x01	; 1
   10aa8:	89 2d       	mov	r24, r9
   10aaa:	84 0f       	add	r24, r20
   10aac:	6d 2d       	mov	r22, r13
   10aae:	0a c0       	rjmp	.+20     	; 0x10ac4 <UserInput+0x600>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
   10ab0:	60 91 86 02 	lds	r22, 0x0286
   10ab4:	86 2f       	mov	r24, r22
   10ab6:	90 e0       	ldi	r25, 0x00	; 0
   10ab8:	48 17       	cp	r20, r24
   10aba:	59 07       	cpc	r21, r25
   10abc:	84 f4       	brge	.+32     	; 0x10ade <UserInput+0x61a>
   10abe:	61 50       	subi	r22, 0x01	; 1
   10ac0:	80 91 87 02 	lds	r24, 0x0287
   10ac4:	48 81       	ld	r20, Y
   10ac6:	09 c0       	rjmp	.+18     	; 0x10ada <UserInput+0x616>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
   10ac8:	f4 e0       	ldi	r31, 0x04	; 4
   10aca:	ff 16       	cp	r15, r31
   10acc:	41 f4       	brne	.+16     	; 0x10ade <UserInput+0x61a>
		      lcd_put(xChar,(yChar-1),'*');
   10ace:	60 91 86 02 	lds	r22, 0x0286
   10ad2:	61 50       	subi	r22, 0x01	; 1
   10ad4:	80 91 87 02 	lds	r24, 0x0287
   10ad8:	4a e2       	ldi	r20, 0x2A	; 42
   10ada:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
		  }

          stUserInput=uiInput;
   10ade:	81 e0       	ldi	r24, 0x01	; 1
   10ae0:	80 93 88 02 	sts	0x0288, r24
   10ae4:	ee 24       	eor	r14, r14
   10ae6:	04 c0       	rjmp	.+8      	; 0x10af0 <UserInput+0x62c>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
   10ae8:	e0 90 89 02 	lds	r14, 0x0289
	      stUserInput=uiInit;
   10aec:	10 92 88 02 	sts	0x0288, r1
	      break;
	 }
	 return Result;
}
   10af0:	8e 2d       	mov	r24, r14
   10af2:	df 91       	pop	r29
   10af4:	cf 91       	pop	r28
   10af6:	1f 91       	pop	r17
   10af8:	0f 91       	pop	r16
   10afa:	ff 90       	pop	r15
   10afc:	ef 90       	pop	r14
   10afe:	df 90       	pop	r13
   10b00:	cf 90       	pop	r12
   10b02:	bf 90       	pop	r11
   10b04:	af 90       	pop	r10
   10b06:	9f 90       	pop	r9
   10b08:	8f 90       	pop	r8
   10b0a:	08 95       	ret

00010b0c <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   10b0c:	ef 92       	push	r14
   10b0e:	0f 93       	push	r16
   10b10:	1f 93       	push	r17
   10b12:	df 93       	push	r29
   10b14:	cf 93       	push	r28
   10b16:	cd b7       	in	r28, 0x3d	; 61
   10b18:	de b7       	in	r29, 0x3e	; 62
   10b1a:	64 97       	sbiw	r28, 0x14	; 20
   10b1c:	0f b6       	in	r0, 0x3f	; 63
   10b1e:	f8 94       	cli
   10b20:	de bf       	out	0x3e, r29	; 62
   10b22:	0f be       	out	0x3f, r0	; 63
   10b24:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoop=0;
     char uiResult=USER_NONE,KeyPressed,KeyChar;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   10b26:	80 91 16 02 	lds	r24, 0x0216
   10b2a:	86 30       	cpi	r24, 0x06	; 6
   10b2c:	09 f4       	brne	.+2      	; 0x10b30 <FMenuTicket+0x24>
   10b2e:	bf c0       	rjmp	.+382    	; 0x10cae <FMenuTicket+0x1a2>
   10b30:	87 30       	cpi	r24, 0x07	; 7
   10b32:	88 f4       	brcc	.+34     	; 0x10b56 <FMenuTicket+0x4a>
   10b34:	82 30       	cpi	r24, 0x02	; 2
   10b36:	e9 f1       	breq	.+122    	; 0x10bb2 <FMenuTicket+0xa6>
   10b38:	83 30       	cpi	r24, 0x03	; 3
   10b3a:	30 f4       	brcc	.+12     	; 0x10b48 <FMenuTicket+0x3c>
   10b3c:	88 23       	and	r24, r24
   10b3e:	09 f1       	breq	.+66     	; 0x10b82 <FMenuTicket+0x76>
   10b40:	81 30       	cpi	r24, 0x01	; 1
   10b42:	09 f0       	breq	.+2      	; 0x10b46 <FMenuTicket+0x3a>
   10b44:	21 c1       	rjmp	.+578    	; 0x10d88 <FMenuTicket+0x27c>
   10b46:	1f c0       	rjmp	.+62     	; 0x10b86 <FMenuTicket+0x7a>
   10b48:	84 30       	cpi	r24, 0x04	; 4
   10b4a:	09 f4       	brne	.+2      	; 0x10b4e <FMenuTicket+0x42>
   10b4c:	87 c0       	rjmp	.+270    	; 0x10c5c <FMenuTicket+0x150>
   10b4e:	85 30       	cpi	r24, 0x05	; 5
   10b50:	08 f0       	brcs	.+2      	; 0x10b54 <FMenuTicket+0x48>
   10b52:	a7 c0       	rjmp	.+334    	; 0x10ca2 <FMenuTicket+0x196>
   10b54:	4d c0       	rjmp	.+154    	; 0x10bf0 <FMenuTicket+0xe4>
   10b56:	89 30       	cpi	r24, 0x09	; 9
   10b58:	09 f4       	brne	.+2      	; 0x10b5c <FMenuTicket+0x50>
   10b5a:	f4 c0       	rjmp	.+488    	; 0x10d44 <FMenuTicket+0x238>
   10b5c:	8a 30       	cpi	r24, 0x0A	; 10
   10b5e:	38 f4       	brcc	.+14     	; 0x10b6e <FMenuTicket+0x62>
   10b60:	87 30       	cpi	r24, 0x07	; 7
   10b62:	09 f4       	brne	.+2      	; 0x10b66 <FMenuTicket+0x5a>
   10b64:	d2 c0       	rjmp	.+420    	; 0x10d0a <FMenuTicket+0x1fe>
   10b66:	88 30       	cpi	r24, 0x08	; 8
   10b68:	09 f0       	breq	.+2      	; 0x10b6c <FMenuTicket+0x60>
   10b6a:	0e c1       	rjmp	.+540    	; 0x10d88 <FMenuTicket+0x27c>
   10b6c:	be c0       	rjmp	.+380    	; 0x10cea <FMenuTicket+0x1de>
   10b6e:	8b 30       	cpi	r24, 0x0B	; 11
   10b70:	09 f4       	brne	.+2      	; 0x10b74 <FMenuTicket+0x68>
   10b72:	ee c0       	rjmp	.+476    	; 0x10d50 <FMenuTicket+0x244>
   10b74:	8b 30       	cpi	r24, 0x0B	; 11
   10b76:	08 f4       	brcc	.+2      	; 0x10b7a <FMenuTicket+0x6e>
   10b78:	01 c1       	rjmp	.+514    	; 0x10d7c <FMenuTicket+0x270>
   10b7a:	8c 30       	cpi	r24, 0x0C	; 12
   10b7c:	09 f0       	breq	.+2      	; 0x10b80 <FMenuTicket+0x74>
   10b7e:	04 c1       	rjmp	.+520    	; 0x10d88 <FMenuTicket+0x27c>
   10b80:	ff c0       	rjmp	.+510    	; 0x10d80 <FMenuTicket+0x274>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   10b82:	81 e0       	ldi	r24, 0x01	; 1
   10b84:	79 c0       	rjmp	.+242    	; 0x10c78 <FMenuTicket+0x16c>
	     break;
    case mtPlatNo:
	     lcd_clear();
   10b86:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   10b8a:	81 e0       	ldi	r24, 0x01	; 1
   10b8c:	61 e0       	ldi	r22, 0x01	; 1
   10b8e:	45 ec       	ldi	r20, 0xC5	; 197
   10b90:	5b e0       	ldi	r21, 0x0B	; 11
   10b92:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   10b96:	82 e0       	ldi	r24, 0x02	; 2
   10b98:	61 e0       	ldi	r22, 0x01	; 1
   10b9a:	43 ec       	ldi	r20, 0xC3	; 195
   10b9c:	5b e0       	ldi	r21, 0x0B	; 11
   10b9e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10ba2:	84 e0       	ldi	r24, 0x04	; 4
   10ba4:	61 e0       	ldi	r22, 0x01	; 1
   10ba6:	4e ea       	ldi	r20, 0xAE	; 174
   10ba8:	5b e0       	ldi	r21, 0x0B	; 11
   10baa:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		 uiResult=USER_NONE;
		 stMenuTicket=mtInputPlatNo;
   10bae:	82 e0       	ldi	r24, 0x02	; 2
   10bb0:	63 c0       	rjmp	.+198    	; 0x10c78 <FMenuTicket+0x16c>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   10bb2:	83 e0       	ldi	r24, 0x03	; 3
   10bb4:	62 e0       	ldi	r22, 0x02	; 2
   10bb6:	41 e0       	ldi	r20, 0x01	; 1
   10bb8:	23 e0       	ldi	r18, 0x03	; 3
   10bba:	39 e0       	ldi	r19, 0x09	; 9
   10bbc:	00 e0       	ldi	r16, 0x00	; 0
   10bbe:	10 e0       	ldi	r17, 0x00	; 0
   10bc0:	5a e0       	ldi	r21, 0x0A	; 10
   10bc2:	e5 2e       	mov	r14, r21
   10bc4:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10bc8:	83 30       	cpi	r24, 0x03	; 3
   10bca:	09 f4       	brne	.+2      	; 0x10bce <FMenuTicket+0xc2>
   10bcc:	55 c0       	rjmp	.+170    	; 0x10c78 <FMenuTicket+0x16c>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   10bce:	81 30       	cpi	r24, 0x01	; 1
   10bd0:	09 f4       	brne	.+2      	; 0x10bd4 <FMenuTicket+0xc8>
   10bd2:	d4 c0       	rjmp	.+424    	; 0x10d7c <FMenuTicket+0x270>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10bd4:	84 30       	cpi	r24, 0x04	; 4
   10bd6:	21 f4       	brne	.+8      	; 0x10be0 <FMenuTicket+0xd4>
   10bd8:	61 e0       	ldi	r22, 0x01	; 1
   10bda:	49 e9       	ldi	r20, 0x99	; 153
   10bdc:	5b e0       	ldi	r21, 0x0B	; 11
   10bde:	5e c0       	rjmp	.+188    	; 0x10c9c <FMenuTicket+0x190>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10be0:	85 30       	cpi	r24, 0x05	; 5
   10be2:	09 f0       	breq	.+2      	; 0x10be6 <FMenuTicket+0xda>
   10be4:	d1 c0       	rjmp	.+418    	; 0x10d88 <FMenuTicket+0x27c>
   10be6:	84 e0       	ldi	r24, 0x04	; 4
   10be8:	61 e0       	ldi	r22, 0x01	; 1
   10bea:	44 e8       	ldi	r20, 0x84	; 132
   10bec:	5b e0       	ldi	r21, 0x0B	; 11
   10bee:	56 c0       	rjmp	.+172    	; 0x10c9c <FMenuTicket+0x190>
	     break;
    case mtOdometer:
	     lcd_clear();
   10bf0:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   10bf4:	00 d0       	rcall	.+0      	; 0x10bf6 <FMenuTicket+0xea>
   10bf6:	00 d0       	rcall	.+0      	; 0x10bf8 <FMenuTicket+0xec>
   10bf8:	00 d0       	rcall	.+0      	; 0x10bfa <FMenuTicket+0xee>
   10bfa:	ed b7       	in	r30, 0x3d	; 61
   10bfc:	fe b7       	in	r31, 0x3e	; 62
   10bfe:	31 96       	adiw	r30, 0x01	; 1
   10c00:	8e 01       	movw	r16, r28
   10c02:	0f 5f       	subi	r16, 0xFF	; 255
   10c04:	1f 4f       	sbci	r17, 0xFF	; 255
   10c06:	ad b7       	in	r26, 0x3d	; 61
   10c08:	be b7       	in	r27, 0x3e	; 62
   10c0a:	12 96       	adiw	r26, 0x02	; 2
   10c0c:	1c 93       	st	X, r17
   10c0e:	0e 93       	st	-X, r16
   10c10:	11 97       	sbiw	r26, 0x01	; 1
   10c12:	87 e7       	ldi	r24, 0x77	; 119
   10c14:	9b e0       	ldi	r25, 0x0B	; 11
   10c16:	93 83       	std	Z+3, r25	; 0x03
   10c18:	82 83       	std	Z+2, r24	; 0x02
   10c1a:	83 e0       	ldi	r24, 0x03	; 3
   10c1c:	99 e0       	ldi	r25, 0x09	; 9
   10c1e:	95 83       	std	Z+5, r25	; 0x05
   10c20:	84 83       	std	Z+4, r24	; 0x04
   10c22:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	     lcd_print(1,1,lcdteks);
   10c26:	8d b7       	in	r24, 0x3d	; 61
   10c28:	9e b7       	in	r25, 0x3e	; 62
   10c2a:	06 96       	adiw	r24, 0x06	; 6
   10c2c:	0f b6       	in	r0, 0x3f	; 63
   10c2e:	f8 94       	cli
   10c30:	9e bf       	out	0x3e, r25	; 62
   10c32:	0f be       	out	0x3f, r0	; 63
   10c34:	8d bf       	out	0x3d, r24	; 61
   10c36:	81 e0       	ldi	r24, 0x01	; 1
   10c38:	61 e0       	ldi	r22, 0x01	; 1
   10c3a:	a8 01       	movw	r20, r16
   10c3c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   10c40:	82 e0       	ldi	r24, 0x02	; 2
   10c42:	61 e0       	ldi	r22, 0x01	; 1
   10c44:	4b e6       	ldi	r20, 0x6B	; 107
   10c46:	5b e0       	ldi	r21, 0x0B	; 11
   10c48:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10c4c:	84 e0       	ldi	r24, 0x04	; 4
   10c4e:	61 e0       	ldi	r22, 0x01	; 1
   10c50:	46 e5       	ldi	r20, 0x56	; 86
   10c52:	5b e0       	ldi	r21, 0x0B	; 11
   10c54:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		 uiResult=USER_NONE;
		 stMenuTicket=mtInputOdometer;
   10c58:	84 e0       	ldi	r24, 0x04	; 4
   10c5a:	0e c0       	rjmp	.+28     	; 0x10c78 <FMenuTicket+0x16c>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   10c5c:	81 e0       	ldi	r24, 0x01	; 1
   10c5e:	62 e0       	ldi	r22, 0x02	; 2
   10c60:	4a e0       	ldi	r20, 0x0A	; 10
   10c62:	2c ec       	ldi	r18, 0xCC	; 204
   10c64:	33 e0       	ldi	r19, 0x03	; 3
   10c66:	00 e0       	ldi	r16, 0x00	; 0
   10c68:	10 e0       	ldi	r17, 0x00	; 0
   10c6a:	9a e0       	ldi	r25, 0x0A	; 10
   10c6c:	e9 2e       	mov	r14, r25
   10c6e:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   10c72:	83 30       	cpi	r24, 0x03	; 3
   10c74:	21 f4       	brne	.+8      	; 0x10c7e <FMenuTicket+0x172>
   10c76:	85 e0       	ldi	r24, 0x05	; 5
   10c78:	80 93 16 02 	sts	0x0216, r24
   10c7c:	85 c0       	rjmp	.+266    	; 0x10d88 <FMenuTicket+0x27c>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   10c7e:	81 30       	cpi	r24, 0x01	; 1
   10c80:	d9 f3       	breq	.-10     	; 0x10c78 <FMenuTicket+0x16c>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10c82:	84 30       	cpi	r24, 0x04	; 4
   10c84:	21 f4       	brne	.+8      	; 0x10c8e <FMenuTicket+0x182>
   10c86:	61 e0       	ldi	r22, 0x01	; 1
   10c88:	41 e4       	ldi	r20, 0x41	; 65
   10c8a:	5b e0       	ldi	r21, 0x0B	; 11
   10c8c:	07 c0       	rjmp	.+14     	; 0x10c9c <FMenuTicket+0x190>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10c8e:	85 30       	cpi	r24, 0x05	; 5
   10c90:	09 f0       	breq	.+2      	; 0x10c94 <FMenuTicket+0x188>
   10c92:	7a c0       	rjmp	.+244    	; 0x10d88 <FMenuTicket+0x27c>
   10c94:	84 e0       	ldi	r24, 0x04	; 4
   10c96:	61 e0       	ldi	r22, 0x01	; 1
   10c98:	4c e2       	ldi	r20, 0x2C	; 44
   10c9a:	5b e0       	ldi	r21, 0x0B	; 11
   10c9c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   10ca0:	73 c0       	rjmp	.+230    	; 0x10d88 <FMenuTicket+0x27c>
	     break;
    case mtFIP:
	     lcd_clear();
   10ca2:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		 _scr_pump();
   10ca6:	0e 94 58 22 	call	0x44b0	; 0x44b0 <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10caa:	86 e0       	ldi	r24, 0x06	; 6
   10cac:	e5 cf       	rjmp	.-54     	; 0x10c78 <FMenuTicket+0x16c>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10cae:	81 e0       	ldi	r24, 0x01	; 1
   10cb0:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   10cb4:	18 2f       	mov	r17, r24
		 KeyChar=_key_btn(KeyPressed);
   10cb6:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10cba:	81 53       	subi	r24, 0x31	; 49
   10cbc:	88 30       	cpi	r24, 0x08	; 8
   10cbe:	40 f4       	brcc	.+16     	; 0x10cd0 <FMenuTicket+0x1c4>
		     FIP_Used=KeyChar-'0';
   10cc0:	8f 5f       	subi	r24, 0xFF	; 255
   10cc2:	80 93 13 02 	sts	0x0213, r24
			 zFIP_Used=FIP_Used;
   10cc6:	80 93 12 02 	sts	0x0212, r24
		     stMenuTicket=mtSendMsg98;
   10cca:	87 e0       	ldi	r24, 0x07	; 7
   10ccc:	80 93 16 02 	sts	0x0216, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10cd0:	17 3e       	cpi	r17, 0xE7	; 231
   10cd2:	11 f4       	brne	.+4      	; 0x10cd8 <FMenuTicket+0x1cc>
             stMenuTicket=mtOdometer;
   10cd4:	83 e0       	ldi	r24, 0x03	; 3
   10cd6:	d0 cf       	rjmp	.-96     	; 0x10c78 <FMenuTicket+0x16c>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   10cd8:	17 3b       	cpi	r17, 0xB7	; 183
   10cda:	09 f0       	breq	.+2      	; 0x10cde <FMenuTicket+0x1d2>
   10cdc:	55 c0       	rjmp	.+170    	; 0x10d88 <FMenuTicket+0x27c>
		     FIP_Used=zFIP_Used;
   10cde:	80 91 12 02 	lds	r24, 0x0212
   10ce2:	80 93 13 02 	sts	0x0213, r24
             stMenuTicket=mtInitWaitMessage99;
   10ce6:	88 e0       	ldi	r24, 0x08	; 8
   10ce8:	c7 cf       	rjmp	.-114    	; 0x10c78 <FMenuTicket+0x16c>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   10cea:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   10cee:	82 e0       	ldi	r24, 0x02	; 2
   10cf0:	61 e0       	ldi	r22, 0x01	; 1
   10cf2:	4f e1       	ldi	r20, 0x1F	; 31
   10cf4:	5b e0       	ldi	r21, 0x0B	; 11
   10cf6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   10cfa:	83 e0       	ldi	r24, 0x03	; 3
   10cfc:	61 e0       	ldi	r22, 0x01	; 1
   10cfe:	48 e1       	ldi	r20, 0x18	; 24
   10d00:	5b e0       	ldi	r21, 0x0B	; 11
   10d02:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
         stMenuTicket=mtSendMsg98;
   10d06:	87 e0       	ldi	r24, 0x07	; 7
   10d08:	b7 cf       	rjmp	.-146    	; 0x10c78 <FMenuTicket+0x16c>
	     break;
    case mtSendMsg98:
	     iPos=0;
   10d0a:	10 92 15 02 	sts	0x0215, r1
		 iSend=0;
   10d0e:	10 92 14 02 	sts	0x0214, r1
		 IsMessage99=False;
   10d12:	10 92 a1 01 	sts	0x01A1, r1
		 TimSend=0;
   10d16:	10 92 91 0e 	sts	0x0E91, r1
		 iLoop=0;
   10d1a:	10 92 11 02 	sts	0x0211, r1
   10d1e:	10 92 10 02 	sts	0x0210, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   10d22:	80 91 00 01 	lds	r24, 0x0100
   10d26:	81 30       	cpi	r24, 0x01	; 1
   10d28:	29 f4       	brne	.+10     	; 0x10d34 <FMenuTicket+0x228>
   10d2a:	80 91 13 02 	lds	r24, 0x0213
   10d2e:	0e 94 2c 50 	call	0xa058	; 0xa058 <sendMessage98>
   10d32:	24 c0       	rjmp	.+72     	; 0x10d7c <FMenuTicket+0x270>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   10d34:	82 30       	cpi	r24, 0x02	; 2
   10d36:	11 f5       	brne	.+68     	; 0x10d7c <FMenuTicket+0x270>
   10d38:	80 91 13 02 	lds	r24, 0x0213
   10d3c:	60 e0       	ldi	r22, 0x00	; 0
   10d3e:	0e 94 75 24 	call	0x48ea	; 0x48ea <PrintStandalone>
   10d42:	1c c0       	rjmp	.+56     	; 0x10d7c <FMenuTicket+0x270>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   10d44:	80 91 a1 01 	lds	r24, 0x01A1
   10d48:	81 30       	cpi	r24, 0x01	; 1
   10d4a:	f1 f4       	brne	.+60     	; 0x10d88 <FMenuTicket+0x27c>
		    stMenuTicket=mtMessage99Received;
   10d4c:	8a e0       	ldi	r24, 0x0A	; 10
   10d4e:	94 cf       	rjmp	.-216    	; 0x10c78 <FMenuTicket+0x16c>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10d50:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   10d54:	82 e0       	ldi	r24, 0x02	; 2
   10d56:	61 e0       	ldi	r22, 0x01	; 1
   10d58:	44 e0       	ldi	r20, 0x04	; 4
   10d5a:	5b e0       	ldi	r21, 0x0B	; 11
   10d5c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10d60:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10d62:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10d64:	82 e0       	ldi	r24, 0x02	; 2
   10d66:	80 93 be 01 	sts	0x01BE, r24
   10d6a:	80 e2       	ldi	r24, 0x20	; 32
   10d6c:	9e e4       	ldi	r25, 0x4E	; 78
   10d6e:	29 e1       	ldi	r18, 0x19	; 25
   10d70:	30 e0       	ldi	r19, 0x00	; 0
   10d72:	f9 01       	movw	r30, r18
   10d74:	31 97       	sbiw	r30, 0x01	; 1
   10d76:	f1 f7       	brne	.-4      	; 0x10d74 <FMenuTicket+0x268>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10d78:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10d7a:	d9 f7       	brne	.-10     	; 0x10d72 <FMenuTicket+0x266>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10d7c:	8c e0       	ldi	r24, 0x0C	; 12
   10d7e:	7c cf       	rjmp	.-264    	; 0x10c78 <FMenuTicket+0x16c>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10d80:	10 92 16 02 	sts	0x0216, r1
   10d84:	81 e0       	ldi	r24, 0x01	; 1
   10d86:	01 c0       	rjmp	.+2      	; 0x10d8a <FMenuTicket+0x27e>
   10d88:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10d8a:	64 96       	adiw	r28, 0x14	; 20
   10d8c:	0f b6       	in	r0, 0x3f	; 63
   10d8e:	f8 94       	cli
   10d90:	de bf       	out	0x3e, r29	; 62
   10d92:	0f be       	out	0x3f, r0	; 63
   10d94:	cd bf       	out	0x3d, r28	; 61
   10d96:	cf 91       	pop	r28
   10d98:	df 91       	pop	r29
   10d9a:	1f 91       	pop	r17
   10d9c:	0f 91       	pop	r16
   10d9e:	ef 90       	pop	r14
   10da0:	08 95       	ret

00010da2 <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}

char FSettingOperator(){//Change Active Operator, Change Password
   10da2:	ef 92       	push	r14
   10da4:	0f 93       	push	r16
   10da6:	1f 93       	push	r17
   10da8:	df 93       	push	r29
   10daa:	cf 93       	push	r28
   10dac:	cd b7       	in	r28, 0x3d	; 61
   10dae:	de b7       	in	r29, 0x3e	; 62
   10db0:	e5 97       	sbiw	r28, 0x35	; 53
   10db2:	0f b6       	in	r0, 0x3f	; 63
   10db4:	f8 94       	cli
   10db6:	de bf       	out	0x3e, r29	; 62
   10db8:	0f be       	out	0x3f, r0	; 63
   10dba:	cd bf       	out	0x3d, r28	; 61
	        char KeyPressed,KeyChar,lcdteks[20],strPassword[15];
			char strOperatorName[18];
			char uiResult=USER_NONE,Result=MENU_NONE;

	 Result=MENU_NONE;
	 switch(stSettingOperator){
   10dbc:	80 91 27 02 	lds	r24, 0x0227
   10dc0:	87 30       	cpi	r24, 0x07	; 7
   10dc2:	09 f4       	brne	.+2      	; 0x10dc6 <FSettingOperator+0x24>
   10dc4:	78 c1       	rjmp	.+752    	; 0x110b6 <FSettingOperator+0x314>
   10dc6:	88 30       	cpi	r24, 0x08	; 8
   10dc8:	90 f4       	brcc	.+36     	; 0x10dee <FSettingOperator+0x4c>
   10dca:	83 30       	cpi	r24, 0x03	; 3
   10dcc:	09 f4       	brne	.+2      	; 0x10dd0 <FSettingOperator+0x2e>
   10dce:	a0 c0       	rjmp	.+320    	; 0x10f10 <FSettingOperator+0x16e>
   10dd0:	84 30       	cpi	r24, 0x04	; 4
   10dd2:	30 f4       	brcc	.+12     	; 0x10de0 <FSettingOperator+0x3e>
   10dd4:	81 30       	cpi	r24, 0x01	; 1
   10dd6:	d1 f1       	breq	.+116    	; 0x10e4c <FSettingOperator+0xaa>
   10dd8:	82 30       	cpi	r24, 0x02	; 2
   10dda:	08 f0       	brcs	.+2      	; 0x10dde <FSettingOperator+0x3c>
   10ddc:	4a c0       	rjmp	.+148    	; 0x10e72 <FSettingOperator+0xd0>
   10dde:	20 c0       	rjmp	.+64     	; 0x10e20 <FSettingOperator+0x7e>
   10de0:	85 30       	cpi	r24, 0x05	; 5
   10de2:	09 f4       	brne	.+2      	; 0x10de6 <FSettingOperator+0x44>
   10de4:	39 c1       	rjmp	.+626    	; 0x11058 <FSettingOperator+0x2b6>
   10de6:	86 30       	cpi	r24, 0x06	; 6
   10de8:	08 f0       	brcs	.+2      	; 0x10dec <FSettingOperator+0x4a>
   10dea:	52 c1       	rjmp	.+676    	; 0x11090 <FSettingOperator+0x2ee>
   10dec:	ff c0       	rjmp	.+510    	; 0x10fec <FSettingOperator+0x24a>
   10dee:	8b 30       	cpi	r24, 0x0B	; 11
   10df0:	09 f4       	brne	.+2      	; 0x10df4 <FSettingOperator+0x52>
   10df2:	23 c2       	rjmp	.+1094   	; 0x1123a <FSettingOperator+0x498>
   10df4:	8c 30       	cpi	r24, 0x0C	; 12
   10df6:	38 f4       	brcc	.+14     	; 0x10e06 <FSettingOperator+0x64>
   10df8:	89 30       	cpi	r24, 0x09	; 9
   10dfa:	09 f4       	brne	.+2      	; 0x10dfe <FSettingOperator+0x5c>
   10dfc:	aa c1       	rjmp	.+852    	; 0x11152 <FSettingOperator+0x3b0>
   10dfe:	8a 30       	cpi	r24, 0x0A	; 10
   10e00:	08 f0       	brcs	.+2      	; 0x10e04 <FSettingOperator+0x62>
   10e02:	da c1       	rjmp	.+948    	; 0x111b8 <FSettingOperator+0x416>
   10e04:	78 c1       	rjmp	.+752    	; 0x110f6 <FSettingOperator+0x354>
   10e06:	8d 30       	cpi	r24, 0x0D	; 13
   10e08:	09 f4       	brne	.+2      	; 0x10e0c <FSettingOperator+0x6a>
   10e0a:	9b c2       	rjmp	.+1334   	; 0x11342 <FSettingOperator+0x5a0>
   10e0c:	8d 30       	cpi	r24, 0x0D	; 13
   10e0e:	08 f4       	brcc	.+2      	; 0x10e12 <FSettingOperator+0x70>
   10e10:	1b c2       	rjmp	.+1078   	; 0x11248 <FSettingOperator+0x4a6>
   10e12:	8e 30       	cpi	r24, 0x0E	; 14
   10e14:	09 f4       	brne	.+2      	; 0x10e18 <FSettingOperator+0x76>
   10e16:	9a c2       	rjmp	.+1332   	; 0x1134c <FSettingOperator+0x5aa>
   10e18:	8f 30       	cpi	r24, 0x0F	; 15
   10e1a:	09 f0       	breq	.+2      	; 0x10e1e <FSettingOperator+0x7c>
   10e1c:	a2 c2       	rjmp	.+1348   	; 0x11362 <FSettingOperator+0x5c0>
   10e1e:	9d c2       	rjmp	.+1338   	; 0x1135a <FSettingOperator+0x5b8>
	 case soMenuOption:
	      lcd_clear();
   10e20:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Change Operator"));
   10e24:	81 e0       	ldi	r24, 0x01	; 1
   10e26:	61 e0       	ldi	r22, 0x01	; 1
   10e28:	4c ed       	ldi	r20, 0xDC	; 220
   10e2a:	51 e1       	ldi	r21, 0x11	; 17
   10e2c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Change Password"));
   10e30:	82 e0       	ldi	r24, 0x02	; 2
   10e32:	61 e0       	ldi	r22, 0x01	; 1
   10e34:	4a ec       	ldi	r20, 0xCA	; 202
   10e36:	51 e1       	ldi	r21, 0x11	; 17
   10e38:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back          "));
   10e3c:	84 e0       	ldi	r24, 0x04	; 4
   10e3e:	61 e0       	ldi	r22, 0x01	; 1
   10e40:	48 eb       	ldi	r20, 0xB8	; 184
   10e42:	51 e1       	ldi	r21, 0x11	; 17
   10e44:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          stSettingOperator=soMenuOptionInput;
   10e48:	81 e0       	ldi	r24, 0x01	; 1
   10e4a:	64 c2       	rjmp	.+1224   	; 0x11314 <FSettingOperator+0x572>
	      break;
     case soMenuOptionInput:
	      KeyPressed=_key_scan(1);
   10e4c:	81 e0       	ldi	r24, 0x01	; 1
   10e4e:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10e52:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  switch(KeyChar){
   10e56:	81 33       	cpi	r24, 0x31	; 49
   10e58:	31 f0       	breq	.+12     	; 0x10e66 <FSettingOperator+0xc4>
   10e5a:	82 33       	cpi	r24, 0x32	; 50
   10e5c:	31 f0       	breq	.+12     	; 0x10e6a <FSettingOperator+0xc8>
   10e5e:	8a 32       	cpi	r24, 0x2A	; 42
   10e60:	09 f0       	breq	.+2      	; 0x10e64 <FSettingOperator+0xc2>
   10e62:	7f c2       	rjmp	.+1278   	; 0x11362 <FSettingOperator+0x5c0>
   10e64:	04 c0       	rjmp	.+8      	; 0x10e6e <FSettingOperator+0xcc>
		  case '1':
		       stSettingOperator=soChangeOperatorInit;
   10e66:	82 e0       	ldi	r24, 0x02	; 2
   10e68:	55 c2       	rjmp	.+1194   	; 0x11314 <FSettingOperator+0x572>
		       break;
          case '2':
		       stSettingOperator=soChangePasswordInit;
   10e6a:	85 e0       	ldi	r24, 0x05	; 5
   10e6c:	53 c2       	rjmp	.+1190   	; 0x11314 <FSettingOperator+0x572>
		       break;
          case '*':
		       stSettingOperator=soExitSettingOperator;
   10e6e:	8f e0       	ldi	r24, 0x0F	; 15
   10e70:	51 c2       	rjmp	.+1186   	; 0x11314 <FSettingOperator+0x572>
		       break;
		  }
	      break;
     case soChangeOperatorInit:
	      lcd_clear();		  
   10e72:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   10e76:	8e 01       	movw	r16, r28
   10e78:	00 5f       	subi	r16, 0xF0	; 240
   10e7a:	1f 4f       	sbci	r17, 0xFF	; 255
   10e7c:	c8 01       	movw	r24, r16
   10e7e:	65 e1       	ldi	r22, 0x15	; 21
   10e80:	70 e0       	ldi	r23, 0x00	; 0
   10e82:	42 e1       	ldi	r20, 0x12	; 18
   10e84:	50 e0       	ldi	r21, 0x00	; 0
   10e86:	22 e4       	ldi	r18, 0x42	; 66
   10e88:	33 e1       	ldi	r19, 0x13	; 19
   10e8a:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10e8e:	98 01       	movw	r18, r16
   10e90:	ce 01       	movw	r24, r28
   10e92:	4f 96       	adiw	r24, 0x1f	; 31
	    Dest[i]=Source[IdxSource+i];
   10e94:	0f 5f       	subi	r16, 0xFF	; 255
   10e96:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10e98:	08 17       	cp	r16, r24
   10e9a:	19 07       	cpc	r17, r25
   10e9c:	d9 f7       	brne	.-10     	; 0x10e94 <FSettingOperator+0xf2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10e9e:	1f 8e       	std	Y+31, r1	; 0x1f
     case soChangeOperatorInit:
	      lcd_clear();		  
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);

		  sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10ea0:	00 d0       	rcall	.+0      	; 0x10ea2 <FSettingOperator+0x100>
   10ea2:	00 d0       	rcall	.+0      	; 0x10ea4 <FSettingOperator+0x102>
   10ea4:	00 d0       	rcall	.+0      	; 0x10ea6 <FSettingOperator+0x104>
   10ea6:	ed b7       	in	r30, 0x3d	; 61
   10ea8:	fe b7       	in	r31, 0x3e	; 62
   10eaa:	31 96       	adiw	r30, 0x01	; 1
   10eac:	8e 01       	movw	r16, r28
   10eae:	0e 5d       	subi	r16, 0xDE	; 222
   10eb0:	1f 4f       	sbci	r17, 0xFF	; 255
   10eb2:	ad b7       	in	r26, 0x3d	; 61
   10eb4:	be b7       	in	r27, 0x3e	; 62
   10eb6:	12 96       	adiw	r26, 0x02	; 2
   10eb8:	1c 93       	st	X, r17
   10eba:	0e 93       	st	-X, r16
   10ebc:	11 97       	sbiw	r26, 0x01	; 1
   10ebe:	85 eb       	ldi	r24, 0xB5	; 181
   10ec0:	91 e1       	ldi	r25, 0x11	; 17
   10ec2:	93 83       	std	Z+3, r25	; 0x03
   10ec4:	82 83       	std	Z+2, r24	; 0x02
   10ec6:	24 83       	std	Z+4, r18	; 0x04
   10ec8:	35 83       	std	Z+5, r19	; 0x05
   10eca:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_printf(1,1,PSTR("Name:"));
   10ece:	8d b7       	in	r24, 0x3d	; 61
   10ed0:	9e b7       	in	r25, 0x3e	; 62
   10ed2:	06 96       	adiw	r24, 0x06	; 6
   10ed4:	0f b6       	in	r0, 0x3f	; 63
   10ed6:	f8 94       	cli
   10ed8:	9e bf       	out	0x3e, r25	; 62
   10eda:	0f be       	out	0x3f, r0	; 63
   10edc:	8d bf       	out	0x3d, r24	; 61
   10ede:	81 e0       	ldi	r24, 0x01	; 1
   10ee0:	61 e0       	ldi	r22, 0x01	; 1
   10ee2:	4f ea       	ldi	r20, 0xAF	; 175
   10ee4:	51 e1       	ldi	r21, 0x11	; 17
   10ee6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_print (1,6,lcdteks);
   10eea:	81 e0       	ldi	r24, 0x01	; 1
   10eec:	66 e0       	ldi	r22, 0x06	; 6
   10eee:	a8 01       	movw	r20, r16
   10ef0:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(2,1,PSTR("New :_              "));
   10ef4:	82 e0       	ldi	r24, 0x02	; 2
   10ef6:	61 e0       	ldi	r22, 0x01	; 1
   10ef8:	4a e9       	ldi	r20, 0x9A	; 154
   10efa:	51 e1       	ldi	r21, 0x11	; 17
   10efc:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f00:	84 e0       	ldi	r24, 0x04	; 4
   10f02:	61 e0       	ldi	r22, 0x01	; 1
   10f04:	45 e8       	ldi	r20, 0x85	; 133
   10f06:	51 e1       	ldi	r21, 0x11	; 17
   10f08:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          stSettingOperator=soOperatorNameInput;
   10f0c:	83 e0       	ldi	r24, 0x03	; 3
   10f0e:	02 c2       	rjmp	.+1028   	; 0x11314 <FSettingOperator+0x572>
	      break;
     case soOperatorNameInput:
          uiResult=USER_NONE;
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
   10f10:	83 e0       	ldi	r24, 0x03	; 3
   10f12:	62 e0       	ldi	r22, 0x02	; 2
   10f14:	46 e0       	ldi	r20, 0x06	; 6
   10f16:	2b e9       	ldi	r18, 0x9B	; 155
   10f18:	38 e0       	ldi	r19, 0x08	; 8
   10f1a:	00 e0       	ldi	r16, 0x00	; 0
   10f1c:	10 e0       	ldi	r17, 0x00	; 0
   10f1e:	a0 e1       	ldi	r26, 0x10	; 16
   10f20:	ea 2e       	mov	r14, r26
   10f22:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  switch(uiResult){
   10f26:	83 30       	cpi	r24, 0x03	; 3
   10f28:	51 f0       	breq	.+20     	; 0x10f3e <FSettingOperator+0x19c>
   10f2a:	84 30       	cpi	r24, 0x04	; 4
   10f2c:	08 f4       	brcc	.+2      	; 0x10f30 <FSettingOperator+0x18e>
   10f2e:	f2 c0       	rjmp	.+484    	; 0x11114 <FSettingOperator+0x372>
   10f30:	84 30       	cpi	r24, 0x04	; 4
   10f32:	09 f4       	brne	.+2      	; 0x10f36 <FSettingOperator+0x194>
   10f34:	51 c0       	rjmp	.+162    	; 0x10fd8 <FSettingOperator+0x236>
   10f36:	85 30       	cpi	r24, 0x05	; 5
   10f38:	09 f0       	breq	.+2      	; 0x10f3c <FSettingOperator+0x19a>
   10f3a:	13 c2       	rjmp	.+1062   	; 0x11362 <FSettingOperator+0x5c0>
   10f3c:	52 c0       	rjmp	.+164    	; 0x10fe2 <FSettingOperator+0x240>
		  case USER_OK:
		       lcd_clear();
   10f3e:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   10f42:	20 e0       	ldi	r18, 0x00	; 0
   10f44:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   10f46:	ae 01       	movw	r20, r28
   10f48:	40 5f       	subi	r20, 0xF0	; 240
   10f4a:	5f 4f       	sbci	r21, 0xFF	; 255
   10f4c:	fa 01       	movw	r30, r20
   10f4e:	e2 0f       	add	r30, r18
   10f50:	f3 1f       	adc	r31, r19
   10f52:	d9 01       	movw	r26, r18
   10f54:	a5 56       	subi	r26, 0x65	; 101
   10f56:	b7 4f       	sbci	r27, 0xF7	; 247
   10f58:	8c 91       	ld	r24, X
   10f5a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10f5c:	2f 5f       	subi	r18, 0xFF	; 255
   10f5e:	3f 4f       	sbci	r19, 0xFF	; 255
   10f60:	2f 30       	cpi	r18, 0x0F	; 15
   10f62:	31 05       	cpc	r19, r1
   10f64:	99 f7       	brne	.-26     	; 0x10f4c <FSettingOperator+0x1aa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10f66:	1f 8e       	std	Y+31, r1	; 0x1f
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
		  switch(uiResult){
		  case USER_OK:
		       lcd_clear();
			   StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
		       sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10f68:	00 d0       	rcall	.+0      	; 0x10f6a <FSettingOperator+0x1c8>
   10f6a:	00 d0       	rcall	.+0      	; 0x10f6c <FSettingOperator+0x1ca>
   10f6c:	00 d0       	rcall	.+0      	; 0x10f6e <FSettingOperator+0x1cc>
   10f6e:	ed b7       	in	r30, 0x3d	; 61
   10f70:	fe b7       	in	r31, 0x3e	; 62
   10f72:	31 96       	adiw	r30, 0x01	; 1
   10f74:	8e 01       	movw	r16, r28
   10f76:	0e 5d       	subi	r16, 0xDE	; 222
   10f78:	1f 4f       	sbci	r17, 0xFF	; 255
   10f7a:	ad b7       	in	r26, 0x3d	; 61
   10f7c:	be b7       	in	r27, 0x3e	; 62
   10f7e:	12 96       	adiw	r26, 0x02	; 2
   10f80:	1c 93       	st	X, r17
   10f82:	0e 93       	st	-X, r16
   10f84:	11 97       	sbiw	r26, 0x01	; 1
   10f86:	82 e8       	ldi	r24, 0x82	; 130
   10f88:	91 e1       	ldi	r25, 0x11	; 17
   10f8a:	93 83       	std	Z+3, r25	; 0x03
   10f8c:	82 83       	std	Z+2, r24	; 0x02
   10f8e:	55 83       	std	Z+5, r21	; 0x05
   10f90:	44 83       	std	Z+4, r20	; 0x04
   10f92:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			   lcd_printf(1,1,PSTR("New Operator:"));
   10f96:	8d b7       	in	r24, 0x3d	; 61
   10f98:	9e b7       	in	r25, 0x3e	; 62
   10f9a:	06 96       	adiw	r24, 0x06	; 6
   10f9c:	0f b6       	in	r0, 0x3f	; 63
   10f9e:	f8 94       	cli
   10fa0:	9e bf       	out	0x3e, r25	; 62
   10fa2:	0f be       	out	0x3f, r0	; 63
   10fa4:	8d bf       	out	0x3d, r24	; 61
   10fa6:	81 e0       	ldi	r24, 0x01	; 1
   10fa8:	61 e0       	ldi	r22, 0x01	; 1
   10faa:	44 e7       	ldi	r20, 0x74	; 116
   10fac:	51 e1       	ldi	r21, 0x11	; 17
   10fae:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   lcd_print (2,1,lcdteks);
   10fb2:	82 e0       	ldi	r24, 0x02	; 2
   10fb4:	61 e0       	ldi	r22, 0x01	; 1
   10fb6:	a8 01       	movw	r20, r16
   10fb8:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			   lcd_printf(3,1,PSTR("Save?"));
   10fbc:	83 e0       	ldi	r24, 0x03	; 3
   10fbe:	61 e0       	ldi	r22, 0x01	; 1
   10fc0:	4e e6       	ldi	r20, 0x6E	; 110
   10fc2:	51 e1       	ldi	r21, 0x11	; 17
   10fc4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]No    [#]Yes"));
   10fc8:	84 e0       	ldi	r24, 0x04	; 4
   10fca:	61 e0       	ldi	r22, 0x01	; 1
   10fcc:	4e e5       	ldi	r20, 0x5E	; 94
   10fce:	51 e1       	ldi	r21, 0x11	; 17
   10fd0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
               stSettingOperator=soIsSaveOperatorName;
   10fd4:	84 e0       	ldi	r24, 0x04	; 4
   10fd6:	9e c1       	rjmp	.+828    	; 0x11314 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10fd8:	84 e0       	ldi	r24, 0x04	; 4
   10fda:	61 e0       	ldi	r22, 0x01	; 1
   10fdc:	49 e4       	ldi	r20, 0x49	; 73
   10fde:	51 e1       	ldi	r21, 0x11	; 17
   10fe0:	29 c1       	rjmp	.+594    	; 0x11234 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10fe2:	84 e0       	ldi	r24, 0x04	; 4
   10fe4:	61 e0       	ldi	r22, 0x01	; 1
   10fe6:	44 e3       	ldi	r20, 0x34	; 52
   10fe8:	51 e1       	ldi	r21, 0x11	; 17
   10fea:	24 c1       	rjmp	.+584    	; 0x11234 <FSettingOperator+0x492>
		       break;
		  }
	      break;
     case soIsSaveOperatorName:
          KeyPressed=_key_scan(1);
   10fec:	81 e0       	ldi	r24, 0x01	; 1
   10fee:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10ff2:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  switch(KeyChar){
   10ff6:	83 32       	cpi	r24, 0x23	; 35
   10ff8:	09 f0       	breq	.+2      	; 0x10ffc <FSettingOperator+0x25a>
   10ffa:	53 c0       	rjmp	.+166    	; 0x110a2 <FSettingOperator+0x300>
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
   10ffc:	20 e0       	ldi	r18, 0x00	; 0
   10ffe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11000:	8e 01       	movw	r16, r28
   11002:	00 5f       	subi	r16, 0xF0	; 240
   11004:	1f 4f       	sbci	r17, 0xFF	; 255
   11006:	f8 01       	movw	r30, r16
   11008:	e2 0f       	add	r30, r18
   1100a:	f3 1f       	adc	r31, r19
   1100c:	d9 01       	movw	r26, r18
   1100e:	a5 56       	subi	r26, 0x65	; 101
   11010:	b7 4f       	sbci	r27, 0xF7	; 247
   11012:	8c 91       	ld	r24, X
   11014:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11016:	2f 5f       	subi	r18, 0xFF	; 255
   11018:	3f 4f       	sbci	r19, 0xFF	; 255
   1101a:	2f 30       	cpi	r18, 0x0F	; 15
   1101c:	31 05       	cpc	r19, r1
   1101e:	99 f7       	brne	.-26     	; 0x11006 <FSettingOperator+0x264>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11020:	1f 8e       	std	Y+31, r1	; 0x1f
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
          case '#':
		       StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
               AddSpaceLag(strOperatorName,18); 
   11022:	c8 01       	movw	r24, r16
   11024:	62 e1       	ldi	r22, 0x12	; 18
   11026:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   1102a:	85 e1       	ldi	r24, 0x15	; 21
   1102c:	90 e0       	ldi	r25, 0x00	; 0
   1102e:	b8 01       	movw	r22, r16
   11030:	42 e1       	ldi	r20, 0x12	; 18
   11032:	50 e0       	ldi	r21, 0x00	; 0
   11034:	2a e4       	ldi	r18, 0x4A	; 74
   11036:	33 e1       	ldi	r19, 0x13	; 19
   11038:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
		       eeprom_write_block((const void*) &strOperatorName, (void*) &DefOperatorName,18);
		       lcd_printf(3,1,PSTR("Saved "));
   1103c:	83 e0       	ldi	r24, 0x03	; 3
   1103e:	61 e0       	ldi	r22, 0x01	; 1
   11040:	4d e2       	ldi	r20, 0x2D	; 45
   11042:	51 e1       	ldi	r21, 0x11	; 17
   11044:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   TimDisplay=0;
   11048:	10 92 94 01 	sts	0x0194, r1
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1104c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1104e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11050:	81 e0       	ldi	r24, 0x01	; 1
   11052:	80 93 be 01 	sts	0x01BE, r24
   11056:	46 c1       	rjmp	.+652    	; 0x112e4 <FSettingOperator+0x542>
		       stSettingOperator=soDelayDisplaySaved;
		       break;
		  }	      
		  break;
     case soChangePasswordInit:
	      lcd_clear();
   11058:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("-Change Password-"));
   1105c:	81 e0       	ldi	r24, 0x01	; 1
   1105e:	61 e0       	ldi	r22, 0x01	; 1
   11060:	4b e1       	ldi	r20, 0x1B	; 27
   11062:	51 e1       	ldi	r21, 0x11	; 17
   11064:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Supervisor"));
   11068:	82 e0       	ldi	r24, 0x02	; 2
   1106a:	61 e0       	ldi	r22, 0x01	; 1
   1106c:	4e e0       	ldi	r20, 0x0E	; 14
   1106e:	51 e1       	ldi	r21, 0x11	; 17
   11070:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Administrator"));
   11074:	83 e0       	ldi	r24, 0x03	; 3
   11076:	61 e0       	ldi	r22, 0x01	; 1
   11078:	4e ef       	ldi	r20, 0xFE	; 254
   1107a:	50 e1       	ldi	r21, 0x10	; 16
   1107c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back     "));
   11080:	84 e0       	ldi	r24, 0x04	; 4
   11082:	61 e0       	ldi	r22, 0x01	; 1
   11084:	41 ef       	ldi	r20, 0xF1	; 241
   11086:	50 e1       	ldi	r21, 0x10	; 16
   11088:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          stSettingOperator=soChangePasswordInput; 
   1108c:	86 e0       	ldi	r24, 0x06	; 6
   1108e:	42 c1       	rjmp	.+644    	; 0x11314 <FSettingOperator+0x572>
	      break;
     case soChangePasswordInput:
          KeyPressed=_key_scan(1);
   11090:	81 e0       	ldi	r24, 0x01	; 1
   11092:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11096:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  switch(KeyChar){
   1109a:	81 33       	cpi	r24, 0x31	; 49
   1109c:	31 f0       	breq	.+12     	; 0x110aa <FSettingOperator+0x308>
   1109e:	82 33       	cpi	r24, 0x32	; 50
   110a0:	31 f0       	breq	.+12     	; 0x110ae <FSettingOperator+0x30c>
   110a2:	8a 32       	cpi	r24, 0x2A	; 42
   110a4:	09 f0       	breq	.+2      	; 0x110a8 <FSettingOperator+0x306>
   110a6:	5d c1       	rjmp	.+698    	; 0x11362 <FSettingOperator+0x5c0>
   110a8:	55 c1       	rjmp	.+682    	; 0x11354 <FSettingOperator+0x5b2>
		  case '1':		 
		       PassType=PT_SUPERVISOR;
   110aa:	81 e0       	ldi	r24, 0x01	; 1
   110ac:	01 c0       	rjmp	.+2      	; 0x110b0 <FSettingOperator+0x30e>
		       stSettingOperator=soOldPasswordDisplay;
		       break;
          case '2':		       
		       PassType=PT_ADMINISTRATOR;
   110ae:	82 e0       	ldi	r24, 0x02	; 2
   110b0:	80 93 26 02 	sts	0x0226, r24
   110b4:	75 c0       	rjmp	.+234    	; 0x111a0 <FSettingOperator+0x3fe>
		       stSettingOperator=soMenuOption;
		       break;
		  }	      
	      break;
     case soOldPasswordDisplay:
	 	  lcd_clear();
   110b6:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	      if (PassType==PT_SUPERVISOR){
   110ba:	80 91 26 02 	lds	r24, 0x0226
   110be:	81 30       	cpi	r24, 0x01	; 1
   110c0:	21 f4       	brne	.+8      	; 0x110ca <FSettingOperator+0x328>
		      lcd_printf(1,1,PSTR("-Supervisor-"));              
   110c2:	61 e0       	ldi	r22, 0x01	; 1
   110c4:	44 ee       	ldi	r20, 0xE4	; 228
   110c6:	50 e1       	ldi	r21, 0x10	; 16
   110c8:	06 c0       	rjmp	.+12     	; 0x110d6 <FSettingOperator+0x334>
		  }else if (PassType==PT_ADMINISTRATOR){		       
   110ca:	82 30       	cpi	r24, 0x02	; 2
   110cc:	31 f4       	brne	.+12     	; 0x110da <FSettingOperator+0x338>
		       lcd_printf(1,1,PSTR("-Administrator-"));			   
   110ce:	81 e0       	ldi	r24, 0x01	; 1
   110d0:	61 e0       	ldi	r22, 0x01	; 1
   110d2:	44 ed       	ldi	r20, 0xD4	; 212
   110d4:	50 e1       	ldi	r21, 0x10	; 16
   110d6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  }
		      lcd_printf(2,1,PSTR("Old:_"));
   110da:	82 e0       	ldi	r24, 0x02	; 2
   110dc:	61 e0       	ldi	r22, 0x01	; 1
   110de:	4e ec       	ldi	r20, 0xCE	; 206
   110e0:	50 e1       	ldi	r21, 0x10	; 16
   110e2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   110e6:	84 e0       	ldi	r24, 0x04	; 4
   110e8:	61 e0       	ldi	r22, 0x01	; 1
   110ea:	49 eb       	ldi	r20, 0xB9	; 185
   110ec:	50 e1       	ldi	r21, 0x10	; 16
   110ee:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>

          stSettingOperator=soOldPasswordEntry;
   110f2:	88 e0       	ldi	r24, 0x08	; 8
   110f4:	0f c1       	rjmp	.+542    	; 0x11314 <FSettingOperator+0x572>
	      break;
     case soOldPasswordEntry:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine1,0,8);           
   110f6:	84 e0       	ldi	r24, 0x04	; 4
   110f8:	62 e0       	ldi	r22, 0x02	; 2
   110fa:	45 e0       	ldi	r20, 0x05	; 5
   110fc:	2b e9       	ldi	r18, 0x9B	; 155
   110fe:	38 e0       	ldi	r19, 0x08	; 8
   11100:	00 e0       	ldi	r16, 0x00	; 0
   11102:	10 e0       	ldi	r17, 0x00	; 0
   11104:	f8 e0       	ldi	r31, 0x08	; 8
   11106:	ef 2e       	mov	r14, r31
   11108:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  switch(uiResult){
   1110c:	83 30       	cpi	r24, 0x03	; 3
   1110e:	61 f0       	breq	.+24     	; 0x11128 <FSettingOperator+0x386>
   11110:	84 30       	cpi	r24, 0x04	; 4
   11112:	20 f4       	brcc	.+8      	; 0x1111c <FSettingOperator+0x37a>
   11114:	81 30       	cpi	r24, 0x01	; 1
   11116:	09 f0       	breq	.+2      	; 0x1111a <FSettingOperator+0x378>
   11118:	24 c1       	rjmp	.+584    	; 0x11362 <FSettingOperator+0x5c0>
   1111a:	1c c1       	rjmp	.+568    	; 0x11354 <FSettingOperator+0x5b2>
   1111c:	84 30       	cpi	r24, 0x04	; 4
   1111e:	79 f0       	breq	.+30     	; 0x1113e <FSettingOperator+0x39c>
   11120:	85 30       	cpi	r24, 0x05	; 5
   11122:	09 f0       	breq	.+2      	; 0x11126 <FSettingOperator+0x384>
   11124:	1e c1       	rjmp	.+572    	; 0x11362 <FSettingOperator+0x5c0>
   11126:	10 c0       	rjmp	.+32     	; 0x11148 <FSettingOperator+0x3a6>
		  case USER_OK:
		       lcd_printf(2,1,PSTR("New:_               "));
   11128:	82 e0       	ldi	r24, 0x02	; 2
   1112a:	61 e0       	ldi	r22, 0x01	; 1
   1112c:	44 ea       	ldi	r20, 0xA4	; 164
   1112e:	50 e1       	ldi	r21, 0x10	; 16
   11130:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11134:	84 e0       	ldi	r24, 0x04	; 4
   11136:	61 e0       	ldi	r22, 0x01	; 1
   11138:	4f e8       	ldi	r20, 0x8F	; 143
   1113a:	50 e1       	ldi	r21, 0x10	; 16
   1113c:	6e c0       	rjmp	.+220    	; 0x1121a <FSettingOperator+0x478>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1113e:	84 e0       	ldi	r24, 0x04	; 4
   11140:	61 e0       	ldi	r22, 0x01	; 1
   11142:	4a e7       	ldi	r20, 0x7A	; 122
   11144:	50 e1       	ldi	r21, 0x10	; 16
   11146:	76 c0       	rjmp	.+236    	; 0x11234 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11148:	84 e0       	ldi	r24, 0x04	; 4
   1114a:	61 e0       	ldi	r22, 0x01	; 1
   1114c:	45 e6       	ldi	r20, 0x65	; 101
   1114e:	50 e1       	ldi	r21, 0x10	; 16
   11150:	71 c0       	rjmp	.+226    	; 0x11234 <FSettingOperator+0x492>
		       break;
		  }
	      break;
     case soNewPasswordEntry1:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine2,0,8);           
   11152:	84 e0       	ldi	r24, 0x04	; 4
   11154:	62 e0       	ldi	r22, 0x02	; 2
   11156:	45 e0       	ldi	r20, 0x05	; 5
   11158:	2c ea       	ldi	r18, 0xAC	; 172
   1115a:	37 e0       	ldi	r19, 0x07	; 7
   1115c:	00 e0       	ldi	r16, 0x00	; 0
   1115e:	10 e0       	ldi	r17, 0x00	; 0
   11160:	e8 e0       	ldi	r30, 0x08	; 8
   11162:	ee 2e       	mov	r14, r30
   11164:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  switch(uiResult){
   11168:	83 30       	cpi	r24, 0x03	; 3
   1116a:	61 f0       	breq	.+24     	; 0x11184 <FSettingOperator+0x3e2>
   1116c:	84 30       	cpi	r24, 0x04	; 4
   1116e:	20 f4       	brcc	.+8      	; 0x11178 <FSettingOperator+0x3d6>
   11170:	81 30       	cpi	r24, 0x01	; 1
   11172:	09 f0       	breq	.+2      	; 0x11176 <FSettingOperator+0x3d4>
   11174:	f6 c0       	rjmp	.+492    	; 0x11362 <FSettingOperator+0x5c0>
   11176:	14 c0       	rjmp	.+40     	; 0x111a0 <FSettingOperator+0x3fe>
   11178:	84 30       	cpi	r24, 0x04	; 4
   1117a:	a1 f0       	breq	.+40     	; 0x111a4 <FSettingOperator+0x402>
   1117c:	85 30       	cpi	r24, 0x05	; 5
   1117e:	09 f0       	breq	.+2      	; 0x11182 <FSettingOperator+0x3e0>
   11180:	f0 c0       	rjmp	.+480    	; 0x11362 <FSettingOperator+0x5c0>
   11182:	15 c0       	rjmp	.+42     	; 0x111ae <FSettingOperator+0x40c>
		  case USER_OK:
		       lcd_printf(3,1,PSTR("New:_               "));
   11184:	83 e0       	ldi	r24, 0x03	; 3
   11186:	61 e0       	ldi	r22, 0x01	; 1
   11188:	40 e5       	ldi	r20, 0x50	; 80
   1118a:	50 e1       	ldi	r21, 0x10	; 16
   1118c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11190:	84 e0       	ldi	r24, 0x04	; 4
   11192:	61 e0       	ldi	r22, 0x01	; 1
   11194:	4b e3       	ldi	r20, 0x3B	; 59
   11196:	50 e1       	ldi	r21, 0x10	; 16
   11198:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry2;
   1119c:	8a e0       	ldi	r24, 0x0A	; 10
   1119e:	ba c0       	rjmp	.+372    	; 0x11314 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:		       
			   stSettingOperator=soOldPasswordDisplay;
   111a0:	87 e0       	ldi	r24, 0x07	; 7
   111a2:	b8 c0       	rjmp	.+368    	; 0x11314 <FSettingOperator+0x572>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   111a4:	84 e0       	ldi	r24, 0x04	; 4
   111a6:	61 e0       	ldi	r22, 0x01	; 1
   111a8:	46 e2       	ldi	r20, 0x26	; 38
   111aa:	50 e1       	ldi	r21, 0x10	; 16
   111ac:	43 c0       	rjmp	.+134    	; 0x11234 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   111ae:	84 e0       	ldi	r24, 0x04	; 4
   111b0:	61 e0       	ldi	r22, 0x01	; 1
   111b2:	41 e1       	ldi	r20, 0x11	; 17
   111b4:	50 e1       	ldi	r21, 0x10	; 16
   111b6:	3e c0       	rjmp	.+124    	; 0x11234 <FSettingOperator+0x492>
		       break;
		  }	      
	      break;
     case soNewPasswordEntry2:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,3,5,strFreeMessageLine3,0,8);           
   111b8:	84 e0       	ldi	r24, 0x04	; 4
   111ba:	63 e0       	ldi	r22, 0x03	; 3
   111bc:	45 e0       	ldi	r20, 0x05	; 5
   111be:	25 e2       	ldi	r18, 0x25	; 37
   111c0:	38 e0       	ldi	r19, 0x08	; 8
   111c2:	00 e0       	ldi	r16, 0x00	; 0
   111c4:	10 e0       	ldi	r17, 0x00	; 0
   111c6:	78 e0       	ldi	r23, 0x08	; 8
   111c8:	e7 2e       	mov	r14, r23
   111ca:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  switch(uiResult){
   111ce:	83 30       	cpi	r24, 0x03	; 3
   111d0:	61 f0       	breq	.+24     	; 0x111ea <FSettingOperator+0x448>
   111d2:	84 30       	cpi	r24, 0x04	; 4
   111d4:	20 f4       	brcc	.+8      	; 0x111de <FSettingOperator+0x43c>
   111d6:	81 30       	cpi	r24, 0x01	; 1
   111d8:	09 f0       	breq	.+2      	; 0x111dc <FSettingOperator+0x43a>
   111da:	c3 c0       	rjmp	.+390    	; 0x11362 <FSettingOperator+0x5c0>
   111dc:	12 c0       	rjmp	.+36     	; 0x11202 <FSettingOperator+0x460>
   111de:	84 30       	cpi	r24, 0x04	; 4
   111e0:	01 f1       	breq	.+64     	; 0x11222 <FSettingOperator+0x480>
   111e2:	85 30       	cpi	r24, 0x05	; 5
   111e4:	09 f0       	breq	.+2      	; 0x111e8 <FSettingOperator+0x446>
   111e6:	bd c0       	rjmp	.+378    	; 0x11362 <FSettingOperator+0x5c0>
   111e8:	21 c0       	rjmp	.+66     	; 0x1122c <FSettingOperator+0x48a>
		  case USER_OK:
		       lcd_clear();
   111ea:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
               lcd_printf(2,1,PSTR("Validating.."));
   111ee:	82 e0       	ldi	r24, 0x02	; 2
   111f0:	61 e0       	ldi	r22, 0x01	; 1
   111f2:	44 e0       	ldi	r20, 0x04	; 4
   111f4:	50 e1       	ldi	r21, 0x10	; 16
   111f6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   TimDisplay=0;
   111fa:	10 92 94 01 	sts	0x0194, r1
		       stSettingOperator=soDispValidatePassword;
   111fe:	8b e0       	ldi	r24, 0x0B	; 11
   11200:	89 c0       	rjmp	.+274    	; 0x11314 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:
               lcd_clear();
   11202:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
               lcd_printf(2,1,PSTR("New:_               "));
   11206:	82 e0       	ldi	r24, 0x02	; 2
   11208:	61 e0       	ldi	r22, 0x01	; 1
   1120a:	4f ee       	ldi	r20, 0xEF	; 239
   1120c:	5f e0       	ldi	r21, 0x0F	; 15
   1120e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11212:	84 e0       	ldi	r24, 0x04	; 4
   11214:	61 e0       	ldi	r22, 0x01	; 1
   11216:	4a ed       	ldi	r20, 0xDA	; 218
   11218:	5f e0       	ldi	r21, 0x0F	; 15
   1121a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry1;
   1121e:	89 e0       	ldi	r24, 0x09	; 9
   11220:	79 c0       	rjmp	.+242    	; 0x11314 <FSettingOperator+0x572>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11222:	84 e0       	ldi	r24, 0x04	; 4
   11224:	61 e0       	ldi	r22, 0x01	; 1
   11226:	45 ec       	ldi	r20, 0xC5	; 197
   11228:	5f e0       	ldi	r21, 0x0F	; 15
   1122a:	04 c0       	rjmp	.+8      	; 0x11234 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1122c:	84 e0       	ldi	r24, 0x04	; 4
   1122e:	61 e0       	ldi	r22, 0x01	; 1
   11230:	40 eb       	ldi	r20, 0xB0	; 176
   11232:	5f e0       	ldi	r21, 0x0F	; 15
   11234:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   11238:	94 c0       	rjmp	.+296    	; 0x11362 <FSettingOperator+0x5c0>
		       break;
		  }	      
	      break;
     case soDispValidatePassword:
	      if (TimDisplay>3)stSettingOperator=soValidatePassword;
   1123a:	80 91 94 01 	lds	r24, 0x0194
   1123e:	84 30       	cpi	r24, 0x04	; 4
   11240:	08 f4       	brcc	.+2      	; 0x11244 <FSettingOperator+0x4a2>
   11242:	8f c0       	rjmp	.+286    	; 0x11362 <FSettingOperator+0x5c0>
   11244:	8c e0       	ldi	r24, 0x0C	; 12
   11246:	66 c0       	rjmp	.+204    	; 0x11314 <FSettingOperator+0x572>
	      break;
     case soValidatePassword:
          if (PassType==PT_SUPERVISOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSysPassword, 10);		      			   
   11248:	80 91 26 02 	lds	r24, 0x0226
   1124c:	81 30       	cpi	r24, 0x01	; 1
   1124e:	29 f4       	brne	.+10     	; 0x1125a <FSettingOperator+0x4b8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   11250:	ce 01       	movw	r24, r28
   11252:	01 96       	adiw	r24, 0x01	; 1
   11254:	6b e0       	ldi	r22, 0x0B	; 11
   11256:	70 e0       	ldi	r23, 0x00	; 0
   11258:	06 c0       	rjmp	.+12     	; 0x11266 <FSettingOperator+0x4c4>
		  else 
		  if (PassType==PT_ADMINISTRATOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSpvPassword, 10);    
   1125a:	82 30       	cpi	r24, 0x02	; 2
   1125c:	51 f4       	brne	.+20     	; 0x11272 <FSettingOperator+0x4d0>
   1125e:	ce 01       	movw	r24, r28
   11260:	01 96       	adiw	r24, 0x01	; 1
   11262:	61 e0       	ldi	r22, 0x01	; 1
   11264:	70 e0       	ldi	r23, 0x00	; 0
   11266:	4a e0       	ldi	r20, 0x0A	; 10
   11268:	50 e0       	ldi	r21, 0x00	; 0
   1126a:	22 e4       	ldi	r18, 0x42	; 66
   1126c:	33 e1       	ldi	r19, 0x13	; 19
   1126e:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		  
		  //Check Old Validity
		  if (strcmp(strPassword,strFreeMessageLine1)==0){//OldMessage Valid
   11272:	ce 01       	movw	r24, r28
   11274:	01 96       	adiw	r24, 0x01	; 1
   11276:	6b e9       	ldi	r22, 0x9B	; 155
   11278:	78 e0       	ldi	r23, 0x08	; 8
   1127a:	0e 94 f3 b0 	call	0x161e6	; 0x161e6 <strcmp>
   1127e:	00 97       	sbiw	r24, 0x00	; 0
   11280:	09 f0       	breq	.+2      	; 0x11284 <FSettingOperator+0x4e2>
   11282:	4b c0       	rjmp	.+150    	; 0x1131a <FSettingOperator+0x578>
              if (strcmp(strFreeMessageLine2,strFreeMessageLine3)==0){
   11284:	8c ea       	ldi	r24, 0xAC	; 172
   11286:	97 e0       	ldi	r25, 0x07	; 7
   11288:	65 e2       	ldi	r22, 0x25	; 37
   1128a:	78 e0       	ldi	r23, 0x08	; 8
   1128c:	0e 94 f3 b0 	call	0x161e6	; 0x161e6 <strcmp>
   11290:	00 97       	sbiw	r24, 0x00	; 0
   11292:	51 f5       	brne	.+84     	; 0x112e8 <FSettingOperator+0x546>
                  
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
   11294:	80 91 26 02 	lds	r24, 0x0226
   11298:	81 30       	cpi	r24, 0x01	; 1
   1129a:	19 f4       	brne	.+6      	; 0x112a2 <FSettingOperator+0x500>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   1129c:	8b e0       	ldi	r24, 0x0B	; 11
   1129e:	90 e0       	ldi	r25, 0x00	; 0
   112a0:	04 c0       	rjmp	.+8      	; 0x112aa <FSettingOperator+0x508>
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    
   112a2:	82 30       	cpi	r24, 0x02	; 2
   112a4:	51 f4       	brne	.+20     	; 0x112ba <FSettingOperator+0x518>
   112a6:	81 e0       	ldi	r24, 0x01	; 1
   112a8:	90 e0       	ldi	r25, 0x00	; 0
   112aa:	6c ea       	ldi	r22, 0xAC	; 172
   112ac:	77 e0       	ldi	r23, 0x07	; 7
   112ae:	4a e0       	ldi	r20, 0x0A	; 10
   112b0:	50 e0       	ldi	r21, 0x00	; 0
   112b2:	2a e4       	ldi	r18, 0x4A	; 74
   112b4:	33 e1       	ldi	r19, 0x13	; 19
   112b6:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   112ba:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   112bc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   112be:	81 e0       	ldi	r24, 0x01	; 1
   112c0:	80 93 be 01 	sts	0x01BE, r24
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    

			      system_beep(1);
				  lcd_clear();
   112c4:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
			      lcd_printf(2,1,PSTR("     Completed      "));
   112c8:	82 e0       	ldi	r24, 0x02	; 2
   112ca:	61 e0       	ldi	r22, 0x01	; 1
   112cc:	4b e9       	ldi	r20, 0x9B	; 155
   112ce:	5f e0       	ldi	r21, 0x0F	; 15
   112d0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
   112d4:	83 e0       	ldi	r24, 0x03	; 3
   112d6:	61 e0       	ldi	r22, 0x01	; 1
   112d8:	46 e8       	ldi	r20, 0x86	; 134
   112da:	5f e0       	ldi	r21, 0x0F	; 15
   112dc:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				  TimDisplay=0;
   112e0:	10 92 94 01 	sts	0x0194, r1
				  stSettingOperator=soDelayDisplaySaved;
   112e4:	8e e0       	ldi	r24, 0x0E	; 14
   112e6:	16 c0       	rjmp	.+44     	; 0x11314 <FSettingOperator+0x572>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   112e8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   112ea:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   112ec:	82 e0       	ldi	r24, 0x02	; 2
   112ee:	80 93 be 01 	sts	0x01BE, r24
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
				  TimDisplay=0;
				  stSettingOperator=soDelayDisplaySaved;
			  }else {
			  system_beep(2);
		      TimDisplay=0;
   112f2:	10 92 94 01 	sts	0x0194, r1
		      lcd_clear();
   112f6:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		      lcd_printf(2,1,PSTR("      ERROR         "));
   112fa:	82 e0       	ldi	r24, 0x02	; 2
   112fc:	61 e0       	ldi	r22, 0x01	; 1
   112fe:	41 e7       	ldi	r20, 0x71	; 113
   11300:	5f e0       	ldi	r21, 0x0F	; 15
   11302:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      lcd_printf(3,1,PSTR("Invalid New Password"));
   11306:	83 e0       	ldi	r24, 0x03	; 3
   11308:	61 e0       	ldi	r22, 0x01	; 1
   1130a:	4c e5       	ldi	r20, 0x5C	; 92
   1130c:	5f e0       	ldi	r21, 0x0F	; 15
   1130e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      stSettingOperator=soDisplayInvalidPassword;
   11312:	8d e0       	ldi	r24, 0x0D	; 13
   11314:	80 93 27 02 	sts	0x0227, r24
   11318:	24 c0       	rjmp	.+72     	; 0x11362 <FSettingOperator+0x5c0>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1131a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1131c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1131e:	82 e0       	ldi	r24, 0x02	; 2
   11320:	80 93 be 01 	sts	0x01BE, r24
		      stSettingOperator=soDisplayInvalidPassword;
			  }
		  }else {
		   //InvalidOld Password
		   system_beep(2);
		   TimDisplay=0;
   11324:	10 92 94 01 	sts	0x0194, r1
		   lcd_clear();
   11328:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		   lcd_printf(2,1,PSTR("      ERROR         "));
   1132c:	82 e0       	ldi	r24, 0x02	; 2
   1132e:	61 e0       	ldi	r22, 0x01	; 1
   11330:	47 e4       	ldi	r20, 0x47	; 71
   11332:	5f e0       	ldi	r21, 0x0F	; 15
   11334:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		   lcd_printf(3,1,PSTR("Invalid Old Password"));
   11338:	83 e0       	ldi	r24, 0x03	; 3
   1133a:	61 e0       	ldi	r22, 0x01	; 1
   1133c:	42 e3       	ldi	r20, 0x32	; 50
   1133e:	5f e0       	ldi	r21, 0x0F	; 15
   11340:	e6 cf       	rjmp	.-52     	; 0x1130e <FSettingOperator+0x56c>
		   stSettingOperator=soDisplayInvalidPassword;
		   }
	      break;
     case soDisplayInvalidPassword:
	      if (TimDisplay>6)stSettingOperator=soMenuOption;
   11342:	80 91 94 01 	lds	r24, 0x0194
   11346:	87 30       	cpi	r24, 0x07	; 7
   11348:	60 f0       	brcs	.+24     	; 0x11362 <FSettingOperator+0x5c0>
   1134a:	04 c0       	rjmp	.+8      	; 0x11354 <FSettingOperator+0x5b2>
	      break;
     case soDelayDisplaySaved:
	      if (TimDisplay>4)stSettingOperator=soMenuOption;
   1134c:	80 91 94 01 	lds	r24, 0x0194
   11350:	85 30       	cpi	r24, 0x05	; 5
   11352:	38 f0       	brcs	.+14     	; 0x11362 <FSettingOperator+0x5c0>
   11354:	10 92 27 02 	sts	0x0227, r1
   11358:	04 c0       	rjmp	.+8      	; 0x11362 <FSettingOperator+0x5c0>
	      break;
	 case soExitSettingOperator:
	      stSettingOperator=soMenuOption;
   1135a:	10 92 27 02 	sts	0x0227, r1
   1135e:	81 e0       	ldi	r24, 0x01	; 1
   11360:	01 c0       	rjmp	.+2      	; 0x11364 <FSettingOperator+0x5c2>
   11362:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   11364:	e5 96       	adiw	r28, 0x35	; 53
   11366:	0f b6       	in	r0, 0x3f	; 63
   11368:	f8 94       	cli
   1136a:	de bf       	out	0x3e, r29	; 62
   1136c:	0f be       	out	0x3f, r0	; 63
   1136e:	cd bf       	out	0x3d, r28	; 61
   11370:	cf 91       	pop	r28
   11372:	df 91       	pop	r29
   11374:	1f 91       	pop	r17
   11376:	0f 91       	pop	r16
   11378:	ef 90       	pop	r14
   1137a:	08 95       	ret

0001137c <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
   1137c:	6f 92       	push	r6
   1137e:	7f 92       	push	r7
   11380:	8f 92       	push	r8
   11382:	9f 92       	push	r9
   11384:	af 92       	push	r10
   11386:	bf 92       	push	r11
   11388:	cf 92       	push	r12
   1138a:	df 92       	push	r13
   1138c:	ef 92       	push	r14
   1138e:	ff 92       	push	r15
   11390:	0f 93       	push	r16
   11392:	1f 93       	push	r17
   11394:	df 93       	push	r29
   11396:	cf 93       	push	r28
   11398:	cd b7       	in	r28, 0x3d	; 61
   1139a:	de b7       	in	r29, 0x3e	; 62
   1139c:	a1 97       	sbiw	r28, 0x21	; 33
   1139e:	0f b6       	in	r0, 0x3f	; 63
   113a0:	f8 94       	cli
   113a2:	de bf       	out	0x3e, r29	; 62
   113a4:	0f be       	out	0x3f, r0	; 63
   113a6:	cd bf       	out	0x3d, r28	; 61
     char i;//,x,y;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
   113a8:	80 91 2a 02 	lds	r24, 0x022A
   113ac:	83 30       	cpi	r24, 0x03	; 3
   113ae:	09 f4       	brne	.+2      	; 0x113b2 <FSettingProduct+0x36>
   113b0:	ff c0       	rjmp	.+510    	; 0x115b0 <FSettingProduct+0x234>
   113b2:	84 30       	cpi	r24, 0x04	; 4
   113b4:	38 f4       	brcc	.+14     	; 0x113c4 <FSettingProduct+0x48>
   113b6:	81 30       	cpi	r24, 0x01	; 1
   113b8:	09 f4       	brne	.+2      	; 0x113bc <FSettingProduct+0x40>
   113ba:	72 c0       	rjmp	.+228    	; 0x114a0 <FSettingProduct+0x124>
   113bc:	82 30       	cpi	r24, 0x02	; 2
   113be:	08 f0       	brcs	.+2      	; 0x113c2 <FSettingProduct+0x46>
   113c0:	82 c0       	rjmp	.+260    	; 0x114c6 <FSettingProduct+0x14a>
   113c2:	0a c0       	rjmp	.+20     	; 0x113d8 <FSettingProduct+0x5c>
   113c4:	85 30       	cpi	r24, 0x05	; 5
   113c6:	09 f4       	brne	.+2      	; 0x113ca <FSettingProduct+0x4e>
   113c8:	81 c1       	rjmp	.+770    	; 0x116cc <FSettingProduct+0x350>
   113ca:	85 30       	cpi	r24, 0x05	; 5
   113cc:	08 f4       	brcc	.+2      	; 0x113d0 <FSettingProduct+0x54>
   113ce:	9e c1       	rjmp	.+828    	; 0x1170c <FSettingProduct+0x390>
   113d0:	86 30       	cpi	r24, 0x06	; 6
   113d2:	09 f0       	breq	.+2      	; 0x113d6 <FSettingProduct+0x5a>
   113d4:	c3 c1       	rjmp	.+902    	; 0x1175c <FSettingProduct+0x3e0>
   113d6:	be c1       	rjmp	.+892    	; 0x11754 <FSettingProduct+0x3d8>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   113d8:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   113dc:	7b eb       	ldi	r23, 0xBB	; 187
   113de:	c7 2e       	mov	r12, r23
   113e0:	70 e0       	ldi	r23, 0x00	; 0
   113e2:	d7 2e       	mov	r13, r23
   113e4:	61 e0       	ldi	r22, 0x01	; 1
   113e6:	e6 2e       	mov	r14, r22
   113e8:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   113ea:	4e 01       	movw	r8, r28
   113ec:	08 94       	sec
   113ee:	81 1c       	adc	r8, r1
   113f0:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   113f2:	5e e0       	ldi	r21, 0x0E	; 14
   113f4:	a5 2e       	mov	r10, r21
   113f6:	b1 2c       	mov	r11, r1
   113f8:	ac 0e       	add	r10, r28
   113fa:	bd 1e       	adc	r11, r29
   113fc:	4c e0       	ldi	r20, 0x0C	; 12
   113fe:	64 2e       	mov	r6, r20
   11400:	43 e1       	ldi	r20, 0x13	; 19
   11402:	74 2e       	mov	r7, r20
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   11404:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11406:	1e 2d       	mov	r17, r14
   11408:	11 50       	subi	r17, 0x01	; 1
   1140a:	c4 01       	movw	r24, r8
   1140c:	b6 01       	movw	r22, r12
   1140e:	4d e0       	ldi	r20, 0x0D	; 13
   11410:	50 e0       	ldi	r21, 0x00	; 0
   11412:	22 e4       	ldi	r18, 0x42	; 66
   11414:	33 e1       	ldi	r19, 0x13	; 19
   11416:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   1141a:	8d b7       	in	r24, 0x3d	; 61
   1141c:	9e b7       	in	r25, 0x3e	; 62
   1141e:	08 97       	sbiw	r24, 0x08	; 8
   11420:	0f b6       	in	r0, 0x3f	; 63
   11422:	f8 94       	cli
   11424:	9e bf       	out	0x3e, r25	; 62
   11426:	0f be       	out	0x3f, r0	; 63
   11428:	8d bf       	out	0x3d, r24	; 61
   1142a:	ed b7       	in	r30, 0x3d	; 61
   1142c:	fe b7       	in	r31, 0x3e	; 62
   1142e:	31 96       	adiw	r30, 0x01	; 1
   11430:	ad b7       	in	r26, 0x3d	; 61
   11432:	be b7       	in	r27, 0x3e	; 62
   11434:	12 96       	adiw	r26, 0x02	; 2
   11436:	bc 92       	st	X, r11
   11438:	ae 92       	st	-X, r10
   1143a:	11 97       	sbiw	r26, 0x01	; 1
   1143c:	73 82       	std	Z+3, r7	; 0x03
   1143e:	62 82       	std	Z+2, r6	; 0x02
   11440:	f5 82       	std	Z+5, r15	; 0x05
   11442:	e4 82       	std	Z+4, r14	; 0x04
   11444:	97 82       	std	Z+7, r9	; 0x07
   11446:	86 82       	std	Z+6, r8	; 0x06
   11448:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   1144c:	8d b7       	in	r24, 0x3d	; 61
   1144e:	9e b7       	in	r25, 0x3e	; 62
   11450:	08 96       	adiw	r24, 0x08	; 8
   11452:	0f b6       	in	r0, 0x3f	; 63
   11454:	f8 94       	cli
   11456:	9e bf       	out	0x3e, r25	; 62
   11458:	0f be       	out	0x3f, r0	; 63
   1145a:	8d bf       	out	0x3d, r24	; 61
   1145c:	61 2f       	mov	r22, r17
   1145e:	66 95       	lsr	r22
   11460:	66 95       	lsr	r22
   11462:	60 9f       	mul	r22, r16
   11464:	b0 01       	movw	r22, r0
   11466:	11 24       	eor	r1, r1
   11468:	6f 5f       	subi	r22, 0xFF	; 255
   1146a:	13 70       	andi	r17, 0x03	; 3
   1146c:	81 2f       	mov	r24, r17
   1146e:	8f 5f       	subi	r24, 0xFF	; 255
   11470:	a5 01       	movw	r20, r10
   11472:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
   11476:	ad e0       	ldi	r26, 0x0D	; 13
   11478:	b0 e0       	ldi	r27, 0x00	; 0
   1147a:	ca 0e       	add	r12, r26
   1147c:	db 1e       	adc	r13, r27
   1147e:	08 94       	sec
   11480:	e1 1c       	adc	r14, r1
   11482:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
   11484:	b9 e0       	ldi	r27, 0x09	; 9
   11486:	cb 16       	cp	r12, r27
   11488:	b1 e0       	ldi	r27, 0x01	; 1
   1148a:	db 06       	cpc	r13, r27
   1148c:	09 f0       	breq	.+2      	; 0x11490 <FSettingProduct+0x114>
   1148e:	bb cf       	rjmp	.-138    	; 0x11406 <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
   11490:	84 e0       	ldi	r24, 0x04	; 4
   11492:	6b e0       	ldi	r22, 0x0B	; 11
   11494:	45 e0       	ldi	r20, 0x05	; 5
   11496:	53 e1       	ldi	r21, 0x13	; 19
   11498:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          stMenuProduct=mpChangeProduct;
   1149c:	81 e0       	ldi	r24, 0x01	; 1
   1149e:	54 c1       	rjmp	.+680    	; 0x11748 <FSettingProduct+0x3cc>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
   114a0:	81 e0       	ldi	r24, 0x01	; 1
   114a2:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   114a6:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   114a8:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   114ac:	81 53       	subi	r24, 0x31	; 49
   114ae:	86 30       	cpi	r24, 0x06	; 6
   114b0:	28 f4       	brcc	.+10     	; 0x114bc <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
   114b2:	80 93 29 02 	sts	0x0229, r24
			  stMenuProduct=mpDispPrice;
   114b6:	82 e0       	ldi	r24, 0x02	; 2
   114b8:	80 93 2a 02 	sts	0x022A, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
   114bc:	17 3e       	cpi	r17, 0xE7	; 231
   114be:	09 f0       	breq	.+2      	; 0x114c2 <FSettingProduct+0x146>
   114c0:	4d c1       	rjmp	.+666    	; 0x1175c <FSettingProduct+0x3e0>
		      stMenuProduct=mpExitMenuProduct;
   114c2:	86 e0       	ldi	r24, 0x06	; 6
   114c4:	41 c1       	rjmp	.+642    	; 0x11748 <FSettingProduct+0x3cc>
   114c6:	60 91 29 02 	lds	r22, 0x0229
   114ca:	8d e0       	ldi	r24, 0x0D	; 13
   114cc:	68 9f       	mul	r22, r24
   114ce:	b0 01       	movw	r22, r0
   114d0:	11 24       	eor	r1, r1
   114d2:	65 54       	subi	r22, 0x45	; 69
   114d4:	7f 4f       	sbci	r23, 0xFF	; 255
   114d6:	7e 01       	movw	r14, r28
   114d8:	08 94       	sec
   114da:	e1 1c       	adc	r14, r1
   114dc:	f1 1c       	adc	r15, r1
   114de:	c7 01       	movw	r24, r14
   114e0:	4d e0       	ldi	r20, 0x0D	; 13
   114e2:	50 e0       	ldi	r21, 0x00	; 0
   114e4:	22 e4       	ldi	r18, 0x42	; 66
   114e6:	33 e1       	ldi	r19, 0x13	; 19
   114e8:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
   114ec:	37 ea       	ldi	r19, 0xA7	; 167
   114ee:	c3 2e       	mov	r12, r19
   114f0:	35 e0       	ldi	r19, 0x05	; 5
   114f2:	d3 2e       	mov	r13, r19
   114f4:	60 91 29 02 	lds	r22, 0x0229
   114f8:	89 e0       	ldi	r24, 0x09	; 9
   114fa:	68 9f       	mul	r22, r24
   114fc:	b0 01       	movw	r22, r0
   114fe:	11 24       	eor	r1, r1
   11500:	6b 57       	subi	r22, 0x7B	; 123
   11502:	7f 4f       	sbci	r23, 0xFF	; 255
   11504:	c6 01       	movw	r24, r12
   11506:	49 e0       	ldi	r20, 0x09	; 9
   11508:	50 e0       	ldi	r21, 0x00	; 0
   1150a:	22 e4       	ldi	r18, 0x42	; 66
   1150c:	33 e1       	ldi	r19, 0x13	; 19
   1150e:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
   11512:	00 d0       	rcall	.+0      	; 0x11514 <FSettingProduct+0x198>
   11514:	00 d0       	rcall	.+0      	; 0x11516 <FSettingProduct+0x19a>
   11516:	00 d0       	rcall	.+0      	; 0x11518 <FSettingProduct+0x19c>
   11518:	ed b7       	in	r30, 0x3d	; 61
   1151a:	fe b7       	in	r31, 0x3e	; 62
   1151c:	31 96       	adiw	r30, 0x01	; 1
   1151e:	8e 01       	movw	r16, r28
   11520:	02 5f       	subi	r16, 0xF2	; 242
   11522:	1f 4f       	sbci	r17, 0xFF	; 255
   11524:	ad b7       	in	r26, 0x3d	; 61
   11526:	be b7       	in	r27, 0x3e	; 62
   11528:	12 96       	adiw	r26, 0x02	; 2
   1152a:	1c 93       	st	X, r17
   1152c:	0e 93       	st	-X, r16
   1152e:	11 97       	sbiw	r26, 0x01	; 1
   11530:	80 e0       	ldi	r24, 0x00	; 0
   11532:	93 e1       	ldi	r25, 0x13	; 19
   11534:	93 83       	std	Z+3, r25	; 0x03
   11536:	82 83       	std	Z+2, r24	; 0x02
   11538:	f5 82       	std	Z+5, r15	; 0x05
   1153a:	e4 82       	std	Z+4, r14	; 0x04
   1153c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
   11540:	8d b7       	in	r24, 0x3d	; 61
   11542:	9e b7       	in	r25, 0x3e	; 62
   11544:	06 96       	adiw	r24, 0x06	; 6
   11546:	0f b6       	in	r0, 0x3f	; 63
   11548:	f8 94       	cli
   1154a:	9e bf       	out	0x3e, r25	; 62
   1154c:	0f be       	out	0x3f, r0	; 63
   1154e:	8d bf       	out	0x3d, r24	; 61
   11550:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   11554:	81 e0       	ldi	r24, 0x01	; 1
   11556:	61 e0       	ldi	r22, 0x01	; 1
   11558:	a8 01       	movw	r20, r16
   1155a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
   1155e:	00 d0       	rcall	.+0      	; 0x11560 <FSettingProduct+0x1e4>
   11560:	00 d0       	rcall	.+0      	; 0x11562 <FSettingProduct+0x1e6>
   11562:	00 d0       	rcall	.+0      	; 0x11564 <FSettingProduct+0x1e8>
   11564:	ed b7       	in	r30, 0x3d	; 61
   11566:	fe b7       	in	r31, 0x3e	; 62
   11568:	31 96       	adiw	r30, 0x01	; 1
   1156a:	ad b7       	in	r26, 0x3d	; 61
   1156c:	be b7       	in	r27, 0x3e	; 62
   1156e:	12 96       	adiw	r26, 0x02	; 2
   11570:	1c 93       	st	X, r17
   11572:	0e 93       	st	-X, r16
   11574:	11 97       	sbiw	r26, 0x01	; 1
   11576:	8b ef       	ldi	r24, 0xFB	; 251
   11578:	92 e1       	ldi	r25, 0x12	; 18
   1157a:	93 83       	std	Z+3, r25	; 0x03
   1157c:	82 83       	std	Z+2, r24	; 0x02
   1157e:	d5 82       	std	Z+5, r13	; 0x05
   11580:	c4 82       	std	Z+4, r12	; 0x04
   11582:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   11586:	8d b7       	in	r24, 0x3d	; 61
   11588:	9e b7       	in	r25, 0x3e	; 62
   1158a:	06 96       	adiw	r24, 0x06	; 6
   1158c:	0f b6       	in	r0, 0x3f	; 63
   1158e:	f8 94       	cli
   11590:	9e bf       	out	0x3e, r25	; 62
   11592:	0f be       	out	0x3f, r0	; 63
   11594:	8d bf       	out	0x3d, r24	; 61
   11596:	82 e0       	ldi	r24, 0x02	; 2
   11598:	61 e0       	ldi	r22, 0x01	; 1
   1159a:	a8 01       	movw	r20, r16
   1159c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
   115a0:	84 e0       	ldi	r24, 0x04	; 4
   115a2:	61 e0       	ldi	r22, 0x01	; 1
   115a4:	4d ee       	ldi	r20, 0xED	; 237
   115a6:	52 e1       	ldi	r21, 0x12	; 18
   115a8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stMenuProduct=mpIsEdit;
   115ac:	83 e0       	ldi	r24, 0x03	; 3
   115ae:	cc c0       	rjmp	.+408    	; 0x11748 <FSettingProduct+0x3cc>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
   115b0:	81 e0       	ldi	r24, 0x01	; 1
   115b2:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   115b6:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  if (KeyChar=='*'){
   115ba:	8a 32       	cpi	r24, 0x2A	; 42
   115bc:	09 f4       	brne	.+2      	; 0x115c0 <FSettingProduct+0x244>
   115be:	a3 c0       	rjmp	.+326    	; 0x11706 <FSettingProduct+0x38a>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
   115c0:	81 33       	cpi	r24, 0x31	; 49
   115c2:	09 f0       	breq	.+2      	; 0x115c6 <FSettingProduct+0x24a>
   115c4:	4c c0       	rjmp	.+152    	; 0x1165e <FSettingProduct+0x2e2>
   115c6:	60 91 29 02 	lds	r22, 0x0229
   115ca:	8d e0       	ldi	r24, 0x0D	; 13
   115cc:	68 9f       	mul	r22, r24
   115ce:	b0 01       	movw	r22, r0
   115d0:	11 24       	eor	r1, r1
   115d2:	65 54       	subi	r22, 0x45	; 69
   115d4:	7f 4f       	sbci	r23, 0xFF	; 255
   115d6:	8e 01       	movw	r16, r28
   115d8:	0f 5f       	subi	r16, 0xFF	; 255
   115da:	1f 4f       	sbci	r17, 0xFF	; 255
   115dc:	c8 01       	movw	r24, r16
   115de:	4d e0       	ldi	r20, 0x0D	; 13
   115e0:	50 e0       	ldi	r21, 0x00	; 0
   115e2:	22 e4       	ldi	r18, 0x42	; 66
   115e4:	33 e1       	ldi	r19, 0x13	; 19
   115e6:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
   115ea:	00 d0       	rcall	.+0      	; 0x115ec <FSettingProduct+0x270>
   115ec:	00 d0       	rcall	.+0      	; 0x115ee <FSettingProduct+0x272>
   115ee:	00 d0       	rcall	.+0      	; 0x115f0 <FSettingProduct+0x274>
   115f0:	ed b7       	in	r30, 0x3d	; 61
   115f2:	fe b7       	in	r31, 0x3e	; 62
   115f4:	31 96       	adiw	r30, 0x01	; 1
   115f6:	2e e0       	ldi	r18, 0x0E	; 14
   115f8:	e2 2e       	mov	r14, r18
   115fa:	f1 2c       	mov	r15, r1
   115fc:	ec 0e       	add	r14, r28
   115fe:	fd 1e       	adc	r15, r29
   11600:	ad b7       	in	r26, 0x3d	; 61
   11602:	be b7       	in	r27, 0x3e	; 62
   11604:	12 96       	adiw	r26, 0x02	; 2
   11606:	fc 92       	st	X, r15
   11608:	ee 92       	st	-X, r14
   1160a:	11 97       	sbiw	r26, 0x01	; 1
   1160c:	86 ee       	ldi	r24, 0xE6	; 230
   1160e:	92 e1       	ldi	r25, 0x12	; 18
   11610:	93 83       	std	Z+3, r25	; 0x03
   11612:	82 83       	std	Z+2, r24	; 0x02
   11614:	15 83       	std	Z+5, r17	; 0x05
   11616:	04 83       	std	Z+4, r16	; 0x04
   11618:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
   1161c:	8d b7       	in	r24, 0x3d	; 61
   1161e:	9e b7       	in	r25, 0x3e	; 62
   11620:	06 96       	adiw	r24, 0x06	; 6
   11622:	0f b6       	in	r0, 0x3f	; 63
   11624:	f8 94       	cli
   11626:	9e bf       	out	0x3e, r25	; 62
   11628:	0f be       	out	0x3f, r0	; 63
   1162a:	8d bf       	out	0x3d, r24	; 61
   1162c:	81 e0       	ldi	r24, 0x01	; 1
   1162e:	61 e0       	ldi	r22, 0x01	; 1
   11630:	41 ed       	ldi	r20, 0xD1	; 209
   11632:	52 e1       	ldi	r21, 0x12	; 18
   11634:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		       lcd_print(2,1,lcdteks);
   11638:	82 e0       	ldi	r24, 0x02	; 2
   1163a:	61 e0       	ldi	r22, 0x01	; 1
   1163c:	a7 01       	movw	r20, r14
   1163e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   11642:	83 e0       	ldi	r24, 0x03	; 3
   11644:	61 e0       	ldi	r22, 0x01	; 1
   11646:	4b ec       	ldi	r20, 0xCB	; 203
   11648:	52 e1       	ldi	r21, 0x12	; 18
   1164a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   1164e:	84 e0       	ldi	r24, 0x04	; 4
   11650:	61 e0       	ldi	r22, 0x01	; 1
   11652:	46 eb       	ldi	r20, 0xB6	; 182
   11654:	52 e1       	ldi	r21, 0x12	; 18
   11656:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      stMenuProduct=mpEditProductName;
   1165a:	85 e0       	ldi	r24, 0x05	; 5
   1165c:	75 c0       	rjmp	.+234    	; 0x11748 <FSettingProduct+0x3cc>
		  }else
		  if (KeyChar=='2'){
   1165e:	82 33       	cpi	r24, 0x32	; 50
   11660:	09 f0       	breq	.+2      	; 0x11664 <FSettingProduct+0x2e8>
   11662:	7c c0       	rjmp	.+248    	; 0x1175c <FSettingProduct+0x3e0>
		      uiResult=USER_NONE;
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
   11664:	00 d0       	rcall	.+0      	; 0x11666 <FSettingProduct+0x2ea>
   11666:	00 d0       	rcall	.+0      	; 0x11668 <FSettingProduct+0x2ec>
   11668:	00 d0       	rcall	.+0      	; 0x1166a <FSettingProduct+0x2ee>
   1166a:	ed b7       	in	r30, 0x3d	; 61
   1166c:	fe b7       	in	r31, 0x3e	; 62
   1166e:	31 96       	adiw	r30, 0x01	; 1
   11670:	8e 01       	movw	r16, r28
   11672:	02 5f       	subi	r16, 0xF2	; 242
   11674:	1f 4f       	sbci	r17, 0xFF	; 255
   11676:	ad b7       	in	r26, 0x3d	; 61
   11678:	be b7       	in	r27, 0x3e	; 62
   1167a:	12 96       	adiw	r26, 0x02	; 2
   1167c:	1c 93       	st	X, r17
   1167e:	0e 93       	st	-X, r16
   11680:	11 97       	sbiw	r26, 0x01	; 1
   11682:	8f ea       	ldi	r24, 0xAF	; 175
   11684:	92 e1       	ldi	r25, 0x12	; 18
   11686:	93 83       	std	Z+3, r25	; 0x03
   11688:	82 83       	std	Z+2, r24	; 0x02
   1168a:	87 ea       	ldi	r24, 0xA7	; 167
   1168c:	95 e0       	ldi	r25, 0x05	; 5
   1168e:	95 83       	std	Z+5, r25	; 0x05
   11690:	84 83       	std	Z+4, r24	; 0x04
   11692:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		       lcd_print(2,1,lcdteks);
   11696:	8d b7       	in	r24, 0x3d	; 61
   11698:	9e b7       	in	r25, 0x3e	; 62
   1169a:	06 96       	adiw	r24, 0x06	; 6
   1169c:	0f b6       	in	r0, 0x3f	; 63
   1169e:	f8 94       	cli
   116a0:	9e bf       	out	0x3e, r25	; 62
   116a2:	0f be       	out	0x3f, r0	; 63
   116a4:	8d bf       	out	0x3d, r24	; 61
   116a6:	82 e0       	ldi	r24, 0x02	; 2
   116a8:	61 e0       	ldi	r22, 0x01	; 1
   116aa:	a8 01       	movw	r20, r16
   116ac:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   116b0:	83 e0       	ldi	r24, 0x03	; 3
   116b2:	61 e0       	ldi	r22, 0x01	; 1
   116b4:	49 ea       	ldi	r20, 0xA9	; 169
   116b6:	52 e1       	ldi	r21, 0x12	; 18
   116b8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   116bc:	84 e0       	ldi	r24, 0x04	; 4
   116be:	61 e0       	ldi	r22, 0x01	; 1
   116c0:	44 e9       	ldi	r20, 0x94	; 148
   116c2:	52 e1       	ldi	r21, 0x12	; 18
   116c4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      stMenuProduct=mpEditPrice;
   116c8:	84 e0       	ldi	r24, 0x04	; 4
   116ca:	3e c0       	rjmp	.+124    	; 0x11748 <FSettingProduct+0x3cc>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
   116cc:	83 e0       	ldi	r24, 0x03	; 3
   116ce:	63 e0       	ldi	r22, 0x03	; 3
   116d0:	45 e0       	ldi	r20, 0x05	; 5
   116d2:	25 e1       	ldi	r18, 0x15	; 21
   116d4:	38 e0       	ldi	r19, 0x08	; 8
   116d6:	00 e0       	ldi	r16, 0x00	; 0
   116d8:	10 e0       	ldi	r17, 0x00	; 0
   116da:	9a e0       	ldi	r25, 0x0A	; 10
   116dc:	e9 2e       	mov	r14, r25
   116de:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  if (uiResult==USER_OK){
   116e2:	83 30       	cpi	r24, 0x03	; 3
   116e4:	a1 f5       	brne	.+104    	; 0x1174e <FSettingProduct+0x3d2>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   116e6:	80 91 29 02 	lds	r24, 0x0229
   116ea:	2d e0       	ldi	r18, 0x0D	; 13
   116ec:	82 9f       	mul	r24, r18
   116ee:	c0 01       	movw	r24, r0
   116f0:	11 24       	eor	r1, r1
   116f2:	85 54       	subi	r24, 0x45	; 69
   116f4:	9f 4f       	sbci	r25, 0xFF	; 255
   116f6:	65 e1       	ldi	r22, 0x15	; 21
   116f8:	78 e0       	ldi	r23, 0x08	; 8
   116fa:	4d e0       	ldi	r20, 0x0D	; 13
   116fc:	50 e0       	ldi	r21, 0x00	; 0
   116fe:	2a e4       	ldi	r18, 0x4A	; 74
   11700:	33 e1       	ldi	r19, 0x13	; 19
   11702:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
   11706:	10 92 2a 02 	sts	0x022A, r1
   1170a:	28 c0       	rjmp	.+80     	; 0x1175c <FSettingProduct+0x3e0>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
   1170c:	81 e0       	ldi	r24, 0x01	; 1
   1170e:	63 e0       	ldi	r22, 0x03	; 3
   11710:	45 e0       	ldi	r20, 0x05	; 5
   11712:	27 ea       	ldi	r18, 0xA7	; 167
   11714:	35 e0       	ldi	r19, 0x05	; 5
   11716:	00 e0       	ldi	r16, 0x00	; 0
   11718:	10 e0       	ldi	r17, 0x00	; 0
   1171a:	b7 e0       	ldi	r27, 0x07	; 7
   1171c:	eb 2e       	mov	r14, r27
   1171e:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  if (uiResult==USER_OK){
   11722:	83 30       	cpi	r24, 0x03	; 3
   11724:	a1 f4       	brne	.+40     	; 0x1174e <FSettingProduct+0x3d2>
   11726:	80 91 29 02 	lds	r24, 0x0229
   1172a:	29 e0       	ldi	r18, 0x09	; 9
   1172c:	82 9f       	mul	r24, r18
   1172e:	c0 01       	movw	r24, r0
   11730:	11 24       	eor	r1, r1
   11732:	8b 57       	subi	r24, 0x7B	; 123
   11734:	9f 4f       	sbci	r25, 0xFF	; 255
   11736:	67 ea       	ldi	r22, 0xA7	; 167
   11738:	75 e0       	ldi	r23, 0x05	; 5
   1173a:	49 e0       	ldi	r20, 0x09	; 9
   1173c:	50 e0       	ldi	r21, 0x00	; 0
   1173e:	2a e4       	ldi	r18, 0x4A	; 74
   11740:	33 e1       	ldi	r19, 0x13	; 19
   11742:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
   11746:	82 e0       	ldi	r24, 0x02	; 2
   11748:	80 93 2a 02 	sts	0x022A, r24
   1174c:	07 c0       	rjmp	.+14     	; 0x1175c <FSettingProduct+0x3e0>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
   1174e:	81 30       	cpi	r24, 0x01	; 1
   11750:	29 f4       	brne	.+10     	; 0x1175c <FSettingProduct+0x3e0>
   11752:	f9 cf       	rjmp	.-14     	; 0x11746 <FSettingProduct+0x3ca>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
   11754:	10 92 2a 02 	sts	0x022A, r1
   11758:	81 e0       	ldi	r24, 0x01	; 1
   1175a:	01 c0       	rjmp	.+2      	; 0x1175e <FSettingProduct+0x3e2>
   1175c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   1175e:	a1 96       	adiw	r28, 0x21	; 33
   11760:	0f b6       	in	r0, 0x3f	; 63
   11762:	f8 94       	cli
   11764:	de bf       	out	0x3e, r29	; 62
   11766:	0f be       	out	0x3f, r0	; 63
   11768:	cd bf       	out	0x3d, r28	; 61
   1176a:	cf 91       	pop	r28
   1176c:	df 91       	pop	r29
   1176e:	1f 91       	pop	r17
   11770:	0f 91       	pop	r16
   11772:	ff 90       	pop	r15
   11774:	ef 90       	pop	r14
   11776:	df 90       	pop	r13
   11778:	cf 90       	pop	r12
   1177a:	bf 90       	pop	r11
   1177c:	af 90       	pop	r10
   1177e:	9f 90       	pop	r9
   11780:	8f 90       	pop	r8
   11782:	7f 90       	pop	r7
   11784:	6f 90       	pop	r6
   11786:	08 95       	ret

00011788 <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
   11788:	ef 92       	push	r14
   1178a:	0f 93       	push	r16
   1178c:	1f 93       	push	r17
   1178e:	df 93       	push	r29
   11790:	cf 93       	push	r28
   11792:	cd b7       	in	r28, 0x3d	; 61
   11794:	de b7       	in	r29, 0x3e	; 62
   11796:	c6 54       	subi	r28, 0x46	; 70
   11798:	d0 40       	sbci	r29, 0x00	; 0
   1179a:	0f b6       	in	r0, 0x3f	; 63
   1179c:	f8 94       	cli
   1179e:	de bf       	out	0x3e, r29	; 62
   117a0:	0f be       	out	0x3f, r0	; 63
   117a2:	cd bf       	out	0x3d, r28	; 61
	 char strHeaderFooter[50];
	 char KeyChar;
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   117a4:	80 91 4d 02 	lds	r24, 0x024D
   117a8:	84 30       	cpi	r24, 0x04	; 4
   117aa:	09 f4       	brne	.+2      	; 0x117ae <FMenuSettingFooter+0x26>
   117ac:	3b c1       	rjmp	.+630    	; 0x11a24 <FMenuSettingFooter+0x29c>
   117ae:	85 30       	cpi	r24, 0x05	; 5
   117b0:	40 f4       	brcc	.+16     	; 0x117c2 <FMenuSettingFooter+0x3a>
   117b2:	81 30       	cpi	r24, 0x01	; 1
   117b4:	79 f1       	breq	.+94     	; 0x11814 <FMenuSettingFooter+0x8c>
   117b6:	81 30       	cpi	r24, 0x01	; 1
   117b8:	88 f0       	brcs	.+34     	; 0x117dc <FMenuSettingFooter+0x54>
   117ba:	82 30       	cpi	r24, 0x02	; 2
   117bc:	09 f0       	breq	.+2      	; 0x117c0 <FMenuSettingFooter+0x38>
   117be:	7f c1       	rjmp	.+766    	; 0x11abe <FMenuSettingFooter+0x336>
   117c0:	74 c0       	rjmp	.+232    	; 0x118aa <FMenuSettingFooter+0x122>
   117c2:	86 30       	cpi	r24, 0x06	; 6
   117c4:	09 f4       	brne	.+2      	; 0x117c8 <FMenuSettingFooter+0x40>
   117c6:	d3 c0       	rjmp	.+422    	; 0x1196e <FMenuSettingFooter+0x1e6>
   117c8:	86 30       	cpi	r24, 0x06	; 6
   117ca:	08 f4       	brcc	.+2      	; 0x117ce <FMenuSettingFooter+0x46>
   117cc:	bd c0       	rjmp	.+378    	; 0x11948 <FMenuSettingFooter+0x1c0>
   117ce:	87 30       	cpi	r24, 0x07	; 7
   117d0:	09 f4       	brne	.+2      	; 0x117d4 <FMenuSettingFooter+0x4c>
   117d2:	37 c1       	rjmp	.+622    	; 0x11a42 <FMenuSettingFooter+0x2ba>
   117d4:	88 30       	cpi	r24, 0x08	; 8
   117d6:	09 f0       	breq	.+2      	; 0x117da <FMenuSettingFooter+0x52>
   117d8:	72 c1       	rjmp	.+740    	; 0x11abe <FMenuSettingFooter+0x336>
   117da:	6d c1       	rjmp	.+730    	; 0x11ab6 <FMenuSettingFooter+0x32e>
	 case shInitHeader:
	      lcd_clear();
   117dc:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
   117e0:	81 e0       	ldi	r24, 0x01	; 1
   117e2:	61 e0       	ldi	r22, 0x01	; 1
   117e4:	43 e0       	ldi	r20, 0x03	; 3
   117e6:	55 e1       	ldi	r21, 0x15	; 21
   117e8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
   117ec:	82 e0       	ldi	r24, 0x02	; 2
   117ee:	61 e0       	ldi	r22, 0x01	; 1
   117f0:	4e ee       	ldi	r20, 0xEE	; 238
   117f2:	54 e1       	ldi	r21, 0x14	; 20
   117f4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
   117f8:	83 e0       	ldi	r24, 0x03	; 3
   117fa:	61 e0       	ldi	r22, 0x01	; 1
   117fc:	49 ed       	ldi	r20, 0xD9	; 217
   117fe:	54 e1       	ldi	r21, 0x14	; 20
   11800:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11804:	84 e0       	ldi	r24, 0x04	; 4
   11806:	61 e0       	ldi	r22, 0x01	; 1
   11808:	44 ec       	ldi	r20, 0xC4	; 196
   1180a:	54 e1       	ldi	r21, 0x14	; 20
   1180c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11810:	81 e0       	ldi	r24, 0x01	; 1
   11812:	10 c1       	rjmp	.+544    	; 0x11a34 <FMenuSettingFooter+0x2ac>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11814:	81 e0       	ldi	r24, 0x01	; 1
   11816:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   1181a:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
   1181e:	e8 2e       	mov	r14, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11820:	81 53       	subi	r24, 0x31	; 49
   11822:	86 30       	cpi	r24, 0x06	; 6
   11824:	e0 f5       	brcc	.+120    	; 0x1189e <FMenuSettingFooter+0x116>
		       HeaderIdx=KeyChar-'1';//
   11826:	80 93 4c 02 	sts	0x024C, r24
			   lcd_clear();
   1182a:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
   1182e:	00 d0       	rcall	.+0      	; 0x11830 <FMenuSettingFooter+0xa8>
   11830:	00 d0       	rcall	.+0      	; 0x11832 <FMenuSettingFooter+0xaa>
   11832:	00 d0       	rcall	.+0      	; 0x11834 <FMenuSettingFooter+0xac>
   11834:	ed b7       	in	r30, 0x3d	; 61
   11836:	fe b7       	in	r31, 0x3e	; 62
   11838:	31 96       	adiw	r30, 0x01	; 1
   1183a:	8e 01       	movw	r16, r28
   1183c:	0f 5f       	subi	r16, 0xFF	; 255
   1183e:	1f 4f       	sbci	r17, 0xFF	; 255
   11840:	ad b7       	in	r26, 0x3d	; 61
   11842:	be b7       	in	r27, 0x3e	; 62
   11844:	12 96       	adiw	r26, 0x02	; 2
   11846:	1c 93       	st	X, r17
   11848:	0e 93       	st	-X, r16
   1184a:	11 97       	sbiw	r26, 0x01	; 1
   1184c:	85 eb       	ldi	r24, 0xB5	; 181
   1184e:	94 e1       	ldi	r25, 0x14	; 20
   11850:	93 83       	std	Z+3, r25	; 0x03
   11852:	82 83       	std	Z+2, r24	; 0x02
   11854:	80 91 4c 02 	lds	r24, 0x024C
   11858:	90 e0       	ldi	r25, 0x00	; 0
   1185a:	01 96       	adiw	r24, 0x01	; 1
   1185c:	95 83       	std	Z+5, r25	; 0x05
   1185e:	84 83       	std	Z+4, r24	; 0x04
   11860:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11864:	8d b7       	in	r24, 0x3d	; 61
   11866:	9e b7       	in	r25, 0x3e	; 62
   11868:	06 96       	adiw	r24, 0x06	; 6
   1186a:	0f b6       	in	r0, 0x3f	; 63
   1186c:	f8 94       	cli
   1186e:	9e bf       	out	0x3e, r25	; 62
   11870:	0f be       	out	0x3f, r0	; 63
   11872:	8d bf       	out	0x3d, r24	; 61
   11874:	81 e0       	ldi	r24, 0x01	; 1
   11876:	61 e0       	ldi	r22, 0x01	; 1
   11878:	a8 01       	movw	r20, r16
   1187a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   1187e:	84 e0       	ldi	r24, 0x04	; 4
   11880:	61 e0       	ldi	r22, 0x01	; 1
   11882:	46 ea       	ldi	r20, 0xA6	; 166
   11884:	54 e1       	ldi	r21, 0x14	; 20
   11886:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   1188a:	e5 ef       	ldi	r30, 0xF5	; 245
   1188c:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   1188e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11890:	95 e0       	ldi	r25, 0x05	; 5
   11892:	e6 38       	cpi	r30, 0x86	; 134
   11894:	f9 07       	cpc	r31, r25
   11896:	d9 f7       	brne	.-10     	; 0x1188e <FMenuSettingFooter+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   11898:	82 e0       	ldi	r24, 0x02	; 2
   1189a:	80 93 4d 02 	sts	0x024D, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   1189e:	aa e2       	ldi	r26, 0x2A	; 42
   118a0:	ea 16       	cp	r14, r26
   118a2:	09 f0       	breq	.+2      	; 0x118a6 <FMenuSettingFooter+0x11e>
   118a4:	0c c1       	rjmp	.+536    	; 0x11abe <FMenuSettingFooter+0x336>
   118a6:	88 e0       	ldi	r24, 0x08	; 8
   118a8:	c5 c0       	rjmp	.+394    	; 0x11a34 <FMenuSettingFooter+0x2ac>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   118aa:	83 e0       	ldi	r24, 0x03	; 3
   118ac:	62 e0       	ldi	r22, 0x02	; 2
   118ae:	41 e0       	ldi	r20, 0x01	; 1
   118b0:	25 ef       	ldi	r18, 0xF5	; 245
   118b2:	33 e0       	ldi	r19, 0x03	; 3
   118b4:	00 e0       	ldi	r16, 0x00	; 0
   118b6:	10 e0       	ldi	r17, 0x00	; 0
   118b8:	e8 e2       	ldi	r30, 0x28	; 40
   118ba:	ee 2e       	mov	r14, r30
   118bc:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  if (uiResult==USER_OK){
   118c0:	83 30       	cpi	r24, 0x03	; 3
   118c2:	f1 f5       	brne	.+124    	; 0x11940 <FMenuSettingFooter+0x1b8>
			  lcd_clear();
   118c4:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   118c8:	85 ef       	ldi	r24, 0xF5	; 245
   118ca:	93 e0       	ldi	r25, 0x03	; 3
   118cc:	68 e2       	ldi	r22, 0x28	; 40
   118ce:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
   118d2:	20 e0       	ldi	r18, 0x00	; 0
   118d4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   118d6:	f9 01       	movw	r30, r18
   118d8:	e5 56       	subi	r30, 0x65	; 101
   118da:	f7 4f       	sbci	r31, 0xF7	; 247
   118dc:	d9 01       	movw	r26, r18
   118de:	ab 50       	subi	r26, 0x0B	; 11
   118e0:	bc 4f       	sbci	r27, 0xFC	; 252
   118e2:	8c 91       	ld	r24, X
   118e4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   118e6:	2f 5f       	subi	r18, 0xFF	; 255
   118e8:	3f 4f       	sbci	r19, 0xFF	; 255
   118ea:	24 31       	cpi	r18, 0x14	; 20
   118ec:	31 05       	cpc	r19, r1
   118ee:	99 f7       	brne	.-26     	; 0x118d6 <FMenuSettingFooter+0x14e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   118f0:	10 92 af 08 	sts	0x08AF, r1
   118f4:	e9 e0       	ldi	r30, 0x09	; 9
   118f6:	f4 e0       	ldi	r31, 0x04	; 4
   118f8:	ac ea       	ldi	r26, 0xAC	; 172
   118fa:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   118fc:	81 91       	ld	r24, Z+
   118fe:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11900:	84 e0       	ldi	r24, 0x04	; 4
   11902:	ed 31       	cpi	r30, 0x1D	; 29
   11904:	f8 07       	cpc	r31, r24
   11906:	d1 f7       	brne	.-12     	; 0x118fc <FMenuSettingFooter+0x174>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11908:	10 92 c0 07 	sts	0x07C0, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   1190c:	81 e0       	ldi	r24, 0x01	; 1
   1190e:	61 e0       	ldi	r22, 0x01	; 1
   11910:	4b e9       	ldi	r20, 0x9B	; 155
   11912:	58 e0       	ldi	r21, 0x08	; 8
   11914:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   11918:	82 e0       	ldi	r24, 0x02	; 2
   1191a:	61 e0       	ldi	r22, 0x01	; 1
   1191c:	4c ea       	ldi	r20, 0xAC	; 172
   1191e:	57 e0       	ldi	r21, 0x07	; 7
   11920:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   11924:	83 e0       	ldi	r24, 0x03	; 3
   11926:	61 e0       	ldi	r22, 0x01	; 1
   11928:	48 e9       	ldi	r20, 0x98	; 152
   1192a:	54 e1       	ldi	r21, 0x14	; 20
   1192c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11930:	84 e0       	ldi	r24, 0x04	; 4
   11932:	61 e0       	ldi	r22, 0x01	; 1
   11934:	4a e8       	ldi	r20, 0x8A	; 138
   11936:	54 e1       	ldi	r21, 0x14	; 20
   11938:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   1193c:	85 e0       	ldi	r24, 0x05	; 5
   1193e:	7a c0       	rjmp	.+244    	; 0x11a34 <FMenuSettingFooter+0x2ac>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11940:	81 30       	cpi	r24, 0x01	; 1
   11942:	09 f0       	breq	.+2      	; 0x11946 <FMenuSettingFooter+0x1be>
   11944:	bc c0       	rjmp	.+376    	; 0x11abe <FMenuSettingFooter+0x336>
   11946:	b4 c0       	rjmp	.+360    	; 0x11ab0 <FMenuSettingFooter+0x328>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   11948:	81 e0       	ldi	r24, 0x01	; 1
   1194a:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   1194e:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
          if(KeyChar=='#'){
   11952:	83 32       	cpi	r24, 0x23	; 35
   11954:	39 f4       	brne	.+14     	; 0x11964 <FMenuSettingFooter+0x1dc>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11956:	85 ef       	ldi	r24, 0xF5	; 245
   11958:	93 e0       	ldi	r25, 0x03	; 3
   1195a:	68 e2       	ldi	r22, 0x28	; 40
   1195c:	70 e0       	ldi	r23, 0x00	; 0
   1195e:	0e 94 3a 35 	call	0x6a74	; 0x6a74 <StrAlignCenter>
   11962:	03 c0       	rjmp	.+6      	; 0x1196a <FMenuSettingFooter+0x1e2>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   11964:	8a 32       	cpi	r24, 0x2A	; 42
   11966:	09 f0       	breq	.+2      	; 0x1196a <FMenuSettingFooter+0x1e2>
   11968:	aa c0       	rjmp	.+340    	; 0x11abe <FMenuSettingFooter+0x336>
   1196a:	86 e0       	ldi	r24, 0x06	; 6
   1196c:	63 c0       	rjmp	.+198    	; 0x11a34 <FMenuSettingFooter+0x2ac>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   1196e:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   11972:	20 e0       	ldi	r18, 0x00	; 0
   11974:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11976:	f9 01       	movw	r30, r18
   11978:	e5 56       	subi	r30, 0x65	; 101
   1197a:	f7 4f       	sbci	r31, 0xF7	; 247
   1197c:	d9 01       	movw	r26, r18
   1197e:	ab 50       	subi	r26, 0x0B	; 11
   11980:	bc 4f       	sbci	r27, 0xFC	; 252
   11982:	8c 91       	ld	r24, X
   11984:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11986:	2f 5f       	subi	r18, 0xFF	; 255
   11988:	3f 4f       	sbci	r19, 0xFF	; 255
   1198a:	24 31       	cpi	r18, 0x14	; 20
   1198c:	31 05       	cpc	r19, r1
   1198e:	99 f7       	brne	.-26     	; 0x11976 <FMenuSettingFooter+0x1ee>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11990:	10 92 af 08 	sts	0x08AF, r1
   11994:	e9 e0       	ldi	r30, 0x09	; 9
   11996:	f4 e0       	ldi	r31, 0x04	; 4
   11998:	ac ea       	ldi	r26, 0xAC	; 172
   1199a:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1199c:	81 91       	ld	r24, Z+
   1199e:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   119a0:	94 e0       	ldi	r25, 0x04	; 4
   119a2:	ed 31       	cpi	r30, 0x1D	; 29
   119a4:	f9 07       	cpc	r31, r25
   119a6:	d1 f7       	brne	.-12     	; 0x1199c <FMenuSettingFooter+0x214>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   119a8:	10 92 c0 07 	sts	0x07C0, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   119ac:	81 e0       	ldi	r24, 0x01	; 1
   119ae:	61 e0       	ldi	r22, 0x01	; 1
   119b0:	4b e9       	ldi	r20, 0x9B	; 155
   119b2:	58 e0       	ldi	r21, 0x08	; 8
   119b4:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   119b8:	82 e0       	ldi	r24, 0x02	; 2
   119ba:	61 e0       	ldi	r22, 0x01	; 1
   119bc:	4c ea       	ldi	r20, 0xAC	; 172
   119be:	57 e0       	ldi	r21, 0x07	; 7
   119c0:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
   119c4:	00 d0       	rcall	.+0      	; 0x119c6 <FMenuSettingFooter+0x23e>
   119c6:	00 d0       	rcall	.+0      	; 0x119c8 <FMenuSettingFooter+0x240>
   119c8:	00 d0       	rcall	.+0      	; 0x119ca <FMenuSettingFooter+0x242>
   119ca:	ed b7       	in	r30, 0x3d	; 61
   119cc:	fe b7       	in	r31, 0x3e	; 62
   119ce:	31 96       	adiw	r30, 0x01	; 1
   119d0:	8e 01       	movw	r16, r28
   119d2:	0f 5f       	subi	r16, 0xFF	; 255
   119d4:	1f 4f       	sbci	r17, 0xFF	; 255
   119d6:	ad b7       	in	r26, 0x3d	; 61
   119d8:	be b7       	in	r27, 0x3e	; 62
   119da:	12 96       	adiw	r26, 0x02	; 2
   119dc:	1c 93       	st	X, r17
   119de:	0e 93       	st	-X, r16
   119e0:	11 97       	sbiw	r26, 0x01	; 1
   119e2:	8a e7       	ldi	r24, 0x7A	; 122
   119e4:	94 e1       	ldi	r25, 0x14	; 20
   119e6:	93 83       	std	Z+3, r25	; 0x03
   119e8:	82 83       	std	Z+2, r24	; 0x02
   119ea:	80 91 4c 02 	lds	r24, 0x024C
   119ee:	90 e0       	ldi	r25, 0x00	; 0
   119f0:	01 96       	adiw	r24, 0x01	; 1
   119f2:	95 83       	std	Z+5, r25	; 0x05
   119f4:	84 83       	std	Z+4, r24	; 0x04
   119f6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   119fa:	8d b7       	in	r24, 0x3d	; 61
   119fc:	9e b7       	in	r25, 0x3e	; 62
   119fe:	06 96       	adiw	r24, 0x06	; 6
   11a00:	0f b6       	in	r0, 0x3f	; 63
   11a02:	f8 94       	cli
   11a04:	9e bf       	out	0x3e, r25	; 62
   11a06:	0f be       	out	0x3f, r0	; 63
   11a08:	8d bf       	out	0x3d, r24	; 61
   11a0a:	83 e0       	ldi	r24, 0x03	; 3
   11a0c:	61 e0       	ldi	r22, 0x01	; 1
   11a0e:	a8 01       	movw	r20, r16
   11a10:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11a14:	84 e0       	ldi	r24, 0x04	; 4
   11a16:	61 e0       	ldi	r22, 0x01	; 1
   11a18:	4d e6       	ldi	r20, 0x6D	; 109
   11a1a:	54 e1       	ldi	r21, 0x14	; 20
   11a1c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11a20:	84 e0       	ldi	r24, 0x04	; 4
   11a22:	08 c0       	rjmp	.+16     	; 0x11a34 <FMenuSettingFooter+0x2ac>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
   11a24:	81 e0       	ldi	r24, 0x01	; 1
   11a26:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   11a2a:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11a2e:	83 32       	cpi	r24, 0x23	; 35
   11a30:	21 f4       	brne	.+8      	; 0x11a3a <FMenuSettingFooter+0x2b2>
   11a32:	87 e0       	ldi	r24, 0x07	; 7
   11a34:	80 93 4d 02 	sts	0x024D, r24
   11a38:	42 c0       	rjmp	.+132    	; 0x11abe <FMenuSettingFooter+0x336>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11a3a:	8a 32       	cpi	r24, 0x2A	; 42
   11a3c:	09 f0       	breq	.+2      	; 0x11a40 <FMenuSettingFooter+0x2b8>
   11a3e:	3f c0       	rjmp	.+126    	; 0x11abe <FMenuSettingFooter+0x336>
   11a40:	37 c0       	rjmp	.+110    	; 0x11ab0 <FMenuSettingFooter+0x328>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11a42:	ad b7       	in	r26, 0x3d	; 61
   11a44:	be b7       	in	r27, 0x3e	; 62
   11a46:	18 97       	sbiw	r26, 0x08	; 8
   11a48:	0f b6       	in	r0, 0x3f	; 63
   11a4a:	f8 94       	cli
   11a4c:	be bf       	out	0x3e, r27	; 62
   11a4e:	0f be       	out	0x3f, r0	; 63
   11a50:	ad bf       	out	0x3d, r26	; 61
   11a52:	ed b7       	in	r30, 0x3d	; 61
   11a54:	fe b7       	in	r31, 0x3e	; 62
   11a56:	31 96       	adiw	r30, 0x01	; 1
   11a58:	8e 01       	movw	r16, r28
   11a5a:	0b 5e       	subi	r16, 0xEB	; 235
   11a5c:	1f 4f       	sbci	r17, 0xFF	; 255
   11a5e:	12 96       	adiw	r26, 0x02	; 2
   11a60:	1c 93       	st	X, r17
   11a62:	0e 93       	st	-X, r16
   11a64:	11 97       	sbiw	r26, 0x01	; 1
   11a66:	88 e6       	ldi	r24, 0x68	; 104
   11a68:	94 e1       	ldi	r25, 0x14	; 20
   11a6a:	93 83       	std	Z+3, r25	; 0x03
   11a6c:	82 83       	std	Z+2, r24	; 0x02
   11a6e:	8b e9       	ldi	r24, 0x9B	; 155
   11a70:	98 e0       	ldi	r25, 0x08	; 8
   11a72:	95 83       	std	Z+5, r25	; 0x05
   11a74:	84 83       	std	Z+4, r24	; 0x04
   11a76:	8c ea       	ldi	r24, 0xAC	; 172
   11a78:	97 e0       	ldi	r25, 0x07	; 7
   11a7a:	97 83       	std	Z+7, r25	; 0x07
   11a7c:	86 83       	std	Z+6, r24	; 0x06
   11a7e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   11a82:	8d b7       	in	r24, 0x3d	; 61
   11a84:	9e b7       	in	r25, 0x3e	; 62
   11a86:	08 96       	adiw	r24, 0x08	; 8
   11a88:	0f b6       	in	r0, 0x3f	; 63
   11a8a:	f8 94       	cli
   11a8c:	9e bf       	out	0x3e, r25	; 62
   11a8e:	0f be       	out	0x3f, r0	; 63
   11a90:	8d bf       	out	0x3d, r24	; 61
   11a92:	80 91 4c 02 	lds	r24, 0x024C
   11a96:	29 e2       	ldi	r18, 0x29	; 41
   11a98:	82 9f       	mul	r24, r18
   11a9a:	c0 01       	movw	r24, r0
   11a9c:	11 24       	eor	r1, r1
   11a9e:	83 5e       	subi	r24, 0xE3	; 227
   11aa0:	9c 4f       	sbci	r25, 0xFC	; 252
   11aa2:	b8 01       	movw	r22, r16
   11aa4:	48 e2       	ldi	r20, 0x28	; 40
   11aa6:	50 e0       	ldi	r21, 0x00	; 0
   11aa8:	2a e4       	ldi	r18, 0x4A	; 74
   11aaa:	33 e1       	ldi	r19, 0x13	; 19
   11aac:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx+6],40);

          stSettingHeader=shInitHeader;
   11ab0:	10 92 4d 02 	sts	0x024D, r1
   11ab4:	04 c0       	rjmp	.+8      	; 0x11abe <FMenuSettingFooter+0x336>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11ab6:	10 92 4d 02 	sts	0x024D, r1
   11aba:	81 e0       	ldi	r24, 0x01	; 1
   11abc:	01 c0       	rjmp	.+2      	; 0x11ac0 <FMenuSettingFooter+0x338>
   11abe:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
   11ac0:	ca 5b       	subi	r28, 0xBA	; 186
   11ac2:	df 4f       	sbci	r29, 0xFF	; 255
   11ac4:	0f b6       	in	r0, 0x3f	; 63
   11ac6:	f8 94       	cli
   11ac8:	de bf       	out	0x3e, r29	; 62
   11aca:	0f be       	out	0x3f, r0	; 63
   11acc:	cd bf       	out	0x3d, r28	; 61
   11ace:	cf 91       	pop	r28
   11ad0:	df 91       	pop	r29
   11ad2:	1f 91       	pop	r17
   11ad4:	0f 91       	pop	r16
   11ad6:	ef 90       	pop	r14
   11ad8:	08 95       	ret

00011ada <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
   11ada:	ef 92       	push	r14
   11adc:	0f 93       	push	r16
   11ade:	1f 93       	push	r17
   11ae0:	df 93       	push	r29
   11ae2:	cf 93       	push	r28
   11ae4:	cd b7       	in	r28, 0x3d	; 61
   11ae6:	de b7       	in	r29, 0x3e	; 62
   11ae8:	c6 54       	subi	r28, 0x46	; 70
   11aea:	d0 40       	sbci	r29, 0x00	; 0
   11aec:	0f b6       	in	r0, 0x3f	; 63
   11aee:	f8 94       	cli
   11af0:	de bf       	out	0x3e, r29	; 62
   11af2:	0f be       	out	0x3f, r0	; 63
   11af4:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11af6:	80 91 4f 02 	lds	r24, 0x024F
   11afa:	84 30       	cpi	r24, 0x04	; 4
   11afc:	09 f4       	brne	.+2      	; 0x11b00 <FMenuSettingHeader+0x26>
   11afe:	3b c1       	rjmp	.+630    	; 0x11d76 <FMenuSettingHeader+0x29c>
   11b00:	85 30       	cpi	r24, 0x05	; 5
   11b02:	40 f4       	brcc	.+16     	; 0x11b14 <FMenuSettingHeader+0x3a>
   11b04:	81 30       	cpi	r24, 0x01	; 1
   11b06:	79 f1       	breq	.+94     	; 0x11b66 <FMenuSettingHeader+0x8c>
   11b08:	81 30       	cpi	r24, 0x01	; 1
   11b0a:	88 f0       	brcs	.+34     	; 0x11b2e <FMenuSettingHeader+0x54>
   11b0c:	82 30       	cpi	r24, 0x02	; 2
   11b0e:	09 f0       	breq	.+2      	; 0x11b12 <FMenuSettingHeader+0x38>
   11b10:	7f c1       	rjmp	.+766    	; 0x11e10 <FMenuSettingHeader+0x336>
   11b12:	74 c0       	rjmp	.+232    	; 0x11bfc <FMenuSettingHeader+0x122>
   11b14:	86 30       	cpi	r24, 0x06	; 6
   11b16:	09 f4       	brne	.+2      	; 0x11b1a <FMenuSettingHeader+0x40>
   11b18:	d3 c0       	rjmp	.+422    	; 0x11cc0 <FMenuSettingHeader+0x1e6>
   11b1a:	86 30       	cpi	r24, 0x06	; 6
   11b1c:	08 f4       	brcc	.+2      	; 0x11b20 <FMenuSettingHeader+0x46>
   11b1e:	bd c0       	rjmp	.+378    	; 0x11c9a <FMenuSettingHeader+0x1c0>
   11b20:	87 30       	cpi	r24, 0x07	; 7
   11b22:	09 f4       	brne	.+2      	; 0x11b26 <FMenuSettingHeader+0x4c>
   11b24:	37 c1       	rjmp	.+622    	; 0x11d94 <FMenuSettingHeader+0x2ba>
   11b26:	88 30       	cpi	r24, 0x08	; 8
   11b28:	09 f0       	breq	.+2      	; 0x11b2c <FMenuSettingHeader+0x52>
   11b2a:	72 c1       	rjmp	.+740    	; 0x11e10 <FMenuSettingHeader+0x336>
   11b2c:	6d c1       	rjmp	.+730    	; 0x11e08 <FMenuSettingHeader+0x32e>
	 case shInitHeader:
	      lcd_clear();
   11b2e:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
   11b32:	81 e0       	ldi	r24, 0x01	; 1
   11b34:	61 e0       	ldi	r22, 0x01	; 1
   11b36:	43 eb       	ldi	r20, 0xB3	; 179
   11b38:	55 e1       	ldi	r21, 0x15	; 21
   11b3a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
   11b3e:	82 e0       	ldi	r24, 0x02	; 2
   11b40:	61 e0       	ldi	r22, 0x01	; 1
   11b42:	4e e9       	ldi	r20, 0x9E	; 158
   11b44:	55 e1       	ldi	r21, 0x15	; 21
   11b46:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
   11b4a:	83 e0       	ldi	r24, 0x03	; 3
   11b4c:	61 e0       	ldi	r22, 0x01	; 1
   11b4e:	49 e8       	ldi	r20, 0x89	; 137
   11b50:	55 e1       	ldi	r21, 0x15	; 21
   11b52:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11b56:	84 e0       	ldi	r24, 0x04	; 4
   11b58:	61 e0       	ldi	r22, 0x01	; 1
   11b5a:	44 e7       	ldi	r20, 0x74	; 116
   11b5c:	55 e1       	ldi	r21, 0x15	; 21
   11b5e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11b62:	81 e0       	ldi	r24, 0x01	; 1
   11b64:	10 c1       	rjmp	.+544    	; 0x11d86 <FMenuSettingHeader+0x2ac>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11b66:	81 e0       	ldi	r24, 0x01	; 1
   11b68:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   11b6c:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
   11b70:	e8 2e       	mov	r14, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11b72:	81 53       	subi	r24, 0x31	; 49
   11b74:	86 30       	cpi	r24, 0x06	; 6
   11b76:	e0 f5       	brcc	.+120    	; 0x11bf0 <FMenuSettingHeader+0x116>
		       HeaderIdx=KeyChar-'1';//
   11b78:	80 93 4e 02 	sts	0x024E, r24
			   lcd_clear();
   11b7c:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
   11b80:	00 d0       	rcall	.+0      	; 0x11b82 <FMenuSettingHeader+0xa8>
   11b82:	00 d0       	rcall	.+0      	; 0x11b84 <FMenuSettingHeader+0xaa>
   11b84:	00 d0       	rcall	.+0      	; 0x11b86 <FMenuSettingHeader+0xac>
   11b86:	ed b7       	in	r30, 0x3d	; 61
   11b88:	fe b7       	in	r31, 0x3e	; 62
   11b8a:	31 96       	adiw	r30, 0x01	; 1
   11b8c:	8e 01       	movw	r16, r28
   11b8e:	0f 5f       	subi	r16, 0xFF	; 255
   11b90:	1f 4f       	sbci	r17, 0xFF	; 255
   11b92:	ad b7       	in	r26, 0x3d	; 61
   11b94:	be b7       	in	r27, 0x3e	; 62
   11b96:	12 96       	adiw	r26, 0x02	; 2
   11b98:	1c 93       	st	X, r17
   11b9a:	0e 93       	st	-X, r16
   11b9c:	11 97       	sbiw	r26, 0x01	; 1
   11b9e:	85 e6       	ldi	r24, 0x65	; 101
   11ba0:	95 e1       	ldi	r25, 0x15	; 21
   11ba2:	93 83       	std	Z+3, r25	; 0x03
   11ba4:	82 83       	std	Z+2, r24	; 0x02
   11ba6:	80 91 4e 02 	lds	r24, 0x024E
   11baa:	90 e0       	ldi	r25, 0x00	; 0
   11bac:	01 96       	adiw	r24, 0x01	; 1
   11bae:	95 83       	std	Z+5, r25	; 0x05
   11bb0:	84 83       	std	Z+4, r24	; 0x04
   11bb2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11bb6:	8d b7       	in	r24, 0x3d	; 61
   11bb8:	9e b7       	in	r25, 0x3e	; 62
   11bba:	06 96       	adiw	r24, 0x06	; 6
   11bbc:	0f b6       	in	r0, 0x3f	; 63
   11bbe:	f8 94       	cli
   11bc0:	9e bf       	out	0x3e, r25	; 62
   11bc2:	0f be       	out	0x3f, r0	; 63
   11bc4:	8d bf       	out	0x3d, r24	; 61
   11bc6:	81 e0       	ldi	r24, 0x01	; 1
   11bc8:	61 e0       	ldi	r22, 0x01	; 1
   11bca:	a8 01       	movw	r20, r16
   11bcc:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   11bd0:	84 e0       	ldi	r24, 0x04	; 4
   11bd2:	61 e0       	ldi	r22, 0x01	; 1
   11bd4:	46 e5       	ldi	r20, 0x56	; 86
   11bd6:	55 e1       	ldi	r21, 0x15	; 21
   11bd8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   11bdc:	e5 ef       	ldi	r30, 0xF5	; 245
   11bde:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11be0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11be2:	95 e0       	ldi	r25, 0x05	; 5
   11be4:	e6 38       	cpi	r30, 0x86	; 134
   11be6:	f9 07       	cpc	r31, r25
   11be8:	d9 f7       	brne	.-10     	; 0x11be0 <FMenuSettingHeader+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   11bea:	82 e0       	ldi	r24, 0x02	; 2
   11bec:	80 93 4f 02 	sts	0x024F, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11bf0:	aa e2       	ldi	r26, 0x2A	; 42
   11bf2:	ea 16       	cp	r14, r26
   11bf4:	09 f0       	breq	.+2      	; 0x11bf8 <FMenuSettingHeader+0x11e>
   11bf6:	0c c1       	rjmp	.+536    	; 0x11e10 <FMenuSettingHeader+0x336>
   11bf8:	88 e0       	ldi	r24, 0x08	; 8
   11bfa:	c5 c0       	rjmp	.+394    	; 0x11d86 <FMenuSettingHeader+0x2ac>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11bfc:	83 e0       	ldi	r24, 0x03	; 3
   11bfe:	62 e0       	ldi	r22, 0x02	; 2
   11c00:	41 e0       	ldi	r20, 0x01	; 1
   11c02:	25 ef       	ldi	r18, 0xF5	; 245
   11c04:	33 e0       	ldi	r19, 0x03	; 3
   11c06:	00 e0       	ldi	r16, 0x00	; 0
   11c08:	10 e0       	ldi	r17, 0x00	; 0
   11c0a:	f8 e2       	ldi	r31, 0x28	; 40
   11c0c:	ef 2e       	mov	r14, r31
   11c0e:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  if (uiResult==USER_OK){
   11c12:	83 30       	cpi	r24, 0x03	; 3
   11c14:	f1 f5       	brne	.+124    	; 0x11c92 <FMenuSettingHeader+0x1b8>
			  lcd_clear();
   11c16:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   11c1a:	85 ef       	ldi	r24, 0xF5	; 245
   11c1c:	93 e0       	ldi	r25, 0x03	; 3
   11c1e:	68 e2       	ldi	r22, 0x28	; 40
   11c20:	0e 94 1e 31 	call	0x623c	; 0x623c <AddSpaceLag>
   11c24:	20 e0       	ldi	r18, 0x00	; 0
   11c26:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11c28:	f9 01       	movw	r30, r18
   11c2a:	e5 56       	subi	r30, 0x65	; 101
   11c2c:	f7 4f       	sbci	r31, 0xF7	; 247
   11c2e:	d9 01       	movw	r26, r18
   11c30:	ab 50       	subi	r26, 0x0B	; 11
   11c32:	bc 4f       	sbci	r27, 0xFC	; 252
   11c34:	8c 91       	ld	r24, X
   11c36:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11c38:	2f 5f       	subi	r18, 0xFF	; 255
   11c3a:	3f 4f       	sbci	r19, 0xFF	; 255
   11c3c:	24 31       	cpi	r18, 0x14	; 20
   11c3e:	31 05       	cpc	r19, r1
   11c40:	99 f7       	brne	.-26     	; 0x11c28 <FMenuSettingHeader+0x14e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11c42:	10 92 af 08 	sts	0x08AF, r1
   11c46:	e9 e0       	ldi	r30, 0x09	; 9
   11c48:	f4 e0       	ldi	r31, 0x04	; 4
   11c4a:	ac ea       	ldi	r26, 0xAC	; 172
   11c4c:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11c4e:	81 91       	ld	r24, Z+
   11c50:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11c52:	84 e0       	ldi	r24, 0x04	; 4
   11c54:	ed 31       	cpi	r30, 0x1D	; 29
   11c56:	f8 07       	cpc	r31, r24
   11c58:	d1 f7       	brne	.-12     	; 0x11c4e <FMenuSettingHeader+0x174>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11c5a:	10 92 c0 07 	sts	0x07C0, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   11c5e:	81 e0       	ldi	r24, 0x01	; 1
   11c60:	61 e0       	ldi	r22, 0x01	; 1
   11c62:	4b e9       	ldi	r20, 0x9B	; 155
   11c64:	58 e0       	ldi	r21, 0x08	; 8
   11c66:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   11c6a:	82 e0       	ldi	r24, 0x02	; 2
   11c6c:	61 e0       	ldi	r22, 0x01	; 1
   11c6e:	4c ea       	ldi	r20, 0xAC	; 172
   11c70:	57 e0       	ldi	r21, 0x07	; 7
   11c72:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   11c76:	83 e0       	ldi	r24, 0x03	; 3
   11c78:	61 e0       	ldi	r22, 0x01	; 1
   11c7a:	48 e4       	ldi	r20, 0x48	; 72
   11c7c:	55 e1       	ldi	r21, 0x15	; 21
   11c7e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11c82:	84 e0       	ldi	r24, 0x04	; 4
   11c84:	61 e0       	ldi	r22, 0x01	; 1
   11c86:	4a e3       	ldi	r20, 0x3A	; 58
   11c88:	55 e1       	ldi	r21, 0x15	; 21
   11c8a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11c8e:	85 e0       	ldi	r24, 0x05	; 5
   11c90:	7a c0       	rjmp	.+244    	; 0x11d86 <FMenuSettingHeader+0x2ac>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11c92:	81 30       	cpi	r24, 0x01	; 1
   11c94:	09 f0       	breq	.+2      	; 0x11c98 <FMenuSettingHeader+0x1be>
   11c96:	bc c0       	rjmp	.+376    	; 0x11e10 <FMenuSettingHeader+0x336>
   11c98:	b4 c0       	rjmp	.+360    	; 0x11e02 <FMenuSettingHeader+0x328>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   11c9a:	81 e0       	ldi	r24, 0x01	; 1
   11c9c:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   11ca0:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
          if(KeyChar=='#'){
   11ca4:	83 32       	cpi	r24, 0x23	; 35
   11ca6:	39 f4       	brne	.+14     	; 0x11cb6 <FMenuSettingHeader+0x1dc>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11ca8:	85 ef       	ldi	r24, 0xF5	; 245
   11caa:	93 e0       	ldi	r25, 0x03	; 3
   11cac:	68 e2       	ldi	r22, 0x28	; 40
   11cae:	70 e0       	ldi	r23, 0x00	; 0
   11cb0:	0e 94 3a 35 	call	0x6a74	; 0x6a74 <StrAlignCenter>
   11cb4:	03 c0       	rjmp	.+6      	; 0x11cbc <FMenuSettingHeader+0x1e2>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   11cb6:	8a 32       	cpi	r24, 0x2A	; 42
   11cb8:	09 f0       	breq	.+2      	; 0x11cbc <FMenuSettingHeader+0x1e2>
   11cba:	aa c0       	rjmp	.+340    	; 0x11e10 <FMenuSettingHeader+0x336>
   11cbc:	86 e0       	ldi	r24, 0x06	; 6
   11cbe:	63 c0       	rjmp	.+198    	; 0x11d86 <FMenuSettingHeader+0x2ac>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11cc0:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   11cc4:	20 e0       	ldi	r18, 0x00	; 0
   11cc6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11cc8:	f9 01       	movw	r30, r18
   11cca:	e5 56       	subi	r30, 0x65	; 101
   11ccc:	f7 4f       	sbci	r31, 0xF7	; 247
   11cce:	d9 01       	movw	r26, r18
   11cd0:	ab 50       	subi	r26, 0x0B	; 11
   11cd2:	bc 4f       	sbci	r27, 0xFC	; 252
   11cd4:	8c 91       	ld	r24, X
   11cd6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11cd8:	2f 5f       	subi	r18, 0xFF	; 255
   11cda:	3f 4f       	sbci	r19, 0xFF	; 255
   11cdc:	24 31       	cpi	r18, 0x14	; 20
   11cde:	31 05       	cpc	r19, r1
   11ce0:	99 f7       	brne	.-26     	; 0x11cc8 <FMenuSettingHeader+0x1ee>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11ce2:	10 92 af 08 	sts	0x08AF, r1
   11ce6:	e9 e0       	ldi	r30, 0x09	; 9
   11ce8:	f4 e0       	ldi	r31, 0x04	; 4
   11cea:	ac ea       	ldi	r26, 0xAC	; 172
   11cec:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11cee:	81 91       	ld	r24, Z+
   11cf0:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11cf2:	94 e0       	ldi	r25, 0x04	; 4
   11cf4:	ed 31       	cpi	r30, 0x1D	; 29
   11cf6:	f9 07       	cpc	r31, r25
   11cf8:	d1 f7       	brne	.-12     	; 0x11cee <FMenuSettingHeader+0x214>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11cfa:	10 92 c0 07 	sts	0x07C0, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11cfe:	81 e0       	ldi	r24, 0x01	; 1
   11d00:	61 e0       	ldi	r22, 0x01	; 1
   11d02:	4b e9       	ldi	r20, 0x9B	; 155
   11d04:	58 e0       	ldi	r21, 0x08	; 8
   11d06:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11d0a:	82 e0       	ldi	r24, 0x02	; 2
   11d0c:	61 e0       	ldi	r22, 0x01	; 1
   11d0e:	4c ea       	ldi	r20, 0xAC	; 172
   11d10:	57 e0       	ldi	r21, 0x07	; 7
   11d12:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
   11d16:	00 d0       	rcall	.+0      	; 0x11d18 <FMenuSettingHeader+0x23e>
   11d18:	00 d0       	rcall	.+0      	; 0x11d1a <FMenuSettingHeader+0x240>
   11d1a:	00 d0       	rcall	.+0      	; 0x11d1c <FMenuSettingHeader+0x242>
   11d1c:	ed b7       	in	r30, 0x3d	; 61
   11d1e:	fe b7       	in	r31, 0x3e	; 62
   11d20:	31 96       	adiw	r30, 0x01	; 1
   11d22:	8e 01       	movw	r16, r28
   11d24:	0f 5f       	subi	r16, 0xFF	; 255
   11d26:	1f 4f       	sbci	r17, 0xFF	; 255
   11d28:	ad b7       	in	r26, 0x3d	; 61
   11d2a:	be b7       	in	r27, 0x3e	; 62
   11d2c:	12 96       	adiw	r26, 0x02	; 2
   11d2e:	1c 93       	st	X, r17
   11d30:	0e 93       	st	-X, r16
   11d32:	11 97       	sbiw	r26, 0x01	; 1
   11d34:	8a e2       	ldi	r24, 0x2A	; 42
   11d36:	95 e1       	ldi	r25, 0x15	; 21
   11d38:	93 83       	std	Z+3, r25	; 0x03
   11d3a:	82 83       	std	Z+2, r24	; 0x02
   11d3c:	80 91 4e 02 	lds	r24, 0x024E
   11d40:	90 e0       	ldi	r25, 0x00	; 0
   11d42:	01 96       	adiw	r24, 0x01	; 1
   11d44:	95 83       	std	Z+5, r25	; 0x05
   11d46:	84 83       	std	Z+4, r24	; 0x04
   11d48:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11d4c:	8d b7       	in	r24, 0x3d	; 61
   11d4e:	9e b7       	in	r25, 0x3e	; 62
   11d50:	06 96       	adiw	r24, 0x06	; 6
   11d52:	0f b6       	in	r0, 0x3f	; 63
   11d54:	f8 94       	cli
   11d56:	9e bf       	out	0x3e, r25	; 62
   11d58:	0f be       	out	0x3f, r0	; 63
   11d5a:	8d bf       	out	0x3d, r24	; 61
   11d5c:	83 e0       	ldi	r24, 0x03	; 3
   11d5e:	61 e0       	ldi	r22, 0x01	; 1
   11d60:	a8 01       	movw	r20, r16
   11d62:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11d66:	84 e0       	ldi	r24, 0x04	; 4
   11d68:	61 e0       	ldi	r22, 0x01	; 1
   11d6a:	4d e1       	ldi	r20, 0x1D	; 29
   11d6c:	55 e1       	ldi	r21, 0x15	; 21
   11d6e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11d72:	84 e0       	ldi	r24, 0x04	; 4
   11d74:	08 c0       	rjmp	.+16     	; 0x11d86 <FMenuSettingHeader+0x2ac>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
   11d76:	81 e0       	ldi	r24, 0x01	; 1
   11d78:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   11d7c:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11d80:	83 32       	cpi	r24, 0x23	; 35
   11d82:	21 f4       	brne	.+8      	; 0x11d8c <FMenuSettingHeader+0x2b2>
   11d84:	87 e0       	ldi	r24, 0x07	; 7
   11d86:	80 93 4f 02 	sts	0x024F, r24
   11d8a:	42 c0       	rjmp	.+132    	; 0x11e10 <FMenuSettingHeader+0x336>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11d8c:	8a 32       	cpi	r24, 0x2A	; 42
   11d8e:	09 f0       	breq	.+2      	; 0x11d92 <FMenuSettingHeader+0x2b8>
   11d90:	3f c0       	rjmp	.+126    	; 0x11e10 <FMenuSettingHeader+0x336>
   11d92:	37 c0       	rjmp	.+110    	; 0x11e02 <FMenuSettingHeader+0x328>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11d94:	ad b7       	in	r26, 0x3d	; 61
   11d96:	be b7       	in	r27, 0x3e	; 62
   11d98:	18 97       	sbiw	r26, 0x08	; 8
   11d9a:	0f b6       	in	r0, 0x3f	; 63
   11d9c:	f8 94       	cli
   11d9e:	be bf       	out	0x3e, r27	; 62
   11da0:	0f be       	out	0x3f, r0	; 63
   11da2:	ad bf       	out	0x3d, r26	; 61
   11da4:	ed b7       	in	r30, 0x3d	; 61
   11da6:	fe b7       	in	r31, 0x3e	; 62
   11da8:	31 96       	adiw	r30, 0x01	; 1
   11daa:	8e 01       	movw	r16, r28
   11dac:	0b 5e       	subi	r16, 0xEB	; 235
   11dae:	1f 4f       	sbci	r17, 0xFF	; 255
   11db0:	12 96       	adiw	r26, 0x02	; 2
   11db2:	1c 93       	st	X, r17
   11db4:	0e 93       	st	-X, r16
   11db6:	11 97       	sbiw	r26, 0x01	; 1
   11db8:	88 e1       	ldi	r24, 0x18	; 24
   11dba:	95 e1       	ldi	r25, 0x15	; 21
   11dbc:	93 83       	std	Z+3, r25	; 0x03
   11dbe:	82 83       	std	Z+2, r24	; 0x02
   11dc0:	8b e9       	ldi	r24, 0x9B	; 155
   11dc2:	98 e0       	ldi	r25, 0x08	; 8
   11dc4:	95 83       	std	Z+5, r25	; 0x05
   11dc6:	84 83       	std	Z+4, r24	; 0x04
   11dc8:	8c ea       	ldi	r24, 0xAC	; 172
   11dca:	97 e0       	ldi	r25, 0x07	; 7
   11dcc:	97 83       	std	Z+7, r25	; 0x07
   11dce:	86 83       	std	Z+6, r24	; 0x06
   11dd0:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   11dd4:	8d b7       	in	r24, 0x3d	; 61
   11dd6:	9e b7       	in	r25, 0x3e	; 62
   11dd8:	08 96       	adiw	r24, 0x08	; 8
   11dda:	0f b6       	in	r0, 0x3f	; 63
   11ddc:	f8 94       	cli
   11dde:	9e bf       	out	0x3e, r25	; 62
   11de0:	0f be       	out	0x3f, r0	; 63
   11de2:	8d bf       	out	0x3d, r24	; 61
   11de4:	80 91 4e 02 	lds	r24, 0x024E
   11de8:	29 e2       	ldi	r18, 0x29	; 41
   11dea:	82 9f       	mul	r24, r18
   11dec:	c0 01       	movw	r24, r0
   11dee:	11 24       	eor	r1, r1
   11df0:	89 5d       	subi	r24, 0xD9	; 217
   11df2:	9d 4f       	sbci	r25, 0xFD	; 253
   11df4:	b8 01       	movw	r22, r16
   11df6:	48 e2       	ldi	r20, 0x28	; 40
   11df8:	50 e0       	ldi	r21, 0x00	; 0
   11dfa:	2a e4       	ldi	r18, 0x4A	; 74
   11dfc:	33 e1       	ldi	r19, 0x13	; 19
   11dfe:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
   11e02:	10 92 4f 02 	sts	0x024F, r1
   11e06:	04 c0       	rjmp	.+8      	; 0x11e10 <FMenuSettingHeader+0x336>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11e08:	10 92 4f 02 	sts	0x024F, r1
   11e0c:	81 e0       	ldi	r24, 0x01	; 1
   11e0e:	01 c0       	rjmp	.+2      	; 0x11e12 <FMenuSettingHeader+0x338>
   11e10:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
   11e12:	ca 5b       	subi	r28, 0xBA	; 186
   11e14:	df 4f       	sbci	r29, 0xFF	; 255
   11e16:	0f b6       	in	r0, 0x3f	; 63
   11e18:	f8 94       	cli
   11e1a:	de bf       	out	0x3e, r29	; 62
   11e1c:	0f be       	out	0x3f, r0	; 63
   11e1e:	cd bf       	out	0x3d, r28	; 61
   11e20:	cf 91       	pop	r28
   11e22:	df 91       	pop	r29
   11e24:	1f 91       	pop	r17
   11e26:	0f 91       	pop	r16
   11e28:	ef 90       	pop	r14
   11e2a:	08 95       	ret

00011e2c <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
   11e2c:	80 91 50 02 	lds	r24, 0x0250
   11e30:	83 30       	cpi	r24, 0x03	; 3
   11e32:	09 f4       	brne	.+2      	; 0x11e36 <FMenuAdminSettings+0xa>
   11e34:	6e c0       	rjmp	.+220    	; 0x11f12 <FMenuAdminSettings+0xe6>
   11e36:	84 30       	cpi	r24, 0x04	; 4
   11e38:	30 f4       	brcc	.+12     	; 0x11e46 <FMenuAdminSettings+0x1a>
   11e3a:	81 30       	cpi	r24, 0x01	; 1
   11e3c:	e9 f1       	breq	.+122    	; 0x11eb8 <FMenuAdminSettings+0x8c>
   11e3e:	82 30       	cpi	r24, 0x02	; 2
   11e40:	08 f0       	brcs	.+2      	; 0x11e44 <FMenuAdminSettings+0x18>
   11e42:	64 c0       	rjmp	.+200    	; 0x11f0c <FMenuAdminSettings+0xe0>
   11e44:	0d c0       	rjmp	.+26     	; 0x11e60 <FMenuAdminSettings+0x34>
   11e46:	85 30       	cpi	r24, 0x05	; 5
   11e48:	09 f4       	brne	.+2      	; 0x11e4c <FMenuAdminSettings+0x20>
   11e4a:	66 c0       	rjmp	.+204    	; 0x11f18 <FMenuAdminSettings+0xec>
   11e4c:	85 30       	cpi	r24, 0x05	; 5
   11e4e:	08 f4       	brcc	.+2      	; 0x11e52 <FMenuAdminSettings+0x26>
   11e50:	6a c0       	rjmp	.+212    	; 0x11f26 <FMenuAdminSettings+0xfa>
   11e52:	86 30       	cpi	r24, 0x06	; 6
   11e54:	09 f4       	brne	.+2      	; 0x11e58 <FMenuAdminSettings+0x2c>
   11e56:	63 c0       	rjmp	.+198    	; 0x11f1e <FMenuAdminSettings+0xf2>
   11e58:	87 30       	cpi	r24, 0x07	; 7
   11e5a:	09 f0       	breq	.+2      	; 0x11e5e <FMenuAdminSettings+0x32>
   11e5c:	6c c0       	rjmp	.+216    	; 0x11f36 <FMenuAdminSettings+0x10a>
   11e5e:	67 c0       	rjmp	.+206    	; 0x11f2e <FMenuAdminSettings+0x102>
	 case asInitMenu:
          lcd_clear();
   11e60:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  if (IFType==IT_SLAVE){
   11e64:	80 91 00 01 	lds	r24, 0x0100
   11e68:	81 30       	cpi	r24, 0x01	; 1
   11e6a:	51 f4       	brne	.+20     	; 0x11e80 <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
   11e6c:	61 e0       	ldi	r22, 0x01	; 1
   11e6e:	43 e2       	ldi	r20, 0x23	; 35
   11e70:	56 e1       	ldi	r21, 0x16	; 22
   11e72:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
   11e76:	82 e0       	ldi	r24, 0x02	; 2
   11e78:	61 e0       	ldi	r22, 0x01	; 1
   11e7a:	4e e0       	ldi	r20, 0x0E	; 14
   11e7c:	56 e1       	ldi	r21, 0x16	; 22
   11e7e:	0c c0       	rjmp	.+24     	; 0x11e98 <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
   11e80:	82 30       	cpi	r24, 0x02	; 2
   11e82:	61 f4       	brne	.+24     	; 0x11e9c <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
   11e84:	81 e0       	ldi	r24, 0x01	; 1
   11e86:	61 e0       	ldi	r22, 0x01	; 1
   11e88:	49 ef       	ldi	r20, 0xF9	; 249
   11e8a:	55 e1       	ldi	r21, 0x15	; 21
   11e8c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
   11e90:	82 e0       	ldi	r24, 0x02	; 2
   11e92:	61 e0       	ldi	r22, 0x01	; 1
   11e94:	44 ee       	ldi	r20, 0xE4	; 228
   11e96:	55 e1       	ldi	r21, 0x15	; 21
   11e98:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
   11e9c:	83 e0       	ldi	r24, 0x03	; 3
   11e9e:	61 e0       	ldi	r22, 0x01	; 1
   11ea0:	4f ec       	ldi	r20, 0xCF	; 207
   11ea2:	55 e1       	ldi	r21, 0x15	; 21
   11ea4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
   11ea8:	84 e0       	ldi	r24, 0x04	; 4
   11eaa:	61 e0       	ldi	r22, 0x01	; 1
   11eac:	48 ec       	ldi	r20, 0xC8	; 200
   11eae:	55 e1       	ldi	r21, 0x15	; 21
   11eb0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
   11eb4:	81 e0       	ldi	r24, 0x01	; 1
   11eb6:	27 c0       	rjmp	.+78     	; 0x11f06 <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
   11eb8:	81 e0       	ldi	r24, 0x01	; 1
   11eba:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   11ebe:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
   11ec2:	98 2f       	mov	r25, r24
		  switch(KeyChar){
   11ec4:	82 33       	cpi	r24, 0x32	; 50
   11ec6:	61 f0       	breq	.+24     	; 0x11ee0 <FMenuAdminSettings+0xb4>
   11ec8:	83 33       	cpi	r24, 0x33	; 51
   11eca:	28 f4       	brcc	.+10     	; 0x11ed6 <FMenuAdminSettings+0xaa>
   11ecc:	8a 32       	cpi	r24, 0x2A	; 42
   11ece:	61 f0       	breq	.+24     	; 0x11ee8 <FMenuAdminSettings+0xbc>
   11ed0:	81 33       	cpi	r24, 0x31	; 49
   11ed2:	69 f4       	brne	.+26     	; 0x11eee <FMenuAdminSettings+0xc2>
   11ed4:	03 c0       	rjmp	.+6      	; 0x11edc <FMenuAdminSettings+0xb0>
   11ed6:	83 33       	cpi	r24, 0x33	; 51
   11ed8:	51 f4       	brne	.+20     	; 0x11eee <FMenuAdminSettings+0xc2>
   11eda:	04 c0       	rjmp	.+8      	; 0x11ee4 <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
   11edc:	82 e0       	ldi	r24, 0x02	; 2
   11ede:	05 c0       	rjmp	.+10     	; 0x11eea <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
   11ee0:	83 e0       	ldi	r24, 0x03	; 3
   11ee2:	03 c0       	rjmp	.+6      	; 0x11eea <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
   11ee4:	84 e0       	ldi	r24, 0x04	; 4
   11ee6:	01 c0       	rjmp	.+2      	; 0x11eea <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
   11ee8:	87 e0       	ldi	r24, 0x07	; 7
   11eea:	80 93 50 02 	sts	0x0250, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
   11eee:	80 91 00 01 	lds	r24, 0x0100
   11ef2:	81 30       	cpi	r24, 0x01	; 1
   11ef4:	01 f5       	brne	.+64     	; 0x11f36 <FMenuAdminSettings+0x10a>
			  switch(KeyChar){
   11ef6:	94 33       	cpi	r25, 0x34	; 52
   11ef8:	19 f0       	breq	.+6      	; 0x11f00 <FMenuAdminSettings+0xd4>
   11efa:	95 33       	cpi	r25, 0x35	; 53
   11efc:	e1 f4       	brne	.+56     	; 0x11f36 <FMenuAdminSettings+0x10a>
   11efe:	02 c0       	rjmp	.+4      	; 0x11f04 <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
   11f00:	85 e0       	ldi	r24, 0x05	; 5
   11f02:	01 c0       	rjmp	.+2      	; 0x11f06 <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
   11f04:	86 e0       	ldi	r24, 0x06	; 6
   11f06:	80 93 50 02 	sts	0x0250, r24
   11f0a:	0f c0       	rjmp	.+30     	; 0x11f2a <FMenuAdminSettings+0xfe>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
   11f0c:	0e 94 6d 8d 	call	0x11ada	; 0x11ada <FMenuSettingHeader>
   11f10:	08 c0       	rjmp	.+16     	; 0x11f22 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
   11f12:	0e 94 c4 8b 	call	0x11788	; 0x11788 <FMenuSettingFooter>
   11f16:	05 c0       	rjmp	.+10     	; 0x11f22 <FMenuAdminSettings+0xf6>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
   11f18:	0e 94 ef 71 	call	0xe3de	; 0xe3de <FMenuSettingClientIP>
   11f1c:	02 c0       	rjmp	.+4      	; 0x11f22 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
   11f1e:	0e 94 66 6f 	call	0xdecc	; 0xdecc <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
   11f22:	81 30       	cpi	r24, 0x01	; 1
   11f24:	41 f4       	brne	.+16     	; 0x11f36 <FMenuAdminSettings+0x10a>
   11f26:	10 92 50 02 	sts	0x0250, r1
   11f2a:	80 e0       	ldi	r24, 0x00	; 0
   11f2c:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
   11f2e:	10 92 50 02 	sts	0x0250, r1
   11f32:	81 e0       	ldi	r24, 0x01	; 1
   11f34:	08 95       	ret
   11f36:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   11f38:	08 95       	ret

00011f3a <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
   11f3a:	ef 92       	push	r14
   11f3c:	ff 92       	push	r15
   11f3e:	0f 93       	push	r16
   11f40:	1f 93       	push	r17
   11f42:	df 93       	push	r29
   11f44:	cf 93       	push	r28
   11f46:	cd b7       	in	r28, 0x3d	; 61
   11f48:	de b7       	in	r29, 0x3e	; 62
   11f4a:	e2 97       	sbiw	r28, 0x32	; 50
   11f4c:	0f b6       	in	r0, 0x3f	; 63
   11f4e:	f8 94       	cli
   11f50:	de bf       	out	0x3e, r29	; 62
   11f52:	0f be       	out	0x3f, r0	; 63
   11f54:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
   11f56:	80 91 55 02 	lds	r24, 0x0255
   11f5a:	e8 2f       	mov	r30, r24
   11f5c:	f0 e0       	ldi	r31, 0x00	; 0
   11f5e:	e1 31       	cpi	r30, 0x11	; 17
   11f60:	f1 05       	cpc	r31, r1
   11f62:	08 f0       	brcs	.+2      	; 0x11f66 <FMenuMaster+0x2c>
   11f64:	ed c1       	rjmp	.+986    	; 0x12340 <FMenuMaster+0x406>
   11f66:	e4 54       	subi	r30, 0x44	; 68
   11f68:	ff 4f       	sbci	r31, 0xFF	; 255
   11f6a:	ee 0f       	add	r30, r30
   11f6c:	ff 1f       	adc	r31, r31
   11f6e:	05 90       	lpm	r0, Z+
   11f70:	f4 91       	lpm	r31, Z+
   11f72:	e0 2d       	mov	r30, r0
   11f74:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
   11f76:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
   11f7a:	81 e0       	ldi	r24, 0x01	; 1
   11f7c:	61 e0       	ldi	r22, 0x01	; 1
   11f7e:	49 e9       	ldi	r20, 0x99	; 153
   11f80:	58 e1       	ldi	r21, 0x18	; 24
   11f82:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
   11f86:	82 e0       	ldi	r24, 0x02	; 2
   11f88:	61 e0       	ldi	r22, 0x01	; 1
   11f8a:	44 e8       	ldi	r20, 0x84	; 132
   11f8c:	58 e1       	ldi	r21, 0x18	; 24
   11f8e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
   11f92:	83 e0       	ldi	r24, 0x03	; 3
   11f94:	61 e0       	ldi	r22, 0x01	; 1
   11f96:	4f e6       	ldi	r20, 0x6F	; 111
   11f98:	58 e1       	ldi	r21, 0x18	; 24
   11f9a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
   11f9e:	84 e0       	ldi	r24, 0x04	; 4
   11fa0:	61 e0       	ldi	r22, 0x01	; 1
   11fa2:	4a e5       	ldi	r20, 0x5A	; 90
   11fa4:	58 e1       	ldi	r21, 0x18	; 24
   11fa6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>

		  //uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
   11faa:	81 e0       	ldi	r24, 0x01	; 1
   11fac:	f3 c0       	rjmp	.+486    	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
   11fae:	81 e0       	ldi	r24, 0x01	; 1
   11fb0:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11fb4:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
          switch(KeyChar){
   11fb8:	81 33       	cpi	r24, 0x31	; 49
   11fba:	09 f4       	brne	.+2      	; 0x11fbe <FMenuMaster+0x84>
   11fbc:	ea c0       	rjmp	.+468    	; 0x12192 <FMenuMaster+0x258>
   11fbe:	82 33       	cpi	r24, 0x32	; 50
   11fc0:	21 f0       	breq	.+8      	; 0x11fca <FMenuMaster+0x90>
   11fc2:	8a 32       	cpi	r24, 0x2A	; 42
   11fc4:	09 f0       	breq	.+2      	; 0x11fc8 <FMenuMaster+0x8e>
   11fc6:	bc c1       	rjmp	.+888    	; 0x12340 <FMenuMaster+0x406>
   11fc8:	b5 c1       	rjmp	.+874    	; 0x12334 <FMenuMaster+0x3fa>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
   11fca:	8e e0       	ldi	r24, 0x0E	; 14
   11fcc:	e3 c0       	rjmp	.+454    	; 0x12194 <FMenuMaster+0x25a>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
   11fce:	10 92 55 02 	sts	0x0255, r1
   11fd2:	b6 c1       	rjmp	.+876    	; 0x12340 <FMenuMaster+0x406>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
   11fd4:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
   11fd8:	81 e0       	ldi	r24, 0x01	; 1
   11fda:	61 e0       	ldi	r22, 0x01	; 1
   11fdc:	45 e4       	ldi	r20, 0x45	; 69
   11fde:	58 e1       	ldi	r21, 0x18	; 24
   11fe0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
   11fe4:	82 e0       	ldi	r24, 0x02	; 2
   11fe6:	61 e0       	ldi	r22, 0x01	; 1
   11fe8:	40 e3       	ldi	r20, 0x30	; 48
   11fea:	58 e1       	ldi	r21, 0x18	; 24
   11fec:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
   11ff0:	84 e0       	ldi	r24, 0x04	; 4
   11ff2:	64 e0       	ldi	r22, 0x04	; 4
   11ff4:	4b e1       	ldi	r20, 0x1B	; 27
   11ff6:	58 e1       	ldi	r21, 0x18	; 24
   11ff8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
   11ffc:	00 d0       	rcall	.+0      	; 0x11ffe <FMenuMaster+0xc4>
   11ffe:	00 d0       	rcall	.+0      	; 0x12000 <FMenuMaster+0xc6>
   12000:	8b e9       	ldi	r24, 0x9B	; 155
   12002:	95 e0       	ldi	r25, 0x05	; 5
   12004:	ad b7       	in	r26, 0x3d	; 61
   12006:	be b7       	in	r27, 0x3e	; 62
   12008:	12 96       	adiw	r26, 0x02	; 2
   1200a:	9c 93       	st	X, r25
   1200c:	8e 93       	st	-X, r24
   1200e:	11 97       	sbiw	r26, 0x01	; 1
   12010:	8a e1       	ldi	r24, 0x1A	; 26
   12012:	98 e1       	ldi	r25, 0x18	; 24
   12014:	14 96       	adiw	r26, 0x04	; 4
   12016:	9c 93       	st	X, r25
   12018:	8e 93       	st	-X, r24
   1201a:	13 97       	sbiw	r26, 0x03	; 3
   1201c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
   12020:	83 e0       	ldi	r24, 0x03	; 3
   12022:	80 93 55 02 	sts	0x0255, r24
   12026:	80 e0       	ldi	r24, 0x00	; 0
   12028:	0f 90       	pop	r0
   1202a:	0f 90       	pop	r0
   1202c:	0f 90       	pop	r0
   1202e:	0f 90       	pop	r0
   12030:	88 c1       	rjmp	.+784    	; 0x12342 <FMenuMaster+0x408>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
   12032:	81 e0       	ldi	r24, 0x01	; 1
   12034:	62 e0       	ldi	r22, 0x02	; 2
   12036:	41 e0       	ldi	r20, 0x01	; 1
   12038:	2b e9       	ldi	r18, 0x9B	; 155
   1203a:	35 e0       	ldi	r19, 0x05	; 5
   1203c:	00 e0       	ldi	r16, 0x00	; 0
   1203e:	10 e0       	ldi	r17, 0x00	; 0
   12040:	9a e0       	ldi	r25, 0x0A	; 10
   12042:	e9 2e       	mov	r14, r25
   12044:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  switch(uiResult){
   12048:	83 30       	cpi	r24, 0x03	; 3
   1204a:	49 f0       	breq	.+18     	; 0x1205e <FMenuMaster+0x124>
   1204c:	84 30       	cpi	r24, 0x04	; 4
   1204e:	08 f4       	brcc	.+2      	; 0x12052 <FMenuMaster+0x118>
   12050:	ef c0       	rjmp	.+478    	; 0x12230 <FMenuMaster+0x2f6>
   12052:	84 30       	cpi	r24, 0x04	; 4
   12054:	69 f0       	breq	.+26     	; 0x12070 <FMenuMaster+0x136>
   12056:	85 30       	cpi	r24, 0x05	; 5
   12058:	09 f0       	breq	.+2      	; 0x1205c <FMenuMaster+0x122>
   1205a:	72 c1       	rjmp	.+740    	; 0x12340 <FMenuMaster+0x406>
   1205c:	0e c0       	rjmp	.+28     	; 0x1207a <FMenuMaster+0x140>
		  case USER_OK:
               
			   //uart_printf(1,0,PSTR("GeniusCode: "));
			   //uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
   1205e:	80 e0       	ldi	r24, 0x00	; 0
   12060:	63 ec       	ldi	r22, 0xC3	; 195
   12062:	73 e0       	ldi	r23, 0x03	; 3
   12064:	4d e7       	ldi	r20, 0x7D	; 125
   12066:	58 e0       	ldi	r21, 0x08	; 8
   12068:	0e 94 b4 aa 	call	0x15568	; 0x15568 <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
   1206c:	84 e0       	ldi	r24, 0x04	; 4
   1206e:	92 c0       	rjmp	.+292    	; 0x12194 <FMenuMaster+0x25a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12070:	84 e0       	ldi	r24, 0x04	; 4
   12072:	61 e0       	ldi	r22, 0x01	; 1
   12074:	45 e0       	ldi	r20, 0x05	; 5
   12076:	58 e1       	ldi	r21, 0x18	; 24
   12078:	f0 c0       	rjmp	.+480    	; 0x1225a <FMenuMaster+0x320>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1207a:	84 e0       	ldi	r24, 0x04	; 4
   1207c:	61 e0       	ldi	r22, 0x01	; 1
   1207e:	40 ef       	ldi	r20, 0xF0	; 240
   12080:	57 e1       	ldi	r21, 0x17	; 23
   12082:	eb c0       	rjmp	.+470    	; 0x1225a <FMenuMaster+0x320>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
   12084:	00 d0       	rcall	.+0      	; 0x12086 <FMenuMaster+0x14c>
   12086:	00 d0       	rcall	.+0      	; 0x12088 <FMenuMaster+0x14e>
   12088:	00 d0       	rcall	.+0      	; 0x1208a <FMenuMaster+0x150>
   1208a:	ed b7       	in	r30, 0x3d	; 61
   1208c:	fe b7       	in	r31, 0x3e	; 62
   1208e:	31 96       	adiw	r30, 0x01	; 1
   12090:	8e 01       	movw	r16, r28
   12092:	05 5f       	subi	r16, 0xF5	; 245
   12094:	1f 4f       	sbci	r17, 0xFF	; 255
   12096:	ad b7       	in	r26, 0x3d	; 61
   12098:	be b7       	in	r27, 0x3e	; 62
   1209a:	12 96       	adiw	r26, 0x02	; 2
   1209c:	1c 93       	st	X, r17
   1209e:	0e 93       	st	-X, r16
   120a0:	11 97       	sbiw	r26, 0x01	; 1
   120a2:	8d ee       	ldi	r24, 0xED	; 237
   120a4:	97 e1       	ldi	r25, 0x17	; 23
   120a6:	93 83       	std	Z+3, r25	; 0x03
   120a8:	82 83       	std	Z+2, r24	; 0x02
   120aa:	83 ec       	ldi	r24, 0xC3	; 195
   120ac:	93 e0       	ldi	r25, 0x03	; 3
   120ae:	95 83       	std	Z+5, r25	; 0x05
   120b0:	84 83       	std	Z+4, r24	; 0x04
   120b2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  RemoveChar(PDate,'/');
   120b6:	ed b7       	in	r30, 0x3d	; 61
   120b8:	fe b7       	in	r31, 0x3e	; 62
   120ba:	36 96       	adiw	r30, 0x06	; 6
   120bc:	0f b6       	in	r0, 0x3f	; 63
   120be:	f8 94       	cli
   120c0:	fe bf       	out	0x3e, r31	; 62
   120c2:	0f be       	out	0x3f, r0	; 63
   120c4:	ed bf       	out	0x3d, r30	; 61
   120c6:	c8 01       	movw	r24, r16
   120c8:	6f e2       	ldi	r22, 0x2F	; 47
   120ca:	0e 94 12 36 	call	0x6c24	; 0x6c24 <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
   120ce:	c8 01       	movw	r24, r16
   120d0:	6b e9       	ldi	r22, 0x9B	; 155
   120d2:	75 e0       	ldi	r23, 0x05	; 5
   120d4:	0e 94 2f 6f 	call	0xde5e	; 0xde5e <ValidateGeniusCode>
   120d8:	81 30       	cpi	r24, 0x01	; 1
   120da:	09 f0       	breq	.+2      	; 0x120de <FMenuMaster+0x1a4>
   120dc:	44 c0       	rjmp	.+136    	; 0x12166 <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
   120de:	00 d0       	rcall	.+0      	; 0x120e0 <FMenuMaster+0x1a6>
   120e0:	00 d0       	rcall	.+0      	; 0x120e2 <FMenuMaster+0x1a8>
   120e2:	00 d0       	rcall	.+0      	; 0x120e4 <FMenuMaster+0x1aa>
   120e4:	ed b7       	in	r30, 0x3d	; 61
   120e6:	fe b7       	in	r31, 0x3e	; 62
   120e8:	31 96       	adiw	r30, 0x01	; 1
   120ea:	8e 01       	movw	r16, r28
   120ec:	0f 5f       	subi	r16, 0xFF	; 255
   120ee:	1f 4f       	sbci	r17, 0xFF	; 255
   120f0:	ad b7       	in	r26, 0x3d	; 61
   120f2:	be b7       	in	r27, 0x3e	; 62
   120f4:	12 96       	adiw	r26, 0x02	; 2
   120f6:	1c 93       	st	X, r17
   120f8:	0e 93       	st	-X, r16
   120fa:	11 97       	sbiw	r26, 0x01	; 1
   120fc:	8a ee       	ldi	r24, 0xEA	; 234
   120fe:	97 e1       	ldi	r25, 0x17	; 23
   12100:	93 83       	std	Z+3, r25	; 0x03
   12102:	82 83       	std	Z+2, r24	; 0x02
   12104:	8d e7       	ldi	r24, 0x7D	; 125
   12106:	98 e0       	ldi	r25, 0x08	; 8
   12108:	95 83       	std	Z+5, r25	; 0x05
   1210a:	84 83       	std	Z+4, r24	; 0x04
   1210c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
   12110:	ed b7       	in	r30, 0x3d	; 61
   12112:	fe b7       	in	r31, 0x3e	; 62
   12114:	36 96       	adiw	r30, 0x06	; 6
   12116:	0f b6       	in	r0, 0x3f	; 63
   12118:	f8 94       	cli
   1211a:	fe bf       	out	0x3e, r31	; 62
   1211c:	0f be       	out	0x3f, r0	; 63
   1211e:	ed bf       	out	0x3d, r30	; 61
   12120:	c8 01       	movw	r24, r16
   12122:	6a e3       	ldi	r22, 0x3A	; 58
   12124:	0e 94 12 36 	call	0x6c24	; 0x6c24 <RemoveChar>
   12128:	00 d0       	rcall	.+0      	; 0x1212a <FMenuMaster+0x1f0>
   1212a:	00 d0       	rcall	.+0      	; 0x1212c <FMenuMaster+0x1f2>
   1212c:	b9 ed       	ldi	r27, 0xD9	; 217
   1212e:	eb 2e       	mov	r14, r27
   12130:	b7 e0       	ldi	r27, 0x07	; 7
   12132:	fb 2e       	mov	r15, r27
   12134:	ad b7       	in	r26, 0x3d	; 61
   12136:	be b7       	in	r27, 0x3e	; 62
   12138:	12 96       	adiw	r26, 0x02	; 2
   1213a:	fc 92       	st	X, r15
   1213c:	ee 92       	st	-X, r14
   1213e:	11 97       	sbiw	r26, 0x01	; 1
   12140:	89 ee       	ldi	r24, 0xE9	; 233
   12142:	97 e1       	ldi	r25, 0x17	; 23
   12144:	14 96       	adiw	r26, 0x04	; 4
   12146:	9c 93       	st	X, r25
   12148:	8e 93       	st	-X, r24
   1214a:	13 97       	sbiw	r26, 0x03	; 3
   1214c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
   12150:	0f 90       	pop	r0
   12152:	0f 90       	pop	r0
   12154:	0f 90       	pop	r0
   12156:	0f 90       	pop	r0
   12158:	c8 01       	movw	r24, r16
   1215a:	6b e9       	ldi	r22, 0x9B	; 155
   1215c:	75 e0       	ldi	r23, 0x05	; 5
   1215e:	a7 01       	movw	r20, r14
   12160:	0e 94 d3 36 	call	0x6da6	; 0x6da6 <GenerateKeyStamp>
   12164:	d2 c0       	rjmp	.+420    	; 0x1230a <FMenuMaster+0x3d0>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
   12166:	85 e0       	ldi	r24, 0x05	; 5
   12168:	15 c0       	rjmp	.+42     	; 0x12194 <FMenuMaster+0x25a>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1216a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1216c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1216e:	81 e0       	ldi	r24, 0x01	; 1
   12170:	80 93 be 01 	sts	0x01BE, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
   12174:	83 e0       	ldi	r24, 0x03	; 3
   12176:	61 e0       	ldi	r22, 0x01	; 1
   12178:	44 ed       	ldi	r20, 0xD4	; 212
   1217a:	57 e1       	ldi	r21, 0x17	; 23
   1217c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          TimDisplay=0; 
   12180:	10 92 94 01 	sts	0x0194, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
   12184:	86 e0       	ldi	r24, 0x06	; 6
   12186:	06 c0       	rjmp	.+12     	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
   12188:	80 91 94 01 	lds	r24, 0x0194
   1218c:	86 30       	cpi	r24, 0x06	; 6
   1218e:	08 f4       	brcc	.+2      	; 0x12192 <FMenuMaster+0x258>
   12190:	d7 c0       	rjmp	.+430    	; 0x12340 <FMenuMaster+0x406>
   12192:	82 e0       	ldi	r24, 0x02	; 2
   12194:	80 93 55 02 	sts	0x0255, r24
   12198:	d3 c0       	rjmp	.+422    	; 0x12340 <FMenuMaster+0x406>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
   1219a:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
   1219e:	00 d0       	rcall	.+0      	; 0x121a0 <FMenuMaster+0x266>
   121a0:	00 d0       	rcall	.+0      	; 0x121a2 <FMenuMaster+0x268>
   121a2:	00 d0       	rcall	.+0      	; 0x121a4 <FMenuMaster+0x26a>
   121a4:	ed b7       	in	r30, 0x3d	; 61
   121a6:	fe b7       	in	r31, 0x3e	; 62
   121a8:	31 96       	adiw	r30, 0x01	; 1
   121aa:	8e 01       	movw	r16, r28
   121ac:	01 5e       	subi	r16, 0xE1	; 225
   121ae:	1f 4f       	sbci	r17, 0xFF	; 255
   121b0:	ad b7       	in	r26, 0x3d	; 61
   121b2:	be b7       	in	r27, 0x3e	; 62
   121b4:	12 96       	adiw	r26, 0x02	; 2
   121b6:	1c 93       	st	X, r17
   121b8:	0e 93       	st	-X, r16
   121ba:	11 97       	sbiw	r26, 0x01	; 1
   121bc:	86 ec       	ldi	r24, 0xC6	; 198
   121be:	97 e1       	ldi	r25, 0x17	; 23
   121c0:	93 83       	std	Z+3, r25	; 0x03
   121c2:	82 83       	std	Z+2, r24	; 0x02
   121c4:	89 ed       	ldi	r24, 0xD9	; 217
   121c6:	97 e0       	ldi	r25, 0x07	; 7
   121c8:	95 83       	std	Z+5, r25	; 0x05
   121ca:	84 83       	std	Z+4, r24	; 0x04
   121cc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   121d0:	ed b7       	in	r30, 0x3d	; 61
   121d2:	fe b7       	in	r31, 0x3e	; 62
   121d4:	36 96       	adiw	r30, 0x06	; 6
   121d6:	0f b6       	in	r0, 0x3f	; 63
   121d8:	f8 94       	cli
   121da:	fe bf       	out	0x3e, r31	; 62
   121dc:	0f be       	out	0x3f, r0	; 63
   121de:	ed bf       	out	0x3d, r30	; 61
   121e0:	81 e0       	ldi	r24, 0x01	; 1
   121e2:	61 e0       	ldi	r22, 0x01	; 1
   121e4:	a8 01       	movw	r20, r16
   121e6:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
   121ea:	82 e0       	ldi	r24, 0x02	; 2
   121ec:	61 e0       	ldi	r22, 0x01	; 1
   121ee:	41 eb       	ldi	r20, 0xB1	; 177
   121f0:	57 e1       	ldi	r21, 0x17	; 23
   121f2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
   121f6:	83 e0       	ldi	r24, 0x03	; 3
   121f8:	61 e0       	ldi	r22, 0x01	; 1
   121fa:	4c e9       	ldi	r20, 0x9C	; 156
   121fc:	57 e1       	ldi	r21, 0x17	; 23
   121fe:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12202:	84 e0       	ldi	r24, 0x04	; 4
   12204:	61 e0       	ldi	r22, 0x01	; 1
   12206:	47 e8       	ldi	r20, 0x87	; 135
   12208:	57 e1       	ldi	r21, 0x17	; 23
   1220a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
   1220e:	88 e0       	ldi	r24, 0x08	; 8
   12210:	c1 cf       	rjmp	.-126    	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
   12212:	81 e0       	ldi	r24, 0x01	; 1
   12214:	63 e0       	ldi	r22, 0x03	; 3
   12216:	41 e0       	ldi	r20, 0x01	; 1
   12218:	24 e7       	ldi	r18, 0x74	; 116
   1221a:	3e e0       	ldi	r19, 0x0E	; 14
   1221c:	00 e0       	ldi	r16, 0x00	; 0
   1221e:	10 e0       	ldi	r17, 0x00	; 0
   12220:	aa e0       	ldi	r26, 0x0A	; 10
   12222:	ea 2e       	mov	r14, r26
   12224:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  switch(uiResult){
   12228:	83 30       	cpi	r24, 0x03	; 3
   1222a:	61 f0       	breq	.+24     	; 0x12244 <FMenuMaster+0x30a>
   1222c:	84 30       	cpi	r24, 0x04	; 4
   1222e:	20 f4       	brcc	.+8      	; 0x12238 <FMenuMaster+0x2fe>
   12230:	81 30       	cpi	r24, 0x01	; 1
   12232:	09 f0       	breq	.+2      	; 0x12236 <FMenuMaster+0x2fc>
   12234:	85 c0       	rjmp	.+266    	; 0x12340 <FMenuMaster+0x406>
   12236:	7e c0       	rjmp	.+252    	; 0x12334 <FMenuMaster+0x3fa>
   12238:	84 30       	cpi	r24, 0x04	; 4
   1223a:	31 f0       	breq	.+12     	; 0x12248 <FMenuMaster+0x30e>
   1223c:	85 30       	cpi	r24, 0x05	; 5
   1223e:	09 f0       	breq	.+2      	; 0x12242 <FMenuMaster+0x308>
   12240:	7f c0       	rjmp	.+254    	; 0x12340 <FMenuMaster+0x406>
   12242:	07 c0       	rjmp	.+14     	; 0x12252 <FMenuMaster+0x318>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
   12244:	89 e0       	ldi	r24, 0x09	; 9
   12246:	a6 cf       	rjmp	.-180    	; 0x12194 <FMenuMaster+0x25a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12248:	84 e0       	ldi	r24, 0x04	; 4
   1224a:	61 e0       	ldi	r22, 0x01	; 1
   1224c:	42 e7       	ldi	r20, 0x72	; 114
   1224e:	57 e1       	ldi	r21, 0x17	; 23
   12250:	04 c0       	rjmp	.+8      	; 0x1225a <FMenuMaster+0x320>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12252:	84 e0       	ldi	r24, 0x04	; 4
   12254:	61 e0       	ldi	r22, 0x01	; 1
   12256:	4d e5       	ldi	r20, 0x5D	; 93
   12258:	57 e1       	ldi	r21, 0x17	; 23
   1225a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   1225e:	70 c0       	rjmp	.+224    	; 0x12340 <FMenuMaster+0x406>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
   12260:	89 ed       	ldi	r24, 0xD9	; 217
   12262:	97 e0       	ldi	r25, 0x07	; 7
   12264:	64 e7       	ldi	r22, 0x74	; 116
   12266:	7e e0       	ldi	r23, 0x0E	; 14
   12268:	0e 94 0d 6f 	call	0xde1a	; 0xde1a <ValidateRestoreCode>
   1226c:	81 30       	cpi	r24, 0x01	; 1
   1226e:	11 f4       	brne	.+4      	; 0x12274 <FMenuMaster+0x33a>
		      stMenuMaster=mmRestorePassword;
   12270:	8c e0       	ldi	r24, 0x0C	; 12
   12272:	90 cf       	rjmp	.-224    	; 0x12194 <FMenuMaster+0x25a>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
   12274:	8a e0       	ldi	r24, 0x0A	; 10
   12276:	8e cf       	rjmp	.-228    	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
   12278:	00 d0       	rcall	.+0      	; 0x1227a <FMenuMaster+0x340>
   1227a:	00 d0       	rcall	.+0      	; 0x1227c <FMenuMaster+0x342>
   1227c:	8e 01       	movw	r16, r28
   1227e:	0b 5e       	subi	r16, 0xEB	; 235
   12280:	1f 4f       	sbci	r17, 0xFF	; 255
   12282:	ad b7       	in	r26, 0x3d	; 61
   12284:	be b7       	in	r27, 0x3e	; 62
   12286:	12 96       	adiw	r26, 0x02	; 2
   12288:	1c 93       	st	X, r17
   1228a:	0e 93       	st	-X, r16
   1228c:	11 97       	sbiw	r26, 0x01	; 1
   1228e:	87 e5       	ldi	r24, 0x57	; 87
   12290:	97 e1       	ldi	r25, 0x17	; 23
   12292:	14 96       	adiw	r26, 0x04	; 4
   12294:	9c 93       	st	X, r25
   12296:	8e 93       	st	-X, r24
   12298:	13 97       	sbiw	r26, 0x03	; 3
   1229a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   1229e:	0f 90       	pop	r0
   122a0:	0f 90       	pop	r0
   122a2:	0f 90       	pop	r0
   122a4:	0f 90       	pop	r0
   122a6:	81 e0       	ldi	r24, 0x01	; 1
   122a8:	90 e0       	ldi	r25, 0x00	; 0
   122aa:	b8 01       	movw	r22, r16
   122ac:	4a e0       	ldi	r20, 0x0A	; 10
   122ae:	50 e0       	ldi	r21, 0x00	; 0
   122b0:	2a e4       	ldi	r18, 0x4A	; 74
   122b2:	33 e1       	ldi	r19, 0x13	; 19
   122b4:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
   122b8:	00 d0       	rcall	.+0      	; 0x122ba <FMenuMaster+0x380>
   122ba:	00 d0       	rcall	.+0      	; 0x122bc <FMenuMaster+0x382>
   122bc:	ed b7       	in	r30, 0x3d	; 61
   122be:	fe b7       	in	r31, 0x3e	; 62
   122c0:	12 83       	std	Z+2, r17	; 0x02
   122c2:	01 83       	std	Z+1, r16	; 0x01
   122c4:	81 e5       	ldi	r24, 0x51	; 81
   122c6:	97 e1       	ldi	r25, 0x17	; 23
   122c8:	94 83       	std	Z+4, r25	; 0x04
   122ca:	83 83       	std	Z+3, r24	; 0x03
   122cc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   122d0:	0f 90       	pop	r0
   122d2:	0f 90       	pop	r0
   122d4:	0f 90       	pop	r0
   122d6:	0f 90       	pop	r0
   122d8:	8b e0       	ldi	r24, 0x0B	; 11
   122da:	90 e0       	ldi	r25, 0x00	; 0
   122dc:	b8 01       	movw	r22, r16
   122de:	4a e0       	ldi	r20, 0x0A	; 10
   122e0:	50 e0       	ldi	r21, 0x00	; 0
   122e2:	2a e4       	ldi	r18, 0x4A	; 74
   122e4:	33 e1       	ldi	r19, 0x13	; 19
   122e6:	0e 94 18 b1 	call	0x16230	; 0x16230 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
   122ea:	8d e0       	ldi	r24, 0x0D	; 13
   122ec:	53 cf       	rjmp	.-346    	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
   122ee:	83 e0       	ldi	r24, 0x03	; 3
   122f0:	61 e0       	ldi	r22, 0x01	; 1
   122f2:	4f e3       	ldi	r20, 0x3F	; 63
   122f4:	57 e1       	ldi	r21, 0x17	; 23
   122f6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  TimDisplay=0;
   122fa:	10 92 94 01 	sts	0x0194, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
   122fe:	8b e0       	ldi	r24, 0x0B	; 11
   12300:	49 cf       	rjmp	.-366    	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
   12302:	80 91 94 01 	lds	r24, 0x0194
   12306:	86 30       	cpi	r24, 0x06	; 6
   12308:	d8 f0       	brcs	.+54     	; 0x12340 <FMenuMaster+0x406>
   1230a:	87 e0       	ldi	r24, 0x07	; 7
   1230c:	43 cf       	rjmp	.-378    	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
   1230e:	83 e0       	ldi	r24, 0x03	; 3
   12310:	61 e0       	ldi	r22, 0x01	; 1
   12312:	4d e2       	ldi	r20, 0x2D	; 45
   12314:	57 e1       	ldi	r21, 0x17	; 23
   12316:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1231a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1231c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1231e:	81 e0       	ldi	r24, 0x01	; 1
   12320:	80 93 be 01 	sts	0x01BE, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
   12324:	10 92 94 01 	sts	0x0194, r1
          stMenuMaster=mmDelayExit;
   12328:	8f e0       	ldi	r24, 0x0F	; 15
   1232a:	34 cf       	rjmp	.-408    	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
   1232c:	80 91 94 01 	lds	r24, 0x0194
   12330:	85 30       	cpi	r24, 0x05	; 5
   12332:	30 f0       	brcs	.+12     	; 0x12340 <FMenuMaster+0x406>
   12334:	80 e1       	ldi	r24, 0x10	; 16
   12336:	2e cf       	rjmp	.-420    	; 0x12194 <FMenuMaster+0x25a>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
   12338:	10 92 55 02 	sts	0x0255, r1
   1233c:	81 e0       	ldi	r24, 0x01	; 1
   1233e:	01 c0       	rjmp	.+2      	; 0x12342 <FMenuMaster+0x408>
   12340:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
   12342:	e2 96       	adiw	r28, 0x32	; 50
   12344:	0f b6       	in	r0, 0x3f	; 63
   12346:	f8 94       	cli
   12348:	de bf       	out	0x3e, r29	; 62
   1234a:	0f be       	out	0x3f, r0	; 63
   1234c:	cd bf       	out	0x3d, r28	; 61
   1234e:	cf 91       	pop	r28
   12350:	df 91       	pop	r29
   12352:	1f 91       	pop	r17
   12354:	0f 91       	pop	r16
   12356:	ff 90       	pop	r15
   12358:	ef 90       	pop	r14
   1235a:	08 95       	ret

0001235c <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
   1235c:	af 92       	push	r10
   1235e:	bf 92       	push	r11
   12360:	cf 92       	push	r12
   12362:	df 92       	push	r13
   12364:	ef 92       	push	r14
   12366:	0f 93       	push	r16
   12368:	1f 93       	push	r17
   1236a:	df 93       	push	r29
   1236c:	cf 93       	push	r28
   1236e:	cd b7       	in	r28, 0x3d	; 61
   12370:	de b7       	in	r29, 0x3e	; 62
   12372:	6e 97       	sbiw	r28, 0x1e	; 30
   12374:	0f b6       	in	r0, 0x3f	; 63
   12376:	f8 94       	cli
   12378:	de bf       	out	0x3e, r29	; 62
   1237a:	0f be       	out	0x3f, r0	; 63
   1237c:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,strPassword[10],PassStatus=MP_NONE;;
       char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];
       char uiResult;

     Result=MP_NONE;
     switch(stMenuPasword){
   1237e:	e0 90 61 02 	lds	r14, 0x0261
   12382:	81 e0       	ldi	r24, 0x01	; 1
   12384:	e8 16       	cp	r14, r24
   12386:	01 f1       	breq	.+64     	; 0x123c8 <FMenuPassword+0x6c>
   12388:	e8 16       	cp	r14, r24
   1238a:	40 f0       	brcs	.+16     	; 0x1239c <FMenuPassword+0x40>
   1238c:	e2 e0       	ldi	r30, 0x02	; 2
   1238e:	ee 16       	cp	r14, r30
   12390:	e9 f1       	breq	.+122    	; 0x1240c <FMenuPassword+0xb0>
   12392:	f3 e0       	ldi	r31, 0x03	; 3
   12394:	ef 16       	cp	r14, r31
   12396:	09 f0       	breq	.+2      	; 0x1239a <FMenuPassword+0x3e>
   12398:	90 c0       	rjmp	.+288    	; 0x124ba <FMenuPassword+0x15e>
   1239a:	8a c0       	rjmp	.+276    	; 0x124b0 <FMenuPassword+0x154>
	 case mpInitPassword:
	      lcd_clear();
   1239c:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
   123a0:	81 e0       	ldi	r24, 0x01	; 1
   123a2:	61 e0       	ldi	r22, 0x01	; 1
   123a4:	4a e0       	ldi	r20, 0x0A	; 10
   123a6:	59 e1       	ldi	r21, 0x19	; 25
   123a8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   123ac:	82 e0       	ldi	r24, 0x02	; 2
   123ae:	61 e0       	ldi	r22, 0x01	; 1
   123b0:	48 e0       	ldi	r20, 0x08	; 8
   123b2:	59 e1       	ldi	r21, 0x19	; 25
   123b4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   123b8:	84 e0       	ldi	r24, 0x04	; 4
   123ba:	61 e0       	ldi	r22, 0x01	; 1
   123bc:	43 ef       	ldi	r20, 0xF3	; 243
   123be:	58 e1       	ldi	r21, 0x18	; 24
   123c0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
   123c4:	81 e0       	ldi	r24, 0x01	; 1
   123c6:	71 c0       	rjmp	.+226    	; 0x124aa <FMenuPassword+0x14e>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
   123c8:	84 e0       	ldi	r24, 0x04	; 4
   123ca:	62 e0       	ldi	r22, 0x02	; 2
   123cc:	41 e0       	ldi	r20, 0x01	; 1
   123ce:	27 e5       	ldi	r18, 0x57	; 87
   123d0:	32 e0       	ldi	r19, 0x02	; 2
   123d2:	00 e0       	ldi	r16, 0x00	; 0
   123d4:	10 e0       	ldi	r17, 0x00	; 0
   123d6:	58 e0       	ldi	r21, 0x08	; 8
   123d8:	e5 2e       	mov	r14, r21
   123da:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
		  if (uiResult==USER_OK){
   123de:	83 30       	cpi	r24, 0x03	; 3
   123e0:	11 f4       	brne	.+4      	; 0x123e6 <FMenuPassword+0x8a>
		      stMenuPasword=mpProcessPassword;
   123e2:	82 e0       	ldi	r24, 0x02	; 2
   123e4:	62 c0       	rjmp	.+196    	; 0x124aa <FMenuPassword+0x14e>
			  }
		  else
		  if (uiResult==USER_CANCEL){
   123e6:	81 30       	cpi	r24, 0x01	; 1
   123e8:	09 f4       	brne	.+2      	; 0x123ec <FMenuPassword+0x90>
   123ea:	50 c0       	rjmp	.+160    	; 0x1248c <FMenuPassword+0x130>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   123ec:	84 30       	cpi	r24, 0x04	; 4
   123ee:	21 f4       	brne	.+8      	; 0x123f8 <FMenuPassword+0x9c>
   123f0:	61 e0       	ldi	r22, 0x01	; 1
   123f2:	4e ed       	ldi	r20, 0xDE	; 222
   123f4:	58 e1       	ldi	r21, 0x18	; 24
   123f6:	07 c0       	rjmp	.+14     	; 0x12406 <FMenuPassword+0xaa>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   123f8:	85 30       	cpi	r24, 0x05	; 5
   123fa:	09 f0       	breq	.+2      	; 0x123fe <FMenuPassword+0xa2>
   123fc:	5e c0       	rjmp	.+188    	; 0x124ba <FMenuPassword+0x15e>
   123fe:	84 e0       	ldi	r24, 0x04	; 4
   12400:	61 e0       	ldi	r22, 0x01	; 1
   12402:	49 ec       	ldi	r20, 0xC9	; 201
   12404:	58 e1       	ldi	r21, 0x18	; 24
   12406:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   1240a:	57 c0       	rjmp	.+174    	; 0x124ba <FMenuPassword+0x15e>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
   1240c:	00 d0       	rcall	.+0      	; 0x1240e <FMenuPassword+0xb2>
   1240e:	00 d0       	rcall	.+0      	; 0x12410 <FMenuPassword+0xb4>
   12410:	8e 01       	movw	r16, r28
   12412:	0f 5f       	subi	r16, 0xFF	; 255
   12414:	1f 4f       	sbci	r17, 0xFF	; 255
   12416:	ed b7       	in	r30, 0x3d	; 61
   12418:	fe b7       	in	r31, 0x3e	; 62
   1241a:	12 83       	std	Z+2, r17	; 0x02
   1241c:	01 83       	std	Z+1, r16	; 0x01
   1241e:	81 ec       	ldi	r24, 0xC1	; 193
   12420:	98 e1       	ldi	r25, 0x18	; 24
   12422:	94 83       	std	Z+4, r25	; 0x04
   12424:	83 83       	std	Z+3, r24	; 0x03
   12426:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   1242a:	0f 90       	pop	r0
   1242c:	0f 90       	pop	r0
   1242e:	0f 90       	pop	r0
   12430:	0f 90       	pop	r0
   12432:	35 e1       	ldi	r19, 0x15	; 21
   12434:	c3 2e       	mov	r12, r19
   12436:	d1 2c       	mov	r13, r1
   12438:	cc 0e       	add	r12, r28
   1243a:	dd 1e       	adc	r13, r29
   1243c:	c6 01       	movw	r24, r12
   1243e:	61 e0       	ldi	r22, 0x01	; 1
   12440:	70 e0       	ldi	r23, 0x00	; 0
   12442:	4a e0       	ldi	r20, 0x0A	; 10
   12444:	50 e0       	ldi	r21, 0x00	; 0
   12446:	22 e4       	ldi	r18, 0x42	; 66
   12448:	33 e1       	ldi	r19, 0x13	; 19
   1244a:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
   1244e:	2b e0       	ldi	r18, 0x0B	; 11
   12450:	a2 2e       	mov	r10, r18
   12452:	b1 2c       	mov	r11, r1
   12454:	ac 0e       	add	r10, r28
   12456:	bd 1e       	adc	r11, r29
   12458:	c5 01       	movw	r24, r10
   1245a:	6b e0       	ldi	r22, 0x0B	; 11
   1245c:	70 e0       	ldi	r23, 0x00	; 0
   1245e:	4a e0       	ldi	r20, 0x0A	; 10
   12460:	50 e0       	ldi	r21, 0x00	; 0
   12462:	22 e4       	ldi	r18, 0x42	; 66
   12464:	33 e1       	ldi	r19, 0x13	; 19
   12466:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
   1246a:	c8 01       	movw	r24, r16
   1246c:	67 e5       	ldi	r22, 0x57	; 87
   1246e:	72 e0       	ldi	r23, 0x02	; 2
   12470:	0e 94 f3 b0 	call	0x161e6	; 0x161e6 <strcmp>
   12474:	00 97       	sbiw	r24, 0x00	; 0
   12476:	11 f4       	brne	.+4      	; 0x1247c <FMenuPassword+0x120>
		       PassStatus=MP_VALID_MASTER;
   12478:	83 e0       	ldi	r24, 0x03	; 3
   1247a:	08 c0       	rjmp	.+16     	; 0x1248c <FMenuPassword+0x130>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
   1247c:	c6 01       	movw	r24, r12
   1247e:	67 e5       	ldi	r22, 0x57	; 87
   12480:	72 e0       	ldi	r23, 0x02	; 2
   12482:	0e 94 f3 b0 	call	0x161e6	; 0x161e6 <strcmp>
   12486:	00 97       	sbiw	r24, 0x00	; 0
   12488:	21 f4       	brne	.+8      	; 0x12492 <FMenuPassword+0x136>
		       PassStatus=MP_VALID_ADMIN;
   1248a:	84 e0       	ldi	r24, 0x04	; 4
   1248c:	80 93 56 02 	sts	0x0256, r24
   12490:	0b c0       	rjmp	.+22     	; 0x124a8 <FMenuPassword+0x14c>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
   12492:	c5 01       	movw	r24, r10
   12494:	67 e5       	ldi	r22, 0x57	; 87
   12496:	72 e0       	ldi	r23, 0x02	; 2
   12498:	0e 94 f3 b0 	call	0x161e6	; 0x161e6 <strcmp>
   1249c:	00 97       	sbiw	r24, 0x00	; 0
   1249e:	11 f4       	brne	.+4      	; 0x124a4 <FMenuPassword+0x148>
		       PassStatus=MP_VALID_SYSTEM;
   124a0:	85 e0       	ldi	r24, 0x05	; 5
   124a2:	f4 cf       	rjmp	.-24     	; 0x1248c <FMenuPassword+0x130>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
   124a4:	e0 92 56 02 	sts	0x0256, r14
		  stMenuPasword=mpExit;
   124a8:	83 e0       	ldi	r24, 0x03	; 3
   124aa:	80 93 61 02 	sts	0x0261, r24
   124ae:	05 c0       	rjmp	.+10     	; 0x124ba <FMenuPassword+0x15e>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
   124b0:	10 92 61 02 	sts	0x0261, r1
	      Result=PassStatus;
   124b4:	80 91 56 02 	lds	r24, 0x0256
   124b8:	01 c0       	rjmp	.+2      	; 0x124bc <FMenuPassword+0x160>
   124ba:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
   124bc:	6e 96       	adiw	r28, 0x1e	; 30
   124be:	0f b6       	in	r0, 0x3f	; 63
   124c0:	f8 94       	cli
   124c2:	de bf       	out	0x3e, r29	; 62
   124c4:	0f be       	out	0x3f, r0	; 63
   124c6:	cd bf       	out	0x3d, r28	; 61
   124c8:	cf 91       	pop	r28
   124ca:	df 91       	pop	r29
   124cc:	1f 91       	pop	r17
   124ce:	0f 91       	pop	r16
   124d0:	ef 90       	pop	r14
   124d2:	df 90       	pop	r13
   124d4:	cf 90       	pop	r12
   124d6:	bf 90       	pop	r11
   124d8:	af 90       	pop	r10
   124da:	08 95       	ret

000124dc <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   124dc:	0f 93       	push	r16
   124de:	1f 93       	push	r17
   124e0:	df 93       	push	r29
   124e2:	cf 93       	push	r28
   124e4:	cd b7       	in	r28, 0x3d	; 61
   124e6:	de b7       	in	r29, 0x3e	; 62
   124e8:	64 97       	sbiw	r28, 0x14	; 20
   124ea:	0f b6       	in	r0, 0x3f	; 63
   124ec:	f8 94       	cli
   124ee:	de bf       	out	0x3e, r29	; 62
   124f0:	0f be       	out	0x3f, r0	; 63
   124f2:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,KeyChar;//,FIP_USED;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   124f4:	80 91 71 02 	lds	r24, 0x0271
   124f8:	87 30       	cpi	r24, 0x07	; 7
   124fa:	09 f4       	brne	.+2      	; 0x124fe <FMenuReprint+0x22>
   124fc:	88 c0       	rjmp	.+272    	; 0x1260e <FMenuReprint+0x132>
   124fe:	88 30       	cpi	r24, 0x08	; 8
   12500:	90 f4       	brcc	.+36     	; 0x12526 <FMenuReprint+0x4a>
   12502:	83 30       	cpi	r24, 0x03	; 3
   12504:	09 f4       	brne	.+2      	; 0x12508 <FMenuReprint+0x2c>
   12506:	43 c0       	rjmp	.+134    	; 0x1258e <FMenuReprint+0xb2>
   12508:	84 30       	cpi	r24, 0x04	; 4
   1250a:	30 f4       	brcc	.+12     	; 0x12518 <FMenuReprint+0x3c>
   1250c:	81 30       	cpi	r24, 0x01	; 1
   1250e:	09 f4       	brne	.+2      	; 0x12512 <FMenuReprint+0x36>
   12510:	52 c0       	rjmp	.+164    	; 0x125b6 <FMenuReprint+0xda>
   12512:	82 30       	cpi	r24, 0x02	; 2
   12514:	48 f5       	brcc	.+82     	; 0x12568 <FMenuReprint+0x8c>
   12516:	1d c0       	rjmp	.+58     	; 0x12552 <FMenuReprint+0x76>
   12518:	85 30       	cpi	r24, 0x05	; 5
   1251a:	09 f4       	brne	.+2      	; 0x1251e <FMenuReprint+0x42>
   1251c:	69 c0       	rjmp	.+210    	; 0x125f0 <FMenuReprint+0x114>
   1251e:	86 30       	cpi	r24, 0x06	; 6
   12520:	08 f0       	brcs	.+2      	; 0x12524 <FMenuReprint+0x48>
   12522:	4d c0       	rjmp	.+154    	; 0x125be <FMenuReprint+0xe2>
   12524:	42 c0       	rjmp	.+132    	; 0x125aa <FMenuReprint+0xce>
   12526:	8b 30       	cpi	r24, 0x0B	; 11
   12528:	09 f4       	brne	.+2      	; 0x1252c <FMenuReprint+0x50>
   1252a:	d2 c0       	rjmp	.+420    	; 0x126d0 <FMenuReprint+0x1f4>
   1252c:	8c 30       	cpi	r24, 0x0C	; 12
   1252e:	38 f4       	brcc	.+14     	; 0x1253e <FMenuReprint+0x62>
   12530:	89 30       	cpi	r24, 0x09	; 9
   12532:	09 f4       	brne	.+2      	; 0x12536 <FMenuReprint+0x5a>
   12534:	b2 c0       	rjmp	.+356    	; 0x1269a <FMenuReprint+0x1be>
   12536:	8a 30       	cpi	r24, 0x0A	; 10
   12538:	08 f0       	brcs	.+2      	; 0x1253c <FMenuReprint+0x60>
   1253a:	c4 c0       	rjmp	.+392    	; 0x126c4 <FMenuReprint+0x1e8>
   1253c:	76 c0       	rjmp	.+236    	; 0x1262a <FMenuReprint+0x14e>
   1253e:	8d 30       	cpi	r24, 0x0D	; 13
   12540:	09 f4       	brne	.+2      	; 0x12544 <FMenuReprint+0x68>
   12542:	e3 c0       	rjmp	.+454    	; 0x1270a <FMenuReprint+0x22e>
   12544:	8d 30       	cpi	r24, 0x0D	; 13
   12546:	08 f4       	brcc	.+2      	; 0x1254a <FMenuReprint+0x6e>
   12548:	cd c0       	rjmp	.+410    	; 0x126e4 <FMenuReprint+0x208>
   1254a:	8e 30       	cpi	r24, 0x0E	; 14
   1254c:	09 f0       	breq	.+2      	; 0x12550 <FMenuReprint+0x74>
   1254e:	e6 c0       	rjmp	.+460    	; 0x1271c <FMenuReprint+0x240>
   12550:	e1 c0       	rjmp	.+450    	; 0x12714 <FMenuReprint+0x238>
	 case rtInit:
	      lcd_clear();
   12552:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   12556:	80 91 00 01 	lds	r24, 0x0100
   1255a:	81 30       	cpi	r24, 0x01	; 1
   1255c:	09 f4       	brne	.+2      	; 0x12560 <FMenuReprint+0x84>
   1255e:	ad c0       	rjmp	.+346    	; 0x126ba <FMenuReprint+0x1de>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   12560:	82 30       	cpi	r24, 0x02	; 2
   12562:	09 f0       	breq	.+2      	; 0x12566 <FMenuReprint+0x8a>
   12564:	db c0       	rjmp	.+438    	; 0x1271c <FMenuReprint+0x240>
   12566:	04 c0       	rjmp	.+8      	; 0x12570 <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   12568:	0e 94 ae 91 	call	0x1235c	; 0x1235c <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   1256c:	84 30       	cpi	r24, 0x04	; 4
   1256e:	11 f4       	brne	.+4      	; 0x12574 <FMenuReprint+0x98>
   12570:	81 e0       	ldi	r24, 0x01	; 1
   12572:	0a c0       	rjmp	.+20     	; 0x12588 <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   12574:	85 30       	cpi	r24, 0x05	; 5
   12576:	11 f0       	breq	.+4      	; 0x1257c <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   12578:	82 30       	cpi	r24, 0x02	; 2
   1257a:	11 f4       	brne	.+4      	; 0x12580 <FMenuReprint+0xa4>
   1257c:	83 e0       	ldi	r24, 0x03	; 3
   1257e:	04 c0       	rjmp	.+8      	; 0x12588 <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   12580:	81 30       	cpi	r24, 0x01	; 1
   12582:	09 f0       	breq	.+2      	; 0x12586 <FMenuReprint+0xaa>
   12584:	cb c0       	rjmp	.+406    	; 0x1271c <FMenuReprint+0x240>
   12586:	8e e0       	ldi	r24, 0x0E	; 14
   12588:	80 93 71 02 	sts	0x0271, r24
   1258c:	c7 c0       	rjmp	.+398    	; 0x1271c <FMenuReprint+0x240>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   1258e:	10 92 94 01 	sts	0x0194, r1
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12592:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12594:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12596:	81 e0       	ldi	r24, 0x01	; 1
   12598:	80 93 be 01 	sts	0x01BE, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   1259c:	83 e0       	ldi	r24, 0x03	; 3
   1259e:	61 e0       	ldi	r22, 0x01	; 1
   125a0:	45 e7       	ldi	r20, 0x75	; 117
   125a2:	5c e1       	ldi	r21, 0x1C	; 28
   125a4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   125a8:	30 c0       	rjmp	.+96     	; 0x1260a <FMenuReprint+0x12e>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   125aa:	80 91 94 01 	lds	r24, 0x0194
   125ae:	83 30       	cpi	r24, 0x03	; 3
   125b0:	08 f4       	brcc	.+2      	; 0x125b4 <FMenuReprint+0xd8>
   125b2:	b4 c0       	rjmp	.+360    	; 0x1271c <FMenuReprint+0x240>
   125b4:	e8 cf       	rjmp	.-48     	; 0x12586 <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   125b6:	0e 94 58 22 	call	0x44b0	; 0x44b0 <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   125ba:	86 e0       	ldi	r24, 0x06	; 6
   125bc:	e5 cf       	rjmp	.-54     	; 0x12588 <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   125be:	81 e0       	ldi	r24, 0x01	; 1
   125c0:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   125c4:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
   125c8:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   125ca:	81 53       	subi	r24, 0x31	; 49
   125cc:	88 30       	cpi	r24, 0x08	; 8
   125ce:	60 f4       	brcc	.+24     	; 0x125e8 <FMenuReprint+0x10c>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   125d0:	8f 5f       	subi	r24, 0xFF	; 255
   125d2:	61 e0       	ldi	r22, 0x01	; 1
   125d4:	0e 94 75 24 	call	0x48ea	; 0x48ea <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   125d8:	82 31       	cpi	r24, 0x12	; 18
   125da:	11 f4       	brne	.+4      	; 0x125e0 <FMenuReprint+0x104>
   125dc:	85 e0       	ldi	r24, 0x05	; 5
   125de:	d4 cf       	rjmp	.-88     	; 0x12588 <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;
   125e0:	81 31       	cpi	r24, 0x11	; 17
   125e2:	09 f0       	breq	.+2      	; 0x125e6 <FMenuReprint+0x10a>
   125e4:	9b c0       	rjmp	.+310    	; 0x1271c <FMenuReprint+0x240>
   125e6:	cf cf       	rjmp	.-98     	; 0x12586 <FMenuReprint+0xaa>

		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   125e8:	9a 32       	cpi	r25, 0x2A	; 42
   125ea:	09 f0       	breq	.+2      	; 0x125ee <FMenuReprint+0x112>
   125ec:	97 c0       	rjmp	.+302    	; 0x1271c <FMenuReprint+0x240>
   125ee:	cb cf       	rjmp	.-106    	; 0x12586 <FMenuReprint+0xaa>

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   125f0:	83 e0       	ldi	r24, 0x03	; 3
   125f2:	61 e0       	ldi	r22, 0x01	; 1
   125f4:	40 e6       	ldi	r20, 0x60	; 96
   125f6:	5c e1       	ldi	r21, 0x1C	; 28
   125f8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   125fc:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   125fe:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12600:	81 e0       	ldi	r24, 0x01	; 1
   12602:	80 93 be 01 	sts	0x01BE, r24

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   12606:	10 92 94 01 	sts	0x0194, r1
		  stReprint=rtTimDisplayInvalid;
   1260a:	84 e0       	ldi	r24, 0x04	; 4
   1260c:	bd cf       	rjmp	.-134    	; 0x12588 <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   1260e:	8f e6       	ldi	r24, 0x6F	; 111
   12610:	92 e0       	ldi	r25, 0x02	; 2
   12612:	62 ec       	ldi	r22, 0xC2	; 194
   12614:	77 e0       	ldi	r23, 0x07	; 7
   12616:	0e 94 3d 6a 	call	0xd47a	; 0xd47a <menu_FIP>
		  if (FIPResult==FIP_DONE){
   1261a:	88 23       	and	r24, r24
   1261c:	11 f4       	brne	.+4      	; 0x12622 <FMenuReprint+0x146>
		      stReprint=rtRFID;
   1261e:	88 e0       	ldi	r24, 0x08	; 8
   12620:	b3 cf       	rjmp	.-154    	; 0x12588 <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   12622:	82 30       	cpi	r24, 0x02	; 2
   12624:	09 f0       	breq	.+2      	; 0x12628 <FMenuReprint+0x14c>
   12626:	7a c0       	rjmp	.+244    	; 0x1271c <FMenuReprint+0x240>
   12628:	ae cf       	rjmp	.-164    	; 0x12586 <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   1262a:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   1262e:	00 d0       	rcall	.+0      	; 0x12630 <FMenuReprint+0x154>
   12630:	00 d0       	rcall	.+0      	; 0x12632 <FMenuReprint+0x156>
   12632:	00 d0       	rcall	.+0      	; 0x12634 <FMenuReprint+0x158>
   12634:	ed b7       	in	r30, 0x3d	; 61
   12636:	fe b7       	in	r31, 0x3e	; 62
   12638:	31 96       	adiw	r30, 0x01	; 1
   1263a:	8e 01       	movw	r16, r28
   1263c:	0f 5f       	subi	r16, 0xFF	; 255
   1263e:	1f 4f       	sbci	r17, 0xFF	; 255
   12640:	ad b7       	in	r26, 0x3d	; 61
   12642:	be b7       	in	r27, 0x3e	; 62
   12644:	12 96       	adiw	r26, 0x02	; 2
   12646:	1c 93       	st	X, r17
   12648:	0e 93       	st	-X, r16
   1264a:	11 97       	sbiw	r26, 0x01	; 1
   1264c:	80 e5       	ldi	r24, 0x50	; 80
   1264e:	9c e1       	ldi	r25, 0x1C	; 28
   12650:	93 83       	std	Z+3, r25	; 0x03
   12652:	82 83       	std	Z+2, r24	; 0x02
   12654:	82 ec       	ldi	r24, 0xC2	; 194
   12656:	97 e0       	ldi	r25, 0x07	; 7
   12658:	95 83       	std	Z+5, r25	; 0x05
   1265a:	84 83       	std	Z+4, r24	; 0x04
   1265c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   12660:	8d b7       	in	r24, 0x3d	; 61
   12662:	9e b7       	in	r25, 0x3e	; 62
   12664:	06 96       	adiw	r24, 0x06	; 6
   12666:	0f b6       	in	r0, 0x3f	; 63
   12668:	f8 94       	cli
   1266a:	9e bf       	out	0x3e, r25	; 62
   1266c:	0f be       	out	0x3f, r0	; 63
   1266e:	8d bf       	out	0x3d, r24	; 61
   12670:	81 e0       	ldi	r24, 0x01	; 1
   12672:	61 e0       	ldi	r22, 0x01	; 1
   12674:	a8 01       	movw	r20, r16
   12676:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   1267a:	82 e0       	ldi	r24, 0x02	; 2
   1267c:	61 e0       	ldi	r22, 0x01	; 1
   1267e:	4c e3       	ldi	r20, 0x3C	; 60
   12680:	5c e1       	ldi	r21, 0x1C	; 28
   12682:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   12686:	84 e0       	ldi	r24, 0x04	; 4
   12688:	61 e0       	ldi	r22, 0x01	; 1
   1268a:	49 e2       	ldi	r20, 0x29	; 41
   1268c:	5c e1       	ldi	r21, 0x1C	; 28
   1268e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  IsRFIDDetected=False;
   12692:	10 92 9a 01 	sts	0x019A, r1
		  stReprint=rtInputRFID;
   12696:	89 e0       	ldi	r24, 0x09	; 9
   12698:	77 cf       	rjmp	.-274    	; 0x12588 <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   1269a:	80 91 9a 01 	lds	r24, 0x019A
   1269e:	81 30       	cpi	r24, 0x01	; 1
   126a0:	29 f4       	brne	.+10     	; 0x126ac <FMenuReprint+0x1d0>
		      IsRFIDDetected=False;
   126a2:	10 92 9a 01 	sts	0x019A, r1
		      stReprint=rtSendMessage28;
   126a6:	8a e0       	ldi	r24, 0x0A	; 10
   126a8:	80 93 71 02 	sts	0x0271, r24
		  }
	 	  KeyPressed=_key_scan(1);
   126ac:	81 e0       	ldi	r24, 0x01	; 1
   126ae:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   126b2:	80 93 70 02 	sts	0x0270, r24
		  if (KeyPressed==_KEY_CANCEL){
   126b6:	87 3e       	cpi	r24, 0xE7	; 231
   126b8:	11 f4       	brne	.+4      	; 0x126be <FMenuReprint+0x1e2>
		      stReprint=rtFIP;
   126ba:	87 e0       	ldi	r24, 0x07	; 7
   126bc:	65 cf       	rjmp	.-310    	; 0x12588 <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   126be:	87 3b       	cpi	r24, 0xB7	; 183
   126c0:	69 f5       	brne	.+90     	; 0x1271c <FMenuReprint+0x240>
   126c2:	61 cf       	rjmp	.-318    	; 0x12586 <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   126c4:	0e 94 6b 50 	call	0xa0d6	; 0xa0d6 <sendMessage28>
		  TimSend=0;
   126c8:	10 92 91 0e 	sts	0x0E91, r1
		  stReprint=rtWaitReply;
   126cc:	8b e0       	ldi	r24, 0x0B	; 11
   126ce:	5c cf       	rjmp	.-328    	; 0x12588 <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   126d0:	80 91 91 0e 	lds	r24, 0x0E91
   126d4:	8f 31       	cpi	r24, 0x1F	; 31
   126d6:	18 f0       	brcs	.+6      	; 0x126de <FMenuReprint+0x202>
   126d8:	8c e0       	ldi	r24, 0x0C	; 12
   126da:	80 93 71 02 	sts	0x0271, r24
	      if (IsMessage99==True){
   126de:	80 91 a1 01 	lds	r24, 0x01A1
   126e2:	4e cf       	rjmp	.-356    	; 0x12580 <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   126e4:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   126e8:	82 e0       	ldi	r24, 0x02	; 2
   126ea:	61 e0       	ldi	r22, 0x01	; 1
   126ec:	4b e1       	ldi	r20, 0x1B	; 27
   126ee:	5c e1       	ldi	r21, 0x1C	; 28
   126f0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   126f4:	83 e0       	ldi	r24, 0x03	; 3
   126f6:	61 e0       	ldi	r22, 0x01	; 1
   126f8:	4d e0       	ldi	r20, 0x0D	; 13
   126fa:	5c e1       	ldi	r21, 0x1C	; 28
   126fc:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  TimDisplay=5;
   12700:	85 e0       	ldi	r24, 0x05	; 5
   12702:	80 93 94 01 	sts	0x0194, r24
		  stReprint=rtDelayExitReprint;
   12706:	8d e0       	ldi	r24, 0x0D	; 13
   12708:	3f cf       	rjmp	.-386    	; 0x12588 <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   1270a:	80 91 94 01 	lds	r24, 0x0194
   1270e:	8a 30       	cpi	r24, 0x0A	; 10
   12710:	28 f0       	brcs	.+10     	; 0x1271c <FMenuReprint+0x240>
   12712:	39 cf       	rjmp	.-398    	; 0x12586 <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   12714:	10 92 71 02 	sts	0x0271, r1
   12718:	81 e0       	ldi	r24, 0x01	; 1
   1271a:	01 c0       	rjmp	.+2      	; 0x1271e <FMenuReprint+0x242>
   1271c:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   1271e:	64 96       	adiw	r28, 0x14	; 20
   12720:	0f b6       	in	r0, 0x3f	; 63
   12722:	f8 94       	cli
   12724:	de bf       	out	0x3e, r29	; 62
   12726:	0f be       	out	0x3f, r0	; 63
   12728:	cd bf       	out	0x3d, r28	; 61
   1272a:	cf 91       	pop	r28
   1272c:	df 91       	pop	r29
   1272e:	1f 91       	pop	r17
   12730:	0f 91       	pop	r16
   12732:	08 95       	ret

00012734 <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   12734:	80 91 54 02 	lds	r24, 0x0254
   12738:	83 30       	cpi	r24, 0x03	; 3
   1273a:	09 f4       	brne	.+2      	; 0x1273e <FMenuAdmin+0xa>
   1273c:	66 c0       	rjmp	.+204    	; 0x1280a <FMenuAdmin+0xd6>
   1273e:	84 30       	cpi	r24, 0x04	; 4
   12740:	30 f4       	brcc	.+12     	; 0x1274e <FMenuAdmin+0x1a>
   12742:	81 30       	cpi	r24, 0x01	; 1
   12744:	69 f1       	breq	.+90     	; 0x127a0 <FMenuAdmin+0x6c>
   12746:	82 30       	cpi	r24, 0x02	; 2
   12748:	08 f0       	brcs	.+2      	; 0x1274c <FMenuAdmin+0x18>
   1274a:	4d c0       	rjmp	.+154    	; 0x127e6 <FMenuAdmin+0xb2>
   1274c:	0d c0       	rjmp	.+26     	; 0x12768 <FMenuAdmin+0x34>
   1274e:	85 30       	cpi	r24, 0x05	; 5
   12750:	09 f4       	brne	.+2      	; 0x12754 <FMenuAdmin+0x20>
   12752:	4e c0       	rjmp	.+156    	; 0x127f0 <FMenuAdmin+0xbc>
   12754:	85 30       	cpi	r24, 0x05	; 5
   12756:	08 f4       	brcc	.+2      	; 0x1275a <FMenuAdmin+0x26>
   12758:	49 c0       	rjmp	.+146    	; 0x127ec <FMenuAdmin+0xb8>
   1275a:	86 30       	cpi	r24, 0x06	; 6
   1275c:	09 f4       	brne	.+2      	; 0x12760 <FMenuAdmin+0x2c>
   1275e:	51 c0       	rjmp	.+162    	; 0x12802 <FMenuAdmin+0xce>
   12760:	87 30       	cpi	r24, 0x07	; 7
   12762:	09 f0       	breq	.+2      	; 0x12766 <FMenuAdmin+0x32>
   12764:	5a c0       	rjmp	.+180    	; 0x1281a <FMenuAdmin+0xe6>
   12766:	55 c0       	rjmp	.+170    	; 0x12812 <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   12768:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   1276c:	81 e0       	ldi	r24, 0x01	; 1
   1276e:	61 e0       	ldi	r22, 0x01	; 1
   12770:	48 e1       	ldi	r20, 0x18	; 24
   12772:	57 e1       	ldi	r21, 0x17	; 23
   12774:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   12778:	82 e0       	ldi	r24, 0x02	; 2
   1277a:	61 e0       	ldi	r22, 0x01	; 1
   1277c:	43 e0       	ldi	r20, 0x03	; 3
   1277e:	57 e1       	ldi	r21, 0x17	; 23
   12780:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   12784:	83 e0       	ldi	r24, 0x03	; 3
   12786:	61 e0       	ldi	r22, 0x01	; 1
   12788:	4e ee       	ldi	r20, 0xEE	; 238
   1278a:	56 e1       	ldi	r21, 0x16	; 22
   1278c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   12790:	84 e0       	ldi	r24, 0x04	; 4
   12792:	61 e0       	ldi	r22, 0x01	; 1
   12794:	49 ed       	ldi	r20, 0xD9	; 217
   12796:	56 e1       	ldi	r21, 0x16	; 22
   12798:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   1279c:	81 e0       	ldi	r24, 0x01	; 1
   1279e:	2e c0       	rjmp	.+92     	; 0x127fc <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   127a0:	81 e0       	ldi	r24, 0x01	; 1
   127a2:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   127a6:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  switch (KeyChar){
   127aa:	82 33       	cpi	r24, 0x32	; 50
   127ac:	71 f0       	breq	.+28     	; 0x127ca <FMenuAdmin+0x96>
   127ae:	83 33       	cpi	r24, 0x33	; 51
   127b0:	28 f4       	brcc	.+10     	; 0x127bc <FMenuAdmin+0x88>
   127b2:	8a 32       	cpi	r24, 0x2A	; 42
   127b4:	11 f1       	breq	.+68     	; 0x127fa <FMenuAdmin+0xc6>
   127b6:	81 33       	cpi	r24, 0x31	; 49
   127b8:	81 f5       	brne	.+96     	; 0x1281a <FMenuAdmin+0xe6>
   127ba:	05 c0       	rjmp	.+10     	; 0x127c6 <FMenuAdmin+0x92>
   127bc:	83 33       	cpi	r24, 0x33	; 51
   127be:	59 f0       	breq	.+22     	; 0x127d6 <FMenuAdmin+0xa2>
   127c0:	84 33       	cpi	r24, 0x34	; 52
   127c2:	59 f5       	brne	.+86     	; 0x1281a <FMenuAdmin+0xe6>
   127c4:	0e c0       	rjmp	.+28     	; 0x127e2 <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   127c6:	82 e0       	ldi	r24, 0x02	; 2
   127c8:	19 c0       	rjmp	.+50     	; 0x127fc <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   127ca:	80 91 00 01 	lds	r24, 0x0100
   127ce:	82 30       	cpi	r24, 0x02	; 2
   127d0:	e1 f4       	brne	.+56     	; 0x1280a <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   127d2:	84 e0       	ldi	r24, 0x04	; 4
   127d4:	13 c0       	rjmp	.+38     	; 0x127fc <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   127d6:	80 91 00 01 	lds	r24, 0x0100
   127da:	82 30       	cpi	r24, 0x02	; 2
   127dc:	b1 f4       	brne	.+44     	; 0x1280a <FMenuAdmin+0xd6>
   127de:	85 e0       	ldi	r24, 0x05	; 5
   127e0:	0d c0       	rjmp	.+26     	; 0x127fc <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   127e2:	86 e0       	ldi	r24, 0x06	; 6
   127e4:	0b c0       	rjmp	.+22     	; 0x127fc <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   127e6:	0e 94 6e 92 	call	0x124dc	; 0x124dc <FMenuReprint>
   127ea:	05 c0       	rjmp	.+10     	; 0x127f6 <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   127ec:	82 e0       	ldi	r24, 0x02	; 2
   127ee:	01 c0       	rjmp	.+2      	; 0x127f2 <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   127f0:	81 e0       	ldi	r24, 0x01	; 1
   127f2:	0e 94 3a 5e 	call	0xbc74	; 0xbc74 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   127f6:	81 30       	cpi	r24, 0x01	; 1
   127f8:	81 f4       	brne	.+32     	; 0x1281a <FMenuAdmin+0xe6>
   127fa:	87 e0       	ldi	r24, 0x07	; 7
   127fc:	80 93 54 02 	sts	0x0254, r24
   12800:	06 c0       	rjmp	.+12     	; 0x1280e <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   12802:	0e 94 16 8f 	call	0x11e2c	; 0x11e2c <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   12806:	81 30       	cpi	r24, 0x01	; 1
   12808:	41 f4       	brne	.+16     	; 0x1281a <FMenuAdmin+0xe6>
   1280a:	10 92 54 02 	sts	0x0254, r1
   1280e:	80 e0       	ldi	r24, 0x00	; 0
   12810:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   12812:	10 92 54 02 	sts	0x0254, r1
   12816:	81 e0       	ldi	r24, 0x01	; 1
   12818:	08 95       	ret
   1281a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   1281c:	08 95       	ret

0001281e <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   1281e:	af 92       	push	r10
   12820:	bf 92       	push	r11
   12822:	cf 92       	push	r12
   12824:	df 92       	push	r13
   12826:	ef 92       	push	r14
   12828:	ff 92       	push	r15
   1282a:	0f 93       	push	r16
   1282c:	1f 93       	push	r17
   1282e:	df 93       	push	r29
   12830:	cf 93       	push	r28
   12832:	cd b7       	in	r28, 0x3d	; 61
   12834:	de b7       	in	r29, 0x3e	; 62
   12836:	a3 97       	sbiw	r28, 0x23	; 35
   12838:	0f b6       	in	r0, 0x3f	; 63
   1283a:	f8 94       	cli
   1283c:	de bf       	out	0x3e, r29	; 62
   1283e:	0f be       	out	0x3f, r0	; 63
   12840:	cd bf       	out	0x3d, r28	; 61
       char lcdteks[20],i,msgResult;       
	   char strBankName[11],strSurcharge[4],Result;
       char uiResult,KeyPressed=0,KeyChar,FIPResult;

     Result=MENU_NONE; 
	 switch(stChangeMOP){
   12842:	80 91 6a 02 	lds	r24, 0x026A
   12846:	e8 2f       	mov	r30, r24
   12848:	f0 e0       	ldi	r31, 0x00	; 0
   1284a:	ee 31       	cpi	r30, 0x1E	; 30
   1284c:	f1 05       	cpc	r31, r1
   1284e:	08 f0       	brcs	.+2      	; 0x12852 <FMenuChangeMOP+0x34>
   12850:	0c c4       	rjmp	.+2072   	; 0x1306a <FMenuChangeMOP+0x84c>
   12852:	e3 53       	subi	r30, 0x33	; 51
   12854:	ff 4f       	sbci	r31, 0xFF	; 255
   12856:	ee 0f       	add	r30, r30
   12858:	ff 1f       	adc	r31, r31
   1285a:	05 90       	lpm	r0, Z+
   1285c:	f4 91       	lpm	r31, Z+
   1285e:	e0 2d       	mov	r30, r0
   12860:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   12862:	85 e0       	ldi	r24, 0x05	; 5
   12864:	80 93 ba 01 	sts	0x01BA, r24
   12868:	3c c1       	rjmp	.+632    	; 0x12ae2 <FMenuChangeMOP+0x2c4>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   1286a:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   1286e:	81 e0       	ldi	r24, 0x01	; 1
   12870:	61 e0       	ldi	r22, 0x01	; 1
   12872:	4f ea       	ldi	r20, 0xAF	; 175
   12874:	5a e1       	ldi	r21, 0x1A	; 26
   12876:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   1287a:	82 e0       	ldi	r24, 0x02	; 2
   1287c:	61 e0       	ldi	r22, 0x01	; 1
   1287e:	4a e9       	ldi	r20, 0x9A	; 154
   12880:	5a e1       	ldi	r21, 0x1A	; 26
   12882:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   12886:	83 e0       	ldi	r24, 0x03	; 3
   12888:	61 e0       	ldi	r22, 0x01	; 1
   1288a:	45 e8       	ldi	r20, 0x85	; 133
   1288c:	5a e1       	ldi	r21, 0x1A	; 26
   1288e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   12892:	84 e0       	ldi	r24, 0x04	; 4
   12894:	61 e0       	ldi	r22, 0x01	; 1
   12896:	40 e7       	ldi	r20, 0x70	; 112
   12898:	5a e1       	ldi	r21, 0x1A	; 26
   1289a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   1289e:	82 e0       	ldi	r24, 0x02	; 2
   128a0:	a2 c1       	rjmp	.+836    	; 0x12be6 <FMenuChangeMOP+0x3c8>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   128a2:	81 e0       	ldi	r24, 0x01	; 1
   128a4:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   128a8:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   128aa:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
   128ae:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   128b0:	81 53       	subi	r24, 0x31	; 49
   128b2:	84 30       	cpi	r24, 0x04	; 4
   128b4:	f0 f4       	brcc	.+60     	; 0x128f2 <FMenuChangeMOP+0xd4>
              switch(KeyChar){
   128b6:	92 33       	cpi	r25, 0x32	; 50
   128b8:	61 f0       	breq	.+24     	; 0x128d2 <FMenuChangeMOP+0xb4>
   128ba:	93 33       	cpi	r25, 0x33	; 51
   128bc:	18 f4       	brcc	.+6      	; 0x128c4 <FMenuChangeMOP+0xa6>
   128be:	91 33       	cpi	r25, 0x31	; 49
   128c0:	c1 f4       	brne	.+48     	; 0x128f2 <FMenuChangeMOP+0xd4>
   128c2:	05 c0       	rjmp	.+10     	; 0x128ce <FMenuChangeMOP+0xb0>
   128c4:	93 33       	cpi	r25, 0x33	; 51
   128c6:	51 f0       	breq	.+20     	; 0x128dc <FMenuChangeMOP+0xbe>
   128c8:	94 33       	cpi	r25, 0x34	; 52
   128ca:	99 f4       	brne	.+38     	; 0x128f2 <FMenuChangeMOP+0xd4>
   128cc:	0c c0       	rjmp	.+24     	; 0x128e6 <FMenuChangeMOP+0xc8>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   128ce:	81 e0       	ldi	r24, 0x01	; 1
   128d0:	0b c0       	rjmp	.+22     	; 0x128e8 <FMenuChangeMOP+0xca>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   128d2:	82 e0       	ldi	r24, 0x02	; 2
   128d4:	80 93 ba 01 	sts	0x01BA, r24
   128d8:	8b e0       	ldi	r24, 0x0B	; 11
   128da:	09 c0       	rjmp	.+18     	; 0x128ee <FMenuChangeMOP+0xd0>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   128dc:	83 e0       	ldi	r24, 0x03	; 3
   128de:	80 93 ba 01 	sts	0x01BA, r24
   128e2:	8f e0       	ldi	r24, 0x0F	; 15
   128e4:	04 c0       	rjmp	.+8      	; 0x128ee <FMenuChangeMOP+0xd0>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   128e6:	84 e0       	ldi	r24, 0x04	; 4
   128e8:	80 93 ba 01 	sts	0x01BA, r24
   128ec:	89 e0       	ldi	r24, 0x09	; 9
   128ee:	80 93 6a 02 	sts	0x026A, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   128f2:	17 3e       	cpi	r17, 0xE7	; 231
   128f4:	09 f0       	breq	.+2      	; 0x128f8 <FMenuChangeMOP+0xda>
   128f6:	b9 c3       	rjmp	.+1906   	; 0x1306a <FMenuChangeMOP+0x84c>
   128f8:	b0 c3       	rjmp	.+1888   	; 0x1305a <FMenuChangeMOP+0x83c>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   128fa:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   128fe:	81 e0       	ldi	r24, 0x01	; 1
   12900:	61 e0       	ldi	r22, 0x01	; 1
   12902:	43 e6       	ldi	r20, 0x63	; 99
   12904:	5a e1       	ldi	r21, 0x1A	; 26
   12906:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   1290a:	82 e0       	ldi	r24, 0x02	; 2
   1290c:	61 e0       	ldi	r22, 0x01	; 1
   1290e:	41 e6       	ldi	r20, 0x61	; 97
   12910:	5a e1       	ldi	r21, 0x1A	; 26
   12912:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12916:	84 e0       	ldi	r24, 0x04	; 4
   12918:	61 e0       	ldi	r22, 0x01	; 1
   1291a:	4c e4       	ldi	r20, 0x4C	; 76
   1291c:	5a e1       	ldi	r21, 0x1A	; 26
   1291e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   12922:	e1 e5       	ldi	r30, 0x51	; 81
   12924:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12926:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12928:	8e e0       	ldi	r24, 0x0E	; 14
   1292a:	e6 36       	cpi	r30, 0x66	; 102
   1292c:	f8 07       	cpc	r31, r24
   1292e:	d9 f7       	brne	.-10     	; 0x12926 <FMenuChangeMOP+0x108>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;		  
   12930:	87 e0       	ldi	r24, 0x07	; 7
   12932:	59 c1       	rjmp	.+690    	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   12934:	81 e0       	ldi	r24, 0x01	; 1
   12936:	62 e0       	ldi	r22, 0x02	; 2
   12938:	41 e0       	ldi	r20, 0x01	; 1
   1293a:	21 e5       	ldi	r18, 0x51	; 81
   1293c:	3e e0       	ldi	r19, 0x0E	; 14
   1293e:	00 e0       	ldi	r16, 0x00	; 0
   12940:	10 e0       	ldi	r17, 0x00	; 0
   12942:	5d e0       	ldi	r21, 0x0D	; 13
   12944:	e5 2e       	mov	r14, r21
   12946:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
	      if (uiResult==USER_OK){
   1294a:	83 30       	cpi	r24, 0x03	; 3
   1294c:	11 f4       	brne	.+4      	; 0x12952 <FMenuChangeMOP+0x134>
		     stChangeMOP=cmSelectFIP;
   1294e:	89 e0       	ldi	r24, 0x09	; 9
   12950:	4a c1       	rjmp	.+660    	; 0x12be6 <FMenuChangeMOP+0x3c8>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   12952:	81 30       	cpi	r24, 0x01	; 1
   12954:	09 f4       	brne	.+2      	; 0x12958 <FMenuChangeMOP+0x13a>
   12956:	47 c1       	rjmp	.+654    	; 0x12be6 <FMenuChangeMOP+0x3c8>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12958:	84 30       	cpi	r24, 0x04	; 4
   1295a:	21 f4       	brne	.+8      	; 0x12964 <FMenuChangeMOP+0x146>
   1295c:	61 e0       	ldi	r22, 0x01	; 1
   1295e:	47 e3       	ldi	r20, 0x37	; 55
   12960:	5a e1       	ldi	r21, 0x1A	; 26
   12962:	29 c1       	rjmp	.+594    	; 0x12bb6 <FMenuChangeMOP+0x398>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12964:	85 30       	cpi	r24, 0x05	; 5
   12966:	09 f0       	breq	.+2      	; 0x1296a <FMenuChangeMOP+0x14c>
   12968:	80 c3       	rjmp	.+1792   	; 0x1306a <FMenuChangeMOP+0x84c>
   1296a:	84 e0       	ldi	r24, 0x04	; 4
   1296c:	61 e0       	ldi	r22, 0x01	; 1
   1296e:	42 e2       	ldi	r20, 0x22	; 34
   12970:	5a e1       	ldi	r21, 0x1A	; 26
   12972:	21 c1       	rjmp	.+578    	; 0x12bb6 <FMenuChangeMOP+0x398>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12974:	89 e6       	ldi	r24, 0x69	; 105
   12976:	92 e0       	ldi	r25, 0x02	; 2
   12978:	62 ec       	ldi	r22, 0xC2	; 194
   1297a:	77 e0       	ldi	r23, 0x07	; 7
   1297c:	0e 94 3d 6a 	call	0xd47a	; 0xd47a <menu_FIP>
		  if (FIPResult==FIP_DONE){
   12980:	88 23       	and	r24, r24
   12982:	11 f4       	brne	.+4      	; 0x12988 <FMenuChangeMOP+0x16a>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   12984:	8e e0       	ldi	r24, 0x0E	; 14
   12986:	2f c1       	rjmp	.+606    	; 0x12be6 <FMenuChangeMOP+0x3c8>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   12988:	82 30       	cpi	r24, 0x02	; 2
   1298a:	09 f0       	breq	.+2      	; 0x1298e <FMenuChangeMOP+0x170>
   1298c:	6e c3       	rjmp	.+1756   	; 0x1306a <FMenuChangeMOP+0x84c>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   1298e:	80 91 ba 01 	lds	r24, 0x01BA
   12992:	81 30       	cpi	r24, 0x01	; 1
   12994:	09 f4       	brne	.+2      	; 0x12998 <FMenuChangeMOP+0x17a>
   12996:	27 c1       	rjmp	.+590    	; 0x12be6 <FMenuChangeMOP+0x3c8>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   12998:	82 30       	cpi	r24, 0x02	; 2
   1299a:	09 f4       	brne	.+2      	; 0x1299e <FMenuChangeMOP+0x180>
   1299c:	fd c0       	rjmp	.+506    	; 0x12b98 <FMenuChangeMOP+0x37a>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   1299e:	83 30       	cpi	r24, 0x03	; 3
   129a0:	11 f4       	brne	.+4      	; 0x129a6 <FMenuChangeMOP+0x188>
   129a2:	8f e0       	ldi	r24, 0x0F	; 15
   129a4:	20 c1       	rjmp	.+576    	; 0x12be6 <FMenuChangeMOP+0x3c8>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   129a6:	84 30       	cpi	r24, 0x04	; 4
   129a8:	09 f4       	brne	.+2      	; 0x129ac <FMenuChangeMOP+0x18e>
   129aa:	9b c0       	rjmp	.+310    	; 0x12ae2 <FMenuChangeMOP+0x2c4>
   129ac:	5e c3       	rjmp	.+1724   	; 0x1306a <FMenuChangeMOP+0x84c>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   129ae:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   129b2:	81 e0       	ldi	r24, 0x01	; 1
   129b4:	61 e0       	ldi	r22, 0x01	; 1
   129b6:	46 e1       	ldi	r20, 0x16	; 22
   129b8:	5a e1       	ldi	r21, 0x1A	; 26
   129ba:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   129be:	10 92 65 02 	sts	0x0265, r1
   129c2:	10 92 64 02 	sts	0x0264, r1
   129c6:	8e 01       	movw	r16, r28
   129c8:	0b 5f       	subi	r16, 0xFB	; 251
   129ca:	1f 4f       	sbci	r17, 0xFF	; 255
   129cc:	2b e0       	ldi	r18, 0x0B	; 11
   129ce:	a2 2e       	mov	r10, r18
   129d0:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   129d2:	90 e1       	ldi	r25, 0x10	; 16
   129d4:	e9 2e       	mov	r14, r25
   129d6:	f1 2c       	mov	r15, r1
   129d8:	ec 0e       	add	r14, r28
   129da:	fd 1e       	adc	r15, r29
   129dc:	80 e1       	ldi	r24, 0x10	; 16
   129de:	c8 2e       	mov	r12, r24
   129e0:	8a e1       	ldi	r24, 0x1A	; 26
   129e2:	d8 2e       	mov	r13, r24
   129e4:	5d c0       	rjmp	.+186    	; 0x12aa0 <FMenuChangeMOP+0x282>
   129e6:	8a 9d       	mul	r24, r10
   129e8:	b0 01       	movw	r22, r0
   129ea:	8b 9d       	mul	r24, r11
   129ec:	70 0d       	add	r23, r0
   129ee:	9a 9d       	mul	r25, r10
   129f0:	70 0d       	add	r23, r0
   129f2:	11 24       	eor	r1, r1
   129f4:	67 5f       	subi	r22, 0xF7	; 247
   129f6:	7e 4f       	sbci	r23, 0xFE	; 254
   129f8:	c8 01       	movw	r24, r16
   129fa:	4b e0       	ldi	r20, 0x0B	; 11
   129fc:	50 e0       	ldi	r21, 0x00	; 0
   129fe:	22 e4       	ldi	r18, 0x42	; 66
   12a00:	33 e1       	ldi	r19, 0x13	; 19
   12a02:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   12a06:	e0 e0       	ldi	r30, 0x00	; 0
   12a08:	f0 e0       	ldi	r31, 0x00	; 0
   12a0a:	0b 30       	cpi	r16, 0x0B	; 11
   12a0c:	11 05       	cpc	r17, r1
   12a0e:	10 f4       	brcc	.+4      	; 0x12a14 <FMenuChangeMOP+0x1f6>
   12a10:	e1 e0       	ldi	r30, 0x01	; 1
   12a12:	f0 e0       	ldi	r31, 0x00	; 0
   12a14:	80 81       	ld	r24, Z
   12a16:	88 23       	and	r24, r24
   12a18:	d1 f1       	breq	.+116    	; 0x12a8e <FMenuChangeMOP+0x270>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12a1a:	ad b7       	in	r26, 0x3d	; 61
   12a1c:	be b7       	in	r27, 0x3e	; 62
   12a1e:	18 97       	sbiw	r26, 0x08	; 8
   12a20:	0f b6       	in	r0, 0x3f	; 63
   12a22:	f8 94       	cli
   12a24:	be bf       	out	0x3e, r27	; 62
   12a26:	0f be       	out	0x3f, r0	; 63
   12a28:	ad bf       	out	0x3d, r26	; 61
   12a2a:	ed b7       	in	r30, 0x3d	; 61
   12a2c:	fe b7       	in	r31, 0x3e	; 62
   12a2e:	31 96       	adiw	r30, 0x01	; 1
   12a30:	12 96       	adiw	r26, 0x02	; 2
   12a32:	fc 92       	st	X, r15
   12a34:	ee 92       	st	-X, r14
   12a36:	11 97       	sbiw	r26, 0x01	; 1
   12a38:	d3 82       	std	Z+3, r13	; 0x03
   12a3a:	c2 82       	std	Z+2, r12	; 0x02
   12a3c:	80 91 64 02 	lds	r24, 0x0264
   12a40:	90 91 65 02 	lds	r25, 0x0265
   12a44:	01 96       	adiw	r24, 0x01	; 1
   12a46:	95 83       	std	Z+5, r25	; 0x05
   12a48:	84 83       	std	Z+4, r24	; 0x04
   12a4a:	17 83       	std	Z+7, r17	; 0x07
   12a4c:	06 83       	std	Z+6, r16	; 0x06
   12a4e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   12a52:	20 91 64 02 	lds	r18, 0x0264
   12a56:	30 91 65 02 	lds	r19, 0x0265
   12a5a:	ed b7       	in	r30, 0x3d	; 61
   12a5c:	fe b7       	in	r31, 0x3e	; 62
   12a5e:	38 96       	adiw	r30, 0x08	; 8
   12a60:	0f b6       	in	r0, 0x3f	; 63
   12a62:	f8 94       	cli
   12a64:	fe bf       	out	0x3e, r31	; 62
   12a66:	0f be       	out	0x3f, r0	; 63
   12a68:	ed bf       	out	0x3d, r30	; 61
   12a6a:	82 2f       	mov	r24, r18
   12a6c:	81 70       	andi	r24, 0x01	; 1
   12a6e:	36 95       	lsr	r19
   12a70:	27 95       	ror	r18
   12a72:	b9 01       	movw	r22, r18
   12a74:	66 0f       	add	r22, r22
   12a76:	77 1f       	adc	r23, r23
   12a78:	62 0f       	add	r22, r18
   12a7a:	73 1f       	adc	r23, r19
   12a7c:	66 0f       	add	r22, r22
   12a7e:	77 1f       	adc	r23, r23
   12a80:	66 0f       	add	r22, r22
   12a82:	77 1f       	adc	r23, r23
   12a84:	6f 5f       	subi	r22, 0xFF	; 255
   12a86:	8e 5f       	subi	r24, 0xFE	; 254
   12a88:	a7 01       	movw	r20, r14
   12a8a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12a8e:	80 91 64 02 	lds	r24, 0x0264
   12a92:	90 91 65 02 	lds	r25, 0x0265
   12a96:	01 96       	adiw	r24, 0x01	; 1
   12a98:	90 93 65 02 	sts	0x0265, r25
   12a9c:	80 93 64 02 	sts	0x0264, r24
   12aa0:	80 91 64 02 	lds	r24, 0x0264
   12aa4:	90 91 65 02 	lds	r25, 0x0265
   12aa8:	84 30       	cpi	r24, 0x04	; 4
   12aaa:	91 05       	cpc	r25, r1
   12aac:	08 f4       	brcc	.+2      	; 0x12ab0 <FMenuChangeMOP+0x292>
   12aae:	9b cf       	rjmp	.-202    	; 0x129e6 <FMenuChangeMOP+0x1c8>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   12ab0:	84 e0       	ldi	r24, 0x04	; 4
   12ab2:	61 e0       	ldi	r22, 0x01	; 1
   12ab4:	48 e0       	ldi	r20, 0x08	; 8
   12ab6:	5a e1       	ldi	r21, 0x1A	; 26
   12ab8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   12abc:	8c e0       	ldi	r24, 0x0C	; 12
   12abe:	93 c0       	rjmp	.+294    	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   12ac0:	81 e0       	ldi	r24, 0x01	; 1
   12ac2:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   12ac6:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   12ac8:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
          if ((KeyChar>='1')&&(KeyChar<='4')){
   12acc:	81 53       	subi	r24, 0x31	; 49
   12ace:	84 30       	cpi	r24, 0x04	; 4
   12ad0:	28 f4       	brcc	.+10     	; 0x12adc <FMenuChangeMOP+0x2be>
		      BankIdx=KeyChar-'1';
   12ad2:	80 93 68 02 	sts	0x0268, r24
			  stChangeMOP=cmSelectFIP;
   12ad6:	89 e0       	ldi	r24, 0x09	; 9
   12ad8:	80 93 6a 02 	sts	0x026A, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   12adc:	17 3e       	cpi	r17, 0xE7	; 231
   12ade:	09 f0       	breq	.+2      	; 0x12ae2 <FMenuChangeMOP+0x2c4>
   12ae0:	c4 c2       	rjmp	.+1416   	; 0x1306a <FMenuChangeMOP+0x84c>
   12ae2:	81 e0       	ldi	r24, 0x01	; 1
   12ae4:	80 c0       	rjmp	.+256    	; 0x12be6 <FMenuChangeMOP+0x3c8>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   12ae6:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   12aea:	e5 e0       	ldi	r30, 0x05	; 5
   12aec:	ee 2e       	mov	r14, r30
   12aee:	f1 2c       	mov	r15, r1
   12af0:	ec 0e       	add	r14, r28
   12af2:	fd 1e       	adc	r15, r29
   12af4:	60 91 68 02 	lds	r22, 0x0268
   12af8:	8b e0       	ldi	r24, 0x0B	; 11
   12afa:	68 9f       	mul	r22, r24
   12afc:	b0 01       	movw	r22, r0
   12afe:	11 24       	eor	r1, r1
   12b00:	67 5f       	subi	r22, 0xF7	; 247
   12b02:	7e 4f       	sbci	r23, 0xFE	; 254
   12b04:	c7 01       	movw	r24, r14
   12b06:	4b e0       	ldi	r20, 0x0B	; 11
   12b08:	50 e0       	ldi	r21, 0x00	; 0
   12b0a:	22 e4       	ldi	r18, 0x42	; 66
   12b0c:	33 e1       	ldi	r19, 0x13	; 19
   12b0e:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12b12:	00 d0       	rcall	.+0      	; 0x12b14 <FMenuChangeMOP+0x2f6>
   12b14:	00 d0       	rcall	.+0      	; 0x12b16 <FMenuChangeMOP+0x2f8>
   12b16:	00 d0       	rcall	.+0      	; 0x12b18 <FMenuChangeMOP+0x2fa>
   12b18:	ed b7       	in	r30, 0x3d	; 61
   12b1a:	fe b7       	in	r31, 0x3e	; 62
   12b1c:	31 96       	adiw	r30, 0x01	; 1
   12b1e:	8e 01       	movw	r16, r28
   12b20:	00 5f       	subi	r16, 0xF0	; 240
   12b22:	1f 4f       	sbci	r17, 0xFF	; 255
   12b24:	ad b7       	in	r26, 0x3d	; 61
   12b26:	be b7       	in	r27, 0x3e	; 62
   12b28:	12 96       	adiw	r26, 0x02	; 2
   12b2a:	1c 93       	st	X, r17
   12b2c:	0e 93       	st	-X, r16
   12b2e:	11 97       	sbiw	r26, 0x01	; 1
   12b30:	85 e0       	ldi	r24, 0x05	; 5
   12b32:	9a e1       	ldi	r25, 0x1A	; 26
   12b34:	93 83       	std	Z+3, r25	; 0x03
   12b36:	82 83       	std	Z+2, r24	; 0x02
   12b38:	f5 82       	std	Z+5, r15	; 0x05
   12b3a:	e4 82       	std	Z+4, r14	; 0x04
   12b3c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   12b40:	ed b7       	in	r30, 0x3d	; 61
   12b42:	fe b7       	in	r31, 0x3e	; 62
   12b44:	36 96       	adiw	r30, 0x06	; 6
   12b46:	0f b6       	in	r0, 0x3f	; 63
   12b48:	f8 94       	cli
   12b4a:	fe bf       	out	0x3e, r31	; 62
   12b4c:	0f be       	out	0x3f, r0	; 63
   12b4e:	ed bf       	out	0x3d, r30	; 61
   12b50:	81 e0       	ldi	r24, 0x01	; 1
   12b52:	61 e0       	ldi	r22, 0x01	; 1
   12b54:	a8 01       	movw	r20, r16
   12b56:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   12b5a:	82 e0       	ldi	r24, 0x02	; 2
   12b5c:	61 e0       	ldi	r22, 0x01	; 1
   12b5e:	45 ef       	ldi	r20, 0xF5	; 245
   12b60:	59 e1       	ldi	r21, 0x19	; 25
   12b62:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12b66:	84 e0       	ldi	r24, 0x04	; 4
   12b68:	61 e0       	ldi	r22, 0x01	; 1
   12b6a:	40 ee       	ldi	r20, 0xE0	; 224
   12b6c:	59 e1       	ldi	r21, 0x19	; 25
   12b6e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   12b72:	8d e0       	ldi	r24, 0x0D	; 13
   12b74:	38 c0       	rjmp	.+112    	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
	 case cmInputBankSurcharge:
	      //uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
		  uiResult=UserInput(UI_NUMBER_L,2,14,strSurcharge,100,3);
   12b76:	82 e0       	ldi	r24, 0x02	; 2
   12b78:	62 e0       	ldi	r22, 0x02	; 2
   12b7a:	4e e0       	ldi	r20, 0x0E	; 14
   12b7c:	9e 01       	movw	r18, r28
   12b7e:	2f 5f       	subi	r18, 0xFF	; 255
   12b80:	3f 4f       	sbci	r19, 0xFF	; 255
   12b82:	04 e6       	ldi	r16, 0x64	; 100
   12b84:	10 e0       	ldi	r17, 0x00	; 0
   12b86:	73 e0       	ldi	r23, 0x03	; 3
   12b88:	e7 2e       	mov	r14, r23
   12b8a:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   12b8e:	83 30       	cpi	r24, 0x03	; 3
   12b90:	09 f4       	brne	.+2      	; 0x12b94 <FMenuChangeMOP+0x376>
   12b92:	c6 c0       	rjmp	.+396    	; 0x12d20 <FMenuChangeMOP+0x502>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   12b94:	81 30       	cpi	r24, 0x01	; 1
   12b96:	11 f4       	brne	.+4      	; 0x12b9c <FMenuChangeMOP+0x37e>
   12b98:	8b e0       	ldi	r24, 0x0B	; 11
   12b9a:	25 c0       	rjmp	.+74     	; 0x12be6 <FMenuChangeMOP+0x3c8>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12b9c:	84 30       	cpi	r24, 0x04	; 4
   12b9e:	21 f4       	brne	.+8      	; 0x12ba8 <FMenuChangeMOP+0x38a>
   12ba0:	61 e0       	ldi	r22, 0x01	; 1
   12ba2:	4b ec       	ldi	r20, 0xCB	; 203
   12ba4:	59 e1       	ldi	r21, 0x19	; 25
   12ba6:	07 c0       	rjmp	.+14     	; 0x12bb6 <FMenuChangeMOP+0x398>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12ba8:	85 30       	cpi	r24, 0x05	; 5
   12baa:	09 f0       	breq	.+2      	; 0x12bae <FMenuChangeMOP+0x390>
   12bac:	5e c2       	rjmp	.+1212   	; 0x1306a <FMenuChangeMOP+0x84c>
   12bae:	84 e0       	ldi	r24, 0x04	; 4
   12bb0:	61 e0       	ldi	r22, 0x01	; 1
   12bb2:	46 eb       	ldi	r20, 0xB6	; 182
   12bb4:	59 e1       	ldi	r21, 0x19	; 25
   12bb6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   12bba:	57 c2       	rjmp	.+1198   	; 0x1306a <FMenuChangeMOP+0x84c>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   12bbc:	80 91 ba 01 	lds	r24, 0x01BA
   12bc0:	82 30       	cpi	r24, 0x02	; 2
   12bc2:	61 f0       	breq	.+24     	; 0x12bdc <FMenuChangeMOP+0x3be>
   12bc4:	83 30       	cpi	r24, 0x03	; 3
   12bc6:	20 f4       	brcc	.+8      	; 0x12bd0 <FMenuChangeMOP+0x3b2>
   12bc8:	81 30       	cpi	r24, 0x01	; 1
   12bca:	09 f0       	breq	.+2      	; 0x12bce <FMenuChangeMOP+0x3b0>
   12bcc:	4e c2       	rjmp	.+1180   	; 0x1306a <FMenuChangeMOP+0x84c>
   12bce:	0a c0       	rjmp	.+20     	; 0x12be4 <FMenuChangeMOP+0x3c6>
   12bd0:	83 30       	cpi	r24, 0x03	; 3
   12bd2:	31 f0       	breq	.+12     	; 0x12be0 <FMenuChangeMOP+0x3c2>
   12bd4:	84 30       	cpi	r24, 0x04	; 4
   12bd6:	09 f0       	breq	.+2      	; 0x12bda <FMenuChangeMOP+0x3bc>
   12bd8:	48 c2       	rjmp	.+1168   	; 0x1306a <FMenuChangeMOP+0x84c>
   12bda:	04 c0       	rjmp	.+8      	; 0x12be4 <FMenuChangeMOP+0x3c6>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   12bdc:	81 e1       	ldi	r24, 0x11	; 17
   12bde:	03 c0       	rjmp	.+6      	; 0x12be6 <FMenuChangeMOP+0x3c8>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   12be0:	85 e1       	ldi	r24, 0x15	; 21
   12be2:	01 c0       	rjmp	.+2      	; 0x12be6 <FMenuChangeMOP+0x3c8>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   12be4:	82 e1       	ldi	r24, 0x12	; 18
   12be6:	80 93 6a 02 	sts	0x026A, r24
   12bea:	3f c2       	rjmp	.+1150   	; 0x1306a <FMenuChangeMOP+0x84c>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   12bec:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   12bf0:	81 e0       	ldi	r24, 0x01	; 1
   12bf2:	61 e0       	ldi	r22, 0x01	; 1
   12bf4:	47 ea       	ldi	r20, 0xA7	; 167
   12bf6:	59 e1       	ldi	r21, 0x19	; 25
   12bf8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   12bfc:	00 d0       	rcall	.+0      	; 0x12bfe <FMenuChangeMOP+0x3e0>
   12bfe:	00 d0       	rcall	.+0      	; 0x12c00 <FMenuChangeMOP+0x3e2>
   12c00:	00 d0       	rcall	.+0      	; 0x12c02 <FMenuChangeMOP+0x3e4>
   12c02:	ed b7       	in	r30, 0x3d	; 61
   12c04:	fe b7       	in	r31, 0x3e	; 62
   12c06:	31 96       	adiw	r30, 0x01	; 1
   12c08:	8e 01       	movw	r16, r28
   12c0a:	00 5f       	subi	r16, 0xF0	; 240
   12c0c:	1f 4f       	sbci	r17, 0xFF	; 255
   12c0e:	ad b7       	in	r26, 0x3d	; 61
   12c10:	be b7       	in	r27, 0x3e	; 62
   12c12:	12 96       	adiw	r26, 0x02	; 2
   12c14:	1c 93       	st	X, r17
   12c16:	0e 93       	st	-X, r16
   12c18:	11 97       	sbiw	r26, 0x01	; 1
   12c1a:	81 ea       	ldi	r24, 0xA1	; 161
   12c1c:	99 e1       	ldi	r25, 0x19	; 25
   12c1e:	93 83       	std	Z+3, r25	; 0x03
   12c20:	82 83       	std	Z+2, r24	; 0x02
   12c22:	82 ec       	ldi	r24, 0xC2	; 194
   12c24:	97 e0       	ldi	r25, 0x07	; 7
   12c26:	95 83       	std	Z+5, r25	; 0x05
   12c28:	84 83       	std	Z+4, r24	; 0x04
   12c2a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   12c2e:	ed b7       	in	r30, 0x3d	; 61
   12c30:	fe b7       	in	r31, 0x3e	; 62
   12c32:	36 96       	adiw	r30, 0x06	; 6
   12c34:	0f b6       	in	r0, 0x3f	; 63
   12c36:	f8 94       	cli
   12c38:	fe bf       	out	0x3e, r31	; 62
   12c3a:	0f be       	out	0x3f, r0	; 63
   12c3c:	ed bf       	out	0x3d, r30	; 61
   12c3e:	82 e0       	ldi	r24, 0x02	; 2
   12c40:	61 e0       	ldi	r22, 0x01	; 1
   12c42:	a8 01       	movw	r20, r16
   12c44:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   12c48:	84 e0       	ldi	r24, 0x04	; 4
   12c4a:	61 e0       	ldi	r22, 0x01	; 1
   12c4c:	4e e8       	ldi	r20, 0x8E	; 142
   12c4e:	59 e1       	ldi	r21, 0x19	; 25
   12c50:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  IsRFIDDetected=False;
   12c54:	10 92 9a 01 	sts	0x019A, r1
          stChangeMOP=cmRFIDCardInput;
   12c58:	83 e1       	ldi	r24, 0x13	; 19
   12c5a:	c5 cf       	rjmp	.-118    	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   12c5c:	81 e0       	ldi	r24, 0x01	; 1
   12c5e:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   12c62:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   12c64:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  if (KeyPressed==_KEY_ENTER){
   12c68:	17 3b       	cpi	r17, 0xB7	; 183
   12c6a:	11 f4       	brne	.+4      	; 0x12c70 <FMenuChangeMOP+0x452>
		      stChangeMOP=cmExitChangeMOP;
   12c6c:	8c e1       	ldi	r24, 0x1C	; 28
   12c6e:	03 c0       	rjmp	.+6      	; 0x12c76 <FMenuChangeMOP+0x458>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   12c70:	17 3e       	cpi	r17, 0xE7	; 231
   12c72:	19 f4       	brne	.+6      	; 0x12c7a <FMenuChangeMOP+0x45c>
   		      stChangeMOP=cmSelectFIP;
   12c74:	89 e0       	ldi	r24, 0x09	; 9
   12c76:	80 93 6a 02 	sts	0x026A, r24
			 }
          if (IsRFIDDetected==True){
   12c7a:	80 91 9a 01 	lds	r24, 0x019A
   12c7e:	81 30       	cpi	r24, 0x01	; 1
   12c80:	09 f0       	breq	.+2      	; 0x12c84 <FMenuChangeMOP+0x466>
   12c82:	f3 c1       	rjmp	.+998    	; 0x1306a <FMenuChangeMOP+0x84c>
		      IsRFIDDetected=False;
   12c84:	10 92 9a 01 	sts	0x019A, r1
			   stChangeMOP=cmProsesRFID;
   12c88:	84 e1       	ldi	r24, 0x14	; 20
   12c8a:	ad cf       	rjmp	.-166    	; 0x12be6 <FMenuChangeMOP+0x3c8>
   12c8c:	20 e0       	ldi	r18, 0x00	; 0
   12c8e:	30 e0       	ldi	r19, 0x00	; 0


void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12c90:	f9 01       	movw	r30, r18
   12c92:	ee 56       	subi	r30, 0x6E	; 110
   12c94:	f2 4f       	sbci	r31, 0xF2	; 242
   12c96:	d9 01       	movw	r26, r18
   12c98:	aa 59       	subi	r26, 0x9A	; 154
   12c9a:	b1 4f       	sbci	r27, 0xF1	; 241
   12c9c:	8c 91       	ld	r24, X
   12c9e:	80 83       	st	Z, r24
   12ca0:	2f 5f       	subi	r18, 0xFF	; 255
   12ca2:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   12ca4:	28 30       	cpi	r18, 0x08	; 8
   12ca6:	31 05       	cpc	r19, r1
   12ca8:	99 f7       	brne	.-26     	; 0x12c90 <FMenuChangeMOP+0x472>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   12caa:	10 92 9a 0d 	sts	0x0D9A, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   12cae:	00 d0       	rcall	.+0      	; 0x12cb0 <FMenuChangeMOP+0x492>
   12cb0:	00 d0       	rcall	.+0      	; 0x12cb2 <FMenuChangeMOP+0x494>
   12cb2:	00 d0       	rcall	.+0      	; 0x12cb4 <FMenuChangeMOP+0x496>
   12cb4:	ed b7       	in	r30, 0x3d	; 61
   12cb6:	fe b7       	in	r31, 0x3e	; 62
   12cb8:	31 96       	adiw	r30, 0x01	; 1
   12cba:	8e 01       	movw	r16, r28
   12cbc:	00 5f       	subi	r16, 0xF0	; 240
   12cbe:	1f 4f       	sbci	r17, 0xFF	; 255
   12cc0:	ad b7       	in	r26, 0x3d	; 61
   12cc2:	be b7       	in	r27, 0x3e	; 62
   12cc4:	12 96       	adiw	r26, 0x02	; 2
   12cc6:	1c 93       	st	X, r17
   12cc8:	0e 93       	st	-X, r16
   12cca:	11 97       	sbiw	r26, 0x01	; 1
   12ccc:	88 e8       	ldi	r24, 0x88	; 136
   12cce:	99 e1       	ldi	r25, 0x19	; 25
   12cd0:	93 83       	std	Z+3, r25	; 0x03
   12cd2:	82 83       	std	Z+2, r24	; 0x02
   12cd4:	82 e9       	ldi	r24, 0x92	; 146
   12cd6:	9d e0       	ldi	r25, 0x0D	; 13
   12cd8:	95 83       	std	Z+5, r25	; 0x05
   12cda:	84 83       	std	Z+4, r24	; 0x04
   12cdc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   12ce0:	ed b7       	in	r30, 0x3d	; 61
   12ce2:	fe b7       	in	r31, 0x3e	; 62
   12ce4:	36 96       	adiw	r30, 0x06	; 6
   12ce6:	0f b6       	in	r0, 0x3f	; 63
   12ce8:	f8 94       	cli
   12cea:	fe bf       	out	0x3e, r31	; 62
   12cec:	0f be       	out	0x3f, r0	; 63
   12cee:	ed bf       	out	0x3d, r30	; 61
   12cf0:	82 e0       	ldi	r24, 0x02	; 2
   12cf2:	61 e0       	ldi	r22, 0x01	; 1
   12cf4:	a8 01       	movw	r20, r16
   12cf6:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   12cfa:	83 e0       	ldi	r24, 0x03	; 3
   12cfc:	61 e0       	ldi	r22, 0x01	; 1
   12cfe:	41 e8       	ldi	r20, 0x81	; 129
   12d00:	59 e1       	ldi	r21, 0x19	; 25
   12d02:	0c c0       	rjmp	.+24     	; 0x12d1c <FMenuChangeMOP+0x4fe>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   12d04:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   12d08:	81 e0       	ldi	r24, 0x01	; 1
   12d0a:	61 e0       	ldi	r22, 0x01	; 1
   12d0c:	43 e7       	ldi	r20, 0x73	; 115
   12d0e:	59 e1       	ldi	r21, 0x19	; 25
   12d10:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   12d14:	83 e0       	ldi	r24, 0x03	; 3
   12d16:	61 e0       	ldi	r22, 0x01	; 1
   12d18:	4c e6       	ldi	r20, 0x6C	; 108
   12d1a:	59 e1       	ldi	r21, 0x19	; 25
   12d1c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stChangeMOP=cmGenerateData;
   12d20:	86 e1       	ldi	r24, 0x16	; 22
   12d22:	61 cf       	rjmp	.-318    	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
   12d24:	e7 ea       	ldi	r30, 0xA7	; 167
   12d26:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12d28:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12d2a:	8e e0       	ldi	r24, 0x0E	; 14
   12d2c:	ec 3b       	cpi	r30, 0xBC	; 188
   12d2e:	f8 07       	cpc	r31, r24
   12d30:	d9 f7       	brne	.-10     	; 0x12d28 <FMenuChangeMOP+0x50a>
   12d32:	e7 ea       	ldi	r30, 0xA7	; 167
   12d34:	fd e0       	ldi	r31, 0x0D	; 13
	     strMemory[i]=data;
   12d36:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12d38:	9d e0       	ldi	r25, 0x0D	; 13
   12d3a:	ec 3b       	cpi	r30, 0xBC	; 188
   12d3c:	f9 07       	cpc	r31, r25
   12d3e:	d9 f7       	brne	.-10     	; 0x12d36 <FMenuChangeMOP+0x518>
   12d40:	e6 e8       	ldi	r30, 0x86	; 134
   12d42:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
   12d44:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12d46:	a8 e0       	ldi	r26, 0x08	; 8
   12d48:	eb 39       	cpi	r30, 0x9B	; 155
   12d4a:	fa 07       	cpc	r31, r26
   12d4c:	d9 f7       	brne	.-10     	; 0x12d44 <FMenuChangeMOP+0x526>
   12d4e:	6e ea       	ldi	r22, 0xAE	; 174
   12d50:	e6 2e       	mov	r14, r22
   12d52:	63 e0       	ldi	r22, 0x03	; 3
   12d54:	f6 2e       	mov	r15, r22
	     strMemory[i]=data;
   12d56:	f7 01       	movw	r30, r14
   12d58:	11 92       	st	Z+, r1
   12d5a:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12d5c:	f3 ec       	ldi	r31, 0xC3	; 195
   12d5e:	ef 16       	cp	r14, r31
   12d60:	f3 e0       	ldi	r31, 0x03	; 3
   12d62:	ff 06       	cpc	r15, r31
   12d64:	c1 f7       	brne	.-16     	; 0x12d56 <FMenuChangeMOP+0x538>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   12d66:	80 91 ba 01 	lds	r24, 0x01BA
   12d6a:	82 30       	cpi	r24, 0x02	; 2
   12d6c:	f1 f0       	breq	.+60     	; 0x12daa <FMenuChangeMOP+0x58c>
   12d6e:	83 30       	cpi	r24, 0x03	; 3
   12d70:	20 f4       	brcc	.+8      	; 0x12d7a <FMenuChangeMOP+0x55c>
   12d72:	81 30       	cpi	r24, 0x01	; 1
   12d74:	09 f0       	breq	.+2      	; 0x12d78 <FMenuChangeMOP+0x55a>
   12d76:	ad c0       	rjmp	.+346    	; 0x12ed2 <FMenuChangeMOP+0x6b4>
   12d78:	07 c0       	rjmp	.+14     	; 0x12d88 <FMenuChangeMOP+0x56a>
   12d7a:	83 30       	cpi	r24, 0x03	; 3
   12d7c:	09 f4       	brne	.+2      	; 0x12d80 <FMenuChangeMOP+0x562>
   12d7e:	64 c0       	rjmp	.+200    	; 0x12e48 <FMenuChangeMOP+0x62a>
   12d80:	84 30       	cpi	r24, 0x04	; 4
   12d82:	09 f0       	breq	.+2      	; 0x12d86 <FMenuChangeMOP+0x568>
   12d84:	a6 c0       	rjmp	.+332    	; 0x12ed2 <FMenuChangeMOP+0x6b4>
   12d86:	75 c0       	rjmp	.+234    	; 0x12e72 <FMenuChangeMOP+0x654>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   12d88:	00 d0       	rcall	.+0      	; 0x12d8a <FMenuChangeMOP+0x56c>
   12d8a:	00 d0       	rcall	.+0      	; 0x12d8c <FMenuChangeMOP+0x56e>
   12d8c:	00 d0       	rcall	.+0      	; 0x12d8e <FMenuChangeMOP+0x570>
   12d8e:	ed b7       	in	r30, 0x3d	; 61
   12d90:	fe b7       	in	r31, 0x3e	; 62
   12d92:	31 96       	adiw	r30, 0x01	; 1
   12d94:	87 ea       	ldi	r24, 0xA7	; 167
   12d96:	9e e0       	ldi	r25, 0x0E	; 14
   12d98:	ad b7       	in	r26, 0x3d	; 61
   12d9a:	be b7       	in	r27, 0x3e	; 62
   12d9c:	12 96       	adiw	r26, 0x02	; 2
   12d9e:	9c 93       	st	X, r25
   12da0:	8e 93       	st	-X, r24
   12da2:	11 97       	sbiw	r26, 0x01	; 1
   12da4:	89 e6       	ldi	r24, 0x69	; 105
   12da6:	99 e1       	ldi	r25, 0x19	; 25
   12da8:	84 c0       	rjmp	.+264    	; 0x12eb2 <FMenuChangeMOP+0x694>
   12daa:	8e 01       	movw	r16, r28
   12dac:	0b 5f       	subi	r16, 0xFB	; 251
   12dae:	1f 4f       	sbci	r17, 0xFF	; 255
   12db0:	60 91 68 02 	lds	r22, 0x0268
   12db4:	8b e0       	ldi	r24, 0x0B	; 11
   12db6:	68 9f       	mul	r22, r24
   12db8:	b0 01       	movw	r22, r0
   12dba:	11 24       	eor	r1, r1
   12dbc:	67 5f       	subi	r22, 0xF7	; 247
   12dbe:	7e 4f       	sbci	r23, 0xFE	; 254
   12dc0:	c8 01       	movw	r24, r16
   12dc2:	4b e0       	ldi	r20, 0x0B	; 11
   12dc4:	50 e0       	ldi	r21, 0x00	; 0
   12dc6:	22 e4       	ldi	r18, 0x42	; 66
   12dc8:	33 e1       	ldi	r19, 0x13	; 19
   12dca:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12dce:	00 d0       	rcall	.+0      	; 0x12dd0 <FMenuChangeMOP+0x5b2>
   12dd0:	00 d0       	rcall	.+0      	; 0x12dd2 <FMenuChangeMOP+0x5b4>
   12dd2:	00 d0       	rcall	.+0      	; 0x12dd4 <FMenuChangeMOP+0x5b6>
   12dd4:	ed b7       	in	r30, 0x3d	; 61
   12dd6:	fe b7       	in	r31, 0x3e	; 62
   12dd8:	31 96       	adiw	r30, 0x01	; 1
   12dda:	ce 01       	movw	r24, r28
   12ddc:	40 96       	adiw	r24, 0x10	; 16
   12dde:	ad b7       	in	r26, 0x3d	; 61
   12de0:	be b7       	in	r27, 0x3e	; 62
   12de2:	12 96       	adiw	r26, 0x02	; 2
   12de4:	9c 93       	st	X, r25
   12de6:	8e 93       	st	-X, r24
   12de8:	11 97       	sbiw	r26, 0x01	; 1
   12dea:	86 e6       	ldi	r24, 0x66	; 102
   12dec:	99 e1       	ldi	r25, 0x19	; 25
   12dee:	93 83       	std	Z+3, r25	; 0x03
   12df0:	82 83       	std	Z+2, r24	; 0x02
   12df2:	15 83       	std	Z+5, r17	; 0x05
   12df4:	04 83       	std	Z+4, r16	; 0x04
   12df6:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   12dfa:	ed b7       	in	r30, 0x3d	; 61
   12dfc:	fe b7       	in	r31, 0x3e	; 62
   12dfe:	31 96       	adiw	r30, 0x01	; 1
   12e00:	87 ea       	ldi	r24, 0xA7	; 167
   12e02:	9e e0       	ldi	r25, 0x0E	; 14
   12e04:	ad b7       	in	r26, 0x3d	; 61
   12e06:	be b7       	in	r27, 0x3e	; 62
   12e08:	12 96       	adiw	r26, 0x02	; 2
   12e0a:	9c 93       	st	X, r25
   12e0c:	8e 93       	st	-X, r24
   12e0e:	11 97       	sbiw	r26, 0x01	; 1
   12e10:	83 e6       	ldi	r24, 0x63	; 99
   12e12:	99 e1       	ldi	r25, 0x19	; 25
   12e14:	93 83       	std	Z+3, r25	; 0x03
   12e16:	82 83       	std	Z+2, r24	; 0x02
   12e18:	15 83       	std	Z+5, r17	; 0x05
   12e1a:	04 83       	std	Z+4, r16	; 0x04
   12e1c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   12e20:	ed b7       	in	r30, 0x3d	; 61
   12e22:	fe b7       	in	r31, 0x3e	; 62
   12e24:	31 96       	adiw	r30, 0x01	; 1
   12e26:	8b ee       	ldi	r24, 0xEB	; 235
   12e28:	9f ef       	ldi	r25, 0xFF	; 255
   12e2a:	e8 0e       	add	r14, r24
   12e2c:	f9 1e       	adc	r15, r25
   12e2e:	ad b7       	in	r26, 0x3d	; 61
   12e30:	be b7       	in	r27, 0x3e	; 62
   12e32:	12 96       	adiw	r26, 0x02	; 2
   12e34:	fc 92       	st	X, r15
   12e36:	ee 92       	st	-X, r14
   12e38:	11 97       	sbiw	r26, 0x01	; 1
   12e3a:	80 e6       	ldi	r24, 0x60	; 96
   12e3c:	99 e1       	ldi	r25, 0x19	; 25
   12e3e:	93 83       	std	Z+3, r25	; 0x03
   12e40:	82 83       	std	Z+2, r24	; 0x02
   12e42:	ce 01       	movw	r24, r28
   12e44:	01 96       	adiw	r24, 0x01	; 1
   12e46:	39 c0       	rjmp	.+114    	; 0x12eba <FMenuChangeMOP+0x69c>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   12e48:	00 d0       	rcall	.+0      	; 0x12e4a <FMenuChangeMOP+0x62c>
   12e4a:	00 d0       	rcall	.+0      	; 0x12e4c <FMenuChangeMOP+0x62e>
   12e4c:	00 d0       	rcall	.+0      	; 0x12e4e <FMenuChangeMOP+0x630>
   12e4e:	ed b7       	in	r30, 0x3d	; 61
   12e50:	fe b7       	in	r31, 0x3e	; 62
   12e52:	31 96       	adiw	r30, 0x01	; 1
   12e54:	87 ea       	ldi	r24, 0xA7	; 167
   12e56:	9e e0       	ldi	r25, 0x0E	; 14
   12e58:	ad b7       	in	r26, 0x3d	; 61
   12e5a:	be b7       	in	r27, 0x3e	; 62
   12e5c:	12 96       	adiw	r26, 0x02	; 2
   12e5e:	9c 93       	st	X, r25
   12e60:	8e 93       	st	-X, r24
   12e62:	11 97       	sbiw	r26, 0x01	; 1
   12e64:	8d e5       	ldi	r24, 0x5D	; 93
   12e66:	99 e1       	ldi	r25, 0x19	; 25
   12e68:	93 83       	std	Z+3, r25	; 0x03
   12e6a:	82 83       	std	Z+2, r24	; 0x02
   12e6c:	81 e5       	ldi	r24, 0x51	; 81
   12e6e:	9e e0       	ldi	r25, 0x0E	; 14
   12e70:	24 c0       	rjmp	.+72     	; 0x12eba <FMenuChangeMOP+0x69c>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   12e72:	00 d0       	rcall	.+0      	; 0x12e74 <FMenuChangeMOP+0x656>
   12e74:	00 d0       	rcall	.+0      	; 0x12e76 <FMenuChangeMOP+0x658>
   12e76:	87 ea       	ldi	r24, 0xA7	; 167
   12e78:	9e e0       	ldi	r25, 0x0E	; 14
   12e7a:	ad b7       	in	r26, 0x3d	; 61
   12e7c:	be b7       	in	r27, 0x3e	; 62
   12e7e:	12 96       	adiw	r26, 0x02	; 2
   12e80:	9c 93       	st	X, r25
   12e82:	8e 93       	st	-X, r24
   12e84:	11 97       	sbiw	r26, 0x01	; 1
   12e86:	83 e5       	ldi	r24, 0x53	; 83
   12e88:	99 e1       	ldi	r25, 0x19	; 25
   12e8a:	14 96       	adiw	r26, 0x04	; 4
   12e8c:	9c 93       	st	X, r25
   12e8e:	8e 93       	st	-X, r24
   12e90:	13 97       	sbiw	r26, 0x03	; 3
   12e92:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   12e96:	00 d0       	rcall	.+0      	; 0x12e98 <FMenuChangeMOP+0x67a>
   12e98:	ed b7       	in	r30, 0x3d	; 61
   12e9a:	fe b7       	in	r31, 0x3e	; 62
   12e9c:	31 96       	adiw	r30, 0x01	; 1
   12e9e:	87 ea       	ldi	r24, 0xA7	; 167
   12ea0:	9d e0       	ldi	r25, 0x0D	; 13
   12ea2:	ad b7       	in	r26, 0x3d	; 61
   12ea4:	be b7       	in	r27, 0x3e	; 62
   12ea6:	12 96       	adiw	r26, 0x02	; 2
   12ea8:	9c 93       	st	X, r25
   12eaa:	8e 93       	st	-X, r24
   12eac:	11 97       	sbiw	r26, 0x01	; 1
   12eae:	80 e5       	ldi	r24, 0x50	; 80
   12eb0:	99 e1       	ldi	r25, 0x19	; 25
   12eb2:	93 83       	std	Z+3, r25	; 0x03
   12eb4:	82 83       	std	Z+2, r24	; 0x02
   12eb6:	82 e9       	ldi	r24, 0x92	; 146
   12eb8:	9d e0       	ldi	r25, 0x0D	; 13
   12eba:	95 83       	std	Z+5, r25	; 0x05
   12ebc:	84 83       	std	Z+4, r24	; 0x04
   12ebe:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   12ec2:	ed b7       	in	r30, 0x3d	; 61
   12ec4:	fe b7       	in	r31, 0x3e	; 62
   12ec6:	36 96       	adiw	r30, 0x06	; 6
   12ec8:	0f b6       	in	r0, 0x3f	; 63
   12eca:	f8 94       	cli
   12ecc:	fe bf       	out	0x3e, r31	; 62
   12ece:	0f be       	out	0x3f, r0	; 63
   12ed0:	ed bf       	out	0x3d, r30	; 61
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
   12ed2:	00 d0       	rcall	.+0      	; 0x12ed4 <FMenuChangeMOP+0x6b6>
   12ed4:	00 d0       	rcall	.+0      	; 0x12ed6 <FMenuChangeMOP+0x6b8>
   12ed6:	00 d0       	rcall	.+0      	; 0x12ed8 <FMenuChangeMOP+0x6ba>
   12ed8:	ed b7       	in	r30, 0x3d	; 61
   12eda:	fe b7       	in	r31, 0x3e	; 62
   12edc:	31 96       	adiw	r30, 0x01	; 1
   12ede:	89 e5       	ldi	r24, 0x59	; 89
   12ee0:	97 e0       	ldi	r25, 0x07	; 7
   12ee2:	ad b7       	in	r26, 0x3d	; 61
   12ee4:	be b7       	in	r27, 0x3e	; 62
   12ee6:	12 96       	adiw	r26, 0x02	; 2
   12ee8:	9c 93       	st	X, r25
   12eea:	8e 93       	st	-X, r24
   12eec:	11 97       	sbiw	r26, 0x01	; 1
   12eee:	8f e4       	ldi	r24, 0x4F	; 79
   12ef0:	9e e0       	ldi	r25, 0x0E	; 14
   12ef2:	93 83       	std	Z+3, r25	; 0x03
   12ef4:	82 83       	std	Z+2, r24	; 0x02
   12ef6:	80 91 ba 01 	lds	r24, 0x01BA
   12efa:	84 83       	std	Z+4, r24	; 0x04
   12efc:	15 82       	std	Z+5, r1	; 0x05
   12efe:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
		  AddSpaceLead(strRef1,20);
   12f02:	ed b7       	in	r30, 0x3d	; 61
   12f04:	fe b7       	in	r31, 0x3e	; 62
   12f06:	36 96       	adiw	r30, 0x06	; 6
   12f08:	0f b6       	in	r0, 0x3f	; 63
   12f0a:	f8 94       	cli
   12f0c:	fe bf       	out	0x3e, r31	; 62
   12f0e:	0f be       	out	0x3f, r0	; 63
   12f10:	ed bf       	out	0x3d, r30	; 61
   12f12:	87 ea       	ldi	r24, 0xA7	; 167
   12f14:	9e e0       	ldi	r25, 0x0E	; 14
   12f16:	64 e1       	ldi	r22, 0x14	; 20
   12f18:	0e 94 b7 30 	call	0x616e	; 0x616e <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   12f1c:	87 ea       	ldi	r24, 0xA7	; 167
   12f1e:	9d e0       	ldi	r25, 0x0D	; 13
   12f20:	64 e1       	ldi	r22, 0x14	; 20
   12f22:	0e 94 b7 30 	call	0x616e	; 0x616e <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   12f26:	86 e8       	ldi	r24, 0x86	; 134
   12f28:	98 e0       	ldi	r25, 0x08	; 8
   12f2a:	64 e1       	ldi	r22, 0x14	; 20
   12f2c:	0e 94 b7 30 	call	0x616e	; 0x616e <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   12f30:	8e ea       	ldi	r24, 0xAE	; 174
   12f32:	93 e0       	ldi	r25, 0x03	; 3
   12f34:	64 e1       	ldi	r22, 0x14	; 20
   12f36:	0e 94 b7 30 	call	0x616e	; 0x616e <AddSpaceLead>
		  iWait=0;
   12f3a:	10 92 66 02 	sts	0x0266, r1
		  IsMessage09=False;
   12f3e:	10 92 a5 01 	sts	0x01A5, r1
		  stChangeMOP=cmSendMessage32;	      
   12f42:	87 e1       	ldi	r24, 0x17	; 23
   12f44:	50 ce       	rjmp	.-864    	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   12f46:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <sendMessage32>
		  iLoop=0;
   12f4a:	10 92 65 02 	sts	0x0265, r1
   12f4e:	10 92 64 02 	sts	0x0264, r1
		  iPos=0;
   12f52:	10 92 67 02 	sts	0x0267, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   12f56:	83 e0       	ldi	r24, 0x03	; 3
   12f58:	61 e0       	ldi	r22, 0x01	; 1
   12f5a:	44 e4       	ldi	r20, 0x44	; 68
   12f5c:	59 e1       	ldi	r21, 0x19	; 25
   12f5e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   12f62:	88 e1       	ldi	r24, 0x18	; 24
   12f64:	40 ce       	rjmp	.-896    	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   12f66:	80 91 64 02 	lds	r24, 0x0264
   12f6a:	90 91 65 02 	lds	r25, 0x0265
   12f6e:	01 96       	adiw	r24, 0x01	; 1
   12f70:	90 93 65 02 	sts	0x0265, r25
   12f74:	80 93 64 02 	sts	0x0264, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   12f78:	68 e9       	ldi	r22, 0x98	; 152
   12f7a:	7a e3       	ldi	r23, 0x3A	; 58
   12f7c:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
   12f80:	89 2b       	or	r24, r25
   12f82:	19 f5       	brne	.+70     	; 0x12fca <FMenuChangeMOP+0x7ac>
			 if (iPos<5){
   12f84:	60 91 67 02 	lds	r22, 0x0267
   12f88:	65 30       	cpi	r22, 0x05	; 5
   12f8a:	68 f4       	brcc	.+26     	; 0x12fa6 <FMenuChangeMOP+0x788>
				 lcd_xy(3,(13+iPos));_lcd('.');
   12f8c:	63 5f       	subi	r22, 0xF3	; 243
   12f8e:	83 e0       	ldi	r24, 0x03	; 3
   12f90:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
   12f94:	8e e2       	ldi	r24, 0x2E	; 46
   12f96:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
				 iPos++;
   12f9a:	80 91 67 02 	lds	r24, 0x0267
   12f9e:	8f 5f       	subi	r24, 0xFF	; 255
   12fa0:	80 93 67 02 	sts	0x0267, r24
   12fa4:	12 c0       	rjmp	.+36     	; 0x12fca <FMenuChangeMOP+0x7ac>
				}
			 else{
				 iPos=0;
   12fa6:	10 92 67 02 	sts	0x0267, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   12faa:	83 e0       	ldi	r24, 0x03	; 3
   12fac:	6d e0       	ldi	r22, 0x0D	; 13
   12fae:	4c e3       	ldi	r20, 0x3C	; 60
   12fb0:	59 e1       	ldi	r21, 0x19	; 25
   12fb2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   12fb6:	90 91 66 02 	lds	r25, 0x0266
   12fba:	95 30       	cpi	r25, 0x05	; 5
   12fbc:	18 f4       	brcc	.+6      	; 0x12fc4 <FMenuChangeMOP+0x7a6>
   12fbe:	87 e1       	ldi	r24, 0x17	; 23
   12fc0:	80 93 6a 02 	sts	0x026A, r24
				iWait++;
   12fc4:	9f 5f       	subi	r25, 0xFF	; 255
   12fc6:	90 93 66 02 	sts	0x0266, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   12fca:	80 91 66 02 	lds	r24, 0x0266
   12fce:	86 30       	cpi	r24, 0x06	; 6
   12fd0:	18 f0       	brcs	.+6      	; 0x12fd8 <FMenuChangeMOP+0x7ba>
   12fd2:	8a e1       	ldi	r24, 0x1A	; 26
   12fd4:	80 93 6a 02 	sts	0x026A, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   12fd8:	80 91 a5 01 	lds	r24, 0x01A5
   12fdc:	81 30       	cpi	r24, 0x01	; 1
   12fde:	19 f4       	brne	.+6      	; 0x12fe6 <FMenuChangeMOP+0x7c8>
   12fe0:	89 e1       	ldi	r24, 0x19	; 25
   12fe2:	80 93 6a 02 	sts	0x026A, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   12fe6:	80 91 a1 01 	lds	r24, 0x01A1
   12fea:	81 30       	cpi	r24, 0x01	; 1
   12fec:	f1 f5       	brne	.+124    	; 0x1306a <FMenuChangeMOP+0x84c>
   12fee:	37 c0       	rjmp	.+110    	; 0x1305e <FMenuChangeMOP+0x840>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   12ff0:	10 92 a5 01 	sts	0x01A5, r1
	      msgResult=procMessage09();
   12ff4:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <procMessage09>
		  lcd_clear();
   12ff8:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   12ffc:	81 e0       	ldi	r24, 0x01	; 1
   12ffe:	61 e0       	ldi	r22, 0x01	; 1
   13000:	4b e9       	ldi	r20, 0x9B	; 155
   13002:	58 e0       	ldi	r21, 0x08	; 8
   13004:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   13008:	82 e0       	ldi	r24, 0x02	; 2
   1300a:	61 e0       	ldi	r22, 0x01	; 1
   1300c:	4c ea       	ldi	r20, 0xAC	; 172
   1300e:	57 e0       	ldi	r21, 0x07	; 7
   13010:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   13014:	83 e0       	ldi	r24, 0x03	; 3
   13016:	61 e0       	ldi	r22, 0x01	; 1
   13018:	45 e2       	ldi	r20, 0x25	; 37
   1301a:	58 e0       	ldi	r21, 0x08	; 8
   1301c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   13020:	84 e0       	ldi	r24, 0x04	; 4
   13022:	61 e0       	ldi	r22, 0x01	; 1
   13024:	43 ee       	ldi	r20, 0xE3	; 227
   13026:	5d e0       	ldi	r21, 0x0D	; 13
   13028:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
   1302c:	0e c0       	rjmp	.+28     	; 0x1304a <FMenuChangeMOP+0x82c>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   1302e:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   13032:	82 e0       	ldi	r24, 0x02	; 2
   13034:	61 e0       	ldi	r22, 0x01	; 1
   13036:	4f e2       	ldi	r20, 0x2F	; 47
   13038:	59 e1       	ldi	r21, 0x19	; 25
   1303a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   1303e:	83 e0       	ldi	r24, 0x03	; 3
   13040:	61 e0       	ldi	r22, 0x01	; 1
   13042:	42 e2       	ldi	r20, 0x22	; 34
   13044:	59 e1       	ldi	r21, 0x19	; 25
   13046:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  TimDisplay=0;
   1304a:	10 92 94 01 	sts	0x0194, r1
          stChangeMOP=cmDelayMOP;
   1304e:	8b e1       	ldi	r24, 0x1B	; 27
   13050:	ca cd       	rjmp	.-1132   	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   13052:	80 91 94 01 	lds	r24, 0x0194
   13056:	8a 30       	cpi	r24, 0x0A	; 10
   13058:	40 f0       	brcs	.+16     	; 0x1306a <FMenuChangeMOP+0x84c>
   1305a:	8c e1       	ldi	r24, 0x1C	; 28
   1305c:	c4 cd       	rjmp	.-1144   	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   1305e:	8d e1       	ldi	r24, 0x1D	; 29
   13060:	c2 cd       	rjmp	.-1148   	; 0x12be6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   13062:	10 92 6a 02 	sts	0x026A, r1
   13066:	81 e0       	ldi	r24, 0x01	; 1
   13068:	01 c0       	rjmp	.+2      	; 0x1306c <FMenuChangeMOP+0x84e>
   1306a:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   1306c:	a3 96       	adiw	r28, 0x23	; 35
   1306e:	0f b6       	in	r0, 0x3f	; 63
   13070:	f8 94       	cli
   13072:	de bf       	out	0x3e, r29	; 62
   13074:	0f be       	out	0x3f, r0	; 63
   13076:	cd bf       	out	0x3d, r28	; 61
   13078:	cf 91       	pop	r28
   1307a:	df 91       	pop	r29
   1307c:	1f 91       	pop	r17
   1307e:	0f 91       	pop	r16
   13080:	ff 90       	pop	r15
   13082:	ef 90       	pop	r14
   13084:	df 90       	pop	r13
   13086:	cf 90       	pop	r12
   13088:	bf 90       	pop	r11
   1308a:	af 90       	pop	r10
   1308c:	08 95       	ret

0001308e <FMenuLocalAccount>:
	 __key_lgtcnt = 0; 
	 PORTG=PORTG&0b11111101;
}


char FMenuLocalAccount(){
   1308e:	6f 92       	push	r6
   13090:	7f 92       	push	r7
   13092:	8f 92       	push	r8
   13094:	9f 92       	push	r9
   13096:	af 92       	push	r10
   13098:	bf 92       	push	r11
   1309a:	cf 92       	push	r12
   1309c:	df 92       	push	r13
   1309e:	ef 92       	push	r14
   130a0:	ff 92       	push	r15
   130a2:	0f 93       	push	r16
   130a4:	1f 93       	push	r17
   130a6:	df 93       	push	r29
   130a8:	cf 93       	push	r28
   130aa:	cd b7       	in	r28, 0x3d	; 61
   130ac:	de b7       	in	r29, 0x3e	; 62
   130ae:	e4 97       	sbiw	r28, 0x34	; 52
   130b0:	0f b6       	in	r0, 0x3f	; 63
   130b2:	f8 94       	cli
   130b4:	de bf       	out	0x3e, r29	; 62
   130b6:	0f be       	out	0x3f, r0	; 63
   130b8:	cd bf       	out	0x3d, r28	; 61
       char ProductName[11],strName[21];//,strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   130ba:	80 91 4c 01 	lds	r24, 0x014C
   130be:	90 e0       	ldi	r25, 0x00	; 0
   130c0:	fc 01       	movw	r30, r24
   130c2:	31 97       	sbiw	r30, 0x01	; 1
   130c4:	ef 31       	cpi	r30, 0x1F	; 31
   130c6:	f1 05       	cpc	r31, r1
   130c8:	10 f0       	brcs	.+4      	; 0x130ce <FMenuLocalAccount+0x40>
   130ca:	0c 94 f3 a0 	jmp	0x141e6	; 0x141e6 <FMenuLocalAccount+0x1158>
   130ce:	e5 51       	subi	r30, 0x15	; 21
   130d0:	ff 4f       	sbci	r31, 0xFF	; 255
   130d2:	ee 0f       	add	r30, r30
   130d4:	ff 1f       	adc	r31, r31
   130d6:	05 90       	lpm	r0, Z+
   130d8:	f4 91       	lpm	r31, Z+
   130da:	e0 2d       	mov	r30, r0
   130dc:	09 94       	ijmp
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
   130de:	81 e0       	ldi	r24, 0x01	; 1
   130e0:	80 93 b7 02 	sts	0x02B7, r24
	 __key_lgtcnt = 0; 
   130e4:	10 92 b8 02 	sts	0x02B8, r1
	 PORTG=PORTG&0b11111101;
   130e8:	80 91 65 00 	lds	r24, 0x0065
   130ec:	8d 7f       	andi	r24, 0xFD	; 253
   130ee:	80 93 65 00 	sts	0x0065, r24
   130f2:	20 e0       	ldi	r18, 0x00	; 0
   130f4:	30 e0       	ldi	r19, 0x00	; 0


void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   130f6:	f9 01       	movw	r30, r18
   130f8:	ee 56       	subi	r30, 0x6E	; 110
   130fa:	f2 4f       	sbci	r31, 0xF2	; 242
   130fc:	d9 01       	movw	r26, r18
   130fe:	aa 59       	subi	r26, 0x9A	; 154
   13100:	b1 4f       	sbci	r27, 0xF1	; 241
   13102:	8c 91       	ld	r24, X
   13104:	80 83       	st	Z, r24
   13106:	2f 5f       	subi	r18, 0xFF	; 255
   13108:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   1310a:	28 30       	cpi	r18, 0x08	; 8
   1310c:	31 05       	cpc	r19, r1
   1310e:	99 f7       	brne	.-26     	; 0x130f6 <FMenuLocalAccount+0x68>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   13110:	10 92 9a 0d 	sts	0x0D9A, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   13114:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   13118:	81 e0       	ldi	r24, 0x01	; 1
   1311a:	61 e0       	ldi	r22, 0x01	; 1
   1311c:	48 e7       	ldi	r20, 0x78	; 120
   1311e:	51 e2       	ldi	r21, 0x21	; 33
   13120:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   13124:	00 d0       	rcall	.+0      	; 0x13126 <FMenuLocalAccount+0x98>
   13126:	00 d0       	rcall	.+0      	; 0x13128 <FMenuLocalAccount+0x9a>
   13128:	00 d0       	rcall	.+0      	; 0x1312a <FMenuLocalAccount+0x9c>
   1312a:	ed b7       	in	r30, 0x3d	; 61
   1312c:	fe b7       	in	r31, 0x3e	; 62
   1312e:	31 96       	adiw	r30, 0x01	; 1
   13130:	8e 01       	movw	r16, r28
   13132:	04 5f       	subi	r16, 0xF4	; 244
   13134:	1f 4f       	sbci	r17, 0xFF	; 255
   13136:	ad b7       	in	r26, 0x3d	; 61
   13138:	be b7       	in	r27, 0x3e	; 62
   1313a:	12 96       	adiw	r26, 0x02	; 2
   1313c:	1c 93       	st	X, r17
   1313e:	0e 93       	st	-X, r16
   13140:	11 97       	sbiw	r26, 0x01	; 1
   13142:	82 e7       	ldi	r24, 0x72	; 114
   13144:	91 e2       	ldi	r25, 0x21	; 33
   13146:	93 83       	std	Z+3, r25	; 0x03
   13148:	82 83       	std	Z+2, r24	; 0x02
   1314a:	82 e9       	ldi	r24, 0x92	; 146
   1314c:	9d e0       	ldi	r25, 0x0D	; 13
   1314e:	95 83       	std	Z+5, r25	; 0x05
   13150:	84 83       	std	Z+4, r24	; 0x04
   13152:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13156:	ed b7       	in	r30, 0x3d	; 61
   13158:	fe b7       	in	r31, 0x3e	; 62
   1315a:	36 96       	adiw	r30, 0x06	; 6
   1315c:	0f b6       	in	r0, 0x3f	; 63
   1315e:	f8 94       	cli
   13160:	fe bf       	out	0x3e, r31	; 62
   13162:	0f be       	out	0x3f, r0	; 63
   13164:	ed bf       	out	0x3d, r30	; 61
   13166:	82 e0       	ldi	r24, 0x02	; 2
   13168:	61 e0       	ldi	r22, 0x01	; 1
   1316a:	a8 01       	movw	r20, r16
   1316c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   13170:	83 e0       	ldi	r24, 0x03	; 3
   13172:	61 e0       	ldi	r22, 0x01	; 1
   13174:	4b e6       	ldi	r20, 0x6B	; 107
   13176:	51 e2       	ldi	r21, 0x21	; 33
   13178:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				iPos=0;//iLoop=0;
   1317c:	10 92 9f 02 	sts	0x029F, r1
				IsFullAuthorized=False;
   13180:	10 92 8f 02 	sts	0x028F, r1
		        stLocalAccount=laSendID;
   13184:	82 e0       	ldi	r24, 0x02	; 2
   13186:	0b c0       	rjmp	.+22     	; 0x1319e <FMenuLocalAccount+0x110>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   13188:	10 92 a7 01 	sts	0x01A7, r1
                sendMessage56();
   1318c:	0e 94 63 50 	call	0xa0c6	; 0xa0c6 <sendMessage56>
				iWait=0;iPos=0;
   13190:	10 92 9e 02 	sts	0x029E, r1
   13194:	10 92 9f 02 	sts	0x029F, r1
				//iLoop=0;
				TimSend=0;
   13198:	10 92 91 0e 	sts	0x0E91, r1
				stLocalAccount=laWaitMessage57;
   1319c:	83 e0       	ldi	r24, 0x03	; 3
   1319e:	80 93 4c 01 	sts	0x014C, r24
   131a2:	0c 94 f3 a0 	jmp	0x141e6	; 0x141e6 <FMenuLocalAccount+0x1158>
						 system_beep(2);
						 stLocalAccount=laConTimout;
				}
				*/
				
		        iLoop++;
   131a6:	80 91 8d 02 	lds	r24, 0x028D
   131aa:	90 91 8e 02 	lds	r25, 0x028E
   131ae:	01 96       	adiw	r24, 0x01	; 1
   131b0:	90 93 8e 02 	sts	0x028E, r25
   131b4:	80 93 8d 02 	sts	0x028D, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   131b8:	68 e9       	ldi	r22, 0x98	; 152
   131ba:	7a e3       	ldi	r23, 0x3A	; 58
   131bc:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
   131c0:	89 2b       	or	r24, r25
   131c2:	e1 f4       	brne	.+56     	; 0x131fc <FMenuLocalAccount+0x16e>
				   if (iPos<5){
   131c4:	60 91 9f 02 	lds	r22, 0x029F
   131c8:	65 30       	cpi	r22, 0x05	; 5
   131ca:	58 f4       	brcc	.+22     	; 0x131e2 <FMenuLocalAccount+0x154>
					   lcd_put(3,(8+iPos),'.');
   131cc:	68 5f       	subi	r22, 0xF8	; 248
   131ce:	83 e0       	ldi	r24, 0x03	; 3
   131d0:	4e e2       	ldi	r20, 0x2E	; 46
   131d2:	0e 94 bf a7 	call	0x14f7e	; 0x14f7e <lcd_put>
				       iPos++;
   131d6:	80 91 9f 02 	lds	r24, 0x029F
   131da:	8f 5f       	subi	r24, 0xFF	; 255
   131dc:	80 93 9f 02 	sts	0x029F, r24
   131e0:	0d c0       	rjmp	.+26     	; 0x131fc <FMenuLocalAccount+0x16e>
					   }
				   else{
				       iPos=0;
   131e2:	10 92 9f 02 	sts	0x029F, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   131e6:	83 e0       	ldi	r24, 0x03	; 3
   131e8:	69 e0       	ldi	r22, 0x09	; 9
   131ea:	43 e6       	ldi	r20, 0x63	; 99
   131ec:	51 e2       	ldi	r21, 0x21	; 33
   131ee:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					   iWait++;
   131f2:	80 91 9e 02 	lds	r24, 0x029E
   131f6:	8f 5f       	subi	r24, 0xFF	; 255
   131f8:	80 93 9e 02 	sts	0x029E, r24
					   }
				}
				if (iWait>3){
   131fc:	80 91 9e 02 	lds	r24, 0x029E
   13200:	84 30       	cpi	r24, 0x04	; 4
   13202:	50 f0       	brcs	.+20     	; 0x13218 <FMenuLocalAccount+0x18a>
				    stLocalAccount=laConTimout;
   13204:	84 e0       	ldi	r24, 0x04	; 4
   13206:	80 93 4c 01 	sts	0x014C, r24
					TimLocAcc=0;
   1320a:	10 92 bc 01 	sts	0x01BC, r1
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1320e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13210:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13212:	82 e0       	ldi	r24, 0x02	; 2
   13214:	80 93 be 01 	sts	0x01BE, r24
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
                 
				if (IsMessage57==True){
   13218:	80 91 a7 01 	lds	r24, 0x01A7
   1321c:	81 30       	cpi	r24, 0x01	; 1
   1321e:	09 f0       	breq	.+2      	; 0x13222 <FMenuLocalAccount+0x194>
   13220:	e2 c7       	rjmp	.+4036   	; 0x141e6 <FMenuLocalAccount+0x1158>
				    IsMessage57=False;
   13222:	10 92 a7 01 	sts	0x01A7, r1
				    stLocalAccount=laProcMessage57;
   13226:	85 e0       	ldi	r24, 0x05	; 5
   13228:	ba cf       	rjmp	.-140    	; 0x1319e <FMenuLocalAccount+0x110>
					}
		        break;
           case laConTimout:
		        //IsErrorTCPIP=True;
				lcd_printf(3,1,PSTR("Sending Failed      "));
   1322a:	83 e0       	ldi	r24, 0x03	; 3
   1322c:	61 e0       	ldi	r22, 0x01	; 1
   1322e:	4e e4       	ldi	r20, 0x4E	; 78
   13230:	51 e2       	ldi	r21, 0x21	; 33
   13232:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   13236:	84 e0       	ldi	r24, 0x04	; 4
   13238:	61 e0       	ldi	r22, 0x01	; 1
   1323a:	49 e3       	ldi	r20, 0x39	; 57
   1323c:	51 e2       	ldi	r21, 0x21	; 33
   1323e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   13242:	80 91 bc 01 	lds	r24, 0x01BC
   13246:	83 30       	cpi	r24, 0x03	; 3
   13248:	08 f4       	brcc	.+2      	; 0x1324c <FMenuLocalAccount+0x1be>
   1324a:	cd c7       	rjmp	.+3994   	; 0x141e6 <FMenuLocalAccount+0x1158>
   1324c:	c2 c7       	rjmp	.+3972   	; 0x141d2 <FMenuLocalAccount+0x1144>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   1324e:	83 e0       	ldi	r24, 0x03	; 3
   13250:	61 e0       	ldi	r22, 0x01	; 1
   13252:	44 e2       	ldi	r20, 0x24	; 36
   13254:	51 e2       	ldi	r21, 0x21	; 33
   13256:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   1325a:	0e 94 74 29 	call	0x52e8	; 0x52e8 <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   1325e:	81 30       	cpi	r24, 0x01	; 1
   13260:	29 f0       	breq	.+10     	; 0x1326c <FMenuLocalAccount+0x1de>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   13262:	82 30       	cpi	r24, 0x02	; 2
   13264:	19 f0       	breq	.+6      	; 0x1326c <FMenuLocalAccount+0x1de>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   13266:	83 30       	cpi	r24, 0x03	; 3
   13268:	09 f0       	breq	.+2      	; 0x1326c <FMenuLocalAccount+0x1de>
   1326a:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   1326c:	80 93 a0 02 	sts	0x02A0, r24
				TimLocAcc=0;
   13270:	10 92 bc 01 	sts	0x01BC, r1
				stLocalAccount=laDispStatus;
   13274:	86 e0       	ldi	r24, 0x06	; 6
   13276:	93 cf       	rjmp	.-218    	; 0x1319e <FMenuLocalAccount+0x110>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   13278:	80 91 a0 02 	lds	r24, 0x02A0
   1327c:	81 30       	cpi	r24, 0x01	; 1
   1327e:	29 f4       	brne	.+10     	; 0x1328a <FMenuLocalAccount+0x1fc>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   13280:	83 e0       	ldi	r24, 0x03	; 3
   13282:	61 e0       	ldi	r22, 0x01	; 1
   13284:	4f e0       	ldi	r20, 0x0F	; 15
   13286:	51 e2       	ldi	r21, 0x21	; 33
   13288:	0d c0       	rjmp	.+26     	; 0x132a4 <FMenuLocalAccount+0x216>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   1328a:	82 30       	cpi	r24, 0x02	; 2
   1328c:	31 f4       	brne	.+12     	; 0x1329a <FMenuLocalAccount+0x20c>
				    stLocalAccount=laDispValid; 
   1328e:	87 e0       	ldi	r24, 0x07	; 7
   13290:	80 93 4c 01 	sts	0x014C, r24
					lcd_clear();
   13294:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   13298:	0c c0       	rjmp	.+24     	; 0x132b2 <FMenuLocalAccount+0x224>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   1329a:	83 30       	cpi	r24, 0x03	; 3
   1329c:	51 f4       	brne	.+20     	; 0x132b2 <FMenuLocalAccount+0x224>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   1329e:	61 e0       	ldi	r22, 0x01	; 1
   132a0:	4a ef       	ldi	r20, 0xFA	; 250
   132a2:	50 e2       	ldi	r21, 0x20	; 32
   132a4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					TimLocAcc=0;
   132a8:	10 92 bc 01 	sts	0x01BC, r1
				    stLocalAccount=laDelayExit;
   132ac:	8e e1       	ldi	r24, 0x1E	; 30
   132ae:	80 93 4c 01 	sts	0x014C, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   132b2:	80 91 bc 01 	lds	r24, 0x01BC
   132b6:	86 30       	cpi	r24, 0x06	; 6
   132b8:	08 f4       	brcc	.+2      	; 0x132bc <FMenuLocalAccount+0x22e>
   132ba:	95 c7       	rjmp	.+3882   	; 0x141e6 <FMenuLocalAccount+0x1158>
   132bc:	8a c7       	rjmp	.+3860   	; 0x141d2 <FMenuLocalAccount+0x1144>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   132be:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   132c2:	00 d0       	rcall	.+0      	; 0x132c4 <FMenuLocalAccount+0x236>
   132c4:	00 d0       	rcall	.+0      	; 0x132c6 <FMenuLocalAccount+0x238>
   132c6:	00 d0       	rcall	.+0      	; 0x132c8 <FMenuLocalAccount+0x23a>
   132c8:	ed b7       	in	r30, 0x3d	; 61
   132ca:	fe b7       	in	r31, 0x3e	; 62
   132cc:	31 96       	adiw	r30, 0x01	; 1
   132ce:	80 e3       	ldi	r24, 0x30	; 48
   132d0:	9e e0       	ldi	r25, 0x0E	; 14
   132d2:	ad b7       	in	r26, 0x3d	; 61
   132d4:	be b7       	in	r27, 0x3e	; 62
   132d6:	12 96       	adiw	r26, 0x02	; 2
   132d8:	9c 93       	st	X, r25
   132da:	8e 93       	st	-X, r24
   132dc:	11 97       	sbiw	r26, 0x01	; 1
   132de:	87 ef       	ldi	r24, 0xF7	; 247
   132e0:	90 e2       	ldi	r25, 0x20	; 32
   132e2:	93 83       	std	Z+3, r25	; 0x03
   132e4:	82 83       	std	Z+2, r24	; 0x02
   132e6:	05 e0       	ldi	r16, 0x05	; 5
   132e8:	1e e0       	ldi	r17, 0x0E	; 14
   132ea:	15 83       	std	Z+5, r17	; 0x05
   132ec:	04 83       	std	Z+4, r16	; 0x04
   132ee:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				FormatCurrency(strBalance);
   132f2:	ed b7       	in	r30, 0x3d	; 61
   132f4:	fe b7       	in	r31, 0x3e	; 62
   132f6:	36 96       	adiw	r30, 0x06	; 6
   132f8:	0f b6       	in	r0, 0x3f	; 63
   132fa:	f8 94       	cli
   132fc:	fe bf       	out	0x3e, r31	; 62
   132fe:	0f be       	out	0x3f, r0	; 63
   13300:	ed bf       	out	0x3d, r30	; 61
   13302:	c8 01       	movw	r24, r16
   13304:	0e 94 a1 38 	call	0x7142	; 0x7142 <FormatCurrency>
   13308:	20 e0       	ldi	r18, 0x00	; 0
   1330a:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   1330c:	60 e2       	ldi	r22, 0x20	; 32
   1330e:	e6 2e       	mov	r14, r22
   13310:	f1 2c       	mov	r15, r1
   13312:	ec 0e       	add	r14, r28
   13314:	fd 1e       	adc	r15, r29
   13316:	f7 01       	movw	r30, r14
   13318:	e2 0f       	add	r30, r18
   1331a:	f3 1f       	adc	r31, r19
   1331c:	d9 01       	movw	r26, r18
   1331e:	a3 5d       	subi	r26, 0xD3	; 211
   13320:	bc 4f       	sbci	r27, 0xFC	; 252
   13322:	8c 91       	ld	r24, X
   13324:	80 83       	st	Z, r24
   13326:	2f 5f       	subi	r18, 0xFF	; 255
   13328:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   1332a:	24 31       	cpi	r18, 0x14	; 20
   1332c:	31 05       	cpc	r19, r1
   1332e:	99 f7       	brne	.-26     	; 0x13316 <FMenuLocalAccount+0x288>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   13330:	1c aa       	std	Y+52, r1	; 0x34
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   13332:	00 d0       	rcall	.+0      	; 0x13334 <FMenuLocalAccount+0x2a6>
   13334:	00 d0       	rcall	.+0      	; 0x13336 <FMenuLocalAccount+0x2a8>
   13336:	00 d0       	rcall	.+0      	; 0x13338 <FMenuLocalAccount+0x2aa>
   13338:	ed b7       	in	r30, 0x3d	; 61
   1333a:	fe b7       	in	r31, 0x3e	; 62
   1333c:	31 96       	adiw	r30, 0x01	; 1
   1333e:	8e 01       	movw	r16, r28
   13340:	04 5f       	subi	r16, 0xF4	; 244
   13342:	1f 4f       	sbci	r17, 0xFF	; 255
   13344:	ad b7       	in	r26, 0x3d	; 61
   13346:	be b7       	in	r27, 0x3e	; 62
   13348:	12 96       	adiw	r26, 0x02	; 2
   1334a:	1c 93       	st	X, r17
   1334c:	0e 93       	st	-X, r16
   1334e:	11 97       	sbiw	r26, 0x01	; 1
   13350:	84 ef       	ldi	r24, 0xF4	; 244
   13352:	90 e2       	ldi	r25, 0x20	; 32
   13354:	93 83       	std	Z+3, r25	; 0x03
   13356:	82 83       	std	Z+2, r24	; 0x02
   13358:	82 e8       	ldi	r24, 0x82	; 130
   1335a:	97 e0       	ldi	r25, 0x07	; 7
   1335c:	95 83       	std	Z+5, r25	; 0x05
   1335e:	84 83       	std	Z+4, r24	; 0x04
   13360:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13364:	ed b7       	in	r30, 0x3d	; 61
   13366:	fe b7       	in	r31, 0x3e	; 62
   13368:	36 96       	adiw	r30, 0x06	; 6
   1336a:	0f b6       	in	r0, 0x3f	; 63
   1336c:	f8 94       	cli
   1336e:	fe bf       	out	0x3e, r31	; 62
   13370:	0f be       	out	0x3f, r0	; 63
   13372:	ed bf       	out	0x3d, r30	; 61
   13374:	81 e0       	ldi	r24, 0x01	; 1
   13376:	61 e0       	ldi	r22, 0x01	; 1
   13378:	a8 01       	movw	r20, r16
   1337a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   1337e:	00 d0       	rcall	.+0      	; 0x13380 <FMenuLocalAccount+0x2f2>
   13380:	00 d0       	rcall	.+0      	; 0x13382 <FMenuLocalAccount+0x2f4>
   13382:	00 d0       	rcall	.+0      	; 0x13384 <FMenuLocalAccount+0x2f6>
   13384:	ed b7       	in	r30, 0x3d	; 61
   13386:	fe b7       	in	r31, 0x3e	; 62
   13388:	31 96       	adiw	r30, 0x01	; 1
   1338a:	ad b7       	in	r26, 0x3d	; 61
   1338c:	be b7       	in	r27, 0x3e	; 62
   1338e:	12 96       	adiw	r26, 0x02	; 2
   13390:	1c 93       	st	X, r17
   13392:	0e 93       	st	-X, r16
   13394:	11 97       	sbiw	r26, 0x01	; 1
   13396:	81 ef       	ldi	r24, 0xF1	; 241
   13398:	90 e2       	ldi	r25, 0x20	; 32
   1339a:	93 83       	std	Z+3, r25	; 0x03
   1339c:	82 83       	std	Z+2, r24	; 0x02
   1339e:	f5 82       	std	Z+5, r15	; 0x05
   133a0:	e4 82       	std	Z+4, r14	; 0x04
   133a2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   133a6:	ed b7       	in	r30, 0x3d	; 61
   133a8:	fe b7       	in	r31, 0x3e	; 62
   133aa:	36 96       	adiw	r30, 0x06	; 6
   133ac:	0f b6       	in	r0, 0x3f	; 63
   133ae:	f8 94       	cli
   133b0:	fe bf       	out	0x3e, r31	; 62
   133b2:	0f be       	out	0x3f, r0	; 63
   133b4:	ed bf       	out	0x3d, r30	; 61
   133b6:	82 e0       	ldi	r24, 0x02	; 2
   133b8:	61 e0       	ldi	r22, 0x01	; 1
   133ba:	a8 01       	movw	r20, r16
   133bc:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   133c0:	2d b7       	in	r18, 0x3d	; 61
   133c2:	3e b7       	in	r19, 0x3e	; 62
   133c4:	28 50       	subi	r18, 0x08	; 8
   133c6:	30 40       	sbci	r19, 0x00	; 0
   133c8:	0f b6       	in	r0, 0x3f	; 63
   133ca:	f8 94       	cli
   133cc:	3e bf       	out	0x3e, r19	; 62
   133ce:	0f be       	out	0x3f, r0	; 63
   133d0:	2d bf       	out	0x3d, r18	; 61
   133d2:	ed b7       	in	r30, 0x3d	; 61
   133d4:	fe b7       	in	r31, 0x3e	; 62
   133d6:	31 96       	adiw	r30, 0x01	; 1
   133d8:	ad b7       	in	r26, 0x3d	; 61
   133da:	be b7       	in	r27, 0x3e	; 62
   133dc:	12 96       	adiw	r26, 0x02	; 2
   133de:	1c 93       	st	X, r17
   133e0:	0e 93       	st	-X, r16
   133e2:	11 97       	sbiw	r26, 0x01	; 1
   133e4:	8b ee       	ldi	r24, 0xEB	; 235
   133e6:	90 e2       	ldi	r25, 0x20	; 32
   133e8:	93 83       	std	Z+3, r25	; 0x03
   133ea:	82 83       	std	Z+2, r24	; 0x02
   133ec:	83 e0       	ldi	r24, 0x03	; 3
   133ee:	99 e0       	ldi	r25, 0x09	; 9
   133f0:	95 83       	std	Z+5, r25	; 0x05
   133f2:	84 83       	std	Z+4, r24	; 0x04
   133f4:	85 e0       	ldi	r24, 0x05	; 5
   133f6:	9e e0       	ldi	r25, 0x0E	; 14
   133f8:	97 83       	std	Z+7, r25	; 0x07
   133fa:	86 83       	std	Z+6, r24	; 0x06
   133fc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13400:	ed b7       	in	r30, 0x3d	; 61
   13402:	fe b7       	in	r31, 0x3e	; 62
   13404:	38 96       	adiw	r30, 0x08	; 8
   13406:	0f b6       	in	r0, 0x3f	; 63
   13408:	f8 94       	cli
   1340a:	fe bf       	out	0x3e, r31	; 62
   1340c:	0f be       	out	0x3f, r0	; 63
   1340e:	ed bf       	out	0x3d, r30	; 61
   13410:	83 e0       	ldi	r24, 0x03	; 3
   13412:	61 e0       	ldi	r22, 0x01	; 1
   13414:	a8 01       	movw	r20, r16
   13416:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   1341a:	84 e0       	ldi	r24, 0x04	; 4
   1341c:	61 e0       	ldi	r22, 0x01	; 1
   1341e:	46 ed       	ldi	r20, 0xD6	; 214
   13420:	50 e2       	ldi	r21, 0x20	; 32
   13422:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				stLocalAccount=laDispValidInput;
   13426:	88 e0       	ldi	r24, 0x08	; 8
   13428:	ba ce       	rjmp	.-652    	; 0x1319e <FMenuLocalAccount+0x110>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   1342a:	81 e0       	ldi	r24, 0x01	; 1
   1342c:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   13430:	87 3b       	cpi	r24, 0xB7	; 183
   13432:	09 f4       	brne	.+2      	; 0x13436 <FMenuLocalAccount+0x3a8>
   13434:	bd c1       	rjmp	.+890    	; 0x137b0 <FMenuLocalAccount+0x722>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   13436:	87 3e       	cpi	r24, 0xE7	; 231
   13438:	09 f0       	breq	.+2      	; 0x1343c <FMenuLocalAccount+0x3ae>
   1343a:	d5 c6       	rjmp	.+3498   	; 0x141e6 <FMenuLocalAccount+0x1158>
   1343c:	ca c6       	rjmp	.+3476   	; 0x141d2 <FMenuLocalAccount+0x1144>
		        break;
           case laSelectFIP:      
			    FIPResult=menu_FIP(&FIP_Used,strFIP);
   1343e:	0a e9       	ldi	r16, 0x9A	; 154
   13440:	12 e0       	ldi	r17, 0x02	; 2
   13442:	81 e9       	ldi	r24, 0x91	; 145
   13444:	92 e0       	ldi	r25, 0x02	; 2
   13446:	b8 01       	movw	r22, r16
   13448:	0e 94 3d 6a 	call	0xd47a	; 0xd47a <menu_FIP>

			    if ((FIPResult==FIP_DONE)&&(FIP_Used>0)){
   1344c:	88 23       	and	r24, r24
   1344e:	09 f0       	breq	.+2      	; 0x13452 <FMenuLocalAccount+0x3c4>
   13450:	50 c0       	rjmp	.+160    	; 0x134f2 <FMenuLocalAccount+0x464>
   13452:	20 91 91 02 	lds	r18, 0x0291
   13456:	22 23       	and	r18, r18
   13458:	09 f4       	brne	.+2      	; 0x1345c <FMenuLocalAccount+0x3ce>
   1345a:	c5 c6       	rjmp	.+3466   	; 0x141e6 <FMenuLocalAccount+0x1158>
                    sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   1345c:	00 d0       	rcall	.+0      	; 0x1345e <FMenuLocalAccount+0x3d0>
   1345e:	00 d0       	rcall	.+0      	; 0x13460 <FMenuLocalAccount+0x3d2>
   13460:	00 d0       	rcall	.+0      	; 0x13462 <FMenuLocalAccount+0x3d4>
   13462:	ed b7       	in	r30, 0x3d	; 61
   13464:	fe b7       	in	r31, 0x3e	; 62
   13466:	31 96       	adiw	r30, 0x01	; 1
   13468:	ad b7       	in	r26, 0x3d	; 61
   1346a:	be b7       	in	r27, 0x3e	; 62
   1346c:	12 96       	adiw	r26, 0x02	; 2
   1346e:	1c 93       	st	X, r17
   13470:	0e 93       	st	-X, r16
   13472:	11 97       	sbiw	r26, 0x01	; 1
   13474:	81 ed       	ldi	r24, 0xD1	; 209
   13476:	90 e2       	ldi	r25, 0x20	; 32
   13478:	93 83       	std	Z+3, r25	; 0x03
   1347a:	82 83       	std	Z+2, r24	; 0x02
   1347c:	24 83       	std	Z+4, r18	; 0x04
   1347e:	15 82       	std	Z+5, r1	; 0x05
   13480:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
					sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   13484:	ed b7       	in	r30, 0x3d	; 61
   13486:	fe b7       	in	r31, 0x3e	; 62
   13488:	31 96       	adiw	r30, 0x01	; 1
   1348a:	82 ec       	ldi	r24, 0xC2	; 194
   1348c:	97 e0       	ldi	r25, 0x07	; 7
   1348e:	ad b7       	in	r26, 0x3d	; 61
   13490:	be b7       	in	r27, 0x3e	; 62
   13492:	12 96       	adiw	r26, 0x02	; 2
   13494:	9c 93       	st	X, r25
   13496:	8e 93       	st	-X, r24
   13498:	11 97       	sbiw	r26, 0x01	; 1
   1349a:	8c ec       	ldi	r24, 0xCC	; 204
   1349c:	90 e2       	ldi	r25, 0x20	; 32
   1349e:	93 83       	std	Z+3, r25	; 0x03
   134a0:	82 83       	std	Z+2, r24	; 0x02
   134a2:	80 91 91 02 	lds	r24, 0x0291
   134a6:	84 83       	std	Z+4, r24	; 0x04
   134a8:	15 82       	std	Z+5, r1	; 0x05
   134aa:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
                    //Load Product Info
					if (GetFIPAddr(FIP_Used)>0) 
   134ae:	ed b7       	in	r30, 0x3d	; 61
   134b0:	fe b7       	in	r31, 0x3e	; 62
   134b2:	36 96       	adiw	r30, 0x06	; 6
   134b4:	0f b6       	in	r0, 0x3f	; 63
   134b6:	f8 94       	cli
   134b8:	fe bf       	out	0x3e, r31	; 62
   134ba:	0f be       	out	0x3f, r0	; 63
   134bc:	ed bf       	out	0x3d, r30	; 61
   134be:	80 91 91 02 	lds	r24, 0x0291
   134c2:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
   134c6:	88 23       	and	r24, r24
   134c8:	91 f0       	breq	.+36     	; 0x134ee <FMenuLocalAccount+0x460>
					    eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[GetFIPAddr(FIP_Used)-1], 6);
   134ca:	80 91 91 02 	lds	r24, 0x0291
   134ce:	0e 94 05 21 	call	0x420a	; 0x420a <GetFIPAddr>
   134d2:	96 e0       	ldi	r25, 0x06	; 6
   134d4:	89 9f       	mul	r24, r25
   134d6:	b0 01       	movw	r22, r0
   134d8:	11 24       	eor	r1, r1
   134da:	61 5b       	subi	r22, 0xB1	; 177
   134dc:	7f 4f       	sbci	r23, 0xFF	; 255
   134de:	82 e9       	ldi	r24, 0x92	; 146
   134e0:	92 e0       	ldi	r25, 0x02	; 2
   134e2:	46 e0       	ldi	r20, 0x06	; 6
   134e4:	50 e0       	ldi	r21, 0x00	; 0
   134e6:	22 e4       	ldi	r18, 0x42	; 66
   134e8:	33 e1       	ldi	r19, 0x13	; 19
   134ea:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
				    stLocalAccount=laSelectProduct;
   134ee:	8b e0       	ldi	r24, 0x0B	; 11
   134f0:	56 ce       	rjmp	.-852    	; 0x1319e <FMenuLocalAccount+0x110>
				}
			    else if (FIPResult==FIP_CANCEL){
   134f2:	82 30       	cpi	r24, 0x02	; 2
   134f4:	09 f0       	breq	.+2      	; 0x134f8 <FMenuLocalAccount+0x46a>
   134f6:	77 c6       	rjmp	.+3310   	; 0x141e6 <FMenuLocalAccount+0x1158>
				    stLocalAccount=laDispValid;
   134f8:	87 e0       	ldi	r24, 0x07	; 7
   134fa:	51 ce       	rjmp	.-862    	; 0x1319e <FMenuLocalAccount+0x110>
		        break; 
           case laSelectFIPInput:

		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   134fc:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   13500:	00 d0       	rcall	.+0      	; 0x13502 <FMenuLocalAccount+0x474>
   13502:	00 d0       	rcall	.+0      	; 0x13504 <FMenuLocalAccount+0x476>
   13504:	00 d0       	rcall	.+0      	; 0x13506 <FMenuLocalAccount+0x478>
   13506:	ed b7       	in	r30, 0x3d	; 61
   13508:	fe b7       	in	r31, 0x3e	; 62
   1350a:	31 96       	adiw	r30, 0x01	; 1
   1350c:	8e 01       	movw	r16, r28
   1350e:	04 5f       	subi	r16, 0xF4	; 244
   13510:	1f 4f       	sbci	r17, 0xFF	; 255
   13512:	ad b7       	in	r26, 0x3d	; 61
   13514:	be b7       	in	r27, 0x3e	; 62
   13516:	12 96       	adiw	r26, 0x02	; 2
   13518:	1c 93       	st	X, r17
   1351a:	0e 93       	st	-X, r16
   1351c:	11 97       	sbiw	r26, 0x01	; 1
   1351e:	83 ec       	ldi	r24, 0xC3	; 195
   13520:	90 e2       	ldi	r25, 0x20	; 32
   13522:	93 83       	std	Z+3, r25	; 0x03
   13524:	82 83       	std	Z+2, r24	; 0x02
   13526:	8a e9       	ldi	r24, 0x9A	; 154
   13528:	92 e0       	ldi	r25, 0x02	; 2
   1352a:	95 83       	std	Z+5, r25	; 0x05
   1352c:	84 83       	std	Z+4, r24	; 0x04
   1352e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13532:	ed b7       	in	r30, 0x3d	; 61
   13534:	fe b7       	in	r31, 0x3e	; 62
   13536:	36 96       	adiw	r30, 0x06	; 6
   13538:	0f b6       	in	r0, 0x3f	; 63
   1353a:	f8 94       	cli
   1353c:	fe bf       	out	0x3e, r31	; 62
   1353e:	0f be       	out	0x3f, r0	; 63
   13540:	ed bf       	out	0x3d, r30	; 61
   13542:	81 e0       	ldi	r24, 0x01	; 1
   13544:	61 e0       	ldi	r22, 0x01	; 1
   13546:	a8 01       	movw	r20, r16
   13548:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   1354c:	90 91 92 02 	lds	r25, 0x0292
   13550:	89 2f       	mov	r24, r25
   13552:	81 50       	subi	r24, 0x01	; 1
   13554:	86 30       	cpi	r24, 0x06	; 6
   13556:	08 f0       	brcs	.+2      	; 0x1355a <FMenuLocalAccount+0x4cc>
   13558:	4e c0       	rjmp	.+156    	; 0x135f6 <FMenuLocalAccount+0x568>
   1355a:	80 91 93 02 	lds	r24, 0x0293
   1355e:	88 23       	and	r24, r24
   13560:	09 f0       	breq	.+2      	; 0x13564 <FMenuLocalAccount+0x4d6>
   13562:	49 c0       	rjmp	.+146    	; 0x135f6 <FMenuLocalAccount+0x568>
   13564:	80 91 94 02 	lds	r24, 0x0294
   13568:	88 23       	and	r24, r24
   1356a:	09 f0       	breq	.+2      	; 0x1356e <FMenuLocalAccount+0x4e0>
   1356c:	44 c0       	rjmp	.+136    	; 0x135f6 <FMenuLocalAccount+0x568>
   1356e:	80 91 95 02 	lds	r24, 0x0295
   13572:	88 23       	and	r24, r24
   13574:	09 f0       	breq	.+2      	; 0x13578 <FMenuLocalAccount+0x4ea>
   13576:	3f c0       	rjmp	.+126    	; 0x135f6 <FMenuLocalAccount+0x568>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   13578:	90 93 90 02 	sts	0x0290, r25
   1357c:	6d e0       	ldi	r22, 0x0D	; 13
   1357e:	96 9f       	mul	r25, r22
   13580:	b0 01       	movw	r22, r0
   13582:	11 24       	eor	r1, r1
   13584:	62 55       	subi	r22, 0x52	; 82
   13586:	7f 4f       	sbci	r23, 0xFF	; 255
   13588:	8e 01       	movw	r16, r28
   1358a:	0f 5f       	subi	r16, 0xFF	; 255
   1358c:	1f 4f       	sbci	r17, 0xFF	; 255
   1358e:	c8 01       	movw	r24, r16
   13590:	4a e0       	ldi	r20, 0x0A	; 10
   13592:	50 e0       	ldi	r21, 0x00	; 0
   13594:	22 e4       	ldi	r18, 0x42	; 66
   13596:	33 e1       	ldi	r19, 0x13	; 19
   13598:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1359c:	ce 01       	movw	r24, r28
   1359e:	09 96       	adiw	r24, 0x09	; 9
	    Dest[i]=Source[IdxSource+i];
   135a0:	0f 5f       	subi	r16, 0xFF	; 255
   135a2:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   135a4:	08 17       	cp	r16, r24
   135a6:	19 07       	cpc	r17, r25
   135a8:	d9 f7       	brne	.-10     	; 0x135a0 <FMenuLocalAccount+0x512>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   135aa:	19 86       	std	Y+9, r1	; 0x09
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   135ac:	00 d0       	rcall	.+0      	; 0x135ae <FMenuLocalAccount+0x520>
   135ae:	00 d0       	rcall	.+0      	; 0x135b0 <FMenuLocalAccount+0x522>
   135b0:	00 d0       	rcall	.+0      	; 0x135b2 <FMenuLocalAccount+0x524>
   135b2:	ed b7       	in	r30, 0x3d	; 61
   135b4:	fe b7       	in	r31, 0x3e	; 62
   135b6:	31 96       	adiw	r30, 0x01	; 1
   135b8:	87 e6       	ldi	r24, 0x67	; 103
   135ba:	97 e0       	ldi	r25, 0x07	; 7
   135bc:	ad b7       	in	r26, 0x3d	; 61
   135be:	be b7       	in	r27, 0x3e	; 62
   135c0:	12 96       	adiw	r26, 0x02	; 2
   135c2:	9c 93       	st	X, r25
   135c4:	8e 93       	st	-X, r24
   135c6:	11 97       	sbiw	r26, 0x01	; 1
   135c8:	80 ec       	ldi	r24, 0xC0	; 192
   135ca:	90 e2       	ldi	r25, 0x20	; 32
   135cc:	93 83       	std	Z+3, r25	; 0x03
   135ce:	82 83       	std	Z+2, r24	; 0x02
   135d0:	ce 01       	movw	r24, r28
   135d2:	01 96       	adiw	r24, 0x01	; 1
   135d4:	95 83       	std	Z+5, r25	; 0x05
   135d6:	84 83       	std	Z+4, r24	; 0x04
   135d8:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   135dc:	8d e0       	ldi	r24, 0x0D	; 13
   135de:	80 93 4c 01 	sts	0x014C, r24
   135e2:	80 e0       	ldi	r24, 0x00	; 0
   135e4:	ed b7       	in	r30, 0x3d	; 61
   135e6:	fe b7       	in	r31, 0x3e	; 62
   135e8:	36 96       	adiw	r30, 0x06	; 6
   135ea:	0f b6       	in	r0, 0x3f	; 63
   135ec:	f8 94       	cli
   135ee:	fe bf       	out	0x3e, r31	; 62
   135f0:	0f be       	out	0x3f, r0	; 63
   135f2:	ed bf       	out	0x3d, r30	; 61
   135f4:	f9 c5       	rjmp	.+3058   	; 0x141e8 <FMenuLocalAccount+0x115a>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   135f6:	10 92 98 02 	sts	0x0298, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   135fa:	5c e0       	ldi	r21, 0x0C	; 12
   135fc:	e5 2e       	mov	r14, r21
   135fe:	f1 2c       	mov	r15, r1
   13600:	ec 0e       	add	r14, r28
   13602:	fd 1e       	adc	r15, r29
   13604:	44 eb       	ldi	r20, 0xB4	; 180
   13606:	84 2e       	mov	r8, r20
   13608:	40 e2       	ldi	r20, 0x20	; 32
   1360a:	94 2e       	mov	r9, r20
   1360c:	3d e0       	ldi	r19, 0x0D	; 13
   1360e:	63 2e       	mov	r6, r19
   13610:	8e 01       	movw	r16, r28
   13612:	0f 5f       	subi	r16, 0xFF	; 255
   13614:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13616:	29 e0       	ldi	r18, 0x09	; 9
   13618:	a2 2e       	mov	r10, r18
   1361a:	b1 2c       	mov	r11, r1
   1361c:	ac 0e       	add	r10, r28
   1361e:	bd 1e       	adc	r11, r29
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13620:	9a eb       	ldi	r25, 0xBA	; 186
   13622:	c9 2e       	mov	r12, r25
   13624:	90 e2       	ldi	r25, 0x20	; 32
   13626:	d9 2e       	mov	r13, r25
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13628:	8b e0       	ldi	r24, 0x0B	; 11
   1362a:	78 2e       	mov	r7, r24
   1362c:	67 c0       	rjmp	.+206    	; 0x136fc <FMenuLocalAccount+0x66e>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   1362e:	f0 e0       	ldi	r31, 0x00	; 0
   13630:	ee 56       	subi	r30, 0x6E	; 110
   13632:	fd 4f       	sbci	r31, 0xFD	; 253
   13634:	e0 81       	ld	r30, Z
   13636:	e0 93 90 02 	sts	0x0290, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   1363a:	8e 2f       	mov	r24, r30
   1363c:	81 50       	subi	r24, 0x01	; 1
   1363e:	86 30       	cpi	r24, 0x06	; 6
   13640:	c8 f5       	brcc	.+114    	; 0x136b4 <FMenuLocalAccount+0x626>
   13642:	e6 9d       	mul	r30, r6
   13644:	b0 01       	movw	r22, r0
   13646:	11 24       	eor	r1, r1
   13648:	62 55       	subi	r22, 0x52	; 82
   1364a:	7f 4f       	sbci	r23, 0xFF	; 255
   1364c:	c8 01       	movw	r24, r16
   1364e:	4a e0       	ldi	r20, 0x0A	; 10
   13650:	50 e0       	ldi	r21, 0x00	; 0
   13652:	22 e4       	ldi	r18, 0x42	; 66
   13654:	33 e1       	ldi	r19, 0x13	; 19
   13656:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
   1365a:	c8 01       	movw	r24, r16
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1365c:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1365e:	8a 15       	cp	r24, r10
   13660:	9b 05       	cpc	r25, r11
   13662:	e1 f7       	brne	.-8      	; 0x1365c <FMenuLocalAccount+0x5ce>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13664:	19 86       	std	Y+9, r1	; 0x09
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13666:	2d b7       	in	r18, 0x3d	; 61
   13668:	3e b7       	in	r19, 0x3e	; 62
   1366a:	28 50       	subi	r18, 0x08	; 8
   1366c:	30 40       	sbci	r19, 0x00	; 0
   1366e:	0f b6       	in	r0, 0x3f	; 63
   13670:	f8 94       	cli
   13672:	3e bf       	out	0x3e, r19	; 62
   13674:	0f be       	out	0x3f, r0	; 63
   13676:	2d bf       	out	0x3d, r18	; 61
   13678:	ed b7       	in	r30, 0x3d	; 61
   1367a:	fe b7       	in	r31, 0x3e	; 62
   1367c:	31 96       	adiw	r30, 0x01	; 1
   1367e:	ad b7       	in	r26, 0x3d	; 61
   13680:	be b7       	in	r27, 0x3e	; 62
   13682:	12 96       	adiw	r26, 0x02	; 2
   13684:	fc 92       	st	X, r15
   13686:	ee 92       	st	-X, r14
   13688:	11 97       	sbiw	r26, 0x01	; 1
   1368a:	d3 82       	std	Z+3, r13	; 0x03
   1368c:	c2 82       	std	Z+2, r12	; 0x02
   1368e:	80 91 98 02 	lds	r24, 0x0298
   13692:	90 e0       	ldi	r25, 0x00	; 0
   13694:	01 96       	adiw	r24, 0x01	; 1
   13696:	95 83       	std	Z+5, r25	; 0x05
   13698:	84 83       	std	Z+4, r24	; 0x04
   1369a:	17 83       	std	Z+7, r17	; 0x07
   1369c:	06 83       	std	Z+6, r16	; 0x06
   1369e:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   136a2:	ed b7       	in	r30, 0x3d	; 61
   136a4:	fe b7       	in	r31, 0x3e	; 62
   136a6:	38 96       	adiw	r30, 0x08	; 8
   136a8:	0f b6       	in	r0, 0x3f	; 63
   136aa:	f8 94       	cli
   136ac:	fe bf       	out	0x3e, r31	; 62
   136ae:	0f be       	out	0x3f, r0	; 63
   136b0:	ed bf       	out	0x3d, r30	; 61
   136b2:	12 c0       	rjmp	.+36     	; 0x136d8 <FMenuLocalAccount+0x64a>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   136b4:	00 d0       	rcall	.+0      	; 0x136b6 <FMenuLocalAccount+0x628>
   136b6:	00 d0       	rcall	.+0      	; 0x136b8 <FMenuLocalAccount+0x62a>
   136b8:	ad b7       	in	r26, 0x3d	; 61
   136ba:	be b7       	in	r27, 0x3e	; 62
   136bc:	12 96       	adiw	r26, 0x02	; 2
   136be:	fc 92       	st	X, r15
   136c0:	ee 92       	st	-X, r14
   136c2:	11 97       	sbiw	r26, 0x01	; 1
   136c4:	14 96       	adiw	r26, 0x04	; 4
   136c6:	9c 92       	st	X, r9
   136c8:	8e 92       	st	-X, r8
   136ca:	13 97       	sbiw	r26, 0x03	; 3
   136cc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   136d0:	0f 90       	pop	r0
   136d2:	0f 90       	pop	r0
   136d4:	0f 90       	pop	r0
   136d6:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   136d8:	80 91 98 02 	lds	r24, 0x0298
   136dc:	68 2f       	mov	r22, r24
   136de:	66 95       	lsr	r22
   136e0:	67 9d       	mul	r22, r7
   136e2:	b0 01       	movw	r22, r0
   136e4:	11 24       	eor	r1, r1
   136e6:	6f 5f       	subi	r22, 0xFF	; 255
   136e8:	81 70       	andi	r24, 0x01	; 1
   136ea:	8e 5f       	subi	r24, 0xFE	; 254
   136ec:	a7 01       	movw	r20, r14
   136ee:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   136f2:	80 91 98 02 	lds	r24, 0x0298
   136f6:	8f 5f       	subi	r24, 0xFF	; 255
   136f8:	80 93 98 02 	sts	0x0298, r24
   136fc:	e0 91 98 02 	lds	r30, 0x0298
   13700:	e4 30       	cpi	r30, 0x04	; 4
   13702:	08 f4       	brcc	.+2      	; 0x13706 <FMenuLocalAccount+0x678>
   13704:	94 cf       	rjmp	.-216    	; 0x1362e <FMenuLocalAccount+0x5a0>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   13706:	84 e0       	ldi	r24, 0x04	; 4
   13708:	61 e0       	ldi	r22, 0x01	; 1
   1370a:	4f e9       	ldi	r20, 0x9F	; 159
   1370c:	50 e2       	ldi	r21, 0x20	; 32
   1370e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				stLocalAccount=laSelectProductInput;
   13712:	8c e0       	ldi	r24, 0x0C	; 12
   13714:	44 cd       	rjmp	.-1400   	; 0x1319e <FMenuLocalAccount+0x110>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   13716:	81 e0       	ldi	r24, 0x01	; 1
   13718:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   1371c:	e8 2e       	mov	r14, r24
			    KeyChar=_key_btn(KeyPressed);
   1371e:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
				if ((KeyChar>='1')&&(KeyChar<='4')){
   13722:	81 53       	subi	r24, 0x31	; 49
   13724:	84 30       	cpi	r24, 0x04	; 4
   13726:	08 f0       	brcs	.+2      	; 0x1372a <FMenuLocalAccount+0x69c>
   13728:	3f c0       	rjmp	.+126    	; 0x137a8 <FMenuLocalAccount+0x71a>
				    iNozzle=KeyChar-'1';
   1372a:	80 93 98 02 	sts	0x0298, r24
   1372e:	e8 2f       	mov	r30, r24
   13730:	f0 e0       	ldi	r31, 0x00	; 0
   13732:	ee 56       	subi	r30, 0x6E	; 110
   13734:	fd 4f       	sbci	r31, 0xFD	; 253
   13736:	60 81       	ld	r22, Z
   13738:	bd e0       	ldi	r27, 0x0D	; 13
   1373a:	fb 2e       	mov	r15, r27
   1373c:	6f 9d       	mul	r22, r15
   1373e:	b0 01       	movw	r22, r0
   13740:	11 24       	eor	r1, r1
   13742:	62 55       	subi	r22, 0x52	; 82
   13744:	7f 4f       	sbci	r23, 0xFF	; 255
   13746:	8e 01       	movw	r16, r28
   13748:	0f 5f       	subi	r16, 0xFF	; 255
   1374a:	1f 4f       	sbci	r17, 0xFF	; 255
   1374c:	c8 01       	movw	r24, r16
   1374e:	4a e0       	ldi	r20, 0x0A	; 10
   13750:	50 e0       	ldi	r21, 0x00	; 0
   13752:	22 e4       	ldi	r18, 0x42	; 66
   13754:	33 e1       	ldi	r19, 0x13	; 19
   13756:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   1375a:	00 d0       	rcall	.+0      	; 0x1375c <FMenuLocalAccount+0x6ce>
   1375c:	00 d0       	rcall	.+0      	; 0x1375e <FMenuLocalAccount+0x6d0>
   1375e:	00 d0       	rcall	.+0      	; 0x13760 <FMenuLocalAccount+0x6d2>
   13760:	ed b7       	in	r30, 0x3d	; 61
   13762:	fe b7       	in	r31, 0x3e	; 62
   13764:	31 96       	adiw	r30, 0x01	; 1
   13766:	87 e6       	ldi	r24, 0x67	; 103
   13768:	97 e0       	ldi	r25, 0x07	; 7
   1376a:	ad b7       	in	r26, 0x3d	; 61
   1376c:	be b7       	in	r27, 0x3e	; 62
   1376e:	12 96       	adiw	r26, 0x02	; 2
   13770:	9c 93       	st	X, r25
   13772:	8e 93       	st	-X, r24
   13774:	11 97       	sbiw	r26, 0x01	; 1
   13776:	8c e9       	ldi	r24, 0x9C	; 156
   13778:	90 e2       	ldi	r25, 0x20	; 32
   1377a:	93 83       	std	Z+3, r25	; 0x03
   1377c:	82 83       	std	Z+2, r24	; 0x02
   1377e:	15 83       	std	Z+5, r17	; 0x05
   13780:	04 83       	std	Z+4, r16	; 0x04
   13782:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
					NozzleID=iNozzle+1;
   13786:	80 91 98 02 	lds	r24, 0x0298
   1378a:	8f 5f       	subi	r24, 0xFF	; 255
   1378c:	80 93 76 07 	sts	0x0776, r24
                    stLocalAccount=laSelectBalanceType;
   13790:	f0 92 4c 01 	sts	0x014C, r15
					lcd_clear();
   13794:	ed b7       	in	r30, 0x3d	; 61
   13796:	fe b7       	in	r31, 0x3e	; 62
   13798:	36 96       	adiw	r30, 0x06	; 6
   1379a:	0f b6       	in	r0, 0x3f	; 63
   1379c:	f8 94       	cli
   1379e:	fe bf       	out	0x3e, r31	; 62
   137a0:	0f be       	out	0x3f, r0	; 63
   137a2:	ed bf       	out	0x3d, r30	; 61
   137a4:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   137a8:	f7 ee       	ldi	r31, 0xE7	; 231
   137aa:	ef 16       	cp	r14, r31
   137ac:	09 f0       	breq	.+2      	; 0x137b0 <FMenuLocalAccount+0x722>
   137ae:	1b c5       	rjmp	.+2614   	; 0x141e6 <FMenuLocalAccount+0x1158>
   137b0:	89 e0       	ldi	r24, 0x09	; 9
   137b2:	f5 cc       	rjmp	.-1558   	; 0x1319e <FMenuLocalAccount+0x110>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   137b4:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   137b8:	2d b7       	in	r18, 0x3d	; 61
   137ba:	3e b7       	in	r19, 0x3e	; 62
   137bc:	28 50       	subi	r18, 0x08	; 8
   137be:	30 40       	sbci	r19, 0x00	; 0
   137c0:	0f b6       	in	r0, 0x3f	; 63
   137c2:	f8 94       	cli
   137c4:	3e bf       	out	0x3e, r19	; 62
   137c6:	0f be       	out	0x3f, r0	; 63
   137c8:	2d bf       	out	0x3d, r18	; 61
   137ca:	ed b7       	in	r30, 0x3d	; 61
   137cc:	fe b7       	in	r31, 0x3e	; 62
   137ce:	31 96       	adiw	r30, 0x01	; 1
   137d0:	8e 01       	movw	r16, r28
   137d2:	04 5f       	subi	r16, 0xF4	; 244
   137d4:	1f 4f       	sbci	r17, 0xFF	; 255
   137d6:	ad b7       	in	r26, 0x3d	; 61
   137d8:	be b7       	in	r27, 0x3e	; 62
   137da:	12 96       	adiw	r26, 0x02	; 2
   137dc:	1c 93       	st	X, r17
   137de:	0e 93       	st	-X, r16
   137e0:	11 97       	sbiw	r26, 0x01	; 1
   137e2:	84 e9       	ldi	r24, 0x94	; 148
   137e4:	90 e2       	ldi	r25, 0x20	; 32
   137e6:	93 83       	std	Z+3, r25	; 0x03
   137e8:	82 83       	std	Z+2, r24	; 0x02
   137ea:	8a e9       	ldi	r24, 0x9A	; 154
   137ec:	92 e0       	ldi	r25, 0x02	; 2
   137ee:	95 83       	std	Z+5, r25	; 0x05
   137f0:	84 83       	std	Z+4, r24	; 0x04
   137f2:	87 e6       	ldi	r24, 0x67	; 103
   137f4:	97 e0       	ldi	r25, 0x07	; 7
   137f6:	97 83       	std	Z+7, r25	; 0x07
   137f8:	86 83       	std	Z+6, r24	; 0x06
   137fa:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   137fe:	ed b7       	in	r30, 0x3d	; 61
   13800:	fe b7       	in	r31, 0x3e	; 62
   13802:	38 96       	adiw	r30, 0x08	; 8
   13804:	0f b6       	in	r0, 0x3f	; 63
   13806:	f8 94       	cli
   13808:	fe bf       	out	0x3e, r31	; 62
   1380a:	0f be       	out	0x3f, r0	; 63
   1380c:	ed bf       	out	0x3d, r30	; 61
   1380e:	81 e0       	ldi	r24, 0x01	; 1
   13810:	61 e0       	ldi	r22, 0x01	; 1
   13812:	a8 01       	movw	r20, r16
   13814:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   13818:	82 e0       	ldi	r24, 0x02	; 2
   1381a:	61 e0       	ldi	r22, 0x01	; 1
   1381c:	4f e7       	ldi	r20, 0x7F	; 127
   1381e:	50 e2       	ldi	r21, 0x20	; 32
   13820:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   13824:	83 e0       	ldi	r24, 0x03	; 3
   13826:	61 e0       	ldi	r22, 0x01	; 1
   13828:	4a e6       	ldi	r20, 0x6A	; 106
   1382a:	50 e2       	ldi	r21, 0x20	; 32
   1382c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   13830:	84 e0       	ldi	r24, 0x04	; 4
   13832:	61 e0       	ldi	r22, 0x01	; 1
   13834:	45 e5       	ldi	r20, 0x55	; 85
   13836:	50 e2       	ldi	r21, 0x20	; 32
   13838:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   1383c:	8e e0       	ldi	r24, 0x0E	; 14
   1383e:	af cc       	rjmp	.-1698   	; 0x1319e <FMenuLocalAccount+0x110>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   13840:	81 e0       	ldi	r24, 0x01	; 1
   13842:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   13846:	18 2f       	mov	r17, r24
			    KeyChar=_key_btn(KeyPressed);
   13848:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
   1384c:	98 2f       	mov	r25, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   1384e:	81 53       	subi	r24, 0x31	; 49
   13850:	82 30       	cpi	r24, 0x02	; 2
   13852:	80 f5       	brcc	.+96     	; 0x138b4 <FMenuLocalAccount+0x826>
                    if(KeyChar=='1'){
   13854:	91 33       	cpi	r25, 0x31	; 49
   13856:	a1 f4       	brne	.+40     	; 0x13880 <FMenuLocalAccount+0x7f2>
					   BalanceType=1;
   13858:	81 e0       	ldi	r24, 0x01	; 1
   1385a:	80 93 9d 02 	sts	0x029D, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   1385e:	00 d0       	rcall	.+0      	; 0x13860 <FMenuLocalAccount+0x7d2>
   13860:	00 d0       	rcall	.+0      	; 0x13862 <FMenuLocalAccount+0x7d4>
   13862:	8c ea       	ldi	r24, 0xAC	; 172
   13864:	93 e0       	ldi	r25, 0x03	; 3
   13866:	ad b7       	in	r26, 0x3d	; 61
   13868:	be b7       	in	r27, 0x3e	; 62
   1386a:	12 96       	adiw	r26, 0x02	; 2
   1386c:	9c 93       	st	X, r25
   1386e:	8e 93       	st	-X, r24
   13870:	11 97       	sbiw	r26, 0x01	; 1
   13872:	83 e5       	ldi	r24, 0x53	; 83
   13874:	90 e2       	ldi	r25, 0x20	; 32
   13876:	14 96       	adiw	r26, 0x04	; 4
   13878:	9c 93       	st	X, r25
   1387a:	8e 93       	st	-X, r24
   1387c:	13 97       	sbiw	r26, 0x03	; 3
   1387e:	11 c0       	rjmp	.+34     	; 0x138a2 <FMenuLocalAccount+0x814>
					   }
					else
                    if(KeyChar=='2'){
   13880:	92 33       	cpi	r25, 0x32	; 50
   13882:	a9 f4       	brne	.+42     	; 0x138ae <FMenuLocalAccount+0x820>
					   BalanceType=2;
   13884:	82 e0       	ldi	r24, 0x02	; 2
   13886:	80 93 9d 02 	sts	0x029D, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   1388a:	00 d0       	rcall	.+0      	; 0x1388c <FMenuLocalAccount+0x7fe>
   1388c:	00 d0       	rcall	.+0      	; 0x1388e <FMenuLocalAccount+0x800>
   1388e:	8c ea       	ldi	r24, 0xAC	; 172
   13890:	93 e0       	ldi	r25, 0x03	; 3
   13892:	ed b7       	in	r30, 0x3d	; 61
   13894:	fe b7       	in	r31, 0x3e	; 62
   13896:	92 83       	std	Z+2, r25	; 0x02
   13898:	81 83       	std	Z+1, r24	; 0x01
   1389a:	81 e5       	ldi	r24, 0x51	; 81
   1389c:	90 e2       	ldi	r25, 0x20	; 32
   1389e:	94 83       	std	Z+4, r25	; 0x04
   138a0:	83 83       	std	Z+3, r24	; 0x03
   138a2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   138a6:	0f 90       	pop	r0
   138a8:	0f 90       	pop	r0
   138aa:	0f 90       	pop	r0
   138ac:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   138ae:	8f e0       	ldi	r24, 0x0F	; 15
   138b0:	80 93 4c 01 	sts	0x014C, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   138b4:	17 3e       	cpi	r17, 0xE7	; 231
   138b6:	c9 f4       	brne	.+50     	; 0x138ea <FMenuLocalAccount+0x85c>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   138b8:	80 91 92 02 	lds	r24, 0x0292
   138bc:	81 50       	subi	r24, 0x01	; 1
   138be:	86 30       	cpi	r24, 0x06	; 6
   138c0:	70 f4       	brcc	.+28     	; 0x138de <FMenuLocalAccount+0x850>
   138c2:	80 91 93 02 	lds	r24, 0x0293
   138c6:	88 23       	and	r24, r24
   138c8:	51 f4       	brne	.+20     	; 0x138de <FMenuLocalAccount+0x850>
   138ca:	80 91 94 02 	lds	r24, 0x0294
   138ce:	88 23       	and	r24, r24
   138d0:	31 f4       	brne	.+12     	; 0x138de <FMenuLocalAccount+0x850>
   138d2:	80 91 95 02 	lds	r24, 0x0295
   138d6:	88 23       	and	r24, r24
   138d8:	11 f4       	brne	.+4      	; 0x138de <FMenuLocalAccount+0x850>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   138da:	89 e0       	ldi	r24, 0x09	; 9
   138dc:	01 c0       	rjmp	.+2      	; 0x138e0 <FMenuLocalAccount+0x852>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   138de:	8b e0       	ldi	r24, 0x0B	; 11
   138e0:	80 93 4c 01 	sts	0x014C, r24
					lcd_clear();
   138e4:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   138e8:	7e c4       	rjmp	.+2300   	; 0x141e6 <FMenuLocalAccount+0x1158>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   138ea:	17 3b       	cpi	r17, 0xB7	; 183
   138ec:	09 f0       	breq	.+2      	; 0x138f0 <FMenuLocalAccount+0x862>
   138ee:	7b c4       	rjmp	.+2294   	; 0x141e6 <FMenuLocalAccount+0x1158>
				    BalanceType=1;
   138f0:	11 e0       	ldi	r17, 0x01	; 1
   138f2:	10 93 9d 02 	sts	0x029D, r17
					sprintf_P(strBalanceType,PSTR("A"));
   138f6:	00 d0       	rcall	.+0      	; 0x138f8 <FMenuLocalAccount+0x86a>
   138f8:	00 d0       	rcall	.+0      	; 0x138fa <FMenuLocalAccount+0x86c>
   138fa:	8c ea       	ldi	r24, 0xAC	; 172
   138fc:	93 e0       	ldi	r25, 0x03	; 3
   138fe:	ad b7       	in	r26, 0x3d	; 61
   13900:	be b7       	in	r27, 0x3e	; 62
   13902:	12 96       	adiw	r26, 0x02	; 2
   13904:	9c 93       	st	X, r25
   13906:	8e 93       	st	-X, r24
   13908:	11 97       	sbiw	r26, 0x01	; 1
   1390a:	8f e4       	ldi	r24, 0x4F	; 79
   1390c:	90 e2       	ldi	r25, 0x20	; 32
   1390e:	14 96       	adiw	r26, 0x04	; 4
   13910:	9c 93       	st	X, r25
   13912:	8e 93       	st	-X, r24
   13914:	13 97       	sbiw	r26, 0x03	; 3
   13916:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   1391a:	10 93 8f 02 	sts	0x028F, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   1391e:	81 e1       	ldi	r24, 0x11	; 17
   13920:	80 93 4c 01 	sts	0x014C, r24
   13924:	80 e0       	ldi	r24, 0x00	; 0
   13926:	0f 90       	pop	r0
   13928:	0f 90       	pop	r0
   1392a:	0f 90       	pop	r0
   1392c:	0f 90       	pop	r0
   1392e:	5c c4       	rjmp	.+2232   	; 0x141e8 <FMenuLocalAccount+0x115a>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   13930:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		        if(BalanceType==1){
   13934:	80 91 9d 02 	lds	r24, 0x029D
   13938:	81 30       	cpi	r24, 0x01	; 1
   1393a:	f1 f5       	brne	.+124    	; 0x139b8 <FMenuLocalAccount+0x92a>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1393c:	ed b7       	in	r30, 0x3d	; 61
   1393e:	fe b7       	in	r31, 0x3e	; 62
   13940:	38 97       	sbiw	r30, 0x08	; 8
   13942:	0f b6       	in	r0, 0x3f	; 63
   13944:	f8 94       	cli
   13946:	fe bf       	out	0x3e, r31	; 62
   13948:	0f be       	out	0x3f, r0	; 63
   1394a:	ed bf       	out	0x3d, r30	; 61
   1394c:	31 96       	adiw	r30, 0x01	; 1
   1394e:	8e 01       	movw	r16, r28
   13950:	04 5f       	subi	r16, 0xF4	; 244
   13952:	1f 4f       	sbci	r17, 0xFF	; 255
   13954:	ad b7       	in	r26, 0x3d	; 61
   13956:	be b7       	in	r27, 0x3e	; 62
   13958:	12 96       	adiw	r26, 0x02	; 2
   1395a:	1c 93       	st	X, r17
   1395c:	0e 93       	st	-X, r16
   1395e:	11 97       	sbiw	r26, 0x01	; 1
   13960:	87 e4       	ldi	r24, 0x47	; 71
   13962:	90 e2       	ldi	r25, 0x20	; 32
   13964:	93 83       	std	Z+3, r25	; 0x03
   13966:	82 83       	std	Z+2, r24	; 0x02
   13968:	8a e9       	ldi	r24, 0x9A	; 154
   1396a:	92 e0       	ldi	r25, 0x02	; 2
   1396c:	95 83       	std	Z+5, r25	; 0x05
   1396e:	84 83       	std	Z+4, r24	; 0x04
   13970:	87 e6       	ldi	r24, 0x67	; 103
   13972:	97 e0       	ldi	r25, 0x07	; 7
   13974:	97 83       	std	Z+7, r25	; 0x07
   13976:	86 83       	std	Z+6, r24	; 0x06
   13978:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   1397c:	ed b7       	in	r30, 0x3d	; 61
   1397e:	fe b7       	in	r31, 0x3e	; 62
   13980:	38 96       	adiw	r30, 0x08	; 8
   13982:	0f b6       	in	r0, 0x3f	; 63
   13984:	f8 94       	cli
   13986:	fe bf       	out	0x3e, r31	; 62
   13988:	0f be       	out	0x3f, r0	; 63
   1398a:	ed bf       	out	0x3d, r30	; 61
   1398c:	81 e0       	ldi	r24, 0x01	; 1
   1398e:	61 e0       	ldi	r22, 0x01	; 1
   13990:	a8 01       	movw	r20, r16
   13992:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   13996:	82 e0       	ldi	r24, 0x02	; 2
   13998:	61 e0       	ldi	r22, 0x01	; 1
   1399a:	42 e3       	ldi	r20, 0x32	; 50
   1399c:	50 e2       	ldi	r21, 0x20	; 32
   1399e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   139a2:	83 e0       	ldi	r24, 0x03	; 3
   139a4:	61 e0       	ldi	r22, 0x01	; 1
   139a6:	4d e1       	ldi	r20, 0x1D	; 29
   139a8:	50 e2       	ldi	r21, 0x20	; 32
   139aa:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   139ae:	84 e0       	ldi	r24, 0x04	; 4
   139b0:	61 e0       	ldi	r22, 0x01	; 1
   139b2:	48 e0       	ldi	r20, 0x08	; 8
   139b4:	50 e2       	ldi	r21, 0x20	; 32
   139b6:	43 c0       	rjmp	.+134    	; 0x13a3e <FMenuLocalAccount+0x9b0>
				   }
                else
		        if(BalanceType==2){
   139b8:	82 30       	cpi	r24, 0x02	; 2
   139ba:	09 f0       	breq	.+2      	; 0x139be <FMenuLocalAccount+0x930>
   139bc:	42 c0       	rjmp	.+132    	; 0x13a42 <FMenuLocalAccount+0x9b4>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   139be:	2d b7       	in	r18, 0x3d	; 61
   139c0:	3e b7       	in	r19, 0x3e	; 62
   139c2:	28 50       	subi	r18, 0x08	; 8
   139c4:	30 40       	sbci	r19, 0x00	; 0
   139c6:	0f b6       	in	r0, 0x3f	; 63
   139c8:	f8 94       	cli
   139ca:	3e bf       	out	0x3e, r19	; 62
   139cc:	0f be       	out	0x3f, r0	; 63
   139ce:	2d bf       	out	0x3d, r18	; 61
   139d0:	ed b7       	in	r30, 0x3d	; 61
   139d2:	fe b7       	in	r31, 0x3e	; 62
   139d4:	31 96       	adiw	r30, 0x01	; 1
   139d6:	8e 01       	movw	r16, r28
   139d8:	04 5f       	subi	r16, 0xF4	; 244
   139da:	1f 4f       	sbci	r17, 0xFF	; 255
   139dc:	ad b7       	in	r26, 0x3d	; 61
   139de:	be b7       	in	r27, 0x3e	; 62
   139e0:	12 96       	adiw	r26, 0x02	; 2
   139e2:	1c 93       	st	X, r17
   139e4:	0e 93       	st	-X, r16
   139e6:	11 97       	sbiw	r26, 0x01	; 1
   139e8:	80 e0       	ldi	r24, 0x00	; 0
   139ea:	90 e2       	ldi	r25, 0x20	; 32
   139ec:	93 83       	std	Z+3, r25	; 0x03
   139ee:	82 83       	std	Z+2, r24	; 0x02
   139f0:	8a e9       	ldi	r24, 0x9A	; 154
   139f2:	92 e0       	ldi	r25, 0x02	; 2
   139f4:	95 83       	std	Z+5, r25	; 0x05
   139f6:	84 83       	std	Z+4, r24	; 0x04
   139f8:	87 e6       	ldi	r24, 0x67	; 103
   139fa:	97 e0       	ldi	r25, 0x07	; 7
   139fc:	97 83       	std	Z+7, r25	; 0x07
   139fe:	86 83       	std	Z+6, r24	; 0x06
   13a00:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   13a04:	ed b7       	in	r30, 0x3d	; 61
   13a06:	fe b7       	in	r31, 0x3e	; 62
   13a08:	38 96       	adiw	r30, 0x08	; 8
   13a0a:	0f b6       	in	r0, 0x3f	; 63
   13a0c:	f8 94       	cli
   13a0e:	fe bf       	out	0x3e, r31	; 62
   13a10:	0f be       	out	0x3f, r0	; 63
   13a12:	ed bf       	out	0x3d, r30	; 61
   13a14:	81 e0       	ldi	r24, 0x01	; 1
   13a16:	61 e0       	ldi	r22, 0x01	; 1
   13a18:	a8 01       	movw	r20, r16
   13a1a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   13a1e:	82 e0       	ldi	r24, 0x02	; 2
   13a20:	61 e0       	ldi	r22, 0x01	; 1
   13a22:	4b ee       	ldi	r20, 0xEB	; 235
   13a24:	5f e1       	ldi	r21, 0x1F	; 31
   13a26:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   13a2a:	83 e0       	ldi	r24, 0x03	; 3
   13a2c:	61 e0       	ldi	r22, 0x01	; 1
   13a2e:	46 ed       	ldi	r20, 0xD6	; 214
   13a30:	5f e1       	ldi	r21, 0x1F	; 31
   13a32:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   13a36:	84 e0       	ldi	r24, 0x04	; 4
   13a38:	61 e0       	ldi	r22, 0x01	; 1
   13a3a:	41 ec       	ldi	r20, 0xC1	; 193
   13a3c:	5f e1       	ldi	r21, 0x1F	; 31
   13a3e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				   }
                iLoop=0;
   13a42:	10 92 8e 02 	sts	0x028E, r1
   13a46:	10 92 8d 02 	sts	0x028D, r1
				iValuePos=0;
   13a4a:	10 92 99 02 	sts	0x0299, r1
				//ValueChar[iValuePos]=' ';
		        stLocalAccount=laBalanceValueInput;  
   13a4e:	80 e1       	ldi	r24, 0x10	; 16
   13a50:	a6 cb       	rjmp	.-2228   	; 0x1319e <FMenuLocalAccount+0x110>
		        break; 
           case laBalanceValueInput:
		        uiResult=UserInput(UI_NUMBER_R,(1+BalanceType),11,strBalanceValue,0,10); 
   13a52:	60 91 9d 02 	lds	r22, 0x029D
   13a56:	6f 5f       	subi	r22, 0xFF	; 255
   13a58:	81 e0       	ldi	r24, 0x01	; 1
   13a5a:	4b e0       	ldi	r20, 0x0B	; 11
   13a5c:	20 e3       	ldi	r18, 0x30	; 48
   13a5e:	3e e0       	ldi	r19, 0x0E	; 14
   13a60:	00 e0       	ldi	r16, 0x00	; 0
   13a62:	10 e0       	ldi	r17, 0x00	; 0
   13a64:	aa e0       	ldi	r26, 0x0A	; 10
   13a66:	ea 2e       	mov	r14, r26
   13a68:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
				if (uiResult==USER_CANCEL){
   13a6c:	81 30       	cpi	r24, 0x01	; 1
   13a6e:	39 f4       	brne	.+14     	; 0x13a7e <FMenuLocalAccount+0x9f0>
				    lcd_clear();
   13a70:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   13a74:	88 ea       	ldi	r24, 0xA8	; 168
   13a76:	91 e6       	ldi	r25, 0x61	; 97
   13a78:	01 97       	sbiw	r24, 0x01	; 1
   13a7a:	f1 f7       	brne	.-4      	; 0x13a78 <FMenuLocalAccount+0x9ea>
   13a7c:	f9 c0       	rjmp	.+498    	; 0x13c70 <FMenuLocalAccount+0xbe2>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (uiResult==USER_OK){				    
   13a7e:	83 30       	cpi	r24, 0x03	; 3
   13a80:	09 f0       	breq	.+2      	; 0x13a84 <FMenuLocalAccount+0x9f6>
   13a82:	b1 c3       	rjmp	.+1890   	; 0x141e6 <FMenuLocalAccount+0x1158>
				    stLocalAccount=laOdometer;
   13a84:	81 e1       	ldi	r24, 0x11	; 17
   13a86:	80 93 4c 01 	sts	0x014C, r24
					lcd_clear();
   13a8a:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   13a8e:	88 ea       	ldi	r24, 0xA8	; 168
   13a90:	91 e6       	ldi	r25, 0x61	; 97
   13a92:	01 97       	sbiw	r24, 0x01	; 1
   13a94:	f1 f7       	brne	.-4      	; 0x13a92 <FMenuLocalAccount+0xa04>
   13a96:	a7 c3       	rjmp	.+1870   	; 0x141e6 <FMenuLocalAccount+0x1158>
					_delay_ms(100);		        
					}
*/
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   13a98:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
				if (IsFullAuthorized==True){
   13a9c:	80 91 8f 02 	lds	r24, 0x028F
   13aa0:	81 30       	cpi	r24, 0x01	; 1
   13aa2:	09 f0       	breq	.+2      	; 0x13aa6 <FMenuLocalAccount+0xa18>
   13aa4:	4a c0       	rjmp	.+148    	; 0x13b3a <FMenuLocalAccount+0xaac>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   13aa6:	61 e0       	ldi	r22, 0x01	; 1
   13aa8:	4d ea       	ldi	r20, 0xAD	; 173
   13aaa:	5f e1       	ldi	r21, 0x1F	; 31
   13aac:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   13ab0:	2d b7       	in	r18, 0x3d	; 61
   13ab2:	3e b7       	in	r19, 0x3e	; 62
   13ab4:	28 50       	subi	r18, 0x08	; 8
   13ab6:	30 40       	sbci	r19, 0x00	; 0
   13ab8:	0f b6       	in	r0, 0x3f	; 63
   13aba:	f8 94       	cli
   13abc:	3e bf       	out	0x3e, r19	; 62
   13abe:	0f be       	out	0x3f, r0	; 63
   13ac0:	2d bf       	out	0x3d, r18	; 61
   13ac2:	ed b7       	in	r30, 0x3d	; 61
   13ac4:	fe b7       	in	r31, 0x3e	; 62
   13ac6:	31 96       	adiw	r30, 0x01	; 1
   13ac8:	8e 01       	movw	r16, r28
   13aca:	04 5f       	subi	r16, 0xF4	; 244
   13acc:	1f 4f       	sbci	r17, 0xFF	; 255
   13ace:	ad b7       	in	r26, 0x3d	; 61
   13ad0:	be b7       	in	r27, 0x3e	; 62
   13ad2:	12 96       	adiw	r26, 0x02	; 2
   13ad4:	1c 93       	st	X, r17
   13ad6:	0e 93       	st	-X, r16
   13ad8:	11 97       	sbiw	r26, 0x01	; 1
   13ada:	84 ea       	ldi	r24, 0xA4	; 164
   13adc:	9f e1       	ldi	r25, 0x1F	; 31
   13ade:	93 83       	std	Z+3, r25	; 0x03
   13ae0:	82 83       	std	Z+2, r24	; 0x02
   13ae2:	8a e9       	ldi	r24, 0x9A	; 154
   13ae4:	92 e0       	ldi	r25, 0x02	; 2
   13ae6:	95 83       	std	Z+5, r25	; 0x05
   13ae8:	84 83       	std	Z+4, r24	; 0x04
   13aea:	87 e6       	ldi	r24, 0x67	; 103
   13aec:	97 e0       	ldi	r25, 0x07	; 7
   13aee:	97 83       	std	Z+7, r25	; 0x07
   13af0:	86 83       	std	Z+6, r24	; 0x06
   13af2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13af6:	ed b7       	in	r30, 0x3d	; 61
   13af8:	fe b7       	in	r31, 0x3e	; 62
   13afa:	38 96       	adiw	r30, 0x08	; 8
   13afc:	0f b6       	in	r0, 0x3f	; 63
   13afe:	f8 94       	cli
   13b00:	fe bf       	out	0x3e, r31	; 62
   13b02:	0f be       	out	0x3f, r0	; 63
   13b04:	ed bf       	out	0x3d, r30	; 61
   13b06:	82 e0       	ldi	r24, 0x02	; 2
   13b08:	61 e0       	ldi	r22, 0x01	; 1
   13b0a:	a8 01       	movw	r20, r16
   13b0c:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   13b10:	00 d0       	rcall	.+0      	; 0x13b12 <FMenuLocalAccount+0xa84>
   13b12:	00 d0       	rcall	.+0      	; 0x13b14 <FMenuLocalAccount+0xa86>
   13b14:	ad b7       	in	r26, 0x3d	; 61
   13b16:	be b7       	in	r27, 0x3e	; 62
   13b18:	12 96       	adiw	r26, 0x02	; 2
   13b1a:	1c 93       	st	X, r17
   13b1c:	0e 93       	st	-X, r16
   13b1e:	11 97       	sbiw	r26, 0x01	; 1
   13b20:	8d e9       	ldi	r24, 0x9D	; 157
   13b22:	9f e1       	ldi	r25, 0x1F	; 31
   13b24:	14 96       	adiw	r26, 0x04	; 4
   13b26:	9c 93       	st	X, r25
   13b28:	8e 93       	st	-X, r24
   13b2a:	13 97       	sbiw	r26, 0x03	; 3
   13b2c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13b30:	0f 90       	pop	r0
   13b32:	0f 90       	pop	r0
   13b34:	0f 90       	pop	r0
   13b36:	0f 90       	pop	r0
   13b38:	5e c0       	rjmp	.+188    	; 0x13bf6 <FMenuLocalAccount+0xb68>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   13b3a:	80 91 9d 02 	lds	r24, 0x029D
   13b3e:	81 30       	cpi	r24, 0x01	; 1
   13b40:	29 f4       	brne	.+10     	; 0x13b4c <FMenuLocalAccount+0xabe>
   13b42:	61 e0       	ldi	r22, 0x01	; 1
   13b44:	49 e8       	ldi	r20, 0x89	; 137
   13b46:	5f e1       	ldi	r21, 0x1F	; 31
   13b48:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   13b4c:	80 91 9d 02 	lds	r24, 0x029D
   13b50:	82 30       	cpi	r24, 0x02	; 2
   13b52:	31 f4       	brne	.+12     	; 0x13b60 <FMenuLocalAccount+0xad2>
   13b54:	81 e0       	ldi	r24, 0x01	; 1
   13b56:	61 e0       	ldi	r22, 0x01	; 1
   13b58:	45 e7       	ldi	r20, 0x75	; 117
   13b5a:	5f e1       	ldi	r21, 0x1F	; 31
   13b5c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   13b60:	ed b7       	in	r30, 0x3d	; 61
   13b62:	fe b7       	in	r31, 0x3e	; 62
   13b64:	38 97       	sbiw	r30, 0x08	; 8
   13b66:	0f b6       	in	r0, 0x3f	; 63
   13b68:	f8 94       	cli
   13b6a:	fe bf       	out	0x3e, r31	; 62
   13b6c:	0f be       	out	0x3f, r0	; 63
   13b6e:	ed bf       	out	0x3d, r30	; 61
   13b70:	31 96       	adiw	r30, 0x01	; 1
   13b72:	8e 01       	movw	r16, r28
   13b74:	04 5f       	subi	r16, 0xF4	; 244
   13b76:	1f 4f       	sbci	r17, 0xFF	; 255
   13b78:	ad b7       	in	r26, 0x3d	; 61
   13b7a:	be b7       	in	r27, 0x3e	; 62
   13b7c:	12 96       	adiw	r26, 0x02	; 2
   13b7e:	1c 93       	st	X, r17
   13b80:	0e 93       	st	-X, r16
   13b82:	11 97       	sbiw	r26, 0x01	; 1
   13b84:	8c e6       	ldi	r24, 0x6C	; 108
   13b86:	9f e1       	ldi	r25, 0x1F	; 31
   13b88:	93 83       	std	Z+3, r25	; 0x03
   13b8a:	82 83       	std	Z+2, r24	; 0x02
   13b8c:	8a e9       	ldi	r24, 0x9A	; 154
   13b8e:	92 e0       	ldi	r25, 0x02	; 2
   13b90:	95 83       	std	Z+5, r25	; 0x05
   13b92:	84 83       	std	Z+4, r24	; 0x04
   13b94:	87 e6       	ldi	r24, 0x67	; 103
   13b96:	97 e0       	ldi	r25, 0x07	; 7
   13b98:	97 83       	std	Z+7, r25	; 0x07
   13b9a:	86 83       	std	Z+6, r24	; 0x06
   13b9c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13ba0:	ed b7       	in	r30, 0x3d	; 61
   13ba2:	fe b7       	in	r31, 0x3e	; 62
   13ba4:	38 96       	adiw	r30, 0x08	; 8
   13ba6:	0f b6       	in	r0, 0x3f	; 63
   13ba8:	f8 94       	cli
   13baa:	fe bf       	out	0x3e, r31	; 62
   13bac:	0f be       	out	0x3f, r0	; 63
   13bae:	ed bf       	out	0x3d, r30	; 61
   13bb0:	82 e0       	ldi	r24, 0x02	; 2
   13bb2:	61 e0       	ldi	r22, 0x01	; 1
   13bb4:	a8 01       	movw	r20, r16
   13bb6:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   13bba:	00 d0       	rcall	.+0      	; 0x13bbc <FMenuLocalAccount+0xb2e>
   13bbc:	00 d0       	rcall	.+0      	; 0x13bbe <FMenuLocalAccount+0xb30>
   13bbe:	00 d0       	rcall	.+0      	; 0x13bc0 <FMenuLocalAccount+0xb32>
   13bc0:	ed b7       	in	r30, 0x3d	; 61
   13bc2:	fe b7       	in	r31, 0x3e	; 62
   13bc4:	31 96       	adiw	r30, 0x01	; 1
   13bc6:	ad b7       	in	r26, 0x3d	; 61
   13bc8:	be b7       	in	r27, 0x3e	; 62
   13bca:	12 96       	adiw	r26, 0x02	; 2
   13bcc:	1c 93       	st	X, r17
   13bce:	0e 93       	st	-X, r16
   13bd0:	11 97       	sbiw	r26, 0x01	; 1
   13bd2:	88 e6       	ldi	r24, 0x68	; 104
   13bd4:	9f e1       	ldi	r25, 0x1F	; 31
   13bd6:	93 83       	std	Z+3, r25	; 0x03
   13bd8:	82 83       	std	Z+2, r24	; 0x02
   13bda:	80 e3       	ldi	r24, 0x30	; 48
   13bdc:	9e e0       	ldi	r25, 0x0E	; 14
   13bde:	95 83       	std	Z+5, r25	; 0x05
   13be0:	84 83       	std	Z+4, r24	; 0x04
   13be2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13be6:	ed b7       	in	r30, 0x3d	; 61
   13be8:	fe b7       	in	r31, 0x3e	; 62
   13bea:	36 96       	adiw	r30, 0x06	; 6
   13bec:	0f b6       	in	r0, 0x3f	; 63
   13bee:	f8 94       	cli
   13bf0:	fe bf       	out	0x3e, r31	; 62
   13bf2:	0f be       	out	0x3f, r0	; 63
   13bf4:	ed bf       	out	0x3d, r30	; 61
   13bf6:	82 e0       	ldi	r24, 0x02	; 2
   13bf8:	6e e0       	ldi	r22, 0x0E	; 14
   13bfa:	a8 01       	movw	r20, r16
   13bfc:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   13c00:	83 e0       	ldi	r24, 0x03	; 3
   13c02:	61 e0       	ldi	r22, 0x01	; 1
   13c04:	46 e5       	ldi	r20, 0x56	; 86
   13c06:	5f e1       	ldi	r21, 0x1F	; 31
   13c08:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   13c0c:	84 e0       	ldi	r24, 0x04	; 4
   13c0e:	61 e0       	ldi	r22, 0x01	; 1
   13c10:	44 e4       	ldi	r20, 0x44	; 68
   13c12:	5f e1       	ldi	r21, 0x1F	; 31
   13c14:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				ClearMem(strOdometer);
   13c18:	8c ec       	ldi	r24, 0xCC	; 204
   13c1a:	93 e0       	ldi	r25, 0x03	; 3
   13c1c:	0e 94 e6 a7 	call	0x14fcc	; 0x14fcc <ClearMem>
		        stLocalAccount=laOdometerInput;
   13c20:	82 e1       	ldi	r24, 0x12	; 18
   13c22:	bd ca       	rjmp	.-2694   	; 0x1319e <FMenuLocalAccount+0x110>
		        break;
           case laOdometerInput:
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   13c24:	fc ec       	ldi	r31, 0xCC	; 204
   13c26:	cf 2e       	mov	r12, r31
   13c28:	f3 e0       	ldi	r31, 0x03	; 3
   13c2a:	df 2e       	mov	r13, r31
   13c2c:	81 e0       	ldi	r24, 0x01	; 1
   13c2e:	63 e0       	ldi	r22, 0x03	; 3
   13c30:	4a e0       	ldi	r20, 0x0A	; 10
   13c32:	96 01       	movw	r18, r12
   13c34:	00 e0       	ldi	r16, 0x00	; 0
   13c36:	10 e0       	ldi	r17, 0x00	; 0
   13c38:	ea e0       	ldi	r30, 0x0A	; 10
   13c3a:	ee 2e       	mov	r14, r30
   13c3c:	0e 94 62 82 	call	0x104c4	; 0x104c4 <UserInput>
				if (uiResult==USER_OK){
   13c40:	83 30       	cpi	r24, 0x03	; 3
   13c42:	79 f4       	brne	.+30     	; 0x13c62 <FMenuLocalAccount+0xbd4>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   13c44:	f6 01       	movw	r30, r12
   13c46:	01 90       	ld	r0, Z+
   13c48:	00 20       	and	r0, r0
   13c4a:	e9 f7       	brne	.-6      	; 0x13c46 <FMenuLocalAccount+0xbb8>
   13c4c:	ee 5c       	subi	r30, 0xCE	; 206
   13c4e:	f3 40       	sbci	r31, 0x03	; 3
   13c50:	31 f4       	brne	.+12     	; 0x13c5e <FMenuLocalAccount+0xbd0>
   13c52:	80 91 cc 03 	lds	r24, 0x03CC
   13c56:	80 33       	cpi	r24, 0x30	; 48
   13c58:	11 f4       	brne	.+4      	; 0x13c5e <FMenuLocalAccount+0xbd0>
					    strOdometer[0]=0;
   13c5a:	10 92 cc 03 	sts	0x03CC, r1
				    stLocalAccount=laDataConfirm;
   13c5e:	83 e1       	ldi	r24, 0x13	; 19
   13c60:	9e ca       	rjmp	.-2756   	; 0x1319e <FMenuLocalAccount+0x110>
					}
			    else
			    if (uiResult==USER_CANCEL){
   13c62:	81 30       	cpi	r24, 0x01	; 1
   13c64:	09 f0       	breq	.+2      	; 0x13c68 <FMenuLocalAccount+0xbda>
   13c66:	bf c2       	rjmp	.+1406   	; 0x141e6 <FMenuLocalAccount+0x1158>
				    if (IsFullAuthorized==True)
   13c68:	80 91 8f 02 	lds	r24, 0x028F
   13c6c:	81 30       	cpi	r24, 0x01	; 1
   13c6e:	11 f4       	brne	.+4      	; 0x13c74 <FMenuLocalAccount+0xbe6>
					     stLocalAccount=laSelectBalanceType;
   13c70:	8d e0       	ldi	r24, 0x0D	; 13
   13c72:	95 ca       	rjmp	.-2774   	; 0x1319e <FMenuLocalAccount+0x110>
					else stLocalAccount=laBalanceValue;		        
   13c74:	8f e0       	ldi	r24, 0x0F	; 15
   13c76:	93 ca       	rjmp	.-2778   	; 0x1319e <FMenuLocalAccount+0x110>
				 }
		        break;
           case laDataConfirm: 
		        lcd_clear();
   13c78:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   13c7c:	e6 e3       	ldi	r30, 0x36	; 54
   13c7e:	f3 e0       	ldi	r31, 0x03	; 3
   13c80:	de 01       	movw	r26, r28
   13c82:	90 96       	adiw	r26, 0x20	; 32
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   13c84:	81 91       	ld	r24, Z+
   13c86:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   13c88:	33 e0       	ldi	r19, 0x03	; 3
   13c8a:	e0 34       	cpi	r30, 0x40	; 64
   13c8c:	f3 07       	cpc	r31, r19
   13c8e:	d1 f7       	brne	.-12     	; 0x13c84 <FMenuLocalAccount+0xbf6>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   13c90:	1a a6       	std	Y+42, r1	; 0x2a
				 }
		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   13c92:	00 d0       	rcall	.+0      	; 0x13c94 <FMenuLocalAccount+0xc06>
   13c94:	00 d0       	rcall	.+0      	; 0x13c96 <FMenuLocalAccount+0xc08>
   13c96:	00 d0       	rcall	.+0      	; 0x13c98 <FMenuLocalAccount+0xc0a>
   13c98:	ed b7       	in	r30, 0x3d	; 61
   13c9a:	fe b7       	in	r31, 0x3e	; 62
   13c9c:	31 96       	adiw	r30, 0x01	; 1
   13c9e:	8e 01       	movw	r16, r28
   13ca0:	04 5f       	subi	r16, 0xF4	; 244
   13ca2:	1f 4f       	sbci	r17, 0xFF	; 255
   13ca4:	ad b7       	in	r26, 0x3d	; 61
   13ca6:	be b7       	in	r27, 0x3e	; 62
   13ca8:	12 96       	adiw	r26, 0x02	; 2
   13caa:	1c 93       	st	X, r17
   13cac:	0e 93       	st	-X, r16
   13cae:	11 97       	sbiw	r26, 0x01	; 1
   13cb0:	80 e4       	ldi	r24, 0x40	; 64
   13cb2:	9f e1       	ldi	r25, 0x1F	; 31
   13cb4:	93 83       	std	Z+3, r25	; 0x03
   13cb6:	82 83       	std	Z+2, r24	; 0x02
   13cb8:	ce 01       	movw	r24, r28
   13cba:	80 96       	adiw	r24, 0x20	; 32
   13cbc:	95 83       	std	Z+5, r25	; 0x05
   13cbe:	84 83       	std	Z+4, r24	; 0x04
   13cc0:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13cc4:	ed b7       	in	r30, 0x3d	; 61
   13cc6:	fe b7       	in	r31, 0x3e	; 62
   13cc8:	36 96       	adiw	r30, 0x06	; 6
   13cca:	0f b6       	in	r0, 0x3f	; 63
   13ccc:	f8 94       	cli
   13cce:	fe bf       	out	0x3e, r31	; 62
   13cd0:	0f be       	out	0x3f, r0	; 63
   13cd2:	ed bf       	out	0x3d, r30	; 61
   13cd4:	81 e0       	ldi	r24, 0x01	; 1
   13cd6:	61 e0       	ldi	r22, 0x01	; 1
   13cd8:	a8 01       	movw	r20, r16
   13cda:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   13cde:	00 d0       	rcall	.+0      	; 0x13ce0 <FMenuLocalAccount+0xc52>
   13ce0:	00 d0       	rcall	.+0      	; 0x13ce2 <FMenuLocalAccount+0xc54>
   13ce2:	00 d0       	rcall	.+0      	; 0x13ce4 <FMenuLocalAccount+0xc56>
   13ce4:	ed b7       	in	r30, 0x3d	; 61
   13ce6:	fe b7       	in	r31, 0x3e	; 62
   13ce8:	31 96       	adiw	r30, 0x01	; 1
   13cea:	ad b7       	in	r26, 0x3d	; 61
   13cec:	be b7       	in	r27, 0x3e	; 62
   13cee:	12 96       	adiw	r26, 0x02	; 2
   13cf0:	1c 93       	st	X, r17
   13cf2:	0e 93       	st	-X, r16
   13cf4:	11 97       	sbiw	r26, 0x01	; 1
   13cf6:	89 e3       	ldi	r24, 0x39	; 57
   13cf8:	9f e1       	ldi	r25, 0x1F	; 31
   13cfa:	93 83       	std	Z+3, r25	; 0x03
   13cfc:	82 83       	std	Z+2, r24	; 0x02
   13cfe:	82 e9       	ldi	r24, 0x92	; 146
   13d00:	9d e0       	ldi	r25, 0x0D	; 13
   13d02:	95 83       	std	Z+5, r25	; 0x05
   13d04:	84 83       	std	Z+4, r24	; 0x04
   13d06:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13d0a:	ed b7       	in	r30, 0x3d	; 61
   13d0c:	fe b7       	in	r31, 0x3e	; 62
   13d0e:	36 96       	adiw	r30, 0x06	; 6
   13d10:	0f b6       	in	r0, 0x3f	; 63
   13d12:	f8 94       	cli
   13d14:	fe bf       	out	0x3e, r31	; 62
   13d16:	0f be       	out	0x3f, r0	; 63
   13d18:	ed bf       	out	0x3d, r30	; 61
   13d1a:	82 e0       	ldi	r24, 0x02	; 2
   13d1c:	61 e0       	ldi	r22, 0x01	; 1
   13d1e:	a8 01       	movw	r20, r16
   13d20:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   13d24:	2d b7       	in	r18, 0x3d	; 61
   13d26:	3e b7       	in	r19, 0x3e	; 62
   13d28:	28 50       	subi	r18, 0x08	; 8
   13d2a:	30 40       	sbci	r19, 0x00	; 0
   13d2c:	0f b6       	in	r0, 0x3f	; 63
   13d2e:	f8 94       	cli
   13d30:	3e bf       	out	0x3e, r19	; 62
   13d32:	0f be       	out	0x3f, r0	; 63
   13d34:	2d bf       	out	0x3d, r18	; 61
   13d36:	ed b7       	in	r30, 0x3d	; 61
   13d38:	fe b7       	in	r31, 0x3e	; 62
   13d3a:	31 96       	adiw	r30, 0x01	; 1
   13d3c:	ad b7       	in	r26, 0x3d	; 61
   13d3e:	be b7       	in	r27, 0x3e	; 62
   13d40:	12 96       	adiw	r26, 0x02	; 2
   13d42:	1c 93       	st	X, r17
   13d44:	0e 93       	st	-X, r16
   13d46:	11 97       	sbiw	r26, 0x01	; 1
   13d48:	81 e3       	ldi	r24, 0x31	; 49
   13d4a:	9f e1       	ldi	r25, 0x1F	; 31
   13d4c:	93 83       	std	Z+3, r25	; 0x03
   13d4e:	82 83       	std	Z+2, r24	; 0x02
   13d50:	8a e9       	ldi	r24, 0x9A	; 154
   13d52:	92 e0       	ldi	r25, 0x02	; 2
   13d54:	95 83       	std	Z+5, r25	; 0x05
   13d56:	84 83       	std	Z+4, r24	; 0x04
   13d58:	87 e6       	ldi	r24, 0x67	; 103
   13d5a:	97 e0       	ldi	r25, 0x07	; 7
   13d5c:	97 83       	std	Z+7, r25	; 0x07
   13d5e:	86 83       	std	Z+6, r24	; 0x06
   13d60:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13d64:	ed b7       	in	r30, 0x3d	; 61
   13d66:	fe b7       	in	r31, 0x3e	; 62
   13d68:	38 96       	adiw	r30, 0x08	; 8
   13d6a:	0f b6       	in	r0, 0x3f	; 63
   13d6c:	f8 94       	cli
   13d6e:	fe bf       	out	0x3e, r31	; 62
   13d70:	0f be       	out	0x3f, r0	; 63
   13d72:	ed bf       	out	0x3d, r30	; 61
   13d74:	83 e0       	ldi	r24, 0x03	; 3
   13d76:	61 e0       	ldi	r22, 0x01	; 1
   13d78:	a8 01       	movw	r20, r16
   13d7a:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		        if (IsFullAuthorized==True){
   13d7e:	80 91 8f 02 	lds	r24, 0x028F
   13d82:	81 30       	cpi	r24, 0x01	; 1
   13d84:	39 f4       	brne	.+14     	; 0x13d94 <FMenuLocalAccount+0xd06>
                    lcd_printf(3,15,PSTR(" Full"));
   13d86:	83 e0       	ldi	r24, 0x03	; 3
   13d88:	6f e0       	ldi	r22, 0x0F	; 15
   13d8a:	4b e2       	ldi	r20, 0x2B	; 43
   13d8c:	5f e1       	ldi	r21, 0x1F	; 31
   13d8e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   13d92:	23 c0       	rjmp	.+70     	; 0x13dda <FMenuLocalAccount+0xd4c>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   13d94:	00 d0       	rcall	.+0      	; 0x13d96 <FMenuLocalAccount+0xd08>
   13d96:	00 d0       	rcall	.+0      	; 0x13d98 <FMenuLocalAccount+0xd0a>
   13d98:	00 d0       	rcall	.+0      	; 0x13d9a <FMenuLocalAccount+0xd0c>
   13d9a:	ed b7       	in	r30, 0x3d	; 61
   13d9c:	fe b7       	in	r31, 0x3e	; 62
   13d9e:	31 96       	adiw	r30, 0x01	; 1
   13da0:	ad b7       	in	r26, 0x3d	; 61
   13da2:	be b7       	in	r27, 0x3e	; 62
   13da4:	12 96       	adiw	r26, 0x02	; 2
   13da6:	1c 93       	st	X, r17
   13da8:	0e 93       	st	-X, r16
   13daa:	11 97       	sbiw	r26, 0x01	; 1
   13dac:	87 e2       	ldi	r24, 0x27	; 39
   13dae:	9f e1       	ldi	r25, 0x1F	; 31
   13db0:	93 83       	std	Z+3, r25	; 0x03
   13db2:	82 83       	std	Z+2, r24	; 0x02
   13db4:	80 e3       	ldi	r24, 0x30	; 48
   13db6:	9e e0       	ldi	r25, 0x0E	; 14
   13db8:	95 83       	std	Z+5, r25	; 0x05
   13dba:	84 83       	std	Z+4, r24	; 0x04
   13dbc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13dc0:	ed b7       	in	r30, 0x3d	; 61
   13dc2:	fe b7       	in	r31, 0x3e	; 62
   13dc4:	36 96       	adiw	r30, 0x06	; 6
   13dc6:	0f b6       	in	r0, 0x3f	; 63
   13dc8:	f8 94       	cli
   13dca:	fe bf       	out	0x3e, r31	; 62
   13dcc:	0f be       	out	0x3f, r0	; 63
   13dce:	ed bf       	out	0x3d, r30	; 61
   13dd0:	83 e0       	ldi	r24, 0x03	; 3
   13dd2:	6f e0       	ldi	r22, 0x0F	; 15
   13dd4:	a8 01       	movw	r20, r16
   13dd6:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   13dda:	84 e0       	ldi	r24, 0x04	; 4
   13ddc:	61 e0       	ldi	r22, 0x01	; 1
   13dde:	42 e1       	ldi	r20, 0x12	; 18
   13de0:	5f e1       	ldi	r21, 0x1F	; 31
   13de2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   13de6:	84 e1       	ldi	r24, 0x14	; 20
   13de8:	da c9       	rjmp	.-3148   	; 0x1319e <FMenuLocalAccount+0x110>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   13dea:	81 e0       	ldi	r24, 0x01	; 1
   13dec:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   13df0:	87 3e       	cpi	r24, 0xE7	; 231
   13df2:	11 f4       	brne	.+4      	; 0x13df8 <FMenuLocalAccount+0xd6a>
   13df4:	81 e1       	ldi	r24, 0x11	; 17
   13df6:	d3 c9       	rjmp	.-3162   	; 0x1319e <FMenuLocalAccount+0x110>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   13df8:	87 3b       	cpi	r24, 0xB7	; 183
   13dfa:	11 f4       	brne	.+4      	; 0x13e00 <FMenuLocalAccount+0xd72>
   13dfc:	85 e1       	ldi	r24, 0x15	; 21
   13dfe:	cf c9       	rjmp	.-3170   	; 0x1319e <FMenuLocalAccount+0x110>
				else
				if (KeyPressed==_KEY_0){
   13e00:	87 3d       	cpi	r24, 0xD7	; 215
   13e02:	09 f0       	breq	.+2      	; 0x13e06 <FMenuLocalAccount+0xd78>
   13e04:	f0 c1       	rjmp	.+992    	; 0x141e6 <FMenuLocalAccount+0x1158>
				   //ShowCancel
				   TimLocAcc=0;
   13e06:	10 92 bc 01 	sts	0x01BC, r1
                   lcd_clear();
   13e0a:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   13e0e:	81 e0       	ldi	r24, 0x01	; 1
   13e10:	61 e0       	ldi	r22, 0x01	; 1
   13e12:	4d ef       	ldi	r20, 0xFD	; 253
   13e14:	5e e1       	ldi	r21, 0x1E	; 30
   13e16:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   13e1a:	d4 c1       	rjmp	.+936    	; 0x141c4 <FMenuLocalAccount+0x1136>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   13e1c:	0e 94 5f 50 	call	0xa0be	; 0xa0be <sendMessage58>
                RemZeroLead(strCardID);
   13e20:	82 e9       	ldi	r24, 0x92	; 146
   13e22:	9d e0       	ldi	r25, 0x0D	; 13
   13e24:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
                RemZeroLead(strBalanceValue);
   13e28:	70 e3       	ldi	r23, 0x30	; 48
   13e2a:	e7 2e       	mov	r14, r23
   13e2c:	7e e0       	ldi	r23, 0x0E	; 14
   13e2e:	f7 2e       	mov	r15, r23
   13e30:	c7 01       	movw	r24, r14
   13e32:	0e 94 97 28 	call	0x512e	; 0x512e <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   13e36:	2d b7       	in	r18, 0x3d	; 61
   13e38:	3e b7       	in	r19, 0x3e	; 62
   13e3a:	28 50       	subi	r18, 0x08	; 8
   13e3c:	30 40       	sbci	r19, 0x00	; 0
   13e3e:	0f b6       	in	r0, 0x3f	; 63
   13e40:	f8 94       	cli
   13e42:	3e bf       	out	0x3e, r19	; 62
   13e44:	0f be       	out	0x3f, r0	; 63
   13e46:	2d bf       	out	0x3d, r18	; 61
   13e48:	ed b7       	in	r30, 0x3d	; 61
   13e4a:	fe b7       	in	r31, 0x3e	; 62
   13e4c:	31 96       	adiw	r30, 0x01	; 1
   13e4e:	8e 01       	movw	r16, r28
   13e50:	04 5f       	subi	r16, 0xF4	; 244
   13e52:	1f 4f       	sbci	r17, 0xFF	; 255
   13e54:	ad b7       	in	r26, 0x3d	; 61
   13e56:	be b7       	in	r27, 0x3e	; 62
   13e58:	12 96       	adiw	r26, 0x02	; 2
   13e5a:	1c 93       	st	X, r17
   13e5c:	0e 93       	st	-X, r16
   13e5e:	11 97       	sbiw	r26, 0x01	; 1
   13e60:	85 ef       	ldi	r24, 0xF5	; 245
   13e62:	9e e1       	ldi	r25, 0x1E	; 30
   13e64:	93 83       	std	Z+3, r25	; 0x03
   13e66:	82 83       	std	Z+2, r24	; 0x02
   13e68:	8a e9       	ldi	r24, 0x9A	; 154
   13e6a:	92 e0       	ldi	r25, 0x02	; 2
   13e6c:	95 83       	std	Z+5, r25	; 0x05
   13e6e:	84 83       	std	Z+4, r24	; 0x04
   13e70:	87 e6       	ldi	r24, 0x67	; 103
   13e72:	97 e0       	ldi	r25, 0x07	; 7
   13e74:	97 83       	std	Z+7, r25	; 0x07
   13e76:	86 83       	std	Z+6, r24	; 0x06
   13e78:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13e7c:	ed b7       	in	r30, 0x3d	; 61
   13e7e:	fe b7       	in	r31, 0x3e	; 62
   13e80:	38 96       	adiw	r30, 0x08	; 8
   13e82:	0f b6       	in	r0, 0x3f	; 63
   13e84:	f8 94       	cli
   13e86:	fe bf       	out	0x3e, r31	; 62
   13e88:	0f be       	out	0x3f, r0	; 63
   13e8a:	ed bf       	out	0x3d, r30	; 61
   13e8c:	81 e0       	ldi	r24, 0x01	; 1
   13e8e:	61 e0       	ldi	r22, 0x01	; 1
   13e90:	a8 01       	movw	r20, r16
   13e92:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   13e96:	00 d0       	rcall	.+0      	; 0x13e98 <FMenuLocalAccount+0xe0a>
   13e98:	00 d0       	rcall	.+0      	; 0x13e9a <FMenuLocalAccount+0xe0c>
   13e9a:	00 d0       	rcall	.+0      	; 0x13e9c <FMenuLocalAccount+0xe0e>
   13e9c:	ed b7       	in	r30, 0x3d	; 61
   13e9e:	fe b7       	in	r31, 0x3e	; 62
   13ea0:	31 96       	adiw	r30, 0x01	; 1
   13ea2:	ad b7       	in	r26, 0x3d	; 61
   13ea4:	be b7       	in	r27, 0x3e	; 62
   13ea6:	12 96       	adiw	r26, 0x02	; 2
   13ea8:	1c 93       	st	X, r17
   13eaa:	0e 93       	st	-X, r16
   13eac:	11 97       	sbiw	r26, 0x01	; 1
   13eae:	82 ef       	ldi	r24, 0xF2	; 242
   13eb0:	9e e1       	ldi	r25, 0x1E	; 30
   13eb2:	93 83       	std	Z+3, r25	; 0x03
   13eb4:	82 83       	std	Z+2, r24	; 0x02
   13eb6:	f5 82       	std	Z+5, r15	; 0x05
   13eb8:	e4 82       	std	Z+4, r14	; 0x04
   13eba:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   13ebe:	ed b7       	in	r30, 0x3d	; 61
   13ec0:	fe b7       	in	r31, 0x3e	; 62
   13ec2:	36 96       	adiw	r30, 0x06	; 6
   13ec4:	0f b6       	in	r0, 0x3f	; 63
   13ec6:	f8 94       	cli
   13ec8:	fe bf       	out	0x3e, r31	; 62
   13eca:	0f be       	out	0x3f, r0	; 63
   13ecc:	ed bf       	out	0x3d, r30	; 61
   13ece:	81 e0       	ldi	r24, 0x01	; 1
   13ed0:	6f e0       	ldi	r22, 0x0F	; 15
   13ed2:	a8 01       	movw	r20, r16
   13ed4:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   13ed8:	83 e0       	ldi	r24, 0x03	; 3
   13eda:	61 e0       	ldi	r22, 0x01	; 1
   13edc:	4d ed       	ldi	r20, 0xDD	; 221
   13ede:	5e e1       	ldi	r21, 0x1E	; 30
   13ee0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   13ee4:	84 e0       	ldi	r24, 0x04	; 4
   13ee6:	61 e0       	ldi	r22, 0x01	; 1
   13ee8:	48 ec       	ldi	r20, 0xC8	; 200
   13eea:	5e e1       	ldi	r21, 0x1E	; 30
   13eec:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				IsMessage00=False;
   13ef0:	10 92 a0 01 	sts	0x01A0, r1
				TimLocAcc=0;
   13ef4:	10 92 bc 01 	sts	0x01BC, r1
				iLoop=0;iPos=0;iWait=0;
   13ef8:	10 92 8e 02 	sts	0x028E, r1
   13efc:	10 92 8d 02 	sts	0x028D, r1
   13f00:	10 92 9f 02 	sts	0x029F, r1
   13f04:	10 92 9e 02 	sts	0x029E, r1
				stLocalAccount=laWaitMessage00;
   13f08:	87 e1       	ldi	r24, 0x17	; 23
   13f0a:	49 c9       	rjmp	.-3438   	; 0x1319e <FMenuLocalAccount+0x110>
		        break;
           case laWaitMessage00:
                iLoop++;
   13f0c:	80 91 8d 02 	lds	r24, 0x028D
   13f10:	90 91 8e 02 	lds	r25, 0x028E
   13f14:	01 96       	adiw	r24, 0x01	; 1
   13f16:	90 93 8e 02 	sts	0x028E, r25
   13f1a:	80 93 8d 02 	sts	0x028D, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   13f1e:	68 e9       	ldi	r22, 0x98	; 152
   13f20:	7a e3       	ldi	r23, 0x3A	; 58
   13f22:	0e 94 15 b4 	call	0x1682a	; 0x1682a <__udivmodhi4>
   13f26:	89 2b       	or	r24, r25
   13f28:	e1 f4       	brne	.+56     	; 0x13f62 <FMenuLocalAccount+0xed4>
				   if (iPos<5){
   13f2a:	60 91 9f 02 	lds	r22, 0x029F
   13f2e:	65 30       	cpi	r22, 0x05	; 5
   13f30:	58 f4       	brcc	.+22     	; 0x13f48 <FMenuLocalAccount+0xeba>
				       iPos++;
   13f32:	6f 5f       	subi	r22, 0xFF	; 255
   13f34:	60 93 9f 02 	sts	0x029F, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   13f38:	62 5f       	subi	r22, 0xF2	; 242
   13f3a:	83 e0       	ldi	r24, 0x03	; 3
   13f3c:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
   13f40:	8e e2       	ldi	r24, 0x2E	; 46
   13f42:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
   13f46:	0d c0       	rjmp	.+26     	; 0x13f62 <FMenuLocalAccount+0xed4>
					   }
				   else{
				       iPos=0;
   13f48:	10 92 9f 02 	sts	0x029F, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   13f4c:	83 e0       	ldi	r24, 0x03	; 3
   13f4e:	6e e0       	ldi	r22, 0x0E	; 14
   13f50:	40 ec       	ldi	r20, 0xC0	; 192
   13f52:	5e e1       	ldi	r21, 0x1E	; 30
   13f54:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
					   iWait++;
   13f58:	80 91 9e 02 	lds	r24, 0x029E
   13f5c:	8f 5f       	subi	r24, 0xFF	; 255
   13f5e:	80 93 9e 02 	sts	0x029E, r24
					   }
				}
				if (iWait>5){
   13f62:	80 91 9e 02 	lds	r24, 0x029E
   13f66:	86 30       	cpi	r24, 0x06	; 6
   13f68:	50 f0       	brcs	.+20     	; 0x13f7e <FMenuLocalAccount+0xef0>
				    stLocalAccount=laConTimout;
   13f6a:	84 e0       	ldi	r24, 0x04	; 4
   13f6c:	80 93 4c 01 	sts	0x014C, r24
					TimLocAcc=0;
   13f70:	10 92 bc 01 	sts	0x01BC, r1
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13f74:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13f76:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13f78:	82 e0       	ldi	r24, 0x02	; 2
   13f7a:	80 93 be 01 	sts	0x01BE, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   13f7e:	80 91 a0 01 	lds	r24, 0x01A0
   13f82:	81 30       	cpi	r24, 0x01	; 1
   13f84:	09 f0       	breq	.+2      	; 0x13f88 <FMenuLocalAccount+0xefa>
   13f86:	2f c1       	rjmp	.+606    	; 0x141e6 <FMenuLocalAccount+0x1158>
                    IsMessage00=False;
   13f88:	10 92 a0 01 	sts	0x01A0, r1
				    stLocalAccount=laProcMessage00;
   13f8c:	88 e1       	ldi	r24, 0x18	; 24
   13f8e:	07 c9       	rjmp	.-3570   	; 0x1319e <FMenuLocalAccount+0x110>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   13f90:	80 91 26 0b 	lds	r24, 0x0B26
   13f94:	81 30       	cpi	r24, 0x01	; 1
   13f96:	51 f4       	brne	.+20     	; 0x13fac <FMenuLocalAccount+0xf1e>
   13f98:	80 91 8d 01 	lds	r24, 0x018D
   13f9c:	90 91 8e 01 	lds	r25, 0x018E
   13fa0:	8f 97       	sbiw	r24, 0x2f	; 47
   13fa2:	21 f4       	brne	.+8      	; 0x13fac <FMenuLocalAccount+0xf1e>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   13fa4:	80 91 4b 0b 	lds	r24, 0x0B4B
   13fa8:	80 53       	subi	r24, 0x30	; 48
   13faa:	01 c0       	rjmp	.+2      	; 0x13fae <FMenuLocalAccount+0xf20>
   13fac:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   13fae:	80 93 a0 02 	sts	0x02A0, r24
                lcd_clear();
   13fb2:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		        switch(LocAccStatus){
   13fb6:	10 91 a0 02 	lds	r17, 0x02A0
   13fba:	11 30       	cpi	r17, 0x01	; 1
   13fbc:	51 f0       	breq	.+20     	; 0x13fd2 <FMenuLocalAccount+0xf44>
   13fbe:	11 30       	cpi	r17, 0x01	; 1
   13fc0:	18 f0       	brcs	.+6      	; 0x13fc8 <FMenuLocalAccount+0xf3a>
   13fc2:	13 30       	cpi	r17, 0x03	; 3
   13fc4:	51 f5       	brne	.+84     	; 0x1401a <FMenuLocalAccount+0xf8c>
   13fc6:	1b c0       	rjmp	.+54     	; 0x13ffe <FMenuLocalAccount+0xf70>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   13fc8:	82 e0       	ldi	r24, 0x02	; 2
   13fca:	61 e0       	ldi	r22, 0x01	; 1
   13fcc:	4b ea       	ldi	r20, 0xAB	; 171
   13fce:	5e e1       	ldi	r21, 0x1E	; 30
   13fd0:	1a c0       	rjmp	.+52     	; 0x14006 <FMenuLocalAccount+0xf78>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   13fd2:	82 e0       	ldi	r24, 0x02	; 2
   13fd4:	61 e0       	ldi	r22, 0x01	; 1
   13fd6:	46 e9       	ldi	r20, 0x96	; 150
   13fd8:	5e e1       	ldi	r21, 0x1E	; 30
   13fda:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   13fde:	90 91 91 01 	lds	r25, 0x0191
   13fe2:	e9 2f       	mov	r30, r25
   13fe4:	f0 e0       	ldi	r31, 0x00	; 0
   13fe6:	e1 5a       	subi	r30, 0xA1	; 161
   13fe8:	fc 4f       	sbci	r31, 0xFC	; 252
   13fea:	80 91 91 02 	lds	r24, 0x0291
   13fee:	80 83       	st	Z, r24
					 nLocalAccount++;
   13ff0:	9f 5f       	subi	r25, 0xFF	; 255
   13ff2:	90 93 91 01 	sts	0x0191, r25
					 IsViewFillingFIP=True;
   13ff6:	10 93 98 01 	sts	0x0198, r17
					 stLocalAccount=laViewStatus;
   13ffa:	86 e1       	ldi	r24, 0x16	; 22
   13ffc:	0c c0       	rjmp	.+24     	; 0x14016 <FMenuLocalAccount+0xf88>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   13ffe:	82 e0       	ldi	r24, 0x02	; 2
   14000:	61 e0       	ldi	r22, 0x01	; 1
   14002:	43 e8       	ldi	r20, 0x83	; 131
   14004:	5e e1       	ldi	r21, 0x1E	; 30
   14006:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1400a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1400c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1400e:	82 e0       	ldi	r24, 0x02	; 2
   14010:	80 93 be 01 	sts	0x01BE, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   14014:	8e e1       	ldi	r24, 0x1E	; 30
   14016:	80 93 4c 01 	sts	0x014C, r24
				     break;
				}
				TimLocAcc=0;
   1401a:	10 92 bc 01 	sts	0x01BC, r1
				ClearMem(strOdometer);
   1401e:	8c ec       	ldi	r24, 0xCC	; 204
   14020:	93 e0       	ldi	r25, 0x03	; 3
   14022:	0e 94 e6 a7 	call	0x14fcc	; 0x14fcc <ClearMem>
	            ClearMem(strLicPlate);
   14026:	83 e0       	ldi	r24, 0x03	; 3
   14028:	99 e0       	ldi	r25, 0x09	; 9
   1402a:	0e 94 e6 a7 	call	0x14fcc	; 0x14fcc <ClearMem>
   1402e:	db c0       	rjmp	.+438    	; 0x141e6 <FMenuLocalAccount+0x1158>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   14030:	80 91 bc 01 	lds	r24, 0x01BC
   14034:	85 31       	cpi	r24, 0x15	; 21
   14036:	08 f4       	brcc	.+2      	; 0x1403a <FMenuLocalAccount+0xfac>
   14038:	d6 c0       	rjmp	.+428    	; 0x141e6 <FMenuLocalAccount+0x1158>
   1403a:	cb c0       	rjmp	.+406    	; 0x141d2 <FMenuLocalAccount+0x1144>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   1403c:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14040:	2d b7       	in	r18, 0x3d	; 61
   14042:	3e b7       	in	r19, 0x3e	; 62
   14044:	28 50       	subi	r18, 0x08	; 8
   14046:	30 40       	sbci	r19, 0x00	; 0
   14048:	0f b6       	in	r0, 0x3f	; 63
   1404a:	f8 94       	cli
   1404c:	3e bf       	out	0x3e, r19	; 62
   1404e:	0f be       	out	0x3f, r0	; 63
   14050:	2d bf       	out	0x3d, r18	; 61
   14052:	ed b7       	in	r30, 0x3d	; 61
   14054:	fe b7       	in	r31, 0x3e	; 62
   14056:	31 96       	adiw	r30, 0x01	; 1
   14058:	6c e0       	ldi	r22, 0x0C	; 12
   1405a:	e6 2e       	mov	r14, r22
   1405c:	f1 2c       	mov	r15, r1
   1405e:	ec 0e       	add	r14, r28
   14060:	fd 1e       	adc	r15, r29
   14062:	ad b7       	in	r26, 0x3d	; 61
   14064:	be b7       	in	r27, 0x3e	; 62
   14066:	12 96       	adiw	r26, 0x02	; 2
   14068:	fc 92       	st	X, r15
   1406a:	ee 92       	st	-X, r14
   1406c:	11 97       	sbiw	r26, 0x01	; 1
   1406e:	8b e7       	ldi	r24, 0x7B	; 123
   14070:	9e e1       	ldi	r25, 0x1E	; 30
   14072:	93 83       	std	Z+3, r25	; 0x03
   14074:	82 83       	std	Z+2, r24	; 0x02
   14076:	8a e9       	ldi	r24, 0x9A	; 154
   14078:	92 e0       	ldi	r25, 0x02	; 2
   1407a:	95 83       	std	Z+5, r25	; 0x05
   1407c:	84 83       	std	Z+4, r24	; 0x04
   1407e:	87 e6       	ldi	r24, 0x67	; 103
   14080:	97 e0       	ldi	r25, 0x07	; 7
   14082:	97 83       	std	Z+7, r25	; 0x07
   14084:	86 83       	std	Z+6, r24	; 0x06
   14086:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   1408a:	ed b7       	in	r30, 0x3d	; 61
   1408c:	fe b7       	in	r31, 0x3e	; 62
   1408e:	38 96       	adiw	r30, 0x08	; 8
   14090:	0f b6       	in	r0, 0x3f	; 63
   14092:	f8 94       	cli
   14094:	fe bf       	out	0x3e, r31	; 62
   14096:	0f be       	out	0x3f, r0	; 63
   14098:	ed bf       	out	0x3d, r30	; 61
   1409a:	81 e0       	ldi	r24, 0x01	; 1
   1409c:	61 e0       	ldi	r22, 0x01	; 1
   1409e:	a7 01       	movw	r20, r14
   140a0:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   140a4:	00 d0       	rcall	.+0      	; 0x140a6 <FMenuLocalAccount+0x1018>
   140a6:	00 d0       	rcall	.+0      	; 0x140a8 <FMenuLocalAccount+0x101a>
   140a8:	00 d0       	rcall	.+0      	; 0x140aa <FMenuLocalAccount+0x101c>
   140aa:	ed b7       	in	r30, 0x3d	; 61
   140ac:	fe b7       	in	r31, 0x3e	; 62
   140ae:	31 96       	adiw	r30, 0x01	; 1
   140b0:	ad b7       	in	r26, 0x3d	; 61
   140b2:	be b7       	in	r27, 0x3e	; 62
   140b4:	12 96       	adiw	r26, 0x02	; 2
   140b6:	fc 92       	st	X, r15
   140b8:	ee 92       	st	-X, r14
   140ba:	11 97       	sbiw	r26, 0x01	; 1
   140bc:	88 e7       	ldi	r24, 0x78	; 120
   140be:	9e e1       	ldi	r25, 0x1E	; 30
   140c0:	93 83       	std	Z+3, r25	; 0x03
   140c2:	82 83       	std	Z+2, r24	; 0x02
   140c4:	80 e3       	ldi	r24, 0x30	; 48
   140c6:	9e e0       	ldi	r25, 0x0E	; 14
   140c8:	95 83       	std	Z+5, r25	; 0x05
   140ca:	84 83       	std	Z+4, r24	; 0x04
   140cc:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   140d0:	ed b7       	in	r30, 0x3d	; 61
   140d2:	fe b7       	in	r31, 0x3e	; 62
   140d4:	36 96       	adiw	r30, 0x06	; 6
   140d6:	0f b6       	in	r0, 0x3f	; 63
   140d8:	f8 94       	cli
   140da:	fe bf       	out	0x3e, r31	; 62
   140dc:	0f be       	out	0x3f, r0	; 63
   140de:	ed bf       	out	0x3d, r30	; 61
   140e0:	81 e0       	ldi	r24, 0x01	; 1
   140e2:	6f e0       	ldi	r22, 0x0F	; 15
   140e4:	a7 01       	movw	r20, r14
   140e6:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
                RemSpaceLead(strCardID);
   140ea:	02 e9       	ldi	r16, 0x92	; 146
   140ec:	1d e0       	ldi	r17, 0x0D	; 13
   140ee:	c8 01       	movw	r24, r16
   140f0:	0e 94 df 28 	call	0x51be	; 0x51be <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   140f4:	00 d0       	rcall	.+0      	; 0x140f6 <FMenuLocalAccount+0x1068>
   140f6:	00 d0       	rcall	.+0      	; 0x140f8 <FMenuLocalAccount+0x106a>
   140f8:	00 d0       	rcall	.+0      	; 0x140fa <FMenuLocalAccount+0x106c>
   140fa:	ed b7       	in	r30, 0x3d	; 61
   140fc:	fe b7       	in	r31, 0x3e	; 62
   140fe:	31 96       	adiw	r30, 0x01	; 1
   14100:	ad b7       	in	r26, 0x3d	; 61
   14102:	be b7       	in	r27, 0x3e	; 62
   14104:	12 96       	adiw	r26, 0x02	; 2
   14106:	fc 92       	st	X, r15
   14108:	ee 92       	st	-X, r14
   1410a:	11 97       	sbiw	r26, 0x01	; 1
   1410c:	81 e7       	ldi	r24, 0x71	; 113
   1410e:	9e e1       	ldi	r25, 0x1E	; 30
   14110:	93 83       	std	Z+3, r25	; 0x03
   14112:	82 83       	std	Z+2, r24	; 0x02
   14114:	15 83       	std	Z+5, r17	; 0x05
   14116:	04 83       	std	Z+4, r16	; 0x04
   14118:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   1411c:	ed b7       	in	r30, 0x3d	; 61
   1411e:	fe b7       	in	r31, 0x3e	; 62
   14120:	36 96       	adiw	r30, 0x06	; 6
   14122:	0f b6       	in	r0, 0x3f	; 63
   14124:	f8 94       	cli
   14126:	fe bf       	out	0x3e, r31	; 62
   14128:	0f be       	out	0x3f, r0	; 63
   1412a:	ed bf       	out	0x3d, r30	; 61
   1412c:	82 e0       	ldi	r24, 0x02	; 2
   1412e:	61 e0       	ldi	r22, 0x01	; 1
   14130:	a7 01       	movw	r20, r14
   14132:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
				TimLocAcc=0;
   14136:	10 92 bc 01 	sts	0x01BC, r1
		        IsCompleteFilling=False;
   1413a:	10 92 ab 01 	sts	0x01AB, r1
				stLocalAccount=laWaitFilling;
   1413e:	8d e1       	ldi	r24, 0x1D	; 29
   14140:	2e c8       	rjmp	.-4004   	; 0x1319e <FMenuLocalAccount+0x110>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   14142:	80 91 ab 01 	lds	r24, 0x01AB
   14146:	81 30       	cpi	r24, 0x01	; 1
   14148:	29 f0       	breq	.+10     	; 0x14154 <FMenuLocalAccount+0x10c6>
   1414a:	80 91 bc 01 	lds	r24, 0x01BC
   1414e:	8b 30       	cpi	r24, 0x0B	; 11
   14150:	08 f4       	brcc	.+2      	; 0x14154 <FMenuLocalAccount+0x10c6>
   14152:	49 c0       	rjmp	.+146    	; 0x141e6 <FMenuLocalAccount+0x1158>
				    IsCompleteFilling=False;
   14154:	10 92 ab 01 	sts	0x01AB, r1
				    stLocalAccount=laSuccessTransaction;
   14158:	89 e1       	ldi	r24, 0x19	; 25
   1415a:	80 93 4c 01 	sts	0x014C, r24
					TimLocAcc=0;
   1415e:	10 92 bc 01 	sts	0x01BC, r1
   14162:	41 c0       	rjmp	.+130    	; 0x141e6 <FMenuLocalAccount+0x1158>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   14164:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   14168:	82 e0       	ldi	r24, 0x02	; 2
   1416a:	61 e0       	ldi	r22, 0x01	; 1
   1416c:	4f e5       	ldi	r20, 0x5F	; 95
   1416e:	5e e1       	ldi	r21, 0x1E	; 30
   14170:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   14174:	00 d0       	rcall	.+0      	; 0x14176 <FMenuLocalAccount+0x10e8>
   14176:	00 d0       	rcall	.+0      	; 0x14178 <FMenuLocalAccount+0x10ea>
   14178:	00 d0       	rcall	.+0      	; 0x1417a <FMenuLocalAccount+0x10ec>
   1417a:	ed b7       	in	r30, 0x3d	; 61
   1417c:	fe b7       	in	r31, 0x3e	; 62
   1417e:	31 96       	adiw	r30, 0x01	; 1
   14180:	8e 01       	movw	r16, r28
   14182:	04 5f       	subi	r16, 0xF4	; 244
   14184:	1f 4f       	sbci	r17, 0xFF	; 255
   14186:	ad b7       	in	r26, 0x3d	; 61
   14188:	be b7       	in	r27, 0x3e	; 62
   1418a:	12 96       	adiw	r26, 0x02	; 2
   1418c:	1c 93       	st	X, r17
   1418e:	0e 93       	st	-X, r16
   14190:	11 97       	sbiw	r26, 0x01	; 1
   14192:	8e e4       	ldi	r24, 0x4E	; 78
   14194:	9e e1       	ldi	r25, 0x1E	; 30
   14196:	93 83       	std	Z+3, r25	; 0x03
   14198:	82 83       	std	Z+2, r24	; 0x02
   1419a:	80 91 91 02 	lds	r24, 0x0291
   1419e:	84 83       	std	Z+4, r24	; 0x04
   141a0:	15 82       	std	Z+5, r1	; 0x05
   141a2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
				lcd_print(3,1,lcdteks);
   141a6:	ed b7       	in	r30, 0x3d	; 61
   141a8:	fe b7       	in	r31, 0x3e	; 62
   141aa:	36 96       	adiw	r30, 0x06	; 6
   141ac:	0f b6       	in	r0, 0x3f	; 63
   141ae:	f8 94       	cli
   141b0:	fe bf       	out	0x3e, r31	; 62
   141b2:	0f be       	out	0x3f, r0	; 63
   141b4:	ed bf       	out	0x3d, r30	; 61
   141b6:	83 e0       	ldi	r24, 0x03	; 3
   141b8:	61 e0       	ldi	r22, 0x01	; 1
   141ba:	a8 01       	movw	r20, r16
   141bc:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   141c0:	10 92 bc 01 	sts	0x01BC, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   141c4:	8e e1       	ldi	r24, 0x1E	; 30
   141c6:	0c 94 cf 98 	jmp	0x1319e	; 0x1319e <FMenuLocalAccount+0x110>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   141ca:	80 91 bc 01 	lds	r24, 0x01BC
   141ce:	80 31       	cpi	r24, 0x10	; 16
   141d0:	50 f0       	brcs	.+20     	; 0x141e6 <FMenuLocalAccount+0x1158>
   141d2:	8f e1       	ldi	r24, 0x1F	; 31
   141d4:	0c 94 cf 98 	jmp	0x1319e	; 0x1319e <FMenuLocalAccount+0x110>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   141d8:	81 e0       	ldi	r24, 0x01	; 1
   141da:	80 93 4c 01 	sts	0x014C, r24
				lcd_clear();
   141de:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
   141e2:	81 e0       	ldi	r24, 0x01	; 1
   141e4:	01 c0       	rjmp	.+2      	; 0x141e8 <FMenuLocalAccount+0x115a>
   141e6:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   141e8:	e4 96       	adiw	r28, 0x34	; 52
   141ea:	0f b6       	in	r0, 0x3f	; 63
   141ec:	f8 94       	cli
   141ee:	de bf       	out	0x3e, r29	; 62
   141f0:	0f be       	out	0x3f, r0	; 63
   141f2:	cd bf       	out	0x3d, r28	; 61
   141f4:	cf 91       	pop	r28
   141f6:	df 91       	pop	r29
   141f8:	1f 91       	pop	r17
   141fa:	0f 91       	pop	r16
   141fc:	ff 90       	pop	r15
   141fe:	ef 90       	pop	r14
   14200:	df 90       	pop	r13
   14202:	cf 90       	pop	r12
   14204:	bf 90       	pop	r11
   14206:	af 90       	pop	r10
   14208:	9f 90       	pop	r9
   1420a:	8f 90       	pop	r8
   1420c:	7f 90       	pop	r7
   1420e:	6f 90       	pop	r6
   14210:	08 95       	ret

00014212 <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
   14212:	28 2f       	mov	r18, r24
   14214:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
   14216:	81 50       	subi	r24, 0x01	; 1
   14218:	82 30       	cpi	r24, 0x02	; 2
   1421a:	b8 f4       	brcc	.+46     	; 0x1424a <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   1421c:	62 30       	cpi	r22, 0x02	; 2
   1421e:	59 f0       	breq	.+22     	; 0x14236 <SetBaudRate+0x24>
   14220:	62 30       	cpi	r22, 0x02	; 2
   14222:	18 f0       	brcs	.+6      	; 0x1422a <SetBaudRate+0x18>
   14224:	63 30       	cpi	r22, 0x03	; 3
   14226:	21 f4       	brne	.+8      	; 0x14230 <SetBaudRate+0x1e>
   14228:	09 c0       	rjmp	.+18     	; 0x1423c <SetBaudRate+0x2a>
   1422a:	40 e8       	ldi	r20, 0x80	; 128
   1422c:	55 e2       	ldi	r21, 0x25	; 37
   1422e:	08 c0       	rjmp	.+16     	; 0x14240 <SetBaudRate+0x2e>
   14230:	40 e0       	ldi	r20, 0x00	; 0
   14232:	50 e0       	ldi	r21, 0x00	; 0
   14234:	05 c0       	rjmp	.+10     	; 0x14240 <SetBaudRate+0x2e>
   14236:	40 e0       	ldi	r20, 0x00	; 0
   14238:	5b e4       	ldi	r21, 0x4B	; 75
   1423a:	02 c0       	rjmp	.+4      	; 0x14240 <SetBaudRate+0x2e>
   1423c:	4b e9       	ldi	r20, 0x9B	; 155
   1423e:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      uart_init((ComAddr-1),brValue);
   14240:	60 e0       	ldi	r22, 0x00	; 0
   14242:	70 e0       	ldi	r23, 0x00	; 0
   14244:	0e 94 a5 ab 	call	0x1574a	; 0x1574a <uart_init>
   14248:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
   1424a:	82 2f       	mov	r24, r18
   1424c:	83 50       	subi	r24, 0x03	; 3
   1424e:	82 30       	cpi	r24, 0x02	; 2
   14250:	a8 f4       	brcc	.+42     	; 0x1427c <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
   14252:	9f 70       	andi	r25, 0x0F	; 15
   14254:	62 2f       	mov	r22, r18
   14256:	62 95       	swap	r22
   14258:	60 7f       	andi	r22, 0xF0	; 240
   1425a:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
   1425c:	80 91 82 01 	lds	r24, 0x0182
   14260:	88 23       	and	r24, r24
   14262:	49 f0       	breq	.+18     	; 0x14276 <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   14264:	86 e0       	ldi	r24, 0x06	; 6
   14266:	80 93 b0 05 	sts	0x05B0, r24
	 PoolMsg=plMsg;
   1426a:	60 93 e0 0d 	sts	0x0DE0, r22
     IsControlPooling=True;
   1426e:	81 e0       	ldi	r24, 0x01	; 1
   14270:	80 93 86 01 	sts	0x0186, r24
   14274:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
   14276:	86 e0       	ldi	r24, 0x06	; 6
   14278:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
   1427c:	08 95       	ret

0001427e <FSettingSystem>:
	      break;
	 }
     return Result;
}

char FSettingSystem(){
   1427e:	af 92       	push	r10
   14280:	bf 92       	push	r11
   14282:	cf 92       	push	r12
   14284:	df 92       	push	r13
   14286:	ef 92       	push	r14
   14288:	ff 92       	push	r15
   1428a:	0f 93       	push	r16
   1428c:	1f 93       	push	r17
   1428e:	df 93       	push	r29
   14290:	cf 93       	push	r28
   14292:	cd b7       	in	r28, 0x3d	; 61
   14294:	de b7       	in	r29, 0x3e	; 62
   14296:	64 97       	sbiw	r28, 0x14	; 20
   14298:	0f b6       	in	r0, 0x3f	; 63
   1429a:	f8 94       	cli
   1429c:	de bf       	out	0x3e, r29	; 62
   1429e:	0f be       	out	0x3f, r0	; 63
   142a0:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
   142a2:	80 91 25 02 	lds	r24, 0x0225
   142a6:	82 30       	cpi	r24, 0x02	; 2
   142a8:	09 f4       	brne	.+2      	; 0x142ac <FSettingSystem+0x2e>
   142aa:	cf c0       	rjmp	.+414    	; 0x1444a <FSettingSystem+0x1cc>
   142ac:	83 30       	cpi	r24, 0x03	; 3
   142ae:	30 f4       	brcc	.+12     	; 0x142bc <FSettingSystem+0x3e>
   142b0:	88 23       	and	r24, r24
   142b2:	71 f0       	breq	.+28     	; 0x142d0 <FSettingSystem+0x52>
   142b4:	81 30       	cpi	r24, 0x01	; 1
   142b6:	09 f0       	breq	.+2      	; 0x142ba <FSettingSystem+0x3c>
   142b8:	6f c1       	rjmp	.+734    	; 0x14598 <FSettingSystem+0x31a>
   142ba:	7f c0       	rjmp	.+254    	; 0x143ba <FSettingSystem+0x13c>
   142bc:	84 30       	cpi	r24, 0x04	; 4
   142be:	09 f4       	brne	.+2      	; 0x142c2 <FSettingSystem+0x44>
   142c0:	60 c1       	rjmp	.+704    	; 0x14582 <FSettingSystem+0x304>
   142c2:	84 30       	cpi	r24, 0x04	; 4
   142c4:	08 f4       	brcc	.+2      	; 0x142c8 <FSettingSystem+0x4a>
   142c6:	2b c1       	rjmp	.+598    	; 0x1451e <FSettingSystem+0x2a0>
   142c8:	85 30       	cpi	r24, 0x05	; 5
   142ca:	09 f0       	breq	.+2      	; 0x142ce <FSettingSystem+0x50>
   142cc:	65 c1       	rjmp	.+714    	; 0x14598 <FSettingSystem+0x31a>
   142ce:	60 c1       	rjmp	.+704    	; 0x14590 <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   142d0:	e1 99       	sbic	0x1c, 1	; 28
   142d2:	fe cf       	rjmp	.-4      	; 0x142d0 <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   142d4:	86 e3       	ldi	r24, 0x36	; 54
   142d6:	91 e0       	ldi	r25, 0x01	; 1
   142d8:	9f bb       	out	0x1f, r25	; 31
   142da:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   142dc:	e0 9a       	sbi	0x1c, 0	; 28
   142de:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
   142e0:	20 93 00 01 	sts	0x0100, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   142e4:	e1 99       	sbic	0x1c, 1	; 28
   142e6:	fe cf       	rjmp	.-4      	; 0x142e4 <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   142e8:	82 ec       	ldi	r24, 0xC2	; 194
   142ea:	93 e0       	ldi	r25, 0x03	; 3
   142ec:	9f bb       	out	0x1f, r25	; 31
   142ee:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   142f0:	e0 9a       	sbi	0x1c, 0	; 28
   142f2:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
   142f4:	22 23       	and	r18, r18
   142f6:	69 f4       	brne	.+26     	; 0x14312 <FSettingSystem+0x94>
   142f8:	00 d0       	rcall	.+0      	; 0x142fa <FSettingSystem+0x7c>
   142fa:	00 d0       	rcall	.+0      	; 0x142fc <FSettingSystem+0x7e>
   142fc:	ce 01       	movw	r24, r28
   142fe:	01 96       	adiw	r24, 0x01	; 1
   14300:	ad b7       	in	r26, 0x3d	; 61
   14302:	be b7       	in	r27, 0x3e	; 62
   14304:	12 96       	adiw	r26, 0x02	; 2
   14306:	9c 93       	st	X, r25
   14308:	8e 93       	st	-X, r24
   1430a:	11 97       	sbiw	r26, 0x01	; 1
   1430c:	86 e2       	ldi	r24, 0x26	; 38
   1430e:	9f e0       	ldi	r25, 0x0F	; 15
   14310:	1d c0       	rjmp	.+58     	; 0x1434c <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
   14312:	21 30       	cpi	r18, 0x01	; 1
   14314:	69 f4       	brne	.+26     	; 0x14330 <FSettingSystem+0xb2>
   14316:	00 d0       	rcall	.+0      	; 0x14318 <FSettingSystem+0x9a>
   14318:	00 d0       	rcall	.+0      	; 0x1431a <FSettingSystem+0x9c>
   1431a:	ce 01       	movw	r24, r28
   1431c:	01 96       	adiw	r24, 0x01	; 1
   1431e:	ed b7       	in	r30, 0x3d	; 61
   14320:	fe b7       	in	r31, 0x3e	; 62
   14322:	92 83       	std	Z+2, r25	; 0x02
   14324:	81 83       	std	Z+1, r24	; 0x01
   14326:	89 e1       	ldi	r24, 0x19	; 25
   14328:	9f e0       	ldi	r25, 0x0F	; 15
   1432a:	94 83       	std	Z+4, r25	; 0x04
   1432c:	83 83       	std	Z+3, r24	; 0x03
   1432e:	12 c0       	rjmp	.+36     	; 0x14354 <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
   14330:	22 30       	cpi	r18, 0x02	; 2
   14332:	b1 f4       	brne	.+44     	; 0x14360 <FSettingSystem+0xe2>
   14334:	00 d0       	rcall	.+0      	; 0x14336 <FSettingSystem+0xb8>
   14336:	00 d0       	rcall	.+0      	; 0x14338 <FSettingSystem+0xba>
   14338:	ce 01       	movw	r24, r28
   1433a:	01 96       	adiw	r24, 0x01	; 1
   1433c:	ad b7       	in	r26, 0x3d	; 61
   1433e:	be b7       	in	r27, 0x3e	; 62
   14340:	12 96       	adiw	r26, 0x02	; 2
   14342:	9c 93       	st	X, r25
   14344:	8e 93       	st	-X, r24
   14346:	11 97       	sbiw	r26, 0x01	; 1
   14348:	87 e0       	ldi	r24, 0x07	; 7
   1434a:	9f e0       	ldi	r25, 0x0F	; 15
   1434c:	14 96       	adiw	r26, 0x04	; 4
   1434e:	9c 93       	st	X, r25
   14350:	8e 93       	st	-X, r24
   14352:	13 97       	sbiw	r26, 0x03	; 3
   14354:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
   14358:	0f 90       	pop	r0
   1435a:	0f 90       	pop	r0
   1435c:	0f 90       	pop	r0
   1435e:	0f 90       	pop	r0

	      lcd_clear();
   14360:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_print(1,1,lcdteks);
   14364:	81 e0       	ldi	r24, 0x01	; 1
   14366:	61 e0       	ldi	r22, 0x01	; 1
   14368:	ae 01       	movw	r20, r28
   1436a:	4f 5f       	subi	r20, 0xFF	; 255
   1436c:	5f 4f       	sbci	r21, 0xFF	; 255
   1436e:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
   14372:	82 e0       	ldi	r24, 0x02	; 2
   14374:	61 e0       	ldi	r22, 0x01	; 1
   14376:	4c ef       	ldi	r20, 0xFC	; 252
   14378:	5e e0       	ldi	r21, 0x0E	; 14
   1437a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
   1437e:	11 23       	and	r17, r17
   14380:	29 f4       	brne	.+10     	; 0x1438c <FSettingSystem+0x10e>
   14382:	83 e0       	ldi	r24, 0x03	; 3
   14384:	61 e0       	ldi	r22, 0x01	; 1
   14386:	41 ef       	ldi	r20, 0xF1	; 241
   14388:	5e e0       	ldi	r21, 0x0E	; 14
   1438a:	0d c0       	rjmp	.+26     	; 0x143a6 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
   1438c:	11 30       	cpi	r17, 0x01	; 1
   1438e:	29 f4       	brne	.+10     	; 0x1439a <FSettingSystem+0x11c>
   14390:	83 e0       	ldi	r24, 0x03	; 3
   14392:	61 e0       	ldi	r22, 0x01	; 1
   14394:	46 ee       	ldi	r20, 0xE6	; 230
   14396:	5e e0       	ldi	r21, 0x0E	; 14
   14398:	06 c0       	rjmp	.+12     	; 0x143a6 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
   1439a:	12 30       	cpi	r17, 0x02	; 2
   1439c:	31 f4       	brne	.+12     	; 0x143aa <FSettingSystem+0x12c>
   1439e:	83 e0       	ldi	r24, 0x03	; 3
   143a0:	61 e0       	ldi	r22, 0x01	; 1
   143a2:	4b ed       	ldi	r20, 0xDB	; 219
   143a4:	5e e0       	ldi	r21, 0x0E	; 14
   143a6:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
   143aa:	84 e0       	ldi	r24, 0x04	; 4
   143ac:	61 e0       	ldi	r22, 0x01	; 1
   143ae:	4d ec       	ldi	r20, 0xCD	; 205
   143b0:	5e e0       	ldi	r21, 0x0E	; 14
   143b2:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stSettingSytem=ssMenuSelect;
   143b6:	81 e0       	ldi	r24, 0x01	; 1
   143b8:	e1 c0       	rjmp	.+450    	; 0x1457c <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
   143ba:	81 e0       	ldi	r24, 0x01	; 1
   143bc:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   143c0:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  if (KeyChar=='1'){
   143c4:	81 33       	cpi	r24, 0x31	; 49
   143c6:	c1 f4       	brne	.+48     	; 0x143f8 <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
   143c8:	80 91 00 01 	lds	r24, 0x0100
   143cc:	90 e0       	ldi	r25, 0x00	; 0
   143ce:	01 96       	adiw	r24, 0x01	; 1
   143d0:	63 e0       	ldi	r22, 0x03	; 3
   143d2:	70 e0       	ldi	r23, 0x00	; 0
   143d4:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   143d8:	80 93 00 01 	sts	0x0100, r24
			  SendSlaveCommand(IFType,DispenserBrand);
   143dc:	60 91 50 01 	lds	r22, 0x0150
   143e0:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
   143e4:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   143e8:	e1 99       	sbic	0x1c, 1	; 28
   143ea:	fe cf       	rjmp	.-4      	; 0x143e8 <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   143ec:	86 e3       	ldi	r24, 0x36	; 54
   143ee:	91 e0       	ldi	r25, 0x01	; 1
   143f0:	9f bb       	out	0x1f, r25	; 31
   143f2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   143f4:	2d bb       	out	0x1d, r18	; 29
   143f6:	1f c0       	rjmp	.+62     	; 0x14436 <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
   143f8:	82 33       	cpi	r24, 0x32	; 50
   143fa:	09 f4       	brne	.+2      	; 0x143fe <FSettingSystem+0x180>
   143fc:	ba c0       	rjmp	.+372    	; 0x14572 <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
   143fe:	83 33       	cpi	r24, 0x33	; 51
   14400:	01 f5       	brne	.+64     	; 0x14442 <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14402:	e1 99       	sbic	0x1c, 1	; 28
   14404:	fe cf       	rjmp	.-4      	; 0x14402 <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14406:	f2 ec       	ldi	r31, 0xC2	; 194
   14408:	ef 2e       	mov	r14, r31
   1440a:	f3 e0       	ldi	r31, 0x03	; 3
   1440c:	ff 2e       	mov	r15, r31
   1440e:	ff ba       	out	0x1f, r15	; 31
   14410:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14412:	e0 9a       	sbi	0x1c, 0	; 28
   14414:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
   14416:	90 e0       	ldi	r25, 0x00	; 0
   14418:	01 96       	adiw	r24, 0x01	; 1
   1441a:	63 e0       	ldi	r22, 0x03	; 3
   1441c:	70 e0       	ldi	r23, 0x00	; 0
   1441e:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   14422:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
   14424:	81 e2       	ldi	r24, 0x21	; 33
   14426:	61 2f       	mov	r22, r17
   14428:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1442c:	e1 99       	sbic	0x1c, 1	; 28
   1442e:	fe cf       	rjmp	.-4      	; 0x1442c <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14430:	ff ba       	out	0x1f, r15	; 31
   14432:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   14434:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
   14436:	0f b6       	in	r0, 0x3f	; 63
   14438:	f8 94       	cli
   1443a:	e2 9a       	sbi	0x1c, 2	; 28
   1443c:	e1 9a       	sbi	0x1c, 1	; 28
   1443e:	0f be       	out	0x3f, r0	; 63
   14440:	a4 c0       	rjmp	.+328    	; 0x1458a <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
   14442:	8a 32       	cpi	r24, 0x2A	; 42
   14444:	09 f4       	brne	.+2      	; 0x14448 <FSettingSystem+0x1ca>
   14446:	99 c0       	rjmp	.+306    	; 0x1457a <FSettingSystem+0x2fc>
   14448:	a7 c0       	rjmp	.+334    	; 0x14598 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
   1444a:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   1444e:	81 e0       	ldi	r24, 0x01	; 1
   14450:	61 e0       	ldi	r22, 0x01	; 1
   14452:	48 eb       	ldi	r20, 0xB8	; 184
   14454:	5e e0       	ldi	r21, 0x0E	; 14
   14456:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   1445a:	01 e0       	ldi	r16, 0x01	; 1
   1445c:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   1445e:	6e 01       	movw	r12, r28
   14460:	08 94       	sec
   14462:	c1 1c       	adc	r12, r1
   14464:	d1 1c       	adc	r13, r1
   14466:	ef ea       	ldi	r30, 0xAF	; 175
   14468:	ae 2e       	mov	r10, r30
   1446a:	ee e0       	ldi	r30, 0x0E	; 14
   1446c:	be 2e       	mov	r11, r30
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   1446e:	7b e0       	ldi	r23, 0x0B	; 11
   14470:	e7 2e       	mov	r14, r23
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   14472:	f0 2e       	mov	r15, r16
   14474:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14476:	e1 99       	sbic	0x1c, 1	; 28
   14478:	fe cf       	rjmp	.-4      	; 0x14476 <FSettingSystem+0x1f8>
   1447a:	c8 01       	movw	r24, r16
   1447c:	81 5c       	subi	r24, 0xC1	; 193
   1447e:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14480:	9f bb       	out	0x1f, r25	; 31
   14482:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14484:	e0 9a       	sbi	0x1c, 0	; 28
   14486:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   14488:	82 30       	cpi	r24, 0x02	; 2
   1448a:	69 f0       	breq	.+26     	; 0x144a6 <FSettingSystem+0x228>
   1448c:	82 30       	cpi	r24, 0x02	; 2
   1448e:	28 f0       	brcs	.+10     	; 0x1449a <FSettingSystem+0x21c>
   14490:	83 30       	cpi	r24, 0x03	; 3
   14492:	31 f4       	brne	.+12     	; 0x144a0 <FSettingSystem+0x222>
   14494:	85 eb       	ldi	r24, 0xB5	; 181
   14496:	9f e2       	ldi	r25, 0x2F	; 47
   14498:	08 c0       	rjmp	.+16     	; 0x144aa <FSettingSystem+0x22c>
   1449a:	80 e8       	ldi	r24, 0x80	; 128
   1449c:	95 e2       	ldi	r25, 0x25	; 37
   1449e:	05 c0       	rjmp	.+10     	; 0x144aa <FSettingSystem+0x22c>
   144a0:	80 e0       	ldi	r24, 0x00	; 0
   144a2:	90 e0       	ldi	r25, 0x00	; 0
   144a4:	02 c0       	rjmp	.+4      	; 0x144aa <FSettingSystem+0x22c>
   144a6:	80 e0       	ldi	r24, 0x00	; 0
   144a8:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   144aa:	ed b7       	in	r30, 0x3d	; 61
   144ac:	fe b7       	in	r31, 0x3e	; 62
   144ae:	38 97       	sbiw	r30, 0x08	; 8
   144b0:	0f b6       	in	r0, 0x3f	; 63
   144b2:	f8 94       	cli
   144b4:	fe bf       	out	0x3e, r31	; 62
   144b6:	0f be       	out	0x3f, r0	; 63
   144b8:	ed bf       	out	0x3d, r30	; 61
   144ba:	31 96       	adiw	r30, 0x01	; 1
   144bc:	ad b7       	in	r26, 0x3d	; 61
   144be:	be b7       	in	r27, 0x3e	; 62
   144c0:	12 96       	adiw	r26, 0x02	; 2
   144c2:	dc 92       	st	X, r13
   144c4:	ce 92       	st	-X, r12
   144c6:	11 97       	sbiw	r26, 0x01	; 1
   144c8:	b3 82       	std	Z+3, r11	; 0x03
   144ca:	a2 82       	std	Z+2, r10	; 0x02
   144cc:	15 83       	std	Z+5, r17	; 0x05
   144ce:	04 83       	std	Z+4, r16	; 0x04
   144d0:	97 83       	std	Z+7, r25	; 0x07
   144d2:	86 83       	std	Z+6, r24	; 0x06
   144d4:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   144d8:	ed b7       	in	r30, 0x3d	; 61
   144da:	fe b7       	in	r31, 0x3e	; 62
   144dc:	38 96       	adiw	r30, 0x08	; 8
   144de:	0f b6       	in	r0, 0x3f	; 63
   144e0:	f8 94       	cli
   144e2:	fe bf       	out	0x3e, r31	; 62
   144e4:	0f be       	out	0x3f, r0	; 63
   144e6:	ed bf       	out	0x3d, r30	; 61
   144e8:	6f 2d       	mov	r22, r15
   144ea:	66 95       	lsr	r22
   144ec:	6e 9d       	mul	r22, r14
   144ee:	b0 01       	movw	r22, r0
   144f0:	11 24       	eor	r1, r1
   144f2:	6f 5f       	subi	r22, 0xFF	; 255
   144f4:	f1 e0       	ldi	r31, 0x01	; 1
   144f6:	ff 22       	and	r15, r31
   144f8:	8f 2d       	mov	r24, r15
   144fa:	8e 5f       	subi	r24, 0xFE	; 254
   144fc:	a6 01       	movw	r20, r12
   144fe:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
   14502:	0f 5f       	subi	r16, 0xFF	; 255
   14504:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
   14506:	05 30       	cpi	r16, 0x05	; 5
   14508:	11 05       	cpc	r17, r1
   1450a:	09 f0       	breq	.+2      	; 0x1450e <FSettingSystem+0x290>
   1450c:	b2 cf       	rjmp	.-156    	; 0x14472 <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
   1450e:	84 e0       	ldi	r24, 0x04	; 4
   14510:	61 e0       	ldi	r22, 0x01	; 1
   14512:	42 ea       	ldi	r20, 0xA2	; 162
   14514:	5e e0       	ldi	r21, 0x0E	; 14
   14516:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
   1451a:	83 e0       	ldi	r24, 0x03	; 3
   1451c:	2f c0       	rjmp	.+94     	; 0x1457c <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
   1451e:	81 e0       	ldi	r24, 0x01	; 1
   14520:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   14524:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
   14528:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1452a:	81 53       	subi	r24, 0x31	; 49
   1452c:	84 30       	cpi	r24, 0x04	; 4
   1452e:	18 f5       	brcc	.+70     	; 0x14576 <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14530:	e1 99       	sbic	0x1c, 1	; 28
   14532:	fe cf       	rjmp	.-4      	; 0x14530 <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14534:	02 2f       	mov	r16, r18
   14536:	10 e0       	ldi	r17, 0x00	; 0
   14538:	01 5f       	subi	r16, 0xF1	; 241
   1453a:	1e 4f       	sbci	r17, 0xFE	; 254
   1453c:	1f bb       	out	0x1f, r17	; 31
   1453e:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14540:	e0 9a       	sbi	0x1c, 0	; 28
   14542:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
   14544:	90 e0       	ldi	r25, 0x00	; 0
   14546:	01 96       	adiw	r24, 0x01	; 1
   14548:	63 e0       	ldi	r22, 0x03	; 3
   1454a:	70 e0       	ldi	r23, 0x00	; 0
   1454c:	0e 94 29 b4 	call	0x16852	; 0x16852 <__divmodhi4>
   14550:	f8 2e       	mov	r15, r24
   14552:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
   14554:	82 2f       	mov	r24, r18
   14556:	80 53       	subi	r24, 0x30	; 48
   14558:	6f 2d       	mov	r22, r15
   1455a:	0e 94 09 a1 	call	0x14212	; 0x14212 <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1455e:	e1 99       	sbic	0x1c, 1	; 28
   14560:	fe cf       	rjmp	.-4      	; 0x1455e <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14562:	1f bb       	out	0x1f, r17	; 31
   14564:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   14566:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
   14568:	0f b6       	in	r0, 0x3f	; 63
   1456a:	f8 94       	cli
   1456c:	e2 9a       	sbi	0x1c, 2	; 28
   1456e:	e1 9a       	sbi	0x1c, 1	; 28
   14570:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
   14572:	82 e0       	ldi	r24, 0x02	; 2
   14574:	03 c0       	rjmp	.+6      	; 0x1457c <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
   14576:	2a 32       	cpi	r18, 0x2A	; 42
   14578:	79 f4       	brne	.+30     	; 0x14598 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
   1457a:	85 e0       	ldi	r24, 0x05	; 5
   1457c:	80 93 25 02 	sts	0x0225, r24
   14580:	0b c0       	rjmp	.+22     	; 0x14598 <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
   14582:	0e 94 ae 74 	call	0xe95c	; 0xe95c <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
   14586:	81 30       	cpi	r24, 0x01	; 1
   14588:	39 f4       	brne	.+14     	; 0x14598 <FSettingSystem+0x31a>
   1458a:	10 92 25 02 	sts	0x0225, r1
   1458e:	04 c0       	rjmp	.+8      	; 0x14598 <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
   14590:	10 92 25 02 	sts	0x0225, r1
   14594:	81 e0       	ldi	r24, 0x01	; 1
   14596:	01 c0       	rjmp	.+2      	; 0x1459a <FSettingSystem+0x31c>
   14598:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   1459a:	64 96       	adiw	r28, 0x14	; 20
   1459c:	0f b6       	in	r0, 0x3f	; 63
   1459e:	f8 94       	cli
   145a0:	de bf       	out	0x3e, r29	; 62
   145a2:	0f be       	out	0x3f, r0	; 63
   145a4:	cd bf       	out	0x3d, r28	; 61
   145a6:	cf 91       	pop	r28
   145a8:	df 91       	pop	r29
   145aa:	1f 91       	pop	r17
   145ac:	0f 91       	pop	r16
   145ae:	ff 90       	pop	r15
   145b0:	ef 90       	pop	r14
   145b2:	df 90       	pop	r13
   145b4:	cf 90       	pop	r12
   145b6:	bf 90       	pop	r11
   145b8:	af 90       	pop	r10
   145ba:	08 95       	ret

000145bc <FMenuSettings>:
char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1;
     char KeyPressed,KeyChar,SubMenu;

     switch(stMenuSettings){
   145bc:	80 91 2b 02 	lds	r24, 0x022B
   145c0:	e8 2f       	mov	r30, r24
   145c2:	f0 e0       	ldi	r31, 0x00	; 0
   145c4:	e3 31       	cpi	r30, 0x13	; 19
   145c6:	f1 05       	cpc	r31, r1
   145c8:	08 f0       	brcs	.+2      	; 0x145cc <FMenuSettings+0x10>
   145ca:	bf c0       	rjmp	.+382    	; 0x1474a <FMenuSettings+0x18e>
   145cc:	e6 5f       	subi	r30, 0xF6	; 246
   145ce:	fe 4f       	sbci	r31, 0xFE	; 254
   145d0:	ee 0f       	add	r30, r30
   145d2:	ff 1f       	adc	r31, r31
   145d4:	05 90       	lpm	r0, Z+
   145d6:	f4 91       	lpm	r31, Z+
   145d8:	e0 2d       	mov	r30, r0
   145da:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
   145dc:	0e 94 a6 a7 	call	0x14f4c	; 0x14f4c <lcd_clear>
		  PageSetting=1;
   145e0:	81 e0       	ldi	r24, 0x01	; 1
   145e2:	80 93 48 01 	sts	0x0148, r24
   145e6:	a9 c0       	rjmp	.+338    	; 0x1473a <FMenuSettings+0x17e>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
   145e8:	80 91 48 01 	lds	r24, 0x0148
   145ec:	8f 5f       	subi	r24, 0xFF	; 255
   145ee:	a5 c0       	rjmp	.+330    	; 0x1473a <FMenuSettings+0x17e>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
   145f0:	81 e0       	ldi	r24, 0x01	; 1
   145f2:	61 e0       	ldi	r22, 0x01	; 1
   145f4:	45 ea       	ldi	r20, 0xA5	; 165
   145f6:	53 e1       	ldi	r21, 0x13	; 19
   145f8:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
   145fc:	82 e0       	ldi	r24, 0x02	; 2
   145fe:	61 e0       	ldi	r22, 0x01	; 1
   14600:	40 e9       	ldi	r20, 0x90	; 144
   14602:	53 e1       	ldi	r21, 0x13	; 19
   14604:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
   14608:	83 e0       	ldi	r24, 0x03	; 3
   1460a:	61 e0       	ldi	r22, 0x01	; 1
   1460c:	4b e7       	ldi	r20, 0x7B	; 123
   1460e:	53 e1       	ldi	r21, 0x13	; 19
   14610:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
   14614:	84 e0       	ldi	r24, 0x04	; 4
   14616:	61 e0       	ldi	r22, 0x01	; 1
   14618:	46 e6       	ldi	r20, 0x66	; 102
   1461a:	53 e1       	ldi	r21, 0x13	; 19
   1461c:	16 c0       	rjmp	.+44     	; 0x1464a <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
   1461e:	81 e0       	ldi	r24, 0x01	; 1
   14620:	61 e0       	ldi	r22, 0x01	; 1
   14622:	41 e5       	ldi	r20, 0x51	; 81
   14624:	53 e1       	ldi	r21, 0x13	; 19
   14626:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
   1462a:	82 e0       	ldi	r24, 0x02	; 2
   1462c:	61 e0       	ldi	r22, 0x01	; 1
   1462e:	4c e3       	ldi	r20, 0x3C	; 60
   14630:	53 e1       	ldi	r21, 0x13	; 19
   14632:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
   14636:	83 e0       	ldi	r24, 0x03	; 3
   14638:	61 e0       	ldi	r22, 0x01	; 1
   1463a:	47 e2       	ldi	r20, 0x27	; 39
   1463c:	53 e1       	ldi	r21, 0x13	; 19
   1463e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
   14642:	84 e0       	ldi	r24, 0x04	; 4
   14644:	61 e0       	ldi	r22, 0x01	; 1
   14646:	42 e1       	ldi	r20, 0x12	; 18
   14648:	53 e1       	ldi	r21, 0x13	; 19
   1464a:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stMenuSettings=msSelection;
   1464e:	84 e0       	ldi	r24, 0x04	; 4
   14650:	74 c0       	rjmp	.+232    	; 0x1473a <FMenuSettings+0x17e>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
   14652:	80 91 48 01 	lds	r24, 0x0148
   14656:	8c 5f       	subi	r24, 0xFC	; 252
   14658:	70 c0       	rjmp	.+224    	; 0x1473a <FMenuSettings+0x17e>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
   1465a:	81 e0       	ldi	r24, 0x01	; 1
   1465c:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   14660:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  switch(KeyChar){
   14664:	84 33       	cpi	r24, 0x34	; 52
   14666:	d1 f0       	breq	.+52     	; 0x1469c <FMenuSettings+0xe0>
   14668:	85 33       	cpi	r24, 0x35	; 53
   1466a:	50 f4       	brcc	.+20     	; 0x14680 <FMenuSettings+0xc4>
   1466c:	82 33       	cpi	r24, 0x32	; 50
   1466e:	91 f0       	breq	.+36     	; 0x14694 <FMenuSettings+0xd8>
   14670:	83 33       	cpi	r24, 0x33	; 51
   14672:	90 f4       	brcc	.+36     	; 0x14698 <FMenuSettings+0xdc>
   14674:	8a 32       	cpi	r24, 0x2A	; 42
   14676:	d1 f0       	breq	.+52     	; 0x146ac <FMenuSettings+0xf0>
   14678:	81 33       	cpi	r24, 0x31	; 49
   1467a:	09 f0       	breq	.+2      	; 0x1467e <FMenuSettings+0xc2>
   1467c:	66 c0       	rjmp	.+204    	; 0x1474a <FMenuSettings+0x18e>
   1467e:	08 c0       	rjmp	.+16     	; 0x14690 <FMenuSettings+0xd4>
   14680:	86 33       	cpi	r24, 0x36	; 54
   14682:	81 f0       	breq	.+32     	; 0x146a4 <FMenuSettings+0xe8>
   14684:	86 33       	cpi	r24, 0x36	; 54
   14686:	60 f0       	brcs	.+24     	; 0x146a0 <FMenuSettings+0xe4>
   14688:	87 33       	cpi	r24, 0x37	; 55
   1468a:	09 f0       	breq	.+2      	; 0x1468e <FMenuSettings+0xd2>
   1468c:	5e c0       	rjmp	.+188    	; 0x1474a <FMenuSettings+0x18e>
   1468e:	0c c0       	rjmp	.+24     	; 0x146a8 <FMenuSettings+0xec>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
   14690:	89 e0       	ldi	r24, 0x09	; 9
   14692:	53 c0       	rjmp	.+166    	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
   14694:	8a e0       	ldi	r24, 0x0A	; 10
   14696:	51 c0       	rjmp	.+162    	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
   14698:	8b e0       	ldi	r24, 0x0B	; 11
   1469a:	4f c0       	rjmp	.+158    	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
   1469c:	8c e0       	ldi	r24, 0x0C	; 12
   1469e:	4d c0       	rjmp	.+154    	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
   146a0:	8d e0       	ldi	r24, 0x0D	; 13
   146a2:	4b c0       	rjmp	.+150    	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
   146a4:	8e e0       	ldi	r24, 0x0E	; 14
   146a6:	49 c0       	rjmp	.+146    	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
   146a8:	87 e0       	ldi	r24, 0x07	; 7
   146aa:	47 c0       	rjmp	.+142    	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
   146ac:	82 e1       	ldi	r24, 0x12	; 18
   146ae:	45 c0       	rjmp	.+138    	; 0x1473a <FMenuSettings+0x17e>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
   146b0:	81 e0       	ldi	r24, 0x01	; 1
   146b2:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   146b6:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>
		  switch(KeyChar){
   146ba:	82 33       	cpi	r24, 0x32	; 50
   146bc:	69 f0       	breq	.+26     	; 0x146d8 <FMenuSettings+0x11c>
   146be:	83 33       	cpi	r24, 0x33	; 51
   146c0:	30 f4       	brcc	.+12     	; 0x146ce <FMenuSettings+0x112>
   146c2:	8a 32       	cpi	r24, 0x2A	; 42
   146c4:	69 f0       	breq	.+26     	; 0x146e0 <FMenuSettings+0x124>
   146c6:	81 33       	cpi	r24, 0x31	; 49
   146c8:	09 f0       	breq	.+2      	; 0x146cc <FMenuSettings+0x110>
   146ca:	3f c0       	rjmp	.+126    	; 0x1474a <FMenuSettings+0x18e>
   146cc:	03 c0       	rjmp	.+6      	; 0x146d4 <FMenuSettings+0x118>
   146ce:	83 33       	cpi	r24, 0x33	; 51
   146d0:	e1 f5       	brne	.+120    	; 0x1474a <FMenuSettings+0x18e>
   146d2:	04 c0       	rjmp	.+8      	; 0x146dc <FMenuSettings+0x120>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
   146d4:	8f e0       	ldi	r24, 0x0F	; 15
   146d6:	31 c0       	rjmp	.+98     	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
   146d8:	80 e1       	ldi	r24, 0x10	; 16
   146da:	2f c0       	rjmp	.+94     	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
   146dc:	81 e1       	ldi	r24, 0x11	; 17
   146de:	2d c0       	rjmp	.+90     	; 0x1473a <FMenuSettings+0x17e>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
   146e0:	88 e0       	ldi	r24, 0x08	; 8
   146e2:	2b c0       	rjmp	.+86     	; 0x1473a <FMenuSettings+0x17e>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
   146e4:	80 91 48 01 	lds	r24, 0x0148
   146e8:	82 30       	cpi	r24, 0x02	; 2
   146ea:	d8 f4       	brcc	.+54     	; 0x14722 <FMenuSettings+0x166>
   146ec:	8f 5f       	subi	r24, 0xFF	; 255
   146ee:	05 c0       	rjmp	.+10     	; 0x146fa <FMenuSettings+0x13e>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
   146f0:	80 91 48 01 	lds	r24, 0x0148
   146f4:	82 30       	cpi	r24, 0x02	; 2
   146f6:	a8 f0       	brcs	.+42     	; 0x14722 <FMenuSettings+0x166>
   146f8:	81 50       	subi	r24, 0x01	; 1
   146fa:	80 93 48 01 	sts	0x0148, r24
   146fe:	11 c0       	rjmp	.+34     	; 0x14722 <FMenuSettings+0x166>
		  stMenuSettings=msDisplayPage;
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
   14700:	0e 94 be 89 	call	0x1137c	; 0x1137c <FSettingProduct>
   14704:	18 c0       	rjmp	.+48     	; 0x14736 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
   14706:	0e 94 a4 7c 	call	0xf948	; 0xf948 <FSettingPump>
   1470a:	15 c0       	rjmp	.+42     	; 0x14736 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
   1470c:	0e 94 26 66 	call	0xcc4c	; 0xcc4c <FSettingDec>
   14710:	12 c0       	rjmp	.+36     	; 0x14736 <FMenuSettings+0x17a>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
   14712:	0e 94 9e 68 	call	0xd13c	; 0xd13c <_menu_datetime>
   14716:	05 c0       	rjmp	.+10     	; 0x14722 <FMenuSettings+0x166>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
   14718:	0e 94 2b 62 	call	0xc456	; 0xc456 <_menu_printer>
   1471c:	02 c0       	rjmp	.+4      	; 0x14722 <FMenuSettings+0x166>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
   1471e:	0e 94 84 60 	call	0xc108	; 0xc108 <_menu_host>
	      SubMenu=FSettingPrinter();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   14722:	81 e0       	ldi	r24, 0x01	; 1
   14724:	0a c0       	rjmp	.+20     	; 0x1473a <FMenuSettings+0x17e>
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
   14726:	0e 94 d1 86 	call	0x10da2	; 0x10da2 <FSettingOperator>
   1472a:	05 c0       	rjmp	.+10     	; 0x14736 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
   1472c:	0e 94 3f a1 	call	0x1427e	; 0x1427e <FSettingSystem>
   14730:	02 c0       	rjmp	.+4      	; 0x14736 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
   14732:	0e 94 ae 74 	call	0xe95c	; 0xe95c <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   14736:	81 30       	cpi	r24, 0x01	; 1
   14738:	41 f4       	brne	.+16     	; 0x1474a <FMenuSettings+0x18e>
   1473a:	80 93 2b 02 	sts	0x022B, r24
   1473e:	80 e0       	ldi	r24, 0x00	; 0
   14740:	08 95       	ret
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
   14742:	10 92 2b 02 	sts	0x022B, r1
   14746:	81 e0       	ldi	r24, 0x01	; 1
   14748:	08 95       	ret
   1474a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   1474c:	08 95       	ret

0001474e <FMenuAuthorization>:


char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   1474e:	80 91 63 02 	lds	r24, 0x0263
   14752:	83 30       	cpi	r24, 0x03	; 3
   14754:	51 f1       	breq	.+84     	; 0x147aa <FMenuAuthorization+0x5c>
   14756:	84 30       	cpi	r24, 0x04	; 4
   14758:	28 f4       	brcc	.+10     	; 0x14764 <FMenuAuthorization+0x16>
   1475a:	81 30       	cpi	r24, 0x01	; 1
   1475c:	81 f0       	breq	.+32     	; 0x1477e <FMenuAuthorization+0x30>
   1475e:	82 30       	cpi	r24, 0x02	; 2
   14760:	38 f5       	brcc	.+78     	; 0x147b0 <FMenuAuthorization+0x62>
   14762:	0a c0       	rjmp	.+20     	; 0x14778 <FMenuAuthorization+0x2a>
   14764:	85 30       	cpi	r24, 0x05	; 5
   14766:	61 f1       	breq	.+88     	; 0x147c0 <FMenuAuthorization+0x72>
   14768:	85 30       	cpi	r24, 0x05	; 5
   1476a:	28 f1       	brcs	.+74     	; 0x147b6 <FMenuAuthorization+0x68>
   1476c:	86 30       	cpi	r24, 0x06	; 6
   1476e:	e1 f1       	breq	.+120    	; 0x147e8 <FMenuAuthorization+0x9a>
   14770:	87 30       	cpi	r24, 0x07	; 7
   14772:	09 f0       	breq	.+2      	; 0x14776 <FMenuAuthorization+0x28>
   14774:	4c c0       	rjmp	.+152    	; 0x1480e <FMenuAuthorization+0xc0>
   14776:	47 c0       	rjmp	.+142    	; 0x14806 <FMenuAuthorization+0xb8>
	 case maInit:
	      PassTry=0;
   14778:	10 92 62 02 	sts	0x0262, r1
   1477c:	3d c0       	rjmp	.+122    	; 0x147f8 <FMenuAuthorization+0xaa>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   1477e:	0e 94 ae 91 	call	0x1235c	; 0x1235c <FMenuPassword>
		  switch(PassResult){
   14782:	83 30       	cpi	r24, 0x03	; 3
   14784:	e1 f1       	breq	.+120    	; 0x147fe <FMenuAuthorization+0xb0>
   14786:	84 30       	cpi	r24, 0x04	; 4
   14788:	28 f4       	brcc	.+10     	; 0x14794 <FMenuAuthorization+0x46>
   1478a:	81 30       	cpi	r24, 0x01	; 1
   1478c:	b9 f1       	breq	.+110    	; 0x147fc <FMenuAuthorization+0xae>
   1478e:	82 30       	cpi	r24, 0x02	; 2
   14790:	f1 f5       	brne	.+124    	; 0x1480e <FMenuAuthorization+0xc0>
   14792:	09 c0       	rjmp	.+18     	; 0x147a6 <FMenuAuthorization+0x58>
   14794:	84 30       	cpi	r24, 0x04	; 4
   14796:	19 f0       	breq	.+6      	; 0x1479e <FMenuAuthorization+0x50>
   14798:	85 30       	cpi	r24, 0x05	; 5
   1479a:	c9 f5       	brne	.+114    	; 0x1480e <FMenuAuthorization+0xc0>
   1479c:	02 c0       	rjmp	.+4      	; 0x147a2 <FMenuAuthorization+0x54>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   1479e:	82 e0       	ldi	r24, 0x02	; 2
   147a0:	2e c0       	rjmp	.+92     	; 0x147fe <FMenuAuthorization+0xb0>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   147a2:	84 e0       	ldi	r24, 0x04	; 4
   147a4:	2c c0       	rjmp	.+88     	; 0x147fe <FMenuAuthorization+0xb0>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   147a6:	85 e0       	ldi	r24, 0x05	; 5
   147a8:	2a c0       	rjmp	.+84     	; 0x147fe <FMenuAuthorization+0xb0>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   147aa:	0e 94 9d 8f 	call	0x11f3a	; 0x11f3a <FMenuMaster>
   147ae:	05 c0       	rjmp	.+10     	; 0x147ba <FMenuAuthorization+0x6c>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   147b0:	0e 94 9a 93 	call	0x12734	; 0x12734 <FMenuAdmin>
   147b4:	02 c0       	rjmp	.+4      	; 0x147ba <FMenuAuthorization+0x6c>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   147b6:	0e 94 de a2 	call	0x145bc	; 0x145bc <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   147ba:	81 30       	cpi	r24, 0x01	; 1
   147bc:	41 f5       	brne	.+80     	; 0x1480e <FMenuAuthorization+0xc0>
   147be:	1e c0       	rjmp	.+60     	; 0x147fc <FMenuAuthorization+0xae>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   147c0:	80 91 62 02 	lds	r24, 0x0262
   147c4:	8f 5f       	subi	r24, 0xFF	; 255
   147c6:	80 93 62 02 	sts	0x0262, r24
	      TimDisplay=0;
   147ca:	10 92 94 01 	sts	0x0194, r1
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   147ce:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   147d0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   147d2:	81 e0       	ldi	r24, 0x01	; 1
   147d4:	80 93 be 01 	sts	0x01BE, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   147d8:	83 e0       	ldi	r24, 0x03	; 3
   147da:	61 e0       	ldi	r22, 0x01	; 1
   147dc:	44 e1       	ldi	r20, 0x14	; 20
   147de:	59 e1       	ldi	r21, 0x19	; 25
   147e0:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   147e4:	86 e0       	ldi	r24, 0x06	; 6
   147e6:	0b c0       	rjmp	.+22     	; 0x147fe <FMenuAuthorization+0xb0>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   147e8:	80 91 94 01 	lds	r24, 0x0194
   147ec:	83 30       	cpi	r24, 0x03	; 3
   147ee:	78 f0       	brcs	.+30     	; 0x1480e <FMenuAuthorization+0xc0>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   147f0:	80 91 62 02 	lds	r24, 0x0262
   147f4:	83 30       	cpi	r24, 0x03	; 3
   147f6:	10 f4       	brcc	.+4      	; 0x147fc <FMenuAuthorization+0xae>
   147f8:	81 e0       	ldi	r24, 0x01	; 1
   147fa:	01 c0       	rjmp	.+2      	; 0x147fe <FMenuAuthorization+0xb0>
			  else stMenuAuthorization=maExitAuthorization;
   147fc:	87 e0       	ldi	r24, 0x07	; 7
   147fe:	80 93 63 02 	sts	0x0263, r24
   14802:	80 e0       	ldi	r24, 0x00	; 0
   14804:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   14806:	10 92 63 02 	sts	0x0263, r1
   1480a:	81 e0       	ldi	r24, 0x01	; 1
   1480c:	08 95       	ret
   1480e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   14810:	08 95       	ret

00014812 <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   14812:	1f 93       	push	r17
	static char stMenuIdle=miInit,ButtonID=0;
	       char PrintStandaloneResult=PS_NONE;
	       char KeyPressed=0,KeyChar=0;
	       char lcdteks[20];

	switch(stMenuIdle){
   14814:	80 91 b5 02 	lds	r24, 0x02B5
   14818:	e8 2f       	mov	r30, r24
   1481a:	f0 e0       	ldi	r31, 0x00	; 0
   1481c:	e9 31       	cpi	r30, 0x19	; 25
   1481e:	f1 05       	cpc	r31, r1
   14820:	08 f0       	brcs	.+2      	; 0x14824 <FMenuIdle+0x12>
   14822:	7e c1       	rjmp	.+764    	; 0x14b20 <FMenuIdle+0x30e>
   14824:	e3 5e       	subi	r30, 0xE3	; 227
   14826:	fe 4f       	sbci	r31, 0xFE	; 254
   14828:	ee 0f       	add	r30, r30
   1482a:	ff 1f       	adc	r31, r31
   1482c:	05 90       	lpm	r0, Z+
   1482e:	f4 91       	lpm	r31, Z+
   14830:	e0 2d       	mov	r30, r0
   14832:	09 94       	ijmp
	case miInit:
         DisplayScreenIdle();
   14834:	0e 94 76 1c 	call	0x38ec	; 0x38ec <DisplayScreenIdle>
   14838:	3a c1       	rjmp	.+628    	; 0x14aae <FMenuIdle+0x29c>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   1483a:	81 e0       	ldi	r24, 0x01	; 1
   1483c:	0e 94 eb a8 	call	0x151d6	; 0x151d6 <_key_scan>
   14840:	18 2f       	mov	r17, r24
		 KeyChar= _key_btn(KeyPressed);       
   14842:	0e 94 4c a8 	call	0x15098	; 0x15098 <_key_btn>

		 switch(KeyPressed){
   14846:	1b 3b       	cpi	r17, 0xBB	; 187
   14848:	09 f4       	brne	.+2      	; 0x1484c <FMenuIdle+0x3a>
   1484a:	7a c0       	rjmp	.+244    	; 0x14940 <FMenuIdle+0x12e>
   1484c:	1c 3b       	cpi	r17, 0xBC	; 188
   1484e:	70 f4       	brcc	.+28     	; 0x1486c <FMenuIdle+0x5a>
   14850:	1b 37       	cpi	r17, 0x7B	; 123
   14852:	69 f1       	breq	.+90     	; 0x148ae <FMenuIdle+0x9c>
   14854:	1c 37       	cpi	r17, 0x7C	; 124
   14856:	20 f4       	brcc	.+8      	; 0x14860 <FMenuIdle+0x4e>
   14858:	17 37       	cpi	r17, 0x77	; 119
   1485a:	09 f0       	breq	.+2      	; 0x1485e <FMenuIdle+0x4c>
   1485c:	61 c1       	rjmp	.+706    	; 0x14b20 <FMenuIdle+0x30e>
   1485e:	2e c0       	rjmp	.+92     	; 0x148bc <FMenuIdle+0xaa>
   14860:	1d 37       	cpi	r17, 0x7D	; 125
   14862:	e9 f0       	breq	.+58     	; 0x1489e <FMenuIdle+0x8c>
   14864:	1e 37       	cpi	r17, 0x7E	; 126
   14866:	09 f0       	breq	.+2      	; 0x1486a <FMenuIdle+0x58>
   14868:	5b c1       	rjmp	.+694    	; 0x14b20 <FMenuIdle+0x30e>
   1486a:	12 c0       	rjmp	.+36     	; 0x14890 <FMenuIdle+0x7e>
   1486c:	1d 3d       	cpi	r17, 0xDD	; 221
   1486e:	09 f4       	brne	.+2      	; 0x14872 <FMenuIdle+0x60>
   14870:	4f c0       	rjmp	.+158    	; 0x14910 <FMenuIdle+0xfe>
   14872:	1e 3d       	cpi	r17, 0xDE	; 222
   14874:	38 f4       	brcc	.+14     	; 0x14884 <FMenuIdle+0x72>
   14876:	1d 3b       	cpi	r17, 0xBD	; 189
   14878:	09 f4       	brne	.+2      	; 0x1487c <FMenuIdle+0x6a>
   1487a:	56 c0       	rjmp	.+172    	; 0x14928 <FMenuIdle+0x116>
   1487c:	17 3d       	cpi	r17, 0xD7	; 215
   1487e:	09 f0       	breq	.+2      	; 0x14882 <FMenuIdle+0x70>
   14880:	4f c1       	rjmp	.+670    	; 0x14b20 <FMenuIdle+0x30e>
   14882:	27 c0       	rjmp	.+78     	; 0x148d2 <FMenuIdle+0xc0>
   14884:	1e 3d       	cpi	r17, 0xDE	; 222
   14886:	61 f1       	breq	.+88     	; 0x148e0 <FMenuIdle+0xce>
   14888:	1d 3e       	cpi	r17, 0xED	; 237
   1488a:	09 f0       	breq	.+2      	; 0x1488e <FMenuIdle+0x7c>
   1488c:	49 c1       	rjmp	.+658    	; 0x14b20 <FMenuIdle+0x30e>
   1488e:	34 c0       	rjmp	.+104    	; 0x148f8 <FMenuIdle+0xe6>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14890:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14892:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14894:	92 e0       	ldi	r25, 0x02	; 2
   14896:	90 93 be 01 	sts	0x01BE, r25
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   1489a:	81 e0       	ldi	r24, 0x01	; 1
   1489c:	15 c0       	rjmp	.+42     	; 0x148c8 <FMenuIdle+0xb6>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1489e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   148a0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   148a2:	82 e0       	ldi	r24, 0x02	; 2
   148a4:	80 93 be 01 	sts	0x01BE, r24
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   148a8:	80 93 b4 02 	sts	0x02B4, r24
   148ac:	37 c1       	rjmp	.+622    	; 0x14b1c <FMenuIdle+0x30a>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   148ae:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   148b0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   148b2:	92 e0       	ldi	r25, 0x02	; 2
   148b4:	90 93 be 01 	sts	0x01BE, r25
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   148b8:	83 e0       	ldi	r24, 0x03	; 3
   148ba:	06 c0       	rjmp	.+12     	; 0x148c8 <FMenuIdle+0xb6>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   148bc:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   148be:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   148c0:	92 e0       	ldi	r25, 0x02	; 2
   148c2:	90 93 be 01 	sts	0x01BE, r25

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   148c6:	84 e0       	ldi	r24, 0x04	; 4
   148c8:	80 93 b4 02 	sts	0x02B4, r24
   148cc:	90 93 b5 02 	sts	0x02B5, r25
   148d0:	27 c1       	rjmp	.+590    	; 0x14b20 <FMenuIdle+0x30e>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   148d2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   148d4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   148d6:	82 e0       	ldi	r24, 0x02	; 2
   148d8:	80 93 be 01 	sts	0x01BE, r24
		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   148dc:	8c e0       	ldi	r24, 0x0C	; 12
   148de:	1e c1       	rjmp	.+572    	; 0x14b1c <FMenuIdle+0x30a>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   148e0:	80 91 00 01 	lds	r24, 0x0100
   148e4:	81 30       	cpi	r24, 0x01	; 1
   148e6:	09 f0       	breq	.+2      	; 0x148ea <FMenuIdle+0xd8>
   148e8:	1b c1       	rjmp	.+566    	; 0x14b20 <FMenuIdle+0x30e>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   148ea:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   148ec:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   148ee:	82 e0       	ldi	r24, 0x02	; 2
   148f0:	80 93 be 01 	sts	0x01BE, r24
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   148f4:	80 e1       	ldi	r24, 0x10	; 16
   148f6:	12 c1       	rjmp	.+548    	; 0x14b1c <FMenuIdle+0x30a>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   148f8:	80 91 00 01 	lds	r24, 0x0100
   148fc:	81 30       	cpi	r24, 0x01	; 1
   148fe:	09 f0       	breq	.+2      	; 0x14902 <FMenuIdle+0xf0>
   14900:	0f c1       	rjmp	.+542    	; 0x14b20 <FMenuIdle+0x30e>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14902:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14904:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14906:	82 e0       	ldi	r24, 0x02	; 2
   14908:	80 93 be 01 	sts	0x01BE, r24
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   1490c:	82 e1       	ldi	r24, 0x12	; 18
   1490e:	06 c1       	rjmp	.+524    	; 0x14b1c <FMenuIdle+0x30a>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   14910:	80 91 00 01 	lds	r24, 0x0100
   14914:	81 30       	cpi	r24, 0x01	; 1
   14916:	09 f0       	breq	.+2      	; 0x1491a <FMenuIdle+0x108>
   14918:	03 c1       	rjmp	.+518    	; 0x14b20 <FMenuIdle+0x30e>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1491a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1491c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1491e:	82 e0       	ldi	r24, 0x02	; 2
   14920:	80 93 be 01 	sts	0x01BE, r24
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   14924:	81 e1       	ldi	r24, 0x11	; 17
   14926:	fa c0       	rjmp	.+500    	; 0x14b1c <FMenuIdle+0x30a>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   14928:	80 91 00 01 	lds	r24, 0x0100
   1492c:	81 30       	cpi	r24, 0x01	; 1
   1492e:	09 f0       	breq	.+2      	; 0x14932 <FMenuIdle+0x120>
   14930:	f7 c0       	rjmp	.+494    	; 0x14b20 <FMenuIdle+0x30e>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14932:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14934:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14936:	82 e0       	ldi	r24, 0x02	; 2
   14938:	80 93 be 01 	sts	0x01BE, r24
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   1493c:	8f e0       	ldi	r24, 0x0F	; 15
   1493e:	ee c0       	rjmp	.+476    	; 0x14b1c <FMenuIdle+0x30a>
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14940:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14942:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14944:	82 e0       	ldi	r24, 0x02	; 2
   14946:	80 93 be 01 	sts	0x01BE, r24
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   1494a:	8d e0       	ldi	r24, 0x0D	; 13
   1494c:	e7 c0       	rjmp	.+462    	; 0x14b1c <FMenuIdle+0x30a>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   1494e:	00 d0       	rcall	.+0      	; 0x14950 <FMenuIdle+0x13e>
   14950:	00 d0       	rcall	.+0      	; 0x14952 <FMenuIdle+0x140>
   14952:	82 e9       	ldi	r24, 0x92	; 146
   14954:	9d e0       	ldi	r25, 0x0D	; 13
   14956:	ed b7       	in	r30, 0x3d	; 61
   14958:	fe b7       	in	r31, 0x3e	; 62
   1495a:	92 83       	std	Z+2, r25	; 0x02
   1495c:	81 83       	std	Z+1, r24	; 0x01
   1495e:	8c eb       	ldi	r24, 0xBC	; 188
   14960:	93 e2       	ldi	r25, 0x23	; 35
   14962:	94 83       	std	Z+4, r25	; 0x04
   14964:	83 83       	std	Z+3, r24	; 0x03
   14966:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	     sendMessage56();
   1496a:	0f 90       	pop	r0
   1496c:	0f 90       	pop	r0
   1496e:	0f 90       	pop	r0
   14970:	0f 90       	pop	r0
   14972:	0e 94 63 50 	call	0xa0c6	; 0xa0c6 <sendMessage56>
         stMenuIdle=miDisplayProses;
   14976:	82 e0       	ldi	r24, 0x02	; 2
   14978:	d1 c0       	rjmp	.+418    	; 0x14b1c <FMenuIdle+0x30a>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   1497a:	80 91 b4 01 	lds	r24, 0x01B4
   1497e:	88 23       	and	r24, r24
   14980:	09 f0       	breq	.+2      	; 0x14984 <FMenuIdle+0x172>
   14982:	95 c0       	rjmp	.+298    	; 0x14aae <FMenuIdle+0x29c>
		     lcd_printf(3,1,PSTR("SedangProses"));
   14984:	83 e0       	ldi	r24, 0x03	; 3
   14986:	61 e0       	ldi	r22, 0x01	; 1
   14988:	4f ea       	ldi	r20, 0xAF	; 175
   1498a:	53 e2       	ldi	r21, 0x23	; 35
   1498c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	         TimDisplay=0;
   14990:	10 92 94 01 	sts	0x0194, r1
			 stMenuIdle=miWaitProses;
   14994:	83 e0       	ldi	r24, 0x03	; 3
   14996:	c2 c0       	rjmp	.+388    	; 0x14b1c <FMenuIdle+0x30a>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   14998:	80 91 94 01 	lds	r24, 0x0194
   1499c:	82 30       	cpi	r24, 0x02	; 2
   1499e:	08 f4       	brcc	.+2      	; 0x149a2 <FMenuIdle+0x190>
   149a0:	bf c0       	rjmp	.+382    	; 0x14b20 <FMenuIdle+0x30e>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   149a2:	80 91 00 01 	lds	r24, 0x0100
   149a6:	81 30       	cpi	r24, 0x01	; 1
   149a8:	11 f4       	brne	.+4      	; 0x149ae <FMenuIdle+0x19c>
   149aa:	84 e0       	ldi	r24, 0x04	; 4
   149ac:	b7 c0       	rjmp	.+366    	; 0x14b1c <FMenuIdle+0x30a>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   149ae:	82 30       	cpi	r24, 0x02	; 2
   149b0:	09 f0       	breq	.+2      	; 0x149b4 <FMenuIdle+0x1a2>
   149b2:	b6 c0       	rjmp	.+364    	; 0x14b20 <FMenuIdle+0x30e>
   149b4:	87 e0       	ldi	r24, 0x07	; 7
   149b6:	b2 c0       	rjmp	.+356    	; 0x14b1c <FMenuIdle+0x30a>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   149b8:	80 91 b4 02 	lds	r24, 0x02B4
   149bc:	60 e0       	ldi	r22, 0x00	; 0
   149be:	0e 94 75 24 	call	0x48ea	; 0x48ea <PrintStandalone>
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   149c2:	81 31       	cpi	r24, 0x11	; 17
   149c4:	09 f4       	brne	.+2      	; 0x149c8 <FMenuIdle+0x1b6>
   149c6:	a9 c0       	rjmp	.+338    	; 0x14b1a <FMenuIdle+0x308>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   149c8:	82 31       	cpi	r24, 0x12	; 18
   149ca:	09 f0       	breq	.+2      	; 0x149ce <FMenuIdle+0x1bc>
   149cc:	a9 c0       	rjmp	.+338    	; 0x14b20 <FMenuIdle+0x30e>
   149ce:	88 e0       	ldi	r24, 0x08	; 8
   149d0:	a5 c0       	rjmp	.+330    	; 0x14b1c <FMenuIdle+0x30a>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   149d2:	83 e0       	ldi	r24, 0x03	; 3
   149d4:	61 e0       	ldi	r22, 0x01	; 1
   149d6:	4a e9       	ldi	r20, 0x9A	; 154
   149d8:	53 e2       	ldi	r21, 0x23	; 35
   149da:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
         TimDisplay=0;
   149de:	10 92 94 01 	sts	0x0194, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   149e2:	89 e0       	ldi	r24, 0x09	; 9
   149e4:	9b c0       	rjmp	.+310    	; 0x14b1c <FMenuIdle+0x30a>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   149e6:	80 91 94 01 	lds	r24, 0x0194
   149ea:	82 30       	cpi	r24, 0x02	; 2
   149ec:	08 f4       	brcc	.+2      	; 0x149f0 <FMenuIdle+0x1de>
   149ee:	98 c0       	rjmp	.+304    	; 0x14b20 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   149f0:	83 e0       	ldi	r24, 0x03	; 3
   149f2:	61 e0       	ldi	r22, 0x01	; 1
   149f4:	45 e8       	ldi	r20, 0x85	; 133
   149f6:	53 e2       	ldi	r21, 0x23	; 35
   149f8:	32 c0       	rjmp	.+100    	; 0x14a5e <FMenuIdle+0x24c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   149fa:	83 e0       	ldi	r24, 0x03	; 3
   149fc:	61 e0       	ldi	r22, 0x01	; 1
   149fe:	40 e7       	ldi	r20, 0x70	; 112
   14a00:	53 e2       	ldi	r21, 0x23	; 35
   14a02:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	     sendMessage98(ButtonID);
   14a06:	80 91 b4 02 	lds	r24, 0x02B4
   14a0a:	0e 94 2c 50 	call	0xa058	; 0xa058 <sendMessage98>
		 ProcTimeOut=0;
   14a0e:	10 92 bd 01 	sts	0x01BD, r1
		 stMenuIdle=miWaitPlease;
   14a12:	85 e0       	ldi	r24, 0x05	; 5
   14a14:	83 c0       	rjmp	.+262    	; 0x14b1c <FMenuIdle+0x30a>
	     break;
    case miWaitPlease:	     
         if (ProcTimeOut>TIM_NO_RESPONSE){
   14a16:	80 91 bd 01 	lds	r24, 0x01BD
   14a1a:	8f 30       	cpi	r24, 0x0F	; 15
   14a1c:	58 f0       	brcs	.+22     	; 0x14a34 <FMenuIdle+0x222>
	         lcd_printf(3,1,PSTR("No Response..       "));
   14a1e:	83 e0       	ldi	r24, 0x03	; 3
   14a20:	61 e0       	ldi	r22, 0x01	; 1
   14a22:	4b e5       	ldi	r20, 0x5B	; 91
   14a24:	53 e2       	ldi	r21, 0x23	; 35
   14a26:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		     stMenuIdle=miNoResponse;
   14a2a:	86 e0       	ldi	r24, 0x06	; 6
   14a2c:	80 93 b5 02 	sts	0x02B5, r24
			 TimDisplay=0;		 
   14a30:	10 92 94 01 	sts	0x0194, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   14a34:	80 91 a1 01 	lds	r24, 0x01A1
   14a38:	81 30       	cpi	r24, 0x01	; 1
   14a3a:	29 f0       	breq	.+10     	; 0x14a46 <FMenuIdle+0x234>
   14a3c:	80 91 a0 01 	lds	r24, 0x01A0
   14a40:	81 30       	cpi	r24, 0x01	; 1
   14a42:	09 f0       	breq	.+2      	; 0x14a46 <FMenuIdle+0x234>
   14a44:	6d c0       	rjmp	.+218    	; 0x14b20 <FMenuIdle+0x30e>
		     ClearMem(strOdometer);
   14a46:	8c ec       	ldi	r24, 0xCC	; 204
   14a48:	93 e0       	ldi	r25, 0x03	; 3
   14a4a:	0e 94 e6 a7 	call	0x14fcc	; 0x14fcc <ClearMem>
		     ClearMem(strLicPlate);
   14a4e:	83 e0       	ldi	r24, 0x03	; 3
   14a50:	99 e0       	ldi	r25, 0x09	; 9
   14a52:	0e 94 e6 a7 	call	0x14fcc	; 0x14fcc <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   14a56:	83 e0       	ldi	r24, 0x03	; 3
   14a58:	61 e0       	ldi	r22, 0x01	; 1
   14a5a:	46 e4       	ldi	r20, 0x46	; 70
   14a5c:	53 e2       	ldi	r21, 0x23	; 35
   14a5e:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		     stMenuIdle=miWaitReady;
   14a62:	8a e0       	ldi	r24, 0x0A	; 10
   14a64:	80 93 b5 02 	sts	0x02B5, r24
			 TimDisplay=0;
   14a68:	10 92 94 01 	sts	0x0194, r1
   14a6c:	59 c0       	rjmp	.+178    	; 0x14b20 <FMenuIdle+0x30e>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   14a6e:	80 91 94 01 	lds	r24, 0x0194
   14a72:	82 30       	cpi	r24, 0x02	; 2
   14a74:	08 f4       	brcc	.+2      	; 0x14a78 <FMenuIdle+0x266>
   14a76:	54 c0       	rjmp	.+168    	; 0x14b20 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   14a78:	83 e0       	ldi	r24, 0x03	; 3
   14a7a:	61 e0       	ldi	r22, 0x01	; 1
   14a7c:	41 e3       	ldi	r20, 0x31	; 49
   14a7e:	53 e2       	ldi	r21, 0x23	; 35
   14a80:	ee cf       	rjmp	.-36     	; 0x14a5e <FMenuIdle+0x24c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   14a82:	80 91 94 01 	lds	r24, 0x0194
   14a86:	82 30       	cpi	r24, 0x02	; 2
   14a88:	08 f4       	brcc	.+2      	; 0x14a8c <FMenuIdle+0x27a>
   14a8a:	4a c0       	rjmp	.+148    	; 0x14b20 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("                "));
   14a8c:	83 e0       	ldi	r24, 0x03	; 3
   14a8e:	61 e0       	ldi	r22, 0x01	; 1
   14a90:	40 e2       	ldi	r20, 0x20	; 32
   14a92:	53 e2       	ldi	r21, 0x23	; 35
   14a94:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		     stMenuIdle=miReady;
   14a98:	8b e0       	ldi	r24, 0x0B	; 11
   14a9a:	e4 cf       	rjmp	.-56     	; 0x14a64 <FMenuIdle+0x252>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     DisplayScreenIdle();
   14a9c:	0e 94 76 1c 	call	0x38ec	; 0x38ec <DisplayScreenIdle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   14aa0:	80 91 00 01 	lds	r24, 0x0100
   14aa4:	82 30       	cpi	r24, 0x02	; 2
   14aa6:	19 f4       	brne	.+6      	; 0x14aae <FMenuIdle+0x29c>
   14aa8:	81 e0       	ldi	r24, 0x01	; 1
   14aaa:	80 93 01 01 	sts	0x0101, r24
		 stMenuIdle=miScan;
   14aae:	81 e0       	ldi	r24, 0x01	; 1
   14ab0:	35 c0       	rjmp	.+106    	; 0x14b1c <FMenuIdle+0x30a>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   14ab2:	0e 94 86 85 	call	0x10b0c	; 0x10b0c <FMenuTicket>
   14ab6:	2f c0       	rjmp	.+94     	; 0x14b16 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   14ab8:	0e 94 a7 a3 	call	0x1474e	; 0x1474e <FMenuAuthorization>
   14abc:	2c c0       	rjmp	.+88     	; 0x14b16 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   14abe:	0e 94 47 98 	call	0x1308e	; 0x1308e <FMenuLocalAccount>
   14ac2:	29 c0       	rjmp	.+82     	; 0x14b16 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   14ac4:	0e 94 0f 94 	call	0x1281e	; 0x1281e <FMenuChangeMOP>
   14ac8:	26 c0       	rjmp	.+76     	; 0x14b16 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   14aca:	0e 94 c5 6b 	call	0xd78a	; 0xd78a <FMenuEDCTransaction>
   14ace:	23 c0       	rjmp	.+70     	; 0x14b16 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   14ad0:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <FMenuLoyalty>
   14ad4:	20 c0       	rjmp	.+64     	; 0x14b16 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   14ad6:	0e 94 6e 92 	call	0x124dc	; 0x124dc <FMenuReprint>
   14ada:	1d c0       	rjmp	.+58     	; 0x14b16 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   14adc:	0e 94 3c 1c 	call	0x3878	; 0x3878 <FViewFreeMessage>
   14ae0:	1a c0       	rjmp	.+52     	; 0x14b16 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   14ae2:	83 e0       	ldi	r24, 0x03	; 3
   14ae4:	61 e0       	ldi	r22, 0x01	; 1
   14ae6:	4b e0       	ldi	r20, 0x0B	; 11
   14ae8:	53 e2       	ldi	r21, 0x23	; 35
   14aea:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   14aee:	80 e0       	ldi	r24, 0x00	; 0
   14af0:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   14af4:	81 e0       	ldi	r24, 0x01	; 1
   14af6:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <ResetTotalizer>
   14afa:	0f c0       	rjmp	.+30     	; 0x14b1a <FMenuIdle+0x308>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   14afc:	83 e0       	ldi	r24, 0x03	; 3
   14afe:	61 e0       	ldi	r22, 0x01	; 1
   14b00:	49 ef       	ldi	r20, 0xF9	; 249
   14b02:	52 e2       	ldi	r21, 0x22	; 34
   14b04:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   14b08:	85 e0       	ldi	r24, 0x05	; 5
   14b0a:	62 e1       	ldi	r22, 0x12	; 18
   14b0c:	0e 94 f4 78 	call	0xf1e8	; 0xf1e8 <SendSlaveCommand>
   14b10:	04 c0       	rjmp	.+8      	; 0x14b1a <FMenuIdle+0x308>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   14b12:	0e 94 8a 1b 	call	0x3714	; 0x3714 <FTestChar>
   14b16:	81 30       	cpi	r24, 0x01	; 1
   14b18:	19 f4       	brne	.+6      	; 0x14b20 <FMenuIdle+0x30e>
         stMenuIdle=miReady;
   14b1a:	8b e0       	ldi	r24, 0x0B	; 11
   14b1c:	80 93 b5 02 	sts	0x02B5, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   14b20:	80 91 a3 01 	lds	r24, 0x01A3
   14b24:	81 30       	cpi	r24, 0x01	; 1
   14b26:	21 f4       	brne	.+8      	; 0x14b30 <FMenuIdle+0x31e>
		    IsMessage21=False;
   14b28:	10 92 a3 01 	sts	0x01A3, r1
			procMessage21();
   14b2c:	0e 94 b8 20 	call	0x4170	; 0x4170 <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   14b30:	80 91 a0 01 	lds	r24, 0x01A0
   14b34:	81 30       	cpi	r24, 0x01	; 1
   14b36:	91 f4       	brne	.+36     	; 0x14b5c <FMenuIdle+0x34a>
		    IsMessage00=False;
   14b38:	10 92 a0 01 	sts	0x01A0, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   14b3c:	20 91 26 0b 	lds	r18, 0x0B26
   14b40:	21 30       	cpi	r18, 0x01	; 1
   14b42:	61 f4       	brne	.+24     	; 0x14b5c <FMenuIdle+0x34a>
   14b44:	80 91 8d 01 	lds	r24, 0x018D
   14b48:	90 91 8e 01 	lds	r25, 0x018E
   14b4c:	8f 97       	sbiw	r24, 0x2f	; 47
   14b4e:	31 f4       	brne	.+12     	; 0x14b5c <FMenuIdle+0x34a>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   14b50:	80 91 4b 0b 	lds	r24, 0x0B4B
   14b54:	84 33       	cpi	r24, 0x34	; 52
   14b56:	11 f4       	brne	.+4      	; 0x14b5c <FMenuIdle+0x34a>
			    IsNoTransaction=True;
   14b58:	20 93 ad 01 	sts	0x01AD, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   14b5c:	80 91 99 01 	lds	r24, 0x0199
   14b60:	81 30       	cpi	r24, 0x01	; 1
   14b62:	21 f4       	brne	.+8      	; 0x14b6c <FMenuIdle+0x35a>
		    IsSendMessageEDC=False;
   14b64:	10 92 99 01 	sts	0x0199, r1
			SendEDCMessage();
   14b68:	0e 94 6f 78 	call	0xf0de	; 0xf0de <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   14b6c:	80 91 9b 01 	lds	r24, 0x019B
   14b70:	81 30       	cpi	r24, 0x01	; 1
   14b72:	21 f4       	brne	.+8      	; 0x14b7c <FMenuIdle+0x36a>
		    IsEDCApproved=False;
   14b74:	10 92 9b 01 	sts	0x019B, r1
            sendMessage92();
   14b78:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <sendMessage92>
		}
		if (IsVoidTransaction==True){
   14b7c:	80 91 9d 01 	lds	r24, 0x019D
   14b80:	81 30       	cpi	r24, 0x01	; 1
   14b82:	21 f4       	brne	.+8      	; 0x14b8c <FMenuIdle+0x37a>
		    IsVoidTransaction=False;
   14b84:	10 92 9d 01 	sts	0x019D, r1
            sendMessage94();
   14b88:	0e 94 53 50 	call	0xa0a6	; 0xa0a6 <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   14b8c:	10 91 a1 01 	lds	r17, 0x01A1
   14b90:	11 30       	cpi	r17, 0x01	; 1
   14b92:	31 f4       	brne	.+12     	; 0x14ba0 <FMenuIdle+0x38e>
	        IsMessage99=False;
   14b94:	10 92 a1 01 	sts	0x01A1, r1
		    procMessage99();
   14b98:	0e 94 8b 47 	call	0x8f16	; 0x8f16 <procMessage99>
		    IsPrinting=True;
   14b9c:	10 93 ae 01 	sts	0x01AE, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   14ba0:	80 91 ad 01 	lds	r24, 0x01AD
   14ba4:	81 30       	cpi	r24, 0x01	; 1
   14ba6:	41 f4       	brne	.+16     	; 0x14bb8 <FMenuIdle+0x3a6>
			IsNoTransaction=False;
   14ba8:	10 92 ad 01 	sts	0x01AD, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   14bac:	83 e0       	ldi	r24, 0x03	; 3
   14bae:	61 e0       	ldi	r22, 0x01	; 1
   14bb0:	44 ee       	ldi	r20, 0xE4	; 228
   14bb2:	52 e2       	ldi	r21, 0x22	; 34
   14bb4:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   14bb8:	80 91 b5 02 	lds	r24, 0x02B5
   14bbc:	81 30       	cpi	r24, 0x01	; 1
   14bbe:	11 f4       	brne	.+4      	; 0x14bc4 <FMenuIdle+0x3b2>
		    DisplayIdle();			
   14bc0:	0e 94 03 77 	call	0xee06	; 0xee06 <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   14bc4:	80 91 b5 02 	lds	r24, 0x02B5
   14bc8:	81 30       	cpi	r24, 0x01	; 1
   14bca:	59 f4       	brne	.+22     	; 0x14be2 <FMenuIdle+0x3d0>
		    if (IsMessage09==True){
   14bcc:	80 91 a5 01 	lds	r24, 0x01A5
   14bd0:	81 30       	cpi	r24, 0x01	; 1
   14bd2:	39 f4       	brne	.+14     	; 0x14be2 <FMenuIdle+0x3d0>
			    IsMessage09=False;
   14bd4:	10 92 a5 01 	sts	0x01A5, r1
				procMessage09();
   14bd8:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   14bdc:	83 e1       	ldi	r24, 0x13	; 19
   14bde:	80 93 b5 02 	sts	0x02B5, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   14be2:	80 91 b5 02 	lds	r24, 0x02B5
   14be6:	81 30       	cpi	r24, 0x01	; 1
   14be8:	71 f4       	brne	.+28     	; 0x14c06 <FMenuIdle+0x3f4>
   14bea:	80 91 9a 01 	lds	r24, 0x019A
   14bee:	81 30       	cpi	r24, 0x01	; 1
   14bf0:	51 f4       	brne	.+20     	; 0x14c06 <FMenuIdle+0x3f4>
		    IsRFIDDetected=False;
   14bf2:	10 92 9a 01 	sts	0x019A, r1
	//uart(1,1,spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14bf6:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14bf8:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14bfa:	82 e0       	ldi	r24, 0x02	; 2
   14bfc:	80 93 be 01 	sts	0x01BE, r24

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
		    IsRFIDDetected=False;
		    system_beep(2);           
			stMenuIdle=miRunLocalAccount;
   14c00:	8e e0       	ldi	r24, 0x0E	; 14
   14c02:	80 93 b5 02 	sts	0x02B5, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   14c06:	10 91 a8 01 	lds	r17, 0x01A8
   14c0a:	11 30       	cpi	r17, 0x01	; 1
   14c0c:	41 f4       	brne	.+16     	; 0x14c1e <FMenuIdle+0x40c>
		    IsMessage81=False;
   14c0e:	10 92 a8 01 	sts	0x01A8, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   14c12:	0e 94 47 18 	call	0x308e	; 0x308e <procMessage81>
   14c16:	80 93 b7 01 	sts	0x01B7, r24
			IsFreePrinting=True;
   14c1a:	10 93 aa 01 	sts	0x01AA, r17
         }

    //SystemService
      systemGenerateReport();
   14c1e:	0e 94 12 3a 	call	0x7424	; 0x7424 <systemGenerateReport>
      systemPrinting();
   14c22:	0e 94 f6 5b 	call	0xb7ec	; 0xb7ec <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   14c26:	0e 94 bf 4b 	call	0x977e	; 0x977e <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   14c2a:	1f 91       	pop	r17
   14c2c:	08 95       	ret

00014c2e <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
   14c2e:	af 92       	push	r10
   14c30:	bf 92       	push	r11
   14c32:	cf 92       	push	r12
   14c34:	df 92       	push	r13
   14c36:	ff 92       	push	r15
   14c38:	0f 93       	push	r16
   14c3a:	1f 93       	push	r17
   14c3c:	df 93       	push	r29
   14c3e:	cf 93       	push	r28
   14c40:	cd b7       	in	r28, 0x3d	; 61
   14c42:	de b7       	in	r29, 0x3e	; 62
   14c44:	64 97       	sbiw	r28, 0x14	; 20
   14c46:	0f b6       	in	r0, 0x3f	; 63
   14c48:	f8 94       	cli
   14c4a:	de bf       	out	0x3e, r29	; 62
   14c4c:	0f be       	out	0x3f, r0	; 63
   14c4e:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
   14c50:	83 e0       	ldi	r24, 0x03	; 3
   14c52:	61 e0       	ldi	r22, 0x01	; 1
   14c54:	48 eb       	ldi	r20, 0xB8	; 184
   14c56:	5d e1       	ldi	r21, 0x1D	; 29
   14c58:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
   14c5c:	01 e0       	ldi	r16, 0x01	; 1
   14c5e:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   14c60:	6e 01       	movw	r12, r28
   14c62:	08 94       	sec
   14c64:	c1 1c       	adc	r12, r1
   14c66:	d1 1c       	adc	r13, r1
   14c68:	a4 ea       	ldi	r26, 0xA4	; 164
   14c6a:	aa 2e       	mov	r10, r26
   14c6c:	ad e1       	ldi	r26, 0x1D	; 29
   14c6e:	ba 2e       	mov	r11, r26
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14c70:	e1 99       	sbic	0x1c, 1	; 28
   14c72:	fe cf       	rjmp	.-4      	; 0x14c70 <InitComport+0x42>
   14c74:	c8 01       	movw	r24, r16
   14c76:	81 5c       	subi	r24, 0xC1	; 193
   14c78:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14c7a:	9f bb       	out	0x1f, r25	; 31
   14c7c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14c7e:	e0 9a       	sbi	0x1c, 0	; 28
   14c80:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   14c82:	22 e0       	ldi	r18, 0x02	; 2
   14c84:	f2 16       	cp	r15, r18
   14c86:	71 f0       	breq	.+28     	; 0x14ca4 <InitComport+0x76>
   14c88:	f2 16       	cp	r15, r18
   14c8a:	30 f0       	brcs	.+12     	; 0x14c98 <InitComport+0x6a>
   14c8c:	33 e0       	ldi	r19, 0x03	; 3
   14c8e:	f3 16       	cp	r15, r19
   14c90:	31 f4       	brne	.+12     	; 0x14c9e <InitComport+0x70>
   14c92:	85 eb       	ldi	r24, 0xB5	; 181
   14c94:	9f e2       	ldi	r25, 0x2F	; 47
   14c96:	08 c0       	rjmp	.+16     	; 0x14ca8 <InitComport+0x7a>
   14c98:	80 e8       	ldi	r24, 0x80	; 128
   14c9a:	95 e2       	ldi	r25, 0x25	; 37
   14c9c:	05 c0       	rjmp	.+10     	; 0x14ca8 <InitComport+0x7a>
   14c9e:	80 e0       	ldi	r24, 0x00	; 0
   14ca0:	90 e0       	ldi	r25, 0x00	; 0
   14ca2:	02 c0       	rjmp	.+4      	; 0x14ca8 <InitComport+0x7a>
   14ca4:	80 e0       	ldi	r24, 0x00	; 0
   14ca6:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   14ca8:	ad b7       	in	r26, 0x3d	; 61
   14caa:	be b7       	in	r27, 0x3e	; 62
   14cac:	18 97       	sbiw	r26, 0x08	; 8
   14cae:	0f b6       	in	r0, 0x3f	; 63
   14cb0:	f8 94       	cli
   14cb2:	be bf       	out	0x3e, r27	; 62
   14cb4:	0f be       	out	0x3f, r0	; 63
   14cb6:	ad bf       	out	0x3d, r26	; 61
   14cb8:	ed b7       	in	r30, 0x3d	; 61
   14cba:	fe b7       	in	r31, 0x3e	; 62
   14cbc:	31 96       	adiw	r30, 0x01	; 1
   14cbe:	12 96       	adiw	r26, 0x02	; 2
   14cc0:	dc 92       	st	X, r13
   14cc2:	ce 92       	st	-X, r12
   14cc4:	11 97       	sbiw	r26, 0x01	; 1
   14cc6:	b3 82       	std	Z+3, r11	; 0x03
   14cc8:	a2 82       	std	Z+2, r10	; 0x02
   14cca:	15 83       	std	Z+5, r17	; 0x05
   14ccc:	04 83       	std	Z+4, r16	; 0x04
   14cce:	97 83       	std	Z+7, r25	; 0x07
   14cd0:	86 83       	std	Z+6, r24	; 0x06
   14cd2:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
		 lcd_print(4,1,lcdteks);
   14cd6:	2d b7       	in	r18, 0x3d	; 61
   14cd8:	3e b7       	in	r19, 0x3e	; 62
   14cda:	28 5f       	subi	r18, 0xF8	; 248
   14cdc:	3f 4f       	sbci	r19, 0xFF	; 255
   14cde:	0f b6       	in	r0, 0x3f	; 63
   14ce0:	f8 94       	cli
   14ce2:	3e bf       	out	0x3e, r19	; 62
   14ce4:	0f be       	out	0x3f, r0	; 63
   14ce6:	2d bf       	out	0x3d, r18	; 61
   14ce8:	84 e0       	ldi	r24, 0x04	; 4
   14cea:	61 e0       	ldi	r22, 0x01	; 1
   14cec:	a6 01       	movw	r20, r12
   14cee:	0e 94 4d a7 	call	0x14e9a	; 0x14e9a <lcd_print>
		 SetBaudRate(i+1,brMap);
   14cf2:	80 2f       	mov	r24, r16
   14cf4:	6f 2d       	mov	r22, r15
   14cf6:	0e 94 09 a1 	call	0x14212	; 0x14212 <SetBaudRate>
 	     TimDisplay=0;
   14cfa:	10 92 94 01 	sts	0x0194, r1
   14cfe:	04 c0       	rjmp	.+8      	; 0x14d08 <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>1)break;
   14d00:	80 91 94 01 	lds	r24, 0x0194
   14d04:	82 30       	cpi	r24, 0x02	; 2
   14d06:	20 f4       	brcc	.+8      	; 0x14d10 <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
   14d08:	80 91 94 01 	lds	r24, 0x0194
   14d0c:	82 30       	cpi	r24, 0x02	; 2
   14d0e:	c0 f3       	brcs	.-16     	; 0x14d00 <InitComport+0xd2>
   14d10:	0f 5f       	subi	r16, 0xFF	; 255
   14d12:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
   14d14:	05 30       	cpi	r16, 0x05	; 5
   14d16:	11 05       	cpc	r17, r1
   14d18:	09 f0       	breq	.+2      	; 0x14d1c <InitComport+0xee>
   14d1a:	aa cf       	rjmp	.-172    	; 0x14c70 <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>1)break;
		 };

	 }
}
   14d1c:	64 96       	adiw	r28, 0x14	; 20
   14d1e:	0f b6       	in	r0, 0x3f	; 63
   14d20:	f8 94       	cli
   14d22:	de bf       	out	0x3e, r29	; 62
   14d24:	0f be       	out	0x3f, r0	; 63
   14d26:	cd bf       	out	0x3d, r28	; 61
   14d28:	cf 91       	pop	r28
   14d2a:	df 91       	pop	r29
   14d2c:	1f 91       	pop	r17
   14d2e:	0f 91       	pop	r16
   14d30:	ff 90       	pop	r15
   14d32:	df 90       	pop	r13
   14d34:	cf 90       	pop	r12
   14d36:	bf 90       	pop	r11
   14d38:	af 90       	pop	r10
   14d3a:	08 95       	ret

00014d3c <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   14d3c:	98 2f       	mov	r25, r24
   14d3e:	90 7f       	andi	r25, 0xF0	; 240
   14d40:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   14d42:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   14d44:	a9 9a       	sbi	0x15, 1	; 21
   14d46:	48 ee       	ldi	r20, 0xE8	; 232
   14d48:	53 e0       	ldi	r21, 0x03	; 3
   14d4a:	fa 01       	movw	r30, r20
   14d4c:	31 97       	sbiw	r30, 0x01	; 1
   14d4e:	f1 f7       	brne	.-4      	; 0x14d4c <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   14d50:	a9 98       	cbi	0x15, 1	; 21
   14d52:	fa 01       	movw	r30, r20
   14d54:	31 97       	sbiw	r30, 0x01	; 1
   14d56:	f1 f7       	brne	.-4      	; 0x14d54 <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   14d58:	28 2f       	mov	r18, r24
   14d5a:	30 e0       	ldi	r19, 0x00	; 0
   14d5c:	94 e0       	ldi	r25, 0x04	; 4
   14d5e:	22 0f       	add	r18, r18
   14d60:	33 1f       	adc	r19, r19
   14d62:	9a 95       	dec	r25
   14d64:	e1 f7       	brne	.-8      	; 0x14d5e <lcd_command+0x22>
   14d66:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   14d68:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   14d6a:	a9 9a       	sbi	0x15, 1	; 21
   14d6c:	fa 01       	movw	r30, r20
   14d6e:	31 97       	sbiw	r30, 0x01	; 1
   14d70:	f1 f7       	brne	.-4      	; 0x14d6e <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   14d72:	a9 98       	cbi	0x15, 1	; 21
   14d74:	fa 01       	movw	r30, r20
   14d76:	31 97       	sbiw	r30, 0x01	; 1
   14d78:	f1 f7       	brne	.-4      	; 0x14d76 <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   14d7a:	fa 01       	movw	r30, r20
   14d7c:	31 97       	sbiw	r30, 0x01	; 1
   14d7e:	f1 f7       	brne	.-4      	; 0x14d7c <lcd_command+0x40>
   14d80:	81 30       	cpi	r24, 0x01	; 1
   14d82:	21 f4       	brne	.+8      	; 0x14d8c <lcd_command+0x50>
   14d84:	84 ed       	ldi	r24, 0xD4	; 212
   14d86:	90 e3       	ldi	r25, 0x30	; 48
   14d88:	01 97       	sbiw	r24, 0x01	; 1
   14d8a:	f1 f7       	brne	.-4      	; 0x14d88 <lcd_command+0x4c>
   14d8c:	08 95       	ret

00014d8e <lcd_init>:
   14d8e:	86 ea       	ldi	r24, 0xA6	; 166
   14d90:	9e e0       	ldi	r25, 0x0E	; 14
   14d92:	01 97       	sbiw	r24, 0x01	; 1
   14d94:	f1 f7       	brne	.-4      	; 0x14d92 <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   14d96:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   14d98:	84 b3       	in	r24, 0x14	; 20
   14d9a:	80 6f       	ori	r24, 0xF0	; 240
   14d9c:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   14d9e:	84 b3       	in	r24, 0x14	; 20
   14da0:	8e 60       	ori	r24, 0x0E	; 14
   14da2:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   14da4:	20 e3       	ldi	r18, 0x30	; 48
   14da6:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   14da8:	a9 9a       	sbi	0x15, 1	; 21
   14daa:	88 ee       	ldi	r24, 0xE8	; 232
   14dac:	93 e0       	ldi	r25, 0x03	; 3
   14dae:	fc 01       	movw	r30, r24
   14db0:	31 97       	sbiw	r30, 0x01	; 1
   14db2:	f1 f7       	brne	.-4      	; 0x14db0 <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   14db4:	a9 98       	cbi	0x15, 1	; 21
   14db6:	fc 01       	movw	r30, r24
   14db8:	31 97       	sbiw	r30, 0x01	; 1
   14dba:	f1 f7       	brne	.-4      	; 0x14db8 <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   14dbc:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   14dbe:	a9 9a       	sbi	0x15, 1	; 21
   14dc0:	fc 01       	movw	r30, r24
   14dc2:	31 97       	sbiw	r30, 0x01	; 1
   14dc4:	f1 f7       	brne	.-4      	; 0x14dc2 <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   14dc6:	a9 98       	cbi	0x15, 1	; 21
   14dc8:	fc 01       	movw	r30, r24
   14dca:	31 97       	sbiw	r30, 0x01	; 1
   14dcc:	f1 f7       	brne	.-4      	; 0x14dca <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   14dce:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   14dd0:	a9 9a       	sbi	0x15, 1	; 21
   14dd2:	fc 01       	movw	r30, r24
   14dd4:	31 97       	sbiw	r30, 0x01	; 1
   14dd6:	f1 f7       	brne	.-4      	; 0x14dd4 <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   14dd8:	a9 98       	cbi	0x15, 1	; 21
   14dda:	fc 01       	movw	r30, r24
   14ddc:	31 97       	sbiw	r30, 0x01	; 1
   14dde:	f1 f7       	brne	.-4      	; 0x14ddc <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   14de0:	20 e2       	ldi	r18, 0x20	; 32
   14de2:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   14de4:	a9 9a       	sbi	0x15, 1	; 21
   14de6:	fc 01       	movw	r30, r24
   14de8:	31 97       	sbiw	r30, 0x01	; 1
   14dea:	f1 f7       	brne	.-4      	; 0x14de8 <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   14dec:	a9 98       	cbi	0x15, 1	; 21
   14dee:	01 97       	sbiw	r24, 0x01	; 1
   14df0:	f1 f7       	brne	.-4      	; 0x14dee <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   14df2:	81 e0       	ldi	r24, 0x01	; 1
   14df4:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   14df8:	e4 e6       	ldi	r30, 0x64	; 100
   14dfa:	f0 e0       	ldi	r31, 0x00	; 0
   14dfc:	80 81       	ld	r24, Z
   14dfe:	82 60       	ori	r24, 0x02	; 2
   14e00:	80 83       	st	Z, r24

	lcd_command(0x28);
   14e02:	88 e2       	ldi	r24, 0x28	; 40
   14e04:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
	lcd_command(0x0c);
   14e08:	8c e0       	ldi	r24, 0x0C	; 12
   14e0a:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
	lcd_command(0x06);
   14e0e:	86 e0       	ldi	r24, 0x06	; 6
   14e10:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
}
   14e14:	08 95       	ret

00014e16 <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   14e16:	28 2f       	mov	r18, r24
   14e18:	20 7f       	andi	r18, 0xF0	; 240
   14e1a:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   14e1c:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   14e1e:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   14e20:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   14e22:	90 e0       	ldi	r25, 0x00	; 0
   14e24:	24 e0       	ldi	r18, 0x04	; 4
   14e26:	88 0f       	add	r24, r24
   14e28:	99 1f       	adc	r25, r25
   14e2a:	2a 95       	dec	r18
   14e2c:	e1 f7       	brne	.-8      	; 0x14e26 <_lcd+0x10>
   14e2e:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   14e30:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   14e32:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   14e34:	a9 98       	cbi	0x15, 1	; 21
   14e36:	88 ee       	ldi	r24, 0xE8	; 232
   14e38:	93 e0       	ldi	r25, 0x03	; 3
   14e3a:	01 97       	sbiw	r24, 0x01	; 1
   14e3c:	f1 f7       	brne	.-4      	; 0x14e3a <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   14e3e:	8a ef       	ldi	r24, 0xFA	; 250
   14e40:	90 e0       	ldi	r25, 0x00	; 0
   14e42:	01 97       	sbiw	r24, 0x01	; 1
   14e44:	f1 f7       	brne	.-4      	; 0x14e42 <_lcd+0x2c>
   14e46:	08 95       	ret

00014e48 <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   14e48:	cf 93       	push	r28
   14e4a:	df 93       	push	r29
   14e4c:	ec 01       	movw	r28, r24
   14e4e:	03 c0       	rjmp	.+6      	; 0x14e56 <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   14e50:	21 96       	adiw	r28, 0x01	; 1
   14e52:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   14e56:	88 81       	ld	r24, Y
   14e58:	88 23       	and	r24, r24
   14e5a:	d1 f7       	brne	.-12     	; 0x14e50 <lcd_string+0x8>
		_lcd(*__string++);
}
   14e5c:	df 91       	pop	r29
   14e5e:	cf 91       	pop	r28
   14e60:	08 95       	ret

00014e62 <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   14e62:	82 30       	cpi	r24, 0x02	; 2
   14e64:	69 f0       	breq	.+26     	; 0x14e80 <lcd_xy+0x1e>
   14e66:	83 30       	cpi	r24, 0x03	; 3
   14e68:	18 f4       	brcc	.+6      	; 0x14e70 <lcd_xy+0xe>
   14e6a:	81 30       	cpi	r24, 0x01	; 1
   14e6c:	a9 f4       	brne	.+42     	; 0x14e98 <lcd_xy+0x36>
   14e6e:	05 c0       	rjmp	.+10     	; 0x14e7a <lcd_xy+0x18>
   14e70:	83 30       	cpi	r24, 0x03	; 3
   14e72:	49 f0       	breq	.+18     	; 0x14e86 <lcd_xy+0x24>
   14e74:	84 30       	cpi	r24, 0x04	; 4
   14e76:	81 f4       	brne	.+32     	; 0x14e98 <lcd_xy+0x36>
   14e78:	0b c0       	rjmp	.+22     	; 0x14e90 <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   14e7a:	86 2f       	mov	r24, r22
   14e7c:	81 58       	subi	r24, 0x81	; 129
   14e7e:	05 c0       	rjmp	.+10     	; 0x14e8a <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   14e80:	86 2f       	mov	r24, r22
   14e82:	81 54       	subi	r24, 0x41	; 65
   14e84:	02 c0       	rjmp	.+4      	; 0x14e8a <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   14e86:	86 2f       	mov	r24, r22
   14e88:	8d 56       	subi	r24, 0x6D	; 109
   14e8a:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
   14e8e:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   14e90:	86 2f       	mov	r24, r22
   14e92:	8d 52       	subi	r24, 0x2D	; 45
   14e94:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
   14e98:	08 95       	ret

00014e9a <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   14e9a:	df 92       	push	r13
   14e9c:	ef 92       	push	r14
   14e9e:	ff 92       	push	r15
   14ea0:	0f 93       	push	r16
   14ea2:	1f 93       	push	r17
   14ea4:	cf 93       	push	r28
   14ea6:	df 93       	push	r29
   14ea8:	06 2f       	mov	r16, r22
   14eaa:	d4 2e       	mov	r13, r20
   14eac:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   14eae:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
   14eb2:	2d 2d       	mov	r18, r13
   14eb4:	31 2f       	mov	r19, r17
   14eb6:	c9 01       	movw	r24, r18
   14eb8:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   14eba:	34 e1       	ldi	r19, 0x14	; 20
   14ebc:	e3 2e       	mov	r14, r19
   14ebe:	f1 2c       	mov	r15, r1
   14ec0:	e0 1a       	sub	r14, r16
   14ec2:	f1 08       	sbc	r15, r1
   14ec4:	04 c0       	rjmp	.+8      	; 0x14ece <lcd_print+0x34>
		_lcd(*__string);__string++;
   14ec6:	82 2f       	mov	r24, r18
   14ec8:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
   14ecc:	21 96       	adiw	r28, 0x01	; 1
   14ece:	9e 01       	movw	r18, r28
   14ed0:	2d 19       	sub	r18, r13
   14ed2:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   14ed4:	28 81       	ld	r18, Y
   14ed6:	22 23       	and	r18, r18
   14ed8:	21 f0       	breq	.+8      	; 0x14ee2 <lcd_print+0x48>
   14eda:	90 e0       	ldi	r25, 0x00	; 0
   14edc:	e8 16       	cp	r14, r24
   14ede:	f9 06       	cpc	r15, r25
   14ee0:	94 f7       	brge	.-28     	; 0x14ec6 <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   14ee2:	df 91       	pop	r29
   14ee4:	cf 91       	pop	r28
   14ee6:	1f 91       	pop	r17
   14ee8:	0f 91       	pop	r16
   14eea:	ff 90       	pop	r15
   14eec:	ef 90       	pop	r14
   14eee:	df 90       	pop	r13
   14ef0:	08 95       	ret

00014ef2 <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   14ef2:	df 92       	push	r13
   14ef4:	ef 92       	push	r14
   14ef6:	ff 92       	push	r15
   14ef8:	0f 93       	push	r16
   14efa:	1f 93       	push	r17
   14efc:	cf 93       	push	r28
   14efe:	df 93       	push	r29
   14f00:	06 2f       	mov	r16, r22
   14f02:	d4 2e       	mov	r13, r20
   14f04:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   14f06:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
   14f0a:	8d 2d       	mov	r24, r13
   14f0c:	91 2f       	mov	r25, r17
   14f0e:	fc 01       	movw	r30, r24
   14f10:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   14f12:	44 e1       	ldi	r20, 0x14	; 20
   14f14:	e4 2e       	mov	r14, r20
   14f16:	f1 2c       	mov	r15, r1
   14f18:	e0 1a       	sub	r14, r16
   14f1a:	f1 08       	sbc	r15, r1
   14f1c:	04 c0       	rjmp	.+8      	; 0x14f26 <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   14f1e:	82 2f       	mov	r24, r18
   14f20:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
		__string++;
   14f24:	21 96       	adiw	r28, 0x01	; 1
   14f26:	9e 01       	movw	r18, r28
   14f28:	2d 19       	sub	r18, r13
   14f2a:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   14f2c:	fe 01       	movw	r30, r28
   14f2e:	24 91       	lpm	r18, Z+
   14f30:	22 23       	and	r18, r18
   14f32:	21 f0       	breq	.+8      	; 0x14f3c <lcd_printf+0x4a>
   14f34:	90 e0       	ldi	r25, 0x00	; 0
   14f36:	e8 16       	cp	r14, r24
   14f38:	f9 06       	cpc	r15, r25
   14f3a:	8c f7       	brge	.-30     	; 0x14f1e <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   14f3c:	df 91       	pop	r29
   14f3e:	cf 91       	pop	r28
   14f40:	1f 91       	pop	r17
   14f42:	0f 91       	pop	r16
   14f44:	ff 90       	pop	r15
   14f46:	ef 90       	pop	r14
   14f48:	df 90       	pop	r13
   14f4a:	08 95       	ret

00014f4c <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   14f4c:	81 e0       	ldi	r24, 0x01	; 1
   14f4e:	61 e0       	ldi	r22, 0x01	; 1
   14f50:	44 e0       	ldi	r20, 0x04	; 4
   14f52:	54 e2       	ldi	r21, 0x24	; 36
   14f54:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   14f58:	82 e0       	ldi	r24, 0x02	; 2
   14f5a:	61 e0       	ldi	r22, 0x01	; 1
   14f5c:	4f ee       	ldi	r20, 0xEF	; 239
   14f5e:	53 e2       	ldi	r21, 0x23	; 35
   14f60:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   14f64:	83 e0       	ldi	r24, 0x03	; 3
   14f66:	61 e0       	ldi	r22, 0x01	; 1
   14f68:	4a ed       	ldi	r20, 0xDA	; 218
   14f6a:	53 e2       	ldi	r21, 0x23	; 35
   14f6c:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   14f70:	84 e0       	ldi	r24, 0x04	; 4
   14f72:	61 e0       	ldi	r22, 0x01	; 1
   14f74:	45 ec       	ldi	r20, 0xC5	; 197
   14f76:	53 e2       	ldi	r21, 0x23	; 35
   14f78:	0e 94 79 a7 	call	0x14ef2	; 0x14ef2 <lcd_printf>
}
   14f7c:	08 95       	ret

00014f7e <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   14f7e:	1f 93       	push	r17
   14f80:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   14f82:	0e 94 31 a7 	call	0x14e62	; 0x14e62 <lcd_xy>
	_lcd(__chr);
   14f86:	81 2f       	mov	r24, r17
   14f88:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
}
   14f8c:	1f 91       	pop	r17
   14f8e:	08 95       	ret

00014f90 <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   14f90:	0f 93       	push	r16
   14f92:	1f 93       	push	r17
   14f94:	cf 93       	push	r28
   14f96:	df 93       	push	r29
   14f98:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   14f9a:	88 30       	cpi	r24, 0x08	; 8
   14f9c:	90 f4       	brcc	.+36     	; 0x14fc2 <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   14f9e:	88 0f       	add	r24, r24
   14fa0:	88 0f       	add	r24, r24
   14fa2:	88 0f       	add	r24, r24
   14fa4:	80 5c       	subi	r24, 0xC0	; 192
   14fa6:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
   14faa:	c0 e0       	ldi	r28, 0x00	; 0
   14fac:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   14fae:	f8 01       	movw	r30, r16
   14fb0:	ec 0f       	add	r30, r28
   14fb2:	fd 1f       	adc	r31, r29
   14fb4:	80 81       	ld	r24, Z
   14fb6:	0e 94 0b a7 	call	0x14e16	; 0x14e16 <_lcd>
   14fba:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   14fbc:	c8 30       	cpi	r28, 0x08	; 8
   14fbe:	d1 05       	cpc	r29, r1
   14fc0:	b1 f7       	brne	.-20     	; 0x14fae <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   14fc2:	df 91       	pop	r29
   14fc4:	cf 91       	pop	r28
   14fc6:	1f 91       	pop	r17
   14fc8:	0f 91       	pop	r16
   14fca:	08 95       	ret

00014fcc <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   14fcc:	cf 93       	push	r28
   14fce:	df 93       	push	r29
   14fd0:	20 e0       	ldi	r18, 0x00	; 0
   14fd2:	04 c0       	rjmp	.+8      	; 0x14fdc <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   14fd4:	c8 0f       	add	r28, r24
   14fd6:	d9 1f       	adc	r29, r25
   14fd8:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   14fda:	2f 5f       	subi	r18, 0xFF	; 255
   14fdc:	c2 2f       	mov	r28, r18
   14fde:	d0 e0       	ldi	r29, 0x00	; 0
   14fe0:	fc 01       	movw	r30, r24
   14fe2:	01 90       	ld	r0, Z+
   14fe4:	00 20       	and	r0, r0
   14fe6:	e9 f7       	brne	.-6      	; 0x14fe2 <ClearMem+0x16>
   14fe8:	31 97       	sbiw	r30, 0x01	; 1
   14fea:	e8 1b       	sub	r30, r24
   14fec:	f9 0b       	sbc	r31, r25
   14fee:	ce 17       	cp	r28, r30
   14ff0:	df 07       	cpc	r29, r31
   14ff2:	80 f3       	brcs	.-32     	; 0x14fd4 <ClearMem+0x8>
          string[i]=0;
	 }     
}
   14ff4:	df 91       	pop	r29
   14ff6:	cf 91       	pop	r28
   14ff8:	08 95       	ret

00014ffa <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   14ffa:	df 93       	push	r29
   14ffc:	cf 93       	push	r28
   14ffe:	00 d0       	rcall	.+0      	; 0x15000 <_key_hit+0x6>
   15000:	00 d0       	rcall	.+0      	; 0x15002 <_key_hit+0x8>
   15002:	cd b7       	in	r28, 0x3d	; 61
   15004:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15006:	8f ee       	ldi	r24, 0xEF	; 239
   15008:	89 83       	std	Y+1, r24	; 0x01
   1500a:	8f ed       	ldi	r24, 0xDF	; 223
   1500c:	8a 83       	std	Y+2, r24	; 0x02
   1500e:	8f eb       	ldi	r24, 0xBF	; 191
   15010:	8b 83       	std	Y+3, r24	; 0x03
   15012:	8f e7       	ldi	r24, 0x7F	; 127
   15014:	8c 83       	std	Y+4, r24	; 0x04
   15016:	de 01       	movw	r26, r28
   15018:	11 96       	adiw	r26, 0x01	; 1
   1501a:	2a ef       	ldi	r18, 0xFA	; 250
   1501c:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   1501e:	ae 01       	movw	r20, r28
   15020:	4b 5f       	subi	r20, 0xFB	; 251
   15022:	5f 4f       	sbci	r21, 0xFF	; 255
   15024:	c9 01       	movw	r24, r18
   15026:	01 97       	sbiw	r24, 0x01	; 1
   15028:	f1 f7       	brne	.-4      	; 0x15026 <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   1502a:	8c 91       	ld	r24, X
   1502c:	80 93 62 00 	sts	0x0062, r24
   15030:	f9 01       	movw	r30, r18
   15032:	31 97       	sbiw	r30, 0x01	; 1
   15034:	f1 f7       	brne	.-4      	; 0x15032 <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15036:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15038:	98 17       	cp	r25, r24
   1503a:	21 f4       	brne	.+8      	; 0x15044 <_key_hit+0x4a>
		    break;
   1503c:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   1503e:	a4 17       	cp	r26, r20
   15040:	b5 07       	cpc	r27, r21
   15042:	81 f7       	brne	.-32     	; 0x15024 <_key_hit+0x2a>
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) 
		    break;
	}
	return keyhit;
}
   15044:	89 2f       	mov	r24, r25
   15046:	0f 90       	pop	r0
   15048:	0f 90       	pop	r0
   1504a:	0f 90       	pop	r0
   1504c:	0f 90       	pop	r0
   1504e:	cf 91       	pop	r28
   15050:	df 91       	pop	r29
   15052:	08 95       	ret

00015054 <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   15054:	8e 3e       	cpi	r24, 0xEE	; 238
   15056:	f9 f0       	breq	.+62     	; 0x15096 <_key_crr+0x42>
   15058:	8e 3d       	cpi	r24, 0xDE	; 222
   1505a:	e9 f0       	breq	.+58     	; 0x15096 <_key_crr+0x42>
   1505c:	8e 3b       	cpi	r24, 0xBE	; 190
   1505e:	d9 f0       	breq	.+54     	; 0x15096 <_key_crr+0x42>
   15060:	8d 3e       	cpi	r24, 0xED	; 237
   15062:	c9 f0       	breq	.+50     	; 0x15096 <_key_crr+0x42>
   15064:	8d 3d       	cpi	r24, 0xDD	; 221
   15066:	b9 f0       	breq	.+46     	; 0x15096 <_key_crr+0x42>
   15068:	8d 3b       	cpi	r24, 0xBD	; 189
   1506a:	a9 f0       	breq	.+42     	; 0x15096 <_key_crr+0x42>
   1506c:	8b 3e       	cpi	r24, 0xEB	; 235
   1506e:	99 f0       	breq	.+38     	; 0x15096 <_key_crr+0x42>
   15070:	8b 3d       	cpi	r24, 0xDB	; 219
   15072:	89 f0       	breq	.+34     	; 0x15096 <_key_crr+0x42>
   15074:	8b 3b       	cpi	r24, 0xBB	; 187
   15076:	79 f0       	breq	.+30     	; 0x15096 <_key_crr+0x42>
   15078:	87 3d       	cpi	r24, 0xD7	; 215
   1507a:	69 f0       	breq	.+26     	; 0x15096 <_key_crr+0x42>
   1507c:	87 3e       	cpi	r24, 0xE7	; 231
   1507e:	59 f0       	breq	.+22     	; 0x15096 <_key_crr+0x42>
   15080:	87 3b       	cpi	r24, 0xB7	; 183
   15082:	49 f0       	breq	.+18     	; 0x15096 <_key_crr+0x42>
   15084:	8e 37       	cpi	r24, 0x7E	; 126
   15086:	39 f0       	breq	.+14     	; 0x15096 <_key_crr+0x42>
   15088:	8d 37       	cpi	r24, 0x7D	; 125
   1508a:	29 f0       	breq	.+10     	; 0x15096 <_key_crr+0x42>
   1508c:	8b 37       	cpi	r24, 0x7B	; 123
   1508e:	19 f0       	breq	.+6      	; 0x15096 <_key_crr+0x42>
   15090:	87 37       	cpi	r24, 0x77	; 119
   15092:	09 f0       	breq	.+2      	; 0x15096 <_key_crr+0x42>
   15094:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   15096:	08 95       	ret

00015098 <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   15098:	8e 3b       	cpi	r24, 0xBE	; 190
   1509a:	91 f1       	breq	.+100    	; 0x15100 <_key_btn+0x68>
   1509c:	8f 3b       	cpi	r24, 0xBF	; 191
   1509e:	a8 f4       	brcc	.+42     	; 0x150ca <_key_btn+0x32>
   150a0:	8e 37       	cpi	r24, 0x7E	; 126
   150a2:	09 f4       	brne	.+2      	; 0x150a6 <_key_btn+0xe>
   150a4:	41 c0       	rjmp	.+130    	; 0x15128 <_key_btn+0x90>
   150a6:	8f 37       	cpi	r24, 0x7F	; 127
   150a8:	48 f4       	brcc	.+18     	; 0x150bc <_key_btn+0x24>
   150aa:	8b 37       	cpi	r24, 0x7B	; 123
   150ac:	09 f4       	brne	.+2      	; 0x150b0 <_key_btn+0x18>
   150ae:	40 c0       	rjmp	.+128    	; 0x15130 <_key_btn+0x98>
   150b0:	8d 37       	cpi	r24, 0x7D	; 125
   150b2:	e1 f1       	breq	.+120    	; 0x1512c <_key_btn+0x94>
   150b4:	87 37       	cpi	r24, 0x77	; 119
   150b6:	09 f0       	breq	.+2      	; 0x150ba <_key_btn+0x22>
   150b8:	3f c0       	rjmp	.+126    	; 0x15138 <_key_btn+0xa0>
   150ba:	3c c0       	rjmp	.+120    	; 0x15134 <_key_btn+0x9c>
   150bc:	8b 3b       	cpi	r24, 0xBB	; 187
   150be:	61 f1       	breq	.+88     	; 0x15118 <_key_btn+0x80>
   150c0:	8d 3b       	cpi	r24, 0xBD	; 189
   150c2:	21 f1       	breq	.+72     	; 0x1510c <_key_btn+0x74>
   150c4:	87 3b       	cpi	r24, 0xB7	; 183
   150c6:	c1 f5       	brne	.+112    	; 0x15138 <_key_btn+0xa0>
   150c8:	2d c0       	rjmp	.+90     	; 0x15124 <_key_btn+0x8c>
   150ca:	8e 3d       	cpi	r24, 0xDE	; 222
   150cc:	a9 f0       	breq	.+42     	; 0x150f8 <_key_btn+0x60>
   150ce:	8f 3d       	cpi	r24, 0xDF	; 223
   150d0:	38 f4       	brcc	.+14     	; 0x150e0 <_key_btn+0x48>
   150d2:	8b 3d       	cpi	r24, 0xDB	; 219
   150d4:	f9 f0       	breq	.+62     	; 0x15114 <_key_btn+0x7c>
   150d6:	8d 3d       	cpi	r24, 0xDD	; 221
   150d8:	b9 f0       	breq	.+46     	; 0x15108 <_key_btn+0x70>
   150da:	87 3d       	cpi	r24, 0xD7	; 215
   150dc:	69 f5       	brne	.+90     	; 0x15138 <_key_btn+0xa0>
   150de:	1e c0       	rjmp	.+60     	; 0x1511c <_key_btn+0x84>
   150e0:	8b 3e       	cpi	r24, 0xEB	; 235
   150e2:	b1 f0       	breq	.+44     	; 0x15110 <_key_btn+0x78>
   150e4:	8c 3e       	cpi	r24, 0xEC	; 236
   150e6:	18 f4       	brcc	.+6      	; 0x150ee <_key_btn+0x56>
   150e8:	87 3e       	cpi	r24, 0xE7	; 231
   150ea:	31 f5       	brne	.+76     	; 0x15138 <_key_btn+0xa0>
   150ec:	19 c0       	rjmp	.+50     	; 0x15120 <_key_btn+0x88>
   150ee:	8d 3e       	cpi	r24, 0xED	; 237
   150f0:	49 f0       	breq	.+18     	; 0x15104 <_key_btn+0x6c>
   150f2:	8e 3e       	cpi	r24, 0xEE	; 238
   150f4:	09 f5       	brne	.+66     	; 0x15138 <_key_btn+0xa0>
   150f6:	02 c0       	rjmp	.+4      	; 0x150fc <_key_btn+0x64>
   150f8:	82 e3       	ldi	r24, 0x32	; 50
   150fa:	08 95       	ret
   150fc:	81 e3       	ldi	r24, 0x31	; 49
   150fe:	08 95       	ret
   15100:	83 e3       	ldi	r24, 0x33	; 51
   15102:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   15104:	84 e3       	ldi	r24, 0x34	; 52
   15106:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   15108:	85 e3       	ldi	r24, 0x35	; 53
   1510a:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   1510c:	86 e3       	ldi	r24, 0x36	; 54
   1510e:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   15110:	87 e3       	ldi	r24, 0x37	; 55
   15112:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   15114:	88 e3       	ldi	r24, 0x38	; 56
   15116:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   15118:	89 e3       	ldi	r24, 0x39	; 57
   1511a:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   1511c:	80 e3       	ldi	r24, 0x30	; 48
   1511e:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   15120:	8a e2       	ldi	r24, 0x2A	; 42
   15122:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   15124:	83 e2       	ldi	r24, 0x23	; 35
   15126:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   15128:	81 ef       	ldi	r24, 0xF1	; 241
   1512a:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   1512c:	82 ef       	ldi	r24, 0xF2	; 242
   1512e:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   15130:	83 ef       	ldi	r24, 0xF3	; 243
   15132:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   15134:	84 ef       	ldi	r24, 0xF4	; 244
   15136:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   15138:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   1513a:	08 95       	ret

0001513c <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   1513c:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   1513e:	6d 3d       	cpi	r22, 0xDD	; 221
   15140:	11 f1       	breq	.+68     	; 0x15186 <_table_alphanum+0x4a>
   15142:	6e 3d       	cpi	r22, 0xDE	; 222
   15144:	60 f4       	brcc	.+24     	; 0x1515e <_table_alphanum+0x22>
   15146:	6d 3b       	cpi	r22, 0xBD	; 189
   15148:	01 f1       	breq	.+64     	; 0x1518a <_table_alphanum+0x4e>
   1514a:	6e 3b       	cpi	r22, 0xBE	; 190
   1514c:	18 f4       	brcc	.+6      	; 0x15154 <_table_alphanum+0x18>
   1514e:	6b 3b       	cpi	r22, 0xBB	; 187
   15150:	21 f5       	brne	.+72     	; 0x1519a <_table_alphanum+0x5e>
   15152:	21 c0       	rjmp	.+66     	; 0x15196 <_table_alphanum+0x5a>
   15154:	6e 3b       	cpi	r22, 0xBE	; 190
   15156:	99 f0       	breq	.+38     	; 0x1517e <_table_alphanum+0x42>
   15158:	6b 3d       	cpi	r22, 0xDB	; 219
   1515a:	f9 f4       	brne	.+62     	; 0x1519a <_table_alphanum+0x5e>
   1515c:	1a c0       	rjmp	.+52     	; 0x15192 <_table_alphanum+0x56>
   1515e:	6b 3e       	cpi	r22, 0xEB	; 235
   15160:	b1 f0       	breq	.+44     	; 0x1518e <_table_alphanum+0x52>
   15162:	6c 3e       	cpi	r22, 0xEC	; 236
   15164:	18 f4       	brcc	.+6      	; 0x1516c <_table_alphanum+0x30>
   15166:	6e 3d       	cpi	r22, 0xDE	; 222
   15168:	c1 f4       	brne	.+48     	; 0x1519a <_table_alphanum+0x5e>
   1516a:	05 c0       	rjmp	.+10     	; 0x15176 <_table_alphanum+0x3a>
   1516c:	6d 3e       	cpi	r22, 0xED	; 237
   1516e:	49 f0       	breq	.+18     	; 0x15182 <_table_alphanum+0x46>
   15170:	6e 3e       	cpi	r22, 0xEE	; 238
   15172:	99 f4       	brne	.+38     	; 0x1519a <_table_alphanum+0x5e>
   15174:	02 c0       	rjmp	.+4      	; 0x1517a <_table_alphanum+0x3e>
   15176:	82 e0       	ldi	r24, 0x02	; 2
   15178:	11 c0       	rjmp	.+34     	; 0x1519c <_table_alphanum+0x60>
   1517a:	81 e0       	ldi	r24, 0x01	; 1
   1517c:	0f c0       	rjmp	.+30     	; 0x1519c <_table_alphanum+0x60>
   1517e:	83 e0       	ldi	r24, 0x03	; 3
   15180:	0d c0       	rjmp	.+26     	; 0x1519c <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   15182:	84 e0       	ldi	r24, 0x04	; 4
   15184:	0b c0       	rjmp	.+22     	; 0x1519c <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   15186:	85 e0       	ldi	r24, 0x05	; 5
   15188:	09 c0       	rjmp	.+18     	; 0x1519c <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   1518a:	86 e0       	ldi	r24, 0x06	; 6
   1518c:	07 c0       	rjmp	.+14     	; 0x1519c <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   1518e:	87 e0       	ldi	r24, 0x07	; 7
   15190:	05 c0       	rjmp	.+10     	; 0x1519c <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   15192:	88 e0       	ldi	r24, 0x08	; 8
   15194:	03 c0       	rjmp	.+6      	; 0x1519c <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   15196:	89 e0       	ldi	r24, 0x09	; 9
   15198:	01 c0       	rjmp	.+2      	; 0x1519c <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   1519a:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   1519c:	28 2f       	mov	r18, r24
   1519e:	30 e0       	ldi	r19, 0x00	; 0
   151a0:	f9 01       	movw	r30, r18
   151a2:	ef 56       	subi	r30, 0x6F	; 111
   151a4:	fb 4d       	sbci	r31, 0xDB	; 219
   151a6:	e4 91       	lpm	r30, Z+
   151a8:	e4 17       	cp	r30, r20
   151aa:	10 f4       	brcc	.+4      	; 0x151b0 <_table_alphanum+0x74>
   151ac:	80 e0       	ldi	r24, 0x00	; 0
   151ae:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   151b0:	ec e3       	ldi	r30, 0x3C	; 60
   151b2:	9e 9f       	mul	r25, r30
   151b4:	f0 01       	movw	r30, r0
   151b6:	11 24       	eor	r1, r1
   151b8:	e4 0f       	add	r30, r20
   151ba:	f1 1d       	adc	r31, r1
   151bc:	c9 01       	movw	r24, r18
   151be:	88 0f       	add	r24, r24
   151c0:	99 1f       	adc	r25, r25
   151c2:	82 0f       	add	r24, r18
   151c4:	93 1f       	adc	r25, r19
   151c6:	88 0f       	add	r24, r24
   151c8:	99 1f       	adc	r25, r25
   151ca:	e8 0f       	add	r30, r24
   151cc:	f9 1f       	adc	r31, r25
   151ce:	e7 5e       	subi	r30, 0xE7	; 231
   151d0:	fb 4d       	sbci	r31, 0xDB	; 219
   151d2:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   151d4:	08 95       	ret

000151d6 <_key_scan>:





char _key_scan(char __select){
   151d6:	8f 92       	push	r8
   151d8:	9f 92       	push	r9
   151da:	af 92       	push	r10
   151dc:	bf 92       	push	r11
   151de:	cf 92       	push	r12
   151e0:	df 92       	push	r13
   151e2:	ef 92       	push	r14
   151e4:	ff 92       	push	r15
   151e6:	0f 93       	push	r16
   151e8:	1f 93       	push	r17
   151ea:	df 93       	push	r29
   151ec:	cf 93       	push	r28
   151ee:	00 d0       	rcall	.+0      	; 0x151f0 <_key_scan+0x1a>
   151f0:	00 d0       	rcall	.+0      	; 0x151f2 <_key_scan+0x1c>
   151f2:	cd b7       	in	r28, 0x3d	; 61
   151f4:	de b7       	in	r29, 0x3e	; 62
   151f6:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   151f8:	81 50       	subi	r24, 0x01	; 1
   151fa:	82 30       	cpi	r24, 0x02	; 2
   151fc:	08 f0       	brcs	.+2      	; 0x15200 <_key_scan+0x2a>
   151fe:	aa c0       	rjmp	.+340    	; 0x15354 <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15200:	8f ee       	ldi	r24, 0xEF	; 239
   15202:	89 83       	std	Y+1, r24	; 0x01
   15204:	8f ed       	ldi	r24, 0xDF	; 223
   15206:	8a 83       	std	Y+2, r24	; 0x02
   15208:	8f eb       	ldi	r24, 0xBF	; 191
   1520a:	8b 83       	std	Y+3, r24	; 0x03
   1520c:	8f e7       	ldi	r24, 0x7F	; 127
   1520e:	8c 83       	std	Y+4, r24	; 0x04
   15210:	de 01       	movw	r26, r28
   15212:	11 96       	adiw	r26, 0x01	; 1
   15214:	2a ef       	ldi	r18, 0xFA	; 250
   15216:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15218:	ae 01       	movw	r20, r28
   1521a:	4b 5f       	subi	r20, 0xFB	; 251
   1521c:	5f 4f       	sbci	r21, 0xFF	; 255
   1521e:	c9 01       	movw	r24, r18
   15220:	01 97       	sbiw	r24, 0x01	; 1
   15222:	f1 f7       	brne	.-4      	; 0x15220 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15224:	8c 91       	ld	r24, X
   15226:	80 93 62 00 	sts	0x0062, r24
   1522a:	f9 01       	movw	r30, r18
   1522c:	31 97       	sbiw	r30, 0x01	; 1
   1522e:	f1 f7       	brne	.-4      	; 0x1522c <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15230:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15232:	98 17       	cp	r25, r24
   15234:	21 f4       	brne	.+8      	; 0x1523e <_key_scan+0x68>
   15236:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15238:	a4 17       	cp	r26, r20
   1523a:	b5 07       	cpc	r27, r21
   1523c:	81 f7       	brne	.-32     	; 0x1521e <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   1523e:	89 2f       	mov	r24, r25
   15240:	0e 94 2a a8 	call	0x15054	; 0x15054 <_key_crr>
   15244:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   15246:	88 23       	and	r24, r24
   15248:	09 f4       	brne	.+2      	; 0x1524c <_key_scan+0x76>
   1524a:	85 c0       	rjmp	.+266    	; 0x15356 <_key_scan+0x180>
			_LIGHT_SET;
   1524c:	91 e0       	ldi	r25, 0x01	; 1
   1524e:	90 93 b7 02 	sts	0x02B7, r25
   15252:	10 92 b8 02 	sts	0x02B8, r1
   15256:	80 91 65 00 	lds	r24, 0x0065
   1525a:	8d 7f       	andi	r24, 0xFD	; 253
   1525c:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   15260:	80 91 c2 02 	lds	r24, 0x02C2
   15264:	88 23       	and	r24, r24
   15266:	31 f0       	breq	.+12     	; 0x15274 <_key_scan+0x9e>
				_SEC_ON;
   15268:	90 93 bd 02 	sts	0x02BD, r25
   1526c:	10 92 bf 02 	sts	0x02BF, r1
   15270:	10 92 be 02 	sts	0x02BE, r1

			if(_IS1st){
   15274:	80 91 b9 02 	lds	r24, 0x02B9
   15278:	88 23       	and	r24, r24
   1527a:	71 f4       	brne	.+28     	; 0x15298 <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   1527c:	27 3e       	cpi	r18, 0xE7	; 231
   1527e:	11 f0       	breq	.+4      	; 0x15284 <_key_scan+0xae>
   15280:	27 3b       	cpi	r18, 0xB7	; 183
   15282:	31 f4       	brne	.+12     	; 0x15290 <_key_scan+0xba>
					if(__lock_num)
   15284:	80 91 b6 02 	lds	r24, 0x02B6
   15288:	88 23       	and	r24, r24
   1528a:	11 f0       	breq	.+4      	; 0x15290 <_key_scan+0xba>
						__lock_num = 0;
   1528c:	10 92 b6 02 	sts	0x02B6, r1
				_PAD_2nd;
   15290:	81 e0       	ldi	r24, 0x01	; 1
   15292:	80 93 b9 02 	sts	0x02B9, r24
   15296:	59 c0       	rjmp	.+178    	; 0x1534a <_key_scan+0x174>
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   15298:	81 30       	cpi	r24, 0x01	; 1
   1529a:	09 f0       	breq	.+2      	; 0x1529e <_key_scan+0xc8>
   1529c:	5c c0       	rjmp	.+184    	; 0x15356 <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   1529e:	12 30       	cpi	r17, 0x02	; 2
   152a0:	21 f5       	brne	.+72     	; 0x152ea <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   152a2:	27 3d       	cpi	r18, 0xD7	; 215
   152a4:	91 f0       	breq	.+36     	; 0x152ca <_key_scan+0xf4>
   152a6:	2e 3e       	cpi	r18, 0xEE	; 238
   152a8:	81 f0       	breq	.+32     	; 0x152ca <_key_scan+0xf4>
   152aa:	2e 3d       	cpi	r18, 0xDE	; 222
   152ac:	71 f0       	breq	.+28     	; 0x152ca <_key_scan+0xf4>
   152ae:	2e 3b       	cpi	r18, 0xBE	; 190
   152b0:	61 f0       	breq	.+24     	; 0x152ca <_key_scan+0xf4>
   152b2:	2d 3e       	cpi	r18, 0xED	; 237
   152b4:	51 f0       	breq	.+20     	; 0x152ca <_key_scan+0xf4>
   152b6:	2d 3d       	cpi	r18, 0xDD	; 221
   152b8:	41 f0       	breq	.+16     	; 0x152ca <_key_scan+0xf4>
   152ba:	2d 3b       	cpi	r18, 0xBD	; 189
   152bc:	31 f0       	breq	.+12     	; 0x152ca <_key_scan+0xf4>
   152be:	2b 3e       	cpi	r18, 0xEB	; 235
   152c0:	21 f0       	breq	.+8      	; 0x152ca <_key_scan+0xf4>
   152c2:	2b 3d       	cpi	r18, 0xDB	; 219
   152c4:	11 f0       	breq	.+4      	; 0x152ca <_key_scan+0xf4>
   152c6:	2b 3b       	cpi	r18, 0xBB	; 187
   152c8:	81 f4       	brne	.+32     	; 0x152ea <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   152ca:	80 91 b6 02 	lds	r24, 0x02B6
   152ce:	88 23       	and	r24, r24
   152d0:	49 f0       	breq	.+18     	; 0x152e4 <_key_scan+0x10e>
							_SHIFT_SET;
   152d2:	81 e0       	ldi	r24, 0x01	; 1
   152d4:	80 93 ba 02 	sts	0x02BA, r24
   152d8:	10 92 bb 02 	sts	0x02BB, r1
							CURSOR_HIDE;
   152dc:	8c e0       	ldi	r24, 0x0C	; 12
   152de:	0e 94 9e a6 	call	0x14d3c	; 0x14d3c <lcd_command>
   152e2:	03 c0       	rjmp	.+6      	; 0x152ea <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   152e4:	81 e0       	ldi	r24, 0x01	; 1
   152e6:	80 93 b6 02 	sts	0x02B6, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   152ea:	ff ee       	ldi	r31, 0xEF	; 239
   152ec:	8f 2e       	mov	r8, r31
   152ee:	ef ed       	ldi	r30, 0xDF	; 223
   152f0:	9e 2e       	mov	r9, r30
   152f2:	7f eb       	ldi	r23, 0xBF	; 191
   152f4:	a7 2e       	mov	r10, r23
   152f6:	6f e7       	ldi	r22, 0x7F	; 127
   152f8:	b6 2e       	mov	r11, r22
   152fa:	6e 01       	movw	r12, r28
   152fc:	08 94       	sec
   152fe:	c1 1c       	adc	r12, r1
   15300:	d1 1c       	adc	r13, r1
   15302:	0a ef       	ldi	r16, 0xFA	; 250
   15304:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   15306:	55 e0       	ldi	r21, 0x05	; 5
   15308:	e5 2e       	mov	r14, r21
   1530a:	f1 2c       	mov	r15, r1
   1530c:	ec 0e       	add	r14, r28
   1530e:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15310:	89 82       	std	Y+1, r8	; 0x01
   15312:	9a 82       	std	Y+2, r9	; 0x02
   15314:	ab 82       	std	Y+3, r10	; 0x03
   15316:	bc 82       	std	Y+4, r11	; 0x04
   15318:	d6 01       	movw	r26, r12
   1531a:	c8 01       	movw	r24, r16
   1531c:	01 97       	sbiw	r24, 0x01	; 1
   1531e:	f1 f7       	brne	.-4      	; 0x1531c <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15320:	8c 91       	ld	r24, X
   15322:	80 93 62 00 	sts	0x0062, r24
   15326:	f8 01       	movw	r30, r16
   15328:	31 97       	sbiw	r30, 0x01	; 1
   1532a:	f1 f7       	brne	.-4      	; 0x15328 <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   1532c:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   1532e:	98 17       	cp	r25, r24
   15330:	21 f4       	brne	.+8      	; 0x1533a <_key_scan+0x164>
   15332:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15334:	ae 15       	cp	r26, r14
   15336:	bf 05       	cpc	r27, r15
   15338:	81 f7       	brne	.-32     	; 0x1531a <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   1533a:	89 2f       	mov	r24, r25
   1533c:	0e 94 2a a8 	call	0x15054	; 0x15054 <_key_crr>
   15340:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   15342:	88 23       	and	r24, r24
   15344:	29 f7       	brne	.-54     	; 0x15310 <_key_scan+0x13a>
				_PAD_1st;
   15346:	10 92 b9 02 	sts	0x02B9, r1
   1534a:	82 ee       	ldi	r24, 0xE2	; 226
   1534c:	94 e0       	ldi	r25, 0x04	; 4
   1534e:	01 97       	sbiw	r24, 0x01	; 1
   15350:	f1 f7       	brne	.-4      	; 0x1534e <_key_scan+0x178>
   15352:	03 c0       	rjmp	.+6      	; 0x1535a <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   15354:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   15356:	10 92 b9 02 	sts	0x02B9, r1
	return __key;
}
   1535a:	82 2f       	mov	r24, r18
   1535c:	0f 90       	pop	r0
   1535e:	0f 90       	pop	r0
   15360:	0f 90       	pop	r0
   15362:	0f 90       	pop	r0
   15364:	cf 91       	pop	r28
   15366:	df 91       	pop	r29
   15368:	1f 91       	pop	r17
   1536a:	0f 91       	pop	r16
   1536c:	ff 90       	pop	r15
   1536e:	ef 90       	pop	r14
   15370:	df 90       	pop	r13
   15372:	cf 90       	pop	r12
   15374:	bf 90       	pop	r11
   15376:	af 90       	pop	r10
   15378:	9f 90       	pop	r9
   1537a:	8f 90       	pop	r8
   1537c:	08 95       	ret

0001537e <spi_init>:
#include <util/delay.h>
#include <compat/deprecated.h>

#include "SPI.h"
void spi_init(unsigned char mode, unsigned char interrupt){
	if(mode){
   1537e:	88 23       	and	r24, r24
   15380:	41 f0       	breq	.+16     	; 0x15392 <spi_init+0x14>
		SPI_DDR = (1 << SPI_MOSI) | (1 << SPI_SCK);
   15382:	86 e0       	ldi	r24, 0x06	; 6
   15384:	87 bb       	out	0x17, r24	; 23
		if(interrupt)
   15386:	66 23       	and	r22, r22
   15388:	11 f0       	breq	.+4      	; 0x1538e <spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   1538a:	82 ed       	ldi	r24, 0xD2	; 210
   1538c:	09 c0       	rjmp	.+18     	; 0x153a0 <spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   1538e:	82 e5       	ldi	r24, 0x52	; 82
   15390:	07 c0       	rjmp	.+14     	; 0x153a0 <spi_init+0x22>
	}
	else{
		SPI_DDR = (1 << SPI_MISO);
   15392:	88 e0       	ldi	r24, 0x08	; 8
   15394:	87 bb       	out	0x17, r24	; 23
		if(interrupt)
   15396:	66 23       	and	r22, r22
   15398:	11 f0       	breq	.+4      	; 0x1539e <spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   1539a:	80 ec       	ldi	r24, 0xC0	; 192
   1539c:	01 c0       	rjmp	.+2      	; 0x153a0 <spi_init+0x22>
		else
			SPCR = (1 << SPE);
   1539e:	80 e4       	ldi	r24, 0x40	; 64
   153a0:	8d b9       	out	0x0d, r24	; 13
   153a2:	08 95       	ret

000153a4 <spi_enable>:
	}
}

void spi_enable(unsigned char select){
	if(select == SPI_NONE){
   153a4:	88 23       	and	r24, r24
   153a6:	19 f4       	brne	.+6      	; 0x153ae <spi_enable+0xa>
		sbi(SLAVE_PORT, SLAVE_PIN);
   153a8:	db 9a       	sbi	0x1b, 3	; 27
		sbi(MMC_PORT, MMC_PIN);
   153aa:	1b 9a       	sbi	0x03, 3	; 3
   153ac:	08 95       	ret
	}
	if(select == SPI_SLAVE){
   153ae:	81 30       	cpi	r24, 0x01	; 1
   153b0:	39 f4       	brne	.+14     	; 0x153c0 <spi_enable+0x1c>
		sbi(MMC_PORT, MMC_PIN);
   153b2:	1b 9a       	sbi	0x03, 3	; 3
   153b4:	82 ee       	ldi	r24, 0xE2	; 226
   153b6:	94 e0       	ldi	r25, 0x04	; 4
   153b8:	01 97       	sbiw	r24, 0x01	; 1
   153ba:	f1 f7       	brne	.-4      	; 0x153b8 <spi_enable+0x14>
		_delay_ms(5);
		cbi(SLAVE_PORT, SLAVE_PIN);
   153bc:	db 98       	cbi	0x1b, 3	; 27
   153be:	08 95       	ret
	}
	if(select == SPI_MMC){
   153c0:	82 30       	cpi	r24, 0x02	; 2
   153c2:	31 f4       	brne	.+12     	; 0x153d0 <spi_enable+0x2c>
		sbi(SLAVE_PORT, SLAVE_PIN);
   153c4:	db 9a       	sbi	0x1b, 3	; 27
   153c6:	82 ee       	ldi	r24, 0xE2	; 226
   153c8:	94 e0       	ldi	r25, 0x04	; 4
   153ca:	01 97       	sbiw	r24, 0x01	; 1
   153cc:	f1 f7       	brne	.-4      	; 0x153ca <spi_enable+0x26>
		_delay_ms(5);
		cbi(MMC_PORT, MMC_PIN);
   153ce:	1b 98       	cbi	0x03, 3	; 3
   153d0:	08 95       	ret

000153d2 <spi>:
	}
}

unsigned char spi(unsigned char data){
	SPDR = data;
   153d2:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   153d4:	77 9b       	sbis	0x0e, 7	; 14
   153d6:	fe cf       	rjmp	.-4      	; 0x153d4 <spi+0x2>
	return SPDR;
   153d8:	8f b1       	in	r24, 0x0f	; 15
}
   153da:	08 95       	ret

000153dc <write_SPI>:

void write_SPI(char dataspi){
     SPDR = dataspi;
   153dc:	8f b9       	out	0x0f, r24	; 15
     while ((SPSR&0x80)!=0x80);//wait for data transfer to be completed
   153de:	77 9b       	sbis	0x0e, 7	; 14
   153e0:	fe cf       	rjmp	.-4      	; 0x153de <write_SPI+0x2>
}
   153e2:	08 95       	ret

000153e4 <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   153e4:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   153e6:	22 23       	and	r18, r18
   153e8:	09 f4       	brne	.+2      	; 0x153ec <_rtc+0x8>
   153ea:	49 c0       	rjmp	.+146    	; 0x1547e <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   153ec:	84 ea       	ldi	r24, 0xA4	; 164
   153ee:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   153f2:	80 91 74 00 	lds	r24, 0x0074
   153f6:	87 ff       	sbrs	r24, 7
   153f8:	fc cf       	rjmp	.-8      	; 0x153f2 <_rtc+0xe>
		if(TW_STATUS != TW_START)
   153fa:	80 91 71 00 	lds	r24, 0x0071
   153fe:	88 7f       	andi	r24, 0xF8	; 248
   15400:	88 30       	cpi	r24, 0x08	; 8
   15402:	09 f0       	breq	.+2      	; 0x15406 <_rtc+0x22>
   15404:	af c0       	rjmp	.+350    	; 0x15564 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   15406:	80 ed       	ldi	r24, 0xD0	; 208
   15408:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   1540c:	84 e8       	ldi	r24, 0x84	; 132
   1540e:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   15412:	80 91 74 00 	lds	r24, 0x0074
   15416:	87 ff       	sbrs	r24, 7
   15418:	fc cf       	rjmp	.-8      	; 0x15412 <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   1541a:	80 91 71 00 	lds	r24, 0x0071
   1541e:	88 7f       	andi	r24, 0xF8	; 248
   15420:	88 31       	cpi	r24, 0x18	; 24
   15422:	09 f0       	breq	.+2      	; 0x15426 <_rtc+0x42>
   15424:	9f c0       	rjmp	.+318    	; 0x15564 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   15426:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   1542a:	84 e8       	ldi	r24, 0x84	; 132
   1542c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   15430:	80 91 74 00 	lds	r24, 0x0074
   15434:	87 ff       	sbrs	r24, 7
   15436:	fc cf       	rjmp	.-8      	; 0x15430 <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   15438:	80 91 71 00 	lds	r24, 0x0071
   1543c:	88 7f       	andi	r24, 0xF8	; 248
   1543e:	88 32       	cpi	r24, 0x28	; 40
   15440:	09 f0       	breq	.+2      	; 0x15444 <_rtc+0x60>
   15442:	90 c0       	rjmp	.+288    	; 0x15564 <_rtc+0x180>
   15444:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   15446:	94 e8       	ldi	r25, 0x84	; 132
   15448:	14 c0       	rjmp	.+40     	; 0x15472 <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   1544a:	fa 01       	movw	r30, r20
   1544c:	e8 0f       	add	r30, r24
   1544e:	f1 1d       	adc	r31, r1
   15450:	80 81       	ld	r24, Z
   15452:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   15456:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   1545a:	80 91 74 00 	lds	r24, 0x0074
   1545e:	87 ff       	sbrs	r24, 7
   15460:	fc cf       	rjmp	.-8      	; 0x1545a <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   15462:	80 91 71 00 	lds	r24, 0x0071
   15466:	88 7f       	andi	r24, 0xF8	; 248
   15468:	80 33       	cpi	r24, 0x30	; 48
   1546a:	09 f4       	brne	.+2      	; 0x1546e <_rtc+0x8a>
   1546c:	7b c0       	rjmp	.+246    	; 0x15564 <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   1546e:	21 50       	subi	r18, 0x01	; 1
   15470:	30 40       	sbci	r19, 0x00	; 0
   15472:	86 2f       	mov	r24, r22
   15474:	82 1b       	sub	r24, r18
   15476:	12 16       	cp	r1, r18
   15478:	13 06       	cpc	r1, r19
   1547a:	3c f3       	brlt	.-50     	; 0x1544a <_rtc+0x66>
   1547c:	6e c0       	rjmp	.+220    	; 0x1555a <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   1547e:	84 ea       	ldi	r24, 0xA4	; 164
   15480:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   15484:	80 91 74 00 	lds	r24, 0x0074
   15488:	87 ff       	sbrs	r24, 7
   1548a:	fc cf       	rjmp	.-8      	; 0x15484 <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   1548c:	80 91 71 00 	lds	r24, 0x0071
   15490:	88 7f       	andi	r24, 0xF8	; 248
   15492:	88 30       	cpi	r24, 0x08	; 8
   15494:	09 f0       	breq	.+2      	; 0x15498 <_rtc+0xb4>
   15496:	66 c0       	rjmp	.+204    	; 0x15564 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   15498:	80 ed       	ldi	r24, 0xD0	; 208
   1549a:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   1549e:	84 e8       	ldi	r24, 0x84	; 132
   154a0:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   154a4:	80 91 74 00 	lds	r24, 0x0074
   154a8:	87 ff       	sbrs	r24, 7
   154aa:	fc cf       	rjmp	.-8      	; 0x154a4 <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   154ac:	80 91 71 00 	lds	r24, 0x0071
   154b0:	88 7f       	andi	r24, 0xF8	; 248
   154b2:	88 31       	cpi	r24, 0x18	; 24
   154b4:	09 f0       	breq	.+2      	; 0x154b8 <_rtc+0xd4>
   154b6:	56 c0       	rjmp	.+172    	; 0x15564 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   154b8:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   154bc:	84 e8       	ldi	r24, 0x84	; 132
   154be:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   154c2:	80 91 74 00 	lds	r24, 0x0074
   154c6:	87 ff       	sbrs	r24, 7
   154c8:	fc cf       	rjmp	.-8      	; 0x154c2 <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   154ca:	80 91 71 00 	lds	r24, 0x0071
   154ce:	88 7f       	andi	r24, 0xF8	; 248
   154d0:	88 32       	cpi	r24, 0x28	; 40
   154d2:	09 f0       	breq	.+2      	; 0x154d6 <_rtc+0xf2>
   154d4:	47 c0       	rjmp	.+142    	; 0x15564 <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   154d6:	84 ea       	ldi	r24, 0xA4	; 164
   154d8:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   154dc:	80 91 74 00 	lds	r24, 0x0074
   154e0:	87 ff       	sbrs	r24, 7
   154e2:	fc cf       	rjmp	.-8      	; 0x154dc <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   154e4:	80 91 71 00 	lds	r24, 0x0071
   154e8:	88 7f       	andi	r24, 0xF8	; 248
   154ea:	80 31       	cpi	r24, 0x10	; 16
   154ec:	d9 f5       	brne	.+118    	; 0x15564 <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   154ee:	81 ed       	ldi	r24, 0xD1	; 209
   154f0:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   154f4:	84 e8       	ldi	r24, 0x84	; 132
   154f6:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   154fa:	80 91 74 00 	lds	r24, 0x0074
   154fe:	87 ff       	sbrs	r24, 7
   15500:	fc cf       	rjmp	.-8      	; 0x154fa <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   15502:	80 91 71 00 	lds	r24, 0x0071
   15506:	88 7f       	andi	r24, 0xF8	; 248
   15508:	80 34       	cpi	r24, 0x40	; 64
   1550a:	61 f5       	brne	.+88     	; 0x15564 <_rtc+0x180>
   1550c:	24 ec       	ldi	r18, 0xC4	; 196
   1550e:	30 e0       	ldi	r19, 0x00	; 0
   15510:	90 e0       	ldi	r25, 0x00	; 0
   15512:	20 c0       	rjmp	.+64     	; 0x15554 <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   15514:	61 30       	cpi	r22, 0x01	; 1
   15516:	71 05       	cpc	r23, r1
   15518:	11 f4       	brne	.+4      	; 0x1551e <_rtc+0x13a>
   1551a:	24 e8       	ldi	r18, 0x84	; 132
   1551c:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   1551e:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   15522:	80 91 74 00 	lds	r24, 0x0074
   15526:	87 ff       	sbrs	r24, 7
   15528:	fc cf       	rjmp	.-8      	; 0x15522 <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   1552a:	80 91 71 00 	lds	r24, 0x0071
   1552e:	88 7f       	andi	r24, 0xF8	; 248
   15530:	88 35       	cpi	r24, 0x58	; 88
   15532:	11 f4       	brne	.+4      	; 0x15538 <_rtc+0x154>
   15534:	60 e0       	ldi	r22, 0x00	; 0
   15536:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   15538:	80 91 71 00 	lds	r24, 0x0071
   1553c:	88 7f       	andi	r24, 0xF8	; 248
   1553e:	80 35       	cpi	r24, 0x50	; 80
   15540:	39 f4       	brne	.+14     	; 0x15550 <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   15542:	80 91 73 00 	lds	r24, 0x0073
   15546:	fa 01       	movw	r30, r20
   15548:	e9 0f       	add	r30, r25
   1554a:	f1 1d       	adc	r31, r1
   1554c:	80 83       	st	Z, r24
   1554e:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   15550:	61 50       	subi	r22, 0x01	; 1
   15552:	70 40       	sbci	r23, 0x00	; 0
   15554:	16 16       	cp	r1, r22
   15556:	17 06       	cpc	r1, r23
   15558:	ec f2       	brlt	.-70     	; 0x15514 <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   1555a:	84 e9       	ldi	r24, 0x94	; 148
   1555c:	80 93 74 00 	sts	0x0074, r24
   15560:	80 e0       	ldi	r24, 0x00	; 0
   15562:	08 95       	ret
   15564:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   15566:	08 95       	ret

00015568 <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   15568:	ef 92       	push	r14
   1556a:	ff 92       	push	r15
   1556c:	0f 93       	push	r16
   1556e:	1f 93       	push	r17
   15570:	df 93       	push	r29
   15572:	cf 93       	push	r28
   15574:	cd b7       	in	r28, 0x3d	; 61
   15576:	de b7       	in	r29, 0x3e	; 62
   15578:	64 97       	sbiw	r28, 0x14	; 20
   1557a:	0f b6       	in	r0, 0x3f	; 63
   1557c:	f8 94       	cli
   1557e:	de bf       	out	0x3e, r29	; 62
   15580:	0f be       	out	0x3f, r0	; 63
   15582:	cd bf       	out	0x3d, r28	; 61
   15584:	28 2f       	mov	r18, r24
   15586:	8b 01       	movw	r16, r22
   15588:	7a 01       	movw	r14, r20
   1558a:	ae 01       	movw	r20, r28
   1558c:	4f 5f       	subi	r20, 0xFF	; 255
   1558e:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   15590:	88 23       	and	r24, r24
   15592:	99 f1       	breq	.+102    	; 0x155fa <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   15594:	fb 01       	movw	r30, r22
   15596:	90 81       	ld	r25, Z
   15598:	92 95       	swap	r25
   1559a:	90 7f       	andi	r25, 0xF0	; 240
   1559c:	81 81       	ldd	r24, Z+1	; 0x01
   1559e:	8f 70       	andi	r24, 0x0F	; 15
   155a0:	98 0f       	add	r25, r24
   155a2:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   155a4:	93 81       	ldd	r25, Z+3	; 0x03
   155a6:	92 95       	swap	r25
   155a8:	90 7f       	andi	r25, 0xF0	; 240
   155aa:	84 81       	ldd	r24, Z+4	; 0x04
   155ac:	8f 70       	andi	r24, 0x0F	; 15
   155ae:	98 0f       	add	r25, r24
   155b0:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   155b2:	96 81       	ldd	r25, Z+6	; 0x06
   155b4:	92 95       	swap	r25
   155b6:	90 7f       	andi	r25, 0xF0	; 240
   155b8:	87 81       	ldd	r24, Z+7	; 0x07
   155ba:	8f 70       	andi	r24, 0x0F	; 15
   155bc:	98 0f       	add	r25, r24
   155be:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   155c0:	f7 01       	movw	r30, r14
   155c2:	90 81       	ld	r25, Z
   155c4:	92 95       	swap	r25
   155c6:	90 7f       	andi	r25, 0xF0	; 240
   155c8:	81 81       	ldd	r24, Z+1	; 0x01
   155ca:	8f 70       	andi	r24, 0x0F	; 15
   155cc:	98 0f       	add	r25, r24
   155ce:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   155d0:	93 81       	ldd	r25, Z+3	; 0x03
   155d2:	92 95       	swap	r25
   155d4:	90 7f       	andi	r25, 0xF0	; 240
   155d6:	84 81       	ldd	r24, Z+4	; 0x04
   155d8:	8f 70       	andi	r24, 0x0F	; 15
   155da:	98 0f       	add	r25, r24
   155dc:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   155de:	96 81       	ldd	r25, Z+6	; 0x06
   155e0:	92 95       	swap	r25
   155e2:	90 7f       	andi	r25, 0xF0	; 240
   155e4:	87 81       	ldd	r24, Z+7	; 0x07
   155e6:	8f 70       	andi	r24, 0x0F	; 15
   155e8:	98 0f       	add	r25, r24
   155ea:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   155ec:	80 e0       	ldi	r24, 0x00	; 0
   155ee:	90 e0       	ldi	r25, 0x00	; 0
   155f0:	68 e0       	ldi	r22, 0x08	; 8
   155f2:	70 e0       	ldi	r23, 0x00	; 0
   155f4:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <_rtc>
   155f8:	4a c0       	rjmp	.+148    	; 0x1568e <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   155fa:	80 e0       	ldi	r24, 0x00	; 0
   155fc:	90 e0       	ldi	r25, 0x00	; 0
   155fe:	68 e0       	ldi	r22, 0x08	; 8
   15600:	70 e0       	ldi	r23, 0x00	; 0
   15602:	20 e0       	ldi	r18, 0x00	; 0
   15604:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <_rtc>
   15608:	81 30       	cpi	r24, 0x01	; 1
   1560a:	09 f4       	brne	.+2      	; 0x1560e <_datetime+0xa6>
   1560c:	40 c0       	rjmp	.+128    	; 0x1568e <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   1560e:	9d 81       	ldd	r25, Y+5	; 0x05
   15610:	89 2f       	mov	r24, r25
   15612:	82 95       	swap	r24
   15614:	8f 70       	andi	r24, 0x0F	; 15
   15616:	80 5d       	subi	r24, 0xD0	; 208
   15618:	f8 01       	movw	r30, r16
   1561a:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   1561c:	9f 70       	andi	r25, 0x0F	; 15
   1561e:	90 5d       	subi	r25, 0xD0	; 208
   15620:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   15622:	2f e2       	ldi	r18, 0x2F	; 47
   15624:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   15626:	9e 81       	ldd	r25, Y+6	; 0x06
   15628:	89 2f       	mov	r24, r25
   1562a:	82 95       	swap	r24
   1562c:	8f 70       	andi	r24, 0x0F	; 15
   1562e:	80 5d       	subi	r24, 0xD0	; 208
   15630:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   15632:	9f 70       	andi	r25, 0x0F	; 15
   15634:	90 5d       	subi	r25, 0xD0	; 208
   15636:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   15638:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   1563a:	9f 81       	ldd	r25, Y+7	; 0x07
   1563c:	89 2f       	mov	r24, r25
   1563e:	82 95       	swap	r24
   15640:	8f 70       	andi	r24, 0x0F	; 15
   15642:	80 5d       	subi	r24, 0xD0	; 208
   15644:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   15646:	9f 70       	andi	r25, 0x0F	; 15
   15648:	90 5d       	subi	r25, 0xD0	; 208
   1564a:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   1564c:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   1564e:	9b 81       	ldd	r25, Y+3	; 0x03
   15650:	89 2f       	mov	r24, r25
   15652:	82 95       	swap	r24
   15654:	8f 70       	andi	r24, 0x0F	; 15
   15656:	80 5d       	subi	r24, 0xD0	; 208
   15658:	f7 01       	movw	r30, r14
   1565a:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   1565c:	9f 70       	andi	r25, 0x0F	; 15
   1565e:	90 5d       	subi	r25, 0xD0	; 208
   15660:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   15662:	2a e3       	ldi	r18, 0x3A	; 58
   15664:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   15666:	9a 81       	ldd	r25, Y+2	; 0x02
   15668:	89 2f       	mov	r24, r25
   1566a:	82 95       	swap	r24
   1566c:	8f 70       	andi	r24, 0x0F	; 15
   1566e:	80 5d       	subi	r24, 0xD0	; 208
   15670:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   15672:	9f 70       	andi	r25, 0x0F	; 15
   15674:	90 5d       	subi	r25, 0xD0	; 208
   15676:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   15678:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   1567a:	99 81       	ldd	r25, Y+1	; 0x01
   1567c:	89 2f       	mov	r24, r25
   1567e:	82 95       	swap	r24
   15680:	8f 70       	andi	r24, 0x0F	; 15
   15682:	80 5d       	subi	r24, 0xD0	; 208
   15684:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   15686:	9f 70       	andi	r25, 0x0F	; 15
   15688:	90 5d       	subi	r25, 0xD0	; 208
   1568a:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   1568c:	10 86       	std	Z+8, r1	; 0x08
		}
}
   1568e:	64 96       	adiw	r28, 0x14	; 20
   15690:	0f b6       	in	r0, 0x3f	; 63
   15692:	f8 94       	cli
   15694:	de bf       	out	0x3e, r29	; 62
   15696:	0f be       	out	0x3f, r0	; 63
   15698:	cd bf       	out	0x3d, r28	; 61
   1569a:	cf 91       	pop	r28
   1569c:	df 91       	pop	r29
   1569e:	1f 91       	pop	r17
   156a0:	0f 91       	pop	r16
   156a2:	ff 90       	pop	r15
   156a4:	ef 90       	pop	r14
   156a6:	08 95       	ret

000156a8 <_day>:

unsigned char _day(void){
   156a8:	df 93       	push	r29
   156aa:	cf 93       	push	r28
   156ac:	cd b7       	in	r28, 0x3d	; 61
   156ae:	de b7       	in	r29, 0x3e	; 62
   156b0:	64 97       	sbiw	r28, 0x14	; 20
   156b2:	0f b6       	in	r0, 0x3f	; 63
   156b4:	f8 94       	cli
   156b6:	de bf       	out	0x3e, r29	; 62
   156b8:	0f be       	out	0x3f, r0	; 63
   156ba:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   156bc:	80 e0       	ldi	r24, 0x00	; 0
   156be:	90 e0       	ldi	r25, 0x00	; 0
   156c0:	68 e0       	ldi	r22, 0x08	; 8
   156c2:	70 e0       	ldi	r23, 0x00	; 0
   156c4:	ae 01       	movw	r20, r28
   156c6:	4f 5f       	subi	r20, 0xFF	; 255
   156c8:	5f 4f       	sbci	r21, 0xFF	; 255
   156ca:	20 e0       	ldi	r18, 0x00	; 0
   156cc:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <_rtc>
   156d0:	81 30       	cpi	r24, 0x01	; 1
   156d2:	11 f4       	brne	.+4      	; 0x156d8 <_day+0x30>
   156d4:	80 e0       	ldi	r24, 0x00	; 0
   156d6:	02 c0       	rjmp	.+4      	; 0x156dc <_day+0x34>
		return __datetime[3] & 0x0F;
   156d8:	8c 81       	ldd	r24, Y+4	; 0x04
   156da:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   156dc:	64 96       	adiw	r28, 0x14	; 20
   156de:	0f b6       	in	r0, 0x3f	; 63
   156e0:	f8 94       	cli
   156e2:	de bf       	out	0x3e, r29	; 62
   156e4:	0f be       	out	0x3f, r0	; 63
   156e6:	cd bf       	out	0x3d, r28	; 61
   156e8:	cf 91       	pop	r28
   156ea:	df 91       	pop	r29
   156ec:	08 95       	ret

000156ee <uart_baudrate>:
	}

	uart_baudrate(__com, __baudrate);
}

void uart_baudrate(unsigned char __com, unsigned long __baudrate){
   156ee:	1f 93       	push	r17
   156f0:	18 2f       	mov	r17, r24
   156f2:	9a 01       	movw	r18, r20
   156f4:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   156f6:	ca 01       	movw	r24, r20
   156f8:	b9 01       	movw	r22, r18
   156fa:	60 50       	subi	r22, 0x00	; 0
   156fc:	70 4e       	sbci	r23, 0xE0	; 224
   156fe:	83 4e       	sbci	r24, 0xE3	; 227
   15700:	9f 4f       	sbci	r25, 0xFF	; 255
   15702:	f3 e0       	ldi	r31, 0x03	; 3
   15704:	66 0f       	add	r22, r22
   15706:	77 1f       	adc	r23, r23
   15708:	88 1f       	adc	r24, r24
   1570a:	99 1f       	adc	r25, r25
   1570c:	fa 95       	dec	r31
   1570e:	d1 f7       	brne	.-12     	; 0x15704 <uart_baudrate+0x16>
   15710:	e4 e0       	ldi	r30, 0x04	; 4
   15712:	22 0f       	add	r18, r18
   15714:	33 1f       	adc	r19, r19
   15716:	44 1f       	adc	r20, r20
   15718:	55 1f       	adc	r21, r21
   1571a:	ea 95       	dec	r30
   1571c:	d1 f7       	brne	.-12     	; 0x15712 <uart_baudrate+0x24>
   1571e:	0e 94 3c b4 	call	0x16878	; 0x16878 <__udivmodsi4>
   15722:	21 50       	subi	r18, 0x01	; 1
   15724:	30 40       	sbci	r19, 0x00	; 0
   15726:	40 40       	sbci	r20, 0x00	; 0
   15728:	50 40       	sbci	r21, 0x00	; 0
   1572a:	bb 27       	eor	r27, r27
   1572c:	a5 2f       	mov	r26, r21
   1572e:	94 2f       	mov	r25, r20
   15730:	83 2f       	mov	r24, r19

	if(__com){
   15732:	11 23       	and	r17, r17
   15734:	29 f0       	breq	.+10     	; 0x15740 <uart_baudrate+0x52>
		UBRR1L = __br;
   15736:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   1573a:	80 93 98 00 	sts	0x0098, r24
   1573e:	03 c0       	rjmp	.+6      	; 0x15746 <uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   15740:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   15742:	80 93 90 00 	sts	0x0090, r24
	}
}
   15746:	1f 91       	pop	r17
   15748:	08 95       	ret

0001574a <uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void uart_init(unsigned char __com, unsigned long __baudrate){
   1574a:	98 2f       	mov	r25, r24
	if(__com){
   1574c:	88 23       	and	r24, r24
   1574e:	39 f0       	breq	.+14     	; 0x1575e <uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   15750:	88 e9       	ldi	r24, 0x98	; 152
   15752:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   15756:	86 e0       	ldi	r24, 0x06	; 6
   15758:	80 93 9d 00 	sts	0x009D, r24
   1575c:	05 c0       	rjmp	.+10     	; 0x15768 <uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   1575e:	88 e9       	ldi	r24, 0x98	; 152
   15760:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   15762:	86 e0       	ldi	r24, 0x06	; 6
   15764:	80 93 95 00 	sts	0x0095, r24
	}

	uart_baudrate(__com, __baudrate);
   15768:	89 2f       	mov	r24, r25
   1576a:	0e 94 77 ab 	call	0x156ee	; 0x156ee <uart_baudrate>
}
   1576e:	08 95       	ret

00015770 <uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   15770:	88 23       	and	r24, r24
   15772:	81 f0       	breq	.+32     	; 0x15794 <uart+0x24>
		if(__dir){
   15774:	66 23       	and	r22, r22
   15776:	39 f0       	breq	.+14     	; 0x15786 <uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   15778:	80 91 9b 00 	lds	r24, 0x009B
   1577c:	85 ff       	sbrs	r24, 5
   1577e:	fc cf       	rjmp	.-8      	; 0x15778 <uart+0x8>
			UDR1 = __chr;
   15780:	40 93 9c 00 	sts	0x009C, r20
   15784:	0c c0       	rjmp	.+24     	; 0x1579e <uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   15786:	80 91 9b 00 	lds	r24, 0x009B
   1578a:	87 ff       	sbrs	r24, 7
   1578c:	fc cf       	rjmp	.-8      	; 0x15786 <uart+0x16>
			return UDR1;
   1578e:	80 91 9c 00 	lds	r24, 0x009C
   15792:	08 95       	ret
		}
	}
	else{
		if(__dir){
   15794:	66 23       	and	r22, r22
   15796:	29 f0       	breq	.+10     	; 0x157a2 <uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   15798:	5d 9b       	sbis	0x0b, 5	; 11
   1579a:	fe cf       	rjmp	.-4      	; 0x15798 <uart+0x28>
			UDR0 = __chr;
   1579c:	4c b9       	out	0x0c, r20	; 12
   1579e:	81 e0       	ldi	r24, 0x01	; 1
   157a0:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   157a2:	5f 9b       	sbis	0x0b, 7	; 11
   157a4:	fe cf       	rjmp	.-4      	; 0x157a2 <uart+0x32>
			return UDR0;
   157a6:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   157a8:	08 95       	ret

000157aa <uart_print>:

void uart_print(unsigned char __com, unsigned char __ret, char *__str){
   157aa:	0f 93       	push	r16
   157ac:	1f 93       	push	r17
   157ae:	cf 93       	push	r28
   157b0:	df 93       	push	r29
   157b2:	18 2f       	mov	r17, r24
   157b4:	06 2f       	mov	r16, r22
   157b6:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   157b8:	88 81       	ld	r24, Y
   157ba:	88 23       	and	r24, r24
   157bc:	31 f4       	brne	.+12     	; 0x157ca <uart_print+0x20>
   157be:	08 c0       	rjmp	.+16     	; 0x157d0 <uart_print+0x26>
		while(*__str)
		     uart(__com, 1, *__str++);
   157c0:	21 96       	adiw	r28, 0x01	; 1
   157c2:	81 2f       	mov	r24, r17
   157c4:	61 e0       	ldi	r22, 0x01	; 1
   157c6:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
	return 1;
}

void uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   157ca:	48 81       	ld	r20, Y
   157cc:	44 23       	and	r20, r20
   157ce:	c1 f7       	brne	.-16     	; 0x157c0 <uart_print+0x16>
		     uart(__com, 1, *__str++);

	if(__ret){
   157d0:	00 23       	and	r16, r16
   157d2:	51 f0       	breq	.+20     	; 0x157e8 <uart_print+0x3e>
		uart(__com, 1, 0x0D);
   157d4:	81 2f       	mov	r24, r17
   157d6:	61 e0       	ldi	r22, 0x01	; 1
   157d8:	4d e0       	ldi	r20, 0x0D	; 13
   157da:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		uart(__com, 1, 0x0A);
   157de:	81 2f       	mov	r24, r17
   157e0:	61 e0       	ldi	r22, 0x01	; 1
   157e2:	4a e0       	ldi	r20, 0x0A	; 10
   157e4:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
   157e8:	82 ee       	ldi	r24, 0xE2	; 226
   157ea:	94 e0       	ldi	r25, 0x04	; 4
   157ec:	01 97       	sbiw	r24, 0x01	; 1
   157ee:	f1 f7       	brne	.-4      	; 0x157ec <uart_print+0x42>
	}
	_delay_ms(5);
}
   157f0:	df 91       	pop	r29
   157f2:	cf 91       	pop	r28
   157f4:	1f 91       	pop	r17
   157f6:	0f 91       	pop	r16
   157f8:	08 95       	ret

000157fa <uart_printf>:

void uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   157fa:	0f 93       	push	r16
   157fc:	1f 93       	push	r17
   157fe:	cf 93       	push	r28
   15800:	df 93       	push	r29
   15802:	18 2f       	mov	r17, r24
   15804:	06 2f       	mov	r16, r22
   15806:	ea 01       	movw	r28, r20
   15808:	07 c0       	rjmp	.+14     	; 0x15818 <uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		uart(__com, 1, pgm_read_byte(&(*__str++)));
   1580a:	21 96       	adiw	r28, 0x01	; 1
   1580c:	f9 01       	movw	r30, r18
   1580e:	44 91       	lpm	r20, Z+
   15810:	81 2f       	mov	r24, r17
   15812:	61 e0       	ldi	r22, 0x01	; 1
   15814:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
   15818:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   1581a:	fe 01       	movw	r30, r28
   1581c:	84 91       	lpm	r24, Z+
   1581e:	88 23       	and	r24, r24
   15820:	a1 f7       	brne	.-24     	; 0x1580a <uart_printf+0x10>
		uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   15822:	00 23       	and	r16, r16
   15824:	51 f0       	breq	.+20     	; 0x1583a <uart_printf+0x40>
		uart(__com, 1, 0x0D);
   15826:	81 2f       	mov	r24, r17
   15828:	61 e0       	ldi	r22, 0x01	; 1
   1582a:	4d e0       	ldi	r20, 0x0D	; 13
   1582c:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
		uart(__com, 1, 0x0A);
   15830:	81 2f       	mov	r24, r17
   15832:	61 e0       	ldi	r22, 0x01	; 1
   15834:	4a e0       	ldi	r20, 0x0A	; 10
   15836:	0e 94 b8 ab 	call	0x15770	; 0x15770 <uart>
   1583a:	86 ea       	ldi	r24, 0xA6	; 166
   1583c:	9e e0       	ldi	r25, 0x0E	; 14
   1583e:	01 97       	sbiw	r24, 0x01	; 1
   15840:	f1 f7       	brne	.-4      	; 0x1583e <uart_printf+0x44>
	}
	_delay_ms(15);
}
   15842:	df 91       	pop	r29
   15844:	cf 91       	pop	r28
   15846:	1f 91       	pop	r17
   15848:	0f 91       	pop	r16
   1584a:	08 95       	ret

0001584c <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   1584c:	6f 92       	push	r6
   1584e:	7f 92       	push	r7
   15850:	8f 92       	push	r8
   15852:	9f 92       	push	r9
   15854:	af 92       	push	r10
   15856:	bf 92       	push	r11
   15858:	cf 92       	push	r12
   1585a:	df 92       	push	r13
   1585c:	ef 92       	push	r14
   1585e:	ff 92       	push	r15
   15860:	0f 93       	push	r16
   15862:	1f 93       	push	r17
   15864:	cf 93       	push	r28
   15866:	df 93       	push	r29
   15868:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   1586a:	41 15       	cp	r20, r1
   1586c:	51 05       	cpc	r21, r1
   1586e:	61 05       	cpc	r22, r1
   15870:	71 05       	cpc	r23, r1
   15872:	21 f4       	brne	.+8      	; 0x1587c <Int2Str+0x30>
		__string[0] = '0';
   15874:	80 e3       	ldi	r24, 0x30	; 48
   15876:	88 83       	st	Y, r24
		__string[1] = '\0';
   15878:	19 82       	std	Y+1, r1	; 0x01
   1587a:	48 c0       	rjmp	.+144    	; 0x1590c <Int2Str+0xc0>
		return;
   1587c:	4a 01       	movw	r8, r20
   1587e:	5b 01       	movw	r10, r22
   15880:	10 e0       	ldi	r17, 0x00	; 0
   15882:	00 e0       	ldi	r16, 0x00	; 0
   15884:	77 24       	eor	r7, r7
   15886:	c1 2c       	mov	r12, r1
   15888:	ba ec       	ldi	r27, 0xCA	; 202
   1588a:	db 2e       	mov	r13, r27
   1588c:	ba e9       	ldi	r27, 0x9A	; 154
   1588e:	eb 2e       	mov	r14, r27
   15890:	bb e3       	ldi	r27, 0x3B	; 59
   15892:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   15894:	a0 e3       	ldi	r26, 0x30	; 48
   15896:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   15898:	8c 14       	cp	r8, r12
   1589a:	9d 04       	cpc	r9, r13
   1589c:	ae 04       	cpc	r10, r14
   1589e:	bf 04       	cpc	r11, r15
   158a0:	d0 f0       	brcs	.+52     	; 0x158d6 <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   158a2:	c5 01       	movw	r24, r10
   158a4:	b4 01       	movw	r22, r8
   158a6:	a7 01       	movw	r20, r14
   158a8:	96 01       	movw	r18, r12
   158aa:	0e 94 3c b4 	call	0x16878	; 0x16878 <__udivmodsi4>
   158ae:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   158b0:	c5 01       	movw	r24, r10
   158b2:	b4 01       	movw	r22, r8
   158b4:	a7 01       	movw	r20, r14
   158b6:	96 01       	movw	r18, r12
   158b8:	0e 94 3c b4 	call	0x16878	; 0x16878 <__udivmodsi4>
   158bc:	ac 01       	movw	r20, r24
   158be:	cb 01       	movw	r24, r22
   158c0:	da 01       	movw	r26, r20
   158c2:	4c 01       	movw	r8, r24
   158c4:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   158c6:	fe 01       	movw	r30, r28
   158c8:	e0 0f       	add	r30, r16
   158ca:	f1 1d       	adc	r31, r1
   158cc:	10 5d       	subi	r17, 0xD0	; 208
   158ce:	10 83       	st	Z, r17
   158d0:	0f 5f       	subi	r16, 0xFF	; 255
   158d2:	11 e0       	ldi	r17, 0x01	; 1
   158d4:	07 c0       	rjmp	.+14     	; 0x158e4 <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   158d6:	11 23       	and	r17, r17
   158d8:	29 f0       	breq	.+10     	; 0x158e4 <Int2Str+0x98>
				__string[__i++] = 0x30;
   158da:	fe 01       	movw	r30, r28
   158dc:	e0 0f       	add	r30, r16
   158de:	f1 1d       	adc	r31, r1
   158e0:	60 82       	st	Z, r6
   158e2:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   158e4:	73 94       	inc	r7
   158e6:	8a e0       	ldi	r24, 0x0A	; 10
   158e8:	78 16       	cp	r7, r24
   158ea:	69 f0       	breq	.+26     	; 0x15906 <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   158ec:	c7 01       	movw	r24, r14
   158ee:	b6 01       	movw	r22, r12
   158f0:	2a e0       	ldi	r18, 0x0A	; 10
   158f2:	30 e0       	ldi	r19, 0x00	; 0
   158f4:	40 e0       	ldi	r20, 0x00	; 0
   158f6:	50 e0       	ldi	r21, 0x00	; 0
   158f8:	0e 94 3c b4 	call	0x16878	; 0x16878 <__udivmodsi4>
   158fc:	c9 01       	movw	r24, r18
   158fe:	da 01       	movw	r26, r20
   15900:	6c 01       	movw	r12, r24
   15902:	7d 01       	movw	r14, r26
   15904:	c9 cf       	rjmp	.-110    	; 0x15898 <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   15906:	c0 0f       	add	r28, r16
   15908:	d1 1d       	adc	r29, r1
   1590a:	18 82       	st	Y, r1
}
   1590c:	df 91       	pop	r29
   1590e:	cf 91       	pop	r28
   15910:	1f 91       	pop	r17
   15912:	0f 91       	pop	r16
   15914:	ff 90       	pop	r15
   15916:	ef 90       	pop	r14
   15918:	df 90       	pop	r13
   1591a:	cf 90       	pop	r12
   1591c:	bf 90       	pop	r11
   1591e:	af 90       	pop	r10
   15920:	9f 90       	pop	r9
   15922:	8f 90       	pop	r8
   15924:	7f 90       	pop	r7
   15926:	6f 90       	pop	r6
   15928:	08 95       	ret

0001592a <Str2Int>:

unsigned long Str2Int(char* __string){
   1592a:	6f 92       	push	r6
   1592c:	7f 92       	push	r7
   1592e:	8f 92       	push	r8
   15930:	9f 92       	push	r9
   15932:	af 92       	push	r10
   15934:	bf 92       	push	r11
   15936:	cf 92       	push	r12
   15938:	df 92       	push	r13
   1593a:	ef 92       	push	r14
   1593c:	ff 92       	push	r15
   1593e:	0f 93       	push	r16
   15940:	1f 93       	push	r17
   15942:	cf 93       	push	r28
   15944:	df 93       	push	r29
   15946:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   15948:	dc 01       	movw	r26, r24
   1594a:	0d 90       	ld	r0, X+
   1594c:	00 20       	and	r0, r0
   1594e:	e9 f7       	brne	.-6      	; 0x1594a <Str2Int+0x20>
   15950:	11 97       	sbiw	r26, 0x01	; 1
   15952:	7a 2e       	mov	r7, r26
   15954:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   15956:	87 2d       	mov	r24, r7
   15958:	81 50       	subi	r24, 0x01	; 1
   1595a:	8a 30       	cpi	r24, 0x0A	; 10
   1595c:	08 f0       	brcs	.+2      	; 0x15960 <Str2Int+0x36>
   1595e:	64 c0       	rjmp	.+200    	; 0x15a28 <Str2Int+0xfe>
   15960:	4e 01       	movw	r8, r28
   15962:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   15964:	6c 2e       	mov	r6, r28
   15966:	05 c0       	rjmp	.+10     	; 0x15972 <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   15968:	81 91       	ld	r24, Z+
   1596a:	80 53       	subi	r24, 0x30	; 48
   1596c:	8a 30       	cpi	r24, 0x0A	; 10
   1596e:	08 f0       	brcs	.+2      	; 0x15972 <Str2Int+0x48>
   15970:	5b c0       	rjmp	.+182    	; 0x15a28 <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   15972:	8e 2f       	mov	r24, r30
   15974:	86 19       	sub	r24, r6
   15976:	87 15       	cp	r24, r7
   15978:	b8 f3       	brcs	.-18     	; 0x15968 <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   1597a:	8a e0       	ldi	r24, 0x0A	; 10
   1597c:	78 16       	cp	r7, r24
   1597e:	f9 f4       	brne	.+62     	; 0x159be <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   15980:	98 81       	ld	r25, Y
   15982:	89 2f       	mov	r24, r25
   15984:	80 53       	subi	r24, 0x30	; 48
   15986:	83 30       	cpi	r24, 0x03	; 3
   15988:	08 f0       	brcs	.+2      	; 0x1598c <Str2Int+0x62>
   1598a:	4e c0       	rjmp	.+156    	; 0x15a28 <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   1598c:	92 33       	cpi	r25, 0x32	; 50
   1598e:	b9 f4       	brne	.+46     	; 0x159be <Str2Int+0x94>
   15990:	fe 01       	movw	r30, r28
   15992:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   15994:	81 81       	ldd	r24, Z+1	; 0x01
   15996:	80 33       	cpi	r24, 0x30	; 48
   15998:	09 f0       	breq	.+2      	; 0x1599c <Str2Int+0x72>
   1599a:	46 c0       	rjmp	.+140    	; 0x15a28 <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   1599c:	9f 5f       	subi	r25, 0xFF	; 255
   1599e:	31 96       	adiw	r30, 0x01	; 1
   159a0:	9a 30       	cpi	r25, 0x0A	; 10
   159a2:	c1 f7       	brne	.-16     	; 0x15994 <Str2Int+0x6a>
   159a4:	0c c0       	rjmp	.+24     	; 0x159be <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   159a6:	c6 01       	movw	r24, r12
   159a8:	b5 01       	movw	r22, r10
   159aa:	2a e0       	ldi	r18, 0x0A	; 10
   159ac:	30 e0       	ldi	r19, 0x00	; 0
   159ae:	40 e0       	ldi	r20, 0x00	; 0
   159b0:	50 e0       	ldi	r21, 0x00	; 0
   159b2:	0e 94 dd b3 	call	0x167ba	; 0x167ba <__mulsi3>
   159b6:	5b 01       	movw	r10, r22
   159b8:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   159ba:	1f 5f       	subi	r17, 0xFF	; 255
   159bc:	09 c0       	rjmp	.+18     	; 0x159d0 <Str2Int+0xa6>
   159be:	10 e0       	ldi	r17, 0x00	; 0
   159c0:	01 e0       	ldi	r16, 0x01	; 1
   159c2:	a0 2e       	mov	r10, r16
   159c4:	b1 2c       	mov	r11, r1
   159c6:	c1 2c       	mov	r12, r1
   159c8:	d1 2c       	mov	r13, r1
   159ca:	c7 2d       	mov	r28, r7
   159cc:	d0 e0       	ldi	r29, 0x00	; 0
   159ce:	21 97       	sbiw	r28, 0x01	; 1
   159d0:	81 2f       	mov	r24, r17
   159d2:	90 e0       	ldi	r25, 0x00	; 0
   159d4:	8c 17       	cp	r24, r28
   159d6:	9d 07       	cpc	r25, r29
   159d8:	34 f3       	brlt	.-52     	; 0x159a6 <Str2Int+0x7c>
   159da:	ee 24       	eor	r14, r14
   159dc:	ff 24       	eor	r15, r15
   159de:	87 01       	movw	r16, r14
   159e0:	1e c0       	rjmp	.+60     	; 0x15a1e <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   159e2:	f4 01       	movw	r30, r8
   159e4:	21 91       	ld	r18, Z+
   159e6:	4f 01       	movw	r8, r30
   159e8:	30 e0       	ldi	r19, 0x00	; 0
   159ea:	20 53       	subi	r18, 0x30	; 48
   159ec:	30 40       	sbci	r19, 0x00	; 0
   159ee:	44 27       	eor	r20, r20
   159f0:	37 fd       	sbrc	r19, 7
   159f2:	40 95       	com	r20
   159f4:	54 2f       	mov	r21, r20
   159f6:	c6 01       	movw	r24, r12
   159f8:	b5 01       	movw	r22, r10
   159fa:	0e 94 dd b3 	call	0x167ba	; 0x167ba <__mulsi3>
   159fe:	e6 0e       	add	r14, r22
   15a00:	f7 1e       	adc	r15, r23
   15a02:	08 1f       	adc	r16, r24
   15a04:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   15a06:	c6 01       	movw	r24, r12
   15a08:	b5 01       	movw	r22, r10
   15a0a:	2a e0       	ldi	r18, 0x0A	; 10
   15a0c:	30 e0       	ldi	r19, 0x00	; 0
   15a0e:	40 e0       	ldi	r20, 0x00	; 0
   15a10:	50 e0       	ldi	r21, 0x00	; 0
   15a12:	0e 94 3c b4 	call	0x16878	; 0x16878 <__udivmodsi4>
   15a16:	c9 01       	movw	r24, r18
   15a18:	da 01       	movw	r26, r20
   15a1a:	5c 01       	movw	r10, r24
   15a1c:	6d 01       	movw	r12, r26
   15a1e:	88 2d       	mov	r24, r8
   15a20:	86 19       	sub	r24, r6
   15a22:	87 15       	cp	r24, r7
   15a24:	f0 f2       	brcs	.-68     	; 0x159e2 <Str2Int+0xb8>
   15a26:	03 c0       	rjmp	.+6      	; 0x15a2e <Str2Int+0x104>
   15a28:	ee 24       	eor	r14, r14
   15a2a:	ff 24       	eor	r15, r15
   15a2c:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   15a2e:	b7 01       	movw	r22, r14
   15a30:	c8 01       	movw	r24, r16
   15a32:	df 91       	pop	r29
   15a34:	cf 91       	pop	r28
   15a36:	1f 91       	pop	r17
   15a38:	0f 91       	pop	r16
   15a3a:	ff 90       	pop	r15
   15a3c:	ef 90       	pop	r14
   15a3e:	df 90       	pop	r13
   15a40:	cf 90       	pop	r12
   15a42:	bf 90       	pop	r11
   15a44:	af 90       	pop	r10
   15a46:	9f 90       	pop	r9
   15a48:	8f 90       	pop	r8
   15a4a:	7f 90       	pop	r7
   15a4c:	6f 90       	pop	r6
   15a4e:	08 95       	ret

00015a50 <mmc_read>:
   }   
   return Result;
}


void mmc_read(unsigned long int sectoraddress){
   15a50:	8f 92       	push	r8
   15a52:	9f 92       	push	r9
   15a54:	af 92       	push	r10
   15a56:	bf 92       	push	r11
   15a58:	cf 92       	push	r12
   15a5a:	df 92       	push	r13
   15a5c:	ef 92       	push	r14
   15a5e:	ff 92       	push	r15
   15a60:	0f 93       	push	r16
   15a62:	1f 93       	push	r17
   15a64:	cf 93       	push	r28
   15a66:	df 93       	push	r29
   15a68:	7b 01       	movw	r14, r22
   15a6a:	8c 01       	movw	r16, r24
   unsigned char xsdread, ysdread;
   unsigned int xsdrcount;
   
   sbi(MMC_PORT, MMC_PIN);
   15a6c:	1b 9a       	sbi	0x03, 3	; 3
   sectoraddress*=0x200;  
   15a6e:	39 e0       	ldi	r19, 0x09	; 9
   15a70:	ee 0c       	add	r14, r14
   15a72:	ff 1c       	adc	r15, r15
   15a74:	00 1f       	adc	r16, r16
   15a76:	11 1f       	adc	r17, r17
   15a78:	3a 95       	dec	r19
   15a7a:	d1 f7       	brne	.-12     	; 0x15a70 <mmc_read+0x20>
      _delay_us(5);
      //MMC_CS_ASSERT;
	  cbi(MMC_PORT, MMC_PIN);
      _delay_us(5);
      write_SPI(0x51);
      xsdread=(sectoraddress>>24)&0xFF;
   15a7c:	81 2f       	mov	r24, r17
   15a7e:	99 27       	eor	r25, r25
   15a80:	aa 27       	eor	r26, r26
   15a82:	bb 27       	eor	r27, r27
   15a84:	98 2e       	mov	r9, r24
      write_SPI(xsdread);
      xsdread=(sectoraddress>>16)&0xFF;
   15a86:	c8 01       	movw	r24, r16
   15a88:	aa 27       	eor	r26, r26
   15a8a:	bb 27       	eor	r27, r27
   15a8c:	a8 2e       	mov	r10, r24
      write_SPI(xsdread);
      xsdread=(sectoraddress>>8)&0xFF;
   15a8e:	bb 27       	eor	r27, r27
   15a90:	a1 2f       	mov	r26, r17
   15a92:	90 2f       	mov	r25, r16
   15a94:	8f 2d       	mov	r24, r15
   15a96:	b8 2e       	mov	r11, r24
   15a98:	cc 24       	eor	r12, r12
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
   15a9a:	88 24       	eor	r8, r8
   15a9c:	83 94       	inc	r8
   unsigned int xsdrcount;
   
   sbi(MMC_PORT, MMC_PIN);
   sectoraddress*=0x200;  
   for(ysdread=0;ysdread<250;ysdread++){
      write_SPI(0xFF);
   15a9e:	8f ef       	ldi	r24, 0xFF	; 255
   15aa0:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15aa4:	88 2d       	mov	r24, r8
   15aa6:	8a 95       	dec	r24
   15aa8:	f1 f7       	brne	.-4      	; 0x15aa6 <mmc_read+0x56>
      _delay_us(5);
      //MMC_CS_ASSERT;
	  cbi(MMC_PORT, MMC_PIN);
   15aaa:	1b 98       	cbi	0x03, 3	; 3
   15aac:	88 2d       	mov	r24, r8
   15aae:	8a 95       	dec	r24
   15ab0:	f1 f7       	brne	.-4      	; 0x15aae <mmc_read+0x5e>
      _delay_us(5);
      write_SPI(0x51);
   15ab2:	81 e5       	ldi	r24, 0x51	; 81
   15ab4:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      xsdread=(sectoraddress>>24)&0xFF;
      write_SPI(xsdread);
   15ab8:	89 2d       	mov	r24, r9
   15aba:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      xsdread=(sectoraddress>>16)&0xFF;
      write_SPI(xsdread);
   15abe:	8a 2d       	mov	r24, r10
   15ac0:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      xsdread=(sectoraddress>>8)&0xFF;
      write_SPI(xsdread);
   15ac4:	8b 2d       	mov	r24, r11
   15ac6:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      xsdread=sectoraddress&0xFF;
      write_SPI(xsdread);
   15aca:	8e 2d       	mov	r24, r14
   15acc:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      write_SPI(0xFF);
   15ad0:	8f ef       	ldi	r24, 0xFF	; 255
   15ad2:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      SPDR=0xFF;
   15ad6:	8f ef       	ldi	r24, 0xFF	; 255
   15ad8:	8f b9       	out	0x0f, r24	; 15
   15ada:	dd 24       	eor	r13, r13
	  for (xsdread=0;xsdread<9;xsdread++){
	       if (SPDR==0xFF) 
   15adc:	8f b1       	in	r24, 0x0f	; 15
   15ade:	8f 3f       	cpi	r24, 0xFF	; 255
   15ae0:	31 f4       	brne	.+12     	; 0x15aee <mmc_read+0x9e>
		       write_SPI(0xFF); 
   15ae2:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      write_SPI(xsdread);
      xsdread=sectoraddress&0xFF;
      write_SPI(xsdread);
      write_SPI(0xFF);
      SPDR=0xFF;
	  for (xsdread=0;xsdread<9;xsdread++){
   15ae6:	d3 94       	inc	r13
   15ae8:	89 e0       	ldi	r24, 0x09	; 9
   15aea:	d8 16       	cp	r13, r24
   15aec:	b9 f7       	brne	.-18     	; 0x15adc <mmc_read+0x8c>
	       if (SPDR==0xFF) 
		       write_SPI(0xFF); 
		   else break;
	  }      
      if (SPDR==0){
   15aee:	8f b1       	in	r24, 0x0f	; 15
   15af0:	88 23       	and	r24, r24
   15af2:	49 f4       	brne	.+18     	; 0x15b06 <mmc_read+0xb6>
	      uart_printf(0,1,PSTR("Read Response OK"));
   15af4:	61 e0       	ldi	r22, 0x01	; 1
   15af6:	48 ef       	ldi	r20, 0xF8	; 248
   15af8:	54 e2       	ldi	r21, 0x24	; 36
   15afa:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
   15afe:	00 e0       	ldi	r16, 0x00	; 0
	      break;      
	   }else uart_printf(0,1,PSTR("Read Response Failed"));
    }//EndFor
       
   for(ysdread=0;ysdread<250;ysdread++){
      SPDR=0xFF;
   15b00:	ff 24       	eor	r15, r15
   15b02:	fa 94       	dec	r15
   15b04:	0c c0       	rjmp	.+24     	; 0x15b1e <mmc_read+0xce>
		   else break;
	  }      
      if (SPDR==0){
	      uart_printf(0,1,PSTR("Read Response OK"));
	      break;      
	   }else uart_printf(0,1,PSTR("Read Response Failed"));
   15b06:	80 e0       	ldi	r24, 0x00	; 0
   15b08:	61 e0       	ldi	r22, 0x01	; 1
   15b0a:	43 ee       	ldi	r20, 0xE3	; 227
   15b0c:	54 e2       	ldi	r21, 0x24	; 36
   15b0e:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
   unsigned char xsdread, ysdread;
   unsigned int xsdrcount;
   
   sbi(MMC_PORT, MMC_PIN);
   sectoraddress*=0x200;  
   for(ysdread=0;ysdread<250;ysdread++){
   15b12:	c3 94       	inc	r12
   15b14:	8a ef       	ldi	r24, 0xFA	; 250
   15b16:	c8 16       	cp	r12, r24
   15b18:	09 f0       	breq	.+2      	; 0x15b1c <mmc_read+0xcc>
   15b1a:	c1 cf       	rjmp	.-126    	; 0x15a9e <mmc_read+0x4e>
   15b1c:	f0 cf       	rjmp	.-32     	; 0x15afe <mmc_read+0xae>
	      break;      
	   }else uart_printf(0,1,PSTR("Read Response Failed"));
    }//EndFor
       
   for(ysdread=0;ysdread<250;ysdread++){
      SPDR=0xFF;
   15b1e:	ff b8       	out	0x0f, r15	; 15
   15b20:	10 e0       	ldi	r17, 0x00	; 0
      for(xsdread=0;xsdread<9;xsdread++){
         if (SPDR==0xFF) write_SPI(0xFF); 
   15b22:	8f b1       	in	r24, 0x0f	; 15
   15b24:	8f 3f       	cpi	r24, 0xFF	; 255
   15b26:	29 f4       	brne	.+10     	; 0x15b32 <mmc_read+0xe2>
   15b28:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
	   }else uart_printf(0,1,PSTR("Read Response Failed"));
    }//EndFor
       
   for(ysdread=0;ysdread<250;ysdread++){
      SPDR=0xFF;
      for(xsdread=0;xsdread<9;xsdread++){
   15b2c:	1f 5f       	subi	r17, 0xFF	; 255
   15b2e:	19 30       	cpi	r17, 0x09	; 9
   15b30:	c1 f7       	brne	.-16     	; 0x15b22 <mmc_read+0xd2>
         if (SPDR==0xFF) write_SPI(0xFF); 
		 else break;         
         }
      if (SPDR==0xFE) break;      
   15b32:	8f b1       	in	r24, 0x0f	; 15
   15b34:	8e 3f       	cpi	r24, 0xFE	; 254
   15b36:	19 f0       	breq	.+6      	; 0x15b3e <mmc_read+0xee>
	      uart_printf(0,1,PSTR("Read Response OK"));
	      break;      
	   }else uart_printf(0,1,PSTR("Read Response Failed"));
    }//EndFor
       
   for(ysdread=0;ysdread<250;ysdread++){
   15b38:	0f 5f       	subi	r16, 0xFF	; 255
   15b3a:	0a 3f       	cpi	r16, 0xFA	; 250
   15b3c:	81 f7       	brne	.-32     	; 0x15b1e <mmc_read+0xce>
   15b3e:	c0 e0       	ldi	r28, 0x00	; 0
   15b40:	d0 e0       	ldi	r29, 0x00	; 0
         }
      if (SPDR==0xFE) break;      
    }
   
   for(xsdrcount=0;xsdrcount<512;xsdrcount++){
       write_SPI(0xFF);
   15b42:	8f ef       	ldi	r24, 0xFF	; 255
   15b44:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
	   MMC_Buffer[xsdrcount]=SPDR;//Store Read data to MMC_Data	  
   15b48:	8f b1       	in	r24, 0x0f	; 15
   15b4a:	fe 01       	movw	r30, r28
   15b4c:	e3 5e       	subi	r30, 0xE3	; 227
   15b4e:	f6 4f       	sbci	r31, 0xF6	; 246
   15b50:	80 83       	st	Z, r24
		 else break;         
         }
      if (SPDR==0xFE) break;      
    }
   
   for(xsdrcount=0;xsdrcount<512;xsdrcount++){
   15b52:	21 96       	adiw	r28, 0x01	; 1
   15b54:	82 e0       	ldi	r24, 0x02	; 2
   15b56:	c0 30       	cpi	r28, 0x00	; 0
   15b58:	d8 07       	cpc	r29, r24
   15b5a:	99 f7       	brne	.-26     	; 0x15b42 <mmc_read+0xf2>
       write_SPI(0xFF);
	   MMC_Buffer[xsdrcount]=SPDR;//Store Read data to MMC_Data	  
   }   
   write_SPI(0xFF);
   15b5c:	8f ef       	ldi	r24, 0xFF	; 255
   15b5e:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   write_SPI(0xFF);
   15b62:	8f ef       	ldi	r24, 0xFF	; 255
   15b64:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15b68:	81 e0       	ldi	r24, 0x01	; 1
   15b6a:	8a 95       	dec	r24
   15b6c:	f1 f7       	brne	.-4      	; 0x15b6a <mmc_read+0x11a>
   _delay_us(5);
   //MMC_CS_DEASSERT;
   sbi(MMC_PORT, MMC_PIN);
   15b6e:	1b 9a       	sbi	0x03, 3	; 3
}
   15b70:	df 91       	pop	r29
   15b72:	cf 91       	pop	r28
   15b74:	1f 91       	pop	r17
   15b76:	0f 91       	pop	r16
   15b78:	ff 90       	pop	r15
   15b7a:	ef 90       	pop	r14
   15b7c:	df 90       	pop	r13
   15b7e:	cf 90       	pop	r12
   15b80:	bf 90       	pop	r11
   15b82:	af 90       	pop	r10
   15b84:	9f 90       	pop	r9
   15b86:	8f 90       	pop	r8
   15b88:	08 95       	ret

00015b8a <mmc_initialize>:

}



unsigned char mmc_initialize(){
   15b8a:	0f 93       	push	r16
   15b8c:	1f 93       	push	r17
   15b8e:	00 e0       	ldi	r16, 0x00	; 0
unsigned char xsdinit, ysdinit,i,j;
char Result;

   Result=MMC_NONE;
   for(i=0;i<250;i++){
       write_SPI(0xFF);
   15b90:	8f ef       	ldi	r24, 0xFF	; 255
   15b92:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
       MMC_CS_ASSERT;
   15b96:	82 e0       	ldi	r24, 0x02	; 2
   15b98:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
       write_SPI(0x41);
   15b9c:	81 e4       	ldi	r24, 0x41	; 65
   15b9e:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
       for(j=0;j<4;j++)write_SPI(0x00);      
   15ba2:	80 e0       	ldi	r24, 0x00	; 0
   15ba4:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15ba8:	80 e0       	ldi	r24, 0x00	; 0
   15baa:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15bae:	80 e0       	ldi	r24, 0x00	; 0
   15bb0:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15bb4:	80 e0       	ldi	r24, 0x00	; 0
   15bb6:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
	   write_SPI(0xFF);
   15bba:	8f ef       	ldi	r24, 0xFF	; 255
   15bbc:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
       SPDR=0xFF;
   15bc0:	8f ef       	ldi	r24, 0xFF	; 255
   15bc2:	8f b9       	out	0x0f, r24	; 15
   15bc4:	10 e0       	ldi	r17, 0x00	; 0
	   for(j=0;j<9;j++)write_SPI(0xFF);
   15bc6:	8f ef       	ldi	r24, 0xFF	; 255
   15bc8:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15bcc:	1f 5f       	subi	r17, 0xFF	; 255
   15bce:	19 30       	cpi	r17, 0x09	; 9
   15bd0:	d1 f7       	brne	.-12     	; 0x15bc6 <mmc_initialize+0x3c>
	   MMC_CS_DEASSERT;
   15bd2:	80 e0       	ldi	r24, 0x00	; 0
   15bd4:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
       if (SPDR==0){
   15bd8:	8f b1       	in	r24, 0x0f	; 15
   15bda:	88 23       	and	r24, r24
   15bdc:	11 f4       	brne	.+4      	; 0x15be2 <mmc_initialize+0x58>
   15bde:	81 e0       	ldi	r24, 0x01	; 1
   15be0:	04 c0       	rjmp	.+8      	; 0x15bea <mmc_initialize+0x60>
unsigned char mmc_initialize(){
unsigned char xsdinit, ysdinit,i,j;
char Result;

   Result=MMC_NONE;
   for(i=0;i<250;i++){
   15be2:	0f 5f       	subi	r16, 0xFF	; 255
   15be4:	0a 3f       	cpi	r16, 0xFA	; 250
   15be6:	a1 f6       	brne	.-88     	; 0x15b90 <mmc_initialize+0x6>
   15be8:	80 e0       	ldi	r24, 0x00	; 0
	       Result=MMC_INITIALIZED;
	       break;
	   }
   }   
   return Result;
}
   15bea:	1f 91       	pop	r17
   15bec:	0f 91       	pop	r16
   15bee:	08 95       	ret

00015bf0 <mmc_reset>:

	return 0;
}

//----------------------
unsigned char mmc_reset(){
   15bf0:	1f 93       	push	r17
unsigned char i;
   
   MMC_CS_DEASSERT;
   15bf2:	80 e0       	ldi	r24, 0x00	; 0
   15bf4:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   15bf8:	10 e0       	ldi	r17, 0x00	; 0

   for (i=0;i<10;i++){
        write_SPI(0xFF);
   15bfa:	8f ef       	ldi	r24, 0xFF	; 255
   15bfc:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
unsigned char mmc_reset(){
unsigned char i;
   
   MMC_CS_DEASSERT;

   for (i=0;i<10;i++){
   15c00:	1f 5f       	subi	r17, 0xFF	; 255
   15c02:	1a 30       	cpi	r17, 0x0A	; 10
   15c04:	d1 f7       	brne	.-12     	; 0x15bfa <mmc_reset+0xa>
        write_SPI(0xFF);
   }
                                 
  MMC_CS_ASSERT;
   15c06:	82 e0       	ldi	r24, 0x02	; 2
   15c08:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>

   write_SPI(0x40);              
   15c0c:	80 e4       	ldi	r24, 0x40	; 64
   15c0e:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   for (i=0;i<4;i++) write_SPI(0x00);         
   15c12:	80 e0       	ldi	r24, 0x00	; 0
   15c14:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15c18:	80 e0       	ldi	r24, 0x00	; 0
   15c1a:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15c1e:	80 e0       	ldi	r24, 0x00	; 0
   15c20:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15c24:	80 e0       	ldi	r24, 0x00	; 0
   15c26:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   write_SPI(0x95);
   15c2a:	85 e9       	ldi	r24, 0x95	; 149
   15c2c:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   
   SPDR=0xFF;
   15c30:	8f ef       	ldi	r24, 0xFF	; 255
   15c32:	8f b9       	out	0x0f, r24	; 15
   15c34:	10 e0       	ldi	r17, 0x00	; 0

   for (i=0;i<9;i++){
        if (SPDR==0xFF) 
   15c36:	8f b1       	in	r24, 0x0f	; 15
   15c38:	8f 3f       	cpi	r24, 0xFF	; 255
   15c3a:	29 f4       	brne	.+10     	; 0x15c46 <mmc_reset+0x56>
		    write_SPI(0xFF);
   15c3c:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   for (i=0;i<4;i++) write_SPI(0x00);         
   write_SPI(0x95);
   
   SPDR=0xFF;

   for (i=0;i<9;i++){
   15c40:	1f 5f       	subi	r17, 0xFF	; 255
   15c42:	19 30       	cpi	r17, 0x09	; 9
   15c44:	c1 f7       	brne	.-16     	; 0x15c36 <mmc_reset+0x46>
        if (SPDR==0xFF) 
		    write_SPI(0xFF);
		else break;
   }
   MMC_CS_DEASSERT;  
   15c46:	80 e0       	ldi	r24, 0x00	; 0
   15c48:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   return SPDR;//01
   15c4c:	8f b1       	in	r24, 0x0f	; 15

}
   15c4e:	1f 91       	pop	r17
   15c50:	08 95       	ret

00015c52 <mmc_write>:
   _delay_us(5);
   //MMC_CS_DEASSERT;
   sbi(MMC_PORT, MMC_PIN);
}

void mmc_write(unsigned long int sectoraddress){
   15c52:	4f 92       	push	r4
   15c54:	5f 92       	push	r5
   15c56:	6f 92       	push	r6
   15c58:	7f 92       	push	r7
   15c5a:	8f 92       	push	r8
   15c5c:	9f 92       	push	r9
   15c5e:	af 92       	push	r10
   15c60:	bf 92       	push	r11
   15c62:	cf 92       	push	r12
   15c64:	df 92       	push	r13
   15c66:	ef 92       	push	r14
   15c68:	ff 92       	push	r15
   15c6a:	0f 93       	push	r16
   15c6c:	1f 93       	push	r17
   15c6e:	df 93       	push	r29
   15c70:	cf 93       	push	r28
   15c72:	cd b7       	in	r28, 0x3d	; 61
   15c74:	de b7       	in	r29, 0x3e	; 62
   15c76:	6e 97       	sbiw	r28, 0x1e	; 30
   15c78:	0f b6       	in	r0, 0x3f	; 63
   15c7a:	f8 94       	cli
   15c7c:	de bf       	out	0x3e, r29	; 62
   15c7e:	0f be       	out	0x3f, r0	; 63
   15c80:	cd bf       	out	0x3d, r28	; 61
   15c82:	7b 01       	movw	r14, r22
   15c84:	8c 01       	movw	r16, r24
   unsigned char xsdwrite, ysdwrite;
   unsigned int xsdwcount;
   char strSend[30];

   uart_printf(1,1,PSTR("-mmc_write-"));
   15c86:	81 e0       	ldi	r24, 0x01	; 1
   15c88:	61 e0       	ldi	r22, 0x01	; 1
   15c8a:	47 ed       	ldi	r20, 0xD7	; 215
   15c8c:	54 e2       	ldi	r21, 0x24	; 36
   15c8e:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>

   sbi(MMC_PORT, MMC_PIN);
   15c92:	1b 9a       	sbi	0x03, 3	; 3
   sectoraddress*=0x200;
   15c94:	f9 e0       	ldi	r31, 0x09	; 9
   15c96:	ee 0c       	add	r14, r14
   15c98:	ff 1c       	adc	r15, r15
   15c9a:	00 1f       	adc	r16, r16
   15c9c:	11 1f       	adc	r17, r17
   15c9e:	fa 95       	dec	r31
   15ca0:	d1 f7       	brne	.-12     	; 0x15c96 <mmc_write+0x44>
      MMC_CS_ASSERT;
	  cbi(MMC_PORT, MMC_PIN);

      _delay_us(5);
      write_SPI(0x58);
      xsdwrite=(sectoraddress>>24)&0xFF;
   15ca2:	81 2f       	mov	r24, r17
   15ca4:	99 27       	eor	r25, r25
   15ca6:	aa 27       	eor	r26, r26
   15ca8:	bb 27       	eor	r27, r27
   15caa:	58 2e       	mov	r5, r24
      write_SPI(xsdwrite);
      xsdwrite=(sectoraddress>>16)&0xFF;
   15cac:	c8 01       	movw	r24, r16
   15cae:	aa 27       	eor	r26, r26
   15cb0:	bb 27       	eor	r27, r27
   15cb2:	68 2e       	mov	r6, r24
      write_SPI(xsdwrite);
      xsdwrite=(sectoraddress>>8)&0xFF;
   15cb4:	bb 27       	eor	r27, r27
   15cb6:	a1 2f       	mov	r26, r17
   15cb8:	90 2f       	mov	r25, r16
   15cba:	8f 2d       	mov	r24, r15
   15cbc:	78 2e       	mov	r7, r24
   15cbe:	cc 24       	eor	r12, r12
   15cc0:	44 24       	eor	r4, r4
   15cc2:	43 94       	inc	r4
	  //Wait MMC Busy OK->SPDR=0
	  for(xsdwrite=0;xsdwrite<9;xsdwrite++){
         if (SPDR==0xFF) write_SPI(0xFF); 
		 else break;
        }
      sprintf_P(strSend,PSTR("SPDR=%.2X"),SPDR);
   15cc4:	5e 01       	movw	r10, r28
   15cc6:	08 94       	sec
   15cc8:	a1 1c       	adc	r10, r1
   15cca:	b1 1c       	adc	r11, r1
   15ccc:	5d ec       	ldi	r21, 0xCD	; 205
   15cce:	85 2e       	mov	r8, r21
   15cd0:	54 e2       	ldi	r21, 0x24	; 36
   15cd2:	95 2e       	mov	r9, r21
   uart_printf(1,1,PSTR("-mmc_write-"));

   sbi(MMC_PORT, MMC_PIN);
   sectoraddress*=0x200;
   for(ysdwrite=0;ysdwrite<250;ysdwrite++){
      write_SPI(0xFF);
   15cd4:	8f ef       	ldi	r24, 0xFF	; 255
   15cd6:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15cda:	84 2d       	mov	r24, r4
   15cdc:	8a 95       	dec	r24
   15cde:	f1 f7       	brne	.-4      	; 0x15cdc <mmc_write+0x8a>
      _delay_us(5);
      MMC_CS_ASSERT;
   15ce0:	82 e0       	ldi	r24, 0x02	; 2
   15ce2:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
	  cbi(MMC_PORT, MMC_PIN);
   15ce6:	1b 98       	cbi	0x03, 3	; 3
   15ce8:	84 2d       	mov	r24, r4
   15cea:	8a 95       	dec	r24
   15cec:	f1 f7       	brne	.-4      	; 0x15cea <mmc_write+0x98>

      _delay_us(5);
      write_SPI(0x58);
   15cee:	88 e5       	ldi	r24, 0x58	; 88
   15cf0:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      xsdwrite=(sectoraddress>>24)&0xFF;
      write_SPI(xsdwrite);
   15cf4:	85 2d       	mov	r24, r5
   15cf6:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      xsdwrite=(sectoraddress>>16)&0xFF;
      write_SPI(xsdwrite);
   15cfa:	86 2d       	mov	r24, r6
   15cfc:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      xsdwrite=(sectoraddress>>8)&0xFF;
      write_SPI(xsdwrite);
   15d00:	87 2d       	mov	r24, r7
   15d02:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      xsdwrite=sectoraddress&0xFF;
      write_SPI(xsdwrite);
   15d06:	8e 2d       	mov	r24, r14
   15d08:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      write_SPI(0xFF);
   15d0c:	8f ef       	ldi	r24, 0xFF	; 255
   15d0e:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      SPDR=0xFF;
   15d12:	8f ef       	ldi	r24, 0xFF	; 255
   15d14:	8f b9       	out	0x0f, r24	; 15
   15d16:	dd 24       	eor	r13, r13
      xsdwrite=0;
	  //Wait MMC Busy OK->SPDR=0
	  for(xsdwrite=0;xsdwrite<9;xsdwrite++){
         if (SPDR==0xFF) write_SPI(0xFF); 
   15d18:	8f b1       	in	r24, 0x0f	; 15
   15d1a:	8f 3f       	cpi	r24, 0xFF	; 255
   15d1c:	31 f4       	brne	.+12     	; 0x15d2a <mmc_write+0xd8>
   15d1e:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      write_SPI(xsdwrite);
      write_SPI(0xFF);
      SPDR=0xFF;
      xsdwrite=0;
	  //Wait MMC Busy OK->SPDR=0
	  for(xsdwrite=0;xsdwrite<9;xsdwrite++){
   15d22:	d3 94       	inc	r13
   15d24:	89 e0       	ldi	r24, 0x09	; 9
   15d26:	d8 16       	cp	r13, r24
   15d28:	b9 f7       	brne	.-18     	; 0x15d18 <mmc_write+0xc6>
         if (SPDR==0xFF) write_SPI(0xFF); 
		 else break;
        }
      sprintf_P(strSend,PSTR("SPDR=%.2X"),SPDR);
   15d2a:	8f b1       	in	r24, 0x0f	; 15
   15d2c:	00 d0       	rcall	.+0      	; 0x15d2e <mmc_write+0xdc>
   15d2e:	00 d0       	rcall	.+0      	; 0x15d30 <mmc_write+0xde>
   15d30:	00 d0       	rcall	.+0      	; 0x15d32 <mmc_write+0xe0>
   15d32:	ed b7       	in	r30, 0x3d	; 61
   15d34:	fe b7       	in	r31, 0x3e	; 62
   15d36:	31 96       	adiw	r30, 0x01	; 1
   15d38:	ad b7       	in	r26, 0x3d	; 61
   15d3a:	be b7       	in	r27, 0x3e	; 62
   15d3c:	12 96       	adiw	r26, 0x02	; 2
   15d3e:	bc 92       	st	X, r11
   15d40:	ae 92       	st	-X, r10
   15d42:	11 97       	sbiw	r26, 0x01	; 1
   15d44:	93 82       	std	Z+3, r9	; 0x03
   15d46:	82 82       	std	Z+2, r8	; 0x02
   15d48:	84 83       	std	Z+4, r24	; 0x04
   15d4a:	15 82       	std	Z+5, r1	; 0x05
   15d4c:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	  uart_print(0,1,strSend);
   15d50:	ed b7       	in	r30, 0x3d	; 61
   15d52:	fe b7       	in	r31, 0x3e	; 62
   15d54:	36 96       	adiw	r30, 0x06	; 6
   15d56:	0f b6       	in	r0, 0x3f	; 63
   15d58:	f8 94       	cli
   15d5a:	fe bf       	out	0x3e, r31	; 62
   15d5c:	0f be       	out	0x3f, r0	; 63
   15d5e:	ed bf       	out	0x3d, r30	; 61
   15d60:	80 e0       	ldi	r24, 0x00	; 0
   15d62:	61 e0       	ldi	r22, 0x01	; 1
   15d64:	a5 01       	movw	r20, r10
   15d66:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>

	   
      if (SPDR==0){
   15d6a:	8f b1       	in	r24, 0x0f	; 15
   15d6c:	88 23       	and	r24, r24
   15d6e:	39 f4       	brne	.+14     	; 0x15d7e <mmc_write+0x12c>
          uart_printf(0,1,PSTR("Cmd Response OK")); 
   15d70:	61 e0       	ldi	r22, 0x01	; 1
   15d72:	4d eb       	ldi	r20, 0xBD	; 189
   15d74:	54 e2       	ldi	r21, 0x24	; 36
   15d76:	0e 94 fd ab 	call	0x157fa	; 0x157fa <uart_printf>
   15d7a:	10 e0       	ldi	r17, 0x00	; 0
   15d7c:	06 c0       	rjmp	.+12     	; 0x15d8a <mmc_write+0x138>

   uart_printf(1,1,PSTR("-mmc_write-"));

   sbi(MMC_PORT, MMC_PIN);
   sectoraddress*=0x200;
   for(ysdwrite=0;ysdwrite<250;ysdwrite++){
   15d7e:	c3 94       	inc	r12
   15d80:	fa ef       	ldi	r31, 0xFA	; 250
   15d82:	cf 16       	cp	r12, r31
   15d84:	09 f0       	breq	.+2      	; 0x15d88 <mmc_write+0x136>
   15d86:	a6 cf       	rjmp	.-180    	; 0x15cd4 <mmc_write+0x82>
   15d88:	f8 cf       	rjmp	.-16     	; 0x15d7a <mmc_write+0x128>
	      break;
	  }
    }

   for (xsdwrite=0;xsdwrite<9;xsdwrite++){
        write_SPI(0xFF);
   15d8a:	8f ef       	ldi	r24, 0xFF	; 255
   15d8c:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
          uart_printf(0,1,PSTR("Cmd Response OK")); 
	      break;
	  }
    }

   for (xsdwrite=0;xsdwrite<9;xsdwrite++){
   15d90:	1f 5f       	subi	r17, 0xFF	; 255
   15d92:	19 30       	cpi	r17, 0x09	; 9
   15d94:	d1 f7       	brne	.-12     	; 0x15d8a <mmc_write+0x138>
        write_SPI(0xFF);
    }
   write_SPI(0xFE);
   15d96:	8e ef       	ldi	r24, 0xFE	; 254
   15d98:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15d9c:	00 e0       	ldi	r16, 0x00	; 0
   15d9e:	10 e0       	ldi	r17, 0x00	; 0
   
   for(xsdwcount=0;xsdwcount<512;xsdwcount++){
      write_SPI(MMC_Buffer[xsdwcount]);
   15da0:	f8 01       	movw	r30, r16
   15da2:	e3 5e       	subi	r30, 0xE3	; 227
   15da4:	f6 4f       	sbci	r31, 0xF6	; 246
   15da6:	80 81       	ld	r24, Z
   15da8:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   for (xsdwrite=0;xsdwrite<9;xsdwrite++){
        write_SPI(0xFF);
    }
   write_SPI(0xFE);
   
   for(xsdwcount=0;xsdwcount<512;xsdwcount++){
   15dac:	0f 5f       	subi	r16, 0xFF	; 255
   15dae:	1f 4f       	sbci	r17, 0xFF	; 255
   15db0:	82 e0       	ldi	r24, 0x02	; 2
   15db2:	00 30       	cpi	r16, 0x00	; 0
   15db4:	18 07       	cpc	r17, r24
   15db6:	a1 f7       	brne	.-24     	; 0x15da0 <mmc_write+0x14e>
      write_SPI(MMC_Buffer[xsdwcount]);
    }
   write_SPI(0xFF);
   15db8:	8f ef       	ldi	r24, 0xFF	; 255
   15dba:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   write_SPI(0xFF);
   15dbe:	8f ef       	ldi	r24, 0xFF	; 255
   15dc0:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   15dc4:	00 e0       	ldi	r16, 0x00	; 0
   
   for (ysdwrite=0;ysdwrite<250;ysdwrite++){
      SPDR=0xFF;
   15dc6:	bb 24       	eor	r11, r11
   15dc8:	ba 94       	dec	r11
   15dca:	7e 01       	movw	r14, r28
   15dcc:	08 94       	sec
   15dce:	e1 1c       	adc	r14, r1
   15dd0:	f1 1c       	adc	r15, r1
      if (xsdwrite==0x05){
          sprintf_P(strSend,PSTR("Write Sucessfull"));
	      uart_print(0,1,strSend);
	      break;
	  }else{
	      sprintf_P(strSend,PSTR("MMC Write Failed"));
   15dd2:	4b e9       	ldi	r20, 0x9B	; 155
   15dd4:	c4 2e       	mov	r12, r20
   15dd6:	44 e2       	ldi	r20, 0x24	; 36
   15dd8:	d4 2e       	mov	r13, r20
    }
   write_SPI(0xFF);
   write_SPI(0xFF);
   
   for (ysdwrite=0;ysdwrite<250;ysdwrite++){
      SPDR=0xFF;
   15dda:	bf b8       	out	0x0f, r11	; 15
   15ddc:	10 e0       	ldi	r17, 0x00	; 0
      for(xsdwrite=0;xsdwrite<9;xsdwrite++){
         if (SPDR==0xFF) write_SPI(0xFF); 
   15dde:	8f b1       	in	r24, 0x0f	; 15
   15de0:	8f 3f       	cpi	r24, 0xFF	; 255
   15de2:	29 f4       	brne	.+10     	; 0x15dee <mmc_write+0x19c>
   15de4:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
   write_SPI(0xFF);
   write_SPI(0xFF);
   
   for (ysdwrite=0;ysdwrite<250;ysdwrite++){
      SPDR=0xFF;
      for(xsdwrite=0;xsdwrite<9;xsdwrite++){
   15de8:	1f 5f       	subi	r17, 0xFF	; 255
   15dea:	19 30       	cpi	r17, 0x09	; 9
   15dec:	c1 f7       	brne	.-16     	; 0x15dde <mmc_write+0x18c>
         if (SPDR==0xFF) write_SPI(0xFF); 
		 else break;
        }
      xsdwrite=SPDR&0x0F;
   15dee:	8f b1       	in	r24, 0x0f	; 15
      if (xsdwrite==0x05){
   15df0:	8f 70       	andi	r24, 0x0F	; 15
   15df2:	85 30       	cpi	r24, 0x05	; 5
   15df4:	d1 f4       	brne	.+52     	; 0x15e2a <mmc_write+0x1d8>
          sprintf_P(strSend,PSTR("Write Sucessfull"));
   15df6:	00 d0       	rcall	.+0      	; 0x15df8 <mmc_write+0x1a6>
   15df8:	00 d0       	rcall	.+0      	; 0x15dfa <mmc_write+0x1a8>
   15dfa:	ad b7       	in	r26, 0x3d	; 61
   15dfc:	be b7       	in	r27, 0x3e	; 62
   15dfe:	12 96       	adiw	r26, 0x02	; 2
   15e00:	fc 92       	st	X, r15
   15e02:	ee 92       	st	-X, r14
   15e04:	11 97       	sbiw	r26, 0x01	; 1
   15e06:	8c ea       	ldi	r24, 0xAC	; 172
   15e08:	94 e2       	ldi	r25, 0x24	; 36
   15e0a:	14 96       	adiw	r26, 0x04	; 4
   15e0c:	9c 93       	st	X, r25
   15e0e:	8e 93       	st	-X, r24
   15e10:	13 97       	sbiw	r26, 0x03	; 3
   15e12:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	      uart_print(0,1,strSend);
   15e16:	0f 90       	pop	r0
   15e18:	0f 90       	pop	r0
   15e1a:	0f 90       	pop	r0
   15e1c:	0f 90       	pop	r0
   15e1e:	80 e0       	ldi	r24, 0x00	; 0
   15e20:	61 e0       	ldi	r22, 0x01	; 1
   15e22:	a7 01       	movw	r20, r14
   15e24:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
   15e28:	16 c0       	rjmp	.+44     	; 0x15e56 <mmc_write+0x204>
	      break;
	  }else{
	      sprintf_P(strSend,PSTR("MMC Write Failed"));
   15e2a:	00 d0       	rcall	.+0      	; 0x15e2c <mmc_write+0x1da>
   15e2c:	00 d0       	rcall	.+0      	; 0x15e2e <mmc_write+0x1dc>
   15e2e:	ed b7       	in	r30, 0x3d	; 61
   15e30:	fe b7       	in	r31, 0x3e	; 62
   15e32:	f2 82       	std	Z+2, r15	; 0x02
   15e34:	e1 82       	std	Z+1, r14	; 0x01
   15e36:	d4 82       	std	Z+4, r13	; 0x04
   15e38:	c3 82       	std	Z+3, r12	; 0x03
   15e3a:	0e 94 3c b1 	call	0x16278	; 0x16278 <sprintf_P>
	      uart_print(0,1,strSend);
   15e3e:	0f 90       	pop	r0
   15e40:	0f 90       	pop	r0
   15e42:	0f 90       	pop	r0
   15e44:	0f 90       	pop	r0
   15e46:	80 e0       	ldi	r24, 0x00	; 0
   15e48:	61 e0       	ldi	r22, 0x01	; 1
   15e4a:	a7 01       	movw	r20, r14
   15e4c:	0e 94 d5 ab 	call	0x157aa	; 0x157aa <uart_print>
      write_SPI(MMC_Buffer[xsdwcount]);
    }
   write_SPI(0xFF);
   write_SPI(0xFF);
   
   for (ysdwrite=0;ysdwrite<250;ysdwrite++){
   15e50:	0e 5f       	subi	r16, 0xFE	; 254
   15e52:	0a 3f       	cpi	r16, 0xFA	; 250
   15e54:	11 f6       	brne	.-124    	; 0x15dda <mmc_write+0x188>
	  }

      ysdwrite++;
    }

   SPDR=0xFF;
   15e56:	8f ef       	ldi	r24, 0xFF	; 255
   15e58:	8f b9       	out	0x0f, r24	; 15
   15e5a:	10 e0       	ldi	r17, 0x00	; 0
   for(ysdwrite=0;ysdwrite<250;ysdwrite++){
      write_SPI(0xFF);
   15e5c:	8f ef       	ldi	r24, 0xFF	; 255
   15e5e:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      if (SPDR==0x00) break;      
   15e62:	8f b1       	in	r24, 0x0f	; 15
   15e64:	88 23       	and	r24, r24
   15e66:	19 f0       	breq	.+6      	; 0x15e6e <mmc_write+0x21c>

      ysdwrite++;
    }

   SPDR=0xFF;
   for(ysdwrite=0;ysdwrite<250;ysdwrite++){
   15e68:	1f 5f       	subi	r17, 0xFF	; 255
   15e6a:	1a 3f       	cpi	r17, 0xFA	; 250
   15e6c:	b9 f7       	brne	.-18     	; 0x15e5c <mmc_write+0x20a>
      write_SPI(0xFF);
      if (SPDR==0x00) break;      
    }
	
   SPDR=0xFF;   
   15e6e:	8f ef       	ldi	r24, 0xFF	; 255
   15e70:	8f b9       	out	0x0f, r24	; 15
   15e72:	10 e0       	ldi	r17, 0x00	; 0
   for (ysdwrite=0;ysdwrite<250;ysdwrite++){
      write_SPI(0xFF);
   15e74:	8f ef       	ldi	r24, 0xFF	; 255
   15e76:	0e 94 ee a9 	call	0x153dc	; 0x153dc <write_SPI>
      if (SPDR!=0x00) break;
   15e7a:	8f b1       	in	r24, 0x0f	; 15
   15e7c:	88 23       	and	r24, r24
   15e7e:	19 f4       	brne	.+6      	; 0x15e86 <mmc_write+0x234>
      write_SPI(0xFF);
      if (SPDR==0x00) break;      
    }
	
   SPDR=0xFF;   
   for (ysdwrite=0;ysdwrite<250;ysdwrite++){
   15e80:	1f 5f       	subi	r17, 0xFF	; 255
   15e82:	1a 3f       	cpi	r17, 0xFA	; 250
   15e84:	b9 f7       	brne	.-18     	; 0x15e74 <mmc_write+0x222>
      write_SPI(0xFF);
      if (SPDR!=0x00) break;
      }
   MMC_CS_DEASSERT;
   15e86:	80 e0       	ldi	r24, 0x00	; 0
   15e88:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   //sbi(MMC_PORT, MMC_PIN);
}
   15e8c:	6e 96       	adiw	r28, 0x1e	; 30
   15e8e:	0f b6       	in	r0, 0x3f	; 63
   15e90:	f8 94       	cli
   15e92:	de bf       	out	0x3e, r29	; 62
   15e94:	0f be       	out	0x3f, r0	; 63
   15e96:	cd bf       	out	0x3d, r28	; 61
   15e98:	cf 91       	pop	r28
   15e9a:	df 91       	pop	r29
   15e9c:	1f 91       	pop	r17
   15e9e:	0f 91       	pop	r16
   15ea0:	ff 90       	pop	r15
   15ea2:	ef 90       	pop	r14
   15ea4:	df 90       	pop	r13
   15ea6:	cf 90       	pop	r12
   15ea8:	bf 90       	pop	r11
   15eaa:	af 90       	pop	r10
   15eac:	9f 90       	pop	r9
   15eae:	8f 90       	pop	r8
   15eb0:	7f 90       	pop	r7
   15eb2:	6f 90       	pop	r6
   15eb4:	5f 90       	pop	r5
   15eb6:	4f 90       	pop	r4
   15eb8:	08 95       	ret

00015eba <mmc_command>:
	mmc_command(MMC_SET_BLOCK_LEN, 512);

	return 0;
}

unsigned char mmc_command(unsigned char cmd, unsigned long arg){
   15eba:	df 92       	push	r13
   15ebc:	ef 92       	push	r14
   15ebe:	ff 92       	push	r15
   15ec0:	0f 93       	push	r16
   15ec2:	1f 93       	push	r17
   15ec4:	d8 2e       	mov	r13, r24
   15ec6:	7a 01       	movw	r14, r20
   15ec8:	8b 01       	movw	r16, r22
	unsigned char response, retry = 0;

	MMC_CS_ASSERT;
   15eca:	82 e0       	ldi	r24, 0x02	; 2
   15ecc:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>

	spi(cmd | 0x40);
   15ed0:	8d 2d       	mov	r24, r13
   15ed2:	80 64       	ori	r24, 0x40	; 64
   15ed4:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	spi(arg >> 24);
   15ed8:	81 2f       	mov	r24, r17
   15eda:	99 27       	eor	r25, r25
   15edc:	aa 27       	eor	r26, r26
   15ede:	bb 27       	eor	r27, r27
   15ee0:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	spi(arg >> 16);
   15ee4:	c8 01       	movw	r24, r16
   15ee6:	aa 27       	eor	r26, r26
   15ee8:	bb 27       	eor	r27, r27
   15eea:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	spi(arg >> 8);
   15eee:	bb 27       	eor	r27, r27
   15ef0:	a1 2f       	mov	r26, r17
   15ef2:	90 2f       	mov	r25, r16
   15ef4:	8f 2d       	mov	r24, r15
   15ef6:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	spi(arg);
   15efa:	8e 2d       	mov	r24, r14
   15efc:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	spi(0x95);
   15f00:	85 e9       	ldi	r24, 0x95	; 149
   15f02:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   15f06:	10 e0       	ldi	r17, 0x00	; 0
   15f08:	02 c0       	rjmp	.+4      	; 0x15f0e <mmc_command+0x54>

	while((response = spi(0xFF)) == 0xFF)
   15f0a:	11 50       	subi	r17, 0x01	; 1
		if(retry++ > 0xFE)
   15f0c:	31 f0       	breq	.+12     	; 0x15f1a <mmc_command+0x60>
	spi(arg >> 16);
	spi(arg >> 8);
	spi(arg);
	spi(0x95);

	while((response = spi(0xFF)) == 0xFF)
   15f0e:	8f ef       	ldi	r24, 0xFF	; 255
   15f10:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   15f14:	08 2f       	mov	r16, r24
   15f16:	8f 3f       	cpi	r24, 0xFF	; 255
   15f18:	c1 f3       	breq	.-16     	; 0x15f0a <mmc_command+0x50>
		if(retry++ > 0xFE)
			break;

	spi(0xFF);
   15f1a:	8f ef       	ldi	r24, 0xFF	; 255
   15f1c:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	MMC_CS_DEASSERT;
   15f20:	80 e0       	ldi	r24, 0x00	; 0
   15f22:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>

	return response;
}
   15f26:	80 2f       	mov	r24, r16
   15f28:	1f 91       	pop	r17
   15f2a:	0f 91       	pop	r16
   15f2c:	ff 90       	pop	r15
   15f2e:	ef 90       	pop	r14
   15f30:	df 90       	pop	r13
   15f32:	08 95       	ret

00015f34 <mmc_erase>:

unsigned char mmc_erase(unsigned long startblock, unsigned long totalblocks){
   15f34:	af 92       	push	r10
   15f36:	bf 92       	push	r11
   15f38:	cf 92       	push	r12
   15f3a:	df 92       	push	r13
   15f3c:	ef 92       	push	r14
   15f3e:	ff 92       	push	r15
   15f40:	0f 93       	push	r16
   15f42:	1f 93       	push	r17
   15f44:	7b 01       	movw	r14, r22
   15f46:	8c 01       	movw	r16, r24
   15f48:	59 01       	movw	r10, r18
   15f4a:	6a 01       	movw	r12, r20
	unsigned char response;

	response = mmc_command(MMC_ERASE_BLOCK_START_ADDR, startblock << 9);
   15f4c:	ab 01       	movw	r20, r22
   15f4e:	bc 01       	movw	r22, r24
   15f50:	29 e0       	ldi	r18, 0x09	; 9
   15f52:	44 0f       	add	r20, r20
   15f54:	55 1f       	adc	r21, r21
   15f56:	66 1f       	adc	r22, r22
   15f58:	77 1f       	adc	r23, r23
   15f5a:	2a 95       	dec	r18
   15f5c:	d1 f7       	brne	.-12     	; 0x15f52 <mmc_erase+0x1e>
   15f5e:	80 e2       	ldi	r24, 0x20	; 32
   15f60:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
	if(response != 0x00)
   15f64:	88 23       	and	r24, r24
   15f66:	f1 f4       	brne	.+60     	; 0x15fa4 <mmc_erase+0x70>
		return response;

	response = mmc_command(MMC_ERASE_BLOCK_END_ADDR,(startblock + totalblocks - 1) << 9);
   15f68:	08 94       	sec
   15f6a:	e1 08       	sbc	r14, r1
   15f6c:	f1 08       	sbc	r15, r1
   15f6e:	01 09       	sbc	r16, r1
   15f70:	11 09       	sbc	r17, r1
   15f72:	ea 0c       	add	r14, r10
   15f74:	fb 1c       	adc	r15, r11
   15f76:	0c 1d       	adc	r16, r12
   15f78:	1d 1d       	adc	r17, r13
   15f7a:	99 e0       	ldi	r25, 0x09	; 9
   15f7c:	ee 0c       	add	r14, r14
   15f7e:	ff 1c       	adc	r15, r15
   15f80:	00 1f       	adc	r16, r16
   15f82:	11 1f       	adc	r17, r17
   15f84:	9a 95       	dec	r25
   15f86:	d1 f7       	brne	.-12     	; 0x15f7c <mmc_erase+0x48>
   15f88:	81 e2       	ldi	r24, 0x21	; 33
   15f8a:	b8 01       	movw	r22, r16
   15f8c:	a7 01       	movw	r20, r14
   15f8e:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
	if(response != 0x00)
   15f92:	88 23       	and	r24, r24
   15f94:	39 f4       	brne	.+14     	; 0x15fa4 <mmc_erase+0x70>
		return response;

	response = mmc_command(MMC_ERASE_SELECTED_BLOCKS, 0);
   15f96:	86 e2       	ldi	r24, 0x26	; 38
   15f98:	40 e0       	ldi	r20, 0x00	; 0
   15f9a:	50 e0       	ldi	r21, 0x00	; 0
   15f9c:	60 e0       	ldi	r22, 0x00	; 0
   15f9e:	70 e0       	ldi	r23, 0x00	; 0
   15fa0:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
	if(response != 0x00)
		return response;

	return 0;
}
   15fa4:	1f 91       	pop	r17
   15fa6:	0f 91       	pop	r16
   15fa8:	ff 90       	pop	r15
   15faa:	ef 90       	pop	r14
   15fac:	df 90       	pop	r13
   15fae:	cf 90       	pop	r12
   15fb0:	bf 90       	pop	r11
   15fb2:	af 90       	pop	r10
   15fb4:	08 95       	ret

00015fb6 <mmc_writesingleblock>:
	MMC_CS_DEASSERT;

	return 0;
}

unsigned char mmc_writesingleblock(unsigned long startblock){
   15fb6:	1f 93       	push	r17
   15fb8:	cf 93       	push	r28
   15fba:	df 93       	push	r29
   15fbc:	ab 01       	movw	r20, r22
   15fbe:	bc 01       	movw	r22, r24
	unsigned char response;
	unsigned int i, retry=0;

	response = mmc_command(MMC_WRITE_SINGLE_BLOCK, startblock << 9);
   15fc0:	39 e0       	ldi	r19, 0x09	; 9
   15fc2:	44 0f       	add	r20, r20
   15fc4:	55 1f       	adc	r21, r21
   15fc6:	66 1f       	adc	r22, r22
   15fc8:	77 1f       	adc	r23, r23
   15fca:	3a 95       	dec	r19
   15fcc:	d1 f7       	brne	.-12     	; 0x15fc2 <mmc_writesingleblock+0xc>
   15fce:	88 e1       	ldi	r24, 0x18	; 24
   15fd0:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
	if(response != 0x00)
   15fd4:	88 23       	and	r24, r24
   15fd6:	11 f0       	breq	.+4      	; 0x15fdc <mmc_writesingleblock+0x26>
   15fd8:	18 2f       	mov	r17, r24
   15fda:	4e c0       	rjmp	.+156    	; 0x16078 <mmc_writesingleblock+0xc2>
		return response;

	MMC_CS_ASSERT;
   15fdc:	82 e0       	ldi	r24, 0x02	; 2
   15fde:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>

	spi(0xFE);
   15fe2:	8e ef       	ldi	r24, 0xFE	; 254
   15fe4:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   15fe8:	c0 e0       	ldi	r28, 0x00	; 0
   15fea:	d0 e0       	ldi	r29, 0x00	; 0

	for(i = 0; i < 512; i++)
		spi(MMC_Buffer[i]);
   15fec:	fe 01       	movw	r30, r28
   15fee:	e3 5e       	subi	r30, 0xE3	; 227
   15ff0:	f6 4f       	sbci	r31, 0xF6	; 246
   15ff2:	80 81       	ld	r24, Z
   15ff4:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>

	MMC_CS_ASSERT;

	spi(0xFE);

	for(i = 0; i < 512; i++)
   15ff8:	21 96       	adiw	r28, 0x01	; 1
   15ffa:	82 e0       	ldi	r24, 0x02	; 2
   15ffc:	c0 30       	cpi	r28, 0x00	; 0
   15ffe:	d8 07       	cpc	r29, r24
   16000:	a9 f7       	brne	.-22     	; 0x15fec <mmc_writesingleblock+0x36>
		spi(MMC_Buffer[i]);

	spi(0xFF);
   16002:	8f ef       	ldi	r24, 0xFF	; 255
   16004:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	spi(0xFF);
   16008:	8f ef       	ldi	r24, 0xFF	; 255
   1600a:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>

	response = spi(0xFF);
   1600e:	8f ef       	ldi	r24, 0xFF	; 255
   16010:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   16014:	18 2f       	mov	r17, r24

	if((response & 0x1F) != 0x05){
   16016:	8f 71       	andi	r24, 0x1F	; 31
   16018:	85 30       	cpi	r24, 0x05	; 5
   1601a:	51 f0       	breq	.+20     	; 0x16030 <mmc_writesingleblock+0x7a>
	  MMC_CS_DEASSERT;
   1601c:	80 e0       	ldi	r24, 0x00	; 0
   1601e:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   16022:	2a c0       	rjmp	.+84     	; 0x16078 <mmc_writesingleblock+0xc2>
	  return response;
	}

	while(!spi(0xFF))
		if(retry++ > 0xFFFE){
   16024:	8f ef       	ldi	r24, 0xFF	; 255
   16026:	cf 3f       	cpi	r28, 0xFF	; 255
   16028:	d8 07       	cpc	r29, r24
   1602a:	b9 f0       	breq	.+46     	; 0x1605a <mmc_writesingleblock+0xa4>
   1602c:	21 96       	adiw	r28, 0x01	; 1
   1602e:	02 c0       	rjmp	.+4      	; 0x16034 <mmc_writesingleblock+0x7e>
			MMC_CS_DEASSERT;
			return 1;
   16030:	c0 e0       	ldi	r28, 0x00	; 0
   16032:	d0 e0       	ldi	r29, 0x00	; 0
	if((response & 0x1F) != 0x05){
	  MMC_CS_DEASSERT;
	  return response;
	}

	while(!spi(0xFF))
   16034:	8f ef       	ldi	r24, 0xFF	; 255
   16036:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   1603a:	88 23       	and	r24, r24
   1603c:	99 f3       	breq	.-26     	; 0x16024 <mmc_writesingleblock+0x6e>
		if(retry++ > 0xFFFE){
			MMC_CS_DEASSERT;
			return 1;
		}

	MMC_CS_DEASSERT;
   1603e:	80 e0       	ldi	r24, 0x00	; 0
   16040:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
	spi(0xFF);
   16044:	8f ef       	ldi	r24, 0xFF	; 255
   16046:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	MMC_CS_ASSERT;
   1604a:	82 e0       	ldi	r24, 0x02	; 2
   1604c:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   16050:	0a c0       	rjmp	.+20     	; 0x16066 <mmc_writesingleblock+0xb0>

	while(!spi(0xFF))
		if(retry++ > 0xFFFE){
   16052:	8f ef       	ldi	r24, 0xFF	; 255
   16054:	cf 3f       	cpi	r28, 0xFF	; 255
   16056:	d8 07       	cpc	r29, r24
   16058:	29 f4       	brne	.+10     	; 0x16064 <mmc_writesingleblock+0xae>
			MMC_CS_DEASSERT;
   1605a:	80 e0       	ldi	r24, 0x00	; 0
   1605c:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   16060:	11 e0       	ldi	r17, 0x01	; 1
   16062:	0a c0       	rjmp	.+20     	; 0x16078 <mmc_writesingleblock+0xc2>
	MMC_CS_DEASSERT;
	spi(0xFF);
	MMC_CS_ASSERT;

	while(!spi(0xFF))
		if(retry++ > 0xFFFE){
   16064:	21 96       	adiw	r28, 0x01	; 1

	MMC_CS_DEASSERT;
	spi(0xFF);
	MMC_CS_ASSERT;

	while(!spi(0xFF))
   16066:	8f ef       	ldi	r24, 0xFF	; 255
   16068:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   1606c:	88 23       	and	r24, r24
   1606e:	89 f3       	breq	.-30     	; 0x16052 <mmc_writesingleblock+0x9c>
		if(retry++ > 0xFFFE){
			MMC_CS_DEASSERT;
			return 1;
		}
	MMC_CS_DEASSERT;
   16070:	80 e0       	ldi	r24, 0x00	; 0
   16072:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   16076:	10 e0       	ldi	r17, 0x00	; 0

	return 0;
}
   16078:	81 2f       	mov	r24, r17
   1607a:	df 91       	pop	r29
   1607c:	cf 91       	pop	r28
   1607e:	1f 91       	pop	r17
   16080:	08 95       	ret

00016082 <mmc_readsingleblock>:
		return response;

	return 0;
}

unsigned char mmc_readsingleblock(unsigned long startblock){
   16082:	1f 93       	push	r17
   16084:	cf 93       	push	r28
   16086:	df 93       	push	r29
   16088:	ab 01       	movw	r20, r22
   1608a:	bc 01       	movw	r22, r24
	unsigned char response;
	unsigned int i, retry = 0;

	response = mmc_command(MMC_READ_SINGLE_BLOCK, startblock << 9);
   1608c:	e9 e0       	ldi	r30, 0x09	; 9
   1608e:	44 0f       	add	r20, r20
   16090:	55 1f       	adc	r21, r21
   16092:	66 1f       	adc	r22, r22
   16094:	77 1f       	adc	r23, r23
   16096:	ea 95       	dec	r30
   16098:	d1 f7       	brne	.-12     	; 0x1608e <mmc_readsingleblock+0xc>
   1609a:	81 e1       	ldi	r24, 0x11	; 17
   1609c:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
   160a0:	18 2f       	mov	r17, r24

	if(response != 0x00)
   160a2:	88 23       	and	r24, r24
   160a4:	61 f5       	brne	.+88     	; 0x160fe <mmc_readsingleblock+0x7c>
		return response;

	MMC_CS_ASSERT;
   160a6:	82 e0       	ldi	r24, 0x02	; 2
   160a8:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   160ac:	c0 e0       	ldi	r28, 0x00	; 0
   160ae:	d0 e0       	ldi	r29, 0x00	; 0
   160b0:	07 c0       	rjmp	.+14     	; 0x160c0 <mmc_readsingleblock+0x3e>

	retry = 0;
	while(spi(0xFF) != 0xFE)
   160b2:	21 97       	sbiw	r28, 0x01	; 1
		if(retry++ > 0xFFFE){
   160b4:	29 f4       	brne	.+10     	; 0x160c0 <mmc_readsingleblock+0x3e>
			MMC_CS_DEASSERT;
   160b6:	80 e0       	ldi	r24, 0x00	; 0
   160b8:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   160bc:	11 e0       	ldi	r17, 0x01	; 1
   160be:	1f c0       	rjmp	.+62     	; 0x160fe <mmc_readsingleblock+0x7c>
		return response;

	MMC_CS_ASSERT;

	retry = 0;
	while(spi(0xFF) != 0xFE)
   160c0:	8f ef       	ldi	r24, 0xFF	; 255
   160c2:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   160c6:	8e 3f       	cpi	r24, 0xFE	; 254
   160c8:	a1 f7       	brne	.-24     	; 0x160b2 <mmc_readsingleblock+0x30>
   160ca:	c0 e0       	ldi	r28, 0x00	; 0
   160cc:	d0 e0       	ldi	r29, 0x00	; 0
			MMC_CS_DEASSERT;
			return 1;
		}

	for(i = 0; i < 512; i++)
		MMC_Buffer[i] = spi(0xFF);
   160ce:	8f ef       	ldi	r24, 0xFF	; 255
   160d0:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   160d4:	fe 01       	movw	r30, r28
   160d6:	e3 5e       	subi	r30, 0xE3	; 227
   160d8:	f6 4f       	sbci	r31, 0xF6	; 246
   160da:	80 83       	st	Z, r24
		if(retry++ > 0xFFFE){
			MMC_CS_DEASSERT;
			return 1;
		}

	for(i = 0; i < 512; i++)
   160dc:	21 96       	adiw	r28, 0x01	; 1
   160de:	82 e0       	ldi	r24, 0x02	; 2
   160e0:	c0 30       	cpi	r28, 0x00	; 0
   160e2:	d8 07       	cpc	r29, r24
   160e4:	a1 f7       	brne	.-24     	; 0x160ce <mmc_readsingleblock+0x4c>
		MMC_Buffer[i] = spi(0xFF);

	spi(0xFF);
   160e6:	8f ef       	ldi	r24, 0xFF	; 255
   160e8:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	spi(0xFF);
   160ec:	8f ef       	ldi	r24, 0xFF	; 255
   160ee:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>

	spi(0xFF);
   160f2:	8f ef       	ldi	r24, 0xFF	; 255
   160f4:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	MMC_CS_DEASSERT;
   160f8:	80 e0       	ldi	r24, 0x00	; 0
   160fa:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>

	return 0;
}
   160fe:	81 2f       	mov	r24, r17
   16100:	df 91       	pop	r29
   16102:	cf 91       	pop	r28
   16104:	1f 91       	pop	r17
   16106:	08 95       	ret

00016108 <mmc_init>:
#include "SPI.h"

#define MMC_CS_ASSERT     spi_enable(SPI_MMC)
#define MMC_CS_DEASSERT   spi_enable(SPI_NONE)

unsigned char mmc_init(void){
   16108:	0f 93       	push	r16
   1610a:	1f 93       	push	r17
	unsigned char i, response, retry = 0 ;

	MMC_CS_ASSERT;
   1610c:	82 e0       	ldi	r24, 0x02	; 2
   1610e:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
   16112:	00 e0       	ldi	r16, 0x00	; 0
   16114:	10 e0       	ldi	r17, 0x00	; 0
	do{
		for(i = 0; i < 10; i++)
			spi(0xFF);
   16116:	8f ef       	ldi	r24, 0xFF	; 255
   16118:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
unsigned char mmc_init(void){
	unsigned char i, response, retry = 0 ;

	MMC_CS_ASSERT;
	do{
		for(i = 0; i < 10; i++)
   1611c:	1f 5f       	subi	r17, 0xFF	; 255
   1611e:	1a 30       	cpi	r17, 0x0A	; 10
   16120:	d1 f7       	brne	.-12     	; 0x16116 <mmc_init+0xe>
			spi(0xFF);
		response = mmc_command(MMC_GO_IDLE_STATE, 0);
   16122:	80 e0       	ldi	r24, 0x00	; 0
   16124:	40 e0       	ldi	r20, 0x00	; 0
   16126:	50 e0       	ldi	r21, 0x00	; 0
   16128:	60 e0       	ldi	r22, 0x00	; 0
   1612a:	70 e0       	ldi	r23, 0x00	; 0
   1612c:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
		retry++;
   16130:	0f 5f       	subi	r16, 0xFF	; 255
		if(retry > 0xFE)
   16132:	0f 3f       	cpi	r16, 0xFF	; 255
   16134:	79 f1       	breq	.+94     	; 0x16194 <mmc_init+0x8c>
			return 1;
	}while(response != 0x01);
   16136:	81 30       	cpi	r24, 0x01	; 1
   16138:	69 f7       	brne	.-38     	; 0x16114 <mmc_init+0xc>

	MMC_CS_DEASSERT;
   1613a:	80 e0       	ldi	r24, 0x00	; 0
   1613c:	0e 94 d2 a9 	call	0x153a4	; 0x153a4 <spi_enable>
	spi(0xFF);
   16140:	8f ef       	ldi	r24, 0xFF	; 255
   16142:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
	spi(0xFF);
   16146:	8f ef       	ldi	r24, 0xFF	; 255
   16148:	0e 94 e9 a9 	call	0x153d2	; 0x153d2 <spi>
   1614c:	10 e0       	ldi	r17, 0x00	; 0

	retry = 0;

	do{
		response = mmc_command(MMC_SEND_OP_COND, 0);
   1614e:	81 e0       	ldi	r24, 0x01	; 1
   16150:	40 e0       	ldi	r20, 0x00	; 0
   16152:	50 e0       	ldi	r21, 0x00	; 0
   16154:	60 e0       	ldi	r22, 0x00	; 0
   16156:	70 e0       	ldi	r23, 0x00	; 0
   16158:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
		response = mmc_command(MMC_SEND_OP_COND, 0);
   1615c:	81 e0       	ldi	r24, 0x01	; 1
   1615e:	40 e0       	ldi	r20, 0x00	; 0
   16160:	50 e0       	ldi	r21, 0x00	; 0
   16162:	60 e0       	ldi	r22, 0x00	; 0
   16164:	70 e0       	ldi	r23, 0x00	; 0
   16166:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
		retry++;
   1616a:	1f 5f       	subi	r17, 0xFF	; 255
		if(retry > 0xFE)
   1616c:	1f 3f       	cpi	r17, 0xFF	; 255
   1616e:	91 f0       	breq	.+36     	; 0x16194 <mmc_init+0x8c>
			return 1;
	}while(response);
   16170:	88 23       	and	r24, r24
   16172:	69 f7       	brne	.-38     	; 0x1614e <mmc_init+0x46>

	mmc_command(MMC_CRC_ON_OFF, MMC_OFF);
   16174:	8b e3       	ldi	r24, 0x3B	; 59
   16176:	40 e0       	ldi	r20, 0x00	; 0
   16178:	50 e0       	ldi	r21, 0x00	; 0
   1617a:	60 e0       	ldi	r22, 0x00	; 0
   1617c:	70 e0       	ldi	r23, 0x00	; 0
   1617e:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
	mmc_command(MMC_SET_BLOCK_LEN, 512);
   16182:	80 e1       	ldi	r24, 0x10	; 16
   16184:	40 e0       	ldi	r20, 0x00	; 0
   16186:	52 e0       	ldi	r21, 0x02	; 2
   16188:	60 e0       	ldi	r22, 0x00	; 0
   1618a:	70 e0       	ldi	r23, 0x00	; 0
   1618c:	0e 94 5d af 	call	0x15eba	; 0x15eba <mmc_command>
   16190:	80 e0       	ldi	r24, 0x00	; 0
   16192:	01 c0       	rjmp	.+2      	; 0x16196 <mmc_init+0x8e>

	return 0;
   16194:	81 e0       	ldi	r24, 0x01	; 1
}
   16196:	1f 91       	pop	r17
   16198:	0f 91       	pop	r16
   1619a:	08 95       	ret

0001619c <atoi>:
   1619c:	fc 01       	movw	r30, r24
   1619e:	88 27       	eor	r24, r24
   161a0:	99 27       	eor	r25, r25
   161a2:	e8 94       	clt
   161a4:	21 91       	ld	r18, Z+
   161a6:	20 32       	cpi	r18, 0x20	; 32
   161a8:	e9 f3       	breq	.-6      	; 0x161a4 <atoi+0x8>
   161aa:	29 30       	cpi	r18, 0x09	; 9
   161ac:	10 f0       	brcs	.+4      	; 0x161b2 <atoi+0x16>
   161ae:	2e 30       	cpi	r18, 0x0E	; 14
   161b0:	c8 f3       	brcs	.-14     	; 0x161a4 <atoi+0x8>
   161b2:	2b 32       	cpi	r18, 0x2B	; 43
   161b4:	41 f0       	breq	.+16     	; 0x161c6 <atoi+0x2a>
   161b6:	2d 32       	cpi	r18, 0x2D	; 45
   161b8:	39 f4       	brne	.+14     	; 0x161c8 <atoi+0x2c>
   161ba:	68 94       	set
   161bc:	04 c0       	rjmp	.+8      	; 0x161c6 <atoi+0x2a>
   161be:	0e 94 34 b1 	call	0x16268	; 0x16268 <__mulhi_const_10>
   161c2:	82 0f       	add	r24, r18
   161c4:	91 1d       	adc	r25, r1
   161c6:	21 91       	ld	r18, Z+
   161c8:	20 53       	subi	r18, 0x30	; 48
   161ca:	2a 30       	cpi	r18, 0x0A	; 10
   161cc:	c0 f3       	brcs	.-16     	; 0x161be <atoi+0x22>
   161ce:	1e f4       	brtc	.+6      	; 0x161d6 <atoi+0x3a>
   161d0:	90 95       	com	r25
   161d2:	81 95       	neg	r24
   161d4:	9f 4f       	sbci	r25, 0xFF	; 255
   161d6:	08 95       	ret

000161d8 <strcpy_P>:
   161d8:	fb 01       	movw	r30, r22
   161da:	dc 01       	movw	r26, r24
   161dc:	05 90       	lpm	r0, Z+
   161de:	0d 92       	st	X+, r0
   161e0:	00 20       	and	r0, r0
   161e2:	e1 f7       	brne	.-8      	; 0x161dc <strcpy_P+0x4>
   161e4:	08 95       	ret

000161e6 <strcmp>:
   161e6:	fb 01       	movw	r30, r22
   161e8:	dc 01       	movw	r26, r24
   161ea:	8d 91       	ld	r24, X+
   161ec:	01 90       	ld	r0, Z+
   161ee:	80 19       	sub	r24, r0
   161f0:	01 10       	cpse	r0, r1
   161f2:	d9 f3       	breq	.-10     	; 0x161ea <strcmp+0x4>
   161f4:	99 0b       	sbc	r25, r25
   161f6:	08 95       	ret

000161f8 <__eerd_block>:
   161f8:	a0 e0       	ldi	r26, 0x00	; 0
   161fa:	b0 e0       	ldi	r27, 0x00	; 0
   161fc:	e2 e0       	ldi	r30, 0x02	; 2
   161fe:	f1 eb       	ldi	r31, 0xB1	; 177
   16200:	0c 94 68 b4 	jmp	0x168d0	; 0x168d0 <__prologue_saves__+0x14>
   16204:	7c 01       	movw	r14, r24
   16206:	eb 01       	movw	r28, r22
   16208:	8a 01       	movw	r16, r20
   1620a:	69 01       	movw	r12, r18
   1620c:	09 c0       	rjmp	.+18     	; 0x16220 <__eerd_block+0x28>
   1620e:	ce 01       	movw	r24, r28
   16210:	21 96       	adiw	r28, 0x01	; 1
   16212:	f6 01       	movw	r30, r12
   16214:	09 95       	icall
   16216:	f7 01       	movw	r30, r14
   16218:	81 93       	st	Z+, r24
   1621a:	7f 01       	movw	r14, r30
   1621c:	01 50       	subi	r16, 0x01	; 1
   1621e:	10 40       	sbci	r17, 0x00	; 0
   16220:	01 15       	cp	r16, r1
   16222:	11 05       	cpc	r17, r1
   16224:	a1 f7       	brne	.-24     	; 0x1620e <__eerd_block+0x16>
   16226:	cd b7       	in	r28, 0x3d	; 61
   16228:	de b7       	in	r29, 0x3e	; 62
   1622a:	e8 e0       	ldi	r30, 0x08	; 8
   1622c:	0c 94 84 b4 	jmp	0x16908	; 0x16908 <__epilogue_restores__+0x14>

00016230 <__eewr_block>:
   16230:	a0 e0       	ldi	r26, 0x00	; 0
   16232:	b0 e0       	ldi	r27, 0x00	; 0
   16234:	ee e1       	ldi	r30, 0x1E	; 30
   16236:	f1 eb       	ldi	r31, 0xB1	; 177
   16238:	0c 94 68 b4 	jmp	0x168d0	; 0x168d0 <__prologue_saves__+0x14>
   1623c:	ec 01       	movw	r28, r24
   1623e:	7b 01       	movw	r14, r22
   16240:	8a 01       	movw	r16, r20
   16242:	69 01       	movw	r12, r18
   16244:	09 c0       	rjmp	.+18     	; 0x16258 <__eewr_block+0x28>
   16246:	ce 01       	movw	r24, r28
   16248:	21 96       	adiw	r28, 0x01	; 1
   1624a:	f7 01       	movw	r30, r14
   1624c:	61 91       	ld	r22, Z+
   1624e:	7f 01       	movw	r14, r30
   16250:	f6 01       	movw	r30, r12
   16252:	09 95       	icall
   16254:	01 50       	subi	r16, 0x01	; 1
   16256:	10 40       	sbci	r17, 0x00	; 0
   16258:	01 15       	cp	r16, r1
   1625a:	11 05       	cpc	r17, r1
   1625c:	a1 f7       	brne	.-24     	; 0x16246 <__eewr_block+0x16>
   1625e:	cd b7       	in	r28, 0x3d	; 61
   16260:	de b7       	in	r29, 0x3e	; 62
   16262:	e8 e0       	ldi	r30, 0x08	; 8
   16264:	0c 94 84 b4 	jmp	0x16908	; 0x16908 <__epilogue_restores__+0x14>

00016268 <__mulhi_const_10>:
   16268:	7a e0       	ldi	r23, 0x0A	; 10
   1626a:	97 9f       	mul	r25, r23
   1626c:	90 2d       	mov	r25, r0
   1626e:	87 9f       	mul	r24, r23
   16270:	80 2d       	mov	r24, r0
   16272:	91 0d       	add	r25, r1
   16274:	11 24       	eor	r1, r1
   16276:	08 95       	ret

00016278 <sprintf_P>:
   16278:	ae e0       	ldi	r26, 0x0E	; 14
   1627a:	b0 e0       	ldi	r27, 0x00	; 0
   1627c:	e2 e4       	ldi	r30, 0x42	; 66
   1627e:	f1 eb       	ldi	r31, 0xB1	; 177
   16280:	0c 94 6c b4 	jmp	0x168d8	; 0x168d8 <__prologue_saves__+0x1c>
   16284:	0d 89       	ldd	r16, Y+21	; 0x15
   16286:	1e 89       	ldd	r17, Y+22	; 0x16
   16288:	8e e0       	ldi	r24, 0x0E	; 14
   1628a:	8c 83       	std	Y+4, r24	; 0x04
   1628c:	1a 83       	std	Y+2, r17	; 0x02
   1628e:	09 83       	std	Y+1, r16	; 0x01
   16290:	8f ef       	ldi	r24, 0xFF	; 255
   16292:	9f e7       	ldi	r25, 0x7F	; 127
   16294:	9e 83       	std	Y+6, r25	; 0x06
   16296:	8d 83       	std	Y+5, r24	; 0x05
   16298:	9e 01       	movw	r18, r28
   1629a:	27 5e       	subi	r18, 0xE7	; 231
   1629c:	3f 4f       	sbci	r19, 0xFF	; 255
   1629e:	ce 01       	movw	r24, r28
   162a0:	01 96       	adiw	r24, 0x01	; 1
   162a2:	6f 89       	ldd	r22, Y+23	; 0x17
   162a4:	78 8d       	ldd	r23, Y+24	; 0x18
   162a6:	a9 01       	movw	r20, r18
   162a8:	0e 94 60 b1 	call	0x162c0	; 0x162c0 <vfprintf>
   162ac:	2f 81       	ldd	r18, Y+7	; 0x07
   162ae:	38 85       	ldd	r19, Y+8	; 0x08
   162b0:	02 0f       	add	r16, r18
   162b2:	13 1f       	adc	r17, r19
   162b4:	f8 01       	movw	r30, r16
   162b6:	10 82       	st	Z, r1
   162b8:	2e 96       	adiw	r28, 0x0e	; 14
   162ba:	e4 e0       	ldi	r30, 0x04	; 4
   162bc:	0c 94 88 b4 	jmp	0x16910	; 0x16910 <__epilogue_restores__+0x1c>

000162c0 <vfprintf>:
   162c0:	ab e0       	ldi	r26, 0x0B	; 11
   162c2:	b0 e0       	ldi	r27, 0x00	; 0
   162c4:	e6 e6       	ldi	r30, 0x66	; 102
   162c6:	f1 eb       	ldi	r31, 0xB1	; 177
   162c8:	0c 94 5e b4 	jmp	0x168bc	; 0x168bc <__prologue_saves__>
   162cc:	3c 01       	movw	r6, r24
   162ce:	2b 01       	movw	r4, r22
   162d0:	5a 01       	movw	r10, r20
   162d2:	fc 01       	movw	r30, r24
   162d4:	17 82       	std	Z+7, r1	; 0x07
   162d6:	16 82       	std	Z+6, r1	; 0x06
   162d8:	83 81       	ldd	r24, Z+3	; 0x03
   162da:	81 fd       	sbrc	r24, 1
   162dc:	03 c0       	rjmp	.+6      	; 0x162e4 <vfprintf+0x24>
   162de:	6f ef       	ldi	r22, 0xFF	; 255
   162e0:	7f ef       	ldi	r23, 0xFF	; 255
   162e2:	c6 c1       	rjmp	.+908    	; 0x16670 <vfprintf+0x3b0>
   162e4:	9a e0       	ldi	r25, 0x0A	; 10
   162e6:	89 2e       	mov	r8, r25
   162e8:	1e 01       	movw	r2, r28
   162ea:	08 94       	sec
   162ec:	21 1c       	adc	r2, r1
   162ee:	31 1c       	adc	r3, r1
   162f0:	f3 01       	movw	r30, r6
   162f2:	23 81       	ldd	r18, Z+3	; 0x03
   162f4:	f2 01       	movw	r30, r4
   162f6:	23 fd       	sbrc	r18, 3
   162f8:	85 91       	lpm	r24, Z+
   162fa:	23 ff       	sbrs	r18, 3
   162fc:	81 91       	ld	r24, Z+
   162fe:	2f 01       	movw	r4, r30
   16300:	88 23       	and	r24, r24
   16302:	09 f4       	brne	.+2      	; 0x16306 <vfprintf+0x46>
   16304:	b2 c1       	rjmp	.+868    	; 0x1666a <vfprintf+0x3aa>
   16306:	85 32       	cpi	r24, 0x25	; 37
   16308:	39 f4       	brne	.+14     	; 0x16318 <vfprintf+0x58>
   1630a:	23 fd       	sbrc	r18, 3
   1630c:	85 91       	lpm	r24, Z+
   1630e:	23 ff       	sbrs	r18, 3
   16310:	81 91       	ld	r24, Z+
   16312:	2f 01       	movw	r4, r30
   16314:	85 32       	cpi	r24, 0x25	; 37
   16316:	29 f4       	brne	.+10     	; 0x16322 <vfprintf+0x62>
   16318:	90 e0       	ldi	r25, 0x00	; 0
   1631a:	b3 01       	movw	r22, r6
   1631c:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   16320:	e7 cf       	rjmp	.-50     	; 0x162f0 <vfprintf+0x30>
   16322:	98 2f       	mov	r25, r24
   16324:	ff 24       	eor	r15, r15
   16326:	ee 24       	eor	r14, r14
   16328:	99 24       	eor	r9, r9
   1632a:	ff e1       	ldi	r31, 0x1F	; 31
   1632c:	ff 15       	cp	r31, r15
   1632e:	d0 f0       	brcs	.+52     	; 0x16364 <vfprintf+0xa4>
   16330:	9b 32       	cpi	r25, 0x2B	; 43
   16332:	69 f0       	breq	.+26     	; 0x1634e <vfprintf+0x8e>
   16334:	9c 32       	cpi	r25, 0x2C	; 44
   16336:	28 f4       	brcc	.+10     	; 0x16342 <vfprintf+0x82>
   16338:	90 32       	cpi	r25, 0x20	; 32
   1633a:	59 f0       	breq	.+22     	; 0x16352 <vfprintf+0x92>
   1633c:	93 32       	cpi	r25, 0x23	; 35
   1633e:	91 f4       	brne	.+36     	; 0x16364 <vfprintf+0xa4>
   16340:	0e c0       	rjmp	.+28     	; 0x1635e <vfprintf+0x9e>
   16342:	9d 32       	cpi	r25, 0x2D	; 45
   16344:	49 f0       	breq	.+18     	; 0x16358 <vfprintf+0x98>
   16346:	90 33       	cpi	r25, 0x30	; 48
   16348:	69 f4       	brne	.+26     	; 0x16364 <vfprintf+0xa4>
   1634a:	41 e0       	ldi	r20, 0x01	; 1
   1634c:	24 c0       	rjmp	.+72     	; 0x16396 <vfprintf+0xd6>
   1634e:	52 e0       	ldi	r21, 0x02	; 2
   16350:	f5 2a       	or	r15, r21
   16352:	84 e0       	ldi	r24, 0x04	; 4
   16354:	f8 2a       	or	r15, r24
   16356:	28 c0       	rjmp	.+80     	; 0x163a8 <vfprintf+0xe8>
   16358:	98 e0       	ldi	r25, 0x08	; 8
   1635a:	f9 2a       	or	r15, r25
   1635c:	25 c0       	rjmp	.+74     	; 0x163a8 <vfprintf+0xe8>
   1635e:	e0 e1       	ldi	r30, 0x10	; 16
   16360:	fe 2a       	or	r15, r30
   16362:	22 c0       	rjmp	.+68     	; 0x163a8 <vfprintf+0xe8>
   16364:	f7 fc       	sbrc	r15, 7
   16366:	29 c0       	rjmp	.+82     	; 0x163ba <vfprintf+0xfa>
   16368:	89 2f       	mov	r24, r25
   1636a:	80 53       	subi	r24, 0x30	; 48
   1636c:	8a 30       	cpi	r24, 0x0A	; 10
   1636e:	70 f4       	brcc	.+28     	; 0x1638c <vfprintf+0xcc>
   16370:	f6 fe       	sbrs	r15, 6
   16372:	05 c0       	rjmp	.+10     	; 0x1637e <vfprintf+0xbe>
   16374:	98 9c       	mul	r9, r8
   16376:	90 2c       	mov	r9, r0
   16378:	11 24       	eor	r1, r1
   1637a:	98 0e       	add	r9, r24
   1637c:	15 c0       	rjmp	.+42     	; 0x163a8 <vfprintf+0xe8>
   1637e:	e8 9c       	mul	r14, r8
   16380:	e0 2c       	mov	r14, r0
   16382:	11 24       	eor	r1, r1
   16384:	e8 0e       	add	r14, r24
   16386:	f0 e2       	ldi	r31, 0x20	; 32
   16388:	ff 2a       	or	r15, r31
   1638a:	0e c0       	rjmp	.+28     	; 0x163a8 <vfprintf+0xe8>
   1638c:	9e 32       	cpi	r25, 0x2E	; 46
   1638e:	29 f4       	brne	.+10     	; 0x1639a <vfprintf+0xda>
   16390:	f6 fc       	sbrc	r15, 6
   16392:	6b c1       	rjmp	.+726    	; 0x1666a <vfprintf+0x3aa>
   16394:	40 e4       	ldi	r20, 0x40	; 64
   16396:	f4 2a       	or	r15, r20
   16398:	07 c0       	rjmp	.+14     	; 0x163a8 <vfprintf+0xe8>
   1639a:	9c 36       	cpi	r25, 0x6C	; 108
   1639c:	19 f4       	brne	.+6      	; 0x163a4 <vfprintf+0xe4>
   1639e:	50 e8       	ldi	r21, 0x80	; 128
   163a0:	f5 2a       	or	r15, r21
   163a2:	02 c0       	rjmp	.+4      	; 0x163a8 <vfprintf+0xe8>
   163a4:	98 36       	cpi	r25, 0x68	; 104
   163a6:	49 f4       	brne	.+18     	; 0x163ba <vfprintf+0xfa>
   163a8:	f2 01       	movw	r30, r4
   163aa:	23 fd       	sbrc	r18, 3
   163ac:	95 91       	lpm	r25, Z+
   163ae:	23 ff       	sbrs	r18, 3
   163b0:	91 91       	ld	r25, Z+
   163b2:	2f 01       	movw	r4, r30
   163b4:	99 23       	and	r25, r25
   163b6:	09 f0       	breq	.+2      	; 0x163ba <vfprintf+0xfa>
   163b8:	b8 cf       	rjmp	.-144    	; 0x1632a <vfprintf+0x6a>
   163ba:	89 2f       	mov	r24, r25
   163bc:	85 54       	subi	r24, 0x45	; 69
   163be:	83 30       	cpi	r24, 0x03	; 3
   163c0:	18 f0       	brcs	.+6      	; 0x163c8 <vfprintf+0x108>
   163c2:	80 52       	subi	r24, 0x20	; 32
   163c4:	83 30       	cpi	r24, 0x03	; 3
   163c6:	38 f4       	brcc	.+14     	; 0x163d6 <vfprintf+0x116>
   163c8:	44 e0       	ldi	r20, 0x04	; 4
   163ca:	50 e0       	ldi	r21, 0x00	; 0
   163cc:	a4 0e       	add	r10, r20
   163ce:	b5 1e       	adc	r11, r21
   163d0:	5f e3       	ldi	r21, 0x3F	; 63
   163d2:	59 83       	std	Y+1, r21	; 0x01
   163d4:	0f c0       	rjmp	.+30     	; 0x163f4 <vfprintf+0x134>
   163d6:	93 36       	cpi	r25, 0x63	; 99
   163d8:	31 f0       	breq	.+12     	; 0x163e6 <vfprintf+0x126>
   163da:	93 37       	cpi	r25, 0x73	; 115
   163dc:	79 f0       	breq	.+30     	; 0x163fc <vfprintf+0x13c>
   163de:	93 35       	cpi	r25, 0x53	; 83
   163e0:	09 f0       	breq	.+2      	; 0x163e4 <vfprintf+0x124>
   163e2:	56 c0       	rjmp	.+172    	; 0x16490 <vfprintf+0x1d0>
   163e4:	20 c0       	rjmp	.+64     	; 0x16426 <vfprintf+0x166>
   163e6:	f5 01       	movw	r30, r10
   163e8:	80 81       	ld	r24, Z
   163ea:	89 83       	std	Y+1, r24	; 0x01
   163ec:	42 e0       	ldi	r20, 0x02	; 2
   163ee:	50 e0       	ldi	r21, 0x00	; 0
   163f0:	a4 0e       	add	r10, r20
   163f2:	b5 1e       	adc	r11, r21
   163f4:	61 01       	movw	r12, r2
   163f6:	01 e0       	ldi	r16, 0x01	; 1
   163f8:	10 e0       	ldi	r17, 0x00	; 0
   163fa:	12 c0       	rjmp	.+36     	; 0x16420 <vfprintf+0x160>
   163fc:	f5 01       	movw	r30, r10
   163fe:	c0 80       	ld	r12, Z
   16400:	d1 80       	ldd	r13, Z+1	; 0x01
   16402:	f6 fc       	sbrc	r15, 6
   16404:	03 c0       	rjmp	.+6      	; 0x1640c <vfprintf+0x14c>
   16406:	6f ef       	ldi	r22, 0xFF	; 255
   16408:	7f ef       	ldi	r23, 0xFF	; 255
   1640a:	02 c0       	rjmp	.+4      	; 0x16410 <vfprintf+0x150>
   1640c:	69 2d       	mov	r22, r9
   1640e:	70 e0       	ldi	r23, 0x00	; 0
   16410:	42 e0       	ldi	r20, 0x02	; 2
   16412:	50 e0       	ldi	r21, 0x00	; 0
   16414:	a4 0e       	add	r10, r20
   16416:	b5 1e       	adc	r11, r21
   16418:	c6 01       	movw	r24, r12
   1641a:	0e 94 48 b3 	call	0x16690	; 0x16690 <strnlen>
   1641e:	8c 01       	movw	r16, r24
   16420:	5f e7       	ldi	r21, 0x7F	; 127
   16422:	f5 22       	and	r15, r21
   16424:	14 c0       	rjmp	.+40     	; 0x1644e <vfprintf+0x18e>
   16426:	f5 01       	movw	r30, r10
   16428:	c0 80       	ld	r12, Z
   1642a:	d1 80       	ldd	r13, Z+1	; 0x01
   1642c:	f6 fc       	sbrc	r15, 6
   1642e:	03 c0       	rjmp	.+6      	; 0x16436 <vfprintf+0x176>
   16430:	6f ef       	ldi	r22, 0xFF	; 255
   16432:	7f ef       	ldi	r23, 0xFF	; 255
   16434:	02 c0       	rjmp	.+4      	; 0x1643a <vfprintf+0x17a>
   16436:	69 2d       	mov	r22, r9
   16438:	70 e0       	ldi	r23, 0x00	; 0
   1643a:	42 e0       	ldi	r20, 0x02	; 2
   1643c:	50 e0       	ldi	r21, 0x00	; 0
   1643e:	a4 0e       	add	r10, r20
   16440:	b5 1e       	adc	r11, r21
   16442:	c6 01       	movw	r24, r12
   16444:	0e 94 3d b3 	call	0x1667a	; 0x1667a <strnlen_P>
   16448:	8c 01       	movw	r16, r24
   1644a:	50 e8       	ldi	r21, 0x80	; 128
   1644c:	f5 2a       	or	r15, r21
   1644e:	f3 fe       	sbrs	r15, 3
   16450:	07 c0       	rjmp	.+14     	; 0x16460 <vfprintf+0x1a0>
   16452:	1a c0       	rjmp	.+52     	; 0x16488 <vfprintf+0x1c8>
   16454:	80 e2       	ldi	r24, 0x20	; 32
   16456:	90 e0       	ldi	r25, 0x00	; 0
   16458:	b3 01       	movw	r22, r6
   1645a:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   1645e:	ea 94       	dec	r14
   16460:	8e 2d       	mov	r24, r14
   16462:	90 e0       	ldi	r25, 0x00	; 0
   16464:	08 17       	cp	r16, r24
   16466:	19 07       	cpc	r17, r25
   16468:	a8 f3       	brcs	.-22     	; 0x16454 <vfprintf+0x194>
   1646a:	0e c0       	rjmp	.+28     	; 0x16488 <vfprintf+0x1c8>
   1646c:	f6 01       	movw	r30, r12
   1646e:	f7 fc       	sbrc	r15, 7
   16470:	85 91       	lpm	r24, Z+
   16472:	f7 fe       	sbrs	r15, 7
   16474:	81 91       	ld	r24, Z+
   16476:	6f 01       	movw	r12, r30
   16478:	90 e0       	ldi	r25, 0x00	; 0
   1647a:	b3 01       	movw	r22, r6
   1647c:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   16480:	e1 10       	cpse	r14, r1
   16482:	ea 94       	dec	r14
   16484:	01 50       	subi	r16, 0x01	; 1
   16486:	10 40       	sbci	r17, 0x00	; 0
   16488:	01 15       	cp	r16, r1
   1648a:	11 05       	cpc	r17, r1
   1648c:	79 f7       	brne	.-34     	; 0x1646c <vfprintf+0x1ac>
   1648e:	ea c0       	rjmp	.+468    	; 0x16664 <vfprintf+0x3a4>
   16490:	94 36       	cpi	r25, 0x64	; 100
   16492:	11 f0       	breq	.+4      	; 0x16498 <vfprintf+0x1d8>
   16494:	99 36       	cpi	r25, 0x69	; 105
   16496:	69 f5       	brne	.+90     	; 0x164f2 <vfprintf+0x232>
   16498:	f7 fe       	sbrs	r15, 7
   1649a:	08 c0       	rjmp	.+16     	; 0x164ac <vfprintf+0x1ec>
   1649c:	f5 01       	movw	r30, r10
   1649e:	20 81       	ld	r18, Z
   164a0:	31 81       	ldd	r19, Z+1	; 0x01
   164a2:	42 81       	ldd	r20, Z+2	; 0x02
   164a4:	53 81       	ldd	r21, Z+3	; 0x03
   164a6:	84 e0       	ldi	r24, 0x04	; 4
   164a8:	90 e0       	ldi	r25, 0x00	; 0
   164aa:	0a c0       	rjmp	.+20     	; 0x164c0 <vfprintf+0x200>
   164ac:	f5 01       	movw	r30, r10
   164ae:	80 81       	ld	r24, Z
   164b0:	91 81       	ldd	r25, Z+1	; 0x01
   164b2:	9c 01       	movw	r18, r24
   164b4:	44 27       	eor	r20, r20
   164b6:	37 fd       	sbrc	r19, 7
   164b8:	40 95       	com	r20
   164ba:	54 2f       	mov	r21, r20
   164bc:	82 e0       	ldi	r24, 0x02	; 2
   164be:	90 e0       	ldi	r25, 0x00	; 0
   164c0:	a8 0e       	add	r10, r24
   164c2:	b9 1e       	adc	r11, r25
   164c4:	9f e6       	ldi	r25, 0x6F	; 111
   164c6:	f9 22       	and	r15, r25
   164c8:	57 ff       	sbrs	r21, 7
   164ca:	09 c0       	rjmp	.+18     	; 0x164de <vfprintf+0x21e>
   164cc:	50 95       	com	r21
   164ce:	40 95       	com	r20
   164d0:	30 95       	com	r19
   164d2:	21 95       	neg	r18
   164d4:	3f 4f       	sbci	r19, 0xFF	; 255
   164d6:	4f 4f       	sbci	r20, 0xFF	; 255
   164d8:	5f 4f       	sbci	r21, 0xFF	; 255
   164da:	e0 e8       	ldi	r30, 0x80	; 128
   164dc:	fe 2a       	or	r15, r30
   164de:	ca 01       	movw	r24, r20
   164e0:	b9 01       	movw	r22, r18
   164e2:	a1 01       	movw	r20, r2
   164e4:	2a e0       	ldi	r18, 0x0A	; 10
   164e6:	30 e0       	ldi	r19, 0x00	; 0
   164e8:	0e 94 7f b3 	call	0x166fe	; 0x166fe <__ultoa_invert>
   164ec:	d8 2e       	mov	r13, r24
   164ee:	d2 18       	sub	r13, r2
   164f0:	40 c0       	rjmp	.+128    	; 0x16572 <vfprintf+0x2b2>
   164f2:	95 37       	cpi	r25, 0x75	; 117
   164f4:	29 f4       	brne	.+10     	; 0x16500 <vfprintf+0x240>
   164f6:	1f 2d       	mov	r17, r15
   164f8:	1f 7e       	andi	r17, 0xEF	; 239
   164fa:	2a e0       	ldi	r18, 0x0A	; 10
   164fc:	30 e0       	ldi	r19, 0x00	; 0
   164fe:	1d c0       	rjmp	.+58     	; 0x1653a <vfprintf+0x27a>
   16500:	1f 2d       	mov	r17, r15
   16502:	19 7f       	andi	r17, 0xF9	; 249
   16504:	9f 36       	cpi	r25, 0x6F	; 111
   16506:	61 f0       	breq	.+24     	; 0x16520 <vfprintf+0x260>
   16508:	90 37       	cpi	r25, 0x70	; 112
   1650a:	20 f4       	brcc	.+8      	; 0x16514 <vfprintf+0x254>
   1650c:	98 35       	cpi	r25, 0x58	; 88
   1650e:	09 f0       	breq	.+2      	; 0x16512 <vfprintf+0x252>
   16510:	ac c0       	rjmp	.+344    	; 0x1666a <vfprintf+0x3aa>
   16512:	0f c0       	rjmp	.+30     	; 0x16532 <vfprintf+0x272>
   16514:	90 37       	cpi	r25, 0x70	; 112
   16516:	39 f0       	breq	.+14     	; 0x16526 <vfprintf+0x266>
   16518:	98 37       	cpi	r25, 0x78	; 120
   1651a:	09 f0       	breq	.+2      	; 0x1651e <vfprintf+0x25e>
   1651c:	a6 c0       	rjmp	.+332    	; 0x1666a <vfprintf+0x3aa>
   1651e:	04 c0       	rjmp	.+8      	; 0x16528 <vfprintf+0x268>
   16520:	28 e0       	ldi	r18, 0x08	; 8
   16522:	30 e0       	ldi	r19, 0x00	; 0
   16524:	0a c0       	rjmp	.+20     	; 0x1653a <vfprintf+0x27a>
   16526:	10 61       	ori	r17, 0x10	; 16
   16528:	14 fd       	sbrc	r17, 4
   1652a:	14 60       	ori	r17, 0x04	; 4
   1652c:	20 e1       	ldi	r18, 0x10	; 16
   1652e:	30 e0       	ldi	r19, 0x00	; 0
   16530:	04 c0       	rjmp	.+8      	; 0x1653a <vfprintf+0x27a>
   16532:	14 fd       	sbrc	r17, 4
   16534:	16 60       	ori	r17, 0x06	; 6
   16536:	20 e1       	ldi	r18, 0x10	; 16
   16538:	32 e0       	ldi	r19, 0x02	; 2
   1653a:	17 ff       	sbrs	r17, 7
   1653c:	08 c0       	rjmp	.+16     	; 0x1654e <vfprintf+0x28e>
   1653e:	f5 01       	movw	r30, r10
   16540:	60 81       	ld	r22, Z
   16542:	71 81       	ldd	r23, Z+1	; 0x01
   16544:	82 81       	ldd	r24, Z+2	; 0x02
   16546:	93 81       	ldd	r25, Z+3	; 0x03
   16548:	44 e0       	ldi	r20, 0x04	; 4
   1654a:	50 e0       	ldi	r21, 0x00	; 0
   1654c:	08 c0       	rjmp	.+16     	; 0x1655e <vfprintf+0x29e>
   1654e:	f5 01       	movw	r30, r10
   16550:	80 81       	ld	r24, Z
   16552:	91 81       	ldd	r25, Z+1	; 0x01
   16554:	bc 01       	movw	r22, r24
   16556:	80 e0       	ldi	r24, 0x00	; 0
   16558:	90 e0       	ldi	r25, 0x00	; 0
   1655a:	42 e0       	ldi	r20, 0x02	; 2
   1655c:	50 e0       	ldi	r21, 0x00	; 0
   1655e:	a4 0e       	add	r10, r20
   16560:	b5 1e       	adc	r11, r21
   16562:	a1 01       	movw	r20, r2
   16564:	0e 94 7f b3 	call	0x166fe	; 0x166fe <__ultoa_invert>
   16568:	d8 2e       	mov	r13, r24
   1656a:	d2 18       	sub	r13, r2
   1656c:	8f e7       	ldi	r24, 0x7F	; 127
   1656e:	f8 2e       	mov	r15, r24
   16570:	f1 22       	and	r15, r17
   16572:	f6 fe       	sbrs	r15, 6
   16574:	0b c0       	rjmp	.+22     	; 0x1658c <vfprintf+0x2cc>
   16576:	5e ef       	ldi	r21, 0xFE	; 254
   16578:	f5 22       	and	r15, r21
   1657a:	d9 14       	cp	r13, r9
   1657c:	38 f4       	brcc	.+14     	; 0x1658c <vfprintf+0x2cc>
   1657e:	f4 fe       	sbrs	r15, 4
   16580:	07 c0       	rjmp	.+14     	; 0x16590 <vfprintf+0x2d0>
   16582:	f2 fc       	sbrc	r15, 2
   16584:	05 c0       	rjmp	.+10     	; 0x16590 <vfprintf+0x2d0>
   16586:	8f ee       	ldi	r24, 0xEF	; 239
   16588:	f8 22       	and	r15, r24
   1658a:	02 c0       	rjmp	.+4      	; 0x16590 <vfprintf+0x2d0>
   1658c:	1d 2d       	mov	r17, r13
   1658e:	01 c0       	rjmp	.+2      	; 0x16592 <vfprintf+0x2d2>
   16590:	19 2d       	mov	r17, r9
   16592:	f4 fe       	sbrs	r15, 4
   16594:	0d c0       	rjmp	.+26     	; 0x165b0 <vfprintf+0x2f0>
   16596:	fe 01       	movw	r30, r28
   16598:	ed 0d       	add	r30, r13
   1659a:	f1 1d       	adc	r31, r1
   1659c:	80 81       	ld	r24, Z
   1659e:	80 33       	cpi	r24, 0x30	; 48
   165a0:	19 f4       	brne	.+6      	; 0x165a8 <vfprintf+0x2e8>
   165a2:	99 ee       	ldi	r25, 0xE9	; 233
   165a4:	f9 22       	and	r15, r25
   165a6:	08 c0       	rjmp	.+16     	; 0x165b8 <vfprintf+0x2f8>
   165a8:	1f 5f       	subi	r17, 0xFF	; 255
   165aa:	f2 fe       	sbrs	r15, 2
   165ac:	05 c0       	rjmp	.+10     	; 0x165b8 <vfprintf+0x2f8>
   165ae:	03 c0       	rjmp	.+6      	; 0x165b6 <vfprintf+0x2f6>
   165b0:	8f 2d       	mov	r24, r15
   165b2:	86 78       	andi	r24, 0x86	; 134
   165b4:	09 f0       	breq	.+2      	; 0x165b8 <vfprintf+0x2f8>
   165b6:	1f 5f       	subi	r17, 0xFF	; 255
   165b8:	0f 2d       	mov	r16, r15
   165ba:	f3 fc       	sbrc	r15, 3
   165bc:	14 c0       	rjmp	.+40     	; 0x165e6 <vfprintf+0x326>
   165be:	f0 fe       	sbrs	r15, 0
   165c0:	0f c0       	rjmp	.+30     	; 0x165e0 <vfprintf+0x320>
   165c2:	1e 15       	cp	r17, r14
   165c4:	10 f0       	brcs	.+4      	; 0x165ca <vfprintf+0x30a>
   165c6:	9d 2c       	mov	r9, r13
   165c8:	0b c0       	rjmp	.+22     	; 0x165e0 <vfprintf+0x320>
   165ca:	9d 2c       	mov	r9, r13
   165cc:	9e 0c       	add	r9, r14
   165ce:	91 1a       	sub	r9, r17
   165d0:	1e 2d       	mov	r17, r14
   165d2:	06 c0       	rjmp	.+12     	; 0x165e0 <vfprintf+0x320>
   165d4:	80 e2       	ldi	r24, 0x20	; 32
   165d6:	90 e0       	ldi	r25, 0x00	; 0
   165d8:	b3 01       	movw	r22, r6
   165da:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   165de:	1f 5f       	subi	r17, 0xFF	; 255
   165e0:	1e 15       	cp	r17, r14
   165e2:	c0 f3       	brcs	.-16     	; 0x165d4 <vfprintf+0x314>
   165e4:	04 c0       	rjmp	.+8      	; 0x165ee <vfprintf+0x32e>
   165e6:	1e 15       	cp	r17, r14
   165e8:	10 f4       	brcc	.+4      	; 0x165ee <vfprintf+0x32e>
   165ea:	e1 1a       	sub	r14, r17
   165ec:	01 c0       	rjmp	.+2      	; 0x165f0 <vfprintf+0x330>
   165ee:	ee 24       	eor	r14, r14
   165f0:	04 ff       	sbrs	r16, 4
   165f2:	0f c0       	rjmp	.+30     	; 0x16612 <vfprintf+0x352>
   165f4:	80 e3       	ldi	r24, 0x30	; 48
   165f6:	90 e0       	ldi	r25, 0x00	; 0
   165f8:	b3 01       	movw	r22, r6
   165fa:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   165fe:	02 ff       	sbrs	r16, 2
   16600:	1d c0       	rjmp	.+58     	; 0x1663c <vfprintf+0x37c>
   16602:	01 fd       	sbrc	r16, 1
   16604:	03 c0       	rjmp	.+6      	; 0x1660c <vfprintf+0x34c>
   16606:	88 e7       	ldi	r24, 0x78	; 120
   16608:	90 e0       	ldi	r25, 0x00	; 0
   1660a:	0e c0       	rjmp	.+28     	; 0x16628 <vfprintf+0x368>
   1660c:	88 e5       	ldi	r24, 0x58	; 88
   1660e:	90 e0       	ldi	r25, 0x00	; 0
   16610:	0b c0       	rjmp	.+22     	; 0x16628 <vfprintf+0x368>
   16612:	80 2f       	mov	r24, r16
   16614:	86 78       	andi	r24, 0x86	; 134
   16616:	91 f0       	breq	.+36     	; 0x1663c <vfprintf+0x37c>
   16618:	01 ff       	sbrs	r16, 1
   1661a:	02 c0       	rjmp	.+4      	; 0x16620 <vfprintf+0x360>
   1661c:	8b e2       	ldi	r24, 0x2B	; 43
   1661e:	01 c0       	rjmp	.+2      	; 0x16622 <vfprintf+0x362>
   16620:	80 e2       	ldi	r24, 0x20	; 32
   16622:	f7 fc       	sbrc	r15, 7
   16624:	8d e2       	ldi	r24, 0x2D	; 45
   16626:	90 e0       	ldi	r25, 0x00	; 0
   16628:	b3 01       	movw	r22, r6
   1662a:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   1662e:	06 c0       	rjmp	.+12     	; 0x1663c <vfprintf+0x37c>
   16630:	80 e3       	ldi	r24, 0x30	; 48
   16632:	90 e0       	ldi	r25, 0x00	; 0
   16634:	b3 01       	movw	r22, r6
   16636:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   1663a:	9a 94       	dec	r9
   1663c:	d9 14       	cp	r13, r9
   1663e:	c0 f3       	brcs	.-16     	; 0x16630 <vfprintf+0x370>
   16640:	da 94       	dec	r13
   16642:	f1 01       	movw	r30, r2
   16644:	ed 0d       	add	r30, r13
   16646:	f1 1d       	adc	r31, r1
   16648:	80 81       	ld	r24, Z
   1664a:	90 e0       	ldi	r25, 0x00	; 0
   1664c:	b3 01       	movw	r22, r6
   1664e:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   16652:	dd 20       	and	r13, r13
   16654:	a9 f7       	brne	.-22     	; 0x16640 <vfprintf+0x380>
   16656:	06 c0       	rjmp	.+12     	; 0x16664 <vfprintf+0x3a4>
   16658:	80 e2       	ldi	r24, 0x20	; 32
   1665a:	90 e0       	ldi	r25, 0x00	; 0
   1665c:	b3 01       	movw	r22, r6
   1665e:	0e 94 53 b3 	call	0x166a6	; 0x166a6 <fputc>
   16662:	ea 94       	dec	r14
   16664:	ee 20       	and	r14, r14
   16666:	c1 f7       	brne	.-16     	; 0x16658 <vfprintf+0x398>
   16668:	43 ce       	rjmp	.-890    	; 0x162f0 <vfprintf+0x30>
   1666a:	f3 01       	movw	r30, r6
   1666c:	66 81       	ldd	r22, Z+6	; 0x06
   1666e:	77 81       	ldd	r23, Z+7	; 0x07
   16670:	cb 01       	movw	r24, r22
   16672:	2b 96       	adiw	r28, 0x0b	; 11
   16674:	e2 e1       	ldi	r30, 0x12	; 18
   16676:	0c 94 7a b4 	jmp	0x168f4	; 0x168f4 <__epilogue_restores__>

0001667a <strnlen_P>:
   1667a:	fc 01       	movw	r30, r24
   1667c:	05 90       	lpm	r0, Z+
   1667e:	61 50       	subi	r22, 0x01	; 1
   16680:	70 40       	sbci	r23, 0x00	; 0
   16682:	01 10       	cpse	r0, r1
   16684:	d8 f7       	brcc	.-10     	; 0x1667c <strnlen_P+0x2>
   16686:	80 95       	com	r24
   16688:	90 95       	com	r25
   1668a:	8e 0f       	add	r24, r30
   1668c:	9f 1f       	adc	r25, r31
   1668e:	08 95       	ret

00016690 <strnlen>:
   16690:	fc 01       	movw	r30, r24
   16692:	61 50       	subi	r22, 0x01	; 1
   16694:	70 40       	sbci	r23, 0x00	; 0
   16696:	01 90       	ld	r0, Z+
   16698:	01 10       	cpse	r0, r1
   1669a:	d8 f7       	brcc	.-10     	; 0x16692 <strnlen+0x2>
   1669c:	80 95       	com	r24
   1669e:	90 95       	com	r25
   166a0:	8e 0f       	add	r24, r30
   166a2:	9f 1f       	adc	r25, r31
   166a4:	08 95       	ret

000166a6 <fputc>:
   166a6:	0f 93       	push	r16
   166a8:	1f 93       	push	r17
   166aa:	cf 93       	push	r28
   166ac:	df 93       	push	r29
   166ae:	8c 01       	movw	r16, r24
   166b0:	eb 01       	movw	r28, r22
   166b2:	8b 81       	ldd	r24, Y+3	; 0x03
   166b4:	81 ff       	sbrs	r24, 1
   166b6:	1b c0       	rjmp	.+54     	; 0x166ee <fputc+0x48>
   166b8:	82 ff       	sbrs	r24, 2
   166ba:	0d c0       	rjmp	.+26     	; 0x166d6 <fputc+0x30>
   166bc:	2e 81       	ldd	r18, Y+6	; 0x06
   166be:	3f 81       	ldd	r19, Y+7	; 0x07
   166c0:	8c 81       	ldd	r24, Y+4	; 0x04
   166c2:	9d 81       	ldd	r25, Y+5	; 0x05
   166c4:	28 17       	cp	r18, r24
   166c6:	39 07       	cpc	r19, r25
   166c8:	64 f4       	brge	.+24     	; 0x166e2 <fputc+0x3c>
   166ca:	e8 81       	ld	r30, Y
   166cc:	f9 81       	ldd	r31, Y+1	; 0x01
   166ce:	01 93       	st	Z+, r16
   166d0:	f9 83       	std	Y+1, r31	; 0x01
   166d2:	e8 83       	st	Y, r30
   166d4:	06 c0       	rjmp	.+12     	; 0x166e2 <fputc+0x3c>
   166d6:	e8 85       	ldd	r30, Y+8	; 0x08
   166d8:	f9 85       	ldd	r31, Y+9	; 0x09
   166da:	80 2f       	mov	r24, r16
   166dc:	09 95       	icall
   166de:	89 2b       	or	r24, r25
   166e0:	31 f4       	brne	.+12     	; 0x166ee <fputc+0x48>
   166e2:	8e 81       	ldd	r24, Y+6	; 0x06
   166e4:	9f 81       	ldd	r25, Y+7	; 0x07
   166e6:	01 96       	adiw	r24, 0x01	; 1
   166e8:	9f 83       	std	Y+7, r25	; 0x07
   166ea:	8e 83       	std	Y+6, r24	; 0x06
   166ec:	02 c0       	rjmp	.+4      	; 0x166f2 <fputc+0x4c>
   166ee:	0f ef       	ldi	r16, 0xFF	; 255
   166f0:	1f ef       	ldi	r17, 0xFF	; 255
   166f2:	c8 01       	movw	r24, r16
   166f4:	df 91       	pop	r29
   166f6:	cf 91       	pop	r28
   166f8:	1f 91       	pop	r17
   166fa:	0f 91       	pop	r16
   166fc:	08 95       	ret

000166fe <__ultoa_invert>:
   166fe:	fa 01       	movw	r30, r20
   16700:	aa 27       	eor	r26, r26
   16702:	28 30       	cpi	r18, 0x08	; 8
   16704:	51 f1       	breq	.+84     	; 0x1675a <__ultoa_invert+0x5c>
   16706:	20 31       	cpi	r18, 0x10	; 16
   16708:	81 f1       	breq	.+96     	; 0x1676a <__ultoa_invert+0x6c>
   1670a:	e8 94       	clt
   1670c:	6f 93       	push	r22
   1670e:	6e 7f       	andi	r22, 0xFE	; 254
   16710:	6e 5f       	subi	r22, 0xFE	; 254
   16712:	7f 4f       	sbci	r23, 0xFF	; 255
   16714:	8f 4f       	sbci	r24, 0xFF	; 255
   16716:	9f 4f       	sbci	r25, 0xFF	; 255
   16718:	af 4f       	sbci	r26, 0xFF	; 255
   1671a:	b1 e0       	ldi	r27, 0x01	; 1
   1671c:	3e d0       	rcall	.+124    	; 0x1679a <__ultoa_invert+0x9c>
   1671e:	b4 e0       	ldi	r27, 0x04	; 4
   16720:	3c d0       	rcall	.+120    	; 0x1679a <__ultoa_invert+0x9c>
   16722:	67 0f       	add	r22, r23
   16724:	78 1f       	adc	r23, r24
   16726:	89 1f       	adc	r24, r25
   16728:	9a 1f       	adc	r25, r26
   1672a:	a1 1d       	adc	r26, r1
   1672c:	68 0f       	add	r22, r24
   1672e:	79 1f       	adc	r23, r25
   16730:	8a 1f       	adc	r24, r26
   16732:	91 1d       	adc	r25, r1
   16734:	a1 1d       	adc	r26, r1
   16736:	6a 0f       	add	r22, r26
   16738:	71 1d       	adc	r23, r1
   1673a:	81 1d       	adc	r24, r1
   1673c:	91 1d       	adc	r25, r1
   1673e:	a1 1d       	adc	r26, r1
   16740:	20 d0       	rcall	.+64     	; 0x16782 <__ultoa_invert+0x84>
   16742:	09 f4       	brne	.+2      	; 0x16746 <__ultoa_invert+0x48>
   16744:	68 94       	set
   16746:	3f 91       	pop	r19
   16748:	2a e0       	ldi	r18, 0x0A	; 10
   1674a:	26 9f       	mul	r18, r22
   1674c:	11 24       	eor	r1, r1
   1674e:	30 19       	sub	r19, r0
   16750:	30 5d       	subi	r19, 0xD0	; 208
   16752:	31 93       	st	Z+, r19
   16754:	de f6       	brtc	.-74     	; 0x1670c <__ultoa_invert+0xe>
   16756:	cf 01       	movw	r24, r30
   16758:	08 95       	ret
   1675a:	46 2f       	mov	r20, r22
   1675c:	47 70       	andi	r20, 0x07	; 7
   1675e:	40 5d       	subi	r20, 0xD0	; 208
   16760:	41 93       	st	Z+, r20
   16762:	b3 e0       	ldi	r27, 0x03	; 3
   16764:	0f d0       	rcall	.+30     	; 0x16784 <__ultoa_invert+0x86>
   16766:	c9 f7       	brne	.-14     	; 0x1675a <__ultoa_invert+0x5c>
   16768:	f6 cf       	rjmp	.-20     	; 0x16756 <__ultoa_invert+0x58>
   1676a:	46 2f       	mov	r20, r22
   1676c:	4f 70       	andi	r20, 0x0F	; 15
   1676e:	40 5d       	subi	r20, 0xD0	; 208
   16770:	4a 33       	cpi	r20, 0x3A	; 58
   16772:	18 f0       	brcs	.+6      	; 0x1677a <__ultoa_invert+0x7c>
   16774:	49 5d       	subi	r20, 0xD9	; 217
   16776:	31 fd       	sbrc	r19, 1
   16778:	40 52       	subi	r20, 0x20	; 32
   1677a:	41 93       	st	Z+, r20
   1677c:	02 d0       	rcall	.+4      	; 0x16782 <__ultoa_invert+0x84>
   1677e:	a9 f7       	brne	.-22     	; 0x1676a <__ultoa_invert+0x6c>
   16780:	ea cf       	rjmp	.-44     	; 0x16756 <__ultoa_invert+0x58>
   16782:	b4 e0       	ldi	r27, 0x04	; 4
   16784:	a6 95       	lsr	r26
   16786:	97 95       	ror	r25
   16788:	87 95       	ror	r24
   1678a:	77 95       	ror	r23
   1678c:	67 95       	ror	r22
   1678e:	ba 95       	dec	r27
   16790:	c9 f7       	brne	.-14     	; 0x16784 <__ultoa_invert+0x86>
   16792:	00 97       	sbiw	r24, 0x00	; 0
   16794:	61 05       	cpc	r22, r1
   16796:	71 05       	cpc	r23, r1
   16798:	08 95       	ret
   1679a:	9b 01       	movw	r18, r22
   1679c:	ac 01       	movw	r20, r24
   1679e:	0a 2e       	mov	r0, r26
   167a0:	06 94       	lsr	r0
   167a2:	57 95       	ror	r21
   167a4:	47 95       	ror	r20
   167a6:	37 95       	ror	r19
   167a8:	27 95       	ror	r18
   167aa:	ba 95       	dec	r27
   167ac:	c9 f7       	brne	.-14     	; 0x167a0 <__ultoa_invert+0xa2>
   167ae:	62 0f       	add	r22, r18
   167b0:	73 1f       	adc	r23, r19
   167b2:	84 1f       	adc	r24, r20
   167b4:	95 1f       	adc	r25, r21
   167b6:	a0 1d       	adc	r26, r0
   167b8:	08 95       	ret

000167ba <__mulsi3>:
   167ba:	62 9f       	mul	r22, r18
   167bc:	d0 01       	movw	r26, r0
   167be:	73 9f       	mul	r23, r19
   167c0:	f0 01       	movw	r30, r0
   167c2:	82 9f       	mul	r24, r18
   167c4:	e0 0d       	add	r30, r0
   167c6:	f1 1d       	adc	r31, r1
   167c8:	64 9f       	mul	r22, r20
   167ca:	e0 0d       	add	r30, r0
   167cc:	f1 1d       	adc	r31, r1
   167ce:	92 9f       	mul	r25, r18
   167d0:	f0 0d       	add	r31, r0
   167d2:	83 9f       	mul	r24, r19
   167d4:	f0 0d       	add	r31, r0
   167d6:	74 9f       	mul	r23, r20
   167d8:	f0 0d       	add	r31, r0
   167da:	65 9f       	mul	r22, r21
   167dc:	f0 0d       	add	r31, r0
   167de:	99 27       	eor	r25, r25
   167e0:	72 9f       	mul	r23, r18
   167e2:	b0 0d       	add	r27, r0
   167e4:	e1 1d       	adc	r30, r1
   167e6:	f9 1f       	adc	r31, r25
   167e8:	63 9f       	mul	r22, r19
   167ea:	b0 0d       	add	r27, r0
   167ec:	e1 1d       	adc	r30, r1
   167ee:	f9 1f       	adc	r31, r25
   167f0:	bd 01       	movw	r22, r26
   167f2:	cf 01       	movw	r24, r30
   167f4:	11 24       	eor	r1, r1
   167f6:	08 95       	ret

000167f8 <__udivmodqi4>:
   167f8:	99 1b       	sub	r25, r25
   167fa:	79 e0       	ldi	r23, 0x09	; 9
   167fc:	04 c0       	rjmp	.+8      	; 0x16806 <__udivmodqi4_ep>

000167fe <__udivmodqi4_loop>:
   167fe:	99 1f       	adc	r25, r25
   16800:	96 17       	cp	r25, r22
   16802:	08 f0       	brcs	.+2      	; 0x16806 <__udivmodqi4_ep>
   16804:	96 1b       	sub	r25, r22

00016806 <__udivmodqi4_ep>:
   16806:	88 1f       	adc	r24, r24
   16808:	7a 95       	dec	r23
   1680a:	c9 f7       	brne	.-14     	; 0x167fe <__udivmodqi4_loop>
   1680c:	80 95       	com	r24
   1680e:	08 95       	ret

00016810 <__divmodqi4>:
   16810:	87 fb       	bst	r24, 7
   16812:	08 2e       	mov	r0, r24
   16814:	06 26       	eor	r0, r22
   16816:	87 fd       	sbrc	r24, 7
   16818:	81 95       	neg	r24
   1681a:	67 fd       	sbrc	r22, 7
   1681c:	61 95       	neg	r22
   1681e:	ec df       	rcall	.-40     	; 0x167f8 <__udivmodqi4>
   16820:	0e f4       	brtc	.+2      	; 0x16824 <__divmodqi4_1>
   16822:	91 95       	neg	r25

00016824 <__divmodqi4_1>:
   16824:	07 fc       	sbrc	r0, 7
   16826:	81 95       	neg	r24

00016828 <__divmodqi4_exit>:
   16828:	08 95       	ret

0001682a <__udivmodhi4>:
   1682a:	aa 1b       	sub	r26, r26
   1682c:	bb 1b       	sub	r27, r27
   1682e:	51 e1       	ldi	r21, 0x11	; 17
   16830:	07 c0       	rjmp	.+14     	; 0x16840 <__udivmodhi4_ep>

00016832 <__udivmodhi4_loop>:
   16832:	aa 1f       	adc	r26, r26
   16834:	bb 1f       	adc	r27, r27
   16836:	a6 17       	cp	r26, r22
   16838:	b7 07       	cpc	r27, r23
   1683a:	10 f0       	brcs	.+4      	; 0x16840 <__udivmodhi4_ep>
   1683c:	a6 1b       	sub	r26, r22
   1683e:	b7 0b       	sbc	r27, r23

00016840 <__udivmodhi4_ep>:
   16840:	88 1f       	adc	r24, r24
   16842:	99 1f       	adc	r25, r25
   16844:	5a 95       	dec	r21
   16846:	a9 f7       	brne	.-22     	; 0x16832 <__udivmodhi4_loop>
   16848:	80 95       	com	r24
   1684a:	90 95       	com	r25
   1684c:	bc 01       	movw	r22, r24
   1684e:	cd 01       	movw	r24, r26
   16850:	08 95       	ret

00016852 <__divmodhi4>:
   16852:	97 fb       	bst	r25, 7
   16854:	09 2e       	mov	r0, r25
   16856:	07 26       	eor	r0, r23
   16858:	0a d0       	rcall	.+20     	; 0x1686e <__divmodhi4_neg1>
   1685a:	77 fd       	sbrc	r23, 7
   1685c:	04 d0       	rcall	.+8      	; 0x16866 <__divmodhi4_neg2>
   1685e:	e5 df       	rcall	.-54     	; 0x1682a <__udivmodhi4>
   16860:	06 d0       	rcall	.+12     	; 0x1686e <__divmodhi4_neg1>
   16862:	00 20       	and	r0, r0
   16864:	1a f4       	brpl	.+6      	; 0x1686c <__divmodhi4_exit>

00016866 <__divmodhi4_neg2>:
   16866:	70 95       	com	r23
   16868:	61 95       	neg	r22
   1686a:	7f 4f       	sbci	r23, 0xFF	; 255

0001686c <__divmodhi4_exit>:
   1686c:	08 95       	ret

0001686e <__divmodhi4_neg1>:
   1686e:	f6 f7       	brtc	.-4      	; 0x1686c <__divmodhi4_exit>
   16870:	90 95       	com	r25
   16872:	81 95       	neg	r24
   16874:	9f 4f       	sbci	r25, 0xFF	; 255
   16876:	08 95       	ret

00016878 <__udivmodsi4>:
   16878:	a1 e2       	ldi	r26, 0x21	; 33
   1687a:	1a 2e       	mov	r1, r26
   1687c:	aa 1b       	sub	r26, r26
   1687e:	bb 1b       	sub	r27, r27
   16880:	fd 01       	movw	r30, r26
   16882:	0d c0       	rjmp	.+26     	; 0x1689e <__udivmodsi4_ep>

00016884 <__udivmodsi4_loop>:
   16884:	aa 1f       	adc	r26, r26
   16886:	bb 1f       	adc	r27, r27
   16888:	ee 1f       	adc	r30, r30
   1688a:	ff 1f       	adc	r31, r31
   1688c:	a2 17       	cp	r26, r18
   1688e:	b3 07       	cpc	r27, r19
   16890:	e4 07       	cpc	r30, r20
   16892:	f5 07       	cpc	r31, r21
   16894:	20 f0       	brcs	.+8      	; 0x1689e <__udivmodsi4_ep>
   16896:	a2 1b       	sub	r26, r18
   16898:	b3 0b       	sbc	r27, r19
   1689a:	e4 0b       	sbc	r30, r20
   1689c:	f5 0b       	sbc	r31, r21

0001689e <__udivmodsi4_ep>:
   1689e:	66 1f       	adc	r22, r22
   168a0:	77 1f       	adc	r23, r23
   168a2:	88 1f       	adc	r24, r24
   168a4:	99 1f       	adc	r25, r25
   168a6:	1a 94       	dec	r1
   168a8:	69 f7       	brne	.-38     	; 0x16884 <__udivmodsi4_loop>
   168aa:	60 95       	com	r22
   168ac:	70 95       	com	r23
   168ae:	80 95       	com	r24
   168b0:	90 95       	com	r25
   168b2:	9b 01       	movw	r18, r22
   168b4:	ac 01       	movw	r20, r24
   168b6:	bd 01       	movw	r22, r26
   168b8:	cf 01       	movw	r24, r30
   168ba:	08 95       	ret

000168bc <__prologue_saves__>:
   168bc:	2f 92       	push	r2
   168be:	3f 92       	push	r3
   168c0:	4f 92       	push	r4
   168c2:	5f 92       	push	r5
   168c4:	6f 92       	push	r6
   168c6:	7f 92       	push	r7
   168c8:	8f 92       	push	r8
   168ca:	9f 92       	push	r9
   168cc:	af 92       	push	r10
   168ce:	bf 92       	push	r11
   168d0:	cf 92       	push	r12
   168d2:	df 92       	push	r13
   168d4:	ef 92       	push	r14
   168d6:	ff 92       	push	r15
   168d8:	0f 93       	push	r16
   168da:	1f 93       	push	r17
   168dc:	cf 93       	push	r28
   168de:	df 93       	push	r29
   168e0:	cd b7       	in	r28, 0x3d	; 61
   168e2:	de b7       	in	r29, 0x3e	; 62
   168e4:	ca 1b       	sub	r28, r26
   168e6:	db 0b       	sbc	r29, r27
   168e8:	0f b6       	in	r0, 0x3f	; 63
   168ea:	f8 94       	cli
   168ec:	de bf       	out	0x3e, r29	; 62
   168ee:	0f be       	out	0x3f, r0	; 63
   168f0:	cd bf       	out	0x3d, r28	; 61
   168f2:	09 94       	ijmp

000168f4 <__epilogue_restores__>:
   168f4:	2a 88       	ldd	r2, Y+18	; 0x12
   168f6:	39 88       	ldd	r3, Y+17	; 0x11
   168f8:	48 88       	ldd	r4, Y+16	; 0x10
   168fa:	5f 84       	ldd	r5, Y+15	; 0x0f
   168fc:	6e 84       	ldd	r6, Y+14	; 0x0e
   168fe:	7d 84       	ldd	r7, Y+13	; 0x0d
   16900:	8c 84       	ldd	r8, Y+12	; 0x0c
   16902:	9b 84       	ldd	r9, Y+11	; 0x0b
   16904:	aa 84       	ldd	r10, Y+10	; 0x0a
   16906:	b9 84       	ldd	r11, Y+9	; 0x09
   16908:	c8 84       	ldd	r12, Y+8	; 0x08
   1690a:	df 80       	ldd	r13, Y+7	; 0x07
   1690c:	ee 80       	ldd	r14, Y+6	; 0x06
   1690e:	fd 80       	ldd	r15, Y+5	; 0x05
   16910:	0c 81       	ldd	r16, Y+4	; 0x04
   16912:	1b 81       	ldd	r17, Y+3	; 0x03
   16914:	aa 81       	ldd	r26, Y+2	; 0x02
   16916:	b9 81       	ldd	r27, Y+1	; 0x01
   16918:	ce 0f       	add	r28, r30
   1691a:	d1 1d       	adc	r29, r1
   1691c:	0f b6       	in	r0, 0x3f	; 63
   1691e:	f8 94       	cli
   16920:	de bf       	out	0x3e, r29	; 62
   16922:	0f be       	out	0x3f, r0	; 63
   16924:	cd bf       	out	0x3d, r28	; 61
   16926:	ed 01       	movw	r28, r26
   16928:	08 95       	ret

0001692a <_exit>:
   1692a:	f8 94       	cli

0001692c <__stop_program>:
   1692c:	ff cf       	rjmp	.-2      	; 0x1692c <__stop_program>
