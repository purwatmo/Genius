
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005c  00800100  00016640  000166f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00016640  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000b57  0080015c  0080015c  00016750  2**0
                  ALLOC
  3 .eeprom       00000857  00810000  00810000  00016750  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  00016fa7  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000024d7  00000000  00000000  00017087  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001331c  00000000  00000000  0001955e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000bae  00000000  00000000  0002c87a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000dfb2  00000000  00000000  0002d428  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000011b0  00000000  00000000  0003b3dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000052b6  00000000  00000000  0003c58c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000078c8  00000000  00000000  00041842  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000720  00000000  00000000  0004910a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f8 12 	jmp	0x25f0	; 0x25f0 <__ctors_end>
       4:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
       8:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
       c:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      10:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      14:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      18:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      1c:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      20:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      24:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      28:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      2c:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      30:	0c 94 e6 13 	jmp	0x27cc	; 0x27cc <__vector_12>
      34:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      38:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      3c:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      40:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      44:	0c 94 dc 6a 	jmp	0xd5b8	; 0xd5b8 <__vector_17>
      48:	0c 94 80 15 	jmp	0x2b00	; 0x2b00 <__vector_18>
      4c:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      50:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      54:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      58:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      5c:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      60:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      64:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      68:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      6c:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      70:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      74:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      78:	0c 94 9f 44 	jmp	0x893e	; 0x893e <__vector_30>
      7c:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      80:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      84:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      88:	0c 94 17 13 	jmp	0x262e	; 0x262e <__bad_interrupt>
      8c:	61 14       	cp	r6, r1
      8e:	5f 14       	cp	r5, r15
      90:	63 14       	cp	r6, r3
      92:	65 14       	cp	r6, r5
      94:	67 14       	cp	r6, r7
      96:	69 14       	cp	r6, r9
      98:	6b 14       	cp	r6, r11
      9a:	6d 14       	cp	r6, r13
      9c:	6f 14       	cp	r6, r15
      9e:	71 14       	cp	r7, r1
      a0:	73 14       	cp	r7, r3
      a2:	75 14       	cp	r7, r5
      a4:	77 14       	cp	r7, r7
      a6:	85 14       	cp	r8, r5
      a8:	79 14       	cp	r7, r9
      aa:	85 14       	cp	r8, r5
      ac:	7b 14       	cp	r7, r11
      ae:	7d 14       	cp	r7, r13
      b0:	85 14       	cp	r8, r5
      b2:	7f 14       	cp	r7, r15
      b4:	81 14       	cp	r8, r1
      b6:	83 14       	cp	r8, r3
      b8:	85 14       	cp	r8, r5
      ba:	85 14       	cp	r8, r5
      bc:	79 14       	cp	r7, r9
      be:	6b 14       	cp	r6, r11
      c0:	85 14       	cp	r8, r5
      c2:	6d 14       	cp	r6, r13
      c4:	71 14       	cp	r7, r1
      c6:	75 14       	cp	r7, r5
      c8:	2a 77       	andi	r18, 0x7A	; 122
      ca:	46 77       	andi	r20, 0x76	; 118
      cc:	4f 78       	andi	r20, 0x8F	; 143
      ce:	7e 78       	andi	r23, 0x8E	; 142
      d0:	a7 78       	andi	r26, 0x87	; 135
      d2:	1a 79       	andi	r17, 0x9A	; 154
      d4:	29 79       	andi	r18, 0x99	; 153
      d6:	30 79       	andi	r19, 0x90	; 144
      d8:	6c 79       	andi	r22, 0x9C	; 156
      da:	93 79       	andi	r25, 0x93	; 147
      dc:	da 79       	andi	r29, 0x9A	; 154
      de:	e4 79       	andi	r30, 0x94	; 148
      e0:	9f 79       	andi	r25, 0x9F	; 159
      e2:	ea 79       	andi	r30, 0x9A	; 154
      e4:	02 7a       	andi	r16, 0xA2	; 162
      e6:	f9 79       	andi	r31, 0x99	; 153
      e8:	fe 79       	andi	r31, 0x9E	; 158
      ea:	5a 77       	andi	r21, 0x7A	; 122
      ec:	e9 77       	andi	r30, 0x79	; 121
      ee:	0b 78       	andi	r16, 0x8B	; 139
      f0:	17 78       	andi	r17, 0x87	; 135
      f2:	29 78       	andi	r18, 0x89	; 137
      f4:	3a 78       	andi	r19, 0x8A	; 138
      f6:	49 78       	andi	r20, 0x89	; 137
      f8:	49 78       	andi	r20, 0x89	; 137
      fa:	b7 7c       	andi	r27, 0xC7	; 199
      fc:	bd 7c       	andi	r27, 0xCD	; 205
      fe:	c1 7c       	andi	r28, 0xC1	; 193
     100:	d8 7c       	andi	r29, 0xC8	; 200
     102:	f2 7c       	andi	r31, 0xC2	; 194
     104:	f6 7c       	andi	r31, 0xC6	; 198
     106:	21 7d       	andi	r18, 0xD1	; 209
     108:	3b 7d       	andi	r19, 0xDB	; 219
     10a:	41 7d       	andi	r20, 0xD1	; 209
     10c:	49 7d       	andi	r20, 0xD9	; 217
     10e:	4c 7d       	andi	r20, 0xDC	; 220
     110:	4f 7d       	andi	r20, 0xDF	; 223
     112:	52 7d       	andi	r21, 0xD2	; 210
     114:	55 7d       	andi	r21, 0xD5	; 213
     116:	58 7d       	andi	r21, 0xD8	; 216
     118:	5c 7d       	andi	r21, 0xDC	; 220
     11a:	5f 7d       	andi	r21, 0xDF	; 223
     11c:	62 7d       	andi	r22, 0xD2	; 210
     11e:	6a 7d       	andi	r22, 0xDA	; 218
     120:	da 83       	std	Y+2, r29	; 0x02
     122:	2f 84       	ldd	r2, Y+15	; 0x0f
     124:	3b 84       	ldd	r3, Y+11	; 0x0b
     126:	7d 84       	ldd	r7, Y+13	; 0x0d
     128:	8f 84       	ldd	r8, Y+15	; 0x0f
     12a:	a4 84       	ldd	r10, Z+12	; 0x0c
     12c:	c7 84       	ldd	r12, Z+15	; 0x0f
     12e:	7d 85       	ldd	r23, Y+13	; 0x0d
     130:	87 85       	ldd	r24, Z+15	; 0x0f
     132:	65 8c       	ldd	r6, Z+29	; 0x1d
     134:	e6 85       	ldd	r30, Z+14	; 0x0e
     136:	f3 86       	std	Z+11, r15	; 0x0b
     138:	42 87       	std	Z+10, r20	; 0x0a
     13a:	88 87       	std	Y+8, r24	; 0x08
     13c:	00 88       	ldd	r0, Z+16	; 0x10
     13e:	91 88       	ldd	r9, Z+17	; 0x11
     140:	be 88       	ldd	r11, Y+22	; 0x16
     142:	84 89       	ldd	r24, Z+20	; 0x14
     144:	b0 89       	ldd	r27, Z+16	; 0x10
     146:	69 8a       	std	Y+17, r6	; 0x11
     148:	82 8a       	std	Z+18, r8	; 0x12
     14a:	8c 8b       	std	Y+20, r24	; 0x14
     14c:	fa 8a       	std	Y+18, r15	; 0x12
     14e:	3c 8b       	std	Y+20, r19	; 0x14
     150:	26 8c       	ldd	r2, Z+30	; 0x1e
     152:	54 8c       	ldd	r5, Z+28	; 0x1c
     154:	65 8c       	ldd	r6, Z+29	; 0x1d
     156:	92 8b       	std	Z+18, r25	; 0x12
     158:	15 8c       	ldd	r1, Z+29	; 0x1d
     15a:	58 8c       	ldd	r5, Y+24	; 0x18
     15c:	5e 8c       	ldd	r5, Y+30	; 0x1e
     15e:	a1 8c       	ldd	r10, Z+25	; 0x19
     160:	a5 8c       	ldd	r10, Z+29	; 0x1d
     162:	c1 8c       	ldd	r12, Z+25	; 0x19
     164:	a5 90       	lpm	r10, Z+
     166:	a5 90       	lpm	r10, Z+
     168:	a5 90       	lpm	r10, Z+
     16a:	a5 90       	lpm	r10, Z+
     16c:	0a 8d       	ldd	r16, Y+26	; 0x1a
     16e:	a5 90       	lpm	r10, Z+
     170:	2a 8d       	ldd	r18, Y+26	; 0x1a
     172:	a5 90       	lpm	r10, Z+
     174:	47 8d       	ldd	r20, Z+31	; 0x1f
     176:	d0 8d       	ldd	r29, Z+24	; 0x18
     178:	2b 8e       	std	Y+27, r2	; 0x1b
     17a:	4e 8e       	std	Y+30, r4	; 0x1e
     17c:	ed 8c       	ldd	r14, Y+29	; 0x1d
     17e:	a5 90       	lpm	r10, Z+
     180:	e3 8d       	ldd	r30, Z+27	; 0x1b
     182:	66 8e       	std	Z+30, r6	; 0x1e
     184:	9e 8e       	std	Y+30, r9	; 0x1e
     186:	b6 8e       	std	Z+30, r11	; 0x1e
     188:	f2 8e       	std	Z+26, r15	; 0x1a
     18a:	02 8f       	std	Z+26, r16	; 0x1a
     18c:	13 90       	.word	0x9013	; ????
     18e:	23 90       	.word	0x9023	; ????
     190:	68 90       	.word	0x9068	; ????
     192:	87 90       	elpm	r8, Z+
     194:	99 90       	ld	r9, Y+
     196:	9f 90       	pop	r9
     198:	a1 90       	ld	r10, Z+
     19a:	19 97       	sbiw	r26, 0x09	; 9
     19c:	31 97       	sbiw	r30, 0x01	; 1
     19e:	43 97       	sbiw	r24, 0x13	; 19
     1a0:	7a 97       	sbiw	r30, 0x1a	; 26
     1a2:	a9 97       	sbiw	r28, 0x29	; 41
     1a4:	bf 97       	sbiw	r30, 0x2f	; 47
     1a6:	fa 97       	sbiw	r30, 0x3a	; 58
     1a8:	32 98       	cbi	0x06, 2	; 6
     1aa:	74 98       	cbi	0x0e, 4	; 14
     1ac:	7c 98       	cbi	0x0f, 4	; 15
     1ae:	9f 99       	sbic	0x13, 7	; 19
     1b0:	a8 99       	sbic	0x15, 0	; 21
     1b2:	da 99       	sbic	0x1b, 2	; 27
     1b4:	17 9a       	sbi	0x02, 7	; 2
     1b6:	34 9a       	sbi	0x06, 4	; 6
     1b8:	4e 9a       	sbi	0x09, 6	; 9
     1ba:	a9 9a       	sbi	0x15, 1	; 21
     1bc:	8f 97       	sbiw	r24, 0x2f	; 47
     1be:	4c 98       	cbi	0x09, 4	; 9
     1c0:	f3 99       	sbic	0x1e, 3	; 30
     1c2:	18 98       	cbi	0x03, 0	; 3
     1c4:	94 98       	cbi	0x12, 4	; 18
     1c6:	e3 98       	cbi	0x1c, 3	; 28
     1c8:	ff 98       	cbi	0x1f, 7	; 31
     1ca:	19 99       	sbic	0x03, 1	; 3
     1cc:	67 99       	sbic	0x0c, 7	; 12
     1ce:	85 99       	sbic	0x10, 5	; 16
     1d0:	e3 9a       	sbi	0x1c, 3	; 28
     1d2:	f9 9a       	sbi	0x1f, 1	; 31
     1d4:	fe 9a       	sbi	0x1f, 6	; 31
     1d6:	37 9b       	sbis	0x06, 7	; 6
     1d8:	66 9b       	sbis	0x0c, 6	; 12
     1da:	ab 9b       	sbis	0x15, 3	; 21
     1dc:	c9 9b       	sbis	0x19, 1	; 25
     1de:	e7 9b       	sbis	0x1c, 7	; 28
     1e0:	21 9c       	mul	r2, r1
     1e2:	84 9c       	mul	r8, r4
     1e4:	c8 a0       	ldd	r12, Y+32	; 0x20
     1e6:	4c 9b       	sbis	0x09, 4	; 9
     1e8:	f1 a0       	ldd	r15, Z+33	; 0x21
     1ea:	df a1       	ldd	r29, Y+39	; 0x27
     1ec:	9b a1       	ldd	r25, Y+35	; 0x23
     1ee:	c6 a1       	ldd	r28, Z+38	; 0x26
     1f0:	19 a2       	std	Y+33, r1	; 0x21
     1f2:	f9 a1       	ldd	r31, Y+33	; 0x21
     1f4:	30 a2       	std	Z+32, r3	; 0x20
     1f6:	49 a2       	std	Y+33, r4	; 0x21
     1f8:	5b a2       	std	Y+35, r5	; 0x23
     1fa:	0b a1       	ldd	r16, Y+35	; 0x23
     1fc:	64 a1       	ldd	r22, Z+36	; 0x24
     1fe:	81 a1       	ldd	r24, Z+33	; 0x21
     200:	94 9c       	mul	r9, r4
     202:	b4 9c       	mul	r11, r4
     204:	db 9c       	mul	r13, r11
     206:	ea 9c       	mul	r14, r10
     208:	08 9d       	mul	r16, r8
     20a:	1f 9d       	mul	r17, r15
     20c:	4b 9d       	mul	r20, r11
     20e:	62 9d       	mul	r22, r2
     210:	8e 9d       	mul	r24, r14
     212:	ae 9d       	mul	r26, r14
     214:	df 9d       	mul	r29, r15
     216:	ee 9d       	mul	r30, r14
     218:	47 9e       	mul	r4, r23
     21a:	be 9e       	mul	r11, r30
     21c:	d2 9e       	mul	r13, r18
     21e:	ad 9f       	mul	r26, r29
     220:	ad 9f       	mul	r26, r29
     222:	e6 9e       	mul	r14, r22
     224:	fa 9e       	mul	r15, r26
     226:	02 9f       	mul	r16, r18
     228:	1e 9f       	mul	r17, r30
     22a:	32 9f       	mul	r19, r18
     22c:	3f 9f       	mul	r19, r31
     22e:	56 9f       	mul	r21, r22
     230:	6d 9f       	mul	r22, r29
     232:	8b 9f       	mul	r24, r27
     234:	b0 9f       	mul	r27, r16
     236:	c7 9f       	mul	r28, r23
     238:	de 9f       	mul	r29, r30
     23a:	f5 9f       	mul	r31, r21
     23c:	0c a0       	ldd	r0, Y+36	; 0x24
     23e:	23 a0       	ldd	r2, Z+35	; 0x23
     240:	3a a0       	ldd	r3, Y+34	; 0x22
     242:	51 a0       	ldd	r5, Z+33	; 0x21
     244:	60 a0       	ldd	r6, Z+32	; 0x20
     246:	77 a0       	ldd	r7, Z+39	; 0x27
     248:	9a a0       	ldd	r9, Y+34	; 0x22
     24a:	cf a6       	std	Y+47, r12	; 0x2f
     24c:	d2 a6       	std	Z+42, r13	; 0x2a
     24e:	72 a7       	std	Z+42, r23	; 0x2a
     250:	81 a7       	std	Z+41, r24	; 0x29
     252:	b2 a7       	std	Z+42, r27	; 0x2a
     254:	c0 a7       	std	Z+40, r28	; 0x28
     256:	ec a7       	std	Y+44, r30	; 0x2c
     258:	91 a7       	std	Z+41, r25	; 0x29
     25a:	9e a7       	std	Y+46, r25	; 0x2e
     25c:	a8 a7       	std	Y+40, r26	; 0x28
     25e:	f6 a7       	std	Z+46, r31	; 0x2e
     260:	03 a8       	ldd	r0, Z+51	; 0x33
     262:	0e a8       	ldd	r0, Y+54	; 0x36
     264:	11 a8       	ldd	r1, Z+49	; 0x31
     266:	14 a8       	ldd	r1, Z+52	; 0x34
     268:	17 a8       	ldd	r1, Z+55	; 0x37
     26a:	1a a8       	ldd	r1, Y+50	; 0x32
     26c:	1d a8       	ldd	r1, Y+53	; 0x35
     26e:	20 a8       	ldd	r2, Z+48	; 0x30
     270:	23 a8       	ldd	r2, Z+51	; 0x33
     272:	45 a8       	ldd	r4, Z+53	; 0x35
     274:	33 a8       	ldd	r3, Z+51	; 0x33
     276:	26 a8       	ldd	r2, Z+54	; 0x36
     278:	3e a8       	ldd	r3, Y+54	; 0x36
     27a:	5c a7       	std	Y+44, r21	; 0x2c

0000027c <__c.3017>:
     27c:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

0000028b <__c.2987>:
     28b:	57 61 74 63 68 44 6f 67 00                          WatchDog.

00000294 <__c.2985>:
     294:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

0000029d <__c.2983>:
     29d:	45 78 74 65 72 6e 61 6c 00                          External.

000002a6 <__c.2978>:
     2a6:	50 6f 77 65 72 4f 6e 00                             PowerOn.

000002ae <__prodloc>:
     2ae:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

000002ba <__prntloc>:
     2ba:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

000002c6 <__prntlmt>:
     2c6:	02 03 04 02 0f 0f                                   ......

000002cc <__prntstr>:
     2cc:	01 01 00 00 00 00                                   ......

000002d2 <__hostloc>:
     2d2:	01 0a 02 0a 03 0a                                   ......

000002d8 <MaxKeyHit>:
     2d8:	02 04 03 03 03 03 03 04 03 04                       ..........

000002e2 <strDispenserName1>:
     2e2:	4e 2f 41 00                                         N/A.

000002e6 <strDispenserName2>:
     2e6:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

000002ef <strDispenserName3>:
     2ef:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

000002fa <strDispenserName4>:
     2fa:	54 61 74 73 75 6e 6f 00                             Tatsuno.

00000302 <strDispenserName5>:
     302:	4c 47 00                                            LG.

00000305 <DefListDispenserName>:
     305:	e2 02 e6 02 ef 02 fa 02 02 03                       ..........

0000030f <__c.9942>:
     30f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     31f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     32f:	20 20 20 20 20 20 20 20 00                                  .

00000338 <__c.9940>:
     338:	20 20 20 20 20 20 53 65 6d 6f 67 61 20 53 65 6c           Semoga Sel
     348:	61 6d 61 74 20 53 61 6d 70 61 69 20 54 75 6a 75     amat Sampai Tuju
     358:	61 6e 20 20 20 20 20 20 00                          an      .

00000361 <__c.9938>:
     361:	20 20 20 20 20 20 20 20 20 20 20 20 53 65 6c 61                 Sela
     371:	6d 61 74 20 20 4a 61 6c 61 6e 20 20 20 20 20 20     mat  Jalan      
     381:	20 20 20 20 20 20 20 20 00                                  .

0000038a <__c.9936>:
     38a:	20 20 20 20 20 20 20 20 20 20 20 20 20 54 65 72                  Ter
     39a:	69 6d 61 20 4b 61 73 69 68 20 20 20 20 20 20 20     ima Kasih       
     3aa:	20 20 20 20 20 20 20 20 00                                  .

000003b3 <__c.9934>:
     3b3:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     3c3:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     3d3:	20 20 20 20 20 20 20 20 00                                  .

000003dc <__c.9932>:
     3dc:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     3ec:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     3fc:	20 20 20 20 20 20 20 20 00                                  .

00000405 <__c.9930>:
     405:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     415:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     425:	20 20 20 20 20 20 20 20 00                                  .

0000042e <__c.9928>:
     42e:	20 20 20 20 20 20 20 20 20 20 20 20 4a 61 6b 61                 Jaka
     43e:	72 74 61 20 53 65 6c 61 74 61 6e 20 20 20 20 20     rta Selatan     
     44e:	20 20 20 20 20 20 20 20 00                                  .

00000457 <__c.9926>:
     457:	20 20 20 20 20 20 20 20 4a 4c 2e 20 52 53 20 46             JL. RS F
     467:	61 74 6d 61 77 61 74 69 20 4e 6f 2e 35 35 20 20     atmawati No.55  
     477:	20 20 20 20 20 20 20 20 00                                  .

00000480 <__c.9924>:
     480:	20 20 20 20 50 54 2e 20 48 41 4e 49 4e 44 4f 20         PT. HANINDO 
     490:	41 55 54 4f 4d 41 54 49 4f 4e 20 53 4f 4c 55 54     AUTOMATION SOLUT
     4a0:	49 4f 4e 53 20 20 20 20 00                          IONS    .

000004a9 <__c.9922>:
     4a9:	30 30 30 30 30 30 00                                000000.

000004b0 <__c.9920>:
     4b0:	42 52 49 00                                         BRI.

000004b4 <__c.9918>:
     4b4:	42 4e 49 00                                         BNI.

000004b8 <__c.9916>:
     4b8:	4d 61 6e 64 69 72 69 00                             Mandiri.

000004c0 <__c.9914>:
     4c0:	42 43 41 00                                         BCA.

000004c4 <__c.9912>:
     4c4:	44 69 65 73 65 6c 20 20 00                          Diesel  .

000004cd <__c.9910>:
     4cd:	42 69 6f 53 6f 6c 72 20 00                          BioSolr .

000004d6 <__c.9908>:
     4d6:	53 6f 6c 61 72 20 20 20 00                          Solar   .

000004df <__c.9906>:
     4df:	50 72 65 6d 69 75 6d 20 00                          Premium .

000004e8 <__c.9904>:
     4e8:	50 65 72 74 61 6d 61 78 00                          Pertamax.

000004f1 <__c.9902>:
     4f1:	50 65 72 74 2b 20 20 20 00                          Pert+   .

000004fa <__c.9900>:
     4fa:	36 35 30 30 00                                      6500.

000004ff <__c.9898>:
     4ff:	34 35 30 30 00                                      4500.

00000504 <__c.9896>:
     504:	36 35 30 30 00                                      6500.

00000509 <__c.9894>:
     509:	34 35 30 30 00                                      4500.

0000050e <__c.9892>:
     50e:	37 32 35 30 00                                      7250.

00000513 <__c.9890>:
     513:	36 35 30 30 00                                      6500.

00000518 <__c.9888>:
     518:	20 20 00                                              .

0000051b <__c.9792>:
     51b:	25 64 00                                            %d.

0000051e <__c.9790>:
     51e:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     52e:	73 25 73 25 73 3a 00                                s%s%s:.

00000535 <__c.9741>:
     535:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     545:	3a 25 73 00                                         :%s.

00000549 <__c.9713>:
     549:	25 73 00                                            %s.

0000054c <__c.9704>:
     54c:	25 73 00                                            %s.

0000054f <__c.9653>:
     54f:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

00000557 <__c.9632>:
     557:	43 54 53 52 50 00                                   CTSRP.

0000055d <__c.9608>:
     55d:	3a 00                                               :.

0000055f <__c.9454>:
     55f:	4e 2f 41 00                                         N/A.

00000563 <__c.9434>:
     563:	25 73 00                                            %s.

00000566 <__c.9429>:
	...

00000567 <__c.9302>:
     567:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

00000571 <__c.9300>:
     571:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

0000057f <__c.9292>:
     57f:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

0000058a <__c.9290>:
     58a:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

00000599 <__c.9286>:
     599:	25 73 25 73 00                                      %s%s.

0000059e <__c.9284>:
     59e:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000005a7 <__c.9282>:
     5a7:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     5b7:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

000005c5 <__c.9280>:
     5c5:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     5d5:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

000005e3 <__c.9278>:
     5e3:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

000005ee <__c.9276>:
     5ee:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

000005fd <__c.9274>:
     5fd:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

00000608 <__c.9272>:
     608:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

00000617 <__c.9270>:
     617:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

00000624 <__c.9268>:
     624:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     634:	73 00                                               s.

00000636 <__c.9266>:
     636:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

00000643 <__c.9262>:
     643:	4e 2f 41 00                                         N/A.

00000647 <__c.9258>:
     647:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     657:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     667:	20 20 20 20 20 20 00                                      .

0000066e <__c.9256>:
     66e:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     67e:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     68e:	41 48 28 52 50 29 00                                AH(RP).

00000695 <__c.9252>:
     695:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     6a5:	20 00                                                .

000006a7 <__c.9250>:
     6a7:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     6b7:	20 00                                                .

000006b9 <__c.9248>:
     6b9:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     6c9:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     6d9:	20 20 20 20 20 00                                        .

000006df <__c.9246>:
     6df:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     6ef:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     6ff:	20 20 20 20 20 00                                        .

00000705 <__c.9243>:
     705:	25 64 00                                            %d.

00000708 <__c.9185>:
     708:	25 73 00                                            %s.

0000070b <__c.9180>:
     70b:	30 00                                               0.

0000070d <__c.9178>:
     70d:	30 00                                               0.

0000070f <__c.9014>:
     70f:	25 73 00                                            %s.

00000712 <__c.9012>:
     712:	25 73 00                                            %s.

00000715 <__c.9010>:
     715:	25 73 00                                            %s.

00000718 <__c.9008>:
     718:	25 73 00                                            %s.

0000071b <__c.9006>:
     71b:	25 73 00                                            %s.

0000071e <__c.8810>:
     71e:	25 73 00                                            %s.

00000721 <__c.8722>:
     721:	30 30 30 30 30 30 30 30 00                          00000000.

0000072a <__c.8641>:
     72a:	4f 70 65 72 61 74 6f 72 3a 20 25 73 00              Operator: %s.

00000737 <__c.8636>:
     737:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     747:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     757:	2d 00                                               -.

00000759 <__c.8627>:
     759:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     769:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     779:	20 20 20 00                                            .

0000077d <__c.8625>:
     77d:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     78d:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     79d:	20 20 20 00                                            .

000007a1 <__c.8473>:
     7a1:	20 20 20 20 20 4f 70 65 72 61 74 6f 72 3a 20 25          Operator: %
     7b1:	73 00                                               s.

000007b3 <__c.8468>:
     7b3:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     7c3:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     7d3:	2d 2d 00                                            --.

000007d6 <__c.8465>:
     7d6:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     7e6:	6d 74 3a 20 25 73 00                                mt: %s.

000007ed <__c.8462>:
     7ed:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     7fd:	73 63 3a 20 25 73 00                                sc: %s.

00000804 <__c.8459>:
     804:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     814:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     824:	2d 2d 00                                            --.

00000827 <__c.8456>:
     827:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     837:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

00000841 <__c.8453>:
     841:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     851:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

0000085a <__c.8450>:
     85a:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     86a:	6d 20 3a 20 25 73 00                                m : %s.

00000871 <__c.8447>:
     871:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     881:	20 20 3a 20 25 73 00                                  : %s.

00000888 <__c.8444>:
     888:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     898:	20 20 3a 20 25 73 00                                  : %s.

0000089f <__c.8441>:
     89f:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     8af:	20 20 3a 20 25 73 00                                  : %s.

000008b6 <__c.8438>:
     8b6:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     8c6:	20 20 3a 20 25 73 00                                  : %s.

000008cd <__c.8435>:
     8cd:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     8dd:	20 20 3a 20 25 73 00                                  : %s.

000008e4 <__c.8432>:
     8e4:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     8f4:	20 20 3a 20 25 73 00                                  : %s.

000008fb <__c.8429>:
     8fb:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     90b:	20 20 3a 20 25 73 20 00                               : %s .

00000913 <__c.8426>:
     913:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     923:	20 20 3a 20 25 73 00                                  : %s.

0000092a <__c.8423>:
     92a:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     93a:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     94a:	20 20 00                                              .

0000094d <__c.8420>:
     94d:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     95d:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     96d:	2d 2d 00                                            --.

00000970 <__c.8417>:
     970:	20 20 20 20 2e 25 73 00                                 .%s.

00000978 <__c.8413>:
     978:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     988:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     998:	5f 29 00                                            _).

0000099b <__c.8408>:
     99b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     9ab:	20 20 20 20 20 20 00                                      .

000009b2 <__c.8405>:
     9b2:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     9c2:	20 20 20 20 20 20 00                                      .

000009c9 <__c.8402>:
     9c9:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     9d9:	20 00                                                .

000009db <__c.8400>:
     9db:	20 20 00                                              .

000009de <__c.8398>:
     9de:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     9ee:	73 00                                               s.

000009f0 <__c.8396>:
     9f0:	25 73 20 20 00                                      %s  .

000009f5 <__c.8394>:
     9f5:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     a05:	73 00                                               s.

00000a07 <__c.8391>:
     a07:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     a17:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     a27:	20 20 00                                              .

00000a2a <__c.8389>:
     a2a:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     a3a:	25 73 00                                            %s.

00000a3d <__c.8387>:
     a3d:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     a4d:	73 00                                               s.

00000a4f <__c.8384>:
     a4f:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     a5f:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     a6f:	2d 2d 00                                            --.

00000a72 <__c.8381>:
     a72:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     a82:	20 20 3a 20 25 73 00                                  : %s.

00000a89 <__c.8378>:
     a89:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     a99:	20 20 3a 20 25 73 00                                  : %s.

00000aa0 <__c.8375>:
	...

00000aa1 <__c.8373>:
     aa1:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     ab1:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000abb <__c.8370>:
     abb:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     acb:	20 20 3a 20 25 73 20 4c 00                            : %s L.

00000ad4 <__c.8367>:
	...

00000ad5 <__c.8365>:
     ad5:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     ae5:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000aef <__c.8362>:
     aef:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     aff:	20 20 3a 20 25 73 00                                  : %s.

00000b06 <__c.8359>:
     b06:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     b16:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

00000b22 <__c.8356>:
     b22:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     b32:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     b42:	2d 2d 00                                            --.

00000b45 <__c.8353>:
     b45:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     b55:	25 73 20 00                                         %s .

00000b59 <__c.8349>:
     b59:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     b69:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000b78 <__c.8332>:
     b78:	20 00                                                .

00000b7a <__c.8330>:
     b7a:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     b8a:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     b9a:	20 20 20 00                                            .

00000b9e <__c.7918>:
     b9e:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     bae:	69 6f 6e 00                                         ion.

00000bb2 <__c.7912>:
     bb2:	50 72 6f 73 65 73 00                                Proses.

00000bb9 <__c.7910>:
     bb9:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000bc6 <__c.7905>:
     bc6:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     bd6:	6e 74 65 72 00                                      nter.

00000bdb <__c.7903>:
     bdb:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     beb:	6e 74 65 72 00                                      nter.

00000bf0 <__c.7900>:
     bf0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     c00:	74 65 72 20 00                                      ter .

00000c05 <__c.7898>:
     c05:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000c11 <__c.7896>:
     c11:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000c1e <__c.7893>:
     c1e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     c2e:	6e 74 65 72 00                                      nter.

00000c33 <__c.7891>:
     c33:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     c43:	6e 74 65 72 00                                      nter.

00000c48 <__c.7888>:
     c48:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     c58:	74 65 72 20 00                                      ter .

00000c5d <__c.7886>:
     c5d:	5f 00                                               _.

00000c5f <__c.7884>:
     c5f:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000c6f <__c.7808>:
     c6f:	23 29 53 61 76 65 00                                #)Save.

00000c76 <__c.7806>:
     c76:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000c83 <__c.7804>:
     c83:	25 64 00                                            %d.

00000c86 <__c.7792>:
     c86:	25 64 00                                            %d.

00000c89 <__c.7784>:
     c89:	23 29 53 61 76 65 00                                #)Save.

00000c90 <__c.7782>:
     c90:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000c9d <__c.7780>:
     c9d:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     cad:	45 78 69 74 00                                      Exit.

00000cb2 <__c.7778>:
     cb2:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000cbc <__c.7776>:
     cbc:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000cc6 <__c.7723>:
     cc6:	25 2e 32 64 00                                      %.2d.

00000ccb <__c.7721>:
     ccb:	25 64 00                                            %d.

00000cce <__c.7704>:
     cce:	25 2e 32 64 00                                      %.2d.

00000cd3 <__c.7702>:
     cd3:	25 64 00                                            %d.

00000cd6 <__c.7694>:
     cd6:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000ce6 <__c.7692>:
     ce6:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000cf6 <__c.7690>:
     cf6:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     d06:	20 3a 00                                             :.

00000d09 <__c.7688>:
     d09:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     d19:	6c 3a 00                                            l:.

00000d1c <__c.7624>:
     d1c:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     d2c:	53 61 76 65 00                                      Save.

00000d31 <__c.7622>:
     d31:	54 49 4d 45 20 3a 20 00                             TIME : .

00000d39 <__c.7620>:
     d39:	44 41 54 45 20 3a 20 00                             DATE : .

00000d41 <__c.7570>:
     d41:	25 64 00                                            %d.

00000d44 <__c.7559>:
     d44:	25 64 00                                            %d.

00000d47 <__c.7551>:
     d47:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     d57:	53 61 76 65 00                                      Save.

00000d5c <__c.7549>:
     d5c:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     d6c:	4e 36 3a 00                                         N6:.

00000d70 <__c.7547>:
     d70:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     d80:	4e 35 3a 00                                         N5:.

00000d84 <__c.7545>:
     d84:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000d94 <__c.7461>:
     d94:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000d9e <__c.7459>:
     d9e:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000daa <__c.7456>:
     daa:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000db8 <__c.7453>:
     db8:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000dc1 <__c.7451>:
     dc1:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000dca <__c.7447>:
     dca:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     dda:	20 20 20 20 00                                          .

00000ddf <__c.7445>:
     ddf:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     def:	49 44 20 20 00                                      ID  .

00000df4 <__c.7443>:
     df4:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     e04:	20 20 20 20 00                                          .

00000e09 <__c.7431>:
     e09:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     e19:	2e 32 64 00                                         .2d.

00000e1d <__c.7425>:
     e1d:	23 29 53 61 76 65 00                                #)Save.

00000e24 <__c.7423>:
     e24:	2a 29 42 61 63 6b 00                                *)Back.

00000e2b <__c.7418>:
     e2b:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     e3b:	2e 32 64 00                                         .2d.

00000e3f <__c.7369>:
     e3f:	25 2e 32 64 00                                      %.2d.

00000e44 <__c.7363>:
     e44:	25 2e 32 64 00                                      %.2d.

00000e49 <__c.7361>:
     e49:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     e59:	45 78 69 74 00                                      Exit.

00000e5e <__c.7359>:
     e5e:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     e6e:	53 61 76 65 00                                      Save.

00000e73 <__c.7357>:
     e73:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000e7f <__c.7355>:
     e7f:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000e8b <__c.7321>:
     e8b:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     e9b:	67 65 20 00                                         ge .

00000e9f <__c.7319>:
     e9f:	25 64 2e 25 73 00                                   %d.%s.

00000ea5 <__c.7314>:
     ea5:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     eb5:	2d 00                                               -.

00000eb7 <__c.7298>:
     eb7:	2a 29 45 78 69 74 00                                *)Exit.

00000ebe <__c.7296>:
     ebe:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000ec8 <__c.7294>:
     ec8:	31 29 49 44 00                                      1)ID.

00000ecd <__c.7279>:
     ecd:	2a 29 45 78 69 74 00                                *)Exit.

00000ed4 <__c.7274>:
     ed4:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     ee4:	2e 32 64 20 00                                      .2d .

00000ee9 <__c.7265>:
     ee9:	25 2e 32 64 00                                      %.2d.

00000eee <__c.7064>:
     eee:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000ef6 <__c.7062>:
     ef6:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000eff <__c.7060>:
     eff:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000f08 <__c.7058>:
     f08:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000f15 <__c.7056>:
     f15:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000f22 <__c.7054>:
     f22:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000f2f <__c.7052>:
     f2f:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000f3c <__c.6993>:
     f3c:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000f49 <__c.6988>:
     f49:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000f52 <__c.6986>:
     f52:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     f62:	20 20 20 20 00                                          .

00000f67 <__c.6981>:
     f67:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000f75 <__c.6979>:
     f75:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000f80 <__c.6977>:
     f80:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000f8b <__c.6975>:
     f8b:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000f96 <__c.6973>:
     f96:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000fa1 <__c.6971>:
     fa1:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     fb1:	65 00                                               e.

00000fb3 <__c.6969>:
     fb3:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000fc0 <__c.6967>:
     fc0:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000fcc <__c.6920>:
     fcc:	49 6e 76 61 6c 69 64 20 4f 6c 64 20 50 61 73 73     Invalid Old Pass
     fdc:	77 6f 72 64 00                                      word.

00000fe1 <__c.6918>:
     fe1:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     ff1:	20 20 20 20 00                                          .

00000ff6 <__c.6916>:
     ff6:	49 6e 76 61 6c 69 64 20 4e 65 77 20 50 61 73 73     Invalid New Pass
    1006:	77 6f 72 64 00                                      word.

0000100b <__c.6914>:
    100b:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
    101b:	20 20 20 20 00                                          .

00001020 <__c.6912>:
    1020:	20 20 20 50 61 73 73 77 6f 72 64 20 53 61 76 65        Password Save
    1030:	64 20 20 20 00                                      d   .

00001035 <__c.6910>:
    1035:	20 20 20 20 20 43 6f 6d 70 6c 65 74 65 64 20 20          Completed  
    1045:	20 20 20 20 00                                          .

0000104a <__c.6906>:
    104a:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    105a:	6e 74 65 72 00                                      nter.

0000105f <__c.6903>:
    105f:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    106f:	6e 74 65 72 00                                      nter.

00001074 <__c.6900>:
    1074:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1084:	6e 74 65 72 00                                      nter.

00001089 <__c.6898>:
    1089:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
    1099:	20 20 20 20 00                                          .

0000109e <__c.6894>:
    109e:	56 61 6c 69 64 61 74 69 6e 67 2e 2e 00              Validating...

000010ab <__c.6890>:
    10ab:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    10bb:	6e 74 65 72 00                                      nter.

000010c0 <__c.6887>:
    10c0:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    10d0:	6e 74 65 72 00                                      nter.

000010d5 <__c.6882>:
    10d5:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    10e5:	6e 74 65 72 00                                      nter.

000010ea <__c.6880>:
    10ea:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
    10fa:	20 20 20 20 00                                          .

000010ff <__c.6876>:
    10ff:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    110f:	6e 74 65 72 00                                      nter.

00001114 <__c.6873>:
    1114:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1124:	6e 74 65 72 00                                      nter.

00001129 <__c.6868>:
    1129:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1139:	6e 74 65 72 00                                      nter.

0000113e <__c.6866>:
    113e:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
    114e:	20 20 20 20 00                                          .

00001153 <__c.6862>:
    1153:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1163:	6e 74 65 72 00                                      nter.

00001168 <__c.6860>:
    1168:	4f 6c 64 3a 5f 00                                   Old:_.

0000116e <__c.6858>:
    116e:	2d 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 2d 00     -Administrator-.

0000117e <__c.6856>:
    117e:	2d 53 75 70 65 72 76 69 73 6f 72 2d 00              -Supervisor-.

0000118b <__c.6848>:
    118b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00001198 <__c.6846>:
    1198:	32 2e 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 00     2.Administrator.

000011a8 <__c.6844>:
    11a8:	31 2e 53 75 70 65 72 76 69 73 6f 72 00              1.Supervisor.

000011b5 <__c.6842>:
    11b5:	2d 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72 64     -Change Password
    11c5:	2d 00                                               -.

000011c7 <__c.6839>:
    11c7:	53 61 76 65 64 20 00                                Saved .

000011ce <__c.6833>:
    11ce:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    11de:	6e 74 65 72 00                                      nter.

000011e3 <__c.6830>:
    11e3:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    11f3:	6e 74 65 72 00                                      nter.

000011f8 <__c.6825>:
    11f8:	5b 2a 5d 4e 6f 20 20 20 20 5b 23 5d 59 65 73 00     [*]No    [#]Yes.

00001208 <__c.6823>:
    1208:	53 61 76 65 3f 00                                   Save?.

0000120e <__c.6821>:
    120e:	4e 65 77 20 4f 70 65 72 61 74 6f 72 3a 00           New Operator:.

0000121c <__c.6819>:
    121c:	25 73 00                                            %s.

0000121f <__c.6815>:
    121f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    122f:	6e 74 65 72 00                                      nter.

00001234 <__c.6813>:
    1234:	4e 65 77 20 3a 5f 20 20 20 20 20 20 20 20 20 20     New :_          
    1244:	20 20 20 20 00                                          .

00001249 <__c.6811>:
    1249:	4e 61 6d 65 3a 00                                   Name:.

0000124f <__c.6809>:
    124f:	25 73 00                                            %s.

00001252 <__c.6800>:
    1252:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1262:	20 00                                                .

00001264 <__c.6798>:
    1264:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    1274:	64 00                                               d.

00001276 <__c.6796>:
    1276:	31 2e 43 68 61 6e 67 65 20 4f 70 65 72 61 74 6f     1.Change Operato
    1286:	72 00                                               r.

00001288 <__c.6714>:
    1288:	2a 29 42 61 63 6b 00                                *)Back.

0000128f <__c.6712>:
    128f:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

0000129e <__c.6710>:
    129e:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

000012ad <__c.6708>:
    12ad:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

000012bc <__c.6706>:
    12bc:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 00        1.T.Volume:%d .

000012cb <__c.6701>:
    12cb:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

000012dc <__c.6699>:
    12dc:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

000012e8 <__c.6697>:
    12e8:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

000012f4 <__c.6695>:
    12f4:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

00001300 <__c.6678>:
    1300:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

00001310 <__c.6676>:
    1310:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

0000131a <__c.6674>:
    131a:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00001324 <__c.6672>:
    1324:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

0000132e <__c.6632>:
    132e:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    133e:	20 20 20 20 00                                          .

00001343 <__c.6630>:
    1343:	4e 65 77 3a 5f 00                                   New:_.

00001349 <__c.6628>:
    1349:	4f 6c 64 3a 25 73 00                                Old:%s.

00001350 <__c.6626>:
    1350:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1360:	20 20 20 20 00                                          .

00001365 <__c.6624>:
    1365:	4e 65 77 3a 5f 00                                   New:_.

0000136b <__c.6622>:
    136b:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    137b:	65 20 20 20 00                                      e   .

00001380 <__c.6620>:
    1380:	4f 6c 64 3a 25 73 00                                Old:%s.

00001387 <__c.6617>:
    1387:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

00001395 <__c.6615>:
    1395:	32 29 25 73 00                                      2)%s.

0000139a <__c.6613>:
    139a:	31 29 25 73 00                                      1)%s.

0000139f <__c.6608>:
    139f:	2a 29 42 61 63 6b 00                                *)Back.

000013a6 <__c.6603>:
    13a6:	25 64 29 25 73 00                                   %d)%s.

000013ac <__c.6534>:
    13ac:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    13bc:	20 20 20 20 00                                          .

000013c1 <__c.6532>:
    13c1:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    13d1:	20 20 20 20 00                                          .

000013d6 <__c.6530>:
    13d6:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    13e6:	20 20 20 20 00                                          .

000013eb <__c.6528>:
    13eb:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    13fb:	20 20 20 20 00                                          .

00001400 <__c.6525>:
    1400:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    1410:	74 20 20 20 00                                      t   .

00001415 <__c.6523>:
    1415:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    1425:	74 20 20 20 00                                      t   .

0000142a <__c.6521>:
    142a:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    143a:	74 20 20 20 00                                      t   .

0000143f <__c.6519>:
    143f:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    144f:	6e 74 65 72 00                                      nter.

00001454 <__c.6434>:
    1454:	2e 00                                               ..

00001456 <__c.6432>:
    1456:	25 64 00                                            %d.

00001459 <__c.6430>:
    1459:	20 20 20 00                                            .

0000145d <__c.6428>:
    145d:	2e 00                                               ..

0000145f <__c.6426>:
    145f:	25 64 00                                            %d.

00001462 <__c.6424>:
    1462:	20 20 20 00                                            .

00001466 <__c.6417>:
    1466:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    1476:	78 74 20 20 00                                      xt  .

0000147b <__c.6415>:
    147b:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    148b:	2e 20 20 20 00                                      .   .

00001490 <__c.6413>:
    1490:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

000014a1 <__c.6411>:
    14a1:	53 65 72 76 65 72 20 49 50 00                       Server IP.

000014ab <__c.6322>:
    14ab:	2e 00                                               ..

000014ad <__c.6320>:
    14ad:	25 64 00                                            %d.

000014b0 <__c.6318>:
    14b0:	20 20 20 00                                            .

000014b4 <__c.6316>:
    14b4:	2e 00                                               ..

000014b6 <__c.6314>:
    14b6:	25 64 00                                            %d.

000014b9 <__c.6312>:
    14b9:	20 20 20 00                                            .

000014bd <__c.6305>:
    14bd:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    14cd:	78 74 20 20 00                                      xt  .

000014d2 <__c.6303>:
    14d2:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    14e2:	2e 20 20 20 00                                      .   .

000014e7 <__c.6301>:
    14e7:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

000014f8 <__c.6299>:
    14f8:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

00001502 <__c.6257>:
    1502:	25 73 25 73 00                                      %s%s.

00001507 <__c.6253>:
    1507:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

00001514 <__c.6251>:
    1514:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

00001524 <__c.6247>:
    1524:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

00001532 <__c.6245>:
    1532:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

00001540 <__c.6242>:
    1540:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

0000154f <__c.6240>:
    154f:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

0000155e <__c.6236>:
    155e:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    156e:	20 20 20 20 00                                          .

00001573 <__c.6234>:
    1573:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1583:	20 20 20 20 00                                          .

00001588 <__c.6232>:
    1588:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    1598:	74 65 72 34 00                                      ter4.

0000159d <__c.6230>:
    159d:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    15ad:	74 65 72 33 00                                      ter3.

000015b2 <__c.6199>:
    15b2:	25 73 25 73 00                                      %s%s.

000015b7 <__c.6195>:
    15b7:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

000015c4 <__c.6193>:
    15c4:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

000015d4 <__c.6189>:
    15d4:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

000015e2 <__c.6187>:
    15e2:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

000015f0 <__c.6184>:
    15f0:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000015ff <__c.6182>:
    15ff:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

0000160e <__c.6178>:
    160e:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    161e:	20 20 20 20 00                                          .

00001623 <__c.6176>:
    1623:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    1633:	64 65 72 36 00                                      der6.

00001638 <__c.6174>:
    1638:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    1648:	64 65 72 35 00                                      der5.

0000164d <__c.6172>:
    164d:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    165d:	64 65 72 34 00                                      der4.

00001662 <__c.6129>:
    1662:	2a 29 45 78 69 74 00                                *)Exit.

00001669 <__c.6127>:
    1669:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    1679:	20 20 20 20 00                                          .

0000167e <__c.6125>:
    167e:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    168e:	20 20 20 20 00                                          .

00001693 <__c.6123>:
    1693:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    16a3:	20 20 20 20 00                                          .

000016a8 <__c.6121>:
    16a8:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    16b8:	72 76 65 72 00                                      rver.

000016bd <__c.6119>:
    16bd:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    16cd:	69 65 6e 74 00                                      ient.

000016d2 <__c.6065>:
    16d2:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    16e2:	2e 2e 20 00                                         .. .

000016e6 <__c.6060>:
    16e6:	25 73 20 25 73 00                                   %s %s.

000016ec <__c.6058>:
    16ec:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    16fc:	65 72 00                                            er.

000016ff <__c.6054>:
    16ff:	43 61 6e 63 65 6c 00                                Cancel.

00001706 <__c.6049>:
    1706:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    1716:	25 64 20 00                                         %d .

0000171a <__c.6044>:
    171a:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

00001728 <__c.6040>:
    1728:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

00001736 <__c.6038>:
    1736:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

00001742 <__c.5966>:
    1742:	2a 29 45 78 69 74 00                                *)Exit.

00001749 <__c.5964>:
    1749:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

00001757 <__c.5962>:
    1757:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

00001765 <__c.5960>:
    1765:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

00001773 <__c.5918>:
    1773:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    1783:	78 69 74 20 00                                      xit .

00001788 <__c.5916>:
    1788:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    1798:	20 20 20 20 00                                          .

0000179d <__c.5914>:
    179d:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    17ad:	20 20 20 20 00                                          .

000017b2 <__c.5912>:
    17b2:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    17c2:	20 20 20 20 00                                          .

000017c7 <__c.5877>:
    17c7:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    17d7:	64 00                                               d.

000017d9 <__c.5873>:
    17d9:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    17e9:	20 00                                                .

000017eb <__c.5870>:
    17eb:	30 30 30 30 30 00                                   00000.

000017f1 <__c.5868>:
    17f1:	31 31 31 31 31 00                                   11111.

000017f7 <__c.5864>:
    17f7:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1807:	6e 74 65 72 00                                      nter.

0000180c <__c.5861>:
    180c:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    181c:	6e 74 65 72 00                                      nter.

00001821 <__c.5854>:
    1821:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1831:	6e 74 65 72 00                                      nter.

00001836 <__c.5852>:
    1836:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    1846:	20 20 20 20 00                                          .

0000184b <__c.5850>:
    184b:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    185b:	64 65 20 20 00                                      de  .

00001860 <__c.5848>:
    1860:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

0000186e <__c.5844>:
    186e:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    187e:	20 20 20 20 00                                          .

00001883 <__c.5841>:
	...

00001884 <__c.5839>:
    1884:	25 73 00                                            %s.

00001887 <__c.5837>:
    1887:	25 73 00                                            %s.

0000188a <__c.5834>:
    188a:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    189a:	6e 74 65 72 00                                      nter.

0000189f <__c.5831>:
    189f:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    18af:	6e 74 65 72 00                                      nter.

000018b4 <__c.5824>:
	...

000018b5 <__c.5822>:
    18b5:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18c5:	6e 74 65 72 00                                      nter.

000018ca <__c.5820>:
    18ca:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    18da:	20 20 20 20 00                                          .

000018df <__c.5818>:
    18df:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    18ef:	65 20 20 20 00                                      e   .

000018f4 <__c.5813>:
    18f4:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    1904:	20 20 20 20 00                                          .

00001909 <__c.5810>:
    1909:	52 65 73 65 74 20 43 6f 6d 70 6c 65 74 65 00        Reset Complete.

00001918 <__c.5807>:
    1918:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 00           Please Wait...

00001926 <__c.5805>:
    1926:	52 65 73 65 74 20 45 45 50 52 4f 4d 00              Reset EEPROM.

00001933 <__c.5801>:
    1933:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1943:	6e 74 65 72 00                                      nter.

00001948 <__c.5798>:
    1948:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1958:	6e 74 65 72 00                                      nter.

0000195d <__c.5791>:
    195d:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    196d:	6e 74 65 72 00                                      nter.

00001972 <__c.5789>:
    1972:	52 65 73 65 74 43 6f 64 65 3a 5f 20 20 20 20 20     ResetCode:_     
    1982:	20 20 20 20 00                                          .

00001987 <__c.5787>:
    1987:	53 65 65 64 20 43 6f 64 65 3a 25 73 00              Seed Code:%s.

00001994 <__c.5785>:
    1994:	2d 4d 61 73 74 65 72 20 52 65 73 65 74 2d 00        -Master Reset-.

000019a3 <__c.5783>:
	...

000019a4 <__c.5781>:
    19a4:	32 32 33 34 35 36 37 38 00                          22345678.

000019ad <__c.5779>:
    19ad:	25 73 00                                            %s.

000019b0 <__c.5770>:
    19b0:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    19c0:	20 20 20 20 00                                          .

000019c5 <__c.5768>:
    19c5:	32 2e 4d 61 73 74 65 72 20 52 65 73 65 74 20 20     2.Master Reset  
    19d5:	20 20 20 20 00                                          .

000019da <__c.5766>:
    19da:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    19ea:	72 64 20 20 00                                      rd  .

000019ef <__c.5764>:
    19ef:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    19ff:	76 65 6c 2d 00                                      vel-.

00001a04 <__c.5705>:
    1a04:	25 73 25 73 00                                      %s%s.

00001a09 <__c.5677>:
    1a09:	25 73 00                                            %s.

00001a0c <__c.5644>:
    1a0c:	25 63 00                                            %c.

00001a0f <__c.5642>:
    1a0f:	32 30 25 73 00                                      20%s.

00001a14 <__c.5620>:
    1a14:	25 73 00                                            %s.

00001a17 <__c.5572>:
    1a17:	34 32 36 34 36 33 36 00                             4264636.

00001a1f <__c.5569>:
    1a1f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1a2f:	6e 74 65 72 00                                      nter.

00001a34 <__c.5567>:
    1a34:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1a44:	6e 74 65 72 00                                      nter.

00001a49 <__c.5563>:
    1a49:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1a59:	6e 74 65 72 00                                      nter.

00001a5e <__c.5561>:
    1a5e:	5f 00                                               _.

00001a60 <__c.5559>:
    1a60:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001a6a <__c.5531>:
    1a6a:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001a78 <__c.5458>:
    1a78:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001a85 <__c.5456>:
    1a85:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

00001a92 <__c.5452>:
    1a92:	20 20 20 20 20 20 20 00                                    .

00001a9a <__c.5449>:
    1a9a:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

00001aa6 <__c.5446>:
    1aa6:	25 73 00                                            %s.

00001aa9 <__c.5444>:
    1aa9:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

00001ab3 <__c.5441>:
    1ab3:	25 73 00                                            %s.

00001ab6 <__c.5438>:
    1ab6:	25 73 00                                            %s.

00001ab9 <__c.5436>:
    1ab9:	25 73 00                                            %s.

00001abc <__c.5434>:
    1abc:	25 73 00                                            %s.

00001abf <__c.5430>:
    1abf:	25 73 00                                            %s.

00001ac2 <__c.5426>:
    1ac2:	50 72 6f 73 65 73 00                                Proses.

00001ac9 <__c.5424>:
    1ac9:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

00001ad7 <__c.5421>:
    1ad7:	50 72 6f 73 65 73 00                                Proses.

00001ade <__c.5419>:
    1ade:	49 44 3a 25 73 00                                   ID:%s.

00001ae4 <__c.5415>:
    1ae4:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1af4:	69 74 00                                            it.

00001af7 <__c.5413>:
    1af7:	46 49 50 25 73 00                                   FIP%s.

00001afd <__c.5411>:
    1afd:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001b0c <__c.5402>:
    1b0c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1b1c:	6e 74 65 72 00                                      nter.

00001b21 <__c.5400>:
    1b21:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1b31:	6e 74 65 72 00                                      nter.

00001b36 <__c.5397>:
    1b36:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1b46:	6e 74 65 72 00                                      nter.

00001b4b <__c.5395>:
    1b4b:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

00001b5b <__c.5393>:
    1b5b:	25 73 00                                            %s.

00001b5e <__c.5389>:
    1b5e:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

00001b66 <__c.5384>:
    1b66:	25 64 2e 25 73 00                                   %d.%s.

00001b6c <__c.5382>:
    1b6c:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

00001b78 <__c.5377>:
    1b78:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1b88:	6e 74 65 72 00                                      nter.

00001b8d <__c.5375>:
    1b8d:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1b9d:	6e 74 65 72 00                                      nter.

00001ba2 <__c.5372>:
    1ba2:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1bb2:	6e 74 65 72 00                                      nter.

00001bb7 <__c.5370>:
    1bb7:	5f 00                                               _.

00001bb9 <__c.5368>:
    1bb9:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

00001bc6 <__c.5359>:
    1bc6:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1bd6:	20 20 20 20 00                                          .

00001bdb <__c.5357>:
    1bdb:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    1beb:	54 65 73 74 00                                      Test.

00001bf0 <__c.5355>:
    1bf0:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    1c00:	68 65 72 20 00                                      her .

00001c05 <__c.5353>:
    1c05:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    1c15:	74 20 20 20 00                                      t   .

00001c1a <__c.5304>:
    1c1a:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

00001c25 <__c.5298>:
    1c25:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1c35:	20 20 20 20 00                                          .

00001c3a <__c.5296>:
    1c3a:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    1c4a:	20 20 20 20 00                                          .

00001c4f <__c.5294>:
    1c4f:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    1c5f:	72 64 20 20 00                                      rd  .

00001c64 <__c.5292>:
    1c64:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

00001c75 <__c.5259>:
    1c75:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001c83 <__c.5257>:
    1c83:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001c91 <__c.5250>:
    1c91:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

00001c9f <__c.5248>:
    1c9f:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

00001ca9 <__c.5246>:
    1ca9:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

00001cb3 <__c.5244>:
    1cb3:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

00001cbd <__c.5242>:
    1cbd:	25 73 3a 25 73 00                                   %s:%s.

00001cc3 <__c.5235>:
    1cc3:	50 72 6f 73 65 73 00                                Proses.

00001cca <__c.5233>:
    1cca:	49 44 3a 25 73 00                                   ID:%s.

00001cd0 <__c.5229>:
    1cd0:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1ce0:	69 74 00                                            it.

00001ce3 <__c.5227>:
    1ce3:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001cf2 <__c.5224>:
    1cf2:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1d02:	69 74 00                                            it.

00001d05 <__c.5222>:
    1d05:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001d14 <__c.5220>:
    1d14:	46 49 50 3a 25 73 00                                FIP:%s.

00001d1b <__c.5214>:
    1d1b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1d2b:	20 00                                                .

00001d2d <__c.5212>:
    1d2d:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1d3d:	20 00                                                .

00001d3f <__c.5210>:
    1d3f:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1d4f:	20 00                                                .

00001d51 <__c.5208>:
    1d51:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1d61:	20 00                                                .

00001d63 <__c.5171>:
    1d63:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001d71 <__c.5169>:
    1d71:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001d7f <__c.5163>:
    1d7f:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1d8f:	69 74 00                                            it.

00001d92 <__c.5161>:
    1d92:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1da2:	61 72 64 00                                         ard.

00001da6 <__c.5159>:
    1da6:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001db6 <__c.5155>:
    1db6:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1dc6:	6b 73 69 20 00                                      ksi .

00001dcb <__c.5146>:
    1dcb:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001dd9 <__c.5103>:
    1dd9:	25 2e 32 64 00                                      %.2d.

00001dde <__c.5099>:
    1dde:	2a 29 45 78 69 74 00                                *)Exit.

00001de5 <__c.5097>:
    1de5:	23 29 4f 4b 20 00                                   #)OK .

00001deb <__c.5095>:
    1deb:	20 20 20 20 20 00                                        .

00001df1 <__c.5093>:
    1df1:	46 49 50 3a 5f 00                                   FIP:_.

00001df7 <__c.5088>:
    1df7:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001e07 <__c.5039>:
    1e07:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001e18 <__c.4896>:
    1e18:	30 00                                               0.

00001e1a <__c.4827>:
    1e1a:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1e2a:	20 20 20 20 00                                          .

00001e2f <__c.4822>:
    1e2f:	23 25 73 00                                         #%s.

00001e33 <__c.4820>:
    1e33:	25 2e 32 64 00                                      %.2d.

00001e38 <__c.4818>:
    1e38:	40 46 49 50 3a 00                                   @FIP:.

00001e3e <__c.4816>:
    1e3e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1e4e:	20 20 20 20 00                                          .

00001e53 <__c.4812>:
    1e53:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001e63 <__c.4788>:
    1e63:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001e6f <__c.4777>:
    1e6f:	25 73 20 25 73 00                                   %s %s.

00001e75 <__c.4749>:
    1e75:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001e83 <__c.4747>:
    1e83:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001e90 <__c.4745>:
    1e90:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001e9a <__c.4743>:
    1e9a:	43 6f 6e 6e 65 63 74 65 64 20 20 20 20 20 20 20     Connected       
    1eaa:	20 20 20 20 00                                          .

00001eaf <__c.4738>:
    1eaf:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1ebf:	20 20 20 00                                            .

00001ec3 <__c.4736>:
    1ec3:	25 73 00                                            %s.

00001ec6 <__c.4731>:
    1ec6:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001ed0 <__c.4726>:
    1ed0:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001ee1 <__c.4724>:
    1ee1:	43 6f 6e 6e 65 63 74 00                             Connect.

00001ee9 <__c.4722>:
    1ee9:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001efa <__c.4694>:
    1efa:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1f0a:	20 20 20 00                                            .

00001f0e <__c.4692>:
    1f0e:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1f1e:	2e 2e 00                                            ...

00001f21 <__c.4653>:
    1f21:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1f31:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1f41:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1f51:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1f61:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1f71:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1f81:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1f91:	0a 00                                               ..

00001f93 <__c.4651>:
    1f93:	31 36 2f 30 35 2f 32 30 31 31 00                    16/05/2011.

00001f9e <__c.4649>:
    1f9e:	32 2e 34 31 00                                      2.41.

00001fa3 <__c.4555>:
    1fa3:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001fb4 <__c.4553>:
    1fb4:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1fc4:	69 00                                               i.

00001fc6 <__c.4549>:
    1fc6:	49 44 3a 20 25 73 00                                ID: %s.

00001fcd <__c.4547>:
    1fcd:	25 73 00                                            %s.

00001fd0 <__c.4545>:
    1fd0:	50 25 73 20 25 73 20 00                             P%s %s .

00001fd8 <__c.4541>:
    1fd8:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1fe8:	20 20 00                                              .

00001feb <__c.4538>:
    1feb:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1ffb:	61 73 69 6c 00                                      asil.

00002000 <__c.4534>:
    2000:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    2010:	6c 20 20 20 00                                      l   .

00002015 <__c.4530>:
    2015:	20 20 20 20 20 20 20 00                                    .

0000201d <__c.4527>:
    201d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    202d:	20 20 20 20 00                                          .

00002032 <__c.4525>:
    2032:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    2042:	20 20 20 20 00                                          .

00002047 <__c.4523>:
    2047:	25 73 00                                            %s.

0000204a <__c.4521>:
    204a:	50 25 73 20 25 73 20 00                             P%s %s .

00002052 <__c.4518>:
    2052:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    2062:	6f 6e 20 20 00                                      on  .

00002067 <__c.4515>:
    2067:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    2077:	23 5d 4f 4b 00                                      #]OK.

0000207c <__c.4513>:
    207c:	25 73 20 00                                         %s .

00002080 <__c.4511>:
    2080:	20 46 75 6c 6c 00                                    Full.

00002086 <__c.4509>:
    2086:	25 73 20 20 25 73 20 00                             %s  %s .

0000208e <__c.4507>:
    208e:	49 44 3a 20 25 73 00                                ID: %s.

00002095 <__c.4505>:
    2095:	25 73 20 00                                         %s .

00002099 <__c.4501>:
    2099:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    20a9:	20 00                                                .

000020ab <__c.4499>:
    20ab:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    20bb:	20 00                                                .

000020bd <__c.4497>:
    20bd:	25 73 20 00                                         %s .

000020c1 <__c.4495>:
    20c1:	20 20 25 73 20 25 73 20 00                            %s %s .

000020ca <__c.4493>:
    20ca:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    20da:	75 6e 74 00                                         unt.

000020de <__c.4491>:
    20de:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    20ee:	75 6d 65 00                                         ume.

000020f2 <__c.4489>:
    20f2:	20 20 54 61 6e 6b 00                                  Tank.

000020f9 <__c.4487>:
    20f9:	20 20 25 73 20 25 73 20 00                            %s %s .

00002102 <__c.4485>:
    2102:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    2112:	75 6c 6c 00                                         ull.

00002116 <__c.4481>:
    2116:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    2126:	20 20 20 20 00                                          .

0000212b <__c.4479>:
    212b:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    213b:	20 20 20 20 00                                          .

00002140 <__c.4477>:
    2140:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2150:	20 20 20 20 00                                          .

00002155 <__c.4475>:
    2155:	50 25 73 2d 25 73 20 00                             P%s-%s .

0000215d <__c.4473>:
    215d:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    216d:	20 20 20 20 00                                          .

00002172 <__c.4471>:
    2172:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2182:	20 20 20 20 00                                          .

00002187 <__c.4469>:
    2187:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    2197:	20 20 20 20 00                                          .

0000219c <__c.4467>:
    219c:	50 25 73 2d 25 73 20 00                             P%s-%s .

000021a4 <__c.4464>:
    21a4:	41 00                                               A.

000021a6 <__c.4462>:
    21a6:	41 00                                               A.

000021a8 <__c.4460>:
    21a8:	56 00                                               V.

000021aa <__c.4457>:
    21aa:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    21ba:	78 74 20 20 00                                      xt  .

000021bf <__c.4455>:
    21bf:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    21cf:	20 20 20 20 00                                          .

000021d4 <__c.4453>:
    21d4:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    21e4:	20 20 20 20 00                                          .

000021e9 <__c.4451>:
    21e9:	50 25 73 2d 25 73 20 00                             P%s-%s .

000021f1 <__c.4448>:
    21f1:	25 73 00                                            %s.

000021f4 <__c.4445>:
    21f4:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    2204:	20 20 20 20 00                                          .

00002209 <__c.4440>:
    2209:	20 20 20 20 20 00                                        .

0000220f <__c.4438>:
    220f:	25 64 2e 25 73 00                                   %d.%s.

00002215 <__c.4436>:
    2215:	25 73 00                                            %s.

00002218 <__c.4434>:
    2218:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00002221 <__c.4430>:
    2221:	25 2e 32 64 00                                      %.2d.

00002226 <__c.4428>:
    2226:	25 2e 32 64 00                                      %.2d.

0000222b <__c.4424>:
    222b:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    223b:	23 5d 4f 4b 00                                      #]OK.

00002240 <__c.4422>:
    2240:	25 73 20 25 73 00                                   %s %s.

00002246 <__c.4420>:
    2246:	25 73 00                                            %s.

00002249 <__c.4418>:
    2249:	25 73 00                                            %s.

0000224c <__c.4416>:
    224c:	25 73 00                                            %s.

0000224f <__c.4413>:
    224f:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    225f:	20 20 20 20 00                                          .

00002264 <__c.4411>:
    2264:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    2274:	20 20 20 20 00                                          .

00002279 <__c.4408>:
    2279:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    2289:	20 20 20 20 00                                          .

0000228e <__c.4405>:
    228e:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    229e:	20 20 20 20 00                                          .

000022a3 <__c.4403>:
    22a3:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    22b3:	20 20 20 20 00                                          .

000022b8 <__c.4400>:
    22b8:	20 20 20 20 20 20 20 00                                    .

000022c0 <__c.4395>:
    22c0:	50 72 6f 73 65 73 00                                Proses.

000022c7 <__c.4393>:
    22c7:	49 44 3a 25 73 00                                   ID:%s.

000022cd <__c.4391>:
    22cd:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    22dd:	20 20 20 00                                            .

000022e1 <__c.4227>:
    22e1:	25 2e 32 64 00                                      %.2d.

000022e6 <__c.4179>:
    22e6:	46 39 36 38 43 46 46 42 00                          F968CFFB.

000022ef <__c.4177>:
    22ef:	25 73 00                                            %s.

000022f2 <__c.4174>:
    22f2:	25 73 25 73 25 73 00                                %s%s%s.

000022f9 <__c.4172>:
    22f9:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00002302 <__c.4169>:
    2302:	25 73 25 73 00                                      %s%s.

00002307 <__c.4166>:
    2307:	25 73 00                                            %s.

0000230a <__c.4164>:
    230a:	46 30 30 30 30 30 30 30 45 31 32 33 34 35 36 46     F0000000E123456F
    231a:	46 46 46 46 00                                      FFFF.

0000231f <__c.4162>:
    231f:	25 73 25 73 25 64 00                                %s%s%d.

00002326 <__c.4160>:
    2326:	25 73 25 73 25 64 00                                %s%s%d.

0000232d <__c.4157>:
    232d:	25 73 00                                            %s.

00002330 <__c.4154>:
    2330:	25 73 25 73 00                                      %s%s.

00002335 <__c.4152>:
    2335:	25 73 25 73 00                                      %s%s.

0000233a <__c.4150>:
    233a:	25 73 25 73 00                                      %s%s.

0000233f <__c.4147>:
    233f:	25 73 25 73 00                                      %s%s.

00002344 <__c.4144>:
    2344:	25 73 25 73 00                                      %s%s.

00002349 <__c.4141>:
    2349:	25 73 00                                            %s.

0000234c <__c.4136>:
    234c:	25 73 31 00                                         %s1.

00002350 <__c.4133>:
    2350:	25 2e 32 58 00                                      %.2X.

00002355 <__c.4131>:
    2355:	25 2e 33 64 2e 25 2e 33 64 2e 25 2e 33 64 2e 25     %.3d.%.3d.%.3d.%
    2365:	2e 33 64 00                                         .3d.

00002369 <__c.4129>:
    2369:	25 2e 33 64 2e 25 2e 33 64 2e 25 2e 33 64 2e 25     %.3d.%.3d.%.3d.%
    2379:	2e 33 64 00                                         .3d.

0000237d <__c.4127>:
    237d:	25 2e 32 64 00                                      %.2d.

00002382 <__c.4125>:
    2382:	25 2e 32 64 00                                      %.2d.

00002387 <__c.4037>:
    2387:	25 73 20 25 73 00                                   %s %s.

0000238d <__c.4035>:
    238d:	32 2e 34 31 00                                      2.41.

00002392 <__c.4033>:
    2392:	47 65 4e 69 55 73 00                                GeNiUs.

00002399 <__c.4019>:
    2399:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    23a9:	20 20 20 20 00                                          .

000023ae <__c.4007>:
    23ae:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    23be:	64 61 6c 6f 6e 65 00                                dalone.

000023c5 <__c.3927>:
    23c5:	3e 00                                               >.

000023c7 <__c.3922>:
    23c7:	25 2e 32 64 00                                      %.2d.

000023cc <__c.3920>:
    23cc:	25 2e 32 64 00                                      %.2d.

000023d1 <__c.3918>:
    23d1:	30 00                                               0.

000023d3 <__c.3916>:
    23d3:	31 00                                               1.

000023d5 <__c.3908>:
    23d5:	25 64 00                                            %d.

000023d8 <__c.3903>:
    23d8:	25 2e 32 64 00                                      %.2d.

000023dd <__c.3898>:
    23dd:	25 73 00                                            %s.

000023e0 <__c.3893>:
    23e0:	25 73 00                                            %s.

000023e3 <__c.3888>:
    23e3:	25 73 00                                            %s.

000023e6 <__c.3886>:
    23e6:	3c 00                                               <.

000023e8 <__c.3818>:
    23e8:	3c 4f 4b 3e 00                                      <OK>.

000023ed <__c.3813>:
    23ed:	25 64 00                                            %d.

000023f0 <__c.3811>:
    23f0:	25 64 00                                            %d.

000023f3 <__c.3800>:
    23f3:	25 64 00                                            %d.

000023f6 <__c.3789>:
    23f6:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

000023ff <__c.3787>:
    23ff:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

00002409 <__c.3603>:
    2409:	25 73 00                                            %s.

0000240c <__c.3545>:
    240c:	25 73 00                                            %s.

0000240f <__c.3543>:
    240f:	25 73 00                                            %s.

00002412 <__c.3541>:
    2412:	25 73 00                                            %s.

00002415 <__c.3539>:
    2415:	25 73 00                                            %s.

00002418 <__c.3537>:
    2418:	25 2e 32 64 00                                      %.2d.

0000241d <__c.3535>:
    241d:	25 64 00                                            %d.

00002420 <__c.3533>:
    2420:	25 73 00                                            %s.

00002423 <__c.3531>:
    2423:	25 73 00                                            %s.

00002426 <__c.3529>:
    2426:	25 73 00                                            %s.

00002429 <__c.3527>:
    2429:	25 64 00                                            %d.

0000242c <__c.3525>:
    242c:	4e 2f 41 00                                         N/A.

00002430 <__c.3426>:
    2430:	25 64 00                                            %d.

00002433 <__c.3424>:
    2433:	25 73 00                                            %s.

00002436 <__c.3422>:
    2436:	25 73 00                                            %s.

00002439 <__c.3339>:
    2439:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    2449:	6b 73 69 20 00                                      ksi .

0000244e <__c.3336>:
    244e:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    245e:	20 00                                                .

00002460 <__c.3333>:
    2460:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    2470:	69 7a 65 72 00                                      izer.

00002475 <__c.3321>:
    2475:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00002486 <__c.3318>:
    2486:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2496:	20 20 20 20 00                                          .

0000249b <__c.3315>:
    249b:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    24ab:	20 20 20 20 00                                          .

000024b0 <__c.3313>:
    24b0:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    24c0:	20 20 20 20 00                                          .

000024c5 <__c.3310>:
    24c5:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    24d5:	20 20 20 20 00                                          .

000024da <__c.3307>:
    24da:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    24ea:	20 20 20 20 00                                          .

000024ef <__c.3304>:
    24ef:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    24ff:	6b 73 69 20 00                                      ksi .

00002504 <__c.3299>:
    2504:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

00002511 <__c.3296>:
    2511:	34 33 35 36 41 33 31 41 00                          4356A31A.

0000251a <__c.1750>:
    251a:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    252a:	20 20 20 20 00                                          .

0000252f <__c.1748>:
    252f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    253f:	20 20 20 20 00                                          .

00002544 <__c.1746>:
    2544:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2554:	20 20 20 20 00                                          .

00002559 <__c.1744>:
    2559:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2569:	20 20 20 20 00                                          .

0000256e <__alphanum>:
    256e:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    257e:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    258e:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    259e:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    25ae:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    25be:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    25ce:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    25de:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

000025e6 <__maxchar>:
    25e6:	02 04 03 03 03 03 03 04 03 04                       ..........

000025f0 <__ctors_end>:
    25f0:	11 24       	eor	r1, r1
    25f2:	1f be       	out	0x3f, r1	; 63
    25f4:	cf ef       	ldi	r28, 0xFF	; 255
    25f6:	d0 e1       	ldi	r29, 0x10	; 16
    25f8:	de bf       	out	0x3e, r29	; 62
    25fa:	cd bf       	out	0x3d, r28	; 61

000025fc <__do_copy_data>:
    25fc:	11 e0       	ldi	r17, 0x01	; 1
    25fe:	a0 e0       	ldi	r26, 0x00	; 0
    2600:	b1 e0       	ldi	r27, 0x01	; 1
    2602:	e0 e4       	ldi	r30, 0x40	; 64
    2604:	f6 e6       	ldi	r31, 0x66	; 102
    2606:	01 e0       	ldi	r16, 0x01	; 1
    2608:	0b bf       	out	0x3b, r16	; 59
    260a:	02 c0       	rjmp	.+4      	; 0x2610 <__do_copy_data+0x14>
    260c:	07 90       	elpm	r0, Z+
    260e:	0d 92       	st	X+, r0
    2610:	ac 35       	cpi	r26, 0x5C	; 92
    2612:	b1 07       	cpc	r27, r17
    2614:	d9 f7       	brne	.-10     	; 0x260c <__do_copy_data+0x10>

00002616 <__do_clear_bss>:
    2616:	1c e0       	ldi	r17, 0x0C	; 12
    2618:	ac e5       	ldi	r26, 0x5C	; 92
    261a:	b1 e0       	ldi	r27, 0x01	; 1
    261c:	01 c0       	rjmp	.+2      	; 0x2620 <.do_clear_bss_start>

0000261e <.do_clear_bss_loop>:
    261e:	1d 92       	st	X+, r1

00002620 <.do_clear_bss_start>:
    2620:	a3 3b       	cpi	r26, 0xB3	; 179
    2622:	b1 07       	cpc	r27, r17
    2624:	e1 f7       	brne	.-8      	; 0x261e <.do_clear_bss_loop>
    2626:	0e 94 cd 13 	call	0x279a	; 0x279a <main>
    262a:	0c 94 1e b3 	jmp	0x1663c	; 0x1663c <_exit>

0000262e <__bad_interrupt>:
    262e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00002632 <systemOnReset>:


void systemOnReset(){
     char SubMenu,KeyPressed,KeyChar,IsMasterReset=False;

     IsPowerOn=False;
    2632:	10 92 ba 02 	sts	0x02BA, r1
     if (MCUCSR & 1){   // Power-on Reset
    2636:	04 b6       	in	r0, 0x34	; 52
    2638:	00 fe       	sbrs	r0, 0
    263a:	30 c0       	rjmp	.+96     	; 0x269c <systemOnReset+0x6a>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));//Wiznet Blm Ready
    263c:	14 be       	out	0x34, r1	; 52
    263e:	81 e0       	ldi	r24, 0x01	; 1
    2640:	61 e0       	ldi	r22, 0x01	; 1
    2642:	46 ea       	ldi	r20, 0xA6	; 166
    2644:	52 e0       	ldi	r21, 0x02	; 2
    2646:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		 IsPowerOn=True;
    264a:	81 e0       	ldi	r24, 0x01	; 1
    264c:	80 93 ba 02 	sts	0x02BA, r24
         //Master Reset Detection
		 PORTF = 0xFF; DDRF = 0xF0;
    2650:	8f ef       	ldi	r24, 0xFF	; 255
    2652:	80 93 62 00 	sts	0x0062, r24
    2656:	80 ef       	ldi	r24, 0xF0	; 240
    2658:	80 93 61 00 	sts	0x0061, r24
		 KeyPressed=_key_scan(1);
    265c:	81 e0       	ldi	r24, 0x01	; 1
    265e:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		 KeyChar= _key_btn(KeyPressed);
    2662:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		 if (KeyChar=='5'){
    2666:	85 33       	cpi	r24, 0x35	; 53
    2668:	89 f5       	brne	.+98     	; 0x26cc <systemOnReset+0x9a>
		     system_beep(2);
    266a:	82 e0       	ldi	r24, 0x02	; 2
    266c:	90 e0       	ldi	r25, 0x00	; 0
    266e:	0e 94 14 16 	call	0x2c28	; 0x2c28 <system_beep>
		     IsMasterReset=True;
			 TCCR1B |= (1 << WGM12);
    2672:	8e b5       	in	r24, 0x2e	; 46
    2674:	88 60       	ori	r24, 0x08	; 8
    2676:	8e bd       	out	0x2e, r24	; 46
			 TIMSK |= (1 << OCIE1A);
    2678:	87 b7       	in	r24, 0x37	; 55
    267a:	80 61       	ori	r24, 0x10	; 16
    267c:	87 bf       	out	0x37, r24	; 55
			 sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    267e:	78 94       	sei
			 OCR1A   = 15624;//49911 -->0,33847384982639 ms
    2680:	88 e0       	ldi	r24, 0x08	; 8
    2682:	9d e3       	ldi	r25, 0x3D	; 61
    2684:	9b bd       	out	0x2b, r25	; 43
    2686:	8a bd       	out	0x2a, r24	; 42
			 TCCR1B |= ((1 << CS10) | (1 << CS11));
    2688:	8e b5       	in	r24, 0x2e	; 46
    268a:	83 60       	ori	r24, 0x03	; 3
    268c:	8e bd       	out	0x2e, r24	; 46
		     while(IsMasterReset==True){
			       SubMenu=FMenuMaster();
    268e:	0e 94 0a 77 	call	0xee14	; 0xee14 <FMenuMaster>
				   if (SubMenu==MENU_DONE){
    2692:	81 30       	cpi	r24, 0x01	; 1
    2694:	e1 f7       	brne	.-8      	; 0x268e <systemOnReset+0x5c>
				       IsMasterReset=False;
					   lcd_clear();
    2696:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    269a:	18 c0       	rjmp	.+48     	; 0x26cc <systemOnReset+0x9a>
				   }
			 }		 
		 }
         }
     else 
     if (MCUCSR & 2){   // External Reset
    269c:	04 b6       	in	r0, 0x34	; 52
    269e:	01 fe       	sbrs	r0, 1
    26a0:	06 c0       	rjmp	.+12     	; 0x26ae <systemOnReset+0x7c>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    26a2:	14 be       	out	0x34, r1	; 52
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	61 e0       	ldi	r22, 0x01	; 1
    26a8:	4d e9       	ldi	r20, 0x9D	; 157
    26aa:	52 e0       	ldi	r21, 0x02	; 2
    26ac:	0d c0       	rjmp	.+26     	; 0x26c8 <systemOnReset+0x96>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    26ae:	04 b6       	in	r0, 0x34	; 52
    26b0:	02 fe       	sbrs	r0, 2
    26b2:	06 c0       	rjmp	.+12     	; 0x26c0 <systemOnReset+0x8e>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    26b4:	14 be       	out	0x34, r1	; 52
    26b6:	81 e0       	ldi	r24, 0x01	; 1
    26b8:	61 e0       	ldi	r22, 0x01	; 1
    26ba:	44 e9       	ldi	r20, 0x94	; 148
    26bc:	52 e0       	ldi	r21, 0x02	; 2
    26be:	04 c0       	rjmp	.+8      	; 0x26c8 <systemOnReset+0x96>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    26c0:	81 e0       	ldi	r24, 0x01	; 1
    26c2:	61 e0       	ldi	r22, 0x01	; 1
    26c4:	4b e8       	ldi	r20, 0x8B	; 139
    26c6:	52 e0       	ldi	r21, 0x02	; 2
    26c8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
        };
     MCUCSR=0;		  
    26cc:	14 be       	out	0x34, r1	; 52
    26ce:	80 ee       	ldi	r24, 0xE0	; 224
    26d0:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    26d2:	20 e7       	ldi	r18, 0x70	; 112
    26d4:	31 e0       	ldi	r19, 0x01	; 1
    26d6:	f9 01       	movw	r30, r18
    26d8:	31 97       	sbiw	r30, 0x01	; 1
    26da:	f1 f7       	brne	.-4      	; 0x26d8 <systemOnReset+0xa6>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26dc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26de:	d9 f7       	brne	.-10     	; 0x26d6 <systemOnReset+0xa4>
	 _delay_ms(1200);
}
    26e0:	08 95       	ret

000026e2 <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    26e2:	0e 94 fa a8 	call	0x151f4	; 0x151f4 <lcd_init>
	lcd_clear();
    26e6:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	BackLightTrig();
    26ea:	0e 94 c9 16 	call	0x2d92	; 0x2d92 <BackLightTrig>
	systemOnReset();
    26ee:	0e 94 19 13 	call	0x2632	; 0x2632 <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    26f2:	84 e0       	ldi	r24, 0x04	; 4
    26f4:	61 e0       	ldi	r22, 0x01	; 1
    26f6:	4c e7       	ldi	r20, 0x7C	; 124
    26f8:	52 e0       	ldi	r21, 0x02	; 2
    26fa:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    26fe:	88 eb       	ldi	r24, 0xB8	; 184
    2700:	9b e0       	ldi	r25, 0x0B	; 11
    2702:	20 e7       	ldi	r18, 0x70	; 112
    2704:	31 e0       	ldi	r19, 0x01	; 1
    2706:	f9 01       	movw	r30, r18
    2708:	31 97       	sbiw	r30, 0x01	; 1
    270a:	f1 f7       	brne	.-4      	; 0x2708 <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    270c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    270e:	d9 f7       	brne	.-10     	; 0x2706 <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    2710:	9f ef       	ldi	r25, 0xFF	; 255
    2712:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    2714:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    2716:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    2718:	98 bb       	out	0x18, r25	; 24
    271a:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    271c:	8d e0       	ldi	r24, 0x0D	; 13
    271e:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    2720:	89 e0       	ldi	r24, 0x09	; 9
    2722:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    2724:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    2728:	8e e0       	ldi	r24, 0x0E	; 14
    272a:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    272c:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    272e:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    2730:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    2732:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    2736:	80 ef       	ldi	r24, 0xF0	; 240
    2738:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    273c:	80 e0       	ldi	r24, 0x00	; 0
    273e:	61 e0       	ldi	r22, 0x01	; 1
    2740:	0e 94 f2 ab 	call	0x157e4	; 0x157e4 <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    2744:	bb 9a       	sbi	0x17, 3	; 23
    2746:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    2748:	ba 98       	cbi	0x17, 2	; 23
    274a:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    274c:	b9 98       	cbi	0x17, 1	; 23
    274e:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    2750:	8e b5       	in	r24, 0x2e	; 46
    2752:	88 60       	ori	r24, 0x08	; 8
    2754:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    2756:	87 b7       	in	r24, 0x37	; 55
    2758:	80 61       	ori	r24, 0x10	; 16
    275a:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    275c:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    275e:	88 e0       	ldi	r24, 0x08	; 8
    2760:	9d e3       	ldi	r25, 0x3D	; 61
    2762:	9b bd       	out	0x2b, r25	; 43
    2764:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    2766:	8e b5       	in	r24, 0x2e	; 46
    2768:	83 60       	ori	r24, 0x03	; 3
    276a:	8e bd       	out	0x2e, r24	; 46

	SendSlaveCommand(SC_SLAVE,ST_NONE);
    276c:	81 e0       	ldi	r24, 0x01	; 1
    276e:	60 e0       	ldi	r22, 0x00	; 0
    2770:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
	
	InitComport();
    2774:	0e 94 70 7d 	call	0xfae0	; 0xfae0 <InitComport>
	_LIGHT_SET;
    2778:	81 e0       	ldi	r24, 0x01	; 1
    277a:	80 93 ae 02 	sts	0x02AE, r24
    277e:	10 92 af 02 	sts	0x02AF, r1
    2782:	80 91 65 00 	lds	r24, 0x0065
    2786:	8d 7f       	andi	r24, 0xFD	; 253
    2788:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    278c:	0e 94 ad 47 	call	0x8f5a	; 0x8f5a <InitPrinter>
    InitializeConnection();
    2790:	0e 94 3f 95 	call	0x12a7e	; 0x12a7e <InitializeConnection>
	lcd_clear();
    2794:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
}
    2798:	08 95       	ret

0000279a <main>:

//Master4 =1+20++2+1
void SystemInit();
//Program Utama
int main(){
	SystemInit();
    279a:	0e 94 71 13 	call	0x26e2	; 0x26e2 <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    279e:	0e 94 be a6 	call	0x14d7c	; 0x14d7c <FMenuIdle>
    27a2:	fd cf       	rjmp	.-6      	; 0x279e <main+0x4>

000027a4 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    27a4:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    27a6:	e1 99       	sbic	0x1c, 1	; 28
    27a8:	fe cf       	rjmp	.-4      	; 0x27a6 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    27aa:	3f bb       	out	0x1f, r19	; 31
    27ac:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    27ae:	e0 9a       	sbi	0x1c, 0	; 28
    27b0:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    27b2:	08 95       	ret

000027b4 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    27b4:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    27b6:	e1 99       	sbic	0x1c, 1	; 28
    27b8:	fe cf       	rjmp	.-4      	; 0x27b6 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    27ba:	3f bb       	out	0x1f, r19	; 31
    27bc:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    27be:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    27c0:	0f b6       	in	r0, 0x3f	; 63
    27c2:	f8 94       	cli
    27c4:	e2 9a       	sbi	0x1c, 2	; 28
    27c6:	e1 9a       	sbi	0x1c, 1	; 28
    27c8:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    27ca:	08 95       	ret

000027cc <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
    27cc:	1f 92       	push	r1
    27ce:	0f 92       	push	r0
    27d0:	0f b6       	in	r0, 0x3f	; 63
    27d2:	0f 92       	push	r0
    27d4:	11 24       	eor	r1, r1
    27d6:	2f 93       	push	r18
    27d8:	6f 93       	push	r22
    27da:	7f 93       	push	r23
    27dc:	8f 93       	push	r24
    27de:	9f 93       	push	r25
	if(__key_light == 1){
    27e0:	80 91 ae 02 	lds	r24, 0x02AE
    27e4:	81 30       	cpi	r24, 0x01	; 1
    27e6:	81 f4       	brne	.+32     	; 0x2808 <__vector_12+0x3c>
		__key_lgtcnt++;
    27e8:	80 91 af 02 	lds	r24, 0x02AF
    27ec:	8f 5f       	subi	r24, 0xFF	; 255
    27ee:	80 93 af 02 	sts	0x02AF, r24
		if(__key_lgtcnt == 150){
    27f2:	86 39       	cpi	r24, 0x96	; 150
    27f4:	49 f4       	brne	.+18     	; 0x2808 <__vector_12+0x3c>
		   __key_light = 0; 
    27f6:	10 92 ae 02 	sts	0x02AE, r1
		   __key_lgtcnt = 0; 
    27fa:	10 92 af 02 	sts	0x02AF, r1
		   sbi(PORTG, 1);
    27fe:	80 91 65 00 	lds	r24, 0x0065
    2802:	82 60       	ori	r24, 0x02	; 2
    2804:	80 93 65 00 	sts	0x0065, r24
		   }
	}

	//Beep
	if (TimBeep>0){
    2808:	80 91 bc 01 	lds	r24, 0x01BC
    280c:	88 23       	and	r24, r24
    280e:	31 f0       	breq	.+12     	; 0x281c <__vector_12+0x50>
	    TimBeep--;
    2810:	81 50       	subi	r24, 0x01	; 1
    2812:	80 93 bc 01 	sts	0x01BC, r24
		DDRB=(DDRB|0b00100000);
    2816:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
    2818:	c5 98       	cbi	0x18, 5	; 24
    281a:	05 c0       	rjmp	.+10     	; 0x2826 <__vector_12+0x5a>
	    }
	else{PORTB=(PORTB|~PORTB);
    281c:	98 b3       	in	r25, 0x18	; 24
    281e:	88 b3       	in	r24, 0x18	; 24
    2820:	80 95       	com	r24
    2822:	89 2b       	or	r24, r25
    2824:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
    2826:	80 91 ba 01 	lds	r24, 0x01BA
    282a:	8f 5f       	subi	r24, 0xFF	; 255
    282c:	80 93 ba 01 	sts	0x01BA, r24
	//DisplaTicker
    TimTicker++;
    2830:	80 91 90 01 	lds	r24, 0x0190
    2834:	8f 5f       	subi	r24, 0xFF	; 255
    2836:	80 93 90 01 	sts	0x0190, r24
	TimPressed++;
    283a:	20 91 91 01 	lds	r18, 0x0191
    283e:	2f 5f       	subi	r18, 0xFF	; 255
    2840:	20 93 91 01 	sts	0x0191, r18
	if ((TimPressed%5)==0){
    2844:	82 2f       	mov	r24, r18
    2846:	65 e0       	ldi	r22, 0x05	; 5
    2848:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    284c:	99 23       	and	r25, r25
    284e:	71 f4       	brne	.+28     	; 0x286c <__vector_12+0xa0>
	    PORTE = PORTE^0x04;
    2850:	83 b1       	in	r24, 0x03	; 3
    2852:	94 e0       	ldi	r25, 0x04	; 4
    2854:	89 27       	eor	r24, r25
    2856:	83 b9       	out	0x03, r24	; 3
	    TimDisplay++;
    2858:	80 91 92 01 	lds	r24, 0x0192
    285c:	8f 5f       	subi	r24, 0xFF	; 255
    285e:	80 93 92 01 	sts	0x0192, r24
		TimPrintBusy++;
    2862:	80 91 b6 01 	lds	r24, 0x01B6
    2866:	8f 5f       	subi	r24, 0xFF	; 255
    2868:	80 93 b6 01 	sts	0x01B6, r24
	}
	if ((TimPressed%PRESSED_DELAY)==0){
    286c:	82 2f       	mov	r24, r18
    286e:	6a e0       	ldi	r22, 0x0A	; 10
    2870:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    2874:	99 23       	and	r25, r25
    2876:	29 f4       	brne	.+10     	; 0x2882 <__vector_12+0xb6>
	     ProcTimeOut++;
    2878:	80 91 bb 01 	lds	r24, 0x01BB
    287c:	8f 5f       	subi	r24, 0xFF	; 255
    287e:	80 93 bb 01 	sts	0x01BB, r24
	}
	TimSend++;
    2882:	80 91 78 0c 	lds	r24, 0x0C78
    2886:	8f 5f       	subi	r24, 0xFF	; 255
    2888:	80 93 78 0c 	sts	0x0C78, r24
}
    288c:	9f 91       	pop	r25
    288e:	8f 91       	pop	r24
    2890:	7f 91       	pop	r23
    2892:	6f 91       	pop	r22
    2894:	2f 91       	pop	r18
    2896:	0f 90       	pop	r0
    2898:	0f be       	out	0x3f, r0	; 63
    289a:	0f 90       	pop	r0
    289c:	1f 90       	pop	r1
    289e:	18 95       	reti

000028a0 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    28a0:	86 e1       	ldi	r24, 0x16	; 22
    28a2:	08 95       	ret

000028a4 <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    28a4:	e8 2f       	mov	r30, r24
    28a6:	f0 e0       	ldi	r31, 0x00	; 0
    28a8:	ee 31       	cpi	r30, 0x1E	; 30
    28aa:	f1 05       	cpc	r31, r1
    28ac:	70 f5       	brcc	.+92     	; 0x290a <GetPumpStatusLabel+0x66>
    28ae:	ea 5b       	subi	r30, 0xBA	; 186
    28b0:	ff 4f       	sbci	r31, 0xFF	; 255
    28b2:	ee 0f       	add	r30, r30
    28b4:	ff 1f       	adc	r31, r31
    28b6:	05 90       	lpm	r0, Z+
    28b8:	f4 91       	lpm	r31, Z+
    28ba:	e0 2d       	mov	r30, r0
    28bc:	09 94       	ijmp
    28be:	81 e3       	ldi	r24, 0x31	; 49
    28c0:	08 95       	ret
    28c2:	85 e4       	ldi	r24, 0x45	; 69
    28c4:	08 95       	ret
    28c6:	82 e3       	ldi	r24, 0x32	; 50
    28c8:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    28ca:	83 e3       	ldi	r24, 0x33	; 51
    28cc:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    28ce:	84 e3       	ldi	r24, 0x34	; 52
    28d0:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    28d2:	85 e3       	ldi	r24, 0x35	; 53
    28d4:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    28d6:	89 e6       	ldi	r24, 0x69	; 105
    28d8:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    28da:	8e e6       	ldi	r24, 0x6E	; 110
    28dc:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    28de:	81 e6       	ldi	r24, 0x61	; 97
    28e0:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    28e2:	84 e6       	ldi	r24, 0x64	; 100
    28e4:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    28e6:	8f e4       	ldi	r24, 0x4F	; 79
    28e8:	08 95       	ret
	 case PUMP_PEOT: 
	 	  Result='O';
		  break;
    28ea:	86 e4       	ldi	r24, 0x46	; 70
    28ec:	08 95       	ret
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    28ee:	83 e5       	ldi	r24, 0x53	; 83
    28f0:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    28f2:	8d e2       	ldi	r24, 0x2D	; 45
    28f4:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    28f6:	80 e5       	ldi	r24, 0x50	; 80
    28f8:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
    28fa:	89 e4       	ldi	r24, 0x49	; 73
    28fc:	08 95       	ret
     case PS_PRINTED:
	      Result='I';
 	      break;
    28fe:	86 e5       	ldi	r24, 0x56	; 86
    2900:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    2902:	84 e5       	ldi	r24, 0x54	; 84
    2904:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    2906:	84 e7       	ldi	r24, 0x74	; 116
    2908:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    290a:	88 e7       	ldi	r24, 0x78	; 120
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    290c:	08 95       	ret

0000290e <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    290e:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    2912:	60 93 d3 0b 	sts	0x0BD3, r22
     IsControlPooling=True;
    2916:	81 e0       	ldi	r24, 0x01	; 1
    2918:	80 93 84 01 	sts	0x0184, r24
}
    291c:	08 95       	ret

0000291e <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    291e:	28 2f       	mov	r18, r24


	 //uart(0,1,data);

     //EDC-MSG
     if (data==0x02){
    2920:	82 30       	cpi	r24, 0x02	; 2
    2922:	39 f4       	brne	.+14     	; 0x2932 <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	80 93 a3 02 	sts	0x02A3, r24
		 nFlow=0;
    292a:	10 92 a2 02 	sts	0x02A2, r1
    292e:	10 92 a1 02 	sts	0x02A1, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    2932:	80 91 a3 02 	lds	r24, 0x02A3
    2936:	81 30       	cpi	r24, 0x01	; 1
    2938:	69 f4       	brne	.+26     	; 0x2954 <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    293a:	80 91 a1 02 	lds	r24, 0x02A1
    293e:	90 91 a2 02 	lds	r25, 0x02A2
    2942:	fc 01       	movw	r30, r24
    2944:	e3 5e       	subi	r30, 0xE3	; 227
    2946:	f6 4f       	sbci	r31, 0xF6	; 246
    2948:	20 83       	st	Z, r18
		 nFlow++;
    294a:	01 96       	adiw	r24, 0x01	; 1
    294c:	90 93 a2 02 	sts	0x02A2, r25
    2950:	80 93 a1 02 	sts	0x02A1, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    2954:	23 30       	cpi	r18, 0x03	; 3
    2956:	41 f0       	breq	.+16     	; 0x2968 <ScanEDCFlow+0x4a>
    2958:	80 91 a1 02 	lds	r24, 0x02A1
    295c:	90 91 a2 02 	lds	r25, 0x02A2
    2960:	8d 34       	cpi	r24, 0x4D	; 77
    2962:	91 05       	cpc	r25, r1
    2964:	08 f4       	brcc	.+2      	; 0x2968 <ScanEDCFlow+0x4a>
    2966:	99 c0       	rjmp	.+306    	; 0x2a9a <ScanEDCFlow+0x17c>
	     //for(i=0;i<nFlow;i++){uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    2968:	10 92 a3 02 	sts	0x02A3, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    296c:	30 91 1f 09 	lds	r19, 0x091F
    2970:	30 51       	subi	r19, 0x10	; 16
    2972:	80 91 1e 09 	lds	r24, 0x091E
    2976:	2a e0       	ldi	r18, 0x0A	; 10
    2978:	82 9f       	mul	r24, r18
    297a:	c0 01       	movw	r24, r0
    297c:	11 24       	eor	r1, r1
    297e:	38 0f       	add	r19, r24

		 if (EDCMsgCode==0x03){
    2980:	33 30       	cpi	r19, 0x03	; 3
    2982:	09 f0       	breq	.+2      	; 0x2986 <ScanEDCFlow+0x68>
    2984:	65 c0       	rjmp	.+202    	; 0x2a50 <ScanEDCFlow+0x132>
    2986:	e0 e2       	ldi	r30, 0x20	; 32
    2988:	f9 e0       	ldi	r31, 0x09	; 9
    298a:	a7 e8       	ldi	r26, 0x87	; 135
    298c:	bc e0       	ldi	r27, 0x0C	; 12
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    298e:	81 91       	ld	r24, Z+
    2990:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2992:	89 e0       	ldi	r24, 0x09	; 9
    2994:	e6 32       	cpi	r30, 0x26	; 38
    2996:	f8 07       	cpc	r31, r24
    2998:	d1 f7       	brne	.-12     	; 0x298e <ScanEDCFlow+0x70>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    299a:	10 92 8d 0c 	sts	0x0C8D, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    299e:	80 81       	ld	r24, Z
    29a0:	80 93 b9 07 	sts	0x07B9, r24
    29a4:	81 81       	ldd	r24, Z+1	; 0x01
    29a6:	80 93 ba 07 	sts	0x07BA, r24
	 }Dest[Length]=0;
    29aa:	10 92 bb 07 	sts	0x07BB, r1
    29ae:	32 96       	adiw	r30, 0x02	; 2
    29b0:	a3 ea       	ldi	r26, 0xA3	; 163
    29b2:	bc e0       	ldi	r27, 0x0C	; 12
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    29b4:	81 91       	ld	r24, Z+
    29b6:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    29b8:	89 e0       	ldi	r24, 0x09	; 9
    29ba:	e7 33       	cpi	r30, 0x37	; 55
    29bc:	f8 07       	cpc	r31, r24
    29be:	d1 f7       	brne	.-12     	; 0x29b4 <ScanEDCFlow+0x96>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    29c0:	10 92 b2 0c 	sts	0x0CB2, r1
    29c4:	a9 e8       	ldi	r26, 0x89	; 137
    29c6:	bb e0       	ldi	r27, 0x0B	; 11
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    29c8:	81 91       	ld	r24, Z+
    29ca:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    29cc:	89 e0       	ldi	r24, 0x09	; 9
    29ce:	ea 34       	cpi	r30, 0x4A	; 74
    29d0:	f8 07       	cpc	r31, r24
    29d2:	d1 f7       	brne	.-12     	; 0x29c8 <ScanEDCFlow+0xaa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    29d4:	10 92 9c 0b 	sts	0x0B9C, r1
    29d8:	20 e0       	ldi	r18, 0x00	; 0
    29da:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    29dc:	f9 01       	movw	r30, r18
    29de:	e0 51       	subi	r30, 0x10	; 16
    29e0:	f8 4f       	sbci	r31, 0xF8	; 248
    29e2:	d9 01       	movw	r26, r18
    29e4:	a3 5e       	subi	r26, 0xE3	; 227
    29e6:	b6 4f       	sbci	r27, 0xF6	; 246
    29e8:	9d 96       	adiw	r26, 0x2d	; 45
    29ea:	8c 91       	ld	r24, X
    29ec:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    29ee:	2f 5f       	subi	r18, 0xFF	; 255
    29f0:	3f 4f       	sbci	r19, 0xFF	; 255
    29f2:	26 30       	cpi	r18, 0x06	; 6
    29f4:	31 05       	cpc	r19, r1
    29f6:	91 f7       	brne	.-28     	; 0x29dc <ScanEDCFlow+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    29f8:	10 92 f6 07 	sts	0x07F6, r1
    29fc:	20 e0       	ldi	r18, 0x00	; 0
    29fe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2a00:	f9 01       	movw	r30, r18
    2a02:	ed 5a       	subi	r30, 0xAD	; 173
    2a04:	f8 4f       	sbci	r31, 0xF8	; 248
    2a06:	d9 01       	movw	r26, r18
    2a08:	a3 5e       	subi	r26, 0xE3	; 227
    2a0a:	b6 4f       	sbci	r27, 0xF6	; 246
    2a0c:	d3 96       	adiw	r26, 0x33	; 51
    2a0e:	8c 91       	ld	r24, X
    2a10:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2a12:	2f 5f       	subi	r18, 0xFF	; 255
    2a14:	3f 4f       	sbci	r19, 0xFF	; 255
    2a16:	2a 30       	cpi	r18, 0x0A	; 10
    2a18:	31 05       	cpc	r19, r1
    2a1a:	91 f7       	brne	.-28     	; 0x2a00 <ScanEDCFlow+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2a1c:	10 92 5d 07 	sts	0x075D, r1
    2a20:	20 e0       	ldi	r18, 0x00	; 0
    2a22:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2a24:	f9 01       	movw	r30, r18
    2a26:	e1 54       	subi	r30, 0x41	; 65
    2a28:	f4 4f       	sbci	r31, 0xF4	; 244
    2a2a:	d9 01       	movw	r26, r18
    2a2c:	a3 5e       	subi	r26, 0xE3	; 227
    2a2e:	b6 4f       	sbci	r27, 0xF6	; 246
    2a30:	dd 96       	adiw	r26, 0x3d	; 61
    2a32:	8c 91       	ld	r24, X
    2a34:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2a36:	2f 5f       	subi	r18, 0xFF	; 255
    2a38:	3f 4f       	sbci	r19, 0xFF	; 255
    2a3a:	2e 30       	cpi	r18, 0x0E	; 14
    2a3c:	31 05       	cpc	r19, r1
    2a3e:	91 f7       	brne	.-28     	; 0x2a24 <ScanEDCFlow+0x106>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2a40:	10 92 cd 0b 	sts	0x0BCD, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	80 93 99 01 	sts	0x0199, r24
			 IsPrintApprovalCode=True;
    2a4a:	80 93 9a 01 	sts	0x019A, r24
    2a4e:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    2a50:	34 30       	cpi	r19, 0x04	; 4
    2a52:	19 f5       	brne	.+70     	; 0x2a9a <ScanEDCFlow+0x17c>
    2a54:	e0 e2       	ldi	r30, 0x20	; 32
    2a56:	f9 e0       	ldi	r31, 0x09	; 9
    2a58:	a0 ef       	ldi	r26, 0xF0	; 240
    2a5a:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2a5c:	81 91       	ld	r24, Z+
    2a5e:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2a60:	89 e0       	ldi	r24, 0x09	; 9
    2a62:	e6 32       	cpi	r30, 0x26	; 38
    2a64:	f8 07       	cpc	r31, r24
    2a66:	d1 f7       	brne	.-12     	; 0x2a5c <ScanEDCFlow+0x13e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2a68:	10 92 f6 07 	sts	0x07F6, r1
    2a6c:	a3 e5       	ldi	r26, 0x53	; 83
    2a6e:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2a70:	81 91       	ld	r24, Z+
    2a72:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2a74:	89 e0       	ldi	r24, 0x09	; 9
    2a76:	e0 33       	cpi	r30, 0x30	; 48
    2a78:	f8 07       	cpc	r31, r24
    2a7a:	d1 f7       	brne	.-12     	; 0x2a70 <ScanEDCFlow+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2a7c:	10 92 5d 07 	sts	0x075D, r1
    2a80:	af eb       	ldi	r26, 0xBF	; 191
    2a82:	bb e0       	ldi	r27, 0x0B	; 11
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2a84:	81 91       	ld	r24, Z+
    2a86:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2a88:	89 e0       	ldi	r24, 0x09	; 9
    2a8a:	ee 33       	cpi	r30, 0x3E	; 62
    2a8c:	f8 07       	cpc	r31, r24
    2a8e:	d1 f7       	brne	.-12     	; 0x2a84 <ScanEDCFlow+0x166>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2a90:	10 92 cd 0b 	sts	0x0BCD, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    2a94:	81 e0       	ldi	r24, 0x01	; 1
    2a96:	80 93 9b 01 	sts	0x019B, r24
    2a9a:	08 95       	ret

00002a9c <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    2a9c:	08 95       	ret

00002a9e <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    2a9e:	98 2f       	mov	r25, r24
    2aa0:	ef e6       	ldi	r30, 0x6F	; 111
    2aa2:	f8 e0       	ldi	r31, 0x08	; 8
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    2aa4:	80 81       	ld	r24, Z
    2aa6:	81 83       	std	Z+1, r24	; 0x01
    2aa8:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    2aaa:	88 e0       	ldi	r24, 0x08	; 8
    2aac:	ec 35       	cpi	r30, 0x5C	; 92
    2aae:	f8 07       	cpc	r31, r24
    2ab0:	c9 f7       	brne	.-14     	; 0x2aa4 <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    2ab2:	9f 01       	movw	r18, r30
    2ab4:	2f 5f       	subi	r18, 0xFF	; 255
    2ab6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ab8:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    2aba:	84 85       	ldd	r24, Z+12	; 0x0c
    2abc:	82 30       	cpi	r24, 0x02	; 2
    2abe:	f9 f4       	brne	.+62     	; 0x2afe <ScanRFIDFlow+0x60>
    2ac0:	80 91 5e 08 	lds	r24, 0x085E
    2ac4:	8a 30       	cpi	r24, 0x0A	; 10
    2ac6:	d9 f4       	brne	.+54     	; 0x2afe <ScanRFIDFlow+0x60>
    2ac8:	93 30       	cpi	r25, 0x03	; 3
    2aca:	c9 f4       	brne	.+50     	; 0x2afe <ScanRFIDFlow+0x60>
    2acc:	f9 01       	movw	r30, r18
    2ace:	3a 96       	adiw	r30, 0x0a	; 10
    2ad0:	a1 e5       	ldi	r26, 0x51	; 81
    2ad2:	bc e0       	ldi	r27, 0x0C	; 12
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    2ad4:	80 81       	ld	r24, Z
    2ad6:	8d 93       	st	X+, r24
    2ad8:	31 97       	sbiw	r30, 0x01	; 1
    2ada:	88 e0       	ldi	r24, 0x08	; 8
    2adc:	ef 35       	cpi	r30, 0x5F	; 95
    2ade:	f8 07       	cpc	r31, r24
    2ae0:	c9 f7       	brne	.-14     	; 0x2ad4 <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    2ae2:	10 92 59 0c 	sts	0x0C59, r1
	    IsRFIDDetected=True;
    2ae6:	81 e0       	ldi	r24, 0x01	; 1
    2ae8:	80 93 98 01 	sts	0x0198, r24
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    2aec:	80 93 ae 02 	sts	0x02AE, r24
	 __key_lgtcnt = 0; 
    2af0:	10 92 af 02 	sts	0x02AF, r1
	 PORTG=PORTG&0b11111101;
    2af4:	80 91 65 00 	lds	r24, 0x0065
    2af8:	8d 7f       	andi	r24, 0xFD	; 253
    2afa:	80 93 65 00 	sts	0x0065, r24
    2afe:	08 95       	ret

00002b00 <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    2b00:	1f 92       	push	r1
    2b02:	0f 92       	push	r0
    2b04:	0f b6       	in	r0, 0x3f	; 63
    2b06:	0f 92       	push	r0
    2b08:	11 24       	eor	r1, r1
    2b0a:	8f 93       	push	r24
    2b0c:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    2b0e:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    2b10:	80 91 b2 01 	lds	r24, 0x01B2
    2b14:	81 30       	cpi	r24, 0x01	; 1
    2b16:	21 f0       	breq	.+8      	; 0x2b20 <__vector_18+0x20>
    2b18:	80 91 b4 01 	lds	r24, 0x01B4
    2b1c:	81 30       	cpi	r24, 0x01	; 1
    2b1e:	51 f4       	brne	.+20     	; 0x2b34 <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    2b20:	93 31       	cpi	r25, 0x13	; 19
    2b22:	21 f4       	brne	.+8      	; 0x2b2c <__vector_18+0x2c>
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	80 93 b3 01 	sts	0x01B3, r24
    2b2a:	04 c0       	rjmp	.+8      	; 0x2b34 <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    2b2c:	91 31       	cpi	r25, 0x11	; 17
    2b2e:	11 f4       	brne	.+4      	; 0x2b34 <__vector_18+0x34>
    2b30:	10 92 b3 01 	sts	0x01B3, r1
	}
}
    2b34:	9f 91       	pop	r25
    2b36:	8f 91       	pop	r24
    2b38:	0f 90       	pop	r0
    2b3a:	0f be       	out	0x3f, r0	; 63
    2b3c:	0f 90       	pop	r0
    2b3e:	1f 90       	pop	r1
    2b40:	18 95       	reti

00002b42 <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    2b42:	80 e0       	ldi	r24, 0x00	; 0
    2b44:	08 95       	ret

00002b46 <ConfigProtocol>:
	 }
	 uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    2b46:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    2b48:	80 91 9f 02 	lds	r24, 0x029F
    2b4c:	89 36       	cpi	r24, 0x69	; 105
    2b4e:	e9 f4       	brne	.+58     	; 0x2b8a <ConfigProtocol+0x44>
    2b50:	80 91 9e 02 	lds	r24, 0x029E
    2b54:	83 34       	cpi	r24, 0x43	; 67
    2b56:	c9 f4       	brne	.+50     	; 0x2b8a <ConfigProtocol+0x44>
    2b58:	80 91 9d 02 	lds	r24, 0x029D
    2b5c:	8f 36       	cpi	r24, 0x6F	; 111
    2b5e:	a9 f4       	brne	.+42     	; 0x2b8a <ConfigProtocol+0x44>
    2b60:	80 91 9c 02 	lds	r24, 0x029C
    2b64:	8e 36       	cpi	r24, 0x6E	; 110
    2b66:	89 f4       	brne	.+34     	; 0x2b8a <ConfigProtocol+0x44>
    2b68:	80 91 9b 02 	lds	r24, 0x029B
    2b6c:	86 36       	cpi	r24, 0x66	; 102
    2b6e:	69 f4       	brne	.+26     	; 0x2b8a <ConfigProtocol+0x44>
    2b70:	80 91 9a 02 	lds	r24, 0x029A
    2b74:	8f 33       	cpi	r24, 0x3F	; 63
    2b76:	49 f4       	brne	.+18     	; 0x2b8a <ConfigProtocol+0x44>
    2b78:	80 91 99 02 	lds	r24, 0x0299
    2b7c:	8d 30       	cpi	r24, 0x0D	; 13
    2b7e:	29 f4       	brne	.+10     	; 0x2b8a <ConfigProtocol+0x44>
    2b80:	2a 30       	cpi	r18, 0x0A	; 10
    2b82:	19 f4       	brne	.+6      	; 0x2b8a <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    2b84:	82 e0       	ldi	r24, 0x02	; 2
    2b86:	80 93 b0 01 	sts	0x01B0, r24
	}

	if (IsConfigFlow==True){        
    2b8a:	80 91 85 01 	lds	r24, 0x0185
    2b8e:	81 30       	cpi	r24, 0x01	; 1
    2b90:	69 f4       	brne	.+26     	; 0x2bac <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    2b92:	80 91 89 01 	lds	r24, 0x0189
    2b96:	90 91 8a 01 	lds	r25, 0x018A
    2b9a:	fc 01       	movw	r30, r24
    2b9c:	e3 5e       	subi	r30, 0xE3	; 227
    2b9e:	f6 4f       	sbci	r31, 0xF6	; 246
    2ba0:	20 83       	st	Z, r18
	    char_count++; 
    2ba2:	01 96       	adiw	r24, 0x01	; 1
    2ba4:	90 93 8a 01 	sts	0x018A, r25
    2ba8:	80 93 89 01 	sts	0x0189, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    2bac:	80 91 99 02 	lds	r24, 0x0299
    2bb0:	84 30       	cpi	r24, 0x04	; 4
    2bb2:	51 f4       	brne	.+20     	; 0x2bc8 <ConfigProtocol+0x82>
    2bb4:	20 34       	cpi	r18, 0x40	; 64
    2bb6:	e9 f4       	brne	.+58     	; 0x2bf2 <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    2bb8:	81 e0       	ldi	r24, 0x01	; 1
    2bba:	80 93 85 01 	sts	0x0185, r24
		 char_count=0;
    2bbe:	10 92 8a 01 	sts	0x018A, r1
    2bc2:	10 92 89 01 	sts	0x0189, r1
    2bc6:	15 c0       	rjmp	.+42     	; 0x2bf2 <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    2bc8:	85 30       	cpi	r24, 0x05	; 5
    2bca:	99 f4       	brne	.+38     	; 0x2bf2 <ConfigProtocol+0xac>
    2bcc:	20 35       	cpi	r18, 0x50	; 80
    2bce:	89 f4       	brne	.+34     	; 0x2bf2 <ConfigProtocol+0xac>
	     transLength=char_count;
    2bd0:	80 91 89 01 	lds	r24, 0x0189
    2bd4:	90 91 8a 01 	lds	r25, 0x018A
    2bd8:	90 93 8c 01 	sts	0x018C, r25
    2bdc:	80 93 8b 01 	sts	0x018B, r24
		 char_count=0;
    2be0:	10 92 8a 01 	sts	0x018A, r1
    2be4:	10 92 89 01 	sts	0x0189, r1
	     IsConfigFlow=False;
    2be8:	10 92 85 01 	sts	0x0185, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    2bec:	81 e0       	ldi	r24, 0x01	; 1
    2bee:	80 93 b0 01 	sts	0x01B0, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    2bf2:	80 91 9e 02 	lds	r24, 0x029E
    2bf6:	80 93 9f 02 	sts	0x029F, r24
	Conflow[5]=Conflow[4];
    2bfa:	80 91 9d 02 	lds	r24, 0x029D
    2bfe:	80 93 9e 02 	sts	0x029E, r24
	Conflow[4]=Conflow[3];
    2c02:	80 91 9c 02 	lds	r24, 0x029C
    2c06:	80 93 9d 02 	sts	0x029D, r24
	Conflow[3]=Conflow[2];
    2c0a:	80 91 9b 02 	lds	r24, 0x029B
    2c0e:	80 93 9c 02 	sts	0x029C, r24
	Conflow[2]=Conflow[1];
    2c12:	80 91 9a 02 	lds	r24, 0x029A
    2c16:	80 93 9b 02 	sts	0x029B, r24
	Conflow[1]=Conflow[0];
    2c1a:	80 91 99 02 	lds	r24, 0x0299
    2c1e:	80 93 9a 02 	sts	0x029A, r24
	Conflow[0]=dataIn;
    2c22:	20 93 99 02 	sts	0x0299, r18

}
    2c26:	08 95       	ret

00002c28 <system_beep>:
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    2c28:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    2c2a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    2c2c:	80 93 bc 01 	sts	0x01BC, r24
}
    2c30:	08 95       	ret

00002c32 <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2c32:	08 95       	ret

00002c34 <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2c34:	8f 70       	andi	r24, 0x0F	; 15
    2c36:	08 95       	ret

00002c38 <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    2c38:	82 95       	swap	r24
    2c3a:	8f 70       	andi	r24, 0x0F	; 15
    2c3c:	08 95       	ret

00002c3e <Str>:
char Str(char H){
    2c3e:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2c40:	8a 30       	cpi	r24, 0x0A	; 10
    2c42:	10 f4       	brcc	.+4      	; 0x2c48 <Str+0xa>
    2c44:	80 5d       	subi	r24, 0xD0	; 208
    2c46:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2c48:	8a 50       	subi	r24, 0x0A	; 10
    2c4a:	86 30       	cpi	r24, 0x06	; 6
    2c4c:	10 f0       	brcs	.+4      	; 0x2c52 <Str+0x14>
    2c4e:	80 e0       	ldi	r24, 0x00	; 0
    2c50:	08 95       	ret
    2c52:	89 2f       	mov	r24, r25
    2c54:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2c56:	08 95       	ret

00002c58 <charToHex>:

void charToHex(char X, char *Result){
    2c58:	28 2f       	mov	r18, r24
    2c5a:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2c5c:	98 2f       	mov	r25, r24
    2c5e:	92 95       	swap	r25
    2c60:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2c62:	9a 30       	cpi	r25, 0x0A	; 10
    2c64:	18 f4       	brcc	.+6      	; 0x2c6c <charToHex+0x14>
    2c66:	89 2f       	mov	r24, r25
    2c68:	80 5d       	subi	r24, 0xD0	; 208
    2c6a:	08 c0       	rjmp	.+16     	; 0x2c7c <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2c6c:	89 2f       	mov	r24, r25
    2c6e:	8a 50       	subi	r24, 0x0A	; 10
    2c70:	86 30       	cpi	r24, 0x06	; 6
    2c72:	10 f0       	brcs	.+4      	; 0x2c78 <charToHex+0x20>
    2c74:	80 e0       	ldi	r24, 0x00	; 0
    2c76:	02 c0       	rjmp	.+4      	; 0x2c7c <charToHex+0x24>
    2c78:	89 2f       	mov	r24, r25
    2c7a:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2c7c:	80 83       	st	Z, r24
	lcd_print(1,1,lcdteks);
}

char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2c7e:	92 2f       	mov	r25, r18
    2c80:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2c82:	9a 30       	cpi	r25, 0x0A	; 10
    2c84:	18 f4       	brcc	.+6      	; 0x2c8c <charToHex+0x34>
    2c86:	89 2f       	mov	r24, r25
    2c88:	80 5d       	subi	r24, 0xD0	; 208
    2c8a:	08 c0       	rjmp	.+16     	; 0x2c9c <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2c8c:	89 2f       	mov	r24, r25
    2c8e:	8a 50       	subi	r24, 0x0A	; 10
    2c90:	86 30       	cpi	r24, 0x06	; 6
    2c92:	10 f0       	brcs	.+4      	; 0x2c98 <charToHex+0x40>
    2c94:	80 e0       	ldi	r24, 0x00	; 0
    2c96:	02 c0       	rjmp	.+4      	; 0x2c9c <charToHex+0x44>
    2c98:	89 2f       	mov	r24, r25
    2c9a:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2c9c:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2c9e:	12 82       	std	Z+2, r1	; 0x02
	 
}
    2ca0:	08 95       	ret

00002ca2 <strToInt>:

char strToInt(char *str){
    2ca2:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    2ca4:	80 81       	ld	r24, Z
    2ca6:	2a e0       	ldi	r18, 0x0A	; 10
    2ca8:	82 9f       	mul	r24, r18
    2caa:	90 01       	movw	r18, r0
    2cac:	11 24       	eor	r1, r1
    2cae:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    2cb0:	82 0f       	add	r24, r18
    2cb2:	08 95       	ret

00002cb4 <intToStr>:

void intToStr(char X, char *str){
    2cb4:	58 2f       	mov	r21, r24
    2cb6:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    2cb8:	64 e6       	ldi	r22, 0x64	; 100
    2cba:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    2cbe:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    2cc0:	85 2f       	mov	r24, r21
    2cc2:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    2cc6:	89 2f       	mov	r24, r25
    2cc8:	6a e0       	ldi	r22, 0x0A	; 10
    2cca:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    2cce:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    2cd0:	8c e9       	ldi	r24, 0x9C	; 156
    2cd2:	9f ef       	ldi	r25, 0xFF	; 255
    2cd4:	a8 9f       	mul	r26, r24
    2cd6:	80 2d       	mov	r24, r0
    2cd8:	11 24       	eor	r1, r1
    2cda:	85 0f       	add	r24, r21
    2cdc:	26 ef       	ldi	r18, 0xF6	; 246
    2cde:	3f ef       	ldi	r19, 0xFF	; 255
    2ce0:	42 9f       	mul	r20, r18
    2ce2:	90 2d       	mov	r25, r0
    2ce4:	11 24       	eor	r1, r1
    2ce6:	98 0f       	add	r25, r24
	 if (X>=100){
    2ce8:	54 36       	cpi	r21, 0x64	; 100
    2cea:	40 f0       	brcs	.+16     	; 0x2cfc <intToStr+0x48>
	     str[0]=('0'+R);
    2cec:	a0 5d       	subi	r26, 0xD0	; 208
    2cee:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    2cf0:	40 5d       	subi	r20, 0xD0	; 208
    2cf2:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    2cf4:	90 5d       	subi	r25, 0xD0	; 208
    2cf6:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    2cf8:	13 82       	std	Z+3, r1	; 0x03
    2cfa:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    2cfc:	5b 30       	cpi	r21, 0x0B	; 11
    2cfe:	18 f4       	brcc	.+6      	; 0x2d06 <intToStr+0x52>
	     str[0]=('0'+S);
    2d00:	90 5d       	subi	r25, 0xD0	; 208
    2d02:	90 83       	st	Z, r25
	     str[1]=0;
    2d04:	11 82       	std	Z+1, r1	; 0x01
    2d06:	08 95       	ret

00002d08 <UpdateClientIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
	 */
}
    2d08:	08 95       	ret

00002d0a <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
		 */
}
    2d0a:	08 95       	ret

00002d0c <UpdateIFT_ID>:
void UpdateIFT_ID(){
    /* char IdIFT;
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
	 */
}
    2d0c:	08 95       	ret

00002d0e <UpdateSeqNum>:
/*
     if (SeqNum<100)SeqNum++;
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 
    2d0e:	08 95       	ret

00002d10 <ViewCardID>:
}




void ViewCardID(){//+12345678 -->12345678
    2d10:	20 e0       	ldi	r18, 0x00	; 0
    2d12:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    2d14:	f9 01       	movw	r30, r18
    2d16:	e7 57       	subi	r30, 0x77	; 119
    2d18:	f4 4f       	sbci	r31, 0xF4	; 244
    2d1a:	d9 01       	movw	r26, r18
    2d1c:	af 5a       	subi	r26, 0xAF	; 175
    2d1e:	b3 4f       	sbci	r27, 0xF3	; 243
    2d20:	8c 91       	ld	r24, X
    2d22:	80 83       	st	Z, r24
    2d24:	2f 5f       	subi	r18, 0xFF	; 255
    2d26:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2d28:	28 30       	cpi	r18, 0x08	; 8
    2d2a:	31 05       	cpc	r19, r1
    2d2c:	99 f7       	brne	.-26     	; 0x2d14 <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2d2e:	10 92 91 0b 	sts	0x0B91, r1
}
    2d32:	08 95       	ret

00002d34 <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    2d34:	cf 93       	push	r28
    2d36:	df 93       	push	r29
    2d38:	db 01       	movw	r26, r22
    2d3a:	ec 01       	movw	r28, r24
    2d3c:	20 e0       	ldi	r18, 0x00	; 0
    2d3e:	30 e0       	ldi	r19, 0x00	; 0
    2d40:	07 c0       	rjmp	.+14     	; 0x2d50 <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    2d42:	fd 01       	movw	r30, r26
    2d44:	e2 0f       	add	r30, r18
    2d46:	f3 1f       	adc	r31, r19
    2d48:	89 91       	ld	r24, Y+
    2d4a:	80 83       	st	Z, r24
    2d4c:	2f 5f       	subi	r18, 0xFF	; 255
    2d4e:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2d50:	24 17       	cp	r18, r20
    2d52:	b8 f3       	brcs	.-18     	; 0x2d42 <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2d54:	a4 0f       	add	r26, r20
    2d56:	b1 1d       	adc	r27, r1
    2d58:	1c 92       	st	X, r1
}
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	08 95       	ret

00002d60 <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2d60:	cf 93       	push	r28
    2d62:	df 93       	push	r29
    2d64:	db 01       	movw	r26, r22
    2d66:	ec 01       	movw	r28, r24
    2d68:	c4 0f       	add	r28, r20
    2d6a:	d1 1d       	adc	r29, r1
    2d6c:	40 e0       	ldi	r20, 0x00	; 0
    2d6e:	50 e0       	ldi	r21, 0x00	; 0
    2d70:	07 c0       	rjmp	.+14     	; 0x2d80 <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2d72:	fd 01       	movw	r30, r26
    2d74:	e4 0f       	add	r30, r20
    2d76:	f5 1f       	adc	r31, r21
    2d78:	89 91       	ld	r24, Y+
    2d7a:	80 83       	st	Z, r24
    2d7c:	4f 5f       	subi	r20, 0xFF	; 255
    2d7e:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2d80:	42 17       	cp	r20, r18
    2d82:	b8 f3       	brcs	.-18     	; 0x2d72 <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2d84:	a2 0f       	add	r26, r18
    2d86:	b1 1d       	adc	r27, r1
    2d88:	1c 92       	st	X, r1
}
    2d8a:	df 91       	pop	r29
    2d8c:	cf 91       	pop	r28
    2d8e:	08 95       	ret

00002d90 <TestLocalAccount>:

void TestLocalAccount(){

}
    2d90:	08 95       	ret

00002d92 <BackLightTrig>:
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    2d92:	81 e0       	ldi	r24, 0x01	; 1
    2d94:	80 93 ae 02 	sts	0x02AE, r24
	 __key_lgtcnt = 0; 
    2d98:	10 92 af 02 	sts	0x02AF, r1
	 PORTG=PORTG&0b11111101;
    2d9c:	e5 e6       	ldi	r30, 0x65	; 101
    2d9e:	f0 e0       	ldi	r31, 0x00	; 0
    2da0:	80 81       	ld	r24, Z
    2da2:	8d 7f       	andi	r24, 0xFD	; 253
    2da4:	80 83       	st	Z, r24
}
    2da6:	08 95       	ret

00002da8 <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2da8:	82 30       	cpi	r24, 0x02	; 2
    2daa:	59 f0       	breq	.+22     	; 0x2dc2 <GetBaudrate+0x1a>
    2dac:	82 30       	cpi	r24, 0x02	; 2
    2dae:	18 f0       	brcs	.+6      	; 0x2db6 <GetBaudrate+0xe>
    2db0:	83 30       	cpi	r24, 0x03	; 3
    2db2:	21 f4       	brne	.+8      	; 0x2dbc <GetBaudrate+0x14>
    2db4:	09 c0       	rjmp	.+18     	; 0x2dc8 <GetBaudrate+0x20>
    2db6:	20 e8       	ldi	r18, 0x80	; 128
    2db8:	35 e2       	ldi	r19, 0x25	; 37
    2dba:	08 c0       	rjmp	.+16     	; 0x2dcc <GetBaudrate+0x24>
    2dbc:	20 e0       	ldi	r18, 0x00	; 0
    2dbe:	30 e0       	ldi	r19, 0x00	; 0
    2dc0:	05 c0       	rjmp	.+10     	; 0x2dcc <GetBaudrate+0x24>
    2dc2:	20 e0       	ldi	r18, 0x00	; 0
    2dc4:	3b e4       	ldi	r19, 0x4B	; 75
    2dc6:	02 c0       	rjmp	.+4      	; 0x2dcc <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2dc8:	2b e9       	ldi	r18, 0x9B	; 155
    2dca:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2dcc:	c9 01       	movw	r24, r18
    2dce:	08 95       	ret

00002dd0 <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2dd0:	e1 99       	sbic	0x1c, 1	; 28
    2dd2:	fe cf       	rjmp	.-4      	; 0x2dd0 <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2dd4:	84 e4       	ldi	r24, 0x44	; 68
    2dd6:	91 e0       	ldi	r25, 0x01	; 1
    2dd8:	9f bb       	out	0x1f, r25	; 31
    2dda:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2ddc:	e0 9a       	sbi	0x1c, 0	; 28
    2dde:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2de0:	80 93 5c 01 	sts	0x015C, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2de4:	e1 99       	sbic	0x1c, 1	; 28
    2de6:	fe cf       	rjmp	.-4      	; 0x2de4 <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2de8:	89 e4       	ldi	r24, 0x49	; 73
    2dea:	91 e0       	ldi	r25, 0x01	; 1
    2dec:	9f bb       	out	0x1f, r25	; 31
    2dee:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2df0:	e0 9a       	sbi	0x1c, 0	; 28
    2df2:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2df4:	80 93 5d 01 	sts	0x015D, r24
}
    2df8:	08 95       	ret

00002dfa <InitStandalone>:
	      RunInitStandalone=False;
	      break;
	 }
  }
  */
}
    2dfa:	08 95       	ret

00002dfc <DisplayQueueFIP>:


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2dfc:	08 95       	ret

00002dfe <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2dfe:	08 95       	ret

00002e00 <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2e00:	86 27       	eor	r24, r22
    2e02:	08 95       	ret

00002e04 <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2e04:	08 95       	ret

00002e06 <GeniusCalc>:


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
	 Result=0;
     switch(cOption){
    2e06:	88 23       	and	r24, r24
    2e08:	19 f0       	breq	.+6      	; 0x2e10 <GeniusCalc+0xa>
    2e0a:	81 30       	cpi	r24, 0x01	; 1
    2e0c:	49 f5       	brne	.+82     	; 0x2e60 <GeniusCalc+0x5a>
    2e0e:	11 c0       	rjmp	.+34     	; 0x2e32 <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2e10:	26 2f       	mov	r18, r22
    2e12:	30 e0       	ldi	r19, 0x00	; 0
    2e14:	24 0f       	add	r18, r20
    2e16:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2e18:	c9 01       	movw	r24, r18
    2e1a:	6a e0       	ldi	r22, 0x0A	; 10
    2e1c:	70 e0       	ldi	r23, 0x00	; 0
    2e1e:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    2e22:	48 2f       	mov	r20, r24
    2e24:	c9 01       	movw	r24, r18
    2e26:	6a e0       	ldi	r22, 0x0A	; 10
    2e28:	70 e0       	ldi	r23, 0x00	; 0
    2e2a:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    2e2e:	46 0f       	add	r20, r22
    2e30:	18 c0       	rjmp	.+48     	; 0x2e62 <GeniusCalc+0x5c>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2e32:	66 23       	and	r22, r22
    2e34:	09 f4       	brne	.+2      	; 0x2e38 <GeniusCalc+0x32>
    2e36:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2e38:	44 23       	and	r20, r20
    2e3a:	09 f4       	brne	.+2      	; 0x2e3e <GeniusCalc+0x38>
    2e3c:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2e3e:	46 9f       	mul	r20, r22
    2e40:	90 01       	movw	r18, r0
    2e42:	11 24       	eor	r1, r1
    2e44:	c9 01       	movw	r24, r18
    2e46:	6a e0       	ldi	r22, 0x0A	; 10
    2e48:	70 e0       	ldi	r23, 0x00	; 0
    2e4a:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    2e4e:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2e50:	c9 01       	movw	r24, r18
    2e52:	6a e0       	ldi	r22, 0x0A	; 10
    2e54:	70 e0       	ldi	r23, 0x00	; 0
    2e56:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    2e5a:	64 2f       	mov	r22, r20
    2e5c:	48 2f       	mov	r20, r24
    2e5e:	d8 cf       	rjmp	.-80     	; 0x2e10 <GeniusCalc+0xa>
    2e60:	40 e0       	ldi	r20, 0x00	; 0
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2e62:	84 2f       	mov	r24, r20
    2e64:	08 95       	ret

00002e66 <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2e66:	81 e0       	ldi	r24, 0x01	; 1
    2e68:	08 95       	ret

00002e6a <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2e6a:	ff 92       	push	r15
    2e6c:	0f 93       	push	r16
    2e6e:	1f 93       	push	r17
    2e70:	cf 93       	push	r28
    2e72:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2e74:	f0 90 5c 01 	lds	r15, 0x015C
    2e78:	ec 01       	movw	r28, r24
    2e7a:	00 e0       	ldi	r16, 0x00	; 0
    2e7c:	10 e0       	ldi	r17, 0x00	; 0
    2e7e:	09 c0       	rjmp	.+18     	; 0x2e92 <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2e80:	8e e0       	ldi	r24, 0x0E	; 14
    2e82:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    2e86:	98 81       	ld	r25, Y
    2e88:	98 17       	cp	r25, r24
    2e8a:	09 f4       	brne	.+2      	; 0x2e8e <CountNoPumpSatus+0x24>
		      Result++;		  
    2e8c:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2e8e:	0f 5f       	subi	r16, 0xFF	; 255
    2e90:	21 96       	adiw	r28, 0x01	; 1
    2e92:	0f 15       	cp	r16, r15
    2e94:	a8 f3       	brcs	.-22     	; 0x2e80 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2e96:	81 2f       	mov	r24, r17
    2e98:	df 91       	pop	r29
    2e9a:	cf 91       	pop	r28
    2e9c:	1f 91       	pop	r17
    2e9e:	0f 91       	pop	r16
    2ea0:	ff 90       	pop	r15
    2ea2:	08 95       	ret

00002ea4 <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2ea4:	08 95       	ret

00002ea6 <FLockPump>:
char FLockPump(){

}
    2ea6:	08 95       	ret

00002ea8 <FMenuSettingPassword>:
char FMenuSettingPassword(){
     char Result;
   //_menu_password();
   Result=MENU_DONE;
   return Result;
}
    2ea8:	81 e0       	ldi	r24, 0x01	; 1
    2eaa:	08 95       	ret

00002eac <menu_product>:
   return Result;
}

void menu_product(){

}
    2eac:	08 95       	ret

00002eae <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2eae:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2eb0:	80 81       	ld	r24, Z
    2eb2:	84 17       	cp	r24, r20
    2eb4:	18 f4       	brcc	.+6      	; 0x2ebc <IncValue+0xe>
	     (*Value)++;
    2eb6:	8f 5f       	subi	r24, 0xFF	; 255
    2eb8:	80 83       	st	Z, r24
    2eba:	08 95       	ret
	 }else *Value=MinValue;
    2ebc:	60 83       	st	Z, r22
    2ebe:	08 95       	ret

00002ec0 <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2ec0:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2ec2:	80 81       	ld	r24, Z
    2ec4:	68 17       	cp	r22, r24
    2ec6:	18 f4       	brcc	.+6      	; 0x2ece <DecValue+0xe>
	     (*Value)--;
    2ec8:	81 50       	subi	r24, 0x01	; 1
    2eca:	80 83       	st	Z, r24
    2ecc:	08 95       	ret
	 }else *Value=MaxValue;
    2ece:	40 83       	st	Z, r20
    2ed0:	08 95       	ret

00002ed2 <zeroIP>:
		 
		}

	}
}
void zeroIP(unsigned char Val,char *StrResult){
    2ed2:	58 2f       	mov	r21, r24
    2ed4:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2ed6:	84 36       	cpi	r24, 0x64	; 100
    2ed8:	00 f1       	brcs	.+64     	; 0x2f1a <zeroIP+0x48>
	    R=(Val/100);
    2eda:	64 e6       	ldi	r22, 0x64	; 100
    2edc:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    2ee0:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2ee2:	85 2f       	mov	r24, r21
    2ee4:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    2ee8:	89 2f       	mov	r24, r25
    2eea:	6a e0       	ldi	r22, 0x0A	; 10
    2eec:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2ef0:	40 5d       	subi	r20, 0xD0	; 208
    2ef2:	40 83       	st	Z, r20
    2ef4:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2ef6:	80 5d       	subi	r24, 0xD0	; 208
    2ef8:	81 83       	std	Z+1, r24	; 0x01
    2efa:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2efc:	50 5d       	subi	r21, 0xD0	; 208
    2efe:	2c e9       	ldi	r18, 0x9C	; 156
    2f00:	3f ef       	ldi	r19, 0xFF	; 255
    2f02:	42 9f       	mul	r20, r18
    2f04:	40 2d       	mov	r20, r0
    2f06:	11 24       	eor	r1, r1
    2f08:	45 0f       	add	r20, r21
    2f0a:	26 ef       	ldi	r18, 0xF6	; 246
    2f0c:	3f ef       	ldi	r19, 0xFF	; 255
    2f0e:	82 9f       	mul	r24, r18
    2f10:	80 2d       	mov	r24, r0
    2f12:	11 24       	eor	r1, r1
    2f14:	84 0f       	add	r24, r20
    2f16:	82 83       	std	Z+2, r24	; 0x02
    2f18:	10 c0       	rjmp	.+32     	; 0x2f3a <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2f1a:	8a 50       	subi	r24, 0x0A	; 10
    2f1c:	8a 35       	cpi	r24, 0x5A	; 90
    2f1e:	78 f4       	brcc	.+30     	; 0x2f3e <zeroIP+0x6c>
        StrResult[0]='0';
    2f20:	80 e3       	ldi	r24, 0x30	; 48
    2f22:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2f24:	85 2f       	mov	r24, r21
    2f26:	6a e0       	ldi	r22, 0x0A	; 10
    2f28:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    2f2c:	80 5d       	subi	r24, 0xD0	; 208
    2f2e:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2f30:	85 2f       	mov	r24, r21
    2f32:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    2f36:	90 5d       	subi	r25, 0xD0	; 208
    2f38:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2f3a:	13 82       	std	Z+3, r1	; 0x03
    2f3c:	08 95       	ret
		}
     else
	 if (Val<10){
    2f3e:	5a 30       	cpi	r21, 0x0A	; 10
    2f40:	30 f4       	brcc	.+12     	; 0x2f4e <zeroIP+0x7c>
	    StrResult[0]='0';
    2f42:	80 e3       	ldi	r24, 0x30	; 48
    2f44:	80 83       	st	Z, r24
		StrResult[1]='0';
    2f46:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2f48:	50 5d       	subi	r21, 0xD0	; 208
    2f4a:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2f4c:	13 82       	std	Z+3, r1	; 0x03
    2f4e:	08 95       	ret

00002f50 <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2f50:	81 30       	cpi	r24, 0x01	; 1
    2f52:	29 f0       	breq	.+10     	; 0x2f5e <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2f54:	82 30       	cpi	r24, 0x02	; 2
    2f56:	19 f0       	breq	.+6      	; 0x2f5e <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2f58:	83 30       	cpi	r24, 0x03	; 3
    2f5a:	09 f0       	breq	.+2      	; 0x2f5e <GetLocAccStatus+0xe>
    2f5c:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2f5e:	08 95       	ret

00002f60 <FTestRemZero>:
	     RemZeroLead(strTest);  
		 uart_print(0,1,strTest);

	while (1){};
  #endif
}
    2f60:	08 95       	ret

00002f62 <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2f62:	cf 93       	push	r28
    2f64:	df 93       	push	r29
    2f66:	eb 01       	movw	r28, r22
    2f68:	da 01       	movw	r26, r20
    2f6a:	a8 0f       	add	r26, r24
    2f6c:	b9 1f       	adc	r27, r25
    2f6e:	40 e0       	ldi	r20, 0x00	; 0
    2f70:	50 e0       	ldi	r21, 0x00	; 0
    2f72:	07 c0       	rjmp	.+14     	; 0x2f82 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f74:	fe 01       	movw	r30, r28
    2f76:	e4 0f       	add	r30, r20
    2f78:	f5 1f       	adc	r31, r21
    2f7a:	8d 91       	ld	r24, X+
    2f7c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f7e:	4f 5f       	subi	r20, 0xFF	; 255
    2f80:	5f 4f       	sbci	r21, 0xFF	; 255
    2f82:	42 17       	cp	r20, r18
    2f84:	53 07       	cpc	r21, r19
    2f86:	b0 f3       	brcs	.-20     	; 0x2f74 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f88:	c2 0f       	add	r28, r18
    2f8a:	d3 1f       	adc	r29, r19
    2f8c:	18 82       	st	Y, r1
}
    2f8e:	df 91       	pop	r29
    2f90:	cf 91       	pop	r28
    2f92:	08 95       	ret

00002f94 <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2f94:	0f 93       	push	r16
    2f96:	1f 93       	push	r17
    2f98:	cf 93       	push	r28
    2f9a:	df 93       	push	r29
    2f9c:	8c 01       	movw	r16, r24
    2f9e:	db 01       	movw	r26, r22
    2fa0:	eb 01       	movw	r28, r22
    2fa2:	c4 0f       	add	r28, r20
    2fa4:	d5 1f       	adc	r29, r21
    2fa6:	60 e0       	ldi	r22, 0x00	; 0
    2fa8:	70 e0       	ldi	r23, 0x00	; 0
    2faa:	07 c0       	rjmp	.+14     	; 0x2fba <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2fac:	f8 01       	movw	r30, r16
    2fae:	e6 0f       	add	r30, r22
    2fb0:	f7 1f       	adc	r31, r23
    2fb2:	80 81       	ld	r24, Z
    2fb4:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fb6:	6f 5f       	subi	r22, 0xFF	; 255
    2fb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2fba:	62 17       	cp	r22, r18
    2fbc:	73 07       	cpc	r23, r19
    2fbe:	b0 f3       	brcs	.-20     	; 0x2fac <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2fc0:	a4 0f       	add	r26, r20
    2fc2:	b5 1f       	adc	r27, r21
    2fc4:	a2 0f       	add	r26, r18
    2fc6:	b3 1f       	adc	r27, r19
    2fc8:	1c 92       	st	X, r1
}
    2fca:	df 91       	pop	r29
    2fcc:	cf 91       	pop	r28
    2fce:	1f 91       	pop	r17
    2fd0:	0f 91       	pop	r16
    2fd2:	08 95       	ret

00002fd4 <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2fd4:	fb 01       	movw	r30, r22
    2fd6:	e8 0f       	add	r30, r24
    2fd8:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2fda:	80 81       	ld	r24, Z
    2fdc:	08 95       	ret

00002fde <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2fde:	80 91 1d 09 	lds	r24, 0x091D
    2fe2:	81 30       	cpi	r24, 0x01	; 1
    2fe4:	51 f4       	brne	.+20     	; 0x2ffa <procMessage00+0x1c>
    2fe6:	80 91 8b 01 	lds	r24, 0x018B
    2fea:	90 91 8c 01 	lds	r25, 0x018C
    2fee:	8f 97       	sbiw	r24, 0x2f	; 47
    2ff0:	21 f4       	brne	.+8      	; 0x2ffa <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2ff2:	80 91 42 09 	lds	r24, 0x0942
    2ff6:	80 53       	subi	r24, 0x30	; 48
    2ff8:	08 95       	ret
    2ffa:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2ffc:	08 95       	ret

00002ffe <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2ffe:	90 91 44 09 	lds	r25, 0x0944
    3002:	20 e0       	ldi	r18, 0x00	; 0
    3004:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3006:	f9 01       	movw	r30, r18
    3008:	ee 56       	subi	r30, 0x6E	; 110
    300a:	f7 4f       	sbci	r31, 0xF7	; 247
    300c:	d9 01       	movw	r26, r18
    300e:	a3 5e       	subi	r26, 0xE3	; 227
    3010:	b6 4f       	sbci	r27, 0xF6	; 246
    3012:	97 96       	adiw	r26, 0x27	; 39
    3014:	8c 91       	ld	r24, X
    3016:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3018:	2f 5f       	subi	r18, 0xFF	; 255
    301a:	3f 4f       	sbci	r19, 0xFF	; 255
    301c:	24 31       	cpi	r18, 0x14	; 20
    301e:	31 05       	cpc	r19, r1
    3020:	91 f7       	brne	.-28     	; 0x3006 <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3022:	10 92 a6 08 	sts	0x08A6, r1
    3026:	20 e0       	ldi	r18, 0x00	; 0
    3028:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    302a:	f9 01       	movw	r30, r18
    302c:	ed 55       	subi	r30, 0x5D	; 93
    302e:	f8 4f       	sbci	r31, 0xF8	; 248
    3030:	d9 01       	movw	r26, r18
    3032:	a3 5e       	subi	r26, 0xE3	; 227
    3034:	b6 4f       	sbci	r27, 0xF6	; 246
    3036:	db 96       	adiw	r26, 0x3b	; 59
    3038:	8c 91       	ld	r24, X
    303a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    303c:	2f 5f       	subi	r18, 0xFF	; 255
    303e:	3f 4f       	sbci	r19, 0xFF	; 255
    3040:	24 31       	cpi	r18, 0x14	; 20
    3042:	31 05       	cpc	r19, r1
    3044:	91 f7       	brne	.-28     	; 0x302a <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3046:	10 92 b7 07 	sts	0x07B7, r1
    304a:	20 e0       	ldi	r18, 0x00	; 0
    304c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    304e:	f9 01       	movw	r30, r18
    3050:	e4 5e       	subi	r30, 0xE4	; 228
    3052:	f7 4f       	sbci	r31, 0xF7	; 247
    3054:	d9 01       	movw	r26, r18
    3056:	a4 59       	subi	r26, 0x94	; 148
    3058:	b6 4f       	sbci	r27, 0xF6	; 246
    305a:	8c 91       	ld	r24, X
    305c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    305e:	2f 5f       	subi	r18, 0xFF	; 255
    3060:	3f 4f       	sbci	r19, 0xFF	; 255
    3062:	24 31       	cpi	r18, 0x14	; 20
    3064:	31 05       	cpc	r19, r1
    3066:	99 f7       	brne	.-26     	; 0x304e <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3068:	10 92 30 08 	sts	0x0830, r1
    306c:	20 e0       	ldi	r18, 0x00	; 0
    306e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3070:	f9 01       	movw	r30, r18
    3072:	ea 52       	subi	r30, 0x2A	; 42
    3074:	f4 4f       	sbci	r31, 0xF4	; 244
    3076:	d9 01       	movw	r26, r18
    3078:	a0 58       	subi	r26, 0x80	; 128
    307a:	b6 4f       	sbci	r27, 0xF6	; 246
    307c:	8c 91       	ld	r24, X
    307e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3080:	2f 5f       	subi	r18, 0xFF	; 255
    3082:	3f 4f       	sbci	r19, 0xFF	; 255
    3084:	24 31       	cpi	r18, 0x14	; 20
    3086:	31 05       	cpc	r19, r1
    3088:	99 f7       	brne	.-26     	; 0x3070 <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    308a:	10 92 ea 0b 	sts	0x0BEA, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    308e:	89 2f       	mov	r24, r25
    3090:	80 53       	subi	r24, 0x30	; 48
    3092:	08 95       	ret

00003094 <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    3094:	20 e0       	ldi	r18, 0x00	; 0
    3096:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3098:	f9 01       	movw	r30, r18
    309a:	e7 57       	subi	r30, 0x77	; 119
    309c:	f4 4f       	sbci	r31, 0xF4	; 244
    309e:	d9 01       	movw	r26, r18
    30a0:	a3 5e       	subi	r26, 0xE3	; 227
    30a2:	b6 4f       	sbci	r27, 0xF6	; 246
    30a4:	95 96       	adiw	r26, 0x25	; 37
    30a6:	8c 91       	ld	r24, X
    30a8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30aa:	2f 5f       	subi	r18, 0xFF	; 255
    30ac:	3f 4f       	sbci	r19, 0xFF	; 255
    30ae:	24 31       	cpi	r18, 0x14	; 20
    30b0:	31 05       	cpc	r19, r1
    30b2:	91 f7       	brne	.-28     	; 0x3098 <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30b4:	10 92 9d 0b 	sts	0x0B9D, r1
    30b8:	20 e0       	ldi	r18, 0x00	; 0
    30ba:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30bc:	f9 01       	movw	r30, r18
    30be:	ec 5d       	subi	r30, 0xDC	; 220
    30c0:	fc 4f       	sbci	r31, 0xFC	; 252
    30c2:	d9 01       	movw	r26, r18
    30c4:	a3 5e       	subi	r26, 0xE3	; 227
    30c6:	b6 4f       	sbci	r27, 0xF6	; 246
    30c8:	d9 96       	adiw	r26, 0x39	; 57
    30ca:	8c 91       	ld	r24, X
    30cc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30ce:	2f 5f       	subi	r18, 0xFF	; 255
    30d0:	3f 4f       	sbci	r19, 0xFF	; 255
    30d2:	2e 31       	cpi	r18, 0x1E	; 30
    30d4:	31 05       	cpc	r19, r1
    30d6:	91 f7       	brne	.-28     	; 0x30bc <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30d8:	10 92 42 03 	sts	0x0342, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30dc:	80 91 74 09 	lds	r24, 0x0974
    30e0:	80 93 8a 03 	sts	0x038A, r24
	 }Dest[Length]=0;
    30e4:	10 92 8b 03 	sts	0x038B, r1
    30e8:	20 e0       	ldi	r18, 0x00	; 0
    30ea:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30ec:	f9 01       	movw	r30, r18
    30ee:	eb 5c       	subi	r30, 0xCB	; 203
    30f0:	f7 4f       	sbci	r31, 0xF7	; 247
    30f2:	d9 01       	movw	r26, r18
    30f4:	ab 58       	subi	r26, 0x8B	; 139
    30f6:	b6 4f       	sbci	r27, 0xF6	; 246
    30f8:	8c 91       	ld	r24, X
    30fa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30fc:	2f 5f       	subi	r18, 0xFF	; 255
    30fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3100:	28 30       	cpi	r18, 0x08	; 8
    3102:	31 05       	cpc	r19, r1
    3104:	99 f7       	brne	.-26     	; 0x30ec <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3106:	10 92 3d 08 	sts	0x083D, r1
    310a:	20 e0       	ldi	r18, 0x00	; 0
    310c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    310e:	f9 01       	movw	r30, r18
    3110:	e2 58       	subi	r30, 0x82	; 130
    3112:	fc 4f       	sbci	r31, 0xFC	; 252
    3114:	d9 01       	movw	r26, r18
    3116:	a3 58       	subi	r26, 0x83	; 131
    3118:	b6 4f       	sbci	r27, 0xF6	; 246
    311a:	8c 91       	ld	r24, X
    311c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    311e:	2f 5f       	subi	r18, 0xFF	; 255
    3120:	3f 4f       	sbci	r19, 0xFF	; 255
    3122:	2a 30       	cpi	r18, 0x0A	; 10
    3124:	31 05       	cpc	r19, r1
    3126:	99 f7       	brne	.-26     	; 0x310e <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3128:	10 92 88 03 	sts	0x0388, r1
    312c:	20 e0       	ldi	r18, 0x00	; 0
    312e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3130:	f9 01       	movw	r30, r18
    3132:	e3 51       	subi	r30, 0x13	; 19
    3134:	f4 4f       	sbci	r31, 0xF4	; 244
    3136:	d9 01       	movw	r26, r18
    3138:	a9 57       	subi	r26, 0x79	; 121
    313a:	b6 4f       	sbci	r27, 0xF6	; 246
    313c:	8c 91       	ld	r24, X
    313e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3140:	2f 5f       	subi	r18, 0xFF	; 255
    3142:	3f 4f       	sbci	r19, 0xFF	; 255
    3144:	2a 30       	cpi	r18, 0x0A	; 10
    3146:	31 05       	cpc	r19, r1
    3148:	99 f7       	brne	.-26     	; 0x3130 <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    314a:	10 92 f7 0b 	sts	0x0BF7, r1
    314e:	20 e0       	ldi	r18, 0x00	; 0
    3150:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3152:	f9 01       	movw	r30, r18
    3154:	e1 54       	subi	r30, 0x41	; 65
    3156:	f4 4f       	sbci	r31, 0xF4	; 244
    3158:	d9 01       	movw	r26, r18
    315a:	af 56       	subi	r26, 0x6F	; 111
    315c:	b6 4f       	sbci	r27, 0xF6	; 246
    315e:	8c 91       	ld	r24, X
    3160:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3162:	2f 5f       	subi	r18, 0xFF	; 255
    3164:	3f 4f       	sbci	r19, 0xFF	; 255
    3166:	23 31       	cpi	r18, 0x13	; 19
    3168:	31 05       	cpc	r19, r1
    316a:	99 f7       	brne	.-26     	; 0x3152 <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    316c:	10 92 d2 0b 	sts	0x0BD2, r1
    3170:	20 e0       	ldi	r18, 0x00	; 0
    3172:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3174:	f9 01       	movw	r30, r18
    3176:	ed 54       	subi	r30, 0x4D	; 77
    3178:	f4 4f       	sbci	r31, 0xF4	; 244
    317a:	d9 01       	movw	r26, r18
    317c:	ac 55       	subi	r26, 0x5C	; 92
    317e:	b6 4f       	sbci	r27, 0xF6	; 246
    3180:	8c 91       	ld	r24, X
    3182:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3184:	2f 5f       	subi	r18, 0xFF	; 255
    3186:	3f 4f       	sbci	r19, 0xFF	; 255
    3188:	27 30       	cpi	r18, 0x07	; 7
    318a:	31 05       	cpc	r19, r1
    318c:	99 f7       	brne	.-26     	; 0x3174 <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    318e:	10 92 ba 0b 	sts	0x0BBA, r1
    3192:	20 e0       	ldi	r18, 0x00	; 0
    3194:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3196:	f9 01       	movw	r30, r18
    3198:	e5 54       	subi	r30, 0x45	; 69
    319a:	fd 4f       	sbci	r31, 0xFD	; 253
    319c:	d9 01       	movw	r26, r18
    319e:	a5 55       	subi	r26, 0x55	; 85
    31a0:	b6 4f       	sbci	r27, 0xF6	; 246
    31a2:	8c 91       	ld	r24, X
    31a4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31a6:	2f 5f       	subi	r18, 0xFF	; 255
    31a8:	3f 4f       	sbci	r19, 0xFF	; 255
    31aa:	24 30       	cpi	r18, 0x04	; 4
    31ac:	31 05       	cpc	r19, r1
    31ae:	99 f7       	brne	.-26     	; 0x3196 <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31b0:	10 92 bf 02 	sts	0x02BF, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    31b4:	80 e0       	ldi	r24, 0x00	; 0
    31b6:	08 95       	ret

000031b8 <procMessage81>:
uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    31b8:	cf 93       	push	r28
    31ba:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    31bc:	80 91 42 09 	lds	r24, 0x0942
    31c0:	89 35       	cpi	r24, 0x59	; 89
    31c2:	11 f4       	brne	.+4      	; 0x31c8 <procMessage81+0x10>
    31c4:	90 e8       	ldi	r25, 0x80	; 128
    31c6:	01 c0       	rjmp	.+2      	; 0x31ca <procMessage81+0x12>
    31c8:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    31ca:	80 91 43 09 	lds	r24, 0x0943
    31ce:	89 35       	cpi	r24, 0x59	; 89
    31d0:	09 f4       	brne	.+2      	; 0x31d4 <procMessage81+0x1c>
    31d2:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    31d4:	80 91 44 09 	lds	r24, 0x0944
    31d8:	89 35       	cpi	r24, 0x59	; 89
    31da:	09 f4       	brne	.+2      	; 0x31de <procMessage81+0x26>
    31dc:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    31de:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    31e0:	80 91 45 09 	lds	r24, 0x0945
    31e4:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    31e6:	81 31       	cpi	r24, 0x11	; 17
    31e8:	08 f4       	brcc	.+2      	; 0x31ec <procMessage81+0x34>
    31ea:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    31ec:	c0 91 8d 01 	lds	r28, 0x018D
    31f0:	d0 91 8e 01 	lds	r29, 0x018E
    31f4:	20 e0       	ldi	r18, 0x00	; 0
    31f6:	30 e0       	ldi	r19, 0x00	; 0
    31f8:	0b c0       	rjmp	.+22     	; 0x3210 <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31fa:	f9 01       	movw	r30, r18
    31fc:	e4 51       	subi	r30, 0x14	; 20
    31fe:	fc 4f       	sbci	r31, 0xFC	; 252
    3200:	d9 01       	movw	r26, r18
    3202:	a3 5e       	subi	r26, 0xE3	; 227
    3204:	b6 4f       	sbci	r27, 0xF6	; 246
    3206:	9c 96       	adiw	r26, 0x2c	; 44
    3208:	8c 91       	ld	r24, X
    320a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    320c:	2f 5f       	subi	r18, 0xFF	; 255
    320e:	3f 4f       	sbci	r19, 0xFF	; 255
    3210:	2c 17       	cp	r18, r28
    3212:	3d 07       	cpc	r19, r29
    3214:	90 f3       	brcs	.-28     	; 0x31fa <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3216:	c4 51       	subi	r28, 0x14	; 20
    3218:	dc 4f       	sbci	r29, 0xFC	; 252
    321a:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    321c:	89 2f       	mov	r24, r25
    321e:	df 91       	pop	r29
    3220:	cf 91       	pop	r28
    3222:	08 95       	ret

00003224 <FillChar>:
	 if(CutType== 1) { uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    3224:	20 e0       	ldi	r18, 0x00	; 0
    3226:	30 e0       	ldi	r19, 0x00	; 0
    3228:	06 c0       	rjmp	.+12     	; 0x3236 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    322a:	fc 01       	movw	r30, r24
    322c:	e2 0f       	add	r30, r18
    322e:	f3 1f       	adc	r31, r19
    3230:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    3232:	2f 5f       	subi	r18, 0xFF	; 255
    3234:	3f 4f       	sbci	r19, 0xFF	; 255
    3236:	26 17       	cp	r18, r22
    3238:	37 07       	cpc	r19, r23
    323a:	b8 f3       	brcs	.-18     	; 0x322a <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    323c:	08 95       	ret

0000323e <ProcMessage91>:

void ProcMessage91(){
    323e:	20 e0       	ldi	r18, 0x00	; 0
    3240:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3242:	f9 01       	movw	r30, r18
    3244:	e9 57       	subi	r30, 0x79	; 121
    3246:	f3 4f       	sbci	r31, 0xF3	; 243
    3248:	d9 01       	movw	r26, r18
    324a:	a3 5e       	subi	r26, 0xE3	; 227
    324c:	b6 4f       	sbci	r27, 0xF6	; 246
    324e:	95 96       	adiw	r26, 0x25	; 37
    3250:	8c 91       	ld	r24, X
    3252:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3254:	2f 5f       	subi	r18, 0xFF	; 255
    3256:	3f 4f       	sbci	r19, 0xFF	; 255
    3258:	26 30       	cpi	r18, 0x06	; 6
    325a:	31 05       	cpc	r19, r1
    325c:	91 f7       	brne	.-28     	; 0x3242 <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    325e:	10 92 8d 0c 	sts	0x0C8D, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3262:	80 91 48 09 	lds	r24, 0x0948
    3266:	80 93 b9 07 	sts	0x07B9, r24
    326a:	80 91 49 09 	lds	r24, 0x0949
    326e:	80 93 ba 07 	sts	0x07BA, r24
	 }Dest[Length]=0;
    3272:	10 92 bb 07 	sts	0x07BB, r1
    3276:	20 e0       	ldi	r18, 0x00	; 0
    3278:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    327a:	f9 01       	movw	r30, r18
    327c:	e4 5f       	subi	r30, 0xF4	; 244
    327e:	f7 4f       	sbci	r31, 0xF7	; 247
    3280:	d9 01       	movw	r26, r18
    3282:	a3 5e       	subi	r26, 0xE3	; 227
    3284:	b6 4f       	sbci	r27, 0xF6	; 246
    3286:	9d 96       	adiw	r26, 0x2d	; 45
    3288:	8c 91       	ld	r24, X
    328a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    328c:	2f 5f       	subi	r18, 0xFF	; 255
    328e:	3f 4f       	sbci	r19, 0xFF	; 255
    3290:	2f 30       	cpi	r18, 0x0F	; 15
    3292:	31 05       	cpc	r19, r1
    3294:	91 f7       	brne	.-28     	; 0x327a <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3296:	10 92 1b 08 	sts	0x081B, r1
    329a:	20 e0       	ldi	r18, 0x00	; 0
    329c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    329e:	f9 01       	movw	r30, r18
    32a0:	e2 56       	subi	r30, 0x62	; 98
    32a2:	fa 4f       	sbci	r31, 0xFA	; 250
    32a4:	d9 01       	movw	r26, r18
    32a6:	a3 5e       	subi	r26, 0xE3	; 227
    32a8:	b6 4f       	sbci	r27, 0xF6	; 246
    32aa:	dc 96       	adiw	r26, 0x3c	; 60
    32ac:	8c 91       	ld	r24, X
    32ae:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    32b0:	2f 5f       	subi	r18, 0xFF	; 255
    32b2:	3f 4f       	sbci	r19, 0xFF	; 255
    32b4:	26 30       	cpi	r18, 0x06	; 6
    32b6:	31 05       	cpc	r19, r1
    32b8:	91 f7       	brne	.-28     	; 0x329e <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    32ba:	10 92 a4 05 	sts	0x05A4, r1
    32be:	20 e0       	ldi	r18, 0x00	; 0
    32c0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    32c2:	f9 01       	movw	r30, r18
    32c4:	eb 58       	subi	r30, 0x8B	; 139
    32c6:	fc 4f       	sbci	r31, 0xFC	; 252
    32c8:	d9 01       	movw	r26, r18
    32ca:	a1 5a       	subi	r26, 0xA1	; 161
    32cc:	b6 4f       	sbci	r27, 0xF6	; 246
    32ce:	8c 91       	ld	r24, X
    32d0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    32d2:	2f 5f       	subi	r18, 0xFF	; 255
    32d4:	3f 4f       	sbci	r19, 0xFF	; 255
    32d6:	28 30       	cpi	r18, 0x08	; 8
    32d8:	31 05       	cpc	r19, r1
    32da:	99 f7       	brne	.-26     	; 0x32c2 <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    32dc:	10 92 7d 03 	sts	0x037D, r1
    32e0:	20 e0       	ldi	r18, 0x00	; 0
    32e2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    32e4:	f9 01       	movw	r30, r18
    32e6:	ed 54       	subi	r30, 0x4D	; 77
    32e8:	f4 4f       	sbci	r31, 0xF4	; 244
    32ea:	d9 01       	movw	r26, r18
    32ec:	a9 59       	subi	r26, 0x99	; 153
    32ee:	b6 4f       	sbci	r27, 0xF6	; 246
    32f0:	8c 91       	ld	r24, X
    32f2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    32f4:	2f 5f       	subi	r18, 0xFF	; 255
    32f6:	3f 4f       	sbci	r19, 0xFF	; 255
    32f8:	28 30       	cpi	r18, 0x08	; 8
    32fa:	31 05       	cpc	r19, r1
    32fc:	99 f7       	brne	.-26     	; 0x32e4 <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    32fe:	10 92 bb 0b 	sts	0x0BBB, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3302:	80 91 6f 09 	lds	r24, 0x096F
    3306:	80 93 8a 03 	sts	0x038A, r24
	 }Dest[Length]=0;
    330a:	10 92 8b 03 	sts	0x038B, r1
    330e:	20 e0       	ldi	r18, 0x00	; 0
    3310:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3312:	f9 01       	movw	r30, r18
    3314:	e4 50       	subi	r30, 0x04	; 4
    3316:	fd 4f       	sbci	r31, 0xFD	; 253
    3318:	d9 01       	movw	r26, r18
    331a:	a0 59       	subi	r26, 0x90	; 144
    331c:	b6 4f       	sbci	r27, 0xF6	; 246
    331e:	8c 91       	ld	r24, X
    3320:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3322:	2f 5f       	subi	r18, 0xFF	; 255
    3324:	3f 4f       	sbci	r19, 0xFF	; 255
    3326:	29 30       	cpi	r18, 0x09	; 9
    3328:	31 05       	cpc	r19, r1
    332a:	99 f7       	brne	.-26     	; 0x3312 <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    332c:	10 92 05 03 	sts	0x0305, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    3330:	08 95       	ret

00003332 <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    3332:	1f 93       	push	r17
   if (STX==0x01){
    3334:	81 30       	cpi	r24, 0x01	; 1
    3336:	09 f0       	breq	.+2      	; 0x333a <IdentifyMessage+0x8>
    3338:	5f c0       	rjmp	.+190    	; 0x33f8 <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    333a:	6f 32       	cpi	r22, 0x2F	; 47
    333c:	71 05       	cpc	r23, r1
    333e:	21 f0       	breq	.+8      	; 0x3348 <IdentifyMessage+0x16>
    3340:	80 91 24 01 	lds	r24, 0x0124
    3344:	88 23       	and	r24, r24
    3346:	21 f4       	brne	.+8      	; 0x3350 <IdentifyMessage+0x1e>
    3348:	81 e0       	ldi	r24, 0x01	; 1
    334a:	80 93 9e 01 	sts	0x019E, r24
    334e:	4a c0       	rjmp	.+148    	; 0x33e4 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    3350:	6c 36       	cpi	r22, 0x6C	; 108
    3352:	71 05       	cpc	r23, r1
    3354:	11 f0       	breq	.+4      	; 0x335a <IdentifyMessage+0x28>
    3356:	89 30       	cpi	r24, 0x09	; 9
    3358:	21 f4       	brne	.+8      	; 0x3362 <IdentifyMessage+0x30>
    335a:	81 e0       	ldi	r24, 0x01	; 1
    335c:	80 93 a3 01 	sts	0x01A3, r24
    3360:	41 c0       	rjmp	.+130    	; 0x33e4 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    3362:	92 e0       	ldi	r25, 0x02	; 2
    3364:	67 36       	cpi	r22, 0x67	; 103
    3366:	79 07       	cpc	r23, r25
    3368:	11 f0       	breq	.+4      	; 0x336e <IdentifyMessage+0x3c>
    336a:	8b 30       	cpi	r24, 0x0B	; 11
    336c:	21 f4       	brne	.+8      	; 0x3376 <IdentifyMessage+0x44>
    336e:	81 e0       	ldi	r24, 0x01	; 1
    3370:	80 93 a0 01 	sts	0x01A0, r24
    3374:	37 c0       	rjmp	.+110    	; 0x33e4 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    3376:	61 39       	cpi	r22, 0x91	; 145
    3378:	71 05       	cpc	r23, r1
    337a:	11 f0       	breq	.+4      	; 0x3380 <IdentifyMessage+0x4e>
    337c:	87 31       	cpi	r24, 0x17	; 23
    337e:	21 f4       	brne	.+8      	; 0x3388 <IdentifyMessage+0x56>
    3380:	81 e0       	ldi	r24, 0x01	; 1
    3382:	80 93 a2 01 	sts	0x01A2, r24
    3386:	2e c0       	rjmp	.+92     	; 0x33e4 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    3388:	66 3e       	cpi	r22, 0xE6	; 230
    338a:	71 05       	cpc	r23, r1
    338c:	11 f0       	breq	.+4      	; 0x3392 <IdentifyMessage+0x60>
    338e:	89 33       	cpi	r24, 0x39	; 57
    3390:	21 f4       	brne	.+8      	; 0x339a <IdentifyMessage+0x68>
    3392:	81 e0       	ldi	r24, 0x01	; 1
    3394:	80 93 a5 01 	sts	0x01A5, r24
    3398:	25 c0       	rjmp	.+74     	; 0x33e4 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    339a:	91 e0       	ldi	r25, 0x01	; 1
    339c:	68 39       	cpi	r22, 0x98	; 152
    339e:	79 07       	cpc	r23, r25
    33a0:	11 f0       	breq	.+4      	; 0x33a6 <IdentifyMessage+0x74>
    33a2:	83 36       	cpi	r24, 0x63	; 99
    33a4:	21 f4       	brne	.+8      	; 0x33ae <IdentifyMessage+0x7c>
    33a6:	81 e0       	ldi	r24, 0x01	; 1
    33a8:	80 93 9f 01 	sts	0x019F, r24
    33ac:	1b c0       	rjmp	.+54     	; 0x33e4 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    33ae:	91 e0       	ldi	r25, 0x01	; 1
    33b0:	66 3b       	cpi	r22, 0xB6	; 182
    33b2:	79 07       	cpc	r23, r25
    33b4:	11 f0       	breq	.+4      	; 0x33ba <IdentifyMessage+0x88>
    33b6:	81 35       	cpi	r24, 0x51	; 81
    33b8:	21 f4       	brne	.+8      	; 0x33c2 <IdentifyMessage+0x90>
    33ba:	81 e0       	ldi	r24, 0x01	; 1
    33bc:	80 93 a6 01 	sts	0x01A6, r24
    33c0:	11 c0       	rjmp	.+34     	; 0x33e4 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    33c2:	6c 35       	cpi	r22, 0x5C	; 92
    33c4:	71 05       	cpc	r23, r1
    33c6:	11 f0       	breq	.+4      	; 0x33cc <IdentifyMessage+0x9a>
    33c8:	8b 35       	cpi	r24, 0x5B	; 91
    33ca:	21 f4       	brne	.+8      	; 0x33d4 <IdentifyMessage+0xa2>
    33cc:	81 e0       	ldi	r24, 0x01	; 1
    33ce:	80 93 a7 01 	sts	0x01A7, r24
    33d2:	08 c0       	rjmp	.+16     	; 0x33e4 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    33d4:	66 35       	cpi	r22, 0x56	; 86
    33d6:	71 05       	cpc	r23, r1
    33d8:	11 f0       	breq	.+4      	; 0x33de <IdentifyMessage+0xac>
    33da:	85 31       	cpi	r24, 0x15	; 21
    33dc:	19 f4       	brne	.+6      	; 0x33e4 <IdentifyMessage+0xb2>
    33de:	81 e0       	ldi	r24, 0x01	; 1
    33e0:	80 93 a1 01 	sts	0x01A1, r24
        //EDC AdvanZ Respond
		if (IsMessage91==True){
    33e4:	10 91 a7 01 	lds	r17, 0x01A7
    33e8:	11 30       	cpi	r17, 0x01	; 1
    33ea:	31 f4       	brne	.+12     	; 0x33f8 <IdentifyMessage+0xc6>
		    IsMessage91=False;
    33ec:	10 92 a7 01 	sts	0x01A7, r1
		    ProcMessage91();
    33f0:	0e 94 1f 19 	call	0x323e	; 0x323e <ProcMessage91>
			IsSendMessageEDC=True;
    33f4:	10 93 97 01 	sts	0x0197, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  uart_print(1,0,SerialSend);
	 }
}
    33f8:	1f 91       	pop	r17
    33fa:	08 95       	ret

000033fc <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    33fc:	fc 01       	movw	r30, r24
    33fe:	dc 01       	movw	r26, r24
    3400:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    3402:	90 e2       	ldi	r25, 0x20	; 32
    3404:	02 c0       	rjmp	.+4      	; 0x340a <Tab+0xe>
    3406:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    3408:	8f 5f       	subi	r24, 0xFF	; 255
    340a:	86 17       	cp	r24, r22
    340c:	e0 f3       	brcs	.-8      	; 0x3406 <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    340e:	e6 0f       	add	r30, r22
    3410:	f1 1d       	adc	r31, r1
    3412:	10 82       	st	Z, r1
}
    3414:	08 95       	ret

00003416 <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    3416:	dc 01       	movw	r26, r24
    3418:	20 e0       	ldi	r18, 0x00	; 0
    341a:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    341c:	9c 91       	ld	r25, X
    341e:	90 53       	subi	r25, 0x30	; 48
    3420:	9a 30       	cpi	r25, 0x0A	; 10
    3422:	08 f0       	brcs	.+2      	; 0x3426 <StrToRaw+0x10>
    3424:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    3426:	11 96       	adiw	r26, 0x01	; 1
    3428:	8c 91       	ld	r24, X
    342a:	11 97       	sbiw	r26, 0x01	; 1
    342c:	80 53       	subi	r24, 0x30	; 48
    342e:	8a 30       	cpi	r24, 0x0A	; 10
    3430:	08 f0       	brcs	.+2      	; 0x3434 <StrToRaw+0x1e>
    3432:	80 e0       	ldi	r24, 0x00	; 0
    3434:	fb 01       	movw	r30, r22
    3436:	e2 0f       	add	r30, r18
    3438:	f3 1f       	adc	r31, r19
    343a:	8f 70       	andi	r24, 0x0F	; 15
    343c:	92 95       	swap	r25
    343e:	90 7f       	andi	r25, 0xF0	; 240
    3440:	98 2b       	or	r25, r24
    3442:	90 83       	st	Z, r25
    3444:	2f 5f       	subi	r18, 0xFF	; 255
    3446:	3f 4f       	sbci	r19, 0xFF	; 255
    3448:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    344a:	26 30       	cpi	r18, 0x06	; 6
    344c:	31 05       	cpc	r19, r1
    344e:	31 f7       	brne	.-52     	; 0x341c <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    3450:	08 95       	ret

00003452 <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    3452:	cf 93       	push	r28
    3454:	df 93       	push	r29
    3456:	eb 01       	movw	r28, r22
    3458:	db 01       	movw	r26, r22
    345a:	20 e0       	ldi	r18, 0x00	; 0
    345c:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    345e:	fc 01       	movw	r30, r24
    3460:	e2 0f       	add	r30, r18
    3462:	f3 1f       	adc	r31, r19
    3464:	e0 81       	ld	r30, Z
    3466:	4e 2f       	mov	r20, r30
    3468:	42 95       	swap	r20
    346a:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    346c:	4a 30       	cpi	r20, 0x0A	; 10
    346e:	10 f0       	brcs	.+4      	; 0x3474 <RawToStr+0x22>
    3470:	40 e3       	ldi	r20, 0x30	; 48
    3472:	01 c0       	rjmp	.+2      	; 0x3476 <RawToStr+0x24>
	    Result='0'+X;
    3474:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    3476:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3478:	ea 30       	cpi	r30, 0x0A	; 10
    347a:	10 f0       	brcs	.+4      	; 0x3480 <RawToStr+0x2e>
    347c:	e0 e3       	ldi	r30, 0x30	; 48
    347e:	01 c0       	rjmp	.+2      	; 0x3482 <RawToStr+0x30>
	    Result='0'+X;
    3480:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    3482:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    3484:	11 96       	adiw	r26, 0x01	; 1
    3486:	ec 93       	st	X, r30
    3488:	11 97       	sbiw	r26, 0x01	; 1
    348a:	2f 5f       	subi	r18, 0xFF	; 255
    348c:	3f 4f       	sbci	r19, 0xFF	; 255
    348e:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    3490:	26 30       	cpi	r18, 0x06	; 6
    3492:	31 05       	cpc	r19, r1
    3494:	21 f7       	brne	.-56     	; 0x345e <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    3496:	1c 86       	std	Y+12, r1	; 0x0c
}
    3498:	df 91       	pop	r29
    349a:	cf 91       	pop	r28
    349c:	08 95       	ret

0000349e <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xC;//,xA,xB;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    349e:	86 17       	cp	r24, r22
    34a0:	08 f4       	brcc	.+2      	; 0x34a4 <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    34a2:	86 5f       	subi	r24, 0xF6	; 246
    34a4:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    34a6:	80 5d       	subi	r24, 0xD0	; 208
    34a8:	08 95       	ret

000034aa <CalcPlus>:

char CalcPlus(char A, char B){
    34aa:	80 56       	subi	r24, 0x60	; 96
    34ac:	86 0f       	add	r24, r22
    34ae:	6a e0       	ldi	r22, 0x0A	; 10
    34b0:	0e 94 91 b2 	call	0x16522	; 0x16522 <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    34b4:	89 2f       	mov	r24, r25
    34b6:	80 5d       	subi	r24, 0xD0	; 208
    34b8:	08 95       	ret

000034ba <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    34ba:	8a 30       	cpi	r24, 0x0A	; 10
    34bc:	10 f0       	brcs	.+4      	; 0x34c2 <Chr+0x8>
    34be:	80 e3       	ldi	r24, 0x30	; 48
    34c0:	08 95       	ret
	    Result='0'+X;
    34c2:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    34c4:	08 95       	ret

000034c6 <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    34c6:	80 53       	subi	r24, 0x30	; 48
    34c8:	8a 30       	cpi	r24, 0x0A	; 10
    34ca:	08 f0       	brcs	.+2      	; 0x34ce <Ord+0x8>
    34cc:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    34ce:	08 95       	ret

000034d0 <FTestCalculation>:
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
*/
}
    34d0:	08 95       	ret

000034d2 <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    34d2:	48 2f       	mov	r20, r24
    34d4:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    34d6:	18 16       	cp	r1, r24
    34d8:	64 f4       	brge	.+24     	; 0x34f2 <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    34da:	56 2f       	mov	r21, r22
    34dc:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    34de:	90 e2       	ldi	r25, 0x20	; 32
    34e0:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    34e2:	8a 2f       	mov	r24, r26
    34e4:	85 1b       	sub	r24, r21
    34e6:	84 17       	cp	r24, r20
    34e8:	d8 f3       	brcs	.-10     	; 0x34e0 <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    34ea:	e4 0f       	add	r30, r20
    34ec:	f1 1d       	adc	r31, r1
    34ee:	10 82       	st	Z, r1
    34f0:	08 95       	ret
     }else{
	 strTab[0]=' ';
    34f2:	80 e2       	ldi	r24, 0x20	; 32
    34f4:	80 83       	st	Z, r24
	 strTab[1]=0;
    34f6:	11 82       	std	Z+1, r1	; 0x01
    34f8:	08 95       	ret

000034fa <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    34fa:	86 30       	cpi	r24, 0x06	; 6
    34fc:	51 f1       	breq	.+84     	; 0x3552 <GetBorderValue+0x58>
    34fe:	87 30       	cpi	r24, 0x07	; 7
    3500:	70 f4       	brcc	.+28     	; 0x351e <GetBorderValue+0x24>
    3502:	83 30       	cpi	r24, 0x03	; 3
    3504:	11 f1       	breq	.+68     	; 0x354a <GetBorderValue+0x50>
    3506:	84 30       	cpi	r24, 0x04	; 4
    3508:	28 f4       	brcc	.+10     	; 0x3514 <GetBorderValue+0x1a>
    350a:	81 30       	cpi	r24, 0x01	; 1
    350c:	c1 f0       	breq	.+48     	; 0x353e <GetBorderValue+0x44>
    350e:	82 30       	cpi	r24, 0x02	; 2
    3510:	c1 f4       	brne	.+48     	; 0x3542 <GetBorderValue+0x48>
    3512:	19 c0       	rjmp	.+50     	; 0x3546 <GetBorderValue+0x4c>
    3514:	84 30       	cpi	r24, 0x04	; 4
    3516:	d9 f0       	breq	.+54     	; 0x354e <GetBorderValue+0x54>
    3518:	85 30       	cpi	r24, 0x05	; 5
    351a:	99 f4       	brne	.+38     	; 0x3542 <GetBorderValue+0x48>
    351c:	22 c0       	rjmp	.+68     	; 0x3562 <GetBorderValue+0x68>
    351e:	89 30       	cpi	r24, 0x09	; 9
    3520:	f1 f0       	breq	.+60     	; 0x355e <GetBorderValue+0x64>
    3522:	8a 30       	cpi	r24, 0x0A	; 10
    3524:	28 f4       	brcc	.+10     	; 0x3530 <GetBorderValue+0x36>
    3526:	87 30       	cpi	r24, 0x07	; 7
    3528:	b1 f0       	breq	.+44     	; 0x3556 <GetBorderValue+0x5c>
    352a:	88 30       	cpi	r24, 0x08	; 8
    352c:	51 f4       	brne	.+20     	; 0x3542 <GetBorderValue+0x48>
    352e:	15 c0       	rjmp	.+42     	; 0x355a <GetBorderValue+0x60>
    3530:	8b 30       	cpi	r24, 0x0B	; 11
    3532:	d9 f0       	breq	.+54     	; 0x356a <GetBorderValue+0x70>
    3534:	8b 30       	cpi	r24, 0x0B	; 11
    3536:	b8 f0       	brcs	.+46     	; 0x3566 <GetBorderValue+0x6c>
    3538:	8c 30       	cpi	r24, 0x0C	; 12
    353a:	19 f4       	brne	.+6      	; 0x3542 <GetBorderValue+0x48>
    353c:	18 c0       	rjmp	.+48     	; 0x356e <GetBorderValue+0x74>
    353e:	8a ed       	ldi	r24, 0xDA	; 218
    3540:	08 95       	ret
    3542:	80 e0       	ldi	r24, 0x00	; 0
    3544:	08 95       	ret
    3546:	82 ec       	ldi	r24, 0xC2	; 194
    3548:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    354a:	8f eb       	ldi	r24, 0xBF	; 191
    354c:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    354e:	83 ec       	ldi	r24, 0xC3	; 195
    3550:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    3552:	84 eb       	ldi	r24, 0xB4	; 180
    3554:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    3556:	80 ec       	ldi	r24, 0xC0	; 192
    3558:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    355a:	81 ec       	ldi	r24, 0xC1	; 193
    355c:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    355e:	89 ed       	ldi	r24, 0xD9	; 217
    3560:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    3562:	85 ec       	ldi	r24, 0xC5	; 197
    3564:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    3566:	83 eb       	ldi	r24, 0xB3	; 179
    3568:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    356a:	84 ec       	ldi	r24, 0xC4	; 196
    356c:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    356e:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    3570:	08 95       	ret

00003572 <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    3572:	bf 92       	push	r11
    3574:	cf 92       	push	r12
    3576:	df 92       	push	r13
    3578:	ef 92       	push	r14
    357a:	ff 92       	push	r15
    357c:	0f 93       	push	r16
    357e:	1f 93       	push	r17
    3580:	cf 93       	push	r28
    3582:	df 93       	push	r29
    3584:	b8 2e       	mov	r11, r24
    3586:	8b 01       	movw	r16, r22
    3588:	e4 2e       	mov	r14, r20
    358a:	69 01       	movw	r12, r18
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    358c:	f9 01       	movw	r30, r18
    358e:	c0 81       	ld	r28, Z
    3590:	d1 81       	ldd	r29, Z+1	; 0x01
    3592:	0c 0f       	add	r16, r28
    3594:	1d 1f       	adc	r17, r29
    3596:	ff 24       	eor	r15, r15
    3598:	07 c0       	rjmp	.+14     	; 0x35a8 <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    359a:	8b 2d       	mov	r24, r11
    359c:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <GetBorderValue>
    35a0:	f8 01       	movw	r30, r16
    35a2:	81 93       	st	Z+, r24
    35a4:	8f 01       	movw	r16, r30
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    35a6:	f3 94       	inc	r15
    35a8:	fe 14       	cp	r15, r14
    35aa:	b8 f3       	brcs	.-18     	; 0x359a <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    35ac:	ce 0d       	add	r28, r14
    35ae:	d1 1d       	adc	r29, r1
    35b0:	f6 01       	movw	r30, r12
    35b2:	d1 83       	std	Z+1, r29	; 0x01
    35b4:	c0 83       	st	Z, r28
}
    35b6:	df 91       	pop	r29
    35b8:	cf 91       	pop	r28
    35ba:	1f 91       	pop	r17
    35bc:	0f 91       	pop	r16
    35be:	ff 90       	pop	r15
    35c0:	ef 90       	pop	r14
    35c2:	df 90       	pop	r13
    35c4:	cf 90       	pop	r12
    35c6:	bf 90       	pop	r11
    35c8:	08 95       	ret

000035ca <TestUserInput>:
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
  */
}
    35ca:	08 95       	ret

000035cc <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    35cc:	08 95       	ret

000035ce <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    35ce:	08 95       	ret

000035d0 <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    35d0:	08 95       	ret

000035d2 <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    35d2:	08 95       	ret

000035d4 <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    35d4:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    35d6:	28 2f       	mov	r18, r24
    35d8:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    35da:	82 2f       	mov	r24, r18
    35dc:	86 95       	lsr	r24
    35de:	86 95       	lsr	r24
    35e0:	86 95       	lsr	r24
    35e2:	a8 2f       	mov	r26, r24
    35e4:	b0 e0       	ldi	r27, 0x00	; 0
    35e6:	ac 52       	subi	r26, 0x2C	; 44
    35e8:	b4 4f       	sbci	r27, 0xF4	; 244
    35ea:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    35ec:	62 30       	cpi	r22, 0x02	; 2
    35ee:	59 f4       	brne	.+22     	; 0x3606 <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    35f0:	27 70       	andi	r18, 0x07	; 7
    35f2:	81 e0       	ldi	r24, 0x01	; 1
    35f4:	90 e0       	ldi	r25, 0x00	; 0
    35f6:	02 c0       	rjmp	.+4      	; 0x35fc <SetIncomingTransStatus+0x28>
    35f8:	88 0f       	add	r24, r24
    35fa:	99 1f       	adc	r25, r25
    35fc:	2a 95       	dec	r18
    35fe:	e2 f7       	brpl	.-8      	; 0x35f8 <SetIncomingTransStatus+0x24>
    3600:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    3602:	4c 93       	st	X, r20
    3604:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    3606:	63 30       	cpi	r22, 0x03	; 3
    3608:	b1 f4       	brne	.+44     	; 0x3636 <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    360a:	27 70       	andi	r18, 0x07	; 7
    360c:	8e ef       	ldi	r24, 0xFE	; 254
    360e:	90 e0       	ldi	r25, 0x00	; 0
    3610:	01 c0       	rjmp	.+2      	; 0x3614 <SetIncomingTransStatus+0x40>
    3612:	88 0f       	add	r24, r24
    3614:	2a 95       	dec	r18
    3616:	ea f7       	brpl	.-6      	; 0x3612 <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    3618:	e6 95       	lsr	r30
    361a:	e6 95       	lsr	r30
    361c:	e6 95       	lsr	r30
    361e:	f0 e0       	ldi	r31, 0x00	; 0
    3620:	ec 52       	subi	r30, 0x2C	; 44
    3622:	f4 4f       	sbci	r31, 0xF4	; 244
    3624:	28 2f       	mov	r18, r24
    3626:	30 e0       	ldi	r19, 0x00	; 0
    3628:	20 95       	com	r18
    362a:	30 95       	com	r19
    362c:	35 95       	asr	r19
    362e:	27 95       	ror	r18
    3630:	82 2b       	or	r24, r18
    3632:	84 23       	and	r24, r20
    3634:	80 83       	st	Z, r24
    3636:	08 95       	ret

00003638 <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    3638:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    363a:	e8 2f       	mov	r30, r24
    363c:	e6 95       	lsr	r30
    363e:	e6 95       	lsr	r30
    3640:	e6 95       	lsr	r30
    3642:	f0 e0       	ldi	r31, 0x00	; 0
    3644:	ec 52       	subi	r30, 0x2C	; 44
    3646:	f4 4f       	sbci	r31, 0xF4	; 244
    3648:	90 81       	ld	r25, Z
    364a:	29 2f       	mov	r18, r25
    364c:	30 e0       	ldi	r19, 0x00	; 0
    364e:	87 70       	andi	r24, 0x07	; 7
    3650:	02 c0       	rjmp	.+4      	; 0x3656 <GetIncomingTransStatus+0x1e>
    3652:	35 95       	asr	r19
    3654:	27 95       	ror	r18
    3656:	8a 95       	dec	r24
    3658:	e2 f7       	brpl	.-8      	; 0x3652 <GetIncomingTransStatus+0x1a>
    365a:	21 30       	cpi	r18, 0x01	; 1
    365c:	31 05       	cpc	r19, r1
    365e:	11 f4       	brne	.+4      	; 0x3664 <GetIncomingTransStatus+0x2c>
    3660:	82 e0       	ldi	r24, 0x02	; 2
    3662:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    3664:	23 2b       	or	r18, r19
    3666:	11 f4       	brne	.+4      	; 0x366c <GetIncomingTransStatus+0x34>
    3668:	83 e0       	ldi	r24, 0x03	; 3
    366a:	08 95       	ret
    366c:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    366e:	08 95       	ret

00003670 <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    3670:	df 93       	push	r29
    3672:	cf 93       	push	r28
    3674:	00 d0       	rcall	.+0      	; 0x3676 <SetDispenser+0x6>
    3676:	00 d0       	rcall	.+0      	; 0x3678 <SetDispenser+0x8>
    3678:	0f 92       	push	r0
    367a:	cd b7       	in	r28, 0x3d	; 61
    367c:	de b7       	in	r29, 0x3e	; 62
    367e:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3680:	e1 99       	sbic	0x1c, 1	; 28
    3682:	fe cf       	rjmp	.-4      	; 0x3680 <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3684:	27 e3       	ldi	r18, 0x37	; 55
    3686:	31 e0       	ldi	r19, 0x01	; 1
    3688:	3f bb       	out	0x1f, r19	; 31
    368a:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    368c:	e0 9a       	sbi	0x1c, 0	; 28
    368e:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    3690:	89 17       	cp	r24, r25
    3692:	51 f0       	breq	.+20     	; 0x36a8 <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3694:	e1 99       	sbic	0x1c, 1	; 28
    3696:	fe cf       	rjmp	.-4      	; 0x3694 <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3698:	3f bb       	out	0x1f, r19	; 31
    369a:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    369c:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    369e:	0f b6       	in	r0, 0x3f	; 63
    36a0:	f8 94       	cli
    36a2:	e2 9a       	sbi	0x1c, 2	; 28
    36a4:	e1 9a       	sbi	0x1c, 1	; 28
    36a6:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    36a8:	91 30       	cpi	r25, 0x01	; 1
    36aa:	19 f0       	breq	.+6      	; 0x36b2 <SetDispenser+0x42>
    36ac:	92 30       	cpi	r25, 0x02	; 2
    36ae:	71 f4       	brne	.+28     	; 0x36cc <SetDispenser+0x5c>
    36b0:	08 c0       	rjmp	.+16     	; 0x36c2 <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    36b2:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    36b4:	83 e0       	ldi	r24, 0x03	; 3
    36b6:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    36b8:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    36ba:	82 e0       	ldi	r24, 0x02	; 2
    36bc:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    36be:	1d 82       	std	Y+5, r1	; 0x05
    36c0:	05 c0       	rjmp	.+10     	; 0x36cc <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    36c2:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    36c4:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    36c6:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    36c8:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    36ca:	9d 83       	std	Y+5, r25	; 0x05
    36cc:	29 e3       	ldi	r18, 0x39	; 57
    36ce:	30 e0       	ldi	r19, 0x00	; 0
    36d0:	fe 01       	movw	r30, r28
    36d2:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    36d4:	e1 99       	sbic	0x1c, 1	; 28
    36d6:	fe cf       	rjmp	.-4      	; 0x36d4 <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    36d8:	3f bb       	out	0x1f, r19	; 31
    36da:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    36dc:	e0 9a       	sbi	0x1c, 0	; 28
    36de:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    36e0:	90 81       	ld	r25, Z
    36e2:	89 17       	cp	r24, r25
    36e4:	51 f0       	breq	.+20     	; 0x36fa <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    36e6:	e1 99       	sbic	0x1c, 1	; 28
    36e8:	fe cf       	rjmp	.-4      	; 0x36e6 <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    36ea:	3f bb       	out	0x1f, r19	; 31
    36ec:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    36ee:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    36f0:	0f b6       	in	r0, 0x3f	; 63
    36f2:	f8 94       	cli
    36f4:	e2 9a       	sbi	0x1c, 2	; 28
    36f6:	e1 9a       	sbi	0x1c, 1	; 28
    36f8:	0f be       	out	0x3f, r0	; 63
    36fa:	2f 5f       	subi	r18, 0xFF	; 255
    36fc:	3f 4f       	sbci	r19, 0xFF	; 255
    36fe:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    3700:	80 e0       	ldi	r24, 0x00	; 0
    3702:	2e 33       	cpi	r18, 0x3E	; 62
    3704:	38 07       	cpc	r19, r24
    3706:	31 f7       	brne	.-52     	; 0x36d4 <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    3708:	0f 90       	pop	r0
    370a:	0f 90       	pop	r0
    370c:	0f 90       	pop	r0
    370e:	0f 90       	pop	r0
    3710:	0f 90       	pop	r0
    3712:	cf 91       	pop	r28
    3714:	df 91       	pop	r29
    3716:	08 95       	ret

00003718 <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    3718:	df 93       	push	r29
    371a:	cf 93       	push	r28
    371c:	cd b7       	in	r28, 0x3d	; 61
    371e:	de b7       	in	r29, 0x3e	; 62
    3720:	62 97       	sbiw	r28, 0x12	; 18
    3722:	0f b6       	in	r0, 0x3f	; 63
    3724:	f8 94       	cli
    3726:	de bf       	out	0x3e, r29	; 62
    3728:	0f be       	out	0x3f, r0	; 63
    372a:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    372c:	20 91 ba 03 	lds	r18, 0x03BA
    3730:	2f 83       	std	Y+7, r18	; 0x07
    3732:	20 91 bb 03 	lds	r18, 0x03BB
    3736:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    3738:	20 91 bd 03 	lds	r18, 0x03BD
    373c:	2c 83       	std	Y+4, r18	; 0x04
    373e:	20 91 be 03 	lds	r18, 0x03BE
    3742:	2d 83       	std	Y+5, r18	; 0x05
    3744:	20 91 c0 03 	lds	r18, 0x03C0
    3748:	29 83       	std	Y+1, r18	; 0x01
    374a:	20 91 c1 03 	lds	r18, 0x03C1
    374e:	2a 83       	std	Y+2, r18	; 0x02
    3750:	20 91 74 08 	lds	r18, 0x0874
    3754:	2a 87       	std	Y+10, r18	; 0x0a
    3756:	20 91 75 08 	lds	r18, 0x0875
    375a:	2b 87       	std	Y+11, r18	; 0x0b
    375c:	20 91 77 08 	lds	r18, 0x0877
    3760:	2d 87       	std	Y+13, r18	; 0x0d
    3762:	20 91 78 08 	lds	r18, 0x0878
    3766:	2e 87       	std	Y+14, r18	; 0x0e
    3768:	20 91 7a 08 	lds	r18, 0x087A
    376c:	28 8b       	std	Y+16, r18	; 0x10
    376e:	20 91 7b 08 	lds	r18, 0x087B
    3772:	29 8b       	std	Y+17, r18	; 0x11
    3774:	1a 8a       	std	Y+18, r1	; 0x12
    3776:	1f 86       	std	Y+15, r1	; 0x0f
    3778:	1c 86       	std	Y+12, r1	; 0x0c
    377a:	1b 82       	std	Y+3, r1	; 0x03
    377c:	1e 82       	std	Y+6, r1	; 0x06
    377e:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    3780:	2d b7       	in	r18, 0x3d	; 61
    3782:	3e b7       	in	r19, 0x3e	; 62
    3784:	20 51       	subi	r18, 0x10	; 16
    3786:	30 40       	sbci	r19, 0x00	; 0
    3788:	0f b6       	in	r0, 0x3f	; 63
    378a:	f8 94       	cli
    378c:	3e bf       	out	0x3e, r19	; 62
    378e:	0f be       	out	0x3f, r0	; 63
    3790:	2d bf       	out	0x3d, r18	; 61
    3792:	ed b7       	in	r30, 0x3d	; 61
    3794:	fe b7       	in	r31, 0x3e	; 62
    3796:	31 96       	adiw	r30, 0x01	; 1
    3798:	ad b7       	in	r26, 0x3d	; 61
    379a:	be b7       	in	r27, 0x3e	; 62
    379c:	12 96       	adiw	r26, 0x02	; 2
    379e:	9c 93       	st	X, r25
    37a0:	8e 93       	st	-X, r24
    37a2:	11 97       	sbiw	r26, 0x01	; 1
    37a4:	85 e3       	ldi	r24, 0x35	; 53
    37a6:	95 e0       	ldi	r25, 0x05	; 5
    37a8:	93 83       	std	Z+3, r25	; 0x03
    37aa:	82 83       	std	Z+2, r24	; 0x02
    37ac:	ce 01       	movw	r24, r28
    37ae:	01 96       	adiw	r24, 0x01	; 1
    37b0:	95 83       	std	Z+5, r25	; 0x05
    37b2:	84 83       	std	Z+4, r24	; 0x04
    37b4:	ce 01       	movw	r24, r28
    37b6:	04 96       	adiw	r24, 0x04	; 4
    37b8:	97 83       	std	Z+7, r25	; 0x07
    37ba:	86 83       	std	Z+6, r24	; 0x06
    37bc:	ce 01       	movw	r24, r28
    37be:	07 96       	adiw	r24, 0x07	; 7
    37c0:	91 87       	std	Z+9, r25	; 0x09
    37c2:	80 87       	std	Z+8, r24	; 0x08
    37c4:	ce 01       	movw	r24, r28
    37c6:	0a 96       	adiw	r24, 0x0a	; 10
    37c8:	93 87       	std	Z+11, r25	; 0x0b
    37ca:	82 87       	std	Z+10, r24	; 0x0a
    37cc:	ce 01       	movw	r24, r28
    37ce:	0d 96       	adiw	r24, 0x0d	; 13
    37d0:	95 87       	std	Z+13, r25	; 0x0d
    37d2:	84 87       	std	Z+12, r24	; 0x0c
    37d4:	ce 01       	movw	r24, r28
    37d6:	40 96       	adiw	r24, 0x10	; 16
    37d8:	97 87       	std	Z+15, r25	; 0x0f
    37da:	86 87       	std	Z+14, r24	; 0x0e
    37dc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    37e0:	2d b7       	in	r18, 0x3d	; 61
    37e2:	3e b7       	in	r19, 0x3e	; 62
    37e4:	20 5f       	subi	r18, 0xF0	; 240
    37e6:	3f 4f       	sbci	r19, 0xFF	; 255
    37e8:	0f b6       	in	r0, 0x3f	; 63
    37ea:	f8 94       	cli
    37ec:	3e bf       	out	0x3e, r19	; 62
    37ee:	0f be       	out	0x3f, r0	; 63
    37f0:	2d bf       	out	0x3d, r18	; 61
}
    37f2:	62 96       	adiw	r28, 0x12	; 18
    37f4:	0f b6       	in	r0, 0x3f	; 63
    37f6:	f8 94       	cli
    37f8:	de bf       	out	0x3e, r29	; 62
    37fa:	0f be       	out	0x3f, r0	; 63
    37fc:	cd bf       	out	0x3d, r28	; 61
    37fe:	cf 91       	pop	r28
    3800:	df 91       	pop	r29
    3802:	08 95       	ret

00003804 <leadingZero>:
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    3804:	00 d0       	rcall	.+0      	; 0x3806 <leadingZero+0x2>
    3806:	00 d0       	rcall	.+0      	; 0x3808 <leadingZero+0x4>
    3808:	00 d0       	rcall	.+0      	; 0x380a <leadingZero+0x6>
    380a:	ed b7       	in	r30, 0x3d	; 61
    380c:	fe b7       	in	r31, 0x3e	; 62
    380e:	31 96       	adiw	r30, 0x01	; 1
    3810:	ad b7       	in	r26, 0x3d	; 61
    3812:	be b7       	in	r27, 0x3e	; 62
    3814:	12 96       	adiw	r26, 0x02	; 2
    3816:	7c 93       	st	X, r23
    3818:	6e 93       	st	-X, r22
    381a:	11 97       	sbiw	r26, 0x01	; 1
    381c:	29 ee       	ldi	r18, 0xE9	; 233
    381e:	3e e0       	ldi	r19, 0x0E	; 14
    3820:	33 83       	std	Z+3, r19	; 0x03
    3822:	22 83       	std	Z+2, r18	; 0x02
    3824:	84 83       	std	Z+4, r24	; 0x04
    3826:	15 82       	std	Z+5, r1	; 0x05
    3828:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    382c:	8d b7       	in	r24, 0x3d	; 61
    382e:	9e b7       	in	r25, 0x3e	; 62
    3830:	06 96       	adiw	r24, 0x06	; 6
    3832:	0f b6       	in	r0, 0x3f	; 63
    3834:	f8 94       	cli
    3836:	9e bf       	out	0x3e, r25	; 62
    3838:	0f be       	out	0x3f, r0	; 63
    383a:	8d bf       	out	0x3d, r24	; 61

}
    383c:	08 95       	ret

0000383e <MasterReset>:
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}

void MasterReset(){
    383e:	df 92       	push	r13
    3840:	ef 92       	push	r14
    3842:	ff 92       	push	r15
    3844:	0f 93       	push	r16
    3846:	1f 93       	push	r17
    3848:	df 93       	push	r29
    384a:	cf 93       	push	r28
    384c:	cd b7       	in	r28, 0x3d	; 61
    384e:	de b7       	in	r29, 0x3e	; 62
    3850:	ec 97       	sbiw	r28, 0x3c	; 60
    3852:	0f b6       	in	r0, 0x3f	; 63
    3854:	f8 94       	cli
    3856:	de bf       	out	0x3e, r29	; 62
    3858:	0f be       	out	0x3f, r0	; 63
    385a:	cd bf       	out	0x3d, r28	; 61
     char strEEP[50];
	 char xArray[10];
     //Restore All Stored EEPROM data to the Default
     sprintf_P(strEEP,PSTR("  "));
    385c:	00 d0       	rcall	.+0      	; 0x385e <MasterReset+0x20>
    385e:	00 d0       	rcall	.+0      	; 0x3860 <MasterReset+0x22>
    3860:	8e 01       	movw	r16, r28
    3862:	05 5f       	subi	r16, 0xF5	; 245
    3864:	1f 4f       	sbci	r17, 0xFF	; 255
    3866:	ed b7       	in	r30, 0x3d	; 61
    3868:	fe b7       	in	r31, 0x3e	; 62
    386a:	12 83       	std	Z+2, r17	; 0x02
    386c:	01 83       	std	Z+1, r16	; 0x01
    386e:	88 e1       	ldi	r24, 0x18	; 24
    3870:	95 e0       	ldi	r25, 0x05	; 5
    3872:	94 83       	std	Z+4, r25	; 0x04
    3874:	83 83       	std	Z+3, r24	; 0x03
    3876:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    387a:	0f 90       	pop	r0
    387c:	0f 90       	pop	r0
    387e:	0f 90       	pop	r0
    3880:	0f 90       	pop	r0
    3882:	85 e1       	ldi	r24, 0x15	; 21
    3884:	90 e0       	ldi	r25, 0x00	; 0
    3886:	b8 01       	movw	r22, r16
    3888:	43 e1       	ldi	r20, 0x13	; 19
    388a:	50 e0       	ldi	r21, 0x00	; 0
    388c:	2a ed       	ldi	r18, 0xDA	; 218
    388e:	33 e1       	ldi	r19, 0x13	; 19
    3890:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefOperatorName, sizeof(DefOperatorName));

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=70; 
    3894:	50 ec       	ldi	r21, 0xC0	; 192
    3896:	d5 2e       	mov	r13, r21
    3898:	d9 82       	std	Y+1, r13	; 0x01
    389a:	48 ea       	ldi	r20, 0xA8	; 168
    389c:	e4 2e       	mov	r14, r20
    389e:	ea 82       	std	Y+2, r14	; 0x02
    38a0:	30 e1       	ldi	r19, 0x10	; 16
    38a2:	f3 2e       	mov	r15, r19
    38a4:	fb 82       	std	Y+3, r15	; 0x03
    38a6:	86 e4       	ldi	r24, 0x46	; 70
    38a8:	8c 83       	std	Y+4, r24	; 0x04
    38aa:	88 e2       	ldi	r24, 0x28	; 40
    38ac:	90 e0       	ldi	r25, 0x00	; 0
    38ae:	8e 01       	movw	r16, r28
    38b0:	0f 5f       	subi	r16, 0xFF	; 255
    38b2:	1f 4f       	sbci	r17, 0xFF	; 255
    38b4:	b8 01       	movw	r22, r16
    38b6:	44 e0       	ldi	r20, 0x04	; 4
    38b8:	50 e0       	ldi	r21, 0x00	; 0
    38ba:	2a ed       	ldi	r18, 0xDA	; 218
    38bc:	33 e1       	ldi	r19, 0x13	; 19
    38be:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefClientIP, 4);

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=180; 
    38c2:	d9 82       	std	Y+1, r13	; 0x01
    38c4:	ea 82       	std	Y+2, r14	; 0x02
    38c6:	fb 82       	std	Y+3, r15	; 0x03
    38c8:	84 eb       	ldi	r24, 0xB4	; 180
    38ca:	8c 83       	std	Y+4, r24	; 0x04
    38cc:	8c e2       	ldi	r24, 0x2C	; 44
    38ce:	90 e0       	ldi	r25, 0x00	; 0
    38d0:	b8 01       	movw	r22, r16
    38d2:	44 e0       	ldi	r20, 0x04	; 4
    38d4:	50 e0       	ldi	r21, 0x00	; 0
    38d6:	2a ed       	ldi	r18, 0xDA	; 218
    38d8:	33 e1       	ldi	r19, 0x13	; 19
    38da:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    38de:	e1 99       	sbic	0x1c, 1	; 28
    38e0:	fe cf       	rjmp	.-4      	; 0x38de <MasterReset+0xa0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38e2:	80 e3       	ldi	r24, 0x30	; 48
    38e4:	90 e0       	ldi	r25, 0x00	; 0
    38e6:	9f bb       	out	0x1f, r25	; 31
    38e8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    38ea:	81 e0       	ldi	r24, 0x01	; 1
    38ec:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    38ee:	0f b6       	in	r0, 0x3f	; 63
    38f0:	f8 94       	cli
    38f2:	e2 9a       	sbi	0x1c, 2	; 28
    38f4:	e1 9a       	sbi	0x1c, 1	; 28
    38f6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    38f8:	e1 99       	sbic	0x1c, 1	; 28
    38fa:	fe cf       	rjmp	.-4      	; 0x38f8 <MasterReset+0xba>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38fc:	81 e3       	ldi	r24, 0x31	; 49
    38fe:	90 e0       	ldi	r25, 0x00	; 0
    3900:	9f bb       	out	0x1f, r25	; 31
    3902:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3904:	87 e0       	ldi	r24, 0x07	; 7
    3906:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3908:	0f b6       	in	r0, 0x3f	; 63
    390a:	f8 94       	cli
    390c:	e2 9a       	sbi	0x1c, 2	; 28
    390e:	e1 9a       	sbi	0x1c, 1	; 28
    3910:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3912:	e1 99       	sbic	0x1c, 1	; 28
    3914:	fe cf       	rjmp	.-4      	; 0x3912 <MasterReset+0xd4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3916:	82 e3       	ldi	r24, 0x32	; 50
    3918:	90 e0       	ldi	r25, 0x00	; 0
    391a:	9f bb       	out	0x1f, r25	; 31
    391c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    391e:	85 e0       	ldi	r24, 0x05	; 5
    3920:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3922:	0f b6       	in	r0, 0x3f	; 63
    3924:	f8 94       	cli
    3926:	e2 9a       	sbi	0x1c, 2	; 28
    3928:	e1 9a       	sbi	0x1c, 1	; 28
    392a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    392c:	e1 99       	sbic	0x1c, 1	; 28
    392e:	fe cf       	rjmp	.-4      	; 0x392c <MasterReset+0xee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3930:	83 e3       	ldi	r24, 0x33	; 51
    3932:	90 e0       	ldi	r25, 0x00	; 0
    3934:	9f bb       	out	0x1f, r25	; 31
    3936:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3938:	82 e0       	ldi	r24, 0x02	; 2
    393a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    393c:	0f b6       	in	r0, 0x3f	; 63
    393e:	f8 94       	cli
    3940:	e2 9a       	sbi	0x1c, 2	; 28
    3942:	e1 9a       	sbi	0x1c, 1	; 28
    3944:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3946:	e1 99       	sbic	0x1c, 1	; 28
    3948:	fe cf       	rjmp	.-4      	; 0x3946 <MasterReset+0x108>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    394a:	84 e3       	ldi	r24, 0x34	; 52
    394c:	90 e0       	ldi	r25, 0x00	; 0
    394e:	9f bb       	out	0x1f, r25	; 31
    3950:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3952:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3954:	0f b6       	in	r0, 0x3f	; 63
    3956:	f8 94       	cli
    3958:	e2 9a       	sbi	0x1c, 2	; 28
    395a:	e1 9a       	sbi	0x1c, 1	; 28
    395c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    395e:	e1 99       	sbic	0x1c, 1	; 28
    3960:	fe cf       	rjmp	.-4      	; 0x395e <MasterReset+0x120>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3962:	85 e3       	ldi	r24, 0x35	; 53
    3964:	90 e0       	ldi	r25, 0x00	; 0
    3966:	9f bb       	out	0x1f, r25	; 31
    3968:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    396a:	83 e0       	ldi	r24, 0x03	; 3
    396c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    396e:	0f b6       	in	r0, 0x3f	; 63
    3970:	f8 94       	cli
    3972:	e2 9a       	sbi	0x1c, 2	; 28
    3974:	e1 9a       	sbi	0x1c, 1	; 28
    3976:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3978:	e1 99       	sbic	0x1c, 1	; 28
    397a:	fe cf       	rjmp	.-4      	; 0x3978 <MasterReset+0x13a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    397c:	86 e3       	ldi	r24, 0x36	; 54
    397e:	90 e0       	ldi	r25, 0x00	; 0
    3980:	9f bb       	out	0x1f, r25	; 31
    3982:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3984:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3986:	0f b6       	in	r0, 0x3f	; 63
    3988:	f8 94       	cli
    398a:	e2 9a       	sbi	0x1c, 2	; 28
    398c:	e1 9a       	sbi	0x1c, 1	; 28
    398e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3990:	e1 99       	sbic	0x1c, 1	; 28
    3992:	fe cf       	rjmp	.-4      	; 0x3990 <MasterReset+0x152>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3994:	87 e3       	ldi	r24, 0x37	; 55
    3996:	90 e0       	ldi	r25, 0x00	; 0
    3998:	9f bb       	out	0x1f, r25	; 31
    399a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    399c:	81 e0       	ldi	r24, 0x01	; 1
    399e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    39a0:	0f b6       	in	r0, 0x3f	; 63
    39a2:	f8 94       	cli
    39a4:	e2 9a       	sbi	0x1c, 2	; 28
    39a6:	e1 9a       	sbi	0x1c, 1	; 28
    39a8:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39aa:	e1 99       	sbic	0x1c, 1	; 28
    39ac:	fe cf       	rjmp	.-4      	; 0x39aa <MasterReset+0x16c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39ae:	88 e3       	ldi	r24, 0x38	; 56
    39b0:	90 e0       	ldi	r25, 0x00	; 0
    39b2:	9f bb       	out	0x1f, r25	; 31
    39b4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39b6:	81 e0       	ldi	r24, 0x01	; 1
    39b8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    39ba:	0f b6       	in	r0, 0x3f	; 63
    39bc:	f8 94       	cli
    39be:	e2 9a       	sbi	0x1c, 2	; 28
    39c0:	e1 9a       	sbi	0x1c, 1	; 28
    39c2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39c4:	e1 99       	sbic	0x1c, 1	; 28
    39c6:	fe cf       	rjmp	.-4      	; 0x39c4 <MasterReset+0x186>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39c8:	89 e3       	ldi	r24, 0x39	; 57
    39ca:	90 e0       	ldi	r25, 0x00	; 0
    39cc:	9f bb       	out	0x1f, r25	; 31
    39ce:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39d0:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    39d2:	0f b6       	in	r0, 0x3f	; 63
    39d4:	f8 94       	cli
    39d6:	e2 9a       	sbi	0x1c, 2	; 28
    39d8:	e1 9a       	sbi	0x1c, 1	; 28
    39da:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39dc:	e1 99       	sbic	0x1c, 1	; 28
    39de:	fe cf       	rjmp	.-4      	; 0x39dc <MasterReset+0x19e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39e0:	8a e3       	ldi	r24, 0x3A	; 58
    39e2:	90 e0       	ldi	r25, 0x00	; 0
    39e4:	9f bb       	out	0x1f, r25	; 31
    39e6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39e8:	83 e0       	ldi	r24, 0x03	; 3
    39ea:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    39ec:	0f b6       	in	r0, 0x3f	; 63
    39ee:	f8 94       	cli
    39f0:	e2 9a       	sbi	0x1c, 2	; 28
    39f2:	e1 9a       	sbi	0x1c, 1	; 28
    39f4:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39f6:	e1 99       	sbic	0x1c, 1	; 28
    39f8:	fe cf       	rjmp	.-4      	; 0x39f6 <MasterReset+0x1b8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39fa:	8b e3       	ldi	r24, 0x3B	; 59
    39fc:	90 e0       	ldi	r25, 0x00	; 0
    39fe:	9f bb       	out	0x1f, r25	; 31
    3a00:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a02:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3a04:	0f b6       	in	r0, 0x3f	; 63
    3a06:	f8 94       	cli
    3a08:	e2 9a       	sbi	0x1c, 2	; 28
    3a0a:	e1 9a       	sbi	0x1c, 1	; 28
    3a0c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a0e:	e1 99       	sbic	0x1c, 1	; 28
    3a10:	fe cf       	rjmp	.-4      	; 0x3a0e <MasterReset+0x1d0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a12:	8c e3       	ldi	r24, 0x3C	; 60
    3a14:	90 e0       	ldi	r25, 0x00	; 0
    3a16:	9f bb       	out	0x1f, r25	; 31
    3a18:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a1a:	82 e0       	ldi	r24, 0x02	; 2
    3a1c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3a1e:	0f b6       	in	r0, 0x3f	; 63
    3a20:	f8 94       	cli
    3a22:	e2 9a       	sbi	0x1c, 2	; 28
    3a24:	e1 9a       	sbi	0x1c, 1	; 28
    3a26:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a28:	e1 99       	sbic	0x1c, 1	; 28
    3a2a:	fe cf       	rjmp	.-4      	; 0x3a28 <MasterReset+0x1ea>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a2c:	8d e3       	ldi	r24, 0x3D	; 61
    3a2e:	90 e0       	ldi	r25, 0x00	; 0
    3a30:	9f bb       	out	0x1f, r25	; 31
    3a32:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a34:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3a36:	0f b6       	in	r0, 0x3f	; 63
    3a38:	f8 94       	cli
    3a3a:	e2 9a       	sbi	0x1c, 2	; 28
    3a3c:	e1 9a       	sbi	0x1c, 1	; 28
    3a3e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a40:	e1 99       	sbic	0x1c, 1	; 28
    3a42:	fe cf       	rjmp	.-4      	; 0x3a40 <MasterReset+0x202>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a44:	8e e3       	ldi	r24, 0x3E	; 62
    3a46:	90 e0       	ldi	r25, 0x00	; 0
    3a48:	9f bb       	out	0x1f, r25	; 31
    3a4a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a4c:	8c e2       	ldi	r24, 0x2C	; 44
    3a4e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3a50:	0f b6       	in	r0, 0x3f	; 63
    3a52:	f8 94       	cli
    3a54:	e2 9a       	sbi	0x1c, 2	; 28
    3a56:	e1 9a       	sbi	0x1c, 1	; 28
    3a58:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a5a:	e1 99       	sbic	0x1c, 1	; 28
    3a5c:	fe cf       	rjmp	.-4      	; 0x3a5a <MasterReset+0x21c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a5e:	8f e3       	ldi	r24, 0x3F	; 63
    3a60:	90 e0       	ldi	r25, 0x00	; 0
    3a62:	9f bb       	out	0x1f, r25	; 31
    3a64:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a66:	9e e2       	ldi	r25, 0x2E	; 46
    3a68:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3a6a:	0f b6       	in	r0, 0x3f	; 63
    3a6c:	f8 94       	cli
    3a6e:	e2 9a       	sbi	0x1c, 2	; 28
    3a70:	e1 9a       	sbi	0x1c, 1	; 28
    3a72:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefDecimalTotalVolume,2);
	 eeprom_write_byte(&DefDecimalTotalMoney,0);
	 eeprom_write_byte(&DefDecimalMark,',');
	 eeprom_write_byte(&DefCurrencyMark,'.');

	 xArray[0]=',';	 xArray[1]='.'; 	 xArray[2]=' ';	 xArray[3]='/';  xArray[4]='-'; 
    3a74:	8c e2       	ldi	r24, 0x2C	; 44
    3a76:	89 83       	std	Y+1, r24	; 0x01
    3a78:	9a 83       	std	Y+2, r25	; 0x02
    3a7a:	80 e2       	ldi	r24, 0x20	; 32
    3a7c:	8b 83       	std	Y+3, r24	; 0x03
    3a7e:	8f e2       	ldi	r24, 0x2F	; 47
    3a80:	8c 83       	std	Y+4, r24	; 0x04
    3a82:	8d e2       	ldi	r24, 0x2D	; 45
    3a84:	8d 83       	std	Y+5, r24	; 0x05
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3a86:	80 e4       	ldi	r24, 0x40	; 64
    3a88:	90 e0       	ldi	r25, 0x00	; 0
    3a8a:	8e 01       	movw	r16, r28
    3a8c:	0f 5f       	subi	r16, 0xFF	; 255
    3a8e:	1f 4f       	sbci	r17, 0xFF	; 255
    3a90:	b8 01       	movw	r22, r16
    3a92:	45 e0       	ldi	r20, 0x05	; 5
    3a94:	50 e0       	ldi	r21, 0x00	; 0
    3a96:	2a ed       	ldi	r18, 0xDA	; 218
    3a98:	33 e1       	ldi	r19, 0x13	; 19
    3a9a:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefMarkMap, 5);

	 xArray[0]=1;	 xArray[1]=2; 	 xArray[2]=0;	 xArray[3]=0; xArray[4]=0;	 xArray[5]=0; xArray[6]=0;	 	 
    3a9e:	ee 24       	eor	r14, r14
    3aa0:	e3 94       	inc	r14
    3aa2:	e9 82       	std	Y+1, r14	; 0x01
    3aa4:	22 e0       	ldi	r18, 0x02	; 2
    3aa6:	f2 2e       	mov	r15, r18
    3aa8:	fa 82       	std	Y+2, r15	; 0x02
    3aaa:	1b 82       	std	Y+3, r1	; 0x03
    3aac:	1c 82       	std	Y+4, r1	; 0x04
    3aae:	1d 82       	std	Y+5, r1	; 0x05
    3ab0:	1e 82       	std	Y+6, r1	; 0x06
    3ab2:	1f 82       	std	Y+7, r1	; 0x07
    3ab4:	85 e4       	ldi	r24, 0x45	; 69
    3ab6:	90 e0       	ldi	r25, 0x00	; 0
    3ab8:	b8 01       	movw	r22, r16
    3aba:	48 e0       	ldi	r20, 0x08	; 8
    3abc:	50 e0       	ldi	r21, 0x00	; 0
    3abe:	2a ed       	ldi	r18, 0xDA	; 218
    3ac0:	33 e1       	ldi	r19, 0x13	; 19
    3ac2:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpMap, 8);
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpLabel, 8);

	 xArray[0]=1;	 xArray[1]=2; 	 xArray[2]=0;	 xArray[3]=0; xArray[4]=0;	 xArray[5]=0; 
    3ac6:	8d e4       	ldi	r24, 0x4D	; 77
    3ac8:	90 e0       	ldi	r25, 0x00	; 0
    3aca:	b8 01       	movw	r22, r16
    3acc:	48 e0       	ldi	r20, 0x08	; 8
    3ace:	50 e0       	ldi	r21, 0x00	; 0
    3ad0:	2a ed       	ldi	r18, 0xDA	; 218
    3ad2:	33 e1       	ldi	r19, 0x13	; 19
    3ad4:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
    3ad8:	e9 82       	std	Y+1, r14	; 0x01
    3ada:	fa 82       	std	Y+2, r15	; 0x02
    3adc:	1b 82       	std	Y+3, r1	; 0x03
    3ade:	1c 82       	std	Y+4, r1	; 0x04
    3ae0:	1d 82       	std	Y+5, r1	; 0x05
    3ae2:	1e 82       	std	Y+6, r1	; 0x06
    3ae4:	85 e5       	ldi	r24, 0x55	; 85
    3ae6:	90 e0       	ldi	r25, 0x00	; 0
    3ae8:	b8 01       	movw	r22, r16
    3aea:	46 e0       	ldi	r20, 0x06	; 6
    3aec:	50 e0       	ldi	r21, 0x00	; 0
    3aee:	2a ed       	ldi	r18, 0xDA	; 218
    3af0:	33 e1       	ldi	r19, 0x13	; 19
    3af2:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefNozzleMap[0], 6);
	 eeprom_write_block((const void*) &xArray, (void*) &DefNozzleMap[1], 6);

	 sprintf_P(strEEP,PSTR("6500"));
    3af6:	8b e5       	ldi	r24, 0x5B	; 91
    3af8:	90 e0       	ldi	r25, 0x00	; 0
    3afa:	b8 01       	movw	r22, r16
    3afc:	46 e0       	ldi	r20, 0x06	; 6
    3afe:	50 e0       	ldi	r21, 0x00	; 0
    3b00:	2a ed       	ldi	r18, 0xDA	; 218
    3b02:	33 e1       	ldi	r19, 0x13	; 19
    3b04:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
    3b08:	00 d0       	rcall	.+0      	; 0x3b0a <MasterReset+0x2cc>
    3b0a:	00 d0       	rcall	.+0      	; 0x3b0c <MasterReset+0x2ce>
    3b0c:	8e 01       	movw	r16, r28
    3b0e:	05 5f       	subi	r16, 0xF5	; 245
    3b10:	1f 4f       	sbci	r17, 0xFF	; 255
    3b12:	ed b7       	in	r30, 0x3d	; 61
    3b14:	fe b7       	in	r31, 0x3e	; 62
    3b16:	12 83       	std	Z+2, r17	; 0x02
    3b18:	01 83       	std	Z+1, r16	; 0x01
    3b1a:	83 e1       	ldi	r24, 0x13	; 19
    3b1c:	95 e0       	ldi	r25, 0x05	; 5
    3b1e:	94 83       	std	Z+4, r25	; 0x04
    3b20:	83 83       	std	Z+3, r24	; 0x03
    3b22:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3b26:	0f 90       	pop	r0
    3b28:	0f 90       	pop	r0
    3b2a:	0f 90       	pop	r0
    3b2c:	0f 90       	pop	r0
    3b2e:	85 e8       	ldi	r24, 0x85	; 133
    3b30:	90 e0       	ldi	r25, 0x00	; 0
    3b32:	b8 01       	movw	r22, r16
    3b34:	49 e0       	ldi	r20, 0x09	; 9
    3b36:	50 e0       	ldi	r21, 0x00	; 0
    3b38:	2a ed       	ldi	r18, 0xDA	; 218
    3b3a:	33 e1       	ldi	r19, 0x13	; 19
    3b3c:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductPrice[0], sizeof(DefProductPrice[0]));
	 sprintf_P(strEEP,PSTR("7250"));
    3b40:	00 d0       	rcall	.+0      	; 0x3b42 <MasterReset+0x304>
    3b42:	00 d0       	rcall	.+0      	; 0x3b44 <MasterReset+0x306>
    3b44:	ed b7       	in	r30, 0x3d	; 61
    3b46:	fe b7       	in	r31, 0x3e	; 62
    3b48:	12 83       	std	Z+2, r17	; 0x02
    3b4a:	01 83       	std	Z+1, r16	; 0x01
    3b4c:	8e e0       	ldi	r24, 0x0E	; 14
    3b4e:	95 e0       	ldi	r25, 0x05	; 5
    3b50:	94 83       	std	Z+4, r25	; 0x04
    3b52:	83 83       	std	Z+3, r24	; 0x03
    3b54:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3b58:	0f 90       	pop	r0
    3b5a:	0f 90       	pop	r0
    3b5c:	0f 90       	pop	r0
    3b5e:	0f 90       	pop	r0
    3b60:	8e e8       	ldi	r24, 0x8E	; 142
    3b62:	90 e0       	ldi	r25, 0x00	; 0
    3b64:	b8 01       	movw	r22, r16
    3b66:	49 e0       	ldi	r20, 0x09	; 9
    3b68:	50 e0       	ldi	r21, 0x00	; 0
    3b6a:	2a ed       	ldi	r18, 0xDA	; 218
    3b6c:	33 e1       	ldi	r19, 0x13	; 19
    3b6e:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductPrice[1], sizeof(DefProductPrice[1]));
	 sprintf_P(strEEP,PSTR("4500"));
    3b72:	00 d0       	rcall	.+0      	; 0x3b74 <MasterReset+0x336>
    3b74:	00 d0       	rcall	.+0      	; 0x3b76 <MasterReset+0x338>
    3b76:	ed b7       	in	r30, 0x3d	; 61
    3b78:	fe b7       	in	r31, 0x3e	; 62
    3b7a:	12 83       	std	Z+2, r17	; 0x02
    3b7c:	01 83       	std	Z+1, r16	; 0x01
    3b7e:	89 e0       	ldi	r24, 0x09	; 9
    3b80:	95 e0       	ldi	r25, 0x05	; 5
    3b82:	94 83       	std	Z+4, r25	; 0x04
    3b84:	83 83       	std	Z+3, r24	; 0x03
    3b86:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3b8a:	0f 90       	pop	r0
    3b8c:	0f 90       	pop	r0
    3b8e:	0f 90       	pop	r0
    3b90:	0f 90       	pop	r0
    3b92:	87 e9       	ldi	r24, 0x97	; 151
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	b8 01       	movw	r22, r16
    3b98:	49 e0       	ldi	r20, 0x09	; 9
    3b9a:	50 e0       	ldi	r21, 0x00	; 0
    3b9c:	2a ed       	ldi	r18, 0xDA	; 218
    3b9e:	33 e1       	ldi	r19, 0x13	; 19
    3ba0:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductPrice[2], sizeof(DefProductPrice[2]));
	 sprintf_P(strEEP,PSTR("6500"));
    3ba4:	00 d0       	rcall	.+0      	; 0x3ba6 <MasterReset+0x368>
    3ba6:	00 d0       	rcall	.+0      	; 0x3ba8 <MasterReset+0x36a>
    3ba8:	ed b7       	in	r30, 0x3d	; 61
    3baa:	fe b7       	in	r31, 0x3e	; 62
    3bac:	12 83       	std	Z+2, r17	; 0x02
    3bae:	01 83       	std	Z+1, r16	; 0x01
    3bb0:	84 e0       	ldi	r24, 0x04	; 4
    3bb2:	95 e0       	ldi	r25, 0x05	; 5
    3bb4:	94 83       	std	Z+4, r25	; 0x04
    3bb6:	83 83       	std	Z+3, r24	; 0x03
    3bb8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3bbc:	0f 90       	pop	r0
    3bbe:	0f 90       	pop	r0
    3bc0:	0f 90       	pop	r0
    3bc2:	0f 90       	pop	r0
    3bc4:	80 ea       	ldi	r24, 0xA0	; 160
    3bc6:	90 e0       	ldi	r25, 0x00	; 0
    3bc8:	b8 01       	movw	r22, r16
    3bca:	49 e0       	ldi	r20, 0x09	; 9
    3bcc:	50 e0       	ldi	r21, 0x00	; 0
    3bce:	2a ed       	ldi	r18, 0xDA	; 218
    3bd0:	33 e1       	ldi	r19, 0x13	; 19
    3bd2:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductPrice[3], sizeof(DefProductPrice[3]));
     sprintf_P(strEEP,PSTR("4500"));
    3bd6:	00 d0       	rcall	.+0      	; 0x3bd8 <MasterReset+0x39a>
    3bd8:	00 d0       	rcall	.+0      	; 0x3bda <MasterReset+0x39c>
    3bda:	ed b7       	in	r30, 0x3d	; 61
    3bdc:	fe b7       	in	r31, 0x3e	; 62
    3bde:	12 83       	std	Z+2, r17	; 0x02
    3be0:	01 83       	std	Z+1, r16	; 0x01
    3be2:	8f ef       	ldi	r24, 0xFF	; 255
    3be4:	94 e0       	ldi	r25, 0x04	; 4
    3be6:	94 83       	std	Z+4, r25	; 0x04
    3be8:	83 83       	std	Z+3, r24	; 0x03
    3bea:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3bee:	0f 90       	pop	r0
    3bf0:	0f 90       	pop	r0
    3bf2:	0f 90       	pop	r0
    3bf4:	0f 90       	pop	r0
    3bf6:	89 ea       	ldi	r24, 0xA9	; 169
    3bf8:	90 e0       	ldi	r25, 0x00	; 0
    3bfa:	b8 01       	movw	r22, r16
    3bfc:	49 e0       	ldi	r20, 0x09	; 9
    3bfe:	50 e0       	ldi	r21, 0x00	; 0
    3c00:	2a ed       	ldi	r18, 0xDA	; 218
    3c02:	33 e1       	ldi	r19, 0x13	; 19
    3c04:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductPrice[4], sizeof(DefProductPrice[4]));
	 sprintf_P(strEEP,PSTR("6500"));
    3c08:	00 d0       	rcall	.+0      	; 0x3c0a <MasterReset+0x3cc>
    3c0a:	00 d0       	rcall	.+0      	; 0x3c0c <MasterReset+0x3ce>
    3c0c:	ed b7       	in	r30, 0x3d	; 61
    3c0e:	fe b7       	in	r31, 0x3e	; 62
    3c10:	12 83       	std	Z+2, r17	; 0x02
    3c12:	01 83       	std	Z+1, r16	; 0x01
    3c14:	8a ef       	ldi	r24, 0xFA	; 250
    3c16:	94 e0       	ldi	r25, 0x04	; 4
    3c18:	94 83       	std	Z+4, r25	; 0x04
    3c1a:	83 83       	std	Z+3, r24	; 0x03
    3c1c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3c20:	0f 90       	pop	r0
    3c22:	0f 90       	pop	r0
    3c24:	0f 90       	pop	r0
    3c26:	0f 90       	pop	r0
    3c28:	82 eb       	ldi	r24, 0xB2	; 178
    3c2a:	90 e0       	ldi	r25, 0x00	; 0
    3c2c:	b8 01       	movw	r22, r16
    3c2e:	49 e0       	ldi	r20, 0x09	; 9
    3c30:	50 e0       	ldi	r21, 0x00	; 0
    3c32:	2a ed       	ldi	r18, 0xDA	; 218
    3c34:	33 e1       	ldi	r19, 0x13	; 19
    3c36:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductPrice[5], sizeof(DefProductPrice[5]));

	 sprintf_P(strEEP,PSTR("Pert+   "));
    3c3a:	00 d0       	rcall	.+0      	; 0x3c3c <MasterReset+0x3fe>
    3c3c:	00 d0       	rcall	.+0      	; 0x3c3e <MasterReset+0x400>
    3c3e:	ed b7       	in	r30, 0x3d	; 61
    3c40:	fe b7       	in	r31, 0x3e	; 62
    3c42:	12 83       	std	Z+2, r17	; 0x02
    3c44:	01 83       	std	Z+1, r16	; 0x01
    3c46:	81 ef       	ldi	r24, 0xF1	; 241
    3c48:	94 e0       	ldi	r25, 0x04	; 4
    3c4a:	94 83       	std	Z+4, r25	; 0x04
    3c4c:	83 83       	std	Z+3, r24	; 0x03
    3c4e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3c52:	0f 90       	pop	r0
    3c54:	0f 90       	pop	r0
    3c56:	0f 90       	pop	r0
    3c58:	0f 90       	pop	r0
    3c5a:	8b eb       	ldi	r24, 0xBB	; 187
    3c5c:	90 e0       	ldi	r25, 0x00	; 0
    3c5e:	b8 01       	movw	r22, r16
    3c60:	4d e0       	ldi	r20, 0x0D	; 13
    3c62:	50 e0       	ldi	r21, 0x00	; 0
    3c64:	2a ed       	ldi	r18, 0xDA	; 218
    3c66:	33 e1       	ldi	r19, 0x13	; 19
    3c68:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductName[0], sizeof(DefProductName[0]));
	 sprintf_P(strEEP,PSTR("Pertamax"));
    3c6c:	00 d0       	rcall	.+0      	; 0x3c6e <MasterReset+0x430>
    3c6e:	00 d0       	rcall	.+0      	; 0x3c70 <MasterReset+0x432>
    3c70:	ed b7       	in	r30, 0x3d	; 61
    3c72:	fe b7       	in	r31, 0x3e	; 62
    3c74:	12 83       	std	Z+2, r17	; 0x02
    3c76:	01 83       	std	Z+1, r16	; 0x01
    3c78:	88 ee       	ldi	r24, 0xE8	; 232
    3c7a:	94 e0       	ldi	r25, 0x04	; 4
    3c7c:	94 83       	std	Z+4, r25	; 0x04
    3c7e:	83 83       	std	Z+3, r24	; 0x03
    3c80:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3c84:	0f 90       	pop	r0
    3c86:	0f 90       	pop	r0
    3c88:	0f 90       	pop	r0
    3c8a:	0f 90       	pop	r0
    3c8c:	88 ec       	ldi	r24, 0xC8	; 200
    3c8e:	90 e0       	ldi	r25, 0x00	; 0
    3c90:	b8 01       	movw	r22, r16
    3c92:	4d e0       	ldi	r20, 0x0D	; 13
    3c94:	50 e0       	ldi	r21, 0x00	; 0
    3c96:	2a ed       	ldi	r18, 0xDA	; 218
    3c98:	33 e1       	ldi	r19, 0x13	; 19
    3c9a:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductName[1], sizeof(DefProductName[1]));
     sprintf_P(strEEP,PSTR("Premium "));
    3c9e:	00 d0       	rcall	.+0      	; 0x3ca0 <MasterReset+0x462>
    3ca0:	00 d0       	rcall	.+0      	; 0x3ca2 <MasterReset+0x464>
    3ca2:	ed b7       	in	r30, 0x3d	; 61
    3ca4:	fe b7       	in	r31, 0x3e	; 62
    3ca6:	12 83       	std	Z+2, r17	; 0x02
    3ca8:	01 83       	std	Z+1, r16	; 0x01
    3caa:	8f ed       	ldi	r24, 0xDF	; 223
    3cac:	94 e0       	ldi	r25, 0x04	; 4
    3cae:	94 83       	std	Z+4, r25	; 0x04
    3cb0:	83 83       	std	Z+3, r24	; 0x03
    3cb2:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3cb6:	0f 90       	pop	r0
    3cb8:	0f 90       	pop	r0
    3cba:	0f 90       	pop	r0
    3cbc:	0f 90       	pop	r0
    3cbe:	85 ed       	ldi	r24, 0xD5	; 213
    3cc0:	90 e0       	ldi	r25, 0x00	; 0
    3cc2:	b8 01       	movw	r22, r16
    3cc4:	4d e0       	ldi	r20, 0x0D	; 13
    3cc6:	50 e0       	ldi	r21, 0x00	; 0
    3cc8:	2a ed       	ldi	r18, 0xDA	; 218
    3cca:	33 e1       	ldi	r19, 0x13	; 19
    3ccc:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductName[2], sizeof(DefProductName[2]));
     sprintf_P(strEEP,PSTR("Solar   "));
    3cd0:	00 d0       	rcall	.+0      	; 0x3cd2 <MasterReset+0x494>
    3cd2:	00 d0       	rcall	.+0      	; 0x3cd4 <MasterReset+0x496>
    3cd4:	ed b7       	in	r30, 0x3d	; 61
    3cd6:	fe b7       	in	r31, 0x3e	; 62
    3cd8:	12 83       	std	Z+2, r17	; 0x02
    3cda:	01 83       	std	Z+1, r16	; 0x01
    3cdc:	86 ed       	ldi	r24, 0xD6	; 214
    3cde:	94 e0       	ldi	r25, 0x04	; 4
    3ce0:	94 83       	std	Z+4, r25	; 0x04
    3ce2:	83 83       	std	Z+3, r24	; 0x03
    3ce4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3ce8:	0f 90       	pop	r0
    3cea:	0f 90       	pop	r0
    3cec:	0f 90       	pop	r0
    3cee:	0f 90       	pop	r0
    3cf0:	82 ee       	ldi	r24, 0xE2	; 226
    3cf2:	90 e0       	ldi	r25, 0x00	; 0
    3cf4:	b8 01       	movw	r22, r16
    3cf6:	4d e0       	ldi	r20, 0x0D	; 13
    3cf8:	50 e0       	ldi	r21, 0x00	; 0
    3cfa:	2a ed       	ldi	r18, 0xDA	; 218
    3cfc:	33 e1       	ldi	r19, 0x13	; 19
    3cfe:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductName[3], sizeof(DefProductName[3]));
     sprintf_P(strEEP,PSTR("BioSolr "));
    3d02:	00 d0       	rcall	.+0      	; 0x3d04 <MasterReset+0x4c6>
    3d04:	00 d0       	rcall	.+0      	; 0x3d06 <MasterReset+0x4c8>
    3d06:	ed b7       	in	r30, 0x3d	; 61
    3d08:	fe b7       	in	r31, 0x3e	; 62
    3d0a:	12 83       	std	Z+2, r17	; 0x02
    3d0c:	01 83       	std	Z+1, r16	; 0x01
    3d0e:	8d ec       	ldi	r24, 0xCD	; 205
    3d10:	94 e0       	ldi	r25, 0x04	; 4
    3d12:	94 83       	std	Z+4, r25	; 0x04
    3d14:	83 83       	std	Z+3, r24	; 0x03
    3d16:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3d1a:	0f 90       	pop	r0
    3d1c:	0f 90       	pop	r0
    3d1e:	0f 90       	pop	r0
    3d20:	0f 90       	pop	r0
    3d22:	8f ee       	ldi	r24, 0xEF	; 239
    3d24:	90 e0       	ldi	r25, 0x00	; 0
    3d26:	b8 01       	movw	r22, r16
    3d28:	4d e0       	ldi	r20, 0x0D	; 13
    3d2a:	50 e0       	ldi	r21, 0x00	; 0
    3d2c:	2a ed       	ldi	r18, 0xDA	; 218
    3d2e:	33 e1       	ldi	r19, 0x13	; 19
    3d30:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductName[4], sizeof(DefProductName[4]));
     sprintf_P(strEEP,PSTR("Diesel  "));
    3d34:	00 d0       	rcall	.+0      	; 0x3d36 <MasterReset+0x4f8>
    3d36:	00 d0       	rcall	.+0      	; 0x3d38 <MasterReset+0x4fa>
    3d38:	ed b7       	in	r30, 0x3d	; 61
    3d3a:	fe b7       	in	r31, 0x3e	; 62
    3d3c:	12 83       	std	Z+2, r17	; 0x02
    3d3e:	01 83       	std	Z+1, r16	; 0x01
    3d40:	84 ec       	ldi	r24, 0xC4	; 196
    3d42:	94 e0       	ldi	r25, 0x04	; 4
    3d44:	94 83       	std	Z+4, r25	; 0x04
    3d46:	83 83       	std	Z+3, r24	; 0x03
    3d48:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3d4c:	0f 90       	pop	r0
    3d4e:	0f 90       	pop	r0
    3d50:	0f 90       	pop	r0
    3d52:	0f 90       	pop	r0
    3d54:	8c ef       	ldi	r24, 0xFC	; 252
    3d56:	90 e0       	ldi	r25, 0x00	; 0
    3d58:	b8 01       	movw	r22, r16
    3d5a:	4d e0       	ldi	r20, 0x0D	; 13
    3d5c:	50 e0       	ldi	r21, 0x00	; 0
    3d5e:	2a ed       	ldi	r18, 0xDA	; 218
    3d60:	33 e1       	ldi	r19, 0x13	; 19
    3d62:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefProductName[5], sizeof(DefProductName[5]));

	 sprintf_P(strEEP,PSTR("BCA"));
    3d66:	00 d0       	rcall	.+0      	; 0x3d68 <MasterReset+0x52a>
    3d68:	00 d0       	rcall	.+0      	; 0x3d6a <MasterReset+0x52c>
    3d6a:	ed b7       	in	r30, 0x3d	; 61
    3d6c:	fe b7       	in	r31, 0x3e	; 62
    3d6e:	12 83       	std	Z+2, r17	; 0x02
    3d70:	01 83       	std	Z+1, r16	; 0x01
    3d72:	80 ec       	ldi	r24, 0xC0	; 192
    3d74:	94 e0       	ldi	r25, 0x04	; 4
    3d76:	94 83       	std	Z+4, r25	; 0x04
    3d78:	83 83       	std	Z+3, r24	; 0x03
    3d7a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3d7e:	0f 90       	pop	r0
    3d80:	0f 90       	pop	r0
    3d82:	0f 90       	pop	r0
    3d84:	0f 90       	pop	r0
    3d86:	89 e0       	ldi	r24, 0x09	; 9
    3d88:	91 e0       	ldi	r25, 0x01	; 1
    3d8a:	b8 01       	movw	r22, r16
    3d8c:	4b e0       	ldi	r20, 0x0B	; 11
    3d8e:	50 e0       	ldi	r21, 0x00	; 0
    3d90:	2a ed       	ldi	r18, 0xDA	; 218
    3d92:	33 e1       	ldi	r19, 0x13	; 19
    3d94:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefBankName[0], sizeof(DefBankName[0]));
	 sprintf_P(strEEP,PSTR("Mandiri"));
    3d98:	00 d0       	rcall	.+0      	; 0x3d9a <MasterReset+0x55c>
    3d9a:	00 d0       	rcall	.+0      	; 0x3d9c <MasterReset+0x55e>
    3d9c:	ed b7       	in	r30, 0x3d	; 61
    3d9e:	fe b7       	in	r31, 0x3e	; 62
    3da0:	12 83       	std	Z+2, r17	; 0x02
    3da2:	01 83       	std	Z+1, r16	; 0x01
    3da4:	88 eb       	ldi	r24, 0xB8	; 184
    3da6:	94 e0       	ldi	r25, 0x04	; 4
    3da8:	94 83       	std	Z+4, r25	; 0x04
    3daa:	83 83       	std	Z+3, r24	; 0x03
    3dac:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3db0:	0f 90       	pop	r0
    3db2:	0f 90       	pop	r0
    3db4:	0f 90       	pop	r0
    3db6:	0f 90       	pop	r0
    3db8:	84 e1       	ldi	r24, 0x14	; 20
    3dba:	91 e0       	ldi	r25, 0x01	; 1
    3dbc:	b8 01       	movw	r22, r16
    3dbe:	4b e0       	ldi	r20, 0x0B	; 11
    3dc0:	50 e0       	ldi	r21, 0x00	; 0
    3dc2:	2a ed       	ldi	r18, 0xDA	; 218
    3dc4:	33 e1       	ldi	r19, 0x13	; 19
    3dc6:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefBankName[1], sizeof(DefBankName[1]));
	 sprintf_P(strEEP,PSTR("BNI"));
    3dca:	00 d0       	rcall	.+0      	; 0x3dcc <MasterReset+0x58e>
    3dcc:	00 d0       	rcall	.+0      	; 0x3dce <MasterReset+0x590>
    3dce:	ed b7       	in	r30, 0x3d	; 61
    3dd0:	fe b7       	in	r31, 0x3e	; 62
    3dd2:	12 83       	std	Z+2, r17	; 0x02
    3dd4:	01 83       	std	Z+1, r16	; 0x01
    3dd6:	84 eb       	ldi	r24, 0xB4	; 180
    3dd8:	94 e0       	ldi	r25, 0x04	; 4
    3dda:	94 83       	std	Z+4, r25	; 0x04
    3ddc:	83 83       	std	Z+3, r24	; 0x03
    3dde:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3de2:	0f 90       	pop	r0
    3de4:	0f 90       	pop	r0
    3de6:	0f 90       	pop	r0
    3de8:	0f 90       	pop	r0
    3dea:	8f e1       	ldi	r24, 0x1F	; 31
    3dec:	91 e0       	ldi	r25, 0x01	; 1
    3dee:	b8 01       	movw	r22, r16
    3df0:	4b e0       	ldi	r20, 0x0B	; 11
    3df2:	50 e0       	ldi	r21, 0x00	; 0
    3df4:	2a ed       	ldi	r18, 0xDA	; 218
    3df6:	33 e1       	ldi	r19, 0x13	; 19
    3df8:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefBankName[2], sizeof(DefBankName[2]));
	 sprintf_P(strEEP,PSTR("BRI"));
    3dfc:	00 d0       	rcall	.+0      	; 0x3dfe <MasterReset+0x5c0>
    3dfe:	00 d0       	rcall	.+0      	; 0x3e00 <MasterReset+0x5c2>
    3e00:	ed b7       	in	r30, 0x3d	; 61
    3e02:	fe b7       	in	r31, 0x3e	; 62
    3e04:	12 83       	std	Z+2, r17	; 0x02
    3e06:	01 83       	std	Z+1, r16	; 0x01
    3e08:	80 eb       	ldi	r24, 0xB0	; 176
    3e0a:	94 e0       	ldi	r25, 0x04	; 4
    3e0c:	94 83       	std	Z+4, r25	; 0x04
    3e0e:	83 83       	std	Z+3, r24	; 0x03
    3e10:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    3e14:	0f 90       	pop	r0
    3e16:	0f 90       	pop	r0
    3e18:	0f 90       	pop	r0
    3e1a:	0f 90       	pop	r0
    3e1c:	8a e2       	ldi	r24, 0x2A	; 42
    3e1e:	91 e0       	ldi	r25, 0x01	; 1
    3e20:	b8 01       	movw	r22, r16
    3e22:	4b e0       	ldi	r20, 0x0B	; 11
    3e24:	50 e0       	ldi	r21, 0x00	; 0
    3e26:	2a ed       	ldi	r18, 0xDA	; 218
    3e28:	33 e1       	ldi	r19, 0x13	; 19
    3e2a:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3e2e:	e1 99       	sbic	0x1c, 1	; 28
    3e30:	fe cf       	rjmp	.-4      	; 0x3e2e <MasterReset+0x5f0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3e32:	85 e3       	ldi	r24, 0x35	; 53
    3e34:	91 e0       	ldi	r25, 0x01	; 1
    3e36:	9f bb       	out	0x1f, r25	; 31
    3e38:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3e3a:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3e3c:	0f b6       	in	r0, 0x3f	; 63
    3e3e:	f8 94       	cli
    3e40:	e2 9a       	sbi	0x1c, 2	; 28
    3e42:	e1 9a       	sbi	0x1c, 1	; 28
    3e44:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3e46:	e1 99       	sbic	0x1c, 1	; 28
    3e48:	fe cf       	rjmp	.-4      	; 0x3e46 <MasterReset+0x608>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3e4a:	86 e3       	ldi	r24, 0x36	; 54
    3e4c:	91 e0       	ldi	r25, 0x01	; 1
    3e4e:	9f bb       	out	0x1f, r25	; 31
    3e50:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3e52:	81 e0       	ldi	r24, 0x01	; 1
    3e54:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3e56:	0f b6       	in	r0, 0x3f	; 63
    3e58:	f8 94       	cli
    3e5a:	e2 9a       	sbi	0x1c, 2	; 28
    3e5c:	e1 9a       	sbi	0x1c, 1	; 28
    3e5e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3e60:	e1 99       	sbic	0x1c, 1	; 28
    3e62:	fe cf       	rjmp	.-4      	; 0x3e60 <MasterReset+0x622>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3e64:	87 e3       	ldi	r24, 0x37	; 55
    3e66:	91 e0       	ldi	r25, 0x01	; 1
    3e68:	9f bb       	out	0x1f, r25	; 31
    3e6a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3e6c:	81 e0       	ldi	r24, 0x01	; 1
    3e6e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3e70:	0f b6       	in	r0, 0x3f	; 63
    3e72:	f8 94       	cli
    3e74:	e2 9a       	sbi	0x1c, 2	; 28
    3e76:	e1 9a       	sbi	0x1c, 1	; 28
    3e78:	0f be       	out	0x3f, r0	; 63

	 eeprom_write_byte(&DefPrintInitialize,False);
	 eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	 eeprom_write_byte(&DefDispenserBrand,ST_GILBARCO);//ST_WAYNE_DART;

	 sprintf_P(strEEP,PSTR("000000"));
    3e7a:	00 d0       	rcall	.+0      	; 0x3e7c <MasterReset+0x63e>
    3e7c:	00 d0       	rcall	.+0      	; 0x3e7e <MasterReset+0x640>
    3e7e:	8e 01       	movw	r16, r28
    3e80:	05 5f       	subi	r16, 0xF5	; 245
    3e82:	1f 4f       	sbci	r17, 0xFF	; 255
    3e84:	ed b7       	in	r30, 0x3d	; 61
    3e86:	fe b7       	in	r31, 0x3e	; 62
    3e88:	12 83       	std	Z+2, r17	; 0x02
    3e8a:	01 83       	std	Z+1, r16	; 0x01
    3e8c:	89 ea       	ldi	r24, 0xA9	; 169
    3e8e:	94 e0       	ldi	r25, 0x04	; 4
    3e90:	94 83       	std	Z+4, r25	; 0x04
    3e92:	83 83       	std	Z+3, r24	; 0x03
    3e94:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3e98:	0f 90       	pop	r0
    3e9a:	0f 90       	pop	r0
    3e9c:	0f 90       	pop	r0
    3e9e:	0f 90       	pop	r0
    3ea0:	88 e3       	ldi	r24, 0x38	; 56
    3ea2:	91 e0       	ldi	r25, 0x01	; 1
    3ea4:	b8 01       	movw	r22, r16
    3ea6:	47 e0       	ldi	r20, 0x07	; 7
    3ea8:	50 e0       	ldi	r21, 0x00	; 0
    3eaa:	2a ed       	ldi	r18, 0xDA	; 218
    3eac:	33 e1       	ldi	r19, 0x13	; 19
    3eae:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3eb2:	e1 99       	sbic	0x1c, 1	; 28
    3eb4:	fe cf       	rjmp	.-4      	; 0x3eb2 <MasterReset+0x674>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3eb6:	8f e3       	ldi	r24, 0x3F	; 63
    3eb8:	91 e0       	ldi	r25, 0x01	; 1
    3eba:	9f bb       	out	0x1f, r25	; 31
    3ebc:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3ebe:	91 e0       	ldi	r25, 0x01	; 1
    3ec0:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3ec2:	0f b6       	in	r0, 0x3f	; 63
    3ec4:	f8 94       	cli
    3ec6:	e2 9a       	sbi	0x1c, 2	; 28
    3ec8:	e1 9a       	sbi	0x1c, 1	; 28
    3eca:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_block((const void*)&strEEP, (void*) &DefTransactionNumber, sizeof(DefTransactionNumber));

     eeprom_write_byte(&DefShift,1);

	 xArray[0]=br9600;	 xArray[1]=br9600; 	 xArray[2]=br5787;	 xArray[3]=br9600;
    3ecc:	99 83       	std	Y+1, r25	; 0x01
    3ece:	9a 83       	std	Y+2, r25	; 0x02
    3ed0:	83 e0       	ldi	r24, 0x03	; 3
    3ed2:	8b 83       	std	Y+3, r24	; 0x03
    3ed4:	9c 83       	std	Y+4, r25	; 0x04
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3ed6:	80 e4       	ldi	r24, 0x40	; 64
    3ed8:	91 e0       	ldi	r25, 0x01	; 1
    3eda:	be 01       	movw	r22, r28
    3edc:	6f 5f       	subi	r22, 0xFF	; 255
    3ede:	7f 4f       	sbci	r23, 0xFF	; 255
    3ee0:	44 e0       	ldi	r20, 0x04	; 4
    3ee2:	50 e0       	ldi	r21, 0x00	; 0
    3ee4:	2a ed       	ldi	r18, 0xDA	; 218
    3ee6:	33 e1       	ldi	r19, 0x13	; 19
    3ee8:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3eec:	e1 99       	sbic	0x1c, 1	; 28
    3eee:	fe cf       	rjmp	.-4      	; 0x3eec <MasterReset+0x6ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3ef0:	84 e4       	ldi	r24, 0x44	; 68
    3ef2:	91 e0       	ldi	r25, 0x01	; 1
    3ef4:	9f bb       	out	0x1f, r25	; 31
    3ef6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3ef8:	84 e0       	ldi	r24, 0x04	; 4
    3efa:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3efc:	0f b6       	in	r0, 0x3f	; 63
    3efe:	f8 94       	cli
    3f00:	e2 9a       	sbi	0x1c, 2	; 28
    3f02:	e1 9a       	sbi	0x1c, 1	; 28
    3f04:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f06:	e1 99       	sbic	0x1c, 1	; 28
    3f08:	fe cf       	rjmp	.-4      	; 0x3f06 <MasterReset+0x6c8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f0a:	85 e4       	ldi	r24, 0x45	; 69
    3f0c:	91 e0       	ldi	r25, 0x01	; 1
    3f0e:	9f bb       	out	0x1f, r25	; 31
    3f10:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f12:	85 e0       	ldi	r24, 0x05	; 5
    3f14:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3f16:	0f b6       	in	r0, 0x3f	; 63
    3f18:	f8 94       	cli
    3f1a:	e2 9a       	sbi	0x1c, 2	; 28
    3f1c:	e1 9a       	sbi	0x1c, 1	; 28
    3f1e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f20:	e1 99       	sbic	0x1c, 1	; 28
    3f22:	fe cf       	rjmp	.-4      	; 0x3f20 <MasterReset+0x6e2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f24:	86 e4       	ldi	r24, 0x46	; 70
    3f26:	91 e0       	ldi	r25, 0x01	; 1
    3f28:	9f bb       	out	0x1f, r25	; 31
    3f2a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f2c:	82 e0       	ldi	r24, 0x02	; 2
    3f2e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3f30:	0f b6       	in	r0, 0x3f	; 63
    3f32:	f8 94       	cli
    3f34:	e2 9a       	sbi	0x1c, 2	; 28
    3f36:	e1 9a       	sbi	0x1c, 1	; 28
    3f38:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f3a:	e1 99       	sbic	0x1c, 1	; 28
    3f3c:	fe cf       	rjmp	.-4      	; 0x3f3a <MasterReset+0x6fc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f3e:	87 e4       	ldi	r24, 0x47	; 71
    3f40:	91 e0       	ldi	r25, 0x01	; 1
    3f42:	9f bb       	out	0x1f, r25	; 31
    3f44:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f46:	85 e0       	ldi	r24, 0x05	; 5
    3f48:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3f4a:	0f b6       	in	r0, 0x3f	; 63
    3f4c:	f8 94       	cli
    3f4e:	e2 9a       	sbi	0x1c, 2	; 28
    3f50:	e1 9a       	sbi	0x1c, 1	; 28
    3f52:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f54:	e1 99       	sbic	0x1c, 1	; 28
    3f56:	fe cf       	rjmp	.-4      	; 0x3f54 <MasterReset+0x716>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f58:	88 e4       	ldi	r24, 0x48	; 72
    3f5a:	91 e0       	ldi	r25, 0x01	; 1
    3f5c:	9f bb       	out	0x1f, r25	; 31
    3f5e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f60:	85 e0       	ldi	r24, 0x05	; 5
    3f62:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3f64:	0f b6       	in	r0, 0x3f	; 63
    3f66:	f8 94       	cli
    3f68:	e2 9a       	sbi	0x1c, 2	; 28
    3f6a:	e1 9a       	sbi	0x1c, 1	; 28
    3f6c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f6e:	e1 99       	sbic	0x1c, 1	; 28
    3f70:	fe cf       	rjmp	.-4      	; 0x3f6e <MasterReset+0x730>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f72:	89 e4       	ldi	r24, 0x49	; 73
    3f74:	91 e0       	ldi	r25, 0x01	; 1
    3f76:	9f bb       	out	0x1f, r25	; 31
    3f78:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f7a:	84 e0       	ldi	r24, 0x04	; 4
    3f7c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3f7e:	0f b6       	in	r0, 0x3f	; 63
    3f80:	f8 94       	cli
    3f82:	e2 9a       	sbi	0x1c, 2	; 28
    3f84:	e1 9a       	sbi	0x1c, 1	; 28
    3f86:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3f88:	e1 99       	sbic	0x1c, 1	; 28
    3f8a:	fe cf       	rjmp	.-4      	; 0x3f88 <MasterReset+0x74a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3f8c:	8a e4       	ldi	r24, 0x4A	; 74
    3f8e:	91 e0       	ldi	r25, 0x01	; 1
    3f90:	9f bb       	out	0x1f, r25	; 31
    3f92:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3f94:	8a e0       	ldi	r24, 0x0A	; 10
    3f96:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3f98:	0f b6       	in	r0, 0x3f	; 63
    3f9a:	f8 94       	cli
    3f9c:	e2 9a       	sbi	0x1c, 2	; 28
    3f9e:	e1 9a       	sbi	0x1c, 1	; 28
    3fa0:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3fa2:	e1 99       	sbic	0x1c, 1	; 28
    3fa4:	fe cf       	rjmp	.-4      	; 0x3fa2 <MasterReset+0x764>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3fa6:	81 ec       	ldi	r24, 0xC1	; 193
    3fa8:	93 e0       	ldi	r25, 0x03	; 3
    3faa:	9f bb       	out	0x1f, r25	; 31
    3fac:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3fae:	81 e0       	ldi	r24, 0x01	; 1
    3fb0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3fb2:	0f b6       	in	r0, 0x3f	; 63
    3fb4:	f8 94       	cli
    3fb6:	e2 9a       	sbi	0x1c, 2	; 28
    3fb8:	e1 9a       	sbi	0x1c, 1	; 28
    3fba:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3fbc:	e1 99       	sbic	0x1c, 1	; 28
    3fbe:	fe cf       	rjmp	.-4      	; 0x3fbc <MasterReset+0x77e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3fc0:	82 ec       	ldi	r24, 0xC2	; 194
    3fc2:	93 e0       	ldi	r25, 0x03	; 3
    3fc4:	9f bb       	out	0x1f, r25	; 31
    3fc6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3fc8:	81 e0       	ldi	r24, 0x01	; 1
    3fca:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3fcc:	0f b6       	in	r0, 0x3f	; 63
    3fce:	f8 94       	cli
    3fd0:	e2 9a       	sbi	0x1c, 2	; 28
    3fd2:	e1 9a       	sbi	0x1c, 1	; 28
    3fd4:	0f be       	out	0x3f, r0	; 63
     eeprom_write_byte(&DefSequenceTimeout,SEQUENCE_TIMEOUT);

     eeprom_write_byte(&DefPrintMoney,True);
	 eeprom_write_byte(&DefHGMode,HM_232);//HM_TTL,HM_232,HM_485

	 sprintf_P(strEEP,PSTR("    PT. HANINDO AUTOMATION SOLUTIONS    "));
    3fd6:	00 d0       	rcall	.+0      	; 0x3fd8 <MasterReset+0x79a>
    3fd8:	00 d0       	rcall	.+0      	; 0x3fda <MasterReset+0x79c>
    3fda:	8e 01       	movw	r16, r28
    3fdc:	05 5f       	subi	r16, 0xF5	; 245
    3fde:	1f 4f       	sbci	r17, 0xFF	; 255
    3fe0:	ed b7       	in	r30, 0x3d	; 61
    3fe2:	fe b7       	in	r31, 0x3e	; 62
    3fe4:	12 83       	std	Z+2, r17	; 0x02
    3fe6:	01 83       	std	Z+1, r16	; 0x01
    3fe8:	80 e8       	ldi	r24, 0x80	; 128
    3fea:	94 e0       	ldi	r25, 0x04	; 4
    3fec:	94 83       	std	Z+4, r25	; 0x04
    3fee:	83 83       	std	Z+3, r24	; 0x03
    3ff0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3ff4:	0f 90       	pop	r0
    3ff6:	0f 90       	pop	r0
    3ff8:	0f 90       	pop	r0
    3ffa:	0f 90       	pop	r0
    3ffc:	87 e2       	ldi	r24, 0x27	; 39
    3ffe:	92 e0       	ldi	r25, 0x02	; 2
    4000:	b8 01       	movw	r22, r16
    4002:	49 e2       	ldi	r20, 0x29	; 41
    4004:	50 e0       	ldi	r21, 0x00	; 0
    4006:	2a ed       	ldi	r18, 0xDA	; 218
    4008:	33 e1       	ldi	r19, 0x13	; 19
    400a:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[0],41);
	 sprintf_P(strEEP,PSTR("        JL. RS Fatmawati No.55          "));
    400e:	00 d0       	rcall	.+0      	; 0x4010 <MasterReset+0x7d2>
    4010:	00 d0       	rcall	.+0      	; 0x4012 <MasterReset+0x7d4>
    4012:	ed b7       	in	r30, 0x3d	; 61
    4014:	fe b7       	in	r31, 0x3e	; 62
    4016:	12 83       	std	Z+2, r17	; 0x02
    4018:	01 83       	std	Z+1, r16	; 0x01
    401a:	87 e5       	ldi	r24, 0x57	; 87
    401c:	94 e0       	ldi	r25, 0x04	; 4
    401e:	94 83       	std	Z+4, r25	; 0x04
    4020:	83 83       	std	Z+3, r24	; 0x03
    4022:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    4026:	0f 90       	pop	r0
    4028:	0f 90       	pop	r0
    402a:	0f 90       	pop	r0
    402c:	0f 90       	pop	r0
    402e:	80 e5       	ldi	r24, 0x50	; 80
    4030:	92 e0       	ldi	r25, 0x02	; 2
    4032:	b8 01       	movw	r22, r16
    4034:	49 e2       	ldi	r20, 0x29	; 41
    4036:	50 e0       	ldi	r21, 0x00	; 0
    4038:	2a ed       	ldi	r18, 0xDA	; 218
    403a:	33 e1       	ldi	r19, 0x13	; 19
    403c:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[1],41);
	 sprintf_P(strEEP,PSTR("            Jakarta Selatan             "));
    4040:	00 d0       	rcall	.+0      	; 0x4042 <MasterReset+0x804>
    4042:	00 d0       	rcall	.+0      	; 0x4044 <MasterReset+0x806>
    4044:	ed b7       	in	r30, 0x3d	; 61
    4046:	fe b7       	in	r31, 0x3e	; 62
    4048:	12 83       	std	Z+2, r17	; 0x02
    404a:	01 83       	std	Z+1, r16	; 0x01
    404c:	8e e2       	ldi	r24, 0x2E	; 46
    404e:	94 e0       	ldi	r25, 0x04	; 4
    4050:	94 83       	std	Z+4, r25	; 0x04
    4052:	83 83       	std	Z+3, r24	; 0x03
    4054:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    4058:	0f 90       	pop	r0
    405a:	0f 90       	pop	r0
    405c:	0f 90       	pop	r0
    405e:	0f 90       	pop	r0
    4060:	89 e7       	ldi	r24, 0x79	; 121
    4062:	92 e0       	ldi	r25, 0x02	; 2
    4064:	b8 01       	movw	r22, r16
    4066:	49 e2       	ldi	r20, 0x29	; 41
    4068:	50 e0       	ldi	r21, 0x00	; 0
    406a:	2a ed       	ldi	r18, 0xDA	; 218
    406c:	33 e1       	ldi	r19, 0x13	; 19
    406e:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[2],41);
	 sprintf_P(strEEP,PSTR("                                        "));
    4072:	00 d0       	rcall	.+0      	; 0x4074 <MasterReset+0x836>
    4074:	00 d0       	rcall	.+0      	; 0x4076 <MasterReset+0x838>
    4076:	ed b7       	in	r30, 0x3d	; 61
    4078:	fe b7       	in	r31, 0x3e	; 62
    407a:	12 83       	std	Z+2, r17	; 0x02
    407c:	01 83       	std	Z+1, r16	; 0x01
    407e:	85 e0       	ldi	r24, 0x05	; 5
    4080:	94 e0       	ldi	r25, 0x04	; 4
    4082:	94 83       	std	Z+4, r25	; 0x04
    4084:	83 83       	std	Z+3, r24	; 0x03
    4086:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    408a:	0f 90       	pop	r0
    408c:	0f 90       	pop	r0
    408e:	0f 90       	pop	r0
    4090:	0f 90       	pop	r0
    4092:	82 ea       	ldi	r24, 0xA2	; 162
    4094:	92 e0       	ldi	r25, 0x02	; 2
    4096:	b8 01       	movw	r22, r16
    4098:	49 e2       	ldi	r20, 0x29	; 41
    409a:	50 e0       	ldi	r21, 0x00	; 0
    409c:	2a ed       	ldi	r18, 0xDA	; 218
    409e:	33 e1       	ldi	r19, 0x13	; 19
    40a0:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[3],41);
	 sprintf_P(strEEP,PSTR("                                        "));
    40a4:	00 d0       	rcall	.+0      	; 0x40a6 <MasterReset+0x868>
    40a6:	00 d0       	rcall	.+0      	; 0x40a8 <MasterReset+0x86a>
    40a8:	ed b7       	in	r30, 0x3d	; 61
    40aa:	fe b7       	in	r31, 0x3e	; 62
    40ac:	12 83       	std	Z+2, r17	; 0x02
    40ae:	01 83       	std	Z+1, r16	; 0x01
    40b0:	8c ed       	ldi	r24, 0xDC	; 220
    40b2:	93 e0       	ldi	r25, 0x03	; 3
    40b4:	94 83       	std	Z+4, r25	; 0x04
    40b6:	83 83       	std	Z+3, r24	; 0x03
    40b8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    40bc:	0f 90       	pop	r0
    40be:	0f 90       	pop	r0
    40c0:	0f 90       	pop	r0
    40c2:	0f 90       	pop	r0
    40c4:	8b ec       	ldi	r24, 0xCB	; 203
    40c6:	92 e0       	ldi	r25, 0x02	; 2
    40c8:	b8 01       	movw	r22, r16
    40ca:	49 e2       	ldi	r20, 0x29	; 41
    40cc:	50 e0       	ldi	r21, 0x00	; 0
    40ce:	2a ed       	ldi	r18, 0xDA	; 218
    40d0:	33 e1       	ldi	r19, 0x13	; 19
    40d2:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[4],41);
	 sprintf_P(strEEP,PSTR("                                        "));
    40d6:	00 d0       	rcall	.+0      	; 0x40d8 <MasterReset+0x89a>
    40d8:	00 d0       	rcall	.+0      	; 0x40da <MasterReset+0x89c>
    40da:	ed b7       	in	r30, 0x3d	; 61
    40dc:	fe b7       	in	r31, 0x3e	; 62
    40de:	12 83       	std	Z+2, r17	; 0x02
    40e0:	01 83       	std	Z+1, r16	; 0x01
    40e2:	83 eb       	ldi	r24, 0xB3	; 179
    40e4:	93 e0       	ldi	r25, 0x03	; 3
    40e6:	94 83       	std	Z+4, r25	; 0x04
    40e8:	83 83       	std	Z+3, r24	; 0x03
    40ea:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    40ee:	0f 90       	pop	r0
    40f0:	0f 90       	pop	r0
    40f2:	0f 90       	pop	r0
    40f4:	0f 90       	pop	r0
    40f6:	84 ef       	ldi	r24, 0xF4	; 244
    40f8:	92 e0       	ldi	r25, 0x02	; 2
    40fa:	b8 01       	movw	r22, r16
    40fc:	49 e2       	ldi	r20, 0x29	; 41
    40fe:	50 e0       	ldi	r21, 0x00	; 0
    4100:	2a ed       	ldi	r18, 0xDA	; 218
    4102:	33 e1       	ldi	r19, 0x13	; 19
    4104:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[5],41);

	 sprintf_P(strEEP,PSTR("             Terima Kasih               "));
    4108:	00 d0       	rcall	.+0      	; 0x410a <MasterReset+0x8cc>
    410a:	00 d0       	rcall	.+0      	; 0x410c <MasterReset+0x8ce>
    410c:	ed b7       	in	r30, 0x3d	; 61
    410e:	fe b7       	in	r31, 0x3e	; 62
    4110:	12 83       	std	Z+2, r17	; 0x02
    4112:	01 83       	std	Z+1, r16	; 0x01
    4114:	8a e8       	ldi	r24, 0x8A	; 138
    4116:	93 e0       	ldi	r25, 0x03	; 3
    4118:	94 83       	std	Z+4, r25	; 0x04
    411a:	83 83       	std	Z+3, r24	; 0x03
    411c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    4120:	0f 90       	pop	r0
    4122:	0f 90       	pop	r0
    4124:	0f 90       	pop	r0
    4126:	0f 90       	pop	r0
    4128:	8d e1       	ldi	r24, 0x1D	; 29
    412a:	93 e0       	ldi	r25, 0x03	; 3
    412c:	b8 01       	movw	r22, r16
    412e:	49 e2       	ldi	r20, 0x29	; 41
    4130:	50 e0       	ldi	r21, 0x00	; 0
    4132:	2a ed       	ldi	r18, 0xDA	; 218
    4134:	33 e1       	ldi	r19, 0x13	; 19
    4136:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[6],41);
	 sprintf_P(strEEP,PSTR("            Selamat  Jalan              "));
    413a:	00 d0       	rcall	.+0      	; 0x413c <MasterReset+0x8fe>
    413c:	00 d0       	rcall	.+0      	; 0x413e <MasterReset+0x900>
    413e:	ed b7       	in	r30, 0x3d	; 61
    4140:	fe b7       	in	r31, 0x3e	; 62
    4142:	12 83       	std	Z+2, r17	; 0x02
    4144:	01 83       	std	Z+1, r16	; 0x01
    4146:	81 e6       	ldi	r24, 0x61	; 97
    4148:	93 e0       	ldi	r25, 0x03	; 3
    414a:	94 83       	std	Z+4, r25	; 0x04
    414c:	83 83       	std	Z+3, r24	; 0x03
    414e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    4152:	0f 90       	pop	r0
    4154:	0f 90       	pop	r0
    4156:	0f 90       	pop	r0
    4158:	0f 90       	pop	r0
    415a:	86 e4       	ldi	r24, 0x46	; 70
    415c:	93 e0       	ldi	r25, 0x03	; 3
    415e:	b8 01       	movw	r22, r16
    4160:	49 e2       	ldi	r20, 0x29	; 41
    4162:	50 e0       	ldi	r21, 0x00	; 0
    4164:	2a ed       	ldi	r18, 0xDA	; 218
    4166:	33 e1       	ldi	r19, 0x13	; 19
    4168:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[7],41);
	 sprintf_P(strEEP,PSTR("      Semoga Selamat Sampai Tujuan      "));
    416c:	00 d0       	rcall	.+0      	; 0x416e <MasterReset+0x930>
    416e:	00 d0       	rcall	.+0      	; 0x4170 <MasterReset+0x932>
    4170:	ed b7       	in	r30, 0x3d	; 61
    4172:	fe b7       	in	r31, 0x3e	; 62
    4174:	12 83       	std	Z+2, r17	; 0x02
    4176:	01 83       	std	Z+1, r16	; 0x01
    4178:	88 e3       	ldi	r24, 0x38	; 56
    417a:	93 e0       	ldi	r25, 0x03	; 3
    417c:	94 83       	std	Z+4, r25	; 0x04
    417e:	83 83       	std	Z+3, r24	; 0x03
    4180:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    4184:	0f 90       	pop	r0
    4186:	0f 90       	pop	r0
    4188:	0f 90       	pop	r0
    418a:	0f 90       	pop	r0
    418c:	8f e6       	ldi	r24, 0x6F	; 111
    418e:	93 e0       	ldi	r25, 0x03	; 3
    4190:	b8 01       	movw	r22, r16
    4192:	49 e2       	ldi	r20, 0x29	; 41
    4194:	50 e0       	ldi	r21, 0x00	; 0
    4196:	2a ed       	ldi	r18, 0xDA	; 218
    4198:	33 e1       	ldi	r19, 0x13	; 19
    419a:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[8],41);
	 sprintf_P(strEEP,PSTR("                                        "));
    419e:	00 d0       	rcall	.+0      	; 0x41a0 <MasterReset+0x962>
    41a0:	00 d0       	rcall	.+0      	; 0x41a2 <MasterReset+0x964>
    41a2:	ed b7       	in	r30, 0x3d	; 61
    41a4:	fe b7       	in	r31, 0x3e	; 62
    41a6:	12 83       	std	Z+2, r17	; 0x02
    41a8:	01 83       	std	Z+1, r16	; 0x01
    41aa:	8f e0       	ldi	r24, 0x0F	; 15
    41ac:	93 e0       	ldi	r25, 0x03	; 3
    41ae:	94 83       	std	Z+4, r25	; 0x04
    41b0:	83 83       	std	Z+3, r24	; 0x03
    41b2:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    41b6:	0f 90       	pop	r0
    41b8:	0f 90       	pop	r0
    41ba:	0f 90       	pop	r0
    41bc:	0f 90       	pop	r0
    41be:	88 e9       	ldi	r24, 0x98	; 152
    41c0:	93 e0       	ldi	r25, 0x03	; 3
    41c2:	b8 01       	movw	r22, r16
    41c4:	49 e2       	ldi	r20, 0x29	; 41
    41c6:	50 e0       	ldi	r21, 0x00	; 0
    41c8:	2a ed       	ldi	r18, 0xDA	; 218
    41ca:	33 e1       	ldi	r19, 0x13	; 19
    41cc:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    41d0:	e1 99       	sbic	0x1c, 1	; 28
    41d2:	fe cf       	rjmp	.-4      	; 0x41d0 <MasterReset+0x992>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    41d4:	80 e0       	ldi	r24, 0x00	; 0
    41d6:	90 e0       	ldi	r25, 0x00	; 0
    41d8:	9f bb       	out	0x1f, r25	; 31
    41da:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    41dc:	81 e0       	ldi	r24, 0x01	; 1
    41de:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    41e0:	0f b6       	in	r0, 0x3f	; 63
    41e2:	f8 94       	cli
    41e4:	e2 9a       	sbi	0x1c, 2	; 28
    41e6:	e1 9a       	sbi	0x1c, 1	; 28
    41e8:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_block((const void*)&strEEP, (void*) &DefHeaderFooter[9],41);
	 
	 eeprom_write_byte(&DefIFT_ID,1);
}
    41ea:	ec 96       	adiw	r28, 0x3c	; 60
    41ec:	0f b6       	in	r0, 0x3f	; 63
    41ee:	f8 94       	cli
    41f0:	de bf       	out	0x3e, r29	; 62
    41f2:	0f be       	out	0x3f, r0	; 63
    41f4:	cd bf       	out	0x3d, r28	; 61
    41f6:	cf 91       	pop	r28
    41f8:	df 91       	pop	r29
    41fa:	1f 91       	pop	r17
    41fc:	0f 91       	pop	r16
    41fe:	ff 90       	pop	r15
    4200:	ef 90       	pop	r14
    4202:	df 90       	pop	r13
    4204:	08 95       	ret

00004206 <procMessage21>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    4206:	af 92       	push	r10
    4208:	bf 92       	push	r11
    420a:	cf 92       	push	r12
    420c:	df 92       	push	r13
    420e:	ef 92       	push	r14
    4210:	ff 92       	push	r15
    4212:	0f 93       	push	r16
    4214:	1f 93       	push	r17
    4216:	df 93       	push	r29
    4218:	cf 93       	push	r28
    421a:	cd b7       	in	r28, 0x3d	; 61
    421c:	de b7       	in	r29, 0x3e	; 62
    421e:	2b 97       	sbiw	r28, 0x0b	; 11
    4220:	0f b6       	in	r0, 0x3f	; 63
    4222:	f8 94       	cli
    4224:	de bf       	out	0x3e, r29	; 62
    4226:	0f be       	out	0x3f, r0	; 63
    4228:	cd bf       	out	0x3d, r28	; 61
    422a:	09 e0       	ldi	r16, 0x09	; 9
    422c:	11 e0       	ldi	r17, 0x01	; 1
    422e:	72 e4       	ldi	r23, 0x42	; 66
    4230:	e7 2e       	mov	r14, r23
    4232:	79 e0       	ldi	r23, 0x09	; 9
    4234:	f7 2e       	mov	r15, r23
    4236:	6e 01       	movw	r12, r28
    4238:	08 94       	sec
    423a:	c1 1c       	adc	r12, r1
    423c:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    423e:	6b e0       	ldi	r22, 0x0B	; 11
    4240:	a6 2e       	mov	r10, r22
    4242:	b1 2c       	mov	r11, r1
    4244:	ac 0e       	add	r10, r28
    4246:	bd 1e       	adc	r11, r29
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    4248:	f6 01       	movw	r30, r12
    424a:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    424c:	8d 91       	ld	r24, X+
    424e:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4250:	ea 15       	cp	r30, r10
    4252:	fb 05       	cpc	r31, r11
    4254:	d9 f7       	brne	.-10     	; 0x424c <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4256:	1b 86       	std	Y+11, r1	; 0x0b
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    4258:	c8 01       	movw	r24, r16
    425a:	b6 01       	movw	r22, r12
    425c:	4b e0       	ldi	r20, 0x0B	; 11
    425e:	50 e0       	ldi	r21, 0x00	; 0
    4260:	2a ed       	ldi	r18, 0xDA	; 218
    4262:	33 e1       	ldi	r19, 0x13	; 19
    4264:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
    4268:	05 5f       	subi	r16, 0xF5	; 245
    426a:	1f 4f       	sbci	r17, 0xFF	; 255
    426c:	8a e0       	ldi	r24, 0x0A	; 10
    426e:	90 e0       	ldi	r25, 0x00	; 0
    4270:	e8 0e       	add	r14, r24
    4272:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    4274:	91 e0       	ldi	r25, 0x01	; 1
    4276:	05 33       	cpi	r16, 0x35	; 53
    4278:	19 07       	cpc	r17, r25
    427a:	31 f7       	brne	.-52     	; 0x4248 <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    427c:	80 e0       	ldi	r24, 0x00	; 0
    427e:	2b 96       	adiw	r28, 0x0b	; 11
    4280:	0f b6       	in	r0, 0x3f	; 63
    4282:	f8 94       	cli
    4284:	de bf       	out	0x3e, r29	; 62
    4286:	0f be       	out	0x3f, r0	; 63
    4288:	cd bf       	out	0x3d, r28	; 61
    428a:	cf 91       	pop	r28
    428c:	df 91       	pop	r29
    428e:	1f 91       	pop	r17
    4290:	0f 91       	pop	r16
    4292:	ff 90       	pop	r15
    4294:	ef 90       	pop	r14
    4296:	df 90       	pop	r13
    4298:	cf 90       	pop	r12
    429a:	bf 90       	pop	r11
    429c:	af 90       	pop	r10
    429e:	08 95       	ret

000042a0 <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){//Find FIP Addr based on PumpID respectively: 
    42a0:	ff 92       	push	r15
    42a2:	0f 93       	push	r16
    42a4:	1f 93       	push	r17
    42a6:	df 93       	push	r29
    42a8:	cf 93       	push	r28
    42aa:	cd b7       	in	r28, 0x3d	; 61
    42ac:	de b7       	in	r29, 0x3e	; 62
    42ae:	28 97       	sbiw	r28, 0x08	; 8
    42b0:	0f b6       	in	r0, 0x3f	; 63
    42b2:	f8 94       	cli
    42b4:	de bf       	out	0x3e, r29	; 62
    42b6:	0f be       	out	0x3f, r0	; 63
    42b8:	cd bf       	out	0x3d, r28	; 61
    42ba:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    42bc:	8e 01       	movw	r16, r28
    42be:	0f 5f       	subi	r16, 0xFF	; 255
    42c0:	1f 4f       	sbci	r17, 0xFF	; 255
    42c2:	c8 01       	movw	r24, r16
    42c4:	65 e4       	ldi	r22, 0x45	; 69
    42c6:	70 e0       	ldi	r23, 0x00	; 0
    42c8:	48 e0       	ldi	r20, 0x08	; 8
    42ca:	50 e0       	ldi	r21, 0x00	; 0
    42cc:	22 ed       	ldi	r18, 0xD2	; 210
    42ce:	33 e1       	ldi	r19, 0x13	; 19
    42d0:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    42d4:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     //FIP1..FIP8
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    42d6:	9e 01       	movw	r18, r28
    42d8:	27 5f       	subi	r18, 0xF7	; 247
    42da:	3f 4f       	sbci	r19, 0xFF	; 255
    42dc:	9e 2f       	mov	r25, r30
    42de:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    42e0:	80 81       	ld	r24, Z
    42e2:	8f 15       	cp	r24, r15
    42e4:	19 f4       	brne	.+6      	; 0x42ec <GetFIPAddr+0x4c>
		     Result=i+1;
    42e6:	89 2f       	mov	r24, r25
    42e8:	8f 5f       	subi	r24, 0xFF	; 255
    42ea:	05 c0       	rjmp	.+10     	; 0x42f6 <GetFIPAddr+0x56>
			 break;
    42ec:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){//Find FIP Addr based on PumpID respectively: 
char i,PPumpID[8],Result;     //FIP1..FIP8
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    42ee:	e2 17       	cp	r30, r18
    42f0:	f3 07       	cpc	r31, r19
    42f2:	a1 f7       	brne	.-24     	; 0x42dc <GetFIPAddr+0x3c>
    42f4:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    42f6:	28 96       	adiw	r28, 0x08	; 8
    42f8:	0f b6       	in	r0, 0x3f	; 63
    42fa:	f8 94       	cli
    42fc:	de bf       	out	0x3e, r29	; 62
    42fe:	0f be       	out	0x3f, r0	; 63
    4300:	cd bf       	out	0x3d, r28	; 61
    4302:	cf 91       	pop	r28
    4304:	df 91       	pop	r29
    4306:	1f 91       	pop	r17
    4308:	0f 91       	pop	r16
    430a:	ff 90       	pop	r15
    430c:	08 95       	ret

0000430e <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    430e:	ff 92       	push	r15
    4310:	0f 93       	push	r16
    4312:	1f 93       	push	r17
    4314:	cf 93       	push	r28
    4316:	df 93       	push	r29
    4318:	28 2f       	mov	r18, r24
    431a:	f6 2e       	mov	r15, r22
char strSend[20],iPumpID; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    431c:	80 31       	cpi	r24, 0x10	; 16
    431e:	08 f0       	brcs	.+2      	; 0x4322 <UpdateStandaloneStatus+0x14>
    4320:	4e c0       	rjmp	.+156    	; 0x43be <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    4322:	e1 99       	sbic	0x1c, 1	; 28
    4324:	fe cf       	rjmp	.-4      	; 0x4322 <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4326:	87 e3       	ldi	r24, 0x37	; 55
    4328:	91 e0       	ldi	r25, 0x01	; 1
    432a:	9f bb       	out	0x1f, r25	; 31
    432c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    432e:	e0 9a       	sbi	0x1c, 0	; 28
    4330:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    4332:	80 93 5e 01 	sts	0x015E, r24
	     switch(DispenserBrand){
    4336:	81 50       	subi	r24, 0x01	; 1
    4338:	82 30       	cpi	r24, 0x02	; 2
    433a:	08 f4       	brcc	.+2      	; 0x433e <UpdateStandaloneStatus+0x30>
    433c:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    433e:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
		 if (iAddr>0){
    4342:	88 23       	and	r24, r24
    4344:	e1 f1       	breq	.+120    	; 0x43be <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    4346:	81 50       	subi	r24, 0x01	; 1
    4348:	c8 2f       	mov	r28, r24
    434a:	d0 e0       	ldi	r29, 0x00	; 0
    434c:	80 e1       	ldi	r24, 0x10	; 16
    434e:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    4352:	8e 01       	movw	r16, r28
    4354:	0e 5f       	subi	r16, 0xFE	; 254
    4356:	1e 4f       	sbci	r17, 0xFE	; 254
    4358:	f8 01       	movw	r30, r16
    435a:	90 81       	ld	r25, Z
    435c:	98 17       	cp	r25, r24
    435e:	b1 f0       	breq	.+44     	; 0x438c <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    4360:	f0 e1       	ldi	r31, 0x10	; 16
    4362:	ff 16       	cp	r15, r31
    4364:	21 f0       	breq	.+8      	; 0x436e <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    4366:	fe 01       	movw	r30, r28
    4368:	e1 5a       	subi	r30, 0xA1	; 161
    436a:	fe 4f       	sbci	r31, 0xFE	; 254
    436c:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    436e:	8f 2d       	mov	r24, r15
    4370:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    4374:	8e 01       	movw	r16, r28
    4376:	0e 5f       	subi	r16, 0xFE	; 254
    4378:	1e 4f       	sbci	r17, 0xFE	; 254
    437a:	f8 01       	movw	r30, r16
    437c:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    437e:	f5 e1       	ldi	r31, 0x15	; 21
    4380:	ff 16       	cp	r15, r31
    4382:	c1 f4       	brne	.+48     	; 0x43b4 <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    4384:	c1 5a       	subi	r28, 0xA1	; 161
    4386:	de 4f       	sbci	r29, 0xFE	; 254
    4388:	88 81       	ld	r24, Y
    438a:	10 c0       	rjmp	.+32     	; 0x43ac <UpdateStandaloneStatus+0x9e>
    438c:	fe 01       	movw	r30, r28
    438e:	e1 5a       	subi	r30, 0xA1	; 161
    4390:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED){
    4392:	81 e1       	ldi	r24, 0x11	; 17
    4394:	f8 16       	cp	r15, r24
    4396:	11 f4       	brne	.+4      	; 0x439c <UpdateStandaloneStatus+0x8e>
				 //New

				     //if (CurrentPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY))
			             strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    4398:	80 81       	ld	r24, Z
    439a:	08 c0       	rjmp	.+16     	; 0x43ac <UpdateStandaloneStatus+0x9e>
					 //    CurrentPumpStatus[iAddr]=PUMP_OFF;
					 //    strPumpStatus[iAddr]=GetPumpStatusLabel(PUMP_OFF);
					 //}

				  }
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    439c:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    439e:	8b e0       	ldi	r24, 0x0B	; 11
    43a0:	f8 16       	cp	r15, r24
    43a2:	21 f0       	breq	.+8      	; 0x43ac <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    43a4:	f4 e1       	ldi	r31, 0x14	; 20
    43a6:	ff 16       	cp	r15, r31
    43a8:	29 f4       	brne	.+10     	; 0x43b4 <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    43aa:	84 e1       	ldi	r24, 0x14	; 20
    43ac:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    43b0:	f8 01       	movw	r30, r16
    43b2:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    43b4:	10 92 12 01 	sts	0x0112, r1
	     IsNewPumpStatus=True;		 
    43b8:	81 e0       	ldi	r24, 0x01	; 1
    43ba:	80 93 01 01 	sts	0x0101, r24
		 }		 
	 }
}
    43be:	df 91       	pop	r29
    43c0:	cf 91       	pop	r28
    43c2:	1f 91       	pop	r17
    43c4:	0f 91       	pop	r16
    43c6:	ff 90       	pop	r15
    43c8:	08 95       	ret

000043ca <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    43ca:	1f 93       	push	r17
    43cc:	df 93       	push	r29
    43ce:	cf 93       	push	r28
    43d0:	cd b7       	in	r28, 0x3d	; 61
    43d2:	de b7       	in	r29, 0x3e	; 62
    43d4:	28 97       	sbiw	r28, 0x08	; 8
    43d6:	0f b6       	in	r0, 0x3f	; 63
    43d8:	f8 94       	cli
    43da:	de bf       	out	0x3e, r29	; 62
    43dc:	0f be       	out	0x3f, r0	; 63
    43de:	cd bf       	out	0x3d, r28	; 61
    43e0:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    43e2:	ce 01       	movw	r24, r28
    43e4:	01 96       	adiw	r24, 0x01	; 1
    43e6:	65 e4       	ldi	r22, 0x45	; 69
    43e8:	70 e0       	ldi	r23, 0x00	; 0
    43ea:	48 e0       	ldi	r20, 0x08	; 8
    43ec:	50 e0       	ldi	r21, 0x00	; 0
    43ee:	22 ed       	ldi	r18, 0xD2	; 210
    43f0:	33 e1       	ldi	r19, 0x13	; 19
    43f2:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    43f6:	81 2f       	mov	r24, r17
    43f8:	81 50       	subi	r24, 0x01	; 1
    43fa:	87 30       	cpi	r24, 0x07	; 7
    43fc:	10 f0       	brcs	.+4      	; 0x4402 <GetPumpID+0x38>
    43fe:	80 e0       	ldi	r24, 0x00	; 0
    4400:	04 c0       	rjmp	.+8      	; 0x440a <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    4402:	fe 01       	movw	r30, r28
    4404:	e1 0f       	add	r30, r17
    4406:	f1 1d       	adc	r31, r1
    4408:	80 81       	ld	r24, Z
	 }
   return Result;
}
    440a:	28 96       	adiw	r28, 0x08	; 8
    440c:	0f b6       	in	r0, 0x3f	; 63
    440e:	f8 94       	cli
    4410:	de bf       	out	0x3e, r29	; 62
    4412:	0f be       	out	0x3f, r0	; 63
    4414:	cd bf       	out	0x3d, r28	; 61
    4416:	cf 91       	pop	r28
    4418:	df 91       	pop	r29
    441a:	1f 91       	pop	r17
    441c:	08 95       	ret

0000441e <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    441e:	0f 93       	push	r16
    4420:	1f 93       	push	r17
    4422:	df 93       	push	r29
    4424:	cf 93       	push	r28
    4426:	00 d0       	rcall	.+0      	; 0x4428 <GetTotalizerData+0xa>
    4428:	00 d0       	rcall	.+0      	; 0x442a <GetTotalizerData+0xc>
    442a:	00 d0       	rcall	.+0      	; 0x442c <GetTotalizerData+0xe>
    442c:	cd b7       	in	r28, 0x3d	; 61
    442e:	de b7       	in	r29, 0x3e	; 62
    4430:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    4432:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    4434:	21 50       	subi	r18, 0x01	; 1
    4436:	26 30       	cpi	r18, 0x06	; 6
    4438:	08 f4       	brcc	.+2      	; 0x443c <GetTotalizerData+0x1e>
    443a:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    443c:	88 23       	and	r24, r24
    443e:	d9 f4       	brne	.+54     	; 0x4476 <GetTotalizerData+0x58>
    4440:	64 e2       	ldi	r22, 0x24	; 36
    4442:	46 9f       	mul	r20, r22
    4444:	b0 01       	movw	r22, r0
    4446:	11 24       	eor	r1, r1
    4448:	29 2f       	mov	r18, r25
    444a:	30 e0       	ldi	r19, 0x00	; 0
    444c:	80 e2       	ldi	r24, 0x20	; 32
    444e:	91 e0       	ldi	r25, 0x01	; 1
    4450:	fc 01       	movw	r30, r24
    4452:	2e 9f       	mul	r18, r30
    4454:	c0 01       	movw	r24, r0
    4456:	2f 9f       	mul	r18, r31
    4458:	90 0d       	add	r25, r0
    445a:	3e 9f       	mul	r19, r30
    445c:	90 0d       	add	r25, r0
    445e:	11 24       	eor	r1, r1
    4460:	68 0f       	add	r22, r24
    4462:	79 1f       	adc	r23, r25
    4464:	86 e0       	ldi	r24, 0x06	; 6
    4466:	58 9f       	mul	r21, r24
    4468:	c0 01       	movw	r24, r0
    446a:	11 24       	eor	r1, r1
    446c:	68 0f       	add	r22, r24
    446e:	79 1f       	adc	r23, r25
    4470:	6d 53       	subi	r22, 0x3D	; 61
    4472:	7c 4f       	sbci	r23, 0xFC	; 252
    4474:	1c c0       	rjmp	.+56     	; 0x44ae <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    4476:	81 30       	cpi	r24, 0x01	; 1
    4478:	11 f5       	brne	.+68     	; 0x44be <GetTotalizerData+0xa0>
    447a:	64 e2       	ldi	r22, 0x24	; 36
    447c:	46 9f       	mul	r20, r22
    447e:	b0 01       	movw	r22, r0
    4480:	11 24       	eor	r1, r1
    4482:	29 2f       	mov	r18, r25
    4484:	30 e0       	ldi	r19, 0x00	; 0
    4486:	80 e2       	ldi	r24, 0x20	; 32
    4488:	91 e0       	ldi	r25, 0x01	; 1
    448a:	fc 01       	movw	r30, r24
    448c:	2e 9f       	mul	r18, r30
    448e:	c0 01       	movw	r24, r0
    4490:	2f 9f       	mul	r18, r31
    4492:	90 0d       	add	r25, r0
    4494:	3e 9f       	mul	r19, r30
    4496:	90 0d       	add	r25, r0
    4498:	11 24       	eor	r1, r1
    449a:	68 0f       	add	r22, r24
    449c:	79 1f       	adc	r23, r25
    449e:	86 e0       	ldi	r24, 0x06	; 6
    44a0:	58 9f       	mul	r21, r24
    44a2:	c0 01       	movw	r24, r0
    44a4:	11 24       	eor	r1, r1
    44a6:	68 0f       	add	r22, r24
    44a8:	79 1f       	adc	r23, r25
    44aa:	6d 5f       	subi	r22, 0xFD	; 253
    44ac:	79 4f       	sbci	r23, 0xF9	; 249
    44ae:	ce 01       	movw	r24, r28
    44b0:	01 96       	adiw	r24, 0x01	; 1
    44b2:	46 e0       	ldi	r20, 0x06	; 6
    44b4:	50 e0       	ldi	r21, 0x00	; 0
    44b6:	22 ed       	ldi	r18, 0xD2	; 210
    44b8:	33 e1       	ldi	r19, 0x13	; 19
    44ba:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    44be:	ce 01       	movw	r24, r28
    44c0:	01 96       	adiw	r24, 0x01	; 1
    44c2:	b8 01       	movw	r22, r16
    44c4:	0e 94 29 1a 	call	0x3452	; 0x3452 <RawToStr>
}
    44c8:	26 96       	adiw	r28, 0x06	; 6
    44ca:	0f b6       	in	r0, 0x3f	; 63
    44cc:	f8 94       	cli
    44ce:	de bf       	out	0x3e, r29	; 62
    44d0:	0f be       	out	0x3f, r0	; 63
    44d2:	cd bf       	out	0x3d, r28	; 61
    44d4:	cf 91       	pop	r28
    44d6:	df 91       	pop	r29
    44d8:	1f 91       	pop	r17
    44da:	0f 91       	pop	r16
    44dc:	08 95       	ret

000044de <SaveToEEPROM>:
     return Result;
}



char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    44de:	ef 92       	push	r14
    44e0:	ff 92       	push	r15
    44e2:	0f 93       	push	r16
    44e4:	1f 93       	push	r17
    44e6:	df 93       	push	r29
    44e8:	cf 93       	push	r28
    44ea:	cd b7       	in	r28, 0x3d	; 61
    44ec:	de b7       	in	r29, 0x3e	; 62
    44ee:	ac 97       	sbiw	r28, 0x2c	; 44
    44f0:	0f b6       	in	r0, 0x3f	; 63
    44f2:	f8 94       	cli
    44f4:	de bf       	out	0x3e, r29	; 62
    44f6:	0f be       	out	0x3f, r0	; 63
    44f8:	cd bf       	out	0x3d, r28	; 61
    44fa:	9a a7       	std	Y+42, r25	; 0x2a
    44fc:	89 a7       	std	Y+41, r24	; 0x29
    44fe:	7c a7       	std	Y+44, r23	; 0x2c
    4500:	6b a7       	std	Y+43, r22	; 0x2b
    4502:	7a 01       	movw	r14, r20
    4504:	8e 01       	movw	r16, r28
    4506:	05 5d       	subi	r16, 0xD5	; 213
    4508:	1f 4f       	sbci	r17, 0xFF	; 255
    450a:	c8 01       	movw	r24, r16
    450c:	be 01       	movw	r22, r28
    450e:	6f 5f       	subi	r22, 0xFF	; 255
    4510:	7f 4f       	sbci	r23, 0xFF	; 255
    4512:	22 ed       	ldi	r18, 0xD2	; 210
    4514:	33 e1       	ldi	r19, 0x13	; 19
    4516:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    451a:	c8 01       	movw	r24, r16
    451c:	be 01       	movw	r22, r28
    451e:	67 5d       	subi	r22, 0xD7	; 215
    4520:	7f 4f       	sbci	r23, 0xFF	; 255
    4522:	a7 01       	movw	r20, r14
    4524:	2a ed       	ldi	r18, 0xDA	; 218
    4526:	33 e1       	ldi	r19, 0x13	; 19
    4528:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    452c:	ac 96       	adiw	r28, 0x2c	; 44
    452e:	0f b6       	in	r0, 0x3f	; 63
    4530:	f8 94       	cli
    4532:	de bf       	out	0x3e, r29	; 62
    4534:	0f be       	out	0x3f, r0	; 63
    4536:	cd bf       	out	0x3d, r28	; 61
    4538:	cf 91       	pop	r28
    453a:	df 91       	pop	r29
    453c:	1f 91       	pop	r17
    453e:	0f 91       	pop	r16
    4540:	ff 90       	pop	r15
    4542:	ef 90       	pop	r14
    4544:	08 95       	ret

00004546 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    4546:	df 92       	push	r13
    4548:	ef 92       	push	r14
    454a:	ff 92       	push	r15
    454c:	0f 93       	push	r16
    454e:	1f 93       	push	r17
    4550:	df 93       	push	r29
    4552:	cf 93       	push	r28
    4554:	00 d0       	rcall	.+0      	; 0x4556 <SelectMark+0x10>
    4556:	00 d0       	rcall	.+0      	; 0x4558 <SelectMark+0x12>
    4558:	0f 92       	push	r0
    455a:	cd b7       	in	r28, 0x3d	; 61
    455c:	de b7       	in	r29, 0x3e	; 62
    455e:	d8 2e       	mov	r13, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4560:	8e 01       	movw	r16, r28
    4562:	0f 5f       	subi	r16, 0xFF	; 255
    4564:	1f 4f       	sbci	r17, 0xFF	; 255
    4566:	c8 01       	movw	r24, r16
    4568:	60 e4       	ldi	r22, 0x40	; 64
    456a:	70 e0       	ldi	r23, 0x00	; 0
    456c:	45 e0       	ldi	r20, 0x05	; 5
    456e:	50 e0       	ldi	r21, 0x00	; 0
    4570:	22 ed       	ldi	r18, 0xD2	; 210
    4572:	33 e1       	ldi	r19, 0x13	; 19
    4574:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    4578:	ed 2d       	mov	r30, r13
    457a:	21 e0       	ldi	r18, 0x01	; 1
    457c:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    457e:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    4580:	d8 01       	movw	r26, r16
    4582:	8c 91       	ld	r24, X
    4584:	d8 16       	cp	r13, r24
    4586:	49 f4       	brne	.+18     	; 0x459a <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    4588:	c9 01       	movw	r24, r18
    458a:	65 e0       	ldi	r22, 0x05	; 5
    458c:	70 e0       	ldi	r23, 0x00	; 0
    458e:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    4592:	f7 01       	movw	r30, r14
    4594:	e8 0f       	add	r30, r24
    4596:	f9 1f       	adc	r31, r25
    4598:	e0 81       	ld	r30, Z
    459a:	0f 5f       	subi	r16, 0xFF	; 255
    459c:	1f 4f       	sbci	r17, 0xFF	; 255
    459e:	2f 5f       	subi	r18, 0xFF	; 255
    45a0:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    45a2:	26 30       	cpi	r18, 0x06	; 6
    45a4:	31 05       	cpc	r19, r1
    45a6:	61 f7       	brne	.-40     	; 0x4580 <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    45a8:	8e 2f       	mov	r24, r30
    45aa:	0f 90       	pop	r0
    45ac:	0f 90       	pop	r0
    45ae:	0f 90       	pop	r0
    45b0:	0f 90       	pop	r0
    45b2:	0f 90       	pop	r0
    45b4:	cf 91       	pop	r28
    45b6:	df 91       	pop	r29
    45b8:	1f 91       	pop	r17
    45ba:	0f 91       	pop	r16
    45bc:	ff 90       	pop	r15
    45be:	ef 90       	pop	r14
    45c0:	df 90       	pop	r13
    45c2:	08 95       	ret

000045c4 <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    45c4:	cf 92       	push	r12
    45c6:	df 92       	push	r13
    45c8:	ef 92       	push	r14
    45ca:	ff 92       	push	r15
    45cc:	0f 93       	push	r16
    45ce:	1f 93       	push	r17
    45d0:	df 93       	push	r29
    45d2:	cf 93       	push	r28
    45d4:	cd b7       	in	r28, 0x3d	; 61
    45d6:	de b7       	in	r29, 0x3e	; 62
    45d8:	2f 97       	sbiw	r28, 0x0f	; 15
    45da:	0f b6       	in	r0, 0x3f	; 63
    45dc:	f8 94       	cli
    45de:	de bf       	out	0x3e, r29	; 62
    45e0:	0f be       	out	0x3f, r0	; 63
    45e2:	cd bf       	out	0x3d, r28	; 61
    45e4:	e8 2e       	mov	r14, r24
    45e6:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    45e8:	8f 70       	andi	r24, 0x0F	; 15
    45ea:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
     if (FIPAddr>0){
    45ee:	88 23       	and	r24, r24
    45f0:	09 f4       	brne	.+2      	; 0x45f4 <GenerateStandaloneTransData+0x30>
    45f2:	2d c1       	rjmp	.+602    	; 0x484e <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    45f4:	81 50       	subi	r24, 0x01	; 1
    45f6:	c8 2e       	mov	r12, r24
    45f8:	dd 24       	eor	r13, r13
    45fa:	85 e3       	ldi	r24, 0x35	; 53
    45fc:	90 e0       	ldi	r25, 0x00	; 0
    45fe:	c8 9e       	mul	r12, r24
    4600:	f0 01       	movw	r30, r0
    4602:	c9 9e       	mul	r12, r25
    4604:	f0 0d       	add	r31, r0
    4606:	d8 9e       	mul	r13, r24
    4608:	f0 0d       	add	r31, r0
    460a:	11 24       	eor	r1, r1
    460c:	e8 55       	subi	r30, 0x58	; 88
    460e:	fa 4f       	sbci	r31, 0xFA	; 250
    4610:	80 81       	ld	r24, Z
    4612:	08 0f       	add	r16, r24
    4614:	11 1d       	adc	r17, r1
    4616:	d8 01       	movw	r26, r16
    4618:	2c 91       	ld	r18, X
    461a:	ce 01       	movw	r24, r28
    461c:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    461e:	22 23       	and	r18, r18
    4620:	69 f0       	breq	.+26     	; 0x463c <GenerateStandaloneTransData+0x78>
    4622:	6d e0       	ldi	r22, 0x0D	; 13
    4624:	26 9f       	mul	r18, r22
    4626:	b0 01       	movw	r22, r0
    4628:	11 24       	eor	r1, r1
    462a:	62 55       	subi	r22, 0x52	; 82
    462c:	7f 4f       	sbci	r23, 0xFF	; 255
    462e:	4d e0       	ldi	r20, 0x0D	; 13
    4630:	50 e0       	ldi	r21, 0x00	; 0
    4632:	22 ed       	ldi	r18, 0xD2	; 210
    4634:	33 e1       	ldi	r19, 0x13	; 19
    4636:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    463a:	10 c0       	rjmp	.+32     	; 0x465c <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    463c:	00 d0       	rcall	.+0      	; 0x463e <GenerateStandaloneTransData+0x7a>
    463e:	00 d0       	rcall	.+0      	; 0x4640 <GenerateStandaloneTransData+0x7c>
    4640:	ed b7       	in	r30, 0x3d	; 61
    4642:	fe b7       	in	r31, 0x3e	; 62
    4644:	92 83       	std	Z+2, r25	; 0x02
    4646:	81 83       	std	Z+1, r24	; 0x01
    4648:	8c e2       	ldi	r24, 0x2C	; 44
    464a:	94 e2       	ldi	r25, 0x24	; 36
    464c:	94 83       	std	Z+4, r25	; 0x04
    464e:	83 83       	std	Z+3, r24	; 0x03
    4650:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    4654:	0f 90       	pop	r0
    4656:	0f 90       	pop	r0
    4658:	0f 90       	pop	r0
    465a:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    465c:	e1 99       	sbic	0x1c, 1	; 28
    465e:	fe cf       	rjmp	.-4      	; 0x465c <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4660:	80 e0       	ldi	r24, 0x00	; 0
    4662:	90 e0       	ldi	r25, 0x00	; 0
    4664:	9f bb       	out	0x1f, r25	; 31
    4666:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4668:	e0 9a       	sbi	0x1c, 0	; 28
    466a:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    466c:	00 d0       	rcall	.+0      	; 0x466e <GenerateStandaloneTransData+0xaa>
    466e:	00 d0       	rcall	.+0      	; 0x4670 <GenerateStandaloneTransData+0xac>
    4670:	00 d0       	rcall	.+0      	; 0x4672 <GenerateStandaloneTransData+0xae>
    4672:	ad b7       	in	r26, 0x3d	; 61
    4674:	be b7       	in	r27, 0x3e	; 62
    4676:	11 96       	adiw	r26, 0x01	; 1
    4678:	88 e6       	ldi	r24, 0x68	; 104
    467a:	9c e0       	ldi	r25, 0x0C	; 12
    467c:	ed b7       	in	r30, 0x3d	; 61
    467e:	fe b7       	in	r31, 0x3e	; 62
    4680:	92 83       	std	Z+2, r25	; 0x02
    4682:	81 83       	std	Z+1, r24	; 0x01
    4684:	89 e2       	ldi	r24, 0x29	; 41
    4686:	94 e2       	ldi	r25, 0x24	; 36
    4688:	13 96       	adiw	r26, 0x03	; 3
    468a:	9c 93       	st	X, r25
    468c:	8e 93       	st	-X, r24
    468e:	12 97       	sbiw	r26, 0x02	; 2
    4690:	85 e3       	ldi	r24, 0x35	; 53
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	c8 9e       	mul	r12, r24
    4696:	80 01       	movw	r16, r0
    4698:	c9 9e       	mul	r12, r25
    469a:	10 0d       	add	r17, r0
    469c:	d8 9e       	mul	r13, r24
    469e:	10 0d       	add	r17, r0
    46a0:	11 24       	eor	r1, r1
    46a2:	f8 01       	movw	r30, r16
    46a4:	e8 55       	subi	r30, 0x58	; 88
    46a6:	fa 4f       	sbci	r31, 0xFA	; 250
    46a8:	82 81       	ldd	r24, Z+2	; 0x02
    46aa:	14 96       	adiw	r26, 0x04	; 4
    46ac:	8c 93       	st	X, r24
    46ae:	14 97       	sbiw	r26, 0x04	; 4
    46b0:	15 96       	adiw	r26, 0x05	; 5
    46b2:	1c 92       	st	X, r1
    46b4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    46b8:	ed b7       	in	r30, 0x3d	; 61
    46ba:	fe b7       	in	r31, 0x3e	; 62
    46bc:	31 96       	adiw	r30, 0x01	; 1
    46be:	87 e8       	ldi	r24, 0x87	; 135
    46c0:	9c e0       	ldi	r25, 0x0C	; 12
    46c2:	ad b7       	in	r26, 0x3d	; 61
    46c4:	be b7       	in	r27, 0x3e	; 62
    46c6:	12 96       	adiw	r26, 0x02	; 2
    46c8:	9c 93       	st	X, r25
    46ca:	8e 93       	st	-X, r24
    46cc:	11 97       	sbiw	r26, 0x01	; 1
    46ce:	86 e2       	ldi	r24, 0x26	; 38
    46d0:	94 e2       	ldi	r25, 0x24	; 36
    46d2:	93 83       	std	Z+3, r25	; 0x03
    46d4:	82 83       	std	Z+2, r24	; 0x02
    46d6:	c8 01       	movw	r24, r16
    46d8:	85 55       	subi	r24, 0x55	; 85
    46da:	9a 4f       	sbci	r25, 0xFA	; 250
    46dc:	95 83       	std	Z+5, r25	; 0x05
    46de:	84 83       	std	Z+4, r24	; 0x04
    46e0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    46e4:	ed b7       	in	r30, 0x3d	; 61
    46e6:	fe b7       	in	r31, 0x3e	; 62
    46e8:	31 96       	adiw	r30, 0x01	; 1
    46ea:	8e e6       	ldi	r24, 0x6E	; 110
    46ec:	97 e0       	ldi	r25, 0x07	; 7
    46ee:	ad b7       	in	r26, 0x3d	; 61
    46f0:	be b7       	in	r27, 0x3e	; 62
    46f2:	12 96       	adiw	r26, 0x02	; 2
    46f4:	9c 93       	st	X, r25
    46f6:	8e 93       	st	-X, r24
    46f8:	11 97       	sbiw	r26, 0x01	; 1
    46fa:	83 e2       	ldi	r24, 0x23	; 35
    46fc:	94 e2       	ldi	r25, 0x24	; 36
    46fe:	93 83       	std	Z+3, r25	; 0x03
    4700:	82 83       	std	Z+2, r24	; 0x02
    4702:	c8 01       	movw	r24, r16
    4704:	8e 54       	subi	r24, 0x4E	; 78
    4706:	9a 4f       	sbci	r25, 0xFA	; 250
    4708:	95 83       	std	Z+5, r25	; 0x05
    470a:	84 83       	std	Z+4, r24	; 0x04
    470c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    4710:	ed b7       	in	r30, 0x3d	; 61
    4712:	fe b7       	in	r31, 0x3e	; 62
    4714:	31 96       	adiw	r30, 0x01	; 1
    4716:	8d e4       	ldi	r24, 0x4D	; 77
    4718:	93 e0       	ldi	r25, 0x03	; 3
    471a:	ad b7       	in	r26, 0x3d	; 61
    471c:	be b7       	in	r27, 0x3e	; 62
    471e:	12 96       	adiw	r26, 0x02	; 2
    4720:	9c 93       	st	X, r25
    4722:	8e 93       	st	-X, r24
    4724:	11 97       	sbiw	r26, 0x01	; 1
    4726:	80 e2       	ldi	r24, 0x20	; 32
    4728:	94 e2       	ldi	r25, 0x24	; 36
    472a:	93 83       	std	Z+3, r25	; 0x03
    472c:	82 83       	std	Z+2, r24	; 0x02
    472e:	c8 01       	movw	r24, r16
    4730:	85 54       	subi	r24, 0x45	; 69
    4732:	9a 4f       	sbci	r25, 0xFA	; 250
    4734:	95 83       	std	Z+5, r25	; 0x05
    4736:	84 83       	std	Z+4, r24	; 0x04
    4738:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    473c:	ed b7       	in	r30, 0x3d	; 61
    473e:	fe b7       	in	r31, 0x3e	; 62
    4740:	31 96       	adiw	r30, 0x01	; 1
    4742:	87 ef       	ldi	r24, 0xF7	; 247
    4744:	98 e0       	ldi	r25, 0x08	; 8
    4746:	ad b7       	in	r26, 0x3d	; 61
    4748:	be b7       	in	r27, 0x3e	; 62
    474a:	12 96       	adiw	r26, 0x02	; 2
    474c:	9c 93       	st	X, r25
    474e:	8e 93       	st	-X, r24
    4750:	11 97       	sbiw	r26, 0x01	; 1
    4752:	8d e1       	ldi	r24, 0x1D	; 29
    4754:	94 e2       	ldi	r25, 0x24	; 36
    4756:	93 83       	std	Z+3, r25	; 0x03
    4758:	82 83       	std	Z+2, r24	; 0x02
    475a:	f4 82       	std	Z+4, r15	; 0x04
    475c:	15 82       	std	Z+5, r1	; 0x05
    475e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    4762:	ed b7       	in	r30, 0x3d	; 61
    4764:	fe b7       	in	r31, 0x3e	; 62
    4766:	31 96       	adiw	r30, 0x01	; 1
    4768:	89 eb       	ldi	r24, 0xB9	; 185
    476a:	97 e0       	ldi	r25, 0x07	; 7
    476c:	ad b7       	in	r26, 0x3d	; 61
    476e:	be b7       	in	r27, 0x3e	; 62
    4770:	12 96       	adiw	r26, 0x02	; 2
    4772:	9c 93       	st	X, r25
    4774:	8e 93       	st	-X, r24
    4776:	11 97       	sbiw	r26, 0x01	; 1
    4778:	88 e1       	ldi	r24, 0x18	; 24
    477a:	94 e2       	ldi	r25, 0x24	; 36
    477c:	93 83       	std	Z+3, r25	; 0x03
    477e:	82 83       	std	Z+2, r24	; 0x02
    4780:	e4 82       	std	Z+4, r14	; 0x04
    4782:	15 82       	std	Z+5, r1	; 0x05
    4784:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    4788:	ed b7       	in	r30, 0x3d	; 61
    478a:	fe b7       	in	r31, 0x3e	; 62
    478c:	31 96       	adiw	r30, 0x01	; 1
    478e:	8c e0       	ldi	r24, 0x0C	; 12
    4790:	98 e0       	ldi	r25, 0x08	; 8
    4792:	ad b7       	in	r26, 0x3d	; 61
    4794:	be b7       	in	r27, 0x3e	; 62
    4796:	12 96       	adiw	r26, 0x02	; 2
    4798:	9c 93       	st	X, r25
    479a:	8e 93       	st	-X, r24
    479c:	11 97       	sbiw	r26, 0x01	; 1
    479e:	85 e1       	ldi	r24, 0x15	; 21
    47a0:	94 e2       	ldi	r25, 0x24	; 36
    47a2:	93 83       	std	Z+3, r25	; 0x03
    47a4:	82 83       	std	Z+2, r24	; 0x02
    47a6:	ce 01       	movw	r24, r28
    47a8:	01 96       	adiw	r24, 0x01	; 1
    47aa:	95 83       	std	Z+5, r25	; 0x05
    47ac:	84 83       	std	Z+4, r24	; 0x04
    47ae:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    47b2:	ed b7       	in	r30, 0x3d	; 61
    47b4:	fe b7       	in	r31, 0x3e	; 62
    47b6:	31 96       	adiw	r30, 0x01	; 1
    47b8:	8e e9       	ldi	r24, 0x9E	; 158
    47ba:	95 e0       	ldi	r25, 0x05	; 5
    47bc:	ad b7       	in	r26, 0x3d	; 61
    47be:	be b7       	in	r27, 0x3e	; 62
    47c0:	12 96       	adiw	r26, 0x02	; 2
    47c2:	9c 93       	st	X, r25
    47c4:	8e 93       	st	-X, r24
    47c6:	11 97       	sbiw	r26, 0x01	; 1
    47c8:	82 e1       	ldi	r24, 0x12	; 18
    47ca:	94 e2       	ldi	r25, 0x24	; 36
    47cc:	93 83       	std	Z+3, r25	; 0x03
    47ce:	82 83       	std	Z+2, r24	; 0x02
    47d0:	c8 01       	movw	r24, r16
    47d2:	8c 53       	subi	r24, 0x3C	; 60
    47d4:	9a 4f       	sbci	r25, 0xFA	; 250
    47d6:	95 83       	std	Z+5, r25	; 0x05
    47d8:	84 83       	std	Z+4, r24	; 0x04
    47da:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    47de:	ed b7       	in	r30, 0x3d	; 61
    47e0:	fe b7       	in	r31, 0x3e	; 62
    47e2:	31 96       	adiw	r30, 0x01	; 1
    47e4:	85 e7       	ldi	r24, 0x75	; 117
    47e6:	93 e0       	ldi	r25, 0x03	; 3
    47e8:	ad b7       	in	r26, 0x3d	; 61
    47ea:	be b7       	in	r27, 0x3e	; 62
    47ec:	12 96       	adiw	r26, 0x02	; 2
    47ee:	9c 93       	st	X, r25
    47f0:	8e 93       	st	-X, r24
    47f2:	11 97       	sbiw	r26, 0x01	; 1
    47f4:	8f e0       	ldi	r24, 0x0F	; 15
    47f6:	94 e2       	ldi	r25, 0x24	; 36
    47f8:	93 83       	std	Z+3, r25	; 0x03
    47fa:	82 83       	std	Z+2, r24	; 0x02
    47fc:	c8 01       	movw	r24, r16
    47fe:	85 53       	subi	r24, 0x35	; 53
    4800:	9a 4f       	sbci	r25, 0xFA	; 250
    4802:	95 83       	std	Z+5, r25	; 0x05
    4804:	84 83       	std	Z+4, r24	; 0x04
    4806:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    480a:	ed b7       	in	r30, 0x3d	; 61
    480c:	fe b7       	in	r31, 0x3e	; 62
    480e:	31 96       	adiw	r30, 0x01	; 1
    4810:	83 eb       	ldi	r24, 0xB3	; 179
    4812:	9b e0       	ldi	r25, 0x0B	; 11
    4814:	ad b7       	in	r26, 0x3d	; 61
    4816:	be b7       	in	r27, 0x3e	; 62
    4818:	12 96       	adiw	r26, 0x02	; 2
    481a:	9c 93       	st	X, r25
    481c:	8e 93       	st	-X, r24
    481e:	11 97       	sbiw	r26, 0x01	; 1
    4820:	8c e0       	ldi	r24, 0x0C	; 12
    4822:	94 e2       	ldi	r25, 0x24	; 36
    4824:	93 83       	std	Z+3, r25	; 0x03
    4826:	82 83       	std	Z+2, r24	; 0x02
    4828:	0c 52       	subi	r16, 0x2C	; 44
    482a:	1a 4f       	sbci	r17, 0xFA	; 250
    482c:	15 83       	std	Z+5, r17	; 0x05
    482e:	04 83       	std	Z+4, r16	; 0x04
    4830:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>

		 MOPType=MOP_CASH;
    4834:	10 92 b8 01 	sts	0x01B8, r1
	     IsPrinting=True;	 
    4838:	81 e0       	ldi	r24, 0x01	; 1
    483a:	80 93 ac 01 	sts	0x01AC, r24
    483e:	ed b7       	in	r30, 0x3d	; 61
    4840:	fe b7       	in	r31, 0x3e	; 62
    4842:	36 96       	adiw	r30, 0x06	; 6
    4844:	0f b6       	in	r0, 0x3f	; 63
    4846:	f8 94       	cli
    4848:	fe bf       	out	0x3e, r31	; 62
    484a:	0f be       	out	0x3f, r0	; 63
    484c:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    484e:	2f 96       	adiw	r28, 0x0f	; 15
    4850:	0f b6       	in	r0, 0x3f	; 63
    4852:	f8 94       	cli
    4854:	de bf       	out	0x3e, r29	; 62
    4856:	0f be       	out	0x3f, r0	; 63
    4858:	cd bf       	out	0x3d, r28	; 61
    485a:	cf 91       	pop	r28
    485c:	df 91       	pop	r29
    485e:	1f 91       	pop	r17
    4860:	0f 91       	pop	r16
    4862:	ff 90       	pop	r15
    4864:	ef 90       	pop	r14
    4866:	df 90       	pop	r13
    4868:	cf 90       	pop	r12
    486a:	08 95       	ret

0000486c <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    486c:	ef 92       	push	r14
    486e:	ff 92       	push	r15
    4870:	0f 93       	push	r16
    4872:	1f 93       	push	r17
    4874:	df 93       	push	r29
    4876:	cf 93       	push	r28
    4878:	00 d0       	rcall	.+0      	; 0x487a <PrintStandalone+0xe>
    487a:	00 d0       	rcall	.+0      	; 0x487c <PrintStandalone+0x10>
    487c:	00 d0       	rcall	.+0      	; 0x487e <PrintStandalone+0x12>
    487e:	cd b7       	in	r28, 0x3d	; 61
    4880:	de b7       	in	r29, 0x3e	; 62
    4882:	f8 2e       	mov	r15, r24
    4884:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    4886:	0e 94 e5 21 	call	0x43ca	; 0x43ca <GetPumpID>
    488a:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    488c:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
    4890:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    4892:	88 23       	and	r24, r24
    4894:	99 f1       	breq	.+102    	; 0x48fc <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    4896:	01 30       	cpi	r16, 0x01	; 1
    4898:	69 f0       	breq	.+26     	; 0x48b4 <PrintStandalone+0x48>
    489a:	ee 20       	and	r14, r14
    489c:	79 f1       	breq	.+94     	; 0x48fc <PrintStandalone+0x90>
    489e:	80 e1       	ldi	r24, 0x10	; 16
    48a0:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    48a4:	11 50       	subi	r17, 0x01	; 1
    48a6:	e1 2f       	mov	r30, r17
    48a8:	f0 e0       	ldi	r31, 0x00	; 0
    48aa:	ee 5f       	subi	r30, 0xFE	; 254
    48ac:	fe 4f       	sbci	r31, 0xFE	; 254
    48ae:	90 81       	ld	r25, Z
    48b0:	98 17       	cp	r25, r24
    48b2:	21 f5       	brne	.+72     	; 0x48fc <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    48b4:	66 e0       	ldi	r22, 0x06	; 6
    48b6:	f6 9e       	mul	r15, r22
    48b8:	b0 01       	movw	r22, r0
    48ba:	11 24       	eor	r1, r1
    48bc:	61 5b       	subi	r22, 0xB1	; 177
    48be:	7f 4f       	sbci	r23, 0xFF	; 255
    48c0:	ce 01       	movw	r24, r28
    48c2:	01 96       	adiw	r24, 0x01	; 1
    48c4:	46 e0       	ldi	r20, 0x06	; 6
    48c6:	50 e0       	ldi	r21, 0x00	; 0
    48c8:	22 ed       	ldi	r18, 0xD2	; 210
    48ca:	33 e1       	ldi	r19, 0x13	; 19
    48cc:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    48d0:	ef 2d       	mov	r30, r15
    48d2:	f0 e0       	ldi	r31, 0x00	; 0
    48d4:	ee 5e       	subi	r30, 0xEE	; 238
    48d6:	fe 4f       	sbci	r31, 0xFE	; 254
    48d8:	80 81       	ld	r24, Z
    48da:	81 30       	cpi	r24, 0x01	; 1
    48dc:	19 f0       	breq	.+6      	; 0x48e4 <PrintStandalone+0x78>
    48de:	00 23       	and	r16, r16
    48e0:	29 f0       	breq	.+10     	; 0x48ec <PrintStandalone+0x80>
    48e2:	0c c0       	rjmp	.+24     	; 0x48fc <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    48e4:	01 30       	cpi	r16, 0x01	; 1
    48e6:	11 f4       	brne	.+4      	; 0x48ec <PrintStandalone+0x80>
    48e8:	00 93 7f 01 	sts	0x017F, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    48ec:	8e 2d       	mov	r24, r14
    48ee:	be 01       	movw	r22, r28
    48f0:	6f 5f       	subi	r22, 0xFF	; 255
    48f2:	7f 4f       	sbci	r23, 0xFF	; 255
    48f4:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <GenerateStandaloneTransData>
    48f8:	81 e1       	ldi	r24, 0x11	; 17
    48fa:	01 c0       	rjmp	.+2      	; 0x48fe <PrintStandalone+0x92>
    48fc:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    48fe:	26 96       	adiw	r28, 0x06	; 6
    4900:	0f b6       	in	r0, 0x3f	; 63
    4902:	f8 94       	cli
    4904:	de bf       	out	0x3e, r29	; 62
    4906:	0f be       	out	0x3f, r0	; 63
    4908:	cd bf       	out	0x3d, r28	; 61
    490a:	cf 91       	pop	r28
    490c:	df 91       	pop	r29
    490e:	1f 91       	pop	r17
    4910:	0f 91       	pop	r16
    4912:	ff 90       	pop	r15
    4914:	ef 90       	pop	r14
    4916:	08 95       	ret

00004918 <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    4918:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    491a:	dc 01       	movw	r26, r24
    491c:	0d 90       	ld	r0, X+
    491e:	00 20       	and	r0, r0
    4920:	e9 f7       	brne	.-6      	; 0x491c <SumChecksum+0x4>
    4922:	11 97       	sbiw	r26, 0x01	; 1
    4924:	a8 1b       	sub	r26, r24
    4926:	b9 0b       	sbc	r27, r25
    4928:	20 e0       	ldi	r18, 0x00	; 0
    492a:	30 e0       	ldi	r19, 0x00	; 0
    492c:	90 e0       	ldi	r25, 0x00	; 0
    492e:	06 c0       	rjmp	.+12     	; 0x493c <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    4930:	e4 0f       	add	r30, r20
    4932:	f5 1f       	adc	r31, r21
    4934:	80 81       	ld	r24, Z
    4936:	28 0f       	add	r18, r24
    4938:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    493a:	9f 5f       	subi	r25, 0xFF	; 255
    493c:	e9 2f       	mov	r30, r25
    493e:	f0 e0       	ldi	r31, 0x00	; 0
    4940:	ea 17       	cp	r30, r26
    4942:	fb 07       	cpc	r31, r27
    4944:	a8 f3       	brcs	.-22     	; 0x4930 <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    4946:	c9 01       	movw	r24, r18
    4948:	6f ef       	ldi	r22, 0xFF	; 255
    494a:	70 e0       	ldi	r23, 0x00	; 0
    494c:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
	 if (Result==0)Result=255;
    4950:	88 23       	and	r24, r24
    4952:	09 f4       	brne	.+2      	; 0x4956 <SumChecksum+0x3e>
    4954:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    4956:	08 95       	ret

00004958 <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    4958:	ff 92       	push	r15
    495a:	0f 93       	push	r16
    495c:	1f 93       	push	r17
    495e:	df 93       	push	r29
    4960:	cf 93       	push	r28
    4962:	cd b7       	in	r28, 0x3d	; 61
    4964:	de b7       	in	r29, 0x3e	; 62
    4966:	2a 97       	sbiw	r28, 0x0a	; 10
    4968:	0f b6       	in	r0, 0x3f	; 63
    496a:	f8 94       	cli
    496c:	de bf       	out	0x3e, r29	; 62
    496e:	0f be       	out	0x3f, r0	; 63
    4970:	cd bf       	out	0x3d, r28	; 61
    4972:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    4974:	00 d0       	rcall	.+0      	; 0x4976 <IsGeniusCommand+0x1e>
    4976:	00 d0       	rcall	.+0      	; 0x4978 <IsGeniusCommand+0x20>
    4978:	8e 01       	movw	r16, r28
    497a:	0f 5f       	subi	r16, 0xFF	; 255
    497c:	1f 4f       	sbci	r17, 0xFF	; 255
    497e:	ed b7       	in	r30, 0x3d	; 61
    4980:	fe b7       	in	r31, 0x3e	; 62
    4982:	12 83       	std	Z+2, r17	; 0x02
    4984:	01 83       	std	Z+1, r16	; 0x01
    4986:	87 e5       	ldi	r24, 0x57	; 87
    4988:	95 e0       	ldi	r25, 0x05	; 5
    498a:	94 83       	std	Z+4, r25	; 0x04
    498c:	83 83       	std	Z+3, r24	; 0x03
    498e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    4992:	d8 01       	movw	r26, r16
    4994:	0d 90       	ld	r0, X+
    4996:	00 20       	and	r0, r0
    4998:	e9 f7       	brne	.-6      	; 0x4994 <IsGeniusCommand+0x3c>
    499a:	11 97       	sbiw	r26, 0x01	; 1
    499c:	a0 1b       	sub	r26, r16
    499e:	b1 0b       	sbc	r27, r17
    49a0:	90 e0       	ldi	r25, 0x00	; 0
    49a2:	0f 90       	pop	r0
    49a4:	0f 90       	pop	r0
    49a6:	0f 90       	pop	r0
    49a8:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    49aa:	98 01       	movw	r18, r16
    49ac:	08 c0       	rjmp	.+16     	; 0x49be <IsGeniusCommand+0x66>
    49ae:	e2 0f       	add	r30, r18
    49b0:	f3 1f       	adc	r31, r19
    49b2:	80 81       	ld	r24, Z
    49b4:	8f 15       	cp	r24, r15
    49b6:	11 f4       	brne	.+4      	; 0x49bc <IsGeniusCommand+0x64>
    49b8:	81 e0       	ldi	r24, 0x01	; 1
    49ba:	07 c0       	rjmp	.+14     	; 0x49ca <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    49bc:	9f 5f       	subi	r25, 0xFF	; 255
    49be:	e9 2f       	mov	r30, r25
    49c0:	f0 e0       	ldi	r31, 0x00	; 0
    49c2:	ea 17       	cp	r30, r26
    49c4:	fb 07       	cpc	r31, r27
    49c6:	98 f3       	brcs	.-26     	; 0x49ae <IsGeniusCommand+0x56>
    49c8:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    49ca:	2a 96       	adiw	r28, 0x0a	; 10
    49cc:	0f b6       	in	r0, 0x3f	; 63
    49ce:	f8 94       	cli
    49d0:	de bf       	out	0x3e, r29	; 62
    49d2:	0f be       	out	0x3f, r0	; 63
    49d4:	cd bf       	out	0x3d, r28	; 61
    49d6:	cf 91       	pop	r28
    49d8:	df 91       	pop	r29
    49da:	1f 91       	pop	r17
    49dc:	0f 91       	pop	r16
    49de:	ff 90       	pop	r15
    49e0:	08 95       	ret

000049e2 <Pos>:
  */
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    49e2:	0f 93       	push	r16
    49e4:	1f 93       	push	r17
    49e6:	cf 93       	push	r28
    49e8:	df 93       	push	r29
    49ea:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    49ec:	fb 01       	movw	r30, r22
    49ee:	01 90       	ld	r0, Z+
    49f0:	00 20       	and	r0, r0
    49f2:	e9 f7       	brne	.-6      	; 0x49ee <Pos+0xc>
    49f4:	31 97       	sbiw	r30, 0x01	; 1
    49f6:	1e 2f       	mov	r17, r30
    49f8:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    49fa:	fc 01       	movw	r30, r24
    49fc:	01 90       	ld	r0, Z+
    49fe:	00 20       	and	r0, r0
    4a00:	e9 f7       	brne	.-6      	; 0x49fc <Pos+0x1a>
    4a02:	31 97       	sbiw	r30, 0x01	; 1
    4a04:	0e 2f       	mov	r16, r30
    4a06:	08 1b       	sub	r16, r24
    4a08:	db 01       	movw	r26, r22
    4a0a:	60 e0       	ldi	r22, 0x00	; 0
    4a0c:	18 c0       	rjmp	.+48     	; 0x4a3e <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    4a0e:	9c 91       	ld	r25, X
    4a10:	fa 01       	movw	r30, r20
    4a12:	80 81       	ld	r24, Z
    4a14:	98 17       	cp	r25, r24
    4a16:	89 f4       	brne	.+34     	; 0x4a3a <Pos+0x58>
    4a18:	ed 01       	movw	r28, r26
    4a1a:	20 e0       	ldi	r18, 0x00	; 0
    4a1c:	30 e0       	ldi	r19, 0x00	; 0
    4a1e:	09 c0       	rjmp	.+18     	; 0x4a32 <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    4a20:	fa 01       	movw	r30, r20
    4a22:	e2 0f       	add	r30, r18
    4a24:	f3 1f       	adc	r31, r19
    4a26:	90 81       	ld	r25, Z
    4a28:	89 91       	ld	r24, Y+
    4a2a:	2f 5f       	subi	r18, 0xFF	; 255
    4a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    4a2e:	98 17       	cp	r25, r24
    4a30:	21 f4       	brne	.+8      	; 0x4a3a <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    4a32:	20 17       	cp	r18, r16
    4a34:	a8 f3       	brcs	.-22     	; 0x4a20 <Pos+0x3e>
    4a36:	86 2f       	mov	r24, r22
    4a38:	05 c0       	rjmp	.+10     	; 0x4a44 <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    4a3a:	6f 5f       	subi	r22, 0xFF	; 255
    4a3c:	11 96       	adiw	r26, 0x01	; 1
    4a3e:	61 17       	cp	r22, r17
    4a40:	30 f3       	brcs	.-52     	; 0x4a0e <Pos+0x2c>
    4a42:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    4a44:	90 e0       	ldi	r25, 0x00	; 0
    4a46:	df 91       	pop	r29
    4a48:	cf 91       	pop	r28
    4a4a:	1f 91       	pop	r17
    4a4c:	0f 91       	pop	r16
    4a4e:	08 95       	ret

00004a50 <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    4a50:	7f 92       	push	r7
    4a52:	8f 92       	push	r8
    4a54:	9f 92       	push	r9
    4a56:	af 92       	push	r10
    4a58:	bf 92       	push	r11
    4a5a:	cf 92       	push	r12
    4a5c:	df 92       	push	r13
    4a5e:	ef 92       	push	r14
    4a60:	ff 92       	push	r15
    4a62:	0f 93       	push	r16
    4a64:	1f 93       	push	r17
    4a66:	cf 93       	push	r28
    4a68:	df 93       	push	r29
    4a6a:	5c 01       	movw	r10, r24
    4a6c:	6b 01       	movw	r12, r22
    4a6e:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    4a70:	ec 01       	movw	r28, r24
    4a72:	09 90       	ld	r0, Y+
    4a74:	00 20       	and	r0, r0
    4a76:	e9 f7       	brne	.-6      	; 0x4a72 <CreateReport+0x22>
    4a78:	21 97       	sbiw	r28, 0x01	; 1
    4a7a:	c8 1b       	sub	r28, r24
    4a7c:	d9 0b       	sbc	r29, r25
    4a7e:	cb 32       	cpi	r28, 0x2B	; 43
    4a80:	d1 05       	cpc	r29, r1
    4a82:	10 f0       	brcs	.+4      	; 0x4a88 <CreateReport+0x38>
    4a84:	ca e2       	ldi	r28, 0x2A	; 42
    4a86:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    4a88:	f4 01       	movw	r30, r8
    4a8a:	00 81       	ld	r16, Z
    4a8c:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4a8e:	76 01       	movw	r14, r12
    4a90:	e0 0e       	add	r14, r16
    4a92:	f1 1e       	adc	r15, r17
    4a94:	8a e0       	ldi	r24, 0x0A	; 10
    4a96:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <GetBorderValue>
    4a9a:	78 2e       	mov	r7, r24
    4a9c:	f7 01       	movw	r30, r14
    4a9e:	80 83       	st	Z, r24
     iPos++;
    4aa0:	98 01       	movw	r18, r16
    4aa2:	2f 5f       	subi	r18, 0xFF	; 255
    4aa4:	3f 4f       	sbci	r19, 0xFF	; 255
    4aa6:	d7 01       	movw	r26, r14
    4aa8:	90 e0       	ldi	r25, 0x00	; 0
    4aaa:	07 c0       	rjmp	.+14     	; 0x4aba <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    4aac:	ea 0d       	add	r30, r10
    4aae:	fb 1d       	adc	r31, r11
    4ab0:	80 81       	ld	r24, Z
    4ab2:	8c 93       	st	X, r24
		  iPos++;
    4ab4:	2f 5f       	subi	r18, 0xFF	; 255
    4ab6:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    4ab8:	9f 5f       	subi	r25, 0xFF	; 255
    4aba:	e9 2f       	mov	r30, r25
    4abc:	f0 e0       	ldi	r31, 0x00	; 0
    4abe:	11 96       	adiw	r26, 0x01	; 1
    4ac0:	ec 17       	cp	r30, r28
    4ac2:	fd 07       	cpc	r31, r29
    4ac4:	98 f3       	brcs	.-26     	; 0x4aac <CreateReport+0x5c>
    4ac6:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    4ac8:	ca 32       	cpi	r28, 0x2A	; 42
    4aca:	d1 05       	cpc	r29, r1
    4acc:	91 f0       	breq	.+36     	; 0x4af2 <CreateReport+0xa2>
    4ace:	f6 01       	movw	r30, r12
    4ad0:	e2 0f       	add	r30, r18
    4ad2:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    4ad4:	4a e2       	ldi	r20, 0x2A	; 42
    4ad6:	50 e0       	ldi	r21, 0x00	; 0
    4ad8:	4c 1b       	sub	r20, r28
    4ada:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    4adc:	70 e2       	ldi	r23, 0x20	; 32
    4ade:	03 c0       	rjmp	.+6      	; 0x4ae6 <CreateReport+0x96>
    4ae0:	71 93       	st	Z+, r23
		      iPos++;
    4ae2:	2f 5f       	subi	r18, 0xFF	; 255
    4ae4:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    4ae6:	82 2f       	mov	r24, r18
    4ae8:	86 1b       	sub	r24, r22
    4aea:	90 e0       	ldi	r25, 0x00	; 0
    4aec:	84 17       	cp	r24, r20
    4aee:	95 07       	cpc	r25, r21
    4af0:	b8 f3       	brcs	.-18     	; 0x4ae0 <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4af2:	f6 01       	movw	r30, r12
    4af4:	e2 0f       	add	r30, r18
    4af6:	f3 1f       	adc	r31, r19
    4af8:	70 82       	st	Z, r7
     iPos++;
    4afa:	c9 01       	movw	r24, r18
    4afc:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    4afe:	c8 0e       	add	r12, r24
    4b00:	d9 1e       	adc	r13, r25
    4b02:	2d e0       	ldi	r18, 0x0D	; 13
    4b04:	f6 01       	movw	r30, r12
    4b06:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    4b08:	01 96       	adiw	r24, 0x01	; 1
    4b0a:	f4 01       	movw	r30, r8
    4b0c:	91 83       	std	Z+1, r25	; 0x01
    4b0e:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//uart_print(0,1,strSend);
}
    4b10:	df 91       	pop	r29
    4b12:	cf 91       	pop	r28
    4b14:	1f 91       	pop	r17
    4b16:	0f 91       	pop	r16
    4b18:	ff 90       	pop	r15
    4b1a:	ef 90       	pop	r14
    4b1c:	df 90       	pop	r13
    4b1e:	cf 90       	pop	r12
    4b20:	bf 90       	pop	r11
    4b22:	af 90       	pop	r10
    4b24:	9f 90       	pop	r9
    4b26:	8f 90       	pop	r8
    4b28:	7f 90       	pop	r7
    4b2a:	08 95       	ret

00004b2c <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    4b2c:	38 2f       	mov	r19, r24
    4b2e:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    4b30:	81 50       	subi	r24, 0x01	; 1
    4b32:	86 30       	cpi	r24, 0x06	; 6
    4b34:	68 f5       	brcc	.+90     	; 0x4b90 <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    4b36:	fb 01       	movw	r30, r22
    4b38:	01 90       	ld	r0, Z+
    4b3a:	00 20       	and	r0, r0
    4b3c:	e9 f7       	brne	.-6      	; 0x4b38 <AddList+0xc>
    4b3e:	31 97       	sbiw	r30, 0x01	; 1
    4b40:	e6 1b       	sub	r30, r22
    4b42:	f7 0b       	sbc	r31, r23
    4b44:	7e 2f       	mov	r23, r30
	     if (Length>0){
    4b46:	ee 23       	and	r30, r30
    4b48:	11 f4       	brne	.+4      	; 0x4b4e <AddList+0x22>
    4b4a:	20 e0       	ldi	r18, 0x00	; 0
    4b4c:	14 c0       	rjmp	.+40     	; 0x4b76 <AddList+0x4a>
    4b4e:	80 e0       	ldi	r24, 0x00	; 0
    4b50:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    4b52:	63 2f       	mov	r22, r19
    4b54:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4b56:	fa 01       	movw	r30, r20
    4b58:	e8 0f       	add	r30, r24
    4b5a:	f9 1f       	adc	r31, r25
    4b5c:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4b5e:	3a 30       	cpi	r19, 0x0A	; 10
    4b60:	10 f0       	brcs	.+4      	; 0x4b66 <AddList+0x3a>
    4b62:	20 e3       	ldi	r18, 0x30	; 48
    4b64:	01 c0       	rjmp	.+2      	; 0x4b68 <AddList+0x3c>
	    Result='0'+X;
    4b66:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4b68:	e2 17       	cp	r30, r18
    4b6a:	91 f0       	breq	.+36     	; 0x4b90 <AddList+0x64>
    4b6c:	28 2f       	mov	r18, r24
    4b6e:	2f 5f       	subi	r18, 0xFF	; 255
    4b70:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    4b72:	87 17       	cp	r24, r23
    4b74:	80 f3       	brcs	.-32     	; 0x4b56 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4b76:	62 2f       	mov	r22, r18
    4b78:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4b7a:	3a 30       	cpi	r19, 0x0A	; 10
    4b7c:	10 f0       	brcs	.+4      	; 0x4b82 <AddList+0x56>
    4b7e:	80 e3       	ldi	r24, 0x30	; 48
    4b80:	02 c0       	rjmp	.+4      	; 0x4b86 <AddList+0x5a>
	    Result='0'+X;
    4b82:	83 2f       	mov	r24, r19
    4b84:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4b86:	fa 01       	movw	r30, r20
    4b88:	e6 0f       	add	r30, r22
    4b8a:	f7 1f       	adc	r31, r23
    4b8c:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    4b8e:	11 82       	std	Z+1, r1	; 0x01
    4b90:	08 95       	ret

00004b92 <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    4b92:	dc 01       	movw	r26, r24
    4b94:	0d 90       	ld	r0, X+
    4b96:	00 20       	and	r0, r0
    4b98:	e9 f7       	brne	.-6      	; 0x4b94 <ClearList+0x2>
    4b9a:	11 97       	sbiw	r26, 0x01	; 1
    4b9c:	a8 1b       	sub	r26, r24
    4b9e:	b9 0b       	sbc	r27, r25
    4ba0:	20 e0       	ldi	r18, 0x00	; 0
    4ba2:	30 e0       	ldi	r19, 0x00	; 0
    4ba4:	06 c0       	rjmp	.+12     	; 0x4bb2 <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4ba6:	fc 01       	movw	r30, r24
    4ba8:	e2 0f       	add	r30, r18
    4baa:	f3 1f       	adc	r31, r19
    4bac:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4bae:	2f 5f       	subi	r18, 0xFF	; 255
    4bb0:	3f 4f       	sbci	r19, 0xFF	; 255
    4bb2:	2a 17       	cp	r18, r26
    4bb4:	3b 07       	cpc	r19, r27
    4bb6:	b8 f3       	brcs	.-18     	; 0x4ba6 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    4bb8:	08 95       	ret

00004bba <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    4bba:	6f 92       	push	r6
    4bbc:	7f 92       	push	r7
    4bbe:	8f 92       	push	r8
    4bc0:	9f 92       	push	r9
    4bc2:	bf 92       	push	r11
    4bc4:	cf 92       	push	r12
    4bc6:	df 92       	push	r13
    4bc8:	ef 92       	push	r14
    4bca:	ff 92       	push	r15
    4bcc:	0f 93       	push	r16
    4bce:	1f 93       	push	r17
    4bd0:	df 93       	push	r29
    4bd2:	cf 93       	push	r28
    4bd4:	cd b7       	in	r28, 0x3d	; 61
    4bd6:	de b7       	in	r29, 0x3e	; 62
    4bd8:	64 97       	sbiw	r28, 0x14	; 20
    4bda:	0f b6       	in	r0, 0x3f	; 63
    4bdc:	f8 94       	cli
    4bde:	de bf       	out	0x3e, r29	; 62
    4be0:	0f be       	out	0x3f, r0	; 63
    4be2:	cd bf       	out	0x3d, r28	; 61
    4be4:	7c 01       	movw	r14, r24
    4be6:	6a 01       	movw	r12, r20
    4be8:	bb 24       	eor	r11, r11
    4bea:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    4bec:	06 2f       	mov	r16, r22
    4bee:	10 e0       	ldi	r17, 0x00	; 0
    4bf0:	00 53       	subi	r16, 0x30	; 48
    4bf2:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    4bf4:	3e 01       	movw	r6, r28
    4bf6:	08 94       	sec
    4bf8:	61 1c       	adc	r6, r1
    4bfa:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    4bfc:	e2 e0       	ldi	r30, 0x02	; 2
    4bfe:	8e 2e       	mov	r8, r30
    4c00:	91 2c       	mov	r9, r1
    4c02:	8c 0e       	add	r8, r28
    4c04:	9d 1e       	adc	r9, r29
    4c06:	24 c0       	rjmp	.+72     	; 0x4c50 <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    4c08:	11 97       	sbiw	r26, 0x01	; 1
    4c0a:	a4 1b       	sub	r26, r20
    4c0c:	b5 0b       	sbc	r27, r21
    4c0e:	ae 0d       	add	r26, r14
    4c10:	bf 1d       	adc	r27, r15
    4c12:	8c 91       	ld	r24, X
    4c14:	90 e0       	ldi	r25, 0x00	; 0
    4c16:	c0 97       	sbiw	r24, 0x30	; 48
    4c18:	bc 01       	movw	r22, r24
    4c1a:	60 9f       	mul	r22, r16
    4c1c:	c0 01       	movw	r24, r0
    4c1e:	61 9f       	mul	r22, r17
    4c20:	90 0d       	add	r25, r0
    4c22:	70 9f       	mul	r23, r16
    4c24:	90 0d       	add	r25, r0
    4c26:	11 24       	eor	r1, r1
    4c28:	23 2f       	mov	r18, r19
    4c2a:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    4c2c:	82 2f       	mov	r24, r18
    4c2e:	6a e0       	ldi	r22, 0x0A	; 10
    4c30:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    4c34:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    4c36:	f3 01       	movw	r30, r6
    4c38:	e4 0f       	add	r30, r20
    4c3a:	f5 1f       	adc	r31, r21
    4c3c:	82 2f       	mov	r24, r18
    4c3e:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    4c42:	90 5d       	subi	r25, 0xD0	; 208
    4c44:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4c46:	48 0d       	add	r20, r8
    4c48:	59 1d       	adc	r21, r9
    4c4a:	fa 01       	movw	r30, r20
    4c4c:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    4c4e:	b3 94       	inc	r11
    4c50:	4b 2d       	mov	r20, r11
    4c52:	50 e0       	ldi	r21, 0x00	; 0
    4c54:	d7 01       	movw	r26, r14
    4c56:	0d 90       	ld	r0, X+
    4c58:	00 20       	and	r0, r0
    4c5a:	e9 f7       	brne	.-6      	; 0x4c56 <CalcSegmen+0x9c>
    4c5c:	11 97       	sbiw	r26, 0x01	; 1
    4c5e:	ae 19       	sub	r26, r14
    4c60:	bf 09       	sbc	r27, r15
    4c62:	4a 17       	cp	r20, r26
    4c64:	5b 07       	cpc	r21, r27
    4c66:	80 f2       	brcs	.-96     	; 0x4c08 <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    4c68:	33 23       	and	r19, r19
    4c6a:	89 f0       	breq	.+34     	; 0x4c8e <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    4c6c:	fe 01       	movw	r30, r28
    4c6e:	31 96       	adiw	r30, 0x01	; 1
    4c70:	df 01       	movw	r26, r30
    4c72:	0d 90       	ld	r0, X+
    4c74:	00 20       	and	r0, r0
    4c76:	e9 f7       	brne	.-6      	; 0x4c72 <CalcSegmen+0xb8>
    4c78:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    4c7a:	ae 1b       	sub	r26, r30
    4c7c:	b0 e0       	ldi	r27, 0x00	; 0
    4c7e:	ea 0f       	add	r30, r26
    4c80:	fb 1f       	adc	r31, r27
    4c82:	30 5d       	subi	r19, 0xD0	; 208
    4c84:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4c86:	ac 0f       	add	r26, r28
    4c88:	bd 1f       	adc	r27, r29
    4c8a:	12 96       	adiw	r26, 0x02	; 2
    4c8c:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    4c8e:	de 01       	movw	r26, r28
    4c90:	11 96       	adiw	r26, 0x01	; 1
    4c92:	fd 01       	movw	r30, r26
    4c94:	01 90       	ld	r0, Z+
    4c96:	00 20       	and	r0, r0
    4c98:	e9 f7       	brne	.-6      	; 0x4c94 <CalcSegmen+0xda>
    4c9a:	31 97       	sbiw	r30, 0x01	; 1
    4c9c:	9e 2f       	mov	r25, r30
    4c9e:	9a 1b       	sub	r25, r26
    4ca0:	a9 0f       	add	r26, r25
    4ca2:	b1 1d       	adc	r27, r1
    4ca4:	f6 01       	movw	r30, r12
    4ca6:	02 c0       	rjmp	.+4      	; 0x4cac <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    4ca8:	8c 91       	ld	r24, X
    4caa:	81 93       	st	Z+, r24
    4cac:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    4cae:	ac 17       	cp	r26, r28
    4cb0:	bd 07       	cpc	r27, r29
    4cb2:	d1 f7       	brne	.-12     	; 0x4ca8 <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    4cb4:	c9 0e       	add	r12, r25
    4cb6:	d1 1c       	adc	r13, r1
    4cb8:	f6 01       	movw	r30, r12
    4cba:	10 82       	st	Z, r1
}
    4cbc:	64 96       	adiw	r28, 0x14	; 20
    4cbe:	0f b6       	in	r0, 0x3f	; 63
    4cc0:	f8 94       	cli
    4cc2:	de bf       	out	0x3e, r29	; 62
    4cc4:	0f be       	out	0x3f, r0	; 63
    4cc6:	cd bf       	out	0x3d, r28	; 61
    4cc8:	cf 91       	pop	r28
    4cca:	df 91       	pop	r29
    4ccc:	1f 91       	pop	r17
    4cce:	0f 91       	pop	r16
    4cd0:	ff 90       	pop	r15
    4cd2:	ef 90       	pop	r14
    4cd4:	df 90       	pop	r13
    4cd6:	cf 90       	pop	r12
    4cd8:	bf 90       	pop	r11
    4cda:	9f 90       	pop	r9
    4cdc:	8f 90       	pop	r8
    4cde:	7f 90       	pop	r7
    4ce0:	6f 90       	pop	r6
    4ce2:	08 95       	ret

00004ce4 <GetMinusPos>:
	      break;	 
	 }
*/
}

char GetMinusPos(char *strNumber){
    4ce4:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    4ce6:	dc 01       	movw	r26, r24
    4ce8:	0d 90       	ld	r0, X+
    4cea:	00 20       	and	r0, r0
    4cec:	e9 f7       	brne	.-6      	; 0x4ce8 <GetMinusPos+0x4>
    4cee:	11 97       	sbiw	r26, 0x01	; 1
    4cf0:	a8 1b       	sub	r26, r24
    4cf2:	b9 0b       	sbc	r27, r25
    4cf4:	20 e0       	ldi	r18, 0x00	; 0
    4cf6:	0a c0       	rjmp	.+20     	; 0x4d0c <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    4cf8:	e4 0f       	add	r30, r20
    4cfa:	f5 1f       	adc	r31, r21
    4cfc:	80 81       	ld	r24, Z
    4cfe:	92 2f       	mov	r25, r18
    4d00:	9f 5f       	subi	r25, 0xFF	; 255
    4d02:	8d 32       	cpi	r24, 0x2D	; 45
    4d04:	11 f4       	brne	.+4      	; 0x4d0a <GetMinusPos+0x26>
		     Result=i+1;
    4d06:	89 2f       	mov	r24, r25
    4d08:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    4d0a:	29 2f       	mov	r18, r25
    4d0c:	e2 2f       	mov	r30, r18
    4d0e:	f0 e0       	ldi	r31, 0x00	; 0
    4d10:	ea 17       	cp	r30, r26
    4d12:	fb 07       	cpc	r31, r27
    4d14:	88 f3       	brcs	.-30     	; 0x4cf8 <GetMinusPos+0x14>
    4d16:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    4d18:	08 95       	ret

00004d1a <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    4d1a:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <GetMinusPos>
    4d1e:	81 11       	cpse	r24, r1
    4d20:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    4d22:	08 95       	ret

00004d24 <RemoveMinus>:

void RemoveMinus(char *strNumber){
    4d24:	cf 93       	push	r28
    4d26:	df 93       	push	r29
    4d28:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    4d2a:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <IsMinus>
    4d2e:	81 30       	cpi	r24, 0x01	; 1
    4d30:	19 f5       	brne	.+70     	; 0x4d78 <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    4d32:	ce 01       	movw	r24, r28
    4d34:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <GetMinusPos>
		 Length=strlen(strNumber);
    4d38:	de 01       	movw	r26, r28
    4d3a:	0d 90       	ld	r0, X+
    4d3c:	00 20       	and	r0, r0
    4d3e:	e9 f7       	brne	.-6      	; 0x4d3a <RemoveMinus+0x16>
    4d40:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    4d42:	ac 1b       	sub	r26, r28
    4d44:	b0 e0       	ldi	r27, 0x00	; 0
    4d46:	90 e0       	ldi	r25, 0x00	; 0
    4d48:	a8 1b       	sub	r26, r24
    4d4a:	b9 0b       	sbc	r27, r25
    4d4c:	ae 01       	movw	r20, r28
    4d4e:	48 0f       	add	r20, r24
    4d50:	59 1f       	adc	r21, r25
    4d52:	20 e0       	ldi	r18, 0x00	; 0
    4d54:	30 e0       	ldi	r19, 0x00	; 0
    4d56:	0a c0       	rjmp	.+20     	; 0x4d6c <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4d58:	be 01       	movw	r22, r28
    4d5a:	62 0f       	add	r22, r18
    4d5c:	73 1f       	adc	r23, r19
    4d5e:	fa 01       	movw	r30, r20
    4d60:	81 91       	ld	r24, Z+
    4d62:	af 01       	movw	r20, r30
    4d64:	fb 01       	movw	r30, r22
    4d66:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4d68:	2f 5f       	subi	r18, 0xFF	; 255
    4d6a:	3f 4f       	sbci	r19, 0xFF	; 255
    4d6c:	2a 17       	cp	r18, r26
    4d6e:	3b 07       	cpc	r19, r27
    4d70:	98 f3       	brcs	.-26     	; 0x4d58 <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4d72:	ac 0f       	add	r26, r28
    4d74:	bd 1f       	adc	r27, r29
    4d76:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    4d78:	df 91       	pop	r29
    4d7a:	cf 91       	pop	r28
    4d7c:	08 95       	ret

00004d7e <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    4d7e:	ac 01       	movw	r20, r24
    4d80:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    4d82:	fc 01       	movw	r30, r24
    4d84:	01 90       	ld	r0, Z+
    4d86:	00 20       	and	r0, r0
    4d88:	e9 f7       	brne	.-6      	; 0x4d84 <IsMoreThan+0x6>
    4d8a:	31 97       	sbiw	r30, 0x01	; 1
    4d8c:	7e 2f       	mov	r23, r30
    4d8e:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    4d90:	a6 2f       	mov	r26, r22
    4d92:	b2 2f       	mov	r27, r18
    4d94:	fd 01       	movw	r30, r26
    4d96:	01 90       	ld	r0, Z+
    4d98:	00 20       	and	r0, r0
    4d9a:	e9 f7       	brne	.-6      	; 0x4d96 <IsMoreThan+0x18>
    4d9c:	31 97       	sbiw	r30, 0x01	; 1
    4d9e:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    4da0:	e7 17       	cp	r30, r23
    4da2:	48 f1       	brcs	.+82     	; 0x4df6 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    4da4:	7e 17       	cp	r23, r30
    4da6:	49 f5       	brne	.+82     	; 0x4dfa <IsMoreThan+0x7c>
    4da8:	86 2f       	mov	r24, r22
    4daa:	92 2f       	mov	r25, r18
    4dac:	9c 01       	movw	r18, r24
    4dae:	d9 01       	movw	r26, r18
    4db0:	20 e0       	ldi	r18, 0x00	; 0
    4db2:	30 e0       	ldi	r19, 0x00	; 0
    4db4:	1d c0       	rjmp	.+58     	; 0x4df0 <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4db6:	fa 01       	movw	r30, r20
    4db8:	e2 0f       	add	r30, r18
    4dba:	f3 1f       	adc	r31, r19
    4dbc:	e0 81       	ld	r30, Z
    4dbe:	e0 53       	subi	r30, 0x30	; 48
    4dc0:	ea 30       	cpi	r30, 0x0A	; 10
    4dc2:	10 f0       	brcs	.+4      	; 0x4dc8 <IsMoreThan+0x4a>
    4dc4:	60 e0       	ldi	r22, 0x00	; 0
    4dc6:	01 c0       	rjmp	.+2      	; 0x4dca <IsMoreThan+0x4c>
    4dc8:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    4dca:	8c 91       	ld	r24, X
    4dcc:	80 53       	subi	r24, 0x30	; 48
    4dce:	8a 30       	cpi	r24, 0x0A	; 10
    4dd0:	10 f0       	brcs	.+4      	; 0x4dd6 <IsMoreThan+0x58>
    4dd2:	90 e0       	ldi	r25, 0x00	; 0
    4dd4:	01 c0       	rjmp	.+2      	; 0x4dd8 <IsMoreThan+0x5a>
    4dd6:	98 2f       	mov	r25, r24
    4dd8:	96 17       	cp	r25, r22
    4dda:	68 f0       	brcs	.+26     	; 0x4df6 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4ddc:	ea 30       	cpi	r30, 0x0A	; 10
    4dde:	08 f0       	brcs	.+2      	; 0x4de2 <IsMoreThan+0x64>
    4de0:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    4de2:	8a 30       	cpi	r24, 0x0A	; 10
    4de4:	10 f4       	brcc	.+4      	; 0x4dea <IsMoreThan+0x6c>
    4de6:	e8 17       	cp	r30, r24
    4de8:	40 f0       	brcs	.+16     	; 0x4dfa <IsMoreThan+0x7c>
    4dea:	2f 5f       	subi	r18, 0xFF	; 255
    4dec:	3f 4f       	sbci	r19, 0xFF	; 255
    4dee:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    4df0:	27 17       	cp	r18, r23
    4df2:	08 f3       	brcs	.-62     	; 0x4db6 <IsMoreThan+0x38>
    4df4:	02 c0       	rjmp	.+4      	; 0x4dfa <IsMoreThan+0x7c>
    4df6:	81 e0       	ldi	r24, 0x01	; 1
    4df8:	08 95       	ret
    4dfa:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    4dfc:	08 95       	ret

00004dfe <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    4dfe:	fc 01       	movw	r30, r24
    4e00:	01 90       	ld	r0, Z+
    4e02:	00 20       	and	r0, r0
    4e04:	e9 f7       	brne	.-6      	; 0x4e00 <IsZerroAll+0x2>
    4e06:	31 97       	sbiw	r30, 0x01	; 1
    4e08:	e8 1b       	sub	r30, r24
    4e0a:	dc 01       	movw	r26, r24
    4e0c:	ae 0f       	add	r26, r30
    4e0e:	b1 1d       	adc	r27, r1
    4e10:	90 e0       	ldi	r25, 0x00	; 0
    4e12:	20 e0       	ldi	r18, 0x00	; 0
    4e14:	06 c0       	rjmp	.+12     	; 0x4e22 <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    4e16:	8c 91       	ld	r24, X
    4e18:	80 33       	cpi	r24, 0x30	; 48
    4e1a:	09 f4       	brne	.+2      	; 0x4e1e <IsZerroAll+0x20>
    4e1c:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    4e1e:	9f 5f       	subi	r25, 0xFF	; 255
    4e20:	11 97       	sbiw	r26, 0x01	; 1
    4e22:	9e 17       	cp	r25, r30
    4e24:	c0 f3       	brcs	.-16     	; 0x4e16 <IsZerroAll+0x18>
    4e26:	80 e0       	ldi	r24, 0x00	; 0
    4e28:	2e 17       	cp	r18, r30
    4e2a:	09 f4       	brne	.+2      	; 0x4e2e <IsZerroAll+0x30>
    4e2c:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    4e2e:	08 95       	ret

00004e30 <PstrCopy>:
void CarriegeReturn(){
     uart(_COM_PRINTER, 1, 0x0D);     
     uart(_COM_PRINTER, 1, 0x0A);
}

void PstrCopy(char *Dest,char *Source){
    4e30:	cf 93       	push	r28
    4e32:	df 93       	push	r29
    4e34:	20 e0       	ldi	r18, 0x00	; 0
    4e36:	08 c0       	rjmp	.+16     	; 0x4e48 <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    4e38:	fb 01       	movw	r30, r22
    4e3a:	ec 0f       	add	r30, r28
    4e3c:	fd 1f       	adc	r31, r29
    4e3e:	e4 91       	lpm	r30, Z+
    4e40:	c8 0f       	add	r28, r24
    4e42:	d9 1f       	adc	r29, r25
    4e44:	e8 83       	st	Y, r30
     uart(_COM_PRINTER, 1, 0x0A);
}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4e46:	2f 5f       	subi	r18, 0xFF	; 255
    4e48:	c2 2f       	mov	r28, r18
    4e4a:	d0 e0       	ldi	r29, 0x00	; 0
    4e4c:	fb 01       	movw	r30, r22
    4e4e:	01 90       	ld	r0, Z+
    4e50:	00 20       	and	r0, r0
    4e52:	e9 f7       	brne	.-6      	; 0x4e4e <PstrCopy+0x1e>
    4e54:	31 97       	sbiw	r30, 0x01	; 1
    4e56:	e6 1b       	sub	r30, r22
    4e58:	f7 0b       	sbc	r31, r23
    4e5a:	ce 17       	cp	r28, r30
    4e5c:	df 07       	cpc	r29, r31
    4e5e:	60 f3       	brcs	.-40     	; 0x4e38 <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    4e60:	df 91       	pop	r29
    4e62:	cf 91       	pop	r28
    4e64:	08 95       	ret

00004e66 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4e66:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4e68:	dc 01       	movw	r26, r24
    4e6a:	0d 90       	ld	r0, X+
    4e6c:	00 20       	and	r0, r0
    4e6e:	e9 f7       	brne	.-6      	; 0x4e6a <SpaceOnly+0x4>
    4e70:	11 97       	sbiw	r26, 0x01	; 1
    4e72:	a8 1b       	sub	r26, r24
    4e74:	b9 0b       	sbc	r27, r25
    4e76:	90 e0       	ldi	r25, 0x00	; 0
    4e78:	20 e0       	ldi	r18, 0x00	; 0
    4e7a:	30 e0       	ldi	r19, 0x00	; 0
    4e7c:	09 c0       	rjmp	.+18     	; 0x4e90 <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    4e7e:	fa 01       	movw	r30, r20
    4e80:	e2 0f       	add	r30, r18
    4e82:	f3 1f       	adc	r31, r19
    4e84:	80 81       	ld	r24, Z
    4e86:	80 32       	cpi	r24, 0x20	; 32
    4e88:	09 f0       	breq	.+2      	; 0x4e8c <SpaceOnly+0x26>
    4e8a:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4e8c:	2f 5f       	subi	r18, 0xFF	; 255
    4e8e:	3f 4f       	sbci	r19, 0xFF	; 255
    4e90:	2a 17       	cp	r18, r26
    4e92:	3b 07       	cpc	r19, r27
    4e94:	a0 f3       	brcs	.-24     	; 0x4e7e <SpaceOnly+0x18>
    4e96:	80 e0       	ldi	r24, 0x00	; 0
    4e98:	99 23       	and	r25, r25
    4e9a:	09 f4       	brne	.+2      	; 0x4e9e <SpaceOnly+0x38>
    4e9c:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    4e9e:	08 95       	ret

00004ea0 <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    4ea0:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    4ea2:	e1 99       	sbic	0x1c, 1	; 28
    4ea4:	fe cf       	rjmp	.-4      	; 0x4ea2 <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4ea6:	8e e3       	ldi	r24, 0x3E	; 62
    4ea8:	90 e0       	ldi	r25, 0x00	; 0
    4eaa:	9f bb       	out	0x1f, r25	; 31
    4eac:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4eae:	e0 9a       	sbi	0x1c, 0	; 28
    4eb0:	5d b3       	in	r21, 0x1d	; 29
    4eb2:	40 e0       	ldi	r20, 0x00	; 0
    4eb4:	08 c0       	rjmp	.+16     	; 0x4ec6 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    4eb6:	f9 01       	movw	r30, r18
    4eb8:	e8 0f       	add	r30, r24
    4eba:	f9 1f       	adc	r31, r25
    4ebc:	80 81       	ld	r24, Z
    4ebe:	85 17       	cp	r24, r21
    4ec0:	09 f4       	brne	.+2      	; 0x4ec4 <RemDecimal+0x24>
		     strDecimal[i]=0;
    4ec2:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    4ec4:	4f 5f       	subi	r20, 0xFF	; 255
    4ec6:	84 2f       	mov	r24, r20
    4ec8:	90 e0       	ldi	r25, 0x00	; 0
    4eca:	f9 01       	movw	r30, r18
    4ecc:	01 90       	ld	r0, Z+
    4ece:	00 20       	and	r0, r0
    4ed0:	e9 f7       	brne	.-6      	; 0x4ecc <RemDecimal+0x2c>
    4ed2:	31 97       	sbiw	r30, 0x01	; 1
    4ed4:	e2 1b       	sub	r30, r18
    4ed6:	f3 0b       	sbc	r31, r19
    4ed8:	8e 17       	cp	r24, r30
    4eda:	9f 07       	cpc	r25, r31
    4edc:	60 f3       	brcs	.-40     	; 0x4eb6 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    4ede:	08 95       	ret

00004ee0 <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    4ee0:	cf 92       	push	r12
    4ee2:	df 92       	push	r13
    4ee4:	ef 92       	push	r14
    4ee6:	ff 92       	push	r15
    4ee8:	0f 93       	push	r16
    4eea:	1f 93       	push	r17
    4eec:	df 93       	push	r29
    4eee:	cf 93       	push	r28
    4ef0:	cd b7       	in	r28, 0x3d	; 61
    4ef2:	de b7       	in	r29, 0x3e	; 62
    4ef4:	67 97       	sbiw	r28, 0x17	; 23
    4ef6:	0f b6       	in	r0, 0x3f	; 63
    4ef8:	f8 94       	cli
    4efa:	de bf       	out	0x3e, r29	; 62
    4efc:	0f be       	out	0x3f, r0	; 63
    4efe:	cd bf       	out	0x3d, r28	; 61
    4f00:	7c 01       	movw	r14, r24
    4f02:	d6 2e       	mov	r13, r22
    4f04:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    4f06:	00 d0       	rcall	.+0      	; 0x4f08 <GetProductPrice+0x28>
    4f08:	00 d0       	rcall	.+0      	; 0x4f0a <GetProductPrice+0x2a>
    4f0a:	ad b7       	in	r26, 0x3d	; 61
    4f0c:	be b7       	in	r27, 0x3e	; 62
    4f0e:	12 96       	adiw	r26, 0x02	; 2
    4f10:	9c 93       	st	X, r25
    4f12:	8e 93       	st	-X, r24
    4f14:	11 97       	sbiw	r26, 0x01	; 1
    4f16:	86 e6       	ldi	r24, 0x66	; 102
    4f18:	95 e0       	ldi	r25, 0x05	; 5
    4f1a:	14 96       	adiw	r26, 0x04	; 4
    4f1c:	9c 93       	st	X, r25
    4f1e:	8e 93       	st	-X, r24
    4f20:	13 97       	sbiw	r26, 0x03	; 3
    4f22:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4f26:	0f 90       	pop	r0
    4f28:	0f 90       	pop	r0
    4f2a:	0f 90       	pop	r0
    4f2c:	0f 90       	pop	r0
    4f2e:	8e 01       	movw	r16, r28
    4f30:	09 5f       	subi	r16, 0xF9	; 249
    4f32:	1f 4f       	sbci	r17, 0xFF	; 255
    4f34:	c8 01       	movw	r24, r16
    4f36:	65 e4       	ldi	r22, 0x45	; 69
    4f38:	70 e0       	ldi	r23, 0x00	; 0
    4f3a:	48 e0       	ldi	r20, 0x08	; 8
    4f3c:	50 e0       	ldi	r21, 0x00	; 0
    4f3e:	22 ed       	ldi	r18, 0xD2	; 210
    4f40:	33 e1       	ldi	r19, 0x13	; 19
    4f42:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    4f46:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4f48:	9e 01       	movw	r18, r28
    4f4a:	21 5f       	subi	r18, 0xF1	; 241
    4f4c:	3f 4f       	sbci	r19, 0xFF	; 255
    4f4e:	9e 2f       	mov	r25, r30
    4f50:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    4f52:	80 81       	ld	r24, Z
    4f54:	8d 15       	cp	r24, r13
    4f56:	11 f4       	brne	.+4      	; 0x4f5c <GetProductPrice+0x7c>
    4f58:	89 2f       	mov	r24, r25
    4f5a:	05 c0       	rjmp	.+10     	; 0x4f66 <GetProductPrice+0x86>
    4f5c:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4f5e:	e2 17       	cp	r30, r18
    4f60:	f3 07       	cpc	r31, r19
    4f62:	a9 f7       	brne	.-22     	; 0x4f4e <GetProductPrice+0x6e>
    4f64:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4f66:	b5 e0       	ldi	r27, 0x05	; 5
    4f68:	bc 15       	cp	r27, r12
    4f6a:	08 f4       	brcc	.+2      	; 0x4f6e <GetProductPrice+0x8e>
    4f6c:	41 c0       	rjmp	.+130    	; 0x4ff0 <GetProductPrice+0x110>
    4f6e:	66 e0       	ldi	r22, 0x06	; 6
    4f70:	86 9f       	mul	r24, r22
    4f72:	b0 01       	movw	r22, r0
    4f74:	11 24       	eor	r1, r1
    4f76:	6b 5a       	subi	r22, 0xAB	; 171
    4f78:	7f 4f       	sbci	r23, 0xFF	; 255
    4f7a:	ce 01       	movw	r24, r28
    4f7c:	01 96       	adiw	r24, 0x01	; 1
    4f7e:	46 e0       	ldi	r20, 0x06	; 6
    4f80:	50 e0       	ldi	r21, 0x00	; 0
    4f82:	22 ed       	ldi	r18, 0xD2	; 210
    4f84:	33 e1       	ldi	r19, 0x13	; 19
    4f86:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    4f8a:	8e 01       	movw	r16, r28
    4f8c:	01 5f       	subi	r16, 0xF1	; 241
    4f8e:	1f 4f       	sbci	r17, 0xFF	; 255
    4f90:	fe 01       	movw	r30, r28
    4f92:	ec 0d       	add	r30, r12
    4f94:	f1 1d       	adc	r31, r1
    4f96:	60 81       	ld	r22, Z
    4f98:	89 e0       	ldi	r24, 0x09	; 9
    4f9a:	68 9f       	mul	r22, r24
    4f9c:	b0 01       	movw	r22, r0
    4f9e:	11 24       	eor	r1, r1
    4fa0:	64 58       	subi	r22, 0x84	; 132
    4fa2:	7f 4f       	sbci	r23, 0xFF	; 255
    4fa4:	c8 01       	movw	r24, r16
    4fa6:	49 e0       	ldi	r20, 0x09	; 9
    4fa8:	50 e0       	ldi	r21, 0x00	; 0
    4faa:	22 ed       	ldi	r18, 0xD2	; 210
    4fac:	33 e1       	ldi	r19, 0x13	; 19
    4fae:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    4fb2:	c8 01       	movw	r24, r16
    4fb4:	0e 94 50 27 	call	0x4ea0	; 0x4ea0 <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    4fb8:	00 d0       	rcall	.+0      	; 0x4fba <GetProductPrice+0xda>
    4fba:	00 d0       	rcall	.+0      	; 0x4fbc <GetProductPrice+0xdc>
    4fbc:	00 d0       	rcall	.+0      	; 0x4fbe <GetProductPrice+0xde>
    4fbe:	ed b7       	in	r30, 0x3d	; 61
    4fc0:	fe b7       	in	r31, 0x3e	; 62
    4fc2:	31 96       	adiw	r30, 0x01	; 1
    4fc4:	ad b7       	in	r26, 0x3d	; 61
    4fc6:	be b7       	in	r27, 0x3e	; 62
    4fc8:	12 96       	adiw	r26, 0x02	; 2
    4fca:	fc 92       	st	X, r15
    4fcc:	ee 92       	st	-X, r14
    4fce:	11 97       	sbiw	r26, 0x01	; 1
    4fd0:	83 e6       	ldi	r24, 0x63	; 99
    4fd2:	95 e0       	ldi	r25, 0x05	; 5
    4fd4:	93 83       	std	Z+3, r25	; 0x03
    4fd6:	82 83       	std	Z+2, r24	; 0x02
    4fd8:	15 83       	std	Z+5, r17	; 0x05
    4fda:	04 83       	std	Z+4, r16	; 0x04
    4fdc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    4fe0:	ed b7       	in	r30, 0x3d	; 61
    4fe2:	fe b7       	in	r31, 0x3e	; 62
    4fe4:	36 96       	adiw	r30, 0x06	; 6
    4fe6:	0f b6       	in	r0, 0x3f	; 63
    4fe8:	f8 94       	cli
    4fea:	fe bf       	out	0x3e, r31	; 62
    4fec:	0f be       	out	0x3f, r0	; 63
    4fee:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    4ff0:	67 96       	adiw	r28, 0x17	; 23
    4ff2:	0f b6       	in	r0, 0x3f	; 63
    4ff4:	f8 94       	cli
    4ff6:	de bf       	out	0x3e, r29	; 62
    4ff8:	0f be       	out	0x3f, r0	; 63
    4ffa:	cd bf       	out	0x3d, r28	; 61
    4ffc:	cf 91       	pop	r28
    4ffe:	df 91       	pop	r29
    5000:	1f 91       	pop	r17
    5002:	0f 91       	pop	r16
    5004:	ff 90       	pop	r15
    5006:	ef 90       	pop	r14
    5008:	df 90       	pop	r13
    500a:	cf 90       	pop	r12
    500c:	08 95       	ret

0000500e <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    500e:	df 93       	push	r29
    5010:	cf 93       	push	r28
    5012:	cd b7       	in	r28, 0x3d	; 61
    5014:	de b7       	in	r29, 0x3e	; 62
    5016:	2b 97       	sbiw	r28, 0x0b	; 11
    5018:	0f b6       	in	r0, 0x3f	; 63
    501a:	f8 94       	cli
    501c:	de bf       	out	0x3e, r29	; 62
    501e:	0f be       	out	0x3f, r0	; 63
    5020:	cd bf       	out	0x3d, r28	; 61
    5022:	98 2f       	mov	r25, r24
    5024:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    5026:	fb 01       	movw	r30, r22
    5028:	80 85       	ldd	r24, Z+8	; 0x08
    502a:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    502c:	81 85       	ldd	r24, Z+9	; 0x09
    502e:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    5030:	87 81       	ldd	r24, Z+7	; 0x07
    5032:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    5034:	85 81       	ldd	r24, Z+5	; 0x05
    5036:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    5038:	86 81       	ldd	r24, Z+6	; 0x06
    503a:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    503c:	84 81       	ldd	r24, Z+4	; 0x04
    503e:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    5040:	99 23       	and	r25, r25
    5042:	19 f0       	breq	.+6      	; 0x504a <FormatDate+0x3c>
    5044:	91 30       	cpi	r25, 0x01	; 1
    5046:	59 f4       	brne	.+22     	; 0x505e <FormatDate+0x50>
    5048:	0f c0       	rjmp	.+30     	; 0x5068 <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    504a:	fb 01       	movw	r30, r22
    504c:	80 81       	ld	r24, Z
    504e:	8f 83       	std	Y+7, r24	; 0x07
    5050:	81 81       	ldd	r24, Z+1	; 0x01
    5052:	88 87       	std	Y+8, r24	; 0x08
    5054:	82 81       	ldd	r24, Z+2	; 0x02
    5056:	89 87       	std	Y+9, r24	; 0x09
    5058:	83 81       	ldd	r24, Z+3	; 0x03
    505a:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    505c:	1b 86       	std	Y+11, r1	; 0x0b
    505e:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    5060:	ae 01       	movw	r20, r28
    5062:	4f 5f       	subi	r20, 0xFF	; 255
    5064:	5f 4f       	sbci	r21, 0xFF	; 255
    5066:	0f c0       	rjmp	.+30     	; 0x5086 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    5068:	fb 01       	movw	r30, r22
    506a:	82 81       	ldd	r24, Z+2	; 0x02
    506c:	8f 83       	std	Y+7, r24	; 0x07
    506e:	83 81       	ldd	r24, Z+3	; 0x03
    5070:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    5072:	19 86       	std	Y+9, r1	; 0x09
    5074:	f4 cf       	rjmp	.-24     	; 0x505e <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    5076:	f9 01       	movw	r30, r18
    5078:	ea 0f       	add	r30, r26
    507a:	fb 1f       	adc	r31, r27
    507c:	a4 0f       	add	r26, r20
    507e:	b5 1f       	adc	r27, r21
    5080:	8c 91       	ld	r24, X
    5082:	80 83       	st	Z, r24
    5084:	9f 5f       	subi	r25, 0xFF	; 255
    5086:	a9 2f       	mov	r26, r25
    5088:	b0 e0       	ldi	r27, 0x00	; 0
    508a:	fa 01       	movw	r30, r20
    508c:	01 90       	ld	r0, Z+
    508e:	00 20       	and	r0, r0
    5090:	e9 f7       	brne	.-6      	; 0x508c <FormatDate+0x7e>
    5092:	31 97       	sbiw	r30, 0x01	; 1
    5094:	e4 1b       	sub	r30, r20
    5096:	f5 0b       	sbc	r31, r21
    5098:	ae 17       	cp	r26, r30
    509a:	bf 07       	cpc	r27, r31
    509c:	60 f3       	brcs	.-40     	; 0x5076 <FormatDate+0x68>
}
    509e:	2b 96       	adiw	r28, 0x0b	; 11
    50a0:	0f b6       	in	r0, 0x3f	; 63
    50a2:	f8 94       	cli
    50a4:	de bf       	out	0x3e, r29	; 62
    50a6:	0f be       	out	0x3f, r0	; 63
    50a8:	cd bf       	out	0x3d, r28	; 61
    50aa:	cf 91       	pop	r28
    50ac:	df 91       	pop	r29
    50ae:	08 95       	ret

000050b0 <RemZeroLead>:

	while (1){};
  #endif
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    50b0:	cf 93       	push	r28
    50b2:	df 93       	push	r29
    50b4:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    50b6:	fc 01       	movw	r30, r24
    50b8:	01 90       	ld	r0, Z+
    50ba:	00 20       	and	r0, r0
    50bc:	e9 f7       	brne	.-6      	; 0x50b8 <RemZeroLead+0x8>
    50be:	31 97       	sbiw	r30, 0x01	; 1
    50c0:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    50c2:	e2 30       	cpi	r30, 0x02	; 2
    50c4:	d0 f1       	brcs	.+116    	; 0x513a <RemZeroLead+0x8a>
    50c6:	88 81       	ld	r24, Y
    50c8:	80 33       	cpi	r24, 0x30	; 48
    50ca:	b9 f5       	brne	.+110    	; 0x513a <RemZeroLead+0x8a>
    50cc:	4c 2f       	mov	r20, r28
    50ce:	de 01       	movw	r26, r28
    50d0:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    50d2:	8c 91       	ld	r24, X
    50d4:	80 33       	cpi	r24, 0x30	; 48
    50d6:	69 f4       	brne	.+26     	; 0x50f2 <RemZeroLead+0x42>
    50d8:	11 96       	adiw	r26, 0x01	; 1
    50da:	8c 91       	ld	r24, X
    50dc:	11 97       	sbiw	r26, 0x01	; 1
    50de:	80 33       	cpi	r24, 0x30	; 48
    50e0:	11 f4       	brne	.+4      	; 0x50e6 <RemZeroLead+0x36>
    50e2:	9f 5f       	subi	r25, 0xFF	; 255
    50e4:	06 c0       	rjmp	.+12     	; 0x50f2 <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    50e6:	8e 32       	cpi	r24, 0x2E	; 46
    50e8:	11 f0       	breq	.+4      	; 0x50ee <RemZeroLead+0x3e>
    50ea:	8c 32       	cpi	r24, 0x2C	; 44
    50ec:	41 f4       	brne	.+16     	; 0x50fe <RemZeroLead+0x4e>
    50ee:	91 50       	subi	r25, 0x01	; 1
    50f0:	06 c0       	rjmp	.+12     	; 0x50fe <RemZeroLead+0x4e>
    50f2:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    50f4:	8a 2f       	mov	r24, r26
    50f6:	84 1b       	sub	r24, r20
    50f8:	8e 17       	cp	r24, r30
    50fa:	58 f3       	brcs	.-42     	; 0x50d2 <RemZeroLead+0x22>
    50fc:	01 c0       	rjmp	.+2      	; 0x5100 <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    50fe:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    5100:	9e 17       	cp	r25, r30
    5102:	10 f0       	brcs	.+4      	; 0x5108 <RemZeroLead+0x58>
    5104:	9e 2f       	mov	r25, r30
    5106:	91 50       	subi	r25, 0x01	; 1
    5108:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    510a:	89 2f       	mov	r24, r25
    510c:	90 e0       	ldi	r25, 0x00	; 0
    510e:	2e 2f       	mov	r18, r30
    5110:	30 e0       	ldi	r19, 0x00	; 0
    5112:	28 1b       	sub	r18, r24
    5114:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    5116:	be 01       	movw	r22, r28
    5118:	68 0f       	add	r22, r24
    511a:	79 1f       	adc	r23, r25
    511c:	09 c0       	rjmp	.+18     	; 0x5130 <RemZeroLead+0x80>
    511e:	fe 01       	movw	r30, r28
    5120:	ea 0f       	add	r30, r26
    5122:	fb 1f       	adc	r31, r27
    5124:	a6 0f       	add	r26, r22
    5126:	b7 1f       	adc	r27, r23
    5128:	8c 91       	ld	r24, X
    512a:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    512c:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    512e:	4f 5f       	subi	r20, 0xFF	; 255
    5130:	a4 2f       	mov	r26, r20
    5132:	b0 e0       	ldi	r27, 0x00	; 0
    5134:	a2 17       	cp	r26, r18
    5136:	b3 07       	cpc	r27, r19
    5138:	94 f3       	brlt	.-28     	; 0x511e <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    513a:	df 91       	pop	r29
    513c:	cf 91       	pop	r28
    513e:	08 95       	ret

00005140 <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    5140:	cf 93       	push	r28
    5142:	df 93       	push	r29
    5144:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    5146:	fc 01       	movw	r30, r24
    5148:	01 90       	ld	r0, Z+
    514a:	00 20       	and	r0, r0
    514c:	e9 f7       	brne	.-6      	; 0x5148 <RemSpaceLead+0x8>
    514e:	31 97       	sbiw	r30, 0x01	; 1
    5150:	6e 2f       	mov	r22, r30
    5152:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    5154:	62 30       	cpi	r22, 0x02	; 2
    5156:	e0 f1       	brcs	.+120    	; 0x51d0 <RemSpaceLead+0x90>
    5158:	88 81       	ld	r24, Y
    515a:	80 32       	cpi	r24, 0x20	; 32
    515c:	c9 f5       	brne	.+114    	; 0x51d0 <RemSpaceLead+0x90>
    515e:	4c 2f       	mov	r20, r28
    5160:	fe 01       	movw	r30, r28
    5162:	90 e0       	ldi	r25, 0x00	; 0
    5164:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    5166:	80 81       	ld	r24, Z
    5168:	80 32       	cpi	r24, 0x20	; 32
    516a:	41 f4       	brne	.+16     	; 0x517c <RemSpaceLead+0x3c>
    516c:	81 81       	ldd	r24, Z+1	; 0x01
    516e:	80 32       	cpi	r24, 0x20	; 32
    5170:	21 f4       	brne	.+8      	; 0x517a <RemSpaceLead+0x3a>
    5172:	22 23       	and	r18, r18
    5174:	19 f4       	brne	.+6      	; 0x517c <RemSpaceLead+0x3c>
    5176:	9f 5f       	subi	r25, 0xFF	; 255
    5178:	01 c0       	rjmp	.+2      	; 0x517c <RemSpaceLead+0x3c>
    517a:	21 e0       	ldi	r18, 0x01	; 1
    517c:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    517e:	8e 2f       	mov	r24, r30
    5180:	84 1b       	sub	r24, r20
    5182:	86 17       	cp	r24, r22
    5184:	80 f3       	brcs	.-32     	; 0x5166 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    5186:	39 2f       	mov	r19, r25
    5188:	3f 5f       	subi	r19, 0xFF	; 255
    518a:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    518c:	43 2f       	mov	r20, r19
    518e:	50 e0       	ldi	r21, 0x00	; 0
    5190:	09 c0       	rjmp	.+18     	; 0x51a4 <RemSpaceLead+0x64>
    5192:	fe 01       	movw	r30, r28
    5194:	e8 0f       	add	r30, r24
    5196:	f9 1f       	adc	r31, r25
    5198:	df 01       	movw	r26, r30
    519a:	a4 0f       	add	r26, r20
    519c:	b5 1f       	adc	r27, r21
    519e:	8c 91       	ld	r24, X
    51a0:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    51a2:	2f 5f       	subi	r18, 0xFF	; 255
    51a4:	82 2f       	mov	r24, r18
    51a6:	90 e0       	ldi	r25, 0x00	; 0
    51a8:	fe 01       	movw	r30, r28
    51aa:	01 90       	ld	r0, Z+
    51ac:	00 20       	and	r0, r0
    51ae:	e9 f7       	brne	.-6      	; 0x51aa <RemSpaceLead+0x6a>
    51b0:	31 97       	sbiw	r30, 0x01	; 1
    51b2:	ec 1b       	sub	r30, r28
    51b4:	fd 0b       	sbc	r31, r29
    51b6:	8e 17       	cp	r24, r30
    51b8:	9f 07       	cpc	r25, r31
    51ba:	58 f3       	brcs	.-42     	; 0x5192 <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    51bc:	86 2f       	mov	r24, r22
    51be:	83 1b       	sub	r24, r19
    51c0:	05 c0       	rjmp	.+10     	; 0x51cc <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    51c2:	fe 01       	movw	r30, r28
    51c4:	e8 0f       	add	r30, r24
    51c6:	f1 1d       	adc	r31, r1
    51c8:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    51ca:	8f 5f       	subi	r24, 0xFF	; 255
    51cc:	86 17       	cp	r24, r22
    51ce:	c8 f3       	brcs	.-14     	; 0x51c2 <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    51d0:	df 91       	pop	r29
    51d2:	cf 91       	pop	r28
    51d4:	08 95       	ret

000051d6 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    51d6:	0f 93       	push	r16
    51d8:	1f 93       	push	r17
    51da:	cf 93       	push	r28
    51dc:	df 93       	push	r29
    51de:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    51e0:	dc 01       	movw	r26, r24
    51e2:	0d 90       	ld	r0, X+
    51e4:	00 20       	and	r0, r0
    51e6:	e9 f7       	brne	.-6      	; 0x51e2 <RemSpaceLag+0xc>
    51e8:	11 97       	sbiw	r26, 0x01	; 1
    51ea:	a8 1b       	sub	r26, r24
    51ec:	b0 e0       	ldi	r27, 0x00	; 0
    51ee:	20 e0       	ldi	r18, 0x00	; 0
    51f0:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    51f2:	6a 2f       	mov	r22, r26
    51f4:	70 e0       	ldi	r23, 0x00	; 0
    51f6:	8b 01       	movw	r16, r22
    51f8:	01 50       	subi	r16, 0x01	; 1
    51fa:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    51fc:	a1 50       	subi	r26, 0x01	; 1
    51fe:	16 c0       	rjmp	.+44     	; 0x522c <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    5200:	ab 01       	movw	r20, r22
    5202:	48 1b       	sub	r20, r24
    5204:	59 0b       	sbc	r21, r25
    5206:	fe 01       	movw	r30, r28
    5208:	e4 0f       	add	r30, r20
    520a:	f5 1f       	adc	r31, r21
    520c:	32 97       	sbiw	r30, 0x02	; 2
    520e:	80 81       	ld	r24, Z
    5210:	80 32       	cpi	r24, 0x20	; 32
    5212:	89 f4       	brne	.+34     	; 0x5236 <RemSpaceLag+0x60>
    5214:	fa 01       	movw	r30, r20
    5216:	31 97       	sbiw	r30, 0x01	; 1
    5218:	ec 0f       	add	r30, r28
    521a:	fd 1f       	adc	r31, r29
    521c:	2f 5f       	subi	r18, 0xFF	; 255
    521e:	3f 4f       	sbci	r19, 0xFF	; 255
    5220:	80 81       	ld	r24, Z
    5222:	80 32       	cpi	r24, 0x20	; 32
    5224:	41 f4       	brne	.+16     	; 0x5236 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    5226:	10 82       	st	Z, r1
    5228:	ba 2f       	mov	r27, r26
    522a:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    522c:	82 2f       	mov	r24, r18
    522e:	90 e0       	ldi	r25, 0x00	; 0
    5230:	80 17       	cp	r24, r16
    5232:	91 07       	cpc	r25, r17
    5234:	2c f3       	brlt	.-54     	; 0x5200 <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    5236:	fe 01       	movw	r30, r28
    5238:	eb 0f       	add	r30, r27
    523a:	f1 1d       	adc	r31, r1
    523c:	80 81       	ld	r24, Z
    523e:	80 32       	cpi	r24, 0x20	; 32
    5240:	09 f4       	brne	.+2      	; 0x5244 <RemSpaceLag+0x6e>
    5242:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    5244:	88 81       	ld	r24, Y
    5246:	80 32       	cpi	r24, 0x20	; 32
    5248:	09 f4       	brne	.+2      	; 0x524c <RemSpaceLag+0x76>
    524a:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    524c:	fe 01       	movw	r30, r28
    524e:	01 90       	ld	r0, Z+
    5250:	00 20       	and	r0, r0
    5252:	e9 f7       	brne	.-6      	; 0x524e <RemSpaceLag+0x78>
    5254:	31 97       	sbiw	r30, 0x01	; 1
    5256:	ec 1b       	sub	r30, r28
    5258:	fd 0b       	sbc	r31, r29
    525a:	ec 0f       	add	r30, r28
    525c:	fd 1f       	adc	r31, r29
    525e:	10 82       	st	Z, r1
}
    5260:	df 91       	pop	r29
    5262:	cf 91       	pop	r28
    5264:	1f 91       	pop	r17
    5266:	0f 91       	pop	r16
    5268:	08 95       	ret

0000526a <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    526a:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    526c:	10 91 56 09 	lds	r17, 0x0956
    5270:	20 e0       	ldi	r18, 0x00	; 0
    5272:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5274:	f9 01       	movw	r30, r18
    5276:	e3 5e       	subi	r30, 0xE3	; 227
    5278:	f6 4f       	sbci	r31, 0xF6	; 246
    527a:	d9 01       	movw	r26, r18
    527c:	a7 57       	subi	r26, 0x77	; 119
    527e:	b4 4f       	sbci	r27, 0xF4	; 244
    5280:	95 96       	adiw	r26, 0x25	; 37
    5282:	8c 91       	ld	r24, X
    5284:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5286:	2f 5f       	subi	r18, 0xFF	; 255
    5288:	3f 4f       	sbci	r19, 0xFF	; 255
    528a:	24 31       	cpi	r18, 0x14	; 20
    528c:	31 05       	cpc	r19, r1
    528e:	91 f7       	brne	.-28     	; 0x5274 <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    5290:	10 92 31 09 	sts	0x0931, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    5294:	89 e8       	ldi	r24, 0x89	; 137
    5296:	9b e0       	ldi	r25, 0x0B	; 11
    5298:	0e 94 a0 28 	call	0x5140	; 0x5140 <RemSpaceLead>
    529c:	20 e0       	ldi	r18, 0x00	; 0
    529e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    52a0:	f9 01       	movw	r30, r18
    52a2:	ec 5d       	subi	r30, 0xDC	; 220
    52a4:	fc 4f       	sbci	r31, 0xFC	; 252
    52a6:	d9 01       	movw	r26, r18
    52a8:	a3 5e       	subi	r26, 0xE3	; 227
    52aa:	b6 4f       	sbci	r27, 0xF6	; 246
    52ac:	dc 96       	adiw	r26, 0x3c	; 60
    52ae:	8c 91       	ld	r24, X
    52b0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    52b2:	2f 5f       	subi	r18, 0xFF	; 255
    52b4:	3f 4f       	sbci	r19, 0xFF	; 255
    52b6:	28 32       	cpi	r18, 0x28	; 40
    52b8:	31 05       	cpc	r19, r1
    52ba:	91 f7       	brne	.-28     	; 0x52a0 <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    52bc:	10 92 4c 03 	sts	0x034C, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    52c0:	84 e2       	ldi	r24, 0x24	; 36
    52c2:	93 e0       	ldi	r25, 0x03	; 3
    52c4:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
    52c8:	20 e0       	ldi	r18, 0x00	; 0
    52ca:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    52cc:	f9 01       	movw	r30, r18
    52ce:	e5 5a       	subi	r30, 0xA5	; 165
    52d0:	fc 4f       	sbci	r31, 0xFC	; 252
    52d2:	d9 01       	movw	r26, r18
    52d4:	ab 54       	subi	r26, 0x4B	; 75
    52d6:	b6 4f       	sbci	r27, 0xF6	; 246
    52d8:	8c 91       	ld	r24, X
    52da:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    52dc:	2f 5f       	subi	r18, 0xFF	; 255
    52de:	3f 4f       	sbci	r19, 0xFF	; 255
    52e0:	29 31       	cpi	r18, 0x19	; 25
    52e2:	31 05       	cpc	r19, r1
    52e4:	99 f7       	brne	.-26     	; 0x52cc <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    52e6:	10 92 74 03 	sts	0x0374, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    52ea:	8b e5       	ldi	r24, 0x5B	; 91
    52ec:	93 e0       	ldi	r25, 0x03	; 3
    52ee:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    52f2:	80 91 ce 09 	lds	r24, 0x09CE
    52f6:	80 93 e5 02 	sts	0x02E5, r24
	 }Dest[Length]=0;
    52fa:	10 92 e6 02 	sts	0x02E6, r1
    52fe:	20 e0       	ldi	r18, 0x00	; 0
    5300:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5302:	f9 01       	movw	r30, r18
    5304:	e8 50       	subi	r30, 0x08	; 8
    5306:	f4 4f       	sbci	r31, 0xF4	; 244
    5308:	d9 01       	movw	r26, r18
    530a:	a1 53       	subi	r26, 0x31	; 49
    530c:	b6 4f       	sbci	r27, 0xF6	; 246
    530e:	8c 91       	ld	r24, X
    5310:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5312:	2f 5f       	subi	r18, 0xFF	; 255
    5314:	3f 4f       	sbci	r19, 0xFF	; 255
    5316:	2d 30       	cpi	r18, 0x0D	; 13
    5318:	31 05       	cpc	r19, r1
    531a:	99 f7       	brne	.-26     	; 0x5302 <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    531c:	10 92 05 0c 	sts	0x0C05, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    5320:	88 ef       	ldi	r24, 0xF8	; 248
    5322:	9b e0       	ldi	r25, 0x0B	; 11
    5324:	0e 94 a0 28 	call	0x5140	; 0x5140 <RemSpaceLead>
    5328:	20 e0       	ldi	r18, 0x00	; 0
    532a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    532c:	f9 01       	movw	r30, r18
    532e:	e6 50       	subi	r30, 0x06	; 6
    5330:	f7 4f       	sbci	r31, 0xF7	; 247
    5332:	d9 01       	movw	r26, r18
    5334:	a4 52       	subi	r26, 0x24	; 36
    5336:	b6 4f       	sbci	r27, 0xF6	; 246
    5338:	8c 91       	ld	r24, X
    533a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    533c:	2f 5f       	subi	r18, 0xFF	; 255
    533e:	3f 4f       	sbci	r19, 0xFF	; 255
    5340:	2a 30       	cpi	r18, 0x0A	; 10
    5342:	31 05       	cpc	r19, r1
    5344:	99 f7       	brne	.-26     	; 0x532c <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    5346:	10 92 04 09 	sts	0x0904, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    534a:	8a ef       	ldi	r24, 0xFA	; 250
    534c:	98 e0       	ldi	r25, 0x08	; 8
    534e:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
    5352:	20 e0       	ldi	r18, 0x00	; 0
    5354:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5356:	f9 01       	movw	r30, r18
    5358:	e7 58       	subi	r30, 0x87	; 135
    535a:	f8 4f       	sbci	r31, 0xF8	; 248
    535c:	d9 01       	movw	r26, r18
    535e:	aa 51       	subi	r26, 0x1A	; 26
    5360:	b6 4f       	sbci	r27, 0xF6	; 246
    5362:	8c 91       	ld	r24, X
    5364:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5366:	2f 5f       	subi	r18, 0xFF	; 255
    5368:	3f 4f       	sbci	r19, 0xFF	; 255
    536a:	24 31       	cpi	r18, 0x14	; 20
    536c:	31 05       	cpc	r19, r1
    536e:	99 f7       	brne	.-26     	; 0x5356 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    5370:	10 92 8d 07 	sts	0x078D, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    5374:	89 e7       	ldi	r24, 0x79	; 121
    5376:	97 e0       	ldi	r25, 0x07	; 7
    5378:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		 uart_print(0,1,strCompName);
		 
uart_print(0,1,strCardID);
*/	
     return Result;
}
    537c:	81 2f       	mov	r24, r17
    537e:	8f 52       	subi	r24, 0x2F	; 47
    5380:	1f 91       	pop	r17
    5382:	08 95       	ret

00005384 <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    5384:	20 e0       	ldi	r18, 0x00	; 0
    5386:	30 e0       	ldi	r19, 0x00	; 0
    5388:	06 c0       	rjmp	.+12     	; 0x5396 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    538a:	fc 01       	movw	r30, r24
    538c:	e2 0f       	add	r30, r18
    538e:	f3 1f       	adc	r31, r19
    5390:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    5392:	2f 5f       	subi	r18, 0xFF	; 255
    5394:	3f 4f       	sbci	r19, 0xFF	; 255
    5396:	fc 01       	movw	r30, r24
    5398:	01 90       	ld	r0, Z+
    539a:	00 20       	and	r0, r0
    539c:	e9 f7       	brne	.-6      	; 0x5398 <clearString+0x14>
    539e:	31 97       	sbiw	r30, 0x01	; 1
    53a0:	e8 1b       	sub	r30, r24
    53a2:	f9 0b       	sbc	r31, r25
    53a4:	2e 17       	cp	r18, r30
    53a6:	3f 07       	cpc	r19, r31
    53a8:	80 f3       	brcs	.-32     	; 0x538a <clearString+0x6>
	    str[i]=0;
	 }
}
    53aa:	08 95       	ret

000053ac <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    53ac:	bf 92       	push	r11
    53ae:	cf 92       	push	r12
    53b0:	df 92       	push	r13
    53b2:	ef 92       	push	r14
    53b4:	ff 92       	push	r15
    53b6:	0f 93       	push	r16
    53b8:	1f 93       	push	r17
    53ba:	df 93       	push	r29
    53bc:	cf 93       	push	r28
    53be:	cd b7       	in	r28, 0x3d	; 61
    53c0:	de b7       	in	r29, 0x3e	; 62
    53c2:	6e 97       	sbiw	r28, 0x1e	; 30
    53c4:	0f b6       	in	r0, 0x3f	; 63
    53c6:	f8 94       	cli
    53c8:	de bf       	out	0x3e, r29	; 62
    53ca:	0f be       	out	0x3f, r0	; 63
    53cc:	cd bf       	out	0x3d, r28	; 61
    53ce:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    53d0:	fc 01       	movw	r30, r24
    53d2:	01 90       	ld	r0, Z+
    53d4:	00 20       	and	r0, r0
    53d6:	e9 f7       	brne	.-6      	; 0x53d2 <AddZeroLead+0x26>
    53d8:	31 97       	sbiw	r30, 0x01	; 1
    53da:	2e 2f       	mov	r18, r30
    53dc:	28 1b       	sub	r18, r24

	 if (Size>Length){
    53de:	26 17       	cp	r18, r22
    53e0:	e0 f5       	brcc	.+120    	; 0x545a <AddZeroLead+0xae>
    53e2:	7e 01       	movw	r14, r28
    53e4:	08 94       	sec
    53e6:	e1 1c       	adc	r14, r1
    53e8:	f1 1c       	adc	r15, r1
    53ea:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    53ec:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    53ee:	90 e3       	ldi	r25, 0x30	; 48
    53f0:	01 c0       	rjmp	.+2      	; 0x53f4 <AddZeroLead+0x48>
    53f2:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    53f4:	8e 2f       	mov	r24, r30
    53f6:	8b 19       	sub	r24, r11
    53f8:	86 17       	cp	r24, r22
    53fa:	d8 f3       	brcs	.-10     	; 0x53f2 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    53fc:	46 2f       	mov	r20, r22
    53fe:	50 e0       	ldi	r21, 0x00	; 0
    5400:	ce 01       	movw	r24, r28
    5402:	01 96       	adiw	r24, 0x01	; 1
    5404:	fc 01       	movw	r30, r24
    5406:	e4 0f       	add	r30, r20
    5408:	f5 1f       	adc	r31, r21
    540a:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    540c:	76 2f       	mov	r23, r22
    540e:	72 1b       	sub	r23, r18
    5410:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5412:	30 e0       	ldi	r19, 0x00	; 0
    5414:	24 1b       	sub	r18, r20
    5416:	35 0b       	sbc	r19, r21
    5418:	0c c0       	rjmp	.+24     	; 0x5432 <AddZeroLead+0x86>
    541a:	e7 2f       	mov	r30, r23
    541c:	f0 e0       	ldi	r31, 0x00	; 0
    541e:	d6 01       	movw	r26, r12
    5420:	ae 0f       	add	r26, r30
    5422:	bf 1f       	adc	r27, r31
    5424:	e0 0f       	add	r30, r16
    5426:	f1 1f       	adc	r31, r17
    5428:	e2 0f       	add	r30, r18
    542a:	f3 1f       	adc	r31, r19
    542c:	80 81       	ld	r24, Z
    542e:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5430:	7f 5f       	subi	r23, 0xFF	; 255
    5432:	76 17       	cp	r23, r22
    5434:	90 f3       	brcs	.-28     	; 0x541a <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    5436:	4c 0d       	add	r20, r12
    5438:	5d 1d       	adc	r21, r13
    543a:	da 01       	movw	r26, r20
    543c:	1c 92       	st	X, r1
    543e:	f8 01       	movw	r30, r16
    5440:	04 c0       	rjmp	.+8      	; 0x544a <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5442:	d7 01       	movw	r26, r14
    5444:	8d 91       	ld	r24, X+
    5446:	7d 01       	movw	r14, r26
    5448:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    544a:	8e 2d       	mov	r24, r14
    544c:	8b 19       	sub	r24, r11
    544e:	86 17       	cp	r24, r22
    5450:	c0 f3       	brcs	.-16     	; 0x5442 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5452:	06 0f       	add	r16, r22
    5454:	11 1d       	adc	r17, r1
    5456:	f8 01       	movw	r30, r16
    5458:	10 82       	st	Z, r1
	 }
}
    545a:	6e 96       	adiw	r28, 0x1e	; 30
    545c:	0f b6       	in	r0, 0x3f	; 63
    545e:	f8 94       	cli
    5460:	de bf       	out	0x3e, r29	; 62
    5462:	0f be       	out	0x3f, r0	; 63
    5464:	cd bf       	out	0x3d, r28	; 61
    5466:	cf 91       	pop	r28
    5468:	df 91       	pop	r29
    546a:	1f 91       	pop	r17
    546c:	0f 91       	pop	r16
    546e:	ff 90       	pop	r15
    5470:	ef 90       	pop	r14
    5472:	df 90       	pop	r13
    5474:	cf 90       	pop	r12
    5476:	bf 90       	pop	r11
    5478:	08 95       	ret

0000547a <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    547a:	0f 93       	push	r16
    547c:	1f 93       	push	r17
    547e:	cf 93       	push	r28
    5480:	df 93       	push	r29
    5482:	18 2f       	mov	r17, r24
    5484:	06 2f       	mov	r16, r22
    5486:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    5488:	ca 01       	movw	r24, r20
    548a:	6d e0       	ldi	r22, 0x0D	; 13
    548c:	0e 94 d6 29 	call	0x53ac	; 0x53ac <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    5490:	81 2f       	mov	r24, r17
    5492:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
    5496:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    5498:	88 23       	and	r24, r24
    549a:	39 f0       	breq	.+14     	; 0x54aa <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    549c:	41 50       	subi	r20, 0x01	; 1
    549e:	81 e0       	ldi	r24, 0x01	; 1
    54a0:	61 e0       	ldi	r22, 0x01	; 1
    54a2:	20 2f       	mov	r18, r16
    54a4:	8e 01       	movw	r16, r28
    54a6:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    54aa:	df 91       	pop	r29
    54ac:	cf 91       	pop	r28
    54ae:	1f 91       	pop	r17
    54b0:	0f 91       	pop	r16
    54b2:	08 95       	ret

000054b4 <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    54b4:	0f 93       	push	r16
    54b6:	1f 93       	push	r17
    54b8:	cf 93       	push	r28
    54ba:	df 93       	push	r29
    54bc:	18 2f       	mov	r17, r24
    54be:	06 2f       	mov	r16, r22
    54c0:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    54c2:	ca 01       	movw	r24, r20
    54c4:	6b e0       	ldi	r22, 0x0B	; 11
    54c6:	0e 94 d6 29 	call	0x53ac	; 0x53ac <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    54ca:	81 2f       	mov	r24, r17
    54cc:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
    54d0:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    54d2:	88 23       	and	r24, r24
    54d4:	39 f0       	breq	.+14     	; 0x54e4 <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    54d6:	41 50       	subi	r20, 0x01	; 1
    54d8:	80 e0       	ldi	r24, 0x00	; 0
    54da:	61 e0       	ldi	r22, 0x01	; 1
    54dc:	20 2f       	mov	r18, r16
    54de:	8e 01       	movw	r16, r28
    54e0:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    54e4:	df 91       	pop	r29
    54e6:	cf 91       	pop	r28
    54e8:	1f 91       	pop	r17
    54ea:	0f 91       	pop	r16
    54ec:	08 95       	ret

000054ee <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    54ee:	ef 92       	push	r14
    54f0:	ff 92       	push	r15
    54f2:	0f 93       	push	r16
    54f4:	1f 93       	push	r17
    54f6:	08 2f       	mov	r16, r24
    54f8:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    54fa:	cb 01       	movw	r24, r22
    54fc:	6a e0       	ldi	r22, 0x0A	; 10
    54fe:	0e 94 d6 29 	call	0x53ac	; 0x53ac <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    5502:	00 d0       	rcall	.+0      	; 0x5504 <GetTransactionMoney+0x16>
    5504:	00 d0       	rcall	.+0      	; 0x5506 <GetTransactionMoney+0x18>
    5506:	00 d0       	rcall	.+0      	; 0x5508 <GetTransactionMoney+0x1a>
    5508:	ed b7       	in	r30, 0x3d	; 61
    550a:	fe b7       	in	r31, 0x3e	; 62
    550c:	31 96       	adiw	r30, 0x01	; 1
    550e:	ad b7       	in	r26, 0x3d	; 61
    5510:	be b7       	in	r27, 0x3e	; 62
    5512:	12 96       	adiw	r26, 0x02	; 2
    5514:	fc 92       	st	X, r15
    5516:	ee 92       	st	-X, r14
    5518:	11 97       	sbiw	r26, 0x01	; 1
    551a:	89 e4       	ldi	r24, 0x49	; 73
    551c:	95 e0       	ldi	r25, 0x05	; 5
    551e:	93 83       	std	Z+3, r25	; 0x03
    5520:	82 83       	std	Z+2, r24	; 0x02
    5522:	10 e0       	ldi	r17, 0x00	; 0
    5524:	0f 70       	andi	r16, 0x0F	; 15
    5526:	10 70       	andi	r17, 0x00	; 0
    5528:	85 e3       	ldi	r24, 0x35	; 53
    552a:	90 e0       	ldi	r25, 0x00	; 0
    552c:	9c 01       	movw	r18, r24
    552e:	02 9f       	mul	r16, r18
    5530:	c0 01       	movw	r24, r0
    5532:	03 9f       	mul	r16, r19
    5534:	90 0d       	add	r25, r0
    5536:	12 9f       	mul	r17, r18
    5538:	90 0d       	add	r25, r0
    553a:	11 24       	eor	r1, r1
    553c:	8c 52       	subi	r24, 0x2C	; 44
    553e:	9a 4f       	sbci	r25, 0xFA	; 250
    5540:	95 83       	std	Z+5, r25	; 0x05
    5542:	84 83       	std	Z+4, r24	; 0x04
    5544:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    5548:	8d b7       	in	r24, 0x3d	; 61
    554a:	9e b7       	in	r25, 0x3e	; 62
    554c:	06 96       	adiw	r24, 0x06	; 6
    554e:	0f b6       	in	r0, 0x3f	; 63
    5550:	f8 94       	cli
    5552:	9e bf       	out	0x3e, r25	; 62
    5554:	0f be       	out	0x3f, r0	; 63
    5556:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    5558:	1f 91       	pop	r17
    555a:	0f 91       	pop	r16
    555c:	ff 90       	pop	r15
    555e:	ef 90       	pop	r14
    5560:	08 95       	ret

00005562 <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    5562:	ef 92       	push	r14
    5564:	ff 92       	push	r15
    5566:	0f 93       	push	r16
    5568:	1f 93       	push	r17
    556a:	08 2f       	mov	r16, r24
    556c:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    556e:	cb 01       	movw	r24, r22
    5570:	6a e0       	ldi	r22, 0x0A	; 10
    5572:	0e 94 d6 29 	call	0x53ac	; 0x53ac <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    5576:	00 d0       	rcall	.+0      	; 0x5578 <GetTransactionVolume+0x16>
    5578:	00 d0       	rcall	.+0      	; 0x557a <GetTransactionVolume+0x18>
    557a:	00 d0       	rcall	.+0      	; 0x557c <GetTransactionVolume+0x1a>
    557c:	ed b7       	in	r30, 0x3d	; 61
    557e:	fe b7       	in	r31, 0x3e	; 62
    5580:	31 96       	adiw	r30, 0x01	; 1
    5582:	ad b7       	in	r26, 0x3d	; 61
    5584:	be b7       	in	r27, 0x3e	; 62
    5586:	12 96       	adiw	r26, 0x02	; 2
    5588:	fc 92       	st	X, r15
    558a:	ee 92       	st	-X, r14
    558c:	11 97       	sbiw	r26, 0x01	; 1
    558e:	8c e4       	ldi	r24, 0x4C	; 76
    5590:	95 e0       	ldi	r25, 0x05	; 5
    5592:	93 83       	std	Z+3, r25	; 0x03
    5594:	82 83       	std	Z+2, r24	; 0x02
    5596:	10 e0       	ldi	r17, 0x00	; 0
    5598:	0f 70       	andi	r16, 0x0F	; 15
    559a:	10 70       	andi	r17, 0x00	; 0
    559c:	85 e3       	ldi	r24, 0x35	; 53
    559e:	90 e0       	ldi	r25, 0x00	; 0
    55a0:	9c 01       	movw	r18, r24
    55a2:	02 9f       	mul	r16, r18
    55a4:	c0 01       	movw	r24, r0
    55a6:	03 9f       	mul	r16, r19
    55a8:	90 0d       	add	r25, r0
    55aa:	12 9f       	mul	r17, r18
    55ac:	90 0d       	add	r25, r0
    55ae:	11 24       	eor	r1, r1
    55b0:	85 53       	subi	r24, 0x35	; 53
    55b2:	9a 4f       	sbci	r25, 0xFA	; 250
    55b4:	95 83       	std	Z+5, r25	; 0x05
    55b6:	84 83       	std	Z+4, r24	; 0x04
    55b8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    55bc:	8d b7       	in	r24, 0x3d	; 61
    55be:	9e b7       	in	r25, 0x3e	; 62
    55c0:	06 96       	adiw	r24, 0x06	; 6
    55c2:	0f b6       	in	r0, 0x3f	; 63
    55c4:	f8 94       	cli
    55c6:	9e bf       	out	0x3e, r25	; 62
    55c8:	0f be       	out	0x3f, r0	; 63
    55ca:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    55cc:	1f 91       	pop	r17
    55ce:	0f 91       	pop	r16
    55d0:	ff 90       	pop	r15
    55d2:	ef 90       	pop	r14
    55d4:	08 95       	ret

000055d6 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    55d6:	af 92       	push	r10
    55d8:	bf 92       	push	r11
    55da:	cf 92       	push	r12
    55dc:	df 92       	push	r13
    55de:	ef 92       	push	r14
    55e0:	ff 92       	push	r15
    55e2:	0f 93       	push	r16
    55e4:	1f 93       	push	r17
    55e6:	df 93       	push	r29
    55e8:	cf 93       	push	r28
    55ea:	cd b7       	in	r28, 0x3d	; 61
    55ec:	de b7       	in	r29, 0x3e	; 62
    55ee:	65 97       	sbiw	r28, 0x15	; 21
    55f0:	0f b6       	in	r0, 0x3f	; 63
    55f2:	f8 94       	cli
    55f4:	de bf       	out	0x3e, r29	; 62
    55f6:	0f be       	out	0x3f, r0	; 63
    55f8:	cd bf       	out	0x3d, r28	; 61
    55fa:	d8 2e       	mov	r13, r24
    55fc:	c6 2e       	mov	r12, r22
    55fe:	b4 2e       	mov	r11, r20
    5600:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    5602:	d8 01       	movw	r26, r16
    5604:	0d 90       	ld	r0, X+
    5606:	00 20       	and	r0, r0
    5608:	e9 f7       	brne	.-6      	; 0x5604 <SetTotalizerData+0x2e>
    560a:	11 97       	sbiw	r26, 0x01	; 1
    560c:	a0 1b       	sub	r26, r16
    560e:	b1 0b       	sbc	r27, r17
    5610:	f7 e0       	ldi	r31, 0x07	; 7
    5612:	ef 2e       	mov	r14, r31
    5614:	f1 2c       	mov	r15, r1
    5616:	ec 0e       	add	r14, r28
    5618:	fd 1e       	adc	r15, r29
    561a:	ad 30       	cpi	r26, 0x0D	; 13
    561c:	b1 05       	cpc	r27, r1
    561e:	58 f5       	brcc	.+86     	; 0x5676 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    5620:	00 d0       	rcall	.+0      	; 0x5622 <SetTotalizerData+0x4c>
    5622:	00 d0       	rcall	.+0      	; 0x5624 <SetTotalizerData+0x4e>
    5624:	00 d0       	rcall	.+0      	; 0x5626 <SetTotalizerData+0x50>
    5626:	ed b7       	in	r30, 0x3d	; 61
    5628:	fe b7       	in	r31, 0x3e	; 62
    562a:	31 96       	adiw	r30, 0x01	; 1
    562c:	ad b7       	in	r26, 0x3d	; 61
    562e:	be b7       	in	r27, 0x3e	; 62
    5630:	12 96       	adiw	r26, 0x02	; 2
    5632:	fc 92       	st	X, r15
    5634:	ee 92       	st	-X, r14
    5636:	11 97       	sbiw	r26, 0x01	; 1
    5638:	8e e1       	ldi	r24, 0x1E	; 30
    563a:	97 e0       	ldi	r25, 0x07	; 7
    563c:	93 83       	std	Z+3, r25	; 0x03
    563e:	82 83       	std	Z+2, r24	; 0x02
    5640:	15 83       	std	Z+5, r17	; 0x05
    5642:	04 83       	std	Z+4, r16	; 0x04
    5644:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    5648:	f7 01       	movw	r30, r14
    564a:	01 90       	ld	r0, Z+
    564c:	00 20       	and	r0, r0
    564e:	e9 f7       	brne	.-6      	; 0x564a <SetTotalizerData+0x74>
    5650:	31 97       	sbiw	r30, 0x01	; 1
    5652:	ee 19       	sub	r30, r14
    5654:	ff 09       	sbc	r31, r15
    5656:	6d b7       	in	r22, 0x3d	; 61
    5658:	7e b7       	in	r23, 0x3e	; 62
    565a:	6a 5f       	subi	r22, 0xFA	; 250
    565c:	7f 4f       	sbci	r23, 0xFF	; 255
    565e:	0f b6       	in	r0, 0x3f	; 63
    5660:	f8 94       	cli
    5662:	7e bf       	out	0x3e, r23	; 62
    5664:	0f be       	out	0x3f, r0	; 63
    5666:	6d bf       	out	0x3d, r22	; 61
    5668:	3c 97       	sbiw	r30, 0x0c	; 12
    566a:	a0 f4       	brcc	.+40     	; 0x5694 <SetTotalizerData+0xbe>
    566c:	c7 01       	movw	r24, r14
    566e:	6c e0       	ldi	r22, 0x0C	; 12
    5670:	0e 94 d6 29 	call	0x53ac	; 0x53ac <AddZeroLead>
    5674:	0f c0       	rjmp	.+30     	; 0x5694 <SetTotalizerData+0xbe>
    5676:	8a 2f       	mov	r24, r26
    5678:	8c 50       	subi	r24, 0x0C	; 12
    567a:	f8 01       	movw	r30, r16
    567c:	e8 0f       	add	r30, r24
    567e:	f1 1d       	adc	r31, r1
    5680:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5682:	9e 01       	movw	r18, r28
    5684:	2d 5e       	subi	r18, 0xED	; 237
    5686:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    5688:	81 91       	ld	r24, Z+
    568a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    568c:	a2 17       	cp	r26, r18
    568e:	b3 07       	cpc	r27, r19
    5690:	d9 f7       	brne	.-10     	; 0x5688 <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    5692:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    5694:	0b 2d       	mov	r16, r11
    5696:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    5698:	1a 2d       	mov	r17, r10
    569a:	11 50       	subi	r17, 0x01	; 1
    569c:	16 30       	cpi	r17, 0x06	; 6
    569e:	08 f0       	brcs	.+2      	; 0x56a2 <SetTotalizerData+0xcc>
    56a0:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    56a2:	ce 01       	movw	r24, r28
    56a4:	07 96       	adiw	r24, 0x07	; 7
    56a6:	7e 01       	movw	r14, r28
    56a8:	08 94       	sec
    56aa:	e1 1c       	adc	r14, r1
    56ac:	f1 1c       	adc	r15, r1
    56ae:	b7 01       	movw	r22, r14
    56b0:	0e 94 0b 1a 	call	0x3416	; 0x3416 <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    56b4:	dd 20       	and	r13, r13
    56b6:	d9 f4       	brne	.+54     	; 0x56ee <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    56b8:	84 e2       	ldi	r24, 0x24	; 36
    56ba:	08 9f       	mul	r16, r24
    56bc:	c0 01       	movw	r24, r0
    56be:	11 24       	eor	r1, r1
    56c0:	4c 2d       	mov	r20, r12
    56c2:	50 e0       	ldi	r21, 0x00	; 0
    56c4:	20 e2       	ldi	r18, 0x20	; 32
    56c6:	31 e0       	ldi	r19, 0x01	; 1
    56c8:	d9 01       	movw	r26, r18
    56ca:	4a 9f       	mul	r20, r26
    56cc:	90 01       	movw	r18, r0
    56ce:	4b 9f       	mul	r20, r27
    56d0:	30 0d       	add	r19, r0
    56d2:	5a 9f       	mul	r21, r26
    56d4:	30 0d       	add	r19, r0
    56d6:	11 24       	eor	r1, r1
    56d8:	82 0f       	add	r24, r18
    56da:	93 1f       	adc	r25, r19
    56dc:	26 e0       	ldi	r18, 0x06	; 6
    56de:	12 9f       	mul	r17, r18
    56e0:	90 01       	movw	r18, r0
    56e2:	11 24       	eor	r1, r1
    56e4:	82 0f       	add	r24, r18
    56e6:	93 1f       	adc	r25, r19
    56e8:	8d 53       	subi	r24, 0x3D	; 61
    56ea:	9c 4f       	sbci	r25, 0xFC	; 252
    56ec:	1d c0       	rjmp	.+58     	; 0x5728 <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    56ee:	b1 e0       	ldi	r27, 0x01	; 1
    56f0:	db 16       	cp	r13, r27
    56f2:	09 f5       	brne	.+66     	; 0x5736 <SetTotalizerData+0x160>
    56f4:	84 e2       	ldi	r24, 0x24	; 36
    56f6:	08 9f       	mul	r16, r24
    56f8:	c0 01       	movw	r24, r0
    56fa:	11 24       	eor	r1, r1
    56fc:	4c 2d       	mov	r20, r12
    56fe:	50 e0       	ldi	r21, 0x00	; 0
    5700:	20 e2       	ldi	r18, 0x20	; 32
    5702:	31 e0       	ldi	r19, 0x01	; 1
    5704:	b9 01       	movw	r22, r18
    5706:	46 9f       	mul	r20, r22
    5708:	90 01       	movw	r18, r0
    570a:	47 9f       	mul	r20, r23
    570c:	30 0d       	add	r19, r0
    570e:	56 9f       	mul	r21, r22
    5710:	30 0d       	add	r19, r0
    5712:	11 24       	eor	r1, r1
    5714:	82 0f       	add	r24, r18
    5716:	93 1f       	adc	r25, r19
    5718:	26 e0       	ldi	r18, 0x06	; 6
    571a:	12 9f       	mul	r17, r18
    571c:	90 01       	movw	r18, r0
    571e:	11 24       	eor	r1, r1
    5720:	82 0f       	add	r24, r18
    5722:	93 1f       	adc	r25, r19
    5724:	8d 5f       	subi	r24, 0xFD	; 253
    5726:	99 4f       	sbci	r25, 0xF9	; 249
    5728:	b7 01       	movw	r22, r14
    572a:	46 e0       	ldi	r20, 0x06	; 6
    572c:	50 e0       	ldi	r21, 0x00	; 0
    572e:	2a ed       	ldi	r18, 0xDA	; 218
    5730:	33 e1       	ldi	r19, 0x13	; 19
    5732:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
}
    5736:	65 96       	adiw	r28, 0x15	; 21
    5738:	0f b6       	in	r0, 0x3f	; 63
    573a:	f8 94       	cli
    573c:	de bf       	out	0x3e, r29	; 62
    573e:	0f be       	out	0x3f, r0	; 63
    5740:	cd bf       	out	0x3d, r28	; 61
    5742:	cf 91       	pop	r28
    5744:	df 91       	pop	r29
    5746:	1f 91       	pop	r17
    5748:	0f 91       	pop	r16
    574a:	ff 90       	pop	r15
    574c:	ef 90       	pop	r14
    574e:	df 90       	pop	r13
    5750:	cf 90       	pop	r12
    5752:	bf 90       	pop	r11
    5754:	af 90       	pop	r10
    5756:	08 95       	ret

00005758 <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    5758:	4f 92       	push	r4
    575a:	5f 92       	push	r5
    575c:	7f 92       	push	r7
    575e:	8f 92       	push	r8
    5760:	9f 92       	push	r9
    5762:	af 92       	push	r10
    5764:	bf 92       	push	r11
    5766:	cf 92       	push	r12
    5768:	df 92       	push	r13
    576a:	ef 92       	push	r14
    576c:	ff 92       	push	r15
    576e:	0f 93       	push	r16
    5770:	1f 93       	push	r17
    5772:	df 93       	push	r29
    5774:	cf 93       	push	r28
    5776:	cd b7       	in	r28, 0x3d	; 61
    5778:	de b7       	in	r29, 0x3e	; 62
    577a:	2f 97       	sbiw	r28, 0x0f	; 15
    577c:	0f b6       	in	r0, 0x3f	; 63
    577e:	f8 94       	cli
    5780:	de bf       	out	0x3e, r29	; 62
    5782:	0f be       	out	0x3f, r0	; 63
    5784:	cd bf       	out	0x3d, r28	; 61
    5786:	77 24       	eor	r7, r7
    5788:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    578a:	4e 01       	movw	r8, r28
    578c:	08 94       	sec
    578e:	81 1c       	adc	r8, r1
    5790:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5792:	a0 e1       	ldi	r26, 0x10	; 16
    5794:	4a 2e       	mov	r4, r26
    5796:	51 2c       	mov	r5, r1
    5798:	4c 0e       	add	r4, r28
    579a:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    579c:	87 2d       	mov	r24, r7
    579e:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
		  if (FIPAddr>0){
    57a2:	88 23       	and	r24, r24
    57a4:	91 f1       	breq	.+100    	; 0x580a <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    57a6:	a8 2e       	mov	r10, r24
    57a8:	aa 94       	dec	r10
    57aa:	bb 24       	eor	r11, r11
    57ac:	b3 94       	inc	r11
    57ae:	2a c0       	rjmp	.+84     	; 0x5804 <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    57b0:	f7 01       	movw	r30, r14
    57b2:	11 92       	st	Z+, r1
    57b4:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    57b6:	e4 15       	cp	r30, r4
    57b8:	f5 05       	cpc	r31, r5
    57ba:	d1 f7       	brne	.-12     	; 0x57b0 <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    57bc:	80 e0       	ldi	r24, 0x00	; 0
    57be:	61 e0       	ldi	r22, 0x01	; 1
    57c0:	4a 2d       	mov	r20, r10
    57c2:	2b 2d       	mov	r18, r11
    57c4:	84 01       	movw	r16, r8
    57c6:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    57ca:	80 e0       	ldi	r24, 0x00	; 0
    57cc:	60 e0       	ldi	r22, 0x00	; 0
    57ce:	4a 2d       	mov	r20, r10
    57d0:	2b 2d       	mov	r18, r11
    57d2:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    57d6:	f6 01       	movw	r30, r12
    57d8:	11 92       	st	Z+, r1
    57da:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    57dc:	ee 15       	cp	r30, r14
    57de:	ff 05       	cpc	r31, r15
    57e0:	d1 f7       	brne	.-12     	; 0x57d6 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    57e2:	81 e0       	ldi	r24, 0x01	; 1
    57e4:	61 e0       	ldi	r22, 0x01	; 1
    57e6:	4a 2d       	mov	r20, r10
    57e8:	2b 2d       	mov	r18, r11
    57ea:	84 01       	movw	r16, r8
    57ec:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    57f0:	81 e0       	ldi	r24, 0x01	; 1
    57f2:	60 e0       	ldi	r22, 0x00	; 0
    57f4:	4a 2d       	mov	r20, r10
    57f6:	2b 2d       	mov	r18, r11
    57f8:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    57fc:	b3 94       	inc	r11
    57fe:	f7 e0       	ldi	r31, 0x07	; 7
    5800:	bf 16       	cp	r11, r31
    5802:	19 f0       	breq	.+6      	; 0x580a <SaveTotalizerCurrentToLast+0xb2>
    5804:	64 01       	movw	r12, r8
    5806:	74 01       	movw	r14, r8
    5808:	d3 cf       	rjmp	.-90     	; 0x57b0 <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    580a:	73 94       	inc	r7
    580c:	81 e1       	ldi	r24, 0x11	; 17
    580e:	78 16       	cp	r7, r24
    5810:	29 f6       	brne	.-118    	; 0x579c <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    5812:	2f 96       	adiw	r28, 0x0f	; 15
    5814:	0f b6       	in	r0, 0x3f	; 63
    5816:	f8 94       	cli
    5818:	de bf       	out	0x3e, r29	; 62
    581a:	0f be       	out	0x3f, r0	; 63
    581c:	cd bf       	out	0x3d, r28	; 61
    581e:	cf 91       	pop	r28
    5820:	df 91       	pop	r29
    5822:	1f 91       	pop	r17
    5824:	0f 91       	pop	r16
    5826:	ff 90       	pop	r15
    5828:	ef 90       	pop	r14
    582a:	df 90       	pop	r13
    582c:	cf 90       	pop	r12
    582e:	bf 90       	pop	r11
    5830:	af 90       	pop	r10
    5832:	9f 90       	pop	r9
    5834:	8f 90       	pop	r8
    5836:	7f 90       	pop	r7
    5838:	5f 90       	pop	r5
    583a:	4f 90       	pop	r4
    583c:	08 95       	ret

0000583e <ResetTotalizer>:
}

//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    583e:	af 92       	push	r10
    5840:	bf 92       	push	r11
    5842:	cf 92       	push	r12
    5844:	df 92       	push	r13
    5846:	ef 92       	push	r14
    5848:	ff 92       	push	r15
    584a:	0f 93       	push	r16
    584c:	1f 93       	push	r17
    584e:	df 93       	push	r29
    5850:	cf 93       	push	r28
    5852:	cd b7       	in	r28, 0x3d	; 61
    5854:	de b7       	in	r29, 0x3e	; 62
    5856:	29 97       	sbiw	r28, 0x09	; 9
    5858:	0f b6       	in	r0, 0x3f	; 63
    585a:	f8 94       	cli
    585c:	de bf       	out	0x3e, r29	; 62
    585e:	0f be       	out	0x3f, r0	; 63
    5860:	cd bf       	out	0x3d, r28	; 61
    5862:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    5864:	00 d0       	rcall	.+0      	; 0x5866 <ResetTotalizer+0x28>
    5866:	00 d0       	rcall	.+0      	; 0x5868 <ResetTotalizer+0x2a>
    5868:	6e 01       	movw	r12, r28
    586a:	08 94       	sec
    586c:	c1 1c       	adc	r12, r1
    586e:	d1 1c       	adc	r13, r1
    5870:	ed b7       	in	r30, 0x3d	; 61
    5872:	fe b7       	in	r31, 0x3e	; 62
    5874:	d2 82       	std	Z+2, r13	; 0x02
    5876:	c1 82       	std	Z+1, r12	; 0x01
    5878:	81 e2       	ldi	r24, 0x21	; 33
    587a:	97 e0       	ldi	r25, 0x07	; 7
    587c:	94 83       	std	Z+4, r25	; 0x04
    587e:	83 83       	std	Z+3, r24	; 0x03
    5880:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    5884:	ee 24       	eor	r14, r14
    5886:	e3 94       	inc	r14
    5888:	0f 90       	pop	r0
    588a:	0f 90       	pop	r0
    588c:	0f 90       	pop	r0
    588e:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    5890:	8e 2d       	mov	r24, r14
    5892:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
		  if (FIPAddr>0){
    5896:	88 23       	and	r24, r24
    5898:	a9 f0       	breq	.+42     	; 0x58c4 <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    589a:	b8 2e       	mov	r11, r24
    589c:	ba 94       	dec	r11
    589e:	ff 24       	eor	r15, r15
    58a0:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    58a2:	80 e0       	ldi	r24, 0x00	; 0
    58a4:	6a 2d       	mov	r22, r10
    58a6:	4b 2d       	mov	r20, r11
    58a8:	2f 2d       	mov	r18, r15
    58aa:	86 01       	movw	r16, r12
    58ac:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    58b0:	81 e0       	ldi	r24, 0x01	; 1
    58b2:	6a 2d       	mov	r22, r10
    58b4:	4b 2d       	mov	r20, r11
    58b6:	2f 2d       	mov	r18, r15
    58b8:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    58bc:	f3 94       	inc	r15
    58be:	f7 e0       	ldi	r31, 0x07	; 7
    58c0:	ff 16       	cp	r15, r31
    58c2:	79 f7       	brne	.-34     	; 0x58a2 <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    58c4:	e3 94       	inc	r14
    58c6:	81 e1       	ldi	r24, 0x11	; 17
    58c8:	e8 16       	cp	r14, r24
    58ca:	11 f7       	brne	.-60     	; 0x5890 <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    58cc:	29 96       	adiw	r28, 0x09	; 9
    58ce:	0f b6       	in	r0, 0x3f	; 63
    58d0:	f8 94       	cli
    58d2:	de bf       	out	0x3e, r29	; 62
    58d4:	0f be       	out	0x3f, r0	; 63
    58d6:	cd bf       	out	0x3d, r28	; 61
    58d8:	cf 91       	pop	r28
    58da:	df 91       	pop	r29
    58dc:	1f 91       	pop	r17
    58de:	0f 91       	pop	r16
    58e0:	ff 90       	pop	r15
    58e2:	ef 90       	pop	r14
    58e4:	df 90       	pop	r13
    58e6:	cf 90       	pop	r12
    58e8:	bf 90       	pop	r11
    58ea:	af 90       	pop	r10
    58ec:	08 95       	ret

000058ee <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    58ee:	cf 93       	push	r28
    58f0:	df 93       	push	r29
    58f2:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    58f4:	dc 01       	movw	r26, r24
    58f6:	0d 90       	ld	r0, X+
    58f8:	00 20       	and	r0, r0
    58fa:	e9 f7       	brne	.-6      	; 0x58f6 <AddZeroLag+0x8>
    58fc:	11 97       	sbiw	r26, 0x01	; 1
    58fe:	a8 1b       	sub	r26, r24
    5900:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5902:	a6 17       	cp	r26, r22
    5904:	60 f4       	brcc	.+24     	; 0x591e <AddZeroLag+0x30>
    5906:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    5908:	90 e3       	ldi	r25, 0x30	; 48
    590a:	fe 01       	movw	r30, r28
    590c:	e8 0f       	add	r30, r24
    590e:	f1 1d       	adc	r31, r1
    5910:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5912:	8f 5f       	subi	r24, 0xFF	; 255
    5914:	86 17       	cp	r24, r22
    5916:	c8 f3       	brcs	.-14     	; 0x590a <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    5918:	c6 0f       	add	r28, r22
    591a:	d1 1d       	adc	r29, r1
    591c:	18 82       	st	Y, r1
  }
}
    591e:	df 91       	pop	r29
    5920:	cf 91       	pop	r28
    5922:	08 95       	ret

00005924 <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    5924:	3f 92       	push	r3
    5926:	4f 92       	push	r4
    5928:	5f 92       	push	r5
    592a:	6f 92       	push	r6
    592c:	7f 92       	push	r7
    592e:	8f 92       	push	r8
    5930:	9f 92       	push	r9
    5932:	af 92       	push	r10
    5934:	bf 92       	push	r11
    5936:	cf 92       	push	r12
    5938:	df 92       	push	r13
    593a:	ef 92       	push	r14
    593c:	ff 92       	push	r15
    593e:	0f 93       	push	r16
    5940:	1f 93       	push	r17
    5942:	df 93       	push	r29
    5944:	cf 93       	push	r28
    5946:	cd b7       	in	r28, 0x3d	; 61
    5948:	de b7       	in	r29, 0x3e	; 62
    594a:	c8 55       	subi	r28, 0x58	; 88
    594c:	d0 40       	sbci	r29, 0x00	; 0
    594e:	0f b6       	in	r0, 0x3f	; 63
    5950:	f8 94       	cli
    5952:	de bf       	out	0x3e, r29	; 62
    5954:	0f be       	out	0x3f, r0	; 63
    5956:	cd bf       	out	0x3d, r28	; 61
    5958:	68 2e       	mov	r6, r24
    595a:	67 96       	adiw	r28, 0x17	; 23
    595c:	7f af       	std	Y+63, r23	; 0x3f
    595e:	6e af       	std	Y+62, r22	; 0x3e
    5960:	67 97       	sbiw	r28, 0x17	; 23
    5962:	69 96       	adiw	r28, 0x19	; 25
    5964:	5f af       	std	Y+63, r21	; 0x3f
    5966:	4e af       	std	Y+62, r20	; 0x3e
    5968:	69 97       	sbiw	r28, 0x19	; 25
    596a:	59 01       	movw	r10, r18
    596c:	fe 01       	movw	r30, r28
    596e:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5970:	ce 01       	movw	r24, r28
    5972:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    5974:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5976:	e8 17       	cp	r30, r24
    5978:	f9 07       	cpc	r31, r25
    597a:	e1 f7       	brne	.-8      	; 0x5974 <StrCalc+0x50>
	     strMemory[i]=data;
    597c:	ce 01       	movw	r24, r28
    597e:	89 96       	adiw	r24, 0x29	; 41
    5980:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5982:	e8 17       	cp	r30, r24
    5984:	f9 07       	cpc	r31, r25
    5986:	e1 f7       	brne	.-8      	; 0x5980 <StrCalc+0x5c>
    5988:	fe 01       	movw	r30, r28
    598a:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    598c:	cf 01       	movw	r24, r30
    598e:	44 96       	adiw	r24, 0x14	; 20
    5990:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5992:	e8 17       	cp	r30, r24
    5994:	f9 07       	cpc	r31, r25
    5996:	e1 f7       	brne	.-8      	; 0x5990 <StrCalc+0x6c>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    5998:	00 d0       	rcall	.+0      	; 0x599a <StrCalc+0x76>
    599a:	00 d0       	rcall	.+0      	; 0x599c <StrCalc+0x78>
    599c:	00 d0       	rcall	.+0      	; 0x599e <StrCalc+0x7a>
    599e:	ed b7       	in	r30, 0x3d	; 61
    59a0:	fe b7       	in	r31, 0x3e	; 62
    59a2:	31 96       	adiw	r30, 0x01	; 1
    59a4:	8e 01       	movw	r16, r28
    59a6:	0f 5f       	subi	r16, 0xFF	; 255
    59a8:	1f 4f       	sbci	r17, 0xFF	; 255
    59aa:	ad b7       	in	r26, 0x3d	; 61
    59ac:	be b7       	in	r27, 0x3e	; 62
    59ae:	12 96       	adiw	r26, 0x02	; 2
    59b0:	1c 93       	st	X, r17
    59b2:	0e 93       	st	-X, r16
    59b4:	11 97       	sbiw	r26, 0x01	; 1
    59b6:	8b e1       	ldi	r24, 0x1B	; 27
    59b8:	97 e0       	ldi	r25, 0x07	; 7
    59ba:	93 83       	std	Z+3, r25	; 0x03
    59bc:	82 83       	std	Z+2, r24	; 0x02
    59be:	67 96       	adiw	r28, 0x17	; 23
    59c0:	2e ad       	ldd	r18, Y+62	; 0x3e
    59c2:	3f ad       	ldd	r19, Y+63	; 0x3f
    59c4:	67 97       	sbiw	r28, 0x17	; 23
    59c6:	35 83       	std	Z+5, r19	; 0x05
    59c8:	24 83       	std	Z+4, r18	; 0x04
    59ca:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    59ce:	ed b7       	in	r30, 0x3d	; 61
    59d0:	fe b7       	in	r31, 0x3e	; 62
    59d2:	31 96       	adiw	r30, 0x01	; 1
    59d4:	ce 01       	movw	r24, r28
    59d6:	45 96       	adiw	r24, 0x15	; 21
    59d8:	ad b7       	in	r26, 0x3d	; 61
    59da:	be b7       	in	r27, 0x3e	; 62
    59dc:	12 96       	adiw	r26, 0x02	; 2
    59de:	9c 93       	st	X, r25
    59e0:	8e 93       	st	-X, r24
    59e2:	11 97       	sbiw	r26, 0x01	; 1
    59e4:	88 e1       	ldi	r24, 0x18	; 24
    59e6:	97 e0       	ldi	r25, 0x07	; 7
    59e8:	93 83       	std	Z+3, r25	; 0x03
    59ea:	82 83       	std	Z+2, r24	; 0x02
    59ec:	69 96       	adiw	r28, 0x19	; 25
    59ee:	2e ad       	ldd	r18, Y+62	; 0x3e
    59f0:	3f ad       	ldd	r19, Y+63	; 0x3f
    59f2:	69 97       	sbiw	r28, 0x19	; 25
    59f4:	35 83       	std	Z+5, r19	; 0x05
    59f6:	24 83       	std	Z+4, r18	; 0x04
    59f8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>

     if (IsMinus(tmpA)==True){
    59fc:	8d b7       	in	r24, 0x3d	; 61
    59fe:	9e b7       	in	r25, 0x3e	; 62
    5a00:	06 96       	adiw	r24, 0x06	; 6
    5a02:	0f b6       	in	r0, 0x3f	; 63
    5a04:	f8 94       	cli
    5a06:	9e bf       	out	0x3e, r25	; 62
    5a08:	0f be       	out	0x3f, r0	; 63
    5a0a:	8d bf       	out	0x3d, r24	; 61
    5a0c:	c8 01       	movw	r24, r16
    5a0e:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <IsMinus>
    5a12:	81 30       	cpi	r24, 0x01	; 1
    5a14:	21 f0       	breq	.+8      	; 0x5a1e <StrCalc+0xfa>
    5a16:	65 96       	adiw	r28, 0x15	; 21
    5a18:	1f ae       	std	Y+63, r1	; 0x3f
    5a1a:	65 97       	sbiw	r28, 0x15	; 21
    5a1c:	07 c0       	rjmp	.+14     	; 0x5a2c <StrCalc+0x108>
	     RemoveMinus(tmpA);
    5a1e:	c8 01       	movw	r24, r16
    5a20:	0e 94 92 26 	call	0x4d24	; 0x4d24 <RemoveMinus>
    5a24:	91 e0       	ldi	r25, 0x01	; 1
    5a26:	65 96       	adiw	r28, 0x15	; 21
    5a28:	9f af       	std	Y+63, r25	; 0x3f
    5a2a:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    5a2c:	8e 01       	movw	r16, r28
    5a2e:	0b 5e       	subi	r16, 0xEB	; 235
    5a30:	1f 4f       	sbci	r17, 0xFF	; 255
    5a32:	c8 01       	movw	r24, r16
    5a34:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <IsMinus>
    5a38:	81 30       	cpi	r24, 0x01	; 1
    5a3a:	21 f0       	breq	.+8      	; 0x5a44 <StrCalc+0x120>
    5a3c:	64 96       	adiw	r28, 0x14	; 20
    5a3e:	1f ae       	std	Y+63, r1	; 0x3f
    5a40:	64 97       	sbiw	r28, 0x14	; 20
    5a42:	07 c0       	rjmp	.+14     	; 0x5a52 <StrCalc+0x12e>
	     RemoveMinus(tmpB);
    5a44:	c8 01       	movw	r24, r16
    5a46:	0e 94 92 26 	call	0x4d24	; 0x4d24 <RemoveMinus>
    5a4a:	a1 e0       	ldi	r26, 0x01	; 1
    5a4c:	64 96       	adiw	r28, 0x14	; 20
    5a4e:	af af       	std	Y+63, r26	; 0x3f
    5a50:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    5a52:	fe 01       	movw	r30, r28
    5a54:	31 96       	adiw	r30, 0x01	; 1
    5a56:	df 01       	movw	r26, r30
    5a58:	0d 90       	ld	r0, X+
    5a5a:	00 20       	and	r0, r0
    5a5c:	e9 f7       	brne	.-6      	; 0x5a58 <StrCalc+0x134>
    5a5e:	cd 01       	movw	r24, r26
    5a60:	01 97       	sbiw	r24, 0x01	; 1
    5a62:	8e 1b       	sub	r24, r30
    5a64:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    5a66:	de 01       	movw	r26, r28
    5a68:	55 96       	adiw	r26, 0x15	; 21
    5a6a:	fd 01       	movw	r30, r26
    5a6c:	01 90       	ld	r0, Z+
    5a6e:	00 20       	and	r0, r0
    5a70:	e9 f7       	brne	.-6      	; 0x5a6c <StrCalc+0x148>
    5a72:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    5a74:	1e 2f       	mov	r17, r30
    5a76:	1a 1b       	sub	r17, r26
    5a78:	18 17       	cp	r17, r24
    5a7a:	08 f4       	brcc	.+2      	; 0x5a7e <StrCalc+0x15a>
    5a7c:	18 2f       	mov	r17, r24
    5a7e:	1f 5f       	subi	r17, 0xFF	; 255
    5a80:	7e 01       	movw	r14, r28
    5a82:	08 94       	sec
    5a84:	e1 1c       	adc	r14, r1
    5a86:	f1 1c       	adc	r15, r1
    5a88:	c7 01       	movw	r24, r14
    5a8a:	61 2f       	mov	r22, r17
    5a8c:	0e 94 d6 29 	call	0x53ac	; 0x53ac <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    5a90:	95 e1       	ldi	r25, 0x15	; 21
    5a92:	c9 2e       	mov	r12, r25
    5a94:	d1 2c       	mov	r13, r1
    5a96:	cc 0e       	add	r12, r28
    5a98:	dd 1e       	adc	r13, r29
    5a9a:	c6 01       	movw	r24, r12
    5a9c:	61 2f       	mov	r22, r17
    5a9e:	0e 94 d6 29 	call	0x53ac	; 0x53ac <AddZeroLead>
	 uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    5aa2:	f7 01       	movw	r30, r14
    5aa4:	01 90       	ld	r0, Z+
    5aa6:	00 20       	and	r0, r0
    5aa8:	e9 f7       	brne	.-6      	; 0x5aa4 <StrCalc+0x180>
    5aaa:	31 97       	sbiw	r30, 0x01	; 1
    5aac:	7e 2e       	mov	r7, r30
    5aae:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    5ab0:	f6 01       	movw	r30, r12
    5ab2:	01 90       	ld	r0, Z+
    5ab4:	00 20       	and	r0, r0
    5ab6:	e9 f7       	brne	.-6      	; 0x5ab2 <StrCalc+0x18e>
    5ab8:	31 97       	sbiw	r30, 0x01	; 1
    5aba:	9e 2e       	mov	r9, r30
    5abc:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    5abe:	c6 01       	movw	r24, r12
    5ac0:	b7 01       	movw	r22, r14
    5ac2:	0e 94 bf 26 	call	0x4d7e	; 0x4d7e <IsMoreThan>
    5ac6:	81 30       	cpi	r24, 0x01	; 1
    5ac8:	11 f0       	breq	.+4      	; 0x5ace <StrCalc+0x1aa>
    5aca:	80 e0       	ldi	r24, 0x00	; 0
    5acc:	42 c0       	rjmp	.+132    	; 0x5b52 <StrCalc+0x22e>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    5ace:	00 d0       	rcall	.+0      	; 0x5ad0 <StrCalc+0x1ac>
    5ad0:	00 d0       	rcall	.+0      	; 0x5ad2 <StrCalc+0x1ae>
    5ad2:	00 d0       	rcall	.+0      	; 0x5ad4 <StrCalc+0x1b0>
    5ad4:	ed b7       	in	r30, 0x3d	; 61
    5ad6:	fe b7       	in	r31, 0x3e	; 62
    5ad8:	31 96       	adiw	r30, 0x01	; 1
    5ada:	8e 01       	movw	r16, r28
    5adc:	07 5d       	subi	r16, 0xD7	; 215
    5ade:	1f 4f       	sbci	r17, 0xFF	; 255
    5ae0:	ad b7       	in	r26, 0x3d	; 61
    5ae2:	be b7       	in	r27, 0x3e	; 62
    5ae4:	12 96       	adiw	r26, 0x02	; 2
    5ae6:	1c 93       	st	X, r17
    5ae8:	0e 93       	st	-X, r16
    5aea:	11 97       	sbiw	r26, 0x01	; 1
    5aec:	85 e1       	ldi	r24, 0x15	; 21
    5aee:	97 e0       	ldi	r25, 0x07	; 7
    5af0:	93 83       	std	Z+3, r25	; 0x03
    5af2:	82 83       	std	Z+2, r24	; 0x02
    5af4:	f5 82       	std	Z+5, r15	; 0x05
    5af6:	e4 82       	std	Z+4, r14	; 0x04
    5af8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    5afc:	ed b7       	in	r30, 0x3d	; 61
    5afe:	fe b7       	in	r31, 0x3e	; 62
    5b00:	31 96       	adiw	r30, 0x01	; 1
    5b02:	ad b7       	in	r26, 0x3d	; 61
    5b04:	be b7       	in	r27, 0x3e	; 62
    5b06:	12 96       	adiw	r26, 0x02	; 2
    5b08:	fc 92       	st	X, r15
    5b0a:	ee 92       	st	-X, r14
    5b0c:	11 97       	sbiw	r26, 0x01	; 1
    5b0e:	82 e1       	ldi	r24, 0x12	; 18
    5b10:	97 e0       	ldi	r25, 0x07	; 7
    5b12:	93 83       	std	Z+3, r25	; 0x03
    5b14:	82 83       	std	Z+2, r24	; 0x02
    5b16:	d5 82       	std	Z+5, r13	; 0x05
    5b18:	c4 82       	std	Z+4, r12	; 0x04
    5b1a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    5b1e:	ed b7       	in	r30, 0x3d	; 61
    5b20:	fe b7       	in	r31, 0x3e	; 62
    5b22:	31 96       	adiw	r30, 0x01	; 1
    5b24:	ad b7       	in	r26, 0x3d	; 61
    5b26:	be b7       	in	r27, 0x3e	; 62
    5b28:	12 96       	adiw	r26, 0x02	; 2
    5b2a:	dc 92       	st	X, r13
    5b2c:	ce 92       	st	-X, r12
    5b2e:	11 97       	sbiw	r26, 0x01	; 1
    5b30:	8f e0       	ldi	r24, 0x0F	; 15
    5b32:	97 e0       	ldi	r25, 0x07	; 7
    5b34:	93 83       	std	Z+3, r25	; 0x03
    5b36:	82 83       	std	Z+2, r24	; 0x02
    5b38:	15 83       	std	Z+5, r17	; 0x05
    5b3a:	04 83       	std	Z+4, r16	; 0x04
    5b3c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    5b40:	81 e0       	ldi	r24, 0x01	; 1
    5b42:	ed b7       	in	r30, 0x3d	; 61
    5b44:	fe b7       	in	r31, 0x3e	; 62
    5b46:	36 96       	adiw	r30, 0x06	; 6
    5b48:	0f b6       	in	r0, 0x3f	; 63
    5b4a:	f8 94       	cli
    5b4c:	fe bf       	out	0x3e, r31	; 62
    5b4e:	0f be       	out	0x3f, r0	; 63
    5b50:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    5b52:	66 20       	and	r6, r6
    5b54:	39 f5       	brne	.+78     	; 0x5ba4 <StrCalc+0x280>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5b56:	81 30       	cpi	r24, 0x01	; 1
    5b58:	99 f4       	brne	.+38     	; 0x5b80 <StrCalc+0x25c>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    5b5a:	65 96       	adiw	r28, 0x15	; 21
    5b5c:	ff ad       	ldd	r31, Y+63	; 0x3f
    5b5e:	65 97       	sbiw	r28, 0x15	; 21
    5b60:	f1 30       	cpi	r31, 0x01	; 1
    5b62:	39 f4       	brne	.+14     	; 0x5b72 <StrCalc+0x24e>
    5b64:	64 96       	adiw	r28, 0x14	; 20
    5b66:	2f ad       	ldd	r18, Y+63	; 0x3f
    5b68:	64 97       	sbiw	r28, 0x14	; 20
    5b6a:	21 30       	cpi	r18, 0x01	; 1
    5b6c:	09 f0       	breq	.+2      	; 0x5b70 <StrCalc+0x24c>
    5b6e:	9e c1       	rjmp	.+828    	; 0x5eac <StrCalc+0x588>
    5b70:	42 c0       	rjmp	.+132    	; 0x5bf6 <StrCalc+0x2d2>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    5b72:	64 96       	adiw	r28, 0x14	; 20
    5b74:	3f ad       	ldd	r19, Y+63	; 0x3f
    5b76:	64 97       	sbiw	r28, 0x14	; 20
    5b78:	31 30       	cpi	r19, 0x01	; 1
    5b7a:	09 f0       	breq	.+2      	; 0x5b7e <StrCalc+0x25a>
    5b7c:	8e c1       	rjmp	.+796    	; 0x5e9a <StrCalc+0x576>
    5b7e:	92 c1       	rjmp	.+804    	; 0x5ea4 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5b80:	65 96       	adiw	r28, 0x15	; 21
    5b82:	8f ad       	ldd	r24, Y+63	; 0x3f
    5b84:	65 97       	sbiw	r28, 0x15	; 21
    5b86:	81 30       	cpi	r24, 0x01	; 1
    5b88:	39 f4       	brne	.+14     	; 0x5b98 <StrCalc+0x274>
    5b8a:	64 96       	adiw	r28, 0x14	; 20
    5b8c:	9f ad       	ldd	r25, Y+63	; 0x3f
    5b8e:	64 97       	sbiw	r28, 0x14	; 20
    5b90:	91 30       	cpi	r25, 0x01	; 1
    5b92:	09 f0       	breq	.+2      	; 0x5b96 <StrCalc+0x272>
    5b94:	8b c1       	rjmp	.+790    	; 0x5eac <StrCalc+0x588>
    5b96:	81 c1       	rjmp	.+770    	; 0x5e9a <StrCalc+0x576>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    5b98:	64 96       	adiw	r28, 0x14	; 20
    5b9a:	af ad       	ldd	r26, Y+63	; 0x3f
    5b9c:	64 97       	sbiw	r28, 0x14	; 20
    5b9e:	a1 30       	cpi	r26, 0x01	; 1
    5ba0:	51 f5       	brne	.+84     	; 0x5bf6 <StrCalc+0x2d2>
    5ba2:	80 c1       	rjmp	.+768    	; 0x5ea4 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    5ba4:	b1 e0       	ldi	r27, 0x01	; 1
    5ba6:	6b 16       	cp	r6, r27
    5ba8:	31 f5       	brne	.+76     	; 0x5bf6 <StrCalc+0x2d2>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5baa:	81 30       	cpi	r24, 0x01	; 1
    5bac:	91 f4       	brne	.+36     	; 0x5bd2 <StrCalc+0x2ae>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5bae:	65 96       	adiw	r28, 0x15	; 21
    5bb0:	ef ad       	ldd	r30, Y+63	; 0x3f
    5bb2:	65 97       	sbiw	r28, 0x15	; 21
    5bb4:	e1 30       	cpi	r30, 0x01	; 1
    5bb6:	31 f4       	brne	.+12     	; 0x5bc4 <StrCalc+0x2a0>
    5bb8:	64 96       	adiw	r28, 0x14	; 20
    5bba:	ff ad       	ldd	r31, Y+63	; 0x3f
    5bbc:	64 97       	sbiw	r28, 0x14	; 20
    5bbe:	f1 30       	cpi	r31, 0x01	; 1
    5bc0:	d1 f4       	brne	.+52     	; 0x5bf6 <StrCalc+0x2d2>
    5bc2:	74 c1       	rjmp	.+744    	; 0x5eac <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5bc4:	64 96       	adiw	r28, 0x14	; 20
    5bc6:	2f ad       	ldd	r18, Y+63	; 0x3f
    5bc8:	64 97       	sbiw	r28, 0x14	; 20
    5bca:	21 30       	cpi	r18, 0x01	; 1
    5bcc:	09 f0       	breq	.+2      	; 0x5bd0 <StrCalc+0x2ac>
    5bce:	6a c1       	rjmp	.+724    	; 0x5ea4 <StrCalc+0x580>
    5bd0:	64 c1       	rjmp	.+712    	; 0x5e9a <StrCalc+0x576>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5bd2:	65 96       	adiw	r28, 0x15	; 21
    5bd4:	3f ad       	ldd	r19, Y+63	; 0x3f
    5bd6:	65 97       	sbiw	r28, 0x15	; 21
    5bd8:	31 30       	cpi	r19, 0x01	; 1
    5bda:	39 f4       	brne	.+14     	; 0x5bea <StrCalc+0x2c6>
    5bdc:	64 96       	adiw	r28, 0x14	; 20
    5bde:	8f ad       	ldd	r24, Y+63	; 0x3f
    5be0:	64 97       	sbiw	r28, 0x14	; 20
    5be2:	81 30       	cpi	r24, 0x01	; 1
    5be4:	09 f0       	breq	.+2      	; 0x5be8 <StrCalc+0x2c4>
    5be6:	59 c1       	rjmp	.+690    	; 0x5e9a <StrCalc+0x576>
    5be8:	61 c1       	rjmp	.+706    	; 0x5eac <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    5bea:	64 96       	adiw	r28, 0x14	; 20
    5bec:	9f ad       	ldd	r25, Y+63	; 0x3f
    5bee:	64 97       	sbiw	r28, 0x14	; 20
    5bf0:	91 30       	cpi	r25, 0x01	; 1
    5bf2:	09 f0       	breq	.+2      	; 0x5bf6 <StrCalc+0x2d2>
    5bf4:	57 c1       	rjmp	.+686    	; 0x5ea4 <StrCalc+0x580>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    5bf6:	62 96       	adiw	r28, 0x12	; 18
    5bf8:	1f ae       	std	Y+63, r1	; 0x3f
    5bfa:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    5bfc:	e7 2c       	mov	r14, r7
    5bfe:	ff 24       	eor	r15, r15
    5c00:	67 01       	movw	r12, r14
    5c02:	08 94       	sec
    5c04:	c1 08       	sbc	r12, r1
    5c06:	d1 08       	sbc	r13, r1
    5c08:	ae 01       	movw	r20, r28
    5c0a:	43 5c       	subi	r20, 0xC3	; 195
    5c0c:	5f 4f       	sbci	r21, 0xFF	; 255
    5c0e:	4c 0d       	add	r20, r12
    5c10:	5d 1d       	adc	r21, r13
    5c12:	ce 01       	movw	r24, r28
    5c14:	01 96       	adiw	r24, 0x01	; 1
    5c16:	8c 01       	movw	r16, r24
    5c18:	0c 0d       	add	r16, r12
    5c1a:	1d 1d       	adc	r17, r13
    5c1c:	be 01       	movw	r22, r28
    5c1e:	69 0d       	add	r22, r9
    5c20:	71 1d       	adc	r23, r1
    5c22:	6c 5e       	subi	r22, 0xEC	; 236
    5c24:	7f 4f       	sbci	r23, 0xFF	; 255
    5c26:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    5c28:	2c 01       	movw	r4, r24
    5c2a:	89 e3       	ldi	r24, 0x39	; 57
    5c2c:	88 2e       	mov	r8, r24
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5c2e:	9a e0       	ldi	r25, 0x0A	; 10
    5c30:	52 c0       	rjmp	.+164    	; 0x5cd6 <StrCalc+0x3b2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5c32:	d8 01       	movw	r26, r16
    5c34:	8c 91       	ld	r24, X
    5c36:	80 53       	subi	r24, 0x30	; 48
    5c38:	8a 30       	cpi	r24, 0x0A	; 10
    5c3a:	10 f0       	brcs	.+4      	; 0x5c40 <StrCalc+0x31c>
    5c3c:	20 e0       	ldi	r18, 0x00	; 0
    5c3e:	01 c0       	rjmp	.+2      	; 0x5c42 <StrCalc+0x31e>
    5c40:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    5c42:	fb 01       	movw	r30, r22
    5c44:	30 81       	ld	r19, Z
    5c46:	30 53       	subi	r19, 0x30	; 48
    5c48:	3a 30       	cpi	r19, 0x0A	; 10
    5c4a:	10 f4       	brcc	.+4      	; 0x5c50 <StrCalc+0x32c>
    5c4c:	23 17       	cp	r18, r19
    5c4e:	40 f0       	brcs	.+16     	; 0x5c60 <StrCalc+0x33c>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5c50:	8a 30       	cpi	r24, 0x0A	; 10
    5c52:	08 f0       	brcs	.+2      	; 0x5c56 <StrCalc+0x332>
    5c54:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5c56:	3a 30       	cpi	r19, 0x0A	; 10
    5c58:	08 f0       	brcs	.+2      	; 0x5c5c <StrCalc+0x338>
    5c5a:	30 e0       	ldi	r19, 0x00	; 0
    5c5c:	83 1b       	sub	r24, r19
    5c5e:	2d c0       	rjmp	.+90     	; 0x5cba <StrCalc+0x396>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5c60:	8a 30       	cpi	r24, 0x0A	; 10
    5c62:	10 f4       	brcc	.+4      	; 0x5c68 <StrCalc+0x344>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    5c64:	83 17       	cp	r24, r19
    5c66:	80 f5       	brcc	.+96     	; 0x5cc8 <StrCalc+0x3a4>
    5c68:	29 2d       	mov	r18, r9
    5c6a:	0a c0       	rjmp	.+20     	; 0x5c80 <StrCalc+0x35c>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    5c6c:	f6 01       	movw	r30, r12
    5c6e:	e2 1b       	sub	r30, r18
    5c70:	f1 09       	sbc	r31, r1
    5c72:	d2 01       	movw	r26, r4
    5c74:	ae 0f       	add	r26, r30
    5c76:	bf 1f       	adc	r27, r31
    5c78:	8c 91       	ld	r24, X
    5c7a:	80 33       	cpi	r24, 0x30	; 48
    5c7c:	29 f4       	brne	.+10     	; 0x5c88 <StrCalc+0x364>
    5c7e:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    5c80:	2f 5f       	subi	r18, 0xFF	; 255
    5c82:	27 15       	cp	r18, r7
    5c84:	98 f3       	brcs	.-26     	; 0x5c6c <StrCalc+0x348>
    5c86:	10 c0       	rjmp	.+32     	; 0x5ca8 <StrCalc+0x384>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5c88:	28 2f       	mov	r18, r24
    5c8a:	20 53       	subi	r18, 0x30	; 48
    5c8c:	2a 30       	cpi	r18, 0x0A	; 10
    5c8e:	08 f0       	brcs	.+2      	; 0x5c92 <StrCalc+0x36e>
    5c90:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5c92:	82 2f       	mov	r24, r18
    5c94:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5c96:	8a 30       	cpi	r24, 0x0A	; 10
    5c98:	10 f0       	brcs	.+4      	; 0x5c9e <StrCalc+0x37a>
    5c9a:	80 e3       	ldi	r24, 0x30	; 48
    5c9c:	02 c0       	rjmp	.+4      	; 0x5ca2 <StrCalc+0x37e>
	    Result='0'+X;
    5c9e:	82 2f       	mov	r24, r18
    5ca0:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5ca2:	e4 0d       	add	r30, r4
    5ca4:	f5 1d       	adc	r31, r5
    5ca6:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5ca8:	f8 01       	movw	r30, r16
    5caa:	20 81       	ld	r18, Z
    5cac:	20 53       	subi	r18, 0x30	; 48
    5cae:	2a 30       	cpi	r18, 0x0A	; 10
    5cb0:	08 f0       	brcs	.+2      	; 0x5cb4 <StrCalc+0x390>
    5cb2:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5cb4:	89 2f       	mov	r24, r25
    5cb6:	83 1b       	sub	r24, r19
    5cb8:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5cba:	8a 30       	cpi	r24, 0x0A	; 10
    5cbc:	10 f0       	brcs	.+4      	; 0x5cc2 <StrCalc+0x39e>
    5cbe:	80 e3       	ldi	r24, 0x30	; 48
    5cc0:	01 c0       	rjmp	.+2      	; 0x5cc4 <StrCalc+0x3a0>
	    Result='0'+X;
    5cc2:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5cc4:	da 01       	movw	r26, r20
    5cc6:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    5cc8:	93 94       	inc	r9
    5cca:	41 50       	subi	r20, 0x01	; 1
    5ccc:	50 40       	sbci	r21, 0x00	; 0
    5cce:	01 50       	subi	r16, 0x01	; 1
    5cd0:	10 40       	sbci	r17, 0x00	; 0
    5cd2:	61 50       	subi	r22, 0x01	; 1
    5cd4:	70 40       	sbci	r23, 0x00	; 0
    5cd6:	97 14       	cp	r9, r7
    5cd8:	08 f4       	brcc	.+2      	; 0x5cdc <StrCalc+0x3b8>
    5cda:	ab cf       	rjmp	.-170    	; 0x5c32 <StrCalc+0x30e>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    5cdc:	8e 01       	movw	r16, r28
    5cde:	03 5c       	subi	r16, 0xC3	; 195
    5ce0:	1f 4f       	sbci	r17, 0xFF	; 255
    5ce2:	e0 0e       	add	r14, r16
    5ce4:	f1 1e       	adc	r15, r17
    5ce6:	f7 01       	movw	r30, r14
    5ce8:	10 82       	st	Z, r1
       RemZeroLead(Result);
    5cea:	c8 01       	movw	r24, r16
    5cec:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    5cf0:	f8 01       	movw	r30, r16
    5cf2:	01 90       	ld	r0, Z+
    5cf4:	00 20       	and	r0, r0
    5cf6:	e9 f7       	brne	.-6      	; 0x5cf2 <StrCalc+0x3ce>
    5cf8:	31 97       	sbiw	r30, 0x01	; 1
    5cfa:	3e 2f       	mov	r19, r30
    5cfc:	30 1b       	sub	r19, r16
    5cfe:	d8 01       	movw	r26, r16
    5d00:	20 e0       	ldi	r18, 0x00	; 0
    5d02:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    5d04:	4d e2       	ldi	r20, 0x2D	; 45
    5d06:	13 c0       	rjmp	.+38     	; 0x5d2e <StrCalc+0x40a>
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    5d08:	22 23       	and	r18, r18
    5d0a:	51 f4       	brne	.+20     	; 0x5d20 <StrCalc+0x3fc>
    5d0c:	62 96       	adiw	r28, 0x12	; 18
    5d0e:	ff ad       	ldd	r31, Y+63	; 0x3f
    5d10:	62 97       	sbiw	r28, 0x12	; 18
    5d12:	f1 30       	cpi	r31, 0x01	; 1
    5d14:	29 f4       	brne	.+10     	; 0x5d20 <StrCalc+0x3fc>
			     strC[iPos]='-';
    5d16:	f5 01       	movw	r30, r10
    5d18:	e9 0f       	add	r30, r25
    5d1a:	f1 1d       	adc	r31, r1
    5d1c:	40 83       	st	Z, r20
				 iPos++;
    5d1e:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    5d20:	f5 01       	movw	r30, r10
    5d22:	e9 0f       	add	r30, r25
    5d24:	f1 1d       	adc	r31, r1
    5d26:	8d 91       	ld	r24, X+
    5d28:	80 83       	st	Z, r24
			 iPos++;
    5d2a:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5d2c:	2f 5f       	subi	r18, 0xFF	; 255
    5d2e:	23 17       	cp	r18, r19
    5d30:	58 f3       	brcs	.-42     	; 0x5d08 <StrCalc+0x3e4>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    5d32:	f5 01       	movw	r30, r10
    5d34:	e9 0f       	add	r30, r25
    5d36:	f1 1d       	adc	r31, r1
    5d38:	10 82       	st	Z, r1
    5d3a:	a0 c0       	rjmp	.+320    	; 0x5e7c <StrCalc+0x558>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    5d3c:	1d e3       	ldi	r17, 0x3D	; 61
    5d3e:	e1 2e       	mov	r14, r17
    5d40:	f1 2c       	mov	r15, r1
    5d42:	ec 0e       	add	r14, r28
    5d44:	fd 1e       	adc	r15, r29
    5d46:	ae 01       	movw	r20, r28
    5d48:	49 0d       	add	r20, r9
    5d4a:	51 1d       	adc	r21, r1
    5d4c:	4c 5e       	subi	r20, 0xEC	; 236
    5d4e:	5f 4f       	sbci	r21, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    5d50:	07 2d       	mov	r16, r7
    5d52:	10 e0       	ldi	r17, 0x00	; 0
    5d54:	48 01       	movw	r8, r16
    5d56:	08 94       	sec
    5d58:	81 08       	sbc	r8, r1
    5d5a:	91 08       	sbc	r9, r1
    5d5c:	ce 01       	movw	r24, r28
    5d5e:	01 96       	adiw	r24, 0x01	; 1
    5d60:	6c 01       	movw	r12, r24
    5d62:	c8 0c       	add	r12, r8
    5d64:	d9 1c       	adc	r13, r9
    5d66:	30 e0       	ldi	r19, 0x00	; 0
    5d68:	20 e0       	ldi	r18, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5d6a:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5d6c:	b0 e3       	ldi	r27, 0x30	; 48
    5d6e:	3b 2e       	mov	r3, r27
    5d70:	47 c0       	rjmp	.+142    	; 0x5e00 <StrCalc+0x4dc>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5d72:	d6 01       	movw	r26, r12
    5d74:	9c 91       	ld	r25, X
    5d76:	90 53       	subi	r25, 0x30	; 48
    5d78:	9a 30       	cpi	r25, 0x0A	; 10
    5d7a:	08 f0       	brcs	.+2      	; 0x5d7e <StrCalc+0x45a>
    5d7c:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    5d7e:	fa 01       	movw	r30, r20
    5d80:	80 81       	ld	r24, Z
    5d82:	80 53       	subi	r24, 0x30	; 48
    5d84:	8a 30       	cpi	r24, 0x0A	; 10
    5d86:	08 f0       	brcs	.+2      	; 0x5d8a <StrCalc+0x466>
    5d88:	80 e0       	ldi	r24, 0x00	; 0
    5d8a:	89 0f       	add	r24, r25
			 if (newC<10){
    5d8c:	8a 30       	cpi	r24, 0x0A	; 10
    5d8e:	18 f4       	brcc	.+6      	; 0x5d96 <StrCalc+0x472>
			     Result[i]=Chr(newC);
    5d90:	80 5d       	subi	r24, 0xD0	; 208
    5d92:	d7 01       	movw	r26, r14
    5d94:	28 c0       	rjmp	.+80     	; 0x5de6 <StrCalc+0x4c2>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5d96:	6a e0       	ldi	r22, 0x0A	; 10
    5d98:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5d9c:	9a 30       	cpi	r25, 0x0A	; 10
    5d9e:	10 f0       	brcs	.+4      	; 0x5da4 <StrCalc+0x480>
    5da0:	90 e3       	ldi	r25, 0x30	; 48
    5da2:	01 c0       	rjmp	.+2      	; 0x5da6 <StrCalc+0x482>
	    Result='0'+X;
    5da4:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5da6:	f7 01       	movw	r30, r14
    5da8:	90 83       	st	Z, r25
    5daa:	83 2f       	mov	r24, r19
    5dac:	0e c0       	rjmp	.+28     	; 0x5dca <StrCalc+0x4a6>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5dae:	d4 01       	movw	r26, r8
    5db0:	a8 1b       	sub	r26, r24
    5db2:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5db4:	f2 01       	movw	r30, r4
    5db6:	ea 0f       	add	r30, r26
    5db8:	fb 1f       	adc	r31, r27
    5dba:	90 81       	ld	r25, Z
    5dbc:	90 53       	subi	r25, 0x30	; 48
    5dbe:	9a 30       	cpi	r25, 0x0A	; 10
    5dc0:	08 f0       	brcs	.+2      	; 0x5dc4 <StrCalc+0x4a0>
    5dc2:	79 c0       	rjmp	.+242    	; 0x5eb6 <StrCalc+0x592>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5dc4:	99 30       	cpi	r25, 0x09	; 9
    5dc6:	29 f4       	brne	.+10     	; 0x5dd2 <StrCalc+0x4ae>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5dc8:	30 82       	st	Z, r3
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    5dca:	8f 5f       	subi	r24, 0xFF	; 255
    5dcc:	87 15       	cp	r24, r7
    5dce:	78 f3       	brcs	.-34     	; 0x5dae <StrCalc+0x48a>
    5dd0:	0d c0       	rjmp	.+26     	; 0x5dec <StrCalc+0x4c8>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5dd2:	89 2f       	mov	r24, r25
    5dd4:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5dd6:	8a 30       	cpi	r24, 0x0A	; 10
    5dd8:	10 f0       	brcs	.+4      	; 0x5dde <StrCalc+0x4ba>
    5dda:	80 e3       	ldi	r24, 0x30	; 48
    5ddc:	02 c0       	rjmp	.+4      	; 0x5de2 <StrCalc+0x4be>
	    Result='0'+X;
    5dde:	89 2f       	mov	r24, r25
    5de0:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5de2:	a4 0d       	add	r26, r4
    5de4:	b5 1d       	adc	r27, r5
    5de6:	8c 93       	st	X, r24
    5de8:	20 e0       	ldi	r18, 0x00	; 0
    5dea:	01 c0       	rjmp	.+2      	; 0x5dee <StrCalc+0x4ca>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    5dec:	21 e0       	ldi	r18, 0x01	; 1
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    5dee:	3f 5f       	subi	r19, 0xFF	; 255
    5df0:	08 94       	sec
    5df2:	e1 1c       	adc	r14, r1
    5df4:	f1 1c       	adc	r15, r1
    5df6:	41 50       	subi	r20, 0x01	; 1
    5df8:	50 40       	sbci	r21, 0x00	; 0
    5dfa:	08 94       	sec
    5dfc:	c1 08       	sbc	r12, r1
    5dfe:	d1 08       	sbc	r13, r1
    5e00:	37 15       	cp	r19, r7
    5e02:	08 f4       	brcc	.+2      	; 0x5e06 <StrCalc+0x4e2>
    5e04:	b6 cf       	rjmp	.-148    	; 0x5d72 <StrCalc+0x44e>
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    5e06:	20 5d       	subi	r18, 0xD0	; 208
				 }//EndFor j                
			   }//End else
			 }//EndFor

		  //Result[lenA]==Chr(zMin); ???
		  Result[lenA]=Chr(zMin);
    5e08:	de 01       	movw	r26, r28
    5e0a:	dd 96       	adiw	r26, 0x3d	; 61
    5e0c:	fd 01       	movw	r30, r26
    5e0e:	e0 0f       	add	r30, r16
    5e10:	f1 1f       	adc	r31, r17
    5e12:	20 83       	st	Z, r18
		  Result[lenA+1]=0;
    5e14:	0c 0f       	add	r16, r28
    5e16:	1d 1f       	adc	r17, r29
    5e18:	f8 01       	movw	r30, r16
    5e1a:	16 ae       	std	Z+62, r1	; 0x3e
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    5e1c:	fd 01       	movw	r30, r26
    5e1e:	01 90       	ld	r0, Z+
    5e20:	00 20       	and	r0, r0
    5e22:	e9 f7       	brne	.-6      	; 0x5e1e <StrCalc+0x4fa>
    5e24:	31 97       	sbiw	r30, 0x01	; 1
    5e26:	5e 2f       	mov	r21, r30
    5e28:	5a 1b       	sub	r21, r26
    5e2a:	25 2f       	mov	r18, r21
    5e2c:	30 e0       	ldi	r19, 0x00	; 0
    5e2e:	21 50       	subi	r18, 0x01	; 1
    5e30:	30 40       	sbci	r19, 0x00	; 0
    5e32:	2a 0f       	add	r18, r26
    5e34:	3b 1f       	adc	r19, r27
    5e36:	40 e0       	ldi	r20, 0x00	; 0
    5e38:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    5e3a:	6d e2       	ldi	r22, 0x2D	; 45
    5e3c:	16 c0       	rjmp	.+44     	; 0x5e6a <StrCalc+0x546>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    5e3e:	44 23       	and	r20, r20
    5e40:	51 f4       	brne	.+20     	; 0x5e56 <StrCalc+0x532>
    5e42:	63 96       	adiw	r28, 0x13	; 19
    5e44:	ff ad       	ldd	r31, Y+63	; 0x3f
    5e46:	63 97       	sbiw	r28, 0x13	; 19
    5e48:	f1 30       	cpi	r31, 0x01	; 1
    5e4a:	29 f4       	brne	.+10     	; 0x5e56 <StrCalc+0x532>
			     strC[iPos]='-';
    5e4c:	f5 01       	movw	r30, r10
    5e4e:	e9 0f       	add	r30, r25
    5e50:	f1 1d       	adc	r31, r1
    5e52:	60 83       	st	Z, r22
				 iPos++;
    5e54:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    5e56:	f5 01       	movw	r30, r10
    5e58:	e9 0f       	add	r30, r25
    5e5a:	f1 1d       	adc	r31, r1
    5e5c:	d9 01       	movw	r26, r18
    5e5e:	8c 91       	ld	r24, X
    5e60:	80 83       	st	Z, r24
			 iPos++;
    5e62:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5e64:	4f 5f       	subi	r20, 0xFF	; 255
    5e66:	21 50       	subi	r18, 0x01	; 1
    5e68:	30 40       	sbci	r19, 0x00	; 0
    5e6a:	45 17       	cp	r20, r21
    5e6c:	40 f3       	brcs	.-48     	; 0x5e3e <StrCalc+0x51a>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    5e6e:	f5 01       	movw	r30, r10
    5e70:	e9 0f       	add	r30, r25
    5e72:	f1 1d       	adc	r31, r1
    5e74:	10 82       	st	Z, r1

       RemZeroLead(strC);
    5e76:	c5 01       	movw	r24, r10
    5e78:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    5e7c:	b2 e0       	ldi	r27, 0x02	; 2
    5e7e:	6b 16       	cp	r6, r27
    5e80:	e1 f4       	brne	.+56     	; 0x5eba <StrCalc+0x596>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    5e82:	67 96       	adiw	r28, 0x17	; 23
    5e84:	8e ad       	ldd	r24, Y+62	; 0x3e
    5e86:	9f ad       	ldd	r25, Y+63	; 0x3f
    5e88:	67 97       	sbiw	r28, 0x17	; 23
    5e8a:	69 96       	adiw	r28, 0x19	; 25
    5e8c:	6e ad       	ldd	r22, Y+62	; 0x3e
    5e8e:	7f ad       	ldd	r23, Y+63	; 0x3f
    5e90:	69 97       	sbiw	r28, 0x19	; 25
    5e92:	a5 01       	movw	r20, r10
    5e94:	0e 94 76 2f 	call	0x5eec	; 0x5eec <CalcMultiply>
    5e98:	10 c0       	rjmp	.+32     	; 0x5eba <StrCalc+0x596>
	 }
}
    5e9a:	e1 e0       	ldi	r30, 0x01	; 1
    5e9c:	62 96       	adiw	r28, 0x12	; 18
    5e9e:	ef af       	std	Y+63, r30	; 0x3f
    5ea0:	62 97       	sbiw	r28, 0x12	; 18
    5ea2:	ac ce       	rjmp	.-680    	; 0x5bfc <StrCalc+0x2d8>
    5ea4:	63 96       	adiw	r28, 0x13	; 19
    5ea6:	1f ae       	std	Y+63, r1	; 0x3f
    5ea8:	63 97       	sbiw	r28, 0x13	; 19
    5eaa:	48 cf       	rjmp	.-368    	; 0x5d3c <StrCalc+0x418>
    5eac:	f1 e0       	ldi	r31, 0x01	; 1
    5eae:	63 96       	adiw	r28, 0x13	; 19
    5eb0:	ff af       	std	Y+63, r31	; 0x3f
    5eb2:	63 97       	sbiw	r28, 0x13	; 19
    5eb4:	43 cf       	rjmp	.-378    	; 0x5d3c <StrCalc+0x418>
    5eb6:	90 e0       	ldi	r25, 0x00	; 0
    5eb8:	8c cf       	rjmp	.-232    	; 0x5dd2 <StrCalc+0x4ae>
    5eba:	c8 5a       	subi	r28, 0xA8	; 168
    5ebc:	df 4f       	sbci	r29, 0xFF	; 255
    5ebe:	0f b6       	in	r0, 0x3f	; 63
    5ec0:	f8 94       	cli
    5ec2:	de bf       	out	0x3e, r29	; 62
    5ec4:	0f be       	out	0x3f, r0	; 63
    5ec6:	cd bf       	out	0x3d, r28	; 61
    5ec8:	cf 91       	pop	r28
    5eca:	df 91       	pop	r29
    5ecc:	1f 91       	pop	r17
    5ece:	0f 91       	pop	r16
    5ed0:	ff 90       	pop	r15
    5ed2:	ef 90       	pop	r14
    5ed4:	df 90       	pop	r13
    5ed6:	cf 90       	pop	r12
    5ed8:	bf 90       	pop	r11
    5eda:	af 90       	pop	r10
    5edc:	9f 90       	pop	r9
    5ede:	8f 90       	pop	r8
    5ee0:	7f 90       	pop	r7
    5ee2:	6f 90       	pop	r6
    5ee4:	5f 90       	pop	r5
    5ee6:	4f 90       	pop	r4
    5ee8:	3f 90       	pop	r3
    5eea:	08 95       	ret

00005eec <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    5eec:	4f 92       	push	r4
    5eee:	5f 92       	push	r5
    5ef0:	6f 92       	push	r6
    5ef2:	7f 92       	push	r7
    5ef4:	8f 92       	push	r8
    5ef6:	9f 92       	push	r9
    5ef8:	af 92       	push	r10
    5efa:	bf 92       	push	r11
    5efc:	cf 92       	push	r12
    5efe:	df 92       	push	r13
    5f00:	ef 92       	push	r14
    5f02:	ff 92       	push	r15
    5f04:	0f 93       	push	r16
    5f06:	1f 93       	push	r17
    5f08:	df 93       	push	r29
    5f0a:	cf 93       	push	r28
    5f0c:	cd b7       	in	r28, 0x3d	; 61
    5f0e:	de b7       	in	r29, 0x3e	; 62
    5f10:	a8 97       	sbiw	r28, 0x28	; 40
    5f12:	0f b6       	in	r0, 0x3f	; 63
    5f14:	f8 94       	cli
    5f16:	de bf       	out	0x3e, r29	; 62
    5f18:	0f be       	out	0x3f, r0	; 63
    5f1a:	cd bf       	out	0x3d, r28	; 61
    5f1c:	3c 01       	movw	r6, r24
    5f1e:	6b 01       	movw	r12, r22
    5f20:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    5f22:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
     RemZeroLead(strB);
    5f26:	c6 01       	movw	r24, r12
    5f28:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
	 lenB=strlen(strB);
    5f2c:	d6 01       	movw	r26, r12
    5f2e:	0d 90       	ld	r0, X+
    5f30:	00 20       	and	r0, r0
    5f32:	e9 f7       	brne	.-6      	; 0x5f2e <CalcMultiply+0x42>
    5f34:	11 97       	sbiw	r26, 0x01	; 1
    5f36:	8a 2e       	mov	r8, r26
    5f38:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    5f3a:	00 d0       	rcall	.+0      	; 0x5f3c <CalcMultiply+0x50>
    5f3c:	00 d0       	rcall	.+0      	; 0x5f3e <CalcMultiply+0x52>
    5f3e:	8e 01       	movw	r16, r28
    5f40:	0f 5f       	subi	r16, 0xFF	; 255
    5f42:	1f 4f       	sbci	r17, 0xFF	; 255
    5f44:	ad b7       	in	r26, 0x3d	; 61
    5f46:	be b7       	in	r27, 0x3e	; 62
    5f48:	12 96       	adiw	r26, 0x02	; 2
    5f4a:	1c 93       	st	X, r17
    5f4c:	0e 93       	st	-X, r16
    5f4e:	11 97       	sbiw	r26, 0x01	; 1
    5f50:	8d e0       	ldi	r24, 0x0D	; 13
    5f52:	97 e0       	ldi	r25, 0x07	; 7
    5f54:	14 96       	adiw	r26, 0x04	; 4
    5f56:	9c 93       	st	X, r25
    5f58:	8e 93       	st	-X, r24
    5f5a:	13 97       	sbiw	r26, 0x03	; 3
    5f5c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    5f60:	25 e1       	ldi	r18, 0x15	; 21
    5f62:	e2 2e       	mov	r14, r18
    5f64:	f1 2c       	mov	r15, r1
    5f66:	ec 0e       	add	r14, r28
    5f68:	fd 1e       	adc	r15, r29
    5f6a:	ed b7       	in	r30, 0x3d	; 61
    5f6c:	fe b7       	in	r31, 0x3e	; 62
    5f6e:	f2 82       	std	Z+2, r15	; 0x02
    5f70:	e1 82       	std	Z+1, r14	; 0x01
    5f72:	8b e0       	ldi	r24, 0x0B	; 11
    5f74:	97 e0       	ldi	r25, 0x07	; 7
    5f76:	94 83       	std	Z+4, r25	; 0x04
    5f78:	83 83       	std	Z+3, r24	; 0x03
    5f7a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    5f7e:	bb 24       	eor	r11, r11
    5f80:	0f 90       	pop	r0
    5f82:	0f 90       	pop	r0
    5f84:	0f 90       	pop	r0
    5f86:	0f 90       	pop	r0
    5f88:	a0 2e       	mov	r10, r16
    5f8a:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    5f8c:	08 2d       	mov	r16, r8
    5f8e:	10 e0       	ldi	r17, 0x00	; 0
    5f90:	01 50       	subi	r16, 0x01	; 1
    5f92:	10 40       	sbci	r17, 0x00	; 0
    5f94:	1f c0       	rjmp	.+62     	; 0x5fd4 <CalcMultiply+0xe8>
    5f96:	f8 01       	movw	r30, r16
    5f98:	e8 1b       	sub	r30, r24
    5f9a:	f9 0b       	sbc	r31, r25
    5f9c:	ec 0d       	add	r30, r12
    5f9e:	fd 1d       	adc	r31, r13
    5fa0:	c3 01       	movw	r24, r6
    5fa2:	60 81       	ld	r22, Z
    5fa4:	a7 01       	movw	r20, r14
    5fa6:	0e 94 dd 25 	call	0x4bba	; 0x4bba <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    5faa:	f7 01       	movw	r30, r14
    5fac:	01 90       	ld	r0, Z+
    5fae:	00 20       	and	r0, r0
    5fb0:	e9 f7       	brne	.-6      	; 0x5fac <CalcMultiply+0xc0>
    5fb2:	31 97       	sbiw	r30, 0x01	; 1
    5fb4:	ee 19       	sub	r30, r14
    5fb6:	ff 09       	sbc	r31, r15
    5fb8:	6b 2d       	mov	r22, r11
    5fba:	6e 0f       	add	r22, r30
    5fbc:	c7 01       	movw	r24, r14
    5fbe:	0e 94 77 2c 	call	0x58ee	; 0x58ee <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    5fc2:	81 e0       	ldi	r24, 0x01	; 1
    5fc4:	6a 2d       	mov	r22, r10
    5fc6:	79 2d       	mov	r23, r9
    5fc8:	a7 01       	movw	r20, r14
    5fca:	2a 2d       	mov	r18, r10
    5fcc:	39 2d       	mov	r19, r9
    5fce:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    5fd2:	b3 94       	inc	r11
    5fd4:	f6 01       	movw	r30, r12
    5fd6:	01 90       	ld	r0, Z+
    5fd8:	00 20       	and	r0, r0
    5fda:	e9 f7       	brne	.-6      	; 0x5fd6 <CalcMultiply+0xea>
    5fdc:	31 97       	sbiw	r30, 0x01	; 1
    5fde:	ec 19       	sub	r30, r12
    5fe0:	fd 09       	sbc	r31, r13
    5fe2:	8b 2d       	mov	r24, r11
    5fe4:	90 e0       	ldi	r25, 0x00	; 0
    5fe6:	8e 17       	cp	r24, r30
    5fe8:	9f 07       	cpc	r25, r31
    5fea:	a8 f2       	brcs	.-86     	; 0x5f96 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    5fec:	00 d0       	rcall	.+0      	; 0x5fee <CalcMultiply+0x102>
    5fee:	00 d0       	rcall	.+0      	; 0x5ff0 <CalcMultiply+0x104>
    5ff0:	00 d0       	rcall	.+0      	; 0x5ff2 <CalcMultiply+0x106>
    5ff2:	ed b7       	in	r30, 0x3d	; 61
    5ff4:	fe b7       	in	r31, 0x3e	; 62
    5ff6:	31 96       	adiw	r30, 0x01	; 1
    5ff8:	ad b7       	in	r26, 0x3d	; 61
    5ffa:	be b7       	in	r27, 0x3e	; 62
    5ffc:	12 96       	adiw	r26, 0x02	; 2
    5ffe:	5c 92       	st	X, r5
    6000:	4e 92       	st	-X, r4
    6002:	11 97       	sbiw	r26, 0x01	; 1
    6004:	88 e0       	ldi	r24, 0x08	; 8
    6006:	97 e0       	ldi	r25, 0x07	; 7
    6008:	93 83       	std	Z+3, r25	; 0x03
    600a:	82 83       	std	Z+2, r24	; 0x02
    600c:	a4 82       	std	Z+4, r10	; 0x04
    600e:	95 82       	std	Z+5, r9	; 0x05
    6010:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    6014:	ed b7       	in	r30, 0x3d	; 61
    6016:	fe b7       	in	r31, 0x3e	; 62
    6018:	36 96       	adiw	r30, 0x06	; 6
    601a:	0f b6       	in	r0, 0x3f	; 63
    601c:	f8 94       	cli
    601e:	fe bf       	out	0x3e, r31	; 62
    6020:	0f be       	out	0x3f, r0	; 63
    6022:	ed bf       	out	0x3d, r30	; 61
}
    6024:	a8 96       	adiw	r28, 0x28	; 40
    6026:	0f b6       	in	r0, 0x3f	; 63
    6028:	f8 94       	cli
    602a:	de bf       	out	0x3e, r29	; 62
    602c:	0f be       	out	0x3f, r0	; 63
    602e:	cd bf       	out	0x3d, r28	; 61
    6030:	cf 91       	pop	r28
    6032:	df 91       	pop	r29
    6034:	1f 91       	pop	r17
    6036:	0f 91       	pop	r16
    6038:	ff 90       	pop	r15
    603a:	ef 90       	pop	r14
    603c:	df 90       	pop	r13
    603e:	cf 90       	pop	r12
    6040:	bf 90       	pop	r11
    6042:	af 90       	pop	r10
    6044:	9f 90       	pop	r9
    6046:	8f 90       	pop	r8
    6048:	7f 90       	pop	r7
    604a:	6f 90       	pop	r6
    604c:	5f 90       	pop	r5
    604e:	4f 90       	pop	r4
    6050:	08 95       	ret

00006052 <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    6052:	cf 92       	push	r12
    6054:	df 92       	push	r13
    6056:	ef 92       	push	r14
    6058:	ff 92       	push	r15
    605a:	0f 93       	push	r16
    605c:	1f 93       	push	r17
    605e:	df 93       	push	r29
    6060:	cf 93       	push	r28
    6062:	cd b7       	in	r28, 0x3d	; 61
    6064:	de b7       	in	r29, 0x3e	; 62
    6066:	64 97       	sbiw	r28, 0x14	; 20
    6068:	0f b6       	in	r0, 0x3f	; 63
    606a:	f8 94       	cli
    606c:	de bf       	out	0x3e, r29	; 62
    606e:	0f be       	out	0x3f, r0	; 63
    6070:	cd bf       	out	0x3d, r28	; 61
    6072:	d8 2e       	mov	r13, r24
    6074:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    6076:	a8 2f       	mov	r26, r24
    6078:	b9 2f       	mov	r27, r25
    607a:	fd 01       	movw	r30, r26
    607c:	01 90       	ld	r0, Z+
    607e:	00 20       	and	r0, r0
    6080:	e9 f7       	brne	.-6      	; 0x607c <NormalizeOverflow+0x2a>
    6082:	31 97       	sbiw	r30, 0x01	; 1
    6084:	4e 2f       	mov	r20, r30
    6086:	48 1b       	sub	r20, r24
    6088:	20 e0       	ldi	r18, 0x00	; 0
    608a:	30 e0       	ldi	r19, 0x00	; 0
    608c:	7e 01       	movw	r14, r28
    608e:	08 94       	sec
    6090:	e1 1c       	adc	r14, r1
    6092:	f1 1c       	adc	r15, r1
    6094:	04 2f       	mov	r16, r20
    6096:	10 e0       	ldi	r17, 0x00	; 0
    6098:	0e c0       	rjmp	.+28     	; 0x60b6 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    609a:	f7 01       	movw	r30, r14
    609c:	e2 0f       	add	r30, r18
    609e:	f3 1f       	adc	r31, r19
    60a0:	c8 01       	movw	r24, r16
    60a2:	82 1b       	sub	r24, r18
    60a4:	93 0b       	sbc	r25, r19
    60a6:	64 2f       	mov	r22, r20
    60a8:	70 e0       	ldi	r23, 0x00	; 0
    60aa:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    60ae:	60 5d       	subi	r22, 0xD0	; 208
    60b0:	60 83       	st	Z, r22
    60b2:	2f 5f       	subi	r18, 0xFF	; 255
    60b4:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    60b6:	24 17       	cp	r18, r20
    60b8:	80 f3       	brcs	.-32     	; 0x609a <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    60ba:	0e 0d       	add	r16, r14
    60bc:	1f 1d       	adc	r17, r15
    60be:	f8 01       	movw	r30, r16
    60c0:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    60c2:	81 e0       	ldi	r24, 0x01	; 1
    60c4:	b7 01       	movw	r22, r14
    60c6:	4d 2d       	mov	r20, r13
    60c8:	5c 2d       	mov	r21, r12
    60ca:	2d 2d       	mov	r18, r13
    60cc:	3c 2d       	mov	r19, r12
    60ce:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>
}
    60d2:	64 96       	adiw	r28, 0x14	; 20
    60d4:	0f b6       	in	r0, 0x3f	; 63
    60d6:	f8 94       	cli
    60d8:	de bf       	out	0x3e, r29	; 62
    60da:	0f be       	out	0x3f, r0	; 63
    60dc:	cd bf       	out	0x3d, r28	; 61
    60de:	cf 91       	pop	r28
    60e0:	df 91       	pop	r29
    60e2:	1f 91       	pop	r17
    60e4:	0f 91       	pop	r16
    60e6:	ff 90       	pop	r15
    60e8:	ef 90       	pop	r14
    60ea:	df 90       	pop	r13
    60ec:	cf 90       	pop	r12
    60ee:	08 95       	ret

000060f0 <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    60f0:	bf 92       	push	r11
    60f2:	cf 92       	push	r12
    60f4:	df 92       	push	r13
    60f6:	ef 92       	push	r14
    60f8:	ff 92       	push	r15
    60fa:	0f 93       	push	r16
    60fc:	1f 93       	push	r17
    60fe:	df 93       	push	r29
    6100:	cf 93       	push	r28
    6102:	cd b7       	in	r28, 0x3d	; 61
    6104:	de b7       	in	r29, 0x3e	; 62
    6106:	e2 97       	sbiw	r28, 0x32	; 50
    6108:	0f b6       	in	r0, 0x3f	; 63
    610a:	f8 94       	cli
    610c:	de bf       	out	0x3e, r29	; 62
    610e:	0f be       	out	0x3f, r0	; 63
    6110:	cd bf       	out	0x3d, r28	; 61
    6112:	8c 01       	movw	r16, r24
     char i,Length,strAdded[50];
     Length=strlen(String);
    6114:	fc 01       	movw	r30, r24
    6116:	01 90       	ld	r0, Z+
    6118:	00 20       	and	r0, r0
    611a:	e9 f7       	brne	.-6      	; 0x6116 <AddSpaceLead+0x26>
    611c:	31 97       	sbiw	r30, 0x01	; 1
    611e:	2e 2f       	mov	r18, r30
    6120:	28 1b       	sub	r18, r24

	 if (Size>Length){
    6122:	26 17       	cp	r18, r22
    6124:	e0 f5       	brcc	.+120    	; 0x619e <AddSpaceLead+0xae>
    6126:	7e 01       	movw	r14, r28
    6128:	08 94       	sec
    612a:	e1 1c       	adc	r14, r1
    612c:	f1 1c       	adc	r15, r1
    612e:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    6130:	be 2c       	mov	r11, r14
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    6132:	90 e2       	ldi	r25, 0x20	; 32
    6134:	01 c0       	rjmp	.+2      	; 0x6138 <AddSpaceLead+0x48>
    6136:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    6138:	8e 2f       	mov	r24, r30
    613a:	8b 19       	sub	r24, r11
    613c:	86 17       	cp	r24, r22
    613e:	d8 f3       	brcs	.-10     	; 0x6136 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    6140:	46 2f       	mov	r20, r22
    6142:	50 e0       	ldi	r21, 0x00	; 0
    6144:	ce 01       	movw	r24, r28
    6146:	01 96       	adiw	r24, 0x01	; 1
    6148:	fc 01       	movw	r30, r24
    614a:	e4 0f       	add	r30, r20
    614c:	f5 1f       	adc	r31, r21
    614e:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    6150:	76 2f       	mov	r23, r22
    6152:	72 1b       	sub	r23, r18
    6154:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    6156:	30 e0       	ldi	r19, 0x00	; 0
    6158:	24 1b       	sub	r18, r20
    615a:	35 0b       	sbc	r19, r21
    615c:	0c c0       	rjmp	.+24     	; 0x6176 <AddSpaceLead+0x86>
    615e:	e7 2f       	mov	r30, r23
    6160:	f0 e0       	ldi	r31, 0x00	; 0
    6162:	d6 01       	movw	r26, r12
    6164:	ae 0f       	add	r26, r30
    6166:	bf 1f       	adc	r27, r31
    6168:	e0 0f       	add	r30, r16
    616a:	f1 1f       	adc	r31, r17
    616c:	e2 0f       	add	r30, r18
    616e:	f3 1f       	adc	r31, r19
    6170:	80 81       	ld	r24, Z
    6172:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    6174:	7f 5f       	subi	r23, 0xFF	; 255
    6176:	76 17       	cp	r23, r22
    6178:	90 f3       	brcs	.-28     	; 0x615e <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    617a:	4c 0d       	add	r20, r12
    617c:	5d 1d       	adc	r21, r13
    617e:	da 01       	movw	r26, r20
    6180:	1c 92       	st	X, r1
    6182:	f8 01       	movw	r30, r16
    6184:	04 c0       	rjmp	.+8      	; 0x618e <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    6186:	d7 01       	movw	r26, r14
    6188:	8d 91       	ld	r24, X+
    618a:	7d 01       	movw	r14, r26
    618c:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    618e:	8e 2d       	mov	r24, r14
    6190:	8b 19       	sub	r24, r11
    6192:	86 17       	cp	r24, r22
    6194:	c0 f3       	brcs	.-16     	; 0x6186 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    6196:	06 0f       	add	r16, r22
    6198:	11 1d       	adc	r17, r1
    619a:	f8 01       	movw	r30, r16
    619c:	10 82       	st	Z, r1
	 }
}
    619e:	e2 96       	adiw	r28, 0x32	; 50
    61a0:	0f b6       	in	r0, 0x3f	; 63
    61a2:	f8 94       	cli
    61a4:	de bf       	out	0x3e, r29	; 62
    61a6:	0f be       	out	0x3f, r0	; 63
    61a8:	cd bf       	out	0x3d, r28	; 61
    61aa:	cf 91       	pop	r28
    61ac:	df 91       	pop	r29
    61ae:	1f 91       	pop	r17
    61b0:	0f 91       	pop	r16
    61b2:	ff 90       	pop	r15
    61b4:	ef 90       	pop	r14
    61b6:	df 90       	pop	r13
    61b8:	cf 90       	pop	r12
    61ba:	bf 90       	pop	r11
    61bc:	08 95       	ret

000061be <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    61be:	cf 93       	push	r28
    61c0:	df 93       	push	r29
    61c2:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    61c4:	dc 01       	movw	r26, r24
    61c6:	0d 90       	ld	r0, X+
    61c8:	00 20       	and	r0, r0
    61ca:	e9 f7       	brne	.-6      	; 0x61c6 <AddSpaceLag+0x8>
    61cc:	11 97       	sbiw	r26, 0x01	; 1
    61ce:	a8 1b       	sub	r26, r24
    61d0:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    61d2:	a6 17       	cp	r26, r22
    61d4:	60 f4       	brcc	.+24     	; 0x61ee <AddSpaceLag+0x30>
    61d6:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    61d8:	90 e2       	ldi	r25, 0x20	; 32
    61da:	fe 01       	movw	r30, r28
    61dc:	e8 0f       	add	r30, r24
    61de:	f1 1d       	adc	r31, r1
    61e0:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    61e2:	8f 5f       	subi	r24, 0xFF	; 255
    61e4:	86 17       	cp	r24, r22
    61e6:	c8 f3       	brcs	.-14     	; 0x61da <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    61e8:	c6 0f       	add	r28, r22
    61ea:	d1 1d       	adc	r29, r1
    61ec:	18 82       	st	Y, r1
  }
}
    61ee:	df 91       	pop	r29
    61f0:	cf 91       	pop	r28
    61f2:	08 95       	ret

000061f4 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    61f4:	0f 93       	push	r16
    61f6:	1f 93       	push	r17
    61f8:	df 93       	push	r29
    61fa:	cf 93       	push	r28
    61fc:	cd b7       	in	r28, 0x3d	; 61
    61fe:	de b7       	in	r29, 0x3e	; 62
    6200:	2c 97       	sbiw	r28, 0x0c	; 12
    6202:	0f b6       	in	r0, 0x3f	; 63
    6204:	f8 94       	cli
    6206:	de bf       	out	0x3e, r29	; 62
    6208:	0f be       	out	0x3f, r0	; 63
    620a:	cd bf       	out	0x3d, r28	; 61
    620c:	48 2f       	mov	r20, r24
    620e:	8b 01       	movw	r16, r22
    6210:	fe 01       	movw	r30, r28
    6212:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6214:	9e 01       	movw	r18, r28
    6216:	23 5f       	subi	r18, 0xF3	; 243
    6218:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    621a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    621c:	e2 17       	cp	r30, r18
    621e:	f3 07       	cpc	r31, r19
    6220:	e1 f7       	brne	.-8      	; 0x621a <GetProductName+0x26>
    6222:	ce 01       	movw	r24, r28
    6224:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    6226:	44 23       	and	r20, r20
    6228:	69 f0       	breq	.+26     	; 0x6244 <GetProductName+0x50>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    622a:	6d e0       	ldi	r22, 0x0D	; 13
    622c:	46 9f       	mul	r20, r22
    622e:	b0 01       	movw	r22, r0
    6230:	11 24       	eor	r1, r1
    6232:	62 55       	subi	r22, 0x52	; 82
    6234:	7f 4f       	sbci	r23, 0xFF	; 255
    6236:	4a e0       	ldi	r20, 0x0A	; 10
    6238:	50 e0       	ldi	r21, 0x00	; 0
    623a:	22 ed       	ldi	r18, 0xD2	; 210
    623c:	33 e1       	ldi	r19, 0x13	; 19
    623e:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    6242:	14 c0       	rjmp	.+40     	; 0x626c <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    6244:	00 d0       	rcall	.+0      	; 0x6246 <GetProductName+0x52>
    6246:	00 d0       	rcall	.+0      	; 0x6248 <GetProductName+0x54>
    6248:	ad b7       	in	r26, 0x3d	; 61
    624a:	be b7       	in	r27, 0x3e	; 62
    624c:	12 96       	adiw	r26, 0x02	; 2
    624e:	9c 93       	st	X, r25
    6250:	8e 93       	st	-X, r24
    6252:	11 97       	sbiw	r26, 0x01	; 1
    6254:	8f e5       	ldi	r24, 0x5F	; 95
    6256:	95 e0       	ldi	r25, 0x05	; 5
    6258:	14 96       	adiw	r26, 0x04	; 4
    625a:	9c 93       	st	X, r25
    625c:	8e 93       	st	-X, r24
    625e:	13 97       	sbiw	r26, 0x03	; 3
    6260:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    6264:	0f 90       	pop	r0
    6266:	0f 90       	pop	r0
    6268:	0f 90       	pop	r0
    626a:	0f 90       	pop	r0

     Length=strlen(SProductName);
    626c:	de 01       	movw	r26, r28
    626e:	11 96       	adiw	r26, 0x01	; 1
    6270:	fd 01       	movw	r30, r26
    6272:	01 90       	ld	r0, Z+
    6274:	00 20       	and	r0, r0
    6276:	e9 f7       	brne	.-6      	; 0x6272 <GetProductName+0x7e>
    6278:	31 97       	sbiw	r30, 0x01	; 1
    627a:	ea 1b       	sub	r30, r26
    627c:	eb 30       	cpi	r30, 0x0B	; 11
    627e:	08 f0       	brcs	.+2      	; 0x6282 <GetProductName+0x8e>
    6280:	ea e0       	ldi	r30, 0x0A	; 10
    6282:	ae 01       	movw	r20, r28
    6284:	4f 5f       	subi	r20, 0xFF	; 255
    6286:	5f 4f       	sbci	r21, 0xFF	; 255
    6288:	98 01       	movw	r18, r16
    628a:	ba 01       	movw	r22, r20
    628c:	06 c0       	rjmp	.+12     	; 0x629a <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    628e:	db 01       	movw	r26, r22
    6290:	8d 91       	ld	r24, X+
    6292:	bd 01       	movw	r22, r26
    6294:	d9 01       	movw	r26, r18
    6296:	8d 93       	st	X+, r24
    6298:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    629a:	86 2f       	mov	r24, r22
    629c:	84 1b       	sub	r24, r20
    629e:	8e 17       	cp	r24, r30
    62a0:	b0 f3       	brcs	.-20     	; 0x628e <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    62a2:	c8 01       	movw	r24, r16
    62a4:	8e 0f       	add	r24, r30
    62a6:	91 1d       	adc	r25, r1
    62a8:	fc 01       	movw	r30, r24
    62aa:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    62ac:	c8 01       	movw	r24, r16
    62ae:	6a e0       	ldi	r22, 0x0A	; 10
    62b0:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
}
    62b4:	2c 96       	adiw	r28, 0x0c	; 12
    62b6:	0f b6       	in	r0, 0x3f	; 63
    62b8:	f8 94       	cli
    62ba:	de bf       	out	0x3e, r29	; 62
    62bc:	0f be       	out	0x3f, r0	; 63
    62be:	cd bf       	out	0x3d, r28	; 61
    62c0:	cf 91       	pop	r28
    62c2:	df 91       	pop	r29
    62c4:	1f 91       	pop	r17
    62c6:	0f 91       	pop	r16
    62c8:	08 95       	ret

000062ca <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    62ca:	2f 92       	push	r2
    62cc:	3f 92       	push	r3
    62ce:	4f 92       	push	r4
    62d0:	5f 92       	push	r5
    62d2:	6f 92       	push	r6
    62d4:	7f 92       	push	r7
    62d6:	8f 92       	push	r8
    62d8:	9f 92       	push	r9
    62da:	af 92       	push	r10
    62dc:	bf 92       	push	r11
    62de:	cf 92       	push	r12
    62e0:	df 92       	push	r13
    62e2:	ef 92       	push	r14
    62e4:	ff 92       	push	r15
    62e6:	0f 93       	push	r16
    62e8:	1f 93       	push	r17
    62ea:	df 93       	push	r29
    62ec:	cf 93       	push	r28
    62ee:	cd b7       	in	r28, 0x3d	; 61
    62f0:	de b7       	in	r29, 0x3e	; 62
    62f2:	c0 5b       	subi	r28, 0xB0	; 176
    62f4:	d0 40       	sbci	r29, 0x00	; 0
    62f6:	0f b6       	in	r0, 0x3f	; 63
    62f8:	f8 94       	cli
    62fa:	de bf       	out	0x3e, r29	; 62
    62fc:	0f be       	out	0x3f, r0	; 63
    62fe:	cd bf       	out	0x3d, r28	; 61
    6300:	e8 2e       	mov	r14, r24
    6302:	fe 01       	movw	r30, r28
    6304:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6306:	ce 01       	movw	r24, r28
    6308:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    630a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    630c:	e8 17       	cp	r30, r24
    630e:	f9 07       	cpc	r31, r25
    6310:	e1 f7       	brne	.-8      	; 0x630a <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    6312:	ce 01       	movw	r24, r28
    6314:	85 96       	adiw	r24, 0x25	; 37
    6316:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6318:	e8 17       	cp	r30, r24
    631a:	f9 07       	cpc	r31, r25
    631c:	e1 f7       	brne	.-8      	; 0x6316 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    631e:	ce 01       	movw	r24, r28
    6320:	c4 96       	adiw	r24, 0x34	; 52
    6322:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6324:	e8 17       	cp	r30, r24
    6326:	f9 07       	cpc	r31, r25
    6328:	e1 f7       	brne	.-8      	; 0x6322 <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    632a:	cf 01       	movw	r24, r30
    632c:	3f 01       	movw	r6, r30
    632e:	0f 96       	adiw	r24, 0x0f	; 15
    6330:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6332:	e8 17       	cp	r30, r24
    6334:	f9 07       	cpc	r31, r25
    6336:	e1 f7       	brne	.-8      	; 0x6330 <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    6338:	8e 2d       	mov	r24, r14
    633a:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
    633e:	96 e0       	ldi	r25, 0x06	; 6
    6340:	89 9f       	mul	r24, r25
    6342:	b0 01       	movw	r22, r0
    6344:	11 24       	eor	r1, r1
    6346:	61 5b       	subi	r22, 0xB1	; 177
    6348:	7f 4f       	sbci	r23, 0xFF	; 255
    634a:	8e 01       	movw	r16, r28
    634c:	0f 5f       	subi	r16, 0xFF	; 255
    634e:	1f 4f       	sbci	r17, 0xFF	; 255
    6350:	c8 01       	movw	r24, r16
    6352:	46 e0       	ldi	r20, 0x06	; 6
    6354:	50 e0       	ldi	r21, 0x00	; 0
    6356:	22 ed       	ldi	r18, 0xD2	; 210
    6358:	33 e1       	ldi	r19, 0x13	; 19
    635a:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    635e:	2e 2c       	mov	r2, r14
    6360:	33 24       	eor	r3, r3
    6362:	91 01       	movw	r18, r2
    6364:	2f 70       	andi	r18, 0x0F	; 15
    6366:	30 70       	andi	r19, 0x00	; 0
    6368:	85 e3       	ldi	r24, 0x35	; 53
    636a:	90 e0       	ldi	r25, 0x00	; 0
    636c:	28 9f       	mul	r18, r24
    636e:	f0 01       	movw	r30, r0
    6370:	29 9f       	mul	r18, r25
    6372:	f0 0d       	add	r31, r0
    6374:	38 9f       	mul	r19, r24
    6376:	f0 0d       	add	r31, r0
    6378:	11 24       	eor	r1, r1
    637a:	e8 55       	subi	r30, 0x58	; 88
    637c:	fa 4f       	sbci	r31, 0xFA	; 250
    637e:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    6380:	4f 2c       	mov	r4, r15
    6382:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    6384:	04 0d       	add	r16, r4
    6386:	15 1d       	adc	r17, r5
    6388:	d8 01       	movw	r26, r16
    638a:	8c 91       	ld	r24, X
    638c:	6e e5       	ldi	r22, 0x5E	; 94
    638e:	77 e0       	ldi	r23, 0x07	; 7
    6390:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    6394:	67 e0       	ldi	r22, 0x07	; 7
    6396:	86 2e       	mov	r8, r22
    6398:	91 2c       	mov	r9, r1
    639a:	8c 0e       	add	r8, r28
    639c:	9d 1e       	adc	r9, r29
    639e:	8e 2d       	mov	r24, r14
    63a0:	b4 01       	movw	r22, r8
    63a2:	0e 94 b1 2a 	call	0x5562	; 0x5562 <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    63a6:	56 e1       	ldi	r21, 0x16	; 22
    63a8:	a5 2e       	mov	r10, r21
    63aa:	b1 2c       	mov	r11, r1
    63ac:	ac 0e       	add	r10, r28
    63ae:	bd 1e       	adc	r11, r29
    63b0:	8e 2d       	mov	r24, r14
    63b2:	b5 01       	movw	r22, r10
    63b4:	0e 94 77 2a 	call	0x54ee	; 0x54ee <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    63b8:	45 e2       	ldi	r20, 0x25	; 37
    63ba:	c4 2e       	mov	r12, r20
    63bc:	d1 2c       	mov	r13, r1
    63be:	cc 0e       	add	r12, r28
    63c0:	dd 1e       	adc	r13, r29
    63c2:	8e 2d       	mov	r24, r14
    63c4:	6f 2d       	mov	r22, r15
    63c6:	a6 01       	movw	r20, r12
    63c8:	0e 94 5a 2a 	call	0x54b4	; 0x54b4 <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    63cc:	8e 2d       	mov	r24, r14
    63ce:	6f 2d       	mov	r22, r15
    63d0:	a3 01       	movw	r20, r6
    63d2:	0e 94 3d 2a 	call	0x547a	; 0x547a <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    63d6:	33 e4       	ldi	r19, 0x43	; 67
    63d8:	e3 2e       	mov	r14, r19
    63da:	f1 2c       	mov	r15, r1
    63dc:	ec 0e       	add	r14, r28
    63de:	fd 1e       	adc	r15, r29
    63e0:	c7 01       	movw	r24, r14
    63e2:	0e 94 8c 1b 	call	0x3718	; 0x3718 <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    63e6:	ed b7       	in	r30, 0x3d	; 61
    63e8:	fe b7       	in	r31, 0x3e	; 62
    63ea:	74 97       	sbiw	r30, 0x14	; 20
    63ec:	0f b6       	in	r0, 0x3f	; 63
    63ee:	f8 94       	cli
    63f0:	fe bf       	out	0x3e, r31	; 62
    63f2:	0f be       	out	0x3f, r0	; 63
    63f4:	ed bf       	out	0x3d, r30	; 61
    63f6:	31 96       	adiw	r30, 0x01	; 1
    63f8:	8e 01       	movw	r16, r28
    63fa:	09 5a       	subi	r16, 0xA9	; 169
    63fc:	1f 4f       	sbci	r17, 0xFF	; 255
    63fe:	ad b7       	in	r26, 0x3d	; 61
    6400:	be b7       	in	r27, 0x3e	; 62
    6402:	12 96       	adiw	r26, 0x02	; 2
    6404:	1c 93       	st	X, r17
    6406:	0e 93       	st	-X, r16
    6408:	11 97       	sbiw	r26, 0x01	; 1
    640a:	8e e1       	ldi	r24, 0x1E	; 30
    640c:	95 e0       	ldi	r25, 0x05	; 5
    640e:	93 83       	std	Z+3, r25	; 0x03
    6410:	82 83       	std	Z+2, r24	; 0x02
    6412:	35 82       	std	Z+5, r3	; 0x05
    6414:	24 82       	std	Z+4, r2	; 0x04
    6416:	57 82       	std	Z+7, r5	; 0x07
    6418:	46 82       	std	Z+6, r4	; 0x06
    641a:	8e e5       	ldi	r24, 0x5E	; 94
    641c:	97 e0       	ldi	r25, 0x07	; 7
    641e:	91 87       	std	Z+9, r25	; 0x09
    6420:	80 87       	std	Z+8, r24	; 0x08
    6422:	f3 86       	std	Z+11, r15	; 0x0b
    6424:	e2 86       	std	Z+10, r14	; 0x0a
    6426:	95 86       	std	Z+13, r9	; 0x0d
    6428:	84 86       	std	Z+12, r8	; 0x0c
    642a:	b7 86       	std	Z+15, r11	; 0x0f
    642c:	a6 86       	std	Z+14, r10	; 0x0e
    642e:	d1 8a       	std	Z+17, r13	; 0x11
    6430:	c0 8a       	std	Z+16, r12	; 0x10
    6432:	62 8a       	std	Z+18, r6	; 0x12
    6434:	73 8a       	std	Z+19, r7	; 0x13
    6436:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 cSum=SumChecksum(strSend);
    643a:	ad b7       	in	r26, 0x3d	; 61
    643c:	be b7       	in	r27, 0x3e	; 62
    643e:	54 96       	adiw	r26, 0x14	; 20
    6440:	0f b6       	in	r0, 0x3f	; 63
    6442:	f8 94       	cli
    6444:	be bf       	out	0x3e, r27	; 62
    6446:	0f be       	out	0x3f, r0	; 63
    6448:	ad bf       	out	0x3d, r26	; 61
    644a:	c8 01       	movw	r24, r16
    644c:	0e 94 8c 24 	call	0x4918	; 0x4918 <SumChecksum>
    6450:	e8 2e       	mov	r14, r24
	 uart_print(1,0,strSend);
    6452:	81 e0       	ldi	r24, 0x01	; 1
    6454:	60 e0       	ldi	r22, 0x00	; 0
    6456:	a8 01       	movw	r20, r16
    6458:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
    645c:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    645e:	c8 01       	movw	r24, r16
    6460:	f9 2e       	mov	r15, r25
    6462:	ce 01       	movw	r24, r28
    6464:	8f 54       	subi	r24, 0x4F	; 79
    6466:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    6468:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    646a:	e8 17       	cp	r30, r24
    646c:	f9 07       	cpc	r31, r25
    646e:	e1 f7       	brne	.-8      	; 0x6468 <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    6470:	00 d0       	rcall	.+0      	; 0x6472 <GeniusSendLastTransaction+0x1a8>
    6472:	00 d0       	rcall	.+0      	; 0x6474 <GeniusSendLastTransaction+0x1aa>
    6474:	00 d0       	rcall	.+0      	; 0x6476 <GeniusSendLastTransaction+0x1ac>
    6476:	ed b7       	in	r30, 0x3d	; 61
    6478:	fe b7       	in	r31, 0x3e	; 62
    647a:	31 96       	adiw	r30, 0x01	; 1
    647c:	ad b7       	in	r26, 0x3d	; 61
    647e:	be b7       	in	r27, 0x3e	; 62
    6480:	11 96       	adiw	r26, 0x01	; 1
    6482:	0c 93       	st	X, r16
    6484:	11 97       	sbiw	r26, 0x01	; 1
    6486:	12 96       	adiw	r26, 0x02	; 2
    6488:	fc 92       	st	X, r15
    648a:	8b e1       	ldi	r24, 0x1B	; 27
    648c:	95 e0       	ldi	r25, 0x05	; 5
    648e:	93 83       	std	Z+3, r25	; 0x03
    6490:	82 83       	std	Z+2, r24	; 0x02
    6492:	e4 82       	std	Z+4, r14	; 0x04
    6494:	15 82       	std	Z+5, r1	; 0x05
    6496:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 uart_print(1,1,strSend);	 
    649a:	ed b7       	in	r30, 0x3d	; 61
    649c:	fe b7       	in	r31, 0x3e	; 62
    649e:	36 96       	adiw	r30, 0x06	; 6
    64a0:	0f b6       	in	r0, 0x3f	; 63
    64a2:	f8 94       	cli
    64a4:	fe bf       	out	0x3e, r31	; 62
    64a6:	0f be       	out	0x3f, r0	; 63
    64a8:	ed bf       	out	0x3d, r30	; 61
    64aa:	81 e0       	ldi	r24, 0x01	; 1
    64ac:	61 e0       	ldi	r22, 0x01	; 1
    64ae:	40 2f       	mov	r20, r16
    64b0:	5f 2d       	mov	r21, r15
    64b2:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
}
    64b6:	c0 55       	subi	r28, 0x50	; 80
    64b8:	df 4f       	sbci	r29, 0xFF	; 255
    64ba:	0f b6       	in	r0, 0x3f	; 63
    64bc:	f8 94       	cli
    64be:	de bf       	out	0x3e, r29	; 62
    64c0:	0f be       	out	0x3f, r0	; 63
    64c2:	cd bf       	out	0x3d, r28	; 61
    64c4:	cf 91       	pop	r28
    64c6:	df 91       	pop	r29
    64c8:	1f 91       	pop	r17
    64ca:	0f 91       	pop	r16
    64cc:	ff 90       	pop	r15
    64ce:	ef 90       	pop	r14
    64d0:	df 90       	pop	r13
    64d2:	cf 90       	pop	r12
    64d4:	bf 90       	pop	r11
    64d6:	af 90       	pop	r10
    64d8:	9f 90       	pop	r9
    64da:	8f 90       	pop	r8
    64dc:	7f 90       	pop	r7
    64de:	6f 90       	pop	r6
    64e0:	5f 90       	pop	r5
    64e2:	4f 90       	pop	r4
    64e4:	3f 90       	pop	r3
    64e6:	2f 90       	pop	r2
    64e8:	08 95       	ret

000064ea <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    64ea:	80 91 bf 01 	lds	r24, 0x01BF
    64ee:	83 30       	cpi	r24, 0x03	; 3
    64f0:	61 f1       	breq	.+88     	; 0x654a <systemGeniusProtocol+0x60>
    64f2:	84 30       	cpi	r24, 0x04	; 4
    64f4:	28 f4       	brcc	.+10     	; 0x6500 <systemGeniusProtocol+0x16>
    64f6:	81 30       	cpi	r24, 0x01	; 1
    64f8:	81 f0       	breq	.+32     	; 0x651a <systemGeniusProtocol+0x30>
    64fa:	82 30       	cpi	r24, 0x02	; 2
    64fc:	c0 f4       	brcc	.+48     	; 0x652e <systemGeniusProtocol+0x44>
    64fe:	09 c0       	rjmp	.+18     	; 0x6512 <systemGeniusProtocol+0x28>
    6500:	85 30       	cpi	r24, 0x05	; 5
    6502:	09 f4       	brne	.+2      	; 0x6506 <systemGeniusProtocol+0x1c>
    6504:	43 c0       	rjmp	.+134    	; 0x658c <systemGeniusProtocol+0xa2>
    6506:	85 30       	cpi	r24, 0x05	; 5
    6508:	a0 f1       	brcs	.+104    	; 0x6572 <systemGeniusProtocol+0x88>
    650a:	86 30       	cpi	r24, 0x06	; 6
    650c:	09 f0       	breq	.+2      	; 0x6510 <systemGeniusProtocol+0x26>
    650e:	58 c0       	rjmp	.+176    	; 0x65c0 <systemGeniusProtocol+0xd6>
    6510:	45 c0       	rjmp	.+138    	; 0x659c <systemGeniusProtocol+0xb2>
	 case gpInitScan:
	      iPumpID=1;
    6512:	81 e0       	ldi	r24, 0x01	; 1
    6514:	80 93 be 01 	sts	0x01BE, r24
    6518:	3e c0       	rjmp	.+124    	; 0x6596 <systemGeniusProtocol+0xac>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    651a:	80 91 bd 01 	lds	r24, 0x01BD
    651e:	0e 94 1c 1b 	call	0x3638	; 0x3638 <GetIncomingTransStatus>
    6522:	82 30       	cpi	r24, 0x02	; 2
    6524:	09 f0       	breq	.+2      	; 0x6528 <systemGeniusProtocol+0x3e>
    6526:	4c c0       	rjmp	.+152    	; 0x65c0 <systemGeniusProtocol+0xd6>
		      IsTotalizerReceived=False;
    6528:	10 92 af 01 	sts	0x01AF, r1
    652c:	34 c0       	rjmp	.+104    	; 0x6596 <systemGeniusProtocol+0xac>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    652e:	90 91 be 01 	lds	r25, 0x01BE
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    6532:	85 e0       	ldi	r24, 0x05	; 5
    6534:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    6538:	90 93 d3 0b 	sts	0x0BD3, r25
     IsControlPooling=True;
    653c:	81 e0       	ldi	r24, 0x01	; 1
    653e:	80 93 84 01 	sts	0x0184, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    6542:	10 92 78 0c 	sts	0x0C78, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    6546:	83 e0       	ldi	r24, 0x03	; 3
    6548:	26 c0       	rjmp	.+76     	; 0x6596 <systemGeniusProtocol+0xac>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    654a:	80 91 af 01 	lds	r24, 0x01AF
    654e:	81 30       	cpi	r24, 0x01	; 1
    6550:	59 f4       	brne	.+22     	; 0x6568 <systemGeniusProtocol+0x7e>
    6552:	90 91 ec 0b 	lds	r25, 0x0BEC
    6556:	80 91 be 01 	lds	r24, 0x01BE
    655a:	98 17       	cp	r25, r24
    655c:	29 f4       	brne	.+10     	; 0x6568 <systemGeniusProtocol+0x7e>
		      IsTotalizerReceived=False;
    655e:	10 92 af 01 	sts	0x01AF, r1
			  stGeniusProtocol=gpSendTransactionData;
    6562:	84 e0       	ldi	r24, 0x04	; 4
    6564:	80 93 bf 01 	sts	0x01BF, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    6568:	80 91 78 0c 	lds	r24, 0x0C78
    656c:	85 31       	cpi	r24, 0x15	; 21
    656e:	40 f1       	brcs	.+80     	; 0x65c0 <systemGeniusProtocol+0xd6>
    6570:	11 c0       	rjmp	.+34     	; 0x6594 <systemGeniusProtocol+0xaa>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    6572:	80 91 be 01 	lds	r24, 0x01BE
    6576:	0e 94 65 31 	call	0x62ca	; 0x62ca <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    657a:	80 91 be 01 	lds	r24, 0x01BE
    657e:	63 e0       	ldi	r22, 0x03	; 3
    6580:	0e 94 ea 1a 	call	0x35d4	; 0x35d4 <SetIncomingTransStatus>
		  
		  TimSend=0;
    6584:	10 92 78 0c 	sts	0x0C78, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    6588:	85 e0       	ldi	r24, 0x05	; 5
    658a:	05 c0       	rjmp	.+10     	; 0x6596 <systemGeniusProtocol+0xac>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    658c:	80 91 78 0c 	lds	r24, 0x0C78
    6590:	82 30       	cpi	r24, 0x02	; 2
    6592:	b0 f0       	brcs	.+44     	; 0x65c0 <systemGeniusProtocol+0xd6>
    6594:	86 e0       	ldi	r24, 0x06	; 6
    6596:	80 93 bf 01 	sts	0x01BF, r24
    659a:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    659c:	20 91 be 01 	lds	r18, 0x01BE
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    65a0:	e1 99       	sbic	0x1c, 1	; 28
    65a2:	fe cf       	rjmp	.-4      	; 0x65a0 <systemGeniusProtocol+0xb6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    65a4:	84 e4       	ldi	r24, 0x44	; 68
    65a6:	91 e0       	ldi	r25, 0x01	; 1
    65a8:	9f bb       	out	0x1f, r25	; 31
    65aa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    65ac:	e0 9a       	sbi	0x1c, 0	; 28
    65ae:	8d b3       	in	r24, 0x1d	; 29
    65b0:	82 17       	cp	r24, r18
    65b2:	30 f0       	brcs	.+12     	; 0x65c0 <systemGeniusProtocol+0xd6>
		      iPumpID++;
    65b4:	2f 5f       	subi	r18, 0xFF	; 255
    65b6:	20 93 be 01 	sts	0x01BE, r18
              stGeniusProtocol=gpScanNewTransaction;
    65ba:	81 e0       	ldi	r24, 0x01	; 1
    65bc:	80 93 bf 01 	sts	0x01BF, r24
    65c0:	08 95       	ret

000065c2 <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    65c2:	ef 92       	push	r14
    65c4:	ff 92       	push	r15
    65c6:	0f 93       	push	r16
    65c8:	1f 93       	push	r17
    65ca:	18 2f       	mov	r17, r24
    65cc:	09 2f       	mov	r16, r25
    65ce:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    65d0:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
	 RemSpaceLead(Source);
    65d4:	81 2f       	mov	r24, r17
    65d6:	90 2f       	mov	r25, r16
    65d8:	0e 94 a0 28 	call	0x5140	; 0x5140 <RemSpaceLead>
	 srcLength=strlen(Source);
    65dc:	a1 2f       	mov	r26, r17
    65de:	b0 2f       	mov	r27, r16
    65e0:	fd 01       	movw	r30, r26
    65e2:	01 90       	ld	r0, Z+
    65e4:	00 20       	and	r0, r0
    65e6:	e9 f7       	brne	.-6      	; 0x65e2 <StrAlignCenter+0x20>
    65e8:	31 97       	sbiw	r30, 0x01	; 1
    65ea:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    65ec:	c7 01       	movw	r24, r14
    65ee:	8e 1b       	sub	r24, r30
    65f0:	91 09       	sbc	r25, r1
    65f2:	96 95       	lsr	r25
    65f4:	87 95       	ror	r24
    65f6:	e8 0f       	add	r30, r24
    65f8:	81 2f       	mov	r24, r17
    65fa:	90 2f       	mov	r25, r16
    65fc:	6e 2f       	mov	r22, r30
    65fe:	0e 94 78 30 	call	0x60f0	; 0x60f0 <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    6602:	81 2f       	mov	r24, r17
    6604:	90 2f       	mov	r25, r16
    6606:	6e 2d       	mov	r22, r14
    6608:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
}
    660c:	1f 91       	pop	r17
    660e:	0f 91       	pop	r16
    6610:	ff 90       	pop	r15
    6612:	ef 90       	pop	r14
    6614:	08 95       	ret

00006616 <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    6616:	bf 92       	push	r11
    6618:	cf 92       	push	r12
    661a:	df 92       	push	r13
    661c:	ef 92       	push	r14
    661e:	ff 92       	push	r15
    6620:	0f 93       	push	r16
    6622:	1f 93       	push	r17
    6624:	df 93       	push	r29
    6626:	cf 93       	push	r28
    6628:	cd b7       	in	r28, 0x3d	; 61
    662a:	de b7       	in	r29, 0x3e	; 62
    662c:	6e 97       	sbiw	r28, 0x1e	; 30
    662e:	0f b6       	in	r0, 0x3f	; 63
    6630:	f8 94       	cli
    6632:	de bf       	out	0x3e, r29	; 62
    6634:	0f be       	out	0x3f, r0	; 63
    6636:	cd bf       	out	0x3d, r28	; 61
    6638:	8c 01       	movw	r16, r24
    663a:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    663c:	fc 01       	movw	r30, r24
    663e:	01 90       	ld	r0, Z+
    6640:	00 20       	and	r0, r0
    6642:	e9 f7       	brne	.-6      	; 0x663e <AddCharLead+0x28>
    6644:	31 97       	sbiw	r30, 0x01	; 1
    6646:	2e 2f       	mov	r18, r30
    6648:	28 1b       	sub	r18, r24

	 if (Size>Length){
    664a:	24 17       	cp	r18, r20
    664c:	d0 f5       	brcc	.+116    	; 0x66c2 <AddCharLead+0xac>
    664e:	ae 01       	movw	r20, r28
    6650:	4f 5f       	subi	r20, 0xFF	; 255
    6652:	5f 4f       	sbci	r21, 0xFF	; 255
    6654:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    6656:	b4 2e       	mov	r11, r20
    6658:	01 c0       	rjmp	.+2      	; 0x665c <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    665a:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    665c:	8e 2f       	mov	r24, r30
    665e:	8b 19       	sub	r24, r11
    6660:	8e 15       	cp	r24, r14
    6662:	d8 f3       	brcs	.-10     	; 0x665a <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    6664:	6e 2d       	mov	r22, r14
    6666:	70 e0       	ldi	r23, 0x00	; 0
    6668:	ce 01       	movw	r24, r28
    666a:	01 96       	adiw	r24, 0x01	; 1
    666c:	fc 01       	movw	r30, r24
    666e:	e6 0f       	add	r30, r22
    6670:	f7 1f       	adc	r31, r23
    6672:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    6674:	fe 2c       	mov	r15, r14
    6676:	f2 1a       	sub	r15, r18
    6678:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    667a:	30 e0       	ldi	r19, 0x00	; 0
    667c:	26 1b       	sub	r18, r22
    667e:	37 0b       	sbc	r19, r23
    6680:	0c c0       	rjmp	.+24     	; 0x669a <AddCharLead+0x84>
    6682:	ef 2d       	mov	r30, r15
    6684:	f0 e0       	ldi	r31, 0x00	; 0
    6686:	d6 01       	movw	r26, r12
    6688:	ae 0f       	add	r26, r30
    668a:	bf 1f       	adc	r27, r31
    668c:	e0 0f       	add	r30, r16
    668e:	f1 1f       	adc	r31, r17
    6690:	e2 0f       	add	r30, r18
    6692:	f3 1f       	adc	r31, r19
    6694:	80 81       	ld	r24, Z
    6696:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    6698:	f3 94       	inc	r15
    669a:	fe 14       	cp	r15, r14
    669c:	90 f3       	brcs	.-28     	; 0x6682 <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    669e:	6c 0d       	add	r22, r12
    66a0:	7d 1d       	adc	r23, r13
    66a2:	db 01       	movw	r26, r22
    66a4:	1c 92       	st	X, r1
    66a6:	f8 01       	movw	r30, r16
    66a8:	04 c0       	rjmp	.+8      	; 0x66b2 <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    66aa:	da 01       	movw	r26, r20
    66ac:	8d 91       	ld	r24, X+
    66ae:	ad 01       	movw	r20, r26
    66b0:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    66b2:	84 2f       	mov	r24, r20
    66b4:	8b 19       	sub	r24, r11
    66b6:	8e 15       	cp	r24, r14
    66b8:	c0 f3       	brcs	.-16     	; 0x66aa <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    66ba:	0e 0d       	add	r16, r14
    66bc:	11 1d       	adc	r17, r1
    66be:	f8 01       	movw	r30, r16
    66c0:	10 82       	st	Z, r1
	 }
}
    66c2:	6e 96       	adiw	r28, 0x1e	; 30
    66c4:	0f b6       	in	r0, 0x3f	; 63
    66c6:	f8 94       	cli
    66c8:	de bf       	out	0x3e, r29	; 62
    66ca:	0f be       	out	0x3f, r0	; 63
    66cc:	cd bf       	out	0x3d, r28	; 61
    66ce:	cf 91       	pop	r28
    66d0:	df 91       	pop	r29
    66d2:	1f 91       	pop	r17
    66d4:	0f 91       	pop	r16
    66d6:	ff 90       	pop	r15
    66d8:	ef 90       	pop	r14
    66da:	df 90       	pop	r13
    66dc:	cf 90       	pop	r12
    66de:	bf 90       	pop	r11
    66e0:	08 95       	ret

000066e2 <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    66e2:	cf 93       	push	r28
    66e4:	df 93       	push	r29
    66e6:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    66e8:	dc 01       	movw	r26, r24
    66ea:	0d 90       	ld	r0, X+
    66ec:	00 20       	and	r0, r0
    66ee:	e9 f7       	brne	.-6      	; 0x66ea <AddCharLag+0x8>
    66f0:	11 97       	sbiw	r26, 0x01	; 1
    66f2:	a8 1b       	sub	r26, r24
    66f4:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    66f6:	a4 17       	cp	r26, r20
    66f8:	58 f4       	brcc	.+22     	; 0x6710 <AddCharLag+0x2e>
    66fa:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    66fc:	fe 01       	movw	r30, r28
    66fe:	e8 0f       	add	r30, r24
    6700:	f1 1d       	adc	r31, r1
    6702:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    6704:	8f 5f       	subi	r24, 0xFF	; 255
    6706:	84 17       	cp	r24, r20
    6708:	c8 f3       	brcs	.-14     	; 0x66fc <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    670a:	c4 0f       	add	r28, r20
    670c:	d1 1d       	adc	r29, r1
    670e:	18 82       	st	Y, r1
  }

}
    6710:	df 91       	pop	r29
    6712:	cf 91       	pop	r28
    6714:	08 95       	ret

00006716 <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    6716:	cf 92       	push	r12
    6718:	df 92       	push	r13
    671a:	ef 92       	push	r14
    671c:	ff 92       	push	r15
    671e:	0f 93       	push	r16
    6720:	1f 93       	push	r17
    6722:	cf 93       	push	r28
    6724:	df 93       	push	r29
    6726:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    6728:	dc 01       	movw	r26, r24
    672a:	0d 90       	ld	r0, X+
    672c:	00 20       	and	r0, r0
    672e:	e9 f7       	brne	.-6      	; 0x672a <CountTotalizerSatus+0x14>
    6730:	8d 01       	movw	r16, r26
    6732:	01 50       	subi	r16, 0x01	; 1
    6734:	10 40       	sbci	r17, 0x00	; 0
    6736:	08 1b       	sub	r16, r24
    6738:	19 0b       	sbc	r17, r25
    673a:	cc 24       	eor	r12, r12
    673c:	dd 24       	eor	r13, r13
    673e:	0a c0       	rjmp	.+20     	; 0x6754 <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    6740:	84 e1       	ldi	r24, 0x14	; 20
    6742:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    6746:	ce 0d       	add	r28, r14
    6748:	df 1d       	adc	r29, r15
    674a:	98 81       	ld	r25, Y
    674c:	98 17       	cp	r25, r24
    674e:	09 f4       	brne	.+2      	; 0x6752 <CountTotalizerSatus+0x3c>
		      Result++;		  
    6750:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    6752:	c3 94       	inc	r12
    6754:	cc 2d       	mov	r28, r12
    6756:	d0 e0       	ldi	r29, 0x00	; 0
    6758:	c0 17       	cp	r28, r16
    675a:	d1 07       	cpc	r29, r17
    675c:	88 f3       	brcs	.-30     	; 0x6740 <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    675e:	8d 2d       	mov	r24, r13
    6760:	df 91       	pop	r29
    6762:	cf 91       	pop	r28
    6764:	1f 91       	pop	r17
    6766:	0f 91       	pop	r16
    6768:	ff 90       	pop	r15
    676a:	ef 90       	pop	r14
    676c:	df 90       	pop	r13
    676e:	cf 90       	pop	r12
    6770:	08 95       	ret

00006772 <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    6772:	1f 93       	push	r17
    6774:	df 93       	push	r29
    6776:	cf 93       	push	r28
    6778:	cd b7       	in	r28, 0x3d	; 61
    677a:	de b7       	in	r29, 0x3e	; 62
    677c:	64 97       	sbiw	r28, 0x14	; 20
    677e:	0f b6       	in	r0, 0x3f	; 63
    6780:	f8 94       	cli
    6782:	de bf       	out	0x3e, r29	; 62
    6784:	0f be       	out	0x3f, r0	; 63
    6786:	cd bf       	out	0x3d, r28	; 61
    6788:	16 2f       	mov	r17, r22
    678a:	50 e0       	ldi	r21, 0x00	; 0
    678c:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    678e:	be 01       	movw	r22, r28
    6790:	6f 5f       	subi	r22, 0xFF	; 255
    6792:	7f 4f       	sbci	r23, 0xFF	; 255
    6794:	0c c0       	rjmp	.+24     	; 0x67ae <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    6796:	28 0f       	add	r18, r24
    6798:	39 1f       	adc	r19, r25
    679a:	d9 01       	movw	r26, r18
    679c:	2c 91       	ld	r18, X
    679e:	21 17       	cp	r18, r17
    67a0:	29 f0       	breq	.+10     	; 0x67ac <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    67a2:	fb 01       	movw	r30, r22
    67a4:	e4 0f       	add	r30, r20
    67a6:	f1 1d       	adc	r31, r1
    67a8:	20 83       	st	Z, r18
			 iAdd++;
    67aa:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    67ac:	5f 5f       	subi	r21, 0xFF	; 255
    67ae:	25 2f       	mov	r18, r21
    67b0:	30 e0       	ldi	r19, 0x00	; 0
    67b2:	fc 01       	movw	r30, r24
    67b4:	01 90       	ld	r0, Z+
    67b6:	00 20       	and	r0, r0
    67b8:	e9 f7       	brne	.-6      	; 0x67b4 <RemoveChar+0x42>
    67ba:	31 97       	sbiw	r30, 0x01	; 1
    67bc:	e8 1b       	sub	r30, r24
    67be:	f9 0b       	sbc	r31, r25
    67c0:	2e 17       	cp	r18, r30
    67c2:	3f 07       	cpc	r19, r31
    67c4:	40 f3       	brcs	.-48     	; 0x6796 <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    67c6:	9e 01       	movw	r18, r28
    67c8:	2f 5f       	subi	r18, 0xFF	; 255
    67ca:	3f 4f       	sbci	r19, 0xFF	; 255
    67cc:	f9 01       	movw	r30, r18
    67ce:	e4 0f       	add	r30, r20
    67d0:	f1 1d       	adc	r31, r1
    67d2:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    67d4:	00 d0       	rcall	.+0      	; 0x67d6 <RemoveChar+0x64>
    67d6:	00 d0       	rcall	.+0      	; 0x67d8 <RemoveChar+0x66>
    67d8:	00 d0       	rcall	.+0      	; 0x67da <RemoveChar+0x68>
    67da:	ed b7       	in	r30, 0x3d	; 61
    67dc:	fe b7       	in	r31, 0x3e	; 62
    67de:	31 96       	adiw	r30, 0x01	; 1
    67e0:	ad b7       	in	r26, 0x3d	; 61
    67e2:	be b7       	in	r27, 0x3e	; 62
    67e4:	12 96       	adiw	r26, 0x02	; 2
    67e6:	9c 93       	st	X, r25
    67e8:	8e 93       	st	-X, r24
    67ea:	11 97       	sbiw	r26, 0x01	; 1
    67ec:	89 e0       	ldi	r24, 0x09	; 9
    67ee:	9a e1       	ldi	r25, 0x1A	; 26
    67f0:	93 83       	std	Z+3, r25	; 0x03
    67f2:	82 83       	std	Z+2, r24	; 0x02
    67f4:	35 83       	std	Z+5, r19	; 0x05
    67f6:	24 83       	std	Z+4, r18	; 0x04
    67f8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    67fc:	ed b7       	in	r30, 0x3d	; 61
    67fe:	fe b7       	in	r31, 0x3e	; 62
    6800:	36 96       	adiw	r30, 0x06	; 6
    6802:	0f b6       	in	r0, 0x3f	; 63
    6804:	f8 94       	cli
    6806:	fe bf       	out	0x3e, r31	; 62
    6808:	0f be       	out	0x3f, r0	; 63
    680a:	ed bf       	out	0x3d, r30	; 61
}
    680c:	64 96       	adiw	r28, 0x14	; 20
    680e:	0f b6       	in	r0, 0x3f	; 63
    6810:	f8 94       	cli
    6812:	de bf       	out	0x3e, r29	; 62
    6814:	0f be       	out	0x3f, r0	; 63
    6816:	cd bf       	out	0x3d, r28	; 61
    6818:	cf 91       	pop	r28
    681a:	df 91       	pop	r29
    681c:	1f 91       	pop	r17
    681e:	08 95       	ret

00006820 <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    6820:	8f 92       	push	r8
    6822:	9f 92       	push	r9
    6824:	bf 92       	push	r11
    6826:	cf 92       	push	r12
    6828:	df 92       	push	r13
    682a:	ef 92       	push	r14
    682c:	ff 92       	push	r15
    682e:	0f 93       	push	r16
    6830:	1f 93       	push	r17
    6832:	df 93       	push	r29
    6834:	cf 93       	push	r28
    6836:	cd b7       	in	r28, 0x3d	; 61
    6838:	de b7       	in	r29, 0x3e	; 62
    683a:	2f 97       	sbiw	r28, 0x0f	; 15
    683c:	0f b6       	in	r0, 0x3f	; 63
    683e:	f8 94       	cli
    6840:	de bf       	out	0x3e, r29	; 62
    6842:	0f be       	out	0x3f, r0	; 63
    6844:	cd bf       	out	0x3d, r28	; 61
    6846:	6c 01       	movw	r12, r24
    6848:	bb 24       	eor	r11, r11
    684a:	40 e0       	ldi	r20, 0x00	; 0
    684c:	4e 01       	movw	r8, r28
    684e:	08 94       	sec
    6850:	81 1c       	adc	r8, r1
    6852:	91 1c       	adc	r9, r1
    6854:	12 c0       	rjmp	.+36     	; 0x687a <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    6856:	86 01       	movw	r16, r12
    6858:	0e 0d       	add	r16, r14
    685a:	1f 1d       	adc	r17, r15
    685c:	d8 01       	movw	r26, r16
    685e:	6c 91       	ld	r22, X
    6860:	60 53       	subi	r22, 0x30	; 48
    6862:	80 e0       	ldi	r24, 0x00	; 0
    6864:	0e 94 03 17 	call	0x2e06	; 0x2e06 <GeniusCalc>
    6868:	e8 0c       	add	r14, r8
    686a:	f9 1c       	adc	r15, r9
    686c:	80 5d       	subi	r24, 0xD0	; 208
    686e:	f7 01       	movw	r30, r14
    6870:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    6872:	d8 01       	movw	r26, r16
    6874:	4c 91       	ld	r20, X
    6876:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    6878:	b3 94       	inc	r11
    687a:	eb 2c       	mov	r14, r11
    687c:	ff 24       	eor	r15, r15
    687e:	d6 01       	movw	r26, r12
    6880:	0d 90       	ld	r0, X+
    6882:	00 20       	and	r0, r0
    6884:	e9 f7       	brne	.-6      	; 0x6880 <WrapCode+0x60>
    6886:	11 97       	sbiw	r26, 0x01	; 1
    6888:	ac 19       	sub	r26, r12
    688a:	bd 09       	sbc	r27, r13
    688c:	ea 16       	cp	r14, r26
    688e:	fb 06       	cpc	r15, r27
    6890:	10 f3       	brcs	.-60     	; 0x6856 <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    6892:	a8 0d       	add	r26, r8
    6894:	b9 1d       	adc	r27, r9
    6896:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    6898:	00 d0       	rcall	.+0      	; 0x689a <WrapCode+0x7a>
    689a:	00 d0       	rcall	.+0      	; 0x689c <WrapCode+0x7c>
    689c:	00 d0       	rcall	.+0      	; 0x689e <WrapCode+0x7e>
    689e:	ed b7       	in	r30, 0x3d	; 61
    68a0:	fe b7       	in	r31, 0x3e	; 62
    68a2:	31 96       	adiw	r30, 0x01	; 1
    68a4:	ad b7       	in	r26, 0x3d	; 61
    68a6:	be b7       	in	r27, 0x3e	; 62
    68a8:	12 96       	adiw	r26, 0x02	; 2
    68aa:	dc 92       	st	X, r13
    68ac:	ce 92       	st	-X, r12
    68ae:	11 97       	sbiw	r26, 0x01	; 1
    68b0:	84 e1       	ldi	r24, 0x14	; 20
    68b2:	9a e1       	ldi	r25, 0x1A	; 26
    68b4:	93 83       	std	Z+3, r25	; 0x03
    68b6:	82 83       	std	Z+2, r24	; 0x02
    68b8:	95 82       	std	Z+5, r9	; 0x05
    68ba:	84 82       	std	Z+4, r8	; 0x04
    68bc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    68c0:	ed b7       	in	r30, 0x3d	; 61
    68c2:	fe b7       	in	r31, 0x3e	; 62
    68c4:	36 96       	adiw	r30, 0x06	; 6
    68c6:	0f b6       	in	r0, 0x3f	; 63
    68c8:	f8 94       	cli
    68ca:	fe bf       	out	0x3e, r31	; 62
    68cc:	0f be       	out	0x3f, r0	; 63
    68ce:	ed bf       	out	0x3d, r30	; 61
}
    68d0:	2f 96       	adiw	r28, 0x0f	; 15
    68d2:	0f b6       	in	r0, 0x3f	; 63
    68d4:	f8 94       	cli
    68d6:	de bf       	out	0x3e, r29	; 62
    68d8:	0f be       	out	0x3f, r0	; 63
    68da:	cd bf       	out	0x3d, r28	; 61
    68dc:	cf 91       	pop	r28
    68de:	df 91       	pop	r29
    68e0:	1f 91       	pop	r17
    68e2:	0f 91       	pop	r16
    68e4:	ff 90       	pop	r15
    68e6:	ef 90       	pop	r14
    68e8:	df 90       	pop	r13
    68ea:	cf 90       	pop	r12
    68ec:	bf 90       	pop	r11
    68ee:	9f 90       	pop	r9
    68f0:	8f 90       	pop	r8
    68f2:	08 95       	ret

000068f4 <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    68f4:	8f 92       	push	r8
    68f6:	9f 92       	push	r9
    68f8:	af 92       	push	r10
    68fa:	bf 92       	push	r11
    68fc:	df 92       	push	r13
    68fe:	ef 92       	push	r14
    6900:	ff 92       	push	r15
    6902:	0f 93       	push	r16
    6904:	1f 93       	push	r17
    6906:	df 93       	push	r29
    6908:	cf 93       	push	r28
    690a:	cd b7       	in	r28, 0x3d	; 61
    690c:	de b7       	in	r29, 0x3e	; 62
    690e:	2d 97       	sbiw	r28, 0x0d	; 13
    6910:	0f b6       	in	r0, 0x3f	; 63
    6912:	f8 94       	cli
    6914:	de bf       	out	0x3e, r29	; 62
    6916:	0f be       	out	0x3f, r0	; 63
    6918:	cd bf       	out	0x3d, r28	; 61
    691a:	9c 01       	movw	r18, r24
    691c:	7b 01       	movw	r14, r22
    691e:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    6920:	dc 01       	movw	r26, r24
    6922:	15 96       	adiw	r26, 0x05	; 5
    6924:	8c 91       	ld	r24, X
    6926:	90 e0       	ldi	r25, 0x00	; 0
    6928:	c0 97       	sbiw	r24, 0x30	; 48
    692a:	68 e0       	ldi	r22, 0x08	; 8
    692c:	70 e0       	ldi	r23, 0x00	; 0
    692e:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    6932:	f7 01       	movw	r30, r14
    6934:	e8 0f       	add	r30, r24
    6936:	f1 1d       	adc	r31, r1
    6938:	80 81       	ld	r24, Z
    693a:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    693c:	f9 01       	movw	r30, r18
    693e:	86 81       	ldd	r24, Z+6	; 0x06
    6940:	90 e0       	ldi	r25, 0x00	; 0
    6942:	c0 97       	sbiw	r24, 0x30	; 48
    6944:	68 e0       	ldi	r22, 0x08	; 8
    6946:	70 e0       	ldi	r23, 0x00	; 0
    6948:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    694c:	f7 01       	movw	r30, r14
    694e:	e8 0f       	add	r30, r24
    6950:	f1 1d       	adc	r31, r1
    6952:	80 81       	ld	r24, Z
    6954:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    6956:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    6958:	8d b7       	in	r24, 0x3d	; 61
    695a:	9e b7       	in	r25, 0x3e	; 62
    695c:	08 97       	sbiw	r24, 0x08	; 8
    695e:	0f b6       	in	r0, 0x3f	; 63
    6960:	f8 94       	cli
    6962:	9e bf       	out	0x3e, r25	; 62
    6964:	0f be       	out	0x3f, r0	; 63
    6966:	8d bf       	out	0x3d, r24	; 61
    6968:	ed b7       	in	r30, 0x3d	; 61
    696a:	fe b7       	in	r31, 0x3e	; 62
    696c:	31 96       	adiw	r30, 0x01	; 1
    696e:	8e 01       	movw	r16, r28
    6970:	0c 5f       	subi	r16, 0xFC	; 252
    6972:	1f 4f       	sbci	r17, 0xFF	; 255
    6974:	ad b7       	in	r26, 0x3d	; 61
    6976:	be b7       	in	r27, 0x3e	; 62
    6978:	12 96       	adiw	r26, 0x02	; 2
    697a:	1c 93       	st	X, r17
    697c:	0e 93       	st	-X, r16
    697e:	11 97       	sbiw	r26, 0x01	; 1
    6980:	84 e0       	ldi	r24, 0x04	; 4
    6982:	9a e1       	ldi	r25, 0x1A	; 26
    6984:	93 83       	std	Z+3, r25	; 0x03
    6986:	82 83       	std	Z+2, r24	; 0x02
    6988:	35 83       	std	Z+5, r19	; 0x05
    698a:	24 83       	std	Z+4, r18	; 0x04
    698c:	ce 01       	movw	r24, r28
    698e:	01 96       	adiw	r24, 0x01	; 1
    6990:	97 83       	std	Z+7, r25	; 0x07
    6992:	86 83       	std	Z+6, r24	; 0x06
    6994:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    6998:	dd 24       	eor	r13, r13
    699a:	ed b7       	in	r30, 0x3d	; 61
    699c:	fe b7       	in	r31, 0x3e	; 62
    699e:	38 96       	adiw	r30, 0x08	; 8
    69a0:	0f b6       	in	r0, 0x3f	; 63
    69a2:	f8 94       	cli
    69a4:	fe bf       	out	0x3e, r31	; 62
    69a6:	0f be       	out	0x3f, r0	; 63
    69a8:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    69aa:	48 01       	movw	r8, r16
    69ac:	13 c0       	rjmp	.+38     	; 0x69d4 <GenerateKeyStamp+0xe0>
    69ae:	f4 01       	movw	r30, r8
    69b0:	e0 0f       	add	r30, r16
    69b2:	f1 1f       	adc	r31, r17
    69b4:	60 81       	ld	r22, Z
    69b6:	60 53       	subi	r22, 0x30	; 48
    69b8:	f7 01       	movw	r30, r14
    69ba:	e0 0f       	add	r30, r16
    69bc:	f1 1f       	adc	r31, r17
    69be:	40 81       	ld	r20, Z
    69c0:	40 53       	subi	r20, 0x30	; 48
    69c2:	81 e0       	ldi	r24, 0x01	; 1
    69c4:	0e 94 03 17 	call	0x2e06	; 0x2e06 <GeniusCalc>
    69c8:	0a 0d       	add	r16, r10
    69ca:	1b 1d       	adc	r17, r11
    69cc:	80 5d       	subi	r24, 0xD0	; 208
    69ce:	d8 01       	movw	r26, r16
    69d0:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    69d2:	d3 94       	inc	r13
    69d4:	0d 2d       	mov	r16, r13
    69d6:	10 e0       	ldi	r17, 0x00	; 0
    69d8:	d7 01       	movw	r26, r14
    69da:	0d 90       	ld	r0, X+
    69dc:	00 20       	and	r0, r0
    69de:	e9 f7       	brne	.-6      	; 0x69da <GenerateKeyStamp+0xe6>
    69e0:	11 97       	sbiw	r26, 0x01	; 1
    69e2:	ae 19       	sub	r26, r14
    69e4:	bf 09       	sbc	r27, r15
    69e6:	0a 17       	cp	r16, r26
    69e8:	1b 07       	cpc	r17, r27
    69ea:	08 f3       	brcs	.-62     	; 0x69ae <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    69ec:	aa 0d       	add	r26, r10
    69ee:	bb 1d       	adc	r27, r11
    69f0:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    69f2:	c5 01       	movw	r24, r10
    69f4:	0e 94 10 34 	call	0x6820	; 0x6820 <WrapCode>
}
    69f8:	2d 96       	adiw	r28, 0x0d	; 13
    69fa:	0f b6       	in	r0, 0x3f	; 63
    69fc:	f8 94       	cli
    69fe:	de bf       	out	0x3e, r29	; 62
    6a00:	0f be       	out	0x3f, r0	; 63
    6a02:	cd bf       	out	0x3d, r28	; 61
    6a04:	cf 91       	pop	r28
    6a06:	df 91       	pop	r29
    6a08:	1f 91       	pop	r17
    6a0a:	0f 91       	pop	r16
    6a0c:	ff 90       	pop	r15
    6a0e:	ef 90       	pop	r14
    6a10:	df 90       	pop	r13
    6a12:	bf 90       	pop	r11
    6a14:	af 90       	pop	r10
    6a16:	9f 90       	pop	r9
    6a18:	8f 90       	pop	r8
    6a1a:	08 95       	ret

00006a1c <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    6a1c:	af 92       	push	r10
    6a1e:	bf 92       	push	r11
    6a20:	cf 92       	push	r12
    6a22:	df 92       	push	r13
    6a24:	ef 92       	push	r14
    6a26:	ff 92       	push	r15
    6a28:	0f 93       	push	r16
    6a2a:	1f 93       	push	r17
    6a2c:	df 93       	push	r29
    6a2e:	cf 93       	push	r28
    6a30:	cd b7       	in	r28, 0x3d	; 61
    6a32:	de b7       	in	r29, 0x3e	; 62
    6a34:	28 97       	sbiw	r28, 0x08	; 8
    6a36:	0f b6       	in	r0, 0x3f	; 63
    6a38:	f8 94       	cli
    6a3a:	de bf       	out	0x3e, r29	; 62
    6a3c:	0f be       	out	0x3f, r0	; 63
    6a3e:	cd bf       	out	0x3d, r28	; 61
    6a40:	7c 01       	movw	r14, r24
    6a42:	c6 2e       	mov	r12, r22
    6a44:	5a 01       	movw	r10, r20
	    sprintf_P(strSend,PSTR("Date[%s]"),srcDate);
		uart_print(1,1,strSend);
     #endif
    

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-2,2);
    6a46:	fc 01       	movw	r30, r24
    6a48:	01 90       	ld	r0, Z+
    6a4a:	00 20       	and	r0, r0
    6a4c:	e9 f7       	brne	.-6      	; 0x6a48 <GenerateGeniusCode+0x2c>
    6a4e:	e8 1b       	sub	r30, r24
    6a50:	f9 0b       	sbc	r31, r25
    6a52:	33 97       	sbiw	r30, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    6a54:	e8 0f       	add	r30, r24
    6a56:	f9 1f       	adc	r31, r25
    6a58:	80 81       	ld	r24, Z
    6a5a:	89 83       	std	Y+1, r24	; 0x01
    6a5c:	81 81       	ldd	r24, Z+1	; 0x01
    6a5e:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    6a60:	1b 82       	std	Y+3, r1	; 0x03
    #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("Year:[%s]"),AddYear);
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    6a62:	00 d0       	rcall	.+0      	; 0x6a64 <GenerateGeniusCode+0x48>
    6a64:	00 d0       	rcall	.+0      	; 0x6a66 <GenerateGeniusCode+0x4a>
    6a66:	00 d0       	rcall	.+0      	; 0x6a68 <GenerateGeniusCode+0x4c>
    6a68:	ed b7       	in	r30, 0x3d	; 61
    6a6a:	fe b7       	in	r31, 0x3e	; 62
    6a6c:	31 96       	adiw	r30, 0x01	; 1
    6a6e:	8e 01       	movw	r16, r28
    6a70:	0c 5f       	subi	r16, 0xFC	; 252
    6a72:	1f 4f       	sbci	r17, 0xFF	; 255
    6a74:	ad b7       	in	r26, 0x3d	; 61
    6a76:	be b7       	in	r27, 0x3e	; 62
    6a78:	12 96       	adiw	r26, 0x02	; 2
    6a7a:	1c 93       	st	X, r17
    6a7c:	0e 93       	st	-X, r16
    6a7e:	11 97       	sbiw	r26, 0x01	; 1
    6a80:	8f e0       	ldi	r24, 0x0F	; 15
    6a82:	9a e1       	ldi	r25, 0x1A	; 26
    6a84:	93 83       	std	Z+3, r25	; 0x03
    6a86:	82 83       	std	Z+2, r24	; 0x02
    6a88:	ce 01       	movw	r24, r28
    6a8a:	01 96       	adiw	r24, 0x01	; 1
    6a8c:	95 83       	std	Z+5, r25	; 0x05
    6a8e:	84 83       	std	Z+4, r24	; 0x04
    6a90:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    6a94:	d7 01       	movw	r26, r14
    6a96:	0d 90       	ld	r0, X+
    6a98:	00 20       	and	r0, r0
    6a9a:	e9 f7       	brne	.-6      	; 0x6a96 <GenerateGeniusCode+0x7a>
    6a9c:	9d 01       	movw	r18, r26
    6a9e:	21 50       	subi	r18, 0x01	; 1
    6aa0:	30 40       	sbci	r19, 0x00	; 0
    6aa2:	2e 19       	sub	r18, r14
    6aa4:	3f 09       	sbc	r19, r15
    6aa6:	d8 01       	movw	r26, r16
    6aa8:	0d 90       	ld	r0, X+
    6aaa:	00 20       	and	r0, r0
    6aac:	e9 f7       	brne	.-6      	; 0x6aa8 <GenerateGeniusCode+0x8c>
    6aae:	11 97       	sbiw	r26, 0x01	; 1
    6ab0:	a0 1b       	sub	r26, r16
    6ab2:	b1 0b       	sbc	r27, r17
    6ab4:	22 50       	subi	r18, 0x02	; 2
    6ab6:	30 40       	sbci	r19, 0x00	; 0
    6ab8:	b7 01       	movw	r22, r14
    6aba:	62 0f       	add	r22, r18
    6abc:	73 1f       	adc	r23, r19
    6abe:	2e 5f       	subi	r18, 0xFE	; 254
    6ac0:	3f 4f       	sbci	r19, 0xFF	; 255
    6ac2:	40 e0       	ldi	r20, 0x00	; 0
    6ac4:	50 e0       	ldi	r21, 0x00	; 0
    6ac6:	ed b7       	in	r30, 0x3d	; 61
    6ac8:	fe b7       	in	r31, 0x3e	; 62
    6aca:	36 96       	adiw	r30, 0x06	; 6
    6acc:	0f b6       	in	r0, 0x3f	; 63
    6ace:	f8 94       	cli
    6ad0:	fe bf       	out	0x3e, r31	; 62
    6ad2:	0f be       	out	0x3f, r0	; 63
    6ad4:	ed bf       	out	0x3d, r30	; 61
    6ad6:	09 c0       	rjmp	.+18     	; 0x6aea <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    6ad8:	f8 01       	movw	r30, r16
    6ada:	e4 0f       	add	r30, r20
    6adc:	f5 1f       	adc	r31, r21
    6ade:	80 81       	ld	r24, Z
    6ae0:	fb 01       	movw	r30, r22
    6ae2:	81 93       	st	Z+, r24
    6ae4:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    6ae6:	4f 5f       	subi	r20, 0xFF	; 255
    6ae8:	5f 4f       	sbci	r21, 0xFF	; 255
    6aea:	4a 17       	cp	r20, r26
    6aec:	5b 07       	cpc	r21, r27
    6aee:	a0 f3       	brcs	.-24     	; 0x6ad8 <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    6af0:	ae 0d       	add	r26, r14
    6af2:	bf 1d       	adc	r27, r15
    6af4:	a2 0f       	add	r26, r18
    6af6:	b3 1f       	adc	r27, r19
    6af8:	12 97       	sbiw	r26, 0x02	; 2
    6afa:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("NewDate[%s]"),srcDate);
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    6afc:	00 d0       	rcall	.+0      	; 0x6afe <GenerateGeniusCode+0xe2>
    6afe:	00 d0       	rcall	.+0      	; 0x6b00 <GenerateGeniusCode+0xe4>
    6b00:	00 d0       	rcall	.+0      	; 0x6b02 <GenerateGeniusCode+0xe6>
    6b02:	ed b7       	in	r30, 0x3d	; 61
    6b04:	fe b7       	in	r31, 0x3e	; 62
    6b06:	31 96       	adiw	r30, 0x01	; 1
    6b08:	ad b7       	in	r26, 0x3d	; 61
    6b0a:	be b7       	in	r27, 0x3e	; 62
    6b0c:	12 96       	adiw	r26, 0x02	; 2
    6b0e:	bc 92       	st	X, r11
    6b10:	ae 92       	st	-X, r10
    6b12:	11 97       	sbiw	r26, 0x01	; 1
    6b14:	8c e0       	ldi	r24, 0x0C	; 12
    6b16:	9a e1       	ldi	r25, 0x1A	; 26
    6b18:	93 83       	std	Z+3, r25	; 0x03
    6b1a:	82 83       	std	Z+2, r24	; 0x02
    6b1c:	c4 82       	std	Z+4, r12	; 0x04
    6b1e:	15 82       	std	Z+5, r1	; 0x05
    6b20:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    6b24:	dd 24       	eor	r13, r13
    6b26:	d3 94       	inc	r13
    6b28:	ed b7       	in	r30, 0x3d	; 61
    6b2a:	fe b7       	in	r31, 0x3e	; 62
    6b2c:	36 96       	adiw	r30, 0x06	; 6
    6b2e:	0f b6       	in	r0, 0x3f	; 63
    6b30:	f8 94       	cli
    6b32:	fe bf       	out	0x3e, r31	; 62
    6b34:	0f be       	out	0x3f, r0	; 63
    6b36:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    6b38:	f0 ed       	ldi	r31, 0xD0	; 208
    6b3a:	cf 0e       	add	r12, r31
    6b3c:	0f c0       	rjmp	.+30     	; 0x6b5c <GenerateGeniusCode+0x140>
    6b3e:	f7 01       	movw	r30, r14
    6b40:	e0 0f       	add	r30, r16
    6b42:	f1 1f       	adc	r31, r17
    6b44:	40 81       	ld	r20, Z
    6b46:	40 53       	subi	r20, 0x30	; 48
    6b48:	80 e0       	ldi	r24, 0x00	; 0
    6b4a:	6c 2d       	mov	r22, r12
    6b4c:	0e 94 03 17 	call	0x2e06	; 0x2e06 <GeniusCalc>
    6b50:	0a 0d       	add	r16, r10
    6b52:	1b 1d       	adc	r17, r11
    6b54:	80 5d       	subi	r24, 0xD0	; 208
    6b56:	d8 01       	movw	r26, r16
    6b58:	8c 93       	st	X, r24
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    6b5a:	d3 94       	inc	r13
    6b5c:	0d 2d       	mov	r16, r13
    6b5e:	10 e0       	ldi	r17, 0x00	; 0
    6b60:	d7 01       	movw	r26, r14
    6b62:	0d 90       	ld	r0, X+
    6b64:	00 20       	and	r0, r0
    6b66:	e9 f7       	brne	.-6      	; 0x6b62 <GenerateGeniusCode+0x146>
    6b68:	11 97       	sbiw	r26, 0x01	; 1
    6b6a:	ae 19       	sub	r26, r14
    6b6c:	bf 09       	sbc	r27, r15
    6b6e:	0a 17       	cp	r16, r26
    6b70:	1b 07       	cpc	r17, r27
    6b72:	28 f3       	brcs	.-54     	; 0x6b3e <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    6b74:	aa 0d       	add	r26, r10
    6b76:	bb 1d       	adc	r27, r11
    6b78:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    6b7a:	c5 01       	movw	r24, r10
    6b7c:	0e 94 10 34 	call	0x6820	; 0x6820 <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif
}
    6b80:	28 96       	adiw	r28, 0x08	; 8
    6b82:	0f b6       	in	r0, 0x3f	; 63
    6b84:	f8 94       	cli
    6b86:	de bf       	out	0x3e, r29	; 62
    6b88:	0f be       	out	0x3f, r0	; 63
    6b8a:	cd bf       	out	0x3d, r28	; 61
    6b8c:	cf 91       	pop	r28
    6b8e:	df 91       	pop	r29
    6b90:	1f 91       	pop	r17
    6b92:	0f 91       	pop	r16
    6b94:	ff 90       	pop	r15
    6b96:	ef 90       	pop	r14
    6b98:	df 90       	pop	r13
    6b9a:	cf 90       	pop	r12
    6b9c:	bf 90       	pop	r11
    6b9e:	af 90       	pop	r10
    6ba0:	08 95       	ret

00006ba2 <GeneratePrintInit>:





void GeneratePrintInit(){//Create Initialize Print 
    6ba2:	cf 92       	push	r12
    6ba4:	df 92       	push	r13
    6ba6:	ef 92       	push	r14
    6ba8:	ff 92       	push	r15
    6baa:	0f 93       	push	r16
    6bac:	1f 93       	push	r17
    6bae:	df 93       	push	r29
    6bb0:	cf 93       	push	r28
    6bb2:	cd b7       	in	r28, 0x3d	; 61
    6bb4:	de b7       	in	r29, 0x3e	; 62
    6bb6:	62 97       	sbiw	r28, 0x12	; 18
    6bb8:	0f b6       	in	r0, 0x3f	; 63
    6bba:	f8 94       	cli
    6bbc:	de bf       	out	0x3e, r29	; 62
    6bbe:	0f be       	out	0x3f, r0	; 63
    6bc0:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    6bc2:	00 d0       	rcall	.+0      	; 0x6bc4 <GeneratePrintInit+0x22>
    6bc4:	00 d0       	rcall	.+0      	; 0x6bc6 <GeneratePrintInit+0x24>
    6bc6:	6e 01       	movw	r12, r28
    6bc8:	08 94       	sec
    6bca:	c1 1c       	adc	r12, r1
    6bcc:	d1 1c       	adc	r13, r1
    6bce:	ad b7       	in	r26, 0x3d	; 61
    6bd0:	be b7       	in	r27, 0x3e	; 62
    6bd2:	12 96       	adiw	r26, 0x02	; 2
    6bd4:	dc 92       	st	X, r13
    6bd6:	ce 92       	st	-X, r12
    6bd8:	11 97       	sbiw	r26, 0x01	; 1
    6bda:	8e e9       	ldi	r24, 0x9E	; 158
    6bdc:	9f e1       	ldi	r25, 0x1F	; 31
    6bde:	14 96       	adiw	r26, 0x04	; 4
    6be0:	9c 93       	st	X, r25
    6be2:	8e 93       	st	-X, r24
    6be4:	13 97       	sbiw	r26, 0x03	; 3
    6be6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    6bea:	e7 e0       	ldi	r30, 0x07	; 7
    6bec:	ee 2e       	mov	r14, r30
    6bee:	f1 2c       	mov	r15, r1
    6bf0:	ec 0e       	add	r14, r28
    6bf2:	fd 1e       	adc	r15, r29
    6bf4:	ed b7       	in	r30, 0x3d	; 61
    6bf6:	fe b7       	in	r31, 0x3e	; 62
    6bf8:	f2 82       	std	Z+2, r15	; 0x02
    6bfa:	e1 82       	std	Z+1, r14	; 0x01
    6bfc:	83 e9       	ldi	r24, 0x93	; 147
    6bfe:	9f e1       	ldi	r25, 0x1F	; 31
    6c00:	94 83       	std	Z+4, r25	; 0x04
    6c02:	83 83       	std	Z+3, r24	; 0x03
    6c04:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    6c08:	00 d0       	rcall	.+0      	; 0x6c0a <GeneratePrintInit+0x68>
    6c0a:	00 d0       	rcall	.+0      	; 0x6c0c <GeneratePrintInit+0x6a>
    6c0c:	ed b7       	in	r30, 0x3d	; 61
    6c0e:	fe b7       	in	r31, 0x3e	; 62
    6c10:	31 96       	adiw	r30, 0x01	; 1
    6c12:	0c ee       	ldi	r16, 0xEC	; 236
    6c14:	13 e0       	ldi	r17, 0x03	; 3
    6c16:	ad b7       	in	r26, 0x3d	; 61
    6c18:	be b7       	in	r27, 0x3e	; 62
    6c1a:	12 96       	adiw	r26, 0x02	; 2
    6c1c:	1c 93       	st	X, r17
    6c1e:	0e 93       	st	-X, r16
    6c20:	11 97       	sbiw	r26, 0x01	; 1
    6c22:	81 e2       	ldi	r24, 0x21	; 33
    6c24:	9f e1       	ldi	r25, 0x1F	; 31
    6c26:	93 83       	std	Z+3, r25	; 0x03
    6c28:	82 83       	std	Z+2, r24	; 0x02
    6c2a:	d5 82       	std	Z+5, r13	; 0x05
    6c2c:	c4 82       	std	Z+4, r12	; 0x04
    6c2e:	f7 82       	std	Z+7, r15	; 0x07
    6c30:	e6 82       	std	Z+6, r14	; 0x06
    6c32:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 uart_print(0,1,PrintBuffer);
    6c36:	ed b7       	in	r30, 0x3d	; 61
    6c38:	fe b7       	in	r31, 0x3e	; 62
    6c3a:	38 96       	adiw	r30, 0x08	; 8
    6c3c:	0f b6       	in	r0, 0x3f	; 63
    6c3e:	f8 94       	cli
    6c40:	fe bf       	out	0x3e, r31	; 62
    6c42:	0f be       	out	0x3f, r0	; 63
    6c44:	ed bf       	out	0x3d, r30	; 61
    6c46:	80 e0       	ldi	r24, 0x00	; 0
    6c48:	61 e0       	ldi	r22, 0x01	; 1
    6c4a:	a8 01       	movw	r20, r16
    6c4c:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    6c50:	f8 01       	movw	r30, r16
    6c52:	01 90       	ld	r0, Z+
    6c54:	00 20       	and	r0, r0
    6c56:	e9 f7       	brne	.-6      	; 0x6c52 <GeneratePrintInit+0xb0>
    6c58:	31 97       	sbiw	r30, 0x01	; 1
    6c5a:	e0 1b       	sub	r30, r16
    6c5c:	f1 0b       	sbc	r31, r17
    6c5e:	f0 93 8e 01 	sts	0x018E, r31
    6c62:	e0 93 8d 01 	sts	0x018D, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    6c66:	80 e3       	ldi	r24, 0x30	; 48
    6c68:	80 93 b5 01 	sts	0x01B5, r24
	 IsFreePrinting=True;
    6c6c:	81 e0       	ldi	r24, 0x01	; 1
    6c6e:	80 93 a8 01 	sts	0x01A8, r24
}
    6c72:	62 96       	adiw	r28, 0x12	; 18
    6c74:	0f b6       	in	r0, 0x3f	; 63
    6c76:	f8 94       	cli
    6c78:	de bf       	out	0x3e, r29	; 62
    6c7a:	0f be       	out	0x3f, r0	; 63
    6c7c:	cd bf       	out	0x3d, r28	; 61
    6c7e:	cf 91       	pop	r28
    6c80:	df 91       	pop	r29
    6c82:	1f 91       	pop	r17
    6c84:	0f 91       	pop	r16
    6c86:	ff 90       	pop	r15
    6c88:	ef 90       	pop	r14
    6c8a:	df 90       	pop	r13
    6c8c:	cf 90       	pop	r12
    6c8e:	08 95       	ret

00006c90 <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    6c90:	9f 92       	push	r9
    6c92:	af 92       	push	r10
    6c94:	bf 92       	push	r11
    6c96:	cf 92       	push	r12
    6c98:	df 92       	push	r13
    6c9a:	ef 92       	push	r14
    6c9c:	ff 92       	push	r15
    6c9e:	0f 93       	push	r16
    6ca0:	1f 93       	push	r17
    6ca2:	df 93       	push	r29
    6ca4:	cf 93       	push	r28
    6ca6:	cd b7       	in	r28, 0x3d	; 61
    6ca8:	de b7       	in	r29, 0x3e	; 62
    6caa:	64 97       	sbiw	r28, 0x14	; 20
    6cac:	0f b6       	in	r0, 0x3f	; 63
    6cae:	f8 94       	cli
    6cb0:	de bf       	out	0x3e, r29	; 62
    6cb2:	0f be       	out	0x3f, r0	; 63
    6cb4:	cd bf       	out	0x3d, r28	; 61
    6cb6:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6cb8:	e1 99       	sbic	0x1c, 1	; 28
    6cba:	fe cf       	rjmp	.-4      	; 0x6cb8 <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6cbc:	8f e3       	ldi	r24, 0x3F	; 63
    6cbe:	90 e0       	ldi	r25, 0x00	; 0
    6cc0:	9f bb       	out	0x1f, r25	; 31
    6cc2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6cc4:	e0 9a       	sbi	0x1c, 0	; 28
    6cc6:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6cc8:	e1 99       	sbic	0x1c, 1	; 28
    6cca:	fe cf       	rjmp	.-4      	; 0x6cc8 <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6ccc:	8e e3       	ldi	r24, 0x3E	; 62
    6cce:	90 e0       	ldi	r25, 0x00	; 0
    6cd0:	9f bb       	out	0x1f, r25	; 31
    6cd2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6cd4:	e0 9a       	sbi	0x1c, 0	; 28
    6cd6:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    6cd8:	f6 01       	movw	r30, r12
    6cda:	01 90       	ld	r0, Z+
    6cdc:	00 20       	and	r0, r0
    6cde:	e9 f7       	brne	.-6      	; 0x6cda <FormatCurrency+0x4a>
    6ce0:	31 97       	sbiw	r30, 0x01	; 1
    6ce2:	ee 2e       	mov	r14, r30
    6ce4:	ec 18       	sub	r14, r12
    6ce6:	fe 01       	movw	r30, r28
    6ce8:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6cea:	ce 01       	movw	r24, r28
    6cec:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    6cee:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6cf0:	e8 17       	cp	r30, r24
    6cf2:	f9 07       	cpc	r31, r25
    6cf4:	e1 f7       	brne	.-8      	; 0x6cee <FormatCurrency+0x5e>
    6cf6:	f6 01       	movw	r30, r12
    6cf8:	fe 2c       	mov	r15, r14
    6cfa:	20 e0       	ldi	r18, 0x00	; 0
    6cfc:	80 e0       	ldi	r24, 0x00	; 0
    6cfe:	09 c0       	rjmp	.+18     	; 0x6d12 <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    6d00:	90 81       	ld	r25, Z
    6d02:	93 17       	cp	r25, r19
    6d04:	09 f4       	brne	.+2      	; 0x6d08 <FormatCurrency+0x78>
    6d06:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    6d08:	99 15       	cp	r25, r9
    6d0a:	09 f4       	brne	.+2      	; 0x6d0e <FormatCurrency+0x7e>
    6d0c:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    6d0e:	8f 5f       	subi	r24, 0xFF	; 255
    6d10:	31 96       	adiw	r30, 0x01	; 1
    6d12:	8e 15       	cp	r24, r14
    6d14:	a8 f3       	brcs	.-22     	; 0x6d00 <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    6d16:	22 23       	and	r18, r18
    6d18:	09 f0       	breq	.+2      	; 0x6d1c <FormatCurrency+0x8c>
    6d1a:	5e c0       	rjmp	.+188    	; 0x6dd8 <FormatCurrency+0x148>
    6d1c:	83 e0       	ldi	r24, 0x03	; 3
    6d1e:	8f 15       	cp	r24, r15
    6d20:	08 f0       	brcs	.+2      	; 0x6d24 <FormatCurrency+0x94>
    6d22:	5a c0       	rjmp	.+180    	; 0x6dd8 <FormatCurrency+0x148>
    6d24:	40 e0       	ldi	r20, 0x00	; 0
    6d26:	20 e0       	ldi	r18, 0x00	; 0
    6d28:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    6d2a:	af 2c       	mov	r10, r15
    6d2c:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    6d2e:	8e 01       	movw	r16, r28
    6d30:	0f 5f       	subi	r16, 0xFF	; 255
    6d32:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    6d34:	c5 01       	movw	r24, r10
    6d36:	82 1b       	sub	r24, r18
    6d38:	93 0b       	sbc	r25, r19
    6d3a:	63 e0       	ldi	r22, 0x03	; 3
    6d3c:	70 e0       	ldi	r23, 0x00	; 0
    6d3e:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    6d42:	89 2b       	or	r24, r25
    6d44:	49 f4       	brne	.+18     	; 0x6d58 <FormatCurrency+0xc8>
    6d46:	2f 15       	cp	r18, r15
    6d48:	38 f4       	brcc	.+14     	; 0x6d58 <FormatCurrency+0xc8>
    6d4a:	22 23       	and	r18, r18
    6d4c:	29 f0       	breq	.+10     	; 0x6d58 <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    6d4e:	f8 01       	movw	r30, r16
    6d50:	e4 0f       	add	r30, r20
    6d52:	f1 1d       	adc	r31, r1
    6d54:	90 82       	st	Z, r9
		        iPos++;
    6d56:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    6d58:	d8 01       	movw	r26, r16
    6d5a:	a4 0f       	add	r26, r20
    6d5c:	b1 1d       	adc	r27, r1
    6d5e:	f6 01       	movw	r30, r12
    6d60:	e2 0f       	add	r30, r18
    6d62:	f3 1f       	adc	r31, r19
    6d64:	80 81       	ld	r24, Z
    6d66:	8c 93       	st	X, r24
			    iPos++;
    6d68:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6d6a:	f8 01       	movw	r30, r16
    6d6c:	e4 0f       	add	r30, r20
    6d6e:	f1 1d       	adc	r31, r1
    6d70:	10 82       	st	Z, r1
    6d72:	2f 5f       	subi	r18, 0xFF	; 255
    6d74:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    6d76:	2f 15       	cp	r18, r15
    6d78:	e8 f2       	brcs	.-70     	; 0x6d34 <FormatCurrency+0xa4>
    6d7a:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    6d7c:	9e 01       	movw	r18, r28
    6d7e:	2f 5f       	subi	r18, 0xFF	; 255
    6d80:	3f 4f       	sbci	r19, 0xFF	; 255
    6d82:	0e c0       	rjmp	.+28     	; 0x6da0 <FormatCurrency+0x110>
    6d84:	d9 01       	movw	r26, r18
    6d86:	a4 0f       	add	r26, r20
    6d88:	b1 1d       	adc	r27, r1
    6d8a:	f6 01       	movw	r30, r12
    6d8c:	e9 0f       	add	r30, r25
    6d8e:	f1 1d       	adc	r31, r1
    6d90:	80 81       	ld	r24, Z
    6d92:	8c 93       	st	X, r24
			    iPos++;
    6d94:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6d96:	f9 01       	movw	r30, r18
    6d98:	e4 0f       	add	r30, r20
    6d9a:	f1 1d       	adc	r31, r1
    6d9c:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    6d9e:	9f 5f       	subi	r25, 0xFF	; 255
    6da0:	9e 15       	cp	r25, r14
    6da2:	80 f3       	brcs	.-32     	; 0x6d84 <FormatCurrency+0xf4>
    6da4:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6da6:	9e 01       	movw	r18, r28
    6da8:	2f 5f       	subi	r18, 0xFF	; 255
    6daa:	3f 4f       	sbci	r19, 0xFF	; 255
    6dac:	09 c0       	rjmp	.+18     	; 0x6dc0 <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    6dae:	f6 01       	movw	r30, r12
    6db0:	ea 0f       	add	r30, r26
    6db2:	fb 1f       	adc	r31, r27
    6db4:	a2 0f       	add	r26, r18
    6db6:	b3 1f       	adc	r27, r19
    6db8:	8c 91       	ld	r24, X
    6dba:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    6dbc:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6dbe:	9f 5f       	subi	r25, 0xFF	; 255
    6dc0:	a9 2f       	mov	r26, r25
    6dc2:	b0 e0       	ldi	r27, 0x00	; 0
    6dc4:	f9 01       	movw	r30, r18
    6dc6:	01 90       	ld	r0, Z+
    6dc8:	00 20       	and	r0, r0
    6dca:	e9 f7       	brne	.-6      	; 0x6dc6 <FormatCurrency+0x136>
    6dcc:	31 97       	sbiw	r30, 0x01	; 1
    6dce:	e2 1b       	sub	r30, r18
    6dd0:	f3 0b       	sbc	r31, r19
    6dd2:	ae 17       	cp	r26, r30
    6dd4:	bf 07       	cpc	r27, r31
    6dd6:	58 f3       	brcs	.-42     	; 0x6dae <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    6dd8:	64 96       	adiw	r28, 0x14	; 20
    6dda:	0f b6       	in	r0, 0x3f	; 63
    6ddc:	f8 94       	cli
    6dde:	de bf       	out	0x3e, r29	; 62
    6de0:	0f be       	out	0x3f, r0	; 63
    6de2:	cd bf       	out	0x3d, r28	; 61
    6de4:	cf 91       	pop	r28
    6de6:	df 91       	pop	r29
    6de8:	1f 91       	pop	r17
    6dea:	0f 91       	pop	r16
    6dec:	ff 90       	pop	r15
    6dee:	ef 90       	pop	r14
    6df0:	df 90       	pop	r13
    6df2:	cf 90       	pop	r12
    6df4:	bf 90       	pop	r11
    6df6:	af 90       	pop	r10
    6df8:	9f 90       	pop	r9
    6dfa:	08 95       	ret

00006dfc <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    6dfc:	ef 92       	push	r14
    6dfe:	ff 92       	push	r15
    6e00:	0f 93       	push	r16
    6e02:	1f 93       	push	r17
    6e04:	df 93       	push	r29
    6e06:	cf 93       	push	r28
    6e08:	cd b7       	in	r28, 0x3d	; 61
    6e0a:	de b7       	in	r29, 0x3e	; 62
    6e0c:	64 97       	sbiw	r28, 0x14	; 20
    6e0e:	0f b6       	in	r0, 0x3f	; 63
    6e10:	f8 94       	cli
    6e12:	de bf       	out	0x3e, r29	; 62
    6e14:	0f be       	out	0x3f, r0	; 63
    6e16:	cd bf       	out	0x3d, r28	; 61
    6e18:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    6e1a:	66 23       	and	r22, r22
    6e1c:	09 f4       	brne	.+2      	; 0x6e20 <FormatDecimal+0x24>
    6e1e:	56 c0       	rjmp	.+172    	; 0x6ecc <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6e20:	e1 99       	sbic	0x1c, 1	; 28
    6e22:	fe cf       	rjmp	.-4      	; 0x6e20 <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6e24:	8e e3       	ldi	r24, 0x3E	; 62
    6e26:	90 e0       	ldi	r25, 0x00	; 0
    6e28:	9f bb       	out	0x1f, r25	; 31
    6e2a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6e2c:	e0 9a       	sbi	0x1c, 0	; 28
    6e2e:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    6e30:	f8 01       	movw	r30, r16
    6e32:	01 90       	ld	r0, Z+
    6e34:	00 20       	and	r0, r0
    6e36:	e9 f7       	brne	.-6      	; 0x6e32 <FormatDecimal+0x36>
    6e38:	31 97       	sbiw	r30, 0x01	; 1
    6e3a:	3e 2f       	mov	r19, r30
    6e3c:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    6e3e:	63 17       	cp	r22, r19
    6e40:	b8 f5       	brcc	.+110    	; 0x6eb0 <FormatDecimal+0xb4>
    6e42:	f3 2e       	mov	r15, r19
    6e44:	f6 1a       	sub	r15, r22
    6e46:	b8 01       	movw	r22, r16
    6e48:	d8 01       	movw	r26, r16
    6e4a:	20 e0       	ldi	r18, 0x00	; 0
    6e4c:	90 e0       	ldi	r25, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    6e4e:	ae 01       	movw	r20, r28
    6e50:	4f 5f       	subi	r20, 0xFF	; 255
    6e52:	5f 4f       	sbci	r21, 0xFF	; 255
    6e54:	0e c0       	rjmp	.+28     	; 0x6e72 <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    6e56:	2f 15       	cp	r18, r15
    6e58:	29 f4       	brne	.+10     	; 0x6e64 <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    6e5a:	fa 01       	movw	r30, r20
    6e5c:	e9 0f       	add	r30, r25
    6e5e:	f1 1d       	adc	r31, r1
    6e60:	e0 82       	st	Z, r14
				 iPos++;
    6e62:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    6e64:	fa 01       	movw	r30, r20
    6e66:	e9 0f       	add	r30, r25
    6e68:	f1 1d       	adc	r31, r1
    6e6a:	8d 91       	ld	r24, X+
    6e6c:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    6e6e:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    6e70:	2f 5f       	subi	r18, 0xFF	; 255
    6e72:	23 17       	cp	r18, r19
    6e74:	80 f3       	brcs	.-32     	; 0x6e56 <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    6e76:	9e 01       	movw	r18, r28
    6e78:	2f 5f       	subi	r18, 0xFF	; 255
    6e7a:	3f 4f       	sbci	r19, 0xFF	; 255
    6e7c:	f9 01       	movw	r30, r18
    6e7e:	e9 0f       	add	r30, r25
    6e80:	f1 1d       	adc	r31, r1
    6e82:	10 82       	st	Z, r1
		 
         //uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    6e84:	f9 01       	movw	r30, r18
    6e86:	01 90       	ld	r0, Z+
    6e88:	00 20       	and	r0, r0
    6e8a:	e9 f7       	brne	.-6      	; 0x6e86 <FormatDecimal+0x8a>
    6e8c:	31 97       	sbiw	r30, 0x01	; 1
    6e8e:	9e 2f       	mov	r25, r30
    6e90:	92 1b       	sub	r25, r18
    6e92:	d9 01       	movw	r26, r18
    6e94:	04 c0       	rjmp	.+8      	; 0x6e9e <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    6e96:	8d 91       	ld	r24, X+
    6e98:	fb 01       	movw	r30, r22
    6e9a:	81 93       	st	Z+, r24
    6e9c:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    6e9e:	8a 2f       	mov	r24, r26
    6ea0:	82 1b       	sub	r24, r18
    6ea2:	89 17       	cp	r24, r25
    6ea4:	c0 f3       	brcs	.-16     	; 0x6e96 <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    6ea6:	09 0f       	add	r16, r25
    6ea8:	11 1d       	adc	r17, r1
    6eaa:	f8 01       	movw	r30, r16
    6eac:	10 82       	st	Z, r1
    6eae:	0e c0       	rjmp	.+28     	; 0x6ecc <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    6eb0:	6f 5f       	subi	r22, 0xFF	; 255
    6eb2:	c8 01       	movw	r24, r16
    6eb4:	0e 94 d6 29 	call	0x53ac	; 0x53ac <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    6eb8:	f8 01       	movw	r30, r16
    6eba:	01 90       	ld	r0, Z+
    6ebc:	00 20       	and	r0, r0
    6ebe:	e9 f7       	brne	.-6      	; 0x6eba <FormatDecimal+0xbe>
    6ec0:	31 97       	sbiw	r30, 0x01	; 1
    6ec2:	3e 2f       	mov	r19, r30
    6ec4:	30 1b       	sub	r19, r16
    6ec6:	ff 24       	eor	r15, r15
    6ec8:	f3 94       	inc	r15
    6eca:	bd cf       	rjmp	.-134    	; 0x6e46 <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //uart_print(1,1,strRawData); 
}
    6ecc:	64 96       	adiw	r28, 0x14	; 20
    6ece:	0f b6       	in	r0, 0x3f	; 63
    6ed0:	f8 94       	cli
    6ed2:	de bf       	out	0x3e, r29	; 62
    6ed4:	0f be       	out	0x3f, r0	; 63
    6ed6:	cd bf       	out	0x3d, r28	; 61
    6ed8:	cf 91       	pop	r28
    6eda:	df 91       	pop	r29
    6edc:	1f 91       	pop	r17
    6ede:	0f 91       	pop	r16
    6ee0:	ff 90       	pop	r15
    6ee2:	ef 90       	pop	r14
    6ee4:	08 95       	ret

00006ee6 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    6ee6:	68 2f       	mov	r22, r24
    6ee8:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    6eea:	0e 94 fe 36 	call	0x6dfc	; 0x6dfc <FormatDecimal>
}
    6eee:	08 95       	ret

00006ef0 <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    6ef0:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6ef2:	e1 99       	sbic	0x1c, 1	; 28
    6ef4:	fe cf       	rjmp	.-4      	; 0x6ef2 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6ef6:	8c e3       	ldi	r24, 0x3C	; 60
    6ef8:	90 e0       	ldi	r25, 0x00	; 0
    6efa:	9f bb       	out	0x1f, r25	; 31
    6efc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6efe:	e0 9a       	sbi	0x1c, 0	; 28
    6f00:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6f02:	c9 01       	movw	r24, r18
    6f04:	0e 94 fe 36 	call	0x6dfc	; 0x6dfc <FormatDecimal>
}
    6f08:	08 95       	ret

00006f0a <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    6f0a:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6f0c:	e1 99       	sbic	0x1c, 1	; 28
    6f0e:	fe cf       	rjmp	.-4      	; 0x6f0c <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6f10:	8d e3       	ldi	r24, 0x3D	; 61
    6f12:	90 e0       	ldi	r25, 0x00	; 0
    6f14:	9f bb       	out	0x1f, r25	; 31
    6f16:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6f18:	e0 9a       	sbi	0x1c, 0	; 28
    6f1a:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    6f1c:	c9 01       	movw	r24, r18
    6f1e:	0e 94 fe 36 	call	0x6dfc	; 0x6dfc <FormatDecimal>
}
    6f22:	08 95       	ret

00006f24 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    6f24:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6f26:	e1 99       	sbic	0x1c, 1	; 28
    6f28:	fe cf       	rjmp	.-4      	; 0x6f26 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6f2a:	8a e3       	ldi	r24, 0x3A	; 58
    6f2c:	90 e0       	ldi	r25, 0x00	; 0
    6f2e:	9f bb       	out	0x1f, r25	; 31
    6f30:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6f32:	e0 9a       	sbi	0x1c, 0	; 28
    6f34:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6f36:	c9 01       	movw	r24, r18
    6f38:	0e 94 fe 36 	call	0x6dfc	; 0x6dfc <FormatDecimal>
}
    6f3c:	08 95       	ret

00006f3e <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    6f3e:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6f40:	e1 99       	sbic	0x1c, 1	; 28
    6f42:	fe cf       	rjmp	.-4      	; 0x6f40 <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6f44:	8b e3       	ldi	r24, 0x3B	; 59
    6f46:	90 e0       	ldi	r25, 0x00	; 0
    6f48:	9f bb       	out	0x1f, r25	; 31
    6f4a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6f4c:	e0 9a       	sbi	0x1c, 0	; 28
    6f4e:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    6f50:	c9 01       	movw	r24, r18
    6f52:	0e 94 fe 36 	call	0x6dfc	; 0x6dfc <FormatDecimal>
}
    6f56:	08 95       	ret

00006f58 <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    6f58:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6f5a:	e1 99       	sbic	0x1c, 1	; 28
    6f5c:	fe cf       	rjmp	.-4      	; 0x6f5a <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6f5e:	89 e3       	ldi	r24, 0x39	; 57
    6f60:	90 e0       	ldi	r25, 0x00	; 0
    6f62:	9f bb       	out	0x1f, r25	; 31
    6f64:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6f66:	e0 9a       	sbi	0x1c, 0	; 28
    6f68:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    6f6a:	c9 01       	movw	r24, r18
    6f6c:	0e 94 fe 36 	call	0x6dfc	; 0x6dfc <FormatDecimal>
}
    6f70:	08 95       	ret

00006f72 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    6f72:	2f 92       	push	r2
    6f74:	3f 92       	push	r3
    6f76:	4f 92       	push	r4
    6f78:	5f 92       	push	r5
    6f7a:	6f 92       	push	r6
    6f7c:	7f 92       	push	r7
    6f7e:	8f 92       	push	r8
    6f80:	9f 92       	push	r9
    6f82:	af 92       	push	r10
    6f84:	bf 92       	push	r11
    6f86:	cf 92       	push	r12
    6f88:	df 92       	push	r13
    6f8a:	ef 92       	push	r14
    6f8c:	ff 92       	push	r15
    6f8e:	0f 93       	push	r16
    6f90:	1f 93       	push	r17
    6f92:	df 93       	push	r29
    6f94:	cf 93       	push	r28
    6f96:	cd b7       	in	r28, 0x3d	; 61
    6f98:	de b7       	in	r29, 0x3e	; 62
    6f9a:	c8 5f       	subi	r28, 0xF8	; 248
    6f9c:	d0 40       	sbci	r29, 0x00	; 0
    6f9e:	0f b6       	in	r0, 0x3f	; 63
    6fa0:	f8 94       	cli
    6fa2:	de bf       	out	0x3e, r29	; 62
    6fa4:	0f be       	out	0x3f, r0	; 63
    6fa6:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char iTotal;//,PadLength;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    6fa8:	10 91 e8 01 	lds	r17, 0x01E8
    6fac:	16 30       	cpi	r17, 0x06	; 6
    6fae:	09 f4       	brne	.+2      	; 0x6fb2 <systemGenerateReport+0x40>
    6fb0:	5d c2       	rjmp	.+1210   	; 0x746c <systemGenerateReport+0x4fa>
    6fb2:	17 30       	cpi	r17, 0x07	; 7
    6fb4:	98 f4       	brcc	.+38     	; 0x6fdc <systemGenerateReport+0x6a>
    6fb6:	12 30       	cpi	r17, 0x02	; 2
    6fb8:	09 f4       	brne	.+2      	; 0x6fbc <systemGenerateReport+0x4a>
    6fba:	a7 c0       	rjmp	.+334    	; 0x710a <systemGenerateReport+0x198>
    6fbc:	13 30       	cpi	r17, 0x03	; 3
    6fbe:	38 f4       	brcc	.+14     	; 0x6fce <systemGenerateReport+0x5c>
    6fc0:	11 23       	and	r17, r17
    6fc2:	31 f1       	breq	.+76     	; 0x7010 <systemGenerateReport+0x9e>
    6fc4:	11 30       	cpi	r17, 0x01	; 1
    6fc6:	11 f0       	breq	.+4      	; 0x6fcc <systemGenerateReport+0x5a>
    6fc8:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <systemGenerateReport+0x1632>
    6fcc:	2d c0       	rjmp	.+90     	; 0x7028 <systemGenerateReport+0xb6>
    6fce:	14 30       	cpi	r17, 0x04	; 4
    6fd0:	09 f4       	brne	.+2      	; 0x6fd4 <systemGenerateReport+0x62>
    6fd2:	c8 c1       	rjmp	.+912    	; 0x7364 <systemGenerateReport+0x3f2>
    6fd4:	15 30       	cpi	r17, 0x05	; 5
    6fd6:	08 f0       	brcs	.+2      	; 0x6fda <systemGenerateReport+0x68>
    6fd8:	4c c7       	rjmp	.+3736   	; 0x7e72 <systemGenerateReport+0xf00>
    6fda:	bb c1       	rjmp	.+886    	; 0x7352 <systemGenerateReport+0x3e0>
    6fdc:	19 30       	cpi	r17, 0x09	; 9
    6fde:	09 f4       	brne	.+2      	; 0x6fe2 <systemGenerateReport+0x70>
    6fe0:	48 c7       	rjmp	.+3728   	; 0x7e72 <systemGenerateReport+0xf00>
    6fe2:	1a 30       	cpi	r17, 0x0A	; 10
    6fe4:	40 f4       	brcc	.+16     	; 0x6ff6 <systemGenerateReport+0x84>
    6fe6:	17 30       	cpi	r17, 0x07	; 7
    6fe8:	09 f4       	brne	.+2      	; 0x6fec <systemGenerateReport+0x7a>
    6fea:	aa c2       	rjmp	.+1364   	; 0x7540 <systemGenerateReport+0x5ce>
    6fec:	18 30       	cpi	r17, 0x08	; 8
    6fee:	11 f0       	breq	.+4      	; 0x6ff4 <systemGenerateReport+0x82>
    6ff0:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <systemGenerateReport+0x1632>
    6ff4:	b3 c2       	rjmp	.+1382   	; 0x755c <systemGenerateReport+0x5ea>
    6ff6:	1b 30       	cpi	r17, 0x0B	; 11
    6ff8:	11 f4       	brne	.+4      	; 0x6ffe <systemGenerateReport+0x8c>
    6ffa:	0c 94 c5 42 	jmp	0x858a	; 0x858a <systemGenerateReport+0x1618>
    6ffe:	1b 30       	cpi	r17, 0x0B	; 11
    7000:	08 f4       	brcc	.+2      	; 0x7004 <systemGenerateReport+0x92>
    7002:	3e c7       	rjmp	.+3708   	; 0x7e80 <systemGenerateReport+0xf0e>
    7004:	1c 30       	cpi	r17, 0x0C	; 12
    7006:	11 f0       	breq	.+4      	; 0x700c <systemGenerateReport+0x9a>
    7008:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <systemGenerateReport+0x1632>
    700c:	0c 94 cd 42 	jmp	0x859a	; 0x859a <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    7010:	80 91 86 01 	lds	r24, 0x0186
    7014:	81 30       	cpi	r24, 0x01	; 1
    7016:	11 f0       	breq	.+4      	; 0x701c <systemGenerateReport+0xaa>
    7018:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    701c:	10 92 86 01 	sts	0x0186, r1
			  IsFinishPrintingTotalizer=False;
    7020:	10 92 87 01 	sts	0x0187, r1
    7024:	0c 94 ca 42 	jmp	0x8594	; 0x8594 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    7028:	10 93 e7 01 	sts	0x01E7, r17
		  xNozzle=1;
    702c:	10 93 e6 01 	sts	0x01E6, r17
		  RepPos=0;
    7030:	10 92 d7 01 	sts	0x01D7, r1
    7034:	10 92 d6 01 	sts	0x01D6, r1
    7038:	ec ee       	ldi	r30, 0xEC	; 236
    703a:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    703c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    703e:	85 e0       	ldi	r24, 0x05	; 5
    7040:	ed 37       	cpi	r30, 0x7D	; 125
    7042:	f8 07       	cpc	r31, r24
    7044:	d9 f7       	brne	.-10     	; 0x703c <systemGenerateReport+0xca>
    7046:	fe 01       	movw	r30, r28
    7048:	eb 55       	subi	r30, 0x5B	; 91
    704a:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    704c:	ce 01       	movw	r24, r28
    704e:	8b 50       	subi	r24, 0x0B	; 11
    7050:	9f 4f       	sbci	r25, 0xFF	; 255
    7052:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7054:	e8 17       	cp	r30, r24
    7056:	f9 07       	cpc	r31, r25
    7058:	e1 f7       	brne	.-8      	; 0x7052 <systemGenerateReport+0xe0>
    705a:	fe 01       	movw	r30, r28
    705c:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    705e:	cf 01       	movw	r24, r30
    7060:	0f 96       	adiw	r24, 0x0f	; 15
    7062:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7064:	e8 17       	cp	r30, r24
    7066:	f9 07       	cpc	r31, r25
    7068:	e1 f7       	brne	.-8      	; 0x7062 <systemGenerateReport+0xf0>
    706a:	fe 01       	movw	r30, r28
    706c:	ea 5b       	subi	r30, 0xBA	; 186
    706e:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7070:	cf 01       	movw	r24, r30
    7072:	0f 96       	adiw	r24, 0x0f	; 15
    7074:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7076:	e8 17       	cp	r30, r24
    7078:	f9 07       	cpc	r31, r25
    707a:	e1 f7       	brne	.-8      	; 0x7074 <systemGenerateReport+0x102>
    707c:	e7 ef       	ldi	r30, 0xF7	; 247
    707e:	f7 e0       	ldi	r31, 0x07	; 7
	     strMemory[i]=data;
    7080:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7082:	98 e0       	ldi	r25, 0x08	; 8
    7084:	eb 30       	cpi	r30, 0x0B	; 11
    7086:	f9 07       	cpc	r31, r25
    7088:	d9 f7       	brne	.-10     	; 0x7080 <systemGenerateReport+0x10e>
    708a:	e8 ea       	ldi	r30, 0xA8	; 168
    708c:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
    708e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7090:	a8 e0       	ldi	r26, 0x08	; 8
    7092:	ec 3b       	cpi	r30, 0xBC	; 188
    7094:	fa 07       	cpc	r31, r26
    7096:	d9 f7       	brne	.-10     	; 0x708e <systemGenerateReport+0x11c>
    7098:	ed e2       	ldi	r30, 0x2D	; 45
    709a:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    709c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    709e:	bc e0       	ldi	r27, 0x0C	; 12
    70a0:	ec 33       	cpi	r30, 0x3C	; 60
    70a2:	fb 07       	cpc	r31, r27
    70a4:	d9 f7       	brne	.-10     	; 0x709c <systemGenerateReport+0x12a>
    70a6:	e5 e0       	ldi	r30, 0x05	; 5
    70a8:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    70aa:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    70ac:	89 e0       	ldi	r24, 0x09	; 9
    70ae:	e4 31       	cpi	r30, 0x14	; 20
    70b0:	f8 07       	cpc	r31, r24
    70b2:	d9 f7       	brne	.-10     	; 0x70aa <systemGenerateReport+0x138>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    70b4:	e1 99       	sbic	0x1c, 1	; 28
    70b6:	fe cf       	rjmp	.-4      	; 0x70b4 <systemGenerateReport+0x142>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    70b8:	8f e3       	ldi	r24, 0x3F	; 63
    70ba:	91 e0       	ldi	r25, 0x01	; 1
    70bc:	9f bb       	out	0x1f, r25	; 31
    70be:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    70c0:	e0 9a       	sbi	0x1c, 0	; 28
    70c2:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    70c4:	00 d0       	rcall	.+0      	; 0x70c6 <systemGenerateReport+0x154>
    70c6:	00 d0       	rcall	.+0      	; 0x70c8 <systemGenerateReport+0x156>
    70c8:	00 d0       	rcall	.+0      	; 0x70ca <systemGenerateReport+0x158>
    70ca:	ed b7       	in	r30, 0x3d	; 61
    70cc:	fe b7       	in	r31, 0x3e	; 62
    70ce:	31 96       	adiw	r30, 0x01	; 1
    70d0:	88 e6       	ldi	r24, 0x68	; 104
    70d2:	9c e0       	ldi	r25, 0x0C	; 12
    70d4:	ad b7       	in	r26, 0x3d	; 61
    70d6:	be b7       	in	r27, 0x3e	; 62
    70d8:	12 96       	adiw	r26, 0x02	; 2
    70da:	9c 93       	st	X, r25
    70dc:	8e 93       	st	-X, r24
    70de:	11 97       	sbiw	r26, 0x01	; 1
    70e0:	85 e0       	ldi	r24, 0x05	; 5
    70e2:	97 e0       	ldi	r25, 0x07	; 7
    70e4:	93 83       	std	Z+3, r25	; 0x03
    70e6:	82 83       	std	Z+2, r24	; 0x02
    70e8:	24 83       	std	Z+4, r18	; 0x04
    70ea:	15 82       	std	Z+5, r1	; 0x05
    70ec:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    70f0:	82 e0       	ldi	r24, 0x02	; 2
    70f2:	80 93 e8 01 	sts	0x01E8, r24
    70f6:	ed b7       	in	r30, 0x3d	; 61
    70f8:	fe b7       	in	r31, 0x3e	; 62
    70fa:	36 96       	adiw	r30, 0x06	; 6
    70fc:	0f b6       	in	r0, 0x3f	; 63
    70fe:	f8 94       	cli
    7100:	fe bf       	out	0x3e, r31	; 62
    7102:	0f be       	out	0x3f, r0	; 63
    7104:	ed bf       	out	0x3d, r30	; 61
    7106:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    710a:	ce 01       	movw	r24, r28
    710c:	8b 5a       	subi	r24, 0xAB	; 171
    710e:	9f 4f       	sbci	r25, 0xFF	; 255
    7110:	63 e4       	ldi	r22, 0x43	; 67
    7112:	78 e0       	ldi	r23, 0x08	; 8
    7114:	44 e1       	ldi	r20, 0x14	; 20
    7116:	50 e0       	ldi	r21, 0x00	; 0
    7118:	22 ed       	ldi	r18, 0xD2	; 210
    711a:	33 e1       	ldi	r19, 0x13	; 19
    711c:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7120:	81 e0       	ldi	r24, 0x01	; 1
    7122:	6c ee       	ldi	r22, 0xEC	; 236
    7124:	73 e0       	ldi	r23, 0x03	; 3
    7126:	41 e0       	ldi	r20, 0x01	; 1
    7128:	26 ed       	ldi	r18, 0xD6	; 214
    712a:	31 e0       	ldi	r19, 0x01	; 1
    712c:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7130:	8b e0       	ldi	r24, 0x0B	; 11
    7132:	6c ee       	ldi	r22, 0xEC	; 236
    7134:	73 e0       	ldi	r23, 0x03	; 3
    7136:	4a e2       	ldi	r20, 0x2A	; 42
    7138:	26 ed       	ldi	r18, 0xD6	; 214
    713a:	31 e0       	ldi	r19, 0x01	; 1
    713c:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7140:	83 e0       	ldi	r24, 0x03	; 3
    7142:	6c ee       	ldi	r22, 0xEC	; 236
    7144:	73 e0       	ldi	r23, 0x03	; 3
    7146:	41 e0       	ldi	r20, 0x01	; 1
    7148:	26 ed       	ldi	r18, 0xD6	; 214
    714a:	31 e0       	ldi	r19, 0x01	; 1
    714c:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7150:	8c e0       	ldi	r24, 0x0C	; 12
    7152:	6c ee       	ldi	r22, 0xEC	; 236
    7154:	73 e0       	ldi	r23, 0x03	; 3
    7156:	41 e0       	ldi	r20, 0x01	; 1
    7158:	26 ed       	ldi	r18, 0xD6	; 214
    715a:	31 e0       	ldi	r19, 0x01	; 1
    715c:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    7160:	00 d0       	rcall	.+0      	; 0x7162 <systemGenerateReport+0x1f0>
    7162:	00 d0       	rcall	.+0      	; 0x7164 <systemGenerateReport+0x1f2>
    7164:	00 d0       	rcall	.+0      	; 0x7166 <systemGenerateReport+0x1f4>
    7166:	ed b7       	in	r30, 0x3d	; 61
    7168:	fe b7       	in	r31, 0x3e	; 62
    716a:	31 96       	adiw	r30, 0x01	; 1
    716c:	8e 01       	movw	r16, r28
    716e:	0b 55       	subi	r16, 0x5B	; 91
    7170:	1f 4f       	sbci	r17, 0xFF	; 255
    7172:	ad b7       	in	r26, 0x3d	; 61
    7174:	be b7       	in	r27, 0x3e	; 62
    7176:	12 96       	adiw	r26, 0x02	; 2
    7178:	1c 93       	st	X, r17
    717a:	0e 93       	st	-X, r16
    717c:	11 97       	sbiw	r26, 0x01	; 1
    717e:	8f ed       	ldi	r24, 0xDF	; 223
    7180:	96 e0       	ldi	r25, 0x06	; 6
    7182:	93 83       	std	Z+3, r25	; 0x03
    7184:	82 83       	std	Z+2, r24	; 0x02
    7186:	88 e6       	ldi	r24, 0x68	; 104
    7188:	9c e0       	ldi	r25, 0x0C	; 12
    718a:	95 83       	std	Z+5, r25	; 0x05
    718c:	84 83       	std	Z+4, r24	; 0x04
    718e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    7192:	ed b7       	in	r30, 0x3d	; 61
    7194:	fe b7       	in	r31, 0x3e	; 62
    7196:	36 96       	adiw	r30, 0x06	; 6
    7198:	0f b6       	in	r0, 0x3f	; 63
    719a:	f8 94       	cli
    719c:	fe bf       	out	0x3e, r31	; 62
    719e:	0f be       	out	0x3f, r0	; 63
    71a0:	ed bf       	out	0x3d, r30	; 61
    71a2:	c8 01       	movw	r24, r16
    71a4:	6c ee       	ldi	r22, 0xEC	; 236
    71a6:	73 e0       	ldi	r23, 0x03	; 3
    71a8:	46 ed       	ldi	r20, 0xD6	; 214
    71aa:	51 e0       	ldi	r21, 0x01	; 1
    71ac:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    71b0:	84 e0       	ldi	r24, 0x04	; 4
    71b2:	6c ee       	ldi	r22, 0xEC	; 236
    71b4:	73 e0       	ldi	r23, 0x03	; 3
    71b6:	41 e0       	ldi	r20, 0x01	; 1
    71b8:	26 ed       	ldi	r18, 0xD6	; 214
    71ba:	31 e0       	ldi	r19, 0x01	; 1
    71bc:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    71c0:	8b e0       	ldi	r24, 0x0B	; 11
    71c2:	6c ee       	ldi	r22, 0xEC	; 236
    71c4:	73 e0       	ldi	r23, 0x03	; 3
    71c6:	4a e2       	ldi	r20, 0x2A	; 42
    71c8:	26 ed       	ldi	r18, 0xD6	; 214
    71ca:	31 e0       	ldi	r19, 0x01	; 1
    71cc:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    71d0:	86 e0       	ldi	r24, 0x06	; 6
    71d2:	6c ee       	ldi	r22, 0xEC	; 236
    71d4:	73 e0       	ldi	r23, 0x03	; 3
    71d6:	41 e0       	ldi	r20, 0x01	; 1
    71d8:	26 ed       	ldi	r18, 0xD6	; 214
    71da:	31 e0       	ldi	r19, 0x01	; 1
    71dc:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    71e0:	8c e0       	ldi	r24, 0x0C	; 12
    71e2:	6c ee       	ldi	r22, 0xEC	; 236
    71e4:	73 e0       	ldi	r23, 0x03	; 3
    71e6:	41 e0       	ldi	r20, 0x01	; 1
    71e8:	26 ed       	ldi	r18, 0xD6	; 214
    71ea:	31 e0       	ldi	r19, 0x01	; 1
    71ec:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    71f0:	e1 99       	sbic	0x1c, 1	; 28
    71f2:	fe cf       	rjmp	.-4      	; 0x71f0 <systemGenerateReport+0x27e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    71f4:	80 e0       	ldi	r24, 0x00	; 0
    71f6:	90 e0       	ldi	r25, 0x00	; 0
    71f8:	9f bb       	out	0x1f, r25	; 31
    71fa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    71fc:	e0 9a       	sbi	0x1c, 0	; 28
    71fe:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    7200:	00 d0       	rcall	.+0      	; 0x7202 <systemGenerateReport+0x290>
    7202:	00 d0       	rcall	.+0      	; 0x7204 <systemGenerateReport+0x292>
    7204:	00 d0       	rcall	.+0      	; 0x7206 <systemGenerateReport+0x294>
    7206:	ed b7       	in	r30, 0x3d	; 61
    7208:	fe b7       	in	r31, 0x3e	; 62
    720a:	31 96       	adiw	r30, 0x01	; 1
    720c:	8e 01       	movw	r16, r28
    720e:	0b 55       	subi	r16, 0x5B	; 91
    7210:	1f 4f       	sbci	r17, 0xFF	; 255
    7212:	ad b7       	in	r26, 0x3d	; 61
    7214:	be b7       	in	r27, 0x3e	; 62
    7216:	12 96       	adiw	r26, 0x02	; 2
    7218:	1c 93       	st	X, r17
    721a:	0e 93       	st	-X, r16
    721c:	11 97       	sbiw	r26, 0x01	; 1
    721e:	89 eb       	ldi	r24, 0xB9	; 185
    7220:	96 e0       	ldi	r25, 0x06	; 6
    7222:	93 83       	std	Z+3, r25	; 0x03
    7224:	82 83       	std	Z+2, r24	; 0x02
    7226:	24 83       	std	Z+4, r18	; 0x04
    7228:	15 82       	std	Z+5, r1	; 0x05
    722a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    722e:	ed b7       	in	r30, 0x3d	; 61
    7230:	fe b7       	in	r31, 0x3e	; 62
    7232:	36 96       	adiw	r30, 0x06	; 6
    7234:	0f b6       	in	r0, 0x3f	; 63
    7236:	f8 94       	cli
    7238:	fe bf       	out	0x3e, r31	; 62
    723a:	0f be       	out	0x3f, r0	; 63
    723c:	ed bf       	out	0x3d, r30	; 61
    723e:	c8 01       	movw	r24, r16
    7240:	6c ee       	ldi	r22, 0xEC	; 236
    7242:	73 e0       	ldi	r23, 0x03	; 3
    7244:	46 ed       	ldi	r20, 0xD6	; 214
    7246:	51 e0       	ldi	r21, 0x01	; 1
    7248:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    724c:	00 d0       	rcall	.+0      	; 0x724e <systemGenerateReport+0x2dc>
    724e:	00 d0       	rcall	.+0      	; 0x7250 <systemGenerateReport+0x2de>
    7250:	00 d0       	rcall	.+0      	; 0x7252 <systemGenerateReport+0x2e0>
    7252:	ed b7       	in	r30, 0x3d	; 61
    7254:	fe b7       	in	r31, 0x3e	; 62
    7256:	31 96       	adiw	r30, 0x01	; 1
    7258:	ad b7       	in	r26, 0x3d	; 61
    725a:	be b7       	in	r27, 0x3e	; 62
    725c:	12 96       	adiw	r26, 0x02	; 2
    725e:	1c 93       	st	X, r17
    7260:	0e 93       	st	-X, r16
    7262:	11 97       	sbiw	r26, 0x01	; 1
    7264:	87 ea       	ldi	r24, 0xA7	; 167
    7266:	96 e0       	ldi	r25, 0x06	; 6
    7268:	93 83       	std	Z+3, r25	; 0x03
    726a:	82 83       	std	Z+2, r24	; 0x02
    726c:	ce 01       	movw	r24, r28
    726e:	8b 5a       	subi	r24, 0xAB	; 171
    7270:	9f 4f       	sbci	r25, 0xFF	; 255
    7272:	95 83       	std	Z+5, r25	; 0x05
    7274:	84 83       	std	Z+4, r24	; 0x04
    7276:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    727a:	ed b7       	in	r30, 0x3d	; 61
    727c:	fe b7       	in	r31, 0x3e	; 62
    727e:	36 96       	adiw	r30, 0x06	; 6
    7280:	0f b6       	in	r0, 0x3f	; 63
    7282:	f8 94       	cli
    7284:	fe bf       	out	0x3e, r31	; 62
    7286:	0f be       	out	0x3f, r0	; 63
    7288:	ed bf       	out	0x3d, r30	; 61
    728a:	c8 01       	movw	r24, r16
    728c:	6c ee       	ldi	r22, 0xEC	; 236
    728e:	73 e0       	ldi	r23, 0x03	; 3
    7290:	46 ed       	ldi	r20, 0xD6	; 214
    7292:	51 e0       	ldi	r21, 0x01	; 1
    7294:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    7298:	00 d0       	rcall	.+0      	; 0x729a <systemGenerateReport+0x328>
    729a:	00 d0       	rcall	.+0      	; 0x729c <systemGenerateReport+0x32a>
    729c:	00 d0       	rcall	.+0      	; 0x729e <systemGenerateReport+0x32c>
    729e:	ed b7       	in	r30, 0x3d	; 61
    72a0:	fe b7       	in	r31, 0x3e	; 62
    72a2:	31 96       	adiw	r30, 0x01	; 1
    72a4:	ad b7       	in	r26, 0x3d	; 61
    72a6:	be b7       	in	r27, 0x3e	; 62
    72a8:	12 96       	adiw	r26, 0x02	; 2
    72aa:	1c 93       	st	X, r17
    72ac:	0e 93       	st	-X, r16
    72ae:	11 97       	sbiw	r26, 0x01	; 1
    72b0:	85 e9       	ldi	r24, 0x95	; 149
    72b2:	96 e0       	ldi	r25, 0x06	; 6
    72b4:	93 83       	std	Z+3, r25	; 0x03
    72b6:	82 83       	std	Z+2, r24	; 0x02
    72b8:	8e e8       	ldi	r24, 0x8E	; 142
    72ba:	97 e0       	ldi	r25, 0x07	; 7
    72bc:	95 83       	std	Z+5, r25	; 0x05
    72be:	84 83       	std	Z+4, r24	; 0x04
    72c0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    72c4:	ed b7       	in	r30, 0x3d	; 61
    72c6:	fe b7       	in	r31, 0x3e	; 62
    72c8:	36 96       	adiw	r30, 0x06	; 6
    72ca:	0f b6       	in	r0, 0x3f	; 63
    72cc:	f8 94       	cli
    72ce:	fe bf       	out	0x3e, r31	; 62
    72d0:	0f be       	out	0x3f, r0	; 63
    72d2:	ed bf       	out	0x3d, r30	; 61
    72d4:	c8 01       	movw	r24, r16
    72d6:	6c ee       	ldi	r22, 0xEC	; 236
    72d8:	73 e0       	ldi	r23, 0x03	; 3
    72da:	46 ed       	ldi	r20, 0xD6	; 214
    72dc:	51 e0       	ldi	r21, 0x01	; 1
    72de:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    72e2:	87 e0       	ldi	r24, 0x07	; 7
    72e4:	6c ee       	ldi	r22, 0xEC	; 236
    72e6:	73 e0       	ldi	r23, 0x03	; 3
    72e8:	41 e0       	ldi	r20, 0x01	; 1
    72ea:	26 ed       	ldi	r18, 0xD6	; 214
    72ec:	31 e0       	ldi	r19, 0x01	; 1
    72ee:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    72f2:	8b e0       	ldi	r24, 0x0B	; 11
    72f4:	6c ee       	ldi	r22, 0xEC	; 236
    72f6:	73 e0       	ldi	r23, 0x03	; 3
    72f8:	4a e2       	ldi	r20, 0x2A	; 42
    72fa:	26 ed       	ldi	r18, 0xD6	; 214
    72fc:	31 e0       	ldi	r19, 0x01	; 1
    72fe:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7302:	89 e0       	ldi	r24, 0x09	; 9
    7304:	6c ee       	ldi	r22, 0xEC	; 236
    7306:	73 e0       	ldi	r23, 0x03	; 3
    7308:	41 e0       	ldi	r20, 0x01	; 1
    730a:	26 ed       	ldi	r18, 0xD6	; 214
    730c:	31 e0       	ldi	r19, 0x01	; 1
    730e:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7312:	8c e0       	ldi	r24, 0x0C	; 12
    7314:	6c ee       	ldi	r22, 0xEC	; 236
    7316:	73 e0       	ldi	r23, 0x03	; 3
    7318:	41 e0       	ldi	r20, 0x01	; 1
    731a:	26 ed       	ldi	r18, 0xD6	; 214
    731c:	31 e0       	ldi	r19, 0x01	; 1
    731e:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    7322:	88 ed       	ldi	r24, 0xD8	; 216
    7324:	91 e0       	ldi	r25, 0x01	; 1
    7326:	0e 94 c9 25 	call	0x4b92	; 0x4b92 <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    732a:	80 e8       	ldi	r24, 0x80	; 128
    732c:	80 93 b5 01 	sts	0x01B5, r24
		  LengthMessage81=RepPos+1;
    7330:	80 91 d6 01 	lds	r24, 0x01D6
    7334:	90 91 d7 01 	lds	r25, 0x01D7
    7338:	01 96       	adiw	r24, 0x01	; 1
    733a:	90 93 8e 01 	sts	0x018E, r25
    733e:	80 93 8d 01 	sts	0x018D, r24
		  IsFreePrinting=True;
    7342:	81 e0       	ldi	r24, 0x01	; 1
    7344:	80 93 a8 01 	sts	0x01A8, r24
          IsBusyFreePrinting=True;
    7348:	80 93 b4 01 	sts	0x01B4, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    734c:	83 e0       	ldi	r24, 0x03	; 3
    734e:	0c 94 ca 42 	jmp	0x8594	; 0x8594 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    7352:	80 91 b4 01 	lds	r24, 0x01B4
    7356:	88 23       	and	r24, r24
    7358:	11 f0       	breq	.+4      	; 0x735e <systemGenerateReport+0x3ec>
    735a:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    735e:	84 e0       	ldi	r24, 0x04	; 4
    7360:	0c 94 ca 42 	jmp	0x8594	; 0x8594 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    7364:	10 92 d7 01 	sts	0x01D7, r1
    7368:	10 92 d6 01 	sts	0x01D6, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    736c:	81 e0       	ldi	r24, 0x01	; 1
    736e:	6c ee       	ldi	r22, 0xEC	; 236
    7370:	73 e0       	ldi	r23, 0x03	; 3
    7372:	41 e0       	ldi	r20, 0x01	; 1
    7374:	26 ed       	ldi	r18, 0xD6	; 214
    7376:	31 e0       	ldi	r19, 0x01	; 1
    7378:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    737c:	8b e0       	ldi	r24, 0x0B	; 11
    737e:	6c ee       	ldi	r22, 0xEC	; 236
    7380:	73 e0       	ldi	r23, 0x03	; 3
    7382:	4a e2       	ldi	r20, 0x2A	; 42
    7384:	26 ed       	ldi	r18, 0xD6	; 214
    7386:	31 e0       	ldi	r19, 0x01	; 1
    7388:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    738c:	83 e0       	ldi	r24, 0x03	; 3
    738e:	6c ee       	ldi	r22, 0xEC	; 236
    7390:	73 e0       	ldi	r23, 0x03	; 3
    7392:	41 e0       	ldi	r20, 0x01	; 1
    7394:	26 ed       	ldi	r18, 0xD6	; 214
    7396:	31 e0       	ldi	r19, 0x01	; 1
    7398:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    739c:	8c e0       	ldi	r24, 0x0C	; 12
    739e:	6c ee       	ldi	r22, 0xEC	; 236
    73a0:	73 e0       	ldi	r23, 0x03	; 3
    73a2:	41 e0       	ldi	r20, 0x01	; 1
    73a4:	26 ed       	ldi	r18, 0xD6	; 214
    73a6:	31 e0       	ldi	r19, 0x01	; 1
    73a8:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    73ac:	e1 99       	sbic	0x1c, 1	; 28
    73ae:	fe cf       	rjmp	.-4      	; 0x73ac <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    73b0:	81 ec       	ldi	r24, 0xC1	; 193
    73b2:	93 e0       	ldi	r25, 0x03	; 3
    73b4:	9f bb       	out	0x1f, r25	; 31
    73b6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73b8:	e0 9a       	sbi	0x1c, 0	; 28
    73ba:	8d b3       	in	r24, 0x1d	; 29
    73bc:	9e 01       	movw	r18, r28
    73be:	2b 55       	subi	r18, 0x5B	; 91
    73c0:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    73c2:	81 30       	cpi	r24, 0x01	; 1
    73c4:	79 f4       	brne	.+30     	; 0x73e4 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    73c6:	00 d0       	rcall	.+0      	; 0x73c8 <systemGenerateReport+0x456>
    73c8:	00 d0       	rcall	.+0      	; 0x73ca <systemGenerateReport+0x458>
    73ca:	ad b7       	in	r26, 0x3d	; 61
    73cc:	be b7       	in	r27, 0x3e	; 62
    73ce:	12 96       	adiw	r26, 0x02	; 2
    73d0:	3c 93       	st	X, r19
    73d2:	2e 93       	st	-X, r18
    73d4:	11 97       	sbiw	r26, 0x01	; 1
    73d6:	8e e6       	ldi	r24, 0x6E	; 110
    73d8:	96 e0       	ldi	r25, 0x06	; 6
    73da:	14 96       	adiw	r26, 0x04	; 4
    73dc:	9c 93       	st	X, r25
    73de:	8e 93       	st	-X, r24
    73e0:	13 97       	sbiw	r26, 0x03	; 3
    73e2:	0a c0       	rjmp	.+20     	; 0x73f8 <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    73e4:	00 d0       	rcall	.+0      	; 0x73e6 <systemGenerateReport+0x474>
    73e6:	00 d0       	rcall	.+0      	; 0x73e8 <systemGenerateReport+0x476>
    73e8:	ed b7       	in	r30, 0x3d	; 61
    73ea:	fe b7       	in	r31, 0x3e	; 62
    73ec:	32 83       	std	Z+2, r19	; 0x02
    73ee:	21 83       	std	Z+1, r18	; 0x01
    73f0:	87 e4       	ldi	r24, 0x47	; 71
    73f2:	96 e0       	ldi	r25, 0x06	; 6
    73f4:	94 83       	std	Z+4, r25	; 0x04
    73f6:	83 83       	std	Z+3, r24	; 0x03
    73f8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    73fc:	0f 90       	pop	r0
    73fe:	0f 90       	pop	r0
    7400:	0f 90       	pop	r0
    7402:	0f 90       	pop	r0
    7404:	ce 01       	movw	r24, r28
    7406:	8b 55       	subi	r24, 0x5B	; 91
    7408:	9f 4f       	sbci	r25, 0xFF	; 255
    740a:	6c ee       	ldi	r22, 0xEC	; 236
    740c:	73 e0       	ldi	r23, 0x03	; 3
    740e:	46 ed       	ldi	r20, 0xD6	; 214
    7410:	51 e0       	ldi	r21, 0x01	; 1
    7412:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    7416:	87 e0       	ldi	r24, 0x07	; 7
    7418:	6c ee       	ldi	r22, 0xEC	; 236
    741a:	73 e0       	ldi	r23, 0x03	; 3
    741c:	41 e0       	ldi	r20, 0x01	; 1
    741e:	26 ed       	ldi	r18, 0xD6	; 214
    7420:	31 e0       	ldi	r19, 0x01	; 1
    7422:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7426:	8b e0       	ldi	r24, 0x0B	; 11
    7428:	6c ee       	ldi	r22, 0xEC	; 236
    742a:	73 e0       	ldi	r23, 0x03	; 3
    742c:	4a e2       	ldi	r20, 0x2A	; 42
    742e:	26 ed       	ldi	r18, 0xD6	; 214
    7430:	31 e0       	ldi	r19, 0x01	; 1
    7432:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7436:	89 e0       	ldi	r24, 0x09	; 9
    7438:	6c ee       	ldi	r22, 0xEC	; 236
    743a:	73 e0       	ldi	r23, 0x03	; 3
    743c:	41 e0       	ldi	r20, 0x01	; 1
    743e:	26 ed       	ldi	r18, 0xD6	; 214
    7440:	31 e0       	ldi	r19, 0x01	; 1
    7442:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
          
		  cmdPrint=0b00000000;
    7446:	10 92 b5 01 	sts	0x01B5, r1
		  LengthMessage81=RepPos+1;
    744a:	80 91 d6 01 	lds	r24, 0x01D6
    744e:	90 91 d7 01 	lds	r25, 0x01D7
    7452:	01 96       	adiw	r24, 0x01	; 1
    7454:	90 93 8e 01 	sts	0x018E, r25
    7458:	80 93 8d 01 	sts	0x018D, r24

		  IsFreePrinting=True;
    745c:	81 e0       	ldi	r24, 0x01	; 1
    745e:	80 93 a8 01 	sts	0x01A8, r24
	      IsBusyFreePrinting=True;
    7462:	80 93 b4 01 	sts	0x01B4, r24

		  stGenerateReport=grWaitLabelPrinted;
    7466:	85 e0       	ldi	r24, 0x05	; 5
    7468:	0c 94 ca 42 	jmp	0x8594	; 0x8594 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    746c:	80 91 e7 01 	lds	r24, 0x01E7
    7470:	81 50       	subi	r24, 0x01	; 1
    7472:	88 30       	cpi	r24, 0x08	; 8
    7474:	10 f0       	brcs	.+4      	; 0x747a <systemGenerateReport+0x508>
    7476:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    747a:	ce 01       	movw	r24, r28
    747c:	07 96       	adiw	r24, 0x07	; 7
    747e:	65 e4       	ldi	r22, 0x45	; 69
    7480:	70 e0       	ldi	r23, 0x00	; 0
    7482:	48 e0       	ldi	r20, 0x08	; 8
    7484:	50 e0       	ldi	r21, 0x00	; 0
    7486:	22 ed       	ldi	r18, 0xD2	; 210
    7488:	33 e1       	ldi	r19, 0x13	; 19
    748a:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    748e:	90 91 e7 01 	lds	r25, 0x01E7
    7492:	fe 01       	movw	r30, r28
    7494:	e9 0f       	add	r30, r25
    7496:	f1 1d       	adc	r31, r1
    7498:	86 81       	ldd	r24, Z+6	; 0x06
    749a:	80 93 e4 01 	sts	0x01E4, r24
			  if (PumpNum>0){
    749e:	88 23       	and	r24, r24
    74a0:	09 f4       	brne	.+2      	; 0x74a4 <systemGenerateReport+0x532>
    74a2:	4b c0       	rjmp	.+150    	; 0x753a <systemGenerateReport+0x5c8>
    74a4:	91 9f       	mul	r25, r17
    74a6:	b0 01       	movw	r22, r0
    74a8:	11 24       	eor	r1, r1
    74aa:	61 5b       	subi	r22, 0xB1	; 177
    74ac:	7f 4f       	sbci	r23, 0xFF	; 255
    74ae:	ce 01       	movw	r24, r28
    74b0:	01 96       	adiw	r24, 0x01	; 1
    74b2:	46 e0       	ldi	r20, 0x06	; 6
    74b4:	50 e0       	ldi	r21, 0x00	; 0
    74b6:	22 ed       	ldi	r18, 0xD2	; 210
    74b8:	33 e1       	ldi	r19, 0x13	; 19
    74ba:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    74be:	80 91 e6 01 	lds	r24, 0x01E6
    74c2:	fe 01       	movw	r30, r28
    74c4:	e8 0f       	add	r30, r24
    74c6:	f1 1d       	adc	r31, r1
    74c8:	80 81       	ld	r24, Z
    74ca:	80 93 e5 01 	sts	0x01E5, r24
    74ce:	ee e5       	ldi	r30, 0x5E	; 94
    74d0:	ce 2e       	mov	r12, r30
    74d2:	e7 e0       	ldi	r30, 0x07	; 7
    74d4:	de 2e       	mov	r13, r30

				  if (xGrade>0){
    74d6:	88 23       	and	r24, r24
    74d8:	99 f0       	breq	.+38     	; 0x7500 <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    74da:	b6 01       	movw	r22, r12
    74dc:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <GetProductName>
                      GradeUsed=xGrade;
    74e0:	80 91 e5 01 	lds	r24, 0x01E5
    74e4:	80 93 e2 01 	sts	0x01E2, r24
					  xGrade=xNozzle;//
    74e8:	80 91 e6 01 	lds	r24, 0x01E6
    74ec:	80 93 e5 01 	sts	0x01E5, r24
					  PumpNozzle=xNozzle;
    74f0:	80 93 e3 01 	sts	0x01E3, r24
					  xNozzle++;
    74f4:	8f 5f       	subi	r24, 0xFF	; 255
    74f6:	80 93 e6 01 	sts	0x01E6, r24
					  stGenerateReport=grCreateReportTotalizer;
    74fa:	88 e0       	ldi	r24, 0x08	; 8
    74fc:	0c 94 ca 42 	jmp	0x8594	; 0x8594 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    7500:	00 d0       	rcall	.+0      	; 0x7502 <systemGenerateReport+0x590>
    7502:	00 d0       	rcall	.+0      	; 0x7504 <systemGenerateReport+0x592>
    7504:	ad b7       	in	r26, 0x3d	; 61
    7506:	be b7       	in	r27, 0x3e	; 62
    7508:	12 96       	adiw	r26, 0x02	; 2
    750a:	dc 92       	st	X, r13
    750c:	ce 92       	st	-X, r12
    750e:	11 97       	sbiw	r26, 0x01	; 1
    7510:	83 e4       	ldi	r24, 0x43	; 67
    7512:	96 e0       	ldi	r25, 0x06	; 6
    7514:	14 96       	adiw	r26, 0x04	; 4
    7516:	9c 93       	st	X, r25
    7518:	8e 93       	st	-X, r24
    751a:	13 97       	sbiw	r26, 0x03	; 3
    751c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
					   xNozzle++;
    7520:	80 91 e6 01 	lds	r24, 0x01E6
    7524:	8f 5f       	subi	r24, 0xFF	; 255
    7526:	80 93 e6 01 	sts	0x01E6, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    752a:	0f 90       	pop	r0
    752c:	0f 90       	pop	r0
    752e:	0f 90       	pop	r0
    7530:	0f 90       	pop	r0
    7532:	87 30       	cpi	r24, 0x07	; 7
    7534:	10 f4       	brcc	.+4      	; 0x753a <systemGenerateReport+0x5c8>
    7536:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    753a:	87 e0       	ldi	r24, 0x07	; 7
    753c:	0c 94 ca 42 	jmp	0x8594	; 0x8594 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    7540:	81 e0       	ldi	r24, 0x01	; 1
    7542:	80 93 e6 01 	sts	0x01E6, r24
	      xPump++;
    7546:	80 91 e7 01 	lds	r24, 0x01E7
    754a:	8f 5f       	subi	r24, 0xFF	; 255
    754c:	80 93 e7 01 	sts	0x01E7, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    7550:	89 30       	cpi	r24, 0x09	; 9
    7552:	08 f4       	brcc	.+2      	; 0x7556 <systemGenerateReport+0x5e4>
    7554:	93 c4       	rjmp	.+2342   	; 0x7e7c <systemGenerateReport+0xf0a>
    7556:	8a e0       	ldi	r24, 0x0A	; 10
    7558:	0c 94 ca 42 	jmp	0x8594	; 0x8594 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    755c:	10 92 d7 01 	sts	0x01D7, r1
    7560:	10 92 d6 01 	sts	0x01D6, r1
    7564:	ec ee       	ldi	r30, 0xEC	; 236
    7566:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7568:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    756a:	b5 e0       	ldi	r27, 0x05	; 5
    756c:	ed 37       	cpi	r30, 0x7D	; 125
    756e:	fb 07       	cpc	r31, r27
    7570:	d9 f7       	brne	.-10     	; 0x7568 <systemGenerateReport+0x5f6>
    7572:	fe 01       	movw	r30, r28
    7574:	eb 55       	subi	r30, 0x5B	; 91
    7576:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7578:	ce 01       	movw	r24, r28
    757a:	8b 50       	subi	r24, 0x0B	; 11
    757c:	9f 4f       	sbci	r25, 0xFF	; 255
    757e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7580:	e8 17       	cp	r30, r24
    7582:	f9 07       	cpc	r31, r25
    7584:	e1 f7       	brne	.-8      	; 0x757e <systemGenerateReport+0x60c>
    7586:	ed e2       	ldi	r30, 0x2D	; 45
    7588:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    758a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    758c:	8c e0       	ldi	r24, 0x0C	; 12
    758e:	ec 33       	cpi	r30, 0x3C	; 60
    7590:	f8 07       	cpc	r31, r24
    7592:	d9 f7       	brne	.-10     	; 0x758a <systemGenerateReport+0x618>
    7594:	e5 e0       	ldi	r30, 0x05	; 5
    7596:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    7598:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    759a:	99 e0       	ldi	r25, 0x09	; 9
    759c:	e4 31       	cpi	r30, 0x14	; 20
    759e:	f9 07       	cpc	r31, r25
    75a0:	d9 f7       	brne	.-10     	; 0x7598 <systemGenerateReport+0x626>
    75a2:	fe 01       	movw	r30, r28
    75a4:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    75a6:	ce 01       	movw	r24, r28
    75a8:	88 96       	adiw	r24, 0x28	; 40
    75aa:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75ac:	e8 17       	cp	r30, r24
    75ae:	f9 07       	cpc	r31, r25
    75b0:	e1 f7       	brne	.-8      	; 0x75aa <systemGenerateReport+0x638>
	     strMemory[i]=data;
    75b2:	ce 01       	movw	r24, r28
    75b4:	c7 96       	adiw	r24, 0x37	; 55
    75b6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75b8:	e8 17       	cp	r30, r24
    75ba:	f9 07       	cpc	r31, r25
    75bc:	e1 f7       	brne	.-8      	; 0x75b6 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    75be:	cf 01       	movw	r24, r30
    75c0:	0f 96       	adiw	r24, 0x0f	; 15
    75c2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75c4:	e8 17       	cp	r30, r24
    75c6:	f9 07       	cpc	r31, r25
    75c8:	e1 f7       	brne	.-8      	; 0x75c2 <systemGenerateReport+0x650>
    75ca:	fe 01       	movw	r30, r28
    75cc:	ea 5b       	subi	r30, 0xBA	; 186
    75ce:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    75d0:	cf 01       	movw	r24, r30
    75d2:	ee 2e       	mov	r14, r30
    75d4:	d9 2e       	mov	r13, r25
    75d6:	0f 96       	adiw	r24, 0x0f	; 15
    75d8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75da:	e8 17       	cp	r30, r24
    75dc:	f9 07       	cpc	r31, r25
    75de:	e1 f7       	brne	.-8      	; 0x75d8 <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    75e0:	80 91 e4 01 	lds	r24, 0x01E4
    75e4:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
		  if (FIPAddr>0){
    75e8:	88 23       	and	r24, r24
    75ea:	49 f1       	breq	.+82     	; 0x763e <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    75ec:	f8 2e       	mov	r15, r24
    75ee:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    75f0:	80 e0       	ldi	r24, 0x00	; 0
    75f2:	60 e0       	ldi	r22, 0x00	; 0
    75f4:	4f 2d       	mov	r20, r15
    75f6:	20 91 e3 01 	lds	r18, 0x01E3
    75fa:	8e 01       	movw	r16, r28
    75fc:	07 5e       	subi	r16, 0xE7	; 231
    75fe:	1f 4f       	sbci	r17, 0xFF	; 255
    7600:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    7604:	81 e0       	ldi	r24, 0x01	; 1
    7606:	60 e0       	ldi	r22, 0x00	; 0
    7608:	4f 2d       	mov	r20, r15
    760a:	20 91 e3 01 	lds	r18, 0x01E3
    760e:	8e 01       	movw	r16, r28
    7610:	08 5d       	subi	r16, 0xD8	; 216
    7612:	1f 4f       	sbci	r17, 0xFF	; 255
    7614:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    7618:	80 e0       	ldi	r24, 0x00	; 0
    761a:	61 e0       	ldi	r22, 0x01	; 1
    761c:	4f 2d       	mov	r20, r15
    761e:	20 91 e3 01 	lds	r18, 0x01E3
    7622:	8e 01       	movw	r16, r28
    7624:	09 5c       	subi	r16, 0xC9	; 201
    7626:	1f 4f       	sbci	r17, 0xFF	; 255
    7628:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    762c:	81 e0       	ldi	r24, 0x01	; 1
    762e:	61 e0       	ldi	r22, 0x01	; 1
    7630:	4f 2d       	mov	r20, r15
    7632:	20 91 e3 01 	lds	r18, 0x01E3
    7636:	0e 2d       	mov	r16, r14
    7638:	1d 2d       	mov	r17, r13
    763a:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    763e:	80 e0       	ldi	r24, 0x00	; 0
    7640:	be 01       	movw	r22, r28
    7642:	69 5c       	subi	r22, 0xC9	; 201
    7644:	7f 4f       	sbci	r23, 0xFF	; 255
    7646:	ae 01       	movw	r20, r28
    7648:	47 5e       	subi	r20, 0xE7	; 231
    764a:	5f 4f       	sbci	r21, 0xFF	; 255
    764c:	25 e0       	ldi	r18, 0x05	; 5
    764e:	39 e0       	ldi	r19, 0x09	; 9
    7650:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    7654:	85 e0       	ldi	r24, 0x05	; 5
    7656:	99 e0       	ldi	r25, 0x09	; 9
    7658:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <IsMinus>
    765c:	81 30       	cpi	r24, 0x01	; 1
    765e:	21 f4       	brne	.+8      	; 0x7668 <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    7660:	85 e0       	ldi	r24, 0x05	; 5
    7662:	99 e0       	ldi	r25, 0x09	; 9
    7664:	0e 94 29 30 	call	0x6052	; 0x6052 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7668:	e1 99       	sbic	0x1c, 1	; 28
    766a:	fe cf       	rjmp	.-4      	; 0x7668 <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    766c:	77 e3       	ldi	r23, 0x37	; 55
    766e:	87 2e       	mov	r8, r23
    7670:	71 e0       	ldi	r23, 0x01	; 1
    7672:	97 2e       	mov	r9, r23
    7674:	9f ba       	out	0x1f, r9	; 31
    7676:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7678:	e0 9a       	sbi	0x1c, 0	; 28
    767a:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    767c:	82 30       	cpi	r24, 0x02	; 2
    767e:	79 f4       	brne	.+30     	; 0x769e <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7680:	8e 01       	movw	r16, r28
    7682:	01 5f       	subi	r16, 0xF1	; 241
    7684:	1f 4f       	sbci	r17, 0xFF	; 255
    7686:	c8 01       	movw	r24, r16
    7688:	60 91 e4 01 	lds	r22, 0x01E4
    768c:	40 91 e3 01 	lds	r20, 0x01E3
    7690:	0e 94 70 27 	call	0x4ee0	; 0x4ee0 <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    7694:	82 e0       	ldi	r24, 0x02	; 2
    7696:	b8 01       	movw	r22, r16
    7698:	45 e0       	ldi	r20, 0x05	; 5
    769a:	59 e0       	ldi	r21, 0x09	; 9
    769c:	07 c0       	rjmp	.+14     	; 0x76ac <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    769e:	80 e0       	ldi	r24, 0x00	; 0
    76a0:	be 01       	movw	r22, r28
    76a2:	6a 5b       	subi	r22, 0xBA	; 186
    76a4:	7f 4f       	sbci	r23, 0xFF	; 255
    76a6:	ae 01       	movw	r20, r28
    76a8:	48 5d       	subi	r20, 0xD8	; 216
    76aa:	5f 4f       	sbci	r21, 0xFF	; 255
    76ac:	2d e2       	ldi	r18, 0x2D	; 45
    76ae:	3c e0       	ldi	r19, 0x0C	; 12
    76b0:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    76b4:	8d e2       	ldi	r24, 0x2D	; 45
    76b6:	9c e0       	ldi	r25, 0x0C	; 12
    76b8:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <IsMinus>
    76bc:	81 30       	cpi	r24, 0x01	; 1
    76be:	21 f4       	brne	.+8      	; 0x76c8 <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    76c0:	8d e2       	ldi	r24, 0x2D	; 45
    76c2:	9c e0       	ldi	r25, 0x0C	; 12
    76c4:	0e 94 29 30 	call	0x6052	; 0x6052 <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    76c8:	80 91 e2 01 	lds	r24, 0x01E2
    76cc:	68 ed       	ldi	r22, 0xD8	; 216
    76ce:	71 e0       	ldi	r23, 0x01	; 1
    76d0:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    76d4:	81 e0       	ldi	r24, 0x01	; 1
    76d6:	67 ef       	ldi	r22, 0xF7	; 247
    76d8:	77 e0       	ldi	r23, 0x07	; 7
    76da:	45 e0       	ldi	r20, 0x05	; 5
    76dc:	59 e0       	ldi	r21, 0x09	; 9
    76de:	9b 01       	movw	r18, r22
    76e0:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    76e4:	81 e0       	ldi	r24, 0x01	; 1
    76e6:	68 ea       	ldi	r22, 0xA8	; 168
    76e8:	78 e0       	ldi	r23, 0x08	; 8
    76ea:	4d e2       	ldi	r20, 0x2D	; 45
    76ec:	5c e0       	ldi	r21, 0x0C	; 12
    76ee:	9b 01       	movw	r18, r22
    76f0:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>


		  RemZeroLead(strDeltaMoney);
    76f4:	8d e2       	ldi	r24, 0x2D	; 45
    76f6:	9c e0       	ldi	r25, 0x0C	; 12
    76f8:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    76fc:	66 e4       	ldi	r22, 0x46	; 70
    76fe:	c6 2e       	mov	r12, r22
    7700:	d1 2c       	mov	r13, r1
    7702:	cc 0e       	add	r12, r28
    7704:	dd 1e       	adc	r13, r29
    7706:	c6 01       	movw	r24, r12
    7708:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		  RemZeroLead(strLastMoney);
    770c:	58 e2       	ldi	r21, 0x28	; 40
    770e:	e5 2e       	mov	r14, r21
    7710:	f1 2c       	mov	r15, r1
    7712:	ec 0e       	add	r14, r28
    7714:	fd 1e       	adc	r15, r29
    7716:	c7 01       	movw	r24, r14
    7718:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    771c:	85 e0       	ldi	r24, 0x05	; 5
    771e:	99 e0       	ldi	r25, 0x09	; 9
    7720:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    7724:	47 e3       	ldi	r20, 0x37	; 55
    7726:	a4 2e       	mov	r10, r20
    7728:	b1 2c       	mov	r11, r1
    772a:	ac 0e       	add	r10, r28
    772c:	bd 1e       	adc	r11, r29
    772e:	c5 01       	movw	r24, r10
    7730:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
          RemZeroLead(strLastVolume);
    7734:	8e 01       	movw	r16, r28
    7736:	07 5e       	subi	r16, 0xE7	; 231
    7738:	1f 4f       	sbci	r17, 0xFF	; 255
    773a:	c8 01       	movw	r24, r16
    773c:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    7740:	8d e2       	ldi	r24, 0x2D	; 45
    7742:	9c e0       	ldi	r25, 0x0C	; 12
    7744:	0e 94 85 37 	call	0x6f0a	; 0x6f0a <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    7748:	c6 01       	movw	r24, r12
    774a:	0e 94 85 37 	call	0x6f0a	; 0x6f0a <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    774e:	c7 01       	movw	r24, r14
    7750:	0e 94 85 37 	call	0x6f0a	; 0x6f0a <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    7754:	85 e0       	ldi	r24, 0x05	; 5
    7756:	99 e0       	ldi	r25, 0x09	; 9
    7758:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    775c:	c8 01       	movw	r24, r16
    775e:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    7762:	c5 01       	movw	r24, r10
    7764:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    7768:	8d e2       	ldi	r24, 0x2D	; 45
    776a:	9c e0       	ldi	r25, 0x0C	; 12
    776c:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    7770:	c6 01       	movw	r24, r12
    7772:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
		  FormatCurrency(strLastMoney);
    7776:	c7 01       	movw	r24, r14
    7778:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    777c:	85 e0       	ldi	r24, 0x05	; 5
    777e:	99 e0       	ldi	r25, 0x09	; 9
    7780:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
		  FormatCurrency(strLastVolume);
    7784:	c8 01       	movw	r24, r16
    7786:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    778a:	c5 01       	movw	r24, r10
    778c:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    7790:	81 e0       	ldi	r24, 0x01	; 1
    7792:	6c ee       	ldi	r22, 0xEC	; 236
    7794:	73 e0       	ldi	r23, 0x03	; 3
    7796:	41 e0       	ldi	r20, 0x01	; 1
    7798:	26 ed       	ldi	r18, 0xD6	; 214
    779a:	31 e0       	ldi	r19, 0x01	; 1
    779c:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    77a0:	8b e0       	ldi	r24, 0x0B	; 11
    77a2:	6c ee       	ldi	r22, 0xEC	; 236
    77a4:	73 e0       	ldi	r23, 0x03	; 3
    77a6:	4a e2       	ldi	r20, 0x2A	; 42
    77a8:	26 ed       	ldi	r18, 0xD6	; 214
    77aa:	31 e0       	ldi	r19, 0x01	; 1
    77ac:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    77b0:	83 e0       	ldi	r24, 0x03	; 3
    77b2:	6c ee       	ldi	r22, 0xEC	; 236
    77b4:	73 e0       	ldi	r23, 0x03	; 3
    77b6:	41 e0       	ldi	r20, 0x01	; 1
    77b8:	26 ed       	ldi	r18, 0xD6	; 214
    77ba:	31 e0       	ldi	r19, 0x01	; 1
    77bc:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    77c0:	8c e0       	ldi	r24, 0x0C	; 12
    77c2:	6c ee       	ldi	r22, 0xEC	; 236
    77c4:	73 e0       	ldi	r23, 0x03	; 3
    77c6:	41 e0       	ldi	r20, 0x01	; 1
    77c8:	26 ed       	ldi	r18, 0xD6	; 214
    77ca:	31 e0       	ldi	r19, 0x01	; 1
    77cc:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    77d0:	e1 99       	sbic	0x1c, 1	; 28
    77d2:	fe cf       	rjmp	.-4      	; 0x77d0 <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    77d4:	9f ba       	out	0x1f, r9	; 31
    77d6:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    77d8:	e0 9a       	sbi	0x1c, 0	; 28
    77da:	8d b3       	in	r24, 0x1d	; 29
    77dc:	3e e5       	ldi	r19, 0x5E	; 94
    77de:	c3 2e       	mov	r12, r19
    77e0:	37 e0       	ldi	r19, 0x07	; 7
    77e2:	d3 2e       	mov	r13, r19
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    77e4:	82 30       	cpi	r24, 0x02	; 2
    77e6:	09 f0       	breq	.+2      	; 0x77ea <systemGenerateReport+0x878>
    77e8:	84 c0       	rjmp	.+264    	; 0x78f2 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    77ea:	2f e0       	ldi	r18, 0x0F	; 15
    77ec:	e2 2e       	mov	r14, r18
    77ee:	f1 2c       	mov	r15, r1
    77f0:	ec 0e       	add	r14, r28
    77f2:	fd 1e       	adc	r15, r29
    77f4:	c7 01       	movw	r24, r14
    77f6:	60 91 e4 01 	lds	r22, 0x01E4
    77fa:	40 91 e3 01 	lds	r20, 0x01E3
    77fe:	0e 94 70 27 	call	0x4ee0	; 0x4ee0 <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    7802:	00 d0       	rcall	.+0      	; 0x7804 <systemGenerateReport+0x892>
    7804:	00 d0       	rcall	.+0      	; 0x7806 <systemGenerateReport+0x894>
    7806:	00 d0       	rcall	.+0      	; 0x7808 <systemGenerateReport+0x896>
    7808:	ed b7       	in	r30, 0x3d	; 61
    780a:	fe b7       	in	r31, 0x3e	; 62
    780c:	31 96       	adiw	r30, 0x01	; 1
    780e:	8e 01       	movw	r16, r28
    7810:	0f 56       	subi	r16, 0x6F	; 111
    7812:	1f 4f       	sbci	r17, 0xFF	; 255
    7814:	ad b7       	in	r26, 0x3d	; 61
    7816:	be b7       	in	r27, 0x3e	; 62
    7818:	12 96       	adiw	r26, 0x02	; 2
    781a:	1c 93       	st	X, r17
    781c:	0e 93       	st	-X, r16
    781e:	11 97       	sbiw	r26, 0x01	; 1
    7820:	86 e3       	ldi	r24, 0x36	; 54
    7822:	96 e0       	ldi	r25, 0x06	; 6
    7824:	93 83       	std	Z+3, r25	; 0x03
    7826:	82 83       	std	Z+2, r24	; 0x02
    7828:	f5 82       	std	Z+5, r15	; 0x05
    782a:	e4 82       	std	Z+4, r14	; 0x04
    782c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    7830:	d6 01       	movw	r26, r12
    7832:	0d 90       	ld	r0, X+
    7834:	00 20       	and	r0, r0
    7836:	e9 f7       	brne	.-6      	; 0x7832 <systemGenerateReport+0x8c0>
    7838:	11 97       	sbiw	r26, 0x01	; 1
    783a:	ac 19       	sub	r26, r12
    783c:	bd 09       	sbc	r27, r13
    783e:	f8 01       	movw	r30, r16
    7840:	01 90       	ld	r0, Z+
    7842:	00 20       	and	r0, r0
    7844:	e9 f7       	brne	.-6      	; 0x7840 <systemGenerateReport+0x8ce>
    7846:	31 97       	sbiw	r30, 0x01	; 1
    7848:	0e 1b       	sub	r16, r30
    784a:	0a 1b       	sub	r16, r26
    784c:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    784e:	ed b7       	in	r30, 0x3d	; 61
    7850:	fe b7       	in	r31, 0x3e	; 62
    7852:	36 96       	adiw	r30, 0x06	; 6
    7854:	0f b6       	in	r0, 0x3f	; 63
    7856:	f8 94       	cli
    7858:	fe bf       	out	0x3e, r31	; 62
    785a:	0f be       	out	0x3f, r0	; 63
    785c:	ed bf       	out	0x3d, r30	; 61
    785e:	fe 01       	movw	r30, r28
    7860:	e3 58       	subi	r30, 0x83	; 131
    7862:	ff 4f       	sbci	r31, 0xFF	; 255
    7864:	10 16       	cp	r1, r16
    7866:	74 f4       	brge	.+28     	; 0x7884 <systemGenerateReport+0x912>
    7868:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    786a:	90 e2       	ldi	r25, 0x20	; 32
    786c:	02 c0       	rjmp	.+4      	; 0x7872 <systemGenerateReport+0x900>
    786e:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7870:	8f 5f       	subi	r24, 0xFF	; 255
    7872:	80 17       	cp	r24, r16
    7874:	e0 f3       	brcs	.-8      	; 0x786e <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7876:	fe 01       	movw	r30, r28
    7878:	e3 58       	subi	r30, 0x83	; 131
    787a:	ff 4f       	sbci	r31, 0xFF	; 255
    787c:	e0 0f       	add	r30, r16
    787e:	f1 1d       	adc	r31, r1
    7880:	10 82       	st	Z, r1
    7882:	03 c0       	rjmp	.+6      	; 0x788a <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    7884:	80 e2       	ldi	r24, 0x20	; 32
    7886:	80 83       	st	Z, r24
	 strTab[1]=0;
    7888:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    788a:	8d b7       	in	r24, 0x3d	; 61
    788c:	9e b7       	in	r25, 0x3e	; 62
    788e:	0e 97       	sbiw	r24, 0x0e	; 14
    7890:	0f b6       	in	r0, 0x3f	; 63
    7892:	f8 94       	cli
    7894:	9e bf       	out	0x3e, r25	; 62
    7896:	0f be       	out	0x3f, r0	; 63
    7898:	8d bf       	out	0x3d, r24	; 61
    789a:	ed b7       	in	r30, 0x3d	; 61
    789c:	fe b7       	in	r31, 0x3e	; 62
    789e:	31 96       	adiw	r30, 0x01	; 1
    78a0:	ce 01       	movw	r24, r28
    78a2:	8b 55       	subi	r24, 0x5B	; 91
    78a4:	9f 4f       	sbci	r25, 0xFF	; 255
    78a6:	ad b7       	in	r26, 0x3d	; 61
    78a8:	be b7       	in	r27, 0x3e	; 62
    78aa:	12 96       	adiw	r26, 0x02	; 2
    78ac:	9c 93       	st	X, r25
    78ae:	8e 93       	st	-X, r24
    78b0:	11 97       	sbiw	r26, 0x01	; 1
    78b2:	84 e2       	ldi	r24, 0x24	; 36
    78b4:	96 e0       	ldi	r25, 0x06	; 6
    78b6:	93 83       	std	Z+3, r25	; 0x03
    78b8:	82 83       	std	Z+2, r24	; 0x02
    78ba:	80 91 e4 01 	lds	r24, 0x01E4
    78be:	84 83       	std	Z+4, r24	; 0x04
    78c0:	15 82       	std	Z+5, r1	; 0x05
    78c2:	80 91 e3 01 	lds	r24, 0x01E3
    78c6:	86 83       	std	Z+6, r24	; 0x06
    78c8:	17 82       	std	Z+7, r1	; 0x07
    78ca:	8e e5       	ldi	r24, 0x5E	; 94
    78cc:	97 e0       	ldi	r25, 0x07	; 7
    78ce:	91 87       	std	Z+9, r25	; 0x09
    78d0:	80 87       	std	Z+8, r24	; 0x08
    78d2:	ce 01       	movw	r24, r28
    78d4:	83 58       	subi	r24, 0x83	; 131
    78d6:	9f 4f       	sbci	r25, 0xFF	; 255
    78d8:	93 87       	std	Z+11, r25	; 0x0b
    78da:	82 87       	std	Z+10, r24	; 0x0a
    78dc:	ce 01       	movw	r24, r28
    78de:	8f 56       	subi	r24, 0x6F	; 111
    78e0:	9f 4f       	sbci	r25, 0xFF	; 255
    78e2:	95 87       	std	Z+13, r25	; 0x0d
    78e4:	84 87       	std	Z+12, r24	; 0x0c
    78e6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    78ea:	ed b7       	in	r30, 0x3d	; 61
    78ec:	fe b7       	in	r31, 0x3e	; 62
    78ee:	3e 96       	adiw	r30, 0x0e	; 14
    78f0:	27 c0       	rjmp	.+78     	; 0x7940 <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    78f2:	8d b7       	in	r24, 0x3d	; 61
    78f4:	9e b7       	in	r25, 0x3e	; 62
    78f6:	0a 97       	sbiw	r24, 0x0a	; 10
    78f8:	0f b6       	in	r0, 0x3f	; 63
    78fa:	f8 94       	cli
    78fc:	9e bf       	out	0x3e, r25	; 62
    78fe:	0f be       	out	0x3f, r0	; 63
    7900:	8d bf       	out	0x3d, r24	; 61
    7902:	ed b7       	in	r30, 0x3d	; 61
    7904:	fe b7       	in	r31, 0x3e	; 62
    7906:	31 96       	adiw	r30, 0x01	; 1
    7908:	ce 01       	movw	r24, r28
    790a:	8b 55       	subi	r24, 0x5B	; 91
    790c:	9f 4f       	sbci	r25, 0xFF	; 255
    790e:	ad b7       	in	r26, 0x3d	; 61
    7910:	be b7       	in	r27, 0x3e	; 62
    7912:	12 96       	adiw	r26, 0x02	; 2
    7914:	9c 93       	st	X, r25
    7916:	8e 93       	st	-X, r24
    7918:	11 97       	sbiw	r26, 0x01	; 1
    791a:	87 e1       	ldi	r24, 0x17	; 23
    791c:	96 e0       	ldi	r25, 0x06	; 6
    791e:	93 83       	std	Z+3, r25	; 0x03
    7920:	82 83       	std	Z+2, r24	; 0x02
    7922:	80 91 e4 01 	lds	r24, 0x01E4
    7926:	84 83       	std	Z+4, r24	; 0x04
    7928:	15 82       	std	Z+5, r1	; 0x05
    792a:	80 91 e3 01 	lds	r24, 0x01E3
    792e:	86 83       	std	Z+6, r24	; 0x06
    7930:	17 82       	std	Z+7, r1	; 0x07
    7932:	d1 86       	std	Z+9, r13	; 0x09
    7934:	c0 86       	std	Z+8, r12	; 0x08
    7936:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    793a:	ed b7       	in	r30, 0x3d	; 61
    793c:	fe b7       	in	r31, 0x3e	; 62
    793e:	3a 96       	adiw	r30, 0x0a	; 10
    7940:	0f b6       	in	r0, 0x3f	; 63
    7942:	f8 94       	cli
    7944:	fe bf       	out	0x3e, r31	; 62
    7946:	0f be       	out	0x3f, r0	; 63
    7948:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    794a:	ce 01       	movw	r24, r28
    794c:	8b 55       	subi	r24, 0x5B	; 91
    794e:	9f 4f       	sbci	r25, 0xFF	; 255
    7950:	6c ee       	ldi	r22, 0xEC	; 236
    7952:	73 e0       	ldi	r23, 0x03	; 3
    7954:	46 ed       	ldi	r20, 0xD6	; 214
    7956:	51 e0       	ldi	r21, 0x01	; 1
    7958:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    795c:	84 e0       	ldi	r24, 0x04	; 4
    795e:	6c ee       	ldi	r22, 0xEC	; 236
    7960:	73 e0       	ldi	r23, 0x03	; 3
    7962:	41 e0       	ldi	r20, 0x01	; 1
    7964:	26 ed       	ldi	r18, 0xD6	; 214
    7966:	31 e0       	ldi	r19, 0x01	; 1
    7968:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    796c:	8b e0       	ldi	r24, 0x0B	; 11
    796e:	6c ee       	ldi	r22, 0xEC	; 236
    7970:	73 e0       	ldi	r23, 0x03	; 3
    7972:	4a e2       	ldi	r20, 0x2A	; 42
    7974:	26 ed       	ldi	r18, 0xD6	; 214
    7976:	31 e0       	ldi	r19, 0x01	; 1
    7978:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    797c:	86 e0       	ldi	r24, 0x06	; 6
    797e:	6c ee       	ldi	r22, 0xEC	; 236
    7980:	73 e0       	ldi	r23, 0x03	; 3
    7982:	41 e0       	ldi	r20, 0x01	; 1
    7984:	26 ed       	ldi	r18, 0xD6	; 214
    7986:	31 e0       	ldi	r19, 0x01	; 1
    7988:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    798c:	8c e0       	ldi	r24, 0x0C	; 12
    798e:	6c ee       	ldi	r22, 0xEC	; 236
    7990:	73 e0       	ldi	r23, 0x03	; 3
    7992:	41 e0       	ldi	r20, 0x01	; 1
    7994:	26 ed       	ldi	r18, 0xD6	; 214
    7996:	31 e0       	ldi	r19, 0x01	; 1
    7998:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    799c:	de 01       	movw	r26, r28
    799e:	d7 96       	adiw	r26, 0x37	; 55
    79a0:	fd 01       	movw	r30, r26
    79a2:	01 90       	ld	r0, Z+
    79a4:	00 20       	and	r0, r0
    79a6:	e9 f7       	brne	.-6      	; 0x79a2 <systemGenerateReport+0xa30>
    79a8:	9a 2f       	mov	r25, r26
    79aa:	9e 1b       	sub	r25, r30
    79ac:	9e 5e       	subi	r25, 0xEE	; 238
    79ae:	de 01       	movw	r26, r28
    79b0:	a7 59       	subi	r26, 0x97	; 151
    79b2:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    79b4:	19 16       	cp	r1, r25
    79b6:	7c f4       	brge	.+30     	; 0x79d6 <systemGenerateReport+0xa64>
    79b8:	fd 01       	movw	r30, r26
    79ba:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    79bc:	20 e2       	ldi	r18, 0x20	; 32
    79be:	02 c0       	rjmp	.+4      	; 0x79c4 <systemGenerateReport+0xa52>
    79c0:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    79c2:	8f 5f       	subi	r24, 0xFF	; 255
    79c4:	89 17       	cp	r24, r25
    79c6:	e0 f3       	brcs	.-8      	; 0x79c0 <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    79c8:	fe 01       	movw	r30, r28
    79ca:	e7 59       	subi	r30, 0x97	; 151
    79cc:	ff 4f       	sbci	r31, 0xFF	; 255
    79ce:	e9 0f       	add	r30, r25
    79d0:	f1 1d       	adc	r31, r1
    79d2:	10 82       	st	Z, r1
    79d4:	04 c0       	rjmp	.+8      	; 0x79de <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    79d6:	80 e2       	ldi	r24, 0x20	; 32
    79d8:	8c 93       	st	X, r24
	 strTab[1]=0;
    79da:	11 96       	adiw	r26, 0x01	; 1
    79dc:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    79de:	de 01       	movw	r26, r28
    79e0:	aa 5b       	subi	r26, 0xBA	; 186
    79e2:	bf 4f       	sbci	r27, 0xFF	; 255
    79e4:	fd 01       	movw	r30, r26
    79e6:	01 90       	ld	r0, Z+
    79e8:	00 20       	and	r0, r0
    79ea:	e9 f7       	brne	.-6      	; 0x79e6 <systemGenerateReport+0xa74>
    79ec:	ae 1b       	sub	r26, r30
    79ee:	a0 5f       	subi	r26, 0xF0	; 240
    79f0:	fe 01       	movw	r30, r28
    79f2:	e3 58       	subi	r30, 0x83	; 131
    79f4:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    79f6:	1a 16       	cp	r1, r26
    79f8:	74 f4       	brge	.+28     	; 0x7a16 <systemGenerateReport+0xaa4>
    79fa:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    79fc:	90 e2       	ldi	r25, 0x20	; 32
    79fe:	02 c0       	rjmp	.+4      	; 0x7a04 <systemGenerateReport+0xa92>
    7a00:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7a02:	8f 5f       	subi	r24, 0xFF	; 255
    7a04:	8a 17       	cp	r24, r26
    7a06:	e0 f3       	brcs	.-8      	; 0x7a00 <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7a08:	fe 01       	movw	r30, r28
    7a0a:	e3 58       	subi	r30, 0x83	; 131
    7a0c:	ff 4f       	sbci	r31, 0xFF	; 255
    7a0e:	ea 0f       	add	r30, r26
    7a10:	f1 1d       	adc	r31, r1
    7a12:	10 82       	st	Z, r1
    7a14:	03 c0       	rjmp	.+6      	; 0x7a1c <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    7a16:	80 e2       	ldi	r24, 0x20	; 32
    7a18:	80 83       	st	Z, r24
	 strTab[1]=0;
    7a1a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7a1c:	e1 99       	sbic	0x1c, 1	; 28
    7a1e:	fe cf       	rjmp	.-4      	; 0x7a1c <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7a20:	91 ec       	ldi	r25, 0xC1	; 193
    7a22:	e9 2e       	mov	r14, r25
    7a24:	93 e0       	ldi	r25, 0x03	; 3
    7a26:	f9 2e       	mov	r15, r25
    7a28:	ff ba       	out	0x1f, r15	; 31
    7a2a:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7a2c:	e0 9a       	sbi	0x1c, 0	; 28
    7a2e:	8d b3       	in	r24, 0x1d	; 29
    7a30:	9e 01       	movw	r18, r28
    7a32:	2b 55       	subi	r18, 0x5B	; 91
    7a34:	3f 4f       	sbci	r19, 0xFF	; 255
    7a36:	ae 01       	movw	r20, r28
    7a38:	49 5c       	subi	r20, 0xC9	; 201
    7a3a:	5f 4f       	sbci	r21, 0xFF	; 255
    7a3c:	de 01       	movw	r26, r28
    7a3e:	a7 59       	subi	r26, 0x97	; 151
    7a40:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7a42:	81 30       	cpi	r24, 0x01	; 1
    7a44:	49 f5       	brne	.+82     	; 0x7a98 <systemGenerateReport+0xb26>
    7a46:	8d b7       	in	r24, 0x3d	; 61
    7a48:	9e b7       	in	r25, 0x3e	; 62
    7a4a:	0c 97       	sbiw	r24, 0x0c	; 12
    7a4c:	0f b6       	in	r0, 0x3f	; 63
    7a4e:	f8 94       	cli
    7a50:	9e bf       	out	0x3e, r25	; 62
    7a52:	0f be       	out	0x3f, r0	; 63
    7a54:	8d bf       	out	0x3d, r24	; 61
    7a56:	6d b7       	in	r22, 0x3d	; 61
    7a58:	7e b7       	in	r23, 0x3e	; 62
    7a5a:	6f 5f       	subi	r22, 0xFF	; 255
    7a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    7a5e:	ed b7       	in	r30, 0x3d	; 61
    7a60:	fe b7       	in	r31, 0x3e	; 62
    7a62:	32 83       	std	Z+2, r19	; 0x02
    7a64:	21 83       	std	Z+1, r18	; 0x01
    7a66:	88 e0       	ldi	r24, 0x08	; 8
    7a68:	96 e0       	ldi	r25, 0x06	; 6
    7a6a:	fb 01       	movw	r30, r22
    7a6c:	93 83       	std	Z+3, r25	; 0x03
    7a6e:	82 83       	std	Z+2, r24	; 0x02
    7a70:	b5 83       	std	Z+5, r27	; 0x05
    7a72:	a4 83       	std	Z+4, r26	; 0x04
    7a74:	57 83       	std	Z+7, r21	; 0x07
    7a76:	46 83       	std	Z+6, r20	; 0x06
    7a78:	ce 01       	movw	r24, r28
    7a7a:	83 58       	subi	r24, 0x83	; 131
    7a7c:	9f 4f       	sbci	r25, 0xFF	; 255
    7a7e:	91 87       	std	Z+9, r25	; 0x09
    7a80:	80 87       	std	Z+8, r24	; 0x08
    7a82:	ce 01       	movw	r24, r28
    7a84:	8a 5b       	subi	r24, 0xBA	; 186
    7a86:	9f 4f       	sbci	r25, 0xFF	; 255
    7a88:	93 87       	std	Z+11, r25	; 0x0b
    7a8a:	82 87       	std	Z+10, r24	; 0x0a
    7a8c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    7a90:	8d b7       	in	r24, 0x3d	; 61
    7a92:	9e b7       	in	r25, 0x3e	; 62
    7a94:	0c 96       	adiw	r24, 0x0c	; 12
    7a96:	1c c0       	rjmp	.+56     	; 0x7ad0 <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    7a98:	ed b7       	in	r30, 0x3d	; 61
    7a9a:	fe b7       	in	r31, 0x3e	; 62
    7a9c:	38 97       	sbiw	r30, 0x08	; 8
    7a9e:	0f b6       	in	r0, 0x3f	; 63
    7aa0:	f8 94       	cli
    7aa2:	fe bf       	out	0x3e, r31	; 62
    7aa4:	0f be       	out	0x3f, r0	; 63
    7aa6:	ed bf       	out	0x3d, r30	; 61
    7aa8:	6d b7       	in	r22, 0x3d	; 61
    7aaa:	7e b7       	in	r23, 0x3e	; 62
    7aac:	6f 5f       	subi	r22, 0xFF	; 255
    7aae:	7f 4f       	sbci	r23, 0xFF	; 255
    7ab0:	32 83       	std	Z+2, r19	; 0x02
    7ab2:	21 83       	std	Z+1, r18	; 0x01
    7ab4:	8d ef       	ldi	r24, 0xFD	; 253
    7ab6:	95 e0       	ldi	r25, 0x05	; 5
    7ab8:	fb 01       	movw	r30, r22
    7aba:	93 83       	std	Z+3, r25	; 0x03
    7abc:	82 83       	std	Z+2, r24	; 0x02
    7abe:	b5 83       	std	Z+5, r27	; 0x05
    7ac0:	a4 83       	std	Z+4, r26	; 0x04
    7ac2:	57 83       	std	Z+7, r21	; 0x07
    7ac4:	46 83       	std	Z+6, r20	; 0x06
    7ac6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    7aca:	8d b7       	in	r24, 0x3d	; 61
    7acc:	9e b7       	in	r25, 0x3e	; 62
    7ace:	08 96       	adiw	r24, 0x08	; 8
    7ad0:	0f b6       	in	r0, 0x3f	; 63
    7ad2:	f8 94       	cli
    7ad4:	9e bf       	out	0x3e, r25	; 62
    7ad6:	0f be       	out	0x3f, r0	; 63
    7ad8:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    7ada:	ce 01       	movw	r24, r28
    7adc:	8b 55       	subi	r24, 0x5B	; 91
    7ade:	9f 4f       	sbci	r25, 0xFF	; 255
    7ae0:	6c ee       	ldi	r22, 0xEC	; 236
    7ae2:	73 e0       	ldi	r23, 0x03	; 3
    7ae4:	46 ed       	ldi	r20, 0xD6	; 214
    7ae6:	51 e0       	ldi	r21, 0x01	; 1
    7ae8:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    7aec:	de 01       	movw	r26, r28
    7aee:	59 96       	adiw	r26, 0x19	; 25
    7af0:	fd 01       	movw	r30, r26
    7af2:	01 90       	ld	r0, Z+
    7af4:	00 20       	and	r0, r0
    7af6:	e9 f7       	brne	.-6      	; 0x7af2 <systemGenerateReport+0xb80>
    7af8:	9a 2f       	mov	r25, r26
    7afa:	9e 1b       	sub	r25, r30
    7afc:	9e 5e       	subi	r25, 0xEE	; 238
    7afe:	de 01       	movw	r26, r28
    7b00:	a7 59       	subi	r26, 0x97	; 151
    7b02:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7b04:	19 16       	cp	r1, r25
    7b06:	7c f4       	brge	.+30     	; 0x7b26 <systemGenerateReport+0xbb4>
    7b08:	fd 01       	movw	r30, r26
    7b0a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7b0c:	20 e2       	ldi	r18, 0x20	; 32
    7b0e:	02 c0       	rjmp	.+4      	; 0x7b14 <systemGenerateReport+0xba2>
    7b10:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7b12:	8f 5f       	subi	r24, 0xFF	; 255
    7b14:	89 17       	cp	r24, r25
    7b16:	e0 f3       	brcs	.-8      	; 0x7b10 <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7b18:	fe 01       	movw	r30, r28
    7b1a:	e7 59       	subi	r30, 0x97	; 151
    7b1c:	ff 4f       	sbci	r31, 0xFF	; 255
    7b1e:	e9 0f       	add	r30, r25
    7b20:	f1 1d       	adc	r31, r1
    7b22:	10 82       	st	Z, r1
    7b24:	04 c0       	rjmp	.+8      	; 0x7b2e <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    7b26:	80 e2       	ldi	r24, 0x20	; 32
    7b28:	8c 93       	st	X, r24
	 strTab[1]=0;
    7b2a:	11 96       	adiw	r26, 0x01	; 1
    7b2c:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    7b2e:	de 01       	movw	r26, r28
    7b30:	98 96       	adiw	r26, 0x28	; 40
    7b32:	fd 01       	movw	r30, r26
    7b34:	01 90       	ld	r0, Z+
    7b36:	00 20       	and	r0, r0
    7b38:	e9 f7       	brne	.-6      	; 0x7b34 <systemGenerateReport+0xbc2>
    7b3a:	ae 1b       	sub	r26, r30
    7b3c:	a0 5f       	subi	r26, 0xF0	; 240
    7b3e:	fe 01       	movw	r30, r28
    7b40:	e3 58       	subi	r30, 0x83	; 131
    7b42:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7b44:	1a 16       	cp	r1, r26
    7b46:	74 f4       	brge	.+28     	; 0x7b64 <systemGenerateReport+0xbf2>
    7b48:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7b4a:	90 e2       	ldi	r25, 0x20	; 32
    7b4c:	02 c0       	rjmp	.+4      	; 0x7b52 <systemGenerateReport+0xbe0>
    7b4e:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7b50:	8f 5f       	subi	r24, 0xFF	; 255
    7b52:	8a 17       	cp	r24, r26
    7b54:	e0 f3       	brcs	.-8      	; 0x7b4e <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7b56:	fe 01       	movw	r30, r28
    7b58:	e3 58       	subi	r30, 0x83	; 131
    7b5a:	ff 4f       	sbci	r31, 0xFF	; 255
    7b5c:	ea 0f       	add	r30, r26
    7b5e:	f1 1d       	adc	r31, r1
    7b60:	10 82       	st	Z, r1
    7b62:	03 c0       	rjmp	.+6      	; 0x7b6a <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    7b64:	80 e2       	ldi	r24, 0x20	; 32
    7b66:	80 83       	st	Z, r24
	 strTab[1]=0;
    7b68:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7b6a:	e1 99       	sbic	0x1c, 1	; 28
    7b6c:	fe cf       	rjmp	.-4      	; 0x7b6a <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7b6e:	ff ba       	out	0x1f, r15	; 31
    7b70:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7b72:	e0 9a       	sbi	0x1c, 0	; 28
    7b74:	8d b3       	in	r24, 0x1d	; 29
    7b76:	9e 01       	movw	r18, r28
    7b78:	2b 55       	subi	r18, 0x5B	; 91
    7b7a:	3f 4f       	sbci	r19, 0xFF	; 255
    7b7c:	ae 01       	movw	r20, r28
    7b7e:	47 5e       	subi	r20, 0xE7	; 231
    7b80:	5f 4f       	sbci	r21, 0xFF	; 255
    7b82:	de 01       	movw	r26, r28
    7b84:	a7 59       	subi	r26, 0x97	; 151
    7b86:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7b88:	81 30       	cpi	r24, 0x01	; 1
    7b8a:	31 f5       	brne	.+76     	; 0x7bd8 <systemGenerateReport+0xc66>
    7b8c:	ed b7       	in	r30, 0x3d	; 61
    7b8e:	fe b7       	in	r31, 0x3e	; 62
    7b90:	3c 97       	sbiw	r30, 0x0c	; 12
    7b92:	0f b6       	in	r0, 0x3f	; 63
    7b94:	f8 94       	cli
    7b96:	fe bf       	out	0x3e, r31	; 62
    7b98:	0f be       	out	0x3f, r0	; 63
    7b9a:	ed bf       	out	0x3d, r30	; 61
    7b9c:	6d b7       	in	r22, 0x3d	; 61
    7b9e:	7e b7       	in	r23, 0x3e	; 62
    7ba0:	6f 5f       	subi	r22, 0xFF	; 255
    7ba2:	7f 4f       	sbci	r23, 0xFF	; 255
    7ba4:	32 83       	std	Z+2, r19	; 0x02
    7ba6:	21 83       	std	Z+1, r18	; 0x01
    7ba8:	8e ee       	ldi	r24, 0xEE	; 238
    7baa:	95 e0       	ldi	r25, 0x05	; 5
    7bac:	fb 01       	movw	r30, r22
    7bae:	93 83       	std	Z+3, r25	; 0x03
    7bb0:	82 83       	std	Z+2, r24	; 0x02
    7bb2:	b5 83       	std	Z+5, r27	; 0x05
    7bb4:	a4 83       	std	Z+4, r26	; 0x04
    7bb6:	57 83       	std	Z+7, r21	; 0x07
    7bb8:	46 83       	std	Z+6, r20	; 0x06
    7bba:	ce 01       	movw	r24, r28
    7bbc:	83 58       	subi	r24, 0x83	; 131
    7bbe:	9f 4f       	sbci	r25, 0xFF	; 255
    7bc0:	91 87       	std	Z+9, r25	; 0x09
    7bc2:	80 87       	std	Z+8, r24	; 0x08
    7bc4:	ce 01       	movw	r24, r28
    7bc6:	88 96       	adiw	r24, 0x28	; 40
    7bc8:	93 87       	std	Z+11, r25	; 0x0b
    7bca:	82 87       	std	Z+10, r24	; 0x0a
    7bcc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    7bd0:	8d b7       	in	r24, 0x3d	; 61
    7bd2:	9e b7       	in	r25, 0x3e	; 62
    7bd4:	0c 96       	adiw	r24, 0x0c	; 12
    7bd6:	1c c0       	rjmp	.+56     	; 0x7c10 <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    7bd8:	ed b7       	in	r30, 0x3d	; 61
    7bda:	fe b7       	in	r31, 0x3e	; 62
    7bdc:	38 97       	sbiw	r30, 0x08	; 8
    7bde:	0f b6       	in	r0, 0x3f	; 63
    7be0:	f8 94       	cli
    7be2:	fe bf       	out	0x3e, r31	; 62
    7be4:	0f be       	out	0x3f, r0	; 63
    7be6:	ed bf       	out	0x3d, r30	; 61
    7be8:	6d b7       	in	r22, 0x3d	; 61
    7bea:	7e b7       	in	r23, 0x3e	; 62
    7bec:	6f 5f       	subi	r22, 0xFF	; 255
    7bee:	7f 4f       	sbci	r23, 0xFF	; 255
    7bf0:	32 83       	std	Z+2, r19	; 0x02
    7bf2:	21 83       	std	Z+1, r18	; 0x01
    7bf4:	83 ee       	ldi	r24, 0xE3	; 227
    7bf6:	95 e0       	ldi	r25, 0x05	; 5
    7bf8:	fb 01       	movw	r30, r22
    7bfa:	93 83       	std	Z+3, r25	; 0x03
    7bfc:	82 83       	std	Z+2, r24	; 0x02
    7bfe:	b5 83       	std	Z+5, r27	; 0x05
    7c00:	a4 83       	std	Z+4, r26	; 0x04
    7c02:	57 83       	std	Z+7, r21	; 0x07
    7c04:	46 83       	std	Z+6, r20	; 0x06
    7c06:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    7c0a:	8d b7       	in	r24, 0x3d	; 61
    7c0c:	9e b7       	in	r25, 0x3e	; 62
    7c0e:	08 96       	adiw	r24, 0x08	; 8
    7c10:	0f b6       	in	r0, 0x3f	; 63
    7c12:	f8 94       	cli
    7c14:	9e bf       	out	0x3e, r25	; 62
    7c16:	0f be       	out	0x3f, r0	; 63
    7c18:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    7c1a:	ce 01       	movw	r24, r28
    7c1c:	8b 55       	subi	r24, 0x5B	; 91
    7c1e:	9f 4f       	sbci	r25, 0xFF	; 255
    7c20:	6c ee       	ldi	r22, 0xEC	; 236
    7c22:	73 e0       	ldi	r23, 0x03	; 3
    7c24:	46 ed       	ldi	r20, 0xD6	; 214
    7c26:	51 e0       	ldi	r21, 0x01	; 1
    7c28:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>
    7c2c:	8e 01       	movw	r16, r28
    7c2e:	07 59       	subi	r16, 0x97	; 151
    7c30:	1f 4f       	sbci	r17, 0xFF	; 255
    7c32:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7c34:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7c36:	d8 01       	movw	r26, r16
    7c38:	c8 01       	movw	r24, r16
    7c3a:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    7c3c:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7c3e:	e8 17       	cp	r30, r24
    7c40:	f9 07       	cpc	r31, r25
    7c42:	e1 f7       	brne	.-8      	; 0x7c3c <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7c44:	1c 96       	adiw	r26, 0x0c	; 12
    7c46:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7c48:	e1 99       	sbic	0x1c, 1	; 28
    7c4a:	fe cf       	rjmp	.-4      	; 0x7c48 <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7c4c:	ff ba       	out	0x1f, r15	; 31
    7c4e:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7c50:	e0 9a       	sbi	0x1c, 0	; 28
    7c52:	8d b3       	in	r24, 0x1d	; 29
    7c54:	9e 01       	movw	r18, r28
    7c56:	2b 55       	subi	r18, 0x5B	; 91
    7c58:	3f 4f       	sbci	r19, 0xFF	; 255
    7c5a:	de 01       	movw	r26, r28
    7c5c:	a7 59       	subi	r26, 0x97	; 151
    7c5e:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    7c60:	81 30       	cpi	r24, 0x01	; 1
    7c62:	71 f4       	brne	.+28     	; 0x7c80 <systemGenerateReport+0xd0e>
    7c64:	00 d0       	rcall	.+0      	; 0x7c66 <systemGenerateReport+0xcf4>
    7c66:	00 d0       	rcall	.+0      	; 0x7c68 <systemGenerateReport+0xcf6>
    7c68:	00 d0       	rcall	.+0      	; 0x7c6a <systemGenerateReport+0xcf8>
    7c6a:	4d b7       	in	r20, 0x3d	; 61
    7c6c:	5e b7       	in	r21, 0x3e	; 62
    7c6e:	4f 5f       	subi	r20, 0xFF	; 255
    7c70:	5f 4f       	sbci	r21, 0xFF	; 255
    7c72:	ed b7       	in	r30, 0x3d	; 61
    7c74:	fe b7       	in	r31, 0x3e	; 62
    7c76:	32 83       	std	Z+2, r19	; 0x02
    7c78:	21 83       	std	Z+1, r18	; 0x01
    7c7a:	85 ec       	ldi	r24, 0xC5	; 197
    7c7c:	95 e0       	ldi	r25, 0x05	; 5
    7c7e:	0d c0       	rjmp	.+26     	; 0x7c9a <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    7c80:	00 d0       	rcall	.+0      	; 0x7c82 <systemGenerateReport+0xd10>
    7c82:	00 d0       	rcall	.+0      	; 0x7c84 <systemGenerateReport+0xd12>
    7c84:	00 d0       	rcall	.+0      	; 0x7c86 <systemGenerateReport+0xd14>
    7c86:	4d b7       	in	r20, 0x3d	; 61
    7c88:	5e b7       	in	r21, 0x3e	; 62
    7c8a:	4f 5f       	subi	r20, 0xFF	; 255
    7c8c:	5f 4f       	sbci	r21, 0xFF	; 255
    7c8e:	ed b7       	in	r30, 0x3d	; 61
    7c90:	fe b7       	in	r31, 0x3e	; 62
    7c92:	32 83       	std	Z+2, r19	; 0x02
    7c94:	21 83       	std	Z+1, r18	; 0x01
    7c96:	87 ea       	ldi	r24, 0xA7	; 167
    7c98:	95 e0       	ldi	r25, 0x05	; 5
    7c9a:	fa 01       	movw	r30, r20
    7c9c:	93 83       	std	Z+3, r25	; 0x03
    7c9e:	82 83       	std	Z+2, r24	; 0x02
    7ca0:	b5 83       	std	Z+5, r27	; 0x05
    7ca2:	a4 83       	std	Z+4, r26	; 0x04
    7ca4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    7ca8:	8d b7       	in	r24, 0x3d	; 61
    7caa:	9e b7       	in	r25, 0x3e	; 62
    7cac:	06 96       	adiw	r24, 0x06	; 6
    7cae:	0f b6       	in	r0, 0x3f	; 63
    7cb0:	f8 94       	cli
    7cb2:	9e bf       	out	0x3e, r25	; 62
    7cb4:	0f be       	out	0x3f, r0	; 63
    7cb6:	8d bf       	out	0x3d, r24	; 61
    7cb8:	ce 01       	movw	r24, r28
    7cba:	8b 55       	subi	r24, 0x5B	; 91
    7cbc:	9f 4f       	sbci	r25, 0xFF	; 255
    7cbe:	6c ee       	ldi	r22, 0xEC	; 236
    7cc0:	73 e0       	ldi	r23, 0x03	; 3
    7cc2:	46 ed       	ldi	r20, 0xD6	; 214
    7cc4:	51 e0       	ldi	r21, 0x01	; 1
    7cc6:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    7cca:	e5 e0       	ldi	r30, 0x05	; 5
    7ccc:	f9 e0       	ldi	r31, 0x09	; 9
    7cce:	01 90       	ld	r0, Z+
    7cd0:	00 20       	and	r0, r0
    7cd2:	e9 f7       	brne	.-6      	; 0x7cce <systemGenerateReport+0xd5c>
    7cd4:	31 97       	sbiw	r30, 0x01	; 1
    7cd6:	e5 50       	subi	r30, 0x05	; 5
    7cd8:	f9 40       	sbci	r31, 0x09	; 9
    7cda:	97 e1       	ldi	r25, 0x17	; 23
    7cdc:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7cde:	19 16       	cp	r1, r25
    7ce0:	84 f4       	brge	.+32     	; 0x7d02 <systemGenerateReport+0xd90>
    7ce2:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7ce4:	20 e2       	ldi	r18, 0x20	; 32
    7ce6:	04 c0       	rjmp	.+8      	; 0x7cf0 <systemGenerateReport+0xd7e>
    7ce8:	d8 01       	movw	r26, r16
    7cea:	2d 93       	st	X+, r18
    7cec:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7cee:	8f 5f       	subi	r24, 0xFF	; 255
    7cf0:	89 17       	cp	r24, r25
    7cf2:	d0 f3       	brcs	.-12     	; 0x7ce8 <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7cf4:	fe 01       	movw	r30, r28
    7cf6:	e7 59       	subi	r30, 0x97	; 151
    7cf8:	ff 4f       	sbci	r31, 0xFF	; 255
    7cfa:	e9 0f       	add	r30, r25
    7cfc:	f1 1d       	adc	r31, r1
    7cfe:	10 82       	st	Z, r1
    7d00:	06 c0       	rjmp	.+12     	; 0x7d0e <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    7d02:	fe 01       	movw	r30, r28
    7d04:	e7 59       	subi	r30, 0x97	; 151
    7d06:	ff 4f       	sbci	r31, 0xFF	; 255
    7d08:	80 e2       	ldi	r24, 0x20	; 32
    7d0a:	80 83       	st	Z, r24
	 strTab[1]=0;
    7d0c:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    7d0e:	ed e2       	ldi	r30, 0x2D	; 45
    7d10:	fc e0       	ldi	r31, 0x0C	; 12
    7d12:	01 90       	ld	r0, Z+
    7d14:	00 20       	and	r0, r0
    7d16:	e9 f7       	brne	.-6      	; 0x7d12 <systemGenerateReport+0xda0>
    7d18:	31 97       	sbiw	r30, 0x01	; 1
    7d1a:	ed 52       	subi	r30, 0x2D	; 45
    7d1c:	fc 40       	sbci	r31, 0x0C	; 12
    7d1e:	9f e0       	ldi	r25, 0x0F	; 15
    7d20:	9e 1b       	sub	r25, r30
    7d22:	fe 01       	movw	r30, r28
    7d24:	e3 58       	subi	r30, 0x83	; 131
    7d26:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7d28:	19 16       	cp	r1, r25
    7d2a:	74 f4       	brge	.+28     	; 0x7d48 <systemGenerateReport+0xdd6>
    7d2c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7d2e:	20 e2       	ldi	r18, 0x20	; 32
    7d30:	02 c0       	rjmp	.+4      	; 0x7d36 <systemGenerateReport+0xdc4>
    7d32:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7d34:	8f 5f       	subi	r24, 0xFF	; 255
    7d36:	89 17       	cp	r24, r25
    7d38:	e0 f3       	brcs	.-8      	; 0x7d32 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7d3a:	fe 01       	movw	r30, r28
    7d3c:	e3 58       	subi	r30, 0x83	; 131
    7d3e:	ff 4f       	sbci	r31, 0xFF	; 255
    7d40:	e9 0f       	add	r30, r25
    7d42:	f1 1d       	adc	r31, r1
    7d44:	10 82       	st	Z, r1
    7d46:	03 c0       	rjmp	.+6      	; 0x7d4e <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    7d48:	80 e2       	ldi	r24, 0x20	; 32
    7d4a:	80 83       	st	Z, r24
	 strTab[1]=0;
    7d4c:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7d4e:	e1 99       	sbic	0x1c, 1	; 28
    7d50:	fe cf       	rjmp	.-4      	; 0x7d4e <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7d52:	ff ba       	out	0x1f, r15	; 31
    7d54:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7d56:	e0 9a       	sbi	0x1c, 0	; 28
    7d58:	8d b3       	in	r24, 0x1d	; 29
    7d5a:	9e 01       	movw	r18, r28
    7d5c:	2b 55       	subi	r18, 0x5B	; 91
    7d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    7d60:	45 e0       	ldi	r20, 0x05	; 5
    7d62:	59 e0       	ldi	r21, 0x09	; 9
    7d64:	de 01       	movw	r26, r28
    7d66:	a7 59       	subi	r26, 0x97	; 151
    7d68:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7d6a:	81 30       	cpi	r24, 0x01	; 1
    7d6c:	31 f5       	brne	.+76     	; 0x7dba <systemGenerateReport+0xe48>
    7d6e:	ed b7       	in	r30, 0x3d	; 61
    7d70:	fe b7       	in	r31, 0x3e	; 62
    7d72:	3c 97       	sbiw	r30, 0x0c	; 12
    7d74:	0f b6       	in	r0, 0x3f	; 63
    7d76:	f8 94       	cli
    7d78:	fe bf       	out	0x3e, r31	; 62
    7d7a:	0f be       	out	0x3f, r0	; 63
    7d7c:	ed bf       	out	0x3d, r30	; 61
    7d7e:	6d b7       	in	r22, 0x3d	; 61
    7d80:	7e b7       	in	r23, 0x3e	; 62
    7d82:	6f 5f       	subi	r22, 0xFF	; 255
    7d84:	7f 4f       	sbci	r23, 0xFF	; 255
    7d86:	32 83       	std	Z+2, r19	; 0x02
    7d88:	21 83       	std	Z+1, r18	; 0x01
    7d8a:	8e e9       	ldi	r24, 0x9E	; 158
    7d8c:	95 e0       	ldi	r25, 0x05	; 5
    7d8e:	fb 01       	movw	r30, r22
    7d90:	93 83       	std	Z+3, r25	; 0x03
    7d92:	82 83       	std	Z+2, r24	; 0x02
    7d94:	b5 83       	std	Z+5, r27	; 0x05
    7d96:	a4 83       	std	Z+4, r26	; 0x04
    7d98:	57 83       	std	Z+7, r21	; 0x07
    7d9a:	46 83       	std	Z+6, r20	; 0x06
    7d9c:	ce 01       	movw	r24, r28
    7d9e:	83 58       	subi	r24, 0x83	; 131
    7da0:	9f 4f       	sbci	r25, 0xFF	; 255
    7da2:	91 87       	std	Z+9, r25	; 0x09
    7da4:	80 87       	std	Z+8, r24	; 0x08
    7da6:	8d e2       	ldi	r24, 0x2D	; 45
    7da8:	9c e0       	ldi	r25, 0x0C	; 12
    7daa:	93 87       	std	Z+11, r25	; 0x0b
    7dac:	82 87       	std	Z+10, r24	; 0x0a
    7dae:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    7db2:	8d b7       	in	r24, 0x3d	; 61
    7db4:	9e b7       	in	r25, 0x3e	; 62
    7db6:	0c 96       	adiw	r24, 0x0c	; 12
    7db8:	1c c0       	rjmp	.+56     	; 0x7df2 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7dba:	ed b7       	in	r30, 0x3d	; 61
    7dbc:	fe b7       	in	r31, 0x3e	; 62
    7dbe:	38 97       	sbiw	r30, 0x08	; 8
    7dc0:	0f b6       	in	r0, 0x3f	; 63
    7dc2:	f8 94       	cli
    7dc4:	fe bf       	out	0x3e, r31	; 62
    7dc6:	0f be       	out	0x3f, r0	; 63
    7dc8:	ed bf       	out	0x3d, r30	; 61
    7dca:	6d b7       	in	r22, 0x3d	; 61
    7dcc:	7e b7       	in	r23, 0x3e	; 62
    7dce:	6f 5f       	subi	r22, 0xFF	; 255
    7dd0:	7f 4f       	sbci	r23, 0xFF	; 255
    7dd2:	32 83       	std	Z+2, r19	; 0x02
    7dd4:	21 83       	std	Z+1, r18	; 0x01
    7dd6:	89 e9       	ldi	r24, 0x99	; 153
    7dd8:	95 e0       	ldi	r25, 0x05	; 5
    7dda:	fb 01       	movw	r30, r22
    7ddc:	93 83       	std	Z+3, r25	; 0x03
    7dde:	82 83       	std	Z+2, r24	; 0x02
    7de0:	b5 83       	std	Z+5, r27	; 0x05
    7de2:	a4 83       	std	Z+4, r26	; 0x04
    7de4:	57 83       	std	Z+7, r21	; 0x07
    7de6:	46 83       	std	Z+6, r20	; 0x06
    7de8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    7dec:	8d b7       	in	r24, 0x3d	; 61
    7dee:	9e b7       	in	r25, 0x3e	; 62
    7df0:	08 96       	adiw	r24, 0x08	; 8
    7df2:	0f b6       	in	r0, 0x3f	; 63
    7df4:	f8 94       	cli
    7df6:	9e bf       	out	0x3e, r25	; 62
    7df8:	0f be       	out	0x3f, r0	; 63
    7dfa:	8d bf       	out	0x3d, r24	; 61
    7dfc:	ce 01       	movw	r24, r28
    7dfe:	8b 55       	subi	r24, 0x5B	; 91
    7e00:	9f 4f       	sbci	r25, 0xFF	; 255
    7e02:	6c ee       	ldi	r22, 0xEC	; 236
    7e04:	73 e0       	ldi	r23, 0x03	; 3
    7e06:	46 ed       	ldi	r20, 0xD6	; 214
    7e08:	51 e0       	ldi	r21, 0x01	; 1
    7e0a:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7e0e:	87 e0       	ldi	r24, 0x07	; 7
    7e10:	6c ee       	ldi	r22, 0xEC	; 236
    7e12:	73 e0       	ldi	r23, 0x03	; 3
    7e14:	41 e0       	ldi	r20, 0x01	; 1
    7e16:	26 ed       	ldi	r18, 0xD6	; 214
    7e18:	31 e0       	ldi	r19, 0x01	; 1
    7e1a:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7e1e:	8b e0       	ldi	r24, 0x0B	; 11
    7e20:	6c ee       	ldi	r22, 0xEC	; 236
    7e22:	73 e0       	ldi	r23, 0x03	; 3
    7e24:	4a e2       	ldi	r20, 0x2A	; 42
    7e26:	26 ed       	ldi	r18, 0xD6	; 214
    7e28:	31 e0       	ldi	r19, 0x01	; 1
    7e2a:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7e2e:	89 e0       	ldi	r24, 0x09	; 9
    7e30:	6c ee       	ldi	r22, 0xEC	; 236
    7e32:	73 e0       	ldi	r23, 0x03	; 3
    7e34:	41 e0       	ldi	r20, 0x01	; 1
    7e36:	26 ed       	ldi	r18, 0xD6	; 214
    7e38:	31 e0       	ldi	r19, 0x01	; 1
    7e3a:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7e3e:	8c e0       	ldi	r24, 0x0C	; 12
    7e40:	6c ee       	ldi	r22, 0xEC	; 236
    7e42:	73 e0       	ldi	r23, 0x03	; 3
    7e44:	41 e0       	ldi	r20, 0x01	; 1
    7e46:	26 ed       	ldi	r18, 0xD6	; 214
    7e48:	31 e0       	ldi	r19, 0x01	; 1
    7e4a:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>


          cmdPrint=0b00000000;
    7e4e:	10 92 b5 01 	sts	0x01B5, r1
		  LengthMessage81=RepPos+1;
    7e52:	80 91 d6 01 	lds	r24, 0x01D6
    7e56:	90 91 d7 01 	lds	r25, 0x01D7
    7e5a:	01 96       	adiw	r24, 0x01	; 1
    7e5c:	90 93 8e 01 	sts	0x018E, r25
    7e60:	80 93 8d 01 	sts	0x018D, r24

		  IsFreePrinting=True;
    7e64:	81 e0       	ldi	r24, 0x01	; 1
    7e66:	80 93 a8 01 	sts	0x01A8, r24
	      IsBusyFreePrinting=True;
    7e6a:	80 93 b4 01 	sts	0x01B4, r24

	      stGenerateReport=grWaitPrinted2;
    7e6e:	89 e0       	ldi	r24, 0x09	; 9
    7e70:	91 c3       	rjmp	.+1826   	; 0x8594 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    7e72:	80 91 b4 01 	lds	r24, 0x01B4
    7e76:	88 23       	and	r24, r24
    7e78:	09 f0       	breq	.+2      	; 0x7e7c <systemGenerateReport+0xf0a>
    7e7a:	94 c3       	rjmp	.+1832   	; 0x85a4 <systemGenerateReport+0x1632>
    7e7c:	86 e0       	ldi	r24, 0x06	; 6
    7e7e:	8a c3       	rjmp	.+1812   	; 0x8594 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    7e80:	10 92 d7 01 	sts	0x01D7, r1
    7e84:	10 92 d6 01 	sts	0x01D6, r1
    7e88:	ec ee       	ldi	r30, 0xEC	; 236
    7e8a:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7e8c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7e8e:	95 e0       	ldi	r25, 0x05	; 5
    7e90:	ed 37       	cpi	r30, 0x7D	; 125
    7e92:	f9 07       	cpc	r31, r25
    7e94:	d9 f7       	brne	.-10     	; 0x7e8c <systemGenerateReport+0xf1a>
    7e96:	fe 01       	movw	r30, r28
    7e98:	eb 55       	subi	r30, 0x5B	; 91
    7e9a:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7e9c:	ce 01       	movw	r24, r28
    7e9e:	8b 50       	subi	r24, 0x0B	; 11
    7ea0:	9f 4f       	sbci	r25, 0xFF	; 255
    7ea2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7ea4:	e8 17       	cp	r30, r24
    7ea6:	f9 07       	cpc	r31, r25
    7ea8:	e1 f7       	brne	.-8      	; 0x7ea2 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    7eaa:	88 ea       	ldi	r24, 0xA8	; 168
    7eac:	98 e0       	ldi	r25, 0x08	; 8
    7eae:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    7eb2:	07 ef       	ldi	r16, 0xF7	; 247
    7eb4:	17 e0       	ldi	r17, 0x07	; 7
    7eb6:	c8 01       	movw	r24, r16
    7eb8:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    7ebc:	88 ea       	ldi	r24, 0xA8	; 168
    7ebe:	98 e0       	ldi	r25, 0x08	; 8
    7ec0:	0e 94 85 37 	call	0x6f0a	; 0x6f0a <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    7ec4:	88 ea       	ldi	r24, 0xA8	; 168
    7ec6:	98 e0       	ldi	r25, 0x08	; 8
    7ec8:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    7ecc:	c8 01       	movw	r24, r16
    7ece:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    7ed2:	c8 01       	movw	r24, r16
    7ed4:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    7ed8:	81 e0       	ldi	r24, 0x01	; 1
    7eda:	6c ee       	ldi	r22, 0xEC	; 236
    7edc:	73 e0       	ldi	r23, 0x03	; 3
    7ede:	41 e0       	ldi	r20, 0x01	; 1
    7ee0:	26 ed       	ldi	r18, 0xD6	; 214
    7ee2:	31 e0       	ldi	r19, 0x01	; 1
    7ee4:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7ee8:	8b e0       	ldi	r24, 0x0B	; 11
    7eea:	6c ee       	ldi	r22, 0xEC	; 236
    7eec:	73 e0       	ldi	r23, 0x03	; 3
    7eee:	4a e2       	ldi	r20, 0x2A	; 42
    7ef0:	26 ed       	ldi	r18, 0xD6	; 214
    7ef2:	31 e0       	ldi	r19, 0x01	; 1
    7ef4:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7ef8:	83 e0       	ldi	r24, 0x03	; 3
    7efa:	6c ee       	ldi	r22, 0xEC	; 236
    7efc:	73 e0       	ldi	r23, 0x03	; 3
    7efe:	41 e0       	ldi	r20, 0x01	; 1
    7f00:	26 ed       	ldi	r18, 0xD6	; 214
    7f02:	31 e0       	ldi	r19, 0x01	; 1
    7f04:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    7f08:	8c e0       	ldi	r24, 0x0C	; 12
    7f0a:	6c ee       	ldi	r22, 0xEC	; 236
    7f0c:	73 e0       	ldi	r23, 0x03	; 3
    7f0e:	41 e0       	ldi	r20, 0x01	; 1
    7f10:	26 ed       	ldi	r18, 0xD6	; 214
    7f12:	31 e0       	ldi	r19, 0x01	; 1
    7f14:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    7f18:	d8 01       	movw	r26, r16
    7f1a:	0d 90       	ld	r0, X+
    7f1c:	00 20       	and	r0, r0
    7f1e:	e9 f7       	brne	.-6      	; 0x7f1a <systemGenerateReport+0xfa8>
    7f20:	8d 01       	movw	r16, r26
    7f22:	01 50       	subi	r16, 0x01	; 1
    7f24:	10 40       	sbci	r17, 0x00	; 0
    7f26:	07 5f       	subi	r16, 0xF7	; 247
    7f28:	17 40       	sbci	r17, 0x07	; 7
    7f2a:	91 e1       	ldi	r25, 0x11	; 17
    7f2c:	90 1b       	sub	r25, r16
    7f2e:	de 01       	movw	r26, r28
    7f30:	a7 59       	subi	r26, 0x97	; 151
    7f32:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7f34:	19 16       	cp	r1, r25
    7f36:	7c f4       	brge	.+30     	; 0x7f56 <systemGenerateReport+0xfe4>
    7f38:	fd 01       	movw	r30, r26
    7f3a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7f3c:	20 e2       	ldi	r18, 0x20	; 32
    7f3e:	02 c0       	rjmp	.+4      	; 0x7f44 <systemGenerateReport+0xfd2>
    7f40:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7f42:	8f 5f       	subi	r24, 0xFF	; 255
    7f44:	89 17       	cp	r24, r25
    7f46:	e0 f3       	brcs	.-8      	; 0x7f40 <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7f48:	fe 01       	movw	r30, r28
    7f4a:	e7 59       	subi	r30, 0x97	; 151
    7f4c:	ff 4f       	sbci	r31, 0xFF	; 255
    7f4e:	e9 0f       	add	r30, r25
    7f50:	f1 1d       	adc	r31, r1
    7f52:	10 82       	st	Z, r1
    7f54:	04 c0       	rjmp	.+8      	; 0x7f5e <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    7f56:	80 e2       	ldi	r24, 0x20	; 32
    7f58:	8c 93       	st	X, r24
	 strTab[1]=0;
    7f5a:	11 96       	adiw	r26, 0x01	; 1
    7f5c:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7f5e:	e8 ea       	ldi	r30, 0xA8	; 168
    7f60:	f8 e0       	ldi	r31, 0x08	; 8
    7f62:	01 90       	ld	r0, Z+
    7f64:	00 20       	and	r0, r0
    7f66:	e9 f7       	brne	.-6      	; 0x7f62 <systemGenerateReport+0xff0>
    7f68:	31 97       	sbiw	r30, 0x01	; 1
    7f6a:	e8 5a       	subi	r30, 0xA8	; 168
    7f6c:	f8 40       	sbci	r31, 0x08	; 8
    7f6e:	9f e0       	ldi	r25, 0x0F	; 15
    7f70:	9e 1b       	sub	r25, r30
    7f72:	fe 01       	movw	r30, r28
    7f74:	e3 58       	subi	r30, 0x83	; 131
    7f76:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7f78:	19 16       	cp	r1, r25
    7f7a:	74 f4       	brge	.+28     	; 0x7f98 <systemGenerateReport+0x1026>
    7f7c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7f7e:	20 e2       	ldi	r18, 0x20	; 32
    7f80:	02 c0       	rjmp	.+4      	; 0x7f86 <systemGenerateReport+0x1014>
    7f82:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7f84:	8f 5f       	subi	r24, 0xFF	; 255
    7f86:	89 17       	cp	r24, r25
    7f88:	e0 f3       	brcs	.-8      	; 0x7f82 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7f8a:	fe 01       	movw	r30, r28
    7f8c:	e3 58       	subi	r30, 0x83	; 131
    7f8e:	ff 4f       	sbci	r31, 0xFF	; 255
    7f90:	e9 0f       	add	r30, r25
    7f92:	f1 1d       	adc	r31, r1
    7f94:	10 82       	st	Z, r1
    7f96:	03 c0       	rjmp	.+6      	; 0x7f9e <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    7f98:	80 e2       	ldi	r24, 0x20	; 32
    7f9a:	80 83       	st	Z, r24
	 strTab[1]=0;
    7f9c:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7f9e:	e1 99       	sbic	0x1c, 1	; 28
    7fa0:	fe cf       	rjmp	.-4      	; 0x7f9e <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7fa2:	e1 ec       	ldi	r30, 0xC1	; 193
    7fa4:	f3 e0       	ldi	r31, 0x03	; 3
    7fa6:	ff bb       	out	0x1f, r31	; 31
    7fa8:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7faa:	e0 9a       	sbi	0x1c, 0	; 28
    7fac:	8d b3       	in	r24, 0x1d	; 29
    7fae:	9e 01       	movw	r18, r28
    7fb0:	2b 55       	subi	r18, 0x5B	; 91
    7fb2:	3f 4f       	sbci	r19, 0xFF	; 255
    7fb4:	47 ef       	ldi	r20, 0xF7	; 247
    7fb6:	57 e0       	ldi	r21, 0x07	; 7
    7fb8:	de 01       	movw	r26, r28
    7fba:	a7 59       	subi	r26, 0x97	; 151
    7fbc:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7fbe:	81 30       	cpi	r24, 0x01	; 1
    7fc0:	41 f5       	brne	.+80     	; 0x8012 <systemGenerateReport+0x10a0>
    7fc2:	8d b7       	in	r24, 0x3d	; 61
    7fc4:	9e b7       	in	r25, 0x3e	; 62
    7fc6:	0c 97       	sbiw	r24, 0x0c	; 12
    7fc8:	0f b6       	in	r0, 0x3f	; 63
    7fca:	f8 94       	cli
    7fcc:	9e bf       	out	0x3e, r25	; 62
    7fce:	0f be       	out	0x3f, r0	; 63
    7fd0:	8d bf       	out	0x3d, r24	; 61
    7fd2:	6d b7       	in	r22, 0x3d	; 61
    7fd4:	7e b7       	in	r23, 0x3e	; 62
    7fd6:	6f 5f       	subi	r22, 0xFF	; 255
    7fd8:	7f 4f       	sbci	r23, 0xFF	; 255
    7fda:	ed b7       	in	r30, 0x3d	; 61
    7fdc:	fe b7       	in	r31, 0x3e	; 62
    7fde:	32 83       	std	Z+2, r19	; 0x02
    7fe0:	21 83       	std	Z+1, r18	; 0x01
    7fe2:	8a e8       	ldi	r24, 0x8A	; 138
    7fe4:	95 e0       	ldi	r25, 0x05	; 5
    7fe6:	fb 01       	movw	r30, r22
    7fe8:	93 83       	std	Z+3, r25	; 0x03
    7fea:	82 83       	std	Z+2, r24	; 0x02
    7fec:	b5 83       	std	Z+5, r27	; 0x05
    7fee:	a4 83       	std	Z+4, r26	; 0x04
    7ff0:	57 83       	std	Z+7, r21	; 0x07
    7ff2:	46 83       	std	Z+6, r20	; 0x06
    7ff4:	ce 01       	movw	r24, r28
    7ff6:	83 58       	subi	r24, 0x83	; 131
    7ff8:	9f 4f       	sbci	r25, 0xFF	; 255
    7ffa:	91 87       	std	Z+9, r25	; 0x09
    7ffc:	80 87       	std	Z+8, r24	; 0x08
    7ffe:	88 ea       	ldi	r24, 0xA8	; 168
    8000:	98 e0       	ldi	r25, 0x08	; 8
    8002:	93 87       	std	Z+11, r25	; 0x0b
    8004:	82 87       	std	Z+10, r24	; 0x0a
    8006:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    800a:	8d b7       	in	r24, 0x3d	; 61
    800c:	9e b7       	in	r25, 0x3e	; 62
    800e:	0c 96       	adiw	r24, 0x0c	; 12
    8010:	1c c0       	rjmp	.+56     	; 0x804a <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    8012:	ed b7       	in	r30, 0x3d	; 61
    8014:	fe b7       	in	r31, 0x3e	; 62
    8016:	38 97       	sbiw	r30, 0x08	; 8
    8018:	0f b6       	in	r0, 0x3f	; 63
    801a:	f8 94       	cli
    801c:	fe bf       	out	0x3e, r31	; 62
    801e:	0f be       	out	0x3f, r0	; 63
    8020:	ed bf       	out	0x3d, r30	; 61
    8022:	6d b7       	in	r22, 0x3d	; 61
    8024:	7e b7       	in	r23, 0x3e	; 62
    8026:	6f 5f       	subi	r22, 0xFF	; 255
    8028:	7f 4f       	sbci	r23, 0xFF	; 255
    802a:	32 83       	std	Z+2, r19	; 0x02
    802c:	21 83       	std	Z+1, r18	; 0x01
    802e:	8f e7       	ldi	r24, 0x7F	; 127
    8030:	95 e0       	ldi	r25, 0x05	; 5
    8032:	fb 01       	movw	r30, r22
    8034:	93 83       	std	Z+3, r25	; 0x03
    8036:	82 83       	std	Z+2, r24	; 0x02
    8038:	b5 83       	std	Z+5, r27	; 0x05
    803a:	a4 83       	std	Z+4, r26	; 0x04
    803c:	57 83       	std	Z+7, r21	; 0x07
    803e:	46 83       	std	Z+6, r20	; 0x06
    8040:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    8044:	8d b7       	in	r24, 0x3d	; 61
    8046:	9e b7       	in	r25, 0x3e	; 62
    8048:	08 96       	adiw	r24, 0x08	; 8
    804a:	0f b6       	in	r0, 0x3f	; 63
    804c:	f8 94       	cli
    804e:	9e bf       	out	0x3e, r25	; 62
    8050:	0f be       	out	0x3f, r0	; 63
    8052:	8d bf       	out	0x3d, r24	; 61
    8054:	ce 01       	movw	r24, r28
    8056:	8b 55       	subi	r24, 0x5B	; 91
    8058:	9f 4f       	sbci	r25, 0xFF	; 255
    805a:	6c ee       	ldi	r22, 0xEC	; 236
    805c:	73 e0       	ldi	r23, 0x03	; 3
    805e:	46 ed       	ldi	r20, 0xD6	; 214
    8060:	51 e0       	ldi	r21, 0x01	; 1
    8062:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    8066:	84 e0       	ldi	r24, 0x04	; 4
    8068:	6c ee       	ldi	r22, 0xEC	; 236
    806a:	73 e0       	ldi	r23, 0x03	; 3
    806c:	41 e0       	ldi	r20, 0x01	; 1
    806e:	26 ed       	ldi	r18, 0xD6	; 214
    8070:	31 e0       	ldi	r19, 0x01	; 1
    8072:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    8076:	8b e0       	ldi	r24, 0x0B	; 11
    8078:	6c ee       	ldi	r22, 0xEC	; 236
    807a:	73 e0       	ldi	r23, 0x03	; 3
    807c:	4a e2       	ldi	r20, 0x2A	; 42
    807e:	26 ed       	ldi	r18, 0xD6	; 214
    8080:	31 e0       	ldi	r19, 0x01	; 1
    8082:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    8086:	86 e0       	ldi	r24, 0x06	; 6
    8088:	6c ee       	ldi	r22, 0xEC	; 236
    808a:	73 e0       	ldi	r23, 0x03	; 3
    808c:	41 e0       	ldi	r20, 0x01	; 1
    808e:	26 ed       	ldi	r18, 0xD6	; 214
    8090:	31 e0       	ldi	r19, 0x01	; 1
    8092:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    8096:	8c e0       	ldi	r24, 0x0C	; 12
    8098:	6c ee       	ldi	r22, 0xEC	; 236
    809a:	73 e0       	ldi	r23, 0x03	; 3
    809c:	41 e0       	ldi	r20, 0x01	; 1
    809e:	26 ed       	ldi	r18, 0xD6	; 214
    80a0:	31 e0       	ldi	r19, 0x01	; 1
    80a2:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    80a6:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    80a8:	88 e2       	ldi	r24, 0x28	; 40
    80aa:	28 2e       	mov	r2, r24
    80ac:	31 2c       	mov	r3, r1
    80ae:	2c 0e       	add	r2, r28
    80b0:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    80b2:	07 e3       	ldi	r16, 0x37	; 55
    80b4:	60 2e       	mov	r6, r16
    80b6:	71 2c       	mov	r7, r1
    80b8:	6c 0e       	add	r6, r28
    80ba:	7d 1e       	adc	r7, r29
    80bc:	d3 01       	movw	r26, r6
    80be:	1f 96       	adiw	r26, 0x0f	; 15
    80c0:	cb 50       	subi	r28, 0x0B	; 11
    80c2:	df 4f       	sbci	r29, 0xFF	; 255
    80c4:	b9 83       	std	Y+1, r27	; 0x01
    80c6:	a8 83       	st	Y, r26
    80c8:	c5 5f       	subi	r28, 0xF5	; 245
    80ca:	d0 40       	sbci	r29, 0x00	; 0
    80cc:	16 e4       	ldi	r17, 0x46	; 70
    80ce:	41 2e       	mov	r4, r17
    80d0:	51 2c       	mov	r5, r1
    80d2:	4c 0e       	add	r4, r28
    80d4:	5d 1e       	adc	r5, r29
    80d6:	f2 01       	movw	r30, r4
    80d8:	3f 96       	adiw	r30, 0x0f	; 15
    80da:	c9 50       	subi	r28, 0x09	; 9
    80dc:	df 4f       	sbci	r29, 0xFF	; 255
    80de:	f9 83       	std	Y+1, r31	; 0x01
    80e0:	e8 83       	st	Y, r30
    80e2:	c7 5f       	subi	r28, 0xF7	; 247
    80e4:	d0 40       	sbci	r29, 0x00	; 0
    80e6:	bd e7       	ldi	r27, 0x7D	; 125
    80e8:	8b 2e       	mov	r8, r27
    80ea:	91 2c       	mov	r9, r1
    80ec:	8c 0e       	add	r8, r28
    80ee:	9d 1e       	adc	r9, r29
    80f0:	e3 c1       	rjmp	.+966    	; 0x84b8 <systemGenerateReport+0x1546>
    80f2:	f5 01       	movw	r30, r10
    80f4:	e8 52       	subi	r30, 0x28	; 40
    80f6:	fe 4f       	sbci	r31, 0xFE	; 254
    80f8:	80 81       	ld	r24, Z
    80fa:	80 53       	subi	r24, 0x30	; 48
    80fc:	8a 30       	cpi	r24, 0x0A	; 10
    80fe:	08 f0       	brcs	.+2      	; 0x8102 <systemGenerateReport+0x1190>
    8100:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    8102:	80 93 e5 01 	sts	0x01E5, r24
			  if (xGrade>0){
    8106:	88 23       	and	r24, r24
    8108:	09 f4       	brne	.+2      	; 0x810c <systemGenerateReport+0x119a>
    810a:	d5 c1       	rjmp	.+938    	; 0x84b6 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    810c:	6e e5       	ldi	r22, 0x5E	; 94
    810e:	77 e0       	ldi	r23, 0x07	; 7
    8110:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <GetProductName>
    8114:	e7 ef       	ldi	r30, 0xF7	; 247
    8116:	f7 e0       	ldi	r31, 0x07	; 7
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    8118:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    811a:	88 e0       	ldi	r24, 0x08	; 8
    811c:	eb 30       	cpi	r30, 0x0B	; 11
    811e:	f8 07       	cpc	r31, r24
    8120:	d9 f7       	brne	.-10     	; 0x8118 <systemGenerateReport+0x11a6>
    8122:	e8 ea       	ldi	r30, 0xA8	; 168
    8124:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
    8126:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8128:	98 e0       	ldi	r25, 0x08	; 8
    812a:	ec 3b       	cpi	r30, 0xBC	; 188
    812c:	f9 07       	cpc	r31, r25
    812e:	d9 f7       	brne	.-10     	; 0x8126 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    8130:	81 e0       	ldi	r24, 0x01	; 1
    8132:	80 93 e7 01 	sts	0x01E7, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8136:	a9 e1       	ldi	r26, 0x19	; 25
    8138:	ca 2e       	mov	r12, r26
    813a:	d1 2c       	mov	r13, r1
    813c:	cc 0e       	add	r12, r28
    813e:	dd 1e       	adc	r13, r29
    8140:	e6 c0       	rjmp	.+460    	; 0x830e <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8142:	ce 01       	movw	r24, r28
    8144:	07 96       	adiw	r24, 0x07	; 7
    8146:	65 e4       	ldi	r22, 0x45	; 69
    8148:	70 e0       	ldi	r23, 0x00	; 0
    814a:	48 e0       	ldi	r20, 0x08	; 8
    814c:	50 e0       	ldi	r21, 0x00	; 0
    814e:	22 ed       	ldi	r18, 0xD2	; 210
    8150:	33 e1       	ldi	r19, 0x13	; 19
    8152:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    8156:	80 91 e7 01 	lds	r24, 0x01E7
    815a:	fe 01       	movw	r30, r28
    815c:	e8 0f       	add	r30, r24
    815e:	f1 1d       	adc	r31, r1
    8160:	86 81       	ldd	r24, Z+6	; 0x06
    8162:	80 93 e4 01 	sts	0x01E4, r24
					  if (PumpNum>0){
    8166:	88 23       	and	r24, r24
    8168:	09 f4       	brne	.+2      	; 0x816c <systemGenerateReport+0x11fa>
    816a:	cc c0       	rjmp	.+408    	; 0x8304 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    816c:	81 e0       	ldi	r24, 0x01	; 1
    816e:	c3 c0       	rjmp	.+390    	; 0x82f6 <systemGenerateReport+0x1384>
    8170:	60 91 e7 01 	lds	r22, 0x01E7
    8174:	a6 e0       	ldi	r26, 0x06	; 6
    8176:	6a 9f       	mul	r22, r26
    8178:	b0 01       	movw	r22, r0
    817a:	11 24       	eor	r1, r1
    817c:	61 5b       	subi	r22, 0xB1	; 177
    817e:	7f 4f       	sbci	r23, 0xFF	; 255
    8180:	ce 01       	movw	r24, r28
    8182:	01 96       	adiw	r24, 0x01	; 1
    8184:	46 e0       	ldi	r20, 0x06	; 6
    8186:	50 e0       	ldi	r21, 0x00	; 0
    8188:	22 ed       	ldi	r18, 0xD2	; 210
    818a:	33 e1       	ldi	r19, 0x13	; 19
    818c:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    8190:	80 91 e6 01 	lds	r24, 0x01E6
    8194:	fe 01       	movw	r30, r28
    8196:	e8 0f       	add	r30, r24
    8198:	f1 1d       	adc	r31, r1
    819a:	90 81       	ld	r25, Z
    819c:	80 91 e5 01 	lds	r24, 0x01E5
    81a0:	98 17       	cp	r25, r24
    81a2:	09 f0       	breq	.+2      	; 0x81a6 <systemGenerateReport+0x1234>
    81a4:	a5 c0       	rjmp	.+330    	; 0x82f0 <systemGenerateReport+0x137e>
    81a6:	ed e2       	ldi	r30, 0x2D	; 45
    81a8:	fc e0       	ldi	r31, 0x0C	; 12
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    81aa:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    81ac:	bc e0       	ldi	r27, 0x0C	; 12
    81ae:	ec 33       	cpi	r30, 0x3C	; 60
    81b0:	fb 07       	cpc	r31, r27
    81b2:	d9 f7       	brne	.-10     	; 0x81aa <systemGenerateReport+0x1238>
    81b4:	e5 e0       	ldi	r30, 0x05	; 5
    81b6:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    81b8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    81ba:	89 e0       	ldi	r24, 0x09	; 9
    81bc:	e4 31       	cpi	r30, 0x14	; 20
    81be:	f8 07       	cpc	r31, r24
    81c0:	d9 f7       	brne	.-10     	; 0x81b8 <systemGenerateReport+0x1246>
    81c2:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    81c4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    81c6:	e2 15       	cp	r30, r2
    81c8:	f3 05       	cpc	r31, r3
    81ca:	e1 f7       	brne	.-8      	; 0x81c4 <systemGenerateReport+0x1252>
    81cc:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    81ce:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    81d0:	e6 15       	cp	r30, r6
    81d2:	f7 05       	cpc	r31, r7
    81d4:	e1 f7       	brne	.-8      	; 0x81ce <systemGenerateReport+0x125c>
    81d6:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    81d8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    81da:	cb 50       	subi	r28, 0x0B	; 11
    81dc:	df 4f       	sbci	r29, 0xFF	; 255
    81de:	a8 81       	ld	r26, Y
    81e0:	b9 81       	ldd	r27, Y+1	; 0x01
    81e2:	c5 5f       	subi	r28, 0xF5	; 245
    81e4:	d0 40       	sbci	r29, 0x00	; 0
    81e6:	ea 17       	cp	r30, r26
    81e8:	fb 07       	cpc	r31, r27
    81ea:	b1 f7       	brne	.-20     	; 0x81d8 <systemGenerateReport+0x1266>
    81ec:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    81ee:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    81f0:	c9 50       	subi	r28, 0x09	; 9
    81f2:	df 4f       	sbci	r29, 0xFF	; 255
    81f4:	88 81       	ld	r24, Y
    81f6:	99 81       	ldd	r25, Y+1	; 0x01
    81f8:	c7 5f       	subi	r28, 0xF7	; 247
    81fa:	d0 40       	sbci	r29, 0x00	; 0
    81fc:	e8 17       	cp	r30, r24
    81fe:	f9 07       	cpc	r31, r25
    8200:	b1 f7       	brne	.-20     	; 0x81ee <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    8202:	80 91 e6 01 	lds	r24, 0x01E6
    8206:	80 93 e3 01 	sts	0x01E3, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    820a:	80 91 e4 01 	lds	r24, 0x01E4
    820e:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
								  if (FIPAddr>0){
    8212:	88 23       	and	r24, r24
    8214:	11 f1       	breq	.+68     	; 0x825a <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    8216:	f8 2e       	mov	r15, r24
    8218:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    821a:	80 e0       	ldi	r24, 0x00	; 0
    821c:	60 e0       	ldi	r22, 0x00	; 0
    821e:	4f 2d       	mov	r20, r15
    8220:	20 91 e3 01 	lds	r18, 0x01E3
    8224:	86 01       	movw	r16, r12
    8226:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    822a:	81 e0       	ldi	r24, 0x01	; 1
    822c:	60 e0       	ldi	r22, 0x00	; 0
    822e:	4f 2d       	mov	r20, r15
    8230:	20 91 e3 01 	lds	r18, 0x01E3
    8234:	81 01       	movw	r16, r2
    8236:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    823a:	80 e0       	ldi	r24, 0x00	; 0
    823c:	61 e0       	ldi	r22, 0x01	; 1
    823e:	4f 2d       	mov	r20, r15
    8240:	20 91 e3 01 	lds	r18, 0x01E3
    8244:	83 01       	movw	r16, r6
    8246:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    824a:	81 e0       	ldi	r24, 0x01	; 1
    824c:	61 e0       	ldi	r22, 0x01	; 1
    824e:	4f 2d       	mov	r20, r15
    8250:	20 91 e3 01 	lds	r18, 0x01E3
    8254:	82 01       	movw	r16, r4
    8256:	0e 94 0f 22 	call	0x441e	; 0x441e <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    825a:	80 e0       	ldi	r24, 0x00	; 0
    825c:	b3 01       	movw	r22, r6
    825e:	a6 01       	movw	r20, r12
    8260:	25 e0       	ldi	r18, 0x05	; 5
    8262:	39 e0       	ldi	r19, 0x09	; 9
    8264:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    8268:	85 e0       	ldi	r24, 0x05	; 5
    826a:	99 e0       	ldi	r25, 0x09	; 9
    826c:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <IsMinus>
    8270:	81 30       	cpi	r24, 0x01	; 1
    8272:	21 f4       	brne	.+8      	; 0x827c <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    8274:	85 e0       	ldi	r24, 0x05	; 5
    8276:	99 e0       	ldi	r25, 0x09	; 9
    8278:	0e 94 29 30 	call	0x6052	; 0x6052 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    827c:	e1 99       	sbic	0x1c, 1	; 28
    827e:	fe cf       	rjmp	.-4      	; 0x827c <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8280:	a7 e3       	ldi	r26, 0x37	; 55
    8282:	b1 e0       	ldi	r27, 0x01	; 1
    8284:	bf bb       	out	0x1f, r27	; 31
    8286:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8288:	e0 9a       	sbi	0x1c, 0	; 28
    828a:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    828c:	82 30       	cpi	r24, 0x02	; 2
    828e:	79 f4       	brne	.+30     	; 0x82ae <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    8290:	ce 01       	movw	r24, r28
    8292:	0f 96       	adiw	r24, 0x0f	; 15
    8294:	60 91 e4 01 	lds	r22, 0x01E4
    8298:	40 91 e3 01 	lds	r20, 0x01E3
    829c:	0e 94 70 27 	call	0x4ee0	; 0x4ee0 <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    82a0:	82 e0       	ldi	r24, 0x02	; 2
    82a2:	be 01       	movw	r22, r28
    82a4:	61 5f       	subi	r22, 0xF1	; 241
    82a6:	7f 4f       	sbci	r23, 0xFF	; 255
    82a8:	45 e0       	ldi	r20, 0x05	; 5
    82aa:	59 e0       	ldi	r21, 0x09	; 9
    82ac:	03 c0       	rjmp	.+6      	; 0x82b4 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    82ae:	80 e0       	ldi	r24, 0x00	; 0
    82b0:	b2 01       	movw	r22, r4
    82b2:	a1 01       	movw	r20, r2
    82b4:	2d e2       	ldi	r18, 0x2D	; 45
    82b6:	3c e0       	ldi	r19, 0x0C	; 12
    82b8:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    82bc:	8d e2       	ldi	r24, 0x2D	; 45
    82be:	9c e0       	ldi	r25, 0x0C	; 12
    82c0:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <IsMinus>
    82c4:	81 30       	cpi	r24, 0x01	; 1
    82c6:	21 f4       	brne	.+8      	; 0x82d0 <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    82c8:	8d e2       	ldi	r24, 0x2D	; 45
    82ca:	9c e0       	ldi	r25, 0x0C	; 12
    82cc:	0e 94 29 30 	call	0x6052	; 0x6052 <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    82d0:	81 e0       	ldi	r24, 0x01	; 1
    82d2:	67 ef       	ldi	r22, 0xF7	; 247
    82d4:	77 e0       	ldi	r23, 0x07	; 7
    82d6:	45 e0       	ldi	r20, 0x05	; 5
    82d8:	59 e0       	ldi	r21, 0x09	; 9
    82da:	9b 01       	movw	r18, r22
    82dc:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    82e0:	81 e0       	ldi	r24, 0x01	; 1
    82e2:	68 ea       	ldi	r22, 0xA8	; 168
    82e4:	78 e0       	ldi	r23, 0x08	; 8
    82e6:	4d e2       	ldi	r20, 0x2D	; 45
    82e8:	5c e0       	ldi	r21, 0x0C	; 12
    82ea:	9b 01       	movw	r18, r22
    82ec:	0e 94 92 2c 	call	0x5924	; 0x5924 <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    82f0:	80 91 e6 01 	lds	r24, 0x01E6
    82f4:	8f 5f       	subi	r24, 0xFF	; 255
    82f6:	80 93 e6 01 	sts	0x01E6, r24
    82fa:	80 91 e6 01 	lds	r24, 0x01E6
    82fe:	87 30       	cpi	r24, 0x07	; 7
    8300:	08 f4       	brcc	.+2      	; 0x8304 <systemGenerateReport+0x1392>
    8302:	36 cf       	rjmp	.-404    	; 0x8170 <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    8304:	80 91 e7 01 	lds	r24, 0x01E7
    8308:	8f 5f       	subi	r24, 0xFF	; 255
    830a:	80 93 e7 01 	sts	0x01E7, r24
    830e:	80 91 e7 01 	lds	r24, 0x01E7
    8312:	89 30       	cpi	r24, 0x09	; 9
    8314:	08 f4       	brcc	.+2      	; 0x8318 <systemGenerateReport+0x13a6>
    8316:	15 cf       	rjmp	.-470    	; 0x8142 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    8318:	88 ea       	ldi	r24, 0xA8	; 168
    831a:	98 e0       	ldi	r25, 0x08	; 8
    831c:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    8320:	07 ef       	ldi	r16, 0xF7	; 247
    8322:	17 e0       	ldi	r17, 0x07	; 7
    8324:	c8 01       	movw	r24, r16
    8326:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    832a:	88 ea       	ldi	r24, 0xA8	; 168
    832c:	98 e0       	ldi	r25, 0x08	; 8
    832e:	0e 94 85 37 	call	0x6f0a	; 0x6f0a <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    8332:	88 ea       	ldi	r24, 0xA8	; 168
    8334:	98 e0       	ldi	r25, 0x08	; 8
    8336:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    833a:	c8 01       	movw	r24, r16
    833c:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    8340:	c8 01       	movw	r24, r16
    8342:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    8346:	ee e5       	ldi	r30, 0x5E	; 94
    8348:	f7 e0       	ldi	r31, 0x07	; 7
    834a:	01 90       	ld	r0, Z+
    834c:	00 20       	and	r0, r0
    834e:	e9 f7       	brne	.-6      	; 0x834a <systemGenerateReport+0x13d8>
    8350:	31 97       	sbiw	r30, 0x01	; 1
    8352:	ee 55       	subi	r30, 0x5E	; 94
    8354:	f7 40       	sbci	r31, 0x07	; 7
    8356:	d8 01       	movw	r26, r16
    8358:	0d 90       	ld	r0, X+
    835a:	00 20       	and	r0, r0
    835c:	e9 f7       	brne	.-6      	; 0x8358 <systemGenerateReport+0x13e6>
    835e:	8d 01       	movw	r16, r26
    8360:	01 50       	subi	r16, 0x01	; 1
    8362:	10 40       	sbci	r17, 0x00	; 0
    8364:	07 5f       	subi	r16, 0xF7	; 247
    8366:	17 40       	sbci	r17, 0x07	; 7
    8368:	8e 2f       	mov	r24, r30
    836a:	81 95       	neg	r24
    836c:	80 1b       	sub	r24, r16
    836e:	8b 5e       	subi	r24, 0xEB	; 235
    8370:	de 01       	movw	r26, r28
    8372:	a7 59       	subi	r26, 0x97	; 151
    8374:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    8376:	18 16       	cp	r1, r24
    8378:	7c f4       	brge	.+30     	; 0x8398 <systemGenerateReport+0x1426>
    837a:	fd 01       	movw	r30, r26
    837c:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    837e:	20 e2       	ldi	r18, 0x20	; 32
    8380:	02 c0       	rjmp	.+4      	; 0x8386 <systemGenerateReport+0x1414>
    8382:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    8384:	9f 5f       	subi	r25, 0xFF	; 255
    8386:	98 17       	cp	r25, r24
    8388:	e0 f3       	brcs	.-8      	; 0x8382 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    838a:	fe 01       	movw	r30, r28
    838c:	e7 59       	subi	r30, 0x97	; 151
    838e:	ff 4f       	sbci	r31, 0xFF	; 255
    8390:	e8 0f       	add	r30, r24
    8392:	f1 1d       	adc	r31, r1
    8394:	10 82       	st	Z, r1
    8396:	04 c0       	rjmp	.+8      	; 0x83a0 <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    8398:	80 e2       	ldi	r24, 0x20	; 32
    839a:	8c 93       	st	X, r24
	 strTab[1]=0;
    839c:	11 96       	adiw	r26, 0x01	; 1
    839e:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    83a0:	e8 ea       	ldi	r30, 0xA8	; 168
    83a2:	f8 e0       	ldi	r31, 0x08	; 8
    83a4:	01 90       	ld	r0, Z+
    83a6:	00 20       	and	r0, r0
    83a8:	e9 f7       	brne	.-6      	; 0x83a4 <systemGenerateReport+0x1432>
    83aa:	31 97       	sbiw	r30, 0x01	; 1
    83ac:	e8 5a       	subi	r30, 0xA8	; 168
    83ae:	f8 40       	sbci	r31, 0x08	; 8
    83b0:	9f e0       	ldi	r25, 0x0F	; 15
    83b2:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    83b4:	19 16       	cp	r1, r25
    83b6:	6c f4       	brge	.+26     	; 0x83d2 <systemGenerateReport+0x1460>
    83b8:	f4 01       	movw	r30, r8
    83ba:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    83bc:	20 e2       	ldi	r18, 0x20	; 32
    83be:	02 c0       	rjmp	.+4      	; 0x83c4 <systemGenerateReport+0x1452>
    83c0:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    83c2:	8f 5f       	subi	r24, 0xFF	; 255
    83c4:	89 17       	cp	r24, r25
    83c6:	e0 f3       	brcs	.-8      	; 0x83c0 <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    83c8:	f4 01       	movw	r30, r8
    83ca:	e9 0f       	add	r30, r25
    83cc:	f1 1d       	adc	r31, r1
    83ce:	10 82       	st	Z, r1
    83d0:	04 c0       	rjmp	.+8      	; 0x83da <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    83d2:	80 e2       	ldi	r24, 0x20	; 32
    83d4:	f4 01       	movw	r30, r8
    83d6:	80 83       	st	Z, r24
	 strTab[1]=0;
    83d8:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    83da:	e1 99       	sbic	0x1c, 1	; 28
    83dc:	fe cf       	rjmp	.-4      	; 0x83da <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    83de:	81 ec       	ldi	r24, 0xC1	; 193
    83e0:	93 e0       	ldi	r25, 0x03	; 3
    83e2:	9f bb       	out	0x1f, r25	; 31
    83e4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    83e6:	e0 9a       	sbi	0x1c, 0	; 28
    83e8:	8d b3       	in	r24, 0x1d	; 29
    83ea:	9e 01       	movw	r18, r28
    83ec:	2b 55       	subi	r18, 0x5B	; 91
    83ee:	3f 4f       	sbci	r19, 0xFF	; 255
    83f0:	47 ef       	ldi	r20, 0xF7	; 247
    83f2:	57 e0       	ldi	r21, 0x07	; 7
    83f4:	fe e5       	ldi	r31, 0x5E	; 94
    83f6:	cf 2e       	mov	r12, r31
    83f8:	f7 e0       	ldi	r31, 0x07	; 7
    83fa:	df 2e       	mov	r13, r31
    83fc:	de 01       	movw	r26, r28
    83fe:	a7 59       	subi	r26, 0x97	; 151
    8400:	bf 4f       	sbci	r27, 0xFF	; 255
    8402:	b5 01       	movw	r22, r10
    8404:	6f 5f       	subi	r22, 0xFF	; 255
    8406:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    8408:	81 30       	cpi	r24, 0x01	; 1
    840a:	39 f5       	brne	.+78     	; 0x845a <systemGenerateReport+0x14e8>
    840c:	ed b7       	in	r30, 0x3d	; 61
    840e:	fe b7       	in	r31, 0x3e	; 62
    8410:	70 97       	sbiw	r30, 0x10	; 16
    8412:	0f b6       	in	r0, 0x3f	; 63
    8414:	f8 94       	cli
    8416:	fe bf       	out	0x3e, r31	; 62
    8418:	0f be       	out	0x3f, r0	; 63
    841a:	ed bf       	out	0x3d, r30	; 61
    841c:	0d b7       	in	r16, 0x3d	; 61
    841e:	1e b7       	in	r17, 0x3e	; 62
    8420:	0f 5f       	subi	r16, 0xFF	; 255
    8422:	1f 4f       	sbci	r17, 0xFF	; 255
    8424:	32 83       	std	Z+2, r19	; 0x02
    8426:	21 83       	std	Z+1, r18	; 0x01
    8428:	81 e7       	ldi	r24, 0x71	; 113
    842a:	95 e0       	ldi	r25, 0x05	; 5
    842c:	f8 01       	movw	r30, r16
    842e:	93 83       	std	Z+3, r25	; 0x03
    8430:	82 83       	std	Z+2, r24	; 0x02
    8432:	75 83       	std	Z+5, r23	; 0x05
    8434:	64 83       	std	Z+4, r22	; 0x04
    8436:	d7 82       	std	Z+7, r13	; 0x07
    8438:	c6 82       	std	Z+6, r12	; 0x06
    843a:	b1 87       	std	Z+9, r27	; 0x09
    843c:	a0 87       	std	Z+8, r26	; 0x08
    843e:	53 87       	std	Z+11, r21	; 0x0b
    8440:	42 87       	std	Z+10, r20	; 0x0a
    8442:	95 86       	std	Z+13, r9	; 0x0d
    8444:	84 86       	std	Z+12, r8	; 0x0c
    8446:	88 ea       	ldi	r24, 0xA8	; 168
    8448:	98 e0       	ldi	r25, 0x08	; 8
    844a:	97 87       	std	Z+15, r25	; 0x0f
    844c:	86 87       	std	Z+14, r24	; 0x0e
    844e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    8452:	8d b7       	in	r24, 0x3d	; 61
    8454:	9e b7       	in	r25, 0x3e	; 62
    8456:	40 96       	adiw	r24, 0x10	; 16
    8458:	20 c0       	rjmp	.+64     	; 0x849a <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    845a:	ed b7       	in	r30, 0x3d	; 61
    845c:	fe b7       	in	r31, 0x3e	; 62
    845e:	3c 97       	sbiw	r30, 0x0c	; 12
    8460:	0f b6       	in	r0, 0x3f	; 63
    8462:	f8 94       	cli
    8464:	fe bf       	out	0x3e, r31	; 62
    8466:	0f be       	out	0x3f, r0	; 63
    8468:	ed bf       	out	0x3d, r30	; 61
    846a:	0d b7       	in	r16, 0x3d	; 61
    846c:	1e b7       	in	r17, 0x3e	; 62
    846e:	0f 5f       	subi	r16, 0xFF	; 255
    8470:	1f 4f       	sbci	r17, 0xFF	; 255
    8472:	32 83       	std	Z+2, r19	; 0x02
    8474:	21 83       	std	Z+1, r18	; 0x01
    8476:	87 e6       	ldi	r24, 0x67	; 103
    8478:	95 e0       	ldi	r25, 0x05	; 5
    847a:	f8 01       	movw	r30, r16
    847c:	93 83       	std	Z+3, r25	; 0x03
    847e:	82 83       	std	Z+2, r24	; 0x02
    8480:	75 83       	std	Z+5, r23	; 0x05
    8482:	64 83       	std	Z+4, r22	; 0x04
    8484:	d7 82       	std	Z+7, r13	; 0x07
    8486:	c6 82       	std	Z+6, r12	; 0x06
    8488:	b1 87       	std	Z+9, r27	; 0x09
    848a:	a0 87       	std	Z+8, r26	; 0x08
    848c:	53 87       	std	Z+11, r21	; 0x0b
    848e:	42 87       	std	Z+10, r20	; 0x0a
    8490:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    8494:	8d b7       	in	r24, 0x3d	; 61
    8496:	9e b7       	in	r25, 0x3e	; 62
    8498:	0c 96       	adiw	r24, 0x0c	; 12
    849a:	0f b6       	in	r0, 0x3f	; 63
    849c:	f8 94       	cli
    849e:	9e bf       	out	0x3e, r25	; 62
    84a0:	0f be       	out	0x3f, r0	; 63
    84a2:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    84a4:	ce 01       	movw	r24, r28
    84a6:	8b 55       	subi	r24, 0x5B	; 91
    84a8:	9f 4f       	sbci	r25, 0xFF	; 255
    84aa:	6c ee       	ldi	r22, 0xEC	; 236
    84ac:	73 e0       	ldi	r23, 0x03	; 3
    84ae:	46 ed       	ldi	r20, 0xD6	; 214
    84b0:	51 e0       	ldi	r21, 0x01	; 1
    84b2:	0e 94 28 25 	call	0x4a50	; 0x4a50 <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    84b6:	e3 94       	inc	r14
    84b8:	e8 ed       	ldi	r30, 0xD8	; 216
    84ba:	f1 e0       	ldi	r31, 0x01	; 1
    84bc:	01 90       	ld	r0, Z+
    84be:	00 20       	and	r0, r0
    84c0:	e9 f7       	brne	.-6      	; 0x84bc <systemGenerateReport+0x154a>
    84c2:	31 97       	sbiw	r30, 0x01	; 1
    84c4:	e8 5d       	subi	r30, 0xD8	; 216
    84c6:	f1 40       	sbci	r31, 0x01	; 1
    84c8:	ae 2c       	mov	r10, r14
    84ca:	bb 24       	eor	r11, r11
    84cc:	ae 16       	cp	r10, r30
    84ce:	bf 06       	cpc	r11, r31
    84d0:	08 f4       	brcc	.+2      	; 0x84d4 <systemGenerateReport+0x1562>
    84d2:	0f ce       	rjmp	.-994    	; 0x80f2 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    84d4:	87 e0       	ldi	r24, 0x07	; 7
    84d6:	6c ee       	ldi	r22, 0xEC	; 236
    84d8:	73 e0       	ldi	r23, 0x03	; 3
    84da:	41 e0       	ldi	r20, 0x01	; 1
    84dc:	26 ed       	ldi	r18, 0xD6	; 214
    84de:	31 e0       	ldi	r19, 0x01	; 1
    84e0:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    84e4:	8b e0       	ldi	r24, 0x0B	; 11
    84e6:	6c ee       	ldi	r22, 0xEC	; 236
    84e8:	73 e0       	ldi	r23, 0x03	; 3
    84ea:	4a e2       	ldi	r20, 0x2A	; 42
    84ec:	26 ed       	ldi	r18, 0xD6	; 214
    84ee:	31 e0       	ldi	r19, 0x01	; 1
    84f0:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    84f4:	89 e0       	ldi	r24, 0x09	; 9
    84f6:	6c ee       	ldi	r22, 0xEC	; 236
    84f8:	73 e0       	ldi	r23, 0x03	; 3
    84fa:	41 e0       	ldi	r20, 0x01	; 1
    84fc:	26 ed       	ldi	r18, 0xD6	; 214
    84fe:	31 e0       	ldi	r19, 0x01	; 1
    8500:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    8504:	8c e0       	ldi	r24, 0x0C	; 12
    8506:	6c ee       	ldi	r22, 0xEC	; 236
    8508:	73 e0       	ldi	r23, 0x03	; 3
    850a:	41 e0       	ldi	r20, 0x01	; 1
    850c:	26 ed       	ldi	r18, 0xD6	; 214
    850e:	31 e0       	ldi	r19, 0x01	; 1
    8510:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    8514:	8c e0       	ldi	r24, 0x0C	; 12
    8516:	6c ee       	ldi	r22, 0xEC	; 236
    8518:	73 e0       	ldi	r23, 0x03	; 3
    851a:	41 e0       	ldi	r20, 0x01	; 1
    851c:	26 ed       	ldi	r18, 0xD6	; 214
    851e:	31 e0       	ldi	r19, 0x01	; 1
    8520:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    8524:	8c e0       	ldi	r24, 0x0C	; 12
    8526:	6c ee       	ldi	r22, 0xEC	; 236
    8528:	73 e0       	ldi	r23, 0x03	; 3
    852a:	41 e0       	ldi	r20, 0x01	; 1
    852c:	26 ed       	ldi	r18, 0xD6	; 214
    852e:	31 e0       	ldi	r19, 0x01	; 1
    8530:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    8534:	8c e0       	ldi	r24, 0x0C	; 12
    8536:	6c ee       	ldi	r22, 0xEC	; 236
    8538:	73 e0       	ldi	r23, 0x03	; 3
    853a:	41 e0       	ldi	r20, 0x01	; 1
    853c:	26 ed       	ldi	r18, 0xD6	; 214
    853e:	31 e0       	ldi	r19, 0x01	; 1
    8540:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    8544:	8c e0       	ldi	r24, 0x0C	; 12
    8546:	6c ee       	ldi	r22, 0xEC	; 236
    8548:	73 e0       	ldi	r23, 0x03	; 3
    854a:	41 e0       	ldi	r20, 0x01	; 1
    854c:	26 ed       	ldi	r18, 0xD6	; 214
    854e:	31 e0       	ldi	r19, 0x01	; 1
    8550:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>
    8554:	8c e0       	ldi	r24, 0x0C	; 12
    8556:	6c ee       	ldi	r22, 0xEC	; 236
    8558:	73 e0       	ldi	r23, 0x03	; 3
    855a:	41 e0       	ldi	r20, 0x01	; 1
    855c:	26 ed       	ldi	r18, 0xD6	; 214
    855e:	31 e0       	ldi	r19, 0x01	; 1
    8560:	0e 94 b9 1a 	call	0x3572	; 0x3572 <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    8564:	80 e3       	ldi	r24, 0x30	; 48
    8566:	80 93 b5 01 	sts	0x01B5, r24
		  LengthMessage81=RepPos+1;
    856a:	80 91 d6 01 	lds	r24, 0x01D6
    856e:	90 91 d7 01 	lds	r25, 0x01D7
    8572:	01 96       	adiw	r24, 0x01	; 1
    8574:	90 93 8e 01 	sts	0x018E, r25
    8578:	80 93 8d 01 	sts	0x018D, r24
		  IsFreePrinting=True;
    857c:	81 e0       	ldi	r24, 0x01	; 1
    857e:	80 93 a8 01 	sts	0x01A8, r24
	      IsBusyFreePrinting=True; 
    8582:	80 93 b4 01 	sts	0x01B4, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    8586:	8b e0       	ldi	r24, 0x0B	; 11
    8588:	05 c0       	rjmp	.+10     	; 0x8594 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    858a:	80 91 b4 01 	lds	r24, 0x01B4
    858e:	88 23       	and	r24, r24
    8590:	49 f4       	brne	.+18     	; 0x85a4 <systemGenerateReport+0x1632>
    8592:	8c e0       	ldi	r24, 0x0C	; 12
    8594:	80 93 e8 01 	sts	0x01E8, r24
    8598:	05 c0       	rjmp	.+10     	; 0x85a4 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    859a:	81 e0       	ldi	r24, 0x01	; 1
    859c:	80 93 87 01 	sts	0x0187, r24
          stGenerateReport=grScanAction;
    85a0:	10 92 e8 01 	sts	0x01E8, r1
	      break;
	 }
}
    85a4:	c8 50       	subi	r28, 0x08	; 8
    85a6:	df 4f       	sbci	r29, 0xFF	; 255
    85a8:	0f b6       	in	r0, 0x3f	; 63
    85aa:	f8 94       	cli
    85ac:	de bf       	out	0x3e, r29	; 62
    85ae:	0f be       	out	0x3f, r0	; 63
    85b0:	cd bf       	out	0x3d, r28	; 61
    85b2:	cf 91       	pop	r28
    85b4:	df 91       	pop	r29
    85b6:	1f 91       	pop	r17
    85b8:	0f 91       	pop	r16
    85ba:	ff 90       	pop	r15
    85bc:	ef 90       	pop	r14
    85be:	df 90       	pop	r13
    85c0:	cf 90       	pop	r12
    85c2:	bf 90       	pop	r11
    85c4:	af 90       	pop	r10
    85c6:	9f 90       	pop	r9
    85c8:	8f 90       	pop	r8
    85ca:	7f 90       	pop	r7
    85cc:	6f 90       	pop	r6
    85ce:	5f 90       	pop	r5
    85d0:	4f 90       	pop	r4
    85d2:	3f 90       	pop	r3
    85d4:	2f 90       	pop	r2
    85d6:	08 95       	ret

000085d8 <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 

void UpdateCardID(){
    85d8:	cf 93       	push	r28
    85da:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    85dc:	e1 e5       	ldi	r30, 0x51	; 81
    85de:	fc e0       	ldi	r31, 0x0C	; 12
    85e0:	01 90       	ld	r0, Z+
    85e2:	00 20       	and	r0, r0
    85e4:	e9 f7       	brne	.-6      	; 0x85e0 <UpdateCardID+0x8>
    85e6:	31 97       	sbiw	r30, 0x01	; 1
    85e8:	e1 55       	subi	r30, 0x51	; 81
    85ea:	fc 40       	sbci	r31, 0x0C	; 12
    85ec:	a9 e8       	ldi	r26, 0x89	; 137
    85ee:	bb e0       	ldi	r27, 0x0B	; 11
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 

void UpdateCardID(){
    85f0:	f0 e0       	ldi	r31, 0x00	; 0
    85f2:	ef 01       	movw	r28, r30
    85f4:	c3 5c       	subi	r28, 0xC3	; 195
    85f6:	d3 4f       	sbci	r29, 0xF3	; 243
    85f8:	20 e0       	ldi	r18, 0x00	; 0
    85fa:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    85fc:	44 e1       	ldi	r20, 0x14	; 20
    85fe:	50 e0       	ldi	r21, 0x00	; 0
    8600:	4e 1b       	sub	r20, r30
    8602:	5f 0b       	sbc	r21, r31
    8604:	90 e2       	ldi	r25, 0x20	; 32
    8606:	24 17       	cp	r18, r20
    8608:	35 07       	cpc	r19, r21
    860a:	14 f4       	brge	.+4      	; 0x8610 <UpdateCardID+0x38>
    860c:	9c 93       	st	X, r25
    860e:	02 c0       	rjmp	.+4      	; 0x8614 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    8610:	88 81       	ld	r24, Y
    8612:	8c 93       	st	X, r24
    8614:	2f 5f       	subi	r18, 0xFF	; 255
    8616:	3f 4f       	sbci	r19, 0xFF	; 255
    8618:	11 96       	adiw	r26, 0x01	; 1
    861a:	21 96       	adiw	r28, 0x01	; 1
} 

void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    861c:	24 31       	cpi	r18, 0x14	; 20
    861e:	31 05       	cpc	r19, r1
    8620:	91 f7       	brne	.-28     	; 0x8606 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    8622:	10 92 9d 0b 	sts	0x0B9D, r1

}
    8626:	df 91       	pop	r29
    8628:	cf 91       	pop	r28
    862a:	08 95       	ret

0000862c <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    862c:	cf 92       	push	r12
    862e:	df 92       	push	r13
    8630:	ef 92       	push	r14
    8632:	ff 92       	push	r15
    8634:	0f 93       	push	r16
    8636:	1f 93       	push	r17
    8638:	df 93       	push	r29
    863a:	cf 93       	push	r28
    863c:	cd b7       	in	r28, 0x3d	; 61
    863e:	de b7       	in	r29, 0x3e	; 62
    8640:	27 97       	sbiw	r28, 0x07	; 7
    8642:	0f b6       	in	r0, 0x3f	; 63
    8644:	f8 94       	cli
    8646:	de bf       	out	0x3e, r29	; 62
    8648:	0f be       	out	0x3f, r0	; 63
    864a:	cd bf       	out	0x3d, r28	; 61
    864c:	6c 01       	movw	r12, r24
    864e:	fe 01       	movw	r30, r28
    8650:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8652:	ce 01       	movw	r24, r28
    8654:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    8656:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8658:	e8 17       	cp	r30, r24
    865a:	f9 07       	cpc	r31, r25
    865c:	e1 f7       	brne	.-8      	; 0x8656 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    865e:	8e 01       	movw	r16, r28
    8660:	0f 5f       	subi	r16, 0xFF	; 255
    8662:	1f 4f       	sbci	r17, 0xFF	; 255
    8664:	c8 01       	movw	r24, r16
    8666:	68 e3       	ldi	r22, 0x38	; 56
    8668:	71 e0       	ldi	r23, 0x01	; 1
    866a:	47 e0       	ldi	r20, 0x07	; 7
    866c:	50 e0       	ldi	r21, 0x00	; 0
    866e:	22 ed       	ldi	r18, 0xD2	; 210
    8670:	33 e1       	ldi	r19, 0x13	; 19
    8672:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    8676:	f8 01       	movw	r30, r16
    8678:	01 90       	ld	r0, Z+
    867a:	00 20       	and	r0, r0
    867c:	e9 f7       	brne	.-6      	; 0x8678 <GenerateTransactionNum+0x4c>
    867e:	31 97       	sbiw	r30, 0x01	; 1
    8680:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    8682:	f0 e0       	ldi	r31, 0x00	; 0
    8684:	0e 0f       	add	r16, r30
    8686:	1f 1f       	adc	r17, r31
    8688:	31 97       	sbiw	r30, 0x01	; 1
    868a:	76 01       	movw	r14, r12
    868c:	ee 0e       	add	r14, r30
    868e:	ff 1e       	adc	r15, r31
    8690:	31 96       	adiw	r30, 0x01	; 1
    8692:	61 e0       	ldi	r22, 0x01	; 1
    8694:	19 c0       	rjmp	.+50     	; 0x86c8 <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    8696:	d8 01       	movw	r26, r16
    8698:	2c 91       	ld	r18, X
    869a:	20 53       	subi	r18, 0x30	; 48
    869c:	30 e0       	ldi	r19, 0x00	; 0
    869e:	26 0f       	add	r18, r22
    86a0:	31 1d       	adc	r19, r1
    86a2:	c9 01       	movw	r24, r18
    86a4:	6a e0       	ldi	r22, 0x0A	; 10
    86a6:	70 e0       	ldi	r23, 0x00	; 0
    86a8:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    86ac:	48 2f       	mov	r20, r24
    86ae:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    86b0:	c9 01       	movw	r24, r18
    86b2:	6a e0       	ldi	r22, 0x0A	; 10
    86b4:	70 e0       	ldi	r23, 0x00	; 0
    86b6:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    86ba:	d8 01       	movw	r26, r16
    86bc:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    86be:	d7 01       	movw	r26, r14
    86c0:	4c 93       	st	X, r20
    86c2:	08 94       	sec
    86c4:	e1 08       	sbc	r14, r1
    86c6:	f1 08       	sbc	r15, r1
    86c8:	01 50       	subi	r16, 0x01	; 1
    86ca:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    86cc:	0c 17       	cp	r16, r28
    86ce:	1d 07       	cpc	r17, r29
    86d0:	11 f7       	brne	.-60     	; 0x8696 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    86d2:	ce 0e       	add	r12, r30
    86d4:	df 1e       	adc	r13, r31
    86d6:	d6 01       	movw	r26, r12
    86d8:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    86da:	be 01       	movw	r22, r28
    86dc:	6f 5f       	subi	r22, 0xFF	; 255
    86de:	7f 4f       	sbci	r23, 0xFF	; 255
    86e0:	e6 0f       	add	r30, r22
    86e2:	f7 1f       	adc	r31, r23
    86e4:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    86e6:	88 e3       	ldi	r24, 0x38	; 56
    86e8:	91 e0       	ldi	r25, 0x01	; 1
    86ea:	47 e0       	ldi	r20, 0x07	; 7
    86ec:	50 e0       	ldi	r21, 0x00	; 0
    86ee:	2a ed       	ldi	r18, 0xDA	; 218
    86f0:	33 e1       	ldi	r19, 0x13	; 19
    86f2:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    86f6:	27 96       	adiw	r28, 0x07	; 7
    86f8:	0f b6       	in	r0, 0x3f	; 63
    86fa:	f8 94       	cli
    86fc:	de bf       	out	0x3e, r29	; 62
    86fe:	0f be       	out	0x3f, r0	; 63
    8700:	cd bf       	out	0x3d, r28	; 61
    8702:	cf 91       	pop	r28
    8704:	df 91       	pop	r29
    8706:	1f 91       	pop	r17
    8708:	0f 91       	pop	r16
    870a:	ff 90       	pop	r15
    870c:	ef 90       	pop	r14
    870e:	df 90       	pop	r13
    8710:	cf 90       	pop	r12
    8712:	08 95       	ret

00008714 <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    8714:	8f 92       	push	r8
    8716:	9f 92       	push	r9
    8718:	af 92       	push	r10
    871a:	bf 92       	push	r11
    871c:	cf 92       	push	r12
    871e:	df 92       	push	r13
    8720:	ef 92       	push	r14
    8722:	ff 92       	push	r15
    8724:	0f 93       	push	r16
    8726:	1f 93       	push	r17
    8728:	df 93       	push	r29
    872a:	cf 93       	push	r28
    872c:	cd b7       	in	r28, 0x3d	; 61
    872e:	de b7       	in	r29, 0x3e	; 62
    8730:	a7 97       	sbiw	r28, 0x27	; 39
    8732:	0f b6       	in	r0, 0x3f	; 63
    8734:	f8 94       	cli
    8736:	de bf       	out	0x3e, r29	; 62
    8738:	0f be       	out	0x3f, r0	; 63
    873a:	cd bf       	out	0x3d, r28	; 61
    873c:	79 01       	movw	r14, r18
    873e:	48 01       	movw	r8, r16
    8740:	e6 2f       	mov	r30, r22
    8742:	f0 e0       	ldi	r31, 0x00	; 0
    8744:	31 97       	sbiw	r30, 0x01	; 1
    8746:	e8 0f       	add	r30, r24
    8748:	f9 1f       	adc	r31, r25
    874a:	9e 01       	movw	r18, r28
    874c:	26 5f       	subi	r18, 0xF6	; 246
    874e:	3f 4f       	sbci	r19, 0xFF	; 255
    8750:	d9 01       	movw	r26, r18
    8752:	03 c0       	rjmp	.+6      	; 0x875a <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    8754:	80 81       	ld	r24, Z
    8756:	8d 93       	st	X+, r24
    8758:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    875a:	8a 2f       	mov	r24, r26
    875c:	82 1b       	sub	r24, r18
    875e:	86 17       	cp	r24, r22
    8760:	c8 f3       	brcs	.-14     	; 0x8754 <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    8762:	c6 2e       	mov	r12, r22
    8764:	dd 24       	eor	r13, r13
    8766:	aa e0       	ldi	r26, 0x0A	; 10
    8768:	aa 2e       	mov	r10, r26
    876a:	b1 2c       	mov	r11, r1
    876c:	ac 0e       	add	r10, r28
    876e:	bd 1e       	adc	r11, r29
    8770:	f5 01       	movw	r30, r10
    8772:	ec 0d       	add	r30, r12
    8774:	fd 1d       	adc	r31, r13
    8776:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    8778:	8a 85       	ldd	r24, Y+10	; 0x0a
    877a:	fa 01       	movw	r30, r20
    877c:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    877e:	8b 85       	ldd	r24, Y+11	; 0x0b
    8780:	89 83       	std	Y+1, r24	; 0x01
    8782:	8c 85       	ldd	r24, Y+12	; 0x0c
    8784:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    8786:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    8788:	ce 01       	movw	r24, r28
    878a:	01 96       	adiw	r24, 0x01	; 1
    878c:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
	 *GPumpID=xPumpID;
    8790:	f7 01       	movw	r30, r14
    8792:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    8794:	00 d0       	rcall	.+0      	; 0x8796 <GetParameter+0x82>
    8796:	00 d0       	rcall	.+0      	; 0x8798 <GetParameter+0x84>
    8798:	f7 e0       	ldi	r31, 0x07	; 7
    879a:	ef 2e       	mov	r14, r31
    879c:	f1 2c       	mov	r15, r1
    879e:	ec 0e       	add	r14, r28
    87a0:	fd 1e       	adc	r15, r29
    87a2:	ed b7       	in	r30, 0x3d	; 61
    87a4:	fe b7       	in	r31, 0x3e	; 62
    87a6:	f2 82       	std	Z+2, r15	; 0x02
    87a8:	e1 82       	std	Z+1, r14	; 0x01
    87aa:	8d e5       	ldi	r24, 0x5D	; 93
    87ac:	95 e0       	ldi	r25, 0x05	; 5
    87ae:	94 83       	std	Z+4, r25	; 0x04
    87b0:	83 83       	std	Z+3, r24	; 0x03
    87b2:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    87b6:	0f 90       	pop	r0
    87b8:	0f 90       	pop	r0
    87ba:	0f 90       	pop	r0
    87bc:	0f 90       	pop	r0
    87be:	c7 01       	movw	r24, r14
    87c0:	b5 01       	movw	r22, r10
    87c2:	0e 94 f1 24 	call	0x49e2	; 0x49e2 <Pos>
    87c6:	8c 15       	cp	r24, r12
    87c8:	9d 05       	cpc	r25, r13
    87ca:	4c f5       	brge	.+82     	; 0x881e <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    87cc:	c7 01       	movw	r24, r14
    87ce:	b5 01       	movw	r22, r10
    87d0:	0e 94 f1 24 	call	0x49e2	; 0x49e2 <Pos>
    87d4:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    87d6:	c7 01       	movw	r24, r14
    87d8:	b5 01       	movw	r22, r10
    87da:	0e 94 f1 24 	call	0x49e2	; 0x49e2 <Pos>
    87de:	a6 01       	movw	r20, r12
    87e0:	40 1b       	sub	r20, r16
    87e2:	51 0b       	sbc	r21, r17
    87e4:	d5 01       	movw	r26, r10
    87e6:	a8 0f       	add	r26, r24
    87e8:	b9 1f       	adc	r27, r25
    87ea:	20 e0       	ldi	r18, 0x00	; 0
    87ec:	30 e0       	ldi	r19, 0x00	; 0
    87ee:	be 01       	movw	r22, r28
    87f0:	6c 5f       	subi	r22, 0xFC	; 252
    87f2:	7f 4f       	sbci	r23, 0xFF	; 255
    87f4:	07 c0       	rjmp	.+14     	; 0x8804 <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87f6:	fb 01       	movw	r30, r22
    87f8:	e2 0f       	add	r30, r18
    87fa:	f3 1f       	adc	r31, r19
    87fc:	8c 91       	ld	r24, X
    87fe:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8800:	2f 5f       	subi	r18, 0xFF	; 255
    8802:	3f 4f       	sbci	r19, 0xFF	; 255
    8804:	11 96       	adiw	r26, 0x01	; 1
    8806:	24 17       	cp	r18, r20
    8808:	35 07       	cpc	r19, r21
    880a:	a8 f3       	brcs	.-22     	; 0x87f6 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    880c:	46 0f       	add	r20, r22
    880e:	57 1f       	adc	r21, r23
    8810:	fa 01       	movw	r30, r20
    8812:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    8814:	cb 01       	movw	r24, r22
    8816:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
	     *GeniCSum=xCsum;
    881a:	f4 01       	movw	r30, r8
    881c:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 uart_print(1,1,strSend);
*/
}
    881e:	a7 96       	adiw	r28, 0x27	; 39
    8820:	0f b6       	in	r0, 0x3f	; 63
    8822:	f8 94       	cli
    8824:	de bf       	out	0x3e, r29	; 62
    8826:	0f be       	out	0x3f, r0	; 63
    8828:	cd bf       	out	0x3d, r28	; 61
    882a:	cf 91       	pop	r28
    882c:	df 91       	pop	r29
    882e:	1f 91       	pop	r17
    8830:	0f 91       	pop	r16
    8832:	ff 90       	pop	r15
    8834:	ef 90       	pop	r14
    8836:	df 90       	pop	r13
    8838:	cf 90       	pop	r12
    883a:	bf 90       	pop	r11
    883c:	af 90       	pop	r10
    883e:	9f 90       	pop	r9
    8840:	8f 90       	pop	r8
    8842:	08 95       	ret

00008844 <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    8844:	ff 92       	push	r15
    8846:	0f 93       	push	r16
    8848:	1f 93       	push	r17
    884a:	df 93       	push	r29
    884c:	cf 93       	push	r28
    884e:	cd b7       	in	r28, 0x3d	; 61
    8850:	de b7       	in	r29, 0x3e	; 62
    8852:	67 97       	sbiw	r28, 0x17	; 23
    8854:	0f b6       	in	r0, 0x3f	; 63
    8856:	f8 94       	cli
    8858:	de bf       	out	0x3e, r29	; 62
    885a:	0f be       	out	0x3f, r0	; 63
    885c:	cd bf       	out	0x3d, r28	; 61
    885e:	f8 2e       	mov	r15, r24
	 char i,GeniCmd,GeniPumpID,GeniCSum;//,sCmd[7];
	 char strSend[20];

    //uart(1,1,dataIn);

	if (dataIn==0x0D){	
    8860:	8d e0       	ldi	r24, 0x0D	; 13
    8862:	f8 16       	cp	r15, r24
    8864:	09 f0       	breq	.+2      	; 0x8868 <GeniusProtocol+0x24>
    8866:	45 c0       	rjmp	.+138    	; 0x88f2 <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    8868:	82 ec       	ldi	r24, 0xC2	; 194
    886a:	91 e0       	ldi	r25, 0x01	; 1
    886c:	60 91 c1 01 	lds	r22, 0x01C1
    8870:	ae 01       	movw	r20, r28
    8872:	4f 5f       	subi	r20, 0xFF	; 255
    8874:	5f 4f       	sbci	r21, 0xFF	; 255
    8876:	9e 01       	movw	r18, r28
    8878:	2e 5f       	subi	r18, 0xFE	; 254
    887a:	3f 4f       	sbci	r19, 0xFF	; 255
    887c:	8e 01       	movw	r16, r28
    887e:	0d 5f       	subi	r16, 0xFD	; 253
    8880:	1f 4f       	sbci	r17, 0xFF	; 255
    8882:	0e 94 8a 43 	call	0x8714	; 0x8714 <GetParameter>
		FlowLength=0;
    8886:	10 92 c1 01 	sts	0x01C1, r1
		IsGeniusFlow=False;
    888a:	10 92 c0 01 	sts	0x01C0, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    888e:	ad b7       	in	r26, 0x3d	; 61
    8890:	be b7       	in	r27, 0x3e	; 62
    8892:	18 97       	sbiw	r26, 0x08	; 8
    8894:	0f b6       	in	r0, 0x3f	; 63
    8896:	f8 94       	cli
    8898:	be bf       	out	0x3e, r27	; 62
    889a:	0f be       	out	0x3f, r0	; 63
    889c:	ad bf       	out	0x3d, r26	; 61
    889e:	ed b7       	in	r30, 0x3d	; 61
    88a0:	fe b7       	in	r31, 0x3e	; 62
    88a2:	31 96       	adiw	r30, 0x01	; 1
    88a4:	8e 01       	movw	r16, r28
    88a6:	0c 5f       	subi	r16, 0xFC	; 252
    88a8:	1f 4f       	sbci	r17, 0xFF	; 255
    88aa:	12 96       	adiw	r26, 0x02	; 2
    88ac:	1c 93       	st	X, r17
    88ae:	0e 93       	st	-X, r16
    88b0:	11 97       	sbiw	r26, 0x01	; 1
    88b2:	8f e4       	ldi	r24, 0x4F	; 79
    88b4:	95 e0       	ldi	r25, 0x05	; 5
    88b6:	93 83       	std	Z+3, r25	; 0x03
    88b8:	82 83       	std	Z+2, r24	; 0x02
    88ba:	89 81       	ldd	r24, Y+1	; 0x01
    88bc:	84 83       	std	Z+4, r24	; 0x04
    88be:	15 82       	std	Z+5, r1	; 0x05
    88c0:	8a 81       	ldd	r24, Y+2	; 0x02
    88c2:	86 83       	std	Z+6, r24	; 0x06
    88c4:	17 82       	std	Z+7, r1	; 0x07
    88c6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		//uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    88ca:	8d b7       	in	r24, 0x3d	; 61
    88cc:	9e b7       	in	r25, 0x3e	; 62
    88ce:	08 96       	adiw	r24, 0x08	; 8
    88d0:	0f b6       	in	r0, 0x3f	; 63
    88d2:	f8 94       	cli
    88d4:	9e bf       	out	0x3e, r25	; 62
    88d6:	0f be       	out	0x3f, r0	; 63
    88d8:	8d bf       	out	0x3d, r24	; 61
    88da:	c8 01       	movw	r24, r16
    88dc:	0e 94 8c 24 	call	0x4918	; 0x4918 <SumChecksum>
    88e0:	9b 81       	ldd	r25, Y+3	; 0x03
    88e2:	89 17       	cp	r24, r25
    88e4:	31 f4       	brne	.+12     	; 0x88f2 <GeniusProtocol+0xae>
		     switch(GeniCmd){
    88e6:	89 81       	ldd	r24, Y+1	; 0x01
    88e8:	84 35       	cpi	r24, 0x54	; 84
    88ea:	19 f4       	brne	.+6      	; 0x88f2 <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    88ec:	8a 81       	ldd	r24, Y+2	; 0x02
    88ee:	0e 94 65 31 	call	0x62ca	; 0x62ca <GeniusSendLastTransaction>
    88f2:	e4 ed       	ldi	r30, 0xD4	; 212
    88f4:	f1 e0       	ldi	r31, 0x01	; 1
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    88f6:	80 81       	ld	r24, Z
    88f8:	81 83       	std	Z+1, r24	; 0x01
    88fa:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    88fc:	91 e0       	ldi	r25, 0x01	; 1
    88fe:	e1 3c       	cpi	r30, 0xC1	; 193
    8900:	f9 07       	cpc	r31, r25
    8902:	c9 f7       	brne	.-14     	; 0x88f6 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    8904:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    8906:	8f 2d       	mov	r24, r15
    8908:	0e 94 ac 24 	call	0x4958	; 0x4958 <IsGeniusCommand>
    890c:	81 30       	cpi	r24, 0x01	; 1
    890e:	11 f4       	brne	.+4      	; 0x8914 <GeniusProtocol+0xd0>
    8910:	80 93 c0 01 	sts	0x01C0, r24
	if (IsGeniusFlow==True)FlowLength++;
    8914:	80 91 c0 01 	lds	r24, 0x01C0
    8918:	81 30       	cpi	r24, 0x01	; 1
    891a:	29 f4       	brne	.+10     	; 0x8926 <GeniusProtocol+0xe2>
    891c:	80 91 c1 01 	lds	r24, 0x01C1
    8920:	8f 5f       	subi	r24, 0xFF	; 255
    8922:	80 93 c1 01 	sts	0x01C1, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    8926:	67 96       	adiw	r28, 0x17	; 23
    8928:	0f b6       	in	r0, 0x3f	; 63
    892a:	f8 94       	cli
    892c:	de bf       	out	0x3e, r29	; 62
    892e:	0f be       	out	0x3f, r0	; 63
    8930:	cd bf       	out	0x3d, r28	; 61
    8932:	cf 91       	pop	r28
    8934:	df 91       	pop	r29
    8936:	1f 91       	pop	r17
    8938:	0f 91       	pop	r16
    893a:	ff 90       	pop	r15
    893c:	08 95       	ret

0000893e <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    893e:	1f 92       	push	r1
    8940:	0f 92       	push	r0
    8942:	0f b6       	in	r0, 0x3f	; 63
    8944:	0f 92       	push	r0
    8946:	0b b6       	in	r0, 0x3b	; 59
    8948:	0f 92       	push	r0
    894a:	11 24       	eor	r1, r1
    894c:	1f 93       	push	r17
    894e:	2f 93       	push	r18
    8950:	3f 93       	push	r19
    8952:	4f 93       	push	r20
    8954:	5f 93       	push	r21
    8956:	6f 93       	push	r22
    8958:	7f 93       	push	r23
    895a:	8f 93       	push	r24
    895c:	9f 93       	push	r25
    895e:	af 93       	push	r26
    8960:	bf 93       	push	r27
    8962:	ef 93       	push	r30
    8964:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    8966:	10 91 9c 00 	lds	r17, 0x009C
    //Not Successfull!
	//NewPacket
	if (IsNewPacket==True){
    896a:	80 91 88 01 	lds	r24, 0x0188
    896e:	81 30       	cpi	r24, 0x01	; 1
    8970:	51 f4       	brne	.+20     	; 0x8986 <__vector_30+0x48>
	    if (dataTX1==0x01){
    8972:	11 30       	cpi	r17, 0x01	; 1
    8974:	41 f4       	brne	.+16     	; 0x8986 <__vector_30+0x48>
		    char_count=0;
    8976:	10 92 8a 01 	sts	0x018A, r1
    897a:	10 92 89 01 	sts	0x0189, r1
            IsNewPacket=False;
    897e:	10 92 88 01 	sts	0x0188, r1
			IsAdvanZProtocol=True;
    8982:	10 93 98 02 	sts	0x0298, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    8986:	80 91 98 02 	lds	r24, 0x0298
    898a:	81 30       	cpi	r24, 0x01	; 1
    898c:	69 f4       	brne	.+26     	; 0x89a8 <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
    898e:	80 91 89 01 	lds	r24, 0x0189
    8992:	90 91 8a 01 	lds	r25, 0x018A
    8996:	fc 01       	movw	r30, r24
    8998:	e3 5e       	subi	r30, 0xE3	; 227
    899a:	f6 4f       	sbci	r31, 0xF6	; 246
    899c:	10 83       	st	Z, r17
	    char_count++; 
    899e:	01 96       	adiw	r24, 0x01	; 1
    89a0:	90 93 8a 01 	sts	0x018A, r25
    89a4:	80 93 89 01 	sts	0x0189, r24
	}

	if (dataTX1==0x02){
    89a8:	12 30       	cpi	r17, 0x02	; 2
    89aa:	b1 f5       	brne	.+108    	; 0x8a18 <__vector_30+0xda>
		transLength=char_count;
    89ac:	60 91 89 01 	lds	r22, 0x0189
    89b0:	70 91 8a 01 	lds	r23, 0x018A
    89b4:	70 93 8c 01 	sts	0x018C, r23
    89b8:	60 93 8b 01 	sts	0x018B, r22
		char_count=0;
    89bc:	10 92 8a 01 	sts	0x018A, r1
    89c0:	10 92 89 01 	sts	0x0189, r1
		IsAdvanZProtocol=False;
    89c4:	10 92 98 02 	sts	0x0298, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    89c8:	20 91 41 09 	lds	r18, 0x0941
    89cc:	20 51       	subi	r18, 0x10	; 16
    89ce:	80 91 40 09 	lds	r24, 0x0940
    89d2:	3a e0       	ldi	r19, 0x0A	; 10
    89d4:	83 9f       	mul	r24, r19
    89d6:	c0 01       	movw	r24, r0
    89d8:	11 24       	eor	r1, r1
    89da:	28 0f       	add	r18, r24
    89dc:	20 93 24 01 	sts	0x0124, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    89e0:	80 91 1d 09 	lds	r24, 0x091D
    89e4:	0e 94 99 19 	call	0x3332	; 0x3332 <IdentifyMessage>
		IsNewPacket=True;
    89e8:	21 e0       	ldi	r18, 0x01	; 1
    89ea:	20 93 88 01 	sts	0x0188, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    89ee:	80 91 40 09 	lds	r24, 0x0940
    89f2:	88 33       	cpi	r24, 0x38	; 56
    89f4:	89 f4       	brne	.+34     	; 0x8a18 <__vector_30+0xda>
    89f6:	80 91 41 09 	lds	r24, 0x0941
    89fa:	81 33       	cpi	r24, 0x31	; 49
    89fc:	69 f4       	brne	.+26     	; 0x8a18 <__vector_30+0xda>
		   LengthMessage81=transLength-12-44;
    89fe:	80 91 8b 01 	lds	r24, 0x018B
    8a02:	90 91 8c 01 	lds	r25, 0x018C
    8a06:	c8 97       	sbiw	r24, 0x38	; 56
    8a08:	90 93 8e 01 	sts	0x018E, r25
    8a0c:	80 93 8d 01 	sts	0x018D, r24
		   IsMessage81=True;
    8a10:	20 93 a6 01 	sts	0x01A6, r18
		   IsCompleteFilling=True;
    8a14:	20 93 a9 01 	sts	0x01A9, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)
    8a18:	80 91 88 01 	lds	r24, 0x0188
    8a1c:	81 30       	cpi	r24, 0x01	; 1
    8a1e:	19 f0       	breq	.+6      	; 0x8a26 <__vector_30+0xe8>
	    ConfigProtocol(dataTX1);
    8a20:	81 2f       	mov	r24, r17
    8a22:	0e 94 a3 15 	call	0x2b46	; 0x2b46 <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))
    8a26:	80 91 00 01 	lds	r24, 0x0100
    8a2a:	82 30       	cpi	r24, 0x02	; 2
    8a2c:	39 f4       	brne	.+14     	; 0x8a3c <__vector_30+0xfe>
    8a2e:	80 91 88 01 	lds	r24, 0x0188
    8a32:	81 30       	cpi	r24, 0x01	; 1
    8a34:	19 f0       	breq	.+6      	; 0x8a3c <__vector_30+0xfe>
	     GeniusProtocol(dataTX1);		
    8a36:	81 2f       	mov	r24, r17
    8a38:	0e 94 22 44 	call	0x8844	; 0x8844 <GeniusProtocol>
    //uart(0,1,dataTX1);
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}
    8a3c:	ff 91       	pop	r31
    8a3e:	ef 91       	pop	r30
    8a40:	bf 91       	pop	r27
    8a42:	af 91       	pop	r26
    8a44:	9f 91       	pop	r25
    8a46:	8f 91       	pop	r24
    8a48:	7f 91       	pop	r23
    8a4a:	6f 91       	pop	r22
    8a4c:	5f 91       	pop	r21
    8a4e:	4f 91       	pop	r20
    8a50:	3f 91       	pop	r19
    8a52:	2f 91       	pop	r18
    8a54:	1f 91       	pop	r17
    8a56:	0f 90       	pop	r0
    8a58:	0b be       	out	0x3b, r0	; 59
    8a5a:	0f 90       	pop	r0
    8a5c:	0f be       	out	0x3f, r0	; 63
    8a5e:	0f 90       	pop	r0
    8a60:	1f 90       	pop	r1
    8a62:	18 95       	reti

00008a64 <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    8a64:	0f 93       	push	r16
    8a66:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    8a68:	80 91 1d 09 	lds	r24, 0x091D
    8a6c:	81 30       	cpi	r24, 0x01	; 1
    8a6e:	09 f0       	breq	.+2      	; 0x8a72 <procMessage99+0xe>
    8a70:	2e c2       	rjmp	.+1116   	; 0x8ece <procMessage99+0x46a>
    8a72:	80 91 8b 01 	lds	r24, 0x018B
    8a76:	90 91 8c 01 	lds	r25, 0x018C
    8a7a:	8a 57       	subi	r24, 0x7A	; 122
    8a7c:	91 40       	sbci	r25, 0x01	; 1
    8a7e:	08 f4       	brcc	.+2      	; 0x8a82 <procMessage99+0x1e>
    8a80:	26 c2       	rjmp	.+1100   	; 0x8ece <procMessage99+0x46a>
    8a82:	20 e0       	ldi	r18, 0x00	; 0
    8a84:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8a86:	f9 01       	movw	r30, r18
    8a88:	e9 57       	subi	r30, 0x79	; 121
    8a8a:	f3 4f       	sbci	r31, 0xF3	; 243
    8a8c:	d9 01       	movw	r26, r18
    8a8e:	a3 5e       	subi	r26, 0xE3	; 227
    8a90:	b6 4f       	sbci	r27, 0xF6	; 246
    8a92:	95 96       	adiw	r26, 0x25	; 37
    8a94:	8c 91       	ld	r24, X
    8a96:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8a98:	2f 5f       	subi	r18, 0xFF	; 255
    8a9a:	3f 4f       	sbci	r19, 0xFF	; 255
    8a9c:	26 30       	cpi	r18, 0x06	; 6
    8a9e:	31 05       	cpc	r19, r1
    8aa0:	91 f7       	brne	.-28     	; 0x8a86 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8aa2:	10 92 8d 0c 	sts	0x0C8D, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8aa6:	80 91 48 09 	lds	r24, 0x0948
    8aaa:	80 93 68 0c 	sts	0x0C68, r24
	 }Dest[Length]=0;
    8aae:	10 92 69 0c 	sts	0x0C69, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    8ab2:	80 53       	subi	r24, 0x30	; 48
    8ab4:	80 93 b9 01 	sts	0x01B9, r24
    8ab8:	20 e0       	ldi	r18, 0x00	; 0
    8aba:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8abc:	f9 01       	movw	r30, r18
    8abe:	e2 59       	subi	r30, 0x92	; 146
    8ac0:	f8 4f       	sbci	r31, 0xF8	; 248
    8ac2:	d9 01       	movw	r26, r18
    8ac4:	a3 5e       	subi	r26, 0xE3	; 227
    8ac6:	b6 4f       	sbci	r27, 0xF6	; 246
    8ac8:	9c 96       	adiw	r26, 0x2c	; 44
    8aca:	8c 91       	ld	r24, X
    8acc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8ace:	2f 5f       	subi	r18, 0xFF	; 255
    8ad0:	3f 4f       	sbci	r19, 0xFF	; 255
    8ad2:	2a 30       	cpi	r18, 0x0A	; 10
    8ad4:	31 05       	cpc	r19, r1
    8ad6:	91 f7       	brne	.-28     	; 0x8abc <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8ad8:	10 92 78 07 	sts	0x0778, r1
    8adc:	20 e0       	ldi	r18, 0x00	; 0
    8ade:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ae0:	f9 01       	movw	r30, r18
    8ae2:	e3 5b       	subi	r30, 0xB3	; 179
    8ae4:	fc 4f       	sbci	r31, 0xFC	; 252
    8ae6:	d9 01       	movw	r26, r18
    8ae8:	a3 5e       	subi	r26, 0xE3	; 227
    8aea:	b6 4f       	sbci	r27, 0xF6	; 246
    8aec:	d6 96       	adiw	r26, 0x36	; 54
    8aee:	8c 91       	ld	r24, X
    8af0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8af2:	2f 5f       	subi	r18, 0xFF	; 255
    8af4:	3f 4f       	sbci	r19, 0xFF	; 255
    8af6:	28 30       	cpi	r18, 0x08	; 8
    8af8:	31 05       	cpc	r19, r1
    8afa:	91 f7       	brne	.-28     	; 0x8ae0 <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8afc:	10 92 55 03 	sts	0x0355, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8b00:	80 91 5b 09 	lds	r24, 0x095B
    8b04:	80 93 f7 08 	sts	0x08F7, r24
    8b08:	80 91 5c 09 	lds	r24, 0x095C
    8b0c:	80 93 f8 08 	sts	0x08F8, r24
	 }Dest[Length]=0;
    8b10:	10 92 f9 08 	sts	0x08F9, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8b14:	80 91 5d 09 	lds	r24, 0x095D
    8b18:	80 93 b9 07 	sts	0x07B9, r24
    8b1c:	80 91 5e 09 	lds	r24, 0x095E
    8b20:	80 93 ba 07 	sts	0x07BA, r24
	 }Dest[Length]=0;
    8b24:	10 92 bb 07 	sts	0x07BB, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8b28:	80 91 5f 09 	lds	r24, 0x095F
    8b2c:	80 93 71 08 	sts	0x0871, r24
    8b30:	80 91 60 09 	lds	r24, 0x0960
    8b34:	80 93 72 08 	sts	0x0872, r24
	 }Dest[Length]=0;
    8b38:	10 92 73 08 	sts	0x0873, r1
    8b3c:	20 e0       	ldi	r18, 0x00	; 0
    8b3e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8b40:	f9 01       	movw	r30, r18
    8b42:	e4 5f       	subi	r30, 0xF4	; 244
    8b44:	f7 4f       	sbci	r31, 0xF7	; 247
    8b46:	d9 01       	movw	r26, r18
    8b48:	af 59       	subi	r26, 0x9F	; 159
    8b4a:	b6 4f       	sbci	r27, 0xF6	; 246
    8b4c:	8c 91       	ld	r24, X
    8b4e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8b50:	2f 5f       	subi	r18, 0xFF	; 255
    8b52:	3f 4f       	sbci	r19, 0xFF	; 255
    8b54:	2f 30       	cpi	r18, 0x0F	; 15
    8b56:	31 05       	cpc	r19, r1
    8b58:	99 f7       	brne	.-26     	; 0x8b40 <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8b5a:	10 92 1b 08 	sts	0x081B, r1
    8b5e:	20 e0       	ldi	r18, 0x00	; 0
    8b60:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8b62:	f9 01       	movw	r30, r18
    8b64:	e2 56       	subi	r30, 0x62	; 98
    8b66:	fa 4f       	sbci	r31, 0xFA	; 250
    8b68:	d9 01       	movw	r26, r18
    8b6a:	a0 59       	subi	r26, 0x90	; 144
    8b6c:	b6 4f       	sbci	r27, 0xF6	; 246
    8b6e:	8c 91       	ld	r24, X
    8b70:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8b72:	2f 5f       	subi	r18, 0xFF	; 255
    8b74:	3f 4f       	sbci	r19, 0xFF	; 255
    8b76:	28 30       	cpi	r18, 0x08	; 8
    8b78:	31 05       	cpc	r19, r1
    8b7a:	99 f7       	brne	.-26     	; 0x8b62 <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8b7c:	10 92 a6 05 	sts	0x05A6, r1
    8b80:	20 e0       	ldi	r18, 0x00	; 0
    8b82:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8b84:	f9 01       	movw	r30, r18
    8b86:	eb 58       	subi	r30, 0x8B	; 139
    8b88:	fc 4f       	sbci	r31, 0xFC	; 252
    8b8a:	d9 01       	movw	r26, r18
    8b8c:	a8 58       	subi	r26, 0x88	; 136
    8b8e:	b6 4f       	sbci	r27, 0xF6	; 246
    8b90:	8c 91       	ld	r24, X
    8b92:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8b94:	2f 5f       	subi	r18, 0xFF	; 255
    8b96:	3f 4f       	sbci	r19, 0xFF	; 255
    8b98:	28 30       	cpi	r18, 0x08	; 8
    8b9a:	31 05       	cpc	r19, r1
    8b9c:	99 f7       	brne	.-26     	; 0x8b84 <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8b9e:	10 92 7d 03 	sts	0x037D, r1
    8ba2:	20 e0       	ldi	r18, 0x00	; 0
    8ba4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ba6:	f9 01       	movw	r30, r18
    8ba8:	ed 54       	subi	r30, 0x4D	; 77
    8baa:	f4 4f       	sbci	r31, 0xF4	; 244
    8bac:	d9 01       	movw	r26, r18
    8bae:	a0 58       	subi	r26, 0x80	; 128
    8bb0:	b6 4f       	sbci	r27, 0xF6	; 246
    8bb2:	8c 91       	ld	r24, X
    8bb4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8bb6:	2f 5f       	subi	r18, 0xFF	; 255
    8bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    8bba:	2a 30       	cpi	r18, 0x0A	; 10
    8bbc:	31 05       	cpc	r19, r1
    8bbe:	99 f7       	brne	.-26     	; 0x8ba6 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8bc0:	10 92 bd 0b 	sts	0x0BBD, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    8bc4:	80 91 8a 09 	lds	r24, 0x098A
    8bc8:	80 53       	subi	r24, 0x30	; 48
    8bca:	80 93 b8 01 	sts	0x01B8, r24
    8bce:	20 e0       	ldi	r18, 0x00	; 0
    8bd0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8bd2:	f9 01       	movw	r30, r18
    8bd4:	e3 58       	subi	r30, 0x83	; 131
    8bd6:	fa 4f       	sbci	r31, 0xFA	; 250
    8bd8:	d9 01       	movw	r26, r18
    8bda:	a5 57       	subi	r26, 0x75	; 117
    8bdc:	b6 4f       	sbci	r27, 0xF6	; 246
    8bde:	8c 91       	ld	r24, X
    8be0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8be2:	2f 5f       	subi	r18, 0xFF	; 255
    8be4:	3f 4f       	sbci	r19, 0xFF	; 255
    8be6:	24 31       	cpi	r18, 0x14	; 20
    8be8:	31 05       	cpc	r19, r1
    8bea:	99 f7       	brne	.-26     	; 0x8bd2 <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8bec:	10 92 91 05 	sts	0x0591, r1
    8bf0:	20 e0       	ldi	r18, 0x00	; 0
    8bf2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8bf4:	f9 01       	movw	r30, r18
    8bf6:	e7 57       	subi	r30, 0x77	; 119
    8bf8:	f4 4f       	sbci	r31, 0xF4	; 244
    8bfa:	d9 01       	movw	r26, r18
    8bfc:	a1 56       	subi	r26, 0x61	; 97
    8bfe:	b6 4f       	sbci	r27, 0xF6	; 246
    8c00:	8c 91       	ld	r24, X
    8c02:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8c04:	2f 5f       	subi	r18, 0xFF	; 255
    8c06:	3f 4f       	sbci	r19, 0xFF	; 255
    8c08:	24 31       	cpi	r18, 0x14	; 20
    8c0a:	31 05       	cpc	r19, r1
    8c0c:	99 f7       	brne	.-26     	; 0x8bf4 <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8c0e:	10 92 9d 0b 	sts	0x0B9D, r1
    8c12:	20 e0       	ldi	r18, 0x00	; 0
    8c14:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8c16:	f9 01       	movw	r30, r18
    8c18:	ec 5d       	subi	r30, 0xDC	; 220
    8c1a:	fc 4f       	sbci	r31, 0xFC	; 252
    8c1c:	d9 01       	movw	r26, r18
    8c1e:	ad 54       	subi	r26, 0x4D	; 77
    8c20:	b6 4f       	sbci	r27, 0xF6	; 246
    8c22:	8c 91       	ld	r24, X
    8c24:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8c26:	2f 5f       	subi	r18, 0xFF	; 255
    8c28:	3f 4f       	sbci	r19, 0xFF	; 255
    8c2a:	28 32       	cpi	r18, 0x28	; 40
    8c2c:	31 05       	cpc	r19, r1
    8c2e:	99 f7       	brne	.-26     	; 0x8c16 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8c30:	10 92 4c 03 	sts	0x034C, r1
    8c34:	20 e0       	ldi	r18, 0x00	; 0
    8c36:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8c38:	f9 01       	movw	r30, r18
    8c3a:	e5 5a       	subi	r30, 0xA5	; 165
    8c3c:	fc 4f       	sbci	r31, 0xFC	; 252
    8c3e:	d9 01       	movw	r26, r18
    8c40:	a5 52       	subi	r26, 0x25	; 37
    8c42:	b6 4f       	sbci	r27, 0xF6	; 246
    8c44:	8c 91       	ld	r24, X
    8c46:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8c48:	2f 5f       	subi	r18, 0xFF	; 255
    8c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    8c4c:	29 31       	cpi	r18, 0x19	; 25
    8c4e:	31 05       	cpc	r19, r1
    8c50:	99 f7       	brne	.-26     	; 0x8c38 <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8c52:	10 92 74 03 	sts	0x0374, r1
    8c56:	20 e0       	ldi	r18, 0x00	; 0
    8c58:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8c5a:	f9 01       	movw	r30, r18
    8c5c:	e8 50       	subi	r30, 0x08	; 8
    8c5e:	f4 4f       	sbci	r31, 0xF4	; 244
    8c60:	d9 01       	movw	r26, r18
    8c62:	ac 50       	subi	r26, 0x0C	; 12
    8c64:	b6 4f       	sbci	r27, 0xF6	; 246
    8c66:	8c 91       	ld	r24, X
    8c68:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8c6a:	2f 5f       	subi	r18, 0xFF	; 255
    8c6c:	3f 4f       	sbci	r19, 0xFF	; 255
    8c6e:	2d 30       	cpi	r18, 0x0D	; 13
    8c70:	31 05       	cpc	r19, r1
    8c72:	99 f7       	brne	.-26     	; 0x8c5a <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8c74:	10 92 05 0c 	sts	0x0C05, r1
    8c78:	20 e0       	ldi	r18, 0x00	; 0
    8c7a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8c7c:	f9 01       	movw	r30, r18
    8c7e:	e4 57       	subi	r30, 0x74	; 116
    8c80:	fc 4f       	sbci	r31, 0xFC	; 252
    8c82:	d9 01       	movw	r26, r18
    8c84:	af 5f       	subi	r26, 0xFF	; 255
    8c86:	b5 4f       	sbci	r27, 0xF5	; 245
    8c88:	8c 91       	ld	r24, X
    8c8a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8c8c:	2f 5f       	subi	r18, 0xFF	; 255
    8c8e:	3f 4f       	sbci	r19, 0xFF	; 255
    8c90:	2d 30       	cpi	r18, 0x0D	; 13
    8c92:	31 05       	cpc	r19, r1
    8c94:	99 f7       	brne	.-26     	; 0x8c7c <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8c96:	10 92 99 03 	sts	0x0399, r1
    8c9a:	20 e0       	ldi	r18, 0x00	; 0
    8c9c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8c9e:	f9 01       	movw	r30, r18
    8ca0:	e7 51       	subi	r30, 0x17	; 23
    8ca2:	f7 4f       	sbci	r31, 0xF7	; 247
    8ca4:	d9 01       	movw	r26, r18
    8ca6:	a2 5f       	subi	r26, 0xF2	; 242
    8ca8:	b5 4f       	sbci	r27, 0xF5	; 245
    8caa:	8c 91       	ld	r24, X
    8cac:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8cae:	2f 5f       	subi	r18, 0xFF	; 255
    8cb0:	3f 4f       	sbci	r19, 0xFF	; 255
    8cb2:	2d 30       	cpi	r18, 0x0D	; 13
    8cb4:	31 05       	cpc	r19, r1
    8cb6:	99 f7       	brne	.-26     	; 0x8c9e <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8cb8:	10 92 f6 08 	sts	0x08F6, r1
    8cbc:	20 e0       	ldi	r18, 0x00	; 0
    8cbe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8cc0:	f9 01       	movw	r30, r18
    8cc2:	e4 54       	subi	r30, 0x44	; 68
    8cc4:	f8 4f       	sbci	r31, 0xF8	; 248
    8cc6:	d9 01       	movw	r26, r18
    8cc8:	a5 5e       	subi	r26, 0xE5	; 229
    8cca:	b5 4f       	sbci	r27, 0xF5	; 245
    8ccc:	8c 91       	ld	r24, X
    8cce:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8cd0:	2f 5f       	subi	r18, 0xFF	; 255
    8cd2:	3f 4f       	sbci	r19, 0xFF	; 255
    8cd4:	23 31       	cpi	r18, 0x13	; 19
    8cd6:	31 05       	cpc	r19, r1
    8cd8:	99 f7       	brne	.-26     	; 0x8cc0 <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8cda:	10 92 cf 07 	sts	0x07CF, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8cde:	80 91 2e 0a 	lds	r24, 0x0A2E
    8ce2:	80 93 84 0c 	sts	0x0C84, r24
    8ce6:	80 91 2f 0a 	lds	r24, 0x0A2F
    8cea:	80 93 85 0c 	sts	0x0C85, r24
	 }Dest[Length]=0;
    8cee:	10 92 86 0c 	sts	0x0C86, r1
    8cf2:	20 e0       	ldi	r18, 0x00	; 0
    8cf4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8cf6:	f9 01       	movw	r30, r18
    8cf8:	ec 5e       	subi	r30, 0xEC	; 236
    8cfa:	f6 4f       	sbci	r31, 0xF6	; 246
    8cfc:	d9 01       	movw	r26, r18
    8cfe:	a0 5d       	subi	r26, 0xD0	; 208
    8d00:	b5 4f       	sbci	r27, 0xF5	; 245
    8d02:	8c 91       	ld	r24, X
    8d04:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8d06:	2f 5f       	subi	r18, 0xFF	; 255
    8d08:	3f 4f       	sbci	r19, 0xFF	; 255
    8d0a:	28 30       	cpi	r18, 0x08	; 8
    8d0c:	31 05       	cpc	r19, r1
    8d0e:	99 f7       	brne	.-26     	; 0x8cf6 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8d10:	10 92 1c 09 	sts	0x091C, r1
    8d14:	20 e0       	ldi	r18, 0x00	; 0
    8d16:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8d18:	f9 01       	movw	r30, r18
    8d1a:	e5 54       	subi	r30, 0x45	; 69
    8d1c:	fd 4f       	sbci	r31, 0xFD	; 253
    8d1e:	d9 01       	movw	r26, r18
    8d20:	a8 5c       	subi	r26, 0xC8	; 200
    8d22:	b5 4f       	sbci	r27, 0xF5	; 245
    8d24:	8c 91       	ld	r24, X
    8d26:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8d28:	2f 5f       	subi	r18, 0xFF	; 255
    8d2a:	3f 4f       	sbci	r19, 0xFF	; 255
    8d2c:	28 30       	cpi	r18, 0x08	; 8
    8d2e:	31 05       	cpc	r19, r1
    8d30:	99 f7       	brne	.-26     	; 0x8d18 <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8d32:	10 92 c3 02 	sts	0x02C3, r1
    8d36:	20 e0       	ldi	r18, 0x00	; 0
    8d38:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8d3a:	f9 01       	movw	r30, r18
    8d3c:	e9 51       	subi	r30, 0x19	; 25
    8d3e:	fd 4f       	sbci	r31, 0xFD	; 253
    8d40:	d9 01       	movw	r26, r18
    8d42:	a0 5c       	subi	r26, 0xC0	; 192
    8d44:	b5 4f       	sbci	r27, 0xF5	; 245
    8d46:	8c 91       	ld	r24, X
    8d48:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8d4a:	2f 5f       	subi	r18, 0xFF	; 255
    8d4c:	3f 4f       	sbci	r19, 0xFF	; 255
    8d4e:	24 31       	cpi	r18, 0x14	; 20
    8d50:	31 05       	cpc	r19, r1
    8d52:	99 f7       	brne	.-26     	; 0x8d3a <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8d54:	10 92 fb 02 	sts	0x02FB, r1
    8d58:	20 e0       	ldi	r18, 0x00	; 0
    8d5a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8d5c:	f9 01       	movw	r30, r18
    8d5e:	ec 53       	subi	r30, 0x3C	; 60
    8d60:	fd 4f       	sbci	r31, 0xFD	; 253
    8d62:	d9 01       	movw	r26, r18
    8d64:	ac 5a       	subi	r26, 0xAC	; 172
    8d66:	b5 4f       	sbci	r27, 0xF5	; 245
    8d68:	8c 91       	ld	r24, X
    8d6a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8d6c:	2f 5f       	subi	r18, 0xFF	; 255
    8d6e:	3f 4f       	sbci	r19, 0xFF	; 255
    8d70:	2e 31       	cpi	r18, 0x1E	; 30
    8d72:	31 05       	cpc	r19, r1
    8d74:	99 f7       	brne	.-26     	; 0x8d5c <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8d76:	10 92 e2 02 	sts	0x02E2, r1
    8d7a:	20 e0       	ldi	r18, 0x00	; 0
    8d7c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8d7e:	f9 01       	movw	r30, r18
    8d80:	eb 5c       	subi	r30, 0xCB	; 203
    8d82:	f7 4f       	sbci	r31, 0xF7	; 247
    8d84:	d9 01       	movw	r26, r18
    8d86:	ae 58       	subi	r26, 0x8E	; 142
    8d88:	b5 4f       	sbci	r27, 0xF5	; 245
    8d8a:	8c 91       	ld	r24, X
    8d8c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8d8e:	2f 5f       	subi	r18, 0xFF	; 255
    8d90:	3f 4f       	sbci	r19, 0xFF	; 255
    8d92:	28 30       	cpi	r18, 0x08	; 8
    8d94:	31 05       	cpc	r19, r1
    8d96:	99 f7       	brne	.-26     	; 0x8d7e <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8d98:	10 92 3d 08 	sts	0x083D, r1
    8d9c:	20 e0       	ldi	r18, 0x00	; 0
    8d9e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8da0:	f9 01       	movw	r30, r18
    8da2:	e2 58       	subi	r30, 0x82	; 130
    8da4:	fc 4f       	sbci	r31, 0xFC	; 252
    8da6:	d9 01       	movw	r26, r18
    8da8:	a6 58       	subi	r26, 0x86	; 134
    8daa:	b5 4f       	sbci	r27, 0xF5	; 245
    8dac:	8c 91       	ld	r24, X
    8dae:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8db0:	2f 5f       	subi	r18, 0xFF	; 255
    8db2:	3f 4f       	sbci	r19, 0xFF	; 255
    8db4:	2a 30       	cpi	r18, 0x0A	; 10
    8db6:	31 05       	cpc	r19, r1
    8db8:	99 f7       	brne	.-26     	; 0x8da0 <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8dba:	10 92 88 03 	sts	0x0388, r1
    8dbe:	20 e0       	ldi	r18, 0x00	; 0
    8dc0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8dc2:	f9 01       	movw	r30, r18
    8dc4:	e3 51       	subi	r30, 0x13	; 19
    8dc6:	f4 4f       	sbci	r31, 0xF4	; 244
    8dc8:	d9 01       	movw	r26, r18
    8dca:	ac 57       	subi	r26, 0x7C	; 124
    8dcc:	b5 4f       	sbci	r27, 0xF5	; 245
    8dce:	8c 91       	ld	r24, X
    8dd0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8dd2:	2f 5f       	subi	r18, 0xFF	; 255
    8dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    8dd6:	2a 30       	cpi	r18, 0x0A	; 10
    8dd8:	31 05       	cpc	r19, r1
    8dda:	99 f7       	brne	.-26     	; 0x8dc2 <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8ddc:	10 92 f7 0b 	sts	0x0BF7, r1
    8de0:	20 e0       	ldi	r18, 0x00	; 0
    8de2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8de4:	f9 01       	movw	r30, r18
    8de6:	e5 52       	subi	r30, 0x25	; 37
    8de8:	f8 4f       	sbci	r31, 0xF8	; 248
    8dea:	d9 01       	movw	r26, r18
    8dec:	a2 57       	subi	r26, 0x72	; 114
    8dee:	b5 4f       	sbci	r27, 0xF5	; 245
    8df0:	8c 91       	ld	r24, X
    8df2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8df4:	2f 5f       	subi	r18, 0xFF	; 255
    8df6:	3f 4f       	sbci	r19, 0xFF	; 255
    8df8:	24 31       	cpi	r18, 0x14	; 20
    8dfa:	31 05       	cpc	r19, r1
    8dfc:	99 f7       	brne	.-26     	; 0x8de4 <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8dfe:	10 92 ef 07 	sts	0x07EF, r1
    8e02:	20 e0       	ldi	r18, 0x00	; 0
    8e04:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8e06:	f9 01       	movw	r30, r18
    8e08:	ee 5a       	subi	r30, 0xAE	; 174
    8e0a:	f7 4f       	sbci	r31, 0xF7	; 247
    8e0c:	d9 01       	movw	r26, r18
    8e0e:	ae 55       	subi	r26, 0x5E	; 94
    8e10:	b5 4f       	sbci	r27, 0xF5	; 245
    8e12:	8c 91       	ld	r24, X
    8e14:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8e16:	2f 5f       	subi	r18, 0xFF	; 255
    8e18:	3f 4f       	sbci	r19, 0xFF	; 255
    8e1a:	2a 30       	cpi	r18, 0x0A	; 10
    8e1c:	31 05       	cpc	r19, r1
    8e1e:	99 f7       	brne	.-26     	; 0x8e06 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8e20:	10 92 5c 08 	sts	0x085C, r1
    8e24:	20 e0       	ldi	r18, 0x00	; 0
    8e26:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8e28:	f9 01       	movw	r30, r18
    8e2a:	e6 56       	subi	r30, 0x66	; 102
    8e2c:	fc 4f       	sbci	r31, 0xFC	; 252
    8e2e:	d9 01       	movw	r26, r18
    8e30:	a4 55       	subi	r26, 0x54	; 84
    8e32:	b5 4f       	sbci	r27, 0xF5	; 245
    8e34:	8c 91       	ld	r24, X
    8e36:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8e38:	2f 5f       	subi	r18, 0xFF	; 255
    8e3a:	3f 4f       	sbci	r19, 0xFF	; 255
    8e3c:	28 30       	cpi	r18, 0x08	; 8
    8e3e:	31 05       	cpc	r19, r1
    8e40:	99 f7       	brne	.-26     	; 0x8e28 <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8e42:	10 92 a2 03 	sts	0x03A2, r1
    8e46:	20 e0       	ldi	r18, 0x00	; 0
    8e48:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8e4a:	f9 01       	movw	r30, r18
    8e4c:	e7 58       	subi	r30, 0x87	; 135
    8e4e:	f3 4f       	sbci	r31, 0xF3	; 243
    8e50:	d9 01       	movw	r26, r18
    8e52:	ac 54       	subi	r26, 0x4C	; 76
    8e54:	b5 4f       	sbci	r27, 0xF5	; 245
    8e56:	8c 91       	ld	r24, X
    8e58:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8e5a:	2f 5f       	subi	r18, 0xFF	; 255
    8e5c:	3f 4f       	sbci	r19, 0xFF	; 255
    8e5e:	2a 30       	cpi	r18, 0x0A	; 10
    8e60:	31 05       	cpc	r19, r1
    8e62:	99 f7       	brne	.-26     	; 0x8e4a <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8e64:	10 92 83 0c 	sts	0x0C83, r1
    8e68:	20 e0       	ldi	r18, 0x00	; 0
    8e6a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8e6c:	f9 01       	movw	r30, r18
    8e6e:	e6 5f       	subi	r30, 0xF6	; 246
    8e70:	f3 4f       	sbci	r31, 0xF3	; 243
    8e72:	d9 01       	movw	r26, r18
    8e74:	a2 54       	subi	r26, 0x42	; 66
    8e76:	b5 4f       	sbci	r27, 0xF5	; 245
    8e78:	8c 91       	ld	r24, X
    8e7a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8e7c:	2f 5f       	subi	r18, 0xFF	; 255
    8e7e:	3f 4f       	sbci	r19, 0xFF	; 255
    8e80:	24 31       	cpi	r18, 0x14	; 20
    8e82:	31 05       	cpc	r19, r1
    8e84:	99 f7       	brne	.-26     	; 0x8e6c <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8e86:	10 92 1e 0c 	sts	0x0C1E, r1
    8e8a:	20 e0       	ldi	r18, 0x00	; 0
    8e8c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8e8e:	f9 01       	movw	r30, r18
    8e90:	e3 53       	subi	r30, 0x33	; 51
    8e92:	fc 4f       	sbci	r31, 0xFC	; 252
    8e94:	d9 01       	movw	r26, r18
    8e96:	ae 52       	subi	r26, 0x2E	; 46
    8e98:	b5 4f       	sbci	r27, 0xF5	; 245
    8e9a:	8c 91       	ld	r24, X
    8e9c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8e9e:	2f 5f       	subi	r18, 0xFF	; 255
    8ea0:	3f 4f       	sbci	r19, 0xFF	; 255
    8ea2:	2e 31       	cpi	r18, 0x1E	; 30
    8ea4:	31 05       	cpc	r19, r1
    8ea6:	99 f7       	brne	.-26     	; 0x8e8e <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8ea8:	10 92 eb 03 	sts	0x03EB, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    8eac:	80 91 8f 01 	lds	r24, 0x018F
    8eb0:	88 23       	and	r24, r24
    8eb2:	69 f0       	breq	.+26     	; 0x8ece <procMessage99+0x46a>
    8eb4:	00 91 56 03 	lds	r16, 0x0356
    8eb8:	10 e0       	ldi	r17, 0x00	; 0
    8eba:	89 eb       	ldi	r24, 0xB9	; 185
    8ebc:	97 e0       	ldi	r25, 0x07	; 7
    8ebe:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
    8ec2:	08 17       	cp	r16, r24
    8ec4:	19 07       	cpc	r17, r25
    8ec6:	19 f4       	brne	.+6      	; 0x8ece <procMessage99+0x46a>
	        IsCompleteFilling=True;
    8ec8:	81 e0       	ldi	r24, 0x01	; 1
    8eca:	80 93 a9 01 	sts	0x01A9, r24
	   }

	  }
     return Result;     
}
    8ece:	80 e0       	ldi	r24, 0x00	; 0
    8ed0:	1f 91       	pop	r17
    8ed2:	0f 91       	pop	r16
    8ed4:	08 95       	ret

00008ed6 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    8ed6:	0f 93       	push	r16
    8ed8:	1f 93       	push	r17
    8eda:	df 93       	push	r29
    8edc:	cf 93       	push	r28
    8ede:	00 d0       	rcall	.+0      	; 0x8ee0 <GetMessageID+0xa>
    8ee0:	0f 92       	push	r0
    8ee2:	cd b7       	in	r28, 0x3d	; 61
    8ee4:	de b7       	in	r29, 0x3e	; 62
    8ee6:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ee8:	80 81       	ld	r24, Z
    8eea:	89 83       	std	Y+1, r24	; 0x01
    8eec:	81 81       	ldd	r24, Z+1	; 0x01
    8eee:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    8ef0:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    8ef2:	8e 01       	movw	r16, r28
    8ef4:	0f 5f       	subi	r16, 0xFF	; 255
    8ef6:	1f 4f       	sbci	r17, 0xFF	; 255
    8ef8:	c8 01       	movw	r24, r16
    8efa:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
	 Result=atoi(strMsgID);
    8efe:	c8 01       	movw	r24, r16
    8f00:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
  return Result;
}
    8f04:	0f 90       	pop	r0
    8f06:	0f 90       	pop	r0
    8f08:	0f 90       	pop	r0
    8f0a:	cf 91       	pop	r28
    8f0c:	df 91       	pop	r29
    8f0e:	1f 91       	pop	r17
    8f10:	0f 91       	pop	r16
    8f12:	08 95       	ret

00008f14 <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    8f14:	1f 93       	push	r17
    8f16:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    8f18:	89 31       	cpi	r24, 0x19	; 25
    8f1a:	59 f4       	brne	.+22     	; 0x8f32 <SendPrint+0x1e>
	     if (zSend==xSendLead)uart(_COM_PRINTER,1,xSendLead);
    8f1c:	40 91 f6 01 	lds	r20, 0x01F6
    8f20:	46 17       	cp	r20, r22
    8f22:	19 f4       	brne	.+6      	; 0x8f2a <SendPrint+0x16>
    8f24:	80 e0       	ldi	r24, 0x00	; 0
    8f26:	61 e0       	ldi	r22, 0x01	; 1
    8f28:	07 c0       	rjmp	.+14     	; 0x8f38 <SendPrint+0x24>
		 else uart(_COM_PRINTER,1,' ');	 
    8f2a:	80 e0       	ldi	r24, 0x00	; 0
    8f2c:	61 e0       	ldi	r22, 0x01	; 1
    8f2e:	40 e2       	ldi	r20, 0x20	; 32
    8f30:	03 c0       	rjmp	.+6      	; 0x8f38 <SendPrint+0x24>
	 } 
	 else uart(_COM_PRINTER,1,xSend);
    8f32:	80 e0       	ldi	r24, 0x00	; 0
    8f34:	61 e0       	ldi	r22, 0x01	; 1
    8f36:	41 2f       	mov	r20, r17
    8f38:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
	 zSend=xSend;
    8f3c:	10 93 f6 01 	sts	0x01F6, r17
}
    8f40:	1f 91       	pop	r17
    8f42:	08 95       	ret

00008f44 <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     uart(_COM_PRINTER, 1, 0x0D);     
    8f44:	80 e0       	ldi	r24, 0x00	; 0
    8f46:	61 e0       	ldi	r22, 0x01	; 1
    8f48:	4d e0       	ldi	r20, 0x0D	; 13
    8f4a:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
     uart(_COM_PRINTER, 1, 0x0A);
    8f4e:	80 e0       	ldi	r24, 0x00	; 0
    8f50:	61 e0       	ldi	r22, 0x01	; 1
    8f52:	4a e0       	ldi	r20, 0x0A	; 10
    8f54:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
}
    8f58:	08 95       	ret

00008f5a <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8f5a:	e1 99       	sbic	0x1c, 1	; 28
    8f5c:	fe cf       	rjmp	.-4      	; 0x8f5a <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8f5e:	80 e3       	ldi	r24, 0x30	; 48
    8f60:	90 e0       	ldi	r25, 0x00	; 0
    8f62:	9f bb       	out	0x1f, r25	; 31
    8f64:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8f66:	e0 9a       	sbi	0x1c, 0	; 28
    8f68:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    8f6a:	81 30       	cpi	r24, 0x01	; 1
    8f6c:	71 f5       	brne	.+92     	; 0x8fca <InitPrinter+0x70>
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x7C);uart(_COM_PRINTER, 1, 0x00);
    8f6e:	80 e0       	ldi	r24, 0x00	; 0
    8f70:	61 e0       	ldi	r22, 0x01	; 1
    8f72:	4d e1       	ldi	r20, 0x1D	; 29
    8f74:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8f78:	80 e0       	ldi	r24, 0x00	; 0
    8f7a:	61 e0       	ldi	r22, 0x01	; 1
    8f7c:	4c e7       	ldi	r20, 0x7C	; 124
    8f7e:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8f82:	80 e0       	ldi	r24, 0x00	; 0
    8f84:	61 e0       	ldi	r22, 0x01	; 1
    8f86:	40 e0       	ldi	r20, 0x00	; 0
    8f88:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		//Double Strike ON : 1B 47 01
		uart(_COM_PRINTER, 1, 0x1B);uart(_COM_PRINTER, 1, 0x47);uart(_COM_PRINTER, 1, 0x01);
    8f8c:	80 e0       	ldi	r24, 0x00	; 0
    8f8e:	61 e0       	ldi	r22, 0x01	; 1
    8f90:	4b e1       	ldi	r20, 0x1B	; 27
    8f92:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8f96:	80 e0       	ldi	r24, 0x00	; 0
    8f98:	61 e0       	ldi	r22, 0x01	; 1
    8f9a:	47 e4       	ldi	r20, 0x47	; 71
    8f9c:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8fa0:	80 e0       	ldi	r24, 0x00	; 0
    8fa2:	61 e0       	ldi	r22, 0x01	; 1
    8fa4:	41 e0       	ldi	r20, 0x01	; 1
    8fa6:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x01);   
    8faa:	80 e0       	ldi	r24, 0x00	; 0
    8fac:	61 e0       	ldi	r22, 0x01	; 1
    8fae:	4d e1       	ldi	r20, 0x1D	; 29
    8fb0:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8fb4:	80 e0       	ldi	r24, 0x00	; 0
    8fb6:	61 e0       	ldi	r22, 0x01	; 1
    8fb8:	41 e2       	ldi	r20, 0x21	; 33
    8fba:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8fbe:	80 e0       	ldi	r24, 0x00	; 0
    8fc0:	61 e0       	ldi	r22, 0x01	; 1
    8fc2:	41 e0       	ldi	r20, 0x01	; 1
    8fc4:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8fc8:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    8fca:	82 30       	cpi	r24, 0x02	; 2
    8fcc:	69 f5       	brne	.+90     	; 0x9028 <InitPrinter+0xce>
        //Print Density 0%
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x7C);uart(_COM_PRINTER, 1, 0x04);
    8fce:	80 e0       	ldi	r24, 0x00	; 0
    8fd0:	61 e0       	ldi	r22, 0x01	; 1
    8fd2:	4d e1       	ldi	r20, 0x1D	; 29
    8fd4:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8fd8:	80 e0       	ldi	r24, 0x00	; 0
    8fda:	61 e0       	ldi	r22, 0x01	; 1
    8fdc:	4c e7       	ldi	r20, 0x7C	; 124
    8fde:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8fe2:	80 e0       	ldi	r24, 0x00	; 0
    8fe4:	61 e0       	ldi	r22, 0x01	; 1
    8fe6:	44 e0       	ldi	r20, 0x04	; 4
    8fe8:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		//Double Strike OFF : 1B 47 00
		uart(_COM_PRINTER, 1, 0x1B);uart(_COM_PRINTER, 1, 0x47);uart(_COM_PRINTER, 1, 0x00);
    8fec:	80 e0       	ldi	r24, 0x00	; 0
    8fee:	61 e0       	ldi	r22, 0x01	; 1
    8ff0:	4b e1       	ldi	r20, 0x1B	; 27
    8ff2:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    8ff6:	80 e0       	ldi	r24, 0x00	; 0
    8ff8:	61 e0       	ldi	r22, 0x01	; 1
    8ffa:	47 e4       	ldi	r20, 0x47	; 71
    8ffc:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    9000:	80 e0       	ldi	r24, 0x00	; 0
    9002:	61 e0       	ldi	r22, 0x01	; 1
    9004:	40 e0       	ldi	r20, 0x00	; 0
    9006:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);   
    900a:	80 e0       	ldi	r24, 0x00	; 0
    900c:	61 e0       	ldi	r22, 0x01	; 1
    900e:	4d e1       	ldi	r20, 0x1D	; 29
    9010:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    9014:	80 e0       	ldi	r24, 0x00	; 0
    9016:	61 e0       	ldi	r22, 0x01	; 1
    9018:	41 e2       	ldi	r20, 0x21	; 33
    901a:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    901e:	80 e0       	ldi	r24, 0x00	; 0
    9020:	61 e0       	ldi	r22, 0x01	; 1
    9022:	40 e0       	ldi	r20, 0x00	; 0
    9024:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    9028:	08 95       	ret

0000902a <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    902a:	e1 99       	sbic	0x1c, 1	; 28
    902c:	fe cf       	rjmp	.-4      	; 0x902a <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    902e:	80 e3       	ldi	r24, 0x30	; 48
    9030:	90 e0       	ldi	r25, 0x00	; 0
    9032:	9f bb       	out	0x1f, r25	; 31
    9034:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9036:	e0 9a       	sbi	0x1c, 0	; 28
    9038:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    903a:	82 30       	cpi	r24, 0x02	; 2
    903c:	79 f4       	brne	.+30     	; 0x905c <PrintNormalHeight+0x32>
	     uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);
    903e:	80 e0       	ldi	r24, 0x00	; 0
    9040:	61 e0       	ldi	r22, 0x01	; 1
    9042:	4d e1       	ldi	r20, 0x1D	; 29
    9044:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    9048:	80 e0       	ldi	r24, 0x00	; 0
    904a:	61 e0       	ldi	r22, 0x01	; 1
    904c:	41 e2       	ldi	r20, 0x21	; 33
    904e:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    9052:	80 e0       	ldi	r24, 0x00	; 0
    9054:	61 e0       	ldi	r22, 0x01	; 1
    9056:	40 e0       	ldi	r20, 0x00	; 0
    9058:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    905c:	08 95       	ret

0000905e <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    905e:	e1 99       	sbic	0x1c, 1	; 28
    9060:	fe cf       	rjmp	.-4      	; 0x905e <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9062:	80 e3       	ldi	r24, 0x30	; 48
    9064:	90 e0       	ldi	r25, 0x00	; 0
    9066:	9f bb       	out	0x1f, r25	; 31
    9068:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    906a:	e0 9a       	sbi	0x1c, 0	; 28
    906c:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    906e:	82 30       	cpi	r24, 0x02	; 2
    9070:	79 f4       	brne	.+30     	; 0x9090 <PrintDoubleHeight+0x32>
	     uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x01);
    9072:	80 e0       	ldi	r24, 0x00	; 0
    9074:	61 e0       	ldi	r22, 0x01	; 1
    9076:	4d e1       	ldi	r20, 0x1D	; 29
    9078:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    907c:	80 e0       	ldi	r24, 0x00	; 0
    907e:	61 e0       	ldi	r22, 0x01	; 1
    9080:	41 e2       	ldi	r20, 0x21	; 33
    9082:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    9086:	80 e0       	ldi	r24, 0x00	; 0
    9088:	61 e0       	ldi	r22, 0x01	; 1
    908a:	41 e0       	ldi	r20, 0x01	; 1
    908c:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
    9090:	08 95       	ret

00009092 <PaperCut>:

	 return Result;
}


void PaperCut(){
    9092:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9094:	e1 99       	sbic	0x1c, 1	; 28
    9096:	fe cf       	rjmp	.-4      	; 0x9094 <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9098:	83 e3       	ldi	r24, 0x33	; 51
    909a:	90 e0       	ldi	r25, 0x00	; 0
    909c:	9f bb       	out	0x1f, r25	; 31
    909e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    90a0:	e0 9a       	sbi	0x1c, 0	; 28
    90a2:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&DefPrintAutoCut);
     uart(_COM_PRINTER, 1, 0x1B);
    90a4:	80 e0       	ldi	r24, 0x00	; 0
    90a6:	61 e0       	ldi	r22, 0x01	; 1
    90a8:	4b e1       	ldi	r20, 0x1B	; 27
    90aa:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
	 if(CutType== 1) { uart(_COM_PRINTER, 1, 0x6D);}
    90ae:	11 30       	cpi	r17, 0x01	; 1
    90b0:	21 f4       	brne	.+8      	; 0x90ba <PaperCut+0x28>
    90b2:	80 e0       	ldi	r24, 0x00	; 0
    90b4:	61 e0       	ldi	r22, 0x01	; 1
    90b6:	4d e6       	ldi	r20, 0x6D	; 109
    90b8:	05 c0       	rjmp	.+10     	; 0x90c4 <PaperCut+0x32>
	 if(CutType== 2) {uart(_COM_PRINTER, 1, 0x69);}
    90ba:	12 30       	cpi	r17, 0x02	; 2
    90bc:	29 f4       	brne	.+10     	; 0x90c8 <PaperCut+0x36>
    90be:	80 e0       	ldi	r24, 0x00	; 0
    90c0:	61 e0       	ldi	r22, 0x01	; 1
    90c2:	49 e6       	ldi	r20, 0x69	; 105
    90c4:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>

}
    90c8:	1f 91       	pop	r17
    90ca:	08 95       	ret

000090cc <procMessage11>:
}




void procMessage11(){
    90cc:	6f 92       	push	r6
    90ce:	7f 92       	push	r7
    90d0:	8f 92       	push	r8
    90d2:	9f 92       	push	r9
    90d4:	af 92       	push	r10
    90d6:	bf 92       	push	r11
    90d8:	cf 92       	push	r12
    90da:	df 92       	push	r13
    90dc:	ef 92       	push	r14
    90de:	ff 92       	push	r15
    90e0:	0f 93       	push	r16
    90e2:	1f 93       	push	r17
    90e4:	df 93       	push	r29
    90e6:	cf 93       	push	r28
    90e8:	cd b7       	in	r28, 0x3d	; 61
    90ea:	de b7       	in	r29, 0x3e	; 62
    90ec:	c0 59       	subi	r28, 0x90	; 144
    90ee:	d0 40       	sbci	r29, 0x00	; 0
    90f0:	0f b6       	in	r0, 0x3f	; 63
    90f2:	f8 94       	cli
    90f4:	de bf       	out	0x3e, r29	; 62
    90f6:	0f be       	out	0x3f, r0	; 63
    90f8:	cd bf       	out	0x3d, r28	; 61
    90fa:	20 e0       	ldi	r18, 0x00	; 0
    90fc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    90fe:	ae 01       	movw	r20, r28
    9100:	46 5f       	subi	r20, 0xF6	; 246
    9102:	5f 4f       	sbci	r21, 0xFF	; 255
    9104:	fa 01       	movw	r30, r20
    9106:	e2 0f       	add	r30, r18
    9108:	f3 1f       	adc	r31, r19
    910a:	d9 01       	movw	r26, r18
    910c:	a3 5e       	subi	r26, 0xE3	; 227
    910e:	b6 4f       	sbci	r27, 0xF6	; 246
    9110:	9b 96       	adiw	r26, 0x2b	; 43
    9112:	8c 91       	ld	r24, X
    9114:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9116:	2f 5f       	subi	r18, 0xFF	; 255
    9118:	3f 4f       	sbci	r19, 0xFF	; 255
    911a:	2a 30       	cpi	r18, 0x0A	; 10
    911c:	31 05       	cpc	r19, r1
    911e:	91 f7       	brne	.-28     	; 0x9104 <procMessage11+0x38>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9120:	fa 01       	movw	r30, r20
    9122:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[50],strReadEEPROM[50];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    9124:	81 e0       	ldi	r24, 0x01	; 1
    9126:	ba 01       	movw	r22, r20
    9128:	0e 94 07 28 	call	0x500e	; 0x500e <FormatDate>
    912c:	20 e0       	ldi	r18, 0x00	; 0
    912e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9130:	ae 01       	movw	r20, r28
    9132:	4c 5e       	subi	r20, 0xEC	; 236
    9134:	5f 4f       	sbci	r21, 0xFF	; 255
    9136:	fa 01       	movw	r30, r20
    9138:	e2 0f       	add	r30, r18
    913a:	f3 1f       	adc	r31, r19
    913c:	d9 01       	movw	r26, r18
    913e:	a3 5e       	subi	r26, 0xE3	; 227
    9140:	b6 4f       	sbci	r27, 0xF6	; 246
    9142:	d6 96       	adiw	r26, 0x36	; 54
    9144:	8c 91       	ld	r24, X
    9146:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9148:	2f 5f       	subi	r18, 0xFF	; 255
    914a:	3f 4f       	sbci	r19, 0xFF	; 255
    914c:	28 30       	cpi	r18, 0x08	; 8
    914e:	31 05       	cpc	r19, r1
    9150:	91 f7       	brne	.-28     	; 0x9136 <procMessage11+0x6a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9152:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    9154:	81 e0       	ldi	r24, 0x01	; 1
    9156:	be 01       	movw	r22, r28
    9158:	66 5f       	subi	r22, 0xF6	; 246
    915a:	7f 4f       	sbci	r23, 0xFF	; 255
    915c:	0e 94 e3 ac 	call	0x159c6	; 0x159c6 <_datetime>
    9160:	07 e2       	ldi	r16, 0x27	; 39
    9162:	12 e0       	ldi	r17, 0x02	; 2
    9164:	ab e5       	ldi	r26, 0x5B	; 91
    9166:	ea 2e       	mov	r14, r26
    9168:	a9 e0       	ldi	r26, 0x09	; 9
    916a:	fa 2e       	mov	r15, r26
    916c:	fd e2       	ldi	r31, 0x2D	; 45
    916e:	cf 2e       	mov	r12, r31
    9170:	d1 2c       	mov	r13, r1
    9172:	cc 0e       	add	r12, r28
    9174:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9176:	e8 e2       	ldi	r30, 0x28	; 40
    9178:	ae 2e       	mov	r10, r30
    917a:	b1 2c       	mov	r11, r1
    917c:	ac 0c       	add	r10, r12
    917e:	bd 1c       	adc	r11, r13
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    9180:	75 e5       	ldi	r23, 0x55	; 85
    9182:	67 2e       	mov	r6, r23
    9184:	71 2c       	mov	r7, r1
    9186:	6c 0e       	add	r6, r28
    9188:	7d 1e       	adc	r7, r29
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    918a:	6f e5       	ldi	r22, 0x5F	; 95
    918c:	86 2e       	mov	r8, r22
    918e:	91 2c       	mov	r9, r1
    9190:	8c 0e       	add	r8, r28
    9192:	9d 1e       	adc	r9, r29

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    9194:	f6 01       	movw	r30, r12
    9196:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9198:	8d 91       	ld	r24, X+
    919a:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    919c:	ea 15       	cp	r30, r10
    919e:	fb 05       	cpc	r31, r11
    91a0:	d9 f7       	brne	.-10     	; 0x9198 <procMessage11+0xcc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    91a2:	f3 01       	movw	r30, r6
    91a4:	10 82       	st	Z, r1
    91a6:	c4 01       	movw	r24, r8
    91a8:	b8 01       	movw	r22, r16
    91aa:	49 e2       	ldi	r20, 0x29	; 41
    91ac:	50 e0       	ldi	r21, 0x00	; 0
    91ae:	22 ed       	ldi	r18, 0xD2	; 210
    91b0:	33 e1       	ldi	r19, 0x13	; 19
    91b2:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	 //HeaderFooter
	 for(i=0;i<10;i++){
	     FillChar(buffHeader,0,sizeof(buffHeader));   
         StrPosCopy(rcv_trans,buffHeader,62+(i*40),40);
		 eeprom_read_block((void*) &strReadEEPROM, (const void*) &DefHeaderFooter[i],41);
	     if (strcmp(strReadEEPROM,buffHeader)!=0)
    91b6:	c4 01       	movw	r24, r8
    91b8:	b6 01       	movw	r22, r12
    91ba:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    91be:	00 97       	sbiw	r24, 0x00	; 0
    91c0:	41 f0       	breq	.+16     	; 0x91d2 <procMessage11+0x106>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    91c2:	c8 01       	movw	r24, r16
    91c4:	b6 01       	movw	r22, r12
    91c6:	49 e2       	ldi	r20, 0x29	; 41
    91c8:	50 e0       	ldi	r21, 0x00	; 0
    91ca:	2a ed       	ldi	r18, 0xDA	; 218
    91cc:	33 e1       	ldi	r19, 0x13	; 19
    91ce:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
    91d2:	07 5d       	subi	r16, 0xD7	; 215
    91d4:	1f 4f       	sbci	r17, 0xFF	; 255
    91d6:	88 e2       	ldi	r24, 0x28	; 40
    91d8:	90 e0       	ldi	r25, 0x00	; 0
    91da:	e8 0e       	add	r14, r24
    91dc:	f9 1e       	adc	r15, r25
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
	      
	 //HeaderFooter
	 for(i=0;i<10;i++){
    91de:	93 e0       	ldi	r25, 0x03	; 3
    91e0:	01 3c       	cpi	r16, 0xC1	; 193
    91e2:	19 07       	cpc	r17, r25
    91e4:	b9 f6       	brne	.-82     	; 0x9194 <procMessage11+0xc8>
    91e6:	0b eb       	ldi	r16, 0xBB	; 187
    91e8:	10 e0       	ldi	r17, 0x00	; 0
    91ea:	53 e0       	ldi	r21, 0x03	; 3
    91ec:	e5 2e       	mov	r14, r21
    91ee:	5b e0       	ldi	r21, 0x0B	; 11
    91f0:	f5 2e       	mov	r15, r21
    91f2:	40 e2       	ldi	r20, 0x20	; 32
    91f4:	c4 2e       	mov	r12, r20
    91f6:	d1 2c       	mov	r13, r1
    91f8:	cc 0e       	add	r12, r28
    91fa:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    91fc:	3c e2       	ldi	r19, 0x2C	; 44
    91fe:	83 2e       	mov	r8, r19
    9200:	91 2c       	mov	r9, r1
    9202:	8c 0e       	add	r8, r28
    9204:	9d 1e       	adc	r9, r29
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9206:	2f e5       	ldi	r18, 0x5F	; 95
    9208:	a2 2e       	mov	r10, r18
    920a:	b1 2c       	mov	r11, r1
    920c:	ac 0e       	add	r10, r28
    920e:	bd 1e       	adc	r11, r29
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
	      
	 //HeaderFooter
	 for(i=0;i<10;i++){
    9210:	f6 01       	movw	r30, r12
    9212:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9214:	8d 91       	ld	r24, X+
    9216:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9218:	e8 15       	cp	r30, r8
    921a:	f9 05       	cpc	r31, r9
    921c:	d9 f7       	brne	.-10     	; 0x9214 <procMessage11+0x148>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    921e:	1c a6       	std	Y+44, r1	; 0x2c
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 */
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    9220:	c6 01       	movw	r24, r12
    9222:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
    9226:	c5 01       	movw	r24, r10
    9228:	b8 01       	movw	r22, r16
    922a:	4c e0       	ldi	r20, 0x0C	; 12
    922c:	50 e0       	ldi	r21, 0x00	; 0
    922e:	22 ed       	ldi	r18, 0xD2	; 210
    9230:	33 e1       	ldi	r19, 0x13	; 19
    9232:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		eeprom_read_block((void*) &strReadEEPROM, (const void*) &DefProductName[i],12);
		if (strcmp(strReadEEPROM,strProductName)!=0)
    9236:	c5 01       	movw	r24, r10
    9238:	b6 01       	movw	r22, r12
    923a:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    923e:	00 97       	sbiw	r24, 0x00	; 0
    9240:	41 f0       	breq	.+16     	; 0x9252 <procMessage11+0x186>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9242:	c8 01       	movw	r24, r16
    9244:	b6 01       	movw	r22, r12
    9246:	4c e0       	ldi	r20, 0x0C	; 12
    9248:	50 e0       	ldi	r21, 0x00	; 0
    924a:	2a ed       	ldi	r18, 0xDA	; 218
    924c:	33 e1       	ldi	r19, 0x13	; 19
    924e:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
    9252:	03 5f       	subi	r16, 0xF3	; 243
    9254:	1f 4f       	sbci	r17, 0xFF	; 255
    9256:	ec e0       	ldi	r30, 0x0C	; 12
    9258:	f0 e0       	ldi	r31, 0x00	; 0
    925a:	ee 0e       	add	r14, r30
    925c:	ff 1e       	adc	r15, r31
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 */
	 //ProductName
	 for(i=0;i<6;i++){
    925e:	f1 e0       	ldi	r31, 0x01	; 1
    9260:	09 30       	cpi	r16, 0x09	; 9
    9262:	1f 07       	cpc	r17, r31
    9264:	a9 f6       	brne	.-86     	; 0x9210 <procMessage11+0x144>
    9266:	05 e8       	ldi	r16, 0x85	; 133
    9268:	10 e0       	ldi	r17, 0x00	; 0
    926a:	9b e4       	ldi	r25, 0x4B	; 75
    926c:	e9 2e       	mov	r14, r25
    926e:	9b e0       	ldi	r25, 0x0B	; 11
    9270:	f9 2e       	mov	r15, r25
    9272:	6e 01       	movw	r12, r28
    9274:	08 94       	sec
    9276:	c1 1c       	adc	r12, r1
    9278:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    927a:	89 e0       	ldi	r24, 0x09	; 9
    927c:	88 2e       	mov	r8, r24
    927e:	91 2c       	mov	r9, r1
    9280:	8c 0e       	add	r8, r28
    9282:	9d 1e       	adc	r9, r29
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9284:	bf e5       	ldi	r27, 0x5F	; 95
    9286:	ab 2e       	mov	r10, r27
    9288:	b1 2c       	mov	r11, r1
    928a:	ac 0e       	add	r10, r28
    928c:	bd 1e       	adc	r11, r29
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 */
	 //ProductName
	 for(i=0;i<6;i++){
    928e:	f6 01       	movw	r30, r12
    9290:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    9292:	8d 91       	ld	r24, X+
    9294:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    9296:	e8 15       	cp	r30, r8
    9298:	f9 05       	cpc	r31, r9
    929a:	d9 f7       	brne	.-10     	; 0x9292 <procMessage11+0x1c6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    929c:	19 86       	std	Y+9, r1	; 0x09
		    eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    929e:	c6 01       	movw	r24, r12
    92a0:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    92a4:	c6 01       	movw	r24, r12
    92a6:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		RemDecimal(strProductPrice);
    92aa:	c6 01       	movw	r24, r12
    92ac:	0e 94 50 27 	call	0x4ea0	; 0x4ea0 <RemDecimal>
    92b0:	c5 01       	movw	r24, r10
    92b2:	b8 01       	movw	r22, r16
    92b4:	48 e0       	ldi	r20, 0x08	; 8
    92b6:	50 e0       	ldi	r21, 0x00	; 0
    92b8:	22 ed       	ldi	r18, 0xD2	; 210
    92ba:	33 e1       	ldi	r19, 0x13	; 19
    92bc:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>

		eeprom_read_block((void*) &strReadEEPROM, (const void*) &DefProductPrice[i], 8);
		if (strcmp(strReadEEPROM,strProductPrice)!=0)
    92c0:	c5 01       	movw	r24, r10
    92c2:	b6 01       	movw	r22, r12
    92c4:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    92c8:	00 97       	sbiw	r24, 0x00	; 0
    92ca:	41 f0       	breq	.+16     	; 0x92dc <procMessage11+0x210>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    92cc:	c8 01       	movw	r24, r16
    92ce:	b6 01       	movw	r22, r12
    92d0:	48 e0       	ldi	r20, 0x08	; 8
    92d2:	50 e0       	ldi	r21, 0x00	; 0
    92d4:	2a ed       	ldi	r18, 0xDA	; 218
    92d6:	33 e1       	ldi	r19, 0x13	; 19
    92d8:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
    92dc:	07 5f       	subi	r16, 0xF7	; 247
    92de:	1f 4f       	sbci	r17, 0xFF	; 255
    92e0:	88 e0       	ldi	r24, 0x08	; 8
    92e2:	90 e0       	ldi	r25, 0x00	; 0
    92e4:	e8 0e       	add	r14, r24
    92e6:	f9 1e       	adc	r15, r25
		eeprom_read_block((void*) &strReadEEPROM, (const void*) &DefProductName[i],12);
		if (strcmp(strReadEEPROM,strProductName)!=0)
		    eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    92e8:	90 e0       	ldi	r25, 0x00	; 0
    92ea:	0b 3b       	cpi	r16, 0xBB	; 187
    92ec:	19 07       	cpc	r17, r25
    92ee:	79 f6       	brne	.-98     	; 0x928e <procMessage11+0x1c2>

		eeprom_read_block((void*) &strReadEEPROM, (const void*) &DefProductPrice[i], 8);
		if (strcmp(strReadEEPROM,strProductPrice)!=0)
		    eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    92f0:	c0 57       	subi	r28, 0x70	; 112
    92f2:	df 4f       	sbci	r29, 0xFF	; 255
    92f4:	0f b6       	in	r0, 0x3f	; 63
    92f6:	f8 94       	cli
    92f8:	de bf       	out	0x3e, r29	; 62
    92fa:	0f be       	out	0x3f, r0	; 63
    92fc:	cd bf       	out	0x3d, r28	; 61
    92fe:	cf 91       	pop	r28
    9300:	df 91       	pop	r29
    9302:	1f 91       	pop	r17
    9304:	0f 91       	pop	r16
    9306:	ff 90       	pop	r15
    9308:	ef 90       	pop	r14
    930a:	df 90       	pop	r13
    930c:	cf 90       	pop	r12
    930e:	bf 90       	pop	r11
    9310:	af 90       	pop	r10
    9312:	9f 90       	pop	r9
    9314:	8f 90       	pop	r8
    9316:	7f 90       	pop	r7
    9318:	6f 90       	pop	r6
    931a:	08 95       	ret

0000931c <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    931c:	ef 92       	push	r14
    931e:	ff 92       	push	r15
    9320:	0f 93       	push	r16
    9322:	1f 93       	push	r17
    9324:	cf 93       	push	r28
    9326:	df 93       	push	r29
    9328:	ec 01       	movw	r28, r24
    932a:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    932c:	08 81       	ld	r16, Y
    932e:	00 53       	subi	r16, 0x30	; 48
    9330:	10 e0       	ldi	r17, 0x00	; 0
    9332:	04 c0       	rjmp	.+8      	; 0x933c <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    9334:	ce 01       	movw	r24, r28
    9336:	0e 94 10 34 	call	0x6820	; 0x6820 <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    933a:	1f 5f       	subi	r17, 0xFF	; 255
    933c:	10 17       	cp	r17, r16
    933e:	d0 f3       	brcs	.-12     	; 0x9334 <ValidateRestoreCode+0x18>
	 //uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    9340:	ce 01       	movw	r24, r28
    9342:	b7 01       	movw	r22, r14
    9344:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    9348:	00 97       	sbiw	r24, 0x00	; 0
    934a:	11 f0       	breq	.+4      	; 0x9350 <ValidateRestoreCode+0x34>
    934c:	82 e0       	ldi	r24, 0x02	; 2
    934e:	01 c0       	rjmp	.+2      	; 0x9352 <ValidateRestoreCode+0x36>
    9350:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    9352:	df 91       	pop	r29
    9354:	cf 91       	pop	r28
    9356:	1f 91       	pop	r17
    9358:	0f 91       	pop	r16
    935a:	ff 90       	pop	r15
    935c:	ef 90       	pop	r14
    935e:	08 95       	ret

00009360 <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    9360:	ef 92       	push	r14
    9362:	ff 92       	push	r15
    9364:	0f 93       	push	r16
    9366:	1f 93       	push	r17
    9368:	df 93       	push	r29
    936a:	cf 93       	push	r28
    936c:	cd b7       	in	r28, 0x3d	; 61
    936e:	de b7       	in	r29, 0x3e	; 62
    9370:	2a 97       	sbiw	r28, 0x0a	; 10
    9372:	0f b6       	in	r0, 0x3f	; 63
    9374:	f8 94       	cli
    9376:	de bf       	out	0x3e, r29	; 62
    9378:	0f be       	out	0x3f, r0	; 63
    937a:	cd bf       	out	0x3d, r28	; 61
    937c:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    937e:	fb 01       	movw	r30, r22
    9380:	01 90       	ld	r0, Z+
    9382:	00 20       	and	r0, r0
    9384:	e9 f7       	brne	.-6      	; 0x9380 <ValidateGeniusCode+0x20>
    9386:	39 97       	sbiw	r30, 0x09	; 9
    9388:	e6 17       	cp	r30, r22
    938a:	f7 07       	cpc	r31, r23
    938c:	11 f0       	breq	.+4      	; 0x9392 <ValidateGeniusCode+0x32>
    938e:	80 e0       	ldi	r24, 0x00	; 0
    9390:	11 c0       	rjmp	.+34     	; 0x93b4 <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    9392:	fb 01       	movw	r30, r22
    9394:	60 81       	ld	r22, Z
    9396:	8e 01       	movw	r16, r28
    9398:	0f 5f       	subi	r16, 0xFF	; 255
    939a:	1f 4f       	sbci	r17, 0xFF	; 255
    939c:	a8 01       	movw	r20, r16
    939e:	0e 94 0e 35 	call	0x6a1c	; 0x6a1c <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    93a2:	c8 01       	movw	r24, r16
    93a4:	b7 01       	movw	r22, r14
    93a6:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    93aa:	00 97       	sbiw	r24, 0x00	; 0
    93ac:	11 f0       	breq	.+4      	; 0x93b2 <ValidateGeniusCode+0x52>
    93ae:	82 e0       	ldi	r24, 0x02	; 2
    93b0:	01 c0       	rjmp	.+2      	; 0x93b4 <ValidateGeniusCode+0x54>
    93b2:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    93b4:	2a 96       	adiw	r28, 0x0a	; 10
    93b6:	0f b6       	in	r0, 0x3f	; 63
    93b8:	f8 94       	cli
    93ba:	de bf       	out	0x3e, r29	; 62
    93bc:	0f be       	out	0x3f, r0	; 63
    93be:	cd bf       	out	0x3d, r28	; 61
    93c0:	cf 91       	pop	r28
    93c2:	df 91       	pop	r29
    93c4:	1f 91       	pop	r17
    93c6:	0f 91       	pop	r16
    93c8:	ff 90       	pop	r15
    93ca:	ef 90       	pop	r14
    93cc:	08 95       	ret

000093ce <_scr_pump>:

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    93ce:	8f 92       	push	r8
    93d0:	9f 92       	push	r9
    93d2:	af 92       	push	r10
    93d4:	bf 92       	push	r11
    93d6:	cf 92       	push	r12
    93d8:	df 92       	push	r13
    93da:	ef 92       	push	r14
    93dc:	ff 92       	push	r15
    93de:	0f 93       	push	r16
    93e0:	1f 93       	push	r17
    93e2:	df 93       	push	r29
    93e4:	cf 93       	push	r28
    93e6:	cd b7       	in	r28, 0x3d	; 61
    93e8:	de b7       	in	r29, 0x3e	; 62
    93ea:	6c 97       	sbiw	r28, 0x1c	; 28
    93ec:	0f b6       	in	r0, 0x3f	; 63
    93ee:	f8 94       	cli
    93f0:	de bf       	out	0x3e, r29	; 62
    93f2:	0f be       	out	0x3f, r0	; 63
    93f4:	cd bf       	out	0x3d, r28	; 61
	 //char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    93f6:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    93fa:	80 e0       	ldi	r24, 0x00	; 0
    93fc:	90 e9       	ldi	r25, 0x90	; 144
    93fe:	01 97       	sbiw	r24, 0x01	; 1
    9400:	f1 f7       	brne	.-4      	; 0x93fe <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9402:	8e 01       	movw	r16, r28
    9404:	0f 5f       	subi	r16, 0xFF	; 255
    9406:	1f 4f       	sbci	r17, 0xFF	; 255
    9408:	c8 01       	movw	r24, r16
    940a:	65 e4       	ldi	r22, 0x45	; 69
    940c:	70 e0       	ldi	r23, 0x00	; 0
    940e:	48 e0       	ldi	r20, 0x08	; 8
    9410:	50 e0       	ldi	r21, 0x00	; 0
    9412:	22 ed       	ldi	r18, 0xD2	; 210
    9414:	33 e1       	ldi	r19, 0x13	; 19
    9416:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    941a:	78 01       	movw	r14, r16
    941c:	01 e0       	ldi	r16, 0x01	; 1
    941e:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    9420:	99 e0       	ldi	r25, 0x09	; 9
    9422:	c9 2e       	mov	r12, r25
    9424:	d1 2c       	mov	r13, r1
    9426:	cc 0e       	add	r12, r28
    9428:	dd 1e       	adc	r13, r29
    942a:	84 ed       	ldi	r24, 0xD4	; 212
    942c:	88 2e       	mov	r8, r24
    942e:	8e e0       	ldi	r24, 0x0E	; 14
    9430:	98 2e       	mov	r9, r24
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    9432:	b5 e0       	ldi	r27, 0x05	; 5
    9434:	ab 2e       	mov	r10, r27
    9436:	b1 2c       	mov	r11, r1
    9438:	ac 0e       	add	r10, r28
    943a:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    943c:	8d b7       	in	r24, 0x3d	; 61
    943e:	9e b7       	in	r25, 0x3e	; 62
    9440:	0c 97       	sbiw	r24, 0x0c	; 12
    9442:	0f b6       	in	r0, 0x3f	; 63
    9444:	f8 94       	cli
    9446:	9e bf       	out	0x3e, r25	; 62
    9448:	0f be       	out	0x3f, r0	; 63
    944a:	8d bf       	out	0x3d, r24	; 61
    944c:	ed b7       	in	r30, 0x3d	; 61
    944e:	fe b7       	in	r31, 0x3e	; 62
    9450:	31 96       	adiw	r30, 0x01	; 1
    9452:	ad b7       	in	r26, 0x3d	; 61
    9454:	be b7       	in	r27, 0x3e	; 62
    9456:	12 96       	adiw	r26, 0x02	; 2
    9458:	dc 92       	st	X, r13
    945a:	ce 92       	st	-X, r12
    945c:	11 97       	sbiw	r26, 0x01	; 1
    945e:	93 82       	std	Z+3, r9	; 0x03
    9460:	82 82       	std	Z+2, r8	; 0x02
    9462:	15 83       	std	Z+5, r17	; 0x05
    9464:	04 83       	std	Z+4, r16	; 0x04
    9466:	d7 01       	movw	r26, r14
    9468:	8c 91       	ld	r24, X
    946a:	86 83       	std	Z+6, r24	; 0x06
    946c:	17 82       	std	Z+7, r1	; 0x07
    946e:	0c 5f       	subi	r16, 0xFC	; 252
    9470:	1f 4f       	sbci	r17, 0xFF	; 255
    9472:	11 87       	std	Z+9, r17	; 0x09
    9474:	00 87       	std	Z+8, r16	; 0x08
    9476:	04 50       	subi	r16, 0x04	; 4
    9478:	10 40       	sbci	r17, 0x00	; 0
    947a:	14 96       	adiw	r26, 0x04	; 4
    947c:	8c 91       	ld	r24, X
    947e:	82 87       	std	Z+10, r24	; 0x0a
    9480:	13 86       	std	Z+11, r1	; 0x0b
    9482:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    9486:	8d b7       	in	r24, 0x3d	; 61
    9488:	9e b7       	in	r25, 0x3e	; 62
    948a:	0c 96       	adiw	r24, 0x0c	; 12
    948c:	0f b6       	in	r0, 0x3f	; 63
    948e:	f8 94       	cli
    9490:	9e bf       	out	0x3e, r25	; 62
    9492:	0f be       	out	0x3f, r0	; 63
    9494:	8d bf       	out	0x3d, r24	; 61
    9496:	80 2f       	mov	r24, r16
    9498:	61 e0       	ldi	r22, 0x01	; 1
    949a:	a6 01       	movw	r20, r12
    949c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    94a0:	08 94       	sec
    94a2:	e1 1c       	adc	r14, r1
    94a4:	f1 1c       	adc	r15, r1
    94a6:	0f 5f       	subi	r16, 0xFF	; 255
    94a8:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    94aa:	ea 14       	cp	r14, r10
    94ac:	fb 04       	cpc	r15, r11
    94ae:	31 f6       	brne	.-116    	; 0x943c <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    94b0:	84 e0       	ldi	r24, 0x04	; 4
    94b2:	6f e0       	ldi	r22, 0x0F	; 15
    94b4:	4d ec       	ldi	r20, 0xCD	; 205
    94b6:	5e e0       	ldi	r21, 0x0E	; 14
    94b8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
}
    94bc:	6c 96       	adiw	r28, 0x1c	; 28
    94be:	0f b6       	in	r0, 0x3f	; 63
    94c0:	f8 94       	cli
    94c2:	de bf       	out	0x3e, r29	; 62
    94c4:	0f be       	out	0x3f, r0	; 63
    94c6:	cd bf       	out	0x3d, r28	; 61
    94c8:	cf 91       	pop	r28
    94ca:	df 91       	pop	r29
    94cc:	1f 91       	pop	r17
    94ce:	0f 91       	pop	r16
    94d0:	ff 90       	pop	r15
    94d2:	ef 90       	pop	r14
    94d4:	df 90       	pop	r13
    94d6:	cf 90       	pop	r12
    94d8:	bf 90       	pop	r11
    94da:	af 90       	pop	r10
    94dc:	9f 90       	pop	r9
    94de:	8f 90       	pop	r8
    94e0:	08 95       	ret

000094e2 <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    94e2:	80 91 6d 02 	lds	r24, 0x026D
    94e6:	81 30       	cpi	r24, 0x01	; 1
    94e8:	49 f0       	breq	.+18     	; 0x94fc <FViewFreeMessage+0x1a>
    94ea:	81 30       	cpi	r24, 0x01	; 1
    94ec:	28 f0       	brcs	.+10     	; 0x94f8 <FViewFreeMessage+0x16>
    94ee:	82 30       	cpi	r24, 0x02	; 2
    94f0:	19 f1       	breq	.+70     	; 0x9538 <FViewFreeMessage+0x56>
    94f2:	83 30       	cpi	r24, 0x03	; 3
    94f4:	71 f5       	brne	.+92     	; 0x9552 <FViewFreeMessage+0x70>
    94f6:	29 c0       	rjmp	.+82     	; 0x954a <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    94f8:	81 e0       	ldi	r24, 0x01	; 1
    94fa:	23 c0       	rjmp	.+70     	; 0x9542 <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    94fc:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    9500:	81 e0       	ldi	r24, 0x01	; 1
    9502:	61 e0       	ldi	r22, 0x01	; 1
    9504:	42 e9       	ldi	r20, 0x92	; 146
    9506:	58 e0       	ldi	r21, 0x08	; 8
    9508:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    950c:	82 e0       	ldi	r24, 0x02	; 2
    950e:	61 e0       	ldi	r22, 0x01	; 1
    9510:	43 ea       	ldi	r20, 0xA3	; 163
    9512:	57 e0       	ldi	r21, 0x07	; 7
    9514:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    9518:	83 e0       	ldi	r24, 0x03	; 3
    951a:	61 e0       	ldi	r22, 0x01	; 1
    951c:	4c e1       	ldi	r20, 0x1C	; 28
    951e:	58 e0       	ldi	r21, 0x08	; 8
    9520:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    9524:	84 e0       	ldi	r24, 0x04	; 4
    9526:	61 e0       	ldi	r22, 0x01	; 1
    9528:	46 ed       	ldi	r20, 0xD6	; 214
    952a:	5b e0       	ldi	r21, 0x0B	; 11
    952c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	      TimDisplay=0;
    9530:	10 92 92 01 	sts	0x0192, r1
	      stFreeMessage=fmDelayViewMesage;
    9534:	82 e0       	ldi	r24, 0x02	; 2
    9536:	05 c0       	rjmp	.+10     	; 0x9542 <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    9538:	80 91 92 01 	lds	r24, 0x0192
    953c:	8b 30       	cpi	r24, 0x0B	; 11
    953e:	48 f0       	brcs	.+18     	; 0x9552 <FViewFreeMessage+0x70>
    9540:	83 e0       	ldi	r24, 0x03	; 3
    9542:	80 93 6d 02 	sts	0x026D, r24
    9546:	80 e0       	ldi	r24, 0x00	; 0
    9548:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    954a:	10 92 6d 02 	sts	0x026D, r1
    954e:	81 e0       	ldi	r24, 0x01	; 1
    9550:	08 95       	ret
    9552:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    9554:	08 95       	ret

00009556 <FTestChar>:
		TimTicker++;
	}

}

char FTestChar(){
    9556:	0f 93       	push	r16
    9558:	1f 93       	push	r17
    955a:	df 93       	push	r29
    955c:	cf 93       	push	r28
    955e:	cd b7       	in	r28, 0x3d	; 61
    9560:	de b7       	in	r29, 0x3e	; 62
    9562:	64 97       	sbiw	r28, 0x14	; 20
    9564:	0f b6       	in	r0, 0x3f	; 63
    9566:	f8 94       	cli
    9568:	de bf       	out	0x3e, r29	; 62
    956a:	0f be       	out	0x3f, r0	; 63
    956c:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    956e:	8d b7       	in	r24, 0x3d	; 61
    9570:	9e b7       	in	r25, 0x3e	; 62
    9572:	08 97       	sbiw	r24, 0x08	; 8
    9574:	0f b6       	in	r0, 0x3f	; 63
    9576:	f8 94       	cli
    9578:	9e bf       	out	0x3e, r25	; 62
    957a:	0f be       	out	0x3f, r0	; 63
    957c:	8d bf       	out	0x3d, r24	; 61
    957e:	ed b7       	in	r30, 0x3d	; 61
    9580:	fe b7       	in	r31, 0x3e	; 62
    9582:	31 96       	adiw	r30, 0x01	; 1
    9584:	8e 01       	movw	r16, r28
    9586:	0f 5f       	subi	r16, 0xFF	; 255
    9588:	1f 4f       	sbci	r17, 0xFF	; 255
    958a:	ad b7       	in	r26, 0x3d	; 61
    958c:	be b7       	in	r27, 0x3e	; 62
    958e:	12 96       	adiw	r26, 0x02	; 2
    9590:	1c 93       	st	X, r17
    9592:	0e 93       	st	-X, r16
    9594:	11 97       	sbiw	r26, 0x01	; 1
    9596:	83 e6       	ldi	r24, 0x63	; 99
    9598:	9e e1       	ldi	r25, 0x1E	; 30
    959a:	93 83       	std	Z+3, r25	; 0x03
    959c:	82 83       	std	Z+2, r24	; 0x02
    959e:	15 82       	std	Z+5, r1	; 0x05
    95a0:	14 82       	std	Z+4, r1	; 0x04
    95a2:	17 82       	std	Z+7, r1	; 0x07
    95a4:	16 82       	std	Z+6, r1	; 0x06
    95a6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
     lcd_print(1,1,lcdteks);
    95aa:	8d b7       	in	r24, 0x3d	; 61
    95ac:	9e b7       	in	r25, 0x3e	; 62
    95ae:	08 96       	adiw	r24, 0x08	; 8
    95b0:	0f b6       	in	r0, 0x3f	; 63
    95b2:	f8 94       	cli
    95b4:	9e bf       	out	0x3e, r25	; 62
    95b6:	0f be       	out	0x3f, r0	; 63
    95b8:	8d bf       	out	0x3d, r24	; 61
    95ba:	81 e0       	ldi	r24, 0x01	; 1
    95bc:	61 e0       	ldi	r22, 0x01	; 1
    95be:	a8 01       	movw	r20, r16
    95c0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    95c4:	88 ee       	ldi	r24, 0xE8	; 232
    95c6:	9d ef       	ldi	r25, 0xFD	; 253
    95c8:	20 e7       	ldi	r18, 0x70	; 112
    95ca:	31 e0       	ldi	r19, 0x01	; 1
    95cc:	f9 01       	movw	r30, r18
    95ce:	31 97       	sbiw	r30, 0x01	; 1
    95d0:	f1 f7       	brne	.-4      	; 0x95ce <FTestChar+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    95d2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    95d4:	d9 f7       	brne	.-10     	; 0x95cc <FTestChar+0x76>
	 if (i==0xFF)Result=MENU_DONE;
	 i++;
     _delay_ms(6500);
  return Result;
}
    95d6:	80 e0       	ldi	r24, 0x00	; 0
    95d8:	64 96       	adiw	r28, 0x14	; 20
    95da:	0f b6       	in	r0, 0x3f	; 63
    95dc:	f8 94       	cli
    95de:	de bf       	out	0x3e, r29	; 62
    95e0:	0f be       	out	0x3f, r0	; 63
    95e2:	cd bf       	out	0x3d, r28	; 61
    95e4:	cf 91       	pop	r28
    95e6:	df 91       	pop	r29
    95e8:	1f 91       	pop	r17
    95ea:	0f 91       	pop	r16
    95ec:	08 95       	ret

000095ee <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    95ee:	cf 92       	push	r12
    95f0:	df 92       	push	r13
    95f2:	ef 92       	push	r14
    95f4:	ff 92       	push	r15
    95f6:	0f 93       	push	r16
    95f8:	1f 93       	push	r17
    95fa:	df 93       	push	r29
    95fc:	cf 93       	push	r28
    95fe:	cd b7       	in	r28, 0x3d	; 61
    9600:	de b7       	in	r29, 0x3e	; 62
    9602:	64 97       	sbiw	r28, 0x14	; 20
    9604:	0f b6       	in	r0, 0x3f	; 63
    9606:	f8 94       	cli
    9608:	de bf       	out	0x3e, r29	; 62
    960a:	0f be       	out	0x3f, r0	; 63
    960c:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    960e:	3a eb       	ldi	r19, 0xBA	; 186
    9610:	e3 2e       	mov	r14, r19
    9612:	33 e0       	ldi	r19, 0x03	; 3
    9614:	f3 2e       	mov	r15, r19
    9616:	24 e7       	ldi	r18, 0x74	; 116
    9618:	c2 2e       	mov	r12, r18
    961a:	28 e0       	ldi	r18, 0x08	; 8
    961c:	d2 2e       	mov	r13, r18
    961e:	80 e0       	ldi	r24, 0x00	; 0
    9620:	b7 01       	movw	r22, r14
    9622:	a6 01       	movw	r20, r12
    9624:	0e 94 e3 ac 	call	0x159c6	; 0x159c6 <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    9628:	8d b7       	in	r24, 0x3d	; 61
    962a:	9e b7       	in	r25, 0x3e	; 62
    962c:	08 97       	sbiw	r24, 0x08	; 8
    962e:	0f b6       	in	r0, 0x3f	; 63
    9630:	f8 94       	cli
    9632:	9e bf       	out	0x3e, r25	; 62
    9634:	0f be       	out	0x3f, r0	; 63
    9636:	8d bf       	out	0x3d, r24	; 61
    9638:	ed b7       	in	r30, 0x3d	; 61
    963a:	fe b7       	in	r31, 0x3e	; 62
    963c:	31 96       	adiw	r30, 0x01	; 1
    963e:	8e 01       	movw	r16, r28
    9640:	0f 5f       	subi	r16, 0xFF	; 255
    9642:	1f 4f       	sbci	r17, 0xFF	; 255
    9644:	ad b7       	in	r26, 0x3d	; 61
    9646:	be b7       	in	r27, 0x3e	; 62
    9648:	12 96       	adiw	r26, 0x02	; 2
    964a:	1c 93       	st	X, r17
    964c:	0e 93       	st	-X, r16
    964e:	11 97       	sbiw	r26, 0x01	; 1
    9650:	8f e6       	ldi	r24, 0x6F	; 111
    9652:	9e e1       	ldi	r25, 0x1E	; 30
    9654:	93 83       	std	Z+3, r25	; 0x03
    9656:	82 83       	std	Z+2, r24	; 0x02
    9658:	f5 82       	std	Z+5, r15	; 0x05
    965a:	e4 82       	std	Z+4, r14	; 0x04
    965c:	d7 82       	std	Z+7, r13	; 0x07
    965e:	c6 82       	std	Z+6, r12	; 0x06
    9660:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    9664:	8d b7       	in	r24, 0x3d	; 61
    9666:	9e b7       	in	r25, 0x3e	; 62
    9668:	08 96       	adiw	r24, 0x08	; 8
    966a:	0f b6       	in	r0, 0x3f	; 63
    966c:	f8 94       	cli
    966e:	9e bf       	out	0x3e, r25	; 62
    9670:	0f be       	out	0x3f, r0	; 63
    9672:	8d bf       	out	0x3d, r24	; 61
    9674:	82 e0       	ldi	r24, 0x02	; 2
    9676:	61 e0       	ldi	r22, 0x01	; 1
    9678:	a8 01       	movw	r20, r16
    967a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
}
    967e:	64 96       	adiw	r28, 0x14	; 20
    9680:	0f b6       	in	r0, 0x3f	; 63
    9682:	f8 94       	cli
    9684:	de bf       	out	0x3e, r29	; 62
    9686:	0f be       	out	0x3f, r0	; 63
    9688:	cd bf       	out	0x3d, r28	; 61
    968a:	cf 91       	pop	r28
    968c:	df 91       	pop	r29
    968e:	1f 91       	pop	r17
    9690:	0f 91       	pop	r16
    9692:	ff 90       	pop	r15
    9694:	ef 90       	pop	r14
    9696:	df 90       	pop	r13
    9698:	cf 90       	pop	r12
    969a:	08 95       	ret

0000969c <DisplayScreenIdle>:
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
		break;
	 }
}

void DisplayScreenIdle(void){
    969c:	cf 92       	push	r12
    969e:	df 92       	push	r13
    96a0:	ef 92       	push	r14
    96a2:	ff 92       	push	r15
    96a4:	0f 93       	push	r16
    96a6:	1f 93       	push	r17
    96a8:	df 93       	push	r29
    96aa:	cf 93       	push	r28
    96ac:	cd b7       	in	r28, 0x3d	; 61
    96ae:	de b7       	in	r29, 0x3e	; 62
    96b0:	a8 97       	sbiw	r28, 0x28	; 40
    96b2:	0f b6       	in	r0, 0x3f	; 63
    96b4:	f8 94       	cli
    96b6:	de bf       	out	0x3e, r29	; 62
    96b8:	0f be       	out	0x3f, r0	; 63
    96ba:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    96bc:	00 d0       	rcall	.+0      	; 0x96be <DisplayScreenIdle+0x22>
    96be:	00 d0       	rcall	.+0      	; 0x96c0 <DisplayScreenIdle+0x24>
    96c0:	6e 01       	movw	r12, r28
    96c2:	08 94       	sec
    96c4:	c1 1c       	adc	r12, r1
    96c6:	d1 1c       	adc	r13, r1
    96c8:	ad b7       	in	r26, 0x3d	; 61
    96ca:	be b7       	in	r27, 0x3e	; 62
    96cc:	12 96       	adiw	r26, 0x02	; 2
    96ce:	dc 92       	st	X, r13
    96d0:	ce 92       	st	-X, r12
    96d2:	11 97       	sbiw	r26, 0x01	; 1
    96d4:	82 e9       	ldi	r24, 0x92	; 146
    96d6:	93 e2       	ldi	r25, 0x23	; 35
    96d8:	14 96       	adiw	r26, 0x04	; 4
    96da:	9c 93       	st	X, r25
    96dc:	8e 93       	st	-X, r24
    96de:	13 97       	sbiw	r26, 0x03	; 3
    96e0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    96e4:	4b e0       	ldi	r20, 0x0B	; 11
    96e6:	e4 2e       	mov	r14, r20
    96e8:	f1 2c       	mov	r15, r1
    96ea:	ec 0e       	add	r14, r28
    96ec:	fd 1e       	adc	r15, r29
    96ee:	ed b7       	in	r30, 0x3d	; 61
    96f0:	fe b7       	in	r31, 0x3e	; 62
    96f2:	f2 82       	std	Z+2, r15	; 0x02
    96f4:	e1 82       	std	Z+1, r14	; 0x01
    96f6:	8d e8       	ldi	r24, 0x8D	; 141
    96f8:	93 e2       	ldi	r25, 0x23	; 35
    96fa:	94 83       	std	Z+4, r25	; 0x04
    96fc:	83 83       	std	Z+3, r24	; 0x03
    96fe:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    9702:	00 d0       	rcall	.+0      	; 0x9704 <DisplayScreenIdle+0x68>
    9704:	00 d0       	rcall	.+0      	; 0x9706 <DisplayScreenIdle+0x6a>
    9706:	ed b7       	in	r30, 0x3d	; 61
    9708:	fe b7       	in	r31, 0x3e	; 62
    970a:	31 96       	adiw	r30, 0x01	; 1
    970c:	8e 01       	movw	r16, r28
    970e:	0b 5e       	subi	r16, 0xEB	; 235
    9710:	1f 4f       	sbci	r17, 0xFF	; 255
    9712:	ad b7       	in	r26, 0x3d	; 61
    9714:	be b7       	in	r27, 0x3e	; 62
    9716:	12 96       	adiw	r26, 0x02	; 2
    9718:	1c 93       	st	X, r17
    971a:	0e 93       	st	-X, r16
    971c:	11 97       	sbiw	r26, 0x01	; 1
    971e:	87 e8       	ldi	r24, 0x87	; 135
    9720:	93 e2       	ldi	r25, 0x23	; 35
    9722:	93 83       	std	Z+3, r25	; 0x03
    9724:	82 83       	std	Z+2, r24	; 0x02
    9726:	d5 82       	std	Z+5, r13	; 0x05
    9728:	c4 82       	std	Z+4, r12	; 0x04
    972a:	f7 82       	std	Z+7, r15	; 0x07
    972c:	e6 82       	std	Z+6, r14	; 0x06
    972e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	lcd_clear();
    9732:	ed b7       	in	r30, 0x3d	; 61
    9734:	fe b7       	in	r31, 0x3e	; 62
    9736:	38 96       	adiw	r30, 0x08	; 8
    9738:	0f b6       	in	r0, 0x3f	; 63
    973a:	f8 94       	cli
    973c:	fe bf       	out	0x3e, r31	; 62
    973e:	0f be       	out	0x3f, r0	; 63
    9740:	ed bf       	out	0x3d, r30	; 61
    9742:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	lcd_print(1,1,lcdteks);
    9746:	81 e0       	ldi	r24, 0x01	; 1
    9748:	61 e0       	ldi	r22, 0x01	; 1
    974a:	a8 01       	movw	r20, r16
    974c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
}
    9750:	a8 96       	adiw	r28, 0x28	; 40
    9752:	0f b6       	in	r0, 0x3f	; 63
    9754:	f8 94       	cli
    9756:	de bf       	out	0x3e, r29	; 62
    9758:	0f be       	out	0x3f, r0	; 63
    975a:	cd bf       	out	0x3d, r28	; 61
    975c:	cf 91       	pop	r28
    975e:	df 91       	pop	r29
    9760:	1f 91       	pop	r17
    9762:	0f 91       	pop	r16
    9764:	ff 90       	pop	r15
    9766:	ef 90       	pop	r14
    9768:	df 90       	pop	r13
    976a:	cf 90       	pop	r12
    976c:	08 95       	ret

0000976e <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    976e:	0f 93       	push	r16
    9770:	1f 93       	push	r17
    9772:	df 93       	push	r29
    9774:	cf 93       	push	r28
    9776:	cd b7       	in	r28, 0x3d	; 61
    9778:	de b7       	in	r29, 0x3e	; 62
    977a:	a8 97       	sbiw	r28, 0x28	; 40
    977c:	0f b6       	in	r0, 0x3f	; 63
    977e:	f8 94       	cli
    9780:	de bf       	out	0x3e, r29	; 62
    9782:	0f be       	out	0x3f, r0	; 63
    9784:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    9786:	80 91 01 01 	lds	r24, 0x0101
    978a:	81 30       	cpi	r24, 0x01	; 1
    978c:	09 f0       	breq	.+2      	; 0x9790 <DisplayPumpStatus+0x22>
    978e:	4a c0       	rjmp	.+148    	; 0x9824 <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    9790:	10 92 01 01 	sts	0x0101, r1
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    9794:	80 93 ae 02 	sts	0x02AE, r24
	 __key_lgtcnt = 0; 
    9798:	10 92 af 02 	sts	0x02AF, r1
	 PORTG=PORTG&0b11111101;
    979c:	80 91 65 00 	lds	r24, 0x0065
    97a0:	8d 7f       	andi	r24, 0xFD	; 253
    97a2:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    97a6:	80 91 5c 01 	lds	r24, 0x015C
    97aa:	48 2f       	mov	r20, r24
    97ac:	50 e0       	ldi	r21, 0x00	; 0
    97ae:	20 e0       	ldi	r18, 0x00	; 0
    97b0:	30 e0       	ldi	r19, 0x00	; 0
    97b2:	be 01       	movw	r22, r28
    97b4:	6f 5f       	subi	r22, 0xFF	; 255
    97b6:	7f 4f       	sbci	r23, 0xFF	; 255
    97b8:	0a c0       	rjmp	.+20     	; 0x97ce <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    97ba:	fb 01       	movw	r30, r22
    97bc:	e2 0f       	add	r30, r18
    97be:	f3 1f       	adc	r31, r19
    97c0:	d9 01       	movw	r26, r18
    97c2:	ae 5f       	subi	r26, 0xFE	; 254
    97c4:	be 4f       	sbci	r27, 0xFE	; 254
    97c6:	8c 91       	ld	r24, X
    97c8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    97ca:	2f 5f       	subi	r18, 0xFF	; 255
    97cc:	3f 4f       	sbci	r19, 0xFF	; 255
    97ce:	24 17       	cp	r18, r20
    97d0:	35 07       	cpc	r19, r21
    97d2:	98 f3       	brcs	.-26     	; 0x97ba <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    97d4:	46 0f       	add	r20, r22
    97d6:	57 1f       	adc	r21, r23
    97d8:	da 01       	movw	r26, r20
    97da:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    97dc:	00 d0       	rcall	.+0      	; 0x97de <DisplayPumpStatus+0x70>
    97de:	00 d0       	rcall	.+0      	; 0x97e0 <DisplayPumpStatus+0x72>
    97e0:	00 d0       	rcall	.+0      	; 0x97e2 <DisplayPumpStatus+0x74>
    97e2:	ed b7       	in	r30, 0x3d	; 61
    97e4:	fe b7       	in	r31, 0x3e	; 62
    97e6:	31 96       	adiw	r30, 0x01	; 1
    97e8:	8e 01       	movw	r16, r28
    97ea:	0b 5e       	subi	r16, 0xEB	; 235
    97ec:	1f 4f       	sbci	r17, 0xFF	; 255
    97ee:	ad b7       	in	r26, 0x3d	; 61
    97f0:	be b7       	in	r27, 0x3e	; 62
    97f2:	12 96       	adiw	r26, 0x02	; 2
    97f4:	1c 93       	st	X, r17
    97f6:	0e 93       	st	-X, r16
    97f8:	11 97       	sbiw	r26, 0x01	; 1
    97fa:	89 e0       	ldi	r24, 0x09	; 9
    97fc:	94 e2       	ldi	r25, 0x24	; 36
    97fe:	93 83       	std	Z+3, r25	; 0x03
    9800:	82 83       	std	Z+2, r24	; 0x02
    9802:	75 83       	std	Z+5, r23	; 0x05
    9804:	64 83       	std	Z+4, r22	; 0x04
    9806:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
         lcd_print(4,1,lcdteks);
    980a:	ed b7       	in	r30, 0x3d	; 61
    980c:	fe b7       	in	r31, 0x3e	; 62
    980e:	36 96       	adiw	r30, 0x06	; 6
    9810:	0f b6       	in	r0, 0x3f	; 63
    9812:	f8 94       	cli
    9814:	fe bf       	out	0x3e, r31	; 62
    9816:	0f be       	out	0x3f, r0	; 63
    9818:	ed bf       	out	0x3d, r30	; 61
    981a:	84 e0       	ldi	r24, 0x04	; 4
    981c:	61 e0       	ldi	r22, 0x01	; 1
    981e:	a8 01       	movw	r20, r16
    9820:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
     	 }
}
    9824:	a8 96       	adiw	r28, 0x28	; 40
    9826:	0f b6       	in	r0, 0x3f	; 63
    9828:	f8 94       	cli
    982a:	de bf       	out	0x3e, r29	; 62
    982c:	0f be       	out	0x3f, r0	; 63
    982e:	cd bf       	out	0x3d, r28	; 61
    9830:	cf 91       	pop	r28
    9832:	df 91       	pop	r29
    9834:	1f 91       	pop	r17
    9836:	0f 91       	pop	r16
    9838:	08 95       	ret

0000983a <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    983a:	df 92       	push	r13
    983c:	ef 92       	push	r14
    983e:	ff 92       	push	r15
    9840:	0f 93       	push	r16
    9842:	1f 93       	push	r17
    9844:	df 93       	push	r29
    9846:	cf 93       	push	r28
    9848:	cd b7       	in	r28, 0x3d	; 61
    984a:	de b7       	in	r29, 0x3e	; 62
    984c:	64 97       	sbiw	r28, 0x14	; 20
    984e:	0f b6       	in	r0, 0x3f	; 63
    9850:	f8 94       	cli
    9852:	de bf       	out	0x3e, r29	; 62
    9854:	0f be       	out	0x3f, r0	; 63
    9856:	cd bf       	out	0x3d, r28	; 61
    9858:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    985a:	80 91 49 02 	lds	r24, 0x0249
    985e:	87 30       	cpi	r24, 0x07	; 7
    9860:	09 f4       	brne	.+2      	; 0x9864 <FCloseShift+0x2a>
    9862:	a0 c1       	rjmp	.+832    	; 0x9ba4 <FCloseShift+0x36a>
    9864:	88 30       	cpi	r24, 0x08	; 8
    9866:	78 f4       	brcc	.+30     	; 0x9886 <FCloseShift+0x4c>
    9868:	84 30       	cpi	r24, 0x04	; 4
    986a:	09 f4       	brne	.+2      	; 0x986e <FCloseShift+0x34>
    986c:	68 c0       	rjmp	.+208    	; 0x993e <FCloseShift+0x104>
    986e:	85 30       	cpi	r24, 0x05	; 5
    9870:	18 f4       	brcc	.+6      	; 0x9878 <FCloseShift+0x3e>
    9872:	88 23       	and	r24, r24
    9874:	c1 f0       	breq	.+48     	; 0x98a6 <FCloseShift+0x6c>
    9876:	1c c2       	rjmp	.+1080   	; 0x9cb0 <FCloseShift+0x476>
    9878:	85 30       	cpi	r24, 0x05	; 5
    987a:	09 f4       	brne	.+2      	; 0x987e <FCloseShift+0x44>
    987c:	a6 c0       	rjmp	.+332    	; 0x99ca <FCloseShift+0x190>
    987e:	86 30       	cpi	r24, 0x06	; 6
    9880:	09 f0       	breq	.+2      	; 0x9884 <FCloseShift+0x4a>
    9882:	16 c2       	rjmp	.+1068   	; 0x9cb0 <FCloseShift+0x476>
    9884:	a8 c0       	rjmp	.+336    	; 0x99d6 <FCloseShift+0x19c>
    9886:	8a 30       	cpi	r24, 0x0A	; 10
    9888:	09 f4       	brne	.+2      	; 0x988c <FCloseShift+0x52>
    988a:	d0 c1       	rjmp	.+928    	; 0x9c2c <FCloseShift+0x3f2>
    988c:	8b 30       	cpi	r24, 0x0B	; 11
    988e:	20 f4       	brcc	.+8      	; 0x9898 <FCloseShift+0x5e>
    9890:	88 30       	cpi	r24, 0x08	; 8
    9892:	09 f0       	breq	.+2      	; 0x9896 <FCloseShift+0x5c>
    9894:	0d c2       	rjmp	.+1050   	; 0x9cb0 <FCloseShift+0x476>
    9896:	8c c1       	rjmp	.+792    	; 0x9bb0 <FCloseShift+0x376>
    9898:	8b 30       	cpi	r24, 0x0B	; 11
    989a:	09 f4       	brne	.+2      	; 0x989e <FCloseShift+0x64>
    989c:	05 c2       	rjmp	.+1034   	; 0x9ca8 <FCloseShift+0x46e>
    989e:	8c 30       	cpi	r24, 0x0C	; 12
    98a0:	09 f0       	breq	.+2      	; 0x98a4 <FCloseShift+0x6a>
    98a2:	06 c2       	rjmp	.+1036   	; 0x9cb0 <FCloseShift+0x476>
    98a4:	cc c1       	rjmp	.+920    	; 0x9c3e <FCloseShift+0x404>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    98a6:	e1 99       	sbic	0x1c, 1	; 28
    98a8:	fe cf       	rjmp	.-4      	; 0x98a6 <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98aa:	89 e4       	ldi	r24, 0x49	; 73
    98ac:	91 e0       	ldi	r25, 0x01	; 1
    98ae:	9f bb       	out	0x1f, r25	; 31
    98b0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    98b2:	e0 9a       	sbi	0x1c, 0	; 28
    98b4:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    98b6:	80 93 5d 01 	sts	0x015D, r24
		  IsPumpBusy=False;
    98ba:	10 92 48 02 	sts	0x0248, r1
    98be:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    98c0:	dd 24       	eor	r13, r13
    98c2:	d3 94       	inc	r13
    98c4:	36 c0       	rjmp	.+108    	; 0x9932 <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    98c6:	0f 2d       	mov	r16, r15
    98c8:	10 e0       	ldi	r17, 0x00	; 0
    98ca:	f8 01       	movw	r30, r16
    98cc:	ee 5f       	subi	r30, 0xFE	; 254
    98ce:	fe 4f       	sbci	r31, 0xFE	; 254
    98d0:	e0 80       	ld	r14, Z
    98d2:	8e e0       	ldi	r24, 0x0E	; 14
    98d4:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    98d8:	e8 16       	cp	r14, r24
    98da:	81 f0       	breq	.+32     	; 0x98fc <FCloseShift+0xc2>
    98dc:	86 e0       	ldi	r24, 0x06	; 6
    98de:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    98e2:	e8 16       	cp	r14, r24
    98e4:	59 f0       	breq	.+22     	; 0x98fc <FCloseShift+0xc2>
    98e6:	89 e0       	ldi	r24, 0x09	; 9
    98e8:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    98ec:	e8 16       	cp	r14, r24
    98ee:	31 f0       	breq	.+12     	; 0x98fc <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    98f0:	8f 2d       	mov	r24, r15
    98f2:	0e 94 e5 21 	call	0x43ca	; 0x43ca <GetPumpID>
    98f6:	66 e0       	ldi	r22, 0x06	; 6
    98f8:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    98fc:	84 e1       	ldi	r24, 0x14	; 20
    98fe:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    9902:	f8 01       	movw	r30, r16
    9904:	ee 5f       	subi	r30, 0xFE	; 254
    9906:	fe 4f       	sbci	r31, 0xFE	; 254
    9908:	90 81       	ld	r25, Z
    990a:	98 17       	cp	r25, r24
    990c:	31 f4       	brne	.+12     	; 0x991a <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    990e:	8f 2d       	mov	r24, r15
    9910:	0e 94 e5 21 	call	0x43ca	; 0x43ca <GetPumpID>
    9914:	66 e0       	ldi	r22, 0x06	; 6
    9916:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    991a:	89 e0       	ldi	r24, 0x09	; 9
    991c:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    9920:	0e 5f       	subi	r16, 0xFE	; 254
    9922:	1e 4f       	sbci	r17, 0xFE	; 254
    9924:	d8 01       	movw	r26, r16
    9926:	9c 91       	ld	r25, X
    9928:	98 17       	cp	r25, r24
    992a:	11 f4       	brne	.+4      	; 0x9930 <FCloseShift+0xf6>
			       IsPumpBusy=True;
    992c:	d0 92 48 02 	sts	0x0248, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    9930:	f3 94       	inc	r15
    9932:	80 91 5d 01 	lds	r24, 0x015D
    9936:	f8 16       	cp	r15, r24
    9938:	30 f2       	brcs	.-116    	; 0x98c6 <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    993a:	84 e0       	ldi	r24, 0x04	; 4
    993c:	b2 c1       	rjmp	.+868    	; 0x9ca2 <FCloseShift+0x468>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    993e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    9942:	81 e0       	ldi	r24, 0x01	; 1
    9944:	61 e0       	ldi	r22, 0x01	; 1
    9946:	46 e3       	ldi	r20, 0x36	; 54
    9948:	57 e1       	ldi	r21, 0x17	; 23
    994a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    994e:	00 91 5d 01 	lds	r16, 0x015D
    9952:	10 e0       	ldi	r17, 0x00	; 0
    9954:	82 e0       	ldi	r24, 0x02	; 2
    9956:	91 e0       	ldi	r25, 0x01	; 1
    9958:	0e 94 8b 33 	call	0x6716	; 0x6716 <CountTotalizerSatus>
    995c:	00 d0       	rcall	.+0      	; 0x995e <FCloseShift+0x124>
    995e:	00 d0       	rcall	.+0      	; 0x9960 <FCloseShift+0x126>
    9960:	00 d0       	rcall	.+0      	; 0x9962 <FCloseShift+0x128>
    9962:	ed b7       	in	r30, 0x3d	; 61
    9964:	fe b7       	in	r31, 0x3e	; 62
    9966:	31 96       	adiw	r30, 0x01	; 1
    9968:	7e 01       	movw	r14, r28
    996a:	08 94       	sec
    996c:	e1 1c       	adc	r14, r1
    996e:	f1 1c       	adc	r15, r1
    9970:	ad b7       	in	r26, 0x3d	; 61
    9972:	be b7       	in	r27, 0x3e	; 62
    9974:	12 96       	adiw	r26, 0x02	; 2
    9976:	fc 92       	st	X, r15
    9978:	ee 92       	st	-X, r14
    997a:	11 97       	sbiw	r26, 0x01	; 1
    997c:	28 e2       	ldi	r18, 0x28	; 40
    997e:	37 e1       	ldi	r19, 0x17	; 23
    9980:	33 83       	std	Z+3, r19	; 0x03
    9982:	22 83       	std	Z+2, r18	; 0x02
    9984:	08 1b       	sub	r16, r24
    9986:	11 09       	sbc	r17, r1
    9988:	15 83       	std	Z+5, r17	; 0x05
    998a:	04 83       	std	Z+4, r16	; 0x04
    998c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(2,1,lcdteks);
    9990:	ed b7       	in	r30, 0x3d	; 61
    9992:	fe b7       	in	r31, 0x3e	; 62
    9994:	36 96       	adiw	r30, 0x06	; 6
    9996:	0f b6       	in	r0, 0x3f	; 63
    9998:	f8 94       	cli
    999a:	fe bf       	out	0x3e, r31	; 62
    999c:	0f be       	out	0x3f, r0	; 63
    999e:	ed bf       	out	0x3d, r30	; 61
    99a0:	82 e0       	ldi	r24, 0x02	; 2
    99a2:	61 e0       	ldi	r22, 0x01	; 1
    99a4:	a7 01       	movw	r20, r14
    99a6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>


          IsNewPumpStatus=True;
    99aa:	11 e0       	ldi	r17, 0x01	; 1
    99ac:	10 93 01 01 	sts	0x0101, r17
		  DisplayPumpStatus(); 
    99b0:	0e 94 b7 4b 	call	0x976e	; 0x976e <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    99b4:	95 e0       	ldi	r25, 0x05	; 5
    99b6:	90 93 a7 05 	sts	0x05A7, r25
	 PoolMsg=plMsg;
    99ba:	82 e1       	ldi	r24, 0x12	; 18
    99bc:	80 93 d3 0b 	sts	0x0BD3, r24
     IsControlPooling=True;
    99c0:	10 93 84 01 	sts	0x0184, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    99c4:	90 93 49 02 	sts	0x0249, r25
    99c8:	73 c1       	rjmp	.+742    	; 0x9cb0 <FCloseShift+0x476>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    99ca:	0e 94 b7 4b 	call	0x976e	; 0x976e <DisplayPumpStatus>
		  TimDisplay=0;         
    99ce:	10 92 92 01 	sts	0x0192, r1
          stCloseShift=csWaitTotalizerComplete;
    99d2:	86 e0       	ldi	r24, 0x06	; 6
    99d4:	66 c1       	rjmp	.+716    	; 0x9ca2 <FCloseShift+0x468>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    99d6:	81 e0       	ldi	r24, 0x01	; 1
    99d8:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    99dc:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    99de:	80 91 01 01 	lds	r24, 0x0101
    99e2:	81 30       	cpi	r24, 0x01	; 1
    99e4:	89 f5       	brne	.+98     	; 0x9a48 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    99e6:	00 91 5d 01 	lds	r16, 0x015D
    99ea:	10 e0       	ldi	r17, 0x00	; 0
    99ec:	82 e0       	ldi	r24, 0x02	; 2
    99ee:	91 e0       	ldi	r25, 0x01	; 1
    99f0:	0e 94 8b 33 	call	0x6716	; 0x6716 <CountTotalizerSatus>
    99f4:	00 d0       	rcall	.+0      	; 0x99f6 <FCloseShift+0x1bc>
    99f6:	00 d0       	rcall	.+0      	; 0x99f8 <FCloseShift+0x1be>
    99f8:	00 d0       	rcall	.+0      	; 0x99fa <FCloseShift+0x1c0>
    99fa:	ed b7       	in	r30, 0x3d	; 61
    99fc:	fe b7       	in	r31, 0x3e	; 62
    99fe:	31 96       	adiw	r30, 0x01	; 1
    9a00:	7e 01       	movw	r14, r28
    9a02:	08 94       	sec
    9a04:	e1 1c       	adc	r14, r1
    9a06:	f1 1c       	adc	r15, r1
    9a08:	ad b7       	in	r26, 0x3d	; 61
    9a0a:	be b7       	in	r27, 0x3e	; 62
    9a0c:	12 96       	adiw	r26, 0x02	; 2
    9a0e:	fc 92       	st	X, r15
    9a10:	ee 92       	st	-X, r14
    9a12:	11 97       	sbiw	r26, 0x01	; 1
    9a14:	2a e1       	ldi	r18, 0x1A	; 26
    9a16:	37 e1       	ldi	r19, 0x17	; 23
    9a18:	33 83       	std	Z+3, r19	; 0x03
    9a1a:	22 83       	std	Z+2, r18	; 0x02
    9a1c:	08 1b       	sub	r16, r24
    9a1e:	11 09       	sbc	r17, r1
    9a20:	15 83       	std	Z+5, r17	; 0x05
    9a22:	04 83       	std	Z+4, r16	; 0x04
    9a24:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  lcd_print(2,1,lcdteks);
    9a28:	ed b7       	in	r30, 0x3d	; 61
    9a2a:	fe b7       	in	r31, 0x3e	; 62
    9a2c:	36 96       	adiw	r30, 0x06	; 6
    9a2e:	0f b6       	in	r0, 0x3f	; 63
    9a30:	f8 94       	cli
    9a32:	fe bf       	out	0x3e, r31	; 62
    9a34:	0f be       	out	0x3f, r0	; 63
    9a36:	ed bf       	out	0x3d, r30	; 61
    9a38:	82 e0       	ldi	r24, 0x02	; 2
    9a3a:	61 e0       	ldi	r22, 0x01	; 1
    9a3c:	a7 01       	movw	r20, r14
    9a3e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    9a42:	85 e0       	ldi	r24, 0x05	; 5
    9a44:	80 93 49 02 	sts	0x0249, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    9a48:	82 e0       	ldi	r24, 0x02	; 2
    9a4a:	91 e0       	ldi	r25, 0x01	; 1
    9a4c:	0e 94 8b 33 	call	0x6716	; 0x6716 <CountTotalizerSatus>
    9a50:	90 91 5d 01 	lds	r25, 0x015D
    9a54:	89 17       	cp	r24, r25
    9a56:	a0 f0       	brcs	.+40     	; 0x9a80 <FCloseShift+0x246>
    9a58:	80 91 92 01 	lds	r24, 0x0192
    9a5c:	86 30       	cpi	r24, 0x06	; 6
    9a5e:	80 f0       	brcs	.+32     	; 0x9a80 <FCloseShift+0x246>
    9a60:	10 e0       	ldi	r17, 0x00	; 0
    9a62:	07 c0       	rjmp	.+14     	; 0x9a72 <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    9a64:	81 2f       	mov	r24, r17
    9a66:	0e 94 e5 21 	call	0x43ca	; 0x43ca <GetPumpID>
    9a6a:	66 e0       	ldi	r22, 0x06	; 6
    9a6c:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    9a70:	1f 5f       	subi	r17, 0xFF	; 255
    9a72:	80 91 5d 01 	lds	r24, 0x015D
    9a76:	18 17       	cp	r17, r24
    9a78:	a8 f3       	brcs	.-22     	; 0x9a64 <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    9a7a:	88 e0       	ldi	r24, 0x08	; 8
    9a7c:	80 93 49 02 	sts	0x0249, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    9a80:	80 91 92 01 	lds	r24, 0x0192
    9a84:	80 31       	cpi	r24, 0x10	; 16
    9a86:	08 f4       	brcc	.+2      	; 0x9a8a <FCloseShift+0x250>
    9a88:	64 c0       	rjmp	.+200    	; 0x9b52 <FCloseShift+0x318>
    9a8a:	80 91 48 02 	lds	r24, 0x0248
    9a8e:	81 30       	cpi	r24, 0x01	; 1
    9a90:	09 f4       	brne	.+2      	; 0x9a94 <FCloseShift+0x25a>
    9a92:	5f c0       	rjmp	.+190    	; 0x9b52 <FCloseShift+0x318>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    9a94:	82 e0       	ldi	r24, 0x02	; 2
    9a96:	91 e0       	ldi	r25, 0x01	; 1
    9a98:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <CountNoPumpSatus>
    9a9c:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9a9e:	e1 99       	sbic	0x1c, 1	; 28
    9aa0:	fe cf       	rjmp	.-4      	; 0x9a9e <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9aa2:	89 e4       	ldi	r24, 0x49	; 73
    9aa4:	91 e0       	ldi	r25, 0x01	; 1
    9aa6:	9f bb       	out	0x1f, r25	; 31
    9aa8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9aaa:	e0 9a       	sbi	0x1c, 0	; 28
    9aac:	8d b3       	in	r24, 0x1d	; 29
    9aae:	28 17       	cp	r18, r24
    9ab0:	08 f4       	brcc	.+2      	; 0x9ab4 <FCloseShift+0x27a>
    9ab2:	4f c0       	rjmp	.+158    	; 0x9b52 <FCloseShift+0x318>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    9ab4:	00 91 5d 01 	lds	r16, 0x015D
    9ab8:	10 e0       	ldi	r17, 0x00	; 0
    9aba:	82 e0       	ldi	r24, 0x02	; 2
    9abc:	91 e0       	ldi	r25, 0x01	; 1
    9abe:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <CountNoPumpSatus>
    9ac2:	00 d0       	rcall	.+0      	; 0x9ac4 <FCloseShift+0x28a>
    9ac4:	00 d0       	rcall	.+0      	; 0x9ac6 <FCloseShift+0x28c>
    9ac6:	00 d0       	rcall	.+0      	; 0x9ac8 <FCloseShift+0x28e>
    9ac8:	ed b7       	in	r30, 0x3d	; 61
    9aca:	fe b7       	in	r31, 0x3e	; 62
    9acc:	31 96       	adiw	r30, 0x01	; 1
    9ace:	7e 01       	movw	r14, r28
    9ad0:	08 94       	sec
    9ad2:	e1 1c       	adc	r14, r1
    9ad4:	f1 1c       	adc	r15, r1
    9ad6:	ad b7       	in	r26, 0x3d	; 61
    9ad8:	be b7       	in	r27, 0x3e	; 62
    9ada:	12 96       	adiw	r26, 0x02	; 2
    9adc:	fc 92       	st	X, r15
    9ade:	ee 92       	st	-X, r14
    9ae0:	11 97       	sbiw	r26, 0x01	; 1
    9ae2:	26 e0       	ldi	r18, 0x06	; 6
    9ae4:	37 e1       	ldi	r19, 0x17	; 23
    9ae6:	33 83       	std	Z+3, r19	; 0x03
    9ae8:	22 83       	std	Z+2, r18	; 0x02
    9aea:	08 1b       	sub	r16, r24
    9aec:	11 09       	sbc	r17, r1
    9aee:	15 83       	std	Z+5, r17	; 0x05
    9af0:	04 83       	std	Z+4, r16	; 0x04
    9af2:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  lcd_print(3,1,lcdteks);
    9af6:	ed b7       	in	r30, 0x3d	; 61
    9af8:	fe b7       	in	r31, 0x3e	; 62
    9afa:	36 96       	adiw	r30, 0x06	; 6
    9afc:	0f b6       	in	r0, 0x3f	; 63
    9afe:	f8 94       	cli
    9b00:	fe bf       	out	0x3e, r31	; 62
    9b02:	0f be       	out	0x3f, r0	; 63
    9b04:	ed bf       	out	0x3d, r30	; 61
    9b06:	83 e0       	ldi	r24, 0x03	; 3
    9b08:	61 e0       	ldi	r22, 0x01	; 1
    9b0a:	a7 01       	movw	r20, r14
    9b0c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    9b10:	10 e0       	ldi	r17, 0x00	; 0
    9b12:	11 c0       	rjmp	.+34     	; 0x9b36 <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    9b14:	84 e1       	ldi	r24, 0x14	; 20
    9b16:	0e 94 52 14 	call	0x28a4	; 0x28a4 <GetPumpStatusLabel>
    9b1a:	e1 2f       	mov	r30, r17
    9b1c:	f0 e0       	ldi	r31, 0x00	; 0
    9b1e:	ee 5f       	subi	r30, 0xFE	; 254
    9b20:	fe 4f       	sbci	r31, 0xFE	; 254
    9b22:	90 81       	ld	r25, Z
    9b24:	98 17       	cp	r25, r24
    9b26:	31 f4       	brne	.+12     	; 0x9b34 <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    9b28:	81 2f       	mov	r24, r17
    9b2a:	0e 94 e5 21 	call	0x43ca	; 0x43ca <GetPumpID>
    9b2e:	66 e0       	ldi	r22, 0x06	; 6
    9b30:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    9b34:	1f 5f       	subi	r17, 0xFF	; 255
    9b36:	80 91 5d 01 	lds	r24, 0x015D
    9b3a:	18 17       	cp	r17, r24
    9b3c:	58 f3       	brcs	.-42     	; 0x9b14 <FCloseShift+0x2da>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    9b3e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    9b40:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    9b42:	81 e0       	ldi	r24, 0x01	; 1
    9b44:	80 93 bc 01 	sts	0x01BC, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    9b48:	10 92 92 01 	sts	0x0192, r1
			  stCloseShift=csNoPumpFound;		     
    9b4c:	87 e0       	ldi	r24, 0x07	; 7
    9b4e:	80 93 49 02 	sts	0x0249, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    9b52:	f7 ee       	ldi	r31, 0xE7	; 231
    9b54:	df 16       	cp	r13, r31
    9b56:	09 f0       	breq	.+2      	; 0x9b5a <FCloseShift+0x320>
    9b58:	ab c0       	rjmp	.+342    	; 0x9cb0 <FCloseShift+0x476>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    9b5a:	00 d0       	rcall	.+0      	; 0x9b5c <FCloseShift+0x322>
    9b5c:	00 d0       	rcall	.+0      	; 0x9b5e <FCloseShift+0x324>
    9b5e:	8e 01       	movw	r16, r28
    9b60:	0f 5f       	subi	r16, 0xFF	; 255
    9b62:	1f 4f       	sbci	r17, 0xFF	; 255
    9b64:	ad b7       	in	r26, 0x3d	; 61
    9b66:	be b7       	in	r27, 0x3e	; 62
    9b68:	12 96       	adiw	r26, 0x02	; 2
    9b6a:	1c 93       	st	X, r17
    9b6c:	0e 93       	st	-X, r16
    9b6e:	11 97       	sbiw	r26, 0x01	; 1
    9b70:	8f ef       	ldi	r24, 0xFF	; 255
    9b72:	96 e1       	ldi	r25, 0x16	; 22
    9b74:	14 96       	adiw	r26, 0x04	; 4
    9b76:	9c 93       	st	X, r25
    9b78:	8e 93       	st	-X, r24
    9b7a:	13 97       	sbiw	r26, 0x03	; 3
    9b7c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  lcd_print(3,1,lcdteks);
    9b80:	0f 90       	pop	r0
    9b82:	0f 90       	pop	r0
    9b84:	0f 90       	pop	r0
    9b86:	0f 90       	pop	r0
    9b88:	83 e0       	ldi	r24, 0x03	; 3
    9b8a:	61 e0       	ldi	r22, 0x01	; 1
    9b8c:	a8 01       	movw	r20, r16
    9b8e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    9b92:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    9b94:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    9b96:	81 e0       	ldi	r24, 0x01	; 1
    9b98:	80 93 bc 01 	sts	0x01BC, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    9b9c:	10 92 92 01 	sts	0x0192, r1
			  stCloseShift=csNoPumpFound;		     		  
    9ba0:	87 e0       	ldi	r24, 0x07	; 7
    9ba2:	7f c0       	rjmp	.+254    	; 0x9ca2 <FCloseShift+0x468>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    9ba4:	80 91 92 01 	lds	r24, 0x0192
    9ba8:	8b 30       	cpi	r24, 0x0B	; 11
    9baa:	08 f4       	brcc	.+2      	; 0x9bae <FCloseShift+0x374>
    9bac:	81 c0       	rjmp	.+258    	; 0x9cb0 <FCloseShift+0x476>
    9bae:	78 c0       	rjmp	.+240    	; 0x9ca0 <FCloseShift+0x466>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    9bb0:	81 e0       	ldi	r24, 0x01	; 1
    9bb2:	61 e0       	ldi	r22, 0x01	; 1
    9bb4:	4c ee       	ldi	r20, 0xEC	; 236
    9bb6:	56 e1       	ldi	r21, 0x16	; 22
    9bb8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    9bbc:	0a eb       	ldi	r16, 0xBA	; 186
    9bbe:	13 e0       	ldi	r17, 0x03	; 3
    9bc0:	54 e7       	ldi	r21, 0x74	; 116
    9bc2:	e5 2e       	mov	r14, r21
    9bc4:	58 e0       	ldi	r21, 0x08	; 8
    9bc6:	f5 2e       	mov	r15, r21
    9bc8:	80 e0       	ldi	r24, 0x00	; 0
    9bca:	b8 01       	movw	r22, r16
    9bcc:	a7 01       	movw	r20, r14
    9bce:	0e 94 e3 ac 	call	0x159c6	; 0x159c6 <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    9bd2:	ed b7       	in	r30, 0x3d	; 61
    9bd4:	fe b7       	in	r31, 0x3e	; 62
    9bd6:	38 97       	sbiw	r30, 0x08	; 8
    9bd8:	0f b6       	in	r0, 0x3f	; 63
    9bda:	f8 94       	cli
    9bdc:	fe bf       	out	0x3e, r31	; 62
    9bde:	0f be       	out	0x3f, r0	; 63
    9be0:	ed bf       	out	0x3d, r30	; 61
    9be2:	31 96       	adiw	r30, 0x01	; 1
    9be4:	8e e8       	ldi	r24, 0x8E	; 142
    9be6:	97 e0       	ldi	r25, 0x07	; 7
    9be8:	ad b7       	in	r26, 0x3d	; 61
    9bea:	be b7       	in	r27, 0x3e	; 62
    9bec:	12 96       	adiw	r26, 0x02	; 2
    9bee:	9c 93       	st	X, r25
    9bf0:	8e 93       	st	-X, r24
    9bf2:	11 97       	sbiw	r26, 0x01	; 1
    9bf4:	86 ee       	ldi	r24, 0xE6	; 230
    9bf6:	96 e1       	ldi	r25, 0x16	; 22
    9bf8:	93 83       	std	Z+3, r25	; 0x03
    9bfa:	82 83       	std	Z+2, r24	; 0x02
    9bfc:	15 83       	std	Z+5, r17	; 0x05
    9bfe:	04 83       	std	Z+4, r16	; 0x04
    9c00:	f7 82       	std	Z+7, r15	; 0x07
    9c02:	e6 82       	std	Z+6, r14	; 0x06
    9c04:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  IsGenerateReport=True;
    9c08:	81 e0       	ldi	r24, 0x01	; 1
    9c0a:	80 93 86 01 	sts	0x0186, r24
		  IsFinishPrintingTotalizer=False;
    9c0e:	10 92 87 01 	sts	0x0187, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    9c12:	8a e0       	ldi	r24, 0x0A	; 10
    9c14:	80 93 49 02 	sts	0x0249, r24
    9c18:	80 e0       	ldi	r24, 0x00	; 0
    9c1a:	ed b7       	in	r30, 0x3d	; 61
    9c1c:	fe b7       	in	r31, 0x3e	; 62
    9c1e:	38 96       	adiw	r30, 0x08	; 8
    9c20:	0f b6       	in	r0, 0x3f	; 63
    9c22:	f8 94       	cli
    9c24:	fe bf       	out	0x3e, r31	; 62
    9c26:	0f be       	out	0x3f, r0	; 63
    9c28:	ed bf       	out	0x3d, r30	; 61
    9c2a:	43 c0       	rjmp	.+134    	; 0x9cb2 <FCloseShift+0x478>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    9c2c:	80 91 87 01 	lds	r24, 0x0187
    9c30:	81 30       	cpi	r24, 0x01	; 1
    9c32:	09 f0       	breq	.+2      	; 0x9c36 <FCloseShift+0x3fc>
    9c34:	3d c0       	rjmp	.+122    	; 0x9cb0 <FCloseShift+0x476>
		      IsFinishPrintingTotalizer=False;
    9c36:	10 92 87 01 	sts	0x0187, r1
		      stCloseShift=csDumpShift;
    9c3a:	8c e0       	ldi	r24, 0x0C	; 12
    9c3c:	32 c0       	rjmp	.+100    	; 0x9ca2 <FCloseShift+0x468>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    9c3e:	81 e0       	ldi	r24, 0x01	; 1
    9c40:	61 e0       	ldi	r22, 0x01	; 1
    9c42:	42 ed       	ldi	r20, 0xD2	; 210
    9c44:	56 e1       	ldi	r21, 0x16	; 22
    9c46:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    9c4a:	12 30       	cpi	r17, 0x02	; 2
    9c4c:	71 f4       	brne	.+28     	; 0x9c6a <FCloseShift+0x430>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9c4e:	e1 99       	sbic	0x1c, 1	; 28
    9c50:	fe cf       	rjmp	.-4      	; 0x9c4e <FCloseShift+0x414>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9c52:	2f e3       	ldi	r18, 0x3F	; 63
    9c54:	31 e0       	ldi	r19, 0x01	; 1
    9c56:	3f bb       	out	0x1f, r19	; 31
    9c58:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9c5a:	e0 9a       	sbi	0x1c, 0	; 28
    9c5c:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9c5e:	e1 99       	sbic	0x1c, 1	; 28
    9c60:	fe cf       	rjmp	.-4      	; 0x9c5e <FCloseShift+0x424>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9c62:	3f bb       	out	0x1f, r19	; 31
    9c64:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    9c66:	8f 5f       	subi	r24, 0xFF	; 255
    9c68:	09 c0       	rjmp	.+18     	; 0x9c7c <FCloseShift+0x442>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    9c6a:	11 30       	cpi	r17, 0x01	; 1
    9c6c:	69 f4       	brne	.+26     	; 0x9c88 <FCloseShift+0x44e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9c6e:	e1 99       	sbic	0x1c, 1	; 28
    9c70:	fe cf       	rjmp	.-4      	; 0x9c6e <FCloseShift+0x434>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9c72:	8f e3       	ldi	r24, 0x3F	; 63
    9c74:	91 e0       	ldi	r25, 0x01	; 1
    9c76:	9f bb       	out	0x1f, r25	; 31
    9c78:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9c7a:	81 e0       	ldi	r24, 0x01	; 1
    9c7c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    9c7e:	0f b6       	in	r0, 0x3f	; 63
    9c80:	f8 94       	cli
    9c82:	e2 9a       	sbi	0x1c, 2	; 28
    9c84:	e1 9a       	sbi	0x1c, 1	; 28
    9c86:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    9c88:	0e 94 ac 2b 	call	0x5758	; 0x5758 <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9c8c:	83 e4       	ldi	r24, 0x43	; 67
    9c8e:	98 e0       	ldi	r25, 0x08	; 8
    9c90:	6e e8       	ldi	r22, 0x8E	; 142
    9c92:	77 e0       	ldi	r23, 0x07	; 7
    9c94:	44 e1       	ldi	r20, 0x14	; 20
    9c96:	50 e0       	ldi	r21, 0x00	; 0
    9c98:	2a ed       	ldi	r18, 0xDA	; 218
    9c9a:	33 e1       	ldi	r19, 0x13	; 19
    9c9c:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    9ca0:	8b e0       	ldi	r24, 0x0B	; 11
    9ca2:	80 93 49 02 	sts	0x0249, r24
    9ca6:	04 c0       	rjmp	.+8      	; 0x9cb0 <FCloseShift+0x476>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    9ca8:	10 92 49 02 	sts	0x0249, r1
    9cac:	81 e0       	ldi	r24, 0x01	; 1
    9cae:	01 c0       	rjmp	.+2      	; 0x9cb2 <FCloseShift+0x478>
    9cb0:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    9cb2:	64 96       	adiw	r28, 0x14	; 20
    9cb4:	0f b6       	in	r0, 0x3f	; 63
    9cb6:	f8 94       	cli
    9cb8:	de bf       	out	0x3e, r29	; 62
    9cba:	0f be       	out	0x3f, r0	; 63
    9cbc:	cd bf       	out	0x3d, r28	; 61
    9cbe:	cf 91       	pop	r28
    9cc0:	df 91       	pop	r29
    9cc2:	1f 91       	pop	r17
    9cc4:	0f 91       	pop	r16
    9cc6:	ff 90       	pop	r15
    9cc8:	ef 90       	pop	r14
    9cca:	df 90       	pop	r13
    9ccc:	08 95       	ret

00009cce <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    9cce:	2f 92       	push	r2
    9cd0:	3f 92       	push	r3
    9cd2:	4f 92       	push	r4
    9cd4:	5f 92       	push	r5
    9cd6:	6f 92       	push	r6
    9cd8:	7f 92       	push	r7
    9cda:	8f 92       	push	r8
    9cdc:	9f 92       	push	r9
    9cde:	bf 92       	push	r11
    9ce0:	cf 92       	push	r12
    9ce2:	df 92       	push	r13
    9ce4:	ef 92       	push	r14
    9ce6:	ff 92       	push	r15
    9ce8:	0f 93       	push	r16
    9cea:	1f 93       	push	r17
    9cec:	df 93       	push	r29
    9cee:	cf 93       	push	r28
    9cf0:	cd b7       	in	r28, 0x3d	; 61
    9cf2:	de b7       	in	r29, 0x3e	; 62
    9cf4:	6d 97       	sbiw	r28, 0x1d	; 29
    9cf6:	0f b6       	in	r0, 0x3f	; 63
    9cf8:	f8 94       	cli
    9cfa:	de bf       	out	0x3e, r29	; 62
    9cfc:	0f be       	out	0x3f, r0	; 63
    9cfe:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9d00:	e1 99       	sbic	0x1c, 1	; 28
    9d02:	fe cf       	rjmp	.-4      	; 0x9d00 <_menu_host+0x32>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9d04:	21 ec       	ldi	r18, 0xC1	; 193
    9d06:	33 e0       	ldi	r19, 0x03	; 3
    9d08:	3f bb       	out	0x1f, r19	; 31
    9d0a:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9d0c:	e0 9a       	sbi	0x1c, 0	; 28
    9d0e:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    9d10:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9d12:	e1 99       	sbic	0x1c, 1	; 28
    9d14:	fe cf       	rjmp	.-4      	; 0x9d12 <_menu_host+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9d16:	87 e3       	ldi	r24, 0x37	; 55
    9d18:	90 e0       	ldi	r25, 0x00	; 0
    9d1a:	9f bb       	out	0x1f, r25	; 31
    9d1c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9d1e:	e0 9a       	sbi	0x1c, 0	; 28
    9d20:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&DefShowDateTime);
    9d22:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9d24:	e1 99       	sbic	0x1c, 1	; 28
    9d26:	fe cf       	rjmp	.-4      	; 0x9d24 <_menu_host+0x56>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9d28:	a8 e3       	ldi	r26, 0x38	; 56
    9d2a:	b0 e0       	ldi	r27, 0x00	; 0
    9d2c:	bf bb       	out	0x1f, r27	; 31
    9d2e:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9d30:	e0 9a       	sbi	0x1c, 0	; 28
    9d32:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    9d34:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9d36:	e1 99       	sbic	0x1c, 1	; 28
    9d38:	fe cf       	rjmp	.-4      	; 0x9d36 <_menu_host+0x68>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9d3a:	80 e0       	ldi	r24, 0x00	; 0
    9d3c:	28 2e       	mov	r2, r24
    9d3e:	80 e0       	ldi	r24, 0x00	; 0
    9d40:	38 2e       	mov	r3, r24
    9d42:	3f ba       	out	0x1f, r3	; 31
    9d44:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9d46:	e0 9a       	sbi	0x1c, 0	; 28
    9d48:	bd b2       	in	r11, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);


	lcd_clear();_delay_ms(10);
    9d4a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    9d4e:	80 e0       	ldi	r24, 0x00	; 0
    9d50:	90 e9       	ldi	r25, 0x90	; 144
    9d52:	01 97       	sbiw	r24, 0x01	; 1
    9d54:	f1 f7       	brne	.-4      	; 0x9d52 <_menu_host+0x84>
	lcd_printf(1, 1, PSTR("1)Money :"));
    9d56:	81 e0       	ldi	r24, 0x01	; 1
    9d58:	61 e0       	ldi	r22, 0x01	; 1
    9d5a:	4c eb       	ldi	r20, 0xBC	; 188
    9d5c:	5c e0       	ldi	r21, 0x0C	; 12
    9d5e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    9d62:	82 e0       	ldi	r24, 0x02	; 2
    9d64:	61 e0       	ldi	r22, 0x01	; 1
    9d66:	42 eb       	ldi	r20, 0xB2	; 178
    9d68:	5c e0       	ldi	r21, 0x0C	; 12
    9d6a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    9d6e:	83 e0       	ldi	r24, 0x03	; 3
    9d70:	61 e0       	ldi	r22, 0x01	; 1
    9d72:	4d e9       	ldi	r20, 0x9D	; 157
    9d74:	5c e0       	ldi	r21, 0x0C	; 12
    9d76:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    9d7a:	00 d0       	rcall	.+0      	; 0x9d7c <_menu_host+0xae>
    9d7c:	00 d0       	rcall	.+0      	; 0x9d7e <_menu_host+0xb0>
    9d7e:	00 d0       	rcall	.+0      	; 0x9d80 <_menu_host+0xb2>
    9d80:	ed b7       	in	r30, 0x3d	; 61
    9d82:	fe b7       	in	r31, 0x3e	; 62
    9d84:	31 96       	adiw	r30, 0x01	; 1
    9d86:	8e 01       	movw	r16, r28
    9d88:	06 5f       	subi	r16, 0xF6	; 246
    9d8a:	1f 4f       	sbci	r17, 0xFF	; 255
    9d8c:	ad b7       	in	r26, 0x3d	; 61
    9d8e:	be b7       	in	r27, 0x3e	; 62
    9d90:	12 96       	adiw	r26, 0x02	; 2
    9d92:	1c 93       	st	X, r17
    9d94:	0e 93       	st	-X, r16
    9d96:	11 97       	sbiw	r26, 0x01	; 1
    9d98:	80 e9       	ldi	r24, 0x90	; 144
    9d9a:	9c e0       	ldi	r25, 0x0C	; 12
    9d9c:	93 83       	std	Z+3, r25	; 0x03
    9d9e:	82 83       	std	Z+2, r24	; 0x02
    9da0:	b4 82       	std	Z+4, r11	; 0x04
    9da2:	15 82       	std	Z+5, r1	; 0x05
    9da4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	lcd_print(4, 1,lcdteks);
    9da8:	ed b7       	in	r30, 0x3d	; 61
    9daa:	fe b7       	in	r31, 0x3e	; 62
    9dac:	36 96       	adiw	r30, 0x06	; 6
    9dae:	0f b6       	in	r0, 0x3f	; 63
    9db0:	f8 94       	cli
    9db2:	fe bf       	out	0x3e, r31	; 62
    9db4:	0f be       	out	0x3f, r0	; 63
    9db6:	ed bf       	out	0x3d, r30	; 61
    9db8:	84 e0       	ldi	r24, 0x04	; 4
    9dba:	61 e0       	ldi	r22, 0x01	; 1
    9dbc:	a8 01       	movw	r20, r16
    9dbe:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    9dc2:	84 e0       	ldi	r24, 0x04	; 4
    9dc4:	6f e0       	ldi	r22, 0x0F	; 15
    9dc6:	49 e8       	ldi	r20, 0x89	; 137
    9dc8:	5c e0       	ldi	r21, 0x0C	; 12
    9dca:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    9dce:	02 ed       	ldi	r16, 0xD2	; 210
    9dd0:	e0 2e       	mov	r14, r16
    9dd2:	02 e0       	ldi	r16, 0x02	; 2
    9dd4:	f0 2e       	mov	r15, r16
    9dd6:	6e 01       	movw	r12, r28
    9dd8:	08 94       	sec
    9dda:	c1 1c       	adc	r12, r1
    9ddc:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		sprintf_P(__buff,PSTR("%d"),__value[__i]);
    9dde:	15 e0       	ldi	r17, 0x05	; 5
    9de0:	81 2e       	mov	r8, r17
    9de2:	91 2c       	mov	r9, r1
    9de4:	8c 0e       	add	r8, r28
    9de6:	9d 1e       	adc	r9, r29
    9de8:	b6 e8       	ldi	r27, 0x86	; 134
    9dea:	6b 2e       	mov	r6, r27
    9dec:	bc e0       	ldi	r27, 0x0C	; 12
    9dee:	7b 2e       	mov	r7, r27
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
	lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    9df0:	f7 01       	movw	r30, r14
    9df2:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    9df4:	08 94       	sec
    9df6:	e1 1c       	adc	r14, r1
    9df8:	f1 1c       	adc	r15, r1
    9dfa:	f7 01       	movw	r30, r14
    9dfc:	14 91       	lpm	r17, Z+
		sprintf_P(__buff,PSTR("%d"),__value[__i]);
    9dfe:	00 d0       	rcall	.+0      	; 0x9e00 <_menu_host+0x132>
    9e00:	00 d0       	rcall	.+0      	; 0x9e02 <_menu_host+0x134>
    9e02:	00 d0       	rcall	.+0      	; 0x9e04 <_menu_host+0x136>
    9e04:	ed b7       	in	r30, 0x3d	; 61
    9e06:	fe b7       	in	r31, 0x3e	; 62
    9e08:	31 96       	adiw	r30, 0x01	; 1
    9e0a:	ad b7       	in	r26, 0x3d	; 61
    9e0c:	be b7       	in	r27, 0x3e	; 62
    9e0e:	12 96       	adiw	r26, 0x02	; 2
    9e10:	9c 92       	st	X, r9
    9e12:	8e 92       	st	-X, r8
    9e14:	11 97       	sbiw	r26, 0x01	; 1
    9e16:	73 82       	std	Z+3, r7	; 0x03
    9e18:	62 82       	std	Z+2, r6	; 0x02
    9e1a:	d6 01       	movw	r26, r12
    9e1c:	8d 91       	ld	r24, X+
    9e1e:	6d 01       	movw	r12, r26
    9e20:	84 83       	std	Z+4, r24	; 0x04
    9e22:	15 82       	std	Z+5, r1	; 0x05
    9e24:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		//_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
    9e28:	ed b7       	in	r30, 0x3d	; 61
    9e2a:	fe b7       	in	r31, 0x3e	; 62
    9e2c:	36 96       	adiw	r30, 0x06	; 6
    9e2e:	0f b6       	in	r0, 0x3f	; 63
    9e30:	f8 94       	cli
    9e32:	fe bf       	out	0x3e, r31	; 62
    9e34:	0f be       	out	0x3f, r0	; 63
    9e36:	ed bf       	out	0x3d, r30	; 61
    9e38:	80 2f       	mov	r24, r16
    9e3a:	61 2f       	mov	r22, r17
    9e3c:	a4 01       	movw	r20, r8
    9e3e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    9e42:	08 94       	sec
    9e44:	e1 1c       	adc	r14, r1
    9e46:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
	lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    9e48:	f8 ed       	ldi	r31, 0xD8	; 216
    9e4a:	ef 16       	cp	r14, r31
    9e4c:	f2 e0       	ldi	r31, 0x02	; 2
    9e4e:	ff 06       	cpc	r15, r31
    9e50:	79 f6       	brne	.-98     	; 0x9df0 <_menu_host+0x122>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    9e52:	aa e0       	ldi	r26, 0x0A	; 10
    9e54:	8a 2e       	mov	r8, r26
    9e56:	91 2c       	mov	r9, r1
    9e58:	8c 0e       	add	r8, r28
    9e5a:	9d 1e       	adc	r9, r29
    9e5c:	f6 e7       	ldi	r31, 0x76	; 118
    9e5e:	4f 2e       	mov	r4, r31
    9e60:	fc e0       	ldi	r31, 0x0C	; 12
    9e62:	5f 2e       	mov	r5, r31
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    9e64:	6e 01       	movw	r12, r28
    9e66:	08 94       	sec
    9e68:	c1 1c       	adc	r12, r1
    9e6a:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    9e6c:	e5 e0       	ldi	r30, 0x05	; 5
    9e6e:	ee 2e       	mov	r14, r30
    9e70:	f1 2c       	mov	r15, r1
    9e72:	ec 0e       	add	r14, r28
    9e74:	fd 1e       	adc	r15, r29
    9e76:	73 e8       	ldi	r23, 0x83	; 131
    9e78:	67 2e       	mov	r6, r23
    9e7a:	7c e0       	ldi	r23, 0x0C	; 12
    9e7c:	77 2e       	mov	r7, r23
		//_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    9e7e:	81 e0       	ldi	r24, 0x01	; 1
    9e80:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    9e84:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    9e86:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    9e8a:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    9e8c:	17 3e       	cpi	r17, 0xE7	; 231
    9e8e:	09 f4       	brne	.+2      	; 0x9e92 <_menu_host+0x1c4>
    9e90:	a9 c0       	rjmp	.+338    	; 0x9fe4 <_menu_host+0x316>
			return;
		if(__key==_KEY_ENTER){
    9e92:	17 3b       	cpi	r17, 0xB7	; 183
    9e94:	09 f0       	breq	.+2      	; 0x9e98 <_menu_host+0x1ca>
    9e96:	32 c0       	rjmp	.+100    	; 0x9efc <_menu_host+0x22e>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    9e98:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9e9a:	e1 99       	sbic	0x1c, 1	; 28
    9e9c:	fe cf       	rjmp	.-4      	; 0x9e9a <_menu_host+0x1cc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9e9e:	21 ec       	ldi	r18, 0xC1	; 193
    9ea0:	33 e0       	ldi	r19, 0x03	; 3
    9ea2:	3f bb       	out	0x1f, r19	; 31
    9ea4:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    9ea6:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    9ea8:	0f b6       	in	r0, 0x3f	; 63
    9eaa:	f8 94       	cli
    9eac:	e2 9a       	sbi	0x1c, 2	; 28
    9eae:	e1 9a       	sbi	0x1c, 1	; 28
    9eb0:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefShowDateTime, __value[1]);
    9eb2:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9eb4:	e1 99       	sbic	0x1c, 1	; 28
    9eb6:	fe cf       	rjmp	.-4      	; 0x9eb4 <_menu_host+0x1e6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9eb8:	a7 e3       	ldi	r26, 0x37	; 55
    9eba:	b0 e0       	ldi	r27, 0x00	; 0
    9ebc:	bf bb       	out	0x1f, r27	; 31
    9ebe:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    9ec0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    9ec2:	0f b6       	in	r0, 0x3f	; 63
    9ec4:	f8 94       	cli
    9ec6:	e2 9a       	sbi	0x1c, 2	; 28
    9ec8:	e1 9a       	sbi	0x1c, 1	; 28
    9eca:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    9ecc:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9ece:	e1 99       	sbic	0x1c, 1	; 28
    9ed0:	fe cf       	rjmp	.-4      	; 0x9ece <_menu_host+0x200>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9ed2:	e8 e3       	ldi	r30, 0x38	; 56
    9ed4:	f0 e0       	ldi	r31, 0x00	; 0
    9ed6:	ff bb       	out	0x1f, r31	; 31
    9ed8:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    9eda:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    9edc:	0f b6       	in	r0, 0x3f	; 63
    9ede:	f8 94       	cli
    9ee0:	e2 9a       	sbi	0x1c, 2	; 28
    9ee2:	e1 9a       	sbi	0x1c, 1	; 28
    9ee4:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9ee6:	e1 99       	sbic	0x1c, 1	; 28
    9ee8:	fe cf       	rjmp	.-4      	; 0x9ee6 <_menu_host+0x218>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9eea:	3f ba       	out	0x1f, r3	; 31
    9eec:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    9eee:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    9ef0:	0f b6       	in	r0, 0x3f	; 63
    9ef2:	f8 94       	cli
    9ef4:	e2 9a       	sbi	0x1c, 2	; 28
    9ef6:	e1 9a       	sbi	0x1c, 1	; 28
    9ef8:	0f be       	out	0x3f, r0	; 63
    9efa:	74 c0       	rjmp	.+232    	; 0x9fe4 <_menu_host+0x316>
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    9efc:	81 53       	subi	r24, 0x31	; 49
    9efe:	83 30       	cpi	r24, 0x03	; 3
    9f00:	08 f0       	brcs	.+2      	; 0x9f04 <_menu_host+0x236>
    9f02:	40 c0       	rjmp	.+128    	; 0x9f84 <_menu_host+0x2b6>
			if(__value[__num - 0x31] == 1)
    9f04:	a9 2f       	mov	r26, r25
    9f06:	b0 e0       	ldi	r27, 0x00	; 0
    9f08:	d1 97       	sbiw	r26, 0x31	; 49
    9f0a:	f6 01       	movw	r30, r12
    9f0c:	ea 0f       	add	r30, r26
    9f0e:	fb 1f       	adc	r31, r27
    9f10:	80 81       	ld	r24, Z
    9f12:	81 30       	cpi	r24, 0x01	; 1
    9f14:	11 f4       	brne	.+4      	; 0x9f1a <_menu_host+0x24c>
				__value[__num - 0x31] = 0;
    9f16:	10 82       	st	Z, r1
    9f18:	02 c0       	rjmp	.+4      	; 0x9f1e <_menu_host+0x250>
			else
				__value[__num - 0x31]++;
    9f1a:	8f 5f       	subi	r24, 0xFF	; 255
    9f1c:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    9f1e:	29 2f       	mov	r18, r25
    9f20:	30 e0       	ldi	r19, 0x00	; 0
    9f22:	21 53       	subi	r18, 0x31	; 49
    9f24:	30 40       	sbci	r19, 0x00	; 0
    9f26:	22 0f       	add	r18, r18
    9f28:	33 1f       	adc	r19, r19
    9f2a:	c9 01       	movw	r24, r18
    9f2c:	8e 52       	subi	r24, 0x2E	; 46
    9f2e:	9d 4f       	sbci	r25, 0xFD	; 253
    9f30:	fc 01       	movw	r30, r24
    9f32:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    9f34:	2d 52       	subi	r18, 0x2D	; 45
    9f36:	3d 4f       	sbci	r19, 0xFD	; 253
    9f38:	f9 01       	movw	r30, r18
    9f3a:	14 91       	lpm	r17, Z+
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    9f3c:	00 d0       	rcall	.+0      	; 0x9f3e <_menu_host+0x270>
    9f3e:	00 d0       	rcall	.+0      	; 0x9f40 <_menu_host+0x272>
    9f40:	00 d0       	rcall	.+0      	; 0x9f42 <_menu_host+0x274>
    9f42:	2d b7       	in	r18, 0x3d	; 61
    9f44:	3e b7       	in	r19, 0x3e	; 62
    9f46:	2f 5f       	subi	r18, 0xFF	; 255
    9f48:	3f 4f       	sbci	r19, 0xFF	; 255
    9f4a:	ed b7       	in	r30, 0x3d	; 61
    9f4c:	fe b7       	in	r31, 0x3e	; 62
    9f4e:	f2 82       	std	Z+2, r15	; 0x02
    9f50:	e1 82       	std	Z+1, r14	; 0x01
    9f52:	f9 01       	movw	r30, r18
    9f54:	73 82       	std	Z+3, r7	; 0x03
    9f56:	62 82       	std	Z+2, r6	; 0x02
    9f58:	ac 0d       	add	r26, r12
    9f5a:	bd 1d       	adc	r27, r13
    9f5c:	8c 91       	ld	r24, X
    9f5e:	84 83       	std	Z+4, r24	; 0x04
    9f60:	15 82       	std	Z+5, r1	; 0x05
    9f62:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			//_f_inttostr(__buff, __value[__num - 0x31]);
			lcd_print(__x, __y, __buff);
    9f66:	2d b7       	in	r18, 0x3d	; 61
    9f68:	3e b7       	in	r19, 0x3e	; 62
    9f6a:	2a 5f       	subi	r18, 0xFA	; 250
    9f6c:	3f 4f       	sbci	r19, 0xFF	; 255
    9f6e:	0f b6       	in	r0, 0x3f	; 63
    9f70:	f8 94       	cli
    9f72:	3e bf       	out	0x3e, r19	; 62
    9f74:	0f be       	out	0x3f, r0	; 63
    9f76:	2d bf       	out	0x3d, r18	; 61
    9f78:	80 2f       	mov	r24, r16
    9f7a:	61 2f       	mov	r22, r17
    9f7c:	a7 01       	movw	r20, r14
    9f7e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    9f82:	7d cf       	rjmp	.-262    	; 0x9e7e <_menu_host+0x1b0>
		}else
		if (__num=='4'){
    9f84:	94 33       	cpi	r25, 0x34	; 52
    9f86:	09 f0       	breq	.+2      	; 0x9f8a <_menu_host+0x2bc>
    9f88:	7a cf       	rjmp	.-268    	; 0x9e7e <_menu_host+0x1b0>
		    if (TermID<=99)TermID++;
    9f8a:	33 e6       	ldi	r19, 0x63	; 99
    9f8c:	3b 15       	cp	r19, r11
    9f8e:	18 f4       	brcc	.+6      	; 0x9f96 <_menu_host+0x2c8>
    9f90:	bb 24       	eor	r11, r11
    9f92:	b3 94       	inc	r11
    9f94:	01 c0       	rjmp	.+2      	; 0x9f98 <_menu_host+0x2ca>
    9f96:	b3 94       	inc	r11
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    9f98:	00 d0       	rcall	.+0      	; 0x9f9a <_menu_host+0x2cc>
    9f9a:	00 d0       	rcall	.+0      	; 0x9f9c <_menu_host+0x2ce>
    9f9c:	00 d0       	rcall	.+0      	; 0x9f9e <_menu_host+0x2d0>
    9f9e:	ed b7       	in	r30, 0x3d	; 61
    9fa0:	fe b7       	in	r31, 0x3e	; 62
    9fa2:	31 96       	adiw	r30, 0x01	; 1
    9fa4:	ad b7       	in	r26, 0x3d	; 61
    9fa6:	be b7       	in	r27, 0x3e	; 62
    9fa8:	12 96       	adiw	r26, 0x02	; 2
    9faa:	9c 92       	st	X, r9
    9fac:	8e 92       	st	-X, r8
    9fae:	11 97       	sbiw	r26, 0x01	; 1
    9fb0:	53 82       	std	Z+3, r5	; 0x03
    9fb2:	42 82       	std	Z+2, r4	; 0x02
    9fb4:	b4 82       	std	Z+4, r11	; 0x04
    9fb6:	15 82       	std	Z+5, r1	; 0x05
    9fb8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    9fbc:	ed b7       	in	r30, 0x3d	; 61
    9fbe:	fe b7       	in	r31, 0x3e	; 62
    9fc0:	36 96       	adiw	r30, 0x06	; 6
    9fc2:	0f b6       	in	r0, 0x3f	; 63
    9fc4:	f8 94       	cli
    9fc6:	fe bf       	out	0x3e, r31	; 62
    9fc8:	0f be       	out	0x3f, r0	; 63
    9fca:	ed bf       	out	0x3d, r30	; 61
    9fcc:	84 e0       	ldi	r24, 0x04	; 4
    9fce:	61 e0       	ldi	r22, 0x01	; 1
    9fd0:	a4 01       	movw	r20, r8
    9fd2:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    9fd6:	84 e0       	ldi	r24, 0x04	; 4
    9fd8:	6f e0       	ldi	r22, 0x0F	; 15
    9fda:	4f e6       	ldi	r20, 0x6F	; 111
    9fdc:	5c e0       	ldi	r21, 0x0C	; 12
    9fde:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    9fe2:	4d cf       	rjmp	.-358    	; 0x9e7e <_menu_host+0x1b0>
		 
		}

	}
}
    9fe4:	6d 96       	adiw	r28, 0x1d	; 29
    9fe6:	0f b6       	in	r0, 0x3f	; 63
    9fe8:	f8 94       	cli
    9fea:	de bf       	out	0x3e, r29	; 62
    9fec:	0f be       	out	0x3f, r0	; 63
    9fee:	cd bf       	out	0x3d, r28	; 61
    9ff0:	cf 91       	pop	r28
    9ff2:	df 91       	pop	r29
    9ff4:	1f 91       	pop	r17
    9ff6:	0f 91       	pop	r16
    9ff8:	ff 90       	pop	r15
    9ffa:	ef 90       	pop	r14
    9ffc:	df 90       	pop	r13
    9ffe:	cf 90       	pop	r12
    a000:	bf 90       	pop	r11
    a002:	9f 90       	pop	r9
    a004:	8f 90       	pop	r8
    a006:	7f 90       	pop	r7
    a008:	6f 90       	pop	r6
    a00a:	5f 90       	pop	r5
    a00c:	4f 90       	pop	r4
    a00e:	3f 90       	pop	r3
    a010:	2f 90       	pop	r2
    a012:	08 95       	ret

0000a014 <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    a014:	0e 94 67 4e 	call	0x9cce	; 0x9cce <_menu_host>
	 return MENU_DONE;
}
    a018:	81 e0       	ldi	r24, 0x01	; 1
    a01a:	08 95       	ret

0000a01c <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    a01c:	2f 92       	push	r2
    a01e:	3f 92       	push	r3
    a020:	4f 92       	push	r4
    a022:	5f 92       	push	r5
    a024:	6f 92       	push	r6
    a026:	7f 92       	push	r7
    a028:	8f 92       	push	r8
    a02a:	9f 92       	push	r9
    a02c:	af 92       	push	r10
    a02e:	bf 92       	push	r11
    a030:	cf 92       	push	r12
    a032:	df 92       	push	r13
    a034:	ef 92       	push	r14
    a036:	ff 92       	push	r15
    a038:	0f 93       	push	r16
    a03a:	1f 93       	push	r17
    a03c:	df 93       	push	r29
    a03e:	cf 93       	push	r28
    a040:	cd b7       	in	r28, 0x3d	; 61
    a042:	de b7       	in	r29, 0x3e	; 62
    a044:	2c 97       	sbiw	r28, 0x0c	; 12
    a046:	0f b6       	in	r0, 0x3f	; 63
    a048:	f8 94       	cli
    a04a:	de bf       	out	0x3e, r29	; 62
    a04c:	0f be       	out	0x3f, r0	; 63
    a04e:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a050:	e1 99       	sbic	0x1c, 1	; 28
    a052:	fe cf       	rjmp	.-4      	; 0xa050 <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a054:	20 e3       	ldi	r18, 0x30	; 48
    a056:	30 e0       	ldi	r19, 0x00	; 0
    a058:	3f bb       	out	0x1f, r19	; 31
    a05a:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a05c:	e0 9a       	sbi	0x1c, 0	; 28
    a05e:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a060:	e1 99       	sbic	0x1c, 1	; 28
    a062:	fe cf       	rjmp	.-4      	; 0xa060 <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a064:	65 e3       	ldi	r22, 0x35	; 53
    a066:	70 e0       	ldi	r23, 0x00	; 0
    a068:	7f bb       	out	0x1f, r23	; 31
    a06a:	6e bb       	out	0x1e, r22	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a06c:	e0 9a       	sbi	0x1c, 0	; 28
    a06e:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a070:	e1 99       	sbic	0x1c, 1	; 28
    a072:	fe cf       	rjmp	.-4      	; 0xa070 <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a074:	84 e3       	ldi	r24, 0x34	; 52
    a076:	90 e0       	ldi	r25, 0x00	; 0
    a078:	9f bb       	out	0x1f, r25	; 31
    a07a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a07c:	e0 9a       	sbi	0x1c, 0	; 28
    a07e:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a080:	e1 99       	sbic	0x1c, 1	; 28
    a082:	fe cf       	rjmp	.-4      	; 0xa080 <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a084:	a3 e3       	ldi	r26, 0x33	; 51
    a086:	b0 e0       	ldi	r27, 0x00	; 0
    a088:	bf bb       	out	0x1f, r27	; 31
    a08a:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a08c:	e0 9a       	sbi	0x1c, 0	; 28
    a08e:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a090:	e1 99       	sbic	0x1c, 1	; 28
    a092:	fe cf       	rjmp	.-4      	; 0xa090 <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a094:	e1 e3       	ldi	r30, 0x31	; 49
    a096:	f0 e0       	ldi	r31, 0x00	; 0
    a098:	ff bb       	out	0x1f, r31	; 31
    a09a:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a09c:	e0 9a       	sbi	0x1c, 0	; 28
    a09e:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a0a0:	e1 99       	sbic	0x1c, 1	; 28
    a0a2:	fe cf       	rjmp	.-4      	; 0xa0a0 <_menu_printer+0x84>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a0a4:	62 e3       	ldi	r22, 0x32	; 50
    a0a6:	70 e0       	ldi	r23, 0x00	; 0
    a0a8:	7f bb       	out	0x1f, r23	; 31
    a0aa:	6e bb       	out	0x1e, r22	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a0ac:	e0 9a       	sbi	0x1c, 0	; 28
    a0ae:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    a0b0:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&DefPrintSize);
    a0b2:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&DefPrintLogo);
    a0b4:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&DefPrintAutoCut);
    a0b6:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    a0b8:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    a0ba:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    a0bc:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    a0c0:	81 e0       	ldi	r24, 0x01	; 1
    a0c2:	61 e0       	ldi	r22, 0x01	; 1
    a0c4:	49 e0       	ldi	r20, 0x09	; 9
    a0c6:	5d e0       	ldi	r21, 0x0D	; 13
    a0c8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    a0cc:	82 e0       	ldi	r24, 0x02	; 2
    a0ce:	61 e0       	ldi	r22, 0x01	; 1
    a0d0:	46 ef       	ldi	r20, 0xF6	; 246
    a0d2:	5c e0       	ldi	r21, 0x0C	; 12
    a0d4:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    a0d8:	83 e0       	ldi	r24, 0x03	; 3
    a0da:	61 e0       	ldi	r22, 0x01	; 1
    a0dc:	46 ee       	ldi	r20, 0xE6	; 230
    a0de:	5c e0       	ldi	r21, 0x0C	; 12
    a0e0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    a0e4:	84 e0       	ldi	r24, 0x04	; 4
    a0e6:	61 e0       	ldi	r22, 0x01	; 1
    a0e8:	46 ed       	ldi	r20, 0xD6	; 214
    a0ea:	5c e0       	ldi	r21, 0x0C	; 12
    a0ec:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    a0f0:	0a eb       	ldi	r16, 0xBA	; 186
    a0f2:	12 e0       	ldi	r17, 0x02	; 2
    a0f4:	4e 01       	movw	r8, r28
    a0f6:	08 94       	sec
    a0f8:	81 1c       	adc	r8, r1
    a0fa:	91 1c       	adc	r9, r1
    a0fc:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
        sprintf_P(__buff,PSTR("%d"),__value[__i]);
    a0fe:	77 e0       	ldi	r23, 0x07	; 7
    a100:	c7 2e       	mov	r12, r23
    a102:	d1 2c       	mov	r13, r1
    a104:	cc 0e       	add	r12, r28
    a106:	dd 1e       	adc	r13, r29
    a108:	63 ed       	ldi	r22, 0xD3	; 211
    a10a:	26 2e       	mov	r2, r22
    a10c:	6c e0       	ldi	r22, 0x0C	; 12
    a10e:	36 2e       	mov	r3, r22
		//_f_inttostr(__buff, __value[__i]);
		if(__i == 4) sprintf_P(__buff,PSTR("%.2d"),__value[__i]);
    a110:	5e ec       	ldi	r21, 0xCE	; 206
    a112:	45 2e       	mov	r4, r21
    a114:	5c e0       	ldi	r21, 0x0C	; 12
    a116:	55 2e       	mov	r5, r21
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    a118:	f8 01       	movw	r30, r16
    a11a:	74 90       	lpm	r7, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    a11c:	0f 5f       	subi	r16, 0xFF	; 255
    a11e:	1f 4f       	sbci	r17, 0xFF	; 255
    a120:	f8 01       	movw	r30, r16
    a122:	a4 90       	lpm	r10, Z+
    a124:	01 50       	subi	r16, 0x01	; 1
    a126:	10 40       	sbci	r17, 0x00	; 0
        sprintf_P(__buff,PSTR("%d"),__value[__i]);
    a128:	d7 01       	movw	r26, r14
    a12a:	bc 90       	ld	r11, X
    a12c:	00 d0       	rcall	.+0      	; 0xa12e <_menu_printer+0x112>
    a12e:	00 d0       	rcall	.+0      	; 0xa130 <_menu_printer+0x114>
    a130:	00 d0       	rcall	.+0      	; 0xa132 <_menu_printer+0x116>
    a132:	ed b7       	in	r30, 0x3d	; 61
    a134:	fe b7       	in	r31, 0x3e	; 62
    a136:	31 96       	adiw	r30, 0x01	; 1
    a138:	ad b7       	in	r26, 0x3d	; 61
    a13a:	be b7       	in	r27, 0x3e	; 62
    a13c:	12 96       	adiw	r26, 0x02	; 2
    a13e:	dc 92       	st	X, r13
    a140:	ce 92       	st	-X, r12
    a142:	11 97       	sbiw	r26, 0x01	; 1
    a144:	33 82       	std	Z+3, r3	; 0x03
    a146:	22 82       	std	Z+2, r2	; 0x02
    a148:	b4 82       	std	Z+4, r11	; 0x04
    a14a:	15 82       	std	Z+5, r1	; 0x05
    a14c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		//_f_inttostr(__buff, __value[__i]);
		if(__i == 4) sprintf_P(__buff,PSTR("%.2d"),__value[__i]);
    a150:	8e 2d       	mov	r24, r14
    a152:	88 19       	sub	r24, r8
    a154:	ed b7       	in	r30, 0x3d	; 61
    a156:	fe b7       	in	r31, 0x3e	; 62
    a158:	36 96       	adiw	r30, 0x06	; 6
    a15a:	0f b6       	in	r0, 0x3f	; 63
    a15c:	f8 94       	cli
    a15e:	fe bf       	out	0x3e, r31	; 62
    a160:	0f be       	out	0x3f, r0	; 63
    a162:	ed bf       	out	0x3d, r30	; 61
    a164:	84 30       	cpi	r24, 0x04	; 4
    a166:	d1 f4       	brne	.+52     	; 0xa19c <_menu_printer+0x180>
    a168:	00 d0       	rcall	.+0      	; 0xa16a <_menu_printer+0x14e>
    a16a:	00 d0       	rcall	.+0      	; 0xa16c <_menu_printer+0x150>
    a16c:	00 d0       	rcall	.+0      	; 0xa16e <_menu_printer+0x152>
    a16e:	ed b7       	in	r30, 0x3d	; 61
    a170:	fe b7       	in	r31, 0x3e	; 62
    a172:	31 96       	adiw	r30, 0x01	; 1
    a174:	ad b7       	in	r26, 0x3d	; 61
    a176:	be b7       	in	r27, 0x3e	; 62
    a178:	12 96       	adiw	r26, 0x02	; 2
    a17a:	dc 92       	st	X, r13
    a17c:	ce 92       	st	-X, r12
    a17e:	11 97       	sbiw	r26, 0x01	; 1
    a180:	53 82       	std	Z+3, r5	; 0x03
    a182:	42 82       	std	Z+2, r4	; 0x02
    a184:	b4 82       	std	Z+4, r11	; 0x04
    a186:	15 82       	std	Z+5, r1	; 0x05
    a188:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    a18c:	ed b7       	in	r30, 0x3d	; 61
    a18e:	fe b7       	in	r31, 0x3e	; 62
    a190:	36 96       	adiw	r30, 0x06	; 6
    a192:	0f b6       	in	r0, 0x3f	; 63
    a194:	f8 94       	cli
    a196:	fe bf       	out	0x3e, r31	; 62
    a198:	0f be       	out	0x3f, r0	; 63
    a19a:	ed bf       	out	0x3d, r30	; 61
		//_f_punctuation(__buff, 0, 2, 0);
		lcd_print(__x, __y, __buff);
    a19c:	87 2d       	mov	r24, r7
    a19e:	6a 2d       	mov	r22, r10
    a1a0:	a6 01       	movw	r20, r12
    a1a2:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    a1a6:	0e 5f       	subi	r16, 0xFE	; 254
    a1a8:	1f 4f       	sbci	r17, 0xFF	; 255
    a1aa:	08 94       	sec
    a1ac:	e1 1c       	adc	r14, r1
    a1ae:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    a1b0:	f2 e0       	ldi	r31, 0x02	; 2
    a1b2:	06 3c       	cpi	r16, 0xC6	; 198
    a1b4:	1f 07       	cpc	r17, r31
    a1b6:	09 f0       	breq	.+2      	; 0xa1ba <_menu_printer+0x19e>
    a1b8:	af cf       	rjmp	.-162    	; 0xa118 <_menu_printer+0xfc>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    a1ba:	2e 01       	movw	r4, r28
    a1bc:	08 94       	sec
    a1be:	41 1c       	adc	r4, r1
    a1c0:	51 1c       	adc	r5, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    a1c2:	47 e0       	ldi	r20, 0x07	; 7
    a1c4:	e4 2e       	mov	r14, r20
    a1c6:	f1 2c       	mov	r15, r1
    a1c8:	ec 0e       	add	r14, r28
    a1ca:	fd 1e       	adc	r15, r29
    a1cc:	3b ec       	ldi	r19, 0xCB	; 203
    a1ce:	63 2e       	mov	r6, r19
    a1d0:	3c e0       	ldi	r19, 0x0C	; 12
    a1d2:	73 2e       	mov	r7, r19
			//_f_inttostr(__buff, __value[__num - 0x31]);
			if((__num == 0x35)||(__num == 0x36))
			   sprintf_P(__buff,PSTR("%.2d"),__value[__num - 0x31]);
    a1d4:	26 ec       	ldi	r18, 0xC6	; 198
    a1d6:	22 2e       	mov	r2, r18
    a1d8:	2c e0       	ldi	r18, 0x0C	; 12
    a1da:	32 2e       	mov	r3, r18
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    a1dc:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&DefPrintSize, __value[1]);
    a1de:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&DefPrintLogo, __value[2]);
    a1e0:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
    a1e2:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    a1e4:	cd 80       	ldd	r12, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    a1e6:	de 80       	ldd	r13, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    a1e8:	81 e0       	ldi	r24, 0x01	; 1
    a1ea:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    a1ee:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    a1f0:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    a1f4:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    a1f6:	17 3e       	cpi	r17, 0xE7	; 231
    a1f8:	09 f4       	brne	.+2      	; 0xa1fc <_menu_printer+0x1e0>
    a1fa:	b1 c0       	rjmp	.+354    	; 0xa35e <_menu_printer+0x342>
			return;
		if(__key==_KEY_ENTER){
    a1fc:	17 3b       	cpi	r17, 0xB7	; 183
    a1fe:	09 f0       	breq	.+2      	; 0xa202 <_menu_printer+0x1e6>
    a200:	48 c0       	rjmp	.+144    	; 0xa292 <_menu_printer+0x276>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a202:	e1 99       	sbic	0x1c, 1	; 28
    a204:	fe cf       	rjmp	.-4      	; 0xa202 <_menu_printer+0x1e6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a206:	20 e3       	ldi	r18, 0x30	; 48
    a208:	30 e0       	ldi	r19, 0x00	; 0
    a20a:	3f bb       	out	0x1f, r19	; 31
    a20c:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    a20e:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    a210:	0f b6       	in	r0, 0x3f	; 63
    a212:	f8 94       	cli
    a214:	e2 9a       	sbi	0x1c, 2	; 28
    a216:	e1 9a       	sbi	0x1c, 1	; 28
    a218:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a21a:	e1 99       	sbic	0x1c, 1	; 28
    a21c:	fe cf       	rjmp	.-4      	; 0xa21a <_menu_printer+0x1fe>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a21e:	65 e3       	ldi	r22, 0x35	; 53
    a220:	70 e0       	ldi	r23, 0x00	; 0
    a222:	7f bb       	out	0x1f, r23	; 31
    a224:	6e bb       	out	0x1e, r22	; 30
#endif
    EEDR = __value;
    a226:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    a228:	0f b6       	in	r0, 0x3f	; 63
    a22a:	f8 94       	cli
    a22c:	e2 9a       	sbi	0x1c, 2	; 28
    a22e:	e1 9a       	sbi	0x1c, 1	; 28
    a230:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a232:	e1 99       	sbic	0x1c, 1	; 28
    a234:	fe cf       	rjmp	.-4      	; 0xa232 <_menu_printer+0x216>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a236:	84 e3       	ldi	r24, 0x34	; 52
    a238:	90 e0       	ldi	r25, 0x00	; 0
    a23a:	9f bb       	out	0x1f, r25	; 31
    a23c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    a23e:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    a240:	0f b6       	in	r0, 0x3f	; 63
    a242:	f8 94       	cli
    a244:	e2 9a       	sbi	0x1c, 2	; 28
    a246:	e1 9a       	sbi	0x1c, 1	; 28
    a248:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a24a:	e1 99       	sbic	0x1c, 1	; 28
    a24c:	fe cf       	rjmp	.-4      	; 0xa24a <_menu_printer+0x22e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a24e:	a3 e3       	ldi	r26, 0x33	; 51
    a250:	b0 e0       	ldi	r27, 0x00	; 0
    a252:	bf bb       	out	0x1f, r27	; 31
    a254:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    a256:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    a258:	0f b6       	in	r0, 0x3f	; 63
    a25a:	f8 94       	cli
    a25c:	e2 9a       	sbi	0x1c, 2	; 28
    a25e:	e1 9a       	sbi	0x1c, 1	; 28
    a260:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a262:	e1 99       	sbic	0x1c, 1	; 28
    a264:	fe cf       	rjmp	.-4      	; 0xa262 <_menu_printer+0x246>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a266:	e1 e3       	ldi	r30, 0x31	; 49
    a268:	f0 e0       	ldi	r31, 0x00	; 0
    a26a:	ff bb       	out	0x1f, r31	; 31
    a26c:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    a26e:	cd ba       	out	0x1d, r12	; 29

    __asm__ __volatile__ (
    a270:	0f b6       	in	r0, 0x3f	; 63
    a272:	f8 94       	cli
    a274:	e2 9a       	sbi	0x1c, 2	; 28
    a276:	e1 9a       	sbi	0x1c, 1	; 28
    a278:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a27a:	e1 99       	sbic	0x1c, 1	; 28
    a27c:	fe cf       	rjmp	.-4      	; 0xa27a <_menu_printer+0x25e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a27e:	22 e3       	ldi	r18, 0x32	; 50
    a280:	30 e0       	ldi	r19, 0x00	; 0
    a282:	3f bb       	out	0x1f, r19	; 31
    a284:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    a286:	dd ba       	out	0x1d, r13	; 29

    __asm__ __volatile__ (
    a288:	0f b6       	in	r0, 0x3f	; 63
    a28a:	f8 94       	cli
    a28c:	e2 9a       	sbi	0x1c, 2	; 28
    a28e:	e1 9a       	sbi	0x1c, 1	; 28
    a290:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    a292:	80 2f       	mov	r24, r16
    a294:	81 53       	subi	r24, 0x31	; 49
    a296:	86 30       	cpi	r24, 0x06	; 6
    a298:	08 f0       	brcs	.+2      	; 0xa29c <_menu_printer+0x280>
    a29a:	a6 cf       	rjmp	.-180    	; 0xa1e8 <_menu_printer+0x1cc>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    a29c:	a0 2f       	mov	r26, r16
    a29e:	b0 e0       	ldi	r27, 0x00	; 0
    a2a0:	d1 97       	sbiw	r26, 0x31	; 49
    a2a2:	fd 01       	movw	r30, r26
    a2a4:	ea 53       	subi	r30, 0x3A	; 58
    a2a6:	fd 4f       	sbci	r31, 0xFD	; 253
    a2a8:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    a2aa:	fd 01       	movw	r30, r26
    a2ac:	e4 53       	subi	r30, 0x34	; 52
    a2ae:	fd 4f       	sbci	r31, 0xFD	; 253
    a2b0:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    a2b2:	f2 01       	movw	r30, r4
    a2b4:	ea 0f       	add	r30, r26
    a2b6:	fb 1f       	adc	r31, r27
    a2b8:	80 81       	ld	r24, Z
    a2ba:	82 17       	cp	r24, r18
    a2bc:	11 f4       	brne	.+4      	; 0xa2c2 <_menu_printer+0x2a6>
				__value[__num - 0x31] = __start;
    a2be:	90 83       	st	Z, r25
    a2c0:	02 c0       	rjmp	.+4      	; 0xa2c6 <_menu_printer+0x2aa>
			else
				__value[__num - 0x31]++;
    a2c2:	8f 5f       	subi	r24, 0xFF	; 255
    a2c4:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    a2c6:	9d 01       	movw	r18, r26
    a2c8:	22 0f       	add	r18, r18
    a2ca:	33 1f       	adc	r19, r19
    a2cc:	c9 01       	movw	r24, r18
    a2ce:	86 54       	subi	r24, 0x46	; 70
    a2d0:	9d 4f       	sbci	r25, 0xFD	; 253
    a2d2:	fc 01       	movw	r30, r24
    a2d4:	c4 90       	lpm	r12, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    a2d6:	25 54       	subi	r18, 0x45	; 69
    a2d8:	3d 4f       	sbci	r19, 0xFD	; 253
    a2da:	f9 01       	movw	r30, r18
    a2dc:	d4 90       	lpm	r13, Z+
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    a2de:	a4 0d       	add	r26, r4
    a2e0:	b5 1d       	adc	r27, r5
    a2e2:	1c 91       	ld	r17, X
    a2e4:	00 d0       	rcall	.+0      	; 0xa2e6 <_menu_printer+0x2ca>
    a2e6:	00 d0       	rcall	.+0      	; 0xa2e8 <_menu_printer+0x2cc>
    a2e8:	00 d0       	rcall	.+0      	; 0xa2ea <_menu_printer+0x2ce>
    a2ea:	ed b7       	in	r30, 0x3d	; 61
    a2ec:	fe b7       	in	r31, 0x3e	; 62
    a2ee:	31 96       	adiw	r30, 0x01	; 1
    a2f0:	ad b7       	in	r26, 0x3d	; 61
    a2f2:	be b7       	in	r27, 0x3e	; 62
    a2f4:	12 96       	adiw	r26, 0x02	; 2
    a2f6:	fc 92       	st	X, r15
    a2f8:	ee 92       	st	-X, r14
    a2fa:	11 97       	sbiw	r26, 0x01	; 1
    a2fc:	73 82       	std	Z+3, r7	; 0x03
    a2fe:	62 82       	std	Z+2, r6	; 0x02
    a300:	14 83       	std	Z+4, r17	; 0x04
    a302:	15 82       	std	Z+5, r1	; 0x05
    a304:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			//_f_inttostr(__buff, __value[__num - 0x31]);
			if((__num == 0x35)||(__num == 0x36))
    a308:	05 53       	subi	r16, 0x35	; 53
    a30a:	ed b7       	in	r30, 0x3d	; 61
    a30c:	fe b7       	in	r31, 0x3e	; 62
    a30e:	36 96       	adiw	r30, 0x06	; 6
    a310:	0f b6       	in	r0, 0x3f	; 63
    a312:	f8 94       	cli
    a314:	fe bf       	out	0x3e, r31	; 62
    a316:	0f be       	out	0x3f, r0	; 63
    a318:	ed bf       	out	0x3d, r30	; 61
    a31a:	02 30       	cpi	r16, 0x02	; 2
    a31c:	d0 f4       	brcc	.+52     	; 0xa352 <_menu_printer+0x336>
			   sprintf_P(__buff,PSTR("%.2d"),__value[__num - 0x31]);
    a31e:	00 d0       	rcall	.+0      	; 0xa320 <_menu_printer+0x304>
    a320:	00 d0       	rcall	.+0      	; 0xa322 <_menu_printer+0x306>
    a322:	00 d0       	rcall	.+0      	; 0xa324 <_menu_printer+0x308>
    a324:	ed b7       	in	r30, 0x3d	; 61
    a326:	fe b7       	in	r31, 0x3e	; 62
    a328:	31 96       	adiw	r30, 0x01	; 1
    a32a:	ad b7       	in	r26, 0x3d	; 61
    a32c:	be b7       	in	r27, 0x3e	; 62
    a32e:	12 96       	adiw	r26, 0x02	; 2
    a330:	fc 92       	st	X, r15
    a332:	ee 92       	st	-X, r14
    a334:	11 97       	sbiw	r26, 0x01	; 1
    a336:	33 82       	std	Z+3, r3	; 0x03
    a338:	22 82       	std	Z+2, r2	; 0x02
    a33a:	14 83       	std	Z+4, r17	; 0x04
    a33c:	15 82       	std	Z+5, r1	; 0x05
    a33e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    a342:	ed b7       	in	r30, 0x3d	; 61
    a344:	fe b7       	in	r31, 0x3e	; 62
    a346:	36 96       	adiw	r30, 0x06	; 6
    a348:	0f b6       	in	r0, 0x3f	; 63
    a34a:	f8 94       	cli
    a34c:	fe bf       	out	0x3e, r31	; 62
    a34e:	0f be       	out	0x3f, r0	; 63
    a350:	ed bf       	out	0x3d, r30	; 61
				//_f_punctuation(__buff, 0, 2, 0);

			lcd_print(__x, __y, __buff);
    a352:	8c 2d       	mov	r24, r12
    a354:	6d 2d       	mov	r22, r13
    a356:	a7 01       	movw	r20, r14
    a358:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    a35c:	3f cf       	rjmp	.-386    	; 0xa1dc <_menu_printer+0x1c0>
		}
	}
}
    a35e:	2c 96       	adiw	r28, 0x0c	; 12
    a360:	0f b6       	in	r0, 0x3f	; 63
    a362:	f8 94       	cli
    a364:	de bf       	out	0x3e, r29	; 62
    a366:	0f be       	out	0x3f, r0	; 63
    a368:	cd bf       	out	0x3d, r28	; 61
    a36a:	cf 91       	pop	r28
    a36c:	df 91       	pop	r29
    a36e:	1f 91       	pop	r17
    a370:	0f 91       	pop	r16
    a372:	ff 90       	pop	r15
    a374:	ef 90       	pop	r14
    a376:	df 90       	pop	r13
    a378:	cf 90       	pop	r12
    a37a:	bf 90       	pop	r11
    a37c:	af 90       	pop	r10
    a37e:	9f 90       	pop	r9
    a380:	8f 90       	pop	r8
    a382:	7f 90       	pop	r7
    a384:	6f 90       	pop	r6
    a386:	5f 90       	pop	r5
    a388:	4f 90       	pop	r4
    a38a:	3f 90       	pop	r3
    a38c:	2f 90       	pop	r2
    a38e:	08 95       	ret

0000a390 <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    a390:	0e 94 0e 50 	call	0xa01c	; 0xa01c <_menu_printer>
	 return MENU_DONE;
}
    a394:	81 e0       	ldi	r24, 0x01	; 1
    a396:	08 95       	ret

0000a398 <_menu_pumpprodinput>:
				*/
		}
	}
}

void _menu_pumpprodinput(unsigned char __select){
    a398:	6f 92       	push	r6
    a39a:	7f 92       	push	r7
    a39c:	8f 92       	push	r8
    a39e:	9f 92       	push	r9
    a3a0:	af 92       	push	r10
    a3a2:	bf 92       	push	r11
    a3a4:	cf 92       	push	r12
    a3a6:	df 92       	push	r13
    a3a8:	ef 92       	push	r14
    a3aa:	ff 92       	push	r15
    a3ac:	0f 93       	push	r16
    a3ae:	1f 93       	push	r17
    a3b0:	df 93       	push	r29
    a3b2:	cf 93       	push	r28
    a3b4:	cd b7       	in	r28, 0x3d	; 61
    a3b6:	de b7       	in	r29, 0x3e	; 62
    a3b8:	a7 97       	sbiw	r28, 0x27	; 39
    a3ba:	0f b6       	in	r0, 0x3f	; 63
    a3bc:	f8 94       	cli
    a3be:	de bf       	out	0x3e, r29	; 62
    a3c0:	0f be       	out	0x3f, r0	; 63
    a3c2:	cd bf       	out	0x3d, r28	; 61
    a3c4:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    a3c6:	8e 01       	movw	r16, r28
    a3c8:	04 5f       	subi	r16, 0xF4	; 244
    a3ca:	1f 4f       	sbci	r17, 0xFF	; 255
    a3cc:	c8 01       	movw	r24, r16
    a3ce:	65 e4       	ldi	r22, 0x45	; 69
    a3d0:	70 e0       	ldi	r23, 0x00	; 0
    a3d2:	48 e0       	ldi	r20, 0x08	; 8
    a3d4:	50 e0       	ldi	r21, 0x00	; 0
    a3d6:	22 ed       	ldi	r18, 0xD2	; 210
    a3d8:	33 e1       	ldi	r19, 0x13	; 19
    a3da:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    a3de:	86 e0       	ldi	r24, 0x06	; 6
    a3e0:	b8 9e       	mul	r11, r24
    a3e2:	40 01       	movw	r8, r0
    a3e4:	11 24       	eor	r1, r1
    a3e6:	85 e5       	ldi	r24, 0x55	; 85
    a3e8:	90 e0       	ldi	r25, 0x00	; 0
    a3ea:	88 0e       	add	r8, r24
    a3ec:	99 1e       	adc	r9, r25
    a3ee:	96 e0       	ldi	r25, 0x06	; 6
    a3f0:	c9 2e       	mov	r12, r25
    a3f2:	d1 2c       	mov	r13, r1
    a3f4:	cc 0e       	add	r12, r28
    a3f6:	dd 1e       	adc	r13, r29
    a3f8:	c6 01       	movw	r24, r12
    a3fa:	b4 01       	movw	r22, r8
    a3fc:	46 e0       	ldi	r20, 0x06	; 6
    a3fe:	50 e0       	ldi	r21, 0x00	; 0
    a400:	22 ed       	ldi	r18, 0xD2	; 210
    a402:	33 e1       	ldi	r19, 0x13	; 19
    a404:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>

	lcd_clear();_delay_ms(10);
    a408:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    a40c:	80 e0       	ldi	r24, 0x00	; 0
    a40e:	90 e9       	ldi	r25, 0x90	; 144
    a410:	01 97       	sbiw	r24, 0x01	; 1
    a412:	f1 f7       	brne	.-4      	; 0xa410 <_menu_pumpprodinput+0x78>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    a414:	00 d0       	rcall	.+0      	; 0xa416 <_menu_pumpprodinput+0x7e>
    a416:	00 d0       	rcall	.+0      	; 0xa418 <_menu_pumpprodinput+0x80>
    a418:	00 d0       	rcall	.+0      	; 0xa41a <_menu_pumpprodinput+0x82>
    a41a:	ed b7       	in	r30, 0x3d	; 61
    a41c:	fe b7       	in	r31, 0x3e	; 62
    a41e:	31 96       	adiw	r30, 0x01	; 1
    a420:	84 e1       	ldi	r24, 0x14	; 20
    a422:	e8 2e       	mov	r14, r24
    a424:	f1 2c       	mov	r15, r1
    a426:	ec 0e       	add	r14, r28
    a428:	fd 1e       	adc	r15, r29
    a42a:	ad b7       	in	r26, 0x3d	; 61
    a42c:	be b7       	in	r27, 0x3e	; 62
    a42e:	12 96       	adiw	r26, 0x02	; 2
    a430:	fc 92       	st	X, r15
    a432:	ee 92       	st	-X, r14
    a434:	11 97       	sbiw	r26, 0x01	; 1
    a436:	84 e8       	ldi	r24, 0x84	; 132
    a438:	9d e0       	ldi	r25, 0x0D	; 13
    a43a:	93 83       	std	Z+3, r25	; 0x03
    a43c:	82 83       	std	Z+2, r24	; 0x02
    a43e:	0b 0d       	add	r16, r11
    a440:	11 1d       	adc	r17, r1
    a442:	d8 01       	movw	r26, r16
    a444:	8c 91       	ld	r24, X
    a446:	84 83       	std	Z+4, r24	; 0x04
    a448:	15 82       	std	Z+5, r1	; 0x05
    a44a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    lcd_print(1, 1,lcdteks);
    a44e:	ed b7       	in	r30, 0x3d	; 61
    a450:	fe b7       	in	r31, 0x3e	; 62
    a452:	36 96       	adiw	r30, 0x06	; 6
    a454:	0f b6       	in	r0, 0x3f	; 63
    a456:	f8 94       	cli
    a458:	fe bf       	out	0x3e, r31	; 62
    a45a:	0f be       	out	0x3f, r0	; 63
    a45c:	ed bf       	out	0x3d, r30	; 61
    a45e:	81 e0       	ldi	r24, 0x01	; 1
    a460:	61 e0       	ldi	r22, 0x01	; 1
    a462:	a7 01       	movw	r20, r14
    a464:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    a468:	82 e0       	ldi	r24, 0x02	; 2
    a46a:	61 e0       	ldi	r22, 0x01	; 1
    a46c:	40 e7       	ldi	r20, 0x70	; 112
    a46e:	5d e0       	ldi	r21, 0x0D	; 13
    a470:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    a474:	83 e0       	ldi	r24, 0x03	; 3
    a476:	61 e0       	ldi	r22, 0x01	; 1
    a478:	4c e5       	ldi	r20, 0x5C	; 92
    a47a:	5d e0       	ldi	r21, 0x0D	; 13
    a47c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    a480:	84 e0       	ldi	r24, 0x04	; 4
    a482:	61 e0       	ldi	r22, 0x01	; 1
    a484:	47 e4       	ldi	r20, 0x47	; 71
    a486:	5d e0       	ldi	r21, 0x0D	; 13
    a488:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    a48c:	1e ea       	ldi	r17, 0xAE	; 174
    a48e:	e1 2e       	mov	r14, r17
    a490:	12 e0       	ldi	r17, 0x02	; 2
    a492:	f1 2e       	mov	r15, r17

	for(i=0;i<6;i++){
		__x = pgm_read_byte(&__prodloc[i][0]);
		__y = pgm_read_byte(&__prodloc[i][1]);

        sprintf_P(__buff,PSTR("%d"),__pump_prod[i]);
    a494:	5e 01       	movw	r10, r28
    a496:	08 94       	sec
    a498:	a1 1c       	adc	r10, r1
    a49a:	b1 1c       	adc	r11, r1
    a49c:	b4 e4       	ldi	r27, 0x44	; 68
    a49e:	6b 2e       	mov	r6, r27
    a4a0:	bd e0       	ldi	r27, 0x0D	; 13
    a4a2:	7b 2e       	mov	r7, r27
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(i=0;i<6;i++){
		__x = pgm_read_byte(&__prodloc[i][0]);
    a4a4:	f7 01       	movw	r30, r14
    a4a6:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[i][1]);
    a4a8:	08 94       	sec
    a4aa:	e1 1c       	adc	r14, r1
    a4ac:	f1 1c       	adc	r15, r1
    a4ae:	f7 01       	movw	r30, r14
    a4b0:	14 91       	lpm	r17, Z+

        sprintf_P(__buff,PSTR("%d"),__pump_prod[i]);
    a4b2:	00 d0       	rcall	.+0      	; 0xa4b4 <_menu_pumpprodinput+0x11c>
    a4b4:	00 d0       	rcall	.+0      	; 0xa4b6 <_menu_pumpprodinput+0x11e>
    a4b6:	00 d0       	rcall	.+0      	; 0xa4b8 <_menu_pumpprodinput+0x120>
    a4b8:	ed b7       	in	r30, 0x3d	; 61
    a4ba:	fe b7       	in	r31, 0x3e	; 62
    a4bc:	31 96       	adiw	r30, 0x01	; 1
    a4be:	ad b7       	in	r26, 0x3d	; 61
    a4c0:	be b7       	in	r27, 0x3e	; 62
    a4c2:	12 96       	adiw	r26, 0x02	; 2
    a4c4:	bc 92       	st	X, r11
    a4c6:	ae 92       	st	-X, r10
    a4c8:	11 97       	sbiw	r26, 0x01	; 1
    a4ca:	73 82       	std	Z+3, r7	; 0x03
    a4cc:	62 82       	std	Z+2, r6	; 0x02
    a4ce:	d6 01       	movw	r26, r12
    a4d0:	8d 91       	ld	r24, X+
    a4d2:	6d 01       	movw	r12, r26
    a4d4:	84 83       	std	Z+4, r24	; 0x04
    a4d6:	15 82       	std	Z+5, r1	; 0x05
    a4d8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		lcd_print(__x+1, __y, __buff);
    a4dc:	ed b7       	in	r30, 0x3d	; 61
    a4de:	fe b7       	in	r31, 0x3e	; 62
    a4e0:	36 96       	adiw	r30, 0x06	; 6
    a4e2:	0f b6       	in	r0, 0x3f	; 63
    a4e4:	f8 94       	cli
    a4e6:	fe bf       	out	0x3e, r31	; 62
    a4e8:	0f be       	out	0x3f, r0	; 63
    a4ea:	ed bf       	out	0x3d, r30	; 61
    a4ec:	80 2f       	mov	r24, r16
    a4ee:	8f 5f       	subi	r24, 0xFF	; 255
    a4f0:	61 2f       	mov	r22, r17
    a4f2:	a5 01       	movw	r20, r10
    a4f4:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    a4f8:	08 94       	sec
    a4fa:	e1 1c       	adc	r14, r1
    a4fc:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(i=0;i<6;i++){
    a4fe:	fa eb       	ldi	r31, 0xBA	; 186
    a500:	ef 16       	cp	r14, r31
    a502:	f2 e0       	ldi	r31, 0x02	; 2
    a504:	ff 06       	cpc	r15, r31
    a506:	71 f6       	brne	.-100    	; 0xa4a4 <_menu_pumpprodinput+0x10c>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    a508:	a6 e0       	ldi	r26, 0x06	; 6
    a50a:	ca 2e       	mov	r12, r26
    a50c:	d1 2c       	mov	r13, r1
    a50e:	cc 0e       	add	r12, r28
    a510:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__pump_prod[__num - 0x31]);
    a512:	7e 01       	movw	r14, r28
    a514:	08 94       	sec
    a516:	e1 1c       	adc	r14, r1
    a518:	f1 1c       	adc	r15, r1
    a51a:	f1 e4       	ldi	r31, 0x41	; 65
    a51c:	af 2e       	mov	r10, r31
    a51e:	fd e0       	ldi	r31, 0x0D	; 13
    a520:	bf 2e       	mov	r11, r31
		//lcd_print(2+(i%2),(i/2)*6,lcdteks);
	}

	while(1){
		
		__key = _key_scan(1);
    a522:	81 e0       	ldi	r24, 0x01	; 1
    a524:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    a528:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    a52a:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    a52e:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    a530:	17 3e       	cpi	r17, 0xE7	; 231
    a532:	09 f4       	brne	.+2      	; 0xa536 <_menu_pumpprodinput+0x19e>
    a534:	50 c0       	rjmp	.+160    	; 0xa5d6 <_menu_pumpprodinput+0x23e>
			return;
		if(__key == _KEY_ENTER){
    a536:	17 3b       	cpi	r17, 0xB7	; 183
    a538:	59 f4       	brne	.+22     	; 0xa550 <_menu_pumpprodinput+0x1b8>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    a53a:	c4 01       	movw	r24, r8
    a53c:	be 01       	movw	r22, r28
    a53e:	6a 5f       	subi	r22, 0xFA	; 250
    a540:	7f 4f       	sbci	r23, 0xFF	; 255
    a542:	46 e0       	ldi	r20, 0x06	; 6
    a544:	50 e0       	ldi	r21, 0x00	; 0
    a546:	2a ed       	ldi	r18, 0xDA	; 218
    a548:	33 e1       	ldi	r19, 0x13	; 19
    a54a:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
    a54e:	43 c0       	rjmp	.+134    	; 0xa5d6 <_menu_pumpprodinput+0x23e>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    a550:	81 53       	subi	r24, 0x31	; 49
    a552:	86 30       	cpi	r24, 0x06	; 6
    a554:	30 f7       	brcc	.-52     	; 0xa522 <_menu_pumpprodinput+0x18a>
			if(__pump_prod[__num - '1'] == 6)
    a556:	a9 2f       	mov	r26, r25
    a558:	b0 e0       	ldi	r27, 0x00	; 0
    a55a:	d1 97       	sbiw	r26, 0x31	; 49
    a55c:	f6 01       	movw	r30, r12
    a55e:	ea 0f       	add	r30, r26
    a560:	fb 1f       	adc	r31, r27
    a562:	80 81       	ld	r24, Z
    a564:	86 30       	cpi	r24, 0x06	; 6
    a566:	11 f4       	brne	.+4      	; 0xa56c <_menu_pumpprodinput+0x1d4>
				__pump_prod[__num - '1'] = 0;
    a568:	10 82       	st	Z, r1
    a56a:	02 c0       	rjmp	.+4      	; 0xa570 <_menu_pumpprodinput+0x1d8>
			else
				__pump_prod[__num - '1']++;
    a56c:	8f 5f       	subi	r24, 0xFF	; 255
    a56e:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    a570:	29 2f       	mov	r18, r25
    a572:	30 e0       	ldi	r19, 0x00	; 0
    a574:	21 53       	subi	r18, 0x31	; 49
    a576:	30 40       	sbci	r19, 0x00	; 0
    a578:	22 0f       	add	r18, r18
    a57a:	33 1f       	adc	r19, r19
    a57c:	c9 01       	movw	r24, r18
    a57e:	82 55       	subi	r24, 0x52	; 82
    a580:	9d 4f       	sbci	r25, 0xFD	; 253
    a582:	fc 01       	movw	r30, r24
    a584:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    a586:	21 55       	subi	r18, 0x51	; 81
    a588:	3d 4f       	sbci	r19, 0xFD	; 253
    a58a:	f9 01       	movw	r30, r18
    a58c:	14 91       	lpm	r17, Z+
			sprintf_P(__buff,PSTR("%d"),__pump_prod[__num - 0x31]);
    a58e:	00 d0       	rcall	.+0      	; 0xa590 <_menu_pumpprodinput+0x1f8>
    a590:	00 d0       	rcall	.+0      	; 0xa592 <_menu_pumpprodinput+0x1fa>
    a592:	00 d0       	rcall	.+0      	; 0xa594 <_menu_pumpprodinput+0x1fc>
    a594:	2d b7       	in	r18, 0x3d	; 61
    a596:	3e b7       	in	r19, 0x3e	; 62
    a598:	2f 5f       	subi	r18, 0xFF	; 255
    a59a:	3f 4f       	sbci	r19, 0xFF	; 255
    a59c:	ed b7       	in	r30, 0x3d	; 61
    a59e:	fe b7       	in	r31, 0x3e	; 62
    a5a0:	f2 82       	std	Z+2, r15	; 0x02
    a5a2:	e1 82       	std	Z+1, r14	; 0x01
    a5a4:	f9 01       	movw	r30, r18
    a5a6:	b3 82       	std	Z+3, r11	; 0x03
    a5a8:	a2 82       	std	Z+2, r10	; 0x02
    a5aa:	ac 0d       	add	r26, r12
    a5ac:	bd 1d       	adc	r27, r13
    a5ae:	8c 91       	ld	r24, X
    a5b0:	84 83       	std	Z+4, r24	; 0x04
    a5b2:	15 82       	std	Z+5, r1	; 0x05
    a5b4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			//_f_inttostr(__buff, __pump_prod[__num - 0x31]);
			lcd_print(__x+1, __y, __buff);
    a5b8:	8d b7       	in	r24, 0x3d	; 61
    a5ba:	9e b7       	in	r25, 0x3e	; 62
    a5bc:	06 96       	adiw	r24, 0x06	; 6
    a5be:	0f b6       	in	r0, 0x3f	; 63
    a5c0:	f8 94       	cli
    a5c2:	9e bf       	out	0x3e, r25	; 62
    a5c4:	0f be       	out	0x3f, r0	; 63
    a5c6:	8d bf       	out	0x3d, r24	; 61
    a5c8:	80 2f       	mov	r24, r16
    a5ca:	8f 5f       	subi	r24, 0xFF	; 255
    a5cc:	61 2f       	mov	r22, r17
    a5ce:	a7 01       	movw	r20, r14
    a5d0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    a5d4:	a6 cf       	rjmp	.-180    	; 0xa522 <_menu_pumpprodinput+0x18a>
		}
	}
}
    a5d6:	a7 96       	adiw	r28, 0x27	; 39
    a5d8:	0f b6       	in	r0, 0x3f	; 63
    a5da:	f8 94       	cli
    a5dc:	de bf       	out	0x3e, r29	; 62
    a5de:	0f be       	out	0x3f, r0	; 63
    a5e0:	cd bf       	out	0x3d, r28	; 61
    a5e2:	cf 91       	pop	r28
    a5e4:	df 91       	pop	r29
    a5e6:	1f 91       	pop	r17
    a5e8:	0f 91       	pop	r16
    a5ea:	ff 90       	pop	r15
    a5ec:	ef 90       	pop	r14
    a5ee:	df 90       	pop	r13
    a5f0:	cf 90       	pop	r12
    a5f2:	bf 90       	pop	r11
    a5f4:	af 90       	pop	r10
    a5f6:	9f 90       	pop	r9
    a5f8:	8f 90       	pop	r8
    a5fa:	7f 90       	pop	r7
    a5fc:	6f 90       	pop	r6
    a5fe:	08 95       	ret

0000a600 <_menu_pumpprod>:
}

void _menu_pumpprod(void){
	char KeyPressed,KeyChar;
	while(1){
		lcd_clear();
    a600:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		_scr_pump();
    a604:	0e 94 e7 49 	call	0x93ce	; 0x93ce <_scr_pump>
		while(1){
			KeyPressed=_key_scan(1);
    a608:	81 e0       	ldi	r24, 0x01	; 1
    a60a:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		    KeyChar=_key_btn(KeyPressed);
    a60e:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    a612:	98 2f       	mov	r25, r24

			if ((KeyChar>='1')&&(KeyChar<='8')){
    a614:	81 53       	subi	r24, 0x31	; 49
    a616:	88 30       	cpi	r24, 0x08	; 8
    a618:	18 f4       	brcc	.+6      	; 0xa620 <_menu_pumpprod+0x20>
			     _menu_pumpprodinput(KeyChar-'1');
    a61a:	0e 94 cc 51 	call	0xa398	; 0xa398 <_menu_pumpprodinput>
    a61e:	f0 cf       	rjmp	.-32     	; 0xa600 <_menu_pumpprod>
				break;
			}else if (KeyChar=='*'){
    a620:	9a 32       	cpi	r25, 0x2A	; 42
    a622:	91 f7       	brne	.-28     	; 0xa608 <_menu_pumpprod+0x8>
			if(__key == _KEY_CANCEL)
				return;
				*/
		}
	}
}
    a624:	08 95       	ret

0000a626 <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    a626:	6f 92       	push	r6
    a628:	7f 92       	push	r7
    a62a:	8f 92       	push	r8
    a62c:	9f 92       	push	r9
    a62e:	af 92       	push	r10
    a630:	bf 92       	push	r11
    a632:	cf 92       	push	r12
    a634:	df 92       	push	r13
    a636:	ef 92       	push	r14
    a638:	ff 92       	push	r15
    a63a:	1f 93       	push	r17
    a63c:	df 93       	push	r29
    a63e:	cf 93       	push	r28
    a640:	cd b7       	in	r28, 0x3d	; 61
    a642:	de b7       	in	r29, 0x3e	; 62
    a644:	2d 97       	sbiw	r28, 0x0d	; 13
    a646:	0f b6       	in	r0, 0x3f	; 63
    a648:	f8 94       	cli
    a64a:	de bf       	out	0x3e, r29	; 62
    a64c:	0f be       	out	0x3f, r0	; 63
    a64e:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    a650:	66 e0       	ldi	r22, 0x06	; 6
    a652:	c6 2e       	mov	r12, r22
    a654:	d1 2c       	mov	r13, r1
    a656:	cc 0e       	add	r12, r28
    a658:	dd 1e       	adc	r13, r29
    a65a:	c6 01       	movw	r24, r12
    a65c:	6d e4       	ldi	r22, 0x4D	; 77
    a65e:	70 e0       	ldi	r23, 0x00	; 0
    a660:	48 e0       	ldi	r20, 0x08	; 8
    a662:	50 e0       	ldi	r21, 0x00	; 0
    a664:	22 ed       	ldi	r18, 0xD2	; 210
    a666:	33 e1       	ldi	r19, 0x13	; 19
    a668:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    a66c:	83 e6       	ldi	r24, 0x63	; 99
    a66e:	80 93 56 01 	sts	0x0156, r24
	lcd_clear();_delay_ms(10);
    a672:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    a676:	80 e0       	ldi	r24, 0x00	; 0
    a678:	90 e9       	ldi	r25, 0x90	; 144
    a67a:	01 97       	sbiw	r24, 0x01	; 1
    a67c:	f1 f7       	brne	.-4      	; 0xa67a <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    a67e:	81 e0       	ldi	r24, 0x01	; 1
    a680:	61 e0       	ldi	r22, 0x01	; 1
    a682:	4f e7       	ldi	r20, 0x7F	; 127
    a684:	5e e0       	ldi	r21, 0x0E	; 14
    a686:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    a68a:	82 e0       	ldi	r24, 0x02	; 2
    a68c:	61 e0       	ldi	r22, 0x01	; 1
    a68e:	43 e7       	ldi	r20, 0x73	; 115
    a690:	5e e0       	ldi	r21, 0x0E	; 14
    a692:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    a696:	83 e0       	ldi	r24, 0x03	; 3
    a698:	61 e0       	ldi	r22, 0x01	; 1
    a69a:	4e e5       	ldi	r20, 0x5E	; 94
    a69c:	5e e0       	ldi	r21, 0x0E	; 14
    a69e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    a6a2:	84 e0       	ldi	r24, 0x04	; 4
    a6a4:	61 e0       	ldi	r22, 0x01	; 1
    a6a6:	49 e4       	ldi	r20, 0x49	; 73
    a6a8:	5e e0       	ldi	r21, 0x0E	; 14
    a6aa:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    a6ae:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    a6b0:	5e 01       	movw	r10, r28
    a6b2:	08 94       	sec
    a6b4:	a1 1c       	adc	r10, r1
    a6b6:	b1 1c       	adc	r11, r1
    a6b8:	54 e4       	ldi	r21, 0x44	; 68
    a6ba:	65 2e       	mov	r6, r21
    a6bc:	5e e0       	ldi	r21, 0x0E	; 14
    a6be:	75 2e       	mov	r7, r21
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    a6c0:	4e e0       	ldi	r20, 0x0E	; 14
    a6c2:	84 2e       	mov	r8, r20
    a6c4:	91 2c       	mov	r9, r1
    a6c6:	8c 0e       	add	r8, r28
    a6c8:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    a6ca:	1e 2d       	mov	r17, r14
    a6cc:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    a6ce:	00 d0       	rcall	.+0      	; 0xa6d0 <FMenuPumpLabel+0xaa>
    a6d0:	00 d0       	rcall	.+0      	; 0xa6d2 <FMenuPumpLabel+0xac>
    a6d2:	00 d0       	rcall	.+0      	; 0xa6d4 <FMenuPumpLabel+0xae>
    a6d4:	ed b7       	in	r30, 0x3d	; 61
    a6d6:	fe b7       	in	r31, 0x3e	; 62
    a6d8:	31 96       	adiw	r30, 0x01	; 1
    a6da:	ad b7       	in	r26, 0x3d	; 61
    a6dc:	be b7       	in	r27, 0x3e	; 62
    a6de:	12 96       	adiw	r26, 0x02	; 2
    a6e0:	bc 92       	st	X, r11
    a6e2:	ae 92       	st	-X, r10
    a6e4:	11 97       	sbiw	r26, 0x01	; 1
    a6e6:	73 82       	std	Z+3, r7	; 0x03
    a6e8:	62 82       	std	Z+2, r6	; 0x02
    a6ea:	d7 01       	movw	r26, r14
    a6ec:	8d 91       	ld	r24, X+
    a6ee:	7d 01       	movw	r14, r26
    a6f0:	84 83       	std	Z+4, r24	; 0x04
    a6f2:	15 82       	std	Z+5, r1	; 0x05
    a6f4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    a6f8:	ed b7       	in	r30, 0x3d	; 61
    a6fa:	fe b7       	in	r31, 0x3e	; 62
    a6fc:	36 96       	adiw	r30, 0x06	; 6
    a6fe:	0f b6       	in	r0, 0x3f	; 63
    a700:	f8 94       	cli
    a702:	fe bf       	out	0x3e, r31	; 62
    a704:	0f be       	out	0x3f, r0	; 63
    a706:	ed bf       	out	0x3d, r30	; 61
    a708:	61 2f       	mov	r22, r17
    a70a:	66 95       	lsr	r22
    a70c:	66 95       	lsr	r22
    a70e:	66 0f       	add	r22, r22
    a710:	66 0f       	add	r22, r22
    a712:	66 0f       	add	r22, r22
    a714:	6b 5f       	subi	r22, 0xFB	; 251
    a716:	13 70       	andi	r17, 0x03	; 3
    a718:	81 2f       	mov	r24, r17
    a71a:	8f 5f       	subi	r24, 0xFF	; 255
    a71c:	a5 01       	movw	r20, r10
    a71e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    a722:	e8 14       	cp	r14, r8
    a724:	f9 04       	cpc	r15, r9
    a726:	89 f6       	brne	.-94     	; 0xa6ca <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    a728:	36 e0       	ldi	r19, 0x06	; 6
    a72a:	c3 2e       	mov	r12, r19
    a72c:	d1 2c       	mov	r13, r1
    a72e:	cc 0e       	add	r12, r28
    a730:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    a732:	7e 01       	movw	r14, r28
    a734:	08 94       	sec
    a736:	e1 1c       	adc	r14, r1
    a738:	f1 1c       	adc	r15, r1
    a73a:	2f e3       	ldi	r18, 0x3F	; 63
    a73c:	a2 2e       	mov	r10, r18
    a73e:	2e e0       	ldi	r18, 0x0E	; 14
    a740:	b2 2e       	mov	r11, r18
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    a742:	81 e0       	ldi	r24, 0x01	; 1
    a744:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    a748:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    a74a:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    a74e:	17 3e       	cpi	r17, 0xE7	; 231
    a750:	09 f4       	brne	.+2      	; 0xa754 <FMenuPumpLabel+0x12e>
    a752:	4b c0       	rjmp	.+150    	; 0xa7ea <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    a754:	17 3b       	cpi	r17, 0xB7	; 183
    a756:	61 f4       	brne	.+24     	; 0xa770 <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    a758:	8d e4       	ldi	r24, 0x4D	; 77
    a75a:	90 e0       	ldi	r25, 0x00	; 0
    a75c:	be 01       	movw	r22, r28
    a75e:	6a 5f       	subi	r22, 0xFA	; 250
    a760:	7f 4f       	sbci	r23, 0xFF	; 255
    a762:	48 e0       	ldi	r20, 0x08	; 8
    a764:	50 e0       	ldi	r21, 0x00	; 0
    a766:	2a ed       	ldi	r18, 0xDA	; 218
    a768:	33 e1       	ldi	r19, 0x13	; 19
    a76a:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
    a76e:	3d c0       	rjmp	.+122    	; 0xa7ea <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    a770:	18 2f       	mov	r17, r24
    a772:	11 53       	subi	r17, 0x31	; 49
    a774:	18 30       	cpi	r17, 0x08	; 8
    a776:	28 f7       	brcc	.-54     	; 0xa742 <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    a778:	a1 2f       	mov	r26, r17
    a77a:	b0 e0       	ldi	r27, 0x00	; 0
    a77c:	f6 01       	movw	r30, r12
    a77e:	ea 0f       	add	r30, r26
    a780:	fb 1f       	adc	r31, r27
    a782:	90 81       	ld	r25, Z
    a784:	80 91 56 01 	lds	r24, 0x0156
    a788:	98 17       	cp	r25, r24
    a78a:	11 f4       	brne	.+4      	; 0xa790 <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    a78c:	10 82       	st	Z, r1
    a78e:	02 c0       	rjmp	.+4      	; 0xa794 <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    a790:	9f 5f       	subi	r25, 0xFF	; 255
    a792:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    a794:	00 d0       	rcall	.+0      	; 0xa796 <FMenuPumpLabel+0x170>
    a796:	00 d0       	rcall	.+0      	; 0xa798 <FMenuPumpLabel+0x172>
    a798:	00 d0       	rcall	.+0      	; 0xa79a <FMenuPumpLabel+0x174>
    a79a:	2d b7       	in	r18, 0x3d	; 61
    a79c:	3e b7       	in	r19, 0x3e	; 62
    a79e:	2f 5f       	subi	r18, 0xFF	; 255
    a7a0:	3f 4f       	sbci	r19, 0xFF	; 255
    a7a2:	ed b7       	in	r30, 0x3d	; 61
    a7a4:	fe b7       	in	r31, 0x3e	; 62
    a7a6:	f2 82       	std	Z+2, r15	; 0x02
    a7a8:	e1 82       	std	Z+1, r14	; 0x01
    a7aa:	f9 01       	movw	r30, r18
    a7ac:	b3 82       	std	Z+3, r11	; 0x03
    a7ae:	a2 82       	std	Z+2, r10	; 0x02
    a7b0:	ac 0d       	add	r26, r12
    a7b2:	bd 1d       	adc	r27, r13
    a7b4:	8c 91       	ld	r24, X
    a7b6:	84 83       	std	Z+4, r24	; 0x04
    a7b8:	15 82       	std	Z+5, r1	; 0x05
    a7ba:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    a7be:	8d b7       	in	r24, 0x3d	; 61
    a7c0:	9e b7       	in	r25, 0x3e	; 62
    a7c2:	06 96       	adiw	r24, 0x06	; 6
    a7c4:	0f b6       	in	r0, 0x3f	; 63
    a7c6:	f8 94       	cli
    a7c8:	9e bf       	out	0x3e, r25	; 62
    a7ca:	0f be       	out	0x3f, r0	; 63
    a7cc:	8d bf       	out	0x3d, r24	; 61
    a7ce:	61 2f       	mov	r22, r17
    a7d0:	66 95       	lsr	r22
    a7d2:	66 95       	lsr	r22
    a7d4:	66 0f       	add	r22, r22
    a7d6:	66 0f       	add	r22, r22
    a7d8:	66 0f       	add	r22, r22
    a7da:	6b 5f       	subi	r22, 0xFB	; 251
    a7dc:	13 70       	andi	r17, 0x03	; 3
    a7de:	81 2f       	mov	r24, r17
    a7e0:	8f 5f       	subi	r24, 0xFF	; 255
    a7e2:	a7 01       	movw	r20, r14
    a7e4:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    a7e8:	ac cf       	rjmp	.-168    	; 0xa742 <FMenuPumpLabel+0x11c>
		}
	}
}
    a7ea:	2d 96       	adiw	r28, 0x0d	; 13
    a7ec:	0f b6       	in	r0, 0x3f	; 63
    a7ee:	f8 94       	cli
    a7f0:	de bf       	out	0x3e, r29	; 62
    a7f2:	0f be       	out	0x3f, r0	; 63
    a7f4:	cd bf       	out	0x3d, r28	; 61
    a7f6:	cf 91       	pop	r28
    a7f8:	df 91       	pop	r29
    a7fa:	1f 91       	pop	r17
    a7fc:	ff 90       	pop	r15
    a7fe:	ef 90       	pop	r14
    a800:	df 90       	pop	r13
    a802:	cf 90       	pop	r12
    a804:	bf 90       	pop	r11
    a806:	af 90       	pop	r10
    a808:	9f 90       	pop	r9
    a80a:	8f 90       	pop	r8
    a80c:	7f 90       	pop	r7
    a80e:	6f 90       	pop	r6
    a810:	08 95       	ret

0000a812 <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
    a812:	df 92       	push	r13
    a814:	ef 92       	push	r14
    a816:	ff 92       	push	r15
    a818:	0f 93       	push	r16
    a81a:	1f 93       	push	r17
    a81c:	df 93       	push	r29
    a81e:	cf 93       	push	r28
    a820:	cd b7       	in	r28, 0x3d	; 61
    a822:	de b7       	in	r29, 0x3e	; 62
    a824:	64 97       	sbiw	r28, 0x14	; 20
    a826:	0f b6       	in	r0, 0x3f	; 63
    a828:	f8 94       	cli
    a82a:	de bf       	out	0x3e, r29	; 62
    a82c:	0f be       	out	0x3f, r0	; 63
    a82e:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
    a830:	80 91 1f 02 	lds	r24, 0x021F
    a834:	82 30       	cpi	r24, 0x02	; 2
    a836:	09 f4       	brne	.+2      	; 0xa83a <FSettingDec+0x28>
    a838:	c7 c0       	rjmp	.+398    	; 0xa9c8 <FSettingDec+0x1b6>
    a83a:	83 30       	cpi	r24, 0x03	; 3
    a83c:	30 f4       	brcc	.+12     	; 0xa84a <FSettingDec+0x38>
    a83e:	88 23       	and	r24, r24
    a840:	71 f0       	breq	.+28     	; 0xa85e <FSettingDec+0x4c>
    a842:	81 30       	cpi	r24, 0x01	; 1
    a844:	09 f0       	breq	.+2      	; 0xa848 <FSettingDec+0x36>
    a846:	b9 c1       	rjmp	.+882    	; 0xabba <FSettingDec+0x3a8>
    a848:	92 c0       	rjmp	.+292    	; 0xa96e <FSettingDec+0x15c>
    a84a:	84 30       	cpi	r24, 0x04	; 4
    a84c:	09 f4       	brne	.+2      	; 0xa850 <FSettingDec+0x3e>
    a84e:	ad c1       	rjmp	.+858    	; 0xabaa <FSettingDec+0x398>
    a850:	84 30       	cpi	r24, 0x04	; 4
    a852:	08 f4       	brcc	.+2      	; 0xa856 <FSettingDec+0x44>
    a854:	68 c1       	rjmp	.+720    	; 0xab26 <FSettingDec+0x314>
    a856:	85 30       	cpi	r24, 0x05	; 5
    a858:	09 f0       	breq	.+2      	; 0xa85c <FSettingDec+0x4a>
    a85a:	af c1       	rjmp	.+862    	; 0xabba <FSettingDec+0x3a8>
    a85c:	aa c1       	rjmp	.+852    	; 0xabb2 <FSettingDec+0x3a0>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
    a85e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a862:	e1 99       	sbic	0x1c, 1	; 28
    a864:	fe cf       	rjmp	.-4      	; 0xa862 <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a866:	89 e3       	ldi	r24, 0x39	; 57
    a868:	90 e0       	ldi	r25, 0x00	; 0
    a86a:	9f bb       	out	0x1f, r25	; 31
    a86c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a86e:	e0 9a       	sbi	0x1c, 0	; 28
    a870:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a872:	e1 99       	sbic	0x1c, 1	; 28
    a874:	fe cf       	rjmp	.-4      	; 0xa872 <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a876:	8a e3       	ldi	r24, 0x3A	; 58
    a878:	90 e0       	ldi	r25, 0x00	; 0
    a87a:	9f bb       	out	0x1f, r25	; 31
    a87c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a87e:	e0 9a       	sbi	0x1c, 0	; 28
    a880:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a882:	e1 99       	sbic	0x1c, 1	; 28
    a884:	fe cf       	rjmp	.-4      	; 0xa882 <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a886:	8b e3       	ldi	r24, 0x3B	; 59
    a888:	90 e0       	ldi	r25, 0x00	; 0
    a88a:	9f bb       	out	0x1f, r25	; 31
    a88c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a88e:	e0 9a       	sbi	0x1c, 0	; 28
    a890:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
    a892:	00 d0       	rcall	.+0      	; 0xa894 <FSettingDec+0x82>
    a894:	00 d0       	rcall	.+0      	; 0xa896 <FSettingDec+0x84>
    a896:	00 d0       	rcall	.+0      	; 0xa898 <FSettingDec+0x86>
    a898:	ed b7       	in	r30, 0x3d	; 61
    a89a:	fe b7       	in	r31, 0x3e	; 62
    a89c:	31 96       	adiw	r30, 0x01	; 1
    a89e:	8e 01       	movw	r16, r28
    a8a0:	0f 5f       	subi	r16, 0xFF	; 255
    a8a2:	1f 4f       	sbci	r17, 0xFF	; 255
    a8a4:	ad b7       	in	r26, 0x3d	; 61
    a8a6:	be b7       	in	r27, 0x3e	; 62
    a8a8:	12 96       	adiw	r26, 0x02	; 2
    a8aa:	1c 93       	st	X, r17
    a8ac:	0e 93       	st	-X, r16
    a8ae:	11 97       	sbiw	r26, 0x01	; 1
    a8b0:	84 ef       	ldi	r24, 0xF4	; 244
    a8b2:	92 e1       	ldi	r25, 0x12	; 18
    a8b4:	93 83       	std	Z+3, r25	; 0x03
    a8b6:	82 83       	std	Z+2, r24	; 0x02
    a8b8:	24 83       	std	Z+4, r18	; 0x04
    a8ba:	15 82       	std	Z+5, r1	; 0x05
    a8bc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(1,1,lcdteks);
    a8c0:	8d b7       	in	r24, 0x3d	; 61
    a8c2:	9e b7       	in	r25, 0x3e	; 62
    a8c4:	06 96       	adiw	r24, 0x06	; 6
    a8c6:	0f b6       	in	r0, 0x3f	; 63
    a8c8:	f8 94       	cli
    a8ca:	9e bf       	out	0x3e, r25	; 62
    a8cc:	0f be       	out	0x3f, r0	; 63
    a8ce:	8d bf       	out	0x3d, r24	; 61
    a8d0:	81 e0       	ldi	r24, 0x01	; 1
    a8d2:	61 e0       	ldi	r22, 0x01	; 1
    a8d4:	a8 01       	movw	r20, r16
    a8d6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
    a8da:	00 d0       	rcall	.+0      	; 0xa8dc <FSettingDec+0xca>
    a8dc:	00 d0       	rcall	.+0      	; 0xa8de <FSettingDec+0xcc>
    a8de:	00 d0       	rcall	.+0      	; 0xa8e0 <FSettingDec+0xce>
    a8e0:	ed b7       	in	r30, 0x3d	; 61
    a8e2:	fe b7       	in	r31, 0x3e	; 62
    a8e4:	31 96       	adiw	r30, 0x01	; 1
    a8e6:	ad b7       	in	r26, 0x3d	; 61
    a8e8:	be b7       	in	r27, 0x3e	; 62
    a8ea:	12 96       	adiw	r26, 0x02	; 2
    a8ec:	1c 93       	st	X, r17
    a8ee:	0e 93       	st	-X, r16
    a8f0:	11 97       	sbiw	r26, 0x01	; 1
    a8f2:	88 ee       	ldi	r24, 0xE8	; 232
    a8f4:	92 e1       	ldi	r25, 0x12	; 18
    a8f6:	93 83       	std	Z+3, r25	; 0x03
    a8f8:	82 83       	std	Z+2, r24	; 0x02
    a8fa:	e4 82       	std	Z+4, r14	; 0x04
    a8fc:	15 82       	std	Z+5, r1	; 0x05
    a8fe:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(2,1,lcdteks);
    a902:	8d b7       	in	r24, 0x3d	; 61
    a904:	9e b7       	in	r25, 0x3e	; 62
    a906:	06 96       	adiw	r24, 0x06	; 6
    a908:	0f b6       	in	r0, 0x3f	; 63
    a90a:	f8 94       	cli
    a90c:	9e bf       	out	0x3e, r25	; 62
    a90e:	0f be       	out	0x3f, r0	; 63
    a910:	8d bf       	out	0x3d, r24	; 61
    a912:	82 e0       	ldi	r24, 0x02	; 2
    a914:	61 e0       	ldi	r22, 0x01	; 1
    a916:	a8 01       	movw	r20, r16
    a918:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
    a91c:	00 d0       	rcall	.+0      	; 0xa91e <FSettingDec+0x10c>
    a91e:	00 d0       	rcall	.+0      	; 0xa920 <FSettingDec+0x10e>
    a920:	00 d0       	rcall	.+0      	; 0xa922 <FSettingDec+0x110>
    a922:	ed b7       	in	r30, 0x3d	; 61
    a924:	fe b7       	in	r31, 0x3e	; 62
    a926:	31 96       	adiw	r30, 0x01	; 1
    a928:	ad b7       	in	r26, 0x3d	; 61
    a92a:	be b7       	in	r27, 0x3e	; 62
    a92c:	12 96       	adiw	r26, 0x02	; 2
    a92e:	1c 93       	st	X, r17
    a930:	0e 93       	st	-X, r16
    a932:	11 97       	sbiw	r26, 0x01	; 1
    a934:	8c ed       	ldi	r24, 0xDC	; 220
    a936:	92 e1       	ldi	r25, 0x12	; 18
    a938:	93 83       	std	Z+3, r25	; 0x03
    a93a:	82 83       	std	Z+2, r24	; 0x02
    a93c:	f4 82       	std	Z+4, r15	; 0x04
    a93e:	15 82       	std	Z+5, r1	; 0x05
    a940:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(3,1,lcdteks);
    a944:	8d b7       	in	r24, 0x3d	; 61
    a946:	9e b7       	in	r25, 0x3e	; 62
    a948:	06 96       	adiw	r24, 0x06	; 6
    a94a:	0f b6       	in	r0, 0x3f	; 63
    a94c:	f8 94       	cli
    a94e:	9e bf       	out	0x3e, r25	; 62
    a950:	0f be       	out	0x3f, r0	; 63
    a952:	8d bf       	out	0x3d, r24	; 61
    a954:	83 e0       	ldi	r24, 0x03	; 3
    a956:	61 e0       	ldi	r22, 0x01	; 1
    a958:	a8 01       	movw	r20, r16
    a95a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
    a95e:	84 e0       	ldi	r24, 0x04	; 4
    a960:	61 e0       	ldi	r22, 0x01	; 1
    a962:	4b ec       	ldi	r20, 0xCB	; 203
    a964:	52 e1       	ldi	r21, 0x12	; 18
    a966:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
    a96a:	81 e0       	ldi	r24, 0x01	; 1
    a96c:	1f c1       	rjmp	.+574    	; 0xabac <FSettingDec+0x39a>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
    a96e:	81 e0       	ldi	r24, 0x01	; 1
    a970:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    a974:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
    a978:	98 2f       	mov	r25, r24
    a97a:	91 53       	subi	r25, 0x31	; 49
    a97c:	93 30       	cpi	r25, 0x03	; 3
    a97e:	e0 f4       	brcc	.+56     	; 0xa9b8 <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
    a980:	29 2f       	mov	r18, r25
    a982:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a984:	e1 99       	sbic	0x1c, 1	; 28
    a986:	fe cf       	rjmp	.-4      	; 0xa984 <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a988:	c9 01       	movw	r24, r18
    a98a:	87 5c       	subi	r24, 0xC7	; 199
    a98c:	9f 4f       	sbci	r25, 0xFF	; 255
    a98e:	9f bb       	out	0x1f, r25	; 31
    a990:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a992:	e0 9a       	sbi	0x1c, 0	; 28
    a994:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a996:	e1 99       	sbic	0x1c, 1	; 28
    a998:	fe cf       	rjmp	.-4      	; 0xa996 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a99a:	27 5c       	subi	r18, 0xC7	; 199
    a99c:	3f 4f       	sbci	r19, 0xFF	; 255
    a99e:	3f bb       	out	0x1f, r19	; 31
    a9a0:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
    a9a2:	90 e0       	ldi	r25, 0x00	; 0
    a9a4:	01 96       	adiw	r24, 0x01	; 1
    a9a6:	83 70       	andi	r24, 0x03	; 3
    a9a8:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
    a9aa:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    a9ac:	0f b6       	in	r0, 0x3f	; 63
    a9ae:	f8 94       	cli
    a9b0:	e2 9a       	sbi	0x1c, 2	; 28
    a9b2:	e1 9a       	sbi	0x1c, 1	; 28
    a9b4:	0f be       	out	0x3f, r0	; 63
    a9b6:	f6 c0       	rjmp	.+492    	; 0xaba4 <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
    a9b8:	8a 32       	cpi	r24, 0x2A	; 42
    a9ba:	11 f4       	brne	.+4      	; 0xa9c0 <FSettingDec+0x1ae>
    a9bc:	85 e0       	ldi	r24, 0x05	; 5
    a9be:	f6 c0       	rjmp	.+492    	; 0xabac <FSettingDec+0x39a>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
    a9c0:	83 32       	cpi	r24, 0x23	; 35
    a9c2:	09 f0       	breq	.+2      	; 0xa9c6 <FSettingDec+0x1b4>
    a9c4:	fa c0       	rjmp	.+500    	; 0xabba <FSettingDec+0x3a8>
    a9c6:	f1 c0       	rjmp	.+482    	; 0xabaa <FSettingDec+0x398>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a9c8:	e1 99       	sbic	0x1c, 1	; 28
    a9ca:	fe cf       	rjmp	.-4      	; 0xa9c8 <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a9cc:	8c e3       	ldi	r24, 0x3C	; 60
    a9ce:	90 e0       	ldi	r25, 0x00	; 0
    a9d0:	9f bb       	out	0x1f, r25	; 31
    a9d2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a9d4:	e0 9a       	sbi	0x1c, 0	; 28
    a9d6:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a9d8:	e1 99       	sbic	0x1c, 1	; 28
    a9da:	fe cf       	rjmp	.-4      	; 0xa9d8 <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a9dc:	8d e3       	ldi	r24, 0x3D	; 61
    a9de:	90 e0       	ldi	r25, 0x00	; 0
    a9e0:	9f bb       	out	0x1f, r25	; 31
    a9e2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a9e4:	e0 9a       	sbi	0x1c, 0	; 28
    a9e6:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a9e8:	e1 99       	sbic	0x1c, 1	; 28
    a9ea:	fe cf       	rjmp	.-4      	; 0xa9e8 <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a9ec:	8e e3       	ldi	r24, 0x3E	; 62
    a9ee:	90 e0       	ldi	r25, 0x00	; 0
    a9f0:	9f bb       	out	0x1f, r25	; 31
    a9f2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a9f4:	e0 9a       	sbi	0x1c, 0	; 28
    a9f6:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a9f8:	e1 99       	sbic	0x1c, 1	; 28
    a9fa:	fe cf       	rjmp	.-4      	; 0xa9f8 <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a9fc:	8f e3       	ldi	r24, 0x3F	; 63
    a9fe:	90 e0       	ldi	r25, 0x00	; 0
    aa00:	9f bb       	out	0x1f, r25	; 31
    aa02:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    aa04:	e0 9a       	sbi	0x1c, 0	; 28
    aa06:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d "),PDecimalConfig[0]);
    aa08:	00 d0       	rcall	.+0      	; 0xaa0a <FSettingDec+0x1f8>
    aa0a:	00 d0       	rcall	.+0      	; 0xaa0c <FSettingDec+0x1fa>
    aa0c:	00 d0       	rcall	.+0      	; 0xaa0e <FSettingDec+0x1fc>
    aa0e:	ed b7       	in	r30, 0x3d	; 61
    aa10:	fe b7       	in	r31, 0x3e	; 62
    aa12:	31 96       	adiw	r30, 0x01	; 1
    aa14:	8e 01       	movw	r16, r28
    aa16:	0f 5f       	subi	r16, 0xFF	; 255
    aa18:	1f 4f       	sbci	r17, 0xFF	; 255
    aa1a:	ad b7       	in	r26, 0x3d	; 61
    aa1c:	be b7       	in	r27, 0x3e	; 62
    aa1e:	12 96       	adiw	r26, 0x02	; 2
    aa20:	1c 93       	st	X, r17
    aa22:	0e 93       	st	-X, r16
    aa24:	11 97       	sbiw	r26, 0x01	; 1
    aa26:	8c eb       	ldi	r24, 0xBC	; 188
    aa28:	92 e1       	ldi	r25, 0x12	; 18
    aa2a:	93 83       	std	Z+3, r25	; 0x03
    aa2c:	82 83       	std	Z+2, r24	; 0x02
    aa2e:	24 83       	std	Z+4, r18	; 0x04
    aa30:	15 82       	std	Z+5, r1	; 0x05
    aa32:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(1,1,lcdteks);
    aa36:	8d b7       	in	r24, 0x3d	; 61
    aa38:	9e b7       	in	r25, 0x3e	; 62
    aa3a:	06 96       	adiw	r24, 0x06	; 6
    aa3c:	0f b6       	in	r0, 0x3f	; 63
    aa3e:	f8 94       	cli
    aa40:	9e bf       	out	0x3e, r25	; 62
    aa42:	0f be       	out	0x3f, r0	; 63
    aa44:	8d bf       	out	0x3d, r24	; 61
    aa46:	81 e0       	ldi	r24, 0x01	; 1
    aa48:	61 e0       	ldi	r22, 0x01	; 1
    aa4a:	a8 01       	movw	r20, r16
    aa4c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
    aa50:	00 d0       	rcall	.+0      	; 0xaa52 <FSettingDec+0x240>
    aa52:	00 d0       	rcall	.+0      	; 0xaa54 <FSettingDec+0x242>
    aa54:	00 d0       	rcall	.+0      	; 0xaa56 <FSettingDec+0x244>
    aa56:	ed b7       	in	r30, 0x3d	; 61
    aa58:	fe b7       	in	r31, 0x3e	; 62
    aa5a:	31 96       	adiw	r30, 0x01	; 1
    aa5c:	ad b7       	in	r26, 0x3d	; 61
    aa5e:	be b7       	in	r27, 0x3e	; 62
    aa60:	12 96       	adiw	r26, 0x02	; 2
    aa62:	1c 93       	st	X, r17
    aa64:	0e 93       	st	-X, r16
    aa66:	11 97       	sbiw	r26, 0x01	; 1
    aa68:	8d ea       	ldi	r24, 0xAD	; 173
    aa6a:	92 e1       	ldi	r25, 0x12	; 18
    aa6c:	93 83       	std	Z+3, r25	; 0x03
    aa6e:	82 83       	std	Z+2, r24	; 0x02
    aa70:	e4 82       	std	Z+4, r14	; 0x04
    aa72:	15 82       	std	Z+5, r1	; 0x05
    aa74:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(2,1,lcdteks);
    aa78:	8d b7       	in	r24, 0x3d	; 61
    aa7a:	9e b7       	in	r25, 0x3e	; 62
    aa7c:	06 96       	adiw	r24, 0x06	; 6
    aa7e:	0f b6       	in	r0, 0x3f	; 63
    aa80:	f8 94       	cli
    aa82:	9e bf       	out	0x3e, r25	; 62
    aa84:	0f be       	out	0x3f, r0	; 63
    aa86:	8d bf       	out	0x3d, r24	; 61
    aa88:	82 e0       	ldi	r24, 0x02	; 2
    aa8a:	61 e0       	ldi	r22, 0x01	; 1
    aa8c:	a8 01       	movw	r20, r16
    aa8e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
    aa92:	00 d0       	rcall	.+0      	; 0xaa94 <FSettingDec+0x282>
    aa94:	00 d0       	rcall	.+0      	; 0xaa96 <FSettingDec+0x284>
    aa96:	00 d0       	rcall	.+0      	; 0xaa98 <FSettingDec+0x286>
    aa98:	ed b7       	in	r30, 0x3d	; 61
    aa9a:	fe b7       	in	r31, 0x3e	; 62
    aa9c:	31 96       	adiw	r30, 0x01	; 1
    aa9e:	ad b7       	in	r26, 0x3d	; 61
    aaa0:	be b7       	in	r27, 0x3e	; 62
    aaa2:	12 96       	adiw	r26, 0x02	; 2
    aaa4:	1c 93       	st	X, r17
    aaa6:	0e 93       	st	-X, r16
    aaa8:	11 97       	sbiw	r26, 0x01	; 1
    aaaa:	8e e9       	ldi	r24, 0x9E	; 158
    aaac:	92 e1       	ldi	r25, 0x12	; 18
    aaae:	93 83       	std	Z+3, r25	; 0x03
    aab0:	82 83       	std	Z+2, r24	; 0x02
    aab2:	d4 82       	std	Z+4, r13	; 0x04
    aab4:	15 82       	std	Z+5, r1	; 0x05
    aab6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(3,1,lcdteks);
    aaba:	8d b7       	in	r24, 0x3d	; 61
    aabc:	9e b7       	in	r25, 0x3e	; 62
    aabe:	06 96       	adiw	r24, 0x06	; 6
    aac0:	0f b6       	in	r0, 0x3f	; 63
    aac2:	f8 94       	cli
    aac4:	9e bf       	out	0x3e, r25	; 62
    aac6:	0f be       	out	0x3f, r0	; 63
    aac8:	8d bf       	out	0x3d, r24	; 61
    aaca:	83 e0       	ldi	r24, 0x03	; 3
    aacc:	61 e0       	ldi	r22, 0x01	; 1
    aace:	a8 01       	movw	r20, r16
    aad0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
    aad4:	00 d0       	rcall	.+0      	; 0xaad6 <FSettingDec+0x2c4>
    aad6:	00 d0       	rcall	.+0      	; 0xaad8 <FSettingDec+0x2c6>
    aad8:	00 d0       	rcall	.+0      	; 0xaada <FSettingDec+0x2c8>
    aada:	ed b7       	in	r30, 0x3d	; 61
    aadc:	fe b7       	in	r31, 0x3e	; 62
    aade:	31 96       	adiw	r30, 0x01	; 1
    aae0:	ad b7       	in	r26, 0x3d	; 61
    aae2:	be b7       	in	r27, 0x3e	; 62
    aae4:	12 96       	adiw	r26, 0x02	; 2
    aae6:	1c 93       	st	X, r17
    aae8:	0e 93       	st	-X, r16
    aaea:	11 97       	sbiw	r26, 0x01	; 1
    aaec:	8f e8       	ldi	r24, 0x8F	; 143
    aaee:	92 e1       	ldi	r25, 0x12	; 18
    aaf0:	93 83       	std	Z+3, r25	; 0x03
    aaf2:	82 83       	std	Z+2, r24	; 0x02
    aaf4:	f4 82       	std	Z+4, r15	; 0x04
    aaf6:	15 82       	std	Z+5, r1	; 0x05
    aaf8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(4,1,lcdteks);
    aafc:	8d b7       	in	r24, 0x3d	; 61
    aafe:	9e b7       	in	r25, 0x3e	; 62
    ab00:	06 96       	adiw	r24, 0x06	; 6
    ab02:	0f b6       	in	r0, 0x3f	; 63
    ab04:	f8 94       	cli
    ab06:	9e bf       	out	0x3e, r25	; 62
    ab08:	0f be       	out	0x3f, r0	; 63
    ab0a:	8d bf       	out	0x3d, r24	; 61
    ab0c:	84 e0       	ldi	r24, 0x04	; 4
    ab0e:	61 e0       	ldi	r22, 0x01	; 1
    ab10:	a8 01       	movw	r20, r16
    ab12:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
    ab16:	84 e0       	ldi	r24, 0x04	; 4
    ab18:	6e e0       	ldi	r22, 0x0E	; 14
    ab1a:	48 e8       	ldi	r20, 0x88	; 136
    ab1c:	52 e1       	ldi	r21, 0x12	; 18
    ab1e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
    ab22:	83 e0       	ldi	r24, 0x03	; 3
    ab24:	43 c0       	rjmp	.+134    	; 0xabac <FSettingDec+0x39a>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
    ab26:	81 e0       	ldi	r24, 0x01	; 1
    ab28:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    ab2c:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    ab30:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    ab32:	98 2f       	mov	r25, r24
    ab34:	91 53       	subi	r25, 0x31	; 49
    ab36:	92 30       	cpi	r25, 0x02	; 2
    ab38:	b0 f4       	brcc	.+44     	; 0xab66 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
    ab3a:	29 2f       	mov	r18, r25
    ab3c:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ab3e:	e1 99       	sbic	0x1c, 1	; 28
    ab40:	fe cf       	rjmp	.-4      	; 0xab3e <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ab42:	c9 01       	movw	r24, r18
    ab44:	84 5c       	subi	r24, 0xC4	; 196
    ab46:	9f 4f       	sbci	r25, 0xFF	; 255
    ab48:	9f bb       	out	0x1f, r25	; 31
    ab4a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ab4c:	e0 9a       	sbi	0x1c, 0	; 28
    ab4e:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ab50:	e1 99       	sbic	0x1c, 1	; 28
    ab52:	fe cf       	rjmp	.-4      	; 0xab50 <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ab54:	24 5c       	subi	r18, 0xC4	; 196
    ab56:	3f 4f       	sbci	r19, 0xFF	; 255
    ab58:	3f bb       	out	0x1f, r19	; 31
    ab5a:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
    ab5c:	90 e0       	ldi	r25, 0x00	; 0
    ab5e:	01 96       	adiw	r24, 0x01	; 1
    ab60:	83 70       	andi	r24, 0x03	; 3
    ab62:	90 70       	andi	r25, 0x00	; 0
    ab64:	16 c0       	rjmp	.+44     	; 0xab92 <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
    ab66:	83 53       	subi	r24, 0x33	; 51
    ab68:	82 30       	cpi	r24, 0x02	; 2
    ab6a:	d0 f4       	brcc	.+52     	; 0xaba0 <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
    ab6c:	09 2f       	mov	r16, r25
    ab6e:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ab70:	e1 99       	sbic	0x1c, 1	; 28
    ab72:	fe cf       	rjmp	.-4      	; 0xab70 <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ab74:	c8 01       	movw	r24, r16
    ab76:	84 5c       	subi	r24, 0xC4	; 196
    ab78:	9f 4f       	sbci	r25, 0xFF	; 255
    ab7a:	9f bb       	out	0x1f, r25	; 31
    ab7c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ab7e:	e0 9a       	sbi	0x1c, 0	; 28
    ab80:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
    ab82:	0e 94 a3 22 	call	0x4546	; 0x4546 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ab86:	e1 99       	sbic	0x1c, 1	; 28
    ab88:	fe cf       	rjmp	.-4      	; 0xab86 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ab8a:	04 5c       	subi	r16, 0xC4	; 196
    ab8c:	1f 4f       	sbci	r17, 0xFF	; 255
    ab8e:	1f bb       	out	0x1f, r17	; 31
    ab90:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    ab92:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    ab94:	0f b6       	in	r0, 0x3f	; 63
    ab96:	f8 94       	cli
    ab98:	e2 9a       	sbi	0x1c, 2	; 28
    ab9a:	e1 9a       	sbi	0x1c, 1	; 28
    ab9c:	0f be       	out	0x3f, r0	; 63
    ab9e:	05 c0       	rjmp	.+10     	; 0xabaa <FSettingDec+0x398>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
    aba0:	2a 32       	cpi	r18, 0x2A	; 42
    aba2:	59 f4       	brne	.+22     	; 0xabba <FSettingDec+0x3a8>
    aba4:	10 92 1f 02 	sts	0x021F, r1
    aba8:	08 c0       	rjmp	.+16     	; 0xabba <FSettingDec+0x3a8>
		          stSettingDecimal=sdTestInput;
				  }*/
          break;
     case sdTestInput:
	      //if (TestUserInput()==MENU_DONE)
		  stSettingDecimal=sdInitDisplay2;
    abaa:	82 e0       	ldi	r24, 0x02	; 2
    abac:	80 93 1f 02 	sts	0x021F, r24
    abb0:	04 c0       	rjmp	.+8      	; 0xabba <FSettingDec+0x3a8>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
    abb2:	10 92 1f 02 	sts	0x021F, r1
    abb6:	81 e0       	ldi	r24, 0x01	; 1
    abb8:	01 c0       	rjmp	.+2      	; 0xabbc <FSettingDec+0x3aa>
    abba:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
    abbc:	64 96       	adiw	r28, 0x14	; 20
    abbe:	0f b6       	in	r0, 0x3f	; 63
    abc0:	f8 94       	cli
    abc2:	de bf       	out	0x3e, r29	; 62
    abc4:	0f be       	out	0x3f, r0	; 63
    abc6:	cd bf       	out	0x3d, r28	; 61
    abc8:	cf 91       	pop	r28
    abca:	df 91       	pop	r29
    abcc:	1f 91       	pop	r17
    abce:	0f 91       	pop	r16
    abd0:	ff 90       	pop	r15
    abd2:	ef 90       	pop	r14
    abd4:	df 90       	pop	r13
    abd6:	08 95       	ret

0000abd8 <FMenuShift>:
static char stMenuShift=msInitMenuShift;
     char SubMenu,KeyChar,KeyPressed;
     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    abd8:	80 91 4a 02 	lds	r24, 0x024A
    abdc:	82 30       	cpi	r24, 0x02	; 2
    abde:	09 f4       	brne	.+2      	; 0xabe2 <FMenuShift+0xa>
    abe0:	48 c0       	rjmp	.+144    	; 0xac72 <FMenuShift+0x9a>
    abe2:	83 30       	cpi	r24, 0x03	; 3
    abe4:	30 f4       	brcc	.+12     	; 0xabf2 <FMenuShift+0x1a>
    abe6:	88 23       	and	r24, r24
    abe8:	69 f0       	breq	.+26     	; 0xac04 <FMenuShift+0x2c>
    abea:	81 30       	cpi	r24, 0x01	; 1
    abec:	09 f0       	breq	.+2      	; 0xabf0 <FMenuShift+0x18>
    abee:	50 c0       	rjmp	.+160    	; 0xac90 <FMenuShift+0xb8>
    abf0:	25 c0       	rjmp	.+74     	; 0xac3c <FMenuShift+0x64>
    abf2:	84 30       	cpi	r24, 0x04	; 4
    abf4:	09 f4       	brne	.+2      	; 0xabf8 <FMenuShift+0x20>
    abf6:	4c c0       	rjmp	.+152    	; 0xac90 <FMenuShift+0xb8>
    abf8:	84 30       	cpi	r24, 0x04	; 4
    abfa:	e8 f1       	brcs	.+122    	; 0xac76 <FMenuShift+0x9e>
    abfc:	85 30       	cpi	r24, 0x05	; 5
    abfe:	09 f0       	breq	.+2      	; 0xac02 <FMenuShift+0x2a>
    ac00:	47 c0       	rjmp	.+142    	; 0xac90 <FMenuShift+0xb8>
    ac02:	42 c0       	rjmp	.+132    	; 0xac88 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    ac04:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    ac08:	81 e0       	ldi	r24, 0x01	; 1
    ac0a:	61 e0       	ldi	r22, 0x01	; 1
    ac0c:	45 e6       	ldi	r20, 0x65	; 101
    ac0e:	57 e1       	ldi	r21, 0x17	; 23
    ac10:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    ac14:	82 e0       	ldi	r24, 0x02	; 2
    ac16:	61 e0       	ldi	r22, 0x01	; 1
    ac18:	47 e5       	ldi	r20, 0x57	; 87
    ac1a:	57 e1       	ldi	r21, 0x17	; 23
    ac1c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    ac20:	83 e0       	ldi	r24, 0x03	; 3
    ac22:	61 e0       	ldi	r22, 0x01	; 1
    ac24:	49 e4       	ldi	r20, 0x49	; 73
    ac26:	57 e1       	ldi	r21, 0x17	; 23
    ac28:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    ac2c:	84 e0       	ldi	r24, 0x04	; 4
    ac2e:	61 e0       	ldi	r22, 0x01	; 1
    ac30:	42 e4       	ldi	r20, 0x42	; 66
    ac32:	57 e1       	ldi	r21, 0x17	; 23
    ac34:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stMenuShift=msSelectShift;
    ac38:	81 e0       	ldi	r24, 0x01	; 1
    ac3a:	18 c0       	rjmp	.+48     	; 0xac6c <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    ac3c:	81 e0       	ldi	r24, 0x01	; 1
    ac3e:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    ac42:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
          switch(KeyChar){
    ac46:	82 33       	cpi	r24, 0x32	; 50
    ac48:	61 f0       	breq	.+24     	; 0xac62 <FMenuShift+0x8a>
    ac4a:	83 33       	cpi	r24, 0x33	; 51
    ac4c:	28 f4       	brcc	.+10     	; 0xac58 <FMenuShift+0x80>
    ac4e:	8a 32       	cpi	r24, 0x2A	; 42
    ac50:	61 f0       	breq	.+24     	; 0xac6a <FMenuShift+0x92>
    ac52:	81 33       	cpi	r24, 0x31	; 49
    ac54:	e9 f4       	brne	.+58     	; 0xac90 <FMenuShift+0xb8>
    ac56:	03 c0       	rjmp	.+6      	; 0xac5e <FMenuShift+0x86>
    ac58:	83 33       	cpi	r24, 0x33	; 51
    ac5a:	d1 f4       	brne	.+52     	; 0xac90 <FMenuShift+0xb8>
    ac5c:	04 c0       	rjmp	.+8      	; 0xac66 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    ac5e:	82 e0       	ldi	r24, 0x02	; 2
    ac60:	05 c0       	rjmp	.+10     	; 0xac6c <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    ac62:	83 e0       	ldi	r24, 0x03	; 3
    ac64:	03 c0       	rjmp	.+6      	; 0xac6c <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    ac66:	84 e0       	ldi	r24, 0x04	; 4
    ac68:	01 c0       	rjmp	.+2      	; 0xac6c <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    ac6a:	85 e0       	ldi	r24, 0x05	; 5
    ac6c:	80 93 4a 02 	sts	0x024A, r24
    ac70:	09 c0       	rjmp	.+18     	; 0xac84 <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    ac72:	82 e0       	ldi	r24, 0x02	; 2
    ac74:	01 c0       	rjmp	.+2      	; 0xac78 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    ac76:	81 e0       	ldi	r24, 0x01	; 1
    ac78:	0e 94 1d 4c 	call	0x983a	; 0x983a <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    ac7c:	81 30       	cpi	r24, 0x01	; 1
    ac7e:	41 f4       	brne	.+16     	; 0xac90 <FMenuShift+0xb8>
    ac80:	10 92 4a 02 	sts	0x024A, r1
    ac84:	80 e0       	ldi	r24, 0x00	; 0
    ac86:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    ac88:	10 92 4a 02 	sts	0x024A, r1
    ac8c:	81 e0       	ldi	r24, 0x01	; 1
    ac8e:	08 95       	ret
    ac90:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    ac92:	08 95       	ret

0000ac94 <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    ac94:	84 e0       	ldi	r24, 0x04	; 4
    ac96:	61 e0       	ldi	r22, 0x01	; 1
    ac98:	49 e9       	ldi	r20, 0x99	; 153
    ac9a:	53 e2       	ldi	r21, 0x23	; 35
    ac9c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    aca0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    aca2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    aca4:	85 e0       	ldi	r24, 0x05	; 5
    aca6:	80 93 bc 01 	sts	0x01BC, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    acaa:	81 e0       	ldi	r24, 0x01	; 1
    acac:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		__num = _key_btn(__key);
    acb0:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    acb4:	80 53       	subi	r24, 0x30	; 48
    acb6:	8a 30       	cpi	r24, 0x0A	; 10
    acb8:	20 f0       	brcs	.+8      	; 0xacc2 <system_stop+0x2e>
    acba:	80 91 9c 01 	lds	r24, 0x019C
    acbe:	81 30       	cpi	r24, 0x01	; 1
    acc0:	a1 f7       	brne	.-24     	; 0xacaa <system_stop+0x16>
    acc2:	08 95       	ret

0000acc4 <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    acc4:	84 e0       	ldi	r24, 0x04	; 4
    acc6:	61 e0       	ldi	r22, 0x01	; 1
    acc8:	4e ea       	ldi	r20, 0xAE	; 174
    acca:	53 e2       	ldi	r21, 0x23	; 35
    accc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    acd0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    acd2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    acd4:	81 e0       	ldi	r24, 0x01	; 1
    acd6:	80 93 bc 01 	sts	0x01BC, r24
    acda:	80 ed       	ldi	r24, 0xD0	; 208
    acdc:	97 e0       	ldi	r25, 0x07	; 7
    acde:	20 e7       	ldi	r18, 0x70	; 112
    ace0:	31 e0       	ldi	r19, 0x01	; 1
    ace2:	f9 01       	movw	r30, r18
    ace4:	31 97       	sbiw	r30, 0x01	; 1
    ace6:	f1 f7       	brne	.-4      	; 0xace4 <systemForceType+0x20>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ace8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    acea:	d9 f7       	brne	.-10     	; 0xace2 <systemForceType+0x1e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    acec:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    acee:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    acf0:	82 e0       	ldi	r24, 0x02	; 2
    acf2:	80 93 bc 01 	sts	0x01BC, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    acf6:	81 e0       	ldi	r24, 0x01	; 1
    acf8:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    acfc:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    ad00:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    ad02:	81 53       	subi	r24, 0x31	; 49
    ad04:	82 30       	cpi	r24, 0x02	; 2
    ad06:	b8 f7       	brcc	.-18     	; 0xacf6 <systemForceType+0x32>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    ad08:	89 2f       	mov	r24, r25
    ad0a:	08 95       	ret

0000ad0c <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    ad0c:	8f 92       	push	r8
    ad0e:	9f 92       	push	r9
    ad10:	af 92       	push	r10
    ad12:	bf 92       	push	r11
    ad14:	cf 92       	push	r12
    ad16:	df 92       	push	r13
    ad18:	ef 92       	push	r14
    ad1a:	ff 92       	push	r15
    ad1c:	0f 93       	push	r16
    ad1e:	1f 93       	push	r17
    ad20:	df 93       	push	r29
    ad22:	cf 93       	push	r28
    ad24:	cd b7       	in	r28, 0x3d	; 61
    ad26:	de b7       	in	r29, 0x3e	; 62
    ad28:	c2 54       	subi	r28, 0x42	; 66
    ad2a:	d0 40       	sbci	r29, 0x00	; 0
    ad2c:	0f b6       	in	r0, 0x3f	; 63
    ad2e:	f8 94       	cli
    ad30:	de bf       	out	0x3e, r29	; 62
    ad32:	0f be       	out	0x3f, r0	; 63
    ad34:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    ad36:	de 01       	movw	r26, r28
    ad38:	53 96       	adiw	r26, 0x13	; 19
    ad3a:	e6 e2       	ldi	r30, 0x26	; 38
    ad3c:	f1 e0       	ldi	r31, 0x01	; 1
    ad3e:	80 e3       	ldi	r24, 0x30	; 48
    ad40:	01 90       	ld	r0, Z+
    ad42:	0d 92       	st	X+, r0
    ad44:	81 50       	subi	r24, 0x01	; 1
    ad46:	e1 f7       	brne	.-8      	; 0xad40 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    ad48:	8e 01       	movw	r16, r28
    ad4a:	0f 5f       	subi	r16, 0xFF	; 255
    ad4c:	1f 4f       	sbci	r17, 0xFF	; 255
    ad4e:	b8 01       	movw	r22, r16
    ad50:	ae 01       	movw	r20, r28
    ad52:	46 5f       	subi	r20, 0xF6	; 246
    ad54:	5f 4f       	sbci	r21, 0xFF	; 255
    ad56:	0e 94 e3 ac 	call	0x159c6	; 0x159c6 <_datetime>
    ad5a:	e5 e1       	ldi	r30, 0x15	; 21
    ad5c:	8e 2e       	mov	r8, r30
    ad5e:	91 2c       	mov	r9, r1
    ad60:	8c 0e       	add	r8, r28
    ad62:	9d 1e       	adc	r9, r29
    ad64:	d4 01       	movw	r26, r8
    ad66:	20 e0       	ldi	r18, 0x00	; 0
    ad68:	30 e0       	ldi	r19, 0x00	; 0
    ad6a:	40 e0       	ldi	r20, 0x00	; 0
    ad6c:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    ad6e:	22 30       	cpi	r18, 0x02	; 2
    ad70:	31 05       	cpc	r19, r1
    ad72:	19 f0       	breq	.+6      	; 0xad7a <_menu_datetime+0x6e>
    ad74:	24 30       	cpi	r18, 0x04	; 4
    ad76:	31 05       	cpc	r19, r1
    ad78:	11 f4       	brne	.+4      	; 0xad7e <_menu_datetime+0x72>
			__ii++;
    ad7a:	4f 5f       	subi	r20, 0xFF	; 255
    ad7c:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    ad7e:	f8 01       	movw	r30, r16
    ad80:	e4 0f       	add	r30, r20
    ad82:	f5 1f       	adc	r31, r21
    ad84:	80 81       	ld	r24, Z
    ad86:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    ad88:	2f 5f       	subi	r18, 0xFF	; 255
    ad8a:	3f 4f       	sbci	r19, 0xFF	; 255
    ad8c:	14 96       	adiw	r26, 0x04	; 4
    ad8e:	26 30       	cpi	r18, 0x06	; 6
    ad90:	31 05       	cpc	r19, r1
    ad92:	19 f0       	breq	.+6      	; 0xad9a <_menu_datetime+0x8e>
    ad94:	4f 5f       	subi	r20, 0xFF	; 255
    ad96:	5f 4f       	sbci	r21, 0xFF	; 255
    ad98:	ea cf       	rjmp	.-44     	; 0xad6e <_menu_datetime+0x62>
    ad9a:	7d e2       	ldi	r23, 0x2D	; 45
    ad9c:	a7 2e       	mov	r10, r23
    ad9e:	b1 2c       	mov	r11, r1
    ada0:	ac 0e       	add	r10, r28
    ada2:	bd 1e       	adc	r11, r29
    ada4:	d5 01       	movw	r26, r10
    ada6:	40 e0       	ldi	r20, 0x00	; 0
    ada8:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    adaa:	6a e0       	ldi	r22, 0x0A	; 10
    adac:	e6 2e       	mov	r14, r22
    adae:	f1 2c       	mov	r15, r1
    adb0:	ec 0e       	add	r14, r28
    adb2:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    adb4:	28 30       	cpi	r18, 0x08	; 8
    adb6:	31 05       	cpc	r19, r1
    adb8:	19 f0       	breq	.+6      	; 0xadc0 <_menu_datetime+0xb4>
    adba:	2a 30       	cpi	r18, 0x0A	; 10
    adbc:	31 05       	cpc	r19, r1
    adbe:	11 f4       	brne	.+4      	; 0xadc4 <_menu_datetime+0xb8>
			__ii++;
    adc0:	4f 5f       	subi	r20, 0xFF	; 255
    adc2:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    adc4:	f7 01       	movw	r30, r14
    adc6:	e4 0f       	add	r30, r20
    adc8:	f5 1f       	adc	r31, r21
    adca:	80 81       	ld	r24, Z
    adcc:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    adce:	2f 5f       	subi	r18, 0xFF	; 255
    add0:	3f 4f       	sbci	r19, 0xFF	; 255
    add2:	14 96       	adiw	r26, 0x04	; 4
    add4:	2c 30       	cpi	r18, 0x0C	; 12
    add6:	31 05       	cpc	r19, r1
    add8:	19 f0       	breq	.+6      	; 0xade0 <_menu_datetime+0xd4>
    adda:	4f 5f       	subi	r20, 0xFF	; 255
    addc:	5f 4f       	sbci	r21, 0xFF	; 255
    adde:	ea cf       	rjmp	.-44     	; 0xadb4 <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    ade0:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    ade4:	80 e0       	ldi	r24, 0x00	; 0
    ade6:	90 e9       	ldi	r25, 0x90	; 144
    ade8:	01 97       	sbiw	r24, 0x01	; 1
    adea:	f1 f7       	brne	.-4      	; 0xade8 <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    adec:	81 e0       	ldi	r24, 0x01	; 1
    adee:	61 e0       	ldi	r22, 0x01	; 1
    adf0:	49 e3       	ldi	r20, 0x39	; 57
    adf2:	5d e0       	ldi	r21, 0x0D	; 13
    adf4:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    adf8:	82 e0       	ldi	r24, 0x02	; 2
    adfa:	61 e0       	ldi	r22, 0x01	; 1
    adfc:	41 e3       	ldi	r20, 0x31	; 49
    adfe:	5d e0       	ldi	r21, 0x0D	; 13
    ae00:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	lcd_print(1, 8, __date);
    ae04:	81 e0       	ldi	r24, 0x01	; 1
    ae06:	68 e0       	ldi	r22, 0x08	; 8
    ae08:	8e 01       	movw	r16, r28
    ae0a:	0f 5f       	subi	r16, 0xFF	; 255
    ae0c:	1f 4f       	sbci	r17, 0xFF	; 255
    ae0e:	a8 01       	movw	r20, r16
    ae10:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	lcd_print(2, 8, __time);
    ae14:	82 e0       	ldi	r24, 0x02	; 2
    ae16:	68 e0       	ldi	r22, 0x08	; 8
    ae18:	a7 01       	movw	r20, r14
    ae1a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    ae1e:	84 e0       	ldi	r24, 0x04	; 4
    ae20:	61 e0       	ldi	r22, 0x01	; 1
    ae22:	4c e1       	ldi	r20, 0x1C	; 28
    ae24:	5d e0       	ldi	r21, 0x0D	; 13
    ae26:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    ae2a:	8b 89       	ldd	r24, Y+19	; 0x13
    ae2c:	6c 89       	ldd	r22, Y+20	; 0x14
    ae2e:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
	CURSOR_SHOW;
    ae32:	8f e0       	ldi	r24, 0x0F	; 15
    ae34:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
    ae38:	ee 24       	eor	r14, r14
    ae3a:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    ae3c:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    ae3e:	81 e0       	ldi	r24, 0x01	; 1
    ae40:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    ae44:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    ae46:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    ae4a:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    ae4c:	80 53       	subi	r24, 0x30	; 48
    ae4e:	8a 30       	cpi	r24, 0x0A	; 10
    ae50:	08 f0       	brcs	.+2      	; 0xae54 <_menu_datetime+0x148>
    ae52:	72 c0       	rjmp	.+228    	; 0xaf38 <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    ae54:	e1 14       	cp	r14, r1
    ae56:	f1 04       	cpc	r15, r1
    ae58:	81 f0       	breq	.+32     	; 0xae7a <_menu_datetime+0x16e>
    ae5a:	82 e0       	ldi	r24, 0x02	; 2
    ae5c:	e8 16       	cp	r14, r24
    ae5e:	f1 04       	cpc	r15, r1
    ae60:	61 f0       	breq	.+24     	; 0xae7a <_menu_datetime+0x16e>
    ae62:	96 e0       	ldi	r25, 0x06	; 6
    ae64:	e9 16       	cp	r14, r25
    ae66:	f1 04       	cpc	r15, r1
    ae68:	41 f0       	breq	.+16     	; 0xae7a <_menu_datetime+0x16e>
    ae6a:	a8 e0       	ldi	r26, 0x08	; 8
    ae6c:	ea 16       	cp	r14, r26
    ae6e:	f1 04       	cpc	r15, r1
    ae70:	21 f0       	breq	.+8      	; 0xae7a <_menu_datetime+0x16e>
    ae72:	ba e0       	ldi	r27, 0x0A	; 10
    ae74:	eb 16       	cp	r14, r27
    ae76:	f1 04       	cpc	r15, r1
    ae78:	81 f4       	brne	.+32     	; 0xae9a <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    ae7a:	84 2f       	mov	r24, r20
    ae7c:	90 e0       	ldi	r25, 0x00	; 0
    ae7e:	c0 97       	sbiw	r24, 0x30	; 48
    ae80:	f7 01       	movw	r30, r14
    ae82:	ee 0f       	add	r30, r30
    ae84:	ff 1f       	adc	r31, r31
    ae86:	ee 0f       	add	r30, r30
    ae88:	ff 1f       	adc	r31, r31
    ae8a:	ec 0d       	add	r30, r12
    ae8c:	fd 1d       	adc	r31, r13
    ae8e:	25 89       	ldd	r18, Z+21	; 0x15
    ae90:	30 e0       	ldi	r19, 0x00	; 0
    ae92:	28 17       	cp	r18, r24
    ae94:	39 07       	cpc	r19, r25
    ae96:	84 f5       	brge	.+96     	; 0xaef8 <_menu_datetime+0x1ec>
    ae98:	4f c0       	rjmp	.+158    	; 0xaf38 <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    ae9a:	81 e0       	ldi	r24, 0x01	; 1
    ae9c:	e8 16       	cp	r14, r24
    ae9e:	f1 04       	cpc	r15, r1
    aea0:	61 f4       	brne	.+24     	; 0xaeba <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    aea2:	2d 89       	ldd	r18, Y+21	; 0x15
    aea4:	30 e0       	ldi	r19, 0x00	; 0
    aea6:	2f 52       	subi	r18, 0x2F	; 47
    aea8:	30 40       	sbci	r19, 0x00	; 0
    aeaa:	8e 89       	ldd	r24, Y+22	; 0x16
    aeac:	90 e0       	ldi	r25, 0x00	; 0
    aeae:	82 17       	cp	r24, r18
    aeb0:	93 07       	cpc	r25, r19
    aeb2:	14 f5       	brge	.+68     	; 0xaef8 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    aeb4:	42 33       	cpi	r20, 0x32	; 50
    aeb6:	00 f1       	brcs	.+64     	; 0xaef8 <_menu_datetime+0x1ec>
    aeb8:	3f c0       	rjmp	.+126    	; 0xaf38 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    aeba:	93 e0       	ldi	r25, 0x03	; 3
    aebc:	e9 16       	cp	r14, r25
    aebe:	f1 04       	cpc	r15, r1
    aec0:	61 f4       	brne	.+24     	; 0xaeda <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    aec2:	2d 8d       	ldd	r18, Y+29	; 0x1d
    aec4:	30 e0       	ldi	r19, 0x00	; 0
    aec6:	2f 52       	subi	r18, 0x2F	; 47
    aec8:	30 40       	sbci	r19, 0x00	; 0
    aeca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    aecc:	90 e0       	ldi	r25, 0x00	; 0
    aece:	82 17       	cp	r24, r18
    aed0:	93 07       	cpc	r25, r19
    aed2:	94 f4       	brge	.+36     	; 0xaef8 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    aed4:	43 33       	cpi	r20, 0x33	; 51
    aed6:	80 f0       	brcs	.+32     	; 0xaef8 <_menu_datetime+0x1ec>
    aed8:	2f c0       	rjmp	.+94     	; 0xaf38 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    aeda:	a7 e0       	ldi	r26, 0x07	; 7
    aedc:	ea 16       	cp	r14, r26
    aede:	f1 04       	cpc	r15, r1
    aee0:	59 f4       	brne	.+22     	; 0xaef8 <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    aee2:	2d a5       	ldd	r18, Y+45	; 0x2d
    aee4:	30 e0       	ldi	r19, 0x00	; 0
    aee6:	2f 52       	subi	r18, 0x2F	; 47
    aee8:	30 40       	sbci	r19, 0x00	; 0
    aeea:	8e a5       	ldd	r24, Y+46	; 0x2e
    aeec:	90 e0       	ldi	r25, 0x00	; 0
    aeee:	82 17       	cp	r24, r18
    aef0:	93 07       	cpc	r25, r19
    aef2:	14 f4       	brge	.+4      	; 0xaef8 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    aef4:	44 33       	cpi	r20, 0x34	; 52
    aef6:	00 f5       	brcc	.+64     	; 0xaf38 <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    aef8:	f7 01       	movw	r30, r14
    aefa:	ee 0f       	add	r30, r30
    aefc:	ff 1f       	adc	r31, r31
    aefe:	ee 0f       	add	r30, r30
    af00:	ff 1f       	adc	r31, r31
    af02:	ec 0d       	add	r30, r12
    af04:	fd 1d       	adc	r31, r13
    af06:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    af08:	84 2f       	mov	r24, r20
    af0a:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
			__i++;
    af0e:	08 94       	sec
    af10:	e1 1c       	adc	r14, r1
    af12:	f1 1c       	adc	r15, r1
    af14:	bc e0       	ldi	r27, 0x0C	; 12
    af16:	eb 16       	cp	r14, r27
    af18:	f1 04       	cpc	r15, r1
    af1a:	1c f0       	brlt	.+6      	; 0xaf22 <_menu_datetime+0x216>
    af1c:	bb e0       	ldi	r27, 0x0B	; 11
    af1e:	eb 2e       	mov	r14, r27
    af20:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    af22:	f7 01       	movw	r30, r14
    af24:	ee 0f       	add	r30, r30
    af26:	ff 1f       	adc	r31, r31
    af28:	ee 0f       	add	r30, r30
    af2a:	ff 1f       	adc	r31, r31
    af2c:	ec 0d       	add	r30, r12
    af2e:	fd 1d       	adc	r31, r13
    af30:	82 89       	ldd	r24, Z+18	; 0x12
    af32:	63 89       	ldd	r22, Z+19	; 0x13
    af34:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    af38:	1b 37       	cpi	r17, 0x7B	; 123
    af3a:	59 f4       	brne	.+22     	; 0xaf52 <_menu_datetime+0x246>
			__i++;
    af3c:	08 94       	sec
    af3e:	e1 1c       	adc	r14, r1
    af40:	f1 1c       	adc	r15, r1
    af42:	8c e0       	ldi	r24, 0x0C	; 12
    af44:	e8 16       	cp	r14, r24
    af46:	f1 04       	cpc	r15, r1
    af48:	6c f0       	brlt	.+26     	; 0xaf64 <_menu_datetime+0x258>
    af4a:	eb e0       	ldi	r30, 0x0B	; 11
    af4c:	ee 2e       	mov	r14, r30
    af4e:	f1 2c       	mov	r15, r1
    af50:	09 c0       	rjmp	.+18     	; 0xaf64 <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    af52:	17 37       	cpi	r17, 0x77	; 119
    af54:	99 f4       	brne	.+38     	; 0xaf7c <_menu_datetime+0x270>
			__i--;
    af56:	08 94       	sec
    af58:	e1 08       	sbc	r14, r1
    af5a:	f1 08       	sbc	r15, r1
    af5c:	f7 fe       	sbrs	r15, 7
    af5e:	02 c0       	rjmp	.+4      	; 0xaf64 <_menu_datetime+0x258>
    af60:	ee 24       	eor	r14, r14
    af62:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    af64:	f7 01       	movw	r30, r14
    af66:	ee 0f       	add	r30, r30
    af68:	ff 1f       	adc	r31, r31
    af6a:	ee 0f       	add	r30, r30
    af6c:	ff 1f       	adc	r31, r31
    af6e:	ec 0d       	add	r30, r12
    af70:	fd 1d       	adc	r31, r13
    af72:	82 89       	ldd	r24, Z+18	; 0x12
    af74:	63 89       	ldd	r22, Z+19	; 0x13
    af76:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
    af7a:	61 cf       	rjmp	.-318    	; 0xae3e <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    af7c:	17 3e       	cpi	r17, 0xE7	; 231
    af7e:	09 f4       	brne	.+2      	; 0xaf82 <_menu_datetime+0x276>
    af80:	49 c0       	rjmp	.+146    	; 0xb014 <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    af82:	17 3b       	cpi	r17, 0xB7	; 183
    af84:	09 f0       	breq	.+2      	; 0xaf88 <_menu_datetime+0x27c>
    af86:	5b cf       	rjmp	.-330    	; 0xae3e <_menu_datetime+0x132>
    af88:	20 e0       	ldi	r18, 0x00	; 0
    af8a:	30 e0       	ldi	r19, 0x00	; 0
    af8c:	40 e0       	ldi	r20, 0x00	; 0
    af8e:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    af90:	be 01       	movw	r22, r28
    af92:	6f 5f       	subi	r22, 0xFF	; 255
    af94:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    af96:	22 30       	cpi	r18, 0x02	; 2
    af98:	31 05       	cpc	r19, r1
    af9a:	19 f0       	breq	.+6      	; 0xafa2 <_menu_datetime+0x296>
    af9c:	24 30       	cpi	r18, 0x04	; 4
    af9e:	31 05       	cpc	r19, r1
    afa0:	11 f4       	brne	.+4      	; 0xafa6 <_menu_datetime+0x29a>
					__ii++;
    afa2:	4f 5f       	subi	r20, 0xFF	; 255
    afa4:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    afa6:	fb 01       	movw	r30, r22
    afa8:	e4 0f       	add	r30, r20
    afaa:	f5 1f       	adc	r31, r21
    afac:	d4 01       	movw	r26, r8
    afae:	8c 91       	ld	r24, X
    afb0:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    afb2:	2f 5f       	subi	r18, 0xFF	; 255
    afb4:	3f 4f       	sbci	r19, 0xFF	; 255
    afb6:	84 e0       	ldi	r24, 0x04	; 4
    afb8:	90 e0       	ldi	r25, 0x00	; 0
    afba:	88 0e       	add	r8, r24
    afbc:	99 1e       	adc	r9, r25
    afbe:	26 30       	cpi	r18, 0x06	; 6
    afc0:	31 05       	cpc	r19, r1
    afc2:	19 f0       	breq	.+6      	; 0xafca <_menu_datetime+0x2be>
    afc4:	4f 5f       	subi	r20, 0xFF	; 255
    afc6:	5f 4f       	sbci	r21, 0xFF	; 255
    afc8:	e6 cf       	rjmp	.-52     	; 0xaf96 <_menu_datetime+0x28a>
    afca:	60 e0       	ldi	r22, 0x00	; 0
    afcc:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    afce:	ae 01       	movw	r20, r28
    afd0:	46 5f       	subi	r20, 0xF6	; 246
    afd2:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    afd4:	28 30       	cpi	r18, 0x08	; 8
    afd6:	31 05       	cpc	r19, r1
    afd8:	19 f0       	breq	.+6      	; 0xafe0 <_menu_datetime+0x2d4>
    afda:	2a 30       	cpi	r18, 0x0A	; 10
    afdc:	31 05       	cpc	r19, r1
    afde:	11 f4       	brne	.+4      	; 0xafe4 <_menu_datetime+0x2d8>
					__ii++;
    afe0:	6f 5f       	subi	r22, 0xFF	; 255
    afe2:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    afe4:	fa 01       	movw	r30, r20
    afe6:	e6 0f       	add	r30, r22
    afe8:	f7 1f       	adc	r31, r23
    afea:	d5 01       	movw	r26, r10
    afec:	8c 91       	ld	r24, X
    afee:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    aff0:	2f 5f       	subi	r18, 0xFF	; 255
    aff2:	3f 4f       	sbci	r19, 0xFF	; 255
    aff4:	84 e0       	ldi	r24, 0x04	; 4
    aff6:	90 e0       	ldi	r25, 0x00	; 0
    aff8:	a8 0e       	add	r10, r24
    affa:	b9 1e       	adc	r11, r25
    affc:	2c 30       	cpi	r18, 0x0C	; 12
    affe:	31 05       	cpc	r19, r1
    b000:	19 f0       	breq	.+6      	; 0xb008 <_menu_datetime+0x2fc>
    b002:	6f 5f       	subi	r22, 0xFF	; 255
    b004:	7f 4f       	sbci	r23, 0xFF	; 255
    b006:	e6 cf       	rjmp	.-52     	; 0xafd4 <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    b008:	81 e0       	ldi	r24, 0x01	; 1
    b00a:	be 01       	movw	r22, r28
    b00c:	6f 5f       	subi	r22, 0xFF	; 255
    b00e:	7f 4f       	sbci	r23, 0xFF	; 255
    b010:	0e 94 e3 ac 	call	0x159c6	; 0x159c6 <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    b014:	8c e0       	ldi	r24, 0x0C	; 12
    b016:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
}
    b01a:	ce 5b       	subi	r28, 0xBE	; 190
    b01c:	df 4f       	sbci	r29, 0xFF	; 255
    b01e:	0f b6       	in	r0, 0x3f	; 63
    b020:	f8 94       	cli
    b022:	de bf       	out	0x3e, r29	; 62
    b024:	0f be       	out	0x3f, r0	; 63
    b026:	cd bf       	out	0x3d, r28	; 61
    b028:	cf 91       	pop	r28
    b02a:	df 91       	pop	r29
    b02c:	1f 91       	pop	r17
    b02e:	0f 91       	pop	r16
    b030:	ff 90       	pop	r15
    b032:	ef 90       	pop	r14
    b034:	df 90       	pop	r13
    b036:	cf 90       	pop	r12
    b038:	bf 90       	pop	r11
    b03a:	af 90       	pop	r10
    b03c:	9f 90       	pop	r9
    b03e:	8f 90       	pop	r8
    b040:	08 95       	ret

0000b042 <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    b042:	0e 94 86 56 	call	0xad0c	; 0xad0c <_menu_datetime>
     return MENU_DONE;
}
    b046:	81 e0       	ldi	r24, 0x01	; 1
    b048:	08 95       	ret

0000b04a <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    b04a:	4f 92       	push	r4
    b04c:	5f 92       	push	r5
    b04e:	6f 92       	push	r6
    b050:	7f 92       	push	r7
    b052:	8f 92       	push	r8
    b054:	9f 92       	push	r9
    b056:	af 92       	push	r10
    b058:	bf 92       	push	r11
    b05a:	cf 92       	push	r12
    b05c:	df 92       	push	r13
    b05e:	ef 92       	push	r14
    b060:	ff 92       	push	r15
    b062:	0f 93       	push	r16
    b064:	1f 93       	push	r17
    b066:	df 93       	push	r29
    b068:	cf 93       	push	r28
    b06a:	cd b7       	in	r28, 0x3d	; 61
    b06c:	de b7       	in	r29, 0x3e	; 62
    b06e:	a2 97       	sbiw	r28, 0x22	; 34
    b070:	0f b6       	in	r0, 0x3f	; 63
    b072:	f8 94       	cli
    b074:	de bf       	out	0x3e, r29	; 62
    b076:	0f be       	out	0x3f, r0	; 63
    b078:	cd bf       	out	0x3d, r28	; 61
    b07a:	7c 01       	movw	r14, r24
    b07c:	6b 01       	movw	r12, r22

       char KeyPressed=0,KeyChar;
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];

       switch(stEnterFIP){
    b07e:	80 91 6c 02 	lds	r24, 0x026C
    b082:	81 30       	cpi	r24, 0x01	; 1
    b084:	09 f4       	brne	.+2      	; 0xb088 <menu_FIP+0x3e>
    b086:	cf c0       	rjmp	.+414    	; 0xb226 <menu_FIP+0x1dc>
    b088:	81 30       	cpi	r24, 0x01	; 1
    b08a:	20 f0       	brcs	.+8      	; 0xb094 <menu_FIP+0x4a>
    b08c:	82 30       	cpi	r24, 0x02	; 2
    b08e:	09 f0       	breq	.+2      	; 0xb092 <menu_FIP+0x48>
    b090:	4c c1       	rjmp	.+664    	; 0xb32a <menu_FIP+0x2e0>
    b092:	49 c1       	rjmp	.+658    	; 0xb326 <menu_FIP+0x2dc>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    b094:	8e 01       	movw	r16, r28
    b096:	09 5f       	subi	r16, 0xF9	; 249
    b098:	1f 4f       	sbci	r17, 0xFF	; 255
    b09a:	c8 01       	movw	r24, r16
    b09c:	65 e4       	ldi	r22, 0x45	; 69
    b09e:	70 e0       	ldi	r23, 0x00	; 0
    b0a0:	48 e0       	ldi	r20, 0x08	; 8
    b0a2:	50 e0       	ldi	r21, 0x00	; 0
    b0a4:	22 ed       	ldi	r18, 0xD2	; 210
    b0a6:	33 e1       	ldi	r19, 0x13	; 19
    b0a8:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    b0ac:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    b0b0:	f8 01       	movw	r30, r16
    b0b2:	20 e0       	ldi	r18, 0x00	; 0
    b0b4:	30 e0       	ldi	r19, 0x00	; 0
    b0b6:	07 c0       	rjmp	.+14     	; 0xb0c6 <menu_FIP+0x7c>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    b0b8:	80 81       	ld	r24, Z
    b0ba:	84 36       	cpi	r24, 0x64	; 100
    b0bc:	08 f0       	brcs	.+2      	; 0xb0c0 <menu_FIP+0x76>
    b0be:	10 82       	st	Z, r1
    b0c0:	2f 5f       	subi	r18, 0xFF	; 255
    b0c2:	3f 4f       	sbci	r19, 0xFF	; 255
    b0c4:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    b0c6:	28 30       	cpi	r18, 0x08	; 8
    b0c8:	31 05       	cpc	r19, r1
    b0ca:	b0 f3       	brcs	.-20     	; 0xb0b8 <menu_FIP+0x6e>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    b0cc:	10 92 6a 02 	sts	0x026A, r1
    b0d0:	10 92 69 02 	sts	0x0269, r1
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    b0d4:	5e 01       	movw	r10, r28
    b0d6:	08 94       	sec
    b0d8:	a1 1c       	adc	r10, r1
    b0da:	b1 1c       	adc	r11, r1
    b0dc:	09 ee       	ldi	r16, 0xE9	; 233
    b0de:	c0 2e       	mov	r12, r16
    b0e0:	0e e0       	ldi	r16, 0x0E	; 14
    b0e2:	d0 2e       	mov	r13, r16
    b0e4:	17 e0       	ldi	r17, 0x07	; 7
    b0e6:	41 2e       	mov	r4, r17
    b0e8:	51 2c       	mov	r5, r1
    b0ea:	4c 0e       	add	r4, r28
    b0ec:	5d 1e       	adc	r5, r29
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    b0ee:	b4 e0       	ldi	r27, 0x04	; 4
    b0f0:	eb 2e       	mov	r14, r27
    b0f2:	f1 2c       	mov	r15, r1
    b0f4:	ec 0e       	add	r14, r28
    b0f6:	fd 1e       	adc	r15, r29
    b0f8:	ab e0       	ldi	r26, 0x0B	; 11
    b0fa:	6a 2e       	mov	r6, r26
    b0fc:	71 2c       	mov	r7, r1
    b0fe:	6c 0e       	add	r6, r28
    b100:	7d 1e       	adc	r7, r29
    b102:	8e 01       	movw	r16, r28
    b104:	01 5f       	subi	r16, 0xF1	; 241
    b106:	1f 4f       	sbci	r17, 0xFF	; 255
    b108:	f7 ef       	ldi	r31, 0xF7	; 247
    b10a:	8f 2e       	mov	r8, r31
    b10c:	fd e1       	ldi	r31, 0x1D	; 29
    b10e:	9f 2e       	mov	r9, r31
    b110:	64 c0       	rjmp	.+200    	; 0xb1da <menu_FIP+0x190>
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    b112:	00 d0       	rcall	.+0      	; 0xb114 <menu_FIP+0xca>
    b114:	00 d0       	rcall	.+0      	; 0xb116 <menu_FIP+0xcc>
    b116:	00 d0       	rcall	.+0      	; 0xb118 <menu_FIP+0xce>
    b118:	2d b7       	in	r18, 0x3d	; 61
    b11a:	3e b7       	in	r19, 0x3e	; 62
    b11c:	2f 5f       	subi	r18, 0xFF	; 255
    b11e:	3f 4f       	sbci	r19, 0xFF	; 255
    b120:	ed b7       	in	r30, 0x3d	; 61
    b122:	fe b7       	in	r31, 0x3e	; 62
    b124:	b2 82       	std	Z+2, r11	; 0x02
    b126:	a1 82       	std	Z+1, r10	; 0x01
    b128:	f9 01       	movw	r30, r18
    b12a:	d3 82       	std	Z+3, r13	; 0x03
    b12c:	c2 82       	std	Z+2, r12	; 0x02
    b12e:	a4 0d       	add	r26, r4
    b130:	b5 1d       	adc	r27, r5
    b132:	8c 91       	ld	r24, X
    b134:	84 83       	std	Z+4, r24	; 0x04
    b136:	15 82       	std	Z+5, r1	; 0x05
    b138:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    b13c:	ad b7       	in	r26, 0x3d	; 61
    b13e:	be b7       	in	r27, 0x3e	; 62
    b140:	11 96       	adiw	r26, 0x01	; 1
    b142:	ed b7       	in	r30, 0x3d	; 61
    b144:	fe b7       	in	r31, 0x3e	; 62
    b146:	f2 82       	std	Z+2, r15	; 0x02
    b148:	e1 82       	std	Z+1, r14	; 0x01
    b14a:	13 96       	adiw	r26, 0x03	; 3
    b14c:	dc 92       	st	X, r13
    b14e:	ce 92       	st	-X, r12
    b150:	12 97       	sbiw	r26, 0x02	; 2
    b152:	e0 91 69 02 	lds	r30, 0x0269
    b156:	f0 91 6a 02 	lds	r31, 0x026A
    b15a:	e6 0d       	add	r30, r6
    b15c:	f7 1d       	adc	r31, r7
    b15e:	80 81       	ld	r24, Z
    b160:	14 96       	adiw	r26, 0x04	; 4
    b162:	8c 93       	st	X, r24
    b164:	14 97       	sbiw	r26, 0x04	; 4
    b166:	15 96       	adiw	r26, 0x05	; 5
    b168:	1c 92       	st	X, r1
    b16a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    b16e:	80 91 69 02 	lds	r24, 0x0269
    b172:	90 91 6a 02 	lds	r25, 0x026A
    b176:	00 d0       	rcall	.+0      	; 0xb178 <menu_FIP+0x12e>
    b178:	00 d0       	rcall	.+0      	; 0xb17a <menu_FIP+0x130>
    b17a:	00 d0       	rcall	.+0      	; 0xb17c <menu_FIP+0x132>
    b17c:	ed b7       	in	r30, 0x3d	; 61
    b17e:	fe b7       	in	r31, 0x3e	; 62
    b180:	31 96       	adiw	r30, 0x01	; 1
    b182:	ad b7       	in	r26, 0x3d	; 61
    b184:	be b7       	in	r27, 0x3e	; 62
    b186:	12 96       	adiw	r26, 0x02	; 2
    b188:	1c 93       	st	X, r17
    b18a:	0e 93       	st	-X, r16
    b18c:	11 97       	sbiw	r26, 0x01	; 1
    b18e:	93 82       	std	Z+3, r9	; 0x03
    b190:	82 82       	std	Z+2, r8	; 0x02
    b192:	01 96       	adiw	r24, 0x01	; 1
    b194:	95 83       	std	Z+5, r25	; 0x05
    b196:	84 83       	std	Z+4, r24	; 0x04
    b198:	b7 82       	std	Z+7, r11	; 0x07
    b19a:	a6 82       	std	Z+6, r10	; 0x06
    b19c:	04 96       	adiw	r24, 0x04	; 4
    b19e:	91 87       	std	Z+9, r25	; 0x09
    b1a0:	80 87       	std	Z+8, r24	; 0x08
    b1a2:	f3 86       	std	Z+11, r15	; 0x0b
    b1a4:	e2 86       	std	Z+10, r14	; 0x0a
    b1a6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			    lcd_print((iLoop+1),1,lcdteks);
    b1aa:	ed b7       	in	r30, 0x3d	; 61
    b1ac:	fe b7       	in	r31, 0x3e	; 62
    b1ae:	3c 96       	adiw	r30, 0x0c	; 12
    b1b0:	0f b6       	in	r0, 0x3f	; 63
    b1b2:	f8 94       	cli
    b1b4:	fe bf       	out	0x3e, r31	; 62
    b1b6:	0f be       	out	0x3f, r0	; 63
    b1b8:	ed bf       	out	0x3d, r30	; 61
    b1ba:	80 91 69 02 	lds	r24, 0x0269
    b1be:	8f 5f       	subi	r24, 0xFF	; 255
    b1c0:	61 e0       	ldi	r22, 0x01	; 1
    b1c2:	a8 01       	movw	r20, r16
    b1c4:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    b1c8:	80 91 69 02 	lds	r24, 0x0269
    b1cc:	90 91 6a 02 	lds	r25, 0x026A
    b1d0:	01 96       	adiw	r24, 0x01	; 1
    b1d2:	90 93 6a 02 	sts	0x026A, r25
    b1d6:	80 93 69 02 	sts	0x0269, r24
    b1da:	a0 91 69 02 	lds	r26, 0x0269
    b1de:	b0 91 6a 02 	lds	r27, 0x026A
    b1e2:	a4 30       	cpi	r26, 0x04	; 4
    b1e4:	b1 05       	cpc	r27, r1
    b1e6:	08 f4       	brcc	.+2      	; 0xb1ea <menu_FIP+0x1a0>
    b1e8:	94 cf       	rjmp	.-216    	; 0xb112 <menu_FIP+0xc8>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    b1ea:	81 e0       	ldi	r24, 0x01	; 1
    b1ec:	6f e0       	ldi	r22, 0x0F	; 15
    b1ee:	41 ef       	ldi	r20, 0xF1	; 241
    b1f0:	5d e1       	ldi	r21, 0x1D	; 29
    b1f2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    b1f6:	82 e0       	ldi	r24, 0x02	; 2
    b1f8:	6f e0       	ldi	r22, 0x0F	; 15
    b1fa:	4b ee       	ldi	r20, 0xEB	; 235
    b1fc:	5d e1       	ldi	r21, 0x1D	; 29
    b1fe:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    b202:	83 e0       	ldi	r24, 0x03	; 3
    b204:	6f e0       	ldi	r22, 0x0F	; 15
    b206:	45 ee       	ldi	r20, 0xE5	; 229
    b208:	5d e1       	ldi	r21, 0x1D	; 29
    b20a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    b20e:	84 e0       	ldi	r24, 0x04	; 4
    b210:	6f e0       	ldi	r22, 0x0F	; 15
    b212:	4e ed       	ldi	r20, 0xDE	; 222
    b214:	5d e1       	ldi	r21, 0x1D	; 29
    b216:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		    iLoop=0;
    b21a:	10 92 6a 02 	sts	0x026A, r1
    b21e:	10 92 69 02 	sts	0x0269, r1
		    stEnterFIP=efFIPInput;
    b222:	81 e0       	ldi	r24, 0x01	; 1
    b224:	7d c0       	rjmp	.+250    	; 0xb320 <menu_FIP+0x2d6>
	        break;
	   case efFIPInput:
		    iLoop++;
    b226:	80 91 69 02 	lds	r24, 0x0269
    b22a:	90 91 6a 02 	lds	r25, 0x026A
    b22e:	01 96       	adiw	r24, 0x01	; 1
    b230:	90 93 6a 02 	sts	0x026A, r25
    b234:	80 93 69 02 	sts	0x0269, r24
		    KeyPressed=_key_scan(1);
    b238:	81 e0       	ldi	r24, 0x01	; 1
    b23a:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    b23e:	08 2f       	mov	r16, r24
		    KeyChar=_key_btn(KeyPressed);
    b240:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    b244:	98 2f       	mov	r25, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    b246:	18 2f       	mov	r17, r24
    b248:	11 53       	subi	r17, 0x31	; 49
    b24a:	18 30       	cpi	r17, 0x08	; 8
    b24c:	60 f4       	brcc	.+24     	; 0xb266 <menu_FIP+0x21c>
		 	     if (KeyCharLast!=KeyChar){
    b24e:	80 91 5a 01 	lds	r24, 0x015A
    b252:	89 17       	cp	r24, r25
    b254:	41 f0       	breq	.+16     	; 0xb266 <menu_FIP+0x21c>
				     KeyCharLast=KeyChar;
    b256:	90 93 5a 01 	sts	0x015A, r25
				     iLoop=1000;
    b25a:	88 ee       	ldi	r24, 0xE8	; 232
    b25c:	93 e0       	ldi	r25, 0x03	; 3
    b25e:	90 93 6a 02 	sts	0x026A, r25
    b262:	80 93 69 02 	sts	0x0269, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    b266:	80 91 69 02 	lds	r24, 0x0269
    b26a:	90 91 6a 02 	lds	r25, 0x026A
    b26e:	60 ed       	ldi	r22, 0xD0	; 208
    b270:	77 e0       	ldi	r23, 0x07	; 7
    b272:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    b276:	89 2b       	or	r24, r25
    b278:	39 f4       	brne	.+14     	; 0xb288 <menu_FIP+0x23e>
		        lcd_xy(1,19);_lcd('_'); 
    b27a:	81 e0       	ldi	r24, 0x01	; 1
    b27c:	63 e1       	ldi	r22, 0x13	; 19
    b27e:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
    b282:	8f e5       	ldi	r24, 0x5F	; 95
    b284:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
			   }
           if ((iLoop%2000)==1000){
    b288:	80 91 69 02 	lds	r24, 0x0269
    b28c:	90 91 6a 02 	lds	r25, 0x026A
    b290:	60 ed       	ldi	r22, 0xD0	; 208
    b292:	77 e0       	ldi	r23, 0x07	; 7
    b294:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    b298:	88 5e       	subi	r24, 0xE8	; 232
    b29a:	93 40       	sbci	r25, 0x03	; 3
    b29c:	41 f4       	brne	.+16     	; 0xb2ae <menu_FIP+0x264>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    b29e:	81 e0       	ldi	r24, 0x01	; 1
    b2a0:	63 e1       	ldi	r22, 0x13	; 19
    b2a2:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
    b2a6:	80 91 5a 01 	lds	r24, 0x015A
    b2aa:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    b2ae:	18 30       	cpi	r17, 0x08	; 8
    b2b0:	30 f0       	brcs	.+12     	; 0xb2be <menu_FIP+0x274>
    b2b2:	07 3b       	cpi	r16, 0xB7	; 183
    b2b4:	91 f5       	brne	.+100    	; 0xb31a <menu_FIP+0x2d0>
    b2b6:	80 91 5a 01 	lds	r24, 0x015A
    b2ba:	80 32       	cpi	r24, 0x20	; 32
    b2bc:	b1 f1       	breq	.+108    	; 0xb32a <menu_FIP+0x2e0>
		         FIP_Used=FIP[KeyCharLast-'1'];
    b2be:	80 91 5a 01 	lds	r24, 0x015A
    b2c2:	fe 01       	movw	r30, r28
    b2c4:	ba 97       	sbiw	r30, 0x2a	; 42
    b2c6:	e8 0f       	add	r30, r24
    b2c8:	f1 1d       	adc	r31, r1
    b2ca:	20 81       	ld	r18, Z
    b2cc:	20 93 6b 02 	sts	0x026B, r18
				 if (FIP_Used<=99){
    b2d0:	24 36       	cpi	r18, 0x64	; 100
    b2d2:	f0 f4       	brcc	.+60     	; 0xb310 <menu_FIP+0x2c6>
                     //leadingZero(FIP_Used,sFIPUsed);
					 //xFIP[0]=FIP_Used;
					 *xFIP=FIP_Used;
    b2d4:	d7 01       	movw	r26, r14
    b2d6:	2c 93       	st	X, r18
					 sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
    b2d8:	00 d0       	rcall	.+0      	; 0xb2da <menu_FIP+0x290>
    b2da:	00 d0       	rcall	.+0      	; 0xb2dc <menu_FIP+0x292>
    b2dc:	00 d0       	rcall	.+0      	; 0xb2de <menu_FIP+0x294>
    b2de:	ed b7       	in	r30, 0x3d	; 61
    b2e0:	fe b7       	in	r31, 0x3e	; 62
    b2e2:	31 96       	adiw	r30, 0x01	; 1
    b2e4:	ad b7       	in	r26, 0x3d	; 61
    b2e6:	be b7       	in	r27, 0x3e	; 62
    b2e8:	12 96       	adiw	r26, 0x02	; 2
    b2ea:	dc 92       	st	X, r13
    b2ec:	ce 92       	st	-X, r12
    b2ee:	11 97       	sbiw	r26, 0x01	; 1
    b2f0:	89 ed       	ldi	r24, 0xD9	; 217
    b2f2:	9d e1       	ldi	r25, 0x1D	; 29
    b2f4:	93 83       	std	Z+3, r25	; 0x03
    b2f6:	82 83       	std	Z+2, r24	; 0x02
    b2f8:	24 83       	std	Z+4, r18	; 0x04
    b2fa:	15 82       	std	Z+5, r1	; 0x05
    b2fc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    b300:	ed b7       	in	r30, 0x3d	; 61
    b302:	fe b7       	in	r31, 0x3e	; 62
    b304:	36 96       	adiw	r30, 0x06	; 6
    b306:	0f b6       	in	r0, 0x3f	; 63
    b308:	f8 94       	cli
    b30a:	fe bf       	out	0x3e, r31	; 62
    b30c:	0f be       	out	0x3f, r0	; 63
    b30e:	ed bf       	out	0x3d, r30	; 61

					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    b310:	82 e0       	ldi	r24, 0x02	; 2
    b312:	80 93 6c 02 	sts	0x026C, r24
    b316:	80 e0       	ldi	r24, 0x00	; 0
    b318:	09 c0       	rjmp	.+18     	; 0xb32c <menu_FIP+0x2e2>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    b31a:	07 3e       	cpi	r16, 0xE7	; 231
    b31c:	31 f4       	brne	.+12     	; 0xb32a <menu_FIP+0x2e0>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    b31e:	82 e0       	ldi	r24, 0x02	; 2
    b320:	80 93 6c 02 	sts	0x026C, r24
    b324:	03 c0       	rjmp	.+6      	; 0xb32c <menu_FIP+0x2e2>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    b326:	10 92 6c 02 	sts	0x026C, r1
    b32a:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    b32c:	a2 96       	adiw	r28, 0x22	; 34
    b32e:	0f b6       	in	r0, 0x3f	; 63
    b330:	f8 94       	cli
    b332:	de bf       	out	0x3e, r29	; 62
    b334:	0f be       	out	0x3f, r0	; 63
    b336:	cd bf       	out	0x3d, r28	; 61
    b338:	cf 91       	pop	r28
    b33a:	df 91       	pop	r29
    b33c:	1f 91       	pop	r17
    b33e:	0f 91       	pop	r16
    b340:	ff 90       	pop	r15
    b342:	ef 90       	pop	r14
    b344:	df 90       	pop	r13
    b346:	cf 90       	pop	r12
    b348:	bf 90       	pop	r11
    b34a:	af 90       	pop	r10
    b34c:	9f 90       	pop	r9
    b34e:	8f 90       	pop	r8
    b350:	7f 90       	pop	r7
    b352:	6f 90       	pop	r6
    b354:	5f 90       	pop	r5
    b356:	4f 90       	pop	r4
    b358:	08 95       	ret

0000b35a <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    b35a:	ff 92       	push	r15
    b35c:	0f 93       	push	r16
    b35e:	1f 93       	push	r17
    b360:	df 93       	push	r29
    b362:	cf 93       	push	r28
    b364:	cd b7       	in	r28, 0x3d	; 61
    b366:	de b7       	in	r29, 0x3e	; 62
    b368:	64 97       	sbiw	r28, 0x14	; 20
    b36a:	0f b6       	in	r0, 0x3f	; 63
    b36c:	f8 94       	cli
    b36e:	de bf       	out	0x3e, r29	; 62
    b370:	0f be       	out	0x3f, r0	; 63
    b372:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    b374:	10 92 2e 02 	sts	0x022E, r1
     switch(stClientIP){
    b378:	80 91 58 01 	lds	r24, 0x0158
    b37c:	82 30       	cpi	r24, 0x02	; 2
    b37e:	09 f4       	brne	.+2      	; 0xb382 <FMenuSettingServerIP+0x28>
    b380:	7b c0       	rjmp	.+246    	; 0xb478 <FMenuSettingServerIP+0x11e>
    b382:	83 30       	cpi	r24, 0x03	; 3
    b384:	20 f4       	brcc	.+8      	; 0xb38e <FMenuSettingServerIP+0x34>
    b386:	81 30       	cpi	r24, 0x01	; 1
    b388:	09 f0       	breq	.+2      	; 0xb38c <FMenuSettingServerIP+0x32>
    b38a:	67 c2       	rjmp	.+1230   	; 0xb85a <FMenuSettingServerIP+0x500>
    b38c:	07 c0       	rjmp	.+14     	; 0xb39c <FMenuSettingServerIP+0x42>
    b38e:	83 30       	cpi	r24, 0x03	; 3
    b390:	09 f4       	brne	.+2      	; 0xb394 <FMenuSettingServerIP+0x3a>
    b392:	5e c2       	rjmp	.+1212   	; 0xb850 <FMenuSettingServerIP+0x4f6>
    b394:	84 30       	cpi	r24, 0x04	; 4
    b396:	09 f0       	breq	.+2      	; 0xb39a <FMenuSettingServerIP+0x40>
    b398:	60 c2       	rjmp	.+1216   	; 0xb85a <FMenuSettingServerIP+0x500>
    b39a:	4c c2       	rjmp	.+1176   	; 0xb834 <FMenuSettingServerIP+0x4da>
		  case cipInit:
			   lcd_clear();
    b39c:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    b3a0:	81 e0       	ldi	r24, 0x01	; 1
    b3a2:	61 e0       	ldi	r22, 0x01	; 1
    b3a4:	41 ea       	ldi	r20, 0xA1	; 161
    b3a6:	54 e1       	ldi	r21, 0x14	; 20
    b3a8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    b3ac:	87 e2       	ldi	r24, 0x27	; 39
    b3ae:	92 e0       	ldi	r25, 0x02	; 2
    b3b0:	6c e2       	ldi	r22, 0x2C	; 44
    b3b2:	70 e0       	ldi	r23, 0x00	; 0
    b3b4:	44 e0       	ldi	r20, 0x04	; 4
    b3b6:	50 e0       	ldi	r21, 0x00	; 0
    b3b8:	22 ed       	ldi	r18, 0xD2	; 210
    b3ba:	33 e1       	ldi	r19, 0x13	; 19
    b3bc:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    b3c0:	8d b7       	in	r24, 0x3d	; 61
    b3c2:	9e b7       	in	r25, 0x3e	; 62
    b3c4:	0c 97       	sbiw	r24, 0x0c	; 12
    b3c6:	0f b6       	in	r0, 0x3f	; 63
    b3c8:	f8 94       	cli
    b3ca:	9e bf       	out	0x3e, r25	; 62
    b3cc:	0f be       	out	0x3f, r0	; 63
    b3ce:	8d bf       	out	0x3d, r24	; 61
    b3d0:	ed b7       	in	r30, 0x3d	; 61
    b3d2:	fe b7       	in	r31, 0x3e	; 62
    b3d4:	31 96       	adiw	r30, 0x01	; 1
    b3d6:	8e 01       	movw	r16, r28
    b3d8:	0f 5f       	subi	r16, 0xFF	; 255
    b3da:	1f 4f       	sbci	r17, 0xFF	; 255
    b3dc:	ad b7       	in	r26, 0x3d	; 61
    b3de:	be b7       	in	r27, 0x3e	; 62
    b3e0:	12 96       	adiw	r26, 0x02	; 2
    b3e2:	1c 93       	st	X, r17
    b3e4:	0e 93       	st	-X, r16
    b3e6:	11 97       	sbiw	r26, 0x01	; 1
    b3e8:	80 e9       	ldi	r24, 0x90	; 144
    b3ea:	94 e1       	ldi	r25, 0x14	; 20
    b3ec:	93 83       	std	Z+3, r25	; 0x03
    b3ee:	82 83       	std	Z+2, r24	; 0x02
    b3f0:	80 91 27 02 	lds	r24, 0x0227
    b3f4:	84 83       	std	Z+4, r24	; 0x04
    b3f6:	15 82       	std	Z+5, r1	; 0x05
    b3f8:	80 91 28 02 	lds	r24, 0x0228
    b3fc:	86 83       	std	Z+6, r24	; 0x06
    b3fe:	17 82       	std	Z+7, r1	; 0x07
    b400:	80 91 29 02 	lds	r24, 0x0229
    b404:	80 87       	std	Z+8, r24	; 0x08
    b406:	11 86       	std	Z+9, r1	; 0x09
    b408:	80 91 2a 02 	lds	r24, 0x022A
    b40c:	82 87       	std	Z+10, r24	; 0x0a
    b40e:	13 86       	std	Z+11, r1	; 0x0b
    b410:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	           lcd_print(2,1,lcdteks);
    b414:	ed b7       	in	r30, 0x3d	; 61
    b416:	fe b7       	in	r31, 0x3e	; 62
    b418:	3c 96       	adiw	r30, 0x0c	; 12
    b41a:	0f b6       	in	r0, 0x3f	; 63
    b41c:	f8 94       	cli
    b41e:	fe bf       	out	0x3e, r31	; 62
    b420:	0f be       	out	0x3f, r0	; 63
    b422:	ed bf       	out	0x3d, r30	; 61
    b424:	82 e0       	ldi	r24, 0x02	; 2
    b426:	61 e0       	ldi	r22, 0x01	; 1
    b428:	a8 01       	movw	r20, r16
    b42a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    b42e:	83 e0       	ldi	r24, 0x03	; 3
    b430:	61 e0       	ldi	r22, 0x01	; 1
    b432:	4b e7       	ldi	r20, 0x7B	; 123
    b434:	54 e1       	ldi	r21, 0x14	; 20
    b436:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    b43a:	84 e0       	ldi	r24, 0x04	; 4
    b43c:	61 e0       	ldi	r22, 0x01	; 1
    b43e:	46 e6       	ldi	r20, 0x66	; 102
    b440:	54 e1       	ldi	r21, 0x14	; 20
    b442:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
               iLoop=0;
    b446:	10 92 26 02 	sts	0x0226, r1
    b44a:	10 92 25 02 	sts	0x0225, r1
			   y=3,x=8;
    b44e:	83 e0       	ldi	r24, 0x03	; 3
    b450:	80 93 2c 02 	sts	0x022C, r24
    b454:	88 e0       	ldi	r24, 0x08	; 8
    b456:	80 93 2d 02 	sts	0x022D, r24
			   iInput=0; iBlok=0;
    b45a:	10 92 2b 02 	sts	0x022B, r1
    b45e:	10 92 24 02 	sts	0x0224, r1
    b462:	10 92 23 02 	sts	0x0223, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    b466:	80 e3       	ldi	r24, 0x30	; 48
    b468:	80 93 30 02 	sts	0x0230, r24
    b46c:	80 93 31 02 	sts	0x0231, r24
    b470:	80 93 32 02 	sts	0x0232, r24
			   stClientIP=cipInputIP; 
    b474:	82 e0       	ldi	r24, 0x02	; 2
    b476:	e9 c1       	rjmp	.+978    	; 0xb84a <FMenuSettingServerIP+0x4f0>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    b478:	80 91 25 02 	lds	r24, 0x0225
    b47c:	90 91 26 02 	lds	r25, 0x0226
    b480:	01 96       	adiw	r24, 0x01	; 1
    b482:	90 93 26 02 	sts	0x0226, r25
    b486:	80 93 25 02 	sts	0x0225, r24
			   if ((iLoop%2000)==0){
    b48a:	60 ed       	ldi	r22, 0xD0	; 208
    b48c:	77 e0       	ldi	r23, 0x07	; 7
    b48e:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    b492:	89 2b       	or	r24, r25
    b494:	81 f4       	brne	.+32     	; 0xb4b6 <FMenuSettingServerIP+0x15c>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    b496:	80 91 23 02 	lds	r24, 0x0223
    b49a:	90 91 24 02 	lds	r25, 0x0224
    b49e:	88 0f       	add	r24, r24
    b4a0:	99 1f       	adc	r25, r25
    b4a2:	88 0f       	add	r24, r24
    b4a4:	99 1f       	adc	r25, r25
    b4a6:	60 91 2d 02 	lds	r22, 0x022D
    b4aa:	68 0f       	add	r22, r24
    b4ac:	80 91 2c 02 	lds	r24, 0x022C
    b4b0:	4f e5       	ldi	r20, 0x5F	; 95
    b4b2:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    b4b6:	80 91 25 02 	lds	r24, 0x0225
    b4ba:	90 91 26 02 	lds	r25, 0x0226
    b4be:	60 ed       	ldi	r22, 0xD0	; 208
    b4c0:	77 e0       	ldi	r23, 0x07	; 7
    b4c2:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    b4c6:	88 5e       	subi	r24, 0xE8	; 232
    b4c8:	93 40       	sbci	r25, 0x03	; 3
    b4ca:	81 f4       	brne	.+32     	; 0xb4ec <FMenuSettingServerIP+0x192>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    b4cc:	80 91 23 02 	lds	r24, 0x0223
    b4d0:	90 91 24 02 	lds	r25, 0x0224
    b4d4:	88 0f       	add	r24, r24
    b4d6:	99 1f       	adc	r25, r25
    b4d8:	88 0f       	add	r24, r24
    b4da:	99 1f       	adc	r25, r25
    b4dc:	60 91 2d 02 	lds	r22, 0x022D
    b4e0:	68 0f       	add	r22, r24
    b4e2:	80 91 2c 02 	lds	r24, 0x022C
    b4e6:	40 e2       	ldi	r20, 0x20	; 32
    b4e8:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    b4ec:	81 e0       	ldi	r24, 0x01	; 1
    b4ee:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    b4f2:	f8 2e       	mov	r15, r24
			   keyChar=_key_btn(keyPressed);
    b4f4:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    b4f8:	48 2f       	mov	r20, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    b4fa:	80 53       	subi	r24, 0x30	; 48
    b4fc:	8a 30       	cpi	r24, 0x0A	; 10
    b4fe:	08 f0       	brcs	.+2      	; 0xb502 <FMenuSettingServerIP+0x1a8>
    b500:	db c0       	rjmp	.+438    	; 0xb6b8 <FMenuSettingServerIP+0x35e>
    b502:	80 ed       	ldi	r24, 0xD0	; 208
    b504:	97 e0       	ldi	r25, 0x07	; 7
    b506:	20 e7       	ldi	r18, 0x70	; 112
    b508:	31 e0       	ldi	r19, 0x01	; 1
    b50a:	f9 01       	movw	r30, r18
    b50c:	31 97       	sbiw	r30, 0x01	; 1
    b50e:	f1 f7       	brne	.-4      	; 0xb50c <FMenuSettingServerIP+0x1b2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    b510:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    b512:	d9 f7       	brne	.-10     	; 0xb50a <FMenuSettingServerIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    b514:	80 91 2b 02 	lds	r24, 0x022B
    b518:	e8 2f       	mov	r30, r24
    b51a:	f0 e0       	ldi	r31, 0x00	; 0
    b51c:	e0 5d       	subi	r30, 0xD0	; 208
    b51e:	fd 4f       	sbci	r31, 0xFD	; 253
    b520:	40 83       	st	Z, r20
				   iInput++;                    
    b522:	8f 5f       	subi	r24, 0xFF	; 255
    b524:	80 93 2b 02 	sts	0x022B, r24
				   for (i=1;i<(iInput+1);i++){
    b528:	81 e0       	ldi	r24, 0x01	; 1
    b52a:	1c c0       	rjmp	.+56     	; 0xb564 <FMenuSettingServerIP+0x20a>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    b52c:	80 91 2d 02 	lds	r24, 0x022D
    b530:	68 0f       	add	r22, r24
    b532:	63 50       	subi	r22, 0x03	; 3
    b534:	80 91 23 02 	lds	r24, 0x0223
    b538:	90 91 24 02 	lds	r25, 0x0224
    b53c:	88 0f       	add	r24, r24
    b53e:	99 1f       	adc	r25, r25
    b540:	88 0f       	add	r24, r24
    b542:	99 1f       	adc	r25, r25
    b544:	68 0f       	add	r22, r24
    b546:	80 91 2c 02 	lds	r24, 0x022C
    b54a:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
    b54e:	e0 91 2f 02 	lds	r30, 0x022F
    b552:	f0 e0       	ldi	r31, 0x00	; 0
    b554:	e1 5d       	subi	r30, 0xD1	; 209
    b556:	fd 4f       	sbci	r31, 0xFD	; 253
    b558:	80 81       	ld	r24, Z
    b55a:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    b55e:	80 91 2f 02 	lds	r24, 0x022F
    b562:	8f 5f       	subi	r24, 0xFF	; 255
    b564:	80 93 2f 02 	sts	0x022F, r24
    b568:	70 91 2b 02 	lds	r23, 0x022B
    b56c:	60 91 2f 02 	lds	r22, 0x022F
    b570:	27 2f       	mov	r18, r23
    b572:	30 e0       	ldi	r19, 0x00	; 0
    b574:	86 2f       	mov	r24, r22
    b576:	90 e0       	ldi	r25, 0x00	; 0
    b578:	28 17       	cp	r18, r24
    b57a:	39 07       	cpc	r19, r25
    b57c:	bc f6       	brge	.-82     	; 0xb52c <FMenuSettingServerIP+0x1d2>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    b57e:	73 30       	cpi	r23, 0x03	; 3
    b580:	08 f4       	brcc	.+2      	; 0xb584 <FMenuSettingServerIP+0x22a>
    b582:	91 c0       	rjmp	.+290    	; 0xb6a6 <FMenuSettingServerIP+0x34c>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    b584:	40 91 23 02 	lds	r20, 0x0223
    b588:	50 91 24 02 	lds	r21, 0x0224
    b58c:	fa 01       	movw	r30, r20
    b58e:	e9 5d       	subi	r30, 0xD9	; 217
    b590:	fd 4f       	sbci	r31, 0xFD	; 253
    b592:	20 91 32 02 	lds	r18, 0x0232
    b596:	20 5d       	subi	r18, 0xD0	; 208
    b598:	80 91 30 02 	lds	r24, 0x0230
    b59c:	34 e6       	ldi	r19, 0x64	; 100
    b59e:	83 9f       	mul	r24, r19
    b5a0:	c0 01       	movw	r24, r0
    b5a2:	11 24       	eor	r1, r1
    b5a4:	28 0f       	add	r18, r24
    b5a6:	80 91 31 02 	lds	r24, 0x0231
    b5aa:	3a e0       	ldi	r19, 0x0A	; 10
    b5ac:	83 9f       	mul	r24, r19
    b5ae:	c0 01       	movw	r24, r0
    b5b0:	11 24       	eor	r1, r1
    b5b2:	28 0f       	add	r18, r24
    b5b4:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    b5b6:	80 e3       	ldi	r24, 0x30	; 48
    b5b8:	80 93 30 02 	sts	0x0230, r24
    b5bc:	80 93 31 02 	sts	0x0231, r24
    b5c0:	80 93 32 02 	sts	0x0232, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    b5c4:	44 0f       	add	r20, r20
    b5c6:	55 1f       	adc	r21, r21
    b5c8:	44 0f       	add	r20, r20
    b5ca:	55 1f       	adc	r21, r21
    b5cc:	60 91 2d 02 	lds	r22, 0x022D
    b5d0:	64 0f       	add	r22, r20
    b5d2:	67 1b       	sub	r22, r23
    b5d4:	80 91 2c 02 	lds	r24, 0x022C
    b5d8:	42 e6       	ldi	r20, 0x62	; 98
    b5da:	54 e1       	ldi	r21, 0x14	; 20
    b5dc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    b5e0:	00 d0       	rcall	.+0      	; 0xb5e2 <FMenuSettingServerIP+0x288>
    b5e2:	00 d0       	rcall	.+0      	; 0xb5e4 <FMenuSettingServerIP+0x28a>
    b5e4:	00 d0       	rcall	.+0      	; 0xb5e6 <FMenuSettingServerIP+0x28c>
    b5e6:	ad b7       	in	r26, 0x3d	; 61
    b5e8:	be b7       	in	r27, 0x3e	; 62
    b5ea:	11 96       	adiw	r26, 0x01	; 1
    b5ec:	8e 01       	movw	r16, r28
    b5ee:	0f 5f       	subi	r16, 0xFF	; 255
    b5f0:	1f 4f       	sbci	r17, 0xFF	; 255
    b5f2:	ed b7       	in	r30, 0x3d	; 61
    b5f4:	fe b7       	in	r31, 0x3e	; 62
    b5f6:	12 83       	std	Z+2, r17	; 0x02
    b5f8:	01 83       	std	Z+1, r16	; 0x01
    b5fa:	8f e5       	ldi	r24, 0x5F	; 95
    b5fc:	94 e1       	ldi	r25, 0x14	; 20
    b5fe:	13 96       	adiw	r26, 0x03	; 3
    b600:	9c 93       	st	X, r25
    b602:	8e 93       	st	-X, r24
    b604:	12 97       	sbiw	r26, 0x02	; 2
    b606:	e0 91 23 02 	lds	r30, 0x0223
    b60a:	f0 91 24 02 	lds	r31, 0x0224
    b60e:	e9 5d       	subi	r30, 0xD9	; 217
    b610:	fd 4f       	sbci	r31, 0xFD	; 253
    b612:	80 81       	ld	r24, Z
    b614:	14 96       	adiw	r26, 0x04	; 4
    b616:	8c 93       	st	X, r24
    b618:	14 97       	sbiw	r26, 0x04	; 4
    b61a:	15 96       	adiw	r26, 0x05	; 5
    b61c:	1c 92       	st	X, r1
    b61e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    b622:	f8 01       	movw	r30, r16
    b624:	01 90       	ld	r0, Z+
    b626:	00 20       	and	r0, r0
    b628:	e9 f7       	brne	.-6      	; 0xb624 <FMenuSettingServerIP+0x2ca>
    b62a:	31 97       	sbiw	r30, 0x01	; 1
    b62c:	e0 1b       	sub	r30, r16
    b62e:	f1 0b       	sbc	r31, r17
    b630:	8d b7       	in	r24, 0x3d	; 61
    b632:	9e b7       	in	r25, 0x3e	; 62
    b634:	06 96       	adiw	r24, 0x06	; 6
    b636:	0f b6       	in	r0, 0x3f	; 63
    b638:	f8 94       	cli
    b63a:	9e bf       	out	0x3e, r25	; 62
    b63c:	0f be       	out	0x3f, r0	; 63
    b63e:	8d bf       	out	0x3d, r24	; 61
    b640:	60 91 2d 02 	lds	r22, 0x022D
    b644:	6f 5f       	subi	r22, 0xFF	; 255
    b646:	80 91 23 02 	lds	r24, 0x0223
    b64a:	90 91 24 02 	lds	r25, 0x0224
    b64e:	88 0f       	add	r24, r24
    b650:	99 1f       	adc	r25, r25
    b652:	88 0f       	add	r24, r24
    b654:	99 1f       	adc	r25, r25
    b656:	68 0f       	add	r22, r24
    b658:	6e 1b       	sub	r22, r30
    b65a:	80 91 2c 02 	lds	r24, 0x022C
    b65e:	a8 01       	movw	r20, r16
    b660:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    b664:	80 91 23 02 	lds	r24, 0x0223
    b668:	90 91 24 02 	lds	r25, 0x0224
    b66c:	00 97       	sbiw	r24, 0x00	; 0
    b66e:	81 f0       	breq	.+32     	; 0xb690 <FMenuSettingServerIP+0x336>
    b670:	60 91 2d 02 	lds	r22, 0x022D
    b674:	6f 5f       	subi	r22, 0xFF	; 255
    b676:	81 50       	subi	r24, 0x01	; 1
    b678:	90 4c       	sbci	r25, 0xC0	; 192
    b67a:	88 0f       	add	r24, r24
    b67c:	99 1f       	adc	r25, r25
    b67e:	88 0f       	add	r24, r24
    b680:	99 1f       	adc	r25, r25
    b682:	68 0f       	add	r22, r24
    b684:	80 91 2c 02 	lds	r24, 0x022C
    b688:	4d e5       	ldi	r20, 0x5D	; 93
    b68a:	54 e1       	ldi	r21, 0x14	; 20
    b68c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					   iInput=0;
    b690:	10 92 2b 02 	sts	0x022B, r1
					   iBlok++;
    b694:	80 91 23 02 	lds	r24, 0x0223
    b698:	90 91 24 02 	lds	r25, 0x0224
    b69c:	01 96       	adiw	r24, 0x01	; 1
    b69e:	90 93 24 02 	sts	0x0224, r25
    b6a2:	80 93 23 02 	sts	0x0223, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    b6a6:	80 91 23 02 	lds	r24, 0x0223
    b6aa:	90 91 24 02 	lds	r25, 0x0224
    b6ae:	04 97       	sbiw	r24, 0x04	; 4
    b6b0:	18 f0       	brcs	.+6      	; 0xb6b8 <FMenuSettingServerIP+0x35e>
    b6b2:	84 e0       	ldi	r24, 0x04	; 4
    b6b4:	80 93 58 01 	sts	0x0158, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    b6b8:	97 ee       	ldi	r25, 0xE7	; 231
    b6ba:	f9 16       	cp	r15, r25
    b6bc:	09 f4       	brne	.+2      	; 0xb6c0 <FMenuSettingServerIP+0x366>
    b6be:	c4 c0       	rjmp	.+392    	; 0xb848 <FMenuSettingServerIP+0x4ee>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    b6c0:	a7 eb       	ldi	r26, 0xB7	; 183
    b6c2:	fa 16       	cp	r15, r26
    b6c4:	09 f0       	breq	.+2      	; 0xb6c8 <FMenuSettingServerIP+0x36e>
    b6c6:	c9 c0       	rjmp	.+402    	; 0xb85a <FMenuSettingServerIP+0x500>
			       //NextInput
			       if (iBlok<4){
    b6c8:	40 91 23 02 	lds	r20, 0x0223
    b6cc:	50 91 24 02 	lds	r21, 0x0224
    b6d0:	44 30       	cpi	r20, 0x04	; 4
    b6d2:	51 05       	cpc	r21, r1
    b6d4:	08 f0       	brcs	.+2      	; 0xb6d8 <FMenuSettingServerIP+0x37e>
    b6d6:	a6 c0       	rjmp	.+332    	; 0xb824 <FMenuSettingServerIP+0x4ca>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    b6d8:	80 91 2b 02 	lds	r24, 0x022B
    b6dc:	81 30       	cpi	r24, 0x01	; 1
    b6de:	41 f4       	brne	.+16     	; 0xb6f0 <FMenuSettingServerIP+0x396>
    b6e0:	fa 01       	movw	r30, r20
    b6e2:	e9 5d       	subi	r30, 0xD9	; 217
    b6e4:	fd 4f       	sbci	r31, 0xFD	; 253
    b6e6:	80 91 30 02 	lds	r24, 0x0230
    b6ea:	80 53       	subi	r24, 0x30	; 48
    b6ec:	80 83       	st	Z, r24
    b6ee:	22 c0       	rjmp	.+68     	; 0xb734 <FMenuSettingServerIP+0x3da>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    b6f0:	82 30       	cpi	r24, 0x02	; 2
    b6f2:	49 f4       	brne	.+18     	; 0xb706 <FMenuSettingServerIP+0x3ac>
    b6f4:	fa 01       	movw	r30, r20
    b6f6:	e9 5d       	subi	r30, 0xD9	; 217
    b6f8:	fd 4f       	sbci	r31, 0xFD	; 253
    b6fa:	20 91 31 02 	lds	r18, 0x0231
    b6fe:	20 51       	subi	r18, 0x10	; 16
    b700:	80 91 30 02 	lds	r24, 0x0230
    b704:	11 c0       	rjmp	.+34     	; 0xb728 <FMenuSettingServerIP+0x3ce>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    b706:	83 30       	cpi	r24, 0x03	; 3
    b708:	a9 f4       	brne	.+42     	; 0xb734 <FMenuSettingServerIP+0x3da>
    b70a:	fa 01       	movw	r30, r20
    b70c:	e9 5d       	subi	r30, 0xD9	; 217
    b70e:	fd 4f       	sbci	r31, 0xFD	; 253
    b710:	20 91 32 02 	lds	r18, 0x0232
    b714:	20 5d       	subi	r18, 0xD0	; 208
    b716:	80 91 30 02 	lds	r24, 0x0230
    b71a:	34 e6       	ldi	r19, 0x64	; 100
    b71c:	83 9f       	mul	r24, r19
    b71e:	c0 01       	movw	r24, r0
    b720:	11 24       	eor	r1, r1
    b722:	28 0f       	add	r18, r24
    b724:	80 91 31 02 	lds	r24, 0x0231
    b728:	3a e0       	ldi	r19, 0x0A	; 10
    b72a:	83 9f       	mul	r24, r19
    b72c:	c0 01       	movw	r24, r0
    b72e:	11 24       	eor	r1, r1
    b730:	28 0f       	add	r18, r24
    b732:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    b734:	80 e3       	ldi	r24, 0x30	; 48
    b736:	80 93 30 02 	sts	0x0230, r24
    b73a:	80 93 31 02 	sts	0x0231, r24
    b73e:	80 93 32 02 	sts	0x0232, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    b742:	60 91 2d 02 	lds	r22, 0x022D
    b746:	63 50       	subi	r22, 0x03	; 3
    b748:	44 0f       	add	r20, r20
    b74a:	55 1f       	adc	r21, r21
    b74c:	44 0f       	add	r20, r20
    b74e:	55 1f       	adc	r21, r21
    b750:	64 0f       	add	r22, r20
    b752:	80 91 2c 02 	lds	r24, 0x022C
    b756:	49 e5       	ldi	r20, 0x59	; 89
    b758:	54 e1       	ldi	r21, 0x14	; 20
    b75a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    b75e:	00 d0       	rcall	.+0      	; 0xb760 <FMenuSettingServerIP+0x406>
    b760:	00 d0       	rcall	.+0      	; 0xb762 <FMenuSettingServerIP+0x408>
    b762:	00 d0       	rcall	.+0      	; 0xb764 <FMenuSettingServerIP+0x40a>
    b764:	ad b7       	in	r26, 0x3d	; 61
    b766:	be b7       	in	r27, 0x3e	; 62
    b768:	11 96       	adiw	r26, 0x01	; 1
    b76a:	8e 01       	movw	r16, r28
    b76c:	0f 5f       	subi	r16, 0xFF	; 255
    b76e:	1f 4f       	sbci	r17, 0xFF	; 255
    b770:	ed b7       	in	r30, 0x3d	; 61
    b772:	fe b7       	in	r31, 0x3e	; 62
    b774:	12 83       	std	Z+2, r17	; 0x02
    b776:	01 83       	std	Z+1, r16	; 0x01
    b778:	86 e5       	ldi	r24, 0x56	; 86
    b77a:	94 e1       	ldi	r25, 0x14	; 20
    b77c:	13 96       	adiw	r26, 0x03	; 3
    b77e:	9c 93       	st	X, r25
    b780:	8e 93       	st	-X, r24
    b782:	12 97       	sbiw	r26, 0x02	; 2
    b784:	e0 91 23 02 	lds	r30, 0x0223
    b788:	f0 91 24 02 	lds	r31, 0x0224
    b78c:	e9 5d       	subi	r30, 0xD9	; 217
    b78e:	fd 4f       	sbci	r31, 0xFD	; 253
    b790:	80 81       	ld	r24, Z
    b792:	14 96       	adiw	r26, 0x04	; 4
    b794:	8c 93       	st	X, r24
    b796:	14 97       	sbiw	r26, 0x04	; 4
    b798:	15 96       	adiw	r26, 0x05	; 5
    b79a:	1c 92       	st	X, r1
    b79c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    b7a0:	f8 01       	movw	r30, r16
    b7a2:	01 90       	ld	r0, Z+
    b7a4:	00 20       	and	r0, r0
    b7a6:	e9 f7       	brne	.-6      	; 0xb7a2 <FMenuSettingServerIP+0x448>
    b7a8:	31 97       	sbiw	r30, 0x01	; 1
    b7aa:	e0 1b       	sub	r30, r16
    b7ac:	f1 0b       	sbc	r31, r17
    b7ae:	8d b7       	in	r24, 0x3d	; 61
    b7b0:	9e b7       	in	r25, 0x3e	; 62
    b7b2:	06 96       	adiw	r24, 0x06	; 6
    b7b4:	0f b6       	in	r0, 0x3f	; 63
    b7b6:	f8 94       	cli
    b7b8:	9e bf       	out	0x3e, r25	; 62
    b7ba:	0f be       	out	0x3f, r0	; 63
    b7bc:	8d bf       	out	0x3d, r24	; 61
    b7be:	60 91 2d 02 	lds	r22, 0x022D
    b7c2:	6f 5f       	subi	r22, 0xFF	; 255
    b7c4:	80 91 23 02 	lds	r24, 0x0223
    b7c8:	90 91 24 02 	lds	r25, 0x0224
    b7cc:	88 0f       	add	r24, r24
    b7ce:	99 1f       	adc	r25, r25
    b7d0:	88 0f       	add	r24, r24
    b7d2:	99 1f       	adc	r25, r25
    b7d4:	68 0f       	add	r22, r24
    b7d6:	6e 1b       	sub	r22, r30
    b7d8:	80 91 2c 02 	lds	r24, 0x022C
    b7dc:	a8 01       	movw	r20, r16
    b7de:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    b7e2:	80 91 23 02 	lds	r24, 0x0223
    b7e6:	90 91 24 02 	lds	r25, 0x0224
    b7ea:	00 97       	sbiw	r24, 0x00	; 0
    b7ec:	81 f0       	breq	.+32     	; 0xb80e <FMenuSettingServerIP+0x4b4>
    b7ee:	60 91 2d 02 	lds	r22, 0x022D
    b7f2:	6f 5f       	subi	r22, 0xFF	; 255
    b7f4:	81 50       	subi	r24, 0x01	; 1
    b7f6:	90 4c       	sbci	r25, 0xC0	; 192
    b7f8:	88 0f       	add	r24, r24
    b7fa:	99 1f       	adc	r25, r25
    b7fc:	88 0f       	add	r24, r24
    b7fe:	99 1f       	adc	r25, r25
    b800:	68 0f       	add	r22, r24
    b802:	80 91 2c 02 	lds	r24, 0x022C
    b806:	44 e5       	ldi	r20, 0x54	; 84
    b808:	54 e1       	ldi	r21, 0x14	; 20
    b80a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				       iInput=0;
    b80e:	10 92 2b 02 	sts	0x022B, r1
					   iBlok++;	   
    b812:	80 91 23 02 	lds	r24, 0x0223
    b816:	90 91 24 02 	lds	r25, 0x0224
    b81a:	01 96       	adiw	r24, 0x01	; 1
    b81c:	90 93 24 02 	sts	0x0224, r25
    b820:	80 93 23 02 	sts	0x0223, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    b824:	80 91 23 02 	lds	r24, 0x0223
    b828:	90 91 24 02 	lds	r25, 0x0224
    b82c:	04 97       	sbiw	r24, 0x04	; 4
    b82e:	a8 f0       	brcs	.+42     	; 0xb85a <FMenuSettingServerIP+0x500>
    b830:	84 e0       	ldi	r24, 0x04	; 4
    b832:	0b c0       	rjmp	.+22     	; 0xb84a <FMenuSettingServerIP+0x4f0>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    b834:	8c e2       	ldi	r24, 0x2C	; 44
    b836:	90 e0       	ldi	r25, 0x00	; 0
    b838:	67 e2       	ldi	r22, 0x27	; 39
    b83a:	72 e0       	ldi	r23, 0x02	; 2
    b83c:	44 e0       	ldi	r20, 0x04	; 4
    b83e:	50 e0       	ldi	r21, 0x00	; 0
    b840:	2a ed       	ldi	r18, 0xDA	; 218
    b842:	33 e1       	ldi	r19, 0x13	; 19
    b844:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    b848:	83 e0       	ldi	r24, 0x03	; 3
    b84a:	80 93 58 01 	sts	0x0158, r24
    b84e:	05 c0       	rjmp	.+10     	; 0xb85a <FMenuSettingServerIP+0x500>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    b850:	81 e0       	ldi	r24, 0x01	; 1
    b852:	80 93 58 01 	sts	0x0158, r24
			   Result=MENU_DONE;
    b856:	80 93 2e 02 	sts	0x022E, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    b85a:	80 91 2e 02 	lds	r24, 0x022E
    b85e:	64 96       	adiw	r28, 0x14	; 20
    b860:	0f b6       	in	r0, 0x3f	; 63
    b862:	f8 94       	cli
    b864:	de bf       	out	0x3e, r29	; 62
    b866:	0f be       	out	0x3f, r0	; 63
    b868:	cd bf       	out	0x3d, r28	; 61
    b86a:	cf 91       	pop	r28
    b86c:	df 91       	pop	r29
    b86e:	1f 91       	pop	r17
    b870:	0f 91       	pop	r16
    b872:	ff 90       	pop	r15
    b874:	08 95       	ret

0000b876 <FMenuSettingClientIP>:





char FMenuSettingClientIP(){
    b876:	ff 92       	push	r15
    b878:	0f 93       	push	r16
    b87a:	1f 93       	push	r17
    b87c:	df 93       	push	r29
    b87e:	cf 93       	push	r28
    b880:	cd b7       	in	r28, 0x3d	; 61
    b882:	de b7       	in	r29, 0x3e	; 62
    b884:	64 97       	sbiw	r28, 0x14	; 20
    b886:	0f b6       	in	r0, 0x3f	; 63
    b888:	f8 94       	cli
    b88a:	de bf       	out	0x3e, r29	; 62
    b88c:	0f be       	out	0x3f, r0	; 63
    b88e:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    b890:	10 92 3e 02 	sts	0x023E, r1
	 switch(stClientIP){
    b894:	80 91 59 01 	lds	r24, 0x0159
    b898:	82 30       	cpi	r24, 0x02	; 2
    b89a:	09 f4       	brne	.+2      	; 0xb89e <FMenuSettingClientIP+0x28>
    b89c:	7b c0       	rjmp	.+246    	; 0xb994 <FMenuSettingClientIP+0x11e>
    b89e:	83 30       	cpi	r24, 0x03	; 3
    b8a0:	20 f4       	brcc	.+8      	; 0xb8aa <FMenuSettingClientIP+0x34>
    b8a2:	81 30       	cpi	r24, 0x01	; 1
    b8a4:	09 f0       	breq	.+2      	; 0xb8a8 <FMenuSettingClientIP+0x32>
    b8a6:	67 c2       	rjmp	.+1230   	; 0xbd76 <FMenuSettingClientIP+0x500>
    b8a8:	07 c0       	rjmp	.+14     	; 0xb8b8 <FMenuSettingClientIP+0x42>
    b8aa:	83 30       	cpi	r24, 0x03	; 3
    b8ac:	09 f4       	brne	.+2      	; 0xb8b0 <FMenuSettingClientIP+0x3a>
    b8ae:	5e c2       	rjmp	.+1212   	; 0xbd6c <FMenuSettingClientIP+0x4f6>
    b8b0:	84 30       	cpi	r24, 0x04	; 4
    b8b2:	09 f0       	breq	.+2      	; 0xb8b6 <FMenuSettingClientIP+0x40>
    b8b4:	60 c2       	rjmp	.+1216   	; 0xbd76 <FMenuSettingClientIP+0x500>
    b8b6:	4c c2       	rjmp	.+1176   	; 0xbd50 <FMenuSettingClientIP+0x4da>
		  case cipInit:
			   lcd_clear();
    b8b8:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    b8bc:	81 e0       	ldi	r24, 0x01	; 1
    b8be:	61 e0       	ldi	r22, 0x01	; 1
    b8c0:	48 ef       	ldi	r20, 0xF8	; 248
    b8c2:	54 e1       	ldi	r21, 0x14	; 20
    b8c4:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    b8c8:	87 e3       	ldi	r24, 0x37	; 55
    b8ca:	92 e0       	ldi	r25, 0x02	; 2
    b8cc:	68 e2       	ldi	r22, 0x28	; 40
    b8ce:	70 e0       	ldi	r23, 0x00	; 0
    b8d0:	44 e0       	ldi	r20, 0x04	; 4
    b8d2:	50 e0       	ldi	r21, 0x00	; 0
    b8d4:	22 ed       	ldi	r18, 0xD2	; 210
    b8d6:	33 e1       	ldi	r19, 0x13	; 19
    b8d8:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    b8dc:	8d b7       	in	r24, 0x3d	; 61
    b8de:	9e b7       	in	r25, 0x3e	; 62
    b8e0:	0c 97       	sbiw	r24, 0x0c	; 12
    b8e2:	0f b6       	in	r0, 0x3f	; 63
    b8e4:	f8 94       	cli
    b8e6:	9e bf       	out	0x3e, r25	; 62
    b8e8:	0f be       	out	0x3f, r0	; 63
    b8ea:	8d bf       	out	0x3d, r24	; 61
    b8ec:	ed b7       	in	r30, 0x3d	; 61
    b8ee:	fe b7       	in	r31, 0x3e	; 62
    b8f0:	31 96       	adiw	r30, 0x01	; 1
    b8f2:	8e 01       	movw	r16, r28
    b8f4:	0f 5f       	subi	r16, 0xFF	; 255
    b8f6:	1f 4f       	sbci	r17, 0xFF	; 255
    b8f8:	ad b7       	in	r26, 0x3d	; 61
    b8fa:	be b7       	in	r27, 0x3e	; 62
    b8fc:	12 96       	adiw	r26, 0x02	; 2
    b8fe:	1c 93       	st	X, r17
    b900:	0e 93       	st	-X, r16
    b902:	11 97       	sbiw	r26, 0x01	; 1
    b904:	87 ee       	ldi	r24, 0xE7	; 231
    b906:	94 e1       	ldi	r25, 0x14	; 20
    b908:	93 83       	std	Z+3, r25	; 0x03
    b90a:	82 83       	std	Z+2, r24	; 0x02
    b90c:	80 91 37 02 	lds	r24, 0x0237
    b910:	84 83       	std	Z+4, r24	; 0x04
    b912:	15 82       	std	Z+5, r1	; 0x05
    b914:	80 91 38 02 	lds	r24, 0x0238
    b918:	86 83       	std	Z+6, r24	; 0x06
    b91a:	17 82       	std	Z+7, r1	; 0x07
    b91c:	80 91 39 02 	lds	r24, 0x0239
    b920:	80 87       	std	Z+8, r24	; 0x08
    b922:	11 86       	std	Z+9, r1	; 0x09
    b924:	80 91 3a 02 	lds	r24, 0x023A
    b928:	82 87       	std	Z+10, r24	; 0x0a
    b92a:	13 86       	std	Z+11, r1	; 0x0b
    b92c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	           lcd_print(2,1,lcdteks);
    b930:	ed b7       	in	r30, 0x3d	; 61
    b932:	fe b7       	in	r31, 0x3e	; 62
    b934:	3c 96       	adiw	r30, 0x0c	; 12
    b936:	0f b6       	in	r0, 0x3f	; 63
    b938:	f8 94       	cli
    b93a:	fe bf       	out	0x3e, r31	; 62
    b93c:	0f be       	out	0x3f, r0	; 63
    b93e:	ed bf       	out	0x3d, r30	; 61
    b940:	82 e0       	ldi	r24, 0x02	; 2
    b942:	61 e0       	ldi	r22, 0x01	; 1
    b944:	a8 01       	movw	r20, r16
    b946:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    b94a:	83 e0       	ldi	r24, 0x03	; 3
    b94c:	61 e0       	ldi	r22, 0x01	; 1
    b94e:	42 ed       	ldi	r20, 0xD2	; 210
    b950:	54 e1       	ldi	r21, 0x14	; 20
    b952:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    b956:	84 e0       	ldi	r24, 0x04	; 4
    b958:	61 e0       	ldi	r22, 0x01	; 1
    b95a:	4d eb       	ldi	r20, 0xBD	; 189
    b95c:	54 e1       	ldi	r21, 0x14	; 20
    b95e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
               iLoop=0;
    b962:	10 92 36 02 	sts	0x0236, r1
    b966:	10 92 35 02 	sts	0x0235, r1
			   y=3,x=8;
    b96a:	83 e0       	ldi	r24, 0x03	; 3
    b96c:	80 93 3c 02 	sts	0x023C, r24
    b970:	88 e0       	ldi	r24, 0x08	; 8
    b972:	80 93 3d 02 	sts	0x023D, r24
			   iInput=0; iBlok=0;
    b976:	10 92 3b 02 	sts	0x023B, r1
    b97a:	10 92 34 02 	sts	0x0234, r1
    b97e:	10 92 33 02 	sts	0x0233, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    b982:	80 e3       	ldi	r24, 0x30	; 48
    b984:	80 93 40 02 	sts	0x0240, r24
    b988:	80 93 41 02 	sts	0x0241, r24
    b98c:	80 93 42 02 	sts	0x0242, r24
			   stClientIP=cipInputIP; 
    b990:	82 e0       	ldi	r24, 0x02	; 2
    b992:	e9 c1       	rjmp	.+978    	; 0xbd66 <FMenuSettingClientIP+0x4f0>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    b994:	80 91 35 02 	lds	r24, 0x0235
    b998:	90 91 36 02 	lds	r25, 0x0236
    b99c:	01 96       	adiw	r24, 0x01	; 1
    b99e:	90 93 36 02 	sts	0x0236, r25
    b9a2:	80 93 35 02 	sts	0x0235, r24
			   if ((iLoop%2000)==0){
    b9a6:	60 ed       	ldi	r22, 0xD0	; 208
    b9a8:	77 e0       	ldi	r23, 0x07	; 7
    b9aa:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    b9ae:	89 2b       	or	r24, r25
    b9b0:	81 f4       	brne	.+32     	; 0xb9d2 <FMenuSettingClientIP+0x15c>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    b9b2:	80 91 33 02 	lds	r24, 0x0233
    b9b6:	90 91 34 02 	lds	r25, 0x0234
    b9ba:	88 0f       	add	r24, r24
    b9bc:	99 1f       	adc	r25, r25
    b9be:	88 0f       	add	r24, r24
    b9c0:	99 1f       	adc	r25, r25
    b9c2:	60 91 3d 02 	lds	r22, 0x023D
    b9c6:	68 0f       	add	r22, r24
    b9c8:	80 91 3c 02 	lds	r24, 0x023C
    b9cc:	4f e5       	ldi	r20, 0x5F	; 95
    b9ce:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    b9d2:	80 91 35 02 	lds	r24, 0x0235
    b9d6:	90 91 36 02 	lds	r25, 0x0236
    b9da:	60 ed       	ldi	r22, 0xD0	; 208
    b9dc:	77 e0       	ldi	r23, 0x07	; 7
    b9de:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    b9e2:	88 5e       	subi	r24, 0xE8	; 232
    b9e4:	93 40       	sbci	r25, 0x03	; 3
    b9e6:	81 f4       	brne	.+32     	; 0xba08 <FMenuSettingClientIP+0x192>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    b9e8:	80 91 33 02 	lds	r24, 0x0233
    b9ec:	90 91 34 02 	lds	r25, 0x0234
    b9f0:	88 0f       	add	r24, r24
    b9f2:	99 1f       	adc	r25, r25
    b9f4:	88 0f       	add	r24, r24
    b9f6:	99 1f       	adc	r25, r25
    b9f8:	60 91 3d 02 	lds	r22, 0x023D
    b9fc:	68 0f       	add	r22, r24
    b9fe:	80 91 3c 02 	lds	r24, 0x023C
    ba02:	40 e2       	ldi	r20, 0x20	; 32
    ba04:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    ba08:	81 e0       	ldi	r24, 0x01	; 1
    ba0a:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    ba0e:	f8 2e       	mov	r15, r24
			   keyChar=_key_btn(keyPressed);
    ba10:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    ba14:	48 2f       	mov	r20, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    ba16:	80 53       	subi	r24, 0x30	; 48
    ba18:	8a 30       	cpi	r24, 0x0A	; 10
    ba1a:	08 f0       	brcs	.+2      	; 0xba1e <FMenuSettingClientIP+0x1a8>
    ba1c:	db c0       	rjmp	.+438    	; 0xbbd4 <FMenuSettingClientIP+0x35e>
    ba1e:	80 ed       	ldi	r24, 0xD0	; 208
    ba20:	97 e0       	ldi	r25, 0x07	; 7
    ba22:	20 e7       	ldi	r18, 0x70	; 112
    ba24:	31 e0       	ldi	r19, 0x01	; 1
    ba26:	f9 01       	movw	r30, r18
    ba28:	31 97       	sbiw	r30, 0x01	; 1
    ba2a:	f1 f7       	brne	.-4      	; 0xba28 <FMenuSettingClientIP+0x1b2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ba2c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ba2e:	d9 f7       	brne	.-10     	; 0xba26 <FMenuSettingClientIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    ba30:	80 91 3b 02 	lds	r24, 0x023B
    ba34:	e8 2f       	mov	r30, r24
    ba36:	f0 e0       	ldi	r31, 0x00	; 0
    ba38:	e0 5c       	subi	r30, 0xC0	; 192
    ba3a:	fd 4f       	sbci	r31, 0xFD	; 253
    ba3c:	40 83       	st	Z, r20
				   iInput++;                    
    ba3e:	8f 5f       	subi	r24, 0xFF	; 255
    ba40:	80 93 3b 02 	sts	0x023B, r24
				   for (i=1;i<(iInput+1);i++){
    ba44:	81 e0       	ldi	r24, 0x01	; 1
    ba46:	1c c0       	rjmp	.+56     	; 0xba80 <FMenuSettingClientIP+0x20a>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    ba48:	80 91 3d 02 	lds	r24, 0x023D
    ba4c:	68 0f       	add	r22, r24
    ba4e:	63 50       	subi	r22, 0x03	; 3
    ba50:	80 91 33 02 	lds	r24, 0x0233
    ba54:	90 91 34 02 	lds	r25, 0x0234
    ba58:	88 0f       	add	r24, r24
    ba5a:	99 1f       	adc	r25, r25
    ba5c:	88 0f       	add	r24, r24
    ba5e:	99 1f       	adc	r25, r25
    ba60:	68 0f       	add	r22, r24
    ba62:	80 91 3c 02 	lds	r24, 0x023C
    ba66:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
    ba6a:	e0 91 3f 02 	lds	r30, 0x023F
    ba6e:	f0 e0       	ldi	r31, 0x00	; 0
    ba70:	e1 5c       	subi	r30, 0xC1	; 193
    ba72:	fd 4f       	sbci	r31, 0xFD	; 253
    ba74:	80 81       	ld	r24, Z
    ba76:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    ba7a:	80 91 3f 02 	lds	r24, 0x023F
    ba7e:	8f 5f       	subi	r24, 0xFF	; 255
    ba80:	80 93 3f 02 	sts	0x023F, r24
    ba84:	70 91 3b 02 	lds	r23, 0x023B
    ba88:	60 91 3f 02 	lds	r22, 0x023F
    ba8c:	27 2f       	mov	r18, r23
    ba8e:	30 e0       	ldi	r19, 0x00	; 0
    ba90:	86 2f       	mov	r24, r22
    ba92:	90 e0       	ldi	r25, 0x00	; 0
    ba94:	28 17       	cp	r18, r24
    ba96:	39 07       	cpc	r19, r25
    ba98:	bc f6       	brge	.-82     	; 0xba48 <FMenuSettingClientIP+0x1d2>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    ba9a:	73 30       	cpi	r23, 0x03	; 3
    ba9c:	08 f4       	brcc	.+2      	; 0xbaa0 <FMenuSettingClientIP+0x22a>
    ba9e:	91 c0       	rjmp	.+290    	; 0xbbc2 <FMenuSettingClientIP+0x34c>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    baa0:	40 91 33 02 	lds	r20, 0x0233
    baa4:	50 91 34 02 	lds	r21, 0x0234
    baa8:	fa 01       	movw	r30, r20
    baaa:	e9 5c       	subi	r30, 0xC9	; 201
    baac:	fd 4f       	sbci	r31, 0xFD	; 253
    baae:	20 91 42 02 	lds	r18, 0x0242
    bab2:	20 5d       	subi	r18, 0xD0	; 208
    bab4:	80 91 40 02 	lds	r24, 0x0240
    bab8:	34 e6       	ldi	r19, 0x64	; 100
    baba:	83 9f       	mul	r24, r19
    babc:	c0 01       	movw	r24, r0
    babe:	11 24       	eor	r1, r1
    bac0:	28 0f       	add	r18, r24
    bac2:	80 91 41 02 	lds	r24, 0x0241
    bac6:	3a e0       	ldi	r19, 0x0A	; 10
    bac8:	83 9f       	mul	r24, r19
    baca:	c0 01       	movw	r24, r0
    bacc:	11 24       	eor	r1, r1
    bace:	28 0f       	add	r18, r24
    bad0:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    bad2:	80 e3       	ldi	r24, 0x30	; 48
    bad4:	80 93 40 02 	sts	0x0240, r24
    bad8:	80 93 41 02 	sts	0x0241, r24
    badc:	80 93 42 02 	sts	0x0242, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    bae0:	44 0f       	add	r20, r20
    bae2:	55 1f       	adc	r21, r21
    bae4:	44 0f       	add	r20, r20
    bae6:	55 1f       	adc	r21, r21
    bae8:	60 91 3d 02 	lds	r22, 0x023D
    baec:	64 0f       	add	r22, r20
    baee:	67 1b       	sub	r22, r23
    baf0:	80 91 3c 02 	lds	r24, 0x023C
    baf4:	49 eb       	ldi	r20, 0xB9	; 185
    baf6:	54 e1       	ldi	r21, 0x14	; 20
    baf8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    bafc:	00 d0       	rcall	.+0      	; 0xbafe <FMenuSettingClientIP+0x288>
    bafe:	00 d0       	rcall	.+0      	; 0xbb00 <FMenuSettingClientIP+0x28a>
    bb00:	00 d0       	rcall	.+0      	; 0xbb02 <FMenuSettingClientIP+0x28c>
    bb02:	ad b7       	in	r26, 0x3d	; 61
    bb04:	be b7       	in	r27, 0x3e	; 62
    bb06:	11 96       	adiw	r26, 0x01	; 1
    bb08:	8e 01       	movw	r16, r28
    bb0a:	0f 5f       	subi	r16, 0xFF	; 255
    bb0c:	1f 4f       	sbci	r17, 0xFF	; 255
    bb0e:	ed b7       	in	r30, 0x3d	; 61
    bb10:	fe b7       	in	r31, 0x3e	; 62
    bb12:	12 83       	std	Z+2, r17	; 0x02
    bb14:	01 83       	std	Z+1, r16	; 0x01
    bb16:	86 eb       	ldi	r24, 0xB6	; 182
    bb18:	94 e1       	ldi	r25, 0x14	; 20
    bb1a:	13 96       	adiw	r26, 0x03	; 3
    bb1c:	9c 93       	st	X, r25
    bb1e:	8e 93       	st	-X, r24
    bb20:	12 97       	sbiw	r26, 0x02	; 2
    bb22:	e0 91 33 02 	lds	r30, 0x0233
    bb26:	f0 91 34 02 	lds	r31, 0x0234
    bb2a:	e9 5c       	subi	r30, 0xC9	; 201
    bb2c:	fd 4f       	sbci	r31, 0xFD	; 253
    bb2e:	80 81       	ld	r24, Z
    bb30:	14 96       	adiw	r26, 0x04	; 4
    bb32:	8c 93       	st	X, r24
    bb34:	14 97       	sbiw	r26, 0x04	; 4
    bb36:	15 96       	adiw	r26, 0x05	; 5
    bb38:	1c 92       	st	X, r1
    bb3a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    bb3e:	f8 01       	movw	r30, r16
    bb40:	01 90       	ld	r0, Z+
    bb42:	00 20       	and	r0, r0
    bb44:	e9 f7       	brne	.-6      	; 0xbb40 <FMenuSettingClientIP+0x2ca>
    bb46:	31 97       	sbiw	r30, 0x01	; 1
    bb48:	e0 1b       	sub	r30, r16
    bb4a:	f1 0b       	sbc	r31, r17
    bb4c:	8d b7       	in	r24, 0x3d	; 61
    bb4e:	9e b7       	in	r25, 0x3e	; 62
    bb50:	06 96       	adiw	r24, 0x06	; 6
    bb52:	0f b6       	in	r0, 0x3f	; 63
    bb54:	f8 94       	cli
    bb56:	9e bf       	out	0x3e, r25	; 62
    bb58:	0f be       	out	0x3f, r0	; 63
    bb5a:	8d bf       	out	0x3d, r24	; 61
    bb5c:	60 91 3d 02 	lds	r22, 0x023D
    bb60:	6f 5f       	subi	r22, 0xFF	; 255
    bb62:	80 91 33 02 	lds	r24, 0x0233
    bb66:	90 91 34 02 	lds	r25, 0x0234
    bb6a:	88 0f       	add	r24, r24
    bb6c:	99 1f       	adc	r25, r25
    bb6e:	88 0f       	add	r24, r24
    bb70:	99 1f       	adc	r25, r25
    bb72:	68 0f       	add	r22, r24
    bb74:	6e 1b       	sub	r22, r30
    bb76:	80 91 3c 02 	lds	r24, 0x023C
    bb7a:	a8 01       	movw	r20, r16
    bb7c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    bb80:	80 91 33 02 	lds	r24, 0x0233
    bb84:	90 91 34 02 	lds	r25, 0x0234
    bb88:	00 97       	sbiw	r24, 0x00	; 0
    bb8a:	81 f0       	breq	.+32     	; 0xbbac <FMenuSettingClientIP+0x336>
    bb8c:	60 91 3d 02 	lds	r22, 0x023D
    bb90:	6f 5f       	subi	r22, 0xFF	; 255
    bb92:	81 50       	subi	r24, 0x01	; 1
    bb94:	90 4c       	sbci	r25, 0xC0	; 192
    bb96:	88 0f       	add	r24, r24
    bb98:	99 1f       	adc	r25, r25
    bb9a:	88 0f       	add	r24, r24
    bb9c:	99 1f       	adc	r25, r25
    bb9e:	68 0f       	add	r22, r24
    bba0:	80 91 3c 02 	lds	r24, 0x023C
    bba4:	44 eb       	ldi	r20, 0xB4	; 180
    bba6:	54 e1       	ldi	r21, 0x14	; 20
    bba8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					   iInput=0;
    bbac:	10 92 3b 02 	sts	0x023B, r1
					   iBlok++;
    bbb0:	80 91 33 02 	lds	r24, 0x0233
    bbb4:	90 91 34 02 	lds	r25, 0x0234
    bbb8:	01 96       	adiw	r24, 0x01	; 1
    bbba:	90 93 34 02 	sts	0x0234, r25
    bbbe:	80 93 33 02 	sts	0x0233, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    bbc2:	80 91 33 02 	lds	r24, 0x0233
    bbc6:	90 91 34 02 	lds	r25, 0x0234
    bbca:	04 97       	sbiw	r24, 0x04	; 4
    bbcc:	18 f0       	brcs	.+6      	; 0xbbd4 <FMenuSettingClientIP+0x35e>
    bbce:	84 e0       	ldi	r24, 0x04	; 4
    bbd0:	80 93 59 01 	sts	0x0159, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    bbd4:	97 ee       	ldi	r25, 0xE7	; 231
    bbd6:	f9 16       	cp	r15, r25
    bbd8:	09 f4       	brne	.+2      	; 0xbbdc <FMenuSettingClientIP+0x366>
    bbda:	c4 c0       	rjmp	.+392    	; 0xbd64 <FMenuSettingClientIP+0x4ee>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    bbdc:	a7 eb       	ldi	r26, 0xB7	; 183
    bbde:	fa 16       	cp	r15, r26
    bbe0:	09 f0       	breq	.+2      	; 0xbbe4 <FMenuSettingClientIP+0x36e>
    bbe2:	c9 c0       	rjmp	.+402    	; 0xbd76 <FMenuSettingClientIP+0x500>
			       //NextInput
			       if (iBlok<4){
    bbe4:	40 91 33 02 	lds	r20, 0x0233
    bbe8:	50 91 34 02 	lds	r21, 0x0234
    bbec:	44 30       	cpi	r20, 0x04	; 4
    bbee:	51 05       	cpc	r21, r1
    bbf0:	08 f0       	brcs	.+2      	; 0xbbf4 <FMenuSettingClientIP+0x37e>
    bbf2:	a6 c0       	rjmp	.+332    	; 0xbd40 <FMenuSettingClientIP+0x4ca>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    bbf4:	80 91 3b 02 	lds	r24, 0x023B
    bbf8:	81 30       	cpi	r24, 0x01	; 1
    bbfa:	41 f4       	brne	.+16     	; 0xbc0c <FMenuSettingClientIP+0x396>
    bbfc:	fa 01       	movw	r30, r20
    bbfe:	e9 5c       	subi	r30, 0xC9	; 201
    bc00:	fd 4f       	sbci	r31, 0xFD	; 253
    bc02:	80 91 40 02 	lds	r24, 0x0240
    bc06:	80 53       	subi	r24, 0x30	; 48
    bc08:	80 83       	st	Z, r24
    bc0a:	22 c0       	rjmp	.+68     	; 0xbc50 <FMenuSettingClientIP+0x3da>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    bc0c:	82 30       	cpi	r24, 0x02	; 2
    bc0e:	49 f4       	brne	.+18     	; 0xbc22 <FMenuSettingClientIP+0x3ac>
    bc10:	fa 01       	movw	r30, r20
    bc12:	e9 5c       	subi	r30, 0xC9	; 201
    bc14:	fd 4f       	sbci	r31, 0xFD	; 253
    bc16:	20 91 41 02 	lds	r18, 0x0241
    bc1a:	20 51       	subi	r18, 0x10	; 16
    bc1c:	80 91 40 02 	lds	r24, 0x0240
    bc20:	11 c0       	rjmp	.+34     	; 0xbc44 <FMenuSettingClientIP+0x3ce>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    bc22:	83 30       	cpi	r24, 0x03	; 3
    bc24:	a9 f4       	brne	.+42     	; 0xbc50 <FMenuSettingClientIP+0x3da>
    bc26:	fa 01       	movw	r30, r20
    bc28:	e9 5c       	subi	r30, 0xC9	; 201
    bc2a:	fd 4f       	sbci	r31, 0xFD	; 253
    bc2c:	20 91 42 02 	lds	r18, 0x0242
    bc30:	20 5d       	subi	r18, 0xD0	; 208
    bc32:	80 91 40 02 	lds	r24, 0x0240
    bc36:	34 e6       	ldi	r19, 0x64	; 100
    bc38:	83 9f       	mul	r24, r19
    bc3a:	c0 01       	movw	r24, r0
    bc3c:	11 24       	eor	r1, r1
    bc3e:	28 0f       	add	r18, r24
    bc40:	80 91 41 02 	lds	r24, 0x0241
    bc44:	3a e0       	ldi	r19, 0x0A	; 10
    bc46:	83 9f       	mul	r24, r19
    bc48:	c0 01       	movw	r24, r0
    bc4a:	11 24       	eor	r1, r1
    bc4c:	28 0f       	add	r18, r24
    bc4e:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    bc50:	80 e3       	ldi	r24, 0x30	; 48
    bc52:	80 93 40 02 	sts	0x0240, r24
    bc56:	80 93 41 02 	sts	0x0241, r24
    bc5a:	80 93 42 02 	sts	0x0242, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    bc5e:	60 91 3d 02 	lds	r22, 0x023D
    bc62:	63 50       	subi	r22, 0x03	; 3
    bc64:	44 0f       	add	r20, r20
    bc66:	55 1f       	adc	r21, r21
    bc68:	44 0f       	add	r20, r20
    bc6a:	55 1f       	adc	r21, r21
    bc6c:	64 0f       	add	r22, r20
    bc6e:	80 91 3c 02 	lds	r24, 0x023C
    bc72:	40 eb       	ldi	r20, 0xB0	; 176
    bc74:	54 e1       	ldi	r21, 0x14	; 20
    bc76:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    bc7a:	00 d0       	rcall	.+0      	; 0xbc7c <FMenuSettingClientIP+0x406>
    bc7c:	00 d0       	rcall	.+0      	; 0xbc7e <FMenuSettingClientIP+0x408>
    bc7e:	00 d0       	rcall	.+0      	; 0xbc80 <FMenuSettingClientIP+0x40a>
    bc80:	ad b7       	in	r26, 0x3d	; 61
    bc82:	be b7       	in	r27, 0x3e	; 62
    bc84:	11 96       	adiw	r26, 0x01	; 1
    bc86:	8e 01       	movw	r16, r28
    bc88:	0f 5f       	subi	r16, 0xFF	; 255
    bc8a:	1f 4f       	sbci	r17, 0xFF	; 255
    bc8c:	ed b7       	in	r30, 0x3d	; 61
    bc8e:	fe b7       	in	r31, 0x3e	; 62
    bc90:	12 83       	std	Z+2, r17	; 0x02
    bc92:	01 83       	std	Z+1, r16	; 0x01
    bc94:	8d ea       	ldi	r24, 0xAD	; 173
    bc96:	94 e1       	ldi	r25, 0x14	; 20
    bc98:	13 96       	adiw	r26, 0x03	; 3
    bc9a:	9c 93       	st	X, r25
    bc9c:	8e 93       	st	-X, r24
    bc9e:	12 97       	sbiw	r26, 0x02	; 2
    bca0:	e0 91 33 02 	lds	r30, 0x0233
    bca4:	f0 91 34 02 	lds	r31, 0x0234
    bca8:	e9 5c       	subi	r30, 0xC9	; 201
    bcaa:	fd 4f       	sbci	r31, 0xFD	; 253
    bcac:	80 81       	ld	r24, Z
    bcae:	14 96       	adiw	r26, 0x04	; 4
    bcb0:	8c 93       	st	X, r24
    bcb2:	14 97       	sbiw	r26, 0x04	; 4
    bcb4:	15 96       	adiw	r26, 0x05	; 5
    bcb6:	1c 92       	st	X, r1
    bcb8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    bcbc:	f8 01       	movw	r30, r16
    bcbe:	01 90       	ld	r0, Z+
    bcc0:	00 20       	and	r0, r0
    bcc2:	e9 f7       	brne	.-6      	; 0xbcbe <FMenuSettingClientIP+0x448>
    bcc4:	31 97       	sbiw	r30, 0x01	; 1
    bcc6:	e0 1b       	sub	r30, r16
    bcc8:	f1 0b       	sbc	r31, r17
    bcca:	8d b7       	in	r24, 0x3d	; 61
    bccc:	9e b7       	in	r25, 0x3e	; 62
    bcce:	06 96       	adiw	r24, 0x06	; 6
    bcd0:	0f b6       	in	r0, 0x3f	; 63
    bcd2:	f8 94       	cli
    bcd4:	9e bf       	out	0x3e, r25	; 62
    bcd6:	0f be       	out	0x3f, r0	; 63
    bcd8:	8d bf       	out	0x3d, r24	; 61
    bcda:	60 91 3d 02 	lds	r22, 0x023D
    bcde:	6f 5f       	subi	r22, 0xFF	; 255
    bce0:	80 91 33 02 	lds	r24, 0x0233
    bce4:	90 91 34 02 	lds	r25, 0x0234
    bce8:	88 0f       	add	r24, r24
    bcea:	99 1f       	adc	r25, r25
    bcec:	88 0f       	add	r24, r24
    bcee:	99 1f       	adc	r25, r25
    bcf0:	68 0f       	add	r22, r24
    bcf2:	6e 1b       	sub	r22, r30
    bcf4:	80 91 3c 02 	lds	r24, 0x023C
    bcf8:	a8 01       	movw	r20, r16
    bcfa:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    bcfe:	80 91 33 02 	lds	r24, 0x0233
    bd02:	90 91 34 02 	lds	r25, 0x0234
    bd06:	00 97       	sbiw	r24, 0x00	; 0
    bd08:	81 f0       	breq	.+32     	; 0xbd2a <FMenuSettingClientIP+0x4b4>
    bd0a:	60 91 3d 02 	lds	r22, 0x023D
    bd0e:	6f 5f       	subi	r22, 0xFF	; 255
    bd10:	81 50       	subi	r24, 0x01	; 1
    bd12:	90 4c       	sbci	r25, 0xC0	; 192
    bd14:	88 0f       	add	r24, r24
    bd16:	99 1f       	adc	r25, r25
    bd18:	88 0f       	add	r24, r24
    bd1a:	99 1f       	adc	r25, r25
    bd1c:	68 0f       	add	r22, r24
    bd1e:	80 91 3c 02 	lds	r24, 0x023C
    bd22:	4b ea       	ldi	r20, 0xAB	; 171
    bd24:	54 e1       	ldi	r21, 0x14	; 20
    bd26:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				       iInput=0;
    bd2a:	10 92 3b 02 	sts	0x023B, r1
					   iBlok++;	   
    bd2e:	80 91 33 02 	lds	r24, 0x0233
    bd32:	90 91 34 02 	lds	r25, 0x0234
    bd36:	01 96       	adiw	r24, 0x01	; 1
    bd38:	90 93 34 02 	sts	0x0234, r25
    bd3c:	80 93 33 02 	sts	0x0233, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    bd40:	80 91 33 02 	lds	r24, 0x0233
    bd44:	90 91 34 02 	lds	r25, 0x0234
    bd48:	04 97       	sbiw	r24, 0x04	; 4
    bd4a:	a8 f0       	brcs	.+42     	; 0xbd76 <FMenuSettingClientIP+0x500>
    bd4c:	84 e0       	ldi	r24, 0x04	; 4
    bd4e:	0b c0       	rjmp	.+22     	; 0xbd66 <FMenuSettingClientIP+0x4f0>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    bd50:	88 e2       	ldi	r24, 0x28	; 40
    bd52:	90 e0       	ldi	r25, 0x00	; 0
    bd54:	67 e3       	ldi	r22, 0x37	; 55
    bd56:	72 e0       	ldi	r23, 0x02	; 2
    bd58:	44 e0       	ldi	r20, 0x04	; 4
    bd5a:	50 e0       	ldi	r21, 0x00	; 0
    bd5c:	2a ed       	ldi	r18, 0xDA	; 218
    bd5e:	33 e1       	ldi	r19, 0x13	; 19
    bd60:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    bd64:	83 e0       	ldi	r24, 0x03	; 3
    bd66:	80 93 59 01 	sts	0x0159, r24
    bd6a:	05 c0       	rjmp	.+10     	; 0xbd76 <FMenuSettingClientIP+0x500>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    bd6c:	81 e0       	ldi	r24, 0x01	; 1
    bd6e:	80 93 59 01 	sts	0x0159, r24
		       Result=MENU_DONE;
    bd72:	80 93 3e 02 	sts	0x023E, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    bd76:	80 91 3e 02 	lds	r24, 0x023E
    bd7a:	64 96       	adiw	r28, 0x14	; 20
    bd7c:	0f b6       	in	r0, 0x3f	; 63
    bd7e:	f8 94       	cli
    bd80:	de bf       	out	0x3e, r29	; 62
    bd82:	0f be       	out	0x3f, r0	; 63
    bd84:	cd bf       	out	0x3d, r28	; 61
    bd86:	cf 91       	pop	r28
    bd88:	df 91       	pop	r29
    bd8a:	1f 91       	pop	r17
    bd8c:	0f 91       	pop	r16
    bd8e:	ff 90       	pop	r15
    bd90:	08 95       	ret

0000bd92 <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    bd92:	df 93       	push	r29
    bd94:	cf 93       	push	r28
    bd96:	cd b7       	in	r28, 0x3d	; 61
    bd98:	de b7       	in	r29, 0x3e	; 62
    bd9a:	28 97       	sbiw	r28, 0x08	; 8
    bd9c:	0f b6       	in	r0, 0x3f	; 63
    bd9e:	f8 94       	cli
    bda0:	de bf       	out	0x3e, r29	; 62
    bda2:	0f be       	out	0x3f, r0	; 63
    bda4:	cd bf       	out	0x3d, r28	; 61
    bda6:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    bda8:	80 91 83 01 	lds	r24, 0x0183
    bdac:	88 23       	and	r24, r24
    bdae:	a1 f4       	brne	.+40     	; 0xbdd8 <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    bdb0:	3d e2       	ldi	r19, 0x2D	; 45
    bdb2:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    bdb4:	80 e6       	ldi	r24, 0x60	; 96
    bdb6:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    bdb8:	2c e7       	ldi	r18, 0x7C	; 124
    bdba:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    bdbc:	9f e2       	ldi	r25, 0x2F	; 47
    bdbe:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    bdc0:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    bdc2:	84 ea       	ldi	r24, 0xA4	; 164
    bdc4:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    bdc6:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    bdc8:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    bdca:	47 70       	andi	r20, 0x07	; 7
    bdcc:	fe 01       	movw	r30, r28
    bdce:	e4 0f       	add	r30, r20
    bdd0:	f1 1d       	adc	r31, r1
    bdd2:	85 2f       	mov	r24, r21
    bdd4:	41 81       	ldd	r20, Z+1	; 0x01
    bdd6:	08 c0       	rjmp	.+16     	; 0xbde8 <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    bdd8:	80 91 83 01 	lds	r24, 0x0183
    bddc:	81 30       	cpi	r24, 0x01	; 1
    bdde:	31 f4       	brne	.+12     	; 0xbdec <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    bde0:	10 92 83 01 	sts	0x0183, r1
	          lcd_put(x,y,'X');     
    bde4:	85 2f       	mov	r24, r21
    bde6:	48 e5       	ldi	r20, 0x58	; 88
    bde8:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			  }

}
    bdec:	28 96       	adiw	r28, 0x08	; 8
    bdee:	0f b6       	in	r0, 0x3f	; 63
    bdf0:	f8 94       	cli
    bdf2:	de bf       	out	0x3e, r29	; 62
    bdf4:	0f be       	out	0x3f, r0	; 63
    bdf6:	cd bf       	out	0x3d, r28	; 61
    bdf8:	cf 91       	pop	r28
    bdfa:	df 91       	pop	r29
    bdfc:	08 95       	ret

0000bdfe <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    bdfe:	0f 93       	push	r16
    be00:	1f 93       	push	r17
    be02:	df 93       	push	r29
    be04:	cf 93       	push	r28
    be06:	cd b7       	in	r28, 0x3d	; 61
    be08:	de b7       	in	r29, 0x3e	; 62
    be0a:	6a 97       	sbiw	r28, 0x1a	; 26
    be0c:	0f b6       	in	r0, 0x3f	; 63
    be0e:	f8 94       	cli
    be10:	de bf       	out	0x3e, r29	; 62
    be12:	0f be       	out	0x3f, r0	; 63
    be14:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
	   char i,lcdteks[20];
	   char KeyChar,Addr=0,PPoolingSetting[6];
     
	 Result=MENU_NONE;
     switch(stPumpPooling){
    be16:	80 91 1b 02 	lds	r24, 0x021B
    be1a:	82 30       	cpi	r24, 0x02	; 2
    be1c:	09 f4       	brne	.+2      	; 0xbe20 <FSettingPumpPooling+0x22>
    be1e:	1b c1       	rjmp	.+566    	; 0xc056 <FSettingPumpPooling+0x258>
    be20:	83 30       	cpi	r24, 0x03	; 3
    be22:	30 f4       	brcc	.+12     	; 0xbe30 <FSettingPumpPooling+0x32>
    be24:	88 23       	and	r24, r24
    be26:	59 f0       	breq	.+22     	; 0xbe3e <FSettingPumpPooling+0x40>
    be28:	81 30       	cpi	r24, 0x01	; 1
    be2a:	09 f0       	breq	.+2      	; 0xbe2e <FSettingPumpPooling+0x30>
    be2c:	17 c2       	rjmp	.+1070   	; 0xc25c <FSettingPumpPooling+0x45e>
    be2e:	09 c1       	rjmp	.+530    	; 0xc042 <FSettingPumpPooling+0x244>
    be30:	83 30       	cpi	r24, 0x03	; 3
    be32:	09 f4       	brne	.+2      	; 0xbe36 <FSettingPumpPooling+0x38>
    be34:	04 c2       	rjmp	.+1032   	; 0xc23e <FSettingPumpPooling+0x440>
    be36:	84 30       	cpi	r24, 0x04	; 4
    be38:	09 f0       	breq	.+2      	; 0xbe3c <FSettingPumpPooling+0x3e>
    be3a:	10 c2       	rjmp	.+1056   	; 0xc25c <FSettingPumpPooling+0x45e>
    be3c:	0b c2       	rjmp	.+1046   	; 0xc254 <FSettingPumpPooling+0x456>
	 case ppInitMenu:
          lcd_clear();
    be3e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    be42:	20 e0       	ldi	r18, 0x00	; 0
    be44:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    be46:	ae 01       	movw	r20, r28
    be48:	4f 5f       	subi	r20, 0xFF	; 255
    be4a:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    be4c:	e1 99       	sbic	0x1c, 1	; 28
    be4e:	fe cf       	rjmp	.-4      	; 0xbe4c <FSettingPumpPooling+0x4e>
    be50:	c9 01       	movw	r24, r18
    be52:	8c 5b       	subi	r24, 0xBC	; 188
    be54:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    be56:	9f bb       	out	0x1f, r25	; 31
    be58:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    be5a:	e0 9a       	sbi	0x1c, 0	; 28
    be5c:	8d b3       	in	r24, 0x1d	; 29
    be5e:	fa 01       	movw	r30, r20
    be60:	e2 0f       	add	r30, r18
    be62:	f3 1f       	adc	r31, r19
    be64:	80 83       	st	Z, r24
    be66:	2f 5f       	subi	r18, 0xFF	; 255
    be68:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 Result=MENU_NONE;
     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    be6a:	26 30       	cpi	r18, 0x06	; 6
    be6c:	31 05       	cpc	r19, r1
    be6e:	71 f7       	brne	.-36     	; 0xbe4c <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    be70:	00 d0       	rcall	.+0      	; 0xbe72 <FSettingPumpPooling+0x74>
    be72:	00 d0       	rcall	.+0      	; 0xbe74 <FSettingPumpPooling+0x76>
    be74:	00 d0       	rcall	.+0      	; 0xbe76 <FSettingPumpPooling+0x78>
    be76:	ed b7       	in	r30, 0x3d	; 61
    be78:	fe b7       	in	r31, 0x3e	; 62
    be7a:	31 96       	adiw	r30, 0x01	; 1
    be7c:	8e 01       	movw	r16, r28
    be7e:	09 5f       	subi	r16, 0xF9	; 249
    be80:	1f 4f       	sbci	r17, 0xFF	; 255
    be82:	ad b7       	in	r26, 0x3d	; 61
    be84:	be b7       	in	r27, 0x3e	; 62
    be86:	12 96       	adiw	r26, 0x02	; 2
    be88:	1c 93       	st	X, r17
    be8a:	0e 93       	st	-X, r16
    be8c:	11 97       	sbiw	r26, 0x01	; 1
    be8e:	8f e2       	ldi	r24, 0x2F	; 47
    be90:	9f e0       	ldi	r25, 0x0F	; 15
    be92:	93 83       	std	Z+3, r25	; 0x03
    be94:	82 83       	std	Z+2, r24	; 0x02
    be96:	89 81       	ldd	r24, Y+1	; 0x01
    be98:	84 83       	std	Z+4, r24	; 0x04
    be9a:	15 82       	std	Z+5, r1	; 0x05
    be9c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    bea0:	ed b7       	in	r30, 0x3d	; 61
    bea2:	fe b7       	in	r31, 0x3e	; 62
    bea4:	36 96       	adiw	r30, 0x06	; 6
    bea6:	0f b6       	in	r0, 0x3f	; 63
    bea8:	f8 94       	cli
    beaa:	fe bf       	out	0x3e, r31	; 62
    beac:	0f be       	out	0x3f, r0	; 63
    beae:	ed bf       	out	0x3d, r30	; 61
    beb0:	81 e0       	ldi	r24, 0x01	; 1
    beb2:	61 e0       	ldi	r22, 0x01	; 1
    beb4:	a8 01       	movw	r20, r16
    beb6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    beba:	00 d0       	rcall	.+0      	; 0xbebc <FSettingPumpPooling+0xbe>
    bebc:	00 d0       	rcall	.+0      	; 0xbebe <FSettingPumpPooling+0xc0>
    bebe:	00 d0       	rcall	.+0      	; 0xbec0 <FSettingPumpPooling+0xc2>
    bec0:	ed b7       	in	r30, 0x3d	; 61
    bec2:	fe b7       	in	r31, 0x3e	; 62
    bec4:	31 96       	adiw	r30, 0x01	; 1
    bec6:	ad b7       	in	r26, 0x3d	; 61
    bec8:	be b7       	in	r27, 0x3e	; 62
    beca:	12 96       	adiw	r26, 0x02	; 2
    becc:	1c 93       	st	X, r17
    bece:	0e 93       	st	-X, r16
    bed0:	11 97       	sbiw	r26, 0x01	; 1
    bed2:	82 e2       	ldi	r24, 0x22	; 34
    bed4:	9f e0       	ldi	r25, 0x0F	; 15
    bed6:	93 83       	std	Z+3, r25	; 0x03
    bed8:	82 83       	std	Z+2, r24	; 0x02
    beda:	8a 81       	ldd	r24, Y+2	; 0x02
    bedc:	84 83       	std	Z+4, r24	; 0x04
    bede:	15 82       	std	Z+5, r1	; 0x05
    bee0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    bee4:	ed b7       	in	r30, 0x3d	; 61
    bee6:	fe b7       	in	r31, 0x3e	; 62
    bee8:	36 96       	adiw	r30, 0x06	; 6
    beea:	0f b6       	in	r0, 0x3f	; 63
    beec:	f8 94       	cli
    beee:	fe bf       	out	0x3e, r31	; 62
    bef0:	0f be       	out	0x3f, r0	; 63
    bef2:	ed bf       	out	0x3d, r30	; 61
    bef4:	82 e0       	ldi	r24, 0x02	; 2
    bef6:	61 e0       	ldi	r22, 0x01	; 1
    bef8:	a8 01       	movw	r20, r16
    befa:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    befe:	00 d0       	rcall	.+0      	; 0xbf00 <FSettingPumpPooling+0x102>
    bf00:	00 d0       	rcall	.+0      	; 0xbf02 <FSettingPumpPooling+0x104>
    bf02:	00 d0       	rcall	.+0      	; 0xbf04 <FSettingPumpPooling+0x106>
    bf04:	ed b7       	in	r30, 0x3d	; 61
    bf06:	fe b7       	in	r31, 0x3e	; 62
    bf08:	31 96       	adiw	r30, 0x01	; 1
    bf0a:	ad b7       	in	r26, 0x3d	; 61
    bf0c:	be b7       	in	r27, 0x3e	; 62
    bf0e:	12 96       	adiw	r26, 0x02	; 2
    bf10:	1c 93       	st	X, r17
    bf12:	0e 93       	st	-X, r16
    bf14:	11 97       	sbiw	r26, 0x01	; 1
    bf16:	85 e1       	ldi	r24, 0x15	; 21
    bf18:	9f e0       	ldi	r25, 0x0F	; 15
    bf1a:	93 83       	std	Z+3, r25	; 0x03
    bf1c:	82 83       	std	Z+2, r24	; 0x02
    bf1e:	8b 81       	ldd	r24, Y+3	; 0x03
    bf20:	84 83       	std	Z+4, r24	; 0x04
    bf22:	15 82       	std	Z+5, r1	; 0x05
    bf24:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    bf28:	ed b7       	in	r30, 0x3d	; 61
    bf2a:	fe b7       	in	r31, 0x3e	; 62
    bf2c:	36 96       	adiw	r30, 0x06	; 6
    bf2e:	0f b6       	in	r0, 0x3f	; 63
    bf30:	f8 94       	cli
    bf32:	fe bf       	out	0x3e, r31	; 62
    bf34:	0f be       	out	0x3f, r0	; 63
    bf36:	ed bf       	out	0x3d, r30	; 61
    bf38:	83 e0       	ldi	r24, 0x03	; 3
    bf3a:	61 e0       	ldi	r22, 0x01	; 1
    bf3c:	a8 01       	movw	r20, r16
    bf3e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    bf42:	00 d0       	rcall	.+0      	; 0xbf44 <FSettingPumpPooling+0x146>
    bf44:	00 d0       	rcall	.+0      	; 0xbf46 <FSettingPumpPooling+0x148>
    bf46:	00 d0       	rcall	.+0      	; 0xbf48 <FSettingPumpPooling+0x14a>
    bf48:	ed b7       	in	r30, 0x3d	; 61
    bf4a:	fe b7       	in	r31, 0x3e	; 62
    bf4c:	31 96       	adiw	r30, 0x01	; 1
    bf4e:	ad b7       	in	r26, 0x3d	; 61
    bf50:	be b7       	in	r27, 0x3e	; 62
    bf52:	12 96       	adiw	r26, 0x02	; 2
    bf54:	1c 93       	st	X, r17
    bf56:	0e 93       	st	-X, r16
    bf58:	11 97       	sbiw	r26, 0x01	; 1
    bf5a:	88 e0       	ldi	r24, 0x08	; 8
    bf5c:	9f e0       	ldi	r25, 0x0F	; 15
    bf5e:	93 83       	std	Z+3, r25	; 0x03
    bf60:	82 83       	std	Z+2, r24	; 0x02
    bf62:	8c 81       	ldd	r24, Y+4	; 0x04
    bf64:	84 83       	std	Z+4, r24	; 0x04
    bf66:	15 82       	std	Z+5, r1	; 0x05
    bf68:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    bf6c:	ed b7       	in	r30, 0x3d	; 61
    bf6e:	fe b7       	in	r31, 0x3e	; 62
    bf70:	36 96       	adiw	r30, 0x06	; 6
    bf72:	0f b6       	in	r0, 0x3f	; 63
    bf74:	f8 94       	cli
    bf76:	fe bf       	out	0x3e, r31	; 62
    bf78:	0f be       	out	0x3f, r0	; 63
    bf7a:	ed bf       	out	0x3d, r30	; 61
    bf7c:	84 e0       	ldi	r24, 0x04	; 4
    bf7e:	61 e0       	ldi	r22, 0x01	; 1
    bf80:	a8 01       	movw	r20, r16
    bf82:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    bf86:	00 d0       	rcall	.+0      	; 0xbf88 <FSettingPumpPooling+0x18a>
    bf88:	00 d0       	rcall	.+0      	; 0xbf8a <FSettingPumpPooling+0x18c>
    bf8a:	00 d0       	rcall	.+0      	; 0xbf8c <FSettingPumpPooling+0x18e>
    bf8c:	ed b7       	in	r30, 0x3d	; 61
    bf8e:	fe b7       	in	r31, 0x3e	; 62
    bf90:	31 96       	adiw	r30, 0x01	; 1
    bf92:	ad b7       	in	r26, 0x3d	; 61
    bf94:	be b7       	in	r27, 0x3e	; 62
    bf96:	12 96       	adiw	r26, 0x02	; 2
    bf98:	1c 93       	st	X, r17
    bf9a:	0e 93       	st	-X, r16
    bf9c:	11 97       	sbiw	r26, 0x01	; 1
    bf9e:	8f ef       	ldi	r24, 0xFF	; 255
    bfa0:	9e e0       	ldi	r25, 0x0E	; 14
    bfa2:	93 83       	std	Z+3, r25	; 0x03
    bfa4:	82 83       	std	Z+2, r24	; 0x02
    bfa6:	8d 81       	ldd	r24, Y+5	; 0x05
    bfa8:	84 83       	std	Z+4, r24	; 0x04
    bfaa:	15 82       	std	Z+5, r1	; 0x05
    bfac:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    bfb0:	ed b7       	in	r30, 0x3d	; 61
    bfb2:	fe b7       	in	r31, 0x3e	; 62
    bfb4:	36 96       	adiw	r30, 0x06	; 6
    bfb6:	0f b6       	in	r0, 0x3f	; 63
    bfb8:	f8 94       	cli
    bfba:	fe bf       	out	0x3e, r31	; 62
    bfbc:	0f be       	out	0x3f, r0	; 63
    bfbe:	ed bf       	out	0x3d, r30	; 61
    bfc0:	81 e0       	ldi	r24, 0x01	; 1
    bfc2:	6d e0       	ldi	r22, 0x0D	; 13
    bfc4:	a8 01       	movw	r20, r16
    bfc6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    bfca:	00 d0       	rcall	.+0      	; 0xbfcc <FSettingPumpPooling+0x1ce>
    bfcc:	00 d0       	rcall	.+0      	; 0xbfce <FSettingPumpPooling+0x1d0>
    bfce:	00 d0       	rcall	.+0      	; 0xbfd0 <FSettingPumpPooling+0x1d2>
    bfd0:	ed b7       	in	r30, 0x3d	; 61
    bfd2:	fe b7       	in	r31, 0x3e	; 62
    bfd4:	31 96       	adiw	r30, 0x01	; 1
    bfd6:	ad b7       	in	r26, 0x3d	; 61
    bfd8:	be b7       	in	r27, 0x3e	; 62
    bfda:	12 96       	adiw	r26, 0x02	; 2
    bfdc:	1c 93       	st	X, r17
    bfde:	0e 93       	st	-X, r16
    bfe0:	11 97       	sbiw	r26, 0x01	; 1
    bfe2:	86 ef       	ldi	r24, 0xF6	; 246
    bfe4:	9e e0       	ldi	r25, 0x0E	; 14
    bfe6:	93 83       	std	Z+3, r25	; 0x03
    bfe8:	82 83       	std	Z+2, r24	; 0x02
    bfea:	8e 81       	ldd	r24, Y+6	; 0x06
    bfec:	84 83       	std	Z+4, r24	; 0x04
    bfee:	15 82       	std	Z+5, r1	; 0x05
    bff0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    bff4:	ed b7       	in	r30, 0x3d	; 61
    bff6:	fe b7       	in	r31, 0x3e	; 62
    bff8:	36 96       	adiw	r30, 0x06	; 6
    bffa:	0f b6       	in	r0, 0x3f	; 63
    bffc:	f8 94       	cli
    bffe:	fe bf       	out	0x3e, r31	; 62
    c000:	0f be       	out	0x3f, r0	; 63
    c002:	ed bf       	out	0x3d, r30	; 61
    c004:	82 e0       	ldi	r24, 0x02	; 2
    c006:	6d e0       	ldi	r22, 0x0D	; 13
    c008:	a8 01       	movw	r20, r16
    c00a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    c00e:	00 d0       	rcall	.+0      	; 0xc010 <FSettingPumpPooling+0x212>
    c010:	00 d0       	rcall	.+0      	; 0xc012 <FSettingPumpPooling+0x214>
    c012:	ad b7       	in	r26, 0x3d	; 61
    c014:	be b7       	in	r27, 0x3e	; 62
    c016:	12 96       	adiw	r26, 0x02	; 2
    c018:	1c 93       	st	X, r17
    c01a:	0e 93       	st	-X, r16
    c01c:	11 97       	sbiw	r26, 0x01	; 1
    c01e:	8e ee       	ldi	r24, 0xEE	; 238
    c020:	9e e0       	ldi	r25, 0x0E	; 14
    c022:	14 96       	adiw	r26, 0x04	; 4
    c024:	9c 93       	st	X, r25
    c026:	8e 93       	st	-X, r24
    c028:	13 97       	sbiw	r26, 0x03	; 3
    c02a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    c02e:	0f 90       	pop	r0
    c030:	0f 90       	pop	r0
    c032:	0f 90       	pop	r0
    c034:	0f 90       	pop	r0
    c036:	84 e0       	ldi	r24, 0x04	; 4
    c038:	6d e0       	ldi	r22, 0x0D	; 13
    c03a:	a8 01       	movw	r20, r16
    c03c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    c040:	08 c0       	rjmp	.+16     	; 0xc052 <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    c042:	10 92 81 01 	sts	0x0181, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    c046:	83 e0       	ldi	r24, 0x03	; 3
    c048:	6e e0       	ldi	r22, 0x0E	; 14
    c04a:	40 91 80 01 	lds	r20, 0x0180
    c04e:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    c052:	82 e0       	ldi	r24, 0x02	; 2
    c054:	f1 c0       	rjmp	.+482    	; 0xc238 <FSettingPumpPooling+0x43a>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    c056:	80 91 81 01 	lds	r24, 0x0181
    c05a:	81 30       	cpi	r24, 0x01	; 1
    c05c:	11 f4       	brne	.+4      	; 0xc062 <FSettingPumpPooling+0x264>
    c05e:	80 93 1b 02 	sts	0x021B, r24

          KeyChar=_key_btn(_key_scan(1));
    c062:	81 e0       	ldi	r24, 0x01	; 1
    c064:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    c068:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    c06c:	48 2f       	mov	r20, r24
    c06e:	41 53       	subi	r20, 0x31	; 49
    c070:	46 30       	cpi	r20, 0x06	; 6
    c072:	10 f0       	brcs	.+4      	; 0xc078 <FSettingPumpPooling+0x27a>
    c074:	40 e0       	ldi	r20, 0x00	; 0
    c076:	04 c0       	rjmp	.+8      	; 0xc080 <FSettingPumpPooling+0x282>
		      Addr=KeyChar-'1';
			  TimSend=0;
    c078:	10 92 78 0c 	sts	0x0C78, r1
			  IsStandaloneAcknoledge=False;
    c07c:	10 92 82 01 	sts	0x0182, r1
          }
		  switch(KeyChar){
    c080:	83 33       	cpi	r24, 0x33	; 51
    c082:	09 f4       	brne	.+2      	; 0xc086 <FSettingPumpPooling+0x288>
    c084:	67 c0       	rjmp	.+206    	; 0xc154 <FSettingPumpPooling+0x356>
    c086:	84 33       	cpi	r24, 0x34	; 52
    c088:	48 f4       	brcc	.+18     	; 0xc09c <FSettingPumpPooling+0x29e>
    c08a:	81 33       	cpi	r24, 0x31	; 49
    c08c:	89 f0       	breq	.+34     	; 0xc0b0 <FSettingPumpPooling+0x2b2>
    c08e:	82 33       	cpi	r24, 0x32	; 50
    c090:	08 f0       	brcs	.+2      	; 0xc094 <FSettingPumpPooling+0x296>
    c092:	3d c0       	rjmp	.+122    	; 0xc10e <FSettingPumpPooling+0x310>
    c094:	8a 32       	cpi	r24, 0x2A	; 42
    c096:	09 f0       	breq	.+2      	; 0xc09a <FSettingPumpPooling+0x29c>
    c098:	e1 c0       	rjmp	.+450    	; 0xc25c <FSettingPumpPooling+0x45e>
    c09a:	cd c0       	rjmp	.+410    	; 0xc236 <FSettingPumpPooling+0x438>
    c09c:	85 33       	cpi	r24, 0x35	; 53
    c09e:	09 f4       	brne	.+2      	; 0xc0a2 <FSettingPumpPooling+0x2a4>
    c0a0:	91 c0       	rjmp	.+290    	; 0xc1c4 <FSettingPumpPooling+0x3c6>
    c0a2:	85 33       	cpi	r24, 0x35	; 53
    c0a4:	08 f4       	brcc	.+2      	; 0xc0a8 <FSettingPumpPooling+0x2aa>
    c0a6:	78 c0       	rjmp	.+240    	; 0xc198 <FSettingPumpPooling+0x39a>
    c0a8:	86 33       	cpi	r24, 0x36	; 54
    c0aa:	09 f0       	breq	.+2      	; 0xc0ae <FSettingPumpPooling+0x2b0>
    c0ac:	d7 c0       	rjmp	.+430    	; 0xc25c <FSettingPumpPooling+0x45e>
    c0ae:	a0 c0       	rjmp	.+320    	; 0xc1f0 <FSettingPumpPooling+0x3f2>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    c0b0:	24 2f       	mov	r18, r20
    c0b2:	30 e0       	ldi	r19, 0x00	; 0
    c0b4:	fe 01       	movw	r30, r28
    c0b6:	31 96       	adiw	r30, 0x01	; 1
    c0b8:	e2 0f       	add	r30, r18
    c0ba:	f3 1f       	adc	r31, r19
    c0bc:	80 81       	ld	r24, Z
    c0be:	90 e0       	ldi	r25, 0x00	; 0
    c0c0:	01 96       	adiw	r24, 0x01	; 1
    c0c2:	61 e1       	ldi	r22, 0x11	; 17
    c0c4:	70 e0       	ldi	r23, 0x00	; 0
    c0c6:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    c0ca:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    c0cc:	88 23       	and	r24, r24
    c0ce:	11 f4       	brne	.+4      	; 0xc0d4 <FSettingPumpPooling+0x2d6>
    c0d0:	81 e0       	ldi	r24, 0x01	; 1
    c0d2:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    c0d4:	2c 0f       	add	r18, r28
    c0d6:	3d 1f       	adc	r19, r29
    c0d8:	f9 01       	movw	r30, r18
    c0da:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c0dc:	85 e1       	ldi	r24, 0x15	; 21
    c0de:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    c0e2:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    c0e6:	81 e0       	ldi	r24, 0x01	; 1
    c0e8:	80 93 84 01 	sts	0x0184, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c0ec:	e1 99       	sbic	0x1c, 1	; 28
    c0ee:	fe cf       	rjmp	.-4      	; 0xc0ec <FSettingPumpPooling+0x2ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c0f0:	84 2f       	mov	r24, r20
    c0f2:	90 e0       	ldi	r25, 0x00	; 0
    c0f4:	8c 5b       	subi	r24, 0xBC	; 188
    c0f6:	9e 4f       	sbci	r25, 0xFE	; 254
    c0f8:	9f bb       	out	0x1f, r25	; 31
    c0fa:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c0fc:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    c0fe:	0f b6       	in	r0, 0x3f	; 63
    c100:	f8 94       	cli
    c102:	e2 9a       	sbi	0x1c, 2	; 28
    c104:	e1 9a       	sbi	0x1c, 1	; 28
    c106:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    c108:	20 93 5c 01 	sts	0x015C, r18
    c10c:	21 c0       	rjmp	.+66     	; 0xc150 <FSettingPumpPooling+0x352>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    c10e:	fe 01       	movw	r30, r28
    c110:	e4 0f       	add	r30, r20
    c112:	f1 1d       	adc	r31, r1
    c114:	81 81       	ldd	r24, Z+1	; 0x01
    c116:	90 e0       	ldi	r25, 0x00	; 0
    c118:	01 96       	adiw	r24, 0x01	; 1
    c11a:	65 e1       	ldi	r22, 0x15	; 21
    c11c:	70 e0       	ldi	r23, 0x00	; 0
    c11e:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    c122:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c124:	84 e1       	ldi	r24, 0x14	; 20
    c126:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    c12a:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    c12e:	81 e0       	ldi	r24, 0x01	; 1
    c130:	80 93 84 01 	sts	0x0184, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c134:	e1 99       	sbic	0x1c, 1	; 28
    c136:	fe cf       	rjmp	.-4      	; 0xc134 <FSettingPumpPooling+0x336>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c138:	84 2f       	mov	r24, r20
    c13a:	90 e0       	ldi	r25, 0x00	; 0
    c13c:	8c 5b       	subi	r24, 0xBC	; 188
    c13e:	9e 4f       	sbci	r25, 0xFE	; 254
    c140:	9f bb       	out	0x1f, r25	; 31
    c142:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c144:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    c146:	0f b6       	in	r0, 0x3f	; 63
    c148:	f8 94       	cli
    c14a:	e2 9a       	sbi	0x1c, 2	; 28
    c14c:	e1 9a       	sbi	0x1c, 1	; 28
    c14e:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    c150:	83 e0       	ldi	r24, 0x03	; 3
    c152:	72 c0       	rjmp	.+228    	; 0xc238 <FSettingPumpPooling+0x43a>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    c154:	24 2f       	mov	r18, r20
    c156:	30 e0       	ldi	r19, 0x00	; 0
    c158:	fe 01       	movw	r30, r28
    c15a:	31 96       	adiw	r30, 0x01	; 1
    c15c:	e2 0f       	add	r30, r18
    c15e:	f3 1f       	adc	r31, r19
    c160:	80 81       	ld	r24, Z
    c162:	90 e0       	ldi	r25, 0x00	; 0
    c164:	01 96       	adiw	r24, 0x01	; 1
    c166:	65 e1       	ldi	r22, 0x15	; 21
    c168:	70 e0       	ldi	r23, 0x00	; 0
    c16a:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    c16e:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    c170:	88 23       	and	r24, r24
    c172:	11 f4       	brne	.+4      	; 0xc178 <FSettingPumpPooling+0x37a>
    c174:	81 e0       	ldi	r24, 0x01	; 1
    c176:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    c178:	2c 0f       	add	r18, r28
    c17a:	3d 1f       	adc	r19, r29
    c17c:	d9 01       	movw	r26, r18
    c17e:	11 96       	adiw	r26, 0x01	; 1
    c180:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c182:	86 e1       	ldi	r24, 0x16	; 22
    c184:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    c188:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    c18c:	81 e0       	ldi	r24, 0x01	; 1
    c18e:	80 93 84 01 	sts	0x0184, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c192:	e1 99       	sbic	0x1c, 1	; 28
    c194:	fe cf       	rjmp	.-4      	; 0xc192 <FSettingPumpPooling+0x394>
    c196:	d0 cf       	rjmp	.-96     	; 0xc138 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    c198:	fe 01       	movw	r30, r28
    c19a:	e4 0f       	add	r30, r20
    c19c:	f1 1d       	adc	r31, r1
    c19e:	81 81       	ldd	r24, Z+1	; 0x01
    c1a0:	90 e0       	ldi	r25, 0x00	; 0
    c1a2:	01 96       	adiw	r24, 0x01	; 1
    c1a4:	65 e1       	ldi	r22, 0x15	; 21
    c1a6:	70 e0       	ldi	r23, 0x00	; 0
    c1a8:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    c1ac:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c1ae:	87 e1       	ldi	r24, 0x17	; 23
    c1b0:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    c1b4:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    c1b8:	81 e0       	ldi	r24, 0x01	; 1
    c1ba:	80 93 84 01 	sts	0x0184, r24
    c1be:	e1 99       	sbic	0x1c, 1	; 28
    c1c0:	fe cf       	rjmp	.-4      	; 0xc1be <FSettingPumpPooling+0x3c0>
    c1c2:	ba cf       	rjmp	.-140    	; 0xc138 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    c1c4:	fe 01       	movw	r30, r28
    c1c6:	e4 0f       	add	r30, r20
    c1c8:	f1 1d       	adc	r31, r1
    c1ca:	81 81       	ldd	r24, Z+1	; 0x01
    c1cc:	90 e0       	ldi	r25, 0x00	; 0
    c1ce:	01 96       	adiw	r24, 0x01	; 1
    c1d0:	69 e2       	ldi	r22, 0x29	; 41
    c1d2:	70 e0       	ldi	r23, 0x00	; 0
    c1d4:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    c1d8:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c1da:	88 e1       	ldi	r24, 0x18	; 24
    c1dc:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    c1e0:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    c1e4:	81 e0       	ldi	r24, 0x01	; 1
    c1e6:	80 93 84 01 	sts	0x0184, r24
    c1ea:	e1 99       	sbic	0x1c, 1	; 28
    c1ec:	fe cf       	rjmp	.-4      	; 0xc1ea <FSettingPumpPooling+0x3ec>
    c1ee:	a4 cf       	rjmp	.-184    	; 0xc138 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    c1f0:	fe 01       	movw	r30, r28
    c1f2:	e4 0f       	add	r30, r20
    c1f4:	f1 1d       	adc	r31, r1
    c1f6:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c1f8:	e1 99       	sbic	0x1c, 1	; 28
    c1fa:	fe cf       	rjmp	.-4      	; 0xc1f8 <FSettingPumpPooling+0x3fa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c1fc:	84 e4       	ldi	r24, 0x44	; 68
    c1fe:	91 e0       	ldi	r25, 0x01	; 1
    c200:	9f bb       	out	0x1f, r25	; 31
    c202:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c204:	e0 9a       	sbi	0x1c, 0	; 28
    c206:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c208:	e1 99       	sbic	0x1c, 1	; 28
    c20a:	fe cf       	rjmp	.-4      	; 0xc208 <FSettingPumpPooling+0x40a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c20c:	84 2f       	mov	r24, r20
    c20e:	90 e0       	ldi	r25, 0x00	; 0
    c210:	8c 5b       	subi	r24, 0xBC	; 188
    c212:	9e 4f       	sbci	r25, 0xFE	; 254
    c214:	9f bb       	out	0x1f, r25	; 31
    c216:	8e bb       	out	0x1e, r24	; 30
    c218:	82 2f       	mov	r24, r18
    c21a:	90 e0       	ldi	r25, 0x00	; 0
    c21c:	70 e0       	ldi	r23, 0x00	; 0
    c21e:	6f 5f       	subi	r22, 0xFF	; 255
    c220:	7f 4f       	sbci	r23, 0xFF	; 255
    c222:	01 96       	adiw	r24, 0x01	; 1
    c224:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
#endif
    EEDR = __value;
    c228:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c22a:	0f b6       	in	r0, 0x3f	; 63
    c22c:	f8 94       	cli
    c22e:	e2 9a       	sbi	0x1c, 2	; 28
    c230:	e1 9a       	sbi	0x1c, 1	; 28
    c232:	0f be       	out	0x3f, r0	; 63
    c234:	0c c0       	rjmp	.+24     	; 0xc24e <FSettingPumpPooling+0x450>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    c236:	84 e0       	ldi	r24, 0x04	; 4
    c238:	80 93 1b 02 	sts	0x021B, r24
    c23c:	0f c0       	rjmp	.+30     	; 0xc25c <FSettingPumpPooling+0x45e>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    c23e:	80 91 82 01 	lds	r24, 0x0182
    c242:	81 30       	cpi	r24, 0x01	; 1
    c244:	21 f0       	breq	.+8      	; 0xc24e <FSettingPumpPooling+0x450>
    c246:	80 91 78 0c 	lds	r24, 0x0C78
    c24a:	86 30       	cpi	r24, 0x06	; 6
    c24c:	38 f0       	brcs	.+14     	; 0xc25c <FSettingPumpPooling+0x45e>
    c24e:	10 92 1b 02 	sts	0x021B, r1
    c252:	04 c0       	rjmp	.+8      	; 0xc25c <FSettingPumpPooling+0x45e>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    c254:	10 92 1b 02 	sts	0x021B, r1
    c258:	81 e0       	ldi	r24, 0x01	; 1
    c25a:	01 c0       	rjmp	.+2      	; 0xc25e <FSettingPumpPooling+0x460>
    c25c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    c25e:	6a 96       	adiw	r28, 0x1a	; 26
    c260:	0f b6       	in	r0, 0x3f	; 63
    c262:	f8 94       	cli
    c264:	de bf       	out	0x3e, r29	; 62
    c266:	0f be       	out	0x3f, r0	; 63
    c268:	cd bf       	out	0x3d, r28	; 61
    c26a:	cf 91       	pop	r28
    c26c:	df 91       	pop	r29
    c26e:	1f 91       	pop	r17
    c270:	0f 91       	pop	r16
    c272:	08 95       	ret

0000c274 <DisplayTicker>:
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
*/
    if (TimTicker>(TICKER_DELAY*2+1)){
    c274:	80 91 90 01 	lds	r24, 0x0190
    c278:	86 31       	cpi	r24, 0x16	; 22
    c27a:	38 f0       	brcs	.+14     	; 0xc28a <DisplayTicker+0x16>
	    lcd_put(4, 1, '>');
    c27c:	84 e0       	ldi	r24, 0x04	; 4
    c27e:	61 e0       	ldi	r22, 0x01	; 1
    c280:	4e e3       	ldi	r20, 0x3E	; 62
    c282:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
		TimTicker=0;
    c286:	10 92 90 01 	sts	0x0190, r1
	}
    if (TimTicker==TICKER_DELAY){
    c28a:	80 91 90 01 	lds	r24, 0x0190
    c28e:	8a 30       	cpi	r24, 0x0A	; 10
    c290:	51 f4       	brne	.+20     	; 0xc2a6 <DisplayTicker+0x32>
	    lcd_put(4, 1, '<');
    c292:	84 e0       	ldi	r24, 0x04	; 4
    c294:	61 e0       	ldi	r22, 0x01	; 1
    c296:	4c e3       	ldi	r20, 0x3C	; 60
    c298:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
		TimTicker++;
    c29c:	80 91 90 01 	lds	r24, 0x0190
    c2a0:	8f 5f       	subi	r24, 0xFF	; 255
    c2a2:	80 93 90 01 	sts	0x0190, r24
    c2a6:	08 95       	ret

0000c2a8 <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    c2a8:	6f 92       	push	r6
    c2aa:	7f 92       	push	r7
    c2ac:	8f 92       	push	r8
    c2ae:	9f 92       	push	r9
    c2b0:	af 92       	push	r10
    c2b2:	bf 92       	push	r11
    c2b4:	cf 92       	push	r12
    c2b6:	df 92       	push	r13
    c2b8:	ff 92       	push	r15
    c2ba:	0f 93       	push	r16
    c2bc:	1f 93       	push	r17
    c2be:	df 93       	push	r29
    c2c0:	cf 93       	push	r28
    c2c2:	cd b7       	in	r28, 0x3d	; 61
    c2c4:	de b7       	in	r29, 0x3e	; 62
    c2c6:	67 97       	sbiw	r28, 0x17	; 23
    c2c8:	0f b6       	in	r0, 0x3f	; 63
    c2ca:	f8 94       	cli
    c2cc:	de bf       	out	0x3e, r29	; 62
    c2ce:	0f be       	out	0x3f, r0	; 63
    c2d0:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    c2d2:	80 91 82 02 	lds	r24, 0x0282
    c2d6:	90 91 83 02 	lds	r25, 0x0283
    c2da:	01 96       	adiw	r24, 0x01	; 1
    c2dc:	90 93 83 02 	sts	0x0283, r25
    c2e0:	80 93 82 02 	sts	0x0282, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    c2e4:	62 e3       	ldi	r22, 0x32	; 50
    c2e6:	70 e0       	ldi	r23, 0x00	; 0
    c2e8:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    c2ec:	89 2b       	or	r24, r25
    c2ee:	29 f5       	brne	.+74     	; 0xc33a <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    c2f0:	80 91 00 01 	lds	r24, 0x0100
    c2f4:	82 30       	cpi	r24, 0x02	; 2
    c2f6:	11 f4       	brne	.+4      	; 0xc2fc <DisplayIdle+0x54>
    c2f8:	0e 94 b7 4b 	call	0x976e	; 0x976e <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c2fc:	e1 99       	sbic	0x1c, 1	; 28
    c2fe:	fe cf       	rjmp	.-4      	; 0xc2fc <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c300:	87 e3       	ldi	r24, 0x37	; 55
    c302:	90 e0       	ldi	r25, 0x00	; 0
    c304:	9f bb       	out	0x1f, r25	; 31
    c306:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c308:	e0 9a       	sbi	0x1c, 0	; 28
    c30a:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&DefShowDateTime)) DisplayDateTime();
    c30c:	88 23       	and	r24, r24
    c30e:	19 f0       	breq	.+6      	; 0xc316 <DisplayIdle+0x6e>
    c310:	0e 94 f7 4a 	call	0x95ee	; 0x95ee <DisplayDateTime>
    c314:	02 c0       	rjmp	.+4      	; 0xc31a <DisplayIdle+0x72>
       else DisplayTicker();
    c316:	0e 94 3a 61 	call	0xc274	; 0xc274 <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    c31a:	80 91 00 01 	lds	r24, 0x0100
    c31e:	82 30       	cpi	r24, 0x02	; 2
    c320:	61 f4       	brne	.+24     	; 0xc33a <DisplayIdle+0x92>
    c322:	80 91 81 01 	lds	r24, 0x0181
    c326:	81 30       	cpi	r24, 0x01	; 1
    c328:	41 f4       	brne	.+16     	; 0xc33a <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    c32a:	10 92 81 01 	sts	0x0181, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    c32e:	84 e0       	ldi	r24, 0x04	; 4
    c330:	62 e1       	ldi	r22, 0x12	; 18
    c332:	40 91 80 01 	lds	r20, 0x0180
    c336:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    c33a:	f0 90 81 02 	lds	r15, 0x0281
    c33e:	ff 20       	and	r15, r15
    c340:	29 f0       	breq	.+10     	; 0xc34c <DisplayIdle+0xa4>
    c342:	81 e0       	ldi	r24, 0x01	; 1
    c344:	f8 16       	cp	r15, r24
    c346:	09 f0       	breq	.+2      	; 0xc34a <DisplayIdle+0xa2>
    c348:	58 c0       	rjmp	.+176    	; 0xc3fa <DisplayIdle+0x152>
    c34a:	2f c0       	rjmp	.+94     	; 0xc3aa <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    c34c:	f0 90 b2 01 	lds	r15, 0x01B2
    c350:	91 e0       	ldi	r25, 0x01	; 1
    c352:	f9 16       	cp	r15, r25
    c354:	09 f0       	breq	.+2      	; 0xc358 <DisplayIdle+0xb0>
    c356:	51 c0       	rjmp	.+162    	; 0xc3fa <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    c358:	00 d0       	rcall	.+0      	; 0xc35a <DisplayIdle+0xb2>
    c35a:	00 d0       	rcall	.+0      	; 0xc35c <DisplayIdle+0xb4>
    c35c:	00 d0       	rcall	.+0      	; 0xc35e <DisplayIdle+0xb6>
    c35e:	ed b7       	in	r30, 0x3d	; 61
    c360:	fe b7       	in	r31, 0x3e	; 62
    c362:	31 96       	adiw	r30, 0x01	; 1
    c364:	8e 01       	movw	r16, r28
    c366:	0c 5f       	subi	r16, 0xFC	; 252
    c368:	1f 4f       	sbci	r17, 0xFF	; 255
    c36a:	ad b7       	in	r26, 0x3d	; 61
    c36c:	be b7       	in	r27, 0x3e	; 62
    c36e:	12 96       	adiw	r26, 0x02	; 2
    c370:	1c 93       	st	X, r17
    c372:	0e 93       	st	-X, r16
    c374:	11 97       	sbiw	r26, 0x01	; 1
    c376:	83 e5       	ldi	r24, 0x53	; 83
    c378:	9e e1       	ldi	r25, 0x1E	; 30
    c37a:	93 83       	std	Z+3, r25	; 0x03
    c37c:	82 83       	std	Z+2, r24	; 0x02
    c37e:	89 eb       	ldi	r24, 0xB9	; 185
    c380:	97 e0       	ldi	r25, 0x07	; 7
    c382:	95 83       	std	Z+5, r25	; 0x05
    c384:	84 83       	std	Z+4, r24	; 0x04
    c386:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			   lcd_print(3,1,lcdteks);
    c38a:	ed b7       	in	r30, 0x3d	; 61
    c38c:	fe b7       	in	r31, 0x3e	; 62
    c38e:	36 96       	adiw	r30, 0x06	; 6
    c390:	0f b6       	in	r0, 0x3f	; 63
    c392:	f8 94       	cli
    c394:	fe bf       	out	0x3e, r31	; 62
    c396:	0f be       	out	0x3f, r0	; 63
    c398:	ed bf       	out	0x3d, r30	; 61
    c39a:	83 e0       	ldi	r24, 0x03	; 3
    c39c:	61 e0       	ldi	r22, 0x01	; 1
    c39e:	a8 01       	movw	r20, r16
    c3a0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			   stDispIdle=diWaitNoBusy;
    c3a4:	f0 92 81 02 	sts	0x0281, r15
    c3a8:	28 c0       	rjmp	.+80     	; 0xc3fa <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    c3aa:	80 91 b2 01 	lds	r24, 0x01B2
    c3ae:	88 23       	and	r24, r24
    c3b0:	21 f5       	brne	.+72     	; 0xc3fa <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    c3b2:	00 d0       	rcall	.+0      	; 0xc3b4 <DisplayIdle+0x10c>
    c3b4:	00 d0       	rcall	.+0      	; 0xc3b6 <DisplayIdle+0x10e>
    c3b6:	8e 01       	movw	r16, r28
    c3b8:	0c 5f       	subi	r16, 0xFC	; 252
    c3ba:	1f 4f       	sbci	r17, 0xFF	; 255
    c3bc:	ad b7       	in	r26, 0x3d	; 61
    c3be:	be b7       	in	r27, 0x3e	; 62
    c3c0:	12 96       	adiw	r26, 0x02	; 2
    c3c2:	1c 93       	st	X, r17
    c3c4:	0e 93       	st	-X, r16
    c3c6:	11 97       	sbiw	r26, 0x01	; 1
    c3c8:	8e e3       	ldi	r24, 0x3E	; 62
    c3ca:	9e e1       	ldi	r25, 0x1E	; 30
    c3cc:	14 96       	adiw	r26, 0x04	; 4
    c3ce:	9c 93       	st	X, r25
    c3d0:	8e 93       	st	-X, r24
    c3d2:	13 97       	sbiw	r26, 0x03	; 3
    c3d4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			   lcd_print(3,1,lcdteks);
    c3d8:	0f 90       	pop	r0
    c3da:	0f 90       	pop	r0
    c3dc:	0f 90       	pop	r0
    c3de:	0f 90       	pop	r0
    c3e0:	83 e0       	ldi	r24, 0x03	; 3
    c3e2:	61 e0       	ldi	r22, 0x01	; 1
    c3e4:	a8 01       	movw	r20, r16
    c3e6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			   stDispIdle=diScan;
    c3ea:	10 92 81 02 	sts	0x0281, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    c3ee:	80 91 8f 01 	lds	r24, 0x018F
    c3f2:	88 23       	and	r24, r24
    c3f4:	11 f0       	breq	.+4      	; 0xc3fa <DisplayIdle+0x152>
    c3f6:	f0 92 96 01 	sts	0x0196, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    c3fa:	80 91 96 01 	lds	r24, 0x0196
    c3fe:	81 30       	cpi	r24, 0x01	; 1
    c400:	09 f0       	breq	.+2      	; 0xc404 <DisplayIdle+0x15c>
    c402:	69 c0       	rjmp	.+210    	; 0xc4d6 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    c404:	10 92 96 01 	sts	0x0196, r1
		 if (nLocalAccount>0){
    c408:	80 91 8f 01 	lds	r24, 0x018F
    c40c:	88 23       	and	r24, r24
    c40e:	09 f4       	brne	.+2      	; 0xc412 <DisplayIdle+0x16a>
    c410:	5c c0       	rjmp	.+184    	; 0xc4ca <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    c412:	83 e0       	ldi	r24, 0x03	; 3
    c414:	61 e0       	ldi	r22, 0x01	; 1
    c416:	48 e3       	ldi	r20, 0x38	; 56
    c418:	5e e1       	ldi	r21, 0x1E	; 30
    c41a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    c41e:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    c420:	5e 01       	movw	r10, r28
    c422:	08 94       	sec
    c424:	a1 1c       	adc	r10, r1
    c426:	b1 1c       	adc	r11, r1
    c428:	33 e3       	ldi	r19, 0x33	; 51
    c42a:	63 2e       	mov	r6, r19
    c42c:	3e e1       	ldi	r19, 0x1E	; 30
    c42e:	73 2e       	mov	r7, r19
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    c430:	24 e0       	ldi	r18, 0x04	; 4
    c432:	c2 2e       	mov	r12, r18
    c434:	d1 2c       	mov	r13, r1
    c436:	cc 0e       	add	r12, r28
    c438:	dd 1e       	adc	r13, r29
    c43a:	9f e2       	ldi	r25, 0x2F	; 47
    c43c:	89 2e       	mov	r8, r25
    c43e:	9e e1       	ldi	r25, 0x1E	; 30
    c440:	99 2e       	mov	r9, r25
    c442:	3d c0       	rjmp	.+122    	; 0xc4be <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    c444:	0f 2d       	mov	r16, r15
    c446:	10 e0       	ldi	r17, 0x00	; 0
    c448:	00 d0       	rcall	.+0      	; 0xc44a <DisplayIdle+0x1a2>
    c44a:	00 d0       	rcall	.+0      	; 0xc44c <DisplayIdle+0x1a4>
    c44c:	00 d0       	rcall	.+0      	; 0xc44e <DisplayIdle+0x1a6>
    c44e:	ad b7       	in	r26, 0x3d	; 61
    c450:	be b7       	in	r27, 0x3e	; 62
    c452:	11 96       	adiw	r26, 0x01	; 1
    c454:	ed b7       	in	r30, 0x3d	; 61
    c456:	fe b7       	in	r31, 0x3e	; 62
    c458:	b2 82       	std	Z+2, r11	; 0x02
    c45a:	a1 82       	std	Z+1, r10	; 0x01
    c45c:	13 96       	adiw	r26, 0x03	; 3
    c45e:	7c 92       	st	X, r7
    c460:	6e 92       	st	-X, r6
    c462:	12 97       	sbiw	r26, 0x02	; 2
    c464:	f8 01       	movw	r30, r16
    c466:	ea 5a       	subi	r30, 0xAA	; 170
    c468:	fc 4f       	sbci	r31, 0xFC	; 252
    c46a:	80 81       	ld	r24, Z
    c46c:	14 96       	adiw	r26, 0x04	; 4
    c46e:	8c 93       	st	X, r24
    c470:	14 97       	sbiw	r26, 0x04	; 4
    c472:	15 96       	adiw	r26, 0x05	; 5
    c474:	1c 92       	st	X, r1
    c476:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    c47a:	ed b7       	in	r30, 0x3d	; 61
    c47c:	fe b7       	in	r31, 0x3e	; 62
    c47e:	31 96       	adiw	r30, 0x01	; 1
    c480:	ad b7       	in	r26, 0x3d	; 61
    c482:	be b7       	in	r27, 0x3e	; 62
    c484:	12 96       	adiw	r26, 0x02	; 2
    c486:	dc 92       	st	X, r13
    c488:	ce 92       	st	-X, r12
    c48a:	11 97       	sbiw	r26, 0x01	; 1
    c48c:	93 82       	std	Z+3, r9	; 0x03
    c48e:	82 82       	std	Z+2, r8	; 0x02
    c490:	b5 82       	std	Z+5, r11	; 0x05
    c492:	a4 82       	std	Z+4, r10	; 0x04
    c494:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    c498:	ed b7       	in	r30, 0x3d	; 61
    c49a:	fe b7       	in	r31, 0x3e	; 62
    c49c:	36 96       	adiw	r30, 0x06	; 6
    c49e:	0f b6       	in	r0, 0x3f	; 63
    c4a0:	f8 94       	cli
    c4a2:	fe bf       	out	0x3e, r31	; 62
    c4a4:	0f be       	out	0x3f, r0	; 63
    c4a6:	ed bf       	out	0x3d, r30	; 61
    c4a8:	b8 01       	movw	r22, r16
    c4aa:	66 0f       	add	r22, r22
    c4ac:	77 1f       	adc	r23, r23
    c4ae:	60 0f       	add	r22, r16
    c4b0:	71 1f       	adc	r23, r17
    c4b2:	6a 5f       	subi	r22, 0xFA	; 250
    c4b4:	83 e0       	ldi	r24, 0x03	; 3
    c4b6:	a6 01       	movw	r20, r12
    c4b8:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    c4bc:	f3 94       	inc	r15
    c4be:	80 91 8f 01 	lds	r24, 0x018F
    c4c2:	f8 16       	cp	r15, r24
    c4c4:	08 f4       	brcc	.+2      	; 0xc4c8 <DisplayIdle+0x220>
    c4c6:	be cf       	rjmp	.-132    	; 0xc444 <DisplayIdle+0x19c>
    c4c8:	06 c0       	rjmp	.+12     	; 0xc4d6 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    c4ca:	83 e0       	ldi	r24, 0x03	; 3
    c4cc:	61 e0       	ldi	r22, 0x01	; 1
    c4ce:	4a e1       	ldi	r20, 0x1A	; 26
    c4d0:	5e e1       	ldi	r21, 0x1E	; 30
    c4d2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    c4d6:	80 91 a9 01 	lds	r24, 0x01A9
    c4da:	81 30       	cpi	r24, 0x01	; 1
    c4dc:	c1 f4       	brne	.+48     	; 0xc50e <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    c4de:	10 92 a9 01 	sts	0x01A9, r1
	     if (nLocalAccount>0){
    c4e2:	90 91 8f 01 	lds	r25, 0x018F
    c4e6:	99 23       	and	r25, r25
    c4e8:	91 f0       	breq	.+36     	; 0xc50e <DisplayIdle+0x266>
    c4ea:	e6 e5       	ldi	r30, 0x56	; 86
    c4ec:	f3 e0       	ldi	r31, 0x03	; 3
			 for(i=0;i<nLocalAccount;i++){//Shift data
    c4ee:	29 2f       	mov	r18, r25
    c4f0:	30 e0       	ldi	r19, 0x00	; 0
    c4f2:	2e 0f       	add	r18, r30
    c4f4:	3f 1f       	adc	r19, r31
    c4f6:	02 c0       	rjmp	.+4      	; 0xc4fc <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    c4f8:	81 81       	ldd	r24, Z+1	; 0x01
    c4fa:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    c4fc:	e2 17       	cp	r30, r18
    c4fe:	f3 07       	cpc	r31, r19
    c500:	d9 f7       	brne	.-10     	; 0xc4f8 <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    c502:	91 50       	subi	r25, 0x01	; 1
    c504:	90 93 8f 01 	sts	0x018F, r25
             IsViewFillingFIP=True; 
    c508:	81 e0       	ldi	r24, 0x01	; 1
    c50a:	80 93 96 01 	sts	0x0196, r24
		 }
	 }
}
    c50e:	67 96       	adiw	r28, 0x17	; 23
    c510:	0f b6       	in	r0, 0x3f	; 63
    c512:	f8 94       	cli
    c514:	de bf       	out	0x3e, r29	; 62
    c516:	0f be       	out	0x3f, r0	; 63
    c518:	cd bf       	out	0x3d, r28	; 61
    c51a:	cf 91       	pop	r28
    c51c:	df 91       	pop	r29
    c51e:	1f 91       	pop	r17
    c520:	0f 91       	pop	r16
    c522:	ff 90       	pop	r15
    c524:	df 90       	pop	r13
    c526:	cf 90       	pop	r12
    c528:	bf 90       	pop	r11
    c52a:	af 90       	pop	r10
    c52c:	9f 90       	pop	r9
    c52e:	8f 90       	pop	r8
    c530:	7f 90       	pop	r7
    c532:	6f 90       	pop	r6
    c534:	08 95       	ret

0000c536 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    c536:	81 e0       	ldi	r24, 0x01	; 1
    c538:	60 e0       	ldi	r22, 0x00	; 0
    c53a:	0e 94 f2 ab 	call	0x157e4	; 0x157e4 <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    c53e:	81 e0       	ldi	r24, 0x01	; 1
    c540:	0e 94 05 ac 	call	0x1580a	; 0x1580a <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    c544:	bb 98       	cbi	0x17, 3	; 23
    c546:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    c548:	ba 9a       	sbi	0x17, 2	; 23
}
    c54a:	08 95       	ret

0000c54c <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    c54c:	80 e0       	ldi	r24, 0x00	; 0
    c54e:	0e 94 05 ac 	call	0x1580a	; 0x1580a <_spi_enable>
  	_spi_init(0, 1);         //Slave
    c552:	80 e0       	ldi	r24, 0x00	; 0
    c554:	61 e0       	ldi	r22, 0x01	; 1
    c556:	0e 94 f2 ab 	call	0x157e4	; 0x157e4 <_spi_init>
	sbi(DDRB,3);             //MISO Output
    c55a:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    c55c:	bb 9a       	sbi	0x17, 3	; 23
    c55e:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    c560:	ba 98       	cbi	0x17, 2	; 23
    c562:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    c564:	b9 98       	cbi	0x17, 1	; 23
    c566:	c1 9a       	sbi	0x18, 1	; 24
}
    c568:	08 95       	ret

0000c56a <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    c56a:	1f 93       	push	r17
    c56c:	18 2f       	mov	r17, r24
     systemMaster();	 
    c56e:	0e 94 9b 62 	call	0xc536	; 0xc536 <systemMaster>
     _spi(EDCData);
    c572:	81 2f       	mov	r24, r17
    c574:	0e 94 1c ac 	call	0x15838	; 0x15838 <_spi>
     systemSlave();
    c578:	0e 94 a6 62 	call	0xc54c	; 0xc54c <systemSlave>
}
    c57c:	1f 91       	pop	r17
    c57e:	08 95       	ret

0000c580 <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    c580:	af 92       	push	r10
    c582:	bf 92       	push	r11
    c584:	df 92       	push	r13
    c586:	ef 92       	push	r14
    c588:	ff 92       	push	r15
    c58a:	0f 93       	push	r16
    c58c:	1f 93       	push	r17
    c58e:	df 93       	push	r29
    c590:	cf 93       	push	r28
    c592:	cd b7       	in	r28, 0x3d	; 61
    c594:	de b7       	in	r29, 0x3e	; 62
    c596:	ec 97       	sbiw	r28, 0x3c	; 60
    c598:	0f b6       	in	r0, 0x3f	; 63
    c59a:	f8 94       	cli
    c59c:	de bf       	out	0x3e, r29	; 62
    c59e:	0f be       	out	0x3f, r0	; 63
    c5a0:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //uart_printf(0,0,PSTR("StrStatus:"));uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    c5a2:	8d b7       	in	r24, 0x3d	; 61
    c5a4:	9e b7       	in	r25, 0x3e	; 62
    c5a6:	42 97       	sbiw	r24, 0x12	; 18
    c5a8:	0f b6       	in	r0, 0x3f	; 63
    c5aa:	f8 94       	cli
    c5ac:	9e bf       	out	0x3e, r25	; 62
    c5ae:	0f be       	out	0x3f, r0	; 63
    c5b0:	8d bf       	out	0x3d, r24	; 61
    c5b2:	ed b7       	in	r30, 0x3d	; 61
    c5b4:	fe b7       	in	r31, 0x3e	; 62
    c5b6:	31 96       	adiw	r30, 0x01	; 1
    c5b8:	8e 01       	movw	r16, r28
    c5ba:	0f 5f       	subi	r16, 0xFF	; 255
    c5bc:	1f 4f       	sbci	r17, 0xFF	; 255
    c5be:	ad b7       	in	r26, 0x3d	; 61
    c5c0:	be b7       	in	r27, 0x3e	; 62
    c5c2:	12 96       	adiw	r26, 0x02	; 2
    c5c4:	1c 93       	st	X, r17
    c5c6:	0e 93       	st	-X, r16
    c5c8:	11 97       	sbiw	r26, 0x01	; 1
    c5ca:	87 e0       	ldi	r24, 0x07	; 7
    c5cc:	9e e1       	ldi	r25, 0x1E	; 30
    c5ce:	93 83       	std	Z+3, r25	; 0x03
    c5d0:	82 83       	std	Z+2, r24	; 0x02
    c5d2:	87 e8       	ldi	r24, 0x87	; 135
    c5d4:	9c e0       	ldi	r25, 0x0C	; 12
    c5d6:	95 83       	std	Z+5, r25	; 0x05
    c5d8:	84 83       	std	Z+4, r24	; 0x04
    c5da:	89 eb       	ldi	r24, 0xB9	; 185
    c5dc:	97 e0       	ldi	r25, 0x07	; 7
    c5de:	97 83       	std	Z+7, r25	; 0x07
    c5e0:	86 83       	std	Z+6, r24	; 0x06
    c5e2:	8c e0       	ldi	r24, 0x0C	; 12
    c5e4:	98 e0       	ldi	r25, 0x08	; 8
    c5e6:	91 87       	std	Z+9, r25	; 0x09
    c5e8:	80 87       	std	Z+8, r24	; 0x08
    c5ea:	8e e9       	ldi	r24, 0x9E	; 158
    c5ec:	95 e0       	ldi	r25, 0x05	; 5
    c5ee:	93 87       	std	Z+11, r25	; 0x0b
    c5f0:	82 87       	std	Z+10, r24	; 0x0a
    c5f2:	85 e7       	ldi	r24, 0x75	; 117
    c5f4:	93 e0       	ldi	r25, 0x03	; 3
    c5f6:	95 87       	std	Z+13, r25	; 0x0d
    c5f8:	84 87       	std	Z+12, r24	; 0x0c
    c5fa:	83 eb       	ldi	r24, 0xB3	; 179
    c5fc:	9b e0       	ldi	r25, 0x0B	; 11
    c5fe:	97 87       	std	Z+15, r25	; 0x0f
    c600:	86 87       	std	Z+14, r24	; 0x0e
    c602:	8a e8       	ldi	r24, 0x8A	; 138
    c604:	93 e0       	ldi	r25, 0x03	; 3
    c606:	91 8b       	std	Z+17, r25	; 0x11
    c608:	80 8b       	std	Z+16, r24	; 0x10
    c60a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    c60e:	8d b7       	in	r24, 0x3d	; 61
    c610:	9e b7       	in	r25, 0x3e	; 62
    c612:	42 96       	adiw	r24, 0x12	; 18
    c614:	0f b6       	in	r0, 0x3f	; 63
    c616:	f8 94       	cli
    c618:	9e bf       	out	0x3e, r25	; 62
    c61a:	0f be       	out	0x3f, r0	; 63
    c61c:	8d bf       	out	0x3d, r24	; 61
    c61e:	82 e0       	ldi	r24, 0x02	; 2
    c620:	0e 94 b5 62 	call	0xc56a	; 0xc56a <EDCSendByte>
    c624:	ff 24       	eor	r15, r15
    c626:	52 e0       	ldi	r21, 0x02	; 2
    c628:	d5 2e       	mov	r13, r21
    c62a:	40 e7       	ldi	r20, 0x70	; 112
    c62c:	a4 2e       	mov	r10, r20
    c62e:	41 e0       	ldi	r20, 0x01	; 1
    c630:	b4 2e       	mov	r11, r20
    c632:	0f c0       	rjmp	.+30     	; 0xc652 <SendEDCMessage+0xd2>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    c634:	a0 0f       	add	r26, r16
    c636:	b1 1f       	adc	r27, r17
    c638:	ec 90       	ld	r14, X
          EDCSendByte(SerialEDC[i]);
    c63a:	8e 2d       	mov	r24, r14
    c63c:	0e 94 b5 62 	call	0xc56a	; 0xc56a <EDCSendByte>
    c640:	84 ef       	ldi	r24, 0xF4	; 244
    c642:	91 e0       	ldi	r25, 0x01	; 1
    c644:	f5 01       	movw	r30, r10
    c646:	31 97       	sbiw	r30, 0x01	; 1
    c648:	f1 f7       	brne	.-4      	; 0xc646 <SendEDCMessage+0xc6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    c64a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    c64c:	d9 f7       	brne	.-10     	; 0xc644 <SendEDCMessage+0xc4>
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    c64e:	de 24       	eor	r13, r14
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    c650:	f3 94       	inc	r15
    c652:	f8 01       	movw	r30, r16
    c654:	01 90       	ld	r0, Z+
    c656:	00 20       	and	r0, r0
    c658:	e9 f7       	brne	.-6      	; 0xc654 <SendEDCMessage+0xd4>
    c65a:	31 97       	sbiw	r30, 0x01	; 1
    c65c:	e0 1b       	sub	r30, r16
    c65e:	f1 0b       	sbc	r31, r17
    c660:	af 2d       	mov	r26, r15
    c662:	b0 e0       	ldi	r27, 0x00	; 0
    c664:	ae 17       	cp	r26, r30
    c666:	bf 07       	cpc	r27, r31
    c668:	28 f3       	brcs	.-54     	; 0xc634 <SendEDCMessage+0xb4>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //uart(0,1,SerialEDC[i]);
		  _delay_ms(SPI_EDC_DELAY);//min:8
	 }
     EDCSendByte(0x03);
    c66a:	83 e0       	ldi	r24, 0x03	; 3
    c66c:	0e 94 b5 62 	call	0xc56a	; 0xc56a <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    c670:	83 e0       	ldi	r24, 0x03	; 3
    c672:	8d 25       	eor	r24, r13
    c674:	0e 94 b5 62 	call	0xc56a	; 0xc56a <EDCSendByte>
}
    c678:	ec 96       	adiw	r28, 0x3c	; 60
    c67a:	0f b6       	in	r0, 0x3f	; 63
    c67c:	f8 94       	cli
    c67e:	de bf       	out	0x3e, r29	; 62
    c680:	0f be       	out	0x3f, r0	; 63
    c682:	cd bf       	out	0x3d, r28	; 61
    c684:	cf 91       	pop	r28
    c686:	df 91       	pop	r29
    c688:	1f 91       	pop	r17
    c68a:	0f 91       	pop	r16
    c68c:	ff 90       	pop	r15
    c68e:	ef 90       	pop	r14
    c690:	df 90       	pop	r13
    c692:	bf 90       	pop	r11
    c694:	af 90       	pop	r10
    c696:	08 95       	ret

0000c698 <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    c698:	0f 93       	push	r16
    c69a:	1f 93       	push	r17
    c69c:	18 2f       	mov	r17, r24
    c69e:	06 2f       	mov	r16, r22
	 systemMaster();
    c6a0:	0e 94 9b 62 	call	0xc536	; 0xc536 <systemMaster>
	 _spi(0x05);
    c6a4:	85 e0       	ldi	r24, 0x05	; 5
    c6a6:	0e 94 1c ac 	call	0x15838	; 0x15838 <_spi>
	 _spi(SlaveCommand);
    c6aa:	81 2f       	mov	r24, r17
    c6ac:	0e 94 1c ac 	call	0x15838	; 0x15838 <_spi>
	 _spi(SlaveMessage);
    c6b0:	80 2f       	mov	r24, r16
    c6b2:	0e 94 1c ac 	call	0x15838	; 0x15838 <_spi>
	 _spi(0x06);
    c6b6:	86 e0       	ldi	r24, 0x06	; 6
    c6b8:	0e 94 1c ac 	call	0x15838	; 0x15838 <_spi>
	 systemSlave();
    c6bc:	0e 94 a6 62 	call	0xc54c	; 0xc54c <systemSlave>
}
    c6c0:	1f 91       	pop	r17
    c6c2:	0f 91       	pop	r16
    c6c4:	08 95       	ret

0000c6c6 <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    c6c6:	9f 92       	push	r9
    c6c8:	af 92       	push	r10
    c6ca:	bf 92       	push	r11
    c6cc:	cf 92       	push	r12
    c6ce:	df 92       	push	r13
    c6d0:	ef 92       	push	r14
    c6d2:	ff 92       	push	r15
    c6d4:	0f 93       	push	r16
    c6d6:	1f 93       	push	r17
    c6d8:	df 93       	push	r29
    c6da:	cf 93       	push	r28
    c6dc:	cd b7       	in	r28, 0x3d	; 61
    c6de:	de b7       	in	r29, 0x3e	; 62
    c6e0:	64 97       	sbiw	r28, 0x14	; 20
    c6e2:	0f b6       	in	r0, 0x3f	; 63
    c6e4:	f8 94       	cli
    c6e6:	de bf       	out	0x3e, r29	; 62
    c6e8:	0f be       	out	0x3f, r0	; 63
    c6ea:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    c6ec:	80 91 1a 02 	lds	r24, 0x021A
    c6f0:	85 30       	cpi	r24, 0x05	; 5
    c6f2:	09 f4       	brne	.+2      	; 0xc6f6 <FSettingPumpID+0x30>
    c6f4:	85 c1       	rjmp	.+778    	; 0xca00 <FSettingPumpID+0x33a>
    c6f6:	86 30       	cpi	r24, 0x06	; 6
    c6f8:	90 f4       	brcc	.+36     	; 0xc71e <FSettingPumpID+0x58>
    c6fa:	82 30       	cpi	r24, 0x02	; 2
    c6fc:	09 f4       	brne	.+2      	; 0xc700 <FSettingPumpID+0x3a>
    c6fe:	8f c0       	rjmp	.+286    	; 0xc81e <FSettingPumpID+0x158>
    c700:	83 30       	cpi	r24, 0x03	; 3
    c702:	30 f4       	brcc	.+12     	; 0xc710 <FSettingPumpID+0x4a>
    c704:	88 23       	and	r24, r24
    c706:	f1 f0       	breq	.+60     	; 0xc744 <FSettingPumpID+0x7e>
    c708:	81 30       	cpi	r24, 0x01	; 1
    c70a:	09 f0       	breq	.+2      	; 0xc70e <FSettingPumpID+0x48>
    c70c:	6c c2       	rjmp	.+1240   	; 0xcbe6 <FSettingPumpID+0x520>
    c70e:	2d c0       	rjmp	.+90     	; 0xc76a <FSettingPumpID+0xa4>
    c710:	83 30       	cpi	r24, 0x03	; 3
    c712:	09 f4       	brne	.+2      	; 0xc716 <FSettingPumpID+0x50>
    c714:	51 c1       	rjmp	.+674    	; 0xc9b8 <FSettingPumpID+0x2f2>
    c716:	84 30       	cpi	r24, 0x04	; 4
    c718:	09 f0       	breq	.+2      	; 0xc71c <FSettingPumpID+0x56>
    c71a:	65 c2       	rjmp	.+1226   	; 0xcbe6 <FSettingPumpID+0x520>
    c71c:	6a c1       	rjmp	.+724    	; 0xc9f2 <FSettingPumpID+0x32c>
    c71e:	88 30       	cpi	r24, 0x08	; 8
    c720:	09 f4       	brne	.+2      	; 0xc724 <FSettingPumpID+0x5e>
    c722:	f9 c1       	rjmp	.+1010   	; 0xcb16 <FSettingPumpID+0x450>
    c724:	89 30       	cpi	r24, 0x09	; 9
    c726:	38 f4       	brcc	.+14     	; 0xc736 <FSettingPumpID+0x70>
    c728:	86 30       	cpi	r24, 0x06	; 6
    c72a:	09 f4       	brne	.+2      	; 0xc72e <FSettingPumpID+0x68>
    c72c:	98 c1       	rjmp	.+816    	; 0xca5e <FSettingPumpID+0x398>
    c72e:	87 30       	cpi	r24, 0x07	; 7
    c730:	09 f0       	breq	.+2      	; 0xc734 <FSettingPumpID+0x6e>
    c732:	59 c2       	rjmp	.+1202   	; 0xcbe6 <FSettingPumpID+0x520>
    c734:	3e c2       	rjmp	.+1148   	; 0xcbb2 <FSettingPumpID+0x4ec>
    c736:	89 30       	cpi	r24, 0x09	; 9
    c738:	09 f4       	brne	.+2      	; 0xc73c <FSettingPumpID+0x76>
    c73a:	43 c2       	rjmp	.+1158   	; 0xcbc2 <FSettingPumpID+0x4fc>
    c73c:	8a 30       	cpi	r24, 0x0A	; 10
    c73e:	09 f0       	breq	.+2      	; 0xc742 <FSettingPumpID+0x7c>
    c740:	52 c2       	rjmp	.+1188   	; 0xcbe6 <FSettingPumpID+0x520>
    c742:	45 c2       	rjmp	.+1162   	; 0xcbce <FSettingPumpID+0x508>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    c744:	80 91 00 01 	lds	r24, 0x0100
    c748:	82 30       	cpi	r24, 0x02	; 2
    c74a:	21 f4       	brne	.+8      	; 0xc754 <FSettingPumpID+0x8e>
    c74c:	8f e1       	ldi	r24, 0x1F	; 31
    c74e:	60 e0       	ldi	r22, 0x00	; 0
    c750:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    c754:	80 e1       	ldi	r24, 0x10	; 16
    c756:	92 e0       	ldi	r25, 0x02	; 2
    c758:	65 e4       	ldi	r22, 0x45	; 69
    c75a:	70 e0       	ldi	r23, 0x00	; 0
    c75c:	48 e0       	ldi	r20, 0x08	; 8
    c75e:	50 e0       	ldi	r21, 0x00	; 0
    c760:	22 ed       	ldi	r18, 0xD2	; 210
    c762:	33 e1       	ldi	r19, 0x13	; 19
    c764:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    c768:	49 c1       	rjmp	.+658    	; 0xc9fc <FSettingPumpID+0x336>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    c76a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    c76e:	b0 e1       	ldi	r27, 0x10	; 16
    c770:	eb 2e       	mov	r14, r27
    c772:	b2 e0       	ldi	r27, 0x02	; 2
    c774:	fb 2e       	mov	r15, r27
    c776:	01 e0       	ldi	r16, 0x01	; 1
    c778:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    c77a:	6e 01       	movw	r12, r28
    c77c:	08 94       	sec
    c77e:	c1 1c       	adc	r12, r1
    c780:	d1 1c       	adc	r13, r1
    c782:	ab e2       	ldi	r26, 0x2B	; 43
    c784:	aa 2e       	mov	r10, r26
    c786:	ae e0       	ldi	r26, 0x0E	; 14
    c788:	ba 2e       	mov	r11, r26
    c78a:	8d b7       	in	r24, 0x3d	; 61
    c78c:	9e b7       	in	r25, 0x3e	; 62
    c78e:	0c 97       	sbiw	r24, 0x0c	; 12
    c790:	0f b6       	in	r0, 0x3f	; 63
    c792:	f8 94       	cli
    c794:	9e bf       	out	0x3e, r25	; 62
    c796:	0f be       	out	0x3f, r0	; 63
    c798:	8d bf       	out	0x3d, r24	; 61
    c79a:	ed b7       	in	r30, 0x3d	; 61
    c79c:	fe b7       	in	r31, 0x3e	; 62
    c79e:	31 96       	adiw	r30, 0x01	; 1
    c7a0:	ad b7       	in	r26, 0x3d	; 61
    c7a2:	be b7       	in	r27, 0x3e	; 62
    c7a4:	12 96       	adiw	r26, 0x02	; 2
    c7a6:	dc 92       	st	X, r13
    c7a8:	ce 92       	st	-X, r12
    c7aa:	11 97       	sbiw	r26, 0x01	; 1
    c7ac:	b3 82       	std	Z+3, r11	; 0x03
    c7ae:	a2 82       	std	Z+2, r10	; 0x02
    c7b0:	15 83       	std	Z+5, r17	; 0x05
    c7b2:	04 83       	std	Z+4, r16	; 0x04
    c7b4:	d7 01       	movw	r26, r14
    c7b6:	8c 91       	ld	r24, X
    c7b8:	86 83       	std	Z+6, r24	; 0x06
    c7ba:	17 82       	std	Z+7, r1	; 0x07
    c7bc:	0c 5f       	subi	r16, 0xFC	; 252
    c7be:	1f 4f       	sbci	r17, 0xFF	; 255
    c7c0:	11 87       	std	Z+9, r17	; 0x09
    c7c2:	00 87       	std	Z+8, r16	; 0x08
    c7c4:	04 50       	subi	r16, 0x04	; 4
    c7c6:	10 40       	sbci	r17, 0x00	; 0
    c7c8:	14 96       	adiw	r26, 0x04	; 4
    c7ca:	8c 91       	ld	r24, X
    c7cc:	82 87       	std	Z+10, r24	; 0x0a
    c7ce:	13 86       	std	Z+11, r1	; 0x0b
    c7d0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    c7d4:	ed b7       	in	r30, 0x3d	; 61
    c7d6:	fe b7       	in	r31, 0x3e	; 62
    c7d8:	3c 96       	adiw	r30, 0x0c	; 12
    c7da:	0f b6       	in	r0, 0x3f	; 63
    c7dc:	f8 94       	cli
    c7de:	fe bf       	out	0x3e, r31	; 62
    c7e0:	0f be       	out	0x3f, r0	; 63
    c7e2:	ed bf       	out	0x3d, r30	; 61
    c7e4:	80 2f       	mov	r24, r16
    c7e6:	61 e0       	ldi	r22, 0x01	; 1
    c7e8:	a6 01       	movw	r20, r12
    c7ea:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    c7ee:	08 94       	sec
    c7f0:	e1 1c       	adc	r14, r1
    c7f2:	f1 1c       	adc	r15, r1
    c7f4:	0f 5f       	subi	r16, 0xFF	; 255
    c7f6:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    c7f8:	f4 e1       	ldi	r31, 0x14	; 20
    c7fa:	ef 16       	cp	r14, r31
    c7fc:	f2 e0       	ldi	r31, 0x02	; 2
    c7fe:	ff 06       	cpc	r15, r31
    c800:	21 f6       	brne	.-120    	; 0xc78a <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    c802:	83 e0       	ldi	r24, 0x03	; 3
    c804:	6f e0       	ldi	r22, 0x0F	; 15
    c806:	44 e2       	ldi	r20, 0x24	; 36
    c808:	5e e0       	ldi	r21, 0x0E	; 14
    c80a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    c80e:	84 e0       	ldi	r24, 0x04	; 4
    c810:	6f e0       	ldi	r22, 0x0F	; 15
    c812:	4d e1       	ldi	r20, 0x1D	; 29
    c814:	5e e0       	ldi	r21, 0x0E	; 14
    c816:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          stMenuPumpID=mpSelectInput;
    c81a:	82 e0       	ldi	r24, 0x02	; 2
    c81c:	cf c1       	rjmp	.+926    	; 0xcbbc <FSettingPumpID+0x4f6>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    c81e:	81 e0       	ldi	r24, 0x01	; 1
    c820:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    c824:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    c826:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    c82a:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    c82c:	81 53       	subi	r24, 0x31	; 49
    c82e:	88 30       	cpi	r24, 0x08	; 8
    c830:	08 f0       	brcs	.+2      	; 0xc834 <FSettingPumpID+0x16e>
    c832:	85 c0       	rjmp	.+266    	; 0xc93e <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    c834:	80 91 00 01 	lds	r24, 0x0100
    c838:	81 30       	cpi	r24, 0x01	; 1
    c83a:	19 f0       	breq	.+6      	; 0xc842 <FSettingPumpID+0x17c>
    c83c:	82 30       	cpi	r24, 0x02	; 2
    c83e:	a1 f5       	brne	.+104    	; 0xc8a8 <FSettingPumpID+0x1e2>
    c840:	17 c0       	rjmp	.+46     	; 0xc870 <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    c842:	80 91 19 02 	lds	r24, 0x0219
    c846:	88 23       	and	r24, r24
    c848:	41 f4       	brne	.+16     	; 0xc85a <FSettingPumpID+0x194>
    c84a:	e9 2f       	mov	r30, r25
    c84c:	f0 e0       	ldi	r31, 0x00	; 0
    c84e:	e1 52       	subi	r30, 0x21	; 33
    c850:	fe 4f       	sbci	r31, 0xFE	; 254
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    c852:	80 81       	ld	r24, Z
    c854:	83 36       	cpi	r24, 0x63	; 99
    c856:	c8 f4       	brcc	.+50     	; 0xc88a <FSettingPumpID+0x1c4>
    c858:	16 c0       	rjmp	.+44     	; 0xc886 <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    c85a:	81 30       	cpi	r24, 0x01	; 1
    c85c:	29 f5       	brne	.+74     	; 0xc8a8 <FSettingPumpID+0x1e2>
    c85e:	e9 2f       	mov	r30, r25
    c860:	f0 e0       	ldi	r31, 0x00	; 0
    c862:	e1 52       	subi	r30, 0x21	; 33
    c864:	fe 4f       	sbci	r31, 0xFE	; 254
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    c866:	80 81       	ld	r24, Z
    c868:	88 23       	and	r24, r24
    c86a:	d1 f4       	brne	.+52     	; 0xc8a0 <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    c86c:	83 e6       	ldi	r24, 0x63	; 99
    c86e:	1b c0       	rjmp	.+54     	; 0xc8a6 <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    c870:	80 91 19 02 	lds	r24, 0x0219
    c874:	88 23       	and	r24, r24
    c876:	59 f4       	brne	.+22     	; 0xc88e <FSettingPumpID+0x1c8>
    c878:	e9 2f       	mov	r30, r25
    c87a:	f0 e0       	ldi	r31, 0x00	; 0
    c87c:	e1 52       	subi	r30, 0x21	; 33
    c87e:	fe 4f       	sbci	r31, 0xFE	; 254
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    c880:	80 81       	ld	r24, Z
    c882:	80 31       	cpi	r24, 0x10	; 16
    c884:	10 f4       	brcc	.+4      	; 0xc88a <FSettingPumpID+0x1c4>
	     (*Value)++;
    c886:	8f 5f       	subi	r24, 0xFF	; 255
    c888:	0e c0       	rjmp	.+28     	; 0xc8a6 <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    c88a:	10 82       	st	Z, r1
    c88c:	0d c0       	rjmp	.+26     	; 0xc8a8 <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    c88e:	81 30       	cpi	r24, 0x01	; 1
    c890:	59 f4       	brne	.+22     	; 0xc8a8 <FSettingPumpID+0x1e2>
    c892:	e9 2f       	mov	r30, r25
    c894:	f0 e0       	ldi	r31, 0x00	; 0
    c896:	e1 52       	subi	r30, 0x21	; 33
    c898:	fe 4f       	sbci	r31, 0xFE	; 254
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    c89a:	80 81       	ld	r24, Z
    c89c:	88 23       	and	r24, r24
    c89e:	11 f0       	breq	.+4      	; 0xc8a4 <FSettingPumpID+0x1de>
	     (*Value)--;
    c8a0:	81 50       	subi	r24, 0x01	; 1
    c8a2:	01 c0       	rjmp	.+2      	; 0xc8a6 <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    c8a4:	80 e1       	ldi	r24, 0x10	; 16
    c8a6:	80 83       	st	Z, r24
    c8a8:	f0 e1       	ldi	r31, 0x10	; 16
    c8aa:	ef 2e       	mov	r14, r31
    c8ac:	f2 e0       	ldi	r31, 0x02	; 2
    c8ae:	ff 2e       	mov	r15, r31
    c8b0:	01 e0       	ldi	r16, 0x01	; 1
    c8b2:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    c8b4:	6e 01       	movw	r12, r28
    c8b6:	08 94       	sec
    c8b8:	c1 1c       	adc	r12, r1
    c8ba:	d1 1c       	adc	r13, r1
    c8bc:	e9 e0       	ldi	r30, 0x09	; 9
    c8be:	ae 2e       	mov	r10, r30
    c8c0:	ee e0       	ldi	r30, 0x0E	; 14
    c8c2:	be 2e       	mov	r11, r30
    c8c4:	8d b7       	in	r24, 0x3d	; 61
    c8c6:	9e b7       	in	r25, 0x3e	; 62
    c8c8:	0c 97       	sbiw	r24, 0x0c	; 12
    c8ca:	0f b6       	in	r0, 0x3f	; 63
    c8cc:	f8 94       	cli
    c8ce:	9e bf       	out	0x3e, r25	; 62
    c8d0:	0f be       	out	0x3f, r0	; 63
    c8d2:	8d bf       	out	0x3d, r24	; 61
    c8d4:	ed b7       	in	r30, 0x3d	; 61
    c8d6:	fe b7       	in	r31, 0x3e	; 62
    c8d8:	31 96       	adiw	r30, 0x01	; 1
    c8da:	ad b7       	in	r26, 0x3d	; 61
    c8dc:	be b7       	in	r27, 0x3e	; 62
    c8de:	12 96       	adiw	r26, 0x02	; 2
    c8e0:	dc 92       	st	X, r13
    c8e2:	ce 92       	st	-X, r12
    c8e4:	11 97       	sbiw	r26, 0x01	; 1
    c8e6:	b3 82       	std	Z+3, r11	; 0x03
    c8e8:	a2 82       	std	Z+2, r10	; 0x02
    c8ea:	15 83       	std	Z+5, r17	; 0x05
    c8ec:	04 83       	std	Z+4, r16	; 0x04
    c8ee:	d7 01       	movw	r26, r14
    c8f0:	8c 91       	ld	r24, X
    c8f2:	86 83       	std	Z+6, r24	; 0x06
    c8f4:	17 82       	std	Z+7, r1	; 0x07
    c8f6:	0c 5f       	subi	r16, 0xFC	; 252
    c8f8:	1f 4f       	sbci	r17, 0xFF	; 255
    c8fa:	11 87       	std	Z+9, r17	; 0x09
    c8fc:	00 87       	std	Z+8, r16	; 0x08
    c8fe:	04 50       	subi	r16, 0x04	; 4
    c900:	10 40       	sbci	r17, 0x00	; 0
    c902:	14 96       	adiw	r26, 0x04	; 4
    c904:	8c 91       	ld	r24, X
    c906:	82 87       	std	Z+10, r24	; 0x0a
    c908:	13 86       	std	Z+11, r1	; 0x0b
    c90a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    c90e:	ed b7       	in	r30, 0x3d	; 61
    c910:	fe b7       	in	r31, 0x3e	; 62
    c912:	3c 96       	adiw	r30, 0x0c	; 12
    c914:	0f b6       	in	r0, 0x3f	; 63
    c916:	f8 94       	cli
    c918:	fe bf       	out	0x3e, r31	; 62
    c91a:	0f be       	out	0x3f, r0	; 63
    c91c:	ed bf       	out	0x3d, r30	; 61
    c91e:	80 2f       	mov	r24, r16
    c920:	61 e0       	ldi	r22, 0x01	; 1
    c922:	a6 01       	movw	r20, r12
    c924:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    c928:	08 94       	sec
    c92a:	e1 1c       	adc	r14, r1
    c92c:	f1 1c       	adc	r15, r1
    c92e:	0f 5f       	subi	r16, 0xFF	; 255
    c930:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    c932:	f4 e1       	ldi	r31, 0x14	; 20
    c934:	ef 16       	cp	r14, r31
    c936:	f2 e0       	ldi	r31, 0x02	; 2
    c938:	ff 06       	cpc	r15, r31
    c93a:	21 f6       	brne	.-120    	; 0xc8c4 <FSettingPumpID+0x1fe>
    c93c:	2b c0       	rjmp	.+86     	; 0xc994 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    c93e:	93 32       	cpi	r25, 0x23	; 35
    c940:	21 f5       	brne	.+72     	; 0xc98a <FSettingPumpID+0x2c4>
    c942:	40 e0       	ldi	r20, 0x00	; 0
    c944:	20 e0       	ldi	r18, 0x00	; 0
    c946:	30 e0       	ldi	r19, 0x00	; 0
    c948:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    c94a:	f9 01       	movw	r30, r18
    c94c:	e0 5f       	subi	r30, 0xF0	; 240
    c94e:	fd 4f       	sbci	r31, 0xFD	; 253
    c950:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    c952:	ee 23       	and	r30, r30
    c954:	69 f0       	breq	.+26     	; 0xc970 <FSettingPumpID+0x2aa>
    c956:	a0 e1       	ldi	r26, 0x10	; 16
    c958:	b2 e0       	ldi	r27, 0x02	; 2
    c95a:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    c95c:	59 17       	cp	r21, r25
    c95e:	21 f0       	breq	.+8      	; 0xc968 <FSettingPumpID+0x2a2>
    c960:	8c 91       	ld	r24, X
    c962:	e8 17       	cp	r30, r24
    c964:	09 f4       	brne	.+2      	; 0xc968 <FSettingPumpID+0x2a2>
						       PumpCount++;
    c966:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    c968:	9f 5f       	subi	r25, 0xFF	; 255
    c96a:	11 96       	adiw	r26, 0x01	; 1
    c96c:	98 30       	cpi	r25, 0x08	; 8
    c96e:	b1 f7       	brne	.-20     	; 0xc95c <FSettingPumpID+0x296>
    c970:	2f 5f       	subi	r18, 0xFF	; 255
    c972:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    c974:	28 30       	cpi	r18, 0x08	; 8
    c976:	31 05       	cpc	r19, r1
    c978:	39 f7       	brne	.-50     	; 0xc948 <FSettingPumpID+0x282>
    c97a:	40 93 0e 02 	sts	0x020E, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    c97e:	44 23       	and	r20, r20
    c980:	11 f0       	breq	.+4      	; 0xc986 <FSettingPumpID+0x2c0>
    c982:	83 e0       	ldi	r24, 0x03	; 3
    c984:	05 c0       	rjmp	.+10     	; 0xc990 <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    c986:	85 e0       	ldi	r24, 0x05	; 5
    c988:	03 c0       	rjmp	.+6      	; 0xc990 <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    c98a:	9a 32       	cpi	r25, 0x2A	; 42
    c98c:	19 f4       	brne	.+6      	; 0xc994 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    c98e:	8a e0       	ldi	r24, 0x0A	; 10
    c990:	80 93 1a 02 	sts	0x021A, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    c994:	8b e7       	ldi	r24, 0x7B	; 123
    c996:	98 16       	cp	r9, r24
    c998:	09 f0       	breq	.+2      	; 0xc99c <FSettingPumpID+0x2d6>
    c99a:	25 c1       	rjmp	.+586    	; 0xcbe6 <FSettingPumpID+0x520>
		      if (IsShift==False)IsShift=True;
    c99c:	80 91 19 02 	lds	r24, 0x0219
    c9a0:	88 23       	and	r24, r24
    c9a2:	21 f4       	brne	.+8      	; 0xc9ac <FSettingPumpID+0x2e6>
    c9a4:	81 e0       	ldi	r24, 0x01	; 1
    c9a6:	80 93 19 02 	sts	0x0219, r24
    c9aa:	1d c1       	rjmp	.+570    	; 0xcbe6 <FSettingPumpID+0x520>
			  else
			  if (IsShift==True)IsShift=False;
    c9ac:	81 30       	cpi	r24, 0x01	; 1
    c9ae:	09 f0       	breq	.+2      	; 0xc9b2 <FSettingPumpID+0x2ec>
    c9b0:	1a c1       	rjmp	.+564    	; 0xcbe6 <FSettingPumpID+0x520>
    c9b2:	10 92 19 02 	sts	0x0219, r1
    c9b6:	17 c1       	rjmp	.+558    	; 0xcbe6 <FSettingPumpID+0x520>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    c9b8:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    c9bc:	81 e0       	ldi	r24, 0x01	; 1
    c9be:	61 e0       	ldi	r22, 0x01	; 1
    c9c0:	44 ef       	ldi	r20, 0xF4	; 244
    c9c2:	5d e0       	ldi	r21, 0x0D	; 13
    c9c4:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    c9c8:	82 e0       	ldi	r24, 0x02	; 2
    c9ca:	61 e0       	ldi	r22, 0x01	; 1
    c9cc:	4f ed       	ldi	r20, 0xDF	; 223
    c9ce:	5d e0       	ldi	r21, 0x0D	; 13
    c9d0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    c9d4:	83 e0       	ldi	r24, 0x03	; 3
    c9d6:	61 e0       	ldi	r22, 0x01	; 1
    c9d8:	4a ec       	ldi	r20, 0xCA	; 202
    c9da:	5d e0       	ldi	r21, 0x0D	; 13
    c9dc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c9e0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c9e2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c9e4:	82 e0       	ldi	r24, 0x02	; 2
    c9e6:	80 93 bc 01 	sts	0x01BC, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    c9ea:	10 92 92 01 	sts	0x0192, r1
	      stMenuPumpID=mpDisplayFailed;
    c9ee:	84 e0       	ldi	r24, 0x04	; 4
    c9f0:	e5 c0       	rjmp	.+458    	; 0xcbbc <FSettingPumpID+0x4f6>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    c9f2:	80 91 92 01 	lds	r24, 0x0192
    c9f6:	87 30       	cpi	r24, 0x07	; 7
    c9f8:	08 f4       	brcc	.+2      	; 0xc9fc <FSettingPumpID+0x336>
    c9fa:	f5 c0       	rjmp	.+490    	; 0xcbe6 <FSettingPumpID+0x520>
    c9fc:	81 e0       	ldi	r24, 0x01	; 1
    c9fe:	de c0       	rjmp	.+444    	; 0xcbbc <FSettingPumpID+0x4f6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    ca00:	85 e4       	ldi	r24, 0x45	; 69
    ca02:	90 e0       	ldi	r25, 0x00	; 0
    ca04:	60 e1       	ldi	r22, 0x10	; 16
    ca06:	72 e0       	ldi	r23, 0x02	; 2
    ca08:	48 e0       	ldi	r20, 0x08	; 8
    ca0a:	50 e0       	ldi	r21, 0x00	; 0
    ca0c:	2a ed       	ldi	r18, 0xDA	; 218
    ca0e:	33 e1       	ldi	r19, 0x13	; 19
    ca10:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    ca14:	80 91 00 01 	lds	r24, 0x0100
    ca18:	82 30       	cpi	r24, 0x02	; 2
    ca1a:	e9 f4       	brne	.+58     	; 0xca56 <FSettingPumpID+0x390>
		      //SendConfig to Slave
			  lcd_clear();
    ca1c:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    ca20:	81 e0       	ldi	r24, 0x01	; 1
    ca22:	61 e0       	ldi	r22, 0x01	; 1
    ca24:	41 ec       	ldi	r20, 0xC1	; 193
    ca26:	5d e0       	ldi	r21, 0x0D	; 13
    ca28:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    ca2c:	82 e0       	ldi	r24, 0x02	; 2
    ca2e:	61 e0       	ldi	r22, 0x01	; 1
    ca30:	48 eb       	ldi	r20, 0xB8	; 184
    ca32:	5d e0       	ldi	r21, 0x0D	; 13
    ca34:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			  Idx=0;
    ca38:	10 92 18 02 	sts	0x0218, r1
			  PumpCount=0;
    ca3c:	10 92 0e 02 	sts	0x020E, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ca40:	80 e1       	ldi	r24, 0x10	; 16
    ca42:	92 e0       	ldi	r25, 0x02	; 2
    ca44:	65 e4       	ldi	r22, 0x45	; 69
    ca46:	70 e0       	ldi	r23, 0x00	; 0
    ca48:	48 e0       	ldi	r20, 0x08	; 8
    ca4a:	50 e0       	ldi	r21, 0x00	; 0
    ca4c:	22 ed       	ldi	r18, 0xD2	; 210
    ca4e:	33 e1       	ldi	r19, 0x13	; 19
    ca50:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    ca54:	b2 c0       	rjmp	.+356    	; 0xcbba <FSettingPumpID+0x4f4>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    ca56:	81 30       	cpi	r24, 0x01	; 1
    ca58:	09 f0       	breq	.+2      	; 0xca5c <FSettingPumpID+0x396>
    ca5a:	c5 c0       	rjmp	.+394    	; 0xcbe6 <FSettingPumpID+0x520>
    ca5c:	b6 c0       	rjmp	.+364    	; 0xcbca <FSettingPumpID+0x504>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    ca5e:	10 92 82 01 	sts	0x0182, r1
	      if (PPumpId[Idx]!=0){
    ca62:	90 91 18 02 	lds	r25, 0x0218
    ca66:	29 2f       	mov	r18, r25
    ca68:	30 e0       	ldi	r19, 0x00	; 0
    ca6a:	f9 01       	movw	r30, r18
    ca6c:	e0 5f       	subi	r30, 0xF0	; 240
    ca6e:	fd 4f       	sbci	r31, 0xFD	; 253
    ca70:	60 81       	ld	r22, Z
    ca72:	66 23       	and	r22, r22
    ca74:	81 f0       	breq	.+32     	; 0xca96 <FSettingPumpID+0x3d0>
		      PumpCount++;
    ca76:	80 91 0e 02 	lds	r24, 0x020E
    ca7a:	8f 5f       	subi	r24, 0xFF	; 255
    ca7c:	80 93 0e 02 	sts	0x020E, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    ca80:	6f 70       	andi	r22, 0x0F	; 15
    ca82:	74 e0       	ldi	r23, 0x04	; 4
    ca84:	22 0f       	add	r18, r18
    ca86:	33 1f       	adc	r19, r19
    ca88:	7a 95       	dec	r23
    ca8a:	e1 f7       	brne	.-8      	; 0xca84 <FSettingPumpID+0x3be>
    ca8c:	62 2b       	or	r22, r18
    ca8e:	60 93 0f 02 	sts	0x020F, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    ca92:	8d e1       	ldi	r24, 0x1D	; 29
    ca94:	02 c0       	rjmp	.+4      	; 0xca9a <FSettingPumpID+0x3d4>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    ca96:	8e e1       	ldi	r24, 0x1E	; 30
    ca98:	69 2f       	mov	r22, r25
    ca9a:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    ca9e:	e0 91 18 02 	lds	r30, 0x0218
    caa2:	f0 e0       	ldi	r31, 0x00	; 0
    caa4:	ad b7       	in	r26, 0x3d	; 61
    caa6:	be b7       	in	r27, 0x3e	; 62
    caa8:	18 97       	sbiw	r26, 0x08	; 8
    caaa:	0f b6       	in	r0, 0x3f	; 63
    caac:	f8 94       	cli
    caae:	be bf       	out	0x3e, r27	; 62
    cab0:	0f be       	out	0x3f, r0	; 63
    cab2:	ad bf       	out	0x3d, r26	; 61
    cab4:	2d b7       	in	r18, 0x3d	; 61
    cab6:	3e b7       	in	r19, 0x3e	; 62
    cab8:	2f 5f       	subi	r18, 0xFF	; 255
    caba:	3f 4f       	sbci	r19, 0xFF	; 255
    cabc:	8e 01       	movw	r16, r28
    cabe:	0f 5f       	subi	r16, 0xFF	; 255
    cac0:	1f 4f       	sbci	r17, 0xFF	; 255
    cac2:	12 96       	adiw	r26, 0x02	; 2
    cac4:	1c 93       	st	X, r17
    cac6:	0e 93       	st	-X, r16
    cac8:	11 97       	sbiw	r26, 0x01	; 1
    caca:	8a ea       	ldi	r24, 0xAA	; 170
    cacc:	9d e0       	ldi	r25, 0x0D	; 13
    cace:	d9 01       	movw	r26, r18
    cad0:	13 96       	adiw	r26, 0x03	; 3
    cad2:	9c 93       	st	X, r25
    cad4:	8e 93       	st	-X, r24
    cad6:	12 97       	sbiw	r26, 0x02	; 2
    cad8:	31 96       	adiw	r30, 0x01	; 1
    cada:	15 96       	adiw	r26, 0x05	; 5
    cadc:	fc 93       	st	X, r31
    cade:	ee 93       	st	-X, r30
    cae0:	14 97       	sbiw	r26, 0x04	; 4
    cae2:	31 97       	sbiw	r30, 0x01	; 1
    cae4:	e0 5f       	subi	r30, 0xF0	; 240
    cae6:	fd 4f       	sbci	r31, 0xFD	; 253
    cae8:	80 81       	ld	r24, Z
    caea:	16 96       	adiw	r26, 0x06	; 6
    caec:	8c 93       	st	X, r24
    caee:	16 97       	sbiw	r26, 0x06	; 6
    caf0:	17 96       	adiw	r26, 0x07	; 7
    caf2:	1c 92       	st	X, r1
    caf4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(3,1,lcdteks);
    caf8:	ed b7       	in	r30, 0x3d	; 61
    cafa:	fe b7       	in	r31, 0x3e	; 62
    cafc:	38 96       	adiw	r30, 0x08	; 8
    cafe:	0f b6       	in	r0, 0x3f	; 63
    cb00:	f8 94       	cli
    cb02:	fe bf       	out	0x3e, r31	; 62
    cb04:	0f be       	out	0x3f, r0	; 63
    cb06:	ed bf       	out	0x3d, r30	; 61
    cb08:	83 e0       	ldi	r24, 0x03	; 3
    cb0a:	61 e0       	ldi	r22, 0x01	; 1
    cb0c:	a8 01       	movw	r20, r16
    cb0e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    cb12:	88 e0       	ldi	r24, 0x08	; 8
    cb14:	53 c0       	rjmp	.+166    	; 0xcbbc <FSettingPumpID+0x4f6>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    cb16:	81 e0       	ldi	r24, 0x01	; 1
    cb18:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    cb1c:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  if (KeyChar=='*'){
    cb20:	8a 32       	cpi	r24, 0x2A	; 42
    cb22:	79 f4       	brne	.+30     	; 0xcb42 <FSettingPumpID+0x47c>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    cb24:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    cb26:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    cb28:	82 e0       	ldi	r24, 0x02	; 2
    cb2a:	80 93 bc 01 	sts	0x01BC, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    cb2e:	61 e0       	ldi	r22, 0x01	; 1
    cb30:	4e e9       	ldi	r20, 0x9E	; 158
    cb32:	5d e0       	ldi	r21, 0x0D	; 13
    cb34:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			  TimDisplay=0;
    cb38:	10 92 92 01 	sts	0x0192, r1
		      stMenuPumpID=mpDelayExitPumpId;
    cb3c:	89 e0       	ldi	r24, 0x09	; 9
    cb3e:	80 93 1a 02 	sts	0x021A, r24
			  }
          if (IsStandaloneAcknoledge==True){
    cb42:	80 91 82 01 	lds	r24, 0x0182
    cb46:	81 30       	cpi	r24, 0x01	; 1
    cb48:	09 f0       	breq	.+2      	; 0xcb4c <FSettingPumpID+0x486>
    cb4a:	4d c0       	rjmp	.+154    	; 0xcbe6 <FSettingPumpID+0x520>
		      Idx++;
    cb4c:	80 91 18 02 	lds	r24, 0x0218
    cb50:	8f 5f       	subi	r24, 0xFF	; 255
    cb52:	80 93 18 02 	sts	0x0218, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    cb56:	88 30       	cpi	r24, 0x08	; 8
    cb58:	10 f5       	brcc	.+68     	; 0xcb9e <FSettingPumpID+0x4d8>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    cb5a:	20 91 0e 02 	lds	r18, 0x020E
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    cb5e:	e1 99       	sbic	0x1c, 1	; 28
    cb60:	fe cf       	rjmp	.-4      	; 0xcb5e <FSettingPumpID+0x498>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cb62:	84 e4       	ldi	r24, 0x44	; 68
    cb64:	91 e0       	ldi	r25, 0x01	; 1
    cb66:	9f bb       	out	0x1f, r25	; 31
    cb68:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    cb6a:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    cb6c:	0f b6       	in	r0, 0x3f	; 63
    cb6e:	f8 94       	cli
    cb70:	e2 9a       	sbi	0x1c, 2	; 28
    cb72:	e1 9a       	sbi	0x1c, 1	; 28
    cb74:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    cb76:	e1 99       	sbic	0x1c, 1	; 28
    cb78:	fe cf       	rjmp	.-4      	; 0xcb76 <FSettingPumpID+0x4b0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cb7a:	9f bb       	out	0x1f, r25	; 31
    cb7c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    cb7e:	e0 9a       	sbi	0x1c, 0	; 28
    cb80:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    cb82:	90 93 5c 01 	sts	0x015C, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    cb86:	85 e1       	ldi	r24, 0x15	; 21
    cb88:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    cb8c:	90 93 d3 0b 	sts	0x0BD3, r25
     IsControlPooling=True;
    cb90:	81 e0       	ldi	r24, 0x01	; 1
    cb92:	80 93 84 01 	sts	0x0184, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    cb96:	10 92 92 01 	sts	0x0192, r1
				  stMenuPumpID=mpDelaySaveConfig;
    cb9a:	87 e0       	ldi	r24, 0x07	; 7
    cb9c:	0f c0       	rjmp	.+30     	; 0xcbbc <FSettingPumpID+0x4f6>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    cb9e:	82 e0       	ldi	r24, 0x02	; 2
    cba0:	61 e0       	ldi	r22, 0x01	; 1
    cba2:	44 e9       	ldi	r20, 0x94	; 148
    cba4:	5d e0       	ldi	r21, 0x0D	; 13
    cba6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					TimDisplay=0;
    cbaa:	10 92 92 01 	sts	0x0192, r1
				    stMenuPumpID=mpDelayExitPumpId;
    cbae:	89 e0       	ldi	r24, 0x09	; 9
    cbb0:	05 c0       	rjmp	.+10     	; 0xcbbc <FSettingPumpID+0x4f6>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    cbb2:	80 91 92 01 	lds	r24, 0x0192
    cbb6:	83 30       	cpi	r24, 0x03	; 3
    cbb8:	b0 f0       	brcs	.+44     	; 0xcbe6 <FSettingPumpID+0x520>
    cbba:	86 e0       	ldi	r24, 0x06	; 6
    cbbc:	80 93 1a 02 	sts	0x021A, r24
    cbc0:	12 c0       	rjmp	.+36     	; 0xcbe6 <FSettingPumpID+0x520>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    cbc2:	80 91 92 01 	lds	r24, 0x0192
    cbc6:	89 30       	cpi	r24, 0x09	; 9
    cbc8:	70 f0       	brcs	.+28     	; 0xcbe6 <FSettingPumpID+0x520>
    cbca:	8a e0       	ldi	r24, 0x0A	; 10
    cbcc:	f7 cf       	rjmp	.-18     	; 0xcbbc <FSettingPumpID+0x4f6>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    cbce:	80 91 00 01 	lds	r24, 0x0100
    cbd2:	82 30       	cpi	r24, 0x02	; 2
    cbd4:	21 f4       	brne	.+8      	; 0xcbde <FSettingPumpID+0x518>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    cbd6:	80 e2       	ldi	r24, 0x20	; 32
    cbd8:	60 e0       	ldi	r22, 0x00	; 0
    cbda:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    cbde:	10 92 1a 02 	sts	0x021A, r1
    cbe2:	81 e0       	ldi	r24, 0x01	; 1
    cbe4:	01 c0       	rjmp	.+2      	; 0xcbe8 <FSettingPumpID+0x522>
    cbe6:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    cbe8:	64 96       	adiw	r28, 0x14	; 20
    cbea:	0f b6       	in	r0, 0x3f	; 63
    cbec:	f8 94       	cli
    cbee:	de bf       	out	0x3e, r29	; 62
    cbf0:	0f be       	out	0x3f, r0	; 63
    cbf2:	cd bf       	out	0x3d, r28	; 61
    cbf4:	cf 91       	pop	r28
    cbf6:	df 91       	pop	r29
    cbf8:	1f 91       	pop	r17
    cbfa:	0f 91       	pop	r16
    cbfc:	ff 90       	pop	r15
    cbfe:	ef 90       	pop	r14
    cc00:	df 90       	pop	r13
    cc02:	cf 90       	pop	r12
    cc04:	bf 90       	pop	r11
    cc06:	af 90       	pop	r10
    cc08:	9f 90       	pop	r9
    cc0a:	08 95       	ret

0000cc0c <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    cc0c:	0e 94 63 63 	call	0xc6c6	; 0xc6c6 <FSettingPumpID>
    cc10:	81 30       	cpi	r24, 0x01	; 1
    cc12:	e1 f7       	brne	.-8      	; 0xcc0c <_menu_pumpid>
	       break;
	   }	   
	}
}
    cc14:	08 95       	ret

0000cc16 <_menu_pump>:
        lcd_printf(4,15,PSTR("*)Exit"));
}



void _menu_pump(void){
    cc16:	cf 93       	push	r28
    cc18:	df 93       	push	r29
    cc1a:	c0 e0       	ldi	r28, 0x00	; 0
    cc1c:	d0 e9       	ldi	r29, 0x90	; 144
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    cc1e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    cc22:	ce 01       	movw	r24, r28
    cc24:	01 97       	sbiw	r24, 0x01	; 1
    cc26:	f1 f7       	brne	.-4      	; 0xcc24 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    cc28:	81 e0       	ldi	r24, 0x01	; 1
    cc2a:	61 e0       	ldi	r22, 0x01	; 1
    cc2c:	48 ec       	ldi	r20, 0xC8	; 200
    cc2e:	5e e0       	ldi	r21, 0x0E	; 14
    cc30:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    cc34:	82 e0       	ldi	r24, 0x02	; 2
    cc36:	61 e0       	ldi	r22, 0x01	; 1
    cc38:	4e eb       	ldi	r20, 0xBE	; 190
    cc3a:	5e e0       	ldi	r21, 0x0E	; 14
    cc3c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    cc40:	84 e0       	ldi	r24, 0x04	; 4
    cc42:	61 e0       	ldi	r22, 0x01	; 1
    cc44:	47 eb       	ldi	r20, 0xB7	; 183
    cc46:	5e e0       	ldi	r21, 0x0E	; 14
    cc48:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>

		while(1){
			__key = _key_scan(1);
    cc4c:	81 e0       	ldi	r24, 0x01	; 1
    cc4e:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
			if(__key == _KEY_CANCEL)
    cc52:	87 3e       	cpi	r24, 0xE7	; 231
    cc54:	51 f0       	breq	.+20     	; 0xcc6a <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    cc56:	8e 3e       	cpi	r24, 0xEE	; 238
    cc58:	19 f4       	brne	.+6      	; 0xcc60 <_menu_pump+0x4a>
				_menu_pumpid();
    cc5a:	0e 94 06 66 	call	0xcc0c	; 0xcc0c <_menu_pumpid>
    cc5e:	df cf       	rjmp	.-66     	; 0xcc1e <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    cc60:	8e 3d       	cpi	r24, 0xDE	; 222
    cc62:	a1 f7       	brne	.-24     	; 0xcc4c <_menu_pump+0x36>
				_menu_pumpprod();
    cc64:	0e 94 00 53 	call	0xa600	; 0xa600 <_menu_pumpprod>
    cc68:	da cf       	rjmp	.-76     	; 0xcc1e <_menu_pump+0x8>
				break;
			}
		}
	}
}
    cc6a:	df 91       	pop	r29
    cc6c:	cf 91       	pop	r28
    cc6e:	08 95       	ret

0000cc70 <FMenuPumpType>:





void FMenuPumpType(){
    cc70:	cf 92       	push	r12
    cc72:	df 92       	push	r13
    cc74:	ef 92       	push	r14
    cc76:	ff 92       	push	r15
    cc78:	0f 93       	push	r16
    cc7a:	1f 93       	push	r17
    cc7c:	df 93       	push	r29
    cc7e:	cf 93       	push	r28
    cc80:	cd b7       	in	r28, 0x3d	; 61
    cc82:	de b7       	in	r29, 0x3e	; 62
    cc84:	a8 97       	sbiw	r28, 0x28	; 40
    cc86:	0f b6       	in	r0, 0x3f	; 63
    cc88:	f8 94       	cli
    cc8a:	de bf       	out	0x3e, r29	; 62
    cc8c:	0f be       	out	0x3f, r0	; 63
    cc8e:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    cc90:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    cc94:	81 e0       	ldi	r24, 0x01	; 1
    cc96:	61 e0       	ldi	r22, 0x01	; 1
    cc98:	45 ea       	ldi	r20, 0xA5	; 165
    cc9a:	5e e0       	ldi	r21, 0x0E	; 14
    cc9c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    cca0:	e1 99       	sbic	0x1c, 1	; 28
    cca2:	fe cf       	rjmp	.-4      	; 0xcca0 <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cca4:	87 e3       	ldi	r24, 0x37	; 55
    cca6:	91 e0       	ldi	r25, 0x01	; 1
    cca8:	9f bb       	out	0x1f, r25	; 31
    ccaa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ccac:	e0 9a       	sbi	0x1c, 0	; 28
    ccae:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    ccb0:	03 30       	cpi	r16, 0x03	; 3
    ccb2:	08 f0       	brcs	.+2      	; 0xccb6 <FMenuPumpType+0x46>
    ccb4:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    ccb6:	10 e0       	ldi	r17, 0x00	; 0
    ccb8:	f8 01       	movw	r30, r16
    ccba:	ee 0f       	add	r30, r30
    ccbc:	ff 1f       	adc	r31, r31
    ccbe:	eb 5f       	subi	r30, 0xFB	; 251
    ccc0:	fc 4f       	sbci	r31, 0xFC	; 252
    ccc2:	65 91       	lpm	r22, Z+
    ccc4:	74 91       	lpm	r23, Z+
    ccc6:	85 e1       	ldi	r24, 0x15	; 21
    ccc8:	c8 2e       	mov	r12, r24
    ccca:	d1 2c       	mov	r13, r1
    cccc:	cc 0e       	add	r12, r28
    ccce:	dd 1e       	adc	r13, r29
    ccd0:	c6 01       	movw	r24, r12
    ccd2:	0e 94 75 af 	call	0x15eea	; 0x15eea <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    ccd6:	8d b7       	in	r24, 0x3d	; 61
    ccd8:	9e b7       	in	r25, 0x3e	; 62
    ccda:	08 97       	sbiw	r24, 0x08	; 8
    ccdc:	0f b6       	in	r0, 0x3f	; 63
    ccde:	f8 94       	cli
    cce0:	9e bf       	out	0x3e, r25	; 62
    cce2:	0f be       	out	0x3f, r0	; 63
    cce4:	8d bf       	out	0x3d, r24	; 61
    cce6:	ed b7       	in	r30, 0x3d	; 61
    cce8:	fe b7       	in	r31, 0x3e	; 62
    ccea:	31 96       	adiw	r30, 0x01	; 1
    ccec:	7e 01       	movw	r14, r28
    ccee:	08 94       	sec
    ccf0:	e1 1c       	adc	r14, r1
    ccf2:	f1 1c       	adc	r15, r1
    ccf4:	ad b7       	in	r26, 0x3d	; 61
    ccf6:	be b7       	in	r27, 0x3e	; 62
    ccf8:	12 96       	adiw	r26, 0x02	; 2
    ccfa:	fc 92       	st	X, r15
    ccfc:	ee 92       	st	-X, r14
    ccfe:	11 97       	sbiw	r26, 0x01	; 1
    cd00:	8f e9       	ldi	r24, 0x9F	; 159
    cd02:	9e e0       	ldi	r25, 0x0E	; 14
    cd04:	93 83       	std	Z+3, r25	; 0x03
    cd06:	82 83       	std	Z+2, r24	; 0x02
    cd08:	0f 5f       	subi	r16, 0xFF	; 255
    cd0a:	1f 4f       	sbci	r17, 0xFF	; 255
    cd0c:	15 83       	std	Z+5, r17	; 0x05
    cd0e:	04 83       	std	Z+4, r16	; 0x04
    cd10:	d7 82       	std	Z+7, r13	; 0x07
    cd12:	c6 82       	std	Z+6, r12	; 0x06
    cd14:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			   lcd_print(2,1,lcdteks);
    cd18:	8d b7       	in	r24, 0x3d	; 61
    cd1a:	9e b7       	in	r25, 0x3e	; 62
    cd1c:	08 96       	adiw	r24, 0x08	; 8
    cd1e:	0f b6       	in	r0, 0x3f	; 63
    cd20:	f8 94       	cli
    cd22:	9e bf       	out	0x3e, r25	; 62
    cd24:	0f be       	out	0x3f, r0	; 63
    cd26:	8d bf       	out	0x3d, r24	; 61
    cd28:	82 e0       	ldi	r24, 0x02	; 2
    cd2a:	61 e0       	ldi	r22, 0x01	; 1
    cd2c:	a7 01       	movw	r20, r14
    cd2e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    cd32:	84 e0       	ldi	r24, 0x04	; 4
    cd34:	61 e0       	ldi	r22, 0x01	; 1
    cd36:	4b e8       	ldi	r20, 0x8B	; 139
    cd38:	5e e0       	ldi	r21, 0x0E	; 14
    cd3a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   if (IFType==IT_STANDALONE)
    cd3e:	80 91 00 01 	lds	r24, 0x0100
    cd42:	82 30       	cpi	r24, 0x02	; 2
    cd44:	21 f4       	brne	.+8      	; 0xcd4e <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    cd46:	8f e1       	ldi	r24, 0x1F	; 31
    cd48:	60 e0       	ldi	r22, 0x00	; 0
    cd4a:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    cd4e:	81 e0       	ldi	r24, 0x01	; 1
    cd50:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    cd54:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>

			   if (KeyChar=='#'){
    cd58:	83 32       	cpi	r24, 0x23	; 35
    cd5a:	09 f0       	breq	.+2      	; 0xcd5e <FMenuPumpType+0xee>
    cd5c:	2d c0       	rjmp	.+90     	; 0xcdb8 <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    cd5e:	e1 99       	sbic	0x1c, 1	; 28
    cd60:	fe cf       	rjmp	.-4      	; 0xcd5e <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cd62:	07 e3       	ldi	r16, 0x37	; 55
    cd64:	11 e0       	ldi	r17, 0x01	; 1
    cd66:	1f bb       	out	0x1f, r17	; 31
    cd68:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    cd6a:	e0 9a       	sbi	0x1c, 0	; 28
    cd6c:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    cd6e:	82 30       	cpi	r24, 0x02	; 2
    cd70:	20 f4       	brcc	.+8      	; 0xcd7a <FMenuPumpType+0x10a>
				        DispenserBrand++;
    cd72:	8f 5f       	subi	r24, 0xFF	; 255
    cd74:	80 93 5e 01 	sts	0x015E, r24
    cd78:	02 c0       	rjmp	.+4      	; 0xcd7e <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    cd7a:	10 92 5e 01 	sts	0x015E, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    cd7e:	80 91 5e 01 	lds	r24, 0x015E
    cd82:	0e 94 38 1b 	call	0x3670	; 0x3670 <SetDispenser>
			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    cd86:	80 91 5e 01 	lds	r24, 0x015E
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    cd8a:	e1 99       	sbic	0x1c, 1	; 28
    cd8c:	fe cf       	rjmp	.-4      	; 0xcd8a <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cd8e:	1f bb       	out	0x1f, r17	; 31
    cd90:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    cd92:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    cd94:	0f b6       	in	r0, 0x3f	; 63
    cd96:	f8 94       	cli
    cd98:	e2 9a       	sbi	0x1c, 2	; 28
    cd9a:	e1 9a       	sbi	0x1c, 1	; 28
    cd9c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    cd9e:	e1 99       	sbic	0x1c, 1	; 28
    cda0:	fe cf       	rjmp	.-4      	; 0xcd9e <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    cda2:	1f bb       	out	0x1f, r17	; 31
    cda4:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    cda6:	e0 9a       	sbi	0x1c, 0	; 28
    cda8:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    cdaa:	8c e1       	ldi	r24, 0x1C	; 28
    cdac:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    cdb0:	81 e0       	ldi	r24, 0x01	; 1
    cdb2:	80 93 23 01 	sts	0x0123, r24
    cdb6:	0c c0       	rjmp	.+24     	; 0xcdd0 <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    cdb8:	8a 32       	cpi	r24, 0x2A	; 42
    cdba:	09 f0       	breq	.+2      	; 0xcdbe <FMenuPumpType+0x14e>
    cdbc:	c8 cf       	rjmp	.-112    	; 0xcd4e <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    cdbe:	80 91 00 01 	lds	r24, 0x0100
    cdc2:	82 30       	cpi	r24, 0x02	; 2
    cdc4:	51 f4       	brne	.+20     	; 0xcdda <FMenuPumpType+0x16a>
    cdc6:	80 e2       	ldi	r24, 0x20	; 32
    cdc8:	60 e0       	ldi	r22, 0x00	; 0
    cdca:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
    cdce:	05 c0       	rjmp	.+10     	; 0xcdda <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    cdd0:	80 91 23 01 	lds	r24, 0x0123
    cdd4:	81 30       	cpi	r24, 0x01	; 1
    cdd6:	e1 f7       	brne	.-8      	; 0xcdd0 <FMenuPumpType+0x160>
    cdd8:	5b cf       	rjmp	.-330    	; 0xcc90 <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    cdda:	a8 96       	adiw	r28, 0x28	; 40
    cddc:	0f b6       	in	r0, 0x3f	; 63
    cdde:	f8 94       	cli
    cde0:	de bf       	out	0x3e, r29	; 62
    cde2:	0f be       	out	0x3f, r0	; 63
    cde4:	cd bf       	out	0x3d, r28	; 61
    cde6:	cf 91       	pop	r28
    cde8:	df 91       	pop	r29
    cdea:	1f 91       	pop	r17
    cdec:	0f 91       	pop	r16
    cdee:	ff 90       	pop	r15
    cdf0:	ef 90       	pop	r14
    cdf2:	df 90       	pop	r13
    cdf4:	cf 90       	pop	r12
    cdf6:	08 95       	ret

0000cdf8 <FSettingPump>:
	      break;
	 
	 }
*/
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    cdf8:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    cdfc:	80 e0       	ldi	r24, 0x00	; 0
    cdfe:	90 e9       	ldi	r25, 0x90	; 144
    ce00:	01 97       	sbiw	r24, 0x01	; 1
    ce02:	f1 f7       	brne	.-4      	; 0xce00 <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    ce04:	81 e0       	ldi	r24, 0x01	; 1
    ce06:	61 e0       	ldi	r22, 0x01	; 1
    ce08:	44 e2       	ldi	r20, 0x24	; 36
    ce0a:	53 e1       	ldi	r21, 0x13	; 19
    ce0c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    ce10:	82 e0       	ldi	r24, 0x02	; 2
    ce12:	61 e0       	ldi	r22, 0x01	; 1
    ce14:	4a e1       	ldi	r20, 0x1A	; 26
    ce16:	53 e1       	ldi	r21, 0x13	; 19
    ce18:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		if (IFType==IT_STANDALONE){
    ce1c:	80 91 00 01 	lds	r24, 0x0100
    ce20:	82 30       	cpi	r24, 0x02	; 2
    ce22:	61 f4       	brne	.+24     	; 0xce3c <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    ce24:	83 e0       	ldi	r24, 0x03	; 3
    ce26:	61 e0       	ldi	r22, 0x01	; 1
    ce28:	40 e1       	ldi	r20, 0x10	; 16
    ce2a:	53 e1       	ldi	r21, 0x13	; 19
    ce2c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    ce30:	84 e0       	ldi	r24, 0x04	; 4
    ce32:	61 e0       	ldi	r22, 0x01	; 1
    ce34:	40 e0       	ldi	r20, 0x00	; 0
    ce36:	53 e1       	ldi	r21, 0x13	; 19
    ce38:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    ce3c:	81 e0       	ldi	r24, 0x01	; 1
    ce3e:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
			if(__key == _KEY_CANCEL)
    ce42:	87 3e       	cpi	r24, 0xE7	; 231
    ce44:	d9 f0       	breq	.+54     	; 0xce7c <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    ce46:	8e 3e       	cpi	r24, 0xEE	; 238
    ce48:	19 f4       	brne	.+6      	; 0xce50 <FSettingPump+0x58>
				_menu_pumpid();
    ce4a:	0e 94 06 66 	call	0xcc0c	; 0xcc0c <_menu_pumpid>
    ce4e:	16 c0       	rjmp	.+44     	; 0xce7c <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    ce50:	8e 3d       	cpi	r24, 0xDE	; 222
    ce52:	19 f4       	brne	.+6      	; 0xce5a <FSettingPump+0x62>
				_menu_pumpprod();
    ce54:	0e 94 00 53 	call	0xa600	; 0xa600 <_menu_pumpprod>
    ce58:	11 c0       	rjmp	.+34     	; 0xce7c <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    ce5a:	8e 3b       	cpi	r24, 0xBE	; 190
    ce5c:	39 f4       	brne	.+14     	; 0xce6c <FSettingPump+0x74>
    ce5e:	80 91 00 01 	lds	r24, 0x0100
    ce62:	82 30       	cpi	r24, 0x02	; 2
    ce64:	59 f7       	brne	.-42     	; 0xce3c <FSettingPump+0x44>
			    FMenuPumpLabel();
    ce66:	0e 94 13 53 	call	0xa626	; 0xa626 <FMenuPumpLabel>
    ce6a:	08 c0       	rjmp	.+16     	; 0xce7c <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    ce6c:	8d 3e       	cpi	r24, 0xED	; 237
    ce6e:	31 f7       	brne	.-52     	; 0xce3c <FSettingPump+0x44>
    ce70:	80 91 00 01 	lds	r24, 0x0100
    ce74:	82 30       	cpi	r24, 0x02	; 2
    ce76:	11 f7       	brne	.-60     	; 0xce3c <FSettingPump+0x44>
			    FMenuPumpType();
    ce78:	0e 94 38 66 	call	0xcc70	; 0xcc70 <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    ce7c:	81 e0       	ldi	r24, 0x01	; 1
    ce7e:	08 95       	ret

0000ce80 <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    ce80:	2f 92       	push	r2
    ce82:	3f 92       	push	r3
    ce84:	4f 92       	push	r4
    ce86:	5f 92       	push	r5
    ce88:	6f 92       	push	r6
    ce8a:	7f 92       	push	r7
    ce8c:	8f 92       	push	r8
    ce8e:	9f 92       	push	r9
    ce90:	af 92       	push	r10
    ce92:	bf 92       	push	r11
    ce94:	cf 92       	push	r12
    ce96:	df 92       	push	r13
    ce98:	ef 92       	push	r14
    ce9a:	ff 92       	push	r15
    ce9c:	0f 93       	push	r16
    ce9e:	1f 93       	push	r17
    cea0:	df 93       	push	r29
    cea2:	cf 93       	push	r28
    cea4:	cd b7       	in	r28, 0x3d	; 61
    cea6:	de b7       	in	r29, 0x3e	; 62
    cea8:	e1 97       	sbiw	r28, 0x31	; 49
    ceaa:	0f b6       	in	r0, 0x3f	; 63
    ceac:	f8 94       	cli
    ceae:	de bf       	out	0x3e, r29	; 62
    ceb0:	0f be       	out	0x3f, r0	; 63
    ceb2:	cd bf       	out	0x3d, r28	; 61
    ceb4:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ceb6:	dc 01       	movw	r26, r24
    ceb8:	12 96       	adiw	r26, 0x02	; 2
    ceba:	8c 91       	ld	r24, X
    cebc:	12 97       	sbiw	r26, 0x02	; 2
    cebe:	89 83       	std	Y+1, r24	; 0x01
    cec0:	13 96       	adiw	r26, 0x03	; 3
    cec2:	8c 91       	ld	r24, X
    cec4:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    cec6:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    cec8:	8e 01       	movw	r16, r28
    ceca:	0f 5f       	subi	r16, 0xFF	; 255
    cecc:	1f 4f       	sbci	r17, 0xFF	; 255
    cece:	c8 01       	movw	r24, r16
    ced0:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    ced4:	c8 01       	movw	r24, r16
    ced6:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
    ceda:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    cedc:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
    cee0:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    cee2:	88 23       	and	r24, r24
    cee4:	09 f4       	brne	.+2      	; 0xcee8 <StoreStandaloneTransData+0x68>
    cee6:	1a c2       	rjmp	.+1076   	; 0xd31c <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    cee8:	f7 01       	movw	r30, r14
    ceea:	f4 81       	ldd	r31, Z+4	; 0x04
    ceec:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    ceee:	d7 01       	movw	r26, r14
    cef0:	15 96       	adiw	r26, 0x05	; 5
    cef2:	2c 90       	ld	r2, X
    cef4:	54 e0       	ldi	r21, 0x04	; 4
    cef6:	85 2e       	mov	r8, r21
    cef8:	91 2c       	mov	r9, r1
    cefa:	8c 0e       	add	r8, r28
    cefc:	9d 1e       	adc	r9, r29
    cefe:	f4 01       	movw	r30, r8
    cf00:	ce 01       	movw	r24, r28
    cf02:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    cf04:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cf06:	e8 17       	cp	r30, r24
    cf08:	f9 07       	cpc	r31, r25
    cf0a:	e1 f7       	brne	.-8      	; 0xcf04 <StoreStandaloneTransData+0x84>
    cf0c:	4d e1       	ldi	r20, 0x1D	; 29
    cf0e:	64 2e       	mov	r6, r20
    cf10:	71 2c       	mov	r7, r1
    cf12:	6c 0e       	add	r6, r28
    cf14:	7d 1e       	adc	r7, r29
    cf16:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    cf18:	ce 01       	movw	r24, r28
    cf1a:	87 96       	adiw	r24, 0x27	; 39
    cf1c:	f9 01       	movw	r30, r18
    cf1e:	11 92       	st	Z+, r1
    cf20:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cf22:	e8 17       	cp	r30, r24
    cf24:	f9 07       	cpc	r31, r25
    cf26:	d1 f7       	brne	.-12     	; 0xcf1c <StoreStandaloneTransData+0x9c>
    cf28:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    cf2a:	ce 01       	movw	r24, r28
    cf2c:	c1 96       	adiw	r24, 0x31	; 49
    cf2e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cf30:	e8 17       	cp	r30, r24
    cf32:	f9 07       	cpc	r31, r25
    cf34:	e1 f7       	brne	.-8      	; 0xcf2e <StoreStandaloneTransData+0xae>
    cf36:	a7 01       	movw	r20, r14
    cf38:	d7 01       	movw	r26, r14
    cf3a:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cf3c:	be 01       	movw	r22, r28
    cf3e:	66 5f       	subi	r22, 0xF6	; 246
    cf40:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    cf42:	16 96       	adiw	r26, 0x06	; 6
    cf44:	8c 91       	ld	r24, X
    cf46:	16 97       	sbiw	r26, 0x06	; 6
    cf48:	81 93       	st	Z+, r24
    cf4a:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cf4c:	e6 17       	cp	r30, r22
    cf4e:	f7 07       	cpc	r31, r23
    cf50:	c1 f7       	brne	.-16     	; 0xcf42 <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    cf52:	1a 86       	std	Y+10, r1	; 0x0a
    cf54:	d7 01       	movw	r26, r14
    cf56:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cf58:	be 01       	movw	r22, r28
    cf5a:	6b 5d       	subi	r22, 0xDB	; 219
    cf5c:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    cf5e:	1c 96       	adiw	r26, 0x0c	; 12
    cf60:	8c 91       	ld	r24, X
    cf62:	1c 97       	sbiw	r26, 0x0c	; 12
    cf64:	81 93       	st	Z+, r24
    cf66:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cf68:	e6 17       	cp	r30, r22
    cf6a:	f7 07       	cpc	r31, r23
    cf6c:	c1 f7       	brne	.-16     	; 0xcf5e <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    cf6e:	1d a2       	std	Y+37, r1	; 0x25
    cf70:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cf72:	be 01       	movw	r22, r28
    cf74:	69 5d       	subi	r22, 0xD9	; 217
    cf76:	7f 4f       	sbci	r23, 0xFF	; 255
    cf78:	9e 01       	movw	r18, r28
    cf7a:	21 5d       	subi	r18, 0xD1	; 209
    cf7c:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    cf7e:	da 01       	movw	r26, r20
    cf80:	54 96       	adiw	r26, 0x14	; 20
    cf82:	8c 91       	ld	r24, X
    cf84:	81 93       	st	Z+, r24
    cf86:	4f 5f       	subi	r20, 0xFF	; 255
    cf88:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cf8a:	e2 17       	cp	r30, r18
    cf8c:	f3 07       	cpc	r31, r19
    cf8e:	b9 f7       	brne	.-18     	; 0xcf7e <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    cf90:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    cf92:	f7 01       	movw	r30, r14
    cf94:	84 8d       	ldd	r24, Z+28	; 0x1c
    cf96:	80 53       	subi	r24, 0x30	; 48
    cf98:	8a 30       	cpi	r24, 0x0A	; 10
    cf9a:	98 f4       	brcc	.+38     	; 0xcfc2 <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //uart_print(1,1,strSend);
		 if  (TransDigit==8){
    cf9c:	88 30       	cpi	r24, 0x08	; 8
    cf9e:	89 f4       	brne	.+34     	; 0xcfc2 <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    cfa0:	fb 01       	movw	r30, r22
    cfa2:	01 90       	ld	r0, Z+
    cfa4:	00 20       	and	r0, r0
    cfa6:	e9 f7       	brne	.-6      	; 0xcfa2 <StoreStandaloneTransData+0x122>
    cfa8:	e6 1b       	sub	r30, r22
    cfaa:	f7 0b       	sbc	r31, r23
    cfac:	32 97       	sbiw	r30, 0x02	; 2
    cfae:	80 e0       	ldi	r24, 0x00	; 0
    cfb0:	90 e0       	ldi	r25, 0x00	; 0
    cfb2:	01 c0       	rjmp	.+2      	; 0xcfb6 <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cfb4:	01 96       	adiw	r24, 0x01	; 1
    cfb6:	8e 17       	cp	r24, r30
    cfb8:	9f 07       	cpc	r25, r31
    cfba:	e0 f3       	brcs	.-8      	; 0xcfb4 <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    cfbc:	ec 0f       	add	r30, r28
    cfbe:	fd 1f       	adc	r31, r29
    cfc0:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    cfc2:	34 e0       	ldi	r19, 0x04	; 4
    cfc4:	e3 2e       	mov	r14, r19
    cfc6:	f1 2c       	mov	r15, r1
    cfc8:	ec 0e       	add	r14, r28
    cfca:	fd 1e       	adc	r15, r29
    cfcc:	c7 01       	movw	r24, r14
    cfce:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		 RemZeroLead(strPVolume);
    cfd2:	2d e1       	ldi	r18, 0x1D	; 29
    cfd4:	a2 2e       	mov	r10, r18
    cfd6:	b1 2c       	mov	r11, r1
    cfd8:	ac 0e       	add	r10, r28
    cfda:	bd 1e       	adc	r11, r29
    cfdc:	c5 01       	movw	r24, r10
    cfde:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		 RemZeroLead(strPMoney);
    cfe2:	8e 01       	movw	r16, r28
    cfe4:	09 5d       	subi	r16, 0xD9	; 217
    cfe6:	1f 4f       	sbci	r17, 0xFF	; 255
    cfe8:	c8 01       	movw	r24, r16
    cfea:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    cfee:	c8 01       	movw	r24, r16
    cff0:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
    cff4:	89 2b       	or	r24, r25
    cff6:	09 f0       	breq	.+2      	; 0xcffa <StoreStandaloneTransData+0x17a>
    cff8:	46 c1       	rjmp	.+652    	; 0xd286 <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    cffa:	83 2d       	mov	r24, r3
    cffc:	8f 70       	andi	r24, 0x0F	; 15
    cffe:	63 e1       	ldi	r22, 0x13	; 19
    d000:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
    d004:	8b c1       	rjmp	.+790    	; 0xd31c <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    d006:	e1 99       	sbic	0x1c, 1	; 28
    d008:	fe cf       	rjmp	.-4      	; 0xd006 <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    d00a:	8f e3       	ldi	r24, 0x3F	; 63
    d00c:	91 e0       	ldi	r25, 0x01	; 1
    d00e:	9f bb       	out	0x1f, r25	; 31
    d010:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    d012:	e0 9a       	sbi	0x1c, 0	; 28
    d014:	2d b3       	in	r18, 0x1d	; 29
			 //uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    d016:	00 d0       	rcall	.+0      	; 0xd018 <StoreStandaloneTransData+0x198>
    d018:	00 d0       	rcall	.+0      	; 0xd01a <StoreStandaloneTransData+0x19a>
    d01a:	00 d0       	rcall	.+0      	; 0xd01c <StoreStandaloneTransData+0x19c>
    d01c:	ed b7       	in	r30, 0x3d	; 61
    d01e:	fe b7       	in	r31, 0x3e	; 62
    d020:	31 96       	adiw	r30, 0x01	; 1
    d022:	88 e6       	ldi	r24, 0x68	; 104
    d024:	9c e0       	ldi	r25, 0x0C	; 12
    d026:	ad b7       	in	r26, 0x3d	; 61
    d028:	be b7       	in	r27, 0x3e	; 62
    d02a:	12 96       	adiw	r26, 0x02	; 2
    d02c:	9c 93       	st	X, r25
    d02e:	8e 93       	st	-X, r24
    d030:	11 97       	sbiw	r26, 0x01	; 1
    d032:	80 e3       	ldi	r24, 0x30	; 48
    d034:	94 e2       	ldi	r25, 0x24	; 36
    d036:	93 83       	std	Z+3, r25	; 0x03
    d038:	82 83       	std	Z+2, r24	; 0x02
    d03a:	24 83       	std	Z+4, r18	; 0x04
    d03c:	15 82       	std	Z+5, r1	; 0x05
    d03e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    d042:	e7 e8       	ldi	r30, 0x87	; 135
    d044:	fc e0       	ldi	r31, 0x0C	; 12
    d046:	df 01       	movw	r26, r30
    d048:	0d 90       	ld	r0, X+
    d04a:	00 20       	and	r0, r0
    d04c:	e9 f7       	brne	.-6      	; 0xd048 <StoreStandaloneTransData+0x1c8>
    d04e:	9d 01       	movw	r18, r26
    d050:	21 50       	subi	r18, 0x01	; 1
    d052:	30 40       	sbci	r19, 0x00	; 0
    d054:	2e 1b       	sub	r18, r30
    d056:	3f 0b       	sbc	r19, r31
    d058:	85 e3       	ldi	r24, 0x35	; 53
    d05a:	90 e0       	ldi	r25, 0x00	; 0
    d05c:	c8 9e       	mul	r12, r24
    d05e:	d0 01       	movw	r26, r0
    d060:	c9 9e       	mul	r12, r25
    d062:	b0 0d       	add	r27, r0
    d064:	d8 9e       	mul	r13, r24
    d066:	b0 0d       	add	r27, r0
    d068:	11 24       	eor	r1, r1
    d06a:	a5 55       	subi	r26, 0x55	; 85
    d06c:	ba 4f       	sbci	r27, 0xFA	; 250
    d06e:	4d b7       	in	r20, 0x3d	; 61
    d070:	5e b7       	in	r21, 0x3e	; 62
    d072:	4a 5f       	subi	r20, 0xFA	; 250
    d074:	5f 4f       	sbci	r21, 0xFF	; 255
    d076:	0f b6       	in	r0, 0x3f	; 63
    d078:	f8 94       	cli
    d07a:	5e bf       	out	0x3e, r21	; 62
    d07c:	0f be       	out	0x3f, r0	; 63
    d07e:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d080:	a9 01       	movw	r20, r18
    d082:	4e 0f       	add	r20, r30
    d084:	5f 1f       	adc	r21, r31
    d086:	02 c0       	rjmp	.+4      	; 0xd08c <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    d088:	81 91       	ld	r24, Z+
    d08a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d08c:	e4 17       	cp	r30, r20
    d08e:	f5 07       	cpc	r31, r21
    d090:	d9 f7       	brne	.-10     	; 0xd088 <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d092:	85 e3       	ldi	r24, 0x35	; 53
    d094:	90 e0       	ldi	r25, 0x00	; 0
    d096:	dc 01       	movw	r26, r24
    d098:	ca 9e       	mul	r12, r26
    d09a:	c0 01       	movw	r24, r0
    d09c:	cb 9e       	mul	r12, r27
    d09e:	90 0d       	add	r25, r0
    d0a0:	da 9e       	mul	r13, r26
    d0a2:	90 0d       	add	r25, r0
    d0a4:	11 24       	eor	r1, r1
    d0a6:	fc 01       	movw	r30, r24
    d0a8:	e8 55       	subi	r30, 0x58	; 88
    d0aa:	fa 4f       	sbci	r31, 0xFA	; 250
    d0ac:	e2 0f       	add	r30, r18
    d0ae:	f3 1f       	adc	r31, r19
    d0b0:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    d0b2:	fe 01       	movw	r30, r28
    d0b4:	3b 96       	adiw	r30, 0x0b	; 11
    d0b6:	df 01       	movw	r26, r30
    d0b8:	0d 90       	ld	r0, X+
    d0ba:	00 20       	and	r0, r0
    d0bc:	e9 f7       	brne	.-6      	; 0xd0b8 <StoreStandaloneTransData+0x238>
    d0be:	11 97       	sbiw	r26, 0x01	; 1
    d0c0:	ae 1b       	sub	r26, r30
    d0c2:	bf 0b       	sbc	r27, r31
    d0c4:	bf 01       	movw	r22, r30
    d0c6:	9c 01       	movw	r18, r24
    d0c8:	2e 54       	subi	r18, 0x4E	; 78
    d0ca:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d0cc:	af 01       	movw	r20, r30
    d0ce:	4a 0f       	add	r20, r26
    d0d0:	5b 1f       	adc	r21, r27
    d0d2:	06 c0       	rjmp	.+12     	; 0xd0e0 <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    d0d4:	fb 01       	movw	r30, r22
    d0d6:	81 91       	ld	r24, Z+
    d0d8:	bf 01       	movw	r22, r30
    d0da:	f9 01       	movw	r30, r18
    d0dc:	81 93       	st	Z+, r24
    d0de:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d0e0:	64 17       	cp	r22, r20
    d0e2:	75 07       	cpc	r23, r21
    d0e4:	b9 f7       	brne	.-18     	; 0xd0d4 <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d0e6:	85 e3       	ldi	r24, 0x35	; 53
    d0e8:	90 e0       	ldi	r25, 0x00	; 0
    d0ea:	9c 01       	movw	r18, r24
    d0ec:	c2 9e       	mul	r12, r18
    d0ee:	c0 01       	movw	r24, r0
    d0f0:	c3 9e       	mul	r12, r19
    d0f2:	90 0d       	add	r25, r0
    d0f4:	d2 9e       	mul	r13, r18
    d0f6:	90 0d       	add	r25, r0
    d0f8:	11 24       	eor	r1, r1
    d0fa:	fc 01       	movw	r30, r24
    d0fc:	e8 55       	subi	r30, 0x58	; 88
    d0fe:	fa 4f       	sbci	r31, 0xFA	; 250
    d100:	ea 0f       	add	r30, r26
    d102:	fb 1f       	adc	r31, r27
    d104:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    d106:	fe 01       	movw	r30, r28
    d108:	74 96       	adiw	r30, 0x14	; 20
    d10a:	df 01       	movw	r26, r30
    d10c:	0d 90       	ld	r0, X+
    d10e:	00 20       	and	r0, r0
    d110:	e9 f7       	brne	.-6      	; 0xd10c <StoreStandaloneTransData+0x28c>
    d112:	11 97       	sbiw	r26, 0x01	; 1
    d114:	ae 1b       	sub	r26, r30
    d116:	bf 0b       	sbc	r27, r31
    d118:	bf 01       	movw	r22, r30
    d11a:	9c 01       	movw	r18, r24
    d11c:	25 54       	subi	r18, 0x45	; 69
    d11e:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d120:	af 01       	movw	r20, r30
    d122:	4a 0f       	add	r20, r26
    d124:	5b 1f       	adc	r21, r27
    d126:	06 c0       	rjmp	.+12     	; 0xd134 <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    d128:	fb 01       	movw	r30, r22
    d12a:	81 91       	ld	r24, Z+
    d12c:	bf 01       	movw	r22, r30
    d12e:	f9 01       	movw	r30, r18
    d130:	81 93       	st	Z+, r24
    d132:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d134:	64 17       	cp	r22, r20
    d136:	75 07       	cpc	r23, r21
    d138:	b9 f7       	brne	.-18     	; 0xd128 <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d13a:	85 e3       	ldi	r24, 0x35	; 53
    d13c:	90 e0       	ldi	r25, 0x00	; 0
    d13e:	c8 9e       	mul	r12, r24
    d140:	70 01       	movw	r14, r0
    d142:	c9 9e       	mul	r12, r25
    d144:	f0 0c       	add	r15, r0
    d146:	d8 9e       	mul	r13, r24
    d148:	f0 0c       	add	r15, r0
    d14a:	11 24       	eor	r1, r1
    d14c:	87 01       	movw	r16, r14
    d14e:	08 55       	subi	r16, 0x58	; 88
    d150:	1a 4f       	sbci	r17, 0xFA	; 250
    d152:	a0 0f       	add	r26, r16
    d154:	b1 1f       	adc	r27, r17
    d156:	53 96       	adiw	r26, 0x13	; 19
    d158:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    d15a:	f0 ed       	ldi	r31, 0xD0	; 208
    d15c:	2f 0e       	add	r2, r31
    d15e:	d8 01       	movw	r26, r16
    d160:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    d162:	b9 a9       	ldd	r27, Y+49	; 0x31
    d164:	b0 53       	subi	r27, 0x30	; 48
    d166:	f8 01       	movw	r30, r16
    d168:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    d16a:	88 e6       	ldi	r24, 0x68	; 104
    d16c:	9c e0       	ldi	r25, 0x0C	; 12
    d16e:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
    d172:	d8 01       	movw	r26, r16
    d174:	12 96       	adiw	r26, 0x02	; 2
    d176:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    d178:	fe 01       	movw	r30, r28
    d17a:	34 96       	adiw	r30, 0x04	; 4
    d17c:	df 01       	movw	r26, r30
    d17e:	0d 90       	ld	r0, X+
    d180:	00 20       	and	r0, r0
    d182:	e9 f7       	brne	.-6      	; 0xd17e <StoreStandaloneTransData+0x2fe>
    d184:	11 97       	sbiw	r26, 0x01	; 1
    d186:	ae 1b       	sub	r26, r30
    d188:	bf 0b       	sbc	r27, r31
    d18a:	97 01       	movw	r18, r14
    d18c:	2c 53       	subi	r18, 0x3C	; 60
    d18e:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d190:	af 01       	movw	r20, r30
    d192:	4a 0f       	add	r20, r26
    d194:	5b 1f       	adc	r21, r27
    d196:	06 c0       	rjmp	.+12     	; 0xd1a4 <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    d198:	f4 01       	movw	r30, r8
    d19a:	81 91       	ld	r24, Z+
    d19c:	4f 01       	movw	r8, r30
    d19e:	f9 01       	movw	r30, r18
    d1a0:	81 93       	st	Z+, r24
    d1a2:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d1a4:	84 16       	cp	r8, r20
    d1a6:	95 06       	cpc	r9, r21
    d1a8:	b9 f7       	brne	.-18     	; 0xd198 <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d1aa:	85 e3       	ldi	r24, 0x35	; 53
    d1ac:	90 e0       	ldi	r25, 0x00	; 0
    d1ae:	9c 01       	movw	r18, r24
    d1b0:	c2 9e       	mul	r12, r18
    d1b2:	c0 01       	movw	r24, r0
    d1b4:	c3 9e       	mul	r12, r19
    d1b6:	90 0d       	add	r25, r0
    d1b8:	d2 9e       	mul	r13, r18
    d1ba:	90 0d       	add	r25, r0
    d1bc:	11 24       	eor	r1, r1
    d1be:	fc 01       	movw	r30, r24
    d1c0:	e8 55       	subi	r30, 0x58	; 88
    d1c2:	fa 4f       	sbci	r31, 0xFA	; 250
    d1c4:	ea 0f       	add	r30, r26
    d1c6:	fb 1f       	adc	r31, r27
    d1c8:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    d1ca:	fe 01       	movw	r30, r28
    d1cc:	7d 96       	adiw	r30, 0x1d	; 29
    d1ce:	df 01       	movw	r26, r30
    d1d0:	0d 90       	ld	r0, X+
    d1d2:	00 20       	and	r0, r0
    d1d4:	e9 f7       	brne	.-6      	; 0xd1d0 <StoreStandaloneTransData+0x350>
    d1d6:	11 97       	sbiw	r26, 0x01	; 1
    d1d8:	ae 1b       	sub	r26, r30
    d1da:	bf 0b       	sbc	r27, r31
    d1dc:	9c 01       	movw	r18, r24
    d1de:	25 53       	subi	r18, 0x35	; 53
    d1e0:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d1e2:	af 01       	movw	r20, r30
    d1e4:	4a 0f       	add	r20, r26
    d1e6:	5b 1f       	adc	r21, r27
    d1e8:	06 c0       	rjmp	.+12     	; 0xd1f6 <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    d1ea:	f3 01       	movw	r30, r6
    d1ec:	81 91       	ld	r24, Z+
    d1ee:	3f 01       	movw	r6, r30
    d1f0:	f9 01       	movw	r30, r18
    d1f2:	81 93       	st	Z+, r24
    d1f4:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d1f6:	64 16       	cp	r6, r20
    d1f8:	75 06       	cpc	r7, r21
    d1fa:	b9 f7       	brne	.-18     	; 0xd1ea <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d1fc:	85 e3       	ldi	r24, 0x35	; 53
    d1fe:	90 e0       	ldi	r25, 0x00	; 0
    d200:	9c 01       	movw	r18, r24
    d202:	c2 9e       	mul	r12, r18
    d204:	c0 01       	movw	r24, r0
    d206:	c3 9e       	mul	r12, r19
    d208:	90 0d       	add	r25, r0
    d20a:	d2 9e       	mul	r13, r18
    d20c:	90 0d       	add	r25, r0
    d20e:	11 24       	eor	r1, r1
    d210:	fc 01       	movw	r30, r24
    d212:	e8 55       	subi	r30, 0x58	; 88
    d214:	fa 4f       	sbci	r31, 0xFA	; 250
    d216:	ea 0f       	add	r30, r26
    d218:	fb 1f       	adc	r31, r27
    d21a:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    d21c:	fe 01       	movw	r30, r28
    d21e:	b7 96       	adiw	r30, 0x27	; 39
    d220:	df 01       	movw	r26, r30
    d222:	0d 90       	ld	r0, X+
    d224:	00 20       	and	r0, r0
    d226:	e9 f7       	brne	.-6      	; 0xd222 <StoreStandaloneTransData+0x3a2>
    d228:	11 97       	sbiw	r26, 0x01	; 1
    d22a:	ae 1b       	sub	r26, r30
    d22c:	bf 0b       	sbc	r27, r31
    d22e:	9c 01       	movw	r18, r24
    d230:	2c 52       	subi	r18, 0x2C	; 44
    d232:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d234:	af 01       	movw	r20, r30
    d236:	4a 0f       	add	r20, r26
    d238:	5b 1f       	adc	r21, r27
    d23a:	06 c0       	rjmp	.+12     	; 0xd248 <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    d23c:	f2 01       	movw	r30, r4
    d23e:	81 91       	ld	r24, Z+
    d240:	2f 01       	movw	r4, r30
    d242:	f9 01       	movw	r30, r18
    d244:	81 93       	st	Z+, r24
    d246:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d248:	44 16       	cp	r4, r20
    d24a:	55 06       	cpc	r5, r21
    d24c:	b9 f7       	brne	.-18     	; 0xd23c <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d24e:	85 e3       	ldi	r24, 0x35	; 53
    d250:	90 e0       	ldi	r25, 0x00	; 0
    d252:	c8 9e       	mul	r12, r24
    d254:	f0 01       	movw	r30, r0
    d256:	c9 9e       	mul	r12, r25
    d258:	f0 0d       	add	r31, r0
    d25a:	d8 9e       	mul	r13, r24
    d25c:	f0 0d       	add	r31, r0
    d25e:	11 24       	eor	r1, r1
    d260:	e8 55       	subi	r30, 0x58	; 88
    d262:	fa 4f       	sbci	r31, 0xFA	; 250
    d264:	ea 0f       	add	r30, r26
    d266:	fb 1f       	adc	r31, r27
    d268:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    d26a:	83 2d       	mov	r24, r3
    d26c:	8f 70       	andi	r24, 0x0F	; 15
    d26e:	60 e1       	ldi	r22, 0x10	; 16
    d270:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    d274:	83 2d       	mov	r24, r3
    d276:	62 e0       	ldi	r22, 0x02	; 2
    d278:	0e 94 ea 1a 	call	0x35d4	; 0x35d4 <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    d27c:	8b e0       	ldi	r24, 0x0B	; 11
    d27e:	63 2d       	mov	r22, r3
    d280:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
    d284:	4b c0       	rjmp	.+150    	; 0xd31c <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    d286:	da 94       	dec	r13
    d288:	cd 2c       	mov	r12, r13
    d28a:	dd 24       	eor	r13, r13
    d28c:	f6 01       	movw	r30, r12
    d28e:	ed 5e       	subi	r30, 0xED	; 237
    d290:	fe 4f       	sbci	r31, 0xFE	; 254
    d292:	81 e0       	ldi	r24, 0x01	; 1
    d294:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    d296:	c7 01       	movw	r24, r14
    d298:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <FormatPrice>
			 FormatMoney(strPMoney);
    d29c:	c8 01       	movw	r24, r16
    d29e:	0e 94 9f 37 	call	0x6f3e	; 0x6f3e <FormatMoney>
			 FormatVolume(strPVolume);
    d2a2:	c5 01       	movw	r24, r10
    d2a4:	0e 94 92 37 	call	0x6f24	; 0x6f24 <FormatVolume>

			 //uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    d2a8:	87 e8       	ldi	r24, 0x87	; 135
    d2aa:	9c e0       	ldi	r25, 0x0C	; 12
    d2ac:	0e 94 16 43 	call	0x862c	; 0x862c <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    d2b0:	00 d0       	rcall	.+0      	; 0xd2b2 <StoreStandaloneTransData+0x432>
    d2b2:	00 d0       	rcall	.+0      	; 0xd2b4 <StoreStandaloneTransData+0x434>
    d2b4:	00 d0       	rcall	.+0      	; 0xd2b6 <StoreStandaloneTransData+0x436>
    d2b6:	ed b7       	in	r30, 0x3d	; 61
    d2b8:	fe b7       	in	r31, 0x3e	; 62
    d2ba:	31 96       	adiw	r30, 0x01	; 1
    d2bc:	ce 01       	movw	r24, r28
    d2be:	0b 96       	adiw	r24, 0x0b	; 11
    d2c0:	ad b7       	in	r26, 0x3d	; 61
    d2c2:	be b7       	in	r27, 0x3e	; 62
    d2c4:	12 96       	adiw	r26, 0x02	; 2
    d2c6:	9c 93       	st	X, r25
    d2c8:	8e 93       	st	-X, r24
    d2ca:	11 97       	sbiw	r26, 0x01	; 1
    d2cc:	86 e3       	ldi	r24, 0x36	; 54
    d2ce:	94 e2       	ldi	r25, 0x24	; 36
    d2d0:	93 83       	std	Z+3, r25	; 0x03
    d2d2:	82 83       	std	Z+2, r24	; 0x02
    d2d4:	8a eb       	ldi	r24, 0xBA	; 186
    d2d6:	93 e0       	ldi	r25, 0x03	; 3
    d2d8:	95 83       	std	Z+5, r25	; 0x05
    d2da:	84 83       	std	Z+4, r24	; 0x04
    d2dc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    d2e0:	ed b7       	in	r30, 0x3d	; 61
    d2e2:	fe b7       	in	r31, 0x3e	; 62
    d2e4:	31 96       	adiw	r30, 0x01	; 1
    d2e6:	ce 01       	movw	r24, r28
    d2e8:	44 96       	adiw	r24, 0x14	; 20
    d2ea:	ad b7       	in	r26, 0x3d	; 61
    d2ec:	be b7       	in	r27, 0x3e	; 62
    d2ee:	12 96       	adiw	r26, 0x02	; 2
    d2f0:	9c 93       	st	X, r25
    d2f2:	8e 93       	st	-X, r24
    d2f4:	11 97       	sbiw	r26, 0x01	; 1
    d2f6:	83 e3       	ldi	r24, 0x33	; 51
    d2f8:	94 e2       	ldi	r25, 0x24	; 36
    d2fa:	93 83       	std	Z+3, r25	; 0x03
    d2fc:	82 83       	std	Z+2, r24	; 0x02
    d2fe:	84 e7       	ldi	r24, 0x74	; 116
    d300:	98 e0       	ldi	r25, 0x08	; 8
    d302:	95 83       	std	Z+5, r25	; 0x05
    d304:	84 83       	std	Z+4, r24	; 0x04
    d306:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    d30a:	ed b7       	in	r30, 0x3d	; 61
    d30c:	fe b7       	in	r31, 0x3e	; 62
    d30e:	36 96       	adiw	r30, 0x06	; 6
    d310:	0f b6       	in	r0, 0x3f	; 63
    d312:	f8 94       	cli
    d314:	fe bf       	out	0x3e, r31	; 62
    d316:	0f be       	out	0x3f, r0	; 63
    d318:	ed bf       	out	0x3d, r30	; 61
    d31a:	75 ce       	rjmp	.-790    	; 0xd006 <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //uart_print(0,1,strRawTransData);
}
    d31c:	e1 96       	adiw	r28, 0x31	; 49
    d31e:	0f b6       	in	r0, 0x3f	; 63
    d320:	f8 94       	cli
    d322:	de bf       	out	0x3e, r29	; 62
    d324:	0f be       	out	0x3f, r0	; 63
    d326:	cd bf       	out	0x3d, r28	; 61
    d328:	cf 91       	pop	r28
    d32a:	df 91       	pop	r29
    d32c:	1f 91       	pop	r17
    d32e:	0f 91       	pop	r16
    d330:	ff 90       	pop	r15
    d332:	ef 90       	pop	r14
    d334:	df 90       	pop	r13
    d336:	cf 90       	pop	r12
    d338:	bf 90       	pop	r11
    d33a:	af 90       	pop	r10
    d33c:	9f 90       	pop	r9
    d33e:	8f 90       	pop	r8
    d340:	7f 90       	pop	r7
    d342:	6f 90       	pop	r6
    d344:	5f 90       	pop	r5
    d346:	4f 90       	pop	r4
    d348:	3f 90       	pop	r3
    d34a:	2f 90       	pop	r2
    d34c:	08 95       	ret

0000d34e <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    d34e:	2f 92       	push	r2
    d350:	3f 92       	push	r3
    d352:	4f 92       	push	r4
    d354:	5f 92       	push	r5
    d356:	7f 92       	push	r7
    d358:	8f 92       	push	r8
    d35a:	9f 92       	push	r9
    d35c:	af 92       	push	r10
    d35e:	bf 92       	push	r11
    d360:	cf 92       	push	r12
    d362:	df 92       	push	r13
    d364:	ef 92       	push	r14
    d366:	ff 92       	push	r15
    d368:	0f 93       	push	r16
    d36a:	1f 93       	push	r17
    d36c:	df 93       	push	r29
    d36e:	cf 93       	push	r28
    d370:	cd b7       	in	r28, 0x3d	; 61
    d372:	de b7       	in	r29, 0x3e	; 62
    d374:	a1 97       	sbiw	r28, 0x21	; 33
    d376:	0f b6       	in	r0, 0x3f	; 63
    d378:	f8 94       	cli
    d37a:	de bf       	out	0x3e, r29	; 62
    d37c:	0f be       	out	0x3f, r0	; 63
    d37e:	cd bf       	out	0x3d, r28	; 61
    d380:	8c 01       	movw	r16, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    d382:	fc 01       	movw	r30, r24
    d384:	82 81       	ldd	r24, Z+2	; 0x02
    d386:	89 83       	std	Y+1, r24	; 0x01
    d388:	83 81       	ldd	r24, Z+3	; 0x03
    d38a:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    d38c:	1b 82       	std	Y+3, r1	; 0x03
	 //    uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
    d38e:	ce 01       	movw	r24, r28
    d390:	01 96       	adiw	r24, 0x01	; 1
    d392:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
    d396:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    d398:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
	 if (FIPAddr>0){
    d39c:	88 23       	and	r24, r24
    d39e:	09 f4       	brne	.+2      	; 0xd3a2 <StoreStandaloneTotalizerData+0x54>
    d3a0:	44 c0       	rjmp	.+136    	; 0xd42a <StoreStandaloneTotalizerData+0xdc>
	     FIPAddr=FIPAddr-1;
    d3a2:	78 2e       	mov	r7, r24
    d3a4:	7a 94       	dec	r7
    d3a6:	a0 e1       	ldi	r26, 0x10	; 16
    d3a8:	ea 2e       	mov	r14, r26
    d3aa:	f1 2c       	mov	r15, r1
    d3ac:	e0 0e       	add	r14, r16
    d3ae:	f1 1e       	adc	r15, r17
    d3b0:	dd 24       	eor	r13, r13
    d3b2:	d3 94       	inc	r13
    d3b4:	f4 e0       	ldi	r31, 0x04	; 4
    d3b6:	8f 2e       	mov	r8, r31
    d3b8:	91 2c       	mov	r9, r1
    d3ba:	8c 0e       	add	r8, r28
    d3bc:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d3be:	e0 e1       	ldi	r30, 0x10	; 16
    d3c0:	2e 2e       	mov	r2, r30
    d3c2:	31 2c       	mov	r3, r1
    d3c4:	2c 0e       	add	r2, r28
    d3c6:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d3c8:	73 e1       	ldi	r23, 0x13	; 19
    d3ca:	a7 2e       	mov	r10, r23
    d3cc:	b1 2c       	mov	r11, r1
    d3ce:	ac 0e       	add	r10, r28
    d3d0:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d3d2:	6f e1       	ldi	r22, 0x1F	; 31
    d3d4:	46 2e       	mov	r4, r22
    d3d6:	51 2c       	mov	r5, r1
    d3d8:	4c 0e       	add	r4, r28
    d3da:	5d 1e       	adc	r5, r29
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    d3dc:	d7 01       	movw	r26, r14
    d3de:	1c 97       	sbiw	r26, 0x0c	; 12
    d3e0:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    d3e2:	8d 91       	ld	r24, X+
    d3e4:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d3e6:	e2 15       	cp	r30, r2
    d3e8:	f3 05       	cpc	r31, r3
    d3ea:	d9 f7       	brne	.-10     	; 0xd3e2 <StoreStandaloneTotalizerData+0x94>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d3ec:	18 8a       	std	Y+16, r1	; 0x10
    d3ee:	f5 01       	movw	r30, r10
    d3f0:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    d3f2:	8d 91       	ld	r24, X+
    d3f4:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d3f6:	e4 15       	cp	r30, r4
    d3f8:	f5 05       	cpc	r31, r5
    d3fa:	d9 f7       	brne	.-10     	; 0xd3f2 <StoreStandaloneTotalizerData+0xa4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d3fc:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    d3fe:	80 e0       	ldi	r24, 0x00	; 0
    d400:	61 e0       	ldi	r22, 0x01	; 1
    d402:	47 2d       	mov	r20, r7
    d404:	2d 2d       	mov	r18, r13
    d406:	84 01       	movw	r16, r8
    d408:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    d40c:	81 e0       	ldi	r24, 0x01	; 1
    d40e:	61 e0       	ldi	r22, 0x01	; 1
    d410:	47 2d       	mov	r20, r7
    d412:	2d 2d       	mov	r18, r13
    d414:	85 01       	movw	r16, r10
    d416:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    d41a:	d3 94       	inc	r13
    d41c:	88 e1       	ldi	r24, 0x18	; 24
    d41e:	90 e0       	ldi	r25, 0x00	; 0
    d420:	e8 0e       	add	r14, r24
    d422:	f9 1e       	adc	r15, r25
    d424:	97 e0       	ldi	r25, 0x07	; 7
    d426:	d9 16       	cp	r13, r25
    d428:	c9 f6       	brne	.-78     	; 0xd3dc <StoreStandaloneTotalizerData+0x8e>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    d42a:	8d e0       	ldi	r24, 0x0D	; 13
    d42c:	6c 2d       	mov	r22, r12
    d42e:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    d432:	8c 2d       	mov	r24, r12
    d434:	8f 70       	andi	r24, 0x0F	; 15
    d436:	64 e1       	ldi	r22, 0x14	; 20
    d438:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
}
    d43c:	a1 96       	adiw	r28, 0x21	; 33
    d43e:	0f b6       	in	r0, 0x3f	; 63
    d440:	f8 94       	cli
    d442:	de bf       	out	0x3e, r29	; 62
    d444:	0f be       	out	0x3f, r0	; 63
    d446:	cd bf       	out	0x3d, r28	; 61
    d448:	cf 91       	pop	r28
    d44a:	df 91       	pop	r29
    d44c:	1f 91       	pop	r17
    d44e:	0f 91       	pop	r16
    d450:	ff 90       	pop	r15
    d452:	ef 90       	pop	r14
    d454:	df 90       	pop	r13
    d456:	cf 90       	pop	r12
    d458:	bf 90       	pop	r11
    d45a:	af 90       	pop	r10
    d45c:	9f 90       	pop	r9
    d45e:	8f 90       	pop	r8
    d460:	7f 90       	pop	r7
    d462:	5f 90       	pop	r5
    d464:	4f 90       	pop	r4
    d466:	3f 90       	pop	r3
    d468:	2f 90       	pop	r2
    d46a:	08 95       	ret

0000d46c <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    d46c:	0f 93       	push	r16
    d46e:	1f 93       	push	r17
    d470:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    d472:	80 91 a9 02 	lds	r24, 0x02A9
    d476:	80 93 aa 02 	sts	0x02AA, r24
	  zDataFlow[3]=zDataFlow[2];
    d47a:	80 91 a8 02 	lds	r24, 0x02A8
    d47e:	80 93 a9 02 	sts	0x02A9, r24
	  zDataFlow[2]=zDataFlow[1];
    d482:	80 91 a7 02 	lds	r24, 0x02A7
    d486:	80 93 a8 02 	sts	0x02A8, r24
      zDataFlow[1]=zDataFlow[0];
    d48a:	90 91 a6 02 	lds	r25, 0x02A6
    d48e:	90 93 a7 02 	sts	0x02A7, r25
      zDataFlow[0]=data;
    d492:	00 93 a6 02 	sts	0x02A6, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    d496:	87 30       	cpi	r24, 0x07	; 7
    d498:	79 f4       	brne	.+30     	; 0xd4b8 <ScanStandaloneFlow+0x4c>
    d49a:	08 30       	cpi	r16, 0x08	; 8
    d49c:	69 f4       	brne	.+26     	; 0xd4b8 <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    d49e:	19 2f       	mov	r17, r25
    d4a0:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    d4a2:	89 2f       	mov	r24, r25
    d4a4:	82 95       	swap	r24
    d4a6:	8f 70       	andi	r24, 0x0F	; 15
    d4a8:	61 2f       	mov	r22, r17
    d4aa:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    d4ae:	1e 30       	cpi	r17, 0x0E	; 14
    d4b0:	19 f0       	breq	.+6      	; 0xd4b8 <ScanStandaloneFlow+0x4c>
    d4b2:	81 e0       	ldi	r24, 0x01	; 1
    d4b4:	80 93 9c 01 	sts	0x019C, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    d4b8:	80 91 9d 01 	lds	r24, 0x019D
    d4bc:	81 30       	cpi	r24, 0x01	; 1
    d4be:	69 f4       	brne	.+26     	; 0xd4da <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    d4c0:	80 91 a4 02 	lds	r24, 0x02A4
    d4c4:	90 91 a5 02 	lds	r25, 0x02A5
    d4c8:	fc 01       	movw	r30, r24
    d4ca:	ea 5f       	subi	r30, 0xFA	; 250
    d4cc:	fc 4f       	sbci	r31, 0xFC	; 252
    d4ce:	00 83       	st	Z, r16
		  iFlow++;
    d4d0:	01 96       	adiw	r24, 0x01	; 1
    d4d2:	90 93 a5 02 	sts	0x02A5, r25
    d4d6:	80 93 a4 02 	sts	0x02A4, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    d4da:	80 91 a7 02 	lds	r24, 0x02A7
    d4de:	85 30       	cpi	r24, 0x05	; 5
    d4e0:	61 f4       	brne	.+24     	; 0xd4fa <ScanStandaloneFlow+0x8e>
    d4e2:	80 91 a6 02 	lds	r24, 0x02A6
    d4e6:	80 35       	cpi	r24, 0x50	; 80
    d4e8:	41 f5       	brne	.+80     	; 0xd53a <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    d4ea:	81 e0       	ldi	r24, 0x01	; 1
    d4ec:	80 93 9d 01 	sts	0x019D, r24
		  iFlow=0;
    d4f0:	10 92 a5 02 	sts	0x02A5, r1
    d4f4:	10 92 a4 02 	sts	0x02A4, r1
    d4f8:	20 c0       	rjmp	.+64     	; 0xd53a <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    d4fa:	86 30       	cpi	r24, 0x06	; 6
    d4fc:	f1 f4       	brne	.+60     	; 0xd53a <ScanStandaloneFlow+0xce>
    d4fe:	80 91 a6 02 	lds	r24, 0x02A6
    d502:	80 36       	cpi	r24, 0x60	; 96
    d504:	d1 f4       	brne	.+52     	; 0xd53a <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    d506:	10 92 9d 01 	sts	0x019D, r1
	      strStandReceived[iFlow]=0;
    d50a:	e0 91 a4 02 	lds	r30, 0x02A4
    d50e:	f0 91 a5 02 	lds	r31, 0x02A5
    d512:	ea 5f       	subi	r30, 0xFA	; 250
    d514:	fc 4f       	sbci	r31, 0xFC	; 252
    d516:	10 82       	st	Z, r1

		  //uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    d518:	86 e0       	ldi	r24, 0x06	; 6
    d51a:	93 e0       	ldi	r25, 0x03	; 3
    d51c:	0e 94 6b 47 	call	0x8ed6	; 0x8ed6 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    d520:	81 30       	cpi	r24, 0x01	; 1
    d522:	29 f4       	brne	.+10     	; 0xd52e <ScanStandaloneFlow+0xc2>
    d524:	86 e0       	ldi	r24, 0x06	; 6
    d526:	93 e0       	ldi	r25, 0x03	; 3
    d528:	0e 94 40 67 	call	0xce80	; 0xce80 <StoreStandaloneTransData>
    d52c:	06 c0       	rjmp	.+12     	; 0xd53a <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    d52e:	82 30       	cpi	r24, 0x02	; 2
    d530:	21 f4       	brne	.+8      	; 0xd53a <ScanStandaloneFlow+0xce>
    d532:	86 e0       	ldi	r24, 0x06	; 6
    d534:	93 e0       	ldi	r25, 0x03	; 3
    d536:	0e 94 a7 69 	call	0xd34e	; 0xd34e <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    d53a:	80 91 a9 02 	lds	r24, 0x02A9
    d53e:	89 30       	cpi	r24, 0x09	; 9
    d540:	c1 f5       	brne	.+112    	; 0xd5b2 <ScanStandaloneFlow+0x146>
    d542:	80 91 a6 02 	lds	r24, 0x02A6
    d546:	8a 30       	cpi	r24, 0x0A	; 10
    d548:	a1 f5       	brne	.+104    	; 0xd5b2 <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    d54a:	90 91 a7 02 	lds	r25, 0x02A7
    d54e:	90 93 ec 0b 	sts	0x0BEC, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    d552:	80 91 a8 02 	lds	r24, 0x02A8
    d556:	80 93 9d 05 	sts	0x059D, r24
		  switch(AcknoledgeCommand){
    d55a:	89 31       	cpi	r24, 0x19	; 25
    d55c:	51 f0       	breq	.+20     	; 0xd572 <ScanStandaloneFlow+0x106>
    d55e:	8a 31       	cpi	r24, 0x1A	; 26
    d560:	18 f4       	brcc	.+6      	; 0xd568 <ScanStandaloneFlow+0xfc>
    d562:	85 30       	cpi	r24, 0x05	; 5
    d564:	19 f5       	brne	.+70     	; 0xd5ac <ScanStandaloneFlow+0x140>
    d566:	17 c0       	rjmp	.+46     	; 0xd596 <ScanStandaloneFlow+0x12a>
    d568:	8a 31       	cpi	r24, 0x1A	; 26
    d56a:	c9 f0       	breq	.+50     	; 0xd59e <ScanStandaloneFlow+0x132>
    d56c:	8c 31       	cpi	r24, 0x1C	; 28
    d56e:	f1 f4       	brne	.+60     	; 0xd5ac <ScanStandaloneFlow+0x140>
    d570:	1a c0       	rjmp	.+52     	; 0xd5a6 <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    d572:	90 93 80 01 	sts	0x0180, r25
			   IsNewPoolingSequence=True;
    d576:	81 e0       	ldi	r24, 0x01	; 1
    d578:	80 93 81 01 	sts	0x0181, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    d57c:	80 91 84 01 	lds	r24, 0x0184
    d580:	81 30       	cpi	r24, 0x01	; 1
    d582:	a1 f4       	brne	.+40     	; 0xd5ac <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    d584:	10 92 84 01 	sts	0x0184, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    d588:	80 91 a7 05 	lds	r24, 0x05A7
    d58c:	60 91 d3 0b 	lds	r22, 0x0BD3
    d590:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
    d594:	0b c0       	rjmp	.+22     	; 0xd5ac <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    d596:	81 e0       	ldi	r24, 0x01	; 1
    d598:	80 93 af 01 	sts	0x01AF, r24
    d59c:	07 c0       	rjmp	.+14     	; 0xd5ac <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    d59e:	81 e0       	ldi	r24, 0x01	; 1
    d5a0:	80 93 83 01 	sts	0x0183, r24
    d5a4:	03 c0       	rjmp	.+6      	; 0xd5ac <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    d5a6:	81 e0       	ldi	r24, 0x01	; 1
    d5a8:	80 93 23 01 	sts	0x0123, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    d5ac:	81 e0       	ldi	r24, 0x01	; 1
    d5ae:	80 93 82 01 	sts	0x0182, r24
	  }
}
    d5b2:	1f 91       	pop	r17
    d5b4:	0f 91       	pop	r16
    d5b6:	08 95       	ret

0000d5b8 <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    d5b8:	1f 92       	push	r1
    d5ba:	0f 92       	push	r0
    d5bc:	0f b6       	in	r0, 0x3f	; 63
    d5be:	0f 92       	push	r0
    d5c0:	0b b6       	in	r0, 0x3b	; 59
    d5c2:	0f 92       	push	r0
    d5c4:	11 24       	eor	r1, r1
    d5c6:	1f 93       	push	r17
    d5c8:	2f 93       	push	r18
    d5ca:	3f 93       	push	r19
    d5cc:	4f 93       	push	r20
    d5ce:	5f 93       	push	r21
    d5d0:	6f 93       	push	r22
    d5d2:	7f 93       	push	r23
    d5d4:	8f 93       	push	r24
    d5d6:	9f 93       	push	r25
    d5d8:	af 93       	push	r26
    d5da:	bf 93       	push	r27
    d5dc:	ef 93       	push	r30
    d5de:	ff 93       	push	r31
char dataSPI;
//char Reply=0;
    //uart(0,1,SPDR);
	dataSPI=SPDR;
    d5e0:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    d5e2:	81 2f       	mov	r24, r17
    d5e4:	0e 94 4f 15 	call	0x2a9e	; 0x2a9e <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    d5e8:	80 91 00 01 	lds	r24, 0x0100
    d5ec:	81 30       	cpi	r24, 0x01	; 1
    d5ee:	21 f4       	brne	.+8      	; 0xd5f8 <__vector_17+0x40>
    d5f0:	81 2f       	mov	r24, r17
    d5f2:	0e 94 8f 14 	call	0x291e	; 0x291e <ScanEDCFlow>
    d5f6:	05 c0       	rjmp	.+10     	; 0xd602 <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    d5f8:	82 30       	cpi	r24, 0x02	; 2
    d5fa:	19 f4       	brne	.+6      	; 0xd602 <__vector_17+0x4a>
    d5fc:	81 2f       	mov	r24, r17
    d5fe:	0e 94 36 6a 	call	0xd46c	; 0xd46c <ScanStandaloneFlow>
}
    d602:	ff 91       	pop	r31
    d604:	ef 91       	pop	r30
    d606:	bf 91       	pop	r27
    d608:	af 91       	pop	r26
    d60a:	9f 91       	pop	r25
    d60c:	8f 91       	pop	r24
    d60e:	7f 91       	pop	r23
    d610:	6f 91       	pop	r22
    d612:	5f 91       	pop	r21
    d614:	4f 91       	pop	r20
    d616:	3f 91       	pop	r19
    d618:	2f 91       	pop	r18
    d61a:	1f 91       	pop	r17
    d61c:	0f 90       	pop	r0
    d61e:	0b be       	out	0x3b, r0	; 59
    d620:	0f 90       	pop	r0
    d622:	0f be       	out	0x3f, r0	; 63
    d624:	0f 90       	pop	r0
    d626:	1f 90       	pop	r1
    d628:	18 95       	reti

0000d62a <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    d62a:	8f 92       	push	r8
    d62c:	9f 92       	push	r9
    d62e:	af 92       	push	r10
    d630:	bf 92       	push	r11
    d632:	cf 92       	push	r12
    d634:	df 92       	push	r13
    d636:	ef 92       	push	r14
    d638:	ff 92       	push	r15
    d63a:	0f 93       	push	r16
    d63c:	1f 93       	push	r17
    d63e:	cf 93       	push	r28
    d640:	df 93       	push	r29
    d642:	f8 2e       	mov	r15, r24
    d644:	96 2e       	mov	r9, r22
    d646:	d4 2e       	mov	r13, r20
    d648:	e9 01       	movw	r28, r18
    d64a:	58 01       	movw	r10, r16
    d64c:	8e 2c       	mov	r8, r14
	 static char iHit=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;//,KeyByte=0;
	 static unsigned int iLoop=0,KeyTimeout;//,TimerPressed=0,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    d64e:	10 91 7f 02 	lds	r17, 0x027F
    d652:	12 30       	cpi	r17, 0x02	; 2
    d654:	09 f4       	brne	.+2      	; 0xd658 <UserInput+0x2e>
    d656:	2e c2       	rjmp	.+1116   	; 0xdab4 <UserInput+0x48a>
    d658:	13 30       	cpi	r17, 0x03	; 3
    d65a:	30 f4       	brcc	.+12     	; 0xd668 <UserInput+0x3e>
    d65c:	11 23       	and	r17, r17
    d65e:	59 f0       	breq	.+22     	; 0xd676 <UserInput+0x4c>
    d660:	11 30       	cpi	r17, 0x01	; 1
    d662:	09 f0       	breq	.+2      	; 0xd666 <UserInput+0x3c>
    d664:	f7 c2       	rjmp	.+1518   	; 0xdc54 <UserInput+0x62a>
    d666:	2c c0       	rjmp	.+88     	; 0xd6c0 <UserInput+0x96>
    d668:	13 30       	cpi	r17, 0x03	; 3
    d66a:	09 f4       	brne	.+2      	; 0xd66e <UserInput+0x44>
    d66c:	78 c2       	rjmp	.+1264   	; 0xdb5e <UserInput+0x534>
    d66e:	14 30       	cpi	r17, 0x04	; 4
    d670:	09 f0       	breq	.+2      	; 0xd674 <UserInput+0x4a>
    d672:	f0 c2       	rjmp	.+1504   	; 0xdc54 <UserInput+0x62a>
    d674:	f1 c2       	rjmp	.+1506   	; 0xdc58 <UserInput+0x62e>
	 case uiInit:
	      iLoop=0;
    d676:	10 92 71 02 	sts	0x0271, r1
    d67a:	10 92 70 02 	sts	0x0270, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    d67e:	60 93 7e 02 	sts	0x027E, r22
    d682:	40 93 7d 02 	sts	0x027D, r20
          iValuePos=0;
    d686:	10 92 7c 02 	sts	0x027C, r1
		  KeyTimeout=0;
    d68a:	10 92 6f 02 	sts	0x026F, r1
    d68e:	10 92 6e 02 	sts	0x026E, r1
		  IsSameKey=False;
    d692:	10 92 75 02 	sts	0x0275, r1
		  IsNextKey=False;
    d696:	10 92 74 02 	sts	0x0274, r1
		  IsNewKey=False;
    d69a:	10 92 73 02 	sts	0x0273, r1
		  IsShifted=True;
    d69e:	91 e0       	ldi	r25, 0x01	; 1
    d6a0:	90 93 76 02 	sts	0x0276, r25
		  zKeyChar=' ';
    d6a4:	80 e2       	ldi	r24, 0x20	; 32
    d6a6:	80 93 7b 02 	sts	0x027B, r24
		  iHit=0;
    d6aa:	10 92 77 02 	sts	0x0277, r1
		  IsFirst=False;
    d6ae:	10 92 72 02 	sts	0x0272, r1
		  IsDelete=False;
    d6b2:	10 92 78 02 	sts	0x0278, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    d6b6:	90 93 7f 02 	sts	0x027F, r25
    d6ba:	95 e0       	ldi	r25, 0x05	; 5
    d6bc:	e9 2e       	mov	r14, r25
    d6be:	d0 c2       	rjmp	.+1440   	; 0xdc60 <UserInput+0x636>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    d6c0:	81 e0       	ldi	r24, 0x01	; 1
    d6c2:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    d6c6:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    d6c8:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    d6cc:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    d6ce:	2b e7       	ldi	r18, 0x7B	; 123
    d6d0:	c2 16       	cp	r12, r18
    d6d2:	59 f4       	brne	.+22     	; 0xd6ea <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
    d6d4:	80 91 76 02 	lds	r24, 0x0276
    d6d8:	88 23       	and	r24, r24
    d6da:	19 f4       	brne	.+6      	; 0xd6e2 <UserInput+0xb8>
    d6dc:	10 93 76 02 	sts	0x0276, r17
    d6e0:	04 c0       	rjmp	.+8      	; 0xd6ea <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
    d6e2:	81 30       	cpi	r24, 0x01	; 1
    d6e4:	11 f4       	brne	.+4      	; 0xd6ea <UserInput+0xc0>
    d6e6:	10 92 76 02 	sts	0x0276, r1
			  }
          
		  if (IsSameKey==True){
    d6ea:	80 91 75 02 	lds	r24, 0x0275
    d6ee:	81 30       	cpi	r24, 0x01	; 1
    d6f0:	e9 f4       	brne	.+58     	; 0xd72c <UserInput+0x102>
		      KeyTimeout++;
    d6f2:	80 91 6e 02 	lds	r24, 0x026E
    d6f6:	90 91 6f 02 	lds	r25, 0x026F
    d6fa:	01 96       	adiw	r24, 0x01	; 1
    d6fc:	90 93 6f 02 	sts	0x026F, r25
    d700:	80 93 6e 02 	sts	0x026E, r24
              if (KeyTimeout>1000){
    d704:	89 5e       	subi	r24, 0xE9	; 233
    d706:	93 40       	sbci	r25, 0x03	; 3
    d708:	88 f0       	brcs	.+34     	; 0xd72c <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    d70a:	f5 e0       	ldi	r31, 0x05	; 5
    d70c:	ff 16       	cp	r15, r31
    d70e:	39 f4       	brne	.+14     	; 0xd71e <UserInput+0xf4>
    d710:	80 91 7e 02 	lds	r24, 0x027E
    d714:	60 91 7d 02 	lds	r22, 0x027D
    d718:	4a e2       	ldi	r20, 0x2A	; 42
    d71a:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>

		          IsNextKey=True;
    d71e:	81 e0       	ldi	r24, 0x01	; 1
    d720:	80 93 74 02 	sts	0x0274, r24
				  iLoop=0;
    d724:	10 92 71 02 	sts	0x0271, r1
    d728:	10 92 70 02 	sts	0x0270, r1
			     }
              }
            
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
    d72c:	8e 2d       	mov	r24, r14
    d72e:	80 53       	subi	r24, 0x30	; 48
    d730:	8a 30       	cpi	r24, 0x0A	; 10
    d732:	20 f4       	brcc	.+8      	; 0xd73c <UserInput+0x112>
    d734:	80 91 7c 02 	lds	r24, 0x027C
    d738:	88 15       	cp	r24, r8
    d73a:	40 f0       	brcs	.+16     	; 0xd74c <UserInput+0x122>
    d73c:	80 91 74 02 	lds	r24, 0x0274
    d740:	81 30       	cpi	r24, 0x01	; 1
    d742:	21 f0       	breq	.+8      	; 0xd74c <UserInput+0x122>
    d744:	ee 24       	eor	r14, r14
    d746:	00 e0       	ldi	r16, 0x00	; 0
    d748:	10 e0       	ldi	r17, 0x00	; 0
    d74a:	c3 c0       	rjmp	.+390    	; 0xd8d2 <UserInput+0x2a8>
    d74c:	84 ec       	ldi	r24, 0xC4	; 196
    d74e:	99 e0       	ldi	r25, 0x09	; 9
    d750:	20 e7       	ldi	r18, 0x70	; 112
    d752:	31 e0       	ldi	r19, 0x01	; 1
    d754:	f9 01       	movw	r30, r18
    d756:	31 97       	sbiw	r30, 0x01	; 1
    d758:	f1 f7       	brne	.-4      	; 0xd756 <UserInput+0x12c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    d75a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    d75c:	d9 f7       	brne	.-10     	; 0xd754 <UserInput+0x12a>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    d75e:	80 91 7c 02 	lds	r24, 0x027C
    d762:	fe 01       	movw	r30, r28
    d764:	e8 0f       	add	r30, r24
    d766:	f1 1d       	adc	r31, r1
    d768:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    d76a:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    d76c:	8f 2d       	mov	r24, r15
    d76e:	81 50       	subi	r24, 0x01	; 1
    d770:	82 30       	cpi	r24, 0x02	; 2
    d772:	30 f0       	brcs	.+12     	; 0xd780 <UserInput+0x156>
    d774:	24 e0       	ldi	r18, 0x04	; 4
    d776:	f2 16       	cp	r15, r18
    d778:	19 f0       	breq	.+6      	; 0xd780 <UserInput+0x156>
    d77a:	00 e0       	ldi	r16, 0x00	; 0
    d77c:	10 e0       	ldi	r17, 0x00	; 0
    d77e:	04 c0       	rjmp	.+8      	; 0xd788 <UserInput+0x15e>
			        NumbValue=atoi(strResult);
    d780:	ce 01       	movw	r24, r28
    d782:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
    d786:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    d788:	83 e0       	ldi	r24, 0x03	; 3
    d78a:	f8 16       	cp	r15, r24
    d78c:	21 f0       	breq	.+8      	; 0xd796 <UserInput+0x16c>
    d78e:	e5 e0       	ldi	r30, 0x05	; 5
    d790:	fe 16       	cp	r15, r30
    d792:	09 f0       	breq	.+2      	; 0xd796 <UserInput+0x16c>
    d794:	63 c0       	rjmp	.+198    	; 0xd85c <UserInput+0x232>
			       if (KeyChar!=zKeyChar){
    d796:	80 91 7b 02 	lds	r24, 0x027B
    d79a:	e8 16       	cp	r14, r24
    d79c:	71 f0       	breq	.+28     	; 0xd7ba <UserInput+0x190>
					   IsSameKey=False;
    d79e:	10 92 75 02 	sts	0x0275, r1
					   IsNewKey=True;
    d7a2:	81 e0       	ldi	r24, 0x01	; 1
    d7a4:	80 93 73 02 	sts	0x0273, r24
				       iHit=0;
    d7a8:	10 92 77 02 	sts	0x0277, r1
					   iLoop=1000;
    d7ac:	88 ee       	ldi	r24, 0xE8	; 232
    d7ae:	93 e0       	ldi	r25, 0x03	; 3
    d7b0:	90 93 71 02 	sts	0x0271, r25
    d7b4:	80 93 70 02 	sts	0x0270, r24
    d7b8:	51 c0       	rjmp	.+162    	; 0xd85c <UserInput+0x232>
				   }
                   else{
				   if (IsNewKey==True){
    d7ba:	80 91 73 02 	lds	r24, 0x0273
    d7be:	81 30       	cpi	r24, 0x01	; 1
    d7c0:	71 f4       	brne	.+28     	; 0xd7de <UserInput+0x1b4>
					   IsNewKey=False;
    d7c2:	10 92 73 02 	sts	0x0273, r1
					   yChar--;
    d7c6:	80 91 7d 02 	lds	r24, 0x027D
    d7ca:	81 50       	subi	r24, 0x01	; 1
    d7cc:	80 93 7d 02 	sts	0x027D, r24
					   if (iValuePos>0) iValuePos--;
    d7d0:	80 91 7c 02 	lds	r24, 0x027C
    d7d4:	88 23       	and	r24, r24
    d7d6:	19 f0       	breq	.+6      	; 0xd7de <UserInput+0x1b4>
    d7d8:	81 50       	subi	r24, 0x01	; 1
    d7da:	80 93 7c 02 	sts	0x027C, r24
					   }
				   KeyTimeout=0;
    d7de:	10 92 6f 02 	sts	0x026F, r1
    d7e2:	10 92 6e 02 	sts	0x026E, r1
				   IsSameKey=True;
    d7e6:	81 e0       	ldi	r24, 0x01	; 1
    d7e8:	80 93 75 02 	sts	0x0275, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) 
    d7ec:	80 91 77 02 	lds	r24, 0x0277
    d7f0:	e0 91 7b 02 	lds	r30, 0x027B
    d7f4:	f0 e0       	ldi	r31, 0x00	; 0
    d7f6:	e8 55       	subi	r30, 0x58	; 88
    d7f8:	fd 4f       	sbci	r31, 0xFD	; 253
    d7fa:	e4 91       	lpm	r30, Z+
    d7fc:	8e 17       	cp	r24, r30
    d7fe:	20 f4       	brcc	.+8      	; 0xd808 <UserInput+0x1de>
				        iHit++;
    d800:	8f 5f       	subi	r24, 0xFF	; 255
    d802:	80 93 77 02 	sts	0x0277, r24
    d806:	02 c0       	rjmp	.+4      	; 0xd80c <UserInput+0x1e2>
                   else iHit=0;
    d808:	10 92 77 02 	sts	0x0277, r1
				   iLoop=1000;
    d80c:	88 ee       	ldi	r24, 0xE8	; 232
    d80e:	93 e0       	ldi	r25, 0x03	; 3
    d810:	90 93 71 02 	sts	0x0271, r25
    d814:	80 93 70 02 	sts	0x0270, r24

                   zAlphaChar=AlphaChar;
    d818:	80 91 79 02 	lds	r24, 0x0279
    d81c:	80 93 7a 02 	sts	0x027A, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    d820:	80 91 76 02 	lds	r24, 0x0276
    d824:	6c 2d       	mov	r22, r12
    d826:	40 91 77 02 	lds	r20, 0x0277
    d82a:	0e 94 d1 aa 	call	0x155a2	; 0x155a2 <_table_alphanum>
    d82e:	80 93 79 02 	sts	0x0279, r24
                   
				   if (IsNextKey==True){
    d832:	80 91 74 02 	lds	r24, 0x0274
    d836:	81 30       	cpi	r24, 0x01	; 1
    d838:	41 f4       	brne	.+16     	; 0xd84a <UserInput+0x220>
                       AlphaChar=zAlphaChar;       
    d83a:	80 91 7a 02 	lds	r24, 0x027A
    d83e:	80 93 79 02 	sts	0x0279, r24
					   IsNextKey=False;
    d842:	10 92 74 02 	sts	0x0274, r1
					   IsSameKey=False;
    d846:	10 92 75 02 	sts	0x0275, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    d84a:	80 91 7c 02 	lds	r24, 0x027C
    d84e:	fe 01       	movw	r30, r28
    d850:	e8 0f       	add	r30, r24
    d852:	f1 1d       	adc	r31, r1
    d854:	80 91 79 02 	lds	r24, 0x0279
    d858:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    d85a:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    d85c:	f2 e0       	ldi	r31, 0x02	; 2
    d85e:	ff 16       	cp	r15, r31
    d860:	71 f4       	brne	.+28     	; 0xd87e <UserInput+0x254>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    d862:	a0 16       	cp	r10, r16
    d864:	b1 06       	cpc	r11, r17
    d866:	18 f4       	brcc	.+6      	; 0xd86e <UserInput+0x244>
    d868:	a1 14       	cp	r10, r1
    d86a:	b1 04       	cpc	r11, r1
    d86c:	71 f5       	brne	.+92     	; 0xd8ca <UserInput+0x2a0>
				     iValuePos++;
    d86e:	80 91 7c 02 	lds	r24, 0x027C
    d872:	8f 5f       	subi	r24, 0xFF	; 255
    d874:	80 93 7c 02 	sts	0x027C, r24
					 stUserInput=uiInputDisp;
    d878:	83 e0       	ldi	r24, 0x03	; 3
    d87a:	80 93 7f 02 	sts	0x027F, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    d87e:	a0 16       	cp	r10, r16
    d880:	b1 06       	cpc	r11, r17
    d882:	18 f4       	brcc	.+6      	; 0xd88a <UserInput+0x260>
    d884:	a1 14       	cp	r10, r1
    d886:	b1 04       	cpc	r11, r1
    d888:	01 f5       	brne	.+64     	; 0xd8ca <UserInput+0x2a0>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    d88a:	21 e0       	ldi	r18, 0x01	; 1
    d88c:	f2 16       	cp	r15, r18
    d88e:	49 f0       	breq	.+18     	; 0xd8a2 <UserInput+0x278>
    d890:	83 e0       	ldi	r24, 0x03	; 3
    d892:	f8 16       	cp	r15, r24
    d894:	31 f0       	breq	.+12     	; 0xd8a2 <UserInput+0x278>
    d896:	e4 e0       	ldi	r30, 0x04	; 4
    d898:	fe 16       	cp	r15, r30
    d89a:	19 f0       	breq	.+6      	; 0xd8a2 <UserInput+0x278>
    d89c:	f5 e0       	ldi	r31, 0x05	; 5
    d89e:	ff 16       	cp	r15, r31
    d8a0:	a1 f4       	brne	.+40     	; 0xd8ca <UserInput+0x2a0>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    d8a2:	80 91 75 02 	lds	r24, 0x0275
    d8a6:	88 23       	and	r24, r24
    d8a8:	69 f4       	brne	.+26     	; 0xd8c4 <UserInput+0x29a>
					      IsFirst=True;
    d8aa:	81 e0       	ldi	r24, 0x01	; 1
    d8ac:	80 93 72 02 	sts	0x0272, r24
					      iValuePos++;
    d8b0:	80 91 7c 02 	lds	r24, 0x027C
    d8b4:	8f 5f       	subi	r24, 0xFF	; 255
    d8b6:	80 93 7c 02 	sts	0x027C, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
    d8ba:	80 91 7d 02 	lds	r24, 0x027D
    d8be:	8f 5f       	subi	r24, 0xFF	; 255
    d8c0:	80 93 7d 02 	sts	0x027D, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
    d8c4:	83 e0       	ldi	r24, 0x03	; 3
    d8c6:	80 93 7f 02 	sts	0x027F, r24
				  }
			   }
              zKeyChar=KeyChar;
    d8ca:	e0 92 7b 02 	sts	0x027B, r14
    d8ce:	84 e0       	ldi	r24, 0x04	; 4
    d8d0:	e8 2e       	mov	r14, r24
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    d8d2:	9f 2d       	mov	r25, r15
    d8d4:	91 50       	subi	r25, 0x01	; 1
    d8d6:	92 30       	cpi	r25, 0x02	; 2
    d8d8:	18 f0       	brcs	.+6      	; 0xd8e0 <UserInput+0x2b6>
    d8da:	24 e0       	ldi	r18, 0x04	; 4
    d8dc:	f2 16       	cp	r15, r18
    d8de:	71 f4       	brne	.+28     	; 0xd8fc <UserInput+0x2d2>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    d8e0:	a0 16       	cp	r10, r16
    d8e2:	b1 06       	cpc	r11, r17
    d8e4:	20 f0       	brcs	.+8      	; 0xd8ee <UserInput+0x2c4>
    d8e6:	80 91 7c 02 	lds	r24, 0x027C
    d8ea:	88 15       	cp	r24, r8
    d8ec:	39 f4       	brne	.+14     	; 0xd8fc <UserInput+0x2d2>
			           if (MaxValue>0)system_beep(1);
    d8ee:	ab 28       	or	r10, r11
    d8f0:	29 f0       	breq	.+10     	; 0xd8fc <UserInput+0x2d2>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d8f2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d8f4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d8f6:	81 e0       	ldi	r24, 0x01	; 1
    d8f8:	80 93 bc 01 	sts	0x01BC, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    d8fc:	87 ee       	ldi	r24, 0xE7	; 231
    d8fe:	c8 16       	cp	r12, r24
    d900:	71 f4       	brne	.+28     	; 0xd91e <UserInput+0x2f4>
		      if (iValuePos>0){
    d902:	80 91 7c 02 	lds	r24, 0x027C
    d906:	88 23       	and	r24, r24
    d908:	41 f0       	breq	.+16     	; 0xd91a <UserInput+0x2f0>
			      iLoop=1999;
    d90a:	8f ec       	ldi	r24, 0xCF	; 207
    d90c:	97 e0       	ldi	r25, 0x07	; 7
    d90e:	90 93 71 02 	sts	0x0271, r25
    d912:	80 93 70 02 	sts	0x0270, r24
				  stUserInput=uiClearDisplay;
    d916:	82 e0       	ldi	r24, 0x02	; 2
    d918:	26 c0       	rjmp	.+76     	; 0xd966 <UserInput+0x33c>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    d91a:	81 e0       	ldi	r24, 0x01	; 1
    d91c:	21 c0       	rjmp	.+66     	; 0xd960 <UserInput+0x336>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    d91e:	e7 eb       	ldi	r30, 0xB7	; 183
    d920:	ce 16       	cp	r12, r30
    d922:	19 f5       	brne	.+70     	; 0xd96a <UserInput+0x340>
		      strResult[iValuePos]=0;
    d924:	80 91 7c 02 	lds	r24, 0x027C
    d928:	fe 01       	movw	r30, r28
    d92a:	e8 0f       	add	r30, r24
    d92c:	f1 1d       	adc	r31, r1
    d92e:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    d930:	92 30       	cpi	r25, 0x02	; 2
    d932:	a8 f4       	brcc	.+42     	; 0xd95e <UserInput+0x334>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    d934:	88 23       	and	r24, r24
    d936:	81 f4       	brne	.+32     	; 0xd958 <UserInput+0x32e>
    d938:	00 d0       	rcall	.+0      	; 0xd93a <UserInput+0x310>
    d93a:	00 d0       	rcall	.+0      	; 0xd93c <UserInput+0x312>
    d93c:	ed b7       	in	r30, 0x3d	; 61
    d93e:	fe b7       	in	r31, 0x3e	; 62
    d940:	d2 83       	std	Z+2, r29	; 0x02
    d942:	c1 83       	std	Z+1, r28	; 0x01
    d944:	88 e1       	ldi	r24, 0x18	; 24
    d946:	9e e1       	ldi	r25, 0x1E	; 30
    d948:	94 83       	std	Z+4, r25	; 0x04
    d94a:	83 83       	std	Z+3, r24	; 0x03
    d94c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    d950:	0f 90       	pop	r0
    d952:	0f 90       	pop	r0
    d954:	0f 90       	pop	r0
    d956:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    d958:	ce 01       	movw	r24, r28
    d95a:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    d95e:	83 e0       	ldi	r24, 0x03	; 3
    d960:	80 93 80 02 	sts	0x0280, r24
		      stUserInput=uiFinished;
    d964:	84 e0       	ldi	r24, 0x04	; 4
    d966:	80 93 7f 02 	sts	0x027F, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    d96a:	80 91 70 02 	lds	r24, 0x0270
    d96e:	90 91 71 02 	lds	r25, 0x0271
    d972:	60 ed       	ldi	r22, 0xD0	; 208
    d974:	77 e0       	ldi	r23, 0x07	; 7
    d976:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    d97a:	89 2b       	or	r24, r25
    d97c:	09 f0       	breq	.+2      	; 0xd980 <UserInput+0x356>
    d97e:	4b c0       	rjmp	.+150    	; 0xda16 <UserInput+0x3ec>
		      if (IsSameKey==True)
    d980:	80 91 75 02 	lds	r24, 0x0275
    d984:	81 30       	cpi	r24, 0x01	; 1
    d986:	c9 f4       	brne	.+50     	; 0xd9ba <UserInput+0x390>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
    d988:	20 91 7c 02 	lds	r18, 0x027C
    d98c:	82 2f       	mov	r24, r18
    d98e:	90 e0       	ldi	r25, 0x00	; 0
    d990:	01 97       	sbiw	r24, 0x01	; 1
    d992:	8d 0d       	add	r24, r13
    d994:	91 1d       	adc	r25, r1
    d996:	64 e1       	ldi	r22, 0x14	; 20
    d998:	70 e0       	ldi	r23, 0x00	; 0
    d99a:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    d99e:	36 2f       	mov	r19, r22
    d9a0:	82 2f       	mov	r24, r18
    d9a2:	64 e1       	ldi	r22, 0x14	; 20
    d9a4:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    d9a8:	6d 2d       	mov	r22, r13
    d9aa:	69 0f       	add	r22, r25
    d9ac:	89 2d       	mov	r24, r9
    d9ae:	83 0f       	add	r24, r19
    d9b0:	40 91 79 02 	lds	r20, 0x0279
    d9b4:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
    d9b8:	2e c0       	rjmp	.+92     	; 0xda16 <UserInput+0x3ec>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    d9ba:	f5 e0       	ldi	r31, 0x05	; 5
    d9bc:	ff 16       	cp	r15, r31
    d9be:	61 f4       	brne	.+24     	; 0xd9d8 <UserInput+0x3ae>
    d9c0:	80 91 7c 02 	lds	r24, 0x027C
    d9c4:	88 23       	and	r24, r24
    d9c6:	41 f0       	breq	.+16     	; 0xd9d8 <UserInput+0x3ae>
    d9c8:	60 91 7d 02 	lds	r22, 0x027D
    d9cc:	61 50       	subi	r22, 0x01	; 1
    d9ce:	80 91 7e 02 	lds	r24, 0x027E
    d9d2:	4a e2       	ldi	r20, 0x2A	; 42
    d9d4:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
    d9d8:	20 91 7c 02 	lds	r18, 0x027C
    d9dc:	82 2f       	mov	r24, r18
    d9de:	90 e0       	ldi	r25, 0x00	; 0
    d9e0:	01 97       	sbiw	r24, 0x01	; 1
    d9e2:	8d 0d       	add	r24, r13
    d9e4:	91 1d       	adc	r25, r1
    d9e6:	64 e1       	ldi	r22, 0x14	; 20
    d9e8:	70 e0       	ldi	r23, 0x00	; 0
    d9ea:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    d9ee:	36 2f       	mov	r19, r22
    d9f0:	82 2f       	mov	r24, r18
    d9f2:	64 e1       	ldi	r22, 0x14	; 20
    d9f4:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    d9f8:	6d 2d       	mov	r22, r13
    d9fa:	69 0f       	add	r22, r25
    d9fc:	89 2d       	mov	r24, r9
    d9fe:	83 0f       	add	r24, r19
    da00:	4f e5       	ldi	r20, 0x5F	; 95
    da02:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>

				  if (IsFirst==True){
    da06:	80 91 72 02 	lds	r24, 0x0272
    da0a:	81 30       	cpi	r24, 0x01	; 1
    da0c:	21 f4       	brne	.+8      	; 0xda16 <UserInput+0x3ec>
				      IsFirst=False;
    da0e:	10 92 72 02 	sts	0x0272, r1
				      zKeyChar=0;
    da12:	10 92 7b 02 	sts	0x027B, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
    da16:	80 91 70 02 	lds	r24, 0x0270
    da1a:	90 91 71 02 	lds	r25, 0x0271
    da1e:	60 ed       	ldi	r22, 0xD0	; 208
    da20:	77 e0       	ldi	r23, 0x07	; 7
    da22:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
    da26:	88 5e       	subi	r24, 0xE8	; 232
    da28:	93 40       	sbci	r25, 0x03	; 3
    da2a:	d1 f5       	brne	.+116    	; 0xdaa0 <UserInput+0x476>
		      if (IsSameKey==True){
    da2c:	80 91 75 02 	lds	r24, 0x0275
    da30:	81 30       	cpi	r24, 0x01	; 1
    da32:	f9 f4       	brne	.+62     	; 0xda72 <UserInput+0x448>
			      if (TypeUI!=UI_NUM_PASSWORD)
    da34:	84 e0       	ldi	r24, 0x04	; 4
    da36:	f8 16       	cp	r15, r24
    da38:	b1 f0       	breq	.+44     	; 0xda66 <UserInput+0x43c>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
    da3a:	80 91 7c 02 	lds	r24, 0x027C
    da3e:	90 e0       	ldi	r25, 0x00	; 0
    da40:	01 97       	sbiw	r24, 0x01	; 1
    da42:	8d 0d       	add	r24, r13
    da44:	91 1d       	adc	r25, r1
    da46:	64 e1       	ldi	r22, 0x14	; 20
    da48:	70 e0       	ldi	r23, 0x00	; 0
    da4a:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    da4e:	26 2f       	mov	r18, r22
    da50:	80 91 7d 02 	lds	r24, 0x027D
    da54:	65 e1       	ldi	r22, 0x15	; 21
    da56:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    da5a:	89 2d       	mov	r24, r9
    da5c:	82 0f       	add	r24, r18
    da5e:	69 2f       	mov	r22, r25
    da60:	40 91 79 02 	lds	r20, 0x0279
    da64:	1b c0       	rjmp	.+54     	; 0xda9c <UserInput+0x472>
					   
				  else lcd_put(xChar,yChar,'*'); 
    da66:	80 91 7e 02 	lds	r24, 0x027E
    da6a:	60 91 7d 02 	lds	r22, 0x027D
    da6e:	4a e2       	ldi	r20, 0x2A	; 42
    da70:	15 c0       	rjmp	.+42     	; 0xda9c <UserInput+0x472>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
    da72:	20 91 7c 02 	lds	r18, 0x027C
    da76:	82 2f       	mov	r24, r18
    da78:	90 e0       	ldi	r25, 0x00	; 0
    da7a:	01 97       	sbiw	r24, 0x01	; 1
    da7c:	8d 0d       	add	r24, r13
    da7e:	91 1d       	adc	r25, r1
    da80:	64 e1       	ldi	r22, 0x14	; 20
    da82:	70 e0       	ldi	r23, 0x00	; 0
    da84:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    da88:	36 2f       	mov	r19, r22
    da8a:	82 2f       	mov	r24, r18
    da8c:	64 e1       	ldi	r22, 0x14	; 20
    da8e:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    da92:	d9 0e       	add	r13, r25
    da94:	89 2d       	mov	r24, r9
    da96:	83 0f       	add	r24, r19
    da98:	6d 2d       	mov	r22, r13
    da9a:	40 e2       	ldi	r20, 0x20	; 32
    da9c:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			  }
          iLoop++;
    daa0:	80 91 70 02 	lds	r24, 0x0270
    daa4:	90 91 71 02 	lds	r25, 0x0271
    daa8:	01 96       	adiw	r24, 0x01	; 1
    daaa:	90 93 71 02 	sts	0x0271, r25
    daae:	80 93 70 02 	sts	0x0270, r24
    dab2:	d6 c0       	rjmp	.+428    	; 0xdc60 <UserInput+0x636>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
    dab4:	e2 e0       	ldi	r30, 0x02	; 2
    dab6:	8e 17       	cp	r24, r30
    dab8:	99 f4       	brne	.+38     	; 0xdae0 <UserInput+0x4b6>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
    daba:	60 91 7d 02 	lds	r22, 0x027D
    dabe:	80 91 7c 02 	lds	r24, 0x027C
    dac2:	68 1b       	sub	r22, r24
    dac4:	80 91 7e 02 	lds	r24, 0x027E
    dac8:	40 e2       	ldi	r20, 0x20	; 32
    daca:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
		      strResult[iValuePos]=0;
    dace:	80 91 7c 02 	lds	r24, 0x027C
    dad2:	c8 0f       	add	r28, r24
    dad4:	d1 1d       	adc	r29, r1
    dad6:	18 82       	st	Y, r1
		      iValuePos--;
    dad8:	81 50       	subi	r24, 0x01	; 1
    dada:	80 93 7c 02 	sts	0x027C, r24
    dade:	33 c0       	rjmp	.+102    	; 0xdb46 <UserInput+0x51c>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    dae0:	f1 e0       	ldi	r31, 0x01	; 1
    dae2:	8f 17       	cp	r24, r31
    dae4:	49 f0       	breq	.+18     	; 0xdaf8 <UserInput+0x4ce>
    dae6:	23 e0       	ldi	r18, 0x03	; 3
    dae8:	82 17       	cp	r24, r18
    daea:	31 f0       	breq	.+12     	; 0xdaf8 <UserInput+0x4ce>
    daec:	84 e0       	ldi	r24, 0x04	; 4
    daee:	f8 16       	cp	r15, r24
    daf0:	19 f0       	breq	.+6      	; 0xdaf8 <UserInput+0x4ce>
    daf2:	e5 e0       	ldi	r30, 0x05	; 5
    daf4:	fe 16       	cp	r15, r30
    daf6:	39 f5       	brne	.+78     	; 0xdb46 <UserInput+0x51c>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
    daf8:	20 91 7c 02 	lds	r18, 0x027C
    dafc:	82 2f       	mov	r24, r18
    dafe:	90 e0       	ldi	r25, 0x00	; 0
    db00:	01 97       	sbiw	r24, 0x01	; 1
    db02:	8d 0d       	add	r24, r13
    db04:	91 1d       	adc	r25, r1
    db06:	64 e1       	ldi	r22, 0x14	; 20
    db08:	70 e0       	ldi	r23, 0x00	; 0
    db0a:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    db0e:	36 2f       	mov	r19, r22
    db10:	82 2f       	mov	r24, r18
    db12:	64 e1       	ldi	r22, 0x14	; 20
    db14:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    db18:	d9 0e       	add	r13, r25
    db1a:	89 2d       	mov	r24, r9
    db1c:	83 0f       	add	r24, r19
    db1e:	6d 2d       	mov	r22, r13
    db20:	40 e2       	ldi	r20, 0x20	; 32
    db22:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			  
		      strResult[iValuePos]=0;
    db26:	80 91 7c 02 	lds	r24, 0x027C
    db2a:	c8 0f       	add	r28, r24
    db2c:	d1 1d       	adc	r29, r1
    db2e:	18 82       	st	Y, r1
		      iValuePos--;
    db30:	81 50       	subi	r24, 0x01	; 1
    db32:	80 93 7c 02 	sts	0x027C, r24
			  yChar--;
    db36:	80 91 7d 02 	lds	r24, 0x027D
    db3a:	81 50       	subi	r24, 0x01	; 1
    db3c:	80 93 7d 02 	sts	0x027D, r24
			  IsDelete=True;
    db40:	81 e0       	ldi	r24, 0x01	; 1
    db42:	80 93 78 02 	sts	0x0278, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
    db46:	80 91 7c 02 	lds	r24, 0x027C
    db4a:	88 23       	and	r24, r24
    db4c:	19 f4       	brne	.+6      	; 0xdb54 <UserInput+0x52a>
    db4e:	b5 e0       	ldi	r27, 0x05	; 5
    db50:	eb 2e       	mov	r14, r27
    db52:	01 c0       	rjmp	.+2      	; 0xdb56 <UserInput+0x52c>
    db54:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
    db56:	83 e0       	ldi	r24, 0x03	; 3
    db58:	80 93 7f 02 	sts	0x027F, r24
    db5c:	81 c0       	rjmp	.+258    	; 0xdc60 <UserInput+0x636>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
    db5e:	f5 e0       	ldi	r31, 0x05	; 5
    db60:	8f 17       	cp	r24, r31
    db62:	19 f5       	brne	.+70     	; 0xdbaa <UserInput+0x580>
			  if (iValuePos>0){
    db64:	80 91 7c 02 	lds	r24, 0x027C
    db68:	88 23       	and	r24, r24
    db6a:	a9 f0       	breq	.+42     	; 0xdb96 <UserInput+0x56c>
                  lcd_put(xChar,(yChar-2),'*');
    db6c:	60 91 7d 02 	lds	r22, 0x027D
    db70:	62 50       	subi	r22, 0x02	; 2
    db72:	80 91 7e 02 	lds	r24, 0x027E
    db76:	4a e2       	ldi	r20, 0x2A	; 42
    db78:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			      if (IsDelete==True){
    db7c:	80 91 78 02 	lds	r24, 0x0278
    db80:	60 91 7d 02 	lds	r22, 0x027D
    db84:	81 30       	cpi	r24, 0x01	; 1
    db86:	71 f0       	breq	.+28     	; 0xdba4 <UserInput+0x57a>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
    db88:	61 50       	subi	r22, 0x01	; 1
    db8a:	80 91 7c 02 	lds	r24, 0x027C
    db8e:	c8 0f       	add	r28, r24
    db90:	d1 1d       	adc	r29, r1
    db92:	21 97       	sbiw	r28, 0x01	; 1
    db94:	4d c0       	rjmp	.+154    	; 0xdc30 <UserInput+0x606>
			      }
			  else{ if(IsDelete==True){
    db96:	80 91 78 02 	lds	r24, 0x0278
    db9a:	60 91 7d 02 	lds	r22, 0x027D
    db9e:	81 30       	cpi	r24, 0x01	; 1
    dba0:	09 f0       	breq	.+2      	; 0xdba4 <UserInput+0x57a>
    dba2:	45 c0       	rjmp	.+138    	; 0xdc2e <UserInput+0x604>
			           IsDelete=False;
    dba4:	10 92 78 02 	sts	0x0278, r1
    dba8:	4c c0       	rjmp	.+152    	; 0xdc42 <UserInput+0x618>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
    dbaa:	22 e0       	ldi	r18, 0x02	; 2
    dbac:	82 17       	cp	r24, r18
    dbae:	a1 f4       	brne	.+40     	; 0xdbd8 <UserInput+0x5ae>
    dbb0:	10 e0       	ldi	r17, 0x00	; 0
    dbb2:	0d c0       	rjmp	.+26     	; 0xdbce <UserInput+0x5a4>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
    dbb4:	60 91 7d 02 	lds	r22, 0x027D
    dbb8:	68 1b       	sub	r22, r24
    dbba:	61 0f       	add	r22, r17
    dbbc:	fe 01       	movw	r30, r28
    dbbe:	e1 0f       	add	r30, r17
    dbc0:	f1 1d       	adc	r31, r1
    dbc2:	80 91 7e 02 	lds	r24, 0x027E
    dbc6:	40 81       	ld	r20, Z
    dbc8:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
    dbcc:	1f 5f       	subi	r17, 0xFF	; 255
    dbce:	80 91 7c 02 	lds	r24, 0x027C
    dbd2:	18 17       	cp	r17, r24
    dbd4:	78 f3       	brcs	.-34     	; 0xdbb4 <UserInput+0x58a>
    dbd6:	3b c0       	rjmp	.+118    	; 0xdc4e <UserInput+0x624>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
    dbd8:	81 e0       	ldi	r24, 0x01	; 1
    dbda:	f8 16       	cp	r15, r24
    dbdc:	19 f0       	breq	.+6      	; 0xdbe4 <UserInput+0x5ba>
    dbde:	e3 e0       	ldi	r30, 0x03	; 3
    dbe0:	fe 16       	cp	r15, r30
    dbe2:	51 f5       	brne	.+84     	; 0xdc38 <UserInput+0x60e>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
    dbe4:	20 91 7c 02 	lds	r18, 0x027C
    dbe8:	4d 2d       	mov	r20, r13
    dbea:	50 e0       	ldi	r21, 0x00	; 0
    dbec:	22 23       	and	r18, r18
    dbee:	c1 f0       	breq	.+48     	; 0xdc20 <UserInput+0x5f6>
    dbf0:	30 e0       	ldi	r19, 0x00	; 0
    dbf2:	f9 01       	movw	r30, r18
    dbf4:	31 97       	sbiw	r30, 0x01	; 1
    dbf6:	cf 01       	movw	r24, r30
    dbf8:	84 0f       	add	r24, r20
    dbfa:	95 1f       	adc	r25, r21
    dbfc:	65 e1       	ldi	r22, 0x15	; 21
    dbfe:	70 e0       	ldi	r23, 0x00	; 0
    dc00:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    dc04:	46 2f       	mov	r20, r22
    dc06:	cf 01       	movw	r24, r30
    dc08:	64 e1       	ldi	r22, 0x14	; 20
    dc0a:	70 e0       	ldi	r23, 0x00	; 0
    dc0c:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    dc10:	d8 0e       	add	r13, r24
    dc12:	c2 0f       	add	r28, r18
    dc14:	d3 1f       	adc	r29, r19
    dc16:	21 97       	sbiw	r28, 0x01	; 1
    dc18:	89 2d       	mov	r24, r9
    dc1a:	84 0f       	add	r24, r20
    dc1c:	6d 2d       	mov	r22, r13
    dc1e:	0a c0       	rjmp	.+20     	; 0xdc34 <UserInput+0x60a>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
    dc20:	60 91 7d 02 	lds	r22, 0x027D
    dc24:	86 2f       	mov	r24, r22
    dc26:	90 e0       	ldi	r25, 0x00	; 0
    dc28:	48 17       	cp	r20, r24
    dc2a:	59 07       	cpc	r21, r25
    dc2c:	84 f4       	brge	.+32     	; 0xdc4e <UserInput+0x624>
    dc2e:	61 50       	subi	r22, 0x01	; 1
    dc30:	80 91 7e 02 	lds	r24, 0x027E
    dc34:	48 81       	ld	r20, Y
    dc36:	09 c0       	rjmp	.+18     	; 0xdc4a <UserInput+0x620>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
    dc38:	f4 e0       	ldi	r31, 0x04	; 4
    dc3a:	ff 16       	cp	r15, r31
    dc3c:	41 f4       	brne	.+16     	; 0xdc4e <UserInput+0x624>
		      lcd_put(xChar,(yChar-1),'*');
    dc3e:	60 91 7d 02 	lds	r22, 0x027D
    dc42:	61 50       	subi	r22, 0x01	; 1
    dc44:	80 91 7e 02 	lds	r24, 0x027E
    dc48:	4a e2       	ldi	r20, 0x2A	; 42
    dc4a:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
		  }

          stUserInput=uiInput;
    dc4e:	81 e0       	ldi	r24, 0x01	; 1
    dc50:	80 93 7f 02 	sts	0x027F, r24
    dc54:	ee 24       	eor	r14, r14
    dc56:	04 c0       	rjmp	.+8      	; 0xdc60 <UserInput+0x636>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
    dc58:	e0 90 80 02 	lds	r14, 0x0280
	      stUserInput=uiInit;
    dc5c:	10 92 7f 02 	sts	0x027F, r1
	      break;
	 }
	 return Result;
}
    dc60:	8e 2d       	mov	r24, r14
    dc62:	df 91       	pop	r29
    dc64:	cf 91       	pop	r28
    dc66:	1f 91       	pop	r17
    dc68:	0f 91       	pop	r16
    dc6a:	ff 90       	pop	r15
    dc6c:	ef 90       	pop	r14
    dc6e:	df 90       	pop	r13
    dc70:	cf 90       	pop	r12
    dc72:	bf 90       	pop	r11
    dc74:	af 90       	pop	r10
    dc76:	9f 90       	pop	r9
    dc78:	8f 90       	pop	r8
    dc7a:	08 95       	ret

0000dc7c <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}

char FSettingOperator(){//Change Active Operator, Change Password
    dc7c:	ef 92       	push	r14
    dc7e:	0f 93       	push	r16
    dc80:	1f 93       	push	r17
    dc82:	df 93       	push	r29
    dc84:	cf 93       	push	r28
    dc86:	cd b7       	in	r28, 0x3d	; 61
    dc88:	de b7       	in	r29, 0x3e	; 62
    dc8a:	e5 97       	sbiw	r28, 0x35	; 53
    dc8c:	0f b6       	in	r0, 0x3f	; 63
    dc8e:	f8 94       	cli
    dc90:	de bf       	out	0x3e, r29	; 62
    dc92:	0f be       	out	0x3f, r0	; 63
    dc94:	cd bf       	out	0x3d, r28	; 61
	        char KeyPressed,KeyChar,lcdteks[20],strPassword[15];
			char strOperatorName[18];
			char uiResult=USER_NONE,Result=MENU_NONE;

	 Result=MENU_NONE;
	 switch(stSettingOperator){
    dc96:	80 91 1e 02 	lds	r24, 0x021E
    dc9a:	87 30       	cpi	r24, 0x07	; 7
    dc9c:	09 f4       	brne	.+2      	; 0xdca0 <FSettingOperator+0x24>
    dc9e:	78 c1       	rjmp	.+752    	; 0xdf90 <FSettingOperator+0x314>
    dca0:	88 30       	cpi	r24, 0x08	; 8
    dca2:	90 f4       	brcc	.+36     	; 0xdcc8 <FSettingOperator+0x4c>
    dca4:	83 30       	cpi	r24, 0x03	; 3
    dca6:	09 f4       	brne	.+2      	; 0xdcaa <FSettingOperator+0x2e>
    dca8:	a0 c0       	rjmp	.+320    	; 0xddea <FSettingOperator+0x16e>
    dcaa:	84 30       	cpi	r24, 0x04	; 4
    dcac:	30 f4       	brcc	.+12     	; 0xdcba <FSettingOperator+0x3e>
    dcae:	81 30       	cpi	r24, 0x01	; 1
    dcb0:	d1 f1       	breq	.+116    	; 0xdd26 <FSettingOperator+0xaa>
    dcb2:	82 30       	cpi	r24, 0x02	; 2
    dcb4:	08 f0       	brcs	.+2      	; 0xdcb8 <FSettingOperator+0x3c>
    dcb6:	4a c0       	rjmp	.+148    	; 0xdd4c <FSettingOperator+0xd0>
    dcb8:	20 c0       	rjmp	.+64     	; 0xdcfa <FSettingOperator+0x7e>
    dcba:	85 30       	cpi	r24, 0x05	; 5
    dcbc:	09 f4       	brne	.+2      	; 0xdcc0 <FSettingOperator+0x44>
    dcbe:	39 c1       	rjmp	.+626    	; 0xdf32 <FSettingOperator+0x2b6>
    dcc0:	86 30       	cpi	r24, 0x06	; 6
    dcc2:	08 f0       	brcs	.+2      	; 0xdcc6 <FSettingOperator+0x4a>
    dcc4:	52 c1       	rjmp	.+676    	; 0xdf6a <FSettingOperator+0x2ee>
    dcc6:	ff c0       	rjmp	.+510    	; 0xdec6 <FSettingOperator+0x24a>
    dcc8:	8b 30       	cpi	r24, 0x0B	; 11
    dcca:	09 f4       	brne	.+2      	; 0xdcce <FSettingOperator+0x52>
    dccc:	23 c2       	rjmp	.+1094   	; 0xe114 <FSettingOperator+0x498>
    dcce:	8c 30       	cpi	r24, 0x0C	; 12
    dcd0:	38 f4       	brcc	.+14     	; 0xdce0 <FSettingOperator+0x64>
    dcd2:	89 30       	cpi	r24, 0x09	; 9
    dcd4:	09 f4       	brne	.+2      	; 0xdcd8 <FSettingOperator+0x5c>
    dcd6:	aa c1       	rjmp	.+852    	; 0xe02c <FSettingOperator+0x3b0>
    dcd8:	8a 30       	cpi	r24, 0x0A	; 10
    dcda:	08 f0       	brcs	.+2      	; 0xdcde <FSettingOperator+0x62>
    dcdc:	da c1       	rjmp	.+948    	; 0xe092 <FSettingOperator+0x416>
    dcde:	78 c1       	rjmp	.+752    	; 0xdfd0 <FSettingOperator+0x354>
    dce0:	8d 30       	cpi	r24, 0x0D	; 13
    dce2:	09 f4       	brne	.+2      	; 0xdce6 <FSettingOperator+0x6a>
    dce4:	9b c2       	rjmp	.+1334   	; 0xe21c <FSettingOperator+0x5a0>
    dce6:	8d 30       	cpi	r24, 0x0D	; 13
    dce8:	08 f4       	brcc	.+2      	; 0xdcec <FSettingOperator+0x70>
    dcea:	1b c2       	rjmp	.+1078   	; 0xe122 <FSettingOperator+0x4a6>
    dcec:	8e 30       	cpi	r24, 0x0E	; 14
    dcee:	09 f4       	brne	.+2      	; 0xdcf2 <FSettingOperator+0x76>
    dcf0:	9a c2       	rjmp	.+1332   	; 0xe226 <FSettingOperator+0x5aa>
    dcf2:	8f 30       	cpi	r24, 0x0F	; 15
    dcf4:	09 f0       	breq	.+2      	; 0xdcf8 <FSettingOperator+0x7c>
    dcf6:	a2 c2       	rjmp	.+1348   	; 0xe23c <FSettingOperator+0x5c0>
    dcf8:	9d c2       	rjmp	.+1338   	; 0xe234 <FSettingOperator+0x5b8>
	 case soMenuOption:
	      lcd_clear();
    dcfa:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Change Operator"));
    dcfe:	81 e0       	ldi	r24, 0x01	; 1
    dd00:	61 e0       	ldi	r22, 0x01	; 1
    dd02:	46 e7       	ldi	r20, 0x76	; 118
    dd04:	52 e1       	ldi	r21, 0x12	; 18
    dd06:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Change Password"));
    dd0a:	82 e0       	ldi	r24, 0x02	; 2
    dd0c:	61 e0       	ldi	r22, 0x01	; 1
    dd0e:	44 e6       	ldi	r20, 0x64	; 100
    dd10:	52 e1       	ldi	r21, 0x12	; 18
    dd12:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back          "));
    dd16:	84 e0       	ldi	r24, 0x04	; 4
    dd18:	61 e0       	ldi	r22, 0x01	; 1
    dd1a:	42 e5       	ldi	r20, 0x52	; 82
    dd1c:	52 e1       	ldi	r21, 0x12	; 18
    dd1e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          stSettingOperator=soMenuOptionInput;
    dd22:	81 e0       	ldi	r24, 0x01	; 1
    dd24:	64 c2       	rjmp	.+1224   	; 0xe1ee <FSettingOperator+0x572>
	      break;
     case soMenuOptionInput:
	      KeyPressed=_key_scan(1);
    dd26:	81 e0       	ldi	r24, 0x01	; 1
    dd28:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    dd2c:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  switch(KeyChar){
    dd30:	81 33       	cpi	r24, 0x31	; 49
    dd32:	31 f0       	breq	.+12     	; 0xdd40 <FSettingOperator+0xc4>
    dd34:	82 33       	cpi	r24, 0x32	; 50
    dd36:	31 f0       	breq	.+12     	; 0xdd44 <FSettingOperator+0xc8>
    dd38:	8a 32       	cpi	r24, 0x2A	; 42
    dd3a:	09 f0       	breq	.+2      	; 0xdd3e <FSettingOperator+0xc2>
    dd3c:	7f c2       	rjmp	.+1278   	; 0xe23c <FSettingOperator+0x5c0>
    dd3e:	04 c0       	rjmp	.+8      	; 0xdd48 <FSettingOperator+0xcc>
		  case '1':
		       stSettingOperator=soChangeOperatorInit;
    dd40:	82 e0       	ldi	r24, 0x02	; 2
    dd42:	55 c2       	rjmp	.+1194   	; 0xe1ee <FSettingOperator+0x572>
		       break;
          case '2':
		       stSettingOperator=soChangePasswordInit;
    dd44:	85 e0       	ldi	r24, 0x05	; 5
    dd46:	53 c2       	rjmp	.+1190   	; 0xe1ee <FSettingOperator+0x572>
		       break;
          case '*':
		       stSettingOperator=soExitSettingOperator;
    dd48:	8f e0       	ldi	r24, 0x0F	; 15
    dd4a:	51 c2       	rjmp	.+1186   	; 0xe1ee <FSettingOperator+0x572>
		       break;
		  }
	      break;
     case soChangeOperatorInit:
	      lcd_clear();		  
    dd4c:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    dd50:	8e 01       	movw	r16, r28
    dd52:	00 5f       	subi	r16, 0xF0	; 240
    dd54:	1f 4f       	sbci	r17, 0xFF	; 255
    dd56:	c8 01       	movw	r24, r16
    dd58:	65 e1       	ldi	r22, 0x15	; 21
    dd5a:	70 e0       	ldi	r23, 0x00	; 0
    dd5c:	42 e1       	ldi	r20, 0x12	; 18
    dd5e:	50 e0       	ldi	r21, 0x00	; 0
    dd60:	22 ed       	ldi	r18, 0xD2	; 210
    dd62:	33 e1       	ldi	r19, 0x13	; 19
    dd64:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    dd68:	98 01       	movw	r18, r16
    dd6a:	ce 01       	movw	r24, r28
    dd6c:	4f 96       	adiw	r24, 0x1f	; 31
	    Dest[i]=Source[IdxSource+i];
    dd6e:	0f 5f       	subi	r16, 0xFF	; 255
    dd70:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    dd72:	08 17       	cp	r16, r24
    dd74:	19 07       	cpc	r17, r25
    dd76:	d9 f7       	brne	.-10     	; 0xdd6e <FSettingOperator+0xf2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    dd78:	1f 8e       	std	Y+31, r1	; 0x1f
     case soChangeOperatorInit:
	      lcd_clear();		  
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);

		  sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
    dd7a:	00 d0       	rcall	.+0      	; 0xdd7c <FSettingOperator+0x100>
    dd7c:	00 d0       	rcall	.+0      	; 0xdd7e <FSettingOperator+0x102>
    dd7e:	00 d0       	rcall	.+0      	; 0xdd80 <FSettingOperator+0x104>
    dd80:	ed b7       	in	r30, 0x3d	; 61
    dd82:	fe b7       	in	r31, 0x3e	; 62
    dd84:	31 96       	adiw	r30, 0x01	; 1
    dd86:	8e 01       	movw	r16, r28
    dd88:	0e 5d       	subi	r16, 0xDE	; 222
    dd8a:	1f 4f       	sbci	r17, 0xFF	; 255
    dd8c:	ad b7       	in	r26, 0x3d	; 61
    dd8e:	be b7       	in	r27, 0x3e	; 62
    dd90:	12 96       	adiw	r26, 0x02	; 2
    dd92:	1c 93       	st	X, r17
    dd94:	0e 93       	st	-X, r16
    dd96:	11 97       	sbiw	r26, 0x01	; 1
    dd98:	8f e4       	ldi	r24, 0x4F	; 79
    dd9a:	92 e1       	ldi	r25, 0x12	; 18
    dd9c:	93 83       	std	Z+3, r25	; 0x03
    dd9e:	82 83       	std	Z+2, r24	; 0x02
    dda0:	24 83       	std	Z+4, r18	; 0x04
    dda2:	35 83       	std	Z+5, r19	; 0x05
    dda4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_printf(1,1,PSTR("Name:"));
    dda8:	8d b7       	in	r24, 0x3d	; 61
    ddaa:	9e b7       	in	r25, 0x3e	; 62
    ddac:	06 96       	adiw	r24, 0x06	; 6
    ddae:	0f b6       	in	r0, 0x3f	; 63
    ddb0:	f8 94       	cli
    ddb2:	9e bf       	out	0x3e, r25	; 62
    ddb4:	0f be       	out	0x3f, r0	; 63
    ddb6:	8d bf       	out	0x3d, r24	; 61
    ddb8:	81 e0       	ldi	r24, 0x01	; 1
    ddba:	61 e0       	ldi	r22, 0x01	; 1
    ddbc:	49 e4       	ldi	r20, 0x49	; 73
    ddbe:	52 e1       	ldi	r21, 0x12	; 18
    ddc0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_print (1,6,lcdteks);
    ddc4:	81 e0       	ldi	r24, 0x01	; 1
    ddc6:	66 e0       	ldi	r22, 0x06	; 6
    ddc8:	a8 01       	movw	r20, r16
    ddca:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(2,1,PSTR("New :_              "));
    ddce:	82 e0       	ldi	r24, 0x02	; 2
    ddd0:	61 e0       	ldi	r22, 0x01	; 1
    ddd2:	44 e3       	ldi	r20, 0x34	; 52
    ddd4:	52 e1       	ldi	r21, 0x12	; 18
    ddd6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    ddda:	84 e0       	ldi	r24, 0x04	; 4
    dddc:	61 e0       	ldi	r22, 0x01	; 1
    ddde:	4f e1       	ldi	r20, 0x1F	; 31
    dde0:	52 e1       	ldi	r21, 0x12	; 18
    dde2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          stSettingOperator=soOperatorNameInput;
    dde6:	83 e0       	ldi	r24, 0x03	; 3
    dde8:	02 c2       	rjmp	.+1028   	; 0xe1ee <FSettingOperator+0x572>
	      break;
     case soOperatorNameInput:
          uiResult=USER_NONE;
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
    ddea:	83 e0       	ldi	r24, 0x03	; 3
    ddec:	62 e0       	ldi	r22, 0x02	; 2
    ddee:	46 e0       	ldi	r20, 0x06	; 6
    ddf0:	22 e9       	ldi	r18, 0x92	; 146
    ddf2:	38 e0       	ldi	r19, 0x08	; 8
    ddf4:	00 e0       	ldi	r16, 0x00	; 0
    ddf6:	10 e0       	ldi	r17, 0x00	; 0
    ddf8:	f0 e1       	ldi	r31, 0x10	; 16
    ddfa:	ef 2e       	mov	r14, r31
    ddfc:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  switch(uiResult){
    de00:	83 30       	cpi	r24, 0x03	; 3
    de02:	51 f0       	breq	.+20     	; 0xde18 <FSettingOperator+0x19c>
    de04:	84 30       	cpi	r24, 0x04	; 4
    de06:	08 f4       	brcc	.+2      	; 0xde0a <FSettingOperator+0x18e>
    de08:	f2 c0       	rjmp	.+484    	; 0xdfee <FSettingOperator+0x372>
    de0a:	84 30       	cpi	r24, 0x04	; 4
    de0c:	09 f4       	brne	.+2      	; 0xde10 <FSettingOperator+0x194>
    de0e:	51 c0       	rjmp	.+162    	; 0xdeb2 <FSettingOperator+0x236>
    de10:	85 30       	cpi	r24, 0x05	; 5
    de12:	09 f0       	breq	.+2      	; 0xde16 <FSettingOperator+0x19a>
    de14:	13 c2       	rjmp	.+1062   	; 0xe23c <FSettingOperator+0x5c0>
    de16:	52 c0       	rjmp	.+164    	; 0xdebc <FSettingOperator+0x240>
		  case USER_OK:
		       lcd_clear();
    de18:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    de1c:	20 e0       	ldi	r18, 0x00	; 0
    de1e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    de20:	ae 01       	movw	r20, r28
    de22:	40 5f       	subi	r20, 0xF0	; 240
    de24:	5f 4f       	sbci	r21, 0xFF	; 255
    de26:	fa 01       	movw	r30, r20
    de28:	e2 0f       	add	r30, r18
    de2a:	f3 1f       	adc	r31, r19
    de2c:	d9 01       	movw	r26, r18
    de2e:	ae 56       	subi	r26, 0x6E	; 110
    de30:	b7 4f       	sbci	r27, 0xF7	; 247
    de32:	8c 91       	ld	r24, X
    de34:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    de36:	2f 5f       	subi	r18, 0xFF	; 255
    de38:	3f 4f       	sbci	r19, 0xFF	; 255
    de3a:	2f 30       	cpi	r18, 0x0F	; 15
    de3c:	31 05       	cpc	r19, r1
    de3e:	99 f7       	brne	.-26     	; 0xde26 <FSettingOperator+0x1aa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    de40:	1f 8e       	std	Y+31, r1	; 0x1f
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
		  switch(uiResult){
		  case USER_OK:
		       lcd_clear();
			   StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
		       sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
    de42:	00 d0       	rcall	.+0      	; 0xde44 <FSettingOperator+0x1c8>
    de44:	00 d0       	rcall	.+0      	; 0xde46 <FSettingOperator+0x1ca>
    de46:	00 d0       	rcall	.+0      	; 0xde48 <FSettingOperator+0x1cc>
    de48:	ed b7       	in	r30, 0x3d	; 61
    de4a:	fe b7       	in	r31, 0x3e	; 62
    de4c:	31 96       	adiw	r30, 0x01	; 1
    de4e:	8e 01       	movw	r16, r28
    de50:	0e 5d       	subi	r16, 0xDE	; 222
    de52:	1f 4f       	sbci	r17, 0xFF	; 255
    de54:	ad b7       	in	r26, 0x3d	; 61
    de56:	be b7       	in	r27, 0x3e	; 62
    de58:	12 96       	adiw	r26, 0x02	; 2
    de5a:	1c 93       	st	X, r17
    de5c:	0e 93       	st	-X, r16
    de5e:	11 97       	sbiw	r26, 0x01	; 1
    de60:	8c e1       	ldi	r24, 0x1C	; 28
    de62:	92 e1       	ldi	r25, 0x12	; 18
    de64:	93 83       	std	Z+3, r25	; 0x03
    de66:	82 83       	std	Z+2, r24	; 0x02
    de68:	55 83       	std	Z+5, r21	; 0x05
    de6a:	44 83       	std	Z+4, r20	; 0x04
    de6c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			   lcd_printf(1,1,PSTR("New Operator:"));
    de70:	8d b7       	in	r24, 0x3d	; 61
    de72:	9e b7       	in	r25, 0x3e	; 62
    de74:	06 96       	adiw	r24, 0x06	; 6
    de76:	0f b6       	in	r0, 0x3f	; 63
    de78:	f8 94       	cli
    de7a:	9e bf       	out	0x3e, r25	; 62
    de7c:	0f be       	out	0x3f, r0	; 63
    de7e:	8d bf       	out	0x3d, r24	; 61
    de80:	81 e0       	ldi	r24, 0x01	; 1
    de82:	61 e0       	ldi	r22, 0x01	; 1
    de84:	4e e0       	ldi	r20, 0x0E	; 14
    de86:	52 e1       	ldi	r21, 0x12	; 18
    de88:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   lcd_print (2,1,lcdteks);
    de8c:	82 e0       	ldi	r24, 0x02	; 2
    de8e:	61 e0       	ldi	r22, 0x01	; 1
    de90:	a8 01       	movw	r20, r16
    de92:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			   lcd_printf(3,1,PSTR("Save?"));
    de96:	83 e0       	ldi	r24, 0x03	; 3
    de98:	61 e0       	ldi	r22, 0x01	; 1
    de9a:	48 e0       	ldi	r20, 0x08	; 8
    de9c:	52 e1       	ldi	r21, 0x12	; 18
    de9e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]No    [#]Yes"));
    dea2:	84 e0       	ldi	r24, 0x04	; 4
    dea4:	61 e0       	ldi	r22, 0x01	; 1
    dea6:	48 ef       	ldi	r20, 0xF8	; 248
    dea8:	51 e1       	ldi	r21, 0x11	; 17
    deaa:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
               stSettingOperator=soIsSaveOperatorName;
    deae:	84 e0       	ldi	r24, 0x04	; 4
    deb0:	9e c1       	rjmp	.+828    	; 0xe1ee <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    deb2:	84 e0       	ldi	r24, 0x04	; 4
    deb4:	61 e0       	ldi	r22, 0x01	; 1
    deb6:	43 ee       	ldi	r20, 0xE3	; 227
    deb8:	51 e1       	ldi	r21, 0x11	; 17
    deba:	29 c1       	rjmp	.+594    	; 0xe10e <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    debc:	84 e0       	ldi	r24, 0x04	; 4
    debe:	61 e0       	ldi	r22, 0x01	; 1
    dec0:	4e ec       	ldi	r20, 0xCE	; 206
    dec2:	51 e1       	ldi	r21, 0x11	; 17
    dec4:	24 c1       	rjmp	.+584    	; 0xe10e <FSettingOperator+0x492>
		       break;
		  }
	      break;
     case soIsSaveOperatorName:
          KeyPressed=_key_scan(1);
    dec6:	81 e0       	ldi	r24, 0x01	; 1
    dec8:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    decc:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  switch(KeyChar){
    ded0:	83 32       	cpi	r24, 0x23	; 35
    ded2:	09 f0       	breq	.+2      	; 0xded6 <FSettingOperator+0x25a>
    ded4:	53 c0       	rjmp	.+166    	; 0xdf7c <FSettingOperator+0x300>
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
    ded6:	20 e0       	ldi	r18, 0x00	; 0
    ded8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    deda:	8e 01       	movw	r16, r28
    dedc:	00 5f       	subi	r16, 0xF0	; 240
    dede:	1f 4f       	sbci	r17, 0xFF	; 255
    dee0:	f8 01       	movw	r30, r16
    dee2:	e2 0f       	add	r30, r18
    dee4:	f3 1f       	adc	r31, r19
    dee6:	d9 01       	movw	r26, r18
    dee8:	ae 56       	subi	r26, 0x6E	; 110
    deea:	b7 4f       	sbci	r27, 0xF7	; 247
    deec:	8c 91       	ld	r24, X
    deee:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    def0:	2f 5f       	subi	r18, 0xFF	; 255
    def2:	3f 4f       	sbci	r19, 0xFF	; 255
    def4:	2f 30       	cpi	r18, 0x0F	; 15
    def6:	31 05       	cpc	r19, r1
    def8:	99 f7       	brne	.-26     	; 0xdee0 <FSettingOperator+0x264>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    defa:	1f 8e       	std	Y+31, r1	; 0x1f
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
          case '#':
		       StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
               AddSpaceLag(strOperatorName,18); 
    defc:	c8 01       	movw	r24, r16
    defe:	62 e1       	ldi	r22, 0x12	; 18
    df00:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    df04:	85 e1       	ldi	r24, 0x15	; 21
    df06:	90 e0       	ldi	r25, 0x00	; 0
    df08:	b8 01       	movw	r22, r16
    df0a:	42 e1       	ldi	r20, 0x12	; 18
    df0c:	50 e0       	ldi	r21, 0x00	; 0
    df0e:	2a ed       	ldi	r18, 0xDA	; 218
    df10:	33 e1       	ldi	r19, 0x13	; 19
    df12:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
		       eeprom_write_block((const void*) &strOperatorName, (void*) &DefOperatorName,18);
		       lcd_printf(3,1,PSTR("Saved "));
    df16:	83 e0       	ldi	r24, 0x03	; 3
    df18:	61 e0       	ldi	r22, 0x01	; 1
    df1a:	47 ec       	ldi	r20, 0xC7	; 199
    df1c:	51 e1       	ldi	r21, 0x11	; 17
    df1e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   TimDisplay=0;
    df22:	10 92 92 01 	sts	0x0192, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    df26:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    df28:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    df2a:	81 e0       	ldi	r24, 0x01	; 1
    df2c:	80 93 bc 01 	sts	0x01BC, r24
    df30:	46 c1       	rjmp	.+652    	; 0xe1be <FSettingOperator+0x542>
		       stSettingOperator=soDelayDisplaySaved;
		       break;
		  }	      
		  break;
     case soChangePasswordInit:
	      lcd_clear();
    df32:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("-Change Password-"));
    df36:	81 e0       	ldi	r24, 0x01	; 1
    df38:	61 e0       	ldi	r22, 0x01	; 1
    df3a:	45 eb       	ldi	r20, 0xB5	; 181
    df3c:	51 e1       	ldi	r21, 0x11	; 17
    df3e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Supervisor"));
    df42:	82 e0       	ldi	r24, 0x02	; 2
    df44:	61 e0       	ldi	r22, 0x01	; 1
    df46:	48 ea       	ldi	r20, 0xA8	; 168
    df48:	51 e1       	ldi	r21, 0x11	; 17
    df4a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Administrator"));
    df4e:	83 e0       	ldi	r24, 0x03	; 3
    df50:	61 e0       	ldi	r22, 0x01	; 1
    df52:	48 e9       	ldi	r20, 0x98	; 152
    df54:	51 e1       	ldi	r21, 0x11	; 17
    df56:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back     "));
    df5a:	84 e0       	ldi	r24, 0x04	; 4
    df5c:	61 e0       	ldi	r22, 0x01	; 1
    df5e:	4b e8       	ldi	r20, 0x8B	; 139
    df60:	51 e1       	ldi	r21, 0x11	; 17
    df62:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          stSettingOperator=soChangePasswordInput; 
    df66:	86 e0       	ldi	r24, 0x06	; 6
    df68:	42 c1       	rjmp	.+644    	; 0xe1ee <FSettingOperator+0x572>
	      break;
     case soChangePasswordInput:
          KeyPressed=_key_scan(1);
    df6a:	81 e0       	ldi	r24, 0x01	; 1
    df6c:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    df70:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  switch(KeyChar){
    df74:	81 33       	cpi	r24, 0x31	; 49
    df76:	31 f0       	breq	.+12     	; 0xdf84 <FSettingOperator+0x308>
    df78:	82 33       	cpi	r24, 0x32	; 50
    df7a:	31 f0       	breq	.+12     	; 0xdf88 <FSettingOperator+0x30c>
    df7c:	8a 32       	cpi	r24, 0x2A	; 42
    df7e:	09 f0       	breq	.+2      	; 0xdf82 <FSettingOperator+0x306>
    df80:	5d c1       	rjmp	.+698    	; 0xe23c <FSettingOperator+0x5c0>
    df82:	55 c1       	rjmp	.+682    	; 0xe22e <FSettingOperator+0x5b2>
		  case '1':		 
		       PassType=PT_SUPERVISOR;
    df84:	81 e0       	ldi	r24, 0x01	; 1
    df86:	01 c0       	rjmp	.+2      	; 0xdf8a <FSettingOperator+0x30e>
		       stSettingOperator=soOldPasswordDisplay;
		       break;
          case '2':		       
		       PassType=PT_ADMINISTRATOR;
    df88:	82 e0       	ldi	r24, 0x02	; 2
    df8a:	80 93 1d 02 	sts	0x021D, r24
    df8e:	75 c0       	rjmp	.+234    	; 0xe07a <FSettingOperator+0x3fe>
		       stSettingOperator=soMenuOption;
		       break;
		  }	      
	      break;
     case soOldPasswordDisplay:
	 	  lcd_clear();
    df90:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	      if (PassType==PT_SUPERVISOR){
    df94:	80 91 1d 02 	lds	r24, 0x021D
    df98:	81 30       	cpi	r24, 0x01	; 1
    df9a:	21 f4       	brne	.+8      	; 0xdfa4 <FSettingOperator+0x328>
		      lcd_printf(1,1,PSTR("-Supervisor-"));              
    df9c:	61 e0       	ldi	r22, 0x01	; 1
    df9e:	4e e7       	ldi	r20, 0x7E	; 126
    dfa0:	51 e1       	ldi	r21, 0x11	; 17
    dfa2:	06 c0       	rjmp	.+12     	; 0xdfb0 <FSettingOperator+0x334>
		  }else if (PassType==PT_ADMINISTRATOR){		       
    dfa4:	82 30       	cpi	r24, 0x02	; 2
    dfa6:	31 f4       	brne	.+12     	; 0xdfb4 <FSettingOperator+0x338>
		       lcd_printf(1,1,PSTR("-Administrator-"));			   
    dfa8:	81 e0       	ldi	r24, 0x01	; 1
    dfaa:	61 e0       	ldi	r22, 0x01	; 1
    dfac:	4e e6       	ldi	r20, 0x6E	; 110
    dfae:	51 e1       	ldi	r21, 0x11	; 17
    dfb0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  }
		      lcd_printf(2,1,PSTR("Old:_"));
    dfb4:	82 e0       	ldi	r24, 0x02	; 2
    dfb6:	61 e0       	ldi	r22, 0x01	; 1
    dfb8:	48 e6       	ldi	r20, 0x68	; 104
    dfba:	51 e1       	ldi	r21, 0x11	; 17
    dfbc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    dfc0:	84 e0       	ldi	r24, 0x04	; 4
    dfc2:	61 e0       	ldi	r22, 0x01	; 1
    dfc4:	43 e5       	ldi	r20, 0x53	; 83
    dfc6:	51 e1       	ldi	r21, 0x11	; 17
    dfc8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>

          stSettingOperator=soOldPasswordEntry;
    dfcc:	88 e0       	ldi	r24, 0x08	; 8
    dfce:	0f c1       	rjmp	.+542    	; 0xe1ee <FSettingOperator+0x572>
	      break;
     case soOldPasswordEntry:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine1,0,8);           
    dfd0:	84 e0       	ldi	r24, 0x04	; 4
    dfd2:	62 e0       	ldi	r22, 0x02	; 2
    dfd4:	45 e0       	ldi	r20, 0x05	; 5
    dfd6:	22 e9       	ldi	r18, 0x92	; 146
    dfd8:	38 e0       	ldi	r19, 0x08	; 8
    dfda:	00 e0       	ldi	r16, 0x00	; 0
    dfdc:	10 e0       	ldi	r17, 0x00	; 0
    dfde:	e8 e0       	ldi	r30, 0x08	; 8
    dfe0:	ee 2e       	mov	r14, r30
    dfe2:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  switch(uiResult){
    dfe6:	83 30       	cpi	r24, 0x03	; 3
    dfe8:	61 f0       	breq	.+24     	; 0xe002 <FSettingOperator+0x386>
    dfea:	84 30       	cpi	r24, 0x04	; 4
    dfec:	20 f4       	brcc	.+8      	; 0xdff6 <FSettingOperator+0x37a>
    dfee:	81 30       	cpi	r24, 0x01	; 1
    dff0:	09 f0       	breq	.+2      	; 0xdff4 <FSettingOperator+0x378>
    dff2:	24 c1       	rjmp	.+584    	; 0xe23c <FSettingOperator+0x5c0>
    dff4:	1c c1       	rjmp	.+568    	; 0xe22e <FSettingOperator+0x5b2>
    dff6:	84 30       	cpi	r24, 0x04	; 4
    dff8:	79 f0       	breq	.+30     	; 0xe018 <FSettingOperator+0x39c>
    dffa:	85 30       	cpi	r24, 0x05	; 5
    dffc:	09 f0       	breq	.+2      	; 0xe000 <FSettingOperator+0x384>
    dffe:	1e c1       	rjmp	.+572    	; 0xe23c <FSettingOperator+0x5c0>
    e000:	10 c0       	rjmp	.+32     	; 0xe022 <FSettingOperator+0x3a6>
		  case USER_OK:
		       lcd_printf(2,1,PSTR("New:_               "));
    e002:	82 e0       	ldi	r24, 0x02	; 2
    e004:	61 e0       	ldi	r22, 0x01	; 1
    e006:	4e e3       	ldi	r20, 0x3E	; 62
    e008:	51 e1       	ldi	r21, 0x11	; 17
    e00a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e00e:	84 e0       	ldi	r24, 0x04	; 4
    e010:	61 e0       	ldi	r22, 0x01	; 1
    e012:	49 e2       	ldi	r20, 0x29	; 41
    e014:	51 e1       	ldi	r21, 0x11	; 17
    e016:	6e c0       	rjmp	.+220    	; 0xe0f4 <FSettingOperator+0x478>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    e018:	84 e0       	ldi	r24, 0x04	; 4
    e01a:	61 e0       	ldi	r22, 0x01	; 1
    e01c:	44 e1       	ldi	r20, 0x14	; 20
    e01e:	51 e1       	ldi	r21, 0x11	; 17
    e020:	76 c0       	rjmp	.+236    	; 0xe10e <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e022:	84 e0       	ldi	r24, 0x04	; 4
    e024:	61 e0       	ldi	r22, 0x01	; 1
    e026:	4f ef       	ldi	r20, 0xFF	; 255
    e028:	50 e1       	ldi	r21, 0x10	; 16
    e02a:	71 c0       	rjmp	.+226    	; 0xe10e <FSettingOperator+0x492>
		       break;
		  }
	      break;
     case soNewPasswordEntry1:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine2,0,8);           
    e02c:	84 e0       	ldi	r24, 0x04	; 4
    e02e:	62 e0       	ldi	r22, 0x02	; 2
    e030:	45 e0       	ldi	r20, 0x05	; 5
    e032:	23 ea       	ldi	r18, 0xA3	; 163
    e034:	37 e0       	ldi	r19, 0x07	; 7
    e036:	00 e0       	ldi	r16, 0x00	; 0
    e038:	10 e0       	ldi	r17, 0x00	; 0
    e03a:	78 e0       	ldi	r23, 0x08	; 8
    e03c:	e7 2e       	mov	r14, r23
    e03e:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  switch(uiResult){
    e042:	83 30       	cpi	r24, 0x03	; 3
    e044:	61 f0       	breq	.+24     	; 0xe05e <FSettingOperator+0x3e2>
    e046:	84 30       	cpi	r24, 0x04	; 4
    e048:	20 f4       	brcc	.+8      	; 0xe052 <FSettingOperator+0x3d6>
    e04a:	81 30       	cpi	r24, 0x01	; 1
    e04c:	09 f0       	breq	.+2      	; 0xe050 <FSettingOperator+0x3d4>
    e04e:	f6 c0       	rjmp	.+492    	; 0xe23c <FSettingOperator+0x5c0>
    e050:	14 c0       	rjmp	.+40     	; 0xe07a <FSettingOperator+0x3fe>
    e052:	84 30       	cpi	r24, 0x04	; 4
    e054:	a1 f0       	breq	.+40     	; 0xe07e <FSettingOperator+0x402>
    e056:	85 30       	cpi	r24, 0x05	; 5
    e058:	09 f0       	breq	.+2      	; 0xe05c <FSettingOperator+0x3e0>
    e05a:	f0 c0       	rjmp	.+480    	; 0xe23c <FSettingOperator+0x5c0>
    e05c:	15 c0       	rjmp	.+42     	; 0xe088 <FSettingOperator+0x40c>
		  case USER_OK:
		       lcd_printf(3,1,PSTR("New:_               "));
    e05e:	83 e0       	ldi	r24, 0x03	; 3
    e060:	61 e0       	ldi	r22, 0x01	; 1
    e062:	4a ee       	ldi	r20, 0xEA	; 234
    e064:	50 e1       	ldi	r21, 0x10	; 16
    e066:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e06a:	84 e0       	ldi	r24, 0x04	; 4
    e06c:	61 e0       	ldi	r22, 0x01	; 1
    e06e:	45 ed       	ldi	r20, 0xD5	; 213
    e070:	50 e1       	ldi	r21, 0x10	; 16
    e072:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry2;
    e076:	8a e0       	ldi	r24, 0x0A	; 10
    e078:	ba c0       	rjmp	.+372    	; 0xe1ee <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:		       
			   stSettingOperator=soOldPasswordDisplay;
    e07a:	87 e0       	ldi	r24, 0x07	; 7
    e07c:	b8 c0       	rjmp	.+368    	; 0xe1ee <FSettingOperator+0x572>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    e07e:	84 e0       	ldi	r24, 0x04	; 4
    e080:	61 e0       	ldi	r22, 0x01	; 1
    e082:	40 ec       	ldi	r20, 0xC0	; 192
    e084:	50 e1       	ldi	r21, 0x10	; 16
    e086:	43 c0       	rjmp	.+134    	; 0xe10e <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e088:	84 e0       	ldi	r24, 0x04	; 4
    e08a:	61 e0       	ldi	r22, 0x01	; 1
    e08c:	4b ea       	ldi	r20, 0xAB	; 171
    e08e:	50 e1       	ldi	r21, 0x10	; 16
    e090:	3e c0       	rjmp	.+124    	; 0xe10e <FSettingOperator+0x492>
		       break;
		  }	      
	      break;
     case soNewPasswordEntry2:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,3,5,strFreeMessageLine3,0,8);           
    e092:	84 e0       	ldi	r24, 0x04	; 4
    e094:	63 e0       	ldi	r22, 0x03	; 3
    e096:	45 e0       	ldi	r20, 0x05	; 5
    e098:	2c e1       	ldi	r18, 0x1C	; 28
    e09a:	38 e0       	ldi	r19, 0x08	; 8
    e09c:	00 e0       	ldi	r16, 0x00	; 0
    e09e:	10 e0       	ldi	r17, 0x00	; 0
    e0a0:	58 e0       	ldi	r21, 0x08	; 8
    e0a2:	e5 2e       	mov	r14, r21
    e0a4:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  switch(uiResult){
    e0a8:	83 30       	cpi	r24, 0x03	; 3
    e0aa:	61 f0       	breq	.+24     	; 0xe0c4 <FSettingOperator+0x448>
    e0ac:	84 30       	cpi	r24, 0x04	; 4
    e0ae:	20 f4       	brcc	.+8      	; 0xe0b8 <FSettingOperator+0x43c>
    e0b0:	81 30       	cpi	r24, 0x01	; 1
    e0b2:	09 f0       	breq	.+2      	; 0xe0b6 <FSettingOperator+0x43a>
    e0b4:	c3 c0       	rjmp	.+390    	; 0xe23c <FSettingOperator+0x5c0>
    e0b6:	12 c0       	rjmp	.+36     	; 0xe0dc <FSettingOperator+0x460>
    e0b8:	84 30       	cpi	r24, 0x04	; 4
    e0ba:	01 f1       	breq	.+64     	; 0xe0fc <FSettingOperator+0x480>
    e0bc:	85 30       	cpi	r24, 0x05	; 5
    e0be:	09 f0       	breq	.+2      	; 0xe0c2 <FSettingOperator+0x446>
    e0c0:	bd c0       	rjmp	.+378    	; 0xe23c <FSettingOperator+0x5c0>
    e0c2:	21 c0       	rjmp	.+66     	; 0xe106 <FSettingOperator+0x48a>
		  case USER_OK:
		       lcd_clear();
    e0c4:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
               lcd_printf(2,1,PSTR("Validating.."));
    e0c8:	82 e0       	ldi	r24, 0x02	; 2
    e0ca:	61 e0       	ldi	r22, 0x01	; 1
    e0cc:	4e e9       	ldi	r20, 0x9E	; 158
    e0ce:	50 e1       	ldi	r21, 0x10	; 16
    e0d0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   TimDisplay=0;
    e0d4:	10 92 92 01 	sts	0x0192, r1
		       stSettingOperator=soDispValidatePassword;
    e0d8:	8b e0       	ldi	r24, 0x0B	; 11
    e0da:	89 c0       	rjmp	.+274    	; 0xe1ee <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:
               lcd_clear();
    e0dc:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
               lcd_printf(2,1,PSTR("New:_               "));
    e0e0:	82 e0       	ldi	r24, 0x02	; 2
    e0e2:	61 e0       	ldi	r22, 0x01	; 1
    e0e4:	49 e8       	ldi	r20, 0x89	; 137
    e0e6:	50 e1       	ldi	r21, 0x10	; 16
    e0e8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e0ec:	84 e0       	ldi	r24, 0x04	; 4
    e0ee:	61 e0       	ldi	r22, 0x01	; 1
    e0f0:	44 e7       	ldi	r20, 0x74	; 116
    e0f2:	50 e1       	ldi	r21, 0x10	; 16
    e0f4:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry1;
    e0f8:	89 e0       	ldi	r24, 0x09	; 9
    e0fa:	79 c0       	rjmp	.+242    	; 0xe1ee <FSettingOperator+0x572>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    e0fc:	84 e0       	ldi	r24, 0x04	; 4
    e0fe:	61 e0       	ldi	r22, 0x01	; 1
    e100:	4f e5       	ldi	r20, 0x5F	; 95
    e102:	50 e1       	ldi	r21, 0x10	; 16
    e104:	04 c0       	rjmp	.+8      	; 0xe10e <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e106:	84 e0       	ldi	r24, 0x04	; 4
    e108:	61 e0       	ldi	r22, 0x01	; 1
    e10a:	4a e4       	ldi	r20, 0x4A	; 74
    e10c:	50 e1       	ldi	r21, 0x10	; 16
    e10e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    e112:	94 c0       	rjmp	.+296    	; 0xe23c <FSettingOperator+0x5c0>
		       break;
		  }	      
	      break;
     case soDispValidatePassword:
	      if (TimDisplay>3)stSettingOperator=soValidatePassword;
    e114:	80 91 92 01 	lds	r24, 0x0192
    e118:	84 30       	cpi	r24, 0x04	; 4
    e11a:	08 f4       	brcc	.+2      	; 0xe11e <FSettingOperator+0x4a2>
    e11c:	8f c0       	rjmp	.+286    	; 0xe23c <FSettingOperator+0x5c0>
    e11e:	8c e0       	ldi	r24, 0x0C	; 12
    e120:	66 c0       	rjmp	.+204    	; 0xe1ee <FSettingOperator+0x572>
	      break;
     case soValidatePassword:
          if (PassType==PT_SUPERVISOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSysPassword, 10);		      			   
    e122:	80 91 1d 02 	lds	r24, 0x021D
    e126:	81 30       	cpi	r24, 0x01	; 1
    e128:	29 f4       	brne	.+10     	; 0xe134 <FSettingOperator+0x4b8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e12a:	ce 01       	movw	r24, r28
    e12c:	01 96       	adiw	r24, 0x01	; 1
    e12e:	6b e0       	ldi	r22, 0x0B	; 11
    e130:	70 e0       	ldi	r23, 0x00	; 0
    e132:	06 c0       	rjmp	.+12     	; 0xe140 <FSettingOperator+0x4c4>
		  else 
		  if (PassType==PT_ADMINISTRATOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSpvPassword, 10);    
    e134:	82 30       	cpi	r24, 0x02	; 2
    e136:	51 f4       	brne	.+20     	; 0xe14c <FSettingOperator+0x4d0>
    e138:	ce 01       	movw	r24, r28
    e13a:	01 96       	adiw	r24, 0x01	; 1
    e13c:	61 e0       	ldi	r22, 0x01	; 1
    e13e:	70 e0       	ldi	r23, 0x00	; 0
    e140:	4a e0       	ldi	r20, 0x0A	; 10
    e142:	50 e0       	ldi	r21, 0x00	; 0
    e144:	22 ed       	ldi	r18, 0xD2	; 210
    e146:	33 e1       	ldi	r19, 0x13	; 19
    e148:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		  
		  //Check Old Validity
		  if (strcmp(strPassword,strFreeMessageLine1)==0){//OldMessage Valid
    e14c:	ce 01       	movw	r24, r28
    e14e:	01 96       	adiw	r24, 0x01	; 1
    e150:	62 e9       	ldi	r22, 0x92	; 146
    e152:	78 e0       	ldi	r23, 0x08	; 8
    e154:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    e158:	00 97       	sbiw	r24, 0x00	; 0
    e15a:	09 f0       	breq	.+2      	; 0xe15e <FSettingOperator+0x4e2>
    e15c:	4b c0       	rjmp	.+150    	; 0xe1f4 <FSettingOperator+0x578>
              if (strcmp(strFreeMessageLine2,strFreeMessageLine3)==0){
    e15e:	83 ea       	ldi	r24, 0xA3	; 163
    e160:	97 e0       	ldi	r25, 0x07	; 7
    e162:	6c e1       	ldi	r22, 0x1C	; 28
    e164:	78 e0       	ldi	r23, 0x08	; 8
    e166:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    e16a:	00 97       	sbiw	r24, 0x00	; 0
    e16c:	51 f5       	brne	.+84     	; 0xe1c2 <FSettingOperator+0x546>
                  
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
    e16e:	80 91 1d 02 	lds	r24, 0x021D
    e172:	81 30       	cpi	r24, 0x01	; 1
    e174:	19 f4       	brne	.+6      	; 0xe17c <FSettingOperator+0x500>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    e176:	8b e0       	ldi	r24, 0x0B	; 11
    e178:	90 e0       	ldi	r25, 0x00	; 0
    e17a:	04 c0       	rjmp	.+8      	; 0xe184 <FSettingOperator+0x508>
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    
    e17c:	82 30       	cpi	r24, 0x02	; 2
    e17e:	51 f4       	brne	.+20     	; 0xe194 <FSettingOperator+0x518>
    e180:	81 e0       	ldi	r24, 0x01	; 1
    e182:	90 e0       	ldi	r25, 0x00	; 0
    e184:	63 ea       	ldi	r22, 0xA3	; 163
    e186:	77 e0       	ldi	r23, 0x07	; 7
    e188:	4a e0       	ldi	r20, 0x0A	; 10
    e18a:	50 e0       	ldi	r21, 0x00	; 0
    e18c:	2a ed       	ldi	r18, 0xDA	; 218
    e18e:	33 e1       	ldi	r19, 0x13	; 19
    e190:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e194:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e196:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e198:	81 e0       	ldi	r24, 0x01	; 1
    e19a:	80 93 bc 01 	sts	0x01BC, r24
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    

			      system_beep(1);
				  lcd_clear();
    e19e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
			      lcd_printf(2,1,PSTR("     Completed      "));
    e1a2:	82 e0       	ldi	r24, 0x02	; 2
    e1a4:	61 e0       	ldi	r22, 0x01	; 1
    e1a6:	45 e3       	ldi	r20, 0x35	; 53
    e1a8:	50 e1       	ldi	r21, 0x10	; 16
    e1aa:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
    e1ae:	83 e0       	ldi	r24, 0x03	; 3
    e1b0:	61 e0       	ldi	r22, 0x01	; 1
    e1b2:	40 e2       	ldi	r20, 0x20	; 32
    e1b4:	50 e1       	ldi	r21, 0x10	; 16
    e1b6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				  TimDisplay=0;
    e1ba:	10 92 92 01 	sts	0x0192, r1
				  stSettingOperator=soDelayDisplaySaved;
    e1be:	8e e0       	ldi	r24, 0x0E	; 14
    e1c0:	16 c0       	rjmp	.+44     	; 0xe1ee <FSettingOperator+0x572>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e1c2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e1c4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e1c6:	82 e0       	ldi	r24, 0x02	; 2
    e1c8:	80 93 bc 01 	sts	0x01BC, r24
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
				  TimDisplay=0;
				  stSettingOperator=soDelayDisplaySaved;
			  }else {
			  system_beep(2);
		      TimDisplay=0;
    e1cc:	10 92 92 01 	sts	0x0192, r1
		      lcd_clear();
    e1d0:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		      lcd_printf(2,1,PSTR("      ERROR         "));
    e1d4:	82 e0       	ldi	r24, 0x02	; 2
    e1d6:	61 e0       	ldi	r22, 0x01	; 1
    e1d8:	4b e0       	ldi	r20, 0x0B	; 11
    e1da:	50 e1       	ldi	r21, 0x10	; 16
    e1dc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      lcd_printf(3,1,PSTR("Invalid New Password"));
    e1e0:	83 e0       	ldi	r24, 0x03	; 3
    e1e2:	61 e0       	ldi	r22, 0x01	; 1
    e1e4:	46 ef       	ldi	r20, 0xF6	; 246
    e1e6:	5f e0       	ldi	r21, 0x0F	; 15
    e1e8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      stSettingOperator=soDisplayInvalidPassword;
    e1ec:	8d e0       	ldi	r24, 0x0D	; 13
    e1ee:	80 93 1e 02 	sts	0x021E, r24
    e1f2:	24 c0       	rjmp	.+72     	; 0xe23c <FSettingOperator+0x5c0>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e1f4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e1f6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e1f8:	82 e0       	ldi	r24, 0x02	; 2
    e1fa:	80 93 bc 01 	sts	0x01BC, r24
		      stSettingOperator=soDisplayInvalidPassword;
			  }
		  }else {
		   //InvalidOld Password
		   system_beep(2);
		   TimDisplay=0;
    e1fe:	10 92 92 01 	sts	0x0192, r1
		   lcd_clear();
    e202:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		   lcd_printf(2,1,PSTR("      ERROR         "));
    e206:	82 e0       	ldi	r24, 0x02	; 2
    e208:	61 e0       	ldi	r22, 0x01	; 1
    e20a:	41 ee       	ldi	r20, 0xE1	; 225
    e20c:	5f e0       	ldi	r21, 0x0F	; 15
    e20e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		   lcd_printf(3,1,PSTR("Invalid Old Password"));
    e212:	83 e0       	ldi	r24, 0x03	; 3
    e214:	61 e0       	ldi	r22, 0x01	; 1
    e216:	4c ec       	ldi	r20, 0xCC	; 204
    e218:	5f e0       	ldi	r21, 0x0F	; 15
    e21a:	e6 cf       	rjmp	.-52     	; 0xe1e8 <FSettingOperator+0x56c>
		   stSettingOperator=soDisplayInvalidPassword;
		   }
	      break;
     case soDisplayInvalidPassword:
	      if (TimDisplay>6)stSettingOperator=soMenuOption;
    e21c:	80 91 92 01 	lds	r24, 0x0192
    e220:	87 30       	cpi	r24, 0x07	; 7
    e222:	60 f0       	brcs	.+24     	; 0xe23c <FSettingOperator+0x5c0>
    e224:	04 c0       	rjmp	.+8      	; 0xe22e <FSettingOperator+0x5b2>
	      break;
     case soDelayDisplaySaved:
	      if (TimDisplay>4)stSettingOperator=soMenuOption;
    e226:	80 91 92 01 	lds	r24, 0x0192
    e22a:	85 30       	cpi	r24, 0x05	; 5
    e22c:	38 f0       	brcs	.+14     	; 0xe23c <FSettingOperator+0x5c0>
    e22e:	10 92 1e 02 	sts	0x021E, r1
    e232:	04 c0       	rjmp	.+8      	; 0xe23c <FSettingOperator+0x5c0>
	      break;
	 case soExitSettingOperator:
	      stSettingOperator=soMenuOption;
    e234:	10 92 1e 02 	sts	0x021E, r1
    e238:	81 e0       	ldi	r24, 0x01	; 1
    e23a:	01 c0       	rjmp	.+2      	; 0xe23e <FSettingOperator+0x5c2>
    e23c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
    e23e:	e5 96       	adiw	r28, 0x35	; 53
    e240:	0f b6       	in	r0, 0x3f	; 63
    e242:	f8 94       	cli
    e244:	de bf       	out	0x3e, r29	; 62
    e246:	0f be       	out	0x3f, r0	; 63
    e248:	cd bf       	out	0x3d, r28	; 61
    e24a:	cf 91       	pop	r28
    e24c:	df 91       	pop	r29
    e24e:	1f 91       	pop	r17
    e250:	0f 91       	pop	r16
    e252:	ef 90       	pop	r14
    e254:	08 95       	ret

0000e256 <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
    e256:	6f 92       	push	r6
    e258:	7f 92       	push	r7
    e25a:	8f 92       	push	r8
    e25c:	9f 92       	push	r9
    e25e:	af 92       	push	r10
    e260:	bf 92       	push	r11
    e262:	cf 92       	push	r12
    e264:	df 92       	push	r13
    e266:	ef 92       	push	r14
    e268:	ff 92       	push	r15
    e26a:	0f 93       	push	r16
    e26c:	1f 93       	push	r17
    e26e:	df 93       	push	r29
    e270:	cf 93       	push	r28
    e272:	cd b7       	in	r28, 0x3d	; 61
    e274:	de b7       	in	r29, 0x3e	; 62
    e276:	a1 97       	sbiw	r28, 0x21	; 33
    e278:	0f b6       	in	r0, 0x3f	; 63
    e27a:	f8 94       	cli
    e27c:	de bf       	out	0x3e, r29	; 62
    e27e:	0f be       	out	0x3f, r0	; 63
    e280:	cd bf       	out	0x3d, r28	; 61
     char i;//,x,y;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
    e282:	80 91 21 02 	lds	r24, 0x0221
    e286:	83 30       	cpi	r24, 0x03	; 3
    e288:	09 f4       	brne	.+2      	; 0xe28c <FSettingProduct+0x36>
    e28a:	ff c0       	rjmp	.+510    	; 0xe48a <FSettingProduct+0x234>
    e28c:	84 30       	cpi	r24, 0x04	; 4
    e28e:	38 f4       	brcc	.+14     	; 0xe29e <FSettingProduct+0x48>
    e290:	81 30       	cpi	r24, 0x01	; 1
    e292:	09 f4       	brne	.+2      	; 0xe296 <FSettingProduct+0x40>
    e294:	72 c0       	rjmp	.+228    	; 0xe37a <FSettingProduct+0x124>
    e296:	82 30       	cpi	r24, 0x02	; 2
    e298:	08 f0       	brcs	.+2      	; 0xe29c <FSettingProduct+0x46>
    e29a:	82 c0       	rjmp	.+260    	; 0xe3a0 <FSettingProduct+0x14a>
    e29c:	0a c0       	rjmp	.+20     	; 0xe2b2 <FSettingProduct+0x5c>
    e29e:	85 30       	cpi	r24, 0x05	; 5
    e2a0:	09 f4       	brne	.+2      	; 0xe2a4 <FSettingProduct+0x4e>
    e2a2:	81 c1       	rjmp	.+770    	; 0xe5a6 <FSettingProduct+0x350>
    e2a4:	85 30       	cpi	r24, 0x05	; 5
    e2a6:	08 f4       	brcc	.+2      	; 0xe2aa <FSettingProduct+0x54>
    e2a8:	9e c1       	rjmp	.+828    	; 0xe5e6 <FSettingProduct+0x390>
    e2aa:	86 30       	cpi	r24, 0x06	; 6
    e2ac:	09 f0       	breq	.+2      	; 0xe2b0 <FSettingProduct+0x5a>
    e2ae:	c3 c1       	rjmp	.+902    	; 0xe636 <FSettingProduct+0x3e0>
    e2b0:	be c1       	rjmp	.+892    	; 0xe62e <FSettingProduct+0x3d8>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
    e2b2:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    e2b6:	5b eb       	ldi	r21, 0xBB	; 187
    e2b8:	c5 2e       	mov	r12, r21
    e2ba:	50 e0       	ldi	r21, 0x00	; 0
    e2bc:	d5 2e       	mov	r13, r21
    e2be:	41 e0       	ldi	r20, 0x01	; 1
    e2c0:	e4 2e       	mov	r14, r20
    e2c2:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e2c4:	4e 01       	movw	r8, r28
    e2c6:	08 94       	sec
    e2c8:	81 1c       	adc	r8, r1
    e2ca:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
    e2cc:	3e e0       	ldi	r19, 0x0E	; 14
    e2ce:	a3 2e       	mov	r10, r19
    e2d0:	b1 2c       	mov	r11, r1
    e2d2:	ac 0e       	add	r10, r28
    e2d4:	bd 1e       	adc	r11, r29
    e2d6:	26 ea       	ldi	r18, 0xA6	; 166
    e2d8:	62 2e       	mov	r6, r18
    e2da:	23 e1       	ldi	r18, 0x13	; 19
    e2dc:	72 2e       	mov	r7, r18
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
    e2de:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
    e2e0:	1e 2d       	mov	r17, r14
    e2e2:	11 50       	subi	r17, 0x01	; 1
    e2e4:	c4 01       	movw	r24, r8
    e2e6:	b6 01       	movw	r22, r12
    e2e8:	4d e0       	ldi	r20, 0x0D	; 13
    e2ea:	50 e0       	ldi	r21, 0x00	; 0
    e2ec:	22 ed       	ldi	r18, 0xD2	; 210
    e2ee:	33 e1       	ldi	r19, 0x13	; 19
    e2f0:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
    e2f4:	8d b7       	in	r24, 0x3d	; 61
    e2f6:	9e b7       	in	r25, 0x3e	; 62
    e2f8:	08 97       	sbiw	r24, 0x08	; 8
    e2fa:	0f b6       	in	r0, 0x3f	; 63
    e2fc:	f8 94       	cli
    e2fe:	9e bf       	out	0x3e, r25	; 62
    e300:	0f be       	out	0x3f, r0	; 63
    e302:	8d bf       	out	0x3d, r24	; 61
    e304:	ed b7       	in	r30, 0x3d	; 61
    e306:	fe b7       	in	r31, 0x3e	; 62
    e308:	31 96       	adiw	r30, 0x01	; 1
    e30a:	ad b7       	in	r26, 0x3d	; 61
    e30c:	be b7       	in	r27, 0x3e	; 62
    e30e:	12 96       	adiw	r26, 0x02	; 2
    e310:	bc 92       	st	X, r11
    e312:	ae 92       	st	-X, r10
    e314:	11 97       	sbiw	r26, 0x01	; 1
    e316:	73 82       	std	Z+3, r7	; 0x03
    e318:	62 82       	std	Z+2, r6	; 0x02
    e31a:	f5 82       	std	Z+5, r15	; 0x05
    e31c:	e4 82       	std	Z+4, r14	; 0x04
    e31e:	97 82       	std	Z+7, r9	; 0x07
    e320:	86 82       	std	Z+6, r8	; 0x06
    e322:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
    e326:	8d b7       	in	r24, 0x3d	; 61
    e328:	9e b7       	in	r25, 0x3e	; 62
    e32a:	08 96       	adiw	r24, 0x08	; 8
    e32c:	0f b6       	in	r0, 0x3f	; 63
    e32e:	f8 94       	cli
    e330:	9e bf       	out	0x3e, r25	; 62
    e332:	0f be       	out	0x3f, r0	; 63
    e334:	8d bf       	out	0x3d, r24	; 61
    e336:	61 2f       	mov	r22, r17
    e338:	66 95       	lsr	r22
    e33a:	66 95       	lsr	r22
    e33c:	60 9f       	mul	r22, r16
    e33e:	b0 01       	movw	r22, r0
    e340:	11 24       	eor	r1, r1
    e342:	6f 5f       	subi	r22, 0xFF	; 255
    e344:	13 70       	andi	r17, 0x03	; 3
    e346:	81 2f       	mov	r24, r17
    e348:	8f 5f       	subi	r24, 0xFF	; 255
    e34a:	a5 01       	movw	r20, r10
    e34c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    e350:	ad e0       	ldi	r26, 0x0D	; 13
    e352:	b0 e0       	ldi	r27, 0x00	; 0
    e354:	ca 0e       	add	r12, r26
    e356:	db 1e       	adc	r13, r27
    e358:	08 94       	sec
    e35a:	e1 1c       	adc	r14, r1
    e35c:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
    e35e:	b9 e0       	ldi	r27, 0x09	; 9
    e360:	cb 16       	cp	r12, r27
    e362:	b1 e0       	ldi	r27, 0x01	; 1
    e364:	db 06       	cpc	r13, r27
    e366:	09 f0       	breq	.+2      	; 0xe36a <FSettingProduct+0x114>
    e368:	bb cf       	rjmp	.-138    	; 0xe2e0 <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
    e36a:	84 e0       	ldi	r24, 0x04	; 4
    e36c:	6b e0       	ldi	r22, 0x0B	; 11
    e36e:	4f e9       	ldi	r20, 0x9F	; 159
    e370:	53 e1       	ldi	r21, 0x13	; 19
    e372:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          stMenuProduct=mpChangeProduct;
    e376:	81 e0       	ldi	r24, 0x01	; 1
    e378:	54 c1       	rjmp	.+680    	; 0xe622 <FSettingProduct+0x3cc>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
    e37a:	81 e0       	ldi	r24, 0x01	; 1
    e37c:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    e380:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
    e382:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    e386:	81 53       	subi	r24, 0x31	; 49
    e388:	86 30       	cpi	r24, 0x06	; 6
    e38a:	28 f4       	brcc	.+10     	; 0xe396 <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
    e38c:	80 93 20 02 	sts	0x0220, r24
			  stMenuProduct=mpDispPrice;
    e390:	82 e0       	ldi	r24, 0x02	; 2
    e392:	80 93 21 02 	sts	0x0221, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
    e396:	17 3e       	cpi	r17, 0xE7	; 231
    e398:	09 f0       	breq	.+2      	; 0xe39c <FSettingProduct+0x146>
    e39a:	4d c1       	rjmp	.+666    	; 0xe636 <FSettingProduct+0x3e0>
		      stMenuProduct=mpExitMenuProduct;
    e39c:	86 e0       	ldi	r24, 0x06	; 6
    e39e:	41 c1       	rjmp	.+642    	; 0xe622 <FSettingProduct+0x3cc>
    e3a0:	60 91 20 02 	lds	r22, 0x0220
    e3a4:	8d e0       	ldi	r24, 0x0D	; 13
    e3a6:	68 9f       	mul	r22, r24
    e3a8:	b0 01       	movw	r22, r0
    e3aa:	11 24       	eor	r1, r1
    e3ac:	65 54       	subi	r22, 0x45	; 69
    e3ae:	7f 4f       	sbci	r23, 0xFF	; 255
    e3b0:	7e 01       	movw	r14, r28
    e3b2:	08 94       	sec
    e3b4:	e1 1c       	adc	r14, r1
    e3b6:	f1 1c       	adc	r15, r1
    e3b8:	c7 01       	movw	r24, r14
    e3ba:	4d e0       	ldi	r20, 0x0D	; 13
    e3bc:	50 e0       	ldi	r21, 0x00	; 0
    e3be:	22 ed       	ldi	r18, 0xD2	; 210
    e3c0:	33 e1       	ldi	r19, 0x13	; 19
    e3c2:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
    e3c6:	9e e9       	ldi	r25, 0x9E	; 158
    e3c8:	c9 2e       	mov	r12, r25
    e3ca:	95 e0       	ldi	r25, 0x05	; 5
    e3cc:	d9 2e       	mov	r13, r25
    e3ce:	60 91 20 02 	lds	r22, 0x0220
    e3d2:	89 e0       	ldi	r24, 0x09	; 9
    e3d4:	68 9f       	mul	r22, r24
    e3d6:	b0 01       	movw	r22, r0
    e3d8:	11 24       	eor	r1, r1
    e3da:	6b 57       	subi	r22, 0x7B	; 123
    e3dc:	7f 4f       	sbci	r23, 0xFF	; 255
    e3de:	c6 01       	movw	r24, r12
    e3e0:	49 e0       	ldi	r20, 0x09	; 9
    e3e2:	50 e0       	ldi	r21, 0x00	; 0
    e3e4:	22 ed       	ldi	r18, 0xD2	; 210
    e3e6:	33 e1       	ldi	r19, 0x13	; 19
    e3e8:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    e3ec:	00 d0       	rcall	.+0      	; 0xe3ee <FSettingProduct+0x198>
    e3ee:	00 d0       	rcall	.+0      	; 0xe3f0 <FSettingProduct+0x19a>
    e3f0:	00 d0       	rcall	.+0      	; 0xe3f2 <FSettingProduct+0x19c>
    e3f2:	ed b7       	in	r30, 0x3d	; 61
    e3f4:	fe b7       	in	r31, 0x3e	; 62
    e3f6:	31 96       	adiw	r30, 0x01	; 1
    e3f8:	8e 01       	movw	r16, r28
    e3fa:	02 5f       	subi	r16, 0xF2	; 242
    e3fc:	1f 4f       	sbci	r17, 0xFF	; 255
    e3fe:	ad b7       	in	r26, 0x3d	; 61
    e400:	be b7       	in	r27, 0x3e	; 62
    e402:	12 96       	adiw	r26, 0x02	; 2
    e404:	1c 93       	st	X, r17
    e406:	0e 93       	st	-X, r16
    e408:	11 97       	sbiw	r26, 0x01	; 1
    e40a:	8a e9       	ldi	r24, 0x9A	; 154
    e40c:	93 e1       	ldi	r25, 0x13	; 19
    e40e:	93 83       	std	Z+3, r25	; 0x03
    e410:	82 83       	std	Z+2, r24	; 0x02
    e412:	f5 82       	std	Z+5, r15	; 0x05
    e414:	e4 82       	std	Z+4, r14	; 0x04
    e416:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
    e41a:	8d b7       	in	r24, 0x3d	; 61
    e41c:	9e b7       	in	r25, 0x3e	; 62
    e41e:	06 96       	adiw	r24, 0x06	; 6
    e420:	0f b6       	in	r0, 0x3f	; 63
    e422:	f8 94       	cli
    e424:	9e bf       	out	0x3e, r25	; 62
    e426:	0f be       	out	0x3f, r0	; 63
    e428:	8d bf       	out	0x3d, r24	; 61
    e42a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    e42e:	81 e0       	ldi	r24, 0x01	; 1
    e430:	61 e0       	ldi	r22, 0x01	; 1
    e432:	a8 01       	movw	r20, r16
    e434:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
    e438:	00 d0       	rcall	.+0      	; 0xe43a <FSettingProduct+0x1e4>
    e43a:	00 d0       	rcall	.+0      	; 0xe43c <FSettingProduct+0x1e6>
    e43c:	00 d0       	rcall	.+0      	; 0xe43e <FSettingProduct+0x1e8>
    e43e:	ed b7       	in	r30, 0x3d	; 61
    e440:	fe b7       	in	r31, 0x3e	; 62
    e442:	31 96       	adiw	r30, 0x01	; 1
    e444:	ad b7       	in	r26, 0x3d	; 61
    e446:	be b7       	in	r27, 0x3e	; 62
    e448:	12 96       	adiw	r26, 0x02	; 2
    e44a:	1c 93       	st	X, r17
    e44c:	0e 93       	st	-X, r16
    e44e:	11 97       	sbiw	r26, 0x01	; 1
    e450:	85 e9       	ldi	r24, 0x95	; 149
    e452:	93 e1       	ldi	r25, 0x13	; 19
    e454:	93 83       	std	Z+3, r25	; 0x03
    e456:	82 83       	std	Z+2, r24	; 0x02
    e458:	d5 82       	std	Z+5, r13	; 0x05
    e45a:	c4 82       	std	Z+4, r12	; 0x04
    e45c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(2,1,lcdteks);
    e460:	8d b7       	in	r24, 0x3d	; 61
    e462:	9e b7       	in	r25, 0x3e	; 62
    e464:	06 96       	adiw	r24, 0x06	; 6
    e466:	0f b6       	in	r0, 0x3f	; 63
    e468:	f8 94       	cli
    e46a:	9e bf       	out	0x3e, r25	; 62
    e46c:	0f be       	out	0x3f, r0	; 63
    e46e:	8d bf       	out	0x3d, r24	; 61
    e470:	82 e0       	ldi	r24, 0x02	; 2
    e472:	61 e0       	ldi	r22, 0x01	; 1
    e474:	a8 01       	movw	r20, r16
    e476:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
    e47a:	84 e0       	ldi	r24, 0x04	; 4
    e47c:	61 e0       	ldi	r22, 0x01	; 1
    e47e:	47 e8       	ldi	r20, 0x87	; 135
    e480:	53 e1       	ldi	r21, 0x13	; 19
    e482:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stMenuProduct=mpIsEdit;
    e486:	83 e0       	ldi	r24, 0x03	; 3
    e488:	cc c0       	rjmp	.+408    	; 0xe622 <FSettingProduct+0x3cc>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
    e48a:	81 e0       	ldi	r24, 0x01	; 1
    e48c:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    e490:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  if (KeyChar=='*'){
    e494:	8a 32       	cpi	r24, 0x2A	; 42
    e496:	09 f4       	brne	.+2      	; 0xe49a <FSettingProduct+0x244>
    e498:	a3 c0       	rjmp	.+326    	; 0xe5e0 <FSettingProduct+0x38a>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
    e49a:	81 33       	cpi	r24, 0x31	; 49
    e49c:	09 f0       	breq	.+2      	; 0xe4a0 <FSettingProduct+0x24a>
    e49e:	4c c0       	rjmp	.+152    	; 0xe538 <FSettingProduct+0x2e2>
    e4a0:	60 91 20 02 	lds	r22, 0x0220
    e4a4:	8d e0       	ldi	r24, 0x0D	; 13
    e4a6:	68 9f       	mul	r22, r24
    e4a8:	b0 01       	movw	r22, r0
    e4aa:	11 24       	eor	r1, r1
    e4ac:	65 54       	subi	r22, 0x45	; 69
    e4ae:	7f 4f       	sbci	r23, 0xFF	; 255
    e4b0:	8e 01       	movw	r16, r28
    e4b2:	0f 5f       	subi	r16, 0xFF	; 255
    e4b4:	1f 4f       	sbci	r17, 0xFF	; 255
    e4b6:	c8 01       	movw	r24, r16
    e4b8:	4d e0       	ldi	r20, 0x0D	; 13
    e4ba:	50 e0       	ldi	r21, 0x00	; 0
    e4bc:	22 ed       	ldi	r18, 0xD2	; 210
    e4be:	33 e1       	ldi	r19, 0x13	; 19
    e4c0:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
    e4c4:	00 d0       	rcall	.+0      	; 0xe4c6 <FSettingProduct+0x270>
    e4c6:	00 d0       	rcall	.+0      	; 0xe4c8 <FSettingProduct+0x272>
    e4c8:	00 d0       	rcall	.+0      	; 0xe4ca <FSettingProduct+0x274>
    e4ca:	ed b7       	in	r30, 0x3d	; 61
    e4cc:	fe b7       	in	r31, 0x3e	; 62
    e4ce:	31 96       	adiw	r30, 0x01	; 1
    e4d0:	8e e0       	ldi	r24, 0x0E	; 14
    e4d2:	e8 2e       	mov	r14, r24
    e4d4:	f1 2c       	mov	r15, r1
    e4d6:	ec 0e       	add	r14, r28
    e4d8:	fd 1e       	adc	r15, r29
    e4da:	ad b7       	in	r26, 0x3d	; 61
    e4dc:	be b7       	in	r27, 0x3e	; 62
    e4de:	12 96       	adiw	r26, 0x02	; 2
    e4e0:	fc 92       	st	X, r15
    e4e2:	ee 92       	st	-X, r14
    e4e4:	11 97       	sbiw	r26, 0x01	; 1
    e4e6:	80 e8       	ldi	r24, 0x80	; 128
    e4e8:	93 e1       	ldi	r25, 0x13	; 19
    e4ea:	93 83       	std	Z+3, r25	; 0x03
    e4ec:	82 83       	std	Z+2, r24	; 0x02
    e4ee:	15 83       	std	Z+5, r17	; 0x05
    e4f0:	04 83       	std	Z+4, r16	; 0x04
    e4f2:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
    e4f6:	8d b7       	in	r24, 0x3d	; 61
    e4f8:	9e b7       	in	r25, 0x3e	; 62
    e4fa:	06 96       	adiw	r24, 0x06	; 6
    e4fc:	0f b6       	in	r0, 0x3f	; 63
    e4fe:	f8 94       	cli
    e500:	9e bf       	out	0x3e, r25	; 62
    e502:	0f be       	out	0x3f, r0	; 63
    e504:	8d bf       	out	0x3d, r24	; 61
    e506:	81 e0       	ldi	r24, 0x01	; 1
    e508:	61 e0       	ldi	r22, 0x01	; 1
    e50a:	4b e6       	ldi	r20, 0x6B	; 107
    e50c:	53 e1       	ldi	r21, 0x13	; 19
    e50e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		       lcd_print(2,1,lcdteks);
    e512:	82 e0       	ldi	r24, 0x02	; 2
    e514:	61 e0       	ldi	r22, 0x01	; 1
    e516:	a7 01       	movw	r20, r14
    e518:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
    e51c:	83 e0       	ldi	r24, 0x03	; 3
    e51e:	61 e0       	ldi	r22, 0x01	; 1
    e520:	45 e6       	ldi	r20, 0x65	; 101
    e522:	53 e1       	ldi	r21, 0x13	; 19
    e524:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
    e528:	84 e0       	ldi	r24, 0x04	; 4
    e52a:	61 e0       	ldi	r22, 0x01	; 1
    e52c:	40 e5       	ldi	r20, 0x50	; 80
    e52e:	53 e1       	ldi	r21, 0x13	; 19
    e530:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      stMenuProduct=mpEditProductName;
    e534:	85 e0       	ldi	r24, 0x05	; 5
    e536:	75 c0       	rjmp	.+234    	; 0xe622 <FSettingProduct+0x3cc>
		  }else
		  if (KeyChar=='2'){
    e538:	82 33       	cpi	r24, 0x32	; 50
    e53a:	09 f0       	breq	.+2      	; 0xe53e <FSettingProduct+0x2e8>
    e53c:	7c c0       	rjmp	.+248    	; 0xe636 <FSettingProduct+0x3e0>
		      uiResult=USER_NONE;
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
    e53e:	00 d0       	rcall	.+0      	; 0xe540 <FSettingProduct+0x2ea>
    e540:	00 d0       	rcall	.+0      	; 0xe542 <FSettingProduct+0x2ec>
    e542:	00 d0       	rcall	.+0      	; 0xe544 <FSettingProduct+0x2ee>
    e544:	ed b7       	in	r30, 0x3d	; 61
    e546:	fe b7       	in	r31, 0x3e	; 62
    e548:	31 96       	adiw	r30, 0x01	; 1
    e54a:	8e 01       	movw	r16, r28
    e54c:	02 5f       	subi	r16, 0xF2	; 242
    e54e:	1f 4f       	sbci	r17, 0xFF	; 255
    e550:	ad b7       	in	r26, 0x3d	; 61
    e552:	be b7       	in	r27, 0x3e	; 62
    e554:	12 96       	adiw	r26, 0x02	; 2
    e556:	1c 93       	st	X, r17
    e558:	0e 93       	st	-X, r16
    e55a:	11 97       	sbiw	r26, 0x01	; 1
    e55c:	89 e4       	ldi	r24, 0x49	; 73
    e55e:	93 e1       	ldi	r25, 0x13	; 19
    e560:	93 83       	std	Z+3, r25	; 0x03
    e562:	82 83       	std	Z+2, r24	; 0x02
    e564:	8e e9       	ldi	r24, 0x9E	; 158
    e566:	95 e0       	ldi	r25, 0x05	; 5
    e568:	95 83       	std	Z+5, r25	; 0x05
    e56a:	84 83       	std	Z+4, r24	; 0x04
    e56c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		       lcd_print(2,1,lcdteks);
    e570:	8d b7       	in	r24, 0x3d	; 61
    e572:	9e b7       	in	r25, 0x3e	; 62
    e574:	06 96       	adiw	r24, 0x06	; 6
    e576:	0f b6       	in	r0, 0x3f	; 63
    e578:	f8 94       	cli
    e57a:	9e bf       	out	0x3e, r25	; 62
    e57c:	0f be       	out	0x3f, r0	; 63
    e57e:	8d bf       	out	0x3d, r24	; 61
    e580:	82 e0       	ldi	r24, 0x02	; 2
    e582:	61 e0       	ldi	r22, 0x01	; 1
    e584:	a8 01       	movw	r20, r16
    e586:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
    e58a:	83 e0       	ldi	r24, 0x03	; 3
    e58c:	61 e0       	ldi	r22, 0x01	; 1
    e58e:	43 e4       	ldi	r20, 0x43	; 67
    e590:	53 e1       	ldi	r21, 0x13	; 19
    e592:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
    e596:	84 e0       	ldi	r24, 0x04	; 4
    e598:	61 e0       	ldi	r22, 0x01	; 1
    e59a:	4e e2       	ldi	r20, 0x2E	; 46
    e59c:	53 e1       	ldi	r21, 0x13	; 19
    e59e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      stMenuProduct=mpEditPrice;
    e5a2:	84 e0       	ldi	r24, 0x04	; 4
    e5a4:	3e c0       	rjmp	.+124    	; 0xe622 <FSettingProduct+0x3cc>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
    e5a6:	83 e0       	ldi	r24, 0x03	; 3
    e5a8:	63 e0       	ldi	r22, 0x03	; 3
    e5aa:	45 e0       	ldi	r20, 0x05	; 5
    e5ac:	2c e0       	ldi	r18, 0x0C	; 12
    e5ae:	38 e0       	ldi	r19, 0x08	; 8
    e5b0:	00 e0       	ldi	r16, 0x00	; 0
    e5b2:	10 e0       	ldi	r17, 0x00	; 0
    e5b4:	ba e0       	ldi	r27, 0x0A	; 10
    e5b6:	eb 2e       	mov	r14, r27
    e5b8:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  if (uiResult==USER_OK){
    e5bc:	83 30       	cpi	r24, 0x03	; 3
    e5be:	a1 f5       	brne	.+104    	; 0xe628 <FSettingProduct+0x3d2>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    e5c0:	80 91 20 02 	lds	r24, 0x0220
    e5c4:	2d e0       	ldi	r18, 0x0D	; 13
    e5c6:	82 9f       	mul	r24, r18
    e5c8:	c0 01       	movw	r24, r0
    e5ca:	11 24       	eor	r1, r1
    e5cc:	85 54       	subi	r24, 0x45	; 69
    e5ce:	9f 4f       	sbci	r25, 0xFF	; 255
    e5d0:	6c e0       	ldi	r22, 0x0C	; 12
    e5d2:	78 e0       	ldi	r23, 0x08	; 8
    e5d4:	4d e0       	ldi	r20, 0x0D	; 13
    e5d6:	50 e0       	ldi	r21, 0x00	; 0
    e5d8:	2a ed       	ldi	r18, 0xDA	; 218
    e5da:	33 e1       	ldi	r19, 0x13	; 19
    e5dc:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
    e5e0:	10 92 21 02 	sts	0x0221, r1
    e5e4:	28 c0       	rjmp	.+80     	; 0xe636 <FSettingProduct+0x3e0>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
    e5e6:	81 e0       	ldi	r24, 0x01	; 1
    e5e8:	63 e0       	ldi	r22, 0x03	; 3
    e5ea:	45 e0       	ldi	r20, 0x05	; 5
    e5ec:	2e e9       	ldi	r18, 0x9E	; 158
    e5ee:	35 e0       	ldi	r19, 0x05	; 5
    e5f0:	00 e0       	ldi	r16, 0x00	; 0
    e5f2:	10 e0       	ldi	r17, 0x00	; 0
    e5f4:	a7 e0       	ldi	r26, 0x07	; 7
    e5f6:	ea 2e       	mov	r14, r26
    e5f8:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  if (uiResult==USER_OK){
    e5fc:	83 30       	cpi	r24, 0x03	; 3
    e5fe:	a1 f4       	brne	.+40     	; 0xe628 <FSettingProduct+0x3d2>
    e600:	80 91 20 02 	lds	r24, 0x0220
    e604:	29 e0       	ldi	r18, 0x09	; 9
    e606:	82 9f       	mul	r24, r18
    e608:	c0 01       	movw	r24, r0
    e60a:	11 24       	eor	r1, r1
    e60c:	8b 57       	subi	r24, 0x7B	; 123
    e60e:	9f 4f       	sbci	r25, 0xFF	; 255
    e610:	6e e9       	ldi	r22, 0x9E	; 158
    e612:	75 e0       	ldi	r23, 0x05	; 5
    e614:	49 e0       	ldi	r20, 0x09	; 9
    e616:	50 e0       	ldi	r21, 0x00	; 0
    e618:	2a ed       	ldi	r18, 0xDA	; 218
    e61a:	33 e1       	ldi	r19, 0x13	; 19
    e61c:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
    e620:	82 e0       	ldi	r24, 0x02	; 2
    e622:	80 93 21 02 	sts	0x0221, r24
    e626:	07 c0       	rjmp	.+14     	; 0xe636 <FSettingProduct+0x3e0>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
    e628:	81 30       	cpi	r24, 0x01	; 1
    e62a:	29 f4       	brne	.+10     	; 0xe636 <FSettingProduct+0x3e0>
    e62c:	f9 cf       	rjmp	.-14     	; 0xe620 <FSettingProduct+0x3ca>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
    e62e:	10 92 21 02 	sts	0x0221, r1
    e632:	81 e0       	ldi	r24, 0x01	; 1
    e634:	01 c0       	rjmp	.+2      	; 0xe638 <FSettingProduct+0x3e2>
    e636:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    e638:	a1 96       	adiw	r28, 0x21	; 33
    e63a:	0f b6       	in	r0, 0x3f	; 63
    e63c:	f8 94       	cli
    e63e:	de bf       	out	0x3e, r29	; 62
    e640:	0f be       	out	0x3f, r0	; 63
    e642:	cd bf       	out	0x3d, r28	; 61
    e644:	cf 91       	pop	r28
    e646:	df 91       	pop	r29
    e648:	1f 91       	pop	r17
    e64a:	0f 91       	pop	r16
    e64c:	ff 90       	pop	r15
    e64e:	ef 90       	pop	r14
    e650:	df 90       	pop	r13
    e652:	cf 90       	pop	r12
    e654:	bf 90       	pop	r11
    e656:	af 90       	pop	r10
    e658:	9f 90       	pop	r9
    e65a:	8f 90       	pop	r8
    e65c:	7f 90       	pop	r7
    e65e:	6f 90       	pop	r6
    e660:	08 95       	ret

0000e662 <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
    e662:	ef 92       	push	r14
    e664:	0f 93       	push	r16
    e666:	1f 93       	push	r17
    e668:	df 93       	push	r29
    e66a:	cf 93       	push	r28
    e66c:	cd b7       	in	r28, 0x3d	; 61
    e66e:	de b7       	in	r29, 0x3e	; 62
    e670:	c6 54       	subi	r28, 0x46	; 70
    e672:	d0 40       	sbci	r29, 0x00	; 0
    e674:	0f b6       	in	r0, 0x3f	; 63
    e676:	f8 94       	cli
    e678:	de bf       	out	0x3e, r29	; 62
    e67a:	0f be       	out	0x3f, r0	; 63
    e67c:	cd bf       	out	0x3d, r28	; 61
	 char strHeaderFooter[50];
	 char KeyChar;
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
    e67e:	80 91 44 02 	lds	r24, 0x0244
    e682:	84 30       	cpi	r24, 0x04	; 4
    e684:	09 f4       	brne	.+2      	; 0xe688 <FMenuSettingFooter+0x26>
    e686:	3b c1       	rjmp	.+630    	; 0xe8fe <FMenuSettingFooter+0x29c>
    e688:	85 30       	cpi	r24, 0x05	; 5
    e68a:	40 f4       	brcc	.+16     	; 0xe69c <FMenuSettingFooter+0x3a>
    e68c:	81 30       	cpi	r24, 0x01	; 1
    e68e:	79 f1       	breq	.+94     	; 0xe6ee <FMenuSettingFooter+0x8c>
    e690:	81 30       	cpi	r24, 0x01	; 1
    e692:	88 f0       	brcs	.+34     	; 0xe6b6 <FMenuSettingFooter+0x54>
    e694:	82 30       	cpi	r24, 0x02	; 2
    e696:	09 f0       	breq	.+2      	; 0xe69a <FMenuSettingFooter+0x38>
    e698:	7f c1       	rjmp	.+766    	; 0xe998 <FMenuSettingFooter+0x336>
    e69a:	74 c0       	rjmp	.+232    	; 0xe784 <FMenuSettingFooter+0x122>
    e69c:	86 30       	cpi	r24, 0x06	; 6
    e69e:	09 f4       	brne	.+2      	; 0xe6a2 <FMenuSettingFooter+0x40>
    e6a0:	d3 c0       	rjmp	.+422    	; 0xe848 <FMenuSettingFooter+0x1e6>
    e6a2:	86 30       	cpi	r24, 0x06	; 6
    e6a4:	08 f4       	brcc	.+2      	; 0xe6a8 <FMenuSettingFooter+0x46>
    e6a6:	bd c0       	rjmp	.+378    	; 0xe822 <FMenuSettingFooter+0x1c0>
    e6a8:	87 30       	cpi	r24, 0x07	; 7
    e6aa:	09 f4       	brne	.+2      	; 0xe6ae <FMenuSettingFooter+0x4c>
    e6ac:	37 c1       	rjmp	.+622    	; 0xe91c <FMenuSettingFooter+0x2ba>
    e6ae:	88 30       	cpi	r24, 0x08	; 8
    e6b0:	09 f0       	breq	.+2      	; 0xe6b4 <FMenuSettingFooter+0x52>
    e6b2:	72 c1       	rjmp	.+740    	; 0xe998 <FMenuSettingFooter+0x336>
    e6b4:	6d c1       	rjmp	.+730    	; 0xe990 <FMenuSettingFooter+0x32e>
	 case shInitHeader:
	      lcd_clear();
    e6b6:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
    e6ba:	81 e0       	ldi	r24, 0x01	; 1
    e6bc:	61 e0       	ldi	r22, 0x01	; 1
    e6be:	4d e9       	ldi	r20, 0x9D	; 157
    e6c0:	55 e1       	ldi	r21, 0x15	; 21
    e6c2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
    e6c6:	82 e0       	ldi	r24, 0x02	; 2
    e6c8:	61 e0       	ldi	r22, 0x01	; 1
    e6ca:	48 e8       	ldi	r20, 0x88	; 136
    e6cc:	55 e1       	ldi	r21, 0x15	; 21
    e6ce:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
    e6d2:	83 e0       	ldi	r24, 0x03	; 3
    e6d4:	61 e0       	ldi	r22, 0x01	; 1
    e6d6:	43 e7       	ldi	r20, 0x73	; 115
    e6d8:	55 e1       	ldi	r21, 0x15	; 21
    e6da:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
    e6de:	84 e0       	ldi	r24, 0x04	; 4
    e6e0:	61 e0       	ldi	r22, 0x01	; 1
    e6e2:	4e e5       	ldi	r20, 0x5E	; 94
    e6e4:	55 e1       	ldi	r21, 0x15	; 21
    e6e6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
    e6ea:	81 e0       	ldi	r24, 0x01	; 1
    e6ec:	10 c1       	rjmp	.+544    	; 0xe90e <FMenuSettingFooter+0x2ac>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
    e6ee:	81 e0       	ldi	r24, 0x01	; 1
    e6f0:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    e6f4:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    e6f8:	e8 2e       	mov	r14, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    e6fa:	81 53       	subi	r24, 0x31	; 49
    e6fc:	86 30       	cpi	r24, 0x06	; 6
    e6fe:	e0 f5       	brcc	.+120    	; 0xe778 <FMenuSettingFooter+0x116>
		       HeaderIdx=KeyChar-'1';//
    e700:	80 93 43 02 	sts	0x0243, r24
			   lcd_clear();
    e704:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
    e708:	00 d0       	rcall	.+0      	; 0xe70a <FMenuSettingFooter+0xa8>
    e70a:	00 d0       	rcall	.+0      	; 0xe70c <FMenuSettingFooter+0xaa>
    e70c:	00 d0       	rcall	.+0      	; 0xe70e <FMenuSettingFooter+0xac>
    e70e:	ed b7       	in	r30, 0x3d	; 61
    e710:	fe b7       	in	r31, 0x3e	; 62
    e712:	31 96       	adiw	r30, 0x01	; 1
    e714:	8e 01       	movw	r16, r28
    e716:	0f 5f       	subi	r16, 0xFF	; 255
    e718:	1f 4f       	sbci	r17, 0xFF	; 255
    e71a:	ad b7       	in	r26, 0x3d	; 61
    e71c:	be b7       	in	r27, 0x3e	; 62
    e71e:	12 96       	adiw	r26, 0x02	; 2
    e720:	1c 93       	st	X, r17
    e722:	0e 93       	st	-X, r16
    e724:	11 97       	sbiw	r26, 0x01	; 1
    e726:	8f e4       	ldi	r24, 0x4F	; 79
    e728:	95 e1       	ldi	r25, 0x15	; 21
    e72a:	93 83       	std	Z+3, r25	; 0x03
    e72c:	82 83       	std	Z+2, r24	; 0x02
    e72e:	80 91 43 02 	lds	r24, 0x0243
    e732:	90 e0       	ldi	r25, 0x00	; 0
    e734:	01 96       	adiw	r24, 0x01	; 1
    e736:	95 83       	std	Z+5, r25	; 0x05
    e738:	84 83       	std	Z+4, r24	; 0x04
    e73a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			   lcd_print(1,1,lcdteks);
    e73e:	8d b7       	in	r24, 0x3d	; 61
    e740:	9e b7       	in	r25, 0x3e	; 62
    e742:	06 96       	adiw	r24, 0x06	; 6
    e744:	0f b6       	in	r0, 0x3f	; 63
    e746:	f8 94       	cli
    e748:	9e bf       	out	0x3e, r25	; 62
    e74a:	0f be       	out	0x3f, r0	; 63
    e74c:	8d bf       	out	0x3d, r24	; 61
    e74e:	81 e0       	ldi	r24, 0x01	; 1
    e750:	61 e0       	ldi	r22, 0x01	; 1
    e752:	a8 01       	movw	r20, r16
    e754:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
    e758:	84 e0       	ldi	r24, 0x04	; 4
    e75a:	61 e0       	ldi	r22, 0x01	; 1
    e75c:	40 e4       	ldi	r20, 0x40	; 64
    e75e:	55 e1       	ldi	r21, 0x15	; 21
    e760:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    e764:	ec ee       	ldi	r30, 0xEC	; 236
    e766:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    e768:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    e76a:	95 e0       	ldi	r25, 0x05	; 5
    e76c:	ed 37       	cpi	r30, 0x7D	; 125
    e76e:	f9 07       	cpc	r31, r25
    e770:	d9 f7       	brne	.-10     	; 0xe768 <FMenuSettingFooter+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
    e772:	82 e0       	ldi	r24, 0x02	; 2
    e774:	80 93 44 02 	sts	0x0244, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
    e778:	aa e2       	ldi	r26, 0x2A	; 42
    e77a:	ea 16       	cp	r14, r26
    e77c:	09 f0       	breq	.+2      	; 0xe780 <FMenuSettingFooter+0x11e>
    e77e:	0c c1       	rjmp	.+536    	; 0xe998 <FMenuSettingFooter+0x336>
    e780:	88 e0       	ldi	r24, 0x08	; 8
    e782:	c5 c0       	rjmp	.+394    	; 0xe90e <FMenuSettingFooter+0x2ac>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
    e784:	83 e0       	ldi	r24, 0x03	; 3
    e786:	62 e0       	ldi	r22, 0x02	; 2
    e788:	41 e0       	ldi	r20, 0x01	; 1
    e78a:	2c ee       	ldi	r18, 0xEC	; 236
    e78c:	33 e0       	ldi	r19, 0x03	; 3
    e78e:	00 e0       	ldi	r16, 0x00	; 0
    e790:	10 e0       	ldi	r17, 0x00	; 0
    e792:	78 e2       	ldi	r23, 0x28	; 40
    e794:	e7 2e       	mov	r14, r23
    e796:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  if (uiResult==USER_OK){
    e79a:	83 30       	cpi	r24, 0x03	; 3
    e79c:	f1 f5       	brne	.+124    	; 0xe81a <FMenuSettingFooter+0x1b8>
			  lcd_clear();
    e79e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
    e7a2:	8c ee       	ldi	r24, 0xEC	; 236
    e7a4:	93 e0       	ldi	r25, 0x03	; 3
    e7a6:	68 e2       	ldi	r22, 0x28	; 40
    e7a8:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
    e7ac:	20 e0       	ldi	r18, 0x00	; 0
    e7ae:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    e7b0:	f9 01       	movw	r30, r18
    e7b2:	ee 56       	subi	r30, 0x6E	; 110
    e7b4:	f7 4f       	sbci	r31, 0xF7	; 247
    e7b6:	d9 01       	movw	r26, r18
    e7b8:	a4 51       	subi	r26, 0x14	; 20
    e7ba:	bc 4f       	sbci	r27, 0xFC	; 252
    e7bc:	8c 91       	ld	r24, X
    e7be:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    e7c0:	2f 5f       	subi	r18, 0xFF	; 255
    e7c2:	3f 4f       	sbci	r19, 0xFF	; 255
    e7c4:	24 31       	cpi	r18, 0x14	; 20
    e7c6:	31 05       	cpc	r19, r1
    e7c8:	99 f7       	brne	.-26     	; 0xe7b0 <FMenuSettingFooter+0x14e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    e7ca:	10 92 a6 08 	sts	0x08A6, r1
    e7ce:	e0 e0       	ldi	r30, 0x00	; 0
    e7d0:	f4 e0       	ldi	r31, 0x04	; 4
    e7d2:	a3 ea       	ldi	r26, 0xA3	; 163
    e7d4:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    e7d6:	81 91       	ld	r24, Z+
    e7d8:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    e7da:	84 e0       	ldi	r24, 0x04	; 4
    e7dc:	e4 31       	cpi	r30, 0x14	; 20
    e7de:	f8 07       	cpc	r31, r24
    e7e0:	d1 f7       	brne	.-12     	; 0xe7d6 <FMenuSettingFooter+0x174>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    e7e2:	10 92 b7 07 	sts	0x07B7, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
    e7e6:	81 e0       	ldi	r24, 0x01	; 1
    e7e8:	61 e0       	ldi	r22, 0x01	; 1
    e7ea:	42 e9       	ldi	r20, 0x92	; 146
    e7ec:	58 e0       	ldi	r21, 0x08	; 8
    e7ee:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
    e7f2:	82 e0       	ldi	r24, 0x02	; 2
    e7f4:	61 e0       	ldi	r22, 0x01	; 1
    e7f6:	43 ea       	ldi	r20, 0xA3	; 163
    e7f8:	57 e0       	ldi	r21, 0x07	; 7
    e7fa:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
    e7fe:	83 e0       	ldi	r24, 0x03	; 3
    e800:	61 e0       	ldi	r22, 0x01	; 1
    e802:	42 e3       	ldi	r20, 0x32	; 50
    e804:	55 e1       	ldi	r21, 0x15	; 21
    e806:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
    e80a:	84 e0       	ldi	r24, 0x04	; 4
    e80c:	61 e0       	ldi	r22, 0x01	; 1
    e80e:	44 e2       	ldi	r20, 0x24	; 36
    e810:	55 e1       	ldi	r21, 0x15	; 21
    e812:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
    e816:	85 e0       	ldi	r24, 0x05	; 5
    e818:	7a c0       	rjmp	.+244    	; 0xe90e <FMenuSettingFooter+0x2ac>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
    e81a:	81 30       	cpi	r24, 0x01	; 1
    e81c:	09 f0       	breq	.+2      	; 0xe820 <FMenuSettingFooter+0x1be>
    e81e:	bc c0       	rjmp	.+376    	; 0xe998 <FMenuSettingFooter+0x336>
    e820:	b4 c0       	rjmp	.+360    	; 0xe98a <FMenuSettingFooter+0x328>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
    e822:	81 e0       	ldi	r24, 0x01	; 1
    e824:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    e828:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
          if(KeyChar=='#'){
    e82c:	83 32       	cpi	r24, 0x23	; 35
    e82e:	39 f4       	brne	.+14     	; 0xe83e <FMenuSettingFooter+0x1dc>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
    e830:	8c ee       	ldi	r24, 0xEC	; 236
    e832:	93 e0       	ldi	r25, 0x03	; 3
    e834:	68 e2       	ldi	r22, 0x28	; 40
    e836:	70 e0       	ldi	r23, 0x00	; 0
    e838:	0e 94 e1 32 	call	0x65c2	; 0x65c2 <StrAlignCenter>
    e83c:	03 c0       	rjmp	.+6      	; 0xe844 <FMenuSettingFooter+0x1e2>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
    e83e:	8a 32       	cpi	r24, 0x2A	; 42
    e840:	09 f0       	breq	.+2      	; 0xe844 <FMenuSettingFooter+0x1e2>
    e842:	aa c0       	rjmp	.+340    	; 0xe998 <FMenuSettingFooter+0x336>
    e844:	86 e0       	ldi	r24, 0x06	; 6
    e846:	63 c0       	rjmp	.+198    	; 0xe90e <FMenuSettingFooter+0x2ac>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
    e848:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    e84c:	20 e0       	ldi	r18, 0x00	; 0
    e84e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    e850:	f9 01       	movw	r30, r18
    e852:	ee 56       	subi	r30, 0x6E	; 110
    e854:	f7 4f       	sbci	r31, 0xF7	; 247
    e856:	d9 01       	movw	r26, r18
    e858:	a4 51       	subi	r26, 0x14	; 20
    e85a:	bc 4f       	sbci	r27, 0xFC	; 252
    e85c:	8c 91       	ld	r24, X
    e85e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    e860:	2f 5f       	subi	r18, 0xFF	; 255
    e862:	3f 4f       	sbci	r19, 0xFF	; 255
    e864:	24 31       	cpi	r18, 0x14	; 20
    e866:	31 05       	cpc	r19, r1
    e868:	99 f7       	brne	.-26     	; 0xe850 <FMenuSettingFooter+0x1ee>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    e86a:	10 92 a6 08 	sts	0x08A6, r1
    e86e:	e0 e0       	ldi	r30, 0x00	; 0
    e870:	f4 e0       	ldi	r31, 0x04	; 4
    e872:	a3 ea       	ldi	r26, 0xA3	; 163
    e874:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    e876:	81 91       	ld	r24, Z+
    e878:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    e87a:	94 e0       	ldi	r25, 0x04	; 4
    e87c:	e4 31       	cpi	r30, 0x14	; 20
    e87e:	f9 07       	cpc	r31, r25
    e880:	d1 f7       	brne	.-12     	; 0xe876 <FMenuSettingFooter+0x214>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    e882:	10 92 b7 07 	sts	0x07B7, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
    e886:	81 e0       	ldi	r24, 0x01	; 1
    e888:	61 e0       	ldi	r22, 0x01	; 1
    e88a:	42 e9       	ldi	r20, 0x92	; 146
    e88c:	58 e0       	ldi	r21, 0x08	; 8
    e88e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    e892:	82 e0       	ldi	r24, 0x02	; 2
    e894:	61 e0       	ldi	r22, 0x01	; 1
    e896:	43 ea       	ldi	r20, 0xA3	; 163
    e898:	57 e0       	ldi	r21, 0x07	; 7
    e89a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
    e89e:	00 d0       	rcall	.+0      	; 0xe8a0 <FMenuSettingFooter+0x23e>
    e8a0:	00 d0       	rcall	.+0      	; 0xe8a2 <FMenuSettingFooter+0x240>
    e8a2:	00 d0       	rcall	.+0      	; 0xe8a4 <FMenuSettingFooter+0x242>
    e8a4:	ed b7       	in	r30, 0x3d	; 61
    e8a6:	fe b7       	in	r31, 0x3e	; 62
    e8a8:	31 96       	adiw	r30, 0x01	; 1
    e8aa:	8e 01       	movw	r16, r28
    e8ac:	0f 5f       	subi	r16, 0xFF	; 255
    e8ae:	1f 4f       	sbci	r17, 0xFF	; 255
    e8b0:	ad b7       	in	r26, 0x3d	; 61
    e8b2:	be b7       	in	r27, 0x3e	; 62
    e8b4:	12 96       	adiw	r26, 0x02	; 2
    e8b6:	1c 93       	st	X, r17
    e8b8:	0e 93       	st	-X, r16
    e8ba:	11 97       	sbiw	r26, 0x01	; 1
    e8bc:	84 e1       	ldi	r24, 0x14	; 20
    e8be:	95 e1       	ldi	r25, 0x15	; 21
    e8c0:	93 83       	std	Z+3, r25	; 0x03
    e8c2:	82 83       	std	Z+2, r24	; 0x02
    e8c4:	80 91 43 02 	lds	r24, 0x0243
    e8c8:	90 e0       	ldi	r25, 0x00	; 0
    e8ca:	01 96       	adiw	r24, 0x01	; 1
    e8cc:	95 83       	std	Z+5, r25	; 0x05
    e8ce:	84 83       	std	Z+4, r24	; 0x04
    e8d0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(3,1,lcdteks);
    e8d4:	8d b7       	in	r24, 0x3d	; 61
    e8d6:	9e b7       	in	r25, 0x3e	; 62
    e8d8:	06 96       	adiw	r24, 0x06	; 6
    e8da:	0f b6       	in	r0, 0x3f	; 63
    e8dc:	f8 94       	cli
    e8de:	9e bf       	out	0x3e, r25	; 62
    e8e0:	0f be       	out	0x3f, r0	; 63
    e8e2:	8d bf       	out	0x3d, r24	; 61
    e8e4:	83 e0       	ldi	r24, 0x03	; 3
    e8e6:	61 e0       	ldi	r22, 0x01	; 1
    e8e8:	a8 01       	movw	r20, r16
    e8ea:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
    e8ee:	84 e0       	ldi	r24, 0x04	; 4
    e8f0:	61 e0       	ldi	r22, 0x01	; 1
    e8f2:	47 e0       	ldi	r20, 0x07	; 7
    e8f4:	55 e1       	ldi	r21, 0x15	; 21
    e8f6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
    e8fa:	84 e0       	ldi	r24, 0x04	; 4
    e8fc:	08 c0       	rjmp	.+16     	; 0xe90e <FMenuSettingFooter+0x2ac>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
    e8fe:	81 e0       	ldi	r24, 0x01	; 1
    e900:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    e904:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
    e908:	83 32       	cpi	r24, 0x23	; 35
    e90a:	21 f4       	brne	.+8      	; 0xe914 <FMenuSettingFooter+0x2b2>
    e90c:	87 e0       	ldi	r24, 0x07	; 7
    e90e:	80 93 44 02 	sts	0x0244, r24
    e912:	42 c0       	rjmp	.+132    	; 0xe998 <FMenuSettingFooter+0x336>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
    e914:	8a 32       	cpi	r24, 0x2A	; 42
    e916:	09 f0       	breq	.+2      	; 0xe91a <FMenuSettingFooter+0x2b8>
    e918:	3f c0       	rjmp	.+126    	; 0xe998 <FMenuSettingFooter+0x336>
    e91a:	37 c0       	rjmp	.+110    	; 0xe98a <FMenuSettingFooter+0x328>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
    e91c:	ad b7       	in	r26, 0x3d	; 61
    e91e:	be b7       	in	r27, 0x3e	; 62
    e920:	18 97       	sbiw	r26, 0x08	; 8
    e922:	0f b6       	in	r0, 0x3f	; 63
    e924:	f8 94       	cli
    e926:	be bf       	out	0x3e, r27	; 62
    e928:	0f be       	out	0x3f, r0	; 63
    e92a:	ad bf       	out	0x3d, r26	; 61
    e92c:	ed b7       	in	r30, 0x3d	; 61
    e92e:	fe b7       	in	r31, 0x3e	; 62
    e930:	31 96       	adiw	r30, 0x01	; 1
    e932:	8e 01       	movw	r16, r28
    e934:	0b 5e       	subi	r16, 0xEB	; 235
    e936:	1f 4f       	sbci	r17, 0xFF	; 255
    e938:	12 96       	adiw	r26, 0x02	; 2
    e93a:	1c 93       	st	X, r17
    e93c:	0e 93       	st	-X, r16
    e93e:	11 97       	sbiw	r26, 0x01	; 1
    e940:	82 e0       	ldi	r24, 0x02	; 2
    e942:	95 e1       	ldi	r25, 0x15	; 21
    e944:	93 83       	std	Z+3, r25	; 0x03
    e946:	82 83       	std	Z+2, r24	; 0x02
    e948:	82 e9       	ldi	r24, 0x92	; 146
    e94a:	98 e0       	ldi	r25, 0x08	; 8
    e94c:	95 83       	std	Z+5, r25	; 0x05
    e94e:	84 83       	std	Z+4, r24	; 0x04
    e950:	83 ea       	ldi	r24, 0xA3	; 163
    e952:	97 e0       	ldi	r25, 0x07	; 7
    e954:	97 83       	std	Z+7, r25	; 0x07
    e956:	86 83       	std	Z+6, r24	; 0x06
    e958:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    e95c:	8d b7       	in	r24, 0x3d	; 61
    e95e:	9e b7       	in	r25, 0x3e	; 62
    e960:	08 96       	adiw	r24, 0x08	; 8
    e962:	0f b6       	in	r0, 0x3f	; 63
    e964:	f8 94       	cli
    e966:	9e bf       	out	0x3e, r25	; 62
    e968:	0f be       	out	0x3f, r0	; 63
    e96a:	8d bf       	out	0x3d, r24	; 61
    e96c:	80 91 43 02 	lds	r24, 0x0243
    e970:	29 e2       	ldi	r18, 0x29	; 41
    e972:	82 9f       	mul	r24, r18
    e974:	c0 01       	movw	r24, r0
    e976:	11 24       	eor	r1, r1
    e978:	83 5e       	subi	r24, 0xE3	; 227
    e97a:	9c 4f       	sbci	r25, 0xFC	; 252
    e97c:	b8 01       	movw	r22, r16
    e97e:	48 e2       	ldi	r20, 0x28	; 40
    e980:	50 e0       	ldi	r21, 0x00	; 0
    e982:	2a ed       	ldi	r18, 0xDA	; 218
    e984:	33 e1       	ldi	r19, 0x13	; 19
    e986:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx+6],40);

          stSettingHeader=shInitHeader;
    e98a:	10 92 44 02 	sts	0x0244, r1
    e98e:	04 c0       	rjmp	.+8      	; 0xe998 <FMenuSettingFooter+0x336>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
    e990:	10 92 44 02 	sts	0x0244, r1
    e994:	81 e0       	ldi	r24, 0x01	; 1
    e996:	01 c0       	rjmp	.+2      	; 0xe99a <FMenuSettingFooter+0x338>
    e998:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
    e99a:	ca 5b       	subi	r28, 0xBA	; 186
    e99c:	df 4f       	sbci	r29, 0xFF	; 255
    e99e:	0f b6       	in	r0, 0x3f	; 63
    e9a0:	f8 94       	cli
    e9a2:	de bf       	out	0x3e, r29	; 62
    e9a4:	0f be       	out	0x3f, r0	; 63
    e9a6:	cd bf       	out	0x3d, r28	; 61
    e9a8:	cf 91       	pop	r28
    e9aa:	df 91       	pop	r29
    e9ac:	1f 91       	pop	r17
    e9ae:	0f 91       	pop	r16
    e9b0:	ef 90       	pop	r14
    e9b2:	08 95       	ret

0000e9b4 <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
    e9b4:	ef 92       	push	r14
    e9b6:	0f 93       	push	r16
    e9b8:	1f 93       	push	r17
    e9ba:	df 93       	push	r29
    e9bc:	cf 93       	push	r28
    e9be:	cd b7       	in	r28, 0x3d	; 61
    e9c0:	de b7       	in	r29, 0x3e	; 62
    e9c2:	c6 54       	subi	r28, 0x46	; 70
    e9c4:	d0 40       	sbci	r29, 0x00	; 0
    e9c6:	0f b6       	in	r0, 0x3f	; 63
    e9c8:	f8 94       	cli
    e9ca:	de bf       	out	0x3e, r29	; 62
    e9cc:	0f be       	out	0x3f, r0	; 63
    e9ce:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
    e9d0:	80 91 46 02 	lds	r24, 0x0246
    e9d4:	84 30       	cpi	r24, 0x04	; 4
    e9d6:	09 f4       	brne	.+2      	; 0xe9da <FMenuSettingHeader+0x26>
    e9d8:	3b c1       	rjmp	.+630    	; 0xec50 <FMenuSettingHeader+0x29c>
    e9da:	85 30       	cpi	r24, 0x05	; 5
    e9dc:	40 f4       	brcc	.+16     	; 0xe9ee <FMenuSettingHeader+0x3a>
    e9de:	81 30       	cpi	r24, 0x01	; 1
    e9e0:	79 f1       	breq	.+94     	; 0xea40 <FMenuSettingHeader+0x8c>
    e9e2:	81 30       	cpi	r24, 0x01	; 1
    e9e4:	88 f0       	brcs	.+34     	; 0xea08 <FMenuSettingHeader+0x54>
    e9e6:	82 30       	cpi	r24, 0x02	; 2
    e9e8:	09 f0       	breq	.+2      	; 0xe9ec <FMenuSettingHeader+0x38>
    e9ea:	7f c1       	rjmp	.+766    	; 0xecea <FMenuSettingHeader+0x336>
    e9ec:	74 c0       	rjmp	.+232    	; 0xead6 <FMenuSettingHeader+0x122>
    e9ee:	86 30       	cpi	r24, 0x06	; 6
    e9f0:	09 f4       	brne	.+2      	; 0xe9f4 <FMenuSettingHeader+0x40>
    e9f2:	d3 c0       	rjmp	.+422    	; 0xeb9a <FMenuSettingHeader+0x1e6>
    e9f4:	86 30       	cpi	r24, 0x06	; 6
    e9f6:	08 f4       	brcc	.+2      	; 0xe9fa <FMenuSettingHeader+0x46>
    e9f8:	bd c0       	rjmp	.+378    	; 0xeb74 <FMenuSettingHeader+0x1c0>
    e9fa:	87 30       	cpi	r24, 0x07	; 7
    e9fc:	09 f4       	brne	.+2      	; 0xea00 <FMenuSettingHeader+0x4c>
    e9fe:	37 c1       	rjmp	.+622    	; 0xec6e <FMenuSettingHeader+0x2ba>
    ea00:	88 30       	cpi	r24, 0x08	; 8
    ea02:	09 f0       	breq	.+2      	; 0xea06 <FMenuSettingHeader+0x52>
    ea04:	72 c1       	rjmp	.+740    	; 0xecea <FMenuSettingHeader+0x336>
    ea06:	6d c1       	rjmp	.+730    	; 0xece2 <FMenuSettingHeader+0x32e>
	 case shInitHeader:
	      lcd_clear();
    ea08:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
    ea0c:	81 e0       	ldi	r24, 0x01	; 1
    ea0e:	61 e0       	ldi	r22, 0x01	; 1
    ea10:	4d e4       	ldi	r20, 0x4D	; 77
    ea12:	56 e1       	ldi	r21, 0x16	; 22
    ea14:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
    ea18:	82 e0       	ldi	r24, 0x02	; 2
    ea1a:	61 e0       	ldi	r22, 0x01	; 1
    ea1c:	48 e3       	ldi	r20, 0x38	; 56
    ea1e:	56 e1       	ldi	r21, 0x16	; 22
    ea20:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
    ea24:	83 e0       	ldi	r24, 0x03	; 3
    ea26:	61 e0       	ldi	r22, 0x01	; 1
    ea28:	43 e2       	ldi	r20, 0x23	; 35
    ea2a:	56 e1       	ldi	r21, 0x16	; 22
    ea2c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
    ea30:	84 e0       	ldi	r24, 0x04	; 4
    ea32:	61 e0       	ldi	r22, 0x01	; 1
    ea34:	4e e0       	ldi	r20, 0x0E	; 14
    ea36:	56 e1       	ldi	r21, 0x16	; 22
    ea38:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
    ea3c:	81 e0       	ldi	r24, 0x01	; 1
    ea3e:	10 c1       	rjmp	.+544    	; 0xec60 <FMenuSettingHeader+0x2ac>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
    ea40:	81 e0       	ldi	r24, 0x01	; 1
    ea42:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    ea46:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    ea4a:	e8 2e       	mov	r14, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    ea4c:	81 53       	subi	r24, 0x31	; 49
    ea4e:	86 30       	cpi	r24, 0x06	; 6
    ea50:	e0 f5       	brcc	.+120    	; 0xeaca <FMenuSettingHeader+0x116>
		       HeaderIdx=KeyChar-'1';//
    ea52:	80 93 45 02 	sts	0x0245, r24
			   lcd_clear();
    ea56:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
    ea5a:	00 d0       	rcall	.+0      	; 0xea5c <FMenuSettingHeader+0xa8>
    ea5c:	00 d0       	rcall	.+0      	; 0xea5e <FMenuSettingHeader+0xaa>
    ea5e:	00 d0       	rcall	.+0      	; 0xea60 <FMenuSettingHeader+0xac>
    ea60:	ed b7       	in	r30, 0x3d	; 61
    ea62:	fe b7       	in	r31, 0x3e	; 62
    ea64:	31 96       	adiw	r30, 0x01	; 1
    ea66:	8e 01       	movw	r16, r28
    ea68:	0f 5f       	subi	r16, 0xFF	; 255
    ea6a:	1f 4f       	sbci	r17, 0xFF	; 255
    ea6c:	ad b7       	in	r26, 0x3d	; 61
    ea6e:	be b7       	in	r27, 0x3e	; 62
    ea70:	12 96       	adiw	r26, 0x02	; 2
    ea72:	1c 93       	st	X, r17
    ea74:	0e 93       	st	-X, r16
    ea76:	11 97       	sbiw	r26, 0x01	; 1
    ea78:	8f ef       	ldi	r24, 0xFF	; 255
    ea7a:	95 e1       	ldi	r25, 0x15	; 21
    ea7c:	93 83       	std	Z+3, r25	; 0x03
    ea7e:	82 83       	std	Z+2, r24	; 0x02
    ea80:	80 91 45 02 	lds	r24, 0x0245
    ea84:	90 e0       	ldi	r25, 0x00	; 0
    ea86:	01 96       	adiw	r24, 0x01	; 1
    ea88:	95 83       	std	Z+5, r25	; 0x05
    ea8a:	84 83       	std	Z+4, r24	; 0x04
    ea8c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			   lcd_print(1,1,lcdteks);
    ea90:	8d b7       	in	r24, 0x3d	; 61
    ea92:	9e b7       	in	r25, 0x3e	; 62
    ea94:	06 96       	adiw	r24, 0x06	; 6
    ea96:	0f b6       	in	r0, 0x3f	; 63
    ea98:	f8 94       	cli
    ea9a:	9e bf       	out	0x3e, r25	; 62
    ea9c:	0f be       	out	0x3f, r0	; 63
    ea9e:	8d bf       	out	0x3d, r24	; 61
    eaa0:	81 e0       	ldi	r24, 0x01	; 1
    eaa2:	61 e0       	ldi	r22, 0x01	; 1
    eaa4:	a8 01       	movw	r20, r16
    eaa6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
    eaaa:	84 e0       	ldi	r24, 0x04	; 4
    eaac:	61 e0       	ldi	r22, 0x01	; 1
    eaae:	40 ef       	ldi	r20, 0xF0	; 240
    eab0:	55 e1       	ldi	r21, 0x15	; 21
    eab2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    eab6:	ec ee       	ldi	r30, 0xEC	; 236
    eab8:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    eaba:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    eabc:	95 e0       	ldi	r25, 0x05	; 5
    eabe:	ed 37       	cpi	r30, 0x7D	; 125
    eac0:	f9 07       	cpc	r31, r25
    eac2:	d9 f7       	brne	.-10     	; 0xeaba <FMenuSettingHeader+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
    eac4:	82 e0       	ldi	r24, 0x02	; 2
    eac6:	80 93 46 02 	sts	0x0246, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
    eaca:	aa e2       	ldi	r26, 0x2A	; 42
    eacc:	ea 16       	cp	r14, r26
    eace:	09 f0       	breq	.+2      	; 0xead2 <FMenuSettingHeader+0x11e>
    ead0:	0c c1       	rjmp	.+536    	; 0xecea <FMenuSettingHeader+0x336>
    ead2:	88 e0       	ldi	r24, 0x08	; 8
    ead4:	c5 c0       	rjmp	.+394    	; 0xec60 <FMenuSettingHeader+0x2ac>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
    ead6:	83 e0       	ldi	r24, 0x03	; 3
    ead8:	62 e0       	ldi	r22, 0x02	; 2
    eada:	41 e0       	ldi	r20, 0x01	; 1
    eadc:	2c ee       	ldi	r18, 0xEC	; 236
    eade:	33 e0       	ldi	r19, 0x03	; 3
    eae0:	00 e0       	ldi	r16, 0x00	; 0
    eae2:	10 e0       	ldi	r17, 0x00	; 0
    eae4:	e8 e2       	ldi	r30, 0x28	; 40
    eae6:	ee 2e       	mov	r14, r30
    eae8:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  if (uiResult==USER_OK){
    eaec:	83 30       	cpi	r24, 0x03	; 3
    eaee:	f1 f5       	brne	.+124    	; 0xeb6c <FMenuSettingHeader+0x1b8>
			  lcd_clear();
    eaf0:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
    eaf4:	8c ee       	ldi	r24, 0xEC	; 236
    eaf6:	93 e0       	ldi	r25, 0x03	; 3
    eaf8:	68 e2       	ldi	r22, 0x28	; 40
    eafa:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
    eafe:	20 e0       	ldi	r18, 0x00	; 0
    eb00:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    eb02:	f9 01       	movw	r30, r18
    eb04:	ee 56       	subi	r30, 0x6E	; 110
    eb06:	f7 4f       	sbci	r31, 0xF7	; 247
    eb08:	d9 01       	movw	r26, r18
    eb0a:	a4 51       	subi	r26, 0x14	; 20
    eb0c:	bc 4f       	sbci	r27, 0xFC	; 252
    eb0e:	8c 91       	ld	r24, X
    eb10:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    eb12:	2f 5f       	subi	r18, 0xFF	; 255
    eb14:	3f 4f       	sbci	r19, 0xFF	; 255
    eb16:	24 31       	cpi	r18, 0x14	; 20
    eb18:	31 05       	cpc	r19, r1
    eb1a:	99 f7       	brne	.-26     	; 0xeb02 <FMenuSettingHeader+0x14e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    eb1c:	10 92 a6 08 	sts	0x08A6, r1
    eb20:	e0 e0       	ldi	r30, 0x00	; 0
    eb22:	f4 e0       	ldi	r31, 0x04	; 4
    eb24:	a3 ea       	ldi	r26, 0xA3	; 163
    eb26:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    eb28:	81 91       	ld	r24, Z+
    eb2a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    eb2c:	84 e0       	ldi	r24, 0x04	; 4
    eb2e:	e4 31       	cpi	r30, 0x14	; 20
    eb30:	f8 07       	cpc	r31, r24
    eb32:	d1 f7       	brne	.-12     	; 0xeb28 <FMenuSettingHeader+0x174>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    eb34:	10 92 b7 07 	sts	0x07B7, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
    eb38:	81 e0       	ldi	r24, 0x01	; 1
    eb3a:	61 e0       	ldi	r22, 0x01	; 1
    eb3c:	42 e9       	ldi	r20, 0x92	; 146
    eb3e:	58 e0       	ldi	r21, 0x08	; 8
    eb40:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
    eb44:	82 e0       	ldi	r24, 0x02	; 2
    eb46:	61 e0       	ldi	r22, 0x01	; 1
    eb48:	43 ea       	ldi	r20, 0xA3	; 163
    eb4a:	57 e0       	ldi	r21, 0x07	; 7
    eb4c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
    eb50:	83 e0       	ldi	r24, 0x03	; 3
    eb52:	61 e0       	ldi	r22, 0x01	; 1
    eb54:	42 ee       	ldi	r20, 0xE2	; 226
    eb56:	55 e1       	ldi	r21, 0x15	; 21
    eb58:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
    eb5c:	84 e0       	ldi	r24, 0x04	; 4
    eb5e:	61 e0       	ldi	r22, 0x01	; 1
    eb60:	44 ed       	ldi	r20, 0xD4	; 212
    eb62:	55 e1       	ldi	r21, 0x15	; 21
    eb64:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
    eb68:	85 e0       	ldi	r24, 0x05	; 5
    eb6a:	7a c0       	rjmp	.+244    	; 0xec60 <FMenuSettingHeader+0x2ac>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
    eb6c:	81 30       	cpi	r24, 0x01	; 1
    eb6e:	09 f0       	breq	.+2      	; 0xeb72 <FMenuSettingHeader+0x1be>
    eb70:	bc c0       	rjmp	.+376    	; 0xecea <FMenuSettingHeader+0x336>
    eb72:	b4 c0       	rjmp	.+360    	; 0xecdc <FMenuSettingHeader+0x328>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
    eb74:	81 e0       	ldi	r24, 0x01	; 1
    eb76:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    eb7a:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
          if(KeyChar=='#'){
    eb7e:	83 32       	cpi	r24, 0x23	; 35
    eb80:	39 f4       	brne	.+14     	; 0xeb90 <FMenuSettingHeader+0x1dc>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
    eb82:	8c ee       	ldi	r24, 0xEC	; 236
    eb84:	93 e0       	ldi	r25, 0x03	; 3
    eb86:	68 e2       	ldi	r22, 0x28	; 40
    eb88:	70 e0       	ldi	r23, 0x00	; 0
    eb8a:	0e 94 e1 32 	call	0x65c2	; 0x65c2 <StrAlignCenter>
    eb8e:	03 c0       	rjmp	.+6      	; 0xeb96 <FMenuSettingHeader+0x1e2>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
    eb90:	8a 32       	cpi	r24, 0x2A	; 42
    eb92:	09 f0       	breq	.+2      	; 0xeb96 <FMenuSettingHeader+0x1e2>
    eb94:	aa c0       	rjmp	.+340    	; 0xecea <FMenuSettingHeader+0x336>
    eb96:	86 e0       	ldi	r24, 0x06	; 6
    eb98:	63 c0       	rjmp	.+198    	; 0xec60 <FMenuSettingHeader+0x2ac>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
    eb9a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
    eb9e:	20 e0       	ldi	r18, 0x00	; 0
    eba0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    eba2:	f9 01       	movw	r30, r18
    eba4:	ee 56       	subi	r30, 0x6E	; 110
    eba6:	f7 4f       	sbci	r31, 0xF7	; 247
    eba8:	d9 01       	movw	r26, r18
    ebaa:	a4 51       	subi	r26, 0x14	; 20
    ebac:	bc 4f       	sbci	r27, 0xFC	; 252
    ebae:	8c 91       	ld	r24, X
    ebb0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ebb2:	2f 5f       	subi	r18, 0xFF	; 255
    ebb4:	3f 4f       	sbci	r19, 0xFF	; 255
    ebb6:	24 31       	cpi	r18, 0x14	; 20
    ebb8:	31 05       	cpc	r19, r1
    ebba:	99 f7       	brne	.-26     	; 0xeba2 <FMenuSettingHeader+0x1ee>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ebbc:	10 92 a6 08 	sts	0x08A6, r1
    ebc0:	e0 e0       	ldi	r30, 0x00	; 0
    ebc2:	f4 e0       	ldi	r31, 0x04	; 4
    ebc4:	a3 ea       	ldi	r26, 0xA3	; 163
    ebc6:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ebc8:	81 91       	ld	r24, Z+
    ebca:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ebcc:	94 e0       	ldi	r25, 0x04	; 4
    ebce:	e4 31       	cpi	r30, 0x14	; 20
    ebd0:	f9 07       	cpc	r31, r25
    ebd2:	d1 f7       	brne	.-12     	; 0xebc8 <FMenuSettingHeader+0x214>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ebd4:	10 92 b7 07 	sts	0x07B7, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
    ebd8:	81 e0       	ldi	r24, 0x01	; 1
    ebda:	61 e0       	ldi	r22, 0x01	; 1
    ebdc:	42 e9       	ldi	r20, 0x92	; 146
    ebde:	58 e0       	ldi	r21, 0x08	; 8
    ebe0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    ebe4:	82 e0       	ldi	r24, 0x02	; 2
    ebe6:	61 e0       	ldi	r22, 0x01	; 1
    ebe8:	43 ea       	ldi	r20, 0xA3	; 163
    ebea:	57 e0       	ldi	r21, 0x07	; 7
    ebec:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
    ebf0:	00 d0       	rcall	.+0      	; 0xebf2 <FMenuSettingHeader+0x23e>
    ebf2:	00 d0       	rcall	.+0      	; 0xebf4 <FMenuSettingHeader+0x240>
    ebf4:	00 d0       	rcall	.+0      	; 0xebf6 <FMenuSettingHeader+0x242>
    ebf6:	ed b7       	in	r30, 0x3d	; 61
    ebf8:	fe b7       	in	r31, 0x3e	; 62
    ebfa:	31 96       	adiw	r30, 0x01	; 1
    ebfc:	8e 01       	movw	r16, r28
    ebfe:	0f 5f       	subi	r16, 0xFF	; 255
    ec00:	1f 4f       	sbci	r17, 0xFF	; 255
    ec02:	ad b7       	in	r26, 0x3d	; 61
    ec04:	be b7       	in	r27, 0x3e	; 62
    ec06:	12 96       	adiw	r26, 0x02	; 2
    ec08:	1c 93       	st	X, r17
    ec0a:	0e 93       	st	-X, r16
    ec0c:	11 97       	sbiw	r26, 0x01	; 1
    ec0e:	84 ec       	ldi	r24, 0xC4	; 196
    ec10:	95 e1       	ldi	r25, 0x15	; 21
    ec12:	93 83       	std	Z+3, r25	; 0x03
    ec14:	82 83       	std	Z+2, r24	; 0x02
    ec16:	80 91 45 02 	lds	r24, 0x0245
    ec1a:	90 e0       	ldi	r25, 0x00	; 0
    ec1c:	01 96       	adiw	r24, 0x01	; 1
    ec1e:	95 83       	std	Z+5, r25	; 0x05
    ec20:	84 83       	std	Z+4, r24	; 0x04
    ec22:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(3,1,lcdteks);
    ec26:	8d b7       	in	r24, 0x3d	; 61
    ec28:	9e b7       	in	r25, 0x3e	; 62
    ec2a:	06 96       	adiw	r24, 0x06	; 6
    ec2c:	0f b6       	in	r0, 0x3f	; 63
    ec2e:	f8 94       	cli
    ec30:	9e bf       	out	0x3e, r25	; 62
    ec32:	0f be       	out	0x3f, r0	; 63
    ec34:	8d bf       	out	0x3d, r24	; 61
    ec36:	83 e0       	ldi	r24, 0x03	; 3
    ec38:	61 e0       	ldi	r22, 0x01	; 1
    ec3a:	a8 01       	movw	r20, r16
    ec3c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
    ec40:	84 e0       	ldi	r24, 0x04	; 4
    ec42:	61 e0       	ldi	r22, 0x01	; 1
    ec44:	47 eb       	ldi	r20, 0xB7	; 183
    ec46:	55 e1       	ldi	r21, 0x15	; 21
    ec48:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
    ec4c:	84 e0       	ldi	r24, 0x04	; 4
    ec4e:	08 c0       	rjmp	.+16     	; 0xec60 <FMenuSettingHeader+0x2ac>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
    ec50:	81 e0       	ldi	r24, 0x01	; 1
    ec52:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    ec56:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
    ec5a:	83 32       	cpi	r24, 0x23	; 35
    ec5c:	21 f4       	brne	.+8      	; 0xec66 <FMenuSettingHeader+0x2b2>
    ec5e:	87 e0       	ldi	r24, 0x07	; 7
    ec60:	80 93 46 02 	sts	0x0246, r24
    ec64:	42 c0       	rjmp	.+132    	; 0xecea <FMenuSettingHeader+0x336>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
    ec66:	8a 32       	cpi	r24, 0x2A	; 42
    ec68:	09 f0       	breq	.+2      	; 0xec6c <FMenuSettingHeader+0x2b8>
    ec6a:	3f c0       	rjmp	.+126    	; 0xecea <FMenuSettingHeader+0x336>
    ec6c:	37 c0       	rjmp	.+110    	; 0xecdc <FMenuSettingHeader+0x328>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
    ec6e:	ad b7       	in	r26, 0x3d	; 61
    ec70:	be b7       	in	r27, 0x3e	; 62
    ec72:	18 97       	sbiw	r26, 0x08	; 8
    ec74:	0f b6       	in	r0, 0x3f	; 63
    ec76:	f8 94       	cli
    ec78:	be bf       	out	0x3e, r27	; 62
    ec7a:	0f be       	out	0x3f, r0	; 63
    ec7c:	ad bf       	out	0x3d, r26	; 61
    ec7e:	ed b7       	in	r30, 0x3d	; 61
    ec80:	fe b7       	in	r31, 0x3e	; 62
    ec82:	31 96       	adiw	r30, 0x01	; 1
    ec84:	8e 01       	movw	r16, r28
    ec86:	0b 5e       	subi	r16, 0xEB	; 235
    ec88:	1f 4f       	sbci	r17, 0xFF	; 255
    ec8a:	12 96       	adiw	r26, 0x02	; 2
    ec8c:	1c 93       	st	X, r17
    ec8e:	0e 93       	st	-X, r16
    ec90:	11 97       	sbiw	r26, 0x01	; 1
    ec92:	82 eb       	ldi	r24, 0xB2	; 178
    ec94:	95 e1       	ldi	r25, 0x15	; 21
    ec96:	93 83       	std	Z+3, r25	; 0x03
    ec98:	82 83       	std	Z+2, r24	; 0x02
    ec9a:	82 e9       	ldi	r24, 0x92	; 146
    ec9c:	98 e0       	ldi	r25, 0x08	; 8
    ec9e:	95 83       	std	Z+5, r25	; 0x05
    eca0:	84 83       	std	Z+4, r24	; 0x04
    eca2:	83 ea       	ldi	r24, 0xA3	; 163
    eca4:	97 e0       	ldi	r25, 0x07	; 7
    eca6:	97 83       	std	Z+7, r25	; 0x07
    eca8:	86 83       	std	Z+6, r24	; 0x06
    ecaa:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    ecae:	8d b7       	in	r24, 0x3d	; 61
    ecb0:	9e b7       	in	r25, 0x3e	; 62
    ecb2:	08 96       	adiw	r24, 0x08	; 8
    ecb4:	0f b6       	in	r0, 0x3f	; 63
    ecb6:	f8 94       	cli
    ecb8:	9e bf       	out	0x3e, r25	; 62
    ecba:	0f be       	out	0x3f, r0	; 63
    ecbc:	8d bf       	out	0x3d, r24	; 61
    ecbe:	80 91 45 02 	lds	r24, 0x0245
    ecc2:	29 e2       	ldi	r18, 0x29	; 41
    ecc4:	82 9f       	mul	r24, r18
    ecc6:	c0 01       	movw	r24, r0
    ecc8:	11 24       	eor	r1, r1
    ecca:	89 5d       	subi	r24, 0xD9	; 217
    eccc:	9d 4f       	sbci	r25, 0xFD	; 253
    ecce:	b8 01       	movw	r22, r16
    ecd0:	48 e2       	ldi	r20, 0x28	; 40
    ecd2:	50 e0       	ldi	r21, 0x00	; 0
    ecd4:	2a ed       	ldi	r18, 0xDA	; 218
    ecd6:	33 e1       	ldi	r19, 0x13	; 19
    ecd8:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
    ecdc:	10 92 46 02 	sts	0x0246, r1
    ece0:	04 c0       	rjmp	.+8      	; 0xecea <FMenuSettingHeader+0x336>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
    ece2:	10 92 46 02 	sts	0x0246, r1
    ece6:	81 e0       	ldi	r24, 0x01	; 1
    ece8:	01 c0       	rjmp	.+2      	; 0xecec <FMenuSettingHeader+0x338>
    ecea:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
    ecec:	ca 5b       	subi	r28, 0xBA	; 186
    ecee:	df 4f       	sbci	r29, 0xFF	; 255
    ecf0:	0f b6       	in	r0, 0x3f	; 63
    ecf2:	f8 94       	cli
    ecf4:	de bf       	out	0x3e, r29	; 62
    ecf6:	0f be       	out	0x3f, r0	; 63
    ecf8:	cd bf       	out	0x3d, r28	; 61
    ecfa:	cf 91       	pop	r28
    ecfc:	df 91       	pop	r29
    ecfe:	1f 91       	pop	r17
    ed00:	0f 91       	pop	r16
    ed02:	ef 90       	pop	r14
    ed04:	08 95       	ret

0000ed06 <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
    ed06:	80 91 47 02 	lds	r24, 0x0247
    ed0a:	83 30       	cpi	r24, 0x03	; 3
    ed0c:	09 f4       	brne	.+2      	; 0xed10 <FMenuAdminSettings+0xa>
    ed0e:	6e c0       	rjmp	.+220    	; 0xedec <FMenuAdminSettings+0xe6>
    ed10:	84 30       	cpi	r24, 0x04	; 4
    ed12:	30 f4       	brcc	.+12     	; 0xed20 <FMenuAdminSettings+0x1a>
    ed14:	81 30       	cpi	r24, 0x01	; 1
    ed16:	e9 f1       	breq	.+122    	; 0xed92 <FMenuAdminSettings+0x8c>
    ed18:	82 30       	cpi	r24, 0x02	; 2
    ed1a:	08 f0       	brcs	.+2      	; 0xed1e <FMenuAdminSettings+0x18>
    ed1c:	64 c0       	rjmp	.+200    	; 0xede6 <FMenuAdminSettings+0xe0>
    ed1e:	0d c0       	rjmp	.+26     	; 0xed3a <FMenuAdminSettings+0x34>
    ed20:	85 30       	cpi	r24, 0x05	; 5
    ed22:	09 f4       	brne	.+2      	; 0xed26 <FMenuAdminSettings+0x20>
    ed24:	66 c0       	rjmp	.+204    	; 0xedf2 <FMenuAdminSettings+0xec>
    ed26:	85 30       	cpi	r24, 0x05	; 5
    ed28:	08 f4       	brcc	.+2      	; 0xed2c <FMenuAdminSettings+0x26>
    ed2a:	6a c0       	rjmp	.+212    	; 0xee00 <FMenuAdminSettings+0xfa>
    ed2c:	86 30       	cpi	r24, 0x06	; 6
    ed2e:	09 f4       	brne	.+2      	; 0xed32 <FMenuAdminSettings+0x2c>
    ed30:	63 c0       	rjmp	.+198    	; 0xedf8 <FMenuAdminSettings+0xf2>
    ed32:	87 30       	cpi	r24, 0x07	; 7
    ed34:	09 f0       	breq	.+2      	; 0xed38 <FMenuAdminSettings+0x32>
    ed36:	6c c0       	rjmp	.+216    	; 0xee10 <FMenuAdminSettings+0x10a>
    ed38:	67 c0       	rjmp	.+206    	; 0xee08 <FMenuAdminSettings+0x102>
	 case asInitMenu:
          lcd_clear();
    ed3a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  if (IFType==IT_SLAVE){
    ed3e:	80 91 00 01 	lds	r24, 0x0100
    ed42:	81 30       	cpi	r24, 0x01	; 1
    ed44:	51 f4       	brne	.+20     	; 0xed5a <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
    ed46:	61 e0       	ldi	r22, 0x01	; 1
    ed48:	4d eb       	ldi	r20, 0xBD	; 189
    ed4a:	56 e1       	ldi	r21, 0x16	; 22
    ed4c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
    ed50:	82 e0       	ldi	r24, 0x02	; 2
    ed52:	61 e0       	ldi	r22, 0x01	; 1
    ed54:	48 ea       	ldi	r20, 0xA8	; 168
    ed56:	56 e1       	ldi	r21, 0x16	; 22
    ed58:	0c c0       	rjmp	.+24     	; 0xed72 <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
    ed5a:	82 30       	cpi	r24, 0x02	; 2
    ed5c:	61 f4       	brne	.+24     	; 0xed76 <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
    ed5e:	81 e0       	ldi	r24, 0x01	; 1
    ed60:	61 e0       	ldi	r22, 0x01	; 1
    ed62:	43 e9       	ldi	r20, 0x93	; 147
    ed64:	56 e1       	ldi	r21, 0x16	; 22
    ed66:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
    ed6a:	82 e0       	ldi	r24, 0x02	; 2
    ed6c:	61 e0       	ldi	r22, 0x01	; 1
    ed6e:	4e e7       	ldi	r20, 0x7E	; 126
    ed70:	56 e1       	ldi	r21, 0x16	; 22
    ed72:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
    ed76:	83 e0       	ldi	r24, 0x03	; 3
    ed78:	61 e0       	ldi	r22, 0x01	; 1
    ed7a:	49 e6       	ldi	r20, 0x69	; 105
    ed7c:	56 e1       	ldi	r21, 0x16	; 22
    ed7e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
    ed82:	84 e0       	ldi	r24, 0x04	; 4
    ed84:	61 e0       	ldi	r22, 0x01	; 1
    ed86:	42 e6       	ldi	r20, 0x62	; 98
    ed88:	56 e1       	ldi	r21, 0x16	; 22
    ed8a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
    ed8e:	81 e0       	ldi	r24, 0x01	; 1
    ed90:	27 c0       	rjmp	.+78     	; 0xede0 <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
    ed92:	81 e0       	ldi	r24, 0x01	; 1
    ed94:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
    ed98:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    ed9c:	98 2f       	mov	r25, r24
		  switch(KeyChar){
    ed9e:	82 33       	cpi	r24, 0x32	; 50
    eda0:	61 f0       	breq	.+24     	; 0xedba <FMenuAdminSettings+0xb4>
    eda2:	83 33       	cpi	r24, 0x33	; 51
    eda4:	28 f4       	brcc	.+10     	; 0xedb0 <FMenuAdminSettings+0xaa>
    eda6:	8a 32       	cpi	r24, 0x2A	; 42
    eda8:	61 f0       	breq	.+24     	; 0xedc2 <FMenuAdminSettings+0xbc>
    edaa:	81 33       	cpi	r24, 0x31	; 49
    edac:	69 f4       	brne	.+26     	; 0xedc8 <FMenuAdminSettings+0xc2>
    edae:	03 c0       	rjmp	.+6      	; 0xedb6 <FMenuAdminSettings+0xb0>
    edb0:	83 33       	cpi	r24, 0x33	; 51
    edb2:	51 f4       	brne	.+20     	; 0xedc8 <FMenuAdminSettings+0xc2>
    edb4:	04 c0       	rjmp	.+8      	; 0xedbe <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
    edb6:	82 e0       	ldi	r24, 0x02	; 2
    edb8:	05 c0       	rjmp	.+10     	; 0xedc4 <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
    edba:	83 e0       	ldi	r24, 0x03	; 3
    edbc:	03 c0       	rjmp	.+6      	; 0xedc4 <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
    edbe:	84 e0       	ldi	r24, 0x04	; 4
    edc0:	01 c0       	rjmp	.+2      	; 0xedc4 <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
    edc2:	87 e0       	ldi	r24, 0x07	; 7
    edc4:	80 93 47 02 	sts	0x0247, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
    edc8:	80 91 00 01 	lds	r24, 0x0100
    edcc:	81 30       	cpi	r24, 0x01	; 1
    edce:	01 f5       	brne	.+64     	; 0xee10 <FMenuAdminSettings+0x10a>
			  switch(KeyChar){
    edd0:	94 33       	cpi	r25, 0x34	; 52
    edd2:	19 f0       	breq	.+6      	; 0xedda <FMenuAdminSettings+0xd4>
    edd4:	95 33       	cpi	r25, 0x35	; 53
    edd6:	e1 f4       	brne	.+56     	; 0xee10 <FMenuAdminSettings+0x10a>
    edd8:	02 c0       	rjmp	.+4      	; 0xedde <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
    edda:	85 e0       	ldi	r24, 0x05	; 5
    eddc:	01 c0       	rjmp	.+2      	; 0xede0 <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
    edde:	86 e0       	ldi	r24, 0x06	; 6
    ede0:	80 93 47 02 	sts	0x0247, r24
    ede4:	0f c0       	rjmp	.+30     	; 0xee04 <FMenuAdminSettings+0xfe>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
    ede6:	0e 94 da 74 	call	0xe9b4	; 0xe9b4 <FMenuSettingHeader>
    edea:	08 c0       	rjmp	.+16     	; 0xedfc <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
    edec:	0e 94 31 73 	call	0xe662	; 0xe662 <FMenuSettingFooter>
    edf0:	05 c0       	rjmp	.+10     	; 0xedfc <FMenuAdminSettings+0xf6>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
    edf2:	0e 94 3b 5c 	call	0xb876	; 0xb876 <FMenuSettingClientIP>
    edf6:	02 c0       	rjmp	.+4      	; 0xedfc <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
    edf8:	0e 94 ad 59 	call	0xb35a	; 0xb35a <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
    edfc:	81 30       	cpi	r24, 0x01	; 1
    edfe:	41 f4       	brne	.+16     	; 0xee10 <FMenuAdminSettings+0x10a>
    ee00:	10 92 47 02 	sts	0x0247, r1
    ee04:	80 e0       	ldi	r24, 0x00	; 0
    ee06:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
    ee08:	10 92 47 02 	sts	0x0247, r1
    ee0c:	81 e0       	ldi	r24, 0x01	; 1
    ee0e:	08 95       	ret
    ee10:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    ee12:	08 95       	ret

0000ee14 <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
    ee14:	cf 92       	push	r12
    ee16:	df 92       	push	r13
    ee18:	ef 92       	push	r14
    ee1a:	ff 92       	push	r15
    ee1c:	0f 93       	push	r16
    ee1e:	1f 93       	push	r17
    ee20:	df 93       	push	r29
    ee22:	cf 93       	push	r28
    ee24:	cd b7       	in	r28, 0x3d	; 61
    ee26:	de b7       	in	r29, 0x3e	; 62
    ee28:	e2 97       	sbiw	r28, 0x32	; 50
    ee2a:	0f b6       	in	r0, 0x3f	; 63
    ee2c:	f8 94       	cli
    ee2e:	de bf       	out	0x3e, r29	; 62
    ee30:	0f be       	out	0x3f, r0	; 63
    ee32:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
    ee34:	80 91 4c 02 	lds	r24, 0x024C
    ee38:	e8 2f       	mov	r30, r24
    ee3a:	f0 e0       	ldi	r31, 0x00	; 0
    ee3c:	e9 31       	cpi	r30, 0x19	; 25
    ee3e:	f1 05       	cpc	r31, r1
    ee40:	08 f0       	brcs	.+2      	; 0xee44 <FMenuMaster+0x30>
    ee42:	e0 c2       	rjmp	.+1472   	; 0xf404 <FMenuMaster+0x5f0>
    ee44:	ec 59       	subi	r30, 0x9C	; 156
    ee46:	ff 4f       	sbci	r31, 0xFF	; 255
    ee48:	ee 0f       	add	r30, r30
    ee4a:	ff 1f       	adc	r31, r31
    ee4c:	05 90       	lpm	r0, Z+
    ee4e:	f4 91       	lpm	r31, Z+
    ee50:	e0 2d       	mov	r30, r0
    ee52:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
    ee54:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
    ee58:	81 e0       	ldi	r24, 0x01	; 1
    ee5a:	61 e0       	ldi	r22, 0x01	; 1
    ee5c:	4f ee       	ldi	r20, 0xEF	; 239
    ee5e:	59 e1       	ldi	r21, 0x19	; 25
    ee60:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
    ee64:	82 e0       	ldi	r24, 0x02	; 2
    ee66:	61 e0       	ldi	r22, 0x01	; 1
    ee68:	4a ed       	ldi	r20, 0xDA	; 218
    ee6a:	59 e1       	ldi	r21, 0x19	; 25
    ee6c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Master Reset      "));
    ee70:	83 e0       	ldi	r24, 0x03	; 3
    ee72:	61 e0       	ldi	r22, 0x01	; 1
    ee74:	45 ec       	ldi	r20, 0xC5	; 197
    ee76:	59 e1       	ldi	r21, 0x19	; 25
    ee78:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
    ee7c:	84 e0       	ldi	r24, 0x04	; 4
    ee7e:	61 e0       	ldi	r22, 0x01	; 1
    ee80:	40 eb       	ldi	r20, 0xB0	; 176
    ee82:	59 e1       	ldi	r21, 0x19	; 25
    ee84:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>

		  //uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
    ee88:	81 e0       	ldi	r24, 0x01	; 1
    ee8a:	11 c0       	rjmp	.+34     	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
    ee8c:	81 e0       	ldi	r24, 0x01	; 1
    ee8e:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    ee92:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
          switch(KeyChar){
    ee96:	81 33       	cpi	r24, 0x31	; 49
    ee98:	09 f4       	brne	.+2      	; 0xee9c <FMenuMaster+0x88>
    ee9a:	e0 c1       	rjmp	.+960    	; 0xf25c <FMenuMaster+0x448>
    ee9c:	82 33       	cpi	r24, 0x32	; 50
    ee9e:	21 f0       	breq	.+8      	; 0xeea8 <FMenuMaster+0x94>
    eea0:	8a 32       	cpi	r24, 0x2A	; 42
    eea2:	09 f0       	breq	.+2      	; 0xeea6 <FMenuMaster+0x92>
    eea4:	af c2       	rjmp	.+1374   	; 0xf404 <FMenuMaster+0x5f0>
    eea6:	02 c0       	rjmp	.+4      	; 0xeeac <FMenuMaster+0x98>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmMasterReset;
    eea8:	81 e1       	ldi	r24, 0x11	; 17
    eeaa:	01 c0       	rjmp	.+2      	; 0xeeae <FMenuMaster+0x9a>
		       break;
          case '*':
		       stMenuMaster=mmExitMaster;
    eeac:	80 e1       	ldi	r24, 0x10	; 16
    eeae:	80 93 4c 02 	sts	0x024C, r24
    eeb2:	a8 c2       	rjmp	.+1360   	; 0xf404 <FMenuMaster+0x5f0>
		       break;
		  }
	      break;
     case mmMasterReset:
		  
	      _datetime(0, strSystemDate, strSystemTime);
    eeb4:	04 e7       	ldi	r16, 0x74	; 116
    eeb6:	18 e0       	ldi	r17, 0x08	; 8
    eeb8:	80 e0       	ldi	r24, 0x00	; 0
    eeba:	6a eb       	ldi	r22, 0xBA	; 186
    eebc:	73 e0       	ldi	r23, 0x03	; 3
    eebe:	a8 01       	movw	r20, r16
    eec0:	0e 94 e3 ac 	call	0x159c6	; 0x159c6 <_datetime>
	      sprintf_P(PTime,PSTR("%s"),strSystemTime);
    eec4:	00 d0       	rcall	.+0      	; 0xeec6 <FMenuMaster+0xb2>
    eec6:	00 d0       	rcall	.+0      	; 0xeec8 <FMenuMaster+0xb4>
    eec8:	00 d0       	rcall	.+0      	; 0xeeca <FMenuMaster+0xb6>
    eeca:	ed b7       	in	r30, 0x3d	; 61
    eecc:	fe b7       	in	r31, 0x3e	; 62
    eece:	31 96       	adiw	r30, 0x01	; 1
    eed0:	7e 01       	movw	r14, r28
    eed2:	08 94       	sec
    eed4:	e1 1c       	adc	r14, r1
    eed6:	f1 1c       	adc	r15, r1
    eed8:	ad b7       	in	r26, 0x3d	; 61
    eeda:	be b7       	in	r27, 0x3e	; 62
    eedc:	12 96       	adiw	r26, 0x02	; 2
    eede:	fc 92       	st	X, r15
    eee0:	ee 92       	st	-X, r14
    eee2:	11 97       	sbiw	r26, 0x01	; 1
    eee4:	8d ea       	ldi	r24, 0xAD	; 173
    eee6:	99 e1       	ldi	r25, 0x19	; 25
    eee8:	93 83       	std	Z+3, r25	; 0x03
    eeea:	82 83       	std	Z+2, r24	; 0x02
    eeec:	15 83       	std	Z+5, r17	; 0x05
    eeee:	04 83       	std	Z+4, r16	; 0x04
    eef0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  sprintf_P(strGeniusCode,PSTR("22345678"));		  
    eef4:	0f 90       	pop	r0
    eef6:	0f 90       	pop	r0
    eef8:	32 e9       	ldi	r19, 0x92	; 146
    eefa:	c3 2e       	mov	r12, r19
    eefc:	35 e0       	ldi	r19, 0x05	; 5
    eefe:	d3 2e       	mov	r13, r19
    ef00:	ed b7       	in	r30, 0x3d	; 61
    ef02:	fe b7       	in	r31, 0x3e	; 62
    ef04:	d2 82       	std	Z+2, r13	; 0x02
    ef06:	c1 82       	std	Z+1, r12	; 0x01
    ef08:	84 ea       	ldi	r24, 0xA4	; 164
    ef0a:	99 e1       	ldi	r25, 0x19	; 25
    ef0c:	94 83       	std	Z+4, r25	; 0x04
    ef0e:	83 83       	std	Z+3, r24	; 0x03
    ef10:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
    ef14:	0f 90       	pop	r0
    ef16:	0f 90       	pop	r0
    ef18:	0f 90       	pop	r0
    ef1a:	0f 90       	pop	r0
    ef1c:	c7 01       	movw	r24, r14
    ef1e:	6a e3       	ldi	r22, 0x3A	; 58
    ef20:	0e 94 b9 33 	call	0x6772	; 0x6772 <RemoveChar>
    ef24:	00 d0       	rcall	.+0      	; 0xef26 <FMenuMaster+0x112>
    ef26:	00 d0       	rcall	.+0      	; 0xef28 <FMenuMaster+0x114>
    ef28:	00 ed       	ldi	r16, 0xD0	; 208
    ef2a:	17 e0       	ldi	r17, 0x07	; 7
    ef2c:	ad b7       	in	r26, 0x3d	; 61
    ef2e:	be b7       	in	r27, 0x3e	; 62
    ef30:	12 96       	adiw	r26, 0x02	; 2
    ef32:	1c 93       	st	X, r17
    ef34:	0e 93       	st	-X, r16
    ef36:	11 97       	sbiw	r26, 0x01	; 1
    ef38:	83 ea       	ldi	r24, 0xA3	; 163
    ef3a:	99 e1       	ldi	r25, 0x19	; 25
    ef3c:	14 96       	adiw	r26, 0x04	; 4
    ef3e:	9c 93       	st	X, r25
    ef40:	8e 93       	st	-X, r24
    ef42:	13 97       	sbiw	r26, 0x03	; 3
    ef44:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);
    ef48:	0f 90       	pop	r0
    ef4a:	0f 90       	pop	r0
    ef4c:	0f 90       	pop	r0
    ef4e:	0f 90       	pop	r0
    ef50:	c7 01       	movw	r24, r14
    ef52:	b6 01       	movw	r22, r12
    ef54:	a8 01       	movw	r20, r16
    ef56:	0e 94 7a 34 	call	0x68f4	; 0x68f4 <GenerateKeyStamp>

		  lcd_clear();
    ef5a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("-Master Reset-"));
    ef5e:	81 e0       	ldi	r24, 0x01	; 1
    ef60:	61 e0       	ldi	r22, 0x01	; 1
    ef62:	44 e9       	ldi	r20, 0x94	; 148
    ef64:	59 e1       	ldi	r21, 0x19	; 25
    ef66:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  sprintf_P(lcdteks,PSTR("Seed Code:%s"),strKeyStamp);
    ef6a:	00 d0       	rcall	.+0      	; 0xef6c <FMenuMaster+0x158>
    ef6c:	00 d0       	rcall	.+0      	; 0xef6e <FMenuMaster+0x15a>
    ef6e:	00 d0       	rcall	.+0      	; 0xef70 <FMenuMaster+0x15c>
    ef70:	ed b7       	in	r30, 0x3d	; 61
    ef72:	fe b7       	in	r31, 0x3e	; 62
    ef74:	31 96       	adiw	r30, 0x01	; 1
    ef76:	2f e1       	ldi	r18, 0x1F	; 31
    ef78:	e2 2e       	mov	r14, r18
    ef7a:	f1 2c       	mov	r15, r1
    ef7c:	ec 0e       	add	r14, r28
    ef7e:	fd 1e       	adc	r15, r29
    ef80:	ad b7       	in	r26, 0x3d	; 61
    ef82:	be b7       	in	r27, 0x3e	; 62
    ef84:	12 96       	adiw	r26, 0x02	; 2
    ef86:	fc 92       	st	X, r15
    ef88:	ee 92       	st	-X, r14
    ef8a:	11 97       	sbiw	r26, 0x01	; 1
    ef8c:	87 e8       	ldi	r24, 0x87	; 135
    ef8e:	99 e1       	ldi	r25, 0x19	; 25
    ef90:	93 83       	std	Z+3, r25	; 0x03
    ef92:	82 83       	std	Z+2, r24	; 0x02
    ef94:	15 83       	std	Z+5, r17	; 0x05
    ef96:	04 83       	std	Z+4, r16	; 0x04
    ef98:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(2,1,lcdteks);
    ef9c:	ed b7       	in	r30, 0x3d	; 61
    ef9e:	fe b7       	in	r31, 0x3e	; 62
    efa0:	36 96       	adiw	r30, 0x06	; 6
    efa2:	0f b6       	in	r0, 0x3f	; 63
    efa4:	f8 94       	cli
    efa6:	fe bf       	out	0x3e, r31	; 62
    efa8:	0f be       	out	0x3f, r0	; 63
    efaa:	ed bf       	out	0x3d, r30	; 61
    efac:	82 e0       	ldi	r24, 0x02	; 2
    efae:	61 e0       	ldi	r22, 0x01	; 1
    efb0:	a7 01       	movw	r20, r14
    efb2:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(3,1,   PSTR("ResetCode:_         "));
    efb6:	83 e0       	ldi	r24, 0x03	; 3
    efb8:	61 e0       	ldi	r22, 0x01	; 1
    efba:	42 e7       	ldi	r20, 0x72	; 114
    efbc:	59 e1       	ldi	r21, 0x19	; 25
    efbe:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,   PSTR("[*]Cancel   [#]Enter"));		          
    efc2:	84 e0       	ldi	r24, 0x04	; 4
    efc4:	61 e0       	ldi	r22, 0x01	; 1
    efc6:	4d e5       	ldi	r20, 0x5D	; 93
    efc8:	59 e1       	ldi	r21, 0x19	; 25
    efca:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      stMenuMaster=mmResetCodeEntry;
    efce:	82 e1       	ldi	r24, 0x12	; 18
    efd0:	6e cf       	rjmp	.-292    	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmResetCodeEntry:
          uiResult=UserInput(UI_NUMBER_R,3,11,strRestoreCode,0,9);
    efd2:	81 e0       	ldi	r24, 0x01	; 1
    efd4:	63 e0       	ldi	r22, 0x03	; 3
    efd6:	4b e0       	ldi	r20, 0x0B	; 11
    efd8:	2b e5       	ldi	r18, 0x5B	; 91
    efda:	3c e0       	ldi	r19, 0x0C	; 12
    efdc:	00 e0       	ldi	r16, 0x00	; 0
    efde:	10 e0       	ldi	r17, 0x00	; 0
    efe0:	99 e0       	ldi	r25, 0x09	; 9
    efe2:	e9 2e       	mov	r14, r25
    efe4:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  switch(uiResult){
    efe8:	83 30       	cpi	r24, 0x03	; 3
    efea:	49 f0       	breq	.+18     	; 0xeffe <FMenuMaster+0x1ea>
    efec:	84 30       	cpi	r24, 0x04	; 4
    efee:	08 f4       	brcc	.+2      	; 0xeff2 <FMenuMaster+0x1de>
    eff0:	82 c1       	rjmp	.+772    	; 0xf2f6 <FMenuMaster+0x4e2>
    eff2:	84 30       	cpi	r24, 0x04	; 4
    eff4:	31 f0       	breq	.+12     	; 0xf002 <FMenuMaster+0x1ee>
    eff6:	85 30       	cpi	r24, 0x05	; 5
    eff8:	09 f0       	breq	.+2      	; 0xeffc <FMenuMaster+0x1e8>
    effa:	04 c2       	rjmp	.+1032   	; 0xf404 <FMenuMaster+0x5f0>
    effc:	07 c0       	rjmp	.+14     	; 0xf00c <FMenuMaster+0x1f8>
		  case USER_OK:
               stMenuMaster=mmIsValidResetCode;
    effe:	83 e1       	ldi	r24, 0x13	; 19
    f000:	56 cf       	rjmp	.-340    	; 0xeeae <FMenuMaster+0x9a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    f002:	84 e0       	ldi	r24, 0x04	; 4
    f004:	61 e0       	ldi	r22, 0x01	; 1
    f006:	48 e4       	ldi	r20, 0x48	; 72
    f008:	59 e1       	ldi	r21, 0x19	; 25
    f00a:	8a c1       	rjmp	.+788    	; 0xf320 <FMenuMaster+0x50c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    f00c:	84 e0       	ldi	r24, 0x04	; 4
    f00e:	61 e0       	ldi	r22, 0x01	; 1
    f010:	43 e3       	ldi	r20, 0x33	; 51
    f012:	59 e1       	ldi	r21, 0x19	; 25
    f014:	85 c1       	rjmp	.+778    	; 0xf320 <FMenuMaster+0x50c>
		       break;
		  }	      
	      break;
     case mmIsValidResetCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
    f016:	80 ed       	ldi	r24, 0xD0	; 208
    f018:	97 e0       	ldi	r25, 0x07	; 7
    f01a:	6b e5       	ldi	r22, 0x5B	; 91
    f01c:	7c e0       	ldi	r23, 0x0C	; 12
    f01e:	0e 94 8e 49 	call	0x931c	; 0x931c <ValidateRestoreCode>
    f022:	81 30       	cpi	r24, 0x01	; 1
    f024:	11 f4       	brne	.+4      	; 0xf02a <FMenuMaster+0x216>
		      stMenuMaster=mmMasterResetExec;
    f026:	84 e1       	ldi	r24, 0x14	; 20
    f028:	42 cf       	rjmp	.-380    	; 0xeeae <FMenuMaster+0x9a>
		  }else stMenuMaster=mmDisplayInvalidResetCode;
    f02a:	86 e1       	ldi	r24, 0x16	; 22
    f02c:	40 cf       	rjmp	.-384    	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmMasterResetExec:
	      lcd_clear();
    f02e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	      lcd_printf(1,1,PSTR("Reset EEPROM"));
    f032:	81 e0       	ldi	r24, 0x01	; 1
    f034:	61 e0       	ldi	r22, 0x01	; 1
    f036:	46 e2       	ldi	r20, 0x26	; 38
    f038:	59 e1       	ldi	r21, 0x19	; 25
    f03a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(2,1,PSTR("Please Wait.."));
    f03e:	82 e0       	ldi	r24, 0x02	; 2
    f040:	61 e0       	ldi	r22, 0x01	; 1
    f042:	48 e1       	ldi	r20, 0x18	; 24
    f044:	59 e1       	ldi	r21, 0x19	; 25
    f046:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      MasterReset();
    f04a:	0e 94 1f 1c 	call	0x383e	; 0x383e <MasterReset>
          stMenuMaster=mmSuccesfullReset;
    f04e:	85 e1       	ldi	r24, 0x15	; 21
    f050:	2e cf       	rjmp	.-420    	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmSuccesfullReset:
	      lcd_clear();
    f052:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    f056:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    f058:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    f05a:	81 e0       	ldi	r24, 0x01	; 1
    f05c:	80 93 bc 01 	sts	0x01BC, r24
          stMenuMaster=mmSuccesfullReset;
	      break;
     case mmSuccesfullReset:
	      lcd_clear();
		  system_beep(1);
	      lcd_printf(2,1,PSTR("Reset Complete"));
    f060:	82 e0       	ldi	r24, 0x02	; 2
    f062:	61 e0       	ldi	r22, 0x01	; 1
    f064:	49 e0       	ldi	r20, 0x09	; 9
    f066:	59 e1       	ldi	r21, 0x19	; 25
    f068:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      TimDisplay=0; 
    f06c:	10 92 92 01 	sts	0x0192, r1
		  stMenuMaster=mmDelayDisplayComplete;
    f070:	88 e1       	ldi	r24, 0x18	; 24
    f072:	1d cf       	rjmp	.-454    	; 0xeeae <FMenuMaster+0x9a>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    f074:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    f076:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    f078:	81 e0       	ldi	r24, 0x01	; 1
    f07a:	80 93 bc 01 	sts	0x01BC, r24
	      TimDisplay=0; 
		  stMenuMaster=mmDelayDisplayComplete;
	      break;
     case mmDisplayInvalidResetCode:
          system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
    f07e:	83 e0       	ldi	r24, 0x03	; 3
    f080:	61 e0       	ldi	r22, 0x01	; 1
    f082:	44 ef       	ldi	r20, 0xF4	; 244
    f084:	58 e1       	ldi	r21, 0x18	; 24
    f086:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          TimDisplay=0; 
    f08a:	10 92 92 01 	sts	0x0192, r1
		  stMenuMaster=mmDelayDisplayInvalidResetCode;
    f08e:	87 e1       	ldi	r24, 0x17	; 23
    f090:	0e cf       	rjmp	.-484    	; 0xeeae <FMenuMaster+0x9a>
     case mmDelayDisplayInvalidResetCode:
          if (TimDisplay>5)stMenuMaster=mmExitMaster;
	      break;
     
	 case mmDelayDisplayComplete:
          if (TimDisplay>5)stMenuMaster=mmExitMaster;
    f092:	80 91 92 01 	lds	r24, 0x0192
    f096:	86 30       	cpi	r24, 0x06	; 6
    f098:	08 f4       	brcc	.+2      	; 0xf09c <FMenuMaster+0x288>
    f09a:	b4 c1       	rjmp	.+872    	; 0xf404 <FMenuMaster+0x5f0>
    f09c:	07 cf       	rjmp	.-498    	; 0xeeac <FMenuMaster+0x98>
	      break;

     case mmRestorePasswordMenu:	      
	      lcd_clear();
    f09e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
    f0a2:	81 e0       	ldi	r24, 0x01	; 1
    f0a4:	61 e0       	ldi	r22, 0x01	; 1
    f0a6:	4f ed       	ldi	r20, 0xDF	; 223
    f0a8:	58 e1       	ldi	r21, 0x18	; 24
    f0aa:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
    f0ae:	82 e0       	ldi	r24, 0x02	; 2
    f0b0:	61 e0       	ldi	r22, 0x01	; 1
    f0b2:	4a ec       	ldi	r20, 0xCA	; 202
    f0b4:	58 e1       	ldi	r21, 0x18	; 24
    f0b6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
    f0ba:	84 e0       	ldi	r24, 0x04	; 4
    f0bc:	64 e0       	ldi	r22, 0x04	; 4
    f0be:	45 eb       	ldi	r20, 0xB5	; 181
    f0c0:	58 e1       	ldi	r21, 0x18	; 24
    f0c2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
    f0c6:	00 d0       	rcall	.+0      	; 0xf0c8 <FMenuMaster+0x2b4>
    f0c8:	00 d0       	rcall	.+0      	; 0xf0ca <FMenuMaster+0x2b6>
    f0ca:	82 e9       	ldi	r24, 0x92	; 146
    f0cc:	95 e0       	ldi	r25, 0x05	; 5
    f0ce:	ad b7       	in	r26, 0x3d	; 61
    f0d0:	be b7       	in	r27, 0x3e	; 62
    f0d2:	12 96       	adiw	r26, 0x02	; 2
    f0d4:	9c 93       	st	X, r25
    f0d6:	8e 93       	st	-X, r24
    f0d8:	11 97       	sbiw	r26, 0x01	; 1
    f0da:	84 eb       	ldi	r24, 0xB4	; 180
    f0dc:	98 e1       	ldi	r25, 0x18	; 24
    f0de:	14 96       	adiw	r26, 0x04	; 4
    f0e0:	9c 93       	st	X, r25
    f0e2:	8e 93       	st	-X, r24
    f0e4:	13 97       	sbiw	r26, 0x03	; 3
    f0e6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
    f0ea:	83 e0       	ldi	r24, 0x03	; 3
    f0ec:	80 93 4c 02 	sts	0x024C, r24
    f0f0:	80 e0       	ldi	r24, 0x00	; 0
    f0f2:	0f 90       	pop	r0
    f0f4:	0f 90       	pop	r0
    f0f6:	0f 90       	pop	r0
    f0f8:	0f 90       	pop	r0
    f0fa:	85 c1       	rjmp	.+778    	; 0xf406 <FMenuMaster+0x5f2>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
    f0fc:	81 e0       	ldi	r24, 0x01	; 1
    f0fe:	62 e0       	ldi	r22, 0x02	; 2
    f100:	41 e0       	ldi	r20, 0x01	; 1
    f102:	22 e9       	ldi	r18, 0x92	; 146
    f104:	35 e0       	ldi	r19, 0x05	; 5
    f106:	00 e0       	ldi	r16, 0x00	; 0
    f108:	10 e0       	ldi	r17, 0x00	; 0
    f10a:	ba e0       	ldi	r27, 0x0A	; 10
    f10c:	eb 2e       	mov	r14, r27
    f10e:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  switch(uiResult){
    f112:	83 30       	cpi	r24, 0x03	; 3
    f114:	49 f0       	breq	.+18     	; 0xf128 <FMenuMaster+0x314>
    f116:	84 30       	cpi	r24, 0x04	; 4
    f118:	08 f4       	brcc	.+2      	; 0xf11c <FMenuMaster+0x308>
    f11a:	ed c0       	rjmp	.+474    	; 0xf2f6 <FMenuMaster+0x4e2>
    f11c:	84 30       	cpi	r24, 0x04	; 4
    f11e:	69 f0       	breq	.+26     	; 0xf13a <FMenuMaster+0x326>
    f120:	85 30       	cpi	r24, 0x05	; 5
    f122:	09 f0       	breq	.+2      	; 0xf126 <FMenuMaster+0x312>
    f124:	6f c1       	rjmp	.+734    	; 0xf404 <FMenuMaster+0x5f0>
    f126:	0e c0       	rjmp	.+28     	; 0xf144 <FMenuMaster+0x330>
		  case USER_OK:               
			   //uart_printf(1,0,PSTR("GeniusCode: "));
			   //uart_print(1,1,strGeniusCode);
		       _datetime(0, strSystemDate, strSystemTime);
    f128:	80 e0       	ldi	r24, 0x00	; 0
    f12a:	6a eb       	ldi	r22, 0xBA	; 186
    f12c:	73 e0       	ldi	r23, 0x03	; 3
    f12e:	44 e7       	ldi	r20, 0x74	; 116
    f130:	58 e0       	ldi	r21, 0x08	; 8
    f132:	0e 94 e3 ac 	call	0x159c6	; 0x159c6 <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
    f136:	84 e0       	ldi	r24, 0x04	; 4
    f138:	ba ce       	rjmp	.-652    	; 0xeeae <FMenuMaster+0x9a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    f13a:	84 e0       	ldi	r24, 0x04	; 4
    f13c:	61 e0       	ldi	r22, 0x01	; 1
    f13e:	4f e9       	ldi	r20, 0x9F	; 159
    f140:	58 e1       	ldi	r21, 0x18	; 24
    f142:	ee c0       	rjmp	.+476    	; 0xf320 <FMenuMaster+0x50c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    f144:	84 e0       	ldi	r24, 0x04	; 4
    f146:	61 e0       	ldi	r22, 0x01	; 1
    f148:	4a e8       	ldi	r20, 0x8A	; 138
    f14a:	58 e1       	ldi	r21, 0x18	; 24
    f14c:	e9 c0       	rjmp	.+466    	; 0xf320 <FMenuMaster+0x50c>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
    f14e:	00 d0       	rcall	.+0      	; 0xf150 <FMenuMaster+0x33c>
    f150:	00 d0       	rcall	.+0      	; 0xf152 <FMenuMaster+0x33e>
    f152:	00 d0       	rcall	.+0      	; 0xf154 <FMenuMaster+0x340>
    f154:	ed b7       	in	r30, 0x3d	; 61
    f156:	fe b7       	in	r31, 0x3e	; 62
    f158:	31 96       	adiw	r30, 0x01	; 1
    f15a:	8e 01       	movw	r16, r28
    f15c:	05 5f       	subi	r16, 0xF5	; 245
    f15e:	1f 4f       	sbci	r17, 0xFF	; 255
    f160:	ad b7       	in	r26, 0x3d	; 61
    f162:	be b7       	in	r27, 0x3e	; 62
    f164:	12 96       	adiw	r26, 0x02	; 2
    f166:	1c 93       	st	X, r17
    f168:	0e 93       	st	-X, r16
    f16a:	11 97       	sbiw	r26, 0x01	; 1
    f16c:	87 e8       	ldi	r24, 0x87	; 135
    f16e:	98 e1       	ldi	r25, 0x18	; 24
    f170:	93 83       	std	Z+3, r25	; 0x03
    f172:	82 83       	std	Z+2, r24	; 0x02
    f174:	8a eb       	ldi	r24, 0xBA	; 186
    f176:	93 e0       	ldi	r25, 0x03	; 3
    f178:	95 83       	std	Z+5, r25	; 0x05
    f17a:	84 83       	std	Z+4, r24	; 0x04
    f17c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  RemoveChar(PDate,'/');
    f180:	ed b7       	in	r30, 0x3d	; 61
    f182:	fe b7       	in	r31, 0x3e	; 62
    f184:	36 96       	adiw	r30, 0x06	; 6
    f186:	0f b6       	in	r0, 0x3f	; 63
    f188:	f8 94       	cli
    f18a:	fe bf       	out	0x3e, r31	; 62
    f18c:	0f be       	out	0x3f, r0	; 63
    f18e:	ed bf       	out	0x3d, r30	; 61
    f190:	c8 01       	movw	r24, r16
    f192:	6f e2       	ldi	r22, 0x2F	; 47
    f194:	0e 94 b9 33 	call	0x6772	; 0x6772 <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
    f198:	c8 01       	movw	r24, r16
    f19a:	62 e9       	ldi	r22, 0x92	; 146
    f19c:	75 e0       	ldi	r23, 0x05	; 5
    f19e:	0e 94 b0 49 	call	0x9360	; 0x9360 <ValidateGeniusCode>
    f1a2:	81 30       	cpi	r24, 0x01	; 1
    f1a4:	09 f0       	breq	.+2      	; 0xf1a8 <FMenuMaster+0x394>
    f1a6:	44 c0       	rjmp	.+136    	; 0xf230 <FMenuMaster+0x41c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
    f1a8:	00 d0       	rcall	.+0      	; 0xf1aa <FMenuMaster+0x396>
    f1aa:	00 d0       	rcall	.+0      	; 0xf1ac <FMenuMaster+0x398>
    f1ac:	00 d0       	rcall	.+0      	; 0xf1ae <FMenuMaster+0x39a>
    f1ae:	ed b7       	in	r30, 0x3d	; 61
    f1b0:	fe b7       	in	r31, 0x3e	; 62
    f1b2:	31 96       	adiw	r30, 0x01	; 1
    f1b4:	8e 01       	movw	r16, r28
    f1b6:	0f 5f       	subi	r16, 0xFF	; 255
    f1b8:	1f 4f       	sbci	r17, 0xFF	; 255
    f1ba:	ad b7       	in	r26, 0x3d	; 61
    f1bc:	be b7       	in	r27, 0x3e	; 62
    f1be:	12 96       	adiw	r26, 0x02	; 2
    f1c0:	1c 93       	st	X, r17
    f1c2:	0e 93       	st	-X, r16
    f1c4:	11 97       	sbiw	r26, 0x01	; 1
    f1c6:	84 e8       	ldi	r24, 0x84	; 132
    f1c8:	98 e1       	ldi	r25, 0x18	; 24
    f1ca:	93 83       	std	Z+3, r25	; 0x03
    f1cc:	82 83       	std	Z+2, r24	; 0x02
    f1ce:	84 e7       	ldi	r24, 0x74	; 116
    f1d0:	98 e0       	ldi	r25, 0x08	; 8
    f1d2:	95 83       	std	Z+5, r25	; 0x05
    f1d4:	84 83       	std	Z+4, r24	; 0x04
    f1d6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
    f1da:	ed b7       	in	r30, 0x3d	; 61
    f1dc:	fe b7       	in	r31, 0x3e	; 62
    f1de:	36 96       	adiw	r30, 0x06	; 6
    f1e0:	0f b6       	in	r0, 0x3f	; 63
    f1e2:	f8 94       	cli
    f1e4:	fe bf       	out	0x3e, r31	; 62
    f1e6:	0f be       	out	0x3f, r0	; 63
    f1e8:	ed bf       	out	0x3d, r30	; 61
    f1ea:	c8 01       	movw	r24, r16
    f1ec:	6a e3       	ldi	r22, 0x3A	; 58
    f1ee:	0e 94 b9 33 	call	0x6772	; 0x6772 <RemoveChar>
    f1f2:	00 d0       	rcall	.+0      	; 0xf1f4 <FMenuMaster+0x3e0>
    f1f4:	00 d0       	rcall	.+0      	; 0xf1f6 <FMenuMaster+0x3e2>
    f1f6:	a0 ed       	ldi	r26, 0xD0	; 208
    f1f8:	ea 2e       	mov	r14, r26
    f1fa:	a7 e0       	ldi	r26, 0x07	; 7
    f1fc:	fa 2e       	mov	r15, r26
    f1fe:	ad b7       	in	r26, 0x3d	; 61
    f200:	be b7       	in	r27, 0x3e	; 62
    f202:	12 96       	adiw	r26, 0x02	; 2
    f204:	fc 92       	st	X, r15
    f206:	ee 92       	st	-X, r14
    f208:	11 97       	sbiw	r26, 0x01	; 1
    f20a:	83 e8       	ldi	r24, 0x83	; 131
    f20c:	98 e1       	ldi	r25, 0x18	; 24
    f20e:	14 96       	adiw	r26, 0x04	; 4
    f210:	9c 93       	st	X, r25
    f212:	8e 93       	st	-X, r24
    f214:	13 97       	sbiw	r26, 0x03	; 3
    f216:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
    f21a:	0f 90       	pop	r0
    f21c:	0f 90       	pop	r0
    f21e:	0f 90       	pop	r0
    f220:	0f 90       	pop	r0
    f222:	c8 01       	movw	r24, r16
    f224:	62 e9       	ldi	r22, 0x92	; 146
    f226:	75 e0       	ldi	r23, 0x05	; 5
    f228:	a7 01       	movw	r20, r14
    f22a:	0e 94 7a 34 	call	0x68f4	; 0x68f4 <GenerateKeyStamp>
    f22e:	d0 c0       	rjmp	.+416    	; 0xf3d0 <FMenuMaster+0x5bc>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
    f230:	85 e0       	ldi	r24, 0x05	; 5
    f232:	3d ce       	rjmp	.-902    	; 0xeeae <FMenuMaster+0x9a>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    f234:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    f236:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    f238:	81 e0       	ldi	r24, 0x01	; 1
    f23a:	80 93 bc 01 	sts	0x01BC, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
    f23e:	83 e0       	ldi	r24, 0x03	; 3
    f240:	61 e0       	ldi	r22, 0x01	; 1
    f242:	4e e6       	ldi	r20, 0x6E	; 110
    f244:	58 e1       	ldi	r21, 0x18	; 24
    f246:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          TimDisplay=0; 
    f24a:	10 92 92 01 	sts	0x0192, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
    f24e:	86 e0       	ldi	r24, 0x06	; 6
    f250:	2e ce       	rjmp	.-932    	; 0xeeae <FMenuMaster+0x9a>
	      break;

     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
    f252:	80 91 92 01 	lds	r24, 0x0192
    f256:	86 30       	cpi	r24, 0x06	; 6
    f258:	08 f4       	brcc	.+2      	; 0xf25c <FMenuMaster+0x448>
    f25a:	d4 c0       	rjmp	.+424    	; 0xf404 <FMenuMaster+0x5f0>
    f25c:	82 e0       	ldi	r24, 0x02	; 2
    f25e:	27 ce       	rjmp	.-946    	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
    f260:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
    f264:	00 d0       	rcall	.+0      	; 0xf266 <FMenuMaster+0x452>
    f266:	00 d0       	rcall	.+0      	; 0xf268 <FMenuMaster+0x454>
    f268:	00 d0       	rcall	.+0      	; 0xf26a <FMenuMaster+0x456>
    f26a:	ed b7       	in	r30, 0x3d	; 61
    f26c:	fe b7       	in	r31, 0x3e	; 62
    f26e:	31 96       	adiw	r30, 0x01	; 1
    f270:	8e 01       	movw	r16, r28
    f272:	01 5e       	subi	r16, 0xE1	; 225
    f274:	1f 4f       	sbci	r17, 0xFF	; 255
    f276:	ad b7       	in	r26, 0x3d	; 61
    f278:	be b7       	in	r27, 0x3e	; 62
    f27a:	12 96       	adiw	r26, 0x02	; 2
    f27c:	1c 93       	st	X, r17
    f27e:	0e 93       	st	-X, r16
    f280:	11 97       	sbiw	r26, 0x01	; 1
    f282:	80 e6       	ldi	r24, 0x60	; 96
    f284:	98 e1       	ldi	r25, 0x18	; 24
    f286:	93 83       	std	Z+3, r25	; 0x03
    f288:	82 83       	std	Z+2, r24	; 0x02
    f28a:	80 ed       	ldi	r24, 0xD0	; 208
    f28c:	97 e0       	ldi	r25, 0x07	; 7
    f28e:	95 83       	std	Z+5, r25	; 0x05
    f290:	84 83       	std	Z+4, r24	; 0x04
    f292:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(1,1,lcdteks);
    f296:	ed b7       	in	r30, 0x3d	; 61
    f298:	fe b7       	in	r31, 0x3e	; 62
    f29a:	36 96       	adiw	r30, 0x06	; 6
    f29c:	0f b6       	in	r0, 0x3f	; 63
    f29e:	f8 94       	cli
    f2a0:	fe bf       	out	0x3e, r31	; 62
    f2a2:	0f be       	out	0x3f, r0	; 63
    f2a4:	ed bf       	out	0x3d, r30	; 61
    f2a6:	81 e0       	ldi	r24, 0x01	; 1
    f2a8:	61 e0       	ldi	r22, 0x01	; 1
    f2aa:	a8 01       	movw	r20, r16
    f2ac:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
    f2b0:	82 e0       	ldi	r24, 0x02	; 2
    f2b2:	61 e0       	ldi	r22, 0x01	; 1
    f2b4:	4b e4       	ldi	r20, 0x4B	; 75
    f2b6:	58 e1       	ldi	r21, 0x18	; 24
    f2b8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
    f2bc:	83 e0       	ldi	r24, 0x03	; 3
    f2be:	61 e0       	ldi	r22, 0x01	; 1
    f2c0:	46 e3       	ldi	r20, 0x36	; 54
    f2c2:	58 e1       	ldi	r21, 0x18	; 24
    f2c4:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    f2c8:	84 e0       	ldi	r24, 0x04	; 4
    f2ca:	61 e0       	ldi	r22, 0x01	; 1
    f2cc:	41 e2       	ldi	r20, 0x21	; 33
    f2ce:	58 e1       	ldi	r21, 0x18	; 24
    f2d0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
    f2d4:	88 e0       	ldi	r24, 0x08	; 8
    f2d6:	eb cd       	rjmp	.-1066   	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
    f2d8:	81 e0       	ldi	r24, 0x01	; 1
    f2da:	63 e0       	ldi	r22, 0x03	; 3
    f2dc:	41 e0       	ldi	r20, 0x01	; 1
    f2de:	2b e5       	ldi	r18, 0x5B	; 91
    f2e0:	3c e0       	ldi	r19, 0x0C	; 12
    f2e2:	00 e0       	ldi	r16, 0x00	; 0
    f2e4:	10 e0       	ldi	r17, 0x00	; 0
    f2e6:	fa e0       	ldi	r31, 0x0A	; 10
    f2e8:	ef 2e       	mov	r14, r31
    f2ea:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  switch(uiResult){
    f2ee:	83 30       	cpi	r24, 0x03	; 3
    f2f0:	61 f0       	breq	.+24     	; 0xf30a <FMenuMaster+0x4f6>
    f2f2:	84 30       	cpi	r24, 0x04	; 4
    f2f4:	20 f4       	brcc	.+8      	; 0xf2fe <FMenuMaster+0x4ea>
    f2f6:	81 30       	cpi	r24, 0x01	; 1
    f2f8:	09 f0       	breq	.+2      	; 0xf2fc <FMenuMaster+0x4e8>
    f2fa:	84 c0       	rjmp	.+264    	; 0xf404 <FMenuMaster+0x5f0>
    f2fc:	d7 cd       	rjmp	.-1106   	; 0xeeac <FMenuMaster+0x98>
    f2fe:	84 30       	cpi	r24, 0x04	; 4
    f300:	31 f0       	breq	.+12     	; 0xf30e <FMenuMaster+0x4fa>
    f302:	85 30       	cpi	r24, 0x05	; 5
    f304:	09 f0       	breq	.+2      	; 0xf308 <FMenuMaster+0x4f4>
    f306:	7e c0       	rjmp	.+252    	; 0xf404 <FMenuMaster+0x5f0>
    f308:	07 c0       	rjmp	.+14     	; 0xf318 <FMenuMaster+0x504>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
    f30a:	89 e0       	ldi	r24, 0x09	; 9
    f30c:	d0 cd       	rjmp	.-1120   	; 0xeeae <FMenuMaster+0x9a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    f30e:	84 e0       	ldi	r24, 0x04	; 4
    f310:	61 e0       	ldi	r22, 0x01	; 1
    f312:	4c e0       	ldi	r20, 0x0C	; 12
    f314:	58 e1       	ldi	r21, 0x18	; 24
    f316:	04 c0       	rjmp	.+8      	; 0xf320 <FMenuMaster+0x50c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    f318:	84 e0       	ldi	r24, 0x04	; 4
    f31a:	61 e0       	ldi	r22, 0x01	; 1
    f31c:	47 ef       	ldi	r20, 0xF7	; 247
    f31e:	57 e1       	ldi	r21, 0x17	; 23
    f320:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    f324:	6f c0       	rjmp	.+222    	; 0xf404 <FMenuMaster+0x5f0>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
    f326:	80 ed       	ldi	r24, 0xD0	; 208
    f328:	97 e0       	ldi	r25, 0x07	; 7
    f32a:	6b e5       	ldi	r22, 0x5B	; 91
    f32c:	7c e0       	ldi	r23, 0x0C	; 12
    f32e:	0e 94 8e 49 	call	0x931c	; 0x931c <ValidateRestoreCode>
    f332:	81 30       	cpi	r24, 0x01	; 1
    f334:	11 f4       	brne	.+4      	; 0xf33a <FMenuMaster+0x526>
		      stMenuMaster=mmRestorePassword;
    f336:	8c e0       	ldi	r24, 0x0C	; 12
    f338:	ba cd       	rjmp	.-1164   	; 0xeeae <FMenuMaster+0x9a>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
    f33a:	8a e0       	ldi	r24, 0x0A	; 10
    f33c:	b8 cd       	rjmp	.-1168   	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
    f33e:	00 d0       	rcall	.+0      	; 0xf340 <FMenuMaster+0x52c>
    f340:	00 d0       	rcall	.+0      	; 0xf342 <FMenuMaster+0x52e>
    f342:	8e 01       	movw	r16, r28
    f344:	0b 5e       	subi	r16, 0xEB	; 235
    f346:	1f 4f       	sbci	r17, 0xFF	; 255
    f348:	ad b7       	in	r26, 0x3d	; 61
    f34a:	be b7       	in	r27, 0x3e	; 62
    f34c:	12 96       	adiw	r26, 0x02	; 2
    f34e:	1c 93       	st	X, r17
    f350:	0e 93       	st	-X, r16
    f352:	11 97       	sbiw	r26, 0x01	; 1
    f354:	81 ef       	ldi	r24, 0xF1	; 241
    f356:	97 e1       	ldi	r25, 0x17	; 23
    f358:	14 96       	adiw	r26, 0x04	; 4
    f35a:	9c 93       	st	X, r25
    f35c:	8e 93       	st	-X, r24
    f35e:	13 97       	sbiw	r26, 0x03	; 3
    f360:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    f364:	0f 90       	pop	r0
    f366:	0f 90       	pop	r0
    f368:	0f 90       	pop	r0
    f36a:	0f 90       	pop	r0
    f36c:	81 e0       	ldi	r24, 0x01	; 1
    f36e:	90 e0       	ldi	r25, 0x00	; 0
    f370:	b8 01       	movw	r22, r16
    f372:	4a e0       	ldi	r20, 0x0A	; 10
    f374:	50 e0       	ldi	r21, 0x00	; 0
    f376:	2a ed       	ldi	r18, 0xDA	; 218
    f378:	33 e1       	ldi	r19, 0x13	; 19
    f37a:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
    f37e:	00 d0       	rcall	.+0      	; 0xf380 <FMenuMaster+0x56c>
    f380:	00 d0       	rcall	.+0      	; 0xf382 <FMenuMaster+0x56e>
    f382:	ed b7       	in	r30, 0x3d	; 61
    f384:	fe b7       	in	r31, 0x3e	; 62
    f386:	12 83       	std	Z+2, r17	; 0x02
    f388:	01 83       	std	Z+1, r16	; 0x01
    f38a:	8b ee       	ldi	r24, 0xEB	; 235
    f38c:	97 e1       	ldi	r25, 0x17	; 23
    f38e:	94 83       	std	Z+4, r25	; 0x04
    f390:	83 83       	std	Z+3, r24	; 0x03
    f392:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    f396:	0f 90       	pop	r0
    f398:	0f 90       	pop	r0
    f39a:	0f 90       	pop	r0
    f39c:	0f 90       	pop	r0
    f39e:	8b e0       	ldi	r24, 0x0B	; 11
    f3a0:	90 e0       	ldi	r25, 0x00	; 0
    f3a2:	b8 01       	movw	r22, r16
    f3a4:	4a e0       	ldi	r20, 0x0A	; 10
    f3a6:	50 e0       	ldi	r21, 0x00	; 0
    f3a8:	2a ed       	ldi	r18, 0xDA	; 218
    f3aa:	33 e1       	ldi	r19, 0x13	; 19
    f3ac:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
    f3b0:	8d e0       	ldi	r24, 0x0D	; 13
    f3b2:	7d cd       	rjmp	.-1286   	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
    f3b4:	83 e0       	ldi	r24, 0x03	; 3
    f3b6:	61 e0       	ldi	r22, 0x01	; 1
    f3b8:	49 ed       	ldi	r20, 0xD9	; 217
    f3ba:	57 e1       	ldi	r21, 0x17	; 23
    f3bc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  TimDisplay=0;
    f3c0:	10 92 92 01 	sts	0x0192, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
    f3c4:	8b e0       	ldi	r24, 0x0B	; 11
    f3c6:	73 cd       	rjmp	.-1306   	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
    f3c8:	80 91 92 01 	lds	r24, 0x0192
    f3cc:	86 30       	cpi	r24, 0x06	; 6
    f3ce:	d0 f0       	brcs	.+52     	; 0xf404 <FMenuMaster+0x5f0>
    f3d0:	87 e0       	ldi	r24, 0x07	; 7
    f3d2:	6d cd       	rjmp	.-1318   	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
    f3d4:	83 e0       	ldi	r24, 0x03	; 3
    f3d6:	61 e0       	ldi	r22, 0x01	; 1
    f3d8:	47 ec       	ldi	r20, 0xC7	; 199
    f3da:	57 e1       	ldi	r21, 0x17	; 23
    f3dc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    f3e0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    f3e2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    f3e4:	81 e0       	ldi	r24, 0x01	; 1
    f3e6:	80 93 bc 01 	sts	0x01BC, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
    f3ea:	10 92 92 01 	sts	0x0192, r1
          stMenuMaster=mmDelayExit;
    f3ee:	8f e0       	ldi	r24, 0x0F	; 15
    f3f0:	5e cd       	rjmp	.-1348   	; 0xeeae <FMenuMaster+0x9a>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
    f3f2:	80 91 92 01 	lds	r24, 0x0192
    f3f6:	85 30       	cpi	r24, 0x05	; 5
    f3f8:	28 f0       	brcs	.+10     	; 0xf404 <FMenuMaster+0x5f0>
    f3fa:	58 cd       	rjmp	.-1360   	; 0xeeac <FMenuMaster+0x98>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
    f3fc:	10 92 4c 02 	sts	0x024C, r1
    f400:	81 e0       	ldi	r24, 0x01	; 1
    f402:	01 c0       	rjmp	.+2      	; 0xf406 <FMenuMaster+0x5f2>
    f404:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
    f406:	e2 96       	adiw	r28, 0x32	; 50
    f408:	0f b6       	in	r0, 0x3f	; 63
    f40a:	f8 94       	cli
    f40c:	de bf       	out	0x3e, r29	; 62
    f40e:	0f be       	out	0x3f, r0	; 63
    f410:	cd bf       	out	0x3d, r28	; 61
    f412:	cf 91       	pop	r28
    f414:	df 91       	pop	r29
    f416:	1f 91       	pop	r17
    f418:	0f 91       	pop	r16
    f41a:	ff 90       	pop	r15
    f41c:	ef 90       	pop	r14
    f41e:	df 90       	pop	r13
    f420:	cf 90       	pop	r12
    f422:	08 95       	ret

0000f424 <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
    f424:	af 92       	push	r10
    f426:	bf 92       	push	r11
    f428:	cf 92       	push	r12
    f42a:	df 92       	push	r13
    f42c:	ef 92       	push	r14
    f42e:	0f 93       	push	r16
    f430:	1f 93       	push	r17
    f432:	df 93       	push	r29
    f434:	cf 93       	push	r28
    f436:	cd b7       	in	r28, 0x3d	; 61
    f438:	de b7       	in	r29, 0x3e	; 62
    f43a:	6e 97       	sbiw	r28, 0x1e	; 30
    f43c:	0f b6       	in	r0, 0x3f	; 63
    f43e:	f8 94       	cli
    f440:	de bf       	out	0x3e, r29	; 62
    f442:	0f be       	out	0x3f, r0	; 63
    f444:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,strPassword[10],PassStatus=MP_NONE;;
       char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];
       char uiResult;

     Result=MP_NONE;
     switch(stMenuPasword){
    f446:	e0 90 58 02 	lds	r14, 0x0258
    f44a:	81 e0       	ldi	r24, 0x01	; 1
    f44c:	e8 16       	cp	r14, r24
    f44e:	01 f1       	breq	.+64     	; 0xf490 <FMenuPassword+0x6c>
    f450:	e8 16       	cp	r14, r24
    f452:	40 f0       	brcs	.+16     	; 0xf464 <FMenuPassword+0x40>
    f454:	e2 e0       	ldi	r30, 0x02	; 2
    f456:	ee 16       	cp	r14, r30
    f458:	e9 f1       	breq	.+122    	; 0xf4d4 <FMenuPassword+0xb0>
    f45a:	f3 e0       	ldi	r31, 0x03	; 3
    f45c:	ef 16       	cp	r14, r31
    f45e:	09 f0       	breq	.+2      	; 0xf462 <FMenuPassword+0x3e>
    f460:	90 c0       	rjmp	.+288    	; 0xf582 <FMenuPassword+0x15e>
    f462:	8a c0       	rjmp	.+276    	; 0xf578 <FMenuPassword+0x154>
	 case mpInitPassword:
	      lcd_clear();
    f464:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
    f468:	81 e0       	ldi	r24, 0x01	; 1
    f46a:	61 e0       	ldi	r22, 0x01	; 1
    f46c:	40 e6       	ldi	r20, 0x60	; 96
    f46e:	5a e1       	ldi	r21, 0x1A	; 26
    f470:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
    f474:	82 e0       	ldi	r24, 0x02	; 2
    f476:	61 e0       	ldi	r22, 0x01	; 1
    f478:	4e e5       	ldi	r20, 0x5E	; 94
    f47a:	5a e1       	ldi	r21, 0x1A	; 26
    f47c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    f480:	84 e0       	ldi	r24, 0x04	; 4
    f482:	61 e0       	ldi	r22, 0x01	; 1
    f484:	49 e4       	ldi	r20, 0x49	; 73
    f486:	5a e1       	ldi	r21, 0x1A	; 26
    f488:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
    f48c:	81 e0       	ldi	r24, 0x01	; 1
    f48e:	71 c0       	rjmp	.+226    	; 0xf572 <FMenuPassword+0x14e>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
    f490:	84 e0       	ldi	r24, 0x04	; 4
    f492:	62 e0       	ldi	r22, 0x02	; 2
    f494:	41 e0       	ldi	r20, 0x01	; 1
    f496:	2e e4       	ldi	r18, 0x4E	; 78
    f498:	32 e0       	ldi	r19, 0x02	; 2
    f49a:	00 e0       	ldi	r16, 0x00	; 0
    f49c:	10 e0       	ldi	r17, 0x00	; 0
    f49e:	78 e0       	ldi	r23, 0x08	; 8
    f4a0:	e7 2e       	mov	r14, r23
    f4a2:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		  if (uiResult==USER_OK){
    f4a6:	83 30       	cpi	r24, 0x03	; 3
    f4a8:	11 f4       	brne	.+4      	; 0xf4ae <FMenuPassword+0x8a>
		      stMenuPasword=mpProcessPassword;
    f4aa:	82 e0       	ldi	r24, 0x02	; 2
    f4ac:	62 c0       	rjmp	.+196    	; 0xf572 <FMenuPassword+0x14e>
			  }
		  else
		  if (uiResult==USER_CANCEL){
    f4ae:	81 30       	cpi	r24, 0x01	; 1
    f4b0:	09 f4       	brne	.+2      	; 0xf4b4 <FMenuPassword+0x90>
    f4b2:	50 c0       	rjmp	.+160    	; 0xf554 <FMenuPassword+0x130>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    f4b4:	84 30       	cpi	r24, 0x04	; 4
    f4b6:	21 f4       	brne	.+8      	; 0xf4c0 <FMenuPassword+0x9c>
    f4b8:	61 e0       	ldi	r22, 0x01	; 1
    f4ba:	44 e3       	ldi	r20, 0x34	; 52
    f4bc:	5a e1       	ldi	r21, 0x1A	; 26
    f4be:	07 c0       	rjmp	.+14     	; 0xf4ce <FMenuPassword+0xaa>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    f4c0:	85 30       	cpi	r24, 0x05	; 5
    f4c2:	09 f0       	breq	.+2      	; 0xf4c6 <FMenuPassword+0xa2>
    f4c4:	5e c0       	rjmp	.+188    	; 0xf582 <FMenuPassword+0x15e>
    f4c6:	84 e0       	ldi	r24, 0x04	; 4
    f4c8:	61 e0       	ldi	r22, 0x01	; 1
    f4ca:	4f e1       	ldi	r20, 0x1F	; 31
    f4cc:	5a e1       	ldi	r21, 0x1A	; 26
    f4ce:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    f4d2:	57 c0       	rjmp	.+174    	; 0xf582 <FMenuPassword+0x15e>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
    f4d4:	00 d0       	rcall	.+0      	; 0xf4d6 <FMenuPassword+0xb2>
    f4d6:	00 d0       	rcall	.+0      	; 0xf4d8 <FMenuPassword+0xb4>
    f4d8:	8e 01       	movw	r16, r28
    f4da:	0f 5f       	subi	r16, 0xFF	; 255
    f4dc:	1f 4f       	sbci	r17, 0xFF	; 255
    f4de:	ed b7       	in	r30, 0x3d	; 61
    f4e0:	fe b7       	in	r31, 0x3e	; 62
    f4e2:	12 83       	std	Z+2, r17	; 0x02
    f4e4:	01 83       	std	Z+1, r16	; 0x01
    f4e6:	87 e1       	ldi	r24, 0x17	; 23
    f4e8:	9a e1       	ldi	r25, 0x1A	; 26
    f4ea:	94 83       	std	Z+4, r25	; 0x04
    f4ec:	83 83       	std	Z+3, r24	; 0x03
    f4ee:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    f4f2:	0f 90       	pop	r0
    f4f4:	0f 90       	pop	r0
    f4f6:	0f 90       	pop	r0
    f4f8:	0f 90       	pop	r0
    f4fa:	55 e1       	ldi	r21, 0x15	; 21
    f4fc:	c5 2e       	mov	r12, r21
    f4fe:	d1 2c       	mov	r13, r1
    f500:	cc 0e       	add	r12, r28
    f502:	dd 1e       	adc	r13, r29
    f504:	c6 01       	movw	r24, r12
    f506:	61 e0       	ldi	r22, 0x01	; 1
    f508:	70 e0       	ldi	r23, 0x00	; 0
    f50a:	4a e0       	ldi	r20, 0x0A	; 10
    f50c:	50 e0       	ldi	r21, 0x00	; 0
    f50e:	22 ed       	ldi	r18, 0xD2	; 210
    f510:	33 e1       	ldi	r19, 0x13	; 19
    f512:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
    f516:	4b e0       	ldi	r20, 0x0B	; 11
    f518:	a4 2e       	mov	r10, r20
    f51a:	b1 2c       	mov	r11, r1
    f51c:	ac 0e       	add	r10, r28
    f51e:	bd 1e       	adc	r11, r29
    f520:	c5 01       	movw	r24, r10
    f522:	6b e0       	ldi	r22, 0x0B	; 11
    f524:	70 e0       	ldi	r23, 0x00	; 0
    f526:	4a e0       	ldi	r20, 0x0A	; 10
    f528:	50 e0       	ldi	r21, 0x00	; 0
    f52a:	22 ed       	ldi	r18, 0xD2	; 210
    f52c:	33 e1       	ldi	r19, 0x13	; 19
    f52e:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
    f532:	c8 01       	movw	r24, r16
    f534:	6e e4       	ldi	r22, 0x4E	; 78
    f536:	72 e0       	ldi	r23, 0x02	; 2
    f538:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    f53c:	00 97       	sbiw	r24, 0x00	; 0
    f53e:	11 f4       	brne	.+4      	; 0xf544 <FMenuPassword+0x120>
		       PassStatus=MP_VALID_MASTER;
    f540:	83 e0       	ldi	r24, 0x03	; 3
    f542:	08 c0       	rjmp	.+16     	; 0xf554 <FMenuPassword+0x130>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
    f544:	c6 01       	movw	r24, r12
    f546:	6e e4       	ldi	r22, 0x4E	; 78
    f548:	72 e0       	ldi	r23, 0x02	; 2
    f54a:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    f54e:	00 97       	sbiw	r24, 0x00	; 0
    f550:	21 f4       	brne	.+8      	; 0xf55a <FMenuPassword+0x136>
		       PassStatus=MP_VALID_ADMIN;
    f552:	84 e0       	ldi	r24, 0x04	; 4
    f554:	80 93 4d 02 	sts	0x024D, r24
    f558:	0b c0       	rjmp	.+22     	; 0xf570 <FMenuPassword+0x14c>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
    f55a:	c5 01       	movw	r24, r10
    f55c:	6e e4       	ldi	r22, 0x4E	; 78
    f55e:	72 e0       	ldi	r23, 0x02	; 2
    f560:	0e 94 7c af 	call	0x15ef8	; 0x15ef8 <strcmp>
    f564:	00 97       	sbiw	r24, 0x00	; 0
    f566:	11 f4       	brne	.+4      	; 0xf56c <FMenuPassword+0x148>
		       PassStatus=MP_VALID_SYSTEM;
    f568:	85 e0       	ldi	r24, 0x05	; 5
    f56a:	f4 cf       	rjmp	.-24     	; 0xf554 <FMenuPassword+0x130>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
    f56c:	e0 92 4d 02 	sts	0x024D, r14
		  stMenuPasword=mpExit;
    f570:	83 e0       	ldi	r24, 0x03	; 3
    f572:	80 93 58 02 	sts	0x0258, r24
    f576:	05 c0       	rjmp	.+10     	; 0xf582 <FMenuPassword+0x15e>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
    f578:	10 92 58 02 	sts	0x0258, r1
	      Result=PassStatus;
    f57c:	80 91 4d 02 	lds	r24, 0x024D
    f580:	01 c0       	rjmp	.+2      	; 0xf584 <FMenuPassword+0x160>
    f582:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    f584:	6e 96       	adiw	r28, 0x1e	; 30
    f586:	0f b6       	in	r0, 0x3f	; 63
    f588:	f8 94       	cli
    f58a:	de bf       	out	0x3e, r29	; 62
    f58c:	0f be       	out	0x3f, r0	; 63
    f58e:	cd bf       	out	0x3d, r28	; 61
    f590:	cf 91       	pop	r28
    f592:	df 91       	pop	r29
    f594:	1f 91       	pop	r17
    f596:	0f 91       	pop	r16
    f598:	ef 90       	pop	r14
    f59a:	df 90       	pop	r13
    f59c:	cf 90       	pop	r12
    f59e:	bf 90       	pop	r11
    f5a0:	af 90       	pop	r10
    f5a2:	08 95       	ret

0000f5a4 <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
    f5a4:	28 2f       	mov	r18, r24
    f5a6:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
    f5a8:	81 50       	subi	r24, 0x01	; 1
    f5aa:	82 30       	cpi	r24, 0x02	; 2
    f5ac:	b8 f4       	brcc	.+46     	; 0xf5dc <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    f5ae:	62 30       	cpi	r22, 0x02	; 2
    f5b0:	59 f0       	breq	.+22     	; 0xf5c8 <SetBaudRate+0x24>
    f5b2:	62 30       	cpi	r22, 0x02	; 2
    f5b4:	18 f0       	brcs	.+6      	; 0xf5bc <SetBaudRate+0x18>
    f5b6:	63 30       	cpi	r22, 0x03	; 3
    f5b8:	21 f4       	brne	.+8      	; 0xf5c2 <SetBaudRate+0x1e>
    f5ba:	09 c0       	rjmp	.+18     	; 0xf5ce <SetBaudRate+0x2a>
    f5bc:	40 e8       	ldi	r20, 0x80	; 128
    f5be:	55 e2       	ldi	r21, 0x25	; 37
    f5c0:	08 c0       	rjmp	.+16     	; 0xf5d2 <SetBaudRate+0x2e>
    f5c2:	40 e0       	ldi	r20, 0x00	; 0
    f5c4:	50 e0       	ldi	r21, 0x00	; 0
    f5c6:	05 c0       	rjmp	.+10     	; 0xf5d2 <SetBaudRate+0x2e>
    f5c8:	40 e0       	ldi	r20, 0x00	; 0
    f5ca:	5b e4       	ldi	r21, 0x4B	; 75
    f5cc:	02 c0       	rjmp	.+4      	; 0xf5d2 <SetBaudRate+0x2e>
    f5ce:	4b e9       	ldi	r20, 0x9B	; 155
    f5d0:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      uart_init((ComAddr-1),brValue);
    f5d2:	60 e0       	ldi	r22, 0x00	; 0
    f5d4:	70 e0       	ldi	r23, 0x00	; 0
    f5d6:	0e 94 d4 ad 	call	0x15ba8	; 0x15ba8 <uart_init>
    f5da:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
    f5dc:	82 2f       	mov	r24, r18
    f5de:	83 50       	subi	r24, 0x03	; 3
    f5e0:	82 30       	cpi	r24, 0x02	; 2
    f5e2:	a8 f4       	brcc	.+42     	; 0xf60e <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
    f5e4:	9f 70       	andi	r25, 0x0F	; 15
    f5e6:	62 2f       	mov	r22, r18
    f5e8:	62 95       	swap	r22
    f5ea:	60 7f       	andi	r22, 0xF0	; 240
    f5ec:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
    f5ee:	80 91 80 01 	lds	r24, 0x0180
    f5f2:	88 23       	and	r24, r24
    f5f4:	49 f0       	breq	.+18     	; 0xf608 <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    f5f6:	86 e0       	ldi	r24, 0x06	; 6
    f5f8:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    f5fc:	60 93 d3 0b 	sts	0x0BD3, r22
     IsControlPooling=True;
    f600:	81 e0       	ldi	r24, 0x01	; 1
    f602:	80 93 84 01 	sts	0x0184, r24
    f606:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
    f608:	86 e0       	ldi	r24, 0x06	; 6
    f60a:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
    f60e:	08 95       	ret

0000f610 <FSettingSystem>:
	      break;
	 }
     return Result;
}

char FSettingSystem(){
    f610:	af 92       	push	r10
    f612:	bf 92       	push	r11
    f614:	cf 92       	push	r12
    f616:	df 92       	push	r13
    f618:	ef 92       	push	r14
    f61a:	ff 92       	push	r15
    f61c:	0f 93       	push	r16
    f61e:	1f 93       	push	r17
    f620:	df 93       	push	r29
    f622:	cf 93       	push	r28
    f624:	cd b7       	in	r28, 0x3d	; 61
    f626:	de b7       	in	r29, 0x3e	; 62
    f628:	64 97       	sbiw	r28, 0x14	; 20
    f62a:	0f b6       	in	r0, 0x3f	; 63
    f62c:	f8 94       	cli
    f62e:	de bf       	out	0x3e, r29	; 62
    f630:	0f be       	out	0x3f, r0	; 63
    f632:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
    f634:	80 91 1c 02 	lds	r24, 0x021C
    f638:	82 30       	cpi	r24, 0x02	; 2
    f63a:	09 f4       	brne	.+2      	; 0xf63e <FSettingSystem+0x2e>
    f63c:	cf c0       	rjmp	.+414    	; 0xf7dc <FSettingSystem+0x1cc>
    f63e:	83 30       	cpi	r24, 0x03	; 3
    f640:	30 f4       	brcc	.+12     	; 0xf64e <FSettingSystem+0x3e>
    f642:	88 23       	and	r24, r24
    f644:	71 f0       	breq	.+28     	; 0xf662 <FSettingSystem+0x52>
    f646:	81 30       	cpi	r24, 0x01	; 1
    f648:	09 f0       	breq	.+2      	; 0xf64c <FSettingSystem+0x3c>
    f64a:	6f c1       	rjmp	.+734    	; 0xf92a <FSettingSystem+0x31a>
    f64c:	7f c0       	rjmp	.+254    	; 0xf74c <FSettingSystem+0x13c>
    f64e:	84 30       	cpi	r24, 0x04	; 4
    f650:	09 f4       	brne	.+2      	; 0xf654 <FSettingSystem+0x44>
    f652:	60 c1       	rjmp	.+704    	; 0xf914 <FSettingSystem+0x304>
    f654:	84 30       	cpi	r24, 0x04	; 4
    f656:	08 f4       	brcc	.+2      	; 0xf65a <FSettingSystem+0x4a>
    f658:	2b c1       	rjmp	.+598    	; 0xf8b0 <FSettingSystem+0x2a0>
    f65a:	85 30       	cpi	r24, 0x05	; 5
    f65c:	09 f0       	breq	.+2      	; 0xf660 <FSettingSystem+0x50>
    f65e:	65 c1       	rjmp	.+714    	; 0xf92a <FSettingSystem+0x31a>
    f660:	60 c1       	rjmp	.+704    	; 0xf922 <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f662:	e1 99       	sbic	0x1c, 1	; 28
    f664:	fe cf       	rjmp	.-4      	; 0xf662 <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f666:	86 e3       	ldi	r24, 0x36	; 54
    f668:	91 e0       	ldi	r25, 0x01	; 1
    f66a:	9f bb       	out	0x1f, r25	; 31
    f66c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f66e:	e0 9a       	sbi	0x1c, 0	; 28
    f670:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
    f672:	20 93 00 01 	sts	0x0100, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f676:	e1 99       	sbic	0x1c, 1	; 28
    f678:	fe cf       	rjmp	.-4      	; 0xf676 <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f67a:	82 ec       	ldi	r24, 0xC2	; 194
    f67c:	93 e0       	ldi	r25, 0x03	; 3
    f67e:	9f bb       	out	0x1f, r25	; 31
    f680:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f682:	e0 9a       	sbi	0x1c, 0	; 28
    f684:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
    f686:	22 23       	and	r18, r18
    f688:	69 f4       	brne	.+26     	; 0xf6a4 <FSettingSystem+0x94>
    f68a:	00 d0       	rcall	.+0      	; 0xf68c <FSettingSystem+0x7c>
    f68c:	00 d0       	rcall	.+0      	; 0xf68e <FSettingSystem+0x7e>
    f68e:	ce 01       	movw	r24, r28
    f690:	01 96       	adiw	r24, 0x01	; 1
    f692:	ad b7       	in	r26, 0x3d	; 61
    f694:	be b7       	in	r27, 0x3e	; 62
    f696:	12 96       	adiw	r26, 0x02	; 2
    f698:	9c 93       	st	X, r25
    f69a:	8e 93       	st	-X, r24
    f69c:	11 97       	sbiw	r26, 0x01	; 1
    f69e:	80 ec       	ldi	r24, 0xC0	; 192
    f6a0:	9f e0       	ldi	r25, 0x0F	; 15
    f6a2:	1d c0       	rjmp	.+58     	; 0xf6de <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
    f6a4:	21 30       	cpi	r18, 0x01	; 1
    f6a6:	69 f4       	brne	.+26     	; 0xf6c2 <FSettingSystem+0xb2>
    f6a8:	00 d0       	rcall	.+0      	; 0xf6aa <FSettingSystem+0x9a>
    f6aa:	00 d0       	rcall	.+0      	; 0xf6ac <FSettingSystem+0x9c>
    f6ac:	ce 01       	movw	r24, r28
    f6ae:	01 96       	adiw	r24, 0x01	; 1
    f6b0:	ed b7       	in	r30, 0x3d	; 61
    f6b2:	fe b7       	in	r31, 0x3e	; 62
    f6b4:	92 83       	std	Z+2, r25	; 0x02
    f6b6:	81 83       	std	Z+1, r24	; 0x01
    f6b8:	83 eb       	ldi	r24, 0xB3	; 179
    f6ba:	9f e0       	ldi	r25, 0x0F	; 15
    f6bc:	94 83       	std	Z+4, r25	; 0x04
    f6be:	83 83       	std	Z+3, r24	; 0x03
    f6c0:	12 c0       	rjmp	.+36     	; 0xf6e6 <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
    f6c2:	22 30       	cpi	r18, 0x02	; 2
    f6c4:	b1 f4       	brne	.+44     	; 0xf6f2 <FSettingSystem+0xe2>
    f6c6:	00 d0       	rcall	.+0      	; 0xf6c8 <FSettingSystem+0xb8>
    f6c8:	00 d0       	rcall	.+0      	; 0xf6ca <FSettingSystem+0xba>
    f6ca:	ce 01       	movw	r24, r28
    f6cc:	01 96       	adiw	r24, 0x01	; 1
    f6ce:	ad b7       	in	r26, 0x3d	; 61
    f6d0:	be b7       	in	r27, 0x3e	; 62
    f6d2:	12 96       	adiw	r26, 0x02	; 2
    f6d4:	9c 93       	st	X, r25
    f6d6:	8e 93       	st	-X, r24
    f6d8:	11 97       	sbiw	r26, 0x01	; 1
    f6da:	81 ea       	ldi	r24, 0xA1	; 161
    f6dc:	9f e0       	ldi	r25, 0x0F	; 15
    f6de:	14 96       	adiw	r26, 0x04	; 4
    f6e0:	9c 93       	st	X, r25
    f6e2:	8e 93       	st	-X, r24
    f6e4:	13 97       	sbiw	r26, 0x03	; 3
    f6e6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
    f6ea:	0f 90       	pop	r0
    f6ec:	0f 90       	pop	r0
    f6ee:	0f 90       	pop	r0
    f6f0:	0f 90       	pop	r0

	      lcd_clear();
    f6f2:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_print(1,1,lcdteks);
    f6f6:	81 e0       	ldi	r24, 0x01	; 1
    f6f8:	61 e0       	ldi	r22, 0x01	; 1
    f6fa:	ae 01       	movw	r20, r28
    f6fc:	4f 5f       	subi	r20, 0xFF	; 255
    f6fe:	5f 4f       	sbci	r21, 0xFF	; 255
    f700:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
    f704:	82 e0       	ldi	r24, 0x02	; 2
    f706:	61 e0       	ldi	r22, 0x01	; 1
    f708:	46 e9       	ldi	r20, 0x96	; 150
    f70a:	5f e0       	ldi	r21, 0x0F	; 15
    f70c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
    f710:	11 23       	and	r17, r17
    f712:	29 f4       	brne	.+10     	; 0xf71e <FSettingSystem+0x10e>
    f714:	83 e0       	ldi	r24, 0x03	; 3
    f716:	61 e0       	ldi	r22, 0x01	; 1
    f718:	4b e8       	ldi	r20, 0x8B	; 139
    f71a:	5f e0       	ldi	r21, 0x0F	; 15
    f71c:	0d c0       	rjmp	.+26     	; 0xf738 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
    f71e:	11 30       	cpi	r17, 0x01	; 1
    f720:	29 f4       	brne	.+10     	; 0xf72c <FSettingSystem+0x11c>
    f722:	83 e0       	ldi	r24, 0x03	; 3
    f724:	61 e0       	ldi	r22, 0x01	; 1
    f726:	40 e8       	ldi	r20, 0x80	; 128
    f728:	5f e0       	ldi	r21, 0x0F	; 15
    f72a:	06 c0       	rjmp	.+12     	; 0xf738 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
    f72c:	12 30       	cpi	r17, 0x02	; 2
    f72e:	31 f4       	brne	.+12     	; 0xf73c <FSettingSystem+0x12c>
    f730:	83 e0       	ldi	r24, 0x03	; 3
    f732:	61 e0       	ldi	r22, 0x01	; 1
    f734:	45 e7       	ldi	r20, 0x75	; 117
    f736:	5f e0       	ldi	r21, 0x0F	; 15
    f738:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
    f73c:	84 e0       	ldi	r24, 0x04	; 4
    f73e:	61 e0       	ldi	r22, 0x01	; 1
    f740:	47 e6       	ldi	r20, 0x67	; 103
    f742:	5f e0       	ldi	r21, 0x0F	; 15
    f744:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stSettingSytem=ssMenuSelect;
    f748:	81 e0       	ldi	r24, 0x01	; 1
    f74a:	e1 c0       	rjmp	.+450    	; 0xf90e <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
    f74c:	81 e0       	ldi	r24, 0x01	; 1
    f74e:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    f752:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  if (KeyChar=='1'){
    f756:	81 33       	cpi	r24, 0x31	; 49
    f758:	c1 f4       	brne	.+48     	; 0xf78a <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
    f75a:	80 91 00 01 	lds	r24, 0x0100
    f75e:	90 e0       	ldi	r25, 0x00	; 0
    f760:	01 96       	adiw	r24, 0x01	; 1
    f762:	63 e0       	ldi	r22, 0x03	; 3
    f764:	70 e0       	ldi	r23, 0x00	; 0
    f766:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    f76a:	80 93 00 01 	sts	0x0100, r24
			  SendSlaveCommand(IFType,DispenserBrand);
    f76e:	60 91 5e 01 	lds	r22, 0x015E
    f772:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
    f776:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f77a:	e1 99       	sbic	0x1c, 1	; 28
    f77c:	fe cf       	rjmp	.-4      	; 0xf77a <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f77e:	86 e3       	ldi	r24, 0x36	; 54
    f780:	91 e0       	ldi	r25, 0x01	; 1
    f782:	9f bb       	out	0x1f, r25	; 31
    f784:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    f786:	2d bb       	out	0x1d, r18	; 29
    f788:	1f c0       	rjmp	.+62     	; 0xf7c8 <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
    f78a:	82 33       	cpi	r24, 0x32	; 50
    f78c:	09 f4       	brne	.+2      	; 0xf790 <FSettingSystem+0x180>
    f78e:	ba c0       	rjmp	.+372    	; 0xf904 <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
    f790:	83 33       	cpi	r24, 0x33	; 51
    f792:	01 f5       	brne	.+64     	; 0xf7d4 <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f794:	e1 99       	sbic	0x1c, 1	; 28
    f796:	fe cf       	rjmp	.-4      	; 0xf794 <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f798:	a2 ec       	ldi	r26, 0xC2	; 194
    f79a:	ea 2e       	mov	r14, r26
    f79c:	a3 e0       	ldi	r26, 0x03	; 3
    f79e:	fa 2e       	mov	r15, r26
    f7a0:	ff ba       	out	0x1f, r15	; 31
    f7a2:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f7a4:	e0 9a       	sbi	0x1c, 0	; 28
    f7a6:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
    f7a8:	90 e0       	ldi	r25, 0x00	; 0
    f7aa:	01 96       	adiw	r24, 0x01	; 1
    f7ac:	63 e0       	ldi	r22, 0x03	; 3
    f7ae:	70 e0       	ldi	r23, 0x00	; 0
    f7b0:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    f7b4:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
    f7b6:	81 e2       	ldi	r24, 0x21	; 33
    f7b8:	61 2f       	mov	r22, r17
    f7ba:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f7be:	e1 99       	sbic	0x1c, 1	; 28
    f7c0:	fe cf       	rjmp	.-4      	; 0xf7be <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f7c2:	ff ba       	out	0x1f, r15	; 31
    f7c4:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
    f7c6:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    f7c8:	0f b6       	in	r0, 0x3f	; 63
    f7ca:	f8 94       	cli
    f7cc:	e2 9a       	sbi	0x1c, 2	; 28
    f7ce:	e1 9a       	sbi	0x1c, 1	; 28
    f7d0:	0f be       	out	0x3f, r0	; 63
    f7d2:	a4 c0       	rjmp	.+328    	; 0xf91c <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
    f7d4:	8a 32       	cpi	r24, 0x2A	; 42
    f7d6:	09 f4       	brne	.+2      	; 0xf7da <FSettingSystem+0x1ca>
    f7d8:	99 c0       	rjmp	.+306    	; 0xf90c <FSettingSystem+0x2fc>
    f7da:	a7 c0       	rjmp	.+334    	; 0xf92a <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
    f7dc:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
    f7e0:	81 e0       	ldi	r24, 0x01	; 1
    f7e2:	61 e0       	ldi	r22, 0x01	; 1
    f7e4:	42 e5       	ldi	r20, 0x52	; 82
    f7e6:	5f e0       	ldi	r21, 0x0F	; 15
    f7e8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    f7ec:	01 e0       	ldi	r16, 0x01	; 1
    f7ee:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
    f7f0:	6e 01       	movw	r12, r28
    f7f2:	08 94       	sec
    f7f4:	c1 1c       	adc	r12, r1
    f7f6:	d1 1c       	adc	r13, r1
    f7f8:	f9 e4       	ldi	r31, 0x49	; 73
    f7fa:	af 2e       	mov	r10, r31
    f7fc:	ff e0       	ldi	r31, 0x0F	; 15
    f7fe:	bf 2e       	mov	r11, r31
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
    f800:	eb e0       	ldi	r30, 0x0B	; 11
    f802:	ee 2e       	mov	r14, r30
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
    f804:	f0 2e       	mov	r15, r16
    f806:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f808:	e1 99       	sbic	0x1c, 1	; 28
    f80a:	fe cf       	rjmp	.-4      	; 0xf808 <FSettingSystem+0x1f8>
    f80c:	c8 01       	movw	r24, r16
    f80e:	81 5c       	subi	r24, 0xC1	; 193
    f810:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f812:	9f bb       	out	0x1f, r25	; 31
    f814:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f816:	e0 9a       	sbi	0x1c, 0	; 28
    f818:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    f81a:	82 30       	cpi	r24, 0x02	; 2
    f81c:	69 f0       	breq	.+26     	; 0xf838 <FSettingSystem+0x228>
    f81e:	82 30       	cpi	r24, 0x02	; 2
    f820:	28 f0       	brcs	.+10     	; 0xf82c <FSettingSystem+0x21c>
    f822:	83 30       	cpi	r24, 0x03	; 3
    f824:	31 f4       	brne	.+12     	; 0xf832 <FSettingSystem+0x222>
    f826:	85 eb       	ldi	r24, 0xB5	; 181
    f828:	9f e2       	ldi	r25, 0x2F	; 47
    f82a:	08 c0       	rjmp	.+16     	; 0xf83c <FSettingSystem+0x22c>
    f82c:	80 e8       	ldi	r24, 0x80	; 128
    f82e:	95 e2       	ldi	r25, 0x25	; 37
    f830:	05 c0       	rjmp	.+10     	; 0xf83c <FSettingSystem+0x22c>
    f832:	80 e0       	ldi	r24, 0x00	; 0
    f834:	90 e0       	ldi	r25, 0x00	; 0
    f836:	02 c0       	rjmp	.+4      	; 0xf83c <FSettingSystem+0x22c>
    f838:	80 e0       	ldi	r24, 0x00	; 0
    f83a:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
    f83c:	ed b7       	in	r30, 0x3d	; 61
    f83e:	fe b7       	in	r31, 0x3e	; 62
    f840:	38 97       	sbiw	r30, 0x08	; 8
    f842:	0f b6       	in	r0, 0x3f	; 63
    f844:	f8 94       	cli
    f846:	fe bf       	out	0x3e, r31	; 62
    f848:	0f be       	out	0x3f, r0	; 63
    f84a:	ed bf       	out	0x3d, r30	; 61
    f84c:	31 96       	adiw	r30, 0x01	; 1
    f84e:	ad b7       	in	r26, 0x3d	; 61
    f850:	be b7       	in	r27, 0x3e	; 62
    f852:	12 96       	adiw	r26, 0x02	; 2
    f854:	dc 92       	st	X, r13
    f856:	ce 92       	st	-X, r12
    f858:	11 97       	sbiw	r26, 0x01	; 1
    f85a:	b3 82       	std	Z+3, r11	; 0x03
    f85c:	a2 82       	std	Z+2, r10	; 0x02
    f85e:	15 83       	std	Z+5, r17	; 0x05
    f860:	04 83       	std	Z+4, r16	; 0x04
    f862:	97 83       	std	Z+7, r25	; 0x07
    f864:	86 83       	std	Z+6, r24	; 0x06
    f866:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
    f86a:	ed b7       	in	r30, 0x3d	; 61
    f86c:	fe b7       	in	r31, 0x3e	; 62
    f86e:	38 96       	adiw	r30, 0x08	; 8
    f870:	0f b6       	in	r0, 0x3f	; 63
    f872:	f8 94       	cli
    f874:	fe bf       	out	0x3e, r31	; 62
    f876:	0f be       	out	0x3f, r0	; 63
    f878:	ed bf       	out	0x3d, r30	; 61
    f87a:	6f 2d       	mov	r22, r15
    f87c:	66 95       	lsr	r22
    f87e:	6e 9d       	mul	r22, r14
    f880:	b0 01       	movw	r22, r0
    f882:	11 24       	eor	r1, r1
    f884:	6f 5f       	subi	r22, 0xFF	; 255
    f886:	f1 e0       	ldi	r31, 0x01	; 1
    f888:	ff 22       	and	r15, r31
    f88a:	8f 2d       	mov	r24, r15
    f88c:	8e 5f       	subi	r24, 0xFE	; 254
    f88e:	a6 01       	movw	r20, r12
    f890:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
    f894:	0f 5f       	subi	r16, 0xFF	; 255
    f896:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
    f898:	05 30       	cpi	r16, 0x05	; 5
    f89a:	11 05       	cpc	r17, r1
    f89c:	09 f0       	breq	.+2      	; 0xf8a0 <FSettingSystem+0x290>
    f89e:	b2 cf       	rjmp	.-156    	; 0xf804 <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
    f8a0:	84 e0       	ldi	r24, 0x04	; 4
    f8a2:	61 e0       	ldi	r22, 0x01	; 1
    f8a4:	4c e3       	ldi	r20, 0x3C	; 60
    f8a6:	5f e0       	ldi	r21, 0x0F	; 15
    f8a8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
    f8ac:	83 e0       	ldi	r24, 0x03	; 3
    f8ae:	2f c0       	rjmp	.+94     	; 0xf90e <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
    f8b0:	81 e0       	ldi	r24, 0x01	; 1
    f8b2:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    f8b6:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
    f8ba:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
    f8bc:	81 53       	subi	r24, 0x31	; 49
    f8be:	84 30       	cpi	r24, 0x04	; 4
    f8c0:	18 f5       	brcc	.+70     	; 0xf908 <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f8c2:	e1 99       	sbic	0x1c, 1	; 28
    f8c4:	fe cf       	rjmp	.-4      	; 0xf8c2 <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f8c6:	02 2f       	mov	r16, r18
    f8c8:	10 e0       	ldi	r17, 0x00	; 0
    f8ca:	01 5f       	subi	r16, 0xF1	; 241
    f8cc:	1e 4f       	sbci	r17, 0xFE	; 254
    f8ce:	1f bb       	out	0x1f, r17	; 31
    f8d0:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f8d2:	e0 9a       	sbi	0x1c, 0	; 28
    f8d4:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
    f8d6:	90 e0       	ldi	r25, 0x00	; 0
    f8d8:	01 96       	adiw	r24, 0x01	; 1
    f8da:	63 e0       	ldi	r22, 0x03	; 3
    f8dc:	70 e0       	ldi	r23, 0x00	; 0
    f8de:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    f8e2:	f8 2e       	mov	r15, r24
    f8e4:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
    f8e6:	82 2f       	mov	r24, r18
    f8e8:	80 53       	subi	r24, 0x30	; 48
    f8ea:	6f 2d       	mov	r22, r15
    f8ec:	0e 94 d2 7a 	call	0xf5a4	; 0xf5a4 <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f8f0:	e1 99       	sbic	0x1c, 1	; 28
    f8f2:	fe cf       	rjmp	.-4      	; 0xf8f0 <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f8f4:	1f bb       	out	0x1f, r17	; 31
    f8f6:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    f8f8:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
    f8fa:	0f b6       	in	r0, 0x3f	; 63
    f8fc:	f8 94       	cli
    f8fe:	e2 9a       	sbi	0x1c, 2	; 28
    f900:	e1 9a       	sbi	0x1c, 1	; 28
    f902:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
    f904:	82 e0       	ldi	r24, 0x02	; 2
    f906:	03 c0       	rjmp	.+6      	; 0xf90e <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
    f908:	2a 32       	cpi	r18, 0x2A	; 42
    f90a:	79 f4       	brne	.+30     	; 0xf92a <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
    f90c:	85 e0       	ldi	r24, 0x05	; 5
    f90e:	80 93 1c 02 	sts	0x021C, r24
    f912:	0b c0       	rjmp	.+22     	; 0xf92a <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
    f914:	0e 94 ff 5e 	call	0xbdfe	; 0xbdfe <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
    f918:	81 30       	cpi	r24, 0x01	; 1
    f91a:	39 f4       	brne	.+14     	; 0xf92a <FSettingSystem+0x31a>
    f91c:	10 92 1c 02 	sts	0x021C, r1
    f920:	04 c0       	rjmp	.+8      	; 0xf92a <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
    f922:	10 92 1c 02 	sts	0x021C, r1
    f926:	81 e0       	ldi	r24, 0x01	; 1
    f928:	01 c0       	rjmp	.+2      	; 0xf92c <FSettingSystem+0x31c>
    f92a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
    f92c:	64 96       	adiw	r28, 0x14	; 20
    f92e:	0f b6       	in	r0, 0x3f	; 63
    f930:	f8 94       	cli
    f932:	de bf       	out	0x3e, r29	; 62
    f934:	0f be       	out	0x3f, r0	; 63
    f936:	cd bf       	out	0x3d, r28	; 61
    f938:	cf 91       	pop	r28
    f93a:	df 91       	pop	r29
    f93c:	1f 91       	pop	r17
    f93e:	0f 91       	pop	r16
    f940:	ff 90       	pop	r15
    f942:	ef 90       	pop	r14
    f944:	df 90       	pop	r13
    f946:	cf 90       	pop	r12
    f948:	bf 90       	pop	r11
    f94a:	af 90       	pop	r10
    f94c:	08 95       	ret

0000f94e <FMenuSettings>:
char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1;
     char KeyPressed,KeyChar,SubMenu;

     switch(stMenuSettings){
    f94e:	80 91 22 02 	lds	r24, 0x0222
    f952:	e8 2f       	mov	r30, r24
    f954:	f0 e0       	ldi	r31, 0x00	; 0
    f956:	e3 31       	cpi	r30, 0x13	; 19
    f958:	f1 05       	cpc	r31, r1
    f95a:	08 f0       	brcs	.+2      	; 0xf95e <FMenuSettings+0x10>
    f95c:	bf c0       	rjmp	.+382    	; 0xfadc <FMenuSettings+0x18e>
    f95e:	e3 58       	subi	r30, 0x83	; 131
    f960:	ff 4f       	sbci	r31, 0xFF	; 255
    f962:	ee 0f       	add	r30, r30
    f964:	ff 1f       	adc	r31, r31
    f966:	05 90       	lpm	r0, Z+
    f968:	f4 91       	lpm	r31, Z+
    f96a:	e0 2d       	mov	r30, r0
    f96c:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
    f96e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  PageSetting=1;
    f972:	81 e0       	ldi	r24, 0x01	; 1
    f974:	80 93 57 01 	sts	0x0157, r24
    f978:	a9 c0       	rjmp	.+338    	; 0xfacc <FMenuSettings+0x17e>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
    f97a:	80 91 57 01 	lds	r24, 0x0157
    f97e:	8f 5f       	subi	r24, 0xFF	; 255
    f980:	a5 c0       	rjmp	.+330    	; 0xfacc <FMenuSettings+0x17e>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
    f982:	81 e0       	ldi	r24, 0x01	; 1
    f984:	61 e0       	ldi	r22, 0x01	; 1
    f986:	4f e3       	ldi	r20, 0x3F	; 63
    f988:	54 e1       	ldi	r21, 0x14	; 20
    f98a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
    f98e:	82 e0       	ldi	r24, 0x02	; 2
    f990:	61 e0       	ldi	r22, 0x01	; 1
    f992:	4a e2       	ldi	r20, 0x2A	; 42
    f994:	54 e1       	ldi	r21, 0x14	; 20
    f996:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
    f99a:	83 e0       	ldi	r24, 0x03	; 3
    f99c:	61 e0       	ldi	r22, 0x01	; 1
    f99e:	45 e1       	ldi	r20, 0x15	; 21
    f9a0:	54 e1       	ldi	r21, 0x14	; 20
    f9a2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
    f9a6:	84 e0       	ldi	r24, 0x04	; 4
    f9a8:	61 e0       	ldi	r22, 0x01	; 1
    f9aa:	40 e0       	ldi	r20, 0x00	; 0
    f9ac:	54 e1       	ldi	r21, 0x14	; 20
    f9ae:	16 c0       	rjmp	.+44     	; 0xf9dc <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
    f9b0:	81 e0       	ldi	r24, 0x01	; 1
    f9b2:	61 e0       	ldi	r22, 0x01	; 1
    f9b4:	4b ee       	ldi	r20, 0xEB	; 235
    f9b6:	53 e1       	ldi	r21, 0x13	; 19
    f9b8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
    f9bc:	82 e0       	ldi	r24, 0x02	; 2
    f9be:	61 e0       	ldi	r22, 0x01	; 1
    f9c0:	46 ed       	ldi	r20, 0xD6	; 214
    f9c2:	53 e1       	ldi	r21, 0x13	; 19
    f9c4:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
    f9c8:	83 e0       	ldi	r24, 0x03	; 3
    f9ca:	61 e0       	ldi	r22, 0x01	; 1
    f9cc:	41 ec       	ldi	r20, 0xC1	; 193
    f9ce:	53 e1       	ldi	r21, 0x13	; 19
    f9d0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
    f9d4:	84 e0       	ldi	r24, 0x04	; 4
    f9d6:	61 e0       	ldi	r22, 0x01	; 1
    f9d8:	4c ea       	ldi	r20, 0xAC	; 172
    f9da:	53 e1       	ldi	r21, 0x13	; 19
    f9dc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stMenuSettings=msSelection;
    f9e0:	84 e0       	ldi	r24, 0x04	; 4
    f9e2:	74 c0       	rjmp	.+232    	; 0xfacc <FMenuSettings+0x17e>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
    f9e4:	80 91 57 01 	lds	r24, 0x0157
    f9e8:	8c 5f       	subi	r24, 0xFC	; 252
    f9ea:	70 c0       	rjmp	.+224    	; 0xfacc <FMenuSettings+0x17e>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
    f9ec:	81 e0       	ldi	r24, 0x01	; 1
    f9ee:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    f9f2:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  switch(KeyChar){
    f9f6:	84 33       	cpi	r24, 0x34	; 52
    f9f8:	d1 f0       	breq	.+52     	; 0xfa2e <FMenuSettings+0xe0>
    f9fa:	85 33       	cpi	r24, 0x35	; 53
    f9fc:	50 f4       	brcc	.+20     	; 0xfa12 <FMenuSettings+0xc4>
    f9fe:	82 33       	cpi	r24, 0x32	; 50
    fa00:	91 f0       	breq	.+36     	; 0xfa26 <FMenuSettings+0xd8>
    fa02:	83 33       	cpi	r24, 0x33	; 51
    fa04:	90 f4       	brcc	.+36     	; 0xfa2a <FMenuSettings+0xdc>
    fa06:	8a 32       	cpi	r24, 0x2A	; 42
    fa08:	d1 f0       	breq	.+52     	; 0xfa3e <FMenuSettings+0xf0>
    fa0a:	81 33       	cpi	r24, 0x31	; 49
    fa0c:	09 f0       	breq	.+2      	; 0xfa10 <FMenuSettings+0xc2>
    fa0e:	66 c0       	rjmp	.+204    	; 0xfadc <FMenuSettings+0x18e>
    fa10:	08 c0       	rjmp	.+16     	; 0xfa22 <FMenuSettings+0xd4>
    fa12:	86 33       	cpi	r24, 0x36	; 54
    fa14:	81 f0       	breq	.+32     	; 0xfa36 <FMenuSettings+0xe8>
    fa16:	86 33       	cpi	r24, 0x36	; 54
    fa18:	60 f0       	brcs	.+24     	; 0xfa32 <FMenuSettings+0xe4>
    fa1a:	87 33       	cpi	r24, 0x37	; 55
    fa1c:	09 f0       	breq	.+2      	; 0xfa20 <FMenuSettings+0xd2>
    fa1e:	5e c0       	rjmp	.+188    	; 0xfadc <FMenuSettings+0x18e>
    fa20:	0c c0       	rjmp	.+24     	; 0xfa3a <FMenuSettings+0xec>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
    fa22:	89 e0       	ldi	r24, 0x09	; 9
    fa24:	53 c0       	rjmp	.+166    	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
    fa26:	8a e0       	ldi	r24, 0x0A	; 10
    fa28:	51 c0       	rjmp	.+162    	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
    fa2a:	8b e0       	ldi	r24, 0x0B	; 11
    fa2c:	4f c0       	rjmp	.+158    	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
    fa2e:	8c e0       	ldi	r24, 0x0C	; 12
    fa30:	4d c0       	rjmp	.+154    	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
    fa32:	8d e0       	ldi	r24, 0x0D	; 13
    fa34:	4b c0       	rjmp	.+150    	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
    fa36:	8e e0       	ldi	r24, 0x0E	; 14
    fa38:	49 c0       	rjmp	.+146    	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
    fa3a:	87 e0       	ldi	r24, 0x07	; 7
    fa3c:	47 c0       	rjmp	.+142    	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
    fa3e:	82 e1       	ldi	r24, 0x12	; 18
    fa40:	45 c0       	rjmp	.+138    	; 0xfacc <FMenuSettings+0x17e>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
    fa42:	81 e0       	ldi	r24, 0x01	; 1
    fa44:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    fa48:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  switch(KeyChar){
    fa4c:	82 33       	cpi	r24, 0x32	; 50
    fa4e:	69 f0       	breq	.+26     	; 0xfa6a <FMenuSettings+0x11c>
    fa50:	83 33       	cpi	r24, 0x33	; 51
    fa52:	30 f4       	brcc	.+12     	; 0xfa60 <FMenuSettings+0x112>
    fa54:	8a 32       	cpi	r24, 0x2A	; 42
    fa56:	69 f0       	breq	.+26     	; 0xfa72 <FMenuSettings+0x124>
    fa58:	81 33       	cpi	r24, 0x31	; 49
    fa5a:	09 f0       	breq	.+2      	; 0xfa5e <FMenuSettings+0x110>
    fa5c:	3f c0       	rjmp	.+126    	; 0xfadc <FMenuSettings+0x18e>
    fa5e:	03 c0       	rjmp	.+6      	; 0xfa66 <FMenuSettings+0x118>
    fa60:	83 33       	cpi	r24, 0x33	; 51
    fa62:	e1 f5       	brne	.+120    	; 0xfadc <FMenuSettings+0x18e>
    fa64:	04 c0       	rjmp	.+8      	; 0xfa6e <FMenuSettings+0x120>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
    fa66:	8f e0       	ldi	r24, 0x0F	; 15
    fa68:	31 c0       	rjmp	.+98     	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
    fa6a:	80 e1       	ldi	r24, 0x10	; 16
    fa6c:	2f c0       	rjmp	.+94     	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
    fa6e:	81 e1       	ldi	r24, 0x11	; 17
    fa70:	2d c0       	rjmp	.+90     	; 0xfacc <FMenuSettings+0x17e>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
    fa72:	88 e0       	ldi	r24, 0x08	; 8
    fa74:	2b c0       	rjmp	.+86     	; 0xfacc <FMenuSettings+0x17e>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
    fa76:	80 91 57 01 	lds	r24, 0x0157
    fa7a:	82 30       	cpi	r24, 0x02	; 2
    fa7c:	d8 f4       	brcc	.+54     	; 0xfab4 <FMenuSettings+0x166>
    fa7e:	8f 5f       	subi	r24, 0xFF	; 255
    fa80:	05 c0       	rjmp	.+10     	; 0xfa8c <FMenuSettings+0x13e>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
    fa82:	80 91 57 01 	lds	r24, 0x0157
    fa86:	82 30       	cpi	r24, 0x02	; 2
    fa88:	a8 f0       	brcs	.+42     	; 0xfab4 <FMenuSettings+0x166>
    fa8a:	81 50       	subi	r24, 0x01	; 1
    fa8c:	80 93 57 01 	sts	0x0157, r24
    fa90:	11 c0       	rjmp	.+34     	; 0xfab4 <FMenuSettings+0x166>
		  stMenuSettings=msDisplayPage;
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
    fa92:	0e 94 2b 71 	call	0xe256	; 0xe256 <FSettingProduct>
    fa96:	18 c0       	rjmp	.+48     	; 0xfac8 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
    fa98:	0e 94 fc 66 	call	0xcdf8	; 0xcdf8 <FSettingPump>
    fa9c:	15 c0       	rjmp	.+42     	; 0xfac8 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
    fa9e:	0e 94 09 54 	call	0xa812	; 0xa812 <FSettingDec>
    faa2:	12 c0       	rjmp	.+36     	; 0xfac8 <FMenuSettings+0x17a>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    faa4:	0e 94 86 56 	call	0xad0c	; 0xad0c <_menu_datetime>
    faa8:	05 c0       	rjmp	.+10     	; 0xfab4 <FMenuSettings+0x166>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    faaa:	0e 94 0e 50 	call	0xa01c	; 0xa01c <_menu_printer>
    faae:	02 c0       	rjmp	.+4      	; 0xfab4 <FMenuSettings+0x166>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    fab0:	0e 94 67 4e 	call	0x9cce	; 0x9cce <_menu_host>
	      SubMenu=FSettingPrinter();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
    fab4:	81 e0       	ldi	r24, 0x01	; 1
    fab6:	0a c0       	rjmp	.+20     	; 0xfacc <FMenuSettings+0x17e>
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
    fab8:	0e 94 3e 6e 	call	0xdc7c	; 0xdc7c <FSettingOperator>
    fabc:	05 c0       	rjmp	.+10     	; 0xfac8 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
    fabe:	0e 94 08 7b 	call	0xf610	; 0xf610 <FSettingSystem>
    fac2:	02 c0       	rjmp	.+4      	; 0xfac8 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
    fac4:	0e 94 ff 5e 	call	0xbdfe	; 0xbdfe <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
    fac8:	81 30       	cpi	r24, 0x01	; 1
    faca:	41 f4       	brne	.+16     	; 0xfadc <FMenuSettings+0x18e>
    facc:	80 93 22 02 	sts	0x0222, r24
    fad0:	80 e0       	ldi	r24, 0x00	; 0
    fad2:	08 95       	ret
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
    fad4:	10 92 22 02 	sts	0x0222, r1
    fad8:	81 e0       	ldi	r24, 0x01	; 1
    fada:	08 95       	ret
    fadc:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    fade:	08 95       	ret

0000fae0 <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
    fae0:	af 92       	push	r10
    fae2:	bf 92       	push	r11
    fae4:	cf 92       	push	r12
    fae6:	df 92       	push	r13
    fae8:	ff 92       	push	r15
    faea:	0f 93       	push	r16
    faec:	1f 93       	push	r17
    faee:	df 93       	push	r29
    faf0:	cf 93       	push	r28
    faf2:	cd b7       	in	r28, 0x3d	; 61
    faf4:	de b7       	in	r29, 0x3e	; 62
    faf6:	64 97       	sbiw	r28, 0x14	; 20
    faf8:	0f b6       	in	r0, 0x3f	; 63
    fafa:	f8 94       	cli
    fafc:	de bf       	out	0x3e, r29	; 62
    fafe:	0f be       	out	0x3f, r0	; 63
    fb00:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
    fb02:	83 e0       	ldi	r24, 0x03	; 3
    fb04:	61 e0       	ldi	r22, 0x01	; 1
    fb06:	4e e0       	ldi	r20, 0x0E	; 14
    fb08:	5f e1       	ldi	r21, 0x1F	; 31
    fb0a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
    fb0e:	01 e0       	ldi	r16, 0x01	; 1
    fb10:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
    fb12:	6e 01       	movw	r12, r28
    fb14:	08 94       	sec
    fb16:	c1 1c       	adc	r12, r1
    fb18:	d1 1c       	adc	r13, r1
    fb1a:	ba ef       	ldi	r27, 0xFA	; 250
    fb1c:	ab 2e       	mov	r10, r27
    fb1e:	be e1       	ldi	r27, 0x1E	; 30
    fb20:	bb 2e       	mov	r11, r27
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    fb22:	e1 99       	sbic	0x1c, 1	; 28
    fb24:	fe cf       	rjmp	.-4      	; 0xfb22 <InitComport+0x42>
    fb26:	c8 01       	movw	r24, r16
    fb28:	81 5c       	subi	r24, 0xC1	; 193
    fb2a:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fb2c:	9f bb       	out	0x1f, r25	; 31
    fb2e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    fb30:	e0 9a       	sbi	0x1c, 0	; 28
    fb32:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    fb34:	22 e0       	ldi	r18, 0x02	; 2
    fb36:	f2 16       	cp	r15, r18
    fb38:	71 f0       	breq	.+28     	; 0xfb56 <InitComport+0x76>
    fb3a:	f2 16       	cp	r15, r18
    fb3c:	30 f0       	brcs	.+12     	; 0xfb4a <InitComport+0x6a>
    fb3e:	33 e0       	ldi	r19, 0x03	; 3
    fb40:	f3 16       	cp	r15, r19
    fb42:	31 f4       	brne	.+12     	; 0xfb50 <InitComport+0x70>
    fb44:	85 eb       	ldi	r24, 0xB5	; 181
    fb46:	9f e2       	ldi	r25, 0x2F	; 47
    fb48:	08 c0       	rjmp	.+16     	; 0xfb5a <InitComport+0x7a>
    fb4a:	80 e8       	ldi	r24, 0x80	; 128
    fb4c:	95 e2       	ldi	r25, 0x25	; 37
    fb4e:	05 c0       	rjmp	.+10     	; 0xfb5a <InitComport+0x7a>
    fb50:	80 e0       	ldi	r24, 0x00	; 0
    fb52:	90 e0       	ldi	r25, 0x00	; 0
    fb54:	02 c0       	rjmp	.+4      	; 0xfb5a <InitComport+0x7a>
    fb56:	80 e0       	ldi	r24, 0x00	; 0
    fb58:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
    fb5a:	ad b7       	in	r26, 0x3d	; 61
    fb5c:	be b7       	in	r27, 0x3e	; 62
    fb5e:	18 97       	sbiw	r26, 0x08	; 8
    fb60:	0f b6       	in	r0, 0x3f	; 63
    fb62:	f8 94       	cli
    fb64:	be bf       	out	0x3e, r27	; 62
    fb66:	0f be       	out	0x3f, r0	; 63
    fb68:	ad bf       	out	0x3d, r26	; 61
    fb6a:	ed b7       	in	r30, 0x3d	; 61
    fb6c:	fe b7       	in	r31, 0x3e	; 62
    fb6e:	31 96       	adiw	r30, 0x01	; 1
    fb70:	12 96       	adiw	r26, 0x02	; 2
    fb72:	dc 92       	st	X, r13
    fb74:	ce 92       	st	-X, r12
    fb76:	11 97       	sbiw	r26, 0x01	; 1
    fb78:	b3 82       	std	Z+3, r11	; 0x03
    fb7a:	a2 82       	std	Z+2, r10	; 0x02
    fb7c:	15 83       	std	Z+5, r17	; 0x05
    fb7e:	04 83       	std	Z+4, r16	; 0x04
    fb80:	97 83       	std	Z+7, r25	; 0x07
    fb82:	86 83       	std	Z+6, r24	; 0x06
    fb84:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 lcd_print(4,1,lcdteks);
    fb88:	2d b7       	in	r18, 0x3d	; 61
    fb8a:	3e b7       	in	r19, 0x3e	; 62
    fb8c:	28 5f       	subi	r18, 0xF8	; 248
    fb8e:	3f 4f       	sbci	r19, 0xFF	; 255
    fb90:	0f b6       	in	r0, 0x3f	; 63
    fb92:	f8 94       	cli
    fb94:	3e bf       	out	0x3e, r19	; 62
    fb96:	0f be       	out	0x3f, r0	; 63
    fb98:	2d bf       	out	0x3d, r18	; 61
    fb9a:	84 e0       	ldi	r24, 0x04	; 4
    fb9c:	61 e0       	ldi	r22, 0x01	; 1
    fb9e:	a6 01       	movw	r20, r12
    fba0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		 SetBaudRate(i+1,brMap);
    fba4:	80 2f       	mov	r24, r16
    fba6:	6f 2d       	mov	r22, r15
    fba8:	0e 94 d2 7a 	call	0xf5a4	; 0xf5a4 <SetBaudRate>
 	     TimDisplay=0;
    fbac:	10 92 92 01 	sts	0x0192, r1
    fbb0:	04 c0       	rjmp	.+8      	; 0xfbba <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>1)break;
    fbb2:	80 91 92 01 	lds	r24, 0x0192
    fbb6:	82 30       	cpi	r24, 0x02	; 2
    fbb8:	20 f4       	brcc	.+8      	; 0xfbc2 <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
    fbba:	80 91 92 01 	lds	r24, 0x0192
    fbbe:	82 30       	cpi	r24, 0x02	; 2
    fbc0:	c0 f3       	brcs	.-16     	; 0xfbb2 <InitComport+0xd2>
    fbc2:	0f 5f       	subi	r16, 0xFF	; 255
    fbc4:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
    fbc6:	05 30       	cpi	r16, 0x05	; 5
    fbc8:	11 05       	cpc	r17, r1
    fbca:	09 f0       	breq	.+2      	; 0xfbce <InitComport+0xee>
    fbcc:	aa cf       	rjmp	.-172    	; 0xfb22 <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>1)break;
		 };

	 }
}
    fbce:	64 96       	adiw	r28, 0x14	; 20
    fbd0:	0f b6       	in	r0, 0x3f	; 63
    fbd2:	f8 94       	cli
    fbd4:	de bf       	out	0x3e, r29	; 62
    fbd6:	0f be       	out	0x3f, r0	; 63
    fbd8:	cd bf       	out	0x3d, r28	; 61
    fbda:	cf 91       	pop	r28
    fbdc:	df 91       	pop	r29
    fbde:	1f 91       	pop	r17
    fbe0:	0f 91       	pop	r16
    fbe2:	ff 90       	pop	r15
    fbe4:	df 90       	pop	r13
    fbe6:	cf 90       	pop	r12
    fbe8:	bf 90       	pop	r11
    fbea:	af 90       	pop	r10
    fbec:	08 95       	ret

0000fbee <IFTSendMessage>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void IFTSendMessage(char MsgCode){//<STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode]
    fbee:	af 92       	push	r10
    fbf0:	bf 92       	push	r11
    fbf2:	cf 92       	push	r12
    fbf4:	df 92       	push	r13
    fbf6:	ef 92       	push	r14
    fbf8:	ff 92       	push	r15
    fbfa:	0f 93       	push	r16
    fbfc:	df 93       	push	r29
    fbfe:	cf 93       	push	r28
    fc00:	cd b7       	in	r28, 0x3d	; 61
    fc02:	de b7       	in	r29, 0x3e	; 62
    fc04:	c0 54       	subi	r28, 0x40	; 64
    fc06:	d0 40       	sbci	r29, 0x00	; 0
    fc08:	0f b6       	in	r0, 0x3f	; 63
    fc0a:	f8 94       	cli
    fc0c:	de bf       	out	0x3e, r29	; 62
    fc0e:	0f be       	out	0x3f, r0	; 63
    fc10:	cd bf       	out	0x3d, r28	; 61
    fc12:	08 2f       	mov	r16, r24
	 char strSeqNum[3];
	 char ReadIP[4];
	 char strSend[60];

     //STX
     uart(1, 1,0x01);
    fc14:	81 e0       	ldi	r24, 0x01	; 1
    fc16:	61 e0       	ldi	r22, 0x01	; 1
    fc18:	41 e0       	ldi	r20, 0x01	; 1
    fc1a:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    fc1e:	e1 99       	sbic	0x1c, 1	; 28
    fc20:	fe cf       	rjmp	.-4      	; 0xfc1e <IFTSendMessage+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    fc22:	80 e0       	ldi	r24, 0x00	; 0
    fc24:	90 e0       	ldi	r25, 0x00	; 0
    fc26:	9f bb       	out	0x1f, r25	; 31
    fc28:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    fc2a:	e0 9a       	sbi	0x1c, 0	; 28
    fc2c:	8d b3       	in	r24, 0x1d	; 29
	 //[IFTID]
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strSend,PSTR("%.2d"),IdIFT);
    fc2e:	00 d0       	rcall	.+0      	; 0xfc30 <IFTSendMessage+0x42>
    fc30:	00 d0       	rcall	.+0      	; 0xfc32 <IFTSendMessage+0x44>
    fc32:	00 d0       	rcall	.+0      	; 0xfc34 <IFTSendMessage+0x46>
    fc34:	ed b7       	in	r30, 0x3d	; 61
    fc36:	fe b7       	in	r31, 0x3e	; 62
    fc38:	31 96       	adiw	r30, 0x01	; 1
    fc3a:	95 e0       	ldi	r25, 0x05	; 5
    fc3c:	c9 2e       	mov	r12, r25
    fc3e:	d1 2c       	mov	r13, r1
    fc40:	cc 0e       	add	r12, r28
    fc42:	dd 1e       	adc	r13, r29
    fc44:	ad b7       	in	r26, 0x3d	; 61
    fc46:	be b7       	in	r27, 0x3e	; 62
    fc48:	12 96       	adiw	r26, 0x02	; 2
    fc4a:	dc 92       	st	X, r13
    fc4c:	ce 92       	st	-X, r12
    fc4e:	11 97       	sbiw	r26, 0x01	; 1
    fc50:	22 e8       	ldi	r18, 0x82	; 130
    fc52:	33 e2       	ldi	r19, 0x23	; 35
    fc54:	33 83       	std	Z+3, r19	; 0x03
    fc56:	22 83       	std	Z+2, r18	; 0x02
    fc58:	64 e6       	ldi	r22, 0x64	; 100
    fc5a:	0e 94 85 b2 	call	0x1650a	; 0x1650a <__udivmodqi4>
    fc5e:	94 83       	std	Z+4, r25	; 0x04
    fc60:	15 82       	std	Z+5, r1	; 0x05
    fc62:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 uart_print(1, 0,strSend);
    fc66:	8d b7       	in	r24, 0x3d	; 61
    fc68:	9e b7       	in	r25, 0x3e	; 62
    fc6a:	06 96       	adiw	r24, 0x06	; 6
    fc6c:	0f b6       	in	r0, 0x3f	; 63
    fc6e:	f8 94       	cli
    fc70:	9e bf       	out	0x3e, r25	; 62
    fc72:	0f be       	out	0x3f, r0	; 63
    fc74:	8d bf       	out	0x3d, r24	; 61
    fc76:	81 e0       	ldi	r24, 0x01	; 1
    fc78:	60 e0       	ldi	r22, 0x00	; 0
    fc7a:	a6 01       	movw	r20, r12
    fc7c:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
     //[Seq]
	 SeqNum=((SeqNum+1)%100);
    fc80:	80 91 ae 01 	lds	r24, 0x01AE
    fc84:	90 e0       	ldi	r25, 0x00	; 0
    fc86:	01 96       	adiw	r24, 0x01	; 1
    fc88:	64 e6       	ldi	r22, 0x64	; 100
    fc8a:	70 e0       	ldi	r23, 0x00	; 0
    fc8c:	0e 94 b2 b2 	call	0x16564	; 0x16564 <__divmodhi4>
    fc90:	80 93 ae 01 	sts	0x01AE, r24
	 sprintf_P(strSend,PSTR("%.2d"),SeqNum);	 
    fc94:	00 d0       	rcall	.+0      	; 0xfc96 <IFTSendMessage+0xa8>
    fc96:	00 d0       	rcall	.+0      	; 0xfc98 <IFTSendMessage+0xaa>
    fc98:	00 d0       	rcall	.+0      	; 0xfc9a <IFTSendMessage+0xac>
    fc9a:	ed b7       	in	r30, 0x3d	; 61
    fc9c:	fe b7       	in	r31, 0x3e	; 62
    fc9e:	31 96       	adiw	r30, 0x01	; 1
    fca0:	ad b7       	in	r26, 0x3d	; 61
    fca2:	be b7       	in	r27, 0x3e	; 62
    fca4:	12 96       	adiw	r26, 0x02	; 2
    fca6:	dc 92       	st	X, r13
    fca8:	ce 92       	st	-X, r12
    fcaa:	11 97       	sbiw	r26, 0x01	; 1
    fcac:	2d e7       	ldi	r18, 0x7D	; 125
    fcae:	33 e2       	ldi	r19, 0x23	; 35
    fcb0:	33 83       	std	Z+3, r19	; 0x03
    fcb2:	22 83       	std	Z+2, r18	; 0x02
    fcb4:	84 83       	std	Z+4, r24	; 0x04
    fcb6:	15 82       	std	Z+5, r1	; 0x05
    fcb8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 uart_print(1, 0,strSend);
    fcbc:	8d b7       	in	r24, 0x3d	; 61
    fcbe:	9e b7       	in	r25, 0x3e	; 62
    fcc0:	06 96       	adiw	r24, 0x06	; 6
    fcc2:	0f b6       	in	r0, 0x3f	; 63
    fcc4:	f8 94       	cli
    fcc6:	9e bf       	out	0x3e, r25	; 62
    fcc8:	0f be       	out	0x3f, r0	; 63
    fcca:	8d bf       	out	0x3d, r24	; 61
    fccc:	81 e0       	ldi	r24, 0x01	; 1
    fcce:	60 e0       	ldi	r22, 0x00	; 0
    fcd0:	a6 01       	movw	r20, r12
    fcd2:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    fcd6:	7e 01       	movw	r14, r28
    fcd8:	08 94       	sec
    fcda:	e1 1c       	adc	r14, r1
    fcdc:	f1 1c       	adc	r15, r1
    fcde:	c7 01       	movw	r24, r14
    fce0:	68 e2       	ldi	r22, 0x28	; 40
    fce2:	70 e0       	ldi	r23, 0x00	; 0
    fce4:	44 e0       	ldi	r20, 0x04	; 4
    fce6:	50 e0       	ldi	r21, 0x00	; 0
    fce8:	22 ed       	ldi	r18, 0xD2	; 210
    fcea:	33 e1       	ldi	r19, 0x13	; 19
    fcec:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	 //[ClientIP]
     eeprom_read_block((void*)&ReadIP,(const void*)&DefClientIP,4);
	 sprintf_P(strSend,PSTR("%.3d.%.3d.%.3d.%.3d"),ReadIP[0],ReadIP[1],ReadIP[2],ReadIP[3]);
    fcf0:	ad b7       	in	r26, 0x3d	; 61
    fcf2:	be b7       	in	r27, 0x3e	; 62
    fcf4:	1c 97       	sbiw	r26, 0x0c	; 12
    fcf6:	0f b6       	in	r0, 0x3f	; 63
    fcf8:	f8 94       	cli
    fcfa:	be bf       	out	0x3e, r27	; 62
    fcfc:	0f be       	out	0x3f, r0	; 63
    fcfe:	ad bf       	out	0x3d, r26	; 61
    fd00:	ed b7       	in	r30, 0x3d	; 61
    fd02:	fe b7       	in	r31, 0x3e	; 62
    fd04:	31 96       	adiw	r30, 0x01	; 1
    fd06:	12 96       	adiw	r26, 0x02	; 2
    fd08:	dc 92       	st	X, r13
    fd0a:	ce 92       	st	-X, r12
    fd0c:	11 97       	sbiw	r26, 0x01	; 1
    fd0e:	89 e6       	ldi	r24, 0x69	; 105
    fd10:	93 e2       	ldi	r25, 0x23	; 35
    fd12:	93 83       	std	Z+3, r25	; 0x03
    fd14:	82 83       	std	Z+2, r24	; 0x02
    fd16:	89 81       	ldd	r24, Y+1	; 0x01
    fd18:	84 83       	std	Z+4, r24	; 0x04
    fd1a:	15 82       	std	Z+5, r1	; 0x05
    fd1c:	8a 81       	ldd	r24, Y+2	; 0x02
    fd1e:	86 83       	std	Z+6, r24	; 0x06
    fd20:	17 82       	std	Z+7, r1	; 0x07
    fd22:	8b 81       	ldd	r24, Y+3	; 0x03
    fd24:	80 87       	std	Z+8, r24	; 0x08
    fd26:	11 86       	std	Z+9, r1	; 0x09
    fd28:	8c 81       	ldd	r24, Y+4	; 0x04
    fd2a:	82 87       	std	Z+10, r24	; 0x0a
    fd2c:	13 86       	std	Z+11, r1	; 0x0b
    fd2e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 uart_print(1, 0,strSend);
    fd32:	8d b7       	in	r24, 0x3d	; 61
    fd34:	9e b7       	in	r25, 0x3e	; 62
    fd36:	0c 96       	adiw	r24, 0x0c	; 12
    fd38:	0f b6       	in	r0, 0x3f	; 63
    fd3a:	f8 94       	cli
    fd3c:	9e bf       	out	0x3e, r25	; 62
    fd3e:	0f be       	out	0x3f, r0	; 63
    fd40:	8d bf       	out	0x3d, r24	; 61
    fd42:	81 e0       	ldi	r24, 0x01	; 1
    fd44:	60 e0       	ldi	r22, 0x00	; 0
    fd46:	a6 01       	movw	r20, r12
    fd48:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
    fd4c:	c7 01       	movw	r24, r14
    fd4e:	6c e2       	ldi	r22, 0x2C	; 44
    fd50:	70 e0       	ldi	r23, 0x00	; 0
    fd52:	44 e0       	ldi	r20, 0x04	; 4
    fd54:	50 e0       	ldi	r21, 0x00	; 0
    fd56:	22 ed       	ldi	r18, 0xD2	; 210
    fd58:	33 e1       	ldi	r19, 0x13	; 19
    fd5a:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	 //[ServerIP]
     eeprom_read_block((void*)&ReadIP,(const void*)&DefServerIP,4);
	 sprintf_P(strSend,PSTR("%.3d.%.3d.%.3d.%.3d"),ReadIP[0],ReadIP[1],ReadIP[2],ReadIP[3]);
    fd5e:	ad b7       	in	r26, 0x3d	; 61
    fd60:	be b7       	in	r27, 0x3e	; 62
    fd62:	1c 97       	sbiw	r26, 0x0c	; 12
    fd64:	0f b6       	in	r0, 0x3f	; 63
    fd66:	f8 94       	cli
    fd68:	be bf       	out	0x3e, r27	; 62
    fd6a:	0f be       	out	0x3f, r0	; 63
    fd6c:	ad bf       	out	0x3d, r26	; 61
    fd6e:	ed b7       	in	r30, 0x3d	; 61
    fd70:	fe b7       	in	r31, 0x3e	; 62
    fd72:	31 96       	adiw	r30, 0x01	; 1
    fd74:	12 96       	adiw	r26, 0x02	; 2
    fd76:	dc 92       	st	X, r13
    fd78:	ce 92       	st	-X, r12
    fd7a:	11 97       	sbiw	r26, 0x01	; 1
    fd7c:	85 e5       	ldi	r24, 0x55	; 85
    fd7e:	93 e2       	ldi	r25, 0x23	; 35
    fd80:	93 83       	std	Z+3, r25	; 0x03
    fd82:	82 83       	std	Z+2, r24	; 0x02
    fd84:	89 81       	ldd	r24, Y+1	; 0x01
    fd86:	84 83       	std	Z+4, r24	; 0x04
    fd88:	15 82       	std	Z+5, r1	; 0x05
    fd8a:	8a 81       	ldd	r24, Y+2	; 0x02
    fd8c:	86 83       	std	Z+6, r24	; 0x06
    fd8e:	17 82       	std	Z+7, r1	; 0x07
    fd90:	8b 81       	ldd	r24, Y+3	; 0x03
    fd92:	80 87       	std	Z+8, r24	; 0x08
    fd94:	11 86       	std	Z+9, r1	; 0x09
    fd96:	8c 81       	ldd	r24, Y+4	; 0x04
    fd98:	82 87       	std	Z+10, r24	; 0x0a
    fd9a:	13 86       	std	Z+11, r1	; 0x0b
    fd9c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 uart_print(1, 0,strSend);
    fda0:	8d b7       	in	r24, 0x3d	; 61
    fda2:	9e b7       	in	r25, 0x3e	; 62
    fda4:	0c 96       	adiw	r24, 0x0c	; 12
    fda6:	0f b6       	in	r0, 0x3f	; 63
    fda8:	f8 94       	cli
    fdaa:	9e bf       	out	0x3e, r25	; 62
    fdac:	0f be       	out	0x3f, r0	; 63
    fdae:	8d bf       	out	0x3d, r24	; 61
    fdb0:	81 e0       	ldi	r24, 0x01	; 1
    fdb2:	60 e0       	ldi	r22, 0x00	; 0
    fdb4:	a6 01       	movw	r20, r12
    fdb6:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
	 //[MsgCode]
	 sprintf_P(strSend,PSTR("%.2X"),MsgCode);	 
    fdba:	00 d0       	rcall	.+0      	; 0xfdbc <IFTSendMessage+0x1ce>
    fdbc:	00 d0       	rcall	.+0      	; 0xfdbe <IFTSendMessage+0x1d0>
    fdbe:	00 d0       	rcall	.+0      	; 0xfdc0 <IFTSendMessage+0x1d2>
    fdc0:	ed b7       	in	r30, 0x3d	; 61
    fdc2:	fe b7       	in	r31, 0x3e	; 62
    fdc4:	31 96       	adiw	r30, 0x01	; 1
    fdc6:	ad b7       	in	r26, 0x3d	; 61
    fdc8:	be b7       	in	r27, 0x3e	; 62
    fdca:	12 96       	adiw	r26, 0x02	; 2
    fdcc:	dc 92       	st	X, r13
    fdce:	ce 92       	st	-X, r12
    fdd0:	11 97       	sbiw	r26, 0x01	; 1
    fdd2:	80 e5       	ldi	r24, 0x50	; 80
    fdd4:	93 e2       	ldi	r25, 0x23	; 35
    fdd6:	93 83       	std	Z+3, r25	; 0x03
    fdd8:	82 83       	std	Z+2, r24	; 0x02
    fdda:	04 83       	std	Z+4, r16	; 0x04
    fddc:	15 82       	std	Z+5, r1	; 0x05
    fdde:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 uart_print(1, 0,strSend);
    fde2:	8d b7       	in	r24, 0x3d	; 61
    fde4:	9e b7       	in	r25, 0x3e	; 62
    fde6:	06 96       	adiw	r24, 0x06	; 6
    fde8:	0f b6       	in	r0, 0x3f	; 63
    fdea:	f8 94       	cli
    fdec:	9e bf       	out	0x3e, r25	; 62
    fdee:	0f be       	out	0x3f, r0	; 63
    fdf0:	8d bf       	out	0x3d, r24	; 61
    fdf2:	81 e0       	ldi	r24, 0x01	; 1
    fdf4:	60 e0       	ldi	r22, 0x00	; 0
    fdf6:	a6 01       	movw	r20, r12
    fdf8:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>

     switch(MsgCode){
    fdfc:	02 33       	cpi	r16, 0x32	; 50
    fdfe:	09 f4       	brne	.+2      	; 0xfe02 <IFTSendMessage+0x214>
    fe00:	7f c0       	rjmp	.+254    	; 0xff00 <IFTSendMessage+0x312>
    fe02:	03 33       	cpi	r16, 0x33	; 51
    fe04:	70 f4       	brcc	.+28     	; 0xfe22 <IFTSendMessage+0x234>
    fe06:	02 32       	cpi	r16, 0x22	; 34
    fe08:	91 f1       	breq	.+100    	; 0xfe6e <IFTSendMessage+0x280>
    fe0a:	03 32       	cpi	r16, 0x23	; 35
    fe0c:	20 f4       	brcc	.+8      	; 0xfe16 <IFTSendMessage+0x228>
    fe0e:	04 30       	cpi	r16, 0x04	; 4
    fe10:	09 f0       	breq	.+2      	; 0xfe14 <IFTSendMessage+0x226>
    fe12:	1d c2       	rjmp	.+1082   	; 0x1024e <IFTSendMessage+0x660>
    fe14:	19 c0       	rjmp	.+50     	; 0xfe48 <IFTSendMessage+0x25a>
    fe16:	04 32       	cpi	r16, 0x24	; 36
    fe18:	d9 f1       	breq	.+118    	; 0xfe90 <IFTSendMessage+0x2a2>
    fe1a:	08 32       	cpi	r16, 0x28	; 40
    fe1c:	09 f0       	breq	.+2      	; 0xfe20 <IFTSendMessage+0x232>
    fe1e:	17 c2       	rjmp	.+1070   	; 0x1024e <IFTSendMessage+0x660>
    fe20:	53 c0       	rjmp	.+166    	; 0xfec8 <IFTSendMessage+0x2da>
    fe22:	00 39       	cpi	r16, 0x90	; 144
    fe24:	09 f4       	brne	.+2      	; 0xfe28 <IFTSendMessage+0x23a>
    fe26:	78 c1       	rjmp	.+752    	; 0x10118 <IFTSendMessage+0x52a>
    fe28:	01 39       	cpi	r16, 0x91	; 145
    fe2a:	38 f4       	brcc	.+14     	; 0xfe3a <IFTSendMessage+0x24c>
    fe2c:	06 35       	cpi	r16, 0x56	; 86
    fe2e:	09 f4       	brne	.+2      	; 0xfe32 <IFTSendMessage+0x244>
    fe30:	d7 c0       	rjmp	.+430    	; 0xffe0 <IFTSendMessage+0x3f2>
    fe32:	08 35       	cpi	r16, 0x58	; 88
    fe34:	09 f0       	breq	.+2      	; 0xfe38 <IFTSendMessage+0x24a>
    fe36:	0b c2       	rjmp	.+1046   	; 0x1024e <IFTSendMessage+0x660>
    fe38:	e8 c0       	rjmp	.+464    	; 0x1000a <IFTSendMessage+0x41c>
    fe3a:	02 39       	cpi	r16, 0x92	; 146
    fe3c:	09 f4       	brne	.+2      	; 0xfe40 <IFTSendMessage+0x252>
    fe3e:	8d c1       	rjmp	.+794    	; 0x1015a <IFTSendMessage+0x56c>
    fe40:	08 39       	cpi	r16, 0x98	; 152
    fe42:	09 f0       	breq	.+2      	; 0xfe46 <IFTSendMessage+0x258>
    fe44:	04 c2       	rjmp	.+1032   	; 0x1024e <IFTSendMessage+0x660>
    fe46:	e0 c1       	rjmp	.+960    	; 0x10208 <IFTSendMessage+0x61a>
	 case MSG_04://Transaction Number
	      sprintf_P(strSend,PSTR("%s1"),strTranNo);
    fe48:	00 d0       	rcall	.+0      	; 0xfe4a <IFTSendMessage+0x25c>
    fe4a:	00 d0       	rcall	.+0      	; 0xfe4c <IFTSendMessage+0x25e>
    fe4c:	00 d0       	rcall	.+0      	; 0xfe4e <IFTSendMessage+0x260>
    fe4e:	ed b7       	in	r30, 0x3d	; 61
    fe50:	fe b7       	in	r31, 0x3e	; 62
    fe52:	31 96       	adiw	r30, 0x01	; 1
    fe54:	ad b7       	in	r26, 0x3d	; 61
    fe56:	be b7       	in	r27, 0x3e	; 62
    fe58:	12 96       	adiw	r26, 0x02	; 2
    fe5a:	dc 92       	st	X, r13
    fe5c:	ce 92       	st	-X, r12
    fe5e:	11 97       	sbiw	r26, 0x01	; 1
    fe60:	8c e4       	ldi	r24, 0x4C	; 76
    fe62:	93 e2       	ldi	r25, 0x23	; 35
    fe64:	93 83       	std	Z+3, r25	; 0x03
    fe66:	82 83       	std	Z+2, r24	; 0x02
    fe68:	87 e8       	ldi	r24, 0x87	; 135
    fe6a:	9c e0       	ldi	r25, 0x0C	; 12
    fe6c:	df c1       	rjmp	.+958    	; 0x1022c <IFTSendMessage+0x63e>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_10://No Additional Parameter
	      break;
	 case MSG_22://strCardID
	      UpdateCardID();
    fe6e:	0e 94 ec 42 	call	0x85d8	; 0x85d8 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s"),strCardID);
    fe72:	00 d0       	rcall	.+0      	; 0xfe74 <IFTSendMessage+0x286>
    fe74:	00 d0       	rcall	.+0      	; 0xfe76 <IFTSendMessage+0x288>
    fe76:	00 d0       	rcall	.+0      	; 0xfe78 <IFTSendMessage+0x28a>
    fe78:	ed b7       	in	r30, 0x3d	; 61
    fe7a:	fe b7       	in	r31, 0x3e	; 62
    fe7c:	31 96       	adiw	r30, 0x01	; 1
    fe7e:	ad b7       	in	r26, 0x3d	; 61
    fe80:	be b7       	in	r27, 0x3e	; 62
    fe82:	12 96       	adiw	r26, 0x02	; 2
    fe84:	dc 92       	st	X, r13
    fe86:	ce 92       	st	-X, r12
    fe88:	11 97       	sbiw	r26, 0x01	; 1
    fe8a:	89 e4       	ldi	r24, 0x49	; 73
    fe8c:	93 e2       	ldi	r25, 0x23	; 35
    fe8e:	b8 c0       	rjmp	.+368    	; 0x10000 <IFTSendMessage+0x412>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_24://strCardID, FIP_ID
	      UpdateCardID();
    fe90:	0e 94 ec 42 	call	0x85d8	; 0x85d8 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strCardID,strFIP_ID);
    fe94:	ad b7       	in	r26, 0x3d	; 61
    fe96:	be b7       	in	r27, 0x3e	; 62
    fe98:	18 97       	sbiw	r26, 0x08	; 8
    fe9a:	0f b6       	in	r0, 0x3f	; 63
    fe9c:	f8 94       	cli
    fe9e:	be bf       	out	0x3e, r27	; 62
    fea0:	0f be       	out	0x3f, r0	; 63
    fea2:	ad bf       	out	0x3d, r26	; 61
    fea4:	ed b7       	in	r30, 0x3d	; 61
    fea6:	fe b7       	in	r31, 0x3e	; 62
    fea8:	31 96       	adiw	r30, 0x01	; 1
    feaa:	12 96       	adiw	r26, 0x02	; 2
    feac:	dc 92       	st	X, r13
    feae:	ce 92       	st	-X, r12
    feb0:	11 97       	sbiw	r26, 0x01	; 1
    feb2:	84 e4       	ldi	r24, 0x44	; 68
    feb4:	93 e2       	ldi	r25, 0x23	; 35
    feb6:	93 83       	std	Z+3, r25	; 0x03
    feb8:	82 83       	std	Z+2, r24	; 0x02
    feba:	89 e8       	ldi	r24, 0x89	; 137
    febc:	9b e0       	ldi	r25, 0x0B	; 11
    febe:	95 83       	std	Z+5, r25	; 0x05
    fec0:	84 83       	std	Z+4, r24	; 0x04
    fec2:	89 eb       	ldi	r24, 0xB9	; 185
    fec4:	97 e0       	ldi	r25, 0x07	; 7
    fec6:	41 c1       	rjmp	.+642    	; 0x1014a <IFTSendMessage+0x55c>
	      uart_print(1, 0,strSend);
	      break;

	 case MSG_28://strCardID, FIP_ID
	      UpdateCardID();
    fec8:	0e 94 ec 42 	call	0x85d8	; 0x85d8 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strCardID);
    fecc:	ad b7       	in	r26, 0x3d	; 61
    fece:	be b7       	in	r27, 0x3e	; 62
    fed0:	18 97       	sbiw	r26, 0x08	; 8
    fed2:	0f b6       	in	r0, 0x3f	; 63
    fed4:	f8 94       	cli
    fed6:	be bf       	out	0x3e, r27	; 62
    fed8:	0f be       	out	0x3f, r0	; 63
    feda:	ad bf       	out	0x3d, r26	; 61
    fedc:	ed b7       	in	r30, 0x3d	; 61
    fede:	fe b7       	in	r31, 0x3e	; 62
    fee0:	31 96       	adiw	r30, 0x01	; 1
    fee2:	12 96       	adiw	r26, 0x02	; 2
    fee4:	dc 92       	st	X, r13
    fee6:	ce 92       	st	-X, r12
    fee8:	11 97       	sbiw	r26, 0x01	; 1
    feea:	8f e3       	ldi	r24, 0x3F	; 63
    feec:	93 e2       	ldi	r25, 0x23	; 35
    feee:	93 83       	std	Z+3, r25	; 0x03
    fef0:	82 83       	std	Z+2, r24	; 0x02
    fef2:	89 eb       	ldi	r24, 0xB9	; 185
    fef4:	97 e0       	ldi	r25, 0x07	; 7
    fef6:	95 83       	std	Z+5, r25	; 0x05
    fef8:	84 83       	std	Z+4, r24	; 0x04
    fefa:	89 e8       	ldi	r24, 0x89	; 137
    fefc:	9b e0       	ldi	r25, 0x0B	; 11
    fefe:	25 c1       	rjmp	.+586    	; 0x1014a <IFTSendMessage+0x55c>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_32://Change MOP
	      UpdateCardID();
    ff00:	0e 94 ec 42 	call	0x85d8	; 0x85d8 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strPaymentType);
    ff04:	ad b7       	in	r26, 0x3d	; 61
    ff06:	be b7       	in	r27, 0x3e	; 62
    ff08:	18 97       	sbiw	r26, 0x08	; 8
    ff0a:	0f b6       	in	r0, 0x3f	; 63
    ff0c:	f8 94       	cli
    ff0e:	be bf       	out	0x3e, r27	; 62
    ff10:	0f be       	out	0x3f, r0	; 63
    ff12:	ad bf       	out	0x3d, r26	; 61
    ff14:	ed b7       	in	r30, 0x3d	; 61
    ff16:	fe b7       	in	r31, 0x3e	; 62
    ff18:	31 96       	adiw	r30, 0x01	; 1
    ff1a:	12 96       	adiw	r26, 0x02	; 2
    ff1c:	dc 92       	st	X, r13
    ff1e:	ce 92       	st	-X, r12
    ff20:	11 97       	sbiw	r26, 0x01	; 1
    ff22:	8a e3       	ldi	r24, 0x3A	; 58
    ff24:	93 e2       	ldi	r25, 0x23	; 35
    ff26:	93 83       	std	Z+3, r25	; 0x03
    ff28:	82 83       	std	Z+2, r24	; 0x02
    ff2a:	89 eb       	ldi	r24, 0xB9	; 185
    ff2c:	97 e0       	ldi	r25, 0x07	; 7
    ff2e:	95 83       	std	Z+5, r25	; 0x05
    ff30:	84 83       	std	Z+4, r24	; 0x04
    ff32:	80 e5       	ldi	r24, 0x50	; 80
    ff34:	97 e0       	ldi	r25, 0x07	; 7
    ff36:	97 83       	std	Z+7, r25	; 0x07
    ff38:	86 83       	std	Z+6, r24	; 0x06
    ff3a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	      uart_print(1,0,strSend);
    ff3e:	8d b7       	in	r24, 0x3d	; 61
    ff40:	9e b7       	in	r25, 0x3e	; 62
    ff42:	08 96       	adiw	r24, 0x08	; 8
    ff44:	0f b6       	in	r0, 0x3f	; 63
    ff46:	f8 94       	cli
    ff48:	9e bf       	out	0x3e, r25	; 62
    ff4a:	0f be       	out	0x3f, r0	; 63
    ff4c:	8d bf       	out	0x3d, r24	; 61
    ff4e:	81 e0       	ldi	r24, 0x01	; 1
    ff50:	60 e0       	ldi	r22, 0x00	; 0
    ff52:	a6 01       	movw	r20, r12
    ff54:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
		  sprintf_P(strSend,PSTR("%s%s"),strRef1,strRef2);
    ff58:	ad b7       	in	r26, 0x3d	; 61
    ff5a:	be b7       	in	r27, 0x3e	; 62
    ff5c:	18 97       	sbiw	r26, 0x08	; 8
    ff5e:	0f b6       	in	r0, 0x3f	; 63
    ff60:	f8 94       	cli
    ff62:	be bf       	out	0x3e, r27	; 62
    ff64:	0f be       	out	0x3f, r0	; 63
    ff66:	ad bf       	out	0x3d, r26	; 61
    ff68:	ed b7       	in	r30, 0x3d	; 61
    ff6a:	fe b7       	in	r31, 0x3e	; 62
    ff6c:	31 96       	adiw	r30, 0x01	; 1
    ff6e:	12 96       	adiw	r26, 0x02	; 2
    ff70:	dc 92       	st	X, r13
    ff72:	ce 92       	st	-X, r12
    ff74:	11 97       	sbiw	r26, 0x01	; 1
    ff76:	85 e3       	ldi	r24, 0x35	; 53
    ff78:	93 e2       	ldi	r25, 0x23	; 35
    ff7a:	93 83       	std	Z+3, r25	; 0x03
    ff7c:	82 83       	std	Z+2, r24	; 0x02
    ff7e:	8e e8       	ldi	r24, 0x8E	; 142
    ff80:	9c e0       	ldi	r25, 0x0C	; 12
    ff82:	95 83       	std	Z+5, r25	; 0x05
    ff84:	84 83       	std	Z+4, r24	; 0x04
    ff86:	8e e9       	ldi	r24, 0x9E	; 158
    ff88:	9b e0       	ldi	r25, 0x0B	; 11
    ff8a:	97 83       	std	Z+7, r25	; 0x07
    ff8c:	86 83       	std	Z+6, r24	; 0x06
    ff8e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  uart_print(1,0,strSend);
    ff92:	8d b7       	in	r24, 0x3d	; 61
    ff94:	9e b7       	in	r25, 0x3e	; 62
    ff96:	08 96       	adiw	r24, 0x08	; 8
    ff98:	0f b6       	in	r0, 0x3f	; 63
    ff9a:	f8 94       	cli
    ff9c:	9e bf       	out	0x3e, r25	; 62
    ff9e:	0f be       	out	0x3f, r0	; 63
    ffa0:	8d bf       	out	0x3d, r24	; 61
    ffa2:	81 e0       	ldi	r24, 0x01	; 1
    ffa4:	60 e0       	ldi	r22, 0x00	; 0
    ffa6:	a6 01       	movw	r20, r12
    ffa8:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
		  sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    ffac:	ad b7       	in	r26, 0x3d	; 61
    ffae:	be b7       	in	r27, 0x3e	; 62
    ffb0:	18 97       	sbiw	r26, 0x08	; 8
    ffb2:	0f b6       	in	r0, 0x3f	; 63
    ffb4:	f8 94       	cli
    ffb6:	be bf       	out	0x3e, r27	; 62
    ffb8:	0f be       	out	0x3f, r0	; 63
    ffba:	ad bf       	out	0x3d, r26	; 61
    ffbc:	ed b7       	in	r30, 0x3d	; 61
    ffbe:	fe b7       	in	r31, 0x3e	; 62
    ffc0:	31 96       	adiw	r30, 0x01	; 1
    ffc2:	12 96       	adiw	r26, 0x02	; 2
    ffc4:	dc 92       	st	X, r13
    ffc6:	ce 92       	st	-X, r12
    ffc8:	11 97       	sbiw	r26, 0x01	; 1
    ffca:	80 e3       	ldi	r24, 0x30	; 48
    ffcc:	93 e2       	ldi	r25, 0x23	; 35
    ffce:	93 83       	std	Z+3, r25	; 0x03
    ffd0:	82 83       	std	Z+2, r24	; 0x02
    ffd2:	8d e7       	ldi	r24, 0x7D	; 125
    ffd4:	98 e0       	ldi	r25, 0x08	; 8
    ffd6:	95 83       	std	Z+5, r25	; 0x05
    ffd8:	84 83       	std	Z+4, r24	; 0x04
    ffda:	85 ea       	ldi	r24, 0xA5	; 165
    ffdc:	93 e0       	ldi	r25, 0x03	; 3
    ffde:	b5 c0       	rjmp	.+362    	; 0x1014a <IFTSendMessage+0x55c>
		  uart_print(1,0,strSend);
	      break;

	 case MSG_56://strCardID, FIP_ID
	      UpdateCardID();
    ffe0:	0e 94 ec 42 	call	0x85d8	; 0x85d8 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s"),strCardID);
    ffe4:	00 d0       	rcall	.+0      	; 0xffe6 <IFTSendMessage+0x3f8>
    ffe6:	00 d0       	rcall	.+0      	; 0xffe8 <IFTSendMessage+0x3fa>
    ffe8:	00 d0       	rcall	.+0      	; 0xffea <IFTSendMessage+0x3fc>
    ffea:	ed b7       	in	r30, 0x3d	; 61
    ffec:	fe b7       	in	r31, 0x3e	; 62
    ffee:	31 96       	adiw	r30, 0x01	; 1
    fff0:	ad b7       	in	r26, 0x3d	; 61
    fff2:	be b7       	in	r27, 0x3e	; 62
    fff4:	12 96       	adiw	r26, 0x02	; 2
    fff6:	dc 92       	st	X, r13
    fff8:	ce 92       	st	-X, r12
    fffa:	11 97       	sbiw	r26, 0x01	; 1
    fffc:	8d e2       	ldi	r24, 0x2D	; 45
    fffe:	93 e2       	ldi	r25, 0x23	; 35
   10000:	93 83       	std	Z+3, r25	; 0x03
   10002:	82 83       	std	Z+2, r24	; 0x02
   10004:	89 e8       	ldi	r24, 0x89	; 137
   10006:	9b e0       	ldi	r25, 0x0B	; 11
   10008:	11 c1       	rjmp	.+546    	; 0x1022c <IFTSendMessage+0x63e>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_58://Request Local Account Transaction
	      UpdateCardID();
   1000a:	0e 94 ec 42 	call	0x85d8	; 0x85d8 <UpdateCardID>
		  AddSpaceLead(strBalanceValue,13);
   1000e:	8f e1       	ldi	r24, 0x1F	; 31
   10010:	a8 2e       	mov	r10, r24
   10012:	8c e0       	ldi	r24, 0x0C	; 12
   10014:	b8 2e       	mov	r11, r24
   10016:	c5 01       	movw	r24, r10
   10018:	6d e0       	ldi	r22, 0x0D	; 13
   1001a:	0e 94 78 30 	call	0x60f0	; 0x60f0 <AddSpaceLead>
		  AddSpaceLead(strOdometer,10);
   1001e:	03 ec       	ldi	r16, 0xC3	; 195
   10020:	e0 2e       	mov	r14, r16
   10022:	03 e0       	ldi	r16, 0x03	; 3
   10024:	f0 2e       	mov	r15, r16
   10026:	c7 01       	movw	r24, r14
   10028:	6a e0       	ldi	r22, 0x0A	; 10
   1002a:	0e 94 78 30 	call	0x60f0	; 0x60f0 <AddSpaceLead>
		  CardType=0;
   1002e:	10 92 89 03 	sts	0x0389, r1
		  sprintf_P(strSend,PSTR("%s%s%d"),strCardID,strFIP_ID,NozzleID);
   10032:	ad b7       	in	r26, 0x3d	; 61
   10034:	be b7       	in	r27, 0x3e	; 62
   10036:	1a 97       	sbiw	r26, 0x0a	; 10
   10038:	0f b6       	in	r0, 0x3f	; 63
   1003a:	f8 94       	cli
   1003c:	be bf       	out	0x3e, r27	; 62
   1003e:	0f be       	out	0x3f, r0	; 63
   10040:	ad bf       	out	0x3d, r26	; 61
   10042:	ed b7       	in	r30, 0x3d	; 61
   10044:	fe b7       	in	r31, 0x3e	; 62
   10046:	31 96       	adiw	r30, 0x01	; 1
   10048:	12 96       	adiw	r26, 0x02	; 2
   1004a:	dc 92       	st	X, r13
   1004c:	ce 92       	st	-X, r12
   1004e:	11 97       	sbiw	r26, 0x01	; 1
   10050:	86 e2       	ldi	r24, 0x26	; 38
   10052:	93 e2       	ldi	r25, 0x23	; 35
   10054:	93 83       	std	Z+3, r25	; 0x03
   10056:	82 83       	std	Z+2, r24	; 0x02
   10058:	89 e8       	ldi	r24, 0x89	; 137
   1005a:	9b e0       	ldi	r25, 0x0B	; 11
   1005c:	95 83       	std	Z+5, r25	; 0x05
   1005e:	84 83       	std	Z+4, r24	; 0x04
   10060:	89 eb       	ldi	r24, 0xB9	; 185
   10062:	97 e0       	ldi	r25, 0x07	; 7
   10064:	97 83       	std	Z+7, r25	; 0x07
   10066:	86 83       	std	Z+6, r24	; 0x06
   10068:	80 91 6d 07 	lds	r24, 0x076D
   1006c:	80 87       	std	Z+8, r24	; 0x08
   1006e:	11 86       	std	Z+9, r1	; 0x09
   10070:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  uart_print(1,0,strSend);
   10074:	8d b7       	in	r24, 0x3d	; 61
   10076:	9e b7       	in	r25, 0x3e	; 62
   10078:	0a 96       	adiw	r24, 0x0a	; 10
   1007a:	0f b6       	in	r0, 0x3f	; 63
   1007c:	f8 94       	cli
   1007e:	9e bf       	out	0x3e, r25	; 62
   10080:	0f be       	out	0x3f, r0	; 63
   10082:	8d bf       	out	0x3d, r24	; 61
   10084:	81 e0       	ldi	r24, 0x01	; 1
   10086:	60 e0       	ldi	r22, 0x00	; 0
   10088:	a6 01       	movw	r20, r12
   1008a:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
		  sprintf_P(strSend,PSTR("%s%s%d"),strBalanceType,strBalanceValue,CardType);
   1008e:	ad b7       	in	r26, 0x3d	; 61
   10090:	be b7       	in	r27, 0x3e	; 62
   10092:	1a 97       	sbiw	r26, 0x0a	; 10
   10094:	0f b6       	in	r0, 0x3f	; 63
   10096:	f8 94       	cli
   10098:	be bf       	out	0x3e, r27	; 62
   1009a:	0f be       	out	0x3f, r0	; 63
   1009c:	ad bf       	out	0x3d, r26	; 61
   1009e:	ed b7       	in	r30, 0x3d	; 61
   100a0:	fe b7       	in	r31, 0x3e	; 62
   100a2:	31 96       	adiw	r30, 0x01	; 1
   100a4:	12 96       	adiw	r26, 0x02	; 2
   100a6:	dc 92       	st	X, r13
   100a8:	ce 92       	st	-X, r12
   100aa:	11 97       	sbiw	r26, 0x01	; 1
   100ac:	8f e1       	ldi	r24, 0x1F	; 31
   100ae:	93 e2       	ldi	r25, 0x23	; 35
   100b0:	93 83       	std	Z+3, r25	; 0x03
   100b2:	82 83       	std	Z+2, r24	; 0x02
   100b4:	83 ea       	ldi	r24, 0xA3	; 163
   100b6:	93 e0       	ldi	r25, 0x03	; 3
   100b8:	95 83       	std	Z+5, r25	; 0x05
   100ba:	84 83       	std	Z+4, r24	; 0x04
   100bc:	b7 82       	std	Z+7, r11	; 0x07
   100be:	a6 82       	std	Z+6, r10	; 0x06
   100c0:	80 91 89 03 	lds	r24, 0x0389
   100c4:	80 87       	std	Z+8, r24	; 0x08
   100c6:	11 86       	std	Z+9, r1	; 0x09
   100c8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  uart_print(1,0,strSend);
   100cc:	8d b7       	in	r24, 0x3d	; 61
   100ce:	9e b7       	in	r25, 0x3e	; 62
   100d0:	0a 96       	adiw	r24, 0x0a	; 10
   100d2:	0f b6       	in	r0, 0x3f	; 63
   100d4:	f8 94       	cli
   100d6:	9e bf       	out	0x3e, r25	; 62
   100d8:	0f be       	out	0x3f, r0	; 63
   100da:	8d bf       	out	0x3d, r24	; 61
   100dc:	81 e0       	ldi	r24, 0x01	; 1
   100de:	60 e0       	ldi	r22, 0x00	; 0
   100e0:	a6 01       	movw	r20, r12
   100e2:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
		  uart_printf(1,0,PSTR("F0000000E123456FFFFF"));
   100e6:	81 e0       	ldi	r24, 0x01	; 1
   100e8:	60 e0       	ldi	r22, 0x00	; 0
   100ea:	4a e0       	ldi	r20, 0x0A	; 10
   100ec:	53 e2       	ldi	r21, 0x23	; 35
   100ee:	0e 94 2c ae 	call	0x15c58	; 0x15c58 <uart_printf>
		  sprintf_P(strSend,PSTR("%s"),strOdometer);
   100f2:	00 d0       	rcall	.+0      	; 0x100f4 <IFTSendMessage+0x506>
   100f4:	00 d0       	rcall	.+0      	; 0x100f6 <IFTSendMessage+0x508>
   100f6:	00 d0       	rcall	.+0      	; 0x100f8 <IFTSendMessage+0x50a>
   100f8:	ed b7       	in	r30, 0x3d	; 61
   100fa:	fe b7       	in	r31, 0x3e	; 62
   100fc:	31 96       	adiw	r30, 0x01	; 1
   100fe:	ad b7       	in	r26, 0x3d	; 61
   10100:	be b7       	in	r27, 0x3e	; 62
   10102:	12 96       	adiw	r26, 0x02	; 2
   10104:	dc 92       	st	X, r13
   10106:	ce 92       	st	-X, r12
   10108:	11 97       	sbiw	r26, 0x01	; 1
   1010a:	87 e0       	ldi	r24, 0x07	; 7
   1010c:	93 e2       	ldi	r25, 0x23	; 35
   1010e:	93 83       	std	Z+3, r25	; 0x03
   10110:	82 83       	std	Z+2, r24	; 0x02
   10112:	f5 82       	std	Z+5, r15	; 0x05
   10114:	e4 82       	std	Z+4, r14	; 0x04
   10116:	8c c0       	rjmp	.+280    	; 0x10230 <IFTSendMessage+0x642>
		  uart_print(1,0,strSend);
		  break;
	 case MSG_90://Request EDC
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
   10118:	ad b7       	in	r26, 0x3d	; 61
   1011a:	be b7       	in	r27, 0x3e	; 62
   1011c:	18 97       	sbiw	r26, 0x08	; 8
   1011e:	0f b6       	in	r0, 0x3f	; 63
   10120:	f8 94       	cli
   10122:	be bf       	out	0x3e, r27	; 62
   10124:	0f be       	out	0x3f, r0	; 63
   10126:	ad bf       	out	0x3d, r26	; 61
   10128:	ed b7       	in	r30, 0x3d	; 61
   1012a:	fe b7       	in	r31, 0x3e	; 62
   1012c:	31 96       	adiw	r30, 0x01	; 1
   1012e:	12 96       	adiw	r26, 0x02	; 2
   10130:	dc 92       	st	X, r13
   10132:	ce 92       	st	-X, r12
   10134:	11 97       	sbiw	r26, 0x01	; 1
   10136:	82 e0       	ldi	r24, 0x02	; 2
   10138:	93 e2       	ldi	r25, 0x23	; 35
   1013a:	93 83       	std	Z+3, r25	; 0x03
   1013c:	82 83       	std	Z+2, r24	; 0x02
   1013e:	89 eb       	ldi	r24, 0xB9	; 185
   10140:	97 e0       	ldi	r25, 0x07	; 7
   10142:	95 83       	std	Z+5, r25	; 0x05
   10144:	84 83       	std	Z+4, r24	; 0x04
   10146:	8e e8       	ldi	r24, 0x8E	; 142
   10148:	9c e0       	ldi	r25, 0x0C	; 12
   1014a:	97 83       	std	Z+7, r25	; 0x07
   1014c:	86 83       	std	Z+6, r24	; 0x06
   1014e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	      uart_print(1, 0,strSend);
   10152:	8d b7       	in	r24, 0x3d	; 61
   10154:	9e b7       	in	r25, 0x3e	; 62
   10156:	08 96       	adiw	r24, 0x08	; 8
   10158:	70 c0       	rjmp	.+224    	; 0x1023a <IFTSendMessage+0x64c>
	      break;
	 case MSG_92://EDC Approval
		  sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
   1015a:	ad b7       	in	r26, 0x3d	; 61
   1015c:	be b7       	in	r27, 0x3e	; 62
   1015e:	1c 97       	sbiw	r26, 0x0c	; 12
   10160:	0f b6       	in	r0, 0x3f	; 63
   10162:	f8 94       	cli
   10164:	be bf       	out	0x3e, r27	; 62
   10166:	0f be       	out	0x3f, r0	; 63
   10168:	ad bf       	out	0x3d, r26	; 61
   1016a:	ed b7       	in	r30, 0x3d	; 61
   1016c:	fe b7       	in	r31, 0x3e	; 62
   1016e:	31 96       	adiw	r30, 0x01	; 1
   10170:	12 96       	adiw	r26, 0x02	; 2
   10172:	dc 92       	st	X, r13
   10174:	ce 92       	st	-X, r12
   10176:	11 97       	sbiw	r26, 0x01	; 1
   10178:	89 ef       	ldi	r24, 0xF9	; 249
   1017a:	92 e2       	ldi	r25, 0x22	; 34
   1017c:	93 83       	std	Z+3, r25	; 0x03
   1017e:	82 83       	std	Z+2, r24	; 0x02
   10180:	87 e8       	ldi	r24, 0x87	; 135
   10182:	9c e0       	ldi	r25, 0x0C	; 12
   10184:	95 83       	std	Z+5, r25	; 0x05
   10186:	84 83       	std	Z+4, r24	; 0x04
   10188:	89 eb       	ldi	r24, 0xB9	; 185
   1018a:	97 e0       	ldi	r25, 0x07	; 7
   1018c:	97 83       	std	Z+7, r25	; 0x07
   1018e:	86 83       	std	Z+6, r24	; 0x06
   10190:	83 ea       	ldi	r24, 0xA3	; 163
   10192:	9c e0       	ldi	r25, 0x0C	; 12
   10194:	91 87       	std	Z+9, r25	; 0x09
   10196:	80 87       	std	Z+8, r24	; 0x08
   10198:	89 e8       	ldi	r24, 0x89	; 137
   1019a:	9b e0       	ldi	r25, 0x0B	; 11
   1019c:	93 87       	std	Z+11, r25	; 0x0b
   1019e:	82 87       	std	Z+10, r24	; 0x0a
   101a0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	      uart_print(1,0,strSend);	    
   101a4:	8d b7       	in	r24, 0x3d	; 61
   101a6:	9e b7       	in	r25, 0x3e	; 62
   101a8:	0c 96       	adiw	r24, 0x0c	; 12
   101aa:	0f b6       	in	r0, 0x3f	; 63
   101ac:	f8 94       	cli
   101ae:	9e bf       	out	0x3e, r25	; 62
   101b0:	0f be       	out	0x3f, r0	; 63
   101b2:	8d bf       	out	0x3d, r24	; 61
   101b4:	81 e0       	ldi	r24, 0x01	; 1
   101b6:	60 e0       	ldi	r22, 0x00	; 0
   101b8:	a6 01       	movw	r20, r12
   101ba:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
		  sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
   101be:	ad b7       	in	r26, 0x3d	; 61
   101c0:	be b7       	in	r27, 0x3e	; 62
   101c2:	1a 97       	sbiw	r26, 0x0a	; 10
   101c4:	0f b6       	in	r0, 0x3f	; 63
   101c6:	f8 94       	cli
   101c8:	be bf       	out	0x3e, r27	; 62
   101ca:	0f be       	out	0x3f, r0	; 63
   101cc:	ad bf       	out	0x3d, r26	; 61
   101ce:	ed b7       	in	r30, 0x3d	; 61
   101d0:	fe b7       	in	r31, 0x3e	; 62
   101d2:	31 96       	adiw	r30, 0x01	; 1
   101d4:	12 96       	adiw	r26, 0x02	; 2
   101d6:	dc 92       	st	X, r13
   101d8:	ce 92       	st	-X, r12
   101da:	11 97       	sbiw	r26, 0x01	; 1
   101dc:	82 ef       	ldi	r24, 0xF2	; 242
   101de:	92 e2       	ldi	r25, 0x22	; 34
   101e0:	93 83       	std	Z+3, r25	; 0x03
   101e2:	82 83       	std	Z+2, r24	; 0x02
   101e4:	80 ef       	ldi	r24, 0xF0	; 240
   101e6:	97 e0       	ldi	r25, 0x07	; 7
   101e8:	95 83       	std	Z+5, r25	; 0x05
   101ea:	84 83       	std	Z+4, r24	; 0x04
   101ec:	83 e5       	ldi	r24, 0x53	; 83
   101ee:	97 e0       	ldi	r25, 0x07	; 7
   101f0:	97 83       	std	Z+7, r25	; 0x07
   101f2:	86 83       	std	Z+6, r24	; 0x06
   101f4:	8f eb       	ldi	r24, 0xBF	; 191
   101f6:	9b e0       	ldi	r25, 0x0B	; 11
   101f8:	91 87       	std	Z+9, r25	; 0x09
   101fa:	80 87       	std	Z+8, r24	; 0x08
   101fc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	      uart_print(1,0,strSend);
   10200:	8d b7       	in	r24, 0x3d	; 61
   10202:	9e b7       	in	r25, 0x3e	; 62
   10204:	0a 96       	adiw	r24, 0x0a	; 10
   10206:	19 c0       	rjmp	.+50     	; 0x1023a <IFTSendMessage+0x64c>
	      break;	 
	 case MSG_98://Request Transaction Info
	      sprintf_P(strSend,PSTR("%s"),strFIP_ID);
   10208:	00 d0       	rcall	.+0      	; 0x1020a <IFTSendMessage+0x61c>
   1020a:	00 d0       	rcall	.+0      	; 0x1020c <IFTSendMessage+0x61e>
   1020c:	00 d0       	rcall	.+0      	; 0x1020e <IFTSendMessage+0x620>
   1020e:	ed b7       	in	r30, 0x3d	; 61
   10210:	fe b7       	in	r31, 0x3e	; 62
   10212:	31 96       	adiw	r30, 0x01	; 1
   10214:	ad b7       	in	r26, 0x3d	; 61
   10216:	be b7       	in	r27, 0x3e	; 62
   10218:	12 96       	adiw	r26, 0x02	; 2
   1021a:	dc 92       	st	X, r13
   1021c:	ce 92       	st	-X, r12
   1021e:	11 97       	sbiw	r26, 0x01	; 1
   10220:	8f ee       	ldi	r24, 0xEF	; 239
   10222:	92 e2       	ldi	r25, 0x22	; 34
   10224:	93 83       	std	Z+3, r25	; 0x03
   10226:	82 83       	std	Z+2, r24	; 0x02
   10228:	89 eb       	ldi	r24, 0xB9	; 185
   1022a:	97 e0       	ldi	r25, 0x07	; 7
   1022c:	95 83       	std	Z+5, r25	; 0x05
   1022e:	84 83       	std	Z+4, r24	; 0x04
   10230:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	      uart_print(1, 0,strSend);
   10234:	8d b7       	in	r24, 0x3d	; 61
   10236:	9e b7       	in	r25, 0x3e	; 62
   10238:	06 96       	adiw	r24, 0x06	; 6
   1023a:	0f b6       	in	r0, 0x3f	; 63
   1023c:	f8 94       	cli
   1023e:	9e bf       	out	0x3e, r25	; 62
   10240:	0f be       	out	0x3f, r0	; 63
   10242:	8d bf       	out	0x3d, r24	; 61
   10244:	81 e0       	ldi	r24, 0x01	; 1
   10246:	60 e0       	ldi	r22, 0x00	; 0
   10248:	a6 01       	movw	r20, r12
   1024a:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
	      break;

	 }     
     //[Checksum]
	 uart_printf(1,0,PSTR("F968CFFB"));
   1024e:	81 e0       	ldi	r24, 0x01	; 1
   10250:	60 e0       	ldi	r22, 0x00	; 0
   10252:	46 ee       	ldi	r20, 0xE6	; 230
   10254:	52 e2       	ldi	r21, 0x22	; 34
   10256:	0e 94 2c ae 	call	0x15c58	; 0x15c58 <uart_printf>
	 //ETX
	 uart(1, 1,0x02);
   1025a:	81 e0       	ldi	r24, 0x01	; 1
   1025c:	61 e0       	ldi	r22, 0x01	; 1
   1025e:	42 e0       	ldi	r20, 0x02	; 2
   10260:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
}
   10264:	c0 5c       	subi	r28, 0xC0	; 192
   10266:	df 4f       	sbci	r29, 0xFF	; 255
   10268:	0f b6       	in	r0, 0x3f	; 63
   1026a:	f8 94       	cli
   1026c:	de bf       	out	0x3e, r29	; 62
   1026e:	0f be       	out	0x3f, r0	; 63
   10270:	cd bf       	out	0x3d, r28	; 61
   10272:	cf 91       	pop	r28
   10274:	df 91       	pop	r29
   10276:	0f 91       	pop	r16
   10278:	ff 90       	pop	r15
   1027a:	ef 90       	pop	r14
   1027c:	df 90       	pop	r13
   1027e:	cf 90       	pop	r12
   10280:	bf 90       	pop	r11
   10282:	af 90       	pop	r10
   10284:	08 95       	ret

00010286 <sendMessage98>:
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
	uart_print(1, 0,strSend);
	uart(1, 1,0x02);
*/
    sprintf_P(strFIP_ID,PSTR("%.2d"),GetPumpID(FIPAddr));
   10286:	0e 94 e5 21 	call	0x43ca	; 0x43ca <GetPumpID>
   1028a:	00 d0       	rcall	.+0      	; 0x1028c <sendMessage98+0x6>
   1028c:	00 d0       	rcall	.+0      	; 0x1028e <sendMessage98+0x8>
   1028e:	00 d0       	rcall	.+0      	; 0x10290 <sendMessage98+0xa>
   10290:	ed b7       	in	r30, 0x3d	; 61
   10292:	fe b7       	in	r31, 0x3e	; 62
   10294:	31 96       	adiw	r30, 0x01	; 1
   10296:	29 eb       	ldi	r18, 0xB9	; 185
   10298:	37 e0       	ldi	r19, 0x07	; 7
   1029a:	ad b7       	in	r26, 0x3d	; 61
   1029c:	be b7       	in	r27, 0x3e	; 62
   1029e:	12 96       	adiw	r26, 0x02	; 2
   102a0:	3c 93       	st	X, r19
   102a2:	2e 93       	st	-X, r18
   102a4:	11 97       	sbiw	r26, 0x01	; 1
   102a6:	21 ee       	ldi	r18, 0xE1	; 225
   102a8:	32 e2       	ldi	r19, 0x22	; 34
   102aa:	33 83       	std	Z+3, r19	; 0x03
   102ac:	22 83       	std	Z+2, r18	; 0x02
   102ae:	84 83       	std	Z+4, r24	; 0x04
   102b0:	15 82       	std	Z+5, r1	; 0x05
   102b2:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	IFTSendMessage(MSG_98);
   102b6:	8d b7       	in	r24, 0x3d	; 61
   102b8:	9e b7       	in	r25, 0x3e	; 62
   102ba:	06 96       	adiw	r24, 0x06	; 6
   102bc:	0f b6       	in	r0, 0x3f	; 63
   102be:	f8 94       	cli
   102c0:	9e bf       	out	0x3e, r25	; 62
   102c2:	0f be       	out	0x3f, r0	; 63
   102c4:	8d bf       	out	0x3d, r24	; 61
   102c6:	88 e9       	ldi	r24, 0x98	; 152
   102c8:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
	IsBusyMsg11=True;
   102cc:	81 e0       	ldi	r24, 0x01	; 1
   102ce:	80 93 ad 01 	sts	0x01AD, r24
}
   102d2:	08 95       	ret

000102d4 <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   102d4:	ef 92       	push	r14
   102d6:	0f 93       	push	r16
   102d8:	1f 93       	push	r17
   102da:	df 93       	push	r29
   102dc:	cf 93       	push	r28
   102de:	cd b7       	in	r28, 0x3d	; 61
   102e0:	de b7       	in	r29, 0x3e	; 62
   102e2:	64 97       	sbiw	r28, 0x14	; 20
   102e4:	0f b6       	in	r0, 0x3f	; 63
   102e6:	f8 94       	cli
   102e8:	de bf       	out	0x3e, r29	; 62
   102ea:	0f be       	out	0x3f, r0	; 63
   102ec:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoop=0;
     char uiResult=USER_NONE,KeyPressed,KeyChar;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   102ee:	80 91 0d 02 	lds	r24, 0x020D
   102f2:	86 30       	cpi	r24, 0x06	; 6
   102f4:	09 f4       	brne	.+2      	; 0x102f8 <FMenuTicket+0x24>
   102f6:	bf c0       	rjmp	.+382    	; 0x10476 <FMenuTicket+0x1a2>
   102f8:	87 30       	cpi	r24, 0x07	; 7
   102fa:	88 f4       	brcc	.+34     	; 0x1031e <FMenuTicket+0x4a>
   102fc:	82 30       	cpi	r24, 0x02	; 2
   102fe:	e9 f1       	breq	.+122    	; 0x1037a <FMenuTicket+0xa6>
   10300:	83 30       	cpi	r24, 0x03	; 3
   10302:	30 f4       	brcc	.+12     	; 0x10310 <FMenuTicket+0x3c>
   10304:	88 23       	and	r24, r24
   10306:	09 f1       	breq	.+66     	; 0x1034a <FMenuTicket+0x76>
   10308:	81 30       	cpi	r24, 0x01	; 1
   1030a:	09 f0       	breq	.+2      	; 0x1030e <FMenuTicket+0x3a>
   1030c:	21 c1       	rjmp	.+578    	; 0x10550 <FMenuTicket+0x27c>
   1030e:	1f c0       	rjmp	.+62     	; 0x1034e <FMenuTicket+0x7a>
   10310:	84 30       	cpi	r24, 0x04	; 4
   10312:	09 f4       	brne	.+2      	; 0x10316 <FMenuTicket+0x42>
   10314:	87 c0       	rjmp	.+270    	; 0x10424 <FMenuTicket+0x150>
   10316:	85 30       	cpi	r24, 0x05	; 5
   10318:	08 f0       	brcs	.+2      	; 0x1031c <FMenuTicket+0x48>
   1031a:	a7 c0       	rjmp	.+334    	; 0x1046a <FMenuTicket+0x196>
   1031c:	4d c0       	rjmp	.+154    	; 0x103b8 <FMenuTicket+0xe4>
   1031e:	89 30       	cpi	r24, 0x09	; 9
   10320:	09 f4       	brne	.+2      	; 0x10324 <FMenuTicket+0x50>
   10322:	f4 c0       	rjmp	.+488    	; 0x1050c <FMenuTicket+0x238>
   10324:	8a 30       	cpi	r24, 0x0A	; 10
   10326:	38 f4       	brcc	.+14     	; 0x10336 <FMenuTicket+0x62>
   10328:	87 30       	cpi	r24, 0x07	; 7
   1032a:	09 f4       	brne	.+2      	; 0x1032e <FMenuTicket+0x5a>
   1032c:	d2 c0       	rjmp	.+420    	; 0x104d2 <FMenuTicket+0x1fe>
   1032e:	88 30       	cpi	r24, 0x08	; 8
   10330:	09 f0       	breq	.+2      	; 0x10334 <FMenuTicket+0x60>
   10332:	0e c1       	rjmp	.+540    	; 0x10550 <FMenuTicket+0x27c>
   10334:	be c0       	rjmp	.+380    	; 0x104b2 <FMenuTicket+0x1de>
   10336:	8b 30       	cpi	r24, 0x0B	; 11
   10338:	09 f4       	brne	.+2      	; 0x1033c <FMenuTicket+0x68>
   1033a:	ee c0       	rjmp	.+476    	; 0x10518 <FMenuTicket+0x244>
   1033c:	8b 30       	cpi	r24, 0x0B	; 11
   1033e:	08 f4       	brcc	.+2      	; 0x10342 <FMenuTicket+0x6e>
   10340:	01 c1       	rjmp	.+514    	; 0x10544 <FMenuTicket+0x270>
   10342:	8c 30       	cpi	r24, 0x0C	; 12
   10344:	09 f0       	breq	.+2      	; 0x10348 <FMenuTicket+0x74>
   10346:	04 c1       	rjmp	.+520    	; 0x10550 <FMenuTicket+0x27c>
   10348:	ff c0       	rjmp	.+510    	; 0x10548 <FMenuTicket+0x274>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   1034a:	81 e0       	ldi	r24, 0x01	; 1
   1034c:	79 c0       	rjmp	.+242    	; 0x10440 <FMenuTicket+0x16c>
	     break;
    case mtPlatNo:
	     lcd_clear();
   1034e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   10352:	81 e0       	ldi	r24, 0x01	; 1
   10354:	61 e0       	ldi	r22, 0x01	; 1
   10356:	4f e5       	ldi	r20, 0x5F	; 95
   10358:	5c e0       	ldi	r21, 0x0C	; 12
   1035a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   1035e:	82 e0       	ldi	r24, 0x02	; 2
   10360:	61 e0       	ldi	r22, 0x01	; 1
   10362:	4d e5       	ldi	r20, 0x5D	; 93
   10364:	5c e0       	ldi	r21, 0x0C	; 12
   10366:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   1036a:	84 e0       	ldi	r24, 0x04	; 4
   1036c:	61 e0       	ldi	r22, 0x01	; 1
   1036e:	48 e4       	ldi	r20, 0x48	; 72
   10370:	5c e0       	ldi	r21, 0x0C	; 12
   10372:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		 uiResult=USER_NONE;
		 stMenuTicket=mtInputPlatNo;
   10376:	82 e0       	ldi	r24, 0x02	; 2
   10378:	63 c0       	rjmp	.+198    	; 0x10440 <FMenuTicket+0x16c>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   1037a:	83 e0       	ldi	r24, 0x03	; 3
   1037c:	62 e0       	ldi	r22, 0x02	; 2
   1037e:	41 e0       	ldi	r20, 0x01	; 1
   10380:	2a ef       	ldi	r18, 0xFA	; 250
   10382:	38 e0       	ldi	r19, 0x08	; 8
   10384:	00 e0       	ldi	r16, 0x00	; 0
   10386:	10 e0       	ldi	r17, 0x00	; 0
   10388:	7a e0       	ldi	r23, 0x0A	; 10
   1038a:	e7 2e       	mov	r14, r23
   1038c:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10390:	83 30       	cpi	r24, 0x03	; 3
   10392:	09 f4       	brne	.+2      	; 0x10396 <FMenuTicket+0xc2>
   10394:	55 c0       	rjmp	.+170    	; 0x10440 <FMenuTicket+0x16c>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   10396:	81 30       	cpi	r24, 0x01	; 1
   10398:	09 f4       	brne	.+2      	; 0x1039c <FMenuTicket+0xc8>
   1039a:	d4 c0       	rjmp	.+424    	; 0x10544 <FMenuTicket+0x270>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1039c:	84 30       	cpi	r24, 0x04	; 4
   1039e:	21 f4       	brne	.+8      	; 0x103a8 <FMenuTicket+0xd4>
   103a0:	61 e0       	ldi	r22, 0x01	; 1
   103a2:	43 e3       	ldi	r20, 0x33	; 51
   103a4:	5c e0       	ldi	r21, 0x0C	; 12
   103a6:	5e c0       	rjmp	.+188    	; 0x10464 <FMenuTicket+0x190>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   103a8:	85 30       	cpi	r24, 0x05	; 5
   103aa:	09 f0       	breq	.+2      	; 0x103ae <FMenuTicket+0xda>
   103ac:	d1 c0       	rjmp	.+418    	; 0x10550 <FMenuTicket+0x27c>
   103ae:	84 e0       	ldi	r24, 0x04	; 4
   103b0:	61 e0       	ldi	r22, 0x01	; 1
   103b2:	4e e1       	ldi	r20, 0x1E	; 30
   103b4:	5c e0       	ldi	r21, 0x0C	; 12
   103b6:	56 c0       	rjmp	.+172    	; 0x10464 <FMenuTicket+0x190>
	     break;
    case mtOdometer:
	     lcd_clear();
   103b8:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   103bc:	00 d0       	rcall	.+0      	; 0x103be <FMenuTicket+0xea>
   103be:	00 d0       	rcall	.+0      	; 0x103c0 <FMenuTicket+0xec>
   103c0:	00 d0       	rcall	.+0      	; 0x103c2 <FMenuTicket+0xee>
   103c2:	ed b7       	in	r30, 0x3d	; 61
   103c4:	fe b7       	in	r31, 0x3e	; 62
   103c6:	31 96       	adiw	r30, 0x01	; 1
   103c8:	8e 01       	movw	r16, r28
   103ca:	0f 5f       	subi	r16, 0xFF	; 255
   103cc:	1f 4f       	sbci	r17, 0xFF	; 255
   103ce:	ad b7       	in	r26, 0x3d	; 61
   103d0:	be b7       	in	r27, 0x3e	; 62
   103d2:	12 96       	adiw	r26, 0x02	; 2
   103d4:	1c 93       	st	X, r17
   103d6:	0e 93       	st	-X, r16
   103d8:	11 97       	sbiw	r26, 0x01	; 1
   103da:	81 e1       	ldi	r24, 0x11	; 17
   103dc:	9c e0       	ldi	r25, 0x0C	; 12
   103de:	93 83       	std	Z+3, r25	; 0x03
   103e0:	82 83       	std	Z+2, r24	; 0x02
   103e2:	8a ef       	ldi	r24, 0xFA	; 250
   103e4:	98 e0       	ldi	r25, 0x08	; 8
   103e6:	95 83       	std	Z+5, r25	; 0x05
   103e8:	84 83       	std	Z+4, r24	; 0x04
   103ea:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	     lcd_print(1,1,lcdteks);
   103ee:	8d b7       	in	r24, 0x3d	; 61
   103f0:	9e b7       	in	r25, 0x3e	; 62
   103f2:	06 96       	adiw	r24, 0x06	; 6
   103f4:	0f b6       	in	r0, 0x3f	; 63
   103f6:	f8 94       	cli
   103f8:	9e bf       	out	0x3e, r25	; 62
   103fa:	0f be       	out	0x3f, r0	; 63
   103fc:	8d bf       	out	0x3d, r24	; 61
   103fe:	81 e0       	ldi	r24, 0x01	; 1
   10400:	61 e0       	ldi	r22, 0x01	; 1
   10402:	a8 01       	movw	r20, r16
   10404:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   10408:	82 e0       	ldi	r24, 0x02	; 2
   1040a:	61 e0       	ldi	r22, 0x01	; 1
   1040c:	45 e0       	ldi	r20, 0x05	; 5
   1040e:	5c e0       	ldi	r21, 0x0C	; 12
   10410:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10414:	84 e0       	ldi	r24, 0x04	; 4
   10416:	61 e0       	ldi	r22, 0x01	; 1
   10418:	40 ef       	ldi	r20, 0xF0	; 240
   1041a:	5b e0       	ldi	r21, 0x0B	; 11
   1041c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		 uiResult=USER_NONE;
		 stMenuTicket=mtInputOdometer;
   10420:	84 e0       	ldi	r24, 0x04	; 4
   10422:	0e c0       	rjmp	.+28     	; 0x10440 <FMenuTicket+0x16c>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   10424:	81 e0       	ldi	r24, 0x01	; 1
   10426:	62 e0       	ldi	r22, 0x02	; 2
   10428:	4a e0       	ldi	r20, 0x0A	; 10
   1042a:	23 ec       	ldi	r18, 0xC3	; 195
   1042c:	33 e0       	ldi	r19, 0x03	; 3
   1042e:	00 e0       	ldi	r16, 0x00	; 0
   10430:	10 e0       	ldi	r17, 0x00	; 0
   10432:	5a e0       	ldi	r21, 0x0A	; 10
   10434:	e5 2e       	mov	r14, r21
   10436:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   1043a:	83 30       	cpi	r24, 0x03	; 3
   1043c:	21 f4       	brne	.+8      	; 0x10446 <FMenuTicket+0x172>
   1043e:	85 e0       	ldi	r24, 0x05	; 5
   10440:	80 93 0d 02 	sts	0x020D, r24
   10444:	85 c0       	rjmp	.+266    	; 0x10550 <FMenuTicket+0x27c>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   10446:	81 30       	cpi	r24, 0x01	; 1
   10448:	d9 f3       	breq	.-10     	; 0x10440 <FMenuTicket+0x16c>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1044a:	84 30       	cpi	r24, 0x04	; 4
   1044c:	21 f4       	brne	.+8      	; 0x10456 <FMenuTicket+0x182>
   1044e:	61 e0       	ldi	r22, 0x01	; 1
   10450:	4b ed       	ldi	r20, 0xDB	; 219
   10452:	5b e0       	ldi	r21, 0x0B	; 11
   10454:	07 c0       	rjmp	.+14     	; 0x10464 <FMenuTicket+0x190>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10456:	85 30       	cpi	r24, 0x05	; 5
   10458:	09 f0       	breq	.+2      	; 0x1045c <FMenuTicket+0x188>
   1045a:	7a c0       	rjmp	.+244    	; 0x10550 <FMenuTicket+0x27c>
   1045c:	84 e0       	ldi	r24, 0x04	; 4
   1045e:	61 e0       	ldi	r22, 0x01	; 1
   10460:	46 ec       	ldi	r20, 0xC6	; 198
   10462:	5b e0       	ldi	r21, 0x0B	; 11
   10464:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
   10468:	73 c0       	rjmp	.+230    	; 0x10550 <FMenuTicket+0x27c>
	     break;
    case mtFIP:
	     lcd_clear();
   1046a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		 _scr_pump();
   1046e:	0e 94 e7 49 	call	0x93ce	; 0x93ce <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10472:	86 e0       	ldi	r24, 0x06	; 6
   10474:	e5 cf       	rjmp	.-54     	; 0x10440 <FMenuTicket+0x16c>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10476:	81 e0       	ldi	r24, 0x01	; 1
   10478:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   1047c:	18 2f       	mov	r17, r24
		 KeyChar=_key_btn(KeyPressed);
   1047e:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10482:	81 53       	subi	r24, 0x31	; 49
   10484:	88 30       	cpi	r24, 0x08	; 8
   10486:	40 f4       	brcc	.+16     	; 0x10498 <FMenuTicket+0x1c4>
		     FIP_Used=KeyChar-'0';
   10488:	8f 5f       	subi	r24, 0xFF	; 255
   1048a:	80 93 0a 02 	sts	0x020A, r24
			 zFIP_Used=FIP_Used;
   1048e:	80 93 09 02 	sts	0x0209, r24
		     stMenuTicket=mtSendMsg98;
   10492:	87 e0       	ldi	r24, 0x07	; 7
   10494:	80 93 0d 02 	sts	0x020D, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10498:	17 3e       	cpi	r17, 0xE7	; 231
   1049a:	11 f4       	brne	.+4      	; 0x104a0 <FMenuTicket+0x1cc>
             stMenuTicket=mtOdometer;
   1049c:	83 e0       	ldi	r24, 0x03	; 3
   1049e:	d0 cf       	rjmp	.-96     	; 0x10440 <FMenuTicket+0x16c>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   104a0:	17 3b       	cpi	r17, 0xB7	; 183
   104a2:	09 f0       	breq	.+2      	; 0x104a6 <FMenuTicket+0x1d2>
   104a4:	55 c0       	rjmp	.+170    	; 0x10550 <FMenuTicket+0x27c>
		     FIP_Used=zFIP_Used;
   104a6:	80 91 09 02 	lds	r24, 0x0209
   104aa:	80 93 0a 02 	sts	0x020A, r24
             stMenuTicket=mtInitWaitMessage99;
   104ae:	88 e0       	ldi	r24, 0x08	; 8
   104b0:	c7 cf       	rjmp	.-114    	; 0x10440 <FMenuTicket+0x16c>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   104b2:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   104b6:	82 e0       	ldi	r24, 0x02	; 2
   104b8:	61 e0       	ldi	r22, 0x01	; 1
   104ba:	49 eb       	ldi	r20, 0xB9	; 185
   104bc:	5b e0       	ldi	r21, 0x0B	; 11
   104be:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   104c2:	83 e0       	ldi	r24, 0x03	; 3
   104c4:	61 e0       	ldi	r22, 0x01	; 1
   104c6:	42 eb       	ldi	r20, 0xB2	; 178
   104c8:	5b e0       	ldi	r21, 0x0B	; 11
   104ca:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
         stMenuTicket=mtSendMsg98;
   104ce:	87 e0       	ldi	r24, 0x07	; 7
   104d0:	b7 cf       	rjmp	.-146    	; 0x10440 <FMenuTicket+0x16c>
	     break;
    case mtSendMsg98:
	     iPos=0;
   104d2:	10 92 0c 02 	sts	0x020C, r1
		 iSend=0;
   104d6:	10 92 0b 02 	sts	0x020B, r1
		 IsMessage99=False;
   104da:	10 92 9f 01 	sts	0x019F, r1
		 TimSend=0;
   104de:	10 92 78 0c 	sts	0x0C78, r1
		 iLoop=0;
   104e2:	10 92 08 02 	sts	0x0208, r1
   104e6:	10 92 07 02 	sts	0x0207, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   104ea:	80 91 00 01 	lds	r24, 0x0100
   104ee:	81 30       	cpi	r24, 0x01	; 1
   104f0:	29 f4       	brne	.+10     	; 0x104fc <FMenuTicket+0x228>
   104f2:	80 91 0a 02 	lds	r24, 0x020A
   104f6:	0e 94 43 81 	call	0x10286	; 0x10286 <sendMessage98>
   104fa:	24 c0       	rjmp	.+72     	; 0x10544 <FMenuTicket+0x270>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   104fc:	82 30       	cpi	r24, 0x02	; 2
   104fe:	11 f5       	brne	.+68     	; 0x10544 <FMenuTicket+0x270>
   10500:	80 91 0a 02 	lds	r24, 0x020A
   10504:	60 e0       	ldi	r22, 0x00	; 0
   10506:	0e 94 36 24 	call	0x486c	; 0x486c <PrintStandalone>
   1050a:	1c c0       	rjmp	.+56     	; 0x10544 <FMenuTicket+0x270>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   1050c:	80 91 9f 01 	lds	r24, 0x019F
   10510:	81 30       	cpi	r24, 0x01	; 1
   10512:	f1 f4       	brne	.+60     	; 0x10550 <FMenuTicket+0x27c>
		    stMenuTicket=mtMessage99Received;
   10514:	8a e0       	ldi	r24, 0x0A	; 10
   10516:	94 cf       	rjmp	.-216    	; 0x10440 <FMenuTicket+0x16c>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10518:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   1051c:	82 e0       	ldi	r24, 0x02	; 2
   1051e:	61 e0       	ldi	r22, 0x01	; 1
   10520:	4e e9       	ldi	r20, 0x9E	; 158
   10522:	5b e0       	ldi	r21, 0x0B	; 11
   10524:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10528:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1052a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1052c:	82 e0       	ldi	r24, 0x02	; 2
   1052e:	80 93 bc 01 	sts	0x01BC, r24
   10532:	80 e2       	ldi	r24, 0x20	; 32
   10534:	9e e4       	ldi	r25, 0x4E	; 78
   10536:	20 e7       	ldi	r18, 0x70	; 112
   10538:	31 e0       	ldi	r19, 0x01	; 1
   1053a:	f9 01       	movw	r30, r18
   1053c:	31 97       	sbiw	r30, 0x01	; 1
   1053e:	f1 f7       	brne	.-4      	; 0x1053c <FMenuTicket+0x268>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10540:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10542:	d9 f7       	brne	.-10     	; 0x1053a <FMenuTicket+0x266>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10544:	8c e0       	ldi	r24, 0x0C	; 12
   10546:	7c cf       	rjmp	.-264    	; 0x10440 <FMenuTicket+0x16c>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10548:	10 92 0d 02 	sts	0x020D, r1
   1054c:	81 e0       	ldi	r24, 0x01	; 1
   1054e:	01 c0       	rjmp	.+2      	; 0x10552 <FMenuTicket+0x27e>
   10550:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10552:	64 96       	adiw	r28, 0x14	; 20
   10554:	0f b6       	in	r0, 0x3f	; 63
   10556:	f8 94       	cli
   10558:	de bf       	out	0x3e, r29	; 62
   1055a:	0f be       	out	0x3f, r0	; 63
   1055c:	cd bf       	out	0x3d, r28	; 61
   1055e:	cf 91       	pop	r28
   10560:	df 91       	pop	r29
   10562:	1f 91       	pop	r17
   10564:	0f 91       	pop	r16
   10566:	ef 90       	pop	r14
   10568:	08 95       	ret

0001056a <sendMessage94>:
	sprintf_P(strSend,PSTR("E9445512"));
    //uart_print(0, 0,strSend);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_94);
   1056a:	84 e9       	ldi	r24, 0x94	; 148
   1056c:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   10570:	08 95       	ret

00010572 <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    //uart_print(0, 0,strSend);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_92);
   10572:	82 e9       	ldi	r24, 0x92	; 146
   10574:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   10578:	08 95       	ret

0001057a <sendMessage90>:
    uart_print(1, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_90);
   1057a:	80 e9       	ldi	r24, 0x90	; 144
   1057c:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   10580:	08 95       	ret

00010582 <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
   10582:	0f 93       	push	r16
   10584:	1f 93       	push	r17
static char FIP_Used=0;
       char lcdteks[20],Result=MENU_NONE;
       char KeyPressed=0,KeyChar,FIPResult;

     Result=MENU_NONE;
	 switch(stEtransaction){
   10586:	80 91 62 02 	lds	r24, 0x0262
   1058a:	85 30       	cpi	r24, 0x05	; 5
   1058c:	09 f4       	brne	.+2      	; 0x10590 <FMenuEDCTransaction+0xe>
   1058e:	96 c0       	rjmp	.+300    	; 0x106bc <FMenuEDCTransaction+0x13a>
   10590:	86 30       	cpi	r24, 0x06	; 6
   10592:	90 f4       	brcc	.+36     	; 0x105b8 <FMenuEDCTransaction+0x36>
   10594:	82 30       	cpi	r24, 0x02	; 2
   10596:	09 f4       	brne	.+2      	; 0x1059a <FMenuEDCTransaction+0x18>
   10598:	52 c0       	rjmp	.+164    	; 0x1063e <FMenuEDCTransaction+0xbc>
   1059a:	83 30       	cpi	r24, 0x03	; 3
   1059c:	30 f4       	brcc	.+12     	; 0x105aa <FMenuEDCTransaction+0x28>
   1059e:	88 23       	and	r24, r24
   105a0:	f1 f0       	breq	.+60     	; 0x105de <FMenuEDCTransaction+0x5c>
   105a2:	81 30       	cpi	r24, 0x01	; 1
   105a4:	09 f0       	breq	.+2      	; 0x105a8 <FMenuEDCTransaction+0x26>
   105a6:	d2 c0       	rjmp	.+420    	; 0x1074c <FMenuEDCTransaction+0x1ca>
   105a8:	36 c0       	rjmp	.+108    	; 0x10616 <FMenuEDCTransaction+0x94>
   105aa:	83 30       	cpi	r24, 0x03	; 3
   105ac:	09 f4       	brne	.+2      	; 0x105b0 <FMenuEDCTransaction+0x2e>
   105ae:	57 c0       	rjmp	.+174    	; 0x1065e <FMenuEDCTransaction+0xdc>
   105b0:	84 30       	cpi	r24, 0x04	; 4
   105b2:	09 f0       	breq	.+2      	; 0x105b6 <FMenuEDCTransaction+0x34>
   105b4:	cb c0       	rjmp	.+406    	; 0x1074c <FMenuEDCTransaction+0x1ca>
   105b6:	7c c0       	rjmp	.+248    	; 0x106b0 <FMenuEDCTransaction+0x12e>
   105b8:	88 30       	cpi	r24, 0x08	; 8
   105ba:	09 f4       	brne	.+2      	; 0x105be <FMenuEDCTransaction+0x3c>
   105bc:	b7 c0       	rjmp	.+366    	; 0x1072c <FMenuEDCTransaction+0x1aa>
   105be:	89 30       	cpi	r24, 0x09	; 9
   105c0:	38 f4       	brcc	.+14     	; 0x105d0 <FMenuEDCTransaction+0x4e>
   105c2:	86 30       	cpi	r24, 0x06	; 6
   105c4:	09 f4       	brne	.+2      	; 0x105c8 <FMenuEDCTransaction+0x46>
   105c6:	8d c0       	rjmp	.+282    	; 0x106e2 <FMenuEDCTransaction+0x160>
   105c8:	87 30       	cpi	r24, 0x07	; 7
   105ca:	09 f0       	breq	.+2      	; 0x105ce <FMenuEDCTransaction+0x4c>
   105cc:	bf c0       	rjmp	.+382    	; 0x1074c <FMenuEDCTransaction+0x1ca>
   105ce:	8b c0       	rjmp	.+278    	; 0x106e6 <FMenuEDCTransaction+0x164>
   105d0:	89 30       	cpi	r24, 0x09	; 9
   105d2:	09 f4       	brne	.+2      	; 0x105d6 <FMenuEDCTransaction+0x54>
   105d4:	b1 c0       	rjmp	.+354    	; 0x10738 <FMenuEDCTransaction+0x1b6>
   105d6:	8a 30       	cpi	r24, 0x0A	; 10
   105d8:	09 f0       	breq	.+2      	; 0x105dc <FMenuEDCTransaction+0x5a>
   105da:	b8 c0       	rjmp	.+368    	; 0x1074c <FMenuEDCTransaction+0x1ca>
   105dc:	b3 c0       	rjmp	.+358    	; 0x10744 <FMenuEDCTransaction+0x1c2>
	 case etInit:
	      lcd_clear();
   105de:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
   105e2:	81 e0       	ldi	r24, 0x01	; 1
   105e4:	61 e0       	ldi	r22, 0x01	; 1
   105e6:	44 e6       	ldi	r20, 0x64	; 100
   105e8:	5c e1       	ldi	r21, 0x1C	; 28
   105ea:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
   105ee:	81 e0       	ldi	r24, 0x01	; 1
   105f0:	61 e0       	ldi	r22, 0x01	; 1
   105f2:	4f e4       	ldi	r20, 0x4F	; 79
   105f4:	5c e1       	ldi	r21, 0x1C	; 28
   105f6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
   105fa:	82 e0       	ldi	r24, 0x02	; 2
   105fc:	61 e0       	ldi	r22, 0x01	; 1
   105fe:	4a e3       	ldi	r20, 0x3A	; 58
   10600:	5c e1       	ldi	r21, 0x1C	; 28
   10602:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   10606:	84 e0       	ldi	r24, 0x04	; 4
   10608:	61 e0       	ldi	r22, 0x01	; 1
   1060a:	45 e2       	ldi	r20, 0x25	; 37
   1060c:	5c e1       	ldi	r21, 0x1C	; 28
   1060e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stEtransaction=etInputEDC;
   10612:	81 e0       	ldi	r24, 0x01	; 1
   10614:	63 c0       	rjmp	.+198    	; 0x106dc <FMenuEDCTransaction+0x15a>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
   10616:	81 e0       	ldi	r24, 0x01	; 1
   10618:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   1061c:	08 2f       	mov	r16, r24
		  KeyChar=_key_btn(KeyPressed);
   1061e:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
   10622:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
   10624:	81 53       	subi	r24, 0x31	; 49
   10626:	82 30       	cpi	r24, 0x02	; 2
   10628:	30 f4       	brcc	.+12     	; 0x10636 <FMenuEDCTransaction+0xb4>
		       EDCType=KeyChar-'0';
   1062a:	90 53       	subi	r25, 0x30	; 48
   1062c:	90 93 0b 08 	sts	0x080B, r25
		       stEtransaction=etSelectFIP;
   10630:	82 e0       	ldi	r24, 0x02	; 2
   10632:	80 93 62 02 	sts	0x0262, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
   10636:	07 3e       	cpi	r16, 0xE7	; 231
   10638:	09 f0       	breq	.+2      	; 0x1063c <FMenuEDCTransaction+0xba>
   1063a:	88 c0       	rjmp	.+272    	; 0x1074c <FMenuEDCTransaction+0x1ca>
   1063c:	81 c0       	rjmp	.+258    	; 0x10740 <FMenuEDCTransaction+0x1be>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
   1063e:	80 e0       	ldi	r24, 0x00	; 0
   10640:	90 e0       	ldi	r25, 0x00	; 0
   10642:	69 eb       	ldi	r22, 0xB9	; 185
   10644:	77 e0       	ldi	r23, 0x07	; 7
   10646:	0e 94 25 58 	call	0xb04a	; 0xb04a <menu_FIP>
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
   1064a:	88 23       	and	r24, r24
   1064c:	11 f4       	brne	.+4      	; 0x10652 <FMenuEDCTransaction+0xd0>
   1064e:	83 e0       	ldi	r24, 0x03	; 3
   10650:	45 c0       	rjmp	.+138    	; 0x106dc <FMenuEDCTransaction+0x15a>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
   10652:	82 30       	cpi	r24, 0x02	; 2
   10654:	09 f0       	breq	.+2      	; 0x10658 <FMenuEDCTransaction+0xd6>
   10656:	7a c0       	rjmp	.+244    	; 0x1074c <FMenuEDCTransaction+0x1ca>
   10658:	10 92 62 02 	sts	0x0262, r1
   1065c:	77 c0       	rjmp	.+238    	; 0x1074c <FMenuEDCTransaction+0x1ca>
   1065e:	ee e8       	ldi	r30, 0x8E	; 142
   10660:	fc e0       	ldi	r31, 0x0C	; 12
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   10662:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10664:	8c e0       	ldi	r24, 0x0C	; 12
   10666:	e3 3a       	cpi	r30, 0xA3	; 163
   10668:	f8 07       	cpc	r31, r24
   1066a:	d9 f7       	brne	.-10     	; 0x10662 <FMenuEDCTransaction+0xe0>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
   1066c:	80 91 0b 08 	lds	r24, 0x080B
   10670:	81 30       	cpi	r24, 0x01	; 1
   10672:	19 f4       	brne	.+6      	; 0x1067a <FMenuEDCTransaction+0xf8>
		      AddSpaceLag(strRef1,20);
   10674:	cf 01       	movw	r24, r30
   10676:	45 97       	sbiw	r24, 0x15	; 21
   10678:	16 c0       	rjmp	.+44     	; 0x106a6 <FMenuEDCTransaction+0x124>
          }
		  else
	      if (EDCType==2){
   1067a:	82 30       	cpi	r24, 0x02	; 2
   1067c:	b9 f4       	brne	.+46     	; 0x106ac <FMenuEDCTransaction+0x12a>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
   1067e:	00 d0       	rcall	.+0      	; 0x10680 <FMenuEDCTransaction+0xfe>
   10680:	00 d0       	rcall	.+0      	; 0x10682 <FMenuEDCTransaction+0x100>
   10682:	8f 01       	movw	r16, r30
   10684:	05 51       	subi	r16, 0x15	; 21
   10686:	10 40       	sbci	r17, 0x00	; 0
   10688:	ed b7       	in	r30, 0x3d	; 61
   1068a:	fe b7       	in	r31, 0x3e	; 62
   1068c:	12 83       	std	Z+2, r17	; 0x02
   1068e:	01 83       	std	Z+1, r16	; 0x01
   10690:	8a e1       	ldi	r24, 0x1A	; 26
   10692:	9c e1       	ldi	r25, 0x1C	; 28
   10694:	94 83       	std	Z+4, r25	; 0x04
   10696:	83 83       	std	Z+3, r24	; 0x03
   10698:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			  AddSpaceLag(strRef1,20);
   1069c:	0f 90       	pop	r0
   1069e:	0f 90       	pop	r0
   106a0:	0f 90       	pop	r0
   106a2:	0f 90       	pop	r0
   106a4:	c8 01       	movw	r24, r16
   106a6:	64 e1       	ldi	r22, 0x14	; 20
   106a8:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
   106ac:	84 e0       	ldi	r24, 0x04	; 4
   106ae:	16 c0       	rjmp	.+44     	; 0x106dc <FMenuEDCTransaction+0x15a>
	      break;
     case etSendingMessage90:
          sendMessage90();
   106b0:	0e 94 bd 82 	call	0x1057a	; 0x1057a <sendMessage90>
		  TimSend=0;
   106b4:	10 92 78 0c 	sts	0x0C78, r1
          stEtransaction=etWaitReply;
   106b8:	85 e0       	ldi	r24, 0x05	; 5
   106ba:	10 c0       	rjmp	.+32     	; 0x106dc <FMenuEDCTransaction+0x15a>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
   106bc:	80 91 78 0c 	lds	r24, 0x0C78
   106c0:	85 31       	cpi	r24, 0x15	; 21
   106c2:	18 f0       	brcs	.+6      	; 0x106ca <FMenuEDCTransaction+0x148>
   106c4:	88 e0       	ldi	r24, 0x08	; 8
   106c6:	80 93 62 02 	sts	0x0262, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
   106ca:	80 91 a7 01 	lds	r24, 0x01A7
   106ce:	81 30       	cpi	r24, 0x01	; 1
   106d0:	21 f0       	breq	.+8      	; 0x106da <FMenuEDCTransaction+0x158>
   106d2:	80 91 a3 01 	lds	r24, 0x01A3
   106d6:	81 30       	cpi	r24, 0x01	; 1
   106d8:	c9 f5       	brne	.+114    	; 0x1074c <FMenuEDCTransaction+0x1ca>
		       stEtransaction=etSuccesEDC;
   106da:	86 e0       	ldi	r24, 0x06	; 6
   106dc:	80 93 62 02 	sts	0x0262, r24
   106e0:	35 c0       	rjmp	.+106    	; 0x1074c <FMenuEDCTransaction+0x1ca>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
   106e2:	87 e0       	ldi	r24, 0x07	; 7
   106e4:	fb cf       	rjmp	.-10     	; 0x106dc <FMenuEDCTransaction+0x15a>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
   106e6:	80 91 a3 01 	lds	r24, 0x01A3
   106ea:	81 30       	cpi	r24, 0x01	; 1
   106ec:	19 f5       	brne	.+70     	; 0x10734 <FMenuEDCTransaction+0x1b2>
		      IsMessage09=False;
   106ee:	10 92 a3 01 	sts	0x01A3, r1
	          procMessage09();
   106f2:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <procMessage09>
		      lcd_clear();
   106f6:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
   106fa:	81 e0       	ldi	r24, 0x01	; 1
   106fc:	61 e0       	ldi	r22, 0x01	; 1
   106fe:	42 e9       	ldi	r20, 0x92	; 146
   10700:	58 e0       	ldi	r21, 0x08	; 8
   10702:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
   10706:	82 e0       	ldi	r24, 0x02	; 2
   10708:	61 e0       	ldi	r22, 0x01	; 1
   1070a:	43 ea       	ldi	r20, 0xA3	; 163
   1070c:	57 e0       	ldi	r21, 0x07	; 7
   1070e:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
   10712:	83 e0       	ldi	r24, 0x03	; 3
   10714:	61 e0       	ldi	r22, 0x01	; 1
   10716:	4c e1       	ldi	r20, 0x1C	; 28
   10718:	58 e0       	ldi	r21, 0x08	; 8
   1071a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
   1071e:	84 e0       	ldi	r24, 0x04	; 4
   10720:	61 e0       	ldi	r22, 0x01	; 1
   10722:	46 ed       	ldi	r20, 0xD6	; 214
   10724:	5b e0       	ldi	r21, 0x0B	; 11
   10726:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
   1072a:	02 c0       	rjmp	.+4      	; 0x10730 <FMenuEDCTransaction+0x1ae>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
   1072c:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  TimDisplay=0;
   10730:	10 92 92 01 	sts	0x0192, r1
		  stEtransaction=etDelayExit;
   10734:	89 e0       	ldi	r24, 0x09	; 9
   10736:	d2 cf       	rjmp	.-92     	; 0x106dc <FMenuEDCTransaction+0x15a>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
   10738:	80 91 92 01 	lds	r24, 0x0192
   1073c:	89 30       	cpi	r24, 0x09	; 9
   1073e:	30 f0       	brcs	.+12     	; 0x1074c <FMenuEDCTransaction+0x1ca>
   10740:	8a e0       	ldi	r24, 0x0A	; 10
   10742:	cc cf       	rjmp	.-104    	; 0x106dc <FMenuEDCTransaction+0x15a>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
   10744:	10 92 62 02 	sts	0x0262, r1
   10748:	81 e0       	ldi	r24, 0x01	; 1
   1074a:	01 c0       	rjmp	.+2      	; 0x1074e <FMenuEDCTransaction+0x1cc>
   1074c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   1074e:	1f 91       	pop	r17
   10750:	0f 91       	pop	r16
   10752:	08 95       	ret

00010754 <sendMessage58>:
	CardType=0;
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_58);
   10754:	88 e5       	ldi	r24, 0x58	; 88
   10756:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   1075a:	08 95       	ret

0001075c <sendMessage56>:
    uart_print(1, 0,strSend);	

	uart_printf(1,0,PSTR("AF968CFFB"));
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_56);
   1075c:	86 e5       	ldi	r24, 0x56	; 86
   1075e:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   10762:	08 95       	ret

00010764 <FMenuLocalAccount>:
	 __key_lgtcnt = 0; 
	 PORTG=PORTG&0b11111101;
}


char FMenuLocalAccount(){
   10764:	6f 92       	push	r6
   10766:	7f 92       	push	r7
   10768:	8f 92       	push	r8
   1076a:	9f 92       	push	r9
   1076c:	af 92       	push	r10
   1076e:	bf 92       	push	r11
   10770:	cf 92       	push	r12
   10772:	df 92       	push	r13
   10774:	ef 92       	push	r14
   10776:	ff 92       	push	r15
   10778:	0f 93       	push	r16
   1077a:	1f 93       	push	r17
   1077c:	df 93       	push	r29
   1077e:	cf 93       	push	r28
   10780:	cd b7       	in	r28, 0x3d	; 61
   10782:	de b7       	in	r29, 0x3e	; 62
   10784:	e4 97       	sbiw	r28, 0x34	; 52
   10786:	0f b6       	in	r0, 0x3f	; 63
   10788:	f8 94       	cli
   1078a:	de bf       	out	0x3e, r29	; 62
   1078c:	0f be       	out	0x3f, r0	; 63
   1078e:	cd bf       	out	0x3d, r28	; 61
       char ProductName[11],strName[21];//,strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   10790:	80 91 5b 01 	lds	r24, 0x015B
   10794:	90 e0       	ldi	r25, 0x00	; 0
   10796:	fc 01       	movw	r30, r24
   10798:	31 97       	sbiw	r30, 0x01	; 1
   1079a:	ef 31       	cpi	r30, 0x1F	; 31
   1079c:	f1 05       	cpc	r31, r1
   1079e:	10 f0       	brcs	.+4      	; 0x107a4 <FMenuLocalAccount+0x40>
   107a0:	0c 94 65 8c 	jmp	0x118ca	; 0x118ca <FMenuLocalAccount+0x1166>
   107a4:	e0 57       	subi	r30, 0x70	; 112
   107a6:	ff 4f       	sbci	r31, 0xFF	; 255
   107a8:	ee 0f       	add	r30, r30
   107aa:	ff 1f       	adc	r31, r31
   107ac:	05 90       	lpm	r0, Z+
   107ae:	f4 91       	lpm	r31, Z+
   107b0:	e0 2d       	mov	r30, r0
   107b2:	09 94       	ijmp
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
   107b4:	81 e0       	ldi	r24, 0x01	; 1
   107b6:	80 93 ae 02 	sts	0x02AE, r24
	 __key_lgtcnt = 0; 
   107ba:	10 92 af 02 	sts	0x02AF, r1
	 PORTG=PORTG&0b11111101;
   107be:	80 91 65 00 	lds	r24, 0x0065
   107c2:	8d 7f       	andi	r24, 0xFD	; 253
   107c4:	80 93 65 00 	sts	0x0065, r24
   107c8:	20 e0       	ldi	r18, 0x00	; 0
   107ca:	30 e0       	ldi	r19, 0x00	; 0


void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   107cc:	f9 01       	movw	r30, r18
   107ce:	e7 57       	subi	r30, 0x77	; 119
   107d0:	f4 4f       	sbci	r31, 0xF4	; 244
   107d2:	d9 01       	movw	r26, r18
   107d4:	af 5a       	subi	r26, 0xAF	; 175
   107d6:	b3 4f       	sbci	r27, 0xF3	; 243
   107d8:	8c 91       	ld	r24, X
   107da:	80 83       	st	Z, r24
   107dc:	2f 5f       	subi	r18, 0xFF	; 255
   107de:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   107e0:	28 30       	cpi	r18, 0x08	; 8
   107e2:	31 05       	cpc	r19, r1
   107e4:	99 f7       	brne	.-26     	; 0x107cc <FMenuLocalAccount+0x68>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   107e6:	10 92 91 0b 	sts	0x0B91, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   107ea:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   107ee:	81 e0       	ldi	r24, 0x01	; 1
   107f0:	61 e0       	ldi	r22, 0x01	; 1
   107f2:	4d ec       	ldi	r20, 0xCD	; 205
   107f4:	52 e2       	ldi	r21, 0x22	; 34
   107f6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   107fa:	00 d0       	rcall	.+0      	; 0x107fc <FMenuLocalAccount+0x98>
   107fc:	00 d0       	rcall	.+0      	; 0x107fe <FMenuLocalAccount+0x9a>
   107fe:	00 d0       	rcall	.+0      	; 0x10800 <FMenuLocalAccount+0x9c>
   10800:	ed b7       	in	r30, 0x3d	; 61
   10802:	fe b7       	in	r31, 0x3e	; 62
   10804:	31 96       	adiw	r30, 0x01	; 1
   10806:	8e 01       	movw	r16, r28
   10808:	04 5f       	subi	r16, 0xF4	; 244
   1080a:	1f 4f       	sbci	r17, 0xFF	; 255
   1080c:	ad b7       	in	r26, 0x3d	; 61
   1080e:	be b7       	in	r27, 0x3e	; 62
   10810:	12 96       	adiw	r26, 0x02	; 2
   10812:	1c 93       	st	X, r17
   10814:	0e 93       	st	-X, r16
   10816:	11 97       	sbiw	r26, 0x01	; 1
   10818:	87 ec       	ldi	r24, 0xC7	; 199
   1081a:	92 e2       	ldi	r25, 0x22	; 34
   1081c:	93 83       	std	Z+3, r25	; 0x03
   1081e:	82 83       	std	Z+2, r24	; 0x02
   10820:	89 e8       	ldi	r24, 0x89	; 137
   10822:	9b e0       	ldi	r25, 0x0B	; 11
   10824:	95 83       	std	Z+5, r25	; 0x05
   10826:	84 83       	std	Z+4, r24	; 0x04
   10828:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   1082c:	ed b7       	in	r30, 0x3d	; 61
   1082e:	fe b7       	in	r31, 0x3e	; 62
   10830:	36 96       	adiw	r30, 0x06	; 6
   10832:	0f b6       	in	r0, 0x3f	; 63
   10834:	f8 94       	cli
   10836:	fe bf       	out	0x3e, r31	; 62
   10838:	0f be       	out	0x3f, r0	; 63
   1083a:	ed bf       	out	0x3d, r30	; 61
   1083c:	82 e0       	ldi	r24, 0x02	; 2
   1083e:	61 e0       	ldi	r22, 0x01	; 1
   10840:	a8 01       	movw	r20, r16
   10842:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   10846:	83 e0       	ldi	r24, 0x03	; 3
   10848:	61 e0       	ldi	r22, 0x01	; 1
   1084a:	40 ec       	ldi	r20, 0xC0	; 192
   1084c:	52 e2       	ldi	r21, 0x22	; 34
   1084e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				iPos=0;//iLoop=0;
   10852:	10 92 96 02 	sts	0x0296, r1
				IsFullAuthorized=False;
   10856:	10 92 86 02 	sts	0x0286, r1
		        stLocalAccount=laSendID;
   1085a:	82 e0       	ldi	r24, 0x02	; 2
   1085c:	7e c5       	rjmp	.+2812   	; 0x1135a <FMenuLocalAccount+0xbf6>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   1085e:	10 92 a5 01 	sts	0x01A5, r1
                sendMessage56();
   10862:	0e 94 ae 83 	call	0x1075c	; 0x1075c <sendMessage56>
				iWait=0;iPos=0;
   10866:	10 92 95 02 	sts	0x0295, r1
   1086a:	10 92 96 02 	sts	0x0296, r1
				//iLoop=0;
				TimSend=0;
   1086e:	10 92 78 0c 	sts	0x0C78, r1
				stLocalAccount=laWaitMessage57;
   10872:	83 e0       	ldi	r24, 0x03	; 3
   10874:	72 c5       	rjmp	.+2788   	; 0x1135a <FMenuLocalAccount+0xbf6>
						 system_beep(2);
						 stLocalAccount=laConTimout;
				}
				*/
				
		        iLoop++;
   10876:	80 91 84 02 	lds	r24, 0x0284
   1087a:	90 91 85 02 	lds	r25, 0x0285
   1087e:	01 96       	adiw	r24, 0x01	; 1
   10880:	90 93 85 02 	sts	0x0285, r25
   10884:	80 93 84 02 	sts	0x0284, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   10888:	68 e9       	ldi	r22, 0x98	; 152
   1088a:	7a e3       	ldi	r23, 0x3A	; 58
   1088c:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
   10890:	89 2b       	or	r24, r25
   10892:	e1 f4       	brne	.+56     	; 0x108cc <FMenuLocalAccount+0x168>
				   if (iPos<5){
   10894:	60 91 96 02 	lds	r22, 0x0296
   10898:	65 30       	cpi	r22, 0x05	; 5
   1089a:	58 f4       	brcc	.+22     	; 0x108b2 <FMenuLocalAccount+0x14e>
					   lcd_put(3,(8+iPos),'.');
   1089c:	68 5f       	subi	r22, 0xF8	; 248
   1089e:	83 e0       	ldi	r24, 0x03	; 3
   108a0:	4e e2       	ldi	r20, 0x2E	; 46
   108a2:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
				       iPos++;
   108a6:	80 91 96 02 	lds	r24, 0x0296
   108aa:	8f 5f       	subi	r24, 0xFF	; 255
   108ac:	80 93 96 02 	sts	0x0296, r24
   108b0:	0d c0       	rjmp	.+26     	; 0x108cc <FMenuLocalAccount+0x168>
					   }
				   else{
				       iPos=0;
   108b2:	10 92 96 02 	sts	0x0296, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   108b6:	83 e0       	ldi	r24, 0x03	; 3
   108b8:	69 e0       	ldi	r22, 0x09	; 9
   108ba:	48 eb       	ldi	r20, 0xB8	; 184
   108bc:	52 e2       	ldi	r21, 0x22	; 34
   108be:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					   iWait++;
   108c2:	80 91 95 02 	lds	r24, 0x0295
   108c6:	8f 5f       	subi	r24, 0xFF	; 255
   108c8:	80 93 95 02 	sts	0x0295, r24
					   }
				}
				if (iWait>3){
   108cc:	80 91 95 02 	lds	r24, 0x0295
   108d0:	84 30       	cpi	r24, 0x04	; 4
   108d2:	50 f0       	brcs	.+20     	; 0x108e8 <FMenuLocalAccount+0x184>
				    stLocalAccount=laConTimout;
   108d4:	84 e0       	ldi	r24, 0x04	; 4
   108d6:	80 93 5b 01 	sts	0x015B, r24
					TimLocAcc=0;
   108da:	10 92 ba 01 	sts	0x01BA, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   108de:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   108e0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   108e2:	82 e0       	ldi	r24, 0x02	; 2
   108e4:	80 93 bc 01 	sts	0x01BC, r24
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
                 
				if (IsMessage57==True){
   108e8:	80 91 a5 01 	lds	r24, 0x01A5
   108ec:	81 30       	cpi	r24, 0x01	; 1
   108ee:	09 f0       	breq	.+2      	; 0x108f2 <FMenuLocalAccount+0x18e>
   108f0:	ec c7       	rjmp	.+4056   	; 0x118ca <FMenuLocalAccount+0x1166>
				    IsMessage57=False;
   108f2:	10 92 a5 01 	sts	0x01A5, r1
				    stLocalAccount=laProcMessage57;
   108f6:	85 e0       	ldi	r24, 0x05	; 5
   108f8:	30 c5       	rjmp	.+2656   	; 0x1135a <FMenuLocalAccount+0xbf6>
					}
		        break;
           case laConTimout:
		        //IsErrorTCPIP=True;
				lcd_printf(3,1,PSTR("Sending Failed      "));
   108fa:	83 e0       	ldi	r24, 0x03	; 3
   108fc:	61 e0       	ldi	r22, 0x01	; 1
   108fe:	43 ea       	ldi	r20, 0xA3	; 163
   10900:	52 e2       	ldi	r21, 0x22	; 34
   10902:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   10906:	84 e0       	ldi	r24, 0x04	; 4
   10908:	61 e0       	ldi	r22, 0x01	; 1
   1090a:	4e e8       	ldi	r20, 0x8E	; 142
   1090c:	52 e2       	ldi	r21, 0x22	; 34
   1090e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   10912:	80 91 ba 01 	lds	r24, 0x01BA
   10916:	83 30       	cpi	r24, 0x03	; 3
   10918:	08 f4       	brcc	.+2      	; 0x1091c <FMenuLocalAccount+0x1b8>
   1091a:	d7 c7       	rjmp	.+4014   	; 0x118ca <FMenuLocalAccount+0x1166>
   1091c:	cd c7       	rjmp	.+3994   	; 0x118b8 <FMenuLocalAccount+0x1154>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   1091e:	83 e0       	ldi	r24, 0x03	; 3
   10920:	61 e0       	ldi	r22, 0x01	; 1
   10922:	49 e7       	ldi	r20, 0x79	; 121
   10924:	52 e2       	ldi	r21, 0x22	; 34
   10926:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   1092a:	0e 94 35 29 	call	0x526a	; 0x526a <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   1092e:	81 30       	cpi	r24, 0x01	; 1
   10930:	29 f0       	breq	.+10     	; 0x1093c <FMenuLocalAccount+0x1d8>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   10932:	82 30       	cpi	r24, 0x02	; 2
   10934:	19 f0       	breq	.+6      	; 0x1093c <FMenuLocalAccount+0x1d8>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   10936:	83 30       	cpi	r24, 0x03	; 3
   10938:	09 f0       	breq	.+2      	; 0x1093c <FMenuLocalAccount+0x1d8>
   1093a:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   1093c:	80 93 97 02 	sts	0x0297, r24
				TimLocAcc=0;
   10940:	10 92 ba 01 	sts	0x01BA, r1
				stLocalAccount=laDispStatus;
   10944:	86 e0       	ldi	r24, 0x06	; 6
   10946:	09 c5       	rjmp	.+2578   	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   10948:	80 91 97 02 	lds	r24, 0x0297
   1094c:	81 30       	cpi	r24, 0x01	; 1
   1094e:	29 f4       	brne	.+10     	; 0x1095a <FMenuLocalAccount+0x1f6>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   10950:	83 e0       	ldi	r24, 0x03	; 3
   10952:	61 e0       	ldi	r22, 0x01	; 1
   10954:	44 e6       	ldi	r20, 0x64	; 100
   10956:	52 e2       	ldi	r21, 0x22	; 34
   10958:	0d c0       	rjmp	.+26     	; 0x10974 <FMenuLocalAccount+0x210>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   1095a:	82 30       	cpi	r24, 0x02	; 2
   1095c:	31 f4       	brne	.+12     	; 0x1096a <FMenuLocalAccount+0x206>
				    stLocalAccount=laDispValid; 
   1095e:	87 e0       	ldi	r24, 0x07	; 7
   10960:	80 93 5b 01 	sts	0x015B, r24
					lcd_clear();
   10964:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
   10968:	0c c0       	rjmp	.+24     	; 0x10982 <FMenuLocalAccount+0x21e>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   1096a:	83 30       	cpi	r24, 0x03	; 3
   1096c:	51 f4       	brne	.+20     	; 0x10982 <FMenuLocalAccount+0x21e>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   1096e:	61 e0       	ldi	r22, 0x01	; 1
   10970:	4f e4       	ldi	r20, 0x4F	; 79
   10972:	52 e2       	ldi	r21, 0x22	; 34
   10974:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					TimLocAcc=0;
   10978:	10 92 ba 01 	sts	0x01BA, r1
				    stLocalAccount=laDelayExit;
   1097c:	8e e1       	ldi	r24, 0x1E	; 30
   1097e:	80 93 5b 01 	sts	0x015B, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   10982:	80 91 ba 01 	lds	r24, 0x01BA
   10986:	86 30       	cpi	r24, 0x06	; 6
   10988:	08 f4       	brcc	.+2      	; 0x1098c <FMenuLocalAccount+0x228>
   1098a:	9f c7       	rjmp	.+3902   	; 0x118ca <FMenuLocalAccount+0x1166>
   1098c:	95 c7       	rjmp	.+3882   	; 0x118b8 <FMenuLocalAccount+0x1154>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   1098e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   10992:	00 d0       	rcall	.+0      	; 0x10994 <FMenuLocalAccount+0x230>
   10994:	00 d0       	rcall	.+0      	; 0x10996 <FMenuLocalAccount+0x232>
   10996:	00 d0       	rcall	.+0      	; 0x10998 <FMenuLocalAccount+0x234>
   10998:	ed b7       	in	r30, 0x3d	; 61
   1099a:	fe b7       	in	r31, 0x3e	; 62
   1099c:	31 96       	adiw	r30, 0x01	; 1
   1099e:	8f e1       	ldi	r24, 0x1F	; 31
   109a0:	9c e0       	ldi	r25, 0x0C	; 12
   109a2:	ad b7       	in	r26, 0x3d	; 61
   109a4:	be b7       	in	r27, 0x3e	; 62
   109a6:	12 96       	adiw	r26, 0x02	; 2
   109a8:	9c 93       	st	X, r25
   109aa:	8e 93       	st	-X, r24
   109ac:	11 97       	sbiw	r26, 0x01	; 1
   109ae:	8c e4       	ldi	r24, 0x4C	; 76
   109b0:	92 e2       	ldi	r25, 0x22	; 34
   109b2:	93 83       	std	Z+3, r25	; 0x03
   109b4:	82 83       	std	Z+2, r24	; 0x02
   109b6:	08 ef       	ldi	r16, 0xF8	; 248
   109b8:	1b e0       	ldi	r17, 0x0B	; 11
   109ba:	15 83       	std	Z+5, r17	; 0x05
   109bc:	04 83       	std	Z+4, r16	; 0x04
   109be:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				FormatCurrency(strBalance);
   109c2:	ed b7       	in	r30, 0x3d	; 61
   109c4:	fe b7       	in	r31, 0x3e	; 62
   109c6:	36 96       	adiw	r30, 0x06	; 6
   109c8:	0f b6       	in	r0, 0x3f	; 63
   109ca:	f8 94       	cli
   109cc:	fe bf       	out	0x3e, r31	; 62
   109ce:	0f be       	out	0x3f, r0	; 63
   109d0:	ed bf       	out	0x3d, r30	; 61
   109d2:	c8 01       	movw	r24, r16
   109d4:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
   109d8:	20 e0       	ldi	r18, 0x00	; 0
   109da:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   109dc:	80 e2       	ldi	r24, 0x20	; 32
   109de:	e8 2e       	mov	r14, r24
   109e0:	f1 2c       	mov	r15, r1
   109e2:	ec 0e       	add	r14, r28
   109e4:	fd 1e       	adc	r15, r29
   109e6:	f7 01       	movw	r30, r14
   109e8:	e2 0f       	add	r30, r18
   109ea:	f3 1f       	adc	r31, r19
   109ec:	d9 01       	movw	r26, r18
   109ee:	ac 5d       	subi	r26, 0xDC	; 220
   109f0:	bc 4f       	sbci	r27, 0xFC	; 252
   109f2:	8c 91       	ld	r24, X
   109f4:	80 83       	st	Z, r24
   109f6:	2f 5f       	subi	r18, 0xFF	; 255
   109f8:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   109fa:	24 31       	cpi	r18, 0x14	; 20
   109fc:	31 05       	cpc	r19, r1
   109fe:	99 f7       	brne	.-26     	; 0x109e6 <FMenuLocalAccount+0x282>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   10a00:	1c aa       	std	Y+52, r1	; 0x34
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   10a02:	00 d0       	rcall	.+0      	; 0x10a04 <FMenuLocalAccount+0x2a0>
   10a04:	00 d0       	rcall	.+0      	; 0x10a06 <FMenuLocalAccount+0x2a2>
   10a06:	00 d0       	rcall	.+0      	; 0x10a08 <FMenuLocalAccount+0x2a4>
   10a08:	ed b7       	in	r30, 0x3d	; 61
   10a0a:	fe b7       	in	r31, 0x3e	; 62
   10a0c:	31 96       	adiw	r30, 0x01	; 1
   10a0e:	8e 01       	movw	r16, r28
   10a10:	04 5f       	subi	r16, 0xF4	; 244
   10a12:	1f 4f       	sbci	r17, 0xFF	; 255
   10a14:	ad b7       	in	r26, 0x3d	; 61
   10a16:	be b7       	in	r27, 0x3e	; 62
   10a18:	12 96       	adiw	r26, 0x02	; 2
   10a1a:	1c 93       	st	X, r17
   10a1c:	0e 93       	st	-X, r16
   10a1e:	11 97       	sbiw	r26, 0x01	; 1
   10a20:	89 e4       	ldi	r24, 0x49	; 73
   10a22:	92 e2       	ldi	r25, 0x22	; 34
   10a24:	93 83       	std	Z+3, r25	; 0x03
   10a26:	82 83       	std	Z+2, r24	; 0x02
   10a28:	89 e7       	ldi	r24, 0x79	; 121
   10a2a:	97 e0       	ldi	r25, 0x07	; 7
   10a2c:	95 83       	std	Z+5, r25	; 0x05
   10a2e:	84 83       	std	Z+4, r24	; 0x04
   10a30:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   10a34:	ed b7       	in	r30, 0x3d	; 61
   10a36:	fe b7       	in	r31, 0x3e	; 62
   10a38:	36 96       	adiw	r30, 0x06	; 6
   10a3a:	0f b6       	in	r0, 0x3f	; 63
   10a3c:	f8 94       	cli
   10a3e:	fe bf       	out	0x3e, r31	; 62
   10a40:	0f be       	out	0x3f, r0	; 63
   10a42:	ed bf       	out	0x3d, r30	; 61
   10a44:	81 e0       	ldi	r24, 0x01	; 1
   10a46:	61 e0       	ldi	r22, 0x01	; 1
   10a48:	a8 01       	movw	r20, r16
   10a4a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   10a4e:	00 d0       	rcall	.+0      	; 0x10a50 <FMenuLocalAccount+0x2ec>
   10a50:	00 d0       	rcall	.+0      	; 0x10a52 <FMenuLocalAccount+0x2ee>
   10a52:	00 d0       	rcall	.+0      	; 0x10a54 <FMenuLocalAccount+0x2f0>
   10a54:	ed b7       	in	r30, 0x3d	; 61
   10a56:	fe b7       	in	r31, 0x3e	; 62
   10a58:	31 96       	adiw	r30, 0x01	; 1
   10a5a:	ad b7       	in	r26, 0x3d	; 61
   10a5c:	be b7       	in	r27, 0x3e	; 62
   10a5e:	12 96       	adiw	r26, 0x02	; 2
   10a60:	1c 93       	st	X, r17
   10a62:	0e 93       	st	-X, r16
   10a64:	11 97       	sbiw	r26, 0x01	; 1
   10a66:	86 e4       	ldi	r24, 0x46	; 70
   10a68:	92 e2       	ldi	r25, 0x22	; 34
   10a6a:	93 83       	std	Z+3, r25	; 0x03
   10a6c:	82 83       	std	Z+2, r24	; 0x02
   10a6e:	f5 82       	std	Z+5, r15	; 0x05
   10a70:	e4 82       	std	Z+4, r14	; 0x04
   10a72:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   10a76:	ed b7       	in	r30, 0x3d	; 61
   10a78:	fe b7       	in	r31, 0x3e	; 62
   10a7a:	36 96       	adiw	r30, 0x06	; 6
   10a7c:	0f b6       	in	r0, 0x3f	; 63
   10a7e:	f8 94       	cli
   10a80:	fe bf       	out	0x3e, r31	; 62
   10a82:	0f be       	out	0x3f, r0	; 63
   10a84:	ed bf       	out	0x3d, r30	; 61
   10a86:	82 e0       	ldi	r24, 0x02	; 2
   10a88:	61 e0       	ldi	r22, 0x01	; 1
   10a8a:	a8 01       	movw	r20, r16
   10a8c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   10a90:	2d b7       	in	r18, 0x3d	; 61
   10a92:	3e b7       	in	r19, 0x3e	; 62
   10a94:	28 50       	subi	r18, 0x08	; 8
   10a96:	30 40       	sbci	r19, 0x00	; 0
   10a98:	0f b6       	in	r0, 0x3f	; 63
   10a9a:	f8 94       	cli
   10a9c:	3e bf       	out	0x3e, r19	; 62
   10a9e:	0f be       	out	0x3f, r0	; 63
   10aa0:	2d bf       	out	0x3d, r18	; 61
   10aa2:	ed b7       	in	r30, 0x3d	; 61
   10aa4:	fe b7       	in	r31, 0x3e	; 62
   10aa6:	31 96       	adiw	r30, 0x01	; 1
   10aa8:	ad b7       	in	r26, 0x3d	; 61
   10aaa:	be b7       	in	r27, 0x3e	; 62
   10aac:	12 96       	adiw	r26, 0x02	; 2
   10aae:	1c 93       	st	X, r17
   10ab0:	0e 93       	st	-X, r16
   10ab2:	11 97       	sbiw	r26, 0x01	; 1
   10ab4:	80 e4       	ldi	r24, 0x40	; 64
   10ab6:	92 e2       	ldi	r25, 0x22	; 34
   10ab8:	93 83       	std	Z+3, r25	; 0x03
   10aba:	82 83       	std	Z+2, r24	; 0x02
   10abc:	8a ef       	ldi	r24, 0xFA	; 250
   10abe:	98 e0       	ldi	r25, 0x08	; 8
   10ac0:	95 83       	std	Z+5, r25	; 0x05
   10ac2:	84 83       	std	Z+4, r24	; 0x04
   10ac4:	88 ef       	ldi	r24, 0xF8	; 248
   10ac6:	9b e0       	ldi	r25, 0x0B	; 11
   10ac8:	97 83       	std	Z+7, r25	; 0x07
   10aca:	86 83       	std	Z+6, r24	; 0x06
   10acc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   10ad0:	ed b7       	in	r30, 0x3d	; 61
   10ad2:	fe b7       	in	r31, 0x3e	; 62
   10ad4:	38 96       	adiw	r30, 0x08	; 8
   10ad6:	0f b6       	in	r0, 0x3f	; 63
   10ad8:	f8 94       	cli
   10ada:	fe bf       	out	0x3e, r31	; 62
   10adc:	0f be       	out	0x3f, r0	; 63
   10ade:	ed bf       	out	0x3d, r30	; 61
   10ae0:	83 e0       	ldi	r24, 0x03	; 3
   10ae2:	61 e0       	ldi	r22, 0x01	; 1
   10ae4:	a8 01       	movw	r20, r16
   10ae6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   10aea:	84 e0       	ldi	r24, 0x04	; 4
   10aec:	61 e0       	ldi	r22, 0x01	; 1
   10aee:	4b e2       	ldi	r20, 0x2B	; 43
   10af0:	52 e2       	ldi	r21, 0x22	; 34
   10af2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				stLocalAccount=laDispValidInput;
   10af6:	88 e0       	ldi	r24, 0x08	; 8
   10af8:	30 c4       	rjmp	.+2144   	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   10afa:	81 e0       	ldi	r24, 0x01	; 1
   10afc:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   10b00:	87 3b       	cpi	r24, 0xB7	; 183
   10b02:	09 f4       	brne	.+2      	; 0x10b06 <FMenuLocalAccount+0x3a2>
   10b04:	bd c1       	rjmp	.+890    	; 0x10e80 <FMenuLocalAccount+0x71c>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   10b06:	87 3e       	cpi	r24, 0xE7	; 231
   10b08:	09 f0       	breq	.+2      	; 0x10b0c <FMenuLocalAccount+0x3a8>
   10b0a:	df c6       	rjmp	.+3518   	; 0x118ca <FMenuLocalAccount+0x1166>
   10b0c:	d5 c6       	rjmp	.+3498   	; 0x118b8 <FMenuLocalAccount+0x1154>
		        break;
           case laSelectFIP:      
			    FIPResult=menu_FIP(&FIP_Used,strFIP);
   10b0e:	01 e9       	ldi	r16, 0x91	; 145
   10b10:	12 e0       	ldi	r17, 0x02	; 2
   10b12:	88 e8       	ldi	r24, 0x88	; 136
   10b14:	92 e0       	ldi	r25, 0x02	; 2
   10b16:	b8 01       	movw	r22, r16
   10b18:	0e 94 25 58 	call	0xb04a	; 0xb04a <menu_FIP>

			    if ((FIPResult==FIP_DONE)&&(FIP_Used>0)){
   10b1c:	88 23       	and	r24, r24
   10b1e:	09 f0       	breq	.+2      	; 0x10b22 <FMenuLocalAccount+0x3be>
   10b20:	50 c0       	rjmp	.+160    	; 0x10bc2 <FMenuLocalAccount+0x45e>
   10b22:	20 91 88 02 	lds	r18, 0x0288
   10b26:	22 23       	and	r18, r18
   10b28:	09 f4       	brne	.+2      	; 0x10b2c <FMenuLocalAccount+0x3c8>
   10b2a:	cf c6       	rjmp	.+3486   	; 0x118ca <FMenuLocalAccount+0x1166>
                    sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   10b2c:	00 d0       	rcall	.+0      	; 0x10b2e <FMenuLocalAccount+0x3ca>
   10b2e:	00 d0       	rcall	.+0      	; 0x10b30 <FMenuLocalAccount+0x3cc>
   10b30:	00 d0       	rcall	.+0      	; 0x10b32 <FMenuLocalAccount+0x3ce>
   10b32:	ed b7       	in	r30, 0x3d	; 61
   10b34:	fe b7       	in	r31, 0x3e	; 62
   10b36:	31 96       	adiw	r30, 0x01	; 1
   10b38:	ad b7       	in	r26, 0x3d	; 61
   10b3a:	be b7       	in	r27, 0x3e	; 62
   10b3c:	12 96       	adiw	r26, 0x02	; 2
   10b3e:	1c 93       	st	X, r17
   10b40:	0e 93       	st	-X, r16
   10b42:	11 97       	sbiw	r26, 0x01	; 1
   10b44:	86 e2       	ldi	r24, 0x26	; 38
   10b46:	92 e2       	ldi	r25, 0x22	; 34
   10b48:	93 83       	std	Z+3, r25	; 0x03
   10b4a:	82 83       	std	Z+2, r24	; 0x02
   10b4c:	24 83       	std	Z+4, r18	; 0x04
   10b4e:	15 82       	std	Z+5, r1	; 0x05
   10b50:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
					sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   10b54:	ed b7       	in	r30, 0x3d	; 61
   10b56:	fe b7       	in	r31, 0x3e	; 62
   10b58:	31 96       	adiw	r30, 0x01	; 1
   10b5a:	89 eb       	ldi	r24, 0xB9	; 185
   10b5c:	97 e0       	ldi	r25, 0x07	; 7
   10b5e:	ad b7       	in	r26, 0x3d	; 61
   10b60:	be b7       	in	r27, 0x3e	; 62
   10b62:	12 96       	adiw	r26, 0x02	; 2
   10b64:	9c 93       	st	X, r25
   10b66:	8e 93       	st	-X, r24
   10b68:	11 97       	sbiw	r26, 0x01	; 1
   10b6a:	81 e2       	ldi	r24, 0x21	; 33
   10b6c:	92 e2       	ldi	r25, 0x22	; 34
   10b6e:	93 83       	std	Z+3, r25	; 0x03
   10b70:	82 83       	std	Z+2, r24	; 0x02
   10b72:	80 91 88 02 	lds	r24, 0x0288
   10b76:	84 83       	std	Z+4, r24	; 0x04
   10b78:	15 82       	std	Z+5, r1	; 0x05
   10b7a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
                    //Load Product Info
					if (GetFIPAddr(FIP_Used)>0) 
   10b7e:	ed b7       	in	r30, 0x3d	; 61
   10b80:	fe b7       	in	r31, 0x3e	; 62
   10b82:	36 96       	adiw	r30, 0x06	; 6
   10b84:	0f b6       	in	r0, 0x3f	; 63
   10b86:	f8 94       	cli
   10b88:	fe bf       	out	0x3e, r31	; 62
   10b8a:	0f be       	out	0x3f, r0	; 63
   10b8c:	ed bf       	out	0x3d, r30	; 61
   10b8e:	80 91 88 02 	lds	r24, 0x0288
   10b92:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
   10b96:	88 23       	and	r24, r24
   10b98:	91 f0       	breq	.+36     	; 0x10bbe <FMenuLocalAccount+0x45a>
					    eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[GetFIPAddr(FIP_Used)-1], 6);
   10b9a:	80 91 88 02 	lds	r24, 0x0288
   10b9e:	0e 94 50 21 	call	0x42a0	; 0x42a0 <GetFIPAddr>
   10ba2:	96 e0       	ldi	r25, 0x06	; 6
   10ba4:	89 9f       	mul	r24, r25
   10ba6:	b0 01       	movw	r22, r0
   10ba8:	11 24       	eor	r1, r1
   10baa:	61 5b       	subi	r22, 0xB1	; 177
   10bac:	7f 4f       	sbci	r23, 0xFF	; 255
   10bae:	89 e8       	ldi	r24, 0x89	; 137
   10bb0:	92 e0       	ldi	r25, 0x02	; 2
   10bb2:	46 e0       	ldi	r20, 0x06	; 6
   10bb4:	50 e0       	ldi	r21, 0x00	; 0
   10bb6:	22 ed       	ldi	r18, 0xD2	; 210
   10bb8:	33 e1       	ldi	r19, 0x13	; 19
   10bba:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
				    stLocalAccount=laSelectProduct;
   10bbe:	8b e0       	ldi	r24, 0x0B	; 11
   10bc0:	cc c3       	rjmp	.+1944   	; 0x1135a <FMenuLocalAccount+0xbf6>
				}
			    else if (FIPResult==FIP_CANCEL){
   10bc2:	82 30       	cpi	r24, 0x02	; 2
   10bc4:	09 f0       	breq	.+2      	; 0x10bc8 <FMenuLocalAccount+0x464>
   10bc6:	81 c6       	rjmp	.+3330   	; 0x118ca <FMenuLocalAccount+0x1166>
				    stLocalAccount=laDispValid;
   10bc8:	87 e0       	ldi	r24, 0x07	; 7
   10bca:	c7 c3       	rjmp	.+1934   	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break; 
           case laSelectFIPInput:

		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   10bcc:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   10bd0:	00 d0       	rcall	.+0      	; 0x10bd2 <FMenuLocalAccount+0x46e>
   10bd2:	00 d0       	rcall	.+0      	; 0x10bd4 <FMenuLocalAccount+0x470>
   10bd4:	00 d0       	rcall	.+0      	; 0x10bd6 <FMenuLocalAccount+0x472>
   10bd6:	ed b7       	in	r30, 0x3d	; 61
   10bd8:	fe b7       	in	r31, 0x3e	; 62
   10bda:	31 96       	adiw	r30, 0x01	; 1
   10bdc:	8e 01       	movw	r16, r28
   10bde:	04 5f       	subi	r16, 0xF4	; 244
   10be0:	1f 4f       	sbci	r17, 0xFF	; 255
   10be2:	ad b7       	in	r26, 0x3d	; 61
   10be4:	be b7       	in	r27, 0x3e	; 62
   10be6:	12 96       	adiw	r26, 0x02	; 2
   10be8:	1c 93       	st	X, r17
   10bea:	0e 93       	st	-X, r16
   10bec:	11 97       	sbiw	r26, 0x01	; 1
   10bee:	88 e1       	ldi	r24, 0x18	; 24
   10bf0:	92 e2       	ldi	r25, 0x22	; 34
   10bf2:	93 83       	std	Z+3, r25	; 0x03
   10bf4:	82 83       	std	Z+2, r24	; 0x02
   10bf6:	81 e9       	ldi	r24, 0x91	; 145
   10bf8:	92 e0       	ldi	r25, 0x02	; 2
   10bfa:	95 83       	std	Z+5, r25	; 0x05
   10bfc:	84 83       	std	Z+4, r24	; 0x04
   10bfe:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   10c02:	ed b7       	in	r30, 0x3d	; 61
   10c04:	fe b7       	in	r31, 0x3e	; 62
   10c06:	36 96       	adiw	r30, 0x06	; 6
   10c08:	0f b6       	in	r0, 0x3f	; 63
   10c0a:	f8 94       	cli
   10c0c:	fe bf       	out	0x3e, r31	; 62
   10c0e:	0f be       	out	0x3f, r0	; 63
   10c10:	ed bf       	out	0x3d, r30	; 61
   10c12:	81 e0       	ldi	r24, 0x01	; 1
   10c14:	61 e0       	ldi	r22, 0x01	; 1
   10c16:	a8 01       	movw	r20, r16
   10c18:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   10c1c:	90 91 89 02 	lds	r25, 0x0289
   10c20:	89 2f       	mov	r24, r25
   10c22:	81 50       	subi	r24, 0x01	; 1
   10c24:	86 30       	cpi	r24, 0x06	; 6
   10c26:	08 f0       	brcs	.+2      	; 0x10c2a <FMenuLocalAccount+0x4c6>
   10c28:	4e c0       	rjmp	.+156    	; 0x10cc6 <FMenuLocalAccount+0x562>
   10c2a:	80 91 8a 02 	lds	r24, 0x028A
   10c2e:	88 23       	and	r24, r24
   10c30:	09 f0       	breq	.+2      	; 0x10c34 <FMenuLocalAccount+0x4d0>
   10c32:	49 c0       	rjmp	.+146    	; 0x10cc6 <FMenuLocalAccount+0x562>
   10c34:	80 91 8b 02 	lds	r24, 0x028B
   10c38:	88 23       	and	r24, r24
   10c3a:	09 f0       	breq	.+2      	; 0x10c3e <FMenuLocalAccount+0x4da>
   10c3c:	44 c0       	rjmp	.+136    	; 0x10cc6 <FMenuLocalAccount+0x562>
   10c3e:	80 91 8c 02 	lds	r24, 0x028C
   10c42:	88 23       	and	r24, r24
   10c44:	09 f0       	breq	.+2      	; 0x10c48 <FMenuLocalAccount+0x4e4>
   10c46:	3f c0       	rjmp	.+126    	; 0x10cc6 <FMenuLocalAccount+0x562>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   10c48:	90 93 87 02 	sts	0x0287, r25
   10c4c:	6d e0       	ldi	r22, 0x0D	; 13
   10c4e:	96 9f       	mul	r25, r22
   10c50:	b0 01       	movw	r22, r0
   10c52:	11 24       	eor	r1, r1
   10c54:	62 55       	subi	r22, 0x52	; 82
   10c56:	7f 4f       	sbci	r23, 0xFF	; 255
   10c58:	8e 01       	movw	r16, r28
   10c5a:	0f 5f       	subi	r16, 0xFF	; 255
   10c5c:	1f 4f       	sbci	r17, 0xFF	; 255
   10c5e:	c8 01       	movw	r24, r16
   10c60:	4a e0       	ldi	r20, 0x0A	; 10
   10c62:	50 e0       	ldi	r21, 0x00	; 0
   10c64:	22 ed       	ldi	r18, 0xD2	; 210
   10c66:	33 e1       	ldi	r19, 0x13	; 19
   10c68:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10c6c:	ce 01       	movw	r24, r28
   10c6e:	09 96       	adiw	r24, 0x09	; 9
	    Dest[i]=Source[IdxSource+i];
   10c70:	0f 5f       	subi	r16, 0xFF	; 255
   10c72:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10c74:	08 17       	cp	r16, r24
   10c76:	19 07       	cpc	r17, r25
   10c78:	d9 f7       	brne	.-10     	; 0x10c70 <FMenuLocalAccount+0x50c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10c7a:	19 86       	std	Y+9, r1	; 0x09
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   10c7c:	00 d0       	rcall	.+0      	; 0x10c7e <FMenuLocalAccount+0x51a>
   10c7e:	00 d0       	rcall	.+0      	; 0x10c80 <FMenuLocalAccount+0x51c>
   10c80:	00 d0       	rcall	.+0      	; 0x10c82 <FMenuLocalAccount+0x51e>
   10c82:	ed b7       	in	r30, 0x3d	; 61
   10c84:	fe b7       	in	r31, 0x3e	; 62
   10c86:	31 96       	adiw	r30, 0x01	; 1
   10c88:	8e e5       	ldi	r24, 0x5E	; 94
   10c8a:	97 e0       	ldi	r25, 0x07	; 7
   10c8c:	ad b7       	in	r26, 0x3d	; 61
   10c8e:	be b7       	in	r27, 0x3e	; 62
   10c90:	12 96       	adiw	r26, 0x02	; 2
   10c92:	9c 93       	st	X, r25
   10c94:	8e 93       	st	-X, r24
   10c96:	11 97       	sbiw	r26, 0x01	; 1
   10c98:	85 e1       	ldi	r24, 0x15	; 21
   10c9a:	92 e2       	ldi	r25, 0x22	; 34
   10c9c:	93 83       	std	Z+3, r25	; 0x03
   10c9e:	82 83       	std	Z+2, r24	; 0x02
   10ca0:	ce 01       	movw	r24, r28
   10ca2:	01 96       	adiw	r24, 0x01	; 1
   10ca4:	95 83       	std	Z+5, r25	; 0x05
   10ca6:	84 83       	std	Z+4, r24	; 0x04
   10ca8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   10cac:	8d e0       	ldi	r24, 0x0D	; 13
   10cae:	80 93 5b 01 	sts	0x015B, r24
   10cb2:	80 e0       	ldi	r24, 0x00	; 0
   10cb4:	ed b7       	in	r30, 0x3d	; 61
   10cb6:	fe b7       	in	r31, 0x3e	; 62
   10cb8:	36 96       	adiw	r30, 0x06	; 6
   10cba:	0f b6       	in	r0, 0x3f	; 63
   10cbc:	f8 94       	cli
   10cbe:	fe bf       	out	0x3e, r31	; 62
   10cc0:	0f be       	out	0x3f, r0	; 63
   10cc2:	ed bf       	out	0x3d, r30	; 61
   10cc4:	03 c6       	rjmp	.+3078   	; 0x118cc <FMenuLocalAccount+0x1168>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   10cc6:	10 92 8f 02 	sts	0x028F, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   10cca:	0c e0       	ldi	r16, 0x0C	; 12
   10ccc:	e0 2e       	mov	r14, r16
   10cce:	f1 2c       	mov	r15, r1
   10cd0:	ec 0e       	add	r14, r28
   10cd2:	fd 1e       	adc	r15, r29
   10cd4:	19 e0       	ldi	r17, 0x09	; 9
   10cd6:	81 2e       	mov	r8, r17
   10cd8:	12 e2       	ldi	r17, 0x22	; 34
   10cda:	91 2e       	mov	r9, r17
   10cdc:	bd e0       	ldi	r27, 0x0D	; 13
   10cde:	6b 2e       	mov	r6, r27
   10ce0:	8e 01       	movw	r16, r28
   10ce2:	0f 5f       	subi	r16, 0xFF	; 255
   10ce4:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10ce6:	a9 e0       	ldi	r26, 0x09	; 9
   10ce8:	aa 2e       	mov	r10, r26
   10cea:	b1 2c       	mov	r11, r1
   10cec:	ac 0e       	add	r10, r28
   10cee:	bd 1e       	adc	r11, r29
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   10cf0:	ff e0       	ldi	r31, 0x0F	; 15
   10cf2:	cf 2e       	mov	r12, r31
   10cf4:	f2 e2       	ldi	r31, 0x22	; 34
   10cf6:	df 2e       	mov	r13, r31
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   10cf8:	eb e0       	ldi	r30, 0x0B	; 11
   10cfa:	7e 2e       	mov	r7, r30
   10cfc:	67 c0       	rjmp	.+206    	; 0x10dcc <FMenuLocalAccount+0x668>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   10cfe:	f0 e0       	ldi	r31, 0x00	; 0
   10d00:	e7 57       	subi	r30, 0x77	; 119
   10d02:	fd 4f       	sbci	r31, 0xFD	; 253
   10d04:	e0 81       	ld	r30, Z
   10d06:	e0 93 87 02 	sts	0x0287, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   10d0a:	8e 2f       	mov	r24, r30
   10d0c:	81 50       	subi	r24, 0x01	; 1
   10d0e:	86 30       	cpi	r24, 0x06	; 6
   10d10:	c8 f5       	brcc	.+114    	; 0x10d84 <FMenuLocalAccount+0x620>
   10d12:	e6 9d       	mul	r30, r6
   10d14:	b0 01       	movw	r22, r0
   10d16:	11 24       	eor	r1, r1
   10d18:	62 55       	subi	r22, 0x52	; 82
   10d1a:	7f 4f       	sbci	r23, 0xFF	; 255
   10d1c:	c8 01       	movw	r24, r16
   10d1e:	4a e0       	ldi	r20, 0x0A	; 10
   10d20:	50 e0       	ldi	r21, 0x00	; 0
   10d22:	22 ed       	ldi	r18, 0xD2	; 210
   10d24:	33 e1       	ldi	r19, 0x13	; 19
   10d26:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
   10d2a:	c8 01       	movw	r24, r16
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   10d2c:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10d2e:	8a 15       	cp	r24, r10
   10d30:	9b 05       	cpc	r25, r11
   10d32:	e1 f7       	brne	.-8      	; 0x10d2c <FMenuLocalAccount+0x5c8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10d34:	19 86       	std	Y+9, r1	; 0x09
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   10d36:	2d b7       	in	r18, 0x3d	; 61
   10d38:	3e b7       	in	r19, 0x3e	; 62
   10d3a:	28 50       	subi	r18, 0x08	; 8
   10d3c:	30 40       	sbci	r19, 0x00	; 0
   10d3e:	0f b6       	in	r0, 0x3f	; 63
   10d40:	f8 94       	cli
   10d42:	3e bf       	out	0x3e, r19	; 62
   10d44:	0f be       	out	0x3f, r0	; 63
   10d46:	2d bf       	out	0x3d, r18	; 61
   10d48:	ed b7       	in	r30, 0x3d	; 61
   10d4a:	fe b7       	in	r31, 0x3e	; 62
   10d4c:	31 96       	adiw	r30, 0x01	; 1
   10d4e:	ad b7       	in	r26, 0x3d	; 61
   10d50:	be b7       	in	r27, 0x3e	; 62
   10d52:	12 96       	adiw	r26, 0x02	; 2
   10d54:	fc 92       	st	X, r15
   10d56:	ee 92       	st	-X, r14
   10d58:	11 97       	sbiw	r26, 0x01	; 1
   10d5a:	d3 82       	std	Z+3, r13	; 0x03
   10d5c:	c2 82       	std	Z+2, r12	; 0x02
   10d5e:	80 91 8f 02 	lds	r24, 0x028F
   10d62:	90 e0       	ldi	r25, 0x00	; 0
   10d64:	01 96       	adiw	r24, 0x01	; 1
   10d66:	95 83       	std	Z+5, r25	; 0x05
   10d68:	84 83       	std	Z+4, r24	; 0x04
   10d6a:	17 83       	std	Z+7, r17	; 0x07
   10d6c:	06 83       	std	Z+6, r16	; 0x06
   10d6e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   10d72:	ed b7       	in	r30, 0x3d	; 61
   10d74:	fe b7       	in	r31, 0x3e	; 62
   10d76:	38 96       	adiw	r30, 0x08	; 8
   10d78:	0f b6       	in	r0, 0x3f	; 63
   10d7a:	f8 94       	cli
   10d7c:	fe bf       	out	0x3e, r31	; 62
   10d7e:	0f be       	out	0x3f, r0	; 63
   10d80:	ed bf       	out	0x3d, r30	; 61
   10d82:	12 c0       	rjmp	.+36     	; 0x10da8 <FMenuLocalAccount+0x644>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   10d84:	00 d0       	rcall	.+0      	; 0x10d86 <FMenuLocalAccount+0x622>
   10d86:	00 d0       	rcall	.+0      	; 0x10d88 <FMenuLocalAccount+0x624>
   10d88:	ad b7       	in	r26, 0x3d	; 61
   10d8a:	be b7       	in	r27, 0x3e	; 62
   10d8c:	12 96       	adiw	r26, 0x02	; 2
   10d8e:	fc 92       	st	X, r15
   10d90:	ee 92       	st	-X, r14
   10d92:	11 97       	sbiw	r26, 0x01	; 1
   10d94:	14 96       	adiw	r26, 0x04	; 4
   10d96:	9c 92       	st	X, r9
   10d98:	8e 92       	st	-X, r8
   10d9a:	13 97       	sbiw	r26, 0x03	; 3
   10d9c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   10da0:	0f 90       	pop	r0
   10da2:	0f 90       	pop	r0
   10da4:	0f 90       	pop	r0
   10da6:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   10da8:	80 91 8f 02 	lds	r24, 0x028F
   10dac:	68 2f       	mov	r22, r24
   10dae:	66 95       	lsr	r22
   10db0:	67 9d       	mul	r22, r7
   10db2:	b0 01       	movw	r22, r0
   10db4:	11 24       	eor	r1, r1
   10db6:	6f 5f       	subi	r22, 0xFF	; 255
   10db8:	81 70       	andi	r24, 0x01	; 1
   10dba:	8e 5f       	subi	r24, 0xFE	; 254
   10dbc:	a7 01       	movw	r20, r14
   10dbe:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   10dc2:	80 91 8f 02 	lds	r24, 0x028F
   10dc6:	8f 5f       	subi	r24, 0xFF	; 255
   10dc8:	80 93 8f 02 	sts	0x028F, r24
   10dcc:	e0 91 8f 02 	lds	r30, 0x028F
   10dd0:	e4 30       	cpi	r30, 0x04	; 4
   10dd2:	08 f4       	brcc	.+2      	; 0x10dd6 <FMenuLocalAccount+0x672>
   10dd4:	94 cf       	rjmp	.-216    	; 0x10cfe <FMenuLocalAccount+0x59a>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   10dd6:	84 e0       	ldi	r24, 0x04	; 4
   10dd8:	61 e0       	ldi	r22, 0x01	; 1
   10dda:	44 ef       	ldi	r20, 0xF4	; 244
   10ddc:	51 e2       	ldi	r21, 0x21	; 33
   10dde:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				stLocalAccount=laSelectProductInput;
   10de2:	8c e0       	ldi	r24, 0x0C	; 12
   10de4:	ba c2       	rjmp	.+1396   	; 0x1135a <FMenuLocalAccount+0xbf6>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   10de6:	81 e0       	ldi	r24, 0x01	; 1
   10de8:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   10dec:	e8 2e       	mov	r14, r24
			    KeyChar=_key_btn(KeyPressed);
   10dee:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
				if ((KeyChar>='1')&&(KeyChar<='4')){
   10df2:	81 53       	subi	r24, 0x31	; 49
   10df4:	84 30       	cpi	r24, 0x04	; 4
   10df6:	08 f0       	brcs	.+2      	; 0x10dfa <FMenuLocalAccount+0x696>
   10df8:	3f c0       	rjmp	.+126    	; 0x10e78 <FMenuLocalAccount+0x714>
				    iNozzle=KeyChar-'1';
   10dfa:	80 93 8f 02 	sts	0x028F, r24
   10dfe:	e8 2f       	mov	r30, r24
   10e00:	f0 e0       	ldi	r31, 0x00	; 0
   10e02:	e7 57       	subi	r30, 0x77	; 119
   10e04:	fd 4f       	sbci	r31, 0xFD	; 253
   10e06:	60 81       	ld	r22, Z
   10e08:	7d e0       	ldi	r23, 0x0D	; 13
   10e0a:	f7 2e       	mov	r15, r23
   10e0c:	6f 9d       	mul	r22, r15
   10e0e:	b0 01       	movw	r22, r0
   10e10:	11 24       	eor	r1, r1
   10e12:	62 55       	subi	r22, 0x52	; 82
   10e14:	7f 4f       	sbci	r23, 0xFF	; 255
   10e16:	8e 01       	movw	r16, r28
   10e18:	0f 5f       	subi	r16, 0xFF	; 255
   10e1a:	1f 4f       	sbci	r17, 0xFF	; 255
   10e1c:	c8 01       	movw	r24, r16
   10e1e:	4a e0       	ldi	r20, 0x0A	; 10
   10e20:	50 e0       	ldi	r21, 0x00	; 0
   10e22:	22 ed       	ldi	r18, 0xD2	; 210
   10e24:	33 e1       	ldi	r19, 0x13	; 19
   10e26:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   10e2a:	00 d0       	rcall	.+0      	; 0x10e2c <FMenuLocalAccount+0x6c8>
   10e2c:	00 d0       	rcall	.+0      	; 0x10e2e <FMenuLocalAccount+0x6ca>
   10e2e:	00 d0       	rcall	.+0      	; 0x10e30 <FMenuLocalAccount+0x6cc>
   10e30:	ed b7       	in	r30, 0x3d	; 61
   10e32:	fe b7       	in	r31, 0x3e	; 62
   10e34:	31 96       	adiw	r30, 0x01	; 1
   10e36:	8e e5       	ldi	r24, 0x5E	; 94
   10e38:	97 e0       	ldi	r25, 0x07	; 7
   10e3a:	ad b7       	in	r26, 0x3d	; 61
   10e3c:	be b7       	in	r27, 0x3e	; 62
   10e3e:	12 96       	adiw	r26, 0x02	; 2
   10e40:	9c 93       	st	X, r25
   10e42:	8e 93       	st	-X, r24
   10e44:	11 97       	sbiw	r26, 0x01	; 1
   10e46:	81 ef       	ldi	r24, 0xF1	; 241
   10e48:	91 e2       	ldi	r25, 0x21	; 33
   10e4a:	93 83       	std	Z+3, r25	; 0x03
   10e4c:	82 83       	std	Z+2, r24	; 0x02
   10e4e:	15 83       	std	Z+5, r17	; 0x05
   10e50:	04 83       	std	Z+4, r16	; 0x04
   10e52:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
					NozzleID=iNozzle+1;
   10e56:	80 91 8f 02 	lds	r24, 0x028F
   10e5a:	8f 5f       	subi	r24, 0xFF	; 255
   10e5c:	80 93 6d 07 	sts	0x076D, r24
                    stLocalAccount=laSelectBalanceType;
   10e60:	f0 92 5b 01 	sts	0x015B, r15
					lcd_clear();
   10e64:	ed b7       	in	r30, 0x3d	; 61
   10e66:	fe b7       	in	r31, 0x3e	; 62
   10e68:	36 96       	adiw	r30, 0x06	; 6
   10e6a:	0f b6       	in	r0, 0x3f	; 63
   10e6c:	f8 94       	cli
   10e6e:	fe bf       	out	0x3e, r31	; 62
   10e70:	0f be       	out	0x3f, r0	; 63
   10e72:	ed bf       	out	0x3d, r30	; 61
   10e74:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   10e78:	f7 ee       	ldi	r31, 0xE7	; 231
   10e7a:	ef 16       	cp	r14, r31
   10e7c:	09 f0       	breq	.+2      	; 0x10e80 <FMenuLocalAccount+0x71c>
   10e7e:	25 c5       	rjmp	.+2634   	; 0x118ca <FMenuLocalAccount+0x1166>
   10e80:	89 e0       	ldi	r24, 0x09	; 9
   10e82:	6b c2       	rjmp	.+1238   	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   10e84:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   10e88:	2d b7       	in	r18, 0x3d	; 61
   10e8a:	3e b7       	in	r19, 0x3e	; 62
   10e8c:	28 50       	subi	r18, 0x08	; 8
   10e8e:	30 40       	sbci	r19, 0x00	; 0
   10e90:	0f b6       	in	r0, 0x3f	; 63
   10e92:	f8 94       	cli
   10e94:	3e bf       	out	0x3e, r19	; 62
   10e96:	0f be       	out	0x3f, r0	; 63
   10e98:	2d bf       	out	0x3d, r18	; 61
   10e9a:	ed b7       	in	r30, 0x3d	; 61
   10e9c:	fe b7       	in	r31, 0x3e	; 62
   10e9e:	31 96       	adiw	r30, 0x01	; 1
   10ea0:	8e 01       	movw	r16, r28
   10ea2:	04 5f       	subi	r16, 0xF4	; 244
   10ea4:	1f 4f       	sbci	r17, 0xFF	; 255
   10ea6:	ad b7       	in	r26, 0x3d	; 61
   10ea8:	be b7       	in	r27, 0x3e	; 62
   10eaa:	12 96       	adiw	r26, 0x02	; 2
   10eac:	1c 93       	st	X, r17
   10eae:	0e 93       	st	-X, r16
   10eb0:	11 97       	sbiw	r26, 0x01	; 1
   10eb2:	89 ee       	ldi	r24, 0xE9	; 233
   10eb4:	91 e2       	ldi	r25, 0x21	; 33
   10eb6:	93 83       	std	Z+3, r25	; 0x03
   10eb8:	82 83       	std	Z+2, r24	; 0x02
   10eba:	81 e9       	ldi	r24, 0x91	; 145
   10ebc:	92 e0       	ldi	r25, 0x02	; 2
   10ebe:	95 83       	std	Z+5, r25	; 0x05
   10ec0:	84 83       	std	Z+4, r24	; 0x04
   10ec2:	8e e5       	ldi	r24, 0x5E	; 94
   10ec4:	97 e0       	ldi	r25, 0x07	; 7
   10ec6:	97 83       	std	Z+7, r25	; 0x07
   10ec8:	86 83       	std	Z+6, r24	; 0x06
   10eca:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   10ece:	ed b7       	in	r30, 0x3d	; 61
   10ed0:	fe b7       	in	r31, 0x3e	; 62
   10ed2:	38 96       	adiw	r30, 0x08	; 8
   10ed4:	0f b6       	in	r0, 0x3f	; 63
   10ed6:	f8 94       	cli
   10ed8:	fe bf       	out	0x3e, r31	; 62
   10eda:	0f be       	out	0x3f, r0	; 63
   10edc:	ed bf       	out	0x3d, r30	; 61
   10ede:	81 e0       	ldi	r24, 0x01	; 1
   10ee0:	61 e0       	ldi	r22, 0x01	; 1
   10ee2:	a8 01       	movw	r20, r16
   10ee4:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   10ee8:	82 e0       	ldi	r24, 0x02	; 2
   10eea:	61 e0       	ldi	r22, 0x01	; 1
   10eec:	44 ed       	ldi	r20, 0xD4	; 212
   10eee:	51 e2       	ldi	r21, 0x21	; 33
   10ef0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   10ef4:	83 e0       	ldi	r24, 0x03	; 3
   10ef6:	61 e0       	ldi	r22, 0x01	; 1
   10ef8:	4f eb       	ldi	r20, 0xBF	; 191
   10efa:	51 e2       	ldi	r21, 0x21	; 33
   10efc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   10f00:	84 e0       	ldi	r24, 0x04	; 4
   10f02:	61 e0       	ldi	r22, 0x01	; 1
   10f04:	4a ea       	ldi	r20, 0xAA	; 170
   10f06:	51 e2       	ldi	r21, 0x21	; 33
   10f08:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   10f0c:	8e e0       	ldi	r24, 0x0E	; 14
   10f0e:	25 c2       	rjmp	.+1098   	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   10f10:	81 e0       	ldi	r24, 0x01	; 1
   10f12:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   10f16:	18 2f       	mov	r17, r24
			    KeyChar=_key_btn(KeyPressed);
   10f18:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
   10f1c:	98 2f       	mov	r25, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   10f1e:	81 53       	subi	r24, 0x31	; 49
   10f20:	82 30       	cpi	r24, 0x02	; 2
   10f22:	80 f5       	brcc	.+96     	; 0x10f84 <FMenuLocalAccount+0x820>
                    if(KeyChar=='1'){
   10f24:	91 33       	cpi	r25, 0x31	; 49
   10f26:	a1 f4       	brne	.+40     	; 0x10f50 <FMenuLocalAccount+0x7ec>
					   BalanceType=1;
   10f28:	81 e0       	ldi	r24, 0x01	; 1
   10f2a:	80 93 94 02 	sts	0x0294, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   10f2e:	00 d0       	rcall	.+0      	; 0x10f30 <FMenuLocalAccount+0x7cc>
   10f30:	00 d0       	rcall	.+0      	; 0x10f32 <FMenuLocalAccount+0x7ce>
   10f32:	83 ea       	ldi	r24, 0xA3	; 163
   10f34:	93 e0       	ldi	r25, 0x03	; 3
   10f36:	ad b7       	in	r26, 0x3d	; 61
   10f38:	be b7       	in	r27, 0x3e	; 62
   10f3a:	12 96       	adiw	r26, 0x02	; 2
   10f3c:	9c 93       	st	X, r25
   10f3e:	8e 93       	st	-X, r24
   10f40:	11 97       	sbiw	r26, 0x01	; 1
   10f42:	88 ea       	ldi	r24, 0xA8	; 168
   10f44:	91 e2       	ldi	r25, 0x21	; 33
   10f46:	14 96       	adiw	r26, 0x04	; 4
   10f48:	9c 93       	st	X, r25
   10f4a:	8e 93       	st	-X, r24
   10f4c:	13 97       	sbiw	r26, 0x03	; 3
   10f4e:	11 c0       	rjmp	.+34     	; 0x10f72 <FMenuLocalAccount+0x80e>
					   }
					else
                    if(KeyChar=='2'){
   10f50:	92 33       	cpi	r25, 0x32	; 50
   10f52:	a9 f4       	brne	.+42     	; 0x10f7e <FMenuLocalAccount+0x81a>
					   BalanceType=2;
   10f54:	82 e0       	ldi	r24, 0x02	; 2
   10f56:	80 93 94 02 	sts	0x0294, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   10f5a:	00 d0       	rcall	.+0      	; 0x10f5c <FMenuLocalAccount+0x7f8>
   10f5c:	00 d0       	rcall	.+0      	; 0x10f5e <FMenuLocalAccount+0x7fa>
   10f5e:	83 ea       	ldi	r24, 0xA3	; 163
   10f60:	93 e0       	ldi	r25, 0x03	; 3
   10f62:	ed b7       	in	r30, 0x3d	; 61
   10f64:	fe b7       	in	r31, 0x3e	; 62
   10f66:	92 83       	std	Z+2, r25	; 0x02
   10f68:	81 83       	std	Z+1, r24	; 0x01
   10f6a:	86 ea       	ldi	r24, 0xA6	; 166
   10f6c:	91 e2       	ldi	r25, 0x21	; 33
   10f6e:	94 83       	std	Z+4, r25	; 0x04
   10f70:	83 83       	std	Z+3, r24	; 0x03
   10f72:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   10f76:	0f 90       	pop	r0
   10f78:	0f 90       	pop	r0
   10f7a:	0f 90       	pop	r0
   10f7c:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   10f7e:	8f e0       	ldi	r24, 0x0F	; 15
   10f80:	80 93 5b 01 	sts	0x015B, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   10f84:	17 3e       	cpi	r17, 0xE7	; 231
   10f86:	c9 f4       	brne	.+50     	; 0x10fba <FMenuLocalAccount+0x856>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   10f88:	80 91 89 02 	lds	r24, 0x0289
   10f8c:	81 50       	subi	r24, 0x01	; 1
   10f8e:	86 30       	cpi	r24, 0x06	; 6
   10f90:	70 f4       	brcc	.+28     	; 0x10fae <FMenuLocalAccount+0x84a>
   10f92:	80 91 8a 02 	lds	r24, 0x028A
   10f96:	88 23       	and	r24, r24
   10f98:	51 f4       	brne	.+20     	; 0x10fae <FMenuLocalAccount+0x84a>
   10f9a:	80 91 8b 02 	lds	r24, 0x028B
   10f9e:	88 23       	and	r24, r24
   10fa0:	31 f4       	brne	.+12     	; 0x10fae <FMenuLocalAccount+0x84a>
   10fa2:	80 91 8c 02 	lds	r24, 0x028C
   10fa6:	88 23       	and	r24, r24
   10fa8:	11 f4       	brne	.+4      	; 0x10fae <FMenuLocalAccount+0x84a>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   10faa:	89 e0       	ldi	r24, 0x09	; 9
   10fac:	01 c0       	rjmp	.+2      	; 0x10fb0 <FMenuLocalAccount+0x84c>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   10fae:	8b e0       	ldi	r24, 0x0B	; 11
   10fb0:	80 93 5b 01 	sts	0x015B, r24
					lcd_clear();
   10fb4:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
   10fb8:	88 c4       	rjmp	.+2320   	; 0x118ca <FMenuLocalAccount+0x1166>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   10fba:	17 3b       	cpi	r17, 0xB7	; 183
   10fbc:	09 f0       	breq	.+2      	; 0x10fc0 <FMenuLocalAccount+0x85c>
   10fbe:	85 c4       	rjmp	.+2314   	; 0x118ca <FMenuLocalAccount+0x1166>
				    BalanceType=1;
   10fc0:	11 e0       	ldi	r17, 0x01	; 1
   10fc2:	10 93 94 02 	sts	0x0294, r17
					sprintf_P(strBalanceType,PSTR("A"));
   10fc6:	00 d0       	rcall	.+0      	; 0x10fc8 <FMenuLocalAccount+0x864>
   10fc8:	00 d0       	rcall	.+0      	; 0x10fca <FMenuLocalAccount+0x866>
   10fca:	83 ea       	ldi	r24, 0xA3	; 163
   10fcc:	93 e0       	ldi	r25, 0x03	; 3
   10fce:	ad b7       	in	r26, 0x3d	; 61
   10fd0:	be b7       	in	r27, 0x3e	; 62
   10fd2:	12 96       	adiw	r26, 0x02	; 2
   10fd4:	9c 93       	st	X, r25
   10fd6:	8e 93       	st	-X, r24
   10fd8:	11 97       	sbiw	r26, 0x01	; 1
   10fda:	84 ea       	ldi	r24, 0xA4	; 164
   10fdc:	91 e2       	ldi	r25, 0x21	; 33
   10fde:	14 96       	adiw	r26, 0x04	; 4
   10fe0:	9c 93       	st	X, r25
   10fe2:	8e 93       	st	-X, r24
   10fe4:	13 97       	sbiw	r26, 0x03	; 3
   10fe6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   10fea:	10 93 86 02 	sts	0x0286, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   10fee:	81 e1       	ldi	r24, 0x11	; 17
   10ff0:	80 93 5b 01 	sts	0x015B, r24
   10ff4:	80 e0       	ldi	r24, 0x00	; 0
   10ff6:	0f 90       	pop	r0
   10ff8:	0f 90       	pop	r0
   10ffa:	0f 90       	pop	r0
   10ffc:	0f 90       	pop	r0
   10ffe:	66 c4       	rjmp	.+2252   	; 0x118cc <FMenuLocalAccount+0x1168>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   11000:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		        if(BalanceType==1){
   11004:	80 91 94 02 	lds	r24, 0x0294
   11008:	81 30       	cpi	r24, 0x01	; 1
   1100a:	f1 f5       	brne	.+124    	; 0x11088 <FMenuLocalAccount+0x924>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1100c:	ed b7       	in	r30, 0x3d	; 61
   1100e:	fe b7       	in	r31, 0x3e	; 62
   11010:	38 97       	sbiw	r30, 0x08	; 8
   11012:	0f b6       	in	r0, 0x3f	; 63
   11014:	f8 94       	cli
   11016:	fe bf       	out	0x3e, r31	; 62
   11018:	0f be       	out	0x3f, r0	; 63
   1101a:	ed bf       	out	0x3d, r30	; 61
   1101c:	31 96       	adiw	r30, 0x01	; 1
   1101e:	8e 01       	movw	r16, r28
   11020:	04 5f       	subi	r16, 0xF4	; 244
   11022:	1f 4f       	sbci	r17, 0xFF	; 255
   11024:	ad b7       	in	r26, 0x3d	; 61
   11026:	be b7       	in	r27, 0x3e	; 62
   11028:	12 96       	adiw	r26, 0x02	; 2
   1102a:	1c 93       	st	X, r17
   1102c:	0e 93       	st	-X, r16
   1102e:	11 97       	sbiw	r26, 0x01	; 1
   11030:	8c e9       	ldi	r24, 0x9C	; 156
   11032:	91 e2       	ldi	r25, 0x21	; 33
   11034:	93 83       	std	Z+3, r25	; 0x03
   11036:	82 83       	std	Z+2, r24	; 0x02
   11038:	81 e9       	ldi	r24, 0x91	; 145
   1103a:	92 e0       	ldi	r25, 0x02	; 2
   1103c:	95 83       	std	Z+5, r25	; 0x05
   1103e:	84 83       	std	Z+4, r24	; 0x04
   11040:	8e e5       	ldi	r24, 0x5E	; 94
   11042:	97 e0       	ldi	r25, 0x07	; 7
   11044:	97 83       	std	Z+7, r25	; 0x07
   11046:	86 83       	std	Z+6, r24	; 0x06
   11048:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   1104c:	ed b7       	in	r30, 0x3d	; 61
   1104e:	fe b7       	in	r31, 0x3e	; 62
   11050:	38 96       	adiw	r30, 0x08	; 8
   11052:	0f b6       	in	r0, 0x3f	; 63
   11054:	f8 94       	cli
   11056:	fe bf       	out	0x3e, r31	; 62
   11058:	0f be       	out	0x3f, r0	; 63
   1105a:	ed bf       	out	0x3d, r30	; 61
   1105c:	81 e0       	ldi	r24, 0x01	; 1
   1105e:	61 e0       	ldi	r22, 0x01	; 1
   11060:	a8 01       	movw	r20, r16
   11062:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   11066:	82 e0       	ldi	r24, 0x02	; 2
   11068:	61 e0       	ldi	r22, 0x01	; 1
   1106a:	47 e8       	ldi	r20, 0x87	; 135
   1106c:	51 e2       	ldi	r21, 0x21	; 33
   1106e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   11072:	83 e0       	ldi	r24, 0x03	; 3
   11074:	61 e0       	ldi	r22, 0x01	; 1
   11076:	42 e7       	ldi	r20, 0x72	; 114
   11078:	51 e2       	ldi	r21, 0x21	; 33
   1107a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   1107e:	84 e0       	ldi	r24, 0x04	; 4
   11080:	61 e0       	ldi	r22, 0x01	; 1
   11082:	4d e5       	ldi	r20, 0x5D	; 93
   11084:	51 e2       	ldi	r21, 0x21	; 33
   11086:	43 c0       	rjmp	.+134    	; 0x1110e <FMenuLocalAccount+0x9aa>
				   }
                else
		        if(BalanceType==2){
   11088:	82 30       	cpi	r24, 0x02	; 2
   1108a:	09 f0       	breq	.+2      	; 0x1108e <FMenuLocalAccount+0x92a>
   1108c:	42 c0       	rjmp	.+132    	; 0x11112 <FMenuLocalAccount+0x9ae>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1108e:	2d b7       	in	r18, 0x3d	; 61
   11090:	3e b7       	in	r19, 0x3e	; 62
   11092:	28 50       	subi	r18, 0x08	; 8
   11094:	30 40       	sbci	r19, 0x00	; 0
   11096:	0f b6       	in	r0, 0x3f	; 63
   11098:	f8 94       	cli
   1109a:	3e bf       	out	0x3e, r19	; 62
   1109c:	0f be       	out	0x3f, r0	; 63
   1109e:	2d bf       	out	0x3d, r18	; 61
   110a0:	ed b7       	in	r30, 0x3d	; 61
   110a2:	fe b7       	in	r31, 0x3e	; 62
   110a4:	31 96       	adiw	r30, 0x01	; 1
   110a6:	8e 01       	movw	r16, r28
   110a8:	04 5f       	subi	r16, 0xF4	; 244
   110aa:	1f 4f       	sbci	r17, 0xFF	; 255
   110ac:	ad b7       	in	r26, 0x3d	; 61
   110ae:	be b7       	in	r27, 0x3e	; 62
   110b0:	12 96       	adiw	r26, 0x02	; 2
   110b2:	1c 93       	st	X, r17
   110b4:	0e 93       	st	-X, r16
   110b6:	11 97       	sbiw	r26, 0x01	; 1
   110b8:	85 e5       	ldi	r24, 0x55	; 85
   110ba:	91 e2       	ldi	r25, 0x21	; 33
   110bc:	93 83       	std	Z+3, r25	; 0x03
   110be:	82 83       	std	Z+2, r24	; 0x02
   110c0:	81 e9       	ldi	r24, 0x91	; 145
   110c2:	92 e0       	ldi	r25, 0x02	; 2
   110c4:	95 83       	std	Z+5, r25	; 0x05
   110c6:	84 83       	std	Z+4, r24	; 0x04
   110c8:	8e e5       	ldi	r24, 0x5E	; 94
   110ca:	97 e0       	ldi	r25, 0x07	; 7
   110cc:	97 83       	std	Z+7, r25	; 0x07
   110ce:	86 83       	std	Z+6, r24	; 0x06
   110d0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   110d4:	ed b7       	in	r30, 0x3d	; 61
   110d6:	fe b7       	in	r31, 0x3e	; 62
   110d8:	38 96       	adiw	r30, 0x08	; 8
   110da:	0f b6       	in	r0, 0x3f	; 63
   110dc:	f8 94       	cli
   110de:	fe bf       	out	0x3e, r31	; 62
   110e0:	0f be       	out	0x3f, r0	; 63
   110e2:	ed bf       	out	0x3d, r30	; 61
   110e4:	81 e0       	ldi	r24, 0x01	; 1
   110e6:	61 e0       	ldi	r22, 0x01	; 1
   110e8:	a8 01       	movw	r20, r16
   110ea:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   110ee:	82 e0       	ldi	r24, 0x02	; 2
   110f0:	61 e0       	ldi	r22, 0x01	; 1
   110f2:	40 e4       	ldi	r20, 0x40	; 64
   110f4:	51 e2       	ldi	r21, 0x21	; 33
   110f6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   110fa:	83 e0       	ldi	r24, 0x03	; 3
   110fc:	61 e0       	ldi	r22, 0x01	; 1
   110fe:	4b e2       	ldi	r20, 0x2B	; 43
   11100:	51 e2       	ldi	r21, 0x21	; 33
   11102:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   11106:	84 e0       	ldi	r24, 0x04	; 4
   11108:	61 e0       	ldi	r22, 0x01	; 1
   1110a:	46 e1       	ldi	r20, 0x16	; 22
   1110c:	51 e2       	ldi	r21, 0x21	; 33
   1110e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				   }
                iLoop=0;
   11112:	10 92 85 02 	sts	0x0285, r1
   11116:	10 92 84 02 	sts	0x0284, r1
				iValuePos=0;
   1111a:	10 92 90 02 	sts	0x0290, r1
				//ValueChar[iValuePos]=' ';
		        stLocalAccount=laBalanceValueInput;  
   1111e:	80 e1       	ldi	r24, 0x10	; 16
   11120:	1c c1       	rjmp	.+568    	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break; 
           case laBalanceValueInput:
		        uiResult=UserInput(UI_NUMBER_R,(1+BalanceType),11,strBalanceValue,0,10); 
   11122:	60 91 94 02 	lds	r22, 0x0294
   11126:	6f 5f       	subi	r22, 0xFF	; 255
   11128:	81 e0       	ldi	r24, 0x01	; 1
   1112a:	4b e0       	ldi	r20, 0x0B	; 11
   1112c:	2f e1       	ldi	r18, 0x1F	; 31
   1112e:	3c e0       	ldi	r19, 0x0C	; 12
   11130:	00 e0       	ldi	r16, 0x00	; 0
   11132:	10 e0       	ldi	r17, 0x00	; 0
   11134:	5a e0       	ldi	r21, 0x0A	; 10
   11136:	e5 2e       	mov	r14, r21
   11138:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
				if (uiResult==USER_CANCEL){
   1113c:	81 30       	cpi	r24, 0x01	; 1
   1113e:	61 f4       	brne	.+24     	; 0x11158 <FMenuLocalAccount+0x9f4>
				    lcd_clear();
   11140:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
   11144:	88 ee       	ldi	r24, 0xE8	; 232
   11146:	93 e0       	ldi	r25, 0x03	; 3
   11148:	20 e7       	ldi	r18, 0x70	; 112
   1114a:	31 e0       	ldi	r19, 0x01	; 1
   1114c:	f9 01       	movw	r30, r18
   1114e:	31 97       	sbiw	r30, 0x01	; 1
   11150:	f1 f7       	brne	.-4      	; 0x1114e <FMenuLocalAccount+0x9ea>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   11152:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   11154:	d9 f7       	brne	.-10     	; 0x1114c <FMenuLocalAccount+0x9e8>
   11156:	fe c0       	rjmp	.+508    	; 0x11354 <FMenuLocalAccount+0xbf0>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (uiResult==USER_OK){				    
   11158:	83 30       	cpi	r24, 0x03	; 3
   1115a:	09 f0       	breq	.+2      	; 0x1115e <FMenuLocalAccount+0x9fa>
   1115c:	b6 c3       	rjmp	.+1900   	; 0x118ca <FMenuLocalAccount+0x1166>
				    stLocalAccount=laOdometer;
   1115e:	81 e1       	ldi	r24, 0x11	; 17
   11160:	80 93 5b 01 	sts	0x015B, r24
					lcd_clear();
   11164:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
   11168:	88 ee       	ldi	r24, 0xE8	; 232
   1116a:	93 e0       	ldi	r25, 0x03	; 3
   1116c:	20 e7       	ldi	r18, 0x70	; 112
   1116e:	31 e0       	ldi	r19, 0x01	; 1
   11170:	f9 01       	movw	r30, r18
   11172:	31 97       	sbiw	r30, 0x01	; 1
   11174:	f1 f7       	brne	.-4      	; 0x11172 <FMenuLocalAccount+0xa0e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   11176:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   11178:	d9 f7       	brne	.-10     	; 0x11170 <FMenuLocalAccount+0xa0c>
   1117a:	a7 c3       	rjmp	.+1870   	; 0x118ca <FMenuLocalAccount+0x1166>
					_delay_ms(100);		        
					}
*/
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   1117c:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
				if (IsFullAuthorized==True){
   11180:	80 91 86 02 	lds	r24, 0x0286
   11184:	81 30       	cpi	r24, 0x01	; 1
   11186:	09 f0       	breq	.+2      	; 0x1118a <FMenuLocalAccount+0xa26>
   11188:	4a c0       	rjmp	.+148    	; 0x1121e <FMenuLocalAccount+0xaba>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   1118a:	61 e0       	ldi	r22, 0x01	; 1
   1118c:	42 e0       	ldi	r20, 0x02	; 2
   1118e:	51 e2       	ldi	r21, 0x21	; 33
   11190:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   11194:	2d b7       	in	r18, 0x3d	; 61
   11196:	3e b7       	in	r19, 0x3e	; 62
   11198:	28 50       	subi	r18, 0x08	; 8
   1119a:	30 40       	sbci	r19, 0x00	; 0
   1119c:	0f b6       	in	r0, 0x3f	; 63
   1119e:	f8 94       	cli
   111a0:	3e bf       	out	0x3e, r19	; 62
   111a2:	0f be       	out	0x3f, r0	; 63
   111a4:	2d bf       	out	0x3d, r18	; 61
   111a6:	ed b7       	in	r30, 0x3d	; 61
   111a8:	fe b7       	in	r31, 0x3e	; 62
   111aa:	31 96       	adiw	r30, 0x01	; 1
   111ac:	8e 01       	movw	r16, r28
   111ae:	04 5f       	subi	r16, 0xF4	; 244
   111b0:	1f 4f       	sbci	r17, 0xFF	; 255
   111b2:	ad b7       	in	r26, 0x3d	; 61
   111b4:	be b7       	in	r27, 0x3e	; 62
   111b6:	12 96       	adiw	r26, 0x02	; 2
   111b8:	1c 93       	st	X, r17
   111ba:	0e 93       	st	-X, r16
   111bc:	11 97       	sbiw	r26, 0x01	; 1
   111be:	89 ef       	ldi	r24, 0xF9	; 249
   111c0:	90 e2       	ldi	r25, 0x20	; 32
   111c2:	93 83       	std	Z+3, r25	; 0x03
   111c4:	82 83       	std	Z+2, r24	; 0x02
   111c6:	81 e9       	ldi	r24, 0x91	; 145
   111c8:	92 e0       	ldi	r25, 0x02	; 2
   111ca:	95 83       	std	Z+5, r25	; 0x05
   111cc:	84 83       	std	Z+4, r24	; 0x04
   111ce:	8e e5       	ldi	r24, 0x5E	; 94
   111d0:	97 e0       	ldi	r25, 0x07	; 7
   111d2:	97 83       	std	Z+7, r25	; 0x07
   111d4:	86 83       	std	Z+6, r24	; 0x06
   111d6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   111da:	ed b7       	in	r30, 0x3d	; 61
   111dc:	fe b7       	in	r31, 0x3e	; 62
   111de:	38 96       	adiw	r30, 0x08	; 8
   111e0:	0f b6       	in	r0, 0x3f	; 63
   111e2:	f8 94       	cli
   111e4:	fe bf       	out	0x3e, r31	; 62
   111e6:	0f be       	out	0x3f, r0	; 63
   111e8:	ed bf       	out	0x3d, r30	; 61
   111ea:	82 e0       	ldi	r24, 0x02	; 2
   111ec:	61 e0       	ldi	r22, 0x01	; 1
   111ee:	a8 01       	movw	r20, r16
   111f0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   111f4:	00 d0       	rcall	.+0      	; 0x111f6 <FMenuLocalAccount+0xa92>
   111f6:	00 d0       	rcall	.+0      	; 0x111f8 <FMenuLocalAccount+0xa94>
   111f8:	ad b7       	in	r26, 0x3d	; 61
   111fa:	be b7       	in	r27, 0x3e	; 62
   111fc:	12 96       	adiw	r26, 0x02	; 2
   111fe:	1c 93       	st	X, r17
   11200:	0e 93       	st	-X, r16
   11202:	11 97       	sbiw	r26, 0x01	; 1
   11204:	82 ef       	ldi	r24, 0xF2	; 242
   11206:	90 e2       	ldi	r25, 0x20	; 32
   11208:	14 96       	adiw	r26, 0x04	; 4
   1120a:	9c 93       	st	X, r25
   1120c:	8e 93       	st	-X, r24
   1120e:	13 97       	sbiw	r26, 0x03	; 3
   11210:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   11214:	0f 90       	pop	r0
   11216:	0f 90       	pop	r0
   11218:	0f 90       	pop	r0
   1121a:	0f 90       	pop	r0
   1121c:	5e c0       	rjmp	.+188    	; 0x112da <FMenuLocalAccount+0xb76>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   1121e:	80 91 94 02 	lds	r24, 0x0294
   11222:	81 30       	cpi	r24, 0x01	; 1
   11224:	29 f4       	brne	.+10     	; 0x11230 <FMenuLocalAccount+0xacc>
   11226:	61 e0       	ldi	r22, 0x01	; 1
   11228:	4e ed       	ldi	r20, 0xDE	; 222
   1122a:	50 e2       	ldi	r21, 0x20	; 32
   1122c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   11230:	80 91 94 02 	lds	r24, 0x0294
   11234:	82 30       	cpi	r24, 0x02	; 2
   11236:	31 f4       	brne	.+12     	; 0x11244 <FMenuLocalAccount+0xae0>
   11238:	81 e0       	ldi	r24, 0x01	; 1
   1123a:	61 e0       	ldi	r22, 0x01	; 1
   1123c:	4a ec       	ldi	r20, 0xCA	; 202
   1123e:	50 e2       	ldi	r21, 0x20	; 32
   11240:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   11244:	ed b7       	in	r30, 0x3d	; 61
   11246:	fe b7       	in	r31, 0x3e	; 62
   11248:	38 97       	sbiw	r30, 0x08	; 8
   1124a:	0f b6       	in	r0, 0x3f	; 63
   1124c:	f8 94       	cli
   1124e:	fe bf       	out	0x3e, r31	; 62
   11250:	0f be       	out	0x3f, r0	; 63
   11252:	ed bf       	out	0x3d, r30	; 61
   11254:	31 96       	adiw	r30, 0x01	; 1
   11256:	8e 01       	movw	r16, r28
   11258:	04 5f       	subi	r16, 0xF4	; 244
   1125a:	1f 4f       	sbci	r17, 0xFF	; 255
   1125c:	ad b7       	in	r26, 0x3d	; 61
   1125e:	be b7       	in	r27, 0x3e	; 62
   11260:	12 96       	adiw	r26, 0x02	; 2
   11262:	1c 93       	st	X, r17
   11264:	0e 93       	st	-X, r16
   11266:	11 97       	sbiw	r26, 0x01	; 1
   11268:	81 ec       	ldi	r24, 0xC1	; 193
   1126a:	90 e2       	ldi	r25, 0x20	; 32
   1126c:	93 83       	std	Z+3, r25	; 0x03
   1126e:	82 83       	std	Z+2, r24	; 0x02
   11270:	81 e9       	ldi	r24, 0x91	; 145
   11272:	92 e0       	ldi	r25, 0x02	; 2
   11274:	95 83       	std	Z+5, r25	; 0x05
   11276:	84 83       	std	Z+4, r24	; 0x04
   11278:	8e e5       	ldi	r24, 0x5E	; 94
   1127a:	97 e0       	ldi	r25, 0x07	; 7
   1127c:	97 83       	std	Z+7, r25	; 0x07
   1127e:	86 83       	std	Z+6, r24	; 0x06
   11280:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   11284:	ed b7       	in	r30, 0x3d	; 61
   11286:	fe b7       	in	r31, 0x3e	; 62
   11288:	38 96       	adiw	r30, 0x08	; 8
   1128a:	0f b6       	in	r0, 0x3f	; 63
   1128c:	f8 94       	cli
   1128e:	fe bf       	out	0x3e, r31	; 62
   11290:	0f be       	out	0x3f, r0	; 63
   11292:	ed bf       	out	0x3d, r30	; 61
   11294:	82 e0       	ldi	r24, 0x02	; 2
   11296:	61 e0       	ldi	r22, 0x01	; 1
   11298:	a8 01       	movw	r20, r16
   1129a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   1129e:	00 d0       	rcall	.+0      	; 0x112a0 <FMenuLocalAccount+0xb3c>
   112a0:	00 d0       	rcall	.+0      	; 0x112a2 <FMenuLocalAccount+0xb3e>
   112a2:	00 d0       	rcall	.+0      	; 0x112a4 <FMenuLocalAccount+0xb40>
   112a4:	ed b7       	in	r30, 0x3d	; 61
   112a6:	fe b7       	in	r31, 0x3e	; 62
   112a8:	31 96       	adiw	r30, 0x01	; 1
   112aa:	ad b7       	in	r26, 0x3d	; 61
   112ac:	be b7       	in	r27, 0x3e	; 62
   112ae:	12 96       	adiw	r26, 0x02	; 2
   112b0:	1c 93       	st	X, r17
   112b2:	0e 93       	st	-X, r16
   112b4:	11 97       	sbiw	r26, 0x01	; 1
   112b6:	8d eb       	ldi	r24, 0xBD	; 189
   112b8:	90 e2       	ldi	r25, 0x20	; 32
   112ba:	93 83       	std	Z+3, r25	; 0x03
   112bc:	82 83       	std	Z+2, r24	; 0x02
   112be:	8f e1       	ldi	r24, 0x1F	; 31
   112c0:	9c e0       	ldi	r25, 0x0C	; 12
   112c2:	95 83       	std	Z+5, r25	; 0x05
   112c4:	84 83       	std	Z+4, r24	; 0x04
   112c6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   112ca:	ed b7       	in	r30, 0x3d	; 61
   112cc:	fe b7       	in	r31, 0x3e	; 62
   112ce:	36 96       	adiw	r30, 0x06	; 6
   112d0:	0f b6       	in	r0, 0x3f	; 63
   112d2:	f8 94       	cli
   112d4:	fe bf       	out	0x3e, r31	; 62
   112d6:	0f be       	out	0x3f, r0	; 63
   112d8:	ed bf       	out	0x3d, r30	; 61
   112da:	82 e0       	ldi	r24, 0x02	; 2
   112dc:	6e e0       	ldi	r22, 0x0E	; 14
   112de:	a8 01       	movw	r20, r16
   112e0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   112e4:	83 e0       	ldi	r24, 0x03	; 3
   112e6:	61 e0       	ldi	r22, 0x01	; 1
   112e8:	4b ea       	ldi	r20, 0xAB	; 171
   112ea:	50 e2       	ldi	r21, 0x20	; 32
   112ec:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   112f0:	84 e0       	ldi	r24, 0x04	; 4
   112f2:	61 e0       	ldi	r22, 0x01	; 1
   112f4:	49 e9       	ldi	r20, 0x99	; 153
   112f6:	50 e2       	ldi	r21, 0x20	; 32
   112f8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				ClearMem(strOdometer);
   112fc:	83 ec       	ldi	r24, 0xC3	; 195
   112fe:	93 e0       	ldi	r25, 0x03	; 3
   11300:	0e 94 19 aa 	call	0x15432	; 0x15432 <ClearMem>
		        stLocalAccount=laOdometerInput;
   11304:	82 e1       	ldi	r24, 0x12	; 18
   11306:	29 c0       	rjmp	.+82     	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break;
           case laOdometerInput:
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   11308:	23 ec       	ldi	r18, 0xC3	; 195
   1130a:	c2 2e       	mov	r12, r18
   1130c:	23 e0       	ldi	r18, 0x03	; 3
   1130e:	d2 2e       	mov	r13, r18
   11310:	81 e0       	ldi	r24, 0x01	; 1
   11312:	63 e0       	ldi	r22, 0x03	; 3
   11314:	4a e0       	ldi	r20, 0x0A	; 10
   11316:	96 01       	movw	r18, r12
   11318:	00 e0       	ldi	r16, 0x00	; 0
   1131a:	10 e0       	ldi	r17, 0x00	; 0
   1131c:	9a e0       	ldi	r25, 0x0A	; 10
   1131e:	e9 2e       	mov	r14, r25
   11320:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
				if (uiResult==USER_OK){
   11324:	83 30       	cpi	r24, 0x03	; 3
   11326:	79 f4       	brne	.+30     	; 0x11346 <FMenuLocalAccount+0xbe2>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   11328:	f6 01       	movw	r30, r12
   1132a:	01 90       	ld	r0, Z+
   1132c:	00 20       	and	r0, r0
   1132e:	e9 f7       	brne	.-6      	; 0x1132a <FMenuLocalAccount+0xbc6>
   11330:	e5 5c       	subi	r30, 0xC5	; 197
   11332:	f3 40       	sbci	r31, 0x03	; 3
   11334:	31 f4       	brne	.+12     	; 0x11342 <FMenuLocalAccount+0xbde>
   11336:	80 91 c3 03 	lds	r24, 0x03C3
   1133a:	80 33       	cpi	r24, 0x30	; 48
   1133c:	11 f4       	brne	.+4      	; 0x11342 <FMenuLocalAccount+0xbde>
					    strOdometer[0]=0;
   1133e:	10 92 c3 03 	sts	0x03C3, r1
				    stLocalAccount=laDataConfirm;
   11342:	83 e1       	ldi	r24, 0x13	; 19
   11344:	0a c0       	rjmp	.+20     	; 0x1135a <FMenuLocalAccount+0xbf6>
					}
			    else
			    if (uiResult==USER_CANCEL){
   11346:	81 30       	cpi	r24, 0x01	; 1
   11348:	09 f0       	breq	.+2      	; 0x1134c <FMenuLocalAccount+0xbe8>
   1134a:	bf c2       	rjmp	.+1406   	; 0x118ca <FMenuLocalAccount+0x1166>
				    if (IsFullAuthorized==True)
   1134c:	80 91 86 02 	lds	r24, 0x0286
   11350:	81 30       	cpi	r24, 0x01	; 1
   11352:	11 f4       	brne	.+4      	; 0x11358 <FMenuLocalAccount+0xbf4>
					     stLocalAccount=laSelectBalanceType;
   11354:	8d e0       	ldi	r24, 0x0D	; 13
   11356:	01 c0       	rjmp	.+2      	; 0x1135a <FMenuLocalAccount+0xbf6>
					else stLocalAccount=laBalanceValue;		        
   11358:	8f e0       	ldi	r24, 0x0F	; 15
   1135a:	80 93 5b 01 	sts	0x015B, r24
   1135e:	b5 c2       	rjmp	.+1386   	; 0x118ca <FMenuLocalAccount+0x1166>
				 }
		        break;
           case laDataConfirm: 
		        lcd_clear();
   11360:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
   11364:	ed e2       	ldi	r30, 0x2D	; 45
   11366:	f3 e0       	ldi	r31, 0x03	; 3
   11368:	de 01       	movw	r26, r28
   1136a:	90 96       	adiw	r26, 0x20	; 32
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   1136c:	81 91       	ld	r24, Z+
   1136e:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   11370:	33 e0       	ldi	r19, 0x03	; 3
   11372:	e7 33       	cpi	r30, 0x37	; 55
   11374:	f3 07       	cpc	r31, r19
   11376:	d1 f7       	brne	.-12     	; 0x1136c <FMenuLocalAccount+0xc08>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   11378:	1a a6       	std	Y+42, r1	; 0x2a
				 }
		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   1137a:	00 d0       	rcall	.+0      	; 0x1137c <FMenuLocalAccount+0xc18>
   1137c:	00 d0       	rcall	.+0      	; 0x1137e <FMenuLocalAccount+0xc1a>
   1137e:	00 d0       	rcall	.+0      	; 0x11380 <FMenuLocalAccount+0xc1c>
   11380:	ed b7       	in	r30, 0x3d	; 61
   11382:	fe b7       	in	r31, 0x3e	; 62
   11384:	31 96       	adiw	r30, 0x01	; 1
   11386:	8e 01       	movw	r16, r28
   11388:	04 5f       	subi	r16, 0xF4	; 244
   1138a:	1f 4f       	sbci	r17, 0xFF	; 255
   1138c:	ad b7       	in	r26, 0x3d	; 61
   1138e:	be b7       	in	r27, 0x3e	; 62
   11390:	12 96       	adiw	r26, 0x02	; 2
   11392:	1c 93       	st	X, r17
   11394:	0e 93       	st	-X, r16
   11396:	11 97       	sbiw	r26, 0x01	; 1
   11398:	85 e9       	ldi	r24, 0x95	; 149
   1139a:	90 e2       	ldi	r25, 0x20	; 32
   1139c:	93 83       	std	Z+3, r25	; 0x03
   1139e:	82 83       	std	Z+2, r24	; 0x02
   113a0:	ce 01       	movw	r24, r28
   113a2:	80 96       	adiw	r24, 0x20	; 32
   113a4:	95 83       	std	Z+5, r25	; 0x05
   113a6:	84 83       	std	Z+4, r24	; 0x04
   113a8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   113ac:	ed b7       	in	r30, 0x3d	; 61
   113ae:	fe b7       	in	r31, 0x3e	; 62
   113b0:	36 96       	adiw	r30, 0x06	; 6
   113b2:	0f b6       	in	r0, 0x3f	; 63
   113b4:	f8 94       	cli
   113b6:	fe bf       	out	0x3e, r31	; 62
   113b8:	0f be       	out	0x3f, r0	; 63
   113ba:	ed bf       	out	0x3d, r30	; 61
   113bc:	81 e0       	ldi	r24, 0x01	; 1
   113be:	61 e0       	ldi	r22, 0x01	; 1
   113c0:	a8 01       	movw	r20, r16
   113c2:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   113c6:	00 d0       	rcall	.+0      	; 0x113c8 <FMenuLocalAccount+0xc64>
   113c8:	00 d0       	rcall	.+0      	; 0x113ca <FMenuLocalAccount+0xc66>
   113ca:	00 d0       	rcall	.+0      	; 0x113cc <FMenuLocalAccount+0xc68>
   113cc:	ed b7       	in	r30, 0x3d	; 61
   113ce:	fe b7       	in	r31, 0x3e	; 62
   113d0:	31 96       	adiw	r30, 0x01	; 1
   113d2:	ad b7       	in	r26, 0x3d	; 61
   113d4:	be b7       	in	r27, 0x3e	; 62
   113d6:	12 96       	adiw	r26, 0x02	; 2
   113d8:	1c 93       	st	X, r17
   113da:	0e 93       	st	-X, r16
   113dc:	11 97       	sbiw	r26, 0x01	; 1
   113de:	8e e8       	ldi	r24, 0x8E	; 142
   113e0:	90 e2       	ldi	r25, 0x20	; 32
   113e2:	93 83       	std	Z+3, r25	; 0x03
   113e4:	82 83       	std	Z+2, r24	; 0x02
   113e6:	89 e8       	ldi	r24, 0x89	; 137
   113e8:	9b e0       	ldi	r25, 0x0B	; 11
   113ea:	95 83       	std	Z+5, r25	; 0x05
   113ec:	84 83       	std	Z+4, r24	; 0x04
   113ee:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   113f2:	ed b7       	in	r30, 0x3d	; 61
   113f4:	fe b7       	in	r31, 0x3e	; 62
   113f6:	36 96       	adiw	r30, 0x06	; 6
   113f8:	0f b6       	in	r0, 0x3f	; 63
   113fa:	f8 94       	cli
   113fc:	fe bf       	out	0x3e, r31	; 62
   113fe:	0f be       	out	0x3f, r0	; 63
   11400:	ed bf       	out	0x3d, r30	; 61
   11402:	82 e0       	ldi	r24, 0x02	; 2
   11404:	61 e0       	ldi	r22, 0x01	; 1
   11406:	a8 01       	movw	r20, r16
   11408:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   1140c:	2d b7       	in	r18, 0x3d	; 61
   1140e:	3e b7       	in	r19, 0x3e	; 62
   11410:	28 50       	subi	r18, 0x08	; 8
   11412:	30 40       	sbci	r19, 0x00	; 0
   11414:	0f b6       	in	r0, 0x3f	; 63
   11416:	f8 94       	cli
   11418:	3e bf       	out	0x3e, r19	; 62
   1141a:	0f be       	out	0x3f, r0	; 63
   1141c:	2d bf       	out	0x3d, r18	; 61
   1141e:	ed b7       	in	r30, 0x3d	; 61
   11420:	fe b7       	in	r31, 0x3e	; 62
   11422:	31 96       	adiw	r30, 0x01	; 1
   11424:	ad b7       	in	r26, 0x3d	; 61
   11426:	be b7       	in	r27, 0x3e	; 62
   11428:	12 96       	adiw	r26, 0x02	; 2
   1142a:	1c 93       	st	X, r17
   1142c:	0e 93       	st	-X, r16
   1142e:	11 97       	sbiw	r26, 0x01	; 1
   11430:	86 e8       	ldi	r24, 0x86	; 134
   11432:	90 e2       	ldi	r25, 0x20	; 32
   11434:	93 83       	std	Z+3, r25	; 0x03
   11436:	82 83       	std	Z+2, r24	; 0x02
   11438:	81 e9       	ldi	r24, 0x91	; 145
   1143a:	92 e0       	ldi	r25, 0x02	; 2
   1143c:	95 83       	std	Z+5, r25	; 0x05
   1143e:	84 83       	std	Z+4, r24	; 0x04
   11440:	8e e5       	ldi	r24, 0x5E	; 94
   11442:	97 e0       	ldi	r25, 0x07	; 7
   11444:	97 83       	std	Z+7, r25	; 0x07
   11446:	86 83       	std	Z+6, r24	; 0x06
   11448:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   1144c:	ed b7       	in	r30, 0x3d	; 61
   1144e:	fe b7       	in	r31, 0x3e	; 62
   11450:	38 96       	adiw	r30, 0x08	; 8
   11452:	0f b6       	in	r0, 0x3f	; 63
   11454:	f8 94       	cli
   11456:	fe bf       	out	0x3e, r31	; 62
   11458:	0f be       	out	0x3f, r0	; 63
   1145a:	ed bf       	out	0x3d, r30	; 61
   1145c:	83 e0       	ldi	r24, 0x03	; 3
   1145e:	61 e0       	ldi	r22, 0x01	; 1
   11460:	a8 01       	movw	r20, r16
   11462:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		        if (IsFullAuthorized==True){
   11466:	80 91 86 02 	lds	r24, 0x0286
   1146a:	81 30       	cpi	r24, 0x01	; 1
   1146c:	39 f4       	brne	.+14     	; 0x1147c <FMenuLocalAccount+0xd18>
                    lcd_printf(3,15,PSTR(" Full"));
   1146e:	83 e0       	ldi	r24, 0x03	; 3
   11470:	6f e0       	ldi	r22, 0x0F	; 15
   11472:	40 e8       	ldi	r20, 0x80	; 128
   11474:	50 e2       	ldi	r21, 0x20	; 32
   11476:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
   1147a:	23 c0       	rjmp	.+70     	; 0x114c2 <FMenuLocalAccount+0xd5e>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   1147c:	00 d0       	rcall	.+0      	; 0x1147e <FMenuLocalAccount+0xd1a>
   1147e:	00 d0       	rcall	.+0      	; 0x11480 <FMenuLocalAccount+0xd1c>
   11480:	00 d0       	rcall	.+0      	; 0x11482 <FMenuLocalAccount+0xd1e>
   11482:	ed b7       	in	r30, 0x3d	; 61
   11484:	fe b7       	in	r31, 0x3e	; 62
   11486:	31 96       	adiw	r30, 0x01	; 1
   11488:	ad b7       	in	r26, 0x3d	; 61
   1148a:	be b7       	in	r27, 0x3e	; 62
   1148c:	12 96       	adiw	r26, 0x02	; 2
   1148e:	1c 93       	st	X, r17
   11490:	0e 93       	st	-X, r16
   11492:	11 97       	sbiw	r26, 0x01	; 1
   11494:	8c e7       	ldi	r24, 0x7C	; 124
   11496:	90 e2       	ldi	r25, 0x20	; 32
   11498:	93 83       	std	Z+3, r25	; 0x03
   1149a:	82 83       	std	Z+2, r24	; 0x02
   1149c:	8f e1       	ldi	r24, 0x1F	; 31
   1149e:	9c e0       	ldi	r25, 0x0C	; 12
   114a0:	95 83       	std	Z+5, r25	; 0x05
   114a2:	84 83       	std	Z+4, r24	; 0x04
   114a4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   114a8:	ed b7       	in	r30, 0x3d	; 61
   114aa:	fe b7       	in	r31, 0x3e	; 62
   114ac:	36 96       	adiw	r30, 0x06	; 6
   114ae:	0f b6       	in	r0, 0x3f	; 63
   114b0:	f8 94       	cli
   114b2:	fe bf       	out	0x3e, r31	; 62
   114b4:	0f be       	out	0x3f, r0	; 63
   114b6:	ed bf       	out	0x3d, r30	; 61
   114b8:	83 e0       	ldi	r24, 0x03	; 3
   114ba:	6f e0       	ldi	r22, 0x0F	; 15
   114bc:	a8 01       	movw	r20, r16
   114be:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   114c2:	84 e0       	ldi	r24, 0x04	; 4
   114c4:	61 e0       	ldi	r22, 0x01	; 1
   114c6:	47 e6       	ldi	r20, 0x67	; 103
   114c8:	50 e2       	ldi	r21, 0x20	; 32
   114ca:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   114ce:	84 e1       	ldi	r24, 0x14	; 20
   114d0:	44 cf       	rjmp	.-376    	; 0x1135a <FMenuLocalAccount+0xbf6>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   114d2:	81 e0       	ldi	r24, 0x01	; 1
   114d4:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   114d8:	87 3e       	cpi	r24, 0xE7	; 231
   114da:	11 f4       	brne	.+4      	; 0x114e0 <FMenuLocalAccount+0xd7c>
   114dc:	81 e1       	ldi	r24, 0x11	; 17
   114de:	3d cf       	rjmp	.-390    	; 0x1135a <FMenuLocalAccount+0xbf6>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   114e0:	87 3b       	cpi	r24, 0xB7	; 183
   114e2:	11 f4       	brne	.+4      	; 0x114e8 <FMenuLocalAccount+0xd84>
   114e4:	85 e1       	ldi	r24, 0x15	; 21
   114e6:	39 cf       	rjmp	.-398    	; 0x1135a <FMenuLocalAccount+0xbf6>
				else
				if (KeyPressed==_KEY_0){
   114e8:	87 3d       	cpi	r24, 0xD7	; 215
   114ea:	09 f0       	breq	.+2      	; 0x114ee <FMenuLocalAccount+0xd8a>
   114ec:	ee c1       	rjmp	.+988    	; 0x118ca <FMenuLocalAccount+0x1166>
				   //ShowCancel
				   TimLocAcc=0;
   114ee:	10 92 ba 01 	sts	0x01BA, r1
                   lcd_clear();
   114f2:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   114f6:	81 e0       	ldi	r24, 0x01	; 1
   114f8:	61 e0       	ldi	r22, 0x01	; 1
   114fa:	42 e5       	ldi	r20, 0x52	; 82
   114fc:	50 e2       	ldi	r21, 0x20	; 32
   114fe:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
   11502:	d4 c1       	rjmp	.+936    	; 0x118ac <FMenuLocalAccount+0x1148>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   11504:	0e 94 aa 83 	call	0x10754	; 0x10754 <sendMessage58>
                RemZeroLead(strCardID);
   11508:	89 e8       	ldi	r24, 0x89	; 137
   1150a:	9b e0       	ldi	r25, 0x0B	; 11
   1150c:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
                RemZeroLead(strBalanceValue);
   11510:	bf e1       	ldi	r27, 0x1F	; 31
   11512:	eb 2e       	mov	r14, r27
   11514:	bc e0       	ldi	r27, 0x0C	; 12
   11516:	fb 2e       	mov	r15, r27
   11518:	c7 01       	movw	r24, r14
   1151a:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   1151e:	2d b7       	in	r18, 0x3d	; 61
   11520:	3e b7       	in	r19, 0x3e	; 62
   11522:	28 50       	subi	r18, 0x08	; 8
   11524:	30 40       	sbci	r19, 0x00	; 0
   11526:	0f b6       	in	r0, 0x3f	; 63
   11528:	f8 94       	cli
   1152a:	3e bf       	out	0x3e, r19	; 62
   1152c:	0f be       	out	0x3f, r0	; 63
   1152e:	2d bf       	out	0x3d, r18	; 61
   11530:	ed b7       	in	r30, 0x3d	; 61
   11532:	fe b7       	in	r31, 0x3e	; 62
   11534:	31 96       	adiw	r30, 0x01	; 1
   11536:	8e 01       	movw	r16, r28
   11538:	04 5f       	subi	r16, 0xF4	; 244
   1153a:	1f 4f       	sbci	r17, 0xFF	; 255
   1153c:	ad b7       	in	r26, 0x3d	; 61
   1153e:	be b7       	in	r27, 0x3e	; 62
   11540:	12 96       	adiw	r26, 0x02	; 2
   11542:	1c 93       	st	X, r17
   11544:	0e 93       	st	-X, r16
   11546:	11 97       	sbiw	r26, 0x01	; 1
   11548:	8a e4       	ldi	r24, 0x4A	; 74
   1154a:	90 e2       	ldi	r25, 0x20	; 32
   1154c:	93 83       	std	Z+3, r25	; 0x03
   1154e:	82 83       	std	Z+2, r24	; 0x02
   11550:	81 e9       	ldi	r24, 0x91	; 145
   11552:	92 e0       	ldi	r25, 0x02	; 2
   11554:	95 83       	std	Z+5, r25	; 0x05
   11556:	84 83       	std	Z+4, r24	; 0x04
   11558:	8e e5       	ldi	r24, 0x5E	; 94
   1155a:	97 e0       	ldi	r25, 0x07	; 7
   1155c:	97 83       	std	Z+7, r25	; 0x07
   1155e:	86 83       	std	Z+6, r24	; 0x06
   11560:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   11564:	ed b7       	in	r30, 0x3d	; 61
   11566:	fe b7       	in	r31, 0x3e	; 62
   11568:	38 96       	adiw	r30, 0x08	; 8
   1156a:	0f b6       	in	r0, 0x3f	; 63
   1156c:	f8 94       	cli
   1156e:	fe bf       	out	0x3e, r31	; 62
   11570:	0f be       	out	0x3f, r0	; 63
   11572:	ed bf       	out	0x3d, r30	; 61
   11574:	81 e0       	ldi	r24, 0x01	; 1
   11576:	61 e0       	ldi	r22, 0x01	; 1
   11578:	a8 01       	movw	r20, r16
   1157a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   1157e:	00 d0       	rcall	.+0      	; 0x11580 <FMenuLocalAccount+0xe1c>
   11580:	00 d0       	rcall	.+0      	; 0x11582 <FMenuLocalAccount+0xe1e>
   11582:	00 d0       	rcall	.+0      	; 0x11584 <FMenuLocalAccount+0xe20>
   11584:	ed b7       	in	r30, 0x3d	; 61
   11586:	fe b7       	in	r31, 0x3e	; 62
   11588:	31 96       	adiw	r30, 0x01	; 1
   1158a:	ad b7       	in	r26, 0x3d	; 61
   1158c:	be b7       	in	r27, 0x3e	; 62
   1158e:	12 96       	adiw	r26, 0x02	; 2
   11590:	1c 93       	st	X, r17
   11592:	0e 93       	st	-X, r16
   11594:	11 97       	sbiw	r26, 0x01	; 1
   11596:	87 e4       	ldi	r24, 0x47	; 71
   11598:	90 e2       	ldi	r25, 0x20	; 32
   1159a:	93 83       	std	Z+3, r25	; 0x03
   1159c:	82 83       	std	Z+2, r24	; 0x02
   1159e:	f5 82       	std	Z+5, r15	; 0x05
   115a0:	e4 82       	std	Z+4, r14	; 0x04
   115a2:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   115a6:	ed b7       	in	r30, 0x3d	; 61
   115a8:	fe b7       	in	r31, 0x3e	; 62
   115aa:	36 96       	adiw	r30, 0x06	; 6
   115ac:	0f b6       	in	r0, 0x3f	; 63
   115ae:	f8 94       	cli
   115b0:	fe bf       	out	0x3e, r31	; 62
   115b2:	0f be       	out	0x3f, r0	; 63
   115b4:	ed bf       	out	0x3d, r30	; 61
   115b6:	81 e0       	ldi	r24, 0x01	; 1
   115b8:	6f e0       	ldi	r22, 0x0F	; 15
   115ba:	a8 01       	movw	r20, r16
   115bc:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   115c0:	83 e0       	ldi	r24, 0x03	; 3
   115c2:	61 e0       	ldi	r22, 0x01	; 1
   115c4:	42 e3       	ldi	r20, 0x32	; 50
   115c6:	50 e2       	ldi	r21, 0x20	; 32
   115c8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   115cc:	84 e0       	ldi	r24, 0x04	; 4
   115ce:	61 e0       	ldi	r22, 0x01	; 1
   115d0:	4d e1       	ldi	r20, 0x1D	; 29
   115d2:	50 e2       	ldi	r21, 0x20	; 32
   115d4:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				IsMessage00=False;
   115d8:	10 92 9e 01 	sts	0x019E, r1
				TimLocAcc=0;
   115dc:	10 92 ba 01 	sts	0x01BA, r1
				iLoop=0;iPos=0;iWait=0;
   115e0:	10 92 85 02 	sts	0x0285, r1
   115e4:	10 92 84 02 	sts	0x0284, r1
   115e8:	10 92 96 02 	sts	0x0296, r1
   115ec:	10 92 95 02 	sts	0x0295, r1
				stLocalAccount=laWaitMessage00;
   115f0:	87 e1       	ldi	r24, 0x17	; 23
   115f2:	b3 ce       	rjmp	.-666    	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break;
           case laWaitMessage00:
                iLoop++;
   115f4:	80 91 84 02 	lds	r24, 0x0284
   115f8:	90 91 85 02 	lds	r25, 0x0285
   115fc:	01 96       	adiw	r24, 0x01	; 1
   115fe:	90 93 85 02 	sts	0x0285, r25
   11602:	80 93 84 02 	sts	0x0284, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   11606:	68 e9       	ldi	r22, 0x98	; 152
   11608:	7a e3       	ldi	r23, 0x3A	; 58
   1160a:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
   1160e:	89 2b       	or	r24, r25
   11610:	e1 f4       	brne	.+56     	; 0x1164a <FMenuLocalAccount+0xee6>
				   if (iPos<5){
   11612:	60 91 96 02 	lds	r22, 0x0296
   11616:	65 30       	cpi	r22, 0x05	; 5
   11618:	58 f4       	brcc	.+22     	; 0x11630 <FMenuLocalAccount+0xecc>
				       iPos++;
   1161a:	6f 5f       	subi	r22, 0xFF	; 255
   1161c:	60 93 96 02 	sts	0x0296, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   11620:	62 5f       	subi	r22, 0xF2	; 242
   11622:	83 e0       	ldi	r24, 0x03	; 3
   11624:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
   11628:	8e e2       	ldi	r24, 0x2E	; 46
   1162a:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
   1162e:	0d c0       	rjmp	.+26     	; 0x1164a <FMenuLocalAccount+0xee6>
					   }
				   else{
				       iPos=0;
   11630:	10 92 96 02 	sts	0x0296, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   11634:	83 e0       	ldi	r24, 0x03	; 3
   11636:	6e e0       	ldi	r22, 0x0E	; 14
   11638:	45 e1       	ldi	r20, 0x15	; 21
   1163a:	50 e2       	ldi	r21, 0x20	; 32
   1163c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					   iWait++;
   11640:	80 91 95 02 	lds	r24, 0x0295
   11644:	8f 5f       	subi	r24, 0xFF	; 255
   11646:	80 93 95 02 	sts	0x0295, r24
					   }
				}
				if (iWait>5){
   1164a:	80 91 95 02 	lds	r24, 0x0295
   1164e:	86 30       	cpi	r24, 0x06	; 6
   11650:	50 f0       	brcs	.+20     	; 0x11666 <FMenuLocalAccount+0xf02>
				    stLocalAccount=laConTimout;
   11652:	84 e0       	ldi	r24, 0x04	; 4
   11654:	80 93 5b 01 	sts	0x015B, r24
					TimLocAcc=0;
   11658:	10 92 ba 01 	sts	0x01BA, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1165c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1165e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11660:	82 e0       	ldi	r24, 0x02	; 2
   11662:	80 93 bc 01 	sts	0x01BC, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   11666:	80 91 9e 01 	lds	r24, 0x019E
   1166a:	81 30       	cpi	r24, 0x01	; 1
   1166c:	09 f0       	breq	.+2      	; 0x11670 <FMenuLocalAccount+0xf0c>
   1166e:	2d c1       	rjmp	.+602    	; 0x118ca <FMenuLocalAccount+0x1166>
                    IsMessage00=False;
   11670:	10 92 9e 01 	sts	0x019E, r1
				    stLocalAccount=laProcMessage00;
   11674:	88 e1       	ldi	r24, 0x18	; 24
   11676:	71 ce       	rjmp	.-798    	; 0x1135a <FMenuLocalAccount+0xbf6>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   11678:	80 91 1d 09 	lds	r24, 0x091D
   1167c:	81 30       	cpi	r24, 0x01	; 1
   1167e:	51 f4       	brne	.+20     	; 0x11694 <FMenuLocalAccount+0xf30>
   11680:	80 91 8b 01 	lds	r24, 0x018B
   11684:	90 91 8c 01 	lds	r25, 0x018C
   11688:	8f 97       	sbiw	r24, 0x2f	; 47
   1168a:	21 f4       	brne	.+8      	; 0x11694 <FMenuLocalAccount+0xf30>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   1168c:	80 91 42 09 	lds	r24, 0x0942
   11690:	80 53       	subi	r24, 0x30	; 48
   11692:	01 c0       	rjmp	.+2      	; 0x11696 <FMenuLocalAccount+0xf32>
   11694:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   11696:	80 93 97 02 	sts	0x0297, r24
                lcd_clear();
   1169a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		        switch(LocAccStatus){
   1169e:	10 91 97 02 	lds	r17, 0x0297
   116a2:	11 30       	cpi	r17, 0x01	; 1
   116a4:	51 f0       	breq	.+20     	; 0x116ba <FMenuLocalAccount+0xf56>
   116a6:	11 30       	cpi	r17, 0x01	; 1
   116a8:	18 f0       	brcs	.+6      	; 0x116b0 <FMenuLocalAccount+0xf4c>
   116aa:	13 30       	cpi	r17, 0x03	; 3
   116ac:	51 f5       	brne	.+84     	; 0x11702 <FMenuLocalAccount+0xf9e>
   116ae:	1b c0       	rjmp	.+54     	; 0x116e6 <FMenuLocalAccount+0xf82>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   116b0:	82 e0       	ldi	r24, 0x02	; 2
   116b2:	61 e0       	ldi	r22, 0x01	; 1
   116b4:	40 e0       	ldi	r20, 0x00	; 0
   116b6:	50 e2       	ldi	r21, 0x20	; 32
   116b8:	1a c0       	rjmp	.+52     	; 0x116ee <FMenuLocalAccount+0xf8a>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   116ba:	82 e0       	ldi	r24, 0x02	; 2
   116bc:	61 e0       	ldi	r22, 0x01	; 1
   116be:	4b ee       	ldi	r20, 0xEB	; 235
   116c0:	5f e1       	ldi	r21, 0x1F	; 31
   116c2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   116c6:	90 91 8f 01 	lds	r25, 0x018F
   116ca:	e9 2f       	mov	r30, r25
   116cc:	f0 e0       	ldi	r31, 0x00	; 0
   116ce:	ea 5a       	subi	r30, 0xAA	; 170
   116d0:	fc 4f       	sbci	r31, 0xFC	; 252
   116d2:	80 91 88 02 	lds	r24, 0x0288
   116d6:	80 83       	st	Z, r24
					 nLocalAccount++;
   116d8:	9f 5f       	subi	r25, 0xFF	; 255
   116da:	90 93 8f 01 	sts	0x018F, r25
					 IsViewFillingFIP=True;
   116de:	10 93 96 01 	sts	0x0196, r17
					 stLocalAccount=laViewStatus;
   116e2:	86 e1       	ldi	r24, 0x16	; 22
   116e4:	0c c0       	rjmp	.+24     	; 0x116fe <FMenuLocalAccount+0xf9a>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   116e6:	82 e0       	ldi	r24, 0x02	; 2
   116e8:	61 e0       	ldi	r22, 0x01	; 1
   116ea:	48 ed       	ldi	r20, 0xD8	; 216
   116ec:	5f e1       	ldi	r21, 0x1F	; 31
   116ee:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   116f2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   116f4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   116f6:	82 e0       	ldi	r24, 0x02	; 2
   116f8:	80 93 bc 01 	sts	0x01BC, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   116fc:	8e e1       	ldi	r24, 0x1E	; 30
   116fe:	80 93 5b 01 	sts	0x015B, r24
				     break;
				}
				TimLocAcc=0;
   11702:	10 92 ba 01 	sts	0x01BA, r1
				ClearMem(strOdometer);
   11706:	83 ec       	ldi	r24, 0xC3	; 195
   11708:	93 e0       	ldi	r25, 0x03	; 3
   1170a:	0e 94 19 aa 	call	0x15432	; 0x15432 <ClearMem>
	            ClearMem(strLicPlate);
   1170e:	8a ef       	ldi	r24, 0xFA	; 250
   11710:	98 e0       	ldi	r25, 0x08	; 8
   11712:	0e 94 19 aa 	call	0x15432	; 0x15432 <ClearMem>
   11716:	d9 c0       	rjmp	.+434    	; 0x118ca <FMenuLocalAccount+0x1166>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   11718:	80 91 ba 01 	lds	r24, 0x01BA
   1171c:	85 31       	cpi	r24, 0x15	; 21
   1171e:	08 f4       	brcc	.+2      	; 0x11722 <FMenuLocalAccount+0xfbe>
   11720:	d4 c0       	rjmp	.+424    	; 0x118ca <FMenuLocalAccount+0x1166>
   11722:	ca c0       	rjmp	.+404    	; 0x118b8 <FMenuLocalAccount+0x1154>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   11724:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   11728:	2d b7       	in	r18, 0x3d	; 61
   1172a:	3e b7       	in	r19, 0x3e	; 62
   1172c:	28 50       	subi	r18, 0x08	; 8
   1172e:	30 40       	sbci	r19, 0x00	; 0
   11730:	0f b6       	in	r0, 0x3f	; 63
   11732:	f8 94       	cli
   11734:	3e bf       	out	0x3e, r19	; 62
   11736:	0f be       	out	0x3f, r0	; 63
   11738:	2d bf       	out	0x3d, r18	; 61
   1173a:	ed b7       	in	r30, 0x3d	; 61
   1173c:	fe b7       	in	r31, 0x3e	; 62
   1173e:	31 96       	adiw	r30, 0x01	; 1
   11740:	ac e0       	ldi	r26, 0x0C	; 12
   11742:	ea 2e       	mov	r14, r26
   11744:	f1 2c       	mov	r15, r1
   11746:	ec 0e       	add	r14, r28
   11748:	fd 1e       	adc	r15, r29
   1174a:	ad b7       	in	r26, 0x3d	; 61
   1174c:	be b7       	in	r27, 0x3e	; 62
   1174e:	12 96       	adiw	r26, 0x02	; 2
   11750:	fc 92       	st	X, r15
   11752:	ee 92       	st	-X, r14
   11754:	11 97       	sbiw	r26, 0x01	; 1
   11756:	80 ed       	ldi	r24, 0xD0	; 208
   11758:	9f e1       	ldi	r25, 0x1F	; 31
   1175a:	93 83       	std	Z+3, r25	; 0x03
   1175c:	82 83       	std	Z+2, r24	; 0x02
   1175e:	81 e9       	ldi	r24, 0x91	; 145
   11760:	92 e0       	ldi	r25, 0x02	; 2
   11762:	95 83       	std	Z+5, r25	; 0x05
   11764:	84 83       	std	Z+4, r24	; 0x04
   11766:	8e e5       	ldi	r24, 0x5E	; 94
   11768:	97 e0       	ldi	r25, 0x07	; 7
   1176a:	97 83       	std	Z+7, r25	; 0x07
   1176c:	86 83       	std	Z+6, r24	; 0x06
   1176e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   11772:	ed b7       	in	r30, 0x3d	; 61
   11774:	fe b7       	in	r31, 0x3e	; 62
   11776:	38 96       	adiw	r30, 0x08	; 8
   11778:	0f b6       	in	r0, 0x3f	; 63
   1177a:	f8 94       	cli
   1177c:	fe bf       	out	0x3e, r31	; 62
   1177e:	0f be       	out	0x3f, r0	; 63
   11780:	ed bf       	out	0x3d, r30	; 61
   11782:	81 e0       	ldi	r24, 0x01	; 1
   11784:	61 e0       	ldi	r22, 0x01	; 1
   11786:	a7 01       	movw	r20, r14
   11788:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   1178c:	00 d0       	rcall	.+0      	; 0x1178e <FMenuLocalAccount+0x102a>
   1178e:	00 d0       	rcall	.+0      	; 0x11790 <FMenuLocalAccount+0x102c>
   11790:	00 d0       	rcall	.+0      	; 0x11792 <FMenuLocalAccount+0x102e>
   11792:	ed b7       	in	r30, 0x3d	; 61
   11794:	fe b7       	in	r31, 0x3e	; 62
   11796:	31 96       	adiw	r30, 0x01	; 1
   11798:	ad b7       	in	r26, 0x3d	; 61
   1179a:	be b7       	in	r27, 0x3e	; 62
   1179c:	12 96       	adiw	r26, 0x02	; 2
   1179e:	fc 92       	st	X, r15
   117a0:	ee 92       	st	-X, r14
   117a2:	11 97       	sbiw	r26, 0x01	; 1
   117a4:	8d ec       	ldi	r24, 0xCD	; 205
   117a6:	9f e1       	ldi	r25, 0x1F	; 31
   117a8:	93 83       	std	Z+3, r25	; 0x03
   117aa:	82 83       	std	Z+2, r24	; 0x02
   117ac:	8f e1       	ldi	r24, 0x1F	; 31
   117ae:	9c e0       	ldi	r25, 0x0C	; 12
   117b0:	95 83       	std	Z+5, r25	; 0x05
   117b2:	84 83       	std	Z+4, r24	; 0x04
   117b4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   117b8:	ed b7       	in	r30, 0x3d	; 61
   117ba:	fe b7       	in	r31, 0x3e	; 62
   117bc:	36 96       	adiw	r30, 0x06	; 6
   117be:	0f b6       	in	r0, 0x3f	; 63
   117c0:	f8 94       	cli
   117c2:	fe bf       	out	0x3e, r31	; 62
   117c4:	0f be       	out	0x3f, r0	; 63
   117c6:	ed bf       	out	0x3d, r30	; 61
   117c8:	81 e0       	ldi	r24, 0x01	; 1
   117ca:	6f e0       	ldi	r22, 0x0F	; 15
   117cc:	a7 01       	movw	r20, r14
   117ce:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
                RemSpaceLead(strCardID);
   117d2:	09 e8       	ldi	r16, 0x89	; 137
   117d4:	1b e0       	ldi	r17, 0x0B	; 11
   117d6:	c8 01       	movw	r24, r16
   117d8:	0e 94 a0 28 	call	0x5140	; 0x5140 <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   117dc:	00 d0       	rcall	.+0      	; 0x117de <FMenuLocalAccount+0x107a>
   117de:	00 d0       	rcall	.+0      	; 0x117e0 <FMenuLocalAccount+0x107c>
   117e0:	00 d0       	rcall	.+0      	; 0x117e2 <FMenuLocalAccount+0x107e>
   117e2:	ed b7       	in	r30, 0x3d	; 61
   117e4:	fe b7       	in	r31, 0x3e	; 62
   117e6:	31 96       	adiw	r30, 0x01	; 1
   117e8:	ad b7       	in	r26, 0x3d	; 61
   117ea:	be b7       	in	r27, 0x3e	; 62
   117ec:	12 96       	adiw	r26, 0x02	; 2
   117ee:	fc 92       	st	X, r15
   117f0:	ee 92       	st	-X, r14
   117f2:	11 97       	sbiw	r26, 0x01	; 1
   117f4:	86 ec       	ldi	r24, 0xC6	; 198
   117f6:	9f e1       	ldi	r25, 0x1F	; 31
   117f8:	93 83       	std	Z+3, r25	; 0x03
   117fa:	82 83       	std	Z+2, r24	; 0x02
   117fc:	15 83       	std	Z+5, r17	; 0x05
   117fe:	04 83       	std	Z+4, r16	; 0x04
   11800:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   11804:	ed b7       	in	r30, 0x3d	; 61
   11806:	fe b7       	in	r31, 0x3e	; 62
   11808:	36 96       	adiw	r30, 0x06	; 6
   1180a:	0f b6       	in	r0, 0x3f	; 63
   1180c:	f8 94       	cli
   1180e:	fe bf       	out	0x3e, r31	; 62
   11810:	0f be       	out	0x3f, r0	; 63
   11812:	ed bf       	out	0x3d, r30	; 61
   11814:	82 e0       	ldi	r24, 0x02	; 2
   11816:	61 e0       	ldi	r22, 0x01	; 1
   11818:	a7 01       	movw	r20, r14
   1181a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
				TimLocAcc=0;
   1181e:	10 92 ba 01 	sts	0x01BA, r1
		        IsCompleteFilling=False;
   11822:	10 92 a9 01 	sts	0x01A9, r1
				stLocalAccount=laWaitFilling;
   11826:	8d e1       	ldi	r24, 0x1D	; 29
   11828:	98 cd       	rjmp	.-1232   	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   1182a:	80 91 a9 01 	lds	r24, 0x01A9
   1182e:	81 30       	cpi	r24, 0x01	; 1
   11830:	29 f0       	breq	.+10     	; 0x1183c <FMenuLocalAccount+0x10d8>
   11832:	80 91 ba 01 	lds	r24, 0x01BA
   11836:	8b 30       	cpi	r24, 0x0B	; 11
   11838:	08 f4       	brcc	.+2      	; 0x1183c <FMenuLocalAccount+0x10d8>
   1183a:	47 c0       	rjmp	.+142    	; 0x118ca <FMenuLocalAccount+0x1166>
				    IsCompleteFilling=False;
   1183c:	10 92 a9 01 	sts	0x01A9, r1
				    stLocalAccount=laSuccessTransaction;
   11840:	89 e1       	ldi	r24, 0x19	; 25
   11842:	80 93 5b 01 	sts	0x015B, r24
					TimLocAcc=0;
   11846:	10 92 ba 01 	sts	0x01BA, r1
   1184a:	3f c0       	rjmp	.+126    	; 0x118ca <FMenuLocalAccount+0x1166>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   1184c:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
   11850:	82 e0       	ldi	r24, 0x02	; 2
   11852:	61 e0       	ldi	r22, 0x01	; 1
   11854:	44 eb       	ldi	r20, 0xB4	; 180
   11856:	5f e1       	ldi	r21, 0x1F	; 31
   11858:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   1185c:	00 d0       	rcall	.+0      	; 0x1185e <FMenuLocalAccount+0x10fa>
   1185e:	00 d0       	rcall	.+0      	; 0x11860 <FMenuLocalAccount+0x10fc>
   11860:	00 d0       	rcall	.+0      	; 0x11862 <FMenuLocalAccount+0x10fe>
   11862:	ed b7       	in	r30, 0x3d	; 61
   11864:	fe b7       	in	r31, 0x3e	; 62
   11866:	31 96       	adiw	r30, 0x01	; 1
   11868:	8e 01       	movw	r16, r28
   1186a:	04 5f       	subi	r16, 0xF4	; 244
   1186c:	1f 4f       	sbci	r17, 0xFF	; 255
   1186e:	ad b7       	in	r26, 0x3d	; 61
   11870:	be b7       	in	r27, 0x3e	; 62
   11872:	12 96       	adiw	r26, 0x02	; 2
   11874:	1c 93       	st	X, r17
   11876:	0e 93       	st	-X, r16
   11878:	11 97       	sbiw	r26, 0x01	; 1
   1187a:	83 ea       	ldi	r24, 0xA3	; 163
   1187c:	9f e1       	ldi	r25, 0x1F	; 31
   1187e:	93 83       	std	Z+3, r25	; 0x03
   11880:	82 83       	std	Z+2, r24	; 0x02
   11882:	80 91 88 02 	lds	r24, 0x0288
   11886:	84 83       	std	Z+4, r24	; 0x04
   11888:	15 82       	std	Z+5, r1	; 0x05
   1188a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				lcd_print(3,1,lcdteks);
   1188e:	ed b7       	in	r30, 0x3d	; 61
   11890:	fe b7       	in	r31, 0x3e	; 62
   11892:	36 96       	adiw	r30, 0x06	; 6
   11894:	0f b6       	in	r0, 0x3f	; 63
   11896:	f8 94       	cli
   11898:	fe bf       	out	0x3e, r31	; 62
   1189a:	0f be       	out	0x3f, r0	; 63
   1189c:	ed bf       	out	0x3d, r30	; 61
   1189e:	83 e0       	ldi	r24, 0x03	; 3
   118a0:	61 e0       	ldi	r22, 0x01	; 1
   118a2:	a8 01       	movw	r20, r16
   118a4:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   118a8:	10 92 ba 01 	sts	0x01BA, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   118ac:	8e e1       	ldi	r24, 0x1E	; 30
   118ae:	55 cd       	rjmp	.-1366   	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   118b0:	80 91 ba 01 	lds	r24, 0x01BA
   118b4:	80 31       	cpi	r24, 0x10	; 16
   118b6:	48 f0       	brcs	.+18     	; 0x118ca <FMenuLocalAccount+0x1166>
   118b8:	8f e1       	ldi	r24, 0x1F	; 31
   118ba:	4f cd       	rjmp	.-1378   	; 0x1135a <FMenuLocalAccount+0xbf6>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   118bc:	81 e0       	ldi	r24, 0x01	; 1
   118be:	80 93 5b 01 	sts	0x015B, r24
				lcd_clear();
   118c2:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
   118c6:	81 e0       	ldi	r24, 0x01	; 1
   118c8:	01 c0       	rjmp	.+2      	; 0x118cc <FMenuLocalAccount+0x1168>
   118ca:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   118cc:	e4 96       	adiw	r28, 0x34	; 52
   118ce:	0f b6       	in	r0, 0x3f	; 63
   118d0:	f8 94       	cli
   118d2:	de bf       	out	0x3e, r29	; 62
   118d4:	0f be       	out	0x3f, r0	; 63
   118d6:	cd bf       	out	0x3d, r28	; 61
   118d8:	cf 91       	pop	r28
   118da:	df 91       	pop	r29
   118dc:	1f 91       	pop	r17
   118de:	0f 91       	pop	r16
   118e0:	ff 90       	pop	r15
   118e2:	ef 90       	pop	r14
   118e4:	df 90       	pop	r13
   118e6:	cf 90       	pop	r12
   118e8:	bf 90       	pop	r11
   118ea:	af 90       	pop	r10
   118ec:	9f 90       	pop	r9
   118ee:	8f 90       	pop	r8
   118f0:	7f 90       	pop	r7
   118f2:	6f 90       	pop	r6
   118f4:	08 95       	ret

000118f6 <sendMessage32>:
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    uart_print(1, 0,strSend);
	sprintf_P(strSend,PSTR("F968CFFB"));
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
*/IFTSendMessage(MSG_32);
   118f6:	82 e3       	ldi	r24, 0x32	; 50
   118f8:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   118fc:	08 95       	ret

000118fe <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   118fe:	af 92       	push	r10
   11900:	bf 92       	push	r11
   11902:	cf 92       	push	r12
   11904:	df 92       	push	r13
   11906:	ef 92       	push	r14
   11908:	ff 92       	push	r15
   1190a:	0f 93       	push	r16
   1190c:	1f 93       	push	r17
   1190e:	df 93       	push	r29
   11910:	cf 93       	push	r28
   11912:	cd b7       	in	r28, 0x3d	; 61
   11914:	de b7       	in	r29, 0x3e	; 62
   11916:	a3 97       	sbiw	r28, 0x23	; 35
   11918:	0f b6       	in	r0, 0x3f	; 63
   1191a:	f8 94       	cli
   1191c:	de bf       	out	0x3e, r29	; 62
   1191e:	0f be       	out	0x3f, r0	; 63
   11920:	cd bf       	out	0x3d, r28	; 61
       char lcdteks[20],i,msgResult;       
	   char strBankName[11],strSurcharge[4],Result;
       char uiResult,KeyPressed=0,KeyChar,FIPResult;

     Result=MENU_NONE; 
	 switch(stChangeMOP){
   11922:	80 91 61 02 	lds	r24, 0x0261
   11926:	e8 2f       	mov	r30, r24
   11928:	f0 e0       	ldi	r31, 0x00	; 0
   1192a:	ee 31       	cpi	r30, 0x1E	; 30
   1192c:	f1 05       	cpc	r31, r1
   1192e:	08 f0       	brcs	.+2      	; 0x11932 <FMenuChangeMOP+0x34>
   11930:	0c c4       	rjmp	.+2072   	; 0x1214a <FMenuChangeMOP+0x84c>
   11932:	e1 55       	subi	r30, 0x51	; 81
   11934:	ff 4f       	sbci	r31, 0xFF	; 255
   11936:	ee 0f       	add	r30, r30
   11938:	ff 1f       	adc	r31, r31
   1193a:	05 90       	lpm	r0, Z+
   1193c:	f4 91       	lpm	r31, Z+
   1193e:	e0 2d       	mov	r30, r0
   11940:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   11942:	85 e0       	ldi	r24, 0x05	; 5
   11944:	80 93 b8 01 	sts	0x01B8, r24
   11948:	3c c1       	rjmp	.+632    	; 0x11bc2 <FMenuChangeMOP+0x2c4>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   1194a:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   1194e:	81 e0       	ldi	r24, 0x01	; 1
   11950:	61 e0       	ldi	r22, 0x01	; 1
   11952:	45 e0       	ldi	r20, 0x05	; 5
   11954:	5c e1       	ldi	r21, 0x1C	; 28
   11956:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   1195a:	82 e0       	ldi	r24, 0x02	; 2
   1195c:	61 e0       	ldi	r22, 0x01	; 1
   1195e:	40 ef       	ldi	r20, 0xF0	; 240
   11960:	5b e1       	ldi	r21, 0x1B	; 27
   11962:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   11966:	83 e0       	ldi	r24, 0x03	; 3
   11968:	61 e0       	ldi	r22, 0x01	; 1
   1196a:	4b ed       	ldi	r20, 0xDB	; 219
   1196c:	5b e1       	ldi	r21, 0x1B	; 27
   1196e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   11972:	84 e0       	ldi	r24, 0x04	; 4
   11974:	61 e0       	ldi	r22, 0x01	; 1
   11976:	46 ec       	ldi	r20, 0xC6	; 198
   11978:	5b e1       	ldi	r21, 0x1B	; 27
   1197a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   1197e:	82 e0       	ldi	r24, 0x02	; 2
   11980:	a2 c1       	rjmp	.+836    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   11982:	81 e0       	ldi	r24, 0x01	; 1
   11984:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   11988:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   1198a:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
   1198e:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   11990:	81 53       	subi	r24, 0x31	; 49
   11992:	84 30       	cpi	r24, 0x04	; 4
   11994:	f0 f4       	brcc	.+60     	; 0x119d2 <FMenuChangeMOP+0xd4>
              switch(KeyChar){
   11996:	92 33       	cpi	r25, 0x32	; 50
   11998:	61 f0       	breq	.+24     	; 0x119b2 <FMenuChangeMOP+0xb4>
   1199a:	93 33       	cpi	r25, 0x33	; 51
   1199c:	18 f4       	brcc	.+6      	; 0x119a4 <FMenuChangeMOP+0xa6>
   1199e:	91 33       	cpi	r25, 0x31	; 49
   119a0:	c1 f4       	brne	.+48     	; 0x119d2 <FMenuChangeMOP+0xd4>
   119a2:	05 c0       	rjmp	.+10     	; 0x119ae <FMenuChangeMOP+0xb0>
   119a4:	93 33       	cpi	r25, 0x33	; 51
   119a6:	51 f0       	breq	.+20     	; 0x119bc <FMenuChangeMOP+0xbe>
   119a8:	94 33       	cpi	r25, 0x34	; 52
   119aa:	99 f4       	brne	.+38     	; 0x119d2 <FMenuChangeMOP+0xd4>
   119ac:	0c c0       	rjmp	.+24     	; 0x119c6 <FMenuChangeMOP+0xc8>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   119ae:	81 e0       	ldi	r24, 0x01	; 1
   119b0:	0b c0       	rjmp	.+22     	; 0x119c8 <FMenuChangeMOP+0xca>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   119b2:	82 e0       	ldi	r24, 0x02	; 2
   119b4:	80 93 b8 01 	sts	0x01B8, r24
   119b8:	8b e0       	ldi	r24, 0x0B	; 11
   119ba:	09 c0       	rjmp	.+18     	; 0x119ce <FMenuChangeMOP+0xd0>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   119bc:	83 e0       	ldi	r24, 0x03	; 3
   119be:	80 93 b8 01 	sts	0x01B8, r24
   119c2:	8f e0       	ldi	r24, 0x0F	; 15
   119c4:	04 c0       	rjmp	.+8      	; 0x119ce <FMenuChangeMOP+0xd0>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   119c6:	84 e0       	ldi	r24, 0x04	; 4
   119c8:	80 93 b8 01 	sts	0x01B8, r24
   119cc:	89 e0       	ldi	r24, 0x09	; 9
   119ce:	80 93 61 02 	sts	0x0261, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   119d2:	17 3e       	cpi	r17, 0xE7	; 231
   119d4:	09 f0       	breq	.+2      	; 0x119d8 <FMenuChangeMOP+0xda>
   119d6:	b9 c3       	rjmp	.+1906   	; 0x1214a <FMenuChangeMOP+0x84c>
   119d8:	b0 c3       	rjmp	.+1888   	; 0x1213a <FMenuChangeMOP+0x83c>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   119da:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   119de:	81 e0       	ldi	r24, 0x01	; 1
   119e0:	61 e0       	ldi	r22, 0x01	; 1
   119e2:	49 eb       	ldi	r20, 0xB9	; 185
   119e4:	5b e1       	ldi	r21, 0x1B	; 27
   119e6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   119ea:	82 e0       	ldi	r24, 0x02	; 2
   119ec:	61 e0       	ldi	r22, 0x01	; 1
   119ee:	47 eb       	ldi	r20, 0xB7	; 183
   119f0:	5b e1       	ldi	r21, 0x1B	; 27
   119f2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   119f6:	84 e0       	ldi	r24, 0x04	; 4
   119f8:	61 e0       	ldi	r22, 0x01	; 1
   119fa:	42 ea       	ldi	r20, 0xA2	; 162
   119fc:	5b e1       	ldi	r21, 0x1B	; 27
   119fe:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
   11a02:	ec e3       	ldi	r30, 0x3C	; 60
   11a04:	fc e0       	ldi	r31, 0x0C	; 12
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11a06:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11a08:	8c e0       	ldi	r24, 0x0C	; 12
   11a0a:	e1 35       	cpi	r30, 0x51	; 81
   11a0c:	f8 07       	cpc	r31, r24
   11a0e:	d9 f7       	brne	.-10     	; 0x11a06 <FMenuChangeMOP+0x108>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;		  
   11a10:	87 e0       	ldi	r24, 0x07	; 7
   11a12:	59 c1       	rjmp	.+690    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   11a14:	81 e0       	ldi	r24, 0x01	; 1
   11a16:	62 e0       	ldi	r22, 0x02	; 2
   11a18:	41 e0       	ldi	r20, 0x01	; 1
   11a1a:	2c e3       	ldi	r18, 0x3C	; 60
   11a1c:	3c e0       	ldi	r19, 0x0C	; 12
   11a1e:	00 e0       	ldi	r16, 0x00	; 0
   11a20:	10 e0       	ldi	r17, 0x00	; 0
   11a22:	5d e0       	ldi	r21, 0x0D	; 13
   11a24:	e5 2e       	mov	r14, r21
   11a26:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
	      if (uiResult==USER_OK){
   11a2a:	83 30       	cpi	r24, 0x03	; 3
   11a2c:	11 f4       	brne	.+4      	; 0x11a32 <FMenuChangeMOP+0x134>
		     stChangeMOP=cmSelectFIP;
   11a2e:	89 e0       	ldi	r24, 0x09	; 9
   11a30:	4a c1       	rjmp	.+660    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   11a32:	81 30       	cpi	r24, 0x01	; 1
   11a34:	09 f4       	brne	.+2      	; 0x11a38 <FMenuChangeMOP+0x13a>
   11a36:	47 c1       	rjmp	.+654    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11a38:	84 30       	cpi	r24, 0x04	; 4
   11a3a:	21 f4       	brne	.+8      	; 0x11a44 <FMenuChangeMOP+0x146>
   11a3c:	61 e0       	ldi	r22, 0x01	; 1
   11a3e:	4d e8       	ldi	r20, 0x8D	; 141
   11a40:	5b e1       	ldi	r21, 0x1B	; 27
   11a42:	29 c1       	rjmp	.+594    	; 0x11c96 <FMenuChangeMOP+0x398>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11a44:	85 30       	cpi	r24, 0x05	; 5
   11a46:	09 f0       	breq	.+2      	; 0x11a4a <FMenuChangeMOP+0x14c>
   11a48:	80 c3       	rjmp	.+1792   	; 0x1214a <FMenuChangeMOP+0x84c>
   11a4a:	84 e0       	ldi	r24, 0x04	; 4
   11a4c:	61 e0       	ldi	r22, 0x01	; 1
   11a4e:	48 e7       	ldi	r20, 0x78	; 120
   11a50:	5b e1       	ldi	r21, 0x1B	; 27
   11a52:	21 c1       	rjmp	.+578    	; 0x11c96 <FMenuChangeMOP+0x398>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   11a54:	80 e6       	ldi	r24, 0x60	; 96
   11a56:	92 e0       	ldi	r25, 0x02	; 2
   11a58:	69 eb       	ldi	r22, 0xB9	; 185
   11a5a:	77 e0       	ldi	r23, 0x07	; 7
   11a5c:	0e 94 25 58 	call	0xb04a	; 0xb04a <menu_FIP>
		  if (FIPResult==FIP_DONE){
   11a60:	88 23       	and	r24, r24
   11a62:	11 f4       	brne	.+4      	; 0x11a68 <FMenuChangeMOP+0x16a>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   11a64:	8e e0       	ldi	r24, 0x0E	; 14
   11a66:	2f c1       	rjmp	.+606    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   11a68:	82 30       	cpi	r24, 0x02	; 2
   11a6a:	09 f0       	breq	.+2      	; 0x11a6e <FMenuChangeMOP+0x170>
   11a6c:	6e c3       	rjmp	.+1756   	; 0x1214a <FMenuChangeMOP+0x84c>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   11a6e:	80 91 b8 01 	lds	r24, 0x01B8
   11a72:	81 30       	cpi	r24, 0x01	; 1
   11a74:	09 f4       	brne	.+2      	; 0x11a78 <FMenuChangeMOP+0x17a>
   11a76:	27 c1       	rjmp	.+590    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   11a78:	82 30       	cpi	r24, 0x02	; 2
   11a7a:	09 f4       	brne	.+2      	; 0x11a7e <FMenuChangeMOP+0x180>
   11a7c:	fd c0       	rjmp	.+506    	; 0x11c78 <FMenuChangeMOP+0x37a>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   11a7e:	83 30       	cpi	r24, 0x03	; 3
   11a80:	11 f4       	brne	.+4      	; 0x11a86 <FMenuChangeMOP+0x188>
   11a82:	8f e0       	ldi	r24, 0x0F	; 15
   11a84:	20 c1       	rjmp	.+576    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   11a86:	84 30       	cpi	r24, 0x04	; 4
   11a88:	09 f4       	brne	.+2      	; 0x11a8c <FMenuChangeMOP+0x18e>
   11a8a:	9b c0       	rjmp	.+310    	; 0x11bc2 <FMenuChangeMOP+0x2c4>
   11a8c:	5e c3       	rjmp	.+1724   	; 0x1214a <FMenuChangeMOP+0x84c>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   11a8e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   11a92:	81 e0       	ldi	r24, 0x01	; 1
   11a94:	61 e0       	ldi	r22, 0x01	; 1
   11a96:	4c e6       	ldi	r20, 0x6C	; 108
   11a98:	5b e1       	ldi	r21, 0x1B	; 27
   11a9a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   11a9e:	10 92 5c 02 	sts	0x025C, r1
   11aa2:	10 92 5b 02 	sts	0x025B, r1
   11aa6:	8e 01       	movw	r16, r28
   11aa8:	0b 5f       	subi	r16, 0xFB	; 251
   11aaa:	1f 4f       	sbci	r17, 0xFF	; 255
   11aac:	9b e0       	ldi	r25, 0x0B	; 11
   11aae:	a9 2e       	mov	r10, r25
   11ab0:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   11ab2:	80 e1       	ldi	r24, 0x10	; 16
   11ab4:	e8 2e       	mov	r14, r24
   11ab6:	f1 2c       	mov	r15, r1
   11ab8:	ec 0e       	add	r14, r28
   11aba:	fd 1e       	adc	r15, r29
   11abc:	b6 e6       	ldi	r27, 0x66	; 102
   11abe:	cb 2e       	mov	r12, r27
   11ac0:	bb e1       	ldi	r27, 0x1B	; 27
   11ac2:	db 2e       	mov	r13, r27
   11ac4:	5d c0       	rjmp	.+186    	; 0x11b80 <FMenuChangeMOP+0x282>
   11ac6:	8a 9d       	mul	r24, r10
   11ac8:	b0 01       	movw	r22, r0
   11aca:	8b 9d       	mul	r24, r11
   11acc:	70 0d       	add	r23, r0
   11ace:	9a 9d       	mul	r25, r10
   11ad0:	70 0d       	add	r23, r0
   11ad2:	11 24       	eor	r1, r1
   11ad4:	67 5f       	subi	r22, 0xF7	; 247
   11ad6:	7e 4f       	sbci	r23, 0xFE	; 254
   11ad8:	c8 01       	movw	r24, r16
   11ada:	4b e0       	ldi	r20, 0x0B	; 11
   11adc:	50 e0       	ldi	r21, 0x00	; 0
   11ade:	22 ed       	ldi	r18, 0xD2	; 210
   11ae0:	33 e1       	ldi	r19, 0x13	; 19
   11ae2:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   11ae6:	e0 e0       	ldi	r30, 0x00	; 0
   11ae8:	f0 e0       	ldi	r31, 0x00	; 0
   11aea:	0b 30       	cpi	r16, 0x0B	; 11
   11aec:	11 05       	cpc	r17, r1
   11aee:	10 f4       	brcc	.+4      	; 0x11af4 <FMenuChangeMOP+0x1f6>
   11af0:	e1 e0       	ldi	r30, 0x01	; 1
   11af2:	f0 e0       	ldi	r31, 0x00	; 0
   11af4:	80 81       	ld	r24, Z
   11af6:	88 23       	and	r24, r24
   11af8:	d1 f1       	breq	.+116    	; 0x11b6e <FMenuChangeMOP+0x270>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   11afa:	ad b7       	in	r26, 0x3d	; 61
   11afc:	be b7       	in	r27, 0x3e	; 62
   11afe:	18 97       	sbiw	r26, 0x08	; 8
   11b00:	0f b6       	in	r0, 0x3f	; 63
   11b02:	f8 94       	cli
   11b04:	be bf       	out	0x3e, r27	; 62
   11b06:	0f be       	out	0x3f, r0	; 63
   11b08:	ad bf       	out	0x3d, r26	; 61
   11b0a:	ed b7       	in	r30, 0x3d	; 61
   11b0c:	fe b7       	in	r31, 0x3e	; 62
   11b0e:	31 96       	adiw	r30, 0x01	; 1
   11b10:	12 96       	adiw	r26, 0x02	; 2
   11b12:	fc 92       	st	X, r15
   11b14:	ee 92       	st	-X, r14
   11b16:	11 97       	sbiw	r26, 0x01	; 1
   11b18:	d3 82       	std	Z+3, r13	; 0x03
   11b1a:	c2 82       	std	Z+2, r12	; 0x02
   11b1c:	80 91 5b 02 	lds	r24, 0x025B
   11b20:	90 91 5c 02 	lds	r25, 0x025C
   11b24:	01 96       	adiw	r24, 0x01	; 1
   11b26:	95 83       	std	Z+5, r25	; 0x05
   11b28:	84 83       	std	Z+4, r24	; 0x04
   11b2a:	17 83       	std	Z+7, r17	; 0x07
   11b2c:	06 83       	std	Z+6, r16	; 0x06
   11b2e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   11b32:	20 91 5b 02 	lds	r18, 0x025B
   11b36:	30 91 5c 02 	lds	r19, 0x025C
   11b3a:	ed b7       	in	r30, 0x3d	; 61
   11b3c:	fe b7       	in	r31, 0x3e	; 62
   11b3e:	38 96       	adiw	r30, 0x08	; 8
   11b40:	0f b6       	in	r0, 0x3f	; 63
   11b42:	f8 94       	cli
   11b44:	fe bf       	out	0x3e, r31	; 62
   11b46:	0f be       	out	0x3f, r0	; 63
   11b48:	ed bf       	out	0x3d, r30	; 61
   11b4a:	82 2f       	mov	r24, r18
   11b4c:	81 70       	andi	r24, 0x01	; 1
   11b4e:	36 95       	lsr	r19
   11b50:	27 95       	ror	r18
   11b52:	b9 01       	movw	r22, r18
   11b54:	66 0f       	add	r22, r22
   11b56:	77 1f       	adc	r23, r23
   11b58:	62 0f       	add	r22, r18
   11b5a:	73 1f       	adc	r23, r19
   11b5c:	66 0f       	add	r22, r22
   11b5e:	77 1f       	adc	r23, r23
   11b60:	66 0f       	add	r22, r22
   11b62:	77 1f       	adc	r23, r23
   11b64:	6f 5f       	subi	r22, 0xFF	; 255
   11b66:	8e 5f       	subi	r24, 0xFE	; 254
   11b68:	a7 01       	movw	r20, r14
   11b6a:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   11b6e:	80 91 5b 02 	lds	r24, 0x025B
   11b72:	90 91 5c 02 	lds	r25, 0x025C
   11b76:	01 96       	adiw	r24, 0x01	; 1
   11b78:	90 93 5c 02 	sts	0x025C, r25
   11b7c:	80 93 5b 02 	sts	0x025B, r24
   11b80:	80 91 5b 02 	lds	r24, 0x025B
   11b84:	90 91 5c 02 	lds	r25, 0x025C
   11b88:	84 30       	cpi	r24, 0x04	; 4
   11b8a:	91 05       	cpc	r25, r1
   11b8c:	08 f4       	brcc	.+2      	; 0x11b90 <FMenuChangeMOP+0x292>
   11b8e:	9b cf       	rjmp	.-202    	; 0x11ac6 <FMenuChangeMOP+0x1c8>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   11b90:	84 e0       	ldi	r24, 0x04	; 4
   11b92:	61 e0       	ldi	r22, 0x01	; 1
   11b94:	4e e5       	ldi	r20, 0x5E	; 94
   11b96:	5b e1       	ldi	r21, 0x1B	; 27
   11b98:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   11b9c:	8c e0       	ldi	r24, 0x0C	; 12
   11b9e:	93 c0       	rjmp	.+294    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   11ba0:	81 e0       	ldi	r24, 0x01	; 1
   11ba2:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   11ba6:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   11ba8:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
          if ((KeyChar>='1')&&(KeyChar<='4')){
   11bac:	81 53       	subi	r24, 0x31	; 49
   11bae:	84 30       	cpi	r24, 0x04	; 4
   11bb0:	28 f4       	brcc	.+10     	; 0x11bbc <FMenuChangeMOP+0x2be>
		      BankIdx=KeyChar-'1';
   11bb2:	80 93 5f 02 	sts	0x025F, r24
			  stChangeMOP=cmSelectFIP;
   11bb6:	89 e0       	ldi	r24, 0x09	; 9
   11bb8:	80 93 61 02 	sts	0x0261, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   11bbc:	17 3e       	cpi	r17, 0xE7	; 231
   11bbe:	09 f0       	breq	.+2      	; 0x11bc2 <FMenuChangeMOP+0x2c4>
   11bc0:	c4 c2       	rjmp	.+1416   	; 0x1214a <FMenuChangeMOP+0x84c>
   11bc2:	81 e0       	ldi	r24, 0x01	; 1
   11bc4:	80 c0       	rjmp	.+256    	; 0x11cc6 <FMenuChangeMOP+0x3c8>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   11bc6:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
   11bca:	65 e0       	ldi	r22, 0x05	; 5
   11bcc:	e6 2e       	mov	r14, r22
   11bce:	f1 2c       	mov	r15, r1
   11bd0:	ec 0e       	add	r14, r28
   11bd2:	fd 1e       	adc	r15, r29
   11bd4:	60 91 5f 02 	lds	r22, 0x025F
   11bd8:	8b e0       	ldi	r24, 0x0B	; 11
   11bda:	68 9f       	mul	r22, r24
   11bdc:	b0 01       	movw	r22, r0
   11bde:	11 24       	eor	r1, r1
   11be0:	67 5f       	subi	r22, 0xF7	; 247
   11be2:	7e 4f       	sbci	r23, 0xFE	; 254
   11be4:	c7 01       	movw	r24, r14
   11be6:	4b e0       	ldi	r20, 0x0B	; 11
   11be8:	50 e0       	ldi	r21, 0x00	; 0
   11bea:	22 ed       	ldi	r18, 0xD2	; 210
   11bec:	33 e1       	ldi	r19, 0x13	; 19
   11bee:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   11bf2:	00 d0       	rcall	.+0      	; 0x11bf4 <FMenuChangeMOP+0x2f6>
   11bf4:	00 d0       	rcall	.+0      	; 0x11bf6 <FMenuChangeMOP+0x2f8>
   11bf6:	00 d0       	rcall	.+0      	; 0x11bf8 <FMenuChangeMOP+0x2fa>
   11bf8:	ed b7       	in	r30, 0x3d	; 61
   11bfa:	fe b7       	in	r31, 0x3e	; 62
   11bfc:	31 96       	adiw	r30, 0x01	; 1
   11bfe:	8e 01       	movw	r16, r28
   11c00:	00 5f       	subi	r16, 0xF0	; 240
   11c02:	1f 4f       	sbci	r17, 0xFF	; 255
   11c04:	ad b7       	in	r26, 0x3d	; 61
   11c06:	be b7       	in	r27, 0x3e	; 62
   11c08:	12 96       	adiw	r26, 0x02	; 2
   11c0a:	1c 93       	st	X, r17
   11c0c:	0e 93       	st	-X, r16
   11c0e:	11 97       	sbiw	r26, 0x01	; 1
   11c10:	8b e5       	ldi	r24, 0x5B	; 91
   11c12:	9b e1       	ldi	r25, 0x1B	; 27
   11c14:	93 83       	std	Z+3, r25	; 0x03
   11c16:	82 83       	std	Z+2, r24	; 0x02
   11c18:	f5 82       	std	Z+5, r15	; 0x05
   11c1a:	e4 82       	std	Z+4, r14	; 0x04
   11c1c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(1,1,lcdteks);
   11c20:	ed b7       	in	r30, 0x3d	; 61
   11c22:	fe b7       	in	r31, 0x3e	; 62
   11c24:	36 96       	adiw	r30, 0x06	; 6
   11c26:	0f b6       	in	r0, 0x3f	; 63
   11c28:	f8 94       	cli
   11c2a:	fe bf       	out	0x3e, r31	; 62
   11c2c:	0f be       	out	0x3f, r0	; 63
   11c2e:	ed bf       	out	0x3d, r30	; 61
   11c30:	81 e0       	ldi	r24, 0x01	; 1
   11c32:	61 e0       	ldi	r22, 0x01	; 1
   11c34:	a8 01       	movw	r20, r16
   11c36:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   11c3a:	82 e0       	ldi	r24, 0x02	; 2
   11c3c:	61 e0       	ldi	r22, 0x01	; 1
   11c3e:	4b e4       	ldi	r20, 0x4B	; 75
   11c40:	5b e1       	ldi	r21, 0x1B	; 27
   11c42:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11c46:	84 e0       	ldi	r24, 0x04	; 4
   11c48:	61 e0       	ldi	r22, 0x01	; 1
   11c4a:	46 e3       	ldi	r20, 0x36	; 54
   11c4c:	5b e1       	ldi	r21, 0x1B	; 27
   11c4e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   11c52:	8d e0       	ldi	r24, 0x0D	; 13
   11c54:	38 c0       	rjmp	.+112    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
	 case cmInputBankSurcharge:
	      //uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
		  uiResult=UserInput(UI_NUMBER_L,2,14,strSurcharge,100,3);
   11c56:	82 e0       	ldi	r24, 0x02	; 2
   11c58:	62 e0       	ldi	r22, 0x02	; 2
   11c5a:	4e e0       	ldi	r20, 0x0E	; 14
   11c5c:	9e 01       	movw	r18, r28
   11c5e:	2f 5f       	subi	r18, 0xFF	; 255
   11c60:	3f 4f       	sbci	r19, 0xFF	; 255
   11c62:	04 e6       	ldi	r16, 0x64	; 100
   11c64:	10 e0       	ldi	r17, 0x00	; 0
   11c66:	53 e0       	ldi	r21, 0x03	; 3
   11c68:	e5 2e       	mov	r14, r21
   11c6a:	0e 94 15 6b 	call	0xd62a	; 0xd62a <UserInput>
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   11c6e:	83 30       	cpi	r24, 0x03	; 3
   11c70:	09 f4       	brne	.+2      	; 0x11c74 <FMenuChangeMOP+0x376>
   11c72:	c6 c0       	rjmp	.+396    	; 0x11e00 <FMenuChangeMOP+0x502>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   11c74:	81 30       	cpi	r24, 0x01	; 1
   11c76:	11 f4       	brne	.+4      	; 0x11c7c <FMenuChangeMOP+0x37e>
   11c78:	8b e0       	ldi	r24, 0x0B	; 11
   11c7a:	25 c0       	rjmp	.+74     	; 0x11cc6 <FMenuChangeMOP+0x3c8>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11c7c:	84 30       	cpi	r24, 0x04	; 4
   11c7e:	21 f4       	brne	.+8      	; 0x11c88 <FMenuChangeMOP+0x38a>
   11c80:	61 e0       	ldi	r22, 0x01	; 1
   11c82:	41 e2       	ldi	r20, 0x21	; 33
   11c84:	5b e1       	ldi	r21, 0x1B	; 27
   11c86:	07 c0       	rjmp	.+14     	; 0x11c96 <FMenuChangeMOP+0x398>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11c88:	85 30       	cpi	r24, 0x05	; 5
   11c8a:	09 f0       	breq	.+2      	; 0x11c8e <FMenuChangeMOP+0x390>
   11c8c:	5e c2       	rjmp	.+1212   	; 0x1214a <FMenuChangeMOP+0x84c>
   11c8e:	84 e0       	ldi	r24, 0x04	; 4
   11c90:	61 e0       	ldi	r22, 0x01	; 1
   11c92:	4c e0       	ldi	r20, 0x0C	; 12
   11c94:	5b e1       	ldi	r21, 0x1B	; 27
   11c96:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
   11c9a:	57 c2       	rjmp	.+1198   	; 0x1214a <FMenuChangeMOP+0x84c>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   11c9c:	80 91 b8 01 	lds	r24, 0x01B8
   11ca0:	82 30       	cpi	r24, 0x02	; 2
   11ca2:	61 f0       	breq	.+24     	; 0x11cbc <FMenuChangeMOP+0x3be>
   11ca4:	83 30       	cpi	r24, 0x03	; 3
   11ca6:	20 f4       	brcc	.+8      	; 0x11cb0 <FMenuChangeMOP+0x3b2>
   11ca8:	81 30       	cpi	r24, 0x01	; 1
   11caa:	09 f0       	breq	.+2      	; 0x11cae <FMenuChangeMOP+0x3b0>
   11cac:	4e c2       	rjmp	.+1180   	; 0x1214a <FMenuChangeMOP+0x84c>
   11cae:	0a c0       	rjmp	.+20     	; 0x11cc4 <FMenuChangeMOP+0x3c6>
   11cb0:	83 30       	cpi	r24, 0x03	; 3
   11cb2:	31 f0       	breq	.+12     	; 0x11cc0 <FMenuChangeMOP+0x3c2>
   11cb4:	84 30       	cpi	r24, 0x04	; 4
   11cb6:	09 f0       	breq	.+2      	; 0x11cba <FMenuChangeMOP+0x3bc>
   11cb8:	48 c2       	rjmp	.+1168   	; 0x1214a <FMenuChangeMOP+0x84c>
   11cba:	04 c0       	rjmp	.+8      	; 0x11cc4 <FMenuChangeMOP+0x3c6>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   11cbc:	81 e1       	ldi	r24, 0x11	; 17
   11cbe:	03 c0       	rjmp	.+6      	; 0x11cc6 <FMenuChangeMOP+0x3c8>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   11cc0:	85 e1       	ldi	r24, 0x15	; 21
   11cc2:	01 c0       	rjmp	.+2      	; 0x11cc6 <FMenuChangeMOP+0x3c8>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   11cc4:	82 e1       	ldi	r24, 0x12	; 18
   11cc6:	80 93 61 02 	sts	0x0261, r24
   11cca:	3f c2       	rjmp	.+1150   	; 0x1214a <FMenuChangeMOP+0x84c>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   11ccc:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   11cd0:	81 e0       	ldi	r24, 0x01	; 1
   11cd2:	61 e0       	ldi	r22, 0x01	; 1
   11cd4:	4d ef       	ldi	r20, 0xFD	; 253
   11cd6:	5a e1       	ldi	r21, 0x1A	; 26
   11cd8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   11cdc:	00 d0       	rcall	.+0      	; 0x11cde <FMenuChangeMOP+0x3e0>
   11cde:	00 d0       	rcall	.+0      	; 0x11ce0 <FMenuChangeMOP+0x3e2>
   11ce0:	00 d0       	rcall	.+0      	; 0x11ce2 <FMenuChangeMOP+0x3e4>
   11ce2:	ed b7       	in	r30, 0x3d	; 61
   11ce4:	fe b7       	in	r31, 0x3e	; 62
   11ce6:	31 96       	adiw	r30, 0x01	; 1
   11ce8:	8e 01       	movw	r16, r28
   11cea:	00 5f       	subi	r16, 0xF0	; 240
   11cec:	1f 4f       	sbci	r17, 0xFF	; 255
   11cee:	ad b7       	in	r26, 0x3d	; 61
   11cf0:	be b7       	in	r27, 0x3e	; 62
   11cf2:	12 96       	adiw	r26, 0x02	; 2
   11cf4:	1c 93       	st	X, r17
   11cf6:	0e 93       	st	-X, r16
   11cf8:	11 97       	sbiw	r26, 0x01	; 1
   11cfa:	87 ef       	ldi	r24, 0xF7	; 247
   11cfc:	9a e1       	ldi	r25, 0x1A	; 26
   11cfe:	93 83       	std	Z+3, r25	; 0x03
   11d00:	82 83       	std	Z+2, r24	; 0x02
   11d02:	89 eb       	ldi	r24, 0xB9	; 185
   11d04:	97 e0       	ldi	r25, 0x07	; 7
   11d06:	95 83       	std	Z+5, r25	; 0x05
   11d08:	84 83       	std	Z+4, r24	; 0x04
   11d0a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(2,1,lcdteks);
   11d0e:	ed b7       	in	r30, 0x3d	; 61
   11d10:	fe b7       	in	r31, 0x3e	; 62
   11d12:	36 96       	adiw	r30, 0x06	; 6
   11d14:	0f b6       	in	r0, 0x3f	; 63
   11d16:	f8 94       	cli
   11d18:	fe bf       	out	0x3e, r31	; 62
   11d1a:	0f be       	out	0x3f, r0	; 63
   11d1c:	ed bf       	out	0x3d, r30	; 61
   11d1e:	82 e0       	ldi	r24, 0x02	; 2
   11d20:	61 e0       	ldi	r22, 0x01	; 1
   11d22:	a8 01       	movw	r20, r16
   11d24:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   11d28:	84 e0       	ldi	r24, 0x04	; 4
   11d2a:	61 e0       	ldi	r22, 0x01	; 1
   11d2c:	44 ee       	ldi	r20, 0xE4	; 228
   11d2e:	5a e1       	ldi	r21, 0x1A	; 26
   11d30:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  IsRFIDDetected=False;
   11d34:	10 92 98 01 	sts	0x0198, r1
          stChangeMOP=cmRFIDCardInput;
   11d38:	83 e1       	ldi	r24, 0x13	; 19
   11d3a:	c5 cf       	rjmp	.-118    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   11d3c:	81 e0       	ldi	r24, 0x01	; 1
   11d3e:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   11d42:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   11d44:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  if (KeyPressed==_KEY_ENTER){
   11d48:	17 3b       	cpi	r17, 0xB7	; 183
   11d4a:	11 f4       	brne	.+4      	; 0x11d50 <FMenuChangeMOP+0x452>
		      stChangeMOP=cmExitChangeMOP;
   11d4c:	8c e1       	ldi	r24, 0x1C	; 28
   11d4e:	03 c0       	rjmp	.+6      	; 0x11d56 <FMenuChangeMOP+0x458>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   11d50:	17 3e       	cpi	r17, 0xE7	; 231
   11d52:	19 f4       	brne	.+6      	; 0x11d5a <FMenuChangeMOP+0x45c>
   		      stChangeMOP=cmSelectFIP;
   11d54:	89 e0       	ldi	r24, 0x09	; 9
   11d56:	80 93 61 02 	sts	0x0261, r24
			 }
          if (IsRFIDDetected==True){
   11d5a:	80 91 98 01 	lds	r24, 0x0198
   11d5e:	81 30       	cpi	r24, 0x01	; 1
   11d60:	09 f0       	breq	.+2      	; 0x11d64 <FMenuChangeMOP+0x466>
   11d62:	f3 c1       	rjmp	.+998    	; 0x1214a <FMenuChangeMOP+0x84c>
		      IsRFIDDetected=False;
   11d64:	10 92 98 01 	sts	0x0198, r1
			   stChangeMOP=cmProsesRFID;
   11d68:	84 e1       	ldi	r24, 0x14	; 20
   11d6a:	ad cf       	rjmp	.-166    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
   11d6c:	20 e0       	ldi	r18, 0x00	; 0
   11d6e:	30 e0       	ldi	r19, 0x00	; 0


void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   11d70:	f9 01       	movw	r30, r18
   11d72:	e7 57       	subi	r30, 0x77	; 119
   11d74:	f4 4f       	sbci	r31, 0xF4	; 244
   11d76:	d9 01       	movw	r26, r18
   11d78:	af 5a       	subi	r26, 0xAF	; 175
   11d7a:	b3 4f       	sbci	r27, 0xF3	; 243
   11d7c:	8c 91       	ld	r24, X
   11d7e:	80 83       	st	Z, r24
   11d80:	2f 5f       	subi	r18, 0xFF	; 255
   11d82:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   11d84:	28 30       	cpi	r18, 0x08	; 8
   11d86:	31 05       	cpc	r19, r1
   11d88:	99 f7       	brne	.-26     	; 0x11d70 <FMenuChangeMOP+0x472>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   11d8a:	10 92 91 0b 	sts	0x0B91, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   11d8e:	00 d0       	rcall	.+0      	; 0x11d90 <FMenuChangeMOP+0x492>
   11d90:	00 d0       	rcall	.+0      	; 0x11d92 <FMenuChangeMOP+0x494>
   11d92:	00 d0       	rcall	.+0      	; 0x11d94 <FMenuChangeMOP+0x496>
   11d94:	ed b7       	in	r30, 0x3d	; 61
   11d96:	fe b7       	in	r31, 0x3e	; 62
   11d98:	31 96       	adiw	r30, 0x01	; 1
   11d9a:	8e 01       	movw	r16, r28
   11d9c:	00 5f       	subi	r16, 0xF0	; 240
   11d9e:	1f 4f       	sbci	r17, 0xFF	; 255
   11da0:	ad b7       	in	r26, 0x3d	; 61
   11da2:	be b7       	in	r27, 0x3e	; 62
   11da4:	12 96       	adiw	r26, 0x02	; 2
   11da6:	1c 93       	st	X, r17
   11da8:	0e 93       	st	-X, r16
   11daa:	11 97       	sbiw	r26, 0x01	; 1
   11dac:	8e ed       	ldi	r24, 0xDE	; 222
   11dae:	9a e1       	ldi	r25, 0x1A	; 26
   11db0:	93 83       	std	Z+3, r25	; 0x03
   11db2:	82 83       	std	Z+2, r24	; 0x02
   11db4:	89 e8       	ldi	r24, 0x89	; 137
   11db6:	9b e0       	ldi	r25, 0x0B	; 11
   11db8:	95 83       	std	Z+5, r25	; 0x05
   11dba:	84 83       	std	Z+4, r24	; 0x04
   11dbc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   11dc0:	ed b7       	in	r30, 0x3d	; 61
   11dc2:	fe b7       	in	r31, 0x3e	; 62
   11dc4:	36 96       	adiw	r30, 0x06	; 6
   11dc6:	0f b6       	in	r0, 0x3f	; 63
   11dc8:	f8 94       	cli
   11dca:	fe bf       	out	0x3e, r31	; 62
   11dcc:	0f be       	out	0x3f, r0	; 63
   11dce:	ed bf       	out	0x3d, r30	; 61
   11dd0:	82 e0       	ldi	r24, 0x02	; 2
   11dd2:	61 e0       	ldi	r22, 0x01	; 1
   11dd4:	a8 01       	movw	r20, r16
   11dd6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   11dda:	83 e0       	ldi	r24, 0x03	; 3
   11ddc:	61 e0       	ldi	r22, 0x01	; 1
   11dde:	47 ed       	ldi	r20, 0xD7	; 215
   11de0:	5a e1       	ldi	r21, 0x1A	; 26
   11de2:	0c c0       	rjmp	.+24     	; 0x11dfc <FMenuChangeMOP+0x4fe>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   11de4:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   11de8:	81 e0       	ldi	r24, 0x01	; 1
   11dea:	61 e0       	ldi	r22, 0x01	; 1
   11dec:	49 ec       	ldi	r20, 0xC9	; 201
   11dee:	5a e1       	ldi	r21, 0x1A	; 26
   11df0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   11df4:	83 e0       	ldi	r24, 0x03	; 3
   11df6:	61 e0       	ldi	r22, 0x01	; 1
   11df8:	42 ec       	ldi	r20, 0xC2	; 194
   11dfa:	5a e1       	ldi	r21, 0x1A	; 26
   11dfc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stChangeMOP=cmGenerateData;
   11e00:	86 e1       	ldi	r24, 0x16	; 22
   11e02:	61 cf       	rjmp	.-318    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
   11e04:	ee e8       	ldi	r30, 0x8E	; 142
   11e06:	fc e0       	ldi	r31, 0x0C	; 12
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11e08:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11e0a:	8c e0       	ldi	r24, 0x0C	; 12
   11e0c:	e3 3a       	cpi	r30, 0xA3	; 163
   11e0e:	f8 07       	cpc	r31, r24
   11e10:	d9 f7       	brne	.-10     	; 0x11e08 <FMenuChangeMOP+0x50a>
   11e12:	ee e9       	ldi	r30, 0x9E	; 158
   11e14:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
   11e16:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11e18:	9b e0       	ldi	r25, 0x0B	; 11
   11e1a:	e3 3b       	cpi	r30, 0xB3	; 179
   11e1c:	f9 07       	cpc	r31, r25
   11e1e:	d9 f7       	brne	.-10     	; 0x11e16 <FMenuChangeMOP+0x518>
   11e20:	ed e7       	ldi	r30, 0x7D	; 125
   11e22:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
   11e24:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11e26:	a8 e0       	ldi	r26, 0x08	; 8
   11e28:	e2 39       	cpi	r30, 0x92	; 146
   11e2a:	fa 07       	cpc	r31, r26
   11e2c:	d9 f7       	brne	.-10     	; 0x11e24 <FMenuChangeMOP+0x526>
   11e2e:	95 ea       	ldi	r25, 0xA5	; 165
   11e30:	e9 2e       	mov	r14, r25
   11e32:	93 e0       	ldi	r25, 0x03	; 3
   11e34:	f9 2e       	mov	r15, r25
	     strMemory[i]=data;
   11e36:	f7 01       	movw	r30, r14
   11e38:	11 92       	st	Z+, r1
   11e3a:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11e3c:	fa eb       	ldi	r31, 0xBA	; 186
   11e3e:	ef 16       	cp	r14, r31
   11e40:	f3 e0       	ldi	r31, 0x03	; 3
   11e42:	ff 06       	cpc	r15, r31
   11e44:	c1 f7       	brne	.-16     	; 0x11e36 <FMenuChangeMOP+0x538>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   11e46:	80 91 b8 01 	lds	r24, 0x01B8
   11e4a:	82 30       	cpi	r24, 0x02	; 2
   11e4c:	f1 f0       	breq	.+60     	; 0x11e8a <FMenuChangeMOP+0x58c>
   11e4e:	83 30       	cpi	r24, 0x03	; 3
   11e50:	20 f4       	brcc	.+8      	; 0x11e5a <FMenuChangeMOP+0x55c>
   11e52:	81 30       	cpi	r24, 0x01	; 1
   11e54:	09 f0       	breq	.+2      	; 0x11e58 <FMenuChangeMOP+0x55a>
   11e56:	ad c0       	rjmp	.+346    	; 0x11fb2 <FMenuChangeMOP+0x6b4>
   11e58:	07 c0       	rjmp	.+14     	; 0x11e68 <FMenuChangeMOP+0x56a>
   11e5a:	83 30       	cpi	r24, 0x03	; 3
   11e5c:	09 f4       	brne	.+2      	; 0x11e60 <FMenuChangeMOP+0x562>
   11e5e:	64 c0       	rjmp	.+200    	; 0x11f28 <FMenuChangeMOP+0x62a>
   11e60:	84 30       	cpi	r24, 0x04	; 4
   11e62:	09 f0       	breq	.+2      	; 0x11e66 <FMenuChangeMOP+0x568>
   11e64:	a6 c0       	rjmp	.+332    	; 0x11fb2 <FMenuChangeMOP+0x6b4>
   11e66:	75 c0       	rjmp	.+234    	; 0x11f52 <FMenuChangeMOP+0x654>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   11e68:	00 d0       	rcall	.+0      	; 0x11e6a <FMenuChangeMOP+0x56c>
   11e6a:	00 d0       	rcall	.+0      	; 0x11e6c <FMenuChangeMOP+0x56e>
   11e6c:	00 d0       	rcall	.+0      	; 0x11e6e <FMenuChangeMOP+0x570>
   11e6e:	ed b7       	in	r30, 0x3d	; 61
   11e70:	fe b7       	in	r31, 0x3e	; 62
   11e72:	31 96       	adiw	r30, 0x01	; 1
   11e74:	8e e8       	ldi	r24, 0x8E	; 142
   11e76:	9c e0       	ldi	r25, 0x0C	; 12
   11e78:	ad b7       	in	r26, 0x3d	; 61
   11e7a:	be b7       	in	r27, 0x3e	; 62
   11e7c:	12 96       	adiw	r26, 0x02	; 2
   11e7e:	9c 93       	st	X, r25
   11e80:	8e 93       	st	-X, r24
   11e82:	11 97       	sbiw	r26, 0x01	; 1
   11e84:	8f eb       	ldi	r24, 0xBF	; 191
   11e86:	9a e1       	ldi	r25, 0x1A	; 26
   11e88:	84 c0       	rjmp	.+264    	; 0x11f92 <FMenuChangeMOP+0x694>
   11e8a:	8e 01       	movw	r16, r28
   11e8c:	0b 5f       	subi	r16, 0xFB	; 251
   11e8e:	1f 4f       	sbci	r17, 0xFF	; 255
   11e90:	60 91 5f 02 	lds	r22, 0x025F
   11e94:	8b e0       	ldi	r24, 0x0B	; 11
   11e96:	68 9f       	mul	r22, r24
   11e98:	b0 01       	movw	r22, r0
   11e9a:	11 24       	eor	r1, r1
   11e9c:	67 5f       	subi	r22, 0xF7	; 247
   11e9e:	7e 4f       	sbci	r23, 0xFE	; 254
   11ea0:	c8 01       	movw	r24, r16
   11ea2:	4b e0       	ldi	r20, 0x0B	; 11
   11ea4:	50 e0       	ldi	r21, 0x00	; 0
   11ea6:	22 ed       	ldi	r18, 0xD2	; 210
   11ea8:	33 e1       	ldi	r19, 0x13	; 19
   11eaa:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   11eae:	00 d0       	rcall	.+0      	; 0x11eb0 <FMenuChangeMOP+0x5b2>
   11eb0:	00 d0       	rcall	.+0      	; 0x11eb2 <FMenuChangeMOP+0x5b4>
   11eb2:	00 d0       	rcall	.+0      	; 0x11eb4 <FMenuChangeMOP+0x5b6>
   11eb4:	ed b7       	in	r30, 0x3d	; 61
   11eb6:	fe b7       	in	r31, 0x3e	; 62
   11eb8:	31 96       	adiw	r30, 0x01	; 1
   11eba:	ce 01       	movw	r24, r28
   11ebc:	40 96       	adiw	r24, 0x10	; 16
   11ebe:	ad b7       	in	r26, 0x3d	; 61
   11ec0:	be b7       	in	r27, 0x3e	; 62
   11ec2:	12 96       	adiw	r26, 0x02	; 2
   11ec4:	9c 93       	st	X, r25
   11ec6:	8e 93       	st	-X, r24
   11ec8:	11 97       	sbiw	r26, 0x01	; 1
   11eca:	8c eb       	ldi	r24, 0xBC	; 188
   11ecc:	9a e1       	ldi	r25, 0x1A	; 26
   11ece:	93 83       	std	Z+3, r25	; 0x03
   11ed0:	82 83       	std	Z+2, r24	; 0x02
   11ed2:	15 83       	std	Z+5, r17	; 0x05
   11ed4:	04 83       	std	Z+4, r16	; 0x04
   11ed6:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   11eda:	ed b7       	in	r30, 0x3d	; 61
   11edc:	fe b7       	in	r31, 0x3e	; 62
   11ede:	31 96       	adiw	r30, 0x01	; 1
   11ee0:	8e e8       	ldi	r24, 0x8E	; 142
   11ee2:	9c e0       	ldi	r25, 0x0C	; 12
   11ee4:	ad b7       	in	r26, 0x3d	; 61
   11ee6:	be b7       	in	r27, 0x3e	; 62
   11ee8:	12 96       	adiw	r26, 0x02	; 2
   11eea:	9c 93       	st	X, r25
   11eec:	8e 93       	st	-X, r24
   11eee:	11 97       	sbiw	r26, 0x01	; 1
   11ef0:	89 eb       	ldi	r24, 0xB9	; 185
   11ef2:	9a e1       	ldi	r25, 0x1A	; 26
   11ef4:	93 83       	std	Z+3, r25	; 0x03
   11ef6:	82 83       	std	Z+2, r24	; 0x02
   11ef8:	15 83       	std	Z+5, r17	; 0x05
   11efa:	04 83       	std	Z+4, r16	; 0x04
   11efc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   11f00:	ed b7       	in	r30, 0x3d	; 61
   11f02:	fe b7       	in	r31, 0x3e	; 62
   11f04:	31 96       	adiw	r30, 0x01	; 1
   11f06:	8b ee       	ldi	r24, 0xEB	; 235
   11f08:	9f ef       	ldi	r25, 0xFF	; 255
   11f0a:	e8 0e       	add	r14, r24
   11f0c:	f9 1e       	adc	r15, r25
   11f0e:	ad b7       	in	r26, 0x3d	; 61
   11f10:	be b7       	in	r27, 0x3e	; 62
   11f12:	12 96       	adiw	r26, 0x02	; 2
   11f14:	fc 92       	st	X, r15
   11f16:	ee 92       	st	-X, r14
   11f18:	11 97       	sbiw	r26, 0x01	; 1
   11f1a:	86 eb       	ldi	r24, 0xB6	; 182
   11f1c:	9a e1       	ldi	r25, 0x1A	; 26
   11f1e:	93 83       	std	Z+3, r25	; 0x03
   11f20:	82 83       	std	Z+2, r24	; 0x02
   11f22:	ce 01       	movw	r24, r28
   11f24:	01 96       	adiw	r24, 0x01	; 1
   11f26:	39 c0       	rjmp	.+114    	; 0x11f9a <FMenuChangeMOP+0x69c>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   11f28:	00 d0       	rcall	.+0      	; 0x11f2a <FMenuChangeMOP+0x62c>
   11f2a:	00 d0       	rcall	.+0      	; 0x11f2c <FMenuChangeMOP+0x62e>
   11f2c:	00 d0       	rcall	.+0      	; 0x11f2e <FMenuChangeMOP+0x630>
   11f2e:	ed b7       	in	r30, 0x3d	; 61
   11f30:	fe b7       	in	r31, 0x3e	; 62
   11f32:	31 96       	adiw	r30, 0x01	; 1
   11f34:	8e e8       	ldi	r24, 0x8E	; 142
   11f36:	9c e0       	ldi	r25, 0x0C	; 12
   11f38:	ad b7       	in	r26, 0x3d	; 61
   11f3a:	be b7       	in	r27, 0x3e	; 62
   11f3c:	12 96       	adiw	r26, 0x02	; 2
   11f3e:	9c 93       	st	X, r25
   11f40:	8e 93       	st	-X, r24
   11f42:	11 97       	sbiw	r26, 0x01	; 1
   11f44:	83 eb       	ldi	r24, 0xB3	; 179
   11f46:	9a e1       	ldi	r25, 0x1A	; 26
   11f48:	93 83       	std	Z+3, r25	; 0x03
   11f4a:	82 83       	std	Z+2, r24	; 0x02
   11f4c:	8c e3       	ldi	r24, 0x3C	; 60
   11f4e:	9c e0       	ldi	r25, 0x0C	; 12
   11f50:	24 c0       	rjmp	.+72     	; 0x11f9a <FMenuChangeMOP+0x69c>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   11f52:	00 d0       	rcall	.+0      	; 0x11f54 <FMenuChangeMOP+0x656>
   11f54:	00 d0       	rcall	.+0      	; 0x11f56 <FMenuChangeMOP+0x658>
   11f56:	8e e8       	ldi	r24, 0x8E	; 142
   11f58:	9c e0       	ldi	r25, 0x0C	; 12
   11f5a:	ad b7       	in	r26, 0x3d	; 61
   11f5c:	be b7       	in	r27, 0x3e	; 62
   11f5e:	12 96       	adiw	r26, 0x02	; 2
   11f60:	9c 93       	st	X, r25
   11f62:	8e 93       	st	-X, r24
   11f64:	11 97       	sbiw	r26, 0x01	; 1
   11f66:	89 ea       	ldi	r24, 0xA9	; 169
   11f68:	9a e1       	ldi	r25, 0x1A	; 26
   11f6a:	14 96       	adiw	r26, 0x04	; 4
   11f6c:	9c 93       	st	X, r25
   11f6e:	8e 93       	st	-X, r24
   11f70:	13 97       	sbiw	r26, 0x03	; 3
   11f72:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   11f76:	00 d0       	rcall	.+0      	; 0x11f78 <FMenuChangeMOP+0x67a>
   11f78:	ed b7       	in	r30, 0x3d	; 61
   11f7a:	fe b7       	in	r31, 0x3e	; 62
   11f7c:	31 96       	adiw	r30, 0x01	; 1
   11f7e:	8e e9       	ldi	r24, 0x9E	; 158
   11f80:	9b e0       	ldi	r25, 0x0B	; 11
   11f82:	ad b7       	in	r26, 0x3d	; 61
   11f84:	be b7       	in	r27, 0x3e	; 62
   11f86:	12 96       	adiw	r26, 0x02	; 2
   11f88:	9c 93       	st	X, r25
   11f8a:	8e 93       	st	-X, r24
   11f8c:	11 97       	sbiw	r26, 0x01	; 1
   11f8e:	86 ea       	ldi	r24, 0xA6	; 166
   11f90:	9a e1       	ldi	r25, 0x1A	; 26
   11f92:	93 83       	std	Z+3, r25	; 0x03
   11f94:	82 83       	std	Z+2, r24	; 0x02
   11f96:	89 e8       	ldi	r24, 0x89	; 137
   11f98:	9b e0       	ldi	r25, 0x0B	; 11
   11f9a:	95 83       	std	Z+5, r25	; 0x05
   11f9c:	84 83       	std	Z+4, r24	; 0x04
   11f9e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   11fa2:	ed b7       	in	r30, 0x3d	; 61
   11fa4:	fe b7       	in	r31, 0x3e	; 62
   11fa6:	36 96       	adiw	r30, 0x06	; 6
   11fa8:	0f b6       	in	r0, 0x3f	; 63
   11faa:	f8 94       	cli
   11fac:	fe bf       	out	0x3e, r31	; 62
   11fae:	0f be       	out	0x3f, r0	; 63
   11fb0:	ed bf       	out	0x3d, r30	; 61
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
   11fb2:	00 d0       	rcall	.+0      	; 0x11fb4 <FMenuChangeMOP+0x6b6>
   11fb4:	00 d0       	rcall	.+0      	; 0x11fb6 <FMenuChangeMOP+0x6b8>
   11fb6:	00 d0       	rcall	.+0      	; 0x11fb8 <FMenuChangeMOP+0x6ba>
   11fb8:	ed b7       	in	r30, 0x3d	; 61
   11fba:	fe b7       	in	r31, 0x3e	; 62
   11fbc:	31 96       	adiw	r30, 0x01	; 1
   11fbe:	80 e5       	ldi	r24, 0x50	; 80
   11fc0:	97 e0       	ldi	r25, 0x07	; 7
   11fc2:	ad b7       	in	r26, 0x3d	; 61
   11fc4:	be b7       	in	r27, 0x3e	; 62
   11fc6:	12 96       	adiw	r26, 0x02	; 2
   11fc8:	9c 93       	st	X, r25
   11fca:	8e 93       	st	-X, r24
   11fcc:	11 97       	sbiw	r26, 0x01	; 1
   11fce:	89 ee       	ldi	r24, 0xE9	; 233
   11fd0:	9e e0       	ldi	r25, 0x0E	; 14
   11fd2:	93 83       	std	Z+3, r25	; 0x03
   11fd4:	82 83       	std	Z+2, r24	; 0x02
   11fd6:	80 91 b8 01 	lds	r24, 0x01B8
   11fda:	84 83       	std	Z+4, r24	; 0x04
   11fdc:	15 82       	std	Z+5, r1	; 0x05
   11fde:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
		  AddSpaceLead(strRef1,20);
   11fe2:	ed b7       	in	r30, 0x3d	; 61
   11fe4:	fe b7       	in	r31, 0x3e	; 62
   11fe6:	36 96       	adiw	r30, 0x06	; 6
   11fe8:	0f b6       	in	r0, 0x3f	; 63
   11fea:	f8 94       	cli
   11fec:	fe bf       	out	0x3e, r31	; 62
   11fee:	0f be       	out	0x3f, r0	; 63
   11ff0:	ed bf       	out	0x3d, r30	; 61
   11ff2:	8e e8       	ldi	r24, 0x8E	; 142
   11ff4:	9c e0       	ldi	r25, 0x0C	; 12
   11ff6:	64 e1       	ldi	r22, 0x14	; 20
   11ff8:	0e 94 78 30 	call	0x60f0	; 0x60f0 <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   11ffc:	8e e9       	ldi	r24, 0x9E	; 158
   11ffe:	9b e0       	ldi	r25, 0x0B	; 11
   12000:	64 e1       	ldi	r22, 0x14	; 20
   12002:	0e 94 78 30 	call	0x60f0	; 0x60f0 <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   12006:	8d e7       	ldi	r24, 0x7D	; 125
   12008:	98 e0       	ldi	r25, 0x08	; 8
   1200a:	64 e1       	ldi	r22, 0x14	; 20
   1200c:	0e 94 78 30 	call	0x60f0	; 0x60f0 <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   12010:	85 ea       	ldi	r24, 0xA5	; 165
   12012:	93 e0       	ldi	r25, 0x03	; 3
   12014:	64 e1       	ldi	r22, 0x14	; 20
   12016:	0e 94 78 30 	call	0x60f0	; 0x60f0 <AddSpaceLead>
		  iWait=0;
   1201a:	10 92 5d 02 	sts	0x025D, r1
		  IsMessage09=False;
   1201e:	10 92 a3 01 	sts	0x01A3, r1
		  stChangeMOP=cmSendMessage32;	      
   12022:	87 e1       	ldi	r24, 0x17	; 23
   12024:	50 ce       	rjmp	.-864    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   12026:	0e 94 7b 8c 	call	0x118f6	; 0x118f6 <sendMessage32>
		  iLoop=0;
   1202a:	10 92 5c 02 	sts	0x025C, r1
   1202e:	10 92 5b 02 	sts	0x025B, r1
		  iPos=0;
   12032:	10 92 5e 02 	sts	0x025E, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   12036:	83 e0       	ldi	r24, 0x03	; 3
   12038:	61 e0       	ldi	r22, 0x01	; 1
   1203a:	4a e9       	ldi	r20, 0x9A	; 154
   1203c:	5a e1       	ldi	r21, 0x1A	; 26
   1203e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   12042:	88 e1       	ldi	r24, 0x18	; 24
   12044:	40 ce       	rjmp	.-896    	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   12046:	80 91 5b 02 	lds	r24, 0x025B
   1204a:	90 91 5c 02 	lds	r25, 0x025C
   1204e:	01 96       	adiw	r24, 0x01	; 1
   12050:	90 93 5c 02 	sts	0x025C, r25
   12054:	80 93 5b 02 	sts	0x025B, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   12058:	68 e9       	ldi	r22, 0x98	; 152
   1205a:	7a e3       	ldi	r23, 0x3A	; 58
   1205c:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
   12060:	89 2b       	or	r24, r25
   12062:	19 f5       	brne	.+70     	; 0x120aa <FMenuChangeMOP+0x7ac>
			 if (iPos<5){
   12064:	60 91 5e 02 	lds	r22, 0x025E
   12068:	65 30       	cpi	r22, 0x05	; 5
   1206a:	68 f4       	brcc	.+26     	; 0x12086 <FMenuChangeMOP+0x788>
				 lcd_xy(3,(13+iPos));_lcd('.');
   1206c:	63 5f       	subi	r22, 0xF3	; 243
   1206e:	83 e0       	ldi	r24, 0x03	; 3
   12070:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
   12074:	8e e2       	ldi	r24, 0x2E	; 46
   12076:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
				 iPos++;
   1207a:	80 91 5e 02 	lds	r24, 0x025E
   1207e:	8f 5f       	subi	r24, 0xFF	; 255
   12080:	80 93 5e 02 	sts	0x025E, r24
   12084:	12 c0       	rjmp	.+36     	; 0x120aa <FMenuChangeMOP+0x7ac>
				}
			 else{
				 iPos=0;
   12086:	10 92 5e 02 	sts	0x025E, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   1208a:	83 e0       	ldi	r24, 0x03	; 3
   1208c:	6d e0       	ldi	r22, 0x0D	; 13
   1208e:	42 e9       	ldi	r20, 0x92	; 146
   12090:	5a e1       	ldi	r21, 0x1A	; 26
   12092:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   12096:	90 91 5d 02 	lds	r25, 0x025D
   1209a:	95 30       	cpi	r25, 0x05	; 5
   1209c:	18 f4       	brcc	.+6      	; 0x120a4 <FMenuChangeMOP+0x7a6>
   1209e:	87 e1       	ldi	r24, 0x17	; 23
   120a0:	80 93 61 02 	sts	0x0261, r24
				iWait++;
   120a4:	9f 5f       	subi	r25, 0xFF	; 255
   120a6:	90 93 5d 02 	sts	0x025D, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   120aa:	80 91 5d 02 	lds	r24, 0x025D
   120ae:	86 30       	cpi	r24, 0x06	; 6
   120b0:	18 f0       	brcs	.+6      	; 0x120b8 <FMenuChangeMOP+0x7ba>
   120b2:	8a e1       	ldi	r24, 0x1A	; 26
   120b4:	80 93 61 02 	sts	0x0261, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   120b8:	80 91 a3 01 	lds	r24, 0x01A3
   120bc:	81 30       	cpi	r24, 0x01	; 1
   120be:	19 f4       	brne	.+6      	; 0x120c6 <FMenuChangeMOP+0x7c8>
   120c0:	89 e1       	ldi	r24, 0x19	; 25
   120c2:	80 93 61 02 	sts	0x0261, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   120c6:	80 91 9f 01 	lds	r24, 0x019F
   120ca:	81 30       	cpi	r24, 0x01	; 1
   120cc:	f1 f5       	brne	.+124    	; 0x1214a <FMenuChangeMOP+0x84c>
   120ce:	37 c0       	rjmp	.+110    	; 0x1213e <FMenuChangeMOP+0x840>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   120d0:	10 92 a3 01 	sts	0x01A3, r1
	      msgResult=procMessage09();
   120d4:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <procMessage09>
		  lcd_clear();
   120d8:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   120dc:	81 e0       	ldi	r24, 0x01	; 1
   120de:	61 e0       	ldi	r22, 0x01	; 1
   120e0:	42 e9       	ldi	r20, 0x92	; 146
   120e2:	58 e0       	ldi	r21, 0x08	; 8
   120e4:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   120e8:	82 e0       	ldi	r24, 0x02	; 2
   120ea:	61 e0       	ldi	r22, 0x01	; 1
   120ec:	43 ea       	ldi	r20, 0xA3	; 163
   120ee:	57 e0       	ldi	r21, 0x07	; 7
   120f0:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   120f4:	83 e0       	ldi	r24, 0x03	; 3
   120f6:	61 e0       	ldi	r22, 0x01	; 1
   120f8:	4c e1       	ldi	r20, 0x1C	; 28
   120fa:	58 e0       	ldi	r21, 0x08	; 8
   120fc:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   12100:	84 e0       	ldi	r24, 0x04	; 4
   12102:	61 e0       	ldi	r22, 0x01	; 1
   12104:	46 ed       	ldi	r20, 0xD6	; 214
   12106:	5b e0       	ldi	r21, 0x0B	; 11
   12108:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
   1210c:	0e c0       	rjmp	.+28     	; 0x1212a <FMenuChangeMOP+0x82c>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   1210e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   12112:	82 e0       	ldi	r24, 0x02	; 2
   12114:	61 e0       	ldi	r22, 0x01	; 1
   12116:	45 e8       	ldi	r20, 0x85	; 133
   12118:	5a e1       	ldi	r21, 0x1A	; 26
   1211a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   1211e:	83 e0       	ldi	r24, 0x03	; 3
   12120:	61 e0       	ldi	r22, 0x01	; 1
   12122:	48 e7       	ldi	r20, 0x78	; 120
   12124:	5a e1       	ldi	r21, 0x1A	; 26
   12126:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  TimDisplay=0;
   1212a:	10 92 92 01 	sts	0x0192, r1
          stChangeMOP=cmDelayMOP;
   1212e:	8b e1       	ldi	r24, 0x1B	; 27
   12130:	ca cd       	rjmp	.-1132   	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   12132:	80 91 92 01 	lds	r24, 0x0192
   12136:	8a 30       	cpi	r24, 0x0A	; 10
   12138:	40 f0       	brcs	.+16     	; 0x1214a <FMenuChangeMOP+0x84c>
   1213a:	8c e1       	ldi	r24, 0x1C	; 28
   1213c:	c4 cd       	rjmp	.-1144   	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   1213e:	8d e1       	ldi	r24, 0x1D	; 29
   12140:	c2 cd       	rjmp	.-1148   	; 0x11cc6 <FMenuChangeMOP+0x3c8>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   12142:	10 92 61 02 	sts	0x0261, r1
   12146:	81 e0       	ldi	r24, 0x01	; 1
   12148:	01 c0       	rjmp	.+2      	; 0x1214c <FMenuChangeMOP+0x84e>
   1214a:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   1214c:	a3 96       	adiw	r28, 0x23	; 35
   1214e:	0f b6       	in	r0, 0x3f	; 63
   12150:	f8 94       	cli
   12152:	de bf       	out	0x3e, r29	; 62
   12154:	0f be       	out	0x3f, r0	; 63
   12156:	cd bf       	out	0x3d, r28	; 61
   12158:	cf 91       	pop	r28
   1215a:	df 91       	pop	r29
   1215c:	1f 91       	pop	r17
   1215e:	0f 91       	pop	r16
   12160:	ff 90       	pop	r15
   12162:	ef 90       	pop	r14
   12164:	df 90       	pop	r13
   12166:	cf 90       	pop	r12
   12168:	bf 90       	pop	r11
   1216a:	af 90       	pop	r10
   1216c:	08 95       	ret

0001216e <sendMessage28>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_28);
   1216e:	88 e2       	ldi	r24, 0x28	; 40
   12170:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   12174:	08 95       	ret

00012176 <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   12176:	0f 93       	push	r16
   12178:	1f 93       	push	r17
   1217a:	df 93       	push	r29
   1217c:	cf 93       	push	r28
   1217e:	cd b7       	in	r28, 0x3d	; 61
   12180:	de b7       	in	r29, 0x3e	; 62
   12182:	64 97       	sbiw	r28, 0x14	; 20
   12184:	0f b6       	in	r0, 0x3f	; 63
   12186:	f8 94       	cli
   12188:	de bf       	out	0x3e, r29	; 62
   1218a:	0f be       	out	0x3f, r0	; 63
   1218c:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,KeyChar;//,FIP_USED;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   1218e:	80 91 68 02 	lds	r24, 0x0268
   12192:	87 30       	cpi	r24, 0x07	; 7
   12194:	09 f4       	brne	.+2      	; 0x12198 <FMenuReprint+0x22>
   12196:	9b c0       	rjmp	.+310    	; 0x122ce <FMenuReprint+0x158>
   12198:	88 30       	cpi	r24, 0x08	; 8
   1219a:	90 f4       	brcc	.+36     	; 0x121c0 <FMenuReprint+0x4a>
   1219c:	83 30       	cpi	r24, 0x03	; 3
   1219e:	09 f4       	brne	.+2      	; 0x121a2 <FMenuReprint+0x2c>
   121a0:	43 c0       	rjmp	.+134    	; 0x12228 <FMenuReprint+0xb2>
   121a2:	84 30       	cpi	r24, 0x04	; 4
   121a4:	30 f4       	brcc	.+12     	; 0x121b2 <FMenuReprint+0x3c>
   121a6:	81 30       	cpi	r24, 0x01	; 1
   121a8:	09 f4       	brne	.+2      	; 0x121ac <FMenuReprint+0x36>
   121aa:	52 c0       	rjmp	.+164    	; 0x12250 <FMenuReprint+0xda>
   121ac:	82 30       	cpi	r24, 0x02	; 2
   121ae:	48 f5       	brcc	.+82     	; 0x12202 <FMenuReprint+0x8c>
   121b0:	1d c0       	rjmp	.+58     	; 0x121ec <FMenuReprint+0x76>
   121b2:	85 30       	cpi	r24, 0x05	; 5
   121b4:	09 f4       	brne	.+2      	; 0x121b8 <FMenuReprint+0x42>
   121b6:	7c c0       	rjmp	.+248    	; 0x122b0 <FMenuReprint+0x13a>
   121b8:	86 30       	cpi	r24, 0x06	; 6
   121ba:	08 f0       	brcs	.+2      	; 0x121be <FMenuReprint+0x48>
   121bc:	4d c0       	rjmp	.+154    	; 0x12258 <FMenuReprint+0xe2>
   121be:	42 c0       	rjmp	.+132    	; 0x12244 <FMenuReprint+0xce>
   121c0:	8b 30       	cpi	r24, 0x0B	; 11
   121c2:	09 f4       	brne	.+2      	; 0x121c6 <FMenuReprint+0x50>
   121c4:	e5 c0       	rjmp	.+458    	; 0x12390 <FMenuReprint+0x21a>
   121c6:	8c 30       	cpi	r24, 0x0C	; 12
   121c8:	38 f4       	brcc	.+14     	; 0x121d8 <FMenuReprint+0x62>
   121ca:	89 30       	cpi	r24, 0x09	; 9
   121cc:	09 f4       	brne	.+2      	; 0x121d0 <FMenuReprint+0x5a>
   121ce:	c5 c0       	rjmp	.+394    	; 0x1235a <FMenuReprint+0x1e4>
   121d0:	8a 30       	cpi	r24, 0x0A	; 10
   121d2:	08 f0       	brcs	.+2      	; 0x121d6 <FMenuReprint+0x60>
   121d4:	d7 c0       	rjmp	.+430    	; 0x12384 <FMenuReprint+0x20e>
   121d6:	89 c0       	rjmp	.+274    	; 0x122ea <FMenuReprint+0x174>
   121d8:	8d 30       	cpi	r24, 0x0D	; 13
   121da:	09 f4       	brne	.+2      	; 0x121de <FMenuReprint+0x68>
   121dc:	f6 c0       	rjmp	.+492    	; 0x123ca <FMenuReprint+0x254>
   121de:	8d 30       	cpi	r24, 0x0D	; 13
   121e0:	08 f4       	brcc	.+2      	; 0x121e4 <FMenuReprint+0x6e>
   121e2:	e0 c0       	rjmp	.+448    	; 0x123a4 <FMenuReprint+0x22e>
   121e4:	8e 30       	cpi	r24, 0x0E	; 14
   121e6:	09 f0       	breq	.+2      	; 0x121ea <FMenuReprint+0x74>
   121e8:	f9 c0       	rjmp	.+498    	; 0x123dc <FMenuReprint+0x266>
   121ea:	f4 c0       	rjmp	.+488    	; 0x123d4 <FMenuReprint+0x25e>
	 case rtInit:
	      lcd_clear();
   121ec:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   121f0:	80 91 00 01 	lds	r24, 0x0100
   121f4:	81 30       	cpi	r24, 0x01	; 1
   121f6:	09 f4       	brne	.+2      	; 0x121fa <FMenuReprint+0x84>
   121f8:	c0 c0       	rjmp	.+384    	; 0x1237a <FMenuReprint+0x204>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   121fa:	82 30       	cpi	r24, 0x02	; 2
   121fc:	09 f0       	breq	.+2      	; 0x12200 <FMenuReprint+0x8a>
   121fe:	ee c0       	rjmp	.+476    	; 0x123dc <FMenuReprint+0x266>
   12200:	04 c0       	rjmp	.+8      	; 0x1220a <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   12202:	0e 94 12 7a 	call	0xf424	; 0xf424 <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   12206:	84 30       	cpi	r24, 0x04	; 4
   12208:	11 f4       	brne	.+4      	; 0x1220e <FMenuReprint+0x98>
   1220a:	81 e0       	ldi	r24, 0x01	; 1
   1220c:	0a c0       	rjmp	.+20     	; 0x12222 <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   1220e:	85 30       	cpi	r24, 0x05	; 5
   12210:	11 f0       	breq	.+4      	; 0x12216 <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   12212:	82 30       	cpi	r24, 0x02	; 2
   12214:	11 f4       	brne	.+4      	; 0x1221a <FMenuReprint+0xa4>
   12216:	83 e0       	ldi	r24, 0x03	; 3
   12218:	04 c0       	rjmp	.+8      	; 0x12222 <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   1221a:	81 30       	cpi	r24, 0x01	; 1
   1221c:	09 f0       	breq	.+2      	; 0x12220 <FMenuReprint+0xaa>
   1221e:	de c0       	rjmp	.+444    	; 0x123dc <FMenuReprint+0x266>
   12220:	8e e0       	ldi	r24, 0x0E	; 14
   12222:	80 93 68 02 	sts	0x0268, r24
   12226:	da c0       	rjmp	.+436    	; 0x123dc <FMenuReprint+0x266>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   12228:	10 92 92 01 	sts	0x0192, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1222c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1222e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12230:	81 e0       	ldi	r24, 0x01	; 1
   12232:	80 93 bc 01 	sts	0x01BC, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   12236:	83 e0       	ldi	r24, 0x03	; 3
   12238:	61 e0       	ldi	r22, 0x01	; 1
   1223a:	4b ec       	ldi	r20, 0xCB	; 203
   1223c:	5d e1       	ldi	r21, 0x1D	; 29
   1223e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
   12242:	43 c0       	rjmp	.+134    	; 0x122ca <FMenuReprint+0x154>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   12244:	80 91 92 01 	lds	r24, 0x0192
   12248:	83 30       	cpi	r24, 0x03	; 3
   1224a:	08 f4       	brcc	.+2      	; 0x1224e <FMenuReprint+0xd8>
   1224c:	c7 c0       	rjmp	.+398    	; 0x123dc <FMenuReprint+0x266>
   1224e:	e8 cf       	rjmp	.-48     	; 0x12220 <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   12250:	0e 94 e7 49 	call	0x93ce	; 0x93ce <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   12254:	86 e0       	ldi	r24, 0x06	; 6
   12256:	e5 cf       	rjmp	.-54     	; 0x12222 <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   12258:	81 e0       	ldi	r24, 0x01	; 1
   1225a:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   1225e:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
   12262:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   12264:	81 53       	subi	r24, 0x31	; 49
   12266:	88 30       	cpi	r24, 0x08	; 8
   12268:	f8 f4       	brcc	.+62     	; 0x122a8 <FMenuReprint+0x132>
		       SendPoolingCommand(SC_TRANSACTION,GetPumpID(KeyChar-'0'));
   1226a:	09 2f       	mov	r16, r25
   1226c:	00 53       	subi	r16, 0x30	; 48
   1226e:	80 2f       	mov	r24, r16
   12270:	0e 94 e5 21 	call	0x43ca	; 0x43ca <GetPumpID>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   12274:	94 e0       	ldi	r25, 0x04	; 4
   12276:	90 93 a7 05 	sts	0x05A7, r25
	 PoolMsg=plMsg;
   1227a:	80 93 d3 0b 	sts	0x0BD3, r24
     IsControlPooling=True;
   1227e:	81 e0       	ldi	r24, 0x01	; 1
   12280:	80 93 84 01 	sts	0x0184, r24
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
		  if ((KeyChar>='1')&&(KeyChar<='8')){
		       SendPoolingCommand(SC_TRANSACTION,GetPumpID(KeyChar-'0'));
			   TimSend=0;
   12284:	10 92 78 0c 	sts	0x0C78, r1
			   while(TimSend<6){};
   12288:	80 91 78 0c 	lds	r24, 0x0C78
   1228c:	86 30       	cpi	r24, 0x06	; 6
   1228e:	e0 f3       	brcs	.-8      	; 0x12288 <FMenuReprint+0x112>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   12290:	80 2f       	mov	r24, r16
   12292:	61 e0       	ldi	r22, 0x01	; 1
   12294:	0e 94 36 24 	call	0x486c	; 0x486c <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   12298:	82 31       	cpi	r24, 0x12	; 18
   1229a:	11 f4       	brne	.+4      	; 0x122a0 <FMenuReprint+0x12a>
   1229c:	85 e0       	ldi	r24, 0x05	; 5
   1229e:	c1 cf       	rjmp	.-126    	; 0x12222 <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;               
   122a0:	81 31       	cpi	r24, 0x11	; 17
   122a2:	09 f0       	breq	.+2      	; 0x122a6 <FMenuReprint+0x130>
   122a4:	9b c0       	rjmp	.+310    	; 0x123dc <FMenuReprint+0x266>
   122a6:	bc cf       	rjmp	.-136    	; 0x12220 <FMenuReprint+0xaa>
			   //stReprint=rtExitReprint;
		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   122a8:	9a 32       	cpi	r25, 0x2A	; 42
   122aa:	09 f0       	breq	.+2      	; 0x122ae <FMenuReprint+0x138>
   122ac:	97 c0       	rjmp	.+302    	; 0x123dc <FMenuReprint+0x266>
   122ae:	b8 cf       	rjmp	.-144    	; 0x12220 <FMenuReprint+0xaa>
	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   122b0:	83 e0       	ldi	r24, 0x03	; 3
   122b2:	61 e0       	ldi	r22, 0x01	; 1
   122b4:	46 eb       	ldi	r20, 0xB6	; 182
   122b6:	5d e1       	ldi	r21, 0x1D	; 29
   122b8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   122bc:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   122be:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   122c0:	81 e0       	ldi	r24, 0x01	; 1
   122c2:	80 93 bc 01 	sts	0x01BC, r24
		  }else if (KeyChar=='*')stReprint=rtExitReprint;
	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   122c6:	10 92 92 01 	sts	0x0192, r1
		  stReprint=rtTimDisplayInvalid;
   122ca:	84 e0       	ldi	r24, 0x04	; 4
   122cc:	aa cf       	rjmp	.-172    	; 0x12222 <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   122ce:	86 e6       	ldi	r24, 0x66	; 102
   122d0:	92 e0       	ldi	r25, 0x02	; 2
   122d2:	69 eb       	ldi	r22, 0xB9	; 185
   122d4:	77 e0       	ldi	r23, 0x07	; 7
   122d6:	0e 94 25 58 	call	0xb04a	; 0xb04a <menu_FIP>
		  if (FIPResult==FIP_DONE){
   122da:	88 23       	and	r24, r24
   122dc:	11 f4       	brne	.+4      	; 0x122e2 <FMenuReprint+0x16c>
		      stReprint=rtRFID;
   122de:	88 e0       	ldi	r24, 0x08	; 8
   122e0:	a0 cf       	rjmp	.-192    	; 0x12222 <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   122e2:	82 30       	cpi	r24, 0x02	; 2
   122e4:	09 f0       	breq	.+2      	; 0x122e8 <FMenuReprint+0x172>
   122e6:	7a c0       	rjmp	.+244    	; 0x123dc <FMenuReprint+0x266>
   122e8:	9b cf       	rjmp	.-202    	; 0x12220 <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   122ea:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   122ee:	00 d0       	rcall	.+0      	; 0x122f0 <FMenuReprint+0x17a>
   122f0:	00 d0       	rcall	.+0      	; 0x122f2 <FMenuReprint+0x17c>
   122f2:	00 d0       	rcall	.+0      	; 0x122f4 <FMenuReprint+0x17e>
   122f4:	ed b7       	in	r30, 0x3d	; 61
   122f6:	fe b7       	in	r31, 0x3e	; 62
   122f8:	31 96       	adiw	r30, 0x01	; 1
   122fa:	8e 01       	movw	r16, r28
   122fc:	0f 5f       	subi	r16, 0xFF	; 255
   122fe:	1f 4f       	sbci	r17, 0xFF	; 255
   12300:	ad b7       	in	r26, 0x3d	; 61
   12302:	be b7       	in	r27, 0x3e	; 62
   12304:	12 96       	adiw	r26, 0x02	; 2
   12306:	1c 93       	st	X, r17
   12308:	0e 93       	st	-X, r16
   1230a:	11 97       	sbiw	r26, 0x01	; 1
   1230c:	86 ea       	ldi	r24, 0xA6	; 166
   1230e:	9d e1       	ldi	r25, 0x1D	; 29
   12310:	93 83       	std	Z+3, r25	; 0x03
   12312:	82 83       	std	Z+2, r24	; 0x02
   12314:	89 eb       	ldi	r24, 0xB9	; 185
   12316:	97 e0       	ldi	r25, 0x07	; 7
   12318:	95 83       	std	Z+5, r25	; 0x05
   1231a:	84 83       	std	Z+4, r24	; 0x04
   1231c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   12320:	8d b7       	in	r24, 0x3d	; 61
   12322:	9e b7       	in	r25, 0x3e	; 62
   12324:	06 96       	adiw	r24, 0x06	; 6
   12326:	0f b6       	in	r0, 0x3f	; 63
   12328:	f8 94       	cli
   1232a:	9e bf       	out	0x3e, r25	; 62
   1232c:	0f be       	out	0x3f, r0	; 63
   1232e:	8d bf       	out	0x3d, r24	; 61
   12330:	81 e0       	ldi	r24, 0x01	; 1
   12332:	61 e0       	ldi	r22, 0x01	; 1
   12334:	a8 01       	movw	r20, r16
   12336:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   1233a:	82 e0       	ldi	r24, 0x02	; 2
   1233c:	61 e0       	ldi	r22, 0x01	; 1
   1233e:	42 e9       	ldi	r20, 0x92	; 146
   12340:	5d e1       	ldi	r21, 0x1D	; 29
   12342:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   12346:	84 e0       	ldi	r24, 0x04	; 4
   12348:	61 e0       	ldi	r22, 0x01	; 1
   1234a:	4f e7       	ldi	r20, 0x7F	; 127
   1234c:	5d e1       	ldi	r21, 0x1D	; 29
   1234e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  IsRFIDDetected=False;
   12352:	10 92 98 01 	sts	0x0198, r1
		  stReprint=rtInputRFID;
   12356:	89 e0       	ldi	r24, 0x09	; 9
   12358:	64 cf       	rjmp	.-312    	; 0x12222 <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   1235a:	80 91 98 01 	lds	r24, 0x0198
   1235e:	81 30       	cpi	r24, 0x01	; 1
   12360:	29 f4       	brne	.+10     	; 0x1236c <FMenuReprint+0x1f6>
		      IsRFIDDetected=False;
   12362:	10 92 98 01 	sts	0x0198, r1
		      stReprint=rtSendMessage28;
   12366:	8a e0       	ldi	r24, 0x0A	; 10
   12368:	80 93 68 02 	sts	0x0268, r24
		  }
	 	  KeyPressed=_key_scan(1);
   1236c:	81 e0       	ldi	r24, 0x01	; 1
   1236e:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   12372:	80 93 67 02 	sts	0x0267, r24
		  if (KeyPressed==_KEY_CANCEL){
   12376:	87 3e       	cpi	r24, 0xE7	; 231
   12378:	11 f4       	brne	.+4      	; 0x1237e <FMenuReprint+0x208>
		      stReprint=rtFIP;
   1237a:	87 e0       	ldi	r24, 0x07	; 7
   1237c:	52 cf       	rjmp	.-348    	; 0x12222 <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   1237e:	87 3b       	cpi	r24, 0xB7	; 183
   12380:	69 f5       	brne	.+90     	; 0x123dc <FMenuReprint+0x266>
   12382:	4e cf       	rjmp	.-356    	; 0x12220 <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   12384:	0e 94 b7 90 	call	0x1216e	; 0x1216e <sendMessage28>
		  TimSend=0;
   12388:	10 92 78 0c 	sts	0x0C78, r1
		  stReprint=rtWaitReply;
   1238c:	8b e0       	ldi	r24, 0x0B	; 11
   1238e:	49 cf       	rjmp	.-366    	; 0x12222 <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   12390:	80 91 78 0c 	lds	r24, 0x0C78
   12394:	8f 31       	cpi	r24, 0x1F	; 31
   12396:	18 f0       	brcs	.+6      	; 0x1239e <FMenuReprint+0x228>
   12398:	8c e0       	ldi	r24, 0x0C	; 12
   1239a:	80 93 68 02 	sts	0x0268, r24
	      if (IsMessage99==True){
   1239e:	80 91 9f 01 	lds	r24, 0x019F
   123a2:	3b cf       	rjmp	.-394    	; 0x1221a <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   123a4:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   123a8:	82 e0       	ldi	r24, 0x02	; 2
   123aa:	61 e0       	ldi	r22, 0x01	; 1
   123ac:	41 e7       	ldi	r20, 0x71	; 113
   123ae:	5d e1       	ldi	r21, 0x1D	; 29
   123b0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   123b4:	83 e0       	ldi	r24, 0x03	; 3
   123b6:	61 e0       	ldi	r22, 0x01	; 1
   123b8:	43 e6       	ldi	r20, 0x63	; 99
   123ba:	5d e1       	ldi	r21, 0x1D	; 29
   123bc:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  TimDisplay=5;
   123c0:	85 e0       	ldi	r24, 0x05	; 5
   123c2:	80 93 92 01 	sts	0x0192, r24
		  stReprint=rtDelayExitReprint;
   123c6:	8d e0       	ldi	r24, 0x0D	; 13
   123c8:	2c cf       	rjmp	.-424    	; 0x12222 <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   123ca:	80 91 92 01 	lds	r24, 0x0192
   123ce:	8a 30       	cpi	r24, 0x0A	; 10
   123d0:	28 f0       	brcs	.+10     	; 0x123dc <FMenuReprint+0x266>
   123d2:	26 cf       	rjmp	.-436    	; 0x12220 <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   123d4:	10 92 68 02 	sts	0x0268, r1
   123d8:	81 e0       	ldi	r24, 0x01	; 1
   123da:	01 c0       	rjmp	.+2      	; 0x123de <FMenuReprint+0x268>
   123dc:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   123de:	64 96       	adiw	r28, 0x14	; 20
   123e0:	0f b6       	in	r0, 0x3f	; 63
   123e2:	f8 94       	cli
   123e4:	de bf       	out	0x3e, r29	; 62
   123e6:	0f be       	out	0x3f, r0	; 63
   123e8:	cd bf       	out	0x3d, r28	; 61
   123ea:	cf 91       	pop	r28
   123ec:	df 91       	pop	r29
   123ee:	1f 91       	pop	r17
   123f0:	0f 91       	pop	r16
   123f2:	08 95       	ret

000123f4 <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   123f4:	80 91 4b 02 	lds	r24, 0x024B
   123f8:	83 30       	cpi	r24, 0x03	; 3
   123fa:	09 f4       	brne	.+2      	; 0x123fe <FMenuAdmin+0xa>
   123fc:	66 c0       	rjmp	.+204    	; 0x124ca <FMenuAdmin+0xd6>
   123fe:	84 30       	cpi	r24, 0x04	; 4
   12400:	30 f4       	brcc	.+12     	; 0x1240e <FMenuAdmin+0x1a>
   12402:	81 30       	cpi	r24, 0x01	; 1
   12404:	69 f1       	breq	.+90     	; 0x12460 <FMenuAdmin+0x6c>
   12406:	82 30       	cpi	r24, 0x02	; 2
   12408:	08 f0       	brcs	.+2      	; 0x1240c <FMenuAdmin+0x18>
   1240a:	4d c0       	rjmp	.+154    	; 0x124a6 <FMenuAdmin+0xb2>
   1240c:	0d c0       	rjmp	.+26     	; 0x12428 <FMenuAdmin+0x34>
   1240e:	85 30       	cpi	r24, 0x05	; 5
   12410:	09 f4       	brne	.+2      	; 0x12414 <FMenuAdmin+0x20>
   12412:	4e c0       	rjmp	.+156    	; 0x124b0 <FMenuAdmin+0xbc>
   12414:	85 30       	cpi	r24, 0x05	; 5
   12416:	08 f4       	brcc	.+2      	; 0x1241a <FMenuAdmin+0x26>
   12418:	49 c0       	rjmp	.+146    	; 0x124ac <FMenuAdmin+0xb8>
   1241a:	86 30       	cpi	r24, 0x06	; 6
   1241c:	09 f4       	brne	.+2      	; 0x12420 <FMenuAdmin+0x2c>
   1241e:	51 c0       	rjmp	.+162    	; 0x124c2 <FMenuAdmin+0xce>
   12420:	87 30       	cpi	r24, 0x07	; 7
   12422:	09 f0       	breq	.+2      	; 0x12426 <FMenuAdmin+0x32>
   12424:	5a c0       	rjmp	.+180    	; 0x124da <FMenuAdmin+0xe6>
   12426:	55 c0       	rjmp	.+170    	; 0x124d2 <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   12428:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   1242c:	81 e0       	ldi	r24, 0x01	; 1
   1242e:	61 e0       	ldi	r22, 0x01	; 1
   12430:	42 eb       	ldi	r20, 0xB2	; 178
   12432:	57 e1       	ldi	r21, 0x17	; 23
   12434:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   12438:	82 e0       	ldi	r24, 0x02	; 2
   1243a:	61 e0       	ldi	r22, 0x01	; 1
   1243c:	4d e9       	ldi	r20, 0x9D	; 157
   1243e:	57 e1       	ldi	r21, 0x17	; 23
   12440:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   12444:	83 e0       	ldi	r24, 0x03	; 3
   12446:	61 e0       	ldi	r22, 0x01	; 1
   12448:	48 e8       	ldi	r20, 0x88	; 136
   1244a:	57 e1       	ldi	r21, 0x17	; 23
   1244c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   12450:	84 e0       	ldi	r24, 0x04	; 4
   12452:	61 e0       	ldi	r22, 0x01	; 1
   12454:	43 e7       	ldi	r20, 0x73	; 115
   12456:	57 e1       	ldi	r21, 0x17	; 23
   12458:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   1245c:	81 e0       	ldi	r24, 0x01	; 1
   1245e:	2e c0       	rjmp	.+92     	; 0x124bc <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   12460:	81 e0       	ldi	r24, 0x01	; 1
   12462:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   12466:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
		  switch (KeyChar){
   1246a:	82 33       	cpi	r24, 0x32	; 50
   1246c:	71 f0       	breq	.+28     	; 0x1248a <FMenuAdmin+0x96>
   1246e:	83 33       	cpi	r24, 0x33	; 51
   12470:	28 f4       	brcc	.+10     	; 0x1247c <FMenuAdmin+0x88>
   12472:	8a 32       	cpi	r24, 0x2A	; 42
   12474:	11 f1       	breq	.+68     	; 0x124ba <FMenuAdmin+0xc6>
   12476:	81 33       	cpi	r24, 0x31	; 49
   12478:	81 f5       	brne	.+96     	; 0x124da <FMenuAdmin+0xe6>
   1247a:	05 c0       	rjmp	.+10     	; 0x12486 <FMenuAdmin+0x92>
   1247c:	83 33       	cpi	r24, 0x33	; 51
   1247e:	59 f0       	breq	.+22     	; 0x12496 <FMenuAdmin+0xa2>
   12480:	84 33       	cpi	r24, 0x34	; 52
   12482:	59 f5       	brne	.+86     	; 0x124da <FMenuAdmin+0xe6>
   12484:	0e c0       	rjmp	.+28     	; 0x124a2 <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   12486:	82 e0       	ldi	r24, 0x02	; 2
   12488:	19 c0       	rjmp	.+50     	; 0x124bc <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   1248a:	80 91 00 01 	lds	r24, 0x0100
   1248e:	82 30       	cpi	r24, 0x02	; 2
   12490:	e1 f4       	brne	.+56     	; 0x124ca <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   12492:	84 e0       	ldi	r24, 0x04	; 4
   12494:	13 c0       	rjmp	.+38     	; 0x124bc <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   12496:	80 91 00 01 	lds	r24, 0x0100
   1249a:	82 30       	cpi	r24, 0x02	; 2
   1249c:	b1 f4       	brne	.+44     	; 0x124ca <FMenuAdmin+0xd6>
   1249e:	85 e0       	ldi	r24, 0x05	; 5
   124a0:	0d c0       	rjmp	.+26     	; 0x124bc <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   124a2:	86 e0       	ldi	r24, 0x06	; 6
   124a4:	0b c0       	rjmp	.+22     	; 0x124bc <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   124a6:	0e 94 bb 90 	call	0x12176	; 0x12176 <FMenuReprint>
   124aa:	05 c0       	rjmp	.+10     	; 0x124b6 <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   124ac:	82 e0       	ldi	r24, 0x02	; 2
   124ae:	01 c0       	rjmp	.+2      	; 0x124b2 <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   124b0:	81 e0       	ldi	r24, 0x01	; 1
   124b2:	0e 94 1d 4c 	call	0x983a	; 0x983a <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   124b6:	81 30       	cpi	r24, 0x01	; 1
   124b8:	81 f4       	brne	.+32     	; 0x124da <FMenuAdmin+0xe6>
   124ba:	87 e0       	ldi	r24, 0x07	; 7
   124bc:	80 93 4b 02 	sts	0x024B, r24
   124c0:	06 c0       	rjmp	.+12     	; 0x124ce <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   124c2:	0e 94 83 76 	call	0xed06	; 0xed06 <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   124c6:	81 30       	cpi	r24, 0x01	; 1
   124c8:	41 f4       	brne	.+16     	; 0x124da <FMenuAdmin+0xe6>
   124ca:	10 92 4b 02 	sts	0x024B, r1
   124ce:	80 e0       	ldi	r24, 0x00	; 0
   124d0:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   124d2:	10 92 4b 02 	sts	0x024B, r1
   124d6:	81 e0       	ldi	r24, 0x01	; 1
   124d8:	08 95       	ret
   124da:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   124dc:	08 95       	ret

000124de <FMenuAuthorization>:


char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   124de:	80 91 5a 02 	lds	r24, 0x025A
   124e2:	83 30       	cpi	r24, 0x03	; 3
   124e4:	51 f1       	breq	.+84     	; 0x1253a <FMenuAuthorization+0x5c>
   124e6:	84 30       	cpi	r24, 0x04	; 4
   124e8:	28 f4       	brcc	.+10     	; 0x124f4 <FMenuAuthorization+0x16>
   124ea:	81 30       	cpi	r24, 0x01	; 1
   124ec:	81 f0       	breq	.+32     	; 0x1250e <FMenuAuthorization+0x30>
   124ee:	82 30       	cpi	r24, 0x02	; 2
   124f0:	38 f5       	brcc	.+78     	; 0x12540 <FMenuAuthorization+0x62>
   124f2:	0a c0       	rjmp	.+20     	; 0x12508 <FMenuAuthorization+0x2a>
   124f4:	85 30       	cpi	r24, 0x05	; 5
   124f6:	61 f1       	breq	.+88     	; 0x12550 <FMenuAuthorization+0x72>
   124f8:	85 30       	cpi	r24, 0x05	; 5
   124fa:	28 f1       	brcs	.+74     	; 0x12546 <FMenuAuthorization+0x68>
   124fc:	86 30       	cpi	r24, 0x06	; 6
   124fe:	e1 f1       	breq	.+120    	; 0x12578 <FMenuAuthorization+0x9a>
   12500:	87 30       	cpi	r24, 0x07	; 7
   12502:	09 f0       	breq	.+2      	; 0x12506 <FMenuAuthorization+0x28>
   12504:	4c c0       	rjmp	.+152    	; 0x1259e <FMenuAuthorization+0xc0>
   12506:	47 c0       	rjmp	.+142    	; 0x12596 <FMenuAuthorization+0xb8>
	 case maInit:
	      PassTry=0;
   12508:	10 92 59 02 	sts	0x0259, r1
   1250c:	3d c0       	rjmp	.+122    	; 0x12588 <FMenuAuthorization+0xaa>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   1250e:	0e 94 12 7a 	call	0xf424	; 0xf424 <FMenuPassword>
		  switch(PassResult){
   12512:	83 30       	cpi	r24, 0x03	; 3
   12514:	e1 f1       	breq	.+120    	; 0x1258e <FMenuAuthorization+0xb0>
   12516:	84 30       	cpi	r24, 0x04	; 4
   12518:	28 f4       	brcc	.+10     	; 0x12524 <FMenuAuthorization+0x46>
   1251a:	81 30       	cpi	r24, 0x01	; 1
   1251c:	b9 f1       	breq	.+110    	; 0x1258c <FMenuAuthorization+0xae>
   1251e:	82 30       	cpi	r24, 0x02	; 2
   12520:	f1 f5       	brne	.+124    	; 0x1259e <FMenuAuthorization+0xc0>
   12522:	09 c0       	rjmp	.+18     	; 0x12536 <FMenuAuthorization+0x58>
   12524:	84 30       	cpi	r24, 0x04	; 4
   12526:	19 f0       	breq	.+6      	; 0x1252e <FMenuAuthorization+0x50>
   12528:	85 30       	cpi	r24, 0x05	; 5
   1252a:	c9 f5       	brne	.+114    	; 0x1259e <FMenuAuthorization+0xc0>
   1252c:	02 c0       	rjmp	.+4      	; 0x12532 <FMenuAuthorization+0x54>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   1252e:	82 e0       	ldi	r24, 0x02	; 2
   12530:	2e c0       	rjmp	.+92     	; 0x1258e <FMenuAuthorization+0xb0>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   12532:	84 e0       	ldi	r24, 0x04	; 4
   12534:	2c c0       	rjmp	.+88     	; 0x1258e <FMenuAuthorization+0xb0>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   12536:	85 e0       	ldi	r24, 0x05	; 5
   12538:	2a c0       	rjmp	.+84     	; 0x1258e <FMenuAuthorization+0xb0>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   1253a:	0e 94 0a 77 	call	0xee14	; 0xee14 <FMenuMaster>
   1253e:	05 c0       	rjmp	.+10     	; 0x1254a <FMenuAuthorization+0x6c>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   12540:	0e 94 fa 91 	call	0x123f4	; 0x123f4 <FMenuAdmin>
   12544:	02 c0       	rjmp	.+4      	; 0x1254a <FMenuAuthorization+0x6c>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   12546:	0e 94 a7 7c 	call	0xf94e	; 0xf94e <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   1254a:	81 30       	cpi	r24, 0x01	; 1
   1254c:	41 f5       	brne	.+80     	; 0x1259e <FMenuAuthorization+0xc0>
   1254e:	1e c0       	rjmp	.+60     	; 0x1258c <FMenuAuthorization+0xae>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   12550:	80 91 59 02 	lds	r24, 0x0259
   12554:	8f 5f       	subi	r24, 0xFF	; 255
   12556:	80 93 59 02 	sts	0x0259, r24
	      TimDisplay=0;
   1255a:	10 92 92 01 	sts	0x0192, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1255e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12560:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12562:	81 e0       	ldi	r24, 0x01	; 1
   12564:	80 93 bc 01 	sts	0x01BC, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   12568:	83 e0       	ldi	r24, 0x03	; 3
   1256a:	61 e0       	ldi	r22, 0x01	; 1
   1256c:	4a e6       	ldi	r20, 0x6A	; 106
   1256e:	5a e1       	ldi	r21, 0x1A	; 26
   12570:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   12574:	86 e0       	ldi	r24, 0x06	; 6
   12576:	0b c0       	rjmp	.+22     	; 0x1258e <FMenuAuthorization+0xb0>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   12578:	80 91 92 01 	lds	r24, 0x0192
   1257c:	83 30       	cpi	r24, 0x03	; 3
   1257e:	78 f0       	brcs	.+30     	; 0x1259e <FMenuAuthorization+0xc0>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   12580:	80 91 59 02 	lds	r24, 0x0259
   12584:	83 30       	cpi	r24, 0x03	; 3
   12586:	10 f4       	brcc	.+4      	; 0x1258c <FMenuAuthorization+0xae>
   12588:	81 e0       	ldi	r24, 0x01	; 1
   1258a:	01 c0       	rjmp	.+2      	; 0x1258e <FMenuAuthorization+0xb0>
			  else stMenuAuthorization=maExitAuthorization;
   1258c:	87 e0       	ldi	r24, 0x07	; 7
   1258e:	80 93 5a 02 	sts	0x025A, r24
   12592:	80 e0       	ldi	r24, 0x00	; 0
   12594:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   12596:	10 92 5a 02 	sts	0x025A, r1
   1259a:	81 e0       	ldi	r24, 0x01	; 1
   1259c:	08 95       	ret
   1259e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   125a0:	08 95       	ret

000125a2 <sendMessage24>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_24);
   125a2:	84 e2       	ldi	r24, 0x24	; 36
   125a4:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   125a8:	08 95       	ret

000125aa <sendMessage22>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_22);
   125aa:	82 e2       	ldi	r24, 0x22	; 34
   125ac:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   125b0:	08 95       	ret

000125b2 <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
   125b2:	cf 92       	push	r12
   125b4:	df 92       	push	r13
   125b6:	ef 92       	push	r14
   125b8:	ff 92       	push	r15
   125ba:	0f 93       	push	r16
   125bc:	1f 93       	push	r17
   125be:	df 93       	push	r29
   125c0:	cf 93       	push	r28
   125c2:	cd b7       	in	r28, 0x3d	; 61
   125c4:	de b7       	in	r29, 0x3e	; 62
   125c6:	64 97       	sbiw	r28, 0x14	; 20
   125c8:	0f b6       	in	r0, 0x3f	; 63
   125ca:	f8 94       	cli
   125cc:	de bf       	out	0x3e, r29	; 62
   125ce:	0f be       	out	0x3f, r0	; 63
   125d0:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyPressed=0,KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
   125d2:	00 91 65 02 	lds	r16, 0x0265
   125d6:	07 30       	cpi	r16, 0x07	; 7
   125d8:	09 f4       	brne	.+2      	; 0x125dc <FMenuLoyalty+0x2a>
   125da:	04 c1       	rjmp	.+520    	; 0x127e4 <FMenuLoyalty+0x232>
   125dc:	08 30       	cpi	r16, 0x08	; 8
   125de:	98 f4       	brcc	.+38     	; 0x12606 <FMenuLoyalty+0x54>
   125e0:	03 30       	cpi	r16, 0x03	; 3
   125e2:	09 f4       	brne	.+2      	; 0x125e6 <FMenuLoyalty+0x34>
   125e4:	5b c0       	rjmp	.+182    	; 0x1269c <FMenuLoyalty+0xea>
   125e6:	04 30       	cpi	r16, 0x04	; 4
   125e8:	38 f4       	brcc	.+14     	; 0x125f8 <FMenuLoyalty+0x46>
   125ea:	01 30       	cpi	r16, 0x01	; 1
   125ec:	09 f4       	brne	.+2      	; 0x125f0 <FMenuLoyalty+0x3e>
   125ee:	42 c0       	rjmp	.+132    	; 0x12674 <FMenuLoyalty+0xc2>
   125f0:	02 30       	cpi	r16, 0x02	; 2
   125f2:	08 f0       	brcs	.+2      	; 0x125f6 <FMenuLoyalty+0x44>
   125f4:	61 c0       	rjmp	.+194    	; 0x126b8 <FMenuLoyalty+0x106>
   125f6:	20 c0       	rjmp	.+64     	; 0x12638 <FMenuLoyalty+0x86>
   125f8:	05 30       	cpi	r16, 0x05	; 5
   125fa:	09 f4       	brne	.+2      	; 0x125fe <FMenuLoyalty+0x4c>
   125fc:	a2 c0       	rjmp	.+324    	; 0x12742 <FMenuLoyalty+0x190>
   125fe:	06 30       	cpi	r16, 0x06	; 6
   12600:	08 f0       	brcs	.+2      	; 0x12604 <FMenuLoyalty+0x52>
   12602:	ba c0       	rjmp	.+372    	; 0x12778 <FMenuLoyalty+0x1c6>
   12604:	8c c0       	rjmp	.+280    	; 0x1271e <FMenuLoyalty+0x16c>
   12606:	0b 30       	cpi	r16, 0x0B	; 11
   12608:	09 f4       	brne	.+2      	; 0x1260c <FMenuLoyalty+0x5a>
   1260a:	36 c1       	rjmp	.+620    	; 0x12878 <FMenuLoyalty+0x2c6>
   1260c:	0c 30       	cpi	r16, 0x0C	; 12
   1260e:	38 f4       	brcc	.+14     	; 0x1261e <FMenuLoyalty+0x6c>
   12610:	09 30       	cpi	r16, 0x09	; 9
   12612:	09 f4       	brne	.+2      	; 0x12616 <FMenuLoyalty+0x64>
   12614:	f0 c0       	rjmp	.+480    	; 0x127f6 <FMenuLoyalty+0x244>
   12616:	0a 30       	cpi	r16, 0x0A	; 10
   12618:	08 f0       	brcs	.+2      	; 0x1261c <FMenuLoyalty+0x6a>
   1261a:	10 c1       	rjmp	.+544    	; 0x1283c <FMenuLoyalty+0x28a>
   1261c:	e6 c0       	rjmp	.+460    	; 0x127ea <FMenuLoyalty+0x238>
   1261e:	0d 30       	cpi	r16, 0x0D	; 13
   12620:	09 f4       	brne	.+2      	; 0x12624 <FMenuLoyalty+0x72>
   12622:	ee c1       	rjmp	.+988    	; 0x12a00 <FMenuLoyalty+0x44e>
   12624:	0d 30       	cpi	r16, 0x0D	; 13
   12626:	08 f4       	brcc	.+2      	; 0x1262a <FMenuLoyalty+0x78>
   12628:	f5 c1       	rjmp	.+1002   	; 0x12a14 <FMenuLoyalty+0x462>
   1262a:	0e 30       	cpi	r16, 0x0E	; 14
   1262c:	09 f4       	brne	.+2      	; 0x12630 <FMenuLoyalty+0x7e>
   1262e:	04 c2       	rjmp	.+1032   	; 0x12a38 <FMenuLoyalty+0x486>
   12630:	0f 30       	cpi	r16, 0x0F	; 15
   12632:	09 f0       	breq	.+2      	; 0x12636 <FMenuLoyalty+0x84>
   12634:	0d c2       	rjmp	.+1050   	; 0x12a50 <FMenuLoyalty+0x49e>
   12636:	06 c2       	rjmp	.+1036   	; 0x12a44 <FMenuLoyalty+0x492>
	 case mlInit:
	      lcd_clear();
   12638:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
   1263c:	81 e0       	ldi	r24, 0x01	; 1
   1263e:	61 e0       	ldi	r22, 0x01	; 1
   12640:	41 e5       	ldi	r20, 0x51	; 81
   12642:	5d e1       	ldi	r21, 0x1D	; 29
   12644:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
   12648:	81 e0       	ldi	r24, 0x01	; 1
   1264a:	61 e0       	ldi	r22, 0x01	; 1
   1264c:	4f e3       	ldi	r20, 0x3F	; 63
   1264e:	5d e1       	ldi	r21, 0x1D	; 29
   12650:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
   12654:	82 e0       	ldi	r24, 0x02	; 2
   12656:	61 e0       	ldi	r22, 0x01	; 1
   12658:	4d e2       	ldi	r20, 0x2D	; 45
   1265a:	5d e1       	ldi	r21, 0x1D	; 29
   1265c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
   12660:	84 e0       	ldi	r24, 0x04	; 4
   12662:	61 e0       	ldi	r22, 0x01	; 1
   12664:	4b e1       	ldi	r20, 0x1B	; 27
   12666:	5d e1       	ldi	r21, 0x1D	; 29
   12668:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  IsLoyaltyUpdate=False;
   1266c:	10 92 63 02 	sts	0x0263, r1
		  stLoyalty=mlLoyaltySelect;
   12670:	81 e0       	ldi	r24, 0x01	; 1
   12672:	08 c0       	rjmp	.+16     	; 0x12684 <FMenuLoyalty+0xd2>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
   12674:	81 e0       	ldi	r24, 0x01	; 1
   12676:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  if (KeyPressed==_KEY_1){
   1267a:	8e 3e       	cpi	r24, 0xEE	; 238
   1267c:	31 f4       	brne	.+12     	; 0x1268a <FMenuLoyalty+0xd8>
		      IsLoyaltyUpdate=False;
   1267e:	10 92 63 02 	sts	0x0263, r1
		      stLoyalty=mlShowEnquiry;
   12682:	84 e0       	ldi	r24, 0x04	; 4
   12684:	80 93 65 02 	sts	0x0265, r24
   12688:	e3 c1       	rjmp	.+966    	; 0x12a50 <FMenuLoyalty+0x49e>
			  }
		  else
		  if (KeyPressed==_KEY_2){
   1268a:	8e 3d       	cpi	r24, 0xDE	; 222
   1268c:	19 f4       	brne	.+6      	; 0x12694 <FMenuLoyalty+0xe2>
		      IsLoyaltyUpdate=True;
   1268e:	00 93 63 02 	sts	0x0263, r16
   12692:	69 c0       	rjmp	.+210    	; 0x12766 <FMenuLoyalty+0x1b4>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
   12694:	87 3e       	cpi	r24, 0xE7	; 231
   12696:	09 f4       	brne	.+2      	; 0x1269a <FMenuLoyalty+0xe8>
   12698:	d3 c1       	rjmp	.+934    	; 0x12a40 <FMenuLoyalty+0x48e>
   1269a:	da c1       	rjmp	.+948    	; 0x12a50 <FMenuLoyalty+0x49e>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   1269c:	84 e6       	ldi	r24, 0x64	; 100
   1269e:	92 e0       	ldi	r25, 0x02	; 2
   126a0:	69 eb       	ldi	r22, 0xB9	; 185
   126a2:	77 e0       	ldi	r23, 0x07	; 7
   126a4:	0e 94 25 58 	call	0xb04a	; 0xb04a <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
   126a8:	88 23       	and	r24, r24
   126aa:	11 f4       	brne	.+4      	; 0x126b0 <FMenuLoyalty+0xfe>
   126ac:	82 e0       	ldi	r24, 0x02	; 2
   126ae:	ea cf       	rjmp	.-44     	; 0x12684 <FMenuLoyalty+0xd2>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
   126b0:	82 30       	cpi	r24, 0x02	; 2
   126b2:	09 f0       	breq	.+2      	; 0x126b6 <FMenuLoyalty+0x104>
   126b4:	cd c1       	rjmp	.+922    	; 0x12a50 <FMenuLoyalty+0x49e>
   126b6:	59 c0       	rjmp	.+178    	; 0x1276a <FMenuLoyalty+0x1b8>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
   126b8:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
   126bc:	00 d0       	rcall	.+0      	; 0x126be <FMenuLoyalty+0x10c>
   126be:	00 d0       	rcall	.+0      	; 0x126c0 <FMenuLoyalty+0x10e>
   126c0:	00 d0       	rcall	.+0      	; 0x126c2 <FMenuLoyalty+0x110>
   126c2:	ed b7       	in	r30, 0x3d	; 61
   126c4:	fe b7       	in	r31, 0x3e	; 62
   126c6:	31 96       	adiw	r30, 0x01	; 1
   126c8:	8e 01       	movw	r16, r28
   126ca:	0f 5f       	subi	r16, 0xFF	; 255
   126cc:	1f 4f       	sbci	r17, 0xFF	; 255
   126ce:	ad b7       	in	r26, 0x3d	; 61
   126d0:	be b7       	in	r27, 0x3e	; 62
   126d2:	12 96       	adiw	r26, 0x02	; 2
   126d4:	1c 93       	st	X, r17
   126d6:	0e 93       	st	-X, r16
   126d8:	11 97       	sbiw	r26, 0x01	; 1
   126da:	84 e1       	ldi	r24, 0x14	; 20
   126dc:	9d e1       	ldi	r25, 0x1D	; 29
   126de:	93 83       	std	Z+3, r25	; 0x03
   126e0:	82 83       	std	Z+2, r24	; 0x02
   126e2:	89 eb       	ldi	r24, 0xB9	; 185
   126e4:	97 e0       	ldi	r25, 0x07	; 7
   126e6:	95 83       	std	Z+5, r25	; 0x05
   126e8:	84 83       	std	Z+4, r24	; 0x04
   126ea:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   126ee:	8d b7       	in	r24, 0x3d	; 61
   126f0:	9e b7       	in	r25, 0x3e	; 62
   126f2:	06 96       	adiw	r24, 0x06	; 6
   126f4:	0f b6       	in	r0, 0x3f	; 63
   126f6:	f8 94       	cli
   126f8:	9e bf       	out	0x3e, r25	; 62
   126fa:	0f be       	out	0x3f, r0	; 63
   126fc:	8d bf       	out	0x3d, r24	; 61
   126fe:	81 e0       	ldi	r24, 0x01	; 1
   12700:	61 e0       	ldi	r22, 0x01	; 1
   12702:	45 e0       	ldi	r20, 0x05	; 5
   12704:	5d e1       	ldi	r21, 0x1D	; 29
   12706:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_print(2,1,lcdteks);
   1270a:	82 e0       	ldi	r24, 0x02	; 2
   1270c:	61 e0       	ldi	r22, 0x01	; 1
   1270e:	a8 01       	movw	r20, r16
   12710:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   12714:	84 e0       	ldi	r24, 0x04	; 4
   12716:	61 e0       	ldi	r22, 0x01	; 1
   12718:	42 ef       	ldi	r20, 0xF2	; 242
   1271a:	5c e1       	ldi	r21, 0x1C	; 28
   1271c:	0c c0       	rjmp	.+24     	; 0x12736 <FMenuLoyalty+0x184>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
   1271e:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   12722:	81 e0       	ldi	r24, 0x01	; 1
   12724:	61 e0       	ldi	r22, 0x01	; 1
   12726:	43 ee       	ldi	r20, 0xE3	; 227
   12728:	5c e1       	ldi	r21, 0x1C	; 28
   1272a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   1272e:	84 e0       	ldi	r24, 0x04	; 4
   12730:	61 e0       	ldi	r22, 0x01	; 1
   12732:	40 ed       	ldi	r20, 0xD0	; 208
   12734:	5c e1       	ldi	r21, 0x1C	; 28
   12736:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  IsRFIDDetected=False;
   1273a:	10 92 98 01 	sts	0x0198, r1
		  stLoyalty=mlInputRFID;
   1273e:	85 e0       	ldi	r24, 0x05	; 5
   12740:	a1 cf       	rjmp	.-190    	; 0x12684 <FMenuLoyalty+0xd2>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
   12742:	80 91 98 01 	lds	r24, 0x0198
   12746:	81 30       	cpi	r24, 0x01	; 1
   12748:	29 f4       	brne	.+10     	; 0x12754 <FMenuLoyalty+0x1a2>
		      IsRFIDDetected=False;
   1274a:	10 92 98 01 	sts	0x0198, r1
		      stLoyalty=mlShowProsesRFID;
   1274e:	86 e0       	ldi	r24, 0x06	; 6
   12750:	80 93 65 02 	sts	0x0265, r24
		  }
	 	  KeyPressed=_key_scan(1);
   12754:	81 e0       	ldi	r24, 0x01	; 1
   12756:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
		  if (KeyPressed==_KEY_CANCEL){
   1275a:	87 3e       	cpi	r24, 0xE7	; 231
   1275c:	49 f4       	brne	.+18     	; 0x12770 <FMenuLoyalty+0x1be>
		      if (IsLoyaltyUpdate==True)
   1275e:	80 91 63 02 	lds	r24, 0x0263
   12762:	81 30       	cpi	r24, 0x01	; 1
   12764:	11 f4       	brne	.+4      	; 0x1276a <FMenuLoyalty+0x1b8>
			       stLoyalty=mlSelectFIP;
   12766:	83 e0       	ldi	r24, 0x03	; 3
   12768:	8d cf       	rjmp	.-230    	; 0x12684 <FMenuLoyalty+0xd2>
			  else stLoyalty=mlInit;
   1276a:	10 92 65 02 	sts	0x0265, r1
   1276e:	70 c1       	rjmp	.+736    	; 0x12a50 <FMenuLoyalty+0x49e>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
   12770:	87 3b       	cpi	r24, 0xB7	; 183
   12772:	09 f0       	breq	.+2      	; 0x12776 <FMenuLoyalty+0x1c4>
   12774:	6d c1       	rjmp	.+730    	; 0x12a50 <FMenuLoyalty+0x49e>
   12776:	64 c1       	rjmp	.+712    	; 0x12a40 <FMenuLoyalty+0x48e>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
   12778:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
   1277c:	00 d0       	rcall	.+0      	; 0x1277e <FMenuLoyalty+0x1cc>
   1277e:	00 d0       	rcall	.+0      	; 0x12780 <FMenuLoyalty+0x1ce>
   12780:	00 d0       	rcall	.+0      	; 0x12782 <FMenuLoyalty+0x1d0>
   12782:	ed b7       	in	r30, 0x3d	; 61
   12784:	fe b7       	in	r31, 0x3e	; 62
   12786:	31 96       	adiw	r30, 0x01	; 1
   12788:	8e 01       	movw	r16, r28
   1278a:	0f 5f       	subi	r16, 0xFF	; 255
   1278c:	1f 4f       	sbci	r17, 0xFF	; 255
   1278e:	ad b7       	in	r26, 0x3d	; 61
   12790:	be b7       	in	r27, 0x3e	; 62
   12792:	12 96       	adiw	r26, 0x02	; 2
   12794:	1c 93       	st	X, r17
   12796:	0e 93       	st	-X, r16
   12798:	11 97       	sbiw	r26, 0x01	; 1
   1279a:	8a ec       	ldi	r24, 0xCA	; 202
   1279c:	9c e1       	ldi	r25, 0x1C	; 28
   1279e:	93 83       	std	Z+3, r25	; 0x03
   127a0:	82 83       	std	Z+2, r24	; 0x02
   127a2:	81 e5       	ldi	r24, 0x51	; 81
   127a4:	9c e0       	ldi	r25, 0x0C	; 12
   127a6:	95 83       	std	Z+5, r25	; 0x05
   127a8:	84 83       	std	Z+4, r24	; 0x04
   127aa:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
   127ae:	8d b7       	in	r24, 0x3d	; 61
   127b0:	9e b7       	in	r25, 0x3e	; 62
   127b2:	06 96       	adiw	r24, 0x06	; 6
   127b4:	0f b6       	in	r0, 0x3f	; 63
   127b6:	f8 94       	cli
   127b8:	9e bf       	out	0x3e, r25	; 62
   127ba:	0f be       	out	0x3f, r0	; 63
   127bc:	8d bf       	out	0x3d, r24	; 61
   127be:	81 e0       	ldi	r24, 0x01	; 1
   127c0:	61 e0       	ldi	r22, 0x01	; 1
   127c2:	a8 01       	movw	r20, r16
   127c4:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
   127c8:	82 e0       	ldi	r24, 0x02	; 2
   127ca:	61 e0       	ldi	r22, 0x01	; 1
   127cc:	43 ec       	ldi	r20, 0xC3	; 195
   127ce:	5c e1       	ldi	r21, 0x1C	; 28
   127d0:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
   127d4:	80 91 63 02 	lds	r24, 0x0263
   127d8:	81 30       	cpi	r24, 0x01	; 1
   127da:	11 f4       	brne	.+4      	; 0x127e0 <FMenuLoyalty+0x22e>
   127dc:	88 e0       	ldi	r24, 0x08	; 8
   127de:	52 cf       	rjmp	.-348    	; 0x12684 <FMenuLoyalty+0xd2>
		  else stLoyalty=mlSendMessage22;
   127e0:	87 e0       	ldi	r24, 0x07	; 7
   127e2:	50 cf       	rjmp	.-352    	; 0x12684 <FMenuLoyalty+0xd2>
	      break;
     case mlSendMessage22:
	      sendMessage22();
   127e4:	0e 94 d5 92 	call	0x125aa	; 0x125aa <sendMessage22>
   127e8:	02 c0       	rjmp	.+4      	; 0x127ee <FMenuLoyalty+0x23c>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
   127ea:	0e 94 d1 92 	call	0x125a2	; 0x125a2 <sendMessage24>
		  TimSend=0;		  
   127ee:	10 92 78 0c 	sts	0x0C78, r1
          stLoyalty=mlWaitReply;
   127f2:	89 e0       	ldi	r24, 0x09	; 9
   127f4:	47 cf       	rjmp	.-370    	; 0x12684 <FMenuLoyalty+0xd2>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
   127f6:	80 91 78 0c 	lds	r24, 0x0C78
   127fa:	8f 31       	cpi	r24, 0x1F	; 31
   127fc:	18 f0       	brcs	.+6      	; 0x12804 <FMenuLoyalty+0x252>
		      stLoyalty=mlNoConnection;
   127fe:	8c e0       	ldi	r24, 0x0C	; 12
   12800:	80 93 65 02 	sts	0x0265, r24
	      if (IsMessage23==True){
   12804:	80 91 a2 01 	lds	r24, 0x01A2
   12808:	81 30       	cpi	r24, 0x01	; 1
   1280a:	39 f4       	brne	.+14     	; 0x1281a <FMenuLoyalty+0x268>
		      IsMessage23=False;
   1280c:	10 92 a2 01 	sts	0x01A2, r1
			  procMessage23();
   12810:	0e 94 4a 18 	call	0x3094	; 0x3094 <procMessage23>
			  stLoyalty=mlDispEnquiry;
   12814:	8b e0       	ldi	r24, 0x0B	; 11
   12816:	80 93 65 02 	sts	0x0265, r24
		  }
	      if (IsMessage09==True){
   1281a:	80 91 a3 01 	lds	r24, 0x01A3
   1281e:	81 30       	cpi	r24, 0x01	; 1
   12820:	39 f4       	brne	.+14     	; 0x12830 <FMenuLoyalty+0x27e>
		      IsMessage09=False;
   12822:	10 92 a3 01 	sts	0x01A3, r1
	          procMessage09();
   12826:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
   1282a:	8a e0       	ldi	r24, 0x0A	; 10
   1282c:	80 93 65 02 	sts	0x0265, r24
		  }
	      if (IsMessage99==True){
   12830:	80 91 9f 01 	lds	r24, 0x019F
   12834:	81 30       	cpi	r24, 0x01	; 1
   12836:	09 f0       	breq	.+2      	; 0x1283a <FMenuLoyalty+0x288>
   12838:	0b c1       	rjmp	.+534    	; 0x12a50 <FMenuLoyalty+0x49e>
   1283a:	1c c0       	rjmp	.+56     	; 0x12874 <FMenuLoyalty+0x2c2>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
   1283c:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   12840:	81 e0       	ldi	r24, 0x01	; 1
   12842:	61 e0       	ldi	r22, 0x01	; 1
   12844:	42 e9       	ldi	r20, 0x92	; 146
   12846:	58 e0       	ldi	r21, 0x08	; 8
   12848:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   1284c:	82 e0       	ldi	r24, 0x02	; 2
   1284e:	61 e0       	ldi	r22, 0x01	; 1
   12850:	43 ea       	ldi	r20, 0xA3	; 163
   12852:	57 e0       	ldi	r21, 0x07	; 7
   12854:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   12858:	83 e0       	ldi	r24, 0x03	; 3
   1285a:	61 e0       	ldi	r22, 0x01	; 1
   1285c:	4c e1       	ldi	r20, 0x1C	; 28
   1285e:	58 e0       	ldi	r21, 0x08	; 8
   12860:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   12864:	84 e0       	ldi	r24, 0x04	; 4
   12866:	61 e0       	ldi	r22, 0x01	; 1
   12868:	46 ed       	ldi	r20, 0xD6	; 214
   1286a:	5b e0       	ldi	r21, 0x0B	; 11
   1286c:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  TimDisplay=0;
   12870:	10 92 92 01 	sts	0x0192, r1
		  stLoyalty=mlDelayExitLoyalty;
   12874:	8e e0       	ldi	r24, 0x0E	; 14
   12876:	06 cf       	rjmp	.-500    	; 0x12684 <FMenuLoyalty+0xd2>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
   12878:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
   1287c:	e9 e8       	ldi	r30, 0x89	; 137
   1287e:	ce 2e       	mov	r12, r30
   12880:	eb e0       	ldi	r30, 0x0B	; 11
   12882:	de 2e       	mov	r13, r30
   12884:	c6 01       	movw	r24, r12
   12886:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
   1288a:	74 e2       	ldi	r23, 0x24	; 36
   1288c:	e7 2e       	mov	r14, r23
   1288e:	73 e0       	ldi	r23, 0x03	; 3
   12890:	f7 2e       	mov	r15, r23
   12892:	c7 01       	movw	r24, r14
   12894:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
   12898:	ad b7       	in	r26, 0x3d	; 61
   1289a:	be b7       	in	r27, 0x3e	; 62
   1289c:	18 97       	sbiw	r26, 0x08	; 8
   1289e:	0f b6       	in	r0, 0x3f	; 63
   128a0:	f8 94       	cli
   128a2:	be bf       	out	0x3e, r27	; 62
   128a4:	0f be       	out	0x3f, r0	; 63
   128a6:	ad bf       	out	0x3d, r26	; 61
   128a8:	ed b7       	in	r30, 0x3d	; 61
   128aa:	fe b7       	in	r31, 0x3e	; 62
   128ac:	31 96       	adiw	r30, 0x01	; 1
   128ae:	8e 01       	movw	r16, r28
   128b0:	0f 5f       	subi	r16, 0xFF	; 255
   128b2:	1f 4f       	sbci	r17, 0xFF	; 255
   128b4:	12 96       	adiw	r26, 0x02	; 2
   128b6:	1c 93       	st	X, r17
   128b8:	0e 93       	st	-X, r16
   128ba:	11 97       	sbiw	r26, 0x01	; 1
   128bc:	8d eb       	ldi	r24, 0xBD	; 189
   128be:	9c e1       	ldi	r25, 0x1C	; 28
   128c0:	93 83       	std	Z+3, r25	; 0x03
   128c2:	82 83       	std	Z+2, r24	; 0x02
   128c4:	d5 82       	std	Z+5, r13	; 0x05
   128c6:	c4 82       	std	Z+4, r12	; 0x04
   128c8:	f7 82       	std	Z+7, r15	; 0x07
   128ca:	e6 82       	std	Z+6, r14	; 0x06
   128cc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
   128d0:	8d b7       	in	r24, 0x3d	; 61
   128d2:	9e b7       	in	r25, 0x3e	; 62
   128d4:	08 96       	adiw	r24, 0x08	; 8
   128d6:	0f b6       	in	r0, 0x3f	; 63
   128d8:	f8 94       	cli
   128da:	9e bf       	out	0x3e, r25	; 62
   128dc:	0f be       	out	0x3f, r0	; 63
   128de:	8d bf       	out	0x3d, r24	; 61
   128e0:	81 e0       	ldi	r24, 0x01	; 1
   128e2:	61 e0       	ldi	r22, 0x01	; 1
   128e4:	a8 01       	movw	r20, r16
   128e6:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
   128ea:	65 e3       	ldi	r22, 0x35	; 53
   128ec:	e6 2e       	mov	r14, r22
   128ee:	68 e0       	ldi	r22, 0x08	; 8
   128f0:	f6 2e       	mov	r15, r22
   128f2:	c7 01       	movw	r24, r14
   128f4:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
   128f8:	00 d0       	rcall	.+0      	; 0x128fa <FMenuLoyalty+0x348>
   128fa:	00 d0       	rcall	.+0      	; 0x128fc <FMenuLoyalty+0x34a>
   128fc:	00 d0       	rcall	.+0      	; 0x128fe <FMenuLoyalty+0x34c>
   128fe:	ed b7       	in	r30, 0x3d	; 61
   12900:	fe b7       	in	r31, 0x3e	; 62
   12902:	31 96       	adiw	r30, 0x01	; 1
   12904:	ad b7       	in	r26, 0x3d	; 61
   12906:	be b7       	in	r27, 0x3e	; 62
   12908:	12 96       	adiw	r26, 0x02	; 2
   1290a:	1c 93       	st	X, r17
   1290c:	0e 93       	st	-X, r16
   1290e:	11 97       	sbiw	r26, 0x01	; 1
   12910:	83 eb       	ldi	r24, 0xB3	; 179
   12912:	9c e1       	ldi	r25, 0x1C	; 28
   12914:	93 83       	std	Z+3, r25	; 0x03
   12916:	82 83       	std	Z+2, r24	; 0x02
   12918:	f5 82       	std	Z+5, r15	; 0x05
   1291a:	e4 82       	std	Z+4, r14	; 0x04
   1291c:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
   12920:	8d b7       	in	r24, 0x3d	; 61
   12922:	9e b7       	in	r25, 0x3e	; 62
   12924:	06 96       	adiw	r24, 0x06	; 6
   12926:	0f b6       	in	r0, 0x3f	; 63
   12928:	f8 94       	cli
   1292a:	9e bf       	out	0x3e, r25	; 62
   1292c:	0f be       	out	0x3f, r0	; 63
   1292e:	8d bf       	out	0x3d, r24	; 61
   12930:	82 e0       	ldi	r24, 0x02	; 2
   12932:	61 e0       	ldi	r22, 0x01	; 1
   12934:	a8 01       	movw	r20, r16
   12936:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
   1293a:	c7 01       	movw	r24, r14
   1293c:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
   12940:	00 d0       	rcall	.+0      	; 0x12942 <FMenuLoyalty+0x390>
   12942:	00 d0       	rcall	.+0      	; 0x12944 <FMenuLoyalty+0x392>
   12944:	00 d0       	rcall	.+0      	; 0x12946 <FMenuLoyalty+0x394>
   12946:	ed b7       	in	r30, 0x3d	; 61
   12948:	fe b7       	in	r31, 0x3e	; 62
   1294a:	31 96       	adiw	r30, 0x01	; 1
   1294c:	ad b7       	in	r26, 0x3d	; 61
   1294e:	be b7       	in	r27, 0x3e	; 62
   12950:	12 96       	adiw	r26, 0x02	; 2
   12952:	1c 93       	st	X, r17
   12954:	0e 93       	st	-X, r16
   12956:	11 97       	sbiw	r26, 0x01	; 1
   12958:	89 ea       	ldi	r24, 0xA9	; 169
   1295a:	9c e1       	ldi	r25, 0x1C	; 28
   1295c:	93 83       	std	Z+3, r25	; 0x03
   1295e:	82 83       	std	Z+2, r24	; 0x02
   12960:	8e e7       	ldi	r24, 0x7E	; 126
   12962:	93 e0       	ldi	r25, 0x03	; 3
   12964:	95 83       	std	Z+5, r25	; 0x05
   12966:	84 83       	std	Z+4, r24	; 0x04
   12968:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
   1296c:	8d b7       	in	r24, 0x3d	; 61
   1296e:	9e b7       	in	r25, 0x3e	; 62
   12970:	06 96       	adiw	r24, 0x06	; 6
   12972:	0f b6       	in	r0, 0x3f	; 63
   12974:	f8 94       	cli
   12976:	9e bf       	out	0x3e, r25	; 62
   12978:	0f be       	out	0x3f, r0	; 63
   1297a:	8d bf       	out	0x3d, r24	; 61
   1297c:	83 e0       	ldi	r24, 0x03	; 3
   1297e:	61 e0       	ldi	r22, 0x01	; 1
   12980:	a8 01       	movw	r20, r16
   12982:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
   12986:	c7 01       	movw	r24, r14
   12988:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
   1298c:	00 d0       	rcall	.+0      	; 0x1298e <FMenuLoyalty+0x3dc>
   1298e:	00 d0       	rcall	.+0      	; 0x12990 <FMenuLoyalty+0x3de>
   12990:	00 d0       	rcall	.+0      	; 0x12992 <FMenuLoyalty+0x3e0>
   12992:	ed b7       	in	r30, 0x3d	; 61
   12994:	fe b7       	in	r31, 0x3e	; 62
   12996:	31 96       	adiw	r30, 0x01	; 1
   12998:	ad b7       	in	r26, 0x3d	; 61
   1299a:	be b7       	in	r27, 0x3e	; 62
   1299c:	12 96       	adiw	r26, 0x02	; 2
   1299e:	1c 93       	st	X, r17
   129a0:	0e 93       	st	-X, r16
   129a2:	11 97       	sbiw	r26, 0x01	; 1
   129a4:	8f e9       	ldi	r24, 0x9F	; 159
   129a6:	9c e1       	ldi	r25, 0x1C	; 28
   129a8:	93 83       	std	Z+3, r25	; 0x03
   129aa:	82 83       	std	Z+2, r24	; 0x02
   129ac:	8d ee       	ldi	r24, 0xED	; 237
   129ae:	9b e0       	ldi	r25, 0x0B	; 11
   129b0:	95 83       	std	Z+5, r25	; 0x05
   129b2:	84 83       	std	Z+4, r24	; 0x04
   129b4:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  lcd_print(4,1,lcdteks);
   129b8:	8d b7       	in	r24, 0x3d	; 61
   129ba:	9e b7       	in	r25, 0x3e	; 62
   129bc:	06 96       	adiw	r24, 0x06	; 6
   129be:	0f b6       	in	r0, 0x3f	; 63
   129c0:	f8 94       	cli
   129c2:	9e bf       	out	0x3e, r25	; 62
   129c4:	0f be       	out	0x3f, r0	; 63
   129c6:	8d bf       	out	0x3d, r24	; 61
   129c8:	84 e0       	ldi	r24, 0x04	; 4
   129ca:	61 e0       	ldi	r22, 0x01	; 1
   129cc:	a8 01       	movw	r20, r16
   129ce:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
		  TimDisplay=0;
   129d2:	10 92 92 01 	sts	0x0192, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   129d6:	e1 99       	sbic	0x1c, 1	; 28
   129d8:	fe cf       	rjmp	.-4      	; 0x129d6 <FMenuLoyalty+0x424>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   129da:	88 e3       	ldi	r24, 0x38	; 56
   129dc:	90 e0       	ldi	r25, 0x00	; 0
   129de:	9f bb       	out	0x1f, r25	; 31
   129e0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   129e2:	e0 9a       	sbi	0x1c, 0	; 28
   129e4:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
   129e6:	81 30       	cpi	r24, 0x01	; 1
   129e8:	09 f0       	breq	.+2      	; 0x129ec <FMenuLoyalty+0x43a>
   129ea:	44 cf       	rjmp	.-376    	; 0x12874 <FMenuLoyalty+0x2c2>
		      stLoyalty=mlPressAnyKey;
   129ec:	8d e0       	ldi	r24, 0x0D	; 13
   129ee:	80 93 65 02 	sts	0x0265, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
   129f2:	82 e0       	ldi	r24, 0x02	; 2
   129f4:	61 e0       	ldi	r22, 0x01	; 1
   129f6:	41 e9       	ldi	r20, 0x91	; 145
   129f8:	5c e1       	ldi	r21, 0x1C	; 28
   129fa:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
   129fe:	28 c0       	rjmp	.+80     	; 0x12a50 <FMenuLoyalty+0x49e>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
   12a00:	81 e0       	ldi	r24, 0x01	; 1
   12a02:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
   12a06:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>
	      switch(KeyChar){		  
   12a0a:	83 32       	cpi	r24, 0x23	; 35
   12a0c:	c9 f0       	breq	.+50     	; 0x12a40 <FMenuLoyalty+0x48e>
   12a0e:	8a 32       	cpi	r24, 0x2A	; 42
   12a10:	f9 f4       	brne	.+62     	; 0x12a50 <FMenuLoyalty+0x49e>
   12a12:	16 c0       	rjmp	.+44     	; 0x12a40 <FMenuLoyalty+0x48e>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
   12a14:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   12a18:	82 e0       	ldi	r24, 0x02	; 2
   12a1a:	61 e0       	ldi	r22, 0x01	; 1
   12a1c:	43 e8       	ldi	r20, 0x83	; 131
   12a1e:	5c e1       	ldi	r21, 0x1C	; 28
   12a20:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   12a24:	83 e0       	ldi	r24, 0x03	; 3
   12a26:	61 e0       	ldi	r22, 0x01	; 1
   12a28:	45 e7       	ldi	r20, 0x75	; 117
   12a2a:	5c e1       	ldi	r21, 0x1C	; 28
   12a2c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		  TimDisplay=5;
   12a30:	85 e0       	ldi	r24, 0x05	; 5
   12a32:	80 93 92 01 	sts	0x0192, r24
   12a36:	1e cf       	rjmp	.-452    	; 0x12874 <FMenuLoyalty+0x2c2>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
   12a38:	80 91 92 01 	lds	r24, 0x0192
   12a3c:	8a 30       	cpi	r24, 0x0A	; 10
   12a3e:	40 f0       	brcs	.+16     	; 0x12a50 <FMenuLoyalty+0x49e>
   12a40:	8f e0       	ldi	r24, 0x0F	; 15
   12a42:	20 ce       	rjmp	.-960    	; 0x12684 <FMenuLoyalty+0xd2>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
   12a44:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	      stLoyalty=mlInit;
   12a48:	10 92 65 02 	sts	0x0265, r1
   12a4c:	81 e0       	ldi	r24, 0x01	; 1
   12a4e:	01 c0       	rjmp	.+2      	; 0x12a52 <FMenuLoyalty+0x4a0>
   12a50:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
   12a52:	64 96       	adiw	r28, 0x14	; 20
   12a54:	0f b6       	in	r0, 0x3f	; 63
   12a56:	f8 94       	cli
   12a58:	de bf       	out	0x3e, r29	; 62
   12a5a:	0f be       	out	0x3f, r0	; 63
   12a5c:	cd bf       	out	0x3d, r28	; 61
   12a5e:	cf 91       	pop	r28
   12a60:	df 91       	pop	r29
   12a62:	1f 91       	pop	r17
   12a64:	0f 91       	pop	r16
   12a66:	ff 90       	pop	r15
   12a68:	ef 90       	pop	r14
   12a6a:	df 90       	pop	r13
   12a6c:	cf 90       	pop	r12
   12a6e:	08 95       	ret

00012a70 <sendMessage10>:
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	IsNewPacket=True;
	*/
	IsNewPacket=True;
   12a70:	81 e0       	ldi	r24, 0x01	; 1
   12a72:	80 93 88 01 	sts	0x0188, r24
	IFTSendMessage(MSG_10);
   12a76:	80 e1       	ldi	r24, 0x10	; 16
   12a78:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   12a7c:	08 95       	ret

00012a7e <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
   12a7e:	af 92       	push	r10
   12a80:	bf 92       	push	r11
   12a82:	cf 92       	push	r12
   12a84:	df 92       	push	r13
   12a86:	ef 92       	push	r14
   12a88:	ff 92       	push	r15
   12a8a:	0f 93       	push	r16
   12a8c:	1f 93       	push	r17
   12a8e:	df 93       	push	r29
   12a90:	cf 93       	push	r28
   12a92:	cd b7       	in	r28, 0x3d	; 61
   12a94:	de b7       	in	r29, 0x3e	; 62
   12a96:	64 97       	sbiw	r28, 0x14	; 20
   12a98:	0f b6       	in	r0, 0x3f	; 63
   12a9a:	f8 94       	cli
   12a9c:	de bf       	out	0x3e, r29	; 62
   12a9e:	0f be       	out	0x3f, r0	; 63
   12aa0:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12aa2:	e1 99       	sbic	0x1c, 1	; 28
   12aa4:	fe cf       	rjmp	.-4      	; 0x12aa2 <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12aa6:	16 e3       	ldi	r17, 0x36	; 54
   12aa8:	a1 2e       	mov	r10, r17
   12aaa:	11 e0       	ldi	r17, 0x01	; 1
   12aac:	b1 2e       	mov	r11, r17
   12aae:	bf ba       	out	0x1f, r11	; 31
   12ab0:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12ab2:	e0 9a       	sbi	0x1c, 0	; 28
   12ab4:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0,KeyPressed;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
   12ab6:	90 93 00 01 	sts	0x0100, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12aba:	e1 99       	sbic	0x1c, 1	; 28
   12abc:	fe cf       	rjmp	.-4      	; 0x12aba <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12abe:	b7 e3       	ldi	r27, 0x37	; 55
   12ac0:	cb 2e       	mov	r12, r27
   12ac2:	b1 e0       	ldi	r27, 0x01	; 1
   12ac4:	db 2e       	mov	r13, r27
   12ac6:	df ba       	out	0x1f, r13	; 31
   12ac8:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12aca:	e0 9a       	sbi	0x1c, 0	; 28
   12acc:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
   12ace:	80 93 5e 01 	sts	0x015E, r24

	//SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);

    //Send Msg10
	if  (IFType==IT_SLAVE){
   12ad2:	91 30       	cpi	r25, 0x01	; 1
   12ad4:	09 f0       	breq	.+2      	; 0x12ad8 <InitializeConnection+0x5a>
   12ad6:	5f c0       	rjmp	.+190    	; 0x12b96 <InitializeConnection+0x118>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
   12ad8:	81 e0       	ldi	r24, 0x01	; 1
   12ada:	60 e0       	ldi	r22, 0x00	; 0
   12adc:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
		 char_count=0;
   12ae0:	10 92 8a 01 	sts	0x018A, r1
   12ae4:	10 92 89 01 	sts	0x0189, r1
		 if (IsPowerOn==True){
   12ae8:	80 91 ba 02 	lds	r24, 0x02BA
   12aec:	81 30       	cpi	r24, 0x01	; 1
   12aee:	59 f4       	brne	.+22     	; 0x12b06 <InitializeConnection+0x88>
		     IsPowerOn=False;
   12af0:	10 92 ba 02 	sts	0x02BA, r1
   12af4:	8f ef       	ldi	r24, 0xFF	; 255
   12af6:	9f ef       	ldi	r25, 0xFF	; 255
   12af8:	20 e7       	ldi	r18, 0x70	; 112
   12afa:	31 e0       	ldi	r19, 0x01	; 1
   12afc:	f9 01       	movw	r30, r18
   12afe:	31 97       	sbiw	r30, 0x01	; 1
   12b00:	f1 f7       	brne	.-4      	; 0x12afe <InitializeConnection+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   12b02:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   12b04:	d9 f7       	brne	.-10     	; 0x12afc <InitializeConnection+0x7e>
		     _delay_ms(8000);
			 }
         sendMessage10();
   12b06:	0e 94 38 95 	call	0x12a70	; 0x12a70 <sendMessage10>
         sendMessage10();
   12b0a:	0e 94 38 95 	call	0x12a70	; 0x12a70 <sendMessage10>
         sendMessage10();
   12b0e:	0e 94 38 95 	call	0x12a70	; 0x12a70 <sendMessage10>
         

         lcd_printf(4,1,PSTR("Connect         "));
   12b12:	84 e0       	ldi	r24, 0x04	; 4
   12b14:	61 e0       	ldi	r22, 0x01	; 1
   12b16:	49 ee       	ldi	r20, 0xE9	; 233
   12b18:	5e e1       	ldi	r21, 0x1E	; 30
   12b1a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
   12b1e:	84 e0       	ldi	r24, 0x04	; 4
   12b20:	61 e0       	ldi	r22, 0x01	; 1
   12b22:	41 ee       	ldi	r20, 0xE1	; 225
   12b24:	5e e1       	ldi	r21, 0x1E	; 30
   12b26:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
   12b2a:	10 92 a0 01 	sts	0x01A0, r1
   12b2e:	ee 24       	eor	r14, r14
   12b30:	ff 24       	eor	r15, r15
   12b32:	00 e0       	ldi	r16, 0x00	; 0
   12b34:	10 e0       	ldi	r17, 0x00	; 0
   12b36:	2b c0       	rjmp	.+86     	; 0x12b8e <InitializeConnection+0x110>
		  //SlaveIdentification		  
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
   12b38:	60 2f       	mov	r22, r16
   12b3a:	68 5f       	subi	r22, 0xF8	; 248
   12b3c:	84 e0       	ldi	r24, 0x04	; 4
   12b3e:	4e e2       	ldi	r20, 0x2E	; 46
   12b40:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
                tConnect++;
   12b44:	08 94       	sec
   12b46:	e1 1c       	adc	r14, r1
   12b48:	f1 1c       	adc	r15, r1
				__key_lgtcnt=0;
   12b4a:	10 92 af 02 	sts	0x02AF, r1
			    if ((tConnect%200)==0)iCon++;
   12b4e:	c7 01       	movw	r24, r14
   12b50:	68 ec       	ldi	r22, 0xC8	; 200
   12b52:	70 e0       	ldi	r23, 0x00	; 0
   12b54:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
   12b58:	89 2b       	or	r24, r25
   12b5a:	09 f4       	brne	.+2      	; 0x12b5e <InitializeConnection+0xe0>
   12b5c:	0f 5f       	subi	r16, 0xFF	; 255
			    if (iCon>8){
   12b5e:	09 30       	cpi	r16, 0x09	; 9
   12b60:	70 f0       	brcs	.+28     	; 0x12b7e <InitializeConnection+0x100>
			        lcd_printf(4,1,PSTR("Connect         "));
   12b62:	84 e0       	ldi	r24, 0x04	; 4
   12b64:	61 e0       	ldi	r22, 0x01	; 1
   12b66:	40 ed       	ldi	r20, 0xD0	; 208
   12b68:	5e e1       	ldi	r21, 0x1E	; 30
   12b6a:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
					
				    sendMessage10();
   12b6e:	0e 94 38 95 	call	0x12a70	; 0x12a70 <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
   12b72:	81 e0       	ldi	r24, 0x01	; 1
   12b74:	60 e0       	ldi	r22, 0x00	; 0
   12b76:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
   12b7a:	1f 5f       	subi	r17, 0xFF	; 255
   12b7c:	00 e0       	ldi	r16, 0x00	; 0
			    if (iTry>3){
   12b7e:	14 30       	cpi	r17, 0x04	; 4
   12b80:	30 f0       	brcs	.+12     	; 0x12b8e <InitializeConnection+0x110>
			        //IsErrorTCPIP=True;
				    IsAdvanzStartupInfo=False;		
   12b82:	10 92 aa 01 	sts	0x01AA, r1
					IFType=IT_STANDALONE;
   12b86:	82 e0       	ldi	r24, 0x02	; 2
   12b88:	80 93 00 01 	sts	0x0100, r24
   12b8c:	04 c0       	rjmp	.+8      	; 0x12b96 <InitializeConnection+0x118>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification		  
		 while (IsMessage11==False){
   12b8e:	80 91 a0 01 	lds	r24, 0x01A0
   12b92:	88 23       	and	r24, r24
   12b94:	89 f2       	breq	.-94     	; 0x12b38 <InitializeConnection+0xba>

			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
   12b96:	80 91 00 01 	lds	r24, 0x0100
   12b9a:	82 30       	cpi	r24, 0x02	; 2
   12b9c:	09 f0       	breq	.+2      	; 0x12ba0 <InitializeConnection+0x122>
   12b9e:	74 c0       	rjmp	.+232    	; 0x12c88 <InitializeConnection+0x20a>
        IsStandAloneDetected=False;		
   12ba0:	10 92 9c 01 	sts	0x019C, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
   12ba4:	60 91 5e 01 	lds	r22, 0x015E
   12ba8:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
   12bac:	0e 94 d9 a9 	call	0x153b2	; 0x153b2 <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
   12bb0:	81 e0       	ldi	r24, 0x01	; 1
   12bb2:	61 e0       	ldi	r22, 0x01	; 1
   12bb4:	46 ec       	ldi	r20, 0xC6	; 198
   12bb6:	5e e1       	ldi	r21, 0x1E	; 30
   12bb8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12bbc:	e1 99       	sbic	0x1c, 1	; 28
   12bbe:	fe cf       	rjmp	.-4      	; 0x12bbc <InitializeConnection+0x13e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12bc0:	df ba       	out	0x1f, r13	; 31
   12bc2:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12bc4:	e0 9a       	sbi	0x1c, 0	; 28
   12bc6:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
   12bc8:	e8 2f       	mov	r30, r24
   12bca:	f0 e0       	ldi	r31, 0x00	; 0
   12bcc:	ee 0f       	add	r30, r30
   12bce:	ff 1f       	adc	r31, r31
   12bd0:	eb 5f       	subi	r30, 0xFB	; 251
   12bd2:	fc 4f       	sbci	r31, 0xFC	; 252
   12bd4:	65 91       	lpm	r22, Z+
   12bd6:	74 91       	lpm	r23, Z+
   12bd8:	8e 01       	movw	r16, r28
   12bda:	0f 5f       	subi	r16, 0xFF	; 255
   12bdc:	1f 4f       	sbci	r17, 0xFF	; 255
   12bde:	c8 01       	movw	r24, r16
   12be0:	0e 94 75 af 	call	0x15eea	; 0x15eea <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
   12be4:	00 d0       	rcall	.+0      	; 0x12be6 <InitializeConnection+0x168>
   12be6:	00 d0       	rcall	.+0      	; 0x12be8 <InitializeConnection+0x16a>
   12be8:	00 d0       	rcall	.+0      	; 0x12bea <InitializeConnection+0x16c>
   12bea:	ed b7       	in	r30, 0x3d	; 61
   12bec:	fe b7       	in	r31, 0x3e	; 62
   12bee:	31 96       	adiw	r30, 0x01	; 1
   12bf0:	ad b7       	in	r26, 0x3d	; 61
   12bf2:	be b7       	in	r27, 0x3e	; 62
   12bf4:	12 96       	adiw	r26, 0x02	; 2
   12bf6:	1c 93       	st	X, r17
   12bf8:	0e 93       	st	-X, r16
   12bfa:	11 97       	sbiw	r26, 0x01	; 1
   12bfc:	83 ec       	ldi	r24, 0xC3	; 195
   12bfe:	9e e1       	ldi	r25, 0x1E	; 30
   12c00:	93 83       	std	Z+3, r25	; 0x03
   12c02:	82 83       	std	Z+2, r24	; 0x02
   12c04:	15 83       	std	Z+5, r17	; 0x05
   12c06:	04 83       	std	Z+4, r16	; 0x04
   12c08:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	    lcd_print(2,1,lcdteks);
   12c0c:	8d b7       	in	r24, 0x3d	; 61
   12c0e:	9e b7       	in	r25, 0x3e	; 62
   12c10:	06 96       	adiw	r24, 0x06	; 6
   12c12:	0f b6       	in	r0, 0x3f	; 63
   12c14:	f8 94       	cli
   12c16:	9e bf       	out	0x3e, r25	; 62
   12c18:	0f be       	out	0x3f, r0	; 63
   12c1a:	8d bf       	out	0x3d, r24	; 61
   12c1c:	82 e0       	ldi	r24, 0x02	; 2
   12c1e:	61 e0       	ldi	r22, 0x01	; 1
   12c20:	a8 01       	movw	r20, r16
   12c22:	0e 94 80 a9 	call	0x15300	; 0x15300 <lcd_print>
   12c26:	00 e0       	ldi	r16, 0x00	; 0
   12c28:	10 e0       	ldi	r17, 0x00	; 0
   12c2a:	ff 24       	eor	r15, r15
   12c2c:	dd 24       	eor	r13, r13
   12c2e:	28 c0       	rjmp	.+80     	; 0x12c80 <InitializeConnection+0x202>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
   12c30:	ef 2c       	mov	r14, r15
   12c32:	e3 94       	inc	r14
   12c34:	84 e0       	ldi	r24, 0x04	; 4
   12c36:	6e 2d       	mov	r22, r14
   12c38:	4e e2       	ldi	r20, 0x2E	; 46
   12c3a:	0e 94 f2 a9 	call	0x153e4	; 0x153e4 <lcd_put>
		       tConnect++;
   12c3e:	0f 5f       	subi	r16, 0xFF	; 255
   12c40:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
   12c42:	c8 01       	movw	r24, r16
   12c44:	64 e6       	ldi	r22, 0x64	; 100
   12c46:	70 e0       	ldi	r23, 0x00	; 0
   12c48:	0e 94 9e b2 	call	0x1653c	; 0x1653c <__udivmodhi4>
   12c4c:	89 2b       	or	r24, r25
   12c4e:	09 f4       	brne	.+2      	; 0x12c52 <InitializeConnection+0x1d4>
   12c50:	fe 2c       	mov	r15, r14
		       if (iCon>16){
   12c52:	90 e1       	ldi	r25, 0x10	; 16
   12c54:	9f 15       	cp	r25, r15
   12c56:	88 f4       	brcc	.+34     	; 0x12c7a <InitializeConnection+0x1fc>
			       __key_lgtcnt=0;
   12c58:	10 92 af 02 	sts	0x02AF, r1
			       lcd_printf(4,1,PSTR("                   "));
   12c5c:	84 e0       	ldi	r24, 0x04	; 4
   12c5e:	61 e0       	ldi	r22, 0x01	; 1
   12c60:	4f ea       	ldi	r20, 0xAF	; 175
   12c62:	5e e1       	ldi	r21, 0x1E	; 30
   12c64:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
   12c68:	82 e0       	ldi	r24, 0x02	; 2
   12c6a:	60 91 5e 01 	lds	r22, 0x015E
   12c6e:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
   12c72:	0e 94 b7 4b 	call	0x976e	; 0x976e <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
   12c76:	d3 94       	inc	r13
   12c78:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
   12c7a:	a3 e0       	ldi	r26, 0x03	; 3
   12c7c:	ad 15       	cp	r26, r13
   12c7e:	20 f0       	brcs	.+8      	; 0x12c88 <InitializeConnection+0x20a>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
   12c80:	80 91 9c 01 	lds	r24, 0x019C
   12c84:	88 23       	and	r24, r24
   12c86:	a1 f2       	breq	.-88     	; 0x12c30 <InitializeConnection+0x1b2>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
   12c88:	80 91 a0 01 	lds	r24, 0x01A0
   12c8c:	81 30       	cpi	r24, 0x01	; 1
   12c8e:	09 f5       	brne	.+66     	; 0x12cd2 <InitializeConnection+0x254>
	   lcd_printf(4,1,PSTR("Connected           "));
   12c90:	84 e0       	ldi	r24, 0x04	; 4
   12c92:	61 e0       	ldi	r22, 0x01	; 1
   12c94:	4a e9       	ldi	r20, 0x9A	; 154
   12c96:	5e e1       	ldi	r21, 0x1E	; 30
   12c98:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   12c9c:	e1 99       	sbic	0x1c, 1	; 28
   12c9e:	fe cf       	rjmp	.-4      	; 0x12c9c <InitializeConnection+0x21e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12ca0:	bf ba       	out	0x1f, r11	; 31
   12ca2:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
   12ca4:	81 e0       	ldi	r24, 0x01	; 1
   12ca6:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   12ca8:	0f b6       	in	r0, 0x3f	; 63
   12caa:	f8 94       	cli
   12cac:	e2 9a       	sbi	0x1c, 2	; 28
   12cae:	e1 9a       	sbi	0x1c, 1	; 28
   12cb0:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
   12cb2:	80 93 00 01 	sts	0x0100, r24
   12cb6:	80 e3       	ldi	r24, 0x30	; 48
   12cb8:	95 e7       	ldi	r25, 0x75	; 117
   12cba:	20 e7       	ldi	r18, 0x70	; 112
   12cbc:	31 e0       	ldi	r19, 0x01	; 1
   12cbe:	f9 01       	movw	r30, r18
   12cc0:	31 97       	sbiw	r30, 0x01	; 1
   12cc2:	f1 f7       	brne	.-4      	; 0x12cc0 <InitializeConnection+0x242>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   12cc4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   12cc6:	d9 f7       	brne	.-10     	; 0x12cbe <InitializeConnection+0x240>
	   _delay_ms(3000);
	   //IsErrorTCPIP=False;
	   procMessage11();
   12cc8:	0e 94 66 48 	call	0x90cc	; 0x90cc <procMessage11>
	   IsAdvanzStartupInfo=True;
   12ccc:	81 e0       	ldi	r24, 0x01	; 1
   12cce:	80 93 aa 01 	sts	0x01AA, r24
	}
	if(IsStandAloneDetected==True){
   12cd2:	80 91 9c 01 	lds	r24, 0x019C
   12cd6:	81 30       	cpi	r24, 0x01	; 1
   12cd8:	99 f4       	brne	.+38     	; 0x12d00 <InitializeConnection+0x282>
	   lcd_printf(4,1,PSTR("PumpFound"));
   12cda:	84 e0       	ldi	r24, 0x04	; 4
   12cdc:	61 e0       	ldi	r22, 0x01	; 1
   12cde:	40 e9       	ldi	r20, 0x90	; 144
   12ce0:	5e e1       	ldi	r21, 0x1E	; 30
   12ce2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   12ce6:	e1 99       	sbic	0x1c, 1	; 28
   12ce8:	fe cf       	rjmp	.-4      	; 0x12ce6 <InitializeConnection+0x268>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12cea:	bf ba       	out	0x1f, r11	; 31
   12cec:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
   12cee:	82 e0       	ldi	r24, 0x02	; 2
   12cf0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   12cf2:	0f b6       	in	r0, 0x3f	; 63
   12cf4:	f8 94       	cli
   12cf6:	e2 9a       	sbi	0x1c, 2	; 28
   12cf8:	e1 9a       	sbi	0x1c, 1	; 28
   12cfa:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
   12cfc:	80 93 00 01 	sts	0x0100, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12d00:	e1 99       	sbic	0x1c, 1	; 28
   12d02:	fe cf       	rjmp	.-4      	; 0x12d00 <InitializeConnection+0x282>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12d04:	85 e3       	ldi	r24, 0x35	; 53
   12d06:	91 e0       	ldi	r25, 0x01	; 1
   12d08:	9f bb       	out	0x1f, r25	; 31
   12d0a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12d0c:	e0 9a       	sbi	0x1c, 0	; 28
   12d0e:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
   12d10:	81 30       	cpi	r24, 0x01	; 1
   12d12:	11 f4       	brne	.+4      	; 0x12d18 <InitializeConnection+0x29a>
   12d14:	0e 94 d1 35 	call	0x6ba2	; 0x6ba2 <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
   12d18:	80 91 9c 01 	lds	r24, 0x019C
   12d1c:	88 23       	and	r24, r24
   12d1e:	09 f0       	breq	.+2      	; 0x12d22 <InitializeConnection+0x2a4>
   12d20:	38 c0       	rjmp	.+112    	; 0x12d92 <InitializeConnection+0x314>
   12d22:	80 91 a0 01 	lds	r24, 0x01A0
   12d26:	88 23       	and	r24, r24
   12d28:	09 f0       	breq	.+2      	; 0x12d2c <InitializeConnection+0x2ae>
   12d2a:	33 c0       	rjmp	.+102    	; 0x12d92 <InitializeConnection+0x314>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
   12d2c:	82 e0       	ldi	r24, 0x02	; 2
   12d2e:	61 e0       	ldi	r22, 0x01	; 1
   12d30:	43 e8       	ldi	r20, 0x83	; 131
   12d32:	5e e1       	ldi	r21, 0x1E	; 30
   12d34:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
   12d38:	83 e0       	ldi	r24, 0x03	; 3
   12d3a:	61 e0       	ldi	r22, 0x01	; 1
   12d3c:	45 e7       	ldi	r20, 0x75	; 117
   12d3e:	5e e1       	ldi	r21, 0x1E	; 30
   12d40:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
   12d44:	80 e2       	ldi	r24, 0x20	; 32
   12d46:	9e e4       	ldi	r25, 0x4E	; 78
   12d48:	20 e7       	ldi	r18, 0x70	; 112
   12d4a:	31 e0       	ldi	r19, 0x01	; 1
   12d4c:	f9 01       	movw	r30, r18
   12d4e:	31 97       	sbiw	r30, 0x01	; 1
   12d50:	f1 f7       	brne	.-4      	; 0x12d4e <InitializeConnection+0x2d0>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   12d52:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   12d54:	d9 f7       	brne	.-10     	; 0x12d4c <InitializeConnection+0x2ce>
		 _delay_ms(2000);
		 ForceType=systemForceType();
   12d56:	0e 94 62 56 	call	0xacc4	; 0xacc4 <systemForceType>
		 if (ForceType=='1'){
   12d5a:	81 33       	cpi	r24, 0x31	; 49
   12d5c:	29 f4       	brne	.+10     	; 0x12d68 <InitializeConnection+0x2ea>
		     IFType=IT_SLAVE;
   12d5e:	81 e0       	ldi	r24, 0x01	; 1
   12d60:	80 93 00 01 	sts	0x0100, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
   12d64:	60 e0       	ldi	r22, 0x00	; 0
   12d66:	07 c0       	rjmp	.+14     	; 0x12d76 <InitializeConnection+0x2f8>
         }
		 else
		 if (ForceType=='2'){
   12d68:	82 33       	cpi	r24, 0x32	; 50
   12d6a:	39 f4       	brne	.+14     	; 0x12d7a <InitializeConnection+0x2fc>
		     IFType=IT_STANDALONE;
   12d6c:	82 e0       	ldi	r24, 0x02	; 2
   12d6e:	80 93 00 01 	sts	0x0100, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
   12d72:	60 91 5e 01 	lds	r22, 0x015E
   12d76:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
   12d7a:	80 91 00 01 	lds	r24, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   12d7e:	e1 99       	sbic	0x1c, 1	; 28
   12d80:	fe cf       	rjmp	.-4      	; 0x12d7e <InitializeConnection+0x300>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12d82:	bf ba       	out	0x1f, r11	; 31
   12d84:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
   12d86:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   12d88:	0f b6       	in	r0, 0x3f	; 63
   12d8a:	f8 94       	cli
   12d8c:	e2 9a       	sbi	0x1c, 2	; 28
   12d8e:	e1 9a       	sbi	0x1c, 1	; 28
   12d90:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12d92:	e1 99       	sbic	0x1c, 1	; 28
   12d94:	fe cf       	rjmp	.-4      	; 0x12d92 <InitializeConnection+0x314>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12d96:	84 e4       	ldi	r24, 0x44	; 68
   12d98:	91 e0       	ldi	r25, 0x01	; 1
   12d9a:	9f bb       	out	0x1f, r25	; 31
   12d9c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12d9e:	e0 9a       	sbi	0x1c, 0	; 28
   12da0:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
   12da2:	80 93 5c 01 	sts	0x015C, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12da6:	e1 99       	sbic	0x1c, 1	; 28
   12da8:	fe cf       	rjmp	.-4      	; 0x12da6 <InitializeConnection+0x328>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12daa:	89 e4       	ldi	r24, 0x49	; 73
   12dac:	91 e0       	ldi	r25, 0x01	; 1
   12dae:	9f bb       	out	0x1f, r25	; 31
   12db0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12db2:	e0 9a       	sbi	0x1c, 0	; 28
   12db4:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
   12db6:	80 93 5d 01 	sts	0x015D, r24
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
	//SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
	
}
   12dba:	64 96       	adiw	r28, 0x14	; 20
   12dbc:	0f b6       	in	r0, 0x3f	; 63
   12dbe:	f8 94       	cli
   12dc0:	de bf       	out	0x3e, r29	; 62
   12dc2:	0f be       	out	0x3f, r0	; 63
   12dc4:	cd bf       	out	0x3d, r28	; 61
   12dc6:	cf 91       	pop	r28
   12dc8:	df 91       	pop	r29
   12dca:	1f 91       	pop	r17
   12dcc:	0f 91       	pop	r16
   12dce:	ff 90       	pop	r15
   12dd0:	ef 90       	pop	r14
   12dd2:	df 90       	pop	r13
   12dd4:	cf 90       	pop	r12
   12dd6:	bf 90       	pop	r11
   12dd8:	af 90       	pop	r10
   12dda:	08 95       	ret

00012ddc <sendMessage04>:
	 UpdateServerIP();//ReadDestIP
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
     uart_print(1, 0,strSend);
	 uart(1, 1,0x02);
	 */IFTSendMessage(MSG_04);
   12ddc:	84 e0       	ldi	r24, 0x04	; 4
   12dde:	0e 94 f7 7d 	call	0xfbee	; 0xfbee <IFTSendMessage>
}
   12de2:	08 95       	ret

00012de4 <FreePrinting>:
	 } 
	 else uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
   12de4:	0f 93       	push	r16
   12de6:	1f 93       	push	r17
   12de8:	df 93       	push	r29
   12dea:	cf 93       	push	r28
   12dec:	cd b7       	in	r28, 0x3d	; 61
   12dee:	de b7       	in	r29, 0x3e	; 62
   12df0:	64 97       	sbiw	r28, 0x14	; 20
   12df2:	0f b6       	in	r0, 0x3f	; 63
   12df4:	f8 94       	cli
   12df6:	de bf       	out	0x3e, r29	; 62
   12df8:	0f be       	out	0x3f, r0	; 63
   12dfa:	cd bf       	out	0x3d, r28	; 61
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static unsigned int iSend=0,LSend=0,iLoop=0;
       char strOperatorName[20];

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
   12dfc:	20 91 a8 01 	lds	r18, 0x01A8
   12e00:	21 30       	cpi	r18, 0x01	; 1
   12e02:	31 f4       	brne	.+12     	; 0x12e10 <FreePrinting+0x2c>
   12e04:	80 91 25 01 	lds	r24, 0x0125
   12e08:	81 30       	cpi	r24, 0x01	; 1
   12e0a:	11 f0       	breq	.+4      	; 0x12e10 <FreePrinting+0x2c>
	     stFreePrinting=fpInit;
   12e0c:	20 93 25 01 	sts	0x0125, r18
	 }
	 switch (stFreePrinting){
   12e10:	80 91 25 01 	lds	r24, 0x0125
   12e14:	90 e0       	ldi	r25, 0x00	; 0
   12e16:	fc 01       	movw	r30, r24
   12e18:	31 97       	sbiw	r30, 0x01	; 1
   12e1a:	eb 31       	cpi	r30, 0x1B	; 27
   12e1c:	f1 05       	cpc	r31, r1
   12e1e:	08 f0       	brcs	.+2      	; 0x12e22 <FreePrinting+0x3e>
   12e20:	9f c3       	rjmp	.+1854   	; 0x13560 <FreePrinting+0x77c>
   12e22:	e3 53       	subi	r30, 0x33	; 51
   12e24:	ff 4f       	sbci	r31, 0xFF	; 255
   12e26:	ee 0f       	add	r30, r30
   12e28:	ff 1f       	adc	r31, r31
   12e2a:	05 90       	lpm	r0, Z+
   12e2c:	f4 91       	lpm	r31, Z+
   12e2e:	e0 2d       	mov	r30, r0
   12e30:	09 94       	ijmp
     case fpInit:
	      //uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
   12e32:	21 30       	cpi	r18, 0x01	; 1
   12e34:	09 f0       	breq	.+2      	; 0x12e38 <FreePrinting+0x54>
   12e36:	94 c3       	rjmp	.+1832   	; 0x13560 <FreePrinting+0x77c>
		      IsFreePrinting=False;
   12e38:	10 92 a8 01 	sts	0x01A8, r1
			  IsBusyFreePrinting=True;
   12e3c:	20 93 b4 01 	sts	0x01B4, r18
			  IsBusyPrint=False;
   12e40:	10 92 b3 01 	sts	0x01B3, r1
			  iPrinted=0,iFooter=0;
   12e44:	10 92 f5 01 	sts	0x01F5, r1
   12e48:	10 92 f3 01 	sts	0x01F3, r1

			  PrintCopy=(cmdPrint&0x0F);
   12e4c:	80 91 b5 01 	lds	r24, 0x01B5
   12e50:	8f 70       	andi	r24, 0x0F	; 15
   12e52:	80 93 f2 01 	sts	0x01F2, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
   12e56:	82 e0       	ldi	r24, 0x02	; 2
   12e58:	80 93 25 01 	sts	0x0125, r24
			  InitPrinter();
   12e5c:	0e 94 ad 47 	call	0x8f5a	; 0x8f5a <InitPrinter>
   12e60:	7f c3       	rjmp	.+1790   	; 0x13560 <FreePrinting+0x77c>
			  }
	      break;
     case fpInitHeader:
	      //uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
   12e62:	10 92 f4 01 	sts	0x01F4, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
   12e66:	80 91 b5 01 	lds	r24, 0x01B5
   12e6a:	88 1f       	adc	r24, r24
   12e6c:	88 27       	eor	r24, r24
   12e6e:	88 1f       	adc	r24, r24
   12e70:	90 e0       	ldi	r25, 0x00	; 0
   12e72:	81 30       	cpi	r24, 0x01	; 1
   12e74:	91 05       	cpc	r25, r1
   12e76:	21 f1       	breq	.+72     	; 0x12ec0 <FreePrinting+0xdc>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
   12e78:	89 2b       	or	r24, r25
   12e7a:	09 f0       	breq	.+2      	; 0x12e7e <FreePrinting+0x9a>
   12e7c:	71 c3       	rjmp	.+1762   	; 0x13560 <FreePrinting+0x77c>
   12e7e:	85 e0       	ldi	r24, 0x05	; 5
   12e80:	80 93 25 01 	sts	0x0125, r24
   12e84:	6d c3       	rjmp	.+1754   	; 0x13560 <FreePrinting+0x77c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   12e86:	60 91 f4 01 	lds	r22, 0x01F4
   12e8a:	89 e2       	ldi	r24, 0x29	; 41
   12e8c:	68 9f       	mul	r22, r24
   12e8e:	b0 01       	movw	r22, r0
   12e90:	11 24       	eor	r1, r1
   12e92:	69 5d       	subi	r22, 0xD9	; 217
   12e94:	7d 4f       	sbci	r23, 0xFD	; 253
   12e96:	8c eb       	ldi	r24, 0xBC	; 188
   12e98:	98 e0       	ldi	r25, 0x08	; 8
   12e9a:	48 e2       	ldi	r20, 0x28	; 40
   12e9c:	50 e0       	ldi	r21, 0x00	; 0
   12e9e:	22 ed       	ldi	r18, 0xD2	; 210
   12ea0:	33 e1       	ldi	r19, 0x13	; 19
   12ea2:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	      break;
     case fpLoadHeader:
	      //uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
   12ea6:	80 91 f4 01 	lds	r24, 0x01F4
   12eaa:	8f 5f       	subi	r24, 0xFF	; 255
   12eac:	80 93 f4 01 	sts	0x01F4, r24
		  if (iHeader<6){
   12eb0:	86 30       	cpi	r24, 0x06	; 6
   12eb2:	28 f7       	brcc	.-54     	; 0x12e7e <FreePrinting+0x9a>
		      if (SpaceOnly(strPrint)==True){
   12eb4:	8c eb       	ldi	r24, 0xBC	; 188
   12eb6:	98 e0       	ldi	r25, 0x08	; 8
   12eb8:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   12ebc:	81 30       	cpi	r24, 0x01	; 1
   12ebe:	11 f4       	brne	.+4      	; 0x12ec4 <FreePrinting+0xe0>
			      stFreePrinting=fpLoadHeader;
   12ec0:	83 e0       	ldi	r24, 0x03	; 3
   12ec2:	de cf       	rjmp	.-68     	; 0x12e80 <FreePrinting+0x9c>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
   12ec4:	84 e0       	ldi	r24, 0x04	; 4
   12ec6:	80 93 25 01 	sts	0x0125, r24
			      iSend=0;
   12eca:	10 92 ee 01 	sts	0x01EE, r1
   12ece:	10 92 ed 01 	sts	0x01ED, r1
				  iLoop=0;
   12ed2:	10 92 ea 01 	sts	0x01EA, r1
   12ed6:	10 92 e9 01 	sts	0x01E9, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
   12eda:	80 91 f4 01 	lds	r24, 0x01F4
   12ede:	81 30       	cpi	r24, 0x01	; 1
   12ee0:	19 f4       	brne	.+6      	; 0x12ee8 <FreePrinting+0x104>
   12ee2:	0e 94 2f 48 	call	0x905e	; 0x905e <PrintDoubleHeight>
   12ee6:	3c c3       	rjmp	.+1656   	; 0x13560 <FreePrinting+0x77c>
				  else 
				  if (iHeader==2) PrintNormalHeight();
   12ee8:	82 30       	cpi	r24, 0x02	; 2
   12eea:	09 f0       	breq	.+2      	; 0x12eee <FreePrinting+0x10a>
   12eec:	39 c3       	rjmp	.+1650   	; 0x13560 <FreePrinting+0x77c>
   12eee:	0e 94 15 48 	call	0x902a	; 0x902a <PrintNormalHeight>
   12ef2:	36 c3       	rjmp	.+1644   	; 0x13560 <FreePrinting+0x77c>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
   12ef4:	80 91 ed 01 	lds	r24, 0x01ED
   12ef8:	90 91 ee 01 	lds	r25, 0x01EE
   12efc:	88 97       	sbiw	r24, 0x28	; 40
   12efe:	68 f4       	brcc	.+26     	; 0x12f1a <FreePrinting+0x136>
		      iLoop++;
   12f00:	80 91 e9 01 	lds	r24, 0x01E9
   12f04:	90 91 ea 01 	lds	r25, 0x01EA
   12f08:	01 96       	adiw	r24, 0x01	; 1
   12f0a:	90 93 ea 01 	sts	0x01EA, r25
   12f0e:	80 93 e9 01 	sts	0x01E9, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //uart(_COM_PRINTER,1,strPrint[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
   12f12:	10 92 b6 01 	sts	0x01B6, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
   12f16:	82 e1       	ldi	r24, 0x12	; 18
   12f18:	b3 cf       	rjmp	.-154    	; 0x12e80 <FreePrinting+0x9c>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
   12f1a:	83 e0       	ldi	r24, 0x03	; 3
   12f1c:	5f c2       	rjmp	.+1214   	; 0x133dc <FreePrinting+0x5f8>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
   12f1e:	80 91 b3 01 	lds	r24, 0x01B3
   12f22:	88 23       	and	r24, r24
   12f24:	09 f0       	breq	.+2      	; 0x12f28 <FreePrinting+0x144>
   12f26:	79 c2       	rjmp	.+1266   	; 0x1341a <FreePrinting+0x636>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   12f28:	e0 91 ed 01 	lds	r30, 0x01ED
   12f2c:	f0 91 ee 01 	lds	r31, 0x01EE
   12f30:	e4 54       	subi	r30, 0x44	; 68
   12f32:	f7 4f       	sbci	r31, 0xF7	; 247
   12f34:	61 e0       	ldi	r22, 0x01	; 1
   12f36:	40 81       	ld	r20, Z
   12f38:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   12f3c:	80 91 ed 01 	lds	r24, 0x01ED
   12f40:	90 91 ee 01 	lds	r25, 0x01EE
   12f44:	01 96       	adiw	r24, 0x01	; 1
   12f46:	90 93 ee 01 	sts	0x01EE, r25
   12f4a:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintHeader;
   12f4e:	84 e0       	ldi	r24, 0x04	; 4
   12f50:	62 c2       	rjmp	.+1220   	; 0x13416 <FreePrinting+0x632>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     case fpInitMessage:
	      //uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
   12f52:	10 92 ee 01 	sts	0x01EE, r1
   12f56:	10 92 ed 01 	sts	0x01ED, r1
   12f5a:	10 92 ea 01 	sts	0x01EA, r1
   12f5e:	10 92 e9 01 	sts	0x01E9, r1
          stFreePrinting=fpPrintMessage; 
   12f62:	08 e0       	ldi	r16, 0x08	; 8
   12f64:	00 93 25 01 	sts	0x0125, r16
		  CarriegeReturn();
   12f68:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
   12f6c:	80 91 f5 01 	lds	r24, 0x01F5
   12f70:	88 23       	and	r24, r24
   12f72:	11 f0       	breq	.+4      	; 0x12f78 <FreePrinting+0x194>
   12f74:	86 e0       	ldi	r24, 0x06	; 6
   12f76:	84 cf       	rjmp	.-248    	; 0x12e80 <FreePrinting+0x9c>
		  else stFreePrinting=fpPrintMessage; 
   12f78:	00 93 25 01 	sts	0x0125, r16
   12f7c:	f1 c2       	rjmp	.+1506   	; 0x13560 <FreePrinting+0x77c>
	      break;
     case fpInitDuplicate:
	      //uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
   12f7e:	80 91 f5 01 	lds	r24, 0x01F5
   12f82:	2c eb       	ldi	r18, 0xBC	; 188
   12f84:	38 e0       	ldi	r19, 0x08	; 8
   12f86:	88 23       	and	r24, r24
   12f88:	79 f0       	breq	.+30     	; 0x12fa8 <FreePrinting+0x1c4>
   12f8a:	00 d0       	rcall	.+0      	; 0x12f8c <FreePrinting+0x1a8>
   12f8c:	00 d0       	rcall	.+0      	; 0x12f8e <FreePrinting+0x1aa>
   12f8e:	ad b7       	in	r26, 0x3d	; 61
   12f90:	be b7       	in	r27, 0x3e	; 62
   12f92:	12 96       	adiw	r26, 0x02	; 2
   12f94:	3c 93       	st	X, r19
   12f96:	2e 93       	st	-X, r18
   12f98:	11 97       	sbiw	r26, 0x01	; 1
   12f9a:	8d e7       	ldi	r24, 0x7D	; 125
   12f9c:	97 e0       	ldi	r25, 0x07	; 7
   12f9e:	14 96       	adiw	r26, 0x04	; 4
   12fa0:	9c 93       	st	X, r25
   12fa2:	8e 93       	st	-X, r24
   12fa4:	13 97       	sbiw	r26, 0x03	; 3
   12fa6:	0a c0       	rjmp	.+20     	; 0x12fbc <FreePrinting+0x1d8>
          else           sprintf_P(strPrint,PSTR("                                   "));
   12fa8:	00 d0       	rcall	.+0      	; 0x12faa <FreePrinting+0x1c6>
   12faa:	00 d0       	rcall	.+0      	; 0x12fac <FreePrinting+0x1c8>
   12fac:	ed b7       	in	r30, 0x3d	; 61
   12fae:	fe b7       	in	r31, 0x3e	; 62
   12fb0:	32 83       	std	Z+2, r19	; 0x02
   12fb2:	21 83       	std	Z+1, r18	; 0x01
   12fb4:	89 e5       	ldi	r24, 0x59	; 89
   12fb6:	97 e0       	ldi	r25, 0x07	; 7
   12fb8:	94 83       	std	Z+4, r25	; 0x04
   12fba:	83 83       	std	Z+3, r24	; 0x03
   12fbc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   12fc0:	0f 90       	pop	r0
   12fc2:	0f 90       	pop	r0
   12fc4:	0f 90       	pop	r0
   12fc6:	0f 90       	pop	r0
		  iSend=0;
   12fc8:	10 92 ee 01 	sts	0x01EE, r1
   12fcc:	10 92 ed 01 	sts	0x01ED, r1
		  iLoop=0;
   12fd0:	10 92 ea 01 	sts	0x01EA, r1
   12fd4:	10 92 e9 01 	sts	0x01E9, r1
		  LSend=strlen(strPrint);
   12fd8:	ec eb       	ldi	r30, 0xBC	; 188
   12fda:	f8 e0       	ldi	r31, 0x08	; 8
   12fdc:	01 90       	ld	r0, Z+
   12fde:	00 20       	and	r0, r0
   12fe0:	e9 f7       	brne	.-6      	; 0x12fdc <FreePrinting+0x1f8>
   12fe2:	31 97       	sbiw	r30, 0x01	; 1
   12fe4:	ec 5b       	subi	r30, 0xBC	; 188
   12fe6:	f8 40       	sbci	r31, 0x08	; 8
   12fe8:	f0 93 ec 01 	sts	0x01EC, r31
   12fec:	e0 93 eb 01 	sts	0x01EB, r30
          stFreePrinting=fpPrintDuplicate; 
   12ff0:	87 e0       	ldi	r24, 0x07	; 7
   12ff2:	46 cf       	rjmp	.-372    	; 0x12e80 <FreePrinting+0x9c>
	      break;
     case fpPrintDuplicate:
	      //uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
   12ff4:	20 91 ed 01 	lds	r18, 0x01ED
   12ff8:	30 91 ee 01 	lds	r19, 0x01EE
   12ffc:	80 91 eb 01 	lds	r24, 0x01EB
   13000:	90 91 ec 01 	lds	r25, 0x01EC
   13004:	28 17       	cp	r18, r24
   13006:	39 07       	cpc	r19, r25
   13008:	68 f4       	brcc	.+26     	; 0x13024 <FreePrinting+0x240>
		      iLoop++;
   1300a:	80 91 e9 01 	lds	r24, 0x01E9
   1300e:	90 91 ea 01 	lds	r25, 0x01EA
   13012:	01 96       	adiw	r24, 0x01	; 1
   13014:	90 93 ea 01 	sts	0x01EA, r25
   13018:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //uart(_COM_PRINTER,1,strPrint[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
   1301c:	10 92 b6 01 	sts	0x01B6, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
   13020:	85 e1       	ldi	r24, 0x15	; 21
   13022:	2e cf       	rjmp	.-420    	; 0x12e80 <FreePrinting+0x9c>
				 }
			  }
          else {
		     iSend=0;
   13024:	10 92 ee 01 	sts	0x01EE, r1
   13028:	10 92 ed 01 	sts	0x01ED, r1
		     stFreePrinting=fpPrintMessage;
   1302c:	88 e0       	ldi	r24, 0x08	; 8
   1302e:	d6 c1       	rjmp	.+940    	; 0x133dc <FreePrinting+0x5f8>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
   13030:	80 91 b3 01 	lds	r24, 0x01B3
   13034:	88 23       	and	r24, r24
   13036:	09 f0       	breq	.+2      	; 0x1303a <FreePrinting+0x256>
   13038:	f0 c1       	rjmp	.+992    	; 0x1341a <FreePrinting+0x636>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   1303a:	e0 91 ed 01 	lds	r30, 0x01ED
   1303e:	f0 91 ee 01 	lds	r31, 0x01EE
   13042:	e4 54       	subi	r30, 0x44	; 68
   13044:	f7 4f       	sbci	r31, 0xF7	; 247
   13046:	61 e0       	ldi	r22, 0x01	; 1
   13048:	40 81       	ld	r20, Z
   1304a:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   1304e:	80 91 ed 01 	lds	r24, 0x01ED
   13052:	90 91 ee 01 	lds	r25, 0x01EE
   13056:	01 96       	adiw	r24, 0x01	; 1
   13058:	90 93 ee 01 	sts	0x01EE, r25
   1305c:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintDuplicate;
   13060:	87 e0       	ldi	r24, 0x07	; 7
   13062:	d9 c1       	rjmp	.+946    	; 0x13416 <FreePrinting+0x632>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
   13064:	20 91 ed 01 	lds	r18, 0x01ED
   13068:	30 91 ee 01 	lds	r19, 0x01EE
   1306c:	80 91 8d 01 	lds	r24, 0x018D
   13070:	90 91 8e 01 	lds	r25, 0x018E
   13074:	28 17       	cp	r18, r24
   13076:	39 07       	cpc	r19, r25
   13078:	68 f4       	brcc	.+26     	; 0x13094 <FreePrinting+0x2b0>
		      iLoop++;
   1307a:	80 91 e9 01 	lds	r24, 0x01E9
   1307e:	90 91 ea 01 	lds	r25, 0x01EA
   13082:	01 96       	adiw	r24, 0x01	; 1
   13084:	90 93 ea 01 	sts	0x01EA, r25
   13088:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
   1308c:	10 92 b6 01 	sts	0x01B6, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
   13090:	83 e1       	ldi	r24, 0x13	; 19
   13092:	f6 ce       	rjmp	.-532    	; 0x12e80 <FreePrinting+0x9c>
				 }
			  }
          else stFreePrinting=fpLoadEndLine;//fpInitFooter;
   13094:	86 e1       	ldi	r24, 0x16	; 22
   13096:	f4 ce       	rjmp	.-536    	; 0x12e80 <FreePrinting+0x9c>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
   13098:	80 91 b3 01 	lds	r24, 0x01B3
   1309c:	88 23       	and	r24, r24
   1309e:	09 f0       	breq	.+2      	; 0x130a2 <FreePrinting+0x2be>
   130a0:	bc c1       	rjmp	.+888    	; 0x1341a <FreePrinting+0x636>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
   130a2:	e0 91 ed 01 	lds	r30, 0x01ED
   130a6:	f0 91 ee 01 	lds	r31, 0x01EE
   130aa:	e4 51       	subi	r30, 0x14	; 20
   130ac:	fc 4f       	sbci	r31, 0xFC	; 252
   130ae:	80 81       	ld	r24, Z
   130b0:	61 81       	ldd	r22, Z+1	; 0x01
   130b2:	0e 94 8a 47 	call	0x8f14	; 0x8f14 <SendPrint>
			     // uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
   130b6:	e0 91 ed 01 	lds	r30, 0x01ED
   130ba:	f0 91 ee 01 	lds	r31, 0x01EE
   130be:	e4 51       	subi	r30, 0x14	; 20
   130c0:	fc 4f       	sbci	r31, 0xFC	; 252
   130c2:	80 81       	ld	r24, Z
   130c4:	8d 30       	cpi	r24, 0x0D	; 13
   130c6:	19 f0       	breq	.+6      	; 0x130ce <FreePrinting+0x2ea>
   130c8:	81 81       	ldd	r24, Z+1	; 0x01
   130ca:	8a 30       	cpi	r24, 0x0A	; 10
   130cc:	11 f4       	brne	.+4      	; 0x130d2 <FreePrinting+0x2ee>
			     CarriegeReturn();
   130ce:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
             iSend++;
   130d2:	80 91 ed 01 	lds	r24, 0x01ED
   130d6:	90 91 ee 01 	lds	r25, 0x01EE
   130da:	01 96       	adiw	r24, 0x01	; 1
   130dc:	90 93 ee 01 	sts	0x01EE, r25
   130e0:	80 93 ed 01 	sts	0x01ED, r24
		     stFreePrinting=fpPrintMessage;
   130e4:	88 e0       	ldi	r24, 0x08	; 8
   130e6:	97 c1       	rjmp	.+814    	; 0x13416 <FreePrinting+0x632>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
   130e8:	10 92 ea 01 	sts	0x01EA, r1
   130ec:	10 92 e9 01 	sts	0x01E9, r1
		  iMargin=0;
   130f0:	10 92 f1 01 	sts	0x01F1, r1
		  stFreePrinting=fpPrintMargin;
   130f4:	8a e0       	ldi	r24, 0x0A	; 10
   130f6:	c4 ce       	rjmp	.-632    	; 0x12e80 <FreePrinting+0x9c>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
   130f8:	80 91 f1 01 	lds	r24, 0x01F1
   130fc:	85 30       	cpi	r24, 0x05	; 5
   130fe:	90 f4       	brcc	.+36     	; 0x13124 <FreePrinting+0x340>
		      iMargin++;
   13100:	8f 5f       	subi	r24, 0xFF	; 255
   13102:	80 93 f1 01 	sts	0x01F1, r24
		      iLoop++;
   13106:	80 91 e9 01 	lds	r24, 0x01E9
   1310a:	90 91 ea 01 	lds	r25, 0x01EA
   1310e:	01 96       	adiw	r24, 0x01	; 1
   13110:	90 93 ea 01 	sts	0x01EA, r25
   13114:	80 93 e9 01 	sts	0x01E9, r24
	          if ((iLoop%PRINT_DELAY)==0)uart(_COM_PRINTER,1,' ');
   13118:	80 e0       	ldi	r24, 0x00	; 0
   1311a:	61 e0       	ldi	r22, 0x01	; 1
   1311c:	40 e2       	ldi	r20, 0x20	; 32
   1311e:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
   13122:	1e c2       	rjmp	.+1084   	; 0x13560 <FreePrinting+0x77c>
			 }
          else stFreePrinting=fpPrintMessage;
   13124:	88 e0       	ldi	r24, 0x08	; 8
   13126:	ac ce       	rjmp	.-680    	; 0x12e80 <FreePrinting+0x9c>
   13128:	8e 01       	movw	r16, r28
   1312a:	0f 5f       	subi	r16, 0xFF	; 255
   1312c:	1f 4f       	sbci	r17, 0xFF	; 255
   1312e:	c8 01       	movw	r24, r16
   13130:	65 e1       	ldi	r22, 0x15	; 21
   13132:	70 e0       	ldi	r23, 0x00	; 0
   13134:	42 e1       	ldi	r20, 0x12	; 18
   13136:	50 e0       	ldi	r21, 0x00	; 0
   13138:	22 ed       	ldi	r18, 0xD2	; 210
   1313a:	33 e1       	ldi	r19, 0x13	; 19
   1313c:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
   13140:	c8 01       	movw	r24, r16
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13142:	9e 01       	movw	r18, r28
   13144:	20 5f       	subi	r18, 0xF0	; 240
   13146:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
   13148:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1314a:	82 17       	cp	r24, r18
   1314c:	93 07       	cpc	r25, r19
   1314e:	e1 f7       	brne	.-8      	; 0x13148 <FreePrinting+0x364>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13150:	18 8a       	std	Y+16, r1	; 0x10
     
     //Added Operator Name:
	 case fpLoadEndLine:
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
          StrPosCopy(strOperatorName,strOperatorName,0,15);
          if (strlen(strOperatorName)>0){
   13152:	89 81       	ldd	r24, Y+1	; 0x01
   13154:	88 23       	and	r24, r24
   13156:	09 f4       	brne	.+2      	; 0x1315a <FreePrinting+0x376>
   13158:	d6 c0       	rjmp	.+428    	; 0x13306 <FreePrinting+0x522>
		  	  if (SpaceOnly(strOperatorName)!=True){
   1315a:	ce 01       	movw	r24, r28
   1315c:	01 96       	adiw	r24, 0x01	; 1
   1315e:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   13162:	81 30       	cpi	r24, 0x01	; 1
   13164:	09 f4       	brne	.+2      	; 0x13168 <FreePrinting+0x384>
   13166:	cf c0       	rjmp	.+414    	; 0x13306 <FreePrinting+0x522>
			      sprintf_P(strPrint,PSTR("---------------------------------"));
   13168:	00 d0       	rcall	.+0      	; 0x1316a <FreePrinting+0x386>
   1316a:	00 d0       	rcall	.+0      	; 0x1316c <FreePrinting+0x388>
   1316c:	0c eb       	ldi	r16, 0xBC	; 188
   1316e:	18 e0       	ldi	r17, 0x08	; 8
   13170:	ad b7       	in	r26, 0x3d	; 61
   13172:	be b7       	in	r27, 0x3e	; 62
   13174:	12 96       	adiw	r26, 0x02	; 2
   13176:	1c 93       	st	X, r17
   13178:	0e 93       	st	-X, r16
   1317a:	11 97       	sbiw	r26, 0x01	; 1
   1317c:	87 e3       	ldi	r24, 0x37	; 55
   1317e:	97 e0       	ldi	r25, 0x07	; 7
   13180:	14 96       	adiw	r26, 0x04	; 4
   13182:	9c 93       	st	X, r25
   13184:	8e 93       	st	-X, r24
   13186:	13 97       	sbiw	r26, 0x03	; 3
   13188:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			      //AddSpaceLead(strPrint,(strlen(strPrint)+PRINT_MARGIN));
			      iSend=0;
   1318c:	10 92 ee 01 	sts	0x01EE, r1
   13190:	10 92 ed 01 	sts	0x01ED, r1
				  iLoop=0;
   13194:	10 92 ea 01 	sts	0x01EA, r1
   13198:	10 92 e9 01 	sts	0x01E9, r1
				  LSend=strlen(strPrint);
   1319c:	f8 01       	movw	r30, r16
   1319e:	01 90       	ld	r0, Z+
   131a0:	00 20       	and	r0, r0
   131a2:	e9 f7       	brne	.-6      	; 0x1319e <FreePrinting+0x3ba>
   131a4:	8f 01       	movw	r16, r30
   131a6:	01 50       	subi	r16, 0x01	; 1
   131a8:	10 40       	sbci	r17, 0x00	; 0
   131aa:	0c 5b       	subi	r16, 0xBC	; 188
   131ac:	18 40       	sbci	r17, 0x08	; 8
   131ae:	10 93 ec 01 	sts	0x01EC, r17
   131b2:	00 93 eb 01 	sts	0x01EB, r16
				  stFreePrinting=fpPrintEndLine;	
   131b6:	87 e1       	ldi	r24, 0x17	; 23
   131b8:	80 93 25 01 	sts	0x0125, r24
   131bc:	0f 90       	pop	r0
   131be:	0f 90       	pop	r0
   131c0:	0f 90       	pop	r0
   131c2:	0f 90       	pop	r0
   131c4:	cd c1       	rjmp	.+922    	; 0x13560 <FreePrinting+0x77c>
			   }else stFreePrinting=fpInitFooter;
		  }else stFreePrinting=fpInitFooter;
	      break;

	 case fpPrintEndLine:
		  if (iSend<LSend){
   131c6:	20 91 ed 01 	lds	r18, 0x01ED
   131ca:	30 91 ee 01 	lds	r19, 0x01EE
   131ce:	80 91 eb 01 	lds	r24, 0x01EB
   131d2:	90 91 ec 01 	lds	r25, 0x01EC
   131d6:	28 17       	cp	r18, r24
   131d8:	39 07       	cpc	r19, r25
   131da:	68 f4       	brcc	.+26     	; 0x131f6 <FreePrinting+0x412>
		      iLoop++;
   131dc:	80 91 e9 01 	lds	r24, 0x01E9
   131e0:	90 91 ea 01 	lds	r25, 0x01EA
   131e4:	01 96       	adiw	r24, 0x01	; 1
   131e6:	90 93 ea 01 	sts	0x01EA, r25
   131ea:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
   131ee:	10 92 b6 01 	sts	0x01B6, r1
				  stFreePrinting=fpCheckPrintEndLine;
   131f2:	88 e1       	ldi	r24, 0x18	; 24
   131f4:	45 ce       	rjmp	.-886    	; 0x12e80 <FreePrinting+0x9c>
				}
			  }
          else {
			  CarriegeReturn();
   131f6:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			  stFreePrinting=fpLoadOperatorName;
   131fa:	89 e1       	ldi	r24, 0x19	; 25
   131fc:	41 ce       	rjmp	.-894    	; 0x12e80 <FreePrinting+0x9c>
			  }
	      break;
	 case fpCheckPrintEndLine:
	      if (IsBusyPrint==False){
   131fe:	80 91 b3 01 	lds	r24, 0x01B3
   13202:	88 23       	and	r24, r24
   13204:	09 f0       	breq	.+2      	; 0x13208 <FreePrinting+0x424>
   13206:	09 c1       	rjmp	.+530    	; 0x1341a <FreePrinting+0x636>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   13208:	e0 91 ed 01 	lds	r30, 0x01ED
   1320c:	f0 91 ee 01 	lds	r31, 0x01EE
   13210:	e4 54       	subi	r30, 0x44	; 68
   13212:	f7 4f       	sbci	r31, 0xF7	; 247
   13214:	61 e0       	ldi	r22, 0x01	; 1
   13216:	40 81       	ld	r20, Z
   13218:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   1321c:	80 91 ed 01 	lds	r24, 0x01ED
   13220:	90 91 ee 01 	lds	r25, 0x01EE
   13224:	01 96       	adiw	r24, 0x01	; 1
   13226:	90 93 ee 01 	sts	0x01EE, r25
   1322a:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintEndLine;
   1322e:	87 e1       	ldi	r24, 0x17	; 23
   13230:	f2 c0       	rjmp	.+484    	; 0x13416 <FreePrinting+0x632>
   13232:	8e 01       	movw	r16, r28
   13234:	0f 5f       	subi	r16, 0xFF	; 255
   13236:	1f 4f       	sbci	r17, 0xFF	; 255
   13238:	c8 01       	movw	r24, r16
   1323a:	65 e1       	ldi	r22, 0x15	; 21
   1323c:	70 e0       	ldi	r23, 0x00	; 0
   1323e:	42 e1       	ldi	r20, 0x12	; 18
   13240:	50 e0       	ldi	r21, 0x00	; 0
   13242:	22 ed       	ldi	r18, 0xD2	; 210
   13244:	33 e1       	ldi	r19, 0x13	; 19
   13246:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
   1324a:	c8 01       	movw	r24, r16
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1324c:	9e 01       	movw	r18, r28
   1324e:	20 5f       	subi	r18, 0xF0	; 240
   13250:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
   13252:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13254:	82 17       	cp	r24, r18
   13256:	93 07       	cpc	r25, r19
   13258:	e1 f7       	brne	.-8      	; 0x13252 <FreePrinting+0x46e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1325a:	18 8a       	std	Y+16, r1	; 0x10
	      break;

	 case fpLoadOperatorName:
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);
		  sprintf_P(strPrint,PSTR("Operator: %s"),strOperatorName);
   1325c:	00 d0       	rcall	.+0      	; 0x1325e <FreePrinting+0x47a>
   1325e:	00 d0       	rcall	.+0      	; 0x13260 <FreePrinting+0x47c>
   13260:	00 d0       	rcall	.+0      	; 0x13262 <FreePrinting+0x47e>
   13262:	ed b7       	in	r30, 0x3d	; 61
   13264:	fe b7       	in	r31, 0x3e	; 62
   13266:	31 96       	adiw	r30, 0x01	; 1
   13268:	0c eb       	ldi	r16, 0xBC	; 188
   1326a:	18 e0       	ldi	r17, 0x08	; 8
   1326c:	ad b7       	in	r26, 0x3d	; 61
   1326e:	be b7       	in	r27, 0x3e	; 62
   13270:	12 96       	adiw	r26, 0x02	; 2
   13272:	1c 93       	st	X, r17
   13274:	0e 93       	st	-X, r16
   13276:	11 97       	sbiw	r26, 0x01	; 1
   13278:	8a e2       	ldi	r24, 0x2A	; 42
   1327a:	97 e0       	ldi	r25, 0x07	; 7
   1327c:	93 83       	std	Z+3, r25	; 0x03
   1327e:	82 83       	std	Z+2, r24	; 0x02
   13280:	ce 01       	movw	r24, r28
   13282:	01 96       	adiw	r24, 0x01	; 1
   13284:	95 83       	std	Z+5, r25	; 0x05
   13286:	84 83       	std	Z+4, r24	; 0x04
   13288:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	      iSend=0;
   1328c:	10 92 ee 01 	sts	0x01EE, r1
   13290:	10 92 ed 01 	sts	0x01ED, r1
		  iLoop=0;
   13294:	10 92 ea 01 	sts	0x01EA, r1
   13298:	10 92 e9 01 	sts	0x01E9, r1
		  LSend=strlen(strPrint);
   1329c:	f8 01       	movw	r30, r16
   1329e:	01 90       	ld	r0, Z+
   132a0:	00 20       	and	r0, r0
   132a2:	e9 f7       	brne	.-6      	; 0x1329e <FreePrinting+0x4ba>
   132a4:	8f 01       	movw	r16, r30
   132a6:	01 50       	subi	r16, 0x01	; 1
   132a8:	10 40       	sbci	r17, 0x00	; 0
   132aa:	0c 5b       	subi	r16, 0xBC	; 188
   132ac:	18 40       	sbci	r17, 0x08	; 8
   132ae:	10 93 ec 01 	sts	0x01EC, r17
   132b2:	00 93 eb 01 	sts	0x01EB, r16
		  stFreePrinting=fpPrintOperatorName;	
   132b6:	8a e1       	ldi	r24, 0x1A	; 26
   132b8:	80 93 25 01 	sts	0x0125, r24
   132bc:	8d b7       	in	r24, 0x3d	; 61
   132be:	9e b7       	in	r25, 0x3e	; 62
   132c0:	06 96       	adiw	r24, 0x06	; 6
   132c2:	0f b6       	in	r0, 0x3f	; 63
   132c4:	f8 94       	cli
   132c6:	9e bf       	out	0x3e, r25	; 62
   132c8:	0f be       	out	0x3f, r0	; 63
   132ca:	8d bf       	out	0x3d, r24	; 61
   132cc:	49 c1       	rjmp	.+658    	; 0x13560 <FreePrinting+0x77c>
	      break;
	 case fpPrintOperatorName:
		  if (iSend<LSend){
   132ce:	20 91 ed 01 	lds	r18, 0x01ED
   132d2:	30 91 ee 01 	lds	r19, 0x01EE
   132d6:	80 91 eb 01 	lds	r24, 0x01EB
   132da:	90 91 ec 01 	lds	r25, 0x01EC
   132de:	28 17       	cp	r18, r24
   132e0:	39 07       	cpc	r19, r25
   132e2:	68 f4       	brcc	.+26     	; 0x132fe <FreePrinting+0x51a>
		      iLoop++;
   132e4:	80 91 e9 01 	lds	r24, 0x01E9
   132e8:	90 91 ea 01 	lds	r25, 0x01EA
   132ec:	01 96       	adiw	r24, 0x01	; 1
   132ee:	90 93 ea 01 	sts	0x01EA, r25
   132f2:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
   132f6:	10 92 b6 01 	sts	0x01B6, r1
				  stFreePrinting=fpCheckPrintOperatorName;
   132fa:	8b e1       	ldi	r24, 0x1B	; 27
   132fc:	c1 cd       	rjmp	.-1150   	; 0x12e80 <FreePrinting+0x9c>
				}
			  }
          else {
			  CarriegeReturn();
   132fe:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			  CarriegeReturn();
   13302:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			  stFreePrinting=fpInitFooter;
   13306:	8b e0       	ldi	r24, 0x0B	; 11
   13308:	bb cd       	rjmp	.-1162   	; 0x12e80 <FreePrinting+0x9c>
			  }
	      break;
	 case fpCheckPrintOperatorName:
	      if (IsBusyPrint==False){
   1330a:	80 91 b3 01 	lds	r24, 0x01B3
   1330e:	88 23       	and	r24, r24
   13310:	09 f0       	breq	.+2      	; 0x13314 <FreePrinting+0x530>
   13312:	83 c0       	rjmp	.+262    	; 0x1341a <FreePrinting+0x636>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   13314:	e0 91 ed 01 	lds	r30, 0x01ED
   13318:	f0 91 ee 01 	lds	r31, 0x01EE
   1331c:	e4 54       	subi	r30, 0x44	; 68
   1331e:	f7 4f       	sbci	r31, 0xF7	; 247
   13320:	61 e0       	ldi	r22, 0x01	; 1
   13322:	40 81       	ld	r20, Z
   13324:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   13328:	80 91 ed 01 	lds	r24, 0x01ED
   1332c:	90 91 ee 01 	lds	r25, 0x01EE
   13330:	01 96       	adiw	r24, 0x01	; 1
   13332:	90 93 ee 01 	sts	0x01EE, r25
   13336:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintOperatorName;
   1333a:	8a e1       	ldi	r24, 0x1A	; 26
   1333c:	6c c0       	rjmp	.+216    	; 0x13416 <FreePrinting+0x632>
			  }
	      break;

     case fpInitFooter:
	      //uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
   1333e:	80 91 b5 01 	lds	r24, 0x01B5
   13342:	86 ff       	sbrs	r24, 6
   13344:	03 c0       	rjmp	.+6      	; 0x1334c <FreePrinting+0x568>
		        iFooter=0;
   13346:	10 92 f3 01 	sts	0x01F3, r1
   1334a:	1f c0       	rjmp	.+62     	; 0x1338a <FreePrinting+0x5a6>
		        stFreePrinting=fpLoadFooter;			  
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
   1334c:	80 e1       	ldi	r24, 0x10	; 16
   1334e:	98 cd       	rjmp	.-1232   	; 0x12e80 <FreePrinting+0x9c>
   13350:	60 91 f3 01 	lds	r22, 0x01F3
   13354:	89 e2       	ldi	r24, 0x29	; 41
   13356:	68 9f       	mul	r22, r24
   13358:	b0 01       	movw	r22, r0
   1335a:	11 24       	eor	r1, r1
   1335c:	63 5e       	subi	r22, 0xE3	; 227
   1335e:	7c 4f       	sbci	r23, 0xFC	; 252
   13360:	8c eb       	ldi	r24, 0xBC	; 188
   13362:	98 e0       	ldi	r25, 0x08	; 8
   13364:	48 e2       	ldi	r20, 0x28	; 40
   13366:	50 e0       	ldi	r21, 0x00	; 0
   13368:	22 ed       	ldi	r18, 0xD2	; 210
   1336a:	33 e1       	ldi	r19, 0x13	; 19
   1336c:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
   13370:	80 91 f3 01 	lds	r24, 0x01F3
   13374:	8f 5f       	subi	r24, 0xFF	; 255
   13376:	80 93 f3 01 	sts	0x01F3, r24
		  if (iFooter<=4){
   1337a:	85 30       	cpi	r24, 0x05	; 5
   1337c:	90 f4       	brcc	.+36     	; 0x133a2 <FreePrinting+0x5be>
		      if (SpaceOnly(strPrint)==True){
   1337e:	8c eb       	ldi	r24, 0xBC	; 188
   13380:	98 e0       	ldi	r25, 0x08	; 8
   13382:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   13386:	81 30       	cpi	r24, 0x01	; 1
   13388:	11 f4       	brne	.+4      	; 0x1338e <FreePrinting+0x5aa>
			      stFreePrinting=fpLoadFooter;
   1338a:	8c e0       	ldi	r24, 0x0C	; 12
   1338c:	79 cd       	rjmp	.-1294   	; 0x12e80 <FreePrinting+0x9c>
				  }
			  else{
			      iSend=0;
   1338e:	10 92 ee 01 	sts	0x01EE, r1
   13392:	10 92 ed 01 	sts	0x01ED, r1
				  iLoop=0;
   13396:	10 92 ea 01 	sts	0x01EA, r1
   1339a:	10 92 e9 01 	sts	0x01E9, r1
				  stFreePrinting=fpPrintFooter;
   1339e:	8d e0       	ldi	r24, 0x0D	; 13
   133a0:	6f cd       	rjmp	.-1314   	; 0x12e80 <FreePrinting+0x9c>
			      }
		  }else{
		    CarriegeReturn();
   133a2:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			iPrinted++;
   133a6:	80 91 f5 01 	lds	r24, 0x01F5
   133aa:	8f 5f       	subi	r24, 0xFF	; 255
   133ac:	80 93 f5 01 	sts	0x01F5, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
   133b0:	8e e0       	ldi	r24, 0x0E	; 14
   133b2:	66 cd       	rjmp	.-1332   	; 0x12e80 <FreePrinting+0x9c>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
   133b4:	80 91 ed 01 	lds	r24, 0x01ED
   133b8:	90 91 ee 01 	lds	r25, 0x01EE
   133bc:	88 97       	sbiw	r24, 0x28	; 40
   133be:	68 f4       	brcc	.+26     	; 0x133da <FreePrinting+0x5f6>
		      iLoop++;
   133c0:	80 91 e9 01 	lds	r24, 0x01E9
   133c4:	90 91 ea 01 	lds	r25, 0x01EA
   133c8:	01 96       	adiw	r24, 0x01	; 1
   133ca:	90 93 ea 01 	sts	0x01EA, r25
   133ce:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //uart(_COM_PRINTER,1,strPrint[iSend]);
		        //iSend++;
				TimPrintBusy=0;
   133d2:	10 92 b6 01 	sts	0x01B6, r1
				stFreePrinting=fpCheckPrintStatusFooter;
   133d6:	84 e1       	ldi	r24, 0x14	; 20
   133d8:	53 cd       	rjmp	.-1370   	; 0x12e80 <FreePrinting+0x9c>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
   133da:	8c e0       	ldi	r24, 0x0C	; 12
   133dc:	80 93 25 01 	sts	0x0125, r24
			  CarriegeReturn();
   133e0:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   133e4:	bd c0       	rjmp	.+378    	; 0x13560 <FreePrinting+0x77c>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
   133e6:	80 91 b3 01 	lds	r24, 0x01B3
   133ea:	88 23       	and	r24, r24
   133ec:	b1 f4       	brne	.+44     	; 0x1341a <FreePrinting+0x636>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   133ee:	e0 91 ed 01 	lds	r30, 0x01ED
   133f2:	f0 91 ee 01 	lds	r31, 0x01EE
   133f6:	e4 54       	subi	r30, 0x44	; 68
   133f8:	f7 4f       	sbci	r31, 0xF7	; 247
   133fa:	61 e0       	ldi	r22, 0x01	; 1
   133fc:	40 81       	ld	r20, Z
   133fe:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   13402:	80 91 ed 01 	lds	r24, 0x01ED
   13406:	90 91 ee 01 	lds	r25, 0x01EE
   1340a:	01 96       	adiw	r24, 0x01	; 1
   1340c:	90 93 ee 01 	sts	0x01EE, r25
   13410:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintFooter;
   13414:	8d e0       	ldi	r24, 0x0D	; 13
   13416:	80 93 25 01 	sts	0x0125, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
   1341a:	80 91 b6 01 	lds	r24, 0x01B6
   1341e:	8b 30       	cpi	r24, 0x0B	; 11
   13420:	08 f4       	brcc	.+2      	; 0x13424 <FreePrinting+0x640>
   13422:	9e c0       	rjmp	.+316    	; 0x13560 <FreePrinting+0x77c>
		      IsPrintERROR=True;
   13424:	81 e0       	ldi	r24, 0x01	; 1
   13426:	80 93 b1 01 	sts	0x01B1, r24
		      stFreePrinting=fpFinishFreePrinting;
   1342a:	81 e1       	ldi	r24, 0x11	; 17
   1342c:	29 cd       	rjmp	.-1454   	; 0x12e80 <FreePrinting+0x9c>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
   1342e:	10 92 f0 01 	sts	0x01F0, r1
		  iSend=0;
   13432:	10 92 ee 01 	sts	0x01EE, r1
   13436:	10 92 ed 01 	sts	0x01ED, r1
		  if (iPrinted<PrintCopy)
   1343a:	90 91 f5 01 	lds	r25, 0x01F5
   1343e:	80 91 f2 01 	lds	r24, 0x01F2
   13442:	98 17       	cp	r25, r24
   13444:	28 f4       	brcc	.+10     	; 0x13450 <FreePrinting+0x66c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13446:	e1 99       	sbic	0x1c, 1	; 28
   13448:	fe cf       	rjmp	.-4      	; 0x13446 <FreePrinting+0x662>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1344a:	82 e3       	ldi	r24, 0x32	; 50
   1344c:	90 e0       	ldi	r25, 0x00	; 0
   1344e:	04 c0       	rjmp	.+8      	; 0x13458 <FreePrinting+0x674>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13450:	e1 99       	sbic	0x1c, 1	; 28
   13452:	fe cf       	rjmp	.-4      	; 0x13450 <FreePrinting+0x66c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13454:	81 e3       	ldi	r24, 0x31	; 49
   13456:	90 e0       	ldi	r25, 0x00	; 0
   13458:	9f bb       	out	0x1f, r25	; 31
   1345a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1345c:	e0 9a       	sbi	0x1c, 0	; 28
   1345e:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
   13460:	80 93 ef 01 	sts	0x01EF, r24

          stFreePrinting=fpScrollPaper;
   13464:	8f e0       	ldi	r24, 0x0F	; 15
   13466:	0c cd       	rjmp	.-1512   	; 0x12e80 <FreePrinting+0x9c>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
   13468:	90 91 f0 01 	lds	r25, 0x01F0
   1346c:	80 91 ef 01 	lds	r24, 0x01EF
   13470:	89 17       	cp	r24, r25
   13472:	18 f4       	brcc	.+6      	; 0x1347a <FreePrinting+0x696>
   13474:	80 e1       	ldi	r24, 0x10	; 16
   13476:	80 93 25 01 	sts	0x0125, r24
		  iSend++;
   1347a:	80 91 ed 01 	lds	r24, 0x01ED
   1347e:	90 91 ee 01 	lds	r25, 0x01EE
   13482:	01 96       	adiw	r24, 0x01	; 1
   13484:	90 93 ee 01 	sts	0x01EE, r25
   13488:	80 93 ed 01 	sts	0x01ED, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
   1348c:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			  iScroll++;
   13490:	80 91 f0 01 	lds	r24, 0x01F0
   13494:	8f 5f       	subi	r24, 0xFF	; 255
   13496:	80 93 f0 01 	sts	0x01F0, r24
   1349a:	62 c0       	rjmp	.+196    	; 0x13560 <FreePrinting+0x77c>
			  }
	      break;
     case fpPaperCut:
		  //uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
   1349c:	90 91 f5 01 	lds	r25, 0x01F5
   134a0:	80 91 f2 01 	lds	r24, 0x01F2
   134a4:	98 17       	cp	r25, r24
   134a6:	20 f4       	brcc	.+8      	; 0x134b0 <FreePrinting+0x6cc>
		      CarriegeReturn();
   134a8:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
              stFreePrinting=fpInitHeader;
   134ac:	82 e0       	ldi	r24, 0x02	; 2
   134ae:	07 c0       	rjmp	.+14     	; 0x134be <FreePrinting+0x6da>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
   134b0:	80 91 00 01 	lds	r24, 0x0100
   134b4:	81 30       	cpi	r24, 0x01	; 1
   134b6:	11 f4       	brne	.+4      	; 0x134bc <FreePrinting+0x6d8>
   134b8:	0e 94 ee 96 	call	0x12ddc	; 0x12ddc <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
   134bc:	81 e1       	ldi	r24, 0x11	; 17
   134be:	80 93 25 01 	sts	0x0125, r24
			  }
          
		  if (((cmdPrint&0b00100000)>>5)==1){
   134c2:	80 91 b5 01 	lds	r24, 0x01B5
   134c6:	85 ff       	sbrs	r24, 5
   134c8:	4b c0       	rjmp	.+150    	; 0x13560 <FreePrinting+0x77c>
		      if (iPrinted==0){
   134ca:	80 91 f5 01 	lds	r24, 0x01F5
   134ce:	88 23       	and	r24, r24
   134d0:	59 f4       	brne	.+22     	; 0x134e8 <FreePrinting+0x704>
			      CarriegeReturn();_delay_ms(50);
   134d2:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   134d6:	84 ef       	ldi	r24, 0xF4	; 244
   134d8:	91 e0       	ldi	r25, 0x01	; 1
   134da:	20 e7       	ldi	r18, 0x70	; 112
   134dc:	31 e0       	ldi	r19, 0x01	; 1
   134de:	f9 01       	movw	r30, r18
   134e0:	31 97       	sbiw	r30, 0x01	; 1
   134e2:	f1 f7       	brne	.-4      	; 0x134e0 <FreePrinting+0x6fc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   134e4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   134e6:	d9 f7       	brne	.-10     	; 0x134de <FreePrinting+0x6fa>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
   134e8:	90 91 f5 01 	lds	r25, 0x01F5
   134ec:	80 91 f2 01 	lds	r24, 0x01F2
   134f0:	98 17       	cp	r25, r24
   134f2:	61 f5       	brne	.+88     	; 0x1354c <FreePrinting+0x768>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				  CarriegeReturn();_delay_ms(50);
   134f4:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   134f8:	84 ef       	ldi	r24, 0xF4	; 244
   134fa:	91 e0       	ldi	r25, 0x01	; 1
   134fc:	20 e7       	ldi	r18, 0x70	; 112
   134fe:	31 e0       	ldi	r19, 0x01	; 1
   13500:	f9 01       	movw	r30, r18
   13502:	31 97       	sbiw	r30, 0x01	; 1
   13504:	f1 f7       	brne	.-4      	; 0x13502 <FreePrinting+0x71e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   13506:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   13508:	d9 f7       	brne	.-10     	; 0x13500 <FreePrinting+0x71c>
				  CarriegeReturn();_delay_ms(50);
   1350a:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   1350e:	84 ef       	ldi	r24, 0xF4	; 244
   13510:	91 e0       	ldi	r25, 0x01	; 1
   13512:	20 e7       	ldi	r18, 0x70	; 112
   13514:	31 e0       	ldi	r19, 0x01	; 1
   13516:	f9 01       	movw	r30, r18
   13518:	31 97       	sbiw	r30, 0x01	; 1
   1351a:	f1 f7       	brne	.-4      	; 0x13518 <FreePrinting+0x734>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   1351c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   1351e:	d9 f7       	brne	.-10     	; 0x13516 <FreePrinting+0x732>
				  CarriegeReturn();_delay_ms(50);
   13520:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   13524:	84 ef       	ldi	r24, 0xF4	; 244
   13526:	91 e0       	ldi	r25, 0x01	; 1
   13528:	20 e7       	ldi	r18, 0x70	; 112
   1352a:	31 e0       	ldi	r19, 0x01	; 1
   1352c:	f9 01       	movw	r30, r18
   1352e:	31 97       	sbiw	r30, 0x01	; 1
   13530:	f1 f7       	brne	.-4      	; 0x1352e <FreePrinting+0x74a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   13532:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   13534:	d9 f7       	brne	.-10     	; 0x1352c <FreePrinting+0x748>
				  CarriegeReturn();_delay_ms(50);
   13536:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   1353a:	84 ef       	ldi	r24, 0xF4	; 244
   1353c:	91 e0       	ldi	r25, 0x01	; 1
   1353e:	20 e7       	ldi	r18, 0x70	; 112
   13540:	31 e0       	ldi	r19, 0x01	; 1
   13542:	f9 01       	movw	r30, r18
   13544:	31 97       	sbiw	r30, 0x01	; 1
   13546:	f1 f7       	brne	.-4      	; 0x13544 <FreePrinting+0x760>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   13548:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   1354a:	d9 f7       	brne	.-10     	; 0x13542 <FreePrinting+0x75e>
				   //}
				 }
		      PaperCut();
   1354c:	0e 94 49 48 	call	0x9092	; 0x9092 <PaperCut>
   13550:	07 c0       	rjmp	.+14     	; 0x13560 <FreePrinting+0x77c>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
   13552:	10 92 b4 01 	sts	0x01B4, r1
	      stFreePrinting=fpInit;
   13556:	81 e0       	ldi	r24, 0x01	; 1
   13558:	80 93 25 01 	sts	0x0125, r24
		  iPrinted=0;
   1355c:	10 92 f5 01 	sts	0x01F5, r1
	      break;
	 }//EndCase
}
   13560:	64 96       	adiw	r28, 0x14	; 20
   13562:	0f b6       	in	r0, 0x3f	; 63
   13564:	f8 94       	cli
   13566:	de bf       	out	0x3e, r29	; 62
   13568:	0f be       	out	0x3f, r0	; 63
   1356a:	cd bf       	out	0x3d, r28	; 61
   1356c:	cf 91       	pop	r28
   1356e:	df 91       	pop	r29
   13570:	1f 91       	pop	r17
   13572:	0f 91       	pop	r16
   13574:	08 95       	ret

00013576 <PrintIdle>:
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
   13576:	ef 92       	push	r14
   13578:	ff 92       	push	r15
   1357a:	0f 93       	push	r16
   1357c:	1f 93       	push	r17
   1357e:	df 93       	push	r29
   13580:	cf 93       	push	r28
   13582:	cd b7       	in	r28, 0x3d	; 61
   13584:	de b7       	in	r29, 0x3e	; 62
   13586:	64 97       	sbiw	r28, 0x14	; 20
   13588:	0f b6       	in	r0, 0x3f	; 63
   1358a:	f8 94       	cli
   1358c:	de bf       	out	0x3e, r29	; 62
   1358e:	0f be       	out	0x3f, r0	; 63
   13590:	cd bf       	out	0x3d, r28	; 61
		uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
   13592:	80 91 ac 01 	lds	r24, 0x01AC
   13596:	81 30       	cpi	r24, 0x01	; 1
   13598:	31 f4       	brne	.+12     	; 0x135a6 <PrintIdle+0x30>
   1359a:	80 91 06 02 	lds	r24, 0x0206
   1359e:	88 23       	and	r24, r24
   135a0:	11 f0       	breq	.+4      	; 0x135a6 <PrintIdle+0x30>
	     stPrintIdle=piIdle;
   135a2:	10 92 06 02 	sts	0x0206, r1
	 }

     switch(stPrintIdle){
   135a6:	80 91 06 02 	lds	r24, 0x0206
   135aa:	e8 2f       	mov	r30, r24
   135ac:	f0 e0       	ldi	r31, 0x00	; 0
   135ae:	e8 31       	cpi	r30, 0x18	; 24
   135b0:	f1 05       	cpc	r31, r1
   135b2:	08 f0       	brcs	.+2      	; 0x135b6 <PrintIdle+0x40>
   135b4:	96 c7       	rjmp	.+3884   	; 0x144e2 <PrintIdle+0xf6c>
   135b6:	e8 51       	subi	r30, 0x18	; 24
   135b8:	ff 4f       	sbci	r31, 0xFF	; 255
   135ba:	ee 0f       	add	r30, r30
   135bc:	ff 1f       	adc	r31, r31
   135be:	05 90       	lpm	r0, Z+
   135c0:	f4 91       	lpm	r31, Z+
   135c2:	e0 2d       	mov	r30, r0
   135c4:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
   135c6:	80 91 ac 01 	lds	r24, 0x01AC
   135ca:	81 30       	cpi	r24, 0x01	; 1
   135cc:	09 f0       	breq	.+2      	; 0x135d0 <PrintIdle+0x5a>
   135ce:	89 c7       	rjmp	.+3858   	; 0x144e2 <PrintIdle+0xf6c>
		      IsPrinting=False;
   135d0:	10 92 ac 01 	sts	0x01AC, r1
			  IsBusyIdlePrinting=True;
   135d4:	80 93 b2 01 	sts	0x01B2, r24
			  IsBusyPrint=False;
   135d8:	10 92 b3 01 	sts	0x01B3, r1
			  iPrinted=0;
   135dc:	10 92 f8 01 	sts	0x01F8, r1
			  PrintCopy=0;
   135e0:	10 92 f7 01 	sts	0x01F7, r1
		      stPrintIdle=piInit;
   135e4:	80 93 06 02 	sts	0x0206, r24
			  InitPrinter();
   135e8:	0e 94 ad 47 	call	0x8f5a	; 0x8f5a <InitPrinter>
			  IsSignedField=False;
   135ec:	10 92 ff 01 	sts	0x01FF, r1
   135f0:	78 c7       	rjmp	.+3824   	; 0x144e2 <PrintIdle+0xf6c>
			  }
	      break;
	 case piInit:
	      iHeader=0;
   135f2:	10 92 05 02 	sts	0x0205, r1
		  CarriegeReturn();
   135f6:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   135fa:	1d c0       	rjmp	.+58     	; 0x13636 <PrintIdle+0xc0>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   135fc:	60 91 05 02 	lds	r22, 0x0205
   13600:	89 e2       	ldi	r24, 0x29	; 41
   13602:	68 9f       	mul	r22, r24
   13604:	b0 01       	movw	r22, r0
   13606:	11 24       	eor	r1, r1
   13608:	69 5d       	subi	r22, 0xD9	; 217
   1360a:	7d 4f       	sbci	r23, 0xFD	; 253
   1360c:	8c eb       	ldi	r24, 0xBC	; 188
   1360e:	98 e0       	ldi	r25, 0x08	; 8
   13610:	49 e2       	ldi	r20, 0x29	; 41
   13612:	50 e0       	ldi	r21, 0x00	; 0
   13614:	22 ed       	ldi	r18, 0xD2	; 210
   13616:	33 e1       	ldi	r19, 0x13	; 19
   13618:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
   1361c:	80 91 05 02 	lds	r24, 0x0205
   13620:	8f 5f       	subi	r24, 0xFF	; 255
   13622:	80 93 05 02 	sts	0x0205, r24
		  if (iHeader<6){
   13626:	86 30       	cpi	r24, 0x06	; 6
   13628:	00 f5       	brcc	.+64     	; 0x1366a <PrintIdle+0xf4>
		      if (SpaceOnly(strPrint)==True){
   1362a:	8c eb       	ldi	r24, 0xBC	; 188
   1362c:	98 e0       	ldi	r25, 0x08	; 8
   1362e:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   13632:	81 30       	cpi	r24, 0x01	; 1
   13634:	11 f4       	brne	.+4      	; 0x1363a <PrintIdle+0xc4>
			      stPrintIdle=piLoadHeader;
   13636:	82 e0       	ldi	r24, 0x02	; 2
   13638:	29 c7       	rjmp	.+3666   	; 0x1448c <PrintIdle+0xf16>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
   1363a:	83 e0       	ldi	r24, 0x03	; 3
   1363c:	80 93 06 02 	sts	0x0206, r24
			      iSend=0;
   13640:	10 92 fe 01 	sts	0x01FE, r1
   13644:	10 92 fd 01 	sts	0x01FD, r1
				  iLoop=0;
   13648:	10 92 fa 01 	sts	0x01FA, r1
   1364c:	10 92 f9 01 	sts	0x01F9, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
   13650:	80 91 05 02 	lds	r24, 0x0205
   13654:	81 30       	cpi	r24, 0x01	; 1
   13656:	19 f4       	brne	.+6      	; 0x1365e <PrintIdle+0xe8>
   13658:	0e 94 2f 48 	call	0x905e	; 0x905e <PrintDoubleHeight>
   1365c:	42 c7       	rjmp	.+3716   	; 0x144e2 <PrintIdle+0xf6c>
				  else 
				  if (iHeader==2) PrintNormalHeight();
   1365e:	82 30       	cpi	r24, 0x02	; 2
   13660:	09 f0       	breq	.+2      	; 0x13664 <PrintIdle+0xee>
   13662:	3f c7       	rjmp	.+3710   	; 0x144e2 <PrintIdle+0xf6c>
   13664:	0e 94 15 48 	call	0x902a	; 0x902a <PrintNormalHeight>
   13668:	3c c7       	rjmp	.+3704   	; 0x144e2 <PrintIdle+0xf6c>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
   1366a:	84 e0       	ldi	r24, 0x04	; 4
   1366c:	0f c7       	rjmp	.+3614   	; 0x1448c <PrintIdle+0xf16>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
   1366e:	80 91 fd 01 	lds	r24, 0x01FD
   13672:	90 91 fe 01 	lds	r25, 0x01FE
   13676:	88 97       	sbiw	r24, 0x28	; 40
   13678:	68 f4       	brcc	.+26     	; 0x13694 <PrintIdle+0x11e>
		      iLoop++;
   1367a:	80 91 f9 01 	lds	r24, 0x01F9
   1367e:	90 91 fa 01 	lds	r25, 0x01FA
   13682:	01 96       	adiw	r24, 0x01	; 1
   13684:	90 93 fa 01 	sts	0x01FA, r25
   13688:	80 93 f9 01 	sts	0x01F9, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
   1368c:	10 92 b6 01 	sts	0x01B6, r1
				 stPrintIdle=piCheckPrintStatusHeader;
   13690:	8b e0       	ldi	r24, 0x0B	; 11
   13692:	fc c6       	rjmp	.+3576   	; 0x1448c <PrintIdle+0xf16>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
   13694:	82 e0       	ldi	r24, 0x02	; 2
   13696:	8e c6       	rjmp	.+3356   	; 0x143b4 <PrintIdle+0xe3e>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
   13698:	80 91 b3 01 	lds	r24, 0x01B3
   1369c:	88 23       	and	r24, r24
   1369e:	09 f0       	breq	.+2      	; 0x136a2 <PrintIdle+0x12c>
   136a0:	ed c6       	rjmp	.+3546   	; 0x1447c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   136a2:	e0 91 fd 01 	lds	r30, 0x01FD
   136a6:	f0 91 fe 01 	lds	r31, 0x01FE
   136aa:	e4 54       	subi	r30, 0x44	; 68
   136ac:	f7 4f       	sbci	r31, 0xF7	; 247
   136ae:	61 e0       	ldi	r22, 0x01	; 1
   136b0:	40 81       	ld	r20, Z
   136b2:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   136b6:	80 91 fd 01 	lds	r24, 0x01FD
   136ba:	90 91 fe 01 	lds	r25, 0x01FE
   136be:	01 96       	adiw	r24, 0x01	; 1
   136c0:	90 93 fe 01 	sts	0x01FE, r25
   136c4:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintHeader;
   136c8:	83 e0       	ldi	r24, 0x03	; 3
   136ca:	d6 c6       	rjmp	.+3500   	; 0x14478 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
   136cc:	80 91 f8 01 	lds	r24, 0x01F8
   136d0:	88 23       	and	r24, r24
   136d2:	21 f4       	brne	.+8      	; 0x136dc <PrintIdle+0x166>
   136d4:	80 91 7f 01 	lds	r24, 0x017F
   136d8:	81 30       	cpi	r24, 0x01	; 1
   136da:	a9 f4       	brne	.+42     	; 0x13706 <PrintIdle+0x190>
		      IsReprintTicket=False;
   136dc:	10 92 7f 01 	sts	0x017F, r1
		      CarriegeReturn(); 
   136e0:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
   136e4:	00 d0       	rcall	.+0      	; 0x136e6 <PrintIdle+0x170>
   136e6:	00 d0       	rcall	.+0      	; 0x136e8 <PrintIdle+0x172>
   136e8:	8c eb       	ldi	r24, 0xBC	; 188
   136ea:	98 e0       	ldi	r25, 0x08	; 8
   136ec:	ad b7       	in	r26, 0x3d	; 61
   136ee:	be b7       	in	r27, 0x3e	; 62
   136f0:	12 96       	adiw	r26, 0x02	; 2
   136f2:	9c 93       	st	X, r25
   136f4:	8e 93       	st	-X, r24
   136f6:	11 97       	sbiw	r26, 0x01	; 1
   136f8:	8a e7       	ldi	r24, 0x7A	; 122
   136fa:	9b e0       	ldi	r25, 0x0B	; 11
   136fc:	14 96       	adiw	r26, 0x04	; 4
   136fe:	9c 93       	st	X, r25
   13700:	8e 93       	st	-X, r24
   13702:	13 97       	sbiw	r26, 0x03	; 3
   13704:	0c c0       	rjmp	.+24     	; 0x1371e <PrintIdle+0x1a8>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
   13706:	00 d0       	rcall	.+0      	; 0x13708 <PrintIdle+0x192>
   13708:	00 d0       	rcall	.+0      	; 0x1370a <PrintIdle+0x194>
   1370a:	8c eb       	ldi	r24, 0xBC	; 188
   1370c:	98 e0       	ldi	r25, 0x08	; 8
   1370e:	ed b7       	in	r30, 0x3d	; 61
   13710:	fe b7       	in	r31, 0x3e	; 62
   13712:	92 83       	std	Z+2, r25	; 0x02
   13714:	81 83       	std	Z+1, r24	; 0x01
   13716:	88 e7       	ldi	r24, 0x78	; 120
   13718:	9b e0       	ldi	r25, 0x0B	; 11
   1371a:	94 83       	std	Z+4, r25	; 0x04
   1371c:	83 83       	std	Z+3, r24	; 0x03
   1371e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   13722:	0f 90       	pop	r0
   13724:	0f 90       	pop	r0
   13726:	0f 90       	pop	r0
   13728:	0f 90       	pop	r0
		      }
		  iSend=0;
   1372a:	10 92 fe 01 	sts	0x01FE, r1
   1372e:	10 92 fd 01 	sts	0x01FD, r1
		  iLoop=0;
   13732:	10 92 fa 01 	sts	0x01FA, r1
   13736:	10 92 f9 01 	sts	0x01F9, r1
		  LSend=strlen(strPrint);
   1373a:	ec eb       	ldi	r30, 0xBC	; 188
   1373c:	f8 e0       	ldi	r31, 0x08	; 8
   1373e:	01 90       	ld	r0, Z+
   13740:	00 20       	and	r0, r0
   13742:	e9 f7       	brne	.-6      	; 0x1373e <PrintIdle+0x1c8>
   13744:	31 97       	sbiw	r30, 0x01	; 1
   13746:	ec 5b       	subi	r30, 0xBC	; 188
   13748:	f8 40       	sbci	r31, 0x08	; 8
   1374a:	f0 93 fc 01 	sts	0x01FC, r31
   1374e:	e0 93 fb 01 	sts	0x01FB, r30
          stPrintIdle=piPrintDuplicate; 
   13752:	85 e0       	ldi	r24, 0x05	; 5
   13754:	9b c6       	rjmp	.+3382   	; 0x1448c <PrintIdle+0xf16>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
   13756:	20 91 fd 01 	lds	r18, 0x01FD
   1375a:	30 91 fe 01 	lds	r19, 0x01FE
   1375e:	80 91 fb 01 	lds	r24, 0x01FB
   13762:	90 91 fc 01 	lds	r25, 0x01FC
   13766:	28 17       	cp	r18, r24
   13768:	39 07       	cpc	r19, r25
   1376a:	68 f4       	brcc	.+26     	; 0x13786 <PrintIdle+0x210>
		      iLoop++;
   1376c:	80 91 f9 01 	lds	r24, 0x01F9
   13770:	90 91 fa 01 	lds	r25, 0x01FA
   13774:	01 96       	adiw	r24, 0x01	; 1
   13776:	90 93 fa 01 	sts	0x01FA, r25
   1377a:	80 93 f9 01 	sts	0x01F9, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
   1377e:	10 92 b6 01 	sts	0x01B6, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
   13782:	86 e0       	ldi	r24, 0x06	; 6
   13784:	83 c6       	rjmp	.+3334   	; 0x1448c <PrintIdle+0xf16>
				 }
			  }
          else {
		     iSend=0;
   13786:	10 92 fe 01 	sts	0x01FE, r1
   1378a:	10 92 fd 01 	sts	0x01FD, r1
		     stPrintIdle=piInitMessage;
   1378e:	87 e0       	ldi	r24, 0x07	; 7
   13790:	7d c6       	rjmp	.+3322   	; 0x1448c <PrintIdle+0xf16>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
   13792:	80 91 b3 01 	lds	r24, 0x01B3
   13796:	88 23       	and	r24, r24
   13798:	09 f0       	breq	.+2      	; 0x1379c <PrintIdle+0x226>
   1379a:	70 c6       	rjmp	.+3296   	; 0x1447c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   1379c:	e0 91 fd 01 	lds	r30, 0x01FD
   137a0:	f0 91 fe 01 	lds	r31, 0x01FE
   137a4:	e4 54       	subi	r30, 0x44	; 68
   137a6:	f7 4f       	sbci	r31, 0xF7	; 247
   137a8:	61 e0       	ldi	r22, 0x01	; 1
   137aa:	40 81       	ld	r20, Z
   137ac:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
   137b0:	80 e0       	ldi	r24, 0x00	; 0
   137b2:	90 e9       	ldi	r25, 0x90	; 144
   137b4:	01 97       	sbiw	r24, 0x01	; 1
   137b6:	f1 f7       	brne	.-4      	; 0x137b4 <PrintIdle+0x23e>
			  _delay_ms(10);
		      iSend++;
   137b8:	80 91 fd 01 	lds	r24, 0x01FD
   137bc:	90 91 fe 01 	lds	r25, 0x01FE
   137c0:	01 96       	adiw	r24, 0x01	; 1
   137c2:	90 93 fe 01 	sts	0x01FE, r25
   137c6:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintDuplicate;
   137ca:	85 e0       	ldi	r24, 0x05	; 5
   137cc:	55 c6       	rjmp	.+3242   	; 0x14478 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
   137ce:	10 92 fe 01 	sts	0x01FE, r1
   137d2:	10 92 fd 01 	sts	0x01FD, r1
   137d6:	10 92 fa 01 	sts	0x01FA, r1
   137da:	10 92 f9 01 	sts	0x01F9, r1
		  iMessage=0;
   137de:	10 92 01 02 	sts	0x0201, r1
		  switch(MOPType){
   137e2:	80 91 b8 01 	lds	r24, 0x01B8
   137e6:	83 30       	cpi	r24, 0x03	; 3
   137e8:	81 f0       	breq	.+32     	; 0x1380a <PrintIdle+0x294>
   137ea:	84 30       	cpi	r24, 0x04	; 4
   137ec:	28 f4       	brcc	.+10     	; 0x137f8 <PrintIdle+0x282>
   137ee:	81 30       	cpi	r24, 0x01	; 1
   137f0:	61 f0       	breq	.+24     	; 0x1380a <PrintIdle+0x294>
   137f2:	82 30       	cpi	r24, 0x02	; 2
   137f4:	40 f4       	brcc	.+16     	; 0x13806 <PrintIdle+0x290>
   137f6:	10 c0       	rjmp	.+32     	; 0x13818 <PrintIdle+0x2a2>
   137f8:	88 30       	cpi	r24, 0x08	; 8
   137fa:	49 f0       	breq	.+18     	; 0x1380e <PrintIdle+0x298>
   137fc:	89 30       	cpi	r24, 0x09	; 9
   137fe:	61 f0       	breq	.+24     	; 0x13818 <PrintIdle+0x2a2>
   13800:	87 30       	cpi	r24, 0x07	; 7
   13802:	51 f4       	brne	.+20     	; 0x13818 <PrintIdle+0x2a2>
   13804:	02 c0       	rjmp	.+4      	; 0x1380a <PrintIdle+0x294>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
   13806:	8a e0       	ldi	r24, 0x0A	; 10
   13808:	03 c0       	rjmp	.+6      	; 0x13810 <PrintIdle+0x29a>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
   1380a:	84 e1       	ldi	r24, 0x14	; 20
   1380c:	01 c0       	rjmp	.+2      	; 0x13810 <PrintIdle+0x29a>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
   1380e:	8c e0       	ldi	r24, 0x0C	; 12
   13810:	80 93 00 02 	sts	0x0200, r24
			   PrintCopy=2;
   13814:	82 e0       	ldi	r24, 0x02	; 2
   13816:	04 c0       	rjmp	.+8      	; 0x13820 <PrintIdle+0x2aa>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
   13818:	8a e0       	ldi	r24, 0x0A	; 10
   1381a:	80 93 00 02 	sts	0x0200, r24
			   PrintCopy=1;
   1381e:	81 e0       	ldi	r24, 0x01	; 1
   13820:	80 93 f7 01 	sts	0x01F7, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
   13824:	80 91 e7 02 	lds	r24, 0x02E7
   13828:	88 23       	and	r24, r24
   1382a:	49 f0       	breq	.+18     	; 0x1383e <PrintIdle+0x2c8>
   1382c:	87 ee       	ldi	r24, 0xE7	; 231
   1382e:	92 e0       	ldi	r25, 0x02	; 2
   13830:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   13834:	88 23       	and	r24, r24
   13836:	19 f4       	brne	.+6      	; 0x1383e <PrintIdle+0x2c8>
		       MessageLine=33;
   13838:	81 e2       	ldi	r24, 0x21	; 33
   1383a:	80 93 00 02 	sts	0x0200, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
   1383e:	88 e0       	ldi	r24, 0x08	; 8
   13840:	25 c6       	rjmp	.+3146   	; 0x1448c <PrintIdle+0xf16>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
   13842:	80 91 f8 01 	lds	r24, 0x01F8
   13846:	88 23       	and	r24, r24
   13848:	09 f0       	breq	.+2      	; 0x1384c <PrintIdle+0x2d6>
   1384a:	c9 c4       	rjmp	.+2450   	; 0x141de <PrintIdle+0xc68>

		      FormatDate(DATE_LONG_YEAR,strDate);
   1384c:	6e e6       	ldi	r22, 0x6E	; 110
   1384e:	77 e0       	ldi	r23, 0x07	; 7
   13850:	0e 94 07 28 	call	0x500e	; 0x500e <FormatDate>
              RemZeroLead(strIslandID);
   13854:	87 ef       	ldi	r24, 0xF7	; 247
   13856:	98 e0       	ldi	r25, 0x08	; 8
   13858:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
			  RemZeroLead(strFIP_ID);
   1385c:	89 eb       	ldi	r24, 0xB9	; 185
   1385e:	97 e0       	ldi	r25, 0x07	; 7
   13860:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		      RemZeroLead(strPrice);              
   13864:	8e e9       	ldi	r24, 0x9E	; 158
   13866:	95 e0       	ldi	r25, 0x05	; 5
   13868:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
              if (IFType==IT_SLAVE)
   1386c:	80 91 00 01 	lds	r24, 0x0100
   13870:	81 30       	cpi	r24, 0x01	; 1
   13872:	21 f4       	brne	.+8      	; 0x1387c <PrintIdle+0x306>
			      RemZeroLead(strVolume);
   13874:	85 e7       	ldi	r24, 0x75	; 117
   13876:	93 e0       	ldi	r25, 0x03	; 3
   13878:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
              RemZeroLead(strAmount);
   1387c:	83 eb       	ldi	r24, 0xB3	; 179
   1387e:	9b e0       	ldi	r25, 0x0B	; 11
   13880:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>

			  RemDecimal(strPrice);
   13884:	8e e9       	ldi	r24, 0x9E	; 158
   13886:	95 e0       	ldi	r25, 0x05	; 5
   13888:	0e 94 50 27 	call	0x4ea0	; 0x4ea0 <RemDecimal>
			  RemDecimal(strAmount);
   1388c:	83 eb       	ldi	r24, 0xB3	; 179
   1388e:	9b e0       	ldi	r25, 0x0B	; 11
   13890:	0e 94 50 27 	call	0x4ea0	; 0x4ea0 <RemDecimal>
	  
			  FormatCurrency(strPrice);
   13894:	8e e9       	ldi	r24, 0x9E	; 158
   13896:	95 e0       	ldi	r25, 0x05	; 5
   13898:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
			  FormatCurrency(strAmount);
   1389c:	83 eb       	ldi	r24, 0xB3	; 179
   1389e:	9b e0       	ldi	r25, 0x0B	; 11
   138a0:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
              if (IFType==IT_SLAVE){
   138a4:	80 91 00 01 	lds	r24, 0x0100
   138a8:	81 30       	cpi	r24, 0x01	; 1
   138aa:	09 f0       	breq	.+2      	; 0x138ae <PrintIdle+0x338>
   138ac:	98 c4       	rjmp	.+2352   	; 0x141de <PrintIdle+0xc68>
		          RemSpaceLag(strCardID);
   138ae:	89 e8       	ldi	r24, 0x89	; 137
   138b0:	9b e0       	ldi	r25, 0x0B	; 11
   138b2:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
   138b6:	84 e2       	ldi	r24, 0x24	; 36
   138b8:	93 e0       	ldi	r25, 0x03	; 3
   138ba:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
   138be:	8d e7       	ldi	r24, 0x7D	; 125
   138c0:	95 e0       	ldi	r25, 0x05	; 5
   138c2:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
   138c6:	84 ec       	ldi	r24, 0xC4	; 196
   138c8:	92 e0       	ldi	r25, 0x02	; 2
   138ca:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
   138ce:	8a e0       	ldi	r24, 0x0A	; 10
   138d0:	9c e0       	ldi	r25, 0x0C	; 12
   138d2:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
   138d6:	8d ec       	ldi	r24, 0xCD	; 205
   138d8:	93 e0       	ldi	r25, 0x03	; 3
   138da:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
   138de:	8a e9       	ldi	r24, 0x9A	; 154
   138e0:	93 e0       	ldi	r25, 0x03	; 3
   138e2:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
   138e6:	8d ee       	ldi	r24, 0xED	; 237
   138e8:	9b e0       	ldi	r25, 0x0B	; 11
   138ea:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
   138ee:	8e e7       	ldi	r24, 0x7E	; 126
   138f0:	93 e0       	ldi	r25, 0x03	; 3
   138f2:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
   138f6:	8d ee       	ldi	r24, 0xED	; 237
   138f8:	9b e0       	ldi	r25, 0x0B	; 11
   138fa:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
   138fe:	8e e7       	ldi	r24, 0x7E	; 126
   13900:	93 e0       	ldi	r25, 0x03	; 3
   13902:	0e 94 48 36 	call	0x6c90	; 0x6c90 <FormatCurrency>
   13906:	6b c4       	rjmp	.+2262   	; 0x141de <PrintIdle+0xc68>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
   13908:	80 91 01 02 	lds	r24, 0x0201
   1390c:	e8 2f       	mov	r30, r24
   1390e:	f0 e0       	ldi	r31, 0x00	; 0
   13910:	e5 32       	cpi	r30, 0x25	; 37
   13912:	f1 05       	cpc	r31, r1
   13914:	08 f0       	brcs	.+2      	; 0x13918 <PrintIdle+0x3a2>
   13916:	26 c4       	rjmp	.+2124   	; 0x14164 <PrintIdle+0xbee>
   13918:	e0 50       	subi	r30, 0x00	; 0
   1391a:	ff 4f       	sbci	r31, 0xFF	; 255
   1391c:	ee 0f       	add	r30, r30
   1391e:	ff 1f       	adc	r31, r31
   13920:	05 90       	lpm	r0, Z+
   13922:	f4 91       	lpm	r31, Z+
   13924:	e0 2d       	mov	r30, r0
   13926:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
   13928:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
   1392c:	8d b7       	in	r24, 0x3d	; 61
   1392e:	9e b7       	in	r25, 0x3e	; 62
   13930:	08 97       	sbiw	r24, 0x08	; 8
   13932:	0f b6       	in	r0, 0x3f	; 63
   13934:	f8 94       	cli
   13936:	9e bf       	out	0x3e, r25	; 62
   13938:	0f be       	out	0x3f, r0	; 63
   1393a:	8d bf       	out	0x3d, r24	; 61
   1393c:	ed b7       	in	r30, 0x3d	; 61
   1393e:	fe b7       	in	r31, 0x3e	; 62
   13940:	31 96       	adiw	r30, 0x01	; 1
   13942:	8c eb       	ldi	r24, 0xBC	; 188
   13944:	98 e0       	ldi	r25, 0x08	; 8
   13946:	ad b7       	in	r26, 0x3d	; 61
   13948:	be b7       	in	r27, 0x3e	; 62
   1394a:	12 96       	adiw	r26, 0x02	; 2
   1394c:	9c 93       	st	X, r25
   1394e:	8e 93       	st	-X, r24
   13950:	11 97       	sbiw	r26, 0x01	; 1
   13952:	89 e5       	ldi	r24, 0x59	; 89
   13954:	9b e0       	ldi	r25, 0x0B	; 11
   13956:	93 83       	std	Z+3, r25	; 0x03
   13958:	82 83       	std	Z+2, r24	; 0x02
   1395a:	88 e6       	ldi	r24, 0x68	; 104
   1395c:	9c e0       	ldi	r25, 0x0C	; 12
   1395e:	95 83       	std	Z+5, r25	; 0x05
   13960:	84 83       	std	Z+4, r24	; 0x04
   13962:	87 e8       	ldi	r24, 0x87	; 135
   13964:	9c e0       	ldi	r25, 0x0C	; 12
   13966:	1f c0       	rjmp	.+62     	; 0x139a6 <PrintIdle+0x430>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
   13968:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
   1396c:	8d b7       	in	r24, 0x3d	; 61
   1396e:	9e b7       	in	r25, 0x3e	; 62
   13970:	08 97       	sbiw	r24, 0x08	; 8
   13972:	0f b6       	in	r0, 0x3f	; 63
   13974:	f8 94       	cli
   13976:	9e bf       	out	0x3e, r25	; 62
   13978:	0f be       	out	0x3f, r0	; 63
   1397a:	8d bf       	out	0x3d, r24	; 61
   1397c:	ed b7       	in	r30, 0x3d	; 61
   1397e:	fe b7       	in	r31, 0x3e	; 62
   13980:	31 96       	adiw	r30, 0x01	; 1
   13982:	8c eb       	ldi	r24, 0xBC	; 188
   13984:	98 e0       	ldi	r25, 0x08	; 8
   13986:	ad b7       	in	r26, 0x3d	; 61
   13988:	be b7       	in	r27, 0x3e	; 62
   1398a:	12 96       	adiw	r26, 0x02	; 2
   1398c:	9c 93       	st	X, r25
   1398e:	8e 93       	st	-X, r24
   13990:	11 97       	sbiw	r26, 0x01	; 1
   13992:	85 e4       	ldi	r24, 0x45	; 69
   13994:	9b e0       	ldi	r25, 0x0B	; 11
   13996:	93 83       	std	Z+3, r25	; 0x03
   13998:	82 83       	std	Z+2, r24	; 0x02
   1399a:	8e e6       	ldi	r24, 0x6E	; 110
   1399c:	97 e0       	ldi	r25, 0x07	; 7
   1399e:	95 83       	std	Z+5, r25	; 0x05
   139a0:	84 83       	std	Z+4, r24	; 0x04
   139a2:	8d e4       	ldi	r24, 0x4D	; 77
   139a4:	93 e0       	ldi	r25, 0x03	; 3
   139a6:	97 83       	std	Z+7, r25	; 0x07
   139a8:	86 83       	std	Z+6, r24	; 0x06
   139aa:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   139ae:	ed b7       	in	r30, 0x3d	; 61
   139b0:	fe b7       	in	r31, 0x3e	; 62
   139b2:	38 96       	adiw	r30, 0x08	; 8
   139b4:	b9 c3       	rjmp	.+1906   	; 0x14128 <PrintIdle+0xbb2>
		       break;
		  case 2:
		       CarriegeReturn();
   139b6:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
   139ba:	00 d0       	rcall	.+0      	; 0x139bc <PrintIdle+0x446>
   139bc:	00 d0       	rcall	.+0      	; 0x139be <PrintIdle+0x448>
   139be:	8c eb       	ldi	r24, 0xBC	; 188
   139c0:	98 e0       	ldi	r25, 0x08	; 8
   139c2:	ad b7       	in	r26, 0x3d	; 61
   139c4:	be b7       	in	r27, 0x3e	; 62
   139c6:	12 96       	adiw	r26, 0x02	; 2
   139c8:	9c 93       	st	X, r25
   139ca:	8e 93       	st	-X, r24
   139cc:	11 97       	sbiw	r26, 0x01	; 1
   139ce:	82 e2       	ldi	r24, 0x22	; 34
   139d0:	9b e0       	ldi	r25, 0x0B	; 11
   139d2:	be c3       	rjmp	.+1916   	; 0x14150 <PrintIdle+0xbda>
		       break;
		  case 3:
		       CarriegeReturn();
   139d4:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
   139d8:	ed b7       	in	r30, 0x3d	; 61
   139da:	fe b7       	in	r31, 0x3e	; 62
   139dc:	38 97       	sbiw	r30, 0x08	; 8
   139de:	0f b6       	in	r0, 0x3f	; 63
   139e0:	f8 94       	cli
   139e2:	fe bf       	out	0x3e, r31	; 62
   139e4:	0f be       	out	0x3f, r0	; 63
   139e6:	ed bf       	out	0x3d, r30	; 61
   139e8:	31 96       	adiw	r30, 0x01	; 1
   139ea:	8c eb       	ldi	r24, 0xBC	; 188
   139ec:	98 e0       	ldi	r25, 0x08	; 8
   139ee:	ad b7       	in	r26, 0x3d	; 61
   139f0:	be b7       	in	r27, 0x3e	; 62
   139f2:	12 96       	adiw	r26, 0x02	; 2
   139f4:	9c 93       	st	X, r25
   139f6:	8e 93       	st	-X, r24
   139f8:	11 97       	sbiw	r26, 0x01	; 1
   139fa:	86 e0       	ldi	r24, 0x06	; 6
   139fc:	9b e0       	ldi	r25, 0x0B	; 11
   139fe:	93 83       	std	Z+3, r25	; 0x03
   13a00:	82 83       	std	Z+2, r24	; 0x02
   13a02:	87 ef       	ldi	r24, 0xF7	; 247
   13a04:	98 e0       	ldi	r25, 0x08	; 8
   13a06:	95 83       	std	Z+5, r25	; 0x05
   13a08:	84 83       	std	Z+4, r24	; 0x04
   13a0a:	89 eb       	ldi	r24, 0xB9	; 185
   13a0c:	97 e0       	ldi	r25, 0x07	; 7
   13a0e:	cb cf       	rjmp	.-106    	; 0x139a6 <PrintIdle+0x430>
		       break;
		  case 4:
		       CarriegeReturn();
   13a10:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
   13a14:	00 d0       	rcall	.+0      	; 0x13a16 <PrintIdle+0x4a0>
   13a16:	00 d0       	rcall	.+0      	; 0x13a18 <PrintIdle+0x4a2>
   13a18:	00 d0       	rcall	.+0      	; 0x13a1a <PrintIdle+0x4a4>
   13a1a:	ed b7       	in	r30, 0x3d	; 61
   13a1c:	fe b7       	in	r31, 0x3e	; 62
   13a1e:	31 96       	adiw	r30, 0x01	; 1
   13a20:	8c eb       	ldi	r24, 0xBC	; 188
   13a22:	98 e0       	ldi	r25, 0x08	; 8
   13a24:	ad b7       	in	r26, 0x3d	; 61
   13a26:	be b7       	in	r27, 0x3e	; 62
   13a28:	12 96       	adiw	r26, 0x02	; 2
   13a2a:	9c 93       	st	X, r25
   13a2c:	8e 93       	st	-X, r24
   13a2e:	11 97       	sbiw	r26, 0x01	; 1
   13a30:	8f ee       	ldi	r24, 0xEF	; 239
   13a32:	9a e0       	ldi	r25, 0x0A	; 10
   13a34:	93 83       	std	Z+3, r25	; 0x03
   13a36:	82 83       	std	Z+2, r24	; 0x02
   13a38:	8c e0       	ldi	r24, 0x0C	; 12
   13a3a:	98 e0       	ldi	r25, 0x08	; 8
   13a3c:	6e c3       	rjmp	.+1756   	; 0x1411a <PrintIdle+0xba4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13a3e:	e1 99       	sbic	0x1c, 1	; 28
   13a40:	fe cf       	rjmp	.-4      	; 0x13a3e <PrintIdle+0x4c8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13a42:	81 ec       	ldi	r24, 0xC1	; 193
   13a44:	93 e0       	ldi	r25, 0x03	; 3
   13a46:	9f bb       	out	0x1f, r25	; 31
   13a48:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13a4a:	e0 9a       	sbi	0x1c, 0	; 28
   13a4c:	8d b3       	in	r24, 0x1d	; 29
   13a4e:	0c eb       	ldi	r16, 0xBC	; 188
   13a50:	18 e0       	ldi	r17, 0x08	; 8
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
   13a52:	81 30       	cpi	r24, 0x01	; 1
   13a54:	a9 f4       	brne	.+42     	; 0x13a80 <PrintIdle+0x50a>
			   	   CarriegeReturn();
   13a56:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
   13a5a:	00 d0       	rcall	.+0      	; 0x13a5c <PrintIdle+0x4e6>
   13a5c:	00 d0       	rcall	.+0      	; 0x13a5e <PrintIdle+0x4e8>
   13a5e:	00 d0       	rcall	.+0      	; 0x13a60 <PrintIdle+0x4ea>
   13a60:	ed b7       	in	r30, 0x3d	; 61
   13a62:	fe b7       	in	r31, 0x3e	; 62
   13a64:	31 96       	adiw	r30, 0x01	; 1
   13a66:	ad b7       	in	r26, 0x3d	; 61
   13a68:	be b7       	in	r27, 0x3e	; 62
   13a6a:	12 96       	adiw	r26, 0x02	; 2
   13a6c:	1c 93       	st	X, r17
   13a6e:	0e 93       	st	-X, r16
   13a70:	11 97       	sbiw	r26, 0x01	; 1
   13a72:	85 ed       	ldi	r24, 0xD5	; 213
   13a74:	9a e0       	ldi	r25, 0x0A	; 10
   13a76:	93 83       	std	Z+3, r25	; 0x03
   13a78:	82 83       	std	Z+2, r24	; 0x02
   13a7a:	8e e9       	ldi	r24, 0x9E	; 158
   13a7c:	95 e0       	ldi	r25, 0x05	; 5
   13a7e:	4d c3       	rjmp	.+1690   	; 0x1411a <PrintIdle+0xba4>
			   }else sprintf_P(strPrint,PSTR(""));
   13a80:	00 d0       	rcall	.+0      	; 0x13a82 <PrintIdle+0x50c>
   13a82:	00 d0       	rcall	.+0      	; 0x13a84 <PrintIdle+0x50e>
   13a84:	ad b7       	in	r26, 0x3d	; 61
   13a86:	be b7       	in	r27, 0x3e	; 62
   13a88:	12 96       	adiw	r26, 0x02	; 2
   13a8a:	1c 93       	st	X, r17
   13a8c:	0e 93       	st	-X, r16
   13a8e:	11 97       	sbiw	r26, 0x01	; 1
   13a90:	84 ed       	ldi	r24, 0xD4	; 212
   13a92:	9a e0       	ldi	r25, 0x0A	; 10
   13a94:	5d c3       	rjmp	.+1722   	; 0x14150 <PrintIdle+0xbda>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
   13a96:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
   13a9a:	00 d0       	rcall	.+0      	; 0x13a9c <PrintIdle+0x526>
   13a9c:	00 d0       	rcall	.+0      	; 0x13a9e <PrintIdle+0x528>
   13a9e:	00 d0       	rcall	.+0      	; 0x13aa0 <PrintIdle+0x52a>
   13aa0:	ed b7       	in	r30, 0x3d	; 61
   13aa2:	fe b7       	in	r31, 0x3e	; 62
   13aa4:	31 96       	adiw	r30, 0x01	; 1
   13aa6:	8c eb       	ldi	r24, 0xBC	; 188
   13aa8:	98 e0       	ldi	r25, 0x08	; 8
   13aaa:	ad b7       	in	r26, 0x3d	; 61
   13aac:	be b7       	in	r27, 0x3e	; 62
   13aae:	12 96       	adiw	r26, 0x02	; 2
   13ab0:	9c 93       	st	X, r25
   13ab2:	8e 93       	st	-X, r24
   13ab4:	11 97       	sbiw	r26, 0x01	; 1
   13ab6:	8b eb       	ldi	r24, 0xBB	; 187
   13ab8:	9a e0       	ldi	r25, 0x0A	; 10
   13aba:	93 83       	std	Z+3, r25	; 0x03
   13abc:	82 83       	std	Z+2, r24	; 0x02
   13abe:	85 e7       	ldi	r24, 0x75	; 117
   13ac0:	93 e0       	ldi	r25, 0x03	; 3
   13ac2:	2b c3       	rjmp	.+1622   	; 0x1411a <PrintIdle+0xba4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13ac4:	e1 99       	sbic	0x1c, 1	; 28
   13ac6:	fe cf       	rjmp	.-4      	; 0x13ac4 <PrintIdle+0x54e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13ac8:	81 ec       	ldi	r24, 0xC1	; 193
   13aca:	93 e0       	ldi	r25, 0x03	; 3
   13acc:	9f bb       	out	0x1f, r25	; 31
   13ace:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13ad0:	e0 9a       	sbi	0x1c, 0	; 28
   13ad2:	8d b3       	in	r24, 0x1d	; 29
   13ad4:	0c eb       	ldi	r16, 0xBC	; 188
   13ad6:	18 e0       	ldi	r17, 0x08	; 8
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
   13ad8:	81 30       	cpi	r24, 0x01	; 1
   13ada:	a9 f4       	brne	.+42     	; 0x13b06 <PrintIdle+0x590>
			   	   CarriegeReturn();
   13adc:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
   13ae0:	00 d0       	rcall	.+0      	; 0x13ae2 <PrintIdle+0x56c>
   13ae2:	00 d0       	rcall	.+0      	; 0x13ae4 <PrintIdle+0x56e>
   13ae4:	00 d0       	rcall	.+0      	; 0x13ae6 <PrintIdle+0x570>
   13ae6:	ed b7       	in	r30, 0x3d	; 61
   13ae8:	fe b7       	in	r31, 0x3e	; 62
   13aea:	31 96       	adiw	r30, 0x01	; 1
   13aec:	ad b7       	in	r26, 0x3d	; 61
   13aee:	be b7       	in	r27, 0x3e	; 62
   13af0:	12 96       	adiw	r26, 0x02	; 2
   13af2:	1c 93       	st	X, r17
   13af4:	0e 93       	st	-X, r16
   13af6:	11 97       	sbiw	r26, 0x01	; 1
   13af8:	81 ea       	ldi	r24, 0xA1	; 161
   13afa:	9a e0       	ldi	r25, 0x0A	; 10
   13afc:	93 83       	std	Z+3, r25	; 0x03
   13afe:	82 83       	std	Z+2, r24	; 0x02
   13b00:	83 eb       	ldi	r24, 0xB3	; 179
   13b02:	9b e0       	ldi	r25, 0x0B	; 11
   13b04:	0a c3       	rjmp	.+1556   	; 0x1411a <PrintIdle+0xba4>
			   }else sprintf_P(strPrint,PSTR(""));
   13b06:	00 d0       	rcall	.+0      	; 0x13b08 <PrintIdle+0x592>
   13b08:	00 d0       	rcall	.+0      	; 0x13b0a <PrintIdle+0x594>
   13b0a:	ad b7       	in	r26, 0x3d	; 61
   13b0c:	be b7       	in	r27, 0x3e	; 62
   13b0e:	12 96       	adiw	r26, 0x02	; 2
   13b10:	1c 93       	st	X, r17
   13b12:	0e 93       	st	-X, r16
   13b14:	11 97       	sbiw	r26, 0x01	; 1
   13b16:	80 ea       	ldi	r24, 0xA0	; 160
   13b18:	9a e0       	ldi	r25, 0x0A	; 10
   13b1a:	1a c3       	rjmp	.+1588   	; 0x14150 <PrintIdle+0xbda>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
   13b1c:	0a ef       	ldi	r16, 0xFA	; 250
   13b1e:	18 e0       	ldi	r17, 0x08	; 8
   13b20:	80 91 fa 08 	lds	r24, 0x08FA
   13b24:	88 23       	and	r24, r24
   13b26:	09 f4       	brne	.+2      	; 0x13b2a <PrintIdle+0x5b4>
   13b28:	18 c2       	rjmp	.+1072   	; 0x13f5a <PrintIdle+0x9e4>
   13b2a:	c8 01       	movw	r24, r16
   13b2c:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   13b30:	88 23       	and	r24, r24
   13b32:	09 f0       	breq	.+2      	; 0x13b36 <PrintIdle+0x5c0>
   13b34:	12 c2       	rjmp	.+1060   	; 0x13f5a <PrintIdle+0x9e4>
			       CarriegeReturn();
   13b36:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
   13b3a:	00 d0       	rcall	.+0      	; 0x13b3c <PrintIdle+0x5c6>
   13b3c:	00 d0       	rcall	.+0      	; 0x13b3e <PrintIdle+0x5c8>
   13b3e:	00 d0       	rcall	.+0      	; 0x13b40 <PrintIdle+0x5ca>
   13b40:	ed b7       	in	r30, 0x3d	; 61
   13b42:	fe b7       	in	r31, 0x3e	; 62
   13b44:	31 96       	adiw	r30, 0x01	; 1
   13b46:	8c eb       	ldi	r24, 0xBC	; 188
   13b48:	98 e0       	ldi	r25, 0x08	; 8
   13b4a:	ad b7       	in	r26, 0x3d	; 61
   13b4c:	be b7       	in	r27, 0x3e	; 62
   13b4e:	12 96       	adiw	r26, 0x02	; 2
   13b50:	9c 93       	st	X, r25
   13b52:	8e 93       	st	-X, r24
   13b54:	11 97       	sbiw	r26, 0x01	; 1
   13b56:	89 e8       	ldi	r24, 0x89	; 137
   13b58:	9a e0       	ldi	r25, 0x0A	; 10
   13b5a:	1f c0       	rjmp	.+62     	; 0x13b9a <PrintIdle+0x624>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
   13b5c:	03 ec       	ldi	r16, 0xC3	; 195
   13b5e:	13 e0       	ldi	r17, 0x03	; 3
   13b60:	80 91 c3 03 	lds	r24, 0x03C3
   13b64:	88 23       	and	r24, r24
   13b66:	09 f4       	brne	.+2      	; 0x13b6a <PrintIdle+0x5f4>
   13b68:	f8 c1       	rjmp	.+1008   	; 0x13f5a <PrintIdle+0x9e4>
   13b6a:	c8 01       	movw	r24, r16
   13b6c:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   13b70:	88 23       	and	r24, r24
   13b72:	09 f0       	breq	.+2      	; 0x13b76 <PrintIdle+0x600>
   13b74:	f2 c1       	rjmp	.+996    	; 0x13f5a <PrintIdle+0x9e4>
			       CarriegeReturn();
   13b76:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
   13b7a:	00 d0       	rcall	.+0      	; 0x13b7c <PrintIdle+0x606>
   13b7c:	00 d0       	rcall	.+0      	; 0x13b7e <PrintIdle+0x608>
   13b7e:	00 d0       	rcall	.+0      	; 0x13b80 <PrintIdle+0x60a>
   13b80:	ed b7       	in	r30, 0x3d	; 61
   13b82:	fe b7       	in	r31, 0x3e	; 62
   13b84:	31 96       	adiw	r30, 0x01	; 1
   13b86:	8c eb       	ldi	r24, 0xBC	; 188
   13b88:	98 e0       	ldi	r25, 0x08	; 8
   13b8a:	ad b7       	in	r26, 0x3d	; 61
   13b8c:	be b7       	in	r27, 0x3e	; 62
   13b8e:	12 96       	adiw	r26, 0x02	; 2
   13b90:	9c 93       	st	X, r25
   13b92:	8e 93       	st	-X, r24
   13b94:	11 97       	sbiw	r26, 0x01	; 1
   13b96:	82 e7       	ldi	r24, 0x72	; 114
   13b98:	9a e0       	ldi	r25, 0x0A	; 10
   13b9a:	93 83       	std	Z+3, r25	; 0x03
   13b9c:	82 83       	std	Z+2, r24	; 0x02
   13b9e:	15 83       	std	Z+5, r17	; 0x05
   13ba0:	04 83       	std	Z+4, r16	; 0x04
   13ba2:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				   ClearMem(strOdometer);
   13ba6:	ed b7       	in	r30, 0x3d	; 61
   13ba8:	fe b7       	in	r31, 0x3e	; 62
   13baa:	36 96       	adiw	r30, 0x06	; 6
   13bac:	0f b6       	in	r0, 0x3f	; 63
   13bae:	f8 94       	cli
   13bb0:	fe bf       	out	0x3e, r31	; 62
   13bb2:	0f be       	out	0x3f, r0	; 63
   13bb4:	ed bf       	out	0x3d, r30	; 61
   13bb6:	c8 01       	movw	r24, r16
   13bb8:	0e 94 19 aa 	call	0x15432	; 0x15432 <ClearMem>
   13bbc:	d3 c2       	rjmp	.+1446   	; 0x14164 <PrintIdle+0xbee>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
   13bbe:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
   13bc2:	00 d0       	rcall	.+0      	; 0x13bc4 <PrintIdle+0x64e>
   13bc4:	00 d0       	rcall	.+0      	; 0x13bc6 <PrintIdle+0x650>
   13bc6:	8c eb       	ldi	r24, 0xBC	; 188
   13bc8:	98 e0       	ldi	r25, 0x08	; 8
   13bca:	ad b7       	in	r26, 0x3d	; 61
   13bcc:	be b7       	in	r27, 0x3e	; 62
   13bce:	12 96       	adiw	r26, 0x02	; 2
   13bd0:	9c 93       	st	X, r25
   13bd2:	8e 93       	st	-X, r24
   13bd4:	11 97       	sbiw	r26, 0x01	; 1
   13bd6:	8f e4       	ldi	r24, 0x4F	; 79
   13bd8:	9a e0       	ldi	r25, 0x0A	; 10
   13bda:	ba c2       	rjmp	.+1396   	; 0x14150 <PrintIdle+0xbda>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
   13bdc:	80 91 b8 01 	lds	r24, 0x01B8
   13be0:	81 30       	cpi	r24, 0x01	; 1
   13be2:	21 f0       	breq	.+8      	; 0x13bec <PrintIdle+0x676>
   13be4:	83 30       	cpi	r24, 0x03	; 3
   13be6:	11 f0       	breq	.+4      	; 0x13bec <PrintIdle+0x676>
   13be8:	86 30       	cpi	r24, 0x06	; 6
   13bea:	b9 f4       	brne	.+46     	; 0x13c1a <PrintIdle+0x6a4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
   13bec:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
   13bf0:	00 d0       	rcall	.+0      	; 0x13bf2 <PrintIdle+0x67c>
   13bf2:	00 d0       	rcall	.+0      	; 0x13bf4 <PrintIdle+0x67e>
   13bf4:	00 d0       	rcall	.+0      	; 0x13bf6 <PrintIdle+0x680>
   13bf6:	ed b7       	in	r30, 0x3d	; 61
   13bf8:	fe b7       	in	r31, 0x3e	; 62
   13bfa:	31 96       	adiw	r30, 0x01	; 1
   13bfc:	8c eb       	ldi	r24, 0xBC	; 188
   13bfe:	98 e0       	ldi	r25, 0x08	; 8
   13c00:	ad b7       	in	r26, 0x3d	; 61
   13c02:	be b7       	in	r27, 0x3e	; 62
   13c04:	12 96       	adiw	r26, 0x02	; 2
   13c06:	9c 93       	st	X, r25
   13c08:	8e 93       	st	-X, r24
   13c0a:	11 97       	sbiw	r26, 0x01	; 1
   13c0c:	8d e3       	ldi	r24, 0x3D	; 61
   13c0e:	9a e0       	ldi	r25, 0x0A	; 10
   13c10:	93 83       	std	Z+3, r25	; 0x03
   13c12:	82 83       	std	Z+2, r24	; 0x02
   13c14:	89 e8       	ldi	r24, 0x89	; 137
   13c16:	9b e0       	ldi	r25, 0x0B	; 11
   13c18:	18 c0       	rjmp	.+48     	; 0x13c4a <PrintIdle+0x6d4>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
   13c1a:	87 30       	cpi	r24, 0x07	; 7
   13c1c:	f1 f4       	brne	.+60     	; 0x13c5a <PrintIdle+0x6e4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
   13c1e:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
   13c22:	00 d0       	rcall	.+0      	; 0x13c24 <PrintIdle+0x6ae>
   13c24:	00 d0       	rcall	.+0      	; 0x13c26 <PrintIdle+0x6b0>
   13c26:	00 d0       	rcall	.+0      	; 0x13c28 <PrintIdle+0x6b2>
   13c28:	ed b7       	in	r30, 0x3d	; 61
   13c2a:	fe b7       	in	r31, 0x3e	; 62
   13c2c:	31 96       	adiw	r30, 0x01	; 1
   13c2e:	8c eb       	ldi	r24, 0xBC	; 188
   13c30:	98 e0       	ldi	r25, 0x08	; 8
   13c32:	ad b7       	in	r26, 0x3d	; 61
   13c34:	be b7       	in	r27, 0x3e	; 62
   13c36:	12 96       	adiw	r26, 0x02	; 2
   13c38:	9c 93       	st	X, r25
   13c3a:	8e 93       	st	-X, r24
   13c3c:	11 97       	sbiw	r26, 0x01	; 1
   13c3e:	8a e2       	ldi	r24, 0x2A	; 42
   13c40:	9a e0       	ldi	r25, 0x0A	; 10
   13c42:	93 83       	std	Z+3, r25	; 0x03
   13c44:	82 83       	std	Z+2, r24	; 0x02
   13c46:	8c e3       	ldi	r24, 0x3C	; 60
   13c48:	9c e0       	ldi	r25, 0x0C	; 12
   13c4a:	95 83       	std	Z+5, r25	; 0x05
   13c4c:	84 83       	std	Z+4, r24	; 0x04
   13c4e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				   IsSignedField=True;
   13c52:	81 e0       	ldi	r24, 0x01	; 1
   13c54:	80 93 ff 01 	sts	0x01FF, r24
   13c58:	64 c2       	rjmp	.+1224   	; 0x14122 <PrintIdle+0xbac>
   13c5a:	0c eb       	ldi	r16, 0xBC	; 188
   13c5c:	18 e0       	ldi	r17, 0x08	; 8
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
   13c5e:	88 30       	cpi	r24, 0x08	; 8
   13c60:	09 f0       	breq	.+2      	; 0x13c64 <PrintIdle+0x6ee>
   13c62:	a9 cf       	rjmp	.-174    	; 0x13bb6 <PrintIdle+0x640>
			       CarriegeReturn();
   13c64:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
   13c68:	00 d0       	rcall	.+0      	; 0x13c6a <PrintIdle+0x6f4>
   13c6a:	00 d0       	rcall	.+0      	; 0x13c6c <PrintIdle+0x6f6>
   13c6c:	ad b7       	in	r26, 0x3d	; 61
   13c6e:	be b7       	in	r27, 0x3e	; 62
   13c70:	12 96       	adiw	r26, 0x02	; 2
   13c72:	1c 93       	st	X, r17
   13c74:	0e 93       	st	-X, r16
   13c76:	11 97       	sbiw	r26, 0x01	; 1
   13c78:	87 e0       	ldi	r24, 0x07	; 7
   13c7a:	9a e0       	ldi	r25, 0x0A	; 10
   13c7c:	14 96       	adiw	r26, 0x04	; 4
   13c7e:	9c 93       	st	X, r25
   13c80:	8e 93       	st	-X, r24
   13c82:	13 97       	sbiw	r26, 0x03	; 3
   13c84:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
				   IsSignedField=False;
   13c88:	10 92 ff 01 	sts	0x01FF, r1
   13c8c:	67 c2       	rjmp	.+1230   	; 0x1415c <PrintIdle+0xbe6>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
   13c8e:	80 91 b8 01 	lds	r24, 0x01B8
   13c92:	81 30       	cpi	r24, 0x01	; 1
   13c94:	99 f4       	brne	.+38     	; 0x13cbc <PrintIdle+0x746>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
   13c96:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
   13c9a:	00 d0       	rcall	.+0      	; 0x13c9c <PrintIdle+0x726>
   13c9c:	00 d0       	rcall	.+0      	; 0x13c9e <PrintIdle+0x728>
   13c9e:	00 d0       	rcall	.+0      	; 0x13ca0 <PrintIdle+0x72a>
   13ca0:	ed b7       	in	r30, 0x3d	; 61
   13ca2:	fe b7       	in	r31, 0x3e	; 62
   13ca4:	31 96       	adiw	r30, 0x01	; 1
   13ca6:	8c eb       	ldi	r24, 0xBC	; 188
   13ca8:	98 e0       	ldi	r25, 0x08	; 8
   13caa:	ad b7       	in	r26, 0x3d	; 61
   13cac:	be b7       	in	r27, 0x3e	; 62
   13cae:	12 96       	adiw	r26, 0x02	; 2
   13cb0:	9c 93       	st	X, r25
   13cb2:	8e 93       	st	-X, r24
   13cb4:	11 97       	sbiw	r26, 0x01	; 1
   13cb6:	85 ef       	ldi	r24, 0xF5	; 245
   13cb8:	99 e0       	ldi	r25, 0x09	; 9
   13cba:	3a c0       	rjmp	.+116    	; 0x13d30 <PrintIdle+0x7ba>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
   13cbc:	83 30       	cpi	r24, 0x03	; 3
   13cbe:	e9 f5       	brne	.+122    	; 0x13d3a <PrintIdle+0x7c4>
			       if (IsPrintApprovalCode==True){
   13cc0:	80 91 9a 01 	lds	r24, 0x019A
   13cc4:	81 30       	cpi	r24, 0x01	; 1
   13cc6:	11 f5       	brne	.+68     	; 0x13d0c <PrintIdle+0x796>
				       IsPrintApprovalCode=False;
   13cc8:	10 92 9a 01 	sts	0x019A, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
   13ccc:	00 d0       	rcall	.+0      	; 0x13cce <PrintIdle+0x758>
   13cce:	00 d0       	rcall	.+0      	; 0x13cd0 <PrintIdle+0x75a>
   13cd0:	00 d0       	rcall	.+0      	; 0x13cd2 <PrintIdle+0x75c>
   13cd2:	ed b7       	in	r30, 0x3d	; 61
   13cd4:	fe b7       	in	r31, 0x3e	; 62
   13cd6:	31 96       	adiw	r30, 0x01	; 1
   13cd8:	84 e2       	ldi	r24, 0x24	; 36
   13cda:	93 e0       	ldi	r25, 0x03	; 3
   13cdc:	ad b7       	in	r26, 0x3d	; 61
   13cde:	be b7       	in	r27, 0x3e	; 62
   13ce0:	12 96       	adiw	r26, 0x02	; 2
   13ce2:	9c 93       	st	X, r25
   13ce4:	8e 93       	st	-X, r24
   13ce6:	11 97       	sbiw	r26, 0x01	; 1
   13ce8:	80 ef       	ldi	r24, 0xF0	; 240
   13cea:	99 e0       	ldi	r25, 0x09	; 9
   13cec:	93 83       	std	Z+3, r25	; 0x03
   13cee:	82 83       	std	Z+2, r24	; 0x02
   13cf0:	80 ef       	ldi	r24, 0xF0	; 240
   13cf2:	97 e0       	ldi	r25, 0x07	; 7
   13cf4:	95 83       	std	Z+5, r25	; 0x05
   13cf6:	84 83       	std	Z+4, r24	; 0x04
   13cf8:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   13cfc:	ed b7       	in	r30, 0x3d	; 61
   13cfe:	fe b7       	in	r31, 0x3e	; 62
   13d00:	36 96       	adiw	r30, 0x06	; 6
   13d02:	0f b6       	in	r0, 0x3f	; 63
   13d04:	f8 94       	cli
   13d06:	fe bf       	out	0x3e, r31	; 62
   13d08:	0f be       	out	0x3f, r0	; 63
   13d0a:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
   13d0c:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
   13d10:	00 d0       	rcall	.+0      	; 0x13d12 <PrintIdle+0x79c>
   13d12:	00 d0       	rcall	.+0      	; 0x13d14 <PrintIdle+0x79e>
   13d14:	00 d0       	rcall	.+0      	; 0x13d16 <PrintIdle+0x7a0>
   13d16:	ed b7       	in	r30, 0x3d	; 61
   13d18:	fe b7       	in	r31, 0x3e	; 62
   13d1a:	31 96       	adiw	r30, 0x01	; 1
   13d1c:	8c eb       	ldi	r24, 0xBC	; 188
   13d1e:	98 e0       	ldi	r25, 0x08	; 8
   13d20:	ad b7       	in	r26, 0x3d	; 61
   13d22:	be b7       	in	r27, 0x3e	; 62
   13d24:	12 96       	adiw	r26, 0x02	; 2
   13d26:	9c 93       	st	X, r25
   13d28:	8e 93       	st	-X, r24
   13d2a:	11 97       	sbiw	r26, 0x01	; 1
   13d2c:	8e ed       	ldi	r24, 0xDE	; 222
   13d2e:	99 e0       	ldi	r25, 0x09	; 9
   13d30:	93 83       	std	Z+3, r25	; 0x03
   13d32:	82 83       	std	Z+2, r24	; 0x02
   13d34:	84 e2       	ldi	r24, 0x24	; 36
   13d36:	93 e0       	ldi	r25, 0x03	; 3
   13d38:	f0 c1       	rjmp	.+992    	; 0x1411a <PrintIdle+0xba4>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
   13d3a:	87 30       	cpi	r24, 0x07	; 7
   13d3c:	79 f4       	brne	.+30     	; 0x13d5c <PrintIdle+0x7e6>
			       CarriegeReturn();
   13d3e:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
   13d42:	00 d0       	rcall	.+0      	; 0x13d44 <PrintIdle+0x7ce>
   13d44:	00 d0       	rcall	.+0      	; 0x13d46 <PrintIdle+0x7d0>
   13d46:	8c eb       	ldi	r24, 0xBC	; 188
   13d48:	98 e0       	ldi	r25, 0x08	; 8
   13d4a:	ad b7       	in	r26, 0x3d	; 61
   13d4c:	be b7       	in	r27, 0x3e	; 62
   13d4e:	12 96       	adiw	r26, 0x02	; 2
   13d50:	9c 93       	st	X, r25
   13d52:	8e 93       	st	-X, r24
   13d54:	11 97       	sbiw	r26, 0x01	; 1
   13d56:	8b ed       	ldi	r24, 0xDB	; 219
   13d58:	99 e0       	ldi	r25, 0x09	; 9
   13d5a:	fa c1       	rjmp	.+1012   	; 0x14150 <PrintIdle+0xbda>
   13d5c:	0c eb       	ldi	r16, 0xBC	; 188
   13d5e:	18 e0       	ldi	r17, 0x08	; 8
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
   13d60:	88 30       	cpi	r24, 0x08	; 8
   13d62:	09 f0       	breq	.+2      	; 0x13d66 <PrintIdle+0x7f0>
   13d64:	28 cf       	rjmp	.-432    	; 0x13bb6 <PrintIdle+0x640>
			       CarriegeReturn();
   13d66:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
   13d6a:	00 d0       	rcall	.+0      	; 0x13d6c <PrintIdle+0x7f6>
   13d6c:	00 d0       	rcall	.+0      	; 0x13d6e <PrintIdle+0x7f8>
   13d6e:	ed b7       	in	r30, 0x3d	; 61
   13d70:	fe b7       	in	r31, 0x3e	; 62
   13d72:	12 83       	std	Z+2, r17	; 0x02
   13d74:	01 83       	std	Z+1, r16	; 0x01
   13d76:	89 ec       	ldi	r24, 0xC9	; 201
   13d78:	99 e0       	ldi	r25, 0x09	; 9
   13d7a:	25 c0       	rjmp	.+74     	; 0x13dc6 <PrintIdle+0x850>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
   13d7c:	80 91 ff 01 	lds	r24, 0x01FF
   13d80:	0c eb       	ldi	r16, 0xBC	; 188
   13d82:	18 e0       	ldi	r17, 0x08	; 8
   13d84:	81 30       	cpi	r24, 0x01	; 1
   13d86:	09 f0       	breq	.+2      	; 0x13d8a <PrintIdle+0x814>
   13d88:	16 cf       	rjmp	.-468    	; 0x13bb6 <PrintIdle+0x640>
			       CarriegeReturn();
   13d8a:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
   13d8e:	00 d0       	rcall	.+0      	; 0x13d90 <PrintIdle+0x81a>
   13d90:	00 d0       	rcall	.+0      	; 0x13d92 <PrintIdle+0x81c>
   13d92:	ad b7       	in	r26, 0x3d	; 61
   13d94:	be b7       	in	r27, 0x3e	; 62
   13d96:	12 96       	adiw	r26, 0x02	; 2
   13d98:	1c 93       	st	X, r17
   13d9a:	0e 93       	st	-X, r16
   13d9c:	11 97       	sbiw	r26, 0x01	; 1
   13d9e:	82 eb       	ldi	r24, 0xB2	; 178
   13da0:	99 e0       	ldi	r25, 0x09	; 9
   13da2:	d6 c1       	rjmp	.+940    	; 0x14150 <PrintIdle+0xbda>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
   13da4:	80 91 ff 01 	lds	r24, 0x01FF
   13da8:	0c eb       	ldi	r16, 0xBC	; 188
   13daa:	18 e0       	ldi	r17, 0x08	; 8
   13dac:	81 30       	cpi	r24, 0x01	; 1
   13dae:	09 f0       	breq	.+2      	; 0x13db2 <PrintIdle+0x83c>
   13db0:	02 cf       	rjmp	.-508    	; 0x13bb6 <PrintIdle+0x640>
			       CarriegeReturn();
   13db2:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
   13db6:	00 d0       	rcall	.+0      	; 0x13db8 <PrintIdle+0x842>
   13db8:	00 d0       	rcall	.+0      	; 0x13dba <PrintIdle+0x844>
   13dba:	ed b7       	in	r30, 0x3d	; 61
   13dbc:	fe b7       	in	r31, 0x3e	; 62
   13dbe:	12 83       	std	Z+2, r17	; 0x02
   13dc0:	01 83       	std	Z+1, r16	; 0x01
   13dc2:	8b e9       	ldi	r24, 0x9B	; 155
   13dc4:	99 e0       	ldi	r25, 0x09	; 9
   13dc6:	94 83       	std	Z+4, r25	; 0x04
   13dc8:	83 83       	std	Z+3, r24	; 0x03
   13dca:	c6 c1       	rjmp	.+908    	; 0x14158 <PrintIdle+0xbe2>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
   13dcc:	80 91 ff 01 	lds	r24, 0x01FF
   13dd0:	0c eb       	ldi	r16, 0xBC	; 188
   13dd2:	18 e0       	ldi	r17, 0x08	; 8
   13dd4:	81 30       	cpi	r24, 0x01	; 1
   13dd6:	09 f0       	breq	.+2      	; 0x13dda <PrintIdle+0x864>
   13dd8:	ee ce       	rjmp	.-548    	; 0x13bb6 <PrintIdle+0x640>
			       CarriegeReturn();
   13dda:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
   13dde:	00 d0       	rcall	.+0      	; 0x13de0 <PrintIdle+0x86a>
   13de0:	00 d0       	rcall	.+0      	; 0x13de2 <PrintIdle+0x86c>
   13de2:	ad b7       	in	r26, 0x3d	; 61
   13de4:	be b7       	in	r27, 0x3e	; 62
   13de6:	12 96       	adiw	r26, 0x02	; 2
   13de8:	1c 93       	st	X, r17
   13dea:	0e 93       	st	-X, r16
   13dec:	11 97       	sbiw	r26, 0x01	; 1
   13dee:	88 e7       	ldi	r24, 0x78	; 120
   13df0:	99 e0       	ldi	r25, 0x09	; 9
   13df2:	ae c1       	rjmp	.+860    	; 0x14150 <PrintIdle+0xbda>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
   13df4:	80 91 ff 01 	lds	r24, 0x01FF
   13df8:	81 30       	cpi	r24, 0x01	; 1
   13dfa:	09 f0       	breq	.+2      	; 0x13dfe <PrintIdle+0x888>
   13dfc:	ae c0       	rjmp	.+348    	; 0x13f5a <PrintIdle+0x9e4>
			       IsSignedField=False;
   13dfe:	10 92 ff 01 	sts	0x01FF, r1
   13e02:	ab c0       	rjmp	.+342    	; 0x13f5a <PrintIdle+0x9e4>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
   13e04:	80 91 b8 01 	lds	r24, 0x01B8
   13e08:	0c eb       	ldi	r16, 0xBC	; 188
   13e0a:	18 e0       	ldi	r17, 0x08	; 8
   13e0c:	88 23       	and	r24, r24
   13e0e:	09 f4       	brne	.+2      	; 0x13e12 <PrintIdle+0x89c>
   13e10:	d2 ce       	rjmp	.-604    	; 0x13bb6 <PrintIdle+0x640>
			       CarriegeReturn();
   13e12:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
   13e16:	00 d0       	rcall	.+0      	; 0x13e18 <PrintIdle+0x8a2>
   13e18:	00 d0       	rcall	.+0      	; 0x13e1a <PrintIdle+0x8a4>
   13e1a:	00 d0       	rcall	.+0      	; 0x13e1c <PrintIdle+0x8a6>
   13e1c:	ed b7       	in	r30, 0x3d	; 61
   13e1e:	fe b7       	in	r31, 0x3e	; 62
   13e20:	31 96       	adiw	r30, 0x01	; 1
   13e22:	ad b7       	in	r26, 0x3d	; 61
   13e24:	be b7       	in	r27, 0x3e	; 62
   13e26:	12 96       	adiw	r26, 0x02	; 2
   13e28:	1c 93       	st	X, r17
   13e2a:	0e 93       	st	-X, r16
   13e2c:	11 97       	sbiw	r26, 0x01	; 1
   13e2e:	80 e7       	ldi	r24, 0x70	; 112
   13e30:	99 e0       	ldi	r25, 0x09	; 9
   13e32:	93 83       	std	Z+3, r25	; 0x03
   13e34:	82 83       	std	Z+2, r24	; 0x02
   13e36:	8d e7       	ldi	r24, 0x7D	; 125
   13e38:	95 e0       	ldi	r25, 0x05	; 5
   13e3a:	6f c1       	rjmp	.+734    	; 0x1411a <PrintIdle+0xba4>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
   13e3c:	80 91 b8 01 	lds	r24, 0x01B8
   13e40:	0c eb       	ldi	r16, 0xBC	; 188
   13e42:	18 e0       	ldi	r17, 0x08	; 8
   13e44:	88 23       	and	r24, r24
   13e46:	09 f4       	brne	.+2      	; 0x13e4a <PrintIdle+0x8d4>
   13e48:	b6 ce       	rjmp	.-660    	; 0x13bb6 <PrintIdle+0x640>
			       CarriegeReturn();
   13e4a:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
   13e4e:	00 d0       	rcall	.+0      	; 0x13e50 <PrintIdle+0x8da>
   13e50:	00 d0       	rcall	.+0      	; 0x13e52 <PrintIdle+0x8dc>
   13e52:	ad b7       	in	r26, 0x3d	; 61
   13e54:	be b7       	in	r27, 0x3e	; 62
   13e56:	12 96       	adiw	r26, 0x02	; 2
   13e58:	1c 93       	st	X, r17
   13e5a:	0e 93       	st	-X, r16
   13e5c:	11 97       	sbiw	r26, 0x01	; 1
   13e5e:	8d e4       	ldi	r24, 0x4D	; 77
   13e60:	99 e0       	ldi	r25, 0x09	; 9
   13e62:	76 c1       	rjmp	.+748    	; 0x14150 <PrintIdle+0xbda>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
   13e64:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
   13e68:	00 d0       	rcall	.+0      	; 0x13e6a <PrintIdle+0x8f4>
   13e6a:	00 d0       	rcall	.+0      	; 0x13e6c <PrintIdle+0x8f6>
   13e6c:	8c eb       	ldi	r24, 0xBC	; 188
   13e6e:	98 e0       	ldi	r25, 0x08	; 8
   13e70:	ed b7       	in	r30, 0x3d	; 61
   13e72:	fe b7       	in	r31, 0x3e	; 62
   13e74:	92 83       	std	Z+2, r25	; 0x02
   13e76:	81 83       	std	Z+1, r24	; 0x01
   13e78:	8a e2       	ldi	r24, 0x2A	; 42
   13e7a:	99 e0       	ldi	r25, 0x09	; 9
   13e7c:	a4 cf       	rjmp	.-184    	; 0x13dc6 <PrintIdle+0x850>
		       break; 			            
		  case 22:
		       CarriegeReturn();
   13e7e:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
   13e82:	00 d0       	rcall	.+0      	; 0x13e84 <PrintIdle+0x90e>
   13e84:	00 d0       	rcall	.+0      	; 0x13e86 <PrintIdle+0x910>
   13e86:	00 d0       	rcall	.+0      	; 0x13e88 <PrintIdle+0x912>
   13e88:	ed b7       	in	r30, 0x3d	; 61
   13e8a:	fe b7       	in	r31, 0x3e	; 62
   13e8c:	31 96       	adiw	r30, 0x01	; 1
   13e8e:	8c eb       	ldi	r24, 0xBC	; 188
   13e90:	98 e0       	ldi	r25, 0x08	; 8
   13e92:	ad b7       	in	r26, 0x3d	; 61
   13e94:	be b7       	in	r27, 0x3e	; 62
   13e96:	12 96       	adiw	r26, 0x02	; 2
   13e98:	9c 93       	st	X, r25
   13e9a:	8e 93       	st	-X, r24
   13e9c:	11 97       	sbiw	r26, 0x01	; 1
   13e9e:	83 e1       	ldi	r24, 0x13	; 19
   13ea0:	99 e0       	ldi	r25, 0x09	; 9
   13ea2:	93 83       	std	Z+3, r25	; 0x03
   13ea4:	82 83       	std	Z+2, r24	; 0x02
   13ea6:	87 ee       	ldi	r24, 0xE7	; 231
   13ea8:	92 e0       	ldi	r25, 0x02	; 2
   13eaa:	37 c1       	rjmp	.+622    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 23:
		       CarriegeReturn();
   13eac:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
   13eb0:	00 d0       	rcall	.+0      	; 0x13eb2 <PrintIdle+0x93c>
   13eb2:	00 d0       	rcall	.+0      	; 0x13eb4 <PrintIdle+0x93e>
   13eb4:	00 d0       	rcall	.+0      	; 0x13eb6 <PrintIdle+0x940>
   13eb6:	ed b7       	in	r30, 0x3d	; 61
   13eb8:	fe b7       	in	r31, 0x3e	; 62
   13eba:	31 96       	adiw	r30, 0x01	; 1
   13ebc:	8c eb       	ldi	r24, 0xBC	; 188
   13ebe:	98 e0       	ldi	r25, 0x08	; 8
   13ec0:	ad b7       	in	r26, 0x3d	; 61
   13ec2:	be b7       	in	r27, 0x3e	; 62
   13ec4:	12 96       	adiw	r26, 0x02	; 2
   13ec6:	9c 93       	st	X, r25
   13ec8:	8e 93       	st	-X, r24
   13eca:	11 97       	sbiw	r26, 0x01	; 1
   13ecc:	8b ef       	ldi	r24, 0xFB	; 251
   13ece:	98 e0       	ldi	r25, 0x08	; 8
   13ed0:	93 83       	std	Z+3, r25	; 0x03
   13ed2:	82 83       	std	Z+2, r24	; 0x02
   13ed4:	84 ec       	ldi	r24, 0xC4	; 196
   13ed6:	92 e0       	ldi	r25, 0x02	; 2
   13ed8:	20 c1       	rjmp	.+576    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
   13eda:	0a e0       	ldi	r16, 0x0A	; 10
   13edc:	1c e0       	ldi	r17, 0x0C	; 12
   13ede:	80 91 0a 0c 	lds	r24, 0x0C0A
   13ee2:	88 23       	and	r24, r24
   13ee4:	d1 f1       	breq	.+116    	; 0x13f5a <PrintIdle+0x9e4>
   13ee6:	c8 01       	movw	r24, r16
   13ee8:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   13eec:	88 23       	and	r24, r24
   13eee:	a9 f5       	brne	.+106    	; 0x13f5a <PrintIdle+0x9e4>
		           CarriegeReturn();
   13ef0:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
   13ef4:	00 d0       	rcall	.+0      	; 0x13ef6 <PrintIdle+0x980>
   13ef6:	00 d0       	rcall	.+0      	; 0x13ef8 <PrintIdle+0x982>
   13ef8:	00 d0       	rcall	.+0      	; 0x13efa <PrintIdle+0x984>
   13efa:	ed b7       	in	r30, 0x3d	; 61
   13efc:	fe b7       	in	r31, 0x3e	; 62
   13efe:	31 96       	adiw	r30, 0x01	; 1
   13f00:	8c eb       	ldi	r24, 0xBC	; 188
   13f02:	98 e0       	ldi	r25, 0x08	; 8
   13f04:	ad b7       	in	r26, 0x3d	; 61
   13f06:	be b7       	in	r27, 0x3e	; 62
   13f08:	12 96       	adiw	r26, 0x02	; 2
   13f0a:	9c 93       	st	X, r25
   13f0c:	8e 93       	st	-X, r24
   13f0e:	11 97       	sbiw	r26, 0x01	; 1
   13f10:	84 ee       	ldi	r24, 0xE4	; 228
   13f12:	98 e0       	ldi	r25, 0x08	; 8
   13f14:	1d c0       	rjmp	.+58     	; 0x13f50 <PrintIdle+0x9da>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
   13f16:	0d ec       	ldi	r16, 0xCD	; 205
   13f18:	13 e0       	ldi	r17, 0x03	; 3
   13f1a:	80 91 cd 03 	lds	r24, 0x03CD
   13f1e:	88 23       	and	r24, r24
   13f20:	e1 f0       	breq	.+56     	; 0x13f5a <PrintIdle+0x9e4>
   13f22:	c8 01       	movw	r24, r16
   13f24:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   13f28:	88 23       	and	r24, r24
   13f2a:	b9 f4       	brne	.+46     	; 0x13f5a <PrintIdle+0x9e4>
		           CarriegeReturn();
   13f2c:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
   13f30:	00 d0       	rcall	.+0      	; 0x13f32 <PrintIdle+0x9bc>
   13f32:	00 d0       	rcall	.+0      	; 0x13f34 <PrintIdle+0x9be>
   13f34:	00 d0       	rcall	.+0      	; 0x13f36 <PrintIdle+0x9c0>
   13f36:	ed b7       	in	r30, 0x3d	; 61
   13f38:	fe b7       	in	r31, 0x3e	; 62
   13f3a:	31 96       	adiw	r30, 0x01	; 1
   13f3c:	8c eb       	ldi	r24, 0xBC	; 188
   13f3e:	98 e0       	ldi	r25, 0x08	; 8
   13f40:	ad b7       	in	r26, 0x3d	; 61
   13f42:	be b7       	in	r27, 0x3e	; 62
   13f44:	12 96       	adiw	r26, 0x02	; 2
   13f46:	9c 93       	st	X, r25
   13f48:	8e 93       	st	-X, r24
   13f4a:	11 97       	sbiw	r26, 0x01	; 1
   13f4c:	8d ec       	ldi	r24, 0xCD	; 205
   13f4e:	98 e0       	ldi	r25, 0x08	; 8
   13f50:	93 83       	std	Z+3, r25	; 0x03
   13f52:	82 83       	std	Z+2, r24	; 0x02
   13f54:	15 83       	std	Z+5, r17	; 0x05
   13f56:	04 83       	std	Z+4, r16	; 0x04
   13f58:	e2 c0       	rjmp	.+452    	; 0x1411e <PrintIdle+0xba8>
			   }else ClearMem(strPrint);
   13f5a:	8c eb       	ldi	r24, 0xBC	; 188
   13f5c:	98 e0       	ldi	r25, 0x08	; 8
   13f5e:	2c ce       	rjmp	.-936    	; 0x13bb8 <PrintIdle+0x642>
		       break;
		  case 26:
		       CarriegeReturn();
   13f60:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
   13f64:	00 d0       	rcall	.+0      	; 0x13f66 <PrintIdle+0x9f0>
   13f66:	00 d0       	rcall	.+0      	; 0x13f68 <PrintIdle+0x9f2>
   13f68:	00 d0       	rcall	.+0      	; 0x13f6a <PrintIdle+0x9f4>
   13f6a:	ed b7       	in	r30, 0x3d	; 61
   13f6c:	fe b7       	in	r31, 0x3e	; 62
   13f6e:	31 96       	adiw	r30, 0x01	; 1
   13f70:	8c eb       	ldi	r24, 0xBC	; 188
   13f72:	98 e0       	ldi	r25, 0x08	; 8
   13f74:	ad b7       	in	r26, 0x3d	; 61
   13f76:	be b7       	in	r27, 0x3e	; 62
   13f78:	12 96       	adiw	r26, 0x02	; 2
   13f7a:	9c 93       	st	X, r25
   13f7c:	8e 93       	st	-X, r24
   13f7e:	11 97       	sbiw	r26, 0x01	; 1
   13f80:	86 eb       	ldi	r24, 0xB6	; 182
   13f82:	98 e0       	ldi	r25, 0x08	; 8
   13f84:	93 83       	std	Z+3, r25	; 0x03
   13f86:	82 83       	std	Z+2, r24	; 0x02
   13f88:	8b eb       	ldi	r24, 0xBB	; 187
   13f8a:	92 e0       	ldi	r25, 0x02	; 2
   13f8c:	c6 c0       	rjmp	.+396    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 27:
		       CarriegeReturn();
   13f8e:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
   13f92:	00 d0       	rcall	.+0      	; 0x13f94 <PrintIdle+0xa1e>
   13f94:	00 d0       	rcall	.+0      	; 0x13f96 <PrintIdle+0xa20>
   13f96:	00 d0       	rcall	.+0      	; 0x13f98 <PrintIdle+0xa22>
   13f98:	ed b7       	in	r30, 0x3d	; 61
   13f9a:	fe b7       	in	r31, 0x3e	; 62
   13f9c:	31 96       	adiw	r30, 0x01	; 1
   13f9e:	8c eb       	ldi	r24, 0xBC	; 188
   13fa0:	98 e0       	ldi	r25, 0x08	; 8
   13fa2:	ad b7       	in	r26, 0x3d	; 61
   13fa4:	be b7       	in	r27, 0x3e	; 62
   13fa6:	12 96       	adiw	r26, 0x02	; 2
   13fa8:	9c 93       	st	X, r25
   13faa:	8e 93       	st	-X, r24
   13fac:	11 97       	sbiw	r26, 0x01	; 1
   13fae:	8f e9       	ldi	r24, 0x9F	; 159
   13fb0:	98 e0       	ldi	r25, 0x08	; 8
   13fb2:	93 83       	std	Z+3, r25	; 0x03
   13fb4:	82 83       	std	Z+2, r24	; 0x02
   13fb6:	84 e1       	ldi	r24, 0x14	; 20
   13fb8:	99 e0       	ldi	r25, 0x09	; 9
   13fba:	af c0       	rjmp	.+350    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 28:
		       CarriegeReturn();
   13fbc:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
   13fc0:	00 d0       	rcall	.+0      	; 0x13fc2 <PrintIdle+0xa4c>
   13fc2:	00 d0       	rcall	.+0      	; 0x13fc4 <PrintIdle+0xa4e>
   13fc4:	00 d0       	rcall	.+0      	; 0x13fc6 <PrintIdle+0xa50>
   13fc6:	ed b7       	in	r30, 0x3d	; 61
   13fc8:	fe b7       	in	r31, 0x3e	; 62
   13fca:	31 96       	adiw	r30, 0x01	; 1
   13fcc:	8c eb       	ldi	r24, 0xBC	; 188
   13fce:	98 e0       	ldi	r25, 0x08	; 8
   13fd0:	ad b7       	in	r26, 0x3d	; 61
   13fd2:	be b7       	in	r27, 0x3e	; 62
   13fd4:	12 96       	adiw	r26, 0x02	; 2
   13fd6:	9c 93       	st	X, r25
   13fd8:	8e 93       	st	-X, r24
   13fda:	11 97       	sbiw	r26, 0x01	; 1
   13fdc:	88 e8       	ldi	r24, 0x88	; 136
   13fde:	98 e0       	ldi	r25, 0x08	; 8
   13fe0:	93 83       	std	Z+3, r25	; 0x03
   13fe2:	82 83       	std	Z+2, r24	; 0x02
   13fe4:	85 e3       	ldi	r24, 0x35	; 53
   13fe6:	98 e0       	ldi	r25, 0x08	; 8
   13fe8:	98 c0       	rjmp	.+304    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 29:
		       CarriegeReturn();
   13fea:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
   13fee:	00 d0       	rcall	.+0      	; 0x13ff0 <PrintIdle+0xa7a>
   13ff0:	00 d0       	rcall	.+0      	; 0x13ff2 <PrintIdle+0xa7c>
   13ff2:	00 d0       	rcall	.+0      	; 0x13ff4 <PrintIdle+0xa7e>
   13ff4:	ed b7       	in	r30, 0x3d	; 61
   13ff6:	fe b7       	in	r31, 0x3e	; 62
   13ff8:	31 96       	adiw	r30, 0x01	; 1
   13ffa:	8c eb       	ldi	r24, 0xBC	; 188
   13ffc:	98 e0       	ldi	r25, 0x08	; 8
   13ffe:	ad b7       	in	r26, 0x3d	; 61
   14000:	be b7       	in	r27, 0x3e	; 62
   14002:	12 96       	adiw	r26, 0x02	; 2
   14004:	9c 93       	st	X, r25
   14006:	8e 93       	st	-X, r24
   14008:	11 97       	sbiw	r26, 0x01	; 1
   1400a:	81 e7       	ldi	r24, 0x71	; 113
   1400c:	98 e0       	ldi	r25, 0x08	; 8
   1400e:	93 83       	std	Z+3, r25	; 0x03
   14010:	82 83       	std	Z+2, r24	; 0x02
   14012:	89 e7       	ldi	r24, 0x79	; 121
   14014:	9c e0       	ldi	r25, 0x0C	; 12
   14016:	81 c0       	rjmp	.+258    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 30:
		       CarriegeReturn();
   14018:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
   1401c:	00 d0       	rcall	.+0      	; 0x1401e <PrintIdle+0xaa8>
   1401e:	00 d0       	rcall	.+0      	; 0x14020 <PrintIdle+0xaaa>
   14020:	00 d0       	rcall	.+0      	; 0x14022 <PrintIdle+0xaac>
   14022:	ed b7       	in	r30, 0x3d	; 61
   14024:	fe b7       	in	r31, 0x3e	; 62
   14026:	31 96       	adiw	r30, 0x01	; 1
   14028:	8c eb       	ldi	r24, 0xBC	; 188
   1402a:	98 e0       	ldi	r25, 0x08	; 8
   1402c:	ad b7       	in	r26, 0x3d	; 61
   1402e:	be b7       	in	r27, 0x3e	; 62
   14030:	12 96       	adiw	r26, 0x02	; 2
   14032:	9c 93       	st	X, r25
   14034:	8e 93       	st	-X, r24
   14036:	11 97       	sbiw	r26, 0x01	; 1
   14038:	8a e5       	ldi	r24, 0x5A	; 90
   1403a:	98 e0       	ldi	r25, 0x08	; 8
   1403c:	93 83       	std	Z+3, r25	; 0x03
   1403e:	82 83       	std	Z+2, r24	; 0x02
   14040:	8a e9       	ldi	r24, 0x9A	; 154
   14042:	93 e0       	ldi	r25, 0x03	; 3
   14044:	6a c0       	rjmp	.+212    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 31:
		       CarriegeReturn();
   14046:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
   1404a:	00 d0       	rcall	.+0      	; 0x1404c <PrintIdle+0xad6>
   1404c:	00 d0       	rcall	.+0      	; 0x1404e <PrintIdle+0xad8>
   1404e:	00 d0       	rcall	.+0      	; 0x14050 <PrintIdle+0xada>
   14050:	ed b7       	in	r30, 0x3d	; 61
   14052:	fe b7       	in	r31, 0x3e	; 62
   14054:	31 96       	adiw	r30, 0x01	; 1
   14056:	8c eb       	ldi	r24, 0xBC	; 188
   14058:	98 e0       	ldi	r25, 0x08	; 8
   1405a:	ad b7       	in	r26, 0x3d	; 61
   1405c:	be b7       	in	r27, 0x3e	; 62
   1405e:	12 96       	adiw	r26, 0x02	; 2
   14060:	9c 93       	st	X, r25
   14062:	8e 93       	st	-X, r24
   14064:	11 97       	sbiw	r26, 0x01	; 1
   14066:	81 e4       	ldi	r24, 0x41	; 65
   14068:	98 e0       	ldi	r25, 0x08	; 8
   1406a:	93 83       	std	Z+3, r25	; 0x03
   1406c:	82 83       	std	Z+2, r24	; 0x02
   1406e:	8d ee       	ldi	r24, 0xED	; 237
   14070:	9b e0       	ldi	r25, 0x0B	; 11
   14072:	53 c0       	rjmp	.+166    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 32:
		       CarriegeReturn();
   14074:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
   14078:	00 d0       	rcall	.+0      	; 0x1407a <PrintIdle+0xb04>
   1407a:	00 d0       	rcall	.+0      	; 0x1407c <PrintIdle+0xb06>
   1407c:	00 d0       	rcall	.+0      	; 0x1407e <PrintIdle+0xb08>
   1407e:	ed b7       	in	r30, 0x3d	; 61
   14080:	fe b7       	in	r31, 0x3e	; 62
   14082:	31 96       	adiw	r30, 0x01	; 1
   14084:	8c eb       	ldi	r24, 0xBC	; 188
   14086:	98 e0       	ldi	r25, 0x08	; 8
   14088:	ad b7       	in	r26, 0x3d	; 61
   1408a:	be b7       	in	r27, 0x3e	; 62
   1408c:	12 96       	adiw	r26, 0x02	; 2
   1408e:	9c 93       	st	X, r25
   14090:	8e 93       	st	-X, r24
   14092:	11 97       	sbiw	r26, 0x01	; 1
   14094:	87 e2       	ldi	r24, 0x27	; 39
   14096:	98 e0       	ldi	r25, 0x08	; 8
   14098:	93 83       	std	Z+3, r25	; 0x03
   1409a:	82 83       	std	Z+2, r24	; 0x02
   1409c:	8e e7       	ldi	r24, 0x7E	; 126
   1409e:	93 e0       	ldi	r25, 0x03	; 3
   140a0:	3c c0       	rjmp	.+120    	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
   140a2:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
   140a6:	00 d0       	rcall	.+0      	; 0x140a8 <PrintIdle+0xb32>
   140a8:	00 d0       	rcall	.+0      	; 0x140aa <PrintIdle+0xb34>
   140aa:	8c eb       	ldi	r24, 0xBC	; 188
   140ac:	98 e0       	ldi	r25, 0x08	; 8
   140ae:	ad b7       	in	r26, 0x3d	; 61
   140b0:	be b7       	in	r27, 0x3e	; 62
   140b2:	12 96       	adiw	r26, 0x02	; 2
   140b4:	9c 93       	st	X, r25
   140b6:	8e 93       	st	-X, r24
   140b8:	11 97       	sbiw	r26, 0x01	; 1
   140ba:	84 e0       	ldi	r24, 0x04	; 4
   140bc:	98 e0       	ldi	r25, 0x08	; 8
   140be:	48 c0       	rjmp	.+144    	; 0x14150 <PrintIdle+0xbda>
		       break;
		  case 34:
		       CarriegeReturn();
   140c0:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
   140c4:	00 d0       	rcall	.+0      	; 0x140c6 <PrintIdle+0xb50>
   140c6:	00 d0       	rcall	.+0      	; 0x140c8 <PrintIdle+0xb52>
   140c8:	00 d0       	rcall	.+0      	; 0x140ca <PrintIdle+0xb54>
   140ca:	ed b7       	in	r30, 0x3d	; 61
   140cc:	fe b7       	in	r31, 0x3e	; 62
   140ce:	31 96       	adiw	r30, 0x01	; 1
   140d0:	8c eb       	ldi	r24, 0xBC	; 188
   140d2:	98 e0       	ldi	r25, 0x08	; 8
   140d4:	ad b7       	in	r26, 0x3d	; 61
   140d6:	be b7       	in	r27, 0x3e	; 62
   140d8:	12 96       	adiw	r26, 0x02	; 2
   140da:	9c 93       	st	X, r25
   140dc:	8e 93       	st	-X, r24
   140de:	11 97       	sbiw	r26, 0x01	; 1
   140e0:	8d ee       	ldi	r24, 0xED	; 237
   140e2:	97 e0       	ldi	r25, 0x07	; 7
   140e4:	93 83       	std	Z+3, r25	; 0x03
   140e6:	82 83       	std	Z+2, r24	; 0x02
   140e8:	8b ed       	ldi	r24, 0xDB	; 219
   140ea:	97 e0       	ldi	r25, 0x07	; 7
   140ec:	16 c0       	rjmp	.+44     	; 0x1411a <PrintIdle+0xba4>
		       break;
		  case 35:
		       CarriegeReturn();
   140ee:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
   140f2:	00 d0       	rcall	.+0      	; 0x140f4 <PrintIdle+0xb7e>
   140f4:	00 d0       	rcall	.+0      	; 0x140f6 <PrintIdle+0xb80>
   140f6:	00 d0       	rcall	.+0      	; 0x140f8 <PrintIdle+0xb82>
   140f8:	ed b7       	in	r30, 0x3d	; 61
   140fa:	fe b7       	in	r31, 0x3e	; 62
   140fc:	31 96       	adiw	r30, 0x01	; 1
   140fe:	8c eb       	ldi	r24, 0xBC	; 188
   14100:	98 e0       	ldi	r25, 0x08	; 8
   14102:	ad b7       	in	r26, 0x3d	; 61
   14104:	be b7       	in	r27, 0x3e	; 62
   14106:	12 96       	adiw	r26, 0x02	; 2
   14108:	9c 93       	st	X, r25
   1410a:	8e 93       	st	-X, r24
   1410c:	11 97       	sbiw	r26, 0x01	; 1
   1410e:	86 ed       	ldi	r24, 0xD6	; 214
   14110:	97 e0       	ldi	r25, 0x07	; 7
   14112:	93 83       	std	Z+3, r25	; 0x03
   14114:	82 83       	std	Z+2, r24	; 0x02
   14116:	82 e5       	ldi	r24, 0x52	; 82
   14118:	98 e0       	ldi	r25, 0x08	; 8
   1411a:	95 83       	std	Z+5, r25	; 0x05
   1411c:	84 83       	std	Z+4, r24	; 0x04
   1411e:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   14122:	ed b7       	in	r30, 0x3d	; 61
   14124:	fe b7       	in	r31, 0x3e	; 62
   14126:	36 96       	adiw	r30, 0x06	; 6
   14128:	0f b6       	in	r0, 0x3f	; 63
   1412a:	f8 94       	cli
   1412c:	fe bf       	out	0x3e, r31	; 62
   1412e:	0f be       	out	0x3f, r0	; 63
   14130:	ed bf       	out	0x3d, r30	; 61
   14132:	18 c0       	rjmp	.+48     	; 0x14164 <PrintIdle+0xbee>
		       break;
		  case 36:
		       CarriegeReturn();
   14134:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
   14138:	00 d0       	rcall	.+0      	; 0x1413a <PrintIdle+0xbc4>
   1413a:	00 d0       	rcall	.+0      	; 0x1413c <PrintIdle+0xbc6>
   1413c:	8c eb       	ldi	r24, 0xBC	; 188
   1413e:	98 e0       	ldi	r25, 0x08	; 8
   14140:	ad b7       	in	r26, 0x3d	; 61
   14142:	be b7       	in	r27, 0x3e	; 62
   14144:	12 96       	adiw	r26, 0x02	; 2
   14146:	9c 93       	st	X, r25
   14148:	8e 93       	st	-X, r24
   1414a:	11 97       	sbiw	r26, 0x01	; 1
   1414c:	83 eb       	ldi	r24, 0xB3	; 179
   1414e:	97 e0       	ldi	r25, 0x07	; 7
   14150:	14 96       	adiw	r26, 0x04	; 4
   14152:	9c 93       	st	X, r25
   14154:	8e 93       	st	-X, r24
   14156:	13 97       	sbiw	r26, 0x03	; 3
   14158:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   1415c:	0f 90       	pop	r0
   1415e:	0f 90       	pop	r0
   14160:	0f 90       	pop	r0
   14162:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
   14164:	10 92 fa 01 	sts	0x01FA, r1
   14168:	10 92 f9 01 	sts	0x01F9, r1
   1416c:	10 92 fe 01 	sts	0x01FE, r1
   14170:	10 92 fd 01 	sts	0x01FD, r1
   14174:	ec eb       	ldi	r30, 0xBC	; 188
   14176:	f8 e0       	ldi	r31, 0x08	; 8
   14178:	01 90       	ld	r0, Z+
   1417a:	00 20       	and	r0, r0
   1417c:	e9 f7       	brne	.-6      	; 0x14178 <PrintIdle+0xc02>
   1417e:	31 97       	sbiw	r30, 0x01	; 1
   14180:	ec 5b       	subi	r30, 0xBC	; 188
   14182:	f8 40       	sbci	r31, 0x08	; 8
   14184:	f0 93 fc 01 	sts	0x01FC, r31
   14188:	e0 93 fb 01 	sts	0x01FB, r30
          stPrintIdle=piPrintMessage;
   1418c:	8a e0       	ldi	r24, 0x0A	; 10
   1418e:	7e c1       	rjmp	.+764    	; 0x1448c <PrintIdle+0xf16>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
   14190:	20 91 fd 01 	lds	r18, 0x01FD
   14194:	30 91 fe 01 	lds	r19, 0x01FE
   14198:	80 91 fb 01 	lds	r24, 0x01FB
   1419c:	90 91 fc 01 	lds	r25, 0x01FC
   141a0:	28 17       	cp	r18, r24
   141a2:	39 07       	cpc	r19, r25
   141a4:	68 f4       	brcc	.+26     	; 0x141c0 <PrintIdle+0xc4a>
		      iLoop++;
   141a6:	80 91 f9 01 	lds	r24, 0x01F9
   141aa:	90 91 fa 01 	lds	r25, 0x01FA
   141ae:	01 96       	adiw	r24, 0x01	; 1
   141b0:	90 93 fa 01 	sts	0x01FA, r25
   141b4:	80 93 f9 01 	sts	0x01F9, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
   141b8:	10 92 b6 01 	sts	0x01B6, r1
				 stPrintIdle=piCheckPrintStatusMessage;
   141bc:	8c e0       	ldi	r24, 0x0C	; 12
   141be:	66 c1       	rjmp	.+716    	; 0x1448c <PrintIdle+0xf16>
				 }
			  }
          else{iMessage++;
   141c0:	80 91 01 02 	lds	r24, 0x0201
   141c4:	8f 5f       	subi	r24, 0xFF	; 255
   141c6:	80 93 01 02 	sts	0x0201, r24
		      if (iMessage>MessageLine){
   141ca:	90 91 00 02 	lds	r25, 0x0200
   141ce:	98 17       	cp	r25, r24
   141d0:	30 f4       	brcc	.+12     	; 0x141de <PrintIdle+0xc68>
			      iFooter=0;				  
   141d2:	10 92 04 02 	sts	0x0204, r1
				  CarriegeReturn();
   141d6:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
				  stPrintIdle=piLoadOperatorName;//piLoadFooter;
   141da:	85 e1       	ldi	r24, 0x15	; 21
   141dc:	57 c1       	rjmp	.+686    	; 0x1448c <PrintIdle+0xf16>
			  }
			  else stPrintIdle=piLoadMessage;
   141de:	89 e0       	ldi	r24, 0x09	; 9
   141e0:	55 c1       	rjmp	.+682    	; 0x1448c <PrintIdle+0xf16>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
   141e2:	80 91 b3 01 	lds	r24, 0x01B3
   141e6:	88 23       	and	r24, r24
   141e8:	09 f0       	breq	.+2      	; 0x141ec <PrintIdle+0xc76>
   141ea:	48 c1       	rjmp	.+656    	; 0x1447c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   141ec:	e0 91 fd 01 	lds	r30, 0x01FD
   141f0:	f0 91 fe 01 	lds	r31, 0x01FE
   141f4:	e4 54       	subi	r30, 0x44	; 68
   141f6:	f7 4f       	sbci	r31, 0xF7	; 247
   141f8:	61 e0       	ldi	r22, 0x01	; 1
   141fa:	40 81       	ld	r20, Z
   141fc:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   14200:	80 91 fd 01 	lds	r24, 0x01FD
   14204:	90 91 fe 01 	lds	r25, 0x01FE
   14208:	01 96       	adiw	r24, 0x01	; 1
   1420a:	90 93 fe 01 	sts	0x01FE, r25
   1420e:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintMessage;
   14212:	8a e0       	ldi	r24, 0x0A	; 10
   14214:	31 c1       	rjmp	.+610    	; 0x14478 <PrintIdle+0xf02>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   14216:	8e 01       	movw	r16, r28
   14218:	0f 5f       	subi	r16, 0xFF	; 255
   1421a:	1f 4f       	sbci	r17, 0xFF	; 255
   1421c:	c8 01       	movw	r24, r16
   1421e:	65 e1       	ldi	r22, 0x15	; 21
   14220:	70 e0       	ldi	r23, 0x00	; 0
   14222:	42 e1       	ldi	r20, 0x12	; 18
   14224:	50 e0       	ldi	r21, 0x00	; 0
   14226:	22 ed       	ldi	r18, 0xD2	; 210
   14228:	33 e1       	ldi	r19, 0x13	; 19
   1422a:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1422e:	ce 01       	movw	r24, r28
   14230:	40 96       	adiw	r24, 0x10	; 16
	    Dest[i]=Source[IdxSource+i];
   14232:	0f 5f       	subi	r16, 0xFF	; 255
   14234:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14236:	08 17       	cp	r16, r24
   14238:	19 07       	cpc	r17, r25
   1423a:	d9 f7       	brne	.-10     	; 0x14232 <PrintIdle+0xcbc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1423c:	18 8a       	std	Y+16, r1	; 0x10
	//Added Operator Name:
	 case piLoadOperatorName:
	      //CheckEmpty
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);
		  if (strlen(strOperatorName)>0){
   1423e:	89 81       	ldd	r24, Y+1	; 0x01
   14240:	88 23       	and	r24, r24
   14242:	09 f4       	brne	.+2      	; 0x14246 <PrintIdle+0xcd0>
   14244:	95 c0       	rjmp	.+298    	; 0x14370 <PrintIdle+0xdfa>
			  if (SpaceOnly(strOperatorName)!=True){		      				  
   14246:	7e 01       	movw	r14, r28
   14248:	08 94       	sec
   1424a:	e1 1c       	adc	r14, r1
   1424c:	f1 1c       	adc	r15, r1
   1424e:	c7 01       	movw	r24, r14
   14250:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   14254:	81 30       	cpi	r24, 0x01	; 1
   14256:	09 f4       	brne	.+2      	; 0x1425a <PrintIdle+0xce4>
   14258:	8b c0       	rjmp	.+278    	; 0x14370 <PrintIdle+0xdfa>
				  sprintf_P(strPrint,PSTR("     Operator: %s"),strOperatorName);			   
   1425a:	00 d0       	rcall	.+0      	; 0x1425c <PrintIdle+0xce6>
   1425c:	00 d0       	rcall	.+0      	; 0x1425e <PrintIdle+0xce8>
   1425e:	00 d0       	rcall	.+0      	; 0x14260 <PrintIdle+0xcea>
   14260:	ed b7       	in	r30, 0x3d	; 61
   14262:	fe b7       	in	r31, 0x3e	; 62
   14264:	31 96       	adiw	r30, 0x01	; 1
   14266:	0c eb       	ldi	r16, 0xBC	; 188
   14268:	18 e0       	ldi	r17, 0x08	; 8
   1426a:	ad b7       	in	r26, 0x3d	; 61
   1426c:	be b7       	in	r27, 0x3e	; 62
   1426e:	12 96       	adiw	r26, 0x02	; 2
   14270:	1c 93       	st	X, r17
   14272:	0e 93       	st	-X, r16
   14274:	11 97       	sbiw	r26, 0x01	; 1
   14276:	81 ea       	ldi	r24, 0xA1	; 161
   14278:	97 e0       	ldi	r25, 0x07	; 7
   1427a:	93 83       	std	Z+3, r25	; 0x03
   1427c:	82 83       	std	Z+2, r24	; 0x02
   1427e:	f5 82       	std	Z+5, r15	; 0x05
   14280:	e4 82       	std	Z+4, r14	; 0x04
   14282:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			      iSend=0;iLoop=0;
   14286:	10 92 fe 01 	sts	0x01FE, r1
   1428a:	10 92 fd 01 	sts	0x01FD, r1
   1428e:	10 92 fa 01 	sts	0x01FA, r1
   14292:	10 92 f9 01 	sts	0x01F9, r1
				  LSend=strlen(strPrint);
   14296:	f8 01       	movw	r30, r16
   14298:	01 90       	ld	r0, Z+
   1429a:	00 20       	and	r0, r0
   1429c:	e9 f7       	brne	.-6      	; 0x14298 <PrintIdle+0xd22>
   1429e:	8f 01       	movw	r16, r30
   142a0:	01 50       	subi	r16, 0x01	; 1
   142a2:	10 40       	sbci	r17, 0x00	; 0
   142a4:	0c 5b       	subi	r16, 0xBC	; 188
   142a6:	18 40       	sbci	r17, 0x08	; 8
   142a8:	10 93 fc 01 	sts	0x01FC, r17
   142ac:	00 93 fb 01 	sts	0x01FB, r16
				  stPrintIdle=piPrintOperatorName;
   142b0:	86 e1       	ldi	r24, 0x16	; 22
   142b2:	80 93 06 02 	sts	0x0206, r24
   142b6:	8d b7       	in	r24, 0x3d	; 61
   142b8:	9e b7       	in	r25, 0x3e	; 62
   142ba:	06 96       	adiw	r24, 0x06	; 6
   142bc:	0f b6       	in	r0, 0x3f	; 63
   142be:	f8 94       	cli
   142c0:	9e bf       	out	0x3e, r25	; 62
   142c2:	0f be       	out	0x3f, r0	; 63
   142c4:	8d bf       	out	0x3d, r24	; 61
   142c6:	0d c1       	rjmp	.+538    	; 0x144e2 <PrintIdle+0xf6c>
			  }else stPrintIdle=piLoadFooter;
          }  
          else stPrintIdle=piLoadFooter;
	      break;
	 case piPrintOperatorName:
		  if (iSend<LSend){
   142c8:	20 91 fd 01 	lds	r18, 0x01FD
   142cc:	30 91 fe 01 	lds	r19, 0x01FE
   142d0:	80 91 fb 01 	lds	r24, 0x01FB
   142d4:	90 91 fc 01 	lds	r25, 0x01FC
   142d8:	28 17       	cp	r18, r24
   142da:	39 07       	cpc	r19, r25
   142dc:	68 f4       	brcc	.+26     	; 0x142f8 <PrintIdle+0xd82>
		      iLoop++;
   142de:	80 91 f9 01 	lds	r24, 0x01F9
   142e2:	90 91 fa 01 	lds	r25, 0x01FA
   142e6:	01 96       	adiw	r24, 0x01	; 1
   142e8:	90 93 fa 01 	sts	0x01FA, r25
   142ec:	80 93 f9 01 	sts	0x01F9, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
   142f0:	10 92 b6 01 	sts	0x01B6, r1
				  stPrintIdle=piCheckPrintOperatorName;
   142f4:	87 e1       	ldi	r24, 0x17	; 23
   142f6:	ca c0       	rjmp	.+404    	; 0x1448c <PrintIdle+0xf16>
				}
			  }
          else {
			  CarriegeReturn();
   142f8:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
			  CarriegeReturn();
   142fc:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   14300:	37 c0       	rjmp	.+110    	; 0x14370 <PrintIdle+0xdfa>
			  stPrintIdle=piLoadFooter;
			  }
	      break;
	 case piCheckPrintOperatorName:
	      if (IsBusyPrint==False){
   14302:	80 91 b3 01 	lds	r24, 0x01B3
   14306:	88 23       	and	r24, r24
   14308:	09 f0       	breq	.+2      	; 0x1430c <PrintIdle+0xd96>
   1430a:	b8 c0       	rjmp	.+368    	; 0x1447c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   1430c:	e0 91 fd 01 	lds	r30, 0x01FD
   14310:	f0 91 fe 01 	lds	r31, 0x01FE
   14314:	e4 54       	subi	r30, 0x44	; 68
   14316:	f7 4f       	sbci	r31, 0xF7	; 247
   14318:	61 e0       	ldi	r22, 0x01	; 1
   1431a:	40 81       	ld	r20, Z
   1431c:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   14320:	80 91 fd 01 	lds	r24, 0x01FD
   14324:	90 91 fe 01 	lds	r25, 0x01FE
   14328:	01 96       	adiw	r24, 0x01	; 1
   1432a:	90 93 fe 01 	sts	0x01FE, r25
   1432e:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintOperatorName;
   14332:	86 e1       	ldi	r24, 0x16	; 22
   14334:	a1 c0       	rjmp	.+322    	; 0x14478 <PrintIdle+0xf02>
   14336:	60 91 04 02 	lds	r22, 0x0204
   1433a:	89 e2       	ldi	r24, 0x29	; 41
   1433c:	68 9f       	mul	r22, r24
   1433e:	b0 01       	movw	r22, r0
   14340:	11 24       	eor	r1, r1
   14342:	63 5e       	subi	r22, 0xE3	; 227
   14344:	7c 4f       	sbci	r23, 0xFC	; 252
   14346:	8c eb       	ldi	r24, 0xBC	; 188
   14348:	98 e0       	ldi	r25, 0x08	; 8
   1434a:	48 e2       	ldi	r20, 0x28	; 40
   1434c:	50 e0       	ldi	r21, 0x00	; 0
   1434e:	22 ed       	ldi	r18, 0xD2	; 210
   14350:	33 e1       	ldi	r19, 0x13	; 19
   14352:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>

	 	       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
   14356:	80 91 04 02 	lds	r24, 0x0204
   1435a:	8f 5f       	subi	r24, 0xFF	; 255
   1435c:	80 93 04 02 	sts	0x0204, r24
		  if (iFooter<=4){
   14360:	85 30       	cpi	r24, 0x05	; 5
   14362:	90 f4       	brcc	.+36     	; 0x14388 <PrintIdle+0xe12>
		      if (SpaceOnly(strPrint)==True){
   14364:	8c eb       	ldi	r24, 0xBC	; 188
   14366:	98 e0       	ldi	r25, 0x08	; 8
   14368:	0e 94 33 27 	call	0x4e66	; 0x4e66 <SpaceOnly>
   1436c:	81 30       	cpi	r24, 0x01	; 1
   1436e:	11 f4       	brne	.+4      	; 0x14374 <PrintIdle+0xdfe>
			      stPrintIdle=piLoadFooter;
   14370:	8e e0       	ldi	r24, 0x0E	; 14
   14372:	8c c0       	rjmp	.+280    	; 0x1448c <PrintIdle+0xf16>
				  }
			  else{
			      iSend=0;
   14374:	10 92 fe 01 	sts	0x01FE, r1
   14378:	10 92 fd 01 	sts	0x01FD, r1
				  iLoop=0;
   1437c:	10 92 fa 01 	sts	0x01FA, r1
   14380:	10 92 f9 01 	sts	0x01F9, r1
				  stPrintIdle=piPrintFooter;
   14384:	8f e0       	ldi	r24, 0x0F	; 15
   14386:	82 c0       	rjmp	.+260    	; 0x1448c <PrintIdle+0xf16>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
   14388:	81 e1       	ldi	r24, 0x11	; 17
   1438a:	80 c0       	rjmp	.+256    	; 0x1448c <PrintIdle+0xf16>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
   1438c:	80 91 fd 01 	lds	r24, 0x01FD
   14390:	90 91 fe 01 	lds	r25, 0x01FE
   14394:	88 97       	sbiw	r24, 0x28	; 40
   14396:	68 f4       	brcc	.+26     	; 0x143b2 <PrintIdle+0xe3c>
		      iLoop++;
   14398:	80 91 f9 01 	lds	r24, 0x01F9
   1439c:	90 91 fa 01 	lds	r25, 0x01FA
   143a0:	01 96       	adiw	r24, 0x01	; 1
   143a2:	90 93 fa 01 	sts	0x01FA, r25
   143a6:	80 93 f9 01 	sts	0x01F9, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
   143aa:	10 92 b6 01 	sts	0x01B6, r1
				stPrintIdle=piCheckPrintStatusFooter;
   143ae:	8d e0       	ldi	r24, 0x0D	; 13
   143b0:	6d c0       	rjmp	.+218    	; 0x1448c <PrintIdle+0xf16>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
   143b2:	8e e0       	ldi	r24, 0x0E	; 14
   143b4:	80 93 06 02 	sts	0x0206, r24
			  CarriegeReturn();
   143b8:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
   143bc:	92 c0       	rjmp	.+292    	; 0x144e2 <PrintIdle+0xf6c>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
   143be:	80 91 b3 01 	lds	r24, 0x01B3
   143c2:	88 23       	and	r24, r24
   143c4:	09 f0       	breq	.+2      	; 0x143c8 <PrintIdle+0xe52>
   143c6:	5a c0       	rjmp	.+180    	; 0x1447c <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   143c8:	e0 91 fd 01 	lds	r30, 0x01FD
   143cc:	f0 91 fe 01 	lds	r31, 0x01FE
   143d0:	e4 54       	subi	r30, 0x44	; 68
   143d2:	f7 4f       	sbci	r31, 0xF7	; 247
   143d4:	61 e0       	ldi	r22, 0x01	; 1
   143d6:	40 81       	ld	r20, Z
   143d8:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		      iSend++;
   143dc:	80 91 fd 01 	lds	r24, 0x01FD
   143e0:	90 91 fe 01 	lds	r25, 0x01FE
   143e4:	01 96       	adiw	r24, 0x01	; 1
   143e6:	90 93 fe 01 	sts	0x01FE, r25
   143ea:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintFooter;
   143ee:	8f e0       	ldi	r24, 0x0F	; 15
   143f0:	43 c0       	rjmp	.+134    	; 0x14478 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
   143f2:	90 91 f8 01 	lds	r25, 0x01F8
   143f6:	9f 5f       	subi	r25, 0xFF	; 255
   143f8:	90 93 f8 01 	sts	0x01F8, r25
		  iScroll=0;
   143fc:	10 92 03 02 	sts	0x0203, r1
		  iLoop=0;
   14400:	10 92 fa 01 	sts	0x01FA, r1
   14404:	10 92 f9 01 	sts	0x01F9, r1
		  if (iPrinted<PrintCopy){
   14408:	80 91 f7 01 	lds	r24, 0x01F7
   1440c:	98 17       	cp	r25, r24
   1440e:	28 f4       	brcc	.+10     	; 0x1441a <PrintIdle+0xea4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14410:	e1 99       	sbic	0x1c, 1	; 28
   14412:	fe cf       	rjmp	.-4      	; 0x14410 <PrintIdle+0xe9a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14414:	82 e3       	ldi	r24, 0x32	; 50
   14416:	90 e0       	ldi	r25, 0x00	; 0
   14418:	04 c0       	rjmp	.+8      	; 0x14422 <PrintIdle+0xeac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1441a:	e1 99       	sbic	0x1c, 1	; 28
   1441c:	fe cf       	rjmp	.-4      	; 0x1441a <PrintIdle+0xea4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1441e:	81 e3       	ldi	r24, 0x31	; 49
   14420:	90 e0       	ldi	r25, 0x00	; 0
   14422:	9f bb       	out	0x1f, r25	; 31
   14424:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14426:	e0 9a       	sbi	0x1c, 0	; 28
   14428:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
   1442a:	80 93 02 02 	sts	0x0202, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
   1442e:	80 e1       	ldi	r24, 0x10	; 16
   14430:	2d c0       	rjmp	.+90     	; 0x1448c <PrintIdle+0xf16>
	      break;
     case piScrollPaper:
	      iLoop++;
   14432:	80 91 f9 01 	lds	r24, 0x01F9
   14436:	90 91 fa 01 	lds	r25, 0x01FA
   1443a:	01 96       	adiw	r24, 0x01	; 1
   1443c:	90 93 fa 01 	sts	0x01FA, r25
   14440:	80 93 f9 01 	sts	0x01F9, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
   14444:	10 92 b6 01 	sts	0x01B6, r1
			  stPrintIdle=piCheckPrintStatusScroll;
   14448:	82 e1       	ldi	r24, 0x12	; 18
   1444a:	80 93 06 02 	sts	0x0206, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
   1444e:	90 91 03 02 	lds	r25, 0x0203
   14452:	80 91 02 02 	lds	r24, 0x0202
   14456:	89 17       	cp	r24, r25
   14458:	08 f0       	brcs	.+2      	; 0x1445c <PrintIdle+0xee6>
   1445a:	43 c0       	rjmp	.+134    	; 0x144e2 <PrintIdle+0xf6c>
   1445c:	83 e1       	ldi	r24, 0x13	; 19
   1445e:	16 c0       	rjmp	.+44     	; 0x1448c <PrintIdle+0xf16>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
   14460:	80 91 b3 01 	lds	r24, 0x01B3
   14464:	88 23       	and	r24, r24
   14466:	51 f4       	brne	.+20     	; 0x1447c <PrintIdle+0xf06>
		      iScroll++;
   14468:	80 91 03 02 	lds	r24, 0x0203
   1446c:	8f 5f       	subi	r24, 0xFF	; 255
   1446e:	80 93 03 02 	sts	0x0203, r24
		      CarriegeReturn();
   14472:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
   14476:	80 e1       	ldi	r24, 0x10	; 16
   14478:	80 93 06 02 	sts	0x0206, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
   1447c:	80 91 b6 01 	lds	r24, 0x01B6
   14480:	8b 30       	cpi	r24, 0x0B	; 11
   14482:	78 f1       	brcs	.+94     	; 0x144e2 <PrintIdle+0xf6c>
		      IsPrintERROR=True;
   14484:	81 e0       	ldi	r24, 0x01	; 1
   14486:	80 93 b1 01 	sts	0x01B1, r24
		      stPrintIdle=piFinishPrintIdle;
   1448a:	84 e1       	ldi	r24, 0x14	; 20
   1448c:	80 93 06 02 	sts	0x0206, r24
   14490:	28 c0       	rjmp	.+80     	; 0x144e2 <PrintIdle+0xf6c>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
   14492:	90 91 f8 01 	lds	r25, 0x01F8
   14496:	80 91 f7 01 	lds	r24, 0x01F7
   1449a:	98 17       	cp	r25, r24
   1449c:	10 f0       	brcs	.+4      	; 0x144a2 <PrintIdle+0xf2c>
		      stPrintIdle=piFinishPrintIdle;
   1449e:	84 e1       	ldi	r24, 0x14	; 20
   144a0:	05 c0       	rjmp	.+10     	; 0x144ac <PrintIdle+0xf36>
			  }
		  else {CarriegeReturn();
   144a2:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		        CarriegeReturn();
   144a6:	0e 94 a2 47 	call	0x8f44	; 0x8f44 <CarriegeReturn>
		        stPrintIdle=piInit;
   144aa:	81 e0       	ldi	r24, 0x01	; 1
   144ac:	80 93 06 02 	sts	0x0206, r24
		       }
		  PaperCut();
   144b0:	0e 94 49 48 	call	0x9092	; 0x9092 <PaperCut>
   144b4:	16 c0       	rjmp	.+44     	; 0x144e2 <PrintIdle+0xf6c>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
   144b6:	80 91 00 01 	lds	r24, 0x0100
   144ba:	81 30       	cpi	r24, 0x01	; 1
   144bc:	19 f0       	breq	.+6      	; 0x144c4 <PrintIdle+0xf4e>
   144be:	82 30       	cpi	r24, 0x02	; 2
   144c0:	61 f4       	brne	.+24     	; 0x144da <PrintIdle+0xf64>
   144c2:	03 c0       	rjmp	.+6      	; 0x144ca <PrintIdle+0xf54>
		  case IT_SLAVE:
		       sendMessage04();
   144c4:	0e 94 ee 96 	call	0x12ddc	; 0x12ddc <sendMessage04>
   144c8:	08 c0       	rjmp	.+16     	; 0x144da <PrintIdle+0xf64>
		       break;
		  case IT_STANDALONE:		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
   144ca:	89 eb       	ldi	r24, 0xB9	; 185
   144cc:	97 e0       	ldi	r25, 0x07	; 7
   144ce:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
   144d2:	8f 70       	andi	r24, 0x0F	; 15
   144d4:	61 e1       	ldi	r22, 0x11	; 17
   144d6:	0e 94 87 21 	call	0x430e	; 0x430e <UpdateStandaloneStatus>
			   //CurrentPumpStatus[FIPAddr]=PUMP_OFF;
			   //strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);			   
			   //IsNewPumpStatus=True;//UpdateDisplay
		       break;
		  }
		  IsBusyIdlePrinting=False;
   144da:	10 92 b2 01 	sts	0x01B2, r1
          stPrintIdle=piIdle;
   144de:	10 92 06 02 	sts	0x0206, r1
	      break;	 
	 }
}
   144e2:	64 96       	adiw	r28, 0x14	; 20
   144e4:	0f b6       	in	r0, 0x3f	; 63
   144e6:	f8 94       	cli
   144e8:	de bf       	out	0x3e, r29	; 62
   144ea:	0f be       	out	0x3f, r0	; 63
   144ec:	cd bf       	out	0x3d, r28	; 61
   144ee:	cf 91       	pop	r28
   144f0:	df 91       	pop	r29
   144f2:	1f 91       	pop	r17
   144f4:	0f 91       	pop	r16
   144f6:	ff 90       	pop	r15
   144f8:	ef 90       	pop	r14
   144fa:	08 95       	ret

000144fc <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
   144fc:	0e 94 f2 96 	call	0x12de4	; 0x12de4 <FreePrinting>
	 PrintIdle();
   14500:	0e 94 bb 9a 	call	0x13576	; 0x13576 <PrintIdle>
}
   14504:	08 95       	ret

00014506 <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
   14506:	8f 92       	push	r8
   14508:	9f 92       	push	r9
   1450a:	af 92       	push	r10
   1450c:	bf 92       	push	r11
   1450e:	cf 92       	push	r12
   14510:	df 92       	push	r13
   14512:	ef 92       	push	r14
   14514:	ff 92       	push	r15
   14516:	0f 93       	push	r16
   14518:	1f 93       	push	r17
   1451a:	df 93       	push	r29
   1451c:	cf 93       	push	r28
   1451e:	cd b7       	in	r28, 0x3d	; 61
   14520:	de b7       	in	r29, 0x3e	; 62
   14522:	c5 56       	subi	r28, 0x65	; 101
   14524:	d0 40       	sbci	r29, 0x00	; 0
   14526:	0f b6       	in	r0, 0x3f	; 63
   14528:	f8 94       	cli
   1452a:	de bf       	out	0x3e, r29	; 62
   1452c:	0f be       	out	0x3f, r0	; 63
   1452e:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 uart_printf(1,0,PSTR("<"));
   14530:	81 e0       	ldi	r24, 0x01	; 1
   14532:	60 e0       	ldi	r22, 0x00	; 0
   14534:	46 ee       	ldi	r20, 0xE6	; 230
   14536:	53 e2       	ldi	r21, 0x23	; 35
   14538:	0e 94 2c ae 	call	0x15c58	; 0x15c58 <uart_printf>
   1453c:	07 e2       	ldi	r16, 0x27	; 39
   1453e:	12 e0       	ldi	r17, 0x02	; 2
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   14540:	6e 01       	movw	r12, r28
   14542:	08 94       	sec
   14544:	c1 1c       	adc	r12, r1
   14546:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14548:	8a e2       	ldi	r24, 0x2A	; 42
   1454a:	e8 2e       	mov	r14, r24
   1454c:	f1 2c       	mov	r15, r1
   1454e:	ec 0e       	add	r14, r28
   14550:	fd 1e       	adc	r15, r29
   14552:	b3 ee       	ldi	r27, 0xE3	; 227
   14554:	ab 2e       	mov	r10, r27
   14556:	b3 e2       	ldi	r27, 0x23	; 35
   14558:	bb 2e       	mov	r11, r27
   1455a:	c6 01       	movw	r24, r12
   1455c:	b8 01       	movw	r22, r16
   1455e:	49 e2       	ldi	r20, 0x29	; 41
   14560:	50 e0       	ldi	r21, 0x00	; 0
   14562:	22 ed       	ldi	r18, 0xD2	; 210
   14564:	33 e1       	ldi	r19, 0x13	; 19
   14566:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
   1456a:	00 d0       	rcall	.+0      	; 0x1456c <SendConfigParamater+0x66>
   1456c:	00 d0       	rcall	.+0      	; 0x1456e <SendConfigParamater+0x68>
   1456e:	00 d0       	rcall	.+0      	; 0x14570 <SendConfigParamater+0x6a>
   14570:	ed b7       	in	r30, 0x3d	; 61
   14572:	fe b7       	in	r31, 0x3e	; 62
   14574:	31 96       	adiw	r30, 0x01	; 1
   14576:	ad b7       	in	r26, 0x3d	; 61
   14578:	be b7       	in	r27, 0x3e	; 62
   1457a:	12 96       	adiw	r26, 0x02	; 2
   1457c:	fc 92       	st	X, r15
   1457e:	ee 92       	st	-X, r14
   14580:	11 97       	sbiw	r26, 0x01	; 1
   14582:	b3 82       	std	Z+3, r11	; 0x03
   14584:	a2 82       	std	Z+2, r10	; 0x02
   14586:	d5 82       	std	Z+5, r13	; 0x05
   14588:	c4 82       	std	Z+4, r12	; 0x04
   1458a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  AddSpaceLag(strSend,40);
   1458e:	ed b7       	in	r30, 0x3d	; 61
   14590:	fe b7       	in	r31, 0x3e	; 62
   14592:	36 96       	adiw	r30, 0x06	; 6
   14594:	0f b6       	in	r0, 0x3f	; 63
   14596:	f8 94       	cli
   14598:	fe bf       	out	0x3e, r31	; 62
   1459a:	0f be       	out	0x3f, r0	; 63
   1459c:	ed bf       	out	0x3d, r30	; 61
   1459e:	c7 01       	movw	r24, r14
   145a0:	68 e2       	ldi	r22, 0x28	; 40
   145a2:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
		  uart_print(1,0,strSend);
   145a6:	81 e0       	ldi	r24, 0x01	; 1
   145a8:	60 e0       	ldi	r22, 0x00	; 0
   145aa:	a7 01       	movw	r20, r14
   145ac:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
   145b0:	07 5d       	subi	r16, 0xD7	; 215
   145b2:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   145b4:	f3 e0       	ldi	r31, 0x03	; 3
   145b6:	01 3c       	cpi	r16, 0xC1	; 193
   145b8:	1f 07       	cpc	r17, r31
   145ba:	79 f6       	brne	.-98     	; 0x1455a <SendConfigParamater+0x54>
   145bc:	0b eb       	ldi	r16, 0xBB	; 187
   145be:	10 e0       	ldi	r17, 0x00	; 0
   145c0:	6e 01       	movw	r12, r28
   145c2:	08 94       	sec
   145c4:	c1 1c       	adc	r12, r1
   145c6:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   145c8:	aa e2       	ldi	r26, 0x2A	; 42
   145ca:	ea 2e       	mov	r14, r26
   145cc:	f1 2c       	mov	r15, r1
   145ce:	ec 0e       	add	r14, r28
   145d0:	fd 1e       	adc	r15, r29
   145d2:	f0 ee       	ldi	r31, 0xE0	; 224
   145d4:	af 2e       	mov	r10, r31
   145d6:	f3 e2       	ldi	r31, 0x23	; 35
   145d8:	bf 2e       	mov	r11, r31
   145da:	c6 01       	movw	r24, r12
   145dc:	b8 01       	movw	r22, r16
   145de:	4d e0       	ldi	r20, 0x0D	; 13
   145e0:	50 e0       	ldi	r21, 0x00	; 0
   145e2:	22 ed       	ldi	r18, 0xD2	; 210
   145e4:	33 e1       	ldi	r19, 0x13	; 19
   145e6:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
   145ea:	00 d0       	rcall	.+0      	; 0x145ec <SendConfigParamater+0xe6>
   145ec:	00 d0       	rcall	.+0      	; 0x145ee <SendConfigParamater+0xe8>
   145ee:	00 d0       	rcall	.+0      	; 0x145f0 <SendConfigParamater+0xea>
   145f0:	ed b7       	in	r30, 0x3d	; 61
   145f2:	fe b7       	in	r31, 0x3e	; 62
   145f4:	31 96       	adiw	r30, 0x01	; 1
   145f6:	ad b7       	in	r26, 0x3d	; 61
   145f8:	be b7       	in	r27, 0x3e	; 62
   145fa:	12 96       	adiw	r26, 0x02	; 2
   145fc:	fc 92       	st	X, r15
   145fe:	ee 92       	st	-X, r14
   14600:	11 97       	sbiw	r26, 0x01	; 1
   14602:	b3 82       	std	Z+3, r11	; 0x03
   14604:	a2 82       	std	Z+2, r10	; 0x02
   14606:	d5 82       	std	Z+5, r13	; 0x05
   14608:	c4 82       	std	Z+4, r12	; 0x04
   1460a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 AddSpaceLag(strSend,12);
   1460e:	ed b7       	in	r30, 0x3d	; 61
   14610:	fe b7       	in	r31, 0x3e	; 62
   14612:	36 96       	adiw	r30, 0x06	; 6
   14614:	0f b6       	in	r0, 0x3f	; 63
   14616:	f8 94       	cli
   14618:	fe bf       	out	0x3e, r31	; 62
   1461a:	0f be       	out	0x3f, r0	; 63
   1461c:	ed bf       	out	0x3d, r30	; 61
   1461e:	c7 01       	movw	r24, r14
   14620:	6c e0       	ldi	r22, 0x0C	; 12
   14622:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
		 uart_print(1,0,strSend);
   14626:	81 e0       	ldi	r24, 0x01	; 1
   14628:	60 e0       	ldi	r22, 0x00	; 0
   1462a:	a7 01       	movw	r20, r14
   1462c:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
   14630:	03 5f       	subi	r16, 0xF3	; 243
   14632:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   14634:	f1 e0       	ldi	r31, 0x01	; 1
   14636:	09 30       	cpi	r16, 0x09	; 9
   14638:	1f 07       	cpc	r17, r31
   1463a:	79 f6       	brne	.-98     	; 0x145da <SendConfigParamater+0xd4>
   1463c:	05 e8       	ldi	r16, 0x85	; 133
   1463e:	10 e0       	ldi	r17, 0x00	; 0
   14640:	6e 01       	movw	r12, r28
   14642:	08 94       	sec
   14644:	c1 1c       	adc	r12, r1
   14646:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14648:	ea e2       	ldi	r30, 0x2A	; 42
   1464a:	ee 2e       	mov	r14, r30
   1464c:	f1 2c       	mov	r15, r1
   1464e:	ec 0e       	add	r14, r28
   14650:	fd 1e       	adc	r15, r29
   14652:	7d ed       	ldi	r23, 0xDD	; 221
   14654:	a7 2e       	mov	r10, r23
   14656:	73 e2       	ldi	r23, 0x23	; 35
   14658:	b7 2e       	mov	r11, r23
   1465a:	c6 01       	movw	r24, r12
   1465c:	b8 01       	movw	r22, r16
   1465e:	49 e0       	ldi	r20, 0x09	; 9
   14660:	50 e0       	ldi	r21, 0x00	; 0
   14662:	22 ed       	ldi	r18, 0xD2	; 210
   14664:	33 e1       	ldi	r19, 0x13	; 19
   14666:	0e 94 85 af 	call	0x15f0a	; 0x15f0a <__eerd_block>
   1466a:	00 d0       	rcall	.+0      	; 0x1466c <SendConfigParamater+0x166>
   1466c:	00 d0       	rcall	.+0      	; 0x1466e <SendConfigParamater+0x168>
   1466e:	00 d0       	rcall	.+0      	; 0x14670 <SendConfigParamater+0x16a>
   14670:	ed b7       	in	r30, 0x3d	; 61
   14672:	fe b7       	in	r31, 0x3e	; 62
   14674:	31 96       	adiw	r30, 0x01	; 1
   14676:	ad b7       	in	r26, 0x3d	; 61
   14678:	be b7       	in	r27, 0x3e	; 62
   1467a:	12 96       	adiw	r26, 0x02	; 2
   1467c:	fc 92       	st	X, r15
   1467e:	ee 92       	st	-X, r14
   14680:	11 97       	sbiw	r26, 0x01	; 1
   14682:	b3 82       	std	Z+3, r11	; 0x03
   14684:	a2 82       	std	Z+2, r10	; 0x02
   14686:	d5 82       	std	Z+5, r13	; 0x05
   14688:	c4 82       	std	Z+4, r12	; 0x04
   1468a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		 AddSpaceLag(strSend,5);
   1468e:	ed b7       	in	r30, 0x3d	; 61
   14690:	fe b7       	in	r31, 0x3e	; 62
   14692:	36 96       	adiw	r30, 0x06	; 6
   14694:	0f b6       	in	r0, 0x3f	; 63
   14696:	f8 94       	cli
   14698:	fe bf       	out	0x3e, r31	; 62
   1469a:	0f be       	out	0x3f, r0	; 63
   1469c:	ed bf       	out	0x3d, r30	; 61
   1469e:	c7 01       	movw	r24, r14
   146a0:	65 e0       	ldi	r22, 0x05	; 5
   146a2:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
		 uart_print(1,0,strSend);
   146a6:	81 e0       	ldi	r24, 0x01	; 1
   146a8:	60 e0       	ldi	r22, 0x00	; 0
   146aa:	a7 01       	movw	r20, r14
   146ac:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
   146b0:	07 5f       	subi	r16, 0xF7	; 247
   146b2:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   146b4:	f0 e0       	ldi	r31, 0x00	; 0
   146b6:	0b 3b       	cpi	r16, 0xBB	; 187
   146b8:	1f 07       	cpc	r17, r31
   146ba:	79 f6       	brne	.-98     	; 0x1465a <SendConfigParamater+0x154>
   146bc:	05 e4       	ldi	r16, 0x45	; 69
   146be:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   146c0:	6a e2       	ldi	r22, 0x2A	; 42
   146c2:	e6 2e       	mov	r14, r22
   146c4:	f1 2c       	mov	r15, r1
   146c6:	ec 0e       	add	r14, r28
   146c8:	fd 1e       	adc	r15, r29
   146ca:	58 ed       	ldi	r21, 0xD8	; 216
   146cc:	c5 2e       	mov	r12, r21
   146ce:	53 e2       	ldi	r21, 0x23	; 35
   146d0:	d5 2e       	mov	r13, r21
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   146d2:	e1 99       	sbic	0x1c, 1	; 28
   146d4:	fe cf       	rjmp	.-4      	; 0x146d2 <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   146d6:	1f bb       	out	0x1f, r17	; 31
   146d8:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   146da:	e0 9a       	sbi	0x1c, 0	; 28
   146dc:	8d b3       	in	r24, 0x1d	; 29
		 uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   146de:	84 36       	cpi	r24, 0x64	; 100
   146e0:	08 f0       	brcs	.+2      	; 0x146e4 <SendConfigParamater+0x1de>
   146e2:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   146e4:	00 d0       	rcall	.+0      	; 0x146e6 <SendConfigParamater+0x1e0>
   146e6:	00 d0       	rcall	.+0      	; 0x146e8 <SendConfigParamater+0x1e2>
   146e8:	00 d0       	rcall	.+0      	; 0x146ea <SendConfigParamater+0x1e4>
   146ea:	ed b7       	in	r30, 0x3d	; 61
   146ec:	fe b7       	in	r31, 0x3e	; 62
   146ee:	31 96       	adiw	r30, 0x01	; 1
   146f0:	ad b7       	in	r26, 0x3d	; 61
   146f2:	be b7       	in	r27, 0x3e	; 62
   146f4:	12 96       	adiw	r26, 0x02	; 2
   146f6:	fc 92       	st	X, r15
   146f8:	ee 92       	st	-X, r14
   146fa:	11 97       	sbiw	r26, 0x01	; 1
   146fc:	d3 82       	std	Z+3, r13	; 0x03
   146fe:	c2 82       	std	Z+2, r12	; 0x02
   14700:	84 83       	std	Z+4, r24	; 0x04
   14702:	15 82       	std	Z+5, r1	; 0x05
   14704:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  AddSpaceLag(strSend,2);
   14708:	ed b7       	in	r30, 0x3d	; 61
   1470a:	fe b7       	in	r31, 0x3e	; 62
   1470c:	36 96       	adiw	r30, 0x06	; 6
   1470e:	0f b6       	in	r0, 0x3f	; 63
   14710:	f8 94       	cli
   14712:	fe bf       	out	0x3e, r31	; 62
   14714:	0f be       	out	0x3f, r0	; 63
   14716:	ed bf       	out	0x3d, r30	; 61
   14718:	c7 01       	movw	r24, r14
   1471a:	62 e0       	ldi	r22, 0x02	; 2
   1471c:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
		 uart_print(1,0,strSend);
   14720:	81 e0       	ldi	r24, 0x01	; 1
   14722:	60 e0       	ldi	r22, 0x00	; 0
   14724:	a7 01       	movw	r20, r14
   14726:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
   1472a:	0f 5f       	subi	r16, 0xFF	; 255
   1472c:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   1472e:	f0 e0       	ldi	r31, 0x00	; 0
   14730:	0d 34       	cpi	r16, 0x4D	; 77
   14732:	1f 07       	cpc	r17, r31
   14734:	71 f6       	brne	.-100    	; 0x146d2 <SendConfigParamater+0x1cc>
   14736:	45 e5       	ldi	r20, 0x55	; 85
   14738:	e4 2e       	mov	r14, r20
   1473a:	40 e0       	ldi	r20, 0x00	; 0
   1473c:	f4 2e       	mov	r15, r20
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1473e:	3a e2       	ldi	r19, 0x2A	; 42
   14740:	a3 2e       	mov	r10, r19
   14742:	b1 2c       	mov	r11, r1
   14744:	ac 0e       	add	r10, r28
   14746:	bd 1e       	adc	r11, r29
   14748:	25 ed       	ldi	r18, 0xD5	; 213
   1474a:	82 2e       	mov	r8, r18
   1474c:	23 e2       	ldi	r18, 0x23	; 35
   1474e:	92 2e       	mov	r9, r18
   14750:	37 c0       	rjmp	.+110    	; 0x147c0 <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14752:	e1 99       	sbic	0x1c, 1	; 28
   14754:	fe cf       	rjmp	.-4      	; 0x14752 <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14756:	1f bb       	out	0x1f, r17	; 31
   14758:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1475a:	e0 9a       	sbi	0x1c, 0	; 28
   1475c:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   1475e:	8a 30       	cpi	r24, 0x0A	; 10
   14760:	08 f0       	brcs	.+2      	; 0x14764 <SendConfigParamater+0x25e>
   14762:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14764:	00 d0       	rcall	.+0      	; 0x14766 <SendConfigParamater+0x260>
   14766:	00 d0       	rcall	.+0      	; 0x14768 <SendConfigParamater+0x262>
   14768:	00 d0       	rcall	.+0      	; 0x1476a <SendConfigParamater+0x264>
   1476a:	ed b7       	in	r30, 0x3d	; 61
   1476c:	fe b7       	in	r31, 0x3e	; 62
   1476e:	31 96       	adiw	r30, 0x01	; 1
   14770:	ad b7       	in	r26, 0x3d	; 61
   14772:	be b7       	in	r27, 0x3e	; 62
   14774:	12 96       	adiw	r26, 0x02	; 2
   14776:	bc 92       	st	X, r11
   14778:	ae 92       	st	-X, r10
   1477a:	11 97       	sbiw	r26, 0x01	; 1
   1477c:	93 82       	std	Z+3, r9	; 0x03
   1477e:	82 82       	std	Z+2, r8	; 0x02
   14780:	84 83       	std	Z+4, r24	; 0x04
   14782:	15 82       	std	Z+5, r1	; 0x05
   14784:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
			   uart_print(1,0,strSend);
   14788:	ed b7       	in	r30, 0x3d	; 61
   1478a:	fe b7       	in	r31, 0x3e	; 62
   1478c:	36 96       	adiw	r30, 0x06	; 6
   1478e:	0f b6       	in	r0, 0x3f	; 63
   14790:	f8 94       	cli
   14792:	fe bf       	out	0x3e, r31	; 62
   14794:	0f be       	out	0x3f, r0	; 63
   14796:	ed bf       	out	0x3d, r30	; 61
   14798:	81 e0       	ldi	r24, 0x01	; 1
   1479a:	60 e0       	ldi	r22, 0x00	; 0
   1479c:	a5 01       	movw	r20, r10
   1479e:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   147a2:	d3 94       	inc	r13
   147a4:	0f 5f       	subi	r16, 0xFF	; 255
   147a6:	1f 4f       	sbci	r17, 0xFF	; 255
   147a8:	f6 e0       	ldi	r31, 0x06	; 6
   147aa:	df 16       	cp	r13, r31
   147ac:	91 f6       	brne	.-92     	; 0x14752 <SendConfigParamater+0x24c>
   147ae:	86 e0       	ldi	r24, 0x06	; 6
   147b0:	90 e0       	ldi	r25, 0x00	; 0
   147b2:	e8 0e       	add	r14, r24
   147b4:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   147b6:	95 e8       	ldi	r25, 0x85	; 133
   147b8:	e9 16       	cp	r14, r25
   147ba:	90 e0       	ldi	r25, 0x00	; 0
   147bc:	f9 06       	cpc	r15, r25
   147be:	19 f0       	breq	.+6      	; 0x147c6 <SendConfigParamater+0x2c0>
   147c0:	87 01       	movw	r16, r14
   147c2:	dd 24       	eor	r13, r13
   147c4:	c6 cf       	rjmp	.-116    	; 0x14752 <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   147c6:	e1 99       	sbic	0x1c, 1	; 28
   147c8:	fe cf       	rjmp	.-4      	; 0x147c6 <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   147ca:	81 ec       	ldi	r24, 0xC1	; 193
   147cc:	93 e0       	ldi	r25, 0x03	; 3
   147ce:	9f bb       	out	0x1f, r25	; 31
   147d0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   147d2:	e0 9a       	sbi	0x1c, 0	; 28
   147d4:	8d b3       	in	r24, 0x1d	; 29
   147d6:	9e 01       	movw	r18, r28
   147d8:	26 5d       	subi	r18, 0xD6	; 214
   147da:	3f 4f       	sbci	r19, 0xFF	; 255
			   uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   147dc:	81 30       	cpi	r24, 0x01	; 1
   147de:	79 f4       	brne	.+30     	; 0x147fe <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   147e0:	00 d0       	rcall	.+0      	; 0x147e2 <SendConfigParamater+0x2dc>
   147e2:	00 d0       	rcall	.+0      	; 0x147e4 <SendConfigParamater+0x2de>
   147e4:	ad b7       	in	r26, 0x3d	; 61
   147e6:	be b7       	in	r27, 0x3e	; 62
   147e8:	12 96       	adiw	r26, 0x02	; 2
   147ea:	3c 93       	st	X, r19
   147ec:	2e 93       	st	-X, r18
   147ee:	11 97       	sbiw	r26, 0x01	; 1
   147f0:	83 ed       	ldi	r24, 0xD3	; 211
   147f2:	93 e2       	ldi	r25, 0x23	; 35
   147f4:	14 96       	adiw	r26, 0x04	; 4
   147f6:	9c 93       	st	X, r25
   147f8:	8e 93       	st	-X, r24
   147fa:	13 97       	sbiw	r26, 0x03	; 3
   147fc:	0a c0       	rjmp	.+20     	; 0x14812 <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   147fe:	00 d0       	rcall	.+0      	; 0x14800 <SendConfigParamater+0x2fa>
   14800:	00 d0       	rcall	.+0      	; 0x14802 <SendConfigParamater+0x2fc>
   14802:	ed b7       	in	r30, 0x3d	; 61
   14804:	fe b7       	in	r31, 0x3e	; 62
   14806:	32 83       	std	Z+2, r19	; 0x02
   14808:	21 83       	std	Z+1, r18	; 0x01
   1480a:	81 ed       	ldi	r24, 0xD1	; 209
   1480c:	93 e2       	ldi	r25, 0x23	; 35
   1480e:	94 83       	std	Z+4, r25	; 0x04
   14810:	83 83       	std	Z+3, r24	; 0x03
   14812:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   14816:	0f 90       	pop	r0
   14818:	0f 90       	pop	r0
   1481a:	0f 90       	pop	r0
   1481c:	0f 90       	pop	r0
	 }uart_print(1,0,strSend);
   1481e:	81 e0       	ldi	r24, 0x01	; 1
   14820:	60 e0       	ldi	r22, 0x00	; 0
   14822:	ae 01       	movw	r20, r28
   14824:	46 5d       	subi	r20, 0xD6	; 214
   14826:	5f 4f       	sbci	r21, 0xFF	; 255
   14828:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1482c:	e1 99       	sbic	0x1c, 1	; 28
   1482e:	fe cf       	rjmp	.-4      	; 0x1482c <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14830:	80 e0       	ldi	r24, 0x00	; 0
   14832:	90 e0       	ldi	r25, 0x00	; 0
   14834:	9f bb       	out	0x1f, r25	; 31
   14836:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14838:	e0 9a       	sbi	0x1c, 0	; 28
   1483a:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   1483c:	00 d0       	rcall	.+0      	; 0x1483e <SendConfigParamater+0x338>
   1483e:	00 d0       	rcall	.+0      	; 0x14840 <SendConfigParamater+0x33a>
   14840:	00 d0       	rcall	.+0      	; 0x14842 <SendConfigParamater+0x33c>
   14842:	ed b7       	in	r30, 0x3d	; 61
   14844:	fe b7       	in	r31, 0x3e	; 62
   14846:	31 96       	adiw	r30, 0x01	; 1
   14848:	8e 01       	movw	r16, r28
   1484a:	06 5d       	subi	r16, 0xD6	; 214
   1484c:	1f 4f       	sbci	r17, 0xFF	; 255
   1484e:	ad b7       	in	r26, 0x3d	; 61
   14850:	be b7       	in	r27, 0x3e	; 62
   14852:	12 96       	adiw	r26, 0x02	; 2
   14854:	1c 93       	st	X, r17
   14856:	0e 93       	st	-X, r16
   14858:	11 97       	sbiw	r26, 0x01	; 1
   1485a:	8c ec       	ldi	r24, 0xCC	; 204
   1485c:	93 e2       	ldi	r25, 0x23	; 35
   1485e:	93 83       	std	Z+3, r25	; 0x03
   14860:	82 83       	std	Z+2, r24	; 0x02
   14862:	24 83       	std	Z+4, r18	; 0x04
   14864:	15 82       	std	Z+5, r1	; 0x05
   14866:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
     uart_print(1,0,strSend);
   1486a:	ed b7       	in	r30, 0x3d	; 61
   1486c:	fe b7       	in	r31, 0x3e	; 62
   1486e:	36 96       	adiw	r30, 0x06	; 6
   14870:	0f b6       	in	r0, 0x3f	; 63
   14872:	f8 94       	cli
   14874:	fe bf       	out	0x3e, r31	; 62
   14876:	0f be       	out	0x3f, r0	; 63
   14878:	ed bf       	out	0x3d, r30	; 61
   1487a:	81 e0       	ldi	r24, 0x01	; 1
   1487c:	60 e0       	ldi	r22, 0x00	; 0
   1487e:	a8 01       	movw	r20, r16
   14880:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
   14884:	9d e4       	ldi	r25, 0x4D	; 77
   14886:	e9 2e       	mov	r14, r25
   14888:	90 e0       	ldi	r25, 0x00	; 0
   1488a:	f9 2e       	mov	r15, r25
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   1488c:	d0 2e       	mov	r13, r16
   1488e:	01 2f       	mov	r16, r17
   14890:	87 ec       	ldi	r24, 0xC7	; 199
   14892:	a8 2e       	mov	r10, r24
   14894:	83 e2       	ldi	r24, 0x23	; 35
   14896:	b8 2e       	mov	r11, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14898:	e1 99       	sbic	0x1c, 1	; 28
   1489a:	fe cf       	rjmp	.-4      	; 0x14898 <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1489c:	ff ba       	out	0x1f, r15	; 31
   1489e:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   148a0:	e0 9a       	sbi	0x1c, 0	; 28
   148a2:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   148a4:	84 36       	cpi	r24, 0x64	; 100
   148a6:	08 f0       	brcs	.+2      	; 0x148aa <SendConfigParamater+0x3a4>
   148a8:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   148aa:	00 d0       	rcall	.+0      	; 0x148ac <SendConfigParamater+0x3a6>
   148ac:	00 d0       	rcall	.+0      	; 0x148ae <SendConfigParamater+0x3a8>
   148ae:	00 d0       	rcall	.+0      	; 0x148b0 <SendConfigParamater+0x3aa>
   148b0:	ed b7       	in	r30, 0x3d	; 61
   148b2:	fe b7       	in	r31, 0x3e	; 62
   148b4:	31 96       	adiw	r30, 0x01	; 1
   148b6:	ad b7       	in	r26, 0x3d	; 61
   148b8:	be b7       	in	r27, 0x3e	; 62
   148ba:	11 96       	adiw	r26, 0x01	; 1
   148bc:	dc 92       	st	X, r13
   148be:	11 97       	sbiw	r26, 0x01	; 1
   148c0:	12 96       	adiw	r26, 0x02	; 2
   148c2:	0c 93       	st	X, r16
   148c4:	b3 82       	std	Z+3, r11	; 0x03
   148c6:	a2 82       	std	Z+2, r10	; 0x02
   148c8:	84 83       	std	Z+4, r24	; 0x04
   148ca:	15 82       	std	Z+5, r1	; 0x05
   148cc:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
		  AddSpaceLag(strSend,2);
   148d0:	ed b7       	in	r30, 0x3d	; 61
   148d2:	fe b7       	in	r31, 0x3e	; 62
   148d4:	36 96       	adiw	r30, 0x06	; 6
   148d6:	0f b6       	in	r0, 0x3f	; 63
   148d8:	f8 94       	cli
   148da:	fe bf       	out	0x3e, r31	; 62
   148dc:	0f be       	out	0x3f, r0	; 63
   148de:	ed bf       	out	0x3d, r30	; 61
   148e0:	8d 2d       	mov	r24, r13
   148e2:	90 2f       	mov	r25, r16
   148e4:	62 e0       	ldi	r22, 0x02	; 2
   148e6:	0e 94 df 30 	call	0x61be	; 0x61be <AddSpaceLag>
		 uart_print(1,0,strSend);
   148ea:	81 e0       	ldi	r24, 0x01	; 1
   148ec:	60 e0       	ldi	r22, 0x00	; 0
   148ee:	4d 2d       	mov	r20, r13
   148f0:	50 2f       	mov	r21, r16
   148f2:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>
   148f6:	08 94       	sec
   148f8:	e1 1c       	adc	r14, r1
   148fa:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   148fc:	f5 e5       	ldi	r31, 0x55	; 85
   148fe:	ef 16       	cp	r14, r31
   14900:	f0 e0       	ldi	r31, 0x00	; 0
   14902:	ff 06       	cpc	r15, r31
   14904:	49 f6       	brne	.-110    	; 0x14898 <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 uart_printf(1,1,PSTR(">"));
   14906:	81 e0       	ldi	r24, 0x01	; 1
   14908:	61 e0       	ldi	r22, 0x01	; 1
   1490a:	45 ec       	ldi	r20, 0xC5	; 197
   1490c:	53 e2       	ldi	r21, 0x23	; 35
   1490e:	0e 94 2c ae 	call	0x15c58	; 0x15c58 <uart_printf>
	 //End
}
   14912:	cb 59       	subi	r28, 0x9B	; 155
   14914:	df 4f       	sbci	r29, 0xFF	; 255
   14916:	0f b6       	in	r0, 0x3f	; 63
   14918:	f8 94       	cli
   1491a:	de bf       	out	0x3e, r29	; 62
   1491c:	0f be       	out	0x3f, r0	; 63
   1491e:	cd bf       	out	0x3d, r28	; 61
   14920:	cf 91       	pop	r28
   14922:	df 91       	pop	r29
   14924:	1f 91       	pop	r17
   14926:	0f 91       	pop	r16
   14928:	ff 90       	pop	r15
   1492a:	ef 90       	pop	r14
   1492c:	df 90       	pop	r13
   1492e:	cf 90       	pop	r12
   14930:	bf 90       	pop	r11
   14932:	af 90       	pop	r10
   14934:	9f 90       	pop	r9
   14936:	8f 90       	pop	r8
   14938:	08 95       	ret

0001493a <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   1493a:	8f 92       	push	r8
   1493c:	9f 92       	push	r9
   1493e:	af 92       	push	r10
   14940:	bf 92       	push	r11
   14942:	cf 92       	push	r12
   14944:	df 92       	push	r13
   14946:	ef 92       	push	r14
   14948:	ff 92       	push	r15
   1494a:	0f 93       	push	r16
   1494c:	1f 93       	push	r17
   1494e:	df 93       	push	r29
   14950:	cf 93       	push	r28
   14952:	cd b7       	in	r28, 0x3d	; 61
   14954:	de b7       	in	r29, 0x3e	; 62
   14956:	c6 54       	subi	r28, 0x46	; 70
   14958:	d0 40       	sbci	r29, 0x00	; 0
   1495a:	0f b6       	in	r0, 0x3f	; 63
   1495c:	f8 94       	cli
   1495e:	de bf       	out	0x3e, r29	; 62
   14960:	0f be       	out	0x3f, r0	; 63
   14962:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
   14964:	00 d0       	rcall	.+0      	; 0x14966 <SaveConfigParameter+0x2c>
   14966:	00 d0       	rcall	.+0      	; 0x14968 <SaveConfigParameter+0x2e>
   14968:	00 d0       	rcall	.+0      	; 0x1496a <SaveConfigParameter+0x30>
   1496a:	ed b7       	in	r30, 0x3d	; 61
   1496c:	fe b7       	in	r31, 0x3e	; 62
   1496e:	31 96       	adiw	r30, 0x01	; 1
   14970:	8e 01       	movw	r16, r28
   14972:	0f 5f       	subi	r16, 0xFF	; 255
   14974:	1f 4f       	sbci	r17, 0xFF	; 255
   14976:	ad b7       	in	r26, 0x3d	; 61
   14978:	be b7       	in	r27, 0x3e	; 62
   1497a:	12 96       	adiw	r26, 0x02	; 2
   1497c:	1c 93       	st	X, r17
   1497e:	0e 93       	st	-X, r16
   14980:	11 97       	sbiw	r26, 0x01	; 1
   14982:	8f ef       	ldi	r24, 0xFF	; 255
   14984:	93 e2       	ldi	r25, 0x23	; 35
   14986:	93 83       	std	Z+3, r25	; 0x03
   14988:	82 83       	std	Z+2, r24	; 0x02
   1498a:	80 91 8b 01 	lds	r24, 0x018B
   1498e:	90 91 8c 01 	lds	r25, 0x018C
   14992:	95 83       	std	Z+5, r25	; 0x05
   14994:	84 83       	std	Z+4, r24	; 0x04
   14996:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	 uart_print(1,1,strSend);
   1499a:	ed b7       	in	r30, 0x3d	; 61
   1499c:	fe b7       	in	r31, 0x3e	; 62
   1499e:	36 96       	adiw	r30, 0x06	; 6
   149a0:	0f b6       	in	r0, 0x3f	; 63
   149a2:	f8 94       	cli
   149a4:	fe bf       	out	0x3e, r31	; 62
   149a6:	0f be       	out	0x3f, r0	; 63
   149a8:	ed bf       	out	0x3d, r30	; 61
   149aa:	81 e0       	ldi	r24, 0x01	; 1
   149ac:	61 e0       	ldi	r22, 0x01	; 1
   149ae:	a8 01       	movw	r20, r16
   149b0:	0e 94 04 ae 	call	0x15c08	; 0x15c08 <uart_print>

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
   149b4:	81 e0       	ldi	r24, 0x01	; 1
   149b6:	61 e0       	ldi	r22, 0x01	; 1
   149b8:	46 ef       	ldi	r20, 0xF6	; 246
   149ba:	53 e2       	ldi	r21, 0x23	; 35
   149bc:	0e 94 2c ae 	call	0x15c58	; 0x15c58 <uart_printf>
   149c0:	07 e2       	ldi	r16, 0x27	; 39
   149c2:	12 e0       	ldi	r17, 0x02	; 2
   149c4:	3d e1       	ldi	r19, 0x1D	; 29
   149c6:	e3 2e       	mov	r14, r19
   149c8:	39 e0       	ldi	r19, 0x09	; 9
   149ca:	f3 2e       	mov	r15, r19
   149cc:	25 e1       	ldi	r18, 0x15	; 21
   149ce:	a2 2e       	mov	r10, r18
   149d0:	b1 2c       	mov	r11, r1
   149d2:	ac 0e       	add	r10, r28
   149d4:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   149d6:	9d e3       	ldi	r25, 0x3D	; 61
   149d8:	c9 2e       	mov	r12, r25
   149da:	d1 2c       	mov	r13, r1
   149dc:	cc 0e       	add	r12, r28
   149de:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
   149e0:	d7 01       	movw	r26, r14
   149e2:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   149e4:	8d 91       	ld	r24, X+
   149e6:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   149e8:	ec 15       	cp	r30, r12
   149ea:	fd 05       	cpc	r31, r13
   149ec:	d9 f7       	brne	.-10     	; 0x149e4 <SaveConfigParameter+0xaa>
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   149ee:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   149f0:	c8 01       	movw	r24, r16
   149f2:	b5 01       	movw	r22, r10
   149f4:	49 e2       	ldi	r20, 0x29	; 41
   149f6:	50 e0       	ldi	r21, 0x00	; 0
   149f8:	2a ed       	ldi	r18, 0xDA	; 218
   149fa:	33 e1       	ldi	r19, 0x13	; 19
   149fc:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
   14a00:	07 5d       	subi	r16, 0xD7	; 215
   14a02:	1f 4f       	sbci	r17, 0xFF	; 255
   14a04:	88 e2       	ldi	r24, 0x28	; 40
   14a06:	90 e0       	ldi	r25, 0x00	; 0
   14a08:	e8 0e       	add	r14, r24
   14a0a:	f9 1e       	adc	r15, r25
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   14a0c:	93 e0       	ldi	r25, 0x03	; 3
   14a0e:	01 3c       	cpi	r16, 0xC1	; 193
   14a10:	19 07       	cpc	r17, r25
   14a12:	31 f7       	brne	.-52     	; 0x149e0 <SaveConfigParameter+0xa6>
   14a14:	0b eb       	ldi	r16, 0xBB	; 187
   14a16:	10 e0       	ldi	r17, 0x00	; 0
   14a18:	8d ea       	ldi	r24, 0xAD	; 173
   14a1a:	e8 2e       	mov	r14, r24
   14a1c:	8a e0       	ldi	r24, 0x0A	; 10
   14a1e:	f8 2e       	mov	r15, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14a20:	b5 e1       	ldi	r27, 0x15	; 21
   14a22:	cb 2e       	mov	r12, r27
   14a24:	d1 2c       	mov	r13, r1
   14a26:	cc 0e       	add	r12, r28
   14a28:	dd 1e       	adc	r13, r29
   14a2a:	a1 e2       	ldi	r26, 0x21	; 33
   14a2c:	8a 2e       	mov	r8, r26
   14a2e:	91 2c       	mov	r9, r1
   14a30:	8c 0e       	add	r8, r28
   14a32:	9d 1e       	adc	r9, r29
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   14a34:	d7 01       	movw	r26, r14
   14a36:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14a38:	8d 91       	ld	r24, X+
   14a3a:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14a3c:	e8 15       	cp	r30, r8
   14a3e:	f9 05       	cpc	r31, r9
   14a40:	d9 f7       	brne	.-10     	; 0x14a38 <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   14a42:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   14a44:	c6 01       	movw	r24, r12
   14a46:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   14a4a:	f6 01       	movw	r30, r12
   14a4c:	01 90       	ld	r0, Z+
   14a4e:	00 20       	and	r0, r0
   14a50:	e9 f7       	brne	.-6      	; 0x14a4c <SaveConfigParameter+0x112>
   14a52:	31 97       	sbiw	r30, 0x01	; 1
   14a54:	10 82       	st	Z, r1
   14a56:	c8 01       	movw	r24, r16
   14a58:	b6 01       	movw	r22, r12
   14a5a:	4d e0       	ldi	r20, 0x0D	; 13
   14a5c:	50 e0       	ldi	r21, 0x00	; 0
   14a5e:	2a ed       	ldi	r18, 0xDA	; 218
   14a60:	33 e1       	ldi	r19, 0x13	; 19
   14a62:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
   14a66:	03 5f       	subi	r16, 0xF3	; 243
   14a68:	1f 4f       	sbci	r17, 0xFF	; 255
   14a6a:	ac e0       	ldi	r26, 0x0C	; 12
   14a6c:	b0 e0       	ldi	r27, 0x00	; 0
   14a6e:	ea 0e       	add	r14, r26
   14a70:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   14a72:	b1 e0       	ldi	r27, 0x01	; 1
   14a74:	09 30       	cpi	r16, 0x09	; 9
   14a76:	1b 07       	cpc	r17, r27
   14a78:	e9 f6       	brne	.-70     	; 0x14a34 <SaveConfigParameter+0xfa>
   14a7a:	05 e8       	ldi	r16, 0x85	; 133
   14a7c:	10 e0       	ldi	r17, 0x00	; 0
   14a7e:	f5 ef       	ldi	r31, 0xF5	; 245
   14a80:	ef 2e       	mov	r14, r31
   14a82:	fa e0       	ldi	r31, 0x0A	; 10
   14a84:	ff 2e       	mov	r15, r31
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14a86:	e5 e1       	ldi	r30, 0x15	; 21
   14a88:	ce 2e       	mov	r12, r30
   14a8a:	d1 2c       	mov	r13, r1
   14a8c:	cc 0e       	add	r12, r28
   14a8e:	dd 1e       	adc	r13, r29
   14a90:	7a e1       	ldi	r23, 0x1A	; 26
   14a92:	87 2e       	mov	r8, r23
   14a94:	91 2c       	mov	r9, r1
   14a96:	8c 0e       	add	r8, r28
   14a98:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   14a9a:	d7 01       	movw	r26, r14
   14a9c:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14a9e:	8d 91       	ld	r24, X+
   14aa0:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14aa2:	e8 15       	cp	r30, r8
   14aa4:	f9 05       	cpc	r31, r9
   14aa6:	d9 f7       	brne	.-10     	; 0x14a9e <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   14aa8:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   14aaa:	c6 01       	movw	r24, r12
   14aac:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <RemSpaceLag>
   14ab0:	c8 01       	movw	r24, r16
   14ab2:	b6 01       	movw	r22, r12
   14ab4:	49 e0       	ldi	r20, 0x09	; 9
   14ab6:	50 e0       	ldi	r21, 0x00	; 0
   14ab8:	2a ed       	ldi	r18, 0xDA	; 218
   14aba:	33 e1       	ldi	r19, 0x13	; 19
   14abc:	0e 94 a1 af 	call	0x15f42	; 0x15f42 <__eewr_block>
   14ac0:	07 5f       	subi	r16, 0xF7	; 247
   14ac2:	1f 4f       	sbci	r17, 0xFF	; 255
   14ac4:	e5 e0       	ldi	r30, 0x05	; 5
   14ac6:	f0 e0       	ldi	r31, 0x00	; 0
   14ac8:	ee 0e       	add	r14, r30
   14aca:	ff 1e       	adc	r15, r31
		// uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   14acc:	f0 e0       	ldi	r31, 0x00	; 0
   14ace:	0b 3b       	cpi	r16, 0xBB	; 187
   14ad0:	1f 07       	cpc	r17, r31
   14ad2:	19 f7       	brne	.-58     	; 0x14a9a <SaveConfigParameter+0x160>
   14ad4:	03 e1       	ldi	r16, 0x13	; 19
   14ad6:	1b e0       	ldi	r17, 0x0B	; 11
   14ad8:	65 e4       	ldi	r22, 0x45	; 69
   14ada:	e6 2e       	mov	r14, r22
   14adc:	60 e0       	ldi	r22, 0x00	; 0
   14ade:	f6 2e       	mov	r15, r22
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   14ae0:	55 e1       	ldi	r21, 0x15	; 21
   14ae2:	c5 2e       	mov	r12, r21
   14ae4:	d1 2c       	mov	r13, r1
   14ae6:	cc 0e       	add	r12, r28
   14ae8:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14aea:	4e 01       	movw	r8, r28
   14aec:	08 94       	sec
   14aee:	81 1c       	adc	r8, r1
   14af0:	91 1c       	adc	r9, r1
   14af2:	43 ef       	ldi	r20, 0xF3	; 243
   14af4:	a4 2e       	mov	r10, r20
   14af6:	43 e2       	ldi	r20, 0x23	; 35
   14af8:	b4 2e       	mov	r11, r20
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14afa:	d8 01       	movw	r26, r16
   14afc:	8c 91       	ld	r24, X
   14afe:	8d 8b       	std	Y+21, r24	; 0x15
   14b00:	11 96       	adiw	r26, 0x01	; 1
   14b02:	8c 91       	ld	r24, X
   14b04:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   14b06:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   14b08:	c6 01       	movw	r24, r12
   14b0a:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   14b0e:	c6 01       	movw	r24, r12
   14b10:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   14b14:	e1 99       	sbic	0x1c, 1	; 28
   14b16:	fe cf       	rjmp	.-4      	; 0x14b14 <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14b18:	ff ba       	out	0x1f, r15	; 31
   14b1a:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   14b1c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   14b1e:	0f b6       	in	r0, 0x3f	; 63
   14b20:	f8 94       	cli
   14b22:	e2 9a       	sbi	0x1c, 2	; 28
   14b24:	e1 9a       	sbi	0x1c, 1	; 28
   14b26:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14b28:	00 d0       	rcall	.+0      	; 0x14b2a <SaveConfigParameter+0x1f0>
   14b2a:	00 d0       	rcall	.+0      	; 0x14b2c <SaveConfigParameter+0x1f2>
   14b2c:	00 d0       	rcall	.+0      	; 0x14b2e <SaveConfigParameter+0x1f4>
   14b2e:	ed b7       	in	r30, 0x3d	; 61
   14b30:	fe b7       	in	r31, 0x3e	; 62
   14b32:	31 96       	adiw	r30, 0x01	; 1
   14b34:	ad b7       	in	r26, 0x3d	; 61
   14b36:	be b7       	in	r27, 0x3e	; 62
   14b38:	12 96       	adiw	r26, 0x02	; 2
   14b3a:	9c 92       	st	X, r9
   14b3c:	8e 92       	st	-X, r8
   14b3e:	11 97       	sbiw	r26, 0x01	; 1
   14b40:	b3 82       	std	Z+3, r11	; 0x03
   14b42:	a2 82       	std	Z+2, r10	; 0x02
   14b44:	84 83       	std	Z+4, r24	; 0x04
   14b46:	15 82       	std	Z+5, r1	; 0x05
   14b48:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   14b4c:	0e 5f       	subi	r16, 0xFE	; 254
   14b4e:	1f 4f       	sbci	r17, 0xFF	; 255
   14b50:	08 94       	sec
   14b52:	e1 1c       	adc	r14, r1
   14b54:	f1 1c       	adc	r15, r1
		// uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   14b56:	ed b7       	in	r30, 0x3d	; 61
   14b58:	fe b7       	in	r31, 0x3e	; 62
   14b5a:	36 96       	adiw	r30, 0x06	; 6
   14b5c:	0f b6       	in	r0, 0x3f	; 63
   14b5e:	f8 94       	cli
   14b60:	fe bf       	out	0x3e, r31	; 62
   14b62:	0f be       	out	0x3f, r0	; 63
   14b64:	ed bf       	out	0x3d, r30	; 61
   14b66:	fb e0       	ldi	r31, 0x0B	; 11
   14b68:	03 32       	cpi	r16, 0x23	; 35
   14b6a:	1f 07       	cpc	r17, r31
   14b6c:	09 f0       	breq	.+2      	; 0x14b70 <SaveConfigParameter+0x236>
   14b6e:	c5 cf       	rjmp	.-118    	; 0x14afa <SaveConfigParameter+0x1c0>
   14b70:	45 e5       	ldi	r20, 0x55	; 85
   14b72:	50 e0       	ldi	r21, 0x00	; 0
   14b74:	b8 01       	movw	r22, r16
   14b76:	1d c0       	rjmp	.+58     	; 0x14bb2 <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   14b78:	90 81       	ld	r25, Z
   14b7a:	90 53       	subi	r25, 0x30	; 48
   14b7c:	9a 30       	cpi	r25, 0x0A	; 10
   14b7e:	08 f0       	brcs	.+2      	; 0x14b82 <SaveConfigParameter+0x248>
   14b80:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   14b82:	e1 99       	sbic	0x1c, 1	; 28
   14b84:	fe cf       	rjmp	.-4      	; 0x14b82 <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14b86:	3f bb       	out	0x1f, r19	; 31
   14b88:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   14b8a:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   14b8c:	0f b6       	in	r0, 0x3f	; 63
   14b8e:	f8 94       	cli
   14b90:	e2 9a       	sbi	0x1c, 2	; 28
   14b92:	e1 9a       	sbi	0x1c, 1	; 28
   14b94:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   14b96:	8f 5f       	subi	r24, 0xFF	; 255
   14b98:	31 96       	adiw	r30, 0x01	; 1
   14b9a:	2f 5f       	subi	r18, 0xFF	; 255
   14b9c:	3f 4f       	sbci	r19, 0xFF	; 255
   14b9e:	86 30       	cpi	r24, 0x06	; 6
   14ba0:	59 f7       	brne	.-42     	; 0x14b78 <SaveConfigParameter+0x23e>
   14ba2:	4a 5f       	subi	r20, 0xFA	; 250
   14ba4:	5f 4f       	sbci	r21, 0xFF	; 255
   14ba6:	6a 5f       	subi	r22, 0xFA	; 250
   14ba8:	7f 4f       	sbci	r23, 0xFF	; 255
		// uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   14baa:	80 e0       	ldi	r24, 0x00	; 0
   14bac:	45 38       	cpi	r20, 0x85	; 133
   14bae:	58 07       	cpc	r21, r24
   14bb0:	21 f0       	breq	.+8      	; 0x14bba <SaveConfigParameter+0x280>
   14bb2:	fb 01       	movw	r30, r22
   14bb4:	9a 01       	movw	r18, r20
   14bb6:	80 e0       	ldi	r24, 0x00	; 0
   14bb8:	df cf       	rjmp	.-66     	; 0x14b78 <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   14bba:	80 91 53 0b 	lds	r24, 0x0B53
   14bbe:	80 53       	subi	r24, 0x30	; 48
   14bc0:	8a 30       	cpi	r24, 0x0A	; 10
   14bc2:	10 f0       	brcs	.+4      	; 0x14bc8 <SaveConfigParameter+0x28e>
   14bc4:	20 e0       	ldi	r18, 0x00	; 0
   14bc6:	03 c0       	rjmp	.+6      	; 0x14bce <SaveConfigParameter+0x294>
   14bc8:	81 11       	cpse	r24, r1
   14bca:	81 e0       	ldi	r24, 0x01	; 1
   14bcc:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   14bce:	e1 99       	sbic	0x1c, 1	; 28
   14bd0:	fe cf       	rjmp	.-4      	; 0x14bce <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14bd2:	81 ec       	ldi	r24, 0xC1	; 193
   14bd4:	93 e0       	ldi	r25, 0x03	; 3
   14bd6:	9f bb       	out	0x1f, r25	; 31
   14bd8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   14bda:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   14bdc:	0f b6       	in	r0, 0x3f	; 63
   14bde:	f8 94       	cli
   14be0:	e2 9a       	sbi	0x1c, 2	; 28
   14be2:	e1 9a       	sbi	0x1c, 1	; 28
   14be4:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14be6:	80 91 54 0b 	lds	r24, 0x0B54
   14bea:	8d 8b       	std	Y+21, r24	; 0x15
   14bec:	80 91 55 0b 	lds	r24, 0x0B55
   14bf0:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   14bf2:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   14bf4:	8e 01       	movw	r16, r28
   14bf6:	0b 5e       	subi	r16, 0xEB	; 235
   14bf8:	1f 4f       	sbci	r17, 0xFF	; 255
   14bfa:	c8 01       	movw	r24, r16
   14bfc:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   14c00:	c8 01       	movw	r24, r16
   14c02:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
   14c06:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   14c08:	e1 99       	sbic	0x1c, 1	; 28
   14c0a:	fe cf       	rjmp	.-4      	; 0x14c08 <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14c0c:	80 e0       	ldi	r24, 0x00	; 0
   14c0e:	90 e0       	ldi	r25, 0x00	; 0
   14c10:	9f bb       	out	0x1f, r25	; 31
   14c12:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   14c14:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   14c16:	0f b6       	in	r0, 0x3f	; 63
   14c18:	f8 94       	cli
   14c1a:	e2 9a       	sbi	0x1c, 2	; 28
   14c1c:	e1 9a       	sbi	0x1c, 1	; 28
   14c1e:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14c20:	00 d0       	rcall	.+0      	; 0x14c22 <SaveConfigParameter+0x2e8>
   14c22:	00 d0       	rcall	.+0      	; 0x14c24 <SaveConfigParameter+0x2ea>
   14c24:	00 d0       	rcall	.+0      	; 0x14c26 <SaveConfigParameter+0x2ec>
   14c26:	ed b7       	in	r30, 0x3d	; 61
   14c28:	fe b7       	in	r31, 0x3e	; 62
   14c2a:	31 96       	adiw	r30, 0x01	; 1
   14c2c:	8e 01       	movw	r16, r28
   14c2e:	0f 5f       	subi	r16, 0xFF	; 255
   14c30:	1f 4f       	sbci	r17, 0xFF	; 255
   14c32:	ad b7       	in	r26, 0x3d	; 61
   14c34:	be b7       	in	r27, 0x3e	; 62
   14c36:	12 96       	adiw	r26, 0x02	; 2
   14c38:	1c 93       	st	X, r17
   14c3a:	0e 93       	st	-X, r16
   14c3c:	11 97       	sbiw	r26, 0x01	; 1
   14c3e:	80 ef       	ldi	r24, 0xF0	; 240
   14c40:	93 e2       	ldi	r25, 0x23	; 35
   14c42:	93 83       	std	Z+3, r25	; 0x03
   14c44:	82 83       	std	Z+2, r24	; 0x02
   14c46:	24 83       	std	Z+4, r18	; 0x04
   14c48:	15 82       	std	Z+5, r1	; 0x05
   14c4a:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   14c4e:	36 e5       	ldi	r19, 0x56	; 86
   14c50:	e3 2e       	mov	r14, r19
   14c52:	3b e0       	ldi	r19, 0x0B	; 11
   14c54:	f3 2e       	mov	r15, r19
   14c56:	2d e4       	ldi	r18, 0x4D	; 77
   14c58:	c2 2e       	mov	r12, r18
   14c5a:	20 e0       	ldi	r18, 0x00	; 0
   14c5c:	d2 2e       	mov	r13, r18
   14c5e:	ed b7       	in	r30, 0x3d	; 61
   14c60:	fe b7       	in	r31, 0x3e	; 62
   14c62:	36 96       	adiw	r30, 0x06	; 6
   14c64:	0f b6       	in	r0, 0x3f	; 63
   14c66:	f8 94       	cli
   14c68:	fe bf       	out	0x3e, r31	; 62
   14c6a:	0f be       	out	0x3f, r0	; 63
   14c6c:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   14c6e:	95 e1       	ldi	r25, 0x15	; 21
   14c70:	a9 2e       	mov	r10, r25
   14c72:	b1 2c       	mov	r11, r1
   14c74:	ac 0e       	add	r10, r28
   14c76:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14c78:	48 01       	movw	r8, r16
   14c7a:	0d ee       	ldi	r16, 0xED	; 237
   14c7c:	13 e2       	ldi	r17, 0x23	; 35
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14c7e:	d7 01       	movw	r26, r14
   14c80:	8c 91       	ld	r24, X
   14c82:	8d 8b       	std	Y+21, r24	; 0x15
   14c84:	11 96       	adiw	r26, 0x01	; 1
   14c86:	8c 91       	ld	r24, X
   14c88:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   14c8a:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   14c8c:	c5 01       	movw	r24, r10
   14c8e:	0e 94 58 28 	call	0x50b0	; 0x50b0 <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   14c92:	c5 01       	movw	r24, r10
   14c94:	0e 94 57 af 	call	0x15eae	; 0x15eae <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   14c98:	e1 99       	sbic	0x1c, 1	; 28
   14c9a:	fe cf       	rjmp	.-4      	; 0x14c98 <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14c9c:	df ba       	out	0x1f, r13	; 31
   14c9e:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   14ca0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   14ca2:	0f b6       	in	r0, 0x3f	; 63
   14ca4:	f8 94       	cli
   14ca6:	e2 9a       	sbi	0x1c, 2	; 28
   14ca8:	e1 9a       	sbi	0x1c, 1	; 28
   14caa:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14cac:	00 d0       	rcall	.+0      	; 0x14cae <SaveConfigParameter+0x374>
   14cae:	00 d0       	rcall	.+0      	; 0x14cb0 <SaveConfigParameter+0x376>
   14cb0:	00 d0       	rcall	.+0      	; 0x14cb2 <SaveConfigParameter+0x378>
   14cb2:	ed b7       	in	r30, 0x3d	; 61
   14cb4:	fe b7       	in	r31, 0x3e	; 62
   14cb6:	31 96       	adiw	r30, 0x01	; 1
   14cb8:	ad b7       	in	r26, 0x3d	; 61
   14cba:	be b7       	in	r27, 0x3e	; 62
   14cbc:	11 96       	adiw	r26, 0x01	; 1
   14cbe:	8c 92       	st	X, r8
   14cc0:	11 97       	sbiw	r26, 0x01	; 1
   14cc2:	12 96       	adiw	r26, 0x02	; 2
   14cc4:	9c 92       	st	X, r9
   14cc6:	13 83       	std	Z+3, r17	; 0x03
   14cc8:	02 83       	std	Z+2, r16	; 0x02
   14cca:	84 83       	std	Z+4, r24	; 0x04
   14ccc:	15 82       	std	Z+5, r1	; 0x05
   14cce:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
   14cd2:	e2 e0       	ldi	r30, 0x02	; 2
   14cd4:	f0 e0       	ldi	r31, 0x00	; 0
   14cd6:	ee 0e       	add	r14, r30
   14cd8:	ff 1e       	adc	r15, r31
   14cda:	08 94       	sec
   14cdc:	c1 1c       	adc	r12, r1
   14cde:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   14ce0:	8d b7       	in	r24, 0x3d	; 61
   14ce2:	9e b7       	in	r25, 0x3e	; 62
   14ce4:	06 96       	adiw	r24, 0x06	; 6
   14ce6:	0f b6       	in	r0, 0x3f	; 63
   14ce8:	f8 94       	cli
   14cea:	9e bf       	out	0x3e, r25	; 62
   14cec:	0f be       	out	0x3f, r0	; 63
   14cee:	8d bf       	out	0x3d, r24	; 61
   14cf0:	96 e6       	ldi	r25, 0x66	; 102
   14cf2:	e9 16       	cp	r14, r25
   14cf4:	9b e0       	ldi	r25, 0x0B	; 11
   14cf6:	f9 06       	cpc	r15, r25
   14cf8:	09 f0       	breq	.+2      	; 0x14cfc <SaveConfigParameter+0x3c2>
   14cfa:	c1 cf       	rjmp	.-126    	; 0x14c7e <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 uart_print(1,1,strSend); 
	 }    
	 uart_printf(1,1,PSTR("<OK>")); 
   14cfc:	81 e0       	ldi	r24, 0x01	; 1
   14cfe:	61 e0       	ldi	r22, 0x01	; 1
   14d00:	48 ee       	ldi	r20, 0xE8	; 232
   14d02:	53 e2       	ldi	r21, 0x23	; 35
   14d04:	0e 94 2c ae 	call	0x15c58	; 0x15c58 <uart_printf>
}
   14d08:	ca 5b       	subi	r28, 0xBA	; 186
   14d0a:	df 4f       	sbci	r29, 0xFF	; 255
   14d0c:	0f b6       	in	r0, 0x3f	; 63
   14d0e:	f8 94       	cli
   14d10:	de bf       	out	0x3e, r29	; 62
   14d12:	0f be       	out	0x3f, r0	; 63
   14d14:	cd bf       	out	0x3d, r28	; 61
   14d16:	cf 91       	pop	r28
   14d18:	df 91       	pop	r29
   14d1a:	1f 91       	pop	r17
   14d1c:	0f 91       	pop	r16
   14d1e:	ff 90       	pop	r15
   14d20:	ef 90       	pop	r14
   14d22:	df 90       	pop	r13
   14d24:	cf 90       	pop	r12
   14d26:	bf 90       	pop	r11
   14d28:	af 90       	pop	r10
   14d2a:	9f 90       	pop	r9
   14d2c:	8f 90       	pop	r8
   14d2e:	08 95       	ret

00014d30 <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
   14d30:	80 91 a0 02 	lds	r24, 0x02A0
   14d34:	81 30       	cpi	r24, 0x01	; 1
   14d36:	c1 f0       	breq	.+48     	; 0x14d68 <systemConfigProtocol+0x38>
   14d38:	81 30       	cpi	r24, 0x01	; 1
   14d3a:	18 f0       	brcs	.+6      	; 0x14d42 <systemConfigProtocol+0x12>
   14d3c:	82 30       	cpi	r24, 0x02	; 2
   14d3e:	e9 f4       	brne	.+58     	; 0x14d7a <systemConfigProtocol+0x4a>
   14d40:	18 c0       	rjmp	.+48     	; 0x14d72 <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
   14d42:	80 91 b0 01 	lds	r24, 0x01B0
   14d46:	81 30       	cpi	r24, 0x01	; 1
   14d48:	31 f0       	breq	.+12     	; 0x14d56 <systemConfigProtocol+0x26>
   14d4a:	82 30       	cpi	r24, 0x02	; 2
   14d4c:	51 f4       	brne	.+20     	; 0x14d62 <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
   14d4e:	10 92 b0 01 	sts	0x01B0, r1
			   stConfigProtocol=cpSendingParameter;
   14d52:	81 e0       	ldi	r24, 0x01	; 1
   14d54:	03 c0       	rjmp	.+6      	; 0x14d5c <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
   14d56:	10 92 b0 01 	sts	0x01B0, r1
			   stConfigProtocol=cpSavingParameter;
   14d5a:	82 e0       	ldi	r24, 0x02	; 2
   14d5c:	80 93 a0 02 	sts	0x02A0, r24
   14d60:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
   14d62:	10 92 b0 01 	sts	0x01B0, r1
   14d66:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
   14d68:	0e 94 83 a2 	call	0x14506	; 0x14506 <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
   14d6c:	10 92 a0 02 	sts	0x02A0, r1
   14d70:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
   14d72:	0e 94 9d a4 	call	0x1493a	; 0x1493a <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
   14d76:	10 92 a0 02 	sts	0x02A0, r1
   14d7a:	08 95       	ret

00014d7c <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   14d7c:	1f 93       	push	r17
	static char stMenuIdle=miInit,ButtonID=0;
	       char PrintStandaloneResult=PS_NONE;
	       char KeyPressed=0,KeyChar=0;
	       char lcdteks[20];

	switch(stMenuIdle){
   14d7e:	80 91 ac 02 	lds	r24, 0x02AC
   14d82:	e8 2f       	mov	r30, r24
   14d84:	f0 e0       	ldi	r31, 0x00	; 0
   14d86:	e9 31       	cpi	r30, 0x19	; 25
   14d88:	f1 05       	cpc	r31, r1
   14d8a:	08 f0       	brcs	.+2      	; 0x14d8e <FMenuIdle+0x12>
   14d8c:	7e c1       	rjmp	.+764    	; 0x1508a <FMenuIdle+0x30e>
   14d8e:	eb 5d       	subi	r30, 0xDB	; 219
   14d90:	fe 4f       	sbci	r31, 0xFE	; 254
   14d92:	ee 0f       	add	r30, r30
   14d94:	ff 1f       	adc	r31, r31
   14d96:	05 90       	lpm	r0, Z+
   14d98:	f4 91       	lpm	r31, Z+
   14d9a:	e0 2d       	mov	r30, r0
   14d9c:	09 94       	ijmp
	case miInit:
         DisplayScreenIdle();
   14d9e:	0e 94 4e 4b 	call	0x969c	; 0x969c <DisplayScreenIdle>
   14da2:	3a c1       	rjmp	.+628    	; 0x15018 <FMenuIdle+0x29c>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   14da4:	81 e0       	ldi	r24, 0x01	; 1
   14da6:	0e 94 1e ab 	call	0x1563c	; 0x1563c <_key_scan>
   14daa:	18 2f       	mov	r17, r24
		 KeyChar= _key_btn(KeyPressed);       
   14dac:	0e 94 7f aa 	call	0x154fe	; 0x154fe <_key_btn>

		 switch(KeyPressed){
   14db0:	1b 3b       	cpi	r17, 0xBB	; 187
   14db2:	09 f4       	brne	.+2      	; 0x14db6 <FMenuIdle+0x3a>
   14db4:	7a c0       	rjmp	.+244    	; 0x14eaa <FMenuIdle+0x12e>
   14db6:	1c 3b       	cpi	r17, 0xBC	; 188
   14db8:	70 f4       	brcc	.+28     	; 0x14dd6 <FMenuIdle+0x5a>
   14dba:	1b 37       	cpi	r17, 0x7B	; 123
   14dbc:	69 f1       	breq	.+90     	; 0x14e18 <FMenuIdle+0x9c>
   14dbe:	1c 37       	cpi	r17, 0x7C	; 124
   14dc0:	20 f4       	brcc	.+8      	; 0x14dca <FMenuIdle+0x4e>
   14dc2:	17 37       	cpi	r17, 0x77	; 119
   14dc4:	09 f0       	breq	.+2      	; 0x14dc8 <FMenuIdle+0x4c>
   14dc6:	61 c1       	rjmp	.+706    	; 0x1508a <FMenuIdle+0x30e>
   14dc8:	2e c0       	rjmp	.+92     	; 0x14e26 <FMenuIdle+0xaa>
   14dca:	1d 37       	cpi	r17, 0x7D	; 125
   14dcc:	e9 f0       	breq	.+58     	; 0x14e08 <FMenuIdle+0x8c>
   14dce:	1e 37       	cpi	r17, 0x7E	; 126
   14dd0:	09 f0       	breq	.+2      	; 0x14dd4 <FMenuIdle+0x58>
   14dd2:	5b c1       	rjmp	.+694    	; 0x1508a <FMenuIdle+0x30e>
   14dd4:	12 c0       	rjmp	.+36     	; 0x14dfa <FMenuIdle+0x7e>
   14dd6:	1d 3d       	cpi	r17, 0xDD	; 221
   14dd8:	09 f4       	brne	.+2      	; 0x14ddc <FMenuIdle+0x60>
   14dda:	4f c0       	rjmp	.+158    	; 0x14e7a <FMenuIdle+0xfe>
   14ddc:	1e 3d       	cpi	r17, 0xDE	; 222
   14dde:	38 f4       	brcc	.+14     	; 0x14dee <FMenuIdle+0x72>
   14de0:	1d 3b       	cpi	r17, 0xBD	; 189
   14de2:	09 f4       	brne	.+2      	; 0x14de6 <FMenuIdle+0x6a>
   14de4:	56 c0       	rjmp	.+172    	; 0x14e92 <FMenuIdle+0x116>
   14de6:	17 3d       	cpi	r17, 0xD7	; 215
   14de8:	09 f0       	breq	.+2      	; 0x14dec <FMenuIdle+0x70>
   14dea:	4f c1       	rjmp	.+670    	; 0x1508a <FMenuIdle+0x30e>
   14dec:	27 c0       	rjmp	.+78     	; 0x14e3c <FMenuIdle+0xc0>
   14dee:	1e 3d       	cpi	r17, 0xDE	; 222
   14df0:	61 f1       	breq	.+88     	; 0x14e4a <FMenuIdle+0xce>
   14df2:	1d 3e       	cpi	r17, 0xED	; 237
   14df4:	09 f0       	breq	.+2      	; 0x14df8 <FMenuIdle+0x7c>
   14df6:	49 c1       	rjmp	.+658    	; 0x1508a <FMenuIdle+0x30e>
   14df8:	34 c0       	rjmp	.+104    	; 0x14e62 <FMenuIdle+0xe6>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14dfa:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14dfc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14dfe:	92 e0       	ldi	r25, 0x02	; 2
   14e00:	90 93 bc 01 	sts	0x01BC, r25
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   14e04:	81 e0       	ldi	r24, 0x01	; 1
   14e06:	15 c0       	rjmp	.+42     	; 0x14e32 <FMenuIdle+0xb6>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14e08:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14e0a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14e0c:	82 e0       	ldi	r24, 0x02	; 2
   14e0e:	80 93 bc 01 	sts	0x01BC, r24
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   14e12:	80 93 ab 02 	sts	0x02AB, r24
   14e16:	37 c1       	rjmp	.+622    	; 0x15086 <FMenuIdle+0x30a>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14e18:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14e1a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14e1c:	92 e0       	ldi	r25, 0x02	; 2
   14e1e:	90 93 bc 01 	sts	0x01BC, r25
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   14e22:	83 e0       	ldi	r24, 0x03	; 3
   14e24:	06 c0       	rjmp	.+12     	; 0x14e32 <FMenuIdle+0xb6>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14e26:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14e28:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14e2a:	92 e0       	ldi	r25, 0x02	; 2
   14e2c:	90 93 bc 01 	sts	0x01BC, r25

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   14e30:	84 e0       	ldi	r24, 0x04	; 4
   14e32:	80 93 ab 02 	sts	0x02AB, r24
   14e36:	90 93 ac 02 	sts	0x02AC, r25
   14e3a:	27 c1       	rjmp	.+590    	; 0x1508a <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14e3c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14e3e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14e40:	82 e0       	ldi	r24, 0x02	; 2
   14e42:	80 93 bc 01 	sts	0x01BC, r24
		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   14e46:	8c e0       	ldi	r24, 0x0C	; 12
   14e48:	1e c1       	rjmp	.+572    	; 0x15086 <FMenuIdle+0x30a>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   14e4a:	80 91 00 01 	lds	r24, 0x0100
   14e4e:	81 30       	cpi	r24, 0x01	; 1
   14e50:	09 f0       	breq	.+2      	; 0x14e54 <FMenuIdle+0xd8>
   14e52:	1b c1       	rjmp	.+566    	; 0x1508a <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14e54:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14e56:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14e58:	82 e0       	ldi	r24, 0x02	; 2
   14e5a:	80 93 bc 01 	sts	0x01BC, r24
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   14e5e:	80 e1       	ldi	r24, 0x10	; 16
   14e60:	12 c1       	rjmp	.+548    	; 0x15086 <FMenuIdle+0x30a>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   14e62:	80 91 00 01 	lds	r24, 0x0100
   14e66:	81 30       	cpi	r24, 0x01	; 1
   14e68:	09 f0       	breq	.+2      	; 0x14e6c <FMenuIdle+0xf0>
   14e6a:	0f c1       	rjmp	.+542    	; 0x1508a <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14e6c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14e6e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14e70:	82 e0       	ldi	r24, 0x02	; 2
   14e72:	80 93 bc 01 	sts	0x01BC, r24
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   14e76:	82 e1       	ldi	r24, 0x12	; 18
   14e78:	06 c1       	rjmp	.+524    	; 0x15086 <FMenuIdle+0x30a>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   14e7a:	80 91 00 01 	lds	r24, 0x0100
   14e7e:	81 30       	cpi	r24, 0x01	; 1
   14e80:	09 f0       	breq	.+2      	; 0x14e84 <FMenuIdle+0x108>
   14e82:	03 c1       	rjmp	.+518    	; 0x1508a <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14e84:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14e86:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14e88:	82 e0       	ldi	r24, 0x02	; 2
   14e8a:	80 93 bc 01 	sts	0x01BC, r24
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   14e8e:	81 e1       	ldi	r24, 0x11	; 17
   14e90:	fa c0       	rjmp	.+500    	; 0x15086 <FMenuIdle+0x30a>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   14e92:	80 91 00 01 	lds	r24, 0x0100
   14e96:	81 30       	cpi	r24, 0x01	; 1
   14e98:	09 f0       	breq	.+2      	; 0x14e9c <FMenuIdle+0x120>
   14e9a:	f7 c0       	rjmp	.+494    	; 0x1508a <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14e9c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14e9e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14ea0:	82 e0       	ldi	r24, 0x02	; 2
   14ea2:	80 93 bc 01 	sts	0x01BC, r24
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   14ea6:	8f e0       	ldi	r24, 0x0F	; 15
   14ea8:	ee c0       	rjmp	.+476    	; 0x15086 <FMenuIdle+0x30a>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14eaa:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14eac:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14eae:	82 e0       	ldi	r24, 0x02	; 2
   14eb0:	80 93 bc 01 	sts	0x01BC, r24
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   14eb4:	8d e0       	ldi	r24, 0x0D	; 13
   14eb6:	e7 c0       	rjmp	.+462    	; 0x15086 <FMenuIdle+0x30a>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   14eb8:	00 d0       	rcall	.+0      	; 0x14eba <FMenuIdle+0x13e>
   14eba:	00 d0       	rcall	.+0      	; 0x14ebc <FMenuIdle+0x140>
   14ebc:	89 e8       	ldi	r24, 0x89	; 137
   14ebe:	9b e0       	ldi	r25, 0x0B	; 11
   14ec0:	ed b7       	in	r30, 0x3d	; 61
   14ec2:	fe b7       	in	r31, 0x3e	; 62
   14ec4:	92 83       	std	Z+2, r25	; 0x02
   14ec6:	81 83       	std	Z+1, r24	; 0x01
   14ec8:	81 e1       	ldi	r24, 0x11	; 17
   14eca:	95 e2       	ldi	r25, 0x25	; 37
   14ecc:	94 83       	std	Z+4, r25	; 0x04
   14ece:	83 83       	std	Z+3, r24	; 0x03
   14ed0:	0e 94 c5 af 	call	0x15f8a	; 0x15f8a <sprintf_P>
	     sendMessage56();
   14ed4:	0f 90       	pop	r0
   14ed6:	0f 90       	pop	r0
   14ed8:	0f 90       	pop	r0
   14eda:	0f 90       	pop	r0
   14edc:	0e 94 ae 83 	call	0x1075c	; 0x1075c <sendMessage56>
         stMenuIdle=miDisplayProses;
   14ee0:	82 e0       	ldi	r24, 0x02	; 2
   14ee2:	d1 c0       	rjmp	.+418    	; 0x15086 <FMenuIdle+0x30a>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   14ee4:	80 91 b2 01 	lds	r24, 0x01B2
   14ee8:	88 23       	and	r24, r24
   14eea:	09 f0       	breq	.+2      	; 0x14eee <FMenuIdle+0x172>
   14eec:	95 c0       	rjmp	.+298    	; 0x15018 <FMenuIdle+0x29c>
		     lcd_printf(3,1,PSTR("SedangProses"));
   14eee:	83 e0       	ldi	r24, 0x03	; 3
   14ef0:	61 e0       	ldi	r22, 0x01	; 1
   14ef2:	44 e0       	ldi	r20, 0x04	; 4
   14ef4:	55 e2       	ldi	r21, 0x25	; 37
   14ef6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	         TimDisplay=0;
   14efa:	10 92 92 01 	sts	0x0192, r1
			 stMenuIdle=miWaitProses;
   14efe:	83 e0       	ldi	r24, 0x03	; 3
   14f00:	c2 c0       	rjmp	.+388    	; 0x15086 <FMenuIdle+0x30a>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   14f02:	80 91 92 01 	lds	r24, 0x0192
   14f06:	82 30       	cpi	r24, 0x02	; 2
   14f08:	08 f4       	brcc	.+2      	; 0x14f0c <FMenuIdle+0x190>
   14f0a:	bf c0       	rjmp	.+382    	; 0x1508a <FMenuIdle+0x30e>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   14f0c:	80 91 00 01 	lds	r24, 0x0100
   14f10:	81 30       	cpi	r24, 0x01	; 1
   14f12:	11 f4       	brne	.+4      	; 0x14f18 <FMenuIdle+0x19c>
   14f14:	84 e0       	ldi	r24, 0x04	; 4
   14f16:	b7 c0       	rjmp	.+366    	; 0x15086 <FMenuIdle+0x30a>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   14f18:	82 30       	cpi	r24, 0x02	; 2
   14f1a:	09 f0       	breq	.+2      	; 0x14f1e <FMenuIdle+0x1a2>
   14f1c:	b6 c0       	rjmp	.+364    	; 0x1508a <FMenuIdle+0x30e>
   14f1e:	87 e0       	ldi	r24, 0x07	; 7
   14f20:	b2 c0       	rjmp	.+356    	; 0x15086 <FMenuIdle+0x30a>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   14f22:	80 91 ab 02 	lds	r24, 0x02AB
   14f26:	60 e0       	ldi	r22, 0x00	; 0
   14f28:	0e 94 36 24 	call	0x486c	; 0x486c <PrintStandalone>
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   14f2c:	81 31       	cpi	r24, 0x11	; 17
   14f2e:	09 f4       	brne	.+2      	; 0x14f32 <FMenuIdle+0x1b6>
   14f30:	a9 c0       	rjmp	.+338    	; 0x15084 <FMenuIdle+0x308>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   14f32:	82 31       	cpi	r24, 0x12	; 18
   14f34:	09 f0       	breq	.+2      	; 0x14f38 <FMenuIdle+0x1bc>
   14f36:	a9 c0       	rjmp	.+338    	; 0x1508a <FMenuIdle+0x30e>
   14f38:	88 e0       	ldi	r24, 0x08	; 8
   14f3a:	a5 c0       	rjmp	.+330    	; 0x15086 <FMenuIdle+0x30a>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   14f3c:	83 e0       	ldi	r24, 0x03	; 3
   14f3e:	61 e0       	ldi	r22, 0x01	; 1
   14f40:	4f ee       	ldi	r20, 0xEF	; 239
   14f42:	54 e2       	ldi	r21, 0x24	; 36
   14f44:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
         TimDisplay=0;
   14f48:	10 92 92 01 	sts	0x0192, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   14f4c:	89 e0       	ldi	r24, 0x09	; 9
   14f4e:	9b c0       	rjmp	.+310    	; 0x15086 <FMenuIdle+0x30a>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   14f50:	80 91 92 01 	lds	r24, 0x0192
   14f54:	82 30       	cpi	r24, 0x02	; 2
   14f56:	08 f4       	brcc	.+2      	; 0x14f5a <FMenuIdle+0x1de>
   14f58:	98 c0       	rjmp	.+304    	; 0x1508a <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   14f5a:	83 e0       	ldi	r24, 0x03	; 3
   14f5c:	61 e0       	ldi	r22, 0x01	; 1
   14f5e:	4a ed       	ldi	r20, 0xDA	; 218
   14f60:	54 e2       	ldi	r21, 0x24	; 36
   14f62:	32 c0       	rjmp	.+100    	; 0x14fc8 <FMenuIdle+0x24c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   14f64:	83 e0       	ldi	r24, 0x03	; 3
   14f66:	61 e0       	ldi	r22, 0x01	; 1
   14f68:	45 ec       	ldi	r20, 0xC5	; 197
   14f6a:	54 e2       	ldi	r21, 0x24	; 36
   14f6c:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	     sendMessage98(ButtonID);
   14f70:	80 91 ab 02 	lds	r24, 0x02AB
   14f74:	0e 94 43 81 	call	0x10286	; 0x10286 <sendMessage98>
		 ProcTimeOut=0;
   14f78:	10 92 bb 01 	sts	0x01BB, r1
		 stMenuIdle=miWaitPlease;
   14f7c:	85 e0       	ldi	r24, 0x05	; 5
   14f7e:	83 c0       	rjmp	.+262    	; 0x15086 <FMenuIdle+0x30a>
	     break;
    case miWaitPlease:	     
         if (ProcTimeOut>TIM_NO_RESPONSE){
   14f80:	80 91 bb 01 	lds	r24, 0x01BB
   14f84:	8f 30       	cpi	r24, 0x0F	; 15
   14f86:	58 f0       	brcs	.+22     	; 0x14f9e <FMenuIdle+0x222>
	         lcd_printf(3,1,PSTR("No Response..       "));
   14f88:	83 e0       	ldi	r24, 0x03	; 3
   14f8a:	61 e0       	ldi	r22, 0x01	; 1
   14f8c:	40 eb       	ldi	r20, 0xB0	; 176
   14f8e:	54 e2       	ldi	r21, 0x24	; 36
   14f90:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		     stMenuIdle=miNoResponse;
   14f94:	86 e0       	ldi	r24, 0x06	; 6
   14f96:	80 93 ac 02 	sts	0x02AC, r24
			 TimDisplay=0;		 
   14f9a:	10 92 92 01 	sts	0x0192, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   14f9e:	80 91 9f 01 	lds	r24, 0x019F
   14fa2:	81 30       	cpi	r24, 0x01	; 1
   14fa4:	29 f0       	breq	.+10     	; 0x14fb0 <FMenuIdle+0x234>
   14fa6:	80 91 9e 01 	lds	r24, 0x019E
   14faa:	81 30       	cpi	r24, 0x01	; 1
   14fac:	09 f0       	breq	.+2      	; 0x14fb0 <FMenuIdle+0x234>
   14fae:	6d c0       	rjmp	.+218    	; 0x1508a <FMenuIdle+0x30e>
		     ClearMem(strOdometer);
   14fb0:	83 ec       	ldi	r24, 0xC3	; 195
   14fb2:	93 e0       	ldi	r25, 0x03	; 3
   14fb4:	0e 94 19 aa 	call	0x15432	; 0x15432 <ClearMem>
		     ClearMem(strLicPlate);
   14fb8:	8a ef       	ldi	r24, 0xFA	; 250
   14fba:	98 e0       	ldi	r25, 0x08	; 8
   14fbc:	0e 94 19 aa 	call	0x15432	; 0x15432 <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   14fc0:	83 e0       	ldi	r24, 0x03	; 3
   14fc2:	61 e0       	ldi	r22, 0x01	; 1
   14fc4:	4b e9       	ldi	r20, 0x9B	; 155
   14fc6:	54 e2       	ldi	r21, 0x24	; 36
   14fc8:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		     stMenuIdle=miWaitReady;
   14fcc:	8a e0       	ldi	r24, 0x0A	; 10
   14fce:	80 93 ac 02 	sts	0x02AC, r24
			 TimDisplay=0;
   14fd2:	10 92 92 01 	sts	0x0192, r1
   14fd6:	59 c0       	rjmp	.+178    	; 0x1508a <FMenuIdle+0x30e>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   14fd8:	80 91 92 01 	lds	r24, 0x0192
   14fdc:	82 30       	cpi	r24, 0x02	; 2
   14fde:	08 f4       	brcc	.+2      	; 0x14fe2 <FMenuIdle+0x266>
   14fe0:	54 c0       	rjmp	.+168    	; 0x1508a <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   14fe2:	83 e0       	ldi	r24, 0x03	; 3
   14fe4:	61 e0       	ldi	r22, 0x01	; 1
   14fe6:	46 e8       	ldi	r20, 0x86	; 134
   14fe8:	54 e2       	ldi	r21, 0x24	; 36
   14fea:	ee cf       	rjmp	.-36     	; 0x14fc8 <FMenuIdle+0x24c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   14fec:	80 91 92 01 	lds	r24, 0x0192
   14ff0:	82 30       	cpi	r24, 0x02	; 2
   14ff2:	08 f4       	brcc	.+2      	; 0x14ff6 <FMenuIdle+0x27a>
   14ff4:	4a c0       	rjmp	.+148    	; 0x1508a <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("                "));
   14ff6:	83 e0       	ldi	r24, 0x03	; 3
   14ff8:	61 e0       	ldi	r22, 0x01	; 1
   14ffa:	45 e7       	ldi	r20, 0x75	; 117
   14ffc:	54 e2       	ldi	r21, 0x24	; 36
   14ffe:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		     stMenuIdle=miReady;
   15002:	8b e0       	ldi	r24, 0x0B	; 11
   15004:	e4 cf       	rjmp	.-56     	; 0x14fce <FMenuIdle+0x252>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     DisplayScreenIdle();
   15006:	0e 94 4e 4b 	call	0x969c	; 0x969c <DisplayScreenIdle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   1500a:	80 91 00 01 	lds	r24, 0x0100
   1500e:	82 30       	cpi	r24, 0x02	; 2
   15010:	19 f4       	brne	.+6      	; 0x15018 <FMenuIdle+0x29c>
   15012:	81 e0       	ldi	r24, 0x01	; 1
   15014:	80 93 01 01 	sts	0x0101, r24
		 stMenuIdle=miScan;
   15018:	81 e0       	ldi	r24, 0x01	; 1
   1501a:	35 c0       	rjmp	.+106    	; 0x15086 <FMenuIdle+0x30a>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   1501c:	0e 94 6a 81 	call	0x102d4	; 0x102d4 <FMenuTicket>
   15020:	2f c0       	rjmp	.+94     	; 0x15080 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   15022:	0e 94 6f 92 	call	0x124de	; 0x124de <FMenuAuthorization>
   15026:	2c c0       	rjmp	.+88     	; 0x15080 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   15028:	0e 94 b2 83 	call	0x10764	; 0x10764 <FMenuLocalAccount>
   1502c:	29 c0       	rjmp	.+82     	; 0x15080 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   1502e:	0e 94 7f 8c 	call	0x118fe	; 0x118fe <FMenuChangeMOP>
   15032:	26 c0       	rjmp	.+76     	; 0x15080 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   15034:	0e 94 c1 82 	call	0x10582	; 0x10582 <FMenuEDCTransaction>
   15038:	23 c0       	rjmp	.+70     	; 0x15080 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   1503a:	0e 94 d9 92 	call	0x125b2	; 0x125b2 <FMenuLoyalty>
   1503e:	20 c0       	rjmp	.+64     	; 0x15080 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   15040:	0e 94 bb 90 	call	0x12176	; 0x12176 <FMenuReprint>
   15044:	1d c0       	rjmp	.+58     	; 0x15080 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   15046:	0e 94 71 4a 	call	0x94e2	; 0x94e2 <FViewFreeMessage>
   1504a:	1a c0       	rjmp	.+52     	; 0x15080 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   1504c:	83 e0       	ldi	r24, 0x03	; 3
   1504e:	61 e0       	ldi	r22, 0x01	; 1
   15050:	40 e6       	ldi	r20, 0x60	; 96
   15052:	54 e2       	ldi	r21, 0x24	; 36
   15054:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   15058:	80 e0       	ldi	r24, 0x00	; 0
   1505a:	0e 94 1f 2c 	call	0x583e	; 0x583e <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   1505e:	81 e0       	ldi	r24, 0x01	; 1
   15060:	0e 94 1f 2c 	call	0x583e	; 0x583e <ResetTotalizer>
   15064:	0f c0       	rjmp	.+30     	; 0x15084 <FMenuIdle+0x308>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   15066:	83 e0       	ldi	r24, 0x03	; 3
   15068:	61 e0       	ldi	r22, 0x01	; 1
   1506a:	4e e4       	ldi	r20, 0x4E	; 78
   1506c:	54 e2       	ldi	r21, 0x24	; 36
   1506e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   15072:	85 e0       	ldi	r24, 0x05	; 5
   15074:	62 e1       	ldi	r22, 0x12	; 18
   15076:	0e 94 4c 63 	call	0xc698	; 0xc698 <SendSlaveCommand>
   1507a:	04 c0       	rjmp	.+8      	; 0x15084 <FMenuIdle+0x308>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   1507c:	0e 94 ab 4a 	call	0x9556	; 0x9556 <FTestChar>
   15080:	81 30       	cpi	r24, 0x01	; 1
   15082:	19 f4       	brne	.+6      	; 0x1508a <FMenuIdle+0x30e>
         stMenuIdle=miReady;
   15084:	8b e0       	ldi	r24, 0x0B	; 11
   15086:	80 93 ac 02 	sts	0x02AC, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   1508a:	80 91 a1 01 	lds	r24, 0x01A1
   1508e:	81 30       	cpi	r24, 0x01	; 1
   15090:	21 f4       	brne	.+8      	; 0x1509a <FMenuIdle+0x31e>
		    IsMessage21=False;
   15092:	10 92 a1 01 	sts	0x01A1, r1
			procMessage21();
   15096:	0e 94 03 21 	call	0x4206	; 0x4206 <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   1509a:	80 91 9e 01 	lds	r24, 0x019E
   1509e:	81 30       	cpi	r24, 0x01	; 1
   150a0:	91 f4       	brne	.+36     	; 0x150c6 <FMenuIdle+0x34a>
		    IsMessage00=False;
   150a2:	10 92 9e 01 	sts	0x019E, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   150a6:	20 91 1d 09 	lds	r18, 0x091D
   150aa:	21 30       	cpi	r18, 0x01	; 1
   150ac:	61 f4       	brne	.+24     	; 0x150c6 <FMenuIdle+0x34a>
   150ae:	80 91 8b 01 	lds	r24, 0x018B
   150b2:	90 91 8c 01 	lds	r25, 0x018C
   150b6:	8f 97       	sbiw	r24, 0x2f	; 47
   150b8:	31 f4       	brne	.+12     	; 0x150c6 <FMenuIdle+0x34a>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   150ba:	80 91 42 09 	lds	r24, 0x0942
   150be:	84 33       	cpi	r24, 0x34	; 52
   150c0:	11 f4       	brne	.+4      	; 0x150c6 <FMenuIdle+0x34a>
			    IsNoTransaction=True;
   150c2:	20 93 ab 01 	sts	0x01AB, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   150c6:	80 91 97 01 	lds	r24, 0x0197
   150ca:	81 30       	cpi	r24, 0x01	; 1
   150cc:	21 f4       	brne	.+8      	; 0x150d6 <FMenuIdle+0x35a>
		    IsSendMessageEDC=False;
   150ce:	10 92 97 01 	sts	0x0197, r1
			SendEDCMessage();
   150d2:	0e 94 c0 62 	call	0xc580	; 0xc580 <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   150d6:	80 91 99 01 	lds	r24, 0x0199
   150da:	81 30       	cpi	r24, 0x01	; 1
   150dc:	21 f4       	brne	.+8      	; 0x150e6 <FMenuIdle+0x36a>
		    IsEDCApproved=False;
   150de:	10 92 99 01 	sts	0x0199, r1
            sendMessage92();
   150e2:	0e 94 b9 82 	call	0x10572	; 0x10572 <sendMessage92>
		}
		if (IsVoidTransaction==True){
   150e6:	80 91 9b 01 	lds	r24, 0x019B
   150ea:	81 30       	cpi	r24, 0x01	; 1
   150ec:	21 f4       	brne	.+8      	; 0x150f6 <FMenuIdle+0x37a>
		    IsVoidTransaction=False;
   150ee:	10 92 9b 01 	sts	0x019B, r1
            sendMessage94();
   150f2:	0e 94 b5 82 	call	0x1056a	; 0x1056a <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   150f6:	10 91 9f 01 	lds	r17, 0x019F
   150fa:	11 30       	cpi	r17, 0x01	; 1
   150fc:	31 f4       	brne	.+12     	; 0x1510a <FMenuIdle+0x38e>
	        IsMessage99=False;
   150fe:	10 92 9f 01 	sts	0x019F, r1
		    procMessage99();
   15102:	0e 94 32 45 	call	0x8a64	; 0x8a64 <procMessage99>
		    IsPrinting=True;
   15106:	10 93 ac 01 	sts	0x01AC, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   1510a:	80 91 ab 01 	lds	r24, 0x01AB
   1510e:	81 30       	cpi	r24, 0x01	; 1
   15110:	41 f4       	brne	.+16     	; 0x15122 <FMenuIdle+0x3a6>
			IsNoTransaction=False;
   15112:	10 92 ab 01 	sts	0x01AB, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   15116:	83 e0       	ldi	r24, 0x03	; 3
   15118:	61 e0       	ldi	r22, 0x01	; 1
   1511a:	49 e3       	ldi	r20, 0x39	; 57
   1511c:	54 e2       	ldi	r21, 0x24	; 36
   1511e:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   15122:	80 91 ac 02 	lds	r24, 0x02AC
   15126:	81 30       	cpi	r24, 0x01	; 1
   15128:	11 f4       	brne	.+4      	; 0x1512e <FMenuIdle+0x3b2>
		    DisplayIdle();			
   1512a:	0e 94 54 61 	call	0xc2a8	; 0xc2a8 <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   1512e:	80 91 ac 02 	lds	r24, 0x02AC
   15132:	81 30       	cpi	r24, 0x01	; 1
   15134:	59 f4       	brne	.+22     	; 0x1514c <FMenuIdle+0x3d0>
		    if (IsMessage09==True){
   15136:	80 91 a3 01 	lds	r24, 0x01A3
   1513a:	81 30       	cpi	r24, 0x01	; 1
   1513c:	39 f4       	brne	.+14     	; 0x1514c <FMenuIdle+0x3d0>
			    IsMessage09=False;
   1513e:	10 92 a3 01 	sts	0x01A3, r1
				procMessage09();
   15142:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   15146:	83 e1       	ldi	r24, 0x13	; 19
   15148:	80 93 ac 02 	sts	0x02AC, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   1514c:	80 91 ac 02 	lds	r24, 0x02AC
   15150:	81 30       	cpi	r24, 0x01	; 1
   15152:	71 f4       	brne	.+28     	; 0x15170 <FMenuIdle+0x3f4>
   15154:	80 91 98 01 	lds	r24, 0x0198
   15158:	81 30       	cpi	r24, 0x01	; 1
   1515a:	51 f4       	brne	.+20     	; 0x15170 <FMenuIdle+0x3f4>
		    IsRFIDDetected=False;
   1515c:	10 92 98 01 	sts	0x0198, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15160:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15162:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15164:	82 e0       	ldi	r24, 0x02	; 2
   15166:	80 93 bc 01 	sts	0x01BC, r24

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
		    IsRFIDDetected=False;
		    system_beep(2);           
			stMenuIdle=miRunLocalAccount;
   1516a:	8e e0       	ldi	r24, 0x0E	; 14
   1516c:	80 93 ac 02 	sts	0x02AC, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   15170:	10 91 a6 01 	lds	r17, 0x01A6
   15174:	11 30       	cpi	r17, 0x01	; 1
   15176:	41 f4       	brne	.+16     	; 0x15188 <FMenuIdle+0x40c>
		    IsMessage81=False;
   15178:	10 92 a6 01 	sts	0x01A6, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   1517c:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <procMessage81>
   15180:	80 93 b5 01 	sts	0x01B5, r24
			IsFreePrinting=True;
   15184:	10 93 a8 01 	sts	0x01A8, r17
         }

    //SystemService
      systemGenerateReport();
   15188:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <systemGenerateReport>
      systemPrinting();
   1518c:	0e 94 7e a2 	call	0x144fc	; 0x144fc <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   15190:	0e 94 98 a6 	call	0x14d30	; 0x14d30 <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   15194:	1f 91       	pop	r17
   15196:	08 95       	ret

00015198 <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   15198:	98 2f       	mov	r25, r24
   1519a:	90 7f       	andi	r25, 0xF0	; 240
   1519c:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   1519e:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   151a0:	a9 9a       	sbi	0x15, 1	; 21
   151a2:	49 e9       	ldi	r20, 0x99	; 153
   151a4:	59 e3       	ldi	r21, 0x39	; 57
   151a6:	fa 01       	movw	r30, r20
   151a8:	31 97       	sbiw	r30, 0x01	; 1
   151aa:	f1 f7       	brne	.-4      	; 0x151a8 <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   151ac:	a9 98       	cbi	0x15, 1	; 21
   151ae:	fa 01       	movw	r30, r20
   151b0:	31 97       	sbiw	r30, 0x01	; 1
   151b2:	f1 f7       	brne	.-4      	; 0x151b0 <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   151b4:	28 2f       	mov	r18, r24
   151b6:	30 e0       	ldi	r19, 0x00	; 0
   151b8:	94 e0       	ldi	r25, 0x04	; 4
   151ba:	22 0f       	add	r18, r18
   151bc:	33 1f       	adc	r19, r19
   151be:	9a 95       	dec	r25
   151c0:	e1 f7       	brne	.-8      	; 0x151ba <lcd_command+0x22>
   151c2:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   151c4:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   151c6:	a9 9a       	sbi	0x15, 1	; 21
   151c8:	fa 01       	movw	r30, r20
   151ca:	31 97       	sbiw	r30, 0x01	; 1
   151cc:	f1 f7       	brne	.-4      	; 0x151ca <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   151ce:	a9 98       	cbi	0x15, 1	; 21
   151d0:	fa 01       	movw	r30, r20
   151d2:	31 97       	sbiw	r30, 0x01	; 1
   151d4:	f1 f7       	brne	.-4      	; 0x151d2 <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   151d6:	fa 01       	movw	r30, r20
   151d8:	31 97       	sbiw	r30, 0x01	; 1
   151da:	f1 f7       	brne	.-4      	; 0x151d8 <lcd_command+0x40>
   151dc:	81 30       	cpi	r24, 0x01	; 1
   151de:	49 f4       	brne	.+18     	; 0x151f2 <lcd_command+0x5a>
   151e0:	84 ef       	ldi	r24, 0xF4	; 244
   151e2:	91 e0       	ldi	r25, 0x01	; 1
   151e4:	20 e7       	ldi	r18, 0x70	; 112
   151e6:	31 e0       	ldi	r19, 0x01	; 1
   151e8:	f9 01       	movw	r30, r18
   151ea:	31 97       	sbiw	r30, 0x01	; 1
   151ec:	f1 f7       	brne	.-4      	; 0x151ea <lcd_command+0x52>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   151ee:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   151f0:	d9 f7       	brne	.-10     	; 0x151e8 <lcd_command+0x50>
   151f2:	08 95       	ret

000151f4 <lcd_init>:
   151f4:	80 e0       	ldi	r24, 0x00	; 0
   151f6:	98 ed       	ldi	r25, 0xD8	; 216
   151f8:	01 97       	sbiw	r24, 0x01	; 1
   151fa:	f1 f7       	brne	.-4      	; 0x151f8 <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   151fc:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   151fe:	84 b3       	in	r24, 0x14	; 20
   15200:	80 6f       	ori	r24, 0xF0	; 240
   15202:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   15204:	84 b3       	in	r24, 0x14	; 20
   15206:	8e 60       	ori	r24, 0x0E	; 14
   15208:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   1520a:	20 e3       	ldi	r18, 0x30	; 48
   1520c:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   1520e:	a9 9a       	sbi	0x15, 1	; 21
   15210:	89 e9       	ldi	r24, 0x99	; 153
   15212:	99 e3       	ldi	r25, 0x39	; 57
   15214:	fc 01       	movw	r30, r24
   15216:	31 97       	sbiw	r30, 0x01	; 1
   15218:	f1 f7       	brne	.-4      	; 0x15216 <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1521a:	a9 98       	cbi	0x15, 1	; 21
   1521c:	fc 01       	movw	r30, r24
   1521e:	31 97       	sbiw	r30, 0x01	; 1
   15220:	f1 f7       	brne	.-4      	; 0x1521e <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15222:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15224:	a9 9a       	sbi	0x15, 1	; 21
   15226:	fc 01       	movw	r30, r24
   15228:	31 97       	sbiw	r30, 0x01	; 1
   1522a:	f1 f7       	brne	.-4      	; 0x15228 <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1522c:	a9 98       	cbi	0x15, 1	; 21
   1522e:	fc 01       	movw	r30, r24
   15230:	31 97       	sbiw	r30, 0x01	; 1
   15232:	f1 f7       	brne	.-4      	; 0x15230 <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15234:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15236:	a9 9a       	sbi	0x15, 1	; 21
   15238:	fc 01       	movw	r30, r24
   1523a:	31 97       	sbiw	r30, 0x01	; 1
   1523c:	f1 f7       	brne	.-4      	; 0x1523a <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1523e:	a9 98       	cbi	0x15, 1	; 21
   15240:	fc 01       	movw	r30, r24
   15242:	31 97       	sbiw	r30, 0x01	; 1
   15244:	f1 f7       	brne	.-4      	; 0x15242 <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   15246:	20 e2       	ldi	r18, 0x20	; 32
   15248:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   1524a:	a9 9a       	sbi	0x15, 1	; 21
   1524c:	fc 01       	movw	r30, r24
   1524e:	31 97       	sbiw	r30, 0x01	; 1
   15250:	f1 f7       	brne	.-4      	; 0x1524e <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15252:	a9 98       	cbi	0x15, 1	; 21
   15254:	01 97       	sbiw	r24, 0x01	; 1
   15256:	f1 f7       	brne	.-4      	; 0x15254 <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   15258:	81 e0       	ldi	r24, 0x01	; 1
   1525a:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   1525e:	e4 e6       	ldi	r30, 0x64	; 100
   15260:	f0 e0       	ldi	r31, 0x00	; 0
   15262:	80 81       	ld	r24, Z
   15264:	82 60       	ori	r24, 0x02	; 2
   15266:	80 83       	st	Z, r24

	lcd_command(0x28);
   15268:	88 e2       	ldi	r24, 0x28	; 40
   1526a:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
	lcd_command(0x0c);
   1526e:	8c e0       	ldi	r24, 0x0C	; 12
   15270:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
	lcd_command(0x06);
   15274:	86 e0       	ldi	r24, 0x06	; 6
   15276:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
}
   1527a:	08 95       	ret

0001527c <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   1527c:	28 2f       	mov	r18, r24
   1527e:	20 7f       	andi	r18, 0xF0	; 240
   15280:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15282:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15284:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   15286:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   15288:	90 e0       	ldi	r25, 0x00	; 0
   1528a:	24 e0       	ldi	r18, 0x04	; 4
   1528c:	88 0f       	add	r24, r24
   1528e:	99 1f       	adc	r25, r25
   15290:	2a 95       	dec	r18
   15292:	e1 f7       	brne	.-8      	; 0x1528c <_lcd+0x10>
   15294:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15296:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15298:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   1529a:	a9 98       	cbi	0x15, 1	; 21
   1529c:	89 e9       	ldi	r24, 0x99	; 153
   1529e:	99 e3       	ldi	r25, 0x39	; 57
   152a0:	01 97       	sbiw	r24, 0x01	; 1
   152a2:	f1 f7       	brne	.-4      	; 0x152a0 <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   152a4:	86 e6       	ldi	r24, 0x66	; 102
   152a6:	9e e0       	ldi	r25, 0x0E	; 14
   152a8:	01 97       	sbiw	r24, 0x01	; 1
   152aa:	f1 f7       	brne	.-4      	; 0x152a8 <_lcd+0x2c>
   152ac:	08 95       	ret

000152ae <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   152ae:	cf 93       	push	r28
   152b0:	df 93       	push	r29
   152b2:	ec 01       	movw	r28, r24
   152b4:	03 c0       	rjmp	.+6      	; 0x152bc <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   152b6:	21 96       	adiw	r28, 0x01	; 1
   152b8:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   152bc:	88 81       	ld	r24, Y
   152be:	88 23       	and	r24, r24
   152c0:	d1 f7       	brne	.-12     	; 0x152b6 <lcd_string+0x8>
		_lcd(*__string++);
}
   152c2:	df 91       	pop	r29
   152c4:	cf 91       	pop	r28
   152c6:	08 95       	ret

000152c8 <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   152c8:	82 30       	cpi	r24, 0x02	; 2
   152ca:	69 f0       	breq	.+26     	; 0x152e6 <lcd_xy+0x1e>
   152cc:	83 30       	cpi	r24, 0x03	; 3
   152ce:	18 f4       	brcc	.+6      	; 0x152d6 <lcd_xy+0xe>
   152d0:	81 30       	cpi	r24, 0x01	; 1
   152d2:	a9 f4       	brne	.+42     	; 0x152fe <lcd_xy+0x36>
   152d4:	05 c0       	rjmp	.+10     	; 0x152e0 <lcd_xy+0x18>
   152d6:	83 30       	cpi	r24, 0x03	; 3
   152d8:	49 f0       	breq	.+18     	; 0x152ec <lcd_xy+0x24>
   152da:	84 30       	cpi	r24, 0x04	; 4
   152dc:	81 f4       	brne	.+32     	; 0x152fe <lcd_xy+0x36>
   152de:	0b c0       	rjmp	.+22     	; 0x152f6 <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   152e0:	86 2f       	mov	r24, r22
   152e2:	81 58       	subi	r24, 0x81	; 129
   152e4:	05 c0       	rjmp	.+10     	; 0x152f0 <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   152e6:	86 2f       	mov	r24, r22
   152e8:	81 54       	subi	r24, 0x41	; 65
   152ea:	02 c0       	rjmp	.+4      	; 0x152f0 <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   152ec:	86 2f       	mov	r24, r22
   152ee:	8d 56       	subi	r24, 0x6D	; 109
   152f0:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
   152f4:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   152f6:	86 2f       	mov	r24, r22
   152f8:	8d 52       	subi	r24, 0x2D	; 45
   152fa:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
   152fe:	08 95       	ret

00015300 <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   15300:	df 92       	push	r13
   15302:	ef 92       	push	r14
   15304:	ff 92       	push	r15
   15306:	0f 93       	push	r16
   15308:	1f 93       	push	r17
   1530a:	cf 93       	push	r28
   1530c:	df 93       	push	r29
   1530e:	06 2f       	mov	r16, r22
   15310:	d4 2e       	mov	r13, r20
   15312:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   15314:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
   15318:	2d 2d       	mov	r18, r13
   1531a:	31 2f       	mov	r19, r17
   1531c:	c9 01       	movw	r24, r18
   1531e:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15320:	34 e1       	ldi	r19, 0x14	; 20
   15322:	e3 2e       	mov	r14, r19
   15324:	f1 2c       	mov	r15, r1
   15326:	e0 1a       	sub	r14, r16
   15328:	f1 08       	sbc	r15, r1
   1532a:	04 c0       	rjmp	.+8      	; 0x15334 <lcd_print+0x34>
		_lcd(*__string);__string++;
   1532c:	82 2f       	mov	r24, r18
   1532e:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
   15332:	21 96       	adiw	r28, 0x01	; 1
   15334:	9e 01       	movw	r18, r28
   15336:	2d 19       	sub	r18, r13
   15338:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   1533a:	28 81       	ld	r18, Y
   1533c:	22 23       	and	r18, r18
   1533e:	21 f0       	breq	.+8      	; 0x15348 <lcd_print+0x48>
   15340:	90 e0       	ldi	r25, 0x00	; 0
   15342:	e8 16       	cp	r14, r24
   15344:	f9 06       	cpc	r15, r25
   15346:	94 f7       	brge	.-28     	; 0x1532c <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   15348:	df 91       	pop	r29
   1534a:	cf 91       	pop	r28
   1534c:	1f 91       	pop	r17
   1534e:	0f 91       	pop	r16
   15350:	ff 90       	pop	r15
   15352:	ef 90       	pop	r14
   15354:	df 90       	pop	r13
   15356:	08 95       	ret

00015358 <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   15358:	df 92       	push	r13
   1535a:	ef 92       	push	r14
   1535c:	ff 92       	push	r15
   1535e:	0f 93       	push	r16
   15360:	1f 93       	push	r17
   15362:	cf 93       	push	r28
   15364:	df 93       	push	r29
   15366:	06 2f       	mov	r16, r22
   15368:	d4 2e       	mov	r13, r20
   1536a:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   1536c:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
   15370:	8d 2d       	mov	r24, r13
   15372:	91 2f       	mov	r25, r17
   15374:	fc 01       	movw	r30, r24
   15376:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15378:	44 e1       	ldi	r20, 0x14	; 20
   1537a:	e4 2e       	mov	r14, r20
   1537c:	f1 2c       	mov	r15, r1
   1537e:	e0 1a       	sub	r14, r16
   15380:	f1 08       	sbc	r15, r1
   15382:	04 c0       	rjmp	.+8      	; 0x1538c <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   15384:	82 2f       	mov	r24, r18
   15386:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
		__string++;
   1538a:	21 96       	adiw	r28, 0x01	; 1
   1538c:	9e 01       	movw	r18, r28
   1538e:	2d 19       	sub	r18, r13
   15390:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15392:	fe 01       	movw	r30, r28
   15394:	24 91       	lpm	r18, Z+
   15396:	22 23       	and	r18, r18
   15398:	21 f0       	breq	.+8      	; 0x153a2 <lcd_printf+0x4a>
   1539a:	90 e0       	ldi	r25, 0x00	; 0
   1539c:	e8 16       	cp	r14, r24
   1539e:	f9 06       	cpc	r15, r25
   153a0:	8c f7       	brge	.-30     	; 0x15384 <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   153a2:	df 91       	pop	r29
   153a4:	cf 91       	pop	r28
   153a6:	1f 91       	pop	r17
   153a8:	0f 91       	pop	r16
   153aa:	ff 90       	pop	r15
   153ac:	ef 90       	pop	r14
   153ae:	df 90       	pop	r13
   153b0:	08 95       	ret

000153b2 <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   153b2:	81 e0       	ldi	r24, 0x01	; 1
   153b4:	61 e0       	ldi	r22, 0x01	; 1
   153b6:	49 e5       	ldi	r20, 0x59	; 89
   153b8:	55 e2       	ldi	r21, 0x25	; 37
   153ba:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   153be:	82 e0       	ldi	r24, 0x02	; 2
   153c0:	61 e0       	ldi	r22, 0x01	; 1
   153c2:	44 e4       	ldi	r20, 0x44	; 68
   153c4:	55 e2       	ldi	r21, 0x25	; 37
   153c6:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   153ca:	83 e0       	ldi	r24, 0x03	; 3
   153cc:	61 e0       	ldi	r22, 0x01	; 1
   153ce:	4f e2       	ldi	r20, 0x2F	; 47
   153d0:	55 e2       	ldi	r21, 0x25	; 37
   153d2:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   153d6:	84 e0       	ldi	r24, 0x04	; 4
   153d8:	61 e0       	ldi	r22, 0x01	; 1
   153da:	4a e1       	ldi	r20, 0x1A	; 26
   153dc:	55 e2       	ldi	r21, 0x25	; 37
   153de:	0e 94 ac a9 	call	0x15358	; 0x15358 <lcd_printf>
}
   153e2:	08 95       	ret

000153e4 <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   153e4:	1f 93       	push	r17
   153e6:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   153e8:	0e 94 64 a9 	call	0x152c8	; 0x152c8 <lcd_xy>
	_lcd(__chr);
   153ec:	81 2f       	mov	r24, r17
   153ee:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
}
   153f2:	1f 91       	pop	r17
   153f4:	08 95       	ret

000153f6 <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   153f6:	0f 93       	push	r16
   153f8:	1f 93       	push	r17
   153fa:	cf 93       	push	r28
   153fc:	df 93       	push	r29
   153fe:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   15400:	88 30       	cpi	r24, 0x08	; 8
   15402:	90 f4       	brcc	.+36     	; 0x15428 <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   15404:	88 0f       	add	r24, r24
   15406:	88 0f       	add	r24, r24
   15408:	88 0f       	add	r24, r24
   1540a:	80 5c       	subi	r24, 0xC0	; 192
   1540c:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
   15410:	c0 e0       	ldi	r28, 0x00	; 0
   15412:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   15414:	f8 01       	movw	r30, r16
   15416:	ec 0f       	add	r30, r28
   15418:	fd 1f       	adc	r31, r29
   1541a:	80 81       	ld	r24, Z
   1541c:	0e 94 3e a9 	call	0x1527c	; 0x1527c <_lcd>
   15420:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   15422:	c8 30       	cpi	r28, 0x08	; 8
   15424:	d1 05       	cpc	r29, r1
   15426:	b1 f7       	brne	.-20     	; 0x15414 <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   15428:	df 91       	pop	r29
   1542a:	cf 91       	pop	r28
   1542c:	1f 91       	pop	r17
   1542e:	0f 91       	pop	r16
   15430:	08 95       	ret

00015432 <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   15432:	cf 93       	push	r28
   15434:	df 93       	push	r29
   15436:	20 e0       	ldi	r18, 0x00	; 0
   15438:	04 c0       	rjmp	.+8      	; 0x15442 <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   1543a:	c8 0f       	add	r28, r24
   1543c:	d9 1f       	adc	r29, r25
   1543e:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   15440:	2f 5f       	subi	r18, 0xFF	; 255
   15442:	c2 2f       	mov	r28, r18
   15444:	d0 e0       	ldi	r29, 0x00	; 0
   15446:	fc 01       	movw	r30, r24
   15448:	01 90       	ld	r0, Z+
   1544a:	00 20       	and	r0, r0
   1544c:	e9 f7       	brne	.-6      	; 0x15448 <ClearMem+0x16>
   1544e:	31 97       	sbiw	r30, 0x01	; 1
   15450:	e8 1b       	sub	r30, r24
   15452:	f9 0b       	sbc	r31, r25
   15454:	ce 17       	cp	r28, r30
   15456:	df 07       	cpc	r29, r31
   15458:	80 f3       	brcs	.-32     	; 0x1543a <ClearMem+0x8>
          string[i]=0;
	 }     
}
   1545a:	df 91       	pop	r29
   1545c:	cf 91       	pop	r28
   1545e:	08 95       	ret

00015460 <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   15460:	df 93       	push	r29
   15462:	cf 93       	push	r28
   15464:	00 d0       	rcall	.+0      	; 0x15466 <_key_hit+0x6>
   15466:	00 d0       	rcall	.+0      	; 0x15468 <_key_hit+0x8>
   15468:	cd b7       	in	r28, 0x3d	; 61
   1546a:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   1546c:	8f ee       	ldi	r24, 0xEF	; 239
   1546e:	89 83       	std	Y+1, r24	; 0x01
   15470:	8f ed       	ldi	r24, 0xDF	; 223
   15472:	8a 83       	std	Y+2, r24	; 0x02
   15474:	8f eb       	ldi	r24, 0xBF	; 191
   15476:	8b 83       	std	Y+3, r24	; 0x03
   15478:	8f e7       	ldi	r24, 0x7F	; 127
   1547a:	8c 83       	std	Y+4, r24	; 0x04
   1547c:	de 01       	movw	r26, r28
   1547e:	11 96       	adiw	r26, 0x01	; 1
   15480:	26 e6       	ldi	r18, 0x66	; 102
   15482:	3e e0       	ldi	r19, 0x0E	; 14

	for(i=0; i<4; i++){
   15484:	ae 01       	movw	r20, r28
   15486:	4b 5f       	subi	r20, 0xFB	; 251
   15488:	5f 4f       	sbci	r21, 0xFF	; 255
   1548a:	c9 01       	movw	r24, r18
   1548c:	01 97       	sbiw	r24, 0x01	; 1
   1548e:	f1 f7       	brne	.-4      	; 0x1548c <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15490:	8c 91       	ld	r24, X
   15492:	80 93 62 00 	sts	0x0062, r24
   15496:	f9 01       	movw	r30, r18
   15498:	31 97       	sbiw	r30, 0x01	; 1
   1549a:	f1 f7       	brne	.-4      	; 0x15498 <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   1549c:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   1549e:	98 17       	cp	r25, r24
   154a0:	21 f4       	brne	.+8      	; 0x154aa <_key_hit+0x4a>
		    break;
   154a2:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   154a4:	a4 17       	cp	r26, r20
   154a6:	b5 07       	cpc	r27, r21
   154a8:	81 f7       	brne	.-32     	; 0x1548a <_key_hit+0x2a>
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) 
		    break;
	}
	return keyhit;
}
   154aa:	89 2f       	mov	r24, r25
   154ac:	0f 90       	pop	r0
   154ae:	0f 90       	pop	r0
   154b0:	0f 90       	pop	r0
   154b2:	0f 90       	pop	r0
   154b4:	cf 91       	pop	r28
   154b6:	df 91       	pop	r29
   154b8:	08 95       	ret

000154ba <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   154ba:	8e 3e       	cpi	r24, 0xEE	; 238
   154bc:	f9 f0       	breq	.+62     	; 0x154fc <_key_crr+0x42>
   154be:	8e 3d       	cpi	r24, 0xDE	; 222
   154c0:	e9 f0       	breq	.+58     	; 0x154fc <_key_crr+0x42>
   154c2:	8e 3b       	cpi	r24, 0xBE	; 190
   154c4:	d9 f0       	breq	.+54     	; 0x154fc <_key_crr+0x42>
   154c6:	8d 3e       	cpi	r24, 0xED	; 237
   154c8:	c9 f0       	breq	.+50     	; 0x154fc <_key_crr+0x42>
   154ca:	8d 3d       	cpi	r24, 0xDD	; 221
   154cc:	b9 f0       	breq	.+46     	; 0x154fc <_key_crr+0x42>
   154ce:	8d 3b       	cpi	r24, 0xBD	; 189
   154d0:	a9 f0       	breq	.+42     	; 0x154fc <_key_crr+0x42>
   154d2:	8b 3e       	cpi	r24, 0xEB	; 235
   154d4:	99 f0       	breq	.+38     	; 0x154fc <_key_crr+0x42>
   154d6:	8b 3d       	cpi	r24, 0xDB	; 219
   154d8:	89 f0       	breq	.+34     	; 0x154fc <_key_crr+0x42>
   154da:	8b 3b       	cpi	r24, 0xBB	; 187
   154dc:	79 f0       	breq	.+30     	; 0x154fc <_key_crr+0x42>
   154de:	87 3d       	cpi	r24, 0xD7	; 215
   154e0:	69 f0       	breq	.+26     	; 0x154fc <_key_crr+0x42>
   154e2:	87 3e       	cpi	r24, 0xE7	; 231
   154e4:	59 f0       	breq	.+22     	; 0x154fc <_key_crr+0x42>
   154e6:	87 3b       	cpi	r24, 0xB7	; 183
   154e8:	49 f0       	breq	.+18     	; 0x154fc <_key_crr+0x42>
   154ea:	8e 37       	cpi	r24, 0x7E	; 126
   154ec:	39 f0       	breq	.+14     	; 0x154fc <_key_crr+0x42>
   154ee:	8d 37       	cpi	r24, 0x7D	; 125
   154f0:	29 f0       	breq	.+10     	; 0x154fc <_key_crr+0x42>
   154f2:	8b 37       	cpi	r24, 0x7B	; 123
   154f4:	19 f0       	breq	.+6      	; 0x154fc <_key_crr+0x42>
   154f6:	87 37       	cpi	r24, 0x77	; 119
   154f8:	09 f0       	breq	.+2      	; 0x154fc <_key_crr+0x42>
   154fa:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   154fc:	08 95       	ret

000154fe <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   154fe:	8e 3b       	cpi	r24, 0xBE	; 190
   15500:	91 f1       	breq	.+100    	; 0x15566 <_key_btn+0x68>
   15502:	8f 3b       	cpi	r24, 0xBF	; 191
   15504:	a8 f4       	brcc	.+42     	; 0x15530 <_key_btn+0x32>
   15506:	8e 37       	cpi	r24, 0x7E	; 126
   15508:	09 f4       	brne	.+2      	; 0x1550c <_key_btn+0xe>
   1550a:	41 c0       	rjmp	.+130    	; 0x1558e <_key_btn+0x90>
   1550c:	8f 37       	cpi	r24, 0x7F	; 127
   1550e:	48 f4       	brcc	.+18     	; 0x15522 <_key_btn+0x24>
   15510:	8b 37       	cpi	r24, 0x7B	; 123
   15512:	09 f4       	brne	.+2      	; 0x15516 <_key_btn+0x18>
   15514:	40 c0       	rjmp	.+128    	; 0x15596 <_key_btn+0x98>
   15516:	8d 37       	cpi	r24, 0x7D	; 125
   15518:	e1 f1       	breq	.+120    	; 0x15592 <_key_btn+0x94>
   1551a:	87 37       	cpi	r24, 0x77	; 119
   1551c:	09 f0       	breq	.+2      	; 0x15520 <_key_btn+0x22>
   1551e:	3f c0       	rjmp	.+126    	; 0x1559e <_key_btn+0xa0>
   15520:	3c c0       	rjmp	.+120    	; 0x1559a <_key_btn+0x9c>
   15522:	8b 3b       	cpi	r24, 0xBB	; 187
   15524:	61 f1       	breq	.+88     	; 0x1557e <_key_btn+0x80>
   15526:	8d 3b       	cpi	r24, 0xBD	; 189
   15528:	21 f1       	breq	.+72     	; 0x15572 <_key_btn+0x74>
   1552a:	87 3b       	cpi	r24, 0xB7	; 183
   1552c:	c1 f5       	brne	.+112    	; 0x1559e <_key_btn+0xa0>
   1552e:	2d c0       	rjmp	.+90     	; 0x1558a <_key_btn+0x8c>
   15530:	8e 3d       	cpi	r24, 0xDE	; 222
   15532:	a9 f0       	breq	.+42     	; 0x1555e <_key_btn+0x60>
   15534:	8f 3d       	cpi	r24, 0xDF	; 223
   15536:	38 f4       	brcc	.+14     	; 0x15546 <_key_btn+0x48>
   15538:	8b 3d       	cpi	r24, 0xDB	; 219
   1553a:	f9 f0       	breq	.+62     	; 0x1557a <_key_btn+0x7c>
   1553c:	8d 3d       	cpi	r24, 0xDD	; 221
   1553e:	b9 f0       	breq	.+46     	; 0x1556e <_key_btn+0x70>
   15540:	87 3d       	cpi	r24, 0xD7	; 215
   15542:	69 f5       	brne	.+90     	; 0x1559e <_key_btn+0xa0>
   15544:	1e c0       	rjmp	.+60     	; 0x15582 <_key_btn+0x84>
   15546:	8b 3e       	cpi	r24, 0xEB	; 235
   15548:	b1 f0       	breq	.+44     	; 0x15576 <_key_btn+0x78>
   1554a:	8c 3e       	cpi	r24, 0xEC	; 236
   1554c:	18 f4       	brcc	.+6      	; 0x15554 <_key_btn+0x56>
   1554e:	87 3e       	cpi	r24, 0xE7	; 231
   15550:	31 f5       	brne	.+76     	; 0x1559e <_key_btn+0xa0>
   15552:	19 c0       	rjmp	.+50     	; 0x15586 <_key_btn+0x88>
   15554:	8d 3e       	cpi	r24, 0xED	; 237
   15556:	49 f0       	breq	.+18     	; 0x1556a <_key_btn+0x6c>
   15558:	8e 3e       	cpi	r24, 0xEE	; 238
   1555a:	09 f5       	brne	.+66     	; 0x1559e <_key_btn+0xa0>
   1555c:	02 c0       	rjmp	.+4      	; 0x15562 <_key_btn+0x64>
   1555e:	82 e3       	ldi	r24, 0x32	; 50
   15560:	08 95       	ret
   15562:	81 e3       	ldi	r24, 0x31	; 49
   15564:	08 95       	ret
   15566:	83 e3       	ldi	r24, 0x33	; 51
   15568:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   1556a:	84 e3       	ldi	r24, 0x34	; 52
   1556c:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   1556e:	85 e3       	ldi	r24, 0x35	; 53
   15570:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   15572:	86 e3       	ldi	r24, 0x36	; 54
   15574:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   15576:	87 e3       	ldi	r24, 0x37	; 55
   15578:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   1557a:	88 e3       	ldi	r24, 0x38	; 56
   1557c:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   1557e:	89 e3       	ldi	r24, 0x39	; 57
   15580:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   15582:	80 e3       	ldi	r24, 0x30	; 48
   15584:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   15586:	8a e2       	ldi	r24, 0x2A	; 42
   15588:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   1558a:	83 e2       	ldi	r24, 0x23	; 35
   1558c:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   1558e:	81 ef       	ldi	r24, 0xF1	; 241
   15590:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   15592:	82 ef       	ldi	r24, 0xF2	; 242
   15594:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   15596:	83 ef       	ldi	r24, 0xF3	; 243
   15598:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   1559a:	84 ef       	ldi	r24, 0xF4	; 244
   1559c:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   1559e:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   155a0:	08 95       	ret

000155a2 <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   155a2:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   155a4:	6d 3d       	cpi	r22, 0xDD	; 221
   155a6:	11 f1       	breq	.+68     	; 0x155ec <_table_alphanum+0x4a>
   155a8:	6e 3d       	cpi	r22, 0xDE	; 222
   155aa:	60 f4       	brcc	.+24     	; 0x155c4 <_table_alphanum+0x22>
   155ac:	6d 3b       	cpi	r22, 0xBD	; 189
   155ae:	01 f1       	breq	.+64     	; 0x155f0 <_table_alphanum+0x4e>
   155b0:	6e 3b       	cpi	r22, 0xBE	; 190
   155b2:	18 f4       	brcc	.+6      	; 0x155ba <_table_alphanum+0x18>
   155b4:	6b 3b       	cpi	r22, 0xBB	; 187
   155b6:	21 f5       	brne	.+72     	; 0x15600 <_table_alphanum+0x5e>
   155b8:	21 c0       	rjmp	.+66     	; 0x155fc <_table_alphanum+0x5a>
   155ba:	6e 3b       	cpi	r22, 0xBE	; 190
   155bc:	99 f0       	breq	.+38     	; 0x155e4 <_table_alphanum+0x42>
   155be:	6b 3d       	cpi	r22, 0xDB	; 219
   155c0:	f9 f4       	brne	.+62     	; 0x15600 <_table_alphanum+0x5e>
   155c2:	1a c0       	rjmp	.+52     	; 0x155f8 <_table_alphanum+0x56>
   155c4:	6b 3e       	cpi	r22, 0xEB	; 235
   155c6:	b1 f0       	breq	.+44     	; 0x155f4 <_table_alphanum+0x52>
   155c8:	6c 3e       	cpi	r22, 0xEC	; 236
   155ca:	18 f4       	brcc	.+6      	; 0x155d2 <_table_alphanum+0x30>
   155cc:	6e 3d       	cpi	r22, 0xDE	; 222
   155ce:	c1 f4       	brne	.+48     	; 0x15600 <_table_alphanum+0x5e>
   155d0:	05 c0       	rjmp	.+10     	; 0x155dc <_table_alphanum+0x3a>
   155d2:	6d 3e       	cpi	r22, 0xED	; 237
   155d4:	49 f0       	breq	.+18     	; 0x155e8 <_table_alphanum+0x46>
   155d6:	6e 3e       	cpi	r22, 0xEE	; 238
   155d8:	99 f4       	brne	.+38     	; 0x15600 <_table_alphanum+0x5e>
   155da:	02 c0       	rjmp	.+4      	; 0x155e0 <_table_alphanum+0x3e>
   155dc:	82 e0       	ldi	r24, 0x02	; 2
   155de:	11 c0       	rjmp	.+34     	; 0x15602 <_table_alphanum+0x60>
   155e0:	81 e0       	ldi	r24, 0x01	; 1
   155e2:	0f c0       	rjmp	.+30     	; 0x15602 <_table_alphanum+0x60>
   155e4:	83 e0       	ldi	r24, 0x03	; 3
   155e6:	0d c0       	rjmp	.+26     	; 0x15602 <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   155e8:	84 e0       	ldi	r24, 0x04	; 4
   155ea:	0b c0       	rjmp	.+22     	; 0x15602 <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   155ec:	85 e0       	ldi	r24, 0x05	; 5
   155ee:	09 c0       	rjmp	.+18     	; 0x15602 <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   155f0:	86 e0       	ldi	r24, 0x06	; 6
   155f2:	07 c0       	rjmp	.+14     	; 0x15602 <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   155f4:	87 e0       	ldi	r24, 0x07	; 7
   155f6:	05 c0       	rjmp	.+10     	; 0x15602 <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   155f8:	88 e0       	ldi	r24, 0x08	; 8
   155fa:	03 c0       	rjmp	.+6      	; 0x15602 <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   155fc:	89 e0       	ldi	r24, 0x09	; 9
   155fe:	01 c0       	rjmp	.+2      	; 0x15602 <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   15600:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   15602:	28 2f       	mov	r18, r24
   15604:	30 e0       	ldi	r19, 0x00	; 0
   15606:	f9 01       	movw	r30, r18
   15608:	ea 51       	subi	r30, 0x1A	; 26
   1560a:	fa 4d       	sbci	r31, 0xDA	; 218
   1560c:	e4 91       	lpm	r30, Z+
   1560e:	e4 17       	cp	r30, r20
   15610:	10 f4       	brcc	.+4      	; 0x15616 <_table_alphanum+0x74>
   15612:	80 e0       	ldi	r24, 0x00	; 0
   15614:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   15616:	ec e3       	ldi	r30, 0x3C	; 60
   15618:	9e 9f       	mul	r25, r30
   1561a:	f0 01       	movw	r30, r0
   1561c:	11 24       	eor	r1, r1
   1561e:	e4 0f       	add	r30, r20
   15620:	f1 1d       	adc	r31, r1
   15622:	c9 01       	movw	r24, r18
   15624:	88 0f       	add	r24, r24
   15626:	99 1f       	adc	r25, r25
   15628:	82 0f       	add	r24, r18
   1562a:	93 1f       	adc	r25, r19
   1562c:	88 0f       	add	r24, r24
   1562e:	99 1f       	adc	r25, r25
   15630:	e8 0f       	add	r30, r24
   15632:	f9 1f       	adc	r31, r25
   15634:	e2 59       	subi	r30, 0x92	; 146
   15636:	fa 4d       	sbci	r31, 0xDA	; 218
   15638:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   1563a:	08 95       	ret

0001563c <_key_scan>:





char _key_scan(char __select){
   1563c:	8f 92       	push	r8
   1563e:	9f 92       	push	r9
   15640:	af 92       	push	r10
   15642:	bf 92       	push	r11
   15644:	cf 92       	push	r12
   15646:	df 92       	push	r13
   15648:	ef 92       	push	r14
   1564a:	ff 92       	push	r15
   1564c:	0f 93       	push	r16
   1564e:	1f 93       	push	r17
   15650:	df 93       	push	r29
   15652:	cf 93       	push	r28
   15654:	00 d0       	rcall	.+0      	; 0x15656 <_key_scan+0x1a>
   15656:	00 d0       	rcall	.+0      	; 0x15658 <_key_scan+0x1c>
   15658:	cd b7       	in	r28, 0x3d	; 61
   1565a:	de b7       	in	r29, 0x3e	; 62
   1565c:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   1565e:	81 50       	subi	r24, 0x01	; 1
   15660:	82 30       	cpi	r24, 0x02	; 2
   15662:	08 f0       	brcs	.+2      	; 0x15666 <_key_scan+0x2a>
   15664:	aa c0       	rjmp	.+340    	; 0x157ba <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15666:	8f ee       	ldi	r24, 0xEF	; 239
   15668:	89 83       	std	Y+1, r24	; 0x01
   1566a:	8f ed       	ldi	r24, 0xDF	; 223
   1566c:	8a 83       	std	Y+2, r24	; 0x02
   1566e:	8f eb       	ldi	r24, 0xBF	; 191
   15670:	8b 83       	std	Y+3, r24	; 0x03
   15672:	8f e7       	ldi	r24, 0x7F	; 127
   15674:	8c 83       	std	Y+4, r24	; 0x04
   15676:	de 01       	movw	r26, r28
   15678:	11 96       	adiw	r26, 0x01	; 1
   1567a:	26 e6       	ldi	r18, 0x66	; 102
   1567c:	3e e0       	ldi	r19, 0x0E	; 14

	for(i=0; i<4; i++){
   1567e:	ae 01       	movw	r20, r28
   15680:	4b 5f       	subi	r20, 0xFB	; 251
   15682:	5f 4f       	sbci	r21, 0xFF	; 255
   15684:	c9 01       	movw	r24, r18
   15686:	01 97       	sbiw	r24, 0x01	; 1
   15688:	f1 f7       	brne	.-4      	; 0x15686 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   1568a:	8c 91       	ld	r24, X
   1568c:	80 93 62 00 	sts	0x0062, r24
   15690:	f9 01       	movw	r30, r18
   15692:	31 97       	sbiw	r30, 0x01	; 1
   15694:	f1 f7       	brne	.-4      	; 0x15692 <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15696:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15698:	98 17       	cp	r25, r24
   1569a:	21 f4       	brne	.+8      	; 0x156a4 <_key_scan+0x68>
   1569c:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   1569e:	a4 17       	cp	r26, r20
   156a0:	b5 07       	cpc	r27, r21
   156a2:	81 f7       	brne	.-32     	; 0x15684 <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   156a4:	89 2f       	mov	r24, r25
   156a6:	0e 94 5d aa 	call	0x154ba	; 0x154ba <_key_crr>
   156aa:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   156ac:	88 23       	and	r24, r24
   156ae:	09 f4       	brne	.+2      	; 0x156b2 <_key_scan+0x76>
   156b0:	85 c0       	rjmp	.+266    	; 0x157bc <_key_scan+0x180>
			_LIGHT_SET;
   156b2:	91 e0       	ldi	r25, 0x01	; 1
   156b4:	90 93 ae 02 	sts	0x02AE, r25
   156b8:	10 92 af 02 	sts	0x02AF, r1
   156bc:	80 91 65 00 	lds	r24, 0x0065
   156c0:	8d 7f       	andi	r24, 0xFD	; 253
   156c2:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   156c6:	80 91 b9 02 	lds	r24, 0x02B9
   156ca:	88 23       	and	r24, r24
   156cc:	31 f0       	breq	.+12     	; 0x156da <_key_scan+0x9e>
				_SEC_ON;
   156ce:	90 93 b4 02 	sts	0x02B4, r25
   156d2:	10 92 b6 02 	sts	0x02B6, r1
   156d6:	10 92 b5 02 	sts	0x02B5, r1

			if(_IS1st){
   156da:	80 91 b0 02 	lds	r24, 0x02B0
   156de:	88 23       	and	r24, r24
   156e0:	71 f4       	brne	.+28     	; 0x156fe <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   156e2:	27 3e       	cpi	r18, 0xE7	; 231
   156e4:	11 f0       	breq	.+4      	; 0x156ea <_key_scan+0xae>
   156e6:	27 3b       	cpi	r18, 0xB7	; 183
   156e8:	31 f4       	brne	.+12     	; 0x156f6 <_key_scan+0xba>
					if(__lock_num)
   156ea:	80 91 ad 02 	lds	r24, 0x02AD
   156ee:	88 23       	and	r24, r24
   156f0:	11 f0       	breq	.+4      	; 0x156f6 <_key_scan+0xba>
						__lock_num = 0;
   156f2:	10 92 ad 02 	sts	0x02AD, r1
				_PAD_2nd;
   156f6:	81 e0       	ldi	r24, 0x01	; 1
   156f8:	80 93 b0 02 	sts	0x02B0, r24
   156fc:	59 c0       	rjmp	.+178    	; 0x157b0 <_key_scan+0x174>
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   156fe:	81 30       	cpi	r24, 0x01	; 1
   15700:	09 f0       	breq	.+2      	; 0x15704 <_key_scan+0xc8>
   15702:	5c c0       	rjmp	.+184    	; 0x157bc <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   15704:	12 30       	cpi	r17, 0x02	; 2
   15706:	21 f5       	brne	.+72     	; 0x15750 <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   15708:	27 3d       	cpi	r18, 0xD7	; 215
   1570a:	91 f0       	breq	.+36     	; 0x15730 <_key_scan+0xf4>
   1570c:	2e 3e       	cpi	r18, 0xEE	; 238
   1570e:	81 f0       	breq	.+32     	; 0x15730 <_key_scan+0xf4>
   15710:	2e 3d       	cpi	r18, 0xDE	; 222
   15712:	71 f0       	breq	.+28     	; 0x15730 <_key_scan+0xf4>
   15714:	2e 3b       	cpi	r18, 0xBE	; 190
   15716:	61 f0       	breq	.+24     	; 0x15730 <_key_scan+0xf4>
   15718:	2d 3e       	cpi	r18, 0xED	; 237
   1571a:	51 f0       	breq	.+20     	; 0x15730 <_key_scan+0xf4>
   1571c:	2d 3d       	cpi	r18, 0xDD	; 221
   1571e:	41 f0       	breq	.+16     	; 0x15730 <_key_scan+0xf4>
   15720:	2d 3b       	cpi	r18, 0xBD	; 189
   15722:	31 f0       	breq	.+12     	; 0x15730 <_key_scan+0xf4>
   15724:	2b 3e       	cpi	r18, 0xEB	; 235
   15726:	21 f0       	breq	.+8      	; 0x15730 <_key_scan+0xf4>
   15728:	2b 3d       	cpi	r18, 0xDB	; 219
   1572a:	11 f0       	breq	.+4      	; 0x15730 <_key_scan+0xf4>
   1572c:	2b 3b       	cpi	r18, 0xBB	; 187
   1572e:	81 f4       	brne	.+32     	; 0x15750 <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   15730:	80 91 ad 02 	lds	r24, 0x02AD
   15734:	88 23       	and	r24, r24
   15736:	49 f0       	breq	.+18     	; 0x1574a <_key_scan+0x10e>
							_SHIFT_SET;
   15738:	81 e0       	ldi	r24, 0x01	; 1
   1573a:	80 93 b1 02 	sts	0x02B1, r24
   1573e:	10 92 b2 02 	sts	0x02B2, r1
							CURSOR_HIDE;
   15742:	8c e0       	ldi	r24, 0x0C	; 12
   15744:	0e 94 cc a8 	call	0x15198	; 0x15198 <lcd_command>
   15748:	03 c0       	rjmp	.+6      	; 0x15750 <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   1574a:	81 e0       	ldi	r24, 0x01	; 1
   1574c:	80 93 ad 02 	sts	0x02AD, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15750:	ff ee       	ldi	r31, 0xEF	; 239
   15752:	8f 2e       	mov	r8, r31
   15754:	ef ed       	ldi	r30, 0xDF	; 223
   15756:	9e 2e       	mov	r9, r30
   15758:	7f eb       	ldi	r23, 0xBF	; 191
   1575a:	a7 2e       	mov	r10, r23
   1575c:	6f e7       	ldi	r22, 0x7F	; 127
   1575e:	b6 2e       	mov	r11, r22
   15760:	6e 01       	movw	r12, r28
   15762:	08 94       	sec
   15764:	c1 1c       	adc	r12, r1
   15766:	d1 1c       	adc	r13, r1
   15768:	06 e6       	ldi	r16, 0x66	; 102
   1576a:	1e e0       	ldi	r17, 0x0E	; 14

	for(i=0; i<4; i++){
   1576c:	55 e0       	ldi	r21, 0x05	; 5
   1576e:	e5 2e       	mov	r14, r21
   15770:	f1 2c       	mov	r15, r1
   15772:	ec 0e       	add	r14, r28
   15774:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15776:	89 82       	std	Y+1, r8	; 0x01
   15778:	9a 82       	std	Y+2, r9	; 0x02
   1577a:	ab 82       	std	Y+3, r10	; 0x03
   1577c:	bc 82       	std	Y+4, r11	; 0x04
   1577e:	d6 01       	movw	r26, r12
   15780:	c8 01       	movw	r24, r16
   15782:	01 97       	sbiw	r24, 0x01	; 1
   15784:	f1 f7       	brne	.-4      	; 0x15782 <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15786:	8c 91       	ld	r24, X
   15788:	80 93 62 00 	sts	0x0062, r24
   1578c:	f8 01       	movw	r30, r16
   1578e:	31 97       	sbiw	r30, 0x01	; 1
   15790:	f1 f7       	brne	.-4      	; 0x1578e <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15792:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15794:	98 17       	cp	r25, r24
   15796:	21 f4       	brne	.+8      	; 0x157a0 <_key_scan+0x164>
   15798:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   1579a:	ae 15       	cp	r26, r14
   1579c:	bf 05       	cpc	r27, r15
   1579e:	81 f7       	brne	.-32     	; 0x15780 <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   157a0:	89 2f       	mov	r24, r25
   157a2:	0e 94 5d aa 	call	0x154ba	; 0x154ba <_key_crr>
   157a6:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   157a8:	88 23       	and	r24, r24
   157aa:	29 f7       	brne	.-54     	; 0x15776 <_key_scan+0x13a>
				_PAD_1st;
   157ac:	10 92 b0 02 	sts	0x02B0, r1
   157b0:	80 e0       	ldi	r24, 0x00	; 0
   157b2:	98 e4       	ldi	r25, 0x48	; 72
   157b4:	01 97       	sbiw	r24, 0x01	; 1
   157b6:	f1 f7       	brne	.-4      	; 0x157b4 <_key_scan+0x178>
   157b8:	03 c0       	rjmp	.+6      	; 0x157c0 <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   157ba:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   157bc:	10 92 b0 02 	sts	0x02B0, r1
	return __key;
}
   157c0:	82 2f       	mov	r24, r18
   157c2:	0f 90       	pop	r0
   157c4:	0f 90       	pop	r0
   157c6:	0f 90       	pop	r0
   157c8:	0f 90       	pop	r0
   157ca:	cf 91       	pop	r28
   157cc:	df 91       	pop	r29
   157ce:	1f 91       	pop	r17
   157d0:	0f 91       	pop	r16
   157d2:	ff 90       	pop	r15
   157d4:	ef 90       	pop	r14
   157d6:	df 90       	pop	r13
   157d8:	cf 90       	pop	r12
   157da:	bf 90       	pop	r11
   157dc:	af 90       	pop	r10
   157de:	9f 90       	pop	r9
   157e0:	8f 90       	pop	r8
   157e2:	08 95       	ret

000157e4 <_spi_init>:
#include <util/delay.h>
#include <compat/deprecated.h>

#include "SPI.h"
void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   157e4:	88 23       	and	r24, r24
   157e6:	41 f0       	breq	.+16     	; 0x157f8 <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   157e8:	86 e0       	ldi	r24, 0x06	; 6
   157ea:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   157ec:	66 23       	and	r22, r22
   157ee:	11 f0       	breq	.+4      	; 0x157f4 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   157f0:	82 ed       	ldi	r24, 0xD2	; 210
   157f2:	09 c0       	rjmp	.+18     	; 0x15806 <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   157f4:	82 e5       	ldi	r24, 0x52	; 82
   157f6:	07 c0       	rjmp	.+14     	; 0x15806 <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   157f8:	88 e0       	ldi	r24, 0x08	; 8
   157fa:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   157fc:	66 23       	and	r22, r22
   157fe:	11 f0       	breq	.+4      	; 0x15804 <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   15800:	80 ec       	ldi	r24, 0xC0	; 192
   15802:	01 c0       	rjmp	.+2      	; 0x15806 <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   15804:	80 e4       	ldi	r24, 0x40	; 64
   15806:	8d b9       	out	0x0d, r24	; 13
   15808:	08 95       	ret

0001580a <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   1580a:	88 23       	and	r24, r24
   1580c:	19 f4       	brne	.+6      	; 0x15814 <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   1580e:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   15810:	1b 9a       	sbi	0x03, 3	; 3
   15812:	08 95       	ret
	}
	if(__select == 1){
   15814:	81 30       	cpi	r24, 0x01	; 1
   15816:	39 f4       	brne	.+14     	; 0x15826 <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   15818:	1b 9a       	sbi	0x03, 3	; 3
   1581a:	80 e0       	ldi	r24, 0x00	; 0
   1581c:	98 e4       	ldi	r25, 0x48	; 72
   1581e:	01 97       	sbiw	r24, 0x01	; 1
   15820:	f1 f7       	brne	.-4      	; 0x1581e <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   15822:	db 98       	cbi	0x1b, 3	; 27
   15824:	08 95       	ret
	}
	if(__select == 2){
   15826:	82 30       	cpi	r24, 0x02	; 2
   15828:	31 f4       	brne	.+12     	; 0x15836 <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   1582a:	db 9a       	sbi	0x1b, 3	; 27
   1582c:	80 e0       	ldi	r24, 0x00	; 0
   1582e:	98 e4       	ldi	r25, 0x48	; 72
   15830:	01 97       	sbiw	r24, 0x01	; 1
   15832:	f1 f7       	brne	.-4      	; 0x15830 <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   15834:	1b 98       	cbi	0x03, 3	; 3
   15836:	08 95       	ret

00015838 <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15838:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1583a:	77 9b       	sbis	0x0e, 7	; 14
   1583c:	fe cf       	rjmp	.-4      	; 0x1583a <_spi+0x2>
	return SPDR;
   1583e:	8f b1       	in	r24, 0x0f	; 15
}
   15840:	08 95       	ret

00015842 <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   15842:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   15844:	22 23       	and	r18, r18
   15846:	09 f4       	brne	.+2      	; 0x1584a <_rtc+0x8>
   15848:	49 c0       	rjmp	.+146    	; 0x158dc <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   1584a:	84 ea       	ldi	r24, 0xA4	; 164
   1584c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   15850:	80 91 74 00 	lds	r24, 0x0074
   15854:	87 ff       	sbrs	r24, 7
   15856:	fc cf       	rjmp	.-8      	; 0x15850 <_rtc+0xe>
		if(TW_STATUS != TW_START)
   15858:	80 91 71 00 	lds	r24, 0x0071
   1585c:	88 7f       	andi	r24, 0xF8	; 248
   1585e:	88 30       	cpi	r24, 0x08	; 8
   15860:	09 f0       	breq	.+2      	; 0x15864 <_rtc+0x22>
   15862:	af c0       	rjmp	.+350    	; 0x159c2 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   15864:	80 ed       	ldi	r24, 0xD0	; 208
   15866:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   1586a:	84 e8       	ldi	r24, 0x84	; 132
   1586c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   15870:	80 91 74 00 	lds	r24, 0x0074
   15874:	87 ff       	sbrs	r24, 7
   15876:	fc cf       	rjmp	.-8      	; 0x15870 <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   15878:	80 91 71 00 	lds	r24, 0x0071
   1587c:	88 7f       	andi	r24, 0xF8	; 248
   1587e:	88 31       	cpi	r24, 0x18	; 24
   15880:	09 f0       	breq	.+2      	; 0x15884 <_rtc+0x42>
   15882:	9f c0       	rjmp	.+318    	; 0x159c2 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   15884:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   15888:	84 e8       	ldi	r24, 0x84	; 132
   1588a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1588e:	80 91 74 00 	lds	r24, 0x0074
   15892:	87 ff       	sbrs	r24, 7
   15894:	fc cf       	rjmp	.-8      	; 0x1588e <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   15896:	80 91 71 00 	lds	r24, 0x0071
   1589a:	88 7f       	andi	r24, 0xF8	; 248
   1589c:	88 32       	cpi	r24, 0x28	; 40
   1589e:	09 f0       	breq	.+2      	; 0x158a2 <_rtc+0x60>
   158a0:	90 c0       	rjmp	.+288    	; 0x159c2 <_rtc+0x180>
   158a2:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   158a4:	94 e8       	ldi	r25, 0x84	; 132
   158a6:	14 c0       	rjmp	.+40     	; 0x158d0 <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   158a8:	fa 01       	movw	r30, r20
   158aa:	e8 0f       	add	r30, r24
   158ac:	f1 1d       	adc	r31, r1
   158ae:	80 81       	ld	r24, Z
   158b0:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   158b4:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   158b8:	80 91 74 00 	lds	r24, 0x0074
   158bc:	87 ff       	sbrs	r24, 7
   158be:	fc cf       	rjmp	.-8      	; 0x158b8 <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   158c0:	80 91 71 00 	lds	r24, 0x0071
   158c4:	88 7f       	andi	r24, 0xF8	; 248
   158c6:	80 33       	cpi	r24, 0x30	; 48
   158c8:	09 f4       	brne	.+2      	; 0x158cc <_rtc+0x8a>
   158ca:	7b c0       	rjmp	.+246    	; 0x159c2 <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   158cc:	21 50       	subi	r18, 0x01	; 1
   158ce:	30 40       	sbci	r19, 0x00	; 0
   158d0:	86 2f       	mov	r24, r22
   158d2:	82 1b       	sub	r24, r18
   158d4:	12 16       	cp	r1, r18
   158d6:	13 06       	cpc	r1, r19
   158d8:	3c f3       	brlt	.-50     	; 0x158a8 <_rtc+0x66>
   158da:	6e c0       	rjmp	.+220    	; 0x159b8 <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   158dc:	84 ea       	ldi	r24, 0xA4	; 164
   158de:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   158e2:	80 91 74 00 	lds	r24, 0x0074
   158e6:	87 ff       	sbrs	r24, 7
   158e8:	fc cf       	rjmp	.-8      	; 0x158e2 <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   158ea:	80 91 71 00 	lds	r24, 0x0071
   158ee:	88 7f       	andi	r24, 0xF8	; 248
   158f0:	88 30       	cpi	r24, 0x08	; 8
   158f2:	09 f0       	breq	.+2      	; 0x158f6 <_rtc+0xb4>
   158f4:	66 c0       	rjmp	.+204    	; 0x159c2 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   158f6:	80 ed       	ldi	r24, 0xD0	; 208
   158f8:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   158fc:	84 e8       	ldi	r24, 0x84	; 132
   158fe:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   15902:	80 91 74 00 	lds	r24, 0x0074
   15906:	87 ff       	sbrs	r24, 7
   15908:	fc cf       	rjmp	.-8      	; 0x15902 <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   1590a:	80 91 71 00 	lds	r24, 0x0071
   1590e:	88 7f       	andi	r24, 0xF8	; 248
   15910:	88 31       	cpi	r24, 0x18	; 24
   15912:	09 f0       	breq	.+2      	; 0x15916 <_rtc+0xd4>
   15914:	56 c0       	rjmp	.+172    	; 0x159c2 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   15916:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   1591a:	84 e8       	ldi	r24, 0x84	; 132
   1591c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   15920:	80 91 74 00 	lds	r24, 0x0074
   15924:	87 ff       	sbrs	r24, 7
   15926:	fc cf       	rjmp	.-8      	; 0x15920 <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   15928:	80 91 71 00 	lds	r24, 0x0071
   1592c:	88 7f       	andi	r24, 0xF8	; 248
   1592e:	88 32       	cpi	r24, 0x28	; 40
   15930:	09 f0       	breq	.+2      	; 0x15934 <_rtc+0xf2>
   15932:	47 c0       	rjmp	.+142    	; 0x159c2 <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   15934:	84 ea       	ldi	r24, 0xA4	; 164
   15936:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1593a:	80 91 74 00 	lds	r24, 0x0074
   1593e:	87 ff       	sbrs	r24, 7
   15940:	fc cf       	rjmp	.-8      	; 0x1593a <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   15942:	80 91 71 00 	lds	r24, 0x0071
   15946:	88 7f       	andi	r24, 0xF8	; 248
   15948:	80 31       	cpi	r24, 0x10	; 16
   1594a:	d9 f5       	brne	.+118    	; 0x159c2 <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   1594c:	81 ed       	ldi	r24, 0xD1	; 209
   1594e:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   15952:	84 e8       	ldi	r24, 0x84	; 132
   15954:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   15958:	80 91 74 00 	lds	r24, 0x0074
   1595c:	87 ff       	sbrs	r24, 7
   1595e:	fc cf       	rjmp	.-8      	; 0x15958 <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   15960:	80 91 71 00 	lds	r24, 0x0071
   15964:	88 7f       	andi	r24, 0xF8	; 248
   15966:	80 34       	cpi	r24, 0x40	; 64
   15968:	61 f5       	brne	.+88     	; 0x159c2 <_rtc+0x180>
   1596a:	24 ec       	ldi	r18, 0xC4	; 196
   1596c:	30 e0       	ldi	r19, 0x00	; 0
   1596e:	90 e0       	ldi	r25, 0x00	; 0
   15970:	20 c0       	rjmp	.+64     	; 0x159b2 <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   15972:	61 30       	cpi	r22, 0x01	; 1
   15974:	71 05       	cpc	r23, r1
   15976:	11 f4       	brne	.+4      	; 0x1597c <_rtc+0x13a>
   15978:	24 e8       	ldi	r18, 0x84	; 132
   1597a:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   1597c:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   15980:	80 91 74 00 	lds	r24, 0x0074
   15984:	87 ff       	sbrs	r24, 7
   15986:	fc cf       	rjmp	.-8      	; 0x15980 <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   15988:	80 91 71 00 	lds	r24, 0x0071
   1598c:	88 7f       	andi	r24, 0xF8	; 248
   1598e:	88 35       	cpi	r24, 0x58	; 88
   15990:	11 f4       	brne	.+4      	; 0x15996 <_rtc+0x154>
   15992:	60 e0       	ldi	r22, 0x00	; 0
   15994:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   15996:	80 91 71 00 	lds	r24, 0x0071
   1599a:	88 7f       	andi	r24, 0xF8	; 248
   1599c:	80 35       	cpi	r24, 0x50	; 80
   1599e:	39 f4       	brne	.+14     	; 0x159ae <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   159a0:	80 91 73 00 	lds	r24, 0x0073
   159a4:	fa 01       	movw	r30, r20
   159a6:	e9 0f       	add	r30, r25
   159a8:	f1 1d       	adc	r31, r1
   159aa:	80 83       	st	Z, r24
   159ac:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   159ae:	61 50       	subi	r22, 0x01	; 1
   159b0:	70 40       	sbci	r23, 0x00	; 0
   159b2:	16 16       	cp	r1, r22
   159b4:	17 06       	cpc	r1, r23
   159b6:	ec f2       	brlt	.-70     	; 0x15972 <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   159b8:	84 e9       	ldi	r24, 0x94	; 148
   159ba:	80 93 74 00 	sts	0x0074, r24
   159be:	80 e0       	ldi	r24, 0x00	; 0
   159c0:	08 95       	ret
   159c2:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   159c4:	08 95       	ret

000159c6 <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   159c6:	ef 92       	push	r14
   159c8:	ff 92       	push	r15
   159ca:	0f 93       	push	r16
   159cc:	1f 93       	push	r17
   159ce:	df 93       	push	r29
   159d0:	cf 93       	push	r28
   159d2:	cd b7       	in	r28, 0x3d	; 61
   159d4:	de b7       	in	r29, 0x3e	; 62
   159d6:	64 97       	sbiw	r28, 0x14	; 20
   159d8:	0f b6       	in	r0, 0x3f	; 63
   159da:	f8 94       	cli
   159dc:	de bf       	out	0x3e, r29	; 62
   159de:	0f be       	out	0x3f, r0	; 63
   159e0:	cd bf       	out	0x3d, r28	; 61
   159e2:	28 2f       	mov	r18, r24
   159e4:	8b 01       	movw	r16, r22
   159e6:	7a 01       	movw	r14, r20
   159e8:	ae 01       	movw	r20, r28
   159ea:	4f 5f       	subi	r20, 0xFF	; 255
   159ec:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   159ee:	88 23       	and	r24, r24
   159f0:	99 f1       	breq	.+102    	; 0x15a58 <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   159f2:	fb 01       	movw	r30, r22
   159f4:	90 81       	ld	r25, Z
   159f6:	92 95       	swap	r25
   159f8:	90 7f       	andi	r25, 0xF0	; 240
   159fa:	81 81       	ldd	r24, Z+1	; 0x01
   159fc:	8f 70       	andi	r24, 0x0F	; 15
   159fe:	98 0f       	add	r25, r24
   15a00:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   15a02:	93 81       	ldd	r25, Z+3	; 0x03
   15a04:	92 95       	swap	r25
   15a06:	90 7f       	andi	r25, 0xF0	; 240
   15a08:	84 81       	ldd	r24, Z+4	; 0x04
   15a0a:	8f 70       	andi	r24, 0x0F	; 15
   15a0c:	98 0f       	add	r25, r24
   15a0e:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   15a10:	96 81       	ldd	r25, Z+6	; 0x06
   15a12:	92 95       	swap	r25
   15a14:	90 7f       	andi	r25, 0xF0	; 240
   15a16:	87 81       	ldd	r24, Z+7	; 0x07
   15a18:	8f 70       	andi	r24, 0x0F	; 15
   15a1a:	98 0f       	add	r25, r24
   15a1c:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   15a1e:	f7 01       	movw	r30, r14
   15a20:	90 81       	ld	r25, Z
   15a22:	92 95       	swap	r25
   15a24:	90 7f       	andi	r25, 0xF0	; 240
   15a26:	81 81       	ldd	r24, Z+1	; 0x01
   15a28:	8f 70       	andi	r24, 0x0F	; 15
   15a2a:	98 0f       	add	r25, r24
   15a2c:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   15a2e:	93 81       	ldd	r25, Z+3	; 0x03
   15a30:	92 95       	swap	r25
   15a32:	90 7f       	andi	r25, 0xF0	; 240
   15a34:	84 81       	ldd	r24, Z+4	; 0x04
   15a36:	8f 70       	andi	r24, 0x0F	; 15
   15a38:	98 0f       	add	r25, r24
   15a3a:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   15a3c:	96 81       	ldd	r25, Z+6	; 0x06
   15a3e:	92 95       	swap	r25
   15a40:	90 7f       	andi	r25, 0xF0	; 240
   15a42:	87 81       	ldd	r24, Z+7	; 0x07
   15a44:	8f 70       	andi	r24, 0x0F	; 15
   15a46:	98 0f       	add	r25, r24
   15a48:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   15a4a:	80 e0       	ldi	r24, 0x00	; 0
   15a4c:	90 e0       	ldi	r25, 0x00	; 0
   15a4e:	68 e0       	ldi	r22, 0x08	; 8
   15a50:	70 e0       	ldi	r23, 0x00	; 0
   15a52:	0e 94 21 ac 	call	0x15842	; 0x15842 <_rtc>
   15a56:	4a c0       	rjmp	.+148    	; 0x15aec <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   15a58:	80 e0       	ldi	r24, 0x00	; 0
   15a5a:	90 e0       	ldi	r25, 0x00	; 0
   15a5c:	68 e0       	ldi	r22, 0x08	; 8
   15a5e:	70 e0       	ldi	r23, 0x00	; 0
   15a60:	20 e0       	ldi	r18, 0x00	; 0
   15a62:	0e 94 21 ac 	call	0x15842	; 0x15842 <_rtc>
   15a66:	81 30       	cpi	r24, 0x01	; 1
   15a68:	09 f4       	brne	.+2      	; 0x15a6c <_datetime+0xa6>
   15a6a:	40 c0       	rjmp	.+128    	; 0x15aec <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   15a6c:	9d 81       	ldd	r25, Y+5	; 0x05
   15a6e:	89 2f       	mov	r24, r25
   15a70:	82 95       	swap	r24
   15a72:	8f 70       	andi	r24, 0x0F	; 15
   15a74:	80 5d       	subi	r24, 0xD0	; 208
   15a76:	f8 01       	movw	r30, r16
   15a78:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   15a7a:	9f 70       	andi	r25, 0x0F	; 15
   15a7c:	90 5d       	subi	r25, 0xD0	; 208
   15a7e:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   15a80:	2f e2       	ldi	r18, 0x2F	; 47
   15a82:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   15a84:	9e 81       	ldd	r25, Y+6	; 0x06
   15a86:	89 2f       	mov	r24, r25
   15a88:	82 95       	swap	r24
   15a8a:	8f 70       	andi	r24, 0x0F	; 15
   15a8c:	80 5d       	subi	r24, 0xD0	; 208
   15a8e:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   15a90:	9f 70       	andi	r25, 0x0F	; 15
   15a92:	90 5d       	subi	r25, 0xD0	; 208
   15a94:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   15a96:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   15a98:	9f 81       	ldd	r25, Y+7	; 0x07
   15a9a:	89 2f       	mov	r24, r25
   15a9c:	82 95       	swap	r24
   15a9e:	8f 70       	andi	r24, 0x0F	; 15
   15aa0:	80 5d       	subi	r24, 0xD0	; 208
   15aa2:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   15aa4:	9f 70       	andi	r25, 0x0F	; 15
   15aa6:	90 5d       	subi	r25, 0xD0	; 208
   15aa8:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   15aaa:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   15aac:	9b 81       	ldd	r25, Y+3	; 0x03
   15aae:	89 2f       	mov	r24, r25
   15ab0:	82 95       	swap	r24
   15ab2:	8f 70       	andi	r24, 0x0F	; 15
   15ab4:	80 5d       	subi	r24, 0xD0	; 208
   15ab6:	f7 01       	movw	r30, r14
   15ab8:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   15aba:	9f 70       	andi	r25, 0x0F	; 15
   15abc:	90 5d       	subi	r25, 0xD0	; 208
   15abe:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   15ac0:	2a e3       	ldi	r18, 0x3A	; 58
   15ac2:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   15ac4:	9a 81       	ldd	r25, Y+2	; 0x02
   15ac6:	89 2f       	mov	r24, r25
   15ac8:	82 95       	swap	r24
   15aca:	8f 70       	andi	r24, 0x0F	; 15
   15acc:	80 5d       	subi	r24, 0xD0	; 208
   15ace:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   15ad0:	9f 70       	andi	r25, 0x0F	; 15
   15ad2:	90 5d       	subi	r25, 0xD0	; 208
   15ad4:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   15ad6:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   15ad8:	99 81       	ldd	r25, Y+1	; 0x01
   15ada:	89 2f       	mov	r24, r25
   15adc:	82 95       	swap	r24
   15ade:	8f 70       	andi	r24, 0x0F	; 15
   15ae0:	80 5d       	subi	r24, 0xD0	; 208
   15ae2:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   15ae4:	9f 70       	andi	r25, 0x0F	; 15
   15ae6:	90 5d       	subi	r25, 0xD0	; 208
   15ae8:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   15aea:	10 86       	std	Z+8, r1	; 0x08
		}
}
   15aec:	64 96       	adiw	r28, 0x14	; 20
   15aee:	0f b6       	in	r0, 0x3f	; 63
   15af0:	f8 94       	cli
   15af2:	de bf       	out	0x3e, r29	; 62
   15af4:	0f be       	out	0x3f, r0	; 63
   15af6:	cd bf       	out	0x3d, r28	; 61
   15af8:	cf 91       	pop	r28
   15afa:	df 91       	pop	r29
   15afc:	1f 91       	pop	r17
   15afe:	0f 91       	pop	r16
   15b00:	ff 90       	pop	r15
   15b02:	ef 90       	pop	r14
   15b04:	08 95       	ret

00015b06 <_day>:

unsigned char _day(void){
   15b06:	df 93       	push	r29
   15b08:	cf 93       	push	r28
   15b0a:	cd b7       	in	r28, 0x3d	; 61
   15b0c:	de b7       	in	r29, 0x3e	; 62
   15b0e:	64 97       	sbiw	r28, 0x14	; 20
   15b10:	0f b6       	in	r0, 0x3f	; 63
   15b12:	f8 94       	cli
   15b14:	de bf       	out	0x3e, r29	; 62
   15b16:	0f be       	out	0x3f, r0	; 63
   15b18:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   15b1a:	80 e0       	ldi	r24, 0x00	; 0
   15b1c:	90 e0       	ldi	r25, 0x00	; 0
   15b1e:	68 e0       	ldi	r22, 0x08	; 8
   15b20:	70 e0       	ldi	r23, 0x00	; 0
   15b22:	ae 01       	movw	r20, r28
   15b24:	4f 5f       	subi	r20, 0xFF	; 255
   15b26:	5f 4f       	sbci	r21, 0xFF	; 255
   15b28:	20 e0       	ldi	r18, 0x00	; 0
   15b2a:	0e 94 21 ac 	call	0x15842	; 0x15842 <_rtc>
   15b2e:	81 30       	cpi	r24, 0x01	; 1
   15b30:	11 f4       	brne	.+4      	; 0x15b36 <_day+0x30>
   15b32:	80 e0       	ldi	r24, 0x00	; 0
   15b34:	02 c0       	rjmp	.+4      	; 0x15b3a <_day+0x34>
		return __datetime[3] & 0x0F;
   15b36:	8c 81       	ldd	r24, Y+4	; 0x04
   15b38:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   15b3a:	64 96       	adiw	r28, 0x14	; 20
   15b3c:	0f b6       	in	r0, 0x3f	; 63
   15b3e:	f8 94       	cli
   15b40:	de bf       	out	0x3e, r29	; 62
   15b42:	0f be       	out	0x3f, r0	; 63
   15b44:	cd bf       	out	0x3d, r28	; 61
   15b46:	cf 91       	pop	r28
   15b48:	df 91       	pop	r29
   15b4a:	08 95       	ret

00015b4c <uart_baudrate>:
	}

	uart_baudrate(__com, __baudrate);
}

void uart_baudrate(unsigned char __com, unsigned long __baudrate){
   15b4c:	1f 93       	push	r17
   15b4e:	18 2f       	mov	r17, r24
   15b50:	9a 01       	movw	r18, r20
   15b52:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   15b54:	ca 01       	movw	r24, r20
   15b56:	b9 01       	movw	r22, r18
   15b58:	60 50       	subi	r22, 0x00	; 0
   15b5a:	70 4e       	sbci	r23, 0xE0	; 224
   15b5c:	83 4e       	sbci	r24, 0xE3	; 227
   15b5e:	9f 4f       	sbci	r25, 0xFF	; 255
   15b60:	f3 e0       	ldi	r31, 0x03	; 3
   15b62:	66 0f       	add	r22, r22
   15b64:	77 1f       	adc	r23, r23
   15b66:	88 1f       	adc	r24, r24
   15b68:	99 1f       	adc	r25, r25
   15b6a:	fa 95       	dec	r31
   15b6c:	d1 f7       	brne	.-12     	; 0x15b62 <uart_baudrate+0x16>
   15b6e:	e4 e0       	ldi	r30, 0x04	; 4
   15b70:	22 0f       	add	r18, r18
   15b72:	33 1f       	adc	r19, r19
   15b74:	44 1f       	adc	r20, r20
   15b76:	55 1f       	adc	r21, r21
   15b78:	ea 95       	dec	r30
   15b7a:	d1 f7       	brne	.-12     	; 0x15b70 <uart_baudrate+0x24>
   15b7c:	0e 94 c5 b2 	call	0x1658a	; 0x1658a <__udivmodsi4>
   15b80:	21 50       	subi	r18, 0x01	; 1
   15b82:	30 40       	sbci	r19, 0x00	; 0
   15b84:	40 40       	sbci	r20, 0x00	; 0
   15b86:	50 40       	sbci	r21, 0x00	; 0
   15b88:	bb 27       	eor	r27, r27
   15b8a:	a5 2f       	mov	r26, r21
   15b8c:	94 2f       	mov	r25, r20
   15b8e:	83 2f       	mov	r24, r19

	if(__com){
   15b90:	11 23       	and	r17, r17
   15b92:	29 f0       	breq	.+10     	; 0x15b9e <uart_baudrate+0x52>
		UBRR1L = __br;
   15b94:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   15b98:	80 93 98 00 	sts	0x0098, r24
   15b9c:	03 c0       	rjmp	.+6      	; 0x15ba4 <uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   15b9e:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   15ba0:	80 93 90 00 	sts	0x0090, r24
	}
}
   15ba4:	1f 91       	pop	r17
   15ba6:	08 95       	ret

00015ba8 <uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void uart_init(unsigned char __com, unsigned long __baudrate){
   15ba8:	98 2f       	mov	r25, r24
	if(__com){
   15baa:	88 23       	and	r24, r24
   15bac:	39 f0       	breq	.+14     	; 0x15bbc <uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   15bae:	88 e9       	ldi	r24, 0x98	; 152
   15bb0:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   15bb4:	86 e0       	ldi	r24, 0x06	; 6
   15bb6:	80 93 9d 00 	sts	0x009D, r24
   15bba:	05 c0       	rjmp	.+10     	; 0x15bc6 <uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   15bbc:	88 e9       	ldi	r24, 0x98	; 152
   15bbe:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   15bc0:	86 e0       	ldi	r24, 0x06	; 6
   15bc2:	80 93 95 00 	sts	0x0095, r24
	}

	uart_baudrate(__com, __baudrate);
   15bc6:	89 2f       	mov	r24, r25
   15bc8:	0e 94 a6 ad 	call	0x15b4c	; 0x15b4c <uart_baudrate>
}
   15bcc:	08 95       	ret

00015bce <uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   15bce:	88 23       	and	r24, r24
   15bd0:	81 f0       	breq	.+32     	; 0x15bf2 <uart+0x24>
		if(__dir){
   15bd2:	66 23       	and	r22, r22
   15bd4:	39 f0       	breq	.+14     	; 0x15be4 <uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   15bd6:	80 91 9b 00 	lds	r24, 0x009B
   15bda:	85 ff       	sbrs	r24, 5
   15bdc:	fc cf       	rjmp	.-8      	; 0x15bd6 <uart+0x8>
			UDR1 = __chr;
   15bde:	40 93 9c 00 	sts	0x009C, r20
   15be2:	0c c0       	rjmp	.+24     	; 0x15bfc <uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   15be4:	80 91 9b 00 	lds	r24, 0x009B
   15be8:	87 ff       	sbrs	r24, 7
   15bea:	fc cf       	rjmp	.-8      	; 0x15be4 <uart+0x16>
			return UDR1;
   15bec:	80 91 9c 00 	lds	r24, 0x009C
   15bf0:	08 95       	ret
		}
	}
	else{
		if(__dir){
   15bf2:	66 23       	and	r22, r22
   15bf4:	29 f0       	breq	.+10     	; 0x15c00 <uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   15bf6:	5d 9b       	sbis	0x0b, 5	; 11
   15bf8:	fe cf       	rjmp	.-4      	; 0x15bf6 <uart+0x28>
			UDR0 = __chr;
   15bfa:	4c b9       	out	0x0c, r20	; 12
   15bfc:	81 e0       	ldi	r24, 0x01	; 1
   15bfe:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   15c00:	5f 9b       	sbis	0x0b, 7	; 11
   15c02:	fe cf       	rjmp	.-4      	; 0x15c00 <uart+0x32>
			return UDR0;
   15c04:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   15c06:	08 95       	ret

00015c08 <uart_print>:

void uart_print(unsigned char __com, unsigned char __ret, char *__str){
   15c08:	0f 93       	push	r16
   15c0a:	1f 93       	push	r17
   15c0c:	cf 93       	push	r28
   15c0e:	df 93       	push	r29
   15c10:	18 2f       	mov	r17, r24
   15c12:	06 2f       	mov	r16, r22
   15c14:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   15c16:	88 81       	ld	r24, Y
   15c18:	88 23       	and	r24, r24
   15c1a:	31 f4       	brne	.+12     	; 0x15c28 <uart_print+0x20>
   15c1c:	08 c0       	rjmp	.+16     	; 0x15c2e <uart_print+0x26>
		while(*__str)
		     uart(__com, 1, *__str++);
   15c1e:	21 96       	adiw	r28, 0x01	; 1
   15c20:	81 2f       	mov	r24, r17
   15c22:	61 e0       	ldi	r22, 0x01	; 1
   15c24:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
	return 1;
}

void uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   15c28:	48 81       	ld	r20, Y
   15c2a:	44 23       	and	r20, r20
   15c2c:	c1 f7       	brne	.-16     	; 0x15c1e <uart_print+0x16>
		     uart(__com, 1, *__str++);

	if(__ret){
   15c2e:	00 23       	and	r16, r16
   15c30:	51 f0       	breq	.+20     	; 0x15c46 <uart_print+0x3e>
		uart(__com, 1, 0x0D);
   15c32:	81 2f       	mov	r24, r17
   15c34:	61 e0       	ldi	r22, 0x01	; 1
   15c36:	4d e0       	ldi	r20, 0x0D	; 13
   15c38:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		uart(__com, 1, 0x0A);
   15c3c:	81 2f       	mov	r24, r17
   15c3e:	61 e0       	ldi	r22, 0x01	; 1
   15c40:	4a e0       	ldi	r20, 0x0A	; 10
   15c42:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
   15c46:	80 e0       	ldi	r24, 0x00	; 0
   15c48:	98 e4       	ldi	r25, 0x48	; 72
   15c4a:	01 97       	sbiw	r24, 0x01	; 1
   15c4c:	f1 f7       	brne	.-4      	; 0x15c4a <uart_print+0x42>
	}
	_delay_ms(5);
}
   15c4e:	df 91       	pop	r29
   15c50:	cf 91       	pop	r28
   15c52:	1f 91       	pop	r17
   15c54:	0f 91       	pop	r16
   15c56:	08 95       	ret

00015c58 <uart_printf>:

void uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   15c58:	0f 93       	push	r16
   15c5a:	1f 93       	push	r17
   15c5c:	cf 93       	push	r28
   15c5e:	df 93       	push	r29
   15c60:	18 2f       	mov	r17, r24
   15c62:	06 2f       	mov	r16, r22
   15c64:	ea 01       	movw	r28, r20
   15c66:	07 c0       	rjmp	.+14     	; 0x15c76 <uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		uart(__com, 1, pgm_read_byte(&(*__str++)));
   15c68:	21 96       	adiw	r28, 0x01	; 1
   15c6a:	f9 01       	movw	r30, r18
   15c6c:	44 91       	lpm	r20, Z+
   15c6e:	81 2f       	mov	r24, r17
   15c70:	61 e0       	ldi	r22, 0x01	; 1
   15c72:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
   15c76:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   15c78:	fe 01       	movw	r30, r28
   15c7a:	84 91       	lpm	r24, Z+
   15c7c:	88 23       	and	r24, r24
   15c7e:	a1 f7       	brne	.-24     	; 0x15c68 <uart_printf+0x10>
		uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   15c80:	00 23       	and	r16, r16
   15c82:	51 f0       	breq	.+20     	; 0x15c98 <uart_printf+0x40>
		uart(__com, 1, 0x0D);
   15c84:	81 2f       	mov	r24, r17
   15c86:	61 e0       	ldi	r22, 0x01	; 1
   15c88:	4d e0       	ldi	r20, 0x0D	; 13
   15c8a:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
		uart(__com, 1, 0x0A);
   15c8e:	81 2f       	mov	r24, r17
   15c90:	61 e0       	ldi	r22, 0x01	; 1
   15c92:	4a e0       	ldi	r20, 0x0A	; 10
   15c94:	0e 94 e7 ad 	call	0x15bce	; 0x15bce <uart>
   15c98:	80 e0       	ldi	r24, 0x00	; 0
   15c9a:	98 ed       	ldi	r25, 0xD8	; 216
   15c9c:	01 97       	sbiw	r24, 0x01	; 1
   15c9e:	f1 f7       	brne	.-4      	; 0x15c9c <uart_printf+0x44>
	}
	_delay_ms(15);
}
   15ca0:	df 91       	pop	r29
   15ca2:	cf 91       	pop	r28
   15ca4:	1f 91       	pop	r17
   15ca6:	0f 91       	pop	r16
   15ca8:	08 95       	ret

00015caa <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   15caa:	6f 92       	push	r6
   15cac:	7f 92       	push	r7
   15cae:	8f 92       	push	r8
   15cb0:	9f 92       	push	r9
   15cb2:	af 92       	push	r10
   15cb4:	bf 92       	push	r11
   15cb6:	cf 92       	push	r12
   15cb8:	df 92       	push	r13
   15cba:	ef 92       	push	r14
   15cbc:	ff 92       	push	r15
   15cbe:	0f 93       	push	r16
   15cc0:	1f 93       	push	r17
   15cc2:	cf 93       	push	r28
   15cc4:	df 93       	push	r29
   15cc6:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   15cc8:	41 15       	cp	r20, r1
   15cca:	51 05       	cpc	r21, r1
   15ccc:	61 05       	cpc	r22, r1
   15cce:	71 05       	cpc	r23, r1
   15cd0:	21 f4       	brne	.+8      	; 0x15cda <Int2Str+0x30>
		__string[0] = '0';
   15cd2:	80 e3       	ldi	r24, 0x30	; 48
   15cd4:	88 83       	st	Y, r24
		__string[1] = '\0';
   15cd6:	19 82       	std	Y+1, r1	; 0x01
   15cd8:	48 c0       	rjmp	.+144    	; 0x15d6a <Int2Str+0xc0>
		return;
   15cda:	4a 01       	movw	r8, r20
   15cdc:	5b 01       	movw	r10, r22
   15cde:	10 e0       	ldi	r17, 0x00	; 0
   15ce0:	00 e0       	ldi	r16, 0x00	; 0
   15ce2:	77 24       	eor	r7, r7
   15ce4:	c1 2c       	mov	r12, r1
   15ce6:	ba ec       	ldi	r27, 0xCA	; 202
   15ce8:	db 2e       	mov	r13, r27
   15cea:	ba e9       	ldi	r27, 0x9A	; 154
   15cec:	eb 2e       	mov	r14, r27
   15cee:	bb e3       	ldi	r27, 0x3B	; 59
   15cf0:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   15cf2:	a0 e3       	ldi	r26, 0x30	; 48
   15cf4:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   15cf6:	8c 14       	cp	r8, r12
   15cf8:	9d 04       	cpc	r9, r13
   15cfa:	ae 04       	cpc	r10, r14
   15cfc:	bf 04       	cpc	r11, r15
   15cfe:	d0 f0       	brcs	.+52     	; 0x15d34 <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   15d00:	c5 01       	movw	r24, r10
   15d02:	b4 01       	movw	r22, r8
   15d04:	a7 01       	movw	r20, r14
   15d06:	96 01       	movw	r18, r12
   15d08:	0e 94 c5 b2 	call	0x1658a	; 0x1658a <__udivmodsi4>
   15d0c:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   15d0e:	c5 01       	movw	r24, r10
   15d10:	b4 01       	movw	r22, r8
   15d12:	a7 01       	movw	r20, r14
   15d14:	96 01       	movw	r18, r12
   15d16:	0e 94 c5 b2 	call	0x1658a	; 0x1658a <__udivmodsi4>
   15d1a:	ac 01       	movw	r20, r24
   15d1c:	cb 01       	movw	r24, r22
   15d1e:	da 01       	movw	r26, r20
   15d20:	4c 01       	movw	r8, r24
   15d22:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   15d24:	fe 01       	movw	r30, r28
   15d26:	e0 0f       	add	r30, r16
   15d28:	f1 1d       	adc	r31, r1
   15d2a:	10 5d       	subi	r17, 0xD0	; 208
   15d2c:	10 83       	st	Z, r17
   15d2e:	0f 5f       	subi	r16, 0xFF	; 255
   15d30:	11 e0       	ldi	r17, 0x01	; 1
   15d32:	07 c0       	rjmp	.+14     	; 0x15d42 <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   15d34:	11 23       	and	r17, r17
   15d36:	29 f0       	breq	.+10     	; 0x15d42 <Int2Str+0x98>
				__string[__i++] = 0x30;
   15d38:	fe 01       	movw	r30, r28
   15d3a:	e0 0f       	add	r30, r16
   15d3c:	f1 1d       	adc	r31, r1
   15d3e:	60 82       	st	Z, r6
   15d40:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   15d42:	73 94       	inc	r7
   15d44:	8a e0       	ldi	r24, 0x0A	; 10
   15d46:	78 16       	cp	r7, r24
   15d48:	69 f0       	breq	.+26     	; 0x15d64 <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   15d4a:	c7 01       	movw	r24, r14
   15d4c:	b6 01       	movw	r22, r12
   15d4e:	2a e0       	ldi	r18, 0x0A	; 10
   15d50:	30 e0       	ldi	r19, 0x00	; 0
   15d52:	40 e0       	ldi	r20, 0x00	; 0
   15d54:	50 e0       	ldi	r21, 0x00	; 0
   15d56:	0e 94 c5 b2 	call	0x1658a	; 0x1658a <__udivmodsi4>
   15d5a:	c9 01       	movw	r24, r18
   15d5c:	da 01       	movw	r26, r20
   15d5e:	6c 01       	movw	r12, r24
   15d60:	7d 01       	movw	r14, r26
   15d62:	c9 cf       	rjmp	.-110    	; 0x15cf6 <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   15d64:	c0 0f       	add	r28, r16
   15d66:	d1 1d       	adc	r29, r1
   15d68:	18 82       	st	Y, r1
}
   15d6a:	df 91       	pop	r29
   15d6c:	cf 91       	pop	r28
   15d6e:	1f 91       	pop	r17
   15d70:	0f 91       	pop	r16
   15d72:	ff 90       	pop	r15
   15d74:	ef 90       	pop	r14
   15d76:	df 90       	pop	r13
   15d78:	cf 90       	pop	r12
   15d7a:	bf 90       	pop	r11
   15d7c:	af 90       	pop	r10
   15d7e:	9f 90       	pop	r9
   15d80:	8f 90       	pop	r8
   15d82:	7f 90       	pop	r7
   15d84:	6f 90       	pop	r6
   15d86:	08 95       	ret

00015d88 <Str2Int>:

unsigned long Str2Int(char* __string){
   15d88:	6f 92       	push	r6
   15d8a:	7f 92       	push	r7
   15d8c:	8f 92       	push	r8
   15d8e:	9f 92       	push	r9
   15d90:	af 92       	push	r10
   15d92:	bf 92       	push	r11
   15d94:	cf 92       	push	r12
   15d96:	df 92       	push	r13
   15d98:	ef 92       	push	r14
   15d9a:	ff 92       	push	r15
   15d9c:	0f 93       	push	r16
   15d9e:	1f 93       	push	r17
   15da0:	cf 93       	push	r28
   15da2:	df 93       	push	r29
   15da4:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   15da6:	dc 01       	movw	r26, r24
   15da8:	0d 90       	ld	r0, X+
   15daa:	00 20       	and	r0, r0
   15dac:	e9 f7       	brne	.-6      	; 0x15da8 <Str2Int+0x20>
   15dae:	11 97       	sbiw	r26, 0x01	; 1
   15db0:	7a 2e       	mov	r7, r26
   15db2:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   15db4:	87 2d       	mov	r24, r7
   15db6:	81 50       	subi	r24, 0x01	; 1
   15db8:	8a 30       	cpi	r24, 0x0A	; 10
   15dba:	08 f0       	brcs	.+2      	; 0x15dbe <Str2Int+0x36>
   15dbc:	64 c0       	rjmp	.+200    	; 0x15e86 <Str2Int+0xfe>
   15dbe:	4e 01       	movw	r8, r28
   15dc0:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   15dc2:	6c 2e       	mov	r6, r28
   15dc4:	05 c0       	rjmp	.+10     	; 0x15dd0 <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   15dc6:	81 91       	ld	r24, Z+
   15dc8:	80 53       	subi	r24, 0x30	; 48
   15dca:	8a 30       	cpi	r24, 0x0A	; 10
   15dcc:	08 f0       	brcs	.+2      	; 0x15dd0 <Str2Int+0x48>
   15dce:	5b c0       	rjmp	.+182    	; 0x15e86 <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   15dd0:	8e 2f       	mov	r24, r30
   15dd2:	86 19       	sub	r24, r6
   15dd4:	87 15       	cp	r24, r7
   15dd6:	b8 f3       	brcs	.-18     	; 0x15dc6 <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   15dd8:	8a e0       	ldi	r24, 0x0A	; 10
   15dda:	78 16       	cp	r7, r24
   15ddc:	f9 f4       	brne	.+62     	; 0x15e1c <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   15dde:	98 81       	ld	r25, Y
   15de0:	89 2f       	mov	r24, r25
   15de2:	80 53       	subi	r24, 0x30	; 48
   15de4:	83 30       	cpi	r24, 0x03	; 3
   15de6:	08 f0       	brcs	.+2      	; 0x15dea <Str2Int+0x62>
   15de8:	4e c0       	rjmp	.+156    	; 0x15e86 <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   15dea:	92 33       	cpi	r25, 0x32	; 50
   15dec:	b9 f4       	brne	.+46     	; 0x15e1c <Str2Int+0x94>
   15dee:	fe 01       	movw	r30, r28
   15df0:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   15df2:	81 81       	ldd	r24, Z+1	; 0x01
   15df4:	80 33       	cpi	r24, 0x30	; 48
   15df6:	09 f0       	breq	.+2      	; 0x15dfa <Str2Int+0x72>
   15df8:	46 c0       	rjmp	.+140    	; 0x15e86 <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   15dfa:	9f 5f       	subi	r25, 0xFF	; 255
   15dfc:	31 96       	adiw	r30, 0x01	; 1
   15dfe:	9a 30       	cpi	r25, 0x0A	; 10
   15e00:	c1 f7       	brne	.-16     	; 0x15df2 <Str2Int+0x6a>
   15e02:	0c c0       	rjmp	.+24     	; 0x15e1c <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   15e04:	c6 01       	movw	r24, r12
   15e06:	b5 01       	movw	r22, r10
   15e08:	2a e0       	ldi	r18, 0x0A	; 10
   15e0a:	30 e0       	ldi	r19, 0x00	; 0
   15e0c:	40 e0       	ldi	r20, 0x00	; 0
   15e0e:	50 e0       	ldi	r21, 0x00	; 0
   15e10:	0e 94 66 b2 	call	0x164cc	; 0x164cc <__mulsi3>
   15e14:	5b 01       	movw	r10, r22
   15e16:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   15e18:	1f 5f       	subi	r17, 0xFF	; 255
   15e1a:	09 c0       	rjmp	.+18     	; 0x15e2e <Str2Int+0xa6>
   15e1c:	10 e0       	ldi	r17, 0x00	; 0
   15e1e:	01 e0       	ldi	r16, 0x01	; 1
   15e20:	a0 2e       	mov	r10, r16
   15e22:	b1 2c       	mov	r11, r1
   15e24:	c1 2c       	mov	r12, r1
   15e26:	d1 2c       	mov	r13, r1
   15e28:	c7 2d       	mov	r28, r7
   15e2a:	d0 e0       	ldi	r29, 0x00	; 0
   15e2c:	21 97       	sbiw	r28, 0x01	; 1
   15e2e:	81 2f       	mov	r24, r17
   15e30:	90 e0       	ldi	r25, 0x00	; 0
   15e32:	8c 17       	cp	r24, r28
   15e34:	9d 07       	cpc	r25, r29
   15e36:	34 f3       	brlt	.-52     	; 0x15e04 <Str2Int+0x7c>
   15e38:	ee 24       	eor	r14, r14
   15e3a:	ff 24       	eor	r15, r15
   15e3c:	87 01       	movw	r16, r14
   15e3e:	1e c0       	rjmp	.+60     	; 0x15e7c <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   15e40:	f4 01       	movw	r30, r8
   15e42:	21 91       	ld	r18, Z+
   15e44:	4f 01       	movw	r8, r30
   15e46:	30 e0       	ldi	r19, 0x00	; 0
   15e48:	20 53       	subi	r18, 0x30	; 48
   15e4a:	30 40       	sbci	r19, 0x00	; 0
   15e4c:	44 27       	eor	r20, r20
   15e4e:	37 fd       	sbrc	r19, 7
   15e50:	40 95       	com	r20
   15e52:	54 2f       	mov	r21, r20
   15e54:	c6 01       	movw	r24, r12
   15e56:	b5 01       	movw	r22, r10
   15e58:	0e 94 66 b2 	call	0x164cc	; 0x164cc <__mulsi3>
   15e5c:	e6 0e       	add	r14, r22
   15e5e:	f7 1e       	adc	r15, r23
   15e60:	08 1f       	adc	r16, r24
   15e62:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   15e64:	c6 01       	movw	r24, r12
   15e66:	b5 01       	movw	r22, r10
   15e68:	2a e0       	ldi	r18, 0x0A	; 10
   15e6a:	30 e0       	ldi	r19, 0x00	; 0
   15e6c:	40 e0       	ldi	r20, 0x00	; 0
   15e6e:	50 e0       	ldi	r21, 0x00	; 0
   15e70:	0e 94 c5 b2 	call	0x1658a	; 0x1658a <__udivmodsi4>
   15e74:	c9 01       	movw	r24, r18
   15e76:	da 01       	movw	r26, r20
   15e78:	5c 01       	movw	r10, r24
   15e7a:	6d 01       	movw	r12, r26
   15e7c:	88 2d       	mov	r24, r8
   15e7e:	86 19       	sub	r24, r6
   15e80:	87 15       	cp	r24, r7
   15e82:	f0 f2       	brcs	.-68     	; 0x15e40 <Str2Int+0xb8>
   15e84:	03 c0       	rjmp	.+6      	; 0x15e8c <Str2Int+0x104>
   15e86:	ee 24       	eor	r14, r14
   15e88:	ff 24       	eor	r15, r15
   15e8a:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   15e8c:	b7 01       	movw	r22, r14
   15e8e:	c8 01       	movw	r24, r16
   15e90:	df 91       	pop	r29
   15e92:	cf 91       	pop	r28
   15e94:	1f 91       	pop	r17
   15e96:	0f 91       	pop	r16
   15e98:	ff 90       	pop	r15
   15e9a:	ef 90       	pop	r14
   15e9c:	df 90       	pop	r13
   15e9e:	cf 90       	pop	r12
   15ea0:	bf 90       	pop	r11
   15ea2:	af 90       	pop	r10
   15ea4:	9f 90       	pop	r9
   15ea6:	8f 90       	pop	r8
   15ea8:	7f 90       	pop	r7
   15eaa:	6f 90       	pop	r6
   15eac:	08 95       	ret

00015eae <atoi>:
   15eae:	fc 01       	movw	r30, r24
   15eb0:	88 27       	eor	r24, r24
   15eb2:	99 27       	eor	r25, r25
   15eb4:	e8 94       	clt
   15eb6:	21 91       	ld	r18, Z+
   15eb8:	20 32       	cpi	r18, 0x20	; 32
   15eba:	e9 f3       	breq	.-6      	; 0x15eb6 <atoi+0x8>
   15ebc:	29 30       	cpi	r18, 0x09	; 9
   15ebe:	10 f0       	brcs	.+4      	; 0x15ec4 <atoi+0x16>
   15ec0:	2e 30       	cpi	r18, 0x0E	; 14
   15ec2:	c8 f3       	brcs	.-14     	; 0x15eb6 <atoi+0x8>
   15ec4:	2b 32       	cpi	r18, 0x2B	; 43
   15ec6:	41 f0       	breq	.+16     	; 0x15ed8 <atoi+0x2a>
   15ec8:	2d 32       	cpi	r18, 0x2D	; 45
   15eca:	39 f4       	brne	.+14     	; 0x15eda <atoi+0x2c>
   15ecc:	68 94       	set
   15ece:	04 c0       	rjmp	.+8      	; 0x15ed8 <atoi+0x2a>
   15ed0:	0e 94 bd af 	call	0x15f7a	; 0x15f7a <__mulhi_const_10>
   15ed4:	82 0f       	add	r24, r18
   15ed6:	91 1d       	adc	r25, r1
   15ed8:	21 91       	ld	r18, Z+
   15eda:	20 53       	subi	r18, 0x30	; 48
   15edc:	2a 30       	cpi	r18, 0x0A	; 10
   15ede:	c0 f3       	brcs	.-16     	; 0x15ed0 <atoi+0x22>
   15ee0:	1e f4       	brtc	.+6      	; 0x15ee8 <atoi+0x3a>
   15ee2:	90 95       	com	r25
   15ee4:	81 95       	neg	r24
   15ee6:	9f 4f       	sbci	r25, 0xFF	; 255
   15ee8:	08 95       	ret

00015eea <strcpy_P>:
   15eea:	fb 01       	movw	r30, r22
   15eec:	dc 01       	movw	r26, r24
   15eee:	05 90       	lpm	r0, Z+
   15ef0:	0d 92       	st	X+, r0
   15ef2:	00 20       	and	r0, r0
   15ef4:	e1 f7       	brne	.-8      	; 0x15eee <strcpy_P+0x4>
   15ef6:	08 95       	ret

00015ef8 <strcmp>:
   15ef8:	fb 01       	movw	r30, r22
   15efa:	dc 01       	movw	r26, r24
   15efc:	8d 91       	ld	r24, X+
   15efe:	01 90       	ld	r0, Z+
   15f00:	80 19       	sub	r24, r0
   15f02:	01 10       	cpse	r0, r1
   15f04:	d9 f3       	breq	.-10     	; 0x15efc <strcmp+0x4>
   15f06:	99 0b       	sbc	r25, r25
   15f08:	08 95       	ret

00015f0a <__eerd_block>:
   15f0a:	a0 e0       	ldi	r26, 0x00	; 0
   15f0c:	b0 e0       	ldi	r27, 0x00	; 0
   15f0e:	eb e8       	ldi	r30, 0x8B	; 139
   15f10:	ff ea       	ldi	r31, 0xAF	; 175
   15f12:	0c 94 f1 b2 	jmp	0x165e2	; 0x165e2 <__prologue_saves__+0x14>
   15f16:	7c 01       	movw	r14, r24
   15f18:	eb 01       	movw	r28, r22
   15f1a:	8a 01       	movw	r16, r20
   15f1c:	69 01       	movw	r12, r18
   15f1e:	09 c0       	rjmp	.+18     	; 0x15f32 <__eerd_block+0x28>
   15f20:	ce 01       	movw	r24, r28
   15f22:	21 96       	adiw	r28, 0x01	; 1
   15f24:	f6 01       	movw	r30, r12
   15f26:	09 95       	icall
   15f28:	f7 01       	movw	r30, r14
   15f2a:	81 93       	st	Z+, r24
   15f2c:	7f 01       	movw	r14, r30
   15f2e:	01 50       	subi	r16, 0x01	; 1
   15f30:	10 40       	sbci	r17, 0x00	; 0
   15f32:	01 15       	cp	r16, r1
   15f34:	11 05       	cpc	r17, r1
   15f36:	a1 f7       	brne	.-24     	; 0x15f20 <__eerd_block+0x16>
   15f38:	cd b7       	in	r28, 0x3d	; 61
   15f3a:	de b7       	in	r29, 0x3e	; 62
   15f3c:	e8 e0       	ldi	r30, 0x08	; 8
   15f3e:	0c 94 0d b3 	jmp	0x1661a	; 0x1661a <__epilogue_restores__+0x14>

00015f42 <__eewr_block>:
   15f42:	a0 e0       	ldi	r26, 0x00	; 0
   15f44:	b0 e0       	ldi	r27, 0x00	; 0
   15f46:	e7 ea       	ldi	r30, 0xA7	; 167
   15f48:	ff ea       	ldi	r31, 0xAF	; 175
   15f4a:	0c 94 f1 b2 	jmp	0x165e2	; 0x165e2 <__prologue_saves__+0x14>
   15f4e:	ec 01       	movw	r28, r24
   15f50:	7b 01       	movw	r14, r22
   15f52:	8a 01       	movw	r16, r20
   15f54:	69 01       	movw	r12, r18
   15f56:	09 c0       	rjmp	.+18     	; 0x15f6a <__eewr_block+0x28>
   15f58:	ce 01       	movw	r24, r28
   15f5a:	21 96       	adiw	r28, 0x01	; 1
   15f5c:	f7 01       	movw	r30, r14
   15f5e:	61 91       	ld	r22, Z+
   15f60:	7f 01       	movw	r14, r30
   15f62:	f6 01       	movw	r30, r12
   15f64:	09 95       	icall
   15f66:	01 50       	subi	r16, 0x01	; 1
   15f68:	10 40       	sbci	r17, 0x00	; 0
   15f6a:	01 15       	cp	r16, r1
   15f6c:	11 05       	cpc	r17, r1
   15f6e:	a1 f7       	brne	.-24     	; 0x15f58 <__eewr_block+0x16>
   15f70:	cd b7       	in	r28, 0x3d	; 61
   15f72:	de b7       	in	r29, 0x3e	; 62
   15f74:	e8 e0       	ldi	r30, 0x08	; 8
   15f76:	0c 94 0d b3 	jmp	0x1661a	; 0x1661a <__epilogue_restores__+0x14>

00015f7a <__mulhi_const_10>:
   15f7a:	7a e0       	ldi	r23, 0x0A	; 10
   15f7c:	97 9f       	mul	r25, r23
   15f7e:	90 2d       	mov	r25, r0
   15f80:	87 9f       	mul	r24, r23
   15f82:	80 2d       	mov	r24, r0
   15f84:	91 0d       	add	r25, r1
   15f86:	11 24       	eor	r1, r1
   15f88:	08 95       	ret

00015f8a <sprintf_P>:
   15f8a:	ae e0       	ldi	r26, 0x0E	; 14
   15f8c:	b0 e0       	ldi	r27, 0x00	; 0
   15f8e:	eb ec       	ldi	r30, 0xCB	; 203
   15f90:	ff ea       	ldi	r31, 0xAF	; 175
   15f92:	0c 94 f5 b2 	jmp	0x165ea	; 0x165ea <__prologue_saves__+0x1c>
   15f96:	0d 89       	ldd	r16, Y+21	; 0x15
   15f98:	1e 89       	ldd	r17, Y+22	; 0x16
   15f9a:	8e e0       	ldi	r24, 0x0E	; 14
   15f9c:	8c 83       	std	Y+4, r24	; 0x04
   15f9e:	1a 83       	std	Y+2, r17	; 0x02
   15fa0:	09 83       	std	Y+1, r16	; 0x01
   15fa2:	8f ef       	ldi	r24, 0xFF	; 255
   15fa4:	9f e7       	ldi	r25, 0x7F	; 127
   15fa6:	9e 83       	std	Y+6, r25	; 0x06
   15fa8:	8d 83       	std	Y+5, r24	; 0x05
   15faa:	9e 01       	movw	r18, r28
   15fac:	27 5e       	subi	r18, 0xE7	; 231
   15fae:	3f 4f       	sbci	r19, 0xFF	; 255
   15fb0:	ce 01       	movw	r24, r28
   15fb2:	01 96       	adiw	r24, 0x01	; 1
   15fb4:	6f 89       	ldd	r22, Y+23	; 0x17
   15fb6:	78 8d       	ldd	r23, Y+24	; 0x18
   15fb8:	a9 01       	movw	r20, r18
   15fba:	0e 94 e9 af 	call	0x15fd2	; 0x15fd2 <vfprintf>
   15fbe:	2f 81       	ldd	r18, Y+7	; 0x07
   15fc0:	38 85       	ldd	r19, Y+8	; 0x08
   15fc2:	02 0f       	add	r16, r18
   15fc4:	13 1f       	adc	r17, r19
   15fc6:	f8 01       	movw	r30, r16
   15fc8:	10 82       	st	Z, r1
   15fca:	2e 96       	adiw	r28, 0x0e	; 14
   15fcc:	e4 e0       	ldi	r30, 0x04	; 4
   15fce:	0c 94 11 b3 	jmp	0x16622	; 0x16622 <__epilogue_restores__+0x1c>

00015fd2 <vfprintf>:
   15fd2:	ab e0       	ldi	r26, 0x0B	; 11
   15fd4:	b0 e0       	ldi	r27, 0x00	; 0
   15fd6:	ef ee       	ldi	r30, 0xEF	; 239
   15fd8:	ff ea       	ldi	r31, 0xAF	; 175
   15fda:	0c 94 e7 b2 	jmp	0x165ce	; 0x165ce <__prologue_saves__>
   15fde:	3c 01       	movw	r6, r24
   15fe0:	2b 01       	movw	r4, r22
   15fe2:	5a 01       	movw	r10, r20
   15fe4:	fc 01       	movw	r30, r24
   15fe6:	17 82       	std	Z+7, r1	; 0x07
   15fe8:	16 82       	std	Z+6, r1	; 0x06
   15fea:	83 81       	ldd	r24, Z+3	; 0x03
   15fec:	81 fd       	sbrc	r24, 1
   15fee:	03 c0       	rjmp	.+6      	; 0x15ff6 <vfprintf+0x24>
   15ff0:	6f ef       	ldi	r22, 0xFF	; 255
   15ff2:	7f ef       	ldi	r23, 0xFF	; 255
   15ff4:	c6 c1       	rjmp	.+908    	; 0x16382 <vfprintf+0x3b0>
   15ff6:	9a e0       	ldi	r25, 0x0A	; 10
   15ff8:	89 2e       	mov	r8, r25
   15ffa:	1e 01       	movw	r2, r28
   15ffc:	08 94       	sec
   15ffe:	21 1c       	adc	r2, r1
   16000:	31 1c       	adc	r3, r1
   16002:	f3 01       	movw	r30, r6
   16004:	23 81       	ldd	r18, Z+3	; 0x03
   16006:	f2 01       	movw	r30, r4
   16008:	23 fd       	sbrc	r18, 3
   1600a:	85 91       	lpm	r24, Z+
   1600c:	23 ff       	sbrs	r18, 3
   1600e:	81 91       	ld	r24, Z+
   16010:	2f 01       	movw	r4, r30
   16012:	88 23       	and	r24, r24
   16014:	09 f4       	brne	.+2      	; 0x16018 <vfprintf+0x46>
   16016:	b2 c1       	rjmp	.+868    	; 0x1637c <vfprintf+0x3aa>
   16018:	85 32       	cpi	r24, 0x25	; 37
   1601a:	39 f4       	brne	.+14     	; 0x1602a <vfprintf+0x58>
   1601c:	23 fd       	sbrc	r18, 3
   1601e:	85 91       	lpm	r24, Z+
   16020:	23 ff       	sbrs	r18, 3
   16022:	81 91       	ld	r24, Z+
   16024:	2f 01       	movw	r4, r30
   16026:	85 32       	cpi	r24, 0x25	; 37
   16028:	29 f4       	brne	.+10     	; 0x16034 <vfprintf+0x62>
   1602a:	90 e0       	ldi	r25, 0x00	; 0
   1602c:	b3 01       	movw	r22, r6
   1602e:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   16032:	e7 cf       	rjmp	.-50     	; 0x16002 <vfprintf+0x30>
   16034:	98 2f       	mov	r25, r24
   16036:	ff 24       	eor	r15, r15
   16038:	ee 24       	eor	r14, r14
   1603a:	99 24       	eor	r9, r9
   1603c:	ff e1       	ldi	r31, 0x1F	; 31
   1603e:	ff 15       	cp	r31, r15
   16040:	d0 f0       	brcs	.+52     	; 0x16076 <vfprintf+0xa4>
   16042:	9b 32       	cpi	r25, 0x2B	; 43
   16044:	69 f0       	breq	.+26     	; 0x16060 <vfprintf+0x8e>
   16046:	9c 32       	cpi	r25, 0x2C	; 44
   16048:	28 f4       	brcc	.+10     	; 0x16054 <vfprintf+0x82>
   1604a:	90 32       	cpi	r25, 0x20	; 32
   1604c:	59 f0       	breq	.+22     	; 0x16064 <vfprintf+0x92>
   1604e:	93 32       	cpi	r25, 0x23	; 35
   16050:	91 f4       	brne	.+36     	; 0x16076 <vfprintf+0xa4>
   16052:	0e c0       	rjmp	.+28     	; 0x16070 <vfprintf+0x9e>
   16054:	9d 32       	cpi	r25, 0x2D	; 45
   16056:	49 f0       	breq	.+18     	; 0x1606a <vfprintf+0x98>
   16058:	90 33       	cpi	r25, 0x30	; 48
   1605a:	69 f4       	brne	.+26     	; 0x16076 <vfprintf+0xa4>
   1605c:	41 e0       	ldi	r20, 0x01	; 1
   1605e:	24 c0       	rjmp	.+72     	; 0x160a8 <vfprintf+0xd6>
   16060:	52 e0       	ldi	r21, 0x02	; 2
   16062:	f5 2a       	or	r15, r21
   16064:	84 e0       	ldi	r24, 0x04	; 4
   16066:	f8 2a       	or	r15, r24
   16068:	28 c0       	rjmp	.+80     	; 0x160ba <vfprintf+0xe8>
   1606a:	98 e0       	ldi	r25, 0x08	; 8
   1606c:	f9 2a       	or	r15, r25
   1606e:	25 c0       	rjmp	.+74     	; 0x160ba <vfprintf+0xe8>
   16070:	e0 e1       	ldi	r30, 0x10	; 16
   16072:	fe 2a       	or	r15, r30
   16074:	22 c0       	rjmp	.+68     	; 0x160ba <vfprintf+0xe8>
   16076:	f7 fc       	sbrc	r15, 7
   16078:	29 c0       	rjmp	.+82     	; 0x160cc <vfprintf+0xfa>
   1607a:	89 2f       	mov	r24, r25
   1607c:	80 53       	subi	r24, 0x30	; 48
   1607e:	8a 30       	cpi	r24, 0x0A	; 10
   16080:	70 f4       	brcc	.+28     	; 0x1609e <vfprintf+0xcc>
   16082:	f6 fe       	sbrs	r15, 6
   16084:	05 c0       	rjmp	.+10     	; 0x16090 <vfprintf+0xbe>
   16086:	98 9c       	mul	r9, r8
   16088:	90 2c       	mov	r9, r0
   1608a:	11 24       	eor	r1, r1
   1608c:	98 0e       	add	r9, r24
   1608e:	15 c0       	rjmp	.+42     	; 0x160ba <vfprintf+0xe8>
   16090:	e8 9c       	mul	r14, r8
   16092:	e0 2c       	mov	r14, r0
   16094:	11 24       	eor	r1, r1
   16096:	e8 0e       	add	r14, r24
   16098:	f0 e2       	ldi	r31, 0x20	; 32
   1609a:	ff 2a       	or	r15, r31
   1609c:	0e c0       	rjmp	.+28     	; 0x160ba <vfprintf+0xe8>
   1609e:	9e 32       	cpi	r25, 0x2E	; 46
   160a0:	29 f4       	brne	.+10     	; 0x160ac <vfprintf+0xda>
   160a2:	f6 fc       	sbrc	r15, 6
   160a4:	6b c1       	rjmp	.+726    	; 0x1637c <vfprintf+0x3aa>
   160a6:	40 e4       	ldi	r20, 0x40	; 64
   160a8:	f4 2a       	or	r15, r20
   160aa:	07 c0       	rjmp	.+14     	; 0x160ba <vfprintf+0xe8>
   160ac:	9c 36       	cpi	r25, 0x6C	; 108
   160ae:	19 f4       	brne	.+6      	; 0x160b6 <vfprintf+0xe4>
   160b0:	50 e8       	ldi	r21, 0x80	; 128
   160b2:	f5 2a       	or	r15, r21
   160b4:	02 c0       	rjmp	.+4      	; 0x160ba <vfprintf+0xe8>
   160b6:	98 36       	cpi	r25, 0x68	; 104
   160b8:	49 f4       	brne	.+18     	; 0x160cc <vfprintf+0xfa>
   160ba:	f2 01       	movw	r30, r4
   160bc:	23 fd       	sbrc	r18, 3
   160be:	95 91       	lpm	r25, Z+
   160c0:	23 ff       	sbrs	r18, 3
   160c2:	91 91       	ld	r25, Z+
   160c4:	2f 01       	movw	r4, r30
   160c6:	99 23       	and	r25, r25
   160c8:	09 f0       	breq	.+2      	; 0x160cc <vfprintf+0xfa>
   160ca:	b8 cf       	rjmp	.-144    	; 0x1603c <vfprintf+0x6a>
   160cc:	89 2f       	mov	r24, r25
   160ce:	85 54       	subi	r24, 0x45	; 69
   160d0:	83 30       	cpi	r24, 0x03	; 3
   160d2:	18 f0       	brcs	.+6      	; 0x160da <vfprintf+0x108>
   160d4:	80 52       	subi	r24, 0x20	; 32
   160d6:	83 30       	cpi	r24, 0x03	; 3
   160d8:	38 f4       	brcc	.+14     	; 0x160e8 <vfprintf+0x116>
   160da:	44 e0       	ldi	r20, 0x04	; 4
   160dc:	50 e0       	ldi	r21, 0x00	; 0
   160de:	a4 0e       	add	r10, r20
   160e0:	b5 1e       	adc	r11, r21
   160e2:	5f e3       	ldi	r21, 0x3F	; 63
   160e4:	59 83       	std	Y+1, r21	; 0x01
   160e6:	0f c0       	rjmp	.+30     	; 0x16106 <vfprintf+0x134>
   160e8:	93 36       	cpi	r25, 0x63	; 99
   160ea:	31 f0       	breq	.+12     	; 0x160f8 <vfprintf+0x126>
   160ec:	93 37       	cpi	r25, 0x73	; 115
   160ee:	79 f0       	breq	.+30     	; 0x1610e <vfprintf+0x13c>
   160f0:	93 35       	cpi	r25, 0x53	; 83
   160f2:	09 f0       	breq	.+2      	; 0x160f6 <vfprintf+0x124>
   160f4:	56 c0       	rjmp	.+172    	; 0x161a2 <vfprintf+0x1d0>
   160f6:	20 c0       	rjmp	.+64     	; 0x16138 <vfprintf+0x166>
   160f8:	f5 01       	movw	r30, r10
   160fa:	80 81       	ld	r24, Z
   160fc:	89 83       	std	Y+1, r24	; 0x01
   160fe:	42 e0       	ldi	r20, 0x02	; 2
   16100:	50 e0       	ldi	r21, 0x00	; 0
   16102:	a4 0e       	add	r10, r20
   16104:	b5 1e       	adc	r11, r21
   16106:	61 01       	movw	r12, r2
   16108:	01 e0       	ldi	r16, 0x01	; 1
   1610a:	10 e0       	ldi	r17, 0x00	; 0
   1610c:	12 c0       	rjmp	.+36     	; 0x16132 <vfprintf+0x160>
   1610e:	f5 01       	movw	r30, r10
   16110:	c0 80       	ld	r12, Z
   16112:	d1 80       	ldd	r13, Z+1	; 0x01
   16114:	f6 fc       	sbrc	r15, 6
   16116:	03 c0       	rjmp	.+6      	; 0x1611e <vfprintf+0x14c>
   16118:	6f ef       	ldi	r22, 0xFF	; 255
   1611a:	7f ef       	ldi	r23, 0xFF	; 255
   1611c:	02 c0       	rjmp	.+4      	; 0x16122 <vfprintf+0x150>
   1611e:	69 2d       	mov	r22, r9
   16120:	70 e0       	ldi	r23, 0x00	; 0
   16122:	42 e0       	ldi	r20, 0x02	; 2
   16124:	50 e0       	ldi	r21, 0x00	; 0
   16126:	a4 0e       	add	r10, r20
   16128:	b5 1e       	adc	r11, r21
   1612a:	c6 01       	movw	r24, r12
   1612c:	0e 94 d1 b1 	call	0x163a2	; 0x163a2 <strnlen>
   16130:	8c 01       	movw	r16, r24
   16132:	5f e7       	ldi	r21, 0x7F	; 127
   16134:	f5 22       	and	r15, r21
   16136:	14 c0       	rjmp	.+40     	; 0x16160 <vfprintf+0x18e>
   16138:	f5 01       	movw	r30, r10
   1613a:	c0 80       	ld	r12, Z
   1613c:	d1 80       	ldd	r13, Z+1	; 0x01
   1613e:	f6 fc       	sbrc	r15, 6
   16140:	03 c0       	rjmp	.+6      	; 0x16148 <vfprintf+0x176>
   16142:	6f ef       	ldi	r22, 0xFF	; 255
   16144:	7f ef       	ldi	r23, 0xFF	; 255
   16146:	02 c0       	rjmp	.+4      	; 0x1614c <vfprintf+0x17a>
   16148:	69 2d       	mov	r22, r9
   1614a:	70 e0       	ldi	r23, 0x00	; 0
   1614c:	42 e0       	ldi	r20, 0x02	; 2
   1614e:	50 e0       	ldi	r21, 0x00	; 0
   16150:	a4 0e       	add	r10, r20
   16152:	b5 1e       	adc	r11, r21
   16154:	c6 01       	movw	r24, r12
   16156:	0e 94 c6 b1 	call	0x1638c	; 0x1638c <strnlen_P>
   1615a:	8c 01       	movw	r16, r24
   1615c:	50 e8       	ldi	r21, 0x80	; 128
   1615e:	f5 2a       	or	r15, r21
   16160:	f3 fe       	sbrs	r15, 3
   16162:	07 c0       	rjmp	.+14     	; 0x16172 <vfprintf+0x1a0>
   16164:	1a c0       	rjmp	.+52     	; 0x1619a <vfprintf+0x1c8>
   16166:	80 e2       	ldi	r24, 0x20	; 32
   16168:	90 e0       	ldi	r25, 0x00	; 0
   1616a:	b3 01       	movw	r22, r6
   1616c:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   16170:	ea 94       	dec	r14
   16172:	8e 2d       	mov	r24, r14
   16174:	90 e0       	ldi	r25, 0x00	; 0
   16176:	08 17       	cp	r16, r24
   16178:	19 07       	cpc	r17, r25
   1617a:	a8 f3       	brcs	.-22     	; 0x16166 <vfprintf+0x194>
   1617c:	0e c0       	rjmp	.+28     	; 0x1619a <vfprintf+0x1c8>
   1617e:	f6 01       	movw	r30, r12
   16180:	f7 fc       	sbrc	r15, 7
   16182:	85 91       	lpm	r24, Z+
   16184:	f7 fe       	sbrs	r15, 7
   16186:	81 91       	ld	r24, Z+
   16188:	6f 01       	movw	r12, r30
   1618a:	90 e0       	ldi	r25, 0x00	; 0
   1618c:	b3 01       	movw	r22, r6
   1618e:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   16192:	e1 10       	cpse	r14, r1
   16194:	ea 94       	dec	r14
   16196:	01 50       	subi	r16, 0x01	; 1
   16198:	10 40       	sbci	r17, 0x00	; 0
   1619a:	01 15       	cp	r16, r1
   1619c:	11 05       	cpc	r17, r1
   1619e:	79 f7       	brne	.-34     	; 0x1617e <vfprintf+0x1ac>
   161a0:	ea c0       	rjmp	.+468    	; 0x16376 <vfprintf+0x3a4>
   161a2:	94 36       	cpi	r25, 0x64	; 100
   161a4:	11 f0       	breq	.+4      	; 0x161aa <vfprintf+0x1d8>
   161a6:	99 36       	cpi	r25, 0x69	; 105
   161a8:	69 f5       	brne	.+90     	; 0x16204 <vfprintf+0x232>
   161aa:	f7 fe       	sbrs	r15, 7
   161ac:	08 c0       	rjmp	.+16     	; 0x161be <vfprintf+0x1ec>
   161ae:	f5 01       	movw	r30, r10
   161b0:	20 81       	ld	r18, Z
   161b2:	31 81       	ldd	r19, Z+1	; 0x01
   161b4:	42 81       	ldd	r20, Z+2	; 0x02
   161b6:	53 81       	ldd	r21, Z+3	; 0x03
   161b8:	84 e0       	ldi	r24, 0x04	; 4
   161ba:	90 e0       	ldi	r25, 0x00	; 0
   161bc:	0a c0       	rjmp	.+20     	; 0x161d2 <vfprintf+0x200>
   161be:	f5 01       	movw	r30, r10
   161c0:	80 81       	ld	r24, Z
   161c2:	91 81       	ldd	r25, Z+1	; 0x01
   161c4:	9c 01       	movw	r18, r24
   161c6:	44 27       	eor	r20, r20
   161c8:	37 fd       	sbrc	r19, 7
   161ca:	40 95       	com	r20
   161cc:	54 2f       	mov	r21, r20
   161ce:	82 e0       	ldi	r24, 0x02	; 2
   161d0:	90 e0       	ldi	r25, 0x00	; 0
   161d2:	a8 0e       	add	r10, r24
   161d4:	b9 1e       	adc	r11, r25
   161d6:	9f e6       	ldi	r25, 0x6F	; 111
   161d8:	f9 22       	and	r15, r25
   161da:	57 ff       	sbrs	r21, 7
   161dc:	09 c0       	rjmp	.+18     	; 0x161f0 <vfprintf+0x21e>
   161de:	50 95       	com	r21
   161e0:	40 95       	com	r20
   161e2:	30 95       	com	r19
   161e4:	21 95       	neg	r18
   161e6:	3f 4f       	sbci	r19, 0xFF	; 255
   161e8:	4f 4f       	sbci	r20, 0xFF	; 255
   161ea:	5f 4f       	sbci	r21, 0xFF	; 255
   161ec:	e0 e8       	ldi	r30, 0x80	; 128
   161ee:	fe 2a       	or	r15, r30
   161f0:	ca 01       	movw	r24, r20
   161f2:	b9 01       	movw	r22, r18
   161f4:	a1 01       	movw	r20, r2
   161f6:	2a e0       	ldi	r18, 0x0A	; 10
   161f8:	30 e0       	ldi	r19, 0x00	; 0
   161fa:	0e 94 08 b2 	call	0x16410	; 0x16410 <__ultoa_invert>
   161fe:	d8 2e       	mov	r13, r24
   16200:	d2 18       	sub	r13, r2
   16202:	40 c0       	rjmp	.+128    	; 0x16284 <vfprintf+0x2b2>
   16204:	95 37       	cpi	r25, 0x75	; 117
   16206:	29 f4       	brne	.+10     	; 0x16212 <vfprintf+0x240>
   16208:	1f 2d       	mov	r17, r15
   1620a:	1f 7e       	andi	r17, 0xEF	; 239
   1620c:	2a e0       	ldi	r18, 0x0A	; 10
   1620e:	30 e0       	ldi	r19, 0x00	; 0
   16210:	1d c0       	rjmp	.+58     	; 0x1624c <vfprintf+0x27a>
   16212:	1f 2d       	mov	r17, r15
   16214:	19 7f       	andi	r17, 0xF9	; 249
   16216:	9f 36       	cpi	r25, 0x6F	; 111
   16218:	61 f0       	breq	.+24     	; 0x16232 <vfprintf+0x260>
   1621a:	90 37       	cpi	r25, 0x70	; 112
   1621c:	20 f4       	brcc	.+8      	; 0x16226 <vfprintf+0x254>
   1621e:	98 35       	cpi	r25, 0x58	; 88
   16220:	09 f0       	breq	.+2      	; 0x16224 <vfprintf+0x252>
   16222:	ac c0       	rjmp	.+344    	; 0x1637c <vfprintf+0x3aa>
   16224:	0f c0       	rjmp	.+30     	; 0x16244 <vfprintf+0x272>
   16226:	90 37       	cpi	r25, 0x70	; 112
   16228:	39 f0       	breq	.+14     	; 0x16238 <vfprintf+0x266>
   1622a:	98 37       	cpi	r25, 0x78	; 120
   1622c:	09 f0       	breq	.+2      	; 0x16230 <vfprintf+0x25e>
   1622e:	a6 c0       	rjmp	.+332    	; 0x1637c <vfprintf+0x3aa>
   16230:	04 c0       	rjmp	.+8      	; 0x1623a <vfprintf+0x268>
   16232:	28 e0       	ldi	r18, 0x08	; 8
   16234:	30 e0       	ldi	r19, 0x00	; 0
   16236:	0a c0       	rjmp	.+20     	; 0x1624c <vfprintf+0x27a>
   16238:	10 61       	ori	r17, 0x10	; 16
   1623a:	14 fd       	sbrc	r17, 4
   1623c:	14 60       	ori	r17, 0x04	; 4
   1623e:	20 e1       	ldi	r18, 0x10	; 16
   16240:	30 e0       	ldi	r19, 0x00	; 0
   16242:	04 c0       	rjmp	.+8      	; 0x1624c <vfprintf+0x27a>
   16244:	14 fd       	sbrc	r17, 4
   16246:	16 60       	ori	r17, 0x06	; 6
   16248:	20 e1       	ldi	r18, 0x10	; 16
   1624a:	32 e0       	ldi	r19, 0x02	; 2
   1624c:	17 ff       	sbrs	r17, 7
   1624e:	08 c0       	rjmp	.+16     	; 0x16260 <vfprintf+0x28e>
   16250:	f5 01       	movw	r30, r10
   16252:	60 81       	ld	r22, Z
   16254:	71 81       	ldd	r23, Z+1	; 0x01
   16256:	82 81       	ldd	r24, Z+2	; 0x02
   16258:	93 81       	ldd	r25, Z+3	; 0x03
   1625a:	44 e0       	ldi	r20, 0x04	; 4
   1625c:	50 e0       	ldi	r21, 0x00	; 0
   1625e:	08 c0       	rjmp	.+16     	; 0x16270 <vfprintf+0x29e>
   16260:	f5 01       	movw	r30, r10
   16262:	80 81       	ld	r24, Z
   16264:	91 81       	ldd	r25, Z+1	; 0x01
   16266:	bc 01       	movw	r22, r24
   16268:	80 e0       	ldi	r24, 0x00	; 0
   1626a:	90 e0       	ldi	r25, 0x00	; 0
   1626c:	42 e0       	ldi	r20, 0x02	; 2
   1626e:	50 e0       	ldi	r21, 0x00	; 0
   16270:	a4 0e       	add	r10, r20
   16272:	b5 1e       	adc	r11, r21
   16274:	a1 01       	movw	r20, r2
   16276:	0e 94 08 b2 	call	0x16410	; 0x16410 <__ultoa_invert>
   1627a:	d8 2e       	mov	r13, r24
   1627c:	d2 18       	sub	r13, r2
   1627e:	8f e7       	ldi	r24, 0x7F	; 127
   16280:	f8 2e       	mov	r15, r24
   16282:	f1 22       	and	r15, r17
   16284:	f6 fe       	sbrs	r15, 6
   16286:	0b c0       	rjmp	.+22     	; 0x1629e <vfprintf+0x2cc>
   16288:	5e ef       	ldi	r21, 0xFE	; 254
   1628a:	f5 22       	and	r15, r21
   1628c:	d9 14       	cp	r13, r9
   1628e:	38 f4       	brcc	.+14     	; 0x1629e <vfprintf+0x2cc>
   16290:	f4 fe       	sbrs	r15, 4
   16292:	07 c0       	rjmp	.+14     	; 0x162a2 <vfprintf+0x2d0>
   16294:	f2 fc       	sbrc	r15, 2
   16296:	05 c0       	rjmp	.+10     	; 0x162a2 <vfprintf+0x2d0>
   16298:	8f ee       	ldi	r24, 0xEF	; 239
   1629a:	f8 22       	and	r15, r24
   1629c:	02 c0       	rjmp	.+4      	; 0x162a2 <vfprintf+0x2d0>
   1629e:	1d 2d       	mov	r17, r13
   162a0:	01 c0       	rjmp	.+2      	; 0x162a4 <vfprintf+0x2d2>
   162a2:	19 2d       	mov	r17, r9
   162a4:	f4 fe       	sbrs	r15, 4
   162a6:	0d c0       	rjmp	.+26     	; 0x162c2 <vfprintf+0x2f0>
   162a8:	fe 01       	movw	r30, r28
   162aa:	ed 0d       	add	r30, r13
   162ac:	f1 1d       	adc	r31, r1
   162ae:	80 81       	ld	r24, Z
   162b0:	80 33       	cpi	r24, 0x30	; 48
   162b2:	19 f4       	brne	.+6      	; 0x162ba <vfprintf+0x2e8>
   162b4:	99 ee       	ldi	r25, 0xE9	; 233
   162b6:	f9 22       	and	r15, r25
   162b8:	08 c0       	rjmp	.+16     	; 0x162ca <vfprintf+0x2f8>
   162ba:	1f 5f       	subi	r17, 0xFF	; 255
   162bc:	f2 fe       	sbrs	r15, 2
   162be:	05 c0       	rjmp	.+10     	; 0x162ca <vfprintf+0x2f8>
   162c0:	03 c0       	rjmp	.+6      	; 0x162c8 <vfprintf+0x2f6>
   162c2:	8f 2d       	mov	r24, r15
   162c4:	86 78       	andi	r24, 0x86	; 134
   162c6:	09 f0       	breq	.+2      	; 0x162ca <vfprintf+0x2f8>
   162c8:	1f 5f       	subi	r17, 0xFF	; 255
   162ca:	0f 2d       	mov	r16, r15
   162cc:	f3 fc       	sbrc	r15, 3
   162ce:	14 c0       	rjmp	.+40     	; 0x162f8 <vfprintf+0x326>
   162d0:	f0 fe       	sbrs	r15, 0
   162d2:	0f c0       	rjmp	.+30     	; 0x162f2 <vfprintf+0x320>
   162d4:	1e 15       	cp	r17, r14
   162d6:	10 f0       	brcs	.+4      	; 0x162dc <vfprintf+0x30a>
   162d8:	9d 2c       	mov	r9, r13
   162da:	0b c0       	rjmp	.+22     	; 0x162f2 <vfprintf+0x320>
   162dc:	9d 2c       	mov	r9, r13
   162de:	9e 0c       	add	r9, r14
   162e0:	91 1a       	sub	r9, r17
   162e2:	1e 2d       	mov	r17, r14
   162e4:	06 c0       	rjmp	.+12     	; 0x162f2 <vfprintf+0x320>
   162e6:	80 e2       	ldi	r24, 0x20	; 32
   162e8:	90 e0       	ldi	r25, 0x00	; 0
   162ea:	b3 01       	movw	r22, r6
   162ec:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   162f0:	1f 5f       	subi	r17, 0xFF	; 255
   162f2:	1e 15       	cp	r17, r14
   162f4:	c0 f3       	brcs	.-16     	; 0x162e6 <vfprintf+0x314>
   162f6:	04 c0       	rjmp	.+8      	; 0x16300 <vfprintf+0x32e>
   162f8:	1e 15       	cp	r17, r14
   162fa:	10 f4       	brcc	.+4      	; 0x16300 <vfprintf+0x32e>
   162fc:	e1 1a       	sub	r14, r17
   162fe:	01 c0       	rjmp	.+2      	; 0x16302 <vfprintf+0x330>
   16300:	ee 24       	eor	r14, r14
   16302:	04 ff       	sbrs	r16, 4
   16304:	0f c0       	rjmp	.+30     	; 0x16324 <vfprintf+0x352>
   16306:	80 e3       	ldi	r24, 0x30	; 48
   16308:	90 e0       	ldi	r25, 0x00	; 0
   1630a:	b3 01       	movw	r22, r6
   1630c:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   16310:	02 ff       	sbrs	r16, 2
   16312:	1d c0       	rjmp	.+58     	; 0x1634e <vfprintf+0x37c>
   16314:	01 fd       	sbrc	r16, 1
   16316:	03 c0       	rjmp	.+6      	; 0x1631e <vfprintf+0x34c>
   16318:	88 e7       	ldi	r24, 0x78	; 120
   1631a:	90 e0       	ldi	r25, 0x00	; 0
   1631c:	0e c0       	rjmp	.+28     	; 0x1633a <vfprintf+0x368>
   1631e:	88 e5       	ldi	r24, 0x58	; 88
   16320:	90 e0       	ldi	r25, 0x00	; 0
   16322:	0b c0       	rjmp	.+22     	; 0x1633a <vfprintf+0x368>
   16324:	80 2f       	mov	r24, r16
   16326:	86 78       	andi	r24, 0x86	; 134
   16328:	91 f0       	breq	.+36     	; 0x1634e <vfprintf+0x37c>
   1632a:	01 ff       	sbrs	r16, 1
   1632c:	02 c0       	rjmp	.+4      	; 0x16332 <vfprintf+0x360>
   1632e:	8b e2       	ldi	r24, 0x2B	; 43
   16330:	01 c0       	rjmp	.+2      	; 0x16334 <vfprintf+0x362>
   16332:	80 e2       	ldi	r24, 0x20	; 32
   16334:	f7 fc       	sbrc	r15, 7
   16336:	8d e2       	ldi	r24, 0x2D	; 45
   16338:	90 e0       	ldi	r25, 0x00	; 0
   1633a:	b3 01       	movw	r22, r6
   1633c:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   16340:	06 c0       	rjmp	.+12     	; 0x1634e <vfprintf+0x37c>
   16342:	80 e3       	ldi	r24, 0x30	; 48
   16344:	90 e0       	ldi	r25, 0x00	; 0
   16346:	b3 01       	movw	r22, r6
   16348:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   1634c:	9a 94       	dec	r9
   1634e:	d9 14       	cp	r13, r9
   16350:	c0 f3       	brcs	.-16     	; 0x16342 <vfprintf+0x370>
   16352:	da 94       	dec	r13
   16354:	f1 01       	movw	r30, r2
   16356:	ed 0d       	add	r30, r13
   16358:	f1 1d       	adc	r31, r1
   1635a:	80 81       	ld	r24, Z
   1635c:	90 e0       	ldi	r25, 0x00	; 0
   1635e:	b3 01       	movw	r22, r6
   16360:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   16364:	dd 20       	and	r13, r13
   16366:	a9 f7       	brne	.-22     	; 0x16352 <vfprintf+0x380>
   16368:	06 c0       	rjmp	.+12     	; 0x16376 <vfprintf+0x3a4>
   1636a:	80 e2       	ldi	r24, 0x20	; 32
   1636c:	90 e0       	ldi	r25, 0x00	; 0
   1636e:	b3 01       	movw	r22, r6
   16370:	0e 94 dc b1 	call	0x163b8	; 0x163b8 <fputc>
   16374:	ea 94       	dec	r14
   16376:	ee 20       	and	r14, r14
   16378:	c1 f7       	brne	.-16     	; 0x1636a <vfprintf+0x398>
   1637a:	43 ce       	rjmp	.-890    	; 0x16002 <vfprintf+0x30>
   1637c:	f3 01       	movw	r30, r6
   1637e:	66 81       	ldd	r22, Z+6	; 0x06
   16380:	77 81       	ldd	r23, Z+7	; 0x07
   16382:	cb 01       	movw	r24, r22
   16384:	2b 96       	adiw	r28, 0x0b	; 11
   16386:	e2 e1       	ldi	r30, 0x12	; 18
   16388:	0c 94 03 b3 	jmp	0x16606	; 0x16606 <__epilogue_restores__>

0001638c <strnlen_P>:
   1638c:	fc 01       	movw	r30, r24
   1638e:	05 90       	lpm	r0, Z+
   16390:	61 50       	subi	r22, 0x01	; 1
   16392:	70 40       	sbci	r23, 0x00	; 0
   16394:	01 10       	cpse	r0, r1
   16396:	d8 f7       	brcc	.-10     	; 0x1638e <strnlen_P+0x2>
   16398:	80 95       	com	r24
   1639a:	90 95       	com	r25
   1639c:	8e 0f       	add	r24, r30
   1639e:	9f 1f       	adc	r25, r31
   163a0:	08 95       	ret

000163a2 <strnlen>:
   163a2:	fc 01       	movw	r30, r24
   163a4:	61 50       	subi	r22, 0x01	; 1
   163a6:	70 40       	sbci	r23, 0x00	; 0
   163a8:	01 90       	ld	r0, Z+
   163aa:	01 10       	cpse	r0, r1
   163ac:	d8 f7       	brcc	.-10     	; 0x163a4 <strnlen+0x2>
   163ae:	80 95       	com	r24
   163b0:	90 95       	com	r25
   163b2:	8e 0f       	add	r24, r30
   163b4:	9f 1f       	adc	r25, r31
   163b6:	08 95       	ret

000163b8 <fputc>:
   163b8:	0f 93       	push	r16
   163ba:	1f 93       	push	r17
   163bc:	cf 93       	push	r28
   163be:	df 93       	push	r29
   163c0:	8c 01       	movw	r16, r24
   163c2:	eb 01       	movw	r28, r22
   163c4:	8b 81       	ldd	r24, Y+3	; 0x03
   163c6:	81 ff       	sbrs	r24, 1
   163c8:	1b c0       	rjmp	.+54     	; 0x16400 <fputc+0x48>
   163ca:	82 ff       	sbrs	r24, 2
   163cc:	0d c0       	rjmp	.+26     	; 0x163e8 <fputc+0x30>
   163ce:	2e 81       	ldd	r18, Y+6	; 0x06
   163d0:	3f 81       	ldd	r19, Y+7	; 0x07
   163d2:	8c 81       	ldd	r24, Y+4	; 0x04
   163d4:	9d 81       	ldd	r25, Y+5	; 0x05
   163d6:	28 17       	cp	r18, r24
   163d8:	39 07       	cpc	r19, r25
   163da:	64 f4       	brge	.+24     	; 0x163f4 <fputc+0x3c>
   163dc:	e8 81       	ld	r30, Y
   163de:	f9 81       	ldd	r31, Y+1	; 0x01
   163e0:	01 93       	st	Z+, r16
   163e2:	f9 83       	std	Y+1, r31	; 0x01
   163e4:	e8 83       	st	Y, r30
   163e6:	06 c0       	rjmp	.+12     	; 0x163f4 <fputc+0x3c>
   163e8:	e8 85       	ldd	r30, Y+8	; 0x08
   163ea:	f9 85       	ldd	r31, Y+9	; 0x09
   163ec:	80 2f       	mov	r24, r16
   163ee:	09 95       	icall
   163f0:	89 2b       	or	r24, r25
   163f2:	31 f4       	brne	.+12     	; 0x16400 <fputc+0x48>
   163f4:	8e 81       	ldd	r24, Y+6	; 0x06
   163f6:	9f 81       	ldd	r25, Y+7	; 0x07
   163f8:	01 96       	adiw	r24, 0x01	; 1
   163fa:	9f 83       	std	Y+7, r25	; 0x07
   163fc:	8e 83       	std	Y+6, r24	; 0x06
   163fe:	02 c0       	rjmp	.+4      	; 0x16404 <fputc+0x4c>
   16400:	0f ef       	ldi	r16, 0xFF	; 255
   16402:	1f ef       	ldi	r17, 0xFF	; 255
   16404:	c8 01       	movw	r24, r16
   16406:	df 91       	pop	r29
   16408:	cf 91       	pop	r28
   1640a:	1f 91       	pop	r17
   1640c:	0f 91       	pop	r16
   1640e:	08 95       	ret

00016410 <__ultoa_invert>:
   16410:	fa 01       	movw	r30, r20
   16412:	aa 27       	eor	r26, r26
   16414:	28 30       	cpi	r18, 0x08	; 8
   16416:	51 f1       	breq	.+84     	; 0x1646c <__ultoa_invert+0x5c>
   16418:	20 31       	cpi	r18, 0x10	; 16
   1641a:	81 f1       	breq	.+96     	; 0x1647c <__ultoa_invert+0x6c>
   1641c:	e8 94       	clt
   1641e:	6f 93       	push	r22
   16420:	6e 7f       	andi	r22, 0xFE	; 254
   16422:	6e 5f       	subi	r22, 0xFE	; 254
   16424:	7f 4f       	sbci	r23, 0xFF	; 255
   16426:	8f 4f       	sbci	r24, 0xFF	; 255
   16428:	9f 4f       	sbci	r25, 0xFF	; 255
   1642a:	af 4f       	sbci	r26, 0xFF	; 255
   1642c:	b1 e0       	ldi	r27, 0x01	; 1
   1642e:	3e d0       	rcall	.+124    	; 0x164ac <__ultoa_invert+0x9c>
   16430:	b4 e0       	ldi	r27, 0x04	; 4
   16432:	3c d0       	rcall	.+120    	; 0x164ac <__ultoa_invert+0x9c>
   16434:	67 0f       	add	r22, r23
   16436:	78 1f       	adc	r23, r24
   16438:	89 1f       	adc	r24, r25
   1643a:	9a 1f       	adc	r25, r26
   1643c:	a1 1d       	adc	r26, r1
   1643e:	68 0f       	add	r22, r24
   16440:	79 1f       	adc	r23, r25
   16442:	8a 1f       	adc	r24, r26
   16444:	91 1d       	adc	r25, r1
   16446:	a1 1d       	adc	r26, r1
   16448:	6a 0f       	add	r22, r26
   1644a:	71 1d       	adc	r23, r1
   1644c:	81 1d       	adc	r24, r1
   1644e:	91 1d       	adc	r25, r1
   16450:	a1 1d       	adc	r26, r1
   16452:	20 d0       	rcall	.+64     	; 0x16494 <__ultoa_invert+0x84>
   16454:	09 f4       	brne	.+2      	; 0x16458 <__ultoa_invert+0x48>
   16456:	68 94       	set
   16458:	3f 91       	pop	r19
   1645a:	2a e0       	ldi	r18, 0x0A	; 10
   1645c:	26 9f       	mul	r18, r22
   1645e:	11 24       	eor	r1, r1
   16460:	30 19       	sub	r19, r0
   16462:	30 5d       	subi	r19, 0xD0	; 208
   16464:	31 93       	st	Z+, r19
   16466:	de f6       	brtc	.-74     	; 0x1641e <__ultoa_invert+0xe>
   16468:	cf 01       	movw	r24, r30
   1646a:	08 95       	ret
   1646c:	46 2f       	mov	r20, r22
   1646e:	47 70       	andi	r20, 0x07	; 7
   16470:	40 5d       	subi	r20, 0xD0	; 208
   16472:	41 93       	st	Z+, r20
   16474:	b3 e0       	ldi	r27, 0x03	; 3
   16476:	0f d0       	rcall	.+30     	; 0x16496 <__ultoa_invert+0x86>
   16478:	c9 f7       	brne	.-14     	; 0x1646c <__ultoa_invert+0x5c>
   1647a:	f6 cf       	rjmp	.-20     	; 0x16468 <__ultoa_invert+0x58>
   1647c:	46 2f       	mov	r20, r22
   1647e:	4f 70       	andi	r20, 0x0F	; 15
   16480:	40 5d       	subi	r20, 0xD0	; 208
   16482:	4a 33       	cpi	r20, 0x3A	; 58
   16484:	18 f0       	brcs	.+6      	; 0x1648c <__ultoa_invert+0x7c>
   16486:	49 5d       	subi	r20, 0xD9	; 217
   16488:	31 fd       	sbrc	r19, 1
   1648a:	40 52       	subi	r20, 0x20	; 32
   1648c:	41 93       	st	Z+, r20
   1648e:	02 d0       	rcall	.+4      	; 0x16494 <__ultoa_invert+0x84>
   16490:	a9 f7       	brne	.-22     	; 0x1647c <__ultoa_invert+0x6c>
   16492:	ea cf       	rjmp	.-44     	; 0x16468 <__ultoa_invert+0x58>
   16494:	b4 e0       	ldi	r27, 0x04	; 4
   16496:	a6 95       	lsr	r26
   16498:	97 95       	ror	r25
   1649a:	87 95       	ror	r24
   1649c:	77 95       	ror	r23
   1649e:	67 95       	ror	r22
   164a0:	ba 95       	dec	r27
   164a2:	c9 f7       	brne	.-14     	; 0x16496 <__ultoa_invert+0x86>
   164a4:	00 97       	sbiw	r24, 0x00	; 0
   164a6:	61 05       	cpc	r22, r1
   164a8:	71 05       	cpc	r23, r1
   164aa:	08 95       	ret
   164ac:	9b 01       	movw	r18, r22
   164ae:	ac 01       	movw	r20, r24
   164b0:	0a 2e       	mov	r0, r26
   164b2:	06 94       	lsr	r0
   164b4:	57 95       	ror	r21
   164b6:	47 95       	ror	r20
   164b8:	37 95       	ror	r19
   164ba:	27 95       	ror	r18
   164bc:	ba 95       	dec	r27
   164be:	c9 f7       	brne	.-14     	; 0x164b2 <__ultoa_invert+0xa2>
   164c0:	62 0f       	add	r22, r18
   164c2:	73 1f       	adc	r23, r19
   164c4:	84 1f       	adc	r24, r20
   164c6:	95 1f       	adc	r25, r21
   164c8:	a0 1d       	adc	r26, r0
   164ca:	08 95       	ret

000164cc <__mulsi3>:
   164cc:	62 9f       	mul	r22, r18
   164ce:	d0 01       	movw	r26, r0
   164d0:	73 9f       	mul	r23, r19
   164d2:	f0 01       	movw	r30, r0
   164d4:	82 9f       	mul	r24, r18
   164d6:	e0 0d       	add	r30, r0
   164d8:	f1 1d       	adc	r31, r1
   164da:	64 9f       	mul	r22, r20
   164dc:	e0 0d       	add	r30, r0
   164de:	f1 1d       	adc	r31, r1
   164e0:	92 9f       	mul	r25, r18
   164e2:	f0 0d       	add	r31, r0
   164e4:	83 9f       	mul	r24, r19
   164e6:	f0 0d       	add	r31, r0
   164e8:	74 9f       	mul	r23, r20
   164ea:	f0 0d       	add	r31, r0
   164ec:	65 9f       	mul	r22, r21
   164ee:	f0 0d       	add	r31, r0
   164f0:	99 27       	eor	r25, r25
   164f2:	72 9f       	mul	r23, r18
   164f4:	b0 0d       	add	r27, r0
   164f6:	e1 1d       	adc	r30, r1
   164f8:	f9 1f       	adc	r31, r25
   164fa:	63 9f       	mul	r22, r19
   164fc:	b0 0d       	add	r27, r0
   164fe:	e1 1d       	adc	r30, r1
   16500:	f9 1f       	adc	r31, r25
   16502:	bd 01       	movw	r22, r26
   16504:	cf 01       	movw	r24, r30
   16506:	11 24       	eor	r1, r1
   16508:	08 95       	ret

0001650a <__udivmodqi4>:
   1650a:	99 1b       	sub	r25, r25
   1650c:	79 e0       	ldi	r23, 0x09	; 9
   1650e:	04 c0       	rjmp	.+8      	; 0x16518 <__udivmodqi4_ep>

00016510 <__udivmodqi4_loop>:
   16510:	99 1f       	adc	r25, r25
   16512:	96 17       	cp	r25, r22
   16514:	08 f0       	brcs	.+2      	; 0x16518 <__udivmodqi4_ep>
   16516:	96 1b       	sub	r25, r22

00016518 <__udivmodqi4_ep>:
   16518:	88 1f       	adc	r24, r24
   1651a:	7a 95       	dec	r23
   1651c:	c9 f7       	brne	.-14     	; 0x16510 <__udivmodqi4_loop>
   1651e:	80 95       	com	r24
   16520:	08 95       	ret

00016522 <__divmodqi4>:
   16522:	87 fb       	bst	r24, 7
   16524:	08 2e       	mov	r0, r24
   16526:	06 26       	eor	r0, r22
   16528:	87 fd       	sbrc	r24, 7
   1652a:	81 95       	neg	r24
   1652c:	67 fd       	sbrc	r22, 7
   1652e:	61 95       	neg	r22
   16530:	ec df       	rcall	.-40     	; 0x1650a <__udivmodqi4>
   16532:	0e f4       	brtc	.+2      	; 0x16536 <__divmodqi4_1>
   16534:	91 95       	neg	r25

00016536 <__divmodqi4_1>:
   16536:	07 fc       	sbrc	r0, 7
   16538:	81 95       	neg	r24

0001653a <__divmodqi4_exit>:
   1653a:	08 95       	ret

0001653c <__udivmodhi4>:
   1653c:	aa 1b       	sub	r26, r26
   1653e:	bb 1b       	sub	r27, r27
   16540:	51 e1       	ldi	r21, 0x11	; 17
   16542:	07 c0       	rjmp	.+14     	; 0x16552 <__udivmodhi4_ep>

00016544 <__udivmodhi4_loop>:
   16544:	aa 1f       	adc	r26, r26
   16546:	bb 1f       	adc	r27, r27
   16548:	a6 17       	cp	r26, r22
   1654a:	b7 07       	cpc	r27, r23
   1654c:	10 f0       	brcs	.+4      	; 0x16552 <__udivmodhi4_ep>
   1654e:	a6 1b       	sub	r26, r22
   16550:	b7 0b       	sbc	r27, r23

00016552 <__udivmodhi4_ep>:
   16552:	88 1f       	adc	r24, r24
   16554:	99 1f       	adc	r25, r25
   16556:	5a 95       	dec	r21
   16558:	a9 f7       	brne	.-22     	; 0x16544 <__udivmodhi4_loop>
   1655a:	80 95       	com	r24
   1655c:	90 95       	com	r25
   1655e:	bc 01       	movw	r22, r24
   16560:	cd 01       	movw	r24, r26
   16562:	08 95       	ret

00016564 <__divmodhi4>:
   16564:	97 fb       	bst	r25, 7
   16566:	09 2e       	mov	r0, r25
   16568:	07 26       	eor	r0, r23
   1656a:	0a d0       	rcall	.+20     	; 0x16580 <__divmodhi4_neg1>
   1656c:	77 fd       	sbrc	r23, 7
   1656e:	04 d0       	rcall	.+8      	; 0x16578 <__divmodhi4_neg2>
   16570:	e5 df       	rcall	.-54     	; 0x1653c <__udivmodhi4>
   16572:	06 d0       	rcall	.+12     	; 0x16580 <__divmodhi4_neg1>
   16574:	00 20       	and	r0, r0
   16576:	1a f4       	brpl	.+6      	; 0x1657e <__divmodhi4_exit>

00016578 <__divmodhi4_neg2>:
   16578:	70 95       	com	r23
   1657a:	61 95       	neg	r22
   1657c:	7f 4f       	sbci	r23, 0xFF	; 255

0001657e <__divmodhi4_exit>:
   1657e:	08 95       	ret

00016580 <__divmodhi4_neg1>:
   16580:	f6 f7       	brtc	.-4      	; 0x1657e <__divmodhi4_exit>
   16582:	90 95       	com	r25
   16584:	81 95       	neg	r24
   16586:	9f 4f       	sbci	r25, 0xFF	; 255
   16588:	08 95       	ret

0001658a <__udivmodsi4>:
   1658a:	a1 e2       	ldi	r26, 0x21	; 33
   1658c:	1a 2e       	mov	r1, r26
   1658e:	aa 1b       	sub	r26, r26
   16590:	bb 1b       	sub	r27, r27
   16592:	fd 01       	movw	r30, r26
   16594:	0d c0       	rjmp	.+26     	; 0x165b0 <__udivmodsi4_ep>

00016596 <__udivmodsi4_loop>:
   16596:	aa 1f       	adc	r26, r26
   16598:	bb 1f       	adc	r27, r27
   1659a:	ee 1f       	adc	r30, r30
   1659c:	ff 1f       	adc	r31, r31
   1659e:	a2 17       	cp	r26, r18
   165a0:	b3 07       	cpc	r27, r19
   165a2:	e4 07       	cpc	r30, r20
   165a4:	f5 07       	cpc	r31, r21
   165a6:	20 f0       	brcs	.+8      	; 0x165b0 <__udivmodsi4_ep>
   165a8:	a2 1b       	sub	r26, r18
   165aa:	b3 0b       	sbc	r27, r19
   165ac:	e4 0b       	sbc	r30, r20
   165ae:	f5 0b       	sbc	r31, r21

000165b0 <__udivmodsi4_ep>:
   165b0:	66 1f       	adc	r22, r22
   165b2:	77 1f       	adc	r23, r23
   165b4:	88 1f       	adc	r24, r24
   165b6:	99 1f       	adc	r25, r25
   165b8:	1a 94       	dec	r1
   165ba:	69 f7       	brne	.-38     	; 0x16596 <__udivmodsi4_loop>
   165bc:	60 95       	com	r22
   165be:	70 95       	com	r23
   165c0:	80 95       	com	r24
   165c2:	90 95       	com	r25
   165c4:	9b 01       	movw	r18, r22
   165c6:	ac 01       	movw	r20, r24
   165c8:	bd 01       	movw	r22, r26
   165ca:	cf 01       	movw	r24, r30
   165cc:	08 95       	ret

000165ce <__prologue_saves__>:
   165ce:	2f 92       	push	r2
   165d0:	3f 92       	push	r3
   165d2:	4f 92       	push	r4
   165d4:	5f 92       	push	r5
   165d6:	6f 92       	push	r6
   165d8:	7f 92       	push	r7
   165da:	8f 92       	push	r8
   165dc:	9f 92       	push	r9
   165de:	af 92       	push	r10
   165e0:	bf 92       	push	r11
   165e2:	cf 92       	push	r12
   165e4:	df 92       	push	r13
   165e6:	ef 92       	push	r14
   165e8:	ff 92       	push	r15
   165ea:	0f 93       	push	r16
   165ec:	1f 93       	push	r17
   165ee:	cf 93       	push	r28
   165f0:	df 93       	push	r29
   165f2:	cd b7       	in	r28, 0x3d	; 61
   165f4:	de b7       	in	r29, 0x3e	; 62
   165f6:	ca 1b       	sub	r28, r26
   165f8:	db 0b       	sbc	r29, r27
   165fa:	0f b6       	in	r0, 0x3f	; 63
   165fc:	f8 94       	cli
   165fe:	de bf       	out	0x3e, r29	; 62
   16600:	0f be       	out	0x3f, r0	; 63
   16602:	cd bf       	out	0x3d, r28	; 61
   16604:	09 94       	ijmp

00016606 <__epilogue_restores__>:
   16606:	2a 88       	ldd	r2, Y+18	; 0x12
   16608:	39 88       	ldd	r3, Y+17	; 0x11
   1660a:	48 88       	ldd	r4, Y+16	; 0x10
   1660c:	5f 84       	ldd	r5, Y+15	; 0x0f
   1660e:	6e 84       	ldd	r6, Y+14	; 0x0e
   16610:	7d 84       	ldd	r7, Y+13	; 0x0d
   16612:	8c 84       	ldd	r8, Y+12	; 0x0c
   16614:	9b 84       	ldd	r9, Y+11	; 0x0b
   16616:	aa 84       	ldd	r10, Y+10	; 0x0a
   16618:	b9 84       	ldd	r11, Y+9	; 0x09
   1661a:	c8 84       	ldd	r12, Y+8	; 0x08
   1661c:	df 80       	ldd	r13, Y+7	; 0x07
   1661e:	ee 80       	ldd	r14, Y+6	; 0x06
   16620:	fd 80       	ldd	r15, Y+5	; 0x05
   16622:	0c 81       	ldd	r16, Y+4	; 0x04
   16624:	1b 81       	ldd	r17, Y+3	; 0x03
   16626:	aa 81       	ldd	r26, Y+2	; 0x02
   16628:	b9 81       	ldd	r27, Y+1	; 0x01
   1662a:	ce 0f       	add	r28, r30
   1662c:	d1 1d       	adc	r29, r1
   1662e:	0f b6       	in	r0, 0x3f	; 63
   16630:	f8 94       	cli
   16632:	de bf       	out	0x3e, r29	; 62
   16634:	0f be       	out	0x3f, r0	; 63
   16636:	cd bf       	out	0x3d, r28	; 61
   16638:	ed 01       	movw	r28, r26
   1663a:	08 95       	ret

0001663c <_exit>:
   1663c:	f8 94       	cli

0001663e <__stop_program>:
   1663e:	ff cf       	rjmp	.-2      	; 0x1663e <__stop_program>
