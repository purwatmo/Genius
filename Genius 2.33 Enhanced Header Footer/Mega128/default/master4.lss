
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000074  00800100  000172de  00017392  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000172de  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d5b  00800174  00800174  00017406  2**0
                  ALLOC
  3 .eeprom       00000887  00810000  00810000  00017406  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  00017c8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000298e  00000000  00000000  00017d6d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000135c9  00000000  00000000  0001a6fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c60  00000000  00000000  0002dcc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000e2aa  00000000  00000000  0002e924  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012f0  00000000  00000000  0003cbd0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000053fd  00000000  00000000  0003dec0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007847  00000000  00000000  000432bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000798  00000000  00000000  0004ab04  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ed 11 	jmp	0x23da	; 0x23da <__ctors_end>
       4:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
       8:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
       c:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      10:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      14:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      18:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      1c:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      20:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      24:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      28:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      2c:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      30:	0c 94 67 ab 	jmp	0x156ce	; 0x156ce <__vector_12>
      34:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      38:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      3c:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      40:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      44:	0c 94 f4 7d 	jmp	0xfbe8	; 0xfbe8 <__vector_17>
      48:	0c 94 db 13 	jmp	0x27b6	; 0x27b6 <__vector_18>
      4c:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      50:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      54:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      58:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      5c:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      60:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      64:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      68:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      6c:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      70:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      74:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      78:	0c 94 d4 3d 	jmp	0x7ba8	; 0x7ba8 <__vector_30>
      7c:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      80:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      84:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      88:	0c 94 0c 12 	jmp	0x2418	; 0x2418 <__bad_interrupt>
      8c:	bc 12       	cpse	r11, r28
      8e:	ba 12       	cpse	r11, r26
      90:	be 12       	cpse	r11, r30
      92:	c0 12       	cpse	r12, r16
      94:	c2 12       	cpse	r12, r18
      96:	c4 12       	cpse	r12, r20
      98:	c6 12       	cpse	r12, r22
      9a:	c8 12       	cpse	r12, r24
      9c:	ca 12       	cpse	r12, r26
      9e:	cc 12       	cpse	r12, r28
      a0:	de 12       	cpse	r13, r30
      a2:	ce 12       	cpse	r12, r30
      a4:	d0 12       	cpse	r13, r16
      a6:	dc 12       	cpse	r13, r28
      a8:	d2 12       	cpse	r13, r18
      aa:	dc 12       	cpse	r13, r28
      ac:	de 12       	cpse	r13, r30
      ae:	d4 12       	cpse	r13, r20
      b0:	dc 12       	cpse	r13, r28
      b2:	d6 12       	cpse	r13, r22
      b4:	d8 12       	cpse	r13, r24
      b6:	da 12       	cpse	r13, r26
      b8:	dc 12       	cpse	r13, r28
      ba:	dc 12       	cpse	r13, r28
      bc:	d2 12       	cpse	r13, r18
      be:	c6 12       	cpse	r12, r22
      c0:	dc 12       	cpse	r13, r28
      c2:	c8 12       	cpse	r12, r24
      c4:	cc 12       	cpse	r12, r28
      c6:	ce 12       	cpse	r12, r30
      c8:	62 53       	subi	r22, 0x32	; 50
      ca:	7a 53       	subi	r23, 0x3A	; 58
      cc:	8c 53       	subi	r24, 0x3C	; 60
      ce:	c1 53       	subi	r28, 0x31	; 49
      d0:	f2 53       	subi	r31, 0x32	; 50
      d2:	08 54       	subi	r16, 0x48	; 72
      d4:	3d 54       	subi	r19, 0x4D	; 77
      d6:	77 54       	subi	r23, 0x47	; 71
      d8:	bb 54       	subi	r27, 0x4B	; 75
      da:	c3 54       	subi	r28, 0x43	; 67
      dc:	db 54       	subi	r29, 0x4B	; 75
      de:	e7 54       	subi	r30, 0x47	; 71
      e0:	19 55       	subi	r17, 0x59	; 89
      e2:	5a 55       	subi	r21, 0x5A	; 90
      e4:	77 55       	subi	r23, 0x57	; 87
      e6:	91 55       	subi	r25, 0x51	; 81
      e8:	d1 55       	subi	r29, 0x51	; 81
      ea:	d8 53       	subi	r29, 0x38	; 56
      ec:	93 54       	subi	r25, 0x43	; 67
      ee:	34 55       	subi	r19, 0x54	; 84
      f0:	5d 54       	subi	r21, 0x4D	; 77
      f2:	f7 55       	subi	r31, 0x57	; 87
      f4:	0d 56       	subi	r16, 0x6D	; 109
      f6:	12 56       	subi	r17, 0x62	; 98
      f8:	4b 56       	subi	r20, 0x6B	; 107
      fa:	7c 56       	subi	r23, 0x6C	; 108
      fc:	c1 56       	subi	r28, 0x61	; 97
      fe:	e1 56       	subi	r30, 0x61	; 97
     100:	fb 56       	subi	r31, 0x6B	; 107
     102:	35 57       	subi	r19, 0x75	; 117
     104:	90 57       	subi	r25, 0x70	; 112
     106:	d4 5b       	subi	r29, 0xB4	; 180
     108:	62 56       	subi	r22, 0x62	; 98
     10a:	fc 5b       	subi	r31, 0xBC	; 188
     10c:	5c 5c       	subi	r21, 0xCC	; 204
     10e:	16 5c       	subi	r17, 0xC6	; 198
     110:	41 5c       	subi	r20, 0xC1	; 193
     112:	96 5c       	subi	r25, 0xC6	; 198
     114:	76 5c       	subi	r23, 0xC6	; 198
     116:	af 5c       	subi	r26, 0xCF	; 207
     118:	ca 5c       	subi	r28, 0xCA	; 202
     11a:	dc 5c       	subi	r29, 0xCC	; 204
     11c:	a0 57       	subi	r26, 0x70	; 112
     11e:	c0 57       	subi	r28, 0x70	; 112
     120:	e7 57       	subi	r30, 0x77	; 119
     122:	f6 57       	subi	r31, 0x76	; 118
     124:	14 58       	subi	r17, 0x84	; 132
     126:	2b 58       	subi	r18, 0x8B	; 139
     128:	57 58       	subi	r21, 0x87	; 135
     12a:	6e 58       	subi	r22, 0x8E	; 142
     12c:	9a 58       	subi	r25, 0x8A	; 138
     12e:	ba 58       	subi	r27, 0x8A	; 138
     130:	eb 58       	subi	r30, 0x8B	; 139
     132:	fa 58       	subi	r31, 0x8A	; 138
     134:	53 59       	subi	r21, 0x93	; 147
     136:	ca 59       	subi	r28, 0x9A	; 154
     138:	de 59       	subi	r29, 0x9E	; 158
     13a:	b9 5a       	subi	r27, 0xA9	; 169
     13c:	b9 5a       	subi	r27, 0xA9	; 169
     13e:	f2 59       	subi	r31, 0x92	; 146
     140:	06 5a       	subi	r16, 0xA6	; 166
     142:	0e 5a       	subi	r16, 0xAE	; 174
     144:	2a 5a       	subi	r18, 0xAA	; 170
     146:	3e 5a       	subi	r19, 0xAE	; 174
     148:	4b 5a       	subi	r20, 0xAB	; 171
     14a:	62 5a       	subi	r22, 0xA2	; 162
     14c:	79 5a       	subi	r23, 0xA9	; 169
     14e:	97 5a       	subi	r25, 0xA7	; 167
     150:	bc 5a       	subi	r27, 0xAC	; 172
     152:	d3 5a       	subi	r29, 0xA3	; 163
     154:	ea 5a       	subi	r30, 0xAA	; 170
     156:	01 5b       	subi	r16, 0xB1	; 177
     158:	18 5b       	subi	r17, 0xB8	; 184
     15a:	2f 5b       	subi	r18, 0xBF	; 191
     15c:	46 5b       	subi	r20, 0xB6	; 182
     15e:	5d 5b       	subi	r21, 0xBD	; 189
     160:	6c 5b       	subi	r22, 0xBC	; 188
     162:	83 5b       	subi	r24, 0xB3	; 179
     164:	a6 5b       	subi	r26, 0xB6	; 182
     166:	fb 8d       	ldd	r31, Y+27	; 0x1b
     168:	17 8e       	std	Z+31, r1	; 0x1f
     16a:	2a 8e       	std	Y+26, r2	; 0x1a
     16c:	59 8e       	std	Y+25, r5	; 0x19
     16e:	82 8e       	std	Z+26, r8	; 0x1a
     170:	f5 8e       	std	Z+29, r15	; 0x1d
     172:	07 8f       	std	Z+31, r16	; 0x1f
     174:	10 8f       	std	Z+24, r17	; 0x18
     176:	4c 8f       	std	Y+28, r20	; 0x1c
     178:	73 8f       	std	Z+27, r23	; 0x1b
     17a:	ba 8f       	std	Y+26, r27	; 0x1a
     17c:	c4 8f       	std	Z+28, r28	; 0x1c
     17e:	7f 8f       	std	Y+31, r23	; 0x1f
     180:	ca 8f       	std	Y+26, r28	; 0x1a
     182:	27 8e       	std	Z+31, r2	; 0x1f
     184:	dc 8f       	std	Y+28, r29	; 0x1c
     186:	e2 8f       	std	Z+26, r30	; 0x1a
     188:	84 92       	.word	0x9284	; ????
     18a:	88 92       	.word	0x9288	; ????
     18c:	a4 92       	.word	0x92a4	; ????
     18e:	87 96       	adiw	r24, 0x27	; 39
     190:	87 96       	adiw	r24, 0x27	; 39
     192:	87 96       	adiw	r24, 0x27	; 39
     194:	87 96       	adiw	r24, 0x27	; 39
     196:	f6 92       	.word	0x92f6	; ????
     198:	87 96       	adiw	r24, 0x27	; 39
     19a:	18 93       	.word	0x9318	; ????
     19c:	87 96       	adiw	r24, 0x27	; 39
     19e:	37 93       	.word	0x9337	; ????
     1a0:	c0 93 20 94 	sts	0x9420, r28
     1a4:	44 94       	.word	0x9444	; ????
     1a6:	d5 92       	.word	0x92d5	; ????
     1a8:	87 96       	adiw	r24, 0x27	; 39
     1aa:	d8 93       	.word	0x93d8	; ????
     1ac:	5c 94 94 94 	jmp	0x152928	; 0x152928 <__data_load_end+0x13b5d6>
     1b0:	b1 94       	neg	r11
     1b2:	ed 94 fd 94 	jmp	0x3b29fa	; 0x3b29fa <__data_load_end+0x39b6a8>
     1b6:	f5 95       	asr	r31
     1b8:	05 96       	adiw	r24, 0x05	; 5
     1ba:	4a 96       	adiw	r24, 0x1a	; 26
     1bc:	69 96       	adiw	r28, 0x19	; 25
     1be:	7b 96       	adiw	r30, 0x1b	; 27
     1c0:	81 96       	adiw	r24, 0x21	; 33
     1c2:	83 96       	adiw	r24, 0x23	; 35
     1c4:	7e 98       	cbi	0x0f, 6	; 15
     1c6:	84 98       	cbi	0x10, 4	; 16
     1c8:	88 98       	cbi	0x11, 0	; 17
     1ca:	9f 98       	cbi	0x13, 7	; 19
     1cc:	b9 98       	cbi	0x17, 1	; 23
     1ce:	bd 98       	cbi	0x17, 5	; 23
     1d0:	ec 98       	cbi	0x1d, 4	; 29
     1d2:	0b 99       	sbic	0x01, 3	; 1
     1d4:	11 99       	sbic	0x02, 1	; 2
     1d6:	1d 99       	sbic	0x03, 5	; 3
     1d8:	20 99       	sbic	0x04, 0	; 4
     1da:	23 99       	sbic	0x04, 3	; 4
     1dc:	26 99       	sbic	0x04, 6	; 4
     1de:	29 99       	sbic	0x05, 1	; 5
     1e0:	2c 99       	sbic	0x05, 4	; 5
     1e2:	2f 99       	sbic	0x05, 7	; 5
     1e4:	35 99       	sbic	0x06, 5	; 6
     1e6:	38 99       	sbic	0x07, 0	; 7
     1e8:	3f 99       	sbic	0x07, 7	; 7
     1ea:	02 9b       	sbis	0x00, 2	; 0
     1ec:	5b 9b       	sbis	0x0b, 3	; 11
     1ee:	69 9b       	sbis	0x0d, 1	; 13
     1f0:	b1 9b       	sbis	0x16, 1	; 22
     1f2:	ca 9b       	sbis	0x19, 2	; 25
     1f4:	e1 9b       	sbis	0x1c, 1	; 28
     1f6:	0a 9c       	mul	r0, r10
     1f8:	c0 9c       	mul	r12, r0
     1fa:	ce 9c       	mul	r12, r14
     1fc:	4d 9d       	mul	r20, r13
     1fe:	f9 9d       	mul	r31, r9
     200:	fd 9e       	mul	r15, r29
     202:	4e 9f       	mul	r20, r30
     204:	94 9f       	mul	r25, r20
     206:	11 a0       	ldd	r1, Z+33	; 0x21
     208:	a5 a0       	ldd	r10, Z+37	; 0x25
     20a:	4b a1       	ldd	r20, Y+35	; 0x23
     20c:	11 a2       	std	Z+33, r1	; 0x21
     20e:	3d a2       	std	Y+37, r3	; 0x25
     210:	f6 a2       	std	Z+38, r15	; 0x26
     212:	13 a3       	std	Z+35, r17	; 0x23
     214:	29 a4       	ldd	r2, Y+41	; 0x29
     216:	8d a3       	std	Y+37, r24	; 0x25
     218:	d4 a3       	std	Z+36, r29	; 0x24
     21a:	ca a4       	ldd	r12, Y+42	; 0x2a
     21c:	f8 a4       	ldd	r15, Y+40	; 0x28
     21e:	0d a5       	ldd	r16, Y+45	; 0x2d
     220:	31 a4       	ldd	r3, Z+41	; 0x29
     222:	b5 a4       	ldd	r11, Z+45	; 0x2d
     224:	fe a4       	ldd	r15, Y+46	; 0x2e
     226:	06 a5       	ldd	r16, Z+46	; 0x2e
     228:	6b a9       	ldd	r22, Y+51	; 0x33
     22a:	6e a9       	ldd	r22, Y+54	; 0x36
     22c:	08 aa       	std	Y+48, r0	; 0x30
     22e:	17 aa       	std	Z+55, r1	; 0x37
     230:	4a aa       	std	Y+50, r4	; 0x32
     232:	5a aa       	std	Y+50, r5	; 0x32
     234:	88 aa       	std	Y+48, r8	; 0x30
     236:	27 aa       	std	Z+55, r2	; 0x37
     238:	36 aa       	std	Z+54, r3	; 0x36
     23a:	40 aa       	std	Z+48, r4	; 0x30
     23c:	92 aa       	std	Z+50, r9	; 0x32
     23e:	9f aa       	std	Y+55, r9	; 0x37
     240:	aa aa       	std	Y+50, r10	; 0x32
     242:	ad aa       	std	Y+53, r10	; 0x35
     244:	b0 aa       	std	Z+48, r11	; 0x30
     246:	b3 aa       	std	Z+51, r11	; 0x33
     248:	b6 aa       	std	Z+54, r11	; 0x36
     24a:	b9 aa       	std	Y+49, r11	; 0x31
     24c:	bc aa       	std	Y+52, r11	; 0x34
     24e:	bf aa       	std	Y+55, r11	; 0x37
     250:	e1 aa       	std	Z+49, r14	; 0x31
     252:	cf aa       	std	Y+55, r12	; 0x37
     254:	c2 aa       	std	Z+50, r12	; 0x32
     256:	da aa       	std	Y+50, r13	; 0x32
     258:	f2 a9       	ldd	r31, Z+50	; 0x32

0000025a <__logo>:
     25a:	00 00 00 01 01 01 05 09 00 00 00 11 11 11 15 15     ................
     26a:	11 00 00 00 00 10 10 10 14 12 00 0f 07 03 01 01     ................
     27a:	01 01 00 00 11 11 11 11 11 11 00 00 00 1e 1c 18     ................
     28a:	10 10 10 10 00 00 1f 1b 15 17 17 15 1b 1f 00 14     ................
     29a:	14 08 08 07 04 06 04 00                             ........

000002a2 <__c.3024>:
     2a2:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

000002b1 <__c.3008>:
     2b1:	57 61 74 63 68 44 6f 67 00                          WatchDog.

000002ba <__c.3006>:
     2ba:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

000002c3 <__c.3004>:
     2c3:	45 78 74 65 72 6e 61 6c 00                          External.

000002cc <__c.3002>:
     2cc:	50 6f 77 65 72 4f 6e 00                             PowerOn.

000002d4 <__reprintloc>:
     2d4:	01 06 02 06 03 06 04 06 01 0d 02 0d 03 0d 04 0d     ................

000002e4 <__idleloc>:
     2e4:	04 05 06 07 08 09 0a 0b                             ........

000002ec <__pumploc>:
     2ec:	01 05 02 05 03 05 04 05 01 0c 02 0c 03 0c 04 0c     ................

000002fc <__prodloc>:
     2fc:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

00000308 <__decloc>:
     308:	01 09 02 09 03 09 04 09 01 14                       ..........

00000312 <__prntloc>:
     312:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

0000031e <__prntlmt>:
     31e:	02 03 04 02 0f 0f                                   ......

00000324 <__prntstr>:
     324:	01 01 00 00 00 00                                   ......

0000032a <__hostloc>:
     32a:	01 0a 02 0a 03 0a                                   ......

00000330 <__txttitle>:
     330:	48 65 61 64 65 72 31 20 3a 00 48 65 61 64 65 72     Header1 :.Header
     340:	32 20 3a 00 48 65 61 64 65 72 33 20 3a 00 48 65     2 :.Header3 :.He
     350:	61 64 65 72 34 20 3a 00 46 6f 6f 74 65 72 31 20     ader4 :.Footer1 
     360:	3a 00 46 6f 6f 74 65 72 32 20 3a 00 46 6f 6f 74     :.Footer2 :.Foot
     370:	65 72 33 20 3a 00 46 6f 6f 74 65 72 34 20 3a 00     er3 :.Footer4 :.

00000380 <MaxKeyHit>:
     380:	02 04 03 03 03 03 03 04 03 04                       ..........

0000038a <strDispenserName1>:
     38a:	4e 2f 41 00                                         N/A.

0000038e <strDispenserName2>:
     38e:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

00000397 <strDispenserName3>:
     397:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

000003a2 <strDispenserName4>:
     3a2:	54 61 74 73 75 6e 6f 00                             Tatsuno.

000003aa <strDispenserName5>:
     3aa:	4c 47 00                                            LG.

000003ad <DefListDispenserName>:
     3ad:	8a 03 8e 03 97 03 a2 03 aa 03                       ..........

000003b7 <__c.10058>:
     3b7:	25 64 00                                            %d.

000003ba <__c.10056>:
     3ba:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     3ca:	73 25 73 25 73 3a 00                                s%s%s:.

000003d1 <__c.10007>:
     3d1:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     3e1:	3a 25 73 00                                         :%s.

000003e5 <__c.9979>:
     3e5:	25 73 00                                            %s.

000003e8 <__c.9970>:
     3e8:	25 73 00                                            %s.

000003eb <__c.9919>:
     3eb:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

000003f3 <__c.9897>:
     3f3:	43 54 53 52 50 00                                   CTSRP.

000003f9 <__c.9873>:
     3f9:	3a 00                                               :.

000003fb <__c.9817>:
     3fb:	46 6d 74 54 4d 6f 6e 65 79 3a 25 73 00              FmtTMoney:%s.

00000408 <__c.9815>:
     408:	46 6d 74 4d 6f 6e 65 79 3a 25 73 00                 FmtMoney:%s.

00000414 <__c.9813>:
     414:	54 4d 6f 6e 65 79 3a 25 73 00                       TMoney:%s.

0000041e <__c.9811>:
     41e:	54 56 6f 6c 75 6d 65 3a 25 73 00                    TVolume:%s.

00000429 <__c.9809>:
     429:	4d 6f 6e 65 79 3a 25 73 00                          Money:%s.

00000432 <__c.9807>:
     432:	56 6f 6c 75 6d 65 3a 25 73 00                       Volume:%s.

0000043c <__c.9805>:
     43c:	52 65 6d 6f 76 65 64 3a 25 73 00                    Removed:%s.

00000447 <__c.9803>:
     447:	4d 69 6e 75 73 3a 25 73 00                          Minus:%s.

00000450 <__c.9801>:
     450:	52 61 77 3a 25 73 00                                Raw:%s.

00000457 <__c.9799>:
     457:	46 6f 72 6d 61 74 65 64 3a 25 73 00                 Formated:%s.

00000463 <__c.9797>:
     463:	25 73 00                                            %s.

00000466 <__c.9795>:
     466:	25 73 00                                            %s.

00000469 <__c.9793>:
     469:	25 73 00                                            %s.

0000046c <__c.9791>:
     46c:	25 73 00                                            %s.

0000046f <__c.9789>:
     46f:	44 61 74 61 3a 25 73 00                             Data:%s.

00000477 <__c.9677>:
     477:	4e 2f 41 00                                         N/A.

0000047b <__c.9657>:
     47b:	25 73 00                                            %s.

0000047e <__c.9652>:
	...

0000047f <__c.9528>:
     47f:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

00000489 <__c.9526>:
     489:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

00000497 <__c.9518>:
     497:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

000004a2 <__c.9516>:
     4a2:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

000004b1 <__c.9512>:
     4b1:	25 73 25 73 00                                      %s%s.

000004b6 <__c.9510>:
     4b6:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000004bf <__c.9508>:
     4bf:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     4cf:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

000004dd <__c.9506>:
     4dd:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     4ed:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

000004fb <__c.9504>:
     4fb:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

00000506 <__c.9502>:
     506:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

00000515 <__c.9500>:
     515:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

00000520 <__c.9498>:
     520:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

0000052f <__c.9496>:
     52f:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

0000053c <__c.9494>:
     53c:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     54c:	73 00                                               s.

0000054e <__c.9492>:
     54e:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

0000055b <__c.9488>:
     55b:	4e 2f 41 00                                         N/A.

0000055f <__c.9484>:
     55f:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     56f:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     57f:	20 20 20 20 20 20 00                                      .

00000586 <__c.9482>:
     586:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     596:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     5a6:	41 48 28 52 50 29 00                                AH(RP).

000005ad <__c.9478>:
     5ad:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     5bd:	20 00                                                .

000005bf <__c.9476>:
     5bf:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     5cf:	20 00                                                .

000005d1 <__c.9474>:
     5d1:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     5e1:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     5f1:	20 20 20 20 20 00                                        .

000005f7 <__c.9472>:
     5f7:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     607:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     617:	20 20 20 20 20 00                                        .

0000061d <__c.9469>:
     61d:	25 64 00                                            %d.

00000620 <__c.9410>:
     620:	25 73 00                                            %s.

00000623 <__c.9405>:
     623:	30 00                                               0.

00000625 <__c.9403>:
     625:	30 00                                               0.

00000627 <__c.9238>:
     627:	25 73 00                                            %s.

0000062a <__c.9236>:
     62a:	25 73 00                                            %s.

0000062d <__c.9234>:
     62d:	25 73 00                                            %s.

00000630 <__c.9232>:
     630:	25 73 00                                            %s.

00000633 <__c.9230>:
     633:	25 73 00                                            %s.

00000636 <__c.9140>:
     636:	41 2b 42 3a 25 73 00                                A+B:%s.

0000063d <__c.9138>:
     63d:	49 6e 42 3a 25 73 00                                InB:%s.

00000644 <__c.9134>:
     644:	49 6e 42 3a 5f 00                                   InB:_.

0000064a <__c.9132>:
     64a:	49 6e 41 3a 25 73 00                                InA:%s.

00000651 <__c.9127>:
     651:	49 6e 41 3a 5f 00                                   InA:_.

00000657 <__c.9125>:
     657:	4f 70 65 72 61 74 69 6f 6e 20 4d 75 6c 74 69 70     Operation Multip
     667:	6c 79 00                                            ly.

0000066a <__c.8994>:
     66a:	25 73 00                                            %s.

0000066d <__c.8906>:
     66d:	30 30 30 30 30 30 30 30 00                          00000000.

00000676 <__c.8748>:
     676:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     686:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     696:	20 20 20 00                                            .

0000069a <__c.8746>:
     69a:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     6aa:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     6ba:	20 20 20 00                                            .

000006be <__c.8600>:
     6be:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     6ce:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6de:	2d 2d 00                                            --.

000006e1 <__c.8597>:
     6e1:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     6f1:	6d 74 3a 20 25 73 00                                mt: %s.

000006f8 <__c.8594>:
     6f8:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     708:	73 63 3a 20 25 73 00                                sc: %s.

0000070f <__c.8591>:
     70f:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     71f:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     72f:	2d 2d 00                                            --.

00000732 <__c.8588>:
     732:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     742:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

0000074c <__c.8585>:
     74c:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     75c:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

00000765 <__c.8582>:
     765:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     775:	6d 20 3a 20 25 73 00                                m : %s.

0000077c <__c.8579>:
     77c:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     78c:	20 20 3a 20 25 73 00                                  : %s.

00000793 <__c.8576>:
     793:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     7a3:	20 20 3a 20 25 73 00                                  : %s.

000007aa <__c.8573>:
     7aa:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     7ba:	20 20 3a 20 25 73 00                                  : %s.

000007c1 <__c.8570>:
     7c1:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     7d1:	20 20 3a 20 25 73 00                                  : %s.

000007d8 <__c.8567>:
     7d8:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     7e8:	20 20 3a 20 25 73 00                                  : %s.

000007ef <__c.8564>:
     7ef:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     7ff:	20 20 3a 20 25 73 00                                  : %s.

00000806 <__c.8561>:
     806:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     816:	20 20 3a 20 25 73 20 00                               : %s .

0000081e <__c.8558>:
     81e:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     82e:	20 20 3a 20 25 73 00                                  : %s.

00000835 <__c.8555>:
     835:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     845:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     855:	20 20 00                                              .

00000858 <__c.8552>:
     858:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     868:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     878:	2d 2d 00                                            --.

0000087b <__c.8549>:
     87b:	20 20 20 20 2e 25 73 00                                 .%s.

00000883 <__c.8545>:
     883:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     893:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     8a3:	5f 29 00                                            _).

000008a6 <__c.8540>:
     8a6:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     8b6:	20 20 20 20 20 20 00                                      .

000008bd <__c.8537>:
     8bd:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     8cd:	20 20 20 20 20 20 00                                      .

000008d4 <__c.8534>:
     8d4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     8e4:	20 00                                                .

000008e6 <__c.8532>:
     8e6:	20 20 00                                              .

000008e9 <__c.8530>:
     8e9:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     8f9:	73 00                                               s.

000008fb <__c.8528>:
     8fb:	25 73 20 20 00                                      %s  .

00000900 <__c.8526>:
     900:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     910:	73 00                                               s.

00000912 <__c.8523>:
     912:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     922:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     932:	20 20 00                                              .

00000935 <__c.8521>:
     935:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     945:	25 73 00                                            %s.

00000948 <__c.8519>:
     948:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     958:	73 00                                               s.

0000095a <__c.8516>:
     95a:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     96a:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     97a:	2d 2d 00                                            --.

0000097d <__c.8513>:
     97d:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     98d:	20 20 3a 20 25 73 00                                  : %s.

00000994 <__c.8510>:
     994:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     9a4:	20 20 3a 20 25 73 00                                  : %s.

000009ab <__c.8507>:
	...

000009ac <__c.8505>:
     9ac:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     9bc:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

000009c6 <__c.8502>:
     9c6:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     9d6:	20 20 3a 20 25 73 20 4c 00                            : %s L.

000009df <__c.8499>:
	...

000009e0 <__c.8497>:
     9e0:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     9f0:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

000009fa <__c.8494>:
     9fa:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     a0a:	20 20 3a 20 25 73 00                                  : %s.

00000a11 <__c.8491>:
     a11:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     a21:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

00000a2d <__c.8488>:
     a2d:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     a3d:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     a4d:	2d 2d 00                                            --.

00000a50 <__c.8485>:
     a50:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     a60:	25 73 20 00                                         %s .

00000a64 <__c.8481>:
     a64:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     a74:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000a83 <__c.8464>:
     a83:	20 00                                                .

00000a85 <__c.8462>:
     a85:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     a95:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     aa5:	20 20 20 00                                            .

00000aa9 <__c.8154>:
     aa9:	30 00                                               0.

00000aab <__c.8152>:
     aab:	30 30 00                                            00.

00000aae <__c.8150>:
     aae:	30 30 30 30 00                                      0000.

00000ab3 <__c.8148>:
     ab3:	30 31 32 33 30 30 00                                012300.

00000aba <__c.8146>:
     aba:	30 30 2e 30 31 32 33 30 30 00                       00.012300.

00000ac4 <__c.8144>:
     ac4:	30 30 2c 30 31 32 33 30 30 00                       00,012300.

00000ace <__c.8142>:
     ace:	30 30 30 31 32 33 30 30 00                          00012300.

00000ad7 <__c.8042>:
     ad7:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     ae7:	69 6f 6e 00                                         ion.

00000aeb <__c.8036>:
     aeb:	50 72 6f 73 65 73 00                                Proses.

00000af2 <__c.8034>:
     af2:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000aff <__c.8029>:
     aff:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     b0f:	6e 74 65 72 00                                      nter.

00000b14 <__c.8027>:
     b14:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     b24:	6e 74 65 72 00                                      nter.

00000b29 <__c.8024>:
     b29:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     b39:	74 65 72 20 00                                      ter .

00000b3e <__c.8022>:
     b3e:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000b4a <__c.8020>:
     b4a:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000b57 <__c.8017>:
     b57:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     b67:	6e 74 65 72 00                                      nter.

00000b6c <__c.8015>:
     b6c:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     b7c:	6e 74 65 72 00                                      nter.

00000b81 <__c.8012>:
     b81:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     b91:	74 65 72 20 00                                      ter .

00000b96 <__c.8010>:
     b96:	5f 00                                               _.

00000b98 <__c.8008>:
     b98:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000ba8 <__c.7962>:
     ba8:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     bb8:	53 61 76 65 00                                      Save.

00000bbd <__c.7960>:
     bbd:	4f 50 45 52 41 54 4f 52 20 3a 00                    OPERATOR :.

00000bc8 <__c.7954>:
     bc8:	2a 29 45 78 69 74 00                                *)Exit.

00000bcf <__c.7952>:
     bcf:	33 29 55 73 65 72 28 00                             3)User(.

00000bd7 <__c.7950>:
     bd7:	32 29 52 65 2d 50 72 69 6e 74 00                    2)Re-Print.

00000be2 <__c.7948>:
     be2:	31 29 43 6c 6f 73 65 20 53 68 69 66 74 00           1)Close Shift.

00000bf0 <__c.7937>:
     bf0:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     c00:	53 61 76 65 00                                      Save.

00000c05 <__c.7935>:
     c05:	50 41 53 53 57 4f 52 44 20 28 4d 41 58 20 20 20     PASSWORD (MAX   
     c15:	29 3a 00                                            ):.

00000c18 <__c.7924>:
     c18:	2a 29 45 78 69 74 00                                *)Exit.

00000c1f <__c.7922>:
     c1f:	32 29 4c 32 3a 00                                   2)L2:.

00000c25 <__c.7920>:
     c25:	31 29 4c 31 3a 00                                   1)L1:.

00000c2b <__c.7878>:
     c2b:	23 29 53 61 76 65 00                                #)Save.

00000c32 <__c.7876>:
     c32:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000c3f <__c.7858>:
     c3f:	23 29 53 61 76 65 00                                #)Save.

00000c46 <__c.7856>:
     c46:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000c53 <__c.7854>:
     c53:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     c63:	45 78 69 74 00                                      Exit.

00000c68 <__c.7852>:
     c68:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000c72 <__c.7850>:
     c72:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000c7c <__c.7776>:
     c7c:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000c8c <__c.7774>:
     c8c:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000c9c <__c.7772>:
     c9c:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     cac:	20 3a 00                                             :.

00000caf <__c.7770>:
     caf:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     cbf:	6c 3a 00                                            l:.

00000cc2 <__c.7706>:
     cc2:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     cd2:	53 61 76 65 00                                      Save.

00000cd7 <__c.7704>:
     cd7:	54 49 4d 45 20 3a 20 00                             TIME : .

00000cdf <__c.7702>:
     cdf:	44 41 54 45 20 3a 20 00                             DATE : .

00000ce7 <__c.7637>:
     ce7:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     cf7:	53 61 76 65 00                                      Save.

00000cfc <__c.7635>:
     cfc:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     d0c:	4e 36 3a 00                                         N6:.

00000d10 <__c.7633>:
     d10:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     d20:	4e 35 3a 00                                         N5:.

00000d24 <__c.7631>:
     d24:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000d34 <__c.7546>:
     d34:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000d3e <__c.7544>:
     d3e:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000d4a <__c.7541>:
     d4a:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000d58 <__c.7538>:
     d58:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000d61 <__c.7536>:
     d61:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000d6a <__c.7532>:
     d6a:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     d7a:	20 20 20 20 00                                          .

00000d7f <__c.7530>:
     d7f:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     d8f:	49 44 20 20 00                                      ID  .

00000d94 <__c.7528>:
     d94:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     da4:	20 20 20 20 00                                          .

00000da9 <__c.7516>:
     da9:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     db9:	2e 32 64 00                                         .2d.

00000dbd <__c.7510>:
     dbd:	23 29 53 61 76 65 00                                #)Save.

00000dc4 <__c.7508>:
     dc4:	2a 29 42 61 63 6b 00                                *)Back.

00000dcb <__c.7503>:
     dcb:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     ddb:	2e 32 64 00                                         .2d.

00000ddf <__c.7454>:
     ddf:	25 2e 32 64 00                                      %.2d.

00000de4 <__c.7448>:
     de4:	25 2e 32 64 00                                      %.2d.

00000de9 <__c.7446>:
     de9:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     df9:	45 78 69 74 00                                      Exit.

00000dfe <__c.7444>:
     dfe:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     e0e:	53 61 76 65 00                                      Save.

00000e13 <__c.7442>:
     e13:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000e1f <__c.7440>:
     e1f:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000e2b <__c.7406>:
     e2b:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     e3b:	67 65 20 00                                         ge .

00000e3f <__c.7404>:
     e3f:	25 64 2e 25 73 00                                   %d.%s.

00000e45 <__c.7399>:
     e45:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     e55:	2d 00                                               -.

00000e57 <__c.7383>:
     e57:	2a 29 45 78 69 74 00                                *)Exit.

00000e5e <__c.7381>:
     e5e:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000e68 <__c.7379>:
     e68:	31 29 49 44 00                                      1)ID.

00000e6d <__c.7370>:
     e6d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     e7d:	20 20 20 20 00                                          .

00000e82 <__c.7368>:
     e82:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 20 5b 23 5d     [*]Cancel    [#]
     e92:	53 61 76 65 00                                      Save.

00000e97 <__c.7353>:
     e97:	2a 29 45 78 69 74 00                                *)Exit.

00000e9e <__c.7348>:
     e9e:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     eae:	2e 32 64 20 00                                      .2d .

00000eb3 <__c.7337>:
     eb3:	25 2e 32 64 00                                      %.2d.

00000eb8 <__c.7136>:
     eb8:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000ec0 <__c.7134>:
     ec0:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000ec9 <__c.7132>:
     ec9:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000ed2 <__c.7130>:
     ed2:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000edf <__c.7128>:
     edf:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000eec <__c.7126>:
     eec:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000ef9 <__c.7124>:
     ef9:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000f06 <__c.7065>:
     f06:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000f13 <__c.7060>:
     f13:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000f1c <__c.7058>:
     f1c:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     f2c:	20 20 20 20 00                                          .

00000f31 <__c.7053>:
     f31:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000f3f <__c.7051>:
     f3f:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000f4a <__c.7049>:
     f4a:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000f55 <__c.7047>:
     f55:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000f60 <__c.7045>:
     f60:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000f6b <__c.7043>:
     f6b:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     f7b:	65 00                                               e.

00000f7d <__c.7041>:
     f7d:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000f8a <__c.7039>:
     f8a:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000f96 <__c.6952>:
     f96:	2a 29 42 61 63 6b 00                                *)Back.

00000f9d <__c.6950>:
     f9d:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

00000fac <__c.6948>:
     fac:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

00000fbb <__c.6946>:
     fbb:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

00000fca <__c.6944>:
     fca:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 20 35     1.T.Volume:%d  5
     fda:	2e 54 65 73 74 00                                   .Test.

00000fe0 <__c.6939>:
     fe0:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

00000ff1 <__c.6937>:
     ff1:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

00000ffd <__c.6935>:
     ffd:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

00001009 <__c.6933>:
    1009:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

00001015 <__c.6916>:
    1015:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

00001025 <__c.6914>:
    1025:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

0000102f <__c.6912>:
    102f:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00001039 <__c.6910>:
    1039:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

00001043 <__c.6869>:
    1043:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1053:	20 20 20 20 00                                          .

00001058 <__c.6867>:
    1058:	4e 65 77 3a 5f 00                                   New:_.

0000105e <__c.6865>:
    105e:	4f 6c 64 3a 25 73 00                                Old:%s.

00001065 <__c.6863>:
    1065:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1075:	20 20 20 20 00                                          .

0000107a <__c.6861>:
    107a:	4e 65 77 3a 5f 00                                   New:_.

00001080 <__c.6859>:
    1080:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    1090:	65 20 20 20 00                                      e   .

00001095 <__c.6857>:
    1095:	4f 6c 64 3a 25 73 00                                Old:%s.

0000109c <__c.6854>:
    109c:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

000010aa <__c.6852>:
    10aa:	32 29 25 73 00                                      2)%s.

000010af <__c.6850>:
    10af:	31 29 25 73 00                                      1)%s.

000010b4 <__c.6845>:
    10b4:	2a 29 42 61 63 6b 00                                *)Back.

000010bb <__c.6840>:
    10bb:	25 64 29 25 73 00                                   %d)%s.

000010c1 <__c.6764>:
    10c1:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    10d1:	20 20 20 20 00                                          .

000010d6 <__c.6762>:
    10d6:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    10e6:	20 20 20 20 00                                          .

000010eb <__c.6760>:
    10eb:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    10fb:	20 20 20 20 00                                          .

00001100 <__c.6758>:
    1100:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    1110:	20 20 20 20 00                                          .

00001115 <__c.6755>:
    1115:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    1125:	74 20 20 20 00                                      t   .

0000112a <__c.6753>:
    112a:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    113a:	74 20 20 20 00                                      t   .

0000113f <__c.6751>:
    113f:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    114f:	74 20 20 20 00                                      t   .

00001154 <__c.6749>:
    1154:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    1164:	6e 74 65 72 00                                      nter.

00001169 <__c.6662>:
    1169:	2e 00                                               ..

0000116b <__c.6660>:
    116b:	25 64 00                                            %d.

0000116e <__c.6658>:
    116e:	20 20 20 00                                            .

00001172 <__c.6656>:
    1172:	2e 00                                               ..

00001174 <__c.6654>:
    1174:	25 64 00                                            %d.

00001177 <__c.6652>:
    1177:	20 20 20 00                                            .

0000117b <__c.6645>:
    117b:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    118b:	78 74 20 20 00                                      xt  .

00001190 <__c.6643>:
    1190:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    11a0:	2e 20 20 20 00                                      .   .

000011a5 <__c.6641>:
    11a5:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

000011b6 <__c.6639>:
    11b6:	53 65 72 76 65 72 20 49 50 00                       Server IP.

000011c0 <__c.6548>:
    11c0:	2e 00                                               ..

000011c2 <__c.6546>:
    11c2:	25 64 00                                            %d.

000011c5 <__c.6544>:
    11c5:	20 20 20 00                                            .

000011c9 <__c.6542>:
    11c9:	2e 00                                               ..

000011cb <__c.6540>:
    11cb:	25 64 00                                            %d.

000011ce <__c.6538>:
    11ce:	20 20 20 00                                            .

000011d2 <__c.6531>:
    11d2:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    11e2:	78 74 20 20 00                                      xt  .

000011e7 <__c.6529>:
    11e7:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    11f7:	2e 20 20 20 00                                      .   .

000011fc <__c.6527>:
    11fc:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

0000120d <__c.6525>:
    120d:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

00001217 <__c.6497>:
    1217:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
    1227:	53 61 76 65 00                                      Save.

0000122c <__c.6479>:
    122c:	2a 29 45 78 69 74 00                                *)Exit.

00001233 <__c.6477>:
    1233:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    1243:	74 65 72 34 00                                      ter4.

00001248 <__c.6475>:
    1248:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    1258:	74 65 72 33 00                                      ter3.

0000125d <__c.6465>:
    125d:	2a 29 45 78 69 74 00                                *)Exit.

00001264 <__c.6463>:
    1264:	32 29 48 65 61 64 65 72 32 20 20 34 29 48 65 61     2)Header2  4)Hea
    1274:	64 65 72 34 00                                      der4.

00001279 <__c.6461>:
    1279:	31 29 48 65 61 64 65 72 31 20 20 33 29 48 65 61     1)Header1  3)Hea
    1289:	64 65 72 33 00                                      der3.

0000128e <__c.6430>:
    128e:	25 73 25 73 00                                      %s%s.

00001293 <__c.6426>:
    1293:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

000012a0 <__c.6424>:
    12a0:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

000012b0 <__c.6420>:
    12b0:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

000012be <__c.6418>:
    12be:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

000012cc <__c.6415>:
    12cc:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000012db <__c.6413>:
    12db:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

000012ea <__c.6409>:
    12ea:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    12fa:	20 20 20 20 00                                          .

000012ff <__c.6407>:
    12ff:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    130f:	20 20 20 20 00                                          .

00001314 <__c.6405>:
    1314:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    1324:	74 65 72 34 00                                      ter4.

00001329 <__c.6403>:
    1329:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    1339:	74 65 72 33 00                                      ter3.

0000133e <__c.6371>:
    133e:	25 73 25 73 00                                      %s%s.

00001343 <__c.6367>:
    1343:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

00001350 <__c.6365>:
    1350:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

00001360 <__c.6361>:
    1360:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

0000136e <__c.6359>:
    136e:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

0000137c <__c.6356>:
    137c:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

0000138b <__c.6354>:
    138b:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

0000139a <__c.6350>:
    139a:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    13aa:	20 20 20 20 00                                          .

000013af <__c.6348>:
    13af:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    13bf:	64 65 72 36 00                                      der6.

000013c4 <__c.6346>:
    13c4:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    13d4:	64 65 72 35 00                                      der5.

000013d9 <__c.6344>:
    13d9:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    13e9:	64 65 72 34 00                                      der4.

000013ee <__c.6301>:
    13ee:	2a 29 45 78 69 74 00                                *)Exit.

000013f5 <__c.6299>:
    13f5:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    1405:	20 20 20 20 00                                          .

0000140a <__c.6297>:
    140a:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    141a:	20 20 20 20 00                                          .

0000141f <__c.6295>:
    141f:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    142f:	20 20 20 20 00                                          .

00001434 <__c.6293>:
    1434:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    1444:	72 76 65 72 00                                      rver.

00001449 <__c.6291>:
    1449:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    1459:	69 65 6e 74 00                                      ient.

0000145e <__c.6237>:
    145e:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    146e:	2e 2e 20 00                                         .. .

00001472 <__c.6232>:
    1472:	25 73 20 25 73 00                                   %s %s.

00001478 <__c.6230>:
    1478:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    1488:	65 72 00                                            er.

0000148b <__c.6226>:
    148b:	43 61 6e 63 65 6c 00                                Cancel.

00001492 <__c.6221>:
    1492:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    14a2:	25 64 20 00                                         %d .

000014a6 <__c.6216>:
    14a6:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

000014b4 <__c.6212>:
    14b4:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

000014c2 <__c.6210>:
    14c2:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

000014ce <__c.6138>:
    14ce:	2a 29 45 78 69 74 00                                *)Exit.

000014d5 <__c.6136>:
    14d5:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

000014e3 <__c.6134>:
    14e3:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

000014f1 <__c.6132>:
    14f1:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

000014ff <__c.6090>:
    14ff:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    150f:	78 69 74 20 00                                      xit .

00001514 <__c.6088>:
    1514:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    1524:	20 20 20 20 00                                          .

00001529 <__c.6086>:
    1529:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    1539:	20 20 20 20 00                                          .

0000153e <__c.6084>:
    153e:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    154e:	20 20 20 20 00                                          .

00001553 <__c.6054>:
    1553:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    1563:	64 00                                               d.

00001565 <__c.6050>:
    1565:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    1575:	20 00                                                .

00001577 <__c.6047>:
    1577:	30 30 30 30 30 00                                   00000.

0000157d <__c.6045>:
    157d:	31 31 31 31 31 00                                   11111.

00001583 <__c.6041>:
    1583:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1593:	6e 74 65 72 00                                      nter.

00001598 <__c.6038>:
    1598:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    15a8:	6e 74 65 72 00                                      nter.

000015ad <__c.6031>:
    15ad:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    15bd:	6e 74 65 72 00                                      nter.

000015c2 <__c.6029>:
    15c2:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    15d2:	20 20 20 20 00                                          .

000015d7 <__c.6027>:
    15d7:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    15e7:	64 65 20 20 00                                      de  .

000015ec <__c.6025>:
    15ec:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

000015fa <__c.6021>:
    15fa:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    160a:	20 20 20 20 00                                          .

0000160f <__c.6018>:
	...

00001610 <__c.6016>:
    1610:	25 73 00                                            %s.

00001613 <__c.6014>:
    1613:	25 73 00                                            %s.

00001616 <__c.6011>:
    1616:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1626:	6e 74 65 72 00                                      nter.

0000162b <__c.6008>:
    162b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    163b:	6e 74 65 72 00                                      nter.

00001640 <__c.6001>:
	...

00001641 <__c.5999>:
    1641:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1651:	6e 74 65 72 00                                      nter.

00001656 <__c.5997>:
    1656:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    1666:	20 20 20 20 00                                          .

0000166b <__c.5995>:
    166b:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    167b:	65 20 20 20 00                                      e   .

00001680 <__c.5985>:
    1680:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    1690:	20 20 20 20 00                                          .

00001695 <__c.5983>:
    1695:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    16a5:	64 20 20 20 00                                      d   .

000016aa <__c.5981>:
    16aa:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    16ba:	72 64 20 20 00                                      rd  .

000016bf <__c.5979>:
    16bf:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    16cf:	76 65 6c 2d 00                                      vel-.

000016d4 <__c.5920>:
    16d4:	25 73 25 73 00                                      %s%s.

000016d9 <__c.5892>:
    16d9:	25 73 00                                            %s.

000016dc <__c.5859>:
    16dc:	25 63 00                                            %c.

000016df <__c.5857>:
    16df:	32 30 25 73 00                                      20%s.

000016e4 <__c.5835>:
    16e4:	25 73 00                                            %s.

000016e7 <__c.5786>:
    16e7:	34 32 36 34 36 33 36 00                             4264636.

000016ef <__c.5783>:
    16ef:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    16ff:	6e 74 65 72 00                                      nter.

00001704 <__c.5781>:
    1704:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1714:	6e 74 65 72 00                                      nter.

00001719 <__c.5777>:
    1719:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1729:	6e 74 65 72 00                                      nter.

0000172e <__c.5775>:
    172e:	5f 00                                               _.

00001730 <__c.5773>:
    1730:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

0000173a <__c.5745>:
    173a:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001748 <__c.5717>:
    1748:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1758:	6e 74 65 72 00                                      nter.

0000175d <__c.5715>:
    175d:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001767 <__c.5651>:
    1767:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001774 <__c.5649>:
    1774:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

00001781 <__c.5645>:
    1781:	20 20 20 20 20 20 20 00                                    .

00001789 <__c.5642>:
    1789:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

00001795 <__c.5639>:
    1795:	25 73 00                                            %s.

00001798 <__c.5637>:
    1798:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

000017a2 <__c.5634>:
    17a2:	25 73 00                                            %s.

000017a5 <__c.5631>:
    17a5:	25 73 00                                            %s.

000017a8 <__c.5629>:
    17a8:	25 73 00                                            %s.

000017ab <__c.5627>:
    17ab:	25 73 00                                            %s.

000017ae <__c.5623>:
    17ae:	25 73 00                                            %s.

000017b1 <__c.5619>:
    17b1:	50 72 6f 73 65 73 00                                Proses.

000017b8 <__c.5617>:
    17b8:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

000017c6 <__c.5614>:
    17c6:	50 72 6f 73 65 73 00                                Proses.

000017cd <__c.5612>:
    17cd:	49 44 3a 25 73 00                                   ID:%s.

000017d3 <__c.5608>:
    17d3:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    17e3:	69 74 00                                            it.

000017e6 <__c.5606>:
    17e6:	46 49 50 25 73 00                                   FIP%s.

000017ec <__c.5604>:
    17ec:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

000017fb <__c.5595>:
    17fb:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    180b:	6e 74 65 72 00                                      nter.

00001810 <__c.5593>:
    1810:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1820:	6e 74 65 72 00                                      nter.

00001825 <__c.5590>:
    1825:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1835:	6e 74 65 72 00                                      nter.

0000183a <__c.5588>:
    183a:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

0000184a <__c.5586>:
    184a:	25 73 00                                            %s.

0000184d <__c.5582>:
    184d:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

00001855 <__c.5577>:
    1855:	25 64 2e 25 73 00                                   %d.%s.

0000185b <__c.5575>:
    185b:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

00001867 <__c.5570>:
    1867:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1877:	6e 74 65 72 00                                      nter.

0000187c <__c.5568>:
    187c:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    188c:	6e 74 65 72 00                                      nter.

00001891 <__c.5565>:
    1891:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18a1:	6e 74 65 72 00                                      nter.

000018a6 <__c.5563>:
    18a6:	5f 00                                               _.

000018a8 <__c.5561>:
    18a8:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

000018b5 <__c.5552>:
    18b5:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    18c5:	20 20 20 20 00                                          .

000018ca <__c.5550>:
    18ca:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    18da:	54 65 73 74 00                                      Test.

000018df <__c.5548>:
    18df:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    18ef:	68 65 72 20 00                                      her .

000018f4 <__c.5546>:
    18f4:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    1904:	74 20 20 20 00                                      t   .

00001909 <__c.5487>:
    1909:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

00001914 <__c.5481>:
    1914:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1924:	20 20 20 20 00                                          .

00001929 <__c.5479>:
    1929:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    1939:	20 20 20 20 00                                          .

0000193e <__c.5477>:
    193e:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    194e:	72 64 20 20 00                                      rd  .

00001953 <__c.5475>:
    1953:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

00001964 <__c.5438>:
    1964:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001972 <__c.5436>:
    1972:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001980 <__c.5429>:
    1980:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

0000198e <__c.5427>:
    198e:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

00001998 <__c.5425>:
    1998:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

000019a2 <__c.5423>:
    19a2:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

000019ac <__c.5421>:
    19ac:	25 73 3a 25 73 00                                   %s:%s.

000019b2 <__c.5414>:
    19b2:	50 72 6f 73 65 73 00                                Proses.

000019b9 <__c.5412>:
    19b9:	49 44 3a 25 73 00                                   ID:%s.

000019bf <__c.5408>:
    19bf:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    19cf:	69 74 00                                            it.

000019d2 <__c.5406>:
    19d2:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

000019e1 <__c.5403>:
    19e1:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    19f1:	69 74 00                                            it.

000019f4 <__c.5401>:
    19f4:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a03 <__c.5399>:
    1a03:	46 49 50 3a 25 73 00                                FIP:%s.

00001a0a <__c.5393>:
    1a0a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1a1a:	20 00                                                .

00001a1c <__c.5391>:
    1a1c:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1a2c:	20 00                                                .

00001a2e <__c.5389>:
    1a2e:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1a3e:	20 00                                                .

00001a40 <__c.5387>:
    1a40:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1a50:	20 00                                                .

00001a52 <__c.5352>:
    1a52:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001a60 <__c.5350>:
    1a60:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001a6e <__c.5344>:
    1a6e:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a7e:	69 74 00                                            it.

00001a81 <__c.5342>:
    1a81:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1a91:	61 72 64 00                                         ard.

00001a95 <__c.5340>:
    1a95:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001aa5 <__c.5336>:
    1aa5:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1ab5:	6b 73 69 20 00                                      ksi .

00001aba <__c.5330>:
    1aba:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001ac8 <__c.5280>:
    1ac8:	2a 29 45 78 69 74 00                                *)Exit.

00001acf <__c.5278>:
    1acf:	23 29 4f 4b 20 00                                   #)OK .

00001ad5 <__c.5276>:
    1ad5:	20 20 20 20 20 00                                        .

00001adb <__c.5274>:
    1adb:	46 49 50 3a 5f 00                                   FIP:_.

00001ae1 <__c.5269>:
    1ae1:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001af1 <__c.5220>:
    1af1:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001b02 <__c.5077>:
    1b02:	30 00                                               0.

00001b04 <__c.5005>:
    1b04:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1b14:	20 20 20 20 00                                          .

00001b19 <__c.5000>:
    1b19:	23 25 73 00                                         #%s.

00001b1d <__c.4998>:
    1b1d:	25 2e 32 64 00                                      %.2d.

00001b22 <__c.4996>:
    1b22:	40 46 49 50 3a 00                                   @FIP:.

00001b28 <__c.4994>:
    1b28:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1b38:	20 20 20 20 00                                          .

00001b3d <__c.4990>:
    1b3d:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001b4d <__c.4964>:
    1b4d:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001b59 <__c.4945>:
    1b59:	25 73 20 25 73 00                                   %s %s.

00001b5f <__c.4902>:
    1b5f:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001b6d <__c.4900>:
    1b6d:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001b7a <__c.4898>:
    1b7a:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001b84 <__c.4896>:
    1b84:	43 6f 6e 6e 65 63 74 65 64 00                       Connected.

00001b8e <__c.4891>:
    1b8e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1b9e:	20 20 20 00                                            .

00001ba2 <__c.4889>:
    1ba2:	25 73 00                                            %s.

00001ba5 <__c.4884>:
    1ba5:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001baf <__c.4879>:
    1baf:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001bc0 <__c.4877>:
    1bc0:	43 6f 6e 6e 65 63 74 00                             Connect.

00001bc8 <__c.4875>:
    1bc8:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001bd9 <__c.4848>:
    1bd9:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1be9:	20 20 20 00                                            .

00001bed <__c.4846>:
    1bed:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1bfd:	2e 2e 00                                            ...

00001c00 <__c.4807>:
    1c00:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1c10:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1c20:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1c30:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1c40:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1c50:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1c60:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1c70:	0a 00                                               ..

00001c72 <__c.4805>:
    1c72:	30 37 2f 30 31 2f 32 30 31 31 00                    07/01/2011.

00001c7d <__c.4803>:
    1c7d:	32 2e 33 33 00                                      2.33.

00001c82 <__c.4794>:
    1c82:	25 73 25 73 25 73 25 73 39 38 25 2e 32 64 46 39     %s%s%s%s98%.2dF9
    1c92:	36 38 43 46 46 42 00                                68CFFB.

00001c99 <__c.4671>:
    1c99:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001caa <__c.4669>:
    1caa:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1cba:	69 00                                               i.

00001cbc <__c.4665>:
    1cbc:	49 44 3a 20 25 73 00                                ID: %s.

00001cc3 <__c.4663>:
    1cc3:	25 73 00                                            %s.

00001cc6 <__c.4661>:
    1cc6:	50 25 73 20 25 73 20 00                             P%s %s .

00001cce <__c.4657>:
    1cce:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1cde:	20 20 00                                              .

00001ce1 <__c.4654>:
    1ce1:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1cf1:	61 73 69 6c 00                                      asil.

00001cf6 <__c.4650>:
    1cf6:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1d06:	6c 20 20 20 00                                      l   .

00001d0b <__c.4646>:
    1d0b:	20 20 20 20 20 20 20 00                                    .

00001d13 <__c.4643>:
    1d13:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1d23:	20 20 20 20 00                                          .

00001d28 <__c.4641>:
    1d28:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1d38:	20 20 20 20 00                                          .

00001d3d <__c.4639>:
    1d3d:	25 73 00                                            %s.

00001d40 <__c.4637>:
    1d40:	50 25 73 20 25 73 20 00                             P%s %s .

00001d48 <__c.4634>:
    1d48:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1d58:	6f 6e 20 20 00                                      on  .

00001d5d <__c.4631>:
    1d5d:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1d6d:	23 5d 4f 4b 00                                      #]OK.

00001d72 <__c.4629>:
    1d72:	25 73 20 00                                         %s .

00001d76 <__c.4627>:
    1d76:	20 46 75 6c 6c 00                                    Full.

00001d7c <__c.4625>:
    1d7c:	25 73 20 20 25 73 20 00                             %s  %s .

00001d84 <__c.4623>:
    1d84:	49 44 3a 20 25 73 00                                ID: %s.

00001d8b <__c.4621>:
    1d8b:	25 73 20 00                                         %s .

00001d8f <__c.4617>:
    1d8f:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1d9f:	20 00                                                .

00001da1 <__c.4615>:
    1da1:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1db1:	20 00                                                .

00001db3 <__c.4613>:
    1db3:	25 73 20 00                                         %s .

00001db7 <__c.4611>:
    1db7:	20 20 25 73 20 25 73 20 00                            %s %s .

00001dc0 <__c.4609>:
    1dc0:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1dd0:	75 6e 74 00                                         unt.

00001dd4 <__c.4607>:
    1dd4:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1de4:	75 6d 65 00                                         ume.

00001de8 <__c.4605>:
    1de8:	20 20 54 61 6e 6b 00                                  Tank.

00001def <__c.4603>:
    1def:	20 20 25 73 20 25 73 20 00                            %s %s .

00001df8 <__c.4601>:
    1df8:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1e08:	75 6c 6c 00                                         ull.

00001e0c <__c.4598>:
    1e0c:	25 73 00                                            %s.

00001e0f <__c.4595>:
    1e0f:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e1f:	20 20 20 20 00                                          .

00001e24 <__c.4593>:
    1e24:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1e34:	20 20 20 20 00                                          .

00001e39 <__c.4591>:
    1e39:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1e49:	20 20 20 20 00                                          .

00001e4e <__c.4589>:
    1e4e:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001e56 <__c.4587>:
    1e56:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e66:	20 20 20 20 00                                          .

00001e6b <__c.4585>:
    1e6b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1e7b:	20 20 20 20 00                                          .

00001e80 <__c.4583>:
    1e80:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    1e90:	20 20 20 20 00                                          .

00001e95 <__c.4581>:
    1e95:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001e9d <__c.4578>:
    1e9d:	41 00                                               A.

00001e9f <__c.4576>:
    1e9f:	41 00                                               A.

00001ea1 <__c.4574>:
    1ea1:	56 00                                               V.

00001ea3 <__c.4571>:
    1ea3:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    1eb3:	78 74 20 20 00                                      xt  .

00001eb8 <__c.4569>:
    1eb8:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    1ec8:	20 20 20 20 00                                          .

00001ecd <__c.4567>:
    1ecd:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    1edd:	20 20 20 20 00                                          .

00001ee2 <__c.4565>:
    1ee2:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001eea <__c.4562>:
    1eea:	25 73 00                                            %s.

00001eed <__c.4559>:
    1eed:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1efd:	20 20 20 20 00                                          .

00001f02 <__c.4554>:
    1f02:	20 20 20 20 20 00                                        .

00001f08 <__c.4552>:
    1f08:	25 64 2e 25 73 00                                   %d.%s.

00001f0e <__c.4550>:
    1f0e:	25 73 00                                            %s.

00001f11 <__c.4548>:
    1f11:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00001f1a <__c.4545>:
    1f1a:	25 2e 32 64 00                                      %.2d.

00001f1f <__c.4543>:
    1f1f:	25 2e 32 64 00                                      %.2d.

00001f24 <__c.4540>:
    1f24:	2a 29 45 78 69 74 00                                *)Exit.

00001f2b <__c.4538>:
    1f2b:	23 29 4f 4b 20 00                                   #)OK .

00001f31 <__c.4536>:
    1f31:	20 20 20 20 20 00                                        .

00001f37 <__c.4534>:
    1f37:	46 49 50 3a 5f 00                                   FIP:_.

00001f3d <__c.4529>:
    1f3d:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
    1f4d:	2e 32 64 00                                         .2d.

00001f51 <__c.4525>:
    1f51:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    1f61:	23 5d 4f 4b 00                                      #]OK.

00001f66 <__c.4523>:
    1f66:	25 73 20 25 73 00                                   %s %s.

00001f6c <__c.4521>:
    1f6c:	25 73 00                                            %s.

00001f6f <__c.4519>:
    1f6f:	25 73 00                                            %s.

00001f72 <__c.4517>:
    1f72:	25 73 00                                            %s.

00001f75 <__c.4514>:
    1f75:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    1f85:	20 20 20 20 00                                          .

00001f8a <__c.4512>:
    1f8a:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    1f9a:	20 20 20 20 00                                          .

00001f9f <__c.4509>:
    1f9f:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    1faf:	20 20 20 20 00                                          .

00001fb4 <__c.4506>:
    1fb4:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    1fc4:	20 20 20 20 00                                          .

00001fc9 <__c.4504>:
    1fc9:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    1fd9:	20 20 20 20 00                                          .

00001fde <__c.4501>:
    1fde:	20 20 20 20 20 20 20 00                                    .

00001fe6 <__c.4496>:
    1fe6:	50 72 6f 73 65 73 00                                Proses.

00001fed <__c.4494>:
    1fed:	49 44 3a 25 73 00                                   ID:%s.

00001ff3 <__c.4492>:
    1ff3:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    2003:	20 20 20 00                                            .

00002007 <__c.4292>:
    2007:	45 39 34 34 35 35 31 32 00                          E9445512.

00002010 <__c.4290>:
    2010:	25 73 25 73 00                                      %s%s.

00002015 <__c.4288>:
    2015:	25 73 25 73 25 73 25 73 39 34 00                    %s%s%s%s94.

00002020 <__c.4283>:
    2020:	45 39 34 34 35 35 31 32 00                          E9445512.

00002029 <__c.4281>:
    2029:	25 73 25 73 25 73 00                                %s%s%s.

00002030 <__c.4279>:
    2030:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00002039 <__c.4277>:
    2039:	25 73 25 73 25 73 25 73 39 32 00                    %s%s%s%s92.

00002044 <__c.4272>:
    2044:	45 39 34 34 35 35 31 32 00                          E9445512.

0000204d <__c.4270>:
    204d:	25 73 25 73 00                                      %s%s.

00002052 <__c.4268>:
    2052:	25 73 25 73 25 73 25 73 39 30 00                    %s%s%s%s90.

0000205d <__c.4259>:
    205d:	25 64 46 30 30 30 30 30 30 30 45 31 32 33 34 35     %dF0000000E12345
    206d:	36 46 46 46 46 46 25 73 45 39 34 34 35 35 31 32     6FFFFF%sE9445512
	...

0000207e <__c.4257>:
    207e:	25 73 25 73 25 64 25 73 25 73 00                    %s%s%d%s%s.

00002089 <__c.4255>:
    2089:	25 73 25 73 25 73 25 73 35 38 00                    %s%s%s%s58.

00002094 <__c.4250>:
    2094:	41 46 39 36 38 43 46 46 42 00                       AF968CFFB.

0000209e <__c.4248>:
    209e:	25 73 00                                            %s.

000020a1 <__c.4246>:
    20a1:	25 73 35 36 00                                      %s56.

000020a6 <__c.4244>:
    20a6:	25 73 25 73 25 73 00                                %s%s%s.

000020ad <__c.4239>:
    20ad:	46 39 36 38 43 46 46 42 00                          F968CFFB.

000020b6 <__c.4237>:
    20b6:	25 73 25 73 00                                      %s%s.

000020bb <__c.4235>:
    20bb:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000020c4 <__c.4233>:
    20c4:	25 73 25 73 25 73 25 73 33 32 00                    %s%s%s%s32.

000020cf <__c.4228>:
    20cf:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

000020dc <__c.4226>:
    20dc:	25 73 25 73 25 73 25 73 32 38 00                    %s%s%s%s28.

000020e7 <__c.4221>:
    20e7:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

000020f4 <__c.4219>:
    20f4:	25 73 25 73 25 73 25 73 32 34 00                    %s%s%s%s24.

000020ff <__c.4214>:
    20ff:	25 73 46 39 36 38 43 46 46 42 00                    %sF968CFFB.

0000210a <__c.4212>:
    210a:	25 73 25 73 25 73 25 73 32 32 00                    %s%s%s%s22.

00002115 <__c.4207>:
    2115:	25 73 25 73 25 73 25 73 31 30 46 39 36 38 43 46     %s%s%s%s10F968CF
    2125:	46 42 00                                            FB.

00002128 <__c.4202>:
    2128:	25 73 25 73 25 73 25 73 30 34 25 73 31 46 39 36     %s%s%s%s04%s1F96
    2138:	38 43 46 46 42 00                                   8CFFB.

0000213e <__c.4188>:
    213e:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

0000214a <__c.4169>:
    214a:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

00002156 <__c.4102>:
    2156:	25 73 20 25 73 00                                   %s %s.

0000215c <__c.4100>:
    215c:	32 2e 33 33 00                                      2.33.

00002161 <__c.4098>:
    2161:	47 65 4e 69 55 73 00                                GeNiUs.

00002168 <__c.4090>:
    2168:	28 50 29 2b 28 43 29 32 30 30 39 2c 20 48 41 53     (P)+(C)2009, HAS
	...

00002179 <__c.4088>:
    2179:	49 46 54 76 35 2e 31 33 00                          IFTv5.13.

00002182 <__c.4077>:
    2182:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    2192:	20 20 20 20 00                                          .

00002197 <__c.4065>:
    2197:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    21a7:	64 61 6c 6f 6e 65 00                                dalone.

000021ae <__c.3985>:
    21ae:	3e 00                                               >.

000021b0 <__c.3980>:
    21b0:	25 2e 32 64 00                                      %.2d.

000021b5 <__c.3978>:
    21b5:	25 2e 32 64 00                                      %.2d.

000021ba <__c.3976>:
    21ba:	30 00                                               0.

000021bc <__c.3974>:
    21bc:	31 00                                               1.

000021be <__c.3966>:
    21be:	25 64 00                                            %d.

000021c1 <__c.3961>:
    21c1:	25 2e 32 64 00                                      %.2d.

000021c6 <__c.3956>:
    21c6:	25 73 00                                            %s.

000021c9 <__c.3951>:
    21c9:	25 73 00                                            %s.

000021cc <__c.3946>:
    21cc:	25 73 00                                            %s.

000021cf <__c.3944>:
    21cf:	3c 00                                               <.

000021d1 <__c.3876>:
    21d1:	3c 4f 4b 3e 00                                      <OK>.

000021d6 <__c.3871>:
    21d6:	25 64 00                                            %d.

000021d9 <__c.3869>:
    21d9:	25 64 00                                            %d.

000021dc <__c.3858>:
    21dc:	25 64 00                                            %d.

000021df <__c.3847>:
    21df:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

000021e8 <__c.3845>:
    21e8:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

000021f2 <__c.3656>:
    21f2:	25 73 00                                            %s.

000021f5 <__c.3598>:
    21f5:	25 73 00                                            %s.

000021f8 <__c.3596>:
    21f8:	25 73 00                                            %s.

000021fb <__c.3594>:
    21fb:	25 73 00                                            %s.

000021fe <__c.3592>:
    21fe:	25 73 00                                            %s.

00002201 <__c.3590>:
    2201:	25 2e 32 64 00                                      %.2d.

00002206 <__c.3588>:
    2206:	25 64 00                                            %d.

00002209 <__c.3586>:
    2209:	25 73 00                                            %s.

0000220c <__c.3584>:
    220c:	25 73 00                                            %s.

0000220f <__c.3582>:
    220f:	25 73 00                                            %s.

00002212 <__c.3580>:
    2212:	25 64 00                                            %d.

00002215 <__c.3578>:
    2215:	4e 2f 41 00                                         N/A.

00002219 <__c.3474>:
    2219:	25 64 00                                            %d.

0000221c <__c.3472>:
    221c:	25 73 00                                            %s.

0000221f <__c.3470>:
    221f:	25 73 00                                            %s.

00002222 <__c.3385>:
    2222:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    2232:	6b 73 69 20 00                                      ksi .

00002237 <__c.3382>:
    2237:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    2247:	20 00                                                .

00002249 <__c.3379>:
    2249:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    2259:	69 7a 65 72 00                                      izer.

0000225e <__c.3367>:
    225e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

0000226f <__c.3364>:
    226f:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    227f:	20 20 20 20 00                                          .

00002284 <__c.3361>:
    2284:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2294:	20 20 20 20 00                                          .

00002299 <__c.3359>:
    2299:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    22a9:	20 20 20 20 00                                          .

000022ae <__c.3356>:
    22ae:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    22be:	20 20 20 20 00                                          .

000022c3 <__c.3353>:
    22c3:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    22d3:	20 20 20 20 00                                          .

000022d8 <__c.3350>:
    22d8:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    22e8:	6b 73 69 20 00                                      ksi .

000022ed <__c.3345>:
    22ed:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

000022fa <__c.3342>:
    22fa:	34 33 35 36 41 33 31 41 00                          4356A31A.

00002303 <__c.1750>:
    2303:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2313:	20 20 20 20 00                                          .

00002318 <__c.1748>:
    2318:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2328:	20 20 20 20 00                                          .

0000232d <__c.1746>:
    232d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    233d:	20 20 20 20 00                                          .

00002342 <__c.1744>:
    2342:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2352:	20 20 20 20 00                                          .

00002357 <__alphanum>:
    2357:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    2367:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    2377:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    2387:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    2397:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    23a7:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    23b7:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    23c7:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

000023cf <__maxchar>:
    23cf:	02 04 03 03 03 03 03 04 03 04 00                    ...........

000023da <__ctors_end>:
    23da:	11 24       	eor	r1, r1
    23dc:	1f be       	out	0x3f, r1	; 63
    23de:	cf ef       	ldi	r28, 0xFF	; 255
    23e0:	d0 e1       	ldi	r29, 0x10	; 16
    23e2:	de bf       	out	0x3e, r29	; 62
    23e4:	cd bf       	out	0x3d, r28	; 61

000023e6 <__do_copy_data>:
    23e6:	11 e0       	ldi	r17, 0x01	; 1
    23e8:	a0 e0       	ldi	r26, 0x00	; 0
    23ea:	b1 e0       	ldi	r27, 0x01	; 1
    23ec:	ee ed       	ldi	r30, 0xDE	; 222
    23ee:	f2 e7       	ldi	r31, 0x72	; 114
    23f0:	01 e0       	ldi	r16, 0x01	; 1
    23f2:	0b bf       	out	0x3b, r16	; 59
    23f4:	02 c0       	rjmp	.+4      	; 0x23fa <__do_copy_data+0x14>
    23f6:	07 90       	elpm	r0, Z+
    23f8:	0d 92       	st	X+, r0
    23fa:	a4 37       	cpi	r26, 0x74	; 116
    23fc:	b1 07       	cpc	r27, r17
    23fe:	d9 f7       	brne	.-10     	; 0x23f6 <__do_copy_data+0x10>

00002400 <__do_clear_bss>:
    2400:	1e e0       	ldi	r17, 0x0E	; 14
    2402:	a4 e7       	ldi	r26, 0x74	; 116
    2404:	b1 e0       	ldi	r27, 0x01	; 1
    2406:	01 c0       	rjmp	.+2      	; 0x240a <.do_clear_bss_start>

00002408 <.do_clear_bss_loop>:
    2408:	1d 92       	st	X+, r1

0000240a <.do_clear_bss_start>:
    240a:	af 3c       	cpi	r26, 0xCF	; 207
    240c:	b1 07       	cpc	r27, r17
    240e:	e1 f7       	brne	.-8      	; 0x2408 <.do_clear_bss_loop>
    2410:	0e 94 92 12 	call	0x2524	; 0x2524 <main>
    2414:	0c 94 6d b9 	jmp	0x172da	; 0x172da <_exit>

00002418 <__bad_interrupt>:
    2418:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000241c <systemOnReset>:
	};
}


void systemOnReset(){
     if (MCUCSR & 1){   // Power-on Reset
    241c:	04 b6       	in	r0, 0x34	; 52
    241e:	00 fe       	sbrs	r0, 0
    2420:	06 c0       	rjmp	.+12     	; 0x242e <systemOnReset+0x12>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));
    2422:	14 be       	out	0x34, r1	; 52
    2424:	81 e0       	ldi	r24, 0x01	; 1
    2426:	61 e0       	ldi	r22, 0x01	; 1
    2428:	4c ec       	ldi	r20, 0xCC	; 204
    242a:	52 e0       	ldi	r21, 0x02	; 2
    242c:	16 c0       	rjmp	.+44     	; 0x245a <systemOnReset+0x3e>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    242e:	04 b6       	in	r0, 0x34	; 52
    2430:	01 fe       	sbrs	r0, 1
    2432:	06 c0       	rjmp	.+12     	; 0x2440 <systemOnReset+0x24>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    2434:	14 be       	out	0x34, r1	; 52
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	61 e0       	ldi	r22, 0x01	; 1
    243a:	43 ec       	ldi	r20, 0xC3	; 195
    243c:	52 e0       	ldi	r21, 0x02	; 2
    243e:	0d c0       	rjmp	.+26     	; 0x245a <systemOnReset+0x3e>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    2440:	04 b6       	in	r0, 0x34	; 52
    2442:	02 fe       	sbrs	r0, 2
    2444:	06 c0       	rjmp	.+12     	; 0x2452 <systemOnReset+0x36>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    2446:	14 be       	out	0x34, r1	; 52
    2448:	81 e0       	ldi	r24, 0x01	; 1
    244a:	61 e0       	ldi	r22, 0x01	; 1
    244c:	4a eb       	ldi	r20, 0xBA	; 186
    244e:	52 e0       	ldi	r21, 0x02	; 2
    2450:	04 c0       	rjmp	.+8      	; 0x245a <systemOnReset+0x3e>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    2452:	81 e0       	ldi	r24, 0x01	; 1
    2454:	61 e0       	ldi	r22, 0x01	; 1
    2456:	41 eb       	ldi	r20, 0xB1	; 177
    2458:	52 e0       	ldi	r21, 0x02	; 2
    245a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
        };
     MCUCSR=0;		  
    245e:	14 be       	out	0x34, r1	; 52
    2460:	80 ee       	ldi	r24, 0xE0	; 224
    2462:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2464:	20 e7       	ldi	r18, 0x70	; 112
    2466:	31 e0       	ldi	r19, 0x01	; 1
    2468:	f9 01       	movw	r30, r18
    246a:	31 97       	sbiw	r30, 0x01	; 1
    246c:	f1 f7       	brne	.-4      	; 0x246a <systemOnReset+0x4e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    246e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2470:	d9 f7       	brne	.-10     	; 0x2468 <systemOnReset+0x4c>
	 _delay_ms(1200);
}
    2472:	08 95       	ret

00002474 <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    2474:	0e 94 3d ac 	call	0x1587a	; 0x1587a <lcd_init>
	lcd_clear();
    2478:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	BackLightTrig();
    247c:	0e 94 22 15 	call	0x2a44	; 0x2a44 <BackLightTrig>
	systemOnReset();
    2480:	0e 94 0e 12 	call	0x241c	; 0x241c <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    2484:	84 e0       	ldi	r24, 0x04	; 4
    2486:	61 e0       	ldi	r22, 0x01	; 1
    2488:	42 ea       	ldi	r20, 0xA2	; 162
    248a:	52 e0       	ldi	r21, 0x02	; 2
    248c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    2490:	88 eb       	ldi	r24, 0xB8	; 184
    2492:	9b e0       	ldi	r25, 0x0B	; 11
    2494:	20 e7       	ldi	r18, 0x70	; 112
    2496:	31 e0       	ldi	r19, 0x01	; 1
    2498:	f9 01       	movw	r30, r18
    249a:	31 97       	sbiw	r30, 0x01	; 1
    249c:	f1 f7       	brne	.-4      	; 0x249a <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    249e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    24a0:	d9 f7       	brne	.-10     	; 0x2498 <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    24a2:	9f ef       	ldi	r25, 0xFF	; 255
    24a4:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    24a6:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    24a8:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    24aa:	98 bb       	out	0x18, r25	; 24
    24ac:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    24ae:	8d e0       	ldi	r24, 0x0D	; 13
    24b0:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    24b2:	89 e0       	ldi	r24, 0x09	; 9
    24b4:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    24b6:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    24ba:	8e e0       	ldi	r24, 0x0E	; 14
    24bc:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    24be:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    24c0:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    24c2:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    24c4:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    24c8:	80 ef       	ldi	r24, 0xF0	; 240
    24ca:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    24ce:	80 e0       	ldi	r24, 0x00	; 0
    24d0:	61 e0       	ldi	r22, 0x01	; 1
    24d2:	0e 94 34 b1 	call	0x16268	; 0x16268 <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    24d6:	bb 9a       	sbi	0x17, 3	; 23
    24d8:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    24da:	ba 98       	cbi	0x17, 2	; 23
    24dc:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    24de:	b9 98       	cbi	0x17, 1	; 23
    24e0:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    24e2:	8e b5       	in	r24, 0x2e	; 46
    24e4:	88 60       	ori	r24, 0x08	; 8
    24e6:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    24e8:	87 b7       	in	r24, 0x37	; 55
    24ea:	80 61       	ori	r24, 0x10	; 16
    24ec:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    24ee:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    24f0:	88 e0       	ldi	r24, 0x08	; 8
    24f2:	9d e3       	ldi	r25, 0x3D	; 61
    24f4:	9b bd       	out	0x2b, r25	; 43
    24f6:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    24f8:	8e b5       	in	r24, 0x2e	; 46
    24fa:	83 60       	ori	r24, 0x03	; 3
    24fc:	8e bd       	out	0x2e, r24	; 46
	systemSlave();
	_delay_ms(100);
	systemMaster();
*/
	
	InitComport();
    24fe:	0e 94 ad 99 	call	0x1335a	; 0x1335a <InitComport>
	_LIGHT_SET;
    2502:	81 e0       	ldi	r24, 0x01	; 1
    2504:	80 93 e1 03 	sts	0x03E1, r24
    2508:	10 92 e2 03 	sts	0x03E2, r1
    250c:	80 91 65 00 	lds	r24, 0x0065
    2510:	8d 7f       	andi	r24, 0xFD	; 253
    2512:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    2516:	0e 94 ca 4b 	call	0x9794	; 0x9794 <InitPrinter>
    InitializeConnection();
    251a:	0e 94 c1 78 	call	0xf182	; 0xf182 <InitializeConnection>
	lcd_clear(); 
    251e:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
}
    2522:	08 95       	ret

00002524 <main>:
void SystemInit();
//void TestUserInput();

//Program Utama
int main(){
	SystemInit();
    2524:	0e 94 3a 12 	call	0x2474	; 0x2474 <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    2528:	0e 94 5a a9 	call	0x152b4	; 0x152b4 <FMenuIdle>
    252c:	fd cf       	rjmp	.-6      	; 0x2528 <main+0x4>

0000252e <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    252e:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    2530:	e1 99       	sbic	0x1c, 1	; 28
    2532:	fe cf       	rjmp	.-4      	; 0x2530 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2534:	3f bb       	out	0x1f, r19	; 31
    2536:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2538:	e0 9a       	sbi	0x1c, 0	; 28
    253a:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    253c:	08 95       	ret

0000253e <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    253e:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    2540:	e1 99       	sbic	0x1c, 1	; 28
    2542:	fe cf       	rjmp	.-4      	; 0x2540 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2544:	3f bb       	out	0x1f, r19	; 31
    2546:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2548:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    254a:	0f b6       	in	r0, 0x3f	; 63
    254c:	f8 94       	cli
    254e:	e2 9a       	sbi	0x1c, 2	; 28
    2550:	e1 9a       	sbi	0x1c, 1	; 28
    2552:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    2554:	08 95       	ret

00002556 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    2556:	86 e1       	ldi	r24, 0x16	; 22
    2558:	08 95       	ret

0000255a <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    255a:	e8 2f       	mov	r30, r24
    255c:	f0 e0       	ldi	r31, 0x00	; 0
    255e:	ee 31       	cpi	r30, 0x1E	; 30
    2560:	f1 05       	cpc	r31, r1
    2562:	50 f5       	brcc	.+84     	; 0x25b8 <GetPumpStatusLabel+0x5e>
    2564:	ea 5b       	subi	r30, 0xBA	; 186
    2566:	ff 4f       	sbci	r31, 0xFF	; 255
    2568:	ee 0f       	add	r30, r30
    256a:	ff 1f       	adc	r31, r31
    256c:	05 90       	lpm	r0, Z+
    256e:	f4 91       	lpm	r31, Z+
    2570:	e0 2d       	mov	r30, r0
    2572:	09 94       	ijmp
    2574:	81 e3       	ldi	r24, 0x31	; 49
    2576:	08 95       	ret
    2578:	85 e4       	ldi	r24, 0x45	; 69
    257a:	08 95       	ret
    257c:	82 e3       	ldi	r24, 0x32	; 50
    257e:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    2580:	83 e3       	ldi	r24, 0x33	; 51
    2582:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    2584:	84 e3       	ldi	r24, 0x34	; 52
    2586:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    2588:	85 e3       	ldi	r24, 0x35	; 53
    258a:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    258c:	89 e6       	ldi	r24, 0x69	; 105
    258e:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    2590:	8e e6       	ldi	r24, 0x6E	; 110
    2592:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    2594:	81 e6       	ldi	r24, 0x61	; 97
    2596:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    2598:	84 e6       	ldi	r24, 0x64	; 100
    259a:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    259c:	86 e4       	ldi	r24, 0x46	; 70
    259e:	08 95       	ret
	 	  Result='P';
		  break;
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    25a0:	83 e5       	ldi	r24, 0x53	; 83
    25a2:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    25a4:	8d e2       	ldi	r24, 0x2D	; 45
    25a6:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    25a8:	89 e4       	ldi	r24, 0x49	; 73
    25aa:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
     case PS_PRINTED:
	      Result='I';
 	      break;
    25ac:	86 e5       	ldi	r24, 0x56	; 86
    25ae:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    25b0:	84 e5       	ldi	r24, 0x54	; 84
    25b2:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    25b4:	84 e7       	ldi	r24, 0x74	; 116
    25b6:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    25b8:	88 e7       	ldi	r24, 0x78	; 120
    25ba:	08 95       	ret
    25bc:	80 e5       	ldi	r24, 0x50	; 80
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    25be:	08 95       	ret

000025c0 <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    25c0:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
    25c4:	60 93 d9 0d 	sts	0x0DD9, r22
     IsControlPooling=True;
    25c8:	81 e0       	ldi	r24, 0x01	; 1
    25ca:	80 93 ad 01 	sts	0x01AD, r24
}
    25ce:	08 95       	ret

000025d0 <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    25d0:	28 2f       	mov	r18, r24
static char IsEDCFlow=False,EDCMsgCode=0;
static unsigned int nFlow=0;
     char i;
     //EDC-MSG
     if (data==0x02){
    25d2:	82 30       	cpi	r24, 0x02	; 2
    25d4:	39 f4       	brne	.+14     	; 0x25e4 <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    25d6:	81 e0       	ldi	r24, 0x01	; 1
    25d8:	80 93 cb 03 	sts	0x03CB, r24
		 nFlow=0;
    25dc:	10 92 c9 03 	sts	0x03C9, r1
    25e0:	10 92 c8 03 	sts	0x03C8, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    25e4:	80 91 cb 03 	lds	r24, 0x03CB
    25e8:	81 30       	cpi	r24, 0x01	; 1
    25ea:	69 f4       	brne	.+26     	; 0x2606 <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    25ec:	80 91 c8 03 	lds	r24, 0x03C8
    25f0:	90 91 c9 03 	lds	r25, 0x03C9
    25f4:	fc 01       	movw	r30, r24
    25f6:	e0 5e       	subi	r30, 0xE0	; 224
    25f8:	f4 4f       	sbci	r31, 0xF4	; 244
    25fa:	20 83       	st	Z, r18
		 nFlow++;
    25fc:	01 96       	adiw	r24, 0x01	; 1
    25fe:	90 93 c9 03 	sts	0x03C9, r25
    2602:	80 93 c8 03 	sts	0x03C8, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    2606:	23 30       	cpi	r18, 0x03	; 3
    2608:	41 f0       	breq	.+16     	; 0x261a <ScanEDCFlow+0x4a>
    260a:	80 91 c8 03 	lds	r24, 0x03C8
    260e:	90 91 c9 03 	lds	r25, 0x03C9
    2612:	8d 34       	cpi	r24, 0x4D	; 77
    2614:	91 05       	cpc	r25, r1
    2616:	08 f4       	brcc	.+2      	; 0x261a <ScanEDCFlow+0x4a>
    2618:	9b c0       	rjmp	.+310    	; 0x2750 <ScanEDCFlow+0x180>
	     //for(i=0;i<nFlow;i++){_uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    261a:	10 92 cb 03 	sts	0x03CB, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    261e:	30 91 22 0b 	lds	r19, 0x0B22
    2622:	30 51       	subi	r19, 0x10	; 16
    2624:	80 91 21 0b 	lds	r24, 0x0B21
    2628:	2a e0       	ldi	r18, 0x0A	; 10
    262a:	82 9f       	mul	r24, r18
    262c:	c0 01       	movw	r24, r0
    262e:	11 24       	eor	r1, r1
    2630:	38 0f       	add	r19, r24
    2632:	30 93 ca 03 	sts	0x03CA, r19

		 if (EDCMsgCode==0x03){
    2636:	33 30       	cpi	r19, 0x03	; 3
    2638:	09 f0       	breq	.+2      	; 0x263c <ScanEDCFlow+0x6c>
    263a:	65 c0       	rjmp	.+202    	; 0x2706 <ScanEDCFlow+0x136>
    263c:	e3 e2       	ldi	r30, 0x23	; 35
    263e:	fb e0       	ldi	r31, 0x0B	; 11
    2640:	ad e8       	ldi	r26, 0x8D	; 141
    2642:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2644:	81 91       	ld	r24, Z+
    2646:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2648:	8b e0       	ldi	r24, 0x0B	; 11
    264a:	e9 32       	cpi	r30, 0x29	; 41
    264c:	f8 07       	cpc	r31, r24
    264e:	d1 f7       	brne	.-12     	; 0x2644 <ScanEDCFlow+0x74>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2650:	10 92 93 0e 	sts	0x0E93, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2654:	80 81       	ld	r24, Z
    2656:	80 93 c3 09 	sts	0x09C3, r24
    265a:	81 81       	ldd	r24, Z+1	; 0x01
    265c:	80 93 c4 09 	sts	0x09C4, r24
	 }Dest[Length]=0;
    2660:	10 92 c5 09 	sts	0x09C5, r1
    2664:	32 96       	adiw	r30, 0x02	; 2
    2666:	a9 ea       	ldi	r26, 0xA9	; 169
    2668:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    266a:	81 91       	ld	r24, Z+
    266c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    266e:	8b e0       	ldi	r24, 0x0B	; 11
    2670:	ea 33       	cpi	r30, 0x3A	; 58
    2672:	f8 07       	cpc	r31, r24
    2674:	d1 f7       	brne	.-12     	; 0x266a <ScanEDCFlow+0x9a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2676:	10 92 b8 0e 	sts	0x0EB8, r1
    267a:	ac e8       	ldi	r26, 0x8C	; 140
    267c:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    267e:	81 91       	ld	r24, Z+
    2680:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2682:	8b e0       	ldi	r24, 0x0B	; 11
    2684:	ed 34       	cpi	r30, 0x4D	; 77
    2686:	f8 07       	cpc	r31, r24
    2688:	d1 f7       	brne	.-12     	; 0x267e <ScanEDCFlow+0xae>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    268a:	10 92 9f 0d 	sts	0x0D9F, r1
    268e:	20 e0       	ldi	r18, 0x00	; 0
    2690:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2692:	f9 01       	movw	r30, r18
    2694:	e5 5f       	subi	r30, 0xF5	; 245
    2696:	f5 4f       	sbci	r31, 0xF5	; 245
    2698:	d9 01       	movw	r26, r18
    269a:	a0 5e       	subi	r26, 0xE0	; 224
    269c:	b4 4f       	sbci	r27, 0xF4	; 244
    269e:	9d 96       	adiw	r26, 0x2d	; 45
    26a0:	8c 91       	ld	r24, X
    26a2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26a4:	2f 5f       	subi	r18, 0xFF	; 255
    26a6:	3f 4f       	sbci	r19, 0xFF	; 255
    26a8:	26 30       	cpi	r18, 0x06	; 6
    26aa:	31 05       	cpc	r19, r1
    26ac:	91 f7       	brne	.-28     	; 0x2692 <ScanEDCFlow+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26ae:	10 92 11 0a 	sts	0x0A11, r1
    26b2:	20 e0       	ldi	r18, 0x00	; 0
    26b4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    26b6:	f9 01       	movw	r30, r18
    26b8:	e3 5a       	subi	r30, 0xA3	; 163
    26ba:	f6 4f       	sbci	r31, 0xF6	; 246
    26bc:	d9 01       	movw	r26, r18
    26be:	a0 5e       	subi	r26, 0xE0	; 224
    26c0:	b4 4f       	sbci	r27, 0xF4	; 244
    26c2:	d3 96       	adiw	r26, 0x33	; 51
    26c4:	8c 91       	ld	r24, X
    26c6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26c8:	2f 5f       	subi	r18, 0xFF	; 255
    26ca:	3f 4f       	sbci	r19, 0xFF	; 255
    26cc:	2a 30       	cpi	r18, 0x0A	; 10
    26ce:	31 05       	cpc	r19, r1
    26d0:	91 f7       	brne	.-28     	; 0x26b6 <ScanEDCFlow+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26d2:	10 92 67 09 	sts	0x0967, r1
    26d6:	20 e0       	ldi	r18, 0x00	; 0
    26d8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    26da:	f9 01       	movw	r30, r18
    26dc:	ee 53       	subi	r30, 0x3E	; 62
    26de:	f2 4f       	sbci	r31, 0xF2	; 242
    26e0:	d9 01       	movw	r26, r18
    26e2:	a0 5e       	subi	r26, 0xE0	; 224
    26e4:	b4 4f       	sbci	r27, 0xF4	; 244
    26e6:	dd 96       	adiw	r26, 0x3d	; 61
    26e8:	8c 91       	ld	r24, X
    26ea:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26ec:	2f 5f       	subi	r18, 0xFF	; 255
    26ee:	3f 4f       	sbci	r19, 0xFF	; 255
    26f0:	2e 30       	cpi	r18, 0x0E	; 14
    26f2:	31 05       	cpc	r19, r1
    26f4:	91 f7       	brne	.-28     	; 0x26da <ScanEDCFlow+0x10a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26f6:	10 92 d0 0d 	sts	0x0DD0, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    26fa:	81 e0       	ldi	r24, 0x01	; 1
    26fc:	80 93 c5 01 	sts	0x01C5, r24
			 IsPrintApprovalCode=True;
    2700:	80 93 c6 01 	sts	0x01C6, r24
    2704:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    2706:	34 30       	cpi	r19, 0x04	; 4
    2708:	19 f5       	brne	.+70     	; 0x2750 <ScanEDCFlow+0x180>
    270a:	e3 e2       	ldi	r30, 0x23	; 35
    270c:	fb e0       	ldi	r31, 0x0B	; 11
    270e:	ab e0       	ldi	r26, 0x0B	; 11
    2710:	ba e0       	ldi	r27, 0x0A	; 10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2712:	81 91       	ld	r24, Z+
    2714:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2716:	8b e0       	ldi	r24, 0x0B	; 11
    2718:	e9 32       	cpi	r30, 0x29	; 41
    271a:	f8 07       	cpc	r31, r24
    271c:	d1 f7       	brne	.-12     	; 0x2712 <ScanEDCFlow+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    271e:	10 92 11 0a 	sts	0x0A11, r1
    2722:	ad e5       	ldi	r26, 0x5D	; 93
    2724:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2726:	81 91       	ld	r24, Z+
    2728:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    272a:	8b e0       	ldi	r24, 0x0B	; 11
    272c:	e3 33       	cpi	r30, 0x33	; 51
    272e:	f8 07       	cpc	r31, r24
    2730:	d1 f7       	brne	.-12     	; 0x2726 <ScanEDCFlow+0x156>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2732:	10 92 67 09 	sts	0x0967, r1
    2736:	a2 ec       	ldi	r26, 0xC2	; 194
    2738:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    273a:	81 91       	ld	r24, Z+
    273c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    273e:	8b e0       	ldi	r24, 0x0B	; 11
    2740:	e1 34       	cpi	r30, 0x41	; 65
    2742:	f8 07       	cpc	r31, r24
    2744:	d1 f7       	brne	.-12     	; 0x273a <ScanEDCFlow+0x16a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2746:	10 92 d0 0d 	sts	0x0DD0, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    274a:	81 e0       	ldi	r24, 0x01	; 1
    274c:	80 93 c7 01 	sts	0x01C7, r24
    2750:	08 95       	ret

00002752 <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    2752:	08 95       	ret

00002754 <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    2754:	98 2f       	mov	r25, r24
    2756:	ef e9       	ldi	r30, 0x9F	; 159
    2758:	fa e0       	ldi	r31, 0x0A	; 10
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    275a:	80 81       	ld	r24, Z
    275c:	81 83       	std	Z+1, r24	; 0x01
    275e:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    2760:	8a e0       	ldi	r24, 0x0A	; 10
    2762:	ec 38       	cpi	r30, 0x8C	; 140
    2764:	f8 07       	cpc	r31, r24
    2766:	c9 f7       	brne	.-14     	; 0x275a <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    2768:	9f 01       	movw	r18, r30
    276a:	2f 5f       	subi	r18, 0xFF	; 255
    276c:	3f 4f       	sbci	r19, 0xFF	; 255
    276e:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    2770:	84 85       	ldd	r24, Z+12	; 0x0c
    2772:	82 30       	cpi	r24, 0x02	; 2
    2774:	f9 f4       	brne	.+62     	; 0x27b4 <ScanRFIDFlow+0x60>
    2776:	80 91 8e 0a 	lds	r24, 0x0A8E
    277a:	8a 30       	cpi	r24, 0x0A	; 10
    277c:	d9 f4       	brne	.+54     	; 0x27b4 <ScanRFIDFlow+0x60>
    277e:	93 30       	cpi	r25, 0x03	; 3
    2780:	c9 f4       	brne	.+50     	; 0x27b4 <ScanRFIDFlow+0x60>
    2782:	f9 01       	movw	r30, r18
    2784:	3a 96       	adiw	r30, 0x0a	; 10
    2786:	a7 e5       	ldi	r26, 0x57	; 87
    2788:	be e0       	ldi	r27, 0x0E	; 14
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    278a:	80 81       	ld	r24, Z
    278c:	8d 93       	st	X+, r24
    278e:	31 97       	sbiw	r30, 0x01	; 1
    2790:	8a e0       	ldi	r24, 0x0A	; 10
    2792:	ef 38       	cpi	r30, 0x8F	; 143
    2794:	f8 07       	cpc	r31, r24
    2796:	c9 f7       	brne	.-14     	; 0x278a <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    2798:	10 92 5f 0e 	sts	0x0E5F, r1
	    IsRFIDDetected=True;
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	80 93 c4 01 	sts	0x01C4, r24
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    27a2:	80 93 e1 03 	sts	0x03E1, r24
    27a6:	10 92 e2 03 	sts	0x03E2, r1
    27aa:	80 91 65 00 	lds	r24, 0x0065
    27ae:	8d 7f       	andi	r24, 0xFD	; 253
    27b0:	80 93 65 00 	sts	0x0065, r24
    27b4:	08 95       	ret

000027b6 <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    27b6:	1f 92       	push	r1
    27b8:	0f 92       	push	r0
    27ba:	0f b6       	in	r0, 0x3f	; 63
    27bc:	0f 92       	push	r0
    27be:	11 24       	eor	r1, r1
    27c0:	8f 93       	push	r24
    27c2:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    27c4:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    27c6:	80 91 e0 01 	lds	r24, 0x01E0
    27ca:	81 30       	cpi	r24, 0x01	; 1
    27cc:	21 f0       	breq	.+8      	; 0x27d6 <__vector_18+0x20>
    27ce:	80 91 df 01 	lds	r24, 0x01DF
    27d2:	81 30       	cpi	r24, 0x01	; 1
    27d4:	51 f4       	brne	.+20     	; 0x27ea <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    27d6:	93 31       	cpi	r25, 0x13	; 19
    27d8:	21 f4       	brne	.+8      	; 0x27e2 <__vector_18+0x2c>
    27da:	81 e0       	ldi	r24, 0x01	; 1
    27dc:	80 93 de 01 	sts	0x01DE, r24
    27e0:	04 c0       	rjmp	.+8      	; 0x27ea <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    27e2:	91 31       	cpi	r25, 0x11	; 17
    27e4:	11 f4       	brne	.+4      	; 0x27ea <__vector_18+0x34>
    27e6:	10 92 de 01 	sts	0x01DE, r1
	}
}
    27ea:	9f 91       	pop	r25
    27ec:	8f 91       	pop	r24
    27ee:	0f 90       	pop	r0
    27f0:	0f be       	out	0x3f, r0	; 63
    27f2:	0f 90       	pop	r0
    27f4:	1f 90       	pop	r1
    27f6:	18 95       	reti

000027f8 <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    27f8:	80 e0       	ldi	r24, 0x00	; 0
    27fa:	08 95       	ret

000027fc <ConfigProtocol>:
	 }
	 _uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    27fc:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    27fe:	80 91 c6 03 	lds	r24, 0x03C6
    2802:	89 36       	cpi	r24, 0x69	; 105
    2804:	e9 f4       	brne	.+58     	; 0x2840 <ConfigProtocol+0x44>
    2806:	80 91 c5 03 	lds	r24, 0x03C5
    280a:	83 34       	cpi	r24, 0x43	; 67
    280c:	c9 f4       	brne	.+50     	; 0x2840 <ConfigProtocol+0x44>
    280e:	80 91 c4 03 	lds	r24, 0x03C4
    2812:	8f 36       	cpi	r24, 0x6F	; 111
    2814:	a9 f4       	brne	.+42     	; 0x2840 <ConfigProtocol+0x44>
    2816:	80 91 c3 03 	lds	r24, 0x03C3
    281a:	8e 36       	cpi	r24, 0x6E	; 110
    281c:	89 f4       	brne	.+34     	; 0x2840 <ConfigProtocol+0x44>
    281e:	80 91 c2 03 	lds	r24, 0x03C2
    2822:	86 36       	cpi	r24, 0x66	; 102
    2824:	69 f4       	brne	.+26     	; 0x2840 <ConfigProtocol+0x44>
    2826:	80 91 c1 03 	lds	r24, 0x03C1
    282a:	8f 33       	cpi	r24, 0x3F	; 63
    282c:	49 f4       	brne	.+18     	; 0x2840 <ConfigProtocol+0x44>
    282e:	80 91 c0 03 	lds	r24, 0x03C0
    2832:	8d 30       	cpi	r24, 0x0D	; 13
    2834:	29 f4       	brne	.+10     	; 0x2840 <ConfigProtocol+0x44>
    2836:	2a 30       	cpi	r18, 0x0A	; 10
    2838:	19 f4       	brne	.+6      	; 0x2840 <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    283a:	82 e0       	ldi	r24, 0x02	; 2
    283c:	80 93 dc 01 	sts	0x01DC, r24
	}

	if (IsConfigFlow==True){        
    2840:	80 91 ae 01 	lds	r24, 0x01AE
    2844:	81 30       	cpi	r24, 0x01	; 1
    2846:	69 f4       	brne	.+26     	; 0x2862 <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    2848:	80 91 b1 01 	lds	r24, 0x01B1
    284c:	90 91 b2 01 	lds	r25, 0x01B2
    2850:	fc 01       	movw	r30, r24
    2852:	e0 5e       	subi	r30, 0xE0	; 224
    2854:	f4 4f       	sbci	r31, 0xF4	; 244
    2856:	20 83       	st	Z, r18
	    char_count++; 
    2858:	01 96       	adiw	r24, 0x01	; 1
    285a:	90 93 b2 01 	sts	0x01B2, r25
    285e:	80 93 b1 01 	sts	0x01B1, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    2862:	80 91 c0 03 	lds	r24, 0x03C0
    2866:	84 30       	cpi	r24, 0x04	; 4
    2868:	51 f4       	brne	.+20     	; 0x287e <ConfigProtocol+0x82>
    286a:	20 34       	cpi	r18, 0x40	; 64
    286c:	e9 f4       	brne	.+58     	; 0x28a8 <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    286e:	81 e0       	ldi	r24, 0x01	; 1
    2870:	80 93 ae 01 	sts	0x01AE, r24
		 char_count=0;
    2874:	10 92 b2 01 	sts	0x01B2, r1
    2878:	10 92 b1 01 	sts	0x01B1, r1
    287c:	15 c0       	rjmp	.+42     	; 0x28a8 <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    287e:	85 30       	cpi	r24, 0x05	; 5
    2880:	99 f4       	brne	.+38     	; 0x28a8 <ConfigProtocol+0xac>
    2882:	20 35       	cpi	r18, 0x50	; 80
    2884:	89 f4       	brne	.+34     	; 0x28a8 <ConfigProtocol+0xac>
	     transLength=char_count;
    2886:	80 91 b1 01 	lds	r24, 0x01B1
    288a:	90 91 b2 01 	lds	r25, 0x01B2
    288e:	90 93 b4 01 	sts	0x01B4, r25
    2892:	80 93 b3 01 	sts	0x01B3, r24
		 char_count=0;
    2896:	10 92 b2 01 	sts	0x01B2, r1
    289a:	10 92 b1 01 	sts	0x01B1, r1
	     IsConfigFlow=False;
    289e:	10 92 ae 01 	sts	0x01AE, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    28a2:	81 e0       	ldi	r24, 0x01	; 1
    28a4:	80 93 dc 01 	sts	0x01DC, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    28a8:	80 91 c5 03 	lds	r24, 0x03C5
    28ac:	80 93 c6 03 	sts	0x03C6, r24
	Conflow[5]=Conflow[4];
    28b0:	80 91 c4 03 	lds	r24, 0x03C4
    28b4:	80 93 c5 03 	sts	0x03C5, r24
	Conflow[4]=Conflow[3];
    28b8:	80 91 c3 03 	lds	r24, 0x03C3
    28bc:	80 93 c4 03 	sts	0x03C4, r24
	Conflow[3]=Conflow[2];
    28c0:	80 91 c2 03 	lds	r24, 0x03C2
    28c4:	80 93 c3 03 	sts	0x03C3, r24
	Conflow[2]=Conflow[1];
    28c8:	80 91 c1 03 	lds	r24, 0x03C1
    28cc:	80 93 c2 03 	sts	0x03C2, r24
	Conflow[1]=Conflow[0];
    28d0:	80 91 c0 03 	lds	r24, 0x03C0
    28d4:	80 93 c1 03 	sts	0x03C1, r24
	Conflow[0]=dataIn;
    28d8:	20 93 c0 03 	sts	0x03C0, r18

}
    28dc:	08 95       	ret

000028de <system_beep>:
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    28de:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    28e0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    28e2:	90 93 ed 01 	sts	0x01ED, r25
    28e6:	80 93 ec 01 	sts	0x01EC, r24
}
    28ea:	08 95       	ret

000028ec <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    28ec:	08 95       	ret

000028ee <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    28ee:	8f 70       	andi	r24, 0x0F	; 15
    28f0:	08 95       	ret

000028f2 <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    28f2:	82 95       	swap	r24
    28f4:	8f 70       	andi	r24, 0x0F	; 15
    28f6:	08 95       	ret

000028f8 <Str>:
char Str(char H){
    28f8:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    28fa:	8a 30       	cpi	r24, 0x0A	; 10
    28fc:	10 f4       	brcc	.+4      	; 0x2902 <Str+0xa>
    28fe:	80 5d       	subi	r24, 0xD0	; 208
    2900:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2902:	8a 50       	subi	r24, 0x0A	; 10
    2904:	86 30       	cpi	r24, 0x06	; 6
    2906:	10 f0       	brcs	.+4      	; 0x290c <Str+0x14>
    2908:	80 e0       	ldi	r24, 0x00	; 0
    290a:	08 95       	ret
    290c:	89 2f       	mov	r24, r25
    290e:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2910:	08 95       	ret

00002912 <charToHex>:

void charToHex(char X, char *Result){
    2912:	28 2f       	mov	r18, r24
    2914:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2916:	98 2f       	mov	r25, r24
    2918:	92 95       	swap	r25
    291a:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    291c:	9a 30       	cpi	r25, 0x0A	; 10
    291e:	18 f4       	brcc	.+6      	; 0x2926 <charToHex+0x14>
    2920:	89 2f       	mov	r24, r25
    2922:	80 5d       	subi	r24, 0xD0	; 208
    2924:	08 c0       	rjmp	.+16     	; 0x2936 <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2926:	89 2f       	mov	r24, r25
    2928:	8a 50       	subi	r24, 0x0A	; 10
    292a:	86 30       	cpi	r24, 0x06	; 6
    292c:	10 f0       	brcs	.+4      	; 0x2932 <charToHex+0x20>
    292e:	80 e0       	ldi	r24, 0x00	; 0
    2930:	02 c0       	rjmp	.+4      	; 0x2936 <charToHex+0x24>
    2932:	89 2f       	mov	r24, r25
    2934:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2936:	80 83       	st	Z, r24



char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2938:	92 2f       	mov	r25, r18
    293a:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    293c:	9a 30       	cpi	r25, 0x0A	; 10
    293e:	18 f4       	brcc	.+6      	; 0x2946 <charToHex+0x34>
    2940:	89 2f       	mov	r24, r25
    2942:	80 5d       	subi	r24, 0xD0	; 208
    2944:	08 c0       	rjmp	.+16     	; 0x2956 <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2946:	89 2f       	mov	r24, r25
    2948:	8a 50       	subi	r24, 0x0A	; 10
    294a:	86 30       	cpi	r24, 0x06	; 6
    294c:	10 f0       	brcs	.+4      	; 0x2952 <charToHex+0x40>
    294e:	80 e0       	ldi	r24, 0x00	; 0
    2950:	02 c0       	rjmp	.+4      	; 0x2956 <charToHex+0x44>
    2952:	89 2f       	mov	r24, r25
    2954:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2956:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2958:	12 82       	std	Z+2, r1	; 0x02
	 
}
    295a:	08 95       	ret

0000295c <strToInt>:

char strToInt(char *str){
    295c:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    295e:	80 81       	ld	r24, Z
    2960:	2a e0       	ldi	r18, 0x0A	; 10
    2962:	82 9f       	mul	r24, r18
    2964:	90 01       	movw	r18, r0
    2966:	11 24       	eor	r1, r1
    2968:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    296a:	82 0f       	add	r24, r18
    296c:	08 95       	ret

0000296e <intToStr>:

void intToStr(char X, char *str){
    296e:	58 2f       	mov	r21, r24
    2970:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    2972:	64 e6       	ldi	r22, 0x64	; 100
    2974:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    2978:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    297a:	85 2f       	mov	r24, r21
    297c:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    2980:	89 2f       	mov	r24, r25
    2982:	6a e0       	ldi	r22, 0x0A	; 10
    2984:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    2988:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    298a:	8c e9       	ldi	r24, 0x9C	; 156
    298c:	9f ef       	ldi	r25, 0xFF	; 255
    298e:	a8 9f       	mul	r26, r24
    2990:	80 2d       	mov	r24, r0
    2992:	11 24       	eor	r1, r1
    2994:	85 0f       	add	r24, r21
    2996:	26 ef       	ldi	r18, 0xF6	; 246
    2998:	3f ef       	ldi	r19, 0xFF	; 255
    299a:	42 9f       	mul	r20, r18
    299c:	90 2d       	mov	r25, r0
    299e:	11 24       	eor	r1, r1
    29a0:	98 0f       	add	r25, r24
	 if (X>=100){
    29a2:	54 36       	cpi	r21, 0x64	; 100
    29a4:	40 f0       	brcs	.+16     	; 0x29b6 <intToStr+0x48>
	     str[0]=('0'+R);
    29a6:	a0 5d       	subi	r26, 0xD0	; 208
    29a8:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    29aa:	40 5d       	subi	r20, 0xD0	; 208
    29ac:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    29ae:	90 5d       	subi	r25, 0xD0	; 208
    29b0:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    29b2:	13 82       	std	Z+3, r1	; 0x03
    29b4:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    29b6:	5b 30       	cpi	r21, 0x0B	; 11
    29b8:	18 f4       	brcc	.+6      	; 0x29c0 <intToStr+0x52>
	     str[0]=('0'+S);
    29ba:	90 5d       	subi	r25, 0xD0	; 208
    29bc:	90 83       	st	Z, r25
	     str[1]=0;
    29be:	11 82       	std	Z+1, r1	; 0x01
    29c0:	08 95       	ret

000029c2 <ViewCardID>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void ViewCardID(){//+12345678 -->12345678
    29c2:	20 e0       	ldi	r18, 0x00	; 0
    29c4:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    29c6:	f9 01       	movw	r30, r18
    29c8:	e4 57       	subi	r30, 0x74	; 116
    29ca:	f2 4f       	sbci	r31, 0xF2	; 242
    29cc:	d9 01       	movw	r26, r18
    29ce:	a9 5a       	subi	r26, 0xA9	; 169
    29d0:	b1 4f       	sbci	r27, 0xF1	; 241
    29d2:	8c 91       	ld	r24, X
    29d4:	80 83       	st	Z, r24
    29d6:	2f 5f       	subi	r18, 0xFF	; 255
    29d8:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    29da:	28 30       	cpi	r18, 0x08	; 8
    29dc:	31 05       	cpc	r19, r1
    29de:	99 f7       	brne	.-26     	; 0x29c6 <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    29e0:	10 92 94 0d 	sts	0x0D94, r1
}
    29e4:	08 95       	ret

000029e6 <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    29e6:	cf 93       	push	r28
    29e8:	df 93       	push	r29
    29ea:	db 01       	movw	r26, r22
    29ec:	ec 01       	movw	r28, r24
    29ee:	20 e0       	ldi	r18, 0x00	; 0
    29f0:	30 e0       	ldi	r19, 0x00	; 0
    29f2:	07 c0       	rjmp	.+14     	; 0x2a02 <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    29f4:	fd 01       	movw	r30, r26
    29f6:	e2 0f       	add	r30, r18
    29f8:	f3 1f       	adc	r31, r19
    29fa:	89 91       	ld	r24, Y+
    29fc:	80 83       	st	Z, r24
    29fe:	2f 5f       	subi	r18, 0xFF	; 255
    2a00:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2a02:	24 17       	cp	r18, r20
    2a04:	b8 f3       	brcs	.-18     	; 0x29f4 <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2a06:	a4 0f       	add	r26, r20
    2a08:	b1 1d       	adc	r27, r1
    2a0a:	1c 92       	st	X, r1
}
    2a0c:	df 91       	pop	r29
    2a0e:	cf 91       	pop	r28
    2a10:	08 95       	ret

00002a12 <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2a12:	cf 93       	push	r28
    2a14:	df 93       	push	r29
    2a16:	db 01       	movw	r26, r22
    2a18:	ec 01       	movw	r28, r24
    2a1a:	c4 0f       	add	r28, r20
    2a1c:	d1 1d       	adc	r29, r1
    2a1e:	40 e0       	ldi	r20, 0x00	; 0
    2a20:	50 e0       	ldi	r21, 0x00	; 0
    2a22:	07 c0       	rjmp	.+14     	; 0x2a32 <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2a24:	fd 01       	movw	r30, r26
    2a26:	e4 0f       	add	r30, r20
    2a28:	f5 1f       	adc	r31, r21
    2a2a:	89 91       	ld	r24, Y+
    2a2c:	80 83       	st	Z, r24
    2a2e:	4f 5f       	subi	r20, 0xFF	; 255
    2a30:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2a32:	42 17       	cp	r20, r18
    2a34:	b8 f3       	brcs	.-18     	; 0x2a24 <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2a36:	a2 0f       	add	r26, r18
    2a38:	b1 1d       	adc	r27, r1
    2a3a:	1c 92       	st	X, r1
}
    2a3c:	df 91       	pop	r29
    2a3e:	cf 91       	pop	r28
    2a40:	08 95       	ret

00002a42 <TestLocalAccount>:

void TestLocalAccount(){

}
    2a42:	08 95       	ret

00002a44 <BackLightTrig>:
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	80 93 e1 03 	sts	0x03E1, r24
    2a4a:	10 92 e2 03 	sts	0x03E2, r1
    2a4e:	e5 e6       	ldi	r30, 0x65	; 101
    2a50:	f0 e0       	ldi	r31, 0x00	; 0
    2a52:	80 81       	ld	r24, Z
    2a54:	8d 7f       	andi	r24, 0xFD	; 253
    2a56:	80 83       	st	Z, r24
}
    2a58:	08 95       	ret

00002a5a <FBackLight>:

void FBackLight(){
     if (TimBackLight>0){
    2a5a:	20 91 b7 01 	lds	r18, 0x01B7
    2a5e:	30 91 b8 01 	lds	r19, 0x01B8
    2a62:	21 15       	cp	r18, r1
    2a64:	31 05       	cpc	r19, r1
    2a66:	61 f0       	breq	.+24     	; 0x2a80 <FBackLight+0x26>
	     PORTG=PORTG&0xFD;
    2a68:	80 91 65 00 	lds	r24, 0x0065
    2a6c:	8d 7f       	andi	r24, 0xFD	; 253
    2a6e:	80 93 65 00 	sts	0x0065, r24
	     TimBackLight--;
    2a72:	21 50       	subi	r18, 0x01	; 1
    2a74:	30 40       	sbci	r19, 0x00	; 0
    2a76:	30 93 b8 01 	sts	0x01B8, r19
    2a7a:	20 93 b7 01 	sts	0x01B7, r18
    2a7e:	08 95       	ret
		 }
	 else PORTG=PORTG|0x02;
    2a80:	80 91 65 00 	lds	r24, 0x0065
    2a84:	82 60       	ori	r24, 0x02	; 2
    2a86:	80 93 65 00 	sts	0x0065, r24
    2a8a:	08 95       	ret

00002a8c <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2a8c:	82 30       	cpi	r24, 0x02	; 2
    2a8e:	59 f0       	breq	.+22     	; 0x2aa6 <GetBaudrate+0x1a>
    2a90:	82 30       	cpi	r24, 0x02	; 2
    2a92:	18 f0       	brcs	.+6      	; 0x2a9a <GetBaudrate+0xe>
    2a94:	83 30       	cpi	r24, 0x03	; 3
    2a96:	21 f4       	brne	.+8      	; 0x2aa0 <GetBaudrate+0x14>
    2a98:	09 c0       	rjmp	.+18     	; 0x2aac <GetBaudrate+0x20>
    2a9a:	20 e8       	ldi	r18, 0x80	; 128
    2a9c:	35 e2       	ldi	r19, 0x25	; 37
    2a9e:	08 c0       	rjmp	.+16     	; 0x2ab0 <GetBaudrate+0x24>
    2aa0:	20 e0       	ldi	r18, 0x00	; 0
    2aa2:	30 e0       	ldi	r19, 0x00	; 0
    2aa4:	05 c0       	rjmp	.+10     	; 0x2ab0 <GetBaudrate+0x24>
    2aa6:	20 e0       	ldi	r18, 0x00	; 0
    2aa8:	3b e4       	ldi	r19, 0x4B	; 75
    2aaa:	02 c0       	rjmp	.+4      	; 0x2ab0 <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2aac:	2b e9       	ldi	r18, 0x9B	; 155
    2aae:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2ab0:	c9 01       	movw	r24, r18
    2ab2:	08 95       	ret

00002ab4 <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2ab4:	e1 99       	sbic	0x1c, 1	; 28
    2ab6:	fe cf       	rjmp	.-4      	; 0x2ab4 <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2ab8:	84 e7       	ldi	r24, 0x74	; 116
    2aba:	91 e0       	ldi	r25, 0x01	; 1
    2abc:	9f bb       	out	0x1f, r25	; 31
    2abe:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2ac0:	e0 9a       	sbi	0x1c, 0	; 28
    2ac2:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2ac4:	80 93 75 01 	sts	0x0175, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2ac8:	e1 99       	sbic	0x1c, 1	; 28
    2aca:	fe cf       	rjmp	.-4      	; 0x2ac8 <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2acc:	89 e7       	ldi	r24, 0x79	; 121
    2ace:	91 e0       	ldi	r25, 0x01	; 1
    2ad0:	9f bb       	out	0x1f, r25	; 31
    2ad2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2ad4:	e0 9a       	sbi	0x1c, 0	; 28
    2ad6:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2ad8:	80 93 76 01 	sts	0x0176, r24
}
    2adc:	08 95       	ret

00002ade <DisplayQueueFIP>:
}


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2ade:	08 95       	ret

00002ae0 <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2ae0:	08 95       	ret

00002ae2 <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2ae2:	86 27       	eor	r24, r22
    2ae4:	08 95       	ret

00002ae6 <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2ae6:	08 95       	ret

00002ae8 <GeniusCalc>:
}


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
     switch(cOption){
    2ae8:	88 23       	and	r24, r24
    2aea:	19 f0       	breq	.+6      	; 0x2af2 <GeniusCalc+0xa>
    2aec:	81 30       	cpi	r24, 0x01	; 1
    2aee:	49 f5       	brne	.+82     	; 0x2b42 <GeniusCalc+0x5a>
    2af0:	11 c0       	rjmp	.+34     	; 0x2b14 <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2af2:	26 2f       	mov	r18, r22
    2af4:	30 e0       	ldi	r19, 0x00	; 0
    2af6:	24 0f       	add	r18, r20
    2af8:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2afa:	c9 01       	movw	r24, r18
    2afc:	6a e0       	ldi	r22, 0x0A	; 10
    2afe:	70 e0       	ldi	r23, 0x00	; 0
    2b00:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    2b04:	48 2f       	mov	r20, r24
    2b06:	c9 01       	movw	r24, r18
    2b08:	6a e0       	ldi	r22, 0x0A	; 10
    2b0a:	70 e0       	ldi	r23, 0x00	; 0
    2b0c:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    2b10:	46 0f       	add	r20, r22
    2b12:	17 c0       	rjmp	.+46     	; 0x2b42 <GeniusCalc+0x5a>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2b14:	66 23       	and	r22, r22
    2b16:	09 f4       	brne	.+2      	; 0x2b1a <GeniusCalc+0x32>
    2b18:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2b1a:	44 23       	and	r20, r20
    2b1c:	09 f4       	brne	.+2      	; 0x2b20 <GeniusCalc+0x38>
    2b1e:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2b20:	46 9f       	mul	r20, r22
    2b22:	90 01       	movw	r18, r0
    2b24:	11 24       	eor	r1, r1
    2b26:	c9 01       	movw	r24, r18
    2b28:	6a e0       	ldi	r22, 0x0A	; 10
    2b2a:	70 e0       	ldi	r23, 0x00	; 0
    2b2c:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    2b30:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2b32:	c9 01       	movw	r24, r18
    2b34:	6a e0       	ldi	r22, 0x0A	; 10
    2b36:	70 e0       	ldi	r23, 0x00	; 0
    2b38:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    2b3c:	64 2f       	mov	r22, r20
    2b3e:	48 2f       	mov	r20, r24
    2b40:	d8 cf       	rjmp	.-80     	; 0x2af2 <GeniusCalc+0xa>
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2b42:	84 2f       	mov	r24, r20
    2b44:	08 95       	ret

00002b46 <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2b46:	81 e0       	ldi	r24, 0x01	; 1
    2b48:	08 95       	ret

00002b4a <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2b4a:	ff 92       	push	r15
    2b4c:	0f 93       	push	r16
    2b4e:	1f 93       	push	r17
    2b50:	cf 93       	push	r28
    2b52:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2b54:	f0 90 75 01 	lds	r15, 0x0175
    2b58:	ec 01       	movw	r28, r24
    2b5a:	00 e0       	ldi	r16, 0x00	; 0
    2b5c:	10 e0       	ldi	r17, 0x00	; 0
    2b5e:	09 c0       	rjmp	.+18     	; 0x2b72 <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2b60:	8e e0       	ldi	r24, 0x0E	; 14
    2b62:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    2b66:	98 81       	ld	r25, Y
    2b68:	98 17       	cp	r25, r24
    2b6a:	09 f4       	brne	.+2      	; 0x2b6e <CountNoPumpSatus+0x24>
		      Result++;		  
    2b6c:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2b6e:	0f 5f       	subi	r16, 0xFF	; 255
    2b70:	21 96       	adiw	r28, 0x01	; 1
    2b72:	0f 15       	cp	r16, r15
    2b74:	a8 f3       	brcs	.-22     	; 0x2b60 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2b76:	81 2f       	mov	r24, r17
    2b78:	df 91       	pop	r29
    2b7a:	cf 91       	pop	r28
    2b7c:	1f 91       	pop	r17
    2b7e:	0f 91       	pop	r16
    2b80:	ff 90       	pop	r15
    2b82:	08 95       	ret

00002b84 <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2b84:	08 95       	ret

00002b86 <FLockPump>:
char FLockPump(){

}
    2b86:	08 95       	ret

00002b88 <menu_product>:
   return Result;
}

void menu_product(){

}
    2b88:	08 95       	ret

00002b8a <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2b8a:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2b8c:	80 81       	ld	r24, Z
    2b8e:	84 17       	cp	r24, r20
    2b90:	18 f4       	brcc	.+6      	; 0x2b98 <IncValue+0xe>
	     (*Value)++;
    2b92:	8f 5f       	subi	r24, 0xFF	; 255
    2b94:	80 83       	st	Z, r24
    2b96:	08 95       	ret
	 }else *Value=MinValue;
    2b98:	60 83       	st	Z, r22
    2b9a:	08 95       	ret

00002b9c <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2b9c:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2b9e:	80 81       	ld	r24, Z
    2ba0:	68 17       	cp	r22, r24
    2ba2:	18 f4       	brcc	.+6      	; 0x2baa <DecValue+0xe>
	     (*Value)--;
    2ba4:	81 50       	subi	r24, 0x01	; 1
    2ba6:	80 83       	st	Z, r24
    2ba8:	08 95       	ret
	 }else *Value=MaxValue;
    2baa:	40 83       	st	Z, r20
    2bac:	08 95       	ret

00002bae <zeroIP>:
	if(__result==0)
		eeprom_write_block((const void*) &__buf_string, (void*) &__opp_name, _MAX_OPP + 1);
}


void zeroIP(unsigned char Val,char *StrResult){
    2bae:	58 2f       	mov	r21, r24
    2bb0:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2bb2:	84 36       	cpi	r24, 0x64	; 100
    2bb4:	00 f1       	brcs	.+64     	; 0x2bf6 <zeroIP+0x48>
	    R=(Val/100);
    2bb6:	64 e6       	ldi	r22, 0x64	; 100
    2bb8:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    2bbc:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2bbe:	85 2f       	mov	r24, r21
    2bc0:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    2bc4:	89 2f       	mov	r24, r25
    2bc6:	6a e0       	ldi	r22, 0x0A	; 10
    2bc8:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2bcc:	40 5d       	subi	r20, 0xD0	; 208
    2bce:	40 83       	st	Z, r20
    2bd0:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2bd2:	80 5d       	subi	r24, 0xD0	; 208
    2bd4:	81 83       	std	Z+1, r24	; 0x01
    2bd6:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2bd8:	50 5d       	subi	r21, 0xD0	; 208
    2bda:	2c e9       	ldi	r18, 0x9C	; 156
    2bdc:	3f ef       	ldi	r19, 0xFF	; 255
    2bde:	42 9f       	mul	r20, r18
    2be0:	40 2d       	mov	r20, r0
    2be2:	11 24       	eor	r1, r1
    2be4:	45 0f       	add	r20, r21
    2be6:	26 ef       	ldi	r18, 0xF6	; 246
    2be8:	3f ef       	ldi	r19, 0xFF	; 255
    2bea:	82 9f       	mul	r24, r18
    2bec:	80 2d       	mov	r24, r0
    2bee:	11 24       	eor	r1, r1
    2bf0:	84 0f       	add	r24, r20
    2bf2:	82 83       	std	Z+2, r24	; 0x02
    2bf4:	10 c0       	rjmp	.+32     	; 0x2c16 <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2bf6:	8a 50       	subi	r24, 0x0A	; 10
    2bf8:	8a 35       	cpi	r24, 0x5A	; 90
    2bfa:	78 f4       	brcc	.+30     	; 0x2c1a <zeroIP+0x6c>
        StrResult[0]='0';
    2bfc:	80 e3       	ldi	r24, 0x30	; 48
    2bfe:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2c00:	85 2f       	mov	r24, r21
    2c02:	6a e0       	ldi	r22, 0x0A	; 10
    2c04:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    2c08:	80 5d       	subi	r24, 0xD0	; 208
    2c0a:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2c0c:	85 2f       	mov	r24, r21
    2c0e:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    2c12:	90 5d       	subi	r25, 0xD0	; 208
    2c14:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2c16:	13 82       	std	Z+3, r1	; 0x03
    2c18:	08 95       	ret
		}
     else
	 if (Val<10){
    2c1a:	5a 30       	cpi	r21, 0x0A	; 10
    2c1c:	30 f4       	brcc	.+12     	; 0x2c2a <zeroIP+0x7c>
	    StrResult[0]='0';
    2c1e:	80 e3       	ldi	r24, 0x30	; 48
    2c20:	80 83       	st	Z, r24
		StrResult[1]='0';
    2c22:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2c24:	50 5d       	subi	r21, 0xD0	; 208
    2c26:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2c28:	13 82       	std	Z+3, r1	; 0x03
    2c2a:	08 95       	ret

00002c2c <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2c2c:	81 30       	cpi	r24, 0x01	; 1
    2c2e:	29 f0       	breq	.+10     	; 0x2c3a <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2c30:	82 30       	cpi	r24, 0x02	; 2
    2c32:	19 f0       	breq	.+6      	; 0x2c3a <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2c34:	83 30       	cpi	r24, 0x03	; 3
    2c36:	09 f0       	breq	.+2      	; 0x2c3a <GetLocAccStatus+0xe>
    2c38:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2c3a:	08 95       	ret

00002c3c <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2c3c:	cf 93       	push	r28
    2c3e:	df 93       	push	r29
    2c40:	eb 01       	movw	r28, r22
    2c42:	da 01       	movw	r26, r20
    2c44:	a8 0f       	add	r26, r24
    2c46:	b9 1f       	adc	r27, r25
    2c48:	40 e0       	ldi	r20, 0x00	; 0
    2c4a:	50 e0       	ldi	r21, 0x00	; 0
    2c4c:	07 c0       	rjmp	.+14     	; 0x2c5c <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2c4e:	fe 01       	movw	r30, r28
    2c50:	e4 0f       	add	r30, r20
    2c52:	f5 1f       	adc	r31, r21
    2c54:	8d 91       	ld	r24, X+
    2c56:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2c58:	4f 5f       	subi	r20, 0xFF	; 255
    2c5a:	5f 4f       	sbci	r21, 0xFF	; 255
    2c5c:	42 17       	cp	r20, r18
    2c5e:	53 07       	cpc	r21, r19
    2c60:	b0 f3       	brcs	.-20     	; 0x2c4e <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2c62:	c2 0f       	add	r28, r18
    2c64:	d3 1f       	adc	r29, r19
    2c66:	18 82       	st	Y, r1
}
    2c68:	df 91       	pop	r29
    2c6a:	cf 91       	pop	r28
    2c6c:	08 95       	ret

00002c6e <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2c6e:	0f 93       	push	r16
    2c70:	1f 93       	push	r17
    2c72:	cf 93       	push	r28
    2c74:	df 93       	push	r29
    2c76:	8c 01       	movw	r16, r24
    2c78:	db 01       	movw	r26, r22
    2c7a:	eb 01       	movw	r28, r22
    2c7c:	c4 0f       	add	r28, r20
    2c7e:	d5 1f       	adc	r29, r21
    2c80:	60 e0       	ldi	r22, 0x00	; 0
    2c82:	70 e0       	ldi	r23, 0x00	; 0
    2c84:	07 c0       	rjmp	.+14     	; 0x2c94 <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2c86:	f8 01       	movw	r30, r16
    2c88:	e6 0f       	add	r30, r22
    2c8a:	f7 1f       	adc	r31, r23
    2c8c:	80 81       	ld	r24, Z
    2c8e:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2c90:	6f 5f       	subi	r22, 0xFF	; 255
    2c92:	7f 4f       	sbci	r23, 0xFF	; 255
    2c94:	62 17       	cp	r22, r18
    2c96:	73 07       	cpc	r23, r19
    2c98:	b0 f3       	brcs	.-20     	; 0x2c86 <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2c9a:	a4 0f       	add	r26, r20
    2c9c:	b5 1f       	adc	r27, r21
    2c9e:	a2 0f       	add	r26, r18
    2ca0:	b3 1f       	adc	r27, r19
    2ca2:	1c 92       	st	X, r1
}
    2ca4:	df 91       	pop	r29
    2ca6:	cf 91       	pop	r28
    2ca8:	1f 91       	pop	r17
    2caa:	0f 91       	pop	r16
    2cac:	08 95       	ret

00002cae <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2cae:	fb 01       	movw	r30, r22
    2cb0:	e8 0f       	add	r30, r24
    2cb2:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2cb4:	80 81       	ld	r24, Z
    2cb6:	08 95       	ret

00002cb8 <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2cb8:	80 91 20 0b 	lds	r24, 0x0B20
    2cbc:	81 30       	cpi	r24, 0x01	; 1
    2cbe:	51 f4       	brne	.+20     	; 0x2cd4 <procMessage00+0x1c>
    2cc0:	80 91 b3 01 	lds	r24, 0x01B3
    2cc4:	90 91 b4 01 	lds	r25, 0x01B4
    2cc8:	8f 97       	sbiw	r24, 0x2f	; 47
    2cca:	21 f4       	brne	.+8      	; 0x2cd4 <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2ccc:	80 91 45 0b 	lds	r24, 0x0B45
    2cd0:	80 53       	subi	r24, 0x30	; 48
    2cd2:	08 95       	ret
    2cd4:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //_uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2cd6:	08 95       	ret

00002cd8 <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2cd8:	90 91 47 0b 	lds	r25, 0x0B47
    2cdc:	20 e0       	ldi	r18, 0x00	; 0
    2cde:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ce0:	f9 01       	movw	r30, r18
    2ce2:	ee 53       	subi	r30, 0x3E	; 62
    2ce4:	f5 4f       	sbci	r31, 0xF5	; 245
    2ce6:	d9 01       	movw	r26, r18
    2ce8:	a0 5e       	subi	r26, 0xE0	; 224
    2cea:	b4 4f       	sbci	r27, 0xF4	; 244
    2cec:	97 96       	adiw	r26, 0x27	; 39
    2cee:	8c 91       	ld	r24, X
    2cf0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2cf2:	2f 5f       	subi	r18, 0xFF	; 255
    2cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    2cf6:	24 31       	cpi	r18, 0x14	; 20
    2cf8:	31 05       	cpc	r19, r1
    2cfa:	91 f7       	brne	.-28     	; 0x2ce0 <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2cfc:	10 92 d6 0a 	sts	0x0AD6, r1
    2d00:	20 e0       	ldi	r18, 0x00	; 0
    2d02:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d04:	f9 01       	movw	r30, r18
    2d06:	e3 55       	subi	r30, 0x53	; 83
    2d08:	f6 4f       	sbci	r31, 0xF6	; 246
    2d0a:	d9 01       	movw	r26, r18
    2d0c:	a0 5e       	subi	r26, 0xE0	; 224
    2d0e:	b4 4f       	sbci	r27, 0xF4	; 244
    2d10:	db 96       	adiw	r26, 0x3b	; 59
    2d12:	8c 91       	ld	r24, X
    2d14:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d16:	2f 5f       	subi	r18, 0xFF	; 255
    2d18:	3f 4f       	sbci	r19, 0xFF	; 255
    2d1a:	24 31       	cpi	r18, 0x14	; 20
    2d1c:	31 05       	cpc	r19, r1
    2d1e:	91 f7       	brne	.-28     	; 0x2d04 <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d20:	10 92 c1 09 	sts	0x09C1, r1
    2d24:	20 e0       	ldi	r18, 0x00	; 0
    2d26:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d28:	f9 01       	movw	r30, r18
    2d2a:	e8 5b       	subi	r30, 0xB8	; 184
    2d2c:	f5 4f       	sbci	r31, 0xF5	; 245
    2d2e:	d9 01       	movw	r26, r18
    2d30:	a1 59       	subi	r26, 0x91	; 145
    2d32:	b4 4f       	sbci	r27, 0xF4	; 244
    2d34:	8c 91       	ld	r24, X
    2d36:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d38:	2f 5f       	subi	r18, 0xFF	; 255
    2d3a:	3f 4f       	sbci	r19, 0xFF	; 255
    2d3c:	24 31       	cpi	r18, 0x14	; 20
    2d3e:	31 05       	cpc	r19, r1
    2d40:	99 f7       	brne	.-26     	; 0x2d28 <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d42:	10 92 5c 0a 	sts	0x0A5C, r1
    2d46:	20 e0       	ldi	r18, 0x00	; 0
    2d48:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d4a:	f9 01       	movw	r30, r18
    2d4c:	e4 52       	subi	r30, 0x24	; 36
    2d4e:	f2 4f       	sbci	r31, 0xF2	; 242
    2d50:	d9 01       	movw	r26, r18
    2d52:	ad 57       	subi	r26, 0x7D	; 125
    2d54:	b4 4f       	sbci	r27, 0xF4	; 244
    2d56:	8c 91       	ld	r24, X
    2d58:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d5a:	2f 5f       	subi	r18, 0xFF	; 255
    2d5c:	3f 4f       	sbci	r19, 0xFF	; 255
    2d5e:	24 31       	cpi	r18, 0x14	; 20
    2d60:	31 05       	cpc	r19, r1
    2d62:	99 f7       	brne	.-26     	; 0x2d4a <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d64:	10 92 f0 0d 	sts	0x0DF0, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    2d68:	89 2f       	mov	r24, r25
    2d6a:	80 53       	subi	r24, 0x30	; 48
    2d6c:	08 95       	ret

00002d6e <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2d6e:	20 e0       	ldi	r18, 0x00	; 0
    2d70:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d72:	f9 01       	movw	r30, r18
    2d74:	e4 57       	subi	r30, 0x74	; 116
    2d76:	f2 4f       	sbci	r31, 0xF2	; 242
    2d78:	d9 01       	movw	r26, r18
    2d7a:	a0 5e       	subi	r26, 0xE0	; 224
    2d7c:	b4 4f       	sbci	r27, 0xF4	; 244
    2d7e:	95 96       	adiw	r26, 0x25	; 37
    2d80:	8c 91       	ld	r24, X
    2d82:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d84:	2f 5f       	subi	r18, 0xFF	; 255
    2d86:	3f 4f       	sbci	r19, 0xFF	; 255
    2d88:	24 31       	cpi	r18, 0x14	; 20
    2d8a:	31 05       	cpc	r19, r1
    2d8c:	91 f7       	brne	.-28     	; 0x2d72 <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d8e:	10 92 a0 0d 	sts	0x0DA0, r1
    2d92:	20 e0       	ldi	r18, 0x00	; 0
    2d94:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d96:	f9 01       	movw	r30, r18
    2d98:	e7 5d       	subi	r30, 0xD7	; 215
    2d9a:	fa 4f       	sbci	r31, 0xFA	; 250
    2d9c:	d9 01       	movw	r26, r18
    2d9e:	a0 5e       	subi	r26, 0xE0	; 224
    2da0:	b4 4f       	sbci	r27, 0xF4	; 244
    2da2:	d9 96       	adiw	r26, 0x39	; 57
    2da4:	8c 91       	ld	r24, X
    2da6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2da8:	2f 5f       	subi	r18, 0xFF	; 255
    2daa:	3f 4f       	sbci	r19, 0xFF	; 255
    2dac:	2e 31       	cpi	r18, 0x1E	; 30
    2dae:	31 05       	cpc	r19, r1
    2db0:	91 f7       	brne	.-28     	; 0x2d96 <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2db2:	10 92 47 05 	sts	0x0547, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2db6:	80 91 77 0b 	lds	r24, 0x0B77
    2dba:	80 93 8f 05 	sts	0x058F, r24
	 }Dest[Length]=0;
    2dbe:	10 92 90 05 	sts	0x0590, r1
    2dc2:	20 e0       	ldi	r18, 0x00	; 0
    2dc4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2dc6:	f9 01       	movw	r30, r18
    2dc8:	ef 59       	subi	r30, 0x9F	; 159
    2dca:	f5 4f       	sbci	r31, 0xF5	; 245
    2dcc:	d9 01       	movw	r26, r18
    2dce:	a8 58       	subi	r26, 0x88	; 136
    2dd0:	b4 4f       	sbci	r27, 0xF4	; 244
    2dd2:	8c 91       	ld	r24, X
    2dd4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2dd6:	2f 5f       	subi	r18, 0xFF	; 255
    2dd8:	3f 4f       	sbci	r19, 0xFF	; 255
    2dda:	28 30       	cpi	r18, 0x08	; 8
    2ddc:	31 05       	cpc	r19, r1
    2dde:	99 f7       	brne	.-26     	; 0x2dc6 <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2de0:	10 92 69 0a 	sts	0x0A69, r1
    2de4:	20 e0       	ldi	r18, 0x00	; 0
    2de6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2de8:	f9 01       	movw	r30, r18
    2dea:	ed 57       	subi	r30, 0x7D	; 125
    2dec:	fa 4f       	sbci	r31, 0xFA	; 250
    2dee:	d9 01       	movw	r26, r18
    2df0:	a0 58       	subi	r26, 0x80	; 128
    2df2:	b4 4f       	sbci	r27, 0xF4	; 244
    2df4:	8c 91       	ld	r24, X
    2df6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2df8:	2f 5f       	subi	r18, 0xFF	; 255
    2dfa:	3f 4f       	sbci	r19, 0xFF	; 255
    2dfc:	2a 30       	cpi	r18, 0x0A	; 10
    2dfe:	31 05       	cpc	r19, r1
    2e00:	99 f7       	brne	.-26     	; 0x2de8 <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e02:	10 92 8d 05 	sts	0x058D, r1
    2e06:	20 e0       	ldi	r18, 0x00	; 0
    2e08:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e0a:	f9 01       	movw	r30, r18
    2e0c:	ed 50       	subi	r30, 0x0D	; 13
    2e0e:	f2 4f       	sbci	r31, 0xF2	; 242
    2e10:	d9 01       	movw	r26, r18
    2e12:	a6 57       	subi	r26, 0x76	; 118
    2e14:	b4 4f       	sbci	r27, 0xF4	; 244
    2e16:	8c 91       	ld	r24, X
    2e18:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e1a:	2f 5f       	subi	r18, 0xFF	; 255
    2e1c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e1e:	2a 30       	cpi	r18, 0x0A	; 10
    2e20:	31 05       	cpc	r19, r1
    2e22:	99 f7       	brne	.-26     	; 0x2e0a <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e24:	10 92 fd 0d 	sts	0x0DFD, r1
    2e28:	20 e0       	ldi	r18, 0x00	; 0
    2e2a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e2c:	f9 01       	movw	r30, r18
    2e2e:	ee 53       	subi	r30, 0x3E	; 62
    2e30:	f2 4f       	sbci	r31, 0xF2	; 242
    2e32:	d9 01       	movw	r26, r18
    2e34:	ac 56       	subi	r26, 0x6C	; 108
    2e36:	b4 4f       	sbci	r27, 0xF4	; 244
    2e38:	8c 91       	ld	r24, X
    2e3a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e3c:	2f 5f       	subi	r18, 0xFF	; 255
    2e3e:	3f 4f       	sbci	r19, 0xFF	; 255
    2e40:	23 31       	cpi	r18, 0x13	; 19
    2e42:	31 05       	cpc	r19, r1
    2e44:	99 f7       	brne	.-26     	; 0x2e2c <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e46:	10 92 d5 0d 	sts	0x0DD5, r1
    2e4a:	20 e0       	ldi	r18, 0x00	; 0
    2e4c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e4e:	f9 01       	movw	r30, r18
    2e50:	ea 54       	subi	r30, 0x4A	; 74
    2e52:	f2 4f       	sbci	r31, 0xF2	; 242
    2e54:	d9 01       	movw	r26, r18
    2e56:	a9 55       	subi	r26, 0x59	; 89
    2e58:	b4 4f       	sbci	r27, 0xF4	; 244
    2e5a:	8c 91       	ld	r24, X
    2e5c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e5e:	2f 5f       	subi	r18, 0xFF	; 255
    2e60:	3f 4f       	sbci	r19, 0xFF	; 255
    2e62:	27 30       	cpi	r18, 0x07	; 7
    2e64:	31 05       	cpc	r19, r1
    2e66:	99 f7       	brne	.-26     	; 0x2e4e <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e68:	10 92 bd 0d 	sts	0x0DBD, r1
    2e6c:	20 e0       	ldi	r18, 0x00	; 0
    2e6e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e70:	f9 01       	movw	r30, r18
    2e72:	e0 54       	subi	r30, 0x40	; 64
    2e74:	fb 4f       	sbci	r31, 0xFB	; 251
    2e76:	d9 01       	movw	r26, r18
    2e78:	a2 55       	subi	r26, 0x52	; 82
    2e7a:	b4 4f       	sbci	r27, 0xF4	; 244
    2e7c:	8c 91       	ld	r24, X
    2e7e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e80:	2f 5f       	subi	r18, 0xFF	; 255
    2e82:	3f 4f       	sbci	r19, 0xFF	; 255
    2e84:	24 30       	cpi	r18, 0x04	; 4
    2e86:	31 05       	cpc	r19, r1
    2e88:	99 f7       	brne	.-26     	; 0x2e70 <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e8a:	10 92 c4 04 	sts	0x04C4, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    2e8e:	80 e0       	ldi	r24, 0x00	; 0
    2e90:	08 95       	ret

00002e92 <procMessage81>:
_uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    2e92:	cf 93       	push	r28
    2e94:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    2e96:	80 91 45 0b 	lds	r24, 0x0B45
    2e9a:	89 35       	cpi	r24, 0x59	; 89
    2e9c:	11 f4       	brne	.+4      	; 0x2ea2 <procMessage81+0x10>
    2e9e:	90 e8       	ldi	r25, 0x80	; 128
    2ea0:	01 c0       	rjmp	.+2      	; 0x2ea4 <procMessage81+0x12>
    2ea2:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    2ea4:	80 91 46 0b 	lds	r24, 0x0B46
    2ea8:	89 35       	cpi	r24, 0x59	; 89
    2eaa:	09 f4       	brne	.+2      	; 0x2eae <procMessage81+0x1c>
    2eac:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    2eae:	80 91 47 0b 	lds	r24, 0x0B47
    2eb2:	89 35       	cpi	r24, 0x59	; 89
    2eb4:	09 f4       	brne	.+2      	; 0x2eb8 <procMessage81+0x26>
    2eb6:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    2eb8:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    2eba:	80 91 48 0b 	lds	r24, 0x0B48
    2ebe:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    2ec0:	81 31       	cpi	r24, 0x11	; 17
    2ec2:	08 f4       	brcc	.+2      	; 0x2ec6 <procMessage81+0x34>
    2ec4:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    2ec6:	c0 91 b5 01 	lds	r28, 0x01B5
    2eca:	d0 91 b6 01 	lds	r29, 0x01B6
    2ece:	20 e0       	ldi	r18, 0x00	; 0
    2ed0:	30 e0       	ldi	r19, 0x00	; 0
    2ed2:	0b c0       	rjmp	.+22     	; 0x2eea <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ed4:	f9 01       	movw	r30, r18
    2ed6:	ea 50       	subi	r30, 0x0A	; 10
    2ed8:	fa 4f       	sbci	r31, 0xFA	; 250
    2eda:	d9 01       	movw	r26, r18
    2edc:	a0 5e       	subi	r26, 0xE0	; 224
    2ede:	b4 4f       	sbci	r27, 0xF4	; 244
    2ee0:	9c 96       	adiw	r26, 0x2c	; 44
    2ee2:	8c 91       	ld	r24, X
    2ee4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ee6:	2f 5f       	subi	r18, 0xFF	; 255
    2ee8:	3f 4f       	sbci	r19, 0xFF	; 255
    2eea:	2c 17       	cp	r18, r28
    2eec:	3d 07       	cpc	r19, r29
    2eee:	90 f3       	brcs	.-28     	; 0x2ed4 <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ef0:	ca 50       	subi	r28, 0x0A	; 10
    2ef2:	da 4f       	sbci	r29, 0xFA	; 250
    2ef4:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //_uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    2ef6:	89 2f       	mov	r24, r25
    2ef8:	df 91       	pop	r29
    2efa:	cf 91       	pop	r28
    2efc:	08 95       	ret

00002efe <FillChar>:
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    2efe:	20 e0       	ldi	r18, 0x00	; 0
    2f00:	30 e0       	ldi	r19, 0x00	; 0
    2f02:	06 c0       	rjmp	.+12     	; 0x2f10 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    2f04:	fc 01       	movw	r30, r24
    2f06:	e2 0f       	add	r30, r18
    2f08:	f3 1f       	adc	r31, r19
    2f0a:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    2f0c:	2f 5f       	subi	r18, 0xFF	; 255
    2f0e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f10:	26 17       	cp	r18, r22
    2f12:	37 07       	cpc	r19, r23
    2f14:	b8 f3       	brcs	.-18     	; 0x2f04 <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    2f16:	08 95       	ret

00002f18 <ProcMessage91>:

void ProcMessage91(){
    2f18:	20 e0       	ldi	r18, 0x00	; 0
    2f1a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f1c:	f9 01       	movw	r30, r18
    2f1e:	e3 57       	subi	r30, 0x73	; 115
    2f20:	f1 4f       	sbci	r31, 0xF1	; 241
    2f22:	d9 01       	movw	r26, r18
    2f24:	a0 5e       	subi	r26, 0xE0	; 224
    2f26:	b4 4f       	sbci	r27, 0xF4	; 244
    2f28:	95 96       	adiw	r26, 0x25	; 37
    2f2a:	8c 91       	ld	r24, X
    2f2c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f2e:	2f 5f       	subi	r18, 0xFF	; 255
    2f30:	3f 4f       	sbci	r19, 0xFF	; 255
    2f32:	26 30       	cpi	r18, 0x06	; 6
    2f34:	31 05       	cpc	r19, r1
    2f36:	91 f7       	brne	.-28     	; 0x2f1c <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f38:	10 92 93 0e 	sts	0x0E93, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f3c:	80 91 4b 0b 	lds	r24, 0x0B4B
    2f40:	80 93 c3 09 	sts	0x09C3, r24
    2f44:	80 91 4c 0b 	lds	r24, 0x0B4C
    2f48:	80 93 c4 09 	sts	0x09C4, r24
	 }Dest[Length]=0;
    2f4c:	10 92 c5 09 	sts	0x09C5, r1
    2f50:	20 e0       	ldi	r18, 0x00	; 0
    2f52:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f54:	f9 01       	movw	r30, r18
    2f56:	e8 5c       	subi	r30, 0xC8	; 200
    2f58:	f5 4f       	sbci	r31, 0xF5	; 245
    2f5a:	d9 01       	movw	r26, r18
    2f5c:	a0 5e       	subi	r26, 0xE0	; 224
    2f5e:	b4 4f       	sbci	r27, 0xF4	; 244
    2f60:	9d 96       	adiw	r26, 0x2d	; 45
    2f62:	8c 91       	ld	r24, X
    2f64:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f66:	2f 5f       	subi	r18, 0xFF	; 255
    2f68:	3f 4f       	sbci	r19, 0xFF	; 255
    2f6a:	2f 30       	cpi	r18, 0x0F	; 15
    2f6c:	31 05       	cpc	r19, r1
    2f6e:	91 f7       	brne	.-28     	; 0x2f54 <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f70:	10 92 47 0a 	sts	0x0A47, r1
    2f74:	20 e0       	ldi	r18, 0x00	; 0
    2f76:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f78:	f9 01       	movw	r30, r18
    2f7a:	e8 55       	subi	r30, 0x58	; 88
    2f7c:	f8 4f       	sbci	r31, 0xF8	; 248
    2f7e:	d9 01       	movw	r26, r18
    2f80:	a0 5e       	subi	r26, 0xE0	; 224
    2f82:	b4 4f       	sbci	r27, 0xF4	; 244
    2f84:	dc 96       	adiw	r26, 0x3c	; 60
    2f86:	8c 91       	ld	r24, X
    2f88:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f8a:	2f 5f       	subi	r18, 0xFF	; 255
    2f8c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f8e:	26 30       	cpi	r18, 0x06	; 6
    2f90:	31 05       	cpc	r19, r1
    2f92:	91 f7       	brne	.-28     	; 0x2f78 <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f94:	10 92 ae 07 	sts	0x07AE, r1
    2f98:	20 e0       	ldi	r18, 0x00	; 0
    2f9a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f9c:	f9 01       	movw	r30, r18
    2f9e:	e6 58       	subi	r30, 0x86	; 134
    2fa0:	fa 4f       	sbci	r31, 0xFA	; 250
    2fa2:	d9 01       	movw	r26, r18
    2fa4:	ae 59       	subi	r26, 0x9E	; 158
    2fa6:	b4 4f       	sbci	r27, 0xF4	; 244
    2fa8:	8c 91       	ld	r24, X
    2faa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fac:	2f 5f       	subi	r18, 0xFF	; 255
    2fae:	3f 4f       	sbci	r19, 0xFF	; 255
    2fb0:	28 30       	cpi	r18, 0x08	; 8
    2fb2:	31 05       	cpc	r19, r1
    2fb4:	99 f7       	brne	.-26     	; 0x2f9c <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fb6:	10 92 82 05 	sts	0x0582, r1
    2fba:	20 e0       	ldi	r18, 0x00	; 0
    2fbc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fbe:	f9 01       	movw	r30, r18
    2fc0:	ea 54       	subi	r30, 0x4A	; 74
    2fc2:	f2 4f       	sbci	r31, 0xF2	; 242
    2fc4:	d9 01       	movw	r26, r18
    2fc6:	a6 59       	subi	r26, 0x96	; 150
    2fc8:	b4 4f       	sbci	r27, 0xF4	; 244
    2fca:	8c 91       	ld	r24, X
    2fcc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fce:	2f 5f       	subi	r18, 0xFF	; 255
    2fd0:	3f 4f       	sbci	r19, 0xFF	; 255
    2fd2:	28 30       	cpi	r18, 0x08	; 8
    2fd4:	31 05       	cpc	r19, r1
    2fd6:	99 f7       	brne	.-26     	; 0x2fbe <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fd8:	10 92 be 0d 	sts	0x0DBE, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fdc:	80 91 72 0b 	lds	r24, 0x0B72
    2fe0:	80 93 8f 05 	sts	0x058F, r24
	 }Dest[Length]=0;
    2fe4:	10 92 90 05 	sts	0x0590, r1
    2fe8:	20 e0       	ldi	r18, 0x00	; 0
    2fea:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fec:	f9 01       	movw	r30, r18
    2fee:	ef 5f       	subi	r30, 0xFF	; 255
    2ff0:	fa 4f       	sbci	r31, 0xFA	; 250
    2ff2:	d9 01       	movw	r26, r18
    2ff4:	ad 58       	subi	r26, 0x8D	; 141
    2ff6:	b4 4f       	sbci	r27, 0xF4	; 244
    2ff8:	8c 91       	ld	r24, X
    2ffa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ffc:	2f 5f       	subi	r18, 0xFF	; 255
    2ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    3000:	29 30       	cpi	r18, 0x09	; 9
    3002:	31 05       	cpc	r19, r1
    3004:	99 f7       	brne	.-26     	; 0x2fec <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3006:	10 92 0a 05 	sts	0x050A, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    300a:	08 95       	ret

0000300c <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //_uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    300c:	1f 93       	push	r17
   if (STX==0x01){
    300e:	81 30       	cpi	r24, 0x01	; 1
    3010:	09 f0       	breq	.+2      	; 0x3014 <IdentifyMessage+0x8>
    3012:	5f c0       	rjmp	.+190    	; 0x30d2 <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    3014:	6f 32       	cpi	r22, 0x2F	; 47
    3016:	71 05       	cpc	r23, r1
    3018:	21 f0       	breq	.+8      	; 0x3022 <IdentifyMessage+0x16>
    301a:	80 91 39 01 	lds	r24, 0x0139
    301e:	88 23       	and	r24, r24
    3020:	21 f4       	brne	.+8      	; 0x302a <IdentifyMessage+0x1e>
    3022:	81 e0       	ldi	r24, 0x01	; 1
    3024:	80 93 cb 01 	sts	0x01CB, r24
    3028:	4a c0       	rjmp	.+148    	; 0x30be <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    302a:	6c 36       	cpi	r22, 0x6C	; 108
    302c:	71 05       	cpc	r23, r1
    302e:	11 f0       	breq	.+4      	; 0x3034 <IdentifyMessage+0x28>
    3030:	89 30       	cpi	r24, 0x09	; 9
    3032:	21 f4       	brne	.+8      	; 0x303c <IdentifyMessage+0x30>
    3034:	81 e0       	ldi	r24, 0x01	; 1
    3036:	80 93 d0 01 	sts	0x01D0, r24
    303a:	41 c0       	rjmp	.+130    	; 0x30be <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    303c:	92 e0       	ldi	r25, 0x02	; 2
    303e:	67 36       	cpi	r22, 0x67	; 103
    3040:	79 07       	cpc	r23, r25
    3042:	11 f0       	breq	.+4      	; 0x3048 <IdentifyMessage+0x3c>
    3044:	8b 30       	cpi	r24, 0x0B	; 11
    3046:	21 f4       	brne	.+8      	; 0x3050 <IdentifyMessage+0x44>
    3048:	81 e0       	ldi	r24, 0x01	; 1
    304a:	80 93 cd 01 	sts	0x01CD, r24
    304e:	37 c0       	rjmp	.+110    	; 0x30be <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    3050:	61 39       	cpi	r22, 0x91	; 145
    3052:	71 05       	cpc	r23, r1
    3054:	11 f0       	breq	.+4      	; 0x305a <IdentifyMessage+0x4e>
    3056:	87 31       	cpi	r24, 0x17	; 23
    3058:	21 f4       	brne	.+8      	; 0x3062 <IdentifyMessage+0x56>
    305a:	81 e0       	ldi	r24, 0x01	; 1
    305c:	80 93 cf 01 	sts	0x01CF, r24
    3060:	2e c0       	rjmp	.+92     	; 0x30be <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    3062:	66 3e       	cpi	r22, 0xE6	; 230
    3064:	71 05       	cpc	r23, r1
    3066:	11 f0       	breq	.+4      	; 0x306c <IdentifyMessage+0x60>
    3068:	89 33       	cpi	r24, 0x39	; 57
    306a:	21 f4       	brne	.+8      	; 0x3074 <IdentifyMessage+0x68>
    306c:	81 e0       	ldi	r24, 0x01	; 1
    306e:	80 93 d2 01 	sts	0x01D2, r24
    3072:	25 c0       	rjmp	.+74     	; 0x30be <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    3074:	91 e0       	ldi	r25, 0x01	; 1
    3076:	68 39       	cpi	r22, 0x98	; 152
    3078:	79 07       	cpc	r23, r25
    307a:	11 f0       	breq	.+4      	; 0x3080 <IdentifyMessage+0x74>
    307c:	83 36       	cpi	r24, 0x63	; 99
    307e:	21 f4       	brne	.+8      	; 0x3088 <IdentifyMessage+0x7c>
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	80 93 cc 01 	sts	0x01CC, r24
    3086:	1b c0       	rjmp	.+54     	; 0x30be <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    3088:	91 e0       	ldi	r25, 0x01	; 1
    308a:	66 3b       	cpi	r22, 0xB6	; 182
    308c:	79 07       	cpc	r23, r25
    308e:	11 f0       	breq	.+4      	; 0x3094 <IdentifyMessage+0x88>
    3090:	81 35       	cpi	r24, 0x51	; 81
    3092:	21 f4       	brne	.+8      	; 0x309c <IdentifyMessage+0x90>
    3094:	81 e0       	ldi	r24, 0x01	; 1
    3096:	80 93 d3 01 	sts	0x01D3, r24
    309a:	11 c0       	rjmp	.+34     	; 0x30be <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    309c:	6c 35       	cpi	r22, 0x5C	; 92
    309e:	71 05       	cpc	r23, r1
    30a0:	11 f0       	breq	.+4      	; 0x30a6 <IdentifyMessage+0x9a>
    30a2:	8b 35       	cpi	r24, 0x5B	; 91
    30a4:	21 f4       	brne	.+8      	; 0x30ae <IdentifyMessage+0xa2>
    30a6:	81 e0       	ldi	r24, 0x01	; 1
    30a8:	80 93 d4 01 	sts	0x01D4, r24
    30ac:	08 c0       	rjmp	.+16     	; 0x30be <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    30ae:	66 35       	cpi	r22, 0x56	; 86
    30b0:	71 05       	cpc	r23, r1
    30b2:	11 f0       	breq	.+4      	; 0x30b8 <IdentifyMessage+0xac>
    30b4:	85 31       	cpi	r24, 0x15	; 21
    30b6:	19 f4       	brne	.+6      	; 0x30be <IdentifyMessage+0xb2>
    30b8:	81 e0       	ldi	r24, 0x01	; 1
    30ba:	80 93 ce 01 	sts	0x01CE, r24

        //EDC AdvanZ Respond
		if (IsMessage91==True){
    30be:	10 91 d4 01 	lds	r17, 0x01D4
    30c2:	11 30       	cpi	r17, 0x01	; 1
    30c4:	31 f4       	brne	.+12     	; 0x30d2 <IdentifyMessage+0xc6>
		    IsMessage91=False;
    30c6:	10 92 d4 01 	sts	0x01D4, r1
		    ProcMessage91();
    30ca:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <ProcMessage91>
			IsSendMessageEDC=True;
    30ce:	10 93 c3 01 	sts	0x01C3, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}
    30d2:	1f 91       	pop	r17
    30d4:	08 95       	ret

000030d6 <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    30d6:	fc 01       	movw	r30, r24
    30d8:	dc 01       	movw	r26, r24
    30da:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    30dc:	90 e2       	ldi	r25, 0x20	; 32
    30de:	02 c0       	rjmp	.+4      	; 0x30e4 <Tab+0xe>
    30e0:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    30e2:	8f 5f       	subi	r24, 0xFF	; 255
    30e4:	86 17       	cp	r24, r22
    30e6:	e0 f3       	brcs	.-8      	; 0x30e0 <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    30e8:	e6 0f       	add	r30, r22
    30ea:	f1 1d       	adc	r31, r1
    30ec:	10 82       	st	Z, r1
}
    30ee:	08 95       	ret

000030f0 <_f_inttostr>:
}



//Old Function
void _f_inttostr(char* __string, unsigned long __value){
    30f0:	6f 92       	push	r6
    30f2:	7f 92       	push	r7
    30f4:	8f 92       	push	r8
    30f6:	9f 92       	push	r9
    30f8:	af 92       	push	r10
    30fa:	bf 92       	push	r11
    30fc:	cf 92       	push	r12
    30fe:	df 92       	push	r13
    3100:	ef 92       	push	r14
    3102:	ff 92       	push	r15
    3104:	0f 93       	push	r16
    3106:	1f 93       	push	r17
    3108:	cf 93       	push	r28
    310a:	df 93       	push	r29
    310c:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
    310e:	41 15       	cp	r20, r1
    3110:	51 05       	cpc	r21, r1
    3112:	61 05       	cpc	r22, r1
    3114:	71 05       	cpc	r23, r1
    3116:	21 f4       	brne	.+8      	; 0x3120 <_f_inttostr+0x30>
		__string[0] = '0';
    3118:	80 e3       	ldi	r24, 0x30	; 48
    311a:	88 83       	st	Y, r24
		__string[1] = '\0';
    311c:	19 82       	std	Y+1, r1	; 0x01
    311e:	48 c0       	rjmp	.+144    	; 0x31b0 <_f_inttostr+0xc0>
		return;
    3120:	4a 01       	movw	r8, r20
    3122:	5b 01       	movw	r10, r22
    3124:	10 e0       	ldi	r17, 0x00	; 0
    3126:	00 e0       	ldi	r16, 0x00	; 0
    3128:	77 24       	eor	r7, r7
    312a:	c1 2c       	mov	r12, r1
    312c:	9a ec       	ldi	r25, 0xCA	; 202
    312e:	d9 2e       	mov	r13, r25
    3130:	9a e9       	ldi	r25, 0x9A	; 154
    3132:	e9 2e       	mov	r14, r25
    3134:	9b e3       	ldi	r25, 0x3B	; 59
    3136:	f9 2e       	mov	r15, r25
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
    3138:	80 e3       	ldi	r24, 0x30	; 48
    313a:	68 2e       	mov	r6, r24
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
    313c:	8c 14       	cp	r8, r12
    313e:	9d 04       	cpc	r9, r13
    3140:	ae 04       	cpc	r10, r14
    3142:	bf 04       	cpc	r11, r15
    3144:	d0 f0       	brcs	.+52     	; 0x317a <_f_inttostr+0x8a>
			__tmp = (int)(__num / __devider);
    3146:	c5 01       	movw	r24, r10
    3148:	b4 01       	movw	r22, r8
    314a:	a7 01       	movw	r20, r14
    314c:	96 01       	movw	r18, r12
    314e:	0e 94 14 b9 	call	0x17228	; 0x17228 <__udivmodsi4>
    3152:	12 2f       	mov	r17, r18
			__num = __num % __devider;
    3154:	c5 01       	movw	r24, r10
    3156:	b4 01       	movw	r22, r8
    3158:	a7 01       	movw	r20, r14
    315a:	96 01       	movw	r18, r12
    315c:	0e 94 14 b9 	call	0x17228	; 0x17228 <__udivmodsi4>
    3160:	ac 01       	movw	r20, r24
    3162:	cb 01       	movw	r24, r22
    3164:	da 01       	movw	r26, r20
    3166:	4c 01       	movw	r8, r24
    3168:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
    316a:	fe 01       	movw	r30, r28
    316c:	e0 0f       	add	r30, r16
    316e:	f1 1d       	adc	r31, r1
    3170:	10 5d       	subi	r17, 0xD0	; 208
    3172:	10 83       	st	Z, r17
    3174:	0f 5f       	subi	r16, 0xFF	; 255
    3176:	11 e0       	ldi	r17, 0x01	; 1
    3178:	07 c0       	rjmp	.+14     	; 0x3188 <_f_inttostr+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
    317a:	11 23       	and	r17, r17
    317c:	29 f0       	breq	.+10     	; 0x3188 <_f_inttostr+0x98>
				__string[__i++] = 0x30;
    317e:	fe 01       	movw	r30, r28
    3180:	e0 0f       	add	r30, r16
    3182:	f1 1d       	adc	r31, r1
    3184:	60 82       	st	Z, r6
    3186:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
    3188:	73 94       	inc	r7
    318a:	8a e0       	ldi	r24, 0x0A	; 10
    318c:	78 16       	cp	r7, r24
    318e:	69 f0       	breq	.+26     	; 0x31aa <_f_inttostr+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
    3190:	c7 01       	movw	r24, r14
    3192:	b6 01       	movw	r22, r12
    3194:	2a e0       	ldi	r18, 0x0A	; 10
    3196:	30 e0       	ldi	r19, 0x00	; 0
    3198:	40 e0       	ldi	r20, 0x00	; 0
    319a:	50 e0       	ldi	r21, 0x00	; 0
    319c:	0e 94 14 b9 	call	0x17228	; 0x17228 <__udivmodsi4>
    31a0:	c9 01       	movw	r24, r18
    31a2:	da 01       	movw	r26, r20
    31a4:	6c 01       	movw	r12, r24
    31a6:	7d 01       	movw	r14, r26
    31a8:	c9 cf       	rjmp	.-110    	; 0x313c <_f_inttostr+0x4c>
	}
	__string[__i] = '\0';
    31aa:	c0 0f       	add	r28, r16
    31ac:	d1 1d       	adc	r29, r1
    31ae:	18 82       	st	Y, r1
}
    31b0:	df 91       	pop	r29
    31b2:	cf 91       	pop	r28
    31b4:	1f 91       	pop	r17
    31b6:	0f 91       	pop	r16
    31b8:	ff 90       	pop	r15
    31ba:	ef 90       	pop	r14
    31bc:	df 90       	pop	r13
    31be:	cf 90       	pop	r12
    31c0:	bf 90       	pop	r11
    31c2:	af 90       	pop	r10
    31c4:	9f 90       	pop	r9
    31c6:	8f 90       	pop	r8
    31c8:	7f 90       	pop	r7
    31ca:	6f 90       	pop	r6
    31cc:	08 95       	ret

000031ce <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    31ce:	dc 01       	movw	r26, r24
    31d0:	20 e0       	ldi	r18, 0x00	; 0
    31d2:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    31d4:	9c 91       	ld	r25, X
    31d6:	90 53       	subi	r25, 0x30	; 48
    31d8:	9a 30       	cpi	r25, 0x0A	; 10
    31da:	08 f0       	brcs	.+2      	; 0x31de <StrToRaw+0x10>
    31dc:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    31de:	11 96       	adiw	r26, 0x01	; 1
    31e0:	8c 91       	ld	r24, X
    31e2:	11 97       	sbiw	r26, 0x01	; 1
    31e4:	80 53       	subi	r24, 0x30	; 48
    31e6:	8a 30       	cpi	r24, 0x0A	; 10
    31e8:	08 f0       	brcs	.+2      	; 0x31ec <StrToRaw+0x1e>
    31ea:	80 e0       	ldi	r24, 0x00	; 0
    31ec:	fb 01       	movw	r30, r22
    31ee:	e2 0f       	add	r30, r18
    31f0:	f3 1f       	adc	r31, r19
    31f2:	8f 70       	andi	r24, 0x0F	; 15
    31f4:	92 95       	swap	r25
    31f6:	90 7f       	andi	r25, 0xF0	; 240
    31f8:	98 2b       	or	r25, r24
    31fa:	90 83       	st	Z, r25
    31fc:	2f 5f       	subi	r18, 0xFF	; 255
    31fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3200:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    3202:	26 30       	cpi	r18, 0x06	; 6
    3204:	31 05       	cpc	r19, r1
    3206:	31 f7       	brne	.-52     	; 0x31d4 <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    3208:	08 95       	ret

0000320a <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    320a:	cf 93       	push	r28
    320c:	df 93       	push	r29
    320e:	eb 01       	movw	r28, r22
    3210:	db 01       	movw	r26, r22
    3212:	20 e0       	ldi	r18, 0x00	; 0
    3214:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    3216:	fc 01       	movw	r30, r24
    3218:	e2 0f       	add	r30, r18
    321a:	f3 1f       	adc	r31, r19
    321c:	e0 81       	ld	r30, Z
    321e:	4e 2f       	mov	r20, r30
    3220:	42 95       	swap	r20
    3222:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3224:	4a 30       	cpi	r20, 0x0A	; 10
    3226:	10 f0       	brcs	.+4      	; 0x322c <RawToStr+0x22>
    3228:	40 e3       	ldi	r20, 0x30	; 48
    322a:	01 c0       	rjmp	.+2      	; 0x322e <RawToStr+0x24>
	    Result='0'+X;
    322c:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    322e:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3230:	ea 30       	cpi	r30, 0x0A	; 10
    3232:	10 f0       	brcs	.+4      	; 0x3238 <RawToStr+0x2e>
    3234:	e0 e3       	ldi	r30, 0x30	; 48
    3236:	01 c0       	rjmp	.+2      	; 0x323a <RawToStr+0x30>
	    Result='0'+X;
    3238:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    323a:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    323c:	11 96       	adiw	r26, 0x01	; 1
    323e:	ec 93       	st	X, r30
    3240:	11 97       	sbiw	r26, 0x01	; 1
    3242:	2f 5f       	subi	r18, 0xFF	; 255
    3244:	3f 4f       	sbci	r19, 0xFF	; 255
    3246:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    3248:	26 30       	cpi	r18, 0x06	; 6
    324a:	31 05       	cpc	r19, r1
    324c:	21 f7       	brne	.-56     	; 0x3216 <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    324e:	1c 86       	std	Y+12, r1	; 0x0c
}
    3250:	df 91       	pop	r29
    3252:	cf 91       	pop	r28
    3254:	08 95       	ret

00003256 <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xA,xB,xC;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    3256:	86 17       	cp	r24, r22
    3258:	08 f4       	brcc	.+2      	; 0x325c <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    325a:	86 5f       	subi	r24, 0xF6	; 246
    325c:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    325e:	80 5d       	subi	r24, 0xD0	; 208
    3260:	08 95       	ret

00003262 <CalcPlus>:

char CalcPlus(char A, char B){
    3262:	80 56       	subi	r24, 0x60	; 96
    3264:	86 0f       	add	r24, r22
    3266:	6a e0       	ldi	r22, 0x0A	; 10
    3268:	0e 94 e0 b8 	call	0x171c0	; 0x171c0 <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    326c:	89 2f       	mov	r24, r25
    326e:	80 5d       	subi	r24, 0xD0	; 208
    3270:	08 95       	ret

00003272 <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3272:	8a 30       	cpi	r24, 0x0A	; 10
    3274:	10 f0       	brcs	.+4      	; 0x327a <Chr+0x8>
    3276:	80 e3       	ldi	r24, 0x30	; 48
    3278:	08 95       	ret
	    Result='0'+X;
    327a:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    327c:	08 95       	ret

0000327e <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    327e:	80 53       	subi	r24, 0x30	; 48
    3280:	8a 30       	cpi	r24, 0x0A	; 10
    3282:	08 f0       	brcs	.+2      	; 0x3286 <Ord+0x8>
    3284:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    3286:	08 95       	ret

00003288 <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    3288:	48 2f       	mov	r20, r24
    328a:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    328c:	18 16       	cp	r1, r24
    328e:	64 f4       	brge	.+24     	; 0x32a8 <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    3290:	56 2f       	mov	r21, r22
    3292:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    3294:	90 e2       	ldi	r25, 0x20	; 32
    3296:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    3298:	8a 2f       	mov	r24, r26
    329a:	85 1b       	sub	r24, r21
    329c:	84 17       	cp	r24, r20
    329e:	d8 f3       	brcs	.-10     	; 0x3296 <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    32a0:	e4 0f       	add	r30, r20
    32a2:	f1 1d       	adc	r31, r1
    32a4:	10 82       	st	Z, r1
    32a6:	08 95       	ret
     }else{
	 strTab[0]=' ';
    32a8:	80 e2       	ldi	r24, 0x20	; 32
    32aa:	80 83       	st	Z, r24
	 strTab[1]=0;
    32ac:	11 82       	std	Z+1, r1	; 0x01
    32ae:	08 95       	ret

000032b0 <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    32b0:	86 30       	cpi	r24, 0x06	; 6
    32b2:	51 f1       	breq	.+84     	; 0x3308 <GetBorderValue+0x58>
    32b4:	87 30       	cpi	r24, 0x07	; 7
    32b6:	70 f4       	brcc	.+28     	; 0x32d4 <GetBorderValue+0x24>
    32b8:	83 30       	cpi	r24, 0x03	; 3
    32ba:	11 f1       	breq	.+68     	; 0x3300 <GetBorderValue+0x50>
    32bc:	84 30       	cpi	r24, 0x04	; 4
    32be:	28 f4       	brcc	.+10     	; 0x32ca <GetBorderValue+0x1a>
    32c0:	81 30       	cpi	r24, 0x01	; 1
    32c2:	c1 f0       	breq	.+48     	; 0x32f4 <GetBorderValue+0x44>
    32c4:	82 30       	cpi	r24, 0x02	; 2
    32c6:	c1 f4       	brne	.+48     	; 0x32f8 <GetBorderValue+0x48>
    32c8:	19 c0       	rjmp	.+50     	; 0x32fc <GetBorderValue+0x4c>
    32ca:	84 30       	cpi	r24, 0x04	; 4
    32cc:	d9 f0       	breq	.+54     	; 0x3304 <GetBorderValue+0x54>
    32ce:	85 30       	cpi	r24, 0x05	; 5
    32d0:	99 f4       	brne	.+38     	; 0x32f8 <GetBorderValue+0x48>
    32d2:	22 c0       	rjmp	.+68     	; 0x3318 <GetBorderValue+0x68>
    32d4:	89 30       	cpi	r24, 0x09	; 9
    32d6:	f1 f0       	breq	.+60     	; 0x3314 <GetBorderValue+0x64>
    32d8:	8a 30       	cpi	r24, 0x0A	; 10
    32da:	28 f4       	brcc	.+10     	; 0x32e6 <GetBorderValue+0x36>
    32dc:	87 30       	cpi	r24, 0x07	; 7
    32de:	b1 f0       	breq	.+44     	; 0x330c <GetBorderValue+0x5c>
    32e0:	88 30       	cpi	r24, 0x08	; 8
    32e2:	51 f4       	brne	.+20     	; 0x32f8 <GetBorderValue+0x48>
    32e4:	15 c0       	rjmp	.+42     	; 0x3310 <GetBorderValue+0x60>
    32e6:	8b 30       	cpi	r24, 0x0B	; 11
    32e8:	d9 f0       	breq	.+54     	; 0x3320 <GetBorderValue+0x70>
    32ea:	8b 30       	cpi	r24, 0x0B	; 11
    32ec:	b8 f0       	brcs	.+46     	; 0x331c <GetBorderValue+0x6c>
    32ee:	8c 30       	cpi	r24, 0x0C	; 12
    32f0:	19 f4       	brne	.+6      	; 0x32f8 <GetBorderValue+0x48>
    32f2:	18 c0       	rjmp	.+48     	; 0x3324 <GetBorderValue+0x74>
    32f4:	8a ed       	ldi	r24, 0xDA	; 218
    32f6:	08 95       	ret
    32f8:	80 e0       	ldi	r24, 0x00	; 0
    32fa:	08 95       	ret
    32fc:	82 ec       	ldi	r24, 0xC2	; 194
    32fe:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    3300:	8f eb       	ldi	r24, 0xBF	; 191
    3302:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    3304:	83 ec       	ldi	r24, 0xC3	; 195
    3306:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    3308:	84 eb       	ldi	r24, 0xB4	; 180
    330a:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    330c:	80 ec       	ldi	r24, 0xC0	; 192
    330e:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    3310:	81 ec       	ldi	r24, 0xC1	; 193
    3312:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    3314:	89 ed       	ldi	r24, 0xD9	; 217
    3316:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    3318:	85 ec       	ldi	r24, 0xC5	; 197
    331a:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    331c:	83 eb       	ldi	r24, 0xB3	; 179
    331e:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    3320:	84 ec       	ldi	r24, 0xC4	; 196
    3322:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    3324:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    3326:	08 95       	ret

00003328 <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    3328:	bf 92       	push	r11
    332a:	cf 92       	push	r12
    332c:	df 92       	push	r13
    332e:	ef 92       	push	r14
    3330:	ff 92       	push	r15
    3332:	0f 93       	push	r16
    3334:	1f 93       	push	r17
    3336:	cf 93       	push	r28
    3338:	df 93       	push	r29
    333a:	b8 2e       	mov	r11, r24
    333c:	8b 01       	movw	r16, r22
    333e:	e4 2e       	mov	r14, r20
    3340:	69 01       	movw	r12, r18
     char i,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    3342:	f9 01       	movw	r30, r18
    3344:	c0 81       	ld	r28, Z
    3346:	d1 81       	ldd	r29, Z+1	; 0x01
    3348:	0c 0f       	add	r16, r28
    334a:	1d 1f       	adc	r17, r29
    334c:	ff 24       	eor	r15, r15
    334e:	07 c0       	rjmp	.+14     	; 0x335e <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    3350:	8b 2d       	mov	r24, r11
    3352:	0e 94 58 19 	call	0x32b0	; 0x32b0 <GetBorderValue>
    3356:	f8 01       	movw	r30, r16
    3358:	81 93       	st	Z+, r24
    335a:	8f 01       	movw	r16, r30
     char i,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    335c:	f3 94       	inc	r15
    335e:	fe 14       	cp	r15, r14
    3360:	b8 f3       	brcs	.-18     	; 0x3350 <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    3362:	ce 0d       	add	r28, r14
    3364:	d1 1d       	adc	r29, r1
    3366:	f6 01       	movw	r30, r12
    3368:	d1 83       	std	Z+1, r29	; 0x01
    336a:	c0 83       	st	Z, r28
}
    336c:	df 91       	pop	r29
    336e:	cf 91       	pop	r28
    3370:	1f 91       	pop	r17
    3372:	0f 91       	pop	r16
    3374:	ff 90       	pop	r15
    3376:	ef 90       	pop	r14
    3378:	df 90       	pop	r13
    337a:	cf 90       	pop	r12
    337c:	bf 90       	pop	r11
    337e:	08 95       	ret

00003380 <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    3380:	08 95       	ret

00003382 <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    3382:	08 95       	ret

00003384 <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    3384:	08 95       	ret

00003386 <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    3386:	08 95       	ret

00003388 <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 _uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    3388:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    338a:	28 2f       	mov	r18, r24
    338c:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    338e:	82 2f       	mov	r24, r18
    3390:	86 95       	lsr	r24
    3392:	86 95       	lsr	r24
    3394:	86 95       	lsr	r24
    3396:	a8 2f       	mov	r26, r24
    3398:	b0 e0       	ldi	r27, 0x00	; 0
    339a:	a6 52       	subi	r26, 0x26	; 38
    339c:	b2 4f       	sbci	r27, 0xF2	; 242
    339e:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    33a0:	62 30       	cpi	r22, 0x02	; 2
    33a2:	59 f4       	brne	.+22     	; 0x33ba <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    33a4:	27 70       	andi	r18, 0x07	; 7
    33a6:	81 e0       	ldi	r24, 0x01	; 1
    33a8:	90 e0       	ldi	r25, 0x00	; 0
    33aa:	02 c0       	rjmp	.+4      	; 0x33b0 <SetIncomingTransStatus+0x28>
    33ac:	88 0f       	add	r24, r24
    33ae:	99 1f       	adc	r25, r25
    33b0:	2a 95       	dec	r18
    33b2:	e2 f7       	brpl	.-8      	; 0x33ac <SetIncomingTransStatus+0x24>
    33b4:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    33b6:	4c 93       	st	X, r20
    33b8:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    33ba:	63 30       	cpi	r22, 0x03	; 3
    33bc:	b1 f4       	brne	.+44     	; 0x33ea <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    33be:	27 70       	andi	r18, 0x07	; 7
    33c0:	8e ef       	ldi	r24, 0xFE	; 254
    33c2:	90 e0       	ldi	r25, 0x00	; 0
    33c4:	01 c0       	rjmp	.+2      	; 0x33c8 <SetIncomingTransStatus+0x40>
    33c6:	88 0f       	add	r24, r24
    33c8:	2a 95       	dec	r18
    33ca:	ea f7       	brpl	.-6      	; 0x33c6 <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    33cc:	e6 95       	lsr	r30
    33ce:	e6 95       	lsr	r30
    33d0:	e6 95       	lsr	r30
    33d2:	f0 e0       	ldi	r31, 0x00	; 0
    33d4:	e6 52       	subi	r30, 0x26	; 38
    33d6:	f2 4f       	sbci	r31, 0xF2	; 242
    33d8:	28 2f       	mov	r18, r24
    33da:	30 e0       	ldi	r19, 0x00	; 0
    33dc:	20 95       	com	r18
    33de:	30 95       	com	r19
    33e0:	35 95       	asr	r19
    33e2:	27 95       	ror	r18
    33e4:	82 2b       	or	r24, r18
    33e6:	84 23       	and	r24, r20
    33e8:	80 83       	st	Z, r24
    33ea:	08 95       	ret

000033ec <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    33ec:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    33ee:	e8 2f       	mov	r30, r24
    33f0:	e6 95       	lsr	r30
    33f2:	e6 95       	lsr	r30
    33f4:	e6 95       	lsr	r30
    33f6:	f0 e0       	ldi	r31, 0x00	; 0
    33f8:	e6 52       	subi	r30, 0x26	; 38
    33fa:	f2 4f       	sbci	r31, 0xF2	; 242
    33fc:	90 81       	ld	r25, Z
    33fe:	29 2f       	mov	r18, r25
    3400:	30 e0       	ldi	r19, 0x00	; 0
    3402:	87 70       	andi	r24, 0x07	; 7
    3404:	02 c0       	rjmp	.+4      	; 0x340a <GetIncomingTransStatus+0x1e>
    3406:	35 95       	asr	r19
    3408:	27 95       	ror	r18
    340a:	8a 95       	dec	r24
    340c:	e2 f7       	brpl	.-8      	; 0x3406 <GetIncomingTransStatus+0x1a>
    340e:	21 30       	cpi	r18, 0x01	; 1
    3410:	31 05       	cpc	r19, r1
    3412:	11 f4       	brne	.+4      	; 0x3418 <GetIncomingTransStatus+0x2c>
    3414:	82 e0       	ldi	r24, 0x02	; 2
    3416:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    3418:	23 2b       	or	r18, r19
    341a:	11 f4       	brne	.+4      	; 0x3420 <GetIncomingTransStatus+0x34>
    341c:	83 e0       	ldi	r24, 0x03	; 3
    341e:	08 95       	ret
    3420:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    3422:	08 95       	ret

00003424 <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    3424:	df 93       	push	r29
    3426:	cf 93       	push	r28
    3428:	00 d0       	rcall	.+0      	; 0x342a <SetDispenser+0x6>
    342a:	00 d0       	rcall	.+0      	; 0x342c <SetDispenser+0x8>
    342c:	0f 92       	push	r0
    342e:	cd b7       	in	r28, 0x3d	; 61
    3430:	de b7       	in	r29, 0x3e	; 62
    3432:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3434:	e1 99       	sbic	0x1c, 1	; 28
    3436:	fe cf       	rjmp	.-4      	; 0x3434 <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3438:	27 e6       	ldi	r18, 0x67	; 103
    343a:	31 e0       	ldi	r19, 0x01	; 1
    343c:	3f bb       	out	0x1f, r19	; 31
    343e:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3440:	e0 9a       	sbi	0x1c, 0	; 28
    3442:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    3444:	89 17       	cp	r24, r25
    3446:	51 f0       	breq	.+20     	; 0x345c <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3448:	e1 99       	sbic	0x1c, 1	; 28
    344a:	fe cf       	rjmp	.-4      	; 0x3448 <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    344c:	3f bb       	out	0x1f, r19	; 31
    344e:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    3450:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3452:	0f b6       	in	r0, 0x3f	; 63
    3454:	f8 94       	cli
    3456:	e2 9a       	sbi	0x1c, 2	; 28
    3458:	e1 9a       	sbi	0x1c, 1	; 28
    345a:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    345c:	91 30       	cpi	r25, 0x01	; 1
    345e:	19 f0       	breq	.+6      	; 0x3466 <SetDispenser+0x42>
    3460:	92 30       	cpi	r25, 0x02	; 2
    3462:	71 f4       	brne	.+28     	; 0x3480 <SetDispenser+0x5c>
    3464:	08 c0       	rjmp	.+16     	; 0x3476 <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    3466:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    3468:	83 e0       	ldi	r24, 0x03	; 3
    346a:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    346c:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    346e:	82 e0       	ldi	r24, 0x02	; 2
    3470:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    3472:	1d 82       	std	Y+5, r1	; 0x05
    3474:	05 c0       	rjmp	.+10     	; 0x3480 <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    3476:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    3478:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    347a:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    347c:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    347e:	9d 83       	std	Y+5, r25	; 0x05
    3480:	29 e3       	ldi	r18, 0x39	; 57
    3482:	30 e0       	ldi	r19, 0x00	; 0
    3484:	fe 01       	movw	r30, r28
    3486:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3488:	e1 99       	sbic	0x1c, 1	; 28
    348a:	fe cf       	rjmp	.-4      	; 0x3488 <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    348c:	3f bb       	out	0x1f, r19	; 31
    348e:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3490:	e0 9a       	sbi	0x1c, 0	; 28
    3492:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    3494:	90 81       	ld	r25, Z
    3496:	89 17       	cp	r24, r25
    3498:	51 f0       	breq	.+20     	; 0x34ae <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    349a:	e1 99       	sbic	0x1c, 1	; 28
    349c:	fe cf       	rjmp	.-4      	; 0x349a <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    349e:	3f bb       	out	0x1f, r19	; 31
    34a0:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    34a2:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    34a4:	0f b6       	in	r0, 0x3f	; 63
    34a6:	f8 94       	cli
    34a8:	e2 9a       	sbi	0x1c, 2	; 28
    34aa:	e1 9a       	sbi	0x1c, 1	; 28
    34ac:	0f be       	out	0x3f, r0	; 63
    34ae:	2f 5f       	subi	r18, 0xFF	; 255
    34b0:	3f 4f       	sbci	r19, 0xFF	; 255
    34b2:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    34b4:	80 e0       	ldi	r24, 0x00	; 0
    34b6:	2e 33       	cpi	r18, 0x3E	; 62
    34b8:	38 07       	cpc	r19, r24
    34ba:	31 f7       	brne	.-52     	; 0x3488 <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    34bc:	0f 90       	pop	r0
    34be:	0f 90       	pop	r0
    34c0:	0f 90       	pop	r0
    34c2:	0f 90       	pop	r0
    34c4:	0f 90       	pop	r0
    34c6:	cf 91       	pop	r28
    34c8:	df 91       	pop	r29
    34ca:	08 95       	ret

000034cc <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    34cc:	df 93       	push	r29
    34ce:	cf 93       	push	r28
    34d0:	cd b7       	in	r28, 0x3d	; 61
    34d2:	de b7       	in	r29, 0x3e	; 62
    34d4:	62 97       	sbiw	r28, 0x12	; 18
    34d6:	0f b6       	in	r0, 0x3f	; 63
    34d8:	f8 94       	cli
    34da:	de bf       	out	0x3e, r29	; 62
    34dc:	0f be       	out	0x3f, r0	; 63
    34de:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    34e0:	20 91 bf 05 	lds	r18, 0x05BF
    34e4:	2f 83       	std	Y+7, r18	; 0x07
    34e6:	20 91 c0 05 	lds	r18, 0x05C0
    34ea:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    34ec:	20 91 c2 05 	lds	r18, 0x05C2
    34f0:	2c 83       	std	Y+4, r18	; 0x04
    34f2:	20 91 c3 05 	lds	r18, 0x05C3
    34f6:	2d 83       	std	Y+5, r18	; 0x05
    34f8:	20 91 c5 05 	lds	r18, 0x05C5
    34fc:	29 83       	std	Y+1, r18	; 0x01
    34fe:	20 91 c6 05 	lds	r18, 0x05C6
    3502:	2a 83       	std	Y+2, r18	; 0x02
    3504:	20 91 a4 0a 	lds	r18, 0x0AA4
    3508:	2a 87       	std	Y+10, r18	; 0x0a
    350a:	20 91 a5 0a 	lds	r18, 0x0AA5
    350e:	2b 87       	std	Y+11, r18	; 0x0b
    3510:	20 91 a7 0a 	lds	r18, 0x0AA7
    3514:	2d 87       	std	Y+13, r18	; 0x0d
    3516:	20 91 a8 0a 	lds	r18, 0x0AA8
    351a:	2e 87       	std	Y+14, r18	; 0x0e
    351c:	20 91 aa 0a 	lds	r18, 0x0AAA
    3520:	28 8b       	std	Y+16, r18	; 0x10
    3522:	20 91 ab 0a 	lds	r18, 0x0AAB
    3526:	29 8b       	std	Y+17, r18	; 0x11
    3528:	1a 8a       	std	Y+18, r1	; 0x12
    352a:	1f 86       	std	Y+15, r1	; 0x0f
    352c:	1c 86       	std	Y+12, r1	; 0x0c
    352e:	1b 82       	std	Y+3, r1	; 0x03
    3530:	1e 82       	std	Y+6, r1	; 0x06
    3532:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    3534:	2d b7       	in	r18, 0x3d	; 61
    3536:	3e b7       	in	r19, 0x3e	; 62
    3538:	20 51       	subi	r18, 0x10	; 16
    353a:	30 40       	sbci	r19, 0x00	; 0
    353c:	0f b6       	in	r0, 0x3f	; 63
    353e:	f8 94       	cli
    3540:	3e bf       	out	0x3e, r19	; 62
    3542:	0f be       	out	0x3f, r0	; 63
    3544:	2d bf       	out	0x3d, r18	; 61
    3546:	ed b7       	in	r30, 0x3d	; 61
    3548:	fe b7       	in	r31, 0x3e	; 62
    354a:	31 96       	adiw	r30, 0x01	; 1
    354c:	ad b7       	in	r26, 0x3d	; 61
    354e:	be b7       	in	r27, 0x3e	; 62
    3550:	12 96       	adiw	r26, 0x02	; 2
    3552:	9c 93       	st	X, r25
    3554:	8e 93       	st	-X, r24
    3556:	11 97       	sbiw	r26, 0x01	; 1
    3558:	81 ed       	ldi	r24, 0xD1	; 209
    355a:	93 e0       	ldi	r25, 0x03	; 3
    355c:	93 83       	std	Z+3, r25	; 0x03
    355e:	82 83       	std	Z+2, r24	; 0x02
    3560:	ce 01       	movw	r24, r28
    3562:	01 96       	adiw	r24, 0x01	; 1
    3564:	95 83       	std	Z+5, r25	; 0x05
    3566:	84 83       	std	Z+4, r24	; 0x04
    3568:	ce 01       	movw	r24, r28
    356a:	04 96       	adiw	r24, 0x04	; 4
    356c:	97 83       	std	Z+7, r25	; 0x07
    356e:	86 83       	std	Z+6, r24	; 0x06
    3570:	ce 01       	movw	r24, r28
    3572:	07 96       	adiw	r24, 0x07	; 7
    3574:	91 87       	std	Z+9, r25	; 0x09
    3576:	80 87       	std	Z+8, r24	; 0x08
    3578:	ce 01       	movw	r24, r28
    357a:	0a 96       	adiw	r24, 0x0a	; 10
    357c:	93 87       	std	Z+11, r25	; 0x0b
    357e:	82 87       	std	Z+10, r24	; 0x0a
    3580:	ce 01       	movw	r24, r28
    3582:	0d 96       	adiw	r24, 0x0d	; 13
    3584:	95 87       	std	Z+13, r25	; 0x0d
    3586:	84 87       	std	Z+12, r24	; 0x0c
    3588:	ce 01       	movw	r24, r28
    358a:	40 96       	adiw	r24, 0x10	; 16
    358c:	97 87       	std	Z+15, r25	; 0x0f
    358e:	86 87       	std	Z+14, r24	; 0x0e
    3590:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    3594:	2d b7       	in	r18, 0x3d	; 61
    3596:	3e b7       	in	r19, 0x3e	; 62
    3598:	20 5f       	subi	r18, 0xF0	; 240
    359a:	3f 4f       	sbci	r19, 0xFF	; 255
    359c:	0f b6       	in	r0, 0x3f	; 63
    359e:	f8 94       	cli
    35a0:	3e bf       	out	0x3e, r19	; 62
    35a2:	0f be       	out	0x3f, r0	; 63
    35a4:	2d bf       	out	0x3d, r18	; 61
}
    35a6:	62 96       	adiw	r28, 0x12	; 18
    35a8:	0f b6       	in	r0, 0x3f	; 63
    35aa:	f8 94       	cli
    35ac:	de bf       	out	0x3e, r29	; 62
    35ae:	0f be       	out	0x3f, r0	; 63
    35b0:	cd bf       	out	0x3d, r28	; 61
    35b2:	cf 91       	pop	r28
    35b4:	df 91       	pop	r29
    35b6:	08 95       	ret

000035b8 <leadingZero>:
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    35b8:	00 d0       	rcall	.+0      	; 0x35ba <leadingZero+0x2>
    35ba:	00 d0       	rcall	.+0      	; 0x35bc <leadingZero+0x4>
    35bc:	00 d0       	rcall	.+0      	; 0x35be <leadingZero+0x6>
    35be:	ed b7       	in	r30, 0x3d	; 61
    35c0:	fe b7       	in	r31, 0x3e	; 62
    35c2:	31 96       	adiw	r30, 0x01	; 1
    35c4:	ad b7       	in	r26, 0x3d	; 61
    35c6:	be b7       	in	r27, 0x3e	; 62
    35c8:	12 96       	adiw	r26, 0x02	; 2
    35ca:	7c 93       	st	X, r23
    35cc:	6e 93       	st	-X, r22
    35ce:	11 97       	sbiw	r26, 0x01	; 1
    35d0:	23 eb       	ldi	r18, 0xB3	; 179
    35d2:	3e e0       	ldi	r19, 0x0E	; 14
    35d4:	33 83       	std	Z+3, r19	; 0x03
    35d6:	22 83       	std	Z+2, r18	; 0x02
    35d8:	84 83       	std	Z+4, r24	; 0x04
    35da:	15 82       	std	Z+5, r1	; 0x05
    35dc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    35e0:	8d b7       	in	r24, 0x3d	; 61
    35e2:	9e b7       	in	r25, 0x3e	; 62
    35e4:	06 96       	adiw	r24, 0x06	; 6
    35e6:	0f b6       	in	r0, 0x3f	; 63
    35e8:	f8 94       	cli
    35ea:	9e bf       	out	0x3e, r25	; 62
    35ec:	0f be       	out	0x3f, r0	; 63
    35ee:	8d bf       	out	0x3d, r24	; 61

}
    35f0:	08 95       	ret

000035f2 <UpdateSeqNum>:
     //sprintf_P(strIFT_ID,PSTR("%.2d"),eeprom_read_byte(&DefIFT_ID));
	 leadingZero(eeprom_read_byte(&DefIFT_ID),strIFT_ID);
}

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
    35f2:	80 91 e7 01 	lds	r24, 0x01E7
    35f6:	84 36       	cpi	r24, 0x64	; 100
    35f8:	20 f4       	brcc	.+8      	; 0x3602 <UpdateSeqNum+0x10>
    35fa:	8f 5f       	subi	r24, 0xFF	; 255
    35fc:	80 93 e7 01 	sts	0x01E7, r24
    3600:	02 c0       	rjmp	.+4      	; 0x3606 <UpdateSeqNum+0x14>
	 else SeqNum=0;
    3602:	10 92 e7 01 	sts	0x01E7, r1
	 leadingZero(SeqNum,strSeqNum);
    3606:	80 91 e7 01 	lds	r24, 0x01E7
    360a:	90 e0       	ldi	r25, 0x00	; 0
    360c:	66 ed       	ldi	r22, 0xD6	; 214
    360e:	7d e0       	ldi	r23, 0x0D	; 13
    3610:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <leadingZero>
} 
    3614:	08 95       	ret

00003616 <UpdateIFT_ID>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3616:	e1 99       	sbic	0x1c, 1	; 28
    3618:	fe cf       	rjmp	.-4      	; 0x3616 <UpdateIFT_ID>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    361a:	80 e0       	ldi	r24, 0x00	; 0
    361c:	90 e0       	ldi	r25, 0x00	; 0
    361e:	9f bb       	out	0x1f, r25	; 31
    3620:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3622:	e0 9a       	sbi	0x1c, 0	; 28
    3624:	8d b3       	in	r24, 0x1d	; 29
}


void UpdateIFT_ID(){
     //sprintf_P(strIFT_ID,PSTR("%.2d"),eeprom_read_byte(&DefIFT_ID));
	 leadingZero(eeprom_read_byte(&DefIFT_ID),strIFT_ID);
    3626:	90 e0       	ldi	r25, 0x00	; 0
    3628:	61 ef       	ldi	r22, 0xF1	; 241
    362a:	75 e0       	ldi	r23, 0x05	; 5
    362c:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <leadingZero>
}
    3630:	08 95       	ret

00003632 <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){
    3632:	ff 92       	push	r15
    3634:	0f 93       	push	r16
    3636:	1f 93       	push	r17
    3638:	df 93       	push	r29
    363a:	cf 93       	push	r28
    363c:	cd b7       	in	r28, 0x3d	; 61
    363e:	de b7       	in	r29, 0x3e	; 62
    3640:	28 97       	sbiw	r28, 0x08	; 8
    3642:	0f b6       	in	r0, 0x3f	; 63
    3644:	f8 94       	cli
    3646:	de bf       	out	0x3e, r29	; 62
    3648:	0f be       	out	0x3f, r0	; 63
    364a:	cd bf       	out	0x3d, r28	; 61
    364c:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    364e:	8e 01       	movw	r16, r28
    3650:	0f 5f       	subi	r16, 0xFF	; 255
    3652:	1f 4f       	sbci	r17, 0xFF	; 255
    3654:	c8 01       	movw	r24, r16
    3656:	65 e4       	ldi	r22, 0x45	; 69
    3658:	70 e0       	ldi	r23, 0x00	; 0
    365a:	48 e0       	ldi	r20, 0x08	; 8
    365c:	50 e0       	ldi	r21, 0x00	; 0
    365e:	27 e9       	ldi	r18, 0x97	; 151
    3660:	32 e1       	ldi	r19, 0x12	; 18
    3662:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    3666:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3668:	9e 01       	movw	r18, r28
    366a:	27 5f       	subi	r18, 0xF7	; 247
    366c:	3f 4f       	sbci	r19, 0xFF	; 255
    366e:	9e 2f       	mov	r25, r30
    3670:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    3672:	80 81       	ld	r24, Z
    3674:	8f 15       	cp	r24, r15
    3676:	19 f4       	brne	.+6      	; 0x367e <GetFIPAddr+0x4c>
		     Result=i+1;
    3678:	89 2f       	mov	r24, r25
    367a:	8f 5f       	subi	r24, 0xFF	; 255
    367c:	05 c0       	rjmp	.+10     	; 0x3688 <GetFIPAddr+0x56>
			 break;
    367e:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3680:	e2 17       	cp	r30, r18
    3682:	f3 07       	cpc	r31, r19
    3684:	a1 f7       	brne	.-24     	; 0x366e <GetFIPAddr+0x3c>
    3686:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    3688:	28 96       	adiw	r28, 0x08	; 8
    368a:	0f b6       	in	r0, 0x3f	; 63
    368c:	f8 94       	cli
    368e:	de bf       	out	0x3e, r29	; 62
    3690:	0f be       	out	0x3f, r0	; 63
    3692:	cd bf       	out	0x3d, r28	; 61
    3694:	cf 91       	pop	r28
    3696:	df 91       	pop	r29
    3698:	1f 91       	pop	r17
    369a:	0f 91       	pop	r16
    369c:	ff 90       	pop	r15
    369e:	08 95       	ret

000036a0 <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    36a0:	ff 92       	push	r15
    36a2:	0f 93       	push	r16
    36a4:	1f 93       	push	r17
    36a6:	cf 93       	push	r28
    36a8:	df 93       	push	r29
    36aa:	28 2f       	mov	r18, r24
    36ac:	f6 2e       	mov	r15, r22
char iPumpID,strSend[20]; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    36ae:	80 31       	cpi	r24, 0x10	; 16
    36b0:	08 f0       	brcs	.+2      	; 0x36b4 <UpdateStandaloneStatus+0x14>
    36b2:	4e c0       	rjmp	.+156    	; 0x3750 <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    36b4:	e1 99       	sbic	0x1c, 1	; 28
    36b6:	fe cf       	rjmp	.-4      	; 0x36b4 <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    36b8:	87 e6       	ldi	r24, 0x67	; 103
    36ba:	91 e0       	ldi	r25, 0x01	; 1
    36bc:	9f bb       	out	0x1f, r25	; 31
    36be:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    36c0:	e0 9a       	sbi	0x1c, 0	; 28
    36c2:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    36c4:	80 93 77 01 	sts	0x0177, r24
	     switch(DispenserBrand){
    36c8:	81 50       	subi	r24, 0x01	; 1
    36ca:	82 30       	cpi	r24, 0x02	; 2
    36cc:	08 f4       	brcc	.+2      	; 0x36d0 <UpdateStandaloneStatus+0x30>
    36ce:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    36d0:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
		 if (iAddr>0){
    36d4:	88 23       	and	r24, r24
    36d6:	e1 f1       	breq	.+120    	; 0x3750 <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    36d8:	81 50       	subi	r24, 0x01	; 1
    36da:	c8 2f       	mov	r28, r24
    36dc:	d0 e0       	ldi	r29, 0x00	; 0
    36de:	80 e1       	ldi	r24, 0x10	; 16
    36e0:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    36e4:	8e 01       	movw	r16, r28
    36e6:	09 5d       	subi	r16, 0xD9	; 217
    36e8:	1e 4f       	sbci	r17, 0xFE	; 254
    36ea:	f8 01       	movw	r30, r16
    36ec:	90 81       	ld	r25, Z
    36ee:	98 17       	cp	r25, r24
    36f0:	b1 f0       	breq	.+44     	; 0x371e <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    36f2:	f0 e1       	ldi	r31, 0x10	; 16
    36f4:	ff 16       	cp	r15, r31
    36f6:	21 f0       	breq	.+8      	; 0x3700 <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    36f8:	fe 01       	movw	r30, r28
    36fa:	e8 58       	subi	r30, 0x88	; 136
    36fc:	fe 4f       	sbci	r31, 0xFE	; 254
    36fe:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3700:	8f 2d       	mov	r24, r15
    3702:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    3706:	8e 01       	movw	r16, r28
    3708:	09 5d       	subi	r16, 0xD9	; 217
    370a:	1e 4f       	sbci	r17, 0xFE	; 254
    370c:	f8 01       	movw	r30, r16
    370e:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    3710:	f5 e1       	ldi	r31, 0x15	; 21
    3712:	ff 16       	cp	r15, r31
    3714:	c1 f4       	brne	.+48     	; 0x3746 <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3716:	c8 58       	subi	r28, 0x88	; 136
    3718:	de 4f       	sbci	r29, 0xFE	; 254
    371a:	88 81       	ld	r24, Y
    371c:	10 c0       	rjmp	.+32     	; 0x373e <UpdateStandaloneStatus+0x9e>
    371e:	fe 01       	movw	r30, r28
    3720:	e8 58       	subi	r30, 0x88	; 136
    3722:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED)
    3724:	81 e1       	ldi	r24, 0x11	; 17
    3726:	f8 16       	cp	r15, r24
    3728:	11 f4       	brne	.+4      	; 0x372e <UpdateStandaloneStatus+0x8e>
			         strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    372a:	80 81       	ld	r24, Z
    372c:	08 c0       	rjmp	.+16     	; 0x373e <UpdateStandaloneStatus+0x9e>
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    372e:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    3730:	8b e0       	ldi	r24, 0x0B	; 11
    3732:	f8 16       	cp	r15, r24
    3734:	21 f0       	breq	.+8      	; 0x373e <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    3736:	f4 e1       	ldi	r31, 0x14	; 20
    3738:	ff 16       	cp	r15, r31
    373a:	29 f4       	brne	.+10     	; 0x3746 <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    373c:	84 e1       	ldi	r24, 0x14	; 20
    373e:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    3742:	f8 01       	movw	r30, r16
    3744:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    3746:	10 92 37 01 	sts	0x0137, r1
	     IsNewPumpStatus=True;		 
    374a:	81 e0       	ldi	r24, 0x01	; 1
    374c:	80 93 26 01 	sts	0x0126, r24
		 }		 
	 }
}
    3750:	df 91       	pop	r29
    3752:	cf 91       	pop	r28
    3754:	1f 91       	pop	r17
    3756:	0f 91       	pop	r16
    3758:	ff 90       	pop	r15
    375a:	08 95       	ret

0000375c <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    375c:	1f 93       	push	r17
    375e:	df 93       	push	r29
    3760:	cf 93       	push	r28
    3762:	cd b7       	in	r28, 0x3d	; 61
    3764:	de b7       	in	r29, 0x3e	; 62
    3766:	28 97       	sbiw	r28, 0x08	; 8
    3768:	0f b6       	in	r0, 0x3f	; 63
    376a:	f8 94       	cli
    376c:	de bf       	out	0x3e, r29	; 62
    376e:	0f be       	out	0x3f, r0	; 63
    3770:	cd bf       	out	0x3d, r28	; 61
    3772:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3774:	ce 01       	movw	r24, r28
    3776:	01 96       	adiw	r24, 0x01	; 1
    3778:	65 e4       	ldi	r22, 0x45	; 69
    377a:	70 e0       	ldi	r23, 0x00	; 0
    377c:	48 e0       	ldi	r20, 0x08	; 8
    377e:	50 e0       	ldi	r21, 0x00	; 0
    3780:	27 e9       	ldi	r18, 0x97	; 151
    3782:	32 e1       	ldi	r19, 0x12	; 18
    3784:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    3788:	81 2f       	mov	r24, r17
    378a:	81 50       	subi	r24, 0x01	; 1
    378c:	87 30       	cpi	r24, 0x07	; 7
    378e:	10 f0       	brcs	.+4      	; 0x3794 <GetPumpID+0x38>
    3790:	80 e0       	ldi	r24, 0x00	; 0
    3792:	04 c0       	rjmp	.+8      	; 0x379c <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    3794:	fe 01       	movw	r30, r28
    3796:	e1 0f       	add	r30, r17
    3798:	f1 1d       	adc	r31, r1
    379a:	80 81       	ld	r24, Z
	 }
   return Result;
}
    379c:	28 96       	adiw	r28, 0x08	; 8
    379e:	0f b6       	in	r0, 0x3f	; 63
    37a0:	f8 94       	cli
    37a2:	de bf       	out	0x3e, r29	; 62
    37a4:	0f be       	out	0x3f, r0	; 63
    37a6:	cd bf       	out	0x3d, r28	; 61
    37a8:	cf 91       	pop	r28
    37aa:	df 91       	pop	r29
    37ac:	1f 91       	pop	r17
    37ae:	08 95       	ret

000037b0 <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    37b0:	0f 93       	push	r16
    37b2:	1f 93       	push	r17
    37b4:	df 93       	push	r29
    37b6:	cf 93       	push	r28
    37b8:	00 d0       	rcall	.+0      	; 0x37ba <GetTotalizerData+0xa>
    37ba:	00 d0       	rcall	.+0      	; 0x37bc <GetTotalizerData+0xc>
    37bc:	00 d0       	rcall	.+0      	; 0x37be <GetTotalizerData+0xe>
    37be:	cd b7       	in	r28, 0x3d	; 61
    37c0:	de b7       	in	r29, 0x3e	; 62
    37c2:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    37c4:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    37c6:	21 50       	subi	r18, 0x01	; 1
    37c8:	26 30       	cpi	r18, 0x06	; 6
    37ca:	08 f4       	brcc	.+2      	; 0x37ce <GetTotalizerData+0x1e>
    37cc:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    37ce:	88 23       	and	r24, r24
    37d0:	d9 f4       	brne	.+54     	; 0x3808 <GetTotalizerData+0x58>
    37d2:	64 e2       	ldi	r22, 0x24	; 36
    37d4:	46 9f       	mul	r20, r22
    37d6:	b0 01       	movw	r22, r0
    37d8:	11 24       	eor	r1, r1
    37da:	29 2f       	mov	r18, r25
    37dc:	30 e0       	ldi	r19, 0x00	; 0
    37de:	80 e2       	ldi	r24, 0x20	; 32
    37e0:	91 e0       	ldi	r25, 0x01	; 1
    37e2:	fc 01       	movw	r30, r24
    37e4:	2e 9f       	mul	r18, r30
    37e6:	c0 01       	movw	r24, r0
    37e8:	2f 9f       	mul	r18, r31
    37ea:	90 0d       	add	r25, r0
    37ec:	3e 9f       	mul	r19, r30
    37ee:	90 0d       	add	r25, r0
    37f0:	11 24       	eor	r1, r1
    37f2:	68 0f       	add	r22, r24
    37f4:	79 1f       	adc	r23, r25
    37f6:	86 e0       	ldi	r24, 0x06	; 6
    37f8:	58 9f       	mul	r21, r24
    37fa:	c0 01       	movw	r24, r0
    37fc:	11 24       	eor	r1, r1
    37fe:	68 0f       	add	r22, r24
    3800:	79 1f       	adc	r23, r25
    3802:	6d 50       	subi	r22, 0x0D	; 13
    3804:	7c 4f       	sbci	r23, 0xFC	; 252
    3806:	1c c0       	rjmp	.+56     	; 0x3840 <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3808:	81 30       	cpi	r24, 0x01	; 1
    380a:	11 f5       	brne	.+68     	; 0x3850 <GetTotalizerData+0xa0>
    380c:	64 e2       	ldi	r22, 0x24	; 36
    380e:	46 9f       	mul	r20, r22
    3810:	b0 01       	movw	r22, r0
    3812:	11 24       	eor	r1, r1
    3814:	29 2f       	mov	r18, r25
    3816:	30 e0       	ldi	r19, 0x00	; 0
    3818:	80 e2       	ldi	r24, 0x20	; 32
    381a:	91 e0       	ldi	r25, 0x01	; 1
    381c:	fc 01       	movw	r30, r24
    381e:	2e 9f       	mul	r18, r30
    3820:	c0 01       	movw	r24, r0
    3822:	2f 9f       	mul	r18, r31
    3824:	90 0d       	add	r25, r0
    3826:	3e 9f       	mul	r19, r30
    3828:	90 0d       	add	r25, r0
    382a:	11 24       	eor	r1, r1
    382c:	68 0f       	add	r22, r24
    382e:	79 1f       	adc	r23, r25
    3830:	86 e0       	ldi	r24, 0x06	; 6
    3832:	58 9f       	mul	r21, r24
    3834:	c0 01       	movw	r24, r0
    3836:	11 24       	eor	r1, r1
    3838:	68 0f       	add	r22, r24
    383a:	79 1f       	adc	r23, r25
    383c:	6d 5c       	subi	r22, 0xCD	; 205
    383e:	79 4f       	sbci	r23, 0xF9	; 249
    3840:	ce 01       	movw	r24, r28
    3842:	01 96       	adiw	r24, 0x01	; 1
    3844:	46 e0       	ldi	r20, 0x06	; 6
    3846:	50 e0       	ldi	r21, 0x00	; 0
    3848:	27 e9       	ldi	r18, 0x97	; 151
    384a:	32 e1       	ldi	r19, 0x12	; 18
    384c:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    3850:	ce 01       	movw	r24, r28
    3852:	01 96       	adiw	r24, 0x01	; 1
    3854:	b8 01       	movw	r22, r16
    3856:	0e 94 05 19 	call	0x320a	; 0x320a <RawToStr>
}
    385a:	26 96       	adiw	r28, 0x06	; 6
    385c:	0f b6       	in	r0, 0x3f	; 63
    385e:	f8 94       	cli
    3860:	de bf       	out	0x3e, r29	; 62
    3862:	0f be       	out	0x3f, r0	; 63
    3864:	cd bf       	out	0x3d, r28	; 61
    3866:	cf 91       	pop	r28
    3868:	df 91       	pop	r29
    386a:	1f 91       	pop	r17
    386c:	0f 91       	pop	r16
    386e:	08 95       	ret

00003870 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    3870:	df 92       	push	r13
    3872:	ef 92       	push	r14
    3874:	ff 92       	push	r15
    3876:	0f 93       	push	r16
    3878:	1f 93       	push	r17
    387a:	df 93       	push	r29
    387c:	cf 93       	push	r28
    387e:	00 d0       	rcall	.+0      	; 0x3880 <SelectMark+0x10>
    3880:	00 d0       	rcall	.+0      	; 0x3882 <SelectMark+0x12>
    3882:	0f 92       	push	r0
    3884:	cd b7       	in	r28, 0x3d	; 61
    3886:	de b7       	in	r29, 0x3e	; 62
    3888:	d8 2e       	mov	r13, r24
    388a:	8e 01       	movw	r16, r28
    388c:	0f 5f       	subi	r16, 0xFF	; 255
    388e:	1f 4f       	sbci	r17, 0xFF	; 255
    3890:	c8 01       	movw	r24, r16
    3892:	60 e4       	ldi	r22, 0x40	; 64
    3894:	70 e0       	ldi	r23, 0x00	; 0
    3896:	45 e0       	ldi	r20, 0x05	; 5
    3898:	50 e0       	ldi	r21, 0x00	; 0
    389a:	27 e9       	ldi	r18, 0x97	; 151
    389c:	32 e1       	ldi	r19, 0x12	; 18
    389e:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    38a2:	ed 2d       	mov	r30, r13
    38a4:	21 e0       	ldi	r18, 0x01	; 1
    38a6:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    38a8:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    38aa:	d8 01       	movw	r26, r16
    38ac:	8c 91       	ld	r24, X
    38ae:	d8 16       	cp	r13, r24
    38b0:	49 f4       	brne	.+18     	; 0x38c4 <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    38b2:	c9 01       	movw	r24, r18
    38b4:	65 e0       	ldi	r22, 0x05	; 5
    38b6:	70 e0       	ldi	r23, 0x00	; 0
    38b8:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    38bc:	f7 01       	movw	r30, r14
    38be:	e8 0f       	add	r30, r24
    38c0:	f9 1f       	adc	r31, r25
    38c2:	e0 81       	ld	r30, Z
    38c4:	0f 5f       	subi	r16, 0xFF	; 255
    38c6:	1f 4f       	sbci	r17, 0xFF	; 255
    38c8:	2f 5f       	subi	r18, 0xFF	; 255
    38ca:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    38cc:	26 30       	cpi	r18, 0x06	; 6
    38ce:	31 05       	cpc	r19, r1
    38d0:	61 f7       	brne	.-40     	; 0x38aa <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    38d2:	8e 2f       	mov	r24, r30
    38d4:	0f 90       	pop	r0
    38d6:	0f 90       	pop	r0
    38d8:	0f 90       	pop	r0
    38da:	0f 90       	pop	r0
    38dc:	0f 90       	pop	r0
    38de:	cf 91       	pop	r28
    38e0:	df 91       	pop	r29
    38e2:	1f 91       	pop	r17
    38e4:	0f 91       	pop	r16
    38e6:	ff 90       	pop	r15
    38e8:	ef 90       	pop	r14
    38ea:	df 90       	pop	r13
    38ec:	08 95       	ret

000038ee <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}
void UpdateServerIP(){     
    38ee:	cf 92       	push	r12
    38f0:	df 92       	push	r13
    38f2:	ef 92       	push	r14
    38f4:	ff 92       	push	r15
    38f6:	0f 93       	push	r16
    38f8:	1f 93       	push	r17
    38fa:	df 93       	push	r29
    38fc:	cf 93       	push	r28
    38fe:	cd b7       	in	r28, 0x3d	; 61
    3900:	de b7       	in	r29, 0x3e	; 62
    3902:	64 97       	sbiw	r28, 0x14	; 20
    3904:	0f b6       	in	r0, 0x3f	; 63
    3906:	f8 94       	cli
    3908:	de bf       	out	0x3e, r29	; 62
    390a:	0f be       	out	0x3f, r0	; 63
    390c:	cd bf       	out	0x3d, r28	; 61
    390e:	8e 01       	movw	r16, r28
    3910:	0f 5f       	subi	r16, 0xFF	; 255
    3912:	1f 4f       	sbci	r17, 0xFF	; 255
    3914:	c8 01       	movw	r24, r16
    3916:	6c e2       	ldi	r22, 0x2C	; 44
    3918:	70 e0       	ldi	r23, 0x00	; 0
    391a:	44 e0       	ldi	r20, 0x04	; 4
    391c:	50 e0       	ldi	r21, 0x00	; 0
    391e:	27 e9       	ldi	r18, 0x97	; 151
    3920:	32 e1       	ldi	r19, 0x12	; 18
    3922:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    3926:	78 01       	movw	r14, r16
    3928:	8e 01       	movw	r16, r28
    392a:	0b 5f       	subi	r16, 0xFB	; 251
    392c:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    392e:	68 01       	movw	r12, r16
    3930:	d7 01       	movw	r26, r14
    3932:	8d 91       	ld	r24, X+
    3934:	7d 01       	movw	r14, r26
    3936:	b8 01       	movw	r22, r16
    3938:	0e 94 d7 15 	call	0x2bae	; 0x2bae <zeroIP>
    393c:	0c 5f       	subi	r16, 0xFC	; 252
    393e:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
    3940:	ec 14       	cp	r14, r12
    3942:	fd 04       	cpc	r15, r13
    3944:	a9 f7       	brne	.-22     	; 0x3930 <UpdateServerIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3946:	ed b7       	in	r30, 0x3d	; 61
    3948:	fe b7       	in	r31, 0x3e	; 62
    394a:	3c 97       	sbiw	r30, 0x0c	; 12
    394c:	0f b6       	in	r0, 0x3f	; 63
    394e:	f8 94       	cli
    3950:	fe bf       	out	0x3e, r31	; 62
    3952:	0f be       	out	0x3f, r0	; 63
    3954:	ed bf       	out	0x3d, r30	; 61
    3956:	31 96       	adiw	r30, 0x01	; 1
    3958:	82 e1       	ldi	r24, 0x12	; 18
    395a:	9a e0       	ldi	r25, 0x0A	; 10
    395c:	ad b7       	in	r26, 0x3d	; 61
    395e:	be b7       	in	r27, 0x3e	; 62
    3960:	12 96       	adiw	r26, 0x02	; 2
    3962:	9c 93       	st	X, r25
    3964:	8e 93       	st	-X, r24
    3966:	11 97       	sbiw	r26, 0x01	; 1
    3968:	8e e3       	ldi	r24, 0x3E	; 62
    396a:	91 e2       	ldi	r25, 0x21	; 33
    396c:	93 83       	std	Z+3, r25	; 0x03
    396e:	82 83       	std	Z+2, r24	; 0x02
    3970:	f5 82       	std	Z+5, r15	; 0x05
    3972:	e4 82       	std	Z+4, r14	; 0x04
    3974:	ce 01       	movw	r24, r28
    3976:	09 96       	adiw	r24, 0x09	; 9
    3978:	97 83       	std	Z+7, r25	; 0x07
    397a:	86 83       	std	Z+6, r24	; 0x06
    397c:	ce 01       	movw	r24, r28
    397e:	0d 96       	adiw	r24, 0x0d	; 13
    3980:	91 87       	std	Z+9, r25	; 0x09
    3982:	80 87       	std	Z+8, r24	; 0x08
    3984:	ce 01       	movw	r24, r28
    3986:	41 96       	adiw	r24, 0x11	; 17
    3988:	93 87       	std	Z+11, r25	; 0x0b
    398a:	82 87       	std	Z+10, r24	; 0x0a
    398c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    3990:	ed b7       	in	r30, 0x3d	; 61
    3992:	fe b7       	in	r31, 0x3e	; 62
    3994:	3c 96       	adiw	r30, 0x0c	; 12
    3996:	0f b6       	in	r0, 0x3f	; 63
    3998:	f8 94       	cli
    399a:	fe bf       	out	0x3e, r31	; 62
    399c:	0f be       	out	0x3f, r0	; 63
    399e:	ed bf       	out	0x3d, r30	; 61
}
    39a0:	64 96       	adiw	r28, 0x14	; 20
    39a2:	0f b6       	in	r0, 0x3f	; 63
    39a4:	f8 94       	cli
    39a6:	de bf       	out	0x3e, r29	; 62
    39a8:	0f be       	out	0x3f, r0	; 63
    39aa:	cd bf       	out	0x3d, r28	; 61
    39ac:	cf 91       	pop	r28
    39ae:	df 91       	pop	r29
    39b0:	1f 91       	pop	r17
    39b2:	0f 91       	pop	r16
    39b4:	ff 90       	pop	r15
    39b6:	ef 90       	pop	r14
    39b8:	df 90       	pop	r13
    39ba:	cf 90       	pop	r12
    39bc:	08 95       	ret

000039be <UpdateClientIP>:
	     str[0]=('0'+S);
	     str[1]=0;
	 }
}

void UpdateClientIP(){     
    39be:	cf 92       	push	r12
    39c0:	df 92       	push	r13
    39c2:	ef 92       	push	r14
    39c4:	ff 92       	push	r15
    39c6:	0f 93       	push	r16
    39c8:	1f 93       	push	r17
    39ca:	df 93       	push	r29
    39cc:	cf 93       	push	r28
    39ce:	cd b7       	in	r28, 0x3d	; 61
    39d0:	de b7       	in	r29, 0x3e	; 62
    39d2:	68 97       	sbiw	r28, 0x18	; 24
    39d4:	0f b6       	in	r0, 0x3f	; 63
    39d6:	f8 94       	cli
    39d8:	de bf       	out	0x3e, r29	; 62
    39da:	0f be       	out	0x3f, r0	; 63
    39dc:	cd bf       	out	0x3d, r28	; 61
    39de:	8e 01       	movw	r16, r28
    39e0:	0f 5f       	subi	r16, 0xFF	; 255
    39e2:	1f 4f       	sbci	r17, 0xFF	; 255
    39e4:	c8 01       	movw	r24, r16
    39e6:	68 e2       	ldi	r22, 0x28	; 40
    39e8:	70 e0       	ldi	r23, 0x00	; 0
    39ea:	44 e0       	ldi	r20, 0x04	; 4
    39ec:	50 e0       	ldi	r21, 0x00	; 0
    39ee:	27 e9       	ldi	r18, 0x97	; 151
    39f0:	32 e1       	ldi	r19, 0x12	; 18
    39f2:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    39f6:	78 01       	movw	r14, r16
    39f8:	8e 01       	movw	r16, r28
    39fa:	0b 5f       	subi	r16, 0xFB	; 251
    39fc:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    39fe:	68 01       	movw	r12, r16
    3a00:	d7 01       	movw	r26, r14
    3a02:	8d 91       	ld	r24, X+
    3a04:	7d 01       	movw	r14, r26
    3a06:	b8 01       	movw	r22, r16
    3a08:	0e 94 d7 15 	call	0x2bae	; 0x2bae <zeroIP>
    3a0c:	0b 5f       	subi	r16, 0xFB	; 251
    3a0e:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
    3a10:	ec 14       	cp	r14, r12
    3a12:	fd 04       	cpc	r15, r13
    3a14:	a9 f7       	brne	.-22     	; 0x3a00 <UpdateClientIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3a16:	ed b7       	in	r30, 0x3d	; 61
    3a18:	fe b7       	in	r31, 0x3e	; 62
    3a1a:	3c 97       	sbiw	r30, 0x0c	; 12
    3a1c:	0f b6       	in	r0, 0x3f	; 63
    3a1e:	f8 94       	cli
    3a20:	fe bf       	out	0x3e, r31	; 62
    3a22:	0f be       	out	0x3f, r0	; 63
    3a24:	ed bf       	out	0x3d, r30	; 61
    3a26:	31 96       	adiw	r30, 0x01	; 1
    3a28:	85 ee       	ldi	r24, 0xE5	; 229
    3a2a:	99 e0       	ldi	r25, 0x09	; 9
    3a2c:	ad b7       	in	r26, 0x3d	; 61
    3a2e:	be b7       	in	r27, 0x3e	; 62
    3a30:	12 96       	adiw	r26, 0x02	; 2
    3a32:	9c 93       	st	X, r25
    3a34:	8e 93       	st	-X, r24
    3a36:	11 97       	sbiw	r26, 0x01	; 1
    3a38:	8a e4       	ldi	r24, 0x4A	; 74
    3a3a:	91 e2       	ldi	r25, 0x21	; 33
    3a3c:	93 83       	std	Z+3, r25	; 0x03
    3a3e:	82 83       	std	Z+2, r24	; 0x02
    3a40:	f5 82       	std	Z+5, r15	; 0x05
    3a42:	e4 82       	std	Z+4, r14	; 0x04
    3a44:	ce 01       	movw	r24, r28
    3a46:	0a 96       	adiw	r24, 0x0a	; 10
    3a48:	97 83       	std	Z+7, r25	; 0x07
    3a4a:	86 83       	std	Z+6, r24	; 0x06
    3a4c:	ce 01       	movw	r24, r28
    3a4e:	0f 96       	adiw	r24, 0x0f	; 15
    3a50:	91 87       	std	Z+9, r25	; 0x09
    3a52:	80 87       	std	Z+8, r24	; 0x08
    3a54:	ce 01       	movw	r24, r28
    3a56:	44 96       	adiw	r24, 0x14	; 20
    3a58:	93 87       	std	Z+11, r25	; 0x0b
    3a5a:	82 87       	std	Z+10, r24	; 0x0a
    3a5c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    3a60:	ed b7       	in	r30, 0x3d	; 61
    3a62:	fe b7       	in	r31, 0x3e	; 62
    3a64:	3c 96       	adiw	r30, 0x0c	; 12
    3a66:	0f b6       	in	r0, 0x3f	; 63
    3a68:	f8 94       	cli
    3a6a:	fe bf       	out	0x3e, r31	; 62
    3a6c:	0f be       	out	0x3f, r0	; 63
    3a6e:	ed bf       	out	0x3d, r30	; 61
}
    3a70:	68 96       	adiw	r28, 0x18	; 24
    3a72:	0f b6       	in	r0, 0x3f	; 63
    3a74:	f8 94       	cli
    3a76:	de bf       	out	0x3e, r29	; 62
    3a78:	0f be       	out	0x3f, r0	; 63
    3a7a:	cd bf       	out	0x3d, r28	; 61
    3a7c:	cf 91       	pop	r28
    3a7e:	df 91       	pop	r29
    3a80:	1f 91       	pop	r17
    3a82:	0f 91       	pop	r16
    3a84:	ff 90       	pop	r15
    3a86:	ef 90       	pop	r14
    3a88:	df 90       	pop	r13
    3a8a:	cf 90       	pop	r12
    3a8c:	08 95       	ret

00003a8e <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    3a8e:	cf 92       	push	r12
    3a90:	df 92       	push	r13
    3a92:	ef 92       	push	r14
    3a94:	ff 92       	push	r15
    3a96:	0f 93       	push	r16
    3a98:	1f 93       	push	r17
    3a9a:	df 93       	push	r29
    3a9c:	cf 93       	push	r28
    3a9e:	cd b7       	in	r28, 0x3d	; 61
    3aa0:	de b7       	in	r29, 0x3e	; 62
    3aa2:	2f 97       	sbiw	r28, 0x0f	; 15
    3aa4:	0f b6       	in	r0, 0x3f	; 63
    3aa6:	f8 94       	cli
    3aa8:	de bf       	out	0x3e, r29	; 62
    3aaa:	0f be       	out	0x3f, r0	; 63
    3aac:	cd bf       	out	0x3d, r28	; 61
    3aae:	e8 2e       	mov	r14, r24
    3ab0:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    3ab2:	8f 70       	andi	r24, 0x0F	; 15
    3ab4:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
     if (FIPAddr>0){
    3ab8:	88 23       	and	r24, r24
    3aba:	09 f4       	brne	.+2      	; 0x3abe <GenerateStandaloneTransData+0x30>
    3abc:	2d c1       	rjmp	.+602    	; 0x3d18 <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    3abe:	81 50       	subi	r24, 0x01	; 1
    3ac0:	c8 2e       	mov	r12, r24
    3ac2:	dd 24       	eor	r13, r13
    3ac4:	85 e3       	ldi	r24, 0x35	; 53
    3ac6:	90 e0       	ldi	r25, 0x00	; 0
    3ac8:	c8 9e       	mul	r12, r24
    3aca:	f0 01       	movw	r30, r0
    3acc:	c9 9e       	mul	r12, r25
    3ace:	f0 0d       	add	r31, r0
    3ad0:	d8 9e       	mul	r13, r24
    3ad2:	f0 0d       	add	r31, r0
    3ad4:	11 24       	eor	r1, r1
    3ad6:	ee 54       	subi	r30, 0x4E	; 78
    3ad8:	f8 4f       	sbci	r31, 0xF8	; 248
    3ada:	80 81       	ld	r24, Z
    3adc:	08 0f       	add	r16, r24
    3ade:	11 1d       	adc	r17, r1
    3ae0:	d8 01       	movw	r26, r16
    3ae2:	2c 91       	ld	r18, X
    3ae4:	ce 01       	movw	r24, r28
    3ae6:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    3ae8:	22 23       	and	r18, r18
    3aea:	69 f0       	breq	.+26     	; 0x3b06 <GenerateStandaloneTransData+0x78>
    3aec:	6d e0       	ldi	r22, 0x0D	; 13
    3aee:	26 9f       	mul	r18, r22
    3af0:	b0 01       	movw	r22, r0
    3af2:	11 24       	eor	r1, r1
    3af4:	62 52       	subi	r22, 0x22	; 34
    3af6:	7f 4f       	sbci	r23, 0xFF	; 255
    3af8:	4d e0       	ldi	r20, 0x0D	; 13
    3afa:	50 e0       	ldi	r21, 0x00	; 0
    3afc:	27 e9       	ldi	r18, 0x97	; 151
    3afe:	32 e1       	ldi	r19, 0x12	; 18
    3b00:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    3b04:	10 c0       	rjmp	.+32     	; 0x3b26 <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    3b06:	00 d0       	rcall	.+0      	; 0x3b08 <GenerateStandaloneTransData+0x7a>
    3b08:	00 d0       	rcall	.+0      	; 0x3b0a <GenerateStandaloneTransData+0x7c>
    3b0a:	ed b7       	in	r30, 0x3d	; 61
    3b0c:	fe b7       	in	r31, 0x3e	; 62
    3b0e:	92 83       	std	Z+2, r25	; 0x02
    3b10:	81 83       	std	Z+1, r24	; 0x01
    3b12:	85 e1       	ldi	r24, 0x15	; 21
    3b14:	92 e2       	ldi	r25, 0x22	; 34
    3b16:	94 83       	std	Z+4, r25	; 0x04
    3b18:	83 83       	std	Z+3, r24	; 0x03
    3b1a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    3b1e:	0f 90       	pop	r0
    3b20:	0f 90       	pop	r0
    3b22:	0f 90       	pop	r0
    3b24:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3b26:	e1 99       	sbic	0x1c, 1	; 28
    3b28:	fe cf       	rjmp	.-4      	; 0x3b26 <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3b2a:	80 e0       	ldi	r24, 0x00	; 0
    3b2c:	90 e0       	ldi	r25, 0x00	; 0
    3b2e:	9f bb       	out	0x1f, r25	; 31
    3b30:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3b32:	e0 9a       	sbi	0x1c, 0	; 28
    3b34:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    3b36:	00 d0       	rcall	.+0      	; 0x3b38 <GenerateStandaloneTransData+0xaa>
    3b38:	00 d0       	rcall	.+0      	; 0x3b3a <GenerateStandaloneTransData+0xac>
    3b3a:	00 d0       	rcall	.+0      	; 0x3b3c <GenerateStandaloneTransData+0xae>
    3b3c:	ad b7       	in	r26, 0x3d	; 61
    3b3e:	be b7       	in	r27, 0x3e	; 62
    3b40:	11 96       	adiw	r26, 0x01	; 1
    3b42:	8e e6       	ldi	r24, 0x6E	; 110
    3b44:	9e e0       	ldi	r25, 0x0E	; 14
    3b46:	ed b7       	in	r30, 0x3d	; 61
    3b48:	fe b7       	in	r31, 0x3e	; 62
    3b4a:	92 83       	std	Z+2, r25	; 0x02
    3b4c:	81 83       	std	Z+1, r24	; 0x01
    3b4e:	82 e1       	ldi	r24, 0x12	; 18
    3b50:	92 e2       	ldi	r25, 0x22	; 34
    3b52:	13 96       	adiw	r26, 0x03	; 3
    3b54:	9c 93       	st	X, r25
    3b56:	8e 93       	st	-X, r24
    3b58:	12 97       	sbiw	r26, 0x02	; 2
    3b5a:	85 e3       	ldi	r24, 0x35	; 53
    3b5c:	90 e0       	ldi	r25, 0x00	; 0
    3b5e:	c8 9e       	mul	r12, r24
    3b60:	80 01       	movw	r16, r0
    3b62:	c9 9e       	mul	r12, r25
    3b64:	10 0d       	add	r17, r0
    3b66:	d8 9e       	mul	r13, r24
    3b68:	10 0d       	add	r17, r0
    3b6a:	11 24       	eor	r1, r1
    3b6c:	f8 01       	movw	r30, r16
    3b6e:	ee 54       	subi	r30, 0x4E	; 78
    3b70:	f8 4f       	sbci	r31, 0xF8	; 248
    3b72:	82 81       	ldd	r24, Z+2	; 0x02
    3b74:	14 96       	adiw	r26, 0x04	; 4
    3b76:	8c 93       	st	X, r24
    3b78:	14 97       	sbiw	r26, 0x04	; 4
    3b7a:	15 96       	adiw	r26, 0x05	; 5
    3b7c:	1c 92       	st	X, r1
    3b7e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    3b82:	ed b7       	in	r30, 0x3d	; 61
    3b84:	fe b7       	in	r31, 0x3e	; 62
    3b86:	31 96       	adiw	r30, 0x01	; 1
    3b88:	8d e8       	ldi	r24, 0x8D	; 141
    3b8a:	9e e0       	ldi	r25, 0x0E	; 14
    3b8c:	ad b7       	in	r26, 0x3d	; 61
    3b8e:	be b7       	in	r27, 0x3e	; 62
    3b90:	12 96       	adiw	r26, 0x02	; 2
    3b92:	9c 93       	st	X, r25
    3b94:	8e 93       	st	-X, r24
    3b96:	11 97       	sbiw	r26, 0x01	; 1
    3b98:	8f e0       	ldi	r24, 0x0F	; 15
    3b9a:	92 e2       	ldi	r25, 0x22	; 34
    3b9c:	93 83       	std	Z+3, r25	; 0x03
    3b9e:	82 83       	std	Z+2, r24	; 0x02
    3ba0:	c8 01       	movw	r24, r16
    3ba2:	8b 54       	subi	r24, 0x4B	; 75
    3ba4:	98 4f       	sbci	r25, 0xF8	; 248
    3ba6:	95 83       	std	Z+5, r25	; 0x05
    3ba8:	84 83       	std	Z+4, r24	; 0x04
    3baa:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    3bae:	ed b7       	in	r30, 0x3d	; 61
    3bb0:	fe b7       	in	r31, 0x3e	; 62
    3bb2:	31 96       	adiw	r30, 0x01	; 1
    3bb4:	88 e7       	ldi	r24, 0x78	; 120
    3bb6:	99 e0       	ldi	r25, 0x09	; 9
    3bb8:	ad b7       	in	r26, 0x3d	; 61
    3bba:	be b7       	in	r27, 0x3e	; 62
    3bbc:	12 96       	adiw	r26, 0x02	; 2
    3bbe:	9c 93       	st	X, r25
    3bc0:	8e 93       	st	-X, r24
    3bc2:	11 97       	sbiw	r26, 0x01	; 1
    3bc4:	8c e0       	ldi	r24, 0x0C	; 12
    3bc6:	92 e2       	ldi	r25, 0x22	; 34
    3bc8:	93 83       	std	Z+3, r25	; 0x03
    3bca:	82 83       	std	Z+2, r24	; 0x02
    3bcc:	c8 01       	movw	r24, r16
    3bce:	84 54       	subi	r24, 0x44	; 68
    3bd0:	98 4f       	sbci	r25, 0xF8	; 248
    3bd2:	95 83       	std	Z+5, r25	; 0x05
    3bd4:	84 83       	std	Z+4, r24	; 0x04
    3bd6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    3bda:	ed b7       	in	r30, 0x3d	; 61
    3bdc:	fe b7       	in	r31, 0x3e	; 62
    3bde:	31 96       	adiw	r30, 0x01	; 1
    3be0:	82 e5       	ldi	r24, 0x52	; 82
    3be2:	95 e0       	ldi	r25, 0x05	; 5
    3be4:	ad b7       	in	r26, 0x3d	; 61
    3be6:	be b7       	in	r27, 0x3e	; 62
    3be8:	12 96       	adiw	r26, 0x02	; 2
    3bea:	9c 93       	st	X, r25
    3bec:	8e 93       	st	-X, r24
    3bee:	11 97       	sbiw	r26, 0x01	; 1
    3bf0:	89 e0       	ldi	r24, 0x09	; 9
    3bf2:	92 e2       	ldi	r25, 0x22	; 34
    3bf4:	93 83       	std	Z+3, r25	; 0x03
    3bf6:	82 83       	std	Z+2, r24	; 0x02
    3bf8:	c8 01       	movw	r24, r16
    3bfa:	8b 53       	subi	r24, 0x3B	; 59
    3bfc:	98 4f       	sbci	r25, 0xF8	; 248
    3bfe:	95 83       	std	Z+5, r25	; 0x05
    3c00:	84 83       	std	Z+4, r24	; 0x04
    3c02:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    3c06:	ed b7       	in	r30, 0x3d	; 61
    3c08:	fe b7       	in	r31, 0x3e	; 62
    3c0a:	31 96       	adiw	r30, 0x01	; 1
    3c0c:	8a ef       	ldi	r24, 0xFA	; 250
    3c0e:	9a e0       	ldi	r25, 0x0A	; 10
    3c10:	ad b7       	in	r26, 0x3d	; 61
    3c12:	be b7       	in	r27, 0x3e	; 62
    3c14:	12 96       	adiw	r26, 0x02	; 2
    3c16:	9c 93       	st	X, r25
    3c18:	8e 93       	st	-X, r24
    3c1a:	11 97       	sbiw	r26, 0x01	; 1
    3c1c:	86 e0       	ldi	r24, 0x06	; 6
    3c1e:	92 e2       	ldi	r25, 0x22	; 34
    3c20:	93 83       	std	Z+3, r25	; 0x03
    3c22:	82 83       	std	Z+2, r24	; 0x02
    3c24:	f4 82       	std	Z+4, r15	; 0x04
    3c26:	15 82       	std	Z+5, r1	; 0x05
    3c28:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    3c2c:	ed b7       	in	r30, 0x3d	; 61
    3c2e:	fe b7       	in	r31, 0x3e	; 62
    3c30:	31 96       	adiw	r30, 0x01	; 1
    3c32:	83 ec       	ldi	r24, 0xC3	; 195
    3c34:	99 e0       	ldi	r25, 0x09	; 9
    3c36:	ad b7       	in	r26, 0x3d	; 61
    3c38:	be b7       	in	r27, 0x3e	; 62
    3c3a:	12 96       	adiw	r26, 0x02	; 2
    3c3c:	9c 93       	st	X, r25
    3c3e:	8e 93       	st	-X, r24
    3c40:	11 97       	sbiw	r26, 0x01	; 1
    3c42:	81 e0       	ldi	r24, 0x01	; 1
    3c44:	92 e2       	ldi	r25, 0x22	; 34
    3c46:	93 83       	std	Z+3, r25	; 0x03
    3c48:	82 83       	std	Z+2, r24	; 0x02
    3c4a:	e4 82       	std	Z+4, r14	; 0x04
    3c4c:	15 82       	std	Z+5, r1	; 0x05
    3c4e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    3c52:	ed b7       	in	r30, 0x3d	; 61
    3c54:	fe b7       	in	r31, 0x3e	; 62
    3c56:	31 96       	adiw	r30, 0x01	; 1
    3c58:	88 e3       	ldi	r24, 0x38	; 56
    3c5a:	9a e0       	ldi	r25, 0x0A	; 10
    3c5c:	ad b7       	in	r26, 0x3d	; 61
    3c5e:	be b7       	in	r27, 0x3e	; 62
    3c60:	12 96       	adiw	r26, 0x02	; 2
    3c62:	9c 93       	st	X, r25
    3c64:	8e 93       	st	-X, r24
    3c66:	11 97       	sbiw	r26, 0x01	; 1
    3c68:	8e ef       	ldi	r24, 0xFE	; 254
    3c6a:	91 e2       	ldi	r25, 0x21	; 33
    3c6c:	93 83       	std	Z+3, r25	; 0x03
    3c6e:	82 83       	std	Z+2, r24	; 0x02
    3c70:	ce 01       	movw	r24, r28
    3c72:	01 96       	adiw	r24, 0x01	; 1
    3c74:	95 83       	std	Z+5, r25	; 0x05
    3c76:	84 83       	std	Z+4, r24	; 0x04
    3c78:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    3c7c:	ed b7       	in	r30, 0x3d	; 61
    3c7e:	fe b7       	in	r31, 0x3e	; 62
    3c80:	31 96       	adiw	r30, 0x01	; 1
    3c82:	88 ea       	ldi	r24, 0xA8	; 168
    3c84:	97 e0       	ldi	r25, 0x07	; 7
    3c86:	ad b7       	in	r26, 0x3d	; 61
    3c88:	be b7       	in	r27, 0x3e	; 62
    3c8a:	12 96       	adiw	r26, 0x02	; 2
    3c8c:	9c 93       	st	X, r25
    3c8e:	8e 93       	st	-X, r24
    3c90:	11 97       	sbiw	r26, 0x01	; 1
    3c92:	8b ef       	ldi	r24, 0xFB	; 251
    3c94:	91 e2       	ldi	r25, 0x21	; 33
    3c96:	93 83       	std	Z+3, r25	; 0x03
    3c98:	82 83       	std	Z+2, r24	; 0x02
    3c9a:	c8 01       	movw	r24, r16
    3c9c:	82 53       	subi	r24, 0x32	; 50
    3c9e:	98 4f       	sbci	r25, 0xF8	; 248
    3ca0:	95 83       	std	Z+5, r25	; 0x05
    3ca2:	84 83       	std	Z+4, r24	; 0x04
    3ca4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    3ca8:	ed b7       	in	r30, 0x3d	; 61
    3caa:	fe b7       	in	r31, 0x3e	; 62
    3cac:	31 96       	adiw	r30, 0x01	; 1
    3cae:	8a e7       	ldi	r24, 0x7A	; 122
    3cb0:	95 e0       	ldi	r25, 0x05	; 5
    3cb2:	ad b7       	in	r26, 0x3d	; 61
    3cb4:	be b7       	in	r27, 0x3e	; 62
    3cb6:	12 96       	adiw	r26, 0x02	; 2
    3cb8:	9c 93       	st	X, r25
    3cba:	8e 93       	st	-X, r24
    3cbc:	11 97       	sbiw	r26, 0x01	; 1
    3cbe:	88 ef       	ldi	r24, 0xF8	; 248
    3cc0:	91 e2       	ldi	r25, 0x21	; 33
    3cc2:	93 83       	std	Z+3, r25	; 0x03
    3cc4:	82 83       	std	Z+2, r24	; 0x02
    3cc6:	c8 01       	movw	r24, r16
    3cc8:	8b 52       	subi	r24, 0x2B	; 43
    3cca:	98 4f       	sbci	r25, 0xF8	; 248
    3ccc:	95 83       	std	Z+5, r25	; 0x05
    3cce:	84 83       	std	Z+4, r24	; 0x04
    3cd0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    3cd4:	ed b7       	in	r30, 0x3d	; 61
    3cd6:	fe b7       	in	r31, 0x3e	; 62
    3cd8:	31 96       	adiw	r30, 0x01	; 1
    3cda:	86 eb       	ldi	r24, 0xB6	; 182
    3cdc:	9d e0       	ldi	r25, 0x0D	; 13
    3cde:	ad b7       	in	r26, 0x3d	; 61
    3ce0:	be b7       	in	r27, 0x3e	; 62
    3ce2:	12 96       	adiw	r26, 0x02	; 2
    3ce4:	9c 93       	st	X, r25
    3ce6:	8e 93       	st	-X, r24
    3ce8:	11 97       	sbiw	r26, 0x01	; 1
    3cea:	85 ef       	ldi	r24, 0xF5	; 245
    3cec:	91 e2       	ldi	r25, 0x21	; 33
    3cee:	93 83       	std	Z+3, r25	; 0x03
    3cf0:	82 83       	std	Z+2, r24	; 0x02
    3cf2:	02 52       	subi	r16, 0x22	; 34
    3cf4:	18 4f       	sbci	r17, 0xF8	; 248
    3cf6:	15 83       	std	Z+5, r17	; 0x05
    3cf8:	04 83       	std	Z+4, r16	; 0x04
    3cfa:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>

		 MOPType=MOP_CASH;
    3cfe:	10 92 e5 01 	sts	0x01E5, r1
	     IsPrinting=True;	 
    3d02:	81 e0       	ldi	r24, 0x01	; 1
    3d04:	80 93 d9 01 	sts	0x01D9, r24
    3d08:	ed b7       	in	r30, 0x3d	; 61
    3d0a:	fe b7       	in	r31, 0x3e	; 62
    3d0c:	36 96       	adiw	r30, 0x06	; 6
    3d0e:	0f b6       	in	r0, 0x3f	; 63
    3d10:	f8 94       	cli
    3d12:	fe bf       	out	0x3e, r31	; 62
    3d14:	0f be       	out	0x3f, r0	; 63
    3d16:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    3d18:	2f 96       	adiw	r28, 0x0f	; 15
    3d1a:	0f b6       	in	r0, 0x3f	; 63
    3d1c:	f8 94       	cli
    3d1e:	de bf       	out	0x3e, r29	; 62
    3d20:	0f be       	out	0x3f, r0	; 63
    3d22:	cd bf       	out	0x3d, r28	; 61
    3d24:	cf 91       	pop	r28
    3d26:	df 91       	pop	r29
    3d28:	1f 91       	pop	r17
    3d2a:	0f 91       	pop	r16
    3d2c:	ff 90       	pop	r15
    3d2e:	ef 90       	pop	r14
    3d30:	df 90       	pop	r13
    3d32:	cf 90       	pop	r12
    3d34:	08 95       	ret

00003d36 <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    3d36:	ef 92       	push	r14
    3d38:	ff 92       	push	r15
    3d3a:	0f 93       	push	r16
    3d3c:	1f 93       	push	r17
    3d3e:	df 93       	push	r29
    3d40:	cf 93       	push	r28
    3d42:	00 d0       	rcall	.+0      	; 0x3d44 <PrintStandalone+0xe>
    3d44:	00 d0       	rcall	.+0      	; 0x3d46 <PrintStandalone+0x10>
    3d46:	00 d0       	rcall	.+0      	; 0x3d48 <PrintStandalone+0x12>
    3d48:	cd b7       	in	r28, 0x3d	; 61
    3d4a:	de b7       	in	r29, 0x3e	; 62
    3d4c:	f8 2e       	mov	r15, r24
    3d4e:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    3d50:	0e 94 ae 1b 	call	0x375c	; 0x375c <GetPumpID>
    3d54:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    3d56:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
    3d5a:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    3d5c:	88 23       	and	r24, r24
    3d5e:	99 f1       	breq	.+102    	; 0x3dc6 <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    3d60:	01 30       	cpi	r16, 0x01	; 1
    3d62:	69 f0       	breq	.+26     	; 0x3d7e <PrintStandalone+0x48>
    3d64:	ee 20       	and	r14, r14
    3d66:	79 f1       	breq	.+94     	; 0x3dc6 <PrintStandalone+0x90>
    3d68:	80 e1       	ldi	r24, 0x10	; 16
    3d6a:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    3d6e:	11 50       	subi	r17, 0x01	; 1
    3d70:	e1 2f       	mov	r30, r17
    3d72:	f0 e0       	ldi	r31, 0x00	; 0
    3d74:	e9 5d       	subi	r30, 0xD9	; 217
    3d76:	fe 4f       	sbci	r31, 0xFE	; 254
    3d78:	90 81       	ld	r25, Z
    3d7a:	98 17       	cp	r25, r24
    3d7c:	21 f5       	brne	.+72     	; 0x3dc6 <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3d7e:	66 e0       	ldi	r22, 0x06	; 6
    3d80:	f6 9e       	mul	r15, r22
    3d82:	b0 01       	movw	r22, r0
    3d84:	11 24       	eor	r1, r1
    3d86:	61 5b       	subi	r22, 0xB1	; 177
    3d88:	7f 4f       	sbci	r23, 0xFF	; 255
    3d8a:	ce 01       	movw	r24, r28
    3d8c:	01 96       	adiw	r24, 0x01	; 1
    3d8e:	46 e0       	ldi	r20, 0x06	; 6
    3d90:	50 e0       	ldi	r21, 0x00	; 0
    3d92:	27 e9       	ldi	r18, 0x97	; 151
    3d94:	32 e1       	ldi	r19, 0x12	; 18
    3d96:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    3d9a:	ef 2d       	mov	r30, r15
    3d9c:	f0 e0       	ldi	r31, 0x00	; 0
    3d9e:	e9 56       	subi	r30, 0x69	; 105
    3da0:	fe 4f       	sbci	r31, 0xFE	; 254
    3da2:	80 81       	ld	r24, Z
    3da4:	81 30       	cpi	r24, 0x01	; 1
    3da6:	19 f0       	breq	.+6      	; 0x3dae <PrintStandalone+0x78>
    3da8:	00 23       	and	r16, r16
    3daa:	29 f0       	breq	.+10     	; 0x3db6 <PrintStandalone+0x80>
    3dac:	0c c0       	rjmp	.+24     	; 0x3dc6 <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    3dae:	01 30       	cpi	r16, 0x01	; 1
    3db0:	11 f4       	brne	.+4      	; 0x3db6 <PrintStandalone+0x80>
    3db2:	00 93 a8 01 	sts	0x01A8, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    3db6:	8e 2d       	mov	r24, r14
    3db8:	be 01       	movw	r22, r28
    3dba:	6f 5f       	subi	r22, 0xFF	; 255
    3dbc:	7f 4f       	sbci	r23, 0xFF	; 255
    3dbe:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <GenerateStandaloneTransData>
    3dc2:	81 e1       	ldi	r24, 0x11	; 17
    3dc4:	01 c0       	rjmp	.+2      	; 0x3dc8 <PrintStandalone+0x92>
    3dc6:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    3dc8:	26 96       	adiw	r28, 0x06	; 6
    3dca:	0f b6       	in	r0, 0x3f	; 63
    3dcc:	f8 94       	cli
    3dce:	de bf       	out	0x3e, r29	; 62
    3dd0:	0f be       	out	0x3f, r0	; 63
    3dd2:	cd bf       	out	0x3d, r28	; 61
    3dd4:	cf 91       	pop	r28
    3dd6:	df 91       	pop	r29
    3dd8:	1f 91       	pop	r17
    3dda:	0f 91       	pop	r16
    3ddc:	ff 90       	pop	r15
    3dde:	ef 90       	pop	r14
    3de0:	08 95       	ret

00003de2 <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    3de2:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    3de4:	dc 01       	movw	r26, r24
    3de6:	0d 90       	ld	r0, X+
    3de8:	00 20       	and	r0, r0
    3dea:	e9 f7       	brne	.-6      	; 0x3de6 <SumChecksum+0x4>
    3dec:	11 97       	sbiw	r26, 0x01	; 1
    3dee:	a8 1b       	sub	r26, r24
    3df0:	b9 0b       	sbc	r27, r25
    3df2:	20 e0       	ldi	r18, 0x00	; 0
    3df4:	30 e0       	ldi	r19, 0x00	; 0
    3df6:	90 e0       	ldi	r25, 0x00	; 0
    3df8:	06 c0       	rjmp	.+12     	; 0x3e06 <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    3dfa:	e4 0f       	add	r30, r20
    3dfc:	f5 1f       	adc	r31, r21
    3dfe:	80 81       	ld	r24, Z
    3e00:	28 0f       	add	r18, r24
    3e02:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    3e04:	9f 5f       	subi	r25, 0xFF	; 255
    3e06:	e9 2f       	mov	r30, r25
    3e08:	f0 e0       	ldi	r31, 0x00	; 0
    3e0a:	ea 17       	cp	r30, r26
    3e0c:	fb 07       	cpc	r31, r27
    3e0e:	a8 f3       	brcs	.-22     	; 0x3dfa <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    3e10:	c9 01       	movw	r24, r18
    3e12:	6f ef       	ldi	r22, 0xFF	; 255
    3e14:	70 e0       	ldi	r23, 0x00	; 0
    3e16:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
	 if (Result==0)Result=255;
    3e1a:	88 23       	and	r24, r24
    3e1c:	09 f4       	brne	.+2      	; 0x3e20 <SumChecksum+0x3e>
    3e1e:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    3e20:	08 95       	ret

00003e22 <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    3e22:	ff 92       	push	r15
    3e24:	0f 93       	push	r16
    3e26:	1f 93       	push	r17
    3e28:	df 93       	push	r29
    3e2a:	cf 93       	push	r28
    3e2c:	cd b7       	in	r28, 0x3d	; 61
    3e2e:	de b7       	in	r29, 0x3e	; 62
    3e30:	2a 97       	sbiw	r28, 0x0a	; 10
    3e32:	0f b6       	in	r0, 0x3f	; 63
    3e34:	f8 94       	cli
    3e36:	de bf       	out	0x3e, r29	; 62
    3e38:	0f be       	out	0x3f, r0	; 63
    3e3a:	cd bf       	out	0x3d, r28	; 61
    3e3c:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    3e3e:	00 d0       	rcall	.+0      	; 0x3e40 <IsGeniusCommand+0x1e>
    3e40:	00 d0       	rcall	.+0      	; 0x3e42 <IsGeniusCommand+0x20>
    3e42:	8e 01       	movw	r16, r28
    3e44:	0f 5f       	subi	r16, 0xFF	; 255
    3e46:	1f 4f       	sbci	r17, 0xFF	; 255
    3e48:	ed b7       	in	r30, 0x3d	; 61
    3e4a:	fe b7       	in	r31, 0x3e	; 62
    3e4c:	12 83       	std	Z+2, r17	; 0x02
    3e4e:	01 83       	std	Z+1, r16	; 0x01
    3e50:	83 ef       	ldi	r24, 0xF3	; 243
    3e52:	93 e0       	ldi	r25, 0x03	; 3
    3e54:	94 83       	std	Z+4, r25	; 0x04
    3e56:	83 83       	std	Z+3, r24	; 0x03
    3e58:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    3e5c:	d8 01       	movw	r26, r16
    3e5e:	0d 90       	ld	r0, X+
    3e60:	00 20       	and	r0, r0
    3e62:	e9 f7       	brne	.-6      	; 0x3e5e <IsGeniusCommand+0x3c>
    3e64:	11 97       	sbiw	r26, 0x01	; 1
    3e66:	a0 1b       	sub	r26, r16
    3e68:	b1 0b       	sbc	r27, r17
    3e6a:	90 e0       	ldi	r25, 0x00	; 0
    3e6c:	0f 90       	pop	r0
    3e6e:	0f 90       	pop	r0
    3e70:	0f 90       	pop	r0
    3e72:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    3e74:	98 01       	movw	r18, r16
    3e76:	08 c0       	rjmp	.+16     	; 0x3e88 <IsGeniusCommand+0x66>
    3e78:	e2 0f       	add	r30, r18
    3e7a:	f3 1f       	adc	r31, r19
    3e7c:	80 81       	ld	r24, Z
    3e7e:	8f 15       	cp	r24, r15
    3e80:	11 f4       	brne	.+4      	; 0x3e86 <IsGeniusCommand+0x64>
    3e82:	81 e0       	ldi	r24, 0x01	; 1
    3e84:	07 c0       	rjmp	.+14     	; 0x3e94 <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    3e86:	9f 5f       	subi	r25, 0xFF	; 255
    3e88:	e9 2f       	mov	r30, r25
    3e8a:	f0 e0       	ldi	r31, 0x00	; 0
    3e8c:	ea 17       	cp	r30, r26
    3e8e:	fb 07       	cpc	r31, r27
    3e90:	98 f3       	brcs	.-26     	; 0x3e78 <IsGeniusCommand+0x56>
    3e92:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    3e94:	2a 96       	adiw	r28, 0x0a	; 10
    3e96:	0f b6       	in	r0, 0x3f	; 63
    3e98:	f8 94       	cli
    3e9a:	de bf       	out	0x3e, r29	; 62
    3e9c:	0f be       	out	0x3f, r0	; 63
    3e9e:	cd bf       	out	0x3d, r28	; 61
    3ea0:	cf 91       	pop	r28
    3ea2:	df 91       	pop	r29
    3ea4:	1f 91       	pop	r17
    3ea6:	0f 91       	pop	r16
    3ea8:	ff 90       	pop	r15
    3eaa:	08 95       	ret

00003eac <Pos>:
  return Result;
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    3eac:	0f 93       	push	r16
    3eae:	1f 93       	push	r17
    3eb0:	cf 93       	push	r28
    3eb2:	df 93       	push	r29
    3eb4:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    3eb6:	fb 01       	movw	r30, r22
    3eb8:	01 90       	ld	r0, Z+
    3eba:	00 20       	and	r0, r0
    3ebc:	e9 f7       	brne	.-6      	; 0x3eb8 <Pos+0xc>
    3ebe:	31 97       	sbiw	r30, 0x01	; 1
    3ec0:	1e 2f       	mov	r17, r30
    3ec2:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    3ec4:	fc 01       	movw	r30, r24
    3ec6:	01 90       	ld	r0, Z+
    3ec8:	00 20       	and	r0, r0
    3eca:	e9 f7       	brne	.-6      	; 0x3ec6 <Pos+0x1a>
    3ecc:	31 97       	sbiw	r30, 0x01	; 1
    3ece:	0e 2f       	mov	r16, r30
    3ed0:	08 1b       	sub	r16, r24
    3ed2:	db 01       	movw	r26, r22
    3ed4:	60 e0       	ldi	r22, 0x00	; 0
    3ed6:	18 c0       	rjmp	.+48     	; 0x3f08 <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    3ed8:	9c 91       	ld	r25, X
    3eda:	fa 01       	movw	r30, r20
    3edc:	80 81       	ld	r24, Z
    3ede:	98 17       	cp	r25, r24
    3ee0:	89 f4       	brne	.+34     	; 0x3f04 <Pos+0x58>
    3ee2:	ed 01       	movw	r28, r26
    3ee4:	20 e0       	ldi	r18, 0x00	; 0
    3ee6:	30 e0       	ldi	r19, 0x00	; 0
    3ee8:	09 c0       	rjmp	.+18     	; 0x3efc <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    3eea:	fa 01       	movw	r30, r20
    3eec:	e2 0f       	add	r30, r18
    3eee:	f3 1f       	adc	r31, r19
    3ef0:	90 81       	ld	r25, Z
    3ef2:	89 91       	ld	r24, Y+
    3ef4:	2f 5f       	subi	r18, 0xFF	; 255
    3ef6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ef8:	98 17       	cp	r25, r24
    3efa:	21 f4       	brne	.+8      	; 0x3f04 <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    3efc:	20 17       	cp	r18, r16
    3efe:	a8 f3       	brcs	.-22     	; 0x3eea <Pos+0x3e>
    3f00:	86 2f       	mov	r24, r22
    3f02:	05 c0       	rjmp	.+10     	; 0x3f0e <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    3f04:	6f 5f       	subi	r22, 0xFF	; 255
    3f06:	11 96       	adiw	r26, 0x01	; 1
    3f08:	61 17       	cp	r22, r17
    3f0a:	30 f3       	brcs	.-52     	; 0x3ed8 <Pos+0x2c>
    3f0c:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    3f0e:	90 e0       	ldi	r25, 0x00	; 0
    3f10:	df 91       	pop	r29
    3f12:	cf 91       	pop	r28
    3f14:	1f 91       	pop	r17
    3f16:	0f 91       	pop	r16
    3f18:	08 95       	ret

00003f1a <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    3f1a:	7f 92       	push	r7
    3f1c:	8f 92       	push	r8
    3f1e:	9f 92       	push	r9
    3f20:	af 92       	push	r10
    3f22:	bf 92       	push	r11
    3f24:	cf 92       	push	r12
    3f26:	df 92       	push	r13
    3f28:	ef 92       	push	r14
    3f2a:	ff 92       	push	r15
    3f2c:	0f 93       	push	r16
    3f2e:	1f 93       	push	r17
    3f30:	cf 93       	push	r28
    3f32:	df 93       	push	r29
    3f34:	5c 01       	movw	r10, r24
    3f36:	6b 01       	movw	r12, r22
    3f38:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    3f3a:	ec 01       	movw	r28, r24
    3f3c:	09 90       	ld	r0, Y+
    3f3e:	00 20       	and	r0, r0
    3f40:	e9 f7       	brne	.-6      	; 0x3f3c <CreateReport+0x22>
    3f42:	21 97       	sbiw	r28, 0x01	; 1
    3f44:	c8 1b       	sub	r28, r24
    3f46:	d9 0b       	sbc	r29, r25
    3f48:	cb 32       	cpi	r28, 0x2B	; 43
    3f4a:	d1 05       	cpc	r29, r1
    3f4c:	10 f0       	brcs	.+4      	; 0x3f52 <CreateReport+0x38>
    3f4e:	ca e2       	ldi	r28, 0x2A	; 42
    3f50:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    3f52:	f4 01       	movw	r30, r8
    3f54:	00 81       	ld	r16, Z
    3f56:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    3f58:	76 01       	movw	r14, r12
    3f5a:	e0 0e       	add	r14, r16
    3f5c:	f1 1e       	adc	r15, r17
    3f5e:	8a e0       	ldi	r24, 0x0A	; 10
    3f60:	0e 94 58 19 	call	0x32b0	; 0x32b0 <GetBorderValue>
    3f64:	78 2e       	mov	r7, r24
    3f66:	f7 01       	movw	r30, r14
    3f68:	80 83       	st	Z, r24
     iPos++;
    3f6a:	98 01       	movw	r18, r16
    3f6c:	2f 5f       	subi	r18, 0xFF	; 255
    3f6e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f70:	d7 01       	movw	r26, r14
    3f72:	90 e0       	ldi	r25, 0x00	; 0
    3f74:	07 c0       	rjmp	.+14     	; 0x3f84 <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    3f76:	ea 0d       	add	r30, r10
    3f78:	fb 1d       	adc	r31, r11
    3f7a:	80 81       	ld	r24, Z
    3f7c:	8c 93       	st	X, r24
		  iPos++;
    3f7e:	2f 5f       	subi	r18, 0xFF	; 255
    3f80:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    3f82:	9f 5f       	subi	r25, 0xFF	; 255
    3f84:	e9 2f       	mov	r30, r25
    3f86:	f0 e0       	ldi	r31, 0x00	; 0
    3f88:	11 96       	adiw	r26, 0x01	; 1
    3f8a:	ec 17       	cp	r30, r28
    3f8c:	fd 07       	cpc	r31, r29
    3f8e:	98 f3       	brcs	.-26     	; 0x3f76 <CreateReport+0x5c>
    3f90:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    3f92:	ca 32       	cpi	r28, 0x2A	; 42
    3f94:	d1 05       	cpc	r29, r1
    3f96:	91 f0       	breq	.+36     	; 0x3fbc <CreateReport+0xa2>
    3f98:	f6 01       	movw	r30, r12
    3f9a:	e2 0f       	add	r30, r18
    3f9c:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    3f9e:	4a e2       	ldi	r20, 0x2A	; 42
    3fa0:	50 e0       	ldi	r21, 0x00	; 0
    3fa2:	4c 1b       	sub	r20, r28
    3fa4:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    3fa6:	70 e2       	ldi	r23, 0x20	; 32
    3fa8:	03 c0       	rjmp	.+6      	; 0x3fb0 <CreateReport+0x96>
    3faa:	71 93       	st	Z+, r23
		      iPos++;
    3fac:	2f 5f       	subi	r18, 0xFF	; 255
    3fae:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    3fb0:	82 2f       	mov	r24, r18
    3fb2:	86 1b       	sub	r24, r22
    3fb4:	90 e0       	ldi	r25, 0x00	; 0
    3fb6:	84 17       	cp	r24, r20
    3fb8:	95 07       	cpc	r25, r21
    3fba:	b8 f3       	brcs	.-18     	; 0x3faa <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    3fbc:	f6 01       	movw	r30, r12
    3fbe:	e2 0f       	add	r30, r18
    3fc0:	f3 1f       	adc	r31, r19
    3fc2:	70 82       	st	Z, r7
     iPos++;
    3fc4:	c9 01       	movw	r24, r18
    3fc6:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    3fc8:	c8 0e       	add	r12, r24
    3fca:	d9 1e       	adc	r13, r25
    3fcc:	2d e0       	ldi	r18, 0x0D	; 13
    3fce:	f6 01       	movw	r30, r12
    3fd0:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    3fd2:	01 96       	adiw	r24, 0x01	; 1
    3fd4:	f4 01       	movw	r30, r8
    3fd6:	91 83       	std	Z+1, r25	; 0x01
    3fd8:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}
    3fda:	df 91       	pop	r29
    3fdc:	cf 91       	pop	r28
    3fde:	1f 91       	pop	r17
    3fe0:	0f 91       	pop	r16
    3fe2:	ff 90       	pop	r15
    3fe4:	ef 90       	pop	r14
    3fe6:	df 90       	pop	r13
    3fe8:	cf 90       	pop	r12
    3fea:	bf 90       	pop	r11
    3fec:	af 90       	pop	r10
    3fee:	9f 90       	pop	r9
    3ff0:	8f 90       	pop	r8
    3ff2:	7f 90       	pop	r7
    3ff4:	08 95       	ret

00003ff6 <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    3ff6:	38 2f       	mov	r19, r24
    3ff8:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    3ffa:	81 50       	subi	r24, 0x01	; 1
    3ffc:	86 30       	cpi	r24, 0x06	; 6
    3ffe:	68 f5       	brcc	.+90     	; 0x405a <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    4000:	fb 01       	movw	r30, r22
    4002:	01 90       	ld	r0, Z+
    4004:	00 20       	and	r0, r0
    4006:	e9 f7       	brne	.-6      	; 0x4002 <AddList+0xc>
    4008:	31 97       	sbiw	r30, 0x01	; 1
    400a:	e6 1b       	sub	r30, r22
    400c:	f7 0b       	sbc	r31, r23
    400e:	7e 2f       	mov	r23, r30
	     if (Length>0){
    4010:	ee 23       	and	r30, r30
    4012:	11 f4       	brne	.+4      	; 0x4018 <AddList+0x22>
    4014:	20 e0       	ldi	r18, 0x00	; 0
    4016:	14 c0       	rjmp	.+40     	; 0x4040 <AddList+0x4a>
    4018:	80 e0       	ldi	r24, 0x00	; 0
    401a:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    401c:	63 2f       	mov	r22, r19
    401e:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4020:	fa 01       	movw	r30, r20
    4022:	e8 0f       	add	r30, r24
    4024:	f9 1f       	adc	r31, r25
    4026:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4028:	3a 30       	cpi	r19, 0x0A	; 10
    402a:	10 f0       	brcs	.+4      	; 0x4030 <AddList+0x3a>
    402c:	20 e3       	ldi	r18, 0x30	; 48
    402e:	01 c0       	rjmp	.+2      	; 0x4032 <AddList+0x3c>
	    Result='0'+X;
    4030:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4032:	e2 17       	cp	r30, r18
    4034:	91 f0       	breq	.+36     	; 0x405a <AddList+0x64>
    4036:	28 2f       	mov	r18, r24
    4038:	2f 5f       	subi	r18, 0xFF	; 255
    403a:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    403c:	87 17       	cp	r24, r23
    403e:	80 f3       	brcs	.-32     	; 0x4020 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4040:	62 2f       	mov	r22, r18
    4042:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4044:	3a 30       	cpi	r19, 0x0A	; 10
    4046:	10 f0       	brcs	.+4      	; 0x404c <AddList+0x56>
    4048:	80 e3       	ldi	r24, 0x30	; 48
    404a:	02 c0       	rjmp	.+4      	; 0x4050 <AddList+0x5a>
	    Result='0'+X;
    404c:	83 2f       	mov	r24, r19
    404e:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4050:	fa 01       	movw	r30, r20
    4052:	e6 0f       	add	r30, r22
    4054:	f7 1f       	adc	r31, r23
    4056:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    4058:	11 82       	std	Z+1, r1	; 0x01
    405a:	08 95       	ret

0000405c <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    405c:	dc 01       	movw	r26, r24
    405e:	0d 90       	ld	r0, X+
    4060:	00 20       	and	r0, r0
    4062:	e9 f7       	brne	.-6      	; 0x405e <ClearList+0x2>
    4064:	11 97       	sbiw	r26, 0x01	; 1
    4066:	a8 1b       	sub	r26, r24
    4068:	b9 0b       	sbc	r27, r25
    406a:	20 e0       	ldi	r18, 0x00	; 0
    406c:	30 e0       	ldi	r19, 0x00	; 0
    406e:	06 c0       	rjmp	.+12     	; 0x407c <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4070:	fc 01       	movw	r30, r24
    4072:	e2 0f       	add	r30, r18
    4074:	f3 1f       	adc	r31, r19
    4076:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4078:	2f 5f       	subi	r18, 0xFF	; 255
    407a:	3f 4f       	sbci	r19, 0xFF	; 255
    407c:	2a 17       	cp	r18, r26
    407e:	3b 07       	cpc	r19, r27
    4080:	b8 f3       	brcs	.-18     	; 0x4070 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    4082:	08 95       	ret

00004084 <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    4084:	6f 92       	push	r6
    4086:	7f 92       	push	r7
    4088:	8f 92       	push	r8
    408a:	9f 92       	push	r9
    408c:	bf 92       	push	r11
    408e:	cf 92       	push	r12
    4090:	df 92       	push	r13
    4092:	ef 92       	push	r14
    4094:	ff 92       	push	r15
    4096:	0f 93       	push	r16
    4098:	1f 93       	push	r17
    409a:	df 93       	push	r29
    409c:	cf 93       	push	r28
    409e:	cd b7       	in	r28, 0x3d	; 61
    40a0:	de b7       	in	r29, 0x3e	; 62
    40a2:	64 97       	sbiw	r28, 0x14	; 20
    40a4:	0f b6       	in	r0, 0x3f	; 63
    40a6:	f8 94       	cli
    40a8:	de bf       	out	0x3e, r29	; 62
    40aa:	0f be       	out	0x3f, r0	; 63
    40ac:	cd bf       	out	0x3d, r28	; 61
    40ae:	7c 01       	movw	r14, r24
    40b0:	6a 01       	movw	r12, r20
    40b2:	bb 24       	eor	r11, r11
    40b4:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    40b6:	06 2f       	mov	r16, r22
    40b8:	10 e0       	ldi	r17, 0x00	; 0
    40ba:	00 53       	subi	r16, 0x30	; 48
    40bc:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    40be:	3e 01       	movw	r6, r28
    40c0:	08 94       	sec
    40c2:	61 1c       	adc	r6, r1
    40c4:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    40c6:	62 e0       	ldi	r22, 0x02	; 2
    40c8:	86 2e       	mov	r8, r22
    40ca:	91 2c       	mov	r9, r1
    40cc:	8c 0e       	add	r8, r28
    40ce:	9d 1e       	adc	r9, r29
    40d0:	24 c0       	rjmp	.+72     	; 0x411a <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    40d2:	11 97       	sbiw	r26, 0x01	; 1
    40d4:	a4 1b       	sub	r26, r20
    40d6:	b5 0b       	sbc	r27, r21
    40d8:	ae 0d       	add	r26, r14
    40da:	bf 1d       	adc	r27, r15
    40dc:	8c 91       	ld	r24, X
    40de:	90 e0       	ldi	r25, 0x00	; 0
    40e0:	c0 97       	sbiw	r24, 0x30	; 48
    40e2:	bc 01       	movw	r22, r24
    40e4:	60 9f       	mul	r22, r16
    40e6:	c0 01       	movw	r24, r0
    40e8:	61 9f       	mul	r22, r17
    40ea:	90 0d       	add	r25, r0
    40ec:	70 9f       	mul	r23, r16
    40ee:	90 0d       	add	r25, r0
    40f0:	11 24       	eor	r1, r1
    40f2:	23 2f       	mov	r18, r19
    40f4:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    40f6:	82 2f       	mov	r24, r18
    40f8:	6a e0       	ldi	r22, 0x0A	; 10
    40fa:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    40fe:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    4100:	f3 01       	movw	r30, r6
    4102:	e4 0f       	add	r30, r20
    4104:	f5 1f       	adc	r31, r21
    4106:	82 2f       	mov	r24, r18
    4108:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    410c:	90 5d       	subi	r25, 0xD0	; 208
    410e:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4110:	48 0d       	add	r20, r8
    4112:	59 1d       	adc	r21, r9
    4114:	fa 01       	movw	r30, r20
    4116:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    4118:	b3 94       	inc	r11
    411a:	4b 2d       	mov	r20, r11
    411c:	50 e0       	ldi	r21, 0x00	; 0
    411e:	d7 01       	movw	r26, r14
    4120:	0d 90       	ld	r0, X+
    4122:	00 20       	and	r0, r0
    4124:	e9 f7       	brne	.-6      	; 0x4120 <CalcSegmen+0x9c>
    4126:	11 97       	sbiw	r26, 0x01	; 1
    4128:	ae 19       	sub	r26, r14
    412a:	bf 09       	sbc	r27, r15
    412c:	4a 17       	cp	r20, r26
    412e:	5b 07       	cpc	r21, r27
    4130:	80 f2       	brcs	.-96     	; 0x40d2 <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    4132:	33 23       	and	r19, r19
    4134:	89 f0       	breq	.+34     	; 0x4158 <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    4136:	fe 01       	movw	r30, r28
    4138:	31 96       	adiw	r30, 0x01	; 1
    413a:	df 01       	movw	r26, r30
    413c:	0d 90       	ld	r0, X+
    413e:	00 20       	and	r0, r0
    4140:	e9 f7       	brne	.-6      	; 0x413c <CalcSegmen+0xb8>
    4142:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    4144:	ae 1b       	sub	r26, r30
    4146:	b0 e0       	ldi	r27, 0x00	; 0
    4148:	ea 0f       	add	r30, r26
    414a:	fb 1f       	adc	r31, r27
    414c:	30 5d       	subi	r19, 0xD0	; 208
    414e:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4150:	ac 0f       	add	r26, r28
    4152:	bd 1f       	adc	r27, r29
    4154:	12 96       	adiw	r26, 0x02	; 2
    4156:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    4158:	de 01       	movw	r26, r28
    415a:	11 96       	adiw	r26, 0x01	; 1
    415c:	fd 01       	movw	r30, r26
    415e:	01 90       	ld	r0, Z+
    4160:	00 20       	and	r0, r0
    4162:	e9 f7       	brne	.-6      	; 0x415e <CalcSegmen+0xda>
    4164:	31 97       	sbiw	r30, 0x01	; 1
    4166:	9e 2f       	mov	r25, r30
    4168:	9a 1b       	sub	r25, r26
    416a:	a9 0f       	add	r26, r25
    416c:	b1 1d       	adc	r27, r1
    416e:	f6 01       	movw	r30, r12
    4170:	02 c0       	rjmp	.+4      	; 0x4176 <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    4172:	8c 91       	ld	r24, X
    4174:	81 93       	st	Z+, r24
    4176:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    4178:	ac 17       	cp	r26, r28
    417a:	bd 07       	cpc	r27, r29
    417c:	d1 f7       	brne	.-12     	; 0x4172 <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    417e:	c9 0e       	add	r12, r25
    4180:	d1 1c       	adc	r13, r1
    4182:	f6 01       	movw	r30, r12
    4184:	10 82       	st	Z, r1
}
    4186:	64 96       	adiw	r28, 0x14	; 20
    4188:	0f b6       	in	r0, 0x3f	; 63
    418a:	f8 94       	cli
    418c:	de bf       	out	0x3e, r29	; 62
    418e:	0f be       	out	0x3f, r0	; 63
    4190:	cd bf       	out	0x3d, r28	; 61
    4192:	cf 91       	pop	r28
    4194:	df 91       	pop	r29
    4196:	1f 91       	pop	r17
    4198:	0f 91       	pop	r16
    419a:	ff 90       	pop	r15
    419c:	ef 90       	pop	r14
    419e:	df 90       	pop	r13
    41a0:	cf 90       	pop	r12
    41a2:	bf 90       	pop	r11
    41a4:	9f 90       	pop	r9
    41a6:	8f 90       	pop	r8
    41a8:	7f 90       	pop	r7
    41aa:	6f 90       	pop	r6
    41ac:	08 95       	ret

000041ae <GetMinusPos>:
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
}

char GetMinusPos(char *strNumber){
    41ae:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    41b0:	dc 01       	movw	r26, r24
    41b2:	0d 90       	ld	r0, X+
    41b4:	00 20       	and	r0, r0
    41b6:	e9 f7       	brne	.-6      	; 0x41b2 <GetMinusPos+0x4>
    41b8:	11 97       	sbiw	r26, 0x01	; 1
    41ba:	a8 1b       	sub	r26, r24
    41bc:	b9 0b       	sbc	r27, r25
    41be:	20 e0       	ldi	r18, 0x00	; 0
    41c0:	0a c0       	rjmp	.+20     	; 0x41d6 <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    41c2:	e4 0f       	add	r30, r20
    41c4:	f5 1f       	adc	r31, r21
    41c6:	80 81       	ld	r24, Z
    41c8:	92 2f       	mov	r25, r18
    41ca:	9f 5f       	subi	r25, 0xFF	; 255
    41cc:	8d 32       	cpi	r24, 0x2D	; 45
    41ce:	11 f4       	brne	.+4      	; 0x41d4 <GetMinusPos+0x26>
		     Result=i+1;
    41d0:	89 2f       	mov	r24, r25
    41d2:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    41d4:	29 2f       	mov	r18, r25
    41d6:	e2 2f       	mov	r30, r18
    41d8:	f0 e0       	ldi	r31, 0x00	; 0
    41da:	ea 17       	cp	r30, r26
    41dc:	fb 07       	cpc	r31, r27
    41de:	88 f3       	brcs	.-30     	; 0x41c2 <GetMinusPos+0x14>
    41e0:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    41e2:	08 95       	ret

000041e4 <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    41e4:	0e 94 d7 20 	call	0x41ae	; 0x41ae <GetMinusPos>
    41e8:	81 11       	cpse	r24, r1
    41ea:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    41ec:	08 95       	ret

000041ee <RemoveMinus>:

void RemoveMinus(char *strNumber){
    41ee:	cf 93       	push	r28
    41f0:	df 93       	push	r29
    41f2:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    41f4:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <IsMinus>
    41f8:	81 30       	cpi	r24, 0x01	; 1
    41fa:	19 f5       	brne	.+70     	; 0x4242 <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    41fc:	ce 01       	movw	r24, r28
    41fe:	0e 94 d7 20 	call	0x41ae	; 0x41ae <GetMinusPos>
		 Length=strlen(strNumber);
    4202:	de 01       	movw	r26, r28
    4204:	0d 90       	ld	r0, X+
    4206:	00 20       	and	r0, r0
    4208:	e9 f7       	brne	.-6      	; 0x4204 <RemoveMinus+0x16>
    420a:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    420c:	ac 1b       	sub	r26, r28
    420e:	b0 e0       	ldi	r27, 0x00	; 0
    4210:	90 e0       	ldi	r25, 0x00	; 0
    4212:	a8 1b       	sub	r26, r24
    4214:	b9 0b       	sbc	r27, r25
    4216:	ae 01       	movw	r20, r28
    4218:	48 0f       	add	r20, r24
    421a:	59 1f       	adc	r21, r25
    421c:	20 e0       	ldi	r18, 0x00	; 0
    421e:	30 e0       	ldi	r19, 0x00	; 0
    4220:	0a c0       	rjmp	.+20     	; 0x4236 <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4222:	be 01       	movw	r22, r28
    4224:	62 0f       	add	r22, r18
    4226:	73 1f       	adc	r23, r19
    4228:	fa 01       	movw	r30, r20
    422a:	81 91       	ld	r24, Z+
    422c:	af 01       	movw	r20, r30
    422e:	fb 01       	movw	r30, r22
    4230:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4232:	2f 5f       	subi	r18, 0xFF	; 255
    4234:	3f 4f       	sbci	r19, 0xFF	; 255
    4236:	2a 17       	cp	r18, r26
    4238:	3b 07       	cpc	r19, r27
    423a:	98 f3       	brcs	.-26     	; 0x4222 <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    423c:	ac 0f       	add	r26, r28
    423e:	bd 1f       	adc	r27, r29
    4240:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    4242:	df 91       	pop	r29
    4244:	cf 91       	pop	r28
    4246:	08 95       	ret

00004248 <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    4248:	ac 01       	movw	r20, r24
    424a:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    424c:	fc 01       	movw	r30, r24
    424e:	01 90       	ld	r0, Z+
    4250:	00 20       	and	r0, r0
    4252:	e9 f7       	brne	.-6      	; 0x424e <IsMoreThan+0x6>
    4254:	31 97       	sbiw	r30, 0x01	; 1
    4256:	7e 2f       	mov	r23, r30
    4258:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    425a:	a6 2f       	mov	r26, r22
    425c:	b2 2f       	mov	r27, r18
    425e:	fd 01       	movw	r30, r26
    4260:	01 90       	ld	r0, Z+
    4262:	00 20       	and	r0, r0
    4264:	e9 f7       	brne	.-6      	; 0x4260 <IsMoreThan+0x18>
    4266:	31 97       	sbiw	r30, 0x01	; 1
    4268:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    426a:	e7 17       	cp	r30, r23
    426c:	48 f1       	brcs	.+82     	; 0x42c0 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    426e:	7e 17       	cp	r23, r30
    4270:	49 f5       	brne	.+82     	; 0x42c4 <IsMoreThan+0x7c>
    4272:	86 2f       	mov	r24, r22
    4274:	92 2f       	mov	r25, r18
    4276:	9c 01       	movw	r18, r24
    4278:	d9 01       	movw	r26, r18
    427a:	20 e0       	ldi	r18, 0x00	; 0
    427c:	30 e0       	ldi	r19, 0x00	; 0
    427e:	1d c0       	rjmp	.+58     	; 0x42ba <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4280:	fa 01       	movw	r30, r20
    4282:	e2 0f       	add	r30, r18
    4284:	f3 1f       	adc	r31, r19
    4286:	e0 81       	ld	r30, Z
    4288:	e0 53       	subi	r30, 0x30	; 48
    428a:	ea 30       	cpi	r30, 0x0A	; 10
    428c:	10 f0       	brcs	.+4      	; 0x4292 <IsMoreThan+0x4a>
    428e:	60 e0       	ldi	r22, 0x00	; 0
    4290:	01 c0       	rjmp	.+2      	; 0x4294 <IsMoreThan+0x4c>
    4292:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    4294:	8c 91       	ld	r24, X
    4296:	80 53       	subi	r24, 0x30	; 48
    4298:	8a 30       	cpi	r24, 0x0A	; 10
    429a:	10 f0       	brcs	.+4      	; 0x42a0 <IsMoreThan+0x58>
    429c:	90 e0       	ldi	r25, 0x00	; 0
    429e:	01 c0       	rjmp	.+2      	; 0x42a2 <IsMoreThan+0x5a>
    42a0:	98 2f       	mov	r25, r24
    42a2:	96 17       	cp	r25, r22
    42a4:	68 f0       	brcs	.+26     	; 0x42c0 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    42a6:	ea 30       	cpi	r30, 0x0A	; 10
    42a8:	08 f0       	brcs	.+2      	; 0x42ac <IsMoreThan+0x64>
    42aa:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    42ac:	8a 30       	cpi	r24, 0x0A	; 10
    42ae:	10 f4       	brcc	.+4      	; 0x42b4 <IsMoreThan+0x6c>
    42b0:	e8 17       	cp	r30, r24
    42b2:	40 f0       	brcs	.+16     	; 0x42c4 <IsMoreThan+0x7c>
    42b4:	2f 5f       	subi	r18, 0xFF	; 255
    42b6:	3f 4f       	sbci	r19, 0xFF	; 255
    42b8:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    42ba:	27 17       	cp	r18, r23
    42bc:	08 f3       	brcs	.-62     	; 0x4280 <IsMoreThan+0x38>
    42be:	02 c0       	rjmp	.+4      	; 0x42c4 <IsMoreThan+0x7c>
    42c0:	81 e0       	ldi	r24, 0x01	; 1
    42c2:	08 95       	ret
    42c4:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    42c6:	08 95       	ret

000042c8 <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    42c8:	fc 01       	movw	r30, r24
    42ca:	01 90       	ld	r0, Z+
    42cc:	00 20       	and	r0, r0
    42ce:	e9 f7       	brne	.-6      	; 0x42ca <IsZerroAll+0x2>
    42d0:	31 97       	sbiw	r30, 0x01	; 1
    42d2:	e8 1b       	sub	r30, r24
    42d4:	dc 01       	movw	r26, r24
    42d6:	ae 0f       	add	r26, r30
    42d8:	b1 1d       	adc	r27, r1
    42da:	90 e0       	ldi	r25, 0x00	; 0
    42dc:	20 e0       	ldi	r18, 0x00	; 0
    42de:	06 c0       	rjmp	.+12     	; 0x42ec <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    42e0:	8c 91       	ld	r24, X
    42e2:	80 33       	cpi	r24, 0x30	; 48
    42e4:	09 f4       	brne	.+2      	; 0x42e8 <IsZerroAll+0x20>
    42e6:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    42e8:	9f 5f       	subi	r25, 0xFF	; 255
    42ea:	11 97       	sbiw	r26, 0x01	; 1
    42ec:	9e 17       	cp	r25, r30
    42ee:	c0 f3       	brcs	.-16     	; 0x42e0 <IsZerroAll+0x18>
    42f0:	80 e0       	ldi	r24, 0x00	; 0
    42f2:	2e 17       	cp	r18, r30
    42f4:	09 f4       	brne	.+2      	; 0x42f8 <IsZerroAll+0x30>
    42f6:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    42f8:	08 95       	ret

000042fa <PstrCopy>:
     _uart(_COM_PRINTER, 1, 0x0D);     
     _uart(_COM_PRINTER, 1, 0x0A);

}

void PstrCopy(char *Dest,char *Source){
    42fa:	cf 93       	push	r28
    42fc:	df 93       	push	r29
    42fe:	20 e0       	ldi	r18, 0x00	; 0
    4300:	08 c0       	rjmp	.+16     	; 0x4312 <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    4302:	fb 01       	movw	r30, r22
    4304:	ec 0f       	add	r30, r28
    4306:	fd 1f       	adc	r31, r29
    4308:	e4 91       	lpm	r30, Z+
    430a:	c8 0f       	add	r28, r24
    430c:	d9 1f       	adc	r29, r25
    430e:	e8 83       	st	Y, r30

}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4310:	2f 5f       	subi	r18, 0xFF	; 255
    4312:	c2 2f       	mov	r28, r18
    4314:	d0 e0       	ldi	r29, 0x00	; 0
    4316:	fb 01       	movw	r30, r22
    4318:	01 90       	ld	r0, Z+
    431a:	00 20       	and	r0, r0
    431c:	e9 f7       	brne	.-6      	; 0x4318 <PstrCopy+0x1e>
    431e:	31 97       	sbiw	r30, 0x01	; 1
    4320:	e6 1b       	sub	r30, r22
    4322:	f7 0b       	sbc	r31, r23
    4324:	ce 17       	cp	r28, r30
    4326:	df 07       	cpc	r29, r31
    4328:	60 f3       	brcs	.-40     	; 0x4302 <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    432a:	df 91       	pop	r29
    432c:	cf 91       	pop	r28
    432e:	08 95       	ret

00004330 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4330:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4332:	dc 01       	movw	r26, r24
    4334:	0d 90       	ld	r0, X+
    4336:	00 20       	and	r0, r0
    4338:	e9 f7       	brne	.-6      	; 0x4334 <SpaceOnly+0x4>
    433a:	11 97       	sbiw	r26, 0x01	; 1
    433c:	a8 1b       	sub	r26, r24
    433e:	b9 0b       	sbc	r27, r25
    4340:	90 e0       	ldi	r25, 0x00	; 0
    4342:	20 e0       	ldi	r18, 0x00	; 0
    4344:	30 e0       	ldi	r19, 0x00	; 0
    4346:	09 c0       	rjmp	.+18     	; 0x435a <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    4348:	fa 01       	movw	r30, r20
    434a:	e2 0f       	add	r30, r18
    434c:	f3 1f       	adc	r31, r19
    434e:	80 81       	ld	r24, Z
    4350:	80 32       	cpi	r24, 0x20	; 32
    4352:	09 f0       	breq	.+2      	; 0x4356 <SpaceOnly+0x26>
    4354:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4356:	2f 5f       	subi	r18, 0xFF	; 255
    4358:	3f 4f       	sbci	r19, 0xFF	; 255
    435a:	2a 17       	cp	r18, r26
    435c:	3b 07       	cpc	r19, r27
    435e:	a0 f3       	brcs	.-24     	; 0x4348 <SpaceOnly+0x18>
    4360:	80 e0       	ldi	r24, 0x00	; 0
    4362:	99 23       	and	r25, r25
    4364:	09 f4       	brne	.+2      	; 0x4368 <SpaceOnly+0x38>
    4366:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    4368:	08 95       	ret

0000436a <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    436a:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    436c:	e1 99       	sbic	0x1c, 1	; 28
    436e:	fe cf       	rjmp	.-4      	; 0x436c <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4370:	8e e3       	ldi	r24, 0x3E	; 62
    4372:	90 e0       	ldi	r25, 0x00	; 0
    4374:	9f bb       	out	0x1f, r25	; 31
    4376:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4378:	e0 9a       	sbi	0x1c, 0	; 28
    437a:	5d b3       	in	r21, 0x1d	; 29
    437c:	40 e0       	ldi	r20, 0x00	; 0
    437e:	08 c0       	rjmp	.+16     	; 0x4390 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    4380:	f9 01       	movw	r30, r18
    4382:	e8 0f       	add	r30, r24
    4384:	f9 1f       	adc	r31, r25
    4386:	80 81       	ld	r24, Z
    4388:	85 17       	cp	r24, r21
    438a:	09 f4       	brne	.+2      	; 0x438e <RemDecimal+0x24>
		     strDecimal[i]=0;
    438c:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    438e:	4f 5f       	subi	r20, 0xFF	; 255
    4390:	84 2f       	mov	r24, r20
    4392:	90 e0       	ldi	r25, 0x00	; 0
    4394:	f9 01       	movw	r30, r18
    4396:	01 90       	ld	r0, Z+
    4398:	00 20       	and	r0, r0
    439a:	e9 f7       	brne	.-6      	; 0x4396 <RemDecimal+0x2c>
    439c:	31 97       	sbiw	r30, 0x01	; 1
    439e:	e2 1b       	sub	r30, r18
    43a0:	f3 0b       	sbc	r31, r19
    43a2:	8e 17       	cp	r24, r30
    43a4:	9f 07       	cpc	r25, r31
    43a6:	60 f3       	brcs	.-40     	; 0x4380 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    43a8:	08 95       	ret

000043aa <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    43aa:	cf 92       	push	r12
    43ac:	df 92       	push	r13
    43ae:	ef 92       	push	r14
    43b0:	ff 92       	push	r15
    43b2:	0f 93       	push	r16
    43b4:	1f 93       	push	r17
    43b6:	df 93       	push	r29
    43b8:	cf 93       	push	r28
    43ba:	cd b7       	in	r28, 0x3d	; 61
    43bc:	de b7       	in	r29, 0x3e	; 62
    43be:	67 97       	sbiw	r28, 0x17	; 23
    43c0:	0f b6       	in	r0, 0x3f	; 63
    43c2:	f8 94       	cli
    43c4:	de bf       	out	0x3e, r29	; 62
    43c6:	0f be       	out	0x3f, r0	; 63
    43c8:	cd bf       	out	0x3d, r28	; 61
    43ca:	7c 01       	movw	r14, r24
    43cc:	d6 2e       	mov	r13, r22
    43ce:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    43d0:	00 d0       	rcall	.+0      	; 0x43d2 <GetProductPrice+0x28>
    43d2:	00 d0       	rcall	.+0      	; 0x43d4 <GetProductPrice+0x2a>
    43d4:	ad b7       	in	r26, 0x3d	; 61
    43d6:	be b7       	in	r27, 0x3e	; 62
    43d8:	12 96       	adiw	r26, 0x02	; 2
    43da:	9c 93       	st	X, r25
    43dc:	8e 93       	st	-X, r24
    43de:	11 97       	sbiw	r26, 0x01	; 1
    43e0:	8e e7       	ldi	r24, 0x7E	; 126
    43e2:	94 e0       	ldi	r25, 0x04	; 4
    43e4:	14 96       	adiw	r26, 0x04	; 4
    43e6:	9c 93       	st	X, r25
    43e8:	8e 93       	st	-X, r24
    43ea:	13 97       	sbiw	r26, 0x03	; 3
    43ec:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    43f0:	0f 90       	pop	r0
    43f2:	0f 90       	pop	r0
    43f4:	0f 90       	pop	r0
    43f6:	0f 90       	pop	r0
    43f8:	8e 01       	movw	r16, r28
    43fa:	09 5f       	subi	r16, 0xF9	; 249
    43fc:	1f 4f       	sbci	r17, 0xFF	; 255
    43fe:	c8 01       	movw	r24, r16
    4400:	65 e4       	ldi	r22, 0x45	; 69
    4402:	70 e0       	ldi	r23, 0x00	; 0
    4404:	48 e0       	ldi	r20, 0x08	; 8
    4406:	50 e0       	ldi	r21, 0x00	; 0
    4408:	27 e9       	ldi	r18, 0x97	; 151
    440a:	32 e1       	ldi	r19, 0x12	; 18
    440c:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    4410:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4412:	9e 01       	movw	r18, r28
    4414:	21 5f       	subi	r18, 0xF1	; 241
    4416:	3f 4f       	sbci	r19, 0xFF	; 255
    4418:	9e 2f       	mov	r25, r30
    441a:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    441c:	80 81       	ld	r24, Z
    441e:	8d 15       	cp	r24, r13
    4420:	11 f4       	brne	.+4      	; 0x4426 <GetProductPrice+0x7c>
    4422:	89 2f       	mov	r24, r25
    4424:	05 c0       	rjmp	.+10     	; 0x4430 <GetProductPrice+0x86>
    4426:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4428:	e2 17       	cp	r30, r18
    442a:	f3 07       	cpc	r31, r19
    442c:	a9 f7       	brne	.-22     	; 0x4418 <GetProductPrice+0x6e>
    442e:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4430:	b5 e0       	ldi	r27, 0x05	; 5
    4432:	bc 15       	cp	r27, r12
    4434:	08 f4       	brcc	.+2      	; 0x4438 <GetProductPrice+0x8e>
    4436:	41 c0       	rjmp	.+130    	; 0x44ba <GetProductPrice+0x110>
    4438:	66 e0       	ldi	r22, 0x06	; 6
    443a:	86 9f       	mul	r24, r22
    443c:	b0 01       	movw	r22, r0
    443e:	11 24       	eor	r1, r1
    4440:	6b 5a       	subi	r22, 0xAB	; 171
    4442:	7f 4f       	sbci	r23, 0xFF	; 255
    4444:	ce 01       	movw	r24, r28
    4446:	01 96       	adiw	r24, 0x01	; 1
    4448:	46 e0       	ldi	r20, 0x06	; 6
    444a:	50 e0       	ldi	r21, 0x00	; 0
    444c:	27 e9       	ldi	r18, 0x97	; 151
    444e:	32 e1       	ldi	r19, 0x12	; 18
    4450:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    4454:	8e 01       	movw	r16, r28
    4456:	01 5f       	subi	r16, 0xF1	; 241
    4458:	1f 4f       	sbci	r17, 0xFF	; 255
    445a:	fe 01       	movw	r30, r28
    445c:	ec 0d       	add	r30, r12
    445e:	f1 1d       	adc	r31, r1
    4460:	60 81       	ld	r22, Z
    4462:	89 e0       	ldi	r24, 0x09	; 9
    4464:	68 9f       	mul	r22, r24
    4466:	b0 01       	movw	r22, r0
    4468:	11 24       	eor	r1, r1
    446a:	64 55       	subi	r22, 0x54	; 84
    446c:	7f 4f       	sbci	r23, 0xFF	; 255
    446e:	c8 01       	movw	r24, r16
    4470:	49 e0       	ldi	r20, 0x09	; 9
    4472:	50 e0       	ldi	r21, 0x00	; 0
    4474:	27 e9       	ldi	r18, 0x97	; 151
    4476:	32 e1       	ldi	r19, 0x12	; 18
    4478:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    447c:	c8 01       	movw	r24, r16
    447e:	0e 94 b5 21 	call	0x436a	; 0x436a <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    4482:	00 d0       	rcall	.+0      	; 0x4484 <GetProductPrice+0xda>
    4484:	00 d0       	rcall	.+0      	; 0x4486 <GetProductPrice+0xdc>
    4486:	00 d0       	rcall	.+0      	; 0x4488 <GetProductPrice+0xde>
    4488:	ed b7       	in	r30, 0x3d	; 61
    448a:	fe b7       	in	r31, 0x3e	; 62
    448c:	31 96       	adiw	r30, 0x01	; 1
    448e:	ad b7       	in	r26, 0x3d	; 61
    4490:	be b7       	in	r27, 0x3e	; 62
    4492:	12 96       	adiw	r26, 0x02	; 2
    4494:	fc 92       	st	X, r15
    4496:	ee 92       	st	-X, r14
    4498:	11 97       	sbiw	r26, 0x01	; 1
    449a:	8b e7       	ldi	r24, 0x7B	; 123
    449c:	94 e0       	ldi	r25, 0x04	; 4
    449e:	93 83       	std	Z+3, r25	; 0x03
    44a0:	82 83       	std	Z+2, r24	; 0x02
    44a2:	15 83       	std	Z+5, r17	; 0x05
    44a4:	04 83       	std	Z+4, r16	; 0x04
    44a6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    44aa:	ed b7       	in	r30, 0x3d	; 61
    44ac:	fe b7       	in	r31, 0x3e	; 62
    44ae:	36 96       	adiw	r30, 0x06	; 6
    44b0:	0f b6       	in	r0, 0x3f	; 63
    44b2:	f8 94       	cli
    44b4:	fe bf       	out	0x3e, r31	; 62
    44b6:	0f be       	out	0x3f, r0	; 63
    44b8:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    44ba:	67 96       	adiw	r28, 0x17	; 23
    44bc:	0f b6       	in	r0, 0x3f	; 63
    44be:	f8 94       	cli
    44c0:	de bf       	out	0x3e, r29	; 62
    44c2:	0f be       	out	0x3f, r0	; 63
    44c4:	cd bf       	out	0x3d, r28	; 61
    44c6:	cf 91       	pop	r28
    44c8:	df 91       	pop	r29
    44ca:	1f 91       	pop	r17
    44cc:	0f 91       	pop	r16
    44ce:	ff 90       	pop	r15
    44d0:	ef 90       	pop	r14
    44d2:	df 90       	pop	r13
    44d4:	cf 90       	pop	r12
    44d6:	08 95       	ret

000044d8 <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    44d8:	df 93       	push	r29
    44da:	cf 93       	push	r28
    44dc:	cd b7       	in	r28, 0x3d	; 61
    44de:	de b7       	in	r29, 0x3e	; 62
    44e0:	2b 97       	sbiw	r28, 0x0b	; 11
    44e2:	0f b6       	in	r0, 0x3f	; 63
    44e4:	f8 94       	cli
    44e6:	de bf       	out	0x3e, r29	; 62
    44e8:	0f be       	out	0x3f, r0	; 63
    44ea:	cd bf       	out	0x3d, r28	; 61
    44ec:	98 2f       	mov	r25, r24
    44ee:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    44f0:	fb 01       	movw	r30, r22
    44f2:	80 85       	ldd	r24, Z+8	; 0x08
    44f4:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    44f6:	81 85       	ldd	r24, Z+9	; 0x09
    44f8:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    44fa:	87 81       	ldd	r24, Z+7	; 0x07
    44fc:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    44fe:	85 81       	ldd	r24, Z+5	; 0x05
    4500:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    4502:	86 81       	ldd	r24, Z+6	; 0x06
    4504:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    4506:	84 81       	ldd	r24, Z+4	; 0x04
    4508:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    450a:	99 23       	and	r25, r25
    450c:	19 f0       	breq	.+6      	; 0x4514 <FormatDate+0x3c>
    450e:	91 30       	cpi	r25, 0x01	; 1
    4510:	59 f4       	brne	.+22     	; 0x4528 <FormatDate+0x50>
    4512:	0f c0       	rjmp	.+30     	; 0x4532 <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    4514:	fb 01       	movw	r30, r22
    4516:	80 81       	ld	r24, Z
    4518:	8f 83       	std	Y+7, r24	; 0x07
    451a:	81 81       	ldd	r24, Z+1	; 0x01
    451c:	88 87       	std	Y+8, r24	; 0x08
    451e:	82 81       	ldd	r24, Z+2	; 0x02
    4520:	89 87       	std	Y+9, r24	; 0x09
    4522:	83 81       	ldd	r24, Z+3	; 0x03
    4524:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    4526:	1b 86       	std	Y+11, r1	; 0x0b
    4528:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    452a:	ae 01       	movw	r20, r28
    452c:	4f 5f       	subi	r20, 0xFF	; 255
    452e:	5f 4f       	sbci	r21, 0xFF	; 255
    4530:	0f c0       	rjmp	.+30     	; 0x4550 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    4532:	fb 01       	movw	r30, r22
    4534:	82 81       	ldd	r24, Z+2	; 0x02
    4536:	8f 83       	std	Y+7, r24	; 0x07
    4538:	83 81       	ldd	r24, Z+3	; 0x03
    453a:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    453c:	19 86       	std	Y+9, r1	; 0x09
    453e:	f4 cf       	rjmp	.-24     	; 0x4528 <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4540:	f9 01       	movw	r30, r18
    4542:	ea 0f       	add	r30, r26
    4544:	fb 1f       	adc	r31, r27
    4546:	a4 0f       	add	r26, r20
    4548:	b5 1f       	adc	r27, r21
    454a:	8c 91       	ld	r24, X
    454c:	80 83       	st	Z, r24
    454e:	9f 5f       	subi	r25, 0xFF	; 255
    4550:	a9 2f       	mov	r26, r25
    4552:	b0 e0       	ldi	r27, 0x00	; 0
    4554:	fa 01       	movw	r30, r20
    4556:	01 90       	ld	r0, Z+
    4558:	00 20       	and	r0, r0
    455a:	e9 f7       	brne	.-6      	; 0x4556 <FormatDate+0x7e>
    455c:	31 97       	sbiw	r30, 0x01	; 1
    455e:	e4 1b       	sub	r30, r20
    4560:	f5 0b       	sbc	r31, r21
    4562:	ae 17       	cp	r26, r30
    4564:	bf 07       	cpc	r27, r31
    4566:	60 f3       	brcs	.-40     	; 0x4540 <FormatDate+0x68>
}
    4568:	2b 96       	adiw	r28, 0x0b	; 11
    456a:	0f b6       	in	r0, 0x3f	; 63
    456c:	f8 94       	cli
    456e:	de bf       	out	0x3e, r29	; 62
    4570:	0f be       	out	0x3f, r0	; 63
    4572:	cd bf       	out	0x3d, r28	; 61
    4574:	cf 91       	pop	r28
    4576:	df 91       	pop	r29
    4578:	08 95       	ret

0000457a <RemZeroLead>:
	 _uart_print(0,1,strTest);

while (1){};
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    457a:	cf 93       	push	r28
    457c:	df 93       	push	r29
    457e:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    4580:	fc 01       	movw	r30, r24
    4582:	01 90       	ld	r0, Z+
    4584:	00 20       	and	r0, r0
    4586:	e9 f7       	brne	.-6      	; 0x4582 <RemZeroLead+0x8>
    4588:	31 97       	sbiw	r30, 0x01	; 1
    458a:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    458c:	e2 30       	cpi	r30, 0x02	; 2
    458e:	d0 f1       	brcs	.+116    	; 0x4604 <RemZeroLead+0x8a>
    4590:	88 81       	ld	r24, Y
    4592:	80 33       	cpi	r24, 0x30	; 48
    4594:	b9 f5       	brne	.+110    	; 0x4604 <RemZeroLead+0x8a>
    4596:	4c 2f       	mov	r20, r28
    4598:	de 01       	movw	r26, r28
    459a:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    459c:	8c 91       	ld	r24, X
    459e:	80 33       	cpi	r24, 0x30	; 48
    45a0:	69 f4       	brne	.+26     	; 0x45bc <RemZeroLead+0x42>
    45a2:	11 96       	adiw	r26, 0x01	; 1
    45a4:	8c 91       	ld	r24, X
    45a6:	11 97       	sbiw	r26, 0x01	; 1
    45a8:	80 33       	cpi	r24, 0x30	; 48
    45aa:	11 f4       	brne	.+4      	; 0x45b0 <RemZeroLead+0x36>
    45ac:	9f 5f       	subi	r25, 0xFF	; 255
    45ae:	06 c0       	rjmp	.+12     	; 0x45bc <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    45b0:	8e 32       	cpi	r24, 0x2E	; 46
    45b2:	11 f0       	breq	.+4      	; 0x45b8 <RemZeroLead+0x3e>
    45b4:	8c 32       	cpi	r24, 0x2C	; 44
    45b6:	41 f4       	brne	.+16     	; 0x45c8 <RemZeroLead+0x4e>
    45b8:	91 50       	subi	r25, 0x01	; 1
    45ba:	06 c0       	rjmp	.+12     	; 0x45c8 <RemZeroLead+0x4e>
    45bc:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    45be:	8a 2f       	mov	r24, r26
    45c0:	84 1b       	sub	r24, r20
    45c2:	8e 17       	cp	r24, r30
    45c4:	58 f3       	brcs	.-42     	; 0x459c <RemZeroLead+0x22>
    45c6:	01 c0       	rjmp	.+2      	; 0x45ca <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    45c8:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    45ca:	9e 17       	cp	r25, r30
    45cc:	10 f0       	brcs	.+4      	; 0x45d2 <RemZeroLead+0x58>
    45ce:	9e 2f       	mov	r25, r30
    45d0:	91 50       	subi	r25, 0x01	; 1
    45d2:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    45d4:	89 2f       	mov	r24, r25
    45d6:	90 e0       	ldi	r25, 0x00	; 0
    45d8:	2e 2f       	mov	r18, r30
    45da:	30 e0       	ldi	r19, 0x00	; 0
    45dc:	28 1b       	sub	r18, r24
    45de:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    45e0:	be 01       	movw	r22, r28
    45e2:	68 0f       	add	r22, r24
    45e4:	79 1f       	adc	r23, r25
    45e6:	09 c0       	rjmp	.+18     	; 0x45fa <RemZeroLead+0x80>
    45e8:	fe 01       	movw	r30, r28
    45ea:	ea 0f       	add	r30, r26
    45ec:	fb 1f       	adc	r31, r27
    45ee:	a6 0f       	add	r26, r22
    45f0:	b7 1f       	adc	r27, r23
    45f2:	8c 91       	ld	r24, X
    45f4:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    45f6:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    45f8:	4f 5f       	subi	r20, 0xFF	; 255
    45fa:	a4 2f       	mov	r26, r20
    45fc:	b0 e0       	ldi	r27, 0x00	; 0
    45fe:	a2 17       	cp	r26, r18
    4600:	b3 07       	cpc	r27, r19
    4602:	94 f3       	brlt	.-28     	; 0x45e8 <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    4604:	df 91       	pop	r29
    4606:	cf 91       	pop	r28
    4608:	08 95       	ret

0000460a <FTestRemZero>:
		     Zeroed[i]=0;
		 }
     }
}

void FTestRemZero(){
    460a:	0f 93       	push	r16
    460c:	1f 93       	push	r17
    460e:	df 93       	push	r29
    4610:	cf 93       	push	r28
    4612:	cd b7       	in	r28, 0x3d	; 61
    4614:	de b7       	in	r29, 0x3e	; 62
    4616:	64 97       	sbiw	r28, 0x14	; 20
    4618:	0f b6       	in	r0, 0x3f	; 63
    461a:	f8 94       	cli
    461c:	de bf       	out	0x3e, r29	; 62
    461e:	0f be       	out	0x3f, r0	; 63
    4620:	cd bf       	out	0x3d, r28	; 61
char strSend[50],strTest[20];

     sprintf_P(strTest,PSTR("00012300"));
    4622:	00 d0       	rcall	.+0      	; 0x4624 <FTestRemZero+0x1a>
    4624:	00 d0       	rcall	.+0      	; 0x4626 <FTestRemZero+0x1c>
    4626:	8e 01       	movw	r16, r28
    4628:	0f 5f       	subi	r16, 0xFF	; 255
    462a:	1f 4f       	sbci	r17, 0xFF	; 255
    462c:	ed b7       	in	r30, 0x3d	; 61
    462e:	fe b7       	in	r31, 0x3e	; 62
    4630:	12 83       	std	Z+2, r17	; 0x02
    4632:	01 83       	std	Z+1, r16	; 0x01
    4634:	8e ec       	ldi	r24, 0xCE	; 206
    4636:	9a e0       	ldi	r25, 0x0A	; 10
    4638:	94 83       	std	Z+4, r25	; 0x04
    463a:	83 83       	std	Z+3, r24	; 0x03
    463c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(0,1,strTest);
    4640:	0f 90       	pop	r0
    4642:	0f 90       	pop	r0
    4644:	0f 90       	pop	r0
    4646:	0f 90       	pop	r0
    4648:	80 e0       	ldi	r24, 0x00	; 0
    464a:	61 e0       	ldi	r22, 0x01	; 1
    464c:	a8 01       	movw	r20, r16
    464e:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
     RemZeroLead(strTest);  
    4652:	c8 01       	movw	r24, r16
    4654:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 _uart_print(0,1,strTest);
    4658:	80 e0       	ldi	r24, 0x00	; 0
    465a:	61 e0       	ldi	r22, 0x01	; 1
    465c:	a8 01       	movw	r20, r16
    465e:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

     sprintf_P(strTest,PSTR("00,012300"));
    4662:	00 d0       	rcall	.+0      	; 0x4664 <FTestRemZero+0x5a>
    4664:	00 d0       	rcall	.+0      	; 0x4666 <FTestRemZero+0x5c>
    4666:	ed b7       	in	r30, 0x3d	; 61
    4668:	fe b7       	in	r31, 0x3e	; 62
    466a:	12 83       	std	Z+2, r17	; 0x02
    466c:	01 83       	std	Z+1, r16	; 0x01
    466e:	84 ec       	ldi	r24, 0xC4	; 196
    4670:	9a e0       	ldi	r25, 0x0A	; 10
    4672:	94 83       	std	Z+4, r25	; 0x04
    4674:	83 83       	std	Z+3, r24	; 0x03
    4676:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(0,1,strTest);
    467a:	0f 90       	pop	r0
    467c:	0f 90       	pop	r0
    467e:	0f 90       	pop	r0
    4680:	0f 90       	pop	r0
    4682:	80 e0       	ldi	r24, 0x00	; 0
    4684:	61 e0       	ldi	r22, 0x01	; 1
    4686:	a8 01       	movw	r20, r16
    4688:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
     RemZeroLead(strTest);  
    468c:	c8 01       	movw	r24, r16
    468e:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 _uart_print(0,1,strTest);
    4692:	80 e0       	ldi	r24, 0x00	; 0
    4694:	61 e0       	ldi	r22, 0x01	; 1
    4696:	a8 01       	movw	r20, r16
    4698:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

     sprintf_P(strTest,PSTR("00.012300"));
    469c:	00 d0       	rcall	.+0      	; 0x469e <FTestRemZero+0x94>
    469e:	00 d0       	rcall	.+0      	; 0x46a0 <FTestRemZero+0x96>
    46a0:	ed b7       	in	r30, 0x3d	; 61
    46a2:	fe b7       	in	r31, 0x3e	; 62
    46a4:	12 83       	std	Z+2, r17	; 0x02
    46a6:	01 83       	std	Z+1, r16	; 0x01
    46a8:	8a eb       	ldi	r24, 0xBA	; 186
    46aa:	9a e0       	ldi	r25, 0x0A	; 10
    46ac:	94 83       	std	Z+4, r25	; 0x04
    46ae:	83 83       	std	Z+3, r24	; 0x03
    46b0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(0,1,strTest);
    46b4:	0f 90       	pop	r0
    46b6:	0f 90       	pop	r0
    46b8:	0f 90       	pop	r0
    46ba:	0f 90       	pop	r0
    46bc:	80 e0       	ldi	r24, 0x00	; 0
    46be:	61 e0       	ldi	r22, 0x01	; 1
    46c0:	a8 01       	movw	r20, r16
    46c2:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
     RemZeroLead(strTest);  
    46c6:	c8 01       	movw	r24, r16
    46c8:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 _uart_print(0,1,strTest);
    46cc:	80 e0       	ldi	r24, 0x00	; 0
    46ce:	61 e0       	ldi	r22, 0x01	; 1
    46d0:	a8 01       	movw	r20, r16
    46d2:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>


     sprintf_P(strTest,PSTR("012300"));
    46d6:	00 d0       	rcall	.+0      	; 0x46d8 <FTestRemZero+0xce>
    46d8:	00 d0       	rcall	.+0      	; 0x46da <FTestRemZero+0xd0>
    46da:	ed b7       	in	r30, 0x3d	; 61
    46dc:	fe b7       	in	r31, 0x3e	; 62
    46de:	12 83       	std	Z+2, r17	; 0x02
    46e0:	01 83       	std	Z+1, r16	; 0x01
    46e2:	83 eb       	ldi	r24, 0xB3	; 179
    46e4:	9a e0       	ldi	r25, 0x0A	; 10
    46e6:	94 83       	std	Z+4, r25	; 0x04
    46e8:	83 83       	std	Z+3, r24	; 0x03
    46ea:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(0,1,strTest);
    46ee:	0f 90       	pop	r0
    46f0:	0f 90       	pop	r0
    46f2:	0f 90       	pop	r0
    46f4:	0f 90       	pop	r0
    46f6:	80 e0       	ldi	r24, 0x00	; 0
    46f8:	61 e0       	ldi	r22, 0x01	; 1
    46fa:	a8 01       	movw	r20, r16
    46fc:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
     RemZeroLead(strTest);  
    4700:	c8 01       	movw	r24, r16
    4702:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 _uart_print(0,1,strTest);
    4706:	80 e0       	ldi	r24, 0x00	; 0
    4708:	61 e0       	ldi	r22, 0x01	; 1
    470a:	a8 01       	movw	r20, r16
    470c:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>


     sprintf_P(strTest,PSTR("0000"));
    4710:	00 d0       	rcall	.+0      	; 0x4712 <FTestRemZero+0x108>
    4712:	00 d0       	rcall	.+0      	; 0x4714 <FTestRemZero+0x10a>
    4714:	ed b7       	in	r30, 0x3d	; 61
    4716:	fe b7       	in	r31, 0x3e	; 62
    4718:	12 83       	std	Z+2, r17	; 0x02
    471a:	01 83       	std	Z+1, r16	; 0x01
    471c:	8e ea       	ldi	r24, 0xAE	; 174
    471e:	9a e0       	ldi	r25, 0x0A	; 10
    4720:	94 83       	std	Z+4, r25	; 0x04
    4722:	83 83       	std	Z+3, r24	; 0x03
    4724:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(0,1,strTest);
    4728:	0f 90       	pop	r0
    472a:	0f 90       	pop	r0
    472c:	0f 90       	pop	r0
    472e:	0f 90       	pop	r0
    4730:	80 e0       	ldi	r24, 0x00	; 0
    4732:	61 e0       	ldi	r22, 0x01	; 1
    4734:	a8 01       	movw	r20, r16
    4736:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
     RemZeroLead(strTest);  
    473a:	c8 01       	movw	r24, r16
    473c:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 _uart_print(0,1,strTest);
    4740:	80 e0       	ldi	r24, 0x00	; 0
    4742:	61 e0       	ldi	r22, 0x01	; 1
    4744:	a8 01       	movw	r20, r16
    4746:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>


     sprintf_P(strTest,PSTR("00"));
    474a:	00 d0       	rcall	.+0      	; 0x474c <FTestRemZero+0x142>
    474c:	00 d0       	rcall	.+0      	; 0x474e <FTestRemZero+0x144>
    474e:	ed b7       	in	r30, 0x3d	; 61
    4750:	fe b7       	in	r31, 0x3e	; 62
    4752:	12 83       	std	Z+2, r17	; 0x02
    4754:	01 83       	std	Z+1, r16	; 0x01
    4756:	8b ea       	ldi	r24, 0xAB	; 171
    4758:	9a e0       	ldi	r25, 0x0A	; 10
    475a:	94 83       	std	Z+4, r25	; 0x04
    475c:	83 83       	std	Z+3, r24	; 0x03
    475e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(0,1,strTest);
    4762:	0f 90       	pop	r0
    4764:	0f 90       	pop	r0
    4766:	0f 90       	pop	r0
    4768:	0f 90       	pop	r0
    476a:	80 e0       	ldi	r24, 0x00	; 0
    476c:	61 e0       	ldi	r22, 0x01	; 1
    476e:	a8 01       	movw	r20, r16
    4770:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
     RemZeroLead(strTest);  
    4774:	c8 01       	movw	r24, r16
    4776:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 _uart_print(0,1,strTest);
    477a:	80 e0       	ldi	r24, 0x00	; 0
    477c:	61 e0       	ldi	r22, 0x01	; 1
    477e:	a8 01       	movw	r20, r16
    4780:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

     sprintf_P(strTest,PSTR("0"));
    4784:	00 d0       	rcall	.+0      	; 0x4786 <FTestRemZero+0x17c>
    4786:	00 d0       	rcall	.+0      	; 0x4788 <FTestRemZero+0x17e>
    4788:	ed b7       	in	r30, 0x3d	; 61
    478a:	fe b7       	in	r31, 0x3e	; 62
    478c:	12 83       	std	Z+2, r17	; 0x02
    478e:	01 83       	std	Z+1, r16	; 0x01
    4790:	89 ea       	ldi	r24, 0xA9	; 169
    4792:	9a e0       	ldi	r25, 0x0A	; 10
    4794:	94 83       	std	Z+4, r25	; 0x04
    4796:	83 83       	std	Z+3, r24	; 0x03
    4798:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(0,1,strTest);
    479c:	0f 90       	pop	r0
    479e:	0f 90       	pop	r0
    47a0:	0f 90       	pop	r0
    47a2:	0f 90       	pop	r0
    47a4:	80 e0       	ldi	r24, 0x00	; 0
    47a6:	61 e0       	ldi	r22, 0x01	; 1
    47a8:	a8 01       	movw	r20, r16
    47aa:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
     RemZeroLead(strTest);  
    47ae:	c8 01       	movw	r24, r16
    47b0:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 _uart_print(0,1,strTest);
    47b4:	80 e0       	ldi	r24, 0x00	; 0
    47b6:	61 e0       	ldi	r22, 0x01	; 1
    47b8:	a8 01       	movw	r20, r16
    47ba:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
    47be:	ff cf       	rjmp	.-2      	; 0x47be <FTestRemZero+0x1b4>

000047c0 <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    47c0:	cf 93       	push	r28
    47c2:	df 93       	push	r29
    47c4:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    47c6:	fc 01       	movw	r30, r24
    47c8:	01 90       	ld	r0, Z+
    47ca:	00 20       	and	r0, r0
    47cc:	e9 f7       	brne	.-6      	; 0x47c8 <RemSpaceLead+0x8>
    47ce:	31 97       	sbiw	r30, 0x01	; 1
    47d0:	6e 2f       	mov	r22, r30
    47d2:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    47d4:	62 30       	cpi	r22, 0x02	; 2
    47d6:	e0 f1       	brcs	.+120    	; 0x4850 <RemSpaceLead+0x90>
    47d8:	88 81       	ld	r24, Y
    47da:	80 32       	cpi	r24, 0x20	; 32
    47dc:	c9 f5       	brne	.+114    	; 0x4850 <RemSpaceLead+0x90>
    47de:	4c 2f       	mov	r20, r28
    47e0:	fe 01       	movw	r30, r28
    47e2:	90 e0       	ldi	r25, 0x00	; 0
    47e4:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    47e6:	80 81       	ld	r24, Z
    47e8:	80 32       	cpi	r24, 0x20	; 32
    47ea:	41 f4       	brne	.+16     	; 0x47fc <RemSpaceLead+0x3c>
    47ec:	81 81       	ldd	r24, Z+1	; 0x01
    47ee:	80 32       	cpi	r24, 0x20	; 32
    47f0:	21 f4       	brne	.+8      	; 0x47fa <RemSpaceLead+0x3a>
    47f2:	22 23       	and	r18, r18
    47f4:	19 f4       	brne	.+6      	; 0x47fc <RemSpaceLead+0x3c>
    47f6:	9f 5f       	subi	r25, 0xFF	; 255
    47f8:	01 c0       	rjmp	.+2      	; 0x47fc <RemSpaceLead+0x3c>
    47fa:	21 e0       	ldi	r18, 0x01	; 1
    47fc:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    47fe:	8e 2f       	mov	r24, r30
    4800:	84 1b       	sub	r24, r20
    4802:	86 17       	cp	r24, r22
    4804:	80 f3       	brcs	.-32     	; 0x47e6 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    4806:	39 2f       	mov	r19, r25
    4808:	3f 5f       	subi	r19, 0xFF	; 255
    480a:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    480c:	43 2f       	mov	r20, r19
    480e:	50 e0       	ldi	r21, 0x00	; 0
    4810:	09 c0       	rjmp	.+18     	; 0x4824 <RemSpaceLead+0x64>
    4812:	fe 01       	movw	r30, r28
    4814:	e8 0f       	add	r30, r24
    4816:	f9 1f       	adc	r31, r25
    4818:	df 01       	movw	r26, r30
    481a:	a4 0f       	add	r26, r20
    481c:	b5 1f       	adc	r27, r21
    481e:	8c 91       	ld	r24, X
    4820:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    4822:	2f 5f       	subi	r18, 0xFF	; 255
    4824:	82 2f       	mov	r24, r18
    4826:	90 e0       	ldi	r25, 0x00	; 0
    4828:	fe 01       	movw	r30, r28
    482a:	01 90       	ld	r0, Z+
    482c:	00 20       	and	r0, r0
    482e:	e9 f7       	brne	.-6      	; 0x482a <RemSpaceLead+0x6a>
    4830:	31 97       	sbiw	r30, 0x01	; 1
    4832:	ec 1b       	sub	r30, r28
    4834:	fd 0b       	sbc	r31, r29
    4836:	8e 17       	cp	r24, r30
    4838:	9f 07       	cpc	r25, r31
    483a:	58 f3       	brcs	.-42     	; 0x4812 <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    483c:	86 2f       	mov	r24, r22
    483e:	83 1b       	sub	r24, r19
    4840:	05 c0       	rjmp	.+10     	; 0x484c <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    4842:	fe 01       	movw	r30, r28
    4844:	e8 0f       	add	r30, r24
    4846:	f1 1d       	adc	r31, r1
    4848:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    484a:	8f 5f       	subi	r24, 0xFF	; 255
    484c:	86 17       	cp	r24, r22
    484e:	c8 f3       	brcs	.-14     	; 0x4842 <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    4850:	df 91       	pop	r29
    4852:	cf 91       	pop	r28
    4854:	08 95       	ret

00004856 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    4856:	0f 93       	push	r16
    4858:	1f 93       	push	r17
    485a:	cf 93       	push	r28
    485c:	df 93       	push	r29
    485e:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    4860:	dc 01       	movw	r26, r24
    4862:	0d 90       	ld	r0, X+
    4864:	00 20       	and	r0, r0
    4866:	e9 f7       	brne	.-6      	; 0x4862 <RemSpaceLag+0xc>
    4868:	11 97       	sbiw	r26, 0x01	; 1
    486a:	a8 1b       	sub	r26, r24
    486c:	b0 e0       	ldi	r27, 0x00	; 0
    486e:	20 e0       	ldi	r18, 0x00	; 0
    4870:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    4872:	6a 2f       	mov	r22, r26
    4874:	70 e0       	ldi	r23, 0x00	; 0
    4876:	8b 01       	movw	r16, r22
    4878:	01 50       	subi	r16, 0x01	; 1
    487a:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    487c:	a1 50       	subi	r26, 0x01	; 1
    487e:	16 c0       	rjmp	.+44     	; 0x48ac <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    4880:	ab 01       	movw	r20, r22
    4882:	48 1b       	sub	r20, r24
    4884:	59 0b       	sbc	r21, r25
    4886:	fe 01       	movw	r30, r28
    4888:	e4 0f       	add	r30, r20
    488a:	f5 1f       	adc	r31, r21
    488c:	32 97       	sbiw	r30, 0x02	; 2
    488e:	80 81       	ld	r24, Z
    4890:	80 32       	cpi	r24, 0x20	; 32
    4892:	89 f4       	brne	.+34     	; 0x48b6 <RemSpaceLag+0x60>
    4894:	fa 01       	movw	r30, r20
    4896:	31 97       	sbiw	r30, 0x01	; 1
    4898:	ec 0f       	add	r30, r28
    489a:	fd 1f       	adc	r31, r29
    489c:	2f 5f       	subi	r18, 0xFF	; 255
    489e:	3f 4f       	sbci	r19, 0xFF	; 255
    48a0:	80 81       	ld	r24, Z
    48a2:	80 32       	cpi	r24, 0x20	; 32
    48a4:	41 f4       	brne	.+16     	; 0x48b6 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    48a6:	10 82       	st	Z, r1
    48a8:	ba 2f       	mov	r27, r26
    48aa:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    48ac:	82 2f       	mov	r24, r18
    48ae:	90 e0       	ldi	r25, 0x00	; 0
    48b0:	80 17       	cp	r24, r16
    48b2:	91 07       	cpc	r25, r17
    48b4:	2c f3       	brlt	.-54     	; 0x4880 <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    48b6:	fe 01       	movw	r30, r28
    48b8:	eb 0f       	add	r30, r27
    48ba:	f1 1d       	adc	r31, r1
    48bc:	80 81       	ld	r24, Z
    48be:	80 32       	cpi	r24, 0x20	; 32
    48c0:	09 f4       	brne	.+2      	; 0x48c4 <RemSpaceLag+0x6e>
    48c2:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    48c4:	88 81       	ld	r24, Y
    48c6:	80 32       	cpi	r24, 0x20	; 32
    48c8:	09 f4       	brne	.+2      	; 0x48cc <RemSpaceLag+0x76>
    48ca:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    48cc:	fe 01       	movw	r30, r28
    48ce:	01 90       	ld	r0, Z+
    48d0:	00 20       	and	r0, r0
    48d2:	e9 f7       	brne	.-6      	; 0x48ce <RemSpaceLag+0x78>
    48d4:	31 97       	sbiw	r30, 0x01	; 1
    48d6:	ec 1b       	sub	r30, r28
    48d8:	fd 0b       	sbc	r31, r29
    48da:	ec 0f       	add	r30, r28
    48dc:	fd 1f       	adc	r31, r29
    48de:	10 82       	st	Z, r1
}
    48e0:	df 91       	pop	r29
    48e2:	cf 91       	pop	r28
    48e4:	1f 91       	pop	r17
    48e6:	0f 91       	pop	r16
    48e8:	08 95       	ret

000048ea <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    48ea:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    48ec:	10 91 59 0b 	lds	r17, 0x0B59
    48f0:	20 e0       	ldi	r18, 0x00	; 0
    48f2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    48f4:	f9 01       	movw	r30, r18
    48f6:	e0 5e       	subi	r30, 0xE0	; 224
    48f8:	f4 4f       	sbci	r31, 0xF4	; 244
    48fa:	d9 01       	movw	r26, r18
    48fc:	a4 57       	subi	r26, 0x74	; 116
    48fe:	b2 4f       	sbci	r27, 0xF2	; 242
    4900:	95 96       	adiw	r26, 0x25	; 37
    4902:	8c 91       	ld	r24, X
    4904:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4906:	2f 5f       	subi	r18, 0xFF	; 255
    4908:	3f 4f       	sbci	r19, 0xFF	; 255
    490a:	24 31       	cpi	r18, 0x14	; 20
    490c:	31 05       	cpc	r19, r1
    490e:	91 f7       	brne	.-28     	; 0x48f4 <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4910:	10 92 34 0b 	sts	0x0B34, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    4914:	8c e8       	ldi	r24, 0x8C	; 140
    4916:	9d e0       	ldi	r25, 0x0D	; 13
    4918:	0e 94 e0 23 	call	0x47c0	; 0x47c0 <RemSpaceLead>
    491c:	20 e0       	ldi	r18, 0x00	; 0
    491e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4920:	f9 01       	movw	r30, r18
    4922:	e7 5d       	subi	r30, 0xD7	; 215
    4924:	fa 4f       	sbci	r31, 0xFA	; 250
    4926:	d9 01       	movw	r26, r18
    4928:	a0 5e       	subi	r26, 0xE0	; 224
    492a:	b4 4f       	sbci	r27, 0xF4	; 244
    492c:	dc 96       	adiw	r26, 0x3c	; 60
    492e:	8c 91       	ld	r24, X
    4930:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4932:	2f 5f       	subi	r18, 0xFF	; 255
    4934:	3f 4f       	sbci	r19, 0xFF	; 255
    4936:	28 32       	cpi	r18, 0x28	; 40
    4938:	31 05       	cpc	r19, r1
    493a:	91 f7       	brne	.-28     	; 0x4920 <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    493c:	10 92 51 05 	sts	0x0551, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    4940:	89 e2       	ldi	r24, 0x29	; 41
    4942:	95 e0       	ldi	r25, 0x05	; 5
    4944:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
    4948:	20 e0       	ldi	r18, 0x00	; 0
    494a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    494c:	f9 01       	movw	r30, r18
    494e:	e0 5a       	subi	r30, 0xA0	; 160
    4950:	fa 4f       	sbci	r31, 0xFA	; 250
    4952:	d9 01       	movw	r26, r18
    4954:	a8 54       	subi	r26, 0x48	; 72
    4956:	b4 4f       	sbci	r27, 0xF4	; 244
    4958:	8c 91       	ld	r24, X
    495a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    495c:	2f 5f       	subi	r18, 0xFF	; 255
    495e:	3f 4f       	sbci	r19, 0xFF	; 255
    4960:	29 31       	cpi	r18, 0x19	; 25
    4962:	31 05       	cpc	r19, r1
    4964:	99 f7       	brne	.-26     	; 0x494c <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4966:	10 92 79 05 	sts	0x0579, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    496a:	80 e6       	ldi	r24, 0x60	; 96
    496c:	95 e0       	ldi	r25, 0x05	; 5
    496e:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4972:	80 91 d1 0b 	lds	r24, 0x0BD1
    4976:	80 93 ea 04 	sts	0x04EA, r24
	 }Dest[Length]=0;
    497a:	10 92 eb 04 	sts	0x04EB, r1
    497e:	20 e0       	ldi	r18, 0x00	; 0
    4980:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4982:	f9 01       	movw	r30, r18
    4984:	e2 50       	subi	r30, 0x02	; 2
    4986:	f2 4f       	sbci	r31, 0xF2	; 242
    4988:	d9 01       	movw	r26, r18
    498a:	ae 52       	subi	r26, 0x2E	; 46
    498c:	b4 4f       	sbci	r27, 0xF4	; 244
    498e:	8c 91       	ld	r24, X
    4990:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4992:	2f 5f       	subi	r18, 0xFF	; 255
    4994:	3f 4f       	sbci	r19, 0xFF	; 255
    4996:	2d 30       	cpi	r18, 0x0D	; 13
    4998:	31 05       	cpc	r19, r1
    499a:	99 f7       	brne	.-26     	; 0x4982 <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    499c:	10 92 0b 0e 	sts	0x0E0B, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    49a0:	8e ef       	ldi	r24, 0xFE	; 254
    49a2:	9d e0       	ldi	r25, 0x0D	; 13
    49a4:	0e 94 e0 23 	call	0x47c0	; 0x47c0 <RemSpaceLead>
    49a8:	20 e0       	ldi	r18, 0x00	; 0
    49aa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    49ac:	f9 01       	movw	r30, r18
    49ae:	e3 50       	subi	r30, 0x03	; 3
    49b0:	f5 4f       	sbci	r31, 0xF5	; 245
    49b2:	d9 01       	movw	r26, r18
    49b4:	a1 52       	subi	r26, 0x21	; 33
    49b6:	b4 4f       	sbci	r27, 0xF4	; 244
    49b8:	8c 91       	ld	r24, X
    49ba:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    49bc:	2f 5f       	subi	r18, 0xFF	; 255
    49be:	3f 4f       	sbci	r19, 0xFF	; 255
    49c0:	2a 30       	cpi	r18, 0x0A	; 10
    49c2:	31 05       	cpc	r19, r1
    49c4:	99 f7       	brne	.-26     	; 0x49ac <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    49c6:	10 92 07 0b 	sts	0x0B07, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    49ca:	8d ef       	ldi	r24, 0xFD	; 253
    49cc:	9a e0       	ldi	r25, 0x0A	; 10
    49ce:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
    49d2:	20 e0       	ldi	r18, 0x00	; 0
    49d4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    49d6:	f9 01       	movw	r30, r18
    49d8:	ed 57       	subi	r30, 0x7D	; 125
    49da:	f6 4f       	sbci	r31, 0xF6	; 246
    49dc:	d9 01       	movw	r26, r18
    49de:	a7 51       	subi	r26, 0x17	; 23
    49e0:	b4 4f       	sbci	r27, 0xF4	; 244
    49e2:	8c 91       	ld	r24, X
    49e4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    49e6:	2f 5f       	subi	r18, 0xFF	; 255
    49e8:	3f 4f       	sbci	r19, 0xFF	; 255
    49ea:	24 31       	cpi	r18, 0x14	; 20
    49ec:	31 05       	cpc	r19, r1
    49ee:	99 f7       	brne	.-26     	; 0x49d6 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    49f0:	10 92 97 09 	sts	0x0997, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    49f4:	83 e8       	ldi	r24, 0x83	; 131
    49f6:	99 e0       	ldi	r25, 0x09	; 9
    49f8:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		 _uart_print(0,1,strCompName);
		 
_uart_print(0,1,strCardID);
*/	
     return Result;
}
    49fc:	81 2f       	mov	r24, r17
    49fe:	8f 52       	subi	r24, 0x2F	; 47
    4a00:	1f 91       	pop	r17
    4a02:	08 95       	ret

00004a04 <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    4a04:	20 e0       	ldi	r18, 0x00	; 0
    4a06:	30 e0       	ldi	r19, 0x00	; 0
    4a08:	06 c0       	rjmp	.+12     	; 0x4a16 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    4a0a:	fc 01       	movw	r30, r24
    4a0c:	e2 0f       	add	r30, r18
    4a0e:	f3 1f       	adc	r31, r19
    4a10:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    4a12:	2f 5f       	subi	r18, 0xFF	; 255
    4a14:	3f 4f       	sbci	r19, 0xFF	; 255
    4a16:	fc 01       	movw	r30, r24
    4a18:	01 90       	ld	r0, Z+
    4a1a:	00 20       	and	r0, r0
    4a1c:	e9 f7       	brne	.-6      	; 0x4a18 <clearString+0x14>
    4a1e:	31 97       	sbiw	r30, 0x01	; 1
    4a20:	e8 1b       	sub	r30, r24
    4a22:	f9 0b       	sbc	r31, r25
    4a24:	2e 17       	cp	r18, r30
    4a26:	3f 07       	cpc	r19, r31
    4a28:	80 f3       	brcs	.-32     	; 0x4a0a <clearString+0x6>
	    str[i]=0;
	 }
}
    4a2a:	08 95       	ret

00004a2c <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4a2c:	bf 92       	push	r11
    4a2e:	cf 92       	push	r12
    4a30:	df 92       	push	r13
    4a32:	ef 92       	push	r14
    4a34:	ff 92       	push	r15
    4a36:	0f 93       	push	r16
    4a38:	1f 93       	push	r17
    4a3a:	df 93       	push	r29
    4a3c:	cf 93       	push	r28
    4a3e:	cd b7       	in	r28, 0x3d	; 61
    4a40:	de b7       	in	r29, 0x3e	; 62
    4a42:	6e 97       	sbiw	r28, 0x1e	; 30
    4a44:	0f b6       	in	r0, 0x3f	; 63
    4a46:	f8 94       	cli
    4a48:	de bf       	out	0x3e, r29	; 62
    4a4a:	0f be       	out	0x3f, r0	; 63
    4a4c:	cd bf       	out	0x3d, r28	; 61
    4a4e:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    4a50:	fc 01       	movw	r30, r24
    4a52:	01 90       	ld	r0, Z+
    4a54:	00 20       	and	r0, r0
    4a56:	e9 f7       	brne	.-6      	; 0x4a52 <AddZeroLead+0x26>
    4a58:	31 97       	sbiw	r30, 0x01	; 1
    4a5a:	2e 2f       	mov	r18, r30
    4a5c:	28 1b       	sub	r18, r24

	 if (Size>Length){
    4a5e:	26 17       	cp	r18, r22
    4a60:	e0 f5       	brcc	.+120    	; 0x4ada <AddZeroLead+0xae>
    4a62:	7e 01       	movw	r14, r28
    4a64:	08 94       	sec
    4a66:	e1 1c       	adc	r14, r1
    4a68:	f1 1c       	adc	r15, r1
    4a6a:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4a6c:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    4a6e:	90 e3       	ldi	r25, 0x30	; 48
    4a70:	01 c0       	rjmp	.+2      	; 0x4a74 <AddZeroLead+0x48>
    4a72:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    4a74:	8e 2f       	mov	r24, r30
    4a76:	8b 19       	sub	r24, r11
    4a78:	86 17       	cp	r24, r22
    4a7a:	d8 f3       	brcs	.-10     	; 0x4a72 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    4a7c:	46 2f       	mov	r20, r22
    4a7e:	50 e0       	ldi	r21, 0x00	; 0
    4a80:	ce 01       	movw	r24, r28
    4a82:	01 96       	adiw	r24, 0x01	; 1
    4a84:	fc 01       	movw	r30, r24
    4a86:	e4 0f       	add	r30, r20
    4a88:	f5 1f       	adc	r31, r21
    4a8a:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4a8c:	76 2f       	mov	r23, r22
    4a8e:	72 1b       	sub	r23, r18
    4a90:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    4a92:	30 e0       	ldi	r19, 0x00	; 0
    4a94:	24 1b       	sub	r18, r20
    4a96:	35 0b       	sbc	r19, r21
    4a98:	0c c0       	rjmp	.+24     	; 0x4ab2 <AddZeroLead+0x86>
    4a9a:	e7 2f       	mov	r30, r23
    4a9c:	f0 e0       	ldi	r31, 0x00	; 0
    4a9e:	d6 01       	movw	r26, r12
    4aa0:	ae 0f       	add	r26, r30
    4aa2:	bf 1f       	adc	r27, r31
    4aa4:	e0 0f       	add	r30, r16
    4aa6:	f1 1f       	adc	r31, r17
    4aa8:	e2 0f       	add	r30, r18
    4aaa:	f3 1f       	adc	r31, r19
    4aac:	80 81       	ld	r24, Z
    4aae:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4ab0:	7f 5f       	subi	r23, 0xFF	; 255
    4ab2:	76 17       	cp	r23, r22
    4ab4:	90 f3       	brcs	.-28     	; 0x4a9a <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    4ab6:	4c 0d       	add	r20, r12
    4ab8:	5d 1d       	adc	r21, r13
    4aba:	da 01       	movw	r26, r20
    4abc:	1c 92       	st	X, r1
    4abe:	f8 01       	movw	r30, r16
    4ac0:	04 c0       	rjmp	.+8      	; 0x4aca <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    4ac2:	d7 01       	movw	r26, r14
    4ac4:	8d 91       	ld	r24, X+
    4ac6:	7d 01       	movw	r14, r26
    4ac8:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    4aca:	8e 2d       	mov	r24, r14
    4acc:	8b 19       	sub	r24, r11
    4ace:	86 17       	cp	r24, r22
    4ad0:	c0 f3       	brcs	.-16     	; 0x4ac2 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    4ad2:	06 0f       	add	r16, r22
    4ad4:	11 1d       	adc	r17, r1
    4ad6:	f8 01       	movw	r30, r16
    4ad8:	10 82       	st	Z, r1
	 }
}
    4ada:	6e 96       	adiw	r28, 0x1e	; 30
    4adc:	0f b6       	in	r0, 0x3f	; 63
    4ade:	f8 94       	cli
    4ae0:	de bf       	out	0x3e, r29	; 62
    4ae2:	0f be       	out	0x3f, r0	; 63
    4ae4:	cd bf       	out	0x3d, r28	; 61
    4ae6:	cf 91       	pop	r28
    4ae8:	df 91       	pop	r29
    4aea:	1f 91       	pop	r17
    4aec:	0f 91       	pop	r16
    4aee:	ff 90       	pop	r15
    4af0:	ef 90       	pop	r14
    4af2:	df 90       	pop	r13
    4af4:	cf 90       	pop	r12
    4af6:	bf 90       	pop	r11
    4af8:	08 95       	ret

00004afa <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    4afa:	0f 93       	push	r16
    4afc:	1f 93       	push	r17
    4afe:	cf 93       	push	r28
    4b00:	df 93       	push	r29
    4b02:	18 2f       	mov	r17, r24
    4b04:	06 2f       	mov	r16, r22
    4b06:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    4b08:	ca 01       	movw	r24, r20
    4b0a:	6d e0       	ldi	r22, 0x0D	; 13
    4b0c:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4b10:	81 2f       	mov	r24, r17
    4b12:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
    4b16:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4b18:	88 23       	and	r24, r24
    4b1a:	39 f0       	breq	.+14     	; 0x4b2a <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4b1c:	41 50       	subi	r20, 0x01	; 1
    4b1e:	81 e0       	ldi	r24, 0x01	; 1
    4b20:	61 e0       	ldi	r22, 0x01	; 1
    4b22:	20 2f       	mov	r18, r16
    4b24:	8e 01       	movw	r16, r28
    4b26:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    4b2a:	df 91       	pop	r29
    4b2c:	cf 91       	pop	r28
    4b2e:	1f 91       	pop	r17
    4b30:	0f 91       	pop	r16
    4b32:	08 95       	ret

00004b34 <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    4b34:	0f 93       	push	r16
    4b36:	1f 93       	push	r17
    4b38:	cf 93       	push	r28
    4b3a:	df 93       	push	r29
    4b3c:	18 2f       	mov	r17, r24
    4b3e:	06 2f       	mov	r16, r22
    4b40:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    4b42:	ca 01       	movw	r24, r20
    4b44:	6b e0       	ldi	r22, 0x0B	; 11
    4b46:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4b4a:	81 2f       	mov	r24, r17
    4b4c:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
    4b50:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4b52:	88 23       	and	r24, r24
    4b54:	39 f0       	breq	.+14     	; 0x4b64 <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4b56:	41 50       	subi	r20, 0x01	; 1
    4b58:	80 e0       	ldi	r24, 0x00	; 0
    4b5a:	61 e0       	ldi	r22, 0x01	; 1
    4b5c:	20 2f       	mov	r18, r16
    4b5e:	8e 01       	movw	r16, r28
    4b60:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    4b64:	df 91       	pop	r29
    4b66:	cf 91       	pop	r28
    4b68:	1f 91       	pop	r17
    4b6a:	0f 91       	pop	r16
    4b6c:	08 95       	ret

00004b6e <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    4b6e:	ef 92       	push	r14
    4b70:	ff 92       	push	r15
    4b72:	0f 93       	push	r16
    4b74:	1f 93       	push	r17
    4b76:	08 2f       	mov	r16, r24
    4b78:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4b7a:	cb 01       	movw	r24, r22
    4b7c:	6a e0       	ldi	r22, 0x0A	; 10
    4b7e:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    4b82:	00 d0       	rcall	.+0      	; 0x4b84 <GetTransactionMoney+0x16>
    4b84:	00 d0       	rcall	.+0      	; 0x4b86 <GetTransactionMoney+0x18>
    4b86:	00 d0       	rcall	.+0      	; 0x4b88 <GetTransactionMoney+0x1a>
    4b88:	ed b7       	in	r30, 0x3d	; 61
    4b8a:	fe b7       	in	r31, 0x3e	; 62
    4b8c:	31 96       	adiw	r30, 0x01	; 1
    4b8e:	ad b7       	in	r26, 0x3d	; 61
    4b90:	be b7       	in	r27, 0x3e	; 62
    4b92:	12 96       	adiw	r26, 0x02	; 2
    4b94:	fc 92       	st	X, r15
    4b96:	ee 92       	st	-X, r14
    4b98:	11 97       	sbiw	r26, 0x01	; 1
    4b9a:	85 ee       	ldi	r24, 0xE5	; 229
    4b9c:	93 e0       	ldi	r25, 0x03	; 3
    4b9e:	93 83       	std	Z+3, r25	; 0x03
    4ba0:	82 83       	std	Z+2, r24	; 0x02
    4ba2:	10 e0       	ldi	r17, 0x00	; 0
    4ba4:	0f 70       	andi	r16, 0x0F	; 15
    4ba6:	10 70       	andi	r17, 0x00	; 0
    4ba8:	85 e3       	ldi	r24, 0x35	; 53
    4baa:	90 e0       	ldi	r25, 0x00	; 0
    4bac:	9c 01       	movw	r18, r24
    4bae:	02 9f       	mul	r16, r18
    4bb0:	c0 01       	movw	r24, r0
    4bb2:	03 9f       	mul	r16, r19
    4bb4:	90 0d       	add	r25, r0
    4bb6:	12 9f       	mul	r17, r18
    4bb8:	90 0d       	add	r25, r0
    4bba:	11 24       	eor	r1, r1
    4bbc:	82 52       	subi	r24, 0x22	; 34
    4bbe:	98 4f       	sbci	r25, 0xF8	; 248
    4bc0:	95 83       	std	Z+5, r25	; 0x05
    4bc2:	84 83       	std	Z+4, r24	; 0x04
    4bc4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    4bc8:	8d b7       	in	r24, 0x3d	; 61
    4bca:	9e b7       	in	r25, 0x3e	; 62
    4bcc:	06 96       	adiw	r24, 0x06	; 6
    4bce:	0f b6       	in	r0, 0x3f	; 63
    4bd0:	f8 94       	cli
    4bd2:	9e bf       	out	0x3e, r25	; 62
    4bd4:	0f be       	out	0x3f, r0	; 63
    4bd6:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    4bd8:	1f 91       	pop	r17
    4bda:	0f 91       	pop	r16
    4bdc:	ff 90       	pop	r15
    4bde:	ef 90       	pop	r14
    4be0:	08 95       	ret

00004be2 <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    4be2:	ef 92       	push	r14
    4be4:	ff 92       	push	r15
    4be6:	0f 93       	push	r16
    4be8:	1f 93       	push	r17
    4bea:	08 2f       	mov	r16, r24
    4bec:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4bee:	cb 01       	movw	r24, r22
    4bf0:	6a e0       	ldi	r22, 0x0A	; 10
    4bf2:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    4bf6:	00 d0       	rcall	.+0      	; 0x4bf8 <GetTransactionVolume+0x16>
    4bf8:	00 d0       	rcall	.+0      	; 0x4bfa <GetTransactionVolume+0x18>
    4bfa:	00 d0       	rcall	.+0      	; 0x4bfc <GetTransactionVolume+0x1a>
    4bfc:	ed b7       	in	r30, 0x3d	; 61
    4bfe:	fe b7       	in	r31, 0x3e	; 62
    4c00:	31 96       	adiw	r30, 0x01	; 1
    4c02:	ad b7       	in	r26, 0x3d	; 61
    4c04:	be b7       	in	r27, 0x3e	; 62
    4c06:	12 96       	adiw	r26, 0x02	; 2
    4c08:	fc 92       	st	X, r15
    4c0a:	ee 92       	st	-X, r14
    4c0c:	11 97       	sbiw	r26, 0x01	; 1
    4c0e:	88 ee       	ldi	r24, 0xE8	; 232
    4c10:	93 e0       	ldi	r25, 0x03	; 3
    4c12:	93 83       	std	Z+3, r25	; 0x03
    4c14:	82 83       	std	Z+2, r24	; 0x02
    4c16:	10 e0       	ldi	r17, 0x00	; 0
    4c18:	0f 70       	andi	r16, 0x0F	; 15
    4c1a:	10 70       	andi	r17, 0x00	; 0
    4c1c:	85 e3       	ldi	r24, 0x35	; 53
    4c1e:	90 e0       	ldi	r25, 0x00	; 0
    4c20:	9c 01       	movw	r18, r24
    4c22:	02 9f       	mul	r16, r18
    4c24:	c0 01       	movw	r24, r0
    4c26:	03 9f       	mul	r16, r19
    4c28:	90 0d       	add	r25, r0
    4c2a:	12 9f       	mul	r17, r18
    4c2c:	90 0d       	add	r25, r0
    4c2e:	11 24       	eor	r1, r1
    4c30:	8b 52       	subi	r24, 0x2B	; 43
    4c32:	98 4f       	sbci	r25, 0xF8	; 248
    4c34:	95 83       	std	Z+5, r25	; 0x05
    4c36:	84 83       	std	Z+4, r24	; 0x04
    4c38:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    4c3c:	8d b7       	in	r24, 0x3d	; 61
    4c3e:	9e b7       	in	r25, 0x3e	; 62
    4c40:	06 96       	adiw	r24, 0x06	; 6
    4c42:	0f b6       	in	r0, 0x3f	; 63
    4c44:	f8 94       	cli
    4c46:	9e bf       	out	0x3e, r25	; 62
    4c48:	0f be       	out	0x3f, r0	; 63
    4c4a:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    4c4c:	1f 91       	pop	r17
    4c4e:	0f 91       	pop	r16
    4c50:	ff 90       	pop	r15
    4c52:	ef 90       	pop	r14
    4c54:	08 95       	ret

00004c56 <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    4c56:	cf 93       	push	r28
    4c58:	df 93       	push	r29
    4c5a:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    4c5c:	dc 01       	movw	r26, r24
    4c5e:	0d 90       	ld	r0, X+
    4c60:	00 20       	and	r0, r0
    4c62:	e9 f7       	brne	.-6      	; 0x4c5e <AddZeroLag+0x8>
    4c64:	11 97       	sbiw	r26, 0x01	; 1
    4c66:	a8 1b       	sub	r26, r24
    4c68:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    4c6a:	a6 17       	cp	r26, r22
    4c6c:	60 f4       	brcc	.+24     	; 0x4c86 <AddZeroLag+0x30>
    4c6e:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    4c70:	90 e3       	ldi	r25, 0x30	; 48
    4c72:	fe 01       	movw	r30, r28
    4c74:	e8 0f       	add	r30, r24
    4c76:	f1 1d       	adc	r31, r1
    4c78:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    4c7a:	8f 5f       	subi	r24, 0xFF	; 255
    4c7c:	86 17       	cp	r24, r22
    4c7e:	c8 f3       	brcs	.-14     	; 0x4c72 <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    4c80:	c6 0f       	add	r28, r22
    4c82:	d1 1d       	adc	r29, r1
    4c84:	18 82       	st	Y, r1
  }
}
    4c86:	df 91       	pop	r29
    4c88:	cf 91       	pop	r28
    4c8a:	08 95       	ret

00004c8c <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4c8c:	2f 92       	push	r2
    4c8e:	3f 92       	push	r3
    4c90:	4f 92       	push	r4
    4c92:	5f 92       	push	r5
    4c94:	6f 92       	push	r6
    4c96:	7f 92       	push	r7
    4c98:	8f 92       	push	r8
    4c9a:	9f 92       	push	r9
    4c9c:	af 92       	push	r10
    4c9e:	bf 92       	push	r11
    4ca0:	cf 92       	push	r12
    4ca2:	df 92       	push	r13
    4ca4:	ef 92       	push	r14
    4ca6:	ff 92       	push	r15
    4ca8:	0f 93       	push	r16
    4caa:	1f 93       	push	r17
    4cac:	df 93       	push	r29
    4cae:	cf 93       	push	r28
    4cb0:	cd b7       	in	r28, 0x3d	; 61
    4cb2:	de b7       	in	r29, 0x3e	; 62
    4cb4:	c6 55       	subi	r28, 0x56	; 86
    4cb6:	d0 40       	sbci	r29, 0x00	; 0
    4cb8:	0f b6       	in	r0, 0x3f	; 63
    4cba:	f8 94       	cli
    4cbc:	de bf       	out	0x3e, r29	; 62
    4cbe:	0f be       	out	0x3f, r0	; 63
    4cc0:	cd bf       	out	0x3d, r28	; 61
    4cc2:	68 2e       	mov	r6, r24
    4cc4:	1b 01       	movw	r2, r22
    4cc6:	67 96       	adiw	r28, 0x17	; 23
    4cc8:	5f af       	std	Y+63, r21	; 0x3f
    4cca:	4e af       	std	Y+62, r20	; 0x3e
    4ccc:	67 97       	sbiw	r28, 0x17	; 23
    4cce:	59 01       	movw	r10, r18
    4cd0:	fe 01       	movw	r30, r28
    4cd2:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4cd4:	ce 01       	movw	r24, r28
    4cd6:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    4cd8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4cda:	e8 17       	cp	r30, r24
    4cdc:	f9 07       	cpc	r31, r25
    4cde:	e1 f7       	brne	.-8      	; 0x4cd8 <StrCalc+0x4c>
	     strMemory[i]=data;
    4ce0:	ce 01       	movw	r24, r28
    4ce2:	89 96       	adiw	r24, 0x29	; 41
    4ce4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4ce6:	e8 17       	cp	r30, r24
    4ce8:	f9 07       	cpc	r31, r25
    4cea:	e1 f7       	brne	.-8      	; 0x4ce4 <StrCalc+0x58>
    4cec:	fe 01       	movw	r30, r28
    4cee:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    4cf0:	cf 01       	movw	r24, r30
    4cf2:	44 96       	adiw	r24, 0x14	; 20
    4cf4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4cf6:	e8 17       	cp	r30, r24
    4cf8:	f9 07       	cpc	r31, r25
    4cfa:	e1 f7       	brne	.-8      	; 0x4cf4 <StrCalc+0x68>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    4cfc:	00 d0       	rcall	.+0      	; 0x4cfe <StrCalc+0x72>
    4cfe:	00 d0       	rcall	.+0      	; 0x4d00 <StrCalc+0x74>
    4d00:	00 d0       	rcall	.+0      	; 0x4d02 <StrCalc+0x76>
    4d02:	ed b7       	in	r30, 0x3d	; 61
    4d04:	fe b7       	in	r31, 0x3e	; 62
    4d06:	31 96       	adiw	r30, 0x01	; 1
    4d08:	8e 01       	movw	r16, r28
    4d0a:	0f 5f       	subi	r16, 0xFF	; 255
    4d0c:	1f 4f       	sbci	r17, 0xFF	; 255
    4d0e:	ad b7       	in	r26, 0x3d	; 61
    4d10:	be b7       	in	r27, 0x3e	; 62
    4d12:	12 96       	adiw	r26, 0x02	; 2
    4d14:	1c 93       	st	X, r17
    4d16:	0e 93       	st	-X, r16
    4d18:	11 97       	sbiw	r26, 0x01	; 1
    4d1a:	83 e3       	ldi	r24, 0x33	; 51
    4d1c:	96 e0       	ldi	r25, 0x06	; 6
    4d1e:	93 83       	std	Z+3, r25	; 0x03
    4d20:	82 83       	std	Z+2, r24	; 0x02
    4d22:	35 82       	std	Z+5, r3	; 0x05
    4d24:	24 82       	std	Z+4, r2	; 0x04
    4d26:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    4d2a:	ed b7       	in	r30, 0x3d	; 61
    4d2c:	fe b7       	in	r31, 0x3e	; 62
    4d2e:	31 96       	adiw	r30, 0x01	; 1
    4d30:	ce 01       	movw	r24, r28
    4d32:	45 96       	adiw	r24, 0x15	; 21
    4d34:	ad b7       	in	r26, 0x3d	; 61
    4d36:	be b7       	in	r27, 0x3e	; 62
    4d38:	12 96       	adiw	r26, 0x02	; 2
    4d3a:	9c 93       	st	X, r25
    4d3c:	8e 93       	st	-X, r24
    4d3e:	11 97       	sbiw	r26, 0x01	; 1
    4d40:	80 e3       	ldi	r24, 0x30	; 48
    4d42:	96 e0       	ldi	r25, 0x06	; 6
    4d44:	93 83       	std	Z+3, r25	; 0x03
    4d46:	82 83       	std	Z+2, r24	; 0x02
    4d48:	67 96       	adiw	r28, 0x17	; 23
    4d4a:	2e ad       	ldd	r18, Y+62	; 0x3e
    4d4c:	3f ad       	ldd	r19, Y+63	; 0x3f
    4d4e:	67 97       	sbiw	r28, 0x17	; 23
    4d50:	35 83       	std	Z+5, r19	; 0x05
    4d52:	24 83       	std	Z+4, r18	; 0x04
    4d54:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>

     if (IsMinus(tmpA)==True){
    4d58:	8d b7       	in	r24, 0x3d	; 61
    4d5a:	9e b7       	in	r25, 0x3e	; 62
    4d5c:	06 96       	adiw	r24, 0x06	; 6
    4d5e:	0f b6       	in	r0, 0x3f	; 63
    4d60:	f8 94       	cli
    4d62:	9e bf       	out	0x3e, r25	; 62
    4d64:	0f be       	out	0x3f, r0	; 63
    4d66:	8d bf       	out	0x3d, r24	; 61
    4d68:	c8 01       	movw	r24, r16
    4d6a:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <IsMinus>
    4d6e:	81 30       	cpi	r24, 0x01	; 1
    4d70:	21 f0       	breq	.+8      	; 0x4d7a <StrCalc+0xee>
    4d72:	65 96       	adiw	r28, 0x15	; 21
    4d74:	1f ae       	std	Y+63, r1	; 0x3f
    4d76:	65 97       	sbiw	r28, 0x15	; 21
    4d78:	07 c0       	rjmp	.+14     	; 0x4d88 <StrCalc+0xfc>
	     RemoveMinus(tmpA);
    4d7a:	c8 01       	movw	r24, r16
    4d7c:	0e 94 f7 20 	call	0x41ee	; 0x41ee <RemoveMinus>
    4d80:	91 e0       	ldi	r25, 0x01	; 1
    4d82:	65 96       	adiw	r28, 0x15	; 21
    4d84:	9f af       	std	Y+63, r25	; 0x3f
    4d86:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    4d88:	8e 01       	movw	r16, r28
    4d8a:	0b 5e       	subi	r16, 0xEB	; 235
    4d8c:	1f 4f       	sbci	r17, 0xFF	; 255
    4d8e:	c8 01       	movw	r24, r16
    4d90:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <IsMinus>
    4d94:	81 30       	cpi	r24, 0x01	; 1
    4d96:	21 f0       	breq	.+8      	; 0x4da0 <StrCalc+0x114>
    4d98:	64 96       	adiw	r28, 0x14	; 20
    4d9a:	1f ae       	std	Y+63, r1	; 0x3f
    4d9c:	64 97       	sbiw	r28, 0x14	; 20
    4d9e:	07 c0       	rjmp	.+14     	; 0x4dae <StrCalc+0x122>
	     RemoveMinus(tmpB);
    4da0:	c8 01       	movw	r24, r16
    4da2:	0e 94 f7 20 	call	0x41ee	; 0x41ee <RemoveMinus>
    4da6:	a1 e0       	ldi	r26, 0x01	; 1
    4da8:	64 96       	adiw	r28, 0x14	; 20
    4daa:	af af       	std	Y+63, r26	; 0x3f
    4dac:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    4dae:	fe 01       	movw	r30, r28
    4db0:	31 96       	adiw	r30, 0x01	; 1
    4db2:	df 01       	movw	r26, r30
    4db4:	0d 90       	ld	r0, X+
    4db6:	00 20       	and	r0, r0
    4db8:	e9 f7       	brne	.-6      	; 0x4db4 <StrCalc+0x128>
    4dba:	cd 01       	movw	r24, r26
    4dbc:	01 97       	sbiw	r24, 0x01	; 1
    4dbe:	8e 1b       	sub	r24, r30
    4dc0:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    4dc2:	de 01       	movw	r26, r28
    4dc4:	55 96       	adiw	r26, 0x15	; 21
    4dc6:	fd 01       	movw	r30, r26
    4dc8:	01 90       	ld	r0, Z+
    4dca:	00 20       	and	r0, r0
    4dcc:	e9 f7       	brne	.-6      	; 0x4dc8 <StrCalc+0x13c>
    4dce:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 _uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    4dd0:	1e 2f       	mov	r17, r30
    4dd2:	1a 1b       	sub	r17, r26
    4dd4:	18 17       	cp	r17, r24
    4dd6:	08 f4       	brcc	.+2      	; 0x4dda <StrCalc+0x14e>
    4dd8:	18 2f       	mov	r17, r24
    4dda:	1f 5f       	subi	r17, 0xFF	; 255
    4ddc:	7e 01       	movw	r14, r28
    4dde:	08 94       	sec
    4de0:	e1 1c       	adc	r14, r1
    4de2:	f1 1c       	adc	r15, r1
    4de4:	c7 01       	movw	r24, r14
    4de6:	61 2f       	mov	r22, r17
    4de8:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    4dec:	f5 e1       	ldi	r31, 0x15	; 21
    4dee:	cf 2e       	mov	r12, r31
    4df0:	d1 2c       	mov	r13, r1
    4df2:	cc 0e       	add	r12, r28
    4df4:	dd 1e       	adc	r13, r29
    4df6:	c6 01       	movw	r24, r12
    4df8:	61 2f       	mov	r22, r17
    4dfa:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <AddZeroLead>
	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 _uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    4dfe:	f7 01       	movw	r30, r14
    4e00:	01 90       	ld	r0, Z+
    4e02:	00 20       	and	r0, r0
    4e04:	e9 f7       	brne	.-6      	; 0x4e00 <StrCalc+0x174>
    4e06:	31 97       	sbiw	r30, 0x01	; 1
    4e08:	7e 2e       	mov	r7, r30
    4e0a:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    4e0c:	f6 01       	movw	r30, r12
    4e0e:	01 90       	ld	r0, Z+
    4e10:	00 20       	and	r0, r0
    4e12:	e9 f7       	brne	.-6      	; 0x4e0e <StrCalc+0x182>
    4e14:	31 97       	sbiw	r30, 0x01	; 1
    4e16:	9e 2e       	mov	r9, r30
    4e18:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    4e1a:	c6 01       	movw	r24, r12
    4e1c:	b7 01       	movw	r22, r14
    4e1e:	0e 94 24 21 	call	0x4248	; 0x4248 <IsMoreThan>
    4e22:	81 30       	cpi	r24, 0x01	; 1
    4e24:	11 f0       	breq	.+4      	; 0x4e2a <StrCalc+0x19e>
    4e26:	80 e0       	ldi	r24, 0x00	; 0
    4e28:	42 c0       	rjmp	.+132    	; 0x4eae <StrCalc+0x222>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    4e2a:	00 d0       	rcall	.+0      	; 0x4e2c <StrCalc+0x1a0>
    4e2c:	00 d0       	rcall	.+0      	; 0x4e2e <StrCalc+0x1a2>
    4e2e:	00 d0       	rcall	.+0      	; 0x4e30 <StrCalc+0x1a4>
    4e30:	ed b7       	in	r30, 0x3d	; 61
    4e32:	fe b7       	in	r31, 0x3e	; 62
    4e34:	31 96       	adiw	r30, 0x01	; 1
    4e36:	8e 01       	movw	r16, r28
    4e38:	07 5d       	subi	r16, 0xD7	; 215
    4e3a:	1f 4f       	sbci	r17, 0xFF	; 255
    4e3c:	ad b7       	in	r26, 0x3d	; 61
    4e3e:	be b7       	in	r27, 0x3e	; 62
    4e40:	12 96       	adiw	r26, 0x02	; 2
    4e42:	1c 93       	st	X, r17
    4e44:	0e 93       	st	-X, r16
    4e46:	11 97       	sbiw	r26, 0x01	; 1
    4e48:	8d e2       	ldi	r24, 0x2D	; 45
    4e4a:	96 e0       	ldi	r25, 0x06	; 6
    4e4c:	93 83       	std	Z+3, r25	; 0x03
    4e4e:	82 83       	std	Z+2, r24	; 0x02
    4e50:	f5 82       	std	Z+5, r15	; 0x05
    4e52:	e4 82       	std	Z+4, r14	; 0x04
    4e54:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    4e58:	ed b7       	in	r30, 0x3d	; 61
    4e5a:	fe b7       	in	r31, 0x3e	; 62
    4e5c:	31 96       	adiw	r30, 0x01	; 1
    4e5e:	ad b7       	in	r26, 0x3d	; 61
    4e60:	be b7       	in	r27, 0x3e	; 62
    4e62:	12 96       	adiw	r26, 0x02	; 2
    4e64:	fc 92       	st	X, r15
    4e66:	ee 92       	st	-X, r14
    4e68:	11 97       	sbiw	r26, 0x01	; 1
    4e6a:	8a e2       	ldi	r24, 0x2A	; 42
    4e6c:	96 e0       	ldi	r25, 0x06	; 6
    4e6e:	93 83       	std	Z+3, r25	; 0x03
    4e70:	82 83       	std	Z+2, r24	; 0x02
    4e72:	d5 82       	std	Z+5, r13	; 0x05
    4e74:	c4 82       	std	Z+4, r12	; 0x04
    4e76:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    4e7a:	ed b7       	in	r30, 0x3d	; 61
    4e7c:	fe b7       	in	r31, 0x3e	; 62
    4e7e:	31 96       	adiw	r30, 0x01	; 1
    4e80:	ad b7       	in	r26, 0x3d	; 61
    4e82:	be b7       	in	r27, 0x3e	; 62
    4e84:	12 96       	adiw	r26, 0x02	; 2
    4e86:	dc 92       	st	X, r13
    4e88:	ce 92       	st	-X, r12
    4e8a:	11 97       	sbiw	r26, 0x01	; 1
    4e8c:	87 e2       	ldi	r24, 0x27	; 39
    4e8e:	96 e0       	ldi	r25, 0x06	; 6
    4e90:	93 83       	std	Z+3, r25	; 0x03
    4e92:	82 83       	std	Z+2, r24	; 0x02
    4e94:	15 83       	std	Z+5, r17	; 0x05
    4e96:	04 83       	std	Z+4, r16	; 0x04
    4e98:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    4e9c:	81 e0       	ldi	r24, 0x01	; 1
    4e9e:	ed b7       	in	r30, 0x3d	; 61
    4ea0:	fe b7       	in	r31, 0x3e	; 62
    4ea2:	36 96       	adiw	r30, 0x06	; 6
    4ea4:	0f b6       	in	r0, 0x3f	; 63
    4ea6:	f8 94       	cli
    4ea8:	fe bf       	out	0x3e, r31	; 62
    4eaa:	0f be       	out	0x3f, r0	; 63
    4eac:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    4eae:	66 20       	and	r6, r6
    4eb0:	39 f5       	brne	.+78     	; 0x4f00 <StrCalc+0x274>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    4eb2:	81 30       	cpi	r24, 0x01	; 1
    4eb4:	99 f4       	brne	.+38     	; 0x4edc <StrCalc+0x250>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    4eb6:	65 96       	adiw	r28, 0x15	; 21
    4eb8:	ff ad       	ldd	r31, Y+63	; 0x3f
    4eba:	65 97       	sbiw	r28, 0x15	; 21
    4ebc:	f1 30       	cpi	r31, 0x01	; 1
    4ebe:	39 f4       	brne	.+14     	; 0x4ece <StrCalc+0x242>
    4ec0:	64 96       	adiw	r28, 0x14	; 20
    4ec2:	2f ad       	ldd	r18, Y+63	; 0x3f
    4ec4:	64 97       	sbiw	r28, 0x14	; 20
    4ec6:	21 30       	cpi	r18, 0x01	; 1
    4ec8:	09 f0       	breq	.+2      	; 0x4ecc <StrCalc+0x240>
    4eca:	90 c1       	rjmp	.+800    	; 0x51ec <StrCalc+0x560>
    4ecc:	42 c0       	rjmp	.+132    	; 0x4f52 <StrCalc+0x2c6>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    4ece:	64 96       	adiw	r28, 0x14	; 20
    4ed0:	3f ad       	ldd	r19, Y+63	; 0x3f
    4ed2:	64 97       	sbiw	r28, 0x14	; 20
    4ed4:	31 30       	cpi	r19, 0x01	; 1
    4ed6:	09 f0       	breq	.+2      	; 0x4eda <StrCalc+0x24e>
    4ed8:	80 c1       	rjmp	.+768    	; 0x51da <StrCalc+0x54e>
    4eda:	84 c1       	rjmp	.+776    	; 0x51e4 <StrCalc+0x558>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    4edc:	65 96       	adiw	r28, 0x15	; 21
    4ede:	8f ad       	ldd	r24, Y+63	; 0x3f
    4ee0:	65 97       	sbiw	r28, 0x15	; 21
    4ee2:	81 30       	cpi	r24, 0x01	; 1
    4ee4:	39 f4       	brne	.+14     	; 0x4ef4 <StrCalc+0x268>
    4ee6:	64 96       	adiw	r28, 0x14	; 20
    4ee8:	9f ad       	ldd	r25, Y+63	; 0x3f
    4eea:	64 97       	sbiw	r28, 0x14	; 20
    4eec:	91 30       	cpi	r25, 0x01	; 1
    4eee:	09 f0       	breq	.+2      	; 0x4ef2 <StrCalc+0x266>
    4ef0:	7d c1       	rjmp	.+762    	; 0x51ec <StrCalc+0x560>
    4ef2:	73 c1       	rjmp	.+742    	; 0x51da <StrCalc+0x54e>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    4ef4:	64 96       	adiw	r28, 0x14	; 20
    4ef6:	af ad       	ldd	r26, Y+63	; 0x3f
    4ef8:	64 97       	sbiw	r28, 0x14	; 20
    4efa:	a1 30       	cpi	r26, 0x01	; 1
    4efc:	51 f5       	brne	.+84     	; 0x4f52 <StrCalc+0x2c6>
    4efe:	72 c1       	rjmp	.+740    	; 0x51e4 <StrCalc+0x558>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    4f00:	b1 e0       	ldi	r27, 0x01	; 1
    4f02:	6b 16       	cp	r6, r27
    4f04:	31 f5       	brne	.+76     	; 0x4f52 <StrCalc+0x2c6>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    4f06:	81 30       	cpi	r24, 0x01	; 1
    4f08:	91 f4       	brne	.+36     	; 0x4f2e <StrCalc+0x2a2>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    4f0a:	65 96       	adiw	r28, 0x15	; 21
    4f0c:	ef ad       	ldd	r30, Y+63	; 0x3f
    4f0e:	65 97       	sbiw	r28, 0x15	; 21
    4f10:	e1 30       	cpi	r30, 0x01	; 1
    4f12:	31 f4       	brne	.+12     	; 0x4f20 <StrCalc+0x294>
    4f14:	64 96       	adiw	r28, 0x14	; 20
    4f16:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f18:	64 97       	sbiw	r28, 0x14	; 20
    4f1a:	f1 30       	cpi	r31, 0x01	; 1
    4f1c:	d1 f4       	brne	.+52     	; 0x4f52 <StrCalc+0x2c6>
    4f1e:	66 c1       	rjmp	.+716    	; 0x51ec <StrCalc+0x560>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    4f20:	64 96       	adiw	r28, 0x14	; 20
    4f22:	2f ad       	ldd	r18, Y+63	; 0x3f
    4f24:	64 97       	sbiw	r28, 0x14	; 20
    4f26:	21 30       	cpi	r18, 0x01	; 1
    4f28:	09 f0       	breq	.+2      	; 0x4f2c <StrCalc+0x2a0>
    4f2a:	5c c1       	rjmp	.+696    	; 0x51e4 <StrCalc+0x558>
    4f2c:	56 c1       	rjmp	.+684    	; 0x51da <StrCalc+0x54e>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    4f2e:	65 96       	adiw	r28, 0x15	; 21
    4f30:	3f ad       	ldd	r19, Y+63	; 0x3f
    4f32:	65 97       	sbiw	r28, 0x15	; 21
    4f34:	31 30       	cpi	r19, 0x01	; 1
    4f36:	39 f4       	brne	.+14     	; 0x4f46 <StrCalc+0x2ba>
    4f38:	64 96       	adiw	r28, 0x14	; 20
    4f3a:	8f ad       	ldd	r24, Y+63	; 0x3f
    4f3c:	64 97       	sbiw	r28, 0x14	; 20
    4f3e:	81 30       	cpi	r24, 0x01	; 1
    4f40:	09 f0       	breq	.+2      	; 0x4f44 <StrCalc+0x2b8>
    4f42:	4b c1       	rjmp	.+662    	; 0x51da <StrCalc+0x54e>
    4f44:	53 c1       	rjmp	.+678    	; 0x51ec <StrCalc+0x560>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    4f46:	64 96       	adiw	r28, 0x14	; 20
    4f48:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f4a:	64 97       	sbiw	r28, 0x14	; 20
    4f4c:	91 30       	cpi	r25, 0x01	; 1
    4f4e:	09 f0       	breq	.+2      	; 0x4f52 <StrCalc+0x2c6>
    4f50:	49 c1       	rjmp	.+658    	; 0x51e4 <StrCalc+0x558>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    4f52:	62 96       	adiw	r28, 0x12	; 18
    4f54:	1f ae       	std	Y+63, r1	; 0x3f
    4f56:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4f58:	e7 2c       	mov	r14, r7
    4f5a:	ff 24       	eor	r15, r15
    4f5c:	67 01       	movw	r12, r14
    4f5e:	08 94       	sec
    4f60:	c1 08       	sbc	r12, r1
    4f62:	d1 08       	sbc	r13, r1
    4f64:	ae 01       	movw	r20, r28
    4f66:	43 5c       	subi	r20, 0xC3	; 195
    4f68:	5f 4f       	sbci	r21, 0xFF	; 255
    4f6a:	4c 0d       	add	r20, r12
    4f6c:	5d 1d       	adc	r21, r13
    4f6e:	ce 01       	movw	r24, r28
    4f70:	01 96       	adiw	r24, 0x01	; 1
    4f72:	8c 01       	movw	r16, r24
    4f74:	0c 0d       	add	r16, r12
    4f76:	1d 1d       	adc	r17, r13
    4f78:	be 01       	movw	r22, r28
    4f7a:	69 0d       	add	r22, r9
    4f7c:	71 1d       	adc	r23, r1
    4f7e:	6c 5e       	subi	r22, 0xEC	; 236
    4f80:	7f 4f       	sbci	r23, 0xFF	; 255
    4f82:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    4f84:	2c 01       	movw	r4, r24
    4f86:	e9 e3       	ldi	r30, 0x39	; 57
    4f88:	8e 2e       	mov	r8, r30
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    4f8a:	9a e0       	ldi	r25, 0x0A	; 10
    4f8c:	52 c0       	rjmp	.+164    	; 0x5032 <StrCalc+0x3a6>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4f8e:	d8 01       	movw	r26, r16
    4f90:	8c 91       	ld	r24, X
    4f92:	80 53       	subi	r24, 0x30	; 48
    4f94:	8a 30       	cpi	r24, 0x0A	; 10
    4f96:	10 f0       	brcs	.+4      	; 0x4f9c <StrCalc+0x310>
    4f98:	20 e0       	ldi	r18, 0x00	; 0
    4f9a:	01 c0       	rjmp	.+2      	; 0x4f9e <StrCalc+0x312>
    4f9c:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    4f9e:	fb 01       	movw	r30, r22
    4fa0:	30 81       	ld	r19, Z
    4fa2:	30 53       	subi	r19, 0x30	; 48
    4fa4:	3a 30       	cpi	r19, 0x0A	; 10
    4fa6:	10 f4       	brcc	.+4      	; 0x4fac <StrCalc+0x320>
    4fa8:	23 17       	cp	r18, r19
    4faa:	40 f0       	brcs	.+16     	; 0x4fbc <StrCalc+0x330>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4fac:	8a 30       	cpi	r24, 0x0A	; 10
    4fae:	08 f0       	brcs	.+2      	; 0x4fb2 <StrCalc+0x326>
    4fb0:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    4fb2:	3a 30       	cpi	r19, 0x0A	; 10
    4fb4:	08 f0       	brcs	.+2      	; 0x4fb8 <StrCalc+0x32c>
    4fb6:	30 e0       	ldi	r19, 0x00	; 0
    4fb8:	83 1b       	sub	r24, r19
    4fba:	2d c0       	rjmp	.+90     	; 0x5016 <StrCalc+0x38a>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4fbc:	8a 30       	cpi	r24, 0x0A	; 10
    4fbe:	10 f4       	brcc	.+4      	; 0x4fc4 <StrCalc+0x338>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    4fc0:	83 17       	cp	r24, r19
    4fc2:	80 f5       	brcc	.+96     	; 0x5024 <StrCalc+0x398>
    4fc4:	29 2d       	mov	r18, r9
    4fc6:	0a c0       	rjmp	.+20     	; 0x4fdc <StrCalc+0x350>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    4fc8:	f6 01       	movw	r30, r12
    4fca:	e2 1b       	sub	r30, r18
    4fcc:	f1 09       	sbc	r31, r1
    4fce:	d2 01       	movw	r26, r4
    4fd0:	ae 0f       	add	r26, r30
    4fd2:	bf 1f       	adc	r27, r31
    4fd4:	8c 91       	ld	r24, X
    4fd6:	80 33       	cpi	r24, 0x30	; 48
    4fd8:	29 f4       	brne	.+10     	; 0x4fe4 <StrCalc+0x358>
    4fda:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    4fdc:	2f 5f       	subi	r18, 0xFF	; 255
    4fde:	27 15       	cp	r18, r7
    4fe0:	98 f3       	brcs	.-26     	; 0x4fc8 <StrCalc+0x33c>
    4fe2:	10 c0       	rjmp	.+32     	; 0x5004 <StrCalc+0x378>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4fe4:	28 2f       	mov	r18, r24
    4fe6:	20 53       	subi	r18, 0x30	; 48
    4fe8:	2a 30       	cpi	r18, 0x0A	; 10
    4fea:	08 f0       	brcs	.+2      	; 0x4fee <StrCalc+0x362>
    4fec:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    4fee:	82 2f       	mov	r24, r18
    4ff0:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4ff2:	8a 30       	cpi	r24, 0x0A	; 10
    4ff4:	10 f0       	brcs	.+4      	; 0x4ffa <StrCalc+0x36e>
    4ff6:	80 e3       	ldi	r24, 0x30	; 48
    4ff8:	02 c0       	rjmp	.+4      	; 0x4ffe <StrCalc+0x372>
	    Result='0'+X;
    4ffa:	82 2f       	mov	r24, r18
    4ffc:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    4ffe:	e4 0d       	add	r30, r4
    5000:	f5 1d       	adc	r31, r5
    5002:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5004:	f8 01       	movw	r30, r16
    5006:	20 81       	ld	r18, Z
    5008:	20 53       	subi	r18, 0x30	; 48
    500a:	2a 30       	cpi	r18, 0x0A	; 10
    500c:	08 f0       	brcs	.+2      	; 0x5010 <StrCalc+0x384>
    500e:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5010:	89 2f       	mov	r24, r25
    5012:	83 1b       	sub	r24, r19
    5014:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5016:	8a 30       	cpi	r24, 0x0A	; 10
    5018:	10 f0       	brcs	.+4      	; 0x501e <StrCalc+0x392>
    501a:	80 e3       	ldi	r24, 0x30	; 48
    501c:	01 c0       	rjmp	.+2      	; 0x5020 <StrCalc+0x394>
	    Result='0'+X;
    501e:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5020:	da 01       	movw	r26, r20
    5022:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    5024:	93 94       	inc	r9
    5026:	41 50       	subi	r20, 0x01	; 1
    5028:	50 40       	sbci	r21, 0x00	; 0
    502a:	01 50       	subi	r16, 0x01	; 1
    502c:	10 40       	sbci	r17, 0x00	; 0
    502e:	61 50       	subi	r22, 0x01	; 1
    5030:	70 40       	sbci	r23, 0x00	; 0
    5032:	97 14       	cp	r9, r7
    5034:	08 f4       	brcc	.+2      	; 0x5038 <StrCalc+0x3ac>
    5036:	ab cf       	rjmp	.-170    	; 0x4f8e <StrCalc+0x302>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    5038:	8e 01       	movw	r16, r28
    503a:	03 5c       	subi	r16, 0xC3	; 195
    503c:	1f 4f       	sbci	r17, 0xFF	; 255
    503e:	e0 0e       	add	r14, r16
    5040:	f1 1e       	adc	r15, r17
    5042:	f7 01       	movw	r30, r14
    5044:	10 82       	st	Z, r1
       RemZeroLead(Result);
    5046:	c8 01       	movw	r24, r16
    5048:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    504c:	f8 01       	movw	r30, r16
    504e:	01 90       	ld	r0, Z+
    5050:	00 20       	and	r0, r0
    5052:	e9 f7       	brne	.-6      	; 0x504e <StrCalc+0x3c2>
    5054:	31 97       	sbiw	r30, 0x01	; 1
    5056:	3e 2f       	mov	r19, r30
    5058:	30 1b       	sub	r19, r16
    505a:	d8 01       	movw	r26, r16
    505c:	20 e0       	ldi	r18, 0x00	; 0
    505e:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    5060:	4d e2       	ldi	r20, 0x2D	; 45
    5062:	13 c0       	rjmp	.+38     	; 0x508a <StrCalc+0x3fe>
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    5064:	22 23       	and	r18, r18
    5066:	51 f4       	brne	.+20     	; 0x507c <StrCalc+0x3f0>
    5068:	62 96       	adiw	r28, 0x12	; 18
    506a:	ff ad       	ldd	r31, Y+63	; 0x3f
    506c:	62 97       	sbiw	r28, 0x12	; 18
    506e:	f1 30       	cpi	r31, 0x01	; 1
    5070:	29 f4       	brne	.+10     	; 0x507c <StrCalc+0x3f0>
			     strC[iPos]='-';
    5072:	f5 01       	movw	r30, r10
    5074:	e9 0f       	add	r30, r25
    5076:	f1 1d       	adc	r31, r1
    5078:	40 83       	st	Z, r20
				 iPos++;
    507a:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    507c:	f5 01       	movw	r30, r10
    507e:	e9 0f       	add	r30, r25
    5080:	f1 1d       	adc	r31, r1
    5082:	8d 91       	ld	r24, X+
    5084:	80 83       	st	Z, r24
			 iPos++;
    5086:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5088:	2f 5f       	subi	r18, 0xFF	; 255
    508a:	23 17       	cp	r18, r19
    508c:	58 f3       	brcs	.-42     	; 0x5064 <StrCalc+0x3d8>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    508e:	f5 01       	movw	r30, r10
    5090:	e9 0f       	add	r30, r25
    5092:	f1 1d       	adc	r31, r1
    5094:	10 82       	st	Z, r1
    5096:	95 c0       	rjmp	.+298    	; 0x51c2 <StrCalc+0x536>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    5098:	8e 01       	movw	r16, r28
    509a:	03 5c       	subi	r16, 0xC3	; 195
    509c:	1f 4f       	sbci	r17, 0xFF	; 255
    509e:	9e 01       	movw	r18, r28
    50a0:	29 0d       	add	r18, r9
    50a2:	31 1d       	adc	r19, r1
    50a4:	2c 5e       	subi	r18, 0xEC	; 236
    50a6:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    50a8:	47 2d       	mov	r20, r7
    50aa:	50 e0       	ldi	r21, 0x00	; 0
    50ac:	4a 01       	movw	r8, r20
    50ae:	08 94       	sec
    50b0:	81 08       	sbc	r8, r1
    50b2:	91 08       	sbc	r9, r1
    50b4:	ce 01       	movw	r24, r28
    50b6:	01 96       	adiw	r24, 0x01	; 1
    50b8:	7c 01       	movw	r14, r24
    50ba:	e8 0c       	add	r14, r8
    50bc:	f9 1c       	adc	r15, r9
    50be:	dd 24       	eor	r13, r13
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    50c0:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    50c2:	70 e3       	ldi	r23, 0x30	; 48
    50c4:	c7 2e       	mov	r12, r23
    50c6:	43 c0       	rjmp	.+134    	; 0x514e <StrCalc+0x4c2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    50c8:	d7 01       	movw	r26, r14
    50ca:	9c 91       	ld	r25, X
    50cc:	90 53       	subi	r25, 0x30	; 48
    50ce:	9a 30       	cpi	r25, 0x0A	; 10
    50d0:	08 f0       	brcs	.+2      	; 0x50d4 <StrCalc+0x448>
    50d2:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    50d4:	f9 01       	movw	r30, r18
    50d6:	80 81       	ld	r24, Z
    50d8:	80 53       	subi	r24, 0x30	; 48
    50da:	8a 30       	cpi	r24, 0x0A	; 10
    50dc:	08 f0       	brcs	.+2      	; 0x50e0 <StrCalc+0x454>
    50de:	80 e0       	ldi	r24, 0x00	; 0
    50e0:	89 0f       	add	r24, r25
			 if (newC<10){
    50e2:	8a 30       	cpi	r24, 0x0A	; 10
    50e4:	18 f4       	brcc	.+6      	; 0x50ec <StrCalc+0x460>
			     Result[i]=Chr(newC);
    50e6:	80 5d       	subi	r24, 0xD0	; 208
    50e8:	d8 01       	movw	r26, r16
    50ea:	28 c0       	rjmp	.+80     	; 0x513c <StrCalc+0x4b0>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    50ec:	6a e0       	ldi	r22, 0x0A	; 10
    50ee:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    50f2:	9a 30       	cpi	r25, 0x0A	; 10
    50f4:	10 f0       	brcs	.+4      	; 0x50fa <StrCalc+0x46e>
    50f6:	90 e3       	ldi	r25, 0x30	; 48
    50f8:	01 c0       	rjmp	.+2      	; 0x50fc <StrCalc+0x470>
	    Result='0'+X;
    50fa:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    50fc:	f8 01       	movw	r30, r16
    50fe:	90 83       	st	Z, r25
    5100:	8d 2d       	mov	r24, r13
    5102:	0e c0       	rjmp	.+28     	; 0x5120 <StrCalc+0x494>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5104:	d4 01       	movw	r26, r8
    5106:	a8 1b       	sub	r26, r24
    5108:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    510a:	f2 01       	movw	r30, r4
    510c:	ea 0f       	add	r30, r26
    510e:	fb 1f       	adc	r31, r27
    5110:	90 81       	ld	r25, Z
    5112:	90 53       	subi	r25, 0x30	; 48
    5114:	9a 30       	cpi	r25, 0x0A	; 10
    5116:	08 f0       	brcs	.+2      	; 0x511a <StrCalc+0x48e>
    5118:	6e c0       	rjmp	.+220    	; 0x51f6 <StrCalc+0x56a>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    511a:	99 30       	cpi	r25, 0x09	; 9
    511c:	29 f4       	brne	.+10     	; 0x5128 <StrCalc+0x49c>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    511e:	c0 82       	st	Z, r12
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    5120:	8f 5f       	subi	r24, 0xFF	; 255
    5122:	87 15       	cp	r24, r7
    5124:	78 f3       	brcs	.-34     	; 0x5104 <StrCalc+0x478>
    5126:	0b c0       	rjmp	.+22     	; 0x513e <StrCalc+0x4b2>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5128:	89 2f       	mov	r24, r25
    512a:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    512c:	8a 30       	cpi	r24, 0x0A	; 10
    512e:	10 f0       	brcs	.+4      	; 0x5134 <StrCalc+0x4a8>
    5130:	80 e3       	ldi	r24, 0x30	; 48
    5132:	02 c0       	rjmp	.+4      	; 0x5138 <StrCalc+0x4ac>
	    Result='0'+X;
    5134:	89 2f       	mov	r24, r25
    5136:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5138:	a4 0d       	add	r26, r4
    513a:	b5 1d       	adc	r27, r5
    513c:	8c 93       	st	X, r24
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    513e:	d3 94       	inc	r13
    5140:	0f 5f       	subi	r16, 0xFF	; 255
    5142:	1f 4f       	sbci	r17, 0xFF	; 255
    5144:	21 50       	subi	r18, 0x01	; 1
    5146:	30 40       	sbci	r19, 0x00	; 0
    5148:	08 94       	sec
    514a:	e1 08       	sbc	r14, r1
    514c:	f1 08       	sbc	r15, r1
    514e:	d7 14       	cp	r13, r7
    5150:	08 f4       	brcc	.+2      	; 0x5154 <StrCalc+0x4c8>
    5152:	ba cf       	rjmp	.-140    	; 0x50c8 <StrCalc+0x43c>
					 }					 
				 }//EndFor j                
			   }//End else
			 }//EndFor
		  Result[lenA]==Chr(zMin);
		  Result[lenA+1]=0;
    5154:	4c 0f       	add	r20, r28
    5156:	5d 1f       	adc	r21, r29
    5158:	da 01       	movw	r26, r20
    515a:	de 96       	adiw	r26, 0x3e	; 62
    515c:	1c 92       	st	X, r1
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    515e:	de 01       	movw	r26, r28
    5160:	dd 96       	adiw	r26, 0x3d	; 61
    5162:	fd 01       	movw	r30, r26
    5164:	01 90       	ld	r0, Z+
    5166:	00 20       	and	r0, r0
    5168:	e9 f7       	brne	.-6      	; 0x5164 <StrCalc+0x4d8>
    516a:	31 97       	sbiw	r30, 0x01	; 1
    516c:	5e 2f       	mov	r21, r30
    516e:	5a 1b       	sub	r21, r26
    5170:	25 2f       	mov	r18, r21
    5172:	30 e0       	ldi	r19, 0x00	; 0
    5174:	21 50       	subi	r18, 0x01	; 1
    5176:	30 40       	sbci	r19, 0x00	; 0
    5178:	2a 0f       	add	r18, r26
    517a:	3b 1f       	adc	r19, r27
    517c:	40 e0       	ldi	r20, 0x00	; 0
    517e:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    5180:	6d e2       	ldi	r22, 0x2D	; 45
    5182:	16 c0       	rjmp	.+44     	; 0x51b0 <StrCalc+0x524>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    5184:	44 23       	and	r20, r20
    5186:	51 f4       	brne	.+20     	; 0x519c <StrCalc+0x510>
    5188:	63 96       	adiw	r28, 0x13	; 19
    518a:	bf ad       	ldd	r27, Y+63	; 0x3f
    518c:	63 97       	sbiw	r28, 0x13	; 19
    518e:	b1 30       	cpi	r27, 0x01	; 1
    5190:	29 f4       	brne	.+10     	; 0x519c <StrCalc+0x510>
			     strC[iPos]='-';
    5192:	f5 01       	movw	r30, r10
    5194:	e9 0f       	add	r30, r25
    5196:	f1 1d       	adc	r31, r1
    5198:	60 83       	st	Z, r22
				 iPos++;
    519a:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    519c:	f5 01       	movw	r30, r10
    519e:	e9 0f       	add	r30, r25
    51a0:	f1 1d       	adc	r31, r1
    51a2:	d9 01       	movw	r26, r18
    51a4:	8c 91       	ld	r24, X
    51a6:	80 83       	st	Z, r24
			 iPos++;
    51a8:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    51aa:	4f 5f       	subi	r20, 0xFF	; 255
    51ac:	21 50       	subi	r18, 0x01	; 1
    51ae:	30 40       	sbci	r19, 0x00	; 0
    51b0:	45 17       	cp	r20, r21
    51b2:	40 f3       	brcs	.-48     	; 0x5184 <StrCalc+0x4f8>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    51b4:	f5 01       	movw	r30, r10
    51b6:	e9 0f       	add	r30, r25
    51b8:	f1 1d       	adc	r31, r1
    51ba:	10 82       	st	Z, r1

       RemZeroLead(strC);
    51bc:	c5 01       	movw	r24, r10
    51be:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 _uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    51c2:	b2 e0       	ldi	r27, 0x02	; 2
    51c4:	6b 16       	cp	r6, r27
    51c6:	c9 f4       	brne	.+50     	; 0x51fa <StrCalc+0x56e>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    51c8:	c1 01       	movw	r24, r2
    51ca:	67 96       	adiw	r28, 0x17	; 23
    51cc:	6e ad       	ldd	r22, Y+62	; 0x3e
    51ce:	7f ad       	ldd	r23, Y+63	; 0x3f
    51d0:	67 97       	sbiw	r28, 0x17	; 23
    51d2:	a5 01       	movw	r20, r10
    51d4:	0e 94 17 29 	call	0x522e	; 0x522e <CalcMultiply>
    51d8:	10 c0       	rjmp	.+32     	; 0x51fa <StrCalc+0x56e>
	 }
}
    51da:	e1 e0       	ldi	r30, 0x01	; 1
    51dc:	62 96       	adiw	r28, 0x12	; 18
    51de:	ef af       	std	Y+63, r30	; 0x3f
    51e0:	62 97       	sbiw	r28, 0x12	; 18
    51e2:	ba ce       	rjmp	.-652    	; 0x4f58 <StrCalc+0x2cc>
    51e4:	63 96       	adiw	r28, 0x13	; 19
    51e6:	1f ae       	std	Y+63, r1	; 0x3f
    51e8:	63 97       	sbiw	r28, 0x13	; 19
    51ea:	56 cf       	rjmp	.-340    	; 0x5098 <StrCalc+0x40c>
    51ec:	f1 e0       	ldi	r31, 0x01	; 1
    51ee:	63 96       	adiw	r28, 0x13	; 19
    51f0:	ff af       	std	Y+63, r31	; 0x3f
    51f2:	63 97       	sbiw	r28, 0x13	; 19
    51f4:	51 cf       	rjmp	.-350    	; 0x5098 <StrCalc+0x40c>
    51f6:	90 e0       	ldi	r25, 0x00	; 0
    51f8:	97 cf       	rjmp	.-210    	; 0x5128 <StrCalc+0x49c>
    51fa:	ca 5a       	subi	r28, 0xAA	; 170
    51fc:	df 4f       	sbci	r29, 0xFF	; 255
    51fe:	0f b6       	in	r0, 0x3f	; 63
    5200:	f8 94       	cli
    5202:	de bf       	out	0x3e, r29	; 62
    5204:	0f be       	out	0x3f, r0	; 63
    5206:	cd bf       	out	0x3d, r28	; 61
    5208:	cf 91       	pop	r28
    520a:	df 91       	pop	r29
    520c:	1f 91       	pop	r17
    520e:	0f 91       	pop	r16
    5210:	ff 90       	pop	r15
    5212:	ef 90       	pop	r14
    5214:	df 90       	pop	r13
    5216:	cf 90       	pop	r12
    5218:	bf 90       	pop	r11
    521a:	af 90       	pop	r10
    521c:	9f 90       	pop	r9
    521e:	8f 90       	pop	r8
    5220:	7f 90       	pop	r7
    5222:	6f 90       	pop	r6
    5224:	5f 90       	pop	r5
    5226:	4f 90       	pop	r4
    5228:	3f 90       	pop	r3
    522a:	2f 90       	pop	r2
    522c:	08 95       	ret

0000522e <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    522e:	4f 92       	push	r4
    5230:	5f 92       	push	r5
    5232:	6f 92       	push	r6
    5234:	7f 92       	push	r7
    5236:	8f 92       	push	r8
    5238:	9f 92       	push	r9
    523a:	af 92       	push	r10
    523c:	bf 92       	push	r11
    523e:	cf 92       	push	r12
    5240:	df 92       	push	r13
    5242:	ef 92       	push	r14
    5244:	ff 92       	push	r15
    5246:	0f 93       	push	r16
    5248:	1f 93       	push	r17
    524a:	df 93       	push	r29
    524c:	cf 93       	push	r28
    524e:	cd b7       	in	r28, 0x3d	; 61
    5250:	de b7       	in	r29, 0x3e	; 62
    5252:	a8 97       	sbiw	r28, 0x28	; 40
    5254:	0f b6       	in	r0, 0x3f	; 63
    5256:	f8 94       	cli
    5258:	de bf       	out	0x3e, r29	; 62
    525a:	0f be       	out	0x3f, r0	; 63
    525c:	cd bf       	out	0x3d, r28	; 61
    525e:	3c 01       	movw	r6, r24
    5260:	6b 01       	movw	r12, r22
    5262:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    5264:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
     RemZeroLead(strB);
    5268:	c6 01       	movw	r24, r12
    526a:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 lenB=strlen(strB);
    526e:	d6 01       	movw	r26, r12
    5270:	0d 90       	ld	r0, X+
    5272:	00 20       	and	r0, r0
    5274:	e9 f7       	brne	.-6      	; 0x5270 <CalcMultiply+0x42>
    5276:	11 97       	sbiw	r26, 0x01	; 1
    5278:	8a 2e       	mov	r8, r26
    527a:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    527c:	00 d0       	rcall	.+0      	; 0x527e <CalcMultiply+0x50>
    527e:	00 d0       	rcall	.+0      	; 0x5280 <CalcMultiply+0x52>
    5280:	8e 01       	movw	r16, r28
    5282:	0f 5f       	subi	r16, 0xFF	; 255
    5284:	1f 4f       	sbci	r17, 0xFF	; 255
    5286:	ad b7       	in	r26, 0x3d	; 61
    5288:	be b7       	in	r27, 0x3e	; 62
    528a:	12 96       	adiw	r26, 0x02	; 2
    528c:	1c 93       	st	X, r17
    528e:	0e 93       	st	-X, r16
    5290:	11 97       	sbiw	r26, 0x01	; 1
    5292:	85 e2       	ldi	r24, 0x25	; 37
    5294:	96 e0       	ldi	r25, 0x06	; 6
    5296:	14 96       	adiw	r26, 0x04	; 4
    5298:	9c 93       	st	X, r25
    529a:	8e 93       	st	-X, r24
    529c:	13 97       	sbiw	r26, 0x03	; 3
    529e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    52a2:	a5 e1       	ldi	r26, 0x15	; 21
    52a4:	ea 2e       	mov	r14, r26
    52a6:	f1 2c       	mov	r15, r1
    52a8:	ec 0e       	add	r14, r28
    52aa:	fd 1e       	adc	r15, r29
    52ac:	ed b7       	in	r30, 0x3d	; 61
    52ae:	fe b7       	in	r31, 0x3e	; 62
    52b0:	f2 82       	std	Z+2, r15	; 0x02
    52b2:	e1 82       	std	Z+1, r14	; 0x01
    52b4:	83 e2       	ldi	r24, 0x23	; 35
    52b6:	96 e0       	ldi	r25, 0x06	; 6
    52b8:	94 83       	std	Z+4, r25	; 0x04
    52ba:	83 83       	std	Z+3, r24	; 0x03
    52bc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    52c0:	bb 24       	eor	r11, r11
    52c2:	0f 90       	pop	r0
    52c4:	0f 90       	pop	r0
    52c6:	0f 90       	pop	r0
    52c8:	0f 90       	pop	r0
    52ca:	a0 2e       	mov	r10, r16
    52cc:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    52ce:	08 2d       	mov	r16, r8
    52d0:	10 e0       	ldi	r17, 0x00	; 0
    52d2:	01 50       	subi	r16, 0x01	; 1
    52d4:	10 40       	sbci	r17, 0x00	; 0
    52d6:	1f c0       	rjmp	.+62     	; 0x5316 <CalcMultiply+0xe8>
    52d8:	f8 01       	movw	r30, r16
    52da:	e8 1b       	sub	r30, r24
    52dc:	f9 0b       	sbc	r31, r25
    52de:	ec 0d       	add	r30, r12
    52e0:	fd 1d       	adc	r31, r13
    52e2:	c3 01       	movw	r24, r6
    52e4:	60 81       	ld	r22, Z
    52e6:	a7 01       	movw	r20, r14
    52e8:	0e 94 42 20 	call	0x4084	; 0x4084 <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    52ec:	f7 01       	movw	r30, r14
    52ee:	01 90       	ld	r0, Z+
    52f0:	00 20       	and	r0, r0
    52f2:	e9 f7       	brne	.-6      	; 0x52ee <CalcMultiply+0xc0>
    52f4:	31 97       	sbiw	r30, 0x01	; 1
    52f6:	ee 19       	sub	r30, r14
    52f8:	ff 09       	sbc	r31, r15
    52fa:	6b 2d       	mov	r22, r11
    52fc:	6e 0f       	add	r22, r30
    52fe:	c7 01       	movw	r24, r14
    5300:	0e 94 2b 26 	call	0x4c56	; 0x4c56 <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    5304:	81 e0       	ldi	r24, 0x01	; 1
    5306:	6a 2d       	mov	r22, r10
    5308:	79 2d       	mov	r23, r9
    530a:	a7 01       	movw	r20, r14
    530c:	2a 2d       	mov	r18, r10
    530e:	39 2d       	mov	r19, r9
    5310:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    5314:	b3 94       	inc	r11
    5316:	f6 01       	movw	r30, r12
    5318:	01 90       	ld	r0, Z+
    531a:	00 20       	and	r0, r0
    531c:	e9 f7       	brne	.-6      	; 0x5318 <CalcMultiply+0xea>
    531e:	31 97       	sbiw	r30, 0x01	; 1
    5320:	ec 19       	sub	r30, r12
    5322:	fd 09       	sbc	r31, r13
    5324:	8b 2d       	mov	r24, r11
    5326:	90 e0       	ldi	r25, 0x00	; 0
    5328:	8e 17       	cp	r24, r30
    532a:	9f 07       	cpc	r25, r31
    532c:	a8 f2       	brcs	.-86     	; 0x52d8 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    532e:	00 d0       	rcall	.+0      	; 0x5330 <CalcMultiply+0x102>
    5330:	00 d0       	rcall	.+0      	; 0x5332 <CalcMultiply+0x104>
    5332:	00 d0       	rcall	.+0      	; 0x5334 <CalcMultiply+0x106>
    5334:	ed b7       	in	r30, 0x3d	; 61
    5336:	fe b7       	in	r31, 0x3e	; 62
    5338:	31 96       	adiw	r30, 0x01	; 1
    533a:	ad b7       	in	r26, 0x3d	; 61
    533c:	be b7       	in	r27, 0x3e	; 62
    533e:	12 96       	adiw	r26, 0x02	; 2
    5340:	5c 92       	st	X, r5
    5342:	4e 92       	st	-X, r4
    5344:	11 97       	sbiw	r26, 0x01	; 1
    5346:	80 e2       	ldi	r24, 0x20	; 32
    5348:	96 e0       	ldi	r25, 0x06	; 6
    534a:	93 83       	std	Z+3, r25	; 0x03
    534c:	82 83       	std	Z+2, r24	; 0x02
    534e:	a4 82       	std	Z+4, r10	; 0x04
    5350:	95 82       	std	Z+5, r9	; 0x05
    5352:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    5356:	ed b7       	in	r30, 0x3d	; 61
    5358:	fe b7       	in	r31, 0x3e	; 62
    535a:	36 96       	adiw	r30, 0x06	; 6
    535c:	0f b6       	in	r0, 0x3f	; 63
    535e:	f8 94       	cli
    5360:	fe bf       	out	0x3e, r31	; 62
    5362:	0f be       	out	0x3f, r0	; 63
    5364:	ed bf       	out	0x3d, r30	; 61
}
    5366:	a8 96       	adiw	r28, 0x28	; 40
    5368:	0f b6       	in	r0, 0x3f	; 63
    536a:	f8 94       	cli
    536c:	de bf       	out	0x3e, r29	; 62
    536e:	0f be       	out	0x3f, r0	; 63
    5370:	cd bf       	out	0x3d, r28	; 61
    5372:	cf 91       	pop	r28
    5374:	df 91       	pop	r29
    5376:	1f 91       	pop	r17
    5378:	0f 91       	pop	r16
    537a:	ff 90       	pop	r15
    537c:	ef 90       	pop	r14
    537e:	df 90       	pop	r13
    5380:	cf 90       	pop	r12
    5382:	bf 90       	pop	r11
    5384:	af 90       	pop	r10
    5386:	9f 90       	pop	r9
    5388:	8f 90       	pop	r8
    538a:	7f 90       	pop	r7
    538c:	6f 90       	pop	r6
    538e:	5f 90       	pop	r5
    5390:	4f 90       	pop	r4
    5392:	08 95       	ret

00005394 <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    5394:	cf 92       	push	r12
    5396:	df 92       	push	r13
    5398:	ef 92       	push	r14
    539a:	ff 92       	push	r15
    539c:	0f 93       	push	r16
    539e:	1f 93       	push	r17
    53a0:	df 93       	push	r29
    53a2:	cf 93       	push	r28
    53a4:	cd b7       	in	r28, 0x3d	; 61
    53a6:	de b7       	in	r29, 0x3e	; 62
    53a8:	64 97       	sbiw	r28, 0x14	; 20
    53aa:	0f b6       	in	r0, 0x3f	; 63
    53ac:	f8 94       	cli
    53ae:	de bf       	out	0x3e, r29	; 62
    53b0:	0f be       	out	0x3f, r0	; 63
    53b2:	cd bf       	out	0x3d, r28	; 61
    53b4:	d8 2e       	mov	r13, r24
    53b6:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    53b8:	a8 2f       	mov	r26, r24
    53ba:	b9 2f       	mov	r27, r25
    53bc:	fd 01       	movw	r30, r26
    53be:	01 90       	ld	r0, Z+
    53c0:	00 20       	and	r0, r0
    53c2:	e9 f7       	brne	.-6      	; 0x53be <NormalizeOverflow+0x2a>
    53c4:	31 97       	sbiw	r30, 0x01	; 1
    53c6:	4e 2f       	mov	r20, r30
    53c8:	48 1b       	sub	r20, r24
    53ca:	20 e0       	ldi	r18, 0x00	; 0
    53cc:	30 e0       	ldi	r19, 0x00	; 0
    53ce:	7e 01       	movw	r14, r28
    53d0:	08 94       	sec
    53d2:	e1 1c       	adc	r14, r1
    53d4:	f1 1c       	adc	r15, r1
    53d6:	04 2f       	mov	r16, r20
    53d8:	10 e0       	ldi	r17, 0x00	; 0
    53da:	0e c0       	rjmp	.+28     	; 0x53f8 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    53dc:	f7 01       	movw	r30, r14
    53de:	e2 0f       	add	r30, r18
    53e0:	f3 1f       	adc	r31, r19
    53e2:	c8 01       	movw	r24, r16
    53e4:	82 1b       	sub	r24, r18
    53e6:	93 0b       	sbc	r25, r19
    53e8:	64 2f       	mov	r22, r20
    53ea:	70 e0       	ldi	r23, 0x00	; 0
    53ec:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    53f0:	60 5d       	subi	r22, 0xD0	; 208
    53f2:	60 83       	st	Z, r22
    53f4:	2f 5f       	subi	r18, 0xFF	; 255
    53f6:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    53f8:	24 17       	cp	r18, r20
    53fa:	80 f3       	brcs	.-32     	; 0x53dc <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    53fc:	0e 0d       	add	r16, r14
    53fe:	1f 1d       	adc	r17, r15
    5400:	f8 01       	movw	r30, r16
    5402:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    5404:	81 e0       	ldi	r24, 0x01	; 1
    5406:	b7 01       	movw	r22, r14
    5408:	4d 2d       	mov	r20, r13
    540a:	5c 2d       	mov	r21, r12
    540c:	2d 2d       	mov	r18, r13
    540e:	3c 2d       	mov	r19, r12
    5410:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>
}
    5414:	64 96       	adiw	r28, 0x14	; 20
    5416:	0f b6       	in	r0, 0x3f	; 63
    5418:	f8 94       	cli
    541a:	de bf       	out	0x3e, r29	; 62
    541c:	0f be       	out	0x3f, r0	; 63
    541e:	cd bf       	out	0x3d, r28	; 61
    5420:	cf 91       	pop	r28
    5422:	df 91       	pop	r29
    5424:	1f 91       	pop	r17
    5426:	0f 91       	pop	r16
    5428:	ff 90       	pop	r15
    542a:	ef 90       	pop	r14
    542c:	df 90       	pop	r13
    542e:	cf 90       	pop	r12
    5430:	08 95       	ret

00005432 <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5432:	bf 92       	push	r11
    5434:	cf 92       	push	r12
    5436:	df 92       	push	r13
    5438:	ef 92       	push	r14
    543a:	ff 92       	push	r15
    543c:	0f 93       	push	r16
    543e:	1f 93       	push	r17
    5440:	df 93       	push	r29
    5442:	cf 93       	push	r28
    5444:	cd b7       	in	r28, 0x3d	; 61
    5446:	de b7       	in	r29, 0x3e	; 62
    5448:	6e 97       	sbiw	r28, 0x1e	; 30
    544a:	0f b6       	in	r0, 0x3f	; 63
    544c:	f8 94       	cli
    544e:	de bf       	out	0x3e, r29	; 62
    5450:	0f be       	out	0x3f, r0	; 63
    5452:	cd bf       	out	0x3d, r28	; 61
    5454:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    5456:	fc 01       	movw	r30, r24
    5458:	01 90       	ld	r0, Z+
    545a:	00 20       	and	r0, r0
    545c:	e9 f7       	brne	.-6      	; 0x5458 <AddSpaceLead+0x26>
    545e:	31 97       	sbiw	r30, 0x01	; 1
    5460:	2e 2f       	mov	r18, r30
    5462:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5464:	26 17       	cp	r18, r22
    5466:	e0 f5       	brcc	.+120    	; 0x54e0 <AddSpaceLead+0xae>
    5468:	7e 01       	movw	r14, r28
    546a:	08 94       	sec
    546c:	e1 1c       	adc	r14, r1
    546e:	f1 1c       	adc	r15, r1
    5470:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5472:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    5474:	90 e2       	ldi	r25, 0x20	; 32
    5476:	01 c0       	rjmp	.+2      	; 0x547a <AddSpaceLead+0x48>
    5478:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    547a:	8e 2f       	mov	r24, r30
    547c:	8b 19       	sub	r24, r11
    547e:	86 17       	cp	r24, r22
    5480:	d8 f3       	brcs	.-10     	; 0x5478 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    5482:	46 2f       	mov	r20, r22
    5484:	50 e0       	ldi	r21, 0x00	; 0
    5486:	ce 01       	movw	r24, r28
    5488:	01 96       	adiw	r24, 0x01	; 1
    548a:	fc 01       	movw	r30, r24
    548c:	e4 0f       	add	r30, r20
    548e:	f5 1f       	adc	r31, r21
    5490:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5492:	76 2f       	mov	r23, r22
    5494:	72 1b       	sub	r23, r18
    5496:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5498:	30 e0       	ldi	r19, 0x00	; 0
    549a:	24 1b       	sub	r18, r20
    549c:	35 0b       	sbc	r19, r21
    549e:	0c c0       	rjmp	.+24     	; 0x54b8 <AddSpaceLead+0x86>
    54a0:	e7 2f       	mov	r30, r23
    54a2:	f0 e0       	ldi	r31, 0x00	; 0
    54a4:	d6 01       	movw	r26, r12
    54a6:	ae 0f       	add	r26, r30
    54a8:	bf 1f       	adc	r27, r31
    54aa:	e0 0f       	add	r30, r16
    54ac:	f1 1f       	adc	r31, r17
    54ae:	e2 0f       	add	r30, r18
    54b0:	f3 1f       	adc	r31, r19
    54b2:	80 81       	ld	r24, Z
    54b4:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    54b6:	7f 5f       	subi	r23, 0xFF	; 255
    54b8:	76 17       	cp	r23, r22
    54ba:	90 f3       	brcs	.-28     	; 0x54a0 <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    54bc:	4c 0d       	add	r20, r12
    54be:	5d 1d       	adc	r21, r13
    54c0:	da 01       	movw	r26, r20
    54c2:	1c 92       	st	X, r1
    54c4:	f8 01       	movw	r30, r16
    54c6:	04 c0       	rjmp	.+8      	; 0x54d0 <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    54c8:	d7 01       	movw	r26, r14
    54ca:	8d 91       	ld	r24, X+
    54cc:	7d 01       	movw	r14, r26
    54ce:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    54d0:	8e 2d       	mov	r24, r14
    54d2:	8b 19       	sub	r24, r11
    54d4:	86 17       	cp	r24, r22
    54d6:	c0 f3       	brcs	.-16     	; 0x54c8 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    54d8:	06 0f       	add	r16, r22
    54da:	11 1d       	adc	r17, r1
    54dc:	f8 01       	movw	r30, r16
    54de:	10 82       	st	Z, r1
	 }
}
    54e0:	6e 96       	adiw	r28, 0x1e	; 30
    54e2:	0f b6       	in	r0, 0x3f	; 63
    54e4:	f8 94       	cli
    54e6:	de bf       	out	0x3e, r29	; 62
    54e8:	0f be       	out	0x3f, r0	; 63
    54ea:	cd bf       	out	0x3d, r28	; 61
    54ec:	cf 91       	pop	r28
    54ee:	df 91       	pop	r29
    54f0:	1f 91       	pop	r17
    54f2:	0f 91       	pop	r16
    54f4:	ff 90       	pop	r15
    54f6:	ef 90       	pop	r14
    54f8:	df 90       	pop	r13
    54fa:	cf 90       	pop	r12
    54fc:	bf 90       	pop	r11
    54fe:	08 95       	ret

00005500 <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    5500:	cf 93       	push	r28
    5502:	df 93       	push	r29
    5504:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5506:	dc 01       	movw	r26, r24
    5508:	0d 90       	ld	r0, X+
    550a:	00 20       	and	r0, r0
    550c:	e9 f7       	brne	.-6      	; 0x5508 <AddSpaceLag+0x8>
    550e:	11 97       	sbiw	r26, 0x01	; 1
    5510:	a8 1b       	sub	r26, r24
    5512:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5514:	a6 17       	cp	r26, r22
    5516:	60 f4       	brcc	.+24     	; 0x5530 <AddSpaceLag+0x30>
    5518:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    551a:	90 e2       	ldi	r25, 0x20	; 32
    551c:	fe 01       	movw	r30, r28
    551e:	e8 0f       	add	r30, r24
    5520:	f1 1d       	adc	r31, r1
    5522:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5524:	8f 5f       	subi	r24, 0xFF	; 255
    5526:	86 17       	cp	r24, r22
    5528:	c8 f3       	brcs	.-14     	; 0x551c <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    552a:	c6 0f       	add	r28, r22
    552c:	d1 1d       	adc	r29, r1
    552e:	18 82       	st	Y, r1
  }
}
    5530:	df 91       	pop	r29
    5532:	cf 91       	pop	r28
    5534:	08 95       	ret

00005536 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    5536:	0f 93       	push	r16
    5538:	1f 93       	push	r17
    553a:	df 93       	push	r29
    553c:	cf 93       	push	r28
    553e:	cd b7       	in	r28, 0x3d	; 61
    5540:	de b7       	in	r29, 0x3e	; 62
    5542:	2c 97       	sbiw	r28, 0x0c	; 12
    5544:	0f b6       	in	r0, 0x3f	; 63
    5546:	f8 94       	cli
    5548:	de bf       	out	0x3e, r29	; 62
    554a:	0f be       	out	0x3f, r0	; 63
    554c:	cd bf       	out	0x3d, r28	; 61
    554e:	48 2f       	mov	r20, r24
    5550:	8b 01       	movw	r16, r22
    5552:	fe 01       	movw	r30, r28
    5554:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5556:	9e 01       	movw	r18, r28
    5558:	23 5f       	subi	r18, 0xF3	; 243
    555a:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    555c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    555e:	e2 17       	cp	r30, r18
    5560:	f3 07       	cpc	r31, r19
    5562:	e1 f7       	brne	.-8      	; 0x555c <GetProductName+0x26>
    5564:	ce 01       	movw	r24, r28
    5566:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    5568:	44 23       	and	r20, r20
    556a:	69 f0       	breq	.+26     	; 0x5586 <GetProductName+0x50>
    556c:	6d e0       	ldi	r22, 0x0D	; 13
    556e:	46 9f       	mul	r20, r22
    5570:	b0 01       	movw	r22, r0
    5572:	11 24       	eor	r1, r1
    5574:	62 52       	subi	r22, 0x22	; 34
    5576:	7f 4f       	sbci	r23, 0xFF	; 255
    5578:	4a e0       	ldi	r20, 0x0A	; 10
    557a:	50 e0       	ldi	r21, 0x00	; 0
    557c:	27 e9       	ldi	r18, 0x97	; 151
    557e:	32 e1       	ldi	r19, 0x12	; 18
    5580:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    5584:	14 c0       	rjmp	.+40     	; 0x55ae <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    5586:	00 d0       	rcall	.+0      	; 0x5588 <GetProductName+0x52>
    5588:	00 d0       	rcall	.+0      	; 0x558a <GetProductName+0x54>
    558a:	ad b7       	in	r26, 0x3d	; 61
    558c:	be b7       	in	r27, 0x3e	; 62
    558e:	12 96       	adiw	r26, 0x02	; 2
    5590:	9c 93       	st	X, r25
    5592:	8e 93       	st	-X, r24
    5594:	11 97       	sbiw	r26, 0x01	; 1
    5596:	87 e7       	ldi	r24, 0x77	; 119
    5598:	94 e0       	ldi	r25, 0x04	; 4
    559a:	14 96       	adiw	r26, 0x04	; 4
    559c:	9c 93       	st	X, r25
    559e:	8e 93       	st	-X, r24
    55a0:	13 97       	sbiw	r26, 0x03	; 3
    55a2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    55a6:	0f 90       	pop	r0
    55a8:	0f 90       	pop	r0
    55aa:	0f 90       	pop	r0
    55ac:	0f 90       	pop	r0

     Length=strlen(SProductName);
    55ae:	de 01       	movw	r26, r28
    55b0:	11 96       	adiw	r26, 0x01	; 1
    55b2:	fd 01       	movw	r30, r26
    55b4:	01 90       	ld	r0, Z+
    55b6:	00 20       	and	r0, r0
    55b8:	e9 f7       	brne	.-6      	; 0x55b4 <GetProductName+0x7e>
    55ba:	31 97       	sbiw	r30, 0x01	; 1
    55bc:	ea 1b       	sub	r30, r26
    55be:	eb 30       	cpi	r30, 0x0B	; 11
    55c0:	08 f0       	brcs	.+2      	; 0x55c4 <GetProductName+0x8e>
    55c2:	ea e0       	ldi	r30, 0x0A	; 10
    55c4:	ae 01       	movw	r20, r28
    55c6:	4f 5f       	subi	r20, 0xFF	; 255
    55c8:	5f 4f       	sbci	r21, 0xFF	; 255
    55ca:	98 01       	movw	r18, r16
    55cc:	ba 01       	movw	r22, r20
    55ce:	06 c0       	rjmp	.+12     	; 0x55dc <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    55d0:	db 01       	movw	r26, r22
    55d2:	8d 91       	ld	r24, X+
    55d4:	bd 01       	movw	r22, r26
    55d6:	d9 01       	movw	r26, r18
    55d8:	8d 93       	st	X+, r24
    55da:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    55dc:	86 2f       	mov	r24, r22
    55de:	84 1b       	sub	r24, r20
    55e0:	8e 17       	cp	r24, r30
    55e2:	b0 f3       	brcs	.-20     	; 0x55d0 <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    55e4:	c8 01       	movw	r24, r16
    55e6:	8e 0f       	add	r24, r30
    55e8:	91 1d       	adc	r25, r1
    55ea:	fc 01       	movw	r30, r24
    55ec:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    55ee:	c8 01       	movw	r24, r16
    55f0:	6a e0       	ldi	r22, 0x0A	; 10
    55f2:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
}
    55f6:	2c 96       	adiw	r28, 0x0c	; 12
    55f8:	0f b6       	in	r0, 0x3f	; 63
    55fa:	f8 94       	cli
    55fc:	de bf       	out	0x3e, r29	; 62
    55fe:	0f be       	out	0x3f, r0	; 63
    5600:	cd bf       	out	0x3d, r28	; 61
    5602:	cf 91       	pop	r28
    5604:	df 91       	pop	r29
    5606:	1f 91       	pop	r17
    5608:	0f 91       	pop	r16
    560a:	08 95       	ret

0000560c <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    560c:	2f 92       	push	r2
    560e:	3f 92       	push	r3
    5610:	4f 92       	push	r4
    5612:	5f 92       	push	r5
    5614:	6f 92       	push	r6
    5616:	7f 92       	push	r7
    5618:	8f 92       	push	r8
    561a:	9f 92       	push	r9
    561c:	af 92       	push	r10
    561e:	bf 92       	push	r11
    5620:	cf 92       	push	r12
    5622:	df 92       	push	r13
    5624:	ef 92       	push	r14
    5626:	ff 92       	push	r15
    5628:	0f 93       	push	r16
    562a:	1f 93       	push	r17
    562c:	df 93       	push	r29
    562e:	cf 93       	push	r28
    5630:	cd b7       	in	r28, 0x3d	; 61
    5632:	de b7       	in	r29, 0x3e	; 62
    5634:	c0 5b       	subi	r28, 0xB0	; 176
    5636:	d0 40       	sbci	r29, 0x00	; 0
    5638:	0f b6       	in	r0, 0x3f	; 63
    563a:	f8 94       	cli
    563c:	de bf       	out	0x3e, r29	; 62
    563e:	0f be       	out	0x3f, r0	; 63
    5640:	cd bf       	out	0x3d, r28	; 61
    5642:	e8 2e       	mov	r14, r24
    5644:	fe 01       	movw	r30, r28
    5646:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5648:	ce 01       	movw	r24, r28
    564a:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    564c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    564e:	e8 17       	cp	r30, r24
    5650:	f9 07       	cpc	r31, r25
    5652:	e1 f7       	brne	.-8      	; 0x564c <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    5654:	ce 01       	movw	r24, r28
    5656:	85 96       	adiw	r24, 0x25	; 37
    5658:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    565a:	e8 17       	cp	r30, r24
    565c:	f9 07       	cpc	r31, r25
    565e:	e1 f7       	brne	.-8      	; 0x5658 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    5660:	ce 01       	movw	r24, r28
    5662:	c4 96       	adiw	r24, 0x34	; 52
    5664:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5666:	e8 17       	cp	r30, r24
    5668:	f9 07       	cpc	r31, r25
    566a:	e1 f7       	brne	.-8      	; 0x5664 <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    566c:	cf 01       	movw	r24, r30
    566e:	3f 01       	movw	r6, r30
    5670:	0f 96       	adiw	r24, 0x0f	; 15
    5672:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5674:	e8 17       	cp	r30, r24
    5676:	f9 07       	cpc	r31, r25
    5678:	e1 f7       	brne	.-8      	; 0x5672 <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    567a:	8e 2d       	mov	r24, r14
    567c:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
    5680:	96 e0       	ldi	r25, 0x06	; 6
    5682:	89 9f       	mul	r24, r25
    5684:	b0 01       	movw	r22, r0
    5686:	11 24       	eor	r1, r1
    5688:	61 5b       	subi	r22, 0xB1	; 177
    568a:	7f 4f       	sbci	r23, 0xFF	; 255
    568c:	8e 01       	movw	r16, r28
    568e:	0f 5f       	subi	r16, 0xFF	; 255
    5690:	1f 4f       	sbci	r17, 0xFF	; 255
    5692:	c8 01       	movw	r24, r16
    5694:	46 e0       	ldi	r20, 0x06	; 6
    5696:	50 e0       	ldi	r21, 0x00	; 0
    5698:	27 e9       	ldi	r18, 0x97	; 151
    569a:	32 e1       	ldi	r19, 0x12	; 18
    569c:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    56a0:	2e 2c       	mov	r2, r14
    56a2:	33 24       	eor	r3, r3
    56a4:	91 01       	movw	r18, r2
    56a6:	2f 70       	andi	r18, 0x0F	; 15
    56a8:	30 70       	andi	r19, 0x00	; 0
    56aa:	85 e3       	ldi	r24, 0x35	; 53
    56ac:	90 e0       	ldi	r25, 0x00	; 0
    56ae:	28 9f       	mul	r18, r24
    56b0:	f0 01       	movw	r30, r0
    56b2:	29 9f       	mul	r18, r25
    56b4:	f0 0d       	add	r31, r0
    56b6:	38 9f       	mul	r19, r24
    56b8:	f0 0d       	add	r31, r0
    56ba:	11 24       	eor	r1, r1
    56bc:	ee 54       	subi	r30, 0x4E	; 78
    56be:	f8 4f       	sbci	r31, 0xF8	; 248
    56c0:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    56c2:	4f 2c       	mov	r4, r15
    56c4:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    56c6:	04 0d       	add	r16, r4
    56c8:	15 1d       	adc	r17, r5
    56ca:	d8 01       	movw	r26, r16
    56cc:	8c 91       	ld	r24, X
    56ce:	68 e6       	ldi	r22, 0x68	; 104
    56d0:	79 e0       	ldi	r23, 0x09	; 9
    56d2:	0e 94 9b 2a 	call	0x5536	; 0x5536 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    56d6:	87 e0       	ldi	r24, 0x07	; 7
    56d8:	88 2e       	mov	r8, r24
    56da:	91 2c       	mov	r9, r1
    56dc:	8c 0e       	add	r8, r28
    56de:	9d 1e       	adc	r9, r29
    56e0:	8e 2d       	mov	r24, r14
    56e2:	b4 01       	movw	r22, r8
    56e4:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    56e8:	06 e1       	ldi	r16, 0x16	; 22
    56ea:	a0 2e       	mov	r10, r16
    56ec:	b1 2c       	mov	r11, r1
    56ee:	ac 0e       	add	r10, r28
    56f0:	bd 1e       	adc	r11, r29
    56f2:	8e 2d       	mov	r24, r14
    56f4:	b5 01       	movw	r22, r10
    56f6:	0e 94 b7 25 	call	0x4b6e	; 0x4b6e <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    56fa:	15 e2       	ldi	r17, 0x25	; 37
    56fc:	c1 2e       	mov	r12, r17
    56fe:	d1 2c       	mov	r13, r1
    5700:	cc 0e       	add	r12, r28
    5702:	dd 1e       	adc	r13, r29
    5704:	8e 2d       	mov	r24, r14
    5706:	6f 2d       	mov	r22, r15
    5708:	a6 01       	movw	r20, r12
    570a:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    570e:	8e 2d       	mov	r24, r14
    5710:	6f 2d       	mov	r22, r15
    5712:	a3 01       	movw	r20, r6
    5714:	0e 94 7d 25 	call	0x4afa	; 0x4afa <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    5718:	b3 e4       	ldi	r27, 0x43	; 67
    571a:	eb 2e       	mov	r14, r27
    571c:	f1 2c       	mov	r15, r1
    571e:	ec 0e       	add	r14, r28
    5720:	fd 1e       	adc	r15, r29
    5722:	c7 01       	movw	r24, r14
    5724:	0e 94 66 1a 	call	0x34cc	; 0x34cc <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    5728:	ed b7       	in	r30, 0x3d	; 61
    572a:	fe b7       	in	r31, 0x3e	; 62
    572c:	74 97       	sbiw	r30, 0x14	; 20
    572e:	0f b6       	in	r0, 0x3f	; 63
    5730:	f8 94       	cli
    5732:	fe bf       	out	0x3e, r31	; 62
    5734:	0f be       	out	0x3f, r0	; 63
    5736:	ed bf       	out	0x3d, r30	; 61
    5738:	31 96       	adiw	r30, 0x01	; 1
    573a:	8e 01       	movw	r16, r28
    573c:	09 5a       	subi	r16, 0xA9	; 169
    573e:	1f 4f       	sbci	r17, 0xFF	; 255
    5740:	ad b7       	in	r26, 0x3d	; 61
    5742:	be b7       	in	r27, 0x3e	; 62
    5744:	12 96       	adiw	r26, 0x02	; 2
    5746:	1c 93       	st	X, r17
    5748:	0e 93       	st	-X, r16
    574a:	11 97       	sbiw	r26, 0x01	; 1
    574c:	8a eb       	ldi	r24, 0xBA	; 186
    574e:	93 e0       	ldi	r25, 0x03	; 3
    5750:	93 83       	std	Z+3, r25	; 0x03
    5752:	82 83       	std	Z+2, r24	; 0x02
    5754:	35 82       	std	Z+5, r3	; 0x05
    5756:	24 82       	std	Z+4, r2	; 0x04
    5758:	57 82       	std	Z+7, r5	; 0x07
    575a:	46 82       	std	Z+6, r4	; 0x06
    575c:	88 e6       	ldi	r24, 0x68	; 104
    575e:	99 e0       	ldi	r25, 0x09	; 9
    5760:	91 87       	std	Z+9, r25	; 0x09
    5762:	80 87       	std	Z+8, r24	; 0x08
    5764:	f3 86       	std	Z+11, r15	; 0x0b
    5766:	e2 86       	std	Z+10, r14	; 0x0a
    5768:	95 86       	std	Z+13, r9	; 0x0d
    576a:	84 86       	std	Z+12, r8	; 0x0c
    576c:	b7 86       	std	Z+15, r11	; 0x0f
    576e:	a6 86       	std	Z+14, r10	; 0x0e
    5770:	d1 8a       	std	Z+17, r13	; 0x11
    5772:	c0 8a       	std	Z+16, r12	; 0x10
    5774:	62 8a       	std	Z+18, r6	; 0x12
    5776:	73 8a       	std	Z+19, r7	; 0x13
    5778:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 cSum=SumChecksum(strSend);
    577c:	ad b7       	in	r26, 0x3d	; 61
    577e:	be b7       	in	r27, 0x3e	; 62
    5780:	54 96       	adiw	r26, 0x14	; 20
    5782:	0f b6       	in	r0, 0x3f	; 63
    5784:	f8 94       	cli
    5786:	be bf       	out	0x3e, r27	; 62
    5788:	0f be       	out	0x3f, r0	; 63
    578a:	ad bf       	out	0x3d, r26	; 61
    578c:	c8 01       	movw	r24, r16
    578e:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <SumChecksum>
    5792:	e8 2e       	mov	r14, r24
	 _uart_print(1,0,strSend);
    5794:	81 e0       	ldi	r24, 0x01	; 1
    5796:	60 e0       	ldi	r22, 0x00	; 0
    5798:	a8 01       	movw	r20, r16
    579a:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
    579e:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    57a0:	c8 01       	movw	r24, r16
    57a2:	f9 2e       	mov	r15, r25
    57a4:	ce 01       	movw	r24, r28
    57a6:	8f 54       	subi	r24, 0x4F	; 79
    57a8:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    57aa:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    57ac:	e8 17       	cp	r30, r24
    57ae:	f9 07       	cpc	r31, r25
    57b0:	e1 f7       	brne	.-8      	; 0x57aa <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 _uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    57b2:	00 d0       	rcall	.+0      	; 0x57b4 <GeniusSendLastTransaction+0x1a8>
    57b4:	00 d0       	rcall	.+0      	; 0x57b6 <GeniusSendLastTransaction+0x1aa>
    57b6:	00 d0       	rcall	.+0      	; 0x57b8 <GeniusSendLastTransaction+0x1ac>
    57b8:	ed b7       	in	r30, 0x3d	; 61
    57ba:	fe b7       	in	r31, 0x3e	; 62
    57bc:	31 96       	adiw	r30, 0x01	; 1
    57be:	ad b7       	in	r26, 0x3d	; 61
    57c0:	be b7       	in	r27, 0x3e	; 62
    57c2:	11 96       	adiw	r26, 0x01	; 1
    57c4:	0c 93       	st	X, r16
    57c6:	11 97       	sbiw	r26, 0x01	; 1
    57c8:	12 96       	adiw	r26, 0x02	; 2
    57ca:	fc 92       	st	X, r15
    57cc:	87 eb       	ldi	r24, 0xB7	; 183
    57ce:	93 e0       	ldi	r25, 0x03	; 3
    57d0:	93 83       	std	Z+3, r25	; 0x03
    57d2:	82 83       	std	Z+2, r24	; 0x02
    57d4:	e4 82       	std	Z+4, r14	; 0x04
    57d6:	15 82       	std	Z+5, r1	; 0x05
    57d8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(1,1,strSend);	 
    57dc:	ed b7       	in	r30, 0x3d	; 61
    57de:	fe b7       	in	r31, 0x3e	; 62
    57e0:	36 96       	adiw	r30, 0x06	; 6
    57e2:	0f b6       	in	r0, 0x3f	; 63
    57e4:	f8 94       	cli
    57e6:	fe bf       	out	0x3e, r31	; 62
    57e8:	0f be       	out	0x3f, r0	; 63
    57ea:	ed bf       	out	0x3d, r30	; 61
    57ec:	81 e0       	ldi	r24, 0x01	; 1
    57ee:	61 e0       	ldi	r22, 0x01	; 1
    57f0:	40 2f       	mov	r20, r16
    57f2:	5f 2d       	mov	r21, r15
    57f4:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
}
    57f8:	c0 55       	subi	r28, 0x50	; 80
    57fa:	df 4f       	sbci	r29, 0xFF	; 255
    57fc:	0f b6       	in	r0, 0x3f	; 63
    57fe:	f8 94       	cli
    5800:	de bf       	out	0x3e, r29	; 62
    5802:	0f be       	out	0x3f, r0	; 63
    5804:	cd bf       	out	0x3d, r28	; 61
    5806:	cf 91       	pop	r28
    5808:	df 91       	pop	r29
    580a:	1f 91       	pop	r17
    580c:	0f 91       	pop	r16
    580e:	ff 90       	pop	r15
    5810:	ef 90       	pop	r14
    5812:	df 90       	pop	r13
    5814:	cf 90       	pop	r12
    5816:	bf 90       	pop	r11
    5818:	af 90       	pop	r10
    581a:	9f 90       	pop	r9
    581c:	8f 90       	pop	r8
    581e:	7f 90       	pop	r7
    5820:	6f 90       	pop	r6
    5822:	5f 90       	pop	r5
    5824:	4f 90       	pop	r4
    5826:	3f 90       	pop	r3
    5828:	2f 90       	pop	r2
    582a:	08 95       	ret

0000582c <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    582c:	80 91 f7 01 	lds	r24, 0x01F7
    5830:	83 30       	cpi	r24, 0x03	; 3
    5832:	71 f1       	breq	.+92     	; 0x5890 <systemGeniusProtocol+0x64>
    5834:	84 30       	cpi	r24, 0x04	; 4
    5836:	28 f4       	brcc	.+10     	; 0x5842 <systemGeniusProtocol+0x16>
    5838:	81 30       	cpi	r24, 0x01	; 1
    583a:	81 f0       	breq	.+32     	; 0x585c <systemGeniusProtocol+0x30>
    583c:	82 30       	cpi	r24, 0x02	; 2
    583e:	c0 f4       	brcc	.+48     	; 0x5870 <systemGeniusProtocol+0x44>
    5840:	09 c0       	rjmp	.+18     	; 0x5854 <systemGeniusProtocol+0x28>
    5842:	85 30       	cpi	r24, 0x05	; 5
    5844:	09 f4       	brne	.+2      	; 0x5848 <systemGeniusProtocol+0x1c>
    5846:	49 c0       	rjmp	.+146    	; 0x58da <systemGeniusProtocol+0xae>
    5848:	85 30       	cpi	r24, 0x05	; 5
    584a:	c0 f1       	brcs	.+112    	; 0x58bc <systemGeniusProtocol+0x90>
    584c:	86 30       	cpi	r24, 0x06	; 6
    584e:	09 f0       	breq	.+2      	; 0x5852 <systemGeniusProtocol+0x26>
    5850:	60 c0       	rjmp	.+192    	; 0x5912 <systemGeniusProtocol+0xe6>
    5852:	4d c0       	rjmp	.+154    	; 0x58ee <systemGeniusProtocol+0xc2>
	 case gpInitScan:
	      iPumpID=1;
    5854:	81 e0       	ldi	r24, 0x01	; 1
    5856:	80 93 f6 01 	sts	0x01F6, r24
    585a:	46 c0       	rjmp	.+140    	; 0x58e8 <systemGeniusProtocol+0xbc>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    585c:	80 91 f4 01 	lds	r24, 0x01F4
    5860:	0e 94 f6 19 	call	0x33ec	; 0x33ec <GetIncomingTransStatus>
    5864:	82 30       	cpi	r24, 0x02	; 2
    5866:	09 f0       	breq	.+2      	; 0x586a <systemGeniusProtocol+0x3e>
    5868:	54 c0       	rjmp	.+168    	; 0x5912 <systemGeniusProtocol+0xe6>
		      IsTotalizerReceived=False;
    586a:	10 92 db 01 	sts	0x01DB, r1
    586e:	3c c0       	rjmp	.+120    	; 0x58e8 <systemGeniusProtocol+0xbc>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    5870:	90 91 f6 01 	lds	r25, 0x01F6
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    5874:	85 e0       	ldi	r24, 0x05	; 5
    5876:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
    587a:	90 93 d9 0d 	sts	0x0DD9, r25
     IsControlPooling=True;
    587e:	81 e0       	ldi	r24, 0x01	; 1
    5880:	80 93 ad 01 	sts	0x01AD, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    5884:	10 92 be 01 	sts	0x01BE, r1
    5888:	10 92 bd 01 	sts	0x01BD, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    588c:	83 e0       	ldi	r24, 0x03	; 3
    588e:	2c c0       	rjmp	.+88     	; 0x58e8 <systemGeniusProtocol+0xbc>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    5890:	80 91 db 01 	lds	r24, 0x01DB
    5894:	81 30       	cpi	r24, 0x01	; 1
    5896:	59 f4       	brne	.+22     	; 0x58ae <systemGeniusProtocol+0x82>
    5898:	90 91 f2 0d 	lds	r25, 0x0DF2
    589c:	80 91 f6 01 	lds	r24, 0x01F6
    58a0:	98 17       	cp	r25, r24
    58a2:	29 f4       	brne	.+10     	; 0x58ae <systemGeniusProtocol+0x82>
		      IsTotalizerReceived=False;
    58a4:	10 92 db 01 	sts	0x01DB, r1
			  stGeniusProtocol=gpSendTransactionData;
    58a8:	84 e0       	ldi	r24, 0x04	; 4
    58aa:	80 93 f7 01 	sts	0x01F7, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    58ae:	80 91 bd 01 	lds	r24, 0x01BD
    58b2:	90 91 be 01 	lds	r25, 0x01BE
    58b6:	45 97       	sbiw	r24, 0x15	; 21
    58b8:	60 f1       	brcs	.+88     	; 0x5912 <systemGeniusProtocol+0xe6>
    58ba:	15 c0       	rjmp	.+42     	; 0x58e6 <systemGeniusProtocol+0xba>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    58bc:	80 91 f6 01 	lds	r24, 0x01F6
    58c0:	0e 94 06 2b 	call	0x560c	; 0x560c <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    58c4:	80 91 f6 01 	lds	r24, 0x01F6
    58c8:	63 e0       	ldi	r22, 0x03	; 3
    58ca:	0e 94 c4 19 	call	0x3388	; 0x3388 <SetIncomingTransStatus>
		  
		  TimSend=0;
    58ce:	10 92 be 01 	sts	0x01BE, r1
    58d2:	10 92 bd 01 	sts	0x01BD, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    58d6:	85 e0       	ldi	r24, 0x05	; 5
    58d8:	07 c0       	rjmp	.+14     	; 0x58e8 <systemGeniusProtocol+0xbc>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    58da:	80 91 bd 01 	lds	r24, 0x01BD
    58de:	90 91 be 01 	lds	r25, 0x01BE
    58e2:	02 97       	sbiw	r24, 0x02	; 2
    58e4:	b0 f0       	brcs	.+44     	; 0x5912 <systemGeniusProtocol+0xe6>
    58e6:	86 e0       	ldi	r24, 0x06	; 6
    58e8:	80 93 f7 01 	sts	0x01F7, r24
    58ec:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    58ee:	20 91 f6 01 	lds	r18, 0x01F6
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    58f2:	e1 99       	sbic	0x1c, 1	; 28
    58f4:	fe cf       	rjmp	.-4      	; 0x58f2 <systemGeniusProtocol+0xc6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    58f6:	84 e7       	ldi	r24, 0x74	; 116
    58f8:	91 e0       	ldi	r25, 0x01	; 1
    58fa:	9f bb       	out	0x1f, r25	; 31
    58fc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    58fe:	e0 9a       	sbi	0x1c, 0	; 28
    5900:	8d b3       	in	r24, 0x1d	; 29
    5902:	82 17       	cp	r24, r18
    5904:	30 f0       	brcs	.+12     	; 0x5912 <systemGeniusProtocol+0xe6>
		      iPumpID++;
    5906:	2f 5f       	subi	r18, 0xFF	; 255
    5908:	20 93 f6 01 	sts	0x01F6, r18
              stGeniusProtocol=gpScanNewTransaction;
    590c:	81 e0       	ldi	r24, 0x01	; 1
    590e:	80 93 f7 01 	sts	0x01F7, r24
    5912:	08 95       	ret

00005914 <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    5914:	ef 92       	push	r14
    5916:	ff 92       	push	r15
    5918:	0f 93       	push	r16
    591a:	1f 93       	push	r17
    591c:	18 2f       	mov	r17, r24
    591e:	09 2f       	mov	r16, r25
    5920:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    5922:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
	 RemSpaceLead(Source);
    5926:	81 2f       	mov	r24, r17
    5928:	90 2f       	mov	r25, r16
    592a:	0e 94 e0 23 	call	0x47c0	; 0x47c0 <RemSpaceLead>
	 srcLength=strlen(Source);
    592e:	a1 2f       	mov	r26, r17
    5930:	b0 2f       	mov	r27, r16
    5932:	fd 01       	movw	r30, r26
    5934:	01 90       	ld	r0, Z+
    5936:	00 20       	and	r0, r0
    5938:	e9 f7       	brne	.-6      	; 0x5934 <StrAlignCenter+0x20>
    593a:	31 97       	sbiw	r30, 0x01	; 1
    593c:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    593e:	c7 01       	movw	r24, r14
    5940:	8e 1b       	sub	r24, r30
    5942:	91 09       	sbc	r25, r1
    5944:	96 95       	lsr	r25
    5946:	87 95       	ror	r24
    5948:	e8 0f       	add	r30, r24
    594a:	81 2f       	mov	r24, r17
    594c:	90 2f       	mov	r25, r16
    594e:	6e 2f       	mov	r22, r30
    5950:	0e 94 19 2a 	call	0x5432	; 0x5432 <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    5954:	81 2f       	mov	r24, r17
    5956:	90 2f       	mov	r25, r16
    5958:	6e 2d       	mov	r22, r14
    595a:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
}
    595e:	1f 91       	pop	r17
    5960:	0f 91       	pop	r16
    5962:	ff 90       	pop	r15
    5964:	ef 90       	pop	r14
    5966:	08 95       	ret

00005968 <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    5968:	bf 92       	push	r11
    596a:	cf 92       	push	r12
    596c:	df 92       	push	r13
    596e:	ef 92       	push	r14
    5970:	ff 92       	push	r15
    5972:	0f 93       	push	r16
    5974:	1f 93       	push	r17
    5976:	df 93       	push	r29
    5978:	cf 93       	push	r28
    597a:	cd b7       	in	r28, 0x3d	; 61
    597c:	de b7       	in	r29, 0x3e	; 62
    597e:	6e 97       	sbiw	r28, 0x1e	; 30
    5980:	0f b6       	in	r0, 0x3f	; 63
    5982:	f8 94       	cli
    5984:	de bf       	out	0x3e, r29	; 62
    5986:	0f be       	out	0x3f, r0	; 63
    5988:	cd bf       	out	0x3d, r28	; 61
    598a:	8c 01       	movw	r16, r24
    598c:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    598e:	fc 01       	movw	r30, r24
    5990:	01 90       	ld	r0, Z+
    5992:	00 20       	and	r0, r0
    5994:	e9 f7       	brne	.-6      	; 0x5990 <AddCharLead+0x28>
    5996:	31 97       	sbiw	r30, 0x01	; 1
    5998:	2e 2f       	mov	r18, r30
    599a:	28 1b       	sub	r18, r24

	 if (Size>Length){
    599c:	24 17       	cp	r18, r20
    599e:	d0 f5       	brcc	.+116    	; 0x5a14 <AddCharLead+0xac>
    59a0:	ae 01       	movw	r20, r28
    59a2:	4f 5f       	subi	r20, 0xFF	; 255
    59a4:	5f 4f       	sbci	r21, 0xFF	; 255
    59a6:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    59a8:	b4 2e       	mov	r11, r20
    59aa:	01 c0       	rjmp	.+2      	; 0x59ae <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    59ac:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    59ae:	8e 2f       	mov	r24, r30
    59b0:	8b 19       	sub	r24, r11
    59b2:	8e 15       	cp	r24, r14
    59b4:	d8 f3       	brcs	.-10     	; 0x59ac <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    59b6:	6e 2d       	mov	r22, r14
    59b8:	70 e0       	ldi	r23, 0x00	; 0
    59ba:	ce 01       	movw	r24, r28
    59bc:	01 96       	adiw	r24, 0x01	; 1
    59be:	fc 01       	movw	r30, r24
    59c0:	e6 0f       	add	r30, r22
    59c2:	f7 1f       	adc	r31, r23
    59c4:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    59c6:	fe 2c       	mov	r15, r14
    59c8:	f2 1a       	sub	r15, r18
    59ca:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    59cc:	30 e0       	ldi	r19, 0x00	; 0
    59ce:	26 1b       	sub	r18, r22
    59d0:	37 0b       	sbc	r19, r23
    59d2:	0c c0       	rjmp	.+24     	; 0x59ec <AddCharLead+0x84>
    59d4:	ef 2d       	mov	r30, r15
    59d6:	f0 e0       	ldi	r31, 0x00	; 0
    59d8:	d6 01       	movw	r26, r12
    59da:	ae 0f       	add	r26, r30
    59dc:	bf 1f       	adc	r27, r31
    59de:	e0 0f       	add	r30, r16
    59e0:	f1 1f       	adc	r31, r17
    59e2:	e2 0f       	add	r30, r18
    59e4:	f3 1f       	adc	r31, r19
    59e6:	80 81       	ld	r24, Z
    59e8:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    59ea:	f3 94       	inc	r15
    59ec:	fe 14       	cp	r15, r14
    59ee:	90 f3       	brcs	.-28     	; 0x59d4 <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    59f0:	6c 0d       	add	r22, r12
    59f2:	7d 1d       	adc	r23, r13
    59f4:	db 01       	movw	r26, r22
    59f6:	1c 92       	st	X, r1
    59f8:	f8 01       	movw	r30, r16
    59fa:	04 c0       	rjmp	.+8      	; 0x5a04 <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    59fc:	da 01       	movw	r26, r20
    59fe:	8d 91       	ld	r24, X+
    5a00:	ad 01       	movw	r20, r26
    5a02:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5a04:	84 2f       	mov	r24, r20
    5a06:	8b 19       	sub	r24, r11
    5a08:	8e 15       	cp	r24, r14
    5a0a:	c0 f3       	brcs	.-16     	; 0x59fc <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5a0c:	0e 0d       	add	r16, r14
    5a0e:	11 1d       	adc	r17, r1
    5a10:	f8 01       	movw	r30, r16
    5a12:	10 82       	st	Z, r1
	 }
}
    5a14:	6e 96       	adiw	r28, 0x1e	; 30
    5a16:	0f b6       	in	r0, 0x3f	; 63
    5a18:	f8 94       	cli
    5a1a:	de bf       	out	0x3e, r29	; 62
    5a1c:	0f be       	out	0x3f, r0	; 63
    5a1e:	cd bf       	out	0x3d, r28	; 61
    5a20:	cf 91       	pop	r28
    5a22:	df 91       	pop	r29
    5a24:	1f 91       	pop	r17
    5a26:	0f 91       	pop	r16
    5a28:	ff 90       	pop	r15
    5a2a:	ef 90       	pop	r14
    5a2c:	df 90       	pop	r13
    5a2e:	cf 90       	pop	r12
    5a30:	bf 90       	pop	r11
    5a32:	08 95       	ret

00005a34 <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    5a34:	cf 93       	push	r28
    5a36:	df 93       	push	r29
    5a38:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5a3a:	dc 01       	movw	r26, r24
    5a3c:	0d 90       	ld	r0, X+
    5a3e:	00 20       	and	r0, r0
    5a40:	e9 f7       	brne	.-6      	; 0x5a3c <AddCharLag+0x8>
    5a42:	11 97       	sbiw	r26, 0x01	; 1
    5a44:	a8 1b       	sub	r26, r24
    5a46:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5a48:	a4 17       	cp	r26, r20
    5a4a:	58 f4       	brcc	.+22     	; 0x5a62 <AddCharLag+0x2e>
    5a4c:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    5a4e:	fe 01       	movw	r30, r28
    5a50:	e8 0f       	add	r30, r24
    5a52:	f1 1d       	adc	r31, r1
    5a54:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5a56:	8f 5f       	subi	r24, 0xFF	; 255
    5a58:	84 17       	cp	r24, r20
    5a5a:	c8 f3       	brcs	.-14     	; 0x5a4e <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    5a5c:	c4 0f       	add	r28, r20
    5a5e:	d1 1d       	adc	r29, r1
    5a60:	18 82       	st	Y, r1
  }

}
    5a62:	df 91       	pop	r29
    5a64:	cf 91       	pop	r28
    5a66:	08 95       	ret

00005a68 <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    5a68:	cf 92       	push	r12
    5a6a:	df 92       	push	r13
    5a6c:	ef 92       	push	r14
    5a6e:	ff 92       	push	r15
    5a70:	0f 93       	push	r16
    5a72:	1f 93       	push	r17
    5a74:	cf 93       	push	r28
    5a76:	df 93       	push	r29
    5a78:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5a7a:	dc 01       	movw	r26, r24
    5a7c:	0d 90       	ld	r0, X+
    5a7e:	00 20       	and	r0, r0
    5a80:	e9 f7       	brne	.-6      	; 0x5a7c <CountTotalizerSatus+0x14>
    5a82:	8d 01       	movw	r16, r26
    5a84:	01 50       	subi	r16, 0x01	; 1
    5a86:	10 40       	sbci	r17, 0x00	; 0
    5a88:	08 1b       	sub	r16, r24
    5a8a:	19 0b       	sbc	r17, r25
    5a8c:	cc 24       	eor	r12, r12
    5a8e:	dd 24       	eor	r13, r13
    5a90:	0a c0       	rjmp	.+20     	; 0x5aa6 <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    5a92:	84 e1       	ldi	r24, 0x14	; 20
    5a94:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    5a98:	ce 0d       	add	r28, r14
    5a9a:	df 1d       	adc	r29, r15
    5a9c:	98 81       	ld	r25, Y
    5a9e:	98 17       	cp	r25, r24
    5aa0:	09 f4       	brne	.+2      	; 0x5aa4 <CountTotalizerSatus+0x3c>
		      Result++;		  
    5aa2:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5aa4:	c3 94       	inc	r12
    5aa6:	cc 2d       	mov	r28, r12
    5aa8:	d0 e0       	ldi	r29, 0x00	; 0
    5aaa:	c0 17       	cp	r28, r16
    5aac:	d1 07       	cpc	r29, r17
    5aae:	88 f3       	brcs	.-30     	; 0x5a92 <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    5ab0:	8d 2d       	mov	r24, r13
    5ab2:	df 91       	pop	r29
    5ab4:	cf 91       	pop	r28
    5ab6:	1f 91       	pop	r17
    5ab8:	0f 91       	pop	r16
    5aba:	ff 90       	pop	r15
    5abc:	ef 90       	pop	r14
    5abe:	df 90       	pop	r13
    5ac0:	cf 90       	pop	r12
    5ac2:	08 95       	ret

00005ac4 <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    5ac4:	1f 93       	push	r17
    5ac6:	df 93       	push	r29
    5ac8:	cf 93       	push	r28
    5aca:	cd b7       	in	r28, 0x3d	; 61
    5acc:	de b7       	in	r29, 0x3e	; 62
    5ace:	64 97       	sbiw	r28, 0x14	; 20
    5ad0:	0f b6       	in	r0, 0x3f	; 63
    5ad2:	f8 94       	cli
    5ad4:	de bf       	out	0x3e, r29	; 62
    5ad6:	0f be       	out	0x3f, r0	; 63
    5ad8:	cd bf       	out	0x3d, r28	; 61
    5ada:	16 2f       	mov	r17, r22
    5adc:	50 e0       	ldi	r21, 0x00	; 0
    5ade:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    5ae0:	be 01       	movw	r22, r28
    5ae2:	6f 5f       	subi	r22, 0xFF	; 255
    5ae4:	7f 4f       	sbci	r23, 0xFF	; 255
    5ae6:	0c c0       	rjmp	.+24     	; 0x5b00 <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    5ae8:	28 0f       	add	r18, r24
    5aea:	39 1f       	adc	r19, r25
    5aec:	d9 01       	movw	r26, r18
    5aee:	2c 91       	ld	r18, X
    5af0:	21 17       	cp	r18, r17
    5af2:	29 f0       	breq	.+10     	; 0x5afe <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    5af4:	fb 01       	movw	r30, r22
    5af6:	e4 0f       	add	r30, r20
    5af8:	f1 1d       	adc	r31, r1
    5afa:	20 83       	st	Z, r18
			 iAdd++;
    5afc:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    5afe:	5f 5f       	subi	r21, 0xFF	; 255
    5b00:	25 2f       	mov	r18, r21
    5b02:	30 e0       	ldi	r19, 0x00	; 0
    5b04:	fc 01       	movw	r30, r24
    5b06:	01 90       	ld	r0, Z+
    5b08:	00 20       	and	r0, r0
    5b0a:	e9 f7       	brne	.-6      	; 0x5b06 <RemoveChar+0x42>
    5b0c:	31 97       	sbiw	r30, 0x01	; 1
    5b0e:	e8 1b       	sub	r30, r24
    5b10:	f9 0b       	sbc	r31, r25
    5b12:	2e 17       	cp	r18, r30
    5b14:	3f 07       	cpc	r19, r31
    5b16:	40 f3       	brcs	.-48     	; 0x5ae8 <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    5b18:	9e 01       	movw	r18, r28
    5b1a:	2f 5f       	subi	r18, 0xFF	; 255
    5b1c:	3f 4f       	sbci	r19, 0xFF	; 255
    5b1e:	f9 01       	movw	r30, r18
    5b20:	e4 0f       	add	r30, r20
    5b22:	f1 1d       	adc	r31, r1
    5b24:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    5b26:	00 d0       	rcall	.+0      	; 0x5b28 <RemoveChar+0x64>
    5b28:	00 d0       	rcall	.+0      	; 0x5b2a <RemoveChar+0x66>
    5b2a:	00 d0       	rcall	.+0      	; 0x5b2c <RemoveChar+0x68>
    5b2c:	ed b7       	in	r30, 0x3d	; 61
    5b2e:	fe b7       	in	r31, 0x3e	; 62
    5b30:	31 96       	adiw	r30, 0x01	; 1
    5b32:	ad b7       	in	r26, 0x3d	; 61
    5b34:	be b7       	in	r27, 0x3e	; 62
    5b36:	12 96       	adiw	r26, 0x02	; 2
    5b38:	9c 93       	st	X, r25
    5b3a:	8e 93       	st	-X, r24
    5b3c:	11 97       	sbiw	r26, 0x01	; 1
    5b3e:	89 ed       	ldi	r24, 0xD9	; 217
    5b40:	96 e1       	ldi	r25, 0x16	; 22
    5b42:	93 83       	std	Z+3, r25	; 0x03
    5b44:	82 83       	std	Z+2, r24	; 0x02
    5b46:	35 83       	std	Z+5, r19	; 0x05
    5b48:	24 83       	std	Z+4, r18	; 0x04
    5b4a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    5b4e:	ed b7       	in	r30, 0x3d	; 61
    5b50:	fe b7       	in	r31, 0x3e	; 62
    5b52:	36 96       	adiw	r30, 0x06	; 6
    5b54:	0f b6       	in	r0, 0x3f	; 63
    5b56:	f8 94       	cli
    5b58:	fe bf       	out	0x3e, r31	; 62
    5b5a:	0f be       	out	0x3f, r0	; 63
    5b5c:	ed bf       	out	0x3d, r30	; 61
}
    5b5e:	64 96       	adiw	r28, 0x14	; 20
    5b60:	0f b6       	in	r0, 0x3f	; 63
    5b62:	f8 94       	cli
    5b64:	de bf       	out	0x3e, r29	; 62
    5b66:	0f be       	out	0x3f, r0	; 63
    5b68:	cd bf       	out	0x3d, r28	; 61
    5b6a:	cf 91       	pop	r28
    5b6c:	df 91       	pop	r29
    5b6e:	1f 91       	pop	r17
    5b70:	08 95       	ret

00005b72 <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    5b72:	8f 92       	push	r8
    5b74:	9f 92       	push	r9
    5b76:	bf 92       	push	r11
    5b78:	cf 92       	push	r12
    5b7a:	df 92       	push	r13
    5b7c:	ef 92       	push	r14
    5b7e:	ff 92       	push	r15
    5b80:	0f 93       	push	r16
    5b82:	1f 93       	push	r17
    5b84:	df 93       	push	r29
    5b86:	cf 93       	push	r28
    5b88:	cd b7       	in	r28, 0x3d	; 61
    5b8a:	de b7       	in	r29, 0x3e	; 62
    5b8c:	2f 97       	sbiw	r28, 0x0f	; 15
    5b8e:	0f b6       	in	r0, 0x3f	; 63
    5b90:	f8 94       	cli
    5b92:	de bf       	out	0x3e, r29	; 62
    5b94:	0f be       	out	0x3f, r0	; 63
    5b96:	cd bf       	out	0x3d, r28	; 61
    5b98:	6c 01       	movw	r12, r24
    5b9a:	bb 24       	eor	r11, r11
    5b9c:	40 e0       	ldi	r20, 0x00	; 0
    5b9e:	4e 01       	movw	r8, r28
    5ba0:	08 94       	sec
    5ba2:	81 1c       	adc	r8, r1
    5ba4:	91 1c       	adc	r9, r1
    5ba6:	12 c0       	rjmp	.+36     	; 0x5bcc <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    5ba8:	86 01       	movw	r16, r12
    5baa:	0e 0d       	add	r16, r14
    5bac:	1f 1d       	adc	r17, r15
    5bae:	d8 01       	movw	r26, r16
    5bb0:	6c 91       	ld	r22, X
    5bb2:	60 53       	subi	r22, 0x30	; 48
    5bb4:	80 e0       	ldi	r24, 0x00	; 0
    5bb6:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <GeniusCalc>
    5bba:	e8 0c       	add	r14, r8
    5bbc:	f9 1c       	adc	r15, r9
    5bbe:	80 5d       	subi	r24, 0xD0	; 208
    5bc0:	f7 01       	movw	r30, r14
    5bc2:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    5bc4:	d8 01       	movw	r26, r16
    5bc6:	4c 91       	ld	r20, X
    5bc8:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    5bca:	b3 94       	inc	r11
    5bcc:	eb 2c       	mov	r14, r11
    5bce:	ff 24       	eor	r15, r15
    5bd0:	d6 01       	movw	r26, r12
    5bd2:	0d 90       	ld	r0, X+
    5bd4:	00 20       	and	r0, r0
    5bd6:	e9 f7       	brne	.-6      	; 0x5bd2 <WrapCode+0x60>
    5bd8:	11 97       	sbiw	r26, 0x01	; 1
    5bda:	ac 19       	sub	r26, r12
    5bdc:	bd 09       	sbc	r27, r13
    5bde:	ea 16       	cp	r14, r26
    5be0:	fb 06       	cpc	r15, r27
    5be2:	10 f3       	brcs	.-60     	; 0x5ba8 <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    5be4:	a8 0d       	add	r26, r8
    5be6:	b9 1d       	adc	r27, r9
    5be8:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    5bea:	00 d0       	rcall	.+0      	; 0x5bec <WrapCode+0x7a>
    5bec:	00 d0       	rcall	.+0      	; 0x5bee <WrapCode+0x7c>
    5bee:	00 d0       	rcall	.+0      	; 0x5bf0 <WrapCode+0x7e>
    5bf0:	ed b7       	in	r30, 0x3d	; 61
    5bf2:	fe b7       	in	r31, 0x3e	; 62
    5bf4:	31 96       	adiw	r30, 0x01	; 1
    5bf6:	ad b7       	in	r26, 0x3d	; 61
    5bf8:	be b7       	in	r27, 0x3e	; 62
    5bfa:	12 96       	adiw	r26, 0x02	; 2
    5bfc:	dc 92       	st	X, r13
    5bfe:	ce 92       	st	-X, r12
    5c00:	11 97       	sbiw	r26, 0x01	; 1
    5c02:	84 ee       	ldi	r24, 0xE4	; 228
    5c04:	96 e1       	ldi	r25, 0x16	; 22
    5c06:	93 83       	std	Z+3, r25	; 0x03
    5c08:	82 83       	std	Z+2, r24	; 0x02
    5c0a:	95 82       	std	Z+5, r9	; 0x05
    5c0c:	84 82       	std	Z+4, r8	; 0x04
    5c0e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    5c12:	ed b7       	in	r30, 0x3d	; 61
    5c14:	fe b7       	in	r31, 0x3e	; 62
    5c16:	36 96       	adiw	r30, 0x06	; 6
    5c18:	0f b6       	in	r0, 0x3f	; 63
    5c1a:	f8 94       	cli
    5c1c:	fe bf       	out	0x3e, r31	; 62
    5c1e:	0f be       	out	0x3f, r0	; 63
    5c20:	ed bf       	out	0x3d, r30	; 61
}
    5c22:	2f 96       	adiw	r28, 0x0f	; 15
    5c24:	0f b6       	in	r0, 0x3f	; 63
    5c26:	f8 94       	cli
    5c28:	de bf       	out	0x3e, r29	; 62
    5c2a:	0f be       	out	0x3f, r0	; 63
    5c2c:	cd bf       	out	0x3d, r28	; 61
    5c2e:	cf 91       	pop	r28
    5c30:	df 91       	pop	r29
    5c32:	1f 91       	pop	r17
    5c34:	0f 91       	pop	r16
    5c36:	ff 90       	pop	r15
    5c38:	ef 90       	pop	r14
    5c3a:	df 90       	pop	r13
    5c3c:	cf 90       	pop	r12
    5c3e:	bf 90       	pop	r11
    5c40:	9f 90       	pop	r9
    5c42:	8f 90       	pop	r8
    5c44:	08 95       	ret

00005c46 <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    5c46:	8f 92       	push	r8
    5c48:	9f 92       	push	r9
    5c4a:	af 92       	push	r10
    5c4c:	bf 92       	push	r11
    5c4e:	df 92       	push	r13
    5c50:	ef 92       	push	r14
    5c52:	ff 92       	push	r15
    5c54:	0f 93       	push	r16
    5c56:	1f 93       	push	r17
    5c58:	df 93       	push	r29
    5c5a:	cf 93       	push	r28
    5c5c:	cd b7       	in	r28, 0x3d	; 61
    5c5e:	de b7       	in	r29, 0x3e	; 62
    5c60:	2d 97       	sbiw	r28, 0x0d	; 13
    5c62:	0f b6       	in	r0, 0x3f	; 63
    5c64:	f8 94       	cli
    5c66:	de bf       	out	0x3e, r29	; 62
    5c68:	0f be       	out	0x3f, r0	; 63
    5c6a:	cd bf       	out	0x3d, r28	; 61
    5c6c:	9c 01       	movw	r18, r24
    5c6e:	7b 01       	movw	r14, r22
    5c70:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    5c72:	dc 01       	movw	r26, r24
    5c74:	15 96       	adiw	r26, 0x05	; 5
    5c76:	8c 91       	ld	r24, X
    5c78:	90 e0       	ldi	r25, 0x00	; 0
    5c7a:	c0 97       	sbiw	r24, 0x30	; 48
    5c7c:	68 e0       	ldi	r22, 0x08	; 8
    5c7e:	70 e0       	ldi	r23, 0x00	; 0
    5c80:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    5c84:	f7 01       	movw	r30, r14
    5c86:	e8 0f       	add	r30, r24
    5c88:	f1 1d       	adc	r31, r1
    5c8a:	80 81       	ld	r24, Z
    5c8c:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    5c8e:	f9 01       	movw	r30, r18
    5c90:	86 81       	ldd	r24, Z+6	; 0x06
    5c92:	90 e0       	ldi	r25, 0x00	; 0
    5c94:	c0 97       	sbiw	r24, 0x30	; 48
    5c96:	68 e0       	ldi	r22, 0x08	; 8
    5c98:	70 e0       	ldi	r23, 0x00	; 0
    5c9a:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    5c9e:	f7 01       	movw	r30, r14
    5ca0:	e8 0f       	add	r30, r24
    5ca2:	f1 1d       	adc	r31, r1
    5ca4:	80 81       	ld	r24, Z
    5ca6:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    5ca8:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    5caa:	8d b7       	in	r24, 0x3d	; 61
    5cac:	9e b7       	in	r25, 0x3e	; 62
    5cae:	08 97       	sbiw	r24, 0x08	; 8
    5cb0:	0f b6       	in	r0, 0x3f	; 63
    5cb2:	f8 94       	cli
    5cb4:	9e bf       	out	0x3e, r25	; 62
    5cb6:	0f be       	out	0x3f, r0	; 63
    5cb8:	8d bf       	out	0x3d, r24	; 61
    5cba:	ed b7       	in	r30, 0x3d	; 61
    5cbc:	fe b7       	in	r31, 0x3e	; 62
    5cbe:	31 96       	adiw	r30, 0x01	; 1
    5cc0:	8e 01       	movw	r16, r28
    5cc2:	0c 5f       	subi	r16, 0xFC	; 252
    5cc4:	1f 4f       	sbci	r17, 0xFF	; 255
    5cc6:	ad b7       	in	r26, 0x3d	; 61
    5cc8:	be b7       	in	r27, 0x3e	; 62
    5cca:	12 96       	adiw	r26, 0x02	; 2
    5ccc:	1c 93       	st	X, r17
    5cce:	0e 93       	st	-X, r16
    5cd0:	11 97       	sbiw	r26, 0x01	; 1
    5cd2:	84 ed       	ldi	r24, 0xD4	; 212
    5cd4:	96 e1       	ldi	r25, 0x16	; 22
    5cd6:	93 83       	std	Z+3, r25	; 0x03
    5cd8:	82 83       	std	Z+2, r24	; 0x02
    5cda:	35 83       	std	Z+5, r19	; 0x05
    5cdc:	24 83       	std	Z+4, r18	; 0x04
    5cde:	ce 01       	movw	r24, r28
    5ce0:	01 96       	adiw	r24, 0x01	; 1
    5ce2:	97 83       	std	Z+7, r25	; 0x07
    5ce4:	86 83       	std	Z+6, r24	; 0x06
    5ce6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    5cea:	dd 24       	eor	r13, r13
    5cec:	ed b7       	in	r30, 0x3d	; 61
    5cee:	fe b7       	in	r31, 0x3e	; 62
    5cf0:	38 96       	adiw	r30, 0x08	; 8
    5cf2:	0f b6       	in	r0, 0x3f	; 63
    5cf4:	f8 94       	cli
    5cf6:	fe bf       	out	0x3e, r31	; 62
    5cf8:	0f be       	out	0x3f, r0	; 63
    5cfa:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    5cfc:	48 01       	movw	r8, r16
    5cfe:	13 c0       	rjmp	.+38     	; 0x5d26 <GenerateKeyStamp+0xe0>
    5d00:	f4 01       	movw	r30, r8
    5d02:	e0 0f       	add	r30, r16
    5d04:	f1 1f       	adc	r31, r17
    5d06:	60 81       	ld	r22, Z
    5d08:	60 53       	subi	r22, 0x30	; 48
    5d0a:	f7 01       	movw	r30, r14
    5d0c:	e0 0f       	add	r30, r16
    5d0e:	f1 1f       	adc	r31, r17
    5d10:	40 81       	ld	r20, Z
    5d12:	40 53       	subi	r20, 0x30	; 48
    5d14:	81 e0       	ldi	r24, 0x01	; 1
    5d16:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <GeniusCalc>
    5d1a:	0a 0d       	add	r16, r10
    5d1c:	1b 1d       	adc	r17, r11
    5d1e:	80 5d       	subi	r24, 0xD0	; 208
    5d20:	d8 01       	movw	r26, r16
    5d22:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    5d24:	d3 94       	inc	r13
    5d26:	0d 2d       	mov	r16, r13
    5d28:	10 e0       	ldi	r17, 0x00	; 0
    5d2a:	d7 01       	movw	r26, r14
    5d2c:	0d 90       	ld	r0, X+
    5d2e:	00 20       	and	r0, r0
    5d30:	e9 f7       	brne	.-6      	; 0x5d2c <GenerateKeyStamp+0xe6>
    5d32:	11 97       	sbiw	r26, 0x01	; 1
    5d34:	ae 19       	sub	r26, r14
    5d36:	bf 09       	sbc	r27, r15
    5d38:	0a 17       	cp	r16, r26
    5d3a:	1b 07       	cpc	r17, r27
    5d3c:	08 f3       	brcs	.-62     	; 0x5d00 <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    5d3e:	aa 0d       	add	r26, r10
    5d40:	bb 1d       	adc	r27, r11
    5d42:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    5d44:	c5 01       	movw	r24, r10
    5d46:	0e 94 b9 2d 	call	0x5b72	; 0x5b72 <WrapCode>
}
    5d4a:	2d 96       	adiw	r28, 0x0d	; 13
    5d4c:	0f b6       	in	r0, 0x3f	; 63
    5d4e:	f8 94       	cli
    5d50:	de bf       	out	0x3e, r29	; 62
    5d52:	0f be       	out	0x3f, r0	; 63
    5d54:	cd bf       	out	0x3d, r28	; 61
    5d56:	cf 91       	pop	r28
    5d58:	df 91       	pop	r29
    5d5a:	1f 91       	pop	r17
    5d5c:	0f 91       	pop	r16
    5d5e:	ff 90       	pop	r15
    5d60:	ef 90       	pop	r14
    5d62:	df 90       	pop	r13
    5d64:	bf 90       	pop	r11
    5d66:	af 90       	pop	r10
    5d68:	9f 90       	pop	r9
    5d6a:	8f 90       	pop	r8
    5d6c:	08 95       	ret

00005d6e <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    5d6e:	af 92       	push	r10
    5d70:	bf 92       	push	r11
    5d72:	cf 92       	push	r12
    5d74:	df 92       	push	r13
    5d76:	ef 92       	push	r14
    5d78:	ff 92       	push	r15
    5d7a:	0f 93       	push	r16
    5d7c:	1f 93       	push	r17
    5d7e:	df 93       	push	r29
    5d80:	cf 93       	push	r28
    5d82:	cd b7       	in	r28, 0x3d	; 61
    5d84:	de b7       	in	r29, 0x3e	; 62
    5d86:	28 97       	sbiw	r28, 0x08	; 8
    5d88:	0f b6       	in	r0, 0x3f	; 63
    5d8a:	f8 94       	cli
    5d8c:	de bf       	out	0x3e, r29	; 62
    5d8e:	0f be       	out	0x3f, r0	; 63
    5d90:	cd bf       	out	0x3d, r28	; 61
    5d92:	7c 01       	movw	r14, r24
    5d94:	c6 2e       	mov	r12, r22
    5d96:	5a 01       	movw	r10, r20
	     WrapC ->68846545
	 */ 
	 char i,GCalcOpt,AddYear[3],SYear[5];
	 char strSend[20];

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-3,2);
    5d98:	fc 01       	movw	r30, r24
    5d9a:	01 90       	ld	r0, Z+
    5d9c:	00 20       	and	r0, r0
    5d9e:	e9 f7       	brne	.-6      	; 0x5d9a <GenerateGeniusCode+0x2c>
    5da0:	e8 1b       	sub	r30, r24
    5da2:	f9 0b       	sbc	r31, r25
    5da4:	34 97       	sbiw	r30, 0x04	; 4
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5da6:	e8 0f       	add	r30, r24
    5da8:	f9 1f       	adc	r31, r25
    5daa:	80 81       	ld	r24, Z
    5dac:	89 83       	std	Y+1, r24	; 0x01
    5dae:	81 81       	ldd	r24, Z+1	; 0x01
    5db0:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    5db2:	1b 82       	std	Y+3, r1	; 0x03
	 */ 
	 char i,GCalcOpt,AddYear[3],SYear[5];
	 char strSend[20];

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-3,2);
	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    5db4:	00 d0       	rcall	.+0      	; 0x5db6 <GenerateGeniusCode+0x48>
    5db6:	00 d0       	rcall	.+0      	; 0x5db8 <GenerateGeniusCode+0x4a>
    5db8:	00 d0       	rcall	.+0      	; 0x5dba <GenerateGeniusCode+0x4c>
    5dba:	ed b7       	in	r30, 0x3d	; 61
    5dbc:	fe b7       	in	r31, 0x3e	; 62
    5dbe:	31 96       	adiw	r30, 0x01	; 1
    5dc0:	8e 01       	movw	r16, r28
    5dc2:	0c 5f       	subi	r16, 0xFC	; 252
    5dc4:	1f 4f       	sbci	r17, 0xFF	; 255
    5dc6:	ad b7       	in	r26, 0x3d	; 61
    5dc8:	be b7       	in	r27, 0x3e	; 62
    5dca:	12 96       	adiw	r26, 0x02	; 2
    5dcc:	1c 93       	st	X, r17
    5dce:	0e 93       	st	-X, r16
    5dd0:	11 97       	sbiw	r26, 0x01	; 1
    5dd2:	8f ed       	ldi	r24, 0xDF	; 223
    5dd4:	96 e1       	ldi	r25, 0x16	; 22
    5dd6:	93 83       	std	Z+3, r25	; 0x03
    5dd8:	82 83       	std	Z+2, r24	; 0x02
    5dda:	ce 01       	movw	r24, r28
    5ddc:	01 96       	adiw	r24, 0x01	; 1
    5dde:	95 83       	std	Z+5, r25	; 0x05
    5de0:	84 83       	std	Z+4, r24	; 0x04
    5de2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    5de6:	d7 01       	movw	r26, r14
    5de8:	0d 90       	ld	r0, X+
    5dea:	00 20       	and	r0, r0
    5dec:	e9 f7       	brne	.-6      	; 0x5de8 <GenerateGeniusCode+0x7a>
    5dee:	9d 01       	movw	r18, r26
    5df0:	21 50       	subi	r18, 0x01	; 1
    5df2:	30 40       	sbci	r19, 0x00	; 0
    5df4:	2e 19       	sub	r18, r14
    5df6:	3f 09       	sbc	r19, r15
    5df8:	d8 01       	movw	r26, r16
    5dfa:	0d 90       	ld	r0, X+
    5dfc:	00 20       	and	r0, r0
    5dfe:	e9 f7       	brne	.-6      	; 0x5dfa <GenerateGeniusCode+0x8c>
    5e00:	11 97       	sbiw	r26, 0x01	; 1
    5e02:	a0 1b       	sub	r26, r16
    5e04:	b1 0b       	sbc	r27, r17
    5e06:	22 50       	subi	r18, 0x02	; 2
    5e08:	30 40       	sbci	r19, 0x00	; 0
    5e0a:	b7 01       	movw	r22, r14
    5e0c:	62 0f       	add	r22, r18
    5e0e:	73 1f       	adc	r23, r19
    5e10:	2e 5f       	subi	r18, 0xFE	; 254
    5e12:	3f 4f       	sbci	r19, 0xFF	; 255
    5e14:	40 e0       	ldi	r20, 0x00	; 0
    5e16:	50 e0       	ldi	r21, 0x00	; 0
    5e18:	ed b7       	in	r30, 0x3d	; 61
    5e1a:	fe b7       	in	r31, 0x3e	; 62
    5e1c:	36 96       	adiw	r30, 0x06	; 6
    5e1e:	0f b6       	in	r0, 0x3f	; 63
    5e20:	f8 94       	cli
    5e22:	fe bf       	out	0x3e, r31	; 62
    5e24:	0f be       	out	0x3f, r0	; 63
    5e26:	ed bf       	out	0x3d, r30	; 61
    5e28:	09 c0       	rjmp	.+18     	; 0x5e3c <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    5e2a:	f8 01       	movw	r30, r16
    5e2c:	e4 0f       	add	r30, r20
    5e2e:	f5 1f       	adc	r31, r21
    5e30:	80 81       	ld	r24, Z
    5e32:	fb 01       	movw	r30, r22
    5e34:	81 93       	st	Z+, r24
    5e36:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5e38:	4f 5f       	subi	r20, 0xFF	; 255
    5e3a:	5f 4f       	sbci	r21, 0xFF	; 255
    5e3c:	4a 17       	cp	r20, r26
    5e3e:	5b 07       	cpc	r21, r27
    5e40:	a0 f3       	brcs	.-24     	; 0x5e2a <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    5e42:	ae 0d       	add	r26, r14
    5e44:	bf 1d       	adc	r27, r15
    5e46:	a2 0f       	add	r26, r18
    5e48:	b3 1f       	adc	r27, r19
    5e4a:	12 97       	sbiw	r26, 0x02	; 2
    5e4c:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	        sprintf_P(strSend,PSTR("[%s]"),srcDate);
			_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    5e4e:	00 d0       	rcall	.+0      	; 0x5e50 <GenerateGeniusCode+0xe2>
    5e50:	00 d0       	rcall	.+0      	; 0x5e52 <GenerateGeniusCode+0xe4>
    5e52:	00 d0       	rcall	.+0      	; 0x5e54 <GenerateGeniusCode+0xe6>
    5e54:	ed b7       	in	r30, 0x3d	; 61
    5e56:	fe b7       	in	r31, 0x3e	; 62
    5e58:	31 96       	adiw	r30, 0x01	; 1
    5e5a:	ad b7       	in	r26, 0x3d	; 61
    5e5c:	be b7       	in	r27, 0x3e	; 62
    5e5e:	12 96       	adiw	r26, 0x02	; 2
    5e60:	bc 92       	st	X, r11
    5e62:	ae 92       	st	-X, r10
    5e64:	11 97       	sbiw	r26, 0x01	; 1
    5e66:	8c ed       	ldi	r24, 0xDC	; 220
    5e68:	96 e1       	ldi	r25, 0x16	; 22
    5e6a:	93 83       	std	Z+3, r25	; 0x03
    5e6c:	82 83       	std	Z+2, r24	; 0x02
    5e6e:	c4 82       	std	Z+4, r12	; 0x04
    5e70:	15 82       	std	Z+5, r1	; 0x05
    5e72:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    5e76:	dd 24       	eor	r13, r13
    5e78:	d3 94       	inc	r13
    5e7a:	ed b7       	in	r30, 0x3d	; 61
    5e7c:	fe b7       	in	r31, 0x3e	; 62
    5e7e:	36 96       	adiw	r30, 0x06	; 6
    5e80:	0f b6       	in	r0, 0x3f	; 63
    5e82:	f8 94       	cli
    5e84:	fe bf       	out	0x3e, r31	; 62
    5e86:	0f be       	out	0x3f, r0	; 63
    5e88:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    5e8a:	f0 ed       	ldi	r31, 0xD0	; 208
    5e8c:	cf 0e       	add	r12, r31
    5e8e:	0f c0       	rjmp	.+30     	; 0x5eae <GenerateGeniusCode+0x140>
    5e90:	f7 01       	movw	r30, r14
    5e92:	e0 0f       	add	r30, r16
    5e94:	f1 1f       	adc	r31, r17
    5e96:	40 81       	ld	r20, Z
    5e98:	40 53       	subi	r20, 0x30	; 48
    5e9a:	80 e0       	ldi	r24, 0x00	; 0
    5e9c:	6c 2d       	mov	r22, r12
    5e9e:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <GeniusCalc>
    5ea2:	0a 0d       	add	r16, r10
    5ea4:	1b 1d       	adc	r17, r11
    5ea6:	80 5d       	subi	r24, 0xD0	; 208
    5ea8:	d8 01       	movw	r26, r16
    5eaa:	8c 93       	st	X, r24
			_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    5eac:	d3 94       	inc	r13
    5eae:	0d 2d       	mov	r16, r13
    5eb0:	10 e0       	ldi	r17, 0x00	; 0
    5eb2:	d7 01       	movw	r26, r14
    5eb4:	0d 90       	ld	r0, X+
    5eb6:	00 20       	and	r0, r0
    5eb8:	e9 f7       	brne	.-6      	; 0x5eb4 <GenerateGeniusCode+0x146>
    5eba:	11 97       	sbiw	r26, 0x01	; 1
    5ebc:	ae 19       	sub	r26, r14
    5ebe:	bf 09       	sbc	r27, r15
    5ec0:	0a 17       	cp	r16, r26
    5ec2:	1b 07       	cpc	r17, r27
    5ec4:	28 f3       	brcs	.-54     	; 0x5e90 <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    5ec6:	aa 0d       	add	r26, r10
    5ec8:	bb 1d       	adc	r27, r11
    5eca:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    5ecc:	c5 01       	movw	r24, r10
    5ece:	0e 94 b9 2d 	call	0x5b72	; 0x5b72 <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}
    5ed2:	28 96       	adiw	r28, 0x08	; 8
    5ed4:	0f b6       	in	r0, 0x3f	; 63
    5ed6:	f8 94       	cli
    5ed8:	de bf       	out	0x3e, r29	; 62
    5eda:	0f be       	out	0x3f, r0	; 63
    5edc:	cd bf       	out	0x3d, r28	; 61
    5ede:	cf 91       	pop	r28
    5ee0:	df 91       	pop	r29
    5ee2:	1f 91       	pop	r17
    5ee4:	0f 91       	pop	r16
    5ee6:	ff 90       	pop	r15
    5ee8:	ef 90       	pop	r14
    5eea:	df 90       	pop	r13
    5eec:	cf 90       	pop	r12
    5eee:	bf 90       	pop	r11
    5ef0:	af 90       	pop	r10
    5ef2:	08 95       	ret

00005ef4 <GeneratePrintInit>:
	IsBusyMsg11=True;
}



void GeneratePrintInit(){//Create Initialize Print 
    5ef4:	cf 92       	push	r12
    5ef6:	df 92       	push	r13
    5ef8:	ef 92       	push	r14
    5efa:	ff 92       	push	r15
    5efc:	0f 93       	push	r16
    5efe:	1f 93       	push	r17
    5f00:	df 93       	push	r29
    5f02:	cf 93       	push	r28
    5f04:	cd b7       	in	r28, 0x3d	; 61
    5f06:	de b7       	in	r29, 0x3e	; 62
    5f08:	62 97       	sbiw	r28, 0x12	; 18
    5f0a:	0f b6       	in	r0, 0x3f	; 63
    5f0c:	f8 94       	cli
    5f0e:	de bf       	out	0x3e, r29	; 62
    5f10:	0f be       	out	0x3f, r0	; 63
    5f12:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    5f14:	00 d0       	rcall	.+0      	; 0x5f16 <GeneratePrintInit+0x22>
    5f16:	00 d0       	rcall	.+0      	; 0x5f18 <GeneratePrintInit+0x24>
    5f18:	6e 01       	movw	r12, r28
    5f1a:	08 94       	sec
    5f1c:	c1 1c       	adc	r12, r1
    5f1e:	d1 1c       	adc	r13, r1
    5f20:	ad b7       	in	r26, 0x3d	; 61
    5f22:	be b7       	in	r27, 0x3e	; 62
    5f24:	12 96       	adiw	r26, 0x02	; 2
    5f26:	dc 92       	st	X, r13
    5f28:	ce 92       	st	-X, r12
    5f2a:	11 97       	sbiw	r26, 0x01	; 1
    5f2c:	8d e7       	ldi	r24, 0x7D	; 125
    5f2e:	9c e1       	ldi	r25, 0x1C	; 28
    5f30:	14 96       	adiw	r26, 0x04	; 4
    5f32:	9c 93       	st	X, r25
    5f34:	8e 93       	st	-X, r24
    5f36:	13 97       	sbiw	r26, 0x03	; 3
    5f38:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    5f3c:	37 e0       	ldi	r19, 0x07	; 7
    5f3e:	e3 2e       	mov	r14, r19
    5f40:	f1 2c       	mov	r15, r1
    5f42:	ec 0e       	add	r14, r28
    5f44:	fd 1e       	adc	r15, r29
    5f46:	ed b7       	in	r30, 0x3d	; 61
    5f48:	fe b7       	in	r31, 0x3e	; 62
    5f4a:	f2 82       	std	Z+2, r15	; 0x02
    5f4c:	e1 82       	std	Z+1, r14	; 0x01
    5f4e:	82 e7       	ldi	r24, 0x72	; 114
    5f50:	9c e1       	ldi	r25, 0x1C	; 28
    5f52:	94 83       	std	Z+4, r25	; 0x04
    5f54:	83 83       	std	Z+3, r24	; 0x03
    5f56:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    5f5a:	00 d0       	rcall	.+0      	; 0x5f5c <GeneratePrintInit+0x68>
    5f5c:	00 d0       	rcall	.+0      	; 0x5f5e <GeneratePrintInit+0x6a>
    5f5e:	ed b7       	in	r30, 0x3d	; 61
    5f60:	fe b7       	in	r31, 0x3e	; 62
    5f62:	31 96       	adiw	r30, 0x01	; 1
    5f64:	06 ef       	ldi	r16, 0xF6	; 246
    5f66:	15 e0       	ldi	r17, 0x05	; 5
    5f68:	ad b7       	in	r26, 0x3d	; 61
    5f6a:	be b7       	in	r27, 0x3e	; 62
    5f6c:	12 96       	adiw	r26, 0x02	; 2
    5f6e:	1c 93       	st	X, r17
    5f70:	0e 93       	st	-X, r16
    5f72:	11 97       	sbiw	r26, 0x01	; 1
    5f74:	80 e0       	ldi	r24, 0x00	; 0
    5f76:	9c e1       	ldi	r25, 0x1C	; 28
    5f78:	93 83       	std	Z+3, r25	; 0x03
    5f7a:	82 83       	std	Z+2, r24	; 0x02
    5f7c:	d5 82       	std	Z+5, r13	; 0x05
    5f7e:	c4 82       	std	Z+4, r12	; 0x04
    5f80:	f7 82       	std	Z+7, r15	; 0x07
    5f82:	e6 82       	std	Z+6, r14	; 0x06
    5f84:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(0,1,PrintBuffer);
    5f88:	ed b7       	in	r30, 0x3d	; 61
    5f8a:	fe b7       	in	r31, 0x3e	; 62
    5f8c:	38 96       	adiw	r30, 0x08	; 8
    5f8e:	0f b6       	in	r0, 0x3f	; 63
    5f90:	f8 94       	cli
    5f92:	fe bf       	out	0x3e, r31	; 62
    5f94:	0f be       	out	0x3f, r0	; 63
    5f96:	ed bf       	out	0x3d, r30	; 61
    5f98:	80 e0       	ldi	r24, 0x00	; 0
    5f9a:	61 e0       	ldi	r22, 0x01	; 1
    5f9c:	a8 01       	movw	r20, r16
    5f9e:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    5fa2:	f8 01       	movw	r30, r16
    5fa4:	01 90       	ld	r0, Z+
    5fa6:	00 20       	and	r0, r0
    5fa8:	e9 f7       	brne	.-6      	; 0x5fa4 <GeneratePrintInit+0xb0>
    5faa:	31 97       	sbiw	r30, 0x01	; 1
    5fac:	e0 1b       	sub	r30, r16
    5fae:	f1 0b       	sbc	r31, r17
    5fb0:	f0 93 b6 01 	sts	0x01B6, r31
    5fb4:	e0 93 b5 01 	sts	0x01B5, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    5fb8:	80 e3       	ldi	r24, 0x30	; 48
    5fba:	80 93 e1 01 	sts	0x01E1, r24
	 IsFreePrinting=True;
    5fbe:	81 e0       	ldi	r24, 0x01	; 1
    5fc0:	80 93 d5 01 	sts	0x01D5, r24
}
    5fc4:	62 96       	adiw	r28, 0x12	; 18
    5fc6:	0f b6       	in	r0, 0x3f	; 63
    5fc8:	f8 94       	cli
    5fca:	de bf       	out	0x3e, r29	; 62
    5fcc:	0f be       	out	0x3f, r0	; 63
    5fce:	cd bf       	out	0x3d, r28	; 61
    5fd0:	cf 91       	pop	r28
    5fd2:	df 91       	pop	r29
    5fd4:	1f 91       	pop	r17
    5fd6:	0f 91       	pop	r16
    5fd8:	ff 90       	pop	r15
    5fda:	ef 90       	pop	r14
    5fdc:	df 90       	pop	r13
    5fde:	cf 90       	pop	r12
    5fe0:	08 95       	ret

00005fe2 <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    5fe2:	9f 92       	push	r9
    5fe4:	af 92       	push	r10
    5fe6:	bf 92       	push	r11
    5fe8:	cf 92       	push	r12
    5fea:	df 92       	push	r13
    5fec:	ef 92       	push	r14
    5fee:	ff 92       	push	r15
    5ff0:	0f 93       	push	r16
    5ff2:	1f 93       	push	r17
    5ff4:	df 93       	push	r29
    5ff6:	cf 93       	push	r28
    5ff8:	cd b7       	in	r28, 0x3d	; 61
    5ffa:	de b7       	in	r29, 0x3e	; 62
    5ffc:	64 97       	sbiw	r28, 0x14	; 20
    5ffe:	0f b6       	in	r0, 0x3f	; 63
    6000:	f8 94       	cli
    6002:	de bf       	out	0x3e, r29	; 62
    6004:	0f be       	out	0x3f, r0	; 63
    6006:	cd bf       	out	0x3d, r28	; 61
    6008:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    600a:	e1 99       	sbic	0x1c, 1	; 28
    600c:	fe cf       	rjmp	.-4      	; 0x600a <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    600e:	8f e3       	ldi	r24, 0x3F	; 63
    6010:	90 e0       	ldi	r25, 0x00	; 0
    6012:	9f bb       	out	0x1f, r25	; 31
    6014:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6016:	e0 9a       	sbi	0x1c, 0	; 28
    6018:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    601a:	e1 99       	sbic	0x1c, 1	; 28
    601c:	fe cf       	rjmp	.-4      	; 0x601a <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    601e:	8e e3       	ldi	r24, 0x3E	; 62
    6020:	90 e0       	ldi	r25, 0x00	; 0
    6022:	9f bb       	out	0x1f, r25	; 31
    6024:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6026:	e0 9a       	sbi	0x1c, 0	; 28
    6028:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    602a:	f6 01       	movw	r30, r12
    602c:	01 90       	ld	r0, Z+
    602e:	00 20       	and	r0, r0
    6030:	e9 f7       	brne	.-6      	; 0x602c <FormatCurrency+0x4a>
    6032:	31 97       	sbiw	r30, 0x01	; 1
    6034:	ee 2e       	mov	r14, r30
    6036:	ec 18       	sub	r14, r12
    6038:	fe 01       	movw	r30, r28
    603a:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    603c:	ce 01       	movw	r24, r28
    603e:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    6040:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6042:	e8 17       	cp	r30, r24
    6044:	f9 07       	cpc	r31, r25
    6046:	e1 f7       	brne	.-8      	; 0x6040 <FormatCurrency+0x5e>
    6048:	f6 01       	movw	r30, r12
    604a:	fe 2c       	mov	r15, r14
    604c:	80 e0       	ldi	r24, 0x00	; 0
    604e:	20 e0       	ldi	r18, 0x00	; 0
    6050:	09 c0       	rjmp	.+18     	; 0x6064 <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    6052:	90 81       	ld	r25, Z
    6054:	93 17       	cp	r25, r19
    6056:	09 f4       	brne	.+2      	; 0x605a <FormatCurrency+0x78>
    6058:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    605a:	99 15       	cp	r25, r9
    605c:	09 f4       	brne	.+2      	; 0x6060 <FormatCurrency+0x7e>
    605e:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    6060:	8f 5f       	subi	r24, 0xFF	; 255
    6062:	31 96       	adiw	r30, 0x01	; 1
    6064:	8e 15       	cp	r24, r14
    6066:	a8 f3       	brcs	.-22     	; 0x6052 <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    6068:	22 23       	and	r18, r18
    606a:	09 f0       	breq	.+2      	; 0x606e <FormatCurrency+0x8c>
    606c:	5e c0       	rjmp	.+188    	; 0x612a <FormatCurrency+0x148>
    606e:	83 e0       	ldi	r24, 0x03	; 3
    6070:	8f 15       	cp	r24, r15
    6072:	08 f0       	brcs	.+2      	; 0x6076 <FormatCurrency+0x94>
    6074:	5a c0       	rjmp	.+180    	; 0x612a <FormatCurrency+0x148>
    6076:	40 e0       	ldi	r20, 0x00	; 0
    6078:	20 e0       	ldi	r18, 0x00	; 0
    607a:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    607c:	af 2c       	mov	r10, r15
    607e:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    6080:	8e 01       	movw	r16, r28
    6082:	0f 5f       	subi	r16, 0xFF	; 255
    6084:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    6086:	c5 01       	movw	r24, r10
    6088:	82 1b       	sub	r24, r18
    608a:	93 0b       	sbc	r25, r19
    608c:	63 e0       	ldi	r22, 0x03	; 3
    608e:	70 e0       	ldi	r23, 0x00	; 0
    6090:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    6094:	89 2b       	or	r24, r25
    6096:	49 f4       	brne	.+18     	; 0x60aa <FormatCurrency+0xc8>
    6098:	2f 15       	cp	r18, r15
    609a:	38 f4       	brcc	.+14     	; 0x60aa <FormatCurrency+0xc8>
    609c:	22 23       	and	r18, r18
    609e:	29 f0       	breq	.+10     	; 0x60aa <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    60a0:	f8 01       	movw	r30, r16
    60a2:	e4 0f       	add	r30, r20
    60a4:	f1 1d       	adc	r31, r1
    60a6:	90 82       	st	Z, r9
		        iPos++;
    60a8:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    60aa:	d8 01       	movw	r26, r16
    60ac:	a4 0f       	add	r26, r20
    60ae:	b1 1d       	adc	r27, r1
    60b0:	f6 01       	movw	r30, r12
    60b2:	e2 0f       	add	r30, r18
    60b4:	f3 1f       	adc	r31, r19
    60b6:	80 81       	ld	r24, Z
    60b8:	8c 93       	st	X, r24
			    iPos++;
    60ba:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    60bc:	f8 01       	movw	r30, r16
    60be:	e4 0f       	add	r30, r20
    60c0:	f1 1d       	adc	r31, r1
    60c2:	10 82       	st	Z, r1
    60c4:	2f 5f       	subi	r18, 0xFF	; 255
    60c6:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    60c8:	2f 15       	cp	r18, r15
    60ca:	e8 f2       	brcs	.-70     	; 0x6086 <FormatCurrency+0xa4>
    60cc:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    60ce:	9e 01       	movw	r18, r28
    60d0:	2f 5f       	subi	r18, 0xFF	; 255
    60d2:	3f 4f       	sbci	r19, 0xFF	; 255
    60d4:	0e c0       	rjmp	.+28     	; 0x60f2 <FormatCurrency+0x110>
    60d6:	d9 01       	movw	r26, r18
    60d8:	a4 0f       	add	r26, r20
    60da:	b1 1d       	adc	r27, r1
    60dc:	f6 01       	movw	r30, r12
    60de:	e9 0f       	add	r30, r25
    60e0:	f1 1d       	adc	r31, r1
    60e2:	80 81       	ld	r24, Z
    60e4:	8c 93       	st	X, r24
			    iPos++;
    60e6:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    60e8:	f9 01       	movw	r30, r18
    60ea:	e4 0f       	add	r30, r20
    60ec:	f1 1d       	adc	r31, r1
    60ee:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    60f0:	9f 5f       	subi	r25, 0xFF	; 255
    60f2:	9e 15       	cp	r25, r14
    60f4:	80 f3       	brcs	.-32     	; 0x60d6 <FormatCurrency+0xf4>
    60f6:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    60f8:	9e 01       	movw	r18, r28
    60fa:	2f 5f       	subi	r18, 0xFF	; 255
    60fc:	3f 4f       	sbci	r19, 0xFF	; 255
    60fe:	09 c0       	rjmp	.+18     	; 0x6112 <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    6100:	f6 01       	movw	r30, r12
    6102:	ea 0f       	add	r30, r26
    6104:	fb 1f       	adc	r31, r27
    6106:	a2 0f       	add	r26, r18
    6108:	b3 1f       	adc	r27, r19
    610a:	8c 91       	ld	r24, X
    610c:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    610e:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6110:	9f 5f       	subi	r25, 0xFF	; 255
    6112:	a9 2f       	mov	r26, r25
    6114:	b0 e0       	ldi	r27, 0x00	; 0
    6116:	f9 01       	movw	r30, r18
    6118:	01 90       	ld	r0, Z+
    611a:	00 20       	and	r0, r0
    611c:	e9 f7       	brne	.-6      	; 0x6118 <FormatCurrency+0x136>
    611e:	31 97       	sbiw	r30, 0x01	; 1
    6120:	e2 1b       	sub	r30, r18
    6122:	f3 0b       	sbc	r31, r19
    6124:	ae 17       	cp	r26, r30
    6126:	bf 07       	cpc	r27, r31
    6128:	58 f3       	brcs	.-42     	; 0x6100 <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    612a:	64 96       	adiw	r28, 0x14	; 20
    612c:	0f b6       	in	r0, 0x3f	; 63
    612e:	f8 94       	cli
    6130:	de bf       	out	0x3e, r29	; 62
    6132:	0f be       	out	0x3f, r0	; 63
    6134:	cd bf       	out	0x3d, r28	; 61
    6136:	cf 91       	pop	r28
    6138:	df 91       	pop	r29
    613a:	1f 91       	pop	r17
    613c:	0f 91       	pop	r16
    613e:	ff 90       	pop	r15
    6140:	ef 90       	pop	r14
    6142:	df 90       	pop	r13
    6144:	cf 90       	pop	r12
    6146:	bf 90       	pop	r11
    6148:	af 90       	pop	r10
    614a:	9f 90       	pop	r9
    614c:	08 95       	ret

0000614e <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    614e:	ef 92       	push	r14
    6150:	ff 92       	push	r15
    6152:	0f 93       	push	r16
    6154:	1f 93       	push	r17
    6156:	df 93       	push	r29
    6158:	cf 93       	push	r28
    615a:	cd b7       	in	r28, 0x3d	; 61
    615c:	de b7       	in	r29, 0x3e	; 62
    615e:	64 97       	sbiw	r28, 0x14	; 20
    6160:	0f b6       	in	r0, 0x3f	; 63
    6162:	f8 94       	cli
    6164:	de bf       	out	0x3e, r29	; 62
    6166:	0f be       	out	0x3f, r0	; 63
    6168:	cd bf       	out	0x3d, r28	; 61
    616a:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    616c:	66 23       	and	r22, r22
    616e:	09 f4       	brne	.+2      	; 0x6172 <FormatDecimal+0x24>
    6170:	56 c0       	rjmp	.+172    	; 0x621e <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6172:	e1 99       	sbic	0x1c, 1	; 28
    6174:	fe cf       	rjmp	.-4      	; 0x6172 <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6176:	8e e3       	ldi	r24, 0x3E	; 62
    6178:	90 e0       	ldi	r25, 0x00	; 0
    617a:	9f bb       	out	0x1f, r25	; 31
    617c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    617e:	e0 9a       	sbi	0x1c, 0	; 28
    6180:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    6182:	f8 01       	movw	r30, r16
    6184:	01 90       	ld	r0, Z+
    6186:	00 20       	and	r0, r0
    6188:	e9 f7       	brne	.-6      	; 0x6184 <FormatDecimal+0x36>
    618a:	31 97       	sbiw	r30, 0x01	; 1
    618c:	3e 2f       	mov	r19, r30
    618e:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    6190:	63 17       	cp	r22, r19
    6192:	b8 f5       	brcc	.+110    	; 0x6202 <FormatDecimal+0xb4>
    6194:	f3 2e       	mov	r15, r19
    6196:	f6 1a       	sub	r15, r22
    6198:	b8 01       	movw	r22, r16
    619a:	d8 01       	movw	r26, r16
    619c:	20 e0       	ldi	r18, 0x00	; 0
    619e:	90 e0       	ldi	r25, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    61a0:	ae 01       	movw	r20, r28
    61a2:	4f 5f       	subi	r20, 0xFF	; 255
    61a4:	5f 4f       	sbci	r21, 0xFF	; 255
    61a6:	0e c0       	rjmp	.+28     	; 0x61c4 <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    61a8:	2f 15       	cp	r18, r15
    61aa:	29 f4       	brne	.+10     	; 0x61b6 <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    61ac:	fa 01       	movw	r30, r20
    61ae:	e9 0f       	add	r30, r25
    61b0:	f1 1d       	adc	r31, r1
    61b2:	e0 82       	st	Z, r14
				 iPos++;
    61b4:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    61b6:	fa 01       	movw	r30, r20
    61b8:	e9 0f       	add	r30, r25
    61ba:	f1 1d       	adc	r31, r1
    61bc:	8d 91       	ld	r24, X+
    61be:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    61c0:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    61c2:	2f 5f       	subi	r18, 0xFF	; 255
    61c4:	23 17       	cp	r18, r19
    61c6:	80 f3       	brcs	.-32     	; 0x61a8 <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    61c8:	9e 01       	movw	r18, r28
    61ca:	2f 5f       	subi	r18, 0xFF	; 255
    61cc:	3f 4f       	sbci	r19, 0xFF	; 255
    61ce:	f9 01       	movw	r30, r18
    61d0:	e9 0f       	add	r30, r25
    61d2:	f1 1d       	adc	r31, r1
    61d4:	10 82       	st	Z, r1
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    61d6:	f9 01       	movw	r30, r18
    61d8:	01 90       	ld	r0, Z+
    61da:	00 20       	and	r0, r0
    61dc:	e9 f7       	brne	.-6      	; 0x61d8 <FormatDecimal+0x8a>
    61de:	31 97       	sbiw	r30, 0x01	; 1
    61e0:	9e 2f       	mov	r25, r30
    61e2:	92 1b       	sub	r25, r18
    61e4:	d9 01       	movw	r26, r18
    61e6:	04 c0       	rjmp	.+8      	; 0x61f0 <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    61e8:	8d 91       	ld	r24, X+
    61ea:	fb 01       	movw	r30, r22
    61ec:	81 93       	st	Z+, r24
    61ee:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    61f0:	8a 2f       	mov	r24, r26
    61f2:	82 1b       	sub	r24, r18
    61f4:	89 17       	cp	r24, r25
    61f6:	c0 f3       	brcs	.-16     	; 0x61e8 <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    61f8:	09 0f       	add	r16, r25
    61fa:	11 1d       	adc	r17, r1
    61fc:	f8 01       	movw	r30, r16
    61fe:	10 82       	st	Z, r1
    6200:	0e c0       	rjmp	.+28     	; 0x621e <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    6202:	6f 5f       	subi	r22, 0xFF	; 255
    6204:	c8 01       	movw	r24, r16
    6206:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    620a:	f8 01       	movw	r30, r16
    620c:	01 90       	ld	r0, Z+
    620e:	00 20       	and	r0, r0
    6210:	e9 f7       	brne	.-6      	; 0x620c <FormatDecimal+0xbe>
    6212:	31 97       	sbiw	r30, 0x01	; 1
    6214:	3e 2f       	mov	r19, r30
    6216:	30 1b       	sub	r19, r16
    6218:	ff 24       	eor	r15, r15
    621a:	f3 94       	inc	r15
    621c:	bd cf       	rjmp	.-134    	; 0x6198 <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}
    621e:	64 96       	adiw	r28, 0x14	; 20
    6220:	0f b6       	in	r0, 0x3f	; 63
    6222:	f8 94       	cli
    6224:	de bf       	out	0x3e, r29	; 62
    6226:	0f be       	out	0x3f, r0	; 63
    6228:	cd bf       	out	0x3d, r28	; 61
    622a:	cf 91       	pop	r28
    622c:	df 91       	pop	r29
    622e:	1f 91       	pop	r17
    6230:	0f 91       	pop	r16
    6232:	ff 90       	pop	r15
    6234:	ef 90       	pop	r14
    6236:	08 95       	ret

00006238 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    6238:	68 2f       	mov	r22, r24
    623a:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    623c:	0e 94 a7 30 	call	0x614e	; 0x614e <FormatDecimal>
}
    6240:	08 95       	ret

00006242 <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    6242:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6244:	e1 99       	sbic	0x1c, 1	; 28
    6246:	fe cf       	rjmp	.-4      	; 0x6244 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6248:	8c e3       	ldi	r24, 0x3C	; 60
    624a:	90 e0       	ldi	r25, 0x00	; 0
    624c:	9f bb       	out	0x1f, r25	; 31
    624e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6250:	e0 9a       	sbi	0x1c, 0	; 28
    6252:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6254:	c9 01       	movw	r24, r18
    6256:	0e 94 a7 30 	call	0x614e	; 0x614e <FormatDecimal>
}
    625a:	08 95       	ret

0000625c <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    625c:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    625e:	e1 99       	sbic	0x1c, 1	; 28
    6260:	fe cf       	rjmp	.-4      	; 0x625e <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6262:	8d e3       	ldi	r24, 0x3D	; 61
    6264:	90 e0       	ldi	r25, 0x00	; 0
    6266:	9f bb       	out	0x1f, r25	; 31
    6268:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    626a:	e0 9a       	sbi	0x1c, 0	; 28
    626c:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    626e:	c9 01       	movw	r24, r18
    6270:	0e 94 a7 30 	call	0x614e	; 0x614e <FormatDecimal>
}
    6274:	08 95       	ret

00006276 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    6276:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6278:	e1 99       	sbic	0x1c, 1	; 28
    627a:	fe cf       	rjmp	.-4      	; 0x6278 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    627c:	8a e3       	ldi	r24, 0x3A	; 58
    627e:	90 e0       	ldi	r25, 0x00	; 0
    6280:	9f bb       	out	0x1f, r25	; 31
    6282:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6284:	e0 9a       	sbi	0x1c, 0	; 28
    6286:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6288:	c9 01       	movw	r24, r18
    628a:	0e 94 a7 30 	call	0x614e	; 0x614e <FormatDecimal>
}
    628e:	08 95       	ret

00006290 <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    6290:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6292:	e1 99       	sbic	0x1c, 1	; 28
    6294:	fe cf       	rjmp	.-4      	; 0x6292 <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6296:	8b e3       	ldi	r24, 0x3B	; 59
    6298:	90 e0       	ldi	r25, 0x00	; 0
    629a:	9f bb       	out	0x1f, r25	; 31
    629c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    629e:	e0 9a       	sbi	0x1c, 0	; 28
    62a0:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    62a2:	c9 01       	movw	r24, r18
    62a4:	0e 94 a7 30 	call	0x614e	; 0x614e <FormatDecimal>
}
    62a8:	08 95       	ret

000062aa <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    62aa:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    62ac:	e1 99       	sbic	0x1c, 1	; 28
    62ae:	fe cf       	rjmp	.-4      	; 0x62ac <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    62b0:	89 e3       	ldi	r24, 0x39	; 57
    62b2:	90 e0       	ldi	r25, 0x00	; 0
    62b4:	9f bb       	out	0x1f, r25	; 31
    62b6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    62b8:	e0 9a       	sbi	0x1c, 0	; 28
    62ba:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    62bc:	c9 01       	movw	r24, r18
    62be:	0e 94 a7 30 	call	0x614e	; 0x614e <FormatDecimal>
}
    62c2:	08 95       	ret

000062c4 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    62c4:	2f 92       	push	r2
    62c6:	3f 92       	push	r3
    62c8:	4f 92       	push	r4
    62ca:	5f 92       	push	r5
    62cc:	6f 92       	push	r6
    62ce:	7f 92       	push	r7
    62d0:	8f 92       	push	r8
    62d2:	9f 92       	push	r9
    62d4:	af 92       	push	r10
    62d6:	bf 92       	push	r11
    62d8:	cf 92       	push	r12
    62da:	df 92       	push	r13
    62dc:	ef 92       	push	r14
    62de:	ff 92       	push	r15
    62e0:	0f 93       	push	r16
    62e2:	1f 93       	push	r17
    62e4:	df 93       	push	r29
    62e6:	cf 93       	push	r28
    62e8:	cd b7       	in	r28, 0x3d	; 61
    62ea:	de b7       	in	r29, 0x3e	; 62
    62ec:	c8 5f       	subi	r28, 0xF8	; 248
    62ee:	d0 40       	sbci	r29, 0x00	; 0
    62f0:	0f b6       	in	r0, 0x3f	; 63
    62f2:	f8 94       	cli
    62f4:	de bf       	out	0x3e, r29	; 62
    62f6:	0f be       	out	0x3f, r0	; 63
    62f8:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char PadLength,iTotal;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    62fa:	10 91 2f 02 	lds	r17, 0x022F
    62fe:	16 30       	cpi	r17, 0x06	; 6
    6300:	09 f4       	brne	.+2      	; 0x6304 <systemGenerateReport+0x40>
    6302:	5d c2       	rjmp	.+1210   	; 0x67be <systemGenerateReport+0x4fa>
    6304:	17 30       	cpi	r17, 0x07	; 7
    6306:	a8 f4       	brcc	.+42     	; 0x6332 <systemGenerateReport+0x6e>
    6308:	12 30       	cpi	r17, 0x02	; 2
    630a:	09 f4       	brne	.+2      	; 0x630e <systemGenerateReport+0x4a>
    630c:	a9 c0       	rjmp	.+338    	; 0x6460 <systemGenerateReport+0x19c>
    630e:	13 30       	cpi	r17, 0x03	; 3
    6310:	38 f4       	brcc	.+14     	; 0x6320 <systemGenerateReport+0x5c>
    6312:	11 23       	and	r17, r17
    6314:	41 f1       	breq	.+80     	; 0x6366 <systemGenerateReport+0xa2>
    6316:	11 30       	cpi	r17, 0x01	; 1
    6318:	11 f0       	breq	.+4      	; 0x631e <systemGenerateReport+0x5a>
    631a:	0c 94 7b 3c 	jmp	0x78f6	; 0x78f6 <systemGenerateReport+0x1632>
    631e:	2f c0       	rjmp	.+94     	; 0x637e <systemGenerateReport+0xba>
    6320:	14 30       	cpi	r17, 0x04	; 4
    6322:	09 f4       	brne	.+2      	; 0x6326 <systemGenerateReport+0x62>
    6324:	c8 c1       	rjmp	.+912    	; 0x66b6 <systemGenerateReport+0x3f2>
    6326:	80 91 df 01 	lds	r24, 0x01DF
    632a:	15 30       	cpi	r17, 0x05	; 5
    632c:	08 f0       	brcs	.+2      	; 0x6330 <systemGenerateReport+0x6c>
    632e:	4c c7       	rjmp	.+3736   	; 0x71c8 <systemGenerateReport+0xf04>
    6330:	bb c1       	rjmp	.+886    	; 0x66a8 <systemGenerateReport+0x3e4>
    6332:	19 30       	cpi	r17, 0x09	; 9
    6334:	09 f4       	brne	.+2      	; 0x6338 <systemGenerateReport+0x74>
    6336:	46 c7       	rjmp	.+3724   	; 0x71c4 <systemGenerateReport+0xf00>
    6338:	1a 30       	cpi	r17, 0x0A	; 10
    633a:	40 f4       	brcc	.+16     	; 0x634c <systemGenerateReport+0x88>
    633c:	17 30       	cpi	r17, 0x07	; 7
    633e:	09 f4       	brne	.+2      	; 0x6342 <systemGenerateReport+0x7e>
    6340:	a8 c2       	rjmp	.+1360   	; 0x6892 <systemGenerateReport+0x5ce>
    6342:	18 30       	cpi	r17, 0x08	; 8
    6344:	11 f0       	breq	.+4      	; 0x634a <systemGenerateReport+0x86>
    6346:	0c 94 7b 3c 	jmp	0x78f6	; 0x78f6 <systemGenerateReport+0x1632>
    634a:	b1 c2       	rjmp	.+1378   	; 0x68ae <systemGenerateReport+0x5ea>
    634c:	1b 30       	cpi	r17, 0x0B	; 11
    634e:	11 f4       	brne	.+4      	; 0x6354 <systemGenerateReport+0x90>
    6350:	0c 94 6e 3c 	jmp	0x78dc	; 0x78dc <systemGenerateReport+0x1618>
    6354:	1b 30       	cpi	r17, 0x0B	; 11
    6356:	08 f4       	brcc	.+2      	; 0x635a <systemGenerateReport+0x96>
    6358:	3c c7       	rjmp	.+3704   	; 0x71d2 <systemGenerateReport+0xf0e>
    635a:	1c 30       	cpi	r17, 0x0C	; 12
    635c:	11 f0       	breq	.+4      	; 0x6362 <systemGenerateReport+0x9e>
    635e:	0c 94 7b 3c 	jmp	0x78f6	; 0x78f6 <systemGenerateReport+0x1632>
    6362:	0c 94 76 3c 	jmp	0x78ec	; 0x78ec <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    6366:	80 91 af 01 	lds	r24, 0x01AF
    636a:	81 30       	cpi	r24, 0x01	; 1
    636c:	11 f0       	breq	.+4      	; 0x6372 <systemGenerateReport+0xae>
    636e:	0c 94 7b 3c 	jmp	0x78f6	; 0x78f6 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    6372:	10 92 af 01 	sts	0x01AF, r1
			  IsFinishPrintingTotalizer=False;
    6376:	10 92 b0 01 	sts	0x01B0, r1
    637a:	0c 94 73 3c 	jmp	0x78e6	; 0x78e6 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    637e:	10 93 2e 02 	sts	0x022E, r17
		  xNozzle=1;
    6382:	10 93 2d 02 	sts	0x022D, r17
		  RepPos=0;
    6386:	10 92 1e 02 	sts	0x021E, r1
    638a:	10 92 1d 02 	sts	0x021D, r1
    638e:	e6 ef       	ldi	r30, 0xF6	; 246
    6390:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    6392:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6394:	87 e0       	ldi	r24, 0x07	; 7
    6396:	e7 38       	cpi	r30, 0x87	; 135
    6398:	f8 07       	cpc	r31, r24
    639a:	d9 f7       	brne	.-10     	; 0x6392 <systemGenerateReport+0xce>
    639c:	fe 01       	movw	r30, r28
    639e:	eb 55       	subi	r30, 0x5B	; 91
    63a0:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    63a2:	ce 01       	movw	r24, r28
    63a4:	8b 50       	subi	r24, 0x0B	; 11
    63a6:	9f 4f       	sbci	r25, 0xFF	; 255
    63a8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    63aa:	e8 17       	cp	r30, r24
    63ac:	f9 07       	cpc	r31, r25
    63ae:	e1 f7       	brne	.-8      	; 0x63a8 <systemGenerateReport+0xe4>
    63b0:	fe 01       	movw	r30, r28
    63b2:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    63b4:	cf 01       	movw	r24, r30
    63b6:	0f 96       	adiw	r24, 0x0f	; 15
    63b8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    63ba:	e8 17       	cp	r30, r24
    63bc:	f9 07       	cpc	r31, r25
    63be:	e1 f7       	brne	.-8      	; 0x63b8 <systemGenerateReport+0xf4>
    63c0:	fe 01       	movw	r30, r28
    63c2:	ea 5b       	subi	r30, 0xBA	; 186
    63c4:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    63c6:	cf 01       	movw	r24, r30
    63c8:	0f 96       	adiw	r24, 0x0f	; 15
    63ca:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    63cc:	e8 17       	cp	r30, r24
    63ce:	f9 07       	cpc	r31, r25
    63d0:	e1 f7       	brne	.-8      	; 0x63ca <systemGenerateReport+0x106>
    63d2:	e3 e2       	ldi	r30, 0x23	; 35
    63d4:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    63d6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    63d8:	9a e0       	ldi	r25, 0x0A	; 10
    63da:	e7 33       	cpi	r30, 0x37	; 55
    63dc:	f9 07       	cpc	r31, r25
    63de:	d9 f7       	brne	.-10     	; 0x63d6 <systemGenerateReport+0x112>
    63e0:	e8 ed       	ldi	r30, 0xD8	; 216
    63e2:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    63e4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    63e6:	aa e0       	ldi	r26, 0x0A	; 10
    63e8:	ec 3e       	cpi	r30, 0xEC	; 236
    63ea:	fa 07       	cpc	r31, r26
    63ec:	d9 f7       	brne	.-10     	; 0x63e4 <systemGenerateReport+0x120>
    63ee:	e3 e3       	ldi	r30, 0x33	; 51
    63f0:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    63f2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    63f4:	be e0       	ldi	r27, 0x0E	; 14
    63f6:	e2 34       	cpi	r30, 0x42	; 66
    63f8:	fb 07       	cpc	r31, r27
    63fa:	d9 f7       	brne	.-10     	; 0x63f2 <systemGenerateReport+0x12e>
    63fc:	e8 e0       	ldi	r30, 0x08	; 8
    63fe:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    6400:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6402:	8b e0       	ldi	r24, 0x0B	; 11
    6404:	e7 31       	cpi	r30, 0x17	; 23
    6406:	f8 07       	cpc	r31, r24
    6408:	d9 f7       	brne	.-10     	; 0x6400 <systemGenerateReport+0x13c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    640a:	e1 99       	sbic	0x1c, 1	; 28
    640c:	fe cf       	rjmp	.-4      	; 0x640a <systemGenerateReport+0x146>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    640e:	8f e6       	ldi	r24, 0x6F	; 111
    6410:	91 e0       	ldi	r25, 0x01	; 1
    6412:	9f bb       	out	0x1f, r25	; 31
    6414:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6416:	e0 9a       	sbi	0x1c, 0	; 28
    6418:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    641a:	00 d0       	rcall	.+0      	; 0x641c <systemGenerateReport+0x158>
    641c:	00 d0       	rcall	.+0      	; 0x641e <systemGenerateReport+0x15a>
    641e:	00 d0       	rcall	.+0      	; 0x6420 <systemGenerateReport+0x15c>
    6420:	ed b7       	in	r30, 0x3d	; 61
    6422:	fe b7       	in	r31, 0x3e	; 62
    6424:	31 96       	adiw	r30, 0x01	; 1
    6426:	8e e6       	ldi	r24, 0x6E	; 110
    6428:	9e e0       	ldi	r25, 0x0E	; 14
    642a:	ad b7       	in	r26, 0x3d	; 61
    642c:	be b7       	in	r27, 0x3e	; 62
    642e:	12 96       	adiw	r26, 0x02	; 2
    6430:	9c 93       	st	X, r25
    6432:	8e 93       	st	-X, r24
    6434:	11 97       	sbiw	r26, 0x01	; 1
    6436:	8d e1       	ldi	r24, 0x1D	; 29
    6438:	96 e0       	ldi	r25, 0x06	; 6
    643a:	93 83       	std	Z+3, r25	; 0x03
    643c:	82 83       	std	Z+2, r24	; 0x02
    643e:	24 83       	std	Z+4, r18	; 0x04
    6440:	15 82       	std	Z+5, r1	; 0x05
    6442:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    6446:	82 e0       	ldi	r24, 0x02	; 2
    6448:	80 93 2f 02 	sts	0x022F, r24
    644c:	ed b7       	in	r30, 0x3d	; 61
    644e:	fe b7       	in	r31, 0x3e	; 62
    6450:	36 96       	adiw	r30, 0x06	; 6
    6452:	0f b6       	in	r0, 0x3f	; 63
    6454:	f8 94       	cli
    6456:	fe bf       	out	0x3e, r31	; 62
    6458:	0f be       	out	0x3f, r0	; 63
    645a:	ed bf       	out	0x3d, r30	; 61
    645c:	0c 94 7b 3c 	jmp	0x78f6	; 0x78f6 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    6460:	ce 01       	movw	r24, r28
    6462:	8b 5a       	subi	r24, 0xAB	; 171
    6464:	9f 4f       	sbci	r25, 0xFF	; 255
    6466:	63 e7       	ldi	r22, 0x73	; 115
    6468:	78 e0       	ldi	r23, 0x08	; 8
    646a:	44 e1       	ldi	r20, 0x14	; 20
    646c:	50 e0       	ldi	r21, 0x00	; 0
    646e:	27 e9       	ldi	r18, 0x97	; 151
    6470:	32 e1       	ldi	r19, 0x12	; 18
    6472:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6476:	81 e0       	ldi	r24, 0x01	; 1
    6478:	66 ef       	ldi	r22, 0xF6	; 246
    647a:	75 e0       	ldi	r23, 0x05	; 5
    647c:	41 e0       	ldi	r20, 0x01	; 1
    647e:	2d e1       	ldi	r18, 0x1D	; 29
    6480:	32 e0       	ldi	r19, 0x02	; 2
    6482:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6486:	8b e0       	ldi	r24, 0x0B	; 11
    6488:	66 ef       	ldi	r22, 0xF6	; 246
    648a:	75 e0       	ldi	r23, 0x05	; 5
    648c:	4a e2       	ldi	r20, 0x2A	; 42
    648e:	2d e1       	ldi	r18, 0x1D	; 29
    6490:	32 e0       	ldi	r19, 0x02	; 2
    6492:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6496:	83 e0       	ldi	r24, 0x03	; 3
    6498:	66 ef       	ldi	r22, 0xF6	; 246
    649a:	75 e0       	ldi	r23, 0x05	; 5
    649c:	41 e0       	ldi	r20, 0x01	; 1
    649e:	2d e1       	ldi	r18, 0x1D	; 29
    64a0:	32 e0       	ldi	r19, 0x02	; 2
    64a2:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    64a6:	8c e0       	ldi	r24, 0x0C	; 12
    64a8:	66 ef       	ldi	r22, 0xF6	; 246
    64aa:	75 e0       	ldi	r23, 0x05	; 5
    64ac:	41 e0       	ldi	r20, 0x01	; 1
    64ae:	2d e1       	ldi	r18, 0x1D	; 29
    64b0:	32 e0       	ldi	r19, 0x02	; 2
    64b2:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    64b6:	00 d0       	rcall	.+0      	; 0x64b8 <systemGenerateReport+0x1f4>
    64b8:	00 d0       	rcall	.+0      	; 0x64ba <systemGenerateReport+0x1f6>
    64ba:	00 d0       	rcall	.+0      	; 0x64bc <systemGenerateReport+0x1f8>
    64bc:	ed b7       	in	r30, 0x3d	; 61
    64be:	fe b7       	in	r31, 0x3e	; 62
    64c0:	31 96       	adiw	r30, 0x01	; 1
    64c2:	8e 01       	movw	r16, r28
    64c4:	0b 55       	subi	r16, 0x5B	; 91
    64c6:	1f 4f       	sbci	r17, 0xFF	; 255
    64c8:	ad b7       	in	r26, 0x3d	; 61
    64ca:	be b7       	in	r27, 0x3e	; 62
    64cc:	12 96       	adiw	r26, 0x02	; 2
    64ce:	1c 93       	st	X, r17
    64d0:	0e 93       	st	-X, r16
    64d2:	11 97       	sbiw	r26, 0x01	; 1
    64d4:	87 ef       	ldi	r24, 0xF7	; 247
    64d6:	95 e0       	ldi	r25, 0x05	; 5
    64d8:	93 83       	std	Z+3, r25	; 0x03
    64da:	82 83       	std	Z+2, r24	; 0x02
    64dc:	8e e6       	ldi	r24, 0x6E	; 110
    64de:	9e e0       	ldi	r25, 0x0E	; 14
    64e0:	95 83       	std	Z+5, r25	; 0x05
    64e2:	84 83       	std	Z+4, r24	; 0x04
    64e4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    64e8:	ed b7       	in	r30, 0x3d	; 61
    64ea:	fe b7       	in	r31, 0x3e	; 62
    64ec:	36 96       	adiw	r30, 0x06	; 6
    64ee:	0f b6       	in	r0, 0x3f	; 63
    64f0:	f8 94       	cli
    64f2:	fe bf       	out	0x3e, r31	; 62
    64f4:	0f be       	out	0x3f, r0	; 63
    64f6:	ed bf       	out	0x3d, r30	; 61
    64f8:	c8 01       	movw	r24, r16
    64fa:	66 ef       	ldi	r22, 0xF6	; 246
    64fc:	75 e0       	ldi	r23, 0x05	; 5
    64fe:	4d e1       	ldi	r20, 0x1D	; 29
    6500:	52 e0       	ldi	r21, 0x02	; 2
    6502:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    6506:	84 e0       	ldi	r24, 0x04	; 4
    6508:	66 ef       	ldi	r22, 0xF6	; 246
    650a:	75 e0       	ldi	r23, 0x05	; 5
    650c:	41 e0       	ldi	r20, 0x01	; 1
    650e:	2d e1       	ldi	r18, 0x1D	; 29
    6510:	32 e0       	ldi	r19, 0x02	; 2
    6512:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6516:	8b e0       	ldi	r24, 0x0B	; 11
    6518:	66 ef       	ldi	r22, 0xF6	; 246
    651a:	75 e0       	ldi	r23, 0x05	; 5
    651c:	4a e2       	ldi	r20, 0x2A	; 42
    651e:	2d e1       	ldi	r18, 0x1D	; 29
    6520:	32 e0       	ldi	r19, 0x02	; 2
    6522:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6526:	86 e0       	ldi	r24, 0x06	; 6
    6528:	66 ef       	ldi	r22, 0xF6	; 246
    652a:	75 e0       	ldi	r23, 0x05	; 5
    652c:	41 e0       	ldi	r20, 0x01	; 1
    652e:	2d e1       	ldi	r18, 0x1D	; 29
    6530:	32 e0       	ldi	r19, 0x02	; 2
    6532:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6536:	8c e0       	ldi	r24, 0x0C	; 12
    6538:	66 ef       	ldi	r22, 0xF6	; 246
    653a:	75 e0       	ldi	r23, 0x05	; 5
    653c:	41 e0       	ldi	r20, 0x01	; 1
    653e:	2d e1       	ldi	r18, 0x1D	; 29
    6540:	32 e0       	ldi	r19, 0x02	; 2
    6542:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6546:	e1 99       	sbic	0x1c, 1	; 28
    6548:	fe cf       	rjmp	.-4      	; 0x6546 <systemGenerateReport+0x282>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    654a:	80 e0       	ldi	r24, 0x00	; 0
    654c:	90 e0       	ldi	r25, 0x00	; 0
    654e:	9f bb       	out	0x1f, r25	; 31
    6550:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6552:	e0 9a       	sbi	0x1c, 0	; 28
    6554:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    6556:	00 d0       	rcall	.+0      	; 0x6558 <systemGenerateReport+0x294>
    6558:	00 d0       	rcall	.+0      	; 0x655a <systemGenerateReport+0x296>
    655a:	00 d0       	rcall	.+0      	; 0x655c <systemGenerateReport+0x298>
    655c:	ed b7       	in	r30, 0x3d	; 61
    655e:	fe b7       	in	r31, 0x3e	; 62
    6560:	31 96       	adiw	r30, 0x01	; 1
    6562:	8e 01       	movw	r16, r28
    6564:	0b 55       	subi	r16, 0x5B	; 91
    6566:	1f 4f       	sbci	r17, 0xFF	; 255
    6568:	ad b7       	in	r26, 0x3d	; 61
    656a:	be b7       	in	r27, 0x3e	; 62
    656c:	12 96       	adiw	r26, 0x02	; 2
    656e:	1c 93       	st	X, r17
    6570:	0e 93       	st	-X, r16
    6572:	11 97       	sbiw	r26, 0x01	; 1
    6574:	81 ed       	ldi	r24, 0xD1	; 209
    6576:	95 e0       	ldi	r25, 0x05	; 5
    6578:	93 83       	std	Z+3, r25	; 0x03
    657a:	82 83       	std	Z+2, r24	; 0x02
    657c:	24 83       	std	Z+4, r18	; 0x04
    657e:	15 82       	std	Z+5, r1	; 0x05
    6580:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    6584:	ed b7       	in	r30, 0x3d	; 61
    6586:	fe b7       	in	r31, 0x3e	; 62
    6588:	36 96       	adiw	r30, 0x06	; 6
    658a:	0f b6       	in	r0, 0x3f	; 63
    658c:	f8 94       	cli
    658e:	fe bf       	out	0x3e, r31	; 62
    6590:	0f be       	out	0x3f, r0	; 63
    6592:	ed bf       	out	0x3d, r30	; 61
    6594:	c8 01       	movw	r24, r16
    6596:	66 ef       	ldi	r22, 0xF6	; 246
    6598:	75 e0       	ldi	r23, 0x05	; 5
    659a:	4d e1       	ldi	r20, 0x1D	; 29
    659c:	52 e0       	ldi	r21, 0x02	; 2
    659e:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    65a2:	00 d0       	rcall	.+0      	; 0x65a4 <systemGenerateReport+0x2e0>
    65a4:	00 d0       	rcall	.+0      	; 0x65a6 <systemGenerateReport+0x2e2>
    65a6:	00 d0       	rcall	.+0      	; 0x65a8 <systemGenerateReport+0x2e4>
    65a8:	ed b7       	in	r30, 0x3d	; 61
    65aa:	fe b7       	in	r31, 0x3e	; 62
    65ac:	31 96       	adiw	r30, 0x01	; 1
    65ae:	ad b7       	in	r26, 0x3d	; 61
    65b0:	be b7       	in	r27, 0x3e	; 62
    65b2:	12 96       	adiw	r26, 0x02	; 2
    65b4:	1c 93       	st	X, r17
    65b6:	0e 93       	st	-X, r16
    65b8:	11 97       	sbiw	r26, 0x01	; 1
    65ba:	8f eb       	ldi	r24, 0xBF	; 191
    65bc:	95 e0       	ldi	r25, 0x05	; 5
    65be:	93 83       	std	Z+3, r25	; 0x03
    65c0:	82 83       	std	Z+2, r24	; 0x02
    65c2:	ce 01       	movw	r24, r28
    65c4:	8b 5a       	subi	r24, 0xAB	; 171
    65c6:	9f 4f       	sbci	r25, 0xFF	; 255
    65c8:	95 83       	std	Z+5, r25	; 0x05
    65ca:	84 83       	std	Z+4, r24	; 0x04
    65cc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    65d0:	ed b7       	in	r30, 0x3d	; 61
    65d2:	fe b7       	in	r31, 0x3e	; 62
    65d4:	36 96       	adiw	r30, 0x06	; 6
    65d6:	0f b6       	in	r0, 0x3f	; 63
    65d8:	f8 94       	cli
    65da:	fe bf       	out	0x3e, r31	; 62
    65dc:	0f be       	out	0x3f, r0	; 63
    65de:	ed bf       	out	0x3d, r30	; 61
    65e0:	c8 01       	movw	r24, r16
    65e2:	66 ef       	ldi	r22, 0xF6	; 246
    65e4:	75 e0       	ldi	r23, 0x05	; 5
    65e6:	4d e1       	ldi	r20, 0x1D	; 29
    65e8:	52 e0       	ldi	r21, 0x02	; 2
    65ea:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    65ee:	00 d0       	rcall	.+0      	; 0x65f0 <systemGenerateReport+0x32c>
    65f0:	00 d0       	rcall	.+0      	; 0x65f2 <systemGenerateReport+0x32e>
    65f2:	00 d0       	rcall	.+0      	; 0x65f4 <systemGenerateReport+0x330>
    65f4:	ed b7       	in	r30, 0x3d	; 61
    65f6:	fe b7       	in	r31, 0x3e	; 62
    65f8:	31 96       	adiw	r30, 0x01	; 1
    65fa:	ad b7       	in	r26, 0x3d	; 61
    65fc:	be b7       	in	r27, 0x3e	; 62
    65fe:	12 96       	adiw	r26, 0x02	; 2
    6600:	1c 93       	st	X, r17
    6602:	0e 93       	st	-X, r16
    6604:	11 97       	sbiw	r26, 0x01	; 1
    6606:	8d ea       	ldi	r24, 0xAD	; 173
    6608:	95 e0       	ldi	r25, 0x05	; 5
    660a:	93 83       	std	Z+3, r25	; 0x03
    660c:	82 83       	std	Z+2, r24	; 0x02
    660e:	88 e9       	ldi	r24, 0x98	; 152
    6610:	99 e0       	ldi	r25, 0x09	; 9
    6612:	95 83       	std	Z+5, r25	; 0x05
    6614:	84 83       	std	Z+4, r24	; 0x04
    6616:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    661a:	ed b7       	in	r30, 0x3d	; 61
    661c:	fe b7       	in	r31, 0x3e	; 62
    661e:	36 96       	adiw	r30, 0x06	; 6
    6620:	0f b6       	in	r0, 0x3f	; 63
    6622:	f8 94       	cli
    6624:	fe bf       	out	0x3e, r31	; 62
    6626:	0f be       	out	0x3f, r0	; 63
    6628:	ed bf       	out	0x3d, r30	; 61
    662a:	c8 01       	movw	r24, r16
    662c:	66 ef       	ldi	r22, 0xF6	; 246
    662e:	75 e0       	ldi	r23, 0x05	; 5
    6630:	4d e1       	ldi	r20, 0x1D	; 29
    6632:	52 e0       	ldi	r21, 0x02	; 2
    6634:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6638:	87 e0       	ldi	r24, 0x07	; 7
    663a:	66 ef       	ldi	r22, 0xF6	; 246
    663c:	75 e0       	ldi	r23, 0x05	; 5
    663e:	41 e0       	ldi	r20, 0x01	; 1
    6640:	2d e1       	ldi	r18, 0x1D	; 29
    6642:	32 e0       	ldi	r19, 0x02	; 2
    6644:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6648:	8b e0       	ldi	r24, 0x0B	; 11
    664a:	66 ef       	ldi	r22, 0xF6	; 246
    664c:	75 e0       	ldi	r23, 0x05	; 5
    664e:	4a e2       	ldi	r20, 0x2A	; 42
    6650:	2d e1       	ldi	r18, 0x1D	; 29
    6652:	32 e0       	ldi	r19, 0x02	; 2
    6654:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6658:	89 e0       	ldi	r24, 0x09	; 9
    665a:	66 ef       	ldi	r22, 0xF6	; 246
    665c:	75 e0       	ldi	r23, 0x05	; 5
    665e:	41 e0       	ldi	r20, 0x01	; 1
    6660:	2d e1       	ldi	r18, 0x1D	; 29
    6662:	32 e0       	ldi	r19, 0x02	; 2
    6664:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6668:	8c e0       	ldi	r24, 0x0C	; 12
    666a:	66 ef       	ldi	r22, 0xF6	; 246
    666c:	75 e0       	ldi	r23, 0x05	; 5
    666e:	41 e0       	ldi	r20, 0x01	; 1
    6670:	2d e1       	ldi	r18, 0x1D	; 29
    6672:	32 e0       	ldi	r19, 0x02	; 2
    6674:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    6678:	8f e1       	ldi	r24, 0x1F	; 31
    667a:	92 e0       	ldi	r25, 0x02	; 2
    667c:	0e 94 2e 20 	call	0x405c	; 0x405c <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    6680:	80 e8       	ldi	r24, 0x80	; 128
    6682:	80 93 e1 01 	sts	0x01E1, r24
		  LengthMessage81=RepPos+1;
    6686:	80 91 1d 02 	lds	r24, 0x021D
    668a:	90 91 1e 02 	lds	r25, 0x021E
    668e:	01 96       	adiw	r24, 0x01	; 1
    6690:	90 93 b6 01 	sts	0x01B6, r25
    6694:	80 93 b5 01 	sts	0x01B5, r24
		  IsFreePrinting=True;
    6698:	81 e0       	ldi	r24, 0x01	; 1
    669a:	80 93 d5 01 	sts	0x01D5, r24
          IsBusyFreePrinting=True;
    669e:	80 93 df 01 	sts	0x01DF, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    66a2:	83 e0       	ldi	r24, 0x03	; 3
    66a4:	0c 94 73 3c 	jmp	0x78e6	; 0x78e6 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    66a8:	88 23       	and	r24, r24
    66aa:	11 f0       	breq	.+4      	; 0x66b0 <systemGenerateReport+0x3ec>
    66ac:	0c 94 7b 3c 	jmp	0x78f6	; 0x78f6 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    66b0:	84 e0       	ldi	r24, 0x04	; 4
    66b2:	0c 94 73 3c 	jmp	0x78e6	; 0x78e6 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    66b6:	10 92 1e 02 	sts	0x021E, r1
    66ba:	10 92 1d 02 	sts	0x021D, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    66be:	81 e0       	ldi	r24, 0x01	; 1
    66c0:	66 ef       	ldi	r22, 0xF6	; 246
    66c2:	75 e0       	ldi	r23, 0x05	; 5
    66c4:	41 e0       	ldi	r20, 0x01	; 1
    66c6:	2d e1       	ldi	r18, 0x1D	; 29
    66c8:	32 e0       	ldi	r19, 0x02	; 2
    66ca:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    66ce:	8b e0       	ldi	r24, 0x0B	; 11
    66d0:	66 ef       	ldi	r22, 0xF6	; 246
    66d2:	75 e0       	ldi	r23, 0x05	; 5
    66d4:	4a e2       	ldi	r20, 0x2A	; 42
    66d6:	2d e1       	ldi	r18, 0x1D	; 29
    66d8:	32 e0       	ldi	r19, 0x02	; 2
    66da:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    66de:	83 e0       	ldi	r24, 0x03	; 3
    66e0:	66 ef       	ldi	r22, 0xF6	; 246
    66e2:	75 e0       	ldi	r23, 0x05	; 5
    66e4:	41 e0       	ldi	r20, 0x01	; 1
    66e6:	2d e1       	ldi	r18, 0x1D	; 29
    66e8:	32 e0       	ldi	r19, 0x02	; 2
    66ea:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    66ee:	8c e0       	ldi	r24, 0x0C	; 12
    66f0:	66 ef       	ldi	r22, 0xF6	; 246
    66f2:	75 e0       	ldi	r23, 0x05	; 5
    66f4:	41 e0       	ldi	r20, 0x01	; 1
    66f6:	2d e1       	ldi	r18, 0x1D	; 29
    66f8:	32 e0       	ldi	r19, 0x02	; 2
    66fa:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    66fe:	e1 99       	sbic	0x1c, 1	; 28
    6700:	fe cf       	rjmp	.-4      	; 0x66fe <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6702:	81 ef       	ldi	r24, 0xF1	; 241
    6704:	93 e0       	ldi	r25, 0x03	; 3
    6706:	9f bb       	out	0x1f, r25	; 31
    6708:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    670a:	e0 9a       	sbi	0x1c, 0	; 28
    670c:	8d b3       	in	r24, 0x1d	; 29
    670e:	9e 01       	movw	r18, r28
    6710:	2b 55       	subi	r18, 0x5B	; 91
    6712:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    6714:	81 30       	cpi	r24, 0x01	; 1
    6716:	79 f4       	brne	.+30     	; 0x6736 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    6718:	00 d0       	rcall	.+0      	; 0x671a <systemGenerateReport+0x456>
    671a:	00 d0       	rcall	.+0      	; 0x671c <systemGenerateReport+0x458>
    671c:	ad b7       	in	r26, 0x3d	; 61
    671e:	be b7       	in	r27, 0x3e	; 62
    6720:	12 96       	adiw	r26, 0x02	; 2
    6722:	3c 93       	st	X, r19
    6724:	2e 93       	st	-X, r18
    6726:	11 97       	sbiw	r26, 0x01	; 1
    6728:	86 e8       	ldi	r24, 0x86	; 134
    672a:	95 e0       	ldi	r25, 0x05	; 5
    672c:	14 96       	adiw	r26, 0x04	; 4
    672e:	9c 93       	st	X, r25
    6730:	8e 93       	st	-X, r24
    6732:	13 97       	sbiw	r26, 0x03	; 3
    6734:	0a c0       	rjmp	.+20     	; 0x674a <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    6736:	00 d0       	rcall	.+0      	; 0x6738 <systemGenerateReport+0x474>
    6738:	00 d0       	rcall	.+0      	; 0x673a <systemGenerateReport+0x476>
    673a:	ed b7       	in	r30, 0x3d	; 61
    673c:	fe b7       	in	r31, 0x3e	; 62
    673e:	32 83       	std	Z+2, r19	; 0x02
    6740:	21 83       	std	Z+1, r18	; 0x01
    6742:	8f e5       	ldi	r24, 0x5F	; 95
    6744:	95 e0       	ldi	r25, 0x05	; 5
    6746:	94 83       	std	Z+4, r25	; 0x04
    6748:	83 83       	std	Z+3, r24	; 0x03
    674a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    674e:	0f 90       	pop	r0
    6750:	0f 90       	pop	r0
    6752:	0f 90       	pop	r0
    6754:	0f 90       	pop	r0
    6756:	ce 01       	movw	r24, r28
    6758:	8b 55       	subi	r24, 0x5B	; 91
    675a:	9f 4f       	sbci	r25, 0xFF	; 255
    675c:	66 ef       	ldi	r22, 0xF6	; 246
    675e:	75 e0       	ldi	r23, 0x05	; 5
    6760:	4d e1       	ldi	r20, 0x1D	; 29
    6762:	52 e0       	ldi	r21, 0x02	; 2
    6764:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    6768:	87 e0       	ldi	r24, 0x07	; 7
    676a:	66 ef       	ldi	r22, 0xF6	; 246
    676c:	75 e0       	ldi	r23, 0x05	; 5
    676e:	41 e0       	ldi	r20, 0x01	; 1
    6770:	2d e1       	ldi	r18, 0x1D	; 29
    6772:	32 e0       	ldi	r19, 0x02	; 2
    6774:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6778:	8b e0       	ldi	r24, 0x0B	; 11
    677a:	66 ef       	ldi	r22, 0xF6	; 246
    677c:	75 e0       	ldi	r23, 0x05	; 5
    677e:	4a e2       	ldi	r20, 0x2A	; 42
    6780:	2d e1       	ldi	r18, 0x1D	; 29
    6782:	32 e0       	ldi	r19, 0x02	; 2
    6784:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6788:	89 e0       	ldi	r24, 0x09	; 9
    678a:	66 ef       	ldi	r22, 0xF6	; 246
    678c:	75 e0       	ldi	r23, 0x05	; 5
    678e:	41 e0       	ldi	r20, 0x01	; 1
    6790:	2d e1       	ldi	r18, 0x1D	; 29
    6792:	32 e0       	ldi	r19, 0x02	; 2
    6794:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
          
		  cmdPrint=0b00000000;
    6798:	10 92 e1 01 	sts	0x01E1, r1
		  LengthMessage81=RepPos+1;
    679c:	80 91 1d 02 	lds	r24, 0x021D
    67a0:	90 91 1e 02 	lds	r25, 0x021E
    67a4:	01 96       	adiw	r24, 0x01	; 1
    67a6:	90 93 b6 01 	sts	0x01B6, r25
    67aa:	80 93 b5 01 	sts	0x01B5, r24

		  IsFreePrinting=True;
    67ae:	81 e0       	ldi	r24, 0x01	; 1
    67b0:	80 93 d5 01 	sts	0x01D5, r24
	      IsBusyFreePrinting=True;
    67b4:	80 93 df 01 	sts	0x01DF, r24

		  stGenerateReport=grWaitLabelPrinted;
    67b8:	85 e0       	ldi	r24, 0x05	; 5
    67ba:	0c 94 73 3c 	jmp	0x78e6	; 0x78e6 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    67be:	80 91 2e 02 	lds	r24, 0x022E
    67c2:	81 50       	subi	r24, 0x01	; 1
    67c4:	88 30       	cpi	r24, 0x08	; 8
    67c6:	10 f0       	brcs	.+4      	; 0x67cc <systemGenerateReport+0x508>
    67c8:	0c 94 7b 3c 	jmp	0x78f6	; 0x78f6 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    67cc:	ce 01       	movw	r24, r28
    67ce:	07 96       	adiw	r24, 0x07	; 7
    67d0:	65 e4       	ldi	r22, 0x45	; 69
    67d2:	70 e0       	ldi	r23, 0x00	; 0
    67d4:	48 e0       	ldi	r20, 0x08	; 8
    67d6:	50 e0       	ldi	r21, 0x00	; 0
    67d8:	27 e9       	ldi	r18, 0x97	; 151
    67da:	32 e1       	ldi	r19, 0x12	; 18
    67dc:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    67e0:	90 91 2e 02 	lds	r25, 0x022E
    67e4:	fe 01       	movw	r30, r28
    67e6:	e9 0f       	add	r30, r25
    67e8:	f1 1d       	adc	r31, r1
    67ea:	86 81       	ldd	r24, Z+6	; 0x06
    67ec:	80 93 2b 02 	sts	0x022B, r24
			  if (PumpNum>0){
    67f0:	88 23       	and	r24, r24
    67f2:	09 f4       	brne	.+2      	; 0x67f6 <systemGenerateReport+0x532>
    67f4:	4b c0       	rjmp	.+150    	; 0x688c <systemGenerateReport+0x5c8>
    67f6:	91 9f       	mul	r25, r17
    67f8:	b0 01       	movw	r22, r0
    67fa:	11 24       	eor	r1, r1
    67fc:	61 5b       	subi	r22, 0xB1	; 177
    67fe:	7f 4f       	sbci	r23, 0xFF	; 255
    6800:	ce 01       	movw	r24, r28
    6802:	01 96       	adiw	r24, 0x01	; 1
    6804:	46 e0       	ldi	r20, 0x06	; 6
    6806:	50 e0       	ldi	r21, 0x00	; 0
    6808:	27 e9       	ldi	r18, 0x97	; 151
    680a:	32 e1       	ldi	r19, 0x12	; 18
    680c:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    6810:	80 91 2d 02 	lds	r24, 0x022D
    6814:	fe 01       	movw	r30, r28
    6816:	e8 0f       	add	r30, r24
    6818:	f1 1d       	adc	r31, r1
    681a:	80 81       	ld	r24, Z
    681c:	80 93 2c 02 	sts	0x022C, r24
    6820:	68 e6       	ldi	r22, 0x68	; 104
    6822:	c6 2e       	mov	r12, r22
    6824:	69 e0       	ldi	r22, 0x09	; 9
    6826:	d6 2e       	mov	r13, r22

				  if (xGrade>0){
    6828:	88 23       	and	r24, r24
    682a:	99 f0       	breq	.+38     	; 0x6852 <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    682c:	b6 01       	movw	r22, r12
    682e:	0e 94 9b 2a 	call	0x5536	; 0x5536 <GetProductName>
                      GradeUsed=xGrade;
    6832:	80 91 2c 02 	lds	r24, 0x022C
    6836:	80 93 29 02 	sts	0x0229, r24
					  xGrade=xNozzle;//
    683a:	80 91 2d 02 	lds	r24, 0x022D
    683e:	80 93 2c 02 	sts	0x022C, r24
					  PumpNozzle=xNozzle;
    6842:	80 93 2a 02 	sts	0x022A, r24
					  xNozzle++;
    6846:	8f 5f       	subi	r24, 0xFF	; 255
    6848:	80 93 2d 02 	sts	0x022D, r24
					  stGenerateReport=grCreateReportTotalizer;
    684c:	88 e0       	ldi	r24, 0x08	; 8
    684e:	0c 94 73 3c 	jmp	0x78e6	; 0x78e6 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    6852:	00 d0       	rcall	.+0      	; 0x6854 <systemGenerateReport+0x590>
    6854:	00 d0       	rcall	.+0      	; 0x6856 <systemGenerateReport+0x592>
    6856:	ad b7       	in	r26, 0x3d	; 61
    6858:	be b7       	in	r27, 0x3e	; 62
    685a:	12 96       	adiw	r26, 0x02	; 2
    685c:	dc 92       	st	X, r13
    685e:	ce 92       	st	-X, r12
    6860:	11 97       	sbiw	r26, 0x01	; 1
    6862:	8b e5       	ldi	r24, 0x5B	; 91
    6864:	95 e0       	ldi	r25, 0x05	; 5
    6866:	14 96       	adiw	r26, 0x04	; 4
    6868:	9c 93       	st	X, r25
    686a:	8e 93       	st	-X, r24
    686c:	13 97       	sbiw	r26, 0x03	; 3
    686e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
					   xNozzle++;
    6872:	80 91 2d 02 	lds	r24, 0x022D
    6876:	8f 5f       	subi	r24, 0xFF	; 255
    6878:	80 93 2d 02 	sts	0x022D, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    687c:	0f 90       	pop	r0
    687e:	0f 90       	pop	r0
    6880:	0f 90       	pop	r0
    6882:	0f 90       	pop	r0
    6884:	87 30       	cpi	r24, 0x07	; 7
    6886:	10 f4       	brcc	.+4      	; 0x688c <systemGenerateReport+0x5c8>
    6888:	0c 94 7b 3c 	jmp	0x78f6	; 0x78f6 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    688c:	87 e0       	ldi	r24, 0x07	; 7
    688e:	0c 94 73 3c 	jmp	0x78e6	; 0x78e6 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    6892:	81 e0       	ldi	r24, 0x01	; 1
    6894:	80 93 2d 02 	sts	0x022D, r24
	      xPump++;
    6898:	80 91 2e 02 	lds	r24, 0x022E
    689c:	8f 5f       	subi	r24, 0xFF	; 255
    689e:	80 93 2e 02 	sts	0x022E, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    68a2:	89 30       	cpi	r24, 0x09	; 9
    68a4:	08 f4       	brcc	.+2      	; 0x68a8 <systemGenerateReport+0x5e4>
    68a6:	93 c4       	rjmp	.+2342   	; 0x71ce <systemGenerateReport+0xf0a>
    68a8:	8a e0       	ldi	r24, 0x0A	; 10
    68aa:	0c 94 73 3c 	jmp	0x78e6	; 0x78e6 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    68ae:	10 92 1e 02 	sts	0x021E, r1
    68b2:	10 92 1d 02 	sts	0x021D, r1
    68b6:	e6 ef       	ldi	r30, 0xF6	; 246
    68b8:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    68ba:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    68bc:	b7 e0       	ldi	r27, 0x07	; 7
    68be:	e7 38       	cpi	r30, 0x87	; 135
    68c0:	fb 07       	cpc	r31, r27
    68c2:	d9 f7       	brne	.-10     	; 0x68ba <systemGenerateReport+0x5f6>
    68c4:	fe 01       	movw	r30, r28
    68c6:	eb 55       	subi	r30, 0x5B	; 91
    68c8:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    68ca:	ce 01       	movw	r24, r28
    68cc:	8b 50       	subi	r24, 0x0B	; 11
    68ce:	9f 4f       	sbci	r25, 0xFF	; 255
    68d0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    68d2:	e8 17       	cp	r30, r24
    68d4:	f9 07       	cpc	r31, r25
    68d6:	e1 f7       	brne	.-8      	; 0x68d0 <systemGenerateReport+0x60c>
    68d8:	e3 e3       	ldi	r30, 0x33	; 51
    68da:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    68dc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    68de:	8e e0       	ldi	r24, 0x0E	; 14
    68e0:	e2 34       	cpi	r30, 0x42	; 66
    68e2:	f8 07       	cpc	r31, r24
    68e4:	d9 f7       	brne	.-10     	; 0x68dc <systemGenerateReport+0x618>
    68e6:	e8 e0       	ldi	r30, 0x08	; 8
    68e8:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    68ea:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    68ec:	9b e0       	ldi	r25, 0x0B	; 11
    68ee:	e7 31       	cpi	r30, 0x17	; 23
    68f0:	f9 07       	cpc	r31, r25
    68f2:	d9 f7       	brne	.-10     	; 0x68ea <systemGenerateReport+0x626>
    68f4:	fe 01       	movw	r30, r28
    68f6:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    68f8:	ce 01       	movw	r24, r28
    68fa:	88 96       	adiw	r24, 0x28	; 40
    68fc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    68fe:	e8 17       	cp	r30, r24
    6900:	f9 07       	cpc	r31, r25
    6902:	e1 f7       	brne	.-8      	; 0x68fc <systemGenerateReport+0x638>
	     strMemory[i]=data;
    6904:	ce 01       	movw	r24, r28
    6906:	c7 96       	adiw	r24, 0x37	; 55
    6908:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    690a:	e8 17       	cp	r30, r24
    690c:	f9 07       	cpc	r31, r25
    690e:	e1 f7       	brne	.-8      	; 0x6908 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    6910:	cf 01       	movw	r24, r30
    6912:	0f 96       	adiw	r24, 0x0f	; 15
    6914:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6916:	e8 17       	cp	r30, r24
    6918:	f9 07       	cpc	r31, r25
    691a:	e1 f7       	brne	.-8      	; 0x6914 <systemGenerateReport+0x650>
    691c:	fe 01       	movw	r30, r28
    691e:	ea 5b       	subi	r30, 0xBA	; 186
    6920:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6922:	cf 01       	movw	r24, r30
    6924:	ee 2e       	mov	r14, r30
    6926:	d9 2e       	mov	r13, r25
    6928:	0f 96       	adiw	r24, 0x0f	; 15
    692a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    692c:	e8 17       	cp	r30, r24
    692e:	f9 07       	cpc	r31, r25
    6930:	e1 f7       	brne	.-8      	; 0x692a <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    6932:	80 91 2b 02 	lds	r24, 0x022B
    6936:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
		  if (FIPAddr>0){
    693a:	88 23       	and	r24, r24
    693c:	49 f1       	breq	.+82     	; 0x6990 <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    693e:	f8 2e       	mov	r15, r24
    6940:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    6942:	80 e0       	ldi	r24, 0x00	; 0
    6944:	60 e0       	ldi	r22, 0x00	; 0
    6946:	4f 2d       	mov	r20, r15
    6948:	20 91 2a 02 	lds	r18, 0x022A
    694c:	8e 01       	movw	r16, r28
    694e:	07 5e       	subi	r16, 0xE7	; 231
    6950:	1f 4f       	sbci	r17, 0xFF	; 255
    6952:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    6956:	81 e0       	ldi	r24, 0x01	; 1
    6958:	60 e0       	ldi	r22, 0x00	; 0
    695a:	4f 2d       	mov	r20, r15
    695c:	20 91 2a 02 	lds	r18, 0x022A
    6960:	8e 01       	movw	r16, r28
    6962:	08 5d       	subi	r16, 0xD8	; 216
    6964:	1f 4f       	sbci	r17, 0xFF	; 255
    6966:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    696a:	80 e0       	ldi	r24, 0x00	; 0
    696c:	61 e0       	ldi	r22, 0x01	; 1
    696e:	4f 2d       	mov	r20, r15
    6970:	20 91 2a 02 	lds	r18, 0x022A
    6974:	8e 01       	movw	r16, r28
    6976:	09 5c       	subi	r16, 0xC9	; 201
    6978:	1f 4f       	sbci	r17, 0xFF	; 255
    697a:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    697e:	81 e0       	ldi	r24, 0x01	; 1
    6980:	61 e0       	ldi	r22, 0x01	; 1
    6982:	4f 2d       	mov	r20, r15
    6984:	20 91 2a 02 	lds	r18, 0x022A
    6988:	0e 2d       	mov	r16, r14
    698a:	1d 2d       	mov	r17, r13
    698c:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    6990:	80 e0       	ldi	r24, 0x00	; 0
    6992:	be 01       	movw	r22, r28
    6994:	69 5c       	subi	r22, 0xC9	; 201
    6996:	7f 4f       	sbci	r23, 0xFF	; 255
    6998:	ae 01       	movw	r20, r28
    699a:	47 5e       	subi	r20, 0xE7	; 231
    699c:	5f 4f       	sbci	r21, 0xFF	; 255
    699e:	28 e0       	ldi	r18, 0x08	; 8
    69a0:	3b e0       	ldi	r19, 0x0B	; 11
    69a2:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    69a6:	88 e0       	ldi	r24, 0x08	; 8
    69a8:	9b e0       	ldi	r25, 0x0B	; 11
    69aa:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <IsMinus>
    69ae:	81 30       	cpi	r24, 0x01	; 1
    69b0:	21 f4       	brne	.+8      	; 0x69ba <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    69b2:	88 e0       	ldi	r24, 0x08	; 8
    69b4:	9b e0       	ldi	r25, 0x0B	; 11
    69b6:	0e 94 ca 29 	call	0x5394	; 0x5394 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    69ba:	e1 99       	sbic	0x1c, 1	; 28
    69bc:	fe cf       	rjmp	.-4      	; 0x69ba <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    69be:	57 e6       	ldi	r21, 0x67	; 103
    69c0:	85 2e       	mov	r8, r21
    69c2:	51 e0       	ldi	r21, 0x01	; 1
    69c4:	95 2e       	mov	r9, r21
    69c6:	9f ba       	out	0x1f, r9	; 31
    69c8:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    69ca:	e0 9a       	sbi	0x1c, 0	; 28
    69cc:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    69ce:	82 30       	cpi	r24, 0x02	; 2
    69d0:	79 f4       	brne	.+30     	; 0x69f0 <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    69d2:	8e 01       	movw	r16, r28
    69d4:	01 5f       	subi	r16, 0xF1	; 241
    69d6:	1f 4f       	sbci	r17, 0xFF	; 255
    69d8:	c8 01       	movw	r24, r16
    69da:	60 91 2b 02 	lds	r22, 0x022B
    69de:	40 91 2a 02 	lds	r20, 0x022A
    69e2:	0e 94 d5 21 	call	0x43aa	; 0x43aa <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    69e6:	82 e0       	ldi	r24, 0x02	; 2
    69e8:	b8 01       	movw	r22, r16
    69ea:	48 e0       	ldi	r20, 0x08	; 8
    69ec:	5b e0       	ldi	r21, 0x0B	; 11
    69ee:	07 c0       	rjmp	.+14     	; 0x69fe <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    69f0:	80 e0       	ldi	r24, 0x00	; 0
    69f2:	be 01       	movw	r22, r28
    69f4:	6a 5b       	subi	r22, 0xBA	; 186
    69f6:	7f 4f       	sbci	r23, 0xFF	; 255
    69f8:	ae 01       	movw	r20, r28
    69fa:	48 5d       	subi	r20, 0xD8	; 216
    69fc:	5f 4f       	sbci	r21, 0xFF	; 255
    69fe:	23 e3       	ldi	r18, 0x33	; 51
    6a00:	3e e0       	ldi	r19, 0x0E	; 14
    6a02:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    6a06:	83 e3       	ldi	r24, 0x33	; 51
    6a08:	9e e0       	ldi	r25, 0x0E	; 14
    6a0a:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <IsMinus>
    6a0e:	81 30       	cpi	r24, 0x01	; 1
    6a10:	21 f4       	brne	.+8      	; 0x6a1a <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    6a12:	83 e3       	ldi	r24, 0x33	; 51
    6a14:	9e e0       	ldi	r25, 0x0E	; 14
    6a16:	0e 94 ca 29 	call	0x5394	; 0x5394 <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    6a1a:	80 91 29 02 	lds	r24, 0x0229
    6a1e:	6f e1       	ldi	r22, 0x1F	; 31
    6a20:	72 e0       	ldi	r23, 0x02	; 2
    6a22:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    6a26:	81 e0       	ldi	r24, 0x01	; 1
    6a28:	63 e2       	ldi	r22, 0x23	; 35
    6a2a:	7a e0       	ldi	r23, 0x0A	; 10
    6a2c:	48 e0       	ldi	r20, 0x08	; 8
    6a2e:	5b e0       	ldi	r21, 0x0B	; 11
    6a30:	9b 01       	movw	r18, r22
    6a32:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    6a36:	81 e0       	ldi	r24, 0x01	; 1
    6a38:	68 ed       	ldi	r22, 0xD8	; 216
    6a3a:	7a e0       	ldi	r23, 0x0A	; 10
    6a3c:	43 e3       	ldi	r20, 0x33	; 51
    6a3e:	5e e0       	ldi	r21, 0x0E	; 14
    6a40:	9b 01       	movw	r18, r22
    6a42:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>


		  RemZeroLead(strDeltaMoney);
    6a46:	83 e3       	ldi	r24, 0x33	; 51
    6a48:	9e e0       	ldi	r25, 0x0E	; 14
    6a4a:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    6a4e:	46 e4       	ldi	r20, 0x46	; 70
    6a50:	c4 2e       	mov	r12, r20
    6a52:	d1 2c       	mov	r13, r1
    6a54:	cc 0e       	add	r12, r28
    6a56:	dd 1e       	adc	r13, r29
    6a58:	c6 01       	movw	r24, r12
    6a5a:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		  RemZeroLead(strLastMoney);
    6a5e:	38 e2       	ldi	r19, 0x28	; 40
    6a60:	e3 2e       	mov	r14, r19
    6a62:	f1 2c       	mov	r15, r1
    6a64:	ec 0e       	add	r14, r28
    6a66:	fd 1e       	adc	r15, r29
    6a68:	c7 01       	movw	r24, r14
    6a6a:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    6a6e:	88 e0       	ldi	r24, 0x08	; 8
    6a70:	9b e0       	ldi	r25, 0x0B	; 11
    6a72:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    6a76:	27 e3       	ldi	r18, 0x37	; 55
    6a78:	a2 2e       	mov	r10, r18
    6a7a:	b1 2c       	mov	r11, r1
    6a7c:	ac 0e       	add	r10, r28
    6a7e:	bd 1e       	adc	r11, r29
    6a80:	c5 01       	movw	r24, r10
    6a82:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
          RemZeroLead(strLastVolume);
    6a86:	8e 01       	movw	r16, r28
    6a88:	07 5e       	subi	r16, 0xE7	; 231
    6a8a:	1f 4f       	sbci	r17, 0xFF	; 255
    6a8c:	c8 01       	movw	r24, r16
    6a8e:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    6a92:	83 e3       	ldi	r24, 0x33	; 51
    6a94:	9e e0       	ldi	r25, 0x0E	; 14
    6a96:	0e 94 2e 31 	call	0x625c	; 0x625c <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    6a9a:	c6 01       	movw	r24, r12
    6a9c:	0e 94 2e 31 	call	0x625c	; 0x625c <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    6aa0:	c7 01       	movw	r24, r14
    6aa2:	0e 94 2e 31 	call	0x625c	; 0x625c <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    6aa6:	88 e0       	ldi	r24, 0x08	; 8
    6aa8:	9b e0       	ldi	r25, 0x0B	; 11
    6aaa:	0e 94 21 31 	call	0x6242	; 0x6242 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    6aae:	c8 01       	movw	r24, r16
    6ab0:	0e 94 21 31 	call	0x6242	; 0x6242 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    6ab4:	c5 01       	movw	r24, r10
    6ab6:	0e 94 21 31 	call	0x6242	; 0x6242 <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    6aba:	83 e3       	ldi	r24, 0x33	; 51
    6abc:	9e e0       	ldi	r25, 0x0E	; 14
    6abe:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    6ac2:	c6 01       	movw	r24, r12
    6ac4:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
		  FormatCurrency(strLastMoney);
    6ac8:	c7 01       	movw	r24, r14
    6aca:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    6ace:	88 e0       	ldi	r24, 0x08	; 8
    6ad0:	9b e0       	ldi	r25, 0x0B	; 11
    6ad2:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
		  FormatCurrency(strLastVolume);
    6ad6:	c8 01       	movw	r24, r16
    6ad8:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    6adc:	c5 01       	movw	r24, r10
    6ade:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6ae2:	81 e0       	ldi	r24, 0x01	; 1
    6ae4:	66 ef       	ldi	r22, 0xF6	; 246
    6ae6:	75 e0       	ldi	r23, 0x05	; 5
    6ae8:	41 e0       	ldi	r20, 0x01	; 1
    6aea:	2d e1       	ldi	r18, 0x1D	; 29
    6aec:	32 e0       	ldi	r19, 0x02	; 2
    6aee:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6af2:	8b e0       	ldi	r24, 0x0B	; 11
    6af4:	66 ef       	ldi	r22, 0xF6	; 246
    6af6:	75 e0       	ldi	r23, 0x05	; 5
    6af8:	4a e2       	ldi	r20, 0x2A	; 42
    6afa:	2d e1       	ldi	r18, 0x1D	; 29
    6afc:	32 e0       	ldi	r19, 0x02	; 2
    6afe:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6b02:	83 e0       	ldi	r24, 0x03	; 3
    6b04:	66 ef       	ldi	r22, 0xF6	; 246
    6b06:	75 e0       	ldi	r23, 0x05	; 5
    6b08:	41 e0       	ldi	r20, 0x01	; 1
    6b0a:	2d e1       	ldi	r18, 0x1D	; 29
    6b0c:	32 e0       	ldi	r19, 0x02	; 2
    6b0e:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6b12:	8c e0       	ldi	r24, 0x0C	; 12
    6b14:	66 ef       	ldi	r22, 0xF6	; 246
    6b16:	75 e0       	ldi	r23, 0x05	; 5
    6b18:	41 e0       	ldi	r20, 0x01	; 1
    6b1a:	2d e1       	ldi	r18, 0x1D	; 29
    6b1c:	32 e0       	ldi	r19, 0x02	; 2
    6b1e:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6b22:	e1 99       	sbic	0x1c, 1	; 28
    6b24:	fe cf       	rjmp	.-4      	; 0x6b22 <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6b26:	9f ba       	out	0x1f, r9	; 31
    6b28:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6b2a:	e0 9a       	sbi	0x1c, 0	; 28
    6b2c:	8d b3       	in	r24, 0x1d	; 29
    6b2e:	98 e6       	ldi	r25, 0x68	; 104
    6b30:	c9 2e       	mov	r12, r25
    6b32:	99 e0       	ldi	r25, 0x09	; 9
    6b34:	d9 2e       	mov	r13, r25
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6b36:	82 30       	cpi	r24, 0x02	; 2
    6b38:	09 f0       	breq	.+2      	; 0x6b3c <systemGenerateReport+0x878>
    6b3a:	84 c0       	rjmp	.+264    	; 0x6c44 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    6b3c:	0f e0       	ldi	r16, 0x0F	; 15
    6b3e:	e0 2e       	mov	r14, r16
    6b40:	f1 2c       	mov	r15, r1
    6b42:	ec 0e       	add	r14, r28
    6b44:	fd 1e       	adc	r15, r29
    6b46:	c7 01       	movw	r24, r14
    6b48:	60 91 2b 02 	lds	r22, 0x022B
    6b4c:	40 91 2a 02 	lds	r20, 0x022A
    6b50:	0e 94 d5 21 	call	0x43aa	; 0x43aa <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    6b54:	00 d0       	rcall	.+0      	; 0x6b56 <systemGenerateReport+0x892>
    6b56:	00 d0       	rcall	.+0      	; 0x6b58 <systemGenerateReport+0x894>
    6b58:	00 d0       	rcall	.+0      	; 0x6b5a <systemGenerateReport+0x896>
    6b5a:	ed b7       	in	r30, 0x3d	; 61
    6b5c:	fe b7       	in	r31, 0x3e	; 62
    6b5e:	31 96       	adiw	r30, 0x01	; 1
    6b60:	8e 01       	movw	r16, r28
    6b62:	0f 56       	subi	r16, 0x6F	; 111
    6b64:	1f 4f       	sbci	r17, 0xFF	; 255
    6b66:	ad b7       	in	r26, 0x3d	; 61
    6b68:	be b7       	in	r27, 0x3e	; 62
    6b6a:	12 96       	adiw	r26, 0x02	; 2
    6b6c:	1c 93       	st	X, r17
    6b6e:	0e 93       	st	-X, r16
    6b70:	11 97       	sbiw	r26, 0x01	; 1
    6b72:	8e e4       	ldi	r24, 0x4E	; 78
    6b74:	95 e0       	ldi	r25, 0x05	; 5
    6b76:	93 83       	std	Z+3, r25	; 0x03
    6b78:	82 83       	std	Z+2, r24	; 0x02
    6b7a:	f5 82       	std	Z+5, r15	; 0x05
    6b7c:	e4 82       	std	Z+4, r14	; 0x04
    6b7e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    6b82:	d6 01       	movw	r26, r12
    6b84:	0d 90       	ld	r0, X+
    6b86:	00 20       	and	r0, r0
    6b88:	e9 f7       	brne	.-6      	; 0x6b84 <systemGenerateReport+0x8c0>
    6b8a:	11 97       	sbiw	r26, 0x01	; 1
    6b8c:	ac 19       	sub	r26, r12
    6b8e:	bd 09       	sbc	r27, r13
    6b90:	f8 01       	movw	r30, r16
    6b92:	01 90       	ld	r0, Z+
    6b94:	00 20       	and	r0, r0
    6b96:	e9 f7       	brne	.-6      	; 0x6b92 <systemGenerateReport+0x8ce>
    6b98:	31 97       	sbiw	r30, 0x01	; 1
    6b9a:	0e 1b       	sub	r16, r30
    6b9c:	0a 1b       	sub	r16, r26
    6b9e:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6ba0:	ed b7       	in	r30, 0x3d	; 61
    6ba2:	fe b7       	in	r31, 0x3e	; 62
    6ba4:	36 96       	adiw	r30, 0x06	; 6
    6ba6:	0f b6       	in	r0, 0x3f	; 63
    6ba8:	f8 94       	cli
    6baa:	fe bf       	out	0x3e, r31	; 62
    6bac:	0f be       	out	0x3f, r0	; 63
    6bae:	ed bf       	out	0x3d, r30	; 61
    6bb0:	fe 01       	movw	r30, r28
    6bb2:	e3 58       	subi	r30, 0x83	; 131
    6bb4:	ff 4f       	sbci	r31, 0xFF	; 255
    6bb6:	10 16       	cp	r1, r16
    6bb8:	74 f4       	brge	.+28     	; 0x6bd6 <systemGenerateReport+0x912>
    6bba:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6bbc:	90 e2       	ldi	r25, 0x20	; 32
    6bbe:	02 c0       	rjmp	.+4      	; 0x6bc4 <systemGenerateReport+0x900>
    6bc0:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6bc2:	8f 5f       	subi	r24, 0xFF	; 255
    6bc4:	80 17       	cp	r24, r16
    6bc6:	e0 f3       	brcs	.-8      	; 0x6bc0 <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6bc8:	fe 01       	movw	r30, r28
    6bca:	e3 58       	subi	r30, 0x83	; 131
    6bcc:	ff 4f       	sbci	r31, 0xFF	; 255
    6bce:	e0 0f       	add	r30, r16
    6bd0:	f1 1d       	adc	r31, r1
    6bd2:	10 82       	st	Z, r1
    6bd4:	03 c0       	rjmp	.+6      	; 0x6bdc <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    6bd6:	80 e2       	ldi	r24, 0x20	; 32
    6bd8:	80 83       	st	Z, r24
	 strTab[1]=0;
    6bda:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    6bdc:	8d b7       	in	r24, 0x3d	; 61
    6bde:	9e b7       	in	r25, 0x3e	; 62
    6be0:	0e 97       	sbiw	r24, 0x0e	; 14
    6be2:	0f b6       	in	r0, 0x3f	; 63
    6be4:	f8 94       	cli
    6be6:	9e bf       	out	0x3e, r25	; 62
    6be8:	0f be       	out	0x3f, r0	; 63
    6bea:	8d bf       	out	0x3d, r24	; 61
    6bec:	ed b7       	in	r30, 0x3d	; 61
    6bee:	fe b7       	in	r31, 0x3e	; 62
    6bf0:	31 96       	adiw	r30, 0x01	; 1
    6bf2:	ce 01       	movw	r24, r28
    6bf4:	8b 55       	subi	r24, 0x5B	; 91
    6bf6:	9f 4f       	sbci	r25, 0xFF	; 255
    6bf8:	ad b7       	in	r26, 0x3d	; 61
    6bfa:	be b7       	in	r27, 0x3e	; 62
    6bfc:	12 96       	adiw	r26, 0x02	; 2
    6bfe:	9c 93       	st	X, r25
    6c00:	8e 93       	st	-X, r24
    6c02:	11 97       	sbiw	r26, 0x01	; 1
    6c04:	8c e3       	ldi	r24, 0x3C	; 60
    6c06:	95 e0       	ldi	r25, 0x05	; 5
    6c08:	93 83       	std	Z+3, r25	; 0x03
    6c0a:	82 83       	std	Z+2, r24	; 0x02
    6c0c:	80 91 2b 02 	lds	r24, 0x022B
    6c10:	84 83       	std	Z+4, r24	; 0x04
    6c12:	15 82       	std	Z+5, r1	; 0x05
    6c14:	80 91 2a 02 	lds	r24, 0x022A
    6c18:	86 83       	std	Z+6, r24	; 0x06
    6c1a:	17 82       	std	Z+7, r1	; 0x07
    6c1c:	88 e6       	ldi	r24, 0x68	; 104
    6c1e:	99 e0       	ldi	r25, 0x09	; 9
    6c20:	91 87       	std	Z+9, r25	; 0x09
    6c22:	80 87       	std	Z+8, r24	; 0x08
    6c24:	ce 01       	movw	r24, r28
    6c26:	83 58       	subi	r24, 0x83	; 131
    6c28:	9f 4f       	sbci	r25, 0xFF	; 255
    6c2a:	93 87       	std	Z+11, r25	; 0x0b
    6c2c:	82 87       	std	Z+10, r24	; 0x0a
    6c2e:	ce 01       	movw	r24, r28
    6c30:	8f 56       	subi	r24, 0x6F	; 111
    6c32:	9f 4f       	sbci	r25, 0xFF	; 255
    6c34:	95 87       	std	Z+13, r25	; 0x0d
    6c36:	84 87       	std	Z+12, r24	; 0x0c
    6c38:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    6c3c:	ed b7       	in	r30, 0x3d	; 61
    6c3e:	fe b7       	in	r31, 0x3e	; 62
    6c40:	3e 96       	adiw	r30, 0x0e	; 14
    6c42:	27 c0       	rjmp	.+78     	; 0x6c92 <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    6c44:	8d b7       	in	r24, 0x3d	; 61
    6c46:	9e b7       	in	r25, 0x3e	; 62
    6c48:	0a 97       	sbiw	r24, 0x0a	; 10
    6c4a:	0f b6       	in	r0, 0x3f	; 63
    6c4c:	f8 94       	cli
    6c4e:	9e bf       	out	0x3e, r25	; 62
    6c50:	0f be       	out	0x3f, r0	; 63
    6c52:	8d bf       	out	0x3d, r24	; 61
    6c54:	ed b7       	in	r30, 0x3d	; 61
    6c56:	fe b7       	in	r31, 0x3e	; 62
    6c58:	31 96       	adiw	r30, 0x01	; 1
    6c5a:	ce 01       	movw	r24, r28
    6c5c:	8b 55       	subi	r24, 0x5B	; 91
    6c5e:	9f 4f       	sbci	r25, 0xFF	; 255
    6c60:	ad b7       	in	r26, 0x3d	; 61
    6c62:	be b7       	in	r27, 0x3e	; 62
    6c64:	12 96       	adiw	r26, 0x02	; 2
    6c66:	9c 93       	st	X, r25
    6c68:	8e 93       	st	-X, r24
    6c6a:	11 97       	sbiw	r26, 0x01	; 1
    6c6c:	8f e2       	ldi	r24, 0x2F	; 47
    6c6e:	95 e0       	ldi	r25, 0x05	; 5
    6c70:	93 83       	std	Z+3, r25	; 0x03
    6c72:	82 83       	std	Z+2, r24	; 0x02
    6c74:	80 91 2b 02 	lds	r24, 0x022B
    6c78:	84 83       	std	Z+4, r24	; 0x04
    6c7a:	15 82       	std	Z+5, r1	; 0x05
    6c7c:	80 91 2a 02 	lds	r24, 0x022A
    6c80:	86 83       	std	Z+6, r24	; 0x06
    6c82:	17 82       	std	Z+7, r1	; 0x07
    6c84:	d1 86       	std	Z+9, r13	; 0x09
    6c86:	c0 86       	std	Z+8, r12	; 0x08
    6c88:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    6c8c:	ed b7       	in	r30, 0x3d	; 61
    6c8e:	fe b7       	in	r31, 0x3e	; 62
    6c90:	3a 96       	adiw	r30, 0x0a	; 10
    6c92:	0f b6       	in	r0, 0x3f	; 63
    6c94:	f8 94       	cli
    6c96:	fe bf       	out	0x3e, r31	; 62
    6c98:	0f be       	out	0x3f, r0	; 63
    6c9a:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6c9c:	ce 01       	movw	r24, r28
    6c9e:	8b 55       	subi	r24, 0x5B	; 91
    6ca0:	9f 4f       	sbci	r25, 0xFF	; 255
    6ca2:	66 ef       	ldi	r22, 0xF6	; 246
    6ca4:	75 e0       	ldi	r23, 0x05	; 5
    6ca6:	4d e1       	ldi	r20, 0x1D	; 29
    6ca8:	52 e0       	ldi	r21, 0x02	; 2
    6caa:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6cae:	84 e0       	ldi	r24, 0x04	; 4
    6cb0:	66 ef       	ldi	r22, 0xF6	; 246
    6cb2:	75 e0       	ldi	r23, 0x05	; 5
    6cb4:	41 e0       	ldi	r20, 0x01	; 1
    6cb6:	2d e1       	ldi	r18, 0x1D	; 29
    6cb8:	32 e0       	ldi	r19, 0x02	; 2
    6cba:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6cbe:	8b e0       	ldi	r24, 0x0B	; 11
    6cc0:	66 ef       	ldi	r22, 0xF6	; 246
    6cc2:	75 e0       	ldi	r23, 0x05	; 5
    6cc4:	4a e2       	ldi	r20, 0x2A	; 42
    6cc6:	2d e1       	ldi	r18, 0x1D	; 29
    6cc8:	32 e0       	ldi	r19, 0x02	; 2
    6cca:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6cce:	86 e0       	ldi	r24, 0x06	; 6
    6cd0:	66 ef       	ldi	r22, 0xF6	; 246
    6cd2:	75 e0       	ldi	r23, 0x05	; 5
    6cd4:	41 e0       	ldi	r20, 0x01	; 1
    6cd6:	2d e1       	ldi	r18, 0x1D	; 29
    6cd8:	32 e0       	ldi	r19, 0x02	; 2
    6cda:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    6cde:	8c e0       	ldi	r24, 0x0C	; 12
    6ce0:	66 ef       	ldi	r22, 0xF6	; 246
    6ce2:	75 e0       	ldi	r23, 0x05	; 5
    6ce4:	41 e0       	ldi	r20, 0x01	; 1
    6ce6:	2d e1       	ldi	r18, 0x1D	; 29
    6ce8:	32 e0       	ldi	r19, 0x02	; 2
    6cea:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    6cee:	de 01       	movw	r26, r28
    6cf0:	d7 96       	adiw	r26, 0x37	; 55
    6cf2:	fd 01       	movw	r30, r26
    6cf4:	01 90       	ld	r0, Z+
    6cf6:	00 20       	and	r0, r0
    6cf8:	e9 f7       	brne	.-6      	; 0x6cf4 <systemGenerateReport+0xa30>
    6cfa:	9a 2f       	mov	r25, r26
    6cfc:	9e 1b       	sub	r25, r30
    6cfe:	9e 5e       	subi	r25, 0xEE	; 238
    6d00:	de 01       	movw	r26, r28
    6d02:	a7 59       	subi	r26, 0x97	; 151
    6d04:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6d06:	19 16       	cp	r1, r25
    6d08:	7c f4       	brge	.+30     	; 0x6d28 <systemGenerateReport+0xa64>
    6d0a:	fd 01       	movw	r30, r26
    6d0c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6d0e:	20 e2       	ldi	r18, 0x20	; 32
    6d10:	02 c0       	rjmp	.+4      	; 0x6d16 <systemGenerateReport+0xa52>
    6d12:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6d14:	8f 5f       	subi	r24, 0xFF	; 255
    6d16:	89 17       	cp	r24, r25
    6d18:	e0 f3       	brcs	.-8      	; 0x6d12 <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6d1a:	fe 01       	movw	r30, r28
    6d1c:	e7 59       	subi	r30, 0x97	; 151
    6d1e:	ff 4f       	sbci	r31, 0xFF	; 255
    6d20:	e9 0f       	add	r30, r25
    6d22:	f1 1d       	adc	r31, r1
    6d24:	10 82       	st	Z, r1
    6d26:	04 c0       	rjmp	.+8      	; 0x6d30 <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    6d28:	80 e2       	ldi	r24, 0x20	; 32
    6d2a:	8c 93       	st	X, r24
	 strTab[1]=0;
    6d2c:	11 96       	adiw	r26, 0x01	; 1
    6d2e:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    6d30:	de 01       	movw	r26, r28
    6d32:	aa 5b       	subi	r26, 0xBA	; 186
    6d34:	bf 4f       	sbci	r27, 0xFF	; 255
    6d36:	fd 01       	movw	r30, r26
    6d38:	01 90       	ld	r0, Z+
    6d3a:	00 20       	and	r0, r0
    6d3c:	e9 f7       	brne	.-6      	; 0x6d38 <systemGenerateReport+0xa74>
    6d3e:	ae 1b       	sub	r26, r30
    6d40:	a0 5f       	subi	r26, 0xF0	; 240
    6d42:	fe 01       	movw	r30, r28
    6d44:	e3 58       	subi	r30, 0x83	; 131
    6d46:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6d48:	1a 16       	cp	r1, r26
    6d4a:	74 f4       	brge	.+28     	; 0x6d68 <systemGenerateReport+0xaa4>
    6d4c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6d4e:	90 e2       	ldi	r25, 0x20	; 32
    6d50:	02 c0       	rjmp	.+4      	; 0x6d56 <systemGenerateReport+0xa92>
    6d52:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6d54:	8f 5f       	subi	r24, 0xFF	; 255
    6d56:	8a 17       	cp	r24, r26
    6d58:	e0 f3       	brcs	.-8      	; 0x6d52 <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6d5a:	fe 01       	movw	r30, r28
    6d5c:	e3 58       	subi	r30, 0x83	; 131
    6d5e:	ff 4f       	sbci	r31, 0xFF	; 255
    6d60:	ea 0f       	add	r30, r26
    6d62:	f1 1d       	adc	r31, r1
    6d64:	10 82       	st	Z, r1
    6d66:	03 c0       	rjmp	.+6      	; 0x6d6e <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    6d68:	80 e2       	ldi	r24, 0x20	; 32
    6d6a:	80 83       	st	Z, r24
	 strTab[1]=0;
    6d6c:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6d6e:	e1 99       	sbic	0x1c, 1	; 28
    6d70:	fe cf       	rjmp	.-4      	; 0x6d6e <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6d72:	11 ef       	ldi	r17, 0xF1	; 241
    6d74:	e1 2e       	mov	r14, r17
    6d76:	13 e0       	ldi	r17, 0x03	; 3
    6d78:	f1 2e       	mov	r15, r17
    6d7a:	ff ba       	out	0x1f, r15	; 31
    6d7c:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6d7e:	e0 9a       	sbi	0x1c, 0	; 28
    6d80:	8d b3       	in	r24, 0x1d	; 29
    6d82:	9e 01       	movw	r18, r28
    6d84:	2b 55       	subi	r18, 0x5B	; 91
    6d86:	3f 4f       	sbci	r19, 0xFF	; 255
    6d88:	ae 01       	movw	r20, r28
    6d8a:	49 5c       	subi	r20, 0xC9	; 201
    6d8c:	5f 4f       	sbci	r21, 0xFF	; 255
    6d8e:	de 01       	movw	r26, r28
    6d90:	a7 59       	subi	r26, 0x97	; 151
    6d92:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6d94:	81 30       	cpi	r24, 0x01	; 1
    6d96:	49 f5       	brne	.+82     	; 0x6dea <systemGenerateReport+0xb26>
    6d98:	8d b7       	in	r24, 0x3d	; 61
    6d9a:	9e b7       	in	r25, 0x3e	; 62
    6d9c:	0c 97       	sbiw	r24, 0x0c	; 12
    6d9e:	0f b6       	in	r0, 0x3f	; 63
    6da0:	f8 94       	cli
    6da2:	9e bf       	out	0x3e, r25	; 62
    6da4:	0f be       	out	0x3f, r0	; 63
    6da6:	8d bf       	out	0x3d, r24	; 61
    6da8:	6d b7       	in	r22, 0x3d	; 61
    6daa:	7e b7       	in	r23, 0x3e	; 62
    6dac:	6f 5f       	subi	r22, 0xFF	; 255
    6dae:	7f 4f       	sbci	r23, 0xFF	; 255
    6db0:	ed b7       	in	r30, 0x3d	; 61
    6db2:	fe b7       	in	r31, 0x3e	; 62
    6db4:	32 83       	std	Z+2, r19	; 0x02
    6db6:	21 83       	std	Z+1, r18	; 0x01
    6db8:	80 e2       	ldi	r24, 0x20	; 32
    6dba:	95 e0       	ldi	r25, 0x05	; 5
    6dbc:	fb 01       	movw	r30, r22
    6dbe:	93 83       	std	Z+3, r25	; 0x03
    6dc0:	82 83       	std	Z+2, r24	; 0x02
    6dc2:	b5 83       	std	Z+5, r27	; 0x05
    6dc4:	a4 83       	std	Z+4, r26	; 0x04
    6dc6:	57 83       	std	Z+7, r21	; 0x07
    6dc8:	46 83       	std	Z+6, r20	; 0x06
    6dca:	ce 01       	movw	r24, r28
    6dcc:	83 58       	subi	r24, 0x83	; 131
    6dce:	9f 4f       	sbci	r25, 0xFF	; 255
    6dd0:	91 87       	std	Z+9, r25	; 0x09
    6dd2:	80 87       	std	Z+8, r24	; 0x08
    6dd4:	ce 01       	movw	r24, r28
    6dd6:	8a 5b       	subi	r24, 0xBA	; 186
    6dd8:	9f 4f       	sbci	r25, 0xFF	; 255
    6dda:	93 87       	std	Z+11, r25	; 0x0b
    6ddc:	82 87       	std	Z+10, r24	; 0x0a
    6dde:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    6de2:	8d b7       	in	r24, 0x3d	; 61
    6de4:	9e b7       	in	r25, 0x3e	; 62
    6de6:	0c 96       	adiw	r24, 0x0c	; 12
    6de8:	1c c0       	rjmp	.+56     	; 0x6e22 <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    6dea:	ed b7       	in	r30, 0x3d	; 61
    6dec:	fe b7       	in	r31, 0x3e	; 62
    6dee:	38 97       	sbiw	r30, 0x08	; 8
    6df0:	0f b6       	in	r0, 0x3f	; 63
    6df2:	f8 94       	cli
    6df4:	fe bf       	out	0x3e, r31	; 62
    6df6:	0f be       	out	0x3f, r0	; 63
    6df8:	ed bf       	out	0x3d, r30	; 61
    6dfa:	6d b7       	in	r22, 0x3d	; 61
    6dfc:	7e b7       	in	r23, 0x3e	; 62
    6dfe:	6f 5f       	subi	r22, 0xFF	; 255
    6e00:	7f 4f       	sbci	r23, 0xFF	; 255
    6e02:	32 83       	std	Z+2, r19	; 0x02
    6e04:	21 83       	std	Z+1, r18	; 0x01
    6e06:	85 e1       	ldi	r24, 0x15	; 21
    6e08:	95 e0       	ldi	r25, 0x05	; 5
    6e0a:	fb 01       	movw	r30, r22
    6e0c:	93 83       	std	Z+3, r25	; 0x03
    6e0e:	82 83       	std	Z+2, r24	; 0x02
    6e10:	b5 83       	std	Z+5, r27	; 0x05
    6e12:	a4 83       	std	Z+4, r26	; 0x04
    6e14:	57 83       	std	Z+7, r21	; 0x07
    6e16:	46 83       	std	Z+6, r20	; 0x06
    6e18:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    6e1c:	8d b7       	in	r24, 0x3d	; 61
    6e1e:	9e b7       	in	r25, 0x3e	; 62
    6e20:	08 96       	adiw	r24, 0x08	; 8
    6e22:	0f b6       	in	r0, 0x3f	; 63
    6e24:	f8 94       	cli
    6e26:	9e bf       	out	0x3e, r25	; 62
    6e28:	0f be       	out	0x3f, r0	; 63
    6e2a:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6e2c:	ce 01       	movw	r24, r28
    6e2e:	8b 55       	subi	r24, 0x5B	; 91
    6e30:	9f 4f       	sbci	r25, 0xFF	; 255
    6e32:	66 ef       	ldi	r22, 0xF6	; 246
    6e34:	75 e0       	ldi	r23, 0x05	; 5
    6e36:	4d e1       	ldi	r20, 0x1D	; 29
    6e38:	52 e0       	ldi	r21, 0x02	; 2
    6e3a:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    6e3e:	de 01       	movw	r26, r28
    6e40:	59 96       	adiw	r26, 0x19	; 25
    6e42:	fd 01       	movw	r30, r26
    6e44:	01 90       	ld	r0, Z+
    6e46:	00 20       	and	r0, r0
    6e48:	e9 f7       	brne	.-6      	; 0x6e44 <systemGenerateReport+0xb80>
    6e4a:	9a 2f       	mov	r25, r26
    6e4c:	9e 1b       	sub	r25, r30
    6e4e:	9e 5e       	subi	r25, 0xEE	; 238
    6e50:	de 01       	movw	r26, r28
    6e52:	a7 59       	subi	r26, 0x97	; 151
    6e54:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6e56:	19 16       	cp	r1, r25
    6e58:	7c f4       	brge	.+30     	; 0x6e78 <systemGenerateReport+0xbb4>
    6e5a:	fd 01       	movw	r30, r26
    6e5c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6e5e:	20 e2       	ldi	r18, 0x20	; 32
    6e60:	02 c0       	rjmp	.+4      	; 0x6e66 <systemGenerateReport+0xba2>
    6e62:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6e64:	8f 5f       	subi	r24, 0xFF	; 255
    6e66:	89 17       	cp	r24, r25
    6e68:	e0 f3       	brcs	.-8      	; 0x6e62 <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6e6a:	fe 01       	movw	r30, r28
    6e6c:	e7 59       	subi	r30, 0x97	; 151
    6e6e:	ff 4f       	sbci	r31, 0xFF	; 255
    6e70:	e9 0f       	add	r30, r25
    6e72:	f1 1d       	adc	r31, r1
    6e74:	10 82       	st	Z, r1
    6e76:	04 c0       	rjmp	.+8      	; 0x6e80 <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    6e78:	80 e2       	ldi	r24, 0x20	; 32
    6e7a:	8c 93       	st	X, r24
	 strTab[1]=0;
    6e7c:	11 96       	adiw	r26, 0x01	; 1
    6e7e:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    6e80:	de 01       	movw	r26, r28
    6e82:	98 96       	adiw	r26, 0x28	; 40
    6e84:	fd 01       	movw	r30, r26
    6e86:	01 90       	ld	r0, Z+
    6e88:	00 20       	and	r0, r0
    6e8a:	e9 f7       	brne	.-6      	; 0x6e86 <systemGenerateReport+0xbc2>
    6e8c:	ae 1b       	sub	r26, r30
    6e8e:	a0 5f       	subi	r26, 0xF0	; 240
    6e90:	fe 01       	movw	r30, r28
    6e92:	e3 58       	subi	r30, 0x83	; 131
    6e94:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6e96:	1a 16       	cp	r1, r26
    6e98:	74 f4       	brge	.+28     	; 0x6eb6 <systemGenerateReport+0xbf2>
    6e9a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6e9c:	90 e2       	ldi	r25, 0x20	; 32
    6e9e:	02 c0       	rjmp	.+4      	; 0x6ea4 <systemGenerateReport+0xbe0>
    6ea0:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6ea2:	8f 5f       	subi	r24, 0xFF	; 255
    6ea4:	8a 17       	cp	r24, r26
    6ea6:	e0 f3       	brcs	.-8      	; 0x6ea0 <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6ea8:	fe 01       	movw	r30, r28
    6eaa:	e3 58       	subi	r30, 0x83	; 131
    6eac:	ff 4f       	sbci	r31, 0xFF	; 255
    6eae:	ea 0f       	add	r30, r26
    6eb0:	f1 1d       	adc	r31, r1
    6eb2:	10 82       	st	Z, r1
    6eb4:	03 c0       	rjmp	.+6      	; 0x6ebc <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    6eb6:	80 e2       	ldi	r24, 0x20	; 32
    6eb8:	80 83       	st	Z, r24
	 strTab[1]=0;
    6eba:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6ebc:	e1 99       	sbic	0x1c, 1	; 28
    6ebe:	fe cf       	rjmp	.-4      	; 0x6ebc <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6ec0:	ff ba       	out	0x1f, r15	; 31
    6ec2:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6ec4:	e0 9a       	sbi	0x1c, 0	; 28
    6ec6:	8d b3       	in	r24, 0x1d	; 29
    6ec8:	9e 01       	movw	r18, r28
    6eca:	2b 55       	subi	r18, 0x5B	; 91
    6ecc:	3f 4f       	sbci	r19, 0xFF	; 255
    6ece:	ae 01       	movw	r20, r28
    6ed0:	47 5e       	subi	r20, 0xE7	; 231
    6ed2:	5f 4f       	sbci	r21, 0xFF	; 255
    6ed4:	de 01       	movw	r26, r28
    6ed6:	a7 59       	subi	r26, 0x97	; 151
    6ed8:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6eda:	81 30       	cpi	r24, 0x01	; 1
    6edc:	31 f5       	brne	.+76     	; 0x6f2a <systemGenerateReport+0xc66>
    6ede:	ed b7       	in	r30, 0x3d	; 61
    6ee0:	fe b7       	in	r31, 0x3e	; 62
    6ee2:	3c 97       	sbiw	r30, 0x0c	; 12
    6ee4:	0f b6       	in	r0, 0x3f	; 63
    6ee6:	f8 94       	cli
    6ee8:	fe bf       	out	0x3e, r31	; 62
    6eea:	0f be       	out	0x3f, r0	; 63
    6eec:	ed bf       	out	0x3d, r30	; 61
    6eee:	6d b7       	in	r22, 0x3d	; 61
    6ef0:	7e b7       	in	r23, 0x3e	; 62
    6ef2:	6f 5f       	subi	r22, 0xFF	; 255
    6ef4:	7f 4f       	sbci	r23, 0xFF	; 255
    6ef6:	32 83       	std	Z+2, r19	; 0x02
    6ef8:	21 83       	std	Z+1, r18	; 0x01
    6efa:	86 e0       	ldi	r24, 0x06	; 6
    6efc:	95 e0       	ldi	r25, 0x05	; 5
    6efe:	fb 01       	movw	r30, r22
    6f00:	93 83       	std	Z+3, r25	; 0x03
    6f02:	82 83       	std	Z+2, r24	; 0x02
    6f04:	b5 83       	std	Z+5, r27	; 0x05
    6f06:	a4 83       	std	Z+4, r26	; 0x04
    6f08:	57 83       	std	Z+7, r21	; 0x07
    6f0a:	46 83       	std	Z+6, r20	; 0x06
    6f0c:	ce 01       	movw	r24, r28
    6f0e:	83 58       	subi	r24, 0x83	; 131
    6f10:	9f 4f       	sbci	r25, 0xFF	; 255
    6f12:	91 87       	std	Z+9, r25	; 0x09
    6f14:	80 87       	std	Z+8, r24	; 0x08
    6f16:	ce 01       	movw	r24, r28
    6f18:	88 96       	adiw	r24, 0x28	; 40
    6f1a:	93 87       	std	Z+11, r25	; 0x0b
    6f1c:	82 87       	std	Z+10, r24	; 0x0a
    6f1e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    6f22:	8d b7       	in	r24, 0x3d	; 61
    6f24:	9e b7       	in	r25, 0x3e	; 62
    6f26:	0c 96       	adiw	r24, 0x0c	; 12
    6f28:	1c c0       	rjmp	.+56     	; 0x6f62 <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    6f2a:	ed b7       	in	r30, 0x3d	; 61
    6f2c:	fe b7       	in	r31, 0x3e	; 62
    6f2e:	38 97       	sbiw	r30, 0x08	; 8
    6f30:	0f b6       	in	r0, 0x3f	; 63
    6f32:	f8 94       	cli
    6f34:	fe bf       	out	0x3e, r31	; 62
    6f36:	0f be       	out	0x3f, r0	; 63
    6f38:	ed bf       	out	0x3d, r30	; 61
    6f3a:	6d b7       	in	r22, 0x3d	; 61
    6f3c:	7e b7       	in	r23, 0x3e	; 62
    6f3e:	6f 5f       	subi	r22, 0xFF	; 255
    6f40:	7f 4f       	sbci	r23, 0xFF	; 255
    6f42:	32 83       	std	Z+2, r19	; 0x02
    6f44:	21 83       	std	Z+1, r18	; 0x01
    6f46:	8b ef       	ldi	r24, 0xFB	; 251
    6f48:	94 e0       	ldi	r25, 0x04	; 4
    6f4a:	fb 01       	movw	r30, r22
    6f4c:	93 83       	std	Z+3, r25	; 0x03
    6f4e:	82 83       	std	Z+2, r24	; 0x02
    6f50:	b5 83       	std	Z+5, r27	; 0x05
    6f52:	a4 83       	std	Z+4, r26	; 0x04
    6f54:	57 83       	std	Z+7, r21	; 0x07
    6f56:	46 83       	std	Z+6, r20	; 0x06
    6f58:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    6f5c:	8d b7       	in	r24, 0x3d	; 61
    6f5e:	9e b7       	in	r25, 0x3e	; 62
    6f60:	08 96       	adiw	r24, 0x08	; 8
    6f62:	0f b6       	in	r0, 0x3f	; 63
    6f64:	f8 94       	cli
    6f66:	9e bf       	out	0x3e, r25	; 62
    6f68:	0f be       	out	0x3f, r0	; 63
    6f6a:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6f6c:	ce 01       	movw	r24, r28
    6f6e:	8b 55       	subi	r24, 0x5B	; 91
    6f70:	9f 4f       	sbci	r25, 0xFF	; 255
    6f72:	66 ef       	ldi	r22, 0xF6	; 246
    6f74:	75 e0       	ldi	r23, 0x05	; 5
    6f76:	4d e1       	ldi	r20, 0x1D	; 29
    6f78:	52 e0       	ldi	r21, 0x02	; 2
    6f7a:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>
    6f7e:	8e 01       	movw	r16, r28
    6f80:	07 59       	subi	r16, 0x97	; 151
    6f82:	1f 4f       	sbci	r17, 0xFF	; 255
    6f84:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6f86:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6f88:	d8 01       	movw	r26, r16
    6f8a:	c8 01       	movw	r24, r16
    6f8c:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    6f8e:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6f90:	e8 17       	cp	r30, r24
    6f92:	f9 07       	cpc	r31, r25
    6f94:	e1 f7       	brne	.-8      	; 0x6f8e <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6f96:	1c 96       	adiw	r26, 0x0c	; 12
    6f98:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6f9a:	e1 99       	sbic	0x1c, 1	; 28
    6f9c:	fe cf       	rjmp	.-4      	; 0x6f9a <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6f9e:	ff ba       	out	0x1f, r15	; 31
    6fa0:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6fa2:	e0 9a       	sbi	0x1c, 0	; 28
    6fa4:	8d b3       	in	r24, 0x1d	; 29
    6fa6:	9e 01       	movw	r18, r28
    6fa8:	2b 55       	subi	r18, 0x5B	; 91
    6faa:	3f 4f       	sbci	r19, 0xFF	; 255
    6fac:	de 01       	movw	r26, r28
    6fae:	a7 59       	subi	r26, 0x97	; 151
    6fb0:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    6fb2:	81 30       	cpi	r24, 0x01	; 1
    6fb4:	71 f4       	brne	.+28     	; 0x6fd2 <systemGenerateReport+0xd0e>
    6fb6:	00 d0       	rcall	.+0      	; 0x6fb8 <systemGenerateReport+0xcf4>
    6fb8:	00 d0       	rcall	.+0      	; 0x6fba <systemGenerateReport+0xcf6>
    6fba:	00 d0       	rcall	.+0      	; 0x6fbc <systemGenerateReport+0xcf8>
    6fbc:	4d b7       	in	r20, 0x3d	; 61
    6fbe:	5e b7       	in	r21, 0x3e	; 62
    6fc0:	4f 5f       	subi	r20, 0xFF	; 255
    6fc2:	5f 4f       	sbci	r21, 0xFF	; 255
    6fc4:	ed b7       	in	r30, 0x3d	; 61
    6fc6:	fe b7       	in	r31, 0x3e	; 62
    6fc8:	32 83       	std	Z+2, r19	; 0x02
    6fca:	21 83       	std	Z+1, r18	; 0x01
    6fcc:	8d ed       	ldi	r24, 0xDD	; 221
    6fce:	94 e0       	ldi	r25, 0x04	; 4
    6fd0:	0d c0       	rjmp	.+26     	; 0x6fec <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    6fd2:	00 d0       	rcall	.+0      	; 0x6fd4 <systemGenerateReport+0xd10>
    6fd4:	00 d0       	rcall	.+0      	; 0x6fd6 <systemGenerateReport+0xd12>
    6fd6:	00 d0       	rcall	.+0      	; 0x6fd8 <systemGenerateReport+0xd14>
    6fd8:	4d b7       	in	r20, 0x3d	; 61
    6fda:	5e b7       	in	r21, 0x3e	; 62
    6fdc:	4f 5f       	subi	r20, 0xFF	; 255
    6fde:	5f 4f       	sbci	r21, 0xFF	; 255
    6fe0:	ed b7       	in	r30, 0x3d	; 61
    6fe2:	fe b7       	in	r31, 0x3e	; 62
    6fe4:	32 83       	std	Z+2, r19	; 0x02
    6fe6:	21 83       	std	Z+1, r18	; 0x01
    6fe8:	8f eb       	ldi	r24, 0xBF	; 191
    6fea:	94 e0       	ldi	r25, 0x04	; 4
    6fec:	fa 01       	movw	r30, r20
    6fee:	93 83       	std	Z+3, r25	; 0x03
    6ff0:	82 83       	std	Z+2, r24	; 0x02
    6ff2:	b5 83       	std	Z+5, r27	; 0x05
    6ff4:	a4 83       	std	Z+4, r26	; 0x04
    6ff6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    6ffa:	8d b7       	in	r24, 0x3d	; 61
    6ffc:	9e b7       	in	r25, 0x3e	; 62
    6ffe:	06 96       	adiw	r24, 0x06	; 6
    7000:	0f b6       	in	r0, 0x3f	; 63
    7002:	f8 94       	cli
    7004:	9e bf       	out	0x3e, r25	; 62
    7006:	0f be       	out	0x3f, r0	; 63
    7008:	8d bf       	out	0x3d, r24	; 61
    700a:	ce 01       	movw	r24, r28
    700c:	8b 55       	subi	r24, 0x5B	; 91
    700e:	9f 4f       	sbci	r25, 0xFF	; 255
    7010:	66 ef       	ldi	r22, 0xF6	; 246
    7012:	75 e0       	ldi	r23, 0x05	; 5
    7014:	4d e1       	ldi	r20, 0x1D	; 29
    7016:	52 e0       	ldi	r21, 0x02	; 2
    7018:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    701c:	e8 e0       	ldi	r30, 0x08	; 8
    701e:	fb e0       	ldi	r31, 0x0B	; 11
    7020:	01 90       	ld	r0, Z+
    7022:	00 20       	and	r0, r0
    7024:	e9 f7       	brne	.-6      	; 0x7020 <systemGenerateReport+0xd5c>
    7026:	31 97       	sbiw	r30, 0x01	; 1
    7028:	e8 50       	subi	r30, 0x08	; 8
    702a:	fb 40       	sbci	r31, 0x0B	; 11
    702c:	97 e1       	ldi	r25, 0x17	; 23
    702e:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7030:	19 16       	cp	r1, r25
    7032:	84 f4       	brge	.+32     	; 0x7054 <systemGenerateReport+0xd90>
    7034:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7036:	20 e2       	ldi	r18, 0x20	; 32
    7038:	04 c0       	rjmp	.+8      	; 0x7042 <systemGenerateReport+0xd7e>
    703a:	d8 01       	movw	r26, r16
    703c:	2d 93       	st	X+, r18
    703e:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7040:	8f 5f       	subi	r24, 0xFF	; 255
    7042:	89 17       	cp	r24, r25
    7044:	d0 f3       	brcs	.-12     	; 0x703a <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7046:	fe 01       	movw	r30, r28
    7048:	e7 59       	subi	r30, 0x97	; 151
    704a:	ff 4f       	sbci	r31, 0xFF	; 255
    704c:	e9 0f       	add	r30, r25
    704e:	f1 1d       	adc	r31, r1
    7050:	10 82       	st	Z, r1
    7052:	06 c0       	rjmp	.+12     	; 0x7060 <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    7054:	fe 01       	movw	r30, r28
    7056:	e7 59       	subi	r30, 0x97	; 151
    7058:	ff 4f       	sbci	r31, 0xFF	; 255
    705a:	80 e2       	ldi	r24, 0x20	; 32
    705c:	80 83       	st	Z, r24
	 strTab[1]=0;
    705e:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    7060:	e3 e3       	ldi	r30, 0x33	; 51
    7062:	fe e0       	ldi	r31, 0x0E	; 14
    7064:	01 90       	ld	r0, Z+
    7066:	00 20       	and	r0, r0
    7068:	e9 f7       	brne	.-6      	; 0x7064 <systemGenerateReport+0xda0>
    706a:	31 97       	sbiw	r30, 0x01	; 1
    706c:	e3 53       	subi	r30, 0x33	; 51
    706e:	fe 40       	sbci	r31, 0x0E	; 14
    7070:	9f e0       	ldi	r25, 0x0F	; 15
    7072:	9e 1b       	sub	r25, r30
    7074:	fe 01       	movw	r30, r28
    7076:	e3 58       	subi	r30, 0x83	; 131
    7078:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    707a:	19 16       	cp	r1, r25
    707c:	74 f4       	brge	.+28     	; 0x709a <systemGenerateReport+0xdd6>
    707e:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7080:	20 e2       	ldi	r18, 0x20	; 32
    7082:	02 c0       	rjmp	.+4      	; 0x7088 <systemGenerateReport+0xdc4>
    7084:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7086:	8f 5f       	subi	r24, 0xFF	; 255
    7088:	89 17       	cp	r24, r25
    708a:	e0 f3       	brcs	.-8      	; 0x7084 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    708c:	fe 01       	movw	r30, r28
    708e:	e3 58       	subi	r30, 0x83	; 131
    7090:	ff 4f       	sbci	r31, 0xFF	; 255
    7092:	e9 0f       	add	r30, r25
    7094:	f1 1d       	adc	r31, r1
    7096:	10 82       	st	Z, r1
    7098:	03 c0       	rjmp	.+6      	; 0x70a0 <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    709a:	80 e2       	ldi	r24, 0x20	; 32
    709c:	80 83       	st	Z, r24
	 strTab[1]=0;
    709e:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    70a0:	e1 99       	sbic	0x1c, 1	; 28
    70a2:	fe cf       	rjmp	.-4      	; 0x70a0 <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    70a4:	ff ba       	out	0x1f, r15	; 31
    70a6:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    70a8:	e0 9a       	sbi	0x1c, 0	; 28
    70aa:	8d b3       	in	r24, 0x1d	; 29
    70ac:	9e 01       	movw	r18, r28
    70ae:	2b 55       	subi	r18, 0x5B	; 91
    70b0:	3f 4f       	sbci	r19, 0xFF	; 255
    70b2:	48 e0       	ldi	r20, 0x08	; 8
    70b4:	5b e0       	ldi	r21, 0x0B	; 11
    70b6:	de 01       	movw	r26, r28
    70b8:	a7 59       	subi	r26, 0x97	; 151
    70ba:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    70bc:	81 30       	cpi	r24, 0x01	; 1
    70be:	31 f5       	brne	.+76     	; 0x710c <systemGenerateReport+0xe48>
    70c0:	ed b7       	in	r30, 0x3d	; 61
    70c2:	fe b7       	in	r31, 0x3e	; 62
    70c4:	3c 97       	sbiw	r30, 0x0c	; 12
    70c6:	0f b6       	in	r0, 0x3f	; 63
    70c8:	f8 94       	cli
    70ca:	fe bf       	out	0x3e, r31	; 62
    70cc:	0f be       	out	0x3f, r0	; 63
    70ce:	ed bf       	out	0x3d, r30	; 61
    70d0:	6d b7       	in	r22, 0x3d	; 61
    70d2:	7e b7       	in	r23, 0x3e	; 62
    70d4:	6f 5f       	subi	r22, 0xFF	; 255
    70d6:	7f 4f       	sbci	r23, 0xFF	; 255
    70d8:	32 83       	std	Z+2, r19	; 0x02
    70da:	21 83       	std	Z+1, r18	; 0x01
    70dc:	86 eb       	ldi	r24, 0xB6	; 182
    70de:	94 e0       	ldi	r25, 0x04	; 4
    70e0:	fb 01       	movw	r30, r22
    70e2:	93 83       	std	Z+3, r25	; 0x03
    70e4:	82 83       	std	Z+2, r24	; 0x02
    70e6:	b5 83       	std	Z+5, r27	; 0x05
    70e8:	a4 83       	std	Z+4, r26	; 0x04
    70ea:	57 83       	std	Z+7, r21	; 0x07
    70ec:	46 83       	std	Z+6, r20	; 0x06
    70ee:	ce 01       	movw	r24, r28
    70f0:	83 58       	subi	r24, 0x83	; 131
    70f2:	9f 4f       	sbci	r25, 0xFF	; 255
    70f4:	91 87       	std	Z+9, r25	; 0x09
    70f6:	80 87       	std	Z+8, r24	; 0x08
    70f8:	83 e3       	ldi	r24, 0x33	; 51
    70fa:	9e e0       	ldi	r25, 0x0E	; 14
    70fc:	93 87       	std	Z+11, r25	; 0x0b
    70fe:	82 87       	std	Z+10, r24	; 0x0a
    7100:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    7104:	8d b7       	in	r24, 0x3d	; 61
    7106:	9e b7       	in	r25, 0x3e	; 62
    7108:	0c 96       	adiw	r24, 0x0c	; 12
    710a:	1c c0       	rjmp	.+56     	; 0x7144 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    710c:	ed b7       	in	r30, 0x3d	; 61
    710e:	fe b7       	in	r31, 0x3e	; 62
    7110:	38 97       	sbiw	r30, 0x08	; 8
    7112:	0f b6       	in	r0, 0x3f	; 63
    7114:	f8 94       	cli
    7116:	fe bf       	out	0x3e, r31	; 62
    7118:	0f be       	out	0x3f, r0	; 63
    711a:	ed bf       	out	0x3d, r30	; 61
    711c:	6d b7       	in	r22, 0x3d	; 61
    711e:	7e b7       	in	r23, 0x3e	; 62
    7120:	6f 5f       	subi	r22, 0xFF	; 255
    7122:	7f 4f       	sbci	r23, 0xFF	; 255
    7124:	32 83       	std	Z+2, r19	; 0x02
    7126:	21 83       	std	Z+1, r18	; 0x01
    7128:	81 eb       	ldi	r24, 0xB1	; 177
    712a:	94 e0       	ldi	r25, 0x04	; 4
    712c:	fb 01       	movw	r30, r22
    712e:	93 83       	std	Z+3, r25	; 0x03
    7130:	82 83       	std	Z+2, r24	; 0x02
    7132:	b5 83       	std	Z+5, r27	; 0x05
    7134:	a4 83       	std	Z+4, r26	; 0x04
    7136:	57 83       	std	Z+7, r21	; 0x07
    7138:	46 83       	std	Z+6, r20	; 0x06
    713a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    713e:	8d b7       	in	r24, 0x3d	; 61
    7140:	9e b7       	in	r25, 0x3e	; 62
    7142:	08 96       	adiw	r24, 0x08	; 8
    7144:	0f b6       	in	r0, 0x3f	; 63
    7146:	f8 94       	cli
    7148:	9e bf       	out	0x3e, r25	; 62
    714a:	0f be       	out	0x3f, r0	; 63
    714c:	8d bf       	out	0x3d, r24	; 61
    714e:	ce 01       	movw	r24, r28
    7150:	8b 55       	subi	r24, 0x5B	; 91
    7152:	9f 4f       	sbci	r25, 0xFF	; 255
    7154:	66 ef       	ldi	r22, 0xF6	; 246
    7156:	75 e0       	ldi	r23, 0x05	; 5
    7158:	4d e1       	ldi	r20, 0x1D	; 29
    715a:	52 e0       	ldi	r21, 0x02	; 2
    715c:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7160:	87 e0       	ldi	r24, 0x07	; 7
    7162:	66 ef       	ldi	r22, 0xF6	; 246
    7164:	75 e0       	ldi	r23, 0x05	; 5
    7166:	41 e0       	ldi	r20, 0x01	; 1
    7168:	2d e1       	ldi	r18, 0x1D	; 29
    716a:	32 e0       	ldi	r19, 0x02	; 2
    716c:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7170:	8b e0       	ldi	r24, 0x0B	; 11
    7172:	66 ef       	ldi	r22, 0xF6	; 246
    7174:	75 e0       	ldi	r23, 0x05	; 5
    7176:	4a e2       	ldi	r20, 0x2A	; 42
    7178:	2d e1       	ldi	r18, 0x1D	; 29
    717a:	32 e0       	ldi	r19, 0x02	; 2
    717c:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7180:	89 e0       	ldi	r24, 0x09	; 9
    7182:	66 ef       	ldi	r22, 0xF6	; 246
    7184:	75 e0       	ldi	r23, 0x05	; 5
    7186:	41 e0       	ldi	r20, 0x01	; 1
    7188:	2d e1       	ldi	r18, 0x1D	; 29
    718a:	32 e0       	ldi	r19, 0x02	; 2
    718c:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7190:	8c e0       	ldi	r24, 0x0C	; 12
    7192:	66 ef       	ldi	r22, 0xF6	; 246
    7194:	75 e0       	ldi	r23, 0x05	; 5
    7196:	41 e0       	ldi	r20, 0x01	; 1
    7198:	2d e1       	ldi	r18, 0x1D	; 29
    719a:	32 e0       	ldi	r19, 0x02	; 2
    719c:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>


          cmdPrint=0b00000000;
    71a0:	10 92 e1 01 	sts	0x01E1, r1
		  LengthMessage81=RepPos+1;
    71a4:	80 91 1d 02 	lds	r24, 0x021D
    71a8:	90 91 1e 02 	lds	r25, 0x021E
    71ac:	01 96       	adiw	r24, 0x01	; 1
    71ae:	90 93 b6 01 	sts	0x01B6, r25
    71b2:	80 93 b5 01 	sts	0x01B5, r24

		  IsFreePrinting=True;
    71b6:	81 e0       	ldi	r24, 0x01	; 1
    71b8:	80 93 d5 01 	sts	0x01D5, r24
	      IsBusyFreePrinting=True;
    71bc:	80 93 df 01 	sts	0x01DF, r24

	      stGenerateReport=grWaitPrinted2;
    71c0:	89 e0       	ldi	r24, 0x09	; 9
    71c2:	91 c3       	rjmp	.+1826   	; 0x78e6 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    71c4:	80 91 df 01 	lds	r24, 0x01DF
    71c8:	88 23       	and	r24, r24
    71ca:	09 f0       	breq	.+2      	; 0x71ce <systemGenerateReport+0xf0a>
    71cc:	94 c3       	rjmp	.+1832   	; 0x78f6 <systemGenerateReport+0x1632>
    71ce:	86 e0       	ldi	r24, 0x06	; 6
    71d0:	8a c3       	rjmp	.+1812   	; 0x78e6 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    71d2:	10 92 1e 02 	sts	0x021E, r1
    71d6:	10 92 1d 02 	sts	0x021D, r1
    71da:	e6 ef       	ldi	r30, 0xF6	; 246
    71dc:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    71de:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    71e0:	97 e0       	ldi	r25, 0x07	; 7
    71e2:	e7 38       	cpi	r30, 0x87	; 135
    71e4:	f9 07       	cpc	r31, r25
    71e6:	d9 f7       	brne	.-10     	; 0x71de <systemGenerateReport+0xf1a>
    71e8:	fe 01       	movw	r30, r28
    71ea:	eb 55       	subi	r30, 0x5B	; 91
    71ec:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    71ee:	ce 01       	movw	r24, r28
    71f0:	8b 50       	subi	r24, 0x0B	; 11
    71f2:	9f 4f       	sbci	r25, 0xFF	; 255
    71f4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    71f6:	e8 17       	cp	r30, r24
    71f8:	f9 07       	cpc	r31, r25
    71fa:	e1 f7       	brne	.-8      	; 0x71f4 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    71fc:	88 ed       	ldi	r24, 0xD8	; 216
    71fe:	9a e0       	ldi	r25, 0x0A	; 10
    7200:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    7204:	03 e2       	ldi	r16, 0x23	; 35
    7206:	1a e0       	ldi	r17, 0x0A	; 10
    7208:	c8 01       	movw	r24, r16
    720a:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    720e:	88 ed       	ldi	r24, 0xD8	; 216
    7210:	9a e0       	ldi	r25, 0x0A	; 10
    7212:	0e 94 2e 31 	call	0x625c	; 0x625c <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    7216:	88 ed       	ldi	r24, 0xD8	; 216
    7218:	9a e0       	ldi	r25, 0x0A	; 10
    721a:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    721e:	c8 01       	movw	r24, r16
    7220:	0e 94 21 31 	call	0x6242	; 0x6242 <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    7224:	c8 01       	movw	r24, r16
    7226:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    722a:	81 e0       	ldi	r24, 0x01	; 1
    722c:	66 ef       	ldi	r22, 0xF6	; 246
    722e:	75 e0       	ldi	r23, 0x05	; 5
    7230:	41 e0       	ldi	r20, 0x01	; 1
    7232:	2d e1       	ldi	r18, 0x1D	; 29
    7234:	32 e0       	ldi	r19, 0x02	; 2
    7236:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    723a:	8b e0       	ldi	r24, 0x0B	; 11
    723c:	66 ef       	ldi	r22, 0xF6	; 246
    723e:	75 e0       	ldi	r23, 0x05	; 5
    7240:	4a e2       	ldi	r20, 0x2A	; 42
    7242:	2d e1       	ldi	r18, 0x1D	; 29
    7244:	32 e0       	ldi	r19, 0x02	; 2
    7246:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    724a:	83 e0       	ldi	r24, 0x03	; 3
    724c:	66 ef       	ldi	r22, 0xF6	; 246
    724e:	75 e0       	ldi	r23, 0x05	; 5
    7250:	41 e0       	ldi	r20, 0x01	; 1
    7252:	2d e1       	ldi	r18, 0x1D	; 29
    7254:	32 e0       	ldi	r19, 0x02	; 2
    7256:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    725a:	8c e0       	ldi	r24, 0x0C	; 12
    725c:	66 ef       	ldi	r22, 0xF6	; 246
    725e:	75 e0       	ldi	r23, 0x05	; 5
    7260:	41 e0       	ldi	r20, 0x01	; 1
    7262:	2d e1       	ldi	r18, 0x1D	; 29
    7264:	32 e0       	ldi	r19, 0x02	; 2
    7266:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    726a:	d8 01       	movw	r26, r16
    726c:	0d 90       	ld	r0, X+
    726e:	00 20       	and	r0, r0
    7270:	e9 f7       	brne	.-6      	; 0x726c <systemGenerateReport+0xfa8>
    7272:	8d 01       	movw	r16, r26
    7274:	01 50       	subi	r16, 0x01	; 1
    7276:	10 40       	sbci	r17, 0x00	; 0
    7278:	03 52       	subi	r16, 0x23	; 35
    727a:	1a 40       	sbci	r17, 0x0A	; 10
    727c:	91 e1       	ldi	r25, 0x11	; 17
    727e:	90 1b       	sub	r25, r16
    7280:	de 01       	movw	r26, r28
    7282:	a7 59       	subi	r26, 0x97	; 151
    7284:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7286:	19 16       	cp	r1, r25
    7288:	7c f4       	brge	.+30     	; 0x72a8 <systemGenerateReport+0xfe4>
    728a:	fd 01       	movw	r30, r26
    728c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    728e:	20 e2       	ldi	r18, 0x20	; 32
    7290:	02 c0       	rjmp	.+4      	; 0x7296 <systemGenerateReport+0xfd2>
    7292:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7294:	8f 5f       	subi	r24, 0xFF	; 255
    7296:	89 17       	cp	r24, r25
    7298:	e0 f3       	brcs	.-8      	; 0x7292 <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    729a:	fe 01       	movw	r30, r28
    729c:	e7 59       	subi	r30, 0x97	; 151
    729e:	ff 4f       	sbci	r31, 0xFF	; 255
    72a0:	e9 0f       	add	r30, r25
    72a2:	f1 1d       	adc	r31, r1
    72a4:	10 82       	st	Z, r1
    72a6:	04 c0       	rjmp	.+8      	; 0x72b0 <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    72a8:	80 e2       	ldi	r24, 0x20	; 32
    72aa:	8c 93       	st	X, r24
	 strTab[1]=0;
    72ac:	11 96       	adiw	r26, 0x01	; 1
    72ae:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    72b0:	e8 ed       	ldi	r30, 0xD8	; 216
    72b2:	fa e0       	ldi	r31, 0x0A	; 10
    72b4:	01 90       	ld	r0, Z+
    72b6:	00 20       	and	r0, r0
    72b8:	e9 f7       	brne	.-6      	; 0x72b4 <systemGenerateReport+0xff0>
    72ba:	31 97       	sbiw	r30, 0x01	; 1
    72bc:	e8 5d       	subi	r30, 0xD8	; 216
    72be:	fa 40       	sbci	r31, 0x0A	; 10
    72c0:	9f e0       	ldi	r25, 0x0F	; 15
    72c2:	9e 1b       	sub	r25, r30
    72c4:	fe 01       	movw	r30, r28
    72c6:	e3 58       	subi	r30, 0x83	; 131
    72c8:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    72ca:	19 16       	cp	r1, r25
    72cc:	74 f4       	brge	.+28     	; 0x72ea <systemGenerateReport+0x1026>
    72ce:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    72d0:	20 e2       	ldi	r18, 0x20	; 32
    72d2:	02 c0       	rjmp	.+4      	; 0x72d8 <systemGenerateReport+0x1014>
    72d4:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    72d6:	8f 5f       	subi	r24, 0xFF	; 255
    72d8:	89 17       	cp	r24, r25
    72da:	e0 f3       	brcs	.-8      	; 0x72d4 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    72dc:	fe 01       	movw	r30, r28
    72de:	e3 58       	subi	r30, 0x83	; 131
    72e0:	ff 4f       	sbci	r31, 0xFF	; 255
    72e2:	e9 0f       	add	r30, r25
    72e4:	f1 1d       	adc	r31, r1
    72e6:	10 82       	st	Z, r1
    72e8:	03 c0       	rjmp	.+6      	; 0x72f0 <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    72ea:	80 e2       	ldi	r24, 0x20	; 32
    72ec:	80 83       	st	Z, r24
	 strTab[1]=0;
    72ee:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    72f0:	e1 99       	sbic	0x1c, 1	; 28
    72f2:	fe cf       	rjmp	.-4      	; 0x72f0 <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    72f4:	e1 ef       	ldi	r30, 0xF1	; 241
    72f6:	f3 e0       	ldi	r31, 0x03	; 3
    72f8:	ff bb       	out	0x1f, r31	; 31
    72fa:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    72fc:	e0 9a       	sbi	0x1c, 0	; 28
    72fe:	8d b3       	in	r24, 0x1d	; 29
    7300:	9e 01       	movw	r18, r28
    7302:	2b 55       	subi	r18, 0x5B	; 91
    7304:	3f 4f       	sbci	r19, 0xFF	; 255
    7306:	43 e2       	ldi	r20, 0x23	; 35
    7308:	5a e0       	ldi	r21, 0x0A	; 10
    730a:	de 01       	movw	r26, r28
    730c:	a7 59       	subi	r26, 0x97	; 151
    730e:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7310:	81 30       	cpi	r24, 0x01	; 1
    7312:	41 f5       	brne	.+80     	; 0x7364 <systemGenerateReport+0x10a0>
    7314:	8d b7       	in	r24, 0x3d	; 61
    7316:	9e b7       	in	r25, 0x3e	; 62
    7318:	0c 97       	sbiw	r24, 0x0c	; 12
    731a:	0f b6       	in	r0, 0x3f	; 63
    731c:	f8 94       	cli
    731e:	9e bf       	out	0x3e, r25	; 62
    7320:	0f be       	out	0x3f, r0	; 63
    7322:	8d bf       	out	0x3d, r24	; 61
    7324:	6d b7       	in	r22, 0x3d	; 61
    7326:	7e b7       	in	r23, 0x3e	; 62
    7328:	6f 5f       	subi	r22, 0xFF	; 255
    732a:	7f 4f       	sbci	r23, 0xFF	; 255
    732c:	ed b7       	in	r30, 0x3d	; 61
    732e:	fe b7       	in	r31, 0x3e	; 62
    7330:	32 83       	std	Z+2, r19	; 0x02
    7332:	21 83       	std	Z+1, r18	; 0x01
    7334:	82 ea       	ldi	r24, 0xA2	; 162
    7336:	94 e0       	ldi	r25, 0x04	; 4
    7338:	fb 01       	movw	r30, r22
    733a:	93 83       	std	Z+3, r25	; 0x03
    733c:	82 83       	std	Z+2, r24	; 0x02
    733e:	b5 83       	std	Z+5, r27	; 0x05
    7340:	a4 83       	std	Z+4, r26	; 0x04
    7342:	57 83       	std	Z+7, r21	; 0x07
    7344:	46 83       	std	Z+6, r20	; 0x06
    7346:	ce 01       	movw	r24, r28
    7348:	83 58       	subi	r24, 0x83	; 131
    734a:	9f 4f       	sbci	r25, 0xFF	; 255
    734c:	91 87       	std	Z+9, r25	; 0x09
    734e:	80 87       	std	Z+8, r24	; 0x08
    7350:	88 ed       	ldi	r24, 0xD8	; 216
    7352:	9a e0       	ldi	r25, 0x0A	; 10
    7354:	93 87       	std	Z+11, r25	; 0x0b
    7356:	82 87       	std	Z+10, r24	; 0x0a
    7358:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    735c:	8d b7       	in	r24, 0x3d	; 61
    735e:	9e b7       	in	r25, 0x3e	; 62
    7360:	0c 96       	adiw	r24, 0x0c	; 12
    7362:	1c c0       	rjmp	.+56     	; 0x739c <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7364:	ed b7       	in	r30, 0x3d	; 61
    7366:	fe b7       	in	r31, 0x3e	; 62
    7368:	38 97       	sbiw	r30, 0x08	; 8
    736a:	0f b6       	in	r0, 0x3f	; 63
    736c:	f8 94       	cli
    736e:	fe bf       	out	0x3e, r31	; 62
    7370:	0f be       	out	0x3f, r0	; 63
    7372:	ed bf       	out	0x3d, r30	; 61
    7374:	6d b7       	in	r22, 0x3d	; 61
    7376:	7e b7       	in	r23, 0x3e	; 62
    7378:	6f 5f       	subi	r22, 0xFF	; 255
    737a:	7f 4f       	sbci	r23, 0xFF	; 255
    737c:	32 83       	std	Z+2, r19	; 0x02
    737e:	21 83       	std	Z+1, r18	; 0x01
    7380:	87 e9       	ldi	r24, 0x97	; 151
    7382:	94 e0       	ldi	r25, 0x04	; 4
    7384:	fb 01       	movw	r30, r22
    7386:	93 83       	std	Z+3, r25	; 0x03
    7388:	82 83       	std	Z+2, r24	; 0x02
    738a:	b5 83       	std	Z+5, r27	; 0x05
    738c:	a4 83       	std	Z+4, r26	; 0x04
    738e:	57 83       	std	Z+7, r21	; 0x07
    7390:	46 83       	std	Z+6, r20	; 0x06
    7392:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    7396:	8d b7       	in	r24, 0x3d	; 61
    7398:	9e b7       	in	r25, 0x3e	; 62
    739a:	08 96       	adiw	r24, 0x08	; 8
    739c:	0f b6       	in	r0, 0x3f	; 63
    739e:	f8 94       	cli
    73a0:	9e bf       	out	0x3e, r25	; 62
    73a2:	0f be       	out	0x3f, r0	; 63
    73a4:	8d bf       	out	0x3d, r24	; 61
    73a6:	ce 01       	movw	r24, r28
    73a8:	8b 55       	subi	r24, 0x5B	; 91
    73aa:	9f 4f       	sbci	r25, 0xFF	; 255
    73ac:	66 ef       	ldi	r22, 0xF6	; 246
    73ae:	75 e0       	ldi	r23, 0x05	; 5
    73b0:	4d e1       	ldi	r20, 0x1D	; 29
    73b2:	52 e0       	ldi	r21, 0x02	; 2
    73b4:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    73b8:	84 e0       	ldi	r24, 0x04	; 4
    73ba:	66 ef       	ldi	r22, 0xF6	; 246
    73bc:	75 e0       	ldi	r23, 0x05	; 5
    73be:	41 e0       	ldi	r20, 0x01	; 1
    73c0:	2d e1       	ldi	r18, 0x1D	; 29
    73c2:	32 e0       	ldi	r19, 0x02	; 2
    73c4:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    73c8:	8b e0       	ldi	r24, 0x0B	; 11
    73ca:	66 ef       	ldi	r22, 0xF6	; 246
    73cc:	75 e0       	ldi	r23, 0x05	; 5
    73ce:	4a e2       	ldi	r20, 0x2A	; 42
    73d0:	2d e1       	ldi	r18, 0x1D	; 29
    73d2:	32 e0       	ldi	r19, 0x02	; 2
    73d4:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    73d8:	86 e0       	ldi	r24, 0x06	; 6
    73da:	66 ef       	ldi	r22, 0xF6	; 246
    73dc:	75 e0       	ldi	r23, 0x05	; 5
    73de:	41 e0       	ldi	r20, 0x01	; 1
    73e0:	2d e1       	ldi	r18, 0x1D	; 29
    73e2:	32 e0       	ldi	r19, 0x02	; 2
    73e4:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    73e8:	8c e0       	ldi	r24, 0x0C	; 12
    73ea:	66 ef       	ldi	r22, 0xF6	; 246
    73ec:	75 e0       	ldi	r23, 0x05	; 5
    73ee:	41 e0       	ldi	r20, 0x01	; 1
    73f0:	2d e1       	ldi	r18, 0x1D	; 29
    73f2:	32 e0       	ldi	r19, 0x02	; 2
    73f4:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    73f8:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    73fa:	b8 e2       	ldi	r27, 0x28	; 40
    73fc:	2b 2e       	mov	r2, r27
    73fe:	31 2c       	mov	r3, r1
    7400:	2c 0e       	add	r2, r28
    7402:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    7404:	a7 e3       	ldi	r26, 0x37	; 55
    7406:	6a 2e       	mov	r6, r26
    7408:	71 2c       	mov	r7, r1
    740a:	6c 0e       	add	r6, r28
    740c:	7d 1e       	adc	r7, r29
    740e:	d3 01       	movw	r26, r6
    7410:	1f 96       	adiw	r26, 0x0f	; 15
    7412:	cb 50       	subi	r28, 0x0B	; 11
    7414:	df 4f       	sbci	r29, 0xFF	; 255
    7416:	b9 83       	std	Y+1, r27	; 0x01
    7418:	a8 83       	st	Y, r26
    741a:	c5 5f       	subi	r28, 0xF5	; 245
    741c:	d0 40       	sbci	r29, 0x00	; 0
    741e:	f6 e4       	ldi	r31, 0x46	; 70
    7420:	4f 2e       	mov	r4, r31
    7422:	51 2c       	mov	r5, r1
    7424:	4c 0e       	add	r4, r28
    7426:	5d 1e       	adc	r5, r29
    7428:	f2 01       	movw	r30, r4
    742a:	3f 96       	adiw	r30, 0x0f	; 15
    742c:	c9 50       	subi	r28, 0x09	; 9
    742e:	df 4f       	sbci	r29, 0xFF	; 255
    7430:	f9 83       	std	Y+1, r31	; 0x01
    7432:	e8 83       	st	Y, r30
    7434:	c7 5f       	subi	r28, 0xF7	; 247
    7436:	d0 40       	sbci	r29, 0x00	; 0
    7438:	ed e7       	ldi	r30, 0x7D	; 125
    743a:	8e 2e       	mov	r8, r30
    743c:	91 2c       	mov	r9, r1
    743e:	8c 0e       	add	r8, r28
    7440:	9d 1e       	adc	r9, r29
    7442:	e3 c1       	rjmp	.+966    	; 0x780a <systemGenerateReport+0x1546>
    7444:	f5 01       	movw	r30, r10
    7446:	e1 5e       	subi	r30, 0xE1	; 225
    7448:	fd 4f       	sbci	r31, 0xFD	; 253
    744a:	80 81       	ld	r24, Z
    744c:	80 53       	subi	r24, 0x30	; 48
    744e:	8a 30       	cpi	r24, 0x0A	; 10
    7450:	08 f0       	brcs	.+2      	; 0x7454 <systemGenerateReport+0x1190>
    7452:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    7454:	80 93 2c 02 	sts	0x022C, r24
			  if (xGrade>0){
    7458:	88 23       	and	r24, r24
    745a:	09 f4       	brne	.+2      	; 0x745e <systemGenerateReport+0x119a>
    745c:	d5 c1       	rjmp	.+938    	; 0x7808 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    745e:	68 e6       	ldi	r22, 0x68	; 104
    7460:	79 e0       	ldi	r23, 0x09	; 9
    7462:	0e 94 9b 2a 	call	0x5536	; 0x5536 <GetProductName>
    7466:	e3 e2       	ldi	r30, 0x23	; 35
    7468:	fa e0       	ldi	r31, 0x0A	; 10
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    746a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    746c:	8a e0       	ldi	r24, 0x0A	; 10
    746e:	e7 33       	cpi	r30, 0x37	; 55
    7470:	f8 07       	cpc	r31, r24
    7472:	d9 f7       	brne	.-10     	; 0x746a <systemGenerateReport+0x11a6>
    7474:	e8 ed       	ldi	r30, 0xD8	; 216
    7476:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    7478:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    747a:	9a e0       	ldi	r25, 0x0A	; 10
    747c:	ec 3e       	cpi	r30, 0xEC	; 236
    747e:	f9 07       	cpc	r31, r25
    7480:	d9 f7       	brne	.-10     	; 0x7478 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7482:	81 e0       	ldi	r24, 0x01	; 1
    7484:	80 93 2e 02 	sts	0x022E, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7488:	79 e1       	ldi	r23, 0x19	; 25
    748a:	c7 2e       	mov	r12, r23
    748c:	d1 2c       	mov	r13, r1
    748e:	cc 0e       	add	r12, r28
    7490:	dd 1e       	adc	r13, r29
    7492:	e6 c0       	rjmp	.+460    	; 0x7660 <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7494:	ce 01       	movw	r24, r28
    7496:	07 96       	adiw	r24, 0x07	; 7
    7498:	65 e4       	ldi	r22, 0x45	; 69
    749a:	70 e0       	ldi	r23, 0x00	; 0
    749c:	48 e0       	ldi	r20, 0x08	; 8
    749e:	50 e0       	ldi	r21, 0x00	; 0
    74a0:	27 e9       	ldi	r18, 0x97	; 151
    74a2:	32 e1       	ldi	r19, 0x12	; 18
    74a4:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    74a8:	80 91 2e 02 	lds	r24, 0x022E
    74ac:	fe 01       	movw	r30, r28
    74ae:	e8 0f       	add	r30, r24
    74b0:	f1 1d       	adc	r31, r1
    74b2:	86 81       	ldd	r24, Z+6	; 0x06
    74b4:	80 93 2b 02 	sts	0x022B, r24
					  if (PumpNum>0){
    74b8:	88 23       	and	r24, r24
    74ba:	09 f4       	brne	.+2      	; 0x74be <systemGenerateReport+0x11fa>
    74bc:	cc c0       	rjmp	.+408    	; 0x7656 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    74be:	81 e0       	ldi	r24, 0x01	; 1
    74c0:	c3 c0       	rjmp	.+390    	; 0x7648 <systemGenerateReport+0x1384>
    74c2:	60 91 2e 02 	lds	r22, 0x022E
    74c6:	a6 e0       	ldi	r26, 0x06	; 6
    74c8:	6a 9f       	mul	r22, r26
    74ca:	b0 01       	movw	r22, r0
    74cc:	11 24       	eor	r1, r1
    74ce:	61 5b       	subi	r22, 0xB1	; 177
    74d0:	7f 4f       	sbci	r23, 0xFF	; 255
    74d2:	ce 01       	movw	r24, r28
    74d4:	01 96       	adiw	r24, 0x01	; 1
    74d6:	46 e0       	ldi	r20, 0x06	; 6
    74d8:	50 e0       	ldi	r21, 0x00	; 0
    74da:	27 e9       	ldi	r18, 0x97	; 151
    74dc:	32 e1       	ldi	r19, 0x12	; 18
    74de:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    74e2:	80 91 2d 02 	lds	r24, 0x022D
    74e6:	fe 01       	movw	r30, r28
    74e8:	e8 0f       	add	r30, r24
    74ea:	f1 1d       	adc	r31, r1
    74ec:	90 81       	ld	r25, Z
    74ee:	80 91 2c 02 	lds	r24, 0x022C
    74f2:	98 17       	cp	r25, r24
    74f4:	09 f0       	breq	.+2      	; 0x74f8 <systemGenerateReport+0x1234>
    74f6:	a5 c0       	rjmp	.+330    	; 0x7642 <systemGenerateReport+0x137e>
    74f8:	e3 e3       	ldi	r30, 0x33	; 51
    74fa:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    74fc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    74fe:	be e0       	ldi	r27, 0x0E	; 14
    7500:	e2 34       	cpi	r30, 0x42	; 66
    7502:	fb 07       	cpc	r31, r27
    7504:	d9 f7       	brne	.-10     	; 0x74fc <systemGenerateReport+0x1238>
    7506:	e8 e0       	ldi	r30, 0x08	; 8
    7508:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    750a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    750c:	8b e0       	ldi	r24, 0x0B	; 11
    750e:	e7 31       	cpi	r30, 0x17	; 23
    7510:	f8 07       	cpc	r31, r24
    7512:	d9 f7       	brne	.-10     	; 0x750a <systemGenerateReport+0x1246>
    7514:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    7516:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7518:	e2 15       	cp	r30, r2
    751a:	f3 05       	cpc	r31, r3
    751c:	e1 f7       	brne	.-8      	; 0x7516 <systemGenerateReport+0x1252>
    751e:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    7520:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7522:	e6 15       	cp	r30, r6
    7524:	f7 05       	cpc	r31, r7
    7526:	e1 f7       	brne	.-8      	; 0x7520 <systemGenerateReport+0x125c>
    7528:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    752a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    752c:	cb 50       	subi	r28, 0x0B	; 11
    752e:	df 4f       	sbci	r29, 0xFF	; 255
    7530:	a8 81       	ld	r26, Y
    7532:	b9 81       	ldd	r27, Y+1	; 0x01
    7534:	c5 5f       	subi	r28, 0xF5	; 245
    7536:	d0 40       	sbci	r29, 0x00	; 0
    7538:	ea 17       	cp	r30, r26
    753a:	fb 07       	cpc	r31, r27
    753c:	b1 f7       	brne	.-20     	; 0x752a <systemGenerateReport+0x1266>
    753e:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    7540:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7542:	c9 50       	subi	r28, 0x09	; 9
    7544:	df 4f       	sbci	r29, 0xFF	; 255
    7546:	88 81       	ld	r24, Y
    7548:	99 81       	ldd	r25, Y+1	; 0x01
    754a:	c7 5f       	subi	r28, 0xF7	; 247
    754c:	d0 40       	sbci	r29, 0x00	; 0
    754e:	e8 17       	cp	r30, r24
    7550:	f9 07       	cpc	r31, r25
    7552:	b1 f7       	brne	.-20     	; 0x7540 <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    7554:	80 91 2d 02 	lds	r24, 0x022D
    7558:	80 93 2a 02 	sts	0x022A, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    755c:	80 91 2b 02 	lds	r24, 0x022B
    7560:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
								  if (FIPAddr>0){
    7564:	88 23       	and	r24, r24
    7566:	11 f1       	breq	.+68     	; 0x75ac <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    7568:	f8 2e       	mov	r15, r24
    756a:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    756c:	80 e0       	ldi	r24, 0x00	; 0
    756e:	60 e0       	ldi	r22, 0x00	; 0
    7570:	4f 2d       	mov	r20, r15
    7572:	20 91 2a 02 	lds	r18, 0x022A
    7576:	86 01       	movw	r16, r12
    7578:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    757c:	81 e0       	ldi	r24, 0x01	; 1
    757e:	60 e0       	ldi	r22, 0x00	; 0
    7580:	4f 2d       	mov	r20, r15
    7582:	20 91 2a 02 	lds	r18, 0x022A
    7586:	81 01       	movw	r16, r2
    7588:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    758c:	80 e0       	ldi	r24, 0x00	; 0
    758e:	61 e0       	ldi	r22, 0x01	; 1
    7590:	4f 2d       	mov	r20, r15
    7592:	20 91 2a 02 	lds	r18, 0x022A
    7596:	83 01       	movw	r16, r6
    7598:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    759c:	81 e0       	ldi	r24, 0x01	; 1
    759e:	61 e0       	ldi	r22, 0x01	; 1
    75a0:	4f 2d       	mov	r20, r15
    75a2:	20 91 2a 02 	lds	r18, 0x022A
    75a6:	82 01       	movw	r16, r4
    75a8:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    75ac:	80 e0       	ldi	r24, 0x00	; 0
    75ae:	b3 01       	movw	r22, r6
    75b0:	a6 01       	movw	r20, r12
    75b2:	28 e0       	ldi	r18, 0x08	; 8
    75b4:	3b e0       	ldi	r19, 0x0B	; 11
    75b6:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    75ba:	88 e0       	ldi	r24, 0x08	; 8
    75bc:	9b e0       	ldi	r25, 0x0B	; 11
    75be:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <IsMinus>
    75c2:	81 30       	cpi	r24, 0x01	; 1
    75c4:	21 f4       	brne	.+8      	; 0x75ce <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    75c6:	88 e0       	ldi	r24, 0x08	; 8
    75c8:	9b e0       	ldi	r25, 0x0B	; 11
    75ca:	0e 94 ca 29 	call	0x5394	; 0x5394 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    75ce:	e1 99       	sbic	0x1c, 1	; 28
    75d0:	fe cf       	rjmp	.-4      	; 0x75ce <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    75d2:	a7 e6       	ldi	r26, 0x67	; 103
    75d4:	b1 e0       	ldi	r27, 0x01	; 1
    75d6:	bf bb       	out	0x1f, r27	; 31
    75d8:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    75da:	e0 9a       	sbi	0x1c, 0	; 28
    75dc:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    75de:	82 30       	cpi	r24, 0x02	; 2
    75e0:	79 f4       	brne	.+30     	; 0x7600 <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    75e2:	ce 01       	movw	r24, r28
    75e4:	0f 96       	adiw	r24, 0x0f	; 15
    75e6:	60 91 2b 02 	lds	r22, 0x022B
    75ea:	40 91 2a 02 	lds	r20, 0x022A
    75ee:	0e 94 d5 21 	call	0x43aa	; 0x43aa <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    75f2:	82 e0       	ldi	r24, 0x02	; 2
    75f4:	be 01       	movw	r22, r28
    75f6:	61 5f       	subi	r22, 0xF1	; 241
    75f8:	7f 4f       	sbci	r23, 0xFF	; 255
    75fa:	48 e0       	ldi	r20, 0x08	; 8
    75fc:	5b e0       	ldi	r21, 0x0B	; 11
    75fe:	03 c0       	rjmp	.+6      	; 0x7606 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7600:	80 e0       	ldi	r24, 0x00	; 0
    7602:	b2 01       	movw	r22, r4
    7604:	a1 01       	movw	r20, r2
    7606:	23 e3       	ldi	r18, 0x33	; 51
    7608:	3e e0       	ldi	r19, 0x0E	; 14
    760a:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    760e:	83 e3       	ldi	r24, 0x33	; 51
    7610:	9e e0       	ldi	r25, 0x0E	; 14
    7612:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <IsMinus>
    7616:	81 30       	cpi	r24, 0x01	; 1
    7618:	21 f4       	brne	.+8      	; 0x7622 <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    761a:	83 e3       	ldi	r24, 0x33	; 51
    761c:	9e e0       	ldi	r25, 0x0E	; 14
    761e:	0e 94 ca 29 	call	0x5394	; 0x5394 <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    7622:	81 e0       	ldi	r24, 0x01	; 1
    7624:	63 e2       	ldi	r22, 0x23	; 35
    7626:	7a e0       	ldi	r23, 0x0A	; 10
    7628:	48 e0       	ldi	r20, 0x08	; 8
    762a:	5b e0       	ldi	r21, 0x0B	; 11
    762c:	9b 01       	movw	r18, r22
    762e:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    7632:	81 e0       	ldi	r24, 0x01	; 1
    7634:	68 ed       	ldi	r22, 0xD8	; 216
    7636:	7a e0       	ldi	r23, 0x0A	; 10
    7638:	43 e3       	ldi	r20, 0x33	; 51
    763a:	5e e0       	ldi	r21, 0x0E	; 14
    763c:	9b 01       	movw	r18, r22
    763e:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7642:	80 91 2d 02 	lds	r24, 0x022D
    7646:	8f 5f       	subi	r24, 0xFF	; 255
    7648:	80 93 2d 02 	sts	0x022D, r24
    764c:	80 91 2d 02 	lds	r24, 0x022D
    7650:	87 30       	cpi	r24, 0x07	; 7
    7652:	08 f4       	brcc	.+2      	; 0x7656 <systemGenerateReport+0x1392>
    7654:	36 cf       	rjmp	.-404    	; 0x74c2 <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7656:	80 91 2e 02 	lds	r24, 0x022E
    765a:	8f 5f       	subi	r24, 0xFF	; 255
    765c:	80 93 2e 02 	sts	0x022E, r24
    7660:	80 91 2e 02 	lds	r24, 0x022E
    7664:	89 30       	cpi	r24, 0x09	; 9
    7666:	08 f4       	brcc	.+2      	; 0x766a <systemGenerateReport+0x13a6>
    7668:	15 cf       	rjmp	.-470    	; 0x7494 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    766a:	88 ed       	ldi	r24, 0xD8	; 216
    766c:	9a e0       	ldi	r25, 0x0A	; 10
    766e:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    7672:	03 e2       	ldi	r16, 0x23	; 35
    7674:	1a e0       	ldi	r17, 0x0A	; 10
    7676:	c8 01       	movw	r24, r16
    7678:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    767c:	88 ed       	ldi	r24, 0xD8	; 216
    767e:	9a e0       	ldi	r25, 0x0A	; 10
    7680:	0e 94 2e 31 	call	0x625c	; 0x625c <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    7684:	88 ed       	ldi	r24, 0xD8	; 216
    7686:	9a e0       	ldi	r25, 0x0A	; 10
    7688:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    768c:	c8 01       	movw	r24, r16
    768e:	0e 94 21 31 	call	0x6242	; 0x6242 <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    7692:	c8 01       	movw	r24, r16
    7694:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    7698:	e8 e6       	ldi	r30, 0x68	; 104
    769a:	f9 e0       	ldi	r31, 0x09	; 9
    769c:	01 90       	ld	r0, Z+
    769e:	00 20       	and	r0, r0
    76a0:	e9 f7       	brne	.-6      	; 0x769c <systemGenerateReport+0x13d8>
    76a2:	31 97       	sbiw	r30, 0x01	; 1
    76a4:	e8 56       	subi	r30, 0x68	; 104
    76a6:	f9 40       	sbci	r31, 0x09	; 9
    76a8:	d8 01       	movw	r26, r16
    76aa:	0d 90       	ld	r0, X+
    76ac:	00 20       	and	r0, r0
    76ae:	e9 f7       	brne	.-6      	; 0x76aa <systemGenerateReport+0x13e6>
    76b0:	8d 01       	movw	r16, r26
    76b2:	01 50       	subi	r16, 0x01	; 1
    76b4:	10 40       	sbci	r17, 0x00	; 0
    76b6:	03 52       	subi	r16, 0x23	; 35
    76b8:	1a 40       	sbci	r17, 0x0A	; 10
    76ba:	8e 2f       	mov	r24, r30
    76bc:	81 95       	neg	r24
    76be:	80 1b       	sub	r24, r16
    76c0:	8b 5e       	subi	r24, 0xEB	; 235
    76c2:	de 01       	movw	r26, r28
    76c4:	a7 59       	subi	r26, 0x97	; 151
    76c6:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    76c8:	18 16       	cp	r1, r24
    76ca:	7c f4       	brge	.+30     	; 0x76ea <systemGenerateReport+0x1426>
    76cc:	fd 01       	movw	r30, r26
    76ce:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    76d0:	20 e2       	ldi	r18, 0x20	; 32
    76d2:	02 c0       	rjmp	.+4      	; 0x76d8 <systemGenerateReport+0x1414>
    76d4:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    76d6:	9f 5f       	subi	r25, 0xFF	; 255
    76d8:	98 17       	cp	r25, r24
    76da:	e0 f3       	brcs	.-8      	; 0x76d4 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    76dc:	fe 01       	movw	r30, r28
    76de:	e7 59       	subi	r30, 0x97	; 151
    76e0:	ff 4f       	sbci	r31, 0xFF	; 255
    76e2:	e8 0f       	add	r30, r24
    76e4:	f1 1d       	adc	r31, r1
    76e6:	10 82       	st	Z, r1
    76e8:	04 c0       	rjmp	.+8      	; 0x76f2 <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    76ea:	80 e2       	ldi	r24, 0x20	; 32
    76ec:	8c 93       	st	X, r24
	 strTab[1]=0;
    76ee:	11 96       	adiw	r26, 0x01	; 1
    76f0:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    76f2:	e8 ed       	ldi	r30, 0xD8	; 216
    76f4:	fa e0       	ldi	r31, 0x0A	; 10
    76f6:	01 90       	ld	r0, Z+
    76f8:	00 20       	and	r0, r0
    76fa:	e9 f7       	brne	.-6      	; 0x76f6 <systemGenerateReport+0x1432>
    76fc:	31 97       	sbiw	r30, 0x01	; 1
    76fe:	e8 5d       	subi	r30, 0xD8	; 216
    7700:	fa 40       	sbci	r31, 0x0A	; 10
    7702:	9f e0       	ldi	r25, 0x0F	; 15
    7704:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7706:	19 16       	cp	r1, r25
    7708:	6c f4       	brge	.+26     	; 0x7724 <systemGenerateReport+0x1460>
    770a:	f4 01       	movw	r30, r8
    770c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    770e:	20 e2       	ldi	r18, 0x20	; 32
    7710:	02 c0       	rjmp	.+4      	; 0x7716 <systemGenerateReport+0x1452>
    7712:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7714:	8f 5f       	subi	r24, 0xFF	; 255
    7716:	89 17       	cp	r24, r25
    7718:	e0 f3       	brcs	.-8      	; 0x7712 <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    771a:	f4 01       	movw	r30, r8
    771c:	e9 0f       	add	r30, r25
    771e:	f1 1d       	adc	r31, r1
    7720:	10 82       	st	Z, r1
    7722:	04 c0       	rjmp	.+8      	; 0x772c <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    7724:	80 e2       	ldi	r24, 0x20	; 32
    7726:	f4 01       	movw	r30, r8
    7728:	80 83       	st	Z, r24
	 strTab[1]=0;
    772a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    772c:	e1 99       	sbic	0x1c, 1	; 28
    772e:	fe cf       	rjmp	.-4      	; 0x772c <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7730:	81 ef       	ldi	r24, 0xF1	; 241
    7732:	93 e0       	ldi	r25, 0x03	; 3
    7734:	9f bb       	out	0x1f, r25	; 31
    7736:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7738:	e0 9a       	sbi	0x1c, 0	; 28
    773a:	8d b3       	in	r24, 0x1d	; 29
    773c:	9e 01       	movw	r18, r28
    773e:	2b 55       	subi	r18, 0x5B	; 91
    7740:	3f 4f       	sbci	r19, 0xFF	; 255
    7742:	43 e2       	ldi	r20, 0x23	; 35
    7744:	5a e0       	ldi	r21, 0x0A	; 10
    7746:	68 e6       	ldi	r22, 0x68	; 104
    7748:	c6 2e       	mov	r12, r22
    774a:	69 e0       	ldi	r22, 0x09	; 9
    774c:	d6 2e       	mov	r13, r22
    774e:	de 01       	movw	r26, r28
    7750:	a7 59       	subi	r26, 0x97	; 151
    7752:	bf 4f       	sbci	r27, 0xFF	; 255
    7754:	b5 01       	movw	r22, r10
    7756:	6f 5f       	subi	r22, 0xFF	; 255
    7758:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    775a:	81 30       	cpi	r24, 0x01	; 1
    775c:	39 f5       	brne	.+78     	; 0x77ac <systemGenerateReport+0x14e8>
    775e:	ed b7       	in	r30, 0x3d	; 61
    7760:	fe b7       	in	r31, 0x3e	; 62
    7762:	70 97       	sbiw	r30, 0x10	; 16
    7764:	0f b6       	in	r0, 0x3f	; 63
    7766:	f8 94       	cli
    7768:	fe bf       	out	0x3e, r31	; 62
    776a:	0f be       	out	0x3f, r0	; 63
    776c:	ed bf       	out	0x3d, r30	; 61
    776e:	0d b7       	in	r16, 0x3d	; 61
    7770:	1e b7       	in	r17, 0x3e	; 62
    7772:	0f 5f       	subi	r16, 0xFF	; 255
    7774:	1f 4f       	sbci	r17, 0xFF	; 255
    7776:	32 83       	std	Z+2, r19	; 0x02
    7778:	21 83       	std	Z+1, r18	; 0x01
    777a:	89 e8       	ldi	r24, 0x89	; 137
    777c:	94 e0       	ldi	r25, 0x04	; 4
    777e:	f8 01       	movw	r30, r16
    7780:	93 83       	std	Z+3, r25	; 0x03
    7782:	82 83       	std	Z+2, r24	; 0x02
    7784:	75 83       	std	Z+5, r23	; 0x05
    7786:	64 83       	std	Z+4, r22	; 0x04
    7788:	d7 82       	std	Z+7, r13	; 0x07
    778a:	c6 82       	std	Z+6, r12	; 0x06
    778c:	b1 87       	std	Z+9, r27	; 0x09
    778e:	a0 87       	std	Z+8, r26	; 0x08
    7790:	53 87       	std	Z+11, r21	; 0x0b
    7792:	42 87       	std	Z+10, r20	; 0x0a
    7794:	95 86       	std	Z+13, r9	; 0x0d
    7796:	84 86       	std	Z+12, r8	; 0x0c
    7798:	88 ed       	ldi	r24, 0xD8	; 216
    779a:	9a e0       	ldi	r25, 0x0A	; 10
    779c:	97 87       	std	Z+15, r25	; 0x0f
    779e:	86 87       	std	Z+14, r24	; 0x0e
    77a0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    77a4:	8d b7       	in	r24, 0x3d	; 61
    77a6:	9e b7       	in	r25, 0x3e	; 62
    77a8:	40 96       	adiw	r24, 0x10	; 16
    77aa:	20 c0       	rjmp	.+64     	; 0x77ec <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    77ac:	ed b7       	in	r30, 0x3d	; 61
    77ae:	fe b7       	in	r31, 0x3e	; 62
    77b0:	3c 97       	sbiw	r30, 0x0c	; 12
    77b2:	0f b6       	in	r0, 0x3f	; 63
    77b4:	f8 94       	cli
    77b6:	fe bf       	out	0x3e, r31	; 62
    77b8:	0f be       	out	0x3f, r0	; 63
    77ba:	ed bf       	out	0x3d, r30	; 61
    77bc:	0d b7       	in	r16, 0x3d	; 61
    77be:	1e b7       	in	r17, 0x3e	; 62
    77c0:	0f 5f       	subi	r16, 0xFF	; 255
    77c2:	1f 4f       	sbci	r17, 0xFF	; 255
    77c4:	32 83       	std	Z+2, r19	; 0x02
    77c6:	21 83       	std	Z+1, r18	; 0x01
    77c8:	8f e7       	ldi	r24, 0x7F	; 127
    77ca:	94 e0       	ldi	r25, 0x04	; 4
    77cc:	f8 01       	movw	r30, r16
    77ce:	93 83       	std	Z+3, r25	; 0x03
    77d0:	82 83       	std	Z+2, r24	; 0x02
    77d2:	75 83       	std	Z+5, r23	; 0x05
    77d4:	64 83       	std	Z+4, r22	; 0x04
    77d6:	d7 82       	std	Z+7, r13	; 0x07
    77d8:	c6 82       	std	Z+6, r12	; 0x06
    77da:	b1 87       	std	Z+9, r27	; 0x09
    77dc:	a0 87       	std	Z+8, r26	; 0x08
    77de:	53 87       	std	Z+11, r21	; 0x0b
    77e0:	42 87       	std	Z+10, r20	; 0x0a
    77e2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    77e6:	8d b7       	in	r24, 0x3d	; 61
    77e8:	9e b7       	in	r25, 0x3e	; 62
    77ea:	0c 96       	adiw	r24, 0x0c	; 12
    77ec:	0f b6       	in	r0, 0x3f	; 63
    77ee:	f8 94       	cli
    77f0:	9e bf       	out	0x3e, r25	; 62
    77f2:	0f be       	out	0x3f, r0	; 63
    77f4:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    77f6:	ce 01       	movw	r24, r28
    77f8:	8b 55       	subi	r24, 0x5B	; 91
    77fa:	9f 4f       	sbci	r25, 0xFF	; 255
    77fc:	66 ef       	ldi	r22, 0xF6	; 246
    77fe:	75 e0       	ldi	r23, 0x05	; 5
    7800:	4d e1       	ldi	r20, 0x1D	; 29
    7802:	52 e0       	ldi	r21, 0x02	; 2
    7804:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    7808:	e3 94       	inc	r14
    780a:	ef e1       	ldi	r30, 0x1F	; 31
    780c:	f2 e0       	ldi	r31, 0x02	; 2
    780e:	01 90       	ld	r0, Z+
    7810:	00 20       	and	r0, r0
    7812:	e9 f7       	brne	.-6      	; 0x780e <systemGenerateReport+0x154a>
    7814:	31 97       	sbiw	r30, 0x01	; 1
    7816:	ef 51       	subi	r30, 0x1F	; 31
    7818:	f2 40       	sbci	r31, 0x02	; 2
    781a:	ae 2c       	mov	r10, r14
    781c:	bb 24       	eor	r11, r11
    781e:	ae 16       	cp	r10, r30
    7820:	bf 06       	cpc	r11, r31
    7822:	08 f4       	brcc	.+2      	; 0x7826 <systemGenerateReport+0x1562>
    7824:	0f ce       	rjmp	.-994    	; 0x7444 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7826:	87 e0       	ldi	r24, 0x07	; 7
    7828:	66 ef       	ldi	r22, 0xF6	; 246
    782a:	75 e0       	ldi	r23, 0x05	; 5
    782c:	41 e0       	ldi	r20, 0x01	; 1
    782e:	2d e1       	ldi	r18, 0x1D	; 29
    7830:	32 e0       	ldi	r19, 0x02	; 2
    7832:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7836:	8b e0       	ldi	r24, 0x0B	; 11
    7838:	66 ef       	ldi	r22, 0xF6	; 246
    783a:	75 e0       	ldi	r23, 0x05	; 5
    783c:	4a e2       	ldi	r20, 0x2A	; 42
    783e:	2d e1       	ldi	r18, 0x1D	; 29
    7840:	32 e0       	ldi	r19, 0x02	; 2
    7842:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7846:	89 e0       	ldi	r24, 0x09	; 9
    7848:	66 ef       	ldi	r22, 0xF6	; 246
    784a:	75 e0       	ldi	r23, 0x05	; 5
    784c:	41 e0       	ldi	r20, 0x01	; 1
    784e:	2d e1       	ldi	r18, 0x1D	; 29
    7850:	32 e0       	ldi	r19, 0x02	; 2
    7852:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7856:	8c e0       	ldi	r24, 0x0C	; 12
    7858:	66 ef       	ldi	r22, 0xF6	; 246
    785a:	75 e0       	ldi	r23, 0x05	; 5
    785c:	41 e0       	ldi	r20, 0x01	; 1
    785e:	2d e1       	ldi	r18, 0x1D	; 29
    7860:	32 e0       	ldi	r19, 0x02	; 2
    7862:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7866:	8c e0       	ldi	r24, 0x0C	; 12
    7868:	66 ef       	ldi	r22, 0xF6	; 246
    786a:	75 e0       	ldi	r23, 0x05	; 5
    786c:	41 e0       	ldi	r20, 0x01	; 1
    786e:	2d e1       	ldi	r18, 0x1D	; 29
    7870:	32 e0       	ldi	r19, 0x02	; 2
    7872:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7876:	8c e0       	ldi	r24, 0x0C	; 12
    7878:	66 ef       	ldi	r22, 0xF6	; 246
    787a:	75 e0       	ldi	r23, 0x05	; 5
    787c:	41 e0       	ldi	r20, 0x01	; 1
    787e:	2d e1       	ldi	r18, 0x1D	; 29
    7880:	32 e0       	ldi	r19, 0x02	; 2
    7882:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7886:	8c e0       	ldi	r24, 0x0C	; 12
    7888:	66 ef       	ldi	r22, 0xF6	; 246
    788a:	75 e0       	ldi	r23, 0x05	; 5
    788c:	41 e0       	ldi	r20, 0x01	; 1
    788e:	2d e1       	ldi	r18, 0x1D	; 29
    7890:	32 e0       	ldi	r19, 0x02	; 2
    7892:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    7896:	8c e0       	ldi	r24, 0x0C	; 12
    7898:	66 ef       	ldi	r22, 0xF6	; 246
    789a:	75 e0       	ldi	r23, 0x05	; 5
    789c:	41 e0       	ldi	r20, 0x01	; 1
    789e:	2d e1       	ldi	r18, 0x1D	; 29
    78a0:	32 e0       	ldi	r19, 0x02	; 2
    78a2:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>
    78a6:	8c e0       	ldi	r24, 0x0C	; 12
    78a8:	66 ef       	ldi	r22, 0xF6	; 246
    78aa:	75 e0       	ldi	r23, 0x05	; 5
    78ac:	41 e0       	ldi	r20, 0x01	; 1
    78ae:	2d e1       	ldi	r18, 0x1D	; 29
    78b0:	32 e0       	ldi	r19, 0x02	; 2
    78b2:	0e 94 94 19 	call	0x3328	; 0x3328 <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    78b6:	80 e3       	ldi	r24, 0x30	; 48
    78b8:	80 93 e1 01 	sts	0x01E1, r24
		  LengthMessage81=RepPos+1;
    78bc:	80 91 1d 02 	lds	r24, 0x021D
    78c0:	90 91 1e 02 	lds	r25, 0x021E
    78c4:	01 96       	adiw	r24, 0x01	; 1
    78c6:	90 93 b6 01 	sts	0x01B6, r25
    78ca:	80 93 b5 01 	sts	0x01B5, r24
		  IsFreePrinting=True;
    78ce:	81 e0       	ldi	r24, 0x01	; 1
    78d0:	80 93 d5 01 	sts	0x01D5, r24
	      IsBusyFreePrinting=True; 
    78d4:	80 93 df 01 	sts	0x01DF, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    78d8:	8b e0       	ldi	r24, 0x0B	; 11
    78da:	05 c0       	rjmp	.+10     	; 0x78e6 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    78dc:	80 91 df 01 	lds	r24, 0x01DF
    78e0:	88 23       	and	r24, r24
    78e2:	49 f4       	brne	.+18     	; 0x78f6 <systemGenerateReport+0x1632>
    78e4:	8c e0       	ldi	r24, 0x0C	; 12
    78e6:	80 93 2f 02 	sts	0x022F, r24
    78ea:	05 c0       	rjmp	.+10     	; 0x78f6 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    78ec:	81 e0       	ldi	r24, 0x01	; 1
    78ee:	80 93 b0 01 	sts	0x01B0, r24
          stGenerateReport=grScanAction;
    78f2:	10 92 2f 02 	sts	0x022F, r1
	      break;
	 }
}
    78f6:	c8 50       	subi	r28, 0x08	; 8
    78f8:	df 4f       	sbci	r29, 0xFF	; 255
    78fa:	0f b6       	in	r0, 0x3f	; 63
    78fc:	f8 94       	cli
    78fe:	de bf       	out	0x3e, r29	; 62
    7900:	0f be       	out	0x3f, r0	; 63
    7902:	cd bf       	out	0x3d, r28	; 61
    7904:	cf 91       	pop	r28
    7906:	df 91       	pop	r29
    7908:	1f 91       	pop	r17
    790a:	0f 91       	pop	r16
    790c:	ff 90       	pop	r15
    790e:	ef 90       	pop	r14
    7910:	df 90       	pop	r13
    7912:	cf 90       	pop	r12
    7914:	bf 90       	pop	r11
    7916:	af 90       	pop	r10
    7918:	9f 90       	pop	r9
    791a:	8f 90       	pop	r8
    791c:	7f 90       	pop	r7
    791e:	6f 90       	pop	r6
    7920:	5f 90       	pop	r5
    7922:	4f 90       	pop	r4
    7924:	3f 90       	pop	r3
    7926:	2f 90       	pop	r2
    7928:	08 95       	ret

0000792a <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    792a:	cf 93       	push	r28
    792c:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    792e:	e7 e5       	ldi	r30, 0x57	; 87
    7930:	fe e0       	ldi	r31, 0x0E	; 14
    7932:	01 90       	ld	r0, Z+
    7934:	00 20       	and	r0, r0
    7936:	e9 f7       	brne	.-6      	; 0x7932 <UpdateCardID+0x8>
    7938:	31 97       	sbiw	r30, 0x01	; 1
    793a:	e7 55       	subi	r30, 0x57	; 87
    793c:	fe 40       	sbci	r31, 0x0E	; 14
    793e:	ac e8       	ldi	r26, 0x8C	; 140
    7940:	bd e0       	ldi	r27, 0x0D	; 13
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    7942:	f0 e0       	ldi	r31, 0x00	; 0
    7944:	ef 01       	movw	r28, r30
    7946:	cd 5b       	subi	r28, 0xBD	; 189
    7948:	d1 4f       	sbci	r29, 0xF1	; 241
    794a:	20 e0       	ldi	r18, 0x00	; 0
    794c:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    794e:	44 e1       	ldi	r20, 0x14	; 20
    7950:	50 e0       	ldi	r21, 0x00	; 0
    7952:	4e 1b       	sub	r20, r30
    7954:	5f 0b       	sbc	r21, r31
    7956:	90 e2       	ldi	r25, 0x20	; 32
    7958:	24 17       	cp	r18, r20
    795a:	35 07       	cpc	r19, r21
    795c:	14 f4       	brge	.+4      	; 0x7962 <UpdateCardID+0x38>
    795e:	9c 93       	st	X, r25
    7960:	02 c0       	rjmp	.+4      	; 0x7966 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    7962:	88 81       	ld	r24, Y
    7964:	8c 93       	st	X, r24
    7966:	2f 5f       	subi	r18, 0xFF	; 255
    7968:	3f 4f       	sbci	r19, 0xFF	; 255
    796a:	11 96       	adiw	r26, 0x01	; 1
    796c:	21 96       	adiw	r28, 0x01	; 1


void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    796e:	24 31       	cpi	r18, 0x14	; 20
    7970:	31 05       	cpc	r19, r1
    7972:	91 f7       	brne	.-28     	; 0x7958 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    7974:	10 92 a0 0d 	sts	0x0DA0, r1

}
    7978:	df 91       	pop	r29
    797a:	cf 91       	pop	r28
    797c:	08 95       	ret

0000797e <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    797e:	8f 92       	push	r8
    7980:	9f 92       	push	r9
    7982:	af 92       	push	r10
    7984:	bf 92       	push	r11
    7986:	cf 92       	push	r12
    7988:	df 92       	push	r13
    798a:	ef 92       	push	r14
    798c:	ff 92       	push	r15
    798e:	0f 93       	push	r16
    7990:	1f 93       	push	r17
    7992:	df 93       	push	r29
    7994:	cf 93       	push	r28
    7996:	cd b7       	in	r28, 0x3d	; 61
    7998:	de b7       	in	r29, 0x3e	; 62
    799a:	a7 97       	sbiw	r28, 0x27	; 39
    799c:	0f b6       	in	r0, 0x3f	; 63
    799e:	f8 94       	cli
    79a0:	de bf       	out	0x3e, r29	; 62
    79a2:	0f be       	out	0x3f, r0	; 63
    79a4:	cd bf       	out	0x3d, r28	; 61
    79a6:	79 01       	movw	r14, r18
    79a8:	48 01       	movw	r8, r16
    79aa:	e6 2f       	mov	r30, r22
    79ac:	f0 e0       	ldi	r31, 0x00	; 0
    79ae:	31 97       	sbiw	r30, 0x01	; 1
    79b0:	e8 0f       	add	r30, r24
    79b2:	f9 1f       	adc	r31, r25
    79b4:	9e 01       	movw	r18, r28
    79b6:	26 5f       	subi	r18, 0xF6	; 246
    79b8:	3f 4f       	sbci	r19, 0xFF	; 255
    79ba:	d9 01       	movw	r26, r18
    79bc:	03 c0       	rjmp	.+6      	; 0x79c4 <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    79be:	80 81       	ld	r24, Z
    79c0:	8d 93       	st	X+, r24
    79c2:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    79c4:	8a 2f       	mov	r24, r26
    79c6:	82 1b       	sub	r24, r18
    79c8:	86 17       	cp	r24, r22
    79ca:	c8 f3       	brcs	.-14     	; 0x79be <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    79cc:	c6 2e       	mov	r12, r22
    79ce:	dd 24       	eor	r13, r13
    79d0:	ea e0       	ldi	r30, 0x0A	; 10
    79d2:	ae 2e       	mov	r10, r30
    79d4:	b1 2c       	mov	r11, r1
    79d6:	ac 0e       	add	r10, r28
    79d8:	bd 1e       	adc	r11, r29
    79da:	f5 01       	movw	r30, r10
    79dc:	ec 0d       	add	r30, r12
    79de:	fd 1d       	adc	r31, r13
    79e0:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    79e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    79e4:	fa 01       	movw	r30, r20
    79e6:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    79e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    79ea:	89 83       	std	Y+1, r24	; 0x01
    79ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    79ee:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    79f0:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    79f2:	ce 01       	movw	r24, r28
    79f4:	01 96       	adiw	r24, 0x01	; 1
    79f6:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
	 *GPumpID=xPumpID;
    79fa:	f7 01       	movw	r30, r14
    79fc:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    79fe:	00 d0       	rcall	.+0      	; 0x7a00 <GetParameter+0x82>
    7a00:	00 d0       	rcall	.+0      	; 0x7a02 <GetParameter+0x84>
    7a02:	77 e0       	ldi	r23, 0x07	; 7
    7a04:	e7 2e       	mov	r14, r23
    7a06:	f1 2c       	mov	r15, r1
    7a08:	ec 0e       	add	r14, r28
    7a0a:	fd 1e       	adc	r15, r29
    7a0c:	ed b7       	in	r30, 0x3d	; 61
    7a0e:	fe b7       	in	r31, 0x3e	; 62
    7a10:	f2 82       	std	Z+2, r15	; 0x02
    7a12:	e1 82       	std	Z+1, r14	; 0x01
    7a14:	89 ef       	ldi	r24, 0xF9	; 249
    7a16:	93 e0       	ldi	r25, 0x03	; 3
    7a18:	94 83       	std	Z+4, r25	; 0x04
    7a1a:	83 83       	std	Z+3, r24	; 0x03
    7a1c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    7a20:	0f 90       	pop	r0
    7a22:	0f 90       	pop	r0
    7a24:	0f 90       	pop	r0
    7a26:	0f 90       	pop	r0
    7a28:	c7 01       	movw	r24, r14
    7a2a:	b5 01       	movw	r22, r10
    7a2c:	0e 94 56 1f 	call	0x3eac	; 0x3eac <Pos>
    7a30:	8c 15       	cp	r24, r12
    7a32:	9d 05       	cpc	r25, r13
    7a34:	4c f5       	brge	.+82     	; 0x7a88 <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    7a36:	c7 01       	movw	r24, r14
    7a38:	b5 01       	movw	r22, r10
    7a3a:	0e 94 56 1f 	call	0x3eac	; 0x3eac <Pos>
    7a3e:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    7a40:	c7 01       	movw	r24, r14
    7a42:	b5 01       	movw	r22, r10
    7a44:	0e 94 56 1f 	call	0x3eac	; 0x3eac <Pos>
    7a48:	a6 01       	movw	r20, r12
    7a4a:	40 1b       	sub	r20, r16
    7a4c:	51 0b       	sbc	r21, r17
    7a4e:	d5 01       	movw	r26, r10
    7a50:	a8 0f       	add	r26, r24
    7a52:	b9 1f       	adc	r27, r25
    7a54:	20 e0       	ldi	r18, 0x00	; 0
    7a56:	30 e0       	ldi	r19, 0x00	; 0
    7a58:	be 01       	movw	r22, r28
    7a5a:	6c 5f       	subi	r22, 0xFC	; 252
    7a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    7a5e:	07 c0       	rjmp	.+14     	; 0x7a6e <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7a60:	fb 01       	movw	r30, r22
    7a62:	e2 0f       	add	r30, r18
    7a64:	f3 1f       	adc	r31, r19
    7a66:	8c 91       	ld	r24, X
    7a68:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7a6a:	2f 5f       	subi	r18, 0xFF	; 255
    7a6c:	3f 4f       	sbci	r19, 0xFF	; 255
    7a6e:	11 96       	adiw	r26, 0x01	; 1
    7a70:	24 17       	cp	r18, r20
    7a72:	35 07       	cpc	r19, r21
    7a74:	a8 f3       	brcs	.-22     	; 0x7a60 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7a76:	46 0f       	add	r20, r22
    7a78:	57 1f       	adc	r21, r23
    7a7a:	fa 01       	movw	r30, r20
    7a7c:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    7a7e:	cb 01       	movw	r24, r22
    7a80:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
	     *GeniCSum=xCsum;
    7a84:	f4 01       	movw	r30, r8
    7a86:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 _uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}
    7a88:	a7 96       	adiw	r28, 0x27	; 39
    7a8a:	0f b6       	in	r0, 0x3f	; 63
    7a8c:	f8 94       	cli
    7a8e:	de bf       	out	0x3e, r29	; 62
    7a90:	0f be       	out	0x3f, r0	; 63
    7a92:	cd bf       	out	0x3d, r28	; 61
    7a94:	cf 91       	pop	r28
    7a96:	df 91       	pop	r29
    7a98:	1f 91       	pop	r17
    7a9a:	0f 91       	pop	r16
    7a9c:	ff 90       	pop	r15
    7a9e:	ef 90       	pop	r14
    7aa0:	df 90       	pop	r13
    7aa2:	cf 90       	pop	r12
    7aa4:	bf 90       	pop	r11
    7aa6:	af 90       	pop	r10
    7aa8:	9f 90       	pop	r9
    7aaa:	8f 90       	pop	r8
    7aac:	08 95       	ret

00007aae <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    7aae:	ff 92       	push	r15
    7ab0:	0f 93       	push	r16
    7ab2:	1f 93       	push	r17
    7ab4:	df 93       	push	r29
    7ab6:	cf 93       	push	r28
    7ab8:	cd b7       	in	r28, 0x3d	; 61
    7aba:	de b7       	in	r29, 0x3e	; 62
    7abc:	67 97       	sbiw	r28, 0x17	; 23
    7abe:	0f b6       	in	r0, 0x3f	; 63
    7ac0:	f8 94       	cli
    7ac2:	de bf       	out	0x3e, r29	; 62
    7ac4:	0f be       	out	0x3f, r0	; 63
    7ac6:	cd bf       	out	0x3d, r28	; 61
    7ac8:	f8 2e       	mov	r15, r24
	 char sCmd[7],i,GeniCmd,GeniPumpID,GeniCSum;
	 char strSend[20];

    //_uart(1,1,dataIn);

	if (dataIn==0x0D){	
    7aca:	8d e0       	ldi	r24, 0x0D	; 13
    7acc:	f8 16       	cp	r15, r24
    7ace:	09 f0       	breq	.+2      	; 0x7ad2 <GeniusProtocol+0x24>
    7ad0:	45 c0       	rjmp	.+138    	; 0x7b5c <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    7ad2:	8a ef       	ldi	r24, 0xFA	; 250
    7ad4:	91 e0       	ldi	r25, 0x01	; 1
    7ad6:	60 91 f9 01 	lds	r22, 0x01F9
    7ada:	ae 01       	movw	r20, r28
    7adc:	4f 5f       	subi	r20, 0xFF	; 255
    7ade:	5f 4f       	sbci	r21, 0xFF	; 255
    7ae0:	9e 01       	movw	r18, r28
    7ae2:	2e 5f       	subi	r18, 0xFE	; 254
    7ae4:	3f 4f       	sbci	r19, 0xFF	; 255
    7ae6:	8e 01       	movw	r16, r28
    7ae8:	0d 5f       	subi	r16, 0xFD	; 253
    7aea:	1f 4f       	sbci	r17, 0xFF	; 255
    7aec:	0e 94 bf 3c 	call	0x797e	; 0x797e <GetParameter>
		FlowLength=0;
    7af0:	10 92 f9 01 	sts	0x01F9, r1
		IsGeniusFlow=False;
    7af4:	10 92 f8 01 	sts	0x01F8, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    7af8:	ad b7       	in	r26, 0x3d	; 61
    7afa:	be b7       	in	r27, 0x3e	; 62
    7afc:	18 97       	sbiw	r26, 0x08	; 8
    7afe:	0f b6       	in	r0, 0x3f	; 63
    7b00:	f8 94       	cli
    7b02:	be bf       	out	0x3e, r27	; 62
    7b04:	0f be       	out	0x3f, r0	; 63
    7b06:	ad bf       	out	0x3d, r26	; 61
    7b08:	ed b7       	in	r30, 0x3d	; 61
    7b0a:	fe b7       	in	r31, 0x3e	; 62
    7b0c:	31 96       	adiw	r30, 0x01	; 1
    7b0e:	8e 01       	movw	r16, r28
    7b10:	0c 5f       	subi	r16, 0xFC	; 252
    7b12:	1f 4f       	sbci	r17, 0xFF	; 255
    7b14:	12 96       	adiw	r26, 0x02	; 2
    7b16:	1c 93       	st	X, r17
    7b18:	0e 93       	st	-X, r16
    7b1a:	11 97       	sbiw	r26, 0x01	; 1
    7b1c:	8b ee       	ldi	r24, 0xEB	; 235
    7b1e:	93 e0       	ldi	r25, 0x03	; 3
    7b20:	93 83       	std	Z+3, r25	; 0x03
    7b22:	82 83       	std	Z+2, r24	; 0x02
    7b24:	89 81       	ldd	r24, Y+1	; 0x01
    7b26:	84 83       	std	Z+4, r24	; 0x04
    7b28:	15 82       	std	Z+5, r1	; 0x05
    7b2a:	8a 81       	ldd	r24, Y+2	; 0x02
    7b2c:	86 83       	std	Z+6, r24	; 0x06
    7b2e:	17 82       	std	Z+7, r1	; 0x07
    7b30:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		//_uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    7b34:	8d b7       	in	r24, 0x3d	; 61
    7b36:	9e b7       	in	r25, 0x3e	; 62
    7b38:	08 96       	adiw	r24, 0x08	; 8
    7b3a:	0f b6       	in	r0, 0x3f	; 63
    7b3c:	f8 94       	cli
    7b3e:	9e bf       	out	0x3e, r25	; 62
    7b40:	0f be       	out	0x3f, r0	; 63
    7b42:	8d bf       	out	0x3d, r24	; 61
    7b44:	c8 01       	movw	r24, r16
    7b46:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <SumChecksum>
    7b4a:	9b 81       	ldd	r25, Y+3	; 0x03
    7b4c:	89 17       	cp	r24, r25
    7b4e:	31 f4       	brne	.+12     	; 0x7b5c <GeniusProtocol+0xae>
		     switch(GeniCmd){
    7b50:	89 81       	ldd	r24, Y+1	; 0x01
    7b52:	84 35       	cpi	r24, 0x54	; 84
    7b54:	19 f4       	brne	.+6      	; 0x7b5c <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    7b56:	8a 81       	ldd	r24, Y+2	; 0x02
    7b58:	0e 94 06 2b 	call	0x560c	; 0x560c <GeniusSendLastTransaction>
    7b5c:	ec e0       	ldi	r30, 0x0C	; 12
    7b5e:	f2 e0       	ldi	r31, 0x02	; 2
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    7b60:	80 81       	ld	r24, Z
    7b62:	81 83       	std	Z+1, r24	; 0x01
    7b64:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    7b66:	91 e0       	ldi	r25, 0x01	; 1
    7b68:	e9 3f       	cpi	r30, 0xF9	; 249
    7b6a:	f9 07       	cpc	r31, r25
    7b6c:	c9 f7       	brne	.-14     	; 0x7b60 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    7b6e:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    7b70:	8f 2d       	mov	r24, r15
    7b72:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <IsGeniusCommand>
    7b76:	81 30       	cpi	r24, 0x01	; 1
    7b78:	11 f4       	brne	.+4      	; 0x7b7e <GeniusProtocol+0xd0>
    7b7a:	80 93 f8 01 	sts	0x01F8, r24
	if (IsGeniusFlow==True)FlowLength++;
    7b7e:	80 91 f8 01 	lds	r24, 0x01F8
    7b82:	81 30       	cpi	r24, 0x01	; 1
    7b84:	29 f4       	brne	.+10     	; 0x7b90 <GeniusProtocol+0xe2>
    7b86:	80 91 f9 01 	lds	r24, 0x01F9
    7b8a:	8f 5f       	subi	r24, 0xFF	; 255
    7b8c:	80 93 f9 01 	sts	0x01F9, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    7b90:	67 96       	adiw	r28, 0x17	; 23
    7b92:	0f b6       	in	r0, 0x3f	; 63
    7b94:	f8 94       	cli
    7b96:	de bf       	out	0x3e, r29	; 62
    7b98:	0f be       	out	0x3f, r0	; 63
    7b9a:	cd bf       	out	0x3d, r28	; 61
    7b9c:	cf 91       	pop	r28
    7b9e:	df 91       	pop	r29
    7ba0:	1f 91       	pop	r17
    7ba2:	0f 91       	pop	r16
    7ba4:	ff 90       	pop	r15
    7ba6:	08 95       	ret

00007ba8 <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    7ba8:	1f 92       	push	r1
    7baa:	0f 92       	push	r0
    7bac:	0f b6       	in	r0, 0x3f	; 63
    7bae:	0f 92       	push	r0
    7bb0:	0b b6       	in	r0, 0x3b	; 59
    7bb2:	0f 92       	push	r0
    7bb4:	11 24       	eor	r1, r1
    7bb6:	0f 93       	push	r16
    7bb8:	1f 93       	push	r17
    7bba:	2f 93       	push	r18
    7bbc:	3f 93       	push	r19
    7bbe:	4f 93       	push	r20
    7bc0:	5f 93       	push	r21
    7bc2:	6f 93       	push	r22
    7bc4:	7f 93       	push	r23
    7bc6:	8f 93       	push	r24
    7bc8:	9f 93       	push	r25
    7bca:	af 93       	push	r26
    7bcc:	bf 93       	push	r27
    7bce:	ef 93       	push	r30
    7bd0:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsNewPacket=False,IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    7bd2:	00 91 9c 00 	lds	r16, 0x009C

	//NewPacket
	if (IsNewPacket==True){
    7bd6:	80 91 bf 03 	lds	r24, 0x03BF
    7bda:	81 30       	cpi	r24, 0x01	; 1
    7bdc:	51 f4       	brne	.+20     	; 0x7bf2 <__vector_30+0x4a>
	    if (dataTX1==0x01){
    7bde:	01 30       	cpi	r16, 0x01	; 1
    7be0:	41 f4       	brne	.+16     	; 0x7bf2 <__vector_30+0x4a>
		    char_count=0;
    7be2:	10 92 b2 01 	sts	0x01B2, r1
    7be6:	10 92 b1 01 	sts	0x01B1, r1
            IsNewPacket=False;
    7bea:	10 92 bf 03 	sts	0x03BF, r1
			IsAdvanZProtocol=True;
    7bee:	00 93 be 03 	sts	0x03BE, r16
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    7bf2:	80 91 be 03 	lds	r24, 0x03BE
    7bf6:	81 30       	cpi	r24, 0x01	; 1
    7bf8:	69 f4       	brne	.+26     	; 0x7c14 <__vector_30+0x6c>
	    rcv_trans[char_count]=dataTX1;
    7bfa:	80 91 b1 01 	lds	r24, 0x01B1
    7bfe:	90 91 b2 01 	lds	r25, 0x01B2
    7c02:	fc 01       	movw	r30, r24
    7c04:	e0 5e       	subi	r30, 0xE0	; 224
    7c06:	f4 4f       	sbci	r31, 0xF4	; 244
    7c08:	00 83       	st	Z, r16
	    char_count++; 
    7c0a:	01 96       	adiw	r24, 0x01	; 1
    7c0c:	90 93 b2 01 	sts	0x01B2, r25
    7c10:	80 93 b1 01 	sts	0x01B1, r24
	}

	if (dataTX1==0x02){
    7c14:	02 30       	cpi	r16, 0x02	; 2
    7c16:	b1 f5       	brne	.+108    	; 0x7c84 <__vector_30+0xdc>
		transLength=char_count;
    7c18:	60 91 b1 01 	lds	r22, 0x01B1
    7c1c:	70 91 b2 01 	lds	r23, 0x01B2
    7c20:	70 93 b4 01 	sts	0x01B4, r23
    7c24:	60 93 b3 01 	sts	0x01B3, r22
		char_count=0;
    7c28:	10 92 b2 01 	sts	0x01B2, r1
    7c2c:	10 92 b1 01 	sts	0x01B1, r1
		IsAdvanZProtocol=False;
    7c30:	10 92 be 03 	sts	0x03BE, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    7c34:	20 91 44 0b 	lds	r18, 0x0B44
    7c38:	20 51       	subi	r18, 0x10	; 16
    7c3a:	80 91 43 0b 	lds	r24, 0x0B43
    7c3e:	3a e0       	ldi	r19, 0x0A	; 10
    7c40:	83 9f       	mul	r24, r19
    7c42:	c0 01       	movw	r24, r0
    7c44:	11 24       	eor	r1, r1
    7c46:	28 0f       	add	r18, r24
    7c48:	20 93 39 01 	sts	0x0139, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    7c4c:	80 91 20 0b 	lds	r24, 0x0B20
    7c50:	0e 94 06 18 	call	0x300c	; 0x300c <IdentifyMessage>
		IsNewPacket=True;
    7c54:	21 e0       	ldi	r18, 0x01	; 1
    7c56:	20 93 bf 03 	sts	0x03BF, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    7c5a:	80 91 43 0b 	lds	r24, 0x0B43
    7c5e:	88 33       	cpi	r24, 0x38	; 56
    7c60:	89 f4       	brne	.+34     	; 0x7c84 <__vector_30+0xdc>
    7c62:	80 91 44 0b 	lds	r24, 0x0B44
    7c66:	81 33       	cpi	r24, 0x31	; 49
    7c68:	69 f4       	brne	.+26     	; 0x7c84 <__vector_30+0xdc>
		   LengthMessage81=transLength-12-44;
    7c6a:	80 91 b3 01 	lds	r24, 0x01B3
    7c6e:	90 91 b4 01 	lds	r25, 0x01B4
    7c72:	c8 97       	sbiw	r24, 0x38	; 56
    7c74:	90 93 b6 01 	sts	0x01B6, r25
    7c78:	80 93 b5 01 	sts	0x01B5, r24
		   IsMessage81=True;
    7c7c:	20 93 d3 01 	sts	0x01D3, r18
		   IsCompleteFilling=True;
    7c80:	20 93 d6 01 	sts	0x01D6, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)ConfigProtocol(dataTX1);
    7c84:	10 91 bf 03 	lds	r17, 0x03BF
    7c88:	11 30       	cpi	r17, 0x01	; 1
    7c8a:	19 f0       	breq	.+6      	; 0x7c92 <__vector_30+0xea>
    7c8c:	80 2f       	mov	r24, r16
    7c8e:	0e 94 fe 13 	call	0x27fc	; 0x27fc <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))GeniusProtocol(dataTX1);
    7c92:	80 91 25 01 	lds	r24, 0x0125
    7c96:	82 30       	cpi	r24, 0x02	; 2
    7c98:	29 f4       	brne	.+10     	; 0x7ca4 <__vector_30+0xfc>
    7c9a:	11 30       	cpi	r17, 0x01	; 1
    7c9c:	19 f0       	breq	.+6      	; 0x7ca4 <__vector_30+0xfc>
    7c9e:	80 2f       	mov	r24, r16
    7ca0:	0e 94 57 3d 	call	0x7aae	; 0x7aae <GeniusProtocol>
    //_uart(0,1,dataTX1);



	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}
    7ca4:	ff 91       	pop	r31
    7ca6:	ef 91       	pop	r30
    7ca8:	bf 91       	pop	r27
    7caa:	af 91       	pop	r26
    7cac:	9f 91       	pop	r25
    7cae:	8f 91       	pop	r24
    7cb0:	7f 91       	pop	r23
    7cb2:	6f 91       	pop	r22
    7cb4:	5f 91       	pop	r21
    7cb6:	4f 91       	pop	r20
    7cb8:	3f 91       	pop	r19
    7cba:	2f 91       	pop	r18
    7cbc:	1f 91       	pop	r17
    7cbe:	0f 91       	pop	r16
    7cc0:	0f 90       	pop	r0
    7cc2:	0b be       	out	0x3b, r0	; 59
    7cc4:	0f 90       	pop	r0
    7cc6:	0f be       	out	0x3f, r0	; 63
    7cc8:	0f 90       	pop	r0
    7cca:	1f 90       	pop	r1
    7ccc:	18 95       	reti

00007cce <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    7cce:	0f 93       	push	r16
    7cd0:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    7cd2:	80 91 20 0b 	lds	r24, 0x0B20
    7cd6:	81 30       	cpi	r24, 0x01	; 1
    7cd8:	09 f0       	breq	.+2      	; 0x7cdc <procMessage99+0xe>
    7cda:	2e c2       	rjmp	.+1116   	; 0x8138 <procMessage99+0x46a>
    7cdc:	80 91 b3 01 	lds	r24, 0x01B3
    7ce0:	90 91 b4 01 	lds	r25, 0x01B4
    7ce4:	8a 57       	subi	r24, 0x7A	; 122
    7ce6:	91 40       	sbci	r25, 0x01	; 1
    7ce8:	08 f4       	brcc	.+2      	; 0x7cec <procMessage99+0x1e>
    7cea:	26 c2       	rjmp	.+1100   	; 0x8138 <procMessage99+0x46a>
    7cec:	20 e0       	ldi	r18, 0x00	; 0
    7cee:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7cf0:	f9 01       	movw	r30, r18
    7cf2:	e3 57       	subi	r30, 0x73	; 115
    7cf4:	f1 4f       	sbci	r31, 0xF1	; 241
    7cf6:	d9 01       	movw	r26, r18
    7cf8:	a0 5e       	subi	r26, 0xE0	; 224
    7cfa:	b4 4f       	sbci	r27, 0xF4	; 244
    7cfc:	95 96       	adiw	r26, 0x25	; 37
    7cfe:	8c 91       	ld	r24, X
    7d00:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7d02:	2f 5f       	subi	r18, 0xFF	; 255
    7d04:	3f 4f       	sbci	r19, 0xFF	; 255
    7d06:	26 30       	cpi	r18, 0x06	; 6
    7d08:	31 05       	cpc	r19, r1
    7d0a:	91 f7       	brne	.-28     	; 0x7cf0 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7d0c:	10 92 93 0e 	sts	0x0E93, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d10:	80 91 4b 0b 	lds	r24, 0x0B4B
    7d14:	80 93 6e 0e 	sts	0x0E6E, r24
	 }Dest[Length]=0;
    7d18:	10 92 6f 0e 	sts	0x0E6F, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    7d1c:	80 53       	subi	r24, 0x30	; 48
    7d1e:	80 93 e6 01 	sts	0x01E6, r24
    7d22:	20 e0       	ldi	r18, 0x00	; 0
    7d24:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d26:	f9 01       	movw	r30, r18
    7d28:	e8 58       	subi	r30, 0x88	; 136
    7d2a:	f6 4f       	sbci	r31, 0xF6	; 246
    7d2c:	d9 01       	movw	r26, r18
    7d2e:	a0 5e       	subi	r26, 0xE0	; 224
    7d30:	b4 4f       	sbci	r27, 0xF4	; 244
    7d32:	9c 96       	adiw	r26, 0x2c	; 44
    7d34:	8c 91       	ld	r24, X
    7d36:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7d38:	2f 5f       	subi	r18, 0xFF	; 255
    7d3a:	3f 4f       	sbci	r19, 0xFF	; 255
    7d3c:	2a 30       	cpi	r18, 0x0A	; 10
    7d3e:	31 05       	cpc	r19, r1
    7d40:	91 f7       	brne	.-28     	; 0x7d26 <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7d42:	10 92 82 09 	sts	0x0982, r1
    7d46:	20 e0       	ldi	r18, 0x00	; 0
    7d48:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d4a:	f9 01       	movw	r30, r18
    7d4c:	ee 5a       	subi	r30, 0xAE	; 174
    7d4e:	fa 4f       	sbci	r31, 0xFA	; 250
    7d50:	d9 01       	movw	r26, r18
    7d52:	a0 5e       	subi	r26, 0xE0	; 224
    7d54:	b4 4f       	sbci	r27, 0xF4	; 244
    7d56:	d6 96       	adiw	r26, 0x36	; 54
    7d58:	8c 91       	ld	r24, X
    7d5a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7d5c:	2f 5f       	subi	r18, 0xFF	; 255
    7d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    7d60:	28 30       	cpi	r18, 0x08	; 8
    7d62:	31 05       	cpc	r19, r1
    7d64:	91 f7       	brne	.-28     	; 0x7d4a <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7d66:	10 92 5a 05 	sts	0x055A, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d6a:	80 91 5e 0b 	lds	r24, 0x0B5E
    7d6e:	80 93 fa 0a 	sts	0x0AFA, r24
    7d72:	80 91 5f 0b 	lds	r24, 0x0B5F
    7d76:	80 93 fb 0a 	sts	0x0AFB, r24
	 }Dest[Length]=0;
    7d7a:	10 92 fc 0a 	sts	0x0AFC, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d7e:	80 91 60 0b 	lds	r24, 0x0B60
    7d82:	80 93 c3 09 	sts	0x09C3, r24
    7d86:	80 91 61 0b 	lds	r24, 0x0B61
    7d8a:	80 93 c4 09 	sts	0x09C4, r24
	 }Dest[Length]=0;
    7d8e:	10 92 c5 09 	sts	0x09C5, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d92:	80 91 62 0b 	lds	r24, 0x0B62
    7d96:	80 93 a1 0a 	sts	0x0AA1, r24
    7d9a:	80 91 63 0b 	lds	r24, 0x0B63
    7d9e:	80 93 a2 0a 	sts	0x0AA2, r24
	 }Dest[Length]=0;
    7da2:	10 92 a3 0a 	sts	0x0AA3, r1
    7da6:	20 e0       	ldi	r18, 0x00	; 0
    7da8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7daa:	f9 01       	movw	r30, r18
    7dac:	e8 5c       	subi	r30, 0xC8	; 200
    7dae:	f5 4f       	sbci	r31, 0xF5	; 245
    7db0:	d9 01       	movw	r26, r18
    7db2:	ac 59       	subi	r26, 0x9C	; 156
    7db4:	b4 4f       	sbci	r27, 0xF4	; 244
    7db6:	8c 91       	ld	r24, X
    7db8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7dba:	2f 5f       	subi	r18, 0xFF	; 255
    7dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    7dbe:	2f 30       	cpi	r18, 0x0F	; 15
    7dc0:	31 05       	cpc	r19, r1
    7dc2:	99 f7       	brne	.-26     	; 0x7daa <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7dc4:	10 92 47 0a 	sts	0x0A47, r1
    7dc8:	20 e0       	ldi	r18, 0x00	; 0
    7dca:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7dcc:	f9 01       	movw	r30, r18
    7dce:	e8 55       	subi	r30, 0x58	; 88
    7dd0:	f8 4f       	sbci	r31, 0xF8	; 248
    7dd2:	d9 01       	movw	r26, r18
    7dd4:	ad 58       	subi	r26, 0x8D	; 141
    7dd6:	b4 4f       	sbci	r27, 0xF4	; 244
    7dd8:	8c 91       	ld	r24, X
    7dda:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7ddc:	2f 5f       	subi	r18, 0xFF	; 255
    7dde:	3f 4f       	sbci	r19, 0xFF	; 255
    7de0:	28 30       	cpi	r18, 0x08	; 8
    7de2:	31 05       	cpc	r19, r1
    7de4:	99 f7       	brne	.-26     	; 0x7dcc <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7de6:	10 92 b0 07 	sts	0x07B0, r1
    7dea:	20 e0       	ldi	r18, 0x00	; 0
    7dec:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7dee:	f9 01       	movw	r30, r18
    7df0:	e6 58       	subi	r30, 0x86	; 134
    7df2:	fa 4f       	sbci	r31, 0xFA	; 250
    7df4:	d9 01       	movw	r26, r18
    7df6:	a5 58       	subi	r26, 0x85	; 133
    7df8:	b4 4f       	sbci	r27, 0xF4	; 244
    7dfa:	8c 91       	ld	r24, X
    7dfc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7dfe:	2f 5f       	subi	r18, 0xFF	; 255
    7e00:	3f 4f       	sbci	r19, 0xFF	; 255
    7e02:	28 30       	cpi	r18, 0x08	; 8
    7e04:	31 05       	cpc	r19, r1
    7e06:	99 f7       	brne	.-26     	; 0x7dee <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e08:	10 92 82 05 	sts	0x0582, r1
    7e0c:	20 e0       	ldi	r18, 0x00	; 0
    7e0e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e10:	f9 01       	movw	r30, r18
    7e12:	ea 54       	subi	r30, 0x4A	; 74
    7e14:	f2 4f       	sbci	r31, 0xF2	; 242
    7e16:	d9 01       	movw	r26, r18
    7e18:	ad 57       	subi	r26, 0x7D	; 125
    7e1a:	b4 4f       	sbci	r27, 0xF4	; 244
    7e1c:	8c 91       	ld	r24, X
    7e1e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e20:	2f 5f       	subi	r18, 0xFF	; 255
    7e22:	3f 4f       	sbci	r19, 0xFF	; 255
    7e24:	2a 30       	cpi	r18, 0x0A	; 10
    7e26:	31 05       	cpc	r19, r1
    7e28:	99 f7       	brne	.-26     	; 0x7e10 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e2a:	10 92 c0 0d 	sts	0x0DC0, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    7e2e:	80 91 8d 0b 	lds	r24, 0x0B8D
    7e32:	80 53       	subi	r24, 0x30	; 48
    7e34:	80 93 e5 01 	sts	0x01E5, r24
    7e38:	20 e0       	ldi	r18, 0x00	; 0
    7e3a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e3c:	f9 01       	movw	r30, r18
    7e3e:	e9 57       	subi	r30, 0x79	; 121
    7e40:	f8 4f       	sbci	r31, 0xF8	; 248
    7e42:	d9 01       	movw	r26, r18
    7e44:	a2 57       	subi	r26, 0x72	; 114
    7e46:	b4 4f       	sbci	r27, 0xF4	; 244
    7e48:	8c 91       	ld	r24, X
    7e4a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e4c:	2f 5f       	subi	r18, 0xFF	; 255
    7e4e:	3f 4f       	sbci	r19, 0xFF	; 255
    7e50:	24 31       	cpi	r18, 0x14	; 20
    7e52:	31 05       	cpc	r19, r1
    7e54:	99 f7       	brne	.-26     	; 0x7e3c <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e56:	10 92 9b 07 	sts	0x079B, r1
    7e5a:	20 e0       	ldi	r18, 0x00	; 0
    7e5c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e5e:	f9 01       	movw	r30, r18
    7e60:	e4 57       	subi	r30, 0x74	; 116
    7e62:	f2 4f       	sbci	r31, 0xF2	; 242
    7e64:	d9 01       	movw	r26, r18
    7e66:	ae 55       	subi	r26, 0x5E	; 94
    7e68:	b4 4f       	sbci	r27, 0xF4	; 244
    7e6a:	8c 91       	ld	r24, X
    7e6c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e6e:	2f 5f       	subi	r18, 0xFF	; 255
    7e70:	3f 4f       	sbci	r19, 0xFF	; 255
    7e72:	24 31       	cpi	r18, 0x14	; 20
    7e74:	31 05       	cpc	r19, r1
    7e76:	99 f7       	brne	.-26     	; 0x7e5e <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e78:	10 92 a0 0d 	sts	0x0DA0, r1
    7e7c:	20 e0       	ldi	r18, 0x00	; 0
    7e7e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e80:	f9 01       	movw	r30, r18
    7e82:	e7 5d       	subi	r30, 0xD7	; 215
    7e84:	fa 4f       	sbci	r31, 0xFA	; 250
    7e86:	d9 01       	movw	r26, r18
    7e88:	aa 54       	subi	r26, 0x4A	; 74
    7e8a:	b4 4f       	sbci	r27, 0xF4	; 244
    7e8c:	8c 91       	ld	r24, X
    7e8e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e90:	2f 5f       	subi	r18, 0xFF	; 255
    7e92:	3f 4f       	sbci	r19, 0xFF	; 255
    7e94:	28 32       	cpi	r18, 0x28	; 40
    7e96:	31 05       	cpc	r19, r1
    7e98:	99 f7       	brne	.-26     	; 0x7e80 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e9a:	10 92 51 05 	sts	0x0551, r1
    7e9e:	20 e0       	ldi	r18, 0x00	; 0
    7ea0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ea2:	f9 01       	movw	r30, r18
    7ea4:	e0 5a       	subi	r30, 0xA0	; 160
    7ea6:	fa 4f       	sbci	r31, 0xFA	; 250
    7ea8:	d9 01       	movw	r26, r18
    7eaa:	a2 52       	subi	r26, 0x22	; 34
    7eac:	b4 4f       	sbci	r27, 0xF4	; 244
    7eae:	8c 91       	ld	r24, X
    7eb0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7eb2:	2f 5f       	subi	r18, 0xFF	; 255
    7eb4:	3f 4f       	sbci	r19, 0xFF	; 255
    7eb6:	29 31       	cpi	r18, 0x19	; 25
    7eb8:	31 05       	cpc	r19, r1
    7eba:	99 f7       	brne	.-26     	; 0x7ea2 <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7ebc:	10 92 79 05 	sts	0x0579, r1
    7ec0:	20 e0       	ldi	r18, 0x00	; 0
    7ec2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ec4:	f9 01       	movw	r30, r18
    7ec6:	e2 50       	subi	r30, 0x02	; 2
    7ec8:	f2 4f       	sbci	r31, 0xF2	; 242
    7eca:	d9 01       	movw	r26, r18
    7ecc:	a9 50       	subi	r26, 0x09	; 9
    7ece:	b4 4f       	sbci	r27, 0xF4	; 244
    7ed0:	8c 91       	ld	r24, X
    7ed2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7ed4:	2f 5f       	subi	r18, 0xFF	; 255
    7ed6:	3f 4f       	sbci	r19, 0xFF	; 255
    7ed8:	2d 30       	cpi	r18, 0x0D	; 13
    7eda:	31 05       	cpc	r19, r1
    7edc:	99 f7       	brne	.-26     	; 0x7ec4 <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7ede:	10 92 0b 0e 	sts	0x0E0B, r1
    7ee2:	20 e0       	ldi	r18, 0x00	; 0
    7ee4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ee6:	f9 01       	movw	r30, r18
    7ee8:	ef 56       	subi	r30, 0x6F	; 111
    7eea:	fa 4f       	sbci	r31, 0xFA	; 250
    7eec:	d9 01       	movw	r26, r18
    7eee:	ac 5f       	subi	r26, 0xFC	; 252
    7ef0:	b3 4f       	sbci	r27, 0xF3	; 243
    7ef2:	8c 91       	ld	r24, X
    7ef4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7ef6:	2f 5f       	subi	r18, 0xFF	; 255
    7ef8:	3f 4f       	sbci	r19, 0xFF	; 255
    7efa:	2d 30       	cpi	r18, 0x0D	; 13
    7efc:	31 05       	cpc	r19, r1
    7efe:	99 f7       	brne	.-26     	; 0x7ee6 <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f00:	10 92 9e 05 	sts	0x059E, r1
    7f04:	20 e0       	ldi	r18, 0x00	; 0
    7f06:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f08:	f9 01       	movw	r30, r18
    7f0a:	e4 51       	subi	r30, 0x14	; 20
    7f0c:	f5 4f       	sbci	r31, 0xF5	; 245
    7f0e:	d9 01       	movw	r26, r18
    7f10:	af 5e       	subi	r26, 0xEF	; 239
    7f12:	b3 4f       	sbci	r27, 0xF3	; 243
    7f14:	8c 91       	ld	r24, X
    7f16:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f18:	2f 5f       	subi	r18, 0xFF	; 255
    7f1a:	3f 4f       	sbci	r19, 0xFF	; 255
    7f1c:	2d 30       	cpi	r18, 0x0D	; 13
    7f1e:	31 05       	cpc	r19, r1
    7f20:	99 f7       	brne	.-26     	; 0x7f08 <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f22:	10 92 f9 0a 	sts	0x0AF9, r1
    7f26:	20 e0       	ldi	r18, 0x00	; 0
    7f28:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f2a:	f9 01       	movw	r30, r18
    7f2c:	ea 53       	subi	r30, 0x3A	; 58
    7f2e:	f6 4f       	sbci	r31, 0xF6	; 246
    7f30:	d9 01       	movw	r26, r18
    7f32:	a2 5e       	subi	r26, 0xE2	; 226
    7f34:	b3 4f       	sbci	r27, 0xF3	; 243
    7f36:	8c 91       	ld	r24, X
    7f38:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f3a:	2f 5f       	subi	r18, 0xFF	; 255
    7f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    7f3e:	23 31       	cpi	r18, 0x13	; 19
    7f40:	31 05       	cpc	r19, r1
    7f42:	99 f7       	brne	.-26     	; 0x7f2a <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f44:	10 92 d9 09 	sts	0x09D9, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f48:	80 91 31 0c 	lds	r24, 0x0C31
    7f4c:	80 93 89 0e 	sts	0x0E89, r24
    7f50:	80 91 32 0c 	lds	r24, 0x0C32
    7f54:	80 93 8a 0e 	sts	0x0E8A, r24
	 }Dest[Length]=0;
    7f58:	10 92 8b 0e 	sts	0x0E8B, r1
    7f5c:	20 e0       	ldi	r18, 0x00	; 0
    7f5e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f60:	f9 01       	movw	r30, r18
    7f62:	e9 5e       	subi	r30, 0xE9	; 233
    7f64:	f4 4f       	sbci	r31, 0xF4	; 244
    7f66:	d9 01       	movw	r26, r18
    7f68:	ad 5c       	subi	r26, 0xCD	; 205
    7f6a:	b3 4f       	sbci	r27, 0xF3	; 243
    7f6c:	8c 91       	ld	r24, X
    7f6e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f70:	2f 5f       	subi	r18, 0xFF	; 255
    7f72:	3f 4f       	sbci	r19, 0xFF	; 255
    7f74:	28 30       	cpi	r18, 0x08	; 8
    7f76:	31 05       	cpc	r19, r1
    7f78:	99 f7       	brne	.-26     	; 0x7f60 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f7a:	10 92 1f 0b 	sts	0x0B1F, r1
    7f7e:	20 e0       	ldi	r18, 0x00	; 0
    7f80:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f82:	f9 01       	movw	r30, r18
    7f84:	e0 54       	subi	r30, 0x40	; 64
    7f86:	fb 4f       	sbci	r31, 0xFB	; 251
    7f88:	d9 01       	movw	r26, r18
    7f8a:	a5 5c       	subi	r26, 0xC5	; 197
    7f8c:	b3 4f       	sbci	r27, 0xF3	; 243
    7f8e:	8c 91       	ld	r24, X
    7f90:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f92:	2f 5f       	subi	r18, 0xFF	; 255
    7f94:	3f 4f       	sbci	r19, 0xFF	; 255
    7f96:	28 30       	cpi	r18, 0x08	; 8
    7f98:	31 05       	cpc	r19, r1
    7f9a:	99 f7       	brne	.-26     	; 0x7f82 <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f9c:	10 92 c8 04 	sts	0x04C8, r1
    7fa0:	20 e0       	ldi	r18, 0x00	; 0
    7fa2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7fa4:	f9 01       	movw	r30, r18
    7fa6:	e4 51       	subi	r30, 0x14	; 20
    7fa8:	fb 4f       	sbci	r31, 0xFB	; 251
    7faa:	d9 01       	movw	r26, r18
    7fac:	ad 5b       	subi	r26, 0xBD	; 189
    7fae:	b3 4f       	sbci	r27, 0xF3	; 243
    7fb0:	8c 91       	ld	r24, X
    7fb2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7fb4:	2f 5f       	subi	r18, 0xFF	; 255
    7fb6:	3f 4f       	sbci	r19, 0xFF	; 255
    7fb8:	24 31       	cpi	r18, 0x14	; 20
    7fba:	31 05       	cpc	r19, r1
    7fbc:	99 f7       	brne	.-26     	; 0x7fa4 <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7fbe:	10 92 00 05 	sts	0x0500, r1
    7fc2:	20 e0       	ldi	r18, 0x00	; 0
    7fc4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7fc6:	f9 01       	movw	r30, r18
    7fc8:	e7 53       	subi	r30, 0x37	; 55
    7fca:	fb 4f       	sbci	r31, 0xFB	; 251
    7fcc:	d9 01       	movw	r26, r18
    7fce:	a9 5a       	subi	r26, 0xA9	; 169
    7fd0:	b3 4f       	sbci	r27, 0xF3	; 243
    7fd2:	8c 91       	ld	r24, X
    7fd4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7fd6:	2f 5f       	subi	r18, 0xFF	; 255
    7fd8:	3f 4f       	sbci	r19, 0xFF	; 255
    7fda:	2e 31       	cpi	r18, 0x1E	; 30
    7fdc:	31 05       	cpc	r19, r1
    7fde:	99 f7       	brne	.-26     	; 0x7fc6 <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7fe0:	10 92 e7 04 	sts	0x04E7, r1
    7fe4:	20 e0       	ldi	r18, 0x00	; 0
    7fe6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7fe8:	f9 01       	movw	r30, r18
    7fea:	ef 59       	subi	r30, 0x9F	; 159
    7fec:	f5 4f       	sbci	r31, 0xF5	; 245
    7fee:	d9 01       	movw	r26, r18
    7ff0:	ab 58       	subi	r26, 0x8B	; 139
    7ff2:	b3 4f       	sbci	r27, 0xF3	; 243
    7ff4:	8c 91       	ld	r24, X
    7ff6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7ff8:	2f 5f       	subi	r18, 0xFF	; 255
    7ffa:	3f 4f       	sbci	r19, 0xFF	; 255
    7ffc:	28 30       	cpi	r18, 0x08	; 8
    7ffe:	31 05       	cpc	r19, r1
    8000:	99 f7       	brne	.-26     	; 0x7fe8 <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8002:	10 92 69 0a 	sts	0x0A69, r1
    8006:	20 e0       	ldi	r18, 0x00	; 0
    8008:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    800a:	f9 01       	movw	r30, r18
    800c:	ed 57       	subi	r30, 0x7D	; 125
    800e:	fa 4f       	sbci	r31, 0xFA	; 250
    8010:	d9 01       	movw	r26, r18
    8012:	a3 58       	subi	r26, 0x83	; 131
    8014:	b3 4f       	sbci	r27, 0xF3	; 243
    8016:	8c 91       	ld	r24, X
    8018:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    801a:	2f 5f       	subi	r18, 0xFF	; 255
    801c:	3f 4f       	sbci	r19, 0xFF	; 255
    801e:	2a 30       	cpi	r18, 0x0A	; 10
    8020:	31 05       	cpc	r19, r1
    8022:	99 f7       	brne	.-26     	; 0x800a <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8024:	10 92 8d 05 	sts	0x058D, r1
    8028:	20 e0       	ldi	r18, 0x00	; 0
    802a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    802c:	f9 01       	movw	r30, r18
    802e:	ed 50       	subi	r30, 0x0D	; 13
    8030:	f2 4f       	sbci	r31, 0xF2	; 242
    8032:	d9 01       	movw	r26, r18
    8034:	a9 57       	subi	r26, 0x79	; 121
    8036:	b3 4f       	sbci	r27, 0xF3	; 243
    8038:	8c 91       	ld	r24, X
    803a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    803c:	2f 5f       	subi	r18, 0xFF	; 255
    803e:	3f 4f       	sbci	r19, 0xFF	; 255
    8040:	2a 30       	cpi	r18, 0x0A	; 10
    8042:	31 05       	cpc	r19, r1
    8044:	99 f7       	brne	.-26     	; 0x802c <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8046:	10 92 fd 0d 	sts	0x0DFD, r1
    804a:	20 e0       	ldi	r18, 0x00	; 0
    804c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    804e:	f9 01       	movw	r30, r18
    8050:	ea 50       	subi	r30, 0x0A	; 10
    8052:	f6 4f       	sbci	r31, 0xF6	; 246
    8054:	d9 01       	movw	r26, r18
    8056:	af 56       	subi	r26, 0x6F	; 111
    8058:	b3 4f       	sbci	r27, 0xF3	; 243
    805a:	8c 91       	ld	r24, X
    805c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    805e:	2f 5f       	subi	r18, 0xFF	; 255
    8060:	3f 4f       	sbci	r19, 0xFF	; 255
    8062:	24 31       	cpi	r18, 0x14	; 20
    8064:	31 05       	cpc	r19, r1
    8066:	99 f7       	brne	.-26     	; 0x804e <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8068:	10 92 0a 0a 	sts	0x0A0A, r1
    806c:	20 e0       	ldi	r18, 0x00	; 0
    806e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8070:	f9 01       	movw	r30, r18
    8072:	ee 57       	subi	r30, 0x7E	; 126
    8074:	f5 4f       	sbci	r31, 0xF5	; 245
    8076:	d9 01       	movw	r26, r18
    8078:	ab 55       	subi	r26, 0x5B	; 91
    807a:	b3 4f       	sbci	r27, 0xF3	; 243
    807c:	8c 91       	ld	r24, X
    807e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8080:	2f 5f       	subi	r18, 0xFF	; 255
    8082:	3f 4f       	sbci	r19, 0xFF	; 255
    8084:	2a 30       	cpi	r18, 0x0A	; 10
    8086:	31 05       	cpc	r19, r1
    8088:	99 f7       	brne	.-26     	; 0x8070 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    808a:	10 92 8c 0a 	sts	0x0A8C, r1
    808e:	20 e0       	ldi	r18, 0x00	; 0
    8090:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8092:	f9 01       	movw	r30, r18
    8094:	e1 56       	subi	r30, 0x61	; 97
    8096:	fa 4f       	sbci	r31, 0xFA	; 250
    8098:	d9 01       	movw	r26, r18
    809a:	a1 55       	subi	r26, 0x51	; 81
    809c:	b3 4f       	sbci	r27, 0xF3	; 243
    809e:	8c 91       	ld	r24, X
    80a0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80a2:	2f 5f       	subi	r18, 0xFF	; 255
    80a4:	3f 4f       	sbci	r19, 0xFF	; 255
    80a6:	28 30       	cpi	r18, 0x08	; 8
    80a8:	31 05       	cpc	r19, r1
    80aa:	99 f7       	brne	.-26     	; 0x8092 <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80ac:	10 92 a7 05 	sts	0x05A7, r1
    80b0:	20 e0       	ldi	r18, 0x00	; 0
    80b2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80b4:	f9 01       	movw	r30, r18
    80b6:	e2 58       	subi	r30, 0x82	; 130
    80b8:	f1 4f       	sbci	r31, 0xF1	; 241
    80ba:	d9 01       	movw	r26, r18
    80bc:	a9 54       	subi	r26, 0x49	; 73
    80be:	b3 4f       	sbci	r27, 0xF3	; 243
    80c0:	8c 91       	ld	r24, X
    80c2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80c4:	2f 5f       	subi	r18, 0xFF	; 255
    80c6:	3f 4f       	sbci	r19, 0xFF	; 255
    80c8:	2a 30       	cpi	r18, 0x0A	; 10
    80ca:	31 05       	cpc	r19, r1
    80cc:	99 f7       	brne	.-26     	; 0x80b4 <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80ce:	10 92 88 0e 	sts	0x0E88, r1
    80d2:	20 e0       	ldi	r18, 0x00	; 0
    80d4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80d6:	f9 01       	movw	r30, r18
    80d8:	e0 5f       	subi	r30, 0xF0	; 240
    80da:	f1 4f       	sbci	r31, 0xF1	; 241
    80dc:	d9 01       	movw	r26, r18
    80de:	af 53       	subi	r26, 0x3F	; 63
    80e0:	b3 4f       	sbci	r27, 0xF3	; 243
    80e2:	8c 91       	ld	r24, X
    80e4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80e6:	2f 5f       	subi	r18, 0xFF	; 255
    80e8:	3f 4f       	sbci	r19, 0xFF	; 255
    80ea:	24 31       	cpi	r18, 0x14	; 20
    80ec:	31 05       	cpc	r19, r1
    80ee:	99 f7       	brne	.-26     	; 0x80d6 <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80f0:	10 92 24 0e 	sts	0x0E24, r1
    80f4:	20 e0       	ldi	r18, 0x00	; 0
    80f6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80f8:	f9 01       	movw	r30, r18
    80fa:	ee 52       	subi	r30, 0x2E	; 46
    80fc:	fa 4f       	sbci	r31, 0xFA	; 250
    80fe:	d9 01       	movw	r26, r18
    8100:	ab 52       	subi	r26, 0x2B	; 43
    8102:	b3 4f       	sbci	r27, 0xF3	; 243
    8104:	8c 91       	ld	r24, X
    8106:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8108:	2f 5f       	subi	r18, 0xFF	; 255
    810a:	3f 4f       	sbci	r19, 0xFF	; 255
    810c:	2e 31       	cpi	r18, 0x1E	; 30
    810e:	31 05       	cpc	r19, r1
    8110:	99 f7       	brne	.-26     	; 0x80f8 <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8112:	10 92 f0 05 	sts	0x05F0, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    8116:	80 91 b9 01 	lds	r24, 0x01B9
    811a:	88 23       	and	r24, r24
    811c:	69 f0       	breq	.+26     	; 0x8138 <procMessage99+0x46a>
    811e:	00 91 5b 05 	lds	r16, 0x055B
    8122:	10 e0       	ldi	r17, 0x00	; 0
    8124:	83 ec       	ldi	r24, 0xC3	; 195
    8126:	99 e0       	ldi	r25, 0x09	; 9
    8128:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
    812c:	08 17       	cp	r16, r24
    812e:	19 07       	cpc	r17, r25
    8130:	19 f4       	brne	.+6      	; 0x8138 <procMessage99+0x46a>
	        IsCompleteFilling=True;
    8132:	81 e0       	ldi	r24, 0x01	; 1
    8134:	80 93 d6 01 	sts	0x01D6, r24
	   }

	  }
     return Result;     
}
    8138:	80 e0       	ldi	r24, 0x00	; 0
    813a:	1f 91       	pop	r17
    813c:	0f 91       	pop	r16
    813e:	08 95       	ret

00008140 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    8140:	0f 93       	push	r16
    8142:	1f 93       	push	r17
    8144:	df 93       	push	r29
    8146:	cf 93       	push	r28
    8148:	00 d0       	rcall	.+0      	; 0x814a <GetMessageID+0xa>
    814a:	0f 92       	push	r0
    814c:	cd b7       	in	r28, 0x3d	; 61
    814e:	de b7       	in	r29, 0x3e	; 62
    8150:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8152:	80 81       	ld	r24, Z
    8154:	89 83       	std	Y+1, r24	; 0x01
    8156:	81 81       	ldd	r24, Z+1	; 0x01
    8158:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    815a:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    815c:	8e 01       	movw	r16, r28
    815e:	0f 5f       	subi	r16, 0xFF	; 255
    8160:	1f 4f       	sbci	r17, 0xFF	; 255
    8162:	c8 01       	movw	r24, r16
    8164:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 Result=atoi(strMsgID);
    8168:	c8 01       	movw	r24, r16
    816a:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
  return Result;
}
    816e:	0f 90       	pop	r0
    8170:	0f 90       	pop	r0
    8172:	0f 90       	pop	r0
    8174:	cf 91       	pop	r28
    8176:	df 91       	pop	r29
    8178:	1f 91       	pop	r17
    817a:	0f 91       	pop	r16
    817c:	08 95       	ret

0000817e <FTestChar>:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
}

char FTestChar(){
    817e:	0f 93       	push	r16
    8180:	1f 93       	push	r17
    8182:	df 93       	push	r29
    8184:	cf 93       	push	r28
    8186:	cd b7       	in	r28, 0x3d	; 61
    8188:	de b7       	in	r29, 0x3e	; 62
    818a:	64 97       	sbiw	r28, 0x14	; 20
    818c:	0f b6       	in	r0, 0x3f	; 63
    818e:	f8 94       	cli
    8190:	de bf       	out	0x3e, r29	; 62
    8192:	0f be       	out	0x3f, r0	; 63
    8194:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
static char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    8196:	20 91 89 03 	lds	r18, 0x0389
    819a:	8d b7       	in	r24, 0x3d	; 61
    819c:	9e b7       	in	r25, 0x3e	; 62
    819e:	08 97       	sbiw	r24, 0x08	; 8
    81a0:	0f b6       	in	r0, 0x3f	; 63
    81a2:	f8 94       	cli
    81a4:	9e bf       	out	0x3e, r25	; 62
    81a6:	0f be       	out	0x3f, r0	; 63
    81a8:	8d bf       	out	0x3d, r24	; 61
    81aa:	ed b7       	in	r30, 0x3d	; 61
    81ac:	fe b7       	in	r31, 0x3e	; 62
    81ae:	31 96       	adiw	r30, 0x01	; 1
    81b0:	8e 01       	movw	r16, r28
    81b2:	0f 5f       	subi	r16, 0xFF	; 255
    81b4:	1f 4f       	sbci	r17, 0xFF	; 255
    81b6:	ad b7       	in	r26, 0x3d	; 61
    81b8:	be b7       	in	r27, 0x3e	; 62
    81ba:	12 96       	adiw	r26, 0x02	; 2
    81bc:	1c 93       	st	X, r17
    81be:	0e 93       	st	-X, r16
    81c0:	11 97       	sbiw	r26, 0x01	; 1
    81c2:	8d e4       	ldi	r24, 0x4D	; 77
    81c4:	9b e1       	ldi	r25, 0x1B	; 27
    81c6:	93 83       	std	Z+3, r25	; 0x03
    81c8:	82 83       	std	Z+2, r24	; 0x02
    81ca:	24 83       	std	Z+4, r18	; 0x04
    81cc:	15 82       	std	Z+5, r1	; 0x05
    81ce:	26 83       	std	Z+6, r18	; 0x06
    81d0:	17 82       	std	Z+7, r1	; 0x07
    81d2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
     lcd_print(1,1,lcdteks);
    81d6:	8d b7       	in	r24, 0x3d	; 61
    81d8:	9e b7       	in	r25, 0x3e	; 62
    81da:	08 96       	adiw	r24, 0x08	; 8
    81dc:	0f b6       	in	r0, 0x3f	; 63
    81de:	f8 94       	cli
    81e0:	9e bf       	out	0x3e, r25	; 62
    81e2:	0f be       	out	0x3f, r0	; 63
    81e4:	8d bf       	out	0x3d, r24	; 61
    81e6:	81 e0       	ldi	r24, 0x01	; 1
    81e8:	61 e0       	ldi	r22, 0x01	; 1
    81ea:	a8 01       	movw	r20, r16
    81ec:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	 if (i==0xFF)Result=MENU_DONE;
    81f0:	20 91 89 03 	lds	r18, 0x0389
	 i++;
    81f4:	2f 5f       	subi	r18, 0xFF	; 255
    81f6:	20 93 89 03 	sts	0x0389, r18
    81fa:	21 50       	subi	r18, 0x01	; 1
    81fc:	88 ee       	ldi	r24, 0xE8	; 232
    81fe:	9d ef       	ldi	r25, 0xFD	; 253
    8200:	49 e1       	ldi	r20, 0x19	; 25
    8202:	50 e0       	ldi	r21, 0x00	; 0
    8204:	fa 01       	movw	r30, r20
    8206:	31 97       	sbiw	r30, 0x01	; 1
    8208:	f1 f7       	brne	.-4      	; 0x8206 <FTestChar+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    820a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    820c:	d9 f7       	brne	.-10     	; 0x8204 <FTestChar+0x86>
    820e:	80 e0       	ldi	r24, 0x00	; 0
    8210:	2f 3f       	cpi	r18, 0xFF	; 255
    8212:	09 f4       	brne	.+2      	; 0x8216 <FTestChar+0x98>
    8214:	81 e0       	ldi	r24, 0x01	; 1
     _delay_ms(6500);
  return Result;
}
    8216:	64 96       	adiw	r28, 0x14	; 20
    8218:	0f b6       	in	r0, 0x3f	; 63
    821a:	f8 94       	cli
    821c:	de bf       	out	0x3e, r29	; 62
    821e:	0f be       	out	0x3f, r0	; 63
    8220:	cd bf       	out	0x3d, r28	; 61
    8222:	cf 91       	pop	r28
    8224:	df 91       	pop	r29
    8226:	1f 91       	pop	r17
    8228:	0f 91       	pop	r16
    822a:	08 95       	ret

0000822c <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    822c:	0f 93       	push	r16
    822e:	1f 93       	push	r17
    8230:	df 93       	push	r29
    8232:	cf 93       	push	r28
    8234:	cd b7       	in	r28, 0x3d	; 61
    8236:	de b7       	in	r29, 0x3e	; 62
    8238:	a8 97       	sbiw	r28, 0x28	; 40
    823a:	0f b6       	in	r0, 0x3f	; 63
    823c:	f8 94       	cli
    823e:	de bf       	out	0x3e, r29	; 62
    8240:	0f be       	out	0x3f, r0	; 63
    8242:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    8244:	80 91 26 01 	lds	r24, 0x0126
    8248:	81 30       	cpi	r24, 0x01	; 1
    824a:	09 f0       	breq	.+2      	; 0x824e <DisplayPumpStatus+0x22>
    824c:	4a c0       	rjmp	.+148    	; 0x82e2 <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    824e:	10 92 26 01 	sts	0x0126, r1
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    8252:	80 93 e1 03 	sts	0x03E1, r24
    8256:	10 92 e2 03 	sts	0x03E2, r1
    825a:	80 91 65 00 	lds	r24, 0x0065
    825e:	8d 7f       	andi	r24, 0xFD	; 253
    8260:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    8264:	80 91 75 01 	lds	r24, 0x0175
    8268:	48 2f       	mov	r20, r24
    826a:	50 e0       	ldi	r21, 0x00	; 0
    826c:	20 e0       	ldi	r18, 0x00	; 0
    826e:	30 e0       	ldi	r19, 0x00	; 0
    8270:	be 01       	movw	r22, r28
    8272:	6f 5f       	subi	r22, 0xFF	; 255
    8274:	7f 4f       	sbci	r23, 0xFF	; 255
    8276:	0a c0       	rjmp	.+20     	; 0x828c <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8278:	fb 01       	movw	r30, r22
    827a:	e2 0f       	add	r30, r18
    827c:	f3 1f       	adc	r31, r19
    827e:	d9 01       	movw	r26, r18
    8280:	a9 5d       	subi	r26, 0xD9	; 217
    8282:	be 4f       	sbci	r27, 0xFE	; 254
    8284:	8c 91       	ld	r24, X
    8286:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8288:	2f 5f       	subi	r18, 0xFF	; 255
    828a:	3f 4f       	sbci	r19, 0xFF	; 255
    828c:	24 17       	cp	r18, r20
    828e:	35 07       	cpc	r19, r21
    8290:	98 f3       	brcs	.-26     	; 0x8278 <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8292:	46 0f       	add	r20, r22
    8294:	57 1f       	adc	r21, r23
    8296:	da 01       	movw	r26, r20
    8298:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    829a:	00 d0       	rcall	.+0      	; 0x829c <DisplayPumpStatus+0x70>
    829c:	00 d0       	rcall	.+0      	; 0x829e <DisplayPumpStatus+0x72>
    829e:	00 d0       	rcall	.+0      	; 0x82a0 <DisplayPumpStatus+0x74>
    82a0:	ed b7       	in	r30, 0x3d	; 61
    82a2:	fe b7       	in	r31, 0x3e	; 62
    82a4:	31 96       	adiw	r30, 0x01	; 1
    82a6:	8e 01       	movw	r16, r28
    82a8:	0b 5e       	subi	r16, 0xEB	; 235
    82aa:	1f 4f       	sbci	r17, 0xFF	; 255
    82ac:	ad b7       	in	r26, 0x3d	; 61
    82ae:	be b7       	in	r27, 0x3e	; 62
    82b0:	12 96       	adiw	r26, 0x02	; 2
    82b2:	1c 93       	st	X, r17
    82b4:	0e 93       	st	-X, r16
    82b6:	11 97       	sbiw	r26, 0x01	; 1
    82b8:	82 ef       	ldi	r24, 0xF2	; 242
    82ba:	91 e2       	ldi	r25, 0x21	; 33
    82bc:	93 83       	std	Z+3, r25	; 0x03
    82be:	82 83       	std	Z+2, r24	; 0x02
    82c0:	75 83       	std	Z+5, r23	; 0x05
    82c2:	64 83       	std	Z+4, r22	; 0x04
    82c4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
         lcd_print(4,1,lcdteks);
    82c8:	ed b7       	in	r30, 0x3d	; 61
    82ca:	fe b7       	in	r31, 0x3e	; 62
    82cc:	36 96       	adiw	r30, 0x06	; 6
    82ce:	0f b6       	in	r0, 0x3f	; 63
    82d0:	f8 94       	cli
    82d2:	fe bf       	out	0x3e, r31	; 62
    82d4:	0f be       	out	0x3f, r0	; 63
    82d6:	ed bf       	out	0x3d, r30	; 61
    82d8:	84 e0       	ldi	r24, 0x04	; 4
    82da:	61 e0       	ldi	r22, 0x01	; 1
    82dc:	a8 01       	movw	r20, r16
    82de:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
     	 }
}
    82e2:	a8 96       	adiw	r28, 0x28	; 40
    82e4:	0f b6       	in	r0, 0x3f	; 63
    82e6:	f8 94       	cli
    82e8:	de bf       	out	0x3e, r29	; 62
    82ea:	0f be       	out	0x3f, r0	; 63
    82ec:	cd bf       	out	0x3d, r28	; 61
    82ee:	cf 91       	pop	r28
    82f0:	df 91       	pop	r29
    82f2:	1f 91       	pop	r17
    82f4:	0f 91       	pop	r16
    82f6:	08 95       	ret

000082f8 <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    82f8:	80 91 72 03 	lds	r24, 0x0372
    82fc:	81 30       	cpi	r24, 0x01	; 1
    82fe:	49 f0       	breq	.+18     	; 0x8312 <FViewFreeMessage+0x1a>
    8300:	81 30       	cpi	r24, 0x01	; 1
    8302:	28 f0       	brcs	.+10     	; 0x830e <FViewFreeMessage+0x16>
    8304:	82 30       	cpi	r24, 0x02	; 2
    8306:	19 f1       	breq	.+70     	; 0x834e <FViewFreeMessage+0x56>
    8308:	83 30       	cpi	r24, 0x03	; 3
    830a:	71 f5       	brne	.+92     	; 0x8368 <FViewFreeMessage+0x70>
    830c:	29 c0       	rjmp	.+82     	; 0x8360 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    830e:	81 e0       	ldi	r24, 0x01	; 1
    8310:	23 c0       	rjmp	.+70     	; 0x8358 <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    8312:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    8316:	81 e0       	ldi	r24, 0x01	; 1
    8318:	61 e0       	ldi	r22, 0x01	; 1
    831a:	42 ec       	ldi	r20, 0xC2	; 194
    831c:	5a e0       	ldi	r21, 0x0A	; 10
    831e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    8322:	82 e0       	ldi	r24, 0x02	; 2
    8324:	61 e0       	ldi	r22, 0x01	; 1
    8326:	4d ea       	ldi	r20, 0xAD	; 173
    8328:	59 e0       	ldi	r21, 0x09	; 9
    832a:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    832e:	83 e0       	ldi	r24, 0x03	; 3
    8330:	61 e0       	ldi	r22, 0x01	; 1
    8332:	48 e4       	ldi	r20, 0x48	; 72
    8334:	5a e0       	ldi	r21, 0x0A	; 10
    8336:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    833a:	84 e0       	ldi	r24, 0x04	; 4
    833c:	61 e0       	ldi	r22, 0x01	; 1
    833e:	4c ed       	ldi	r20, 0xDC	; 220
    8340:	5d e0       	ldi	r21, 0x0D	; 13
    8342:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	      TimDisplay=0;
    8346:	10 92 bc 01 	sts	0x01BC, r1
	      stFreeMessage=fmDelayViewMesage;
    834a:	82 e0       	ldi	r24, 0x02	; 2
    834c:	05 c0       	rjmp	.+10     	; 0x8358 <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    834e:	80 91 bc 01 	lds	r24, 0x01BC
    8352:	8b 30       	cpi	r24, 0x0B	; 11
    8354:	48 f0       	brcs	.+18     	; 0x8368 <FViewFreeMessage+0x70>
    8356:	83 e0       	ldi	r24, 0x03	; 3
    8358:	80 93 72 03 	sts	0x0372, r24
    835c:	80 e0       	ldi	r24, 0x00	; 0
    835e:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    8360:	10 92 72 03 	sts	0x0372, r1
    8364:	81 e0       	ldi	r24, 0x01	; 1
    8366:	08 95       	ret
    8368:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    836a:	08 95       	ret

0000836c <_scr_idle>:
	lcd_printf(2, 5, PSTR("(P)+(C)2009, HAS"));
}



void _scr_idle(void){
    836c:	cf 92       	push	r12
    836e:	df 92       	push	r13
    8370:	ef 92       	push	r14
    8372:	ff 92       	push	r15
    8374:	0f 93       	push	r16
    8376:	1f 93       	push	r17
    8378:	df 93       	push	r29
    837a:	cf 93       	push	r28
    837c:	cd b7       	in	r28, 0x3d	; 61
    837e:	de b7       	in	r29, 0x3e	; 62
    8380:	a8 97       	sbiw	r28, 0x28	; 40
    8382:	0f b6       	in	r0, 0x3f	; 63
    8384:	f8 94       	cli
    8386:	de bf       	out	0x3e, r29	; 62
    8388:	0f be       	out	0x3f, r0	; 63
    838a:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    838c:	00 d0       	rcall	.+0      	; 0x838e <_scr_idle+0x22>
    838e:	00 d0       	rcall	.+0      	; 0x8390 <_scr_idle+0x24>
    8390:	6e 01       	movw	r12, r28
    8392:	08 94       	sec
    8394:	c1 1c       	adc	r12, r1
    8396:	d1 1c       	adc	r13, r1
    8398:	ad b7       	in	r26, 0x3d	; 61
    839a:	be b7       	in	r27, 0x3e	; 62
    839c:	12 96       	adiw	r26, 0x02	; 2
    839e:	dc 92       	st	X, r13
    83a0:	ce 92       	st	-X, r12
    83a2:	11 97       	sbiw	r26, 0x01	; 1
    83a4:	81 e6       	ldi	r24, 0x61	; 97
    83a6:	91 e2       	ldi	r25, 0x21	; 33
    83a8:	14 96       	adiw	r26, 0x04	; 4
    83aa:	9c 93       	st	X, r25
    83ac:	8e 93       	st	-X, r24
    83ae:	13 97       	sbiw	r26, 0x03	; 3
    83b0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    83b4:	fb e0       	ldi	r31, 0x0B	; 11
    83b6:	ef 2e       	mov	r14, r31
    83b8:	f1 2c       	mov	r15, r1
    83ba:	ec 0e       	add	r14, r28
    83bc:	fd 1e       	adc	r15, r29
    83be:	ed b7       	in	r30, 0x3d	; 61
    83c0:	fe b7       	in	r31, 0x3e	; 62
    83c2:	f2 82       	std	Z+2, r15	; 0x02
    83c4:	e1 82       	std	Z+1, r14	; 0x01
    83c6:	8c e5       	ldi	r24, 0x5C	; 92
    83c8:	91 e2       	ldi	r25, 0x21	; 33
    83ca:	94 83       	std	Z+4, r25	; 0x04
    83cc:	83 83       	std	Z+3, r24	; 0x03
    83ce:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    83d2:	00 d0       	rcall	.+0      	; 0x83d4 <_scr_idle+0x68>
    83d4:	00 d0       	rcall	.+0      	; 0x83d6 <_scr_idle+0x6a>
    83d6:	ed b7       	in	r30, 0x3d	; 61
    83d8:	fe b7       	in	r31, 0x3e	; 62
    83da:	31 96       	adiw	r30, 0x01	; 1
    83dc:	8e 01       	movw	r16, r28
    83de:	0b 5e       	subi	r16, 0xEB	; 235
    83e0:	1f 4f       	sbci	r17, 0xFF	; 255
    83e2:	ad b7       	in	r26, 0x3d	; 61
    83e4:	be b7       	in	r27, 0x3e	; 62
    83e6:	12 96       	adiw	r26, 0x02	; 2
    83e8:	1c 93       	st	X, r17
    83ea:	0e 93       	st	-X, r16
    83ec:	11 97       	sbiw	r26, 0x01	; 1
    83ee:	86 e5       	ldi	r24, 0x56	; 86
    83f0:	91 e2       	ldi	r25, 0x21	; 33
    83f2:	93 83       	std	Z+3, r25	; 0x03
    83f4:	82 83       	std	Z+2, r24	; 0x02
    83f6:	d5 82       	std	Z+5, r13	; 0x05
    83f8:	c4 82       	std	Z+4, r12	; 0x04
    83fa:	f7 82       	std	Z+7, r15	; 0x07
    83fc:	e6 82       	std	Z+6, r14	; 0x06
    83fe:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	lcd_clear();
    8402:	ed b7       	in	r30, 0x3d	; 61
    8404:	fe b7       	in	r31, 0x3e	; 62
    8406:	38 96       	adiw	r30, 0x08	; 8
    8408:	0f b6       	in	r0, 0x3f	; 63
    840a:	f8 94       	cli
    840c:	fe bf       	out	0x3e, r31	; 62
    840e:	0f be       	out	0x3f, r0	; 63
    8410:	ed bf       	out	0x3d, r30	; 61
    8412:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	lcd_print(1,1,lcdteks);
    8416:	81 e0       	ldi	r24, 0x01	; 1
    8418:	61 e0       	ldi	r22, 0x01	; 1
    841a:	a8 01       	movw	r20, r16
    841c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
}
    8420:	a8 96       	adiw	r28, 0x28	; 40
    8422:	0f b6       	in	r0, 0x3f	; 63
    8424:	f8 94       	cli
    8426:	de bf       	out	0x3e, r29	; 62
    8428:	0f be       	out	0x3f, r0	; 63
    842a:	cd bf       	out	0x3d, r28	; 61
    842c:	cf 91       	pop	r28
    842e:	df 91       	pop	r29
    8430:	1f 91       	pop	r17
    8432:	0f 91       	pop	r16
    8434:	ff 90       	pop	r15
    8436:	ef 90       	pop	r14
    8438:	df 90       	pop	r13
    843a:	cf 90       	pop	r12
    843c:	08 95       	ret

0000843e <_menu_admin>:
}



void _menu_admin(void){
		lcd_clear();
    843e:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		lcd_printf(1, 1, PSTR("1)Close Shift"));
    8442:	81 e0       	ldi	r24, 0x01	; 1
    8444:	61 e0       	ldi	r22, 0x01	; 1
    8446:	42 ee       	ldi	r20, 0xE2	; 226
    8448:	5b e0       	ldi	r21, 0x0B	; 11
    844a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Re-Print"));
    844e:	82 e0       	ldi	r24, 0x02	; 2
    8450:	61 e0       	ldi	r22, 0x01	; 1
    8452:	47 ed       	ldi	r20, 0xD7	; 215
    8454:	5b e0       	ldi	r21, 0x0B	; 11
    8456:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(3, 1, PSTR("3)User("));
    845a:	83 e0       	ldi	r24, 0x03	; 3
    845c:	61 e0       	ldi	r22, 0x01	; 1
    845e:	4f ec       	ldi	r20, 0xCF	; 207
    8460:	5b e0       	ldi	r21, 0x0B	; 11
    8462:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    8466:	84 e0       	ldi	r24, 0x04	; 4
    8468:	61 e0       	ldi	r22, 0x01	; 1
    846a:	48 ec       	ldi	r20, 0xC8	; 200
    846c:	5b e0       	ldi	r21, 0x0B	; 11
    846e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
}
    8472:	08 95       	ret

00008474 <_scr_pump>:
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    8474:	8f 92       	push	r8
    8476:	9f 92       	push	r9
    8478:	af 92       	push	r10
    847a:	bf 92       	push	r11
    847c:	cf 92       	push	r12
    847e:	df 92       	push	r13
    8480:	ef 92       	push	r14
    8482:	ff 92       	push	r15
    8484:	0f 93       	push	r16
    8486:	1f 93       	push	r17
    8488:	df 93       	push	r29
    848a:	cf 93       	push	r28
    848c:	cd b7       	in	r28, 0x3d	; 61
    848e:	de b7       	in	r29, 0x3e	; 62
    8490:	6c 97       	sbiw	r28, 0x1c	; 28
    8492:	0f b6       	in	r0, 0x3f	; 63
    8494:	f8 94       	cli
    8496:	de bf       	out	0x3e, r29	; 62
    8498:	0f be       	out	0x3f, r0	; 63
    849a:	cd bf       	out	0x3d, r28	; 61
	 char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    849c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    84a0:	84 ec       	ldi	r24, 0xC4	; 196
    84a2:	99 e0       	ldi	r25, 0x09	; 9
    84a4:	01 97       	sbiw	r24, 0x01	; 1
    84a6:	f1 f7       	brne	.-4      	; 0x84a4 <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    84a8:	8e 01       	movw	r16, r28
    84aa:	0f 5f       	subi	r16, 0xFF	; 255
    84ac:	1f 4f       	sbci	r17, 0xFF	; 255
    84ae:	c8 01       	movw	r24, r16
    84b0:	65 e4       	ldi	r22, 0x45	; 69
    84b2:	70 e0       	ldi	r23, 0x00	; 0
    84b4:	48 e0       	ldi	r20, 0x08	; 8
    84b6:	50 e0       	ldi	r21, 0x00	; 0
    84b8:	27 e9       	ldi	r18, 0x97	; 151
    84ba:	32 e1       	ldi	r19, 0x12	; 18
    84bc:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    84c0:	78 01       	movw	r14, r16
    84c2:	01 e0       	ldi	r16, 0x01	; 1
    84c4:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    84c6:	89 e0       	ldi	r24, 0x09	; 9
    84c8:	c8 2e       	mov	r12, r24
    84ca:	d1 2c       	mov	r13, r1
    84cc:	cc 0e       	add	r12, r28
    84ce:	dd 1e       	adc	r13, r29
    84d0:	be e9       	ldi	r27, 0x9E	; 158
    84d2:	8b 2e       	mov	r8, r27
    84d4:	be e0       	ldi	r27, 0x0E	; 14
    84d6:	9b 2e       	mov	r9, r27
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    84d8:	a5 e0       	ldi	r26, 0x05	; 5
    84da:	aa 2e       	mov	r10, r26
    84dc:	b1 2c       	mov	r11, r1
    84de:	ac 0e       	add	r10, r28
    84e0:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    84e2:	8d b7       	in	r24, 0x3d	; 61
    84e4:	9e b7       	in	r25, 0x3e	; 62
    84e6:	0c 97       	sbiw	r24, 0x0c	; 12
    84e8:	0f b6       	in	r0, 0x3f	; 63
    84ea:	f8 94       	cli
    84ec:	9e bf       	out	0x3e, r25	; 62
    84ee:	0f be       	out	0x3f, r0	; 63
    84f0:	8d bf       	out	0x3d, r24	; 61
    84f2:	ed b7       	in	r30, 0x3d	; 61
    84f4:	fe b7       	in	r31, 0x3e	; 62
    84f6:	31 96       	adiw	r30, 0x01	; 1
    84f8:	ad b7       	in	r26, 0x3d	; 61
    84fa:	be b7       	in	r27, 0x3e	; 62
    84fc:	12 96       	adiw	r26, 0x02	; 2
    84fe:	dc 92       	st	X, r13
    8500:	ce 92       	st	-X, r12
    8502:	11 97       	sbiw	r26, 0x01	; 1
    8504:	93 82       	std	Z+3, r9	; 0x03
    8506:	82 82       	std	Z+2, r8	; 0x02
    8508:	15 83       	std	Z+5, r17	; 0x05
    850a:	04 83       	std	Z+4, r16	; 0x04
    850c:	d7 01       	movw	r26, r14
    850e:	8c 91       	ld	r24, X
    8510:	86 83       	std	Z+6, r24	; 0x06
    8512:	17 82       	std	Z+7, r1	; 0x07
    8514:	0c 5f       	subi	r16, 0xFC	; 252
    8516:	1f 4f       	sbci	r17, 0xFF	; 255
    8518:	11 87       	std	Z+9, r17	; 0x09
    851a:	00 87       	std	Z+8, r16	; 0x08
    851c:	04 50       	subi	r16, 0x04	; 4
    851e:	10 40       	sbci	r17, 0x00	; 0
    8520:	14 96       	adiw	r26, 0x04	; 4
    8522:	8c 91       	ld	r24, X
    8524:	82 87       	std	Z+10, r24	; 0x0a
    8526:	13 86       	std	Z+11, r1	; 0x0b
    8528:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    852c:	8d b7       	in	r24, 0x3d	; 61
    852e:	9e b7       	in	r25, 0x3e	; 62
    8530:	0c 96       	adiw	r24, 0x0c	; 12
    8532:	0f b6       	in	r0, 0x3f	; 63
    8534:	f8 94       	cli
    8536:	9e bf       	out	0x3e, r25	; 62
    8538:	0f be       	out	0x3f, r0	; 63
    853a:	8d bf       	out	0x3d, r24	; 61
    853c:	80 2f       	mov	r24, r16
    853e:	61 e0       	ldi	r22, 0x01	; 1
    8540:	a6 01       	movw	r20, r12
    8542:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    8546:	08 94       	sec
    8548:	e1 1c       	adc	r14, r1
    854a:	f1 1c       	adc	r15, r1
    854c:	0f 5f       	subi	r16, 0xFF	; 255
    854e:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8550:	ea 14       	cp	r14, r10
    8552:	fb 04       	cpc	r15, r11
    8554:	31 f6       	brne	.-116    	; 0x84e2 <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    8556:	84 e0       	ldi	r24, 0x04	; 4
    8558:	6f e0       	ldi	r22, 0x0F	; 15
    855a:	47 e9       	ldi	r20, 0x97	; 151
    855c:	5e e0       	ldi	r21, 0x0E	; 14
    855e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
}
    8562:	6c 96       	adiw	r28, 0x1c	; 28
    8564:	0f b6       	in	r0, 0x3f	; 63
    8566:	f8 94       	cli
    8568:	de bf       	out	0x3e, r29	; 62
    856a:	0f be       	out	0x3f, r0	; 63
    856c:	cd bf       	out	0x3d, r28	; 61
    856e:	cf 91       	pop	r28
    8570:	df 91       	pop	r29
    8572:	1f 91       	pop	r17
    8574:	0f 91       	pop	r16
    8576:	ff 90       	pop	r15
    8578:	ef 90       	pop	r14
    857a:	df 90       	pop	r13
    857c:	cf 90       	pop	r12
    857e:	bf 90       	pop	r11
    8580:	af 90       	pop	r10
    8582:	9f 90       	pop	r9
    8584:	8f 90       	pop	r8
    8586:	08 95       	ret

00008588 <_scr_splash>:
		break;
	 }
}

void _scr_splash(void){
	lcd_clear();_delay_ms(20);
    8588:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    858c:	88 e8       	ldi	r24, 0x88	; 136
    858e:	93 e1       	ldi	r25, 0x13	; 19
    8590:	01 97       	sbiw	r24, 0x01	; 1
    8592:	f1 f7       	brne	.-4      	; 0x8590 <_scr_splash+0x8>
	lcd_printf(1, 5, PSTR("IFTv5.13"));
    8594:	81 e0       	ldi	r24, 0x01	; 1
    8596:	65 e0       	ldi	r22, 0x05	; 5
    8598:	49 e7       	ldi	r20, 0x79	; 121
    859a:	51 e2       	ldi	r21, 0x21	; 33
    859c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(2, 5, PSTR("(P)+(C)2009, HAS"));
    85a0:	82 e0       	ldi	r24, 0x02	; 2
    85a2:	65 e0       	ldi	r22, 0x05	; 5
    85a4:	48 e6       	ldi	r20, 0x68	; 104
    85a6:	51 e2       	ldi	r21, 0x21	; 33
    85a8:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
}
    85ac:	08 95       	ret

000085ae <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    85ae:	2f 92       	push	r2
    85b0:	3f 92       	push	r3
    85b2:	4f 92       	push	r4
    85b4:	5f 92       	push	r5
    85b6:	6f 92       	push	r6
    85b8:	7f 92       	push	r7
    85ba:	8f 92       	push	r8
    85bc:	9f 92       	push	r9
    85be:	af 92       	push	r10
    85c0:	bf 92       	push	r11
    85c2:	cf 92       	push	r12
    85c4:	df 92       	push	r13
    85c6:	ef 92       	push	r14
    85c8:	ff 92       	push	r15
    85ca:	0f 93       	push	r16
    85cc:	1f 93       	push	r17
    85ce:	df 93       	push	r29
    85d0:	cf 93       	push	r28
    85d2:	cd b7       	in	r28, 0x3d	; 61
    85d4:	de b7       	in	r29, 0x3e	; 62
    85d6:	6d 97       	sbiw	r28, 0x1d	; 29
    85d8:	0f b6       	in	r0, 0x3f	; 63
    85da:	f8 94       	cli
    85dc:	de bf       	out	0x3e, r29	; 62
    85de:	0f be       	out	0x3f, r0	; 63
    85e0:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    85e2:	e1 99       	sbic	0x1c, 1	; 28
    85e4:	fe cf       	rjmp	.-4      	; 0x85e2 <_menu_host+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    85e6:	21 ef       	ldi	r18, 0xF1	; 241
    85e8:	33 e0       	ldi	r19, 0x03	; 3
    85ea:	3f bb       	out	0x1f, r19	; 31
    85ec:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    85ee:	e0 9a       	sbi	0x1c, 0	; 28
    85f0:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	static char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    85f2:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    85f4:	e1 99       	sbic	0x1c, 1	; 28
    85f6:	fe cf       	rjmp	.-4      	; 0x85f4 <_menu_host+0x46>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    85f8:	f7 e3       	ldi	r31, 0x37	; 55
    85fa:	2f 2e       	mov	r2, r31
    85fc:	f0 e0       	ldi	r31, 0x00	; 0
    85fe:	3f 2e       	mov	r3, r31
    8600:	3f ba       	out	0x1f, r3	; 31
    8602:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8604:	e0 9a       	sbi	0x1c, 0	; 28
    8606:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&__date_time);
    8608:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    860a:	e1 99       	sbic	0x1c, 1	; 28
    860c:	fe cf       	rjmp	.-4      	; 0x860a <_menu_host+0x5c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    860e:	e8 e3       	ldi	r30, 0x38	; 56
    8610:	4e 2e       	mov	r4, r30
    8612:	e0 e0       	ldi	r30, 0x00	; 0
    8614:	5e 2e       	mov	r5, r30
    8616:	5f ba       	out	0x1f, r5	; 31
    8618:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    861a:	e0 9a       	sbi	0x1c, 0	; 28
    861c:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    861e:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8620:	e1 99       	sbic	0x1c, 1	; 28
    8622:	fe cf       	rjmp	.-4      	; 0x8620 <_menu_host+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8624:	70 e0       	ldi	r23, 0x00	; 0
    8626:	67 2e       	mov	r6, r23
    8628:	70 e0       	ldi	r23, 0x00	; 0
    862a:	77 2e       	mov	r7, r23
    862c:	7f ba       	out	0x1f, r7	; 31
    862e:	6e ba       	out	0x1e, r6	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8630:	e0 9a       	sbi	0x1c, 0	; 28
    8632:	8d b3       	in	r24, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);
    8634:	80 93 ec 02 	sts	0x02EC, r24


	lcd_clear();_delay_ms(10);
    8638:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    863c:	84 ec       	ldi	r24, 0xC4	; 196
    863e:	99 e0       	ldi	r25, 0x09	; 9
    8640:	01 97       	sbiw	r24, 0x01	; 1
    8642:	f1 f7       	brne	.-4      	; 0x8640 <_menu_host+0x92>
	lcd_printf(1, 1, PSTR("1)Money :"));
    8644:	81 e0       	ldi	r24, 0x01	; 1
    8646:	61 e0       	ldi	r22, 0x01	; 1
    8648:	42 e7       	ldi	r20, 0x72	; 114
    864a:	5c e0       	ldi	r21, 0x0C	; 12
    864c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    8650:	82 e0       	ldi	r24, 0x02	; 2
    8652:	61 e0       	ldi	r22, 0x01	; 1
    8654:	48 e6       	ldi	r20, 0x68	; 104
    8656:	5c e0       	ldi	r21, 0x0C	; 12
    8658:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    865c:	83 e0       	ldi	r24, 0x03	; 3
    865e:	61 e0       	ldi	r22, 0x01	; 1
    8660:	43 e5       	ldi	r20, 0x53	; 83
    8662:	5c e0       	ldi	r21, 0x0C	; 12
    8664:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8668:	00 d0       	rcall	.+0      	; 0x866a <_menu_host+0xbc>
    866a:	00 d0       	rcall	.+0      	; 0x866c <_menu_host+0xbe>
    866c:	00 d0       	rcall	.+0      	; 0x866e <_menu_host+0xc0>
    866e:	ed b7       	in	r30, 0x3d	; 61
    8670:	fe b7       	in	r31, 0x3e	; 62
    8672:	31 96       	adiw	r30, 0x01	; 1
    8674:	8e 01       	movw	r16, r28
    8676:	06 5f       	subi	r16, 0xF6	; 246
    8678:	1f 4f       	sbci	r17, 0xFF	; 255
    867a:	ad b7       	in	r26, 0x3d	; 61
    867c:	be b7       	in	r27, 0x3e	; 62
    867e:	12 96       	adiw	r26, 0x02	; 2
    8680:	1c 93       	st	X, r17
    8682:	0e 93       	st	-X, r16
    8684:	11 97       	sbiw	r26, 0x01	; 1
    8686:	86 e4       	ldi	r24, 0x46	; 70
    8688:	9c e0       	ldi	r25, 0x0C	; 12
    868a:	93 83       	std	Z+3, r25	; 0x03
    868c:	82 83       	std	Z+2, r24	; 0x02
    868e:	80 91 ec 02 	lds	r24, 0x02EC
    8692:	84 83       	std	Z+4, r24	; 0x04
    8694:	15 82       	std	Z+5, r1	; 0x05
    8696:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 lcd_print(4, 1,lcdteks);
    869a:	ed b7       	in	r30, 0x3d	; 61
    869c:	fe b7       	in	r31, 0x3e	; 62
    869e:	36 96       	adiw	r30, 0x06	; 6
    86a0:	0f b6       	in	r0, 0x3f	; 63
    86a2:	f8 94       	cli
    86a4:	fe bf       	out	0x3e, r31	; 62
    86a6:	0f be       	out	0x3f, r0	; 63
    86a8:	ed bf       	out	0x3d, r30	; 61
    86aa:	84 e0       	ldi	r24, 0x04	; 4
    86ac:	61 e0       	ldi	r22, 0x01	; 1
    86ae:	a8 01       	movw	r20, r16
    86b0:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    86b4:	84 e0       	ldi	r24, 0x04	; 4
    86b6:	6f e0       	ldi	r22, 0x0F	; 15
    86b8:	4f e3       	ldi	r20, 0x3F	; 63
    86ba:	5c e0       	ldi	r21, 0x0C	; 12
    86bc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    86c0:	6a e2       	ldi	r22, 0x2A	; 42
    86c2:	e6 2e       	mov	r14, r22
    86c4:	63 e0       	ldi	r22, 0x03	; 3
    86c6:	f6 2e       	mov	r15, r22
    86c8:	6e 01       	movw	r12, r28
    86ca:	08 94       	sec
    86cc:	c1 1c       	adc	r12, r1
    86ce:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    86d0:	55 e0       	ldi	r21, 0x05	; 5
    86d2:	a5 2e       	mov	r10, r21
    86d4:	b1 2c       	mov	r11, r1
    86d6:	ac 0e       	add	r10, r28
    86d8:	bd 1e       	adc	r11, r29
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    86da:	f7 01       	movw	r30, r14
    86dc:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    86de:	08 94       	sec
    86e0:	e1 1c       	adc	r14, r1
    86e2:	f1 1c       	adc	r15, r1
    86e4:	f7 01       	movw	r30, r14
    86e6:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __value[__i]);
    86e8:	d6 01       	movw	r26, r12
    86ea:	4d 91       	ld	r20, X+
    86ec:	6d 01       	movw	r12, r26
    86ee:	50 e0       	ldi	r21, 0x00	; 0
    86f0:	60 e0       	ldi	r22, 0x00	; 0
    86f2:	70 e0       	ldi	r23, 0x00	; 0
    86f4:	c5 01       	movw	r24, r10
    86f6:	0e 94 78 18 	call	0x30f0	; 0x30f0 <_f_inttostr>
		lcd_print(__x, __y, __buff);
    86fa:	80 2f       	mov	r24, r16
    86fc:	61 2f       	mov	r22, r17
    86fe:	a5 01       	movw	r20, r10
    8700:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    8704:	08 94       	sec
    8706:	e1 1c       	adc	r14, r1
    8708:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    870a:	b0 e3       	ldi	r27, 0x30	; 48
    870c:	eb 16       	cp	r14, r27
    870e:	b3 e0       	ldi	r27, 0x03	; 3
    8710:	fb 06       	cpc	r15, r27
    8712:	19 f7       	brne	.-58     	; 0x86da <_menu_host+0x12c>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8714:	4a e0       	ldi	r20, 0x0A	; 10
    8716:	a4 2e       	mov	r10, r20
    8718:	b1 2c       	mov	r11, r1
    871a:	ac 0e       	add	r10, r28
    871c:	bd 1e       	adc	r11, r29
    871e:	32 e3       	ldi	r19, 0x32	; 50
    8720:	83 2e       	mov	r8, r19
    8722:	3c e0       	ldi	r19, 0x0C	; 12
    8724:	93 2e       	mov	r9, r19
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    8726:	6e 01       	movw	r12, r28
    8728:	08 94       	sec
    872a:	c1 1c       	adc	r12, r1
    872c:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    872e:	25 e0       	ldi	r18, 0x05	; 5
    8730:	e2 2e       	mov	r14, r18
    8732:	f1 2c       	mov	r15, r1
    8734:	ec 0e       	add	r14, r28
    8736:	fd 1e       	adc	r15, r29
		_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    8738:	81 e0       	ldi	r24, 0x01	; 1
    873a:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    873e:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8740:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    8744:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    8746:	17 3e       	cpi	r17, 0xE7	; 231
    8748:	09 f4       	brne	.+2      	; 0x874c <_menu_host+0x19e>
    874a:	95 c0       	rjmp	.+298    	; 0x8876 <_menu_host+0x2c8>
			return;
		if(__key==_KEY_ENTER){
    874c:	17 3b       	cpi	r17, 0xB7	; 183
    874e:	09 f0       	breq	.+2      	; 0x8752 <_menu_host+0x1a4>
    8750:	30 c0       	rjmp	.+96     	; 0x87b2 <_menu_host+0x204>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    8752:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8754:	e1 99       	sbic	0x1c, 1	; 28
    8756:	fe cf       	rjmp	.-4      	; 0x8754 <_menu_host+0x1a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8758:	e1 ef       	ldi	r30, 0xF1	; 241
    875a:	f3 e0       	ldi	r31, 0x03	; 3
    875c:	ff bb       	out	0x1f, r31	; 31
    875e:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    8760:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8762:	0f b6       	in	r0, 0x3f	; 63
    8764:	f8 94       	cli
    8766:	e2 9a       	sbi	0x1c, 2	; 28
    8768:	e1 9a       	sbi	0x1c, 1	; 28
    876a:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&__date_time, __value[1]);
    876c:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    876e:	e1 99       	sbic	0x1c, 1	; 28
    8770:	fe cf       	rjmp	.-4      	; 0x876e <_menu_host+0x1c0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8772:	3f ba       	out	0x1f, r3	; 31
    8774:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    8776:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8778:	0f b6       	in	r0, 0x3f	; 63
    877a:	f8 94       	cli
    877c:	e2 9a       	sbi	0x1c, 2	; 28
    877e:	e1 9a       	sbi	0x1c, 1	; 28
    8780:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    8782:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8784:	e1 99       	sbic	0x1c, 1	; 28
    8786:	fe cf       	rjmp	.-4      	; 0x8784 <_menu_host+0x1d6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8788:	5f ba       	out	0x1f, r5	; 31
    878a:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    878c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    878e:	0f b6       	in	r0, 0x3f	; 63
    8790:	f8 94       	cli
    8792:	e2 9a       	sbi	0x1c, 2	; 28
    8794:	e1 9a       	sbi	0x1c, 1	; 28
    8796:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefIFT_ID,TermID);
    8798:	80 91 ec 02 	lds	r24, 0x02EC
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    879c:	e1 99       	sbic	0x1c, 1	; 28
    879e:	fe cf       	rjmp	.-4      	; 0x879c <_menu_host+0x1ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    87a0:	7f ba       	out	0x1f, r7	; 31
    87a2:	6e ba       	out	0x1e, r6	; 30
#endif
    EEDR = __value;
    87a4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    87a6:	0f b6       	in	r0, 0x3f	; 63
    87a8:	f8 94       	cli
    87aa:	e2 9a       	sbi	0x1c, 2	; 28
    87ac:	e1 9a       	sbi	0x1c, 1	; 28
    87ae:	0f be       	out	0x3f, r0	; 63
    87b0:	62 c0       	rjmp	.+196    	; 0x8876 <_menu_host+0x2c8>
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    87b2:	81 53       	subi	r24, 0x31	; 49
    87b4:	83 30       	cpi	r24, 0x03	; 3
    87b6:	58 f5       	brcc	.+86     	; 0x880e <_menu_host+0x260>
			if(__value[__num - 0x31] == 1)
    87b8:	a9 2f       	mov	r26, r25
    87ba:	b0 e0       	ldi	r27, 0x00	; 0
    87bc:	d1 97       	sbiw	r26, 0x31	; 49
    87be:	f6 01       	movw	r30, r12
    87c0:	ea 0f       	add	r30, r26
    87c2:	fb 1f       	adc	r31, r27
    87c4:	80 81       	ld	r24, Z
    87c6:	81 30       	cpi	r24, 0x01	; 1
    87c8:	11 f4       	brne	.+4      	; 0x87ce <_menu_host+0x220>
				__value[__num - 0x31] = 0;
    87ca:	10 82       	st	Z, r1
    87cc:	02 c0       	rjmp	.+4      	; 0x87d2 <_menu_host+0x224>
			else
				__value[__num - 0x31]++;
    87ce:	8f 5f       	subi	r24, 0xFF	; 255
    87d0:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    87d2:	29 2f       	mov	r18, r25
    87d4:	30 e0       	ldi	r19, 0x00	; 0
    87d6:	21 53       	subi	r18, 0x31	; 49
    87d8:	30 40       	sbci	r19, 0x00	; 0
    87da:	22 0f       	add	r18, r18
    87dc:	33 1f       	adc	r19, r19
    87de:	c9 01       	movw	r24, r18
    87e0:	86 5d       	subi	r24, 0xD6	; 214
    87e2:	9c 4f       	sbci	r25, 0xFC	; 252
    87e4:	fc 01       	movw	r30, r24
    87e6:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    87e8:	25 5d       	subi	r18, 0xD5	; 213
    87ea:	3c 4f       	sbci	r19, 0xFC	; 252
    87ec:	f9 01       	movw	r30, r18
    87ee:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    87f0:	ac 0d       	add	r26, r12
    87f2:	bd 1d       	adc	r27, r13
    87f4:	4c 91       	ld	r20, X
    87f6:	50 e0       	ldi	r21, 0x00	; 0
    87f8:	60 e0       	ldi	r22, 0x00	; 0
    87fa:	70 e0       	ldi	r23, 0x00	; 0
    87fc:	c7 01       	movw	r24, r14
    87fe:	0e 94 78 18 	call	0x30f0	; 0x30f0 <_f_inttostr>
			lcd_print(__x, __y, __buff);
    8802:	80 2f       	mov	r24, r16
    8804:	61 2f       	mov	r22, r17
    8806:	a7 01       	movw	r20, r14
    8808:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    880c:	95 cf       	rjmp	.-214    	; 0x8738 <_menu_host+0x18a>
		}else
		if (__num=='4'){
    880e:	94 33       	cpi	r25, 0x34	; 52
    8810:	09 f0       	breq	.+2      	; 0x8814 <_menu_host+0x266>
    8812:	92 cf       	rjmp	.-220    	; 0x8738 <_menu_host+0x18a>
		    if (TermID<=99)TermID++;
    8814:	80 91 ec 02 	lds	r24, 0x02EC
    8818:	84 36       	cpi	r24, 0x64	; 100
    881a:	10 f4       	brcc	.+4      	; 0x8820 <_menu_host+0x272>
    881c:	8f 5f       	subi	r24, 0xFF	; 255
    881e:	01 c0       	rjmp	.+2      	; 0x8822 <_menu_host+0x274>
			else TermID=1;
    8820:	81 e0       	ldi	r24, 0x01	; 1
    8822:	80 93 ec 02 	sts	0x02EC, r24
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8826:	00 d0       	rcall	.+0      	; 0x8828 <_menu_host+0x27a>
    8828:	00 d0       	rcall	.+0      	; 0x882a <_menu_host+0x27c>
    882a:	00 d0       	rcall	.+0      	; 0x882c <_menu_host+0x27e>
    882c:	ed b7       	in	r30, 0x3d	; 61
    882e:	fe b7       	in	r31, 0x3e	; 62
    8830:	31 96       	adiw	r30, 0x01	; 1
    8832:	ad b7       	in	r26, 0x3d	; 61
    8834:	be b7       	in	r27, 0x3e	; 62
    8836:	12 96       	adiw	r26, 0x02	; 2
    8838:	bc 92       	st	X, r11
    883a:	ae 92       	st	-X, r10
    883c:	11 97       	sbiw	r26, 0x01	; 1
    883e:	93 82       	std	Z+3, r9	; 0x03
    8840:	82 82       	std	Z+2, r8	; 0x02
    8842:	80 91 ec 02 	lds	r24, 0x02EC
    8846:	84 83       	std	Z+4, r24	; 0x04
    8848:	15 82       	std	Z+5, r1	; 0x05
    884a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    884e:	ed b7       	in	r30, 0x3d	; 61
    8850:	fe b7       	in	r31, 0x3e	; 62
    8852:	36 96       	adiw	r30, 0x06	; 6
    8854:	0f b6       	in	r0, 0x3f	; 63
    8856:	f8 94       	cli
    8858:	fe bf       	out	0x3e, r31	; 62
    885a:	0f be       	out	0x3f, r0	; 63
    885c:	ed bf       	out	0x3d, r30	; 61
    885e:	84 e0       	ldi	r24, 0x04	; 4
    8860:	61 e0       	ldi	r22, 0x01	; 1
    8862:	a5 01       	movw	r20, r10
    8864:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    8868:	84 e0       	ldi	r24, 0x04	; 4
    886a:	6f e0       	ldi	r22, 0x0F	; 15
    886c:	4b e2       	ldi	r20, 0x2B	; 43
    886e:	5c e0       	ldi	r21, 0x0C	; 12
    8870:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    8874:	61 cf       	rjmp	.-318    	; 0x8738 <_menu_host+0x18a>
		 
		}

	}
}
    8876:	6d 96       	adiw	r28, 0x1d	; 29
    8878:	0f b6       	in	r0, 0x3f	; 63
    887a:	f8 94       	cli
    887c:	de bf       	out	0x3e, r29	; 62
    887e:	0f be       	out	0x3f, r0	; 63
    8880:	cd bf       	out	0x3d, r28	; 61
    8882:	cf 91       	pop	r28
    8884:	df 91       	pop	r29
    8886:	1f 91       	pop	r17
    8888:	0f 91       	pop	r16
    888a:	ff 90       	pop	r15
    888c:	ef 90       	pop	r14
    888e:	df 90       	pop	r13
    8890:	cf 90       	pop	r12
    8892:	bf 90       	pop	r11
    8894:	af 90       	pop	r10
    8896:	9f 90       	pop	r9
    8898:	8f 90       	pop	r8
    889a:	7f 90       	pop	r7
    889c:	6f 90       	pop	r6
    889e:	5f 90       	pop	r5
    88a0:	4f 90       	pop	r4
    88a2:	3f 90       	pop	r3
    88a4:	2f 90       	pop	r2
    88a6:	08 95       	ret

000088a8 <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    88a8:	0e 94 d7 42 	call	0x85ae	; 0x85ae <_menu_host>
	 return MENU_DONE;
}
    88ac:	81 e0       	ldi	r24, 0x01	; 1
    88ae:	08 95       	ret

000088b0 <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    88b0:	84 e0       	ldi	r24, 0x04	; 4
    88b2:	61 e0       	ldi	r22, 0x01	; 1
    88b4:	42 e8       	ldi	r20, 0x82	; 130
    88b6:	51 e2       	ldi	r21, 0x21	; 33
    88b8:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    88bc:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    88be:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    88c0:	85 e0       	ldi	r24, 0x05	; 5
    88c2:	90 e0       	ldi	r25, 0x00	; 0
    88c4:	90 93 ed 01 	sts	0x01ED, r25
    88c8:	80 93 ec 01 	sts	0x01EC, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    88cc:	81 e0       	ldi	r24, 0x01	; 1
    88ce:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
		__num = _key_btn(__key);
    88d2:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    88d6:	80 53       	subi	r24, 0x30	; 48
    88d8:	8a 30       	cpi	r24, 0x0A	; 10
    88da:	20 f0       	brcs	.+8      	; 0x88e4 <system_stop+0x34>
    88dc:	80 91 c8 01 	lds	r24, 0x01C8
    88e0:	81 30       	cpi	r24, 0x01	; 1
    88e2:	a1 f7       	brne	.-24     	; 0x88cc <system_stop+0x1c>
    88e4:	08 95       	ret

000088e6 <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    88e6:	84 e0       	ldi	r24, 0x04	; 4
    88e8:	61 e0       	ldi	r22, 0x01	; 1
    88ea:	47 e9       	ldi	r20, 0x97	; 151
    88ec:	51 e2       	ldi	r21, 0x21	; 33
    88ee:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    88f2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    88f4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    88f6:	81 e0       	ldi	r24, 0x01	; 1
    88f8:	90 e0       	ldi	r25, 0x00	; 0
    88fa:	90 93 ed 01 	sts	0x01ED, r25
    88fe:	80 93 ec 01 	sts	0x01EC, r24
    8902:	80 e5       	ldi	r24, 0x50	; 80
    8904:	93 ec       	ldi	r25, 0xC3	; 195
    8906:	01 97       	sbiw	r24, 0x01	; 1
    8908:	f1 f7       	brne	.-4      	; 0x8906 <systemForceType+0x20>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    890a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    890c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    890e:	82 e0       	ldi	r24, 0x02	; 2
    8910:	90 e0       	ldi	r25, 0x00	; 0
    8912:	90 93 ed 01 	sts	0x01ED, r25
    8916:	80 93 ec 01 	sts	0x01EC, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    891a:	81 e0       	ldi	r24, 0x01	; 1
    891c:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    8920:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    8924:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    8926:	81 53       	subi	r24, 0x31	; 49
    8928:	82 30       	cpi	r24, 0x02	; 2
    892a:	b8 f7       	brcc	.-18     	; 0x891a <systemForceType+0x34>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    892c:	89 2f       	mov	r24, r25
    892e:	08 95       	ret

00008930 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    8930:	af 92       	push	r10
    8932:	bf 92       	push	r11
    8934:	cf 92       	push	r12
    8936:	df 92       	push	r13
    8938:	ef 92       	push	r14
    893a:	ff 92       	push	r15
    893c:	0f 93       	push	r16
    893e:	1f 93       	push	r17
    8940:	df 93       	push	r29
    8942:	cf 93       	push	r28
    8944:	cd b7       	in	r28, 0x3d	; 61
    8946:	de b7       	in	r29, 0x3e	; 62
    8948:	65 97       	sbiw	r28, 0x15	; 21
    894a:	0f b6       	in	r0, 0x3f	; 63
    894c:	f8 94       	cli
    894e:	de bf       	out	0x3e, r29	; 62
    8950:	0f be       	out	0x3f, r0	; 63
    8952:	cd bf       	out	0x3d, r28	; 61
    8954:	d8 2e       	mov	r13, r24
    8956:	c6 2e       	mov	r12, r22
    8958:	b4 2e       	mov	r11, r20
    895a:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    895c:	d8 01       	movw	r26, r16
    895e:	0d 90       	ld	r0, X+
    8960:	00 20       	and	r0, r0
    8962:	e9 f7       	brne	.-6      	; 0x895e <SetTotalizerData+0x2e>
    8964:	11 97       	sbiw	r26, 0x01	; 1
    8966:	a0 1b       	sub	r26, r16
    8968:	b1 0b       	sbc	r27, r17
    896a:	87 e0       	ldi	r24, 0x07	; 7
    896c:	e8 2e       	mov	r14, r24
    896e:	f1 2c       	mov	r15, r1
    8970:	ec 0e       	add	r14, r28
    8972:	fd 1e       	adc	r15, r29
    8974:	ad 30       	cpi	r26, 0x0D	; 13
    8976:	b1 05       	cpc	r27, r1
    8978:	58 f5       	brcc	.+86     	; 0x89d0 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    897a:	00 d0       	rcall	.+0      	; 0x897c <SetTotalizerData+0x4c>
    897c:	00 d0       	rcall	.+0      	; 0x897e <SetTotalizerData+0x4e>
    897e:	00 d0       	rcall	.+0      	; 0x8980 <SetTotalizerData+0x50>
    8980:	ed b7       	in	r30, 0x3d	; 61
    8982:	fe b7       	in	r31, 0x3e	; 62
    8984:	31 96       	adiw	r30, 0x01	; 1
    8986:	ad b7       	in	r26, 0x3d	; 61
    8988:	be b7       	in	r27, 0x3e	; 62
    898a:	12 96       	adiw	r26, 0x02	; 2
    898c:	fc 92       	st	X, r15
    898e:	ee 92       	st	-X, r14
    8990:	11 97       	sbiw	r26, 0x01	; 1
    8992:	8a e6       	ldi	r24, 0x6A	; 106
    8994:	96 e0       	ldi	r25, 0x06	; 6
    8996:	93 83       	std	Z+3, r25	; 0x03
    8998:	82 83       	std	Z+2, r24	; 0x02
    899a:	15 83       	std	Z+5, r17	; 0x05
    899c:	04 83       	std	Z+4, r16	; 0x04
    899e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    89a2:	f7 01       	movw	r30, r14
    89a4:	01 90       	ld	r0, Z+
    89a6:	00 20       	and	r0, r0
    89a8:	e9 f7       	brne	.-6      	; 0x89a4 <SetTotalizerData+0x74>
    89aa:	31 97       	sbiw	r30, 0x01	; 1
    89ac:	ee 19       	sub	r30, r14
    89ae:	ff 09       	sbc	r31, r15
    89b0:	6d b7       	in	r22, 0x3d	; 61
    89b2:	7e b7       	in	r23, 0x3e	; 62
    89b4:	6a 5f       	subi	r22, 0xFA	; 250
    89b6:	7f 4f       	sbci	r23, 0xFF	; 255
    89b8:	0f b6       	in	r0, 0x3f	; 63
    89ba:	f8 94       	cli
    89bc:	7e bf       	out	0x3e, r23	; 62
    89be:	0f be       	out	0x3f, r0	; 63
    89c0:	6d bf       	out	0x3d, r22	; 61
    89c2:	3c 97       	sbiw	r30, 0x0c	; 12
    89c4:	a0 f4       	brcc	.+40     	; 0x89ee <SetTotalizerData+0xbe>
    89c6:	c7 01       	movw	r24, r14
    89c8:	6c e0       	ldi	r22, 0x0C	; 12
    89ca:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <AddZeroLead>
    89ce:	0f c0       	rjmp	.+30     	; 0x89ee <SetTotalizerData+0xbe>
    89d0:	8a 2f       	mov	r24, r26
    89d2:	8c 50       	subi	r24, 0x0C	; 12
    89d4:	f8 01       	movw	r30, r16
    89d6:	e8 0f       	add	r30, r24
    89d8:	f1 1d       	adc	r31, r1
    89da:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    89dc:	9e 01       	movw	r18, r28
    89de:	2d 5e       	subi	r18, 0xED	; 237
    89e0:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    89e2:	81 91       	ld	r24, Z+
    89e4:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    89e6:	a2 17       	cp	r26, r18
    89e8:	b3 07       	cpc	r27, r19
    89ea:	d9 f7       	brne	.-10     	; 0x89e2 <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    89ec:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    89ee:	0b 2d       	mov	r16, r11
    89f0:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    89f2:	1a 2d       	mov	r17, r10
    89f4:	11 50       	subi	r17, 0x01	; 1
    89f6:	16 30       	cpi	r17, 0x06	; 6
    89f8:	08 f0       	brcs	.+2      	; 0x89fc <SetTotalizerData+0xcc>
    89fa:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    89fc:	ce 01       	movw	r24, r28
    89fe:	07 96       	adiw	r24, 0x07	; 7
    8a00:	7e 01       	movw	r14, r28
    8a02:	08 94       	sec
    8a04:	e1 1c       	adc	r14, r1
    8a06:	f1 1c       	adc	r15, r1
    8a08:	b7 01       	movw	r22, r14
    8a0a:	0e 94 e7 18 	call	0x31ce	; 0x31ce <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    8a0e:	dd 20       	and	r13, r13
    8a10:	d9 f4       	brne	.+54     	; 0x8a48 <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8a12:	84 e2       	ldi	r24, 0x24	; 36
    8a14:	08 9f       	mul	r16, r24
    8a16:	c0 01       	movw	r24, r0
    8a18:	11 24       	eor	r1, r1
    8a1a:	4c 2d       	mov	r20, r12
    8a1c:	50 e0       	ldi	r21, 0x00	; 0
    8a1e:	20 e2       	ldi	r18, 0x20	; 32
    8a20:	31 e0       	ldi	r19, 0x01	; 1
    8a22:	d9 01       	movw	r26, r18
    8a24:	4a 9f       	mul	r20, r26
    8a26:	90 01       	movw	r18, r0
    8a28:	4b 9f       	mul	r20, r27
    8a2a:	30 0d       	add	r19, r0
    8a2c:	5a 9f       	mul	r21, r26
    8a2e:	30 0d       	add	r19, r0
    8a30:	11 24       	eor	r1, r1
    8a32:	82 0f       	add	r24, r18
    8a34:	93 1f       	adc	r25, r19
    8a36:	26 e0       	ldi	r18, 0x06	; 6
    8a38:	12 9f       	mul	r17, r18
    8a3a:	90 01       	movw	r18, r0
    8a3c:	11 24       	eor	r1, r1
    8a3e:	82 0f       	add	r24, r18
    8a40:	93 1f       	adc	r25, r19
    8a42:	8d 50       	subi	r24, 0x0D	; 13
    8a44:	9c 4f       	sbci	r25, 0xFC	; 252
    8a46:	1d c0       	rjmp	.+58     	; 0x8a82 <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    8a48:	b1 e0       	ldi	r27, 0x01	; 1
    8a4a:	db 16       	cp	r13, r27
    8a4c:	09 f5       	brne	.+66     	; 0x8a90 <SetTotalizerData+0x160>
    8a4e:	84 e2       	ldi	r24, 0x24	; 36
    8a50:	08 9f       	mul	r16, r24
    8a52:	c0 01       	movw	r24, r0
    8a54:	11 24       	eor	r1, r1
    8a56:	4c 2d       	mov	r20, r12
    8a58:	50 e0       	ldi	r21, 0x00	; 0
    8a5a:	20 e2       	ldi	r18, 0x20	; 32
    8a5c:	31 e0       	ldi	r19, 0x01	; 1
    8a5e:	b9 01       	movw	r22, r18
    8a60:	46 9f       	mul	r20, r22
    8a62:	90 01       	movw	r18, r0
    8a64:	47 9f       	mul	r20, r23
    8a66:	30 0d       	add	r19, r0
    8a68:	56 9f       	mul	r21, r22
    8a6a:	30 0d       	add	r19, r0
    8a6c:	11 24       	eor	r1, r1
    8a6e:	82 0f       	add	r24, r18
    8a70:	93 1f       	adc	r25, r19
    8a72:	26 e0       	ldi	r18, 0x06	; 6
    8a74:	12 9f       	mul	r17, r18
    8a76:	90 01       	movw	r18, r0
    8a78:	11 24       	eor	r1, r1
    8a7a:	82 0f       	add	r24, r18
    8a7c:	93 1f       	adc	r25, r19
    8a7e:	8d 5c       	subi	r24, 0xCD	; 205
    8a80:	99 4f       	sbci	r25, 0xF9	; 249
    8a82:	b7 01       	movw	r22, r14
    8a84:	46 e0       	ldi	r20, 0x06	; 6
    8a86:	50 e0       	ldi	r21, 0x00	; 0
    8a88:	2f e9       	ldi	r18, 0x9F	; 159
    8a8a:	32 e1       	ldi	r19, 0x12	; 18
    8a8c:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
}
    8a90:	65 96       	adiw	r28, 0x15	; 21
    8a92:	0f b6       	in	r0, 0x3f	; 63
    8a94:	f8 94       	cli
    8a96:	de bf       	out	0x3e, r29	; 62
    8a98:	0f be       	out	0x3f, r0	; 63
    8a9a:	cd bf       	out	0x3d, r28	; 61
    8a9c:	cf 91       	pop	r28
    8a9e:	df 91       	pop	r29
    8aa0:	1f 91       	pop	r17
    8aa2:	0f 91       	pop	r16
    8aa4:	ff 90       	pop	r15
    8aa6:	ef 90       	pop	r14
    8aa8:	df 90       	pop	r13
    8aaa:	cf 90       	pop	r12
    8aac:	bf 90       	pop	r11
    8aae:	af 90       	pop	r10
    8ab0:	08 95       	ret

00008ab2 <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    8ab2:	4f 92       	push	r4
    8ab4:	5f 92       	push	r5
    8ab6:	7f 92       	push	r7
    8ab8:	8f 92       	push	r8
    8aba:	9f 92       	push	r9
    8abc:	af 92       	push	r10
    8abe:	bf 92       	push	r11
    8ac0:	cf 92       	push	r12
    8ac2:	df 92       	push	r13
    8ac4:	ef 92       	push	r14
    8ac6:	ff 92       	push	r15
    8ac8:	0f 93       	push	r16
    8aca:	1f 93       	push	r17
    8acc:	df 93       	push	r29
    8ace:	cf 93       	push	r28
    8ad0:	cd b7       	in	r28, 0x3d	; 61
    8ad2:	de b7       	in	r29, 0x3e	; 62
    8ad4:	2f 97       	sbiw	r28, 0x0f	; 15
    8ad6:	0f b6       	in	r0, 0x3f	; 63
    8ad8:	f8 94       	cli
    8ada:	de bf       	out	0x3e, r29	; 62
    8adc:	0f be       	out	0x3f, r0	; 63
    8ade:	cd bf       	out	0x3d, r28	; 61
    8ae0:	77 24       	eor	r7, r7
    8ae2:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8ae4:	4e 01       	movw	r8, r28
    8ae6:	08 94       	sec
    8ae8:	81 1c       	adc	r8, r1
    8aea:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8aec:	90 e1       	ldi	r25, 0x10	; 16
    8aee:	49 2e       	mov	r4, r25
    8af0:	51 2c       	mov	r5, r1
    8af2:	4c 0e       	add	r4, r28
    8af4:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    8af6:	87 2d       	mov	r24, r7
    8af8:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
		  if (FIPAddr>0){
    8afc:	88 23       	and	r24, r24
    8afe:	91 f1       	breq	.+100    	; 0x8b64 <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    8b00:	a8 2e       	mov	r10, r24
    8b02:	aa 94       	dec	r10
    8b04:	bb 24       	eor	r11, r11
    8b06:	b3 94       	inc	r11
    8b08:	2a c0       	rjmp	.+84     	; 0x8b5e <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    8b0a:	f7 01       	movw	r30, r14
    8b0c:	11 92       	st	Z+, r1
    8b0e:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b10:	e4 15       	cp	r30, r4
    8b12:	f5 05       	cpc	r31, r5
    8b14:	d1 f7       	brne	.-12     	; 0x8b0a <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    8b16:	80 e0       	ldi	r24, 0x00	; 0
    8b18:	61 e0       	ldi	r22, 0x01	; 1
    8b1a:	4a 2d       	mov	r20, r10
    8b1c:	2b 2d       	mov	r18, r11
    8b1e:	84 01       	movw	r16, r8
    8b20:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    8b24:	80 e0       	ldi	r24, 0x00	; 0
    8b26:	60 e0       	ldi	r22, 0x00	; 0
    8b28:	4a 2d       	mov	r20, r10
    8b2a:	2b 2d       	mov	r18, r11
    8b2c:	0e 94 98 44 	call	0x8930	; 0x8930 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    8b30:	f6 01       	movw	r30, r12
    8b32:	11 92       	st	Z+, r1
    8b34:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b36:	ee 15       	cp	r30, r14
    8b38:	ff 05       	cpc	r31, r15
    8b3a:	d1 f7       	brne	.-12     	; 0x8b30 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    8b3c:	81 e0       	ldi	r24, 0x01	; 1
    8b3e:	61 e0       	ldi	r22, 0x01	; 1
    8b40:	4a 2d       	mov	r20, r10
    8b42:	2b 2d       	mov	r18, r11
    8b44:	84 01       	movw	r16, r8
    8b46:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    8b4a:	81 e0       	ldi	r24, 0x01	; 1
    8b4c:	60 e0       	ldi	r22, 0x00	; 0
    8b4e:	4a 2d       	mov	r20, r10
    8b50:	2b 2d       	mov	r18, r11
    8b52:	0e 94 98 44 	call	0x8930	; 0x8930 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8b56:	b3 94       	inc	r11
    8b58:	f7 e0       	ldi	r31, 0x07	; 7
    8b5a:	bf 16       	cp	r11, r31
    8b5c:	19 f0       	breq	.+6      	; 0x8b64 <SaveTotalizerCurrentToLast+0xb2>
    8b5e:	64 01       	movw	r12, r8
    8b60:	74 01       	movw	r14, r8
    8b62:	d3 cf       	rjmp	.-90     	; 0x8b0a <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    8b64:	73 94       	inc	r7
    8b66:	81 e1       	ldi	r24, 0x11	; 17
    8b68:	78 16       	cp	r7, r24
    8b6a:	29 f6       	brne	.-118    	; 0x8af6 <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    8b6c:	2f 96       	adiw	r28, 0x0f	; 15
    8b6e:	0f b6       	in	r0, 0x3f	; 63
    8b70:	f8 94       	cli
    8b72:	de bf       	out	0x3e, r29	; 62
    8b74:	0f be       	out	0x3f, r0	; 63
    8b76:	cd bf       	out	0x3d, r28	; 61
    8b78:	cf 91       	pop	r28
    8b7a:	df 91       	pop	r29
    8b7c:	1f 91       	pop	r17
    8b7e:	0f 91       	pop	r16
    8b80:	ff 90       	pop	r15
    8b82:	ef 90       	pop	r14
    8b84:	df 90       	pop	r13
    8b86:	cf 90       	pop	r12
    8b88:	bf 90       	pop	r11
    8b8a:	af 90       	pop	r10
    8b8c:	9f 90       	pop	r9
    8b8e:	8f 90       	pop	r8
    8b90:	7f 90       	pop	r7
    8b92:	5f 90       	pop	r5
    8b94:	4f 90       	pop	r4
    8b96:	08 95       	ret

00008b98 <ResetTotalizer>:
}

//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    8b98:	af 92       	push	r10
    8b9a:	bf 92       	push	r11
    8b9c:	cf 92       	push	r12
    8b9e:	df 92       	push	r13
    8ba0:	ef 92       	push	r14
    8ba2:	ff 92       	push	r15
    8ba4:	0f 93       	push	r16
    8ba6:	1f 93       	push	r17
    8ba8:	df 93       	push	r29
    8baa:	cf 93       	push	r28
    8bac:	cd b7       	in	r28, 0x3d	; 61
    8bae:	de b7       	in	r29, 0x3e	; 62
    8bb0:	29 97       	sbiw	r28, 0x09	; 9
    8bb2:	0f b6       	in	r0, 0x3f	; 63
    8bb4:	f8 94       	cli
    8bb6:	de bf       	out	0x3e, r29	; 62
    8bb8:	0f be       	out	0x3f, r0	; 63
    8bba:	cd bf       	out	0x3d, r28	; 61
    8bbc:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    8bbe:	00 d0       	rcall	.+0      	; 0x8bc0 <ResetTotalizer+0x28>
    8bc0:	00 d0       	rcall	.+0      	; 0x8bc2 <ResetTotalizer+0x2a>
    8bc2:	6e 01       	movw	r12, r28
    8bc4:	08 94       	sec
    8bc6:	c1 1c       	adc	r12, r1
    8bc8:	d1 1c       	adc	r13, r1
    8bca:	ed b7       	in	r30, 0x3d	; 61
    8bcc:	fe b7       	in	r31, 0x3e	; 62
    8bce:	d2 82       	std	Z+2, r13	; 0x02
    8bd0:	c1 82       	std	Z+1, r12	; 0x01
    8bd2:	8d e6       	ldi	r24, 0x6D	; 109
    8bd4:	96 e0       	ldi	r25, 0x06	; 6
    8bd6:	94 83       	std	Z+4, r25	; 0x04
    8bd8:	83 83       	std	Z+3, r24	; 0x03
    8bda:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    8bde:	ee 24       	eor	r14, r14
    8be0:	e3 94       	inc	r14
    8be2:	0f 90       	pop	r0
    8be4:	0f 90       	pop	r0
    8be6:	0f 90       	pop	r0
    8be8:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    8bea:	8e 2d       	mov	r24, r14
    8bec:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
		  if (FIPAddr>0){
    8bf0:	88 23       	and	r24, r24
    8bf2:	a9 f0       	breq	.+42     	; 0x8c1e <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    8bf4:	b8 2e       	mov	r11, r24
    8bf6:	ba 94       	dec	r11
    8bf8:	ff 24       	eor	r15, r15
    8bfa:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    8bfc:	80 e0       	ldi	r24, 0x00	; 0
    8bfe:	6a 2d       	mov	r22, r10
    8c00:	4b 2d       	mov	r20, r11
    8c02:	2f 2d       	mov	r18, r15
    8c04:	86 01       	movw	r16, r12
    8c06:	0e 94 98 44 	call	0x8930	; 0x8930 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    8c0a:	81 e0       	ldi	r24, 0x01	; 1
    8c0c:	6a 2d       	mov	r22, r10
    8c0e:	4b 2d       	mov	r20, r11
    8c10:	2f 2d       	mov	r18, r15
    8c12:	0e 94 98 44 	call	0x8930	; 0x8930 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8c16:	f3 94       	inc	r15
    8c18:	f7 e0       	ldi	r31, 0x07	; 7
    8c1a:	ff 16       	cp	r15, r31
    8c1c:	79 f7       	brne	.-34     	; 0x8bfc <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    8c1e:	e3 94       	inc	r14
    8c20:	81 e1       	ldi	r24, 0x11	; 17
    8c22:	e8 16       	cp	r14, r24
    8c24:	11 f7       	brne	.-60     	; 0x8bea <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    8c26:	29 96       	adiw	r28, 0x09	; 9
    8c28:	0f b6       	in	r0, 0x3f	; 63
    8c2a:	f8 94       	cli
    8c2c:	de bf       	out	0x3e, r29	; 62
    8c2e:	0f be       	out	0x3f, r0	; 63
    8c30:	cd bf       	out	0x3d, r28	; 61
    8c32:	cf 91       	pop	r28
    8c34:	df 91       	pop	r29
    8c36:	1f 91       	pop	r17
    8c38:	0f 91       	pop	r16
    8c3a:	ff 90       	pop	r15
    8c3c:	ef 90       	pop	r14
    8c3e:	df 90       	pop	r13
    8c40:	cf 90       	pop	r12
    8c42:	bf 90       	pop	r11
    8c44:	af 90       	pop	r10
    8c46:	08 95       	ret

00008c48 <procMessage21>:
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}

char procMessage21(){
    8c48:	af 92       	push	r10
    8c4a:	bf 92       	push	r11
    8c4c:	cf 92       	push	r12
    8c4e:	df 92       	push	r13
    8c50:	ef 92       	push	r14
    8c52:	ff 92       	push	r15
    8c54:	0f 93       	push	r16
    8c56:	1f 93       	push	r17
    8c58:	df 93       	push	r29
    8c5a:	cf 93       	push	r28
    8c5c:	cd b7       	in	r28, 0x3d	; 61
    8c5e:	de b7       	in	r29, 0x3e	; 62
    8c60:	2b 97       	sbiw	r28, 0x0b	; 11
    8c62:	0f b6       	in	r0, 0x3f	; 63
    8c64:	f8 94       	cli
    8c66:	de bf       	out	0x3e, r29	; 62
    8c68:	0f be       	out	0x3f, r0	; 63
    8c6a:	cd bf       	out	0x3d, r28	; 61
    8c6c:	09 e3       	ldi	r16, 0x39	; 57
    8c6e:	11 e0       	ldi	r17, 0x01	; 1
    8c70:	35 e4       	ldi	r19, 0x45	; 69
    8c72:	e3 2e       	mov	r14, r19
    8c74:	3b e0       	ldi	r19, 0x0B	; 11
    8c76:	f3 2e       	mov	r15, r19
    8c78:	6e 01       	movw	r12, r28
    8c7a:	08 94       	sec
    8c7c:	c1 1c       	adc	r12, r1
    8c7e:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8c80:	2b e0       	ldi	r18, 0x0B	; 11
    8c82:	a2 2e       	mov	r10, r18
    8c84:	b1 2c       	mov	r11, r1
    8c86:	ac 0e       	add	r10, r28
    8c88:	bd 1e       	adc	r11, r29
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}

char procMessage21(){
    8c8a:	f6 01       	movw	r30, r12
    8c8c:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8c8e:	8d 91       	ld	r24, X+
    8c90:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8c92:	ea 15       	cp	r30, r10
    8c94:	fb 05       	cpc	r31, r11
    8c96:	d9 f7       	brne	.-10     	; 0x8c8e <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8c98:	1b 86       	std	Y+11, r1	; 0x0b
    8c9a:	c8 01       	movw	r24, r16
    8c9c:	b6 01       	movw	r22, r12
    8c9e:	4b e0       	ldi	r20, 0x0B	; 11
    8ca0:	50 e0       	ldi	r21, 0x00	; 0
    8ca2:	2f e9       	ldi	r18, 0x9F	; 159
    8ca4:	32 e1       	ldi	r19, 0x12	; 18
    8ca6:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    8caa:	05 5f       	subi	r16, 0xF5	; 245
    8cac:	1f 4f       	sbci	r17, 0xFF	; 255
    8cae:	8a e0       	ldi	r24, 0x0A	; 10
    8cb0:	90 e0       	ldi	r25, 0x00	; 0
    8cb2:	e8 0e       	add	r14, r24
    8cb4:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    8cb6:	91 e0       	ldi	r25, 0x01	; 1
    8cb8:	05 36       	cpi	r16, 0x65	; 101
    8cba:	19 07       	cpc	r17, r25
    8cbc:	31 f7       	brne	.-52     	; 0x8c8a <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    8cbe:	80 e0       	ldi	r24, 0x00	; 0
    8cc0:	2b 96       	adiw	r28, 0x0b	; 11
    8cc2:	0f b6       	in	r0, 0x3f	; 63
    8cc4:	f8 94       	cli
    8cc6:	de bf       	out	0x3e, r29	; 62
    8cc8:	0f be       	out	0x3f, r0	; 63
    8cca:	cd bf       	out	0x3d, r28	; 61
    8ccc:	cf 91       	pop	r28
    8cce:	df 91       	pop	r29
    8cd0:	1f 91       	pop	r17
    8cd2:	0f 91       	pop	r16
    8cd4:	ff 90       	pop	r15
    8cd6:	ef 90       	pop	r14
    8cd8:	df 90       	pop	r13
    8cda:	cf 90       	pop	r12
    8cdc:	bf 90       	pop	r11
    8cde:	af 90       	pop	r10
    8ce0:	08 95       	ret

00008ce2 <SaveToEEPROM>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    8ce2:	ef 92       	push	r14
    8ce4:	ff 92       	push	r15
    8ce6:	0f 93       	push	r16
    8ce8:	1f 93       	push	r17
    8cea:	df 93       	push	r29
    8cec:	cf 93       	push	r28
    8cee:	cd b7       	in	r28, 0x3d	; 61
    8cf0:	de b7       	in	r29, 0x3e	; 62
    8cf2:	ac 97       	sbiw	r28, 0x2c	; 44
    8cf4:	0f b6       	in	r0, 0x3f	; 63
    8cf6:	f8 94       	cli
    8cf8:	de bf       	out	0x3e, r29	; 62
    8cfa:	0f be       	out	0x3f, r0	; 63
    8cfc:	cd bf       	out	0x3d, r28	; 61
    8cfe:	9a a7       	std	Y+42, r25	; 0x2a
    8d00:	89 a7       	std	Y+41, r24	; 0x29
    8d02:	7c a7       	std	Y+44, r23	; 0x2c
    8d04:	6b a7       	std	Y+43, r22	; 0x2b
    8d06:	7a 01       	movw	r14, r20
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8d08:	8e 01       	movw	r16, r28
    8d0a:	05 5d       	subi	r16, 0xD5	; 213
    8d0c:	1f 4f       	sbci	r17, 0xFF	; 255
    8d0e:	c8 01       	movw	r24, r16
    8d10:	be 01       	movw	r22, r28
    8d12:	6f 5f       	subi	r22, 0xFF	; 255
    8d14:	7f 4f       	sbci	r23, 0xFF	; 255
    8d16:	27 e9       	ldi	r18, 0x97	; 151
    8d18:	32 e1       	ldi	r19, 0x12	; 18
    8d1a:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8d1e:	c8 01       	movw	r24, r16
    8d20:	be 01       	movw	r22, r28
    8d22:	67 5d       	subi	r22, 0xD7	; 215
    8d24:	7f 4f       	sbci	r23, 0xFF	; 255
    8d26:	a7 01       	movw	r20, r14
    8d28:	2f e9       	ldi	r18, 0x9F	; 159
    8d2a:	32 e1       	ldi	r19, 0x12	; 18
    8d2c:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    8d30:	ac 96       	adiw	r28, 0x2c	; 44
    8d32:	0f b6       	in	r0, 0x3f	; 63
    8d34:	f8 94       	cli
    8d36:	de bf       	out	0x3e, r29	; 62
    8d38:	0f be       	out	0x3f, r0	; 63
    8d3a:	cd bf       	out	0x3d, r28	; 61
    8d3c:	cf 91       	pop	r28
    8d3e:	df 91       	pop	r29
    8d40:	1f 91       	pop	r17
    8d42:	0f 91       	pop	r16
    8d44:	ff 90       	pop	r15
    8d46:	ef 90       	pop	r14
    8d48:	08 95       	ret

00008d4a <_menu_pumpprodinput>:
//**********************************************************************
// subrutin merubah produk
// parameter di simpan di __pump_prod
//**********************************************************************

void _menu_pumpprodinput(unsigned char __select){
    8d4a:	8f 92       	push	r8
    8d4c:	9f 92       	push	r9
    8d4e:	af 92       	push	r10
    8d50:	bf 92       	push	r11
    8d52:	cf 92       	push	r12
    8d54:	df 92       	push	r13
    8d56:	ef 92       	push	r14
    8d58:	ff 92       	push	r15
    8d5a:	0f 93       	push	r16
    8d5c:	1f 93       	push	r17
    8d5e:	df 93       	push	r29
    8d60:	cf 93       	push	r28
    8d62:	cd b7       	in	r28, 0x3d	; 61
    8d64:	de b7       	in	r29, 0x3e	; 62
    8d66:	a7 97       	sbiw	r28, 0x27	; 39
    8d68:	0f b6       	in	r0, 0x3f	; 63
    8d6a:	f8 94       	cli
    8d6c:	de bf       	out	0x3e, r29	; 62
    8d6e:	0f be       	out	0x3f, r0	; 63
    8d70:	cd bf       	out	0x3d, r28	; 61
    8d72:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8d74:	8e 01       	movw	r16, r28
    8d76:	04 5f       	subi	r16, 0xF4	; 244
    8d78:	1f 4f       	sbci	r17, 0xFF	; 255
    8d7a:	c8 01       	movw	r24, r16
    8d7c:	65 e4       	ldi	r22, 0x45	; 69
    8d7e:	70 e0       	ldi	r23, 0x00	; 0
    8d80:	48 e0       	ldi	r20, 0x08	; 8
    8d82:	50 e0       	ldi	r21, 0x00	; 0
    8d84:	27 e9       	ldi	r18, 0x97	; 151
    8d86:	32 e1       	ldi	r19, 0x12	; 18
    8d88:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    8d8c:	86 e0       	ldi	r24, 0x06	; 6
    8d8e:	b8 9e       	mul	r11, r24
    8d90:	40 01       	movw	r8, r0
    8d92:	11 24       	eor	r1, r1
    8d94:	85 e5       	ldi	r24, 0x55	; 85
    8d96:	90 e0       	ldi	r25, 0x00	; 0
    8d98:	88 0e       	add	r8, r24
    8d9a:	99 1e       	adc	r9, r25
    8d9c:	e6 e0       	ldi	r30, 0x06	; 6
    8d9e:	ce 2e       	mov	r12, r30
    8da0:	d1 2c       	mov	r13, r1
    8da2:	cc 0e       	add	r12, r28
    8da4:	dd 1e       	adc	r13, r29
    8da6:	c6 01       	movw	r24, r12
    8da8:	b4 01       	movw	r22, r8
    8daa:	46 e0       	ldi	r20, 0x06	; 6
    8dac:	50 e0       	ldi	r21, 0x00	; 0
    8dae:	27 e9       	ldi	r18, 0x97	; 151
    8db0:	32 e1       	ldi	r19, 0x12	; 18
    8db2:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>

	lcd_clear();_delay_ms(10);
    8db6:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    8dba:	84 ec       	ldi	r24, 0xC4	; 196
    8dbc:	99 e0       	ldi	r25, 0x09	; 9
    8dbe:	01 97       	sbiw	r24, 0x01	; 1
    8dc0:	f1 f7       	brne	.-4      	; 0x8dbe <_menu_pumpprodinput+0x74>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    8dc2:	00 d0       	rcall	.+0      	; 0x8dc4 <_menu_pumpprodinput+0x7a>
    8dc4:	00 d0       	rcall	.+0      	; 0x8dc6 <_menu_pumpprodinput+0x7c>
    8dc6:	00 d0       	rcall	.+0      	; 0x8dc8 <_menu_pumpprodinput+0x7e>
    8dc8:	ed b7       	in	r30, 0x3d	; 61
    8dca:	fe b7       	in	r31, 0x3e	; 62
    8dcc:	31 96       	adiw	r30, 0x01	; 1
    8dce:	74 e1       	ldi	r23, 0x14	; 20
    8dd0:	e7 2e       	mov	r14, r23
    8dd2:	f1 2c       	mov	r15, r1
    8dd4:	ec 0e       	add	r14, r28
    8dd6:	fd 1e       	adc	r15, r29
    8dd8:	ad b7       	in	r26, 0x3d	; 61
    8dda:	be b7       	in	r27, 0x3e	; 62
    8ddc:	12 96       	adiw	r26, 0x02	; 2
    8dde:	fc 92       	st	X, r15
    8de0:	ee 92       	st	-X, r14
    8de2:	11 97       	sbiw	r26, 0x01	; 1
    8de4:	84 e2       	ldi	r24, 0x24	; 36
    8de6:	9d e0       	ldi	r25, 0x0D	; 13
    8de8:	93 83       	std	Z+3, r25	; 0x03
    8dea:	82 83       	std	Z+2, r24	; 0x02
    8dec:	0b 0d       	add	r16, r11
    8dee:	11 1d       	adc	r17, r1
    8df0:	d8 01       	movw	r26, r16
    8df2:	8c 91       	ld	r24, X
    8df4:	84 83       	std	Z+4, r24	; 0x04
    8df6:	15 82       	std	Z+5, r1	; 0x05
    8df8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    lcd_print(1, 1,lcdteks);
    8dfc:	ed b7       	in	r30, 0x3d	; 61
    8dfe:	fe b7       	in	r31, 0x3e	; 62
    8e00:	36 96       	adiw	r30, 0x06	; 6
    8e02:	0f b6       	in	r0, 0x3f	; 63
    8e04:	f8 94       	cli
    8e06:	fe bf       	out	0x3e, r31	; 62
    8e08:	0f be       	out	0x3f, r0	; 63
    8e0a:	ed bf       	out	0x3d, r30	; 61
    8e0c:	81 e0       	ldi	r24, 0x01	; 1
    8e0e:	61 e0       	ldi	r22, 0x01	; 1
    8e10:	a7 01       	movw	r20, r14
    8e12:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    8e16:	82 e0       	ldi	r24, 0x02	; 2
    8e18:	61 e0       	ldi	r22, 0x01	; 1
    8e1a:	40 e1       	ldi	r20, 0x10	; 16
    8e1c:	5d e0       	ldi	r21, 0x0D	; 13
    8e1e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    8e22:	83 e0       	ldi	r24, 0x03	; 3
    8e24:	61 e0       	ldi	r22, 0x01	; 1
    8e26:	4c ef       	ldi	r20, 0xFC	; 252
    8e28:	5c e0       	ldi	r21, 0x0C	; 12
    8e2a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    8e2e:	84 e0       	ldi	r24, 0x04	; 4
    8e30:	61 e0       	ldi	r22, 0x01	; 1
    8e32:	47 ee       	ldi	r20, 0xE7	; 231
    8e34:	5c e0       	ldi	r21, 0x0C	; 12
    8e36:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    8e3a:	6c ef       	ldi	r22, 0xFC	; 252
    8e3c:	e6 2e       	mov	r14, r22
    8e3e:	62 e0       	ldi	r22, 0x02	; 2
    8e40:	f6 2e       	mov	r15, r22

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
		__y = pgm_read_byte(&__prodloc[__i][1]);
		_f_inttostr(__buff, __pump_prod[__i]);
    8e42:	5e 01       	movw	r10, r28
    8e44:	08 94       	sec
    8e46:	a1 1c       	adc	r10, r1
    8e48:	b1 1c       	adc	r11, r1
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
    8e4a:	f7 01       	movw	r30, r14
    8e4c:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[__i][1]);
    8e4e:	08 94       	sec
    8e50:	e1 1c       	adc	r14, r1
    8e52:	f1 1c       	adc	r15, r1
    8e54:	f7 01       	movw	r30, r14
    8e56:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __pump_prod[__i]);
    8e58:	d6 01       	movw	r26, r12
    8e5a:	4d 91       	ld	r20, X+
    8e5c:	6d 01       	movw	r12, r26
    8e5e:	50 e0       	ldi	r21, 0x00	; 0
    8e60:	60 e0       	ldi	r22, 0x00	; 0
    8e62:	70 e0       	ldi	r23, 0x00	; 0
    8e64:	c5 01       	movw	r24, r10
    8e66:	0e 94 78 18 	call	0x30f0	; 0x30f0 <_f_inttostr>
		lcd_print(__x+1, __y, __buff);
    8e6a:	80 2f       	mov	r24, r16
    8e6c:	8f 5f       	subi	r24, 0xFF	; 255
    8e6e:	61 2f       	mov	r22, r17
    8e70:	a5 01       	movw	r20, r10
    8e72:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    8e76:	08 94       	sec
    8e78:	e1 1c       	adc	r14, r1
    8e7a:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
    8e7c:	b8 e0       	ldi	r27, 0x08	; 8
    8e7e:	eb 16       	cp	r14, r27
    8e80:	b3 e0       	ldi	r27, 0x03	; 3
    8e82:	fb 06       	cpc	r15, r27
    8e84:	11 f7       	brne	.-60     	; 0x8e4a <_menu_pumpprodinput+0x100>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    8e86:	56 e0       	ldi	r21, 0x06	; 6
    8e88:	c5 2e       	mov	r12, r21
    8e8a:	d1 2c       	mov	r13, r1
    8e8c:	cc 0e       	add	r12, r28
    8e8e:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    8e90:	7e 01       	movw	r14, r28
    8e92:	08 94       	sec
    8e94:	e1 1c       	adc	r14, r1
    8e96:	f1 1c       	adc	r15, r1
		lcd_print(__x+1, __y, __buff);
	}

	while(1){
		
		__key = _key_scan(1);
    8e98:	81 e0       	ldi	r24, 0x01	; 1
    8e9a:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    8e9e:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8ea0:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    8ea4:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    8ea6:	17 3e       	cpi	r17, 0xE7	; 231
    8ea8:	09 f4       	brne	.+2      	; 0x8eac <_menu_pumpprodinput+0x162>
    8eaa:	3c c0       	rjmp	.+120    	; 0x8f24 <_menu_pumpprodinput+0x1da>
			return;
		if(__key == _KEY_ENTER){
    8eac:	17 3b       	cpi	r17, 0xB7	; 183
    8eae:	59 f4       	brne	.+22     	; 0x8ec6 <_menu_pumpprodinput+0x17c>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8eb0:	c4 01       	movw	r24, r8
    8eb2:	be 01       	movw	r22, r28
    8eb4:	6a 5f       	subi	r22, 0xFA	; 250
    8eb6:	7f 4f       	sbci	r23, 0xFF	; 255
    8eb8:	46 e0       	ldi	r20, 0x06	; 6
    8eba:	50 e0       	ldi	r21, 0x00	; 0
    8ebc:	2f e9       	ldi	r18, 0x9F	; 159
    8ebe:	32 e1       	ldi	r19, 0x12	; 18
    8ec0:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    8ec4:	2f c0       	rjmp	.+94     	; 0x8f24 <_menu_pumpprodinput+0x1da>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    8ec6:	81 53       	subi	r24, 0x31	; 49
    8ec8:	86 30       	cpi	r24, 0x06	; 6
    8eca:	30 f7       	brcc	.-52     	; 0x8e98 <_menu_pumpprodinput+0x14e>
			if(__pump_prod[__num - '1'] == 6)
    8ecc:	a9 2f       	mov	r26, r25
    8ece:	b0 e0       	ldi	r27, 0x00	; 0
    8ed0:	d1 97       	sbiw	r26, 0x31	; 49
    8ed2:	f6 01       	movw	r30, r12
    8ed4:	ea 0f       	add	r30, r26
    8ed6:	fb 1f       	adc	r31, r27
    8ed8:	80 81       	ld	r24, Z
    8eda:	86 30       	cpi	r24, 0x06	; 6
    8edc:	11 f4       	brne	.+4      	; 0x8ee2 <_menu_pumpprodinput+0x198>
				__pump_prod[__num - '1'] = 0;
    8ede:	10 82       	st	Z, r1
    8ee0:	02 c0       	rjmp	.+4      	; 0x8ee6 <_menu_pumpprodinput+0x19c>
			else
				__pump_prod[__num - '1']++;
    8ee2:	8f 5f       	subi	r24, 0xFF	; 255
    8ee4:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    8ee6:	29 2f       	mov	r18, r25
    8ee8:	30 e0       	ldi	r19, 0x00	; 0
    8eea:	21 53       	subi	r18, 0x31	; 49
    8eec:	30 40       	sbci	r19, 0x00	; 0
    8eee:	22 0f       	add	r18, r18
    8ef0:	33 1f       	adc	r19, r19
    8ef2:	c9 01       	movw	r24, r18
    8ef4:	84 50       	subi	r24, 0x04	; 4
    8ef6:	9d 4f       	sbci	r25, 0xFD	; 253
    8ef8:	fc 01       	movw	r30, r24
    8efa:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    8efc:	23 50       	subi	r18, 0x03	; 3
    8efe:	3d 4f       	sbci	r19, 0xFD	; 253
    8f00:	f9 01       	movw	r30, r18
    8f02:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    8f04:	ac 0d       	add	r26, r12
    8f06:	bd 1d       	adc	r27, r13
    8f08:	4c 91       	ld	r20, X
    8f0a:	50 e0       	ldi	r21, 0x00	; 0
    8f0c:	60 e0       	ldi	r22, 0x00	; 0
    8f0e:	70 e0       	ldi	r23, 0x00	; 0
    8f10:	c7 01       	movw	r24, r14
    8f12:	0e 94 78 18 	call	0x30f0	; 0x30f0 <_f_inttostr>
			lcd_print(__x+1, __y, __buff);
    8f16:	80 2f       	mov	r24, r16
    8f18:	8f 5f       	subi	r24, 0xFF	; 255
    8f1a:	61 2f       	mov	r22, r17
    8f1c:	a7 01       	movw	r20, r14
    8f1e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    8f22:	ba cf       	rjmp	.-140    	; 0x8e98 <_menu_pumpprodinput+0x14e>
		}
	}
}
    8f24:	a7 96       	adiw	r28, 0x27	; 39
    8f26:	0f b6       	in	r0, 0x3f	; 63
    8f28:	f8 94       	cli
    8f2a:	de bf       	out	0x3e, r29	; 62
    8f2c:	0f be       	out	0x3f, r0	; 63
    8f2e:	cd bf       	out	0x3d, r28	; 61
    8f30:	cf 91       	pop	r28
    8f32:	df 91       	pop	r29
    8f34:	1f 91       	pop	r17
    8f36:	0f 91       	pop	r16
    8f38:	ff 90       	pop	r15
    8f3a:	ef 90       	pop	r14
    8f3c:	df 90       	pop	r13
    8f3e:	cf 90       	pop	r12
    8f40:	bf 90       	pop	r11
    8f42:	af 90       	pop	r10
    8f44:	9f 90       	pop	r9
    8f46:	8f 90       	pop	r8
    8f48:	08 95       	ret

00008f4a <_menu_pumpprod>:
	       break;
	   }	   
	}
}

void _menu_pumpprod(void){
    8f4a:	cf 93       	push	r28
    8f4c:	df 93       	push	r29
    8f4e:	c4 ec       	ldi	r28, 0xC4	; 196
    8f50:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;
	char __pump_id[8];
	while(1){
		lcd_clear();_delay_ms(10);
    8f52:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    8f56:	ce 01       	movw	r24, r28
    8f58:	01 97       	sbiw	r24, 0x01	; 1
    8f5a:	f1 f7       	brne	.-4      	; 0x8f58 <_menu_pumpprod+0xe>
		_scr_pump();
    8f5c:	0e 94 3a 42 	call	0x8474	; 0x8474 <_scr_pump>
		while(1){
			__key = _key_scan(1);
    8f60:	81 e0       	ldi	r24, 0x01	; 1
    8f62:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
			if( __key == _KEY_1 || __key == _KEY_2 || __key == _KEY_3 ||
    8f66:	8e 3e       	cpi	r24, 0xEE	; 238
    8f68:	71 f0       	breq	.+28     	; 0x8f86 <_menu_pumpprod+0x3c>
    8f6a:	8e 3d       	cpi	r24, 0xDE	; 222
    8f6c:	61 f0       	breq	.+24     	; 0x8f86 <_menu_pumpprod+0x3c>
    8f6e:	8e 3b       	cpi	r24, 0xBE	; 190
    8f70:	51 f0       	breq	.+20     	; 0x8f86 <_menu_pumpprod+0x3c>
    8f72:	8d 3e       	cpi	r24, 0xED	; 237
    8f74:	41 f0       	breq	.+16     	; 0x8f86 <_menu_pumpprod+0x3c>
    8f76:	8d 3d       	cpi	r24, 0xDD	; 221
    8f78:	31 f0       	breq	.+12     	; 0x8f86 <_menu_pumpprod+0x3c>
    8f7a:	8d 3b       	cpi	r24, 0xBD	; 189
    8f7c:	21 f0       	breq	.+8      	; 0x8f86 <_menu_pumpprod+0x3c>
    8f7e:	8b 3e       	cpi	r24, 0xEB	; 235
    8f80:	11 f0       	breq	.+4      	; 0x8f86 <_menu_pumpprod+0x3c>
    8f82:	8b 3d       	cpi	r24, 0xDB	; 219
    8f84:	31 f4       	brne	.+12     	; 0x8f92 <_menu_pumpprod+0x48>
				__key == _KEY_4 || __key == _KEY_5 || __key == _KEY_6 ||
				__key == _KEY_7 || __key == _KEY_8){
				_menu_pumpprodinput(_key_btn(__key) - 0x31);
    8f86:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    8f8a:	81 53       	subi	r24, 0x31	; 49
    8f8c:	0e 94 a5 46 	call	0x8d4a	; 0x8d4a <_menu_pumpprodinput>
    8f90:	e0 cf       	rjmp	.-64     	; 0x8f52 <_menu_pumpprod+0x8>
				break;
			}
			if(__key == _KEY_CANCEL)
    8f92:	87 3e       	cpi	r24, 0xE7	; 231
    8f94:	29 f7       	brne	.-54     	; 0x8f60 <_menu_pumpprod+0x16>
				return;
		}
	}
}
    8f96:	df 91       	pop	r29
    8f98:	cf 91       	pop	r28
    8f9a:	08 95       	ret

00008f9c <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    8f9c:	6f 92       	push	r6
    8f9e:	7f 92       	push	r7
    8fa0:	8f 92       	push	r8
    8fa2:	9f 92       	push	r9
    8fa4:	af 92       	push	r10
    8fa6:	bf 92       	push	r11
    8fa8:	cf 92       	push	r12
    8faa:	df 92       	push	r13
    8fac:	ef 92       	push	r14
    8fae:	ff 92       	push	r15
    8fb0:	1f 93       	push	r17
    8fb2:	df 93       	push	r29
    8fb4:	cf 93       	push	r28
    8fb6:	cd b7       	in	r28, 0x3d	; 61
    8fb8:	de b7       	in	r29, 0x3e	; 62
    8fba:	2d 97       	sbiw	r28, 0x0d	; 13
    8fbc:	0f b6       	in	r0, 0x3f	; 63
    8fbe:	f8 94       	cli
    8fc0:	de bf       	out	0x3e, r29	; 62
    8fc2:	0f be       	out	0x3f, r0	; 63
    8fc4:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8fc6:	86 e0       	ldi	r24, 0x06	; 6
    8fc8:	c8 2e       	mov	r12, r24
    8fca:	d1 2c       	mov	r13, r1
    8fcc:	cc 0e       	add	r12, r28
    8fce:	dd 1e       	adc	r13, r29
    8fd0:	c6 01       	movw	r24, r12
    8fd2:	6d e4       	ldi	r22, 0x4D	; 77
    8fd4:	70 e0       	ldi	r23, 0x00	; 0
    8fd6:	48 e0       	ldi	r20, 0x08	; 8
    8fd8:	50 e0       	ldi	r21, 0x00	; 0
    8fda:	27 e9       	ldi	r18, 0x97	; 151
    8fdc:	32 e1       	ldi	r19, 0x12	; 18
    8fde:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    8fe2:	83 e6       	ldi	r24, 0x63	; 99
    8fe4:	80 93 6b 01 	sts	0x016B, r24
	lcd_clear();_delay_ms(10);
    8fe8:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    8fec:	84 ec       	ldi	r24, 0xC4	; 196
    8fee:	99 e0       	ldi	r25, 0x09	; 9
    8ff0:	01 97       	sbiw	r24, 0x01	; 1
    8ff2:	f1 f7       	brne	.-4      	; 0x8ff0 <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    8ff4:	81 e0       	ldi	r24, 0x01	; 1
    8ff6:	61 e0       	ldi	r22, 0x01	; 1
    8ff8:	4f e1       	ldi	r20, 0x1F	; 31
    8ffa:	5e e0       	ldi	r21, 0x0E	; 14
    8ffc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    9000:	82 e0       	ldi	r24, 0x02	; 2
    9002:	61 e0       	ldi	r22, 0x01	; 1
    9004:	43 e1       	ldi	r20, 0x13	; 19
    9006:	5e e0       	ldi	r21, 0x0E	; 14
    9008:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    900c:	83 e0       	ldi	r24, 0x03	; 3
    900e:	61 e0       	ldi	r22, 0x01	; 1
    9010:	4e ef       	ldi	r20, 0xFE	; 254
    9012:	5d e0       	ldi	r21, 0x0D	; 13
    9014:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    9018:	84 e0       	ldi	r24, 0x04	; 4
    901a:	61 e0       	ldi	r22, 0x01	; 1
    901c:	49 ee       	ldi	r20, 0xE9	; 233
    901e:	5d e0       	ldi	r21, 0x0D	; 13
    9020:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    9024:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9026:	5e 01       	movw	r10, r28
    9028:	08 94       	sec
    902a:	a1 1c       	adc	r10, r1
    902c:	b1 1c       	adc	r11, r1
    902e:	14 ee       	ldi	r17, 0xE4	; 228
    9030:	61 2e       	mov	r6, r17
    9032:	1d e0       	ldi	r17, 0x0D	; 13
    9034:	71 2e       	mov	r7, r17
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    9036:	be e0       	ldi	r27, 0x0E	; 14
    9038:	8b 2e       	mov	r8, r27
    903a:	91 2c       	mov	r9, r1
    903c:	8c 0e       	add	r8, r28
    903e:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    9040:	1e 2d       	mov	r17, r14
    9042:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9044:	00 d0       	rcall	.+0      	; 0x9046 <FMenuPumpLabel+0xaa>
    9046:	00 d0       	rcall	.+0      	; 0x9048 <FMenuPumpLabel+0xac>
    9048:	00 d0       	rcall	.+0      	; 0x904a <FMenuPumpLabel+0xae>
    904a:	ed b7       	in	r30, 0x3d	; 61
    904c:	fe b7       	in	r31, 0x3e	; 62
    904e:	31 96       	adiw	r30, 0x01	; 1
    9050:	ad b7       	in	r26, 0x3d	; 61
    9052:	be b7       	in	r27, 0x3e	; 62
    9054:	12 96       	adiw	r26, 0x02	; 2
    9056:	bc 92       	st	X, r11
    9058:	ae 92       	st	-X, r10
    905a:	11 97       	sbiw	r26, 0x01	; 1
    905c:	73 82       	std	Z+3, r7	; 0x03
    905e:	62 82       	std	Z+2, r6	; 0x02
    9060:	d7 01       	movw	r26, r14
    9062:	8d 91       	ld	r24, X+
    9064:	7d 01       	movw	r14, r26
    9066:	84 83       	std	Z+4, r24	; 0x04
    9068:	15 82       	std	Z+5, r1	; 0x05
    906a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    906e:	ed b7       	in	r30, 0x3d	; 61
    9070:	fe b7       	in	r31, 0x3e	; 62
    9072:	36 96       	adiw	r30, 0x06	; 6
    9074:	0f b6       	in	r0, 0x3f	; 63
    9076:	f8 94       	cli
    9078:	fe bf       	out	0x3e, r31	; 62
    907a:	0f be       	out	0x3f, r0	; 63
    907c:	ed bf       	out	0x3d, r30	; 61
    907e:	61 2f       	mov	r22, r17
    9080:	66 95       	lsr	r22
    9082:	66 95       	lsr	r22
    9084:	66 0f       	add	r22, r22
    9086:	66 0f       	add	r22, r22
    9088:	66 0f       	add	r22, r22
    908a:	6b 5f       	subi	r22, 0xFB	; 251
    908c:	13 70       	andi	r17, 0x03	; 3
    908e:	81 2f       	mov	r24, r17
    9090:	8f 5f       	subi	r24, 0xFF	; 255
    9092:	a5 01       	movw	r20, r10
    9094:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    9098:	e8 14       	cp	r14, r8
    909a:	f9 04       	cpc	r15, r9
    909c:	89 f6       	brne	.-94     	; 0x9040 <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    909e:	a6 e0       	ldi	r26, 0x06	; 6
    90a0:	ca 2e       	mov	r12, r26
    90a2:	d1 2c       	mov	r13, r1
    90a4:	cc 0e       	add	r12, r28
    90a6:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    90a8:	7e 01       	movw	r14, r28
    90aa:	08 94       	sec
    90ac:	e1 1c       	adc	r14, r1
    90ae:	f1 1c       	adc	r15, r1
    90b0:	ff ed       	ldi	r31, 0xDF	; 223
    90b2:	af 2e       	mov	r10, r31
    90b4:	fd e0       	ldi	r31, 0x0D	; 13
    90b6:	bf 2e       	mov	r11, r31
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    90b8:	81 e0       	ldi	r24, 0x01	; 1
    90ba:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    90be:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    90c0:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    90c4:	17 3e       	cpi	r17, 0xE7	; 231
    90c6:	09 f4       	brne	.+2      	; 0x90ca <FMenuPumpLabel+0x12e>
    90c8:	4b c0       	rjmp	.+150    	; 0x9160 <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    90ca:	17 3b       	cpi	r17, 0xB7	; 183
    90cc:	61 f4       	brne	.+24     	; 0x90e6 <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    90ce:	8d e4       	ldi	r24, 0x4D	; 77
    90d0:	90 e0       	ldi	r25, 0x00	; 0
    90d2:	be 01       	movw	r22, r28
    90d4:	6a 5f       	subi	r22, 0xFA	; 250
    90d6:	7f 4f       	sbci	r23, 0xFF	; 255
    90d8:	48 e0       	ldi	r20, 0x08	; 8
    90da:	50 e0       	ldi	r21, 0x00	; 0
    90dc:	2f e9       	ldi	r18, 0x9F	; 159
    90de:	32 e1       	ldi	r19, 0x12	; 18
    90e0:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    90e4:	3d c0       	rjmp	.+122    	; 0x9160 <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    90e6:	18 2f       	mov	r17, r24
    90e8:	11 53       	subi	r17, 0x31	; 49
    90ea:	18 30       	cpi	r17, 0x08	; 8
    90ec:	28 f7       	brcc	.-54     	; 0x90b8 <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    90ee:	a1 2f       	mov	r26, r17
    90f0:	b0 e0       	ldi	r27, 0x00	; 0
    90f2:	f6 01       	movw	r30, r12
    90f4:	ea 0f       	add	r30, r26
    90f6:	fb 1f       	adc	r31, r27
    90f8:	90 81       	ld	r25, Z
    90fa:	80 91 6b 01 	lds	r24, 0x016B
    90fe:	98 17       	cp	r25, r24
    9100:	11 f4       	brne	.+4      	; 0x9106 <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    9102:	10 82       	st	Z, r1
    9104:	02 c0       	rjmp	.+4      	; 0x910a <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    9106:	9f 5f       	subi	r25, 0xFF	; 255
    9108:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    910a:	00 d0       	rcall	.+0      	; 0x910c <FMenuPumpLabel+0x170>
    910c:	00 d0       	rcall	.+0      	; 0x910e <FMenuPumpLabel+0x172>
    910e:	00 d0       	rcall	.+0      	; 0x9110 <FMenuPumpLabel+0x174>
    9110:	2d b7       	in	r18, 0x3d	; 61
    9112:	3e b7       	in	r19, 0x3e	; 62
    9114:	2f 5f       	subi	r18, 0xFF	; 255
    9116:	3f 4f       	sbci	r19, 0xFF	; 255
    9118:	ed b7       	in	r30, 0x3d	; 61
    911a:	fe b7       	in	r31, 0x3e	; 62
    911c:	f2 82       	std	Z+2, r15	; 0x02
    911e:	e1 82       	std	Z+1, r14	; 0x01
    9120:	f9 01       	movw	r30, r18
    9122:	b3 82       	std	Z+3, r11	; 0x03
    9124:	a2 82       	std	Z+2, r10	; 0x02
    9126:	ac 0d       	add	r26, r12
    9128:	bd 1d       	adc	r27, r13
    912a:	8c 91       	ld	r24, X
    912c:	84 83       	std	Z+4, r24	; 0x04
    912e:	15 82       	std	Z+5, r1	; 0x05
    9130:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    9134:	8d b7       	in	r24, 0x3d	; 61
    9136:	9e b7       	in	r25, 0x3e	; 62
    9138:	06 96       	adiw	r24, 0x06	; 6
    913a:	0f b6       	in	r0, 0x3f	; 63
    913c:	f8 94       	cli
    913e:	9e bf       	out	0x3e, r25	; 62
    9140:	0f be       	out	0x3f, r0	; 63
    9142:	8d bf       	out	0x3d, r24	; 61
    9144:	61 2f       	mov	r22, r17
    9146:	66 95       	lsr	r22
    9148:	66 95       	lsr	r22
    914a:	66 0f       	add	r22, r22
    914c:	66 0f       	add	r22, r22
    914e:	66 0f       	add	r22, r22
    9150:	6b 5f       	subi	r22, 0xFB	; 251
    9152:	13 70       	andi	r17, 0x03	; 3
    9154:	81 2f       	mov	r24, r17
    9156:	8f 5f       	subi	r24, 0xFF	; 255
    9158:	a7 01       	movw	r20, r14
    915a:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    915e:	ac cf       	rjmp	.-168    	; 0x90b8 <FMenuPumpLabel+0x11c>
		}
	}
}
    9160:	2d 96       	adiw	r28, 0x0d	; 13
    9162:	0f b6       	in	r0, 0x3f	; 63
    9164:	f8 94       	cli
    9166:	de bf       	out	0x3e, r29	; 62
    9168:	0f be       	out	0x3f, r0	; 63
    916a:	cd bf       	out	0x3d, r28	; 61
    916c:	cf 91       	pop	r28
    916e:	df 91       	pop	r29
    9170:	1f 91       	pop	r17
    9172:	ff 90       	pop	r15
    9174:	ef 90       	pop	r14
    9176:	df 90       	pop	r13
    9178:	cf 90       	pop	r12
    917a:	bf 90       	pop	r11
    917c:	af 90       	pop	r10
    917e:	9f 90       	pop	r9
    9180:	8f 90       	pop	r8
    9182:	7f 90       	pop	r7
    9184:	6f 90       	pop	r6
    9186:	08 95       	ret

00009188 <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    9188:	cf 92       	push	r12
    918a:	df 92       	push	r13
    918c:	ef 92       	push	r14
    918e:	ff 92       	push	r15
    9190:	0f 93       	push	r16
    9192:	1f 93       	push	r17
    9194:	df 93       	push	r29
    9196:	cf 93       	push	r28
    9198:	cd b7       	in	r28, 0x3d	; 61
    919a:	de b7       	in	r29, 0x3e	; 62
    919c:	27 97       	sbiw	r28, 0x07	; 7
    919e:	0f b6       	in	r0, 0x3f	; 63
    91a0:	f8 94       	cli
    91a2:	de bf       	out	0x3e, r29	; 62
    91a4:	0f be       	out	0x3f, r0	; 63
    91a6:	cd bf       	out	0x3d, r28	; 61
    91a8:	6c 01       	movw	r12, r24
    91aa:	fe 01       	movw	r30, r28
    91ac:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    91ae:	ce 01       	movw	r24, r28
    91b0:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    91b2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    91b4:	e8 17       	cp	r30, r24
    91b6:	f9 07       	cpc	r31, r25
    91b8:	e1 f7       	brne	.-8      	; 0x91b2 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    91ba:	8e 01       	movw	r16, r28
    91bc:	0f 5f       	subi	r16, 0xFF	; 255
    91be:	1f 4f       	sbci	r17, 0xFF	; 255
    91c0:	c8 01       	movw	r24, r16
    91c2:	68 e6       	ldi	r22, 0x68	; 104
    91c4:	71 e0       	ldi	r23, 0x01	; 1
    91c6:	47 e0       	ldi	r20, 0x07	; 7
    91c8:	50 e0       	ldi	r21, 0x00	; 0
    91ca:	27 e9       	ldi	r18, 0x97	; 151
    91cc:	32 e1       	ldi	r19, 0x12	; 18
    91ce:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    91d2:	f8 01       	movw	r30, r16
    91d4:	01 90       	ld	r0, Z+
    91d6:	00 20       	and	r0, r0
    91d8:	e9 f7       	brne	.-6      	; 0x91d4 <GenerateTransactionNum+0x4c>
    91da:	31 97       	sbiw	r30, 0x01	; 1
    91dc:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    91de:	f0 e0       	ldi	r31, 0x00	; 0
    91e0:	0e 0f       	add	r16, r30
    91e2:	1f 1f       	adc	r17, r31
    91e4:	31 97       	sbiw	r30, 0x01	; 1
    91e6:	76 01       	movw	r14, r12
    91e8:	ee 0e       	add	r14, r30
    91ea:	ff 1e       	adc	r15, r31
    91ec:	31 96       	adiw	r30, 0x01	; 1
    91ee:	61 e0       	ldi	r22, 0x01	; 1
    91f0:	19 c0       	rjmp	.+50     	; 0x9224 <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    91f2:	d8 01       	movw	r26, r16
    91f4:	2c 91       	ld	r18, X
    91f6:	20 53       	subi	r18, 0x30	; 48
    91f8:	30 e0       	ldi	r19, 0x00	; 0
    91fa:	26 0f       	add	r18, r22
    91fc:	31 1d       	adc	r19, r1
    91fe:	c9 01       	movw	r24, r18
    9200:	6a e0       	ldi	r22, 0x0A	; 10
    9202:	70 e0       	ldi	r23, 0x00	; 0
    9204:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    9208:	48 2f       	mov	r20, r24
    920a:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    920c:	c9 01       	movw	r24, r18
    920e:	6a e0       	ldi	r22, 0x0A	; 10
    9210:	70 e0       	ldi	r23, 0x00	; 0
    9212:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    9216:	d8 01       	movw	r26, r16
    9218:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    921a:	d7 01       	movw	r26, r14
    921c:	4c 93       	st	X, r20
    921e:	08 94       	sec
    9220:	e1 08       	sbc	r14, r1
    9222:	f1 08       	sbc	r15, r1
    9224:	01 50       	subi	r16, 0x01	; 1
    9226:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    9228:	0c 17       	cp	r16, r28
    922a:	1d 07       	cpc	r17, r29
    922c:	11 f7       	brne	.-60     	; 0x91f2 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    922e:	ce 0e       	add	r12, r30
    9230:	df 1e       	adc	r13, r31
    9232:	d6 01       	movw	r26, r12
    9234:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    9236:	be 01       	movw	r22, r28
    9238:	6f 5f       	subi	r22, 0xFF	; 255
    923a:	7f 4f       	sbci	r23, 0xFF	; 255
    923c:	e6 0f       	add	r30, r22
    923e:	f7 1f       	adc	r31, r23
    9240:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9242:	88 e6       	ldi	r24, 0x68	; 104
    9244:	91 e0       	ldi	r25, 0x01	; 1
    9246:	47 e0       	ldi	r20, 0x07	; 7
    9248:	50 e0       	ldi	r21, 0x00	; 0
    924a:	2f e9       	ldi	r18, 0x9F	; 159
    924c:	32 e1       	ldi	r19, 0x12	; 18
    924e:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    9252:	27 96       	adiw	r28, 0x07	; 7
    9254:	0f b6       	in	r0, 0x3f	; 63
    9256:	f8 94       	cli
    9258:	de bf       	out	0x3e, r29	; 62
    925a:	0f be       	out	0x3f, r0	; 63
    925c:	cd bf       	out	0x3d, r28	; 61
    925e:	cf 91       	pop	r28
    9260:	df 91       	pop	r29
    9262:	1f 91       	pop	r17
    9264:	0f 91       	pop	r16
    9266:	ff 90       	pop	r15
    9268:	ef 90       	pop	r14
    926a:	df 90       	pop	r13
    926c:	cf 90       	pop	r12
    926e:	08 95       	ret

00009270 <_c_pumpmap>:
			__string[__length] = '\0';
		}
	}
}

void _c_pumpmap(void){
    9270:	0f 93       	push	r16
    9272:	1f 93       	push	r17
    9274:	df 93       	push	r29
    9276:	cf 93       	push	r28
    9278:	cd b7       	in	r28, 0x3d	; 61
    927a:	de b7       	in	r29, 0x3e	; 62
    927c:	28 97       	sbiw	r28, 0x08	; 8
    927e:	0f b6       	in	r0, 0x3f	; 63
    9280:	f8 94       	cli
    9282:	de bf       	out	0x3e, r29	; 62
    9284:	0f be       	out	0x3f, r0	; 63
    9286:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9288:	8e 01       	movw	r16, r28
    928a:	0f 5f       	subi	r16, 0xFF	; 255
    928c:	1f 4f       	sbci	r17, 0xFF	; 255
    928e:	c8 01       	movw	r24, r16
    9290:	65 e4       	ldi	r22, 0x45	; 69
    9292:	70 e0       	ldi	r23, 0x00	; 0
    9294:	48 e0       	ldi	r20, 0x08	; 8
    9296:	50 e0       	ldi	r21, 0x00	; 0
    9298:	27 e9       	ldi	r18, 0x97	; 151
    929a:	32 e1       	ldi	r19, 0x12	; 18
    929c:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	unsigned char __buff[8];

	eeprom_read_block((void*) &__buff, (const void*) &DefPumpMap, 8);
	_spi_txnum(_PUMP_DEF, _SPI_SLAVE, __buff, 8);
    92a0:	8a ec       	ldi	r24, 0xCA	; 202
    92a2:	61 e0       	ldi	r22, 0x01	; 1
    92a4:	a8 01       	movw	r20, r16
    92a6:	28 e0       	ldi	r18, 0x08	; 8
    92a8:	0e 94 ae b1 	call	0x1635c	; 0x1635c <_spi_txnum>
}
    92ac:	28 96       	adiw	r28, 0x08	; 8
    92ae:	0f b6       	in	r0, 0x3f	; 63
    92b0:	f8 94       	cli
    92b2:	de bf       	out	0x3e, r29	; 62
    92b4:	0f be       	out	0x3f, r0	; 63
    92b6:	cd bf       	out	0x3d, r28	; 61
    92b8:	cf 91       	pop	r28
    92ba:	df 91       	pop	r29
    92bc:	1f 91       	pop	r17
    92be:	0f 91       	pop	r16
    92c0:	08 95       	ret

000092c2 <_f_punctuation>:
				__string[__i++] = 0x30;
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}
void _f_punctuation(char* __string, unsigned char __mode, unsigned char __length, unsigned char __decimal){
    92c2:	bf 92       	push	r11
    92c4:	cf 92       	push	r12
    92c6:	df 92       	push	r13
    92c8:	ef 92       	push	r14
    92ca:	ff 92       	push	r15
    92cc:	0f 93       	push	r16
    92ce:	1f 93       	push	r17
    92d0:	df 93       	push	r29
    92d2:	cf 93       	push	r28
    92d4:	cd b7       	in	r28, 0x3d	; 61
    92d6:	de b7       	in	r29, 0x3e	; 62
    92d8:	2f 97       	sbiw	r28, 0x0f	; 15
    92da:	0f b6       	in	r0, 0x3f	; 63
    92dc:	f8 94       	cli
    92de:	de bf       	out	0x3e, r29	; 62
    92e0:	0f be       	out	0x3f, r0	; 63
    92e2:	cd bf       	out	0x3d, r28	; 61
    92e4:	8c 01       	movw	r16, r24
    92e6:	c6 2e       	mov	r12, r22
    92e8:	d4 2e       	mov	r13, r20
    92ea:	62 2f       	mov	r22, r18
	char __buff[15] = {"000000000000000"};
    92ec:	de 01       	movw	r26, r28
    92ee:	11 96       	adiw	r26, 0x01	; 1
    92f0:	e0 e0       	ldi	r30, 0x00	; 0
    92f2:	f1 e0       	ldi	r31, 0x01	; 1
    92f4:	8f e0       	ldi	r24, 0x0F	; 15
    92f6:	01 90       	ld	r0, Z+
    92f8:	0d 92       	st	X+, r0
    92fa:	81 50       	subi	r24, 0x01	; 1
    92fc:	e1 f7       	brne	.-8      	; 0x92f6 <_f_punctuation+0x34>
	char  __point = 0,  __len;
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
    92fe:	f8 01       	movw	r30, r16
    9300:	01 90       	ld	r0, Z+
    9302:	00 20       	and	r0, r0
    9304:	e9 f7       	brne	.-6      	; 0x9300 <_f_punctuation+0x3e>
    9306:	31 97       	sbiw	r30, 0x01	; 1
    9308:	3e 2f       	mov	r19, r30
    930a:	30 1b       	sub	r19, r16
	if(__mode == 0){
    930c:	cc 20       	and	r12, r12
    930e:	11 f5       	brne	.+68     	; 0x9354 <_f_punctuation+0x92>
		__buff[__length] = '\0';
    9310:	8d 2d       	mov	r24, r13
    9312:	90 e0       	ldi	r25, 0x00	; 0
    9314:	fe 01       	movw	r30, r28
    9316:	e8 0f       	add	r30, r24
    9318:	f9 1f       	adc	r31, r25
    931a:	11 82       	std	Z+1, r1	; 0x01
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    931c:	23 2f       	mov	r18, r19
    931e:	21 50       	subi	r18, 0x01	; 1
    9320:	4d 2d       	mov	r20, r13
    9322:	bc 01       	movw	r22, r24
    9324:	63 1b       	sub	r22, r19
    9326:	71 09       	sbc	r23, r1
    9328:	09 c0       	rjmp	.+18     	; 0x933c <_f_punctuation+0x7a>
			__buff[__i - 1] = __string[__ii];
    932a:	ac 0f       	add	r26, r28
    932c:	bd 1f       	adc	r27, r29
    932e:	f8 01       	movw	r30, r16
    9330:	e2 0f       	add	r30, r18
    9332:	f1 1d       	adc	r31, r1
    9334:	80 81       	ld	r24, Z
    9336:	8c 93       	st	X, r24
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
	if(__mode == 0){
		__buff[__length] = '\0';
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    9338:	41 50       	subi	r20, 0x01	; 1
    933a:	21 50       	subi	r18, 0x01	; 1
    933c:	a4 2f       	mov	r26, r20
    933e:	b0 e0       	ldi	r27, 0x00	; 0
    9340:	6a 17       	cp	r22, r26
    9342:	7b 07       	cpc	r23, r27
    9344:	94 f3       	brlt	.-28     	; 0x932a <_f_punctuation+0x68>
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
    9346:	c8 01       	movw	r24, r16
    9348:	be 01       	movw	r22, r28
    934a:	6f 5f       	subi	r22, 0xFF	; 255
    934c:	7f 4f       	sbci	r23, 0xFF	; 255
    934e:	0e 94 cd b5 	call	0x16b9a	; 0x16b9a <strcpy>
    9352:	90 c0       	rjmp	.+288    	; 0x9474 <_f_punctuation+0x1b2>
	}
	else{
		if(__decimal > 0){
    9354:	66 23       	and	r22, r22
    9356:	61 f1       	breq	.+88     	; 0x93b0 <_f_punctuation+0xee>
    9358:	a3 2f       	mov	r26, r19
    935a:	b0 e0       	ldi	r27, 0x00	; 0
    935c:	11 97       	sbiw	r26, 0x01	; 1
    935e:	a0 0f       	add	r26, r16
    9360:	b1 1f       	adc	r27, r17
    9362:	90 e0       	ldi	r25, 0x00	; 0
    9364:	ae 01       	movw	r20, r28
    9366:	4f 5f       	subi	r20, 0xFF	; 255
    9368:	5f 4f       	sbci	r21, 0xFF	; 255
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
    936a:	20 e3       	ldi	r18, 0x30	; 48
    936c:	0e c0       	rjmp	.+28     	; 0x938a <_f_punctuation+0xc8>
    936e:	e9 2f       	mov	r30, r25
    9370:	f0 e0       	ldi	r31, 0x00	; 0
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
    9372:	93 17       	cp	r25, r19
    9374:	28 f4       	brcc	.+10     	; 0x9380 <_f_punctuation+0xbe>
					__buff[__counter++] = __string[__len - 1 - __i];
    9376:	e4 0f       	add	r30, r20
    9378:	f5 1f       	adc	r31, r21
    937a:	8c 91       	ld	r24, X
    937c:	80 83       	st	Z, r24
    937e:	03 c0       	rjmp	.+6      	; 0x9386 <_f_punctuation+0xc4>
				else
					__buff[__counter++] = '0';
    9380:	e4 0f       	add	r30, r20
    9382:	f5 1f       	adc	r31, r21
    9384:	20 83       	st	Z, r18
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
    9386:	9f 5f       	subi	r25, 0xFF	; 255
    9388:	11 97       	sbiw	r26, 0x01	; 1
    938a:	96 17       	cp	r25, r22
    938c:	80 f3       	brcs	.-32     	; 0x936e <_f_punctuation+0xac>
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
			}
			__buff[__counter++] = ',';
    938e:	de 01       	movw	r26, r28
    9390:	11 96       	adiw	r26, 0x01	; 1
    9392:	fd 01       	movw	r30, r26
    9394:	e6 0f       	add	r30, r22
    9396:	f1 1d       	adc	r31, r1
    9398:	8c e2       	ldi	r24, 0x2C	; 44
    939a:	80 83       	st	Z, r24
    939c:	56 2f       	mov	r21, r22
    939e:	5f 5f       	subi	r21, 0xFF	; 255
		}
		if(__decimal > 0 && __len <= 2)
    93a0:	33 30       	cpi	r19, 0x03	; 3
    93a2:	48 f4       	brcc	.+18     	; 0x93b6 <_f_punctuation+0xf4>
			__buff[__counter++] = '0';
    93a4:	a5 0f       	add	r26, r21
    93a6:	b1 1d       	adc	r27, r1
    93a8:	80 e3       	ldi	r24, 0x30	; 48
    93aa:	8c 93       	st	X, r24
    93ac:	5f 5f       	subi	r21, 0xFF	; 255
    93ae:	32 c0       	rjmp	.+100    	; 0x9414 <_f_punctuation+0x152>
		else{
			if(__len > 1){
    93b0:	32 30       	cpi	r19, 0x02	; 2
    93b2:	68 f1       	brcs	.+90     	; 0x940e <_f_punctuation+0x14c>
    93b4:	50 e0       	ldi	r21, 0x00	; 0
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    93b6:	31 50       	subi	r19, 0x01	; 1
    93b8:	b3 2e       	mov	r11, r19
    93ba:	b6 1a       	sub	r11, r22
    93bc:	3f 5f       	subi	r19, 0xFF	; 255
    93be:	70 e0       	ldi	r23, 0x00	; 0
    93c0:	40 e0       	ldi	r20, 0x00	; 0
    93c2:	23 2f       	mov	r18, r19
    93c4:	30 e0       	ldi	r19, 0x00	; 0
    93c6:	26 1b       	sub	r18, r22
    93c8:	31 09       	sbc	r19, r1
						__i++, __point++, __ii--){
					if(__point == 3){
						__point = 0;
						__buff[__counter++] = '.';
    93ca:	7e 01       	movw	r14, r28
    93cc:	08 94       	sec
    93ce:	e1 1c       	adc	r14, r1
    93d0:	f1 1c       	adc	r15, r1
    93d2:	6e e2       	ldi	r22, 0x2E	; 46
    93d4:	14 c0       	rjmp	.+40     	; 0x93fe <_f_punctuation+0x13c>
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
					if(__point == 3){
    93d6:	73 30       	cpi	r23, 0x03	; 3
    93d8:	31 f4       	brne	.+12     	; 0x93e6 <_f_punctuation+0x124>
						__point = 0;
						__buff[__counter++] = '.';
    93da:	f7 01       	movw	r30, r14
    93dc:	e5 0f       	add	r30, r21
    93de:	f1 1d       	adc	r31, r1
    93e0:	60 83       	st	Z, r22
    93e2:	5f 5f       	subi	r21, 0xFF	; 255
    93e4:	70 e0       	ldi	r23, 0x00	; 0
					}
					__buff[__counter++] = __string[__ii];
    93e6:	f7 01       	movw	r30, r14
    93e8:	e5 0f       	add	r30, r21
    93ea:	f1 1d       	adc	r31, r1
    93ec:	c8 01       	movw	r24, r16
    93ee:	8a 0f       	add	r24, r26
    93f0:	91 1d       	adc	r25, r1
    93f2:	dc 01       	movw	r26, r24
    93f4:	8c 91       	ld	r24, X
    93f6:	80 83       	st	Z, r24
    93f8:	5f 5f       	subi	r21, 0xFF	; 255
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
    93fa:	4f 5f       	subi	r20, 0xFF	; 255
    93fc:	7f 5f       	subi	r23, 0xFF	; 255
    93fe:	ab 2d       	mov	r26, r11
    9400:	a4 1b       	sub	r26, r20
		}
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    9402:	84 2f       	mov	r24, r20
    9404:	90 e0       	ldi	r25, 0x00	; 0
    9406:	82 17       	cp	r24, r18
    9408:	93 07       	cpc	r25, r19
    940a:	2c f3       	brlt	.-54     	; 0x93d6 <_f_punctuation+0x114>
    940c:	03 c0       	rjmp	.+6      	; 0x9414 <_f_punctuation+0x152>
					}
					__buff[__counter++] = __string[__ii];
				}
			}
			else
				__buff[__counter++] = '0';
    940e:	80 e3       	ldi	r24, 0x30	; 48
    9410:	89 83       	std	Y+1, r24	; 0x01
    9412:	51 e0       	ldi	r21, 0x01	; 1
		}
		if(__mode == 1){
    9414:	91 e0       	ldi	r25, 0x01	; 1
    9416:	c9 16       	cp	r12, r25
    9418:	79 f4       	brne	.+30     	; 0x9438 <_f_punctuation+0x176>
    941a:	fe 01       	movw	r30, r28
    941c:	31 96       	adiw	r30, 0x01	; 1
    941e:	e5 0f       	add	r30, r21
    9420:	f1 1d       	adc	r31, r1
    9422:	d8 01       	movw	r26, r16
    9424:	02 c0       	rjmp	.+4      	; 0x942a <_f_punctuation+0x168>
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
    9426:	80 81       	ld	r24, Z
    9428:	8d 93       	st	X+, r24
    942a:	31 97       	sbiw	r30, 0x01	; 1
			}
			else
				__buff[__counter++] = '0';
		}
		if(__mode == 1){
			for(__i = 0; __i < __counter; __i++)
    942c:	ec 17       	cp	r30, r28
    942e:	fd 07       	cpc	r31, r29
    9430:	d1 f7       	brne	.-12     	; 0x9426 <_f_punctuation+0x164>
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
    9432:	05 0f       	add	r16, r21
    9434:	11 1d       	adc	r17, r1
    9436:	1c c0       	rjmp	.+56     	; 0x9470 <_f_punctuation+0x1ae>
		}
		if(__mode == 2){
    9438:	f2 e0       	ldi	r31, 0x02	; 2
    943a:	cf 16       	cp	r12, r31
    943c:	d9 f4       	brne	.+54     	; 0x9474 <_f_punctuation+0x1b2>
    943e:	f8 01       	movw	r30, r16
    9440:	80 e0       	ldi	r24, 0x00	; 0
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
    9442:	90 e2       	ldi	r25, 0x20	; 32
    9444:	02 c0       	rjmp	.+4      	; 0x944a <_f_punctuation+0x188>
    9446:	91 93       	st	Z+, r25
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
    9448:	8f 5f       	subi	r24, 0xFF	; 255
    944a:	8d 15       	cp	r24, r13
    944c:	e0 f3       	brcs	.-8      	; 0x9446 <_f_punctuation+0x184>
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    944e:	de 01       	movw	r26, r28
    9450:	11 96       	adiw	r26, 0x01	; 1
    9452:	9d 2d       	mov	r25, r13
    9454:	91 50       	subi	r25, 0x01	; 1
    9456:	29 2f       	mov	r18, r25
    9458:	25 1b       	sub	r18, r21
    945a:	06 c0       	rjmp	.+12     	; 0x9468 <_f_punctuation+0x1a6>
				__string[__ii] = __buff[__i];
    945c:	f8 01       	movw	r30, r16
    945e:	e9 0f       	add	r30, r25
    9460:	f1 1d       	adc	r31, r1
    9462:	8d 91       	ld	r24, X+
    9464:	80 83       	st	Z, r24
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    9466:	91 50       	subi	r25, 0x01	; 1
    9468:	92 17       	cp	r25, r18
    946a:	c1 f7       	brne	.-16     	; 0x945c <_f_punctuation+0x19a>
				__string[__ii] = __buff[__i];
			__string[__length] = '\0';
    946c:	0d 0d       	add	r16, r13
    946e:	11 1d       	adc	r17, r1
    9470:	f8 01       	movw	r30, r16
    9472:	10 82       	st	Z, r1
		}
	}
}
    9474:	2f 96       	adiw	r28, 0x0f	; 15
    9476:	0f b6       	in	r0, 0x3f	; 63
    9478:	f8 94       	cli
    947a:	de bf       	out	0x3e, r29	; 62
    947c:	0f be       	out	0x3f, r0	; 63
    947e:	cd bf       	out	0x3d, r28	; 61
    9480:	cf 91       	pop	r28
    9482:	df 91       	pop	r29
    9484:	1f 91       	pop	r17
    9486:	0f 91       	pop	r16
    9488:	ff 90       	pop	r15
    948a:	ef 90       	pop	r14
    948c:	df 90       	pop	r13
    948e:	cf 90       	pop	r12
    9490:	bf 90       	pop	r11
    9492:	08 95       	ret

00009494 <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    9494:	2f 92       	push	r2
    9496:	3f 92       	push	r3
    9498:	4f 92       	push	r4
    949a:	5f 92       	push	r5
    949c:	6f 92       	push	r6
    949e:	7f 92       	push	r7
    94a0:	8f 92       	push	r8
    94a2:	9f 92       	push	r9
    94a4:	af 92       	push	r10
    94a6:	bf 92       	push	r11
    94a8:	cf 92       	push	r12
    94aa:	df 92       	push	r13
    94ac:	ef 92       	push	r14
    94ae:	ff 92       	push	r15
    94b0:	0f 93       	push	r16
    94b2:	1f 93       	push	r17
    94b4:	df 93       	push	r29
    94b6:	cf 93       	push	r28
    94b8:	cd b7       	in	r28, 0x3d	; 61
    94ba:	de b7       	in	r29, 0x3e	; 62
    94bc:	2c 97       	sbiw	r28, 0x0c	; 12
    94be:	0f b6       	in	r0, 0x3f	; 63
    94c0:	f8 94       	cli
    94c2:	de bf       	out	0x3e, r29	; 62
    94c4:	0f be       	out	0x3f, r0	; 63
    94c6:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94c8:	e1 99       	sbic	0x1c, 1	; 28
    94ca:	fe cf       	rjmp	.-4      	; 0x94c8 <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94cc:	80 e3       	ldi	r24, 0x30	; 48
    94ce:	90 e0       	ldi	r25, 0x00	; 0
    94d0:	9f bb       	out	0x1f, r25	; 31
    94d2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94d4:	e0 9a       	sbi	0x1c, 0	; 28
    94d6:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94d8:	e1 99       	sbic	0x1c, 1	; 28
    94da:	fe cf       	rjmp	.-4      	; 0x94d8 <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94dc:	e5 e3       	ldi	r30, 0x35	; 53
    94de:	f0 e0       	ldi	r31, 0x00	; 0
    94e0:	ff bb       	out	0x1f, r31	; 31
    94e2:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94e4:	e0 9a       	sbi	0x1c, 0	; 28
    94e6:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94e8:	e1 99       	sbic	0x1c, 1	; 28
    94ea:	fe cf       	rjmp	.-4      	; 0x94e8 <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94ec:	84 e3       	ldi	r24, 0x34	; 52
    94ee:	90 e0       	ldi	r25, 0x00	; 0
    94f0:	9f bb       	out	0x1f, r25	; 31
    94f2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94f4:	e0 9a       	sbi	0x1c, 0	; 28
    94f6:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94f8:	e1 99       	sbic	0x1c, 1	; 28
    94fa:	fe cf       	rjmp	.-4      	; 0x94f8 <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94fc:	e3 e3       	ldi	r30, 0x33	; 51
    94fe:	f0 e0       	ldi	r31, 0x00	; 0
    9500:	ff bb       	out	0x1f, r31	; 31
    9502:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9504:	e0 9a       	sbi	0x1c, 0	; 28
    9506:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9508:	e1 99       	sbic	0x1c, 1	; 28
    950a:	fe cf       	rjmp	.-4      	; 0x9508 <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    950c:	71 e3       	ldi	r23, 0x31	; 49
    950e:	27 2e       	mov	r2, r23
    9510:	70 e0       	ldi	r23, 0x00	; 0
    9512:	37 2e       	mov	r3, r23
    9514:	3f ba       	out	0x1f, r3	; 31
    9516:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9518:	e0 9a       	sbi	0x1c, 0	; 28
    951a:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    951c:	e1 99       	sbic	0x1c, 1	; 28
    951e:	fe cf       	rjmp	.-4      	; 0x951c <_menu_printer+0x88>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9520:	62 e3       	ldi	r22, 0x32	; 50
    9522:	46 2e       	mov	r4, r22
    9524:	60 e0       	ldi	r22, 0x00	; 0
    9526:	56 2e       	mov	r5, r22
    9528:	5f ba       	out	0x1f, r5	; 31
    952a:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    952c:	e0 9a       	sbi	0x1c, 0	; 28
    952e:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    9530:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&__prt_papper);
    9532:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&__prt_logo);
    9534:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&__prt_autocut);
    9536:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    9538:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    953a:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    953c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    9540:	81 e0       	ldi	r24, 0x01	; 1
    9542:	61 e0       	ldi	r22, 0x01	; 1
    9544:	4f ea       	ldi	r20, 0xAF	; 175
    9546:	5c e0       	ldi	r21, 0x0C	; 12
    9548:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    954c:	82 e0       	ldi	r24, 0x02	; 2
    954e:	61 e0       	ldi	r22, 0x01	; 1
    9550:	4c e9       	ldi	r20, 0x9C	; 156
    9552:	5c e0       	ldi	r21, 0x0C	; 12
    9554:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    9558:	83 e0       	ldi	r24, 0x03	; 3
    955a:	61 e0       	ldi	r22, 0x01	; 1
    955c:	4c e8       	ldi	r20, 0x8C	; 140
    955e:	5c e0       	ldi	r21, 0x0C	; 12
    9560:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    9564:	84 e0       	ldi	r24, 0x04	; 4
    9566:	61 e0       	ldi	r22, 0x01	; 1
    9568:	4c e7       	ldi	r20, 0x7C	; 124
    956a:	5c e0       	ldi	r21, 0x0C	; 12
    956c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    9570:	02 e1       	ldi	r16, 0x12	; 18
    9572:	13 e0       	ldi	r17, 0x03	; 3
    9574:	4e 01       	movw	r8, r28
    9576:	08 94       	sec
    9578:	81 1c       	adc	r8, r1
    957a:	91 1c       	adc	r9, r1
    957c:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    957e:	37 e0       	ldi	r19, 0x07	; 7
    9580:	c3 2e       	mov	r12, r19
    9582:	d1 2c       	mov	r13, r1
    9584:	cc 0e       	add	r12, r28
    9586:	dd 1e       	adc	r13, r29
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    9588:	f8 01       	movw	r30, r16
    958a:	a4 90       	lpm	r10, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    958c:	0f 5f       	subi	r16, 0xFF	; 255
    958e:	1f 4f       	sbci	r17, 0xFF	; 255
    9590:	f8 01       	movw	r30, r16
    9592:	b4 90       	lpm	r11, Z+
    9594:	01 50       	subi	r16, 0x01	; 1
    9596:	10 40       	sbci	r17, 0x00	; 0
		_f_inttostr(__buff, __value[__i]);
    9598:	f7 01       	movw	r30, r14
    959a:	40 81       	ld	r20, Z
    959c:	50 e0       	ldi	r21, 0x00	; 0
    959e:	60 e0       	ldi	r22, 0x00	; 0
    95a0:	70 e0       	ldi	r23, 0x00	; 0
    95a2:	c6 01       	movw	r24, r12
    95a4:	0e 94 78 18 	call	0x30f0	; 0x30f0 <_f_inttostr>
		if(__i == 4)_f_punctuation(__buff, 0, 2, 0);
    95a8:	8e 2d       	mov	r24, r14
    95aa:	88 19       	sub	r24, r8
    95ac:	84 30       	cpi	r24, 0x04	; 4
    95ae:	31 f4       	brne	.+12     	; 0x95bc <_menu_printer+0x128>
    95b0:	c6 01       	movw	r24, r12
    95b2:	60 e0       	ldi	r22, 0x00	; 0
    95b4:	42 e0       	ldi	r20, 0x02	; 2
    95b6:	20 e0       	ldi	r18, 0x00	; 0
    95b8:	0e 94 61 49 	call	0x92c2	; 0x92c2 <_f_punctuation>
		lcd_print(__x, __y, __buff);
    95bc:	8a 2d       	mov	r24, r10
    95be:	6b 2d       	mov	r22, r11
    95c0:	a6 01       	movw	r20, r12
    95c2:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    95c6:	0e 5f       	subi	r16, 0xFE	; 254
    95c8:	1f 4f       	sbci	r17, 0xFF	; 255
    95ca:	08 94       	sec
    95cc:	e1 1c       	adc	r14, r1
    95ce:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    95d0:	f3 e0       	ldi	r31, 0x03	; 3
    95d2:	0e 31       	cpi	r16, 0x1E	; 30
    95d4:	1f 07       	cpc	r17, r31
    95d6:	c1 f6       	brne	.-80     	; 0x9588 <_menu_printer+0xf4>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    95d8:	3e 01       	movw	r6, r28
    95da:	08 94       	sec
    95dc:	61 1c       	adc	r6, r1
    95de:	71 1c       	adc	r7, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    95e0:	27 e0       	ldi	r18, 0x07	; 7
    95e2:	c2 2e       	mov	r12, r18
    95e4:	d1 2c       	mov	r13, r1
    95e6:	cc 0e       	add	r12, r28
    95e8:	dd 1e       	adc	r13, r29
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    95ea:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&__prt_papper, __value[1]);
    95ec:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&__prt_logo, __value[2]);
    95ee:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&__prt_autocut, __value[3]);
    95f0:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    95f2:	ed 80       	ldd	r14, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    95f4:	fe 80       	ldd	r15, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    95f6:	81 e0       	ldi	r24, 0x01	; 1
    95f8:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    95fc:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    95fe:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    9602:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    9604:	17 3e       	cpi	r17, 0xE7	; 231
    9606:	09 f4       	brne	.+2      	; 0x960a <_menu_printer+0x176>
    9608:	85 c0       	rjmp	.+266    	; 0x9714 <_menu_printer+0x280>
			return;
		if(__key==_KEY_ENTER){
    960a:	17 3b       	cpi	r17, 0xB7	; 183
    960c:	09 f0       	breq	.+2      	; 0x9610 <_menu_printer+0x17c>
    960e:	44 c0       	rjmp	.+136    	; 0x9698 <_menu_printer+0x204>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9610:	e1 99       	sbic	0x1c, 1	; 28
    9612:	fe cf       	rjmp	.-4      	; 0x9610 <_menu_printer+0x17c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9614:	80 e3       	ldi	r24, 0x30	; 48
    9616:	90 e0       	ldi	r25, 0x00	; 0
    9618:	9f bb       	out	0x1f, r25	; 31
    961a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    961c:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    961e:	0f b6       	in	r0, 0x3f	; 63
    9620:	f8 94       	cli
    9622:	e2 9a       	sbi	0x1c, 2	; 28
    9624:	e1 9a       	sbi	0x1c, 1	; 28
    9626:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9628:	e1 99       	sbic	0x1c, 1	; 28
    962a:	fe cf       	rjmp	.-4      	; 0x9628 <_menu_printer+0x194>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    962c:	e5 e3       	ldi	r30, 0x35	; 53
    962e:	f0 e0       	ldi	r31, 0x00	; 0
    9630:	ff bb       	out	0x1f, r31	; 31
    9632:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    9634:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    9636:	0f b6       	in	r0, 0x3f	; 63
    9638:	f8 94       	cli
    963a:	e2 9a       	sbi	0x1c, 2	; 28
    963c:	e1 9a       	sbi	0x1c, 1	; 28
    963e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9640:	e1 99       	sbic	0x1c, 1	; 28
    9642:	fe cf       	rjmp	.-4      	; 0x9640 <_menu_printer+0x1ac>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9644:	84 e3       	ldi	r24, 0x34	; 52
    9646:	90 e0       	ldi	r25, 0x00	; 0
    9648:	9f bb       	out	0x1f, r25	; 31
    964a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    964c:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    964e:	0f b6       	in	r0, 0x3f	; 63
    9650:	f8 94       	cli
    9652:	e2 9a       	sbi	0x1c, 2	; 28
    9654:	e1 9a       	sbi	0x1c, 1	; 28
    9656:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9658:	e1 99       	sbic	0x1c, 1	; 28
    965a:	fe cf       	rjmp	.-4      	; 0x9658 <_menu_printer+0x1c4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    965c:	e3 e3       	ldi	r30, 0x33	; 51
    965e:	f0 e0       	ldi	r31, 0x00	; 0
    9660:	ff bb       	out	0x1f, r31	; 31
    9662:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    9664:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    9666:	0f b6       	in	r0, 0x3f	; 63
    9668:	f8 94       	cli
    966a:	e2 9a       	sbi	0x1c, 2	; 28
    966c:	e1 9a       	sbi	0x1c, 1	; 28
    966e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9670:	e1 99       	sbic	0x1c, 1	; 28
    9672:	fe cf       	rjmp	.-4      	; 0x9670 <_menu_printer+0x1dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9674:	3f ba       	out	0x1f, r3	; 31
    9676:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    9678:	ed ba       	out	0x1d, r14	; 29

    __asm__ __volatile__ (
    967a:	0f b6       	in	r0, 0x3f	; 63
    967c:	f8 94       	cli
    967e:	e2 9a       	sbi	0x1c, 2	; 28
    9680:	e1 9a       	sbi	0x1c, 1	; 28
    9682:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9684:	e1 99       	sbic	0x1c, 1	; 28
    9686:	fe cf       	rjmp	.-4      	; 0x9684 <_menu_printer+0x1f0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9688:	5f ba       	out	0x1f, r5	; 31
    968a:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    968c:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
    968e:	0f b6       	in	r0, 0x3f	; 63
    9690:	f8 94       	cli
    9692:	e2 9a       	sbi	0x1c, 2	; 28
    9694:	e1 9a       	sbi	0x1c, 1	; 28
    9696:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&__prt_autocut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    9698:	80 2f       	mov	r24, r16
    969a:	81 53       	subi	r24, 0x31	; 49
    969c:	86 30       	cpi	r24, 0x06	; 6
    969e:	08 f0       	brcs	.+2      	; 0x96a2 <_menu_printer+0x20e>
    96a0:	aa cf       	rjmp	.-172    	; 0x95f6 <_menu_printer+0x162>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    96a2:	a0 2f       	mov	r26, r16
    96a4:	b0 e0       	ldi	r27, 0x00	; 0
    96a6:	d1 97       	sbiw	r26, 0x31	; 49
    96a8:	fd 01       	movw	r30, r26
    96aa:	e2 5e       	subi	r30, 0xE2	; 226
    96ac:	fc 4f       	sbci	r31, 0xFC	; 252
    96ae:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    96b0:	fd 01       	movw	r30, r26
    96b2:	ec 5d       	subi	r30, 0xDC	; 220
    96b4:	fc 4f       	sbci	r31, 0xFC	; 252
    96b6:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    96b8:	f3 01       	movw	r30, r6
    96ba:	ea 0f       	add	r30, r26
    96bc:	fb 1f       	adc	r31, r27
    96be:	80 81       	ld	r24, Z
    96c0:	82 17       	cp	r24, r18
    96c2:	11 f4       	brne	.+4      	; 0x96c8 <_menu_printer+0x234>
				__value[__num - 0x31] = __start;
    96c4:	90 83       	st	Z, r25
    96c6:	02 c0       	rjmp	.+4      	; 0x96cc <_menu_printer+0x238>
			else
				__value[__num - 0x31]++;
    96c8:	8f 5f       	subi	r24, 0xFF	; 255
    96ca:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    96cc:	9d 01       	movw	r18, r26
    96ce:	22 0f       	add	r18, r18
    96d0:	33 1f       	adc	r19, r19
    96d2:	c9 01       	movw	r24, r18
    96d4:	8e 5e       	subi	r24, 0xEE	; 238
    96d6:	9c 4f       	sbci	r25, 0xFC	; 252
    96d8:	fc 01       	movw	r30, r24
    96da:	f4 90       	lpm	r15, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    96dc:	2d 5e       	subi	r18, 0xED	; 237
    96de:	3c 4f       	sbci	r19, 0xFC	; 252
    96e0:	f9 01       	movw	r30, r18
    96e2:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    96e4:	a6 0d       	add	r26, r6
    96e6:	b7 1d       	adc	r27, r7
    96e8:	4c 91       	ld	r20, X
    96ea:	50 e0       	ldi	r21, 0x00	; 0
    96ec:	60 e0       	ldi	r22, 0x00	; 0
    96ee:	70 e0       	ldi	r23, 0x00	; 0
    96f0:	c6 01       	movw	r24, r12
    96f2:	0e 94 78 18 	call	0x30f0	; 0x30f0 <_f_inttostr>
			if((__num == 0x35)||(__num == 0x36))
    96f6:	05 53       	subi	r16, 0x35	; 53
    96f8:	02 30       	cpi	r16, 0x02	; 2
    96fa:	30 f4       	brcc	.+12     	; 0x9708 <_menu_printer+0x274>
				_f_punctuation(__buff, 0, 2, 0);
    96fc:	c6 01       	movw	r24, r12
    96fe:	60 e0       	ldi	r22, 0x00	; 0
    9700:	42 e0       	ldi	r20, 0x02	; 2
    9702:	20 e0       	ldi	r18, 0x00	; 0
    9704:	0e 94 61 49 	call	0x92c2	; 0x92c2 <_f_punctuation>
			lcd_print(__x, __y, __buff);
    9708:	8f 2d       	mov	r24, r15
    970a:	61 2f       	mov	r22, r17
    970c:	a6 01       	movw	r20, r12
    970e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    9712:	6b cf       	rjmp	.-298    	; 0x95ea <_menu_printer+0x156>
		}
	}
}
    9714:	2c 96       	adiw	r28, 0x0c	; 12
    9716:	0f b6       	in	r0, 0x3f	; 63
    9718:	f8 94       	cli
    971a:	de bf       	out	0x3e, r29	; 62
    971c:	0f be       	out	0x3f, r0	; 63
    971e:	cd bf       	out	0x3d, r28	; 61
    9720:	cf 91       	pop	r28
    9722:	df 91       	pop	r29
    9724:	1f 91       	pop	r17
    9726:	0f 91       	pop	r16
    9728:	ff 90       	pop	r15
    972a:	ef 90       	pop	r14
    972c:	df 90       	pop	r13
    972e:	cf 90       	pop	r12
    9730:	bf 90       	pop	r11
    9732:	af 90       	pop	r10
    9734:	9f 90       	pop	r9
    9736:	8f 90       	pop	r8
    9738:	7f 90       	pop	r7
    973a:	6f 90       	pop	r6
    973c:	5f 90       	pop	r5
    973e:	4f 90       	pop	r4
    9740:	3f 90       	pop	r3
    9742:	2f 90       	pop	r2
    9744:	08 95       	ret

00009746 <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    9746:	0e 94 4a 4a 	call	0x9494	; 0x9494 <_menu_printer>
	 return MENU_DONE;
}
    974a:	81 e0       	ldi	r24, 0x01	; 1
    974c:	08 95       	ret

0000974e <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    974e:	1f 93       	push	r17
    9750:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    9752:	89 31       	cpi	r24, 0x19	; 25
    9754:	59 f4       	brne	.+22     	; 0x976c <SendPrint+0x1e>
	     if (zSend==xSendLead)_uart(_COM_PRINTER,1,xSendLead);
    9756:	40 91 a4 02 	lds	r20, 0x02A4
    975a:	46 17       	cp	r20, r22
    975c:	19 f4       	brne	.+6      	; 0x9764 <SendPrint+0x16>
    975e:	80 e0       	ldi	r24, 0x00	; 0
    9760:	61 e0       	ldi	r22, 0x01	; 1
    9762:	07 c0       	rjmp	.+14     	; 0x9772 <SendPrint+0x24>
		 else _uart(_COM_PRINTER,1,' ');	 
    9764:	80 e0       	ldi	r24, 0x00	; 0
    9766:	61 e0       	ldi	r22, 0x01	; 1
    9768:	40 e2       	ldi	r20, 0x20	; 32
    976a:	03 c0       	rjmp	.+6      	; 0x9772 <SendPrint+0x24>
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
    976c:	80 e0       	ldi	r24, 0x00	; 0
    976e:	61 e0       	ldi	r22, 0x01	; 1
    9770:	41 2f       	mov	r20, r17
    9772:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	 zSend=xSend;
    9776:	10 93 a4 02 	sts	0x02A4, r17
}
    977a:	1f 91       	pop	r17
    977c:	08 95       	ret

0000977e <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     _uart(_COM_PRINTER, 1, 0x0D);     
    977e:	80 e0       	ldi	r24, 0x00	; 0
    9780:	61 e0       	ldi	r22, 0x01	; 1
    9782:	4d e0       	ldi	r20, 0x0D	; 13
    9784:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
     _uart(_COM_PRINTER, 1, 0x0A);
    9788:	80 e0       	ldi	r24, 0x00	; 0
    978a:	61 e0       	ldi	r22, 0x01	; 1
    978c:	4a e0       	ldi	r20, 0x0A	; 10
    978e:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>

}
    9792:	08 95       	ret

00009794 <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9794:	e1 99       	sbic	0x1c, 1	; 28
    9796:	fe cf       	rjmp	.-4      	; 0x9794 <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9798:	80 e3       	ldi	r24, 0x30	; 48
    979a:	90 e0       	ldi	r25, 0x00	; 0
    979c:	9f bb       	out	0x1f, r25	; 31
    979e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97a0:	e0 9a       	sbi	0x1c, 0	; 28
    97a2:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    97a4:	81 30       	cpi	r24, 0x01	; 1
    97a6:	71 f5       	brne	.+92     	; 0x9804 <InitPrinter+0x70>
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x00);
    97a8:	80 e0       	ldi	r24, 0x00	; 0
    97aa:	61 e0       	ldi	r22, 0x01	; 1
    97ac:	4d e1       	ldi	r20, 0x1D	; 29
    97ae:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    97b2:	80 e0       	ldi	r24, 0x00	; 0
    97b4:	61 e0       	ldi	r22, 0x01	; 1
    97b6:	4c e7       	ldi	r20, 0x7C	; 124
    97b8:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    97bc:	80 e0       	ldi	r24, 0x00	; 0
    97be:	61 e0       	ldi	r22, 0x01	; 1
    97c0:	40 e0       	ldi	r20, 0x00	; 0
    97c2:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		//Double Strike ON : 1B 47 01
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x01);
    97c6:	80 e0       	ldi	r24, 0x00	; 0
    97c8:	61 e0       	ldi	r22, 0x01	; 1
    97ca:	4b e1       	ldi	r20, 0x1B	; 27
    97cc:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    97d0:	80 e0       	ldi	r24, 0x00	; 0
    97d2:	61 e0       	ldi	r22, 0x01	; 1
    97d4:	47 e4       	ldi	r20, 0x47	; 71
    97d6:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    97da:	80 e0       	ldi	r24, 0x00	; 0
    97dc:	61 e0       	ldi	r22, 0x01	; 1
    97de:	41 e0       	ldi	r20, 0x01	; 1
    97e0:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);   
    97e4:	80 e0       	ldi	r24, 0x00	; 0
    97e6:	61 e0       	ldi	r22, 0x01	; 1
    97e8:	4d e1       	ldi	r20, 0x1D	; 29
    97ea:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    97ee:	80 e0       	ldi	r24, 0x00	; 0
    97f0:	61 e0       	ldi	r22, 0x01	; 1
    97f2:	41 e2       	ldi	r20, 0x21	; 33
    97f4:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    97f8:	80 e0       	ldi	r24, 0x00	; 0
    97fa:	61 e0       	ldi	r22, 0x01	; 1
    97fc:	41 e0       	ldi	r20, 0x01	; 1
    97fe:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    9802:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    9804:	82 30       	cpi	r24, 0x02	; 2
    9806:	69 f5       	brne	.+90     	; 0x9862 <InitPrinter+0xce>
        //Print Density 0%
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x04);
    9808:	80 e0       	ldi	r24, 0x00	; 0
    980a:	61 e0       	ldi	r22, 0x01	; 1
    980c:	4d e1       	ldi	r20, 0x1D	; 29
    980e:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    9812:	80 e0       	ldi	r24, 0x00	; 0
    9814:	61 e0       	ldi	r22, 0x01	; 1
    9816:	4c e7       	ldi	r20, 0x7C	; 124
    9818:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    981c:	80 e0       	ldi	r24, 0x00	; 0
    981e:	61 e0       	ldi	r22, 0x01	; 1
    9820:	44 e0       	ldi	r20, 0x04	; 4
    9822:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		//Double Strike OFF : 1B 47 00
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x00);
    9826:	80 e0       	ldi	r24, 0x00	; 0
    9828:	61 e0       	ldi	r22, 0x01	; 1
    982a:	4b e1       	ldi	r20, 0x1B	; 27
    982c:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    9830:	80 e0       	ldi	r24, 0x00	; 0
    9832:	61 e0       	ldi	r22, 0x01	; 1
    9834:	47 e4       	ldi	r20, 0x47	; 71
    9836:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    983a:	80 e0       	ldi	r24, 0x00	; 0
    983c:	61 e0       	ldi	r22, 0x01	; 1
    983e:	40 e0       	ldi	r20, 0x00	; 0
    9840:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
    9844:	80 e0       	ldi	r24, 0x00	; 0
    9846:	61 e0       	ldi	r22, 0x01	; 1
    9848:	4d e1       	ldi	r20, 0x1D	; 29
    984a:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    984e:	80 e0       	ldi	r24, 0x00	; 0
    9850:	61 e0       	ldi	r22, 0x01	; 1
    9852:	41 e2       	ldi	r20, 0x21	; 33
    9854:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    9858:	80 e0       	ldi	r24, 0x00	; 0
    985a:	61 e0       	ldi	r22, 0x01	; 1
    985c:	40 e0       	ldi	r20, 0x00	; 0
    985e:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    9862:	08 95       	ret

00009864 <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9864:	e1 99       	sbic	0x1c, 1	; 28
    9866:	fe cf       	rjmp	.-4      	; 0x9864 <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9868:	80 e3       	ldi	r24, 0x30	; 48
    986a:	90 e0       	ldi	r25, 0x00	; 0
    986c:	9f bb       	out	0x1f, r25	; 31
    986e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9870:	e0 9a       	sbi	0x1c, 0	; 28
    9872:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9874:	82 30       	cpi	r24, 0x02	; 2
    9876:	79 f4       	brne	.+30     	; 0x9896 <PrintNormalHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);
    9878:	80 e0       	ldi	r24, 0x00	; 0
    987a:	61 e0       	ldi	r22, 0x01	; 1
    987c:	4d e1       	ldi	r20, 0x1D	; 29
    987e:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    9882:	80 e0       	ldi	r24, 0x00	; 0
    9884:	61 e0       	ldi	r22, 0x01	; 1
    9886:	41 e2       	ldi	r20, 0x21	; 33
    9888:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    988c:	80 e0       	ldi	r24, 0x00	; 0
    988e:	61 e0       	ldi	r22, 0x01	; 1
    9890:	40 e0       	ldi	r20, 0x00	; 0
    9892:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    9896:	08 95       	ret

00009898 <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9898:	e1 99       	sbic	0x1c, 1	; 28
    989a:	fe cf       	rjmp	.-4      	; 0x9898 <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    989c:	80 e3       	ldi	r24, 0x30	; 48
    989e:	90 e0       	ldi	r25, 0x00	; 0
    98a0:	9f bb       	out	0x1f, r25	; 31
    98a2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    98a4:	e0 9a       	sbi	0x1c, 0	; 28
    98a6:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    98a8:	82 30       	cpi	r24, 0x02	; 2
    98aa:	79 f4       	brne	.+30     	; 0x98ca <PrintDoubleHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);
    98ac:	80 e0       	ldi	r24, 0x00	; 0
    98ae:	61 e0       	ldi	r22, 0x01	; 1
    98b0:	4d e1       	ldi	r20, 0x1D	; 29
    98b2:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    98b6:	80 e0       	ldi	r24, 0x00	; 0
    98b8:	61 e0       	ldi	r22, 0x01	; 1
    98ba:	41 e2       	ldi	r20, 0x21	; 33
    98bc:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    98c0:	80 e0       	ldi	r24, 0x00	; 0
    98c2:	61 e0       	ldi	r22, 0x01	; 1
    98c4:	41 e0       	ldi	r20, 0x01	; 1
    98c6:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    98ca:	08 95       	ret

000098cc <PaperCut>:

	 return Result;
}


void PaperCut(){
    98cc:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    98ce:	e1 99       	sbic	0x1c, 1	; 28
    98d0:	fe cf       	rjmp	.-4      	; 0x98ce <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98d2:	83 e3       	ldi	r24, 0x33	; 51
    98d4:	90 e0       	ldi	r25, 0x00	; 0
    98d6:	9f bb       	out	0x1f, r25	; 31
    98d8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    98da:	e0 9a       	sbi	0x1c, 0	; 28
    98dc:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&__prt_autocut);
     _uart(_COM_PRINTER, 1, 0x1B);
    98de:	80 e0       	ldi	r24, 0x00	; 0
    98e0:	61 e0       	ldi	r22, 0x01	; 1
    98e2:	4b e1       	ldi	r20, 0x1B	; 27
    98e4:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
    98e8:	11 30       	cpi	r17, 0x01	; 1
    98ea:	21 f4       	brne	.+8      	; 0x98f4 <PaperCut+0x28>
    98ec:	80 e0       	ldi	r24, 0x00	; 0
    98ee:	61 e0       	ldi	r22, 0x01	; 1
    98f0:	4d e6       	ldi	r20, 0x6D	; 109
    98f2:	05 c0       	rjmp	.+10     	; 0x98fe <PaperCut+0x32>
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}
    98f4:	12 30       	cpi	r17, 0x02	; 2
    98f6:	29 f4       	brne	.+10     	; 0x9902 <PaperCut+0x36>
    98f8:	80 e0       	ldi	r24, 0x00	; 0
    98fa:	61 e0       	ldi	r22, 0x01	; 1
    98fc:	49 e6       	ldi	r20, 0x69	; 105
    98fe:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>

}
    9902:	1f 91       	pop	r17
    9904:	08 95       	ret

00009906 <sendMessage98>:
		        break;
	       }//EndSwitch
return Result;
}

void sendMessage98(char PumpID){
    9906:	ff 92       	push	r15
    9908:	0f 93       	push	r16
    990a:	1f 93       	push	r17
    990c:	df 93       	push	r29
    990e:	cf 93       	push	r28
    9910:	cd b7       	in	r28, 0x3d	; 61
    9912:	de b7       	in	r29, 0x3e	; 62
    9914:	ea 97       	sbiw	r28, 0x3a	; 58
    9916:	0f b6       	in	r0, 0x3f	; 63
    9918:	f8 94       	cli
    991a:	de bf       	out	0x3e, r29	; 62
    991c:	0f be       	out	0x3f, r0	; 63
    991e:	cd bf       	out	0x3d, r28	; 61
    9920:	f8 2e       	mov	r15, r24
	char __pump_id[8];
	char strSend[50];
	char xFIP_ID;
	
	_uart(1, 1,0x01);
    9922:	81 e0       	ldi	r24, 0x01	; 1
    9924:	61 e0       	ldi	r22, 0x01	; 1
    9926:	41 e0       	ldi	r20, 0x01	; 1
    9928:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    UpdateIFT_ID(); //ReadIFT_ID
    992c:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9930:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9934:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9938:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    993c:	ce 01       	movw	r24, r28
    993e:	01 96       	adiw	r24, 0x01	; 1
    9940:	65 e4       	ldi	r22, 0x45	; 69
    9942:	70 e0       	ldi	r23, 0x00	; 0
    9944:	48 e0       	ldi	r20, 0x08	; 8
    9946:	50 e0       	ldi	r21, 0x00	; 0
    9948:	27 e9       	ldi	r18, 0x97	; 151
    994a:	32 e1       	ldi	r19, 0x12	; 18
    994c:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	xFIP_ID=__pump_id[PumpID-1];
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
    9950:	8d b7       	in	r24, 0x3d	; 61
    9952:	9e b7       	in	r25, 0x3e	; 62
    9954:	0e 97       	sbiw	r24, 0x0e	; 14
    9956:	0f b6       	in	r0, 0x3f	; 63
    9958:	f8 94       	cli
    995a:	9e bf       	out	0x3e, r25	; 62
    995c:	0f be       	out	0x3f, r0	; 63
    995e:	8d bf       	out	0x3d, r24	; 61
    9960:	ad b7       	in	r26, 0x3d	; 61
    9962:	be b7       	in	r27, 0x3e	; 62
    9964:	11 96       	adiw	r26, 0x01	; 1
    9966:	8e 01       	movw	r16, r28
    9968:	07 5f       	subi	r16, 0xF7	; 247
    996a:	1f 4f       	sbci	r17, 0xFF	; 255
    996c:	ed b7       	in	r30, 0x3d	; 61
    996e:	fe b7       	in	r31, 0x3e	; 62
    9970:	12 83       	std	Z+2, r17	; 0x02
    9972:	01 83       	std	Z+1, r16	; 0x01
    9974:	82 e8       	ldi	r24, 0x82	; 130
    9976:	9c e1       	ldi	r25, 0x1C	; 28
    9978:	13 96       	adiw	r26, 0x03	; 3
    997a:	9c 93       	st	X, r25
    997c:	8e 93       	st	-X, r24
    997e:	12 97       	sbiw	r26, 0x02	; 2
    9980:	81 ef       	ldi	r24, 0xF1	; 241
    9982:	95 e0       	ldi	r25, 0x05	; 5
    9984:	15 96       	adiw	r26, 0x05	; 5
    9986:	9c 93       	st	X, r25
    9988:	8e 93       	st	-X, r24
    998a:	14 97       	sbiw	r26, 0x04	; 4
    998c:	86 ed       	ldi	r24, 0xD6	; 214
    998e:	9d e0       	ldi	r25, 0x0D	; 13
    9990:	17 96       	adiw	r26, 0x07	; 7
    9992:	9c 93       	st	X, r25
    9994:	8e 93       	st	-X, r24
    9996:	16 97       	sbiw	r26, 0x06	; 6
    9998:	85 ee       	ldi	r24, 0xE5	; 229
    999a:	99 e0       	ldi	r25, 0x09	; 9
    999c:	19 96       	adiw	r26, 0x09	; 9
    999e:	9c 93       	st	X, r25
    99a0:	8e 93       	st	-X, r24
    99a2:	18 97       	sbiw	r26, 0x08	; 8
    99a4:	82 e1       	ldi	r24, 0x12	; 18
    99a6:	9a e0       	ldi	r25, 0x0A	; 10
    99a8:	1b 96       	adiw	r26, 0x0b	; 11
    99aa:	9c 93       	st	X, r25
    99ac:	8e 93       	st	-X, r24
    99ae:	1a 97       	sbiw	r26, 0x0a	; 10
    99b0:	fe 01       	movw	r30, r28
    99b2:	ef 0d       	add	r30, r15
    99b4:	f1 1d       	adc	r31, r1
    99b6:	80 81       	ld	r24, Z
    99b8:	1c 96       	adiw	r26, 0x0c	; 12
    99ba:	8c 93       	st	X, r24
    99bc:	1c 97       	sbiw	r26, 0x0c	; 12
    99be:	1d 96       	adiw	r26, 0x0d	; 13
    99c0:	1c 92       	st	X, r1
    99c2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	_uart_print(1, 0,strSend);
    99c6:	8d b7       	in	r24, 0x3d	; 61
    99c8:	9e b7       	in	r25, 0x3e	; 62
    99ca:	0e 96       	adiw	r24, 0x0e	; 14
    99cc:	0f b6       	in	r0, 0x3f	; 63
    99ce:	f8 94       	cli
    99d0:	9e bf       	out	0x3e, r25	; 62
    99d2:	0f be       	out	0x3f, r0	; 63
    99d4:	8d bf       	out	0x3d, r24	; 61
    99d6:	81 e0       	ldi	r24, 0x01	; 1
    99d8:	60 e0       	ldi	r22, 0x00	; 0
    99da:	a8 01       	movw	r20, r16
    99dc:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    99e0:	81 e0       	ldi	r24, 0x01	; 1
    99e2:	61 e0       	ldi	r22, 0x01	; 1
    99e4:	42 e0       	ldi	r20, 0x02	; 2
    99e6:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	IsBusyMsg11=True;
    99ea:	81 e0       	ldi	r24, 0x01	; 1
    99ec:	80 93 da 01 	sts	0x01DA, r24
}
    99f0:	ea 96       	adiw	r28, 0x3a	; 58
    99f2:	0f b6       	in	r0, 0x3f	; 63
    99f4:	f8 94       	cli
    99f6:	de bf       	out	0x3e, r29	; 62
    99f8:	0f be       	out	0x3f, r0	; 63
    99fa:	cd bf       	out	0x3d, r28	; 61
    99fc:	cf 91       	pop	r28
    99fe:	df 91       	pop	r29
    9a00:	1f 91       	pop	r17
    9a02:	0f 91       	pop	r16
    9a04:	ff 90       	pop	r15
    9a06:	08 95       	ret

00009a08 <sendMessage94>:
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage94(){//Void Transaction Message
    9a08:	0f 93       	push	r16
    9a0a:	1f 93       	push	r17
    9a0c:	df 93       	push	r29
    9a0e:	cf 93       	push	r28
    9a10:	cd b7       	in	r28, 0x3d	; 61
    9a12:	de b7       	in	r29, 0x3e	; 62
    9a14:	c0 55       	subi	r28, 0x50	; 80
    9a16:	d0 40       	sbci	r29, 0x00	; 0
    9a18:	0f b6       	in	r0, 0x3f	; 63
    9a1a:	f8 94       	cli
    9a1c:	de bf       	out	0x3e, r29	; 62
    9a1e:	0f be       	out	0x3f, r0	; 63
    9a20:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9a22:	81 e0       	ldi	r24, 0x01	; 1
    9a24:	61 e0       	ldi	r22, 0x01	; 1
    9a26:	41 e0       	ldi	r20, 0x01	; 1
    9a28:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9a2c:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9a30:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9a34:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9a38:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s94"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9a3c:	8d b7       	in	r24, 0x3d	; 61
    9a3e:	9e b7       	in	r25, 0x3e	; 62
    9a40:	0c 97       	sbiw	r24, 0x0c	; 12
    9a42:	0f b6       	in	r0, 0x3f	; 63
    9a44:	f8 94       	cli
    9a46:	9e bf       	out	0x3e, r25	; 62
    9a48:	0f be       	out	0x3f, r0	; 63
    9a4a:	8d bf       	out	0x3d, r24	; 61
    9a4c:	ed b7       	in	r30, 0x3d	; 61
    9a4e:	fe b7       	in	r31, 0x3e	; 62
    9a50:	31 96       	adiw	r30, 0x01	; 1
    9a52:	8e 01       	movw	r16, r28
    9a54:	0f 5f       	subi	r16, 0xFF	; 255
    9a56:	1f 4f       	sbci	r17, 0xFF	; 255
    9a58:	ad b7       	in	r26, 0x3d	; 61
    9a5a:	be b7       	in	r27, 0x3e	; 62
    9a5c:	12 96       	adiw	r26, 0x02	; 2
    9a5e:	1c 93       	st	X, r17
    9a60:	0e 93       	st	-X, r16
    9a62:	11 97       	sbiw	r26, 0x01	; 1
    9a64:	85 e1       	ldi	r24, 0x15	; 21
    9a66:	90 e2       	ldi	r25, 0x20	; 32
    9a68:	93 83       	std	Z+3, r25	; 0x03
    9a6a:	82 83       	std	Z+2, r24	; 0x02
    9a6c:	81 ef       	ldi	r24, 0xF1	; 241
    9a6e:	95 e0       	ldi	r25, 0x05	; 5
    9a70:	95 83       	std	Z+5, r25	; 0x05
    9a72:	84 83       	std	Z+4, r24	; 0x04
    9a74:	86 ed       	ldi	r24, 0xD6	; 214
    9a76:	9d e0       	ldi	r25, 0x0D	; 13
    9a78:	97 83       	std	Z+7, r25	; 0x07
    9a7a:	86 83       	std	Z+6, r24	; 0x06
    9a7c:	85 ee       	ldi	r24, 0xE5	; 229
    9a7e:	99 e0       	ldi	r25, 0x09	; 9
    9a80:	91 87       	std	Z+9, r25	; 0x09
    9a82:	80 87       	std	Z+8, r24	; 0x08
    9a84:	82 e1       	ldi	r24, 0x12	; 18
    9a86:	9a e0       	ldi	r25, 0x0A	; 10
    9a88:	93 87       	std	Z+11, r25	; 0x0b
    9a8a:	82 87       	std	Z+10, r24	; 0x0a
    9a8c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9a90:	ed b7       	in	r30, 0x3d	; 61
    9a92:	fe b7       	in	r31, 0x3e	; 62
    9a94:	3c 96       	adiw	r30, 0x0c	; 12
    9a96:	0f b6       	in	r0, 0x3f	; 63
    9a98:	f8 94       	cli
    9a9a:	fe bf       	out	0x3e, r31	; 62
    9a9c:	0f be       	out	0x3f, r0	; 63
    9a9e:	ed bf       	out	0x3d, r30	; 61
    9aa0:	81 e0       	ldi	r24, 0x01	; 1
    9aa2:	60 e0       	ldi	r22, 0x00	; 0
    9aa4:	a8 01       	movw	r20, r16
    9aa6:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s"),strInvoiceNumber,strDateTime);
    9aaa:	8d b7       	in	r24, 0x3d	; 61
    9aac:	9e b7       	in	r25, 0x3e	; 62
    9aae:	08 97       	sbiw	r24, 0x08	; 8
    9ab0:	0f b6       	in	r0, 0x3f	; 63
    9ab2:	f8 94       	cli
    9ab4:	9e bf       	out	0x3e, r25	; 62
    9ab6:	0f be       	out	0x3f, r0	; 63
    9ab8:	8d bf       	out	0x3d, r24	; 61
    9aba:	ed b7       	in	r30, 0x3d	; 61
    9abc:	fe b7       	in	r31, 0x3e	; 62
    9abe:	31 96       	adiw	r30, 0x01	; 1
    9ac0:	ad b7       	in	r26, 0x3d	; 61
    9ac2:	be b7       	in	r27, 0x3e	; 62
    9ac4:	12 96       	adiw	r26, 0x02	; 2
    9ac6:	1c 93       	st	X, r17
    9ac8:	0e 93       	st	-X, r16
    9aca:	11 97       	sbiw	r26, 0x01	; 1
    9acc:	80 e1       	ldi	r24, 0x10	; 16
    9ace:	90 e2       	ldi	r25, 0x20	; 32
    9ad0:	93 83       	std	Z+3, r25	; 0x03
    9ad2:	82 83       	std	Z+2, r24	; 0x02
    9ad4:	8d e5       	ldi	r24, 0x5D	; 93
    9ad6:	99 e0       	ldi	r25, 0x09	; 9
    9ad8:	95 83       	std	Z+5, r25	; 0x05
    9ada:	84 83       	std	Z+4, r24	; 0x04
    9adc:	82 ec       	ldi	r24, 0xC2	; 194
    9ade:	9d e0       	ldi	r25, 0x0D	; 13
    9ae0:	97 83       	std	Z+7, r25	; 0x07
    9ae2:	86 83       	std	Z+6, r24	; 0x06
    9ae4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9ae8:	ed b7       	in	r30, 0x3d	; 61
    9aea:	fe b7       	in	r31, 0x3e	; 62
    9aec:	38 96       	adiw	r30, 0x08	; 8
    9aee:	0f b6       	in	r0, 0x3f	; 63
    9af0:	f8 94       	cli
    9af2:	fe bf       	out	0x3e, r31	; 62
    9af4:	0f be       	out	0x3f, r0	; 63
    9af6:	ed bf       	out	0x3d, r30	; 61
    9af8:	81 e0       	ldi	r24, 0x01	; 1
    9afa:	60 e0       	ldi	r22, 0x00	; 0
    9afc:	a8 01       	movw	r20, r16
    9afe:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9b02:	00 d0       	rcall	.+0      	; 0x9b04 <sendMessage94+0xfc>
    9b04:	00 d0       	rcall	.+0      	; 0x9b06 <sendMessage94+0xfe>
    9b06:	ad b7       	in	r26, 0x3d	; 61
    9b08:	be b7       	in	r27, 0x3e	; 62
    9b0a:	12 96       	adiw	r26, 0x02	; 2
    9b0c:	1c 93       	st	X, r17
    9b0e:	0e 93       	st	-X, r16
    9b10:	11 97       	sbiw	r26, 0x01	; 1
    9b12:	87 e0       	ldi	r24, 0x07	; 7
    9b14:	90 e2       	ldi	r25, 0x20	; 32
    9b16:	14 96       	adiw	r26, 0x04	; 4
    9b18:	9c 93       	st	X, r25
    9b1a:	8e 93       	st	-X, r24
    9b1c:	13 97       	sbiw	r26, 0x03	; 3
    9b1e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9b22:	0f 90       	pop	r0
    9b24:	0f 90       	pop	r0
    9b26:	0f 90       	pop	r0
    9b28:	0f 90       	pop	r0
    9b2a:	81 e0       	ldi	r24, 0x01	; 1
    9b2c:	60 e0       	ldi	r22, 0x00	; 0
    9b2e:	a8 01       	movw	r20, r16
    9b30:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    9b34:	81 e0       	ldi	r24, 0x01	; 1
    9b36:	61 e0       	ldi	r22, 0x01	; 1
    9b38:	42 e0       	ldi	r20, 0x02	; 2
    9b3a:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    9b3e:	c0 5b       	subi	r28, 0xB0	; 176
    9b40:	df 4f       	sbci	r29, 0xFF	; 255
    9b42:	0f b6       	in	r0, 0x3f	; 63
    9b44:	f8 94       	cli
    9b46:	de bf       	out	0x3e, r29	; 62
    9b48:	0f be       	out	0x3f, r0	; 63
    9b4a:	cd bf       	out	0x3d, r28	; 61
    9b4c:	cf 91       	pop	r28
    9b4e:	df 91       	pop	r29
    9b50:	1f 91       	pop	r17
    9b52:	0f 91       	pop	r16
    9b54:	08 95       	ret

00009b56 <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage92(){
    9b56:	0f 93       	push	r16
    9b58:	1f 93       	push	r17
    9b5a:	df 93       	push	r29
    9b5c:	cf 93       	push	r28
    9b5e:	cd b7       	in	r28, 0x3d	; 61
    9b60:	de b7       	in	r29, 0x3e	; 62
    9b62:	c0 55       	subi	r28, 0x50	; 80
    9b64:	d0 40       	sbci	r29, 0x00	; 0
    9b66:	0f b6       	in	r0, 0x3f	; 63
    9b68:	f8 94       	cli
    9b6a:	de bf       	out	0x3e, r29	; 62
    9b6c:	0f be       	out	0x3f, r0	; 63
    9b6e:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9b70:	81 e0       	ldi	r24, 0x01	; 1
    9b72:	61 e0       	ldi	r22, 0x01	; 1
    9b74:	41 e0       	ldi	r20, 0x01	; 1
    9b76:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9b7a:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9b7e:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9b82:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9b86:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s92"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9b8a:	8d b7       	in	r24, 0x3d	; 61
    9b8c:	9e b7       	in	r25, 0x3e	; 62
    9b8e:	0c 97       	sbiw	r24, 0x0c	; 12
    9b90:	0f b6       	in	r0, 0x3f	; 63
    9b92:	f8 94       	cli
    9b94:	9e bf       	out	0x3e, r25	; 62
    9b96:	0f be       	out	0x3f, r0	; 63
    9b98:	8d bf       	out	0x3d, r24	; 61
    9b9a:	ed b7       	in	r30, 0x3d	; 61
    9b9c:	fe b7       	in	r31, 0x3e	; 62
    9b9e:	31 96       	adiw	r30, 0x01	; 1
    9ba0:	8e 01       	movw	r16, r28
    9ba2:	0f 5f       	subi	r16, 0xFF	; 255
    9ba4:	1f 4f       	sbci	r17, 0xFF	; 255
    9ba6:	ad b7       	in	r26, 0x3d	; 61
    9ba8:	be b7       	in	r27, 0x3e	; 62
    9baa:	12 96       	adiw	r26, 0x02	; 2
    9bac:	1c 93       	st	X, r17
    9bae:	0e 93       	st	-X, r16
    9bb0:	11 97       	sbiw	r26, 0x01	; 1
    9bb2:	89 e3       	ldi	r24, 0x39	; 57
    9bb4:	90 e2       	ldi	r25, 0x20	; 32
    9bb6:	93 83       	std	Z+3, r25	; 0x03
    9bb8:	82 83       	std	Z+2, r24	; 0x02
    9bba:	81 ef       	ldi	r24, 0xF1	; 241
    9bbc:	95 e0       	ldi	r25, 0x05	; 5
    9bbe:	95 83       	std	Z+5, r25	; 0x05
    9bc0:	84 83       	std	Z+4, r24	; 0x04
    9bc2:	86 ed       	ldi	r24, 0xD6	; 214
    9bc4:	9d e0       	ldi	r25, 0x0D	; 13
    9bc6:	97 83       	std	Z+7, r25	; 0x07
    9bc8:	86 83       	std	Z+6, r24	; 0x06
    9bca:	85 ee       	ldi	r24, 0xE5	; 229
    9bcc:	99 e0       	ldi	r25, 0x09	; 9
    9bce:	91 87       	std	Z+9, r25	; 0x09
    9bd0:	80 87       	std	Z+8, r24	; 0x08
    9bd2:	82 e1       	ldi	r24, 0x12	; 18
    9bd4:	9a e0       	ldi	r25, 0x0A	; 10
    9bd6:	93 87       	std	Z+11, r25	; 0x0b
    9bd8:	82 87       	std	Z+10, r24	; 0x0a
    9bda:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9bde:	ed b7       	in	r30, 0x3d	; 61
    9be0:	fe b7       	in	r31, 0x3e	; 62
    9be2:	3c 96       	adiw	r30, 0x0c	; 12
    9be4:	0f b6       	in	r0, 0x3f	; 63
    9be6:	f8 94       	cli
    9be8:	fe bf       	out	0x3e, r31	; 62
    9bea:	0f be       	out	0x3f, r0	; 63
    9bec:	ed bf       	out	0x3d, r30	; 61
    9bee:	81 e0       	ldi	r24, 0x01	; 1
    9bf0:	60 e0       	ldi	r22, 0x00	; 0
    9bf2:	a8 01       	movw	r20, r16
    9bf4:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    9bf8:	8d b7       	in	r24, 0x3d	; 61
    9bfa:	9e b7       	in	r25, 0x3e	; 62
    9bfc:	0c 97       	sbiw	r24, 0x0c	; 12
    9bfe:	0f b6       	in	r0, 0x3f	; 63
    9c00:	f8 94       	cli
    9c02:	9e bf       	out	0x3e, r25	; 62
    9c04:	0f be       	out	0x3f, r0	; 63
    9c06:	8d bf       	out	0x3d, r24	; 61
    9c08:	ed b7       	in	r30, 0x3d	; 61
    9c0a:	fe b7       	in	r31, 0x3e	; 62
    9c0c:	31 96       	adiw	r30, 0x01	; 1
    9c0e:	ad b7       	in	r26, 0x3d	; 61
    9c10:	be b7       	in	r27, 0x3e	; 62
    9c12:	12 96       	adiw	r26, 0x02	; 2
    9c14:	1c 93       	st	X, r17
    9c16:	0e 93       	st	-X, r16
    9c18:	11 97       	sbiw	r26, 0x01	; 1
    9c1a:	80 e3       	ldi	r24, 0x30	; 48
    9c1c:	90 e2       	ldi	r25, 0x20	; 32
    9c1e:	93 83       	std	Z+3, r25	; 0x03
    9c20:	82 83       	std	Z+2, r24	; 0x02
    9c22:	8d e8       	ldi	r24, 0x8D	; 141
    9c24:	9e e0       	ldi	r25, 0x0E	; 14
    9c26:	95 83       	std	Z+5, r25	; 0x05
    9c28:	84 83       	std	Z+4, r24	; 0x04
    9c2a:	83 ec       	ldi	r24, 0xC3	; 195
    9c2c:	99 e0       	ldi	r25, 0x09	; 9
    9c2e:	97 83       	std	Z+7, r25	; 0x07
    9c30:	86 83       	std	Z+6, r24	; 0x06
    9c32:	89 ea       	ldi	r24, 0xA9	; 169
    9c34:	9e e0       	ldi	r25, 0x0E	; 14
    9c36:	91 87       	std	Z+9, r25	; 0x09
    9c38:	80 87       	std	Z+8, r24	; 0x08
    9c3a:	8c e8       	ldi	r24, 0x8C	; 140
    9c3c:	9d e0       	ldi	r25, 0x0D	; 13
    9c3e:	93 87       	std	Z+11, r25	; 0x0b
    9c40:	82 87       	std	Z+10, r24	; 0x0a
    9c42:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9c46:	ed b7       	in	r30, 0x3d	; 61
    9c48:	fe b7       	in	r31, 0x3e	; 62
    9c4a:	3c 96       	adiw	r30, 0x0c	; 12
    9c4c:	0f b6       	in	r0, 0x3f	; 63
    9c4e:	f8 94       	cli
    9c50:	fe bf       	out	0x3e, r31	; 62
    9c52:	0f be       	out	0x3f, r0	; 63
    9c54:	ed bf       	out	0x3d, r30	; 61
    9c56:	81 e0       	ldi	r24, 0x01	; 1
    9c58:	60 e0       	ldi	r22, 0x00	; 0
    9c5a:	a8 01       	movw	r20, r16
    9c5c:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    9c60:	8d b7       	in	r24, 0x3d	; 61
    9c62:	9e b7       	in	r25, 0x3e	; 62
    9c64:	0a 97       	sbiw	r24, 0x0a	; 10
    9c66:	0f b6       	in	r0, 0x3f	; 63
    9c68:	f8 94       	cli
    9c6a:	9e bf       	out	0x3e, r25	; 62
    9c6c:	0f be       	out	0x3f, r0	; 63
    9c6e:	8d bf       	out	0x3d, r24	; 61
    9c70:	ed b7       	in	r30, 0x3d	; 61
    9c72:	fe b7       	in	r31, 0x3e	; 62
    9c74:	31 96       	adiw	r30, 0x01	; 1
    9c76:	ad b7       	in	r26, 0x3d	; 61
    9c78:	be b7       	in	r27, 0x3e	; 62
    9c7a:	12 96       	adiw	r26, 0x02	; 2
    9c7c:	1c 93       	st	X, r17
    9c7e:	0e 93       	st	-X, r16
    9c80:	11 97       	sbiw	r26, 0x01	; 1
    9c82:	89 e2       	ldi	r24, 0x29	; 41
    9c84:	90 e2       	ldi	r25, 0x20	; 32
    9c86:	93 83       	std	Z+3, r25	; 0x03
    9c88:	82 83       	std	Z+2, r24	; 0x02
    9c8a:	8b e0       	ldi	r24, 0x0B	; 11
    9c8c:	9a e0       	ldi	r25, 0x0A	; 10
    9c8e:	95 83       	std	Z+5, r25	; 0x05
    9c90:	84 83       	std	Z+4, r24	; 0x04
    9c92:	8d e5       	ldi	r24, 0x5D	; 93
    9c94:	99 e0       	ldi	r25, 0x09	; 9
    9c96:	97 83       	std	Z+7, r25	; 0x07
    9c98:	86 83       	std	Z+6, r24	; 0x06
    9c9a:	82 ec       	ldi	r24, 0xC2	; 194
    9c9c:	9d e0       	ldi	r25, 0x0D	; 13
    9c9e:	91 87       	std	Z+9, r25	; 0x09
    9ca0:	80 87       	std	Z+8, r24	; 0x08
    9ca2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9ca6:	ed b7       	in	r30, 0x3d	; 61
    9ca8:	fe b7       	in	r31, 0x3e	; 62
    9caa:	3a 96       	adiw	r30, 0x0a	; 10
    9cac:	0f b6       	in	r0, 0x3f	; 63
    9cae:	f8 94       	cli
    9cb0:	fe bf       	out	0x3e, r31	; 62
    9cb2:	0f be       	out	0x3f, r0	; 63
    9cb4:	ed bf       	out	0x3d, r30	; 61
    9cb6:	81 e0       	ldi	r24, 0x01	; 1
    9cb8:	60 e0       	ldi	r22, 0x00	; 0
    9cba:	a8 01       	movw	r20, r16
    9cbc:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    9cc0:	00 d0       	rcall	.+0      	; 0x9cc2 <sendMessage92+0x16c>
    9cc2:	00 d0       	rcall	.+0      	; 0x9cc4 <sendMessage92+0x16e>
    9cc4:	ad b7       	in	r26, 0x3d	; 61
    9cc6:	be b7       	in	r27, 0x3e	; 62
    9cc8:	12 96       	adiw	r26, 0x02	; 2
    9cca:	1c 93       	st	X, r17
    9ccc:	0e 93       	st	-X, r16
    9cce:	11 97       	sbiw	r26, 0x01	; 1
    9cd0:	80 e2       	ldi	r24, 0x20	; 32
    9cd2:	90 e2       	ldi	r25, 0x20	; 32
    9cd4:	14 96       	adiw	r26, 0x04	; 4
    9cd6:	9c 93       	st	X, r25
    9cd8:	8e 93       	st	-X, r24
    9cda:	13 97       	sbiw	r26, 0x03	; 3
    9cdc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9ce0:	0f 90       	pop	r0
    9ce2:	0f 90       	pop	r0
    9ce4:	0f 90       	pop	r0
    9ce6:	0f 90       	pop	r0
    9ce8:	81 e0       	ldi	r24, 0x01	; 1
    9cea:	60 e0       	ldi	r22, 0x00	; 0
    9cec:	a8 01       	movw	r20, r16
    9cee:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    9cf2:	81 e0       	ldi	r24, 0x01	; 1
    9cf4:	61 e0       	ldi	r22, 0x01	; 1
    9cf6:	42 e0       	ldi	r20, 0x02	; 2
    9cf8:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    9cfc:	c0 5b       	subi	r28, 0xB0	; 176
    9cfe:	df 4f       	sbci	r29, 0xFF	; 255
    9d00:	0f b6       	in	r0, 0x3f	; 63
    9d02:	f8 94       	cli
    9d04:	de bf       	out	0x3e, r29	; 62
    9d06:	0f be       	out	0x3f, r0	; 63
    9d08:	cd bf       	out	0x3d, r28	; 61
    9d0a:	cf 91       	pop	r28
    9d0c:	df 91       	pop	r29
    9d0e:	1f 91       	pop	r17
    9d10:	0f 91       	pop	r16
    9d12:	08 95       	ret

00009d14 <sendMessage90>:
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage90(){
    9d14:	0f 93       	push	r16
    9d16:	1f 93       	push	r17
    9d18:	df 93       	push	r29
    9d1a:	cf 93       	push	r28
    9d1c:	cd b7       	in	r28, 0x3d	; 61
    9d1e:	de b7       	in	r29, 0x3e	; 62
    9d20:	c0 55       	subi	r28, 0x50	; 80
    9d22:	d0 40       	sbci	r29, 0x00	; 0
    9d24:	0f b6       	in	r0, 0x3f	; 63
    9d26:	f8 94       	cli
    9d28:	de bf       	out	0x3e, r29	; 62
    9d2a:	0f be       	out	0x3f, r0	; 63
    9d2c:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9d2e:	81 e0       	ldi	r24, 0x01	; 1
    9d30:	61 e0       	ldi	r22, 0x01	; 1
    9d32:	41 e0       	ldi	r20, 0x01	; 1
    9d34:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9d38:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9d3c:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9d40:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9d44:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s90"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9d48:	8d b7       	in	r24, 0x3d	; 61
    9d4a:	9e b7       	in	r25, 0x3e	; 62
    9d4c:	0c 97       	sbiw	r24, 0x0c	; 12
    9d4e:	0f b6       	in	r0, 0x3f	; 63
    9d50:	f8 94       	cli
    9d52:	9e bf       	out	0x3e, r25	; 62
    9d54:	0f be       	out	0x3f, r0	; 63
    9d56:	8d bf       	out	0x3d, r24	; 61
    9d58:	ed b7       	in	r30, 0x3d	; 61
    9d5a:	fe b7       	in	r31, 0x3e	; 62
    9d5c:	31 96       	adiw	r30, 0x01	; 1
    9d5e:	8e 01       	movw	r16, r28
    9d60:	0f 5f       	subi	r16, 0xFF	; 255
    9d62:	1f 4f       	sbci	r17, 0xFF	; 255
    9d64:	ad b7       	in	r26, 0x3d	; 61
    9d66:	be b7       	in	r27, 0x3e	; 62
    9d68:	12 96       	adiw	r26, 0x02	; 2
    9d6a:	1c 93       	st	X, r17
    9d6c:	0e 93       	st	-X, r16
    9d6e:	11 97       	sbiw	r26, 0x01	; 1
    9d70:	82 e5       	ldi	r24, 0x52	; 82
    9d72:	90 e2       	ldi	r25, 0x20	; 32
    9d74:	93 83       	std	Z+3, r25	; 0x03
    9d76:	82 83       	std	Z+2, r24	; 0x02
    9d78:	81 ef       	ldi	r24, 0xF1	; 241
    9d7a:	95 e0       	ldi	r25, 0x05	; 5
    9d7c:	95 83       	std	Z+5, r25	; 0x05
    9d7e:	84 83       	std	Z+4, r24	; 0x04
    9d80:	86 ed       	ldi	r24, 0xD6	; 214
    9d82:	9d e0       	ldi	r25, 0x0D	; 13
    9d84:	97 83       	std	Z+7, r25	; 0x07
    9d86:	86 83       	std	Z+6, r24	; 0x06
    9d88:	85 ee       	ldi	r24, 0xE5	; 229
    9d8a:	99 e0       	ldi	r25, 0x09	; 9
    9d8c:	91 87       	std	Z+9, r25	; 0x09
    9d8e:	80 87       	std	Z+8, r24	; 0x08
    9d90:	82 e1       	ldi	r24, 0x12	; 18
    9d92:	9a e0       	ldi	r25, 0x0A	; 10
    9d94:	93 87       	std	Z+11, r25	; 0x0b
    9d96:	82 87       	std	Z+10, r24	; 0x0a
    9d98:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9d9c:	ed b7       	in	r30, 0x3d	; 61
    9d9e:	fe b7       	in	r31, 0x3e	; 62
    9da0:	3c 96       	adiw	r30, 0x0c	; 12
    9da2:	0f b6       	in	r0, 0x3f	; 63
    9da4:	f8 94       	cli
    9da6:	fe bf       	out	0x3e, r31	; 62
    9da8:	0f be       	out	0x3f, r0	; 63
    9daa:	ed bf       	out	0x3d, r30	; 61
    9dac:	81 e0       	ldi	r24, 0x01	; 1
    9dae:	60 e0       	ldi	r22, 0x00	; 0
    9db0:	a8 01       	movw	r20, r16
    9db2:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    9db6:	8d b7       	in	r24, 0x3d	; 61
    9db8:	9e b7       	in	r25, 0x3e	; 62
    9dba:	08 97       	sbiw	r24, 0x08	; 8
    9dbc:	0f b6       	in	r0, 0x3f	; 63
    9dbe:	f8 94       	cli
    9dc0:	9e bf       	out	0x3e, r25	; 62
    9dc2:	0f be       	out	0x3f, r0	; 63
    9dc4:	8d bf       	out	0x3d, r24	; 61
    9dc6:	ed b7       	in	r30, 0x3d	; 61
    9dc8:	fe b7       	in	r31, 0x3e	; 62
    9dca:	31 96       	adiw	r30, 0x01	; 1
    9dcc:	ad b7       	in	r26, 0x3d	; 61
    9dce:	be b7       	in	r27, 0x3e	; 62
    9dd0:	12 96       	adiw	r26, 0x02	; 2
    9dd2:	1c 93       	st	X, r17
    9dd4:	0e 93       	st	-X, r16
    9dd6:	11 97       	sbiw	r26, 0x01	; 1
    9dd8:	8d e4       	ldi	r24, 0x4D	; 77
    9dda:	90 e2       	ldi	r25, 0x20	; 32
    9ddc:	93 83       	std	Z+3, r25	; 0x03
    9dde:	82 83       	std	Z+2, r24	; 0x02
    9de0:	83 ec       	ldi	r24, 0xC3	; 195
    9de2:	99 e0       	ldi	r25, 0x09	; 9
    9de4:	95 83       	std	Z+5, r25	; 0x05
    9de6:	84 83       	std	Z+4, r24	; 0x04
    9de8:	84 e9       	ldi	r24, 0x94	; 148
    9dea:	9e e0       	ldi	r25, 0x0E	; 14
    9dec:	97 83       	std	Z+7, r25	; 0x07
    9dee:	86 83       	std	Z+6, r24	; 0x06
    9df0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9df4:	ed b7       	in	r30, 0x3d	; 61
    9df6:	fe b7       	in	r31, 0x3e	; 62
    9df8:	38 96       	adiw	r30, 0x08	; 8
    9dfa:	0f b6       	in	r0, 0x3f	; 63
    9dfc:	f8 94       	cli
    9dfe:	fe bf       	out	0x3e, r31	; 62
    9e00:	0f be       	out	0x3f, r0	; 63
    9e02:	ed bf       	out	0x3d, r30	; 61
    9e04:	81 e0       	ldi	r24, 0x01	; 1
    9e06:	60 e0       	ldi	r22, 0x00	; 0
    9e08:	a8 01       	movw	r20, r16
    9e0a:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9e0e:	00 d0       	rcall	.+0      	; 0x9e10 <sendMessage90+0xfc>
    9e10:	00 d0       	rcall	.+0      	; 0x9e12 <sendMessage90+0xfe>
    9e12:	ad b7       	in	r26, 0x3d	; 61
    9e14:	be b7       	in	r27, 0x3e	; 62
    9e16:	12 96       	adiw	r26, 0x02	; 2
    9e18:	1c 93       	st	X, r17
    9e1a:	0e 93       	st	-X, r16
    9e1c:	11 97       	sbiw	r26, 0x01	; 1
    9e1e:	84 e4       	ldi	r24, 0x44	; 68
    9e20:	90 e2       	ldi	r25, 0x20	; 32
    9e22:	14 96       	adiw	r26, 0x04	; 4
    9e24:	9c 93       	st	X, r25
    9e26:	8e 93       	st	-X, r24
    9e28:	13 97       	sbiw	r26, 0x03	; 3
    9e2a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9e2e:	0f 90       	pop	r0
    9e30:	0f 90       	pop	r0
    9e32:	0f 90       	pop	r0
    9e34:	0f 90       	pop	r0
    9e36:	81 e0       	ldi	r24, 0x01	; 1
    9e38:	60 e0       	ldi	r22, 0x00	; 0
    9e3a:	a8 01       	movw	r20, r16
    9e3c:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    9e40:	81 e0       	ldi	r24, 0x01	; 1
    9e42:	61 e0       	ldi	r22, 0x01	; 1
    9e44:	42 e0       	ldi	r20, 0x02	; 2
    9e46:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    9e4a:	c0 5b       	subi	r28, 0xB0	; 176
    9e4c:	df 4f       	sbci	r29, 0xFF	; 255
    9e4e:	0f b6       	in	r0, 0x3f	; 63
    9e50:	f8 94       	cli
    9e52:	de bf       	out	0x3e, r29	; 62
    9e54:	0f be       	out	0x3f, r0	; 63
    9e56:	cd bf       	out	0x3d, r28	; 61
    9e58:	cf 91       	pop	r28
    9e5a:	df 91       	pop	r29
    9e5c:	1f 91       	pop	r17
    9e5e:	0f 91       	pop	r16
    9e60:	08 95       	ret

00009e62 <sendMessage58>:

	_uart_printf(1,0,PSTR("AF968CFFB"));
	_uart(1, 1,0x02);
}

void sendMessage58(){
    9e62:	cf 92       	push	r12
    9e64:	df 92       	push	r13
    9e66:	ef 92       	push	r14
    9e68:	ff 92       	push	r15
    9e6a:	0f 93       	push	r16
    9e6c:	1f 93       	push	r17
    9e6e:	df 93       	push	r29
    9e70:	cf 93       	push	r28
    9e72:	cd b7       	in	r28, 0x3d	; 61
    9e74:	de b7       	in	r29, 0x3e	; 62
    9e76:	c0 55       	subi	r28, 0x50	; 80
    9e78:	d0 40       	sbci	r29, 0x00	; 0
    9e7a:	0f b6       	in	r0, 0x3f	; 63
    9e7c:	f8 94       	cli
    9e7e:	de bf       	out	0x3e, r29	; 62
    9e80:	0f be       	out	0x3f, r0	; 63
    9e82:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9e84:	81 e0       	ldi	r24, 0x01	; 1
    9e86:	61 e0       	ldi	r22, 0x01	; 1
    9e88:	41 e0       	ldi	r20, 0x01	; 1
    9e8a:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9e8e:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9e92:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9e96:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9e9a:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	UpdateCardID();  //ReadCardID
    9e9e:	0e 94 95 3c 	call	0x792a	; 0x792a <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%s%s%s58"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9ea2:	8d b7       	in	r24, 0x3d	; 61
    9ea4:	9e b7       	in	r25, 0x3e	; 62
    9ea6:	0c 97       	sbiw	r24, 0x0c	; 12
    9ea8:	0f b6       	in	r0, 0x3f	; 63
    9eaa:	f8 94       	cli
    9eac:	9e bf       	out	0x3e, r25	; 62
    9eae:	0f be       	out	0x3f, r0	; 63
    9eb0:	8d bf       	out	0x3d, r24	; 61
    9eb2:	ed b7       	in	r30, 0x3d	; 61
    9eb4:	fe b7       	in	r31, 0x3e	; 62
    9eb6:	31 96       	adiw	r30, 0x01	; 1
    9eb8:	8e 01       	movw	r16, r28
    9eba:	0f 5f       	subi	r16, 0xFF	; 255
    9ebc:	1f 4f       	sbci	r17, 0xFF	; 255
    9ebe:	ad b7       	in	r26, 0x3d	; 61
    9ec0:	be b7       	in	r27, 0x3e	; 62
    9ec2:	12 96       	adiw	r26, 0x02	; 2
    9ec4:	1c 93       	st	X, r17
    9ec6:	0e 93       	st	-X, r16
    9ec8:	11 97       	sbiw	r26, 0x01	; 1
    9eca:	89 e8       	ldi	r24, 0x89	; 137
    9ecc:	90 e2       	ldi	r25, 0x20	; 32
    9ece:	93 83       	std	Z+3, r25	; 0x03
    9ed0:	82 83       	std	Z+2, r24	; 0x02
    9ed2:	81 ef       	ldi	r24, 0xF1	; 241
    9ed4:	95 e0       	ldi	r25, 0x05	; 5
    9ed6:	95 83       	std	Z+5, r25	; 0x05
    9ed8:	84 83       	std	Z+4, r24	; 0x04
    9eda:	86 ed       	ldi	r24, 0xD6	; 214
    9edc:	9d e0       	ldi	r25, 0x0D	; 13
    9ede:	97 83       	std	Z+7, r25	; 0x07
    9ee0:	86 83       	std	Z+6, r24	; 0x06
    9ee2:	85 ee       	ldi	r24, 0xE5	; 229
    9ee4:	99 e0       	ldi	r25, 0x09	; 9
    9ee6:	91 87       	std	Z+9, r25	; 0x09
    9ee8:	80 87       	std	Z+8, r24	; 0x08
    9eea:	82 e1       	ldi	r24, 0x12	; 18
    9eec:	9a e0       	ldi	r25, 0x0A	; 10
    9eee:	93 87       	std	Z+11, r25	; 0x0b
    9ef0:	82 87       	std	Z+10, r24	; 0x0a
    9ef2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9ef6:	8d b7       	in	r24, 0x3d	; 61
    9ef8:	9e b7       	in	r25, 0x3e	; 62
    9efa:	0c 96       	adiw	r24, 0x0c	; 12
    9efc:	0f b6       	in	r0, 0x3f	; 63
    9efe:	f8 94       	cli
    9f00:	9e bf       	out	0x3e, r25	; 62
    9f02:	0f be       	out	0x3f, r0	; 63
    9f04:	8d bf       	out	0x3d, r24	; 61
    9f06:	81 e0       	ldi	r24, 0x01	; 1
    9f08:	60 e0       	ldi	r22, 0x00	; 0
    9f0a:	a8 01       	movw	r20, r16
    9f0c:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	AddSpaceLead(strBalanceValue,13);
    9f10:	f5 e2       	ldi	r31, 0x25	; 37
    9f12:	ef 2e       	mov	r14, r31
    9f14:	fe e0       	ldi	r31, 0x0E	; 14
    9f16:	ff 2e       	mov	r15, r31
    9f18:	c7 01       	movw	r24, r14
    9f1a:	6d e0       	ldi	r22, 0x0D	; 13
    9f1c:	0e 94 19 2a 	call	0x5432	; 0x5432 <AddSpaceLead>
	AddSpaceLead(strOdometer,10);
    9f20:	e8 ec       	ldi	r30, 0xC8	; 200
    9f22:	ce 2e       	mov	r12, r30
    9f24:	e5 e0       	ldi	r30, 0x05	; 5
    9f26:	de 2e       	mov	r13, r30
    9f28:	c6 01       	movw	r24, r12
    9f2a:	6a e0       	ldi	r22, 0x0A	; 10
    9f2c:	0e 94 19 2a 	call	0x5432	; 0x5432 <AddSpaceLead>
	sprintf_P(strSend,PSTR("%s%s%d%s%s"),strCardID,strFIP_ID,NozzleID,strBalanceType,strBalanceValue);
    9f30:	ad b7       	in	r26, 0x3d	; 61
    9f32:	be b7       	in	r27, 0x3e	; 62
    9f34:	1e 97       	sbiw	r26, 0x0e	; 14
    9f36:	0f b6       	in	r0, 0x3f	; 63
    9f38:	f8 94       	cli
    9f3a:	be bf       	out	0x3e, r27	; 62
    9f3c:	0f be       	out	0x3f, r0	; 63
    9f3e:	ad bf       	out	0x3d, r26	; 61
    9f40:	ed b7       	in	r30, 0x3d	; 61
    9f42:	fe b7       	in	r31, 0x3e	; 62
    9f44:	31 96       	adiw	r30, 0x01	; 1
    9f46:	12 96       	adiw	r26, 0x02	; 2
    9f48:	1c 93       	st	X, r17
    9f4a:	0e 93       	st	-X, r16
    9f4c:	11 97       	sbiw	r26, 0x01	; 1
    9f4e:	8e e7       	ldi	r24, 0x7E	; 126
    9f50:	90 e2       	ldi	r25, 0x20	; 32
    9f52:	93 83       	std	Z+3, r25	; 0x03
    9f54:	82 83       	std	Z+2, r24	; 0x02
    9f56:	8c e8       	ldi	r24, 0x8C	; 140
    9f58:	9d e0       	ldi	r25, 0x0D	; 13
    9f5a:	95 83       	std	Z+5, r25	; 0x05
    9f5c:	84 83       	std	Z+4, r24	; 0x04
    9f5e:	83 ec       	ldi	r24, 0xC3	; 195
    9f60:	99 e0       	ldi	r25, 0x09	; 9
    9f62:	97 83       	std	Z+7, r25	; 0x07
    9f64:	86 83       	std	Z+6, r24	; 0x06
    9f66:	80 91 77 09 	lds	r24, 0x0977
    9f6a:	80 87       	std	Z+8, r24	; 0x08
    9f6c:	11 86       	std	Z+9, r1	; 0x09
    9f6e:	88 ea       	ldi	r24, 0xA8	; 168
    9f70:	95 e0       	ldi	r25, 0x05	; 5
    9f72:	93 87       	std	Z+11, r25	; 0x0b
    9f74:	82 87       	std	Z+10, r24	; 0x0a
    9f76:	f5 86       	std	Z+13, r15	; 0x0d
    9f78:	e4 86       	std	Z+12, r14	; 0x0c
    9f7a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9f7e:	8d b7       	in	r24, 0x3d	; 61
    9f80:	9e b7       	in	r25, 0x3e	; 62
    9f82:	0e 96       	adiw	r24, 0x0e	; 14
    9f84:	0f b6       	in	r0, 0x3f	; 63
    9f86:	f8 94       	cli
    9f88:	9e bf       	out	0x3e, r25	; 62
    9f8a:	0f be       	out	0x3f, r0	; 63
    9f8c:	8d bf       	out	0x3d, r24	; 61
    9f8e:	81 e0       	ldi	r24, 0x01	; 1
    9f90:	60 e0       	ldi	r22, 0x00	; 0
    9f92:	a8 01       	movw	r20, r16
    9f94:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

	CardType=0;
    9f98:	10 92 8e 05 	sts	0x058E, r1
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    9f9c:	ad b7       	in	r26, 0x3d	; 61
    9f9e:	be b7       	in	r27, 0x3e	; 62
    9fa0:	18 97       	sbiw	r26, 0x08	; 8
    9fa2:	0f b6       	in	r0, 0x3f	; 63
    9fa4:	f8 94       	cli
    9fa6:	be bf       	out	0x3e, r27	; 62
    9fa8:	0f be       	out	0x3f, r0	; 63
    9faa:	ad bf       	out	0x3d, r26	; 61
    9fac:	ed b7       	in	r30, 0x3d	; 61
    9fae:	fe b7       	in	r31, 0x3e	; 62
    9fb0:	31 96       	adiw	r30, 0x01	; 1
    9fb2:	12 96       	adiw	r26, 0x02	; 2
    9fb4:	1c 93       	st	X, r17
    9fb6:	0e 93       	st	-X, r16
    9fb8:	11 97       	sbiw	r26, 0x01	; 1
    9fba:	8d e5       	ldi	r24, 0x5D	; 93
    9fbc:	90 e2       	ldi	r25, 0x20	; 32
    9fbe:	93 83       	std	Z+3, r25	; 0x03
    9fc0:	82 83       	std	Z+2, r24	; 0x02
    9fc2:	15 82       	std	Z+5, r1	; 0x05
    9fc4:	14 82       	std	Z+4, r1	; 0x04
    9fc6:	d7 82       	std	Z+7, r13	; 0x07
    9fc8:	c6 82       	std	Z+6, r12	; 0x06
    9fca:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    9fce:	8d b7       	in	r24, 0x3d	; 61
    9fd0:	9e b7       	in	r25, 0x3e	; 62
    9fd2:	08 96       	adiw	r24, 0x08	; 8
    9fd4:	0f b6       	in	r0, 0x3f	; 63
    9fd6:	f8 94       	cli
    9fd8:	9e bf       	out	0x3e, r25	; 62
    9fda:	0f be       	out	0x3f, r0	; 63
    9fdc:	8d bf       	out	0x3d, r24	; 61
    9fde:	81 e0       	ldi	r24, 0x01	; 1
    9fe0:	60 e0       	ldi	r22, 0x00	; 0
    9fe2:	a8 01       	movw	r20, r16
    9fe4:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    9fe8:	81 e0       	ldi	r24, 0x01	; 1
    9fea:	61 e0       	ldi	r22, 0x01	; 1
    9fec:	42 e0       	ldi	r20, 0x02	; 2
    9fee:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    9ff2:	c0 5b       	subi	r28, 0xB0	; 176
    9ff4:	df 4f       	sbci	r29, 0xFF	; 255
    9ff6:	0f b6       	in	r0, 0x3f	; 63
    9ff8:	f8 94       	cli
    9ffa:	de bf       	out	0x3e, r29	; 62
    9ffc:	0f be       	out	0x3f, r0	; 63
    9ffe:	cd bf       	out	0x3d, r28	; 61
    a000:	cf 91       	pop	r28
    a002:	df 91       	pop	r29
    a004:	1f 91       	pop	r17
    a006:	0f 91       	pop	r16
    a008:	ff 90       	pop	r15
    a00a:	ef 90       	pop	r14
    a00c:	df 90       	pop	r13
    a00e:	cf 90       	pop	r12
    a010:	08 95       	ret

0000a012 <sendMessage32>:
	_uart(1, 1,0x02);
}



void sendMessage32(){//Msg32: <01>[ID][Seq][SrcIP][DestIP][MsgCode][FIP][PaymentType][Ref1][Ref2][Ref3][Ref4]<02>
    a012:	0f 93       	push	r16
    a014:	1f 93       	push	r17
    a016:	df 93       	push	r29
    a018:	cf 93       	push	r28
    a01a:	cd b7       	in	r28, 0x3d	; 61
    a01c:	de b7       	in	r29, 0x3e	; 62
    a01e:	c0 55       	subi	r28, 0x50	; 80
    a020:	d0 40       	sbci	r29, 0x00	; 0
    a022:	0f b6       	in	r0, 0x3f	; 63
    a024:	f8 94       	cli
    a026:	de bf       	out	0x3e, r29	; 62
    a028:	0f be       	out	0x3f, r0	; 63
    a02a:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	UpdateIFT_ID(); //ReadIFT_ID
    a02c:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a030:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a034:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a038:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	_uart(1, 1,0x01);
    a03c:	81 e0       	ldi	r24, 0x01	; 1
    a03e:	61 e0       	ldi	r22, 0x01	; 1
    a040:	41 e0       	ldi	r20, 0x01	; 1
    a042:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	sprintf_P(strSend,PSTR("%s%s%s%s32"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a046:	8d b7       	in	r24, 0x3d	; 61
    a048:	9e b7       	in	r25, 0x3e	; 62
    a04a:	0c 97       	sbiw	r24, 0x0c	; 12
    a04c:	0f b6       	in	r0, 0x3f	; 63
    a04e:	f8 94       	cli
    a050:	9e bf       	out	0x3e, r25	; 62
    a052:	0f be       	out	0x3f, r0	; 63
    a054:	8d bf       	out	0x3d, r24	; 61
    a056:	ed b7       	in	r30, 0x3d	; 61
    a058:	fe b7       	in	r31, 0x3e	; 62
    a05a:	31 96       	adiw	r30, 0x01	; 1
    a05c:	8e 01       	movw	r16, r28
    a05e:	0f 5f       	subi	r16, 0xFF	; 255
    a060:	1f 4f       	sbci	r17, 0xFF	; 255
    a062:	ad b7       	in	r26, 0x3d	; 61
    a064:	be b7       	in	r27, 0x3e	; 62
    a066:	12 96       	adiw	r26, 0x02	; 2
    a068:	1c 93       	st	X, r17
    a06a:	0e 93       	st	-X, r16
    a06c:	11 97       	sbiw	r26, 0x01	; 1
    a06e:	84 ec       	ldi	r24, 0xC4	; 196
    a070:	90 e2       	ldi	r25, 0x20	; 32
    a072:	93 83       	std	Z+3, r25	; 0x03
    a074:	82 83       	std	Z+2, r24	; 0x02
    a076:	81 ef       	ldi	r24, 0xF1	; 241
    a078:	95 e0       	ldi	r25, 0x05	; 5
    a07a:	95 83       	std	Z+5, r25	; 0x05
    a07c:	84 83       	std	Z+4, r24	; 0x04
    a07e:	86 ed       	ldi	r24, 0xD6	; 214
    a080:	9d e0       	ldi	r25, 0x0D	; 13
    a082:	97 83       	std	Z+7, r25	; 0x07
    a084:	86 83       	std	Z+6, r24	; 0x06
    a086:	85 ee       	ldi	r24, 0xE5	; 229
    a088:	99 e0       	ldi	r25, 0x09	; 9
    a08a:	91 87       	std	Z+9, r25	; 0x09
    a08c:	80 87       	std	Z+8, r24	; 0x08
    a08e:	82 e1       	ldi	r24, 0x12	; 18
    a090:	9a e0       	ldi	r25, 0x0A	; 10
    a092:	93 87       	std	Z+11, r25	; 0x0b
    a094:	82 87       	std	Z+10, r24	; 0x0a
    a096:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a09a:	ed b7       	in	r30, 0x3d	; 61
    a09c:	fe b7       	in	r31, 0x3e	; 62
    a09e:	3c 96       	adiw	r30, 0x0c	; 12
    a0a0:	0f b6       	in	r0, 0x3f	; 63
    a0a2:	f8 94       	cli
    a0a4:	fe bf       	out	0x3e, r31	; 62
    a0a6:	0f be       	out	0x3f, r0	; 63
    a0a8:	ed bf       	out	0x3d, r30	; 61
    a0aa:	81 e0       	ldi	r24, 0x01	; 1
    a0ac:	60 e0       	ldi	r22, 0x00	; 0
    a0ae:	a8 01       	movw	r20, r16
    a0b0:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s%s%s"),strFIP_ID,strPaymentType,strRef1,strRef2);
    a0b4:	8d b7       	in	r24, 0x3d	; 61
    a0b6:	9e b7       	in	r25, 0x3e	; 62
    a0b8:	0c 97       	sbiw	r24, 0x0c	; 12
    a0ba:	0f b6       	in	r0, 0x3f	; 63
    a0bc:	f8 94       	cli
    a0be:	9e bf       	out	0x3e, r25	; 62
    a0c0:	0f be       	out	0x3f, r0	; 63
    a0c2:	8d bf       	out	0x3d, r24	; 61
    a0c4:	ed b7       	in	r30, 0x3d	; 61
    a0c6:	fe b7       	in	r31, 0x3e	; 62
    a0c8:	31 96       	adiw	r30, 0x01	; 1
    a0ca:	ad b7       	in	r26, 0x3d	; 61
    a0cc:	be b7       	in	r27, 0x3e	; 62
    a0ce:	12 96       	adiw	r26, 0x02	; 2
    a0d0:	1c 93       	st	X, r17
    a0d2:	0e 93       	st	-X, r16
    a0d4:	11 97       	sbiw	r26, 0x01	; 1
    a0d6:	8b eb       	ldi	r24, 0xBB	; 187
    a0d8:	90 e2       	ldi	r25, 0x20	; 32
    a0da:	93 83       	std	Z+3, r25	; 0x03
    a0dc:	82 83       	std	Z+2, r24	; 0x02
    a0de:	83 ec       	ldi	r24, 0xC3	; 195
    a0e0:	99 e0       	ldi	r25, 0x09	; 9
    a0e2:	95 83       	std	Z+5, r25	; 0x05
    a0e4:	84 83       	std	Z+4, r24	; 0x04
    a0e6:	8a e5       	ldi	r24, 0x5A	; 90
    a0e8:	99 e0       	ldi	r25, 0x09	; 9
    a0ea:	97 83       	std	Z+7, r25	; 0x07
    a0ec:	86 83       	std	Z+6, r24	; 0x06
    a0ee:	84 e9       	ldi	r24, 0x94	; 148
    a0f0:	9e e0       	ldi	r25, 0x0E	; 14
    a0f2:	91 87       	std	Z+9, r25	; 0x09
    a0f4:	80 87       	std	Z+8, r24	; 0x08
    a0f6:	81 ea       	ldi	r24, 0xA1	; 161
    a0f8:	9d e0       	ldi	r25, 0x0D	; 13
    a0fa:	93 87       	std	Z+11, r25	; 0x0b
    a0fc:	82 87       	std	Z+10, r24	; 0x0a
    a0fe:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a102:	ed b7       	in	r30, 0x3d	; 61
    a104:	fe b7       	in	r31, 0x3e	; 62
    a106:	3c 96       	adiw	r30, 0x0c	; 12
    a108:	0f b6       	in	r0, 0x3f	; 63
    a10a:	f8 94       	cli
    a10c:	fe bf       	out	0x3e, r31	; 62
    a10e:	0f be       	out	0x3f, r0	; 63
    a110:	ed bf       	out	0x3d, r30	; 61
    a112:	81 e0       	ldi	r24, 0x01	; 1
    a114:	60 e0       	ldi	r22, 0x00	; 0
    a116:	a8 01       	movw	r20, r16
    a118:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    a11c:	8d b7       	in	r24, 0x3d	; 61
    a11e:	9e b7       	in	r25, 0x3e	; 62
    a120:	08 97       	sbiw	r24, 0x08	; 8
    a122:	0f b6       	in	r0, 0x3f	; 63
    a124:	f8 94       	cli
    a126:	9e bf       	out	0x3e, r25	; 62
    a128:	0f be       	out	0x3f, r0	; 63
    a12a:	8d bf       	out	0x3d, r24	; 61
    a12c:	ed b7       	in	r30, 0x3d	; 61
    a12e:	fe b7       	in	r31, 0x3e	; 62
    a130:	31 96       	adiw	r30, 0x01	; 1
    a132:	ad b7       	in	r26, 0x3d	; 61
    a134:	be b7       	in	r27, 0x3e	; 62
    a136:	12 96       	adiw	r26, 0x02	; 2
    a138:	1c 93       	st	X, r17
    a13a:	0e 93       	st	-X, r16
    a13c:	11 97       	sbiw	r26, 0x01	; 1
    a13e:	86 eb       	ldi	r24, 0xB6	; 182
    a140:	90 e2       	ldi	r25, 0x20	; 32
    a142:	93 83       	std	Z+3, r25	; 0x03
    a144:	82 83       	std	Z+2, r24	; 0x02
    a146:	8d ea       	ldi	r24, 0xAD	; 173
    a148:	9a e0       	ldi	r25, 0x0A	; 10
    a14a:	95 83       	std	Z+5, r25	; 0x05
    a14c:	84 83       	std	Z+4, r24	; 0x04
    a14e:	8a ea       	ldi	r24, 0xAA	; 170
    a150:	95 e0       	ldi	r25, 0x05	; 5
    a152:	97 83       	std	Z+7, r25	; 0x07
    a154:	86 83       	std	Z+6, r24	; 0x06
    a156:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a15a:	ed b7       	in	r30, 0x3d	; 61
    a15c:	fe b7       	in	r31, 0x3e	; 62
    a15e:	38 96       	adiw	r30, 0x08	; 8
    a160:	0f b6       	in	r0, 0x3f	; 63
    a162:	f8 94       	cli
    a164:	fe bf       	out	0x3e, r31	; 62
    a166:	0f be       	out	0x3f, r0	; 63
    a168:	ed bf       	out	0x3d, r30	; 61
    a16a:	81 e0       	ldi	r24, 0x01	; 1
    a16c:	60 e0       	ldi	r22, 0x00	; 0
    a16e:	a8 01       	movw	r20, r16
    a170:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	sprintf_P(strSend,PSTR("F968CFFB"));
    a174:	00 d0       	rcall	.+0      	; 0xa176 <sendMessage32+0x164>
    a176:	00 d0       	rcall	.+0      	; 0xa178 <sendMessage32+0x166>
    a178:	ad b7       	in	r26, 0x3d	; 61
    a17a:	be b7       	in	r27, 0x3e	; 62
    a17c:	12 96       	adiw	r26, 0x02	; 2
    a17e:	1c 93       	st	X, r17
    a180:	0e 93       	st	-X, r16
    a182:	11 97       	sbiw	r26, 0x01	; 1
    a184:	8d ea       	ldi	r24, 0xAD	; 173
    a186:	90 e2       	ldi	r25, 0x20	; 32
    a188:	14 96       	adiw	r26, 0x04	; 4
    a18a:	9c 93       	st	X, r25
    a18c:	8e 93       	st	-X, r24
    a18e:	13 97       	sbiw	r26, 0x03	; 3
    a190:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a194:	0f 90       	pop	r0
    a196:	0f 90       	pop	r0
    a198:	0f 90       	pop	r0
    a19a:	0f 90       	pop	r0
    a19c:	81 e0       	ldi	r24, 0x01	; 1
    a19e:	60 e0       	ldi	r22, 0x00	; 0
    a1a0:	a8 01       	movw	r20, r16
    a1a2:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    a1a6:	81 e0       	ldi	r24, 0x01	; 1
    a1a8:	61 e0       	ldi	r22, 0x01	; 1
    a1aa:	42 e0       	ldi	r20, 0x02	; 2
    a1ac:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>

}
    a1b0:	c0 5b       	subi	r28, 0xB0	; 176
    a1b2:	df 4f       	sbci	r29, 0xFF	; 255
    a1b4:	0f b6       	in	r0, 0x3f	; 63
    a1b6:	f8 94       	cli
    a1b8:	de bf       	out	0x3e, r29	; 62
    a1ba:	0f be       	out	0x3f, r0	; 63
    a1bc:	cd bf       	out	0x3d, r28	; 61
    a1be:	cf 91       	pop	r28
    a1c0:	df 91       	pop	r29
    a1c2:	1f 91       	pop	r17
    a1c4:	0f 91       	pop	r16
    a1c6:	08 95       	ret

0000a1c8 <sendMessage28>:
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage28(){//Msg28: <01>[0103192.168.016.070192.168.016.18024[FIP][CardID]F968CFFB]<02>
    a1c8:	0f 93       	push	r16
    a1ca:	1f 93       	push	r17
    a1cc:	df 93       	push	r29
    a1ce:	cf 93       	push	r28
    a1d0:	cd b7       	in	r28, 0x3d	; 61
    a1d2:	de b7       	in	r29, 0x3e	; 62
    a1d4:	ec 97       	sbiw	r28, 0x3c	; 60
    a1d6:	0f b6       	in	r0, 0x3f	; 63
    a1d8:	f8 94       	cli
    a1da:	de bf       	out	0x3e, r29	; 62
    a1dc:	0f be       	out	0x3f, r0	; 63
    a1de:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a1e0:	81 e0       	ldi	r24, 0x01	; 1
    a1e2:	61 e0       	ldi	r22, 0x01	; 1
    a1e4:	41 e0       	ldi	r20, 0x01	; 1
    a1e6:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a1ea:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a1ee:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a1f2:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a1f6:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s28"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a1fa:	8d b7       	in	r24, 0x3d	; 61
    a1fc:	9e b7       	in	r25, 0x3e	; 62
    a1fe:	0c 97       	sbiw	r24, 0x0c	; 12
    a200:	0f b6       	in	r0, 0x3f	; 63
    a202:	f8 94       	cli
    a204:	9e bf       	out	0x3e, r25	; 62
    a206:	0f be       	out	0x3f, r0	; 63
    a208:	8d bf       	out	0x3d, r24	; 61
    a20a:	ed b7       	in	r30, 0x3d	; 61
    a20c:	fe b7       	in	r31, 0x3e	; 62
    a20e:	31 96       	adiw	r30, 0x01	; 1
    a210:	8e 01       	movw	r16, r28
    a212:	0f 5f       	subi	r16, 0xFF	; 255
    a214:	1f 4f       	sbci	r17, 0xFF	; 255
    a216:	ad b7       	in	r26, 0x3d	; 61
    a218:	be b7       	in	r27, 0x3e	; 62
    a21a:	12 96       	adiw	r26, 0x02	; 2
    a21c:	1c 93       	st	X, r17
    a21e:	0e 93       	st	-X, r16
    a220:	11 97       	sbiw	r26, 0x01	; 1
    a222:	8c ed       	ldi	r24, 0xDC	; 220
    a224:	90 e2       	ldi	r25, 0x20	; 32
    a226:	93 83       	std	Z+3, r25	; 0x03
    a228:	82 83       	std	Z+2, r24	; 0x02
    a22a:	81 ef       	ldi	r24, 0xF1	; 241
    a22c:	95 e0       	ldi	r25, 0x05	; 5
    a22e:	95 83       	std	Z+5, r25	; 0x05
    a230:	84 83       	std	Z+4, r24	; 0x04
    a232:	86 ed       	ldi	r24, 0xD6	; 214
    a234:	9d e0       	ldi	r25, 0x0D	; 13
    a236:	97 83       	std	Z+7, r25	; 0x07
    a238:	86 83       	std	Z+6, r24	; 0x06
    a23a:	85 ee       	ldi	r24, 0xE5	; 229
    a23c:	99 e0       	ldi	r25, 0x09	; 9
    a23e:	91 87       	std	Z+9, r25	; 0x09
    a240:	80 87       	std	Z+8, r24	; 0x08
    a242:	82 e1       	ldi	r24, 0x12	; 18
    a244:	9a e0       	ldi	r25, 0x0A	; 10
    a246:	93 87       	std	Z+11, r25	; 0x0b
    a248:	82 87       	std	Z+10, r24	; 0x0a
    a24a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a24e:	8d b7       	in	r24, 0x3d	; 61
    a250:	9e b7       	in	r25, 0x3e	; 62
    a252:	0c 96       	adiw	r24, 0x0c	; 12
    a254:	0f b6       	in	r0, 0x3f	; 63
    a256:	f8 94       	cli
    a258:	9e bf       	out	0x3e, r25	; 62
    a25a:	0f be       	out	0x3f, r0	; 63
    a25c:	8d bf       	out	0x3d, r24	; 61
    a25e:	81 e0       	ldi	r24, 0x01	; 1
    a260:	60 e0       	ldi	r22, 0x00	; 0
    a262:	a8 01       	movw	r20, r16
    a264:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	UpdateCardID();
    a268:	0e 94 95 3c 	call	0x792a	; 0x792a <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    a26c:	ad b7       	in	r26, 0x3d	; 61
    a26e:	be b7       	in	r27, 0x3e	; 62
    a270:	18 97       	sbiw	r26, 0x08	; 8
    a272:	0f b6       	in	r0, 0x3f	; 63
    a274:	f8 94       	cli
    a276:	be bf       	out	0x3e, r27	; 62
    a278:	0f be       	out	0x3f, r0	; 63
    a27a:	ad bf       	out	0x3d, r26	; 61
    a27c:	ed b7       	in	r30, 0x3d	; 61
    a27e:	fe b7       	in	r31, 0x3e	; 62
    a280:	31 96       	adiw	r30, 0x01	; 1
    a282:	12 96       	adiw	r26, 0x02	; 2
    a284:	1c 93       	st	X, r17
    a286:	0e 93       	st	-X, r16
    a288:	11 97       	sbiw	r26, 0x01	; 1
    a28a:	8f ec       	ldi	r24, 0xCF	; 207
    a28c:	90 e2       	ldi	r25, 0x20	; 32
    a28e:	93 83       	std	Z+3, r25	; 0x03
    a290:	82 83       	std	Z+2, r24	; 0x02
    a292:	83 ec       	ldi	r24, 0xC3	; 195
    a294:	99 e0       	ldi	r25, 0x09	; 9
    a296:	95 83       	std	Z+5, r25	; 0x05
    a298:	84 83       	std	Z+4, r24	; 0x04
    a29a:	8c e8       	ldi	r24, 0x8C	; 140
    a29c:	9d e0       	ldi	r25, 0x0D	; 13
    a29e:	97 83       	std	Z+7, r25	; 0x07
    a2a0:	86 83       	std	Z+6, r24	; 0x06
    a2a2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a2a6:	8d b7       	in	r24, 0x3d	; 61
    a2a8:	9e b7       	in	r25, 0x3e	; 62
    a2aa:	08 96       	adiw	r24, 0x08	; 8
    a2ac:	0f b6       	in	r0, 0x3f	; 63
    a2ae:	f8 94       	cli
    a2b0:	9e bf       	out	0x3e, r25	; 62
    a2b2:	0f be       	out	0x3f, r0	; 63
    a2b4:	8d bf       	out	0x3d, r24	; 61
    a2b6:	81 e0       	ldi	r24, 0x01	; 1
    a2b8:	60 e0       	ldi	r22, 0x00	; 0
    a2ba:	a8 01       	movw	r20, r16
    a2bc:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    a2c0:	81 e0       	ldi	r24, 0x01	; 1
    a2c2:	61 e0       	ldi	r22, 0x01	; 1
    a2c4:	42 e0       	ldi	r20, 0x02	; 2
    a2c6:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    a2ca:	ec 96       	adiw	r28, 0x3c	; 60
    a2cc:	0f b6       	in	r0, 0x3f	; 63
    a2ce:	f8 94       	cli
    a2d0:	de bf       	out	0x3e, r29	; 62
    a2d2:	0f be       	out	0x3f, r0	; 63
    a2d4:	cd bf       	out	0x3d, r28	; 61
    a2d6:	cf 91       	pop	r28
    a2d8:	df 91       	pop	r29
    a2da:	1f 91       	pop	r17
    a2dc:	0f 91       	pop	r16
    a2de:	08 95       	ret

0000a2e0 <sendMessage24>:
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage24(){//Msg24: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a2e0:	0f 93       	push	r16
    a2e2:	1f 93       	push	r17
    a2e4:	df 93       	push	r29
    a2e6:	cf 93       	push	r28
    a2e8:	cd b7       	in	r28, 0x3d	; 61
    a2ea:	de b7       	in	r29, 0x3e	; 62
    a2ec:	ec 97       	sbiw	r28, 0x3c	; 60
    a2ee:	0f b6       	in	r0, 0x3f	; 63
    a2f0:	f8 94       	cli
    a2f2:	de bf       	out	0x3e, r29	; 62
    a2f4:	0f be       	out	0x3f, r0	; 63
    a2f6:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a2f8:	81 e0       	ldi	r24, 0x01	; 1
    a2fa:	61 e0       	ldi	r22, 0x01	; 1
    a2fc:	41 e0       	ldi	r20, 0x01	; 1
    a2fe:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a302:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a306:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a30a:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a30e:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s24"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a312:	8d b7       	in	r24, 0x3d	; 61
    a314:	9e b7       	in	r25, 0x3e	; 62
    a316:	0c 97       	sbiw	r24, 0x0c	; 12
    a318:	0f b6       	in	r0, 0x3f	; 63
    a31a:	f8 94       	cli
    a31c:	9e bf       	out	0x3e, r25	; 62
    a31e:	0f be       	out	0x3f, r0	; 63
    a320:	8d bf       	out	0x3d, r24	; 61
    a322:	ed b7       	in	r30, 0x3d	; 61
    a324:	fe b7       	in	r31, 0x3e	; 62
    a326:	31 96       	adiw	r30, 0x01	; 1
    a328:	8e 01       	movw	r16, r28
    a32a:	0f 5f       	subi	r16, 0xFF	; 255
    a32c:	1f 4f       	sbci	r17, 0xFF	; 255
    a32e:	ad b7       	in	r26, 0x3d	; 61
    a330:	be b7       	in	r27, 0x3e	; 62
    a332:	12 96       	adiw	r26, 0x02	; 2
    a334:	1c 93       	st	X, r17
    a336:	0e 93       	st	-X, r16
    a338:	11 97       	sbiw	r26, 0x01	; 1
    a33a:	84 ef       	ldi	r24, 0xF4	; 244
    a33c:	90 e2       	ldi	r25, 0x20	; 32
    a33e:	93 83       	std	Z+3, r25	; 0x03
    a340:	82 83       	std	Z+2, r24	; 0x02
    a342:	81 ef       	ldi	r24, 0xF1	; 241
    a344:	95 e0       	ldi	r25, 0x05	; 5
    a346:	95 83       	std	Z+5, r25	; 0x05
    a348:	84 83       	std	Z+4, r24	; 0x04
    a34a:	86 ed       	ldi	r24, 0xD6	; 214
    a34c:	9d e0       	ldi	r25, 0x0D	; 13
    a34e:	97 83       	std	Z+7, r25	; 0x07
    a350:	86 83       	std	Z+6, r24	; 0x06
    a352:	85 ee       	ldi	r24, 0xE5	; 229
    a354:	99 e0       	ldi	r25, 0x09	; 9
    a356:	91 87       	std	Z+9, r25	; 0x09
    a358:	80 87       	std	Z+8, r24	; 0x08
    a35a:	82 e1       	ldi	r24, 0x12	; 18
    a35c:	9a e0       	ldi	r25, 0x0A	; 10
    a35e:	93 87       	std	Z+11, r25	; 0x0b
    a360:	82 87       	std	Z+10, r24	; 0x0a
    a362:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a366:	8d b7       	in	r24, 0x3d	; 61
    a368:	9e b7       	in	r25, 0x3e	; 62
    a36a:	0c 96       	adiw	r24, 0x0c	; 12
    a36c:	0f b6       	in	r0, 0x3f	; 63
    a36e:	f8 94       	cli
    a370:	9e bf       	out	0x3e, r25	; 62
    a372:	0f be       	out	0x3f, r0	; 63
    a374:	8d bf       	out	0x3d, r24	; 61
    a376:	81 e0       	ldi	r24, 0x01	; 1
    a378:	60 e0       	ldi	r22, 0x00	; 0
    a37a:	a8 01       	movw	r20, r16
    a37c:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	UpdateCardID();
    a380:	0e 94 95 3c 	call	0x792a	; 0x792a <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    a384:	ad b7       	in	r26, 0x3d	; 61
    a386:	be b7       	in	r27, 0x3e	; 62
    a388:	18 97       	sbiw	r26, 0x08	; 8
    a38a:	0f b6       	in	r0, 0x3f	; 63
    a38c:	f8 94       	cli
    a38e:	be bf       	out	0x3e, r27	; 62
    a390:	0f be       	out	0x3f, r0	; 63
    a392:	ad bf       	out	0x3d, r26	; 61
    a394:	ed b7       	in	r30, 0x3d	; 61
    a396:	fe b7       	in	r31, 0x3e	; 62
    a398:	31 96       	adiw	r30, 0x01	; 1
    a39a:	12 96       	adiw	r26, 0x02	; 2
    a39c:	1c 93       	st	X, r17
    a39e:	0e 93       	st	-X, r16
    a3a0:	11 97       	sbiw	r26, 0x01	; 1
    a3a2:	87 ee       	ldi	r24, 0xE7	; 231
    a3a4:	90 e2       	ldi	r25, 0x20	; 32
    a3a6:	93 83       	std	Z+3, r25	; 0x03
    a3a8:	82 83       	std	Z+2, r24	; 0x02
    a3aa:	8c e8       	ldi	r24, 0x8C	; 140
    a3ac:	9d e0       	ldi	r25, 0x0D	; 13
    a3ae:	95 83       	std	Z+5, r25	; 0x05
    a3b0:	84 83       	std	Z+4, r24	; 0x04
    a3b2:	83 ec       	ldi	r24, 0xC3	; 195
    a3b4:	99 e0       	ldi	r25, 0x09	; 9
    a3b6:	97 83       	std	Z+7, r25	; 0x07
    a3b8:	86 83       	std	Z+6, r24	; 0x06
    a3ba:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a3be:	8d b7       	in	r24, 0x3d	; 61
    a3c0:	9e b7       	in	r25, 0x3e	; 62
    a3c2:	08 96       	adiw	r24, 0x08	; 8
    a3c4:	0f b6       	in	r0, 0x3f	; 63
    a3c6:	f8 94       	cli
    a3c8:	9e bf       	out	0x3e, r25	; 62
    a3ca:	0f be       	out	0x3f, r0	; 63
    a3cc:	8d bf       	out	0x3d, r24	; 61
    a3ce:	81 e0       	ldi	r24, 0x01	; 1
    a3d0:	60 e0       	ldi	r22, 0x00	; 0
    a3d2:	a8 01       	movw	r20, r16
    a3d4:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    a3d8:	81 e0       	ldi	r24, 0x01	; 1
    a3da:	61 e0       	ldi	r22, 0x01	; 1
    a3dc:	42 e0       	ldi	r20, 0x02	; 2
    a3de:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    a3e2:	ec 96       	adiw	r28, 0x3c	; 60
    a3e4:	0f b6       	in	r0, 0x3f	; 63
    a3e6:	f8 94       	cli
    a3e8:	de bf       	out	0x3e, r29	; 62
    a3ea:	0f be       	out	0x3f, r0	; 63
    a3ec:	cd bf       	out	0x3d, r28	; 61
    a3ee:	cf 91       	pop	r28
    a3f0:	df 91       	pop	r29
    a3f2:	1f 91       	pop	r17
    a3f4:	0f 91       	pop	r16
    a3f6:	08 95       	ret

0000a3f8 <sendMessage22>:
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage22(){//Msg22: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a3f8:	0f 93       	push	r16
    a3fa:	1f 93       	push	r17
    a3fc:	df 93       	push	r29
    a3fe:	cf 93       	push	r28
    a400:	cd b7       	in	r28, 0x3d	; 61
    a402:	de b7       	in	r29, 0x3e	; 62
    a404:	ec 97       	sbiw	r28, 0x3c	; 60
    a406:	0f b6       	in	r0, 0x3f	; 63
    a408:	f8 94       	cli
    a40a:	de bf       	out	0x3e, r29	; 62
    a40c:	0f be       	out	0x3f, r0	; 63
    a40e:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a410:	81 e0       	ldi	r24, 0x01	; 1
    a412:	61 e0       	ldi	r22, 0x01	; 1
    a414:	41 e0       	ldi	r20, 0x01	; 1
    a416:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a41a:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a41e:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a422:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a426:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s22"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a42a:	8d b7       	in	r24, 0x3d	; 61
    a42c:	9e b7       	in	r25, 0x3e	; 62
    a42e:	0c 97       	sbiw	r24, 0x0c	; 12
    a430:	0f b6       	in	r0, 0x3f	; 63
    a432:	f8 94       	cli
    a434:	9e bf       	out	0x3e, r25	; 62
    a436:	0f be       	out	0x3f, r0	; 63
    a438:	8d bf       	out	0x3d, r24	; 61
    a43a:	ed b7       	in	r30, 0x3d	; 61
    a43c:	fe b7       	in	r31, 0x3e	; 62
    a43e:	31 96       	adiw	r30, 0x01	; 1
    a440:	8e 01       	movw	r16, r28
    a442:	0f 5f       	subi	r16, 0xFF	; 255
    a444:	1f 4f       	sbci	r17, 0xFF	; 255
    a446:	ad b7       	in	r26, 0x3d	; 61
    a448:	be b7       	in	r27, 0x3e	; 62
    a44a:	12 96       	adiw	r26, 0x02	; 2
    a44c:	1c 93       	st	X, r17
    a44e:	0e 93       	st	-X, r16
    a450:	11 97       	sbiw	r26, 0x01	; 1
    a452:	8a e0       	ldi	r24, 0x0A	; 10
    a454:	91 e2       	ldi	r25, 0x21	; 33
    a456:	93 83       	std	Z+3, r25	; 0x03
    a458:	82 83       	std	Z+2, r24	; 0x02
    a45a:	81 ef       	ldi	r24, 0xF1	; 241
    a45c:	95 e0       	ldi	r25, 0x05	; 5
    a45e:	95 83       	std	Z+5, r25	; 0x05
    a460:	84 83       	std	Z+4, r24	; 0x04
    a462:	86 ed       	ldi	r24, 0xD6	; 214
    a464:	9d e0       	ldi	r25, 0x0D	; 13
    a466:	97 83       	std	Z+7, r25	; 0x07
    a468:	86 83       	std	Z+6, r24	; 0x06
    a46a:	85 ee       	ldi	r24, 0xE5	; 229
    a46c:	99 e0       	ldi	r25, 0x09	; 9
    a46e:	91 87       	std	Z+9, r25	; 0x09
    a470:	80 87       	std	Z+8, r24	; 0x08
    a472:	82 e1       	ldi	r24, 0x12	; 18
    a474:	9a e0       	ldi	r25, 0x0A	; 10
    a476:	93 87       	std	Z+11, r25	; 0x0b
    a478:	82 87       	std	Z+10, r24	; 0x0a
    a47a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a47e:	8d b7       	in	r24, 0x3d	; 61
    a480:	9e b7       	in	r25, 0x3e	; 62
    a482:	0c 96       	adiw	r24, 0x0c	; 12
    a484:	0f b6       	in	r0, 0x3f	; 63
    a486:	f8 94       	cli
    a488:	9e bf       	out	0x3e, r25	; 62
    a48a:	0f be       	out	0x3f, r0	; 63
    a48c:	8d bf       	out	0x3d, r24	; 61
    a48e:	81 e0       	ldi	r24, 0x01	; 1
    a490:	60 e0       	ldi	r22, 0x00	; 0
    a492:	a8 01       	movw	r20, r16
    a494:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	UpdateCardID();
    a498:	0e 94 95 3c 	call	0x792a	; 0x792a <UpdateCardID>
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    a49c:	00 d0       	rcall	.+0      	; 0xa49e <sendMessage22+0xa6>
    a49e:	00 d0       	rcall	.+0      	; 0xa4a0 <sendMessage22+0xa8>
    a4a0:	00 d0       	rcall	.+0      	; 0xa4a2 <sendMessage22+0xaa>
    a4a2:	ed b7       	in	r30, 0x3d	; 61
    a4a4:	fe b7       	in	r31, 0x3e	; 62
    a4a6:	31 96       	adiw	r30, 0x01	; 1
    a4a8:	ad b7       	in	r26, 0x3d	; 61
    a4aa:	be b7       	in	r27, 0x3e	; 62
    a4ac:	12 96       	adiw	r26, 0x02	; 2
    a4ae:	1c 93       	st	X, r17
    a4b0:	0e 93       	st	-X, r16
    a4b2:	11 97       	sbiw	r26, 0x01	; 1
    a4b4:	8f ef       	ldi	r24, 0xFF	; 255
    a4b6:	90 e2       	ldi	r25, 0x20	; 32
    a4b8:	93 83       	std	Z+3, r25	; 0x03
    a4ba:	82 83       	std	Z+2, r24	; 0x02
    a4bc:	8c e8       	ldi	r24, 0x8C	; 140
    a4be:	9d e0       	ldi	r25, 0x0D	; 13
    a4c0:	95 83       	std	Z+5, r25	; 0x05
    a4c2:	84 83       	std	Z+4, r24	; 0x04
    a4c4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a4c8:	8d b7       	in	r24, 0x3d	; 61
    a4ca:	9e b7       	in	r25, 0x3e	; 62
    a4cc:	06 96       	adiw	r24, 0x06	; 6
    a4ce:	0f b6       	in	r0, 0x3f	; 63
    a4d0:	f8 94       	cli
    a4d2:	9e bf       	out	0x3e, r25	; 62
    a4d4:	0f be       	out	0x3f, r0	; 63
    a4d6:	8d bf       	out	0x3d, r24	; 61
    a4d8:	81 e0       	ldi	r24, 0x01	; 1
    a4da:	60 e0       	ldi	r22, 0x00	; 0
    a4dc:	a8 01       	movw	r20, r16
    a4de:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    a4e2:	81 e0       	ldi	r24, 0x01	; 1
    a4e4:	61 e0       	ldi	r22, 0x01	; 1
    a4e6:	42 e0       	ldi	r20, 0x02	; 2
    a4e8:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    a4ec:	ec 96       	adiw	r28, 0x3c	; 60
    a4ee:	0f b6       	in	r0, 0x3f	; 63
    a4f0:	f8 94       	cli
    a4f2:	de bf       	out	0x3e, r29	; 62
    a4f4:	0f be       	out	0x3f, r0	; 63
    a4f6:	cd bf       	out	0x3d, r28	; 61
    a4f8:	cf 91       	pop	r28
    a4fa:	df 91       	pop	r29
    a4fc:	1f 91       	pop	r17
    a4fe:	0f 91       	pop	r16
    a500:	08 95       	ret

0000a502 <sendMessage10>:
     _uart_print(1, 0,strSend);
	 _uart(1, 1,0x02);
}

/*Subrutine Msg10*/
void sendMessage10(){//Msg10: <01>[0103192.168.016.070192.168.016.18010F968CFFB]<02>
    a502:	0f 93       	push	r16
    a504:	1f 93       	push	r17
    a506:	df 93       	push	r29
    a508:	cf 93       	push	r28
    a50a:	cd b7       	in	r28, 0x3d	; 61
    a50c:	de b7       	in	r29, 0x3e	; 62
    a50e:	ec 97       	sbiw	r28, 0x3c	; 60
    a510:	0f b6       	in	r0, 0x3f	; 63
    a512:	f8 94       	cli
    a514:	de bf       	out	0x3e, r29	; 62
    a516:	0f be       	out	0x3f, r0	; 63
    a518:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a51a:	81 e0       	ldi	r24, 0x01	; 1
    a51c:	61 e0       	ldi	r22, 0x01	; 1
    a51e:	41 e0       	ldi	r20, 0x01	; 1
    a520:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a524:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a528:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a52c:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a530:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a534:	8d b7       	in	r24, 0x3d	; 61
    a536:	9e b7       	in	r25, 0x3e	; 62
    a538:	0c 97       	sbiw	r24, 0x0c	; 12
    a53a:	0f b6       	in	r0, 0x3f	; 63
    a53c:	f8 94       	cli
    a53e:	9e bf       	out	0x3e, r25	; 62
    a540:	0f be       	out	0x3f, r0	; 63
    a542:	8d bf       	out	0x3d, r24	; 61
    a544:	ed b7       	in	r30, 0x3d	; 61
    a546:	fe b7       	in	r31, 0x3e	; 62
    a548:	31 96       	adiw	r30, 0x01	; 1
    a54a:	8e 01       	movw	r16, r28
    a54c:	0f 5f       	subi	r16, 0xFF	; 255
    a54e:	1f 4f       	sbci	r17, 0xFF	; 255
    a550:	ad b7       	in	r26, 0x3d	; 61
    a552:	be b7       	in	r27, 0x3e	; 62
    a554:	12 96       	adiw	r26, 0x02	; 2
    a556:	1c 93       	st	X, r17
    a558:	0e 93       	st	-X, r16
    a55a:	11 97       	sbiw	r26, 0x01	; 1
    a55c:	85 e1       	ldi	r24, 0x15	; 21
    a55e:	91 e2       	ldi	r25, 0x21	; 33
    a560:	93 83       	std	Z+3, r25	; 0x03
    a562:	82 83       	std	Z+2, r24	; 0x02
    a564:	81 ef       	ldi	r24, 0xF1	; 241
    a566:	95 e0       	ldi	r25, 0x05	; 5
    a568:	95 83       	std	Z+5, r25	; 0x05
    a56a:	84 83       	std	Z+4, r24	; 0x04
    a56c:	86 ed       	ldi	r24, 0xD6	; 214
    a56e:	9d e0       	ldi	r25, 0x0D	; 13
    a570:	97 83       	std	Z+7, r25	; 0x07
    a572:	86 83       	std	Z+6, r24	; 0x06
    a574:	85 ee       	ldi	r24, 0xE5	; 229
    a576:	99 e0       	ldi	r25, 0x09	; 9
    a578:	91 87       	std	Z+9, r25	; 0x09
    a57a:	80 87       	std	Z+8, r24	; 0x08
    a57c:	82 e1       	ldi	r24, 0x12	; 18
    a57e:	9a e0       	ldi	r25, 0x0A	; 10
    a580:	93 87       	std	Z+11, r25	; 0x0b
    a582:	82 87       	std	Z+10, r24	; 0x0a
    a584:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
    a588:	8d b7       	in	r24, 0x3d	; 61
    a58a:	9e b7       	in	r25, 0x3e	; 62
    a58c:	0c 96       	adiw	r24, 0x0c	; 12
    a58e:	0f b6       	in	r0, 0x3f	; 63
    a590:	f8 94       	cli
    a592:	9e bf       	out	0x3e, r25	; 62
    a594:	0f be       	out	0x3f, r0	; 63
    a596:	8d bf       	out	0x3d, r24	; 61
    a598:	81 e0       	ldi	r24, 0x01	; 1
    a59a:	60 e0       	ldi	r22, 0x00	; 0
    a59c:	a8 01       	movw	r20, r16
    a59e:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	_uart(1, 1,0x02);
    a5a2:	81 e0       	ldi	r24, 0x01	; 1
    a5a4:	61 e0       	ldi	r22, 0x01	; 1
    a5a6:	42 e0       	ldi	r20, 0x02	; 2
    a5a8:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    a5ac:	ec 96       	adiw	r28, 0x3c	; 60
    a5ae:	0f b6       	in	r0, 0x3f	; 63
    a5b0:	f8 94       	cli
    a5b2:	de bf       	out	0x3e, r29	; 62
    a5b4:	0f be       	out	0x3f, r0	; 63
    a5b6:	cd bf       	out	0x3d, r28	; 61
    a5b8:	cf 91       	pop	r28
    a5ba:	df 91       	pop	r29
    a5bc:	1f 91       	pop	r17
    a5be:	0f 91       	pop	r16
    a5c0:	08 95       	ret

0000a5c2 <sendMessage04>:
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}

/*Subrutine Msg04*/
void sendMessage04(){   //      <STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode][ReceiptNo][Value][Checksum][ETX]
    a5c2:	0f 93       	push	r16
    a5c4:	1f 93       	push	r17
    a5c6:	df 93       	push	r29
    a5c8:	cf 93       	push	r28
    a5ca:	cd b7       	in	r28, 0x3d	; 61
    a5cc:	de b7       	in	r29, 0x3e	; 62
    a5ce:	ec 97       	sbiw	r28, 0x3c	; 60
    a5d0:	0f b6       	in	r0, 0x3f	; 63
    a5d2:	f8 94       	cli
    a5d4:	de bf       	out	0x3e, r29	; 62
    a5d6:	0f be       	out	0x3f, r0	; 63
    a5d8:	cd bf       	out	0x3d, r28	; 61
                        //Msg04: <01>[01][03][192.168.000.101][192.168.000.001][04][000001]0F968CFFB]<02>
	 char strSend[60];
	 _uart(1, 1,0x01);
    a5da:	81 e0       	ldi	r24, 0x01	; 1
    a5dc:	61 e0       	ldi	r22, 0x01	; 1
    a5de:	41 e0       	ldi	r20, 0x01	; 1
    a5e0:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	 UpdateIFT_ID(); //ReadIFT_ID
    a5e4:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	 UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a5e8:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	 UpdateClientIP();//ReadSourceIP
    a5ec:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	 UpdateServerIP();//ReadDestIP
    a5f0:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
    a5f4:	8d b7       	in	r24, 0x3d	; 61
    a5f6:	9e b7       	in	r25, 0x3e	; 62
    a5f8:	0e 97       	sbiw	r24, 0x0e	; 14
    a5fa:	0f b6       	in	r0, 0x3f	; 63
    a5fc:	f8 94       	cli
    a5fe:	9e bf       	out	0x3e, r25	; 62
    a600:	0f be       	out	0x3f, r0	; 63
    a602:	8d bf       	out	0x3d, r24	; 61
    a604:	ed b7       	in	r30, 0x3d	; 61
    a606:	fe b7       	in	r31, 0x3e	; 62
    a608:	31 96       	adiw	r30, 0x01	; 1
    a60a:	8e 01       	movw	r16, r28
    a60c:	0f 5f       	subi	r16, 0xFF	; 255
    a60e:	1f 4f       	sbci	r17, 0xFF	; 255
    a610:	ad b7       	in	r26, 0x3d	; 61
    a612:	be b7       	in	r27, 0x3e	; 62
    a614:	12 96       	adiw	r26, 0x02	; 2
    a616:	1c 93       	st	X, r17
    a618:	0e 93       	st	-X, r16
    a61a:	11 97       	sbiw	r26, 0x01	; 1
    a61c:	88 e2       	ldi	r24, 0x28	; 40
    a61e:	91 e2       	ldi	r25, 0x21	; 33
    a620:	93 83       	std	Z+3, r25	; 0x03
    a622:	82 83       	std	Z+2, r24	; 0x02
    a624:	81 ef       	ldi	r24, 0xF1	; 241
    a626:	95 e0       	ldi	r25, 0x05	; 5
    a628:	95 83       	std	Z+5, r25	; 0x05
    a62a:	84 83       	std	Z+4, r24	; 0x04
    a62c:	86 ed       	ldi	r24, 0xD6	; 214
    a62e:	9d e0       	ldi	r25, 0x0D	; 13
    a630:	97 83       	std	Z+7, r25	; 0x07
    a632:	86 83       	std	Z+6, r24	; 0x06
    a634:	85 ee       	ldi	r24, 0xE5	; 229
    a636:	99 e0       	ldi	r25, 0x09	; 9
    a638:	91 87       	std	Z+9, r25	; 0x09
    a63a:	80 87       	std	Z+8, r24	; 0x08
    a63c:	82 e1       	ldi	r24, 0x12	; 18
    a63e:	9a e0       	ldi	r25, 0x0A	; 10
    a640:	93 87       	std	Z+11, r25	; 0x0b
    a642:	82 87       	std	Z+10, r24	; 0x0a
    a644:	8d e8       	ldi	r24, 0x8D	; 141
    a646:	9e e0       	ldi	r25, 0x0E	; 14
    a648:	95 87       	std	Z+13, r25	; 0x0d
    a64a:	84 87       	std	Z+12, r24	; 0x0c
    a64c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
     _uart_print(1, 0,strSend);
    a650:	8d b7       	in	r24, 0x3d	; 61
    a652:	9e b7       	in	r25, 0x3e	; 62
    a654:	0e 96       	adiw	r24, 0x0e	; 14
    a656:	0f b6       	in	r0, 0x3f	; 63
    a658:	f8 94       	cli
    a65a:	9e bf       	out	0x3e, r25	; 62
    a65c:	0f be       	out	0x3f, r0	; 63
    a65e:	8d bf       	out	0x3d, r24	; 61
    a660:	81 e0       	ldi	r24, 0x01	; 1
    a662:	60 e0       	ldi	r22, 0x00	; 0
    a664:	a8 01       	movw	r20, r16
    a666:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	 _uart(1, 1,0x02);
    a66a:	81 e0       	ldi	r24, 0x01	; 1
    a66c:	61 e0       	ldi	r22, 0x01	; 1
    a66e:	42 e0       	ldi	r20, 0x02	; 2
    a670:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
    a674:	ec 96       	adiw	r28, 0x3c	; 60
    a676:	0f b6       	in	r0, 0x3f	; 63
    a678:	f8 94       	cli
    a67a:	de bf       	out	0x3e, r29	; 62
    a67c:	0f be       	out	0x3f, r0	; 63
    a67e:	cd bf       	out	0x3d, r28	; 61
    a680:	cf 91       	pop	r28
    a682:	df 91       	pop	r29
    a684:	1f 91       	pop	r17
    a686:	0f 91       	pop	r16
    a688:	08 95       	ret

0000a68a <FreePrinting>:
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
    a68a:	0f 93       	push	r16
    a68c:	1f 93       	push	r17
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static char strHeader[41];
static unsigned int iSend=0,LSend=0,iLoop=0;

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
    a68e:	20 91 d5 01 	lds	r18, 0x01D5
    a692:	21 30       	cpi	r18, 0x01	; 1
    a694:	31 f4       	brne	.+12     	; 0xa6a2 <FreePrinting+0x18>
    a696:	80 91 3a 01 	lds	r24, 0x013A
    a69a:	81 30       	cpi	r24, 0x01	; 1
    a69c:	11 f0       	breq	.+4      	; 0xa6a2 <FreePrinting+0x18>
	     stFreePrinting=fpInit;
    a69e:	20 93 3a 01 	sts	0x013A, r18
	 }

	 switch (stFreePrinting){
    a6a2:	80 91 3a 01 	lds	r24, 0x013A
    a6a6:	90 e0       	ldi	r25, 0x00	; 0
    a6a8:	fc 01       	movw	r30, r24
    a6aa:	31 97       	sbiw	r30, 0x01	; 1
    a6ac:	e5 31       	cpi	r30, 0x15	; 21
    a6ae:	f1 05       	cpc	r31, r1
    a6b0:	08 f0       	brcs	.+2      	; 0xa6b4 <FreePrinting+0x2a>
    a6b2:	7e c2       	rjmp	.+1276   	; 0xabb0 <FreePrinting+0x526>
    a6b4:	ec 59       	subi	r30, 0x9C	; 156
    a6b6:	ff 4f       	sbci	r31, 0xFF	; 255
    a6b8:	ee 0f       	add	r30, r30
    a6ba:	ff 1f       	adc	r31, r31
    a6bc:	05 90       	lpm	r0, Z+
    a6be:	f4 91       	lpm	r31, Z+
    a6c0:	e0 2d       	mov	r30, r0
    a6c2:	09 94       	ijmp
     case fpInit:
	      //_uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
    a6c4:	21 30       	cpi	r18, 0x01	; 1
    a6c6:	09 f0       	breq	.+2      	; 0xa6ca <FreePrinting+0x40>
    a6c8:	73 c2       	rjmp	.+1254   	; 0xabb0 <FreePrinting+0x526>
		      IsFreePrinting=False;
    a6ca:	10 92 d5 01 	sts	0x01D5, r1
			  IsBusyFreePrinting=True;
    a6ce:	20 93 df 01 	sts	0x01DF, r18
			  IsBusyPrint=False;
    a6d2:	10 92 de 01 	sts	0x01DE, r1
			  iPrinted=0,iFooter=0;
    a6d6:	10 92 a3 02 	sts	0x02A3, r1
    a6da:	10 92 a1 02 	sts	0x02A1, r1

			  PrintCopy=(cmdPrint&0x0F);
    a6de:	80 91 e1 01 	lds	r24, 0x01E1
    a6e2:	8f 70       	andi	r24, 0x0F	; 15
    a6e4:	80 93 a0 02 	sts	0x02A0, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
    a6e8:	82 e0       	ldi	r24, 0x02	; 2
    a6ea:	80 93 3a 01 	sts	0x013A, r24
			  InitPrinter();
    a6ee:	0e 94 ca 4b 	call	0x9794	; 0x9794 <InitPrinter>
    a6f2:	5e c2       	rjmp	.+1212   	; 0xabb0 <FreePrinting+0x526>
			  }
	      break;
     case fpInitHeader:
	      //_uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
    a6f4:	10 92 a2 02 	sts	0x02A2, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
    a6f8:	80 91 e1 01 	lds	r24, 0x01E1
    a6fc:	88 1f       	adc	r24, r24
    a6fe:	88 27       	eor	r24, r24
    a700:	88 1f       	adc	r24, r24
    a702:	90 e0       	ldi	r25, 0x00	; 0
    a704:	81 30       	cpi	r24, 0x01	; 1
    a706:	91 05       	cpc	r25, r1
    a708:	21 f1       	breq	.+72     	; 0xa752 <FreePrinting+0xc8>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
    a70a:	89 2b       	or	r24, r25
    a70c:	09 f0       	breq	.+2      	; 0xa710 <FreePrinting+0x86>
    a70e:	50 c2       	rjmp	.+1184   	; 0xabb0 <FreePrinting+0x526>
    a710:	85 e0       	ldi	r24, 0x05	; 5
    a712:	80 93 3a 01 	sts	0x013A, r24
    a716:	4c c2       	rjmp	.+1176   	; 0xabb0 <FreePrinting+0x526>
    a718:	60 91 a2 02 	lds	r22, 0x02A2
    a71c:	89 e2       	ldi	r24, 0x29	; 41
    a71e:	68 9f       	mul	r22, r24
    a720:	b0 01       	movw	r22, r0
    a722:	11 24       	eor	r1, r1
    a724:	69 5a       	subi	r22, 0xA9	; 169
    a726:	7d 4f       	sbci	r23, 0xFD	; 253
    a728:	84 e7       	ldi	r24, 0x74	; 116
    a72a:	92 e0       	ldi	r25, 0x02	; 2
    a72c:	48 e2       	ldi	r20, 0x28	; 40
    a72e:	50 e0       	ldi	r21, 0x00	; 0
    a730:	27 e9       	ldi	r18, 0x97	; 151
    a732:	32 e1       	ldi	r19, 0x12	; 18
    a734:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	      break;
     case fpLoadHeader:
	      //_uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
    a738:	00 91 a2 02 	lds	r16, 0x02A2
    a73c:	0f 5f       	subi	r16, 0xFF	; 255
    a73e:	00 93 a2 02 	sts	0x02A2, r16
		  if (iHeader<6){
    a742:	06 30       	cpi	r16, 0x06	; 6
    a744:	28 f7       	brcc	.-54     	; 0xa710 <FreePrinting+0x86>
		      if (SpaceOnly(strHeader)==True){
    a746:	84 e7       	ldi	r24, 0x74	; 116
    a748:	92 e0       	ldi	r25, 0x02	; 2
    a74a:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    a74e:	81 30       	cpi	r24, 0x01	; 1
    a750:	11 f4       	brne	.+4      	; 0xa756 <FreePrinting+0xcc>
			      stFreePrinting=fpLoadHeader;
    a752:	83 e0       	ldi	r24, 0x03	; 3
    a754:	de cf       	rjmp	.-68     	; 0xa712 <FreePrinting+0x88>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
    a756:	84 e0       	ldi	r24, 0x04	; 4
    a758:	80 93 3a 01 	sts	0x013A, r24
			      iSend=0;
    a75c:	10 92 73 02 	sts	0x0273, r1
    a760:	10 92 72 02 	sts	0x0272, r1
				  iLoop=0;
    a764:	10 92 6f 02 	sts	0x026F, r1
    a768:	10 92 6e 02 	sts	0x026E, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    a76c:	01 30       	cpi	r16, 0x01	; 1
    a76e:	19 f4       	brne	.+6      	; 0xa776 <FreePrinting+0xec>
    a770:	0e 94 4c 4c 	call	0x9898	; 0x9898 <PrintDoubleHeight>
    a774:	1d c2       	rjmp	.+1082   	; 0xabb0 <FreePrinting+0x526>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    a776:	02 30       	cpi	r16, 0x02	; 2
    a778:	09 f0       	breq	.+2      	; 0xa77c <FreePrinting+0xf2>
    a77a:	1a c2       	rjmp	.+1076   	; 0xabb0 <FreePrinting+0x526>
    a77c:	0e 94 32 4c 	call	0x9864	; 0x9864 <PrintNormalHeight>
    a780:	17 c2       	rjmp	.+1070   	; 0xabb0 <FreePrinting+0x526>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //_uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
    a782:	80 91 72 02 	lds	r24, 0x0272
    a786:	90 91 73 02 	lds	r25, 0x0273
    a78a:	88 97       	sbiw	r24, 0x28	; 40
    a78c:	78 f4       	brcc	.+30     	; 0xa7ac <FreePrinting+0x122>
		      iLoop++;
    a78e:	80 91 6e 02 	lds	r24, 0x026E
    a792:	90 91 6f 02 	lds	r25, 0x026F
    a796:	01 96       	adiw	r24, 0x01	; 1
    a798:	90 93 6f 02 	sts	0x026F, r25
    a79c:	80 93 6e 02 	sts	0x026E, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
    a7a0:	10 92 e3 01 	sts	0x01E3, r1
    a7a4:	10 92 e2 01 	sts	0x01E2, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
    a7a8:	82 e1       	ldi	r24, 0x12	; 18
    a7aa:	b3 cf       	rjmp	.-154    	; 0xa712 <FreePrinting+0x88>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
    a7ac:	83 e0       	ldi	r24, 0x03	; 3
    a7ae:	57 c1       	rjmp	.+686    	; 0xaa5e <FreePrinting+0x3d4>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    a7b0:	80 91 de 01 	lds	r24, 0x01DE
    a7b4:	88 23       	and	r24, r24
    a7b6:	09 f0       	breq	.+2      	; 0xa7ba <FreePrinting+0x130>
    a7b8:	71 c1       	rjmp	.+738    	; 0xaa9c <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a7ba:	e0 91 72 02 	lds	r30, 0x0272
    a7be:	f0 91 73 02 	lds	r31, 0x0273
    a7c2:	ec 58       	subi	r30, 0x8C	; 140
    a7c4:	fd 4f       	sbci	r31, 0xFD	; 253
    a7c6:	61 e0       	ldi	r22, 0x01	; 1
    a7c8:	40 81       	ld	r20, Z
    a7ca:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		      iSend++;
    a7ce:	80 91 72 02 	lds	r24, 0x0272
    a7d2:	90 91 73 02 	lds	r25, 0x0273
    a7d6:	01 96       	adiw	r24, 0x01	; 1
    a7d8:	90 93 73 02 	sts	0x0273, r25
    a7dc:	80 93 72 02 	sts	0x0272, r24
		      stFreePrinting=fpPrintHeader;
    a7e0:	84 e0       	ldi	r24, 0x04	; 4
    a7e2:	5a c1       	rjmp	.+692    	; 0xaa98 <FreePrinting+0x40e>
			  }
	      break;

     case fpInitMessage:
	      //_uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
    a7e4:	10 92 73 02 	sts	0x0273, r1
    a7e8:	10 92 72 02 	sts	0x0272, r1
    a7ec:	10 92 6f 02 	sts	0x026F, r1
    a7f0:	10 92 6e 02 	sts	0x026E, r1
          stFreePrinting=fpPrintMessage; 
    a7f4:	08 e0       	ldi	r16, 0x08	; 8
    a7f6:	00 93 3a 01 	sts	0x013A, r16
		  CarriegeReturn();
    a7fa:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
    a7fe:	80 91 a3 02 	lds	r24, 0x02A3
    a802:	88 23       	and	r24, r24
    a804:	11 f0       	breq	.+4      	; 0xa80a <FreePrinting+0x180>
    a806:	86 e0       	ldi	r24, 0x06	; 6
    a808:	84 cf       	rjmp	.-248    	; 0xa712 <FreePrinting+0x88>
		  else stFreePrinting=fpPrintMessage; 
    a80a:	00 93 3a 01 	sts	0x013A, r16
    a80e:	d0 c1       	rjmp	.+928    	; 0xabb0 <FreePrinting+0x526>
	      break;
     case fpInitDuplicate:
	      //_uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strHeader,PSTR("             DUPLICATE COPY        "));
    a810:	80 91 a3 02 	lds	r24, 0x02A3
    a814:	24 e7       	ldi	r18, 0x74	; 116
    a816:	32 e0       	ldi	r19, 0x02	; 2
    a818:	88 23       	and	r24, r24
    a81a:	49 f0       	breq	.+18     	; 0xa82e <FreePrinting+0x1a4>
    a81c:	00 d0       	rcall	.+0      	; 0xa81e <FreePrinting+0x194>
    a81e:	00 d0       	rcall	.+0      	; 0xa820 <FreePrinting+0x196>
    a820:	ed b7       	in	r30, 0x3d	; 61
    a822:	fe b7       	in	r31, 0x3e	; 62
    a824:	32 83       	std	Z+2, r19	; 0x02
    a826:	21 83       	std	Z+1, r18	; 0x01
    a828:	8a e9       	ldi	r24, 0x9A	; 154
    a82a:	96 e0       	ldi	r25, 0x06	; 6
    a82c:	08 c0       	rjmp	.+16     	; 0xa83e <FreePrinting+0x1b4>
          else           sprintf_P(strHeader,PSTR("                                   "));
    a82e:	00 d0       	rcall	.+0      	; 0xa830 <FreePrinting+0x1a6>
    a830:	00 d0       	rcall	.+0      	; 0xa832 <FreePrinting+0x1a8>
    a832:	ed b7       	in	r30, 0x3d	; 61
    a834:	fe b7       	in	r31, 0x3e	; 62
    a836:	32 83       	std	Z+2, r19	; 0x02
    a838:	21 83       	std	Z+1, r18	; 0x01
    a83a:	86 e7       	ldi	r24, 0x76	; 118
    a83c:	96 e0       	ldi	r25, 0x06	; 6
    a83e:	94 83       	std	Z+4, r25	; 0x04
    a840:	83 83       	std	Z+3, r24	; 0x03
    a842:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    a846:	0f 90       	pop	r0
    a848:	0f 90       	pop	r0
    a84a:	0f 90       	pop	r0
    a84c:	0f 90       	pop	r0
		  iSend=0;
    a84e:	10 92 73 02 	sts	0x0273, r1
    a852:	10 92 72 02 	sts	0x0272, r1
		  iLoop=0;
    a856:	10 92 6f 02 	sts	0x026F, r1
    a85a:	10 92 6e 02 	sts	0x026E, r1
		  LSend=strlen(strHeader);
    a85e:	e4 e7       	ldi	r30, 0x74	; 116
    a860:	f2 e0       	ldi	r31, 0x02	; 2
    a862:	01 90       	ld	r0, Z+
    a864:	00 20       	and	r0, r0
    a866:	e9 f7       	brne	.-6      	; 0xa862 <FreePrinting+0x1d8>
    a868:	31 97       	sbiw	r30, 0x01	; 1
    a86a:	e4 57       	subi	r30, 0x74	; 116
    a86c:	f2 40       	sbci	r31, 0x02	; 2
    a86e:	f0 93 71 02 	sts	0x0271, r31
    a872:	e0 93 70 02 	sts	0x0270, r30
          stFreePrinting=fpPrintDuplicate; 
    a876:	87 e0       	ldi	r24, 0x07	; 7
    a878:	4c cf       	rjmp	.-360    	; 0xa712 <FreePrinting+0x88>
	      break;
     case fpPrintDuplicate:
	      //_uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
    a87a:	20 91 72 02 	lds	r18, 0x0272
    a87e:	30 91 73 02 	lds	r19, 0x0273
    a882:	80 91 70 02 	lds	r24, 0x0270
    a886:	90 91 71 02 	lds	r25, 0x0271
    a88a:	28 17       	cp	r18, r24
    a88c:	39 07       	cpc	r19, r25
    a88e:	78 f4       	brcc	.+30     	; 0xa8ae <FreePrinting+0x224>
		      iLoop++;
    a890:	80 91 6e 02 	lds	r24, 0x026E
    a894:	90 91 6f 02 	lds	r25, 0x026F
    a898:	01 96       	adiw	r24, 0x01	; 1
    a89a:	90 93 6f 02 	sts	0x026F, r25
    a89e:	80 93 6e 02 	sts	0x026E, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
    a8a2:	10 92 e3 01 	sts	0x01E3, r1
    a8a6:	10 92 e2 01 	sts	0x01E2, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
    a8aa:	85 e1       	ldi	r24, 0x15	; 21
    a8ac:	32 cf       	rjmp	.-412    	; 0xa712 <FreePrinting+0x88>
				 }
			  }
          else {
		     iSend=0;
    a8ae:	10 92 73 02 	sts	0x0273, r1
    a8b2:	10 92 72 02 	sts	0x0272, r1
		     stFreePrinting=fpPrintMessage;
    a8b6:	88 e0       	ldi	r24, 0x08	; 8
    a8b8:	d2 c0       	rjmp	.+420    	; 0xaa5e <FreePrinting+0x3d4>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    a8ba:	80 91 de 01 	lds	r24, 0x01DE
    a8be:	88 23       	and	r24, r24
    a8c0:	09 f0       	breq	.+2      	; 0xa8c4 <FreePrinting+0x23a>
    a8c2:	ec c0       	rjmp	.+472    	; 0xaa9c <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a8c4:	e0 91 72 02 	lds	r30, 0x0272
    a8c8:	f0 91 73 02 	lds	r31, 0x0273
    a8cc:	ec 58       	subi	r30, 0x8C	; 140
    a8ce:	fd 4f       	sbci	r31, 0xFD	; 253
    a8d0:	61 e0       	ldi	r22, 0x01	; 1
    a8d2:	40 81       	ld	r20, Z
    a8d4:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		      iSend++;
    a8d8:	80 91 72 02 	lds	r24, 0x0272
    a8dc:	90 91 73 02 	lds	r25, 0x0273
    a8e0:	01 96       	adiw	r24, 0x01	; 1
    a8e2:	90 93 73 02 	sts	0x0273, r25
    a8e6:	80 93 72 02 	sts	0x0272, r24
		      stFreePrinting=fpPrintDuplicate;
    a8ea:	87 e0       	ldi	r24, 0x07	; 7
    a8ec:	d5 c0       	rjmp	.+426    	; 0xaa98 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
    a8ee:	20 91 72 02 	lds	r18, 0x0272
    a8f2:	30 91 73 02 	lds	r19, 0x0273
    a8f6:	80 91 b5 01 	lds	r24, 0x01B5
    a8fa:	90 91 b6 01 	lds	r25, 0x01B6
    a8fe:	28 17       	cp	r18, r24
    a900:	39 07       	cpc	r19, r25
    a902:	78 f4       	brcc	.+30     	; 0xa922 <FreePrinting+0x298>
		      iLoop++;
    a904:	80 91 6e 02 	lds	r24, 0x026E
    a908:	90 91 6f 02 	lds	r25, 0x026F
    a90c:	01 96       	adiw	r24, 0x01	; 1
    a90e:	90 93 6f 02 	sts	0x026F, r25
    a912:	80 93 6e 02 	sts	0x026E, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
    a916:	10 92 e3 01 	sts	0x01E3, r1
    a91a:	10 92 e2 01 	sts	0x01E2, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
    a91e:	83 e1       	ldi	r24, 0x13	; 19
    a920:	f8 ce       	rjmp	.-528    	; 0xa712 <FreePrinting+0x88>
				 }
			  }
          else stFreePrinting=fpInitFooter;
    a922:	8b e0       	ldi	r24, 0x0B	; 11
    a924:	f6 ce       	rjmp	.-532    	; 0xa712 <FreePrinting+0x88>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    a926:	80 91 de 01 	lds	r24, 0x01DE
    a92a:	88 23       	and	r24, r24
    a92c:	09 f0       	breq	.+2      	; 0xa930 <FreePrinting+0x2a6>
    a92e:	b6 c0       	rjmp	.+364    	; 0xaa9c <FreePrinting+0x412>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
    a930:	e0 91 72 02 	lds	r30, 0x0272
    a934:	f0 91 73 02 	lds	r31, 0x0273
    a938:	ea 50       	subi	r30, 0x0A	; 10
    a93a:	fa 4f       	sbci	r31, 0xFA	; 250
    a93c:	80 81       	ld	r24, Z
    a93e:	61 81       	ldd	r22, Z+1	; 0x01
    a940:	0e 94 a7 4b 	call	0x974e	; 0x974e <SendPrint>
			     // _uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
    a944:	e0 91 72 02 	lds	r30, 0x0272
    a948:	f0 91 73 02 	lds	r31, 0x0273
    a94c:	ea 50       	subi	r30, 0x0A	; 10
    a94e:	fa 4f       	sbci	r31, 0xFA	; 250
    a950:	80 81       	ld	r24, Z
    a952:	8d 30       	cpi	r24, 0x0D	; 13
    a954:	19 f0       	breq	.+6      	; 0xa95c <FreePrinting+0x2d2>
    a956:	81 81       	ldd	r24, Z+1	; 0x01
    a958:	8a 30       	cpi	r24, 0x0A	; 10
    a95a:	11 f4       	brne	.+4      	; 0xa960 <FreePrinting+0x2d6>
			     CarriegeReturn();
    a95c:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
             iSend++;
    a960:	80 91 72 02 	lds	r24, 0x0272
    a964:	90 91 73 02 	lds	r25, 0x0273
    a968:	01 96       	adiw	r24, 0x01	; 1
    a96a:	90 93 73 02 	sts	0x0273, r25
    a96e:	80 93 72 02 	sts	0x0272, r24
		     stFreePrinting=fpPrintMessage;
    a972:	88 e0       	ldi	r24, 0x08	; 8
    a974:	91 c0       	rjmp	.+290    	; 0xaa98 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
    a976:	10 92 6f 02 	sts	0x026F, r1
    a97a:	10 92 6e 02 	sts	0x026E, r1
		  iMargin=0;
    a97e:	10 92 9f 02 	sts	0x029F, r1
		  stFreePrinting=fpPrintMargin;
    a982:	8a e0       	ldi	r24, 0x0A	; 10
    a984:	c6 ce       	rjmp	.-628    	; 0xa712 <FreePrinting+0x88>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
    a986:	80 91 9f 02 	lds	r24, 0x029F
    a98a:	85 30       	cpi	r24, 0x05	; 5
    a98c:	90 f4       	brcc	.+36     	; 0xa9b2 <FreePrinting+0x328>
		      iMargin++;
    a98e:	8f 5f       	subi	r24, 0xFF	; 255
    a990:	80 93 9f 02 	sts	0x029F, r24
		      iLoop++;
    a994:	80 91 6e 02 	lds	r24, 0x026E
    a998:	90 91 6f 02 	lds	r25, 0x026F
    a99c:	01 96       	adiw	r24, 0x01	; 1
    a99e:	90 93 6f 02 	sts	0x026F, r25
    a9a2:	80 93 6e 02 	sts	0x026E, r24
	          if ((iLoop%PRINT_DELAY)==0)_uart(_COM_PRINTER,1,' ');
    a9a6:	80 e0       	ldi	r24, 0x00	; 0
    a9a8:	61 e0       	ldi	r22, 0x01	; 1
    a9aa:	40 e2       	ldi	r20, 0x20	; 32
    a9ac:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
    a9b0:	ff c0       	rjmp	.+510    	; 0xabb0 <FreePrinting+0x526>
			 }
          else stFreePrinting=fpPrintMessage;
    a9b2:	88 e0       	ldi	r24, 0x08	; 8
    a9b4:	ae ce       	rjmp	.-676    	; 0xa712 <FreePrinting+0x88>
	      break;
     case fpInitFooter:
	      //_uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
    a9b6:	80 91 e1 01 	lds	r24, 0x01E1
    a9ba:	86 ff       	sbrs	r24, 6
    a9bc:	06 c0       	rjmp	.+12     	; 0xa9ca <FreePrinting+0x340>
		      stFreePrinting=fpLoadFooter;
    a9be:	8c e0       	ldi	r24, 0x0C	; 12
    a9c0:	80 93 3a 01 	sts	0x013A, r24
			  iFooter=0;
    a9c4:	10 92 a1 02 	sts	0x02A1, r1
    a9c8:	f3 c0       	rjmp	.+486    	; 0xabb0 <FreePrinting+0x526>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
    a9ca:	80 e1       	ldi	r24, 0x10	; 16
    a9cc:	a2 ce       	rjmp	.-700    	; 0xa712 <FreePrinting+0x88>
    a9ce:	60 91 a1 02 	lds	r22, 0x02A1
    a9d2:	89 e2       	ldi	r24, 0x29	; 41
    a9d4:	68 9f       	mul	r22, r24
    a9d6:	b0 01       	movw	r22, r0
    a9d8:	11 24       	eor	r1, r1
    a9da:	63 5b       	subi	r22, 0xB3	; 179
    a9dc:	7c 4f       	sbci	r23, 0xFC	; 252
    a9de:	84 e7       	ldi	r24, 0x74	; 116
    a9e0:	92 e0       	ldi	r25, 0x02	; 2
    a9e2:	48 e2       	ldi	r20, 0x28	; 40
    a9e4:	50 e0       	ldi	r21, 0x00	; 0
    a9e6:	27 e9       	ldi	r18, 0x97	; 151
    a9e8:	32 e1       	ldi	r19, 0x12	; 18
    a9ea:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //_uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    a9ee:	80 91 a1 02 	lds	r24, 0x02A1
    a9f2:	8f 5f       	subi	r24, 0xFF	; 255
    a9f4:	80 93 a1 02 	sts	0x02A1, r24
		  if (iFooter<4){
    a9f8:	84 30       	cpi	r24, 0x04	; 4
    a9fa:	90 f4       	brcc	.+36     	; 0xaa20 <FreePrinting+0x396>
		      if (SpaceOnly(strHeader)==True){
    a9fc:	84 e7       	ldi	r24, 0x74	; 116
    a9fe:	92 e0       	ldi	r25, 0x02	; 2
    aa00:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    aa04:	81 30       	cpi	r24, 0x01	; 1
    aa06:	11 f4       	brne	.+4      	; 0xaa0c <FreePrinting+0x382>
			      stFreePrinting=fpLoadFooter;
    aa08:	8c e0       	ldi	r24, 0x0C	; 12
    aa0a:	83 ce       	rjmp	.-762    	; 0xa712 <FreePrinting+0x88>
				  }
			  else{
			      iSend=0;
    aa0c:	10 92 73 02 	sts	0x0273, r1
    aa10:	10 92 72 02 	sts	0x0272, r1
				  iLoop=0;
    aa14:	10 92 6f 02 	sts	0x026F, r1
    aa18:	10 92 6e 02 	sts	0x026E, r1
				  stFreePrinting=fpPrintFooter;
    aa1c:	8d e0       	ldi	r24, 0x0D	; 13
    aa1e:	79 ce       	rjmp	.-782    	; 0xa712 <FreePrinting+0x88>
			      }
		  }else{
		    CarriegeReturn();
    aa20:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			iPrinted++;
    aa24:	80 91 a3 02 	lds	r24, 0x02A3
    aa28:	8f 5f       	subi	r24, 0xFF	; 255
    aa2a:	80 93 a3 02 	sts	0x02A3, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
    aa2e:	8e e0       	ldi	r24, 0x0E	; 14
    aa30:	70 ce       	rjmp	.-800    	; 0xa712 <FreePrinting+0x88>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
    aa32:	80 91 72 02 	lds	r24, 0x0272
    aa36:	90 91 73 02 	lds	r25, 0x0273
    aa3a:	88 97       	sbiw	r24, 0x28	; 40
    aa3c:	78 f4       	brcc	.+30     	; 0xaa5c <FreePrinting+0x3d2>
		      iLoop++;
    aa3e:	80 91 6e 02 	lds	r24, 0x026E
    aa42:	90 91 6f 02 	lds	r25, 0x026F
    aa46:	01 96       	adiw	r24, 0x01	; 1
    aa48:	90 93 6f 02 	sts	0x026F, r25
    aa4c:	80 93 6e 02 	sts	0x026E, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //_uart(_COM_PRINTER,1,strHeader[iSend]);
		        //iSend++;
				TimPrintBusy=0;
    aa50:	10 92 e3 01 	sts	0x01E3, r1
    aa54:	10 92 e2 01 	sts	0x01E2, r1
				stFreePrinting=fpCheckPrintStatusFooter;
    aa58:	84 e1       	ldi	r24, 0x14	; 20
    aa5a:	5b ce       	rjmp	.-842    	; 0xa712 <FreePrinting+0x88>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
    aa5c:	8c e0       	ldi	r24, 0x0C	; 12
    aa5e:	80 93 3a 01 	sts	0x013A, r24
			  CarriegeReturn();
    aa62:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
    aa66:	a4 c0       	rjmp	.+328    	; 0xabb0 <FreePrinting+0x526>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    aa68:	80 91 de 01 	lds	r24, 0x01DE
    aa6c:	88 23       	and	r24, r24
    aa6e:	b1 f4       	brne	.+44     	; 0xaa9c <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    aa70:	e0 91 72 02 	lds	r30, 0x0272
    aa74:	f0 91 73 02 	lds	r31, 0x0273
    aa78:	ec 58       	subi	r30, 0x8C	; 140
    aa7a:	fd 4f       	sbci	r31, 0xFD	; 253
    aa7c:	61 e0       	ldi	r22, 0x01	; 1
    aa7e:	40 81       	ld	r20, Z
    aa80:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		      iSend++;
    aa84:	80 91 72 02 	lds	r24, 0x0272
    aa88:	90 91 73 02 	lds	r25, 0x0273
    aa8c:	01 96       	adiw	r24, 0x01	; 1
    aa8e:	90 93 73 02 	sts	0x0273, r25
    aa92:	80 93 72 02 	sts	0x0272, r24
		      stFreePrinting=fpPrintFooter;
    aa96:	8d e0       	ldi	r24, 0x0D	; 13
    aa98:	80 93 3a 01 	sts	0x013A, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    aa9c:	80 91 e2 01 	lds	r24, 0x01E2
    aaa0:	90 91 e3 01 	lds	r25, 0x01E3
    aaa4:	0b 97       	sbiw	r24, 0x0b	; 11
    aaa6:	0c f4       	brge	.+2      	; 0xaaaa <FreePrinting+0x420>
    aaa8:	83 c0       	rjmp	.+262    	; 0xabb0 <FreePrinting+0x526>
		      IsPrintERROR=True;
    aaaa:	81 e0       	ldi	r24, 0x01	; 1
    aaac:	80 93 dd 01 	sts	0x01DD, r24
		      stFreePrinting=fpFinishFreePrinting;
    aab0:	81 e1       	ldi	r24, 0x11	; 17
    aab2:	2f ce       	rjmp	.-930    	; 0xa712 <FreePrinting+0x88>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
    aab4:	10 92 9e 02 	sts	0x029E, r1
		  iSend=0;
    aab8:	10 92 73 02 	sts	0x0273, r1
    aabc:	10 92 72 02 	sts	0x0272, r1
		  if (iPrinted<PrintCopy)
    aac0:	90 91 a3 02 	lds	r25, 0x02A3
    aac4:	80 91 a0 02 	lds	r24, 0x02A0
    aac8:	98 17       	cp	r25, r24
    aaca:	28 f4       	brcc	.+10     	; 0xaad6 <FreePrinting+0x44c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    aacc:	e1 99       	sbic	0x1c, 1	; 28
    aace:	fe cf       	rjmp	.-4      	; 0xaacc <FreePrinting+0x442>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    aad0:	82 e3       	ldi	r24, 0x32	; 50
    aad2:	90 e0       	ldi	r25, 0x00	; 0
    aad4:	04 c0       	rjmp	.+8      	; 0xaade <FreePrinting+0x454>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    aad6:	e1 99       	sbic	0x1c, 1	; 28
    aad8:	fe cf       	rjmp	.-4      	; 0xaad6 <FreePrinting+0x44c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    aada:	81 e3       	ldi	r24, 0x31	; 49
    aadc:	90 e0       	ldi	r25, 0x00	; 0
    aade:	9f bb       	out	0x1f, r25	; 31
    aae0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    aae2:	e0 9a       	sbi	0x1c, 0	; 28
    aae4:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    aae6:	80 93 9d 02 	sts	0x029D, r24

          stFreePrinting=fpScrollPaper;
    aaea:	8f e0       	ldi	r24, 0x0F	; 15
    aaec:	12 ce       	rjmp	.-988    	; 0xa712 <FreePrinting+0x88>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
    aaee:	90 91 9e 02 	lds	r25, 0x029E
    aaf2:	80 91 9d 02 	lds	r24, 0x029D
    aaf6:	89 17       	cp	r24, r25
    aaf8:	18 f4       	brcc	.+6      	; 0xab00 <FreePrinting+0x476>
    aafa:	80 e1       	ldi	r24, 0x10	; 16
    aafc:	80 93 3a 01 	sts	0x013A, r24
		  iSend++;
    ab00:	80 91 72 02 	lds	r24, 0x0272
    ab04:	90 91 73 02 	lds	r25, 0x0273
    ab08:	01 96       	adiw	r24, 0x01	; 1
    ab0a:	90 93 73 02 	sts	0x0273, r25
    ab0e:	80 93 72 02 	sts	0x0272, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
    ab12:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			  iScroll++;
    ab16:	80 91 9e 02 	lds	r24, 0x029E
    ab1a:	8f 5f       	subi	r24, 0xFF	; 255
    ab1c:	80 93 9e 02 	sts	0x029E, r24
    ab20:	47 c0       	rjmp	.+142    	; 0xabb0 <FreePrinting+0x526>
			  }
	      break;
     case fpPaperCut:
		  //_uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
    ab22:	90 91 a3 02 	lds	r25, 0x02A3
    ab26:	80 91 a0 02 	lds	r24, 0x02A0
    ab2a:	98 17       	cp	r25, r24
    ab2c:	20 f4       	brcc	.+8      	; 0xab36 <FreePrinting+0x4ac>
		      CarriegeReturn();
    ab2e:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
              stFreePrinting=fpInitHeader;
    ab32:	82 e0       	ldi	r24, 0x02	; 2
    ab34:	07 c0       	rjmp	.+14     	; 0xab44 <FreePrinting+0x4ba>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
    ab36:	80 91 25 01 	lds	r24, 0x0125
    ab3a:	81 30       	cpi	r24, 0x01	; 1
    ab3c:	11 f4       	brne	.+4      	; 0xab42 <FreePrinting+0x4b8>
    ab3e:	0e 94 e1 52 	call	0xa5c2	; 0xa5c2 <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
    ab42:	81 e1       	ldi	r24, 0x11	; 17
    ab44:	80 93 3a 01 	sts	0x013A, r24
			  }

		  if (((cmdPrint&0b00100000)>>5)==1){
    ab48:	80 91 e1 01 	lds	r24, 0x01E1
    ab4c:	85 ff       	sbrs	r24, 5
    ab4e:	30 c0       	rjmp	.+96     	; 0xabb0 <FreePrinting+0x526>
		      if (iPrinted==0){
    ab50:	80 91 a3 02 	lds	r24, 0x02A3
    ab54:	88 23       	and	r24, r24
    ab56:	31 f4       	brne	.+12     	; 0xab64 <FreePrinting+0x4da>
			      CarriegeReturn();_delay_ms(50);
    ab58:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
    ab5c:	84 ed       	ldi	r24, 0xD4	; 212
    ab5e:	90 e3       	ldi	r25, 0x30	; 48
    ab60:	01 97       	sbiw	r24, 0x01	; 1
    ab62:	f1 f7       	brne	.-4      	; 0xab60 <FreePrinting+0x4d6>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
    ab64:	90 91 a3 02 	lds	r25, 0x02A3
    ab68:	80 91 a0 02 	lds	r24, 0x02A0
    ab6c:	98 17       	cp	r25, r24
    ab6e:	b1 f4       	brne	.+44     	; 0xab9c <FreePrinting+0x512>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				       CarriegeReturn();_delay_ms(50);
    ab70:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
    ab74:	04 ed       	ldi	r16, 0xD4	; 212
    ab76:	10 e3       	ldi	r17, 0x30	; 48
    ab78:	c8 01       	movw	r24, r16
    ab7a:	01 97       	sbiw	r24, 0x01	; 1
    ab7c:	f1 f7       	brne	.-4      	; 0xab7a <FreePrinting+0x4f0>
					   CarriegeReturn();_delay_ms(50);
    ab7e:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
    ab82:	c8 01       	movw	r24, r16
    ab84:	01 97       	sbiw	r24, 0x01	; 1
    ab86:	f1 f7       	brne	.-4      	; 0xab84 <FreePrinting+0x4fa>
					   CarriegeReturn();_delay_ms(50);
    ab88:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
    ab8c:	c8 01       	movw	r24, r16
    ab8e:	01 97       	sbiw	r24, 0x01	; 1
    ab90:	f1 f7       	brne	.-4      	; 0xab8e <FreePrinting+0x504>
					   CarriegeReturn();_delay_ms(50);
    ab92:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
    ab96:	c8 01       	movw	r24, r16
    ab98:	01 97       	sbiw	r24, 0x01	; 1
    ab9a:	f1 f7       	brne	.-4      	; 0xab98 <FreePrinting+0x50e>
				   //}
				 }
		      PaperCut();
    ab9c:	0e 94 66 4c 	call	0x98cc	; 0x98cc <PaperCut>
    aba0:	07 c0       	rjmp	.+14     	; 0xabb0 <FreePrinting+0x526>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //_uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
    aba2:	10 92 df 01 	sts	0x01DF, r1
	      stFreePrinting=fpInit;
    aba6:	81 e0       	ldi	r24, 0x01	; 1
    aba8:	80 93 3a 01 	sts	0x013A, r24
		  iPrinted=0;
    abac:	10 92 a3 02 	sts	0x02A3, r1
	      break;
	 }//EndCase
}
    abb0:	1f 91       	pop	r17
    abb2:	0f 91       	pop	r16
    abb4:	08 95       	ret

0000abb6 <PrintIdle>:
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
    abb6:	cf 93       	push	r28
    abb8:	df 93       	push	r29
		_uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
    abba:	80 91 d9 01 	lds	r24, 0x01D9
    abbe:	81 30       	cpi	r24, 0x01	; 1
    abc0:	31 f4       	brne	.+12     	; 0xabce <PrintIdle+0x18>
    abc2:	80 91 e1 02 	lds	r24, 0x02E1
    abc6:	88 23       	and	r24, r24
    abc8:	11 f0       	breq	.+4      	; 0xabce <PrintIdle+0x18>
	     stPrintIdle=piIdle;
    abca:	10 92 e1 02 	sts	0x02E1, r1
	 }

     switch(stPrintIdle){
    abce:	80 91 e1 02 	lds	r24, 0x02E1
    abd2:	e8 2f       	mov	r30, r24
    abd4:	f0 e0       	ldi	r31, 0x00	; 0
    abd6:	e5 31       	cpi	r30, 0x15	; 21
    abd8:	f1 05       	cpc	r31, r1
    abda:	08 f0       	brcs	.+2      	; 0xabde <PrintIdle+0x28>
    abdc:	12 c7       	rjmp	.+3620   	; 0xba02 <PrintIdle+0xe4c>
    abde:	e7 58       	subi	r30, 0x87	; 135
    abe0:	ff 4f       	sbci	r31, 0xFF	; 255
    abe2:	ee 0f       	add	r30, r30
    abe4:	ff 1f       	adc	r31, r31
    abe6:	05 90       	lpm	r0, Z+
    abe8:	f4 91       	lpm	r31, Z+
    abea:	e0 2d       	mov	r30, r0
    abec:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
    abee:	80 91 d9 01 	lds	r24, 0x01D9
    abf2:	81 30       	cpi	r24, 0x01	; 1
    abf4:	09 f0       	breq	.+2      	; 0xabf8 <PrintIdle+0x42>
    abf6:	05 c7       	rjmp	.+3594   	; 0xba02 <PrintIdle+0xe4c>
		      IsPrinting=False;
    abf8:	10 92 d9 01 	sts	0x01D9, r1
			  IsBusyIdlePrinting=True;
    abfc:	80 93 e0 01 	sts	0x01E0, r24
			  IsBusyPrint=False;
    ac00:	10 92 de 01 	sts	0x01DE, r1
			  iPrinted=0;
    ac04:	10 92 a6 02 	sts	0x02A6, r1
			  PrintCopy=0;
    ac08:	10 92 a5 02 	sts	0x02A5, r1
		      stPrintIdle=piInit;
    ac0c:	80 93 e1 02 	sts	0x02E1, r24
			  InitPrinter();
    ac10:	0e 94 ca 4b 	call	0x9794	; 0x9794 <InitPrinter>
			  IsSignedField=False;
    ac14:	10 92 ad 02 	sts	0x02AD, r1
    ac18:	f4 c6       	rjmp	.+3560   	; 0xba02 <PrintIdle+0xe4c>
			  }
	      break;
	 case piInit:
	      iHeader=0;
    ac1a:	10 92 e0 02 	sts	0x02E0, r1
		  CarriegeReturn();
    ac1e:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
    ac22:	1d c0       	rjmp	.+58     	; 0xac5e <PrintIdle+0xa8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ac24:	60 91 e0 02 	lds	r22, 0x02E0
    ac28:	89 e2       	ldi	r24, 0x29	; 41
    ac2a:	68 9f       	mul	r22, r24
    ac2c:	b0 01       	movw	r22, r0
    ac2e:	11 24       	eor	r1, r1
    ac30:	69 5a       	subi	r22, 0xA9	; 169
    ac32:	7d 4f       	sbci	r23, 0xFD	; 253
    ac34:	80 eb       	ldi	r24, 0xB0	; 176
    ac36:	92 e0       	ldi	r25, 0x02	; 2
    ac38:	49 e2       	ldi	r20, 0x29	; 41
    ac3a:	50 e0       	ldi	r21, 0x00	; 0
    ac3c:	27 e9       	ldi	r18, 0x97	; 151
    ac3e:	32 e1       	ldi	r19, 0x12	; 18
    ac40:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
    ac44:	80 91 e0 02 	lds	r24, 0x02E0
    ac48:	8f 5f       	subi	r24, 0xFF	; 255
    ac4a:	80 93 e0 02 	sts	0x02E0, r24
		  if (iHeader<6){
    ac4e:	86 30       	cpi	r24, 0x06	; 6
    ac50:	00 f5       	brcc	.+64     	; 0xac92 <PrintIdle+0xdc>
		      if (SpaceOnly(strPrint)==True){
    ac52:	80 eb       	ldi	r24, 0xB0	; 176
    ac54:	92 e0       	ldi	r25, 0x02	; 2
    ac56:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    ac5a:	81 30       	cpi	r24, 0x01	; 1
    ac5c:	11 f4       	brne	.+4      	; 0xac62 <PrintIdle+0xac>
			      stPrintIdle=piLoadHeader;
    ac5e:	82 e0       	ldi	r24, 0x02	; 2
    ac60:	96 c6       	rjmp	.+3372   	; 0xb98e <PrintIdle+0xdd8>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
    ac62:	83 e0       	ldi	r24, 0x03	; 3
    ac64:	80 93 e1 02 	sts	0x02E1, r24
			      iSend=0;
    ac68:	10 92 ac 02 	sts	0x02AC, r1
    ac6c:	10 92 ab 02 	sts	0x02AB, r1
				  iLoop=0;
    ac70:	10 92 a8 02 	sts	0x02A8, r1
    ac74:	10 92 a7 02 	sts	0x02A7, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    ac78:	80 91 e0 02 	lds	r24, 0x02E0
    ac7c:	81 30       	cpi	r24, 0x01	; 1
    ac7e:	19 f4       	brne	.+6      	; 0xac86 <PrintIdle+0xd0>
    ac80:	0e 94 4c 4c 	call	0x9898	; 0x9898 <PrintDoubleHeight>
    ac84:	be c6       	rjmp	.+3452   	; 0xba02 <PrintIdle+0xe4c>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    ac86:	82 30       	cpi	r24, 0x02	; 2
    ac88:	09 f0       	breq	.+2      	; 0xac8c <PrintIdle+0xd6>
    ac8a:	bb c6       	rjmp	.+3446   	; 0xba02 <PrintIdle+0xe4c>
    ac8c:	0e 94 32 4c 	call	0x9864	; 0x9864 <PrintNormalHeight>
    ac90:	b8 c6       	rjmp	.+3440   	; 0xba02 <PrintIdle+0xe4c>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
    ac92:	84 e0       	ldi	r24, 0x04	; 4
    ac94:	7c c6       	rjmp	.+3320   	; 0xb98e <PrintIdle+0xdd8>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
    ac96:	80 91 ab 02 	lds	r24, 0x02AB
    ac9a:	90 91 ac 02 	lds	r25, 0x02AC
    ac9e:	88 97       	sbiw	r24, 0x28	; 40
    aca0:	78 f4       	brcc	.+30     	; 0xacc0 <PrintIdle+0x10a>
		      iLoop++;
    aca2:	80 91 a7 02 	lds	r24, 0x02A7
    aca6:	90 91 a8 02 	lds	r25, 0x02A8
    acaa:	01 96       	adiw	r24, 0x01	; 1
    acac:	90 93 a8 02 	sts	0x02A8, r25
    acb0:	80 93 a7 02 	sts	0x02A7, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    acb4:	10 92 e3 01 	sts	0x01E3, r1
    acb8:	10 92 e2 01 	sts	0x01E2, r1
				 stPrintIdle=piCheckPrintStatusHeader;
    acbc:	8b e0       	ldi	r24, 0x0B	; 11
    acbe:	67 c6       	rjmp	.+3278   	; 0xb98e <PrintIdle+0xdd8>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
    acc0:	82 e0       	ldi	r24, 0x02	; 2
    acc2:	f5 c5       	rjmp	.+3050   	; 0xb8ae <PrintIdle+0xcf8>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    acc4:	80 91 de 01 	lds	r24, 0x01DE
    acc8:	88 23       	and	r24, r24
    acca:	09 f0       	breq	.+2      	; 0xacce <PrintIdle+0x118>
    accc:	56 c6       	rjmp	.+3244   	; 0xb97a <PrintIdle+0xdc4>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    acce:	e0 91 ab 02 	lds	r30, 0x02AB
    acd2:	f0 91 ac 02 	lds	r31, 0x02AC
    acd6:	e0 55       	subi	r30, 0x50	; 80
    acd8:	fd 4f       	sbci	r31, 0xFD	; 253
    acda:	61 e0       	ldi	r22, 0x01	; 1
    acdc:	40 81       	ld	r20, Z
    acde:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		      iSend++;
    ace2:	80 91 ab 02 	lds	r24, 0x02AB
    ace6:	90 91 ac 02 	lds	r25, 0x02AC
    acea:	01 96       	adiw	r24, 0x01	; 1
    acec:	90 93 ac 02 	sts	0x02AC, r25
    acf0:	80 93 ab 02 	sts	0x02AB, r24
		      stPrintIdle=piPrintHeader;
    acf4:	83 e0       	ldi	r24, 0x03	; 3
    acf6:	3f c6       	rjmp	.+3198   	; 0xb976 <PrintIdle+0xdc0>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
    acf8:	80 91 a6 02 	lds	r24, 0x02A6
    acfc:	88 23       	and	r24, r24
    acfe:	21 f4       	brne	.+8      	; 0xad08 <PrintIdle+0x152>
    ad00:	80 91 a8 01 	lds	r24, 0x01A8
    ad04:	81 30       	cpi	r24, 0x01	; 1
    ad06:	a9 f4       	brne	.+42     	; 0xad32 <PrintIdle+0x17c>
		      IsReprintTicket=False;
    ad08:	10 92 a8 01 	sts	0x01A8, r1
		      CarriegeReturn(); 
    ad0c:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    ad10:	00 d0       	rcall	.+0      	; 0xad12 <PrintIdle+0x15c>
    ad12:	00 d0       	rcall	.+0      	; 0xad14 <PrintIdle+0x15e>
    ad14:	80 eb       	ldi	r24, 0xB0	; 176
    ad16:	92 e0       	ldi	r25, 0x02	; 2
    ad18:	ad b7       	in	r26, 0x3d	; 61
    ad1a:	be b7       	in	r27, 0x3e	; 62
    ad1c:	12 96       	adiw	r26, 0x02	; 2
    ad1e:	9c 93       	st	X, r25
    ad20:	8e 93       	st	-X, r24
    ad22:	11 97       	sbiw	r26, 0x01	; 1
    ad24:	85 e8       	ldi	r24, 0x85	; 133
    ad26:	9a e0       	ldi	r25, 0x0A	; 10
    ad28:	14 96       	adiw	r26, 0x04	; 4
    ad2a:	9c 93       	st	X, r25
    ad2c:	8e 93       	st	-X, r24
    ad2e:	13 97       	sbiw	r26, 0x03	; 3
    ad30:	0c c0       	rjmp	.+24     	; 0xad4a <PrintIdle+0x194>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
    ad32:	00 d0       	rcall	.+0      	; 0xad34 <PrintIdle+0x17e>
    ad34:	00 d0       	rcall	.+0      	; 0xad36 <PrintIdle+0x180>
    ad36:	80 eb       	ldi	r24, 0xB0	; 176
    ad38:	92 e0       	ldi	r25, 0x02	; 2
    ad3a:	ed b7       	in	r30, 0x3d	; 61
    ad3c:	fe b7       	in	r31, 0x3e	; 62
    ad3e:	92 83       	std	Z+2, r25	; 0x02
    ad40:	81 83       	std	Z+1, r24	; 0x01
    ad42:	83 e8       	ldi	r24, 0x83	; 131
    ad44:	9a e0       	ldi	r25, 0x0A	; 10
    ad46:	94 83       	std	Z+4, r25	; 0x04
    ad48:	83 83       	std	Z+3, r24	; 0x03
    ad4a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    ad4e:	0f 90       	pop	r0
    ad50:	0f 90       	pop	r0
    ad52:	0f 90       	pop	r0
    ad54:	0f 90       	pop	r0
		      }
		  iSend=0;
    ad56:	10 92 ac 02 	sts	0x02AC, r1
    ad5a:	10 92 ab 02 	sts	0x02AB, r1
		  iLoop=0;
    ad5e:	10 92 a8 02 	sts	0x02A8, r1
    ad62:	10 92 a7 02 	sts	0x02A7, r1
		  LSend=strlen(strPrint);
    ad66:	e0 eb       	ldi	r30, 0xB0	; 176
    ad68:	f2 e0       	ldi	r31, 0x02	; 2
    ad6a:	01 90       	ld	r0, Z+
    ad6c:	00 20       	and	r0, r0
    ad6e:	e9 f7       	brne	.-6      	; 0xad6a <PrintIdle+0x1b4>
    ad70:	31 97       	sbiw	r30, 0x01	; 1
    ad72:	e0 5b       	subi	r30, 0xB0	; 176
    ad74:	f2 40       	sbci	r31, 0x02	; 2
    ad76:	f0 93 aa 02 	sts	0x02AA, r31
    ad7a:	e0 93 a9 02 	sts	0x02A9, r30
          stPrintIdle=piPrintDuplicate; 
    ad7e:	85 e0       	ldi	r24, 0x05	; 5
    ad80:	06 c6       	rjmp	.+3084   	; 0xb98e <PrintIdle+0xdd8>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
    ad82:	20 91 ab 02 	lds	r18, 0x02AB
    ad86:	30 91 ac 02 	lds	r19, 0x02AC
    ad8a:	80 91 a9 02 	lds	r24, 0x02A9
    ad8e:	90 91 aa 02 	lds	r25, 0x02AA
    ad92:	28 17       	cp	r18, r24
    ad94:	39 07       	cpc	r19, r25
    ad96:	78 f4       	brcc	.+30     	; 0xadb6 <PrintIdle+0x200>
		      iLoop++;
    ad98:	80 91 a7 02 	lds	r24, 0x02A7
    ad9c:	90 91 a8 02 	lds	r25, 0x02A8
    ada0:	01 96       	adiw	r24, 0x01	; 1
    ada2:	90 93 a8 02 	sts	0x02A8, r25
    ada6:	80 93 a7 02 	sts	0x02A7, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    adaa:	10 92 e3 01 	sts	0x01E3, r1
    adae:	10 92 e2 01 	sts	0x01E2, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
    adb2:	86 e0       	ldi	r24, 0x06	; 6
    adb4:	ec c5       	rjmp	.+3032   	; 0xb98e <PrintIdle+0xdd8>
				 }
			  }
          else {
		     iSend=0;
    adb6:	10 92 ac 02 	sts	0x02AC, r1
    adba:	10 92 ab 02 	sts	0x02AB, r1
		     stPrintIdle=piInitMessage;
    adbe:	87 e0       	ldi	r24, 0x07	; 7
    adc0:	e6 c5       	rjmp	.+3020   	; 0xb98e <PrintIdle+0xdd8>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    adc2:	80 91 de 01 	lds	r24, 0x01DE
    adc6:	88 23       	and	r24, r24
    adc8:	09 f0       	breq	.+2      	; 0xadcc <PrintIdle+0x216>
    adca:	d7 c5       	rjmp	.+2990   	; 0xb97a <PrintIdle+0xdc4>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    adcc:	e0 91 ab 02 	lds	r30, 0x02AB
    add0:	f0 91 ac 02 	lds	r31, 0x02AC
    add4:	e0 55       	subi	r30, 0x50	; 80
    add6:	fd 4f       	sbci	r31, 0xFD	; 253
    add8:	61 e0       	ldi	r22, 0x01	; 1
    adda:	40 81       	ld	r20, Z
    addc:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		      iSend++;
    ade0:	80 91 ab 02 	lds	r24, 0x02AB
    ade4:	90 91 ac 02 	lds	r25, 0x02AC
    ade8:	01 96       	adiw	r24, 0x01	; 1
    adea:	90 93 ac 02 	sts	0x02AC, r25
    adee:	80 93 ab 02 	sts	0x02AB, r24
		      stPrintIdle=piPrintDuplicate;
    adf2:	85 e0       	ldi	r24, 0x05	; 5
    adf4:	c0 c5       	rjmp	.+2944   	; 0xb976 <PrintIdle+0xdc0>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
    adf6:	10 92 ac 02 	sts	0x02AC, r1
    adfa:	10 92 ab 02 	sts	0x02AB, r1
    adfe:	10 92 a8 02 	sts	0x02A8, r1
    ae02:	10 92 a7 02 	sts	0x02A7, r1
		  iMessage=0;
    ae06:	10 92 af 02 	sts	0x02AF, r1
		  switch(MOPType){
    ae0a:	80 91 e5 01 	lds	r24, 0x01E5
    ae0e:	83 30       	cpi	r24, 0x03	; 3
    ae10:	81 f0       	breq	.+32     	; 0xae32 <PrintIdle+0x27c>
    ae12:	84 30       	cpi	r24, 0x04	; 4
    ae14:	28 f4       	brcc	.+10     	; 0xae20 <PrintIdle+0x26a>
    ae16:	81 30       	cpi	r24, 0x01	; 1
    ae18:	61 f0       	breq	.+24     	; 0xae32 <PrintIdle+0x27c>
    ae1a:	82 30       	cpi	r24, 0x02	; 2
    ae1c:	40 f4       	brcc	.+16     	; 0xae2e <PrintIdle+0x278>
    ae1e:	10 c0       	rjmp	.+32     	; 0xae40 <PrintIdle+0x28a>
    ae20:	88 30       	cpi	r24, 0x08	; 8
    ae22:	49 f0       	breq	.+18     	; 0xae36 <PrintIdle+0x280>
    ae24:	89 30       	cpi	r24, 0x09	; 9
    ae26:	61 f0       	breq	.+24     	; 0xae40 <PrintIdle+0x28a>
    ae28:	87 30       	cpi	r24, 0x07	; 7
    ae2a:	51 f4       	brne	.+20     	; 0xae40 <PrintIdle+0x28a>
    ae2c:	02 c0       	rjmp	.+4      	; 0xae32 <PrintIdle+0x27c>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
    ae2e:	8a e0       	ldi	r24, 0x0A	; 10
    ae30:	03 c0       	rjmp	.+6      	; 0xae38 <PrintIdle+0x282>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
    ae32:	84 e1       	ldi	r24, 0x14	; 20
    ae34:	01 c0       	rjmp	.+2      	; 0xae38 <PrintIdle+0x282>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
    ae36:	8c e0       	ldi	r24, 0x0C	; 12
    ae38:	80 93 ae 02 	sts	0x02AE, r24
			   PrintCopy=2;
    ae3c:	82 e0       	ldi	r24, 0x02	; 2
    ae3e:	04 c0       	rjmp	.+8      	; 0xae48 <PrintIdle+0x292>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
    ae40:	8a e0       	ldi	r24, 0x0A	; 10
    ae42:	80 93 ae 02 	sts	0x02AE, r24
			   PrintCopy=1;
    ae46:	81 e0       	ldi	r24, 0x01	; 1
    ae48:	80 93 a5 02 	sts	0x02A5, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
    ae4c:	80 91 ec 04 	lds	r24, 0x04EC
    ae50:	88 23       	and	r24, r24
    ae52:	49 f0       	breq	.+18     	; 0xae66 <PrintIdle+0x2b0>
    ae54:	8c ee       	ldi	r24, 0xEC	; 236
    ae56:	94 e0       	ldi	r25, 0x04	; 4
    ae58:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    ae5c:	88 23       	and	r24, r24
    ae5e:	19 f4       	brne	.+6      	; 0xae66 <PrintIdle+0x2b0>
		       MessageLine=33;
    ae60:	81 e2       	ldi	r24, 0x21	; 33
    ae62:	80 93 ae 02 	sts	0x02AE, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
    ae66:	88 e0       	ldi	r24, 0x08	; 8
    ae68:	92 c5       	rjmp	.+2852   	; 0xb98e <PrintIdle+0xdd8>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
    ae6a:	80 91 a6 02 	lds	r24, 0x02A6
    ae6e:	88 23       	and	r24, r24
    ae70:	09 f0       	breq	.+2      	; 0xae74 <PrintIdle+0x2be>
    ae72:	c0 c4       	rjmp	.+2432   	; 0xb7f4 <PrintIdle+0xc3e>

		      FormatDate(DATE_LONG_YEAR,strDate);
    ae74:	68 e7       	ldi	r22, 0x78	; 120
    ae76:	79 e0       	ldi	r23, 0x09	; 9
    ae78:	0e 94 6c 22 	call	0x44d8	; 0x44d8 <FormatDate>
              RemZeroLead(strIslandID);
    ae7c:	8a ef       	ldi	r24, 0xFA	; 250
    ae7e:	9a e0       	ldi	r25, 0x0A	; 10
    ae80:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
			  RemZeroLead(strFIP_ID);
    ae84:	83 ec       	ldi	r24, 0xC3	; 195
    ae86:	99 e0       	ldi	r25, 0x09	; 9
    ae88:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		      RemZeroLead(strPrice);              
    ae8c:	88 ea       	ldi	r24, 0xA8	; 168
    ae8e:	97 e0       	ldi	r25, 0x07	; 7
    ae90:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
              //RemZeroLead(strVolume);
              RemZeroLead(strAmount);
    ae94:	86 eb       	ldi	r24, 0xB6	; 182
    ae96:	9d e0       	ldi	r25, 0x0D	; 13
    ae98:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>

			  RemDecimal(strPrice);
    ae9c:	88 ea       	ldi	r24, 0xA8	; 168
    ae9e:	97 e0       	ldi	r25, 0x07	; 7
    aea0:	0e 94 b5 21 	call	0x436a	; 0x436a <RemDecimal>
			  RemDecimal(strAmount);
    aea4:	86 eb       	ldi	r24, 0xB6	; 182
    aea6:	9d e0       	ldi	r25, 0x0D	; 13
    aea8:	0e 94 b5 21 	call	0x436a	; 0x436a <RemDecimal>
	  
			  FormatCurrency(strPrice);
    aeac:	88 ea       	ldi	r24, 0xA8	; 168
    aeae:	97 e0       	ldi	r25, 0x07	; 7
    aeb0:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
			  FormatCurrency(strAmount);
    aeb4:	86 eb       	ldi	r24, 0xB6	; 182
    aeb6:	9d e0       	ldi	r25, 0x0D	; 13
    aeb8:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
              if (IFType==IT_SLAVE){
    aebc:	80 91 25 01 	lds	r24, 0x0125
    aec0:	81 30       	cpi	r24, 0x01	; 1
    aec2:	09 f0       	breq	.+2      	; 0xaec6 <PrintIdle+0x310>
    aec4:	97 c4       	rjmp	.+2350   	; 0xb7f4 <PrintIdle+0xc3e>
		          RemSpaceLag(strCardID);
    aec6:	8c e8       	ldi	r24, 0x8C	; 140
    aec8:	9d e0       	ldi	r25, 0x0D	; 13
    aeca:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
    aece:	89 e2       	ldi	r24, 0x29	; 41
    aed0:	95 e0       	ldi	r25, 0x05	; 5
    aed2:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
    aed6:	87 e8       	ldi	r24, 0x87	; 135
    aed8:	97 e0       	ldi	r25, 0x07	; 7
    aeda:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
    aede:	89 ec       	ldi	r24, 0xC9	; 201
    aee0:	94 e0       	ldi	r25, 0x04	; 4
    aee2:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
    aee6:	80 e1       	ldi	r24, 0x10	; 16
    aee8:	9e e0       	ldi	r25, 0x0E	; 14
    aeea:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
    aeee:	82 ed       	ldi	r24, 0xD2	; 210
    aef0:	95 e0       	ldi	r25, 0x05	; 5
    aef2:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
    aef6:	8f e9       	ldi	r24, 0x9F	; 159
    aef8:	95 e0       	ldi	r25, 0x05	; 5
    aefa:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
    aefe:	83 ef       	ldi	r24, 0xF3	; 243
    af00:	9d e0       	ldi	r25, 0x0D	; 13
    af02:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
    af06:	83 e8       	ldi	r24, 0x83	; 131
    af08:	95 e0       	ldi	r25, 0x05	; 5
    af0a:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
    af0e:	83 ef       	ldi	r24, 0xF3	; 243
    af10:	9d e0       	ldi	r25, 0x0D	; 13
    af12:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
    af16:	83 e8       	ldi	r24, 0x83	; 131
    af18:	95 e0       	ldi	r25, 0x05	; 5
    af1a:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
    af1e:	6a c4       	rjmp	.+2260   	; 0xb7f4 <PrintIdle+0xc3e>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
    af20:	80 91 af 02 	lds	r24, 0x02AF
    af24:	e8 2f       	mov	r30, r24
    af26:	f0 e0       	ldi	r31, 0x00	; 0
    af28:	e5 32       	cpi	r30, 0x25	; 37
    af2a:	f1 05       	cpc	r31, r1
    af2c:	08 f0       	brcs	.+2      	; 0xaf30 <PrintIdle+0x37a>
    af2e:	26 c4       	rjmp	.+2124   	; 0xb77c <PrintIdle+0xbc6>
    af30:	e2 57       	subi	r30, 0x72	; 114
    af32:	ff 4f       	sbci	r31, 0xFF	; 255
    af34:	ee 0f       	add	r30, r30
    af36:	ff 1f       	adc	r31, r31
    af38:	05 90       	lpm	r0, Z+
    af3a:	f4 91       	lpm	r31, Z+
    af3c:	e0 2d       	mov	r30, r0
    af3e:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
    af40:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
    af44:	8d b7       	in	r24, 0x3d	; 61
    af46:	9e b7       	in	r25, 0x3e	; 62
    af48:	08 97       	sbiw	r24, 0x08	; 8
    af4a:	0f b6       	in	r0, 0x3f	; 63
    af4c:	f8 94       	cli
    af4e:	9e bf       	out	0x3e, r25	; 62
    af50:	0f be       	out	0x3f, r0	; 63
    af52:	8d bf       	out	0x3d, r24	; 61
    af54:	ed b7       	in	r30, 0x3d	; 61
    af56:	fe b7       	in	r31, 0x3e	; 62
    af58:	31 96       	adiw	r30, 0x01	; 1
    af5a:	80 eb       	ldi	r24, 0xB0	; 176
    af5c:	92 e0       	ldi	r25, 0x02	; 2
    af5e:	ad b7       	in	r26, 0x3d	; 61
    af60:	be b7       	in	r27, 0x3e	; 62
    af62:	12 96       	adiw	r26, 0x02	; 2
    af64:	9c 93       	st	X, r25
    af66:	8e 93       	st	-X, r24
    af68:	11 97       	sbiw	r26, 0x01	; 1
    af6a:	84 e6       	ldi	r24, 0x64	; 100
    af6c:	9a e0       	ldi	r25, 0x0A	; 10
    af6e:	93 83       	std	Z+3, r25	; 0x03
    af70:	82 83       	std	Z+2, r24	; 0x02
    af72:	8e e6       	ldi	r24, 0x6E	; 110
    af74:	9e e0       	ldi	r25, 0x0E	; 14
    af76:	95 83       	std	Z+5, r25	; 0x05
    af78:	84 83       	std	Z+4, r24	; 0x04
    af7a:	8d e8       	ldi	r24, 0x8D	; 141
    af7c:	9e e0       	ldi	r25, 0x0E	; 14
    af7e:	1f c0       	rjmp	.+62     	; 0xafbe <PrintIdle+0x408>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
    af80:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
    af84:	8d b7       	in	r24, 0x3d	; 61
    af86:	9e b7       	in	r25, 0x3e	; 62
    af88:	08 97       	sbiw	r24, 0x08	; 8
    af8a:	0f b6       	in	r0, 0x3f	; 63
    af8c:	f8 94       	cli
    af8e:	9e bf       	out	0x3e, r25	; 62
    af90:	0f be       	out	0x3f, r0	; 63
    af92:	8d bf       	out	0x3d, r24	; 61
    af94:	ed b7       	in	r30, 0x3d	; 61
    af96:	fe b7       	in	r31, 0x3e	; 62
    af98:	31 96       	adiw	r30, 0x01	; 1
    af9a:	80 eb       	ldi	r24, 0xB0	; 176
    af9c:	92 e0       	ldi	r25, 0x02	; 2
    af9e:	ad b7       	in	r26, 0x3d	; 61
    afa0:	be b7       	in	r27, 0x3e	; 62
    afa2:	12 96       	adiw	r26, 0x02	; 2
    afa4:	9c 93       	st	X, r25
    afa6:	8e 93       	st	-X, r24
    afa8:	11 97       	sbiw	r26, 0x01	; 1
    afaa:	80 e5       	ldi	r24, 0x50	; 80
    afac:	9a e0       	ldi	r25, 0x0A	; 10
    afae:	93 83       	std	Z+3, r25	; 0x03
    afb0:	82 83       	std	Z+2, r24	; 0x02
    afb2:	88 e7       	ldi	r24, 0x78	; 120
    afb4:	99 e0       	ldi	r25, 0x09	; 9
    afb6:	95 83       	std	Z+5, r25	; 0x05
    afb8:	84 83       	std	Z+4, r24	; 0x04
    afba:	82 e5       	ldi	r24, 0x52	; 82
    afbc:	95 e0       	ldi	r25, 0x05	; 5
    afbe:	97 83       	std	Z+7, r25	; 0x07
    afc0:	86 83       	std	Z+6, r24	; 0x06
    afc2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    afc6:	ed b7       	in	r30, 0x3d	; 61
    afc8:	fe b7       	in	r31, 0x3e	; 62
    afca:	38 96       	adiw	r30, 0x08	; 8
    afcc:	b9 c3       	rjmp	.+1906   	; 0xb740 <PrintIdle+0xb8a>
		       break;
		  case 2:
		       CarriegeReturn();
    afce:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    afd2:	00 d0       	rcall	.+0      	; 0xafd4 <PrintIdle+0x41e>
    afd4:	00 d0       	rcall	.+0      	; 0xafd6 <PrintIdle+0x420>
    afd6:	80 eb       	ldi	r24, 0xB0	; 176
    afd8:	92 e0       	ldi	r25, 0x02	; 2
    afda:	ad b7       	in	r26, 0x3d	; 61
    afdc:	be b7       	in	r27, 0x3e	; 62
    afde:	12 96       	adiw	r26, 0x02	; 2
    afe0:	9c 93       	st	X, r25
    afe2:	8e 93       	st	-X, r24
    afe4:	11 97       	sbiw	r26, 0x01	; 1
    afe6:	8d e2       	ldi	r24, 0x2D	; 45
    afe8:	9a e0       	ldi	r25, 0x0A	; 10
    afea:	be c3       	rjmp	.+1916   	; 0xb768 <PrintIdle+0xbb2>
		       break;
		  case 3:
		       CarriegeReturn();
    afec:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
    aff0:	ed b7       	in	r30, 0x3d	; 61
    aff2:	fe b7       	in	r31, 0x3e	; 62
    aff4:	38 97       	sbiw	r30, 0x08	; 8
    aff6:	0f b6       	in	r0, 0x3f	; 63
    aff8:	f8 94       	cli
    affa:	fe bf       	out	0x3e, r31	; 62
    affc:	0f be       	out	0x3f, r0	; 63
    affe:	ed bf       	out	0x3d, r30	; 61
    b000:	31 96       	adiw	r30, 0x01	; 1
    b002:	80 eb       	ldi	r24, 0xB0	; 176
    b004:	92 e0       	ldi	r25, 0x02	; 2
    b006:	ad b7       	in	r26, 0x3d	; 61
    b008:	be b7       	in	r27, 0x3e	; 62
    b00a:	12 96       	adiw	r26, 0x02	; 2
    b00c:	9c 93       	st	X, r25
    b00e:	8e 93       	st	-X, r24
    b010:	11 97       	sbiw	r26, 0x01	; 1
    b012:	81 e1       	ldi	r24, 0x11	; 17
    b014:	9a e0       	ldi	r25, 0x0A	; 10
    b016:	93 83       	std	Z+3, r25	; 0x03
    b018:	82 83       	std	Z+2, r24	; 0x02
    b01a:	8a ef       	ldi	r24, 0xFA	; 250
    b01c:	9a e0       	ldi	r25, 0x0A	; 10
    b01e:	95 83       	std	Z+5, r25	; 0x05
    b020:	84 83       	std	Z+4, r24	; 0x04
    b022:	83 ec       	ldi	r24, 0xC3	; 195
    b024:	99 e0       	ldi	r25, 0x09	; 9
    b026:	cb cf       	rjmp	.-106    	; 0xafbe <PrintIdle+0x408>
		       break;
		  case 4:
		       CarriegeReturn();
    b028:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
    b02c:	00 d0       	rcall	.+0      	; 0xb02e <PrintIdle+0x478>
    b02e:	00 d0       	rcall	.+0      	; 0xb030 <PrintIdle+0x47a>
    b030:	00 d0       	rcall	.+0      	; 0xb032 <PrintIdle+0x47c>
    b032:	ed b7       	in	r30, 0x3d	; 61
    b034:	fe b7       	in	r31, 0x3e	; 62
    b036:	31 96       	adiw	r30, 0x01	; 1
    b038:	80 eb       	ldi	r24, 0xB0	; 176
    b03a:	92 e0       	ldi	r25, 0x02	; 2
    b03c:	ad b7       	in	r26, 0x3d	; 61
    b03e:	be b7       	in	r27, 0x3e	; 62
    b040:	12 96       	adiw	r26, 0x02	; 2
    b042:	9c 93       	st	X, r25
    b044:	8e 93       	st	-X, r24
    b046:	11 97       	sbiw	r26, 0x01	; 1
    b048:	8a ef       	ldi	r24, 0xFA	; 250
    b04a:	99 e0       	ldi	r25, 0x09	; 9
    b04c:	93 83       	std	Z+3, r25	; 0x03
    b04e:	82 83       	std	Z+2, r24	; 0x02
    b050:	88 e3       	ldi	r24, 0x38	; 56
    b052:	9a e0       	ldi	r25, 0x0A	; 10
    b054:	6e c3       	rjmp	.+1756   	; 0xb732 <PrintIdle+0xb7c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b056:	e1 99       	sbic	0x1c, 1	; 28
    b058:	fe cf       	rjmp	.-4      	; 0xb056 <PrintIdle+0x4a0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b05a:	81 ef       	ldi	r24, 0xF1	; 241
    b05c:	93 e0       	ldi	r25, 0x03	; 3
    b05e:	9f bb       	out	0x1f, r25	; 31
    b060:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b062:	e0 9a       	sbi	0x1c, 0	; 28
    b064:	8d b3       	in	r24, 0x1d	; 29
    b066:	c0 eb       	ldi	r28, 0xB0	; 176
    b068:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b06a:	81 30       	cpi	r24, 0x01	; 1
    b06c:	a9 f4       	brne	.+42     	; 0xb098 <PrintIdle+0x4e2>
			   	   CarriegeReturn();
    b06e:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
    b072:	00 d0       	rcall	.+0      	; 0xb074 <PrintIdle+0x4be>
    b074:	00 d0       	rcall	.+0      	; 0xb076 <PrintIdle+0x4c0>
    b076:	00 d0       	rcall	.+0      	; 0xb078 <PrintIdle+0x4c2>
    b078:	ed b7       	in	r30, 0x3d	; 61
    b07a:	fe b7       	in	r31, 0x3e	; 62
    b07c:	31 96       	adiw	r30, 0x01	; 1
    b07e:	ad b7       	in	r26, 0x3d	; 61
    b080:	be b7       	in	r27, 0x3e	; 62
    b082:	12 96       	adiw	r26, 0x02	; 2
    b084:	dc 93       	st	X, r29
    b086:	ce 93       	st	-X, r28
    b088:	11 97       	sbiw	r26, 0x01	; 1
    b08a:	80 ee       	ldi	r24, 0xE0	; 224
    b08c:	99 e0       	ldi	r25, 0x09	; 9
    b08e:	93 83       	std	Z+3, r25	; 0x03
    b090:	82 83       	std	Z+2, r24	; 0x02
    b092:	88 ea       	ldi	r24, 0xA8	; 168
    b094:	97 e0       	ldi	r25, 0x07	; 7
    b096:	4d c3       	rjmp	.+1690   	; 0xb732 <PrintIdle+0xb7c>
			   }else sprintf_P(strPrint,PSTR(""));
    b098:	00 d0       	rcall	.+0      	; 0xb09a <PrintIdle+0x4e4>
    b09a:	00 d0       	rcall	.+0      	; 0xb09c <PrintIdle+0x4e6>
    b09c:	ad b7       	in	r26, 0x3d	; 61
    b09e:	be b7       	in	r27, 0x3e	; 62
    b0a0:	12 96       	adiw	r26, 0x02	; 2
    b0a2:	dc 93       	st	X, r29
    b0a4:	ce 93       	st	-X, r28
    b0a6:	11 97       	sbiw	r26, 0x01	; 1
    b0a8:	8f ed       	ldi	r24, 0xDF	; 223
    b0aa:	99 e0       	ldi	r25, 0x09	; 9
    b0ac:	5d c3       	rjmp	.+1722   	; 0xb768 <PrintIdle+0xbb2>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
    b0ae:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
    b0b2:	00 d0       	rcall	.+0      	; 0xb0b4 <PrintIdle+0x4fe>
    b0b4:	00 d0       	rcall	.+0      	; 0xb0b6 <PrintIdle+0x500>
    b0b6:	00 d0       	rcall	.+0      	; 0xb0b8 <PrintIdle+0x502>
    b0b8:	ed b7       	in	r30, 0x3d	; 61
    b0ba:	fe b7       	in	r31, 0x3e	; 62
    b0bc:	31 96       	adiw	r30, 0x01	; 1
    b0be:	80 eb       	ldi	r24, 0xB0	; 176
    b0c0:	92 e0       	ldi	r25, 0x02	; 2
    b0c2:	ad b7       	in	r26, 0x3d	; 61
    b0c4:	be b7       	in	r27, 0x3e	; 62
    b0c6:	12 96       	adiw	r26, 0x02	; 2
    b0c8:	9c 93       	st	X, r25
    b0ca:	8e 93       	st	-X, r24
    b0cc:	11 97       	sbiw	r26, 0x01	; 1
    b0ce:	86 ec       	ldi	r24, 0xC6	; 198
    b0d0:	99 e0       	ldi	r25, 0x09	; 9
    b0d2:	93 83       	std	Z+3, r25	; 0x03
    b0d4:	82 83       	std	Z+2, r24	; 0x02
    b0d6:	8a e7       	ldi	r24, 0x7A	; 122
    b0d8:	95 e0       	ldi	r25, 0x05	; 5
    b0da:	2b c3       	rjmp	.+1622   	; 0xb732 <PrintIdle+0xb7c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b0dc:	e1 99       	sbic	0x1c, 1	; 28
    b0de:	fe cf       	rjmp	.-4      	; 0xb0dc <PrintIdle+0x526>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b0e0:	81 ef       	ldi	r24, 0xF1	; 241
    b0e2:	93 e0       	ldi	r25, 0x03	; 3
    b0e4:	9f bb       	out	0x1f, r25	; 31
    b0e6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b0e8:	e0 9a       	sbi	0x1c, 0	; 28
    b0ea:	8d b3       	in	r24, 0x1d	; 29
    b0ec:	c0 eb       	ldi	r28, 0xB0	; 176
    b0ee:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b0f0:	81 30       	cpi	r24, 0x01	; 1
    b0f2:	a9 f4       	brne	.+42     	; 0xb11e <PrintIdle+0x568>
			   	   CarriegeReturn();
    b0f4:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
    b0f8:	00 d0       	rcall	.+0      	; 0xb0fa <PrintIdle+0x544>
    b0fa:	00 d0       	rcall	.+0      	; 0xb0fc <PrintIdle+0x546>
    b0fc:	00 d0       	rcall	.+0      	; 0xb0fe <PrintIdle+0x548>
    b0fe:	ed b7       	in	r30, 0x3d	; 61
    b100:	fe b7       	in	r31, 0x3e	; 62
    b102:	31 96       	adiw	r30, 0x01	; 1
    b104:	ad b7       	in	r26, 0x3d	; 61
    b106:	be b7       	in	r27, 0x3e	; 62
    b108:	12 96       	adiw	r26, 0x02	; 2
    b10a:	dc 93       	st	X, r29
    b10c:	ce 93       	st	-X, r28
    b10e:	11 97       	sbiw	r26, 0x01	; 1
    b110:	8c ea       	ldi	r24, 0xAC	; 172
    b112:	99 e0       	ldi	r25, 0x09	; 9
    b114:	93 83       	std	Z+3, r25	; 0x03
    b116:	82 83       	std	Z+2, r24	; 0x02
    b118:	86 eb       	ldi	r24, 0xB6	; 182
    b11a:	9d e0       	ldi	r25, 0x0D	; 13
    b11c:	0a c3       	rjmp	.+1556   	; 0xb732 <PrintIdle+0xb7c>
			   }else sprintf_P(strPrint,PSTR(""));
    b11e:	00 d0       	rcall	.+0      	; 0xb120 <PrintIdle+0x56a>
    b120:	00 d0       	rcall	.+0      	; 0xb122 <PrintIdle+0x56c>
    b122:	ad b7       	in	r26, 0x3d	; 61
    b124:	be b7       	in	r27, 0x3e	; 62
    b126:	12 96       	adiw	r26, 0x02	; 2
    b128:	dc 93       	st	X, r29
    b12a:	ce 93       	st	-X, r28
    b12c:	11 97       	sbiw	r26, 0x01	; 1
    b12e:	8b ea       	ldi	r24, 0xAB	; 171
    b130:	99 e0       	ldi	r25, 0x09	; 9
    b132:	1a c3       	rjmp	.+1588   	; 0xb768 <PrintIdle+0xbb2>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
    b134:	cd ef       	ldi	r28, 0xFD	; 253
    b136:	da e0       	ldi	r29, 0x0A	; 10
    b138:	80 91 fd 0a 	lds	r24, 0x0AFD
    b13c:	88 23       	and	r24, r24
    b13e:	09 f4       	brne	.+2      	; 0xb142 <PrintIdle+0x58c>
    b140:	18 c2       	rjmp	.+1072   	; 0xb572 <PrintIdle+0x9bc>
    b142:	ce 01       	movw	r24, r28
    b144:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    b148:	88 23       	and	r24, r24
    b14a:	09 f0       	breq	.+2      	; 0xb14e <PrintIdle+0x598>
    b14c:	12 c2       	rjmp	.+1060   	; 0xb572 <PrintIdle+0x9bc>
			       CarriegeReturn();
    b14e:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
    b152:	00 d0       	rcall	.+0      	; 0xb154 <PrintIdle+0x59e>
    b154:	00 d0       	rcall	.+0      	; 0xb156 <PrintIdle+0x5a0>
    b156:	00 d0       	rcall	.+0      	; 0xb158 <PrintIdle+0x5a2>
    b158:	ed b7       	in	r30, 0x3d	; 61
    b15a:	fe b7       	in	r31, 0x3e	; 62
    b15c:	31 96       	adiw	r30, 0x01	; 1
    b15e:	80 eb       	ldi	r24, 0xB0	; 176
    b160:	92 e0       	ldi	r25, 0x02	; 2
    b162:	ad b7       	in	r26, 0x3d	; 61
    b164:	be b7       	in	r27, 0x3e	; 62
    b166:	12 96       	adiw	r26, 0x02	; 2
    b168:	9c 93       	st	X, r25
    b16a:	8e 93       	st	-X, r24
    b16c:	11 97       	sbiw	r26, 0x01	; 1
    b16e:	84 e9       	ldi	r24, 0x94	; 148
    b170:	99 e0       	ldi	r25, 0x09	; 9
    b172:	1f c0       	rjmp	.+62     	; 0xb1b2 <PrintIdle+0x5fc>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
    b174:	c8 ec       	ldi	r28, 0xC8	; 200
    b176:	d5 e0       	ldi	r29, 0x05	; 5
    b178:	80 91 c8 05 	lds	r24, 0x05C8
    b17c:	88 23       	and	r24, r24
    b17e:	09 f4       	brne	.+2      	; 0xb182 <PrintIdle+0x5cc>
    b180:	f8 c1       	rjmp	.+1008   	; 0xb572 <PrintIdle+0x9bc>
    b182:	ce 01       	movw	r24, r28
    b184:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    b188:	88 23       	and	r24, r24
    b18a:	09 f0       	breq	.+2      	; 0xb18e <PrintIdle+0x5d8>
    b18c:	f2 c1       	rjmp	.+996    	; 0xb572 <PrintIdle+0x9bc>
			       CarriegeReturn();
    b18e:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
    b192:	00 d0       	rcall	.+0      	; 0xb194 <PrintIdle+0x5de>
    b194:	00 d0       	rcall	.+0      	; 0xb196 <PrintIdle+0x5e0>
    b196:	00 d0       	rcall	.+0      	; 0xb198 <PrintIdle+0x5e2>
    b198:	ed b7       	in	r30, 0x3d	; 61
    b19a:	fe b7       	in	r31, 0x3e	; 62
    b19c:	31 96       	adiw	r30, 0x01	; 1
    b19e:	80 eb       	ldi	r24, 0xB0	; 176
    b1a0:	92 e0       	ldi	r25, 0x02	; 2
    b1a2:	ad b7       	in	r26, 0x3d	; 61
    b1a4:	be b7       	in	r27, 0x3e	; 62
    b1a6:	12 96       	adiw	r26, 0x02	; 2
    b1a8:	9c 93       	st	X, r25
    b1aa:	8e 93       	st	-X, r24
    b1ac:	11 97       	sbiw	r26, 0x01	; 1
    b1ae:	8d e7       	ldi	r24, 0x7D	; 125
    b1b0:	99 e0       	ldi	r25, 0x09	; 9
    b1b2:	93 83       	std	Z+3, r25	; 0x03
    b1b4:	82 83       	std	Z+2, r24	; 0x02
    b1b6:	d5 83       	std	Z+5, r29	; 0x05
    b1b8:	c4 83       	std	Z+4, r28	; 0x04
    b1ba:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				   ClearMem(strOdometer);
    b1be:	ed b7       	in	r30, 0x3d	; 61
    b1c0:	fe b7       	in	r31, 0x3e	; 62
    b1c2:	36 96       	adiw	r30, 0x06	; 6
    b1c4:	0f b6       	in	r0, 0x3f	; 63
    b1c6:	f8 94       	cli
    b1c8:	fe bf       	out	0x3e, r31	; 62
    b1ca:	0f be       	out	0x3f, r0	; 63
    b1cc:	ed bf       	out	0x3d, r30	; 61
    b1ce:	ce 01       	movw	r24, r28
    b1d0:	0e 94 5c ad 	call	0x15ab8	; 0x15ab8 <ClearMem>
    b1d4:	d3 c2       	rjmp	.+1446   	; 0xb77c <PrintIdle+0xbc6>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
    b1d6:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b1da:	00 d0       	rcall	.+0      	; 0xb1dc <PrintIdle+0x626>
    b1dc:	00 d0       	rcall	.+0      	; 0xb1de <PrintIdle+0x628>
    b1de:	80 eb       	ldi	r24, 0xB0	; 176
    b1e0:	92 e0       	ldi	r25, 0x02	; 2
    b1e2:	ad b7       	in	r26, 0x3d	; 61
    b1e4:	be b7       	in	r27, 0x3e	; 62
    b1e6:	12 96       	adiw	r26, 0x02	; 2
    b1e8:	9c 93       	st	X, r25
    b1ea:	8e 93       	st	-X, r24
    b1ec:	11 97       	sbiw	r26, 0x01	; 1
    b1ee:	8a e5       	ldi	r24, 0x5A	; 90
    b1f0:	99 e0       	ldi	r25, 0x09	; 9
    b1f2:	ba c2       	rjmp	.+1396   	; 0xb768 <PrintIdle+0xbb2>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
    b1f4:	80 91 e5 01 	lds	r24, 0x01E5
    b1f8:	81 30       	cpi	r24, 0x01	; 1
    b1fa:	21 f0       	breq	.+8      	; 0xb204 <PrintIdle+0x64e>
    b1fc:	83 30       	cpi	r24, 0x03	; 3
    b1fe:	11 f0       	breq	.+4      	; 0xb204 <PrintIdle+0x64e>
    b200:	86 30       	cpi	r24, 0x06	; 6
    b202:	b9 f4       	brne	.+46     	; 0xb232 <PrintIdle+0x67c>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b204:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
    b208:	00 d0       	rcall	.+0      	; 0xb20a <PrintIdle+0x654>
    b20a:	00 d0       	rcall	.+0      	; 0xb20c <PrintIdle+0x656>
    b20c:	00 d0       	rcall	.+0      	; 0xb20e <PrintIdle+0x658>
    b20e:	ed b7       	in	r30, 0x3d	; 61
    b210:	fe b7       	in	r31, 0x3e	; 62
    b212:	31 96       	adiw	r30, 0x01	; 1
    b214:	80 eb       	ldi	r24, 0xB0	; 176
    b216:	92 e0       	ldi	r25, 0x02	; 2
    b218:	ad b7       	in	r26, 0x3d	; 61
    b21a:	be b7       	in	r27, 0x3e	; 62
    b21c:	12 96       	adiw	r26, 0x02	; 2
    b21e:	9c 93       	st	X, r25
    b220:	8e 93       	st	-X, r24
    b222:	11 97       	sbiw	r26, 0x01	; 1
    b224:	88 e4       	ldi	r24, 0x48	; 72
    b226:	99 e0       	ldi	r25, 0x09	; 9
    b228:	93 83       	std	Z+3, r25	; 0x03
    b22a:	82 83       	std	Z+2, r24	; 0x02
    b22c:	8c e8       	ldi	r24, 0x8C	; 140
    b22e:	9d e0       	ldi	r25, 0x0D	; 13
    b230:	18 c0       	rjmp	.+48     	; 0xb262 <PrintIdle+0x6ac>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
    b232:	87 30       	cpi	r24, 0x07	; 7
    b234:	f1 f4       	brne	.+60     	; 0xb272 <PrintIdle+0x6bc>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b236:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
    b23a:	00 d0       	rcall	.+0      	; 0xb23c <PrintIdle+0x686>
    b23c:	00 d0       	rcall	.+0      	; 0xb23e <PrintIdle+0x688>
    b23e:	00 d0       	rcall	.+0      	; 0xb240 <PrintIdle+0x68a>
    b240:	ed b7       	in	r30, 0x3d	; 61
    b242:	fe b7       	in	r31, 0x3e	; 62
    b244:	31 96       	adiw	r30, 0x01	; 1
    b246:	80 eb       	ldi	r24, 0xB0	; 176
    b248:	92 e0       	ldi	r25, 0x02	; 2
    b24a:	ad b7       	in	r26, 0x3d	; 61
    b24c:	be b7       	in	r27, 0x3e	; 62
    b24e:	12 96       	adiw	r26, 0x02	; 2
    b250:	9c 93       	st	X, r25
    b252:	8e 93       	st	-X, r24
    b254:	11 97       	sbiw	r26, 0x01	; 1
    b256:	85 e3       	ldi	r24, 0x35	; 53
    b258:	99 e0       	ldi	r25, 0x09	; 9
    b25a:	93 83       	std	Z+3, r25	; 0x03
    b25c:	82 83       	std	Z+2, r24	; 0x02
    b25e:	82 e4       	ldi	r24, 0x42	; 66
    b260:	9e e0       	ldi	r25, 0x0E	; 14
    b262:	95 83       	std	Z+5, r25	; 0x05
    b264:	84 83       	std	Z+4, r24	; 0x04
    b266:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				   IsSignedField=True;
    b26a:	81 e0       	ldi	r24, 0x01	; 1
    b26c:	80 93 ad 02 	sts	0x02AD, r24
    b270:	64 c2       	rjmp	.+1224   	; 0xb73a <PrintIdle+0xb84>
    b272:	c0 eb       	ldi	r28, 0xB0	; 176
    b274:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b276:	88 30       	cpi	r24, 0x08	; 8
    b278:	09 f0       	breq	.+2      	; 0xb27c <PrintIdle+0x6c6>
    b27a:	a9 cf       	rjmp	.-174    	; 0xb1ce <PrintIdle+0x618>
			       CarriegeReturn();
    b27c:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
    b280:	00 d0       	rcall	.+0      	; 0xb282 <PrintIdle+0x6cc>
    b282:	00 d0       	rcall	.+0      	; 0xb284 <PrintIdle+0x6ce>
    b284:	ad b7       	in	r26, 0x3d	; 61
    b286:	be b7       	in	r27, 0x3e	; 62
    b288:	12 96       	adiw	r26, 0x02	; 2
    b28a:	dc 93       	st	X, r29
    b28c:	ce 93       	st	-X, r28
    b28e:	11 97       	sbiw	r26, 0x01	; 1
    b290:	82 e1       	ldi	r24, 0x12	; 18
    b292:	99 e0       	ldi	r25, 0x09	; 9
    b294:	14 96       	adiw	r26, 0x04	; 4
    b296:	9c 93       	st	X, r25
    b298:	8e 93       	st	-X, r24
    b29a:	13 97       	sbiw	r26, 0x03	; 3
    b29c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				   IsSignedField=False;
    b2a0:	10 92 ad 02 	sts	0x02AD, r1
    b2a4:	67 c2       	rjmp	.+1230   	; 0xb774 <PrintIdle+0xbbe>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
    b2a6:	80 91 e5 01 	lds	r24, 0x01E5
    b2aa:	81 30       	cpi	r24, 0x01	; 1
    b2ac:	99 f4       	brne	.+38     	; 0xb2d4 <PrintIdle+0x71e>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b2ae:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
    b2b2:	00 d0       	rcall	.+0      	; 0xb2b4 <PrintIdle+0x6fe>
    b2b4:	00 d0       	rcall	.+0      	; 0xb2b6 <PrintIdle+0x700>
    b2b6:	00 d0       	rcall	.+0      	; 0xb2b8 <PrintIdle+0x702>
    b2b8:	ed b7       	in	r30, 0x3d	; 61
    b2ba:	fe b7       	in	r31, 0x3e	; 62
    b2bc:	31 96       	adiw	r30, 0x01	; 1
    b2be:	80 eb       	ldi	r24, 0xB0	; 176
    b2c0:	92 e0       	ldi	r25, 0x02	; 2
    b2c2:	ad b7       	in	r26, 0x3d	; 61
    b2c4:	be b7       	in	r27, 0x3e	; 62
    b2c6:	12 96       	adiw	r26, 0x02	; 2
    b2c8:	9c 93       	st	X, r25
    b2ca:	8e 93       	st	-X, r24
    b2cc:	11 97       	sbiw	r26, 0x01	; 1
    b2ce:	80 e0       	ldi	r24, 0x00	; 0
    b2d0:	99 e0       	ldi	r25, 0x09	; 9
    b2d2:	3a c0       	rjmp	.+116    	; 0xb348 <PrintIdle+0x792>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
    b2d4:	83 30       	cpi	r24, 0x03	; 3
    b2d6:	e9 f5       	brne	.+122    	; 0xb352 <PrintIdle+0x79c>
			       if (IsPrintApprovalCode==True){
    b2d8:	80 91 c6 01 	lds	r24, 0x01C6
    b2dc:	81 30       	cpi	r24, 0x01	; 1
    b2de:	11 f5       	brne	.+68     	; 0xb324 <PrintIdle+0x76e>
				       IsPrintApprovalCode=False;
    b2e0:	10 92 c6 01 	sts	0x01C6, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
    b2e4:	00 d0       	rcall	.+0      	; 0xb2e6 <PrintIdle+0x730>
    b2e6:	00 d0       	rcall	.+0      	; 0xb2e8 <PrintIdle+0x732>
    b2e8:	00 d0       	rcall	.+0      	; 0xb2ea <PrintIdle+0x734>
    b2ea:	ed b7       	in	r30, 0x3d	; 61
    b2ec:	fe b7       	in	r31, 0x3e	; 62
    b2ee:	31 96       	adiw	r30, 0x01	; 1
    b2f0:	89 e2       	ldi	r24, 0x29	; 41
    b2f2:	95 e0       	ldi	r25, 0x05	; 5
    b2f4:	ad b7       	in	r26, 0x3d	; 61
    b2f6:	be b7       	in	r27, 0x3e	; 62
    b2f8:	12 96       	adiw	r26, 0x02	; 2
    b2fa:	9c 93       	st	X, r25
    b2fc:	8e 93       	st	-X, r24
    b2fe:	11 97       	sbiw	r26, 0x01	; 1
    b300:	8b ef       	ldi	r24, 0xFB	; 251
    b302:	98 e0       	ldi	r25, 0x08	; 8
    b304:	93 83       	std	Z+3, r25	; 0x03
    b306:	82 83       	std	Z+2, r24	; 0x02
    b308:	8b e0       	ldi	r24, 0x0B	; 11
    b30a:	9a e0       	ldi	r25, 0x0A	; 10
    b30c:	95 83       	std	Z+5, r25	; 0x05
    b30e:	84 83       	std	Z+4, r24	; 0x04
    b310:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    b314:	ed b7       	in	r30, 0x3d	; 61
    b316:	fe b7       	in	r31, 0x3e	; 62
    b318:	36 96       	adiw	r30, 0x06	; 6
    b31a:	0f b6       	in	r0, 0x3f	; 63
    b31c:	f8 94       	cli
    b31e:	fe bf       	out	0x3e, r31	; 62
    b320:	0f be       	out	0x3f, r0	; 63
    b322:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b324:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
    b328:	00 d0       	rcall	.+0      	; 0xb32a <PrintIdle+0x774>
    b32a:	00 d0       	rcall	.+0      	; 0xb32c <PrintIdle+0x776>
    b32c:	00 d0       	rcall	.+0      	; 0xb32e <PrintIdle+0x778>
    b32e:	ed b7       	in	r30, 0x3d	; 61
    b330:	fe b7       	in	r31, 0x3e	; 62
    b332:	31 96       	adiw	r30, 0x01	; 1
    b334:	80 eb       	ldi	r24, 0xB0	; 176
    b336:	92 e0       	ldi	r25, 0x02	; 2
    b338:	ad b7       	in	r26, 0x3d	; 61
    b33a:	be b7       	in	r27, 0x3e	; 62
    b33c:	12 96       	adiw	r26, 0x02	; 2
    b33e:	9c 93       	st	X, r25
    b340:	8e 93       	st	-X, r24
    b342:	11 97       	sbiw	r26, 0x01	; 1
    b344:	89 ee       	ldi	r24, 0xE9	; 233
    b346:	98 e0       	ldi	r25, 0x08	; 8
    b348:	93 83       	std	Z+3, r25	; 0x03
    b34a:	82 83       	std	Z+2, r24	; 0x02
    b34c:	89 e2       	ldi	r24, 0x29	; 41
    b34e:	95 e0       	ldi	r25, 0x05	; 5
    b350:	f0 c1       	rjmp	.+992    	; 0xb732 <PrintIdle+0xb7c>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
    b352:	87 30       	cpi	r24, 0x07	; 7
    b354:	79 f4       	brne	.+30     	; 0xb374 <PrintIdle+0x7be>
			       CarriegeReturn();
    b356:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
    b35a:	00 d0       	rcall	.+0      	; 0xb35c <PrintIdle+0x7a6>
    b35c:	00 d0       	rcall	.+0      	; 0xb35e <PrintIdle+0x7a8>
    b35e:	80 eb       	ldi	r24, 0xB0	; 176
    b360:	92 e0       	ldi	r25, 0x02	; 2
    b362:	ad b7       	in	r26, 0x3d	; 61
    b364:	be b7       	in	r27, 0x3e	; 62
    b366:	12 96       	adiw	r26, 0x02	; 2
    b368:	9c 93       	st	X, r25
    b36a:	8e 93       	st	-X, r24
    b36c:	11 97       	sbiw	r26, 0x01	; 1
    b36e:	86 ee       	ldi	r24, 0xE6	; 230
    b370:	98 e0       	ldi	r25, 0x08	; 8
    b372:	fa c1       	rjmp	.+1012   	; 0xb768 <PrintIdle+0xbb2>
    b374:	c0 eb       	ldi	r28, 0xB0	; 176
    b376:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b378:	88 30       	cpi	r24, 0x08	; 8
    b37a:	09 f0       	breq	.+2      	; 0xb37e <PrintIdle+0x7c8>
    b37c:	28 cf       	rjmp	.-432    	; 0xb1ce <PrintIdle+0x618>
			       CarriegeReturn();
    b37e:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
    b382:	00 d0       	rcall	.+0      	; 0xb384 <PrintIdle+0x7ce>
    b384:	00 d0       	rcall	.+0      	; 0xb386 <PrintIdle+0x7d0>
    b386:	ed b7       	in	r30, 0x3d	; 61
    b388:	fe b7       	in	r31, 0x3e	; 62
    b38a:	d2 83       	std	Z+2, r29	; 0x02
    b38c:	c1 83       	std	Z+1, r28	; 0x01
    b38e:	84 ed       	ldi	r24, 0xD4	; 212
    b390:	98 e0       	ldi	r25, 0x08	; 8
    b392:	25 c0       	rjmp	.+74     	; 0xb3de <PrintIdle+0x828>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
    b394:	80 91 ad 02 	lds	r24, 0x02AD
    b398:	c0 eb       	ldi	r28, 0xB0	; 176
    b39a:	d2 e0       	ldi	r29, 0x02	; 2
    b39c:	81 30       	cpi	r24, 0x01	; 1
    b39e:	09 f0       	breq	.+2      	; 0xb3a2 <PrintIdle+0x7ec>
    b3a0:	16 cf       	rjmp	.-468    	; 0xb1ce <PrintIdle+0x618>
			       CarriegeReturn();
    b3a2:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b3a6:	00 d0       	rcall	.+0      	; 0xb3a8 <PrintIdle+0x7f2>
    b3a8:	00 d0       	rcall	.+0      	; 0xb3aa <PrintIdle+0x7f4>
    b3aa:	ad b7       	in	r26, 0x3d	; 61
    b3ac:	be b7       	in	r27, 0x3e	; 62
    b3ae:	12 96       	adiw	r26, 0x02	; 2
    b3b0:	dc 93       	st	X, r29
    b3b2:	ce 93       	st	-X, r28
    b3b4:	11 97       	sbiw	r26, 0x01	; 1
    b3b6:	8d eb       	ldi	r24, 0xBD	; 189
    b3b8:	98 e0       	ldi	r25, 0x08	; 8
    b3ba:	d6 c1       	rjmp	.+940    	; 0xb768 <PrintIdle+0xbb2>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
    b3bc:	80 91 ad 02 	lds	r24, 0x02AD
    b3c0:	c0 eb       	ldi	r28, 0xB0	; 176
    b3c2:	d2 e0       	ldi	r29, 0x02	; 2
    b3c4:	81 30       	cpi	r24, 0x01	; 1
    b3c6:	09 f0       	breq	.+2      	; 0xb3ca <PrintIdle+0x814>
    b3c8:	02 cf       	rjmp	.-508    	; 0xb1ce <PrintIdle+0x618>
			       CarriegeReturn();
    b3ca:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b3ce:	00 d0       	rcall	.+0      	; 0xb3d0 <PrintIdle+0x81a>
    b3d0:	00 d0       	rcall	.+0      	; 0xb3d2 <PrintIdle+0x81c>
    b3d2:	ed b7       	in	r30, 0x3d	; 61
    b3d4:	fe b7       	in	r31, 0x3e	; 62
    b3d6:	d2 83       	std	Z+2, r29	; 0x02
    b3d8:	c1 83       	std	Z+1, r28	; 0x01
    b3da:	86 ea       	ldi	r24, 0xA6	; 166
    b3dc:	98 e0       	ldi	r25, 0x08	; 8
    b3de:	94 83       	std	Z+4, r25	; 0x04
    b3e0:	83 83       	std	Z+3, r24	; 0x03
    b3e2:	c6 c1       	rjmp	.+908    	; 0xb770 <PrintIdle+0xbba>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
    b3e4:	80 91 ad 02 	lds	r24, 0x02AD
    b3e8:	c0 eb       	ldi	r28, 0xB0	; 176
    b3ea:	d2 e0       	ldi	r29, 0x02	; 2
    b3ec:	81 30       	cpi	r24, 0x01	; 1
    b3ee:	09 f0       	breq	.+2      	; 0xb3f2 <PrintIdle+0x83c>
    b3f0:	ee ce       	rjmp	.-548    	; 0xb1ce <PrintIdle+0x618>
			       CarriegeReturn();
    b3f2:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
    b3f6:	00 d0       	rcall	.+0      	; 0xb3f8 <PrintIdle+0x842>
    b3f8:	00 d0       	rcall	.+0      	; 0xb3fa <PrintIdle+0x844>
    b3fa:	ad b7       	in	r26, 0x3d	; 61
    b3fc:	be b7       	in	r27, 0x3e	; 62
    b3fe:	12 96       	adiw	r26, 0x02	; 2
    b400:	dc 93       	st	X, r29
    b402:	ce 93       	st	-X, r28
    b404:	11 97       	sbiw	r26, 0x01	; 1
    b406:	83 e8       	ldi	r24, 0x83	; 131
    b408:	98 e0       	ldi	r25, 0x08	; 8
    b40a:	ae c1       	rjmp	.+860    	; 0xb768 <PrintIdle+0xbb2>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
    b40c:	80 91 ad 02 	lds	r24, 0x02AD
    b410:	81 30       	cpi	r24, 0x01	; 1
    b412:	09 f0       	breq	.+2      	; 0xb416 <PrintIdle+0x860>
    b414:	ae c0       	rjmp	.+348    	; 0xb572 <PrintIdle+0x9bc>
			       IsSignedField=False;
    b416:	10 92 ad 02 	sts	0x02AD, r1
    b41a:	ab c0       	rjmp	.+342    	; 0xb572 <PrintIdle+0x9bc>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
    b41c:	80 91 e5 01 	lds	r24, 0x01E5
    b420:	c0 eb       	ldi	r28, 0xB0	; 176
    b422:	d2 e0       	ldi	r29, 0x02	; 2
    b424:	88 23       	and	r24, r24
    b426:	09 f4       	brne	.+2      	; 0xb42a <PrintIdle+0x874>
    b428:	d2 ce       	rjmp	.-604    	; 0xb1ce <PrintIdle+0x618>
			       CarriegeReturn();
    b42a:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
    b42e:	00 d0       	rcall	.+0      	; 0xb430 <PrintIdle+0x87a>
    b430:	00 d0       	rcall	.+0      	; 0xb432 <PrintIdle+0x87c>
    b432:	00 d0       	rcall	.+0      	; 0xb434 <PrintIdle+0x87e>
    b434:	ed b7       	in	r30, 0x3d	; 61
    b436:	fe b7       	in	r31, 0x3e	; 62
    b438:	31 96       	adiw	r30, 0x01	; 1
    b43a:	ad b7       	in	r26, 0x3d	; 61
    b43c:	be b7       	in	r27, 0x3e	; 62
    b43e:	12 96       	adiw	r26, 0x02	; 2
    b440:	dc 93       	st	X, r29
    b442:	ce 93       	st	-X, r28
    b444:	11 97       	sbiw	r26, 0x01	; 1
    b446:	8b e7       	ldi	r24, 0x7B	; 123
    b448:	98 e0       	ldi	r25, 0x08	; 8
    b44a:	93 83       	std	Z+3, r25	; 0x03
    b44c:	82 83       	std	Z+2, r24	; 0x02
    b44e:	87 e8       	ldi	r24, 0x87	; 135
    b450:	97 e0       	ldi	r25, 0x07	; 7
    b452:	6f c1       	rjmp	.+734    	; 0xb732 <PrintIdle+0xb7c>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
    b454:	80 91 e5 01 	lds	r24, 0x01E5
    b458:	c0 eb       	ldi	r28, 0xB0	; 176
    b45a:	d2 e0       	ldi	r29, 0x02	; 2
    b45c:	88 23       	and	r24, r24
    b45e:	09 f4       	brne	.+2      	; 0xb462 <PrintIdle+0x8ac>
    b460:	b6 ce       	rjmp	.-660    	; 0xb1ce <PrintIdle+0x618>
			       CarriegeReturn();
    b462:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
    b466:	00 d0       	rcall	.+0      	; 0xb468 <PrintIdle+0x8b2>
    b468:	00 d0       	rcall	.+0      	; 0xb46a <PrintIdle+0x8b4>
    b46a:	ad b7       	in	r26, 0x3d	; 61
    b46c:	be b7       	in	r27, 0x3e	; 62
    b46e:	12 96       	adiw	r26, 0x02	; 2
    b470:	dc 93       	st	X, r29
    b472:	ce 93       	st	-X, r28
    b474:	11 97       	sbiw	r26, 0x01	; 1
    b476:	88 e5       	ldi	r24, 0x58	; 88
    b478:	98 e0       	ldi	r25, 0x08	; 8
    b47a:	76 c1       	rjmp	.+748    	; 0xb768 <PrintIdle+0xbb2>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
    b47c:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
    b480:	00 d0       	rcall	.+0      	; 0xb482 <PrintIdle+0x8cc>
    b482:	00 d0       	rcall	.+0      	; 0xb484 <PrintIdle+0x8ce>
    b484:	80 eb       	ldi	r24, 0xB0	; 176
    b486:	92 e0       	ldi	r25, 0x02	; 2
    b488:	ed b7       	in	r30, 0x3d	; 61
    b48a:	fe b7       	in	r31, 0x3e	; 62
    b48c:	92 83       	std	Z+2, r25	; 0x02
    b48e:	81 83       	std	Z+1, r24	; 0x01
    b490:	85 e3       	ldi	r24, 0x35	; 53
    b492:	98 e0       	ldi	r25, 0x08	; 8
    b494:	a4 cf       	rjmp	.-184    	; 0xb3de <PrintIdle+0x828>
		       break; 			            
		  case 22:
		       CarriegeReturn();
    b496:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
    b49a:	00 d0       	rcall	.+0      	; 0xb49c <PrintIdle+0x8e6>
    b49c:	00 d0       	rcall	.+0      	; 0xb49e <PrintIdle+0x8e8>
    b49e:	00 d0       	rcall	.+0      	; 0xb4a0 <PrintIdle+0x8ea>
    b4a0:	ed b7       	in	r30, 0x3d	; 61
    b4a2:	fe b7       	in	r31, 0x3e	; 62
    b4a4:	31 96       	adiw	r30, 0x01	; 1
    b4a6:	80 eb       	ldi	r24, 0xB0	; 176
    b4a8:	92 e0       	ldi	r25, 0x02	; 2
    b4aa:	ad b7       	in	r26, 0x3d	; 61
    b4ac:	be b7       	in	r27, 0x3e	; 62
    b4ae:	12 96       	adiw	r26, 0x02	; 2
    b4b0:	9c 93       	st	X, r25
    b4b2:	8e 93       	st	-X, r24
    b4b4:	11 97       	sbiw	r26, 0x01	; 1
    b4b6:	8e e1       	ldi	r24, 0x1E	; 30
    b4b8:	98 e0       	ldi	r25, 0x08	; 8
    b4ba:	93 83       	std	Z+3, r25	; 0x03
    b4bc:	82 83       	std	Z+2, r24	; 0x02
    b4be:	8c ee       	ldi	r24, 0xEC	; 236
    b4c0:	94 e0       	ldi	r25, 0x04	; 4
    b4c2:	37 c1       	rjmp	.+622    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 23:
		       CarriegeReturn();
    b4c4:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
    b4c8:	00 d0       	rcall	.+0      	; 0xb4ca <PrintIdle+0x914>
    b4ca:	00 d0       	rcall	.+0      	; 0xb4cc <PrintIdle+0x916>
    b4cc:	00 d0       	rcall	.+0      	; 0xb4ce <PrintIdle+0x918>
    b4ce:	ed b7       	in	r30, 0x3d	; 61
    b4d0:	fe b7       	in	r31, 0x3e	; 62
    b4d2:	31 96       	adiw	r30, 0x01	; 1
    b4d4:	80 eb       	ldi	r24, 0xB0	; 176
    b4d6:	92 e0       	ldi	r25, 0x02	; 2
    b4d8:	ad b7       	in	r26, 0x3d	; 61
    b4da:	be b7       	in	r27, 0x3e	; 62
    b4dc:	12 96       	adiw	r26, 0x02	; 2
    b4de:	9c 93       	st	X, r25
    b4e0:	8e 93       	st	-X, r24
    b4e2:	11 97       	sbiw	r26, 0x01	; 1
    b4e4:	86 e0       	ldi	r24, 0x06	; 6
    b4e6:	98 e0       	ldi	r25, 0x08	; 8
    b4e8:	93 83       	std	Z+3, r25	; 0x03
    b4ea:	82 83       	std	Z+2, r24	; 0x02
    b4ec:	89 ec       	ldi	r24, 0xC9	; 201
    b4ee:	94 e0       	ldi	r25, 0x04	; 4
    b4f0:	20 c1       	rjmp	.+576    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
    b4f2:	c0 e1       	ldi	r28, 0x10	; 16
    b4f4:	de e0       	ldi	r29, 0x0E	; 14
    b4f6:	80 91 10 0e 	lds	r24, 0x0E10
    b4fa:	88 23       	and	r24, r24
    b4fc:	d1 f1       	breq	.+116    	; 0xb572 <PrintIdle+0x9bc>
    b4fe:	ce 01       	movw	r24, r28
    b500:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    b504:	88 23       	and	r24, r24
    b506:	a9 f5       	brne	.+106    	; 0xb572 <PrintIdle+0x9bc>
		           CarriegeReturn();
    b508:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
    b50c:	00 d0       	rcall	.+0      	; 0xb50e <PrintIdle+0x958>
    b50e:	00 d0       	rcall	.+0      	; 0xb510 <PrintIdle+0x95a>
    b510:	00 d0       	rcall	.+0      	; 0xb512 <PrintIdle+0x95c>
    b512:	ed b7       	in	r30, 0x3d	; 61
    b514:	fe b7       	in	r31, 0x3e	; 62
    b516:	31 96       	adiw	r30, 0x01	; 1
    b518:	80 eb       	ldi	r24, 0xB0	; 176
    b51a:	92 e0       	ldi	r25, 0x02	; 2
    b51c:	ad b7       	in	r26, 0x3d	; 61
    b51e:	be b7       	in	r27, 0x3e	; 62
    b520:	12 96       	adiw	r26, 0x02	; 2
    b522:	9c 93       	st	X, r25
    b524:	8e 93       	st	-X, r24
    b526:	11 97       	sbiw	r26, 0x01	; 1
    b528:	8f ee       	ldi	r24, 0xEF	; 239
    b52a:	97 e0       	ldi	r25, 0x07	; 7
    b52c:	1d c0       	rjmp	.+58     	; 0xb568 <PrintIdle+0x9b2>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
    b52e:	c2 ed       	ldi	r28, 0xD2	; 210
    b530:	d5 e0       	ldi	r29, 0x05	; 5
    b532:	80 91 d2 05 	lds	r24, 0x05D2
    b536:	88 23       	and	r24, r24
    b538:	e1 f0       	breq	.+56     	; 0xb572 <PrintIdle+0x9bc>
    b53a:	ce 01       	movw	r24, r28
    b53c:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    b540:	88 23       	and	r24, r24
    b542:	b9 f4       	brne	.+46     	; 0xb572 <PrintIdle+0x9bc>
		           CarriegeReturn();
    b544:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
    b548:	00 d0       	rcall	.+0      	; 0xb54a <PrintIdle+0x994>
    b54a:	00 d0       	rcall	.+0      	; 0xb54c <PrintIdle+0x996>
    b54c:	00 d0       	rcall	.+0      	; 0xb54e <PrintIdle+0x998>
    b54e:	ed b7       	in	r30, 0x3d	; 61
    b550:	fe b7       	in	r31, 0x3e	; 62
    b552:	31 96       	adiw	r30, 0x01	; 1
    b554:	80 eb       	ldi	r24, 0xB0	; 176
    b556:	92 e0       	ldi	r25, 0x02	; 2
    b558:	ad b7       	in	r26, 0x3d	; 61
    b55a:	be b7       	in	r27, 0x3e	; 62
    b55c:	12 96       	adiw	r26, 0x02	; 2
    b55e:	9c 93       	st	X, r25
    b560:	8e 93       	st	-X, r24
    b562:	11 97       	sbiw	r26, 0x01	; 1
    b564:	88 ed       	ldi	r24, 0xD8	; 216
    b566:	97 e0       	ldi	r25, 0x07	; 7
    b568:	93 83       	std	Z+3, r25	; 0x03
    b56a:	82 83       	std	Z+2, r24	; 0x02
    b56c:	d5 83       	std	Z+5, r29	; 0x05
    b56e:	c4 83       	std	Z+4, r28	; 0x04
    b570:	e2 c0       	rjmp	.+452    	; 0xb736 <PrintIdle+0xb80>
			   }else ClearMem(strPrint);
    b572:	80 eb       	ldi	r24, 0xB0	; 176
    b574:	92 e0       	ldi	r25, 0x02	; 2
    b576:	2c ce       	rjmp	.-936    	; 0xb1d0 <PrintIdle+0x61a>
		       break;
		  case 26:
		       CarriegeReturn();
    b578:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
    b57c:	00 d0       	rcall	.+0      	; 0xb57e <PrintIdle+0x9c8>
    b57e:	00 d0       	rcall	.+0      	; 0xb580 <PrintIdle+0x9ca>
    b580:	00 d0       	rcall	.+0      	; 0xb582 <PrintIdle+0x9cc>
    b582:	ed b7       	in	r30, 0x3d	; 61
    b584:	fe b7       	in	r31, 0x3e	; 62
    b586:	31 96       	adiw	r30, 0x01	; 1
    b588:	80 eb       	ldi	r24, 0xB0	; 176
    b58a:	92 e0       	ldi	r25, 0x02	; 2
    b58c:	ad b7       	in	r26, 0x3d	; 61
    b58e:	be b7       	in	r27, 0x3e	; 62
    b590:	12 96       	adiw	r26, 0x02	; 2
    b592:	9c 93       	st	X, r25
    b594:	8e 93       	st	-X, r24
    b596:	11 97       	sbiw	r26, 0x01	; 1
    b598:	81 ec       	ldi	r24, 0xC1	; 193
    b59a:	97 e0       	ldi	r25, 0x07	; 7
    b59c:	93 83       	std	Z+3, r25	; 0x03
    b59e:	82 83       	std	Z+2, r24	; 0x02
    b5a0:	80 ec       	ldi	r24, 0xC0	; 192
    b5a2:	94 e0       	ldi	r25, 0x04	; 4
    b5a4:	c6 c0       	rjmp	.+396    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 27:
		       CarriegeReturn();
    b5a6:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
    b5aa:	00 d0       	rcall	.+0      	; 0xb5ac <PrintIdle+0x9f6>
    b5ac:	00 d0       	rcall	.+0      	; 0xb5ae <PrintIdle+0x9f8>
    b5ae:	00 d0       	rcall	.+0      	; 0xb5b0 <PrintIdle+0x9fa>
    b5b0:	ed b7       	in	r30, 0x3d	; 61
    b5b2:	fe b7       	in	r31, 0x3e	; 62
    b5b4:	31 96       	adiw	r30, 0x01	; 1
    b5b6:	80 eb       	ldi	r24, 0xB0	; 176
    b5b8:	92 e0       	ldi	r25, 0x02	; 2
    b5ba:	ad b7       	in	r26, 0x3d	; 61
    b5bc:	be b7       	in	r27, 0x3e	; 62
    b5be:	12 96       	adiw	r26, 0x02	; 2
    b5c0:	9c 93       	st	X, r25
    b5c2:	8e 93       	st	-X, r24
    b5c4:	11 97       	sbiw	r26, 0x01	; 1
    b5c6:	8a ea       	ldi	r24, 0xAA	; 170
    b5c8:	97 e0       	ldi	r25, 0x07	; 7
    b5ca:	93 83       	std	Z+3, r25	; 0x03
    b5cc:	82 83       	std	Z+2, r24	; 0x02
    b5ce:	87 e1       	ldi	r24, 0x17	; 23
    b5d0:	9b e0       	ldi	r25, 0x0B	; 11
    b5d2:	af c0       	rjmp	.+350    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 28:
		       CarriegeReturn();
    b5d4:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
    b5d8:	00 d0       	rcall	.+0      	; 0xb5da <PrintIdle+0xa24>
    b5da:	00 d0       	rcall	.+0      	; 0xb5dc <PrintIdle+0xa26>
    b5dc:	00 d0       	rcall	.+0      	; 0xb5de <PrintIdle+0xa28>
    b5de:	ed b7       	in	r30, 0x3d	; 61
    b5e0:	fe b7       	in	r31, 0x3e	; 62
    b5e2:	31 96       	adiw	r30, 0x01	; 1
    b5e4:	80 eb       	ldi	r24, 0xB0	; 176
    b5e6:	92 e0       	ldi	r25, 0x02	; 2
    b5e8:	ad b7       	in	r26, 0x3d	; 61
    b5ea:	be b7       	in	r27, 0x3e	; 62
    b5ec:	12 96       	adiw	r26, 0x02	; 2
    b5ee:	9c 93       	st	X, r25
    b5f0:	8e 93       	st	-X, r24
    b5f2:	11 97       	sbiw	r26, 0x01	; 1
    b5f4:	83 e9       	ldi	r24, 0x93	; 147
    b5f6:	97 e0       	ldi	r25, 0x07	; 7
    b5f8:	93 83       	std	Z+3, r25	; 0x03
    b5fa:	82 83       	std	Z+2, r24	; 0x02
    b5fc:	81 e6       	ldi	r24, 0x61	; 97
    b5fe:	9a e0       	ldi	r25, 0x0A	; 10
    b600:	98 c0       	rjmp	.+304    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 29:
		       CarriegeReturn();
    b602:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
    b606:	00 d0       	rcall	.+0      	; 0xb608 <PrintIdle+0xa52>
    b608:	00 d0       	rcall	.+0      	; 0xb60a <PrintIdle+0xa54>
    b60a:	00 d0       	rcall	.+0      	; 0xb60c <PrintIdle+0xa56>
    b60c:	ed b7       	in	r30, 0x3d	; 61
    b60e:	fe b7       	in	r31, 0x3e	; 62
    b610:	31 96       	adiw	r30, 0x01	; 1
    b612:	80 eb       	ldi	r24, 0xB0	; 176
    b614:	92 e0       	ldi	r25, 0x02	; 2
    b616:	ad b7       	in	r26, 0x3d	; 61
    b618:	be b7       	in	r27, 0x3e	; 62
    b61a:	12 96       	adiw	r26, 0x02	; 2
    b61c:	9c 93       	st	X, r25
    b61e:	8e 93       	st	-X, r24
    b620:	11 97       	sbiw	r26, 0x01	; 1
    b622:	8c e7       	ldi	r24, 0x7C	; 124
    b624:	97 e0       	ldi	r25, 0x07	; 7
    b626:	93 83       	std	Z+3, r25	; 0x03
    b628:	82 83       	std	Z+2, r24	; 0x02
    b62a:	8e e7       	ldi	r24, 0x7E	; 126
    b62c:	9e e0       	ldi	r25, 0x0E	; 14
    b62e:	81 c0       	rjmp	.+258    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 30:
		       CarriegeReturn();
    b630:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
    b634:	00 d0       	rcall	.+0      	; 0xb636 <PrintIdle+0xa80>
    b636:	00 d0       	rcall	.+0      	; 0xb638 <PrintIdle+0xa82>
    b638:	00 d0       	rcall	.+0      	; 0xb63a <PrintIdle+0xa84>
    b63a:	ed b7       	in	r30, 0x3d	; 61
    b63c:	fe b7       	in	r31, 0x3e	; 62
    b63e:	31 96       	adiw	r30, 0x01	; 1
    b640:	80 eb       	ldi	r24, 0xB0	; 176
    b642:	92 e0       	ldi	r25, 0x02	; 2
    b644:	ad b7       	in	r26, 0x3d	; 61
    b646:	be b7       	in	r27, 0x3e	; 62
    b648:	12 96       	adiw	r26, 0x02	; 2
    b64a:	9c 93       	st	X, r25
    b64c:	8e 93       	st	-X, r24
    b64e:	11 97       	sbiw	r26, 0x01	; 1
    b650:	85 e6       	ldi	r24, 0x65	; 101
    b652:	97 e0       	ldi	r25, 0x07	; 7
    b654:	93 83       	std	Z+3, r25	; 0x03
    b656:	82 83       	std	Z+2, r24	; 0x02
    b658:	8f e9       	ldi	r24, 0x9F	; 159
    b65a:	95 e0       	ldi	r25, 0x05	; 5
    b65c:	6a c0       	rjmp	.+212    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 31:
		       CarriegeReturn();
    b65e:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
    b662:	00 d0       	rcall	.+0      	; 0xb664 <PrintIdle+0xaae>
    b664:	00 d0       	rcall	.+0      	; 0xb666 <PrintIdle+0xab0>
    b666:	00 d0       	rcall	.+0      	; 0xb668 <PrintIdle+0xab2>
    b668:	ed b7       	in	r30, 0x3d	; 61
    b66a:	fe b7       	in	r31, 0x3e	; 62
    b66c:	31 96       	adiw	r30, 0x01	; 1
    b66e:	80 eb       	ldi	r24, 0xB0	; 176
    b670:	92 e0       	ldi	r25, 0x02	; 2
    b672:	ad b7       	in	r26, 0x3d	; 61
    b674:	be b7       	in	r27, 0x3e	; 62
    b676:	12 96       	adiw	r26, 0x02	; 2
    b678:	9c 93       	st	X, r25
    b67a:	8e 93       	st	-X, r24
    b67c:	11 97       	sbiw	r26, 0x01	; 1
    b67e:	8c e4       	ldi	r24, 0x4C	; 76
    b680:	97 e0       	ldi	r25, 0x07	; 7
    b682:	93 83       	std	Z+3, r25	; 0x03
    b684:	82 83       	std	Z+2, r24	; 0x02
    b686:	83 ef       	ldi	r24, 0xF3	; 243
    b688:	9d e0       	ldi	r25, 0x0D	; 13
    b68a:	53 c0       	rjmp	.+166    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 32:
		       CarriegeReturn();
    b68c:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
    b690:	00 d0       	rcall	.+0      	; 0xb692 <PrintIdle+0xadc>
    b692:	00 d0       	rcall	.+0      	; 0xb694 <PrintIdle+0xade>
    b694:	00 d0       	rcall	.+0      	; 0xb696 <PrintIdle+0xae0>
    b696:	ed b7       	in	r30, 0x3d	; 61
    b698:	fe b7       	in	r31, 0x3e	; 62
    b69a:	31 96       	adiw	r30, 0x01	; 1
    b69c:	80 eb       	ldi	r24, 0xB0	; 176
    b69e:	92 e0       	ldi	r25, 0x02	; 2
    b6a0:	ad b7       	in	r26, 0x3d	; 61
    b6a2:	be b7       	in	r27, 0x3e	; 62
    b6a4:	12 96       	adiw	r26, 0x02	; 2
    b6a6:	9c 93       	st	X, r25
    b6a8:	8e 93       	st	-X, r24
    b6aa:	11 97       	sbiw	r26, 0x01	; 1
    b6ac:	82 e3       	ldi	r24, 0x32	; 50
    b6ae:	97 e0       	ldi	r25, 0x07	; 7
    b6b0:	93 83       	std	Z+3, r25	; 0x03
    b6b2:	82 83       	std	Z+2, r24	; 0x02
    b6b4:	83 e8       	ldi	r24, 0x83	; 131
    b6b6:	95 e0       	ldi	r25, 0x05	; 5
    b6b8:	3c c0       	rjmp	.+120    	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
    b6ba:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b6be:	00 d0       	rcall	.+0      	; 0xb6c0 <PrintIdle+0xb0a>
    b6c0:	00 d0       	rcall	.+0      	; 0xb6c2 <PrintIdle+0xb0c>
    b6c2:	80 eb       	ldi	r24, 0xB0	; 176
    b6c4:	92 e0       	ldi	r25, 0x02	; 2
    b6c6:	ad b7       	in	r26, 0x3d	; 61
    b6c8:	be b7       	in	r27, 0x3e	; 62
    b6ca:	12 96       	adiw	r26, 0x02	; 2
    b6cc:	9c 93       	st	X, r25
    b6ce:	8e 93       	st	-X, r24
    b6d0:	11 97       	sbiw	r26, 0x01	; 1
    b6d2:	8f e0       	ldi	r24, 0x0F	; 15
    b6d4:	97 e0       	ldi	r25, 0x07	; 7
    b6d6:	48 c0       	rjmp	.+144    	; 0xb768 <PrintIdle+0xbb2>
		       break;
		  case 34:
		       CarriegeReturn();
    b6d8:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
    b6dc:	00 d0       	rcall	.+0      	; 0xb6de <PrintIdle+0xb28>
    b6de:	00 d0       	rcall	.+0      	; 0xb6e0 <PrintIdle+0xb2a>
    b6e0:	00 d0       	rcall	.+0      	; 0xb6e2 <PrintIdle+0xb2c>
    b6e2:	ed b7       	in	r30, 0x3d	; 61
    b6e4:	fe b7       	in	r31, 0x3e	; 62
    b6e6:	31 96       	adiw	r30, 0x01	; 1
    b6e8:	80 eb       	ldi	r24, 0xB0	; 176
    b6ea:	92 e0       	ldi	r25, 0x02	; 2
    b6ec:	ad b7       	in	r26, 0x3d	; 61
    b6ee:	be b7       	in	r27, 0x3e	; 62
    b6f0:	12 96       	adiw	r26, 0x02	; 2
    b6f2:	9c 93       	st	X, r25
    b6f4:	8e 93       	st	-X, r24
    b6f6:	11 97       	sbiw	r26, 0x01	; 1
    b6f8:	88 ef       	ldi	r24, 0xF8	; 248
    b6fa:	96 e0       	ldi	r25, 0x06	; 6
    b6fc:	93 83       	std	Z+3, r25	; 0x03
    b6fe:	82 83       	std	Z+2, r24	; 0x02
    b700:	86 ef       	ldi	r24, 0xF6	; 246
    b702:	99 e0       	ldi	r25, 0x09	; 9
    b704:	16 c0       	rjmp	.+44     	; 0xb732 <PrintIdle+0xb7c>
		       break;
		  case 35:
		       CarriegeReturn();
    b706:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
    b70a:	00 d0       	rcall	.+0      	; 0xb70c <PrintIdle+0xb56>
    b70c:	00 d0       	rcall	.+0      	; 0xb70e <PrintIdle+0xb58>
    b70e:	00 d0       	rcall	.+0      	; 0xb710 <PrintIdle+0xb5a>
    b710:	ed b7       	in	r30, 0x3d	; 61
    b712:	fe b7       	in	r31, 0x3e	; 62
    b714:	31 96       	adiw	r30, 0x01	; 1
    b716:	80 eb       	ldi	r24, 0xB0	; 176
    b718:	92 e0       	ldi	r25, 0x02	; 2
    b71a:	ad b7       	in	r26, 0x3d	; 61
    b71c:	be b7       	in	r27, 0x3e	; 62
    b71e:	12 96       	adiw	r26, 0x02	; 2
    b720:	9c 93       	st	X, r25
    b722:	8e 93       	st	-X, r24
    b724:	11 97       	sbiw	r26, 0x01	; 1
    b726:	81 ee       	ldi	r24, 0xE1	; 225
    b728:	96 e0       	ldi	r25, 0x06	; 6
    b72a:	93 83       	std	Z+3, r25	; 0x03
    b72c:	82 83       	std	Z+2, r24	; 0x02
    b72e:	82 e8       	ldi	r24, 0x82	; 130
    b730:	9a e0       	ldi	r25, 0x0A	; 10
    b732:	95 83       	std	Z+5, r25	; 0x05
    b734:	84 83       	std	Z+4, r24	; 0x04
    b736:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    b73a:	ed b7       	in	r30, 0x3d	; 61
    b73c:	fe b7       	in	r31, 0x3e	; 62
    b73e:	36 96       	adiw	r30, 0x06	; 6
    b740:	0f b6       	in	r0, 0x3f	; 63
    b742:	f8 94       	cli
    b744:	fe bf       	out	0x3e, r31	; 62
    b746:	0f be       	out	0x3f, r0	; 63
    b748:	ed bf       	out	0x3d, r30	; 61
    b74a:	18 c0       	rjmp	.+48     	; 0xb77c <PrintIdle+0xbc6>
		       break;
		  case 36:
		       CarriegeReturn();
    b74c:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b750:	00 d0       	rcall	.+0      	; 0xb752 <PrintIdle+0xb9c>
    b752:	00 d0       	rcall	.+0      	; 0xb754 <PrintIdle+0xb9e>
    b754:	80 eb       	ldi	r24, 0xB0	; 176
    b756:	92 e0       	ldi	r25, 0x02	; 2
    b758:	ad b7       	in	r26, 0x3d	; 61
    b75a:	be b7       	in	r27, 0x3e	; 62
    b75c:	12 96       	adiw	r26, 0x02	; 2
    b75e:	9c 93       	st	X, r25
    b760:	8e 93       	st	-X, r24
    b762:	11 97       	sbiw	r26, 0x01	; 1
    b764:	8e eb       	ldi	r24, 0xBE	; 190
    b766:	96 e0       	ldi	r25, 0x06	; 6
    b768:	14 96       	adiw	r26, 0x04	; 4
    b76a:	9c 93       	st	X, r25
    b76c:	8e 93       	st	-X, r24
    b76e:	13 97       	sbiw	r26, 0x03	; 3
    b770:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    b774:	0f 90       	pop	r0
    b776:	0f 90       	pop	r0
    b778:	0f 90       	pop	r0
    b77a:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
    b77c:	10 92 a8 02 	sts	0x02A8, r1
    b780:	10 92 a7 02 	sts	0x02A7, r1
    b784:	10 92 ac 02 	sts	0x02AC, r1
    b788:	10 92 ab 02 	sts	0x02AB, r1
    b78c:	e0 eb       	ldi	r30, 0xB0	; 176
    b78e:	f2 e0       	ldi	r31, 0x02	; 2
    b790:	01 90       	ld	r0, Z+
    b792:	00 20       	and	r0, r0
    b794:	e9 f7       	brne	.-6      	; 0xb790 <PrintIdle+0xbda>
    b796:	31 97       	sbiw	r30, 0x01	; 1
    b798:	e0 5b       	subi	r30, 0xB0	; 176
    b79a:	f2 40       	sbci	r31, 0x02	; 2
    b79c:	f0 93 aa 02 	sts	0x02AA, r31
    b7a0:	e0 93 a9 02 	sts	0x02A9, r30
          stPrintIdle=piPrintMessage;
    b7a4:	8a e0       	ldi	r24, 0x0A	; 10
    b7a6:	f3 c0       	rjmp	.+486    	; 0xb98e <PrintIdle+0xdd8>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
    b7a8:	20 91 ab 02 	lds	r18, 0x02AB
    b7ac:	30 91 ac 02 	lds	r19, 0x02AC
    b7b0:	80 91 a9 02 	lds	r24, 0x02A9
    b7b4:	90 91 aa 02 	lds	r25, 0x02AA
    b7b8:	28 17       	cp	r18, r24
    b7ba:	39 07       	cpc	r19, r25
    b7bc:	78 f4       	brcc	.+30     	; 0xb7dc <PrintIdle+0xc26>
		      iLoop++;
    b7be:	80 91 a7 02 	lds	r24, 0x02A7
    b7c2:	90 91 a8 02 	lds	r25, 0x02A8
    b7c6:	01 96       	adiw	r24, 0x01	; 1
    b7c8:	90 93 a8 02 	sts	0x02A8, r25
    b7cc:	80 93 a7 02 	sts	0x02A7, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    b7d0:	10 92 e3 01 	sts	0x01E3, r1
    b7d4:	10 92 e2 01 	sts	0x01E2, r1
				 stPrintIdle=piCheckPrintStatusMessage;
    b7d8:	8c e0       	ldi	r24, 0x0C	; 12
    b7da:	d9 c0       	rjmp	.+434    	; 0xb98e <PrintIdle+0xdd8>
				 }
			  }
          else{iMessage++;
    b7dc:	80 91 af 02 	lds	r24, 0x02AF
    b7e0:	8f 5f       	subi	r24, 0xFF	; 255
    b7e2:	80 93 af 02 	sts	0x02AF, r24
		      if (iMessage>MessageLine){
    b7e6:	90 91 ae 02 	lds	r25, 0x02AE
    b7ea:	98 17       	cp	r25, r24
    b7ec:	18 f4       	brcc	.+6      	; 0xb7f4 <PrintIdle+0xc3e>
			      iFooter=0;
    b7ee:	10 92 df 02 	sts	0x02DF, r1
    b7f2:	5c c0       	rjmp	.+184    	; 0xb8ac <PrintIdle+0xcf6>
				  stPrintIdle=piLoadFooter;
				  CarriegeReturn();
			  }
			  else stPrintIdle=piLoadMessage;
    b7f4:	89 e0       	ldi	r24, 0x09	; 9
    b7f6:	cb c0       	rjmp	.+406    	; 0xb98e <PrintIdle+0xdd8>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    b7f8:	80 91 de 01 	lds	r24, 0x01DE
    b7fc:	88 23       	and	r24, r24
    b7fe:	09 f0       	breq	.+2      	; 0xb802 <PrintIdle+0xc4c>
    b800:	bc c0       	rjmp	.+376    	; 0xb97a <PrintIdle+0xdc4>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b802:	e0 91 ab 02 	lds	r30, 0x02AB
    b806:	f0 91 ac 02 	lds	r31, 0x02AC
    b80a:	e0 55       	subi	r30, 0x50	; 80
    b80c:	fd 4f       	sbci	r31, 0xFD	; 253
    b80e:	61 e0       	ldi	r22, 0x01	; 1
    b810:	40 81       	ld	r20, Z
    b812:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		      iSend++;
    b816:	80 91 ab 02 	lds	r24, 0x02AB
    b81a:	90 91 ac 02 	lds	r25, 0x02AC
    b81e:	01 96       	adiw	r24, 0x01	; 1
    b820:	90 93 ac 02 	sts	0x02AC, r25
    b824:	80 93 ab 02 	sts	0x02AB, r24
		      stPrintIdle=piPrintMessage;
    b828:	8a e0       	ldi	r24, 0x0A	; 10
    b82a:	a5 c0       	rjmp	.+330    	; 0xb976 <PrintIdle+0xdc0>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    b82c:	60 91 df 02 	lds	r22, 0x02DF
    b830:	89 e2       	ldi	r24, 0x29	; 41
    b832:	68 9f       	mul	r22, r24
    b834:	b0 01       	movw	r22, r0
    b836:	11 24       	eor	r1, r1
    b838:	63 5b       	subi	r22, 0xB3	; 179
    b83a:	7c 4f       	sbci	r23, 0xFC	; 252
    b83c:	80 eb       	ldi	r24, 0xB0	; 176
    b83e:	92 e0       	ldi	r25, 0x02	; 2
    b840:	48 e2       	ldi	r20, 0x28	; 40
    b842:	50 e0       	ldi	r21, 0x00	; 0
    b844:	27 e9       	ldi	r18, 0x97	; 151
    b846:	32 e1       	ldi	r19, 0x12	; 18
    b848:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	      break;
		       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    b84c:	80 91 df 02 	lds	r24, 0x02DF
    b850:	8f 5f       	subi	r24, 0xFF	; 255
    b852:	80 93 df 02 	sts	0x02DF, r24
		  if (iFooter<=4){
    b856:	85 30       	cpi	r24, 0x05	; 5
    b858:	90 f4       	brcc	.+36     	; 0xb87e <PrintIdle+0xcc8>
		      if (SpaceOnly(strPrint)==True){
    b85a:	80 eb       	ldi	r24, 0xB0	; 176
    b85c:	92 e0       	ldi	r25, 0x02	; 2
    b85e:	0e 94 98 21 	call	0x4330	; 0x4330 <SpaceOnly>
    b862:	81 30       	cpi	r24, 0x01	; 1
    b864:	11 f4       	brne	.+4      	; 0xb86a <PrintIdle+0xcb4>
			      stPrintIdle=piLoadFooter;
    b866:	8e e0       	ldi	r24, 0x0E	; 14
    b868:	92 c0       	rjmp	.+292    	; 0xb98e <PrintIdle+0xdd8>
				  }
			  else{
			      iSend=0;
    b86a:	10 92 ac 02 	sts	0x02AC, r1
    b86e:	10 92 ab 02 	sts	0x02AB, r1
				  iLoop=0;
    b872:	10 92 a8 02 	sts	0x02A8, r1
    b876:	10 92 a7 02 	sts	0x02A7, r1
				  stPrintIdle=piPrintFooter;
    b87a:	8f e0       	ldi	r24, 0x0F	; 15
    b87c:	88 c0       	rjmp	.+272    	; 0xb98e <PrintIdle+0xdd8>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
    b87e:	81 e1       	ldi	r24, 0x11	; 17
    b880:	86 c0       	rjmp	.+268    	; 0xb98e <PrintIdle+0xdd8>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
    b882:	80 91 ab 02 	lds	r24, 0x02AB
    b886:	90 91 ac 02 	lds	r25, 0x02AC
    b88a:	88 97       	sbiw	r24, 0x28	; 40
    b88c:	78 f4       	brcc	.+30     	; 0xb8ac <PrintIdle+0xcf6>
		      iLoop++;
    b88e:	80 91 a7 02 	lds	r24, 0x02A7
    b892:	90 91 a8 02 	lds	r25, 0x02A8
    b896:	01 96       	adiw	r24, 0x01	; 1
    b898:	90 93 a8 02 	sts	0x02A8, r25
    b89c:	80 93 a7 02 	sts	0x02A7, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
    b8a0:	10 92 e3 01 	sts	0x01E3, r1
    b8a4:	10 92 e2 01 	sts	0x01E2, r1
				stPrintIdle=piCheckPrintStatusFooter;
    b8a8:	8d e0       	ldi	r24, 0x0D	; 13
    b8aa:	71 c0       	rjmp	.+226    	; 0xb98e <PrintIdle+0xdd8>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
    b8ac:	8e e0       	ldi	r24, 0x0E	; 14
    b8ae:	80 93 e1 02 	sts	0x02E1, r24
			  CarriegeReturn();
    b8b2:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
    b8b6:	a5 c0       	rjmp	.+330    	; 0xba02 <PrintIdle+0xe4c>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    b8b8:	80 91 de 01 	lds	r24, 0x01DE
    b8bc:	88 23       	and	r24, r24
    b8be:	09 f0       	breq	.+2      	; 0xb8c2 <PrintIdle+0xd0c>
    b8c0:	5c c0       	rjmp	.+184    	; 0xb97a <PrintIdle+0xdc4>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b8c2:	e0 91 ab 02 	lds	r30, 0x02AB
    b8c6:	f0 91 ac 02 	lds	r31, 0x02AC
    b8ca:	e0 55       	subi	r30, 0x50	; 80
    b8cc:	fd 4f       	sbci	r31, 0xFD	; 253
    b8ce:	61 e0       	ldi	r22, 0x01	; 1
    b8d0:	40 81       	ld	r20, Z
    b8d2:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		      iSend++;
    b8d6:	80 91 ab 02 	lds	r24, 0x02AB
    b8da:	90 91 ac 02 	lds	r25, 0x02AC
    b8de:	01 96       	adiw	r24, 0x01	; 1
    b8e0:	90 93 ac 02 	sts	0x02AC, r25
    b8e4:	80 93 ab 02 	sts	0x02AB, r24
		      stPrintIdle=piPrintFooter;
    b8e8:	8f e0       	ldi	r24, 0x0F	; 15
    b8ea:	45 c0       	rjmp	.+138    	; 0xb976 <PrintIdle+0xdc0>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
    b8ec:	90 91 a6 02 	lds	r25, 0x02A6
    b8f0:	9f 5f       	subi	r25, 0xFF	; 255
    b8f2:	90 93 a6 02 	sts	0x02A6, r25
		  iScroll=0;
    b8f6:	10 92 de 02 	sts	0x02DE, r1
		  iLoop=0;
    b8fa:	10 92 a8 02 	sts	0x02A8, r1
    b8fe:	10 92 a7 02 	sts	0x02A7, r1
		  if (iPrinted<PrintCopy){
    b902:	80 91 a5 02 	lds	r24, 0x02A5
    b906:	98 17       	cp	r25, r24
    b908:	28 f4       	brcc	.+10     	; 0xb914 <PrintIdle+0xd5e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b90a:	e1 99       	sbic	0x1c, 1	; 28
    b90c:	fe cf       	rjmp	.-4      	; 0xb90a <PrintIdle+0xd54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b90e:	82 e3       	ldi	r24, 0x32	; 50
    b910:	90 e0       	ldi	r25, 0x00	; 0
    b912:	04 c0       	rjmp	.+8      	; 0xb91c <PrintIdle+0xd66>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b914:	e1 99       	sbic	0x1c, 1	; 28
    b916:	fe cf       	rjmp	.-4      	; 0xb914 <PrintIdle+0xd5e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b918:	81 e3       	ldi	r24, 0x31	; 49
    b91a:	90 e0       	ldi	r25, 0x00	; 0
    b91c:	9f bb       	out	0x1f, r25	; 31
    b91e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b920:	e0 9a       	sbi	0x1c, 0	; 28
    b922:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    b924:	80 93 dd 02 	sts	0x02DD, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      _uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
    b928:	80 e1       	ldi	r24, 0x10	; 16
    b92a:	31 c0       	rjmp	.+98     	; 0xb98e <PrintIdle+0xdd8>
	      break;
     case piScrollPaper:
	      iLoop++;
    b92c:	80 91 a7 02 	lds	r24, 0x02A7
    b930:	90 91 a8 02 	lds	r25, 0x02A8
    b934:	01 96       	adiw	r24, 0x01	; 1
    b936:	90 93 a8 02 	sts	0x02A8, r25
    b93a:	80 93 a7 02 	sts	0x02A7, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
    b93e:	10 92 e3 01 	sts	0x01E3, r1
    b942:	10 92 e2 01 	sts	0x01E2, r1
			  stPrintIdle=piCheckPrintStatusScroll;
    b946:	82 e1       	ldi	r24, 0x12	; 18
    b948:	80 93 e1 02 	sts	0x02E1, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
    b94c:	90 91 de 02 	lds	r25, 0x02DE
    b950:	80 91 dd 02 	lds	r24, 0x02DD
    b954:	89 17       	cp	r24, r25
    b956:	08 f0       	brcs	.+2      	; 0xb95a <PrintIdle+0xda4>
    b958:	54 c0       	rjmp	.+168    	; 0xba02 <PrintIdle+0xe4c>
    b95a:	83 e1       	ldi	r24, 0x13	; 19
    b95c:	18 c0       	rjmp	.+48     	; 0xb98e <PrintIdle+0xdd8>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
    b95e:	80 91 de 01 	lds	r24, 0x01DE
    b962:	88 23       	and	r24, r24
    b964:	51 f4       	brne	.+20     	; 0xb97a <PrintIdle+0xdc4>
		      iScroll++;
    b966:	80 91 de 02 	lds	r24, 0x02DE
    b96a:	8f 5f       	subi	r24, 0xFF	; 255
    b96c:	80 93 de 02 	sts	0x02DE, r24
		      CarriegeReturn();
    b970:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
    b974:	80 e1       	ldi	r24, 0x10	; 16
    b976:	80 93 e1 02 	sts	0x02E1, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    b97a:	80 91 e2 01 	lds	r24, 0x01E2
    b97e:	90 91 e3 01 	lds	r25, 0x01E3
    b982:	0b 97       	sbiw	r24, 0x0b	; 11
    b984:	f4 f1       	brlt	.+124    	; 0xba02 <PrintIdle+0xe4c>
		      IsPrintERROR=True;
    b986:	81 e0       	ldi	r24, 0x01	; 1
    b988:	80 93 dd 01 	sts	0x01DD, r24
		      stPrintIdle=piFinishPrintIdle;
    b98c:	84 e1       	ldi	r24, 0x14	; 20
    b98e:	80 93 e1 02 	sts	0x02E1, r24
    b992:	37 c0       	rjmp	.+110    	; 0xba02 <PrintIdle+0xe4c>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //_uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
    b994:	90 91 a6 02 	lds	r25, 0x02A6
    b998:	80 91 a5 02 	lds	r24, 0x02A5
    b99c:	98 17       	cp	r25, r24
    b99e:	10 f0       	brcs	.+4      	; 0xb9a4 <PrintIdle+0xdee>
		      stPrintIdle=piFinishPrintIdle;
    b9a0:	84 e1       	ldi	r24, 0x14	; 20
    b9a2:	05 c0       	rjmp	.+10     	; 0xb9ae <PrintIdle+0xdf8>
			  }
		  else {CarriegeReturn();
    b9a4:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		        CarriegeReturn();
    b9a8:	0e 94 bf 4b 	call	0x977e	; 0x977e <CarriegeReturn>
		        stPrintIdle=piInit;
    b9ac:	81 e0       	ldi	r24, 0x01	; 1
    b9ae:	80 93 e1 02 	sts	0x02E1, r24
		       }
		  PaperCut();
    b9b2:	0e 94 66 4c 	call	0x98cc	; 0x98cc <PaperCut>
    b9b6:	25 c0       	rjmp	.+74     	; 0xba02 <PrintIdle+0xe4c>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
    b9b8:	80 91 25 01 	lds	r24, 0x0125
    b9bc:	81 30       	cpi	r24, 0x01	; 1
    b9be:	19 f0       	breq	.+6      	; 0xb9c6 <PrintIdle+0xe10>
    b9c0:	82 30       	cpi	r24, 0x02	; 2
    b9c2:	d9 f4       	brne	.+54     	; 0xb9fa <PrintIdle+0xe44>
    b9c4:	03 c0       	rjmp	.+6      	; 0xb9cc <PrintIdle+0xe16>
		  case IT_SLAVE:
		       sendMessage04();
    b9c6:	0e 94 e1 52 	call	0xa5c2	; 0xa5c2 <sendMessage04>
    b9ca:	17 c0       	rjmp	.+46     	; 0xb9fa <PrintIdle+0xe44>
		       break;
		  case IT_STANDALONE:
		  
		       //UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
			   FIPAddr=GetFIPAddr(atoi(strFIP_ID)&0x0F)-1;
    b9cc:	83 ec       	ldi	r24, 0xC3	; 195
    b9ce:	99 e0       	ldi	r25, 0x09	; 9
    b9d0:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
    b9d4:	8f 70       	andi	r24, 0x0F	; 15
    b9d6:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
			   CurrentPumpStatus[FIPAddr]=PUMP_OFF;
    b9da:	81 50       	subi	r24, 0x01	; 1
    b9dc:	c8 2f       	mov	r28, r24
    b9de:	d0 e0       	ldi	r29, 0x00	; 0
    b9e0:	fe 01       	movw	r30, r28
    b9e2:	e8 58       	subi	r30, 0x88	; 136
    b9e4:	fe 4f       	sbci	r31, 0xFE	; 254
    b9e6:	86 e0       	ldi	r24, 0x06	; 6
    b9e8:	80 83       	st	Z, r24
			   strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);
    b9ea:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    b9ee:	c9 5d       	subi	r28, 0xD9	; 217
    b9f0:	de 4f       	sbci	r29, 0xFE	; 254
    b9f2:	88 83       	st	Y, r24
			   //UpdateDisplay
			   IsNewPumpStatus=True;
    b9f4:	81 e0       	ldi	r24, 0x01	; 1
    b9f6:	80 93 26 01 	sts	0x0126, r24
		       break;
		  }
		  IsBusyIdlePrinting=False;
    b9fa:	10 92 e0 01 	sts	0x01E0, r1
          stPrintIdle=piIdle;
    b9fe:	10 92 e1 02 	sts	0x02E1, r1
	      break;	 
	 }
}
    ba02:	df 91       	pop	r29
    ba04:	cf 91       	pop	r28
    ba06:	08 95       	ret

0000ba08 <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
    ba08:	0e 94 45 53 	call	0xa68a	; 0xa68a <FreePrinting>
	 PrintIdle();
    ba0c:	0e 94 db 55 	call	0xabb6	; 0xabb6 <PrintIdle>
}
    ba10:	08 95       	ret

0000ba12 <procMessage11>:
}




void procMessage11(){
    ba12:	af 92       	push	r10
    ba14:	bf 92       	push	r11
    ba16:	cf 92       	push	r12
    ba18:	df 92       	push	r13
    ba1a:	ef 92       	push	r14
    ba1c:	ff 92       	push	r15
    ba1e:	0f 93       	push	r16
    ba20:	1f 93       	push	r17
    ba22:	df 93       	push	r29
    ba24:	cf 93       	push	r28
    ba26:	cd b7       	in	r28, 0x3d	; 61
    ba28:	de b7       	in	r29, 0x3e	; 62
    ba2a:	c5 55       	subi	r28, 0x55	; 85
    ba2c:	d0 40       	sbci	r29, 0x00	; 0
    ba2e:	0f b6       	in	r0, 0x3f	; 63
    ba30:	f8 94       	cli
    ba32:	de bf       	out	0x3e, r29	; 62
    ba34:	0f be       	out	0x3f, r0	; 63
    ba36:	cd bf       	out	0x3d, r28	; 61
    ba38:	20 e0       	ldi	r18, 0x00	; 0
    ba3a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba3c:	ae 01       	movw	r20, r28
    ba3e:	46 5f       	subi	r20, 0xF6	; 246
    ba40:	5f 4f       	sbci	r21, 0xFF	; 255
    ba42:	fa 01       	movw	r30, r20
    ba44:	e2 0f       	add	r30, r18
    ba46:	f3 1f       	adc	r31, r19
    ba48:	d9 01       	movw	r26, r18
    ba4a:	a0 5e       	subi	r26, 0xE0	; 224
    ba4c:	b4 4f       	sbci	r27, 0xF4	; 244
    ba4e:	9b 96       	adiw	r26, 0x2b	; 43
    ba50:	8c 91       	ld	r24, X
    ba52:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba54:	2f 5f       	subi	r18, 0xFF	; 255
    ba56:	3f 4f       	sbci	r19, 0xFF	; 255
    ba58:	2a 30       	cpi	r18, 0x0A	; 10
    ba5a:	31 05       	cpc	r19, r1
    ba5c:	91 f7       	brne	.-28     	; 0xba42 <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba5e:	fa 01       	movw	r30, r20
    ba60:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    ba62:	81 e0       	ldi	r24, 0x01	; 1
    ba64:	ba 01       	movw	r22, r20
    ba66:	0e 94 6c 22 	call	0x44d8	; 0x44d8 <FormatDate>
    ba6a:	20 e0       	ldi	r18, 0x00	; 0
    ba6c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba6e:	ae 01       	movw	r20, r28
    ba70:	4c 5e       	subi	r20, 0xEC	; 236
    ba72:	5f 4f       	sbci	r21, 0xFF	; 255
    ba74:	fa 01       	movw	r30, r20
    ba76:	e2 0f       	add	r30, r18
    ba78:	f3 1f       	adc	r31, r19
    ba7a:	d9 01       	movw	r26, r18
    ba7c:	a0 5e       	subi	r26, 0xE0	; 224
    ba7e:	b4 4f       	sbci	r27, 0xF4	; 244
    ba80:	d6 96       	adiw	r26, 0x36	; 54
    ba82:	8c 91       	ld	r24, X
    ba84:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba86:	2f 5f       	subi	r18, 0xFF	; 255
    ba88:	3f 4f       	sbci	r19, 0xFF	; 255
    ba8a:	28 30       	cpi	r18, 0x08	; 8
    ba8c:	31 05       	cpc	r19, r1
    ba8e:	91 f7       	brne	.-28     	; 0xba74 <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba90:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    ba92:	81 e0       	ldi	r24, 0x01	; 1
    ba94:	be 01       	movw	r22, r28
    ba96:	66 5f       	subi	r22, 0xF6	; 246
    ba98:	7f 4f       	sbci	r23, 0xFF	; 255
    ba9a:	0e 94 2b b3 	call	0x16656	; 0x16656 <_datetime>
	  
     clearString(buffHeader);
    ba9e:	8e 01       	movw	r16, r28
    baa0:	03 5d       	subi	r16, 0xD3	; 211
    baa2:	1f 4f       	sbci	r17, 0xFF	; 255
    baa4:	c8 01       	movw	r24, r16
    baa6:	0e 94 02 25 	call	0x4a04	; 0x4a04 <clearString>
    baaa:	20 e0       	ldi	r18, 0x00	; 0
    baac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    baae:	f8 01       	movw	r30, r16
    bab0:	e2 0f       	add	r30, r18
    bab2:	f3 1f       	adc	r31, r19
    bab4:	d9 01       	movw	r26, r18
    bab6:	a0 5e       	subi	r26, 0xE0	; 224
    bab8:	b4 4f       	sbci	r27, 0xF4	; 244
    baba:	de 96       	adiw	r26, 0x3e	; 62
    babc:	8c 91       	ld	r24, X
    babe:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bac0:	2f 5f       	subi	r18, 0xFF	; 255
    bac2:	3f 4f       	sbci	r19, 0xFF	; 255
    bac4:	28 32       	cpi	r18, 0x28	; 40
    bac6:	31 05       	cpc	r19, r1
    bac8:	91 f7       	brne	.-28     	; 0xbaae <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    baca:	fe 01       	movw	r30, r28
    bacc:	eb 5a       	subi	r30, 0xAB	; 171
    bace:	ff 4f       	sbci	r31, 0xFF	; 255
    bad0:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    bad2:	87 e5       	ldi	r24, 0x57	; 87
    bad4:	92 e0       	ldi	r25, 0x02	; 2
    bad6:	b8 01       	movw	r22, r16
    bad8:	48 e2       	ldi	r20, 0x28	; 40
    bada:	50 e0       	ldi	r21, 0x00	; 0
    badc:	2f e9       	ldi	r18, 0x9F	; 159
    bade:	32 e1       	ldi	r19, 0x12	; 18
    bae0:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bae4:	20 e0       	ldi	r18, 0x00	; 0
    bae6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bae8:	be 01       	movw	r22, r28
    baea:	63 5d       	subi	r22, 0xD3	; 211
    baec:	7f 4f       	sbci	r23, 0xFF	; 255
    baee:	fb 01       	movw	r30, r22
    baf0:	e2 0f       	add	r30, r18
    baf2:	f3 1f       	adc	r31, r19
    baf4:	d9 01       	movw	r26, r18
    baf6:	aa 57       	subi	r26, 0x7A	; 122
    baf8:	b4 4f       	sbci	r27, 0xF4	; 244
    bafa:	8c 91       	ld	r24, X
    bafc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bafe:	2f 5f       	subi	r18, 0xFF	; 255
    bb00:	3f 4f       	sbci	r19, 0xFF	; 255
    bb02:	28 32       	cpi	r18, 0x28	; 40
    bb04:	31 05       	cpc	r19, r1
    bb06:	99 f7       	brne	.-26     	; 0xbaee <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb08:	fe 01       	movw	r30, r28
    bb0a:	eb 5a       	subi	r30, 0xAB	; 171
    bb0c:	ff 4f       	sbci	r31, 0xFF	; 255
    bb0e:	10 82       	st	Z, r1
    bb10:	80 e8       	ldi	r24, 0x80	; 128
    bb12:	92 e0       	ldi	r25, 0x02	; 2
    bb14:	48 e2       	ldi	r20, 0x28	; 40
    bb16:	50 e0       	ldi	r21, 0x00	; 0
    bb18:	2f e9       	ldi	r18, 0x9F	; 159
    bb1a:	32 e1       	ldi	r19, 0x12	; 18
    bb1c:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bb20:	20 e0       	ldi	r18, 0x00	; 0
    bb22:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb24:	be 01       	movw	r22, r28
    bb26:	63 5d       	subi	r22, 0xD3	; 211
    bb28:	7f 4f       	sbci	r23, 0xFF	; 255
    bb2a:	fb 01       	movw	r30, r22
    bb2c:	e2 0f       	add	r30, r18
    bb2e:	f3 1f       	adc	r31, r19
    bb30:	d9 01       	movw	r26, r18
    bb32:	a2 55       	subi	r26, 0x52	; 82
    bb34:	b4 4f       	sbci	r27, 0xF4	; 244
    bb36:	8c 91       	ld	r24, X
    bb38:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb3a:	2f 5f       	subi	r18, 0xFF	; 255
    bb3c:	3f 4f       	sbci	r19, 0xFF	; 255
    bb3e:	28 32       	cpi	r18, 0x28	; 40
    bb40:	31 05       	cpc	r19, r1
    bb42:	99 f7       	brne	.-26     	; 0xbb2a <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb44:	fe 01       	movw	r30, r28
    bb46:	eb 5a       	subi	r30, 0xAB	; 171
    bb48:	ff 4f       	sbci	r31, 0xFF	; 255
    bb4a:	10 82       	st	Z, r1
    bb4c:	89 ea       	ldi	r24, 0xA9	; 169
    bb4e:	92 e0       	ldi	r25, 0x02	; 2
    bb50:	48 e2       	ldi	r20, 0x28	; 40
    bb52:	50 e0       	ldi	r21, 0x00	; 0
    bb54:	2f e9       	ldi	r18, 0x9F	; 159
    bb56:	32 e1       	ldi	r19, 0x12	; 18
    bb58:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bb5c:	20 e0       	ldi	r18, 0x00	; 0
    bb5e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb60:	be 01       	movw	r22, r28
    bb62:	63 5d       	subi	r22, 0xD3	; 211
    bb64:	7f 4f       	sbci	r23, 0xFF	; 255
    bb66:	fb 01       	movw	r30, r22
    bb68:	e2 0f       	add	r30, r18
    bb6a:	f3 1f       	adc	r31, r19
    bb6c:	d9 01       	movw	r26, r18
    bb6e:	aa 52       	subi	r26, 0x2A	; 42
    bb70:	b4 4f       	sbci	r27, 0xF4	; 244
    bb72:	8c 91       	ld	r24, X
    bb74:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb76:	2f 5f       	subi	r18, 0xFF	; 255
    bb78:	3f 4f       	sbci	r19, 0xFF	; 255
    bb7a:	28 32       	cpi	r18, 0x28	; 40
    bb7c:	31 05       	cpc	r19, r1
    bb7e:	99 f7       	brne	.-26     	; 0xbb66 <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb80:	fe 01       	movw	r30, r28
    bb82:	eb 5a       	subi	r30, 0xAB	; 171
    bb84:	ff 4f       	sbci	r31, 0xFF	; 255
    bb86:	10 82       	st	Z, r1
    bb88:	82 ed       	ldi	r24, 0xD2	; 210
    bb8a:	92 e0       	ldi	r25, 0x02	; 2
    bb8c:	48 e2       	ldi	r20, 0x28	; 40
    bb8e:	50 e0       	ldi	r21, 0x00	; 0
    bb90:	2f e9       	ldi	r18, 0x9F	; 159
    bb92:	32 e1       	ldi	r19, 0x12	; 18
    bb94:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bb98:	20 e0       	ldi	r18, 0x00	; 0
    bb9a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb9c:	be 01       	movw	r22, r28
    bb9e:	63 5d       	subi	r22, 0xD3	; 211
    bba0:	7f 4f       	sbci	r23, 0xFF	; 255
    bba2:	fb 01       	movw	r30, r22
    bba4:	e2 0f       	add	r30, r18
    bba6:	f3 1f       	adc	r31, r19
    bba8:	d9 01       	movw	r26, r18
    bbaa:	a2 50       	subi	r26, 0x02	; 2
    bbac:	b4 4f       	sbci	r27, 0xF4	; 244
    bbae:	8c 91       	ld	r24, X
    bbb0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbb2:	2f 5f       	subi	r18, 0xFF	; 255
    bbb4:	3f 4f       	sbci	r19, 0xFF	; 255
    bbb6:	28 32       	cpi	r18, 0x28	; 40
    bbb8:	31 05       	cpc	r19, r1
    bbba:	99 f7       	brne	.-26     	; 0xbba2 <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bbbc:	fe 01       	movw	r30, r28
    bbbe:	eb 5a       	subi	r30, 0xAB	; 171
    bbc0:	ff 4f       	sbci	r31, 0xFF	; 255
    bbc2:	10 82       	st	Z, r1
    bbc4:	8b ef       	ldi	r24, 0xFB	; 251
    bbc6:	92 e0       	ldi	r25, 0x02	; 2
    bbc8:	48 e2       	ldi	r20, 0x28	; 40
    bbca:	50 e0       	ldi	r21, 0x00	; 0
    bbcc:	2f e9       	ldi	r18, 0x9F	; 159
    bbce:	32 e1       	ldi	r19, 0x12	; 18
    bbd0:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bbd4:	20 e0       	ldi	r18, 0x00	; 0
    bbd6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bbd8:	be 01       	movw	r22, r28
    bbda:	63 5d       	subi	r22, 0xD3	; 211
    bbdc:	7f 4f       	sbci	r23, 0xFF	; 255
    bbde:	fb 01       	movw	r30, r22
    bbe0:	e2 0f       	add	r30, r18
    bbe2:	f3 1f       	adc	r31, r19
    bbe4:	d9 01       	movw	r26, r18
    bbe6:	aa 5d       	subi	r26, 0xDA	; 218
    bbe8:	b3 4f       	sbci	r27, 0xF3	; 243
    bbea:	8c 91       	ld	r24, X
    bbec:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbee:	2f 5f       	subi	r18, 0xFF	; 255
    bbf0:	3f 4f       	sbci	r19, 0xFF	; 255
    bbf2:	28 32       	cpi	r18, 0x28	; 40
    bbf4:	31 05       	cpc	r19, r1
    bbf6:	99 f7       	brne	.-26     	; 0xbbde <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bbf8:	fe 01       	movw	r30, r28
    bbfa:	eb 5a       	subi	r30, 0xAB	; 171
    bbfc:	ff 4f       	sbci	r31, 0xFF	; 255
    bbfe:	10 82       	st	Z, r1
    bc00:	84 e2       	ldi	r24, 0x24	; 36
    bc02:	93 e0       	ldi	r25, 0x03	; 3
    bc04:	48 e2       	ldi	r20, 0x28	; 40
    bc06:	50 e0       	ldi	r21, 0x00	; 0
    bc08:	2f e9       	ldi	r18, 0x9F	; 159
    bc0a:	32 e1       	ldi	r19, 0x12	; 18
    bc0c:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bc10:	20 e0       	ldi	r18, 0x00	; 0
    bc12:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc14:	be 01       	movw	r22, r28
    bc16:	63 5d       	subi	r22, 0xD3	; 211
    bc18:	7f 4f       	sbci	r23, 0xFF	; 255
    bc1a:	fb 01       	movw	r30, r22
    bc1c:	e2 0f       	add	r30, r18
    bc1e:	f3 1f       	adc	r31, r19
    bc20:	d9 01       	movw	r26, r18
    bc22:	a2 5b       	subi	r26, 0xB2	; 178
    bc24:	b3 4f       	sbci	r27, 0xF3	; 243
    bc26:	8c 91       	ld	r24, X
    bc28:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bc2a:	2f 5f       	subi	r18, 0xFF	; 255
    bc2c:	3f 4f       	sbci	r19, 0xFF	; 255
    bc2e:	28 32       	cpi	r18, 0x28	; 40
    bc30:	31 05       	cpc	r19, r1
    bc32:	99 f7       	brne	.-26     	; 0xbc1a <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bc34:	fe 01       	movw	r30, r28
    bc36:	eb 5a       	subi	r30, 0xAB	; 171
    bc38:	ff 4f       	sbci	r31, 0xFF	; 255
    bc3a:	10 82       	st	Z, r1
    bc3c:	8d e4       	ldi	r24, 0x4D	; 77
    bc3e:	93 e0       	ldi	r25, 0x03	; 3
    bc40:	48 e2       	ldi	r20, 0x28	; 40
    bc42:	50 e0       	ldi	r21, 0x00	; 0
    bc44:	2f e9       	ldi	r18, 0x9F	; 159
    bc46:	32 e1       	ldi	r19, 0x12	; 18
    bc48:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bc4c:	20 e0       	ldi	r18, 0x00	; 0
    bc4e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc50:	be 01       	movw	r22, r28
    bc52:	63 5d       	subi	r22, 0xD3	; 211
    bc54:	7f 4f       	sbci	r23, 0xFF	; 255
    bc56:	fb 01       	movw	r30, r22
    bc58:	e2 0f       	add	r30, r18
    bc5a:	f3 1f       	adc	r31, r19
    bc5c:	d9 01       	movw	r26, r18
    bc5e:	aa 58       	subi	r26, 0x8A	; 138
    bc60:	b3 4f       	sbci	r27, 0xF3	; 243
    bc62:	8c 91       	ld	r24, X
    bc64:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bc66:	2f 5f       	subi	r18, 0xFF	; 255
    bc68:	3f 4f       	sbci	r19, 0xFF	; 255
    bc6a:	28 32       	cpi	r18, 0x28	; 40
    bc6c:	31 05       	cpc	r19, r1
    bc6e:	99 f7       	brne	.-26     	; 0xbc56 <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bc70:	fe 01       	movw	r30, r28
    bc72:	eb 5a       	subi	r30, 0xAB	; 171
    bc74:	ff 4f       	sbci	r31, 0xFF	; 255
    bc76:	10 82       	st	Z, r1
    bc78:	86 e7       	ldi	r24, 0x76	; 118
    bc7a:	93 e0       	ldi	r25, 0x03	; 3
    bc7c:	48 e2       	ldi	r20, 0x28	; 40
    bc7e:	50 e0       	ldi	r21, 0x00	; 0
    bc80:	2f e9       	ldi	r18, 0x9F	; 159
    bc82:	32 e1       	ldi	r19, 0x12	; 18
    bc84:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bc88:	20 e0       	ldi	r18, 0x00	; 0
    bc8a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc8c:	be 01       	movw	r22, r28
    bc8e:	63 5d       	subi	r22, 0xD3	; 211
    bc90:	7f 4f       	sbci	r23, 0xFF	; 255
    bc92:	fb 01       	movw	r30, r22
    bc94:	e2 0f       	add	r30, r18
    bc96:	f3 1f       	adc	r31, r19
    bc98:	d9 01       	movw	r26, r18
    bc9a:	a2 56       	subi	r26, 0x62	; 98
    bc9c:	b3 4f       	sbci	r27, 0xF3	; 243
    bc9e:	8c 91       	ld	r24, X
    bca0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bca2:	2f 5f       	subi	r18, 0xFF	; 255
    bca4:	3f 4f       	sbci	r19, 0xFF	; 255
    bca6:	28 32       	cpi	r18, 0x28	; 40
    bca8:	31 05       	cpc	r19, r1
    bcaa:	99 f7       	brne	.-26     	; 0xbc92 <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bcac:	fe 01       	movw	r30, r28
    bcae:	eb 5a       	subi	r30, 0xAB	; 171
    bcb0:	ff 4f       	sbci	r31, 0xFF	; 255
    bcb2:	10 82       	st	Z, r1
    bcb4:	8f e9       	ldi	r24, 0x9F	; 159
    bcb6:	93 e0       	ldi	r25, 0x03	; 3
    bcb8:	48 e2       	ldi	r20, 0x28	; 40
    bcba:	50 e0       	ldi	r21, 0x00	; 0
    bcbc:	2f e9       	ldi	r18, 0x9F	; 159
    bcbe:	32 e1       	ldi	r19, 0x12	; 18
    bcc0:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bcc4:	20 e0       	ldi	r18, 0x00	; 0
    bcc6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bcc8:	be 01       	movw	r22, r28
    bcca:	63 5d       	subi	r22, 0xD3	; 211
    bccc:	7f 4f       	sbci	r23, 0xFF	; 255
    bcce:	fb 01       	movw	r30, r22
    bcd0:	e2 0f       	add	r30, r18
    bcd2:	f3 1f       	adc	r31, r19
    bcd4:	d9 01       	movw	r26, r18
    bcd6:	aa 53       	subi	r26, 0x3A	; 58
    bcd8:	b3 4f       	sbci	r27, 0xF3	; 243
    bcda:	8c 91       	ld	r24, X
    bcdc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bcde:	2f 5f       	subi	r18, 0xFF	; 255
    bce0:	3f 4f       	sbci	r19, 0xFF	; 255
    bce2:	28 32       	cpi	r18, 0x28	; 40
    bce4:	31 05       	cpc	r19, r1
    bce6:	99 f7       	brne	.-26     	; 0xbcce <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bce8:	fe 01       	movw	r30, r28
    bcea:	eb 5a       	subi	r30, 0xAB	; 171
    bcec:	ff 4f       	sbci	r31, 0xFF	; 255
    bcee:	10 82       	st	Z, r1
    bcf0:	88 ec       	ldi	r24, 0xC8	; 200
    bcf2:	93 e0       	ldi	r25, 0x03	; 3
    bcf4:	48 e2       	ldi	r20, 0x28	; 40
    bcf6:	50 e0       	ldi	r21, 0x00	; 0
    bcf8:	2f e9       	ldi	r18, 0x9F	; 159
    bcfa:	32 e1       	ldi	r19, 0x12	; 18
    bcfc:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bd00:	0b ee       	ldi	r16, 0xEB	; 235
    bd02:	10 e0       	ldi	r17, 0x00	; 0
    bd04:	26 e0       	ldi	r18, 0x06	; 6
    bd06:	e2 2e       	mov	r14, r18
    bd08:	2d e0       	ldi	r18, 0x0D	; 13
    bd0a:	f2 2e       	mov	r15, r18
    bd0c:	90 e2       	ldi	r25, 0x20	; 32
    bd0e:	c9 2e       	mov	r12, r25
    bd10:	d1 2c       	mov	r13, r1
    bd12:	cc 0e       	add	r12, r28
    bd14:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd16:	8c e2       	ldi	r24, 0x2C	; 44
    bd18:	a8 2e       	mov	r10, r24
    bd1a:	b1 2c       	mov	r11, r1
    bd1c:	ac 0e       	add	r10, r28
    bd1e:	bd 1e       	adc	r11, r29
    bd20:	f6 01       	movw	r30, r12
    bd22:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    bd24:	8d 91       	ld	r24, X+
    bd26:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd28:	ea 15       	cp	r30, r10
    bd2a:	fb 05       	cpc	r31, r11
    bd2c:	d9 f7       	brne	.-10     	; 0xbd24 <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd2e:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    bd30:	c6 01       	movw	r24, r12
    bd32:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
    bd36:	c8 01       	movw	r24, r16
    bd38:	b6 01       	movw	r22, r12
    bd3a:	4c e0       	ldi	r20, 0x0C	; 12
    bd3c:	50 e0       	ldi	r21, 0x00	; 0
    bd3e:	2f e9       	ldi	r18, 0x9F	; 159
    bd40:	32 e1       	ldi	r19, 0x12	; 18
    bd42:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bd46:	03 5f       	subi	r16, 0xF3	; 243
    bd48:	1f 4f       	sbci	r17, 0xFF	; 255
    bd4a:	8c e0       	ldi	r24, 0x0C	; 12
    bd4c:	90 e0       	ldi	r25, 0x00	; 0
    bd4e:	e8 0e       	add	r14, r24
    bd50:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bd52:	91 e0       	ldi	r25, 0x01	; 1
    bd54:	09 33       	cpi	r16, 0x39	; 57
    bd56:	19 07       	cpc	r17, r25
    bd58:	19 f7       	brne	.-58     	; 0xbd20 <procMessage11+0x30e>
    bd5a:	05 eb       	ldi	r16, 0xB5	; 181
    bd5c:	10 e0       	ldi	r17, 0x00	; 0
    bd5e:	be e4       	ldi	r27, 0x4E	; 78
    bd60:	eb 2e       	mov	r14, r27
    bd62:	bd e0       	ldi	r27, 0x0D	; 13
    bd64:	fb 2e       	mov	r15, r27
    bd66:	6e 01       	movw	r12, r28
    bd68:	08 94       	sec
    bd6a:	c1 1c       	adc	r12, r1
    bd6c:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd6e:	a9 e0       	ldi	r26, 0x09	; 9
    bd70:	aa 2e       	mov	r10, r26
    bd72:	b1 2c       	mov	r11, r1
    bd74:	ac 0e       	add	r10, r28
    bd76:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bd78:	f6 01       	movw	r30, r12
    bd7a:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bd7c:	8d 91       	ld	r24, X+
    bd7e:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd80:	ea 15       	cp	r30, r10
    bd82:	fb 05       	cpc	r31, r11
    bd84:	d9 f7       	brne	.-10     	; 0xbd7c <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd86:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    bd88:	c6 01       	movw	r24, r12
    bd8a:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    bd8e:	c6 01       	movw	r24, r12
    bd90:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		RemDecimal(strProductPrice);
    bd94:	c6 01       	movw	r24, r12
    bd96:	0e 94 b5 21 	call	0x436a	; 0x436a <RemDecimal>
    bd9a:	c8 01       	movw	r24, r16
    bd9c:	b6 01       	movw	r22, r12
    bd9e:	48 e0       	ldi	r20, 0x08	; 8
    bda0:	50 e0       	ldi	r21, 0x00	; 0
    bda2:	2f e9       	ldi	r18, 0x9F	; 159
    bda4:	32 e1       	ldi	r19, 0x12	; 18
    bda6:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    bdaa:	07 5f       	subi	r16, 0xF7	; 247
    bdac:	1f 4f       	sbci	r17, 0xFF	; 255
    bdae:	e8 e0       	ldi	r30, 0x08	; 8
    bdb0:	f0 e0       	ldi	r31, 0x00	; 0
    bdb2:	ee 0e       	add	r14, r30
    bdb4:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    bdb6:	f0 e0       	ldi	r31, 0x00	; 0
    bdb8:	0b 3e       	cpi	r16, 0xEB	; 235
    bdba:	1f 07       	cpc	r17, r31
    bdbc:	e9 f6       	brne	.-70     	; 0xbd78 <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    bdbe:	cb 5a       	subi	r28, 0xAB	; 171
    bdc0:	df 4f       	sbci	r29, 0xFF	; 255
    bdc2:	0f b6       	in	r0, 0x3f	; 63
    bdc4:	f8 94       	cli
    bdc6:	de bf       	out	0x3e, r29	; 62
    bdc8:	0f be       	out	0x3f, r0	; 63
    bdca:	cd bf       	out	0x3d, r28	; 61
    bdcc:	cf 91       	pop	r28
    bdce:	df 91       	pop	r29
    bdd0:	1f 91       	pop	r17
    bdd2:	0f 91       	pop	r16
    bdd4:	ff 90       	pop	r15
    bdd6:	ef 90       	pop	r14
    bdd8:	df 90       	pop	r13
    bdda:	cf 90       	pop	r12
    bddc:	bf 90       	pop	r11
    bdde:	af 90       	pop	r10
    bde0:	08 95       	ret

0000bde2 <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    bde2:	df 92       	push	r13
    bde4:	ef 92       	push	r14
    bde6:	ff 92       	push	r15
    bde8:	0f 93       	push	r16
    bdea:	1f 93       	push	r17
    bdec:	df 93       	push	r29
    bdee:	cf 93       	push	r28
    bdf0:	cd b7       	in	r28, 0x3d	; 61
    bdf2:	de b7       	in	r29, 0x3e	; 62
    bdf4:	64 97       	sbiw	r28, 0x14	; 20
    bdf6:	0f b6       	in	r0, 0x3f	; 63
    bdf8:	f8 94       	cli
    bdfa:	de bf       	out	0x3e, r29	; 62
    bdfc:	0f be       	out	0x3f, r0	; 63
    bdfe:	cd bf       	out	0x3d, r28	; 61
    be00:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    be02:	80 91 39 03 	lds	r24, 0x0339
    be06:	87 30       	cpi	r24, 0x07	; 7
    be08:	09 f4       	brne	.+2      	; 0xbe0c <FCloseShift+0x2a>
    be0a:	a6 c1       	rjmp	.+844    	; 0xc158 <FCloseShift+0x376>
    be0c:	88 30       	cpi	r24, 0x08	; 8
    be0e:	78 f4       	brcc	.+30     	; 0xbe2e <FCloseShift+0x4c>
    be10:	84 30       	cpi	r24, 0x04	; 4
    be12:	09 f4       	brne	.+2      	; 0xbe16 <FCloseShift+0x34>
    be14:	68 c0       	rjmp	.+208    	; 0xbee6 <FCloseShift+0x104>
    be16:	85 30       	cpi	r24, 0x05	; 5
    be18:	18 f4       	brcc	.+6      	; 0xbe20 <FCloseShift+0x3e>
    be1a:	88 23       	and	r24, r24
    be1c:	c1 f0       	breq	.+48     	; 0xbe4e <FCloseShift+0x6c>
    be1e:	22 c2       	rjmp	.+1092   	; 0xc264 <FCloseShift+0x482>
    be20:	85 30       	cpi	r24, 0x05	; 5
    be22:	09 f4       	brne	.+2      	; 0xbe26 <FCloseShift+0x44>
    be24:	a6 c0       	rjmp	.+332    	; 0xbf72 <FCloseShift+0x190>
    be26:	86 30       	cpi	r24, 0x06	; 6
    be28:	09 f0       	breq	.+2      	; 0xbe2c <FCloseShift+0x4a>
    be2a:	1c c2       	rjmp	.+1080   	; 0xc264 <FCloseShift+0x482>
    be2c:	a8 c0       	rjmp	.+336    	; 0xbf7e <FCloseShift+0x19c>
    be2e:	8a 30       	cpi	r24, 0x0A	; 10
    be30:	09 f4       	brne	.+2      	; 0xbe34 <FCloseShift+0x52>
    be32:	d6 c1       	rjmp	.+940    	; 0xc1e0 <FCloseShift+0x3fe>
    be34:	8b 30       	cpi	r24, 0x0B	; 11
    be36:	20 f4       	brcc	.+8      	; 0xbe40 <FCloseShift+0x5e>
    be38:	88 30       	cpi	r24, 0x08	; 8
    be3a:	09 f0       	breq	.+2      	; 0xbe3e <FCloseShift+0x5c>
    be3c:	13 c2       	rjmp	.+1062   	; 0xc264 <FCloseShift+0x482>
    be3e:	92 c1       	rjmp	.+804    	; 0xc164 <FCloseShift+0x382>
    be40:	8b 30       	cpi	r24, 0x0B	; 11
    be42:	09 f4       	brne	.+2      	; 0xbe46 <FCloseShift+0x64>
    be44:	0b c2       	rjmp	.+1046   	; 0xc25c <FCloseShift+0x47a>
    be46:	8c 30       	cpi	r24, 0x0C	; 12
    be48:	09 f0       	breq	.+2      	; 0xbe4c <FCloseShift+0x6a>
    be4a:	0c c2       	rjmp	.+1048   	; 0xc264 <FCloseShift+0x482>
    be4c:	d2 c1       	rjmp	.+932    	; 0xc1f2 <FCloseShift+0x410>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    be4e:	e1 99       	sbic	0x1c, 1	; 28
    be50:	fe cf       	rjmp	.-4      	; 0xbe4e <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    be52:	89 e7       	ldi	r24, 0x79	; 121
    be54:	91 e0       	ldi	r25, 0x01	; 1
    be56:	9f bb       	out	0x1f, r25	; 31
    be58:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    be5a:	e0 9a       	sbi	0x1c, 0	; 28
    be5c:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    be5e:	80 93 76 01 	sts	0x0176, r24
		  IsPumpBusy=False;
    be62:	10 92 38 03 	sts	0x0338, r1
    be66:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    be68:	dd 24       	eor	r13, r13
    be6a:	d3 94       	inc	r13
    be6c:	36 c0       	rjmp	.+108    	; 0xbeda <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    be6e:	0f 2d       	mov	r16, r15
    be70:	10 e0       	ldi	r17, 0x00	; 0
    be72:	f8 01       	movw	r30, r16
    be74:	e9 5d       	subi	r30, 0xD9	; 217
    be76:	fe 4f       	sbci	r31, 0xFE	; 254
    be78:	e0 80       	ld	r14, Z
    be7a:	8e e0       	ldi	r24, 0x0E	; 14
    be7c:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    be80:	e8 16       	cp	r14, r24
    be82:	81 f0       	breq	.+32     	; 0xbea4 <FCloseShift+0xc2>
    be84:	86 e0       	ldi	r24, 0x06	; 6
    be86:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    be8a:	e8 16       	cp	r14, r24
    be8c:	59 f0       	breq	.+22     	; 0xbea4 <FCloseShift+0xc2>
    be8e:	89 e0       	ldi	r24, 0x09	; 9
    be90:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    be94:	e8 16       	cp	r14, r24
    be96:	31 f0       	breq	.+12     	; 0xbea4 <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    be98:	8f 2d       	mov	r24, r15
    be9a:	0e 94 ae 1b 	call	0x375c	; 0x375c <GetPumpID>
    be9e:	66 e0       	ldi	r22, 0x06	; 6
    bea0:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    bea4:	84 e1       	ldi	r24, 0x14	; 20
    bea6:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    beaa:	f8 01       	movw	r30, r16
    beac:	e9 5d       	subi	r30, 0xD9	; 217
    beae:	fe 4f       	sbci	r31, 0xFE	; 254
    beb0:	90 81       	ld	r25, Z
    beb2:	98 17       	cp	r25, r24
    beb4:	31 f4       	brne	.+12     	; 0xbec2 <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    beb6:	8f 2d       	mov	r24, r15
    beb8:	0e 94 ae 1b 	call	0x375c	; 0x375c <GetPumpID>
    bebc:	66 e0       	ldi	r22, 0x06	; 6
    bebe:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    bec2:	89 e0       	ldi	r24, 0x09	; 9
    bec4:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    bec8:	09 5d       	subi	r16, 0xD9	; 217
    beca:	1e 4f       	sbci	r17, 0xFE	; 254
    becc:	d8 01       	movw	r26, r16
    bece:	9c 91       	ld	r25, X
    bed0:	98 17       	cp	r25, r24
    bed2:	11 f4       	brne	.+4      	; 0xbed8 <FCloseShift+0xf6>
			       IsPumpBusy=True;
    bed4:	d0 92 38 03 	sts	0x0338, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    bed8:	f3 94       	inc	r15
    beda:	80 91 76 01 	lds	r24, 0x0176
    bede:	f8 16       	cp	r15, r24
    bee0:	30 f2       	brcs	.-116    	; 0xbe6e <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    bee2:	84 e0       	ldi	r24, 0x04	; 4
    bee4:	b8 c1       	rjmp	.+880    	; 0xc256 <FCloseShift+0x474>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    bee6:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    beea:	81 e0       	ldi	r24, 0x01	; 1
    beec:	61 e0       	ldi	r22, 0x01	; 1
    beee:	42 ec       	ldi	r20, 0xC2	; 194
    bef0:	54 e1       	ldi	r21, 0x14	; 20
    bef2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    bef6:	00 91 76 01 	lds	r16, 0x0176
    befa:	10 e0       	ldi	r17, 0x00	; 0
    befc:	87 e2       	ldi	r24, 0x27	; 39
    befe:	91 e0       	ldi	r25, 0x01	; 1
    bf00:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <CountTotalizerSatus>
    bf04:	00 d0       	rcall	.+0      	; 0xbf06 <FCloseShift+0x124>
    bf06:	00 d0       	rcall	.+0      	; 0xbf08 <FCloseShift+0x126>
    bf08:	00 d0       	rcall	.+0      	; 0xbf0a <FCloseShift+0x128>
    bf0a:	ed b7       	in	r30, 0x3d	; 61
    bf0c:	fe b7       	in	r31, 0x3e	; 62
    bf0e:	31 96       	adiw	r30, 0x01	; 1
    bf10:	7e 01       	movw	r14, r28
    bf12:	08 94       	sec
    bf14:	e1 1c       	adc	r14, r1
    bf16:	f1 1c       	adc	r15, r1
    bf18:	ad b7       	in	r26, 0x3d	; 61
    bf1a:	be b7       	in	r27, 0x3e	; 62
    bf1c:	12 96       	adiw	r26, 0x02	; 2
    bf1e:	fc 92       	st	X, r15
    bf20:	ee 92       	st	-X, r14
    bf22:	11 97       	sbiw	r26, 0x01	; 1
    bf24:	24 eb       	ldi	r18, 0xB4	; 180
    bf26:	34 e1       	ldi	r19, 0x14	; 20
    bf28:	33 83       	std	Z+3, r19	; 0x03
    bf2a:	22 83       	std	Z+2, r18	; 0x02
    bf2c:	08 1b       	sub	r16, r24
    bf2e:	11 09       	sbc	r17, r1
    bf30:	15 83       	std	Z+5, r17	; 0x05
    bf32:	04 83       	std	Z+4, r16	; 0x04
    bf34:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    bf38:	ed b7       	in	r30, 0x3d	; 61
    bf3a:	fe b7       	in	r31, 0x3e	; 62
    bf3c:	36 96       	adiw	r30, 0x06	; 6
    bf3e:	0f b6       	in	r0, 0x3f	; 63
    bf40:	f8 94       	cli
    bf42:	fe bf       	out	0x3e, r31	; 62
    bf44:	0f be       	out	0x3f, r0	; 63
    bf46:	ed bf       	out	0x3d, r30	; 61
    bf48:	82 e0       	ldi	r24, 0x02	; 2
    bf4a:	61 e0       	ldi	r22, 0x01	; 1
    bf4c:	a7 01       	movw	r20, r14
    bf4e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>


          IsNewPumpStatus=True;
    bf52:	11 e0       	ldi	r17, 0x01	; 1
    bf54:	10 93 26 01 	sts	0x0126, r17
		  DisplayPumpStatus(); 
    bf58:	0e 94 16 41 	call	0x822c	; 0x822c <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    bf5c:	95 e0       	ldi	r25, 0x05	; 5
    bf5e:	90 93 b1 07 	sts	0x07B1, r25
	 PoolMsg=plMsg;
    bf62:	82 e1       	ldi	r24, 0x12	; 18
    bf64:	80 93 d9 0d 	sts	0x0DD9, r24
     IsControlPooling=True;
    bf68:	10 93 ad 01 	sts	0x01AD, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    bf6c:	90 93 39 03 	sts	0x0339, r25
    bf70:	79 c1       	rjmp	.+754    	; 0xc264 <FCloseShift+0x482>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    bf72:	0e 94 16 41 	call	0x822c	; 0x822c <DisplayPumpStatus>
		  TimDisplay=0;         
    bf76:	10 92 bc 01 	sts	0x01BC, r1
          stCloseShift=csWaitTotalizerComplete;
    bf7a:	86 e0       	ldi	r24, 0x06	; 6
    bf7c:	6c c1       	rjmp	.+728    	; 0xc256 <FCloseShift+0x474>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    bf7e:	81 e0       	ldi	r24, 0x01	; 1
    bf80:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    bf84:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    bf86:	80 91 26 01 	lds	r24, 0x0126
    bf8a:	81 30       	cpi	r24, 0x01	; 1
    bf8c:	89 f5       	brne	.+98     	; 0xbff0 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    bf8e:	00 91 76 01 	lds	r16, 0x0176
    bf92:	10 e0       	ldi	r17, 0x00	; 0
    bf94:	87 e2       	ldi	r24, 0x27	; 39
    bf96:	91 e0       	ldi	r25, 0x01	; 1
    bf98:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <CountTotalizerSatus>
    bf9c:	00 d0       	rcall	.+0      	; 0xbf9e <FCloseShift+0x1bc>
    bf9e:	00 d0       	rcall	.+0      	; 0xbfa0 <FCloseShift+0x1be>
    bfa0:	00 d0       	rcall	.+0      	; 0xbfa2 <FCloseShift+0x1c0>
    bfa2:	ed b7       	in	r30, 0x3d	; 61
    bfa4:	fe b7       	in	r31, 0x3e	; 62
    bfa6:	31 96       	adiw	r30, 0x01	; 1
    bfa8:	7e 01       	movw	r14, r28
    bfaa:	08 94       	sec
    bfac:	e1 1c       	adc	r14, r1
    bfae:	f1 1c       	adc	r15, r1
    bfb0:	ad b7       	in	r26, 0x3d	; 61
    bfb2:	be b7       	in	r27, 0x3e	; 62
    bfb4:	12 96       	adiw	r26, 0x02	; 2
    bfb6:	fc 92       	st	X, r15
    bfb8:	ee 92       	st	-X, r14
    bfba:	11 97       	sbiw	r26, 0x01	; 1
    bfbc:	26 ea       	ldi	r18, 0xA6	; 166
    bfbe:	34 e1       	ldi	r19, 0x14	; 20
    bfc0:	33 83       	std	Z+3, r19	; 0x03
    bfc2:	22 83       	std	Z+2, r18	; 0x02
    bfc4:	08 1b       	sub	r16, r24
    bfc6:	11 09       	sbc	r17, r1
    bfc8:	15 83       	std	Z+5, r17	; 0x05
    bfca:	04 83       	std	Z+4, r16	; 0x04
    bfcc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  lcd_print(2,1,lcdteks);
    bfd0:	ed b7       	in	r30, 0x3d	; 61
    bfd2:	fe b7       	in	r31, 0x3e	; 62
    bfd4:	36 96       	adiw	r30, 0x06	; 6
    bfd6:	0f b6       	in	r0, 0x3f	; 63
    bfd8:	f8 94       	cli
    bfda:	fe bf       	out	0x3e, r31	; 62
    bfdc:	0f be       	out	0x3f, r0	; 63
    bfde:	ed bf       	out	0x3d, r30	; 61
    bfe0:	82 e0       	ldi	r24, 0x02	; 2
    bfe2:	61 e0       	ldi	r22, 0x01	; 1
    bfe4:	a7 01       	movw	r20, r14
    bfe6:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    bfea:	85 e0       	ldi	r24, 0x05	; 5
    bfec:	80 93 39 03 	sts	0x0339, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    bff0:	87 e2       	ldi	r24, 0x27	; 39
    bff2:	91 e0       	ldi	r25, 0x01	; 1
    bff4:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <CountTotalizerSatus>
    bff8:	90 91 76 01 	lds	r25, 0x0176
    bffc:	89 17       	cp	r24, r25
    bffe:	a0 f0       	brcs	.+40     	; 0xc028 <FCloseShift+0x246>
    c000:	80 91 bc 01 	lds	r24, 0x01BC
    c004:	86 30       	cpi	r24, 0x06	; 6
    c006:	80 f0       	brcs	.+32     	; 0xc028 <FCloseShift+0x246>
    c008:	10 e0       	ldi	r17, 0x00	; 0
    c00a:	07 c0       	rjmp	.+14     	; 0xc01a <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c00c:	81 2f       	mov	r24, r17
    c00e:	0e 94 ae 1b 	call	0x375c	; 0x375c <GetPumpID>
    c012:	66 e0       	ldi	r22, 0x06	; 6
    c014:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    c018:	1f 5f       	subi	r17, 0xFF	; 255
    c01a:	80 91 76 01 	lds	r24, 0x0176
    c01e:	18 17       	cp	r17, r24
    c020:	a8 f3       	brcs	.-22     	; 0xc00c <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    c022:	88 e0       	ldi	r24, 0x08	; 8
    c024:	80 93 39 03 	sts	0x0339, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    c028:	80 91 bc 01 	lds	r24, 0x01BC
    c02c:	80 31       	cpi	r24, 0x10	; 16
    c02e:	08 f4       	brcc	.+2      	; 0xc032 <FCloseShift+0x250>
    c030:	67 c0       	rjmp	.+206    	; 0xc100 <FCloseShift+0x31e>
    c032:	80 91 38 03 	lds	r24, 0x0338
    c036:	81 30       	cpi	r24, 0x01	; 1
    c038:	09 f4       	brne	.+2      	; 0xc03c <FCloseShift+0x25a>
    c03a:	62 c0       	rjmp	.+196    	; 0xc100 <FCloseShift+0x31e>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    c03c:	87 e2       	ldi	r24, 0x27	; 39
    c03e:	91 e0       	ldi	r25, 0x01	; 1
    c040:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <CountNoPumpSatus>
    c044:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c046:	e1 99       	sbic	0x1c, 1	; 28
    c048:	fe cf       	rjmp	.-4      	; 0xc046 <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c04a:	89 e7       	ldi	r24, 0x79	; 121
    c04c:	91 e0       	ldi	r25, 0x01	; 1
    c04e:	9f bb       	out	0x1f, r25	; 31
    c050:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c052:	e0 9a       	sbi	0x1c, 0	; 28
    c054:	8d b3       	in	r24, 0x1d	; 29
    c056:	28 17       	cp	r18, r24
    c058:	08 f4       	brcc	.+2      	; 0xc05c <FCloseShift+0x27a>
    c05a:	52 c0       	rjmp	.+164    	; 0xc100 <FCloseShift+0x31e>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    c05c:	00 91 76 01 	lds	r16, 0x0176
    c060:	10 e0       	ldi	r17, 0x00	; 0
    c062:	87 e2       	ldi	r24, 0x27	; 39
    c064:	91 e0       	ldi	r25, 0x01	; 1
    c066:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <CountNoPumpSatus>
    c06a:	00 d0       	rcall	.+0      	; 0xc06c <FCloseShift+0x28a>
    c06c:	00 d0       	rcall	.+0      	; 0xc06e <FCloseShift+0x28c>
    c06e:	00 d0       	rcall	.+0      	; 0xc070 <FCloseShift+0x28e>
    c070:	ed b7       	in	r30, 0x3d	; 61
    c072:	fe b7       	in	r31, 0x3e	; 62
    c074:	31 96       	adiw	r30, 0x01	; 1
    c076:	7e 01       	movw	r14, r28
    c078:	08 94       	sec
    c07a:	e1 1c       	adc	r14, r1
    c07c:	f1 1c       	adc	r15, r1
    c07e:	ad b7       	in	r26, 0x3d	; 61
    c080:	be b7       	in	r27, 0x3e	; 62
    c082:	12 96       	adiw	r26, 0x02	; 2
    c084:	fc 92       	st	X, r15
    c086:	ee 92       	st	-X, r14
    c088:	11 97       	sbiw	r26, 0x01	; 1
    c08a:	22 e9       	ldi	r18, 0x92	; 146
    c08c:	34 e1       	ldi	r19, 0x14	; 20
    c08e:	33 83       	std	Z+3, r19	; 0x03
    c090:	22 83       	std	Z+2, r18	; 0x02
    c092:	08 1b       	sub	r16, r24
    c094:	11 09       	sbc	r17, r1
    c096:	15 83       	std	Z+5, r17	; 0x05
    c098:	04 83       	std	Z+4, r16	; 0x04
    c09a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c09e:	ed b7       	in	r30, 0x3d	; 61
    c0a0:	fe b7       	in	r31, 0x3e	; 62
    c0a2:	36 96       	adiw	r30, 0x06	; 6
    c0a4:	0f b6       	in	r0, 0x3f	; 63
    c0a6:	f8 94       	cli
    c0a8:	fe bf       	out	0x3e, r31	; 62
    c0aa:	0f be       	out	0x3f, r0	; 63
    c0ac:	ed bf       	out	0x3d, r30	; 61
    c0ae:	83 e0       	ldi	r24, 0x03	; 3
    c0b0:	61 e0       	ldi	r22, 0x01	; 1
    c0b2:	a7 01       	movw	r20, r14
    c0b4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    c0b8:	10 e0       	ldi	r17, 0x00	; 0
    c0ba:	11 c0       	rjmp	.+34     	; 0xc0de <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c0bc:	84 e1       	ldi	r24, 0x14	; 20
    c0be:	0e 94 ad 12 	call	0x255a	; 0x255a <GetPumpStatusLabel>
    c0c2:	e1 2f       	mov	r30, r17
    c0c4:	f0 e0       	ldi	r31, 0x00	; 0
    c0c6:	e9 5d       	subi	r30, 0xD9	; 217
    c0c8:	fe 4f       	sbci	r31, 0xFE	; 254
    c0ca:	90 81       	ld	r25, Z
    c0cc:	98 17       	cp	r25, r24
    c0ce:	31 f4       	brne	.+12     	; 0xc0dc <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c0d0:	81 2f       	mov	r24, r17
    c0d2:	0e 94 ae 1b 	call	0x375c	; 0x375c <GetPumpID>
    c0d6:	66 e0       	ldi	r22, 0x06	; 6
    c0d8:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    c0dc:	1f 5f       	subi	r17, 0xFF	; 255
    c0de:	80 91 76 01 	lds	r24, 0x0176
    c0e2:	18 17       	cp	r17, r24
    c0e4:	58 f3       	brcs	.-42     	; 0xc0bc <FCloseShift+0x2da>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c0e6:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c0e8:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c0ea:	81 e0       	ldi	r24, 0x01	; 1
    c0ec:	90 e0       	ldi	r25, 0x00	; 0
    c0ee:	90 93 ed 01 	sts	0x01ED, r25
    c0f2:	80 93 ec 01 	sts	0x01EC, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    c0f6:	10 92 bc 01 	sts	0x01BC, r1
			  stCloseShift=csNoPumpFound;		     
    c0fa:	87 e0       	ldi	r24, 0x07	; 7
    c0fc:	80 93 39 03 	sts	0x0339, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    c100:	f7 ee       	ldi	r31, 0xE7	; 231
    c102:	df 16       	cp	r13, r31
    c104:	09 f0       	breq	.+2      	; 0xc108 <FCloseShift+0x326>
    c106:	ae c0       	rjmp	.+348    	; 0xc264 <FCloseShift+0x482>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    c108:	00 d0       	rcall	.+0      	; 0xc10a <FCloseShift+0x328>
    c10a:	00 d0       	rcall	.+0      	; 0xc10c <FCloseShift+0x32a>
    c10c:	8e 01       	movw	r16, r28
    c10e:	0f 5f       	subi	r16, 0xFF	; 255
    c110:	1f 4f       	sbci	r17, 0xFF	; 255
    c112:	ad b7       	in	r26, 0x3d	; 61
    c114:	be b7       	in	r27, 0x3e	; 62
    c116:	12 96       	adiw	r26, 0x02	; 2
    c118:	1c 93       	st	X, r17
    c11a:	0e 93       	st	-X, r16
    c11c:	11 97       	sbiw	r26, 0x01	; 1
    c11e:	8b e8       	ldi	r24, 0x8B	; 139
    c120:	94 e1       	ldi	r25, 0x14	; 20
    c122:	14 96       	adiw	r26, 0x04	; 4
    c124:	9c 93       	st	X, r25
    c126:	8e 93       	st	-X, r24
    c128:	13 97       	sbiw	r26, 0x03	; 3
    c12a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c12e:	0f 90       	pop	r0
    c130:	0f 90       	pop	r0
    c132:	0f 90       	pop	r0
    c134:	0f 90       	pop	r0
    c136:	83 e0       	ldi	r24, 0x03	; 3
    c138:	61 e0       	ldi	r22, 0x01	; 1
    c13a:	a8 01       	movw	r20, r16
    c13c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c140:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c142:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c144:	81 e0       	ldi	r24, 0x01	; 1
    c146:	90 e0       	ldi	r25, 0x00	; 0
    c148:	90 93 ed 01 	sts	0x01ED, r25
    c14c:	80 93 ec 01 	sts	0x01EC, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    c150:	10 92 bc 01 	sts	0x01BC, r1
			  stCloseShift=csNoPumpFound;		     		  
    c154:	87 e0       	ldi	r24, 0x07	; 7
    c156:	7f c0       	rjmp	.+254    	; 0xc256 <FCloseShift+0x474>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    c158:	80 91 bc 01 	lds	r24, 0x01BC
    c15c:	8b 30       	cpi	r24, 0x0B	; 11
    c15e:	08 f4       	brcc	.+2      	; 0xc162 <FCloseShift+0x380>
    c160:	81 c0       	rjmp	.+258    	; 0xc264 <FCloseShift+0x482>
    c162:	78 c0       	rjmp	.+240    	; 0xc254 <FCloseShift+0x472>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    c164:	81 e0       	ldi	r24, 0x01	; 1
    c166:	61 e0       	ldi	r22, 0x01	; 1
    c168:	48 e7       	ldi	r20, 0x78	; 120
    c16a:	54 e1       	ldi	r21, 0x14	; 20
    c16c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    c170:	0f eb       	ldi	r16, 0xBF	; 191
    c172:	15 e0       	ldi	r17, 0x05	; 5
    c174:	34 ea       	ldi	r19, 0xA4	; 164
    c176:	e3 2e       	mov	r14, r19
    c178:	3a e0       	ldi	r19, 0x0A	; 10
    c17a:	f3 2e       	mov	r15, r19
    c17c:	80 e0       	ldi	r24, 0x00	; 0
    c17e:	b8 01       	movw	r22, r16
    c180:	a7 01       	movw	r20, r14
    c182:	0e 94 2b b3 	call	0x16656	; 0x16656 <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    c186:	ed b7       	in	r30, 0x3d	; 61
    c188:	fe b7       	in	r31, 0x3e	; 62
    c18a:	38 97       	sbiw	r30, 0x08	; 8
    c18c:	0f b6       	in	r0, 0x3f	; 63
    c18e:	f8 94       	cli
    c190:	fe bf       	out	0x3e, r31	; 62
    c192:	0f be       	out	0x3f, r0	; 63
    c194:	ed bf       	out	0x3d, r30	; 61
    c196:	31 96       	adiw	r30, 0x01	; 1
    c198:	88 e9       	ldi	r24, 0x98	; 152
    c19a:	99 e0       	ldi	r25, 0x09	; 9
    c19c:	ad b7       	in	r26, 0x3d	; 61
    c19e:	be b7       	in	r27, 0x3e	; 62
    c1a0:	12 96       	adiw	r26, 0x02	; 2
    c1a2:	9c 93       	st	X, r25
    c1a4:	8e 93       	st	-X, r24
    c1a6:	11 97       	sbiw	r26, 0x01	; 1
    c1a8:	82 e7       	ldi	r24, 0x72	; 114
    c1aa:	94 e1       	ldi	r25, 0x14	; 20
    c1ac:	93 83       	std	Z+3, r25	; 0x03
    c1ae:	82 83       	std	Z+2, r24	; 0x02
    c1b0:	15 83       	std	Z+5, r17	; 0x05
    c1b2:	04 83       	std	Z+4, r16	; 0x04
    c1b4:	f7 82       	std	Z+7, r15	; 0x07
    c1b6:	e6 82       	std	Z+6, r14	; 0x06
    c1b8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  IsGenerateReport=True;
    c1bc:	81 e0       	ldi	r24, 0x01	; 1
    c1be:	80 93 af 01 	sts	0x01AF, r24
		  IsFinishPrintingTotalizer=False;
    c1c2:	10 92 b0 01 	sts	0x01B0, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    c1c6:	8a e0       	ldi	r24, 0x0A	; 10
    c1c8:	80 93 39 03 	sts	0x0339, r24
    c1cc:	80 e0       	ldi	r24, 0x00	; 0
    c1ce:	ed b7       	in	r30, 0x3d	; 61
    c1d0:	fe b7       	in	r31, 0x3e	; 62
    c1d2:	38 96       	adiw	r30, 0x08	; 8
    c1d4:	0f b6       	in	r0, 0x3f	; 63
    c1d6:	f8 94       	cli
    c1d8:	fe bf       	out	0x3e, r31	; 62
    c1da:	0f be       	out	0x3f, r0	; 63
    c1dc:	ed bf       	out	0x3d, r30	; 61
    c1de:	43 c0       	rjmp	.+134    	; 0xc266 <FCloseShift+0x484>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    c1e0:	80 91 b0 01 	lds	r24, 0x01B0
    c1e4:	81 30       	cpi	r24, 0x01	; 1
    c1e6:	09 f0       	breq	.+2      	; 0xc1ea <FCloseShift+0x408>
    c1e8:	3d c0       	rjmp	.+122    	; 0xc264 <FCloseShift+0x482>
		      IsFinishPrintingTotalizer=False;
    c1ea:	10 92 b0 01 	sts	0x01B0, r1
		      stCloseShift=csDumpShift;
    c1ee:	8c e0       	ldi	r24, 0x0C	; 12
    c1f0:	32 c0       	rjmp	.+100    	; 0xc256 <FCloseShift+0x474>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    c1f2:	81 e0       	ldi	r24, 0x01	; 1
    c1f4:	61 e0       	ldi	r22, 0x01	; 1
    c1f6:	4e e5       	ldi	r20, 0x5E	; 94
    c1f8:	54 e1       	ldi	r21, 0x14	; 20
    c1fa:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    c1fe:	12 30       	cpi	r17, 0x02	; 2
    c200:	71 f4       	brne	.+28     	; 0xc21e <FCloseShift+0x43c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c202:	e1 99       	sbic	0x1c, 1	; 28
    c204:	fe cf       	rjmp	.-4      	; 0xc202 <FCloseShift+0x420>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c206:	2f e6       	ldi	r18, 0x6F	; 111
    c208:	31 e0       	ldi	r19, 0x01	; 1
    c20a:	3f bb       	out	0x1f, r19	; 31
    c20c:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c20e:	e0 9a       	sbi	0x1c, 0	; 28
    c210:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c212:	e1 99       	sbic	0x1c, 1	; 28
    c214:	fe cf       	rjmp	.-4      	; 0xc212 <FCloseShift+0x430>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c216:	3f bb       	out	0x1f, r19	; 31
    c218:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    c21a:	8f 5f       	subi	r24, 0xFF	; 255
    c21c:	09 c0       	rjmp	.+18     	; 0xc230 <FCloseShift+0x44e>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    c21e:	11 30       	cpi	r17, 0x01	; 1
    c220:	69 f4       	brne	.+26     	; 0xc23c <FCloseShift+0x45a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c222:	e1 99       	sbic	0x1c, 1	; 28
    c224:	fe cf       	rjmp	.-4      	; 0xc222 <FCloseShift+0x440>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c226:	8f e6       	ldi	r24, 0x6F	; 111
    c228:	91 e0       	ldi	r25, 0x01	; 1
    c22a:	9f bb       	out	0x1f, r25	; 31
    c22c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c22e:	81 e0       	ldi	r24, 0x01	; 1
    c230:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c232:	0f b6       	in	r0, 0x3f	; 63
    c234:	f8 94       	cli
    c236:	e2 9a       	sbi	0x1c, 2	; 28
    c238:	e1 9a       	sbi	0x1c, 1	; 28
    c23a:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    c23c:	0e 94 59 45 	call	0x8ab2	; 0x8ab2 <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c240:	83 e7       	ldi	r24, 0x73	; 115
    c242:	98 e0       	ldi	r25, 0x08	; 8
    c244:	68 e9       	ldi	r22, 0x98	; 152
    c246:	79 e0       	ldi	r23, 0x09	; 9
    c248:	44 e1       	ldi	r20, 0x14	; 20
    c24a:	50 e0       	ldi	r21, 0x00	; 0
    c24c:	2f e9       	ldi	r18, 0x9F	; 159
    c24e:	32 e1       	ldi	r19, 0x12	; 18
    c250:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    c254:	8b e0       	ldi	r24, 0x0B	; 11
    c256:	80 93 39 03 	sts	0x0339, r24
    c25a:	04 c0       	rjmp	.+8      	; 0xc264 <FCloseShift+0x482>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    c25c:	10 92 39 03 	sts	0x0339, r1
    c260:	81 e0       	ldi	r24, 0x01	; 1
    c262:	01 c0       	rjmp	.+2      	; 0xc266 <FCloseShift+0x484>
    c264:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //_uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    c266:	64 96       	adiw	r28, 0x14	; 20
    c268:	0f b6       	in	r0, 0x3f	; 63
    c26a:	f8 94       	cli
    c26c:	de bf       	out	0x3e, r29	; 62
    c26e:	0f be       	out	0x3f, r0	; 63
    c270:	cd bf       	out	0x3d, r28	; 61
    c272:	cf 91       	pop	r28
    c274:	df 91       	pop	r29
    c276:	1f 91       	pop	r17
    c278:	0f 91       	pop	r16
    c27a:	ff 90       	pop	r15
    c27c:	ef 90       	pop	r14
    c27e:	df 90       	pop	r13
    c280:	08 95       	ret

0000c282 <FMenuShift>:
     char SubMenu,KeyChar,KeyPressed;

     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    c282:	80 91 3a 03 	lds	r24, 0x033A
    c286:	82 30       	cpi	r24, 0x02	; 2
    c288:	09 f4       	brne	.+2      	; 0xc28c <FMenuShift+0xa>
    c28a:	48 c0       	rjmp	.+144    	; 0xc31c <FMenuShift+0x9a>
    c28c:	83 30       	cpi	r24, 0x03	; 3
    c28e:	30 f4       	brcc	.+12     	; 0xc29c <FMenuShift+0x1a>
    c290:	88 23       	and	r24, r24
    c292:	69 f0       	breq	.+26     	; 0xc2ae <FMenuShift+0x2c>
    c294:	81 30       	cpi	r24, 0x01	; 1
    c296:	09 f0       	breq	.+2      	; 0xc29a <FMenuShift+0x18>
    c298:	50 c0       	rjmp	.+160    	; 0xc33a <FMenuShift+0xb8>
    c29a:	25 c0       	rjmp	.+74     	; 0xc2e6 <FMenuShift+0x64>
    c29c:	84 30       	cpi	r24, 0x04	; 4
    c29e:	09 f4       	brne	.+2      	; 0xc2a2 <FMenuShift+0x20>
    c2a0:	4c c0       	rjmp	.+152    	; 0xc33a <FMenuShift+0xb8>
    c2a2:	84 30       	cpi	r24, 0x04	; 4
    c2a4:	e8 f1       	brcs	.+122    	; 0xc320 <FMenuShift+0x9e>
    c2a6:	85 30       	cpi	r24, 0x05	; 5
    c2a8:	09 f0       	breq	.+2      	; 0xc2ac <FMenuShift+0x2a>
    c2aa:	47 c0       	rjmp	.+142    	; 0xc33a <FMenuShift+0xb8>
    c2ac:	42 c0       	rjmp	.+132    	; 0xc332 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    c2ae:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    c2b2:	81 e0       	ldi	r24, 0x01	; 1
    c2b4:	61 e0       	ldi	r22, 0x01	; 1
    c2b6:	41 ef       	ldi	r20, 0xF1	; 241
    c2b8:	54 e1       	ldi	r21, 0x14	; 20
    c2ba:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    c2be:	82 e0       	ldi	r24, 0x02	; 2
    c2c0:	61 e0       	ldi	r22, 0x01	; 1
    c2c2:	43 ee       	ldi	r20, 0xE3	; 227
    c2c4:	54 e1       	ldi	r21, 0x14	; 20
    c2c6:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    c2ca:	83 e0       	ldi	r24, 0x03	; 3
    c2cc:	61 e0       	ldi	r22, 0x01	; 1
    c2ce:	45 ed       	ldi	r20, 0xD5	; 213
    c2d0:	54 e1       	ldi	r21, 0x14	; 20
    c2d2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    c2d6:	84 e0       	ldi	r24, 0x04	; 4
    c2d8:	61 e0       	ldi	r22, 0x01	; 1
    c2da:	4e ec       	ldi	r20, 0xCE	; 206
    c2dc:	54 e1       	ldi	r21, 0x14	; 20
    c2de:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stMenuShift=msSelectShift;
    c2e2:	81 e0       	ldi	r24, 0x01	; 1
    c2e4:	18 c0       	rjmp	.+48     	; 0xc316 <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    c2e6:	81 e0       	ldi	r24, 0x01	; 1
    c2e8:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    c2ec:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
          switch(KeyChar){
    c2f0:	82 33       	cpi	r24, 0x32	; 50
    c2f2:	61 f0       	breq	.+24     	; 0xc30c <FMenuShift+0x8a>
    c2f4:	83 33       	cpi	r24, 0x33	; 51
    c2f6:	28 f4       	brcc	.+10     	; 0xc302 <FMenuShift+0x80>
    c2f8:	8a 32       	cpi	r24, 0x2A	; 42
    c2fa:	61 f0       	breq	.+24     	; 0xc314 <FMenuShift+0x92>
    c2fc:	81 33       	cpi	r24, 0x31	; 49
    c2fe:	e9 f4       	brne	.+58     	; 0xc33a <FMenuShift+0xb8>
    c300:	03 c0       	rjmp	.+6      	; 0xc308 <FMenuShift+0x86>
    c302:	83 33       	cpi	r24, 0x33	; 51
    c304:	d1 f4       	brne	.+52     	; 0xc33a <FMenuShift+0xb8>
    c306:	04 c0       	rjmp	.+8      	; 0xc310 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    c308:	82 e0       	ldi	r24, 0x02	; 2
    c30a:	05 c0       	rjmp	.+10     	; 0xc316 <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    c30c:	83 e0       	ldi	r24, 0x03	; 3
    c30e:	03 c0       	rjmp	.+6      	; 0xc316 <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    c310:	84 e0       	ldi	r24, 0x04	; 4
    c312:	01 c0       	rjmp	.+2      	; 0xc316 <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    c314:	85 e0       	ldi	r24, 0x05	; 5
    c316:	80 93 3a 03 	sts	0x033A, r24
    c31a:	09 c0       	rjmp	.+18     	; 0xc32e <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    c31c:	82 e0       	ldi	r24, 0x02	; 2
    c31e:	01 c0       	rjmp	.+2      	; 0xc322 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    c320:	81 e0       	ldi	r24, 0x01	; 1
    c322:	0e 94 f1 5e 	call	0xbde2	; 0xbde2 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    c326:	81 30       	cpi	r24, 0x01	; 1
    c328:	41 f4       	brne	.+16     	; 0xc33a <FMenuShift+0xb8>
    c32a:	10 92 3a 03 	sts	0x033A, r1
    c32e:	80 e0       	ldi	r24, 0x00	; 0
    c330:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    c332:	10 92 3a 03 	sts	0x033A, r1
    c336:	81 e0       	ldi	r24, 0x01	; 1
    c338:	08 95       	ret
    c33a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    c33c:	08 95       	ret

0000c33e <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    c33e:	cf 92       	push	r12
    c340:	df 92       	push	r13
    c342:	ef 92       	push	r14
    c344:	ff 92       	push	r15
    c346:	0f 93       	push	r16
    c348:	1f 93       	push	r17
    c34a:	df 93       	push	r29
    c34c:	cf 93       	push	r28
    c34e:	cd b7       	in	r28, 0x3d	; 61
    c350:	de b7       	in	r29, 0x3e	; 62
    c352:	64 97       	sbiw	r28, 0x14	; 20
    c354:	0f b6       	in	r0, 0x3f	; 63
    c356:	f8 94       	cli
    c358:	de bf       	out	0x3e, r29	; 62
    c35a:	0f be       	out	0x3f, r0	; 63
    c35c:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    c35e:	5f eb       	ldi	r21, 0xBF	; 191
    c360:	e5 2e       	mov	r14, r21
    c362:	55 e0       	ldi	r21, 0x05	; 5
    c364:	f5 2e       	mov	r15, r21
    c366:	44 ea       	ldi	r20, 0xA4	; 164
    c368:	c4 2e       	mov	r12, r20
    c36a:	4a e0       	ldi	r20, 0x0A	; 10
    c36c:	d4 2e       	mov	r13, r20
    c36e:	80 e0       	ldi	r24, 0x00	; 0
    c370:	b7 01       	movw	r22, r14
    c372:	a6 01       	movw	r20, r12
    c374:	0e 94 2b b3 	call	0x16656	; 0x16656 <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    c378:	8d b7       	in	r24, 0x3d	; 61
    c37a:	9e b7       	in	r25, 0x3e	; 62
    c37c:	08 97       	sbiw	r24, 0x08	; 8
    c37e:	0f b6       	in	r0, 0x3f	; 63
    c380:	f8 94       	cli
    c382:	9e bf       	out	0x3e, r25	; 62
    c384:	0f be       	out	0x3f, r0	; 63
    c386:	8d bf       	out	0x3d, r24	; 61
    c388:	ed b7       	in	r30, 0x3d	; 61
    c38a:	fe b7       	in	r31, 0x3e	; 62
    c38c:	31 96       	adiw	r30, 0x01	; 1
    c38e:	8e 01       	movw	r16, r28
    c390:	0f 5f       	subi	r16, 0xFF	; 255
    c392:	1f 4f       	sbci	r17, 0xFF	; 255
    c394:	ad b7       	in	r26, 0x3d	; 61
    c396:	be b7       	in	r27, 0x3e	; 62
    c398:	12 96       	adiw	r26, 0x02	; 2
    c39a:	1c 93       	st	X, r17
    c39c:	0e 93       	st	-X, r16
    c39e:	11 97       	sbiw	r26, 0x01	; 1
    c3a0:	89 e5       	ldi	r24, 0x59	; 89
    c3a2:	9b e1       	ldi	r25, 0x1B	; 27
    c3a4:	93 83       	std	Z+3, r25	; 0x03
    c3a6:	82 83       	std	Z+2, r24	; 0x02
    c3a8:	f5 82       	std	Z+5, r15	; 0x05
    c3aa:	e4 82       	std	Z+4, r14	; 0x04
    c3ac:	d7 82       	std	Z+7, r13	; 0x07
    c3ae:	c6 82       	std	Z+6, r12	; 0x06
    c3b0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    c3b4:	8d b7       	in	r24, 0x3d	; 61
    c3b6:	9e b7       	in	r25, 0x3e	; 62
    c3b8:	08 96       	adiw	r24, 0x08	; 8
    c3ba:	0f b6       	in	r0, 0x3f	; 63
    c3bc:	f8 94       	cli
    c3be:	9e bf       	out	0x3e, r25	; 62
    c3c0:	0f be       	out	0x3f, r0	; 63
    c3c2:	8d bf       	out	0x3d, r24	; 61
    c3c4:	82 e0       	ldi	r24, 0x02	; 2
    c3c6:	61 e0       	ldi	r22, 0x01	; 1
    c3c8:	a8 01       	movw	r20, r16
    c3ca:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
}
    c3ce:	64 96       	adiw	r28, 0x14	; 20
    c3d0:	0f b6       	in	r0, 0x3f	; 63
    c3d2:	f8 94       	cli
    c3d4:	de bf       	out	0x3e, r29	; 62
    c3d6:	0f be       	out	0x3f, r0	; 63
    c3d8:	cd bf       	out	0x3d, r28	; 61
    c3da:	cf 91       	pop	r28
    c3dc:	df 91       	pop	r29
    c3de:	1f 91       	pop	r17
    c3e0:	0f 91       	pop	r16
    c3e2:	ff 90       	pop	r15
    c3e4:	ef 90       	pop	r14
    c3e6:	df 90       	pop	r13
    c3e8:	cf 90       	pop	r12
    c3ea:	08 95       	ret

0000c3ec <_menu_operator>:
}

void _menu_operator(void){
	char __result;

	__max_string = _MAX_OPP;
    c3ec:	82 e1       	ldi	r24, 0x12	; 18
    c3ee:	80 93 db 03 	sts	0x03DB, r24
	__chr_count = 0;
    c3f2:	10 92 da 03 	sts	0x03DA, r1
	__buf_string[0] = '\0';
    c3f6:	10 92 b9 0e 	sts	0x0EB9, r1

	lcd_clear();
    c3fa:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	lcd_printf(1, 1, PSTR("OPERATOR :"));
    c3fe:	81 e0       	ldi	r24, 0x01	; 1
    c400:	61 e0       	ldi	r22, 0x01	; 1
    c402:	4d eb       	ldi	r20, 0xBD	; 189
    c404:	5b e0       	ldi	r21, 0x0B	; 11
    c406:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c40a:	84 e0       	ldi	r24, 0x04	; 4
    c40c:	61 e0       	ldi	r22, 0x01	; 1
    c40e:	48 ea       	ldi	r20, 0xA8	; 168
    c410:	5b e0       	ldi	r21, 0x0B	; 11
    c412:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_xy(2, 1);
    c416:	82 e0       	ldi	r24, 0x02	; 2
    c418:	61 e0       	ldi	r22, 0x01	; 1
    c41a:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
	__result = _key_string(1);
    c41e:	81 e0       	ldi	r24, 0x01	; 1
    c420:	0e 94 4a af 	call	0x15e94	; 0x15e94 <_key_string>
	if(__result==0)
    c424:	88 23       	and	r24, r24
    c426:	51 f4       	brne	.+20     	; 0xc43c <_menu_operator+0x50>
    c428:	85 e1       	ldi	r24, 0x15	; 21
    c42a:	90 e0       	ldi	r25, 0x00	; 0
    c42c:	69 eb       	ldi	r22, 0xB9	; 185
    c42e:	7e e0       	ldi	r23, 0x0E	; 14
    c430:	43 e1       	ldi	r20, 0x13	; 19
    c432:	50 e0       	ldi	r21, 0x00	; 0
    c434:	2f e9       	ldi	r18, 0x9F	; 159
    c436:	32 e1       	ldi	r19, 0x12	; 18
    c438:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
    c43c:	08 95       	ret

0000c43e <_menu_setpassword>:
			}
		}
	}
}

void _menu_setpassword(unsigned char __level){
    c43e:	cf 92       	push	r12
    c440:	df 92       	push	r13
    c442:	ff 92       	push	r15
    c444:	0f 93       	push	r16
    c446:	1f 93       	push	r17
    c448:	df 93       	push	r29
    c44a:	cf 93       	push	r28
    c44c:	00 d0       	rcall	.+0      	; 0xc44e <_menu_setpassword+0x10>
    c44e:	00 d0       	rcall	.+0      	; 0xc450 <_menu_setpassword+0x12>
    c450:	0f 92       	push	r0
    c452:	cd b7       	in	r28, 0x3d	; 61
    c454:	de b7       	in	r29, 0x3e	; 62
    c456:	f8 2e       	mov	r15, r24
	unsigned char	__result = 0;
	unsigned char	__buff[5];

	__max_string = _MAX_PASS;
    c458:	8a e0       	ldi	r24, 0x0A	; 10
    c45a:	80 93 db 03 	sts	0x03DB, r24
    c45e:	64 ec       	ldi	r22, 0xC4	; 196
    c460:	c6 2e       	mov	r12, r22
    c462:	69 e0       	ldi	r22, 0x09	; 9
    c464:	d6 2e       	mov	r13, r22
	while(1){
		lcd_clear();_delay_ms(10);
		lcd_printf(1, 1, PSTR("PASSWORD (MAX   ):"));
		_f_inttostr(__buff, _MAX_PASS);
    c466:	8e 01       	movw	r16, r28
    c468:	0f 5f       	subi	r16, 0xFF	; 255
    c46a:	1f 4f       	sbci	r17, 0xFF	; 255
	unsigned char	__result = 0;
	unsigned char	__buff[5];

	__max_string = _MAX_PASS;
	while(1){
		lcd_clear();_delay_ms(10);
    c46c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    c470:	c6 01       	movw	r24, r12
    c472:	01 97       	sbiw	r24, 0x01	; 1
    c474:	f1 f7       	brne	.-4      	; 0xc472 <_menu_setpassword+0x34>
		lcd_printf(1, 1, PSTR("PASSWORD (MAX   ):"));
    c476:	81 e0       	ldi	r24, 0x01	; 1
    c478:	61 e0       	ldi	r22, 0x01	; 1
    c47a:	45 e0       	ldi	r20, 0x05	; 5
    c47c:	5c e0       	ldi	r21, 0x0C	; 12
    c47e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		_f_inttostr(__buff, _MAX_PASS);
    c482:	c8 01       	movw	r24, r16
    c484:	4a e0       	ldi	r20, 0x0A	; 10
    c486:	50 e0       	ldi	r21, 0x00	; 0
    c488:	60 e0       	ldi	r22, 0x00	; 0
    c48a:	70 e0       	ldi	r23, 0x00	; 0
    c48c:	0e 94 78 18 	call	0x30f0	; 0x30f0 <_f_inttostr>
		_f_punctuation(__buff, 0, 2, 0);
    c490:	c8 01       	movw	r24, r16
    c492:	60 e0       	ldi	r22, 0x00	; 0
    c494:	42 e0       	ldi	r20, 0x02	; 2
    c496:	20 e0       	ldi	r18, 0x00	; 0
    c498:	0e 94 61 49 	call	0x92c2	; 0x92c2 <_f_punctuation>
		lcd_print(1, 15, __buff);
    c49c:	81 e0       	ldi	r24, 0x01	; 1
    c49e:	6f e0       	ldi	r22, 0x0F	; 15
    c4a0:	a8 01       	movw	r20, r16
    c4a2:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    c4a6:	84 e0       	ldi	r24, 0x04	; 4
    c4a8:	61 e0       	ldi	r22, 0x01	; 1
    c4aa:	40 ef       	ldi	r20, 0xF0	; 240
    c4ac:	5b e0       	ldi	r21, 0x0B	; 11
    c4ae:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_xy(2, 1);
    c4b2:	82 e0       	ldi	r24, 0x02	; 2
    c4b4:	61 e0       	ldi	r22, 0x01	; 1
    c4b6:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>

		
		__result = _key_string(2);
    c4ba:	82 e0       	ldi	r24, 0x02	; 2
    c4bc:	0e 94 4a af 	call	0x15e94	; 0x15e94 <_key_string>
		if(__result)
    c4c0:	88 23       	and	r24, r24
    c4c2:	91 f4       	brne	.+36     	; 0xc4e8 <_menu_setpassword+0xaa>
			return;
		else
			switch(__level){
    c4c4:	ff 20       	and	r15, r15
    c4c6:	31 f0       	breq	.+12     	; 0xc4d4 <_menu_setpassword+0x96>
    c4c8:	81 e0       	ldi	r24, 0x01	; 1
    c4ca:	f8 16       	cp	r15, r24
    c4cc:	79 f6       	brne	.-98     	; 0xc46c <_menu_setpassword+0x2e>
    c4ce:	8b e0       	ldi	r24, 0x0B	; 11
    c4d0:	90 e0       	ldi	r25, 0x00	; 0
    c4d2:	02 c0       	rjmp	.+4      	; 0xc4d8 <_menu_setpassword+0x9a>
				case _SYS_PASS:
					eeprom_write_block((const void*) &__buf_string, (void*) &DefSysPassword, _MAX_PASS + 1);
					return;
    c4d4:	81 e0       	ldi	r24, 0x01	; 1
    c4d6:	90 e0       	ldi	r25, 0x00	; 0
    c4d8:	69 eb       	ldi	r22, 0xB9	; 185
    c4da:	7e e0       	ldi	r23, 0x0E	; 14
    c4dc:	4b e0       	ldi	r20, 0x0B	; 11
    c4de:	50 e0       	ldi	r21, 0x00	; 0
    c4e0:	2f e9       	ldi	r18, 0x9F	; 159
    c4e2:	32 e1       	ldi	r19, 0x12	; 18
    c4e4:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
					eeprom_write_block((const void*) &__buf_string, (void*) &DefSpvPassword, _MAX_PASS + 1);
					return;
					break;
			}
	}
}
    c4e8:	0f 90       	pop	r0
    c4ea:	0f 90       	pop	r0
    c4ec:	0f 90       	pop	r0
    c4ee:	0f 90       	pop	r0
    c4f0:	0f 90       	pop	r0
    c4f2:	cf 91       	pop	r28
    c4f4:	df 91       	pop	r29
    c4f6:	1f 91       	pop	r17
    c4f8:	0f 91       	pop	r16
    c4fa:	ff 90       	pop	r15
    c4fc:	df 90       	pop	r13
    c4fe:	cf 90       	pop	r12
    c500:	08 95       	ret

0000c502 <_menu_user>:
		}

	}
}

void _menu_user(void){
    c502:	cf 92       	push	r12
    c504:	df 92       	push	r13
    c506:	ef 92       	push	r14
    c508:	ff 92       	push	r15
    c50a:	0f 93       	push	r16
    c50c:	1f 93       	push	r17
    c50e:	df 93       	push	r29
    c510:	cf 93       	push	r28
    c512:	cd b7       	in	r28, 0x3d	; 61
    c514:	de b7       	in	r29, 0x3e	; 62
    c516:	66 97       	sbiw	r28, 0x16	; 22
    c518:	0f b6       	in	r0, 0x3f	; 63
    c51a:	f8 94       	cli
    c51c:	de bf       	out	0x3e, r29	; 62
    c51e:	0f be       	out	0x3f, r0	; 63
    c520:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    c522:	7e 01       	movw	r14, r28
    c524:	08 94       	sec
    c526:	e1 1c       	adc	r14, r1
    c528:	f1 1c       	adc	r15, r1
    c52a:	8e 01       	movw	r16, r28
    c52c:	04 5f       	subi	r16, 0xF4	; 244
    c52e:	1f 4f       	sbci	r17, 0xFF	; 255
    c530:	74 ec       	ldi	r23, 0xC4	; 196
    c532:	c7 2e       	mov	r12, r23
    c534:	79 e0       	ldi	r23, 0x09	; 9
    c536:	d7 2e       	mov	r13, r23
    c538:	c7 01       	movw	r24, r14
    c53a:	61 e0       	ldi	r22, 0x01	; 1
    c53c:	70 e0       	ldi	r23, 0x00	; 0
    c53e:	4b e0       	ldi	r20, 0x0B	; 11
    c540:	50 e0       	ldi	r21, 0x00	; 0
    c542:	27 e9       	ldi	r18, 0x97	; 151
    c544:	32 e1       	ldi	r19, 0x12	; 18
    c546:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    c54a:	c8 01       	movw	r24, r16
    c54c:	6b e0       	ldi	r22, 0x0B	; 11
    c54e:	70 e0       	ldi	r23, 0x00	; 0
    c550:	4b e0       	ldi	r20, 0x0B	; 11
    c552:	50 e0       	ldi	r21, 0x00	; 0
    c554:	27 e9       	ldi	r18, 0x97	; 151
    c556:	32 e1       	ldi	r19, 0x12	; 18
    c558:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>

	while(1){
		eeprom_read_block((void*) &__t_spv_pass, (const void*) &DefSpvPassword, _MAX_PASS + 1);
		eeprom_read_block((void*) &__t_sys_pass, (const void*) &DefSysPassword, _MAX_PASS + 1);
		
		lcd_clear();_delay_ms(10);
    c55c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    c560:	c6 01       	movw	r24, r12
    c562:	01 97       	sbiw	r24, 0x01	; 1
    c564:	f1 f7       	brne	.-4      	; 0xc562 <_menu_user+0x60>
		lcd_printf(1, 1, PSTR("1)L1:"));
    c566:	81 e0       	ldi	r24, 0x01	; 1
    c568:	61 e0       	ldi	r22, 0x01	; 1
    c56a:	45 e2       	ldi	r20, 0x25	; 37
    c56c:	5c e0       	ldi	r21, 0x0C	; 12
    c56e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(2, 1, PSTR("2)L2:"));
    c572:	82 e0       	ldi	r24, 0x02	; 2
    c574:	61 e0       	ldi	r22, 0x01	; 1
    c576:	4f e1       	ldi	r20, 0x1F	; 31
    c578:	5c e0       	ldi	r21, 0x0C	; 12
    c57a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_print(1, 6, __t_spv_pass);
    c57e:	81 e0       	ldi	r24, 0x01	; 1
    c580:	66 e0       	ldi	r22, 0x06	; 6
    c582:	a7 01       	movw	r20, r14
    c584:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		lcd_print(2, 6, __t_sys_pass);
    c588:	82 e0       	ldi	r24, 0x02	; 2
    c58a:	66 e0       	ldi	r22, 0x06	; 6
    c58c:	a8 01       	movw	r20, r16
    c58e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		lcd_printf(4, 1, PSTR("*)Exit"));
    c592:	84 e0       	ldi	r24, 0x04	; 4
    c594:	61 e0       	ldi	r22, 0x01	; 1
    c596:	48 e1       	ldi	r20, 0x18	; 24
    c598:	5c e0       	ldi	r21, 0x0C	; 12
    c59a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>

		while(1){
			
			__key = _key_scan(1);
    c59e:	81 e0       	ldi	r24, 0x01	; 1
    c5a0:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
			if(__key == _KEY_CANCEL)
    c5a4:	87 3e       	cpi	r24, 0xE7	; 231
    c5a6:	51 f0       	breq	.+20     	; 0xc5bc <_menu_user+0xba>
				return;
			if(__key == _KEY_1){
    c5a8:	8e 3e       	cpi	r24, 0xEE	; 238
    c5aa:	11 f4       	brne	.+4      	; 0xc5b0 <_menu_user+0xae>
				_menu_setpassword(_SPV_PASS);
    c5ac:	80 e0       	ldi	r24, 0x00	; 0
    c5ae:	03 c0       	rjmp	.+6      	; 0xc5b6 <_menu_user+0xb4>
				break;
			}
			if(__key == _KEY_2){
    c5b0:	8e 3d       	cpi	r24, 0xDE	; 222
    c5b2:	a9 f7       	brne	.-22     	; 0xc59e <_menu_user+0x9c>
				_menu_setpassword(_SYS_PASS);
    c5b4:	81 e0       	ldi	r24, 0x01	; 1
    c5b6:	0e 94 1f 62 	call	0xc43e	; 0xc43e <_menu_setpassword>
    c5ba:	be cf       	rjmp	.-132    	; 0xc538 <_menu_user+0x36>
				break;
			}
		}
	}
}
    c5bc:	66 96       	adiw	r28, 0x16	; 22
    c5be:	0f b6       	in	r0, 0x3f	; 63
    c5c0:	f8 94       	cli
    c5c2:	de bf       	out	0x3e, r29	; 62
    c5c4:	0f be       	out	0x3f, r0	; 63
    c5c6:	cd bf       	out	0x3d, r28	; 61
    c5c8:	cf 91       	pop	r28
    c5ca:	df 91       	pop	r29
    c5cc:	1f 91       	pop	r17
    c5ce:	0f 91       	pop	r16
    c5d0:	ff 90       	pop	r15
    c5d2:	ef 90       	pop	r14
    c5d4:	df 90       	pop	r13
    c5d6:	cf 90       	pop	r12
    c5d8:	08 95       	ret

0000c5da <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}
char FSettingOperator(){
     _menu_user();
    c5da:	0e 94 81 62 	call	0xc502	; 0xc502 <_menu_user>
     return MENU_DONE;
}
    c5de:	81 e0       	ldi	r24, 0x01	; 1
    c5e0:	08 95       	ret

0000c5e2 <_menu_productinput>:
}

unsigned char _menu_productinput(void){
	char __result;

	__max_string = 5;
    c5e2:	85 e0       	ldi	r24, 0x05	; 5
    c5e4:	80 93 db 03 	sts	0x03DB, r24
	lcd_printf(4, 1, PSTR("[*]Cancel    [#]Save"));
    c5e8:	84 e0       	ldi	r24, 0x04	; 4
    c5ea:	61 e0       	ldi	r22, 0x01	; 1
    c5ec:	42 e8       	ldi	r20, 0x82	; 130
    c5ee:	5e e0       	ldi	r21, 0x0E	; 14
    c5f0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	while(1){
		
		lcd_printf(2, 1,PSTR("                    "));
    c5f4:	82 e0       	ldi	r24, 0x02	; 2
    c5f6:	61 e0       	ldi	r22, 0x01	; 1
    c5f8:	4d e6       	ldi	r20, 0x6D	; 109
    c5fa:	5e e0       	ldi	r21, 0x0E	; 14
    c5fc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_xy(2, 1);
    c600:	82 e0       	ldi	r24, 0x02	; 2
    c602:	61 e0       	ldi	r22, 0x01	; 1
    c604:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
		__result = _key_string(0);
    c608:	80 e0       	ldi	r24, 0x00	; 0
    c60a:	0e 94 4a af 	call	0x15e94	; 0x15e94 <_key_string>
		if(__result){
    c60e:	88 23       	and	r24, r24
    c610:	29 f0       	breq	.+10     	; 0xc61c <_menu_productinput+0x3a>
			__chr_count = 0;
    c612:	10 92 da 03 	sts	0x03DA, r1
			__buf_string[0] = '\0';
    c616:	10 92 b9 0e 	sts	0x0EB9, r1
    c61a:	81 e0       	ldi	r24, 0x01	; 1
		}
		else
			return 0;
	}
	return 0;
}
    c61c:	08 95       	ret

0000c61e <_menu_text>:
			}
		}
	}
}

void _menu_text(unsigned char __select){
    c61e:	0f 93       	push	r16
    c620:	1f 93       	push	r17
    c622:	df 93       	push	r29
    c624:	cf 93       	push	r28
    c626:	cd b7       	in	r28, 0x3d	; 61
    c628:	de b7       	in	r29, 0x3e	; 62
    c62a:	2a 97       	sbiw	r28, 0x0a	; 10
    c62c:	0f b6       	in	r0, 0x3f	; 63
    c62e:	f8 94       	cli
    c630:	de bf       	out	0x3e, r29	; 62
    c632:	0f be       	out	0x3f, r0	; 63
    c634:	cd bf       	out	0x3d, r28	; 61
	unsigned char	__result;
	unsigned char	__title[10];

	__max_string = _MAX_TEXT;
    c636:	96 e2       	ldi	r25, 0x26	; 38
    c638:	90 93 db 03 	sts	0x03DB, r25
	__chr_count = 0;
    c63c:	10 92 da 03 	sts	0x03DA, r1
	__buf_string[0] = '\0';
    c640:	10 92 b9 0e 	sts	0x0EB9, r1

	for(unsigned char __i = 0; __i < 10; __i ++)
		__title[__i] = pgm_read_byte(&__txttitle[__select][__i]);
    c644:	08 2f       	mov	r16, r24
    c646:	10 e0       	ldi	r17, 0x00	; 0
    c648:	f8 01       	movw	r30, r16
    c64a:	ee 0f       	add	r30, r30
    c64c:	ff 1f       	adc	r31, r31
    c64e:	c8 01       	movw	r24, r16
    c650:	a3 e0       	ldi	r26, 0x03	; 3
    c652:	88 0f       	add	r24, r24
    c654:	99 1f       	adc	r25, r25
    c656:	aa 95       	dec	r26
    c658:	e1 f7       	brne	.-8      	; 0xc652 <_menu_text+0x34>
    c65a:	e8 0f       	add	r30, r24
    c65c:	f9 1f       	adc	r31, r25
    c65e:	e0 5d       	subi	r30, 0xD0	; 208
    c660:	fc 4f       	sbci	r31, 0xFC	; 252
    c662:	de 01       	movw	r26, r28
    c664:	11 96       	adiw	r26, 0x01	; 1

	__max_string = _MAX_TEXT;
	__chr_count = 0;
	__buf_string[0] = '\0';

	for(unsigned char __i = 0; __i < 10; __i ++)
    c666:	9e 01       	movw	r18, r28
    c668:	25 5f       	subi	r18, 0xF5	; 245
    c66a:	3f 4f       	sbci	r19, 0xFF	; 255
		__title[__i] = pgm_read_byte(&__txttitle[__select][__i]);
    c66c:	84 91       	lpm	r24, Z+
    c66e:	8d 93       	st	X+, r24
    c670:	31 96       	adiw	r30, 0x01	; 1

	__max_string = _MAX_TEXT;
	__chr_count = 0;
	__buf_string[0] = '\0';

	for(unsigned char __i = 0; __i < 10; __i ++)
    c672:	a2 17       	cp	r26, r18
    c674:	b3 07       	cpc	r27, r19
    c676:	d1 f7       	brne	.-12     	; 0xc66c <_menu_text+0x4e>
		__title[__i] = pgm_read_byte(&__txttitle[__select][__i]);

	lcd_clear();
    c678:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	lcd_print(1, 1, __title);
    c67c:	81 e0       	ldi	r24, 0x01	; 1
    c67e:	61 e0       	ldi	r22, 0x01	; 1
    c680:	ae 01       	movw	r20, r28
    c682:	4f 5f       	subi	r20, 0xFF	; 255
    c684:	5f 4f       	sbci	r21, 0xFF	; 255
    c686:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    c68a:	84 e0       	ldi	r24, 0x04	; 4
    c68c:	61 e0       	ldi	r22, 0x01	; 1
    c68e:	47 e1       	ldi	r20, 0x17	; 23
    c690:	52 e1       	ldi	r21, 0x12	; 18
    c692:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_xy(2, 1);
    c696:	82 e0       	ldi	r24, 0x02	; 2
    c698:	61 e0       	ldi	r22, 0x01	; 1
    c69a:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
	__result = _key_string(1);
    c69e:	81 e0       	ldi	r24, 0x01	; 1
    c6a0:	0e 94 4a af 	call	0x15e94	; 0x15e94 <_key_string>
	if(__result==0)
    c6a4:	88 23       	and	r24, r24
    c6a6:	a1 f4       	brne	.+40     	; 0xc6d0 <_menu_text+0xb2>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c6a8:	89 e2       	ldi	r24, 0x29	; 41
    c6aa:	90 e0       	ldi	r25, 0x00	; 0
    c6ac:	9c 01       	movw	r18, r24
    c6ae:	02 9f       	mul	r16, r18
    c6b0:	c0 01       	movw	r24, r0
    c6b2:	03 9f       	mul	r16, r19
    c6b4:	90 0d       	add	r25, r0
    c6b6:	12 9f       	mul	r17, r18
    c6b8:	90 0d       	add	r25, r0
    c6ba:	11 24       	eor	r1, r1
    c6bc:	89 5a       	subi	r24, 0xA9	; 169
    c6be:	9d 4f       	sbci	r25, 0xFD	; 253
    c6c0:	69 eb       	ldi	r22, 0xB9	; 185
    c6c2:	7e e0       	ldi	r23, 0x0E	; 14
    c6c4:	47 e2       	ldi	r20, 0x27	; 39
    c6c6:	50 e0       	ldi	r21, 0x00	; 0
    c6c8:	2f e9       	ldi	r18, 0x9F	; 159
    c6ca:	32 e1       	ldi	r19, 0x12	; 18
    c6cc:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
		eeprom_write_block((const void*) &__buf_string, (void*) &DefHeaderFooter[__select], _MAX_TEXT + 1);
}
    c6d0:	2a 96       	adiw	r28, 0x0a	; 10
    c6d2:	0f b6       	in	r0, 0x3f	; 63
    c6d4:	f8 94       	cli
    c6d6:	de bf       	out	0x3e, r29	; 62
    c6d8:	0f be       	out	0x3f, r0	; 63
    c6da:	cd bf       	out	0x3d, r28	; 61
    c6dc:	cf 91       	pop	r28
    c6de:	df 91       	pop	r29
    c6e0:	1f 91       	pop	r17
    c6e2:	0f 91       	pop	r16
    c6e4:	08 95       	ret

0000c6e6 <_menu_footer>:

void _menu_footer(void){
	char __key;

	while(1){
		lcd_clear();
    c6e6:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		lcd_printf(1, 1, PSTR("1)Footer1  3)Footer3"));
    c6ea:	81 e0       	ldi	r24, 0x01	; 1
    c6ec:	61 e0       	ldi	r22, 0x01	; 1
    c6ee:	48 e4       	ldi	r20, 0x48	; 72
    c6f0:	52 e1       	ldi	r21, 0x12	; 18
    c6f2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Footer2  4)Footer4"));
    c6f6:	82 e0       	ldi	r24, 0x02	; 2
    c6f8:	61 e0       	ldi	r22, 0x01	; 1
    c6fa:	43 e3       	ldi	r20, 0x33	; 51
    c6fc:	52 e1       	ldi	r21, 0x12	; 18
    c6fe:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    c702:	84 e0       	ldi	r24, 0x04	; 4
    c704:	61 e0       	ldi	r22, 0x01	; 1
    c706:	4c e2       	ldi	r20, 0x2C	; 44
    c708:	52 e1       	ldi	r21, 0x12	; 18
    c70a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		
		while(1){
			__key = _key_scan(1);
    c70e:	81 e0       	ldi	r24, 0x01	; 1
    c710:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
			if(__key == _KEY_CANCEL)
    c714:	87 3e       	cpi	r24, 0xE7	; 231
    c716:	91 f0       	breq	.+36     	; 0xc73c <_menu_footer+0x56>
				return;
			if(__key == _KEY_1){
    c718:	8e 3e       	cpi	r24, 0xEE	; 238
    c71a:	11 f4       	brne	.+4      	; 0xc720 <_menu_footer+0x3a>
				_menu_text(4);
    c71c:	84 e0       	ldi	r24, 0x04	; 4
    c71e:	0b c0       	rjmp	.+22     	; 0xc736 <_menu_footer+0x50>
				break;
			}
			if(__key == _KEY_2){
    c720:	8e 3d       	cpi	r24, 0xDE	; 222
    c722:	11 f4       	brne	.+4      	; 0xc728 <_menu_footer+0x42>
				_menu_text(5);
    c724:	85 e0       	ldi	r24, 0x05	; 5
    c726:	07 c0       	rjmp	.+14     	; 0xc736 <_menu_footer+0x50>
				break;
			}
			if(__key == _KEY_3){
    c728:	8e 3b       	cpi	r24, 0xBE	; 190
    c72a:	11 f4       	brne	.+4      	; 0xc730 <_menu_footer+0x4a>
				_menu_text(6);
    c72c:	86 e0       	ldi	r24, 0x06	; 6
    c72e:	03 c0       	rjmp	.+6      	; 0xc736 <_menu_footer+0x50>
				break;
			}
			if(__key == _KEY_4){
    c730:	8d 3e       	cpi	r24, 0xED	; 237
    c732:	69 f7       	brne	.-38     	; 0xc70e <_menu_footer+0x28>
				_menu_text(7);
    c734:	87 e0       	ldi	r24, 0x07	; 7
    c736:	0e 94 0f 63 	call	0xc61e	; 0xc61e <_menu_text>
    c73a:	d5 cf       	rjmp	.-86     	; 0xc6e6 <_menu_footer>
    c73c:	08 95       	ret

0000c73e <_menu_header>:

void _menu_header(void){
	char __key;

	while(1){
		lcd_clear();
    c73e:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		lcd_printf(1, 1, PSTR("1)Header1  3)Header3"));
    c742:	81 e0       	ldi	r24, 0x01	; 1
    c744:	61 e0       	ldi	r22, 0x01	; 1
    c746:	49 e7       	ldi	r20, 0x79	; 121
    c748:	52 e1       	ldi	r21, 0x12	; 18
    c74a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Header2  4)Header4"));
    c74e:	82 e0       	ldi	r24, 0x02	; 2
    c750:	61 e0       	ldi	r22, 0x01	; 1
    c752:	44 e6       	ldi	r20, 0x64	; 100
    c754:	52 e1       	ldi	r21, 0x12	; 18
    c756:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    c75a:	84 e0       	ldi	r24, 0x04	; 4
    c75c:	61 e0       	ldi	r22, 0x01	; 1
    c75e:	4d e5       	ldi	r20, 0x5D	; 93
    c760:	52 e1       	ldi	r21, 0x12	; 18
    c762:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		
		while(1){
			
			__key = _key_scan(1);
    c766:	81 e0       	ldi	r24, 0x01	; 1
    c768:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
			if(__key == _KEY_CANCEL)
    c76c:	87 3e       	cpi	r24, 0xE7	; 231
    c76e:	91 f0       	breq	.+36     	; 0xc794 <_menu_header+0x56>
				return;
			if(__key == _KEY_1){
    c770:	8e 3e       	cpi	r24, 0xEE	; 238
    c772:	11 f4       	brne	.+4      	; 0xc778 <_menu_header+0x3a>
				_menu_text(0);
    c774:	80 e0       	ldi	r24, 0x00	; 0
    c776:	0b c0       	rjmp	.+22     	; 0xc78e <_menu_header+0x50>
				break;
			}
			if(__key == _KEY_2){
    c778:	8e 3d       	cpi	r24, 0xDE	; 222
    c77a:	11 f4       	brne	.+4      	; 0xc780 <_menu_header+0x42>
				_menu_text(1);
    c77c:	81 e0       	ldi	r24, 0x01	; 1
    c77e:	07 c0       	rjmp	.+14     	; 0xc78e <_menu_header+0x50>
				break;
			}
			if(__key == _KEY_3){
    c780:	8e 3b       	cpi	r24, 0xBE	; 190
    c782:	11 f4       	brne	.+4      	; 0xc788 <_menu_header+0x4a>
				_menu_text(2);
    c784:	82 e0       	ldi	r24, 0x02	; 2
    c786:	03 c0       	rjmp	.+6      	; 0xc78e <_menu_header+0x50>
				break;
			}
			if(__key == _KEY_4){
    c788:	8d 3e       	cpi	r24, 0xED	; 237
    c78a:	69 f7       	brne	.-38     	; 0xc766 <_menu_header+0x28>
				_menu_text(3);
    c78c:	83 e0       	ldi	r24, 0x03	; 3
    c78e:	0e 94 0f 63 	call	0xc61e	; 0xc61e <_menu_text>
    c792:	d5 cf       	rjmp	.-86     	; 0xc73e <_menu_header>
    c794:	08 95       	ret

0000c796 <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    c796:	8f 92       	push	r8
    c798:	9f 92       	push	r9
    c79a:	af 92       	push	r10
    c79c:	bf 92       	push	r11
    c79e:	cf 92       	push	r12
    c7a0:	df 92       	push	r13
    c7a2:	ef 92       	push	r14
    c7a4:	ff 92       	push	r15
    c7a6:	0f 93       	push	r16
    c7a8:	1f 93       	push	r17
    c7aa:	df 93       	push	r29
    c7ac:	cf 93       	push	r28
    c7ae:	cd b7       	in	r28, 0x3d	; 61
    c7b0:	de b7       	in	r29, 0x3e	; 62
    c7b2:	c2 54       	subi	r28, 0x42	; 66
    c7b4:	d0 40       	sbci	r29, 0x00	; 0
    c7b6:	0f b6       	in	r0, 0x3f	; 63
    c7b8:	f8 94       	cli
    c7ba:	de bf       	out	0x3e, r29	; 62
    c7bc:	0f be       	out	0x3f, r0	; 63
    c7be:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    c7c0:	de 01       	movw	r26, r28
    c7c2:	53 96       	adiw	r26, 0x13	; 19
    c7c4:	eb e3       	ldi	r30, 0x3B	; 59
    c7c6:	f1 e0       	ldi	r31, 0x01	; 1
    c7c8:	80 e3       	ldi	r24, 0x30	; 48
    c7ca:	01 90       	ld	r0, Z+
    c7cc:	0d 92       	st	X+, r0
    c7ce:	81 50       	subi	r24, 0x01	; 1
    c7d0:	e1 f7       	brne	.-8      	; 0xc7ca <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    c7d2:	8e 01       	movw	r16, r28
    c7d4:	0f 5f       	subi	r16, 0xFF	; 255
    c7d6:	1f 4f       	sbci	r17, 0xFF	; 255
    c7d8:	b8 01       	movw	r22, r16
    c7da:	ae 01       	movw	r20, r28
    c7dc:	46 5f       	subi	r20, 0xF6	; 246
    c7de:	5f 4f       	sbci	r21, 0xFF	; 255
    c7e0:	0e 94 2b b3 	call	0x16656	; 0x16656 <_datetime>
    c7e4:	e5 e1       	ldi	r30, 0x15	; 21
    c7e6:	8e 2e       	mov	r8, r30
    c7e8:	91 2c       	mov	r9, r1
    c7ea:	8c 0e       	add	r8, r28
    c7ec:	9d 1e       	adc	r9, r29
    c7ee:	d4 01       	movw	r26, r8
    c7f0:	20 e0       	ldi	r18, 0x00	; 0
    c7f2:	30 e0       	ldi	r19, 0x00	; 0
    c7f4:	40 e0       	ldi	r20, 0x00	; 0
    c7f6:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    c7f8:	22 30       	cpi	r18, 0x02	; 2
    c7fa:	31 05       	cpc	r19, r1
    c7fc:	19 f0       	breq	.+6      	; 0xc804 <_menu_datetime+0x6e>
    c7fe:	24 30       	cpi	r18, 0x04	; 4
    c800:	31 05       	cpc	r19, r1
    c802:	11 f4       	brne	.+4      	; 0xc808 <_menu_datetime+0x72>
			__ii++;
    c804:	4f 5f       	subi	r20, 0xFF	; 255
    c806:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    c808:	f8 01       	movw	r30, r16
    c80a:	e4 0f       	add	r30, r20
    c80c:	f5 1f       	adc	r31, r21
    c80e:	80 81       	ld	r24, Z
    c810:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c812:	2f 5f       	subi	r18, 0xFF	; 255
    c814:	3f 4f       	sbci	r19, 0xFF	; 255
    c816:	14 96       	adiw	r26, 0x04	; 4
    c818:	26 30       	cpi	r18, 0x06	; 6
    c81a:	31 05       	cpc	r19, r1
    c81c:	19 f0       	breq	.+6      	; 0xc824 <_menu_datetime+0x8e>
    c81e:	4f 5f       	subi	r20, 0xFF	; 255
    c820:	5f 4f       	sbci	r21, 0xFF	; 255
    c822:	ea cf       	rjmp	.-44     	; 0xc7f8 <_menu_datetime+0x62>
    c824:	7d e2       	ldi	r23, 0x2D	; 45
    c826:	a7 2e       	mov	r10, r23
    c828:	b1 2c       	mov	r11, r1
    c82a:	ac 0e       	add	r10, r28
    c82c:	bd 1e       	adc	r11, r29
    c82e:	d5 01       	movw	r26, r10
    c830:	40 e0       	ldi	r20, 0x00	; 0
    c832:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    c834:	6a e0       	ldi	r22, 0x0A	; 10
    c836:	e6 2e       	mov	r14, r22
    c838:	f1 2c       	mov	r15, r1
    c83a:	ec 0e       	add	r14, r28
    c83c:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    c83e:	28 30       	cpi	r18, 0x08	; 8
    c840:	31 05       	cpc	r19, r1
    c842:	19 f0       	breq	.+6      	; 0xc84a <_menu_datetime+0xb4>
    c844:	2a 30       	cpi	r18, 0x0A	; 10
    c846:	31 05       	cpc	r19, r1
    c848:	11 f4       	brne	.+4      	; 0xc84e <_menu_datetime+0xb8>
			__ii++;
    c84a:	4f 5f       	subi	r20, 0xFF	; 255
    c84c:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    c84e:	f7 01       	movw	r30, r14
    c850:	e4 0f       	add	r30, r20
    c852:	f5 1f       	adc	r31, r21
    c854:	80 81       	ld	r24, Z
    c856:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c858:	2f 5f       	subi	r18, 0xFF	; 255
    c85a:	3f 4f       	sbci	r19, 0xFF	; 255
    c85c:	14 96       	adiw	r26, 0x04	; 4
    c85e:	2c 30       	cpi	r18, 0x0C	; 12
    c860:	31 05       	cpc	r19, r1
    c862:	19 f0       	breq	.+6      	; 0xc86a <_menu_datetime+0xd4>
    c864:	4f 5f       	subi	r20, 0xFF	; 255
    c866:	5f 4f       	sbci	r21, 0xFF	; 255
    c868:	ea cf       	rjmp	.-44     	; 0xc83e <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    c86a:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    c86e:	84 ec       	ldi	r24, 0xC4	; 196
    c870:	99 e0       	ldi	r25, 0x09	; 9
    c872:	01 97       	sbiw	r24, 0x01	; 1
    c874:	f1 f7       	brne	.-4      	; 0xc872 <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    c876:	81 e0       	ldi	r24, 0x01	; 1
    c878:	61 e0       	ldi	r22, 0x01	; 1
    c87a:	4f ed       	ldi	r20, 0xDF	; 223
    c87c:	5c e0       	ldi	r21, 0x0C	; 12
    c87e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    c882:	82 e0       	ldi	r24, 0x02	; 2
    c884:	61 e0       	ldi	r22, 0x01	; 1
    c886:	47 ed       	ldi	r20, 0xD7	; 215
    c888:	5c e0       	ldi	r21, 0x0C	; 12
    c88a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_print(1, 8, __date);
    c88e:	81 e0       	ldi	r24, 0x01	; 1
    c890:	68 e0       	ldi	r22, 0x08	; 8
    c892:	8e 01       	movw	r16, r28
    c894:	0f 5f       	subi	r16, 0xFF	; 255
    c896:	1f 4f       	sbci	r17, 0xFF	; 255
    c898:	a8 01       	movw	r20, r16
    c89a:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	lcd_print(2, 8, __time);
    c89e:	82 e0       	ldi	r24, 0x02	; 2
    c8a0:	68 e0       	ldi	r22, 0x08	; 8
    c8a2:	a7 01       	movw	r20, r14
    c8a4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c8a8:	84 e0       	ldi	r24, 0x04	; 4
    c8aa:	61 e0       	ldi	r22, 0x01	; 1
    c8ac:	42 ec       	ldi	r20, 0xC2	; 194
    c8ae:	5c e0       	ldi	r21, 0x0C	; 12
    c8b0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    c8b4:	8b 89       	ldd	r24, Y+19	; 0x13
    c8b6:	6c 89       	ldd	r22, Y+20	; 0x14
    c8b8:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
	CURSOR_SHOW;
    c8bc:	8f e0       	ldi	r24, 0x0F	; 15
    c8be:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
    c8c2:	ee 24       	eor	r14, r14
    c8c4:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c8c6:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    c8c8:	81 e0       	ldi	r24, 0x01	; 1
    c8ca:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    c8ce:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    c8d0:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    c8d4:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    c8d6:	80 53       	subi	r24, 0x30	; 48
    c8d8:	8a 30       	cpi	r24, 0x0A	; 10
    c8da:	08 f0       	brcs	.+2      	; 0xc8de <_menu_datetime+0x148>
    c8dc:	72 c0       	rjmp	.+228    	; 0xc9c2 <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    c8de:	e1 14       	cp	r14, r1
    c8e0:	f1 04       	cpc	r15, r1
    c8e2:	81 f0       	breq	.+32     	; 0xc904 <_menu_datetime+0x16e>
    c8e4:	82 e0       	ldi	r24, 0x02	; 2
    c8e6:	e8 16       	cp	r14, r24
    c8e8:	f1 04       	cpc	r15, r1
    c8ea:	61 f0       	breq	.+24     	; 0xc904 <_menu_datetime+0x16e>
    c8ec:	96 e0       	ldi	r25, 0x06	; 6
    c8ee:	e9 16       	cp	r14, r25
    c8f0:	f1 04       	cpc	r15, r1
    c8f2:	41 f0       	breq	.+16     	; 0xc904 <_menu_datetime+0x16e>
    c8f4:	a8 e0       	ldi	r26, 0x08	; 8
    c8f6:	ea 16       	cp	r14, r26
    c8f8:	f1 04       	cpc	r15, r1
    c8fa:	21 f0       	breq	.+8      	; 0xc904 <_menu_datetime+0x16e>
    c8fc:	ba e0       	ldi	r27, 0x0A	; 10
    c8fe:	eb 16       	cp	r14, r27
    c900:	f1 04       	cpc	r15, r1
    c902:	81 f4       	brne	.+32     	; 0xc924 <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    c904:	84 2f       	mov	r24, r20
    c906:	90 e0       	ldi	r25, 0x00	; 0
    c908:	c0 97       	sbiw	r24, 0x30	; 48
    c90a:	f7 01       	movw	r30, r14
    c90c:	ee 0f       	add	r30, r30
    c90e:	ff 1f       	adc	r31, r31
    c910:	ee 0f       	add	r30, r30
    c912:	ff 1f       	adc	r31, r31
    c914:	ec 0d       	add	r30, r12
    c916:	fd 1d       	adc	r31, r13
    c918:	25 89       	ldd	r18, Z+21	; 0x15
    c91a:	30 e0       	ldi	r19, 0x00	; 0
    c91c:	28 17       	cp	r18, r24
    c91e:	39 07       	cpc	r19, r25
    c920:	84 f5       	brge	.+96     	; 0xc982 <_menu_datetime+0x1ec>
    c922:	4f c0       	rjmp	.+158    	; 0xc9c2 <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    c924:	81 e0       	ldi	r24, 0x01	; 1
    c926:	e8 16       	cp	r14, r24
    c928:	f1 04       	cpc	r15, r1
    c92a:	61 f4       	brne	.+24     	; 0xc944 <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    c92c:	2d 89       	ldd	r18, Y+21	; 0x15
    c92e:	30 e0       	ldi	r19, 0x00	; 0
    c930:	2f 52       	subi	r18, 0x2F	; 47
    c932:	30 40       	sbci	r19, 0x00	; 0
    c934:	8e 89       	ldd	r24, Y+22	; 0x16
    c936:	90 e0       	ldi	r25, 0x00	; 0
    c938:	82 17       	cp	r24, r18
    c93a:	93 07       	cpc	r25, r19
    c93c:	14 f5       	brge	.+68     	; 0xc982 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    c93e:	42 33       	cpi	r20, 0x32	; 50
    c940:	00 f1       	brcs	.+64     	; 0xc982 <_menu_datetime+0x1ec>
    c942:	3f c0       	rjmp	.+126    	; 0xc9c2 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    c944:	93 e0       	ldi	r25, 0x03	; 3
    c946:	e9 16       	cp	r14, r25
    c948:	f1 04       	cpc	r15, r1
    c94a:	61 f4       	brne	.+24     	; 0xc964 <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    c94c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    c94e:	30 e0       	ldi	r19, 0x00	; 0
    c950:	2f 52       	subi	r18, 0x2F	; 47
    c952:	30 40       	sbci	r19, 0x00	; 0
    c954:	8e 8d       	ldd	r24, Y+30	; 0x1e
    c956:	90 e0       	ldi	r25, 0x00	; 0
    c958:	82 17       	cp	r24, r18
    c95a:	93 07       	cpc	r25, r19
    c95c:	94 f4       	brge	.+36     	; 0xc982 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    c95e:	43 33       	cpi	r20, 0x33	; 51
    c960:	80 f0       	brcs	.+32     	; 0xc982 <_menu_datetime+0x1ec>
    c962:	2f c0       	rjmp	.+94     	; 0xc9c2 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    c964:	a7 e0       	ldi	r26, 0x07	; 7
    c966:	ea 16       	cp	r14, r26
    c968:	f1 04       	cpc	r15, r1
    c96a:	59 f4       	brne	.+22     	; 0xc982 <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    c96c:	2d a5       	ldd	r18, Y+45	; 0x2d
    c96e:	30 e0       	ldi	r19, 0x00	; 0
    c970:	2f 52       	subi	r18, 0x2F	; 47
    c972:	30 40       	sbci	r19, 0x00	; 0
    c974:	8e a5       	ldd	r24, Y+46	; 0x2e
    c976:	90 e0       	ldi	r25, 0x00	; 0
    c978:	82 17       	cp	r24, r18
    c97a:	93 07       	cpc	r25, r19
    c97c:	14 f4       	brge	.+4      	; 0xc982 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    c97e:	44 33       	cpi	r20, 0x34	; 52
    c980:	00 f5       	brcc	.+64     	; 0xc9c2 <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c982:	f7 01       	movw	r30, r14
    c984:	ee 0f       	add	r30, r30
    c986:	ff 1f       	adc	r31, r31
    c988:	ee 0f       	add	r30, r30
    c98a:	ff 1f       	adc	r31, r31
    c98c:	ec 0d       	add	r30, r12
    c98e:	fd 1d       	adc	r31, r13
    c990:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    c992:	84 2f       	mov	r24, r20
    c994:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			__i++;
    c998:	08 94       	sec
    c99a:	e1 1c       	adc	r14, r1
    c99c:	f1 1c       	adc	r15, r1
    c99e:	bc e0       	ldi	r27, 0x0C	; 12
    c9a0:	eb 16       	cp	r14, r27
    c9a2:	f1 04       	cpc	r15, r1
    c9a4:	1c f0       	brlt	.+6      	; 0xc9ac <_menu_datetime+0x216>
    c9a6:	9b e0       	ldi	r25, 0x0B	; 11
    c9a8:	e9 2e       	mov	r14, r25
    c9aa:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c9ac:	f7 01       	movw	r30, r14
    c9ae:	ee 0f       	add	r30, r30
    c9b0:	ff 1f       	adc	r31, r31
    c9b2:	ee 0f       	add	r30, r30
    c9b4:	ff 1f       	adc	r31, r31
    c9b6:	ec 0d       	add	r30, r12
    c9b8:	fd 1d       	adc	r31, r13
    c9ba:	82 89       	ldd	r24, Z+18	; 0x12
    c9bc:	63 89       	ldd	r22, Z+19	; 0x13
    c9be:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    c9c2:	1b 37       	cpi	r17, 0x7B	; 123
    c9c4:	59 f4       	brne	.+22     	; 0xc9dc <_menu_datetime+0x246>
			__i++;
    c9c6:	08 94       	sec
    c9c8:	e1 1c       	adc	r14, r1
    c9ca:	f1 1c       	adc	r15, r1
    c9cc:	8c e0       	ldi	r24, 0x0C	; 12
    c9ce:	e8 16       	cp	r14, r24
    c9d0:	f1 04       	cpc	r15, r1
    c9d2:	6c f0       	brlt	.+26     	; 0xc9ee <_menu_datetime+0x258>
    c9d4:	0b e0       	ldi	r16, 0x0B	; 11
    c9d6:	e0 2e       	mov	r14, r16
    c9d8:	f1 2c       	mov	r15, r1
    c9da:	09 c0       	rjmp	.+18     	; 0xc9ee <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    c9dc:	17 37       	cpi	r17, 0x77	; 119
    c9de:	99 f4       	brne	.+38     	; 0xca06 <_menu_datetime+0x270>
			__i--;
    c9e0:	08 94       	sec
    c9e2:	e1 08       	sbc	r14, r1
    c9e4:	f1 08       	sbc	r15, r1
    c9e6:	f7 fe       	sbrs	r15, 7
    c9e8:	02 c0       	rjmp	.+4      	; 0xc9ee <_menu_datetime+0x258>
    c9ea:	ee 24       	eor	r14, r14
    c9ec:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c9ee:	f7 01       	movw	r30, r14
    c9f0:	ee 0f       	add	r30, r30
    c9f2:	ff 1f       	adc	r31, r31
    c9f4:	ee 0f       	add	r30, r30
    c9f6:	ff 1f       	adc	r31, r31
    c9f8:	ec 0d       	add	r30, r12
    c9fa:	fd 1d       	adc	r31, r13
    c9fc:	82 89       	ldd	r24, Z+18	; 0x12
    c9fe:	63 89       	ldd	r22, Z+19	; 0x13
    ca00:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
    ca04:	61 cf       	rjmp	.-318    	; 0xc8c8 <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    ca06:	17 3e       	cpi	r17, 0xE7	; 231
    ca08:	09 f4       	brne	.+2      	; 0xca0c <_menu_datetime+0x276>
    ca0a:	49 c0       	rjmp	.+146    	; 0xca9e <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    ca0c:	17 3b       	cpi	r17, 0xB7	; 183
    ca0e:	09 f0       	breq	.+2      	; 0xca12 <_menu_datetime+0x27c>
    ca10:	5b cf       	rjmp	.-330    	; 0xc8c8 <_menu_datetime+0x132>
    ca12:	20 e0       	ldi	r18, 0x00	; 0
    ca14:	30 e0       	ldi	r19, 0x00	; 0
    ca16:	40 e0       	ldi	r20, 0x00	; 0
    ca18:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    ca1a:	be 01       	movw	r22, r28
    ca1c:	6f 5f       	subi	r22, 0xFF	; 255
    ca1e:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    ca20:	22 30       	cpi	r18, 0x02	; 2
    ca22:	31 05       	cpc	r19, r1
    ca24:	19 f0       	breq	.+6      	; 0xca2c <_menu_datetime+0x296>
    ca26:	24 30       	cpi	r18, 0x04	; 4
    ca28:	31 05       	cpc	r19, r1
    ca2a:	11 f4       	brne	.+4      	; 0xca30 <_menu_datetime+0x29a>
					__ii++;
    ca2c:	4f 5f       	subi	r20, 0xFF	; 255
    ca2e:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    ca30:	fb 01       	movw	r30, r22
    ca32:	e4 0f       	add	r30, r20
    ca34:	f5 1f       	adc	r31, r21
    ca36:	d4 01       	movw	r26, r8
    ca38:	8c 91       	ld	r24, X
    ca3a:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    ca3c:	2f 5f       	subi	r18, 0xFF	; 255
    ca3e:	3f 4f       	sbci	r19, 0xFF	; 255
    ca40:	84 e0       	ldi	r24, 0x04	; 4
    ca42:	90 e0       	ldi	r25, 0x00	; 0
    ca44:	88 0e       	add	r8, r24
    ca46:	99 1e       	adc	r9, r25
    ca48:	26 30       	cpi	r18, 0x06	; 6
    ca4a:	31 05       	cpc	r19, r1
    ca4c:	19 f0       	breq	.+6      	; 0xca54 <_menu_datetime+0x2be>
    ca4e:	4f 5f       	subi	r20, 0xFF	; 255
    ca50:	5f 4f       	sbci	r21, 0xFF	; 255
    ca52:	e6 cf       	rjmp	.-52     	; 0xca20 <_menu_datetime+0x28a>
    ca54:	60 e0       	ldi	r22, 0x00	; 0
    ca56:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    ca58:	ae 01       	movw	r20, r28
    ca5a:	46 5f       	subi	r20, 0xF6	; 246
    ca5c:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    ca5e:	28 30       	cpi	r18, 0x08	; 8
    ca60:	31 05       	cpc	r19, r1
    ca62:	19 f0       	breq	.+6      	; 0xca6a <_menu_datetime+0x2d4>
    ca64:	2a 30       	cpi	r18, 0x0A	; 10
    ca66:	31 05       	cpc	r19, r1
    ca68:	11 f4       	brne	.+4      	; 0xca6e <_menu_datetime+0x2d8>
					__ii++;
    ca6a:	6f 5f       	subi	r22, 0xFF	; 255
    ca6c:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    ca6e:	fa 01       	movw	r30, r20
    ca70:	e6 0f       	add	r30, r22
    ca72:	f7 1f       	adc	r31, r23
    ca74:	d5 01       	movw	r26, r10
    ca76:	8c 91       	ld	r24, X
    ca78:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    ca7a:	2f 5f       	subi	r18, 0xFF	; 255
    ca7c:	3f 4f       	sbci	r19, 0xFF	; 255
    ca7e:	84 e0       	ldi	r24, 0x04	; 4
    ca80:	90 e0       	ldi	r25, 0x00	; 0
    ca82:	a8 0e       	add	r10, r24
    ca84:	b9 1e       	adc	r11, r25
    ca86:	2c 30       	cpi	r18, 0x0C	; 12
    ca88:	31 05       	cpc	r19, r1
    ca8a:	19 f0       	breq	.+6      	; 0xca92 <_menu_datetime+0x2fc>
    ca8c:	6f 5f       	subi	r22, 0xFF	; 255
    ca8e:	7f 4f       	sbci	r23, 0xFF	; 255
    ca90:	e6 cf       	rjmp	.-52     	; 0xca5e <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    ca92:	81 e0       	ldi	r24, 0x01	; 1
    ca94:	be 01       	movw	r22, r28
    ca96:	6f 5f       	subi	r22, 0xFF	; 255
    ca98:	7f 4f       	sbci	r23, 0xFF	; 255
    ca9a:	0e 94 2b b3 	call	0x16656	; 0x16656 <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    ca9e:	8c e0       	ldi	r24, 0x0C	; 12
    caa0:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
}
    caa4:	ce 5b       	subi	r28, 0xBE	; 190
    caa6:	df 4f       	sbci	r29, 0xFF	; 255
    caa8:	0f b6       	in	r0, 0x3f	; 63
    caaa:	f8 94       	cli
    caac:	de bf       	out	0x3e, r29	; 62
    caae:	0f be       	out	0x3f, r0	; 63
    cab0:	cd bf       	out	0x3d, r28	; 61
    cab2:	cf 91       	pop	r28
    cab4:	df 91       	pop	r29
    cab6:	1f 91       	pop	r17
    cab8:	0f 91       	pop	r16
    caba:	ff 90       	pop	r15
    cabc:	ef 90       	pop	r14
    cabe:	df 90       	pop	r13
    cac0:	cf 90       	pop	r12
    cac2:	bf 90       	pop	r11
    cac4:	af 90       	pop	r10
    cac6:	9f 90       	pop	r9
    cac8:	8f 90       	pop	r8
    caca:	08 95       	ret

0000cacc <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    cacc:	0e 94 cb 63 	call	0xc796	; 0xc796 <_menu_datetime>
     return MENU_DONE;
}
    cad0:	81 e0       	ldi	r24, 0x01	; 1
    cad2:	08 95       	ret

0000cad4 <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    cad4:	6f 92       	push	r6
    cad6:	7f 92       	push	r7
    cad8:	8f 92       	push	r8
    cada:	9f 92       	push	r9
    cadc:	af 92       	push	r10
    cade:	bf 92       	push	r11
    cae0:	cf 92       	push	r12
    cae2:	df 92       	push	r13
    cae4:	ef 92       	push	r14
    cae6:	ff 92       	push	r15
    cae8:	0f 93       	push	r16
    caea:	1f 93       	push	r17
    caec:	df 93       	push	r29
    caee:	cf 93       	push	r28
    caf0:	cd b7       	in	r28, 0x3d	; 61
    caf2:	de b7       	in	r29, 0x3e	; 62
    caf4:	a2 97       	sbiw	r28, 0x22	; 34
    caf6:	0f b6       	in	r0, 0x3f	; 63
    caf8:	f8 94       	cli
    cafa:	de bf       	out	0x3e, r29	; 62
    cafc:	0f be       	out	0x3f, r0	; 63
    cafe:	cd bf       	out	0x3d, r28	; 61
    cb00:	7c 01       	movw	r14, r24
    cb02:	8b 01       	movw	r16, r22
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];
static char KeyPressed=0,KeyChar,KeyCharLast=' ',FIP_Used=0;
static unsigned int iLoop;

       switch(stEnterFIP){
    cb04:	80 91 71 03 	lds	r24, 0x0371
    cb08:	81 30       	cpi	r24, 0x01	; 1
    cb0a:	09 f4       	brne	.+2      	; 0xcb0e <menu_FIP+0x3a>
    cb0c:	b5 c0       	rjmp	.+362    	; 0xcc78 <menu_FIP+0x1a4>
    cb0e:	81 30       	cpi	r24, 0x01	; 1
    cb10:	20 f0       	brcs	.+8      	; 0xcb1a <menu_FIP+0x46>
    cb12:	82 30       	cpi	r24, 0x02	; 2
    cb14:	09 f0       	breq	.+2      	; 0xcb18 <menu_FIP+0x44>
    cb16:	23 c1       	rjmp	.+582    	; 0xcd5e <menu_FIP+0x28a>
    cb18:	20 c1       	rjmp	.+576    	; 0xcd5a <menu_FIP+0x286>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    cb1a:	8e 01       	movw	r16, r28
    cb1c:	09 5f       	subi	r16, 0xF9	; 249
    cb1e:	1f 4f       	sbci	r17, 0xFF	; 255
    cb20:	c8 01       	movw	r24, r16
    cb22:	65 e4       	ldi	r22, 0x45	; 69
    cb24:	70 e0       	ldi	r23, 0x00	; 0
    cb26:	48 e0       	ldi	r20, 0x08	; 8
    cb28:	50 e0       	ldi	r21, 0x00	; 0
    cb2a:	27 e9       	ldi	r18, 0x97	; 151
    cb2c:	32 e1       	ldi	r19, 0x12	; 18
    cb2e:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    cb32:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    cb36:	f8 01       	movw	r30, r16
    cb38:	20 e0       	ldi	r18, 0x00	; 0
    cb3a:	30 e0       	ldi	r19, 0x00	; 0
    cb3c:	07 c0       	rjmp	.+14     	; 0xcb4c <menu_FIP+0x78>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    cb3e:	80 81       	ld	r24, Z
    cb40:	84 36       	cpi	r24, 0x64	; 100
    cb42:	08 f0       	brcs	.+2      	; 0xcb46 <menu_FIP+0x72>
    cb44:	10 82       	st	Z, r1
    cb46:	2f 5f       	subi	r18, 0xFF	; 255
    cb48:	3f 4f       	sbci	r19, 0xFF	; 255
    cb4a:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    cb4c:	28 30       	cpi	r18, 0x08	; 8
    cb4e:	31 05       	cpc	r19, r1
    cb50:	b0 f3       	brcs	.-20     	; 0xcb3e <menu_FIP+0x6a>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    cb52:	10 92 6d 03 	sts	0x036D, r1
    cb56:	10 92 6c 03 	sts	0x036C, r1
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
    cb5a:	17 e0       	ldi	r17, 0x07	; 7
    cb5c:	61 2e       	mov	r6, r17
    cb5e:	71 2c       	mov	r7, r1
    cb60:	6c 0e       	add	r6, r28
    cb62:	7d 1e       	adc	r7, r29
    cb64:	6e 01       	movw	r12, r28
    cb66:	08 94       	sec
    cb68:	c1 1c       	adc	r12, r1
    cb6a:	d1 1c       	adc	r13, r1
    cb6c:	bb e0       	ldi	r27, 0x0B	; 11
    cb6e:	8b 2e       	mov	r8, r27
    cb70:	91 2c       	mov	r9, r1
    cb72:	8c 0e       	add	r8, r28
    cb74:	9d 1e       	adc	r9, r29
    cb76:	a4 e0       	ldi	r26, 0x04	; 4
    cb78:	ea 2e       	mov	r14, r26
    cb7a:	f1 2c       	mov	r15, r1
    cb7c:	ec 0e       	add	r14, r28
    cb7e:	fd 1e       	adc	r15, r29
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    cb80:	8e 01       	movw	r16, r28
    cb82:	01 5f       	subi	r16, 0xF1	; 241
    cb84:	1f 4f       	sbci	r17, 0xFF	; 255
    cb86:	f1 ee       	ldi	r31, 0xE1	; 225
    cb88:	af 2e       	mov	r10, r31
    cb8a:	fa e1       	ldi	r31, 0x1A	; 26
    cb8c:	bf 2e       	mov	r11, r31
    cb8e:	4e c0       	rjmp	.+156    	; 0xcc2c <menu_FIP+0x158>
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
    cb90:	e6 0d       	add	r30, r6
    cb92:	f7 1d       	adc	r31, r7
    cb94:	80 81       	ld	r24, Z
    cb96:	90 e0       	ldi	r25, 0x00	; 0
    cb98:	b6 01       	movw	r22, r12
    cb9a:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <leadingZero>
    cb9e:	e0 91 6c 03 	lds	r30, 0x036C
    cba2:	f0 91 6d 03 	lds	r31, 0x036D
    cba6:	e8 0d       	add	r30, r8
    cba8:	f9 1d       	adc	r31, r9
    cbaa:	80 81       	ld	r24, Z
    cbac:	90 e0       	ldi	r25, 0x00	; 0
    cbae:	b7 01       	movw	r22, r14
    cbb0:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <leadingZero>
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    cbb4:	80 91 6c 03 	lds	r24, 0x036C
    cbb8:	90 91 6d 03 	lds	r25, 0x036D
    cbbc:	2d b7       	in	r18, 0x3d	; 61
    cbbe:	3e b7       	in	r19, 0x3e	; 62
    cbc0:	2c 50       	subi	r18, 0x0C	; 12
    cbc2:	30 40       	sbci	r19, 0x00	; 0
    cbc4:	0f b6       	in	r0, 0x3f	; 63
    cbc6:	f8 94       	cli
    cbc8:	3e bf       	out	0x3e, r19	; 62
    cbca:	0f be       	out	0x3f, r0	; 63
    cbcc:	2d bf       	out	0x3d, r18	; 61
    cbce:	ed b7       	in	r30, 0x3d	; 61
    cbd0:	fe b7       	in	r31, 0x3e	; 62
    cbd2:	31 96       	adiw	r30, 0x01	; 1
    cbd4:	ad b7       	in	r26, 0x3d	; 61
    cbd6:	be b7       	in	r27, 0x3e	; 62
    cbd8:	12 96       	adiw	r26, 0x02	; 2
    cbda:	1c 93       	st	X, r17
    cbdc:	0e 93       	st	-X, r16
    cbde:	11 97       	sbiw	r26, 0x01	; 1
    cbe0:	b3 82       	std	Z+3, r11	; 0x03
    cbe2:	a2 82       	std	Z+2, r10	; 0x02
    cbe4:	01 96       	adiw	r24, 0x01	; 1
    cbe6:	95 83       	std	Z+5, r25	; 0x05
    cbe8:	84 83       	std	Z+4, r24	; 0x04
    cbea:	d7 82       	std	Z+7, r13	; 0x07
    cbec:	c6 82       	std	Z+6, r12	; 0x06
    cbee:	04 96       	adiw	r24, 0x04	; 4
    cbf0:	91 87       	std	Z+9, r25	; 0x09
    cbf2:	80 87       	std	Z+8, r24	; 0x08
    cbf4:	f3 86       	std	Z+11, r15	; 0x0b
    cbf6:	e2 86       	std	Z+10, r14	; 0x0a
    cbf8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
    cbfc:	ed b7       	in	r30, 0x3d	; 61
    cbfe:	fe b7       	in	r31, 0x3e	; 62
    cc00:	3c 96       	adiw	r30, 0x0c	; 12
    cc02:	0f b6       	in	r0, 0x3f	; 63
    cc04:	f8 94       	cli
    cc06:	fe bf       	out	0x3e, r31	; 62
    cc08:	0f be       	out	0x3f, r0	; 63
    cc0a:	ed bf       	out	0x3d, r30	; 61
    cc0c:	80 91 6c 03 	lds	r24, 0x036C
    cc10:	8f 5f       	subi	r24, 0xFF	; 255
    cc12:	61 e0       	ldi	r22, 0x01	; 1
    cc14:	a8 01       	movw	r20, r16
    cc16:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    cc1a:	80 91 6c 03 	lds	r24, 0x036C
    cc1e:	90 91 6d 03 	lds	r25, 0x036D
    cc22:	01 96       	adiw	r24, 0x01	; 1
    cc24:	90 93 6d 03 	sts	0x036D, r25
    cc28:	80 93 6c 03 	sts	0x036C, r24
    cc2c:	e0 91 6c 03 	lds	r30, 0x036C
    cc30:	f0 91 6d 03 	lds	r31, 0x036D
    cc34:	e4 30       	cpi	r30, 0x04	; 4
    cc36:	f1 05       	cpc	r31, r1
    cc38:	08 f4       	brcc	.+2      	; 0xcc3c <menu_FIP+0x168>
    cc3a:	aa cf       	rjmp	.-172    	; 0xcb90 <menu_FIP+0xbc>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    cc3c:	81 e0       	ldi	r24, 0x01	; 1
    cc3e:	6f e0       	ldi	r22, 0x0F	; 15
    cc40:	4b ed       	ldi	r20, 0xDB	; 219
    cc42:	5a e1       	ldi	r21, 0x1A	; 26
    cc44:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    cc48:	82 e0       	ldi	r24, 0x02	; 2
    cc4a:	6f e0       	ldi	r22, 0x0F	; 15
    cc4c:	45 ed       	ldi	r20, 0xD5	; 213
    cc4e:	5a e1       	ldi	r21, 0x1A	; 26
    cc50:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    cc54:	83 e0       	ldi	r24, 0x03	; 3
    cc56:	6f e0       	ldi	r22, 0x0F	; 15
    cc58:	4f ec       	ldi	r20, 0xCF	; 207
    cc5a:	5a e1       	ldi	r21, 0x1A	; 26
    cc5c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    cc60:	84 e0       	ldi	r24, 0x04	; 4
    cc62:	6f e0       	ldi	r22, 0x0F	; 15
    cc64:	48 ec       	ldi	r20, 0xC8	; 200
    cc66:	5a e1       	ldi	r21, 0x1A	; 26
    cc68:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		    iLoop=0;
    cc6c:	10 92 6d 03 	sts	0x036D, r1
    cc70:	10 92 6c 03 	sts	0x036C, r1
		    stEnterFIP=efFIPInput;
    cc74:	81 e0       	ldi	r24, 0x01	; 1
    cc76:	6e c0       	rjmp	.+220    	; 0xcd54 <menu_FIP+0x280>
	        break;
	   case efFIPInput:
		    iLoop++;
    cc78:	80 91 6c 03 	lds	r24, 0x036C
    cc7c:	90 91 6d 03 	lds	r25, 0x036D
    cc80:	01 96       	adiw	r24, 0x01	; 1
    cc82:	90 93 6d 03 	sts	0x036D, r25
    cc86:	80 93 6c 03 	sts	0x036C, r24
		    KeyPressed=_key_scan(1);
    cc8a:	81 e0       	ldi	r24, 0x01	; 1
    cc8c:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    cc90:	80 93 70 03 	sts	0x0370, r24
		    KeyChar=_key_btn(KeyPressed);
    cc94:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    cc98:	98 2f       	mov	r25, r24
    cc9a:	80 93 6f 03 	sts	0x036F, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    cc9e:	81 53       	subi	r24, 0x31	; 49
    cca0:	88 30       	cpi	r24, 0x08	; 8
    cca2:	60 f4       	brcc	.+24     	; 0xccbc <menu_FIP+0x1e8>
		 	     if (KeyCharLast!=KeyChar){
    cca4:	80 91 6f 01 	lds	r24, 0x016F
    cca8:	89 17       	cp	r24, r25
    ccaa:	41 f0       	breq	.+16     	; 0xccbc <menu_FIP+0x1e8>
				     KeyCharLast=KeyChar;
    ccac:	90 93 6f 01 	sts	0x016F, r25
				     iLoop=1000;
    ccb0:	88 ee       	ldi	r24, 0xE8	; 232
    ccb2:	93 e0       	ldi	r25, 0x03	; 3
    ccb4:	90 93 6d 03 	sts	0x036D, r25
    ccb8:	80 93 6c 03 	sts	0x036C, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    ccbc:	80 91 6c 03 	lds	r24, 0x036C
    ccc0:	90 91 6d 03 	lds	r25, 0x036D
    ccc4:	60 ed       	ldi	r22, 0xD0	; 208
    ccc6:	77 e0       	ldi	r23, 0x07	; 7
    ccc8:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    cccc:	89 2b       	or	r24, r25
    ccce:	39 f4       	brne	.+14     	; 0xccde <menu_FIP+0x20a>
		        lcd_xy(1,19);_lcd('_'); 
    ccd0:	81 e0       	ldi	r24, 0x01	; 1
    ccd2:	63 e1       	ldi	r22, 0x13	; 19
    ccd4:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
    ccd8:	8f e5       	ldi	r24, 0x5F	; 95
    ccda:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			   }
           if ((iLoop%2000)==1000){
    ccde:	80 91 6c 03 	lds	r24, 0x036C
    cce2:	90 91 6d 03 	lds	r25, 0x036D
    cce6:	60 ed       	ldi	r22, 0xD0	; 208
    cce8:	77 e0       	ldi	r23, 0x07	; 7
    ccea:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    ccee:	88 5e       	subi	r24, 0xE8	; 232
    ccf0:	93 40       	sbci	r25, 0x03	; 3
    ccf2:	41 f4       	brne	.+16     	; 0xcd04 <menu_FIP+0x230>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    ccf4:	81 e0       	ldi	r24, 0x01	; 1
    ccf6:	63 e1       	ldi	r22, 0x13	; 19
    ccf8:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
    ccfc:	80 91 6f 01 	lds	r24, 0x016F
    cd00:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    cd04:	80 91 6f 03 	lds	r24, 0x036F
    cd08:	81 53       	subi	r24, 0x31	; 49
    cd0a:	88 30       	cpi	r24, 0x08	; 8
    cd0c:	40 f0       	brcs	.+16     	; 0xcd1e <menu_FIP+0x24a>
    cd0e:	80 91 70 03 	lds	r24, 0x0370
    cd12:	87 3b       	cpi	r24, 0xB7	; 183
    cd14:	e1 f4       	brne	.+56     	; 0xcd4e <menu_FIP+0x27a>
    cd16:	80 91 6f 01 	lds	r24, 0x016F
    cd1a:	80 32       	cpi	r24, 0x20	; 32
    cd1c:	01 f1       	breq	.+64     	; 0xcd5e <menu_FIP+0x28a>
		         FIP_Used=FIP[KeyCharLast-'1'];
    cd1e:	80 91 6f 01 	lds	r24, 0x016F
    cd22:	fe 01       	movw	r30, r28
    cd24:	ba 97       	sbiw	r30, 0x2a	; 42
    cd26:	e8 0f       	add	r30, r24
    cd28:	f1 1d       	adc	r31, r1
    cd2a:	80 81       	ld	r24, Z
    cd2c:	80 93 6e 03 	sts	0x036E, r24
				 if (FIP_Used<=99){
    cd30:	84 36       	cpi	r24, 0x64	; 100
    cd32:	40 f4       	brcc	.+16     	; 0xcd44 <menu_FIP+0x270>
                    leadingZero(FIP_Used,sFIPUsed);
    cd34:	90 e0       	ldi	r25, 0x00	; 0
    cd36:	b8 01       	movw	r22, r16
    cd38:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <leadingZero>
					 //sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
					 xFIP[0]=FIP_Used;
    cd3c:	80 91 6e 03 	lds	r24, 0x036E
    cd40:	d7 01       	movw	r26, r14
    cd42:	8c 93       	st	X, r24
					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    cd44:	82 e0       	ldi	r24, 0x02	; 2
    cd46:	80 93 71 03 	sts	0x0371, r24
    cd4a:	80 e0       	ldi	r24, 0x00	; 0
    cd4c:	09 c0       	rjmp	.+18     	; 0xcd60 <menu_FIP+0x28c>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    cd4e:	87 3e       	cpi	r24, 0xE7	; 231
    cd50:	31 f4       	brne	.+12     	; 0xcd5e <menu_FIP+0x28a>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    cd52:	82 e0       	ldi	r24, 0x02	; 2
    cd54:	80 93 71 03 	sts	0x0371, r24
    cd58:	03 c0       	rjmp	.+6      	; 0xcd60 <menu_FIP+0x28c>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    cd5a:	10 92 71 03 	sts	0x0371, r1
    cd5e:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    cd60:	a2 96       	adiw	r28, 0x22	; 34
    cd62:	0f b6       	in	r0, 0x3f	; 63
    cd64:	f8 94       	cli
    cd66:	de bf       	out	0x3e, r29	; 62
    cd68:	0f be       	out	0x3f, r0	; 63
    cd6a:	cd bf       	out	0x3d, r28	; 61
    cd6c:	cf 91       	pop	r28
    cd6e:	df 91       	pop	r29
    cd70:	1f 91       	pop	r17
    cd72:	0f 91       	pop	r16
    cd74:	ff 90       	pop	r15
    cd76:	ef 90       	pop	r14
    cd78:	df 90       	pop	r13
    cd7a:	cf 90       	pop	r12
    cd7c:	bf 90       	pop	r11
    cd7e:	af 90       	pop	r10
    cd80:	9f 90       	pop	r9
    cd82:	8f 90       	pop	r8
    cd84:	7f 90       	pop	r7
    cd86:	6f 90       	pop	r6
    cd88:	08 95       	ret

0000cd8a <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    cd8a:	0f 93       	push	r16
    cd8c:	1f 93       	push	r17
static char KeyPressed=0,FIP_Used=0,FIPResult;
       char lcdteks[20],Result=MENU_NONE;
static unsigned int iLoop=0;

Result=MENU_NONE;
	 switch(stEtransaction){
    cd8e:	80 91 64 03 	lds	r24, 0x0364
    cd92:	85 30       	cpi	r24, 0x05	; 5
    cd94:	09 f4       	brne	.+2      	; 0xcd98 <FMenuEDCTransaction+0xe>
    cd96:	9f c0       	rjmp	.+318    	; 0xced6 <FMenuEDCTransaction+0x14c>
    cd98:	86 30       	cpi	r24, 0x06	; 6
    cd9a:	90 f4       	brcc	.+36     	; 0xcdc0 <FMenuEDCTransaction+0x36>
    cd9c:	82 30       	cpi	r24, 0x02	; 2
    cd9e:	09 f4       	brne	.+2      	; 0xcda2 <FMenuEDCTransaction+0x18>
    cda0:	57 c0       	rjmp	.+174    	; 0xce50 <FMenuEDCTransaction+0xc6>
    cda2:	83 30       	cpi	r24, 0x03	; 3
    cda4:	30 f4       	brcc	.+12     	; 0xcdb2 <FMenuEDCTransaction+0x28>
    cda6:	88 23       	and	r24, r24
    cda8:	f1 f0       	breq	.+60     	; 0xcde6 <FMenuEDCTransaction+0x5c>
    cdaa:	81 30       	cpi	r24, 0x01	; 1
    cdac:	09 f0       	breq	.+2      	; 0xcdb0 <FMenuEDCTransaction+0x26>
    cdae:	dd c0       	rjmp	.+442    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
    cdb0:	36 c0       	rjmp	.+108    	; 0xce1e <FMenuEDCTransaction+0x94>
    cdb2:	83 30       	cpi	r24, 0x03	; 3
    cdb4:	09 f4       	brne	.+2      	; 0xcdb8 <FMenuEDCTransaction+0x2e>
    cdb6:	5e c0       	rjmp	.+188    	; 0xce74 <FMenuEDCTransaction+0xea>
    cdb8:	84 30       	cpi	r24, 0x04	; 4
    cdba:	09 f0       	breq	.+2      	; 0xcdbe <FMenuEDCTransaction+0x34>
    cdbc:	d6 c0       	rjmp	.+428    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
    cdbe:	83 c0       	rjmp	.+262    	; 0xcec6 <FMenuEDCTransaction+0x13c>
    cdc0:	88 30       	cpi	r24, 0x08	; 8
    cdc2:	09 f4       	brne	.+2      	; 0xcdc6 <FMenuEDCTransaction+0x3c>
    cdc4:	c2 c0       	rjmp	.+388    	; 0xcf4a <FMenuEDCTransaction+0x1c0>
    cdc6:	89 30       	cpi	r24, 0x09	; 9
    cdc8:	38 f4       	brcc	.+14     	; 0xcdd8 <FMenuEDCTransaction+0x4e>
    cdca:	86 30       	cpi	r24, 0x06	; 6
    cdcc:	09 f4       	brne	.+2      	; 0xcdd0 <FMenuEDCTransaction+0x46>
    cdce:	98 c0       	rjmp	.+304    	; 0xcf00 <FMenuEDCTransaction+0x176>
    cdd0:	87 30       	cpi	r24, 0x07	; 7
    cdd2:	09 f0       	breq	.+2      	; 0xcdd6 <FMenuEDCTransaction+0x4c>
    cdd4:	ca c0       	rjmp	.+404    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
    cdd6:	96 c0       	rjmp	.+300    	; 0xcf04 <FMenuEDCTransaction+0x17a>
    cdd8:	89 30       	cpi	r24, 0x09	; 9
    cdda:	09 f4       	brne	.+2      	; 0xcdde <FMenuEDCTransaction+0x54>
    cddc:	bc c0       	rjmp	.+376    	; 0xcf56 <FMenuEDCTransaction+0x1cc>
    cdde:	8a 30       	cpi	r24, 0x0A	; 10
    cde0:	09 f0       	breq	.+2      	; 0xcde4 <FMenuEDCTransaction+0x5a>
    cde2:	c3 c0       	rjmp	.+390    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
    cde4:	be c0       	rjmp	.+380    	; 0xcf62 <FMenuEDCTransaction+0x1d8>
	 case etInit:
	      lcd_clear();
    cde6:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    cdea:	81 e0       	ldi	r24, 0x01	; 1
    cdec:	61 e0       	ldi	r22, 0x01	; 1
    cdee:	43 e5       	ldi	r20, 0x53	; 83
    cdf0:	59 e1       	ldi	r21, 0x19	; 25
    cdf2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    cdf6:	81 e0       	ldi	r24, 0x01	; 1
    cdf8:	61 e0       	ldi	r22, 0x01	; 1
    cdfa:	4e e3       	ldi	r20, 0x3E	; 62
    cdfc:	59 e1       	ldi	r21, 0x19	; 25
    cdfe:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    ce02:	82 e0       	ldi	r24, 0x02	; 2
    ce04:	61 e0       	ldi	r22, 0x01	; 1
    ce06:	49 e2       	ldi	r20, 0x29	; 41
    ce08:	59 e1       	ldi	r21, 0x19	; 25
    ce0a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    ce0e:	84 e0       	ldi	r24, 0x04	; 4
    ce10:	61 e0       	ldi	r22, 0x01	; 1
    ce12:	44 e1       	ldi	r20, 0x14	; 20
    ce14:	59 e1       	ldi	r21, 0x19	; 25
    ce16:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stEtransaction=etInputEDC;
    ce1a:	81 e0       	ldi	r24, 0x01	; 1
    ce1c:	6e c0       	rjmp	.+220    	; 0xcefa <FMenuEDCTransaction+0x170>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    ce1e:	81 e0       	ldi	r24, 0x01	; 1
    ce20:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    ce24:	80 93 62 03 	sts	0x0362, r24
		  KeyChar=_key_btn(KeyPressed);
    ce28:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    ce2c:	98 2f       	mov	r25, r24
    ce2e:	80 93 63 03 	sts	0x0363, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    ce32:	81 53       	subi	r24, 0x31	; 49
    ce34:	82 30       	cpi	r24, 0x02	; 2
    ce36:	30 f4       	brcc	.+12     	; 0xce44 <FMenuEDCTransaction+0xba>
		       EDCType=KeyChar-'0';
    ce38:	90 53       	subi	r25, 0x30	; 48
    ce3a:	90 93 37 0a 	sts	0x0A37, r25
		       stEtransaction=etSelectFIP;
    ce3e:	82 e0       	ldi	r24, 0x02	; 2
    ce40:	80 93 64 03 	sts	0x0364, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    ce44:	80 91 62 03 	lds	r24, 0x0362
    ce48:	87 3e       	cpi	r24, 0xE7	; 231
    ce4a:	09 f0       	breq	.+2      	; 0xce4e <FMenuEDCTransaction+0xc4>
    ce4c:	8e c0       	rjmp	.+284    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
    ce4e:	87 c0       	rjmp	.+270    	; 0xcf5e <FMenuEDCTransaction+0x1d4>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    ce50:	80 e0       	ldi	r24, 0x00	; 0
    ce52:	90 e0       	ldi	r25, 0x00	; 0
    ce54:	63 ec       	ldi	r22, 0xC3	; 195
    ce56:	79 e0       	ldi	r23, 0x09	; 9
    ce58:	0e 94 6a 65 	call	0xcad4	; 0xcad4 <menu_FIP>
    ce5c:	80 93 61 03 	sts	0x0361, r24
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    ce60:	88 23       	and	r24, r24
    ce62:	11 f4       	brne	.+4      	; 0xce68 <FMenuEDCTransaction+0xde>
    ce64:	83 e0       	ldi	r24, 0x03	; 3
    ce66:	49 c0       	rjmp	.+146    	; 0xcefa <FMenuEDCTransaction+0x170>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    ce68:	82 30       	cpi	r24, 0x02	; 2
    ce6a:	09 f0       	breq	.+2      	; 0xce6e <FMenuEDCTransaction+0xe4>
    ce6c:	7e c0       	rjmp	.+252    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
    ce6e:	10 92 64 03 	sts	0x0364, r1
    ce72:	7b c0       	rjmp	.+246    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
    ce74:	e4 e9       	ldi	r30, 0x94	; 148
    ce76:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    ce78:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    ce7a:	8e e0       	ldi	r24, 0x0E	; 14
    ce7c:	e9 3a       	cpi	r30, 0xA9	; 169
    ce7e:	f8 07       	cpc	r31, r24
    ce80:	d9 f7       	brne	.-10     	; 0xce78 <FMenuEDCTransaction+0xee>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    ce82:	80 91 37 0a 	lds	r24, 0x0A37
    ce86:	81 30       	cpi	r24, 0x01	; 1
    ce88:	19 f4       	brne	.+6      	; 0xce90 <FMenuEDCTransaction+0x106>
		      AddSpaceLag(strRef1,20);
    ce8a:	cf 01       	movw	r24, r30
    ce8c:	45 97       	sbiw	r24, 0x15	; 21
    ce8e:	16 c0       	rjmp	.+44     	; 0xcebc <FMenuEDCTransaction+0x132>
          }
		  else
	      if (EDCType==2){
    ce90:	82 30       	cpi	r24, 0x02	; 2
    ce92:	b9 f4       	brne	.+46     	; 0xcec2 <FMenuEDCTransaction+0x138>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    ce94:	00 d0       	rcall	.+0      	; 0xce96 <FMenuEDCTransaction+0x10c>
    ce96:	00 d0       	rcall	.+0      	; 0xce98 <FMenuEDCTransaction+0x10e>
    ce98:	8f 01       	movw	r16, r30
    ce9a:	05 51       	subi	r16, 0x15	; 21
    ce9c:	10 40       	sbci	r17, 0x00	; 0
    ce9e:	ed b7       	in	r30, 0x3d	; 61
    cea0:	fe b7       	in	r31, 0x3e	; 62
    cea2:	12 83       	std	Z+2, r17	; 0x02
    cea4:	01 83       	std	Z+1, r16	; 0x01
    cea6:	89 e0       	ldi	r24, 0x09	; 9
    cea8:	99 e1       	ldi	r25, 0x19	; 25
    ceaa:	94 83       	std	Z+4, r25	; 0x04
    ceac:	83 83       	std	Z+3, r24	; 0x03
    ceae:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  AddSpaceLag(strRef1,20);
    ceb2:	0f 90       	pop	r0
    ceb4:	0f 90       	pop	r0
    ceb6:	0f 90       	pop	r0
    ceb8:	0f 90       	pop	r0
    ceba:	c8 01       	movw	r24, r16
    cebc:	64 e1       	ldi	r22, 0x14	; 20
    cebe:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    cec2:	84 e0       	ldi	r24, 0x04	; 4
    cec4:	1a c0       	rjmp	.+52     	; 0xcefa <FMenuEDCTransaction+0x170>
	      break;
     case etSendingMessage90:
          sendMessage90();
    cec6:	0e 94 8a 4e 	call	0x9d14	; 0x9d14 <sendMessage90>
		  TimSend=0;
    ceca:	10 92 be 01 	sts	0x01BE, r1
    cece:	10 92 bd 01 	sts	0x01BD, r1
          stEtransaction=etWaitReply;
    ced2:	85 e0       	ldi	r24, 0x05	; 5
    ced4:	12 c0       	rjmp	.+36     	; 0xcefa <FMenuEDCTransaction+0x170>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
    ced6:	80 91 bd 01 	lds	r24, 0x01BD
    ceda:	90 91 be 01 	lds	r25, 0x01BE
    cede:	45 97       	sbiw	r24, 0x15	; 21
    cee0:	18 f0       	brcs	.+6      	; 0xcee8 <FMenuEDCTransaction+0x15e>
    cee2:	88 e0       	ldi	r24, 0x08	; 8
    cee4:	80 93 64 03 	sts	0x0364, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    cee8:	80 91 d4 01 	lds	r24, 0x01D4
    ceec:	81 30       	cpi	r24, 0x01	; 1
    ceee:	21 f0       	breq	.+8      	; 0xcef8 <FMenuEDCTransaction+0x16e>
    cef0:	80 91 d0 01 	lds	r24, 0x01D0
    cef4:	81 30       	cpi	r24, 0x01	; 1
    cef6:	c9 f5       	brne	.+114    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
		       stEtransaction=etSuccesEDC;
    cef8:	86 e0       	ldi	r24, 0x06	; 6
    cefa:	80 93 64 03 	sts	0x0364, r24
    cefe:	35 c0       	rjmp	.+106    	; 0xcf6a <FMenuEDCTransaction+0x1e0>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    cf00:	87 e0       	ldi	r24, 0x07	; 7
    cf02:	fb cf       	rjmp	.-10     	; 0xcefa <FMenuEDCTransaction+0x170>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    cf04:	80 91 d0 01 	lds	r24, 0x01D0
    cf08:	81 30       	cpi	r24, 0x01	; 1
    cf0a:	19 f5       	brne	.+70     	; 0xcf52 <FMenuEDCTransaction+0x1c8>
		      IsMessage09=False;
    cf0c:	10 92 d0 01 	sts	0x01D0, r1
	          procMessage09();
    cf10:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <procMessage09>
		      lcd_clear();
    cf14:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
    cf18:	81 e0       	ldi	r24, 0x01	; 1
    cf1a:	61 e0       	ldi	r22, 0x01	; 1
    cf1c:	42 ec       	ldi	r20, 0xC2	; 194
    cf1e:	5a e0       	ldi	r21, 0x0A	; 10
    cf20:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
    cf24:	82 e0       	ldi	r24, 0x02	; 2
    cf26:	61 e0       	ldi	r22, 0x01	; 1
    cf28:	4d ea       	ldi	r20, 0xAD	; 173
    cf2a:	59 e0       	ldi	r21, 0x09	; 9
    cf2c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
    cf30:	83 e0       	ldi	r24, 0x03	; 3
    cf32:	61 e0       	ldi	r22, 0x01	; 1
    cf34:	48 e4       	ldi	r20, 0x48	; 72
    cf36:	5a e0       	ldi	r21, 0x0A	; 10
    cf38:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
    cf3c:	84 e0       	ldi	r24, 0x04	; 4
    cf3e:	61 e0       	ldi	r22, 0x01	; 1
    cf40:	4c ed       	ldi	r20, 0xDC	; 220
    cf42:	5d e0       	ldi	r21, 0x0D	; 13
    cf44:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    cf48:	02 c0       	rjmp	.+4      	; 0xcf4e <FMenuEDCTransaction+0x1c4>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    cf4a:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  TimDisplay=0;
    cf4e:	10 92 bc 01 	sts	0x01BC, r1
		  stEtransaction=etDelayExit;
    cf52:	89 e0       	ldi	r24, 0x09	; 9
    cf54:	d2 cf       	rjmp	.-92     	; 0xcefa <FMenuEDCTransaction+0x170>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    cf56:	80 91 bc 01 	lds	r24, 0x01BC
    cf5a:	89 30       	cpi	r24, 0x09	; 9
    cf5c:	30 f0       	brcs	.+12     	; 0xcf6a <FMenuEDCTransaction+0x1e0>
    cf5e:	8a e0       	ldi	r24, 0x0A	; 10
    cf60:	cc cf       	rjmp	.-104    	; 0xcefa <FMenuEDCTransaction+0x170>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    cf62:	10 92 64 03 	sts	0x0364, r1
    cf66:	81 e0       	ldi	r24, 0x01	; 1
    cf68:	01 c0       	rjmp	.+2      	; 0xcf6c <FMenuEDCTransaction+0x1e2>
    cf6a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    cf6c:	1f 91       	pop	r17
    cf6e:	0f 91       	pop	r16
    cf70:	08 95       	ret

0000cf72 <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
    cf72:	cf 92       	push	r12
    cf74:	df 92       	push	r13
    cf76:	ef 92       	push	r14
    cf78:	ff 92       	push	r15
    cf7a:	0f 93       	push	r16
    cf7c:	1f 93       	push	r17
    cf7e:	df 93       	push	r29
    cf80:	cf 93       	push	r28
    cf82:	cd b7       	in	r28, 0x3d	; 61
    cf84:	de b7       	in	r29, 0x3e	; 62
    cf86:	64 97       	sbiw	r28, 0x14	; 20
    cf88:	0f b6       	in	r0, 0x3f	; 63
    cf8a:	f8 94       	cli
    cf8c:	de bf       	out	0x3e, r29	; 62
    cf8e:	0f be       	out	0x3f, r0	; 63
    cf90:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
    cf92:	00 91 68 03 	lds	r16, 0x0368
    cf96:	07 30       	cpi	r16, 0x07	; 7
    cf98:	09 f4       	brne	.+2      	; 0xcf9c <FMenuLoyalty+0x2a>
    cf9a:	08 c1       	rjmp	.+528    	; 0xd1ac <FMenuLoyalty+0x23a>
    cf9c:	08 30       	cpi	r16, 0x08	; 8
    cf9e:	98 f4       	brcc	.+38     	; 0xcfc6 <FMenuLoyalty+0x54>
    cfa0:	03 30       	cpi	r16, 0x03	; 3
    cfa2:	09 f4       	brne	.+2      	; 0xcfa6 <FMenuLoyalty+0x34>
    cfa4:	5d c0       	rjmp	.+186    	; 0xd060 <FMenuLoyalty+0xee>
    cfa6:	04 30       	cpi	r16, 0x04	; 4
    cfa8:	38 f4       	brcc	.+14     	; 0xcfb8 <FMenuLoyalty+0x46>
    cfaa:	01 30       	cpi	r16, 0x01	; 1
    cfac:	09 f4       	brne	.+2      	; 0xcfb0 <FMenuLoyalty+0x3e>
    cfae:	42 c0       	rjmp	.+132    	; 0xd034 <FMenuLoyalty+0xc2>
    cfb0:	02 30       	cpi	r16, 0x02	; 2
    cfb2:	08 f0       	brcs	.+2      	; 0xcfb6 <FMenuLoyalty+0x44>
    cfb4:	63 c0       	rjmp	.+198    	; 0xd07c <FMenuLoyalty+0x10a>
    cfb6:	20 c0       	rjmp	.+64     	; 0xcff8 <FMenuLoyalty+0x86>
    cfb8:	05 30       	cpi	r16, 0x05	; 5
    cfba:	09 f4       	brne	.+2      	; 0xcfbe <FMenuLoyalty+0x4c>
    cfbc:	a4 c0       	rjmp	.+328    	; 0xd106 <FMenuLoyalty+0x194>
    cfbe:	06 30       	cpi	r16, 0x06	; 6
    cfc0:	08 f0       	brcs	.+2      	; 0xcfc4 <FMenuLoyalty+0x52>
    cfc2:	be c0       	rjmp	.+380    	; 0xd140 <FMenuLoyalty+0x1ce>
    cfc4:	8e c0       	rjmp	.+284    	; 0xd0e2 <FMenuLoyalty+0x170>
    cfc6:	0b 30       	cpi	r16, 0x0B	; 11
    cfc8:	09 f4       	brne	.+2      	; 0xcfcc <FMenuLoyalty+0x5a>
    cfca:	3e c1       	rjmp	.+636    	; 0xd248 <FMenuLoyalty+0x2d6>
    cfcc:	0c 30       	cpi	r16, 0x0C	; 12
    cfce:	38 f4       	brcc	.+14     	; 0xcfde <FMenuLoyalty+0x6c>
    cfd0:	09 30       	cpi	r16, 0x09	; 9
    cfd2:	09 f4       	brne	.+2      	; 0xcfd6 <FMenuLoyalty+0x64>
    cfd4:	f6 c0       	rjmp	.+492    	; 0xd1c2 <FMenuLoyalty+0x250>
    cfd6:	0a 30       	cpi	r16, 0x0A	; 10
    cfd8:	08 f0       	brcs	.+2      	; 0xcfdc <FMenuLoyalty+0x6a>
    cfda:	18 c1       	rjmp	.+560    	; 0xd20c <FMenuLoyalty+0x29a>
    cfdc:	ea c0       	rjmp	.+468    	; 0xd1b2 <FMenuLoyalty+0x240>
    cfde:	0d 30       	cpi	r16, 0x0D	; 13
    cfe0:	09 f4       	brne	.+2      	; 0xcfe4 <FMenuLoyalty+0x72>
    cfe2:	f6 c1       	rjmp	.+1004   	; 0xd3d0 <FMenuLoyalty+0x45e>
    cfe4:	0d 30       	cpi	r16, 0x0D	; 13
    cfe6:	08 f4       	brcc	.+2      	; 0xcfea <FMenuLoyalty+0x78>
    cfe8:	ff c1       	rjmp	.+1022   	; 0xd3e8 <FMenuLoyalty+0x476>
    cfea:	0e 30       	cpi	r16, 0x0E	; 14
    cfec:	09 f4       	brne	.+2      	; 0xcff0 <FMenuLoyalty+0x7e>
    cfee:	0e c2       	rjmp	.+1052   	; 0xd40c <FMenuLoyalty+0x49a>
    cff0:	0f 30       	cpi	r16, 0x0F	; 15
    cff2:	09 f0       	breq	.+2      	; 0xcff6 <FMenuLoyalty+0x84>
    cff4:	17 c2       	rjmp	.+1070   	; 0xd424 <FMenuLoyalty+0x4b2>
    cff6:	10 c2       	rjmp	.+1056   	; 0xd418 <FMenuLoyalty+0x4a6>
	 case mlInit:
	      lcd_clear();
    cff8:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
    cffc:	81 e0       	ldi	r24, 0x01	; 1
    cffe:	61 e0       	ldi	r22, 0x01	; 1
    d000:	40 e4       	ldi	r20, 0x40	; 64
    d002:	5a e1       	ldi	r21, 0x1A	; 26
    d004:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
    d008:	81 e0       	ldi	r24, 0x01	; 1
    d00a:	61 e0       	ldi	r22, 0x01	; 1
    d00c:	4e e2       	ldi	r20, 0x2E	; 46
    d00e:	5a e1       	ldi	r21, 0x1A	; 26
    d010:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
    d014:	82 e0       	ldi	r24, 0x02	; 2
    d016:	61 e0       	ldi	r22, 0x01	; 1
    d018:	4c e1       	ldi	r20, 0x1C	; 28
    d01a:	5a e1       	ldi	r21, 0x1A	; 26
    d01c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
    d020:	84 e0       	ldi	r24, 0x04	; 4
    d022:	61 e0       	ldi	r22, 0x01	; 1
    d024:	4a e0       	ldi	r20, 0x0A	; 10
    d026:	5a e1       	ldi	r21, 0x1A	; 26
    d028:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  IsLoyaltyUpdate=False;
    d02c:	10 92 65 03 	sts	0x0365, r1
		  stLoyalty=mlLoyaltySelect;
    d030:	81 e0       	ldi	r24, 0x01	; 1
    d032:	0a c0       	rjmp	.+20     	; 0xd048 <FMenuLoyalty+0xd6>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
    d034:	81 e0       	ldi	r24, 0x01	; 1
    d036:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    d03a:	80 93 67 03 	sts	0x0367, r24
		  if (KeyPressed==_KEY_1){
    d03e:	8e 3e       	cpi	r24, 0xEE	; 238
    d040:	31 f4       	brne	.+12     	; 0xd04e <FMenuLoyalty+0xdc>
		      IsLoyaltyUpdate=False;
    d042:	10 92 65 03 	sts	0x0365, r1
		      stLoyalty=mlShowEnquiry;
    d046:	84 e0       	ldi	r24, 0x04	; 4
    d048:	80 93 68 03 	sts	0x0368, r24
    d04c:	eb c1       	rjmp	.+982    	; 0xd424 <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_2){
    d04e:	8e 3d       	cpi	r24, 0xDE	; 222
    d050:	19 f4       	brne	.+6      	; 0xd058 <FMenuLoyalty+0xe6>
		      IsLoyaltyUpdate=True;
    d052:	00 93 65 03 	sts	0x0365, r16
    d056:	6b c0       	rjmp	.+214    	; 0xd12e <FMenuLoyalty+0x1bc>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
    d058:	87 3e       	cpi	r24, 0xE7	; 231
    d05a:	09 f4       	brne	.+2      	; 0xd05e <FMenuLoyalty+0xec>
    d05c:	db c1       	rjmp	.+950    	; 0xd414 <FMenuLoyalty+0x4a2>
    d05e:	e2 c1       	rjmp	.+964    	; 0xd424 <FMenuLoyalty+0x4b2>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
    d060:	86 e6       	ldi	r24, 0x66	; 102
    d062:	93 e0       	ldi	r25, 0x03	; 3
    d064:	63 ec       	ldi	r22, 0xC3	; 195
    d066:	79 e0       	ldi	r23, 0x09	; 9
    d068:	0e 94 6a 65 	call	0xcad4	; 0xcad4 <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
    d06c:	88 23       	and	r24, r24
    d06e:	11 f4       	brne	.+4      	; 0xd074 <FMenuLoyalty+0x102>
    d070:	82 e0       	ldi	r24, 0x02	; 2
    d072:	ea cf       	rjmp	.-44     	; 0xd048 <FMenuLoyalty+0xd6>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
    d074:	82 30       	cpi	r24, 0x02	; 2
    d076:	09 f0       	breq	.+2      	; 0xd07a <FMenuLoyalty+0x108>
    d078:	d5 c1       	rjmp	.+938    	; 0xd424 <FMenuLoyalty+0x4b2>
    d07a:	5b c0       	rjmp	.+182    	; 0xd132 <FMenuLoyalty+0x1c0>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
    d07c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
    d080:	00 d0       	rcall	.+0      	; 0xd082 <FMenuLoyalty+0x110>
    d082:	00 d0       	rcall	.+0      	; 0xd084 <FMenuLoyalty+0x112>
    d084:	00 d0       	rcall	.+0      	; 0xd086 <FMenuLoyalty+0x114>
    d086:	ed b7       	in	r30, 0x3d	; 61
    d088:	fe b7       	in	r31, 0x3e	; 62
    d08a:	31 96       	adiw	r30, 0x01	; 1
    d08c:	8e 01       	movw	r16, r28
    d08e:	0f 5f       	subi	r16, 0xFF	; 255
    d090:	1f 4f       	sbci	r17, 0xFF	; 255
    d092:	ad b7       	in	r26, 0x3d	; 61
    d094:	be b7       	in	r27, 0x3e	; 62
    d096:	12 96       	adiw	r26, 0x02	; 2
    d098:	1c 93       	st	X, r17
    d09a:	0e 93       	st	-X, r16
    d09c:	11 97       	sbiw	r26, 0x01	; 1
    d09e:	83 e0       	ldi	r24, 0x03	; 3
    d0a0:	9a e1       	ldi	r25, 0x1A	; 26
    d0a2:	93 83       	std	Z+3, r25	; 0x03
    d0a4:	82 83       	std	Z+2, r24	; 0x02
    d0a6:	83 ec       	ldi	r24, 0xC3	; 195
    d0a8:	99 e0       	ldi	r25, 0x09	; 9
    d0aa:	95 83       	std	Z+5, r25	; 0x05
    d0ac:	84 83       	std	Z+4, r24	; 0x04
    d0ae:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    d0b2:	8d b7       	in	r24, 0x3d	; 61
    d0b4:	9e b7       	in	r25, 0x3e	; 62
    d0b6:	06 96       	adiw	r24, 0x06	; 6
    d0b8:	0f b6       	in	r0, 0x3f	; 63
    d0ba:	f8 94       	cli
    d0bc:	9e bf       	out	0x3e, r25	; 62
    d0be:	0f be       	out	0x3f, r0	; 63
    d0c0:	8d bf       	out	0x3d, r24	; 61
    d0c2:	81 e0       	ldi	r24, 0x01	; 1
    d0c4:	61 e0       	ldi	r22, 0x01	; 1
    d0c6:	44 ef       	ldi	r20, 0xF4	; 244
    d0c8:	59 e1       	ldi	r21, 0x19	; 25
    d0ca:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_print(2,1,lcdteks);
    d0ce:	82 e0       	ldi	r24, 0x02	; 2
    d0d0:	61 e0       	ldi	r22, 0x01	; 1
    d0d2:	a8 01       	movw	r20, r16
    d0d4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    d0d8:	84 e0       	ldi	r24, 0x04	; 4
    d0da:	61 e0       	ldi	r22, 0x01	; 1
    d0dc:	41 ee       	ldi	r20, 0xE1	; 225
    d0de:	59 e1       	ldi	r21, 0x19	; 25
    d0e0:	0c c0       	rjmp	.+24     	; 0xd0fa <FMenuLoyalty+0x188>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
    d0e2:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    d0e6:	81 e0       	ldi	r24, 0x01	; 1
    d0e8:	61 e0       	ldi	r22, 0x01	; 1
    d0ea:	42 ed       	ldi	r20, 0xD2	; 210
    d0ec:	59 e1       	ldi	r21, 0x19	; 25
    d0ee:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    d0f2:	84 e0       	ldi	r24, 0x04	; 4
    d0f4:	61 e0       	ldi	r22, 0x01	; 1
    d0f6:	4f eb       	ldi	r20, 0xBF	; 191
    d0f8:	59 e1       	ldi	r21, 0x19	; 25
    d0fa:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  IsRFIDDetected=False;
    d0fe:	10 92 c4 01 	sts	0x01C4, r1
		  stLoyalty=mlInputRFID;
    d102:	85 e0       	ldi	r24, 0x05	; 5
    d104:	a1 cf       	rjmp	.-190    	; 0xd048 <FMenuLoyalty+0xd6>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
    d106:	80 91 c4 01 	lds	r24, 0x01C4
    d10a:	81 30       	cpi	r24, 0x01	; 1
    d10c:	29 f4       	brne	.+10     	; 0xd118 <FMenuLoyalty+0x1a6>
		      IsRFIDDetected=False;
    d10e:	10 92 c4 01 	sts	0x01C4, r1
		      stLoyalty=mlShowProsesRFID;
    d112:	86 e0       	ldi	r24, 0x06	; 6
    d114:	80 93 68 03 	sts	0x0368, r24
		  }
	 	  KeyPressed=_key_scan(1);
    d118:	81 e0       	ldi	r24, 0x01	; 1
    d11a:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    d11e:	80 93 67 03 	sts	0x0367, r24
		  if (KeyPressed==_KEY_CANCEL){
    d122:	87 3e       	cpi	r24, 0xE7	; 231
    d124:	49 f4       	brne	.+18     	; 0xd138 <FMenuLoyalty+0x1c6>
		      if (IsLoyaltyUpdate==True)
    d126:	80 91 65 03 	lds	r24, 0x0365
    d12a:	81 30       	cpi	r24, 0x01	; 1
    d12c:	11 f4       	brne	.+4      	; 0xd132 <FMenuLoyalty+0x1c0>
			       stLoyalty=mlSelectFIP;
    d12e:	83 e0       	ldi	r24, 0x03	; 3
    d130:	8b cf       	rjmp	.-234    	; 0xd048 <FMenuLoyalty+0xd6>
			  else stLoyalty=mlInit;
    d132:	10 92 68 03 	sts	0x0368, r1
    d136:	76 c1       	rjmp	.+748    	; 0xd424 <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
    d138:	87 3b       	cpi	r24, 0xB7	; 183
    d13a:	09 f0       	breq	.+2      	; 0xd13e <FMenuLoyalty+0x1cc>
    d13c:	73 c1       	rjmp	.+742    	; 0xd424 <FMenuLoyalty+0x4b2>
    d13e:	6a c1       	rjmp	.+724    	; 0xd414 <FMenuLoyalty+0x4a2>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
    d140:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
    d144:	00 d0       	rcall	.+0      	; 0xd146 <FMenuLoyalty+0x1d4>
    d146:	00 d0       	rcall	.+0      	; 0xd148 <FMenuLoyalty+0x1d6>
    d148:	00 d0       	rcall	.+0      	; 0xd14a <FMenuLoyalty+0x1d8>
    d14a:	ed b7       	in	r30, 0x3d	; 61
    d14c:	fe b7       	in	r31, 0x3e	; 62
    d14e:	31 96       	adiw	r30, 0x01	; 1
    d150:	8e 01       	movw	r16, r28
    d152:	0f 5f       	subi	r16, 0xFF	; 255
    d154:	1f 4f       	sbci	r17, 0xFF	; 255
    d156:	ad b7       	in	r26, 0x3d	; 61
    d158:	be b7       	in	r27, 0x3e	; 62
    d15a:	12 96       	adiw	r26, 0x02	; 2
    d15c:	1c 93       	st	X, r17
    d15e:	0e 93       	st	-X, r16
    d160:	11 97       	sbiw	r26, 0x01	; 1
    d162:	89 eb       	ldi	r24, 0xB9	; 185
    d164:	99 e1       	ldi	r25, 0x19	; 25
    d166:	93 83       	std	Z+3, r25	; 0x03
    d168:	82 83       	std	Z+2, r24	; 0x02
    d16a:	87 e5       	ldi	r24, 0x57	; 87
    d16c:	9e e0       	ldi	r25, 0x0E	; 14
    d16e:	95 83       	std	Z+5, r25	; 0x05
    d170:	84 83       	std	Z+4, r24	; 0x04
    d172:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
    d176:	8d b7       	in	r24, 0x3d	; 61
    d178:	9e b7       	in	r25, 0x3e	; 62
    d17a:	06 96       	adiw	r24, 0x06	; 6
    d17c:	0f b6       	in	r0, 0x3f	; 63
    d17e:	f8 94       	cli
    d180:	9e bf       	out	0x3e, r25	; 62
    d182:	0f be       	out	0x3f, r0	; 63
    d184:	8d bf       	out	0x3d, r24	; 61
    d186:	81 e0       	ldi	r24, 0x01	; 1
    d188:	61 e0       	ldi	r22, 0x01	; 1
    d18a:	a8 01       	movw	r20, r16
    d18c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
    d190:	82 e0       	ldi	r24, 0x02	; 2
    d192:	61 e0       	ldi	r22, 0x01	; 1
    d194:	42 eb       	ldi	r20, 0xB2	; 178
    d196:	59 e1       	ldi	r21, 0x19	; 25
    d198:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
    d19c:	80 91 65 03 	lds	r24, 0x0365
    d1a0:	81 30       	cpi	r24, 0x01	; 1
    d1a2:	11 f4       	brne	.+4      	; 0xd1a8 <FMenuLoyalty+0x236>
    d1a4:	88 e0       	ldi	r24, 0x08	; 8
    d1a6:	50 cf       	rjmp	.-352    	; 0xd048 <FMenuLoyalty+0xd6>
		  else stLoyalty=mlSendMessage22;
    d1a8:	87 e0       	ldi	r24, 0x07	; 7
    d1aa:	4e cf       	rjmp	.-356    	; 0xd048 <FMenuLoyalty+0xd6>
	      break;
     case mlSendMessage22:
	      sendMessage22();
    d1ac:	0e 94 fc 51 	call	0xa3f8	; 0xa3f8 <sendMessage22>
    d1b0:	02 c0       	rjmp	.+4      	; 0xd1b6 <FMenuLoyalty+0x244>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
    d1b2:	0e 94 70 51 	call	0xa2e0	; 0xa2e0 <sendMessage24>
		  TimSend=0;		  
    d1b6:	10 92 be 01 	sts	0x01BE, r1
    d1ba:	10 92 bd 01 	sts	0x01BD, r1
          stLoyalty=mlWaitReply;
    d1be:	89 e0       	ldi	r24, 0x09	; 9
    d1c0:	43 cf       	rjmp	.-378    	; 0xd048 <FMenuLoyalty+0xd6>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
    d1c2:	80 91 bd 01 	lds	r24, 0x01BD
    d1c6:	90 91 be 01 	lds	r25, 0x01BE
    d1ca:	4f 97       	sbiw	r24, 0x1f	; 31
    d1cc:	18 f0       	brcs	.+6      	; 0xd1d4 <FMenuLoyalty+0x262>
		      stLoyalty=mlNoConnection;
    d1ce:	8c e0       	ldi	r24, 0x0C	; 12
    d1d0:	80 93 68 03 	sts	0x0368, r24
	      if (IsMessage23==True){
    d1d4:	80 91 cf 01 	lds	r24, 0x01CF
    d1d8:	81 30       	cpi	r24, 0x01	; 1
    d1da:	39 f4       	brne	.+14     	; 0xd1ea <FMenuLoyalty+0x278>
		      IsMessage23=False;
    d1dc:	10 92 cf 01 	sts	0x01CF, r1
			  procMessage23();
    d1e0:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <procMessage23>
			  stLoyalty=mlDispEnquiry;
    d1e4:	8b e0       	ldi	r24, 0x0B	; 11
    d1e6:	80 93 68 03 	sts	0x0368, r24
		  }
	      if (IsMessage09==True){
    d1ea:	80 91 d0 01 	lds	r24, 0x01D0
    d1ee:	81 30       	cpi	r24, 0x01	; 1
    d1f0:	39 f4       	brne	.+14     	; 0xd200 <FMenuLoyalty+0x28e>
		      IsMessage09=False;
    d1f2:	10 92 d0 01 	sts	0x01D0, r1
	          procMessage09();
    d1f6:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
    d1fa:	8a e0       	ldi	r24, 0x0A	; 10
    d1fc:	80 93 68 03 	sts	0x0368, r24
		  }
	      if (IsMessage99==True){
    d200:	80 91 cc 01 	lds	r24, 0x01CC
    d204:	81 30       	cpi	r24, 0x01	; 1
    d206:	09 f0       	breq	.+2      	; 0xd20a <FMenuLoyalty+0x298>
    d208:	0d c1       	rjmp	.+538    	; 0xd424 <FMenuLoyalty+0x4b2>
    d20a:	1c c0       	rjmp	.+56     	; 0xd244 <FMenuLoyalty+0x2d2>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
    d20c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    d210:	81 e0       	ldi	r24, 0x01	; 1
    d212:	61 e0       	ldi	r22, 0x01	; 1
    d214:	42 ec       	ldi	r20, 0xC2	; 194
    d216:	5a e0       	ldi	r21, 0x0A	; 10
    d218:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    d21c:	82 e0       	ldi	r24, 0x02	; 2
    d21e:	61 e0       	ldi	r22, 0x01	; 1
    d220:	4d ea       	ldi	r20, 0xAD	; 173
    d222:	59 e0       	ldi	r21, 0x09	; 9
    d224:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    d228:	83 e0       	ldi	r24, 0x03	; 3
    d22a:	61 e0       	ldi	r22, 0x01	; 1
    d22c:	48 e4       	ldi	r20, 0x48	; 72
    d22e:	5a e0       	ldi	r21, 0x0A	; 10
    d230:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    d234:	84 e0       	ldi	r24, 0x04	; 4
    d236:	61 e0       	ldi	r22, 0x01	; 1
    d238:	4c ed       	ldi	r20, 0xDC	; 220
    d23a:	5d e0       	ldi	r21, 0x0D	; 13
    d23c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  TimDisplay=0;
    d240:	10 92 bc 01 	sts	0x01BC, r1
		  stLoyalty=mlDelayExitLoyalty;
    d244:	8e e0       	ldi	r24, 0x0E	; 14
    d246:	00 cf       	rjmp	.-512    	; 0xd048 <FMenuLoyalty+0xd6>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
    d248:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
    d24c:	2c e8       	ldi	r18, 0x8C	; 140
    d24e:	c2 2e       	mov	r12, r18
    d250:	2d e0       	ldi	r18, 0x0D	; 13
    d252:	d2 2e       	mov	r13, r18
    d254:	c6 01       	movw	r24, r12
    d256:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
    d25a:	99 e2       	ldi	r25, 0x29	; 41
    d25c:	e9 2e       	mov	r14, r25
    d25e:	95 e0       	ldi	r25, 0x05	; 5
    d260:	f9 2e       	mov	r15, r25
    d262:	c7 01       	movw	r24, r14
    d264:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
    d268:	ad b7       	in	r26, 0x3d	; 61
    d26a:	be b7       	in	r27, 0x3e	; 62
    d26c:	18 97       	sbiw	r26, 0x08	; 8
    d26e:	0f b6       	in	r0, 0x3f	; 63
    d270:	f8 94       	cli
    d272:	be bf       	out	0x3e, r27	; 62
    d274:	0f be       	out	0x3f, r0	; 63
    d276:	ad bf       	out	0x3d, r26	; 61
    d278:	ed b7       	in	r30, 0x3d	; 61
    d27a:	fe b7       	in	r31, 0x3e	; 62
    d27c:	31 96       	adiw	r30, 0x01	; 1
    d27e:	8e 01       	movw	r16, r28
    d280:	0f 5f       	subi	r16, 0xFF	; 255
    d282:	1f 4f       	sbci	r17, 0xFF	; 255
    d284:	12 96       	adiw	r26, 0x02	; 2
    d286:	1c 93       	st	X, r17
    d288:	0e 93       	st	-X, r16
    d28a:	11 97       	sbiw	r26, 0x01	; 1
    d28c:	8c ea       	ldi	r24, 0xAC	; 172
    d28e:	99 e1       	ldi	r25, 0x19	; 25
    d290:	93 83       	std	Z+3, r25	; 0x03
    d292:	82 83       	std	Z+2, r24	; 0x02
    d294:	d5 82       	std	Z+5, r13	; 0x05
    d296:	c4 82       	std	Z+4, r12	; 0x04
    d298:	f7 82       	std	Z+7, r15	; 0x07
    d29a:	e6 82       	std	Z+6, r14	; 0x06
    d29c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d2a0:	8d b7       	in	r24, 0x3d	; 61
    d2a2:	9e b7       	in	r25, 0x3e	; 62
    d2a4:	08 96       	adiw	r24, 0x08	; 8
    d2a6:	0f b6       	in	r0, 0x3f	; 63
    d2a8:	f8 94       	cli
    d2aa:	9e bf       	out	0x3e, r25	; 62
    d2ac:	0f be       	out	0x3f, r0	; 63
    d2ae:	8d bf       	out	0x3d, r24	; 61
    d2b0:	81 e0       	ldi	r24, 0x01	; 1
    d2b2:	61 e0       	ldi	r22, 0x01	; 1
    d2b4:	a8 01       	movw	r20, r16
    d2b6:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    d2ba:	81 e6       	ldi	r24, 0x61	; 97
    d2bc:	e8 2e       	mov	r14, r24
    d2be:	8a e0       	ldi	r24, 0x0A	; 10
    d2c0:	f8 2e       	mov	r15, r24
    d2c2:	c7 01       	movw	r24, r14
    d2c4:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
    d2c8:	00 d0       	rcall	.+0      	; 0xd2ca <FMenuLoyalty+0x358>
    d2ca:	00 d0       	rcall	.+0      	; 0xd2cc <FMenuLoyalty+0x35a>
    d2cc:	00 d0       	rcall	.+0      	; 0xd2ce <FMenuLoyalty+0x35c>
    d2ce:	ed b7       	in	r30, 0x3d	; 61
    d2d0:	fe b7       	in	r31, 0x3e	; 62
    d2d2:	31 96       	adiw	r30, 0x01	; 1
    d2d4:	ad b7       	in	r26, 0x3d	; 61
    d2d6:	be b7       	in	r27, 0x3e	; 62
    d2d8:	12 96       	adiw	r26, 0x02	; 2
    d2da:	1c 93       	st	X, r17
    d2dc:	0e 93       	st	-X, r16
    d2de:	11 97       	sbiw	r26, 0x01	; 1
    d2e0:	82 ea       	ldi	r24, 0xA2	; 162
    d2e2:	99 e1       	ldi	r25, 0x19	; 25
    d2e4:	93 83       	std	Z+3, r25	; 0x03
    d2e6:	82 83       	std	Z+2, r24	; 0x02
    d2e8:	f5 82       	std	Z+5, r15	; 0x05
    d2ea:	e4 82       	std	Z+4, r14	; 0x04
    d2ec:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d2f0:	8d b7       	in	r24, 0x3d	; 61
    d2f2:	9e b7       	in	r25, 0x3e	; 62
    d2f4:	06 96       	adiw	r24, 0x06	; 6
    d2f6:	0f b6       	in	r0, 0x3f	; 63
    d2f8:	f8 94       	cli
    d2fa:	9e bf       	out	0x3e, r25	; 62
    d2fc:	0f be       	out	0x3f, r0	; 63
    d2fe:	8d bf       	out	0x3d, r24	; 61
    d300:	82 e0       	ldi	r24, 0x02	; 2
    d302:	61 e0       	ldi	r22, 0x01	; 1
    d304:	a8 01       	movw	r20, r16
    d306:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    d30a:	c7 01       	movw	r24, r14
    d30c:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
    d310:	00 d0       	rcall	.+0      	; 0xd312 <FMenuLoyalty+0x3a0>
    d312:	00 d0       	rcall	.+0      	; 0xd314 <FMenuLoyalty+0x3a2>
    d314:	00 d0       	rcall	.+0      	; 0xd316 <FMenuLoyalty+0x3a4>
    d316:	ed b7       	in	r30, 0x3d	; 61
    d318:	fe b7       	in	r31, 0x3e	; 62
    d31a:	31 96       	adiw	r30, 0x01	; 1
    d31c:	ad b7       	in	r26, 0x3d	; 61
    d31e:	be b7       	in	r27, 0x3e	; 62
    d320:	12 96       	adiw	r26, 0x02	; 2
    d322:	1c 93       	st	X, r17
    d324:	0e 93       	st	-X, r16
    d326:	11 97       	sbiw	r26, 0x01	; 1
    d328:	88 e9       	ldi	r24, 0x98	; 152
    d32a:	99 e1       	ldi	r25, 0x19	; 25
    d32c:	93 83       	std	Z+3, r25	; 0x03
    d32e:	82 83       	std	Z+2, r24	; 0x02
    d330:	83 e8       	ldi	r24, 0x83	; 131
    d332:	95 e0       	ldi	r25, 0x05	; 5
    d334:	95 83       	std	Z+5, r25	; 0x05
    d336:	84 83       	std	Z+4, r24	; 0x04
    d338:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d33c:	8d b7       	in	r24, 0x3d	; 61
    d33e:	9e b7       	in	r25, 0x3e	; 62
    d340:	06 96       	adiw	r24, 0x06	; 6
    d342:	0f b6       	in	r0, 0x3f	; 63
    d344:	f8 94       	cli
    d346:	9e bf       	out	0x3e, r25	; 62
    d348:	0f be       	out	0x3f, r0	; 63
    d34a:	8d bf       	out	0x3d, r24	; 61
    d34c:	83 e0       	ldi	r24, 0x03	; 3
    d34e:	61 e0       	ldi	r22, 0x01	; 1
    d350:	a8 01       	movw	r20, r16
    d352:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    d356:	c7 01       	movw	r24, r14
    d358:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
    d35c:	00 d0       	rcall	.+0      	; 0xd35e <FMenuLoyalty+0x3ec>
    d35e:	00 d0       	rcall	.+0      	; 0xd360 <FMenuLoyalty+0x3ee>
    d360:	00 d0       	rcall	.+0      	; 0xd362 <FMenuLoyalty+0x3f0>
    d362:	ed b7       	in	r30, 0x3d	; 61
    d364:	fe b7       	in	r31, 0x3e	; 62
    d366:	31 96       	adiw	r30, 0x01	; 1
    d368:	ad b7       	in	r26, 0x3d	; 61
    d36a:	be b7       	in	r27, 0x3e	; 62
    d36c:	12 96       	adiw	r26, 0x02	; 2
    d36e:	1c 93       	st	X, r17
    d370:	0e 93       	st	-X, r16
    d372:	11 97       	sbiw	r26, 0x01	; 1
    d374:	8e e8       	ldi	r24, 0x8E	; 142
    d376:	99 e1       	ldi	r25, 0x19	; 25
    d378:	93 83       	std	Z+3, r25	; 0x03
    d37a:	82 83       	std	Z+2, r24	; 0x02
    d37c:	83 ef       	ldi	r24, 0xF3	; 243
    d37e:	9d e0       	ldi	r25, 0x0D	; 13
    d380:	95 83       	std	Z+5, r25	; 0x05
    d382:	84 83       	std	Z+4, r24	; 0x04
    d384:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    d388:	8d b7       	in	r24, 0x3d	; 61
    d38a:	9e b7       	in	r25, 0x3e	; 62
    d38c:	06 96       	adiw	r24, 0x06	; 6
    d38e:	0f b6       	in	r0, 0x3f	; 63
    d390:	f8 94       	cli
    d392:	9e bf       	out	0x3e, r25	; 62
    d394:	0f be       	out	0x3f, r0	; 63
    d396:	8d bf       	out	0x3d, r24	; 61
    d398:	84 e0       	ldi	r24, 0x04	; 4
    d39a:	61 e0       	ldi	r22, 0x01	; 1
    d39c:	a8 01       	movw	r20, r16
    d39e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  TimDisplay=0;
    d3a2:	10 92 bc 01 	sts	0x01BC, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    d3a6:	e1 99       	sbic	0x1c, 1	; 28
    d3a8:	fe cf       	rjmp	.-4      	; 0xd3a6 <FMenuLoyalty+0x434>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    d3aa:	88 e3       	ldi	r24, 0x38	; 56
    d3ac:	90 e0       	ldi	r25, 0x00	; 0
    d3ae:	9f bb       	out	0x1f, r25	; 31
    d3b0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    d3b2:	e0 9a       	sbi	0x1c, 0	; 28
    d3b4:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
    d3b6:	81 30       	cpi	r24, 0x01	; 1
    d3b8:	09 f0       	breq	.+2      	; 0xd3bc <FMenuLoyalty+0x44a>
    d3ba:	44 cf       	rjmp	.-376    	; 0xd244 <FMenuLoyalty+0x2d2>
		      stLoyalty=mlPressAnyKey;
    d3bc:	8d e0       	ldi	r24, 0x0D	; 13
    d3be:	80 93 68 03 	sts	0x0368, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
    d3c2:	82 e0       	ldi	r24, 0x02	; 2
    d3c4:	61 e0       	ldi	r22, 0x01	; 1
    d3c6:	40 e8       	ldi	r20, 0x80	; 128
    d3c8:	59 e1       	ldi	r21, 0x19	; 25
    d3ca:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    d3ce:	2a c0       	rjmp	.+84     	; 0xd424 <FMenuLoyalty+0x4b2>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
    d3d0:	81 e0       	ldi	r24, 0x01	; 1
    d3d2:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    d3d6:	80 93 67 03 	sts	0x0367, r24
	      KeyChar=_key_btn(KeyPressed);
    d3da:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
	      switch(KeyChar){		  
    d3de:	83 32       	cpi	r24, 0x23	; 35
    d3e0:	c9 f0       	breq	.+50     	; 0xd414 <FMenuLoyalty+0x4a2>
    d3e2:	8a 32       	cpi	r24, 0x2A	; 42
    d3e4:	f9 f4       	brne	.+62     	; 0xd424 <FMenuLoyalty+0x4b2>
    d3e6:	16 c0       	rjmp	.+44     	; 0xd414 <FMenuLoyalty+0x4a2>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
    d3e8:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
    d3ec:	82 e0       	ldi	r24, 0x02	; 2
    d3ee:	61 e0       	ldi	r22, 0x01	; 1
    d3f0:	42 e7       	ldi	r20, 0x72	; 114
    d3f2:	59 e1       	ldi	r21, 0x19	; 25
    d3f4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
    d3f8:	83 e0       	ldi	r24, 0x03	; 3
    d3fa:	61 e0       	ldi	r22, 0x01	; 1
    d3fc:	44 e6       	ldi	r20, 0x64	; 100
    d3fe:	59 e1       	ldi	r21, 0x19	; 25
    d400:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  TimDisplay=5;
    d404:	85 e0       	ldi	r24, 0x05	; 5
    d406:	80 93 bc 01 	sts	0x01BC, r24
    d40a:	1c cf       	rjmp	.-456    	; 0xd244 <FMenuLoyalty+0x2d2>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
    d40c:	80 91 bc 01 	lds	r24, 0x01BC
    d410:	8a 30       	cpi	r24, 0x0A	; 10
    d412:	40 f0       	brcs	.+16     	; 0xd424 <FMenuLoyalty+0x4b2>
    d414:	8f e0       	ldi	r24, 0x0F	; 15
    d416:	18 ce       	rjmp	.-976    	; 0xd048 <FMenuLoyalty+0xd6>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
    d418:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	      stLoyalty=mlInit;
    d41c:	10 92 68 03 	sts	0x0368, r1
    d420:	81 e0       	ldi	r24, 0x01	; 1
    d422:	01 c0       	rjmp	.+2      	; 0xd426 <FMenuLoyalty+0x4b4>
    d424:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
    d426:	64 96       	adiw	r28, 0x14	; 20
    d428:	0f b6       	in	r0, 0x3f	; 63
    d42a:	f8 94       	cli
    d42c:	de bf       	out	0x3e, r29	; 62
    d42e:	0f be       	out	0x3f, r0	; 63
    d430:	cd bf       	out	0x3d, r28	; 61
    d432:	cf 91       	pop	r28
    d434:	df 91       	pop	r29
    d436:	1f 91       	pop	r17
    d438:	0f 91       	pop	r16
    d43a:	ff 90       	pop	r15
    d43c:	ef 90       	pop	r14
    d43e:	df 90       	pop	r13
    d440:	cf 90       	pop	r12
    d442:	08 95       	ret

0000d444 <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    d444:	0f 93       	push	r16
    d446:	1f 93       	push	r17
    d448:	df 93       	push	r29
    d44a:	cf 93       	push	r28
    d44c:	cd b7       	in	r28, 0x3d	; 61
    d44e:	de b7       	in	r29, 0x3e	; 62
    d450:	64 97       	sbiw	r28, 0x14	; 20
    d452:	0f b6       	in	r0, 0x3f	; 63
    d454:	f8 94       	cli
    d456:	de bf       	out	0x3e, r29	; 62
    d458:	0f be       	out	0x3f, r0	; 63
    d45a:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    d45c:	10 92 1a 03 	sts	0x031A, r1
     switch(stClientIP){
    d460:	80 91 6d 01 	lds	r24, 0x016D
    d464:	82 30       	cpi	r24, 0x02	; 2
    d466:	09 f4       	brne	.+2      	; 0xd46a <FMenuSettingServerIP+0x26>
    d468:	7b c0       	rjmp	.+246    	; 0xd560 <FMenuSettingServerIP+0x11c>
    d46a:	83 30       	cpi	r24, 0x03	; 3
    d46c:	20 f4       	brcc	.+8      	; 0xd476 <FMenuSettingServerIP+0x32>
    d46e:	81 30       	cpi	r24, 0x01	; 1
    d470:	09 f0       	breq	.+2      	; 0xd474 <FMenuSettingServerIP+0x30>
    d472:	65 c2       	rjmp	.+1226   	; 0xd93e <FMenuSettingServerIP+0x4fa>
    d474:	07 c0       	rjmp	.+14     	; 0xd484 <FMenuSettingServerIP+0x40>
    d476:	83 30       	cpi	r24, 0x03	; 3
    d478:	09 f4       	brne	.+2      	; 0xd47c <FMenuSettingServerIP+0x38>
    d47a:	5c c2       	rjmp	.+1208   	; 0xd934 <FMenuSettingServerIP+0x4f0>
    d47c:	84 30       	cpi	r24, 0x04	; 4
    d47e:	09 f0       	breq	.+2      	; 0xd482 <FMenuSettingServerIP+0x3e>
    d480:	5e c2       	rjmp	.+1212   	; 0xd93e <FMenuSettingServerIP+0x4fa>
    d482:	4a c2       	rjmp	.+1172   	; 0xd918 <FMenuSettingServerIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d484:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    d488:	81 e0       	ldi	r24, 0x01	; 1
    d48a:	61 e0       	ldi	r22, 0x01	; 1
    d48c:	46 eb       	ldi	r20, 0xB6	; 182
    d48e:	51 e1       	ldi	r21, 0x11	; 17
    d490:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d494:	81 e1       	ldi	r24, 0x11	; 17
    d496:	93 e0       	ldi	r25, 0x03	; 3
    d498:	6c e2       	ldi	r22, 0x2C	; 44
    d49a:	70 e0       	ldi	r23, 0x00	; 0
    d49c:	44 e0       	ldi	r20, 0x04	; 4
    d49e:	50 e0       	ldi	r21, 0x00	; 0
    d4a0:	27 e9       	ldi	r18, 0x97	; 151
    d4a2:	32 e1       	ldi	r19, 0x12	; 18
    d4a4:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d4a8:	8d b7       	in	r24, 0x3d	; 61
    d4aa:	9e b7       	in	r25, 0x3e	; 62
    d4ac:	0c 97       	sbiw	r24, 0x0c	; 12
    d4ae:	0f b6       	in	r0, 0x3f	; 63
    d4b0:	f8 94       	cli
    d4b2:	9e bf       	out	0x3e, r25	; 62
    d4b4:	0f be       	out	0x3f, r0	; 63
    d4b6:	8d bf       	out	0x3d, r24	; 61
    d4b8:	ed b7       	in	r30, 0x3d	; 61
    d4ba:	fe b7       	in	r31, 0x3e	; 62
    d4bc:	31 96       	adiw	r30, 0x01	; 1
    d4be:	8e 01       	movw	r16, r28
    d4c0:	0f 5f       	subi	r16, 0xFF	; 255
    d4c2:	1f 4f       	sbci	r17, 0xFF	; 255
    d4c4:	ad b7       	in	r26, 0x3d	; 61
    d4c6:	be b7       	in	r27, 0x3e	; 62
    d4c8:	12 96       	adiw	r26, 0x02	; 2
    d4ca:	1c 93       	st	X, r17
    d4cc:	0e 93       	st	-X, r16
    d4ce:	11 97       	sbiw	r26, 0x01	; 1
    d4d0:	85 ea       	ldi	r24, 0xA5	; 165
    d4d2:	91 e1       	ldi	r25, 0x11	; 17
    d4d4:	93 83       	std	Z+3, r25	; 0x03
    d4d6:	82 83       	std	Z+2, r24	; 0x02
    d4d8:	80 91 11 03 	lds	r24, 0x0311
    d4dc:	84 83       	std	Z+4, r24	; 0x04
    d4de:	15 82       	std	Z+5, r1	; 0x05
    d4e0:	80 91 12 03 	lds	r24, 0x0312
    d4e4:	86 83       	std	Z+6, r24	; 0x06
    d4e6:	17 82       	std	Z+7, r1	; 0x07
    d4e8:	80 91 13 03 	lds	r24, 0x0313
    d4ec:	80 87       	std	Z+8, r24	; 0x08
    d4ee:	11 86       	std	Z+9, r1	; 0x09
    d4f0:	80 91 14 03 	lds	r24, 0x0314
    d4f4:	82 87       	std	Z+10, r24	; 0x0a
    d4f6:	13 86       	std	Z+11, r1	; 0x0b
    d4f8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d4fc:	ed b7       	in	r30, 0x3d	; 61
    d4fe:	fe b7       	in	r31, 0x3e	; 62
    d500:	3c 96       	adiw	r30, 0x0c	; 12
    d502:	0f b6       	in	r0, 0x3f	; 63
    d504:	f8 94       	cli
    d506:	fe bf       	out	0x3e, r31	; 62
    d508:	0f be       	out	0x3f, r0	; 63
    d50a:	ed bf       	out	0x3d, r30	; 61
    d50c:	82 e0       	ldi	r24, 0x02	; 2
    d50e:	61 e0       	ldi	r22, 0x01	; 1
    d510:	a8 01       	movw	r20, r16
    d512:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d516:	83 e0       	ldi	r24, 0x03	; 3
    d518:	61 e0       	ldi	r22, 0x01	; 1
    d51a:	40 e9       	ldi	r20, 0x90	; 144
    d51c:	51 e1       	ldi	r21, 0x11	; 17
    d51e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d522:	84 e0       	ldi	r24, 0x04	; 4
    d524:	61 e0       	ldi	r22, 0x01	; 1
    d526:	4b e7       	ldi	r20, 0x7B	; 123
    d528:	51 e1       	ldi	r21, 0x11	; 17
    d52a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
               iLoop=0;
    d52e:	10 92 10 03 	sts	0x0310, r1
    d532:	10 92 0f 03 	sts	0x030F, r1
			   y=3,x=8;
    d536:	83 e0       	ldi	r24, 0x03	; 3
    d538:	80 93 17 03 	sts	0x0317, r24
    d53c:	88 e0       	ldi	r24, 0x08	; 8
    d53e:	80 93 18 03 	sts	0x0318, r24
			   iInput=0; iBlok=0;
    d542:	10 92 16 03 	sts	0x0316, r1
    d546:	10 92 0e 03 	sts	0x030E, r1
    d54a:	10 92 0d 03 	sts	0x030D, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d54e:	80 e3       	ldi	r24, 0x30	; 48
    d550:	80 93 1c 03 	sts	0x031C, r24
    d554:	80 93 1d 03 	sts	0x031D, r24
    d558:	80 93 1e 03 	sts	0x031E, r24
			   stClientIP=cipInputIP; 
    d55c:	82 e0       	ldi	r24, 0x02	; 2
    d55e:	e7 c1       	rjmp	.+974    	; 0xd92e <FMenuSettingServerIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d560:	80 91 0f 03 	lds	r24, 0x030F
    d564:	90 91 10 03 	lds	r25, 0x0310
    d568:	01 96       	adiw	r24, 0x01	; 1
    d56a:	90 93 10 03 	sts	0x0310, r25
    d56e:	80 93 0f 03 	sts	0x030F, r24
			   if ((iLoop%2000)==0){
    d572:	60 ed       	ldi	r22, 0xD0	; 208
    d574:	77 e0       	ldi	r23, 0x07	; 7
    d576:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    d57a:	89 2b       	or	r24, r25
    d57c:	81 f4       	brne	.+32     	; 0xd59e <FMenuSettingServerIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d57e:	80 91 0d 03 	lds	r24, 0x030D
    d582:	90 91 0e 03 	lds	r25, 0x030E
    d586:	88 0f       	add	r24, r24
    d588:	99 1f       	adc	r25, r25
    d58a:	88 0f       	add	r24, r24
    d58c:	99 1f       	adc	r25, r25
    d58e:	60 91 18 03 	lds	r22, 0x0318
    d592:	68 0f       	add	r22, r24
    d594:	80 91 17 03 	lds	r24, 0x0317
    d598:	4f e5       	ldi	r20, 0x5F	; 95
    d59a:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d59e:	80 91 0f 03 	lds	r24, 0x030F
    d5a2:	90 91 10 03 	lds	r25, 0x0310
    d5a6:	60 ed       	ldi	r22, 0xD0	; 208
    d5a8:	77 e0       	ldi	r23, 0x07	; 7
    d5aa:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    d5ae:	88 5e       	subi	r24, 0xE8	; 232
    d5b0:	93 40       	sbci	r25, 0x03	; 3
    d5b2:	81 f4       	brne	.+32     	; 0xd5d4 <FMenuSettingServerIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d5b4:	80 91 0d 03 	lds	r24, 0x030D
    d5b8:	90 91 0e 03 	lds	r25, 0x030E
    d5bc:	88 0f       	add	r24, r24
    d5be:	99 1f       	adc	r25, r25
    d5c0:	88 0f       	add	r24, r24
    d5c2:	99 1f       	adc	r25, r25
    d5c4:	60 91 18 03 	lds	r22, 0x0318
    d5c8:	68 0f       	add	r22, r24
    d5ca:	80 91 17 03 	lds	r24, 0x0317
    d5ce:	40 e2       	ldi	r20, 0x20	; 32
    d5d0:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d5d4:	81 e0       	ldi	r24, 0x01	; 1
    d5d6:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    d5da:	80 93 15 03 	sts	0x0315, r24
			   keyChar=_key_btn(keyPressed);
    d5de:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    d5e2:	28 2f       	mov	r18, r24
    d5e4:	80 93 19 03 	sts	0x0319, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d5e8:	80 53       	subi	r24, 0x30	; 48
    d5ea:	8a 30       	cpi	r24, 0x0A	; 10
    d5ec:	08 f0       	brcs	.+2      	; 0xd5f0 <FMenuSettingServerIP+0x1ac>
    d5ee:	d6 c0       	rjmp	.+428    	; 0xd79c <FMenuSettingServerIP+0x358>
    d5f0:	80 e5       	ldi	r24, 0x50	; 80
    d5f2:	93 ec       	ldi	r25, 0xC3	; 195
    d5f4:	01 97       	sbiw	r24, 0x01	; 1
    d5f6:	f1 f7       	brne	.-4      	; 0xd5f4 <FMenuSettingServerIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d5f8:	80 91 16 03 	lds	r24, 0x0316
    d5fc:	e8 2f       	mov	r30, r24
    d5fe:	f0 e0       	ldi	r31, 0x00	; 0
    d600:	e4 5e       	subi	r30, 0xE4	; 228
    d602:	fc 4f       	sbci	r31, 0xFC	; 252
    d604:	20 83       	st	Z, r18
				   iInput++;                    
    d606:	8f 5f       	subi	r24, 0xFF	; 255
    d608:	80 93 16 03 	sts	0x0316, r24
				   for (i=1;i<(iInput+1);i++){
    d60c:	81 e0       	ldi	r24, 0x01	; 1
    d60e:	1c c0       	rjmp	.+56     	; 0xd648 <FMenuSettingServerIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d610:	80 91 18 03 	lds	r24, 0x0318
    d614:	68 0f       	add	r22, r24
    d616:	63 50       	subi	r22, 0x03	; 3
    d618:	80 91 0d 03 	lds	r24, 0x030D
    d61c:	90 91 0e 03 	lds	r25, 0x030E
    d620:	88 0f       	add	r24, r24
    d622:	99 1f       	adc	r25, r25
    d624:	88 0f       	add	r24, r24
    d626:	99 1f       	adc	r25, r25
    d628:	68 0f       	add	r22, r24
    d62a:	80 91 17 03 	lds	r24, 0x0317
    d62e:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
    d632:	e0 91 1b 03 	lds	r30, 0x031B
    d636:	f0 e0       	ldi	r31, 0x00	; 0
    d638:	e5 5e       	subi	r30, 0xE5	; 229
    d63a:	fc 4f       	sbci	r31, 0xFC	; 252
    d63c:	80 81       	ld	r24, Z
    d63e:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d642:	80 91 1b 03 	lds	r24, 0x031B
    d646:	8f 5f       	subi	r24, 0xFF	; 255
    d648:	80 93 1b 03 	sts	0x031B, r24
    d64c:	70 91 16 03 	lds	r23, 0x0316
    d650:	60 91 1b 03 	lds	r22, 0x031B
    d654:	27 2f       	mov	r18, r23
    d656:	30 e0       	ldi	r19, 0x00	; 0
    d658:	86 2f       	mov	r24, r22
    d65a:	90 e0       	ldi	r25, 0x00	; 0
    d65c:	28 17       	cp	r18, r24
    d65e:	39 07       	cpc	r19, r25
    d660:	bc f6       	brge	.-82     	; 0xd610 <FMenuSettingServerIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d662:	73 30       	cpi	r23, 0x03	; 3
    d664:	08 f4       	brcc	.+2      	; 0xd668 <FMenuSettingServerIP+0x224>
    d666:	91 c0       	rjmp	.+290    	; 0xd78a <FMenuSettingServerIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d668:	40 91 0d 03 	lds	r20, 0x030D
    d66c:	50 91 0e 03 	lds	r21, 0x030E
    d670:	fa 01       	movw	r30, r20
    d672:	ef 5e       	subi	r30, 0xEF	; 239
    d674:	fc 4f       	sbci	r31, 0xFC	; 252
    d676:	20 91 1e 03 	lds	r18, 0x031E
    d67a:	20 5d       	subi	r18, 0xD0	; 208
    d67c:	80 91 1c 03 	lds	r24, 0x031C
    d680:	34 e6       	ldi	r19, 0x64	; 100
    d682:	83 9f       	mul	r24, r19
    d684:	c0 01       	movw	r24, r0
    d686:	11 24       	eor	r1, r1
    d688:	28 0f       	add	r18, r24
    d68a:	80 91 1d 03 	lds	r24, 0x031D
    d68e:	3a e0       	ldi	r19, 0x0A	; 10
    d690:	83 9f       	mul	r24, r19
    d692:	c0 01       	movw	r24, r0
    d694:	11 24       	eor	r1, r1
    d696:	28 0f       	add	r18, r24
    d698:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d69a:	80 e3       	ldi	r24, 0x30	; 48
    d69c:	80 93 1c 03 	sts	0x031C, r24
    d6a0:	80 93 1d 03 	sts	0x031D, r24
    d6a4:	80 93 1e 03 	sts	0x031E, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d6a8:	44 0f       	add	r20, r20
    d6aa:	55 1f       	adc	r21, r21
    d6ac:	44 0f       	add	r20, r20
    d6ae:	55 1f       	adc	r21, r21
    d6b0:	60 91 18 03 	lds	r22, 0x0318
    d6b4:	64 0f       	add	r22, r20
    d6b6:	67 1b       	sub	r22, r23
    d6b8:	80 91 17 03 	lds	r24, 0x0317
    d6bc:	47 e7       	ldi	r20, 0x77	; 119
    d6be:	51 e1       	ldi	r21, 0x11	; 17
    d6c0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d6c4:	00 d0       	rcall	.+0      	; 0xd6c6 <FMenuSettingServerIP+0x282>
    d6c6:	00 d0       	rcall	.+0      	; 0xd6c8 <FMenuSettingServerIP+0x284>
    d6c8:	00 d0       	rcall	.+0      	; 0xd6ca <FMenuSettingServerIP+0x286>
    d6ca:	ad b7       	in	r26, 0x3d	; 61
    d6cc:	be b7       	in	r27, 0x3e	; 62
    d6ce:	11 96       	adiw	r26, 0x01	; 1
    d6d0:	8e 01       	movw	r16, r28
    d6d2:	0f 5f       	subi	r16, 0xFF	; 255
    d6d4:	1f 4f       	sbci	r17, 0xFF	; 255
    d6d6:	ed b7       	in	r30, 0x3d	; 61
    d6d8:	fe b7       	in	r31, 0x3e	; 62
    d6da:	12 83       	std	Z+2, r17	; 0x02
    d6dc:	01 83       	std	Z+1, r16	; 0x01
    d6de:	84 e7       	ldi	r24, 0x74	; 116
    d6e0:	91 e1       	ldi	r25, 0x11	; 17
    d6e2:	13 96       	adiw	r26, 0x03	; 3
    d6e4:	9c 93       	st	X, r25
    d6e6:	8e 93       	st	-X, r24
    d6e8:	12 97       	sbiw	r26, 0x02	; 2
    d6ea:	e0 91 0d 03 	lds	r30, 0x030D
    d6ee:	f0 91 0e 03 	lds	r31, 0x030E
    d6f2:	ef 5e       	subi	r30, 0xEF	; 239
    d6f4:	fc 4f       	sbci	r31, 0xFC	; 252
    d6f6:	80 81       	ld	r24, Z
    d6f8:	14 96       	adiw	r26, 0x04	; 4
    d6fa:	8c 93       	st	X, r24
    d6fc:	14 97       	sbiw	r26, 0x04	; 4
    d6fe:	15 96       	adiw	r26, 0x05	; 5
    d700:	1c 92       	st	X, r1
    d702:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d706:	f8 01       	movw	r30, r16
    d708:	01 90       	ld	r0, Z+
    d70a:	00 20       	and	r0, r0
    d70c:	e9 f7       	brne	.-6      	; 0xd708 <FMenuSettingServerIP+0x2c4>
    d70e:	31 97       	sbiw	r30, 0x01	; 1
    d710:	e0 1b       	sub	r30, r16
    d712:	f1 0b       	sbc	r31, r17
    d714:	8d b7       	in	r24, 0x3d	; 61
    d716:	9e b7       	in	r25, 0x3e	; 62
    d718:	06 96       	adiw	r24, 0x06	; 6
    d71a:	0f b6       	in	r0, 0x3f	; 63
    d71c:	f8 94       	cli
    d71e:	9e bf       	out	0x3e, r25	; 62
    d720:	0f be       	out	0x3f, r0	; 63
    d722:	8d bf       	out	0x3d, r24	; 61
    d724:	60 91 18 03 	lds	r22, 0x0318
    d728:	6f 5f       	subi	r22, 0xFF	; 255
    d72a:	80 91 0d 03 	lds	r24, 0x030D
    d72e:	90 91 0e 03 	lds	r25, 0x030E
    d732:	88 0f       	add	r24, r24
    d734:	99 1f       	adc	r25, r25
    d736:	88 0f       	add	r24, r24
    d738:	99 1f       	adc	r25, r25
    d73a:	68 0f       	add	r22, r24
    d73c:	6e 1b       	sub	r22, r30
    d73e:	80 91 17 03 	lds	r24, 0x0317
    d742:	a8 01       	movw	r20, r16
    d744:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d748:	80 91 0d 03 	lds	r24, 0x030D
    d74c:	90 91 0e 03 	lds	r25, 0x030E
    d750:	00 97       	sbiw	r24, 0x00	; 0
    d752:	81 f0       	breq	.+32     	; 0xd774 <FMenuSettingServerIP+0x330>
    d754:	60 91 18 03 	lds	r22, 0x0318
    d758:	6f 5f       	subi	r22, 0xFF	; 255
    d75a:	81 50       	subi	r24, 0x01	; 1
    d75c:	90 4c       	sbci	r25, 0xC0	; 192
    d75e:	88 0f       	add	r24, r24
    d760:	99 1f       	adc	r25, r25
    d762:	88 0f       	add	r24, r24
    d764:	99 1f       	adc	r25, r25
    d766:	68 0f       	add	r22, r24
    d768:	80 91 17 03 	lds	r24, 0x0317
    d76c:	42 e7       	ldi	r20, 0x72	; 114
    d76e:	51 e1       	ldi	r21, 0x11	; 17
    d770:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					   iInput=0;
    d774:	10 92 16 03 	sts	0x0316, r1
					   iBlok++;
    d778:	80 91 0d 03 	lds	r24, 0x030D
    d77c:	90 91 0e 03 	lds	r25, 0x030E
    d780:	01 96       	adiw	r24, 0x01	; 1
    d782:	90 93 0e 03 	sts	0x030E, r25
    d786:	80 93 0d 03 	sts	0x030D, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d78a:	80 91 0d 03 	lds	r24, 0x030D
    d78e:	90 91 0e 03 	lds	r25, 0x030E
    d792:	04 97       	sbiw	r24, 0x04	; 4
    d794:	18 f0       	brcs	.+6      	; 0xd79c <FMenuSettingServerIP+0x358>
    d796:	84 e0       	ldi	r24, 0x04	; 4
    d798:	80 93 6d 01 	sts	0x016D, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    d79c:	80 91 15 03 	lds	r24, 0x0315
    d7a0:	87 3e       	cpi	r24, 0xE7	; 231
    d7a2:	09 f4       	brne	.+2      	; 0xd7a6 <FMenuSettingServerIP+0x362>
    d7a4:	c3 c0       	rjmp	.+390    	; 0xd92c <FMenuSettingServerIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    d7a6:	87 3b       	cpi	r24, 0xB7	; 183
    d7a8:	09 f0       	breq	.+2      	; 0xd7ac <FMenuSettingServerIP+0x368>
    d7aa:	c9 c0       	rjmp	.+402    	; 0xd93e <FMenuSettingServerIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    d7ac:	40 91 0d 03 	lds	r20, 0x030D
    d7b0:	50 91 0e 03 	lds	r21, 0x030E
    d7b4:	44 30       	cpi	r20, 0x04	; 4
    d7b6:	51 05       	cpc	r21, r1
    d7b8:	08 f0       	brcs	.+2      	; 0xd7bc <FMenuSettingServerIP+0x378>
    d7ba:	a6 c0       	rjmp	.+332    	; 0xd908 <FMenuSettingServerIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    d7bc:	80 91 16 03 	lds	r24, 0x0316
    d7c0:	81 30       	cpi	r24, 0x01	; 1
    d7c2:	41 f4       	brne	.+16     	; 0xd7d4 <FMenuSettingServerIP+0x390>
    d7c4:	fa 01       	movw	r30, r20
    d7c6:	ef 5e       	subi	r30, 0xEF	; 239
    d7c8:	fc 4f       	sbci	r31, 0xFC	; 252
    d7ca:	80 91 1c 03 	lds	r24, 0x031C
    d7ce:	80 53       	subi	r24, 0x30	; 48
    d7d0:	80 83       	st	Z, r24
    d7d2:	22 c0       	rjmp	.+68     	; 0xd818 <FMenuSettingServerIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    d7d4:	82 30       	cpi	r24, 0x02	; 2
    d7d6:	49 f4       	brne	.+18     	; 0xd7ea <FMenuSettingServerIP+0x3a6>
    d7d8:	fa 01       	movw	r30, r20
    d7da:	ef 5e       	subi	r30, 0xEF	; 239
    d7dc:	fc 4f       	sbci	r31, 0xFC	; 252
    d7de:	20 91 1d 03 	lds	r18, 0x031D
    d7e2:	20 51       	subi	r18, 0x10	; 16
    d7e4:	80 91 1c 03 	lds	r24, 0x031C
    d7e8:	11 c0       	rjmp	.+34     	; 0xd80c <FMenuSettingServerIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d7ea:	83 30       	cpi	r24, 0x03	; 3
    d7ec:	a9 f4       	brne	.+42     	; 0xd818 <FMenuSettingServerIP+0x3d4>
    d7ee:	fa 01       	movw	r30, r20
    d7f0:	ef 5e       	subi	r30, 0xEF	; 239
    d7f2:	fc 4f       	sbci	r31, 0xFC	; 252
    d7f4:	20 91 1e 03 	lds	r18, 0x031E
    d7f8:	20 5d       	subi	r18, 0xD0	; 208
    d7fa:	80 91 1c 03 	lds	r24, 0x031C
    d7fe:	34 e6       	ldi	r19, 0x64	; 100
    d800:	83 9f       	mul	r24, r19
    d802:	c0 01       	movw	r24, r0
    d804:	11 24       	eor	r1, r1
    d806:	28 0f       	add	r18, r24
    d808:	80 91 1d 03 	lds	r24, 0x031D
    d80c:	3a e0       	ldi	r19, 0x0A	; 10
    d80e:	83 9f       	mul	r24, r19
    d810:	c0 01       	movw	r24, r0
    d812:	11 24       	eor	r1, r1
    d814:	28 0f       	add	r18, r24
    d816:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d818:	80 e3       	ldi	r24, 0x30	; 48
    d81a:	80 93 1c 03 	sts	0x031C, r24
    d81e:	80 93 1d 03 	sts	0x031D, r24
    d822:	80 93 1e 03 	sts	0x031E, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    d826:	60 91 18 03 	lds	r22, 0x0318
    d82a:	63 50       	subi	r22, 0x03	; 3
    d82c:	44 0f       	add	r20, r20
    d82e:	55 1f       	adc	r21, r21
    d830:	44 0f       	add	r20, r20
    d832:	55 1f       	adc	r21, r21
    d834:	64 0f       	add	r22, r20
    d836:	80 91 17 03 	lds	r24, 0x0317
    d83a:	4e e6       	ldi	r20, 0x6E	; 110
    d83c:	51 e1       	ldi	r21, 0x11	; 17
    d83e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d842:	00 d0       	rcall	.+0      	; 0xd844 <FMenuSettingServerIP+0x400>
    d844:	00 d0       	rcall	.+0      	; 0xd846 <FMenuSettingServerIP+0x402>
    d846:	00 d0       	rcall	.+0      	; 0xd848 <FMenuSettingServerIP+0x404>
    d848:	ad b7       	in	r26, 0x3d	; 61
    d84a:	be b7       	in	r27, 0x3e	; 62
    d84c:	11 96       	adiw	r26, 0x01	; 1
    d84e:	8e 01       	movw	r16, r28
    d850:	0f 5f       	subi	r16, 0xFF	; 255
    d852:	1f 4f       	sbci	r17, 0xFF	; 255
    d854:	ed b7       	in	r30, 0x3d	; 61
    d856:	fe b7       	in	r31, 0x3e	; 62
    d858:	12 83       	std	Z+2, r17	; 0x02
    d85a:	01 83       	std	Z+1, r16	; 0x01
    d85c:	8b e6       	ldi	r24, 0x6B	; 107
    d85e:	91 e1       	ldi	r25, 0x11	; 17
    d860:	13 96       	adiw	r26, 0x03	; 3
    d862:	9c 93       	st	X, r25
    d864:	8e 93       	st	-X, r24
    d866:	12 97       	sbiw	r26, 0x02	; 2
    d868:	e0 91 0d 03 	lds	r30, 0x030D
    d86c:	f0 91 0e 03 	lds	r31, 0x030E
    d870:	ef 5e       	subi	r30, 0xEF	; 239
    d872:	fc 4f       	sbci	r31, 0xFC	; 252
    d874:	80 81       	ld	r24, Z
    d876:	14 96       	adiw	r26, 0x04	; 4
    d878:	8c 93       	st	X, r24
    d87a:	14 97       	sbiw	r26, 0x04	; 4
    d87c:	15 96       	adiw	r26, 0x05	; 5
    d87e:	1c 92       	st	X, r1
    d880:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d884:	f8 01       	movw	r30, r16
    d886:	01 90       	ld	r0, Z+
    d888:	00 20       	and	r0, r0
    d88a:	e9 f7       	brne	.-6      	; 0xd886 <FMenuSettingServerIP+0x442>
    d88c:	31 97       	sbiw	r30, 0x01	; 1
    d88e:	e0 1b       	sub	r30, r16
    d890:	f1 0b       	sbc	r31, r17
    d892:	8d b7       	in	r24, 0x3d	; 61
    d894:	9e b7       	in	r25, 0x3e	; 62
    d896:	06 96       	adiw	r24, 0x06	; 6
    d898:	0f b6       	in	r0, 0x3f	; 63
    d89a:	f8 94       	cli
    d89c:	9e bf       	out	0x3e, r25	; 62
    d89e:	0f be       	out	0x3f, r0	; 63
    d8a0:	8d bf       	out	0x3d, r24	; 61
    d8a2:	60 91 18 03 	lds	r22, 0x0318
    d8a6:	6f 5f       	subi	r22, 0xFF	; 255
    d8a8:	80 91 0d 03 	lds	r24, 0x030D
    d8ac:	90 91 0e 03 	lds	r25, 0x030E
    d8b0:	88 0f       	add	r24, r24
    d8b2:	99 1f       	adc	r25, r25
    d8b4:	88 0f       	add	r24, r24
    d8b6:	99 1f       	adc	r25, r25
    d8b8:	68 0f       	add	r22, r24
    d8ba:	6e 1b       	sub	r22, r30
    d8bc:	80 91 17 03 	lds	r24, 0x0317
    d8c0:	a8 01       	movw	r20, r16
    d8c2:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d8c6:	80 91 0d 03 	lds	r24, 0x030D
    d8ca:	90 91 0e 03 	lds	r25, 0x030E
    d8ce:	00 97       	sbiw	r24, 0x00	; 0
    d8d0:	81 f0       	breq	.+32     	; 0xd8f2 <FMenuSettingServerIP+0x4ae>
    d8d2:	60 91 18 03 	lds	r22, 0x0318
    d8d6:	6f 5f       	subi	r22, 0xFF	; 255
    d8d8:	81 50       	subi	r24, 0x01	; 1
    d8da:	90 4c       	sbci	r25, 0xC0	; 192
    d8dc:	88 0f       	add	r24, r24
    d8de:	99 1f       	adc	r25, r25
    d8e0:	88 0f       	add	r24, r24
    d8e2:	99 1f       	adc	r25, r25
    d8e4:	68 0f       	add	r22, r24
    d8e6:	80 91 17 03 	lds	r24, 0x0317
    d8ea:	49 e6       	ldi	r20, 0x69	; 105
    d8ec:	51 e1       	ldi	r21, 0x11	; 17
    d8ee:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				       iInput=0;
    d8f2:	10 92 16 03 	sts	0x0316, r1
					   iBlok++;	   
    d8f6:	80 91 0d 03 	lds	r24, 0x030D
    d8fa:	90 91 0e 03 	lds	r25, 0x030E
    d8fe:	01 96       	adiw	r24, 0x01	; 1
    d900:	90 93 0e 03 	sts	0x030E, r25
    d904:	80 93 0d 03 	sts	0x030D, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d908:	80 91 0d 03 	lds	r24, 0x030D
    d90c:	90 91 0e 03 	lds	r25, 0x030E
    d910:	04 97       	sbiw	r24, 0x04	; 4
    d912:	a8 f0       	brcs	.+42     	; 0xd93e <FMenuSettingServerIP+0x4fa>
    d914:	84 e0       	ldi	r24, 0x04	; 4
    d916:	0b c0       	rjmp	.+22     	; 0xd92e <FMenuSettingServerIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    d918:	8c e2       	ldi	r24, 0x2C	; 44
    d91a:	90 e0       	ldi	r25, 0x00	; 0
    d91c:	61 e1       	ldi	r22, 0x11	; 17
    d91e:	73 e0       	ldi	r23, 0x03	; 3
    d920:	44 e0       	ldi	r20, 0x04	; 4
    d922:	50 e0       	ldi	r21, 0x00	; 0
    d924:	2f e9       	ldi	r18, 0x9F	; 159
    d926:	32 e1       	ldi	r19, 0x12	; 18
    d928:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    d92c:	83 e0       	ldi	r24, 0x03	; 3
    d92e:	80 93 6d 01 	sts	0x016D, r24
    d932:	05 c0       	rjmp	.+10     	; 0xd93e <FMenuSettingServerIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    d934:	81 e0       	ldi	r24, 0x01	; 1
    d936:	80 93 6d 01 	sts	0x016D, r24
			   Result=MENU_DONE;
    d93a:	80 93 1a 03 	sts	0x031A, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    d93e:	80 91 1a 03 	lds	r24, 0x031A
    d942:	64 96       	adiw	r28, 0x14	; 20
    d944:	0f b6       	in	r0, 0x3f	; 63
    d946:	f8 94       	cli
    d948:	de bf       	out	0x3e, r29	; 62
    d94a:	0f be       	out	0x3f, r0	; 63
    d94c:	cd bf       	out	0x3d, r28	; 61
    d94e:	cf 91       	pop	r28
    d950:	df 91       	pop	r29
    d952:	1f 91       	pop	r17
    d954:	0f 91       	pop	r16
    d956:	08 95       	ret

0000d958 <FMenuSettingClientIP>:
	if(__result==0)
		eeprom_write_block((const void*) &__buf_string, (void*) &DefHeaderFooter[__select], _MAX_TEXT + 1);
}


char FMenuSettingClientIP(){
    d958:	0f 93       	push	r16
    d95a:	1f 93       	push	r17
    d95c:	df 93       	push	r29
    d95e:	cf 93       	push	r28
    d960:	cd b7       	in	r28, 0x3d	; 61
    d962:	de b7       	in	r29, 0x3e	; 62
    d964:	64 97       	sbiw	r28, 0x14	; 20
    d966:	0f b6       	in	r0, 0x3f	; 63
    d968:	f8 94       	cli
    d96a:	de bf       	out	0x3e, r29	; 62
    d96c:	0f be       	out	0x3f, r0	; 63
    d96e:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    d970:	10 92 2c 03 	sts	0x032C, r1
	 switch(stClientIP){
    d974:	80 91 6e 01 	lds	r24, 0x016E
    d978:	82 30       	cpi	r24, 0x02	; 2
    d97a:	09 f4       	brne	.+2      	; 0xd97e <FMenuSettingClientIP+0x26>
    d97c:	7b c0       	rjmp	.+246    	; 0xda74 <FMenuSettingClientIP+0x11c>
    d97e:	83 30       	cpi	r24, 0x03	; 3
    d980:	20 f4       	brcc	.+8      	; 0xd98a <FMenuSettingClientIP+0x32>
    d982:	81 30       	cpi	r24, 0x01	; 1
    d984:	09 f0       	breq	.+2      	; 0xd988 <FMenuSettingClientIP+0x30>
    d986:	65 c2       	rjmp	.+1226   	; 0xde52 <FMenuSettingClientIP+0x4fa>
    d988:	07 c0       	rjmp	.+14     	; 0xd998 <FMenuSettingClientIP+0x40>
    d98a:	83 30       	cpi	r24, 0x03	; 3
    d98c:	09 f4       	brne	.+2      	; 0xd990 <FMenuSettingClientIP+0x38>
    d98e:	5c c2       	rjmp	.+1208   	; 0xde48 <FMenuSettingClientIP+0x4f0>
    d990:	84 30       	cpi	r24, 0x04	; 4
    d992:	09 f0       	breq	.+2      	; 0xd996 <FMenuSettingClientIP+0x3e>
    d994:	5e c2       	rjmp	.+1212   	; 0xde52 <FMenuSettingClientIP+0x4fa>
    d996:	4a c2       	rjmp	.+1172   	; 0xde2c <FMenuSettingClientIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d998:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    d99c:	81 e0       	ldi	r24, 0x01	; 1
    d99e:	61 e0       	ldi	r22, 0x01	; 1
    d9a0:	4d e0       	ldi	r20, 0x0D	; 13
    d9a2:	52 e1       	ldi	r21, 0x12	; 18
    d9a4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d9a8:	83 e2       	ldi	r24, 0x23	; 35
    d9aa:	93 e0       	ldi	r25, 0x03	; 3
    d9ac:	68 e2       	ldi	r22, 0x28	; 40
    d9ae:	70 e0       	ldi	r23, 0x00	; 0
    d9b0:	44 e0       	ldi	r20, 0x04	; 4
    d9b2:	50 e0       	ldi	r21, 0x00	; 0
    d9b4:	27 e9       	ldi	r18, 0x97	; 151
    d9b6:	32 e1       	ldi	r19, 0x12	; 18
    d9b8:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d9bc:	8d b7       	in	r24, 0x3d	; 61
    d9be:	9e b7       	in	r25, 0x3e	; 62
    d9c0:	0c 97       	sbiw	r24, 0x0c	; 12
    d9c2:	0f b6       	in	r0, 0x3f	; 63
    d9c4:	f8 94       	cli
    d9c6:	9e bf       	out	0x3e, r25	; 62
    d9c8:	0f be       	out	0x3f, r0	; 63
    d9ca:	8d bf       	out	0x3d, r24	; 61
    d9cc:	ed b7       	in	r30, 0x3d	; 61
    d9ce:	fe b7       	in	r31, 0x3e	; 62
    d9d0:	31 96       	adiw	r30, 0x01	; 1
    d9d2:	8e 01       	movw	r16, r28
    d9d4:	0f 5f       	subi	r16, 0xFF	; 255
    d9d6:	1f 4f       	sbci	r17, 0xFF	; 255
    d9d8:	ad b7       	in	r26, 0x3d	; 61
    d9da:	be b7       	in	r27, 0x3e	; 62
    d9dc:	12 96       	adiw	r26, 0x02	; 2
    d9de:	1c 93       	st	X, r17
    d9e0:	0e 93       	st	-X, r16
    d9e2:	11 97       	sbiw	r26, 0x01	; 1
    d9e4:	8c ef       	ldi	r24, 0xFC	; 252
    d9e6:	91 e1       	ldi	r25, 0x11	; 17
    d9e8:	93 83       	std	Z+3, r25	; 0x03
    d9ea:	82 83       	std	Z+2, r24	; 0x02
    d9ec:	80 91 23 03 	lds	r24, 0x0323
    d9f0:	84 83       	std	Z+4, r24	; 0x04
    d9f2:	15 82       	std	Z+5, r1	; 0x05
    d9f4:	80 91 24 03 	lds	r24, 0x0324
    d9f8:	86 83       	std	Z+6, r24	; 0x06
    d9fa:	17 82       	std	Z+7, r1	; 0x07
    d9fc:	80 91 25 03 	lds	r24, 0x0325
    da00:	80 87       	std	Z+8, r24	; 0x08
    da02:	11 86       	std	Z+9, r1	; 0x09
    da04:	80 91 26 03 	lds	r24, 0x0326
    da08:	82 87       	std	Z+10, r24	; 0x0a
    da0a:	13 86       	std	Z+11, r1	; 0x0b
    da0c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    da10:	ed b7       	in	r30, 0x3d	; 61
    da12:	fe b7       	in	r31, 0x3e	; 62
    da14:	3c 96       	adiw	r30, 0x0c	; 12
    da16:	0f b6       	in	r0, 0x3f	; 63
    da18:	f8 94       	cli
    da1a:	fe bf       	out	0x3e, r31	; 62
    da1c:	0f be       	out	0x3f, r0	; 63
    da1e:	ed bf       	out	0x3d, r30	; 61
    da20:	82 e0       	ldi	r24, 0x02	; 2
    da22:	61 e0       	ldi	r22, 0x01	; 1
    da24:	a8 01       	movw	r20, r16
    da26:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    da2a:	83 e0       	ldi	r24, 0x03	; 3
    da2c:	61 e0       	ldi	r22, 0x01	; 1
    da2e:	47 ee       	ldi	r20, 0xE7	; 231
    da30:	51 e1       	ldi	r21, 0x11	; 17
    da32:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    da36:	84 e0       	ldi	r24, 0x04	; 4
    da38:	61 e0       	ldi	r22, 0x01	; 1
    da3a:	42 ed       	ldi	r20, 0xD2	; 210
    da3c:	51 e1       	ldi	r21, 0x11	; 17
    da3e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
               iLoop=0;
    da42:	10 92 22 03 	sts	0x0322, r1
    da46:	10 92 21 03 	sts	0x0321, r1
			   y=3,x=8;
    da4a:	83 e0       	ldi	r24, 0x03	; 3
    da4c:	80 93 29 03 	sts	0x0329, r24
    da50:	88 e0       	ldi	r24, 0x08	; 8
    da52:	80 93 2a 03 	sts	0x032A, r24
			   iInput=0; iBlok=0;
    da56:	10 92 28 03 	sts	0x0328, r1
    da5a:	10 92 20 03 	sts	0x0320, r1
    da5e:	10 92 1f 03 	sts	0x031F, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    da62:	80 e3       	ldi	r24, 0x30	; 48
    da64:	80 93 2e 03 	sts	0x032E, r24
    da68:	80 93 2f 03 	sts	0x032F, r24
    da6c:	80 93 30 03 	sts	0x0330, r24
			   stClientIP=cipInputIP; 
    da70:	82 e0       	ldi	r24, 0x02	; 2
    da72:	e7 c1       	rjmp	.+974    	; 0xde42 <FMenuSettingClientIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    da74:	80 91 21 03 	lds	r24, 0x0321
    da78:	90 91 22 03 	lds	r25, 0x0322
    da7c:	01 96       	adiw	r24, 0x01	; 1
    da7e:	90 93 22 03 	sts	0x0322, r25
    da82:	80 93 21 03 	sts	0x0321, r24
			   if ((iLoop%2000)==0){
    da86:	60 ed       	ldi	r22, 0xD0	; 208
    da88:	77 e0       	ldi	r23, 0x07	; 7
    da8a:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    da8e:	89 2b       	or	r24, r25
    da90:	81 f4       	brne	.+32     	; 0xdab2 <FMenuSettingClientIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    da92:	80 91 1f 03 	lds	r24, 0x031F
    da96:	90 91 20 03 	lds	r25, 0x0320
    da9a:	88 0f       	add	r24, r24
    da9c:	99 1f       	adc	r25, r25
    da9e:	88 0f       	add	r24, r24
    daa0:	99 1f       	adc	r25, r25
    daa2:	60 91 2a 03 	lds	r22, 0x032A
    daa6:	68 0f       	add	r22, r24
    daa8:	80 91 29 03 	lds	r24, 0x0329
    daac:	4f e5       	ldi	r20, 0x5F	; 95
    daae:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    dab2:	80 91 21 03 	lds	r24, 0x0321
    dab6:	90 91 22 03 	lds	r25, 0x0322
    daba:	60 ed       	ldi	r22, 0xD0	; 208
    dabc:	77 e0       	ldi	r23, 0x07	; 7
    dabe:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    dac2:	88 5e       	subi	r24, 0xE8	; 232
    dac4:	93 40       	sbci	r25, 0x03	; 3
    dac6:	81 f4       	brne	.+32     	; 0xdae8 <FMenuSettingClientIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    dac8:	80 91 1f 03 	lds	r24, 0x031F
    dacc:	90 91 20 03 	lds	r25, 0x0320
    dad0:	88 0f       	add	r24, r24
    dad2:	99 1f       	adc	r25, r25
    dad4:	88 0f       	add	r24, r24
    dad6:	99 1f       	adc	r25, r25
    dad8:	60 91 2a 03 	lds	r22, 0x032A
    dadc:	68 0f       	add	r22, r24
    dade:	80 91 29 03 	lds	r24, 0x0329
    dae2:	40 e2       	ldi	r20, 0x20	; 32
    dae4:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    dae8:	81 e0       	ldi	r24, 0x01	; 1
    daea:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    daee:	80 93 27 03 	sts	0x0327, r24
			   keyChar=_key_btn(keyPressed);
    daf2:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    daf6:	28 2f       	mov	r18, r24
    daf8:	80 93 2b 03 	sts	0x032B, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    dafc:	80 53       	subi	r24, 0x30	; 48
    dafe:	8a 30       	cpi	r24, 0x0A	; 10
    db00:	08 f0       	brcs	.+2      	; 0xdb04 <FMenuSettingClientIP+0x1ac>
    db02:	d6 c0       	rjmp	.+428    	; 0xdcb0 <FMenuSettingClientIP+0x358>
    db04:	80 e5       	ldi	r24, 0x50	; 80
    db06:	93 ec       	ldi	r25, 0xC3	; 195
    db08:	01 97       	sbiw	r24, 0x01	; 1
    db0a:	f1 f7       	brne	.-4      	; 0xdb08 <FMenuSettingClientIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    db0c:	80 91 28 03 	lds	r24, 0x0328
    db10:	e8 2f       	mov	r30, r24
    db12:	f0 e0       	ldi	r31, 0x00	; 0
    db14:	e2 5d       	subi	r30, 0xD2	; 210
    db16:	fc 4f       	sbci	r31, 0xFC	; 252
    db18:	20 83       	st	Z, r18
				   iInput++;                    
    db1a:	8f 5f       	subi	r24, 0xFF	; 255
    db1c:	80 93 28 03 	sts	0x0328, r24
				   for (i=1;i<(iInput+1);i++){
    db20:	81 e0       	ldi	r24, 0x01	; 1
    db22:	1c c0       	rjmp	.+56     	; 0xdb5c <FMenuSettingClientIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    db24:	80 91 2a 03 	lds	r24, 0x032A
    db28:	68 0f       	add	r22, r24
    db2a:	63 50       	subi	r22, 0x03	; 3
    db2c:	80 91 1f 03 	lds	r24, 0x031F
    db30:	90 91 20 03 	lds	r25, 0x0320
    db34:	88 0f       	add	r24, r24
    db36:	99 1f       	adc	r25, r25
    db38:	88 0f       	add	r24, r24
    db3a:	99 1f       	adc	r25, r25
    db3c:	68 0f       	add	r22, r24
    db3e:	80 91 29 03 	lds	r24, 0x0329
    db42:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
    db46:	e0 91 2d 03 	lds	r30, 0x032D
    db4a:	f0 e0       	ldi	r31, 0x00	; 0
    db4c:	e3 5d       	subi	r30, 0xD3	; 211
    db4e:	fc 4f       	sbci	r31, 0xFC	; 252
    db50:	80 81       	ld	r24, Z
    db52:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    db56:	80 91 2d 03 	lds	r24, 0x032D
    db5a:	8f 5f       	subi	r24, 0xFF	; 255
    db5c:	80 93 2d 03 	sts	0x032D, r24
    db60:	70 91 28 03 	lds	r23, 0x0328
    db64:	60 91 2d 03 	lds	r22, 0x032D
    db68:	27 2f       	mov	r18, r23
    db6a:	30 e0       	ldi	r19, 0x00	; 0
    db6c:	86 2f       	mov	r24, r22
    db6e:	90 e0       	ldi	r25, 0x00	; 0
    db70:	28 17       	cp	r18, r24
    db72:	39 07       	cpc	r19, r25
    db74:	bc f6       	brge	.-82     	; 0xdb24 <FMenuSettingClientIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    db76:	73 30       	cpi	r23, 0x03	; 3
    db78:	08 f4       	brcc	.+2      	; 0xdb7c <FMenuSettingClientIP+0x224>
    db7a:	91 c0       	rjmp	.+290    	; 0xdc9e <FMenuSettingClientIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    db7c:	40 91 1f 03 	lds	r20, 0x031F
    db80:	50 91 20 03 	lds	r21, 0x0320
    db84:	fa 01       	movw	r30, r20
    db86:	ed 5d       	subi	r30, 0xDD	; 221
    db88:	fc 4f       	sbci	r31, 0xFC	; 252
    db8a:	20 91 30 03 	lds	r18, 0x0330
    db8e:	20 5d       	subi	r18, 0xD0	; 208
    db90:	80 91 2e 03 	lds	r24, 0x032E
    db94:	34 e6       	ldi	r19, 0x64	; 100
    db96:	83 9f       	mul	r24, r19
    db98:	c0 01       	movw	r24, r0
    db9a:	11 24       	eor	r1, r1
    db9c:	28 0f       	add	r18, r24
    db9e:	80 91 2f 03 	lds	r24, 0x032F
    dba2:	3a e0       	ldi	r19, 0x0A	; 10
    dba4:	83 9f       	mul	r24, r19
    dba6:	c0 01       	movw	r24, r0
    dba8:	11 24       	eor	r1, r1
    dbaa:	28 0f       	add	r18, r24
    dbac:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dbae:	80 e3       	ldi	r24, 0x30	; 48
    dbb0:	80 93 2e 03 	sts	0x032E, r24
    dbb4:	80 93 2f 03 	sts	0x032F, r24
    dbb8:	80 93 30 03 	sts	0x0330, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    dbbc:	44 0f       	add	r20, r20
    dbbe:	55 1f       	adc	r21, r21
    dbc0:	44 0f       	add	r20, r20
    dbc2:	55 1f       	adc	r21, r21
    dbc4:	60 91 2a 03 	lds	r22, 0x032A
    dbc8:	64 0f       	add	r22, r20
    dbca:	67 1b       	sub	r22, r23
    dbcc:	80 91 29 03 	lds	r24, 0x0329
    dbd0:	4e ec       	ldi	r20, 0xCE	; 206
    dbd2:	51 e1       	ldi	r21, 0x11	; 17
    dbd4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dbd8:	00 d0       	rcall	.+0      	; 0xdbda <FMenuSettingClientIP+0x282>
    dbda:	00 d0       	rcall	.+0      	; 0xdbdc <FMenuSettingClientIP+0x284>
    dbdc:	00 d0       	rcall	.+0      	; 0xdbde <FMenuSettingClientIP+0x286>
    dbde:	ad b7       	in	r26, 0x3d	; 61
    dbe0:	be b7       	in	r27, 0x3e	; 62
    dbe2:	11 96       	adiw	r26, 0x01	; 1
    dbe4:	8e 01       	movw	r16, r28
    dbe6:	0f 5f       	subi	r16, 0xFF	; 255
    dbe8:	1f 4f       	sbci	r17, 0xFF	; 255
    dbea:	ed b7       	in	r30, 0x3d	; 61
    dbec:	fe b7       	in	r31, 0x3e	; 62
    dbee:	12 83       	std	Z+2, r17	; 0x02
    dbf0:	01 83       	std	Z+1, r16	; 0x01
    dbf2:	8b ec       	ldi	r24, 0xCB	; 203
    dbf4:	91 e1       	ldi	r25, 0x11	; 17
    dbf6:	13 96       	adiw	r26, 0x03	; 3
    dbf8:	9c 93       	st	X, r25
    dbfa:	8e 93       	st	-X, r24
    dbfc:	12 97       	sbiw	r26, 0x02	; 2
    dbfe:	e0 91 1f 03 	lds	r30, 0x031F
    dc02:	f0 91 20 03 	lds	r31, 0x0320
    dc06:	ed 5d       	subi	r30, 0xDD	; 221
    dc08:	fc 4f       	sbci	r31, 0xFC	; 252
    dc0a:	80 81       	ld	r24, Z
    dc0c:	14 96       	adiw	r26, 0x04	; 4
    dc0e:	8c 93       	st	X, r24
    dc10:	14 97       	sbiw	r26, 0x04	; 4
    dc12:	15 96       	adiw	r26, 0x05	; 5
    dc14:	1c 92       	st	X, r1
    dc16:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    dc1a:	f8 01       	movw	r30, r16
    dc1c:	01 90       	ld	r0, Z+
    dc1e:	00 20       	and	r0, r0
    dc20:	e9 f7       	brne	.-6      	; 0xdc1c <FMenuSettingClientIP+0x2c4>
    dc22:	31 97       	sbiw	r30, 0x01	; 1
    dc24:	e0 1b       	sub	r30, r16
    dc26:	f1 0b       	sbc	r31, r17
    dc28:	8d b7       	in	r24, 0x3d	; 61
    dc2a:	9e b7       	in	r25, 0x3e	; 62
    dc2c:	06 96       	adiw	r24, 0x06	; 6
    dc2e:	0f b6       	in	r0, 0x3f	; 63
    dc30:	f8 94       	cli
    dc32:	9e bf       	out	0x3e, r25	; 62
    dc34:	0f be       	out	0x3f, r0	; 63
    dc36:	8d bf       	out	0x3d, r24	; 61
    dc38:	60 91 2a 03 	lds	r22, 0x032A
    dc3c:	6f 5f       	subi	r22, 0xFF	; 255
    dc3e:	80 91 1f 03 	lds	r24, 0x031F
    dc42:	90 91 20 03 	lds	r25, 0x0320
    dc46:	88 0f       	add	r24, r24
    dc48:	99 1f       	adc	r25, r25
    dc4a:	88 0f       	add	r24, r24
    dc4c:	99 1f       	adc	r25, r25
    dc4e:	68 0f       	add	r22, r24
    dc50:	6e 1b       	sub	r22, r30
    dc52:	80 91 29 03 	lds	r24, 0x0329
    dc56:	a8 01       	movw	r20, r16
    dc58:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    dc5c:	80 91 1f 03 	lds	r24, 0x031F
    dc60:	90 91 20 03 	lds	r25, 0x0320
    dc64:	00 97       	sbiw	r24, 0x00	; 0
    dc66:	81 f0       	breq	.+32     	; 0xdc88 <FMenuSettingClientIP+0x330>
    dc68:	60 91 2a 03 	lds	r22, 0x032A
    dc6c:	6f 5f       	subi	r22, 0xFF	; 255
    dc6e:	81 50       	subi	r24, 0x01	; 1
    dc70:	90 4c       	sbci	r25, 0xC0	; 192
    dc72:	88 0f       	add	r24, r24
    dc74:	99 1f       	adc	r25, r25
    dc76:	88 0f       	add	r24, r24
    dc78:	99 1f       	adc	r25, r25
    dc7a:	68 0f       	add	r22, r24
    dc7c:	80 91 29 03 	lds	r24, 0x0329
    dc80:	49 ec       	ldi	r20, 0xC9	; 201
    dc82:	51 e1       	ldi	r21, 0x11	; 17
    dc84:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					   iInput=0;
    dc88:	10 92 28 03 	sts	0x0328, r1
					   iBlok++;
    dc8c:	80 91 1f 03 	lds	r24, 0x031F
    dc90:	90 91 20 03 	lds	r25, 0x0320
    dc94:	01 96       	adiw	r24, 0x01	; 1
    dc96:	90 93 20 03 	sts	0x0320, r25
    dc9a:	80 93 1f 03 	sts	0x031F, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    dc9e:	80 91 1f 03 	lds	r24, 0x031F
    dca2:	90 91 20 03 	lds	r25, 0x0320
    dca6:	04 97       	sbiw	r24, 0x04	; 4
    dca8:	18 f0       	brcs	.+6      	; 0xdcb0 <FMenuSettingClientIP+0x358>
    dcaa:	84 e0       	ldi	r24, 0x04	; 4
    dcac:	80 93 6e 01 	sts	0x016E, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    dcb0:	80 91 27 03 	lds	r24, 0x0327
    dcb4:	87 3e       	cpi	r24, 0xE7	; 231
    dcb6:	09 f4       	brne	.+2      	; 0xdcba <FMenuSettingClientIP+0x362>
    dcb8:	c3 c0       	rjmp	.+390    	; 0xde40 <FMenuSettingClientIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    dcba:	87 3b       	cpi	r24, 0xB7	; 183
    dcbc:	09 f0       	breq	.+2      	; 0xdcc0 <FMenuSettingClientIP+0x368>
    dcbe:	c9 c0       	rjmp	.+402    	; 0xde52 <FMenuSettingClientIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    dcc0:	40 91 1f 03 	lds	r20, 0x031F
    dcc4:	50 91 20 03 	lds	r21, 0x0320
    dcc8:	44 30       	cpi	r20, 0x04	; 4
    dcca:	51 05       	cpc	r21, r1
    dccc:	08 f0       	brcs	.+2      	; 0xdcd0 <FMenuSettingClientIP+0x378>
    dcce:	a6 c0       	rjmp	.+332    	; 0xde1c <FMenuSettingClientIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    dcd0:	80 91 28 03 	lds	r24, 0x0328
    dcd4:	81 30       	cpi	r24, 0x01	; 1
    dcd6:	41 f4       	brne	.+16     	; 0xdce8 <FMenuSettingClientIP+0x390>
    dcd8:	fa 01       	movw	r30, r20
    dcda:	ed 5d       	subi	r30, 0xDD	; 221
    dcdc:	fc 4f       	sbci	r31, 0xFC	; 252
    dcde:	80 91 2e 03 	lds	r24, 0x032E
    dce2:	80 53       	subi	r24, 0x30	; 48
    dce4:	80 83       	st	Z, r24
    dce6:	22 c0       	rjmp	.+68     	; 0xdd2c <FMenuSettingClientIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    dce8:	82 30       	cpi	r24, 0x02	; 2
    dcea:	49 f4       	brne	.+18     	; 0xdcfe <FMenuSettingClientIP+0x3a6>
    dcec:	fa 01       	movw	r30, r20
    dcee:	ed 5d       	subi	r30, 0xDD	; 221
    dcf0:	fc 4f       	sbci	r31, 0xFC	; 252
    dcf2:	20 91 2f 03 	lds	r18, 0x032F
    dcf6:	20 51       	subi	r18, 0x10	; 16
    dcf8:	80 91 2e 03 	lds	r24, 0x032E
    dcfc:	11 c0       	rjmp	.+34     	; 0xdd20 <FMenuSettingClientIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    dcfe:	83 30       	cpi	r24, 0x03	; 3
    dd00:	a9 f4       	brne	.+42     	; 0xdd2c <FMenuSettingClientIP+0x3d4>
    dd02:	fa 01       	movw	r30, r20
    dd04:	ed 5d       	subi	r30, 0xDD	; 221
    dd06:	fc 4f       	sbci	r31, 0xFC	; 252
    dd08:	20 91 30 03 	lds	r18, 0x0330
    dd0c:	20 5d       	subi	r18, 0xD0	; 208
    dd0e:	80 91 2e 03 	lds	r24, 0x032E
    dd12:	34 e6       	ldi	r19, 0x64	; 100
    dd14:	83 9f       	mul	r24, r19
    dd16:	c0 01       	movw	r24, r0
    dd18:	11 24       	eor	r1, r1
    dd1a:	28 0f       	add	r18, r24
    dd1c:	80 91 2f 03 	lds	r24, 0x032F
    dd20:	3a e0       	ldi	r19, 0x0A	; 10
    dd22:	83 9f       	mul	r24, r19
    dd24:	c0 01       	movw	r24, r0
    dd26:	11 24       	eor	r1, r1
    dd28:	28 0f       	add	r18, r24
    dd2a:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dd2c:	80 e3       	ldi	r24, 0x30	; 48
    dd2e:	80 93 2e 03 	sts	0x032E, r24
    dd32:	80 93 2f 03 	sts	0x032F, r24
    dd36:	80 93 30 03 	sts	0x0330, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    dd3a:	60 91 2a 03 	lds	r22, 0x032A
    dd3e:	63 50       	subi	r22, 0x03	; 3
    dd40:	44 0f       	add	r20, r20
    dd42:	55 1f       	adc	r21, r21
    dd44:	44 0f       	add	r20, r20
    dd46:	55 1f       	adc	r21, r21
    dd48:	64 0f       	add	r22, r20
    dd4a:	80 91 29 03 	lds	r24, 0x0329
    dd4e:	45 ec       	ldi	r20, 0xC5	; 197
    dd50:	51 e1       	ldi	r21, 0x11	; 17
    dd52:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dd56:	00 d0       	rcall	.+0      	; 0xdd58 <FMenuSettingClientIP+0x400>
    dd58:	00 d0       	rcall	.+0      	; 0xdd5a <FMenuSettingClientIP+0x402>
    dd5a:	00 d0       	rcall	.+0      	; 0xdd5c <FMenuSettingClientIP+0x404>
    dd5c:	ad b7       	in	r26, 0x3d	; 61
    dd5e:	be b7       	in	r27, 0x3e	; 62
    dd60:	11 96       	adiw	r26, 0x01	; 1
    dd62:	8e 01       	movw	r16, r28
    dd64:	0f 5f       	subi	r16, 0xFF	; 255
    dd66:	1f 4f       	sbci	r17, 0xFF	; 255
    dd68:	ed b7       	in	r30, 0x3d	; 61
    dd6a:	fe b7       	in	r31, 0x3e	; 62
    dd6c:	12 83       	std	Z+2, r17	; 0x02
    dd6e:	01 83       	std	Z+1, r16	; 0x01
    dd70:	82 ec       	ldi	r24, 0xC2	; 194
    dd72:	91 e1       	ldi	r25, 0x11	; 17
    dd74:	13 96       	adiw	r26, 0x03	; 3
    dd76:	9c 93       	st	X, r25
    dd78:	8e 93       	st	-X, r24
    dd7a:	12 97       	sbiw	r26, 0x02	; 2
    dd7c:	e0 91 1f 03 	lds	r30, 0x031F
    dd80:	f0 91 20 03 	lds	r31, 0x0320
    dd84:	ed 5d       	subi	r30, 0xDD	; 221
    dd86:	fc 4f       	sbci	r31, 0xFC	; 252
    dd88:	80 81       	ld	r24, Z
    dd8a:	14 96       	adiw	r26, 0x04	; 4
    dd8c:	8c 93       	st	X, r24
    dd8e:	14 97       	sbiw	r26, 0x04	; 4
    dd90:	15 96       	adiw	r26, 0x05	; 5
    dd92:	1c 92       	st	X, r1
    dd94:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    dd98:	f8 01       	movw	r30, r16
    dd9a:	01 90       	ld	r0, Z+
    dd9c:	00 20       	and	r0, r0
    dd9e:	e9 f7       	brne	.-6      	; 0xdd9a <FMenuSettingClientIP+0x442>
    dda0:	31 97       	sbiw	r30, 0x01	; 1
    dda2:	e0 1b       	sub	r30, r16
    dda4:	f1 0b       	sbc	r31, r17
    dda6:	8d b7       	in	r24, 0x3d	; 61
    dda8:	9e b7       	in	r25, 0x3e	; 62
    ddaa:	06 96       	adiw	r24, 0x06	; 6
    ddac:	0f b6       	in	r0, 0x3f	; 63
    ddae:	f8 94       	cli
    ddb0:	9e bf       	out	0x3e, r25	; 62
    ddb2:	0f be       	out	0x3f, r0	; 63
    ddb4:	8d bf       	out	0x3d, r24	; 61
    ddb6:	60 91 2a 03 	lds	r22, 0x032A
    ddba:	6f 5f       	subi	r22, 0xFF	; 255
    ddbc:	80 91 1f 03 	lds	r24, 0x031F
    ddc0:	90 91 20 03 	lds	r25, 0x0320
    ddc4:	88 0f       	add	r24, r24
    ddc6:	99 1f       	adc	r25, r25
    ddc8:	88 0f       	add	r24, r24
    ddca:	99 1f       	adc	r25, r25
    ddcc:	68 0f       	add	r22, r24
    ddce:	6e 1b       	sub	r22, r30
    ddd0:	80 91 29 03 	lds	r24, 0x0329
    ddd4:	a8 01       	movw	r20, r16
    ddd6:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    ddda:	80 91 1f 03 	lds	r24, 0x031F
    ddde:	90 91 20 03 	lds	r25, 0x0320
    dde2:	00 97       	sbiw	r24, 0x00	; 0
    dde4:	81 f0       	breq	.+32     	; 0xde06 <FMenuSettingClientIP+0x4ae>
    dde6:	60 91 2a 03 	lds	r22, 0x032A
    ddea:	6f 5f       	subi	r22, 0xFF	; 255
    ddec:	81 50       	subi	r24, 0x01	; 1
    ddee:	90 4c       	sbci	r25, 0xC0	; 192
    ddf0:	88 0f       	add	r24, r24
    ddf2:	99 1f       	adc	r25, r25
    ddf4:	88 0f       	add	r24, r24
    ddf6:	99 1f       	adc	r25, r25
    ddf8:	68 0f       	add	r22, r24
    ddfa:	80 91 29 03 	lds	r24, 0x0329
    ddfe:	40 ec       	ldi	r20, 0xC0	; 192
    de00:	51 e1       	ldi	r21, 0x11	; 17
    de02:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				       iInput=0;
    de06:	10 92 28 03 	sts	0x0328, r1
					   iBlok++;	   
    de0a:	80 91 1f 03 	lds	r24, 0x031F
    de0e:	90 91 20 03 	lds	r25, 0x0320
    de12:	01 96       	adiw	r24, 0x01	; 1
    de14:	90 93 20 03 	sts	0x0320, r25
    de18:	80 93 1f 03 	sts	0x031F, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    de1c:	80 91 1f 03 	lds	r24, 0x031F
    de20:	90 91 20 03 	lds	r25, 0x0320
    de24:	04 97       	sbiw	r24, 0x04	; 4
    de26:	a8 f0       	brcs	.+42     	; 0xde52 <FMenuSettingClientIP+0x4fa>
    de28:	84 e0       	ldi	r24, 0x04	; 4
    de2a:	0b c0       	rjmp	.+22     	; 0xde42 <FMenuSettingClientIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    de2c:	88 e2       	ldi	r24, 0x28	; 40
    de2e:	90 e0       	ldi	r25, 0x00	; 0
    de30:	63 e2       	ldi	r22, 0x23	; 35
    de32:	73 e0       	ldi	r23, 0x03	; 3
    de34:	44 e0       	ldi	r20, 0x04	; 4
    de36:	50 e0       	ldi	r21, 0x00	; 0
    de38:	2f e9       	ldi	r18, 0x9F	; 159
    de3a:	32 e1       	ldi	r19, 0x12	; 18
    de3c:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    de40:	83 e0       	ldi	r24, 0x03	; 3
    de42:	80 93 6e 01 	sts	0x016E, r24
    de46:	05 c0       	rjmp	.+10     	; 0xde52 <FMenuSettingClientIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    de48:	81 e0       	ldi	r24, 0x01	; 1
    de4a:	80 93 6e 01 	sts	0x016E, r24
		       Result=MENU_DONE;
    de4e:	80 93 2c 03 	sts	0x032C, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    de52:	80 91 2c 03 	lds	r24, 0x032C
    de56:	64 96       	adiw	r28, 0x14	; 20
    de58:	0f b6       	in	r0, 0x3f	; 63
    de5a:	f8 94       	cli
    de5c:	de bf       	out	0x3e, r29	; 62
    de5e:	0f be       	out	0x3f, r0	; 63
    de60:	cd bf       	out	0x3d, r28	; 61
    de62:	cf 91       	pop	r28
    de64:	df 91       	pop	r29
    de66:	1f 91       	pop	r17
    de68:	0f 91       	pop	r16
    de6a:	08 95       	ret

0000de6c <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    de6c:	df 93       	push	r29
    de6e:	cf 93       	push	r28
    de70:	cd b7       	in	r28, 0x3d	; 61
    de72:	de b7       	in	r29, 0x3e	; 62
    de74:	28 97       	sbiw	r28, 0x08	; 8
    de76:	0f b6       	in	r0, 0x3f	; 63
    de78:	f8 94       	cli
    de7a:	de bf       	out	0x3e, r29	; 62
    de7c:	0f be       	out	0x3f, r0	; 63
    de7e:	cd bf       	out	0x3d, r28	; 61
    de80:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    de82:	80 91 ac 01 	lds	r24, 0x01AC
    de86:	88 23       	and	r24, r24
    de88:	a1 f4       	brne	.+40     	; 0xdeb2 <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    de8a:	3d e2       	ldi	r19, 0x2D	; 45
    de8c:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    de8e:	80 e6       	ldi	r24, 0x60	; 96
    de90:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    de92:	2c e7       	ldi	r18, 0x7C	; 124
    de94:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    de96:	9f e2       	ldi	r25, 0x2F	; 47
    de98:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    de9a:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    de9c:	84 ea       	ldi	r24, 0xA4	; 164
    de9e:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    dea0:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    dea2:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dea4:	47 70       	andi	r20, 0x07	; 7
    dea6:	fe 01       	movw	r30, r28
    dea8:	e4 0f       	add	r30, r20
    deaa:	f1 1d       	adc	r31, r1
    deac:	85 2f       	mov	r24, r21
    deae:	41 81       	ldd	r20, Z+1	; 0x01
    deb0:	08 c0       	rjmp	.+16     	; 0xdec2 <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    deb2:	80 91 ac 01 	lds	r24, 0x01AC
    deb6:	81 30       	cpi	r24, 0x01	; 1
    deb8:	31 f4       	brne	.+12     	; 0xdec6 <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    deba:	10 92 ac 01 	sts	0x01AC, r1
	          lcd_put(x,y,'X');     
    debe:	85 2f       	mov	r24, r21
    dec0:	48 e5       	ldi	r20, 0x58	; 88
    dec2:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			  }

}
    dec6:	28 96       	adiw	r28, 0x08	; 8
    dec8:	0f b6       	in	r0, 0x3f	; 63
    deca:	f8 94       	cli
    decc:	de bf       	out	0x3e, r29	; 62
    dece:	0f be       	out	0x3f, r0	; 63
    ded0:	cd bf       	out	0x3d, r28	; 61
    ded2:	cf 91       	pop	r28
    ded4:	df 91       	pop	r29
    ded6:	08 95       	ret

0000ded8 <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    ded8:	0f 93       	push	r16
    deda:	1f 93       	push	r17
    dedc:	df 93       	push	r29
    dede:	cf 93       	push	r28
    dee0:	cd b7       	in	r28, 0x3d	; 61
    dee2:	de b7       	in	r29, 0x3e	; 62
    dee4:	6a 97       	sbiw	r28, 0x1a	; 26
    dee6:	0f b6       	in	r0, 0x3f	; 63
    dee8:	f8 94       	cli
    deea:	de bf       	out	0x3e, r29	; 62
    deec:	0f be       	out	0x3f, r0	; 63
    deee:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
char i,lcdteks[20];
char KeyChar,Addr,PPoolingSetting[6];
     Result=MENU_NONE;

     switch(stPumpPooling){
    def0:	80 91 fa 02 	lds	r24, 0x02FA
    def4:	82 30       	cpi	r24, 0x02	; 2
    def6:	09 f4       	brne	.+2      	; 0xdefa <FSettingPumpPooling+0x22>
    def8:	1b c1       	rjmp	.+566    	; 0xe130 <FSettingPumpPooling+0x258>
    defa:	83 30       	cpi	r24, 0x03	; 3
    defc:	30 f4       	brcc	.+12     	; 0xdf0a <FSettingPumpPooling+0x32>
    defe:	88 23       	and	r24, r24
    df00:	59 f0       	breq	.+22     	; 0xdf18 <FSettingPumpPooling+0x40>
    df02:	81 30       	cpi	r24, 0x01	; 1
    df04:	09 f0       	breq	.+2      	; 0xdf08 <FSettingPumpPooling+0x30>
    df06:	1b c2       	rjmp	.+1078   	; 0xe33e <FSettingPumpPooling+0x466>
    df08:	09 c1       	rjmp	.+530    	; 0xe11c <FSettingPumpPooling+0x244>
    df0a:	83 30       	cpi	r24, 0x03	; 3
    df0c:	09 f4       	brne	.+2      	; 0xdf10 <FSettingPumpPooling+0x38>
    df0e:	06 c2       	rjmp	.+1036   	; 0xe31c <FSettingPumpPooling+0x444>
    df10:	84 30       	cpi	r24, 0x04	; 4
    df12:	09 f0       	breq	.+2      	; 0xdf16 <FSettingPumpPooling+0x3e>
    df14:	14 c2       	rjmp	.+1064   	; 0xe33e <FSettingPumpPooling+0x466>
    df16:	0f c2       	rjmp	.+1054   	; 0xe336 <FSettingPumpPooling+0x45e>
	 case ppInitMenu:
          lcd_clear();
    df18:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    df1c:	20 e0       	ldi	r18, 0x00	; 0
    df1e:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    df20:	ae 01       	movw	r20, r28
    df22:	4f 5f       	subi	r20, 0xFF	; 255
    df24:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    df26:	e1 99       	sbic	0x1c, 1	; 28
    df28:	fe cf       	rjmp	.-4      	; 0xdf26 <FSettingPumpPooling+0x4e>
    df2a:	c9 01       	movw	r24, r18
    df2c:	8c 58       	subi	r24, 0x8C	; 140
    df2e:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    df30:	9f bb       	out	0x1f, r25	; 31
    df32:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    df34:	e0 9a       	sbi	0x1c, 0	; 28
    df36:	8d b3       	in	r24, 0x1d	; 29
    df38:	fa 01       	movw	r30, r20
    df3a:	e2 0f       	add	r30, r18
    df3c:	f3 1f       	adc	r31, r19
    df3e:	80 83       	st	Z, r24
    df40:	2f 5f       	subi	r18, 0xFF	; 255
    df42:	3f 4f       	sbci	r19, 0xFF	; 255
     Result=MENU_NONE;

     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    df44:	26 30       	cpi	r18, 0x06	; 6
    df46:	31 05       	cpc	r19, r1
    df48:	71 f7       	brne	.-36     	; 0xdf26 <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    df4a:	00 d0       	rcall	.+0      	; 0xdf4c <FSettingPumpPooling+0x74>
    df4c:	00 d0       	rcall	.+0      	; 0xdf4e <FSettingPumpPooling+0x76>
    df4e:	00 d0       	rcall	.+0      	; 0xdf50 <FSettingPumpPooling+0x78>
    df50:	ed b7       	in	r30, 0x3d	; 61
    df52:	fe b7       	in	r31, 0x3e	; 62
    df54:	31 96       	adiw	r30, 0x01	; 1
    df56:	8e 01       	movw	r16, r28
    df58:	09 5f       	subi	r16, 0xF9	; 249
    df5a:	1f 4f       	sbci	r17, 0xFF	; 255
    df5c:	ad b7       	in	r26, 0x3d	; 61
    df5e:	be b7       	in	r27, 0x3e	; 62
    df60:	12 96       	adiw	r26, 0x02	; 2
    df62:	1c 93       	st	X, r17
    df64:	0e 93       	st	-X, r16
    df66:	11 97       	sbiw	r26, 0x01	; 1
    df68:	89 ef       	ldi	r24, 0xF9	; 249
    df6a:	9e e0       	ldi	r25, 0x0E	; 14
    df6c:	93 83       	std	Z+3, r25	; 0x03
    df6e:	82 83       	std	Z+2, r24	; 0x02
    df70:	89 81       	ldd	r24, Y+1	; 0x01
    df72:	84 83       	std	Z+4, r24	; 0x04
    df74:	15 82       	std	Z+5, r1	; 0x05
    df76:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    df7a:	ed b7       	in	r30, 0x3d	; 61
    df7c:	fe b7       	in	r31, 0x3e	; 62
    df7e:	36 96       	adiw	r30, 0x06	; 6
    df80:	0f b6       	in	r0, 0x3f	; 63
    df82:	f8 94       	cli
    df84:	fe bf       	out	0x3e, r31	; 62
    df86:	0f be       	out	0x3f, r0	; 63
    df88:	ed bf       	out	0x3d, r30	; 61
    df8a:	81 e0       	ldi	r24, 0x01	; 1
    df8c:	61 e0       	ldi	r22, 0x01	; 1
    df8e:	a8 01       	movw	r20, r16
    df90:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    df94:	00 d0       	rcall	.+0      	; 0xdf96 <FSettingPumpPooling+0xbe>
    df96:	00 d0       	rcall	.+0      	; 0xdf98 <FSettingPumpPooling+0xc0>
    df98:	00 d0       	rcall	.+0      	; 0xdf9a <FSettingPumpPooling+0xc2>
    df9a:	ed b7       	in	r30, 0x3d	; 61
    df9c:	fe b7       	in	r31, 0x3e	; 62
    df9e:	31 96       	adiw	r30, 0x01	; 1
    dfa0:	ad b7       	in	r26, 0x3d	; 61
    dfa2:	be b7       	in	r27, 0x3e	; 62
    dfa4:	12 96       	adiw	r26, 0x02	; 2
    dfa6:	1c 93       	st	X, r17
    dfa8:	0e 93       	st	-X, r16
    dfaa:	11 97       	sbiw	r26, 0x01	; 1
    dfac:	8c ee       	ldi	r24, 0xEC	; 236
    dfae:	9e e0       	ldi	r25, 0x0E	; 14
    dfb0:	93 83       	std	Z+3, r25	; 0x03
    dfb2:	82 83       	std	Z+2, r24	; 0x02
    dfb4:	8a 81       	ldd	r24, Y+2	; 0x02
    dfb6:	84 83       	std	Z+4, r24	; 0x04
    dfb8:	15 82       	std	Z+5, r1	; 0x05
    dfba:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    dfbe:	ed b7       	in	r30, 0x3d	; 61
    dfc0:	fe b7       	in	r31, 0x3e	; 62
    dfc2:	36 96       	adiw	r30, 0x06	; 6
    dfc4:	0f b6       	in	r0, 0x3f	; 63
    dfc6:	f8 94       	cli
    dfc8:	fe bf       	out	0x3e, r31	; 62
    dfca:	0f be       	out	0x3f, r0	; 63
    dfcc:	ed bf       	out	0x3d, r30	; 61
    dfce:	82 e0       	ldi	r24, 0x02	; 2
    dfd0:	61 e0       	ldi	r22, 0x01	; 1
    dfd2:	a8 01       	movw	r20, r16
    dfd4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    dfd8:	00 d0       	rcall	.+0      	; 0xdfda <FSettingPumpPooling+0x102>
    dfda:	00 d0       	rcall	.+0      	; 0xdfdc <FSettingPumpPooling+0x104>
    dfdc:	00 d0       	rcall	.+0      	; 0xdfde <FSettingPumpPooling+0x106>
    dfde:	ed b7       	in	r30, 0x3d	; 61
    dfe0:	fe b7       	in	r31, 0x3e	; 62
    dfe2:	31 96       	adiw	r30, 0x01	; 1
    dfe4:	ad b7       	in	r26, 0x3d	; 61
    dfe6:	be b7       	in	r27, 0x3e	; 62
    dfe8:	12 96       	adiw	r26, 0x02	; 2
    dfea:	1c 93       	st	X, r17
    dfec:	0e 93       	st	-X, r16
    dfee:	11 97       	sbiw	r26, 0x01	; 1
    dff0:	8f ed       	ldi	r24, 0xDF	; 223
    dff2:	9e e0       	ldi	r25, 0x0E	; 14
    dff4:	93 83       	std	Z+3, r25	; 0x03
    dff6:	82 83       	std	Z+2, r24	; 0x02
    dff8:	8b 81       	ldd	r24, Y+3	; 0x03
    dffa:	84 83       	std	Z+4, r24	; 0x04
    dffc:	15 82       	std	Z+5, r1	; 0x05
    dffe:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    e002:	ed b7       	in	r30, 0x3d	; 61
    e004:	fe b7       	in	r31, 0x3e	; 62
    e006:	36 96       	adiw	r30, 0x06	; 6
    e008:	0f b6       	in	r0, 0x3f	; 63
    e00a:	f8 94       	cli
    e00c:	fe bf       	out	0x3e, r31	; 62
    e00e:	0f be       	out	0x3f, r0	; 63
    e010:	ed bf       	out	0x3d, r30	; 61
    e012:	83 e0       	ldi	r24, 0x03	; 3
    e014:	61 e0       	ldi	r22, 0x01	; 1
    e016:	a8 01       	movw	r20, r16
    e018:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    e01c:	00 d0       	rcall	.+0      	; 0xe01e <FSettingPumpPooling+0x146>
    e01e:	00 d0       	rcall	.+0      	; 0xe020 <FSettingPumpPooling+0x148>
    e020:	00 d0       	rcall	.+0      	; 0xe022 <FSettingPumpPooling+0x14a>
    e022:	ed b7       	in	r30, 0x3d	; 61
    e024:	fe b7       	in	r31, 0x3e	; 62
    e026:	31 96       	adiw	r30, 0x01	; 1
    e028:	ad b7       	in	r26, 0x3d	; 61
    e02a:	be b7       	in	r27, 0x3e	; 62
    e02c:	12 96       	adiw	r26, 0x02	; 2
    e02e:	1c 93       	st	X, r17
    e030:	0e 93       	st	-X, r16
    e032:	11 97       	sbiw	r26, 0x01	; 1
    e034:	82 ed       	ldi	r24, 0xD2	; 210
    e036:	9e e0       	ldi	r25, 0x0E	; 14
    e038:	93 83       	std	Z+3, r25	; 0x03
    e03a:	82 83       	std	Z+2, r24	; 0x02
    e03c:	8c 81       	ldd	r24, Y+4	; 0x04
    e03e:	84 83       	std	Z+4, r24	; 0x04
    e040:	15 82       	std	Z+5, r1	; 0x05
    e042:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    e046:	ed b7       	in	r30, 0x3d	; 61
    e048:	fe b7       	in	r31, 0x3e	; 62
    e04a:	36 96       	adiw	r30, 0x06	; 6
    e04c:	0f b6       	in	r0, 0x3f	; 63
    e04e:	f8 94       	cli
    e050:	fe bf       	out	0x3e, r31	; 62
    e052:	0f be       	out	0x3f, r0	; 63
    e054:	ed bf       	out	0x3d, r30	; 61
    e056:	84 e0       	ldi	r24, 0x04	; 4
    e058:	61 e0       	ldi	r22, 0x01	; 1
    e05a:	a8 01       	movw	r20, r16
    e05c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    e060:	00 d0       	rcall	.+0      	; 0xe062 <FSettingPumpPooling+0x18a>
    e062:	00 d0       	rcall	.+0      	; 0xe064 <FSettingPumpPooling+0x18c>
    e064:	00 d0       	rcall	.+0      	; 0xe066 <FSettingPumpPooling+0x18e>
    e066:	ed b7       	in	r30, 0x3d	; 61
    e068:	fe b7       	in	r31, 0x3e	; 62
    e06a:	31 96       	adiw	r30, 0x01	; 1
    e06c:	ad b7       	in	r26, 0x3d	; 61
    e06e:	be b7       	in	r27, 0x3e	; 62
    e070:	12 96       	adiw	r26, 0x02	; 2
    e072:	1c 93       	st	X, r17
    e074:	0e 93       	st	-X, r16
    e076:	11 97       	sbiw	r26, 0x01	; 1
    e078:	89 ec       	ldi	r24, 0xC9	; 201
    e07a:	9e e0       	ldi	r25, 0x0E	; 14
    e07c:	93 83       	std	Z+3, r25	; 0x03
    e07e:	82 83       	std	Z+2, r24	; 0x02
    e080:	8d 81       	ldd	r24, Y+5	; 0x05
    e082:	84 83       	std	Z+4, r24	; 0x04
    e084:	15 82       	std	Z+5, r1	; 0x05
    e086:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    e08a:	ed b7       	in	r30, 0x3d	; 61
    e08c:	fe b7       	in	r31, 0x3e	; 62
    e08e:	36 96       	adiw	r30, 0x06	; 6
    e090:	0f b6       	in	r0, 0x3f	; 63
    e092:	f8 94       	cli
    e094:	fe bf       	out	0x3e, r31	; 62
    e096:	0f be       	out	0x3f, r0	; 63
    e098:	ed bf       	out	0x3d, r30	; 61
    e09a:	81 e0       	ldi	r24, 0x01	; 1
    e09c:	6d e0       	ldi	r22, 0x0D	; 13
    e09e:	a8 01       	movw	r20, r16
    e0a0:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    e0a4:	00 d0       	rcall	.+0      	; 0xe0a6 <FSettingPumpPooling+0x1ce>
    e0a6:	00 d0       	rcall	.+0      	; 0xe0a8 <FSettingPumpPooling+0x1d0>
    e0a8:	00 d0       	rcall	.+0      	; 0xe0aa <FSettingPumpPooling+0x1d2>
    e0aa:	ed b7       	in	r30, 0x3d	; 61
    e0ac:	fe b7       	in	r31, 0x3e	; 62
    e0ae:	31 96       	adiw	r30, 0x01	; 1
    e0b0:	ad b7       	in	r26, 0x3d	; 61
    e0b2:	be b7       	in	r27, 0x3e	; 62
    e0b4:	12 96       	adiw	r26, 0x02	; 2
    e0b6:	1c 93       	st	X, r17
    e0b8:	0e 93       	st	-X, r16
    e0ba:	11 97       	sbiw	r26, 0x01	; 1
    e0bc:	80 ec       	ldi	r24, 0xC0	; 192
    e0be:	9e e0       	ldi	r25, 0x0E	; 14
    e0c0:	93 83       	std	Z+3, r25	; 0x03
    e0c2:	82 83       	std	Z+2, r24	; 0x02
    e0c4:	8e 81       	ldd	r24, Y+6	; 0x06
    e0c6:	84 83       	std	Z+4, r24	; 0x04
    e0c8:	15 82       	std	Z+5, r1	; 0x05
    e0ca:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    e0ce:	ed b7       	in	r30, 0x3d	; 61
    e0d0:	fe b7       	in	r31, 0x3e	; 62
    e0d2:	36 96       	adiw	r30, 0x06	; 6
    e0d4:	0f b6       	in	r0, 0x3f	; 63
    e0d6:	f8 94       	cli
    e0d8:	fe bf       	out	0x3e, r31	; 62
    e0da:	0f be       	out	0x3f, r0	; 63
    e0dc:	ed bf       	out	0x3d, r30	; 61
    e0de:	82 e0       	ldi	r24, 0x02	; 2
    e0e0:	6d e0       	ldi	r22, 0x0D	; 13
    e0e2:	a8 01       	movw	r20, r16
    e0e4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    e0e8:	00 d0       	rcall	.+0      	; 0xe0ea <FSettingPumpPooling+0x212>
    e0ea:	00 d0       	rcall	.+0      	; 0xe0ec <FSettingPumpPooling+0x214>
    e0ec:	ad b7       	in	r26, 0x3d	; 61
    e0ee:	be b7       	in	r27, 0x3e	; 62
    e0f0:	12 96       	adiw	r26, 0x02	; 2
    e0f2:	1c 93       	st	X, r17
    e0f4:	0e 93       	st	-X, r16
    e0f6:	11 97       	sbiw	r26, 0x01	; 1
    e0f8:	88 eb       	ldi	r24, 0xB8	; 184
    e0fa:	9e e0       	ldi	r25, 0x0E	; 14
    e0fc:	14 96       	adiw	r26, 0x04	; 4
    e0fe:	9c 93       	st	X, r25
    e100:	8e 93       	st	-X, r24
    e102:	13 97       	sbiw	r26, 0x03	; 3
    e104:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    e108:	0f 90       	pop	r0
    e10a:	0f 90       	pop	r0
    e10c:	0f 90       	pop	r0
    e10e:	0f 90       	pop	r0
    e110:	84 e0       	ldi	r24, 0x04	; 4
    e112:	6d e0       	ldi	r22, 0x0D	; 13
    e114:	a8 01       	movw	r20, r16
    e116:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    e11a:	08 c0       	rjmp	.+16     	; 0xe12c <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    e11c:	10 92 aa 01 	sts	0x01AA, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    e120:	83 e0       	ldi	r24, 0x03	; 3
    e122:	6e e0       	ldi	r22, 0x0E	; 14
    e124:	40 91 a9 01 	lds	r20, 0x01A9
    e128:	0e 94 36 6f 	call	0xde6c	; 0xde6c <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    e12c:	82 e0       	ldi	r24, 0x02	; 2
    e12e:	f3 c0       	rjmp	.+486    	; 0xe316 <FSettingPumpPooling+0x43e>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    e130:	80 91 aa 01 	lds	r24, 0x01AA
    e134:	81 30       	cpi	r24, 0x01	; 1
    e136:	11 f4       	brne	.+4      	; 0xe13c <FSettingPumpPooling+0x264>
    e138:	80 93 fa 02 	sts	0x02FA, r24

          KeyChar=_key_btn(_key_scan(1));
    e13c:	81 e0       	ldi	r24, 0x01	; 1
    e13e:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    e142:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    e146:	48 2f       	mov	r20, r24
    e148:	41 53       	subi	r20, 0x31	; 49
    e14a:	46 30       	cpi	r20, 0x06	; 6
    e14c:	10 f0       	brcs	.+4      	; 0xe152 <FSettingPumpPooling+0x27a>
    e14e:	40 e0       	ldi	r20, 0x00	; 0
    e150:	06 c0       	rjmp	.+12     	; 0xe15e <FSettingPumpPooling+0x286>
		      Addr=KeyChar-'1';
			  TimSend=0;
    e152:	10 92 be 01 	sts	0x01BE, r1
    e156:	10 92 bd 01 	sts	0x01BD, r1
			  IsStandaloneAcknoledge=False;
    e15a:	10 92 ab 01 	sts	0x01AB, r1
          }
		  switch(KeyChar){
    e15e:	83 33       	cpi	r24, 0x33	; 51
    e160:	09 f4       	brne	.+2      	; 0xe164 <FSettingPumpPooling+0x28c>
    e162:	67 c0       	rjmp	.+206    	; 0xe232 <FSettingPumpPooling+0x35a>
    e164:	84 33       	cpi	r24, 0x34	; 52
    e166:	48 f4       	brcc	.+18     	; 0xe17a <FSettingPumpPooling+0x2a2>
    e168:	81 33       	cpi	r24, 0x31	; 49
    e16a:	89 f0       	breq	.+34     	; 0xe18e <FSettingPumpPooling+0x2b6>
    e16c:	82 33       	cpi	r24, 0x32	; 50
    e16e:	08 f0       	brcs	.+2      	; 0xe172 <FSettingPumpPooling+0x29a>
    e170:	3d c0       	rjmp	.+122    	; 0xe1ec <FSettingPumpPooling+0x314>
    e172:	8a 32       	cpi	r24, 0x2A	; 42
    e174:	09 f0       	breq	.+2      	; 0xe178 <FSettingPumpPooling+0x2a0>
    e176:	e3 c0       	rjmp	.+454    	; 0xe33e <FSettingPumpPooling+0x466>
    e178:	cd c0       	rjmp	.+410    	; 0xe314 <FSettingPumpPooling+0x43c>
    e17a:	85 33       	cpi	r24, 0x35	; 53
    e17c:	09 f4       	brne	.+2      	; 0xe180 <FSettingPumpPooling+0x2a8>
    e17e:	91 c0       	rjmp	.+290    	; 0xe2a2 <FSettingPumpPooling+0x3ca>
    e180:	85 33       	cpi	r24, 0x35	; 53
    e182:	08 f4       	brcc	.+2      	; 0xe186 <FSettingPumpPooling+0x2ae>
    e184:	78 c0       	rjmp	.+240    	; 0xe276 <FSettingPumpPooling+0x39e>
    e186:	86 33       	cpi	r24, 0x36	; 54
    e188:	09 f0       	breq	.+2      	; 0xe18c <FSettingPumpPooling+0x2b4>
    e18a:	d9 c0       	rjmp	.+434    	; 0xe33e <FSettingPumpPooling+0x466>
    e18c:	a0 c0       	rjmp	.+320    	; 0xe2ce <FSettingPumpPooling+0x3f6>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    e18e:	24 2f       	mov	r18, r20
    e190:	30 e0       	ldi	r19, 0x00	; 0
    e192:	fe 01       	movw	r30, r28
    e194:	31 96       	adiw	r30, 0x01	; 1
    e196:	e2 0f       	add	r30, r18
    e198:	f3 1f       	adc	r31, r19
    e19a:	80 81       	ld	r24, Z
    e19c:	90 e0       	ldi	r25, 0x00	; 0
    e19e:	01 96       	adiw	r24, 0x01	; 1
    e1a0:	61 e1       	ldi	r22, 0x11	; 17
    e1a2:	70 e0       	ldi	r23, 0x00	; 0
    e1a4:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    e1a8:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e1aa:	88 23       	and	r24, r24
    e1ac:	11 f4       	brne	.+4      	; 0xe1b2 <FSettingPumpPooling+0x2da>
    e1ae:	81 e0       	ldi	r24, 0x01	; 1
    e1b0:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    e1b2:	2c 0f       	add	r18, r28
    e1b4:	3d 1f       	adc	r19, r29
    e1b6:	f9 01       	movw	r30, r18
    e1b8:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e1ba:	85 e1       	ldi	r24, 0x15	; 21
    e1bc:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
    e1c0:	20 93 d9 0d 	sts	0x0DD9, r18
     IsControlPooling=True;
    e1c4:	81 e0       	ldi	r24, 0x01	; 1
    e1c6:	80 93 ad 01 	sts	0x01AD, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e1ca:	e1 99       	sbic	0x1c, 1	; 28
    e1cc:	fe cf       	rjmp	.-4      	; 0xe1ca <FSettingPumpPooling+0x2f2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e1ce:	84 2f       	mov	r24, r20
    e1d0:	90 e0       	ldi	r25, 0x00	; 0
    e1d2:	8c 58       	subi	r24, 0x8C	; 140
    e1d4:	9e 4f       	sbci	r25, 0xFE	; 254
    e1d6:	9f bb       	out	0x1f, r25	; 31
    e1d8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e1da:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e1dc:	0f b6       	in	r0, 0x3f	; 63
    e1de:	f8 94       	cli
    e1e0:	e2 9a       	sbi	0x1c, 2	; 28
    e1e2:	e1 9a       	sbi	0x1c, 1	; 28
    e1e4:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    e1e6:	20 93 75 01 	sts	0x0175, r18
    e1ea:	21 c0       	rjmp	.+66     	; 0xe22e <FSettingPumpPooling+0x356>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e1ec:	fe 01       	movw	r30, r28
    e1ee:	e4 0f       	add	r30, r20
    e1f0:	f1 1d       	adc	r31, r1
    e1f2:	81 81       	ldd	r24, Z+1	; 0x01
    e1f4:	90 e0       	ldi	r25, 0x00	; 0
    e1f6:	01 96       	adiw	r24, 0x01	; 1
    e1f8:	65 e1       	ldi	r22, 0x15	; 21
    e1fa:	70 e0       	ldi	r23, 0x00	; 0
    e1fc:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    e200:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e202:	84 e1       	ldi	r24, 0x14	; 20
    e204:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
    e208:	20 93 d9 0d 	sts	0x0DD9, r18
     IsControlPooling=True;
    e20c:	81 e0       	ldi	r24, 0x01	; 1
    e20e:	80 93 ad 01 	sts	0x01AD, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e212:	e1 99       	sbic	0x1c, 1	; 28
    e214:	fe cf       	rjmp	.-4      	; 0xe212 <FSettingPumpPooling+0x33a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e216:	84 2f       	mov	r24, r20
    e218:	90 e0       	ldi	r25, 0x00	; 0
    e21a:	8c 58       	subi	r24, 0x8C	; 140
    e21c:	9e 4f       	sbci	r25, 0xFE	; 254
    e21e:	9f bb       	out	0x1f, r25	; 31
    e220:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e222:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e224:	0f b6       	in	r0, 0x3f	; 63
    e226:	f8 94       	cli
    e228:	e2 9a       	sbi	0x1c, 2	; 28
    e22a:	e1 9a       	sbi	0x1c, 1	; 28
    e22c:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    e22e:	83 e0       	ldi	r24, 0x03	; 3
    e230:	72 c0       	rjmp	.+228    	; 0xe316 <FSettingPumpPooling+0x43e>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e232:	24 2f       	mov	r18, r20
    e234:	30 e0       	ldi	r19, 0x00	; 0
    e236:	fe 01       	movw	r30, r28
    e238:	31 96       	adiw	r30, 0x01	; 1
    e23a:	e2 0f       	add	r30, r18
    e23c:	f3 1f       	adc	r31, r19
    e23e:	80 81       	ld	r24, Z
    e240:	90 e0       	ldi	r25, 0x00	; 0
    e242:	01 96       	adiw	r24, 0x01	; 1
    e244:	65 e1       	ldi	r22, 0x15	; 21
    e246:	70 e0       	ldi	r23, 0x00	; 0
    e248:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    e24c:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e24e:	88 23       	and	r24, r24
    e250:	11 f4       	brne	.+4      	; 0xe256 <FSettingPumpPooling+0x37e>
    e252:	81 e0       	ldi	r24, 0x01	; 1
    e254:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    e256:	2c 0f       	add	r18, r28
    e258:	3d 1f       	adc	r19, r29
    e25a:	d9 01       	movw	r26, r18
    e25c:	11 96       	adiw	r26, 0x01	; 1
    e25e:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e260:	86 e1       	ldi	r24, 0x16	; 22
    e262:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
    e266:	20 93 d9 0d 	sts	0x0DD9, r18
     IsControlPooling=True;
    e26a:	81 e0       	ldi	r24, 0x01	; 1
    e26c:	80 93 ad 01 	sts	0x01AD, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e270:	e1 99       	sbic	0x1c, 1	; 28
    e272:	fe cf       	rjmp	.-4      	; 0xe270 <FSettingPumpPooling+0x398>
    e274:	d0 cf       	rjmp	.-96     	; 0xe216 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e276:	fe 01       	movw	r30, r28
    e278:	e4 0f       	add	r30, r20
    e27a:	f1 1d       	adc	r31, r1
    e27c:	81 81       	ldd	r24, Z+1	; 0x01
    e27e:	90 e0       	ldi	r25, 0x00	; 0
    e280:	01 96       	adiw	r24, 0x01	; 1
    e282:	65 e1       	ldi	r22, 0x15	; 21
    e284:	70 e0       	ldi	r23, 0x00	; 0
    e286:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    e28a:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e28c:	87 e1       	ldi	r24, 0x17	; 23
    e28e:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
    e292:	20 93 d9 0d 	sts	0x0DD9, r18
     IsControlPooling=True;
    e296:	81 e0       	ldi	r24, 0x01	; 1
    e298:	80 93 ad 01 	sts	0x01AD, r24
    e29c:	e1 99       	sbic	0x1c, 1	; 28
    e29e:	fe cf       	rjmp	.-4      	; 0xe29c <FSettingPumpPooling+0x3c4>
    e2a0:	ba cf       	rjmp	.-140    	; 0xe216 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    e2a2:	fe 01       	movw	r30, r28
    e2a4:	e4 0f       	add	r30, r20
    e2a6:	f1 1d       	adc	r31, r1
    e2a8:	81 81       	ldd	r24, Z+1	; 0x01
    e2aa:	90 e0       	ldi	r25, 0x00	; 0
    e2ac:	01 96       	adiw	r24, 0x01	; 1
    e2ae:	69 e2       	ldi	r22, 0x29	; 41
    e2b0:	70 e0       	ldi	r23, 0x00	; 0
    e2b2:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    e2b6:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e2b8:	88 e1       	ldi	r24, 0x18	; 24
    e2ba:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
    e2be:	20 93 d9 0d 	sts	0x0DD9, r18
     IsControlPooling=True;
    e2c2:	81 e0       	ldi	r24, 0x01	; 1
    e2c4:	80 93 ad 01 	sts	0x01AD, r24
    e2c8:	e1 99       	sbic	0x1c, 1	; 28
    e2ca:	fe cf       	rjmp	.-4      	; 0xe2c8 <FSettingPumpPooling+0x3f0>
    e2cc:	a4 cf       	rjmp	.-184    	; 0xe216 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    e2ce:	fe 01       	movw	r30, r28
    e2d0:	e4 0f       	add	r30, r20
    e2d2:	f1 1d       	adc	r31, r1
    e2d4:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e2d6:	e1 99       	sbic	0x1c, 1	; 28
    e2d8:	fe cf       	rjmp	.-4      	; 0xe2d6 <FSettingPumpPooling+0x3fe>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e2da:	84 e7       	ldi	r24, 0x74	; 116
    e2dc:	91 e0       	ldi	r25, 0x01	; 1
    e2de:	9f bb       	out	0x1f, r25	; 31
    e2e0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e2e2:	e0 9a       	sbi	0x1c, 0	; 28
    e2e4:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e2e6:	e1 99       	sbic	0x1c, 1	; 28
    e2e8:	fe cf       	rjmp	.-4      	; 0xe2e6 <FSettingPumpPooling+0x40e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e2ea:	84 2f       	mov	r24, r20
    e2ec:	90 e0       	ldi	r25, 0x00	; 0
    e2ee:	8c 58       	subi	r24, 0x8C	; 140
    e2f0:	9e 4f       	sbci	r25, 0xFE	; 254
    e2f2:	9f bb       	out	0x1f, r25	; 31
    e2f4:	8e bb       	out	0x1e, r24	; 30
    e2f6:	82 2f       	mov	r24, r18
    e2f8:	90 e0       	ldi	r25, 0x00	; 0
    e2fa:	70 e0       	ldi	r23, 0x00	; 0
    e2fc:	6f 5f       	subi	r22, 0xFF	; 255
    e2fe:	7f 4f       	sbci	r23, 0xFF	; 255
    e300:	01 96       	adiw	r24, 0x01	; 1
    e302:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
#endif
    EEDR = __value;
    e306:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    e308:	0f b6       	in	r0, 0x3f	; 63
    e30a:	f8 94       	cli
    e30c:	e2 9a       	sbi	0x1c, 2	; 28
    e30e:	e1 9a       	sbi	0x1c, 1	; 28
    e310:	0f be       	out	0x3f, r0	; 63
    e312:	0e c0       	rjmp	.+28     	; 0xe330 <FSettingPumpPooling+0x458>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    e314:	84 e0       	ldi	r24, 0x04	; 4
    e316:	80 93 fa 02 	sts	0x02FA, r24
    e31a:	11 c0       	rjmp	.+34     	; 0xe33e <FSettingPumpPooling+0x466>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    e31c:	80 91 ab 01 	lds	r24, 0x01AB
    e320:	81 30       	cpi	r24, 0x01	; 1
    e322:	31 f0       	breq	.+12     	; 0xe330 <FSettingPumpPooling+0x458>
    e324:	80 91 bd 01 	lds	r24, 0x01BD
    e328:	90 91 be 01 	lds	r25, 0x01BE
    e32c:	06 97       	sbiw	r24, 0x06	; 6
    e32e:	38 f0       	brcs	.+14     	; 0xe33e <FSettingPumpPooling+0x466>
    e330:	10 92 fa 02 	sts	0x02FA, r1
    e334:	04 c0       	rjmp	.+8      	; 0xe33e <FSettingPumpPooling+0x466>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    e336:	10 92 fa 02 	sts	0x02FA, r1
    e33a:	81 e0       	ldi	r24, 0x01	; 1
    e33c:	01 c0       	rjmp	.+2      	; 0xe340 <FSettingPumpPooling+0x468>
    e33e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    e340:	6a 96       	adiw	r28, 0x1a	; 26
    e342:	0f b6       	in	r0, 0x3f	; 63
    e344:	f8 94       	cli
    e346:	de bf       	out	0x3e, r29	; 62
    e348:	0f be       	out	0x3f, r0	; 63
    e34a:	cd bf       	out	0x3d, r28	; 61
    e34c:	cf 91       	pop	r28
    e34e:	df 91       	pop	r29
    e350:	1f 91       	pop	r17
    e352:	0f 91       	pop	r16
    e354:	08 95       	ret

0000e356 <DisplayTicker>:
	 lcd_print(2, 1, lcdteks);
}

void DisplayTicker(){
static char stDisplayTicker=tiRight;
	switch(stDisplayTicker){
    e356:	80 91 8a 03 	lds	r24, 0x038A
    e35a:	81 30       	cpi	r24, 0x01	; 1
    e35c:	81 f0       	breq	.+32     	; 0xe37e <DisplayTicker+0x28>
    e35e:	81 30       	cpi	r24, 0x01	; 1
    e360:	28 f0       	brcs	.+10     	; 0xe36c <DisplayTicker+0x16>
    e362:	82 30       	cpi	r24, 0x02	; 2
    e364:	91 f0       	breq	.+36     	; 0xe38a <DisplayTicker+0x34>
    e366:	83 30       	cpi	r24, 0x03	; 3
    e368:	09 f5       	brne	.+66     	; 0xe3ac <DisplayTicker+0x56>
    e36a:	1a c0       	rjmp	.+52     	; 0xe3a0 <DisplayTicker+0x4a>
	case tiRight:
	     lcd_put(4, 1, '>');
    e36c:	84 e0       	ldi	r24, 0x04	; 4
    e36e:	61 e0       	ldi	r22, 0x01	; 1
    e370:	4e e3       	ldi	r20, 0x3E	; 62
    e372:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
		 TimTicker=0;
    e376:	10 92 ba 01 	sts	0x01BA, r1
         stDisplayTicker=tiDelayRight;
    e37a:	81 e0       	ldi	r24, 0x01	; 1
    e37c:	0e c0       	rjmp	.+28     	; 0xe39a <DisplayTicker+0x44>
	break;
	case tiDelayRight:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiLeft;	     
    e37e:	80 91 ba 01 	lds	r24, 0x01BA
    e382:	8b 30       	cpi	r24, 0x0B	; 11
    e384:	98 f0       	brcs	.+38     	; 0xe3ac <DisplayTicker+0x56>
    e386:	82 e0       	ldi	r24, 0x02	; 2
    e388:	08 c0       	rjmp	.+16     	; 0xe39a <DisplayTicker+0x44>
	     break;
	case tiLeft:
	     lcd_put(4, 1, '<');
    e38a:	84 e0       	ldi	r24, 0x04	; 4
    e38c:	61 e0       	ldi	r22, 0x01	; 1
    e38e:	4c e3       	ldi	r20, 0x3C	; 60
    e390:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
         TimTicker=0;
    e394:	10 92 ba 01 	sts	0x01BA, r1
         stDisplayTicker=tiDelayLeft;
    e398:	83 e0       	ldi	r24, 0x03	; 3
    e39a:	80 93 8a 03 	sts	0x038A, r24
    e39e:	08 95       	ret
	break;
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
    e3a0:	80 91 ba 01 	lds	r24, 0x01BA
    e3a4:	8b 30       	cpi	r24, 0x0B	; 11
    e3a6:	10 f0       	brcs	.+4      	; 0xe3ac <DisplayTicker+0x56>
    e3a8:	10 92 8a 03 	sts	0x038A, r1
    e3ac:	08 95       	ret

0000e3ae <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    e3ae:	6f 92       	push	r6
    e3b0:	7f 92       	push	r7
    e3b2:	8f 92       	push	r8
    e3b4:	9f 92       	push	r9
    e3b6:	af 92       	push	r10
    e3b8:	bf 92       	push	r11
    e3ba:	cf 92       	push	r12
    e3bc:	df 92       	push	r13
    e3be:	ff 92       	push	r15
    e3c0:	0f 93       	push	r16
    e3c2:	1f 93       	push	r17
    e3c4:	df 93       	push	r29
    e3c6:	cf 93       	push	r28
    e3c8:	cd b7       	in	r28, 0x3d	; 61
    e3ca:	de b7       	in	r29, 0x3e	; 62
    e3cc:	67 97       	sbiw	r28, 0x17	; 23
    e3ce:	0f b6       	in	r0, 0x3f	; 63
    e3d0:	f8 94       	cli
    e3d2:	de bf       	out	0x3e, r29	; 62
    e3d4:	0f be       	out	0x3f, r0	; 63
    e3d6:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    e3d8:	80 91 87 03 	lds	r24, 0x0387
    e3dc:	90 91 88 03 	lds	r25, 0x0388
    e3e0:	01 96       	adiw	r24, 0x01	; 1
    e3e2:	90 93 88 03 	sts	0x0388, r25
    e3e6:	80 93 87 03 	sts	0x0387, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    e3ea:	62 e3       	ldi	r22, 0x32	; 50
    e3ec:	70 e0       	ldi	r23, 0x00	; 0
    e3ee:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    e3f2:	89 2b       	or	r24, r25
    e3f4:	29 f5       	brne	.+74     	; 0xe440 <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    e3f6:	80 91 25 01 	lds	r24, 0x0125
    e3fa:	82 30       	cpi	r24, 0x02	; 2
    e3fc:	11 f4       	brne	.+4      	; 0xe402 <DisplayIdle+0x54>
    e3fe:	0e 94 16 41 	call	0x822c	; 0x822c <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e402:	e1 99       	sbic	0x1c, 1	; 28
    e404:	fe cf       	rjmp	.-4      	; 0xe402 <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e406:	87 e3       	ldi	r24, 0x37	; 55
    e408:	90 e0       	ldi	r25, 0x00	; 0
    e40a:	9f bb       	out	0x1f, r25	; 31
    e40c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e40e:	e0 9a       	sbi	0x1c, 0	; 28
    e410:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&__date_time)) DisplayDateTime();
    e412:	88 23       	and	r24, r24
    e414:	19 f0       	breq	.+6      	; 0xe41c <DisplayIdle+0x6e>
    e416:	0e 94 9f 61 	call	0xc33e	; 0xc33e <DisplayDateTime>
    e41a:	02 c0       	rjmp	.+4      	; 0xe420 <DisplayIdle+0x72>
       else DisplayTicker();
    e41c:	0e 94 ab 71 	call	0xe356	; 0xe356 <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    e420:	80 91 25 01 	lds	r24, 0x0125
    e424:	82 30       	cpi	r24, 0x02	; 2
    e426:	61 f4       	brne	.+24     	; 0xe440 <DisplayIdle+0x92>
    e428:	80 91 aa 01 	lds	r24, 0x01AA
    e42c:	81 30       	cpi	r24, 0x01	; 1
    e42e:	41 f4       	brne	.+16     	; 0xe440 <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    e430:	10 92 aa 01 	sts	0x01AA, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    e434:	84 e0       	ldi	r24, 0x04	; 4
    e436:	62 e1       	ldi	r22, 0x12	; 18
    e438:	40 91 a9 01 	lds	r20, 0x01A9
    e43c:	0e 94 36 6f 	call	0xde6c	; 0xde6c <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    e440:	f0 90 86 03 	lds	r15, 0x0386
    e444:	ff 20       	and	r15, r15
    e446:	29 f0       	breq	.+10     	; 0xe452 <DisplayIdle+0xa4>
    e448:	81 e0       	ldi	r24, 0x01	; 1
    e44a:	f8 16       	cp	r15, r24
    e44c:	09 f0       	breq	.+2      	; 0xe450 <DisplayIdle+0xa2>
    e44e:	58 c0       	rjmp	.+176    	; 0xe500 <DisplayIdle+0x152>
    e450:	2f c0       	rjmp	.+94     	; 0xe4b0 <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    e452:	f0 90 e0 01 	lds	r15, 0x01E0
    e456:	91 e0       	ldi	r25, 0x01	; 1
    e458:	f9 16       	cp	r15, r25
    e45a:	09 f0       	breq	.+2      	; 0xe45e <DisplayIdle+0xb0>
    e45c:	51 c0       	rjmp	.+162    	; 0xe500 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    e45e:	00 d0       	rcall	.+0      	; 0xe460 <DisplayIdle+0xb2>
    e460:	00 d0       	rcall	.+0      	; 0xe462 <DisplayIdle+0xb4>
    e462:	00 d0       	rcall	.+0      	; 0xe464 <DisplayIdle+0xb6>
    e464:	ed b7       	in	r30, 0x3d	; 61
    e466:	fe b7       	in	r31, 0x3e	; 62
    e468:	31 96       	adiw	r30, 0x01	; 1
    e46a:	8e 01       	movw	r16, r28
    e46c:	0c 5f       	subi	r16, 0xFC	; 252
    e46e:	1f 4f       	sbci	r17, 0xFF	; 255
    e470:	ad b7       	in	r26, 0x3d	; 61
    e472:	be b7       	in	r27, 0x3e	; 62
    e474:	12 96       	adiw	r26, 0x02	; 2
    e476:	1c 93       	st	X, r17
    e478:	0e 93       	st	-X, r16
    e47a:	11 97       	sbiw	r26, 0x01	; 1
    e47c:	8d e3       	ldi	r24, 0x3D	; 61
    e47e:	9b e1       	ldi	r25, 0x1B	; 27
    e480:	93 83       	std	Z+3, r25	; 0x03
    e482:	82 83       	std	Z+2, r24	; 0x02
    e484:	83 ec       	ldi	r24, 0xC3	; 195
    e486:	99 e0       	ldi	r25, 0x09	; 9
    e488:	95 83       	std	Z+5, r25	; 0x05
    e48a:	84 83       	std	Z+4, r24	; 0x04
    e48c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e490:	ed b7       	in	r30, 0x3d	; 61
    e492:	fe b7       	in	r31, 0x3e	; 62
    e494:	36 96       	adiw	r30, 0x06	; 6
    e496:	0f b6       	in	r0, 0x3f	; 63
    e498:	f8 94       	cli
    e49a:	fe bf       	out	0x3e, r31	; 62
    e49c:	0f be       	out	0x3f, r0	; 63
    e49e:	ed bf       	out	0x3d, r30	; 61
    e4a0:	83 e0       	ldi	r24, 0x03	; 3
    e4a2:	61 e0       	ldi	r22, 0x01	; 1
    e4a4:	a8 01       	movw	r20, r16
    e4a6:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			   stDispIdle=diWaitNoBusy;
    e4aa:	f0 92 86 03 	sts	0x0386, r15
    e4ae:	28 c0       	rjmp	.+80     	; 0xe500 <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    e4b0:	80 91 e0 01 	lds	r24, 0x01E0
    e4b4:	88 23       	and	r24, r24
    e4b6:	21 f5       	brne	.+72     	; 0xe500 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    e4b8:	00 d0       	rcall	.+0      	; 0xe4ba <DisplayIdle+0x10c>
    e4ba:	00 d0       	rcall	.+0      	; 0xe4bc <DisplayIdle+0x10e>
    e4bc:	8e 01       	movw	r16, r28
    e4be:	0c 5f       	subi	r16, 0xFC	; 252
    e4c0:	1f 4f       	sbci	r17, 0xFF	; 255
    e4c2:	ad b7       	in	r26, 0x3d	; 61
    e4c4:	be b7       	in	r27, 0x3e	; 62
    e4c6:	12 96       	adiw	r26, 0x02	; 2
    e4c8:	1c 93       	st	X, r17
    e4ca:	0e 93       	st	-X, r16
    e4cc:	11 97       	sbiw	r26, 0x01	; 1
    e4ce:	88 e2       	ldi	r24, 0x28	; 40
    e4d0:	9b e1       	ldi	r25, 0x1B	; 27
    e4d2:	14 96       	adiw	r26, 0x04	; 4
    e4d4:	9c 93       	st	X, r25
    e4d6:	8e 93       	st	-X, r24
    e4d8:	13 97       	sbiw	r26, 0x03	; 3
    e4da:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e4de:	0f 90       	pop	r0
    e4e0:	0f 90       	pop	r0
    e4e2:	0f 90       	pop	r0
    e4e4:	0f 90       	pop	r0
    e4e6:	83 e0       	ldi	r24, 0x03	; 3
    e4e8:	61 e0       	ldi	r22, 0x01	; 1
    e4ea:	a8 01       	movw	r20, r16
    e4ec:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			   stDispIdle=diScan;
    e4f0:	10 92 86 03 	sts	0x0386, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    e4f4:	80 91 b9 01 	lds	r24, 0x01B9
    e4f8:	88 23       	and	r24, r24
    e4fa:	11 f0       	breq	.+4      	; 0xe500 <DisplayIdle+0x152>
    e4fc:	f0 92 c2 01 	sts	0x01C2, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    e500:	80 91 c2 01 	lds	r24, 0x01C2
    e504:	81 30       	cpi	r24, 0x01	; 1
    e506:	09 f0       	breq	.+2      	; 0xe50a <DisplayIdle+0x15c>
    e508:	69 c0       	rjmp	.+210    	; 0xe5dc <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    e50a:	10 92 c2 01 	sts	0x01C2, r1
		 if (nLocalAccount>0){
    e50e:	80 91 b9 01 	lds	r24, 0x01B9
    e512:	88 23       	and	r24, r24
    e514:	09 f4       	brne	.+2      	; 0xe518 <DisplayIdle+0x16a>
    e516:	5c c0       	rjmp	.+184    	; 0xe5d0 <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    e518:	83 e0       	ldi	r24, 0x03	; 3
    e51a:	61 e0       	ldi	r22, 0x01	; 1
    e51c:	42 e2       	ldi	r20, 0x22	; 34
    e51e:	5b e1       	ldi	r21, 0x1B	; 27
    e520:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    e524:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e526:	5e 01       	movw	r10, r28
    e528:	08 94       	sec
    e52a:	a1 1c       	adc	r10, r1
    e52c:	b1 1c       	adc	r11, r1
    e52e:	3d e1       	ldi	r19, 0x1D	; 29
    e530:	63 2e       	mov	r6, r19
    e532:	3b e1       	ldi	r19, 0x1B	; 27
    e534:	73 2e       	mov	r7, r19
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e536:	24 e0       	ldi	r18, 0x04	; 4
    e538:	c2 2e       	mov	r12, r18
    e53a:	d1 2c       	mov	r13, r1
    e53c:	cc 0e       	add	r12, r28
    e53e:	dd 1e       	adc	r13, r29
    e540:	99 e1       	ldi	r25, 0x19	; 25
    e542:	89 2e       	mov	r8, r25
    e544:	9b e1       	ldi	r25, 0x1B	; 27
    e546:	99 2e       	mov	r9, r25
    e548:	3d c0       	rjmp	.+122    	; 0xe5c4 <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e54a:	0f 2d       	mov	r16, r15
    e54c:	10 e0       	ldi	r17, 0x00	; 0
    e54e:	00 d0       	rcall	.+0      	; 0xe550 <DisplayIdle+0x1a2>
    e550:	00 d0       	rcall	.+0      	; 0xe552 <DisplayIdle+0x1a4>
    e552:	00 d0       	rcall	.+0      	; 0xe554 <DisplayIdle+0x1a6>
    e554:	ad b7       	in	r26, 0x3d	; 61
    e556:	be b7       	in	r27, 0x3e	; 62
    e558:	11 96       	adiw	r26, 0x01	; 1
    e55a:	ed b7       	in	r30, 0x3d	; 61
    e55c:	fe b7       	in	r31, 0x3e	; 62
    e55e:	b2 82       	std	Z+2, r11	; 0x02
    e560:	a1 82       	std	Z+1, r10	; 0x01
    e562:	13 96       	adiw	r26, 0x03	; 3
    e564:	7c 92       	st	X, r7
    e566:	6e 92       	st	-X, r6
    e568:	12 97       	sbiw	r26, 0x02	; 2
    e56a:	f8 01       	movw	r30, r16
    e56c:	e5 5a       	subi	r30, 0xA5	; 165
    e56e:	fa 4f       	sbci	r31, 0xFA	; 250
    e570:	80 81       	ld	r24, Z
    e572:	14 96       	adiw	r26, 0x04	; 4
    e574:	8c 93       	st	X, r24
    e576:	14 97       	sbiw	r26, 0x04	; 4
    e578:	15 96       	adiw	r26, 0x05	; 5
    e57a:	1c 92       	st	X, r1
    e57c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e580:	ed b7       	in	r30, 0x3d	; 61
    e582:	fe b7       	in	r31, 0x3e	; 62
    e584:	31 96       	adiw	r30, 0x01	; 1
    e586:	ad b7       	in	r26, 0x3d	; 61
    e588:	be b7       	in	r27, 0x3e	; 62
    e58a:	12 96       	adiw	r26, 0x02	; 2
    e58c:	dc 92       	st	X, r13
    e58e:	ce 92       	st	-X, r12
    e590:	11 97       	sbiw	r26, 0x01	; 1
    e592:	93 82       	std	Z+3, r9	; 0x03
    e594:	82 82       	std	Z+2, r8	; 0x02
    e596:	b5 82       	std	Z+5, r11	; 0x05
    e598:	a4 82       	std	Z+4, r10	; 0x04
    e59a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    e59e:	ed b7       	in	r30, 0x3d	; 61
    e5a0:	fe b7       	in	r31, 0x3e	; 62
    e5a2:	36 96       	adiw	r30, 0x06	; 6
    e5a4:	0f b6       	in	r0, 0x3f	; 63
    e5a6:	f8 94       	cli
    e5a8:	fe bf       	out	0x3e, r31	; 62
    e5aa:	0f be       	out	0x3f, r0	; 63
    e5ac:	ed bf       	out	0x3d, r30	; 61
    e5ae:	b8 01       	movw	r22, r16
    e5b0:	66 0f       	add	r22, r22
    e5b2:	77 1f       	adc	r23, r23
    e5b4:	60 0f       	add	r22, r16
    e5b6:	71 1f       	adc	r23, r17
    e5b8:	6a 5f       	subi	r22, 0xFA	; 250
    e5ba:	83 e0       	ldi	r24, 0x03	; 3
    e5bc:	a6 01       	movw	r20, r12
    e5be:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    e5c2:	f3 94       	inc	r15
    e5c4:	80 91 b9 01 	lds	r24, 0x01B9
    e5c8:	f8 16       	cp	r15, r24
    e5ca:	08 f4       	brcc	.+2      	; 0xe5ce <DisplayIdle+0x220>
    e5cc:	be cf       	rjmp	.-132    	; 0xe54a <DisplayIdle+0x19c>
    e5ce:	06 c0       	rjmp	.+12     	; 0xe5dc <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    e5d0:	83 e0       	ldi	r24, 0x03	; 3
    e5d2:	61 e0       	ldi	r22, 0x01	; 1
    e5d4:	44 e0       	ldi	r20, 0x04	; 4
    e5d6:	5b e1       	ldi	r21, 0x1B	; 27
    e5d8:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    e5dc:	80 91 d6 01 	lds	r24, 0x01D6
    e5e0:	81 30       	cpi	r24, 0x01	; 1
    e5e2:	c1 f4       	brne	.+48     	; 0xe614 <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    e5e4:	10 92 d6 01 	sts	0x01D6, r1
	     if (nLocalAccount>0){
    e5e8:	90 91 b9 01 	lds	r25, 0x01B9
    e5ec:	99 23       	and	r25, r25
    e5ee:	91 f0       	breq	.+36     	; 0xe614 <DisplayIdle+0x266>
    e5f0:	eb e5       	ldi	r30, 0x5B	; 91
    e5f2:	f5 e0       	ldi	r31, 0x05	; 5
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e5f4:	29 2f       	mov	r18, r25
    e5f6:	30 e0       	ldi	r19, 0x00	; 0
    e5f8:	2e 0f       	add	r18, r30
    e5fa:	3f 1f       	adc	r19, r31
    e5fc:	02 c0       	rjmp	.+4      	; 0xe602 <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    e5fe:	81 81       	ldd	r24, Z+1	; 0x01
    e600:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e602:	e2 17       	cp	r30, r18
    e604:	f3 07       	cpc	r31, r19
    e606:	d9 f7       	brne	.-10     	; 0xe5fe <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    e608:	91 50       	subi	r25, 0x01	; 1
    e60a:	90 93 b9 01 	sts	0x01B9, r25
             IsViewFillingFIP=True; 
    e60e:	81 e0       	ldi	r24, 0x01	; 1
    e610:	80 93 c2 01 	sts	0x01C2, r24
		 }
	 }
}
    e614:	67 96       	adiw	r28, 0x17	; 23
    e616:	0f b6       	in	r0, 0x3f	; 63
    e618:	f8 94       	cli
    e61a:	de bf       	out	0x3e, r29	; 62
    e61c:	0f be       	out	0x3f, r0	; 63
    e61e:	cd bf       	out	0x3d, r28	; 61
    e620:	cf 91       	pop	r28
    e622:	df 91       	pop	r29
    e624:	1f 91       	pop	r17
    e626:	0f 91       	pop	r16
    e628:	ff 90       	pop	r15
    e62a:	df 90       	pop	r13
    e62c:	cf 90       	pop	r12
    e62e:	bf 90       	pop	r11
    e630:	af 90       	pop	r10
    e632:	9f 90       	pop	r9
    e634:	8f 90       	pop	r8
    e636:	7f 90       	pop	r7
    e638:	6f 90       	pop	r6
    e63a:	08 95       	ret

0000e63c <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    e63c:	ef 92       	push	r14
    e63e:	ff 92       	push	r15
    e640:	0f 93       	push	r16
    e642:	1f 93       	push	r17
    e644:	cf 93       	push	r28
    e646:	df 93       	push	r29
    e648:	ec 01       	movw	r28, r24
    e64a:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    e64c:	08 81       	ld	r16, Y
    e64e:	00 53       	subi	r16, 0x30	; 48
    e650:	10 e0       	ldi	r17, 0x00	; 0
    e652:	04 c0       	rjmp	.+8      	; 0xe65c <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    e654:	ce 01       	movw	r24, r28
    e656:	0e 94 b9 2d 	call	0x5b72	; 0x5b72 <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    e65a:	1f 5f       	subi	r17, 0xFF	; 255
    e65c:	10 17       	cp	r17, r16
    e65e:	d0 f3       	brcs	.-12     	; 0xe654 <ValidateRestoreCode+0x18>
	 //_uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //_uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    e660:	ce 01       	movw	r24, r28
    e662:	b7 01       	movw	r22, r14
    e664:	0e 94 c4 b5 	call	0x16b88	; 0x16b88 <strcmp>
    e668:	00 97       	sbiw	r24, 0x00	; 0
    e66a:	11 f0       	breq	.+4      	; 0xe670 <ValidateRestoreCode+0x34>
    e66c:	82 e0       	ldi	r24, 0x02	; 2
    e66e:	01 c0       	rjmp	.+2      	; 0xe672 <ValidateRestoreCode+0x36>
    e670:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    e672:	df 91       	pop	r29
    e674:	cf 91       	pop	r28
    e676:	1f 91       	pop	r17
    e678:	0f 91       	pop	r16
    e67a:	ff 90       	pop	r15
    e67c:	ef 90       	pop	r14
    e67e:	08 95       	ret

0000e680 <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    e680:	ef 92       	push	r14
    e682:	ff 92       	push	r15
    e684:	0f 93       	push	r16
    e686:	1f 93       	push	r17
    e688:	df 93       	push	r29
    e68a:	cf 93       	push	r28
    e68c:	cd b7       	in	r28, 0x3d	; 61
    e68e:	de b7       	in	r29, 0x3e	; 62
    e690:	2a 97       	sbiw	r28, 0x0a	; 10
    e692:	0f b6       	in	r0, 0x3f	; 63
    e694:	f8 94       	cli
    e696:	de bf       	out	0x3e, r29	; 62
    e698:	0f be       	out	0x3f, r0	; 63
    e69a:	cd bf       	out	0x3d, r28	; 61
    e69c:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         _uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    e69e:	fb 01       	movw	r30, r22
    e6a0:	01 90       	ld	r0, Z+
    e6a2:	00 20       	and	r0, r0
    e6a4:	e9 f7       	brne	.-6      	; 0xe6a0 <ValidateGeniusCode+0x20>
    e6a6:	39 97       	sbiw	r30, 0x09	; 9
    e6a8:	e6 17       	cp	r30, r22
    e6aa:	f7 07       	cpc	r31, r23
    e6ac:	11 f0       	breq	.+4      	; 0xe6b2 <ValidateGeniusCode+0x32>
    e6ae:	80 e0       	ldi	r24, 0x00	; 0
    e6b0:	11 c0       	rjmp	.+34     	; 0xe6d4 <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    e6b2:	fb 01       	movw	r30, r22
    e6b4:	60 81       	ld	r22, Z
    e6b6:	8e 01       	movw	r16, r28
    e6b8:	0f 5f       	subi	r16, 0xFF	; 255
    e6ba:	1f 4f       	sbci	r17, 0xFF	; 255
    e6bc:	a8 01       	movw	r20, r16
    e6be:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         _uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    e6c2:	c8 01       	movw	r24, r16
    e6c4:	b7 01       	movw	r22, r14
    e6c6:	0e 94 c4 b5 	call	0x16b88	; 0x16b88 <strcmp>
    e6ca:	00 97       	sbiw	r24, 0x00	; 0
    e6cc:	11 f0       	breq	.+4      	; 0xe6d2 <ValidateGeniusCode+0x52>
    e6ce:	82 e0       	ldi	r24, 0x02	; 2
    e6d0:	01 c0       	rjmp	.+2      	; 0xe6d4 <ValidateGeniusCode+0x54>
    e6d2:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    e6d4:	2a 96       	adiw	r28, 0x0a	; 10
    e6d6:	0f b6       	in	r0, 0x3f	; 63
    e6d8:	f8 94       	cli
    e6da:	de bf       	out	0x3e, r29	; 62
    e6dc:	0f be       	out	0x3f, r0	; 63
    e6de:	cd bf       	out	0x3d, r28	; 61
    e6e0:	cf 91       	pop	r28
    e6e2:	df 91       	pop	r29
    e6e4:	1f 91       	pop	r17
    e6e6:	0f 91       	pop	r16
    e6e8:	ff 90       	pop	r15
    e6ea:	ef 90       	pop	r14
    e6ec:	08 95       	ret

0000e6ee <_menu_password>:

//****************************************************************
// menu autorisasi
// untuk masuk dgn password untuk merubah parameter
//****************************************************************
unsigned char _menu_password(void){
    e6ee:	df 92       	push	r13
    e6f0:	ef 92       	push	r14
    e6f2:	ff 92       	push	r15
    e6f4:	0f 93       	push	r16
    e6f6:	1f 93       	push	r17
    e6f8:	df 93       	push	r29
    e6fa:	cf 93       	push	r28
    e6fc:	cd b7       	in	r28, 0x3d	; 61
    e6fe:	de b7       	in	r29, 0x3e	; 62
    e700:	66 97       	sbiw	r28, 0x16	; 22
    e702:	0f b6       	in	r0, 0x3f	; 63
    e704:	f8 94       	cli
    e706:	de bf       	out	0x3e, r29	; 62
    e708:	0f be       	out	0x3f, r0	; 63
    e70a:	cd bf       	out	0x3d, r28	; 61
	char	__pad = 0, __ret = 3;
	char	__t_spv_pass[_MAX_PASS + 1];
	char	__t_sys_pass[_MAX_PASS + 1];

	__max_string = _MAX_PASS;	
    e70c:	8a e0       	ldi	r24, 0x0A	; 10
    e70e:	80 93 db 03 	sts	0x03DB, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e712:	7e 01       	movw	r14, r28
    e714:	08 94       	sec
    e716:	e1 1c       	adc	r14, r1
    e718:	f1 1c       	adc	r15, r1
    e71a:	c7 01       	movw	r24, r14
    e71c:	61 e0       	ldi	r22, 0x01	; 1
    e71e:	70 e0       	ldi	r23, 0x00	; 0
    e720:	4b e0       	ldi	r20, 0x0B	; 11
    e722:	50 e0       	ldi	r21, 0x00	; 0
    e724:	27 e9       	ldi	r18, 0x97	; 151
    e726:	32 e1       	ldi	r19, 0x12	; 18
    e728:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	eeprom_read_block((void*) &__t_spv_pass, (const void*) &DefSpvPassword, _MAX_PASS + 1);
	eeprom_read_block((void*) &__t_sys_pass, (const void*) &DefSysPassword, _MAX_PASS + 1);


	lcd_clear();_delay_ms(10);
    e72c:	8e 01       	movw	r16, r28
    e72e:	04 5f       	subi	r16, 0xF4	; 244
    e730:	1f 4f       	sbci	r17, 0xFF	; 255
    e732:	c8 01       	movw	r24, r16
    e734:	6b e0       	ldi	r22, 0x0B	; 11
    e736:	70 e0       	ldi	r23, 0x00	; 0
    e738:	4b e0       	ldi	r20, 0x0B	; 11
    e73a:	50 e0       	ldi	r21, 0x00	; 0
    e73c:	27 e9       	ldi	r18, 0x97	; 151
    e73e:	32 e1       	ldi	r19, 0x12	; 18
    e740:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    e744:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    e748:	84 ec       	ldi	r24, 0xC4	; 196
    e74a:	99 e0       	ldi	r25, 0x09	; 9
    e74c:	01 97       	sbiw	r24, 0x01	; 1
    e74e:	f1 f7       	brne	.-4      	; 0xe74c <_menu_password+0x5e>
//	lcd_print(3, 1, __t_sys_pass);
	lcd_printf(1, 1, PSTR("PASSWORD:"));
    e750:	81 e0       	ldi	r24, 0x01	; 1
    e752:	61 e0       	ldi	r22, 0x01	; 1
    e754:	4d e5       	ldi	r20, 0x5D	; 93
    e756:	57 e1       	ldi	r21, 0x17	; 23
    e758:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_printf(4, 1, PSTR("[*]Cancel   [#]Enter"));
    e75c:	84 e0       	ldi	r24, 0x04	; 4
    e75e:	61 e0       	ldi	r22, 0x01	; 1
    e760:	48 e4       	ldi	r20, 0x48	; 72
    e762:	57 e1       	ldi	r21, 0x17	; 23
    e764:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	lcd_xy(2, 1);
    e768:	82 e0       	ldi	r24, 0x02	; 2
    e76a:	61 e0       	ldi	r22, 0x01	; 1
    e76c:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>

	while(1){
		__pad = _key_string(2);
		if(!__pad){
			if(strcmp(__buf_string, __t_sys_pass) == 0){
    e770:	d0 2e       	mov	r13, r16
    e772:	01 2f       	mov	r16, r17
				__ret = 0x36;
				break;
			}
			else if(strcmp(__buf_string, __t_spv_pass) == 0){
    e774:	1e 2d       	mov	r17, r14
    e776:	ef 2c       	mov	r14, r15
	lcd_printf(1, 1, PSTR("PASSWORD:"));
	lcd_printf(4, 1, PSTR("[*]Cancel   [#]Enter"));
	lcd_xy(2, 1);

	while(1){
		__pad = _key_string(2);
    e778:	82 e0       	ldi	r24, 0x02	; 2
    e77a:	0e 94 4a af 	call	0x15e94	; 0x15e94 <_key_string>
		if(!__pad){
    e77e:	88 23       	and	r24, r24
    e780:	11 f0       	breq	.+4      	; 0xe786 <_menu_password+0x98>
    e782:	80 e0       	ldi	r24, 0x00	; 0
    e784:	20 c0       	rjmp	.+64     	; 0xe7c6 <_menu_password+0xd8>
			if(strcmp(__buf_string, __t_sys_pass) == 0){
    e786:	89 eb       	ldi	r24, 0xB9	; 185
    e788:	9e e0       	ldi	r25, 0x0E	; 14
    e78a:	6d 2d       	mov	r22, r13
    e78c:	70 2f       	mov	r23, r16
    e78e:	0e 94 c4 b5 	call	0x16b88	; 0x16b88 <strcmp>
    e792:	00 97       	sbiw	r24, 0x00	; 0
    e794:	b9 f0       	breq	.+46     	; 0xe7c4 <_menu_password+0xd6>
				__ret = 0x36;
				break;
			}
			else if(strcmp(__buf_string, __t_spv_pass) == 0){
    e796:	89 eb       	ldi	r24, 0xB9	; 185
    e798:	9e e0       	ldi	r25, 0x0E	; 14
    e79a:	61 2f       	mov	r22, r17
    e79c:	7e 2d       	mov	r23, r14
    e79e:	0e 94 c4 b5 	call	0x16b88	; 0x16b88 <strcmp>
    e7a2:	00 97       	sbiw	r24, 0x00	; 0
    e7a4:	11 f4       	brne	.+4      	; 0xe7aa <_menu_password+0xbc>
    e7a6:	83 e6       	ldi	r24, 0x63	; 99
    e7a8:	0e c0       	rjmp	.+28     	; 0xe7c6 <_menu_password+0xd8>
				__ret = 0x63;
				break;
			}
			else{
				lcd_print(2, 1, "                    ");
    e7aa:	82 e0       	ldi	r24, 0x02	; 2
    e7ac:	61 e0       	ldi	r22, 0x01	; 1
    e7ae:	40 e1       	ldi	r20, 0x10	; 16
    e7b0:	51 e0       	ldi	r21, 0x01	; 1
    e7b2:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
				lcd_xy(2, 1);
    e7b6:	82 e0       	ldi	r24, 0x02	; 2
    e7b8:	61 e0       	ldi	r22, 0x01	; 1
    e7ba:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
				__chr_count = 0;
    e7be:	10 92 da 03 	sts	0x03DA, r1
    e7c2:	da cf       	rjmp	.-76     	; 0xe778 <_menu_password+0x8a>
    e7c4:	86 e3       	ldi	r24, 0x36	; 54
			__ret = 0x00;
			break;
		}
	}
	return __ret;
}
    e7c6:	66 96       	adiw	r28, 0x16	; 22
    e7c8:	0f b6       	in	r0, 0x3f	; 63
    e7ca:	f8 94       	cli
    e7cc:	de bf       	out	0x3e, r29	; 62
    e7ce:	0f be       	out	0x3f, r0	; 63
    e7d0:	cd bf       	out	0x3d, r28	; 61
    e7d2:	cf 91       	pop	r28
    e7d4:	df 91       	pop	r29
    e7d6:	1f 91       	pop	r17
    e7d8:	0f 91       	pop	r16
    e7da:	ff 90       	pop	r15
    e7dc:	ef 90       	pop	r14
    e7de:	df 90       	pop	r13
    e7e0:	08 95       	ret

0000e7e2 <FMenuSettingPassword>:
	 }
   return Result;
}
char FMenuSettingPassword(){
     char Result;
   _menu_password();
    e7e2:	0e 94 77 73 	call	0xe6ee	; 0xe6ee <_menu_password>
   Result=MENU_DONE;
   return Result;
}
    e7e6:	81 e0       	ldi	r24, 0x01	; 1
    e7e8:	08 95       	ret

0000e7ea <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    e7ea:	81 e0       	ldi	r24, 0x01	; 1
    e7ec:	60 e0       	ldi	r22, 0x00	; 0
    e7ee:	0e 94 34 b1 	call	0x16268	; 0x16268 <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    e7f2:	81 e0       	ldi	r24, 0x01	; 1
    e7f4:	0e 94 47 b1 	call	0x1628e	; 0x1628e <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    e7f8:	bb 98       	cbi	0x17, 3	; 23
    e7fa:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    e7fc:	ba 9a       	sbi	0x17, 2	; 23
}
    e7fe:	08 95       	ret

0000e800 <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    e800:	80 e0       	ldi	r24, 0x00	; 0
    e802:	0e 94 47 b1 	call	0x1628e	; 0x1628e <_spi_enable>
  	_spi_init(0, 1);         //Slave
    e806:	80 e0       	ldi	r24, 0x00	; 0
    e808:	61 e0       	ldi	r22, 0x01	; 1
    e80a:	0e 94 34 b1 	call	0x16268	; 0x16268 <_spi_init>
	sbi(DDRB,3);             //MISO Output
    e80e:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    e810:	bb 9a       	sbi	0x17, 3	; 23
    e812:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    e814:	ba 98       	cbi	0x17, 2	; 23
    e816:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    e818:	b9 98       	cbi	0x17, 1	; 23
    e81a:	c1 9a       	sbi	0x18, 1	; 24
}
    e81c:	08 95       	ret

0000e81e <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    e81e:	1f 93       	push	r17
    e820:	18 2f       	mov	r17, r24
     systemMaster();	 
    e822:	0e 94 f5 73 	call	0xe7ea	; 0xe7ea <systemMaster>
     _spi(EDCData);
    e826:	81 2f       	mov	r24, r17
    e828:	0e 94 5e b1 	call	0x162bc	; 0x162bc <_spi>
     systemSlave();
    e82c:	0e 94 00 74 	call	0xe800	; 0xe800 <systemSlave>
}
    e830:	1f 91       	pop	r17
    e832:	08 95       	ret

0000e834 <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    e834:	cf 92       	push	r12
    e836:	df 92       	push	r13
    e838:	ef 92       	push	r14
    e83a:	ff 92       	push	r15
    e83c:	0f 93       	push	r16
    e83e:	1f 93       	push	r17
    e840:	df 93       	push	r29
    e842:	cf 93       	push	r28
    e844:	cd b7       	in	r28, 0x3d	; 61
    e846:	de b7       	in	r29, 0x3e	; 62
    e848:	ec 97       	sbiw	r28, 0x3c	; 60
    e84a:	0f b6       	in	r0, 0x3f	; 63
    e84c:	f8 94       	cli
    e84e:	de bf       	out	0x3e, r29	; 62
    e850:	0f be       	out	0x3f, r0	; 63
    e852:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    e854:	8d b7       	in	r24, 0x3d	; 61
    e856:	9e b7       	in	r25, 0x3e	; 62
    e858:	42 97       	sbiw	r24, 0x12	; 18
    e85a:	0f b6       	in	r0, 0x3f	; 63
    e85c:	f8 94       	cli
    e85e:	9e bf       	out	0x3e, r25	; 62
    e860:	0f be       	out	0x3f, r0	; 63
    e862:	8d bf       	out	0x3d, r24	; 61
    e864:	ed b7       	in	r30, 0x3d	; 61
    e866:	fe b7       	in	r31, 0x3e	; 62
    e868:	31 96       	adiw	r30, 0x01	; 1
    e86a:	8e 01       	movw	r16, r28
    e86c:	0f 5f       	subi	r16, 0xFF	; 255
    e86e:	1f 4f       	sbci	r17, 0xFF	; 255
    e870:	ad b7       	in	r26, 0x3d	; 61
    e872:	be b7       	in	r27, 0x3e	; 62
    e874:	12 96       	adiw	r26, 0x02	; 2
    e876:	1c 93       	st	X, r17
    e878:	0e 93       	st	-X, r16
    e87a:	11 97       	sbiw	r26, 0x01	; 1
    e87c:	81 ef       	ldi	r24, 0xF1	; 241
    e87e:	9a e1       	ldi	r25, 0x1A	; 26
    e880:	93 83       	std	Z+3, r25	; 0x03
    e882:	82 83       	std	Z+2, r24	; 0x02
    e884:	8d e8       	ldi	r24, 0x8D	; 141
    e886:	9e e0       	ldi	r25, 0x0E	; 14
    e888:	95 83       	std	Z+5, r25	; 0x05
    e88a:	84 83       	std	Z+4, r24	; 0x04
    e88c:	83 ec       	ldi	r24, 0xC3	; 195
    e88e:	99 e0       	ldi	r25, 0x09	; 9
    e890:	97 83       	std	Z+7, r25	; 0x07
    e892:	86 83       	std	Z+6, r24	; 0x06
    e894:	88 e3       	ldi	r24, 0x38	; 56
    e896:	9a e0       	ldi	r25, 0x0A	; 10
    e898:	91 87       	std	Z+9, r25	; 0x09
    e89a:	80 87       	std	Z+8, r24	; 0x08
    e89c:	88 ea       	ldi	r24, 0xA8	; 168
    e89e:	97 e0       	ldi	r25, 0x07	; 7
    e8a0:	93 87       	std	Z+11, r25	; 0x0b
    e8a2:	82 87       	std	Z+10, r24	; 0x0a
    e8a4:	8a e7       	ldi	r24, 0x7A	; 122
    e8a6:	95 e0       	ldi	r25, 0x05	; 5
    e8a8:	95 87       	std	Z+13, r25	; 0x0d
    e8aa:	84 87       	std	Z+12, r24	; 0x0c
    e8ac:	86 eb       	ldi	r24, 0xB6	; 182
    e8ae:	9d e0       	ldi	r25, 0x0D	; 13
    e8b0:	97 87       	std	Z+15, r25	; 0x0f
    e8b2:	86 87       	std	Z+14, r24	; 0x0e
    e8b4:	8f e8       	ldi	r24, 0x8F	; 143
    e8b6:	95 e0       	ldi	r25, 0x05	; 5
    e8b8:	91 8b       	std	Z+17, r25	; 0x11
    e8ba:	80 8b       	std	Z+16, r24	; 0x10
    e8bc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    e8c0:	8d b7       	in	r24, 0x3d	; 61
    e8c2:	9e b7       	in	r25, 0x3e	; 62
    e8c4:	42 96       	adiw	r24, 0x12	; 18
    e8c6:	0f b6       	in	r0, 0x3f	; 63
    e8c8:	f8 94       	cli
    e8ca:	9e bf       	out	0x3e, r25	; 62
    e8cc:	0f be       	out	0x3f, r0	; 63
    e8ce:	8d bf       	out	0x3d, r24	; 61
    e8d0:	82 e0       	ldi	r24, 0x02	; 2
    e8d2:	0e 94 0f 74 	call	0xe81e	; 0xe81e <EDCSendByte>
    e8d6:	ff 24       	eor	r15, r15
    e8d8:	52 e0       	ldi	r21, 0x02	; 2
    e8da:	e5 2e       	mov	r14, r21
    e8dc:	44 ec       	ldi	r20, 0xC4	; 196
    e8de:	c4 2e       	mov	r12, r20
    e8e0:	49 e0       	ldi	r20, 0x09	; 9
    e8e2:	d4 2e       	mov	r13, r20
    e8e4:	0a c0       	rjmp	.+20     	; 0xe8fa <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    e8e6:	a0 0f       	add	r26, r16
    e8e8:	b1 1f       	adc	r27, r17
    e8ea:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    e8ec:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    e8ee:	0e 94 0f 74 	call	0xe81e	; 0xe81e <EDCSendByte>
    e8f2:	c6 01       	movw	r24, r12
    e8f4:	01 97       	sbiw	r24, 0x01	; 1
    e8f6:	f1 f7       	brne	.-4      	; 0xe8f4 <SendEDCMessage+0xc0>
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    e8f8:	f3 94       	inc	r15
    e8fa:	f8 01       	movw	r30, r16
    e8fc:	01 90       	ld	r0, Z+
    e8fe:	00 20       	and	r0, r0
    e900:	e9 f7       	brne	.-6      	; 0xe8fc <SendEDCMessage+0xc8>
    e902:	31 97       	sbiw	r30, 0x01	; 1
    e904:	e0 1b       	sub	r30, r16
    e906:	f1 0b       	sbc	r31, r17
    e908:	af 2d       	mov	r26, r15
    e90a:	b0 e0       	ldi	r27, 0x00	; 0
    e90c:	ae 17       	cp	r26, r30
    e90e:	bf 07       	cpc	r27, r31
    e910:	50 f3       	brcs	.-44     	; 0xe8e6 <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //_uart(0,1,SerialEDC[i]);
		  _delay_ms(10);//min:8
	 }
     EDCSendByte(0x03);
    e912:	83 e0       	ldi	r24, 0x03	; 3
    e914:	0e 94 0f 74 	call	0xe81e	; 0xe81e <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    e918:	83 e0       	ldi	r24, 0x03	; 3
    e91a:	8e 25       	eor	r24, r14
    e91c:	0e 94 0f 74 	call	0xe81e	; 0xe81e <EDCSendByte>
}
    e920:	ec 96       	adiw	r28, 0x3c	; 60
    e922:	0f b6       	in	r0, 0x3f	; 63
    e924:	f8 94       	cli
    e926:	de bf       	out	0x3e, r29	; 62
    e928:	0f be       	out	0x3f, r0	; 63
    e92a:	cd bf       	out	0x3d, r28	; 61
    e92c:	cf 91       	pop	r28
    e92e:	df 91       	pop	r29
    e930:	1f 91       	pop	r17
    e932:	0f 91       	pop	r16
    e934:	ff 90       	pop	r15
    e936:	ef 90       	pop	r14
    e938:	df 90       	pop	r13
    e93a:	cf 90       	pop	r12
    e93c:	08 95       	ret

0000e93e <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    e93e:	0f 93       	push	r16
    e940:	1f 93       	push	r17
    e942:	18 2f       	mov	r17, r24
    e944:	06 2f       	mov	r16, r22
	 systemMaster();
    e946:	0e 94 f5 73 	call	0xe7ea	; 0xe7ea <systemMaster>
	 _spi(0x05);
    e94a:	85 e0       	ldi	r24, 0x05	; 5
    e94c:	0e 94 5e b1 	call	0x162bc	; 0x162bc <_spi>
	 _spi(SlaveCommand);
    e950:	81 2f       	mov	r24, r17
    e952:	0e 94 5e b1 	call	0x162bc	; 0x162bc <_spi>
	 _spi(SlaveMessage);
    e956:	80 2f       	mov	r24, r16
    e958:	0e 94 5e b1 	call	0x162bc	; 0x162bc <_spi>
	 _spi(0x06);
    e95c:	86 e0       	ldi	r24, 0x06	; 6
    e95e:	0e 94 5e b1 	call	0x162bc	; 0x162bc <_spi>
	 systemSlave();
    e962:	0e 94 00 74 	call	0xe800	; 0xe800 <systemSlave>
}
    e966:	1f 91       	pop	r17
    e968:	0f 91       	pop	r16
    e96a:	08 95       	ret

0000e96c <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    e96c:	9f 92       	push	r9
    e96e:	af 92       	push	r10
    e970:	bf 92       	push	r11
    e972:	cf 92       	push	r12
    e974:	df 92       	push	r13
    e976:	ef 92       	push	r14
    e978:	ff 92       	push	r15
    e97a:	0f 93       	push	r16
    e97c:	1f 93       	push	r17
    e97e:	df 93       	push	r29
    e980:	cf 93       	push	r28
    e982:	cd b7       	in	r28, 0x3d	; 61
    e984:	de b7       	in	r29, 0x3e	; 62
    e986:	64 97       	sbiw	r28, 0x14	; 20
    e988:	0f b6       	in	r0, 0x3f	; 63
    e98a:	f8 94       	cli
    e98c:	de bf       	out	0x3e, r29	; 62
    e98e:	0f be       	out	0x3f, r0	; 63
    e990:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    e992:	80 91 f9 02 	lds	r24, 0x02F9
    e996:	85 30       	cpi	r24, 0x05	; 5
    e998:	09 f4       	brne	.+2      	; 0xe99c <FSettingPumpID+0x30>
    e99a:	88 c1       	rjmp	.+784    	; 0xecac <FSettingPumpID+0x340>
    e99c:	86 30       	cpi	r24, 0x06	; 6
    e99e:	90 f4       	brcc	.+36     	; 0xe9c4 <FSettingPumpID+0x58>
    e9a0:	82 30       	cpi	r24, 0x02	; 2
    e9a2:	09 f4       	brne	.+2      	; 0xe9a6 <FSettingPumpID+0x3a>
    e9a4:	8f c0       	rjmp	.+286    	; 0xeac4 <FSettingPumpID+0x158>
    e9a6:	83 30       	cpi	r24, 0x03	; 3
    e9a8:	30 f4       	brcc	.+12     	; 0xe9b6 <FSettingPumpID+0x4a>
    e9aa:	88 23       	and	r24, r24
    e9ac:	f1 f0       	breq	.+60     	; 0xe9ea <FSettingPumpID+0x7e>
    e9ae:	81 30       	cpi	r24, 0x01	; 1
    e9b0:	09 f0       	breq	.+2      	; 0xe9b4 <FSettingPumpID+0x48>
    e9b2:	73 c2       	rjmp	.+1254   	; 0xee9a <FSettingPumpID+0x52e>
    e9b4:	2d c0       	rjmp	.+90     	; 0xea10 <FSettingPumpID+0xa4>
    e9b6:	83 30       	cpi	r24, 0x03	; 3
    e9b8:	09 f4       	brne	.+2      	; 0xe9bc <FSettingPumpID+0x50>
    e9ba:	51 c1       	rjmp	.+674    	; 0xec5e <FSettingPumpID+0x2f2>
    e9bc:	84 30       	cpi	r24, 0x04	; 4
    e9be:	09 f0       	breq	.+2      	; 0xe9c2 <FSettingPumpID+0x56>
    e9c0:	6c c2       	rjmp	.+1240   	; 0xee9a <FSettingPumpID+0x52e>
    e9c2:	6d c1       	rjmp	.+730    	; 0xec9e <FSettingPumpID+0x332>
    e9c4:	88 30       	cpi	r24, 0x08	; 8
    e9c6:	09 f4       	brne	.+2      	; 0xe9ca <FSettingPumpID+0x5e>
    e9c8:	fc c1       	rjmp	.+1016   	; 0xedc2 <FSettingPumpID+0x456>
    e9ca:	89 30       	cpi	r24, 0x09	; 9
    e9cc:	38 f4       	brcc	.+14     	; 0xe9dc <FSettingPumpID+0x70>
    e9ce:	86 30       	cpi	r24, 0x06	; 6
    e9d0:	09 f4       	brne	.+2      	; 0xe9d4 <FSettingPumpID+0x68>
    e9d2:	9b c1       	rjmp	.+822    	; 0xed0a <FSettingPumpID+0x39e>
    e9d4:	87 30       	cpi	r24, 0x07	; 7
    e9d6:	09 f0       	breq	.+2      	; 0xe9da <FSettingPumpID+0x6e>
    e9d8:	60 c2       	rjmp	.+1216   	; 0xee9a <FSettingPumpID+0x52e>
    e9da:	45 c2       	rjmp	.+1162   	; 0xee66 <FSettingPumpID+0x4fa>
    e9dc:	89 30       	cpi	r24, 0x09	; 9
    e9de:	09 f4       	brne	.+2      	; 0xe9e2 <FSettingPumpID+0x76>
    e9e0:	4a c2       	rjmp	.+1172   	; 0xee76 <FSettingPumpID+0x50a>
    e9e2:	8a 30       	cpi	r24, 0x0A	; 10
    e9e4:	09 f0       	breq	.+2      	; 0xe9e8 <FSettingPumpID+0x7c>
    e9e6:	59 c2       	rjmp	.+1202   	; 0xee9a <FSettingPumpID+0x52e>
    e9e8:	4c c2       	rjmp	.+1176   	; 0xee82 <FSettingPumpID+0x516>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    e9ea:	80 91 25 01 	lds	r24, 0x0125
    e9ee:	82 30       	cpi	r24, 0x02	; 2
    e9f0:	21 f4       	brne	.+8      	; 0xe9fa <FSettingPumpID+0x8e>
    e9f2:	8f e1       	ldi	r24, 0x1F	; 31
    e9f4:	60 e0       	ldi	r22, 0x00	; 0
    e9f6:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
    e9fa:	8f ee       	ldi	r24, 0xEF	; 239
    e9fc:	92 e0       	ldi	r25, 0x02	; 2
    e9fe:	65 e4       	ldi	r22, 0x45	; 69
    ea00:	70 e0       	ldi	r23, 0x00	; 0
    ea02:	48 e0       	ldi	r20, 0x08	; 8
    ea04:	50 e0       	ldi	r21, 0x00	; 0
    ea06:	27 e9       	ldi	r18, 0x97	; 151
    ea08:	32 e1       	ldi	r19, 0x12	; 18
    ea0a:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    ea0e:	4c c1       	rjmp	.+664    	; 0xeca8 <FSettingPumpID+0x33c>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    ea10:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    ea14:	bf ee       	ldi	r27, 0xEF	; 239
    ea16:	eb 2e       	mov	r14, r27
    ea18:	b2 e0       	ldi	r27, 0x02	; 2
    ea1a:	fb 2e       	mov	r15, r27
    ea1c:	01 e0       	ldi	r16, 0x01	; 1
    ea1e:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    ea20:	6e 01       	movw	r12, r28
    ea22:	08 94       	sec
    ea24:	c1 1c       	adc	r12, r1
    ea26:	d1 1c       	adc	r13, r1
    ea28:	ab ec       	ldi	r26, 0xCB	; 203
    ea2a:	aa 2e       	mov	r10, r26
    ea2c:	ad e0       	ldi	r26, 0x0D	; 13
    ea2e:	ba 2e       	mov	r11, r26
    ea30:	8d b7       	in	r24, 0x3d	; 61
    ea32:	9e b7       	in	r25, 0x3e	; 62
    ea34:	0c 97       	sbiw	r24, 0x0c	; 12
    ea36:	0f b6       	in	r0, 0x3f	; 63
    ea38:	f8 94       	cli
    ea3a:	9e bf       	out	0x3e, r25	; 62
    ea3c:	0f be       	out	0x3f, r0	; 63
    ea3e:	8d bf       	out	0x3d, r24	; 61
    ea40:	ed b7       	in	r30, 0x3d	; 61
    ea42:	fe b7       	in	r31, 0x3e	; 62
    ea44:	31 96       	adiw	r30, 0x01	; 1
    ea46:	ad b7       	in	r26, 0x3d	; 61
    ea48:	be b7       	in	r27, 0x3e	; 62
    ea4a:	12 96       	adiw	r26, 0x02	; 2
    ea4c:	dc 92       	st	X, r13
    ea4e:	ce 92       	st	-X, r12
    ea50:	11 97       	sbiw	r26, 0x01	; 1
    ea52:	b3 82       	std	Z+3, r11	; 0x03
    ea54:	a2 82       	std	Z+2, r10	; 0x02
    ea56:	15 83       	std	Z+5, r17	; 0x05
    ea58:	04 83       	std	Z+4, r16	; 0x04
    ea5a:	d7 01       	movw	r26, r14
    ea5c:	8c 91       	ld	r24, X
    ea5e:	86 83       	std	Z+6, r24	; 0x06
    ea60:	17 82       	std	Z+7, r1	; 0x07
    ea62:	0c 5f       	subi	r16, 0xFC	; 252
    ea64:	1f 4f       	sbci	r17, 0xFF	; 255
    ea66:	11 87       	std	Z+9, r17	; 0x09
    ea68:	00 87       	std	Z+8, r16	; 0x08
    ea6a:	04 50       	subi	r16, 0x04	; 4
    ea6c:	10 40       	sbci	r17, 0x00	; 0
    ea6e:	14 96       	adiw	r26, 0x04	; 4
    ea70:	8c 91       	ld	r24, X
    ea72:	82 87       	std	Z+10, r24	; 0x0a
    ea74:	13 86       	std	Z+11, r1	; 0x0b
    ea76:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    ea7a:	ed b7       	in	r30, 0x3d	; 61
    ea7c:	fe b7       	in	r31, 0x3e	; 62
    ea7e:	3c 96       	adiw	r30, 0x0c	; 12
    ea80:	0f b6       	in	r0, 0x3f	; 63
    ea82:	f8 94       	cli
    ea84:	fe bf       	out	0x3e, r31	; 62
    ea86:	0f be       	out	0x3f, r0	; 63
    ea88:	ed bf       	out	0x3d, r30	; 61
    ea8a:	80 2f       	mov	r24, r16
    ea8c:	61 e0       	ldi	r22, 0x01	; 1
    ea8e:	a6 01       	movw	r20, r12
    ea90:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    ea94:	08 94       	sec
    ea96:	e1 1c       	adc	r14, r1
    ea98:	f1 1c       	adc	r15, r1
    ea9a:	0f 5f       	subi	r16, 0xFF	; 255
    ea9c:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    ea9e:	f3 ef       	ldi	r31, 0xF3	; 243
    eaa0:	ef 16       	cp	r14, r31
    eaa2:	f2 e0       	ldi	r31, 0x02	; 2
    eaa4:	ff 06       	cpc	r15, r31
    eaa6:	21 f6       	brne	.-120    	; 0xea30 <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    eaa8:	83 e0       	ldi	r24, 0x03	; 3
    eaaa:	6f e0       	ldi	r22, 0x0F	; 15
    eaac:	44 ec       	ldi	r20, 0xC4	; 196
    eaae:	5d e0       	ldi	r21, 0x0D	; 13
    eab0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    eab4:	84 e0       	ldi	r24, 0x04	; 4
    eab6:	6f e0       	ldi	r22, 0x0F	; 15
    eab8:	4d eb       	ldi	r20, 0xBD	; 189
    eaba:	5d e0       	ldi	r21, 0x0D	; 13
    eabc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          stMenuPumpID=mpSelectInput;
    eac0:	82 e0       	ldi	r24, 0x02	; 2
    eac2:	d6 c1       	rjmp	.+940    	; 0xee70 <FSettingPumpID+0x504>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    eac4:	81 e0       	ldi	r24, 0x01	; 1
    eac6:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    eaca:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    eacc:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    ead0:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    ead2:	81 53       	subi	r24, 0x31	; 49
    ead4:	88 30       	cpi	r24, 0x08	; 8
    ead6:	08 f0       	brcs	.+2      	; 0xeada <FSettingPumpID+0x16e>
    ead8:	85 c0       	rjmp	.+266    	; 0xebe4 <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    eada:	80 91 25 01 	lds	r24, 0x0125
    eade:	81 30       	cpi	r24, 0x01	; 1
    eae0:	19 f0       	breq	.+6      	; 0xeae8 <FSettingPumpID+0x17c>
    eae2:	82 30       	cpi	r24, 0x02	; 2
    eae4:	a1 f5       	brne	.+104    	; 0xeb4e <FSettingPumpID+0x1e2>
    eae6:	17 c0       	rjmp	.+46     	; 0xeb16 <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    eae8:	80 91 f8 02 	lds	r24, 0x02F8
    eaec:	88 23       	and	r24, r24
    eaee:	41 f4       	brne	.+16     	; 0xeb00 <FSettingPumpID+0x194>
    eaf0:	e9 2f       	mov	r30, r25
    eaf2:	f0 e0       	ldi	r31, 0x00	; 0
    eaf4:	e2 54       	subi	r30, 0x42	; 66
    eaf6:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    eaf8:	80 81       	ld	r24, Z
    eafa:	83 36       	cpi	r24, 0x63	; 99
    eafc:	c8 f4       	brcc	.+50     	; 0xeb30 <FSettingPumpID+0x1c4>
    eafe:	16 c0       	rjmp	.+44     	; 0xeb2c <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    eb00:	81 30       	cpi	r24, 0x01	; 1
    eb02:	29 f5       	brne	.+74     	; 0xeb4e <FSettingPumpID+0x1e2>
    eb04:	e9 2f       	mov	r30, r25
    eb06:	f0 e0       	ldi	r31, 0x00	; 0
    eb08:	e2 54       	subi	r30, 0x42	; 66
    eb0a:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    eb0c:	80 81       	ld	r24, Z
    eb0e:	88 23       	and	r24, r24
    eb10:	d1 f4       	brne	.+52     	; 0xeb46 <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    eb12:	83 e6       	ldi	r24, 0x63	; 99
    eb14:	1b c0       	rjmp	.+54     	; 0xeb4c <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    eb16:	80 91 f8 02 	lds	r24, 0x02F8
    eb1a:	88 23       	and	r24, r24
    eb1c:	59 f4       	brne	.+22     	; 0xeb34 <FSettingPumpID+0x1c8>
    eb1e:	e9 2f       	mov	r30, r25
    eb20:	f0 e0       	ldi	r31, 0x00	; 0
    eb22:	e2 54       	subi	r30, 0x42	; 66
    eb24:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    eb26:	80 81       	ld	r24, Z
    eb28:	80 31       	cpi	r24, 0x10	; 16
    eb2a:	10 f4       	brcc	.+4      	; 0xeb30 <FSettingPumpID+0x1c4>
	     (*Value)++;
    eb2c:	8f 5f       	subi	r24, 0xFF	; 255
    eb2e:	0e c0       	rjmp	.+28     	; 0xeb4c <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    eb30:	10 82       	st	Z, r1
    eb32:	0d c0       	rjmp	.+26     	; 0xeb4e <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    eb34:	81 30       	cpi	r24, 0x01	; 1
    eb36:	59 f4       	brne	.+22     	; 0xeb4e <FSettingPumpID+0x1e2>
    eb38:	e9 2f       	mov	r30, r25
    eb3a:	f0 e0       	ldi	r31, 0x00	; 0
    eb3c:	e2 54       	subi	r30, 0x42	; 66
    eb3e:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    eb40:	80 81       	ld	r24, Z
    eb42:	88 23       	and	r24, r24
    eb44:	11 f0       	breq	.+4      	; 0xeb4a <FSettingPumpID+0x1de>
	     (*Value)--;
    eb46:	81 50       	subi	r24, 0x01	; 1
    eb48:	01 c0       	rjmp	.+2      	; 0xeb4c <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    eb4a:	80 e1       	ldi	r24, 0x10	; 16
    eb4c:	80 83       	st	Z, r24
    eb4e:	ff ee       	ldi	r31, 0xEF	; 239
    eb50:	ef 2e       	mov	r14, r31
    eb52:	f2 e0       	ldi	r31, 0x02	; 2
    eb54:	ff 2e       	mov	r15, r31
    eb56:	01 e0       	ldi	r16, 0x01	; 1
    eb58:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    eb5a:	6e 01       	movw	r12, r28
    eb5c:	08 94       	sec
    eb5e:	c1 1c       	adc	r12, r1
    eb60:	d1 1c       	adc	r13, r1
    eb62:	e9 ea       	ldi	r30, 0xA9	; 169
    eb64:	ae 2e       	mov	r10, r30
    eb66:	ed e0       	ldi	r30, 0x0D	; 13
    eb68:	be 2e       	mov	r11, r30
    eb6a:	8d b7       	in	r24, 0x3d	; 61
    eb6c:	9e b7       	in	r25, 0x3e	; 62
    eb6e:	0c 97       	sbiw	r24, 0x0c	; 12
    eb70:	0f b6       	in	r0, 0x3f	; 63
    eb72:	f8 94       	cli
    eb74:	9e bf       	out	0x3e, r25	; 62
    eb76:	0f be       	out	0x3f, r0	; 63
    eb78:	8d bf       	out	0x3d, r24	; 61
    eb7a:	ed b7       	in	r30, 0x3d	; 61
    eb7c:	fe b7       	in	r31, 0x3e	; 62
    eb7e:	31 96       	adiw	r30, 0x01	; 1
    eb80:	ad b7       	in	r26, 0x3d	; 61
    eb82:	be b7       	in	r27, 0x3e	; 62
    eb84:	12 96       	adiw	r26, 0x02	; 2
    eb86:	dc 92       	st	X, r13
    eb88:	ce 92       	st	-X, r12
    eb8a:	11 97       	sbiw	r26, 0x01	; 1
    eb8c:	b3 82       	std	Z+3, r11	; 0x03
    eb8e:	a2 82       	std	Z+2, r10	; 0x02
    eb90:	15 83       	std	Z+5, r17	; 0x05
    eb92:	04 83       	std	Z+4, r16	; 0x04
    eb94:	d7 01       	movw	r26, r14
    eb96:	8c 91       	ld	r24, X
    eb98:	86 83       	std	Z+6, r24	; 0x06
    eb9a:	17 82       	std	Z+7, r1	; 0x07
    eb9c:	0c 5f       	subi	r16, 0xFC	; 252
    eb9e:	1f 4f       	sbci	r17, 0xFF	; 255
    eba0:	11 87       	std	Z+9, r17	; 0x09
    eba2:	00 87       	std	Z+8, r16	; 0x08
    eba4:	04 50       	subi	r16, 0x04	; 4
    eba6:	10 40       	sbci	r17, 0x00	; 0
    eba8:	14 96       	adiw	r26, 0x04	; 4
    ebaa:	8c 91       	ld	r24, X
    ebac:	82 87       	std	Z+10, r24	; 0x0a
    ebae:	13 86       	std	Z+11, r1	; 0x0b
    ebb0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    ebb4:	ed b7       	in	r30, 0x3d	; 61
    ebb6:	fe b7       	in	r31, 0x3e	; 62
    ebb8:	3c 96       	adiw	r30, 0x0c	; 12
    ebba:	0f b6       	in	r0, 0x3f	; 63
    ebbc:	f8 94       	cli
    ebbe:	fe bf       	out	0x3e, r31	; 62
    ebc0:	0f be       	out	0x3f, r0	; 63
    ebc2:	ed bf       	out	0x3d, r30	; 61
    ebc4:	80 2f       	mov	r24, r16
    ebc6:	61 e0       	ldi	r22, 0x01	; 1
    ebc8:	a6 01       	movw	r20, r12
    ebca:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    ebce:	08 94       	sec
    ebd0:	e1 1c       	adc	r14, r1
    ebd2:	f1 1c       	adc	r15, r1
    ebd4:	0f 5f       	subi	r16, 0xFF	; 255
    ebd6:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    ebd8:	f3 ef       	ldi	r31, 0xF3	; 243
    ebda:	ef 16       	cp	r14, r31
    ebdc:	f2 e0       	ldi	r31, 0x02	; 2
    ebde:	ff 06       	cpc	r15, r31
    ebe0:	21 f6       	brne	.-120    	; 0xeb6a <FSettingPumpID+0x1fe>
    ebe2:	2b c0       	rjmp	.+86     	; 0xec3a <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    ebe4:	93 32       	cpi	r25, 0x23	; 35
    ebe6:	21 f5       	brne	.+72     	; 0xec30 <FSettingPumpID+0x2c4>
    ebe8:	40 e0       	ldi	r20, 0x00	; 0
    ebea:	20 e0       	ldi	r18, 0x00	; 0
    ebec:	30 e0       	ldi	r19, 0x00	; 0
    ebee:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    ebf0:	f9 01       	movw	r30, r18
    ebf2:	e1 51       	subi	r30, 0x11	; 17
    ebf4:	fd 4f       	sbci	r31, 0xFD	; 253
    ebf6:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    ebf8:	ee 23       	and	r30, r30
    ebfa:	69 f0       	breq	.+26     	; 0xec16 <FSettingPumpID+0x2aa>
    ebfc:	af ee       	ldi	r26, 0xEF	; 239
    ebfe:	b2 e0       	ldi	r27, 0x02	; 2
    ec00:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    ec02:	59 17       	cp	r21, r25
    ec04:	21 f0       	breq	.+8      	; 0xec0e <FSettingPumpID+0x2a2>
    ec06:	8c 91       	ld	r24, X
    ec08:	e8 17       	cp	r30, r24
    ec0a:	09 f4       	brne	.+2      	; 0xec0e <FSettingPumpID+0x2a2>
						       PumpCount++;
    ec0c:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    ec0e:	9f 5f       	subi	r25, 0xFF	; 255
    ec10:	11 96       	adiw	r26, 0x01	; 1
    ec12:	98 30       	cpi	r25, 0x08	; 8
    ec14:	b1 f7       	brne	.-20     	; 0xec02 <FSettingPumpID+0x296>
    ec16:	2f 5f       	subi	r18, 0xFF	; 255
    ec18:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    ec1a:	28 30       	cpi	r18, 0x08	; 8
    ec1c:	31 05       	cpc	r19, r1
    ec1e:	39 f7       	brne	.-50     	; 0xebee <FSettingPumpID+0x282>
    ec20:	40 93 ed 02 	sts	0x02ED, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    ec24:	44 23       	and	r20, r20
    ec26:	11 f0       	breq	.+4      	; 0xec2c <FSettingPumpID+0x2c0>
    ec28:	83 e0       	ldi	r24, 0x03	; 3
    ec2a:	05 c0       	rjmp	.+10     	; 0xec36 <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    ec2c:	85 e0       	ldi	r24, 0x05	; 5
    ec2e:	03 c0       	rjmp	.+6      	; 0xec36 <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    ec30:	9a 32       	cpi	r25, 0x2A	; 42
    ec32:	19 f4       	brne	.+6      	; 0xec3a <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    ec34:	8a e0       	ldi	r24, 0x0A	; 10
    ec36:	80 93 f9 02 	sts	0x02F9, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    ec3a:	8b e7       	ldi	r24, 0x7B	; 123
    ec3c:	98 16       	cp	r9, r24
    ec3e:	09 f0       	breq	.+2      	; 0xec42 <FSettingPumpID+0x2d6>
    ec40:	2c c1       	rjmp	.+600    	; 0xee9a <FSettingPumpID+0x52e>
		      if (IsShift==False)IsShift=True;
    ec42:	80 91 f8 02 	lds	r24, 0x02F8
    ec46:	88 23       	and	r24, r24
    ec48:	21 f4       	brne	.+8      	; 0xec52 <FSettingPumpID+0x2e6>
    ec4a:	81 e0       	ldi	r24, 0x01	; 1
    ec4c:	80 93 f8 02 	sts	0x02F8, r24
    ec50:	24 c1       	rjmp	.+584    	; 0xee9a <FSettingPumpID+0x52e>
			  else
			  if (IsShift==True)IsShift=False;
    ec52:	81 30       	cpi	r24, 0x01	; 1
    ec54:	09 f0       	breq	.+2      	; 0xec58 <FSettingPumpID+0x2ec>
    ec56:	21 c1       	rjmp	.+578    	; 0xee9a <FSettingPumpID+0x52e>
    ec58:	10 92 f8 02 	sts	0x02F8, r1
    ec5c:	1e c1       	rjmp	.+572    	; 0xee9a <FSettingPumpID+0x52e>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    ec5e:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    ec62:	81 e0       	ldi	r24, 0x01	; 1
    ec64:	61 e0       	ldi	r22, 0x01	; 1
    ec66:	44 e9       	ldi	r20, 0x94	; 148
    ec68:	5d e0       	ldi	r21, 0x0D	; 13
    ec6a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    ec6e:	82 e0       	ldi	r24, 0x02	; 2
    ec70:	61 e0       	ldi	r22, 0x01	; 1
    ec72:	4f e7       	ldi	r20, 0x7F	; 127
    ec74:	5d e0       	ldi	r21, 0x0D	; 13
    ec76:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    ec7a:	83 e0       	ldi	r24, 0x03	; 3
    ec7c:	61 e0       	ldi	r22, 0x01	; 1
    ec7e:	4a e6       	ldi	r20, 0x6A	; 106
    ec80:	5d e0       	ldi	r21, 0x0D	; 13
    ec82:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    ec86:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    ec88:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    ec8a:	82 e0       	ldi	r24, 0x02	; 2
    ec8c:	90 e0       	ldi	r25, 0x00	; 0
    ec8e:	90 93 ed 01 	sts	0x01ED, r25
    ec92:	80 93 ec 01 	sts	0x01EC, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    ec96:	10 92 bc 01 	sts	0x01BC, r1
	      stMenuPumpID=mpDisplayFailed;
    ec9a:	84 e0       	ldi	r24, 0x04	; 4
    ec9c:	e9 c0       	rjmp	.+466    	; 0xee70 <FSettingPumpID+0x504>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    ec9e:	80 91 bc 01 	lds	r24, 0x01BC
    eca2:	87 30       	cpi	r24, 0x07	; 7
    eca4:	08 f4       	brcc	.+2      	; 0xeca8 <FSettingPumpID+0x33c>
    eca6:	f9 c0       	rjmp	.+498    	; 0xee9a <FSettingPumpID+0x52e>
    eca8:	81 e0       	ldi	r24, 0x01	; 1
    ecaa:	e2 c0       	rjmp	.+452    	; 0xee70 <FSettingPumpID+0x504>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    ecac:	85 e4       	ldi	r24, 0x45	; 69
    ecae:	90 e0       	ldi	r25, 0x00	; 0
    ecb0:	6f ee       	ldi	r22, 0xEF	; 239
    ecb2:	72 e0       	ldi	r23, 0x02	; 2
    ecb4:	48 e0       	ldi	r20, 0x08	; 8
    ecb6:	50 e0       	ldi	r21, 0x00	; 0
    ecb8:	2f e9       	ldi	r18, 0x9F	; 159
    ecba:	32 e1       	ldi	r19, 0x12	; 18
    ecbc:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    ecc0:	80 91 25 01 	lds	r24, 0x0125
    ecc4:	82 30       	cpi	r24, 0x02	; 2
    ecc6:	e9 f4       	brne	.+58     	; 0xed02 <FSettingPumpID+0x396>
		      //SendConfig to Slave
			  lcd_clear();
    ecc8:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    eccc:	81 e0       	ldi	r24, 0x01	; 1
    ecce:	61 e0       	ldi	r22, 0x01	; 1
    ecd0:	41 e6       	ldi	r20, 0x61	; 97
    ecd2:	5d e0       	ldi	r21, 0x0D	; 13
    ecd4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    ecd8:	82 e0       	ldi	r24, 0x02	; 2
    ecda:	61 e0       	ldi	r22, 0x01	; 1
    ecdc:	48 e5       	ldi	r20, 0x58	; 88
    ecde:	5d e0       	ldi	r21, 0x0D	; 13
    ece0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
			  Idx=0;
    ece4:	10 92 f7 02 	sts	0x02F7, r1
			  PumpCount=0;
    ece8:	10 92 ed 02 	sts	0x02ED, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ecec:	8f ee       	ldi	r24, 0xEF	; 239
    ecee:	92 e0       	ldi	r25, 0x02	; 2
    ecf0:	65 e4       	ldi	r22, 0x45	; 69
    ecf2:	70 e0       	ldi	r23, 0x00	; 0
    ecf4:	48 e0       	ldi	r20, 0x08	; 8
    ecf6:	50 e0       	ldi	r21, 0x00	; 0
    ecf8:	27 e9       	ldi	r18, 0x97	; 151
    ecfa:	32 e1       	ldi	r19, 0x12	; 18
    ecfc:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
    ed00:	b6 c0       	rjmp	.+364    	; 0xee6e <FSettingPumpID+0x502>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    ed02:	81 30       	cpi	r24, 0x01	; 1
    ed04:	09 f0       	breq	.+2      	; 0xed08 <FSettingPumpID+0x39c>
    ed06:	c9 c0       	rjmp	.+402    	; 0xee9a <FSettingPumpID+0x52e>
    ed08:	ba c0       	rjmp	.+372    	; 0xee7e <FSettingPumpID+0x512>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    ed0a:	10 92 ab 01 	sts	0x01AB, r1
	      if (PPumpId[Idx]!=0){
    ed0e:	90 91 f7 02 	lds	r25, 0x02F7
    ed12:	29 2f       	mov	r18, r25
    ed14:	30 e0       	ldi	r19, 0x00	; 0
    ed16:	f9 01       	movw	r30, r18
    ed18:	e1 51       	subi	r30, 0x11	; 17
    ed1a:	fd 4f       	sbci	r31, 0xFD	; 253
    ed1c:	60 81       	ld	r22, Z
    ed1e:	66 23       	and	r22, r22
    ed20:	81 f0       	breq	.+32     	; 0xed42 <FSettingPumpID+0x3d6>
		      PumpCount++;
    ed22:	80 91 ed 02 	lds	r24, 0x02ED
    ed26:	8f 5f       	subi	r24, 0xFF	; 255
    ed28:	80 93 ed 02 	sts	0x02ED, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    ed2c:	6f 70       	andi	r22, 0x0F	; 15
    ed2e:	74 e0       	ldi	r23, 0x04	; 4
    ed30:	22 0f       	add	r18, r18
    ed32:	33 1f       	adc	r19, r19
    ed34:	7a 95       	dec	r23
    ed36:	e1 f7       	brne	.-8      	; 0xed30 <FSettingPumpID+0x3c4>
    ed38:	62 2b       	or	r22, r18
    ed3a:	60 93 ee 02 	sts	0x02EE, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    ed3e:	8d e1       	ldi	r24, 0x1D	; 29
    ed40:	02 c0       	rjmp	.+4      	; 0xed46 <FSettingPumpID+0x3da>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    ed42:	8e e1       	ldi	r24, 0x1E	; 30
    ed44:	69 2f       	mov	r22, r25
    ed46:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    ed4a:	e0 91 f7 02 	lds	r30, 0x02F7
    ed4e:	f0 e0       	ldi	r31, 0x00	; 0
    ed50:	ad b7       	in	r26, 0x3d	; 61
    ed52:	be b7       	in	r27, 0x3e	; 62
    ed54:	18 97       	sbiw	r26, 0x08	; 8
    ed56:	0f b6       	in	r0, 0x3f	; 63
    ed58:	f8 94       	cli
    ed5a:	be bf       	out	0x3e, r27	; 62
    ed5c:	0f be       	out	0x3f, r0	; 63
    ed5e:	ad bf       	out	0x3d, r26	; 61
    ed60:	2d b7       	in	r18, 0x3d	; 61
    ed62:	3e b7       	in	r19, 0x3e	; 62
    ed64:	2f 5f       	subi	r18, 0xFF	; 255
    ed66:	3f 4f       	sbci	r19, 0xFF	; 255
    ed68:	8e 01       	movw	r16, r28
    ed6a:	0f 5f       	subi	r16, 0xFF	; 255
    ed6c:	1f 4f       	sbci	r17, 0xFF	; 255
    ed6e:	12 96       	adiw	r26, 0x02	; 2
    ed70:	1c 93       	st	X, r17
    ed72:	0e 93       	st	-X, r16
    ed74:	11 97       	sbiw	r26, 0x01	; 1
    ed76:	8a e4       	ldi	r24, 0x4A	; 74
    ed78:	9d e0       	ldi	r25, 0x0D	; 13
    ed7a:	d9 01       	movw	r26, r18
    ed7c:	13 96       	adiw	r26, 0x03	; 3
    ed7e:	9c 93       	st	X, r25
    ed80:	8e 93       	st	-X, r24
    ed82:	12 97       	sbiw	r26, 0x02	; 2
    ed84:	31 96       	adiw	r30, 0x01	; 1
    ed86:	15 96       	adiw	r26, 0x05	; 5
    ed88:	fc 93       	st	X, r31
    ed8a:	ee 93       	st	-X, r30
    ed8c:	14 97       	sbiw	r26, 0x04	; 4
    ed8e:	31 97       	sbiw	r30, 0x01	; 1
    ed90:	e1 51       	subi	r30, 0x11	; 17
    ed92:	fd 4f       	sbci	r31, 0xFD	; 253
    ed94:	80 81       	ld	r24, Z
    ed96:	16 96       	adiw	r26, 0x06	; 6
    ed98:	8c 93       	st	X, r24
    ed9a:	16 97       	sbiw	r26, 0x06	; 6
    ed9c:	17 96       	adiw	r26, 0x07	; 7
    ed9e:	1c 92       	st	X, r1
    eda0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    eda4:	ed b7       	in	r30, 0x3d	; 61
    eda6:	fe b7       	in	r31, 0x3e	; 62
    eda8:	38 96       	adiw	r30, 0x08	; 8
    edaa:	0f b6       	in	r0, 0x3f	; 63
    edac:	f8 94       	cli
    edae:	fe bf       	out	0x3e, r31	; 62
    edb0:	0f be       	out	0x3f, r0	; 63
    edb2:	ed bf       	out	0x3d, r30	; 61
    edb4:	83 e0       	ldi	r24, 0x03	; 3
    edb6:	61 e0       	ldi	r22, 0x01	; 1
    edb8:	a8 01       	movw	r20, r16
    edba:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    edbe:	88 e0       	ldi	r24, 0x08	; 8
    edc0:	57 c0       	rjmp	.+174    	; 0xee70 <FSettingPumpID+0x504>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    edc2:	81 e0       	ldi	r24, 0x01	; 1
    edc4:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    edc8:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		  if (KeyChar=='*'){
    edcc:	8a 32       	cpi	r24, 0x2A	; 42
    edce:	99 f4       	brne	.+38     	; 0xedf6 <FSettingPumpID+0x48a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    edd0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    edd2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    edd4:	82 e0       	ldi	r24, 0x02	; 2
    edd6:	90 e0       	ldi	r25, 0x00	; 0
    edd8:	90 93 ed 01 	sts	0x01ED, r25
    eddc:	80 93 ec 01 	sts	0x01EC, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    ede0:	82 e0       	ldi	r24, 0x02	; 2
    ede2:	61 e0       	ldi	r22, 0x01	; 1
    ede4:	4e e3       	ldi	r20, 0x3E	; 62
    ede6:	5d e0       	ldi	r21, 0x0D	; 13
    ede8:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
			  TimDisplay=0;
    edec:	10 92 bc 01 	sts	0x01BC, r1
		      stMenuPumpID=mpDelayExitPumpId;
    edf0:	89 e0       	ldi	r24, 0x09	; 9
    edf2:	80 93 f9 02 	sts	0x02F9, r24
			  }
          if (IsStandaloneAcknoledge==True){
    edf6:	80 91 ab 01 	lds	r24, 0x01AB
    edfa:	81 30       	cpi	r24, 0x01	; 1
    edfc:	09 f0       	breq	.+2      	; 0xee00 <FSettingPumpID+0x494>
    edfe:	4d c0       	rjmp	.+154    	; 0xee9a <FSettingPumpID+0x52e>
		      Idx++;
    ee00:	80 91 f7 02 	lds	r24, 0x02F7
    ee04:	8f 5f       	subi	r24, 0xFF	; 255
    ee06:	80 93 f7 02 	sts	0x02F7, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    ee0a:	88 30       	cpi	r24, 0x08	; 8
    ee0c:	10 f5       	brcc	.+68     	; 0xee52 <FSettingPumpID+0x4e6>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    ee0e:	20 91 ed 02 	lds	r18, 0x02ED
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ee12:	e1 99       	sbic	0x1c, 1	; 28
    ee14:	fe cf       	rjmp	.-4      	; 0xee12 <FSettingPumpID+0x4a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ee16:	84 e7       	ldi	r24, 0x74	; 116
    ee18:	91 e0       	ldi	r25, 0x01	; 1
    ee1a:	9f bb       	out	0x1f, r25	; 31
    ee1c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    ee1e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    ee20:	0f b6       	in	r0, 0x3f	; 63
    ee22:	f8 94       	cli
    ee24:	e2 9a       	sbi	0x1c, 2	; 28
    ee26:	e1 9a       	sbi	0x1c, 1	; 28
    ee28:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ee2a:	e1 99       	sbic	0x1c, 1	; 28
    ee2c:	fe cf       	rjmp	.-4      	; 0xee2a <FSettingPumpID+0x4be>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ee2e:	9f bb       	out	0x1f, r25	; 31
    ee30:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ee32:	e0 9a       	sbi	0x1c, 0	; 28
    ee34:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    ee36:	90 93 75 01 	sts	0x0175, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ee3a:	85 e1       	ldi	r24, 0x15	; 21
    ee3c:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
    ee40:	90 93 d9 0d 	sts	0x0DD9, r25
     IsControlPooling=True;
    ee44:	81 e0       	ldi	r24, 0x01	; 1
    ee46:	80 93 ad 01 	sts	0x01AD, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    ee4a:	10 92 bc 01 	sts	0x01BC, r1
				  stMenuPumpID=mpDelaySaveConfig;
    ee4e:	87 e0       	ldi	r24, 0x07	; 7
    ee50:	0f c0       	rjmp	.+30     	; 0xee70 <FSettingPumpID+0x504>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    ee52:	82 e0       	ldi	r24, 0x02	; 2
    ee54:	61 e0       	ldi	r22, 0x01	; 1
    ee56:	44 e3       	ldi	r20, 0x34	; 52
    ee58:	5d e0       	ldi	r21, 0x0D	; 13
    ee5a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					TimDisplay=0;
    ee5e:	10 92 bc 01 	sts	0x01BC, r1
				    stMenuPumpID=mpDelayExitPumpId;
    ee62:	89 e0       	ldi	r24, 0x09	; 9
    ee64:	05 c0       	rjmp	.+10     	; 0xee70 <FSettingPumpID+0x504>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    ee66:	80 91 bc 01 	lds	r24, 0x01BC
    ee6a:	83 30       	cpi	r24, 0x03	; 3
    ee6c:	b0 f0       	brcs	.+44     	; 0xee9a <FSettingPumpID+0x52e>
    ee6e:	86 e0       	ldi	r24, 0x06	; 6
    ee70:	80 93 f9 02 	sts	0x02F9, r24
    ee74:	12 c0       	rjmp	.+36     	; 0xee9a <FSettingPumpID+0x52e>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    ee76:	80 91 bc 01 	lds	r24, 0x01BC
    ee7a:	89 30       	cpi	r24, 0x09	; 9
    ee7c:	70 f0       	brcs	.+28     	; 0xee9a <FSettingPumpID+0x52e>
    ee7e:	8a e0       	ldi	r24, 0x0A	; 10
    ee80:	f7 cf       	rjmp	.-18     	; 0xee70 <FSettingPumpID+0x504>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    ee82:	80 91 25 01 	lds	r24, 0x0125
    ee86:	82 30       	cpi	r24, 0x02	; 2
    ee88:	21 f4       	brne	.+8      	; 0xee92 <FSettingPumpID+0x526>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ee8a:	80 e2       	ldi	r24, 0x20	; 32
    ee8c:	60 e0       	ldi	r22, 0x00	; 0
    ee8e:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    ee92:	10 92 f9 02 	sts	0x02F9, r1
    ee96:	81 e0       	ldi	r24, 0x01	; 1
    ee98:	01 c0       	rjmp	.+2      	; 0xee9c <FSettingPumpID+0x530>
    ee9a:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    ee9c:	64 96       	adiw	r28, 0x14	; 20
    ee9e:	0f b6       	in	r0, 0x3f	; 63
    eea0:	f8 94       	cli
    eea2:	de bf       	out	0x3e, r29	; 62
    eea4:	0f be       	out	0x3f, r0	; 63
    eea6:	cd bf       	out	0x3d, r28	; 61
    eea8:	cf 91       	pop	r28
    eeaa:	df 91       	pop	r29
    eeac:	1f 91       	pop	r17
    eeae:	0f 91       	pop	r16
    eeb0:	ff 90       	pop	r15
    eeb2:	ef 90       	pop	r14
    eeb4:	df 90       	pop	r13
    eeb6:	cf 90       	pop	r12
    eeb8:	bf 90       	pop	r11
    eeba:	af 90       	pop	r10
    eebc:	9f 90       	pop	r9
    eebe:	08 95       	ret

0000eec0 <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    eec0:	0e 94 b6 74 	call	0xe96c	; 0xe96c <FSettingPumpID>
    eec4:	81 30       	cpi	r24, 0x01	; 1
    eec6:	e1 f7       	brne	.-8      	; 0xeec0 <_menu_pumpid>
	       break;
	   }	   
	}
}
    eec8:	08 95       	ret

0000eeca <_menu_pump>:
			return 0;
	}
	return 0;
}

void _menu_pump(void){
    eeca:	cf 93       	push	r28
    eecc:	df 93       	push	r29
    eece:	c4 ec       	ldi	r28, 0xC4	; 196
    eed0:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    eed2:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    eed6:	ce 01       	movw	r24, r28
    eed8:	01 97       	sbiw	r24, 0x01	; 1
    eeda:	f1 f7       	brne	.-4      	; 0xeed8 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    eedc:	81 e0       	ldi	r24, 0x01	; 1
    eede:	61 e0       	ldi	r22, 0x01	; 1
    eee0:	48 e6       	ldi	r20, 0x68	; 104
    eee2:	5e e0       	ldi	r21, 0x0E	; 14
    eee4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    eee8:	82 e0       	ldi	r24, 0x02	; 2
    eeea:	61 e0       	ldi	r22, 0x01	; 1
    eeec:	4e e5       	ldi	r20, 0x5E	; 94
    eeee:	5e e0       	ldi	r21, 0x0E	; 14
    eef0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    eef4:	84 e0       	ldi	r24, 0x04	; 4
    eef6:	61 e0       	ldi	r22, 0x01	; 1
    eef8:	47 e5       	ldi	r20, 0x57	; 87
    eefa:	5e e0       	ldi	r21, 0x0E	; 14
    eefc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>

		while(1){
			__key = _key_scan(1);
    ef00:	81 e0       	ldi	r24, 0x01	; 1
    ef02:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
			if(__key == _KEY_CANCEL)
    ef06:	87 3e       	cpi	r24, 0xE7	; 231
    ef08:	51 f0       	breq	.+20     	; 0xef1e <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    ef0a:	8e 3e       	cpi	r24, 0xEE	; 238
    ef0c:	19 f4       	brne	.+6      	; 0xef14 <_menu_pump+0x4a>
				_menu_pumpid();
    ef0e:	0e 94 60 77 	call	0xeec0	; 0xeec0 <_menu_pumpid>
    ef12:	df cf       	rjmp	.-66     	; 0xeed2 <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    ef14:	8e 3d       	cpi	r24, 0xDE	; 222
    ef16:	a1 f7       	brne	.-24     	; 0xef00 <_menu_pump+0x36>
				_menu_pumpprod();
    ef18:	0e 94 a5 47 	call	0x8f4a	; 0x8f4a <_menu_pumpprod>
    ef1c:	da cf       	rjmp	.-76     	; 0xeed2 <_menu_pump+0x8>
				break;
			}
		}
	}
}
    ef1e:	df 91       	pop	r29
    ef20:	cf 91       	pop	r28
    ef22:	08 95       	ret

0000ef24 <FMenuPumpType>:





void FMenuPumpType(){
    ef24:	cf 92       	push	r12
    ef26:	df 92       	push	r13
    ef28:	ef 92       	push	r14
    ef2a:	ff 92       	push	r15
    ef2c:	0f 93       	push	r16
    ef2e:	1f 93       	push	r17
    ef30:	df 93       	push	r29
    ef32:	cf 93       	push	r28
    ef34:	cd b7       	in	r28, 0x3d	; 61
    ef36:	de b7       	in	r29, 0x3e	; 62
    ef38:	a8 97       	sbiw	r28, 0x28	; 40
    ef3a:	0f b6       	in	r0, 0x3f	; 63
    ef3c:	f8 94       	cli
    ef3e:	de bf       	out	0x3e, r29	; 62
    ef40:	0f be       	out	0x3f, r0	; 63
    ef42:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    ef44:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    ef48:	81 e0       	ldi	r24, 0x01	; 1
    ef4a:	61 e0       	ldi	r22, 0x01	; 1
    ef4c:	45 e4       	ldi	r20, 0x45	; 69
    ef4e:	5e e0       	ldi	r21, 0x0E	; 14
    ef50:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ef54:	e1 99       	sbic	0x1c, 1	; 28
    ef56:	fe cf       	rjmp	.-4      	; 0xef54 <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ef58:	87 e6       	ldi	r24, 0x67	; 103
    ef5a:	91 e0       	ldi	r25, 0x01	; 1
    ef5c:	9f bb       	out	0x1f, r25	; 31
    ef5e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ef60:	e0 9a       	sbi	0x1c, 0	; 28
    ef62:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    ef64:	03 30       	cpi	r16, 0x03	; 3
    ef66:	08 f0       	brcs	.+2      	; 0xef6a <FMenuPumpType+0x46>
    ef68:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    ef6a:	10 e0       	ldi	r17, 0x00	; 0
    ef6c:	f8 01       	movw	r30, r16
    ef6e:	ee 0f       	add	r30, r30
    ef70:	ff 1f       	adc	r31, r31
    ef72:	e3 55       	subi	r30, 0x53	; 83
    ef74:	fc 4f       	sbci	r31, 0xFC	; 252
    ef76:	65 91       	lpm	r22, Z+
    ef78:	74 91       	lpm	r23, Z+
    ef7a:	85 e1       	ldi	r24, 0x15	; 21
    ef7c:	c8 2e       	mov	r12, r24
    ef7e:	d1 2c       	mov	r13, r1
    ef80:	cc 0e       	add	r12, r28
    ef82:	dd 1e       	adc	r13, r29
    ef84:	c6 01       	movw	r24, r12
    ef86:	0e 94 bd b5 	call	0x16b7a	; 0x16b7a <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    ef8a:	8d b7       	in	r24, 0x3d	; 61
    ef8c:	9e b7       	in	r25, 0x3e	; 62
    ef8e:	08 97       	sbiw	r24, 0x08	; 8
    ef90:	0f b6       	in	r0, 0x3f	; 63
    ef92:	f8 94       	cli
    ef94:	9e bf       	out	0x3e, r25	; 62
    ef96:	0f be       	out	0x3f, r0	; 63
    ef98:	8d bf       	out	0x3d, r24	; 61
    ef9a:	ed b7       	in	r30, 0x3d	; 61
    ef9c:	fe b7       	in	r31, 0x3e	; 62
    ef9e:	31 96       	adiw	r30, 0x01	; 1
    efa0:	7e 01       	movw	r14, r28
    efa2:	08 94       	sec
    efa4:	e1 1c       	adc	r14, r1
    efa6:	f1 1c       	adc	r15, r1
    efa8:	ad b7       	in	r26, 0x3d	; 61
    efaa:	be b7       	in	r27, 0x3e	; 62
    efac:	12 96       	adiw	r26, 0x02	; 2
    efae:	fc 92       	st	X, r15
    efb0:	ee 92       	st	-X, r14
    efb2:	11 97       	sbiw	r26, 0x01	; 1
    efb4:	8f e3       	ldi	r24, 0x3F	; 63
    efb6:	9e e0       	ldi	r25, 0x0E	; 14
    efb8:	93 83       	std	Z+3, r25	; 0x03
    efba:	82 83       	std	Z+2, r24	; 0x02
    efbc:	0f 5f       	subi	r16, 0xFF	; 255
    efbe:	1f 4f       	sbci	r17, 0xFF	; 255
    efc0:	15 83       	std	Z+5, r17	; 0x05
    efc2:	04 83       	std	Z+4, r16	; 0x04
    efc4:	d7 82       	std	Z+7, r13	; 0x07
    efc6:	c6 82       	std	Z+6, r12	; 0x06
    efc8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			   lcd_print(2,1,lcdteks);
    efcc:	8d b7       	in	r24, 0x3d	; 61
    efce:	9e b7       	in	r25, 0x3e	; 62
    efd0:	08 96       	adiw	r24, 0x08	; 8
    efd2:	0f b6       	in	r0, 0x3f	; 63
    efd4:	f8 94       	cli
    efd6:	9e bf       	out	0x3e, r25	; 62
    efd8:	0f be       	out	0x3f, r0	; 63
    efda:	8d bf       	out	0x3d, r24	; 61
    efdc:	82 e0       	ldi	r24, 0x02	; 2
    efde:	61 e0       	ldi	r22, 0x01	; 1
    efe0:	a7 01       	movw	r20, r14
    efe2:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    efe6:	84 e0       	ldi	r24, 0x04	; 4
    efe8:	61 e0       	ldi	r22, 0x01	; 1
    efea:	4b e2       	ldi	r20, 0x2B	; 43
    efec:	5e e0       	ldi	r21, 0x0E	; 14
    efee:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
			   if (IFType==IT_STANDALONE)
    eff2:	80 91 25 01 	lds	r24, 0x0125
    eff6:	82 30       	cpi	r24, 0x02	; 2
    eff8:	21 f4       	brne	.+8      	; 0xf002 <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    effa:	8f e1       	ldi	r24, 0x1F	; 31
    effc:	60 e0       	ldi	r22, 0x00	; 0
    effe:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    f002:	81 e0       	ldi	r24, 0x01	; 1
    f004:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    f008:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>

			   if (KeyChar=='#'){
    f00c:	83 32       	cpi	r24, 0x23	; 35
    f00e:	09 f0       	breq	.+2      	; 0xf012 <FMenuPumpType+0xee>
    f010:	2d c0       	rjmp	.+90     	; 0xf06c <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f012:	e1 99       	sbic	0x1c, 1	; 28
    f014:	fe cf       	rjmp	.-4      	; 0xf012 <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f016:	07 e6       	ldi	r16, 0x67	; 103
    f018:	11 e0       	ldi	r17, 0x01	; 1
    f01a:	1f bb       	out	0x1f, r17	; 31
    f01c:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f01e:	e0 9a       	sbi	0x1c, 0	; 28
    f020:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    f022:	82 30       	cpi	r24, 0x02	; 2
    f024:	20 f4       	brcc	.+8      	; 0xf02e <FMenuPumpType+0x10a>
				        DispenserBrand++;
    f026:	8f 5f       	subi	r24, 0xFF	; 255
    f028:	80 93 77 01 	sts	0x0177, r24
    f02c:	02 c0       	rjmp	.+4      	; 0xf032 <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    f02e:	10 92 77 01 	sts	0x0177, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    f032:	80 91 77 01 	lds	r24, 0x0177
    f036:	0e 94 12 1a 	call	0x3424	; 0x3424 <SetDispenser>

			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    f03a:	80 91 77 01 	lds	r24, 0x0177
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f03e:	e1 99       	sbic	0x1c, 1	; 28
    f040:	fe cf       	rjmp	.-4      	; 0xf03e <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f042:	1f bb       	out	0x1f, r17	; 31
    f044:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    f046:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f048:	0f b6       	in	r0, 0x3f	; 63
    f04a:	f8 94       	cli
    f04c:	e2 9a       	sbi	0x1c, 2	; 28
    f04e:	e1 9a       	sbi	0x1c, 1	; 28
    f050:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f052:	e1 99       	sbic	0x1c, 1	; 28
    f054:	fe cf       	rjmp	.-4      	; 0xf052 <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f056:	1f bb       	out	0x1f, r17	; 31
    f058:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f05a:	e0 9a       	sbi	0x1c, 0	; 28
    f05c:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    f05e:	8c e1       	ldi	r24, 0x1C	; 28
    f060:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    f064:	81 e0       	ldi	r24, 0x01	; 1
    f066:	80 93 38 01 	sts	0x0138, r24
    f06a:	0c c0       	rjmp	.+24     	; 0xf084 <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    f06c:	8a 32       	cpi	r24, 0x2A	; 42
    f06e:	09 f0       	breq	.+2      	; 0xf072 <FMenuPumpType+0x14e>
    f070:	c8 cf       	rjmp	.-112    	; 0xf002 <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    f072:	80 91 25 01 	lds	r24, 0x0125
    f076:	82 30       	cpi	r24, 0x02	; 2
    f078:	51 f4       	brne	.+20     	; 0xf08e <FMenuPumpType+0x16a>
    f07a:	80 e2       	ldi	r24, 0x20	; 32
    f07c:	60 e0       	ldi	r22, 0x00	; 0
    f07e:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
    f082:	05 c0       	rjmp	.+10     	; 0xf08e <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    f084:	80 91 38 01 	lds	r24, 0x0138
    f088:	81 30       	cpi	r24, 0x01	; 1
    f08a:	e1 f7       	brne	.-8      	; 0xf084 <FMenuPumpType+0x160>
    f08c:	5b cf       	rjmp	.-330    	; 0xef44 <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    f08e:	a8 96       	adiw	r28, 0x28	; 40
    f090:	0f b6       	in	r0, 0x3f	; 63
    f092:	f8 94       	cli
    f094:	de bf       	out	0x3e, r29	; 62
    f096:	0f be       	out	0x3f, r0	; 63
    f098:	cd bf       	out	0x3d, r28	; 61
    f09a:	cf 91       	pop	r28
    f09c:	df 91       	pop	r29
    f09e:	1f 91       	pop	r17
    f0a0:	0f 91       	pop	r16
    f0a2:	ff 90       	pop	r15
    f0a4:	ef 90       	pop	r14
    f0a6:	df 90       	pop	r13
    f0a8:	cf 90       	pop	r12
    f0aa:	08 95       	ret

0000f0ac <FSettingPump>:
   return Result;
}

char FSettingPump(){
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    f0ac:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
    f0b0:	84 ec       	ldi	r24, 0xC4	; 196
    f0b2:	99 e0       	ldi	r25, 0x09	; 9
    f0b4:	01 97       	sbiw	r24, 0x01	; 1
    f0b6:	f1 f7       	brne	.-4      	; 0xf0b4 <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    f0b8:	81 e0       	ldi	r24, 0x01	; 1
    f0ba:	61 e0       	ldi	r22, 0x01	; 1
    f0bc:	49 e3       	ldi	r20, 0x39	; 57
    f0be:	50 e1       	ldi	r21, 0x10	; 16
    f0c0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    f0c4:	82 e0       	ldi	r24, 0x02	; 2
    f0c6:	61 e0       	ldi	r22, 0x01	; 1
    f0c8:	4f e2       	ldi	r20, 0x2F	; 47
    f0ca:	50 e1       	ldi	r21, 0x10	; 16
    f0cc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		if (IFType==IT_STANDALONE){
    f0d0:	80 91 25 01 	lds	r24, 0x0125
    f0d4:	82 30       	cpi	r24, 0x02	; 2
    f0d6:	61 f4       	brne	.+24     	; 0xf0f0 <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    f0d8:	83 e0       	ldi	r24, 0x03	; 3
    f0da:	61 e0       	ldi	r22, 0x01	; 1
    f0dc:	45 e2       	ldi	r20, 0x25	; 37
    f0de:	50 e1       	ldi	r21, 0x10	; 16
    f0e0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    f0e4:	84 e0       	ldi	r24, 0x04	; 4
    f0e6:	61 e0       	ldi	r22, 0x01	; 1
    f0e8:	45 e1       	ldi	r20, 0x15	; 21
    f0ea:	50 e1       	ldi	r21, 0x10	; 16
    f0ec:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    f0f0:	81 e0       	ldi	r24, 0x01	; 1
    f0f2:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
			if(__key == _KEY_CANCEL)
    f0f6:	87 3e       	cpi	r24, 0xE7	; 231
    f0f8:	d9 f0       	breq	.+54     	; 0xf130 <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    f0fa:	8e 3e       	cpi	r24, 0xEE	; 238
    f0fc:	19 f4       	brne	.+6      	; 0xf104 <FSettingPump+0x58>
				_menu_pumpid();
    f0fe:	0e 94 60 77 	call	0xeec0	; 0xeec0 <_menu_pumpid>
    f102:	16 c0       	rjmp	.+44     	; 0xf130 <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    f104:	8e 3d       	cpi	r24, 0xDE	; 222
    f106:	19 f4       	brne	.+6      	; 0xf10e <FSettingPump+0x62>
				_menu_pumpprod();
    f108:	0e 94 a5 47 	call	0x8f4a	; 0x8f4a <_menu_pumpprod>
    f10c:	11 c0       	rjmp	.+34     	; 0xf130 <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    f10e:	8e 3b       	cpi	r24, 0xBE	; 190
    f110:	39 f4       	brne	.+14     	; 0xf120 <FSettingPump+0x74>
    f112:	80 91 25 01 	lds	r24, 0x0125
    f116:	82 30       	cpi	r24, 0x02	; 2
    f118:	59 f7       	brne	.-42     	; 0xf0f0 <FSettingPump+0x44>
			    FMenuPumpLabel();
    f11a:	0e 94 ce 47 	call	0x8f9c	; 0x8f9c <FMenuPumpLabel>
    f11e:	08 c0       	rjmp	.+16     	; 0xf130 <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    f120:	8d 3e       	cpi	r24, 0xED	; 237
    f122:	31 f7       	brne	.-52     	; 0xf0f0 <FSettingPump+0x44>
    f124:	80 91 25 01 	lds	r24, 0x0125
    f128:	82 30       	cpi	r24, 0x02	; 2
    f12a:	11 f7       	brne	.-60     	; 0xf0f0 <FSettingPump+0x44>
			    FMenuPumpType();
    f12c:	0e 94 92 77 	call	0xef24	; 0xef24 <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    f130:	81 e0       	ldi	r24, 0x01	; 1
    f132:	08 95       	ret

0000f134 <InitStandalone>:
stInitStandalone=isSendType;

while (RunInitStandalone==True){
     switch(stInitStandalone){
	 case isSendType:
	      IsStandaloneAcknoledge=False;
    f134:	10 92 ab 01 	sts	0x01AB, r1
          SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f138:	82 e0       	ldi	r24, 0x02	; 2
    f13a:	60 91 77 01 	lds	r22, 0x0177
    f13e:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
		  TimSend=0;
    f142:	10 92 be 01 	sts	0x01BE, r1
    f146:	10 92 bd 01 	sts	0x01BD, r1
		  stInitStandalone=isWaitAcknoledge1;
	      break;
     case isWaitAcknoledge1:
          if (IsStandaloneAcknoledge==True){
    f14a:	80 91 ab 01 	lds	r24, 0x01AB
    f14e:	81 30       	cpi	r24, 0x01	; 1
    f150:	11 f4       	brne	.+4      	; 0xf156 <InitStandalone+0x22>
		      IsStandaloneAcknoledge=False;
    f152:	10 92 ab 01 	sts	0x01AB, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f156:	e1 99       	sbic	0x1c, 1	; 28
    f158:	fe cf       	rjmp	.-4      	; 0xf156 <InitStandalone+0x22>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f15a:	84 e7       	ldi	r24, 0x74	; 116
    f15c:	91 e0       	ldi	r25, 0x01	; 1
    f15e:	9f bb       	out	0x1f, r25	; 31
    f160:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f162:	e0 9a       	sbi	0x1c, 0	; 28
    f164:	6d b3       	in	r22, 0x1d	; 29
		      stInitStandalone=isSendPumpConfig;
		  }
     case isSendPumpConfig:
          SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));
    f166:	85 e1       	ldi	r24, 0x15	; 21
    f168:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
		  TimSend=0;
    f16c:	10 92 be 01 	sts	0x01BE, r1
    f170:	10 92 bd 01 	sts	0x01BD, r1
		  stInitStandalone=isWaitAcknoledge2;
	      break;
     case isWaitAcknoledge2:
          if (IsStandaloneAcknoledge==True){
    f174:	80 91 ab 01 	lds	r24, 0x01AB
    f178:	81 30       	cpi	r24, 0x01	; 1
    f17a:	e1 f7       	brne	.-8      	; 0xf174 <InitStandalone+0x40>
		      IsStandaloneAcknoledge=False;
    f17c:	10 92 ab 01 	sts	0x01AB, r1
     case isFinishInitStandalone:
	      RunInitStandalone=False;
	      break;
	 }
  }
}
    f180:	08 95       	ret

0000f182 <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
    f182:	af 92       	push	r10
    f184:	bf 92       	push	r11
    f186:	cf 92       	push	r12
    f188:	df 92       	push	r13
    f18a:	ef 92       	push	r14
    f18c:	ff 92       	push	r15
    f18e:	0f 93       	push	r16
    f190:	1f 93       	push	r17
    f192:	df 93       	push	r29
    f194:	cf 93       	push	r28
    f196:	cd b7       	in	r28, 0x3d	; 61
    f198:	de b7       	in	r29, 0x3e	; 62
    f19a:	64 97       	sbiw	r28, 0x14	; 20
    f19c:	0f b6       	in	r0, 0x3f	; 63
    f19e:	f8 94       	cli
    f1a0:	de bf       	out	0x3e, r29	; 62
    f1a2:	0f be       	out	0x3f, r0	; 63
    f1a4:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f1a6:	e1 99       	sbic	0x1c, 1	; 28
    f1a8:	fe cf       	rjmp	.-4      	; 0xf1a6 <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f1aa:	46 e6       	ldi	r20, 0x66	; 102
    f1ac:	a4 2e       	mov	r10, r20
    f1ae:	41 e0       	ldi	r20, 0x01	; 1
    f1b0:	b4 2e       	mov	r11, r20
    f1b2:	bf ba       	out	0x1f, r11	; 31
    f1b4:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f1b6:	e0 9a       	sbi	0x1c, 0	; 28
    f1b8:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
    f1ba:	90 93 25 01 	sts	0x0125, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f1be:	e1 99       	sbic	0x1c, 1	; 28
    f1c0:	fe cf       	rjmp	.-4      	; 0xf1be <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f1c2:	37 e6       	ldi	r19, 0x67	; 103
    f1c4:	c3 2e       	mov	r12, r19
    f1c6:	31 e0       	ldi	r19, 0x01	; 1
    f1c8:	d3 2e       	mov	r13, r19
    f1ca:	df ba       	out	0x1f, r13	; 31
    f1cc:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f1ce:	e0 9a       	sbi	0x1c, 0	; 28
    f1d0:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    f1d2:	80 93 77 01 	sts	0x0177, r24

    //Send Msg10
	if  (IFType==IT_SLAVE){
    f1d6:	91 30       	cpi	r25, 0x01	; 1
    f1d8:	09 f0       	breq	.+2      	; 0xf1dc <InitializeConnection+0x5a>
    f1da:	4d c0       	rjmp	.+154    	; 0xf276 <InitializeConnection+0xf4>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
    f1dc:	81 e0       	ldi	r24, 0x01	; 1
    f1de:	60 e0       	ldi	r22, 0x00	; 0
    f1e0:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
		 char_count=0;
    f1e4:	10 92 b2 01 	sts	0x01B2, r1
    f1e8:	10 92 b1 01 	sts	0x01B1, r1
         sendMessage10();
    f1ec:	0e 94 81 52 	call	0xa502	; 0xa502 <sendMessage10>
         lcd_printf(4,1,PSTR("Connect         "));
    f1f0:	84 e0       	ldi	r24, 0x04	; 4
    f1f2:	61 e0       	ldi	r22, 0x01	; 1
    f1f4:	48 ec       	ldi	r20, 0xC8	; 200
    f1f6:	5b e1       	ldi	r21, 0x1B	; 27
    f1f8:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
    f1fc:	84 e0       	ldi	r24, 0x04	; 4
    f1fe:	61 e0       	ldi	r22, 0x01	; 1
    f200:	40 ec       	ldi	r20, 0xC0	; 192
    f202:	5b e1       	ldi	r21, 0x1B	; 27
    f204:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
    f208:	10 92 cd 01 	sts	0x01CD, r1
    f20c:	ee 24       	eor	r14, r14
    f20e:	ff 24       	eor	r15, r15
    f210:	10 e0       	ldi	r17, 0x00	; 0
    f212:	00 e0       	ldi	r16, 0x00	; 0
    f214:	2c c0       	rjmp	.+88     	; 0xf26e <InitializeConnection+0xec>
		  //SlaveIdentification
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
    f216:	61 2f       	mov	r22, r17
    f218:	68 5f       	subi	r22, 0xF8	; 248
    f21a:	84 e0       	ldi	r24, 0x04	; 4
    f21c:	4e e2       	ldi	r20, 0x2E	; 46
    f21e:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
                tConnect++;
    f222:	08 94       	sec
    f224:	e1 1c       	adc	r14, r1
    f226:	f1 1c       	adc	r15, r1
			    if ((tConnect%400)==0)iCon++;
    f228:	c7 01       	movw	r24, r14
    f22a:	60 e9       	ldi	r22, 0x90	; 144
    f22c:	71 e0       	ldi	r23, 0x01	; 1
    f22e:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    f232:	89 2b       	or	r24, r25
    f234:	09 f4       	brne	.+2      	; 0xf238 <InitializeConnection+0xb6>
    f236:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>5){
    f238:	16 30       	cpi	r17, 0x06	; 6
    f23a:	70 f0       	brcs	.+28     	; 0xf258 <InitializeConnection+0xd6>
			        lcd_printf(4,1,PSTR("Connect         "));
    f23c:	84 e0       	ldi	r24, 0x04	; 4
    f23e:	61 e0       	ldi	r22, 0x01	; 1
    f240:	4f ea       	ldi	r20, 0xAF	; 175
    f242:	5b e1       	ldi	r21, 0x1B	; 27
    f244:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				    sendMessage10();
    f248:	0e 94 81 52 	call	0xa502	; 0xa502 <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
    f24c:	81 e0       	ldi	r24, 0x01	; 1
    f24e:	60 e0       	ldi	r22, 0x00	; 0
    f250:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
    f254:	0f 5f       	subi	r16, 0xFF	; 255
    f256:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
    f258:	04 30       	cpi	r16, 0x04	; 4
    f25a:	48 f0       	brcs	.+18     	; 0xf26e <InitializeConnection+0xec>
			        IsErrorTCPIP=True;
    f25c:	81 e0       	ldi	r24, 0x01	; 1
    f25e:	80 93 ca 01 	sts	0x01CA, r24
				    IsAdvanzStartupInfo=False;		
    f262:	10 92 d7 01 	sts	0x01D7, r1
					IFType=IT_STANDALONE;
    f266:	82 e0       	ldi	r24, 0x02	; 2
    f268:	80 93 25 01 	sts	0x0125, r24
    f26c:	04 c0       	rjmp	.+8      	; 0xf276 <InitializeConnection+0xf4>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification
		 while (IsMessage11==False){
    f26e:	80 91 cd 01 	lds	r24, 0x01CD
    f272:	88 23       	and	r24, r24
    f274:	81 f2       	breq	.-96     	; 0xf216 <InitializeConnection+0x94>
				    break;
			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
    f276:	80 91 25 01 	lds	r24, 0x0125
    f27a:	82 30       	cpi	r24, 0x02	; 2
    f27c:	09 f0       	breq	.+2      	; 0xf280 <InitializeConnection+0xfe>
    f27e:	72 c0       	rjmp	.+228    	; 0xf364 <InitializeConnection+0x1e2>
        IsStandAloneDetected=False;		
    f280:	10 92 c8 01 	sts	0x01C8, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f284:	60 91 77 01 	lds	r22, 0x0177
    f288:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
    f28c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
    f290:	81 e0       	ldi	r24, 0x01	; 1
    f292:	61 e0       	ldi	r22, 0x01	; 1
    f294:	45 ea       	ldi	r20, 0xA5	; 165
    f296:	5b e1       	ldi	r21, 0x1B	; 27
    f298:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f29c:	e1 99       	sbic	0x1c, 1	; 28
    f29e:	fe cf       	rjmp	.-4      	; 0xf29c <InitializeConnection+0x11a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f2a0:	df ba       	out	0x1f, r13	; 31
    f2a2:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f2a4:	e0 9a       	sbi	0x1c, 0	; 28
    f2a6:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
    f2a8:	e8 2f       	mov	r30, r24
    f2aa:	f0 e0       	ldi	r31, 0x00	; 0
    f2ac:	ee 0f       	add	r30, r30
    f2ae:	ff 1f       	adc	r31, r31
    f2b0:	e3 55       	subi	r30, 0x53	; 83
    f2b2:	fc 4f       	sbci	r31, 0xFC	; 252
    f2b4:	65 91       	lpm	r22, Z+
    f2b6:	74 91       	lpm	r23, Z+
    f2b8:	8e 01       	movw	r16, r28
    f2ba:	0f 5f       	subi	r16, 0xFF	; 255
    f2bc:	1f 4f       	sbci	r17, 0xFF	; 255
    f2be:	c8 01       	movw	r24, r16
    f2c0:	0e 94 bd b5 	call	0x16b7a	; 0x16b7a <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
    f2c4:	00 d0       	rcall	.+0      	; 0xf2c6 <InitializeConnection+0x144>
    f2c6:	00 d0       	rcall	.+0      	; 0xf2c8 <InitializeConnection+0x146>
    f2c8:	00 d0       	rcall	.+0      	; 0xf2ca <InitializeConnection+0x148>
    f2ca:	ed b7       	in	r30, 0x3d	; 61
    f2cc:	fe b7       	in	r31, 0x3e	; 62
    f2ce:	31 96       	adiw	r30, 0x01	; 1
    f2d0:	ad b7       	in	r26, 0x3d	; 61
    f2d2:	be b7       	in	r27, 0x3e	; 62
    f2d4:	12 96       	adiw	r26, 0x02	; 2
    f2d6:	1c 93       	st	X, r17
    f2d8:	0e 93       	st	-X, r16
    f2da:	11 97       	sbiw	r26, 0x01	; 1
    f2dc:	82 ea       	ldi	r24, 0xA2	; 162
    f2de:	9b e1       	ldi	r25, 0x1B	; 27
    f2e0:	93 83       	std	Z+3, r25	; 0x03
    f2e2:	82 83       	std	Z+2, r24	; 0x02
    f2e4:	15 83       	std	Z+5, r17	; 0x05
    f2e6:	04 83       	std	Z+4, r16	; 0x04
    f2e8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	    lcd_print(2,1,lcdteks);
    f2ec:	8d b7       	in	r24, 0x3d	; 61
    f2ee:	9e b7       	in	r25, 0x3e	; 62
    f2f0:	06 96       	adiw	r24, 0x06	; 6
    f2f2:	0f b6       	in	r0, 0x3f	; 63
    f2f4:	f8 94       	cli
    f2f6:	9e bf       	out	0x3e, r25	; 62
    f2f8:	0f be       	out	0x3f, r0	; 63
    f2fa:	8d bf       	out	0x3d, r24	; 61
    f2fc:	82 e0       	ldi	r24, 0x02	; 2
    f2fe:	61 e0       	ldi	r22, 0x01	; 1
    f300:	a8 01       	movw	r20, r16
    f302:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
    f306:	00 e0       	ldi	r16, 0x00	; 0
    f308:	10 e0       	ldi	r17, 0x00	; 0
    f30a:	ff 24       	eor	r15, r15
    f30c:	dd 24       	eor	r13, r13
    f30e:	26 c0       	rjmp	.+76     	; 0xf35c <InitializeConnection+0x1da>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
    f310:	ef 2c       	mov	r14, r15
    f312:	e3 94       	inc	r14
    f314:	84 e0       	ldi	r24, 0x04	; 4
    f316:	6e 2d       	mov	r22, r14
    f318:	4e e2       	ldi	r20, 0x2E	; 46
    f31a:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
		       tConnect++;
    f31e:	0f 5f       	subi	r16, 0xFF	; 255
    f320:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
    f322:	c8 01       	movw	r24, r16
    f324:	64 e6       	ldi	r22, 0x64	; 100
    f326:	70 e0       	ldi	r23, 0x00	; 0
    f328:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    f32c:	89 2b       	or	r24, r25
    f32e:	09 f4       	brne	.+2      	; 0xf332 <InitializeConnection+0x1b0>
    f330:	fe 2c       	mov	r15, r14
		       if (iCon>16){
    f332:	90 e1       	ldi	r25, 0x10	; 16
    f334:	9f 15       	cp	r25, r15
    f336:	78 f4       	brcc	.+30     	; 0xf356 <InitializeConnection+0x1d4>
			       lcd_printf(4,1,PSTR("                   "));
    f338:	84 e0       	ldi	r24, 0x04	; 4
    f33a:	61 e0       	ldi	r22, 0x01	; 1
    f33c:	4e e8       	ldi	r20, 0x8E	; 142
    f33e:	5b e1       	ldi	r21, 0x1B	; 27
    f340:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f344:	82 e0       	ldi	r24, 0x02	; 2
    f346:	60 91 77 01 	lds	r22, 0x0177
    f34a:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
    f34e:	0e 94 16 41 	call	0x822c	; 0x822c <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
    f352:	d3 94       	inc	r13
    f354:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
    f356:	a3 e0       	ldi	r26, 0x03	; 3
    f358:	ad 15       	cp	r26, r13
    f35a:	20 f0       	brcs	.+8      	; 0xf364 <InitializeConnection+0x1e2>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
    f35c:	80 91 c8 01 	lds	r24, 0x01C8
    f360:	88 23       	and	r24, r24
    f362:	b1 f2       	breq	.-84     	; 0xf310 <InitializeConnection+0x18e>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
    f364:	80 91 cd 01 	lds	r24, 0x01CD
    f368:	81 30       	cpi	r24, 0x01	; 1
    f36a:	c9 f4       	brne	.+50     	; 0xf39e <InitializeConnection+0x21c>
	   lcd_printf(4,1,PSTR("Connected"));
    f36c:	84 e0       	ldi	r24, 0x04	; 4
    f36e:	61 e0       	ldi	r22, 0x01	; 1
    f370:	44 e8       	ldi	r20, 0x84	; 132
    f372:	5b e1       	ldi	r21, 0x1B	; 27
    f374:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f378:	e1 99       	sbic	0x1c, 1	; 28
    f37a:	fe cf       	rjmp	.-4      	; 0xf378 <InitializeConnection+0x1f6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f37c:	bf ba       	out	0x1f, r11	; 31
    f37e:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f380:	11 e0       	ldi	r17, 0x01	; 1
    f382:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    f384:	0f b6       	in	r0, 0x3f	; 63
    f386:	f8 94       	cli
    f388:	e2 9a       	sbi	0x1c, 2	; 28
    f38a:	e1 9a       	sbi	0x1c, 1	; 28
    f38c:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
    f38e:	10 93 25 01 	sts	0x0125, r17
	   IsErrorTCPIP=False;
    f392:	10 92 ca 01 	sts	0x01CA, r1
	   procMessage11();
    f396:	0e 94 09 5d 	call	0xba12	; 0xba12 <procMessage11>
	   IsAdvanzStartupInfo=True;
    f39a:	10 93 d7 01 	sts	0x01D7, r17
	}
	if(IsStandAloneDetected==True){
    f39e:	80 91 c8 01 	lds	r24, 0x01C8
    f3a2:	81 30       	cpi	r24, 0x01	; 1
    f3a4:	99 f4       	brne	.+38     	; 0xf3cc <InitializeConnection+0x24a>
	   lcd_printf(4,1,PSTR("PumpFound"));
    f3a6:	84 e0       	ldi	r24, 0x04	; 4
    f3a8:	61 e0       	ldi	r22, 0x01	; 1
    f3aa:	4a e7       	ldi	r20, 0x7A	; 122
    f3ac:	5b e1       	ldi	r21, 0x1B	; 27
    f3ae:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f3b2:	e1 99       	sbic	0x1c, 1	; 28
    f3b4:	fe cf       	rjmp	.-4      	; 0xf3b2 <InitializeConnection+0x230>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f3b6:	bf ba       	out	0x1f, r11	; 31
    f3b8:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f3ba:	82 e0       	ldi	r24, 0x02	; 2
    f3bc:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f3be:	0f b6       	in	r0, 0x3f	; 63
    f3c0:	f8 94       	cli
    f3c2:	e2 9a       	sbi	0x1c, 2	; 28
    f3c4:	e1 9a       	sbi	0x1c, 1	; 28
    f3c6:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
    f3c8:	80 93 25 01 	sts	0x0125, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f3cc:	e1 99       	sbic	0x1c, 1	; 28
    f3ce:	fe cf       	rjmp	.-4      	; 0xf3cc <InitializeConnection+0x24a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f3d0:	85 e6       	ldi	r24, 0x65	; 101
    f3d2:	91 e0       	ldi	r25, 0x01	; 1
    f3d4:	9f bb       	out	0x1f, r25	; 31
    f3d6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f3d8:	e0 9a       	sbi	0x1c, 0	; 28
    f3da:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
    f3dc:	81 30       	cpi	r24, 0x01	; 1
    f3de:	11 f4       	brne	.+4      	; 0xf3e4 <InitializeConnection+0x262>
    f3e0:	0e 94 7a 2f 	call	0x5ef4	; 0x5ef4 <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
    f3e4:	80 91 c8 01 	lds	r24, 0x01C8
    f3e8:	88 23       	and	r24, r24
    f3ea:	09 f0       	breq	.+2      	; 0xf3ee <InitializeConnection+0x26c>
    f3ec:	38 c0       	rjmp	.+112    	; 0xf45e <InitializeConnection+0x2dc>
    f3ee:	80 91 cd 01 	lds	r24, 0x01CD
    f3f2:	88 23       	and	r24, r24
    f3f4:	09 f0       	breq	.+2      	; 0xf3f8 <InitializeConnection+0x276>
    f3f6:	33 c0       	rjmp	.+102    	; 0xf45e <InitializeConnection+0x2dc>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
    f3f8:	82 e0       	ldi	r24, 0x02	; 2
    f3fa:	61 e0       	ldi	r22, 0x01	; 1
    f3fc:	4d e6       	ldi	r20, 0x6D	; 109
    f3fe:	5b e1       	ldi	r21, 0x1B	; 27
    f400:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
    f404:	83 e0       	ldi	r24, 0x03	; 3
    f406:	61 e0       	ldi	r22, 0x01	; 1
    f408:	4f e5       	ldi	r20, 0x5F	; 95
    f40a:	5b e1       	ldi	r21, 0x1B	; 27
    f40c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
    f410:	80 e2       	ldi	r24, 0x20	; 32
    f412:	9e e4       	ldi	r25, 0x4E	; 78
    f414:	29 e1       	ldi	r18, 0x19	; 25
    f416:	30 e0       	ldi	r19, 0x00	; 0
    f418:	f9 01       	movw	r30, r18
    f41a:	31 97       	sbiw	r30, 0x01	; 1
    f41c:	f1 f7       	brne	.-4      	; 0xf41a <InitializeConnection+0x298>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    f41e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    f420:	d9 f7       	brne	.-10     	; 0xf418 <InitializeConnection+0x296>
		 _delay_ms(2000);
		 ForceType=systemForceType();
    f422:	0e 94 73 44 	call	0x88e6	; 0x88e6 <systemForceType>
		 if (ForceType=='1'){
    f426:	81 33       	cpi	r24, 0x31	; 49
    f428:	29 f4       	brne	.+10     	; 0xf434 <InitializeConnection+0x2b2>
		     IFType=IT_SLAVE;
    f42a:	81 e0       	ldi	r24, 0x01	; 1
    f42c:	80 93 25 01 	sts	0x0125, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
    f430:	60 e0       	ldi	r22, 0x00	; 0
    f432:	07 c0       	rjmp	.+14     	; 0xf442 <InitializeConnection+0x2c0>
         }
		 else
		 if (ForceType=='2'){
    f434:	82 33       	cpi	r24, 0x32	; 50
    f436:	39 f4       	brne	.+14     	; 0xf446 <InitializeConnection+0x2c4>
		     IFType=IT_STANDALONE;
    f438:	82 e0       	ldi	r24, 0x02	; 2
    f43a:	80 93 25 01 	sts	0x0125, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f43e:	60 91 77 01 	lds	r22, 0x0177
    f442:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
    f446:	80 91 25 01 	lds	r24, 0x0125
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f44a:	e1 99       	sbic	0x1c, 1	; 28
    f44c:	fe cf       	rjmp	.-4      	; 0xf44a <InitializeConnection+0x2c8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f44e:	bf ba       	out	0x1f, r11	; 31
    f450:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f452:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f454:	0f b6       	in	r0, 0x3f	; 63
    f456:	f8 94       	cli
    f458:	e2 9a       	sbi	0x1c, 2	; 28
    f45a:	e1 9a       	sbi	0x1c, 1	; 28
    f45c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f45e:	e1 99       	sbic	0x1c, 1	; 28
    f460:	fe cf       	rjmp	.-4      	; 0xf45e <InitializeConnection+0x2dc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f462:	84 e7       	ldi	r24, 0x74	; 116
    f464:	91 e0       	ldi	r25, 0x01	; 1
    f466:	9f bb       	out	0x1f, r25	; 31
    f468:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f46a:	e0 9a       	sbi	0x1c, 0	; 28
    f46c:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    f46e:	80 93 75 01 	sts	0x0175, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f472:	e1 99       	sbic	0x1c, 1	; 28
    f474:	fe cf       	rjmp	.-4      	; 0xf472 <InitializeConnection+0x2f0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f476:	89 e7       	ldi	r24, 0x79	; 121
    f478:	91 e0       	ldi	r25, 0x01	; 1
    f47a:	9f bb       	out	0x1f, r25	; 31
    f47c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f47e:	e0 9a       	sbi	0x1c, 0	; 28
    f480:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    f482:	80 93 76 01 	sts	0x0176, r24
			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
}
    f486:	64 96       	adiw	r28, 0x14	; 20
    f488:	0f b6       	in	r0, 0x3f	; 63
    f48a:	f8 94       	cli
    f48c:	de bf       	out	0x3e, r29	; 62
    f48e:	0f be       	out	0x3f, r0	; 63
    f490:	cd bf       	out	0x3d, r28	; 61
    f492:	cf 91       	pop	r28
    f494:	df 91       	pop	r29
    f496:	1f 91       	pop	r17
    f498:	0f 91       	pop	r16
    f49a:	ff 90       	pop	r15
    f49c:	ef 90       	pop	r14
    f49e:	df 90       	pop	r13
    f4a0:	cf 90       	pop	r12
    f4a2:	bf 90       	pop	r11
    f4a4:	af 90       	pop	r10
    f4a6:	08 95       	ret

0000f4a8 <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    f4a8:	2f 92       	push	r2
    f4aa:	3f 92       	push	r3
    f4ac:	4f 92       	push	r4
    f4ae:	5f 92       	push	r5
    f4b0:	6f 92       	push	r6
    f4b2:	7f 92       	push	r7
    f4b4:	8f 92       	push	r8
    f4b6:	9f 92       	push	r9
    f4b8:	af 92       	push	r10
    f4ba:	bf 92       	push	r11
    f4bc:	cf 92       	push	r12
    f4be:	df 92       	push	r13
    f4c0:	ef 92       	push	r14
    f4c2:	ff 92       	push	r15
    f4c4:	0f 93       	push	r16
    f4c6:	1f 93       	push	r17
    f4c8:	df 93       	push	r29
    f4ca:	cf 93       	push	r28
    f4cc:	cd b7       	in	r28, 0x3d	; 61
    f4ce:	de b7       	in	r29, 0x3e	; 62
    f4d0:	e1 97       	sbiw	r28, 0x31	; 49
    f4d2:	0f b6       	in	r0, 0x3f	; 63
    f4d4:	f8 94       	cli
    f4d6:	de bf       	out	0x3e, r29	; 62
    f4d8:	0f be       	out	0x3f, r0	; 63
    f4da:	cd bf       	out	0x3d, r28	; 61
    f4dc:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f4de:	dc 01       	movw	r26, r24
    f4e0:	12 96       	adiw	r26, 0x02	; 2
    f4e2:	8c 91       	ld	r24, X
    f4e4:	12 97       	sbiw	r26, 0x02	; 2
    f4e6:	89 83       	std	Y+1, r24	; 0x01
    f4e8:	13 96       	adiw	r26, 0x03	; 3
    f4ea:	8c 91       	ld	r24, X
    f4ec:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f4ee:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f4f0:	8e 01       	movw	r16, r28
    f4f2:	0f 5f       	subi	r16, 0xFF	; 255
    f4f4:	1f 4f       	sbci	r17, 0xFF	; 255
    f4f6:	c8 01       	movw	r24, r16
    f4f8:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    f4fc:	c8 01       	movw	r24, r16
    f4fe:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
    f502:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f504:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
    f508:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    f50a:	88 23       	and	r24, r24
    f50c:	09 f4       	brne	.+2      	; 0xf510 <StoreStandaloneTransData+0x68>
    f50e:	1a c2       	rjmp	.+1076   	; 0xf944 <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    f510:	f7 01       	movw	r30, r14
    f512:	f4 81       	ldd	r31, Z+4	; 0x04
    f514:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f516:	d7 01       	movw	r26, r14
    f518:	15 96       	adiw	r26, 0x05	; 5
    f51a:	2c 90       	ld	r2, X
    f51c:	e4 e0       	ldi	r30, 0x04	; 4
    f51e:	8e 2e       	mov	r8, r30
    f520:	91 2c       	mov	r9, r1
    f522:	8c 0e       	add	r8, r28
    f524:	9d 1e       	adc	r9, r29
    f526:	f4 01       	movw	r30, r8
    f528:	ce 01       	movw	r24, r28
    f52a:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    f52c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f52e:	e8 17       	cp	r30, r24
    f530:	f9 07       	cpc	r31, r25
    f532:	e1 f7       	brne	.-8      	; 0xf52c <StoreStandaloneTransData+0x84>
    f534:	7d e1       	ldi	r23, 0x1D	; 29
    f536:	67 2e       	mov	r6, r23
    f538:	71 2c       	mov	r7, r1
    f53a:	6c 0e       	add	r6, r28
    f53c:	7d 1e       	adc	r7, r29
    f53e:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    f540:	ce 01       	movw	r24, r28
    f542:	87 96       	adiw	r24, 0x27	; 39
    f544:	f9 01       	movw	r30, r18
    f546:	11 92       	st	Z+, r1
    f548:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f54a:	e8 17       	cp	r30, r24
    f54c:	f9 07       	cpc	r31, r25
    f54e:	d1 f7       	brne	.-12     	; 0xf544 <StoreStandaloneTransData+0x9c>
    f550:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    f552:	ce 01       	movw	r24, r28
    f554:	c1 96       	adiw	r24, 0x31	; 49
    f556:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f558:	e8 17       	cp	r30, r24
    f55a:	f9 07       	cpc	r31, r25
    f55c:	e1 f7       	brne	.-8      	; 0xf556 <StoreStandaloneTransData+0xae>
    f55e:	a7 01       	movw	r20, r14
    f560:	d7 01       	movw	r26, r14
    f562:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f564:	be 01       	movw	r22, r28
    f566:	66 5f       	subi	r22, 0xF6	; 246
    f568:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f56a:	16 96       	adiw	r26, 0x06	; 6
    f56c:	8c 91       	ld	r24, X
    f56e:	16 97       	sbiw	r26, 0x06	; 6
    f570:	81 93       	st	Z+, r24
    f572:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f574:	e6 17       	cp	r30, r22
    f576:	f7 07       	cpc	r31, r23
    f578:	c1 f7       	brne	.-16     	; 0xf56a <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f57a:	1a 86       	std	Y+10, r1	; 0x0a
    f57c:	d7 01       	movw	r26, r14
    f57e:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f580:	be 01       	movw	r22, r28
    f582:	6b 5d       	subi	r22, 0xDB	; 219
    f584:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f586:	1c 96       	adiw	r26, 0x0c	; 12
    f588:	8c 91       	ld	r24, X
    f58a:	1c 97       	sbiw	r26, 0x0c	; 12
    f58c:	81 93       	st	Z+, r24
    f58e:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f590:	e6 17       	cp	r30, r22
    f592:	f7 07       	cpc	r31, r23
    f594:	c1 f7       	brne	.-16     	; 0xf586 <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f596:	1d a2       	std	Y+37, r1	; 0x25
    f598:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f59a:	be 01       	movw	r22, r28
    f59c:	69 5d       	subi	r22, 0xD9	; 217
    f59e:	7f 4f       	sbci	r23, 0xFF	; 255
    f5a0:	9e 01       	movw	r18, r28
    f5a2:	21 5d       	subi	r18, 0xD1	; 209
    f5a4:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f5a6:	da 01       	movw	r26, r20
    f5a8:	54 96       	adiw	r26, 0x14	; 20
    f5aa:	8c 91       	ld	r24, X
    f5ac:	81 93       	st	Z+, r24
    f5ae:	4f 5f       	subi	r20, 0xFF	; 255
    f5b0:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5b2:	e2 17       	cp	r30, r18
    f5b4:	f3 07       	cpc	r31, r19
    f5b6:	b9 f7       	brne	.-18     	; 0xf5a6 <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f5b8:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    f5ba:	f7 01       	movw	r30, r14
    f5bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    f5be:	80 53       	subi	r24, 0x30	; 48
    f5c0:	8a 30       	cpi	r24, 0x0A	; 10
    f5c2:	98 f4       	brcc	.+38     	; 0xf5ea <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
    f5c4:	88 30       	cpi	r24, 0x08	; 8
    f5c6:	89 f4       	brne	.+34     	; 0xf5ea <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    f5c8:	fb 01       	movw	r30, r22
    f5ca:	01 90       	ld	r0, Z+
    f5cc:	00 20       	and	r0, r0
    f5ce:	e9 f7       	brne	.-6      	; 0xf5ca <StoreStandaloneTransData+0x122>
    f5d0:	e6 1b       	sub	r30, r22
    f5d2:	f7 0b       	sbc	r31, r23
    f5d4:	32 97       	sbiw	r30, 0x02	; 2
    f5d6:	80 e0       	ldi	r24, 0x00	; 0
    f5d8:	90 e0       	ldi	r25, 0x00	; 0
    f5da:	01 c0       	rjmp	.+2      	; 0xf5de <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5dc:	01 96       	adiw	r24, 0x01	; 1
    f5de:	8e 17       	cp	r24, r30
    f5e0:	9f 07       	cpc	r25, r31
    f5e2:	e0 f3       	brcs	.-8      	; 0xf5dc <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f5e4:	ec 0f       	add	r30, r28
    f5e6:	fd 1f       	adc	r31, r29
    f5e8:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    f5ea:	64 e0       	ldi	r22, 0x04	; 4
    f5ec:	e6 2e       	mov	r14, r22
    f5ee:	f1 2c       	mov	r15, r1
    f5f0:	ec 0e       	add	r14, r28
    f5f2:	fd 1e       	adc	r15, r29
    f5f4:	c7 01       	movw	r24, r14
    f5f6:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		 RemZeroLead(strPVolume);
    f5fa:	5d e1       	ldi	r21, 0x1D	; 29
    f5fc:	a5 2e       	mov	r10, r21
    f5fe:	b1 2c       	mov	r11, r1
    f600:	ac 0e       	add	r10, r28
    f602:	bd 1e       	adc	r11, r29
    f604:	c5 01       	movw	r24, r10
    f606:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		 RemZeroLead(strPMoney);
    f60a:	8e 01       	movw	r16, r28
    f60c:	09 5d       	subi	r16, 0xD9	; 217
    f60e:	1f 4f       	sbci	r17, 0xFF	; 255
    f610:	c8 01       	movw	r24, r16
    f612:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //_uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    f616:	c8 01       	movw	r24, r16
    f618:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
    f61c:	89 2b       	or	r24, r25
    f61e:	09 f0       	breq	.+2      	; 0xf622 <StoreStandaloneTransData+0x17a>
    f620:	46 c1       	rjmp	.+652    	; 0xf8ae <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    f622:	83 2d       	mov	r24, r3
    f624:	8f 70       	andi	r24, 0x0F	; 15
    f626:	63 e1       	ldi	r22, 0x13	; 19
    f628:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <UpdateStandaloneStatus>
    f62c:	8b c1       	rjmp	.+790    	; 0xf944 <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f62e:	e1 99       	sbic	0x1c, 1	; 28
    f630:	fe cf       	rjmp	.-4      	; 0xf62e <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f632:	8f e6       	ldi	r24, 0x6F	; 111
    f634:	91 e0       	ldi	r25, 0x01	; 1
    f636:	9f bb       	out	0x1f, r25	; 31
    f638:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f63a:	e0 9a       	sbi	0x1c, 0	; 28
    f63c:	2d b3       	in	r18, 0x1d	; 29
			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    f63e:	00 d0       	rcall	.+0      	; 0xf640 <StoreStandaloneTransData+0x198>
    f640:	00 d0       	rcall	.+0      	; 0xf642 <StoreStandaloneTransData+0x19a>
    f642:	00 d0       	rcall	.+0      	; 0xf644 <StoreStandaloneTransData+0x19c>
    f644:	ed b7       	in	r30, 0x3d	; 61
    f646:	fe b7       	in	r31, 0x3e	; 62
    f648:	31 96       	adiw	r30, 0x01	; 1
    f64a:	8e e6       	ldi	r24, 0x6E	; 110
    f64c:	9e e0       	ldi	r25, 0x0E	; 14
    f64e:	ad b7       	in	r26, 0x3d	; 61
    f650:	be b7       	in	r27, 0x3e	; 62
    f652:	12 96       	adiw	r26, 0x02	; 2
    f654:	9c 93       	st	X, r25
    f656:	8e 93       	st	-X, r24
    f658:	11 97       	sbiw	r26, 0x01	; 1
    f65a:	89 e1       	ldi	r24, 0x19	; 25
    f65c:	92 e2       	ldi	r25, 0x22	; 34
    f65e:	93 83       	std	Z+3, r25	; 0x03
    f660:	82 83       	std	Z+2, r24	; 0x02
    f662:	24 83       	std	Z+4, r18	; 0x04
    f664:	15 82       	std	Z+5, r1	; 0x05
    f666:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    f66a:	ed e8       	ldi	r30, 0x8D	; 141
    f66c:	fe e0       	ldi	r31, 0x0E	; 14
    f66e:	df 01       	movw	r26, r30
    f670:	0d 90       	ld	r0, X+
    f672:	00 20       	and	r0, r0
    f674:	e9 f7       	brne	.-6      	; 0xf670 <StoreStandaloneTransData+0x1c8>
    f676:	9d 01       	movw	r18, r26
    f678:	21 50       	subi	r18, 0x01	; 1
    f67a:	30 40       	sbci	r19, 0x00	; 0
    f67c:	2e 1b       	sub	r18, r30
    f67e:	3f 0b       	sbc	r19, r31
    f680:	85 e3       	ldi	r24, 0x35	; 53
    f682:	90 e0       	ldi	r25, 0x00	; 0
    f684:	c8 9e       	mul	r12, r24
    f686:	d0 01       	movw	r26, r0
    f688:	c9 9e       	mul	r12, r25
    f68a:	b0 0d       	add	r27, r0
    f68c:	d8 9e       	mul	r13, r24
    f68e:	b0 0d       	add	r27, r0
    f690:	11 24       	eor	r1, r1
    f692:	ab 54       	subi	r26, 0x4B	; 75
    f694:	b8 4f       	sbci	r27, 0xF8	; 248
    f696:	4d b7       	in	r20, 0x3d	; 61
    f698:	5e b7       	in	r21, 0x3e	; 62
    f69a:	4a 5f       	subi	r20, 0xFA	; 250
    f69c:	5f 4f       	sbci	r21, 0xFF	; 255
    f69e:	0f b6       	in	r0, 0x3f	; 63
    f6a0:	f8 94       	cli
    f6a2:	5e bf       	out	0x3e, r21	; 62
    f6a4:	0f be       	out	0x3f, r0	; 63
    f6a6:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6a8:	a9 01       	movw	r20, r18
    f6aa:	4e 0f       	add	r20, r30
    f6ac:	5f 1f       	adc	r21, r31
    f6ae:	02 c0       	rjmp	.+4      	; 0xf6b4 <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    f6b0:	81 91       	ld	r24, Z+
    f6b2:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6b4:	e4 17       	cp	r30, r20
    f6b6:	f5 07       	cpc	r31, r21
    f6b8:	d9 f7       	brne	.-10     	; 0xf6b0 <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f6ba:	85 e3       	ldi	r24, 0x35	; 53
    f6bc:	90 e0       	ldi	r25, 0x00	; 0
    f6be:	dc 01       	movw	r26, r24
    f6c0:	ca 9e       	mul	r12, r26
    f6c2:	c0 01       	movw	r24, r0
    f6c4:	cb 9e       	mul	r12, r27
    f6c6:	90 0d       	add	r25, r0
    f6c8:	da 9e       	mul	r13, r26
    f6ca:	90 0d       	add	r25, r0
    f6cc:	11 24       	eor	r1, r1
    f6ce:	fc 01       	movw	r30, r24
    f6d0:	ee 54       	subi	r30, 0x4E	; 78
    f6d2:	f8 4f       	sbci	r31, 0xF8	; 248
    f6d4:	e2 0f       	add	r30, r18
    f6d6:	f3 1f       	adc	r31, r19
    f6d8:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    f6da:	fe 01       	movw	r30, r28
    f6dc:	3b 96       	adiw	r30, 0x0b	; 11
    f6de:	df 01       	movw	r26, r30
    f6e0:	0d 90       	ld	r0, X+
    f6e2:	00 20       	and	r0, r0
    f6e4:	e9 f7       	brne	.-6      	; 0xf6e0 <StoreStandaloneTransData+0x238>
    f6e6:	11 97       	sbiw	r26, 0x01	; 1
    f6e8:	ae 1b       	sub	r26, r30
    f6ea:	bf 0b       	sbc	r27, r31
    f6ec:	bf 01       	movw	r22, r30
    f6ee:	9c 01       	movw	r18, r24
    f6f0:	24 54       	subi	r18, 0x44	; 68
    f6f2:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6f4:	af 01       	movw	r20, r30
    f6f6:	4a 0f       	add	r20, r26
    f6f8:	5b 1f       	adc	r21, r27
    f6fa:	06 c0       	rjmp	.+12     	; 0xf708 <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    f6fc:	fb 01       	movw	r30, r22
    f6fe:	81 91       	ld	r24, Z+
    f700:	bf 01       	movw	r22, r30
    f702:	f9 01       	movw	r30, r18
    f704:	81 93       	st	Z+, r24
    f706:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f708:	64 17       	cp	r22, r20
    f70a:	75 07       	cpc	r23, r21
    f70c:	b9 f7       	brne	.-18     	; 0xf6fc <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f70e:	85 e3       	ldi	r24, 0x35	; 53
    f710:	90 e0       	ldi	r25, 0x00	; 0
    f712:	9c 01       	movw	r18, r24
    f714:	c2 9e       	mul	r12, r18
    f716:	c0 01       	movw	r24, r0
    f718:	c3 9e       	mul	r12, r19
    f71a:	90 0d       	add	r25, r0
    f71c:	d2 9e       	mul	r13, r18
    f71e:	90 0d       	add	r25, r0
    f720:	11 24       	eor	r1, r1
    f722:	fc 01       	movw	r30, r24
    f724:	ee 54       	subi	r30, 0x4E	; 78
    f726:	f8 4f       	sbci	r31, 0xF8	; 248
    f728:	ea 0f       	add	r30, r26
    f72a:	fb 1f       	adc	r31, r27
    f72c:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    f72e:	fe 01       	movw	r30, r28
    f730:	74 96       	adiw	r30, 0x14	; 20
    f732:	df 01       	movw	r26, r30
    f734:	0d 90       	ld	r0, X+
    f736:	00 20       	and	r0, r0
    f738:	e9 f7       	brne	.-6      	; 0xf734 <StoreStandaloneTransData+0x28c>
    f73a:	11 97       	sbiw	r26, 0x01	; 1
    f73c:	ae 1b       	sub	r26, r30
    f73e:	bf 0b       	sbc	r27, r31
    f740:	bf 01       	movw	r22, r30
    f742:	9c 01       	movw	r18, r24
    f744:	2b 53       	subi	r18, 0x3B	; 59
    f746:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f748:	af 01       	movw	r20, r30
    f74a:	4a 0f       	add	r20, r26
    f74c:	5b 1f       	adc	r21, r27
    f74e:	06 c0       	rjmp	.+12     	; 0xf75c <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    f750:	fb 01       	movw	r30, r22
    f752:	81 91       	ld	r24, Z+
    f754:	bf 01       	movw	r22, r30
    f756:	f9 01       	movw	r30, r18
    f758:	81 93       	st	Z+, r24
    f75a:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f75c:	64 17       	cp	r22, r20
    f75e:	75 07       	cpc	r23, r21
    f760:	b9 f7       	brne	.-18     	; 0xf750 <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f762:	85 e3       	ldi	r24, 0x35	; 53
    f764:	90 e0       	ldi	r25, 0x00	; 0
    f766:	c8 9e       	mul	r12, r24
    f768:	70 01       	movw	r14, r0
    f76a:	c9 9e       	mul	r12, r25
    f76c:	f0 0c       	add	r15, r0
    f76e:	d8 9e       	mul	r13, r24
    f770:	f0 0c       	add	r15, r0
    f772:	11 24       	eor	r1, r1
    f774:	87 01       	movw	r16, r14
    f776:	0e 54       	subi	r16, 0x4E	; 78
    f778:	18 4f       	sbci	r17, 0xF8	; 248
    f77a:	a0 0f       	add	r26, r16
    f77c:	b1 1f       	adc	r27, r17
    f77e:	53 96       	adiw	r26, 0x13	; 19
    f780:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    f782:	f0 ed       	ldi	r31, 0xD0	; 208
    f784:	2f 0e       	add	r2, r31
    f786:	d8 01       	movw	r26, r16
    f788:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    f78a:	b9 a9       	ldd	r27, Y+49	; 0x31
    f78c:	b0 53       	subi	r27, 0x30	; 48
    f78e:	f8 01       	movw	r30, r16
    f790:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    f792:	8e e6       	ldi	r24, 0x6E	; 110
    f794:	9e e0       	ldi	r25, 0x0E	; 14
    f796:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
    f79a:	d8 01       	movw	r26, r16
    f79c:	12 96       	adiw	r26, 0x02	; 2
    f79e:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    f7a0:	fe 01       	movw	r30, r28
    f7a2:	34 96       	adiw	r30, 0x04	; 4
    f7a4:	df 01       	movw	r26, r30
    f7a6:	0d 90       	ld	r0, X+
    f7a8:	00 20       	and	r0, r0
    f7aa:	e9 f7       	brne	.-6      	; 0xf7a6 <StoreStandaloneTransData+0x2fe>
    f7ac:	11 97       	sbiw	r26, 0x01	; 1
    f7ae:	ae 1b       	sub	r26, r30
    f7b0:	bf 0b       	sbc	r27, r31
    f7b2:	97 01       	movw	r18, r14
    f7b4:	22 53       	subi	r18, 0x32	; 50
    f7b6:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f7b8:	af 01       	movw	r20, r30
    f7ba:	4a 0f       	add	r20, r26
    f7bc:	5b 1f       	adc	r21, r27
    f7be:	06 c0       	rjmp	.+12     	; 0xf7cc <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    f7c0:	f4 01       	movw	r30, r8
    f7c2:	81 91       	ld	r24, Z+
    f7c4:	4f 01       	movw	r8, r30
    f7c6:	f9 01       	movw	r30, r18
    f7c8:	81 93       	st	Z+, r24
    f7ca:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f7cc:	84 16       	cp	r8, r20
    f7ce:	95 06       	cpc	r9, r21
    f7d0:	b9 f7       	brne	.-18     	; 0xf7c0 <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f7d2:	85 e3       	ldi	r24, 0x35	; 53
    f7d4:	90 e0       	ldi	r25, 0x00	; 0
    f7d6:	9c 01       	movw	r18, r24
    f7d8:	c2 9e       	mul	r12, r18
    f7da:	c0 01       	movw	r24, r0
    f7dc:	c3 9e       	mul	r12, r19
    f7de:	90 0d       	add	r25, r0
    f7e0:	d2 9e       	mul	r13, r18
    f7e2:	90 0d       	add	r25, r0
    f7e4:	11 24       	eor	r1, r1
    f7e6:	fc 01       	movw	r30, r24
    f7e8:	ee 54       	subi	r30, 0x4E	; 78
    f7ea:	f8 4f       	sbci	r31, 0xF8	; 248
    f7ec:	ea 0f       	add	r30, r26
    f7ee:	fb 1f       	adc	r31, r27
    f7f0:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    f7f2:	fe 01       	movw	r30, r28
    f7f4:	7d 96       	adiw	r30, 0x1d	; 29
    f7f6:	df 01       	movw	r26, r30
    f7f8:	0d 90       	ld	r0, X+
    f7fa:	00 20       	and	r0, r0
    f7fc:	e9 f7       	brne	.-6      	; 0xf7f8 <StoreStandaloneTransData+0x350>
    f7fe:	11 97       	sbiw	r26, 0x01	; 1
    f800:	ae 1b       	sub	r26, r30
    f802:	bf 0b       	sbc	r27, r31
    f804:	9c 01       	movw	r18, r24
    f806:	2b 52       	subi	r18, 0x2B	; 43
    f808:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f80a:	af 01       	movw	r20, r30
    f80c:	4a 0f       	add	r20, r26
    f80e:	5b 1f       	adc	r21, r27
    f810:	06 c0       	rjmp	.+12     	; 0xf81e <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    f812:	f3 01       	movw	r30, r6
    f814:	81 91       	ld	r24, Z+
    f816:	3f 01       	movw	r6, r30
    f818:	f9 01       	movw	r30, r18
    f81a:	81 93       	st	Z+, r24
    f81c:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f81e:	64 16       	cp	r6, r20
    f820:	75 06       	cpc	r7, r21
    f822:	b9 f7       	brne	.-18     	; 0xf812 <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f824:	85 e3       	ldi	r24, 0x35	; 53
    f826:	90 e0       	ldi	r25, 0x00	; 0
    f828:	9c 01       	movw	r18, r24
    f82a:	c2 9e       	mul	r12, r18
    f82c:	c0 01       	movw	r24, r0
    f82e:	c3 9e       	mul	r12, r19
    f830:	90 0d       	add	r25, r0
    f832:	d2 9e       	mul	r13, r18
    f834:	90 0d       	add	r25, r0
    f836:	11 24       	eor	r1, r1
    f838:	fc 01       	movw	r30, r24
    f83a:	ee 54       	subi	r30, 0x4E	; 78
    f83c:	f8 4f       	sbci	r31, 0xF8	; 248
    f83e:	ea 0f       	add	r30, r26
    f840:	fb 1f       	adc	r31, r27
    f842:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    f844:	fe 01       	movw	r30, r28
    f846:	b7 96       	adiw	r30, 0x27	; 39
    f848:	df 01       	movw	r26, r30
    f84a:	0d 90       	ld	r0, X+
    f84c:	00 20       	and	r0, r0
    f84e:	e9 f7       	brne	.-6      	; 0xf84a <StoreStandaloneTransData+0x3a2>
    f850:	11 97       	sbiw	r26, 0x01	; 1
    f852:	ae 1b       	sub	r26, r30
    f854:	bf 0b       	sbc	r27, r31
    f856:	9c 01       	movw	r18, r24
    f858:	22 52       	subi	r18, 0x22	; 34
    f85a:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f85c:	af 01       	movw	r20, r30
    f85e:	4a 0f       	add	r20, r26
    f860:	5b 1f       	adc	r21, r27
    f862:	06 c0       	rjmp	.+12     	; 0xf870 <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    f864:	f2 01       	movw	r30, r4
    f866:	81 91       	ld	r24, Z+
    f868:	2f 01       	movw	r4, r30
    f86a:	f9 01       	movw	r30, r18
    f86c:	81 93       	st	Z+, r24
    f86e:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f870:	44 16       	cp	r4, r20
    f872:	55 06       	cpc	r5, r21
    f874:	b9 f7       	brne	.-18     	; 0xf864 <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f876:	85 e3       	ldi	r24, 0x35	; 53
    f878:	90 e0       	ldi	r25, 0x00	; 0
    f87a:	c8 9e       	mul	r12, r24
    f87c:	f0 01       	movw	r30, r0
    f87e:	c9 9e       	mul	r12, r25
    f880:	f0 0d       	add	r31, r0
    f882:	d8 9e       	mul	r13, r24
    f884:	f0 0d       	add	r31, r0
    f886:	11 24       	eor	r1, r1
    f888:	ee 54       	subi	r30, 0x4E	; 78
    f88a:	f8 4f       	sbci	r31, 0xF8	; 248
    f88c:	ea 0f       	add	r30, r26
    f88e:	fb 1f       	adc	r31, r27
    f890:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    f892:	83 2d       	mov	r24, r3
    f894:	8f 70       	andi	r24, 0x0F	; 15
    f896:	60 e1       	ldi	r22, 0x10	; 16
    f898:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    f89c:	83 2d       	mov	r24, r3
    f89e:	62 e0       	ldi	r22, 0x02	; 2
    f8a0:	0e 94 c4 19 	call	0x3388	; 0x3388 <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    f8a4:	8b e0       	ldi	r24, 0x0B	; 11
    f8a6:	63 2d       	mov	r22, r3
    f8a8:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
    f8ac:	4b c0       	rjmp	.+150    	; 0xf944 <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    f8ae:	da 94       	dec	r13
    f8b0:	cd 2c       	mov	r12, r13
    f8b2:	dd 24       	eor	r13, r13
    f8b4:	f6 01       	movw	r30, r12
    f8b6:	e8 56       	subi	r30, 0x68	; 104
    f8b8:	fe 4f       	sbci	r31, 0xFE	; 254
    f8ba:	81 e0       	ldi	r24, 0x01	; 1
    f8bc:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    f8be:	c7 01       	movw	r24, r14
    f8c0:	0e 94 55 31 	call	0x62aa	; 0x62aa <FormatPrice>
			 FormatMoney(strPMoney);
    f8c4:	c8 01       	movw	r24, r16
    f8c6:	0e 94 48 31 	call	0x6290	; 0x6290 <FormatMoney>
			 FormatVolume(strPVolume);
    f8ca:	c5 01       	movw	r24, r10
    f8cc:	0e 94 3b 31 	call	0x6276	; 0x6276 <FormatVolume>

			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    f8d0:	8d e8       	ldi	r24, 0x8D	; 141
    f8d2:	9e e0       	ldi	r25, 0x0E	; 14
    f8d4:	0e 94 c4 48 	call	0x9188	; 0x9188 <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    f8d8:	00 d0       	rcall	.+0      	; 0xf8da <StoreStandaloneTransData+0x432>
    f8da:	00 d0       	rcall	.+0      	; 0xf8dc <StoreStandaloneTransData+0x434>
    f8dc:	00 d0       	rcall	.+0      	; 0xf8de <StoreStandaloneTransData+0x436>
    f8de:	ed b7       	in	r30, 0x3d	; 61
    f8e0:	fe b7       	in	r31, 0x3e	; 62
    f8e2:	31 96       	adiw	r30, 0x01	; 1
    f8e4:	ce 01       	movw	r24, r28
    f8e6:	0b 96       	adiw	r24, 0x0b	; 11
    f8e8:	ad b7       	in	r26, 0x3d	; 61
    f8ea:	be b7       	in	r27, 0x3e	; 62
    f8ec:	12 96       	adiw	r26, 0x02	; 2
    f8ee:	9c 93       	st	X, r25
    f8f0:	8e 93       	st	-X, r24
    f8f2:	11 97       	sbiw	r26, 0x01	; 1
    f8f4:	8f e1       	ldi	r24, 0x1F	; 31
    f8f6:	92 e2       	ldi	r25, 0x22	; 34
    f8f8:	93 83       	std	Z+3, r25	; 0x03
    f8fa:	82 83       	std	Z+2, r24	; 0x02
    f8fc:	8f eb       	ldi	r24, 0xBF	; 191
    f8fe:	95 e0       	ldi	r25, 0x05	; 5
    f900:	95 83       	std	Z+5, r25	; 0x05
    f902:	84 83       	std	Z+4, r24	; 0x04
    f904:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    f908:	ed b7       	in	r30, 0x3d	; 61
    f90a:	fe b7       	in	r31, 0x3e	; 62
    f90c:	31 96       	adiw	r30, 0x01	; 1
    f90e:	ce 01       	movw	r24, r28
    f910:	44 96       	adiw	r24, 0x14	; 20
    f912:	ad b7       	in	r26, 0x3d	; 61
    f914:	be b7       	in	r27, 0x3e	; 62
    f916:	12 96       	adiw	r26, 0x02	; 2
    f918:	9c 93       	st	X, r25
    f91a:	8e 93       	st	-X, r24
    f91c:	11 97       	sbiw	r26, 0x01	; 1
    f91e:	8c e1       	ldi	r24, 0x1C	; 28
    f920:	92 e2       	ldi	r25, 0x22	; 34
    f922:	93 83       	std	Z+3, r25	; 0x03
    f924:	82 83       	std	Z+2, r24	; 0x02
    f926:	84 ea       	ldi	r24, 0xA4	; 164
    f928:	9a e0       	ldi	r25, 0x0A	; 10
    f92a:	95 83       	std	Z+5, r25	; 0x05
    f92c:	84 83       	std	Z+4, r24	; 0x04
    f92e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    f932:	ed b7       	in	r30, 0x3d	; 61
    f934:	fe b7       	in	r31, 0x3e	; 62
    f936:	36 96       	adiw	r30, 0x06	; 6
    f938:	0f b6       	in	r0, 0x3f	; 63
    f93a:	f8 94       	cli
    f93c:	fe bf       	out	0x3e, r31	; 62
    f93e:	0f be       	out	0x3f, r0	; 63
    f940:	ed bf       	out	0x3d, r30	; 61
    f942:	75 ce       	rjmp	.-790    	; 0xf62e <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //_uart_print(0,1,strRawTransData);
}
    f944:	e1 96       	adiw	r28, 0x31	; 49
    f946:	0f b6       	in	r0, 0x3f	; 63
    f948:	f8 94       	cli
    f94a:	de bf       	out	0x3e, r29	; 62
    f94c:	0f be       	out	0x3f, r0	; 63
    f94e:	cd bf       	out	0x3d, r28	; 61
    f950:	cf 91       	pop	r28
    f952:	df 91       	pop	r29
    f954:	1f 91       	pop	r17
    f956:	0f 91       	pop	r16
    f958:	ff 90       	pop	r15
    f95a:	ef 90       	pop	r14
    f95c:	df 90       	pop	r13
    f95e:	cf 90       	pop	r12
    f960:	bf 90       	pop	r11
    f962:	af 90       	pop	r10
    f964:	9f 90       	pop	r9
    f966:	8f 90       	pop	r8
    f968:	7f 90       	pop	r7
    f96a:	6f 90       	pop	r6
    f96c:	5f 90       	pop	r5
    f96e:	4f 90       	pop	r4
    f970:	3f 90       	pop	r3
    f972:	2f 90       	pop	r2
    f974:	08 95       	ret

0000f976 <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    f976:	2f 92       	push	r2
    f978:	3f 92       	push	r3
    f97a:	4f 92       	push	r4
    f97c:	5f 92       	push	r5
    f97e:	7f 92       	push	r7
    f980:	8f 92       	push	r8
    f982:	9f 92       	push	r9
    f984:	af 92       	push	r10
    f986:	bf 92       	push	r11
    f988:	cf 92       	push	r12
    f98a:	df 92       	push	r13
    f98c:	ef 92       	push	r14
    f98e:	ff 92       	push	r15
    f990:	0f 93       	push	r16
    f992:	1f 93       	push	r17
    f994:	df 93       	push	r29
    f996:	cf 93       	push	r28
    f998:	cd b7       	in	r28, 0x3d	; 61
    f99a:	de b7       	in	r29, 0x3e	; 62
    f99c:	a1 97       	sbiw	r28, 0x21	; 33
    f99e:	0f b6       	in	r0, 0x3f	; 63
    f9a0:	f8 94       	cli
    f9a2:	de bf       	out	0x3e, r29	; 62
    f9a4:	0f be       	out	0x3f, r0	; 63
    f9a6:	cd bf       	out	0x3d, r28	; 61
    f9a8:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f9aa:	fc 01       	movw	r30, r24
    f9ac:	82 81       	ldd	r24, Z+2	; 0x02
    f9ae:	89 83       	std	Y+1, r24	; 0x01
    f9b0:	83 81       	ldd	r24, Z+3	; 0x03
    f9b2:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f9b4:	1b 82       	std	Y+3, r1	; 0x03
	 //for(i=0;i<strlen(strRawTransData);i++){
	 //    _uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f9b6:	8e 01       	movw	r16, r28
    f9b8:	0f 5f       	subi	r16, 0xFF	; 255
    f9ba:	1f 4f       	sbci	r17, 0xFF	; 255
    f9bc:	c8 01       	movw	r24, r16
    f9be:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 iPumpID=atoi(strPumpID);  
    f9c2:	c8 01       	movw	r24, r16
    f9c4:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
    f9c8:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f9ca:	0e 94 19 1b 	call	0x3632	; 0x3632 <GetFIPAddr>
	 if (FIPAddr>0){
    f9ce:	88 23       	and	r24, r24
    f9d0:	09 f4       	brne	.+2      	; 0xf9d4 <StoreStandaloneTotalizerData+0x5e>
    f9d2:	43 c0       	rjmp	.+134    	; 0xfa5a <StoreStandaloneTotalizerData+0xe4>
	     FIPAddr=FIPAddr-1;
    f9d4:	78 2e       	mov	r7, r24
    f9d6:	7a 94       	dec	r7
    f9d8:	80 e1       	ldi	r24, 0x10	; 16
    f9da:	90 e0       	ldi	r25, 0x00	; 0
    f9dc:	e8 0e       	add	r14, r24
    f9de:	f9 1e       	adc	r15, r25
    f9e0:	dd 24       	eor	r13, r13
    f9e2:	d3 94       	inc	r13
    f9e4:	14 e0       	ldi	r17, 0x04	; 4
    f9e6:	81 2e       	mov	r8, r17
    f9e8:	91 2c       	mov	r9, r1
    f9ea:	8c 0e       	add	r8, r28
    f9ec:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f9ee:	b0 e1       	ldi	r27, 0x10	; 16
    f9f0:	2b 2e       	mov	r2, r27
    f9f2:	31 2c       	mov	r3, r1
    f9f4:	2c 0e       	add	r2, r28
    f9f6:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f9f8:	a3 e1       	ldi	r26, 0x13	; 19
    f9fa:	aa 2e       	mov	r10, r26
    f9fc:	b1 2c       	mov	r11, r1
    f9fe:	ac 0e       	add	r10, r28
    fa00:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fa02:	ff e1       	ldi	r31, 0x1F	; 31
    fa04:	4f 2e       	mov	r4, r31
    fa06:	51 2c       	mov	r5, r1
    fa08:	4c 0e       	add	r4, r28
    fa0a:	5d 1e       	adc	r5, r29
	 RemZeroLead(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    fa0c:	d7 01       	movw	r26, r14
    fa0e:	1c 97       	sbiw	r26, 0x0c	; 12
    fa10:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    fa12:	8d 91       	ld	r24, X+
    fa14:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fa16:	e2 15       	cp	r30, r2
    fa18:	f3 05       	cpc	r31, r3
    fa1a:	d9 f7       	brne	.-10     	; 0xfa12 <StoreStandaloneTotalizerData+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    fa1c:	18 8a       	std	Y+16, r1	; 0x10
    fa1e:	f5 01       	movw	r30, r10
    fa20:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    fa22:	8d 91       	ld	r24, X+
    fa24:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    fa26:	e4 15       	cp	r30, r4
    fa28:	f5 05       	cpc	r31, r5
    fa2a:	d9 f7       	brne	.-10     	; 0xfa22 <StoreStandaloneTotalizerData+0xac>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    fa2c:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    fa2e:	80 e0       	ldi	r24, 0x00	; 0
    fa30:	61 e0       	ldi	r22, 0x01	; 1
    fa32:	47 2d       	mov	r20, r7
    fa34:	2d 2d       	mov	r18, r13
    fa36:	84 01       	movw	r16, r8
    fa38:	0e 94 98 44 	call	0x8930	; 0x8930 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    fa3c:	81 e0       	ldi	r24, 0x01	; 1
    fa3e:	61 e0       	ldi	r22, 0x01	; 1
    fa40:	47 2d       	mov	r20, r7
    fa42:	2d 2d       	mov	r18, r13
    fa44:	85 01       	movw	r16, r10
    fa46:	0e 94 98 44 	call	0x8930	; 0x8930 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //_uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    fa4a:	d3 94       	inc	r13
    fa4c:	e8 e1       	ldi	r30, 0x18	; 24
    fa4e:	f0 e0       	ldi	r31, 0x00	; 0
    fa50:	ee 0e       	add	r14, r30
    fa52:	ff 1e       	adc	r15, r31
    fa54:	f7 e0       	ldi	r31, 0x07	; 7
    fa56:	df 16       	cp	r13, r31
    fa58:	c9 f6       	brne	.-78     	; 0xfa0c <StoreStandaloneTotalizerData+0x96>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //_uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    fa5a:	8d e0       	ldi	r24, 0x0D	; 13
    fa5c:	6c 2d       	mov	r22, r12
    fa5e:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    fa62:	8c 2d       	mov	r24, r12
    fa64:	8f 70       	andi	r24, 0x0F	; 15
    fa66:	64 e1       	ldi	r22, 0x14	; 20
    fa68:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <UpdateStandaloneStatus>
}
    fa6c:	a1 96       	adiw	r28, 0x21	; 33
    fa6e:	0f b6       	in	r0, 0x3f	; 63
    fa70:	f8 94       	cli
    fa72:	de bf       	out	0x3e, r29	; 62
    fa74:	0f be       	out	0x3f, r0	; 63
    fa76:	cd bf       	out	0x3d, r28	; 61
    fa78:	cf 91       	pop	r28
    fa7a:	df 91       	pop	r29
    fa7c:	1f 91       	pop	r17
    fa7e:	0f 91       	pop	r16
    fa80:	ff 90       	pop	r15
    fa82:	ef 90       	pop	r14
    fa84:	df 90       	pop	r13
    fa86:	cf 90       	pop	r12
    fa88:	bf 90       	pop	r11
    fa8a:	af 90       	pop	r10
    fa8c:	9f 90       	pop	r9
    fa8e:	8f 90       	pop	r8
    fa90:	7f 90       	pop	r7
    fa92:	5f 90       	pop	r5
    fa94:	4f 90       	pop	r4
    fa96:	3f 90       	pop	r3
    fa98:	2f 90       	pop	r2
    fa9a:	08 95       	ret

0000fa9c <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    fa9c:	0f 93       	push	r16
    fa9e:	1f 93       	push	r17
    faa0:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    faa2:	80 91 d1 03 	lds	r24, 0x03D1
    faa6:	80 93 d2 03 	sts	0x03D2, r24
	  zDataFlow[3]=zDataFlow[2];
    faaa:	80 91 d0 03 	lds	r24, 0x03D0
    faae:	80 93 d1 03 	sts	0x03D1, r24
	  zDataFlow[2]=zDataFlow[1];
    fab2:	80 91 cf 03 	lds	r24, 0x03CF
    fab6:	80 93 d0 03 	sts	0x03D0, r24
      zDataFlow[1]=zDataFlow[0];
    faba:	90 91 ce 03 	lds	r25, 0x03CE
    fabe:	90 93 cf 03 	sts	0x03CF, r25
      zDataFlow[0]=data;
    fac2:	00 93 ce 03 	sts	0x03CE, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    fac6:	87 30       	cpi	r24, 0x07	; 7
    fac8:	79 f4       	brne	.+30     	; 0xfae8 <ScanStandaloneFlow+0x4c>
    faca:	08 30       	cpi	r16, 0x08	; 8
    facc:	69 f4       	brne	.+26     	; 0xfae8 <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    face:	19 2f       	mov	r17, r25
    fad0:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    fad2:	89 2f       	mov	r24, r25
    fad4:	82 95       	swap	r24
    fad6:	8f 70       	andi	r24, 0x0F	; 15
    fad8:	61 2f       	mov	r22, r17
    fada:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    fade:	1e 30       	cpi	r17, 0x0E	; 14
    fae0:	19 f0       	breq	.+6      	; 0xfae8 <ScanStandaloneFlow+0x4c>
    fae2:	81 e0       	ldi	r24, 0x01	; 1
    fae4:	80 93 c8 01 	sts	0x01C8, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //_uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    fae8:	80 91 c9 01 	lds	r24, 0x01C9
    faec:	81 30       	cpi	r24, 0x01	; 1
    faee:	69 f4       	brne	.+26     	; 0xfb0a <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    faf0:	80 91 cc 03 	lds	r24, 0x03CC
    faf4:	90 91 cd 03 	lds	r25, 0x03CD
    faf8:	fc 01       	movw	r30, r24
    fafa:	e5 5f       	subi	r30, 0xF5	; 245
    fafc:	fa 4f       	sbci	r31, 0xFA	; 250
    fafe:	00 83       	st	Z, r16
		  iFlow++;
    fb00:	01 96       	adiw	r24, 0x01	; 1
    fb02:	90 93 cd 03 	sts	0x03CD, r25
    fb06:	80 93 cc 03 	sts	0x03CC, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    fb0a:	80 91 cf 03 	lds	r24, 0x03CF
    fb0e:	85 30       	cpi	r24, 0x05	; 5
    fb10:	61 f4       	brne	.+24     	; 0xfb2a <ScanStandaloneFlow+0x8e>
    fb12:	80 91 ce 03 	lds	r24, 0x03CE
    fb16:	80 35       	cpi	r24, 0x50	; 80
    fb18:	41 f5       	brne	.+80     	; 0xfb6a <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    fb1a:	81 e0       	ldi	r24, 0x01	; 1
    fb1c:	80 93 c9 01 	sts	0x01C9, r24
		  iFlow=0;
    fb20:	10 92 cd 03 	sts	0x03CD, r1
    fb24:	10 92 cc 03 	sts	0x03CC, r1
    fb28:	20 c0       	rjmp	.+64     	; 0xfb6a <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    fb2a:	86 30       	cpi	r24, 0x06	; 6
    fb2c:	f1 f4       	brne	.+60     	; 0xfb6a <ScanStandaloneFlow+0xce>
    fb2e:	80 91 ce 03 	lds	r24, 0x03CE
    fb32:	80 36       	cpi	r24, 0x60	; 96
    fb34:	d1 f4       	brne	.+52     	; 0xfb6a <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    fb36:	10 92 c9 01 	sts	0x01C9, r1
	      strStandReceived[iFlow]=0;
    fb3a:	e0 91 cc 03 	lds	r30, 0x03CC
    fb3e:	f0 91 cd 03 	lds	r31, 0x03CD
    fb42:	e5 5f       	subi	r30, 0xF5	; 245
    fb44:	fa 4f       	sbci	r31, 0xFA	; 250
    fb46:	10 82       	st	Z, r1

		  //_uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    fb48:	8b e0       	ldi	r24, 0x0B	; 11
    fb4a:	95 e0       	ldi	r25, 0x05	; 5
    fb4c:	0e 94 a0 40 	call	0x8140	; 0x8140 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    fb50:	81 30       	cpi	r24, 0x01	; 1
    fb52:	29 f4       	brne	.+10     	; 0xfb5e <ScanStandaloneFlow+0xc2>
    fb54:	8b e0       	ldi	r24, 0x0B	; 11
    fb56:	95 e0       	ldi	r25, 0x05	; 5
    fb58:	0e 94 54 7a 	call	0xf4a8	; 0xf4a8 <StoreStandaloneTransData>
    fb5c:	06 c0       	rjmp	.+12     	; 0xfb6a <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    fb5e:	82 30       	cpi	r24, 0x02	; 2
    fb60:	21 f4       	brne	.+8      	; 0xfb6a <ScanStandaloneFlow+0xce>
    fb62:	8b e0       	ldi	r24, 0x0B	; 11
    fb64:	95 e0       	ldi	r25, 0x05	; 5
    fb66:	0e 94 bb 7c 	call	0xf976	; 0xf976 <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    fb6a:	80 91 d1 03 	lds	r24, 0x03D1
    fb6e:	89 30       	cpi	r24, 0x09	; 9
    fb70:	c1 f5       	brne	.+112    	; 0xfbe2 <ScanStandaloneFlow+0x146>
    fb72:	80 91 ce 03 	lds	r24, 0x03CE
    fb76:	8a 30       	cpi	r24, 0x0A	; 10
    fb78:	a1 f5       	brne	.+104    	; 0xfbe2 <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    fb7a:	90 91 cf 03 	lds	r25, 0x03CF
    fb7e:	90 93 f2 0d 	sts	0x0DF2, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    fb82:	80 91 d0 03 	lds	r24, 0x03D0
    fb86:	80 93 a7 07 	sts	0x07A7, r24
		  switch(AcknoledgeCommand){
    fb8a:	89 31       	cpi	r24, 0x19	; 25
    fb8c:	51 f0       	breq	.+20     	; 0xfba2 <ScanStandaloneFlow+0x106>
    fb8e:	8a 31       	cpi	r24, 0x1A	; 26
    fb90:	18 f4       	brcc	.+6      	; 0xfb98 <ScanStandaloneFlow+0xfc>
    fb92:	85 30       	cpi	r24, 0x05	; 5
    fb94:	19 f5       	brne	.+70     	; 0xfbdc <ScanStandaloneFlow+0x140>
    fb96:	17 c0       	rjmp	.+46     	; 0xfbc6 <ScanStandaloneFlow+0x12a>
    fb98:	8a 31       	cpi	r24, 0x1A	; 26
    fb9a:	c9 f0       	breq	.+50     	; 0xfbce <ScanStandaloneFlow+0x132>
    fb9c:	8c 31       	cpi	r24, 0x1C	; 28
    fb9e:	f1 f4       	brne	.+60     	; 0xfbdc <ScanStandaloneFlow+0x140>
    fba0:	1a c0       	rjmp	.+52     	; 0xfbd6 <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    fba2:	90 93 a9 01 	sts	0x01A9, r25
			   IsNewPoolingSequence=True;
    fba6:	81 e0       	ldi	r24, 0x01	; 1
    fba8:	80 93 aa 01 	sts	0x01AA, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    fbac:	80 91 ad 01 	lds	r24, 0x01AD
    fbb0:	81 30       	cpi	r24, 0x01	; 1
    fbb2:	a1 f4       	brne	.+40     	; 0xfbdc <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    fbb4:	10 92 ad 01 	sts	0x01AD, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    fbb8:	80 91 b1 07 	lds	r24, 0x07B1
    fbbc:	60 91 d9 0d 	lds	r22, 0x0DD9
    fbc0:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
    fbc4:	0b c0       	rjmp	.+22     	; 0xfbdc <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    fbc6:	81 e0       	ldi	r24, 0x01	; 1
    fbc8:	80 93 db 01 	sts	0x01DB, r24
    fbcc:	07 c0       	rjmp	.+14     	; 0xfbdc <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    fbce:	81 e0       	ldi	r24, 0x01	; 1
    fbd0:	80 93 ac 01 	sts	0x01AC, r24
    fbd4:	03 c0       	rjmp	.+6      	; 0xfbdc <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    fbd6:	81 e0       	ldi	r24, 0x01	; 1
    fbd8:	80 93 38 01 	sts	0x0138, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    fbdc:	81 e0       	ldi	r24, 0x01	; 1
    fbde:	80 93 ab 01 	sts	0x01AB, r24
	  }
}
    fbe2:	1f 91       	pop	r17
    fbe4:	0f 91       	pop	r16
    fbe6:	08 95       	ret

0000fbe8 <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    fbe8:	1f 92       	push	r1
    fbea:	0f 92       	push	r0
    fbec:	0f b6       	in	r0, 0x3f	; 63
    fbee:	0f 92       	push	r0
    fbf0:	0b b6       	in	r0, 0x3b	; 59
    fbf2:	0f 92       	push	r0
    fbf4:	11 24       	eor	r1, r1
    fbf6:	1f 93       	push	r17
    fbf8:	2f 93       	push	r18
    fbfa:	3f 93       	push	r19
    fbfc:	4f 93       	push	r20
    fbfe:	5f 93       	push	r21
    fc00:	6f 93       	push	r22
    fc02:	7f 93       	push	r23
    fc04:	8f 93       	push	r24
    fc06:	9f 93       	push	r25
    fc08:	af 93       	push	r26
    fc0a:	bf 93       	push	r27
    fc0c:	ef 93       	push	r30
    fc0e:	ff 93       	push	r31
char dataSPI;
char Reply=0;
    //_uart(0,1,SPDR);
	dataSPI=SPDR;
    fc10:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    fc12:	81 2f       	mov	r24, r17
    fc14:	0e 94 aa 13 	call	0x2754	; 0x2754 <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    fc18:	80 91 25 01 	lds	r24, 0x0125
    fc1c:	81 30       	cpi	r24, 0x01	; 1
    fc1e:	21 f4       	brne	.+8      	; 0xfc28 <__vector_17+0x40>
    fc20:	81 2f       	mov	r24, r17
    fc22:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <ScanEDCFlow>
    fc26:	05 c0       	rjmp	.+10     	; 0xfc32 <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    fc28:	82 30       	cpi	r24, 0x02	; 2
    fc2a:	19 f4       	brne	.+6      	; 0xfc32 <__vector_17+0x4a>
    fc2c:	81 2f       	mov	r24, r17
    fc2e:	0e 94 4e 7d 	call	0xfa9c	; 0xfa9c <ScanStandaloneFlow>
}
    fc32:	ff 91       	pop	r31
    fc34:	ef 91       	pop	r30
    fc36:	bf 91       	pop	r27
    fc38:	af 91       	pop	r26
    fc3a:	9f 91       	pop	r25
    fc3c:	8f 91       	pop	r24
    fc3e:	7f 91       	pop	r23
    fc40:	6f 91       	pop	r22
    fc42:	5f 91       	pop	r21
    fc44:	4f 91       	pop	r20
    fc46:	3f 91       	pop	r19
    fc48:	2f 91       	pop	r18
    fc4a:	1f 91       	pop	r17
    fc4c:	0f 90       	pop	r0
    fc4e:	0b be       	out	0x3b, r0	; 59
    fc50:	0f 90       	pop	r0
    fc52:	0f be       	out	0x3f, r0	; 63
    fc54:	0f 90       	pop	r0
    fc56:	1f 90       	pop	r1
    fc58:	18 95       	reti

0000fc5a <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    fc5a:	8f 92       	push	r8
    fc5c:	9f 92       	push	r9
    fc5e:	af 92       	push	r10
    fc60:	bf 92       	push	r11
    fc62:	cf 92       	push	r12
    fc64:	df 92       	push	r13
    fc66:	ef 92       	push	r14
    fc68:	ff 92       	push	r15
    fc6a:	0f 93       	push	r16
    fc6c:	1f 93       	push	r17
    fc6e:	cf 93       	push	r28
    fc70:	df 93       	push	r29
    fc72:	f8 2e       	mov	r15, r24
    fc74:	96 2e       	mov	r9, r22
    fc76:	d4 2e       	mov	r13, r20
    fc78:	e9 01       	movw	r28, r18
    fc7a:	58 01       	movw	r10, r16
    fc7c:	8e 2c       	mov	r8, r14
	 static char iHit=0,KeyByte=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;
	 static unsigned int iLoop=0,TimerPressed=0,KeyTimeout,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    fc7e:	10 91 84 03 	lds	r17, 0x0384
    fc82:	12 30       	cpi	r17, 0x02	; 2
    fc84:	09 f4       	brne	.+2      	; 0xfc88 <UserInput+0x2e>
    fc86:	2c c2       	rjmp	.+1112   	; 0x100e0 <UserInput+0x486>
    fc88:	13 30       	cpi	r17, 0x03	; 3
    fc8a:	30 f4       	brcc	.+12     	; 0xfc98 <UserInput+0x3e>
    fc8c:	11 23       	and	r17, r17
    fc8e:	59 f0       	breq	.+22     	; 0xfca6 <UserInput+0x4c>
    fc90:	11 30       	cpi	r17, 0x01	; 1
    fc92:	09 f0       	breq	.+2      	; 0xfc96 <UserInput+0x3c>
    fc94:	f5 c2       	rjmp	.+1514   	; 0x10280 <UserInput+0x626>
    fc96:	2c c0       	rjmp	.+88     	; 0xfcf0 <UserInput+0x96>
    fc98:	13 30       	cpi	r17, 0x03	; 3
    fc9a:	09 f4       	brne	.+2      	; 0xfc9e <UserInput+0x44>
    fc9c:	76 c2       	rjmp	.+1260   	; 0x1018a <UserInput+0x530>
    fc9e:	14 30       	cpi	r17, 0x04	; 4
    fca0:	09 f0       	breq	.+2      	; 0xfca4 <UserInput+0x4a>
    fca2:	ee c2       	rjmp	.+1500   	; 0x10280 <UserInput+0x626>
    fca4:	ef c2       	rjmp	.+1502   	; 0x10284 <UserInput+0x62a>
	 case uiInit:
	      iLoop=0;
    fca6:	10 92 76 03 	sts	0x0376, r1
    fcaa:	10 92 75 03 	sts	0x0375, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    fcae:	60 93 83 03 	sts	0x0383, r22
    fcb2:	40 93 82 03 	sts	0x0382, r20
          iValuePos=0;
    fcb6:	10 92 81 03 	sts	0x0381, r1
		  KeyTimeout=0;
    fcba:	10 92 74 03 	sts	0x0374, r1
    fcbe:	10 92 73 03 	sts	0x0373, r1
		  IsSameKey=False;
    fcc2:	10 92 7a 03 	sts	0x037A, r1
		  IsNextKey=False;
    fcc6:	10 92 79 03 	sts	0x0379, r1
		  IsNewKey=False;
    fcca:	10 92 78 03 	sts	0x0378, r1
		  IsShifted=True;
    fcce:	91 e0       	ldi	r25, 0x01	; 1
    fcd0:	90 93 7b 03 	sts	0x037B, r25
		  zKeyChar=' ';
    fcd4:	80 e2       	ldi	r24, 0x20	; 32
    fcd6:	80 93 80 03 	sts	0x0380, r24
		  iHit=0;
    fcda:	10 92 7c 03 	sts	0x037C, r1
		  IsFirst=False;
    fcde:	10 92 77 03 	sts	0x0377, r1
		  IsDelete=False;
    fce2:	10 92 7d 03 	sts	0x037D, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    fce6:	90 93 84 03 	sts	0x0384, r25
    fcea:	95 e0       	ldi	r25, 0x05	; 5
    fcec:	e9 2e       	mov	r14, r25
    fcee:	ce c2       	rjmp	.+1436   	; 0x1028c <UserInput+0x632>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    fcf0:	81 e0       	ldi	r24, 0x01	; 1
    fcf2:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
    fcf6:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    fcf8:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
    fcfc:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    fcfe:	2b e7       	ldi	r18, 0x7B	; 123
    fd00:	c2 16       	cp	r12, r18
    fd02:	59 f4       	brne	.+22     	; 0xfd1a <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
    fd04:	80 91 7b 03 	lds	r24, 0x037B
    fd08:	88 23       	and	r24, r24
    fd0a:	19 f4       	brne	.+6      	; 0xfd12 <UserInput+0xb8>
    fd0c:	10 93 7b 03 	sts	0x037B, r17
    fd10:	04 c0       	rjmp	.+8      	; 0xfd1a <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
    fd12:	81 30       	cpi	r24, 0x01	; 1
    fd14:	11 f4       	brne	.+4      	; 0xfd1a <UserInput+0xc0>
    fd16:	10 92 7b 03 	sts	0x037B, r1
			  }
          
		  if (IsSameKey==True){
    fd1a:	80 91 7a 03 	lds	r24, 0x037A
    fd1e:	81 30       	cpi	r24, 0x01	; 1
    fd20:	e9 f4       	brne	.+58     	; 0xfd5c <UserInput+0x102>
		      KeyTimeout++;
    fd22:	80 91 73 03 	lds	r24, 0x0373
    fd26:	90 91 74 03 	lds	r25, 0x0374
    fd2a:	01 96       	adiw	r24, 0x01	; 1
    fd2c:	90 93 74 03 	sts	0x0374, r25
    fd30:	80 93 73 03 	sts	0x0373, r24
              if (KeyTimeout>1000){
    fd34:	89 5e       	subi	r24, 0xE9	; 233
    fd36:	93 40       	sbci	r25, 0x03	; 3
    fd38:	88 f0       	brcs	.+34     	; 0xfd5c <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    fd3a:	f5 e0       	ldi	r31, 0x05	; 5
    fd3c:	ff 16       	cp	r15, r31
    fd3e:	39 f4       	brne	.+14     	; 0xfd4e <UserInput+0xf4>
    fd40:	80 91 83 03 	lds	r24, 0x0383
    fd44:	60 91 82 03 	lds	r22, 0x0382
    fd48:	4a e2       	ldi	r20, 0x2A	; 42
    fd4a:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>

		          IsNextKey=True;
    fd4e:	81 e0       	ldi	r24, 0x01	; 1
    fd50:	80 93 79 03 	sts	0x0379, r24
				  iLoop=0;
    fd54:	10 92 76 03 	sts	0x0376, r1
    fd58:	10 92 75 03 	sts	0x0375, r1
			     }
              }
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
    fd5c:	8e 2d       	mov	r24, r14
    fd5e:	80 53       	subi	r24, 0x30	; 48
    fd60:	8a 30       	cpi	r24, 0x0A	; 10
    fd62:	20 f4       	brcc	.+8      	; 0xfd6c <UserInput+0x112>
    fd64:	80 91 81 03 	lds	r24, 0x0381
    fd68:	88 15       	cp	r24, r8
    fd6a:	40 f0       	brcs	.+16     	; 0xfd7c <UserInput+0x122>
    fd6c:	80 91 79 03 	lds	r24, 0x0379
    fd70:	81 30       	cpi	r24, 0x01	; 1
    fd72:	21 f0       	breq	.+8      	; 0xfd7c <UserInput+0x122>
    fd74:	ee 24       	eor	r14, r14
    fd76:	00 e0       	ldi	r16, 0x00	; 0
    fd78:	10 e0       	ldi	r17, 0x00	; 0
    fd7a:	be c0       	rjmp	.+380    	; 0xfef8 <UserInput+0x29e>
    fd7c:	84 e2       	ldi	r24, 0x24	; 36
    fd7e:	94 ef       	ldi	r25, 0xF4	; 244
    fd80:	01 97       	sbiw	r24, 0x01	; 1
    fd82:	f1 f7       	brne	.-4      	; 0xfd80 <UserInput+0x126>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    fd84:	80 91 81 03 	lds	r24, 0x0381
    fd88:	fe 01       	movw	r30, r28
    fd8a:	e8 0f       	add	r30, r24
    fd8c:	f1 1d       	adc	r31, r1
    fd8e:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    fd90:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    fd92:	8f 2d       	mov	r24, r15
    fd94:	81 50       	subi	r24, 0x01	; 1
    fd96:	82 30       	cpi	r24, 0x02	; 2
    fd98:	30 f0       	brcs	.+12     	; 0xfda6 <UserInput+0x14c>
    fd9a:	24 e0       	ldi	r18, 0x04	; 4
    fd9c:	f2 16       	cp	r15, r18
    fd9e:	19 f0       	breq	.+6      	; 0xfda6 <UserInput+0x14c>
    fda0:	00 e0       	ldi	r16, 0x00	; 0
    fda2:	10 e0       	ldi	r17, 0x00	; 0
    fda4:	04 c0       	rjmp	.+8      	; 0xfdae <UserInput+0x154>
			        NumbValue=atoi(strResult);
    fda6:	ce 01       	movw	r24, r28
    fda8:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
    fdac:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    fdae:	83 e0       	ldi	r24, 0x03	; 3
    fdb0:	f8 16       	cp	r15, r24
    fdb2:	21 f0       	breq	.+8      	; 0xfdbc <UserInput+0x162>
    fdb4:	e5 e0       	ldi	r30, 0x05	; 5
    fdb6:	fe 16       	cp	r15, r30
    fdb8:	09 f0       	breq	.+2      	; 0xfdbc <UserInput+0x162>
    fdba:	63 c0       	rjmp	.+198    	; 0xfe82 <UserInput+0x228>
			       if (KeyChar!=zKeyChar){
    fdbc:	80 91 80 03 	lds	r24, 0x0380
    fdc0:	e8 16       	cp	r14, r24
    fdc2:	71 f0       	breq	.+28     	; 0xfde0 <UserInput+0x186>
					   IsSameKey=False;
    fdc4:	10 92 7a 03 	sts	0x037A, r1
					   IsNewKey=True;
    fdc8:	81 e0       	ldi	r24, 0x01	; 1
    fdca:	80 93 78 03 	sts	0x0378, r24
				       iHit=0;
    fdce:	10 92 7c 03 	sts	0x037C, r1
					   iLoop=1000;
    fdd2:	88 ee       	ldi	r24, 0xE8	; 232
    fdd4:	93 e0       	ldi	r25, 0x03	; 3
    fdd6:	90 93 76 03 	sts	0x0376, r25
    fdda:	80 93 75 03 	sts	0x0375, r24
    fdde:	51 c0       	rjmp	.+162    	; 0xfe82 <UserInput+0x228>
				   }
                   else{
				   if (IsNewKey==True){
    fde0:	80 91 78 03 	lds	r24, 0x0378
    fde4:	81 30       	cpi	r24, 0x01	; 1
    fde6:	71 f4       	brne	.+28     	; 0xfe04 <UserInput+0x1aa>
					   IsNewKey=False;
    fde8:	10 92 78 03 	sts	0x0378, r1
					   yChar--;
    fdec:	80 91 82 03 	lds	r24, 0x0382
    fdf0:	81 50       	subi	r24, 0x01	; 1
    fdf2:	80 93 82 03 	sts	0x0382, r24
					   if (iValuePos>0) iValuePos--;
    fdf6:	80 91 81 03 	lds	r24, 0x0381
    fdfa:	88 23       	and	r24, r24
    fdfc:	19 f0       	breq	.+6      	; 0xfe04 <UserInput+0x1aa>
    fdfe:	81 50       	subi	r24, 0x01	; 1
    fe00:	80 93 81 03 	sts	0x0381, r24
					   }
				   KeyTimeout=0;
    fe04:	10 92 74 03 	sts	0x0374, r1
    fe08:	10 92 73 03 	sts	0x0373, r1
				   IsSameKey=True;
    fe0c:	81 e0       	ldi	r24, 0x01	; 1
    fe0e:	80 93 7a 03 	sts	0x037A, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) iHit++;
    fe12:	80 91 7c 03 	lds	r24, 0x037C
    fe16:	e0 91 80 03 	lds	r30, 0x0380
    fe1a:	f0 e0       	ldi	r31, 0x00	; 0
    fe1c:	e0 5b       	subi	r30, 0xB0	; 176
    fe1e:	fc 4f       	sbci	r31, 0xFC	; 252
    fe20:	e4 91       	lpm	r30, Z+
    fe22:	8e 17       	cp	r24, r30
    fe24:	20 f4       	brcc	.+8      	; 0xfe2e <UserInput+0x1d4>
    fe26:	8f 5f       	subi	r24, 0xFF	; 255
    fe28:	80 93 7c 03 	sts	0x037C, r24
    fe2c:	02 c0       	rjmp	.+4      	; 0xfe32 <UserInput+0x1d8>
                   else iHit=0;
    fe2e:	10 92 7c 03 	sts	0x037C, r1
				   iLoop=1000;
    fe32:	88 ee       	ldi	r24, 0xE8	; 232
    fe34:	93 e0       	ldi	r25, 0x03	; 3
    fe36:	90 93 76 03 	sts	0x0376, r25
    fe3a:	80 93 75 03 	sts	0x0375, r24

                   zAlphaChar=AlphaChar;
    fe3e:	80 91 7e 03 	lds	r24, 0x037E
    fe42:	80 93 7f 03 	sts	0x037F, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    fe46:	80 91 7b 03 	lds	r24, 0x037B
    fe4a:	6c 2d       	mov	r22, r12
    fe4c:	40 91 7c 03 	lds	r20, 0x037C
    fe50:	0e 94 29 ae 	call	0x15c52	; 0x15c52 <_table_alphanum>
    fe54:	80 93 7e 03 	sts	0x037E, r24
                   
				   if (IsNextKey==True){
    fe58:	80 91 79 03 	lds	r24, 0x0379
    fe5c:	81 30       	cpi	r24, 0x01	; 1
    fe5e:	41 f4       	brne	.+16     	; 0xfe70 <UserInput+0x216>
                       AlphaChar=zAlphaChar;       
    fe60:	80 91 7f 03 	lds	r24, 0x037F
    fe64:	80 93 7e 03 	sts	0x037E, r24
					   IsNextKey=False;
    fe68:	10 92 79 03 	sts	0x0379, r1
					   IsSameKey=False;
    fe6c:	10 92 7a 03 	sts	0x037A, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    fe70:	80 91 81 03 	lds	r24, 0x0381
    fe74:	fe 01       	movw	r30, r28
    fe76:	e8 0f       	add	r30, r24
    fe78:	f1 1d       	adc	r31, r1
    fe7a:	80 91 7e 03 	lds	r24, 0x037E
    fe7e:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    fe80:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    fe82:	f2 e0       	ldi	r31, 0x02	; 2
    fe84:	ff 16       	cp	r15, r31
    fe86:	71 f4       	brne	.+28     	; 0xfea4 <UserInput+0x24a>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fe88:	a0 16       	cp	r10, r16
    fe8a:	b1 06       	cpc	r11, r17
    fe8c:	18 f4       	brcc	.+6      	; 0xfe94 <UserInput+0x23a>
    fe8e:	a1 14       	cp	r10, r1
    fe90:	b1 04       	cpc	r11, r1
    fe92:	71 f5       	brne	.+92     	; 0xfef0 <UserInput+0x296>
				     iValuePos++;
    fe94:	80 91 81 03 	lds	r24, 0x0381
    fe98:	8f 5f       	subi	r24, 0xFF	; 255
    fe9a:	80 93 81 03 	sts	0x0381, r24
					 stUserInput=uiInputDisp;
    fe9e:	83 e0       	ldi	r24, 0x03	; 3
    fea0:	80 93 84 03 	sts	0x0384, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fea4:	a0 16       	cp	r10, r16
    fea6:	b1 06       	cpc	r11, r17
    fea8:	18 f4       	brcc	.+6      	; 0xfeb0 <UserInput+0x256>
    feaa:	a1 14       	cp	r10, r1
    feac:	b1 04       	cpc	r11, r1
    feae:	01 f5       	brne	.+64     	; 0xfef0 <UserInput+0x296>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    feb0:	21 e0       	ldi	r18, 0x01	; 1
    feb2:	f2 16       	cp	r15, r18
    feb4:	49 f0       	breq	.+18     	; 0xfec8 <UserInput+0x26e>
    feb6:	83 e0       	ldi	r24, 0x03	; 3
    feb8:	f8 16       	cp	r15, r24
    feba:	31 f0       	breq	.+12     	; 0xfec8 <UserInput+0x26e>
    febc:	e4 e0       	ldi	r30, 0x04	; 4
    febe:	fe 16       	cp	r15, r30
    fec0:	19 f0       	breq	.+6      	; 0xfec8 <UserInput+0x26e>
    fec2:	f5 e0       	ldi	r31, 0x05	; 5
    fec4:	ff 16       	cp	r15, r31
    fec6:	a1 f4       	brne	.+40     	; 0xfef0 <UserInput+0x296>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    fec8:	80 91 7a 03 	lds	r24, 0x037A
    fecc:	88 23       	and	r24, r24
    fece:	69 f4       	brne	.+26     	; 0xfeea <UserInput+0x290>
					      IsFirst=True;
    fed0:	81 e0       	ldi	r24, 0x01	; 1
    fed2:	80 93 77 03 	sts	0x0377, r24
					      iValuePos++;
    fed6:	80 91 81 03 	lds	r24, 0x0381
    feda:	8f 5f       	subi	r24, 0xFF	; 255
    fedc:	80 93 81 03 	sts	0x0381, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
    fee0:	80 91 82 03 	lds	r24, 0x0382
    fee4:	8f 5f       	subi	r24, 0xFF	; 255
    fee6:	80 93 82 03 	sts	0x0382, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
    feea:	83 e0       	ldi	r24, 0x03	; 3
    feec:	80 93 84 03 	sts	0x0384, r24
				  }
			   }
              zKeyChar=KeyChar;
    fef0:	e0 92 80 03 	sts	0x0380, r14
    fef4:	84 e0       	ldi	r24, 0x04	; 4
    fef6:	e8 2e       	mov	r14, r24
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    fef8:	2f 2d       	mov	r18, r15
    fefa:	21 50       	subi	r18, 0x01	; 1
    fefc:	22 30       	cpi	r18, 0x02	; 2
    fefe:	18 f0       	brcs	.+6      	; 0xff06 <UserInput+0x2ac>
    ff00:	84 e0       	ldi	r24, 0x04	; 4
    ff02:	f8 16       	cp	r15, r24
    ff04:	89 f4       	brne	.+34     	; 0xff28 <UserInput+0x2ce>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    ff06:	a0 16       	cp	r10, r16
    ff08:	b1 06       	cpc	r11, r17
    ff0a:	20 f0       	brcs	.+8      	; 0xff14 <UserInput+0x2ba>
    ff0c:	80 91 81 03 	lds	r24, 0x0381
    ff10:	88 15       	cp	r24, r8
    ff12:	51 f4       	brne	.+20     	; 0xff28 <UserInput+0x2ce>
			           if (MaxValue>0)system_beep(1);
    ff14:	ab 28       	or	r10, r11
    ff16:	41 f0       	breq	.+16     	; 0xff28 <UserInput+0x2ce>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    ff18:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    ff1a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    ff1c:	81 e0       	ldi	r24, 0x01	; 1
    ff1e:	90 e0       	ldi	r25, 0x00	; 0
    ff20:	90 93 ed 01 	sts	0x01ED, r25
    ff24:	80 93 ec 01 	sts	0x01EC, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    ff28:	e7 ee       	ldi	r30, 0xE7	; 231
    ff2a:	ce 16       	cp	r12, r30
    ff2c:	71 f4       	brne	.+28     	; 0xff4a <UserInput+0x2f0>
		      if (iValuePos>0){
    ff2e:	80 91 81 03 	lds	r24, 0x0381
    ff32:	88 23       	and	r24, r24
    ff34:	41 f0       	breq	.+16     	; 0xff46 <UserInput+0x2ec>
			      iLoop=1999;
    ff36:	8f ec       	ldi	r24, 0xCF	; 207
    ff38:	97 e0       	ldi	r25, 0x07	; 7
    ff3a:	90 93 76 03 	sts	0x0376, r25
    ff3e:	80 93 75 03 	sts	0x0375, r24
				  stUserInput=uiClearDisplay;
    ff42:	82 e0       	ldi	r24, 0x02	; 2
    ff44:	26 c0       	rjmp	.+76     	; 0xff92 <UserInput+0x338>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    ff46:	81 e0       	ldi	r24, 0x01	; 1
    ff48:	21 c0       	rjmp	.+66     	; 0xff8c <UserInput+0x332>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    ff4a:	f7 eb       	ldi	r31, 0xB7	; 183
    ff4c:	cf 16       	cp	r12, r31
    ff4e:	19 f5       	brne	.+70     	; 0xff96 <UserInput+0x33c>
		      strResult[iValuePos]=0;
    ff50:	80 91 81 03 	lds	r24, 0x0381
    ff54:	fe 01       	movw	r30, r28
    ff56:	e8 0f       	add	r30, r24
    ff58:	f1 1d       	adc	r31, r1
    ff5a:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    ff5c:	22 30       	cpi	r18, 0x02	; 2
    ff5e:	a8 f4       	brcc	.+42     	; 0xff8a <UserInput+0x330>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    ff60:	88 23       	and	r24, r24
    ff62:	81 f4       	brne	.+32     	; 0xff84 <UserInput+0x32a>
    ff64:	00 d0       	rcall	.+0      	; 0xff66 <UserInput+0x30c>
    ff66:	00 d0       	rcall	.+0      	; 0xff68 <UserInput+0x30e>
    ff68:	ed b7       	in	r30, 0x3d	; 61
    ff6a:	fe b7       	in	r31, 0x3e	; 62
    ff6c:	d2 83       	std	Z+2, r29	; 0x02
    ff6e:	c1 83       	std	Z+1, r28	; 0x01
    ff70:	82 e0       	ldi	r24, 0x02	; 2
    ff72:	9b e1       	ldi	r25, 0x1B	; 27
    ff74:	94 83       	std	Z+4, r25	; 0x04
    ff76:	83 83       	std	Z+3, r24	; 0x03
    ff78:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    ff7c:	0f 90       	pop	r0
    ff7e:	0f 90       	pop	r0
    ff80:	0f 90       	pop	r0
    ff82:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    ff84:	ce 01       	movw	r24, r28
    ff86:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    ff8a:	83 e0       	ldi	r24, 0x03	; 3
    ff8c:	80 93 85 03 	sts	0x0385, r24
		      stUserInput=uiFinished;
    ff90:	84 e0       	ldi	r24, 0x04	; 4
    ff92:	80 93 84 03 	sts	0x0384, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    ff96:	80 91 75 03 	lds	r24, 0x0375
    ff9a:	90 91 76 03 	lds	r25, 0x0376
    ff9e:	60 ed       	ldi	r22, 0xD0	; 208
    ffa0:	77 e0       	ldi	r23, 0x07	; 7
    ffa2:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
    ffa6:	89 2b       	or	r24, r25
    ffa8:	09 f0       	breq	.+2      	; 0xffac <UserInput+0x352>
    ffaa:	4b c0       	rjmp	.+150    	; 0x10042 <UserInput+0x3e8>
		      if (IsSameKey==True)
    ffac:	80 91 7a 03 	lds	r24, 0x037A
    ffb0:	81 30       	cpi	r24, 0x01	; 1
    ffb2:	c9 f4       	brne	.+50     	; 0xffe6 <UserInput+0x38c>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
    ffb4:	20 91 81 03 	lds	r18, 0x0381
    ffb8:	82 2f       	mov	r24, r18
    ffba:	90 e0       	ldi	r25, 0x00	; 0
    ffbc:	01 97       	sbiw	r24, 0x01	; 1
    ffbe:	8d 0d       	add	r24, r13
    ffc0:	91 1d       	adc	r25, r1
    ffc2:	64 e1       	ldi	r22, 0x14	; 20
    ffc4:	70 e0       	ldi	r23, 0x00	; 0
    ffc6:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
    ffca:	36 2f       	mov	r19, r22
    ffcc:	82 2f       	mov	r24, r18
    ffce:	64 e1       	ldi	r22, 0x14	; 20
    ffd0:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
    ffd4:	6d 2d       	mov	r22, r13
    ffd6:	69 0f       	add	r22, r25
    ffd8:	89 2d       	mov	r24, r9
    ffda:	83 0f       	add	r24, r19
    ffdc:	40 91 7e 03 	lds	r20, 0x037E
    ffe0:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
    ffe4:	2e c0       	rjmp	.+92     	; 0x10042 <UserInput+0x3e8>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    ffe6:	f5 e0       	ldi	r31, 0x05	; 5
    ffe8:	ff 16       	cp	r15, r31
    ffea:	61 f4       	brne	.+24     	; 0x10004 <UserInput+0x3aa>
    ffec:	80 91 81 03 	lds	r24, 0x0381
    fff0:	88 23       	and	r24, r24
    fff2:	41 f0       	breq	.+16     	; 0x10004 <UserInput+0x3aa>
    fff4:	60 91 82 03 	lds	r22, 0x0382
    fff8:	61 50       	subi	r22, 0x01	; 1
    fffa:	80 91 83 03 	lds	r24, 0x0383
    fffe:	4a e2       	ldi	r20, 0x2A	; 42
   10000:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
   10004:	20 91 81 03 	lds	r18, 0x0381
   10008:	82 2f       	mov	r24, r18
   1000a:	90 e0       	ldi	r25, 0x00	; 0
   1000c:	01 97       	sbiw	r24, 0x01	; 1
   1000e:	8d 0d       	add	r24, r13
   10010:	91 1d       	adc	r25, r1
   10012:	64 e1       	ldi	r22, 0x14	; 20
   10014:	70 e0       	ldi	r23, 0x00	; 0
   10016:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   1001a:	36 2f       	mov	r19, r22
   1001c:	82 2f       	mov	r24, r18
   1001e:	64 e1       	ldi	r22, 0x14	; 20
   10020:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
   10024:	6d 2d       	mov	r22, r13
   10026:	69 0f       	add	r22, r25
   10028:	89 2d       	mov	r24, r9
   1002a:	83 0f       	add	r24, r19
   1002c:	4f e5       	ldi	r20, 0x5F	; 95
   1002e:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>

				  if (IsFirst==True){
   10032:	80 91 77 03 	lds	r24, 0x0377
   10036:	81 30       	cpi	r24, 0x01	; 1
   10038:	21 f4       	brne	.+8      	; 0x10042 <UserInput+0x3e8>
				      IsFirst=False;
   1003a:	10 92 77 03 	sts	0x0377, r1
				      zKeyChar=0;
   1003e:	10 92 80 03 	sts	0x0380, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
   10042:	80 91 75 03 	lds	r24, 0x0375
   10046:	90 91 76 03 	lds	r25, 0x0376
   1004a:	60 ed       	ldi	r22, 0xD0	; 208
   1004c:	77 e0       	ldi	r23, 0x07	; 7
   1004e:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
   10052:	88 5e       	subi	r24, 0xE8	; 232
   10054:	93 40       	sbci	r25, 0x03	; 3
   10056:	d1 f5       	brne	.+116    	; 0x100cc <UserInput+0x472>
		      if (IsSameKey==True){
   10058:	80 91 7a 03 	lds	r24, 0x037A
   1005c:	81 30       	cpi	r24, 0x01	; 1
   1005e:	f9 f4       	brne	.+62     	; 0x1009e <UserInput+0x444>
			      if (TypeUI!=UI_NUM_PASSWORD)
   10060:	84 e0       	ldi	r24, 0x04	; 4
   10062:	f8 16       	cp	r15, r24
   10064:	b1 f0       	breq	.+44     	; 0x10092 <UserInput+0x438>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
   10066:	80 91 81 03 	lds	r24, 0x0381
   1006a:	90 e0       	ldi	r25, 0x00	; 0
   1006c:	01 97       	sbiw	r24, 0x01	; 1
   1006e:	8d 0d       	add	r24, r13
   10070:	91 1d       	adc	r25, r1
   10072:	64 e1       	ldi	r22, 0x14	; 20
   10074:	70 e0       	ldi	r23, 0x00	; 0
   10076:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   1007a:	26 2f       	mov	r18, r22
   1007c:	80 91 82 03 	lds	r24, 0x0382
   10080:	65 e1       	ldi	r22, 0x15	; 21
   10082:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
   10086:	89 2d       	mov	r24, r9
   10088:	82 0f       	add	r24, r18
   1008a:	69 2f       	mov	r22, r25
   1008c:	40 91 7e 03 	lds	r20, 0x037E
   10090:	1b c0       	rjmp	.+54     	; 0x100c8 <UserInput+0x46e>
					   
				  else lcd_put(xChar,yChar,'*'); 
   10092:	80 91 83 03 	lds	r24, 0x0383
   10096:	60 91 82 03 	lds	r22, 0x0382
   1009a:	4a e2       	ldi	r20, 0x2A	; 42
   1009c:	15 c0       	rjmp	.+42     	; 0x100c8 <UserInput+0x46e>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
   1009e:	20 91 81 03 	lds	r18, 0x0381
   100a2:	82 2f       	mov	r24, r18
   100a4:	90 e0       	ldi	r25, 0x00	; 0
   100a6:	01 97       	sbiw	r24, 0x01	; 1
   100a8:	8d 0d       	add	r24, r13
   100aa:	91 1d       	adc	r25, r1
   100ac:	64 e1       	ldi	r22, 0x14	; 20
   100ae:	70 e0       	ldi	r23, 0x00	; 0
   100b0:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   100b4:	36 2f       	mov	r19, r22
   100b6:	82 2f       	mov	r24, r18
   100b8:	64 e1       	ldi	r22, 0x14	; 20
   100ba:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
   100be:	d9 0e       	add	r13, r25
   100c0:	89 2d       	mov	r24, r9
   100c2:	83 0f       	add	r24, r19
   100c4:	6d 2d       	mov	r22, r13
   100c6:	40 e2       	ldi	r20, 0x20	; 32
   100c8:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			  }
          iLoop++;
   100cc:	80 91 75 03 	lds	r24, 0x0375
   100d0:	90 91 76 03 	lds	r25, 0x0376
   100d4:	01 96       	adiw	r24, 0x01	; 1
   100d6:	90 93 76 03 	sts	0x0376, r25
   100da:	80 93 75 03 	sts	0x0375, r24
   100de:	d6 c0       	rjmp	.+428    	; 0x1028c <UserInput+0x632>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
   100e0:	e2 e0       	ldi	r30, 0x02	; 2
   100e2:	8e 17       	cp	r24, r30
   100e4:	99 f4       	brne	.+38     	; 0x1010c <UserInput+0x4b2>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
   100e6:	60 91 82 03 	lds	r22, 0x0382
   100ea:	80 91 81 03 	lds	r24, 0x0381
   100ee:	68 1b       	sub	r22, r24
   100f0:	80 91 83 03 	lds	r24, 0x0383
   100f4:	40 e2       	ldi	r20, 0x20	; 32
   100f6:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
		      strResult[iValuePos]=0;
   100fa:	80 91 81 03 	lds	r24, 0x0381
   100fe:	c8 0f       	add	r28, r24
   10100:	d1 1d       	adc	r29, r1
   10102:	18 82       	st	Y, r1
		      iValuePos--;
   10104:	81 50       	subi	r24, 0x01	; 1
   10106:	80 93 81 03 	sts	0x0381, r24
   1010a:	33 c0       	rjmp	.+102    	; 0x10172 <UserInput+0x518>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
   1010c:	f1 e0       	ldi	r31, 0x01	; 1
   1010e:	8f 17       	cp	r24, r31
   10110:	49 f0       	breq	.+18     	; 0x10124 <UserInput+0x4ca>
   10112:	23 e0       	ldi	r18, 0x03	; 3
   10114:	82 17       	cp	r24, r18
   10116:	31 f0       	breq	.+12     	; 0x10124 <UserInput+0x4ca>
   10118:	84 e0       	ldi	r24, 0x04	; 4
   1011a:	f8 16       	cp	r15, r24
   1011c:	19 f0       	breq	.+6      	; 0x10124 <UserInput+0x4ca>
   1011e:	e5 e0       	ldi	r30, 0x05	; 5
   10120:	fe 16       	cp	r15, r30
   10122:	39 f5       	brne	.+78     	; 0x10172 <UserInput+0x518>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
   10124:	20 91 81 03 	lds	r18, 0x0381
   10128:	82 2f       	mov	r24, r18
   1012a:	90 e0       	ldi	r25, 0x00	; 0
   1012c:	01 97       	sbiw	r24, 0x01	; 1
   1012e:	8d 0d       	add	r24, r13
   10130:	91 1d       	adc	r25, r1
   10132:	64 e1       	ldi	r22, 0x14	; 20
   10134:	70 e0       	ldi	r23, 0x00	; 0
   10136:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   1013a:	36 2f       	mov	r19, r22
   1013c:	82 2f       	mov	r24, r18
   1013e:	64 e1       	ldi	r22, 0x14	; 20
   10140:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
   10144:	d9 0e       	add	r13, r25
   10146:	89 2d       	mov	r24, r9
   10148:	83 0f       	add	r24, r19
   1014a:	6d 2d       	mov	r22, r13
   1014c:	40 e2       	ldi	r20, 0x20	; 32
   1014e:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			  
		      strResult[iValuePos]=0;
   10152:	80 91 81 03 	lds	r24, 0x0381
   10156:	c8 0f       	add	r28, r24
   10158:	d1 1d       	adc	r29, r1
   1015a:	18 82       	st	Y, r1
		      iValuePos--;
   1015c:	81 50       	subi	r24, 0x01	; 1
   1015e:	80 93 81 03 	sts	0x0381, r24
			  yChar--;
   10162:	80 91 82 03 	lds	r24, 0x0382
   10166:	81 50       	subi	r24, 0x01	; 1
   10168:	80 93 82 03 	sts	0x0382, r24
			  IsDelete=True;
   1016c:	81 e0       	ldi	r24, 0x01	; 1
   1016e:	80 93 7d 03 	sts	0x037D, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
   10172:	80 91 81 03 	lds	r24, 0x0381
   10176:	88 23       	and	r24, r24
   10178:	19 f4       	brne	.+6      	; 0x10180 <UserInput+0x526>
   1017a:	05 e0       	ldi	r16, 0x05	; 5
   1017c:	e0 2e       	mov	r14, r16
   1017e:	01 c0       	rjmp	.+2      	; 0x10182 <UserInput+0x528>
   10180:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
   10182:	83 e0       	ldi	r24, 0x03	; 3
   10184:	80 93 84 03 	sts	0x0384, r24
   10188:	81 c0       	rjmp	.+258    	; 0x1028c <UserInput+0x632>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
   1018a:	f5 e0       	ldi	r31, 0x05	; 5
   1018c:	8f 17       	cp	r24, r31
   1018e:	19 f5       	brne	.+70     	; 0x101d6 <UserInput+0x57c>
			  if (iValuePos>0){
   10190:	80 91 81 03 	lds	r24, 0x0381
   10194:	88 23       	and	r24, r24
   10196:	a9 f0       	breq	.+42     	; 0x101c2 <UserInput+0x568>
                  lcd_put(xChar,(yChar-2),'*');
   10198:	60 91 82 03 	lds	r22, 0x0382
   1019c:	62 50       	subi	r22, 0x02	; 2
   1019e:	80 91 83 03 	lds	r24, 0x0383
   101a2:	4a e2       	ldi	r20, 0x2A	; 42
   101a4:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			      if (IsDelete==True){
   101a8:	80 91 7d 03 	lds	r24, 0x037D
   101ac:	60 91 82 03 	lds	r22, 0x0382
   101b0:	81 30       	cpi	r24, 0x01	; 1
   101b2:	71 f0       	breq	.+28     	; 0x101d0 <UserInput+0x576>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
   101b4:	61 50       	subi	r22, 0x01	; 1
   101b6:	80 91 81 03 	lds	r24, 0x0381
   101ba:	c8 0f       	add	r28, r24
   101bc:	d1 1d       	adc	r29, r1
   101be:	21 97       	sbiw	r28, 0x01	; 1
   101c0:	4d c0       	rjmp	.+154    	; 0x1025c <UserInput+0x602>
			      }
			  else{ if(IsDelete==True){
   101c2:	80 91 7d 03 	lds	r24, 0x037D
   101c6:	60 91 82 03 	lds	r22, 0x0382
   101ca:	81 30       	cpi	r24, 0x01	; 1
   101cc:	09 f0       	breq	.+2      	; 0x101d0 <UserInput+0x576>
   101ce:	45 c0       	rjmp	.+138    	; 0x1025a <UserInput+0x600>
			           IsDelete=False;
   101d0:	10 92 7d 03 	sts	0x037D, r1
   101d4:	4c c0       	rjmp	.+152    	; 0x1026e <UserInput+0x614>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
   101d6:	22 e0       	ldi	r18, 0x02	; 2
   101d8:	82 17       	cp	r24, r18
   101da:	a1 f4       	brne	.+40     	; 0x10204 <UserInput+0x5aa>
   101dc:	10 e0       	ldi	r17, 0x00	; 0
   101de:	0d c0       	rjmp	.+26     	; 0x101fa <UserInput+0x5a0>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
   101e0:	60 91 82 03 	lds	r22, 0x0382
   101e4:	68 1b       	sub	r22, r24
   101e6:	61 0f       	add	r22, r17
   101e8:	fe 01       	movw	r30, r28
   101ea:	e1 0f       	add	r30, r17
   101ec:	f1 1d       	adc	r31, r1
   101ee:	80 91 83 03 	lds	r24, 0x0383
   101f2:	40 81       	ld	r20, Z
   101f4:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
   101f8:	1f 5f       	subi	r17, 0xFF	; 255
   101fa:	80 91 81 03 	lds	r24, 0x0381
   101fe:	18 17       	cp	r17, r24
   10200:	78 f3       	brcs	.-34     	; 0x101e0 <UserInput+0x586>
   10202:	3b c0       	rjmp	.+118    	; 0x1027a <UserInput+0x620>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
   10204:	81 e0       	ldi	r24, 0x01	; 1
   10206:	f8 16       	cp	r15, r24
   10208:	19 f0       	breq	.+6      	; 0x10210 <UserInput+0x5b6>
   1020a:	e3 e0       	ldi	r30, 0x03	; 3
   1020c:	fe 16       	cp	r15, r30
   1020e:	51 f5       	brne	.+84     	; 0x10264 <UserInput+0x60a>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
   10210:	20 91 81 03 	lds	r18, 0x0381
   10214:	4d 2d       	mov	r20, r13
   10216:	50 e0       	ldi	r21, 0x00	; 0
   10218:	22 23       	and	r18, r18
   1021a:	c1 f0       	breq	.+48     	; 0x1024c <UserInput+0x5f2>
   1021c:	30 e0       	ldi	r19, 0x00	; 0
   1021e:	f9 01       	movw	r30, r18
   10220:	31 97       	sbiw	r30, 0x01	; 1
   10222:	cf 01       	movw	r24, r30
   10224:	84 0f       	add	r24, r20
   10226:	95 1f       	adc	r25, r21
   10228:	65 e1       	ldi	r22, 0x15	; 21
   1022a:	70 e0       	ldi	r23, 0x00	; 0
   1022c:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   10230:	46 2f       	mov	r20, r22
   10232:	cf 01       	movw	r24, r30
   10234:	64 e1       	ldi	r22, 0x14	; 20
   10236:	70 e0       	ldi	r23, 0x00	; 0
   10238:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   1023c:	d8 0e       	add	r13, r24
   1023e:	c2 0f       	add	r28, r18
   10240:	d3 1f       	adc	r29, r19
   10242:	21 97       	sbiw	r28, 0x01	; 1
   10244:	89 2d       	mov	r24, r9
   10246:	84 0f       	add	r24, r20
   10248:	6d 2d       	mov	r22, r13
   1024a:	0a c0       	rjmp	.+20     	; 0x10260 <UserInput+0x606>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
   1024c:	60 91 82 03 	lds	r22, 0x0382
   10250:	86 2f       	mov	r24, r22
   10252:	90 e0       	ldi	r25, 0x00	; 0
   10254:	48 17       	cp	r20, r24
   10256:	59 07       	cpc	r21, r25
   10258:	84 f4       	brge	.+32     	; 0x1027a <UserInput+0x620>
   1025a:	61 50       	subi	r22, 0x01	; 1
   1025c:	80 91 83 03 	lds	r24, 0x0383
   10260:	48 81       	ld	r20, Y
   10262:	09 c0       	rjmp	.+18     	; 0x10276 <UserInput+0x61c>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
   10264:	f4 e0       	ldi	r31, 0x04	; 4
   10266:	ff 16       	cp	r15, r31
   10268:	41 f4       	brne	.+16     	; 0x1027a <UserInput+0x620>
		      lcd_put(xChar,(yChar-1),'*');
   1026a:	60 91 82 03 	lds	r22, 0x0382
   1026e:	61 50       	subi	r22, 0x01	; 1
   10270:	80 91 83 03 	lds	r24, 0x0383
   10274:	4a e2       	ldi	r20, 0x2A	; 42
   10276:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
		  }

          stUserInput=uiInput;
   1027a:	81 e0       	ldi	r24, 0x01	; 1
   1027c:	80 93 84 03 	sts	0x0384, r24
   10280:	ee 24       	eor	r14, r14
   10282:	04 c0       	rjmp	.+8      	; 0x1028c <UserInput+0x632>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
   10284:	e0 90 85 03 	lds	r14, 0x0385
	      stUserInput=uiInit;
   10288:	10 92 84 03 	sts	0x0384, r1
	      break;
	 }
	 return Result;
}
   1028c:	8e 2d       	mov	r24, r14
   1028e:	df 91       	pop	r29
   10290:	cf 91       	pop	r28
   10292:	1f 91       	pop	r17
   10294:	0f 91       	pop	r16
   10296:	ff 90       	pop	r15
   10298:	ef 90       	pop	r14
   1029a:	df 90       	pop	r13
   1029c:	cf 90       	pop	r12
   1029e:	bf 90       	pop	r11
   102a0:	af 90       	pop	r10
   102a2:	9f 90       	pop	r9
   102a4:	8f 90       	pop	r8
   102a6:	08 95       	ret

000102a8 <TestUserInput>:
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}


char TestUserInput(){
   102a8:	6f 92       	push	r6
   102aa:	7f 92       	push	r7
   102ac:	8f 92       	push	r8
   102ae:	9f 92       	push	r9
   102b0:	af 92       	push	r10
   102b2:	bf 92       	push	r11
   102b4:	cf 92       	push	r12
   102b6:	df 92       	push	r13
   102b8:	ef 92       	push	r14
   102ba:	ff 92       	push	r15
   102bc:	0f 93       	push	r16
   102be:	1f 93       	push	r17
   102c0:	df 93       	push	r29
   102c2:	cf 93       	push	r28
   102c4:	cd b7       	in	r28, 0x3d	; 61
   102c6:	de b7       	in	r29, 0x3e	; 62
   102c8:	ce 56       	subi	r28, 0x6E	; 110
   102ca:	d0 40       	sbci	r29, 0x00	; 0
   102cc:	0f b6       	in	r0, 0x3f	; 63
   102ce:	f8 94       	cli
   102d0:	de bf       	out	0x3e, r29	; 62
   102d2:	0f be       	out	0x3f, r0	; 63
   102d4:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],strSend[30];
char SVolume[15],SMoney[15],STotalVolume[15],STotalMoney[15];
char Result;

char uiResult;
	uiResult=UserInput(UI_ALPHANUM_R,2,1,strNumber,0,10);
   102d6:	6e e0       	ldi	r22, 0x0E	; 14
   102d8:	66 2e       	mov	r6, r22
   102da:	62 e0       	ldi	r22, 0x02	; 2
   102dc:	76 2e       	mov	r7, r22
   102de:	83 e0       	ldi	r24, 0x03	; 3
   102e0:	62 e0       	ldi	r22, 0x02	; 2
   102e2:	41 e0       	ldi	r20, 0x01	; 1
   102e4:	93 01       	movw	r18, r6
   102e6:	00 e0       	ldi	r16, 0x00	; 0
   102e8:	10 e0       	ldi	r17, 0x00	; 0
   102ea:	5a e0       	ldi	r21, 0x0A	; 10
   102ec:	e5 2e       	mov	r14, r21
   102ee:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
	Result=MENU_NONE;
    if (uiResult==USER_OK){
   102f2:	83 30       	cpi	r24, 0x03	; 3
   102f4:	09 f0       	breq	.+2      	; 0x102f8 <TestUserInput+0x50>
   102f6:	ed c1       	rjmp	.+986    	; 0x106d2 <TestUserInput+0x42a>
	    sprintf_P(lcdteks,PSTR("Data:%s"),strNumber);
   102f8:	00 d0       	rcall	.+0      	; 0x102fa <TestUserInput+0x52>
   102fa:	00 d0       	rcall	.+0      	; 0x102fc <TestUserInput+0x54>
   102fc:	00 d0       	rcall	.+0      	; 0x102fe <TestUserInput+0x56>
   102fe:	ed b7       	in	r30, 0x3d	; 61
   10300:	fe b7       	in	r31, 0x3e	; 62
   10302:	31 96       	adiw	r30, 0x01	; 1
   10304:	8e 01       	movw	r16, r28
   10306:	03 5c       	subi	r16, 0xC3	; 195
   10308:	1f 4f       	sbci	r17, 0xFF	; 255
   1030a:	ad b7       	in	r26, 0x3d	; 61
   1030c:	be b7       	in	r27, 0x3e	; 62
   1030e:	12 96       	adiw	r26, 0x02	; 2
   10310:	1c 93       	st	X, r17
   10312:	0e 93       	st	-X, r16
   10314:	11 97       	sbiw	r26, 0x01	; 1
   10316:	8f e6       	ldi	r24, 0x6F	; 111
   10318:	94 e0       	ldi	r25, 0x04	; 4
   1031a:	93 83       	std	Z+3, r25	; 0x03
   1031c:	82 83       	std	Z+2, r24	; 0x02
   1031e:	75 82       	std	Z+5, r7	; 0x05
   10320:	64 82       	std	Z+4, r6	; 0x04
   10322:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   lcd_print(3,1,lcdteks);
   10326:	8d b7       	in	r24, 0x3d	; 61
   10328:	9e b7       	in	r25, 0x3e	; 62
   1032a:	06 96       	adiw	r24, 0x06	; 6
   1032c:	0f b6       	in	r0, 0x3f	; 63
   1032e:	f8 94       	cli
   10330:	9e bf       	out	0x3e, r25	; 62
   10332:	0f be       	out	0x3f, r0	; 63
   10334:	8d bf       	out	0x3d, r24	; 61
   10336:	83 e0       	ldi	r24, 0x03	; 3
   10338:	61 e0       	ldi	r22, 0x01	; 1
   1033a:	a8 01       	movw	r20, r16
   1033c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	   //FormatCurrency(strNumber);
	   //FormatMoney(strNumber);
	   //RemZeroLead(strNumber);
	   sprintf_P(SVolume,PSTR("%s"),strNumber);
   10340:	00 d0       	rcall	.+0      	; 0x10342 <TestUserInput+0x9a>
   10342:	00 d0       	rcall	.+0      	; 0x10344 <TestUserInput+0x9c>
   10344:	00 d0       	rcall	.+0      	; 0x10346 <TestUserInput+0x9e>
   10346:	ed b7       	in	r30, 0x3d	; 61
   10348:	fe b7       	in	r31, 0x3e	; 62
   1034a:	31 96       	adiw	r30, 0x01	; 1
   1034c:	7e 01       	movw	r14, r28
   1034e:	08 94       	sec
   10350:	e1 1c       	adc	r14, r1
   10352:	f1 1c       	adc	r15, r1
   10354:	ad b7       	in	r26, 0x3d	; 61
   10356:	be b7       	in	r27, 0x3e	; 62
   10358:	12 96       	adiw	r26, 0x02	; 2
   1035a:	fc 92       	st	X, r15
   1035c:	ee 92       	st	-X, r14
   1035e:	11 97       	sbiw	r26, 0x01	; 1
   10360:	8c e6       	ldi	r24, 0x6C	; 108
   10362:	94 e0       	ldi	r25, 0x04	; 4
   10364:	93 83       	std	Z+3, r25	; 0x03
   10366:	82 83       	std	Z+2, r24	; 0x02
   10368:	75 82       	std	Z+5, r7	; 0x05
   1036a:	64 82       	std	Z+4, r6	; 0x04
   1036c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   sprintf_P(SMoney,PSTR("%s"),strNumber);
   10370:	ed b7       	in	r30, 0x3d	; 61
   10372:	fe b7       	in	r31, 0x3e	; 62
   10374:	31 96       	adiw	r30, 0x01	; 1
   10376:	40 e1       	ldi	r20, 0x10	; 16
   10378:	a4 2e       	mov	r10, r20
   1037a:	b1 2c       	mov	r11, r1
   1037c:	ac 0e       	add	r10, r28
   1037e:	bd 1e       	adc	r11, r29
   10380:	ad b7       	in	r26, 0x3d	; 61
   10382:	be b7       	in	r27, 0x3e	; 62
   10384:	12 96       	adiw	r26, 0x02	; 2
   10386:	bc 92       	st	X, r11
   10388:	ae 92       	st	-X, r10
   1038a:	11 97       	sbiw	r26, 0x01	; 1
   1038c:	89 e6       	ldi	r24, 0x69	; 105
   1038e:	94 e0       	ldi	r25, 0x04	; 4
   10390:	93 83       	std	Z+3, r25	; 0x03
   10392:	82 83       	std	Z+2, r24	; 0x02
   10394:	75 82       	std	Z+5, r7	; 0x05
   10396:	64 82       	std	Z+4, r6	; 0x04
   10398:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   sprintf_P(STotalVolume,PSTR("%s"),strNumber);
   1039c:	ed b7       	in	r30, 0x3d	; 61
   1039e:	fe b7       	in	r31, 0x3e	; 62
   103a0:	31 96       	adiw	r30, 0x01	; 1
   103a2:	3f e1       	ldi	r19, 0x1F	; 31
   103a4:	83 2e       	mov	r8, r19
   103a6:	91 2c       	mov	r9, r1
   103a8:	8c 0e       	add	r8, r28
   103aa:	9d 1e       	adc	r9, r29
   103ac:	ad b7       	in	r26, 0x3d	; 61
   103ae:	be b7       	in	r27, 0x3e	; 62
   103b0:	12 96       	adiw	r26, 0x02	; 2
   103b2:	9c 92       	st	X, r9
   103b4:	8e 92       	st	-X, r8
   103b6:	11 97       	sbiw	r26, 0x01	; 1
   103b8:	86 e6       	ldi	r24, 0x66	; 102
   103ba:	94 e0       	ldi	r25, 0x04	; 4
   103bc:	93 83       	std	Z+3, r25	; 0x03
   103be:	82 83       	std	Z+2, r24	; 0x02
   103c0:	75 82       	std	Z+5, r7	; 0x05
   103c2:	64 82       	std	Z+4, r6	; 0x04
   103c4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   sprintf_P(STotalMoney,PSTR("%s"),strNumber);
   103c8:	ed b7       	in	r30, 0x3d	; 61
   103ca:	fe b7       	in	r31, 0x3e	; 62
   103cc:	31 96       	adiw	r30, 0x01	; 1
   103ce:	2e e2       	ldi	r18, 0x2E	; 46
   103d0:	c2 2e       	mov	r12, r18
   103d2:	d1 2c       	mov	r13, r1
   103d4:	cc 0e       	add	r12, r28
   103d6:	dd 1e       	adc	r13, r29
   103d8:	ad b7       	in	r26, 0x3d	; 61
   103da:	be b7       	in	r27, 0x3e	; 62
   103dc:	12 96       	adiw	r26, 0x02	; 2
   103de:	dc 92       	st	X, r13
   103e0:	ce 92       	st	-X, r12
   103e2:	11 97       	sbiw	r26, 0x01	; 1
   103e4:	83 e6       	ldi	r24, 0x63	; 99
   103e6:	94 e0       	ldi	r25, 0x04	; 4
   103e8:	93 83       	std	Z+3, r25	; 0x03
   103ea:	82 83       	std	Z+2, r24	; 0x02
   103ec:	75 82       	std	Z+5, r7	; 0x05
   103ee:	64 82       	std	Z+4, r6	; 0x04
   103f0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>

	   sprintf_P(lcdteks,PSTR("Formated:%s"),strNumber);
   103f4:	ed b7       	in	r30, 0x3d	; 61
   103f6:	fe b7       	in	r31, 0x3e	; 62
   103f8:	31 96       	adiw	r30, 0x01	; 1
   103fa:	ad b7       	in	r26, 0x3d	; 61
   103fc:	be b7       	in	r27, 0x3e	; 62
   103fe:	12 96       	adiw	r26, 0x02	; 2
   10400:	1c 93       	st	X, r17
   10402:	0e 93       	st	-X, r16
   10404:	11 97       	sbiw	r26, 0x01	; 1
   10406:	87 e5       	ldi	r24, 0x57	; 87
   10408:	94 e0       	ldi	r25, 0x04	; 4
   1040a:	93 83       	std	Z+3, r25	; 0x03
   1040c:	82 83       	std	Z+2, r24	; 0x02
   1040e:	75 82       	std	Z+5, r7	; 0x05
   10410:	64 82       	std	Z+4, r6	; 0x04
   10412:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
       lcd_print(4,1,lcdteks);
   10416:	8d b7       	in	r24, 0x3d	; 61
   10418:	9e b7       	in	r25, 0x3e	; 62
   1041a:	06 96       	adiw	r24, 0x06	; 6
   1041c:	0f b6       	in	r0, 0x3f	; 63
   1041e:	f8 94       	cli
   10420:	9e bf       	out	0x3e, r25	; 62
   10422:	0f be       	out	0x3f, r0	; 63
   10424:	8d bf       	out	0x3d, r24	; 61
   10426:	84 e0       	ldi	r24, 0x04	; 4
   10428:	61 e0       	ldi	r22, 0x01	; 1
   1042a:	a8 01       	movw	r20, r16
   1042c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	   sprintf_P(strSend,PSTR("Raw:%s"),strNumber);
   10430:	00 d0       	rcall	.+0      	; 0x10432 <TestUserInput+0x18a>
   10432:	00 d0       	rcall	.+0      	; 0x10434 <TestUserInput+0x18c>
   10434:	00 d0       	rcall	.+0      	; 0x10436 <TestUserInput+0x18e>
   10436:	ed b7       	in	r30, 0x3d	; 61
   10438:	fe b7       	in	r31, 0x3e	; 62
   1043a:	31 96       	adiw	r30, 0x01	; 1
   1043c:	8e 01       	movw	r16, r28
   1043e:	0f 5a       	subi	r16, 0xAF	; 175
   10440:	1f 4f       	sbci	r17, 0xFF	; 255
   10442:	ad b7       	in	r26, 0x3d	; 61
   10444:	be b7       	in	r27, 0x3e	; 62
   10446:	12 96       	adiw	r26, 0x02	; 2
   10448:	1c 93       	st	X, r17
   1044a:	0e 93       	st	-X, r16
   1044c:	11 97       	sbiw	r26, 0x01	; 1
   1044e:	80 e5       	ldi	r24, 0x50	; 80
   10450:	94 e0       	ldi	r25, 0x04	; 4
   10452:	93 83       	std	Z+3, r25	; 0x03
   10454:	82 83       	std	Z+2, r24	; 0x02
   10456:	75 82       	std	Z+5, r7	; 0x05
   10458:	64 82       	std	Z+4, r6	; 0x04
   1045a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   1045e:	8d b7       	in	r24, 0x3d	; 61
   10460:	9e b7       	in	r25, 0x3e	; 62
   10462:	06 96       	adiw	r24, 0x06	; 6
   10464:	0f b6       	in	r0, 0x3f	; 63
   10466:	f8 94       	cli
   10468:	9e bf       	out	0x3e, r25	; 62
   1046a:	0f be       	out	0x3f, r0	; 63
   1046c:	8d bf       	out	0x3d, r24	; 61
   1046e:	80 e0       	ldi	r24, 0x00	; 0
   10470:	61 e0       	ldi	r22, 0x01	; 1
   10472:	a8 01       	movw	r20, r16
   10474:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

	   RemoveMinus(strNumber);
   10478:	c3 01       	movw	r24, r6
   1047a:	0e 94 f7 20 	call	0x41ee	; 0x41ee <RemoveMinus>

	   sprintf_P(strSend,PSTR("Minus:%s"),strNumber);
   1047e:	00 d0       	rcall	.+0      	; 0x10480 <TestUserInput+0x1d8>
   10480:	00 d0       	rcall	.+0      	; 0x10482 <TestUserInput+0x1da>
   10482:	00 d0       	rcall	.+0      	; 0x10484 <TestUserInput+0x1dc>
   10484:	ed b7       	in	r30, 0x3d	; 61
   10486:	fe b7       	in	r31, 0x3e	; 62
   10488:	31 96       	adiw	r30, 0x01	; 1
   1048a:	ad b7       	in	r26, 0x3d	; 61
   1048c:	be b7       	in	r27, 0x3e	; 62
   1048e:	12 96       	adiw	r26, 0x02	; 2
   10490:	1c 93       	st	X, r17
   10492:	0e 93       	st	-X, r16
   10494:	11 97       	sbiw	r26, 0x01	; 1
   10496:	87 e4       	ldi	r24, 0x47	; 71
   10498:	94 e0       	ldi	r25, 0x04	; 4
   1049a:	93 83       	std	Z+3, r25	; 0x03
   1049c:	82 83       	std	Z+2, r24	; 0x02
   1049e:	75 82       	std	Z+5, r7	; 0x05
   104a0:	64 82       	std	Z+4, r6	; 0x04
   104a2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   104a6:	8d b7       	in	r24, 0x3d	; 61
   104a8:	9e b7       	in	r25, 0x3e	; 62
   104aa:	06 96       	adiw	r24, 0x06	; 6
   104ac:	0f b6       	in	r0, 0x3f	; 63
   104ae:	f8 94       	cli
   104b0:	9e bf       	out	0x3e, r25	; 62
   104b2:	0f be       	out	0x3f, r0	; 63
   104b4:	8d bf       	out	0x3d, r24	; 61
   104b6:	80 e0       	ldi	r24, 0x00	; 0
   104b8:	61 e0       	ldi	r22, 0x01	; 1
   104ba:	a8 01       	movw	r20, r16
   104bc:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

       
	   RemZeroLead(strNumber);
   104c0:	c3 01       	movw	r24, r6
   104c2:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	   sprintf_P(strSend,PSTR("Removed:%s"),strNumber);
   104c6:	00 d0       	rcall	.+0      	; 0x104c8 <TestUserInput+0x220>
   104c8:	00 d0       	rcall	.+0      	; 0x104ca <TestUserInput+0x222>
   104ca:	00 d0       	rcall	.+0      	; 0x104cc <TestUserInput+0x224>
   104cc:	ed b7       	in	r30, 0x3d	; 61
   104ce:	fe b7       	in	r31, 0x3e	; 62
   104d0:	31 96       	adiw	r30, 0x01	; 1
   104d2:	ad b7       	in	r26, 0x3d	; 61
   104d4:	be b7       	in	r27, 0x3e	; 62
   104d6:	12 96       	adiw	r26, 0x02	; 2
   104d8:	1c 93       	st	X, r17
   104da:	0e 93       	st	-X, r16
   104dc:	11 97       	sbiw	r26, 0x01	; 1
   104de:	8c e3       	ldi	r24, 0x3C	; 60
   104e0:	94 e0       	ldi	r25, 0x04	; 4
   104e2:	93 83       	std	Z+3, r25	; 0x03
   104e4:	82 83       	std	Z+2, r24	; 0x02
   104e6:	75 82       	std	Z+5, r7	; 0x05
   104e8:	64 82       	std	Z+4, r6	; 0x04
   104ea:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   104ee:	8d b7       	in	r24, 0x3d	; 61
   104f0:	9e b7       	in	r25, 0x3e	; 62
   104f2:	06 96       	adiw	r24, 0x06	; 6
   104f4:	0f b6       	in	r0, 0x3f	; 63
   104f6:	f8 94       	cli
   104f8:	9e bf       	out	0x3e, r25	; 62
   104fa:	0f be       	out	0x3f, r0	; 63
   104fc:	8d bf       	out	0x3d, r24	; 61
   104fe:	80 e0       	ldi	r24, 0x00	; 0
   10500:	61 e0       	ldi	r22, 0x01	; 1
   10502:	a8 01       	movw	r20, r16
   10504:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

RemZeroLead(SVolume);
   10508:	c7 01       	movw	r24, r14
   1050a:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
RemZeroLead(SMoney);
   1050e:	c5 01       	movw	r24, r10
   10510:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
RemZeroLead(STotalVolume);
   10514:	c4 01       	movw	r24, r8
   10516:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
RemZeroLead(STotalMoney);
   1051a:	c6 01       	movw	r24, r12
   1051c:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
       
	   
	   FormatVolume(SVolume); 
   10520:	c7 01       	movw	r24, r14
   10522:	0e 94 3b 31 	call	0x6276	; 0x6276 <FormatVolume>
	   FormatMoney(SMoney);
   10526:	c5 01       	movw	r24, r10
   10528:	0e 94 48 31 	call	0x6290	; 0x6290 <FormatMoney>
	   FormatTotalizerMoney(STotalVolume);
   1052c:	c4 01       	movw	r24, r8
   1052e:	0e 94 2e 31 	call	0x625c	; 0x625c <FormatTotalizerMoney>
	   FormatTotalizerVolume(STotalMoney);
   10532:	c6 01       	movw	r24, r12
   10534:	0e 94 21 31 	call	0x6242	; 0x6242 <FormatTotalizerVolume>

	   sprintf_P(strSend,PSTR("Volume:%s"),SVolume);
   10538:	00 d0       	rcall	.+0      	; 0x1053a <TestUserInput+0x292>
   1053a:	00 d0       	rcall	.+0      	; 0x1053c <TestUserInput+0x294>
   1053c:	00 d0       	rcall	.+0      	; 0x1053e <TestUserInput+0x296>
   1053e:	ed b7       	in	r30, 0x3d	; 61
   10540:	fe b7       	in	r31, 0x3e	; 62
   10542:	31 96       	adiw	r30, 0x01	; 1
   10544:	ad b7       	in	r26, 0x3d	; 61
   10546:	be b7       	in	r27, 0x3e	; 62
   10548:	12 96       	adiw	r26, 0x02	; 2
   1054a:	1c 93       	st	X, r17
   1054c:	0e 93       	st	-X, r16
   1054e:	11 97       	sbiw	r26, 0x01	; 1
   10550:	82 e3       	ldi	r24, 0x32	; 50
   10552:	94 e0       	ldi	r25, 0x04	; 4
   10554:	93 83       	std	Z+3, r25	; 0x03
   10556:	82 83       	std	Z+2, r24	; 0x02
   10558:	f5 82       	std	Z+5, r15	; 0x05
   1055a:	e4 82       	std	Z+4, r14	; 0x04
   1055c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   10560:	8d b7       	in	r24, 0x3d	; 61
   10562:	9e b7       	in	r25, 0x3e	; 62
   10564:	06 96       	adiw	r24, 0x06	; 6
   10566:	0f b6       	in	r0, 0x3f	; 63
   10568:	f8 94       	cli
   1056a:	9e bf       	out	0x3e, r25	; 62
   1056c:	0f be       	out	0x3f, r0	; 63
   1056e:	8d bf       	out	0x3d, r24	; 61
   10570:	80 e0       	ldi	r24, 0x00	; 0
   10572:	61 e0       	ldi	r22, 0x01	; 1
   10574:	a8 01       	movw	r20, r16
   10576:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	   sprintf_P(strSend,PSTR("Money:%s"),SMoney);
   1057a:	00 d0       	rcall	.+0      	; 0x1057c <TestUserInput+0x2d4>
   1057c:	00 d0       	rcall	.+0      	; 0x1057e <TestUserInput+0x2d6>
   1057e:	00 d0       	rcall	.+0      	; 0x10580 <TestUserInput+0x2d8>
   10580:	ed b7       	in	r30, 0x3d	; 61
   10582:	fe b7       	in	r31, 0x3e	; 62
   10584:	31 96       	adiw	r30, 0x01	; 1
   10586:	ad b7       	in	r26, 0x3d	; 61
   10588:	be b7       	in	r27, 0x3e	; 62
   1058a:	12 96       	adiw	r26, 0x02	; 2
   1058c:	1c 93       	st	X, r17
   1058e:	0e 93       	st	-X, r16
   10590:	11 97       	sbiw	r26, 0x01	; 1
   10592:	89 e2       	ldi	r24, 0x29	; 41
   10594:	94 e0       	ldi	r25, 0x04	; 4
   10596:	93 83       	std	Z+3, r25	; 0x03
   10598:	82 83       	std	Z+2, r24	; 0x02
   1059a:	b5 82       	std	Z+5, r11	; 0x05
   1059c:	a4 82       	std	Z+4, r10	; 0x04
   1059e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   105a2:	8d b7       	in	r24, 0x3d	; 61
   105a4:	9e b7       	in	r25, 0x3e	; 62
   105a6:	06 96       	adiw	r24, 0x06	; 6
   105a8:	0f b6       	in	r0, 0x3f	; 63
   105aa:	f8 94       	cli
   105ac:	9e bf       	out	0x3e, r25	; 62
   105ae:	0f be       	out	0x3f, r0	; 63
   105b0:	8d bf       	out	0x3d, r24	; 61
   105b2:	80 e0       	ldi	r24, 0x00	; 0
   105b4:	61 e0       	ldi	r22, 0x01	; 1
   105b6:	a8 01       	movw	r20, r16
   105b8:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	   sprintf_P(strSend,PSTR("TVolume:%s"),STotalVolume);
   105bc:	00 d0       	rcall	.+0      	; 0x105be <TestUserInput+0x316>
   105be:	00 d0       	rcall	.+0      	; 0x105c0 <TestUserInput+0x318>
   105c0:	00 d0       	rcall	.+0      	; 0x105c2 <TestUserInput+0x31a>
   105c2:	ed b7       	in	r30, 0x3d	; 61
   105c4:	fe b7       	in	r31, 0x3e	; 62
   105c6:	31 96       	adiw	r30, 0x01	; 1
   105c8:	ad b7       	in	r26, 0x3d	; 61
   105ca:	be b7       	in	r27, 0x3e	; 62
   105cc:	12 96       	adiw	r26, 0x02	; 2
   105ce:	1c 93       	st	X, r17
   105d0:	0e 93       	st	-X, r16
   105d2:	11 97       	sbiw	r26, 0x01	; 1
   105d4:	8e e1       	ldi	r24, 0x1E	; 30
   105d6:	94 e0       	ldi	r25, 0x04	; 4
   105d8:	93 83       	std	Z+3, r25	; 0x03
   105da:	82 83       	std	Z+2, r24	; 0x02
   105dc:	95 82       	std	Z+5, r9	; 0x05
   105de:	84 82       	std	Z+4, r8	; 0x04
   105e0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   105e4:	8d b7       	in	r24, 0x3d	; 61
   105e6:	9e b7       	in	r25, 0x3e	; 62
   105e8:	06 96       	adiw	r24, 0x06	; 6
   105ea:	0f b6       	in	r0, 0x3f	; 63
   105ec:	f8 94       	cli
   105ee:	9e bf       	out	0x3e, r25	; 62
   105f0:	0f be       	out	0x3f, r0	; 63
   105f2:	8d bf       	out	0x3d, r24	; 61
   105f4:	80 e0       	ldi	r24, 0x00	; 0
   105f6:	61 e0       	ldi	r22, 0x01	; 1
   105f8:	a8 01       	movw	r20, r16
   105fa:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	   sprintf_P(strSend,PSTR("TMoney:%s"),STotalMoney);
   105fe:	00 d0       	rcall	.+0      	; 0x10600 <TestUserInput+0x358>
   10600:	00 d0       	rcall	.+0      	; 0x10602 <TestUserInput+0x35a>
   10602:	00 d0       	rcall	.+0      	; 0x10604 <TestUserInput+0x35c>
   10604:	ed b7       	in	r30, 0x3d	; 61
   10606:	fe b7       	in	r31, 0x3e	; 62
   10608:	31 96       	adiw	r30, 0x01	; 1
   1060a:	ad b7       	in	r26, 0x3d	; 61
   1060c:	be b7       	in	r27, 0x3e	; 62
   1060e:	12 96       	adiw	r26, 0x02	; 2
   10610:	1c 93       	st	X, r17
   10612:	0e 93       	st	-X, r16
   10614:	11 97       	sbiw	r26, 0x01	; 1
   10616:	84 e1       	ldi	r24, 0x14	; 20
   10618:	94 e0       	ldi	r25, 0x04	; 4
   1061a:	93 83       	std	Z+3, r25	; 0x03
   1061c:	82 83       	std	Z+2, r24	; 0x02
   1061e:	d5 82       	std	Z+5, r13	; 0x05
   10620:	c4 82       	std	Z+4, r12	; 0x04
   10622:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   10626:	8d b7       	in	r24, 0x3d	; 61
   10628:	9e b7       	in	r25, 0x3e	; 62
   1062a:	06 96       	adiw	r24, 0x06	; 6
   1062c:	0f b6       	in	r0, 0x3f	; 63
   1062e:	f8 94       	cli
   10630:	9e bf       	out	0x3e, r25	; 62
   10632:	0f be       	out	0x3f, r0	; 63
   10634:	8d bf       	out	0x3d, r24	; 61
   10636:	80 e0       	ldi	r24, 0x00	; 0
   10638:	61 e0       	ldi	r22, 0x01	; 1
   1063a:	a8 01       	movw	r20, r16
   1063c:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

	   FormatCurrency(SMoney);
   10640:	c5 01       	movw	r24, r10
   10642:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
	   FormatCurrency(STotalMoney);
   10646:	c6 01       	movw	r24, r12
   10648:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
    
	   sprintf_P(strSend,PSTR("FmtMoney:%s"),SMoney);
   1064c:	00 d0       	rcall	.+0      	; 0x1064e <TestUserInput+0x3a6>
   1064e:	00 d0       	rcall	.+0      	; 0x10650 <TestUserInput+0x3a8>
   10650:	00 d0       	rcall	.+0      	; 0x10652 <TestUserInput+0x3aa>
   10652:	ed b7       	in	r30, 0x3d	; 61
   10654:	fe b7       	in	r31, 0x3e	; 62
   10656:	31 96       	adiw	r30, 0x01	; 1
   10658:	ad b7       	in	r26, 0x3d	; 61
   1065a:	be b7       	in	r27, 0x3e	; 62
   1065c:	12 96       	adiw	r26, 0x02	; 2
   1065e:	1c 93       	st	X, r17
   10660:	0e 93       	st	-X, r16
   10662:	11 97       	sbiw	r26, 0x01	; 1
   10664:	88 e0       	ldi	r24, 0x08	; 8
   10666:	94 e0       	ldi	r25, 0x04	; 4
   10668:	93 83       	std	Z+3, r25	; 0x03
   1066a:	82 83       	std	Z+2, r24	; 0x02
   1066c:	b5 82       	std	Z+5, r11	; 0x05
   1066e:	a4 82       	std	Z+4, r10	; 0x04
   10670:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   10674:	8d b7       	in	r24, 0x3d	; 61
   10676:	9e b7       	in	r25, 0x3e	; 62
   10678:	06 96       	adiw	r24, 0x06	; 6
   1067a:	0f b6       	in	r0, 0x3f	; 63
   1067c:	f8 94       	cli
   1067e:	9e bf       	out	0x3e, r25	; 62
   10680:	0f be       	out	0x3f, r0	; 63
   10682:	8d bf       	out	0x3d, r24	; 61
   10684:	80 e0       	ldi	r24, 0x00	; 0
   10686:	61 e0       	ldi	r22, 0x01	; 1
   10688:	a8 01       	movw	r20, r16
   1068a:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	   sprintf_P(strSend,PSTR("FmtTMoney:%s"),STotalMoney);
   1068e:	00 d0       	rcall	.+0      	; 0x10690 <TestUserInput+0x3e8>
   10690:	00 d0       	rcall	.+0      	; 0x10692 <TestUserInput+0x3ea>
   10692:	00 d0       	rcall	.+0      	; 0x10694 <TestUserInput+0x3ec>
   10694:	ed b7       	in	r30, 0x3d	; 61
   10696:	fe b7       	in	r31, 0x3e	; 62
   10698:	31 96       	adiw	r30, 0x01	; 1
   1069a:	ad b7       	in	r26, 0x3d	; 61
   1069c:	be b7       	in	r27, 0x3e	; 62
   1069e:	12 96       	adiw	r26, 0x02	; 2
   106a0:	1c 93       	st	X, r17
   106a2:	0e 93       	st	-X, r16
   106a4:	11 97       	sbiw	r26, 0x01	; 1
   106a6:	8b ef       	ldi	r24, 0xFB	; 251
   106a8:	93 e0       	ldi	r25, 0x03	; 3
   106aa:	93 83       	std	Z+3, r25	; 0x03
   106ac:	82 83       	std	Z+2, r24	; 0x02
   106ae:	d5 82       	std	Z+5, r13	; 0x05
   106b0:	c4 82       	std	Z+4, r12	; 0x04
   106b2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	   _uart_print(0,1,strSend);
   106b6:	8d b7       	in	r24, 0x3d	; 61
   106b8:	9e b7       	in	r25, 0x3e	; 62
   106ba:	06 96       	adiw	r24, 0x06	; 6
   106bc:	0f b6       	in	r0, 0x3f	; 63
   106be:	f8 94       	cli
   106c0:	9e bf       	out	0x3e, r25	; 62
   106c2:	0f be       	out	0x3f, r0	; 63
   106c4:	8d bf       	out	0x3d, r24	; 61
   106c6:	80 e0       	ldi	r24, 0x00	; 0
   106c8:	61 e0       	ldi	r22, 0x01	; 1
   106ca:	a8 01       	movw	r20, r16
   106cc:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
   106d0:	02 c0       	rjmp	.+4      	; 0x106d6 <TestUserInput+0x42e>


   	
	}else    
	if (uiResult==USER_CANCEL){
   106d2:	81 30       	cpi	r24, 0x01	; 1
   106d4:	11 f0       	breq	.+4      	; 0x106da <TestUserInput+0x432>
   106d6:	80 e0       	ldi	r24, 0x00	; 0
   106d8:	0b c0       	rjmp	.+22     	; 0x106f0 <TestUserInput+0x448>
	   lcd_clear();
   106da:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   106de:	fe 01       	movw	r30, r28
   106e0:	fd 96       	adiw	r30, 0x3d	; 61

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   106e2:	cf 01       	movw	r24, r30
   106e4:	0f 96       	adiw	r24, 0x0f	; 15
	     strMemory[i]=data;
   106e6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   106e8:	e8 17       	cp	r30, r24
   106ea:	f9 07       	cpc	r31, r25
   106ec:	e1 f7       	brne	.-8      	; 0x106e6 <TestUserInput+0x43e>
   106ee:	81 e0       	ldi	r24, 0x01	; 1
       Result=MENU_DONE;   
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
}
   106f0:	c2 59       	subi	r28, 0x92	; 146
   106f2:	df 4f       	sbci	r29, 0xFF	; 255
   106f4:	0f b6       	in	r0, 0x3f	; 63
   106f6:	f8 94       	cli
   106f8:	de bf       	out	0x3e, r29	; 62
   106fa:	0f be       	out	0x3f, r0	; 63
   106fc:	cd bf       	out	0x3d, r28	; 61
   106fe:	cf 91       	pop	r28
   10700:	df 91       	pop	r29
   10702:	1f 91       	pop	r17
   10704:	0f 91       	pop	r16
   10706:	ff 90       	pop	r15
   10708:	ef 90       	pop	r14
   1070a:	df 90       	pop	r13
   1070c:	cf 90       	pop	r12
   1070e:	bf 90       	pop	r11
   10710:	af 90       	pop	r10
   10712:	9f 90       	pop	r9
   10714:	8f 90       	pop	r8
   10716:	7f 90       	pop	r7
   10718:	6f 90       	pop	r6
   1071a:	08 95       	ret

0001071c <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
   1071c:	df 92       	push	r13
   1071e:	ef 92       	push	r14
   10720:	ff 92       	push	r15
   10722:	0f 93       	push	r16
   10724:	1f 93       	push	r17
   10726:	df 93       	push	r29
   10728:	cf 93       	push	r28
   1072a:	cd b7       	in	r28, 0x3d	; 61
   1072c:	de b7       	in	r29, 0x3e	; 62
   1072e:	64 97       	sbiw	r28, 0x14	; 20
   10730:	0f b6       	in	r0, 0x3f	; 63
   10732:	f8 94       	cli
   10734:	de bf       	out	0x3e, r29	; 62
   10736:	0f be       	out	0x3f, r0	; 63
   10738:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
   1073a:	80 91 fc 02 	lds	r24, 0x02FC
   1073e:	82 30       	cpi	r24, 0x02	; 2
   10740:	09 f4       	brne	.+2      	; 0x10744 <FSettingDec+0x28>
   10742:	c7 c0       	rjmp	.+398    	; 0x108d2 <FSettingDec+0x1b6>
   10744:	83 30       	cpi	r24, 0x03	; 3
   10746:	30 f4       	brcc	.+12     	; 0x10754 <FSettingDec+0x38>
   10748:	88 23       	and	r24, r24
   1074a:	71 f0       	breq	.+28     	; 0x10768 <FSettingDec+0x4c>
   1074c:	81 30       	cpi	r24, 0x01	; 1
   1074e:	09 f0       	breq	.+2      	; 0x10752 <FSettingDec+0x36>
   10750:	c3 c1       	rjmp	.+902    	; 0x10ad8 <FSettingDec+0x3bc>
   10752:	92 c0       	rjmp	.+292    	; 0x10878 <FSettingDec+0x15c>
   10754:	84 30       	cpi	r24, 0x04	; 4
   10756:	09 f4       	brne	.+2      	; 0x1075a <FSettingDec+0x3e>
   10758:	b3 c1       	rjmp	.+870    	; 0x10ac0 <FSettingDec+0x3a4>
   1075a:	84 30       	cpi	r24, 0x04	; 4
   1075c:	08 f4       	brcc	.+2      	; 0x10760 <FSettingDec+0x44>
   1075e:	68 c1       	rjmp	.+720    	; 0x10a30 <FSettingDec+0x314>
   10760:	85 30       	cpi	r24, 0x05	; 5
   10762:	09 f0       	breq	.+2      	; 0x10766 <FSettingDec+0x4a>
   10764:	b9 c1       	rjmp	.+882    	; 0x10ad8 <FSettingDec+0x3bc>
   10766:	b4 c1       	rjmp	.+872    	; 0x10ad0 <FSettingDec+0x3b4>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
   10768:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1076c:	e1 99       	sbic	0x1c, 1	; 28
   1076e:	fe cf       	rjmp	.-4      	; 0x1076c <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10770:	89 e3       	ldi	r24, 0x39	; 57
   10772:	90 e0       	ldi	r25, 0x00	; 0
   10774:	9f bb       	out	0x1f, r25	; 31
   10776:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10778:	e0 9a       	sbi	0x1c, 0	; 28
   1077a:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1077c:	e1 99       	sbic	0x1c, 1	; 28
   1077e:	fe cf       	rjmp	.-4      	; 0x1077c <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10780:	8a e3       	ldi	r24, 0x3A	; 58
   10782:	90 e0       	ldi	r25, 0x00	; 0
   10784:	9f bb       	out	0x1f, r25	; 31
   10786:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10788:	e0 9a       	sbi	0x1c, 0	; 28
   1078a:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1078c:	e1 99       	sbic	0x1c, 1	; 28
   1078e:	fe cf       	rjmp	.-4      	; 0x1078c <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10790:	8b e3       	ldi	r24, 0x3B	; 59
   10792:	90 e0       	ldi	r25, 0x00	; 0
   10794:	9f bb       	out	0x1f, r25	; 31
   10796:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10798:	e0 9a       	sbi	0x1c, 0	; 28
   1079a:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
   1079c:	00 d0       	rcall	.+0      	; 0x1079e <FSettingDec+0x82>
   1079e:	00 d0       	rcall	.+0      	; 0x107a0 <FSettingDec+0x84>
   107a0:	00 d0       	rcall	.+0      	; 0x107a2 <FSettingDec+0x86>
   107a2:	ed b7       	in	r30, 0x3d	; 61
   107a4:	fe b7       	in	r31, 0x3e	; 62
   107a6:	31 96       	adiw	r30, 0x01	; 1
   107a8:	8e 01       	movw	r16, r28
   107aa:	0f 5f       	subi	r16, 0xFF	; 255
   107ac:	1f 4f       	sbci	r17, 0xFF	; 255
   107ae:	ad b7       	in	r26, 0x3d	; 61
   107b0:	be b7       	in	r27, 0x3e	; 62
   107b2:	12 96       	adiw	r26, 0x02	; 2
   107b4:	1c 93       	st	X, r17
   107b6:	0e 93       	st	-X, r16
   107b8:	11 97       	sbiw	r26, 0x01	; 1
   107ba:	89 e0       	ldi	r24, 0x09	; 9
   107bc:	90 e1       	ldi	r25, 0x10	; 16
   107be:	93 83       	std	Z+3, r25	; 0x03
   107c0:	82 83       	std	Z+2, r24	; 0x02
   107c2:	24 83       	std	Z+4, r18	; 0x04
   107c4:	15 82       	std	Z+5, r1	; 0x05
   107c6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   107ca:	8d b7       	in	r24, 0x3d	; 61
   107cc:	9e b7       	in	r25, 0x3e	; 62
   107ce:	06 96       	adiw	r24, 0x06	; 6
   107d0:	0f b6       	in	r0, 0x3f	; 63
   107d2:	f8 94       	cli
   107d4:	9e bf       	out	0x3e, r25	; 62
   107d6:	0f be       	out	0x3f, r0	; 63
   107d8:	8d bf       	out	0x3d, r24	; 61
   107da:	81 e0       	ldi	r24, 0x01	; 1
   107dc:	61 e0       	ldi	r22, 0x01	; 1
   107de:	a8 01       	movw	r20, r16
   107e0:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
   107e4:	00 d0       	rcall	.+0      	; 0x107e6 <FSettingDec+0xca>
   107e6:	00 d0       	rcall	.+0      	; 0x107e8 <FSettingDec+0xcc>
   107e8:	00 d0       	rcall	.+0      	; 0x107ea <FSettingDec+0xce>
   107ea:	ed b7       	in	r30, 0x3d	; 61
   107ec:	fe b7       	in	r31, 0x3e	; 62
   107ee:	31 96       	adiw	r30, 0x01	; 1
   107f0:	ad b7       	in	r26, 0x3d	; 61
   107f2:	be b7       	in	r27, 0x3e	; 62
   107f4:	12 96       	adiw	r26, 0x02	; 2
   107f6:	1c 93       	st	X, r17
   107f8:	0e 93       	st	-X, r16
   107fa:	11 97       	sbiw	r26, 0x01	; 1
   107fc:	8d ef       	ldi	r24, 0xFD	; 253
   107fe:	9f e0       	ldi	r25, 0x0F	; 15
   10800:	93 83       	std	Z+3, r25	; 0x03
   10802:	82 83       	std	Z+2, r24	; 0x02
   10804:	e4 82       	std	Z+4, r14	; 0x04
   10806:	15 82       	std	Z+5, r1	; 0x05
   10808:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   1080c:	8d b7       	in	r24, 0x3d	; 61
   1080e:	9e b7       	in	r25, 0x3e	; 62
   10810:	06 96       	adiw	r24, 0x06	; 6
   10812:	0f b6       	in	r0, 0x3f	; 63
   10814:	f8 94       	cli
   10816:	9e bf       	out	0x3e, r25	; 62
   10818:	0f be       	out	0x3f, r0	; 63
   1081a:	8d bf       	out	0x3d, r24	; 61
   1081c:	82 e0       	ldi	r24, 0x02	; 2
   1081e:	61 e0       	ldi	r22, 0x01	; 1
   10820:	a8 01       	movw	r20, r16
   10822:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
   10826:	00 d0       	rcall	.+0      	; 0x10828 <FSettingDec+0x10c>
   10828:	00 d0       	rcall	.+0      	; 0x1082a <FSettingDec+0x10e>
   1082a:	00 d0       	rcall	.+0      	; 0x1082c <FSettingDec+0x110>
   1082c:	ed b7       	in	r30, 0x3d	; 61
   1082e:	fe b7       	in	r31, 0x3e	; 62
   10830:	31 96       	adiw	r30, 0x01	; 1
   10832:	ad b7       	in	r26, 0x3d	; 61
   10834:	be b7       	in	r27, 0x3e	; 62
   10836:	12 96       	adiw	r26, 0x02	; 2
   10838:	1c 93       	st	X, r17
   1083a:	0e 93       	st	-X, r16
   1083c:	11 97       	sbiw	r26, 0x01	; 1
   1083e:	81 ef       	ldi	r24, 0xF1	; 241
   10840:	9f e0       	ldi	r25, 0x0F	; 15
   10842:	93 83       	std	Z+3, r25	; 0x03
   10844:	82 83       	std	Z+2, r24	; 0x02
   10846:	f4 82       	std	Z+4, r15	; 0x04
   10848:	15 82       	std	Z+5, r1	; 0x05
   1084a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   1084e:	8d b7       	in	r24, 0x3d	; 61
   10850:	9e b7       	in	r25, 0x3e	; 62
   10852:	06 96       	adiw	r24, 0x06	; 6
   10854:	0f b6       	in	r0, 0x3f	; 63
   10856:	f8 94       	cli
   10858:	9e bf       	out	0x3e, r25	; 62
   1085a:	0f be       	out	0x3f, r0	; 63
   1085c:	8d bf       	out	0x3d, r24	; 61
   1085e:	83 e0       	ldi	r24, 0x03	; 3
   10860:	61 e0       	ldi	r22, 0x01	; 1
   10862:	a8 01       	movw	r20, r16
   10864:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
   10868:	84 e0       	ldi	r24, 0x04	; 4
   1086a:	61 e0       	ldi	r22, 0x01	; 1
   1086c:	40 ee       	ldi	r20, 0xE0	; 224
   1086e:	5f e0       	ldi	r21, 0x0F	; 15
   10870:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
   10874:	81 e0       	ldi	r24, 0x01	; 1
   10876:	29 c1       	rjmp	.+594    	; 0x10aca <FSettingDec+0x3ae>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
   10878:	81 e0       	ldi	r24, 0x01	; 1
   1087a:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   1087e:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
   10882:	98 2f       	mov	r25, r24
   10884:	91 53       	subi	r25, 0x31	; 49
   10886:	93 30       	cpi	r25, 0x03	; 3
   10888:	e0 f4       	brcc	.+56     	; 0x108c2 <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
   1088a:	29 2f       	mov	r18, r25
   1088c:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1088e:	e1 99       	sbic	0x1c, 1	; 28
   10890:	fe cf       	rjmp	.-4      	; 0x1088e <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10892:	c9 01       	movw	r24, r18
   10894:	87 5c       	subi	r24, 0xC7	; 199
   10896:	9f 4f       	sbci	r25, 0xFF	; 255
   10898:	9f bb       	out	0x1f, r25	; 31
   1089a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1089c:	e0 9a       	sbi	0x1c, 0	; 28
   1089e:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   108a0:	e1 99       	sbic	0x1c, 1	; 28
   108a2:	fe cf       	rjmp	.-4      	; 0x108a0 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   108a4:	27 5c       	subi	r18, 0xC7	; 199
   108a6:	3f 4f       	sbci	r19, 0xFF	; 255
   108a8:	3f bb       	out	0x1f, r19	; 31
   108aa:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   108ac:	90 e0       	ldi	r25, 0x00	; 0
   108ae:	01 96       	adiw	r24, 0x01	; 1
   108b0:	83 70       	andi	r24, 0x03	; 3
   108b2:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
   108b4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   108b6:	0f b6       	in	r0, 0x3f	; 63
   108b8:	f8 94       	cli
   108ba:	e2 9a       	sbi	0x1c, 2	; 28
   108bc:	e1 9a       	sbi	0x1c, 1	; 28
   108be:	0f be       	out	0x3f, r0	; 63
   108c0:	f6 c0       	rjmp	.+492    	; 0x10aae <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
   108c2:	8a 32       	cpi	r24, 0x2A	; 42
   108c4:	11 f4       	brne	.+4      	; 0x108ca <FSettingDec+0x1ae>
   108c6:	85 e0       	ldi	r24, 0x05	; 5
   108c8:	00 c1       	rjmp	.+512    	; 0x10aca <FSettingDec+0x3ae>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
   108ca:	83 32       	cpi	r24, 0x23	; 35
   108cc:	09 f0       	breq	.+2      	; 0x108d0 <FSettingDec+0x1b4>
   108ce:	04 c1       	rjmp	.+520    	; 0x10ad8 <FSettingDec+0x3bc>
   108d0:	fb c0       	rjmp	.+502    	; 0x10ac8 <FSettingDec+0x3ac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   108d2:	e1 99       	sbic	0x1c, 1	; 28
   108d4:	fe cf       	rjmp	.-4      	; 0x108d2 <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   108d6:	8c e3       	ldi	r24, 0x3C	; 60
   108d8:	90 e0       	ldi	r25, 0x00	; 0
   108da:	9f bb       	out	0x1f, r25	; 31
   108dc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   108de:	e0 9a       	sbi	0x1c, 0	; 28
   108e0:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   108e2:	e1 99       	sbic	0x1c, 1	; 28
   108e4:	fe cf       	rjmp	.-4      	; 0x108e2 <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   108e6:	8d e3       	ldi	r24, 0x3D	; 61
   108e8:	90 e0       	ldi	r25, 0x00	; 0
   108ea:	9f bb       	out	0x1f, r25	; 31
   108ec:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   108ee:	e0 9a       	sbi	0x1c, 0	; 28
   108f0:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   108f2:	e1 99       	sbic	0x1c, 1	; 28
   108f4:	fe cf       	rjmp	.-4      	; 0x108f2 <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   108f6:	8e e3       	ldi	r24, 0x3E	; 62
   108f8:	90 e0       	ldi	r25, 0x00	; 0
   108fa:	9f bb       	out	0x1f, r25	; 31
   108fc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   108fe:	e0 9a       	sbi	0x1c, 0	; 28
   10900:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10902:	e1 99       	sbic	0x1c, 1	; 28
   10904:	fe cf       	rjmp	.-4      	; 0x10902 <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10906:	8f e3       	ldi	r24, 0x3F	; 63
   10908:	90 e0       	ldi	r25, 0x00	; 0
   1090a:	9f bb       	out	0x1f, r25	; 31
   1090c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1090e:	e0 9a       	sbi	0x1c, 0	; 28
   10910:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d  5.Test"),PDecimalConfig[0]);
   10912:	00 d0       	rcall	.+0      	; 0x10914 <FSettingDec+0x1f8>
   10914:	00 d0       	rcall	.+0      	; 0x10916 <FSettingDec+0x1fa>
   10916:	00 d0       	rcall	.+0      	; 0x10918 <FSettingDec+0x1fc>
   10918:	ed b7       	in	r30, 0x3d	; 61
   1091a:	fe b7       	in	r31, 0x3e	; 62
   1091c:	31 96       	adiw	r30, 0x01	; 1
   1091e:	8e 01       	movw	r16, r28
   10920:	0f 5f       	subi	r16, 0xFF	; 255
   10922:	1f 4f       	sbci	r17, 0xFF	; 255
   10924:	ad b7       	in	r26, 0x3d	; 61
   10926:	be b7       	in	r27, 0x3e	; 62
   10928:	12 96       	adiw	r26, 0x02	; 2
   1092a:	1c 93       	st	X, r17
   1092c:	0e 93       	st	-X, r16
   1092e:	11 97       	sbiw	r26, 0x01	; 1
   10930:	8a ec       	ldi	r24, 0xCA	; 202
   10932:	9f e0       	ldi	r25, 0x0F	; 15
   10934:	93 83       	std	Z+3, r25	; 0x03
   10936:	82 83       	std	Z+2, r24	; 0x02
   10938:	24 83       	std	Z+4, r18	; 0x04
   1093a:	15 82       	std	Z+5, r1	; 0x05
   1093c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10940:	8d b7       	in	r24, 0x3d	; 61
   10942:	9e b7       	in	r25, 0x3e	; 62
   10944:	06 96       	adiw	r24, 0x06	; 6
   10946:	0f b6       	in	r0, 0x3f	; 63
   10948:	f8 94       	cli
   1094a:	9e bf       	out	0x3e, r25	; 62
   1094c:	0f be       	out	0x3f, r0	; 63
   1094e:	8d bf       	out	0x3d, r24	; 61
   10950:	81 e0       	ldi	r24, 0x01	; 1
   10952:	61 e0       	ldi	r22, 0x01	; 1
   10954:	a8 01       	movw	r20, r16
   10956:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
   1095a:	00 d0       	rcall	.+0      	; 0x1095c <FSettingDec+0x240>
   1095c:	00 d0       	rcall	.+0      	; 0x1095e <FSettingDec+0x242>
   1095e:	00 d0       	rcall	.+0      	; 0x10960 <FSettingDec+0x244>
   10960:	ed b7       	in	r30, 0x3d	; 61
   10962:	fe b7       	in	r31, 0x3e	; 62
   10964:	31 96       	adiw	r30, 0x01	; 1
   10966:	ad b7       	in	r26, 0x3d	; 61
   10968:	be b7       	in	r27, 0x3e	; 62
   1096a:	12 96       	adiw	r26, 0x02	; 2
   1096c:	1c 93       	st	X, r17
   1096e:	0e 93       	st	-X, r16
   10970:	11 97       	sbiw	r26, 0x01	; 1
   10972:	8b eb       	ldi	r24, 0xBB	; 187
   10974:	9f e0       	ldi	r25, 0x0F	; 15
   10976:	93 83       	std	Z+3, r25	; 0x03
   10978:	82 83       	std	Z+2, r24	; 0x02
   1097a:	e4 82       	std	Z+4, r14	; 0x04
   1097c:	15 82       	std	Z+5, r1	; 0x05
   1097e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10982:	8d b7       	in	r24, 0x3d	; 61
   10984:	9e b7       	in	r25, 0x3e	; 62
   10986:	06 96       	adiw	r24, 0x06	; 6
   10988:	0f b6       	in	r0, 0x3f	; 63
   1098a:	f8 94       	cli
   1098c:	9e bf       	out	0x3e, r25	; 62
   1098e:	0f be       	out	0x3f, r0	; 63
   10990:	8d bf       	out	0x3d, r24	; 61
   10992:	82 e0       	ldi	r24, 0x02	; 2
   10994:	61 e0       	ldi	r22, 0x01	; 1
   10996:	a8 01       	movw	r20, r16
   10998:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
   1099c:	00 d0       	rcall	.+0      	; 0x1099e <FSettingDec+0x282>
   1099e:	00 d0       	rcall	.+0      	; 0x109a0 <FSettingDec+0x284>
   109a0:	00 d0       	rcall	.+0      	; 0x109a2 <FSettingDec+0x286>
   109a2:	ed b7       	in	r30, 0x3d	; 61
   109a4:	fe b7       	in	r31, 0x3e	; 62
   109a6:	31 96       	adiw	r30, 0x01	; 1
   109a8:	ad b7       	in	r26, 0x3d	; 61
   109aa:	be b7       	in	r27, 0x3e	; 62
   109ac:	12 96       	adiw	r26, 0x02	; 2
   109ae:	1c 93       	st	X, r17
   109b0:	0e 93       	st	-X, r16
   109b2:	11 97       	sbiw	r26, 0x01	; 1
   109b4:	8c ea       	ldi	r24, 0xAC	; 172
   109b6:	9f e0       	ldi	r25, 0x0F	; 15
   109b8:	93 83       	std	Z+3, r25	; 0x03
   109ba:	82 83       	std	Z+2, r24	; 0x02
   109bc:	d4 82       	std	Z+4, r13	; 0x04
   109be:	15 82       	std	Z+5, r1	; 0x05
   109c0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   109c4:	8d b7       	in	r24, 0x3d	; 61
   109c6:	9e b7       	in	r25, 0x3e	; 62
   109c8:	06 96       	adiw	r24, 0x06	; 6
   109ca:	0f b6       	in	r0, 0x3f	; 63
   109cc:	f8 94       	cli
   109ce:	9e bf       	out	0x3e, r25	; 62
   109d0:	0f be       	out	0x3f, r0	; 63
   109d2:	8d bf       	out	0x3d, r24	; 61
   109d4:	83 e0       	ldi	r24, 0x03	; 3
   109d6:	61 e0       	ldi	r22, 0x01	; 1
   109d8:	a8 01       	movw	r20, r16
   109da:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
   109de:	00 d0       	rcall	.+0      	; 0x109e0 <FSettingDec+0x2c4>
   109e0:	00 d0       	rcall	.+0      	; 0x109e2 <FSettingDec+0x2c6>
   109e2:	00 d0       	rcall	.+0      	; 0x109e4 <FSettingDec+0x2c8>
   109e4:	ed b7       	in	r30, 0x3d	; 61
   109e6:	fe b7       	in	r31, 0x3e	; 62
   109e8:	31 96       	adiw	r30, 0x01	; 1
   109ea:	ad b7       	in	r26, 0x3d	; 61
   109ec:	be b7       	in	r27, 0x3e	; 62
   109ee:	12 96       	adiw	r26, 0x02	; 2
   109f0:	1c 93       	st	X, r17
   109f2:	0e 93       	st	-X, r16
   109f4:	11 97       	sbiw	r26, 0x01	; 1
   109f6:	8d e9       	ldi	r24, 0x9D	; 157
   109f8:	9f e0       	ldi	r25, 0x0F	; 15
   109fa:	93 83       	std	Z+3, r25	; 0x03
   109fc:	82 83       	std	Z+2, r24	; 0x02
   109fe:	f4 82       	std	Z+4, r15	; 0x04
   10a00:	15 82       	std	Z+5, r1	; 0x05
   10a02:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10a06:	8d b7       	in	r24, 0x3d	; 61
   10a08:	9e b7       	in	r25, 0x3e	; 62
   10a0a:	06 96       	adiw	r24, 0x06	; 6
   10a0c:	0f b6       	in	r0, 0x3f	; 63
   10a0e:	f8 94       	cli
   10a10:	9e bf       	out	0x3e, r25	; 62
   10a12:	0f be       	out	0x3f, r0	; 63
   10a14:	8d bf       	out	0x3d, r24	; 61
   10a16:	84 e0       	ldi	r24, 0x04	; 4
   10a18:	61 e0       	ldi	r22, 0x01	; 1
   10a1a:	a8 01       	movw	r20, r16
   10a1c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
   10a20:	84 e0       	ldi	r24, 0x04	; 4
   10a22:	6e e0       	ldi	r22, 0x0E	; 14
   10a24:	46 e9       	ldi	r20, 0x96	; 150
   10a26:	5f e0       	ldi	r21, 0x0F	; 15
   10a28:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
   10a2c:	83 e0       	ldi	r24, 0x03	; 3
   10a2e:	4d c0       	rjmp	.+154    	; 0x10aca <FSettingDec+0x3ae>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
   10a30:	81 e0       	ldi	r24, 0x01	; 1
   10a32:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   10a36:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   10a3a:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
   10a3c:	98 2f       	mov	r25, r24
   10a3e:	91 53       	subi	r25, 0x31	; 49
   10a40:	92 30       	cpi	r25, 0x02	; 2
   10a42:	b0 f4       	brcc	.+44     	; 0x10a70 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   10a44:	29 2f       	mov	r18, r25
   10a46:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10a48:	e1 99       	sbic	0x1c, 1	; 28
   10a4a:	fe cf       	rjmp	.-4      	; 0x10a48 <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10a4c:	c9 01       	movw	r24, r18
   10a4e:	84 5c       	subi	r24, 0xC4	; 196
   10a50:	9f 4f       	sbci	r25, 0xFF	; 255
   10a52:	9f bb       	out	0x1f, r25	; 31
   10a54:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10a56:	e0 9a       	sbi	0x1c, 0	; 28
   10a58:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   10a5a:	e1 99       	sbic	0x1c, 1	; 28
   10a5c:	fe cf       	rjmp	.-4      	; 0x10a5a <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10a5e:	24 5c       	subi	r18, 0xC4	; 196
   10a60:	3f 4f       	sbci	r19, 0xFF	; 255
   10a62:	3f bb       	out	0x1f, r19	; 31
   10a64:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   10a66:	90 e0       	ldi	r25, 0x00	; 0
   10a68:	01 96       	adiw	r24, 0x01	; 1
   10a6a:	83 70       	andi	r24, 0x03	; 3
   10a6c:	90 70       	andi	r25, 0x00	; 0
   10a6e:	16 c0       	rjmp	.+44     	; 0x10a9c <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
   10a70:	83 53       	subi	r24, 0x33	; 51
   10a72:	82 30       	cpi	r24, 0x02	; 2
   10a74:	d0 f4       	brcc	.+52     	; 0x10aaa <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   10a76:	09 2f       	mov	r16, r25
   10a78:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10a7a:	e1 99       	sbic	0x1c, 1	; 28
   10a7c:	fe cf       	rjmp	.-4      	; 0x10a7a <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10a7e:	c8 01       	movw	r24, r16
   10a80:	84 5c       	subi	r24, 0xC4	; 196
   10a82:	9f 4f       	sbci	r25, 0xFF	; 255
   10a84:	9f bb       	out	0x1f, r25	; 31
   10a86:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10a88:	e0 9a       	sbi	0x1c, 0	; 28
   10a8a:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
   10a8c:	0e 94 38 1c 	call	0x3870	; 0x3870 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   10a90:	e1 99       	sbic	0x1c, 1	; 28
   10a92:	fe cf       	rjmp	.-4      	; 0x10a90 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10a94:	04 5c       	subi	r16, 0xC4	; 196
   10a96:	1f 4f       	sbci	r17, 0xFF	; 255
   10a98:	1f bb       	out	0x1f, r17	; 31
   10a9a:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   10a9c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   10a9e:	0f b6       	in	r0, 0x3f	; 63
   10aa0:	f8 94       	cli
   10aa2:	e2 9a       	sbi	0x1c, 2	; 28
   10aa4:	e1 9a       	sbi	0x1c, 1	; 28
   10aa6:	0f be       	out	0x3f, r0	; 63
   10aa8:	0f c0       	rjmp	.+30     	; 0x10ac8 <FSettingDec+0x3ac>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
   10aaa:	2a 32       	cpi	r18, 0x2A	; 42
   10aac:	19 f4       	brne	.+6      	; 0x10ab4 <FSettingDec+0x398>
   10aae:	10 92 fc 02 	sts	0x02FC, r1
   10ab2:	12 c0       	rjmp	.+36     	; 0x10ad8 <FSettingDec+0x3bc>
		  else if (KeyChar=='5'){
   10ab4:	25 33       	cpi	r18, 0x35	; 53
   10ab6:	81 f4       	brne	.+32     	; 0x10ad8 <FSettingDec+0x3bc>
		          lcd_clear();
   10ab8:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		          stSettingDecimal=sdTestInput;
   10abc:	84 e0       	ldi	r24, 0x04	; 4
   10abe:	05 c0       	rjmp	.+10     	; 0x10aca <FSettingDec+0x3ae>
				  }
          break;
     case sdTestInput:
	      if (TestUserInput()==MENU_DONE)stSettingDecimal=sdInitDisplay2;
   10ac0:	0e 94 54 81 	call	0x102a8	; 0x102a8 <TestUserInput>
   10ac4:	81 30       	cpi	r24, 0x01	; 1
   10ac6:	41 f4       	brne	.+16     	; 0x10ad8 <FSettingDec+0x3bc>
   10ac8:	82 e0       	ldi	r24, 0x02	; 2
   10aca:	80 93 fc 02 	sts	0x02FC, r24
   10ace:	04 c0       	rjmp	.+8      	; 0x10ad8 <FSettingDec+0x3bc>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
   10ad0:	10 92 fc 02 	sts	0x02FC, r1
   10ad4:	81 e0       	ldi	r24, 0x01	; 1
   10ad6:	01 c0       	rjmp	.+2      	; 0x10ada <FSettingDec+0x3be>
   10ad8:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
   10ada:	64 96       	adiw	r28, 0x14	; 20
   10adc:	0f b6       	in	r0, 0x3f	; 63
   10ade:	f8 94       	cli
   10ae0:	de bf       	out	0x3e, r29	; 62
   10ae2:	0f be       	out	0x3f, r0	; 63
   10ae4:	cd bf       	out	0x3d, r28	; 61
   10ae6:	cf 91       	pop	r28
   10ae8:	df 91       	pop	r29
   10aea:	1f 91       	pop	r17
   10aec:	0f 91       	pop	r16
   10aee:	ff 90       	pop	r15
   10af0:	ef 90       	pop	r14
   10af2:	df 90       	pop	r13
   10af4:	08 95       	ret

00010af6 <FTestCalculation>:
	 }
  return Result;
}


void FTestCalculation(){
   10af6:	cf 92       	push	r12
   10af8:	df 92       	push	r13
   10afa:	ef 92       	push	r14
   10afc:	ff 92       	push	r15
   10afe:	0f 93       	push	r16
   10b00:	1f 93       	push	r17
   10b02:	df 93       	push	r29
   10b04:	cf 93       	push	r28
   10b06:	cd b7       	in	r28, 0x3d	; 61
   10b08:	de b7       	in	r29, 0x3e	; 62
   10b0a:	64 97       	sbiw	r28, 0x14	; 20
   10b0c:	0f b6       	in	r0, 0x3f	; 63
   10b0e:	f8 94       	cli
   10b10:	de bf       	out	0x3e, r29	; 62
   10b12:	0f be       	out	0x3f, r0	; 63
   10b14:	cd bf       	out	0x3d, r28	; 61
static char stTestCalc=tcInitData,uiResult=USER_NONE;
static char InputA[20],InputB[20],OutputC[20];
     char lcdteks[20],KeyChar;
     
	 switch(stTestCalc){
   10b16:	80 91 6d 02 	lds	r24, 0x026D
   10b1a:	82 30       	cpi	r24, 0x02	; 2
   10b1c:	09 f4       	brne	.+2      	; 0x10b20 <FTestCalculation+0x2a>
   10b1e:	4b c0       	rjmp	.+150    	; 0x10bb6 <FTestCalculation+0xc0>
   10b20:	83 30       	cpi	r24, 0x03	; 3
   10b22:	30 f4       	brcc	.+12     	; 0x10b30 <FTestCalculation+0x3a>
   10b24:	88 23       	and	r24, r24
   10b26:	71 f0       	breq	.+28     	; 0x10b44 <FTestCalculation+0x4e>
   10b28:	81 30       	cpi	r24, 0x01	; 1
   10b2a:	09 f0       	breq	.+2      	; 0x10b2e <FTestCalculation+0x38>
   10b2c:	e7 c0       	rjmp	.+462    	; 0x10cfc <FTestCalculation+0x206>
   10b2e:	2f c0       	rjmp	.+94     	; 0x10b8e <FTestCalculation+0x98>
   10b30:	84 30       	cpi	r24, 0x04	; 4
   10b32:	09 f4       	brne	.+2      	; 0x10b36 <FTestCalculation+0x40>
   10b34:	82 c0       	rjmp	.+260    	; 0x10c3a <FTestCalculation+0x144>
   10b36:	84 30       	cpi	r24, 0x04	; 4
   10b38:	08 f4       	brcc	.+2      	; 0x10b3c <FTestCalculation+0x46>
   10b3a:	6d c0       	rjmp	.+218    	; 0x10c16 <FTestCalculation+0x120>
   10b3c:	85 30       	cpi	r24, 0x05	; 5
   10b3e:	09 f0       	breq	.+2      	; 0x10b42 <FTestCalculation+0x4c>
   10b40:	dd c0       	rjmp	.+442    	; 0x10cfc <FTestCalculation+0x206>
   10b42:	d1 c0       	rjmp	.+418    	; 0x10ce6 <FTestCalculation+0x1f0>
	 case tcInitData:
	      lcd_clear();
   10b44:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("Operation Multiply"));
   10b48:	81 e0       	ldi	r24, 0x01	; 1
   10b4a:	61 e0       	ldi	r22, 0x01	; 1
   10b4c:	47 e5       	ldi	r20, 0x57	; 87
   10b4e:	56 e0       	ldi	r21, 0x06	; 6
   10b50:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("InA:_"));
   10b54:	82 e0       	ldi	r24, 0x02	; 2
   10b56:	61 e0       	ldi	r22, 0x01	; 1
   10b58:	41 e5       	ldi	r20, 0x51	; 81
   10b5a:	56 e0       	ldi	r21, 0x06	; 6
   10b5c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   10b60:	a8 e5       	ldi	r26, 0x58	; 88
   10b62:	b2 e0       	ldi	r27, 0x02	; 2
   10b64:	fd 01       	movw	r30, r26
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   10b66:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10b68:	82 e0       	ldi	r24, 0x02	; 2
   10b6a:	ec 36       	cpi	r30, 0x6C	; 108
   10b6c:	f8 07       	cpc	r31, r24
   10b6e:	d9 f7       	brne	.-10     	; 0x10b66 <FTestCalculation+0x70>
   10b70:	74 97       	sbiw	r30, 0x14	; 20
	     strMemory[i]=data;
   10b72:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10b74:	92 e0       	ldi	r25, 0x02	; 2
   10b76:	ec 36       	cpi	r30, 0x6C	; 108
   10b78:	f9 07       	cpc	r31, r25
   10b7a:	d9 f7       	brne	.-10     	; 0x10b72 <FTestCalculation+0x7c>
	     strMemory[i]=data;
   10b7c:	1d 92       	st	X+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10b7e:	82 e0       	ldi	r24, 0x02	; 2
   10b80:	ac 36       	cpi	r26, 0x6C	; 108
   10b82:	b8 07       	cpc	r27, r24
   10b84:	d9 f7       	brne	.-10     	; 0x10b7c <FTestCalculation+0x86>
		  lcd_printf(2,1,PSTR("InA:_"));
		  FillChar(InputA,sizeof(InputA),0);
		  FillChar(InputA,sizeof(InputB),0);
		  FillChar(InputA,sizeof(OutputC),0);

		  uiResult=USER_NONE;
   10b86:	10 92 6c 02 	sts	0x026C, r1
          stTestCalc=tcInputA;
   10b8a:	81 e0       	ldi	r24, 0x01	; 1
   10b8c:	11 c0       	rjmp	.+34     	; 0x10bb0 <FTestCalculation+0xba>
	      break;
     case tcInputA:
	      uiResult=UserInput(UI_ALPHANUM_R,2,5,InputA,0,15);
   10b8e:	83 e0       	ldi	r24, 0x03	; 3
   10b90:	62 e0       	ldi	r22, 0x02	; 2
   10b92:	45 e0       	ldi	r20, 0x05	; 5
   10b94:	28 e5       	ldi	r18, 0x58	; 88
   10b96:	32 e0       	ldi	r19, 0x02	; 2
   10b98:	00 e0       	ldi	r16, 0x00	; 0
   10b9a:	10 e0       	ldi	r17, 0x00	; 0
   10b9c:	9f e0       	ldi	r25, 0x0F	; 15
   10b9e:	e9 2e       	mov	r14, r25
   10ba0:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   10ba4:	80 93 6c 02 	sts	0x026C, r24
	      if (uiResult==USER_OK)stTestCalc=tcDispInputA;
   10ba8:	83 30       	cpi	r24, 0x03	; 3
   10baa:	09 f0       	breq	.+2      	; 0x10bae <FTestCalculation+0xb8>
   10bac:	a7 c0       	rjmp	.+334    	; 0x10cfc <FTestCalculation+0x206>
   10bae:	82 e0       	ldi	r24, 0x02	; 2
   10bb0:	80 93 6d 02 	sts	0x026D, r24
   10bb4:	a3 c0       	rjmp	.+326    	; 0x10cfc <FTestCalculation+0x206>
	      break;
     case tcDispInputA:
	      sprintf_P(lcdteks,PSTR("InA:%s"),InputA);
   10bb6:	00 d0       	rcall	.+0      	; 0x10bb8 <FTestCalculation+0xc2>
   10bb8:	00 d0       	rcall	.+0      	; 0x10bba <FTestCalculation+0xc4>
   10bba:	00 d0       	rcall	.+0      	; 0x10bbc <FTestCalculation+0xc6>
   10bbc:	ed b7       	in	r30, 0x3d	; 61
   10bbe:	fe b7       	in	r31, 0x3e	; 62
   10bc0:	31 96       	adiw	r30, 0x01	; 1
   10bc2:	8e 01       	movw	r16, r28
   10bc4:	0f 5f       	subi	r16, 0xFF	; 255
   10bc6:	1f 4f       	sbci	r17, 0xFF	; 255
   10bc8:	ad b7       	in	r26, 0x3d	; 61
   10bca:	be b7       	in	r27, 0x3e	; 62
   10bcc:	12 96       	adiw	r26, 0x02	; 2
   10bce:	1c 93       	st	X, r17
   10bd0:	0e 93       	st	-X, r16
   10bd2:	11 97       	sbiw	r26, 0x01	; 1
   10bd4:	8a e4       	ldi	r24, 0x4A	; 74
   10bd6:	96 e0       	ldi	r25, 0x06	; 6
   10bd8:	93 83       	std	Z+3, r25	; 0x03
   10bda:	82 83       	std	Z+2, r24	; 0x02
   10bdc:	88 e5       	ldi	r24, 0x58	; 88
   10bde:	92 e0       	ldi	r25, 0x02	; 2
   10be0:	95 83       	std	Z+5, r25	; 0x05
   10be2:	84 83       	std	Z+4, r24	; 0x04
   10be4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10be8:	8d b7       	in	r24, 0x3d	; 61
   10bea:	9e b7       	in	r25, 0x3e	; 62
   10bec:	06 96       	adiw	r24, 0x06	; 6
   10bee:	0f b6       	in	r0, 0x3f	; 63
   10bf0:	f8 94       	cli
   10bf2:	9e bf       	out	0x3e, r25	; 62
   10bf4:	0f be       	out	0x3f, r0	; 63
   10bf6:	8d bf       	out	0x3d, r24	; 61
   10bf8:	82 e0       	ldi	r24, 0x02	; 2
   10bfa:	61 e0       	ldi	r22, 0x01	; 1
   10bfc:	a8 01       	movw	r20, r16
   10bfe:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(3,1,PSTR("InB:_"));
   10c02:	83 e0       	ldi	r24, 0x03	; 3
   10c04:	61 e0       	ldi	r22, 0x01	; 1
   10c06:	44 e4       	ldi	r20, 0x44	; 68
   10c08:	56 e0       	ldi	r21, 0x06	; 6
   10c0a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  uiResult=USER_NONE;
   10c0e:	10 92 6c 02 	sts	0x026C, r1
          stTestCalc=tcInputB;
   10c12:	83 e0       	ldi	r24, 0x03	; 3
   10c14:	cd cf       	rjmp	.-102    	; 0x10bb0 <FTestCalculation+0xba>
	      break;
     case tcInputB:
	 	  uiResult=UserInput(UI_ALPHANUM_R,3,5,InputB,0,15);
   10c16:	83 e0       	ldi	r24, 0x03	; 3
   10c18:	63 e0       	ldi	r22, 0x03	; 3
   10c1a:	45 e0       	ldi	r20, 0x05	; 5
   10c1c:	24 e4       	ldi	r18, 0x44	; 68
   10c1e:	32 e0       	ldi	r19, 0x02	; 2
   10c20:	00 e0       	ldi	r16, 0x00	; 0
   10c22:	10 e0       	ldi	r17, 0x00	; 0
   10c24:	bf e0       	ldi	r27, 0x0F	; 15
   10c26:	eb 2e       	mov	r14, r27
   10c28:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   10c2c:	80 93 6c 02 	sts	0x026C, r24
	      if (uiResult==USER_OK)stTestCalc=tcCalcualte;
   10c30:	83 30       	cpi	r24, 0x03	; 3
   10c32:	09 f0       	breq	.+2      	; 0x10c36 <FTestCalculation+0x140>
   10c34:	63 c0       	rjmp	.+198    	; 0x10cfc <FTestCalculation+0x206>
   10c36:	84 e0       	ldi	r24, 0x04	; 4
   10c38:	bb cf       	rjmp	.-138    	; 0x10bb0 <FTestCalculation+0xba>
	      break;
     case tcCalcualte:
	      sprintf_P(lcdteks,PSTR("InB:%s"),InputB);
   10c3a:	00 d0       	rcall	.+0      	; 0x10c3c <FTestCalculation+0x146>
   10c3c:	00 d0       	rcall	.+0      	; 0x10c3e <FTestCalculation+0x148>
   10c3e:	00 d0       	rcall	.+0      	; 0x10c40 <FTestCalculation+0x14a>
   10c40:	ed b7       	in	r30, 0x3d	; 61
   10c42:	fe b7       	in	r31, 0x3e	; 62
   10c44:	31 96       	adiw	r30, 0x01	; 1
   10c46:	8e 01       	movw	r16, r28
   10c48:	0f 5f       	subi	r16, 0xFF	; 255
   10c4a:	1f 4f       	sbci	r17, 0xFF	; 255
   10c4c:	ad b7       	in	r26, 0x3d	; 61
   10c4e:	be b7       	in	r27, 0x3e	; 62
   10c50:	12 96       	adiw	r26, 0x02	; 2
   10c52:	1c 93       	st	X, r17
   10c54:	0e 93       	st	-X, r16
   10c56:	11 97       	sbiw	r26, 0x01	; 1
   10c58:	8d e3       	ldi	r24, 0x3D	; 61
   10c5a:	96 e0       	ldi	r25, 0x06	; 6
   10c5c:	93 83       	std	Z+3, r25	; 0x03
   10c5e:	82 83       	std	Z+2, r24	; 0x02
   10c60:	a4 e4       	ldi	r26, 0x44	; 68
   10c62:	ea 2e       	mov	r14, r26
   10c64:	a2 e0       	ldi	r26, 0x02	; 2
   10c66:	fa 2e       	mov	r15, r26
   10c68:	f5 82       	std	Z+5, r15	; 0x05
   10c6a:	e4 82       	std	Z+4, r14	; 0x04
   10c6c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10c70:	8d b7       	in	r24, 0x3d	; 61
   10c72:	9e b7       	in	r25, 0x3e	; 62
   10c74:	06 96       	adiw	r24, 0x06	; 6
   10c76:	0f b6       	in	r0, 0x3f	; 63
   10c78:	f8 94       	cli
   10c7a:	9e bf       	out	0x3e, r25	; 62
   10c7c:	0f be       	out	0x3f, r0	; 63
   10c7e:	8d bf       	out	0x3d, r24	; 61
   10c80:	83 e0       	ldi	r24, 0x03	; 3
   10c82:	61 e0       	ldi	r22, 0x01	; 1
   10c84:	a8 01       	movw	r20, r16
   10c86:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  //StrCalc(TMINUS,InputA,InputB,OutputC);
		  //StrCalc(TPLUS,InputA,InputB,OutputC);
		  StrCalc(TMULTIPLY,InputA,InputB,OutputC);
   10c8a:	70 e3       	ldi	r23, 0x30	; 48
   10c8c:	c7 2e       	mov	r12, r23
   10c8e:	72 e0       	ldi	r23, 0x02	; 2
   10c90:	d7 2e       	mov	r13, r23
   10c92:	82 e0       	ldi	r24, 0x02	; 2
   10c94:	68 e5       	ldi	r22, 0x58	; 88
   10c96:	72 e0       	ldi	r23, 0x02	; 2
   10c98:	a7 01       	movw	r20, r14
   10c9a:	96 01       	movw	r18, r12
   10c9c:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <StrCalc>
	      sprintf_P(lcdteks,PSTR("A+B:%s"),OutputC);
   10ca0:	00 d0       	rcall	.+0      	; 0x10ca2 <FTestCalculation+0x1ac>
   10ca2:	00 d0       	rcall	.+0      	; 0x10ca4 <FTestCalculation+0x1ae>
   10ca4:	00 d0       	rcall	.+0      	; 0x10ca6 <FTestCalculation+0x1b0>
   10ca6:	ed b7       	in	r30, 0x3d	; 61
   10ca8:	fe b7       	in	r31, 0x3e	; 62
   10caa:	31 96       	adiw	r30, 0x01	; 1
   10cac:	ad b7       	in	r26, 0x3d	; 61
   10cae:	be b7       	in	r27, 0x3e	; 62
   10cb0:	12 96       	adiw	r26, 0x02	; 2
   10cb2:	1c 93       	st	X, r17
   10cb4:	0e 93       	st	-X, r16
   10cb6:	11 97       	sbiw	r26, 0x01	; 1
   10cb8:	86 e3       	ldi	r24, 0x36	; 54
   10cba:	96 e0       	ldi	r25, 0x06	; 6
   10cbc:	93 83       	std	Z+3, r25	; 0x03
   10cbe:	82 83       	std	Z+2, r24	; 0x02
   10cc0:	d5 82       	std	Z+5, r13	; 0x05
   10cc2:	c4 82       	std	Z+4, r12	; 0x04
   10cc4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10cc8:	8d b7       	in	r24, 0x3d	; 61
   10cca:	9e b7       	in	r25, 0x3e	; 62
   10ccc:	06 96       	adiw	r24, 0x06	; 6
   10cce:	0f b6       	in	r0, 0x3f	; 63
   10cd0:	f8 94       	cli
   10cd2:	9e bf       	out	0x3e, r25	; 62
   10cd4:	0f be       	out	0x3f, r0	; 63
   10cd6:	8d bf       	out	0x3d, r24	; 61
   10cd8:	84 e0       	ldi	r24, 0x04	; 4
   10cda:	61 e0       	ldi	r22, 0x01	; 1
   10cdc:	a8 01       	movw	r20, r16
   10cde:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          stTestCalc=tcWaitEnter;
   10ce2:	85 e0       	ldi	r24, 0x05	; 5
   10ce4:	65 cf       	rjmp	.-310    	; 0x10bb0 <FTestCalculation+0xba>
	      break;
     case tcWaitEnter:
	      KeyChar= _key_btn(_key_scan(1));       
   10ce6:	81 e0       	ldi	r24, 0x01	; 1
   10ce8:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   10cec:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		  if (KeyChar=='#')stTestCalc=tcInitData;
   10cf0:	83 32       	cpi	r24, 0x23	; 35
   10cf2:	11 f0       	breq	.+4      	; 0x10cf8 <FTestCalculation+0x202>
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
   10cf4:	8a 32       	cpi	r24, 0x2A	; 42
   10cf6:	11 f4       	brne	.+4      	; 0x10cfc <FTestCalculation+0x206>
   10cf8:	10 92 6d 02 	sts	0x026D, r1
	      break;	 
	 }
}
   10cfc:	64 96       	adiw	r28, 0x14	; 20
   10cfe:	0f b6       	in	r0, 0x3f	; 63
   10d00:	f8 94       	cli
   10d02:	de bf       	out	0x3e, r29	; 62
   10d04:	0f be       	out	0x3f, r0	; 63
   10d06:	cd bf       	out	0x3d, r28	; 61
   10d08:	cf 91       	pop	r28
   10d0a:	df 91       	pop	r29
   10d0c:	1f 91       	pop	r17
   10d0e:	0f 91       	pop	r16
   10d10:	ff 90       	pop	r15
   10d12:	ef 90       	pop	r14
   10d14:	df 90       	pop	r13
   10d16:	cf 90       	pop	r12
   10d18:	08 95       	ret

00010d1a <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   10d1a:	ef 92       	push	r14
   10d1c:	0f 93       	push	r16
   10d1e:	1f 93       	push	r17
   10d20:	df 93       	push	r29
   10d22:	cf 93       	push	r28
   10d24:	cd b7       	in	r28, 0x3d	; 61
   10d26:	de b7       	in	r29, 0x3e	; 62
   10d28:	64 97       	sbiw	r28, 0x14	; 20
   10d2a:	0f b6       	in	r0, 0x3f	; 63
   10d2c:	f8 94       	cli
   10d2e:	de bf       	out	0x3e, r29	; 62
   10d30:	0f be       	out	0x3f, r0	; 63
   10d32:	cd bf       	out	0x3d, r28	; 61
static char uiResult=USER_NONE,iPos,iSend,KeyPressed,KeyChar,FIP_Used,zFIP_Used;
static unsigned int iLoop=0;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   10d34:	80 91 eb 02 	lds	r24, 0x02EB
   10d38:	86 30       	cpi	r24, 0x06	; 6
   10d3a:	09 f4       	brne	.+2      	; 0x10d3e <FMenuTicket+0x24>
   10d3c:	c8 c0       	rjmp	.+400    	; 0x10ece <FMenuTicket+0x1b4>
   10d3e:	87 30       	cpi	r24, 0x07	; 7
   10d40:	90 f4       	brcc	.+36     	; 0x10d66 <FMenuTicket+0x4c>
   10d42:	82 30       	cpi	r24, 0x02	; 2
   10d44:	09 f4       	brne	.+2      	; 0x10d48 <FMenuTicket+0x2e>
   10d46:	3f c0       	rjmp	.+126    	; 0x10dc6 <FMenuTicket+0xac>
   10d48:	83 30       	cpi	r24, 0x03	; 3
   10d4a:	30 f4       	brcc	.+12     	; 0x10d58 <FMenuTicket+0x3e>
   10d4c:	88 23       	and	r24, r24
   10d4e:	09 f1       	breq	.+66     	; 0x10d92 <FMenuTicket+0x78>
   10d50:	81 30       	cpi	r24, 0x01	; 1
   10d52:	09 f0       	breq	.+2      	; 0x10d56 <FMenuTicket+0x3c>
   10d54:	33 c1       	rjmp	.+614    	; 0x10fbc <FMenuTicket+0x2a2>
   10d56:	1f c0       	rjmp	.+62     	; 0x10d96 <FMenuTicket+0x7c>
   10d58:	84 30       	cpi	r24, 0x04	; 4
   10d5a:	09 f4       	brne	.+2      	; 0x10d5e <FMenuTicket+0x44>
   10d5c:	8d c0       	rjmp	.+282    	; 0x10e78 <FMenuTicket+0x15e>
   10d5e:	85 30       	cpi	r24, 0x05	; 5
   10d60:	08 f0       	brcs	.+2      	; 0x10d64 <FMenuTicket+0x4a>
   10d62:	af c0       	rjmp	.+350    	; 0x10ec2 <FMenuTicket+0x1a8>
   10d64:	51 c0       	rjmp	.+162    	; 0x10e08 <FMenuTicket+0xee>
   10d66:	89 30       	cpi	r24, 0x09	; 9
   10d68:	09 f4       	brne	.+2      	; 0x10d6c <FMenuTicket+0x52>
   10d6a:	03 c1       	rjmp	.+518    	; 0x10f72 <FMenuTicket+0x258>
   10d6c:	8a 30       	cpi	r24, 0x0A	; 10
   10d6e:	38 f4       	brcc	.+14     	; 0x10d7e <FMenuTicket+0x64>
   10d70:	87 30       	cpi	r24, 0x07	; 7
   10d72:	09 f4       	brne	.+2      	; 0x10d76 <FMenuTicket+0x5c>
   10d74:	df c0       	rjmp	.+446    	; 0x10f34 <FMenuTicket+0x21a>
   10d76:	88 30       	cpi	r24, 0x08	; 8
   10d78:	09 f0       	breq	.+2      	; 0x10d7c <FMenuTicket+0x62>
   10d7a:	20 c1       	rjmp	.+576    	; 0x10fbc <FMenuTicket+0x2a2>
   10d7c:	cb c0       	rjmp	.+406    	; 0x10f14 <FMenuTicket+0x1fa>
   10d7e:	8b 30       	cpi	r24, 0x0B	; 11
   10d80:	09 f4       	brne	.+2      	; 0x10d84 <FMenuTicket+0x6a>
   10d82:	fd c0       	rjmp	.+506    	; 0x10f7e <FMenuTicket+0x264>
   10d84:	8b 30       	cpi	r24, 0x0B	; 11
   10d86:	08 f4       	brcc	.+2      	; 0x10d8a <FMenuTicket+0x70>
   10d88:	13 c1       	rjmp	.+550    	; 0x10fb0 <FMenuTicket+0x296>
   10d8a:	8c 30       	cpi	r24, 0x0C	; 12
   10d8c:	09 f0       	breq	.+2      	; 0x10d90 <FMenuTicket+0x76>
   10d8e:	16 c1       	rjmp	.+556    	; 0x10fbc <FMenuTicket+0x2a2>
   10d90:	11 c1       	rjmp	.+546    	; 0x10fb4 <FMenuTicket+0x29a>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   10d92:	81 e0       	ldi	r24, 0x01	; 1
   10d94:	81 c0       	rjmp	.+258    	; 0x10e98 <FMenuTicket+0x17e>
	     break;
    case mtPlatNo:
	     lcd_clear();
   10d96:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   10d9a:	81 e0       	ldi	r24, 0x01	; 1
   10d9c:	61 e0       	ldi	r22, 0x01	; 1
   10d9e:	48 e9       	ldi	r20, 0x98	; 152
   10da0:	5b e0       	ldi	r21, 0x0B	; 11
   10da2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   10da6:	82 e0       	ldi	r24, 0x02	; 2
   10da8:	61 e0       	ldi	r22, 0x01	; 1
   10daa:	46 e9       	ldi	r20, 0x96	; 150
   10dac:	5b e0       	ldi	r21, 0x0B	; 11
   10dae:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10db2:	84 e0       	ldi	r24, 0x04	; 4
   10db4:	61 e0       	ldi	r22, 0x01	; 1
   10db6:	41 e8       	ldi	r20, 0x81	; 129
   10db8:	5b e0       	ldi	r21, 0x0B	; 11
   10dba:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		 uiResult=USER_NONE;
   10dbe:	10 92 ea 02 	sts	0x02EA, r1
		 stMenuTicket=mtInputPlatNo;
   10dc2:	82 e0       	ldi	r24, 0x02	; 2
   10dc4:	69 c0       	rjmp	.+210    	; 0x10e98 <FMenuTicket+0x17e>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   10dc6:	83 e0       	ldi	r24, 0x03	; 3
   10dc8:	62 e0       	ldi	r22, 0x02	; 2
   10dca:	41 e0       	ldi	r20, 0x01	; 1
   10dcc:	2d ef       	ldi	r18, 0xFD	; 253
   10dce:	3a e0       	ldi	r19, 0x0A	; 10
   10dd0:	00 e0       	ldi	r16, 0x00	; 0
   10dd2:	10 e0       	ldi	r17, 0x00	; 0
   10dd4:	7a e0       	ldi	r23, 0x0A	; 10
   10dd6:	e7 2e       	mov	r14, r23
   10dd8:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   10ddc:	80 93 ea 02 	sts	0x02EA, r24
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10de0:	83 30       	cpi	r24, 0x03	; 3
   10de2:	09 f4       	brne	.+2      	; 0x10de6 <FMenuTicket+0xcc>
   10de4:	59 c0       	rjmp	.+178    	; 0x10e98 <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   10de6:	81 30       	cpi	r24, 0x01	; 1
   10de8:	09 f4       	brne	.+2      	; 0x10dec <FMenuTicket+0xd2>
   10dea:	e2 c0       	rjmp	.+452    	; 0x10fb0 <FMenuTicket+0x296>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10dec:	84 30       	cpi	r24, 0x04	; 4
   10dee:	21 f4       	brne	.+8      	; 0x10df8 <FMenuTicket+0xde>
   10df0:	61 e0       	ldi	r22, 0x01	; 1
   10df2:	4c e6       	ldi	r20, 0x6C	; 108
   10df4:	5b e0       	ldi	r21, 0x0B	; 11
   10df6:	62 c0       	rjmp	.+196    	; 0x10ebc <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10df8:	85 30       	cpi	r24, 0x05	; 5
   10dfa:	09 f0       	breq	.+2      	; 0x10dfe <FMenuTicket+0xe4>
   10dfc:	df c0       	rjmp	.+446    	; 0x10fbc <FMenuTicket+0x2a2>
   10dfe:	84 e0       	ldi	r24, 0x04	; 4
   10e00:	61 e0       	ldi	r22, 0x01	; 1
   10e02:	47 e5       	ldi	r20, 0x57	; 87
   10e04:	5b e0       	ldi	r21, 0x0B	; 11
   10e06:	5a c0       	rjmp	.+180    	; 0x10ebc <FMenuTicket+0x1a2>
	     break;
    case mtOdometer:
	     lcd_clear();
   10e08:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   10e0c:	00 d0       	rcall	.+0      	; 0x10e0e <FMenuTicket+0xf4>
   10e0e:	00 d0       	rcall	.+0      	; 0x10e10 <FMenuTicket+0xf6>
   10e10:	00 d0       	rcall	.+0      	; 0x10e12 <FMenuTicket+0xf8>
   10e12:	ed b7       	in	r30, 0x3d	; 61
   10e14:	fe b7       	in	r31, 0x3e	; 62
   10e16:	31 96       	adiw	r30, 0x01	; 1
   10e18:	8e 01       	movw	r16, r28
   10e1a:	0f 5f       	subi	r16, 0xFF	; 255
   10e1c:	1f 4f       	sbci	r17, 0xFF	; 255
   10e1e:	ad b7       	in	r26, 0x3d	; 61
   10e20:	be b7       	in	r27, 0x3e	; 62
   10e22:	12 96       	adiw	r26, 0x02	; 2
   10e24:	1c 93       	st	X, r17
   10e26:	0e 93       	st	-X, r16
   10e28:	11 97       	sbiw	r26, 0x01	; 1
   10e2a:	8a e4       	ldi	r24, 0x4A	; 74
   10e2c:	9b e0       	ldi	r25, 0x0B	; 11
   10e2e:	93 83       	std	Z+3, r25	; 0x03
   10e30:	82 83       	std	Z+2, r24	; 0x02
   10e32:	8d ef       	ldi	r24, 0xFD	; 253
   10e34:	9a e0       	ldi	r25, 0x0A	; 10
   10e36:	95 83       	std	Z+5, r25	; 0x05
   10e38:	84 83       	std	Z+4, r24	; 0x04
   10e3a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	     lcd_print(1,1,lcdteks);
   10e3e:	8d b7       	in	r24, 0x3d	; 61
   10e40:	9e b7       	in	r25, 0x3e	; 62
   10e42:	06 96       	adiw	r24, 0x06	; 6
   10e44:	0f b6       	in	r0, 0x3f	; 63
   10e46:	f8 94       	cli
   10e48:	9e bf       	out	0x3e, r25	; 62
   10e4a:	0f be       	out	0x3f, r0	; 63
   10e4c:	8d bf       	out	0x3d, r24	; 61
   10e4e:	81 e0       	ldi	r24, 0x01	; 1
   10e50:	61 e0       	ldi	r22, 0x01	; 1
   10e52:	a8 01       	movw	r20, r16
   10e54:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   10e58:	82 e0       	ldi	r24, 0x02	; 2
   10e5a:	61 e0       	ldi	r22, 0x01	; 1
   10e5c:	4e e3       	ldi	r20, 0x3E	; 62
   10e5e:	5b e0       	ldi	r21, 0x0B	; 11
   10e60:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10e64:	84 e0       	ldi	r24, 0x04	; 4
   10e66:	61 e0       	ldi	r22, 0x01	; 1
   10e68:	49 e2       	ldi	r20, 0x29	; 41
   10e6a:	5b e0       	ldi	r21, 0x0B	; 11
   10e6c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		 uiResult=USER_NONE;
   10e70:	10 92 ea 02 	sts	0x02EA, r1
		 stMenuTicket=mtInputOdometer;
   10e74:	84 e0       	ldi	r24, 0x04	; 4
   10e76:	10 c0       	rjmp	.+32     	; 0x10e98 <FMenuTicket+0x17e>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   10e78:	81 e0       	ldi	r24, 0x01	; 1
   10e7a:	62 e0       	ldi	r22, 0x02	; 2
   10e7c:	4a e0       	ldi	r20, 0x0A	; 10
   10e7e:	28 ec       	ldi	r18, 0xC8	; 200
   10e80:	35 e0       	ldi	r19, 0x05	; 5
   10e82:	00 e0       	ldi	r16, 0x00	; 0
   10e84:	10 e0       	ldi	r17, 0x00	; 0
   10e86:	5a e0       	ldi	r21, 0x0A	; 10
   10e88:	e5 2e       	mov	r14, r21
   10e8a:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   10e8e:	80 93 ea 02 	sts	0x02EA, r24
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   10e92:	83 30       	cpi	r24, 0x03	; 3
   10e94:	21 f4       	brne	.+8      	; 0x10e9e <FMenuTicket+0x184>
   10e96:	85 e0       	ldi	r24, 0x05	; 5
   10e98:	80 93 eb 02 	sts	0x02EB, r24
   10e9c:	8f c0       	rjmp	.+286    	; 0x10fbc <FMenuTicket+0x2a2>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   10e9e:	81 30       	cpi	r24, 0x01	; 1
   10ea0:	d9 f3       	breq	.-10     	; 0x10e98 <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10ea2:	84 30       	cpi	r24, 0x04	; 4
   10ea4:	21 f4       	brne	.+8      	; 0x10eae <FMenuTicket+0x194>
   10ea6:	61 e0       	ldi	r22, 0x01	; 1
   10ea8:	44 e1       	ldi	r20, 0x14	; 20
   10eaa:	5b e0       	ldi	r21, 0x0B	; 11
   10eac:	07 c0       	rjmp	.+14     	; 0x10ebc <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10eae:	85 30       	cpi	r24, 0x05	; 5
   10eb0:	09 f0       	breq	.+2      	; 0x10eb4 <FMenuTicket+0x19a>
   10eb2:	84 c0       	rjmp	.+264    	; 0x10fbc <FMenuTicket+0x2a2>
   10eb4:	84 e0       	ldi	r24, 0x04	; 4
   10eb6:	61 e0       	ldi	r22, 0x01	; 1
   10eb8:	4f ef       	ldi	r20, 0xFF	; 255
   10eba:	5a e0       	ldi	r21, 0x0A	; 10
   10ebc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   10ec0:	7d c0       	rjmp	.+250    	; 0x10fbc <FMenuTicket+0x2a2>
	     break;
    case mtFIP:
	     lcd_clear();
   10ec2:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		 _scr_pump();
   10ec6:	0e 94 3a 42 	call	0x8474	; 0x8474 <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10eca:	86 e0       	ldi	r24, 0x06	; 6
   10ecc:	e5 cf       	rjmp	.-54     	; 0x10e98 <FMenuTicket+0x17e>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10ece:	81 e0       	ldi	r24, 0x01	; 1
   10ed0:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   10ed4:	80 93 e7 02 	sts	0x02E7, r24
		 KeyChar=_key_btn(KeyPressed);
   10ed8:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   10edc:	80 93 e6 02 	sts	0x02E6, r24
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10ee0:	81 53       	subi	r24, 0x31	; 49
   10ee2:	88 30       	cpi	r24, 0x08	; 8
   10ee4:	40 f4       	brcc	.+16     	; 0x10ef6 <FMenuTicket+0x1dc>
		     FIP_Used=KeyChar-'0';
   10ee6:	8f 5f       	subi	r24, 0xFF	; 255
   10ee8:	80 93 e5 02 	sts	0x02E5, r24
			 zFIP_Used=FIP_Used;
   10eec:	80 93 e4 02 	sts	0x02E4, r24
		     stMenuTicket=mtSendMsg98;
   10ef0:	87 e0       	ldi	r24, 0x07	; 7
   10ef2:	80 93 eb 02 	sts	0x02EB, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10ef6:	80 91 e7 02 	lds	r24, 0x02E7
   10efa:	87 3e       	cpi	r24, 0xE7	; 231
   10efc:	11 f4       	brne	.+4      	; 0x10f02 <FMenuTicket+0x1e8>
             stMenuTicket=mtOdometer;
   10efe:	83 e0       	ldi	r24, 0x03	; 3
   10f00:	cb cf       	rjmp	.-106    	; 0x10e98 <FMenuTicket+0x17e>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   10f02:	87 3b       	cpi	r24, 0xB7	; 183
   10f04:	09 f0       	breq	.+2      	; 0x10f08 <FMenuTicket+0x1ee>
   10f06:	5a c0       	rjmp	.+180    	; 0x10fbc <FMenuTicket+0x2a2>
		     FIP_Used=zFIP_Used;
   10f08:	80 91 e4 02 	lds	r24, 0x02E4
   10f0c:	80 93 e5 02 	sts	0x02E5, r24
             stMenuTicket=mtInitWaitMessage99;
   10f10:	88 e0       	ldi	r24, 0x08	; 8
   10f12:	c2 cf       	rjmp	.-124    	; 0x10e98 <FMenuTicket+0x17e>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   10f14:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   10f18:	82 e0       	ldi	r24, 0x02	; 2
   10f1a:	61 e0       	ldi	r22, 0x01	; 1
   10f1c:	42 ef       	ldi	r20, 0xF2	; 242
   10f1e:	5a e0       	ldi	r21, 0x0A	; 10
   10f20:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   10f24:	83 e0       	ldi	r24, 0x03	; 3
   10f26:	61 e0       	ldi	r22, 0x01	; 1
   10f28:	4b ee       	ldi	r20, 0xEB	; 235
   10f2a:	5a e0       	ldi	r21, 0x0A	; 10
   10f2c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
         stMenuTicket=mtSendMsg98;
   10f30:	87 e0       	ldi	r24, 0x07	; 7
   10f32:	b2 cf       	rjmp	.-156    	; 0x10e98 <FMenuTicket+0x17e>
	     break;
    case mtSendMsg98:
	     iPos=0;
   10f34:	10 92 e9 02 	sts	0x02E9, r1
		 iSend=0;
   10f38:	10 92 e8 02 	sts	0x02E8, r1
		 IsMessage99=False;
   10f3c:	10 92 cc 01 	sts	0x01CC, r1
		 TimSend=0;
   10f40:	10 92 be 01 	sts	0x01BE, r1
   10f44:	10 92 bd 01 	sts	0x01BD, r1
		 iLoop=0;
   10f48:	10 92 e3 02 	sts	0x02E3, r1
   10f4c:	10 92 e2 02 	sts	0x02E2, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   10f50:	80 91 25 01 	lds	r24, 0x0125
   10f54:	81 30       	cpi	r24, 0x01	; 1
   10f56:	29 f4       	brne	.+10     	; 0x10f62 <FMenuTicket+0x248>
   10f58:	80 91 e5 02 	lds	r24, 0x02E5
   10f5c:	0e 94 83 4c 	call	0x9906	; 0x9906 <sendMessage98>
   10f60:	27 c0       	rjmp	.+78     	; 0x10fb0 <FMenuTicket+0x296>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   10f62:	82 30       	cpi	r24, 0x02	; 2
   10f64:	29 f5       	brne	.+74     	; 0x10fb0 <FMenuTicket+0x296>
   10f66:	80 91 e5 02 	lds	r24, 0x02E5
   10f6a:	60 e0       	ldi	r22, 0x00	; 0
   10f6c:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <PrintStandalone>
   10f70:	1f c0       	rjmp	.+62     	; 0x10fb0 <FMenuTicket+0x296>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   10f72:	80 91 cc 01 	lds	r24, 0x01CC
   10f76:	81 30       	cpi	r24, 0x01	; 1
   10f78:	09 f5       	brne	.+66     	; 0x10fbc <FMenuTicket+0x2a2>
		    stMenuTicket=mtMessage99Received;
   10f7a:	8a e0       	ldi	r24, 0x0A	; 10
   10f7c:	8d cf       	rjmp	.-230    	; 0x10e98 <FMenuTicket+0x17e>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10f7e:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   10f82:	82 e0       	ldi	r24, 0x02	; 2
   10f84:	61 e0       	ldi	r22, 0x01	; 1
   10f86:	47 ed       	ldi	r20, 0xD7	; 215
   10f88:	5a e0       	ldi	r21, 0x0A	; 10
   10f8a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10f8e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10f90:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10f92:	82 e0       	ldi	r24, 0x02	; 2
   10f94:	90 e0       	ldi	r25, 0x00	; 0
   10f96:	90 93 ed 01 	sts	0x01ED, r25
   10f9a:	80 93 ec 01 	sts	0x01EC, r24
   10f9e:	80 e2       	ldi	r24, 0x20	; 32
   10fa0:	9e e4       	ldi	r25, 0x4E	; 78
   10fa2:	29 e1       	ldi	r18, 0x19	; 25
   10fa4:	30 e0       	ldi	r19, 0x00	; 0
   10fa6:	f9 01       	movw	r30, r18
   10fa8:	31 97       	sbiw	r30, 0x01	; 1
   10faa:	f1 f7       	brne	.-4      	; 0x10fa8 <FMenuTicket+0x28e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10fac:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10fae:	d9 f7       	brne	.-10     	; 0x10fa6 <FMenuTicket+0x28c>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10fb0:	8c e0       	ldi	r24, 0x0C	; 12
   10fb2:	72 cf       	rjmp	.-284    	; 0x10e98 <FMenuTicket+0x17e>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10fb4:	10 92 eb 02 	sts	0x02EB, r1
   10fb8:	81 e0       	ldi	r24, 0x01	; 1
   10fba:	01 c0       	rjmp	.+2      	; 0x10fbe <FMenuTicket+0x2a4>
   10fbc:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10fbe:	64 96       	adiw	r28, 0x14	; 20
   10fc0:	0f b6       	in	r0, 0x3f	; 63
   10fc2:	f8 94       	cli
   10fc4:	de bf       	out	0x3e, r29	; 62
   10fc6:	0f be       	out	0x3f, r0	; 63
   10fc8:	cd bf       	out	0x3d, r28	; 61
   10fca:	cf 91       	pop	r28
   10fcc:	df 91       	pop	r29
   10fce:	1f 91       	pop	r17
   10fd0:	0f 91       	pop	r16
   10fd2:	ef 90       	pop	r14
   10fd4:	08 95       	ret

00010fd6 <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
   10fd6:	6f 92       	push	r6
   10fd8:	7f 92       	push	r7
   10fda:	8f 92       	push	r8
   10fdc:	9f 92       	push	r9
   10fde:	af 92       	push	r10
   10fe0:	bf 92       	push	r11
   10fe2:	cf 92       	push	r12
   10fe4:	df 92       	push	r13
   10fe6:	ef 92       	push	r14
   10fe8:	ff 92       	push	r15
   10fea:	0f 93       	push	r16
   10fec:	1f 93       	push	r17
   10fee:	df 93       	push	r29
   10ff0:	cf 93       	push	r28
   10ff2:	cd b7       	in	r28, 0x3d	; 61
   10ff4:	de b7       	in	r29, 0x3e	; 62
   10ff6:	a1 97       	sbiw	r28, 0x21	; 33
   10ff8:	0f b6       	in	r0, 0x3f	; 63
   10ffa:	f8 94       	cli
   10ffc:	de bf       	out	0x3e, r29	; 62
   10ffe:	0f be       	out	0x3f, r0	; 63
   11000:	cd bf       	out	0x3d, r28	; 61
     char x,y,i;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
   11002:	80 91 08 03 	lds	r24, 0x0308
   11006:	83 30       	cpi	r24, 0x03	; 3
   11008:	09 f4       	brne	.+2      	; 0x1100c <FSettingProduct+0x36>
   1100a:	ff c0       	rjmp	.+510    	; 0x1120a <FSettingProduct+0x234>
   1100c:	84 30       	cpi	r24, 0x04	; 4
   1100e:	38 f4       	brcc	.+14     	; 0x1101e <FSettingProduct+0x48>
   11010:	81 30       	cpi	r24, 0x01	; 1
   11012:	09 f4       	brne	.+2      	; 0x11016 <FSettingProduct+0x40>
   11014:	72 c0       	rjmp	.+228    	; 0x110fa <FSettingProduct+0x124>
   11016:	82 30       	cpi	r24, 0x02	; 2
   11018:	08 f0       	brcs	.+2      	; 0x1101c <FSettingProduct+0x46>
   1101a:	82 c0       	rjmp	.+260    	; 0x11120 <FSettingProduct+0x14a>
   1101c:	0a c0       	rjmp	.+20     	; 0x11032 <FSettingProduct+0x5c>
   1101e:	85 30       	cpi	r24, 0x05	; 5
   11020:	09 f4       	brne	.+2      	; 0x11024 <FSettingProduct+0x4e>
   11022:	83 c1       	rjmp	.+774    	; 0x1132a <FSettingProduct+0x354>
   11024:	85 30       	cpi	r24, 0x05	; 5
   11026:	08 f4       	brcc	.+2      	; 0x1102a <FSettingProduct+0x54>
   11028:	a2 c1       	rjmp	.+836    	; 0x1136e <FSettingProduct+0x398>
   1102a:	86 30       	cpi	r24, 0x06	; 6
   1102c:	09 f0       	breq	.+2      	; 0x11030 <FSettingProduct+0x5a>
   1102e:	c9 c1       	rjmp	.+914    	; 0x113c2 <FSettingProduct+0x3ec>
   11030:	c4 c1       	rjmp	.+904    	; 0x113ba <FSettingProduct+0x3e4>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11032:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   11036:	9b ee       	ldi	r25, 0xEB	; 235
   11038:	c9 2e       	mov	r12, r25
   1103a:	90 e0       	ldi	r25, 0x00	; 0
   1103c:	d9 2e       	mov	r13, r25
   1103e:	81 e0       	ldi	r24, 0x01	; 1
   11040:	e8 2e       	mov	r14, r24
   11042:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   11044:	4e 01       	movw	r8, r28
   11046:	08 94       	sec
   11048:	81 1c       	adc	r8, r1
   1104a:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   1104c:	0e e0       	ldi	r16, 0x0E	; 14
   1104e:	a0 2e       	mov	r10, r16
   11050:	b1 2c       	mov	r11, r1
   11052:	ac 0e       	add	r10, r28
   11054:	bd 1e       	adc	r11, r29
   11056:	1b eb       	ldi	r17, 0xBB	; 187
   11058:	61 2e       	mov	r6, r17
   1105a:	10 e1       	ldi	r17, 0x10	; 16
   1105c:	71 2e       	mov	r7, r17
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   1105e:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11060:	1e 2d       	mov	r17, r14
   11062:	11 50       	subi	r17, 0x01	; 1
   11064:	c4 01       	movw	r24, r8
   11066:	b6 01       	movw	r22, r12
   11068:	4d e0       	ldi	r20, 0x0D	; 13
   1106a:	50 e0       	ldi	r21, 0x00	; 0
   1106c:	27 e9       	ldi	r18, 0x97	; 151
   1106e:	32 e1       	ldi	r19, 0x12	; 18
   11070:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   11074:	8d b7       	in	r24, 0x3d	; 61
   11076:	9e b7       	in	r25, 0x3e	; 62
   11078:	08 97       	sbiw	r24, 0x08	; 8
   1107a:	0f b6       	in	r0, 0x3f	; 63
   1107c:	f8 94       	cli
   1107e:	9e bf       	out	0x3e, r25	; 62
   11080:	0f be       	out	0x3f, r0	; 63
   11082:	8d bf       	out	0x3d, r24	; 61
   11084:	ed b7       	in	r30, 0x3d	; 61
   11086:	fe b7       	in	r31, 0x3e	; 62
   11088:	31 96       	adiw	r30, 0x01	; 1
   1108a:	ad b7       	in	r26, 0x3d	; 61
   1108c:	be b7       	in	r27, 0x3e	; 62
   1108e:	12 96       	adiw	r26, 0x02	; 2
   11090:	bc 92       	st	X, r11
   11092:	ae 92       	st	-X, r10
   11094:	11 97       	sbiw	r26, 0x01	; 1
   11096:	73 82       	std	Z+3, r7	; 0x03
   11098:	62 82       	std	Z+2, r6	; 0x02
   1109a:	f5 82       	std	Z+5, r15	; 0x05
   1109c:	e4 82       	std	Z+4, r14	; 0x04
   1109e:	97 82       	std	Z+7, r9	; 0x07
   110a0:	86 82       	std	Z+6, r8	; 0x06
   110a2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   110a6:	8d b7       	in	r24, 0x3d	; 61
   110a8:	9e b7       	in	r25, 0x3e	; 62
   110aa:	08 96       	adiw	r24, 0x08	; 8
   110ac:	0f b6       	in	r0, 0x3f	; 63
   110ae:	f8 94       	cli
   110b0:	9e bf       	out	0x3e, r25	; 62
   110b2:	0f be       	out	0x3f, r0	; 63
   110b4:	8d bf       	out	0x3d, r24	; 61
   110b6:	61 2f       	mov	r22, r17
   110b8:	66 95       	lsr	r22
   110ba:	66 95       	lsr	r22
   110bc:	60 9f       	mul	r22, r16
   110be:	b0 01       	movw	r22, r0
   110c0:	11 24       	eor	r1, r1
   110c2:	6f 5f       	subi	r22, 0xFF	; 255
   110c4:	13 70       	andi	r17, 0x03	; 3
   110c6:	81 2f       	mov	r24, r17
   110c8:	8f 5f       	subi	r24, 0xFF	; 255
   110ca:	a5 01       	movw	r20, r10
   110cc:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
   110d0:	ad e0       	ldi	r26, 0x0D	; 13
   110d2:	b0 e0       	ldi	r27, 0x00	; 0
   110d4:	ca 0e       	add	r12, r26
   110d6:	db 1e       	adc	r13, r27
   110d8:	08 94       	sec
   110da:	e1 1c       	adc	r14, r1
   110dc:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
   110de:	b9 e3       	ldi	r27, 0x39	; 57
   110e0:	cb 16       	cp	r12, r27
   110e2:	b1 e0       	ldi	r27, 0x01	; 1
   110e4:	db 06       	cpc	r13, r27
   110e6:	09 f0       	breq	.+2      	; 0x110ea <FSettingProduct+0x114>
   110e8:	bb cf       	rjmp	.-138    	; 0x11060 <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
   110ea:	84 e0       	ldi	r24, 0x04	; 4
   110ec:	6b e0       	ldi	r22, 0x0B	; 11
   110ee:	44 eb       	ldi	r20, 0xB4	; 180
   110f0:	50 e1       	ldi	r21, 0x10	; 16
   110f2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          stMenuProduct=mpChangeProduct;
   110f6:	81 e0       	ldi	r24, 0x01	; 1
   110f8:	5a c1       	rjmp	.+692    	; 0x113ae <FSettingProduct+0x3d8>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
   110fa:	81 e0       	ldi	r24, 0x01	; 1
   110fc:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   11100:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   11102:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11106:	81 53       	subi	r24, 0x31	; 49
   11108:	86 30       	cpi	r24, 0x06	; 6
   1110a:	28 f4       	brcc	.+10     	; 0x11116 <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
   1110c:	80 93 07 03 	sts	0x0307, r24
			  stMenuProduct=mpDispPrice;
   11110:	82 e0       	ldi	r24, 0x02	; 2
   11112:	80 93 08 03 	sts	0x0308, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
   11116:	17 3e       	cpi	r17, 0xE7	; 231
   11118:	09 f0       	breq	.+2      	; 0x1111c <FSettingProduct+0x146>
   1111a:	53 c1       	rjmp	.+678    	; 0x113c2 <FSettingProduct+0x3ec>
		      stMenuProduct=mpExitMenuProduct;
   1111c:	86 e0       	ldi	r24, 0x06	; 6
   1111e:	47 c1       	rjmp	.+654    	; 0x113ae <FSettingProduct+0x3d8>
   11120:	60 91 07 03 	lds	r22, 0x0307
   11124:	8d e0       	ldi	r24, 0x0D	; 13
   11126:	68 9f       	mul	r22, r24
   11128:	b0 01       	movw	r22, r0
   1112a:	11 24       	eor	r1, r1
   1112c:	65 51       	subi	r22, 0x15	; 21
   1112e:	7f 4f       	sbci	r23, 0xFF	; 255
   11130:	7e 01       	movw	r14, r28
   11132:	08 94       	sec
   11134:	e1 1c       	adc	r14, r1
   11136:	f1 1c       	adc	r15, r1
   11138:	c7 01       	movw	r24, r14
   1113a:	4d e0       	ldi	r20, 0x0D	; 13
   1113c:	50 e0       	ldi	r21, 0x00	; 0
   1113e:	27 e9       	ldi	r18, 0x97	; 151
   11140:	32 e1       	ldi	r19, 0x12	; 18
   11142:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
   11146:	bd ef       	ldi	r27, 0xFD	; 253
   11148:	cb 2e       	mov	r12, r27
   1114a:	b2 e0       	ldi	r27, 0x02	; 2
   1114c:	db 2e       	mov	r13, r27
   1114e:	60 91 07 03 	lds	r22, 0x0307
   11152:	89 e0       	ldi	r24, 0x09	; 9
   11154:	68 9f       	mul	r22, r24
   11156:	b0 01       	movw	r22, r0
   11158:	11 24       	eor	r1, r1
   1115a:	6b 54       	subi	r22, 0x4B	; 75
   1115c:	7f 4f       	sbci	r23, 0xFF	; 255
   1115e:	c6 01       	movw	r24, r12
   11160:	49 e0       	ldi	r20, 0x09	; 9
   11162:	50 e0       	ldi	r21, 0x00	; 0
   11164:	27 e9       	ldi	r18, 0x97	; 151
   11166:	32 e1       	ldi	r19, 0x12	; 18
   11168:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
   1116c:	00 d0       	rcall	.+0      	; 0x1116e <FSettingProduct+0x198>
   1116e:	00 d0       	rcall	.+0      	; 0x11170 <FSettingProduct+0x19a>
   11170:	00 d0       	rcall	.+0      	; 0x11172 <FSettingProduct+0x19c>
   11172:	ed b7       	in	r30, 0x3d	; 61
   11174:	fe b7       	in	r31, 0x3e	; 62
   11176:	31 96       	adiw	r30, 0x01	; 1
   11178:	8e 01       	movw	r16, r28
   1117a:	02 5f       	subi	r16, 0xF2	; 242
   1117c:	1f 4f       	sbci	r17, 0xFF	; 255
   1117e:	ad b7       	in	r26, 0x3d	; 61
   11180:	be b7       	in	r27, 0x3e	; 62
   11182:	12 96       	adiw	r26, 0x02	; 2
   11184:	1c 93       	st	X, r17
   11186:	0e 93       	st	-X, r16
   11188:	11 97       	sbiw	r26, 0x01	; 1
   1118a:	8f ea       	ldi	r24, 0xAF	; 175
   1118c:	90 e1       	ldi	r25, 0x10	; 16
   1118e:	93 83       	std	Z+3, r25	; 0x03
   11190:	82 83       	std	Z+2, r24	; 0x02
   11192:	f5 82       	std	Z+5, r15	; 0x05
   11194:	e4 82       	std	Z+4, r14	; 0x04
   11196:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
   1119a:	8d b7       	in	r24, 0x3d	; 61
   1119c:	9e b7       	in	r25, 0x3e	; 62
   1119e:	06 96       	adiw	r24, 0x06	; 6
   111a0:	0f b6       	in	r0, 0x3f	; 63
   111a2:	f8 94       	cli
   111a4:	9e bf       	out	0x3e, r25	; 62
   111a6:	0f be       	out	0x3f, r0	; 63
   111a8:	8d bf       	out	0x3d, r24	; 61
   111aa:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   111ae:	81 e0       	ldi	r24, 0x01	; 1
   111b0:	61 e0       	ldi	r22, 0x01	; 1
   111b2:	a8 01       	movw	r20, r16
   111b4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
   111b8:	00 d0       	rcall	.+0      	; 0x111ba <FSettingProduct+0x1e4>
   111ba:	00 d0       	rcall	.+0      	; 0x111bc <FSettingProduct+0x1e6>
   111bc:	00 d0       	rcall	.+0      	; 0x111be <FSettingProduct+0x1e8>
   111be:	ed b7       	in	r30, 0x3d	; 61
   111c0:	fe b7       	in	r31, 0x3e	; 62
   111c2:	31 96       	adiw	r30, 0x01	; 1
   111c4:	ad b7       	in	r26, 0x3d	; 61
   111c6:	be b7       	in	r27, 0x3e	; 62
   111c8:	12 96       	adiw	r26, 0x02	; 2
   111ca:	1c 93       	st	X, r17
   111cc:	0e 93       	st	-X, r16
   111ce:	11 97       	sbiw	r26, 0x01	; 1
   111d0:	8a ea       	ldi	r24, 0xAA	; 170
   111d2:	90 e1       	ldi	r25, 0x10	; 16
   111d4:	93 83       	std	Z+3, r25	; 0x03
   111d6:	82 83       	std	Z+2, r24	; 0x02
   111d8:	d5 82       	std	Z+5, r13	; 0x05
   111da:	c4 82       	std	Z+4, r12	; 0x04
   111dc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   111e0:	8d b7       	in	r24, 0x3d	; 61
   111e2:	9e b7       	in	r25, 0x3e	; 62
   111e4:	06 96       	adiw	r24, 0x06	; 6
   111e6:	0f b6       	in	r0, 0x3f	; 63
   111e8:	f8 94       	cli
   111ea:	9e bf       	out	0x3e, r25	; 62
   111ec:	0f be       	out	0x3f, r0	; 63
   111ee:	8d bf       	out	0x3d, r24	; 61
   111f0:	82 e0       	ldi	r24, 0x02	; 2
   111f2:	61 e0       	ldi	r22, 0x01	; 1
   111f4:	a8 01       	movw	r20, r16
   111f6:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
   111fa:	84 e0       	ldi	r24, 0x04	; 4
   111fc:	61 e0       	ldi	r22, 0x01	; 1
   111fe:	4c e9       	ldi	r20, 0x9C	; 156
   11200:	50 e1       	ldi	r21, 0x10	; 16
   11202:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stMenuProduct=mpIsEdit;
   11206:	83 e0       	ldi	r24, 0x03	; 3
   11208:	d2 c0       	rjmp	.+420    	; 0x113ae <FSettingProduct+0x3d8>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
   1120a:	81 e0       	ldi	r24, 0x01	; 1
   1120c:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11210:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		  if (KeyChar=='*'){
   11214:	8a 32       	cpi	r24, 0x2A	; 42
   11216:	09 f4       	brne	.+2      	; 0x1121a <FSettingProduct+0x244>
   11218:	a7 c0       	rjmp	.+334    	; 0x11368 <FSettingProduct+0x392>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
   1121a:	81 33       	cpi	r24, 0x31	; 49
   1121c:	09 f0       	breq	.+2      	; 0x11220 <FSettingProduct+0x24a>
   1121e:	4c c0       	rjmp	.+152    	; 0x112b8 <FSettingProduct+0x2e2>
   11220:	60 91 07 03 	lds	r22, 0x0307
   11224:	8d e0       	ldi	r24, 0x0D	; 13
   11226:	68 9f       	mul	r22, r24
   11228:	b0 01       	movw	r22, r0
   1122a:	11 24       	eor	r1, r1
   1122c:	65 51       	subi	r22, 0x15	; 21
   1122e:	7f 4f       	sbci	r23, 0xFF	; 255
   11230:	8e 01       	movw	r16, r28
   11232:	0f 5f       	subi	r16, 0xFF	; 255
   11234:	1f 4f       	sbci	r17, 0xFF	; 255
   11236:	c8 01       	movw	r24, r16
   11238:	4d e0       	ldi	r20, 0x0D	; 13
   1123a:	50 e0       	ldi	r21, 0x00	; 0
   1123c:	27 e9       	ldi	r18, 0x97	; 151
   1123e:	32 e1       	ldi	r19, 0x12	; 18
   11240:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
   11244:	00 d0       	rcall	.+0      	; 0x11246 <FSettingProduct+0x270>
   11246:	00 d0       	rcall	.+0      	; 0x11248 <FSettingProduct+0x272>
   11248:	00 d0       	rcall	.+0      	; 0x1124a <FSettingProduct+0x274>
   1124a:	ed b7       	in	r30, 0x3d	; 61
   1124c:	fe b7       	in	r31, 0x3e	; 62
   1124e:	31 96       	adiw	r30, 0x01	; 1
   11250:	ae e0       	ldi	r26, 0x0E	; 14
   11252:	ea 2e       	mov	r14, r26
   11254:	f1 2c       	mov	r15, r1
   11256:	ec 0e       	add	r14, r28
   11258:	fd 1e       	adc	r15, r29
   1125a:	ad b7       	in	r26, 0x3d	; 61
   1125c:	be b7       	in	r27, 0x3e	; 62
   1125e:	12 96       	adiw	r26, 0x02	; 2
   11260:	fc 92       	st	X, r15
   11262:	ee 92       	st	-X, r14
   11264:	11 97       	sbiw	r26, 0x01	; 1
   11266:	85 e9       	ldi	r24, 0x95	; 149
   11268:	90 e1       	ldi	r25, 0x10	; 16
   1126a:	93 83       	std	Z+3, r25	; 0x03
   1126c:	82 83       	std	Z+2, r24	; 0x02
   1126e:	15 83       	std	Z+5, r17	; 0x05
   11270:	04 83       	std	Z+4, r16	; 0x04
   11272:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
   11276:	8d b7       	in	r24, 0x3d	; 61
   11278:	9e b7       	in	r25, 0x3e	; 62
   1127a:	06 96       	adiw	r24, 0x06	; 6
   1127c:	0f b6       	in	r0, 0x3f	; 63
   1127e:	f8 94       	cli
   11280:	9e bf       	out	0x3e, r25	; 62
   11282:	0f be       	out	0x3f, r0	; 63
   11284:	8d bf       	out	0x3d, r24	; 61
   11286:	81 e0       	ldi	r24, 0x01	; 1
   11288:	61 e0       	ldi	r22, 0x01	; 1
   1128a:	40 e8       	ldi	r20, 0x80	; 128
   1128c:	50 e1       	ldi	r21, 0x10	; 16
   1128e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		       lcd_print(2,1,lcdteks);
   11292:	82 e0       	ldi	r24, 0x02	; 2
   11294:	61 e0       	ldi	r22, 0x01	; 1
   11296:	a7 01       	movw	r20, r14
   11298:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   1129c:	83 e0       	ldi	r24, 0x03	; 3
   1129e:	61 e0       	ldi	r22, 0x01	; 1
   112a0:	4a e7       	ldi	r20, 0x7A	; 122
   112a2:	50 e1       	ldi	r21, 0x10	; 16
   112a4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   112a8:	84 e0       	ldi	r24, 0x04	; 4
   112aa:	61 e0       	ldi	r22, 0x01	; 1
   112ac:	45 e6       	ldi	r20, 0x65	; 101
   112ae:	50 e1       	ldi	r21, 0x10	; 16
   112b0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		      stMenuProduct=mpEditProductName;
   112b4:	85 e0       	ldi	r24, 0x05	; 5
   112b6:	7b c0       	rjmp	.+246    	; 0x113ae <FSettingProduct+0x3d8>
		  }else
		  if (KeyChar=='2'){
   112b8:	82 33       	cpi	r24, 0x32	; 50
   112ba:	09 f0       	breq	.+2      	; 0x112be <FSettingProduct+0x2e8>
   112bc:	82 c0       	rjmp	.+260    	; 0x113c2 <FSettingProduct+0x3ec>
		      uiResult=USER_NONE;
   112be:	10 92 06 03 	sts	0x0306, r1
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
   112c2:	00 d0       	rcall	.+0      	; 0x112c4 <FSettingProduct+0x2ee>
   112c4:	00 d0       	rcall	.+0      	; 0x112c6 <FSettingProduct+0x2f0>
   112c6:	00 d0       	rcall	.+0      	; 0x112c8 <FSettingProduct+0x2f2>
   112c8:	ed b7       	in	r30, 0x3d	; 61
   112ca:	fe b7       	in	r31, 0x3e	; 62
   112cc:	31 96       	adiw	r30, 0x01	; 1
   112ce:	8e 01       	movw	r16, r28
   112d0:	02 5f       	subi	r16, 0xF2	; 242
   112d2:	1f 4f       	sbci	r17, 0xFF	; 255
   112d4:	ad b7       	in	r26, 0x3d	; 61
   112d6:	be b7       	in	r27, 0x3e	; 62
   112d8:	12 96       	adiw	r26, 0x02	; 2
   112da:	1c 93       	st	X, r17
   112dc:	0e 93       	st	-X, r16
   112de:	11 97       	sbiw	r26, 0x01	; 1
   112e0:	8e e5       	ldi	r24, 0x5E	; 94
   112e2:	90 e1       	ldi	r25, 0x10	; 16
   112e4:	93 83       	std	Z+3, r25	; 0x03
   112e6:	82 83       	std	Z+2, r24	; 0x02
   112e8:	8d ef       	ldi	r24, 0xFD	; 253
   112ea:	92 e0       	ldi	r25, 0x02	; 2
   112ec:	95 83       	std	Z+5, r25	; 0x05
   112ee:	84 83       	std	Z+4, r24	; 0x04
   112f0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		       lcd_print(2,1,lcdteks);
   112f4:	8d b7       	in	r24, 0x3d	; 61
   112f6:	9e b7       	in	r25, 0x3e	; 62
   112f8:	06 96       	adiw	r24, 0x06	; 6
   112fa:	0f b6       	in	r0, 0x3f	; 63
   112fc:	f8 94       	cli
   112fe:	9e bf       	out	0x3e, r25	; 62
   11300:	0f be       	out	0x3f, r0	; 63
   11302:	8d bf       	out	0x3d, r24	; 61
   11304:	82 e0       	ldi	r24, 0x02	; 2
   11306:	61 e0       	ldi	r22, 0x01	; 1
   11308:	a8 01       	movw	r20, r16
   1130a:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   1130e:	83 e0       	ldi	r24, 0x03	; 3
   11310:	61 e0       	ldi	r22, 0x01	; 1
   11312:	48 e5       	ldi	r20, 0x58	; 88
   11314:	50 e1       	ldi	r21, 0x10	; 16
   11316:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   1131a:	84 e0       	ldi	r24, 0x04	; 4
   1131c:	61 e0       	ldi	r22, 0x01	; 1
   1131e:	43 e4       	ldi	r20, 0x43	; 67
   11320:	50 e1       	ldi	r21, 0x10	; 16
   11322:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		      stMenuProduct=mpEditPrice;
   11326:	84 e0       	ldi	r24, 0x04	; 4
   11328:	42 c0       	rjmp	.+132    	; 0x113ae <FSettingProduct+0x3d8>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
   1132a:	83 e0       	ldi	r24, 0x03	; 3
   1132c:	63 e0       	ldi	r22, 0x03	; 3
   1132e:	45 e0       	ldi	r20, 0x05	; 5
   11330:	28 e3       	ldi	r18, 0x38	; 56
   11332:	3a e0       	ldi	r19, 0x0A	; 10
   11334:	00 e0       	ldi	r16, 0x00	; 0
   11336:	10 e0       	ldi	r17, 0x00	; 0
   11338:	fa e0       	ldi	r31, 0x0A	; 10
   1133a:	ef 2e       	mov	r14, r31
   1133c:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   11340:	80 93 06 03 	sts	0x0306, r24
		  if (uiResult==USER_OK){
   11344:	83 30       	cpi	r24, 0x03	; 3
   11346:	b1 f5       	brne	.+108    	; 0x113b4 <FSettingProduct+0x3de>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   11348:	80 91 07 03 	lds	r24, 0x0307
   1134c:	2d e0       	ldi	r18, 0x0D	; 13
   1134e:	82 9f       	mul	r24, r18
   11350:	c0 01       	movw	r24, r0
   11352:	11 24       	eor	r1, r1
   11354:	85 51       	subi	r24, 0x15	; 21
   11356:	9f 4f       	sbci	r25, 0xFF	; 255
   11358:	68 e3       	ldi	r22, 0x38	; 56
   1135a:	7a e0       	ldi	r23, 0x0A	; 10
   1135c:	4d e0       	ldi	r20, 0x0D	; 13
   1135e:	50 e0       	ldi	r21, 0x00	; 0
   11360:	2f e9       	ldi	r18, 0x9F	; 159
   11362:	32 e1       	ldi	r19, 0x12	; 18
   11364:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
   11368:	10 92 08 03 	sts	0x0308, r1
   1136c:	2a c0       	rjmp	.+84     	; 0x113c2 <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
   1136e:	81 e0       	ldi	r24, 0x01	; 1
   11370:	63 e0       	ldi	r22, 0x03	; 3
   11372:	45 e0       	ldi	r20, 0x05	; 5
   11374:	2d ef       	ldi	r18, 0xFD	; 253
   11376:	32 e0       	ldi	r19, 0x02	; 2
   11378:	00 e0       	ldi	r16, 0x00	; 0
   1137a:	10 e0       	ldi	r17, 0x00	; 0
   1137c:	e7 e0       	ldi	r30, 0x07	; 7
   1137e:	ee 2e       	mov	r14, r30
   11380:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   11384:	80 93 06 03 	sts	0x0306, r24
		  if (uiResult==USER_OK){
   11388:	83 30       	cpi	r24, 0x03	; 3
   1138a:	a1 f4       	brne	.+40     	; 0x113b4 <FSettingProduct+0x3de>
   1138c:	80 91 07 03 	lds	r24, 0x0307
   11390:	29 e0       	ldi	r18, 0x09	; 9
   11392:	82 9f       	mul	r24, r18
   11394:	c0 01       	movw	r24, r0
   11396:	11 24       	eor	r1, r1
   11398:	8b 54       	subi	r24, 0x4B	; 75
   1139a:	9f 4f       	sbci	r25, 0xFF	; 255
   1139c:	6d ef       	ldi	r22, 0xFD	; 253
   1139e:	72 e0       	ldi	r23, 0x02	; 2
   113a0:	49 e0       	ldi	r20, 0x09	; 9
   113a2:	50 e0       	ldi	r21, 0x00	; 0
   113a4:	2f e9       	ldi	r18, 0x9F	; 159
   113a6:	32 e1       	ldi	r19, 0x12	; 18
   113a8:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
   113ac:	82 e0       	ldi	r24, 0x02	; 2
   113ae:	80 93 08 03 	sts	0x0308, r24
   113b2:	07 c0       	rjmp	.+14     	; 0x113c2 <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
   113b4:	81 30       	cpi	r24, 0x01	; 1
   113b6:	29 f4       	brne	.+10     	; 0x113c2 <FSettingProduct+0x3ec>
   113b8:	f9 cf       	rjmp	.-14     	; 0x113ac <FSettingProduct+0x3d6>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
   113ba:	10 92 08 03 	sts	0x0308, r1
   113be:	81 e0       	ldi	r24, 0x01	; 1
   113c0:	01 c0       	rjmp	.+2      	; 0x113c4 <FSettingProduct+0x3ee>
   113c2:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   113c4:	a1 96       	adiw	r28, 0x21	; 33
   113c6:	0f b6       	in	r0, 0x3f	; 63
   113c8:	f8 94       	cli
   113ca:	de bf       	out	0x3e, r29	; 62
   113cc:	0f be       	out	0x3f, r0	; 63
   113ce:	cd bf       	out	0x3d, r28	; 61
   113d0:	cf 91       	pop	r28
   113d2:	df 91       	pop	r29
   113d4:	1f 91       	pop	r17
   113d6:	0f 91       	pop	r16
   113d8:	ff 90       	pop	r15
   113da:	ef 90       	pop	r14
   113dc:	df 90       	pop	r13
   113de:	cf 90       	pop	r12
   113e0:	bf 90       	pop	r11
   113e2:	af 90       	pop	r10
   113e4:	9f 90       	pop	r9
   113e6:	8f 90       	pop	r8
   113e8:	7f 90       	pop	r7
   113ea:	6f 90       	pop	r6
   113ec:	08 95       	ret

000113ee <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
   113ee:	ef 92       	push	r14
   113f0:	0f 93       	push	r16
   113f2:	1f 93       	push	r17
   113f4:	df 93       	push	r29
   113f6:	cf 93       	push	r28
   113f8:	cd b7       	in	r28, 0x3d	; 61
   113fa:	de b7       	in	r29, 0x3e	; 62
   113fc:	ed 97       	sbiw	r28, 0x3d	; 61
   113fe:	0f b6       	in	r0, 0x3f	; 63
   11400:	f8 94       	cli
   11402:	de bf       	out	0x3e, r29	; 62
   11404:	0f be       	out	0x3f, r0	; 63
   11406:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[41];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11408:	80 91 33 03 	lds	r24, 0x0333
   1140c:	84 30       	cpi	r24, 0x04	; 4
   1140e:	09 f4       	brne	.+2      	; 0x11412 <FMenuSettingFooter+0x24>
   11410:	3f c1       	rjmp	.+638    	; 0x11690 <FMenuSettingFooter+0x2a2>
   11412:	85 30       	cpi	r24, 0x05	; 5
   11414:	40 f4       	brcc	.+16     	; 0x11426 <FMenuSettingFooter+0x38>
   11416:	81 30       	cpi	r24, 0x01	; 1
   11418:	79 f1       	breq	.+94     	; 0x11478 <FMenuSettingFooter+0x8a>
   1141a:	81 30       	cpi	r24, 0x01	; 1
   1141c:	88 f0       	brcs	.+34     	; 0x11440 <FMenuSettingFooter+0x52>
   1141e:	82 30       	cpi	r24, 0x02	; 2
   11420:	09 f0       	breq	.+2      	; 0x11424 <FMenuSettingFooter+0x36>
   11422:	85 c1       	rjmp	.+778    	; 0x1172e <FMenuSettingFooter+0x340>
   11424:	76 c0       	rjmp	.+236    	; 0x11512 <FMenuSettingFooter+0x124>
   11426:	86 30       	cpi	r24, 0x06	; 6
   11428:	09 f4       	brne	.+2      	; 0x1142c <FMenuSettingFooter+0x3e>
   1142a:	d7 c0       	rjmp	.+430    	; 0x115da <FMenuSettingFooter+0x1ec>
   1142c:	86 30       	cpi	r24, 0x06	; 6
   1142e:	08 f4       	brcc	.+2      	; 0x11432 <FMenuSettingFooter+0x44>
   11430:	bf c0       	rjmp	.+382    	; 0x115b0 <FMenuSettingFooter+0x1c2>
   11432:	87 30       	cpi	r24, 0x07	; 7
   11434:	09 f4       	brne	.+2      	; 0x11438 <FMenuSettingFooter+0x4a>
   11436:	3d c1       	rjmp	.+634    	; 0x116b2 <FMenuSettingFooter+0x2c4>
   11438:	88 30       	cpi	r24, 0x08	; 8
   1143a:	09 f0       	breq	.+2      	; 0x1143e <FMenuSettingFooter+0x50>
   1143c:	78 c1       	rjmp	.+752    	; 0x1172e <FMenuSettingFooter+0x340>
   1143e:	73 c1       	rjmp	.+742    	; 0x11726 <FMenuSettingFooter+0x338>
	 case shInitHeader:
	      lcd_clear();
   11440:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
   11444:	81 e0       	ldi	r24, 0x01	; 1
   11446:	61 e0       	ldi	r22, 0x01	; 1
   11448:	49 e2       	ldi	r20, 0x29	; 41
   1144a:	53 e1       	ldi	r21, 0x13	; 19
   1144c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
   11450:	82 e0       	ldi	r24, 0x02	; 2
   11452:	61 e0       	ldi	r22, 0x01	; 1
   11454:	44 e1       	ldi	r20, 0x14	; 20
   11456:	53 e1       	ldi	r21, 0x13	; 19
   11458:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
   1145c:	83 e0       	ldi	r24, 0x03	; 3
   1145e:	61 e0       	ldi	r22, 0x01	; 1
   11460:	4f ef       	ldi	r20, 0xFF	; 255
   11462:	52 e1       	ldi	r21, 0x12	; 18
   11464:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11468:	84 e0       	ldi	r24, 0x04	; 4
   1146a:	61 e0       	ldi	r22, 0x01	; 1
   1146c:	4a ee       	ldi	r20, 0xEA	; 234
   1146e:	52 e1       	ldi	r21, 0x12	; 18
   11470:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11474:	81 e0       	ldi	r24, 0x01	; 1
   11476:	16 c1       	rjmp	.+556    	; 0x116a4 <FMenuSettingFooter+0x2b6>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11478:	81 e0       	ldi	r24, 0x01	; 1
   1147a:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   1147e:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   11482:	80 93 31 03 	sts	0x0331, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11486:	81 53       	subi	r24, 0x31	; 49
   11488:	86 30       	cpi	r24, 0x06	; 6
   1148a:	e0 f5       	brcc	.+120    	; 0x11504 <FMenuSettingFooter+0x116>
		       HeaderIdx=KeyChar-'1';//
   1148c:	80 93 32 03 	sts	0x0332, r24
			   lcd_clear();
   11490:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
   11494:	00 d0       	rcall	.+0      	; 0x11496 <FMenuSettingFooter+0xa8>
   11496:	00 d0       	rcall	.+0      	; 0x11498 <FMenuSettingFooter+0xaa>
   11498:	00 d0       	rcall	.+0      	; 0x1149a <FMenuSettingFooter+0xac>
   1149a:	ed b7       	in	r30, 0x3d	; 61
   1149c:	fe b7       	in	r31, 0x3e	; 62
   1149e:	31 96       	adiw	r30, 0x01	; 1
   114a0:	8e 01       	movw	r16, r28
   114a2:	0f 5f       	subi	r16, 0xFF	; 255
   114a4:	1f 4f       	sbci	r17, 0xFF	; 255
   114a6:	ad b7       	in	r26, 0x3d	; 61
   114a8:	be b7       	in	r27, 0x3e	; 62
   114aa:	12 96       	adiw	r26, 0x02	; 2
   114ac:	1c 93       	st	X, r17
   114ae:	0e 93       	st	-X, r16
   114b0:	11 97       	sbiw	r26, 0x01	; 1
   114b2:	8b ed       	ldi	r24, 0xDB	; 219
   114b4:	92 e1       	ldi	r25, 0x12	; 18
   114b6:	93 83       	std	Z+3, r25	; 0x03
   114b8:	82 83       	std	Z+2, r24	; 0x02
   114ba:	80 91 32 03 	lds	r24, 0x0332
   114be:	90 e0       	ldi	r25, 0x00	; 0
   114c0:	01 96       	adiw	r24, 0x01	; 1
   114c2:	95 83       	std	Z+5, r25	; 0x05
   114c4:	84 83       	std	Z+4, r24	; 0x04
   114c6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   114ca:	8d b7       	in	r24, 0x3d	; 61
   114cc:	9e b7       	in	r25, 0x3e	; 62
   114ce:	06 96       	adiw	r24, 0x06	; 6
   114d0:	0f b6       	in	r0, 0x3f	; 63
   114d2:	f8 94       	cli
   114d4:	9e bf       	out	0x3e, r25	; 62
   114d6:	0f be       	out	0x3f, r0	; 63
   114d8:	8d bf       	out	0x3d, r24	; 61
   114da:	81 e0       	ldi	r24, 0x01	; 1
   114dc:	61 e0       	ldi	r22, 0x01	; 1
   114de:	a8 01       	movw	r20, r16
   114e0:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   114e4:	84 e0       	ldi	r24, 0x04	; 4
   114e6:	61 e0       	ldi	r22, 0x01	; 1
   114e8:	4c ec       	ldi	r20, 0xCC	; 204
   114ea:	52 e1       	ldi	r21, 0x12	; 18
   114ec:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   114f0:	e6 ef       	ldi	r30, 0xF6	; 246
   114f2:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   114f4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   114f6:	97 e0       	ldi	r25, 0x07	; 7
   114f8:	e7 38       	cpi	r30, 0x87	; 135
   114fa:	f9 07       	cpc	r31, r25
   114fc:	d9 f7       	brne	.-10     	; 0x114f4 <FMenuSettingFooter+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   114fe:	82 e0       	ldi	r24, 0x02	; 2
   11500:	80 93 33 03 	sts	0x0333, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11504:	80 91 31 03 	lds	r24, 0x0331
   11508:	8a 32       	cpi	r24, 0x2A	; 42
   1150a:	09 f0       	breq	.+2      	; 0x1150e <FMenuSettingFooter+0x120>
   1150c:	10 c1       	rjmp	.+544    	; 0x1172e <FMenuSettingFooter+0x340>
   1150e:	88 e0       	ldi	r24, 0x08	; 8
   11510:	c9 c0       	rjmp	.+402    	; 0x116a4 <FMenuSettingFooter+0x2b6>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11512:	83 e0       	ldi	r24, 0x03	; 3
   11514:	62 e0       	ldi	r22, 0x02	; 2
   11516:	41 e0       	ldi	r20, 0x01	; 1
   11518:	26 ef       	ldi	r18, 0xF6	; 246
   1151a:	35 e0       	ldi	r19, 0x05	; 5
   1151c:	00 e0       	ldi	r16, 0x00	; 0
   1151e:	10 e0       	ldi	r17, 0x00	; 0
   11520:	58 e2       	ldi	r21, 0x28	; 40
   11522:	e5 2e       	mov	r14, r21
   11524:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
		  if (uiResult==USER_OK){
   11528:	83 30       	cpi	r24, 0x03	; 3
   1152a:	f1 f5       	brne	.+124    	; 0x115a8 <FMenuSettingFooter+0x1ba>
			  lcd_clear();
   1152c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   11530:	86 ef       	ldi	r24, 0xF6	; 246
   11532:	95 e0       	ldi	r25, 0x05	; 5
   11534:	68 e2       	ldi	r22, 0x28	; 40
   11536:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
   1153a:	20 e0       	ldi	r18, 0x00	; 0
   1153c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1153e:	f9 01       	movw	r30, r18
   11540:	ee 53       	subi	r30, 0x3E	; 62
   11542:	f5 4f       	sbci	r31, 0xF5	; 245
   11544:	d9 01       	movw	r26, r18
   11546:	aa 50       	subi	r26, 0x0A	; 10
   11548:	ba 4f       	sbci	r27, 0xFA	; 250
   1154a:	8c 91       	ld	r24, X
   1154c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1154e:	2f 5f       	subi	r18, 0xFF	; 255
   11550:	3f 4f       	sbci	r19, 0xFF	; 255
   11552:	24 31       	cpi	r18, 0x14	; 20
   11554:	31 05       	cpc	r19, r1
   11556:	99 f7       	brne	.-26     	; 0x1153e <FMenuSettingFooter+0x150>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11558:	10 92 d6 0a 	sts	0x0AD6, r1
   1155c:	ea e0       	ldi	r30, 0x0A	; 10
   1155e:	f6 e0       	ldi	r31, 0x06	; 6
   11560:	ad ea       	ldi	r26, 0xAD	; 173
   11562:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11564:	81 91       	ld	r24, Z+
   11566:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11568:	86 e0       	ldi	r24, 0x06	; 6
   1156a:	ee 31       	cpi	r30, 0x1E	; 30
   1156c:	f8 07       	cpc	r31, r24
   1156e:	d1 f7       	brne	.-12     	; 0x11564 <FMenuSettingFooter+0x176>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11570:	10 92 c1 09 	sts	0x09C1, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   11574:	81 e0       	ldi	r24, 0x01	; 1
   11576:	61 e0       	ldi	r22, 0x01	; 1
   11578:	42 ec       	ldi	r20, 0xC2	; 194
   1157a:	5a e0       	ldi	r21, 0x0A	; 10
   1157c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   11580:	82 e0       	ldi	r24, 0x02	; 2
   11582:	61 e0       	ldi	r22, 0x01	; 1
   11584:	4d ea       	ldi	r20, 0xAD	; 173
   11586:	59 e0       	ldi	r21, 0x09	; 9
   11588:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   1158c:	83 e0       	ldi	r24, 0x03	; 3
   1158e:	61 e0       	ldi	r22, 0x01	; 1
   11590:	4e eb       	ldi	r20, 0xBE	; 190
   11592:	52 e1       	ldi	r21, 0x12	; 18
   11594:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11598:	84 e0       	ldi	r24, 0x04	; 4
   1159a:	61 e0       	ldi	r22, 0x01	; 1
   1159c:	40 eb       	ldi	r20, 0xB0	; 176
   1159e:	52 e1       	ldi	r21, 0x12	; 18
   115a0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   115a4:	85 e0       	ldi	r24, 0x05	; 5
   115a6:	7e c0       	rjmp	.+252    	; 0x116a4 <FMenuSettingFooter+0x2b6>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   115a8:	81 30       	cpi	r24, 0x01	; 1
   115aa:	09 f0       	breq	.+2      	; 0x115ae <FMenuSettingFooter+0x1c0>
   115ac:	c0 c0       	rjmp	.+384    	; 0x1172e <FMenuSettingFooter+0x340>
   115ae:	b8 c0       	rjmp	.+368    	; 0x11720 <FMenuSettingFooter+0x332>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   115b0:	81 e0       	ldi	r24, 0x01	; 1
   115b2:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   115b6:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   115ba:	80 93 31 03 	sts	0x0331, r24
          if(KeyChar=='#'){
   115be:	83 32       	cpi	r24, 0x23	; 35
   115c0:	39 f4       	brne	.+14     	; 0x115d0 <FMenuSettingFooter+0x1e2>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   115c2:	86 ef       	ldi	r24, 0xF6	; 246
   115c4:	95 e0       	ldi	r25, 0x05	; 5
   115c6:	68 e2       	ldi	r22, 0x28	; 40
   115c8:	70 e0       	ldi	r23, 0x00	; 0
   115ca:	0e 94 8a 2c 	call	0x5914	; 0x5914 <StrAlignCenter>
   115ce:	03 c0       	rjmp	.+6      	; 0x115d6 <FMenuSettingFooter+0x1e8>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   115d0:	8a 32       	cpi	r24, 0x2A	; 42
   115d2:	09 f0       	breq	.+2      	; 0x115d6 <FMenuSettingFooter+0x1e8>
   115d4:	ac c0       	rjmp	.+344    	; 0x1172e <FMenuSettingFooter+0x340>
   115d6:	86 e0       	ldi	r24, 0x06	; 6
   115d8:	65 c0       	rjmp	.+202    	; 0x116a4 <FMenuSettingFooter+0x2b6>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   115da:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   115de:	20 e0       	ldi	r18, 0x00	; 0
   115e0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   115e2:	f9 01       	movw	r30, r18
   115e4:	ee 53       	subi	r30, 0x3E	; 62
   115e6:	f5 4f       	sbci	r31, 0xF5	; 245
   115e8:	d9 01       	movw	r26, r18
   115ea:	aa 50       	subi	r26, 0x0A	; 10
   115ec:	ba 4f       	sbci	r27, 0xFA	; 250
   115ee:	8c 91       	ld	r24, X
   115f0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   115f2:	2f 5f       	subi	r18, 0xFF	; 255
   115f4:	3f 4f       	sbci	r19, 0xFF	; 255
   115f6:	24 31       	cpi	r18, 0x14	; 20
   115f8:	31 05       	cpc	r19, r1
   115fa:	99 f7       	brne	.-26     	; 0x115e2 <FMenuSettingFooter+0x1f4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   115fc:	10 92 d6 0a 	sts	0x0AD6, r1
   11600:	ea e0       	ldi	r30, 0x0A	; 10
   11602:	f6 e0       	ldi	r31, 0x06	; 6
   11604:	ad ea       	ldi	r26, 0xAD	; 173
   11606:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11608:	81 91       	ld	r24, Z+
   1160a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1160c:	96 e0       	ldi	r25, 0x06	; 6
   1160e:	ee 31       	cpi	r30, 0x1E	; 30
   11610:	f9 07       	cpc	r31, r25
   11612:	d1 f7       	brne	.-12     	; 0x11608 <FMenuSettingFooter+0x21a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11614:	10 92 c1 09 	sts	0x09C1, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11618:	81 e0       	ldi	r24, 0x01	; 1
   1161a:	61 e0       	ldi	r22, 0x01	; 1
   1161c:	42 ec       	ldi	r20, 0xC2	; 194
   1161e:	5a e0       	ldi	r21, 0x0A	; 10
   11620:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11624:	82 e0       	ldi	r24, 0x02	; 2
   11626:	61 e0       	ldi	r22, 0x01	; 1
   11628:	4d ea       	ldi	r20, 0xAD	; 173
   1162a:	59 e0       	ldi	r21, 0x09	; 9
   1162c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
   11630:	00 d0       	rcall	.+0      	; 0x11632 <FMenuSettingFooter+0x244>
   11632:	00 d0       	rcall	.+0      	; 0x11634 <FMenuSettingFooter+0x246>
   11634:	00 d0       	rcall	.+0      	; 0x11636 <FMenuSettingFooter+0x248>
   11636:	ed b7       	in	r30, 0x3d	; 61
   11638:	fe b7       	in	r31, 0x3e	; 62
   1163a:	31 96       	adiw	r30, 0x01	; 1
   1163c:	8e 01       	movw	r16, r28
   1163e:	0f 5f       	subi	r16, 0xFF	; 255
   11640:	1f 4f       	sbci	r17, 0xFF	; 255
   11642:	ad b7       	in	r26, 0x3d	; 61
   11644:	be b7       	in	r27, 0x3e	; 62
   11646:	12 96       	adiw	r26, 0x02	; 2
   11648:	1c 93       	st	X, r17
   1164a:	0e 93       	st	-X, r16
   1164c:	11 97       	sbiw	r26, 0x01	; 1
   1164e:	80 ea       	ldi	r24, 0xA0	; 160
   11650:	92 e1       	ldi	r25, 0x12	; 18
   11652:	93 83       	std	Z+3, r25	; 0x03
   11654:	82 83       	std	Z+2, r24	; 0x02
   11656:	80 91 32 03 	lds	r24, 0x0332
   1165a:	90 e0       	ldi	r25, 0x00	; 0
   1165c:	01 96       	adiw	r24, 0x01	; 1
   1165e:	95 83       	std	Z+5, r25	; 0x05
   11660:	84 83       	std	Z+4, r24	; 0x04
   11662:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11666:	8d b7       	in	r24, 0x3d	; 61
   11668:	9e b7       	in	r25, 0x3e	; 62
   1166a:	06 96       	adiw	r24, 0x06	; 6
   1166c:	0f b6       	in	r0, 0x3f	; 63
   1166e:	f8 94       	cli
   11670:	9e bf       	out	0x3e, r25	; 62
   11672:	0f be       	out	0x3f, r0	; 63
   11674:	8d bf       	out	0x3d, r24	; 61
   11676:	83 e0       	ldi	r24, 0x03	; 3
   11678:	61 e0       	ldi	r22, 0x01	; 1
   1167a:	a8 01       	movw	r20, r16
   1167c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11680:	84 e0       	ldi	r24, 0x04	; 4
   11682:	61 e0       	ldi	r22, 0x01	; 1
   11684:	43 e9       	ldi	r20, 0x93	; 147
   11686:	52 e1       	ldi	r21, 0x12	; 18
   11688:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   1168c:	84 e0       	ldi	r24, 0x04	; 4
   1168e:	0a c0       	rjmp	.+20     	; 0x116a4 <FMenuSettingFooter+0x2b6>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
   11690:	81 e0       	ldi	r24, 0x01	; 1
   11692:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   11696:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   1169a:	80 93 31 03 	sts	0x0331, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   1169e:	83 32       	cpi	r24, 0x23	; 35
   116a0:	21 f4       	brne	.+8      	; 0x116aa <FMenuSettingFooter+0x2bc>
   116a2:	87 e0       	ldi	r24, 0x07	; 7
   116a4:	80 93 33 03 	sts	0x0333, r24
   116a8:	42 c0       	rjmp	.+132    	; 0x1172e <FMenuSettingFooter+0x340>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   116aa:	8a 32       	cpi	r24, 0x2A	; 42
   116ac:	09 f0       	breq	.+2      	; 0x116b0 <FMenuSettingFooter+0x2c2>
   116ae:	3f c0       	rjmp	.+126    	; 0x1172e <FMenuSettingFooter+0x340>
   116b0:	37 c0       	rjmp	.+110    	; 0x11720 <FMenuSettingFooter+0x332>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   116b2:	ad b7       	in	r26, 0x3d	; 61
   116b4:	be b7       	in	r27, 0x3e	; 62
   116b6:	18 97       	sbiw	r26, 0x08	; 8
   116b8:	0f b6       	in	r0, 0x3f	; 63
   116ba:	f8 94       	cli
   116bc:	be bf       	out	0x3e, r27	; 62
   116be:	0f be       	out	0x3f, r0	; 63
   116c0:	ad bf       	out	0x3d, r26	; 61
   116c2:	ed b7       	in	r30, 0x3d	; 61
   116c4:	fe b7       	in	r31, 0x3e	; 62
   116c6:	31 96       	adiw	r30, 0x01	; 1
   116c8:	8e 01       	movw	r16, r28
   116ca:	0b 5e       	subi	r16, 0xEB	; 235
   116cc:	1f 4f       	sbci	r17, 0xFF	; 255
   116ce:	12 96       	adiw	r26, 0x02	; 2
   116d0:	1c 93       	st	X, r17
   116d2:	0e 93       	st	-X, r16
   116d4:	11 97       	sbiw	r26, 0x01	; 1
   116d6:	8e e8       	ldi	r24, 0x8E	; 142
   116d8:	92 e1       	ldi	r25, 0x12	; 18
   116da:	93 83       	std	Z+3, r25	; 0x03
   116dc:	82 83       	std	Z+2, r24	; 0x02
   116de:	82 ec       	ldi	r24, 0xC2	; 194
   116e0:	9a e0       	ldi	r25, 0x0A	; 10
   116e2:	95 83       	std	Z+5, r25	; 0x05
   116e4:	84 83       	std	Z+4, r24	; 0x04
   116e6:	8d ea       	ldi	r24, 0xAD	; 173
   116e8:	99 e0       	ldi	r25, 0x09	; 9
   116ea:	97 83       	std	Z+7, r25	; 0x07
   116ec:	86 83       	std	Z+6, r24	; 0x06
   116ee:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   116f2:	8d b7       	in	r24, 0x3d	; 61
   116f4:	9e b7       	in	r25, 0x3e	; 62
   116f6:	08 96       	adiw	r24, 0x08	; 8
   116f8:	0f b6       	in	r0, 0x3f	; 63
   116fa:	f8 94       	cli
   116fc:	9e bf       	out	0x3e, r25	; 62
   116fe:	0f be       	out	0x3f, r0	; 63
   11700:	8d bf       	out	0x3d, r24	; 61
   11702:	80 91 32 03 	lds	r24, 0x0332
   11706:	29 e2       	ldi	r18, 0x29	; 41
   11708:	82 9f       	mul	r24, r18
   1170a:	c0 01       	movw	r24, r0
   1170c:	11 24       	eor	r1, r1
   1170e:	83 5b       	subi	r24, 0xB3	; 179
   11710:	9c 4f       	sbci	r25, 0xFC	; 252
   11712:	b8 01       	movw	r22, r16
   11714:	48 e2       	ldi	r20, 0x28	; 40
   11716:	50 e0       	ldi	r21, 0x00	; 0
   11718:	2f e9       	ldi	r18, 0x9F	; 159
   1171a:	32 e1       	ldi	r19, 0x12	; 18
   1171c:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
          stSettingHeader=shInitHeader;
   11720:	10 92 33 03 	sts	0x0333, r1
   11724:	04 c0       	rjmp	.+8      	; 0x1172e <FMenuSettingFooter+0x340>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11726:	10 92 33 03 	sts	0x0333, r1
   1172a:	81 e0       	ldi	r24, 0x01	; 1
   1172c:	01 c0       	rjmp	.+2      	; 0x11730 <FMenuSettingFooter+0x342>
   1172e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
   11730:	ed 96       	adiw	r28, 0x3d	; 61
   11732:	0f b6       	in	r0, 0x3f	; 63
   11734:	f8 94       	cli
   11736:	de bf       	out	0x3e, r29	; 62
   11738:	0f be       	out	0x3f, r0	; 63
   1173a:	cd bf       	out	0x3d, r28	; 61
   1173c:	cf 91       	pop	r28
   1173e:	df 91       	pop	r29
   11740:	1f 91       	pop	r17
   11742:	0f 91       	pop	r16
   11744:	ef 90       	pop	r14
   11746:	08 95       	ret

00011748 <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
   11748:	ef 92       	push	r14
   1174a:	0f 93       	push	r16
   1174c:	1f 93       	push	r17
   1174e:	df 93       	push	r29
   11750:	cf 93       	push	r28
   11752:	cd b7       	in	r28, 0x3d	; 61
   11754:	de b7       	in	r29, 0x3e	; 62
   11756:	c6 54       	subi	r28, 0x46	; 70
   11758:	d0 40       	sbci	r29, 0x00	; 0
   1175a:	0f b6       	in	r0, 0x3f	; 63
   1175c:	f8 94       	cli
   1175e:	de bf       	out	0x3e, r29	; 62
   11760:	0f be       	out	0x3f, r0	; 63
   11762:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11764:	80 91 36 03 	lds	r24, 0x0336
   11768:	84 30       	cpi	r24, 0x04	; 4
   1176a:	09 f4       	brne	.+2      	; 0x1176e <FMenuSettingHeader+0x26>
   1176c:	3f c1       	rjmp	.+638    	; 0x119ec <FMenuSettingHeader+0x2a4>
   1176e:	85 30       	cpi	r24, 0x05	; 5
   11770:	40 f4       	brcc	.+16     	; 0x11782 <FMenuSettingHeader+0x3a>
   11772:	81 30       	cpi	r24, 0x01	; 1
   11774:	79 f1       	breq	.+94     	; 0x117d4 <FMenuSettingHeader+0x8c>
   11776:	81 30       	cpi	r24, 0x01	; 1
   11778:	88 f0       	brcs	.+34     	; 0x1179c <FMenuSettingHeader+0x54>
   1177a:	82 30       	cpi	r24, 0x02	; 2
   1177c:	09 f0       	breq	.+2      	; 0x11780 <FMenuSettingHeader+0x38>
   1177e:	85 c1       	rjmp	.+778    	; 0x11a8a <FMenuSettingHeader+0x342>
   11780:	76 c0       	rjmp	.+236    	; 0x1186e <FMenuSettingHeader+0x126>
   11782:	86 30       	cpi	r24, 0x06	; 6
   11784:	09 f4       	brne	.+2      	; 0x11788 <FMenuSettingHeader+0x40>
   11786:	d7 c0       	rjmp	.+430    	; 0x11936 <FMenuSettingHeader+0x1ee>
   11788:	86 30       	cpi	r24, 0x06	; 6
   1178a:	08 f4       	brcc	.+2      	; 0x1178e <FMenuSettingHeader+0x46>
   1178c:	bf c0       	rjmp	.+382    	; 0x1190c <FMenuSettingHeader+0x1c4>
   1178e:	87 30       	cpi	r24, 0x07	; 7
   11790:	09 f4       	brne	.+2      	; 0x11794 <FMenuSettingHeader+0x4c>
   11792:	3d c1       	rjmp	.+634    	; 0x11a0e <FMenuSettingHeader+0x2c6>
   11794:	88 30       	cpi	r24, 0x08	; 8
   11796:	09 f0       	breq	.+2      	; 0x1179a <FMenuSettingHeader+0x52>
   11798:	78 c1       	rjmp	.+752    	; 0x11a8a <FMenuSettingHeader+0x342>
   1179a:	73 c1       	rjmp	.+742    	; 0x11a82 <FMenuSettingHeader+0x33a>
	 case shInitHeader:
	      lcd_clear();
   1179c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
   117a0:	81 e0       	ldi	r24, 0x01	; 1
   117a2:	61 e0       	ldi	r22, 0x01	; 1
   117a4:	49 ed       	ldi	r20, 0xD9	; 217
   117a6:	53 e1       	ldi	r21, 0x13	; 19
   117a8:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
   117ac:	82 e0       	ldi	r24, 0x02	; 2
   117ae:	61 e0       	ldi	r22, 0x01	; 1
   117b0:	44 ec       	ldi	r20, 0xC4	; 196
   117b2:	53 e1       	ldi	r21, 0x13	; 19
   117b4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
   117b8:	83 e0       	ldi	r24, 0x03	; 3
   117ba:	61 e0       	ldi	r22, 0x01	; 1
   117bc:	4f ea       	ldi	r20, 0xAF	; 175
   117be:	53 e1       	ldi	r21, 0x13	; 19
   117c0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   117c4:	84 e0       	ldi	r24, 0x04	; 4
   117c6:	61 e0       	ldi	r22, 0x01	; 1
   117c8:	4a e9       	ldi	r20, 0x9A	; 154
   117ca:	53 e1       	ldi	r21, 0x13	; 19
   117cc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   117d0:	81 e0       	ldi	r24, 0x01	; 1
   117d2:	16 c1       	rjmp	.+556    	; 0x11a00 <FMenuSettingHeader+0x2b8>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   117d4:	81 e0       	ldi	r24, 0x01	; 1
   117d6:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   117da:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   117de:	80 93 34 03 	sts	0x0334, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   117e2:	81 53       	subi	r24, 0x31	; 49
   117e4:	86 30       	cpi	r24, 0x06	; 6
   117e6:	e0 f5       	brcc	.+120    	; 0x11860 <FMenuSettingHeader+0x118>
		       HeaderIdx=KeyChar-'1';//
   117e8:	80 93 35 03 	sts	0x0335, r24
			   lcd_clear();
   117ec:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
   117f0:	00 d0       	rcall	.+0      	; 0x117f2 <FMenuSettingHeader+0xaa>
   117f2:	00 d0       	rcall	.+0      	; 0x117f4 <FMenuSettingHeader+0xac>
   117f4:	00 d0       	rcall	.+0      	; 0x117f6 <FMenuSettingHeader+0xae>
   117f6:	ed b7       	in	r30, 0x3d	; 61
   117f8:	fe b7       	in	r31, 0x3e	; 62
   117fa:	31 96       	adiw	r30, 0x01	; 1
   117fc:	8e 01       	movw	r16, r28
   117fe:	0f 5f       	subi	r16, 0xFF	; 255
   11800:	1f 4f       	sbci	r17, 0xFF	; 255
   11802:	ad b7       	in	r26, 0x3d	; 61
   11804:	be b7       	in	r27, 0x3e	; 62
   11806:	12 96       	adiw	r26, 0x02	; 2
   11808:	1c 93       	st	X, r17
   1180a:	0e 93       	st	-X, r16
   1180c:	11 97       	sbiw	r26, 0x01	; 1
   1180e:	8b e8       	ldi	r24, 0x8B	; 139
   11810:	93 e1       	ldi	r25, 0x13	; 19
   11812:	93 83       	std	Z+3, r25	; 0x03
   11814:	82 83       	std	Z+2, r24	; 0x02
   11816:	80 91 35 03 	lds	r24, 0x0335
   1181a:	90 e0       	ldi	r25, 0x00	; 0
   1181c:	01 96       	adiw	r24, 0x01	; 1
   1181e:	95 83       	std	Z+5, r25	; 0x05
   11820:	84 83       	std	Z+4, r24	; 0x04
   11822:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11826:	8d b7       	in	r24, 0x3d	; 61
   11828:	9e b7       	in	r25, 0x3e	; 62
   1182a:	06 96       	adiw	r24, 0x06	; 6
   1182c:	0f b6       	in	r0, 0x3f	; 63
   1182e:	f8 94       	cli
   11830:	9e bf       	out	0x3e, r25	; 62
   11832:	0f be       	out	0x3f, r0	; 63
   11834:	8d bf       	out	0x3d, r24	; 61
   11836:	81 e0       	ldi	r24, 0x01	; 1
   11838:	61 e0       	ldi	r22, 0x01	; 1
   1183a:	a8 01       	movw	r20, r16
   1183c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   11840:	84 e0       	ldi	r24, 0x04	; 4
   11842:	61 e0       	ldi	r22, 0x01	; 1
   11844:	4c e7       	ldi	r20, 0x7C	; 124
   11846:	53 e1       	ldi	r21, 0x13	; 19
   11848:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   1184c:	e6 ef       	ldi	r30, 0xF6	; 246
   1184e:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11850:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11852:	97 e0       	ldi	r25, 0x07	; 7
   11854:	e7 38       	cpi	r30, 0x87	; 135
   11856:	f9 07       	cpc	r31, r25
   11858:	d9 f7       	brne	.-10     	; 0x11850 <FMenuSettingHeader+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   1185a:	82 e0       	ldi	r24, 0x02	; 2
   1185c:	80 93 36 03 	sts	0x0336, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11860:	80 91 34 03 	lds	r24, 0x0334
   11864:	8a 32       	cpi	r24, 0x2A	; 42
   11866:	09 f0       	breq	.+2      	; 0x1186a <FMenuSettingHeader+0x122>
   11868:	10 c1       	rjmp	.+544    	; 0x11a8a <FMenuSettingHeader+0x342>
   1186a:	88 e0       	ldi	r24, 0x08	; 8
   1186c:	c9 c0       	rjmp	.+402    	; 0x11a00 <FMenuSettingHeader+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   1186e:	83 e0       	ldi	r24, 0x03	; 3
   11870:	62 e0       	ldi	r22, 0x02	; 2
   11872:	41 e0       	ldi	r20, 0x01	; 1
   11874:	26 ef       	ldi	r18, 0xF6	; 246
   11876:	35 e0       	ldi	r19, 0x05	; 5
   11878:	00 e0       	ldi	r16, 0x00	; 0
   1187a:	10 e0       	ldi	r17, 0x00	; 0
   1187c:	78 e2       	ldi	r23, 0x28	; 40
   1187e:	e7 2e       	mov	r14, r23
   11880:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
		  if (uiResult==USER_OK){
   11884:	83 30       	cpi	r24, 0x03	; 3
   11886:	f1 f5       	brne	.+124    	; 0x11904 <FMenuSettingHeader+0x1bc>
			  lcd_clear();
   11888:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   1188c:	86 ef       	ldi	r24, 0xF6	; 246
   1188e:	95 e0       	ldi	r25, 0x05	; 5
   11890:	68 e2       	ldi	r22, 0x28	; 40
   11892:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
   11896:	20 e0       	ldi	r18, 0x00	; 0
   11898:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1189a:	f9 01       	movw	r30, r18
   1189c:	ee 53       	subi	r30, 0x3E	; 62
   1189e:	f5 4f       	sbci	r31, 0xF5	; 245
   118a0:	d9 01       	movw	r26, r18
   118a2:	aa 50       	subi	r26, 0x0A	; 10
   118a4:	ba 4f       	sbci	r27, 0xFA	; 250
   118a6:	8c 91       	ld	r24, X
   118a8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   118aa:	2f 5f       	subi	r18, 0xFF	; 255
   118ac:	3f 4f       	sbci	r19, 0xFF	; 255
   118ae:	24 31       	cpi	r18, 0x14	; 20
   118b0:	31 05       	cpc	r19, r1
   118b2:	99 f7       	brne	.-26     	; 0x1189a <FMenuSettingHeader+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   118b4:	10 92 d6 0a 	sts	0x0AD6, r1
   118b8:	ea e0       	ldi	r30, 0x0A	; 10
   118ba:	f6 e0       	ldi	r31, 0x06	; 6
   118bc:	ad ea       	ldi	r26, 0xAD	; 173
   118be:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   118c0:	81 91       	ld	r24, Z+
   118c2:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   118c4:	86 e0       	ldi	r24, 0x06	; 6
   118c6:	ee 31       	cpi	r30, 0x1E	; 30
   118c8:	f8 07       	cpc	r31, r24
   118ca:	d1 f7       	brne	.-12     	; 0x118c0 <FMenuSettingHeader+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   118cc:	10 92 c1 09 	sts	0x09C1, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   118d0:	81 e0       	ldi	r24, 0x01	; 1
   118d2:	61 e0       	ldi	r22, 0x01	; 1
   118d4:	42 ec       	ldi	r20, 0xC2	; 194
   118d6:	5a e0       	ldi	r21, 0x0A	; 10
   118d8:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   118dc:	82 e0       	ldi	r24, 0x02	; 2
   118de:	61 e0       	ldi	r22, 0x01	; 1
   118e0:	4d ea       	ldi	r20, 0xAD	; 173
   118e2:	59 e0       	ldi	r21, 0x09	; 9
   118e4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   118e8:	83 e0       	ldi	r24, 0x03	; 3
   118ea:	61 e0       	ldi	r22, 0x01	; 1
   118ec:	4e e6       	ldi	r20, 0x6E	; 110
   118ee:	53 e1       	ldi	r21, 0x13	; 19
   118f0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   118f4:	84 e0       	ldi	r24, 0x04	; 4
   118f6:	61 e0       	ldi	r22, 0x01	; 1
   118f8:	40 e6       	ldi	r20, 0x60	; 96
   118fa:	53 e1       	ldi	r21, 0x13	; 19
   118fc:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11900:	85 e0       	ldi	r24, 0x05	; 5
   11902:	7e c0       	rjmp	.+252    	; 0x11a00 <FMenuSettingHeader+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11904:	81 30       	cpi	r24, 0x01	; 1
   11906:	09 f0       	breq	.+2      	; 0x1190a <FMenuSettingHeader+0x1c2>
   11908:	c0 c0       	rjmp	.+384    	; 0x11a8a <FMenuSettingHeader+0x342>
   1190a:	b8 c0       	rjmp	.+368    	; 0x11a7c <FMenuSettingHeader+0x334>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   1190c:	81 e0       	ldi	r24, 0x01	; 1
   1190e:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   11912:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   11916:	80 93 34 03 	sts	0x0334, r24
          if(KeyChar=='#'){
   1191a:	83 32       	cpi	r24, 0x23	; 35
   1191c:	39 f4       	brne	.+14     	; 0x1192c <FMenuSettingHeader+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   1191e:	86 ef       	ldi	r24, 0xF6	; 246
   11920:	95 e0       	ldi	r25, 0x05	; 5
   11922:	68 e2       	ldi	r22, 0x28	; 40
   11924:	70 e0       	ldi	r23, 0x00	; 0
   11926:	0e 94 8a 2c 	call	0x5914	; 0x5914 <StrAlignCenter>
   1192a:	03 c0       	rjmp	.+6      	; 0x11932 <FMenuSettingHeader+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   1192c:	8a 32       	cpi	r24, 0x2A	; 42
   1192e:	09 f0       	breq	.+2      	; 0x11932 <FMenuSettingHeader+0x1ea>
   11930:	ac c0       	rjmp	.+344    	; 0x11a8a <FMenuSettingHeader+0x342>
   11932:	86 e0       	ldi	r24, 0x06	; 6
   11934:	65 c0       	rjmp	.+202    	; 0x11a00 <FMenuSettingHeader+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11936:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   1193a:	20 e0       	ldi	r18, 0x00	; 0
   1193c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1193e:	f9 01       	movw	r30, r18
   11940:	ee 53       	subi	r30, 0x3E	; 62
   11942:	f5 4f       	sbci	r31, 0xF5	; 245
   11944:	d9 01       	movw	r26, r18
   11946:	aa 50       	subi	r26, 0x0A	; 10
   11948:	ba 4f       	sbci	r27, 0xFA	; 250
   1194a:	8c 91       	ld	r24, X
   1194c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1194e:	2f 5f       	subi	r18, 0xFF	; 255
   11950:	3f 4f       	sbci	r19, 0xFF	; 255
   11952:	24 31       	cpi	r18, 0x14	; 20
   11954:	31 05       	cpc	r19, r1
   11956:	99 f7       	brne	.-26     	; 0x1193e <FMenuSettingHeader+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11958:	10 92 d6 0a 	sts	0x0AD6, r1
   1195c:	ea e0       	ldi	r30, 0x0A	; 10
   1195e:	f6 e0       	ldi	r31, 0x06	; 6
   11960:	ad ea       	ldi	r26, 0xAD	; 173
   11962:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11964:	81 91       	ld	r24, Z+
   11966:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11968:	96 e0       	ldi	r25, 0x06	; 6
   1196a:	ee 31       	cpi	r30, 0x1E	; 30
   1196c:	f9 07       	cpc	r31, r25
   1196e:	d1 f7       	brne	.-12     	; 0x11964 <FMenuSettingHeader+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11970:	10 92 c1 09 	sts	0x09C1, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11974:	81 e0       	ldi	r24, 0x01	; 1
   11976:	61 e0       	ldi	r22, 0x01	; 1
   11978:	42 ec       	ldi	r20, 0xC2	; 194
   1197a:	5a e0       	ldi	r21, 0x0A	; 10
   1197c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11980:	82 e0       	ldi	r24, 0x02	; 2
   11982:	61 e0       	ldi	r22, 0x01	; 1
   11984:	4d ea       	ldi	r20, 0xAD	; 173
   11986:	59 e0       	ldi	r21, 0x09	; 9
   11988:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
   1198c:	00 d0       	rcall	.+0      	; 0x1198e <FMenuSettingHeader+0x246>
   1198e:	00 d0       	rcall	.+0      	; 0x11990 <FMenuSettingHeader+0x248>
   11990:	00 d0       	rcall	.+0      	; 0x11992 <FMenuSettingHeader+0x24a>
   11992:	ed b7       	in	r30, 0x3d	; 61
   11994:	fe b7       	in	r31, 0x3e	; 62
   11996:	31 96       	adiw	r30, 0x01	; 1
   11998:	8e 01       	movw	r16, r28
   1199a:	0f 5f       	subi	r16, 0xFF	; 255
   1199c:	1f 4f       	sbci	r17, 0xFF	; 255
   1199e:	ad b7       	in	r26, 0x3d	; 61
   119a0:	be b7       	in	r27, 0x3e	; 62
   119a2:	12 96       	adiw	r26, 0x02	; 2
   119a4:	1c 93       	st	X, r17
   119a6:	0e 93       	st	-X, r16
   119a8:	11 97       	sbiw	r26, 0x01	; 1
   119aa:	80 e5       	ldi	r24, 0x50	; 80
   119ac:	93 e1       	ldi	r25, 0x13	; 19
   119ae:	93 83       	std	Z+3, r25	; 0x03
   119b0:	82 83       	std	Z+2, r24	; 0x02
   119b2:	80 91 35 03 	lds	r24, 0x0335
   119b6:	90 e0       	ldi	r25, 0x00	; 0
   119b8:	01 96       	adiw	r24, 0x01	; 1
   119ba:	95 83       	std	Z+5, r25	; 0x05
   119bc:	84 83       	std	Z+4, r24	; 0x04
   119be:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   119c2:	8d b7       	in	r24, 0x3d	; 61
   119c4:	9e b7       	in	r25, 0x3e	; 62
   119c6:	06 96       	adiw	r24, 0x06	; 6
   119c8:	0f b6       	in	r0, 0x3f	; 63
   119ca:	f8 94       	cli
   119cc:	9e bf       	out	0x3e, r25	; 62
   119ce:	0f be       	out	0x3f, r0	; 63
   119d0:	8d bf       	out	0x3d, r24	; 61
   119d2:	83 e0       	ldi	r24, 0x03	; 3
   119d4:	61 e0       	ldi	r22, 0x01	; 1
   119d6:	a8 01       	movw	r20, r16
   119d8:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   119dc:	84 e0       	ldi	r24, 0x04	; 4
   119de:	61 e0       	ldi	r22, 0x01	; 1
   119e0:	43 e4       	ldi	r20, 0x43	; 67
   119e2:	53 e1       	ldi	r21, 0x13	; 19
   119e4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   119e8:	84 e0       	ldi	r24, 0x04	; 4
   119ea:	0a c0       	rjmp	.+20     	; 0x11a00 <FMenuSettingHeader+0x2b8>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
   119ec:	81 e0       	ldi	r24, 0x01	; 1
   119ee:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   119f2:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   119f6:	80 93 34 03 	sts	0x0334, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   119fa:	83 32       	cpi	r24, 0x23	; 35
   119fc:	21 f4       	brne	.+8      	; 0x11a06 <FMenuSettingHeader+0x2be>
   119fe:	87 e0       	ldi	r24, 0x07	; 7
   11a00:	80 93 36 03 	sts	0x0336, r24
   11a04:	42 c0       	rjmp	.+132    	; 0x11a8a <FMenuSettingHeader+0x342>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11a06:	8a 32       	cpi	r24, 0x2A	; 42
   11a08:	09 f0       	breq	.+2      	; 0x11a0c <FMenuSettingHeader+0x2c4>
   11a0a:	3f c0       	rjmp	.+126    	; 0x11a8a <FMenuSettingHeader+0x342>
   11a0c:	37 c0       	rjmp	.+110    	; 0x11a7c <FMenuSettingHeader+0x334>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11a0e:	ad b7       	in	r26, 0x3d	; 61
   11a10:	be b7       	in	r27, 0x3e	; 62
   11a12:	18 97       	sbiw	r26, 0x08	; 8
   11a14:	0f b6       	in	r0, 0x3f	; 63
   11a16:	f8 94       	cli
   11a18:	be bf       	out	0x3e, r27	; 62
   11a1a:	0f be       	out	0x3f, r0	; 63
   11a1c:	ad bf       	out	0x3d, r26	; 61
   11a1e:	ed b7       	in	r30, 0x3d	; 61
   11a20:	fe b7       	in	r31, 0x3e	; 62
   11a22:	31 96       	adiw	r30, 0x01	; 1
   11a24:	8e 01       	movw	r16, r28
   11a26:	0b 5e       	subi	r16, 0xEB	; 235
   11a28:	1f 4f       	sbci	r17, 0xFF	; 255
   11a2a:	12 96       	adiw	r26, 0x02	; 2
   11a2c:	1c 93       	st	X, r17
   11a2e:	0e 93       	st	-X, r16
   11a30:	11 97       	sbiw	r26, 0x01	; 1
   11a32:	8e e3       	ldi	r24, 0x3E	; 62
   11a34:	93 e1       	ldi	r25, 0x13	; 19
   11a36:	93 83       	std	Z+3, r25	; 0x03
   11a38:	82 83       	std	Z+2, r24	; 0x02
   11a3a:	82 ec       	ldi	r24, 0xC2	; 194
   11a3c:	9a e0       	ldi	r25, 0x0A	; 10
   11a3e:	95 83       	std	Z+5, r25	; 0x05
   11a40:	84 83       	std	Z+4, r24	; 0x04
   11a42:	8d ea       	ldi	r24, 0xAD	; 173
   11a44:	99 e0       	ldi	r25, 0x09	; 9
   11a46:	97 83       	std	Z+7, r25	; 0x07
   11a48:	86 83       	std	Z+6, r24	; 0x06
   11a4a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   11a4e:	8d b7       	in	r24, 0x3d	; 61
   11a50:	9e b7       	in	r25, 0x3e	; 62
   11a52:	08 96       	adiw	r24, 0x08	; 8
   11a54:	0f b6       	in	r0, 0x3f	; 63
   11a56:	f8 94       	cli
   11a58:	9e bf       	out	0x3e, r25	; 62
   11a5a:	0f be       	out	0x3f, r0	; 63
   11a5c:	8d bf       	out	0x3d, r24	; 61
   11a5e:	80 91 35 03 	lds	r24, 0x0335
   11a62:	29 e2       	ldi	r18, 0x29	; 41
   11a64:	82 9f       	mul	r24, r18
   11a66:	c0 01       	movw	r24, r0
   11a68:	11 24       	eor	r1, r1
   11a6a:	89 5a       	subi	r24, 0xA9	; 169
   11a6c:	9d 4f       	sbci	r25, 0xFD	; 253
   11a6e:	b8 01       	movw	r22, r16
   11a70:	48 e2       	ldi	r20, 0x28	; 40
   11a72:	50 e0       	ldi	r21, 0x00	; 0
   11a74:	2f e9       	ldi	r18, 0x9F	; 159
   11a76:	32 e1       	ldi	r19, 0x12	; 18
   11a78:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
   11a7c:	10 92 36 03 	sts	0x0336, r1
   11a80:	04 c0       	rjmp	.+8      	; 0x11a8a <FMenuSettingHeader+0x342>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11a82:	10 92 36 03 	sts	0x0336, r1
   11a86:	81 e0       	ldi	r24, 0x01	; 1
   11a88:	01 c0       	rjmp	.+2      	; 0x11a8c <FMenuSettingHeader+0x344>
   11a8a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
   11a8c:	ca 5b       	subi	r28, 0xBA	; 186
   11a8e:	df 4f       	sbci	r29, 0xFF	; 255
   11a90:	0f b6       	in	r0, 0x3f	; 63
   11a92:	f8 94       	cli
   11a94:	de bf       	out	0x3e, r29	; 62
   11a96:	0f be       	out	0x3f, r0	; 63
   11a98:	cd bf       	out	0x3d, r28	; 61
   11a9a:	cf 91       	pop	r28
   11a9c:	df 91       	pop	r29
   11a9e:	1f 91       	pop	r17
   11aa0:	0f 91       	pop	r16
   11aa2:	ef 90       	pop	r14
   11aa4:	08 95       	ret

00011aa6 <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
   11aa6:	80 91 37 03 	lds	r24, 0x0337
   11aaa:	83 30       	cpi	r24, 0x03	; 3
   11aac:	09 f4       	brne	.+2      	; 0x11ab0 <FMenuAdminSettings+0xa>
   11aae:	6e c0       	rjmp	.+220    	; 0x11b8c <FMenuAdminSettings+0xe6>
   11ab0:	84 30       	cpi	r24, 0x04	; 4
   11ab2:	30 f4       	brcc	.+12     	; 0x11ac0 <FMenuAdminSettings+0x1a>
   11ab4:	81 30       	cpi	r24, 0x01	; 1
   11ab6:	e9 f1       	breq	.+122    	; 0x11b32 <FMenuAdminSettings+0x8c>
   11ab8:	82 30       	cpi	r24, 0x02	; 2
   11aba:	08 f0       	brcs	.+2      	; 0x11abe <FMenuAdminSettings+0x18>
   11abc:	64 c0       	rjmp	.+200    	; 0x11b86 <FMenuAdminSettings+0xe0>
   11abe:	0d c0       	rjmp	.+26     	; 0x11ada <FMenuAdminSettings+0x34>
   11ac0:	85 30       	cpi	r24, 0x05	; 5
   11ac2:	09 f4       	brne	.+2      	; 0x11ac6 <FMenuAdminSettings+0x20>
   11ac4:	69 c0       	rjmp	.+210    	; 0x11b98 <FMenuAdminSettings+0xf2>
   11ac6:	85 30       	cpi	r24, 0x05	; 5
   11ac8:	08 f4       	brcc	.+2      	; 0x11acc <FMenuAdminSettings+0x26>
   11aca:	63 c0       	rjmp	.+198    	; 0x11b92 <FMenuAdminSettings+0xec>
   11acc:	86 30       	cpi	r24, 0x06	; 6
   11ace:	09 f4       	brne	.+2      	; 0x11ad2 <FMenuAdminSettings+0x2c>
   11ad0:	66 c0       	rjmp	.+204    	; 0x11b9e <FMenuAdminSettings+0xf8>
   11ad2:	87 30       	cpi	r24, 0x07	; 7
   11ad4:	09 f0       	breq	.+2      	; 0x11ad8 <FMenuAdminSettings+0x32>
   11ad6:	6f c0       	rjmp	.+222    	; 0x11bb6 <FMenuAdminSettings+0x110>
   11ad8:	6a c0       	rjmp	.+212    	; 0x11bae <FMenuAdminSettings+0x108>
	 case asInitMenu:
          lcd_clear();
   11ada:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  if (IFType==IT_SLAVE){
   11ade:	80 91 25 01 	lds	r24, 0x0125
   11ae2:	81 30       	cpi	r24, 0x01	; 1
   11ae4:	51 f4       	brne	.+20     	; 0x11afa <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
   11ae6:	61 e0       	ldi	r22, 0x01	; 1
   11ae8:	49 e4       	ldi	r20, 0x49	; 73
   11aea:	54 e1       	ldi	r21, 0x14	; 20
   11aec:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
   11af0:	82 e0       	ldi	r24, 0x02	; 2
   11af2:	61 e0       	ldi	r22, 0x01	; 1
   11af4:	44 e3       	ldi	r20, 0x34	; 52
   11af6:	54 e1       	ldi	r21, 0x14	; 20
   11af8:	0c c0       	rjmp	.+24     	; 0x11b12 <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
   11afa:	82 30       	cpi	r24, 0x02	; 2
   11afc:	61 f4       	brne	.+24     	; 0x11b16 <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
   11afe:	81 e0       	ldi	r24, 0x01	; 1
   11b00:	61 e0       	ldi	r22, 0x01	; 1
   11b02:	4f e1       	ldi	r20, 0x1F	; 31
   11b04:	54 e1       	ldi	r21, 0x14	; 20
   11b06:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
   11b0a:	82 e0       	ldi	r24, 0x02	; 2
   11b0c:	61 e0       	ldi	r22, 0x01	; 1
   11b0e:	4a e0       	ldi	r20, 0x0A	; 10
   11b10:	54 e1       	ldi	r21, 0x14	; 20
   11b12:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
   11b16:	83 e0       	ldi	r24, 0x03	; 3
   11b18:	61 e0       	ldi	r22, 0x01	; 1
   11b1a:	45 ef       	ldi	r20, 0xF5	; 245
   11b1c:	53 e1       	ldi	r21, 0x13	; 19
   11b1e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
   11b22:	84 e0       	ldi	r24, 0x04	; 4
   11b24:	61 e0       	ldi	r22, 0x01	; 1
   11b26:	4e ee       	ldi	r20, 0xEE	; 238
   11b28:	53 e1       	ldi	r21, 0x13	; 19
   11b2a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
   11b2e:	81 e0       	ldi	r24, 0x01	; 1
   11b30:	27 c0       	rjmp	.+78     	; 0x11b80 <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
   11b32:	81 e0       	ldi	r24, 0x01	; 1
   11b34:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   11b38:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   11b3c:	98 2f       	mov	r25, r24
		  switch(KeyChar){
   11b3e:	82 33       	cpi	r24, 0x32	; 50
   11b40:	61 f0       	breq	.+24     	; 0x11b5a <FMenuAdminSettings+0xb4>
   11b42:	83 33       	cpi	r24, 0x33	; 51
   11b44:	28 f4       	brcc	.+10     	; 0x11b50 <FMenuAdminSettings+0xaa>
   11b46:	8a 32       	cpi	r24, 0x2A	; 42
   11b48:	61 f0       	breq	.+24     	; 0x11b62 <FMenuAdminSettings+0xbc>
   11b4a:	81 33       	cpi	r24, 0x31	; 49
   11b4c:	69 f4       	brne	.+26     	; 0x11b68 <FMenuAdminSettings+0xc2>
   11b4e:	03 c0       	rjmp	.+6      	; 0x11b56 <FMenuAdminSettings+0xb0>
   11b50:	83 33       	cpi	r24, 0x33	; 51
   11b52:	51 f4       	brne	.+20     	; 0x11b68 <FMenuAdminSettings+0xc2>
   11b54:	04 c0       	rjmp	.+8      	; 0x11b5e <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
   11b56:	82 e0       	ldi	r24, 0x02	; 2
   11b58:	05 c0       	rjmp	.+10     	; 0x11b64 <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
   11b5a:	83 e0       	ldi	r24, 0x03	; 3
   11b5c:	03 c0       	rjmp	.+6      	; 0x11b64 <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
   11b5e:	84 e0       	ldi	r24, 0x04	; 4
   11b60:	01 c0       	rjmp	.+2      	; 0x11b64 <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
   11b62:	87 e0       	ldi	r24, 0x07	; 7
   11b64:	80 93 37 03 	sts	0x0337, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
   11b68:	80 91 25 01 	lds	r24, 0x0125
   11b6c:	81 30       	cpi	r24, 0x01	; 1
   11b6e:	19 f5       	brne	.+70     	; 0x11bb6 <FMenuAdminSettings+0x110>
			  switch(KeyChar){
   11b70:	94 33       	cpi	r25, 0x34	; 52
   11b72:	19 f0       	breq	.+6      	; 0x11b7a <FMenuAdminSettings+0xd4>
   11b74:	95 33       	cpi	r25, 0x35	; 53
   11b76:	f9 f4       	brne	.+62     	; 0x11bb6 <FMenuAdminSettings+0x110>
   11b78:	02 c0       	rjmp	.+4      	; 0x11b7e <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
   11b7a:	85 e0       	ldi	r24, 0x05	; 5
   11b7c:	01 c0       	rjmp	.+2      	; 0x11b80 <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
   11b7e:	86 e0       	ldi	r24, 0x06	; 6
   11b80:	80 93 37 03 	sts	0x0337, r24
   11b84:	12 c0       	rjmp	.+36     	; 0x11baa <FMenuAdminSettings+0x104>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
   11b86:	0e 94 a4 8b 	call	0x11748	; 0x11748 <FMenuSettingHeader>
   11b8a:	0b c0       	rjmp	.+22     	; 0x11ba2 <FMenuAdminSettings+0xfc>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
   11b8c:	0e 94 f7 89 	call	0x113ee	; 0x113ee <FMenuSettingFooter>
   11b90:	08 c0       	rjmp	.+16     	; 0x11ba2 <FMenuAdminSettings+0xfc>
	 }
   return Result;
}
char FMenuSettingPassword(){
     char Result;
   _menu_password();
   11b92:	0e 94 77 73 	call	0xe6ee	; 0xe6ee <_menu_password>
   11b96:	07 c0       	rjmp	.+14     	; 0x11ba6 <FMenuAdminSettings+0x100>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
   11b98:	0e 94 ac 6c 	call	0xd958	; 0xd958 <FMenuSettingClientIP>
   11b9c:	02 c0       	rjmp	.+4      	; 0x11ba2 <FMenuAdminSettings+0xfc>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
   11b9e:	0e 94 22 6a 	call	0xd444	; 0xd444 <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
   11ba2:	81 30       	cpi	r24, 0x01	; 1
   11ba4:	41 f4       	brne	.+16     	; 0x11bb6 <FMenuAdminSettings+0x110>
   11ba6:	10 92 37 03 	sts	0x0337, r1
   11baa:	80 e0       	ldi	r24, 0x00	; 0
   11bac:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
   11bae:	10 92 37 03 	sts	0x0337, r1
   11bb2:	81 e0       	ldi	r24, 0x01	; 1
   11bb4:	08 95       	ret
   11bb6:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   11bb8:	08 95       	ret

00011bba <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
   11bba:	ef 92       	push	r14
   11bbc:	ff 92       	push	r15
   11bbe:	0f 93       	push	r16
   11bc0:	1f 93       	push	r17
   11bc2:	df 93       	push	r29
   11bc4:	cf 93       	push	r28
   11bc6:	cd b7       	in	r28, 0x3d	; 61
   11bc8:	de b7       	in	r29, 0x3e	; 62
   11bca:	e2 97       	sbiw	r28, 0x32	; 50
   11bcc:	0f b6       	in	r0, 0x3f	; 63
   11bce:	f8 94       	cli
   11bd0:	de bf       	out	0x3e, r29	; 62
   11bd2:	0f be       	out	0x3f, r0	; 63
   11bd4:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
   11bd6:	80 91 3c 03 	lds	r24, 0x033C
   11bda:	e8 2f       	mov	r30, r24
   11bdc:	f0 e0       	ldi	r31, 0x00	; 0
   11bde:	e1 31       	cpi	r30, 0x11	; 17
   11be0:	f1 05       	cpc	r31, r1
   11be2:	08 f0       	brcs	.+2      	; 0x11be6 <FMenuMaster+0x2c>
   11be4:	f3 c1       	rjmp	.+998    	; 0x11fcc <FMenuMaster+0x412>
   11be6:	ed 54       	subi	r30, 0x4D	; 77
   11be8:	ff 4f       	sbci	r31, 0xFF	; 255
   11bea:	ee 0f       	add	r30, r30
   11bec:	ff 1f       	adc	r31, r31
   11bee:	05 90       	lpm	r0, Z+
   11bf0:	f4 91       	lpm	r31, Z+
   11bf2:	e0 2d       	mov	r30, r0
   11bf4:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
   11bf6:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
   11bfa:	81 e0       	ldi	r24, 0x01	; 1
   11bfc:	61 e0       	ldi	r22, 0x01	; 1
   11bfe:	4f eb       	ldi	r20, 0xBF	; 191
   11c00:	56 e1       	ldi	r21, 0x16	; 22
   11c02:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
   11c06:	82 e0       	ldi	r24, 0x02	; 2
   11c08:	61 e0       	ldi	r22, 0x01	; 1
   11c0a:	4a ea       	ldi	r20, 0xAA	; 170
   11c0c:	56 e1       	ldi	r21, 0x16	; 22
   11c0e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
   11c12:	83 e0       	ldi	r24, 0x03	; 3
   11c14:	61 e0       	ldi	r22, 0x01	; 1
   11c16:	45 e9       	ldi	r20, 0x95	; 149
   11c18:	56 e1       	ldi	r21, 0x16	; 22
   11c1a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
   11c1e:	84 e0       	ldi	r24, 0x04	; 4
   11c20:	61 e0       	ldi	r22, 0x01	; 1
   11c22:	40 e8       	ldi	r20, 0x80	; 128
   11c24:	56 e1       	ldi	r21, 0x16	; 22
   11c26:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>

		  //_uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
   11c2a:	81 e0       	ldi	r24, 0x01	; 1
   11c2c:	f6 c0       	rjmp	.+492    	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
   11c2e:	81 e0       	ldi	r24, 0x01	; 1
   11c30:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11c34:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
          switch(KeyChar){
   11c38:	81 33       	cpi	r24, 0x31	; 49
   11c3a:	09 f4       	brne	.+2      	; 0x11c3e <FMenuMaster+0x84>
   11c3c:	ed c0       	rjmp	.+474    	; 0x11e18 <FMenuMaster+0x25e>
   11c3e:	82 33       	cpi	r24, 0x32	; 50
   11c40:	21 f0       	breq	.+8      	; 0x11c4a <FMenuMaster+0x90>
   11c42:	8a 32       	cpi	r24, 0x2A	; 42
   11c44:	09 f0       	breq	.+2      	; 0x11c48 <FMenuMaster+0x8e>
   11c46:	c2 c1       	rjmp	.+900    	; 0x11fcc <FMenuMaster+0x412>
   11c48:	bb c1       	rjmp	.+886    	; 0x11fc0 <FMenuMaster+0x406>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
   11c4a:	8e e0       	ldi	r24, 0x0E	; 14
   11c4c:	e6 c0       	rjmp	.+460    	; 0x11e1a <FMenuMaster+0x260>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
   11c4e:	10 92 3c 03 	sts	0x033C, r1
   11c52:	bc c1       	rjmp	.+888    	; 0x11fcc <FMenuMaster+0x412>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
   11c54:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
   11c58:	81 e0       	ldi	r24, 0x01	; 1
   11c5a:	61 e0       	ldi	r22, 0x01	; 1
   11c5c:	4b e6       	ldi	r20, 0x6B	; 107
   11c5e:	56 e1       	ldi	r21, 0x16	; 22
   11c60:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
   11c64:	82 e0       	ldi	r24, 0x02	; 2
   11c66:	61 e0       	ldi	r22, 0x01	; 1
   11c68:	46 e5       	ldi	r20, 0x56	; 86
   11c6a:	56 e1       	ldi	r21, 0x16	; 22
   11c6c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
   11c70:	84 e0       	ldi	r24, 0x04	; 4
   11c72:	64 e0       	ldi	r22, 0x04	; 4
   11c74:	41 e4       	ldi	r20, 0x41	; 65
   11c76:	56 e1       	ldi	r21, 0x16	; 22
   11c78:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
   11c7c:	00 d0       	rcall	.+0      	; 0x11c7e <FMenuMaster+0xc4>
   11c7e:	00 d0       	rcall	.+0      	; 0x11c80 <FMenuMaster+0xc6>
   11c80:	8c e9       	ldi	r24, 0x9C	; 156
   11c82:	97 e0       	ldi	r25, 0x07	; 7
   11c84:	ad b7       	in	r26, 0x3d	; 61
   11c86:	be b7       	in	r27, 0x3e	; 62
   11c88:	12 96       	adiw	r26, 0x02	; 2
   11c8a:	9c 93       	st	X, r25
   11c8c:	8e 93       	st	-X, r24
   11c8e:	11 97       	sbiw	r26, 0x01	; 1
   11c90:	80 e4       	ldi	r24, 0x40	; 64
   11c92:	96 e1       	ldi	r25, 0x16	; 22
   11c94:	14 96       	adiw	r26, 0x04	; 4
   11c96:	9c 93       	st	X, r25
   11c98:	8e 93       	st	-X, r24
   11c9a:	13 97       	sbiw	r26, 0x03	; 3
   11c9c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
   11ca0:	83 e0       	ldi	r24, 0x03	; 3
   11ca2:	80 93 3c 03 	sts	0x033C, r24
   11ca6:	80 e0       	ldi	r24, 0x00	; 0
   11ca8:	0f 90       	pop	r0
   11caa:	0f 90       	pop	r0
   11cac:	0f 90       	pop	r0
   11cae:	0f 90       	pop	r0
   11cb0:	8e c1       	rjmp	.+796    	; 0x11fce <FMenuMaster+0x414>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
   11cb2:	81 e0       	ldi	r24, 0x01	; 1
   11cb4:	62 e0       	ldi	r22, 0x02	; 2
   11cb6:	41 e0       	ldi	r20, 0x01	; 1
   11cb8:	2c e9       	ldi	r18, 0x9C	; 156
   11cba:	37 e0       	ldi	r19, 0x07	; 7
   11cbc:	00 e0       	ldi	r16, 0x00	; 0
   11cbe:	10 e0       	ldi	r17, 0x00	; 0
   11cc0:	aa e0       	ldi	r26, 0x0A	; 10
   11cc2:	ea 2e       	mov	r14, r26
   11cc4:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
		  switch(uiResult){
   11cc8:	83 30       	cpi	r24, 0x03	; 3
   11cca:	49 f0       	breq	.+18     	; 0x11cde <FMenuMaster+0x124>
   11ccc:	84 30       	cpi	r24, 0x04	; 4
   11cce:	08 f4       	brcc	.+2      	; 0x11cd2 <FMenuMaster+0x118>
   11cd0:	f2 c0       	rjmp	.+484    	; 0x11eb6 <FMenuMaster+0x2fc>
   11cd2:	84 30       	cpi	r24, 0x04	; 4
   11cd4:	69 f0       	breq	.+26     	; 0x11cf0 <FMenuMaster+0x136>
   11cd6:	85 30       	cpi	r24, 0x05	; 5
   11cd8:	09 f0       	breq	.+2      	; 0x11cdc <FMenuMaster+0x122>
   11cda:	78 c1       	rjmp	.+752    	; 0x11fcc <FMenuMaster+0x412>
   11cdc:	0e c0       	rjmp	.+28     	; 0x11cfa <FMenuMaster+0x140>
		  case USER_OK:
               
			   //_uart_printf(1,0,PSTR("GeniusCode: "));
			   //_uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
   11cde:	80 e0       	ldi	r24, 0x00	; 0
   11ce0:	6f eb       	ldi	r22, 0xBF	; 191
   11ce2:	75 e0       	ldi	r23, 0x05	; 5
   11ce4:	44 ea       	ldi	r20, 0xA4	; 164
   11ce6:	5a e0       	ldi	r21, 0x0A	; 10
   11ce8:	0e 94 2b b3 	call	0x16656	; 0x16656 <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
   11cec:	84 e0       	ldi	r24, 0x04	; 4
   11cee:	95 c0       	rjmp	.+298    	; 0x11e1a <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11cf0:	84 e0       	ldi	r24, 0x04	; 4
   11cf2:	61 e0       	ldi	r22, 0x01	; 1
   11cf4:	4b e2       	ldi	r20, 0x2B	; 43
   11cf6:	56 e1       	ldi	r21, 0x16	; 22
   11cf8:	f3 c0       	rjmp	.+486    	; 0x11ee0 <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11cfa:	84 e0       	ldi	r24, 0x04	; 4
   11cfc:	61 e0       	ldi	r22, 0x01	; 1
   11cfe:	46 e1       	ldi	r20, 0x16	; 22
   11d00:	56 e1       	ldi	r21, 0x16	; 22
   11d02:	ee c0       	rjmp	.+476    	; 0x11ee0 <FMenuMaster+0x326>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
   11d04:	00 d0       	rcall	.+0      	; 0x11d06 <FMenuMaster+0x14c>
   11d06:	00 d0       	rcall	.+0      	; 0x11d08 <FMenuMaster+0x14e>
   11d08:	00 d0       	rcall	.+0      	; 0x11d0a <FMenuMaster+0x150>
   11d0a:	ed b7       	in	r30, 0x3d	; 61
   11d0c:	fe b7       	in	r31, 0x3e	; 62
   11d0e:	31 96       	adiw	r30, 0x01	; 1
   11d10:	8e 01       	movw	r16, r28
   11d12:	05 5f       	subi	r16, 0xF5	; 245
   11d14:	1f 4f       	sbci	r17, 0xFF	; 255
   11d16:	ad b7       	in	r26, 0x3d	; 61
   11d18:	be b7       	in	r27, 0x3e	; 62
   11d1a:	12 96       	adiw	r26, 0x02	; 2
   11d1c:	1c 93       	st	X, r17
   11d1e:	0e 93       	st	-X, r16
   11d20:	11 97       	sbiw	r26, 0x01	; 1
   11d22:	83 e1       	ldi	r24, 0x13	; 19
   11d24:	96 e1       	ldi	r25, 0x16	; 22
   11d26:	93 83       	std	Z+3, r25	; 0x03
   11d28:	82 83       	std	Z+2, r24	; 0x02
   11d2a:	8f eb       	ldi	r24, 0xBF	; 191
   11d2c:	95 e0       	ldi	r25, 0x05	; 5
   11d2e:	95 83       	std	Z+5, r25	; 0x05
   11d30:	84 83       	std	Z+4, r24	; 0x04
   11d32:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  RemoveChar(PDate,'/');
   11d36:	ed b7       	in	r30, 0x3d	; 61
   11d38:	fe b7       	in	r31, 0x3e	; 62
   11d3a:	36 96       	adiw	r30, 0x06	; 6
   11d3c:	0f b6       	in	r0, 0x3f	; 63
   11d3e:	f8 94       	cli
   11d40:	fe bf       	out	0x3e, r31	; 62
   11d42:	0f be       	out	0x3f, r0	; 63
   11d44:	ed bf       	out	0x3d, r30	; 61
   11d46:	c8 01       	movw	r24, r16
   11d48:	6f e2       	ldi	r22, 0x2F	; 47
   11d4a:	0e 94 62 2d 	call	0x5ac4	; 0x5ac4 <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
   11d4e:	c8 01       	movw	r24, r16
   11d50:	6c e9       	ldi	r22, 0x9C	; 156
   11d52:	77 e0       	ldi	r23, 0x07	; 7
   11d54:	0e 94 40 73 	call	0xe680	; 0xe680 <ValidateGeniusCode>
   11d58:	81 30       	cpi	r24, 0x01	; 1
   11d5a:	09 f0       	breq	.+2      	; 0x11d5e <FMenuMaster+0x1a4>
   11d5c:	44 c0       	rjmp	.+136    	; 0x11de6 <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
   11d5e:	00 d0       	rcall	.+0      	; 0x11d60 <FMenuMaster+0x1a6>
   11d60:	00 d0       	rcall	.+0      	; 0x11d62 <FMenuMaster+0x1a8>
   11d62:	00 d0       	rcall	.+0      	; 0x11d64 <FMenuMaster+0x1aa>
   11d64:	ed b7       	in	r30, 0x3d	; 61
   11d66:	fe b7       	in	r31, 0x3e	; 62
   11d68:	31 96       	adiw	r30, 0x01	; 1
   11d6a:	8e 01       	movw	r16, r28
   11d6c:	0f 5f       	subi	r16, 0xFF	; 255
   11d6e:	1f 4f       	sbci	r17, 0xFF	; 255
   11d70:	ad b7       	in	r26, 0x3d	; 61
   11d72:	be b7       	in	r27, 0x3e	; 62
   11d74:	12 96       	adiw	r26, 0x02	; 2
   11d76:	1c 93       	st	X, r17
   11d78:	0e 93       	st	-X, r16
   11d7a:	11 97       	sbiw	r26, 0x01	; 1
   11d7c:	80 e1       	ldi	r24, 0x10	; 16
   11d7e:	96 e1       	ldi	r25, 0x16	; 22
   11d80:	93 83       	std	Z+3, r25	; 0x03
   11d82:	82 83       	std	Z+2, r24	; 0x02
   11d84:	84 ea       	ldi	r24, 0xA4	; 164
   11d86:	9a e0       	ldi	r25, 0x0A	; 10
   11d88:	95 83       	std	Z+5, r25	; 0x05
   11d8a:	84 83       	std	Z+4, r24	; 0x04
   11d8c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
   11d90:	ed b7       	in	r30, 0x3d	; 61
   11d92:	fe b7       	in	r31, 0x3e	; 62
   11d94:	36 96       	adiw	r30, 0x06	; 6
   11d96:	0f b6       	in	r0, 0x3f	; 63
   11d98:	f8 94       	cli
   11d9a:	fe bf       	out	0x3e, r31	; 62
   11d9c:	0f be       	out	0x3f, r0	; 63
   11d9e:	ed bf       	out	0x3d, r30	; 61
   11da0:	c8 01       	movw	r24, r16
   11da2:	6a e3       	ldi	r22, 0x3A	; 58
   11da4:	0e 94 62 2d 	call	0x5ac4	; 0x5ac4 <RemoveChar>
   11da8:	00 d0       	rcall	.+0      	; 0x11daa <FMenuMaster+0x1f0>
   11daa:	00 d0       	rcall	.+0      	; 0x11dac <FMenuMaster+0x1f2>
   11dac:	fa ed       	ldi	r31, 0xDA	; 218
   11dae:	ef 2e       	mov	r14, r31
   11db0:	f9 e0       	ldi	r31, 0x09	; 9
   11db2:	ff 2e       	mov	r15, r31
   11db4:	ad b7       	in	r26, 0x3d	; 61
   11db6:	be b7       	in	r27, 0x3e	; 62
   11db8:	12 96       	adiw	r26, 0x02	; 2
   11dba:	fc 92       	st	X, r15
   11dbc:	ee 92       	st	-X, r14
   11dbe:	11 97       	sbiw	r26, 0x01	; 1
   11dc0:	8f e0       	ldi	r24, 0x0F	; 15
   11dc2:	96 e1       	ldi	r25, 0x16	; 22
   11dc4:	14 96       	adiw	r26, 0x04	; 4
   11dc6:	9c 93       	st	X, r25
   11dc8:	8e 93       	st	-X, r24
   11dca:	13 97       	sbiw	r26, 0x03	; 3
   11dcc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // _uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
   11dd0:	0f 90       	pop	r0
   11dd2:	0f 90       	pop	r0
   11dd4:	0f 90       	pop	r0
   11dd6:	0f 90       	pop	r0
   11dd8:	c8 01       	movw	r24, r16
   11dda:	6c e9       	ldi	r22, 0x9C	; 156
   11ddc:	77 e0       	ldi	r23, 0x07	; 7
   11dde:	a7 01       	movw	r20, r14
   11de0:	0e 94 23 2e 	call	0x5c46	; 0x5c46 <GenerateKeyStamp>
   11de4:	d5 c0       	rjmp	.+426    	; 0x11f90 <FMenuMaster+0x3d6>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
   11de6:	85 e0       	ldi	r24, 0x05	; 5
   11de8:	18 c0       	rjmp	.+48     	; 0x11e1a <FMenuMaster+0x260>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11dea:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11dec:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11dee:	81 e0       	ldi	r24, 0x01	; 1
   11df0:	90 e0       	ldi	r25, 0x00	; 0
   11df2:	90 93 ed 01 	sts	0x01ED, r25
   11df6:	80 93 ec 01 	sts	0x01EC, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
   11dfa:	83 e0       	ldi	r24, 0x03	; 3
   11dfc:	61 e0       	ldi	r22, 0x01	; 1
   11dfe:	4a ef       	ldi	r20, 0xFA	; 250
   11e00:	55 e1       	ldi	r21, 0x15	; 21
   11e02:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          TimDisplay=0; 
   11e06:	10 92 bc 01 	sts	0x01BC, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
   11e0a:	86 e0       	ldi	r24, 0x06	; 6
   11e0c:	06 c0       	rjmp	.+12     	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
   11e0e:	80 91 bc 01 	lds	r24, 0x01BC
   11e12:	86 30       	cpi	r24, 0x06	; 6
   11e14:	08 f4       	brcc	.+2      	; 0x11e18 <FMenuMaster+0x25e>
   11e16:	da c0       	rjmp	.+436    	; 0x11fcc <FMenuMaster+0x412>
   11e18:	82 e0       	ldi	r24, 0x02	; 2
   11e1a:	80 93 3c 03 	sts	0x033C, r24
   11e1e:	d6 c0       	rjmp	.+428    	; 0x11fcc <FMenuMaster+0x412>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
   11e20:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
   11e24:	00 d0       	rcall	.+0      	; 0x11e26 <FMenuMaster+0x26c>
   11e26:	00 d0       	rcall	.+0      	; 0x11e28 <FMenuMaster+0x26e>
   11e28:	00 d0       	rcall	.+0      	; 0x11e2a <FMenuMaster+0x270>
   11e2a:	ed b7       	in	r30, 0x3d	; 61
   11e2c:	fe b7       	in	r31, 0x3e	; 62
   11e2e:	31 96       	adiw	r30, 0x01	; 1
   11e30:	8e 01       	movw	r16, r28
   11e32:	01 5e       	subi	r16, 0xE1	; 225
   11e34:	1f 4f       	sbci	r17, 0xFF	; 255
   11e36:	ad b7       	in	r26, 0x3d	; 61
   11e38:	be b7       	in	r27, 0x3e	; 62
   11e3a:	12 96       	adiw	r26, 0x02	; 2
   11e3c:	1c 93       	st	X, r17
   11e3e:	0e 93       	st	-X, r16
   11e40:	11 97       	sbiw	r26, 0x01	; 1
   11e42:	8c ee       	ldi	r24, 0xEC	; 236
   11e44:	95 e1       	ldi	r25, 0x15	; 21
   11e46:	93 83       	std	Z+3, r25	; 0x03
   11e48:	82 83       	std	Z+2, r24	; 0x02
   11e4a:	8a ed       	ldi	r24, 0xDA	; 218
   11e4c:	99 e0       	ldi	r25, 0x09	; 9
   11e4e:	95 83       	std	Z+5, r25	; 0x05
   11e50:	84 83       	std	Z+4, r24	; 0x04
   11e52:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   11e56:	ed b7       	in	r30, 0x3d	; 61
   11e58:	fe b7       	in	r31, 0x3e	; 62
   11e5a:	36 96       	adiw	r30, 0x06	; 6
   11e5c:	0f b6       	in	r0, 0x3f	; 63
   11e5e:	f8 94       	cli
   11e60:	fe bf       	out	0x3e, r31	; 62
   11e62:	0f be       	out	0x3f, r0	; 63
   11e64:	ed bf       	out	0x3d, r30	; 61
   11e66:	81 e0       	ldi	r24, 0x01	; 1
   11e68:	61 e0       	ldi	r22, 0x01	; 1
   11e6a:	a8 01       	movw	r20, r16
   11e6c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
   11e70:	82 e0       	ldi	r24, 0x02	; 2
   11e72:	61 e0       	ldi	r22, 0x01	; 1
   11e74:	47 ed       	ldi	r20, 0xD7	; 215
   11e76:	55 e1       	ldi	r21, 0x15	; 21
   11e78:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
   11e7c:	83 e0       	ldi	r24, 0x03	; 3
   11e7e:	61 e0       	ldi	r22, 0x01	; 1
   11e80:	42 ec       	ldi	r20, 0xC2	; 194
   11e82:	55 e1       	ldi	r21, 0x15	; 21
   11e84:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11e88:	84 e0       	ldi	r24, 0x04	; 4
   11e8a:	61 e0       	ldi	r22, 0x01	; 1
   11e8c:	4d ea       	ldi	r20, 0xAD	; 173
   11e8e:	55 e1       	ldi	r21, 0x15	; 21
   11e90:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
   11e94:	88 e0       	ldi	r24, 0x08	; 8
   11e96:	c1 cf       	rjmp	.-126    	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
   11e98:	81 e0       	ldi	r24, 0x01	; 1
   11e9a:	63 e0       	ldi	r22, 0x03	; 3
   11e9c:	41 e0       	ldi	r20, 0x01	; 1
   11e9e:	21 e6       	ldi	r18, 0x61	; 97
   11ea0:	3e e0       	ldi	r19, 0x0E	; 14
   11ea2:	00 e0       	ldi	r16, 0x00	; 0
   11ea4:	10 e0       	ldi	r17, 0x00	; 0
   11ea6:	ea e0       	ldi	r30, 0x0A	; 10
   11ea8:	ee 2e       	mov	r14, r30
   11eaa:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
		  switch(uiResult){
   11eae:	83 30       	cpi	r24, 0x03	; 3
   11eb0:	61 f0       	breq	.+24     	; 0x11eca <FMenuMaster+0x310>
   11eb2:	84 30       	cpi	r24, 0x04	; 4
   11eb4:	20 f4       	brcc	.+8      	; 0x11ebe <FMenuMaster+0x304>
   11eb6:	81 30       	cpi	r24, 0x01	; 1
   11eb8:	09 f0       	breq	.+2      	; 0x11ebc <FMenuMaster+0x302>
   11eba:	88 c0       	rjmp	.+272    	; 0x11fcc <FMenuMaster+0x412>
   11ebc:	81 c0       	rjmp	.+258    	; 0x11fc0 <FMenuMaster+0x406>
   11ebe:	84 30       	cpi	r24, 0x04	; 4
   11ec0:	31 f0       	breq	.+12     	; 0x11ece <FMenuMaster+0x314>
   11ec2:	85 30       	cpi	r24, 0x05	; 5
   11ec4:	09 f0       	breq	.+2      	; 0x11ec8 <FMenuMaster+0x30e>
   11ec6:	82 c0       	rjmp	.+260    	; 0x11fcc <FMenuMaster+0x412>
   11ec8:	07 c0       	rjmp	.+14     	; 0x11ed8 <FMenuMaster+0x31e>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
   11eca:	89 e0       	ldi	r24, 0x09	; 9
   11ecc:	a6 cf       	rjmp	.-180    	; 0x11e1a <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11ece:	84 e0       	ldi	r24, 0x04	; 4
   11ed0:	61 e0       	ldi	r22, 0x01	; 1
   11ed2:	48 e9       	ldi	r20, 0x98	; 152
   11ed4:	55 e1       	ldi	r21, 0x15	; 21
   11ed6:	04 c0       	rjmp	.+8      	; 0x11ee0 <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11ed8:	84 e0       	ldi	r24, 0x04	; 4
   11eda:	61 e0       	ldi	r22, 0x01	; 1
   11edc:	43 e8       	ldi	r20, 0x83	; 131
   11ede:	55 e1       	ldi	r21, 0x15	; 21
   11ee0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   11ee4:	73 c0       	rjmp	.+230    	; 0x11fcc <FMenuMaster+0x412>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
   11ee6:	8a ed       	ldi	r24, 0xDA	; 218
   11ee8:	99 e0       	ldi	r25, 0x09	; 9
   11eea:	61 e6       	ldi	r22, 0x61	; 97
   11eec:	7e e0       	ldi	r23, 0x0E	; 14
   11eee:	0e 94 1e 73 	call	0xe63c	; 0xe63c <ValidateRestoreCode>
   11ef2:	81 30       	cpi	r24, 0x01	; 1
   11ef4:	11 f4       	brne	.+4      	; 0x11efa <FMenuMaster+0x340>
		      stMenuMaster=mmRestorePassword;
   11ef6:	8c e0       	ldi	r24, 0x0C	; 12
   11ef8:	90 cf       	rjmp	.-224    	; 0x11e1a <FMenuMaster+0x260>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
   11efa:	8a e0       	ldi	r24, 0x0A	; 10
   11efc:	8e cf       	rjmp	.-228    	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
   11efe:	00 d0       	rcall	.+0      	; 0x11f00 <FMenuMaster+0x346>
   11f00:	00 d0       	rcall	.+0      	; 0x11f02 <FMenuMaster+0x348>
   11f02:	8e 01       	movw	r16, r28
   11f04:	0b 5e       	subi	r16, 0xEB	; 235
   11f06:	1f 4f       	sbci	r17, 0xFF	; 255
   11f08:	ad b7       	in	r26, 0x3d	; 61
   11f0a:	be b7       	in	r27, 0x3e	; 62
   11f0c:	12 96       	adiw	r26, 0x02	; 2
   11f0e:	1c 93       	st	X, r17
   11f10:	0e 93       	st	-X, r16
   11f12:	11 97       	sbiw	r26, 0x01	; 1
   11f14:	8d e7       	ldi	r24, 0x7D	; 125
   11f16:	95 e1       	ldi	r25, 0x15	; 21
   11f18:	14 96       	adiw	r26, 0x04	; 4
   11f1a:	9c 93       	st	X, r25
   11f1c:	8e 93       	st	-X, r24
   11f1e:	13 97       	sbiw	r26, 0x03	; 3
   11f20:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   11f24:	0f 90       	pop	r0
   11f26:	0f 90       	pop	r0
   11f28:	0f 90       	pop	r0
   11f2a:	0f 90       	pop	r0
   11f2c:	81 e0       	ldi	r24, 0x01	; 1
   11f2e:	90 e0       	ldi	r25, 0x00	; 0
   11f30:	b8 01       	movw	r22, r16
   11f32:	4a e0       	ldi	r20, 0x0A	; 10
   11f34:	50 e0       	ldi	r21, 0x00	; 0
   11f36:	2f e9       	ldi	r18, 0x9F	; 159
   11f38:	32 e1       	ldi	r19, 0x12	; 18
   11f3a:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
   11f3e:	00 d0       	rcall	.+0      	; 0x11f40 <FMenuMaster+0x386>
   11f40:	00 d0       	rcall	.+0      	; 0x11f42 <FMenuMaster+0x388>
   11f42:	ed b7       	in	r30, 0x3d	; 61
   11f44:	fe b7       	in	r31, 0x3e	; 62
   11f46:	12 83       	std	Z+2, r17	; 0x02
   11f48:	01 83       	std	Z+1, r16	; 0x01
   11f4a:	87 e7       	ldi	r24, 0x77	; 119
   11f4c:	95 e1       	ldi	r25, 0x15	; 21
   11f4e:	94 83       	std	Z+4, r25	; 0x04
   11f50:	83 83       	std	Z+3, r24	; 0x03
   11f52:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   11f56:	0f 90       	pop	r0
   11f58:	0f 90       	pop	r0
   11f5a:	0f 90       	pop	r0
   11f5c:	0f 90       	pop	r0
   11f5e:	8b e0       	ldi	r24, 0x0B	; 11
   11f60:	90 e0       	ldi	r25, 0x00	; 0
   11f62:	b8 01       	movw	r22, r16
   11f64:	4a e0       	ldi	r20, 0x0A	; 10
   11f66:	50 e0       	ldi	r21, 0x00	; 0
   11f68:	2f e9       	ldi	r18, 0x9F	; 159
   11f6a:	32 e1       	ldi	r19, 0x12	; 18
   11f6c:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
   11f70:	8d e0       	ldi	r24, 0x0D	; 13
   11f72:	53 cf       	rjmp	.-346    	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
   11f74:	83 e0       	ldi	r24, 0x03	; 3
   11f76:	61 e0       	ldi	r22, 0x01	; 1
   11f78:	45 e6       	ldi	r20, 0x65	; 101
   11f7a:	55 e1       	ldi	r21, 0x15	; 21
   11f7c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  TimDisplay=0;
   11f80:	10 92 bc 01 	sts	0x01BC, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
   11f84:	8b e0       	ldi	r24, 0x0B	; 11
   11f86:	49 cf       	rjmp	.-366    	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
   11f88:	80 91 bc 01 	lds	r24, 0x01BC
   11f8c:	86 30       	cpi	r24, 0x06	; 6
   11f8e:	f0 f0       	brcs	.+60     	; 0x11fcc <FMenuMaster+0x412>
   11f90:	87 e0       	ldi	r24, 0x07	; 7
   11f92:	43 cf       	rjmp	.-378    	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
   11f94:	83 e0       	ldi	r24, 0x03	; 3
   11f96:	61 e0       	ldi	r22, 0x01	; 1
   11f98:	43 e5       	ldi	r20, 0x53	; 83
   11f9a:	55 e1       	ldi	r21, 0x15	; 21
   11f9c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11fa0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11fa2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11fa4:	81 e0       	ldi	r24, 0x01	; 1
   11fa6:	90 e0       	ldi	r25, 0x00	; 0
   11fa8:	90 93 ed 01 	sts	0x01ED, r25
   11fac:	80 93 ec 01 	sts	0x01EC, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
   11fb0:	10 92 bc 01 	sts	0x01BC, r1
          stMenuMaster=mmDelayExit;
   11fb4:	8f e0       	ldi	r24, 0x0F	; 15
   11fb6:	31 cf       	rjmp	.-414    	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
   11fb8:	80 91 bc 01 	lds	r24, 0x01BC
   11fbc:	85 30       	cpi	r24, 0x05	; 5
   11fbe:	30 f0       	brcs	.+12     	; 0x11fcc <FMenuMaster+0x412>
   11fc0:	80 e1       	ldi	r24, 0x10	; 16
   11fc2:	2b cf       	rjmp	.-426    	; 0x11e1a <FMenuMaster+0x260>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
   11fc4:	10 92 3c 03 	sts	0x033C, r1
   11fc8:	81 e0       	ldi	r24, 0x01	; 1
   11fca:	01 c0       	rjmp	.+2      	; 0x11fce <FMenuMaster+0x414>
   11fcc:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
   11fce:	e2 96       	adiw	r28, 0x32	; 50
   11fd0:	0f b6       	in	r0, 0x3f	; 63
   11fd2:	f8 94       	cli
   11fd4:	de bf       	out	0x3e, r29	; 62
   11fd6:	0f be       	out	0x3f, r0	; 63
   11fd8:	cd bf       	out	0x3d, r28	; 61
   11fda:	cf 91       	pop	r28
   11fdc:	df 91       	pop	r29
   11fde:	1f 91       	pop	r17
   11fe0:	0f 91       	pop	r16
   11fe2:	ff 90       	pop	r15
   11fe4:	ef 90       	pop	r14
   11fe6:	08 95       	ret

00011fe8 <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
   11fe8:	af 92       	push	r10
   11fea:	bf 92       	push	r11
   11fec:	cf 92       	push	r12
   11fee:	df 92       	push	r13
   11ff0:	ef 92       	push	r14
   11ff2:	0f 93       	push	r16
   11ff4:	1f 93       	push	r17
   11ff6:	df 93       	push	r29
   11ff8:	cf 93       	push	r28
   11ffa:	cd b7       	in	r28, 0x3d	; 61
   11ffc:	de b7       	in	r29, 0x3e	; 62
   11ffe:	6e 97       	sbiw	r28, 0x1e	; 30
   12000:	0f b6       	in	r0, 0x3f	; 63
   12002:	f8 94       	cli
   12004:	de bf       	out	0x3e, r29	; 62
   12006:	0f be       	out	0x3f, r0	; 63
   12008:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,uiResult,strPassword[10],PassStatus=MP_NONE;;
char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];

     Result=MP_NONE;
     switch(stMenuPasword){
   1200a:	e0 90 49 03 	lds	r14, 0x0349
   1200e:	81 e0       	ldi	r24, 0x01	; 1
   12010:	e8 16       	cp	r14, r24
   12012:	09 f1       	breq	.+66     	; 0x12056 <FMenuPassword+0x6e>
   12014:	e8 16       	cp	r14, r24
   12016:	48 f0       	brcs	.+18     	; 0x1202a <FMenuPassword+0x42>
   12018:	e2 e0       	ldi	r30, 0x02	; 2
   1201a:	ee 16       	cp	r14, r30
   1201c:	09 f4       	brne	.+2      	; 0x12020 <FMenuPassword+0x38>
   1201e:	3f c0       	rjmp	.+126    	; 0x1209e <FMenuPassword+0xb6>
   12020:	f3 e0       	ldi	r31, 0x03	; 3
   12022:	ef 16       	cp	r14, r31
   12024:	09 f0       	breq	.+2      	; 0x12028 <FMenuPassword+0x40>
   12026:	92 c0       	rjmp	.+292    	; 0x1214c <FMenuPassword+0x164>
   12028:	8c c0       	rjmp	.+280    	; 0x12142 <FMenuPassword+0x15a>
	 case mpInitPassword:
	      lcd_clear();
   1202a:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
   1202e:	81 e0       	ldi	r24, 0x01	; 1
   12030:	61 e0       	ldi	r22, 0x01	; 1
   12032:	40 e3       	ldi	r20, 0x30	; 48
   12034:	57 e1       	ldi	r21, 0x17	; 23
   12036:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   1203a:	82 e0       	ldi	r24, 0x02	; 2
   1203c:	61 e0       	ldi	r22, 0x01	; 1
   1203e:	4e e2       	ldi	r20, 0x2E	; 46
   12040:	57 e1       	ldi	r21, 0x17	; 23
   12042:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12046:	84 e0       	ldi	r24, 0x04	; 4
   12048:	61 e0       	ldi	r22, 0x01	; 1
   1204a:	49 e1       	ldi	r20, 0x19	; 25
   1204c:	57 e1       	ldi	r21, 0x17	; 23
   1204e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
   12052:	81 e0       	ldi	r24, 0x01	; 1
   12054:	73 c0       	rjmp	.+230    	; 0x1213c <FMenuPassword+0x154>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
   12056:	84 e0       	ldi	r24, 0x04	; 4
   12058:	62 e0       	ldi	r22, 0x02	; 2
   1205a:	41 e0       	ldi	r20, 0x01	; 1
   1205c:	2e e3       	ldi	r18, 0x3E	; 62
   1205e:	33 e0       	ldi	r19, 0x03	; 3
   12060:	00 e0       	ldi	r16, 0x00	; 0
   12062:	10 e0       	ldi	r17, 0x00	; 0
   12064:	98 e0       	ldi	r25, 0x08	; 8
   12066:	e9 2e       	mov	r14, r25
   12068:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   1206c:	80 93 48 03 	sts	0x0348, r24
		  if (uiResult==USER_OK){
   12070:	83 30       	cpi	r24, 0x03	; 3
   12072:	11 f4       	brne	.+4      	; 0x12078 <FMenuPassword+0x90>
		      stMenuPasword=mpProcessPassword;
   12074:	82 e0       	ldi	r24, 0x02	; 2
   12076:	62 c0       	rjmp	.+196    	; 0x1213c <FMenuPassword+0x154>
			  }
		  else
		  if (uiResult==USER_CANCEL){
   12078:	81 30       	cpi	r24, 0x01	; 1
   1207a:	09 f4       	brne	.+2      	; 0x1207e <FMenuPassword+0x96>
   1207c:	50 c0       	rjmp	.+160    	; 0x1211e <FMenuPassword+0x136>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1207e:	84 30       	cpi	r24, 0x04	; 4
   12080:	21 f4       	brne	.+8      	; 0x1208a <FMenuPassword+0xa2>
   12082:	61 e0       	ldi	r22, 0x01	; 1
   12084:	44 e0       	ldi	r20, 0x04	; 4
   12086:	57 e1       	ldi	r21, 0x17	; 23
   12088:	07 c0       	rjmp	.+14     	; 0x12098 <FMenuPassword+0xb0>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1208a:	85 30       	cpi	r24, 0x05	; 5
   1208c:	09 f0       	breq	.+2      	; 0x12090 <FMenuPassword+0xa8>
   1208e:	5e c0       	rjmp	.+188    	; 0x1214c <FMenuPassword+0x164>
   12090:	84 e0       	ldi	r24, 0x04	; 4
   12092:	61 e0       	ldi	r22, 0x01	; 1
   12094:	4f ee       	ldi	r20, 0xEF	; 239
   12096:	56 e1       	ldi	r21, 0x16	; 22
   12098:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   1209c:	57 c0       	rjmp	.+174    	; 0x1214c <FMenuPassword+0x164>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
   1209e:	00 d0       	rcall	.+0      	; 0x120a0 <FMenuPassword+0xb8>
   120a0:	00 d0       	rcall	.+0      	; 0x120a2 <FMenuPassword+0xba>
   120a2:	8e 01       	movw	r16, r28
   120a4:	0f 5f       	subi	r16, 0xFF	; 255
   120a6:	1f 4f       	sbci	r17, 0xFF	; 255
   120a8:	ed b7       	in	r30, 0x3d	; 61
   120aa:	fe b7       	in	r31, 0x3e	; 62
   120ac:	12 83       	std	Z+2, r17	; 0x02
   120ae:	01 83       	std	Z+1, r16	; 0x01
   120b0:	87 ee       	ldi	r24, 0xE7	; 231
   120b2:	96 e1       	ldi	r25, 0x16	; 22
   120b4:	94 83       	std	Z+4, r25	; 0x04
   120b6:	83 83       	std	Z+3, r24	; 0x03
   120b8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   120bc:	0f 90       	pop	r0
   120be:	0f 90       	pop	r0
   120c0:	0f 90       	pop	r0
   120c2:	0f 90       	pop	r0
   120c4:	85 e1       	ldi	r24, 0x15	; 21
   120c6:	c8 2e       	mov	r12, r24
   120c8:	d1 2c       	mov	r13, r1
   120ca:	cc 0e       	add	r12, r28
   120cc:	dd 1e       	adc	r13, r29
   120ce:	c6 01       	movw	r24, r12
   120d0:	61 e0       	ldi	r22, 0x01	; 1
   120d2:	70 e0       	ldi	r23, 0x00	; 0
   120d4:	4a e0       	ldi	r20, 0x0A	; 10
   120d6:	50 e0       	ldi	r21, 0x00	; 0
   120d8:	27 e9       	ldi	r18, 0x97	; 151
   120da:	32 e1       	ldi	r19, 0x12	; 18
   120dc:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
   120e0:	bb e0       	ldi	r27, 0x0B	; 11
   120e2:	ab 2e       	mov	r10, r27
   120e4:	b1 2c       	mov	r11, r1
   120e6:	ac 0e       	add	r10, r28
   120e8:	bd 1e       	adc	r11, r29
   120ea:	c5 01       	movw	r24, r10
   120ec:	6b e0       	ldi	r22, 0x0B	; 11
   120ee:	70 e0       	ldi	r23, 0x00	; 0
   120f0:	4a e0       	ldi	r20, 0x0A	; 10
   120f2:	50 e0       	ldi	r21, 0x00	; 0
   120f4:	27 e9       	ldi	r18, 0x97	; 151
   120f6:	32 e1       	ldi	r19, 0x12	; 18
   120f8:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
   120fc:	c8 01       	movw	r24, r16
   120fe:	6e e3       	ldi	r22, 0x3E	; 62
   12100:	73 e0       	ldi	r23, 0x03	; 3
   12102:	0e 94 c4 b5 	call	0x16b88	; 0x16b88 <strcmp>
   12106:	00 97       	sbiw	r24, 0x00	; 0
   12108:	11 f4       	brne	.+4      	; 0x1210e <FMenuPassword+0x126>
		       PassStatus=MP_VALID_MASTER;
   1210a:	83 e0       	ldi	r24, 0x03	; 3
   1210c:	08 c0       	rjmp	.+16     	; 0x1211e <FMenuPassword+0x136>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
   1210e:	c6 01       	movw	r24, r12
   12110:	6e e3       	ldi	r22, 0x3E	; 62
   12112:	73 e0       	ldi	r23, 0x03	; 3
   12114:	0e 94 c4 b5 	call	0x16b88	; 0x16b88 <strcmp>
   12118:	00 97       	sbiw	r24, 0x00	; 0
   1211a:	21 f4       	brne	.+8      	; 0x12124 <FMenuPassword+0x13c>
		       PassStatus=MP_VALID_ADMIN;
   1211c:	84 e0       	ldi	r24, 0x04	; 4
   1211e:	80 93 3d 03 	sts	0x033D, r24
   12122:	0b c0       	rjmp	.+22     	; 0x1213a <FMenuPassword+0x152>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
   12124:	c5 01       	movw	r24, r10
   12126:	6e e3       	ldi	r22, 0x3E	; 62
   12128:	73 e0       	ldi	r23, 0x03	; 3
   1212a:	0e 94 c4 b5 	call	0x16b88	; 0x16b88 <strcmp>
   1212e:	00 97       	sbiw	r24, 0x00	; 0
   12130:	11 f4       	brne	.+4      	; 0x12136 <FMenuPassword+0x14e>
		       PassStatus=MP_VALID_SYSTEM;
   12132:	85 e0       	ldi	r24, 0x05	; 5
   12134:	f4 cf       	rjmp	.-24     	; 0x1211e <FMenuPassword+0x136>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
   12136:	e0 92 3d 03 	sts	0x033D, r14
		  stMenuPasword=mpExit;
   1213a:	83 e0       	ldi	r24, 0x03	; 3
   1213c:	80 93 49 03 	sts	0x0349, r24
   12140:	05 c0       	rjmp	.+10     	; 0x1214c <FMenuPassword+0x164>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
   12142:	10 92 49 03 	sts	0x0349, r1
	      Result=PassStatus;
   12146:	80 91 3d 03 	lds	r24, 0x033D
   1214a:	01 c0       	rjmp	.+2      	; 0x1214e <FMenuPassword+0x166>
   1214c:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
   1214e:	6e 96       	adiw	r28, 0x1e	; 30
   12150:	0f b6       	in	r0, 0x3f	; 63
   12152:	f8 94       	cli
   12154:	de bf       	out	0x3e, r29	; 62
   12156:	0f be       	out	0x3f, r0	; 63
   12158:	cd bf       	out	0x3d, r28	; 61
   1215a:	cf 91       	pop	r28
   1215c:	df 91       	pop	r29
   1215e:	1f 91       	pop	r17
   12160:	0f 91       	pop	r16
   12162:	ef 90       	pop	r14
   12164:	df 90       	pop	r13
   12166:	cf 90       	pop	r12
   12168:	bf 90       	pop	r11
   1216a:	af 90       	pop	r10
   1216c:	08 95       	ret

0001216e <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   1216e:	0f 93       	push	r16
   12170:	1f 93       	push	r17
   12172:	df 93       	push	r29
   12174:	cf 93       	push	r28
   12176:	cd b7       	in	r28, 0x3d	; 61
   12178:	de b7       	in	r29, 0x3e	; 62
   1217a:	64 97       	sbiw	r28, 0x14	; 20
   1217c:	0f b6       	in	r0, 0x3f	; 63
   1217e:	f8 94       	cli
   12180:	de bf       	out	0x3e, r29	; 62
   12182:	0f be       	out	0x3f, r0	; 63
   12184:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,FIP_USED,KeyChar;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   12186:	80 91 6b 03 	lds	r24, 0x036B
   1218a:	87 30       	cpi	r24, 0x07	; 7
   1218c:	09 f4       	brne	.+2      	; 0x12190 <FMenuReprint+0x22>
   1218e:	8e c0       	rjmp	.+284    	; 0x122ac <FMenuReprint+0x13e>
   12190:	88 30       	cpi	r24, 0x08	; 8
   12192:	90 f4       	brcc	.+36     	; 0x121b8 <FMenuReprint+0x4a>
   12194:	83 30       	cpi	r24, 0x03	; 3
   12196:	09 f4       	brne	.+2      	; 0x1219a <FMenuReprint+0x2c>
   12198:	43 c0       	rjmp	.+134    	; 0x12220 <FMenuReprint+0xb2>
   1219a:	84 30       	cpi	r24, 0x04	; 4
   1219c:	30 f4       	brcc	.+12     	; 0x121aa <FMenuReprint+0x3c>
   1219e:	81 30       	cpi	r24, 0x01	; 1
   121a0:	09 f4       	brne	.+2      	; 0x121a4 <FMenuReprint+0x36>
   121a2:	55 c0       	rjmp	.+170    	; 0x1224e <FMenuReprint+0xe0>
   121a4:	82 30       	cpi	r24, 0x02	; 2
   121a6:	48 f5       	brcc	.+82     	; 0x121fa <FMenuReprint+0x8c>
   121a8:	1d c0       	rjmp	.+58     	; 0x121e4 <FMenuReprint+0x76>
   121aa:	85 30       	cpi	r24, 0x05	; 5
   121ac:	09 f4       	brne	.+2      	; 0x121b0 <FMenuReprint+0x42>
   121ae:	6c c0       	rjmp	.+216    	; 0x12288 <FMenuReprint+0x11a>
   121b0:	86 30       	cpi	r24, 0x06	; 6
   121b2:	08 f0       	brcs	.+2      	; 0x121b6 <FMenuReprint+0x48>
   121b4:	50 c0       	rjmp	.+160    	; 0x12256 <FMenuReprint+0xe8>
   121b6:	45 c0       	rjmp	.+138    	; 0x12242 <FMenuReprint+0xd4>
   121b8:	8b 30       	cpi	r24, 0x0B	; 11
   121ba:	09 f4       	brne	.+2      	; 0x121be <FMenuReprint+0x50>
   121bc:	da c0       	rjmp	.+436    	; 0x12372 <FMenuReprint+0x204>
   121be:	8c 30       	cpi	r24, 0x0C	; 12
   121c0:	38 f4       	brcc	.+14     	; 0x121d0 <FMenuReprint+0x62>
   121c2:	89 30       	cpi	r24, 0x09	; 9
   121c4:	09 f4       	brne	.+2      	; 0x121c8 <FMenuReprint+0x5a>
   121c6:	b8 c0       	rjmp	.+368    	; 0x12338 <FMenuReprint+0x1ca>
   121c8:	8a 30       	cpi	r24, 0x0A	; 10
   121ca:	08 f0       	brcs	.+2      	; 0x121ce <FMenuReprint+0x60>
   121cc:	ca c0       	rjmp	.+404    	; 0x12362 <FMenuReprint+0x1f4>
   121ce:	7c c0       	rjmp	.+248    	; 0x122c8 <FMenuReprint+0x15a>
   121d0:	8d 30       	cpi	r24, 0x0D	; 13
   121d2:	09 f4       	brne	.+2      	; 0x121d6 <FMenuReprint+0x68>
   121d4:	ed c0       	rjmp	.+474    	; 0x123b0 <FMenuReprint+0x242>
   121d6:	8d 30       	cpi	r24, 0x0D	; 13
   121d8:	08 f4       	brcc	.+2      	; 0x121dc <FMenuReprint+0x6e>
   121da:	d7 c0       	rjmp	.+430    	; 0x1238a <FMenuReprint+0x21c>
   121dc:	8e 30       	cpi	r24, 0x0E	; 14
   121de:	09 f0       	breq	.+2      	; 0x121e2 <FMenuReprint+0x74>
   121e0:	f0 c0       	rjmp	.+480    	; 0x123c2 <FMenuReprint+0x254>
   121e2:	eb c0       	rjmp	.+470    	; 0x123ba <FMenuReprint+0x24c>
	 case rtInit:
	      lcd_clear();
   121e4:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   121e8:	80 91 25 01 	lds	r24, 0x0125
   121ec:	81 30       	cpi	r24, 0x01	; 1
   121ee:	09 f4       	brne	.+2      	; 0x121f2 <FMenuReprint+0x84>
   121f0:	b3 c0       	rjmp	.+358    	; 0x12358 <FMenuReprint+0x1ea>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   121f2:	82 30       	cpi	r24, 0x02	; 2
   121f4:	09 f0       	breq	.+2      	; 0x121f8 <FMenuReprint+0x8a>
   121f6:	e5 c0       	rjmp	.+458    	; 0x123c2 <FMenuReprint+0x254>
   121f8:	04 c0       	rjmp	.+8      	; 0x12202 <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   121fa:	0e 94 f4 8f 	call	0x11fe8	; 0x11fe8 <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   121fe:	84 30       	cpi	r24, 0x04	; 4
   12200:	11 f4       	brne	.+4      	; 0x12206 <FMenuReprint+0x98>
   12202:	81 e0       	ldi	r24, 0x01	; 1
   12204:	0a c0       	rjmp	.+20     	; 0x1221a <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   12206:	85 30       	cpi	r24, 0x05	; 5
   12208:	11 f0       	breq	.+4      	; 0x1220e <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   1220a:	82 30       	cpi	r24, 0x02	; 2
   1220c:	11 f4       	brne	.+4      	; 0x12212 <FMenuReprint+0xa4>
   1220e:	83 e0       	ldi	r24, 0x03	; 3
   12210:	04 c0       	rjmp	.+8      	; 0x1221a <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   12212:	81 30       	cpi	r24, 0x01	; 1
   12214:	09 f0       	breq	.+2      	; 0x12218 <FMenuReprint+0xaa>
   12216:	d5 c0       	rjmp	.+426    	; 0x123c2 <FMenuReprint+0x254>
   12218:	8e e0       	ldi	r24, 0x0E	; 14
   1221a:	80 93 6b 03 	sts	0x036B, r24
   1221e:	d1 c0       	rjmp	.+418    	; 0x123c2 <FMenuReprint+0x254>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   12220:	10 92 bc 01 	sts	0x01BC, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12224:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12226:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12228:	81 e0       	ldi	r24, 0x01	; 1
   1222a:	90 e0       	ldi	r25, 0x00	; 0
   1222c:	90 93 ed 01 	sts	0x01ED, r25
   12230:	80 93 ec 01 	sts	0x01EC, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   12234:	83 e0       	ldi	r24, 0x03	; 3
   12236:	61 e0       	ldi	r22, 0x01	; 1
   12238:	4a eb       	ldi	r20, 0xBA	; 186
   1223a:	5a e1       	ldi	r21, 0x1A	; 26
   1223c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   12240:	33 c0       	rjmp	.+102    	; 0x122a8 <FMenuReprint+0x13a>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   12242:	80 91 bc 01 	lds	r24, 0x01BC
   12246:	83 30       	cpi	r24, 0x03	; 3
   12248:	08 f4       	brcc	.+2      	; 0x1224c <FMenuReprint+0xde>
   1224a:	bb c0       	rjmp	.+374    	; 0x123c2 <FMenuReprint+0x254>
   1224c:	e5 cf       	rjmp	.-54     	; 0x12218 <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   1224e:	0e 94 3a 42 	call	0x8474	; 0x8474 <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   12252:	86 e0       	ldi	r24, 0x06	; 6
   12254:	e2 cf       	rjmp	.-60     	; 0x1221a <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   12256:	81 e0       	ldi	r24, 0x01	; 1
   12258:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   1225c:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   12260:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   12262:	81 53       	subi	r24, 0x31	; 49
   12264:	88 30       	cpi	r24, 0x08	; 8
   12266:	60 f4       	brcc	.+24     	; 0x12280 <FMenuReprint+0x112>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   12268:	8f 5f       	subi	r24, 0xFF	; 255
   1226a:	61 e0       	ldi	r22, 0x01	; 1
   1226c:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   12270:	82 31       	cpi	r24, 0x12	; 18
   12272:	11 f4       	brne	.+4      	; 0x12278 <FMenuReprint+0x10a>
   12274:	85 e0       	ldi	r24, 0x05	; 5
   12276:	d1 cf       	rjmp	.-94     	; 0x1221a <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;
   12278:	81 31       	cpi	r24, 0x11	; 17
   1227a:	09 f0       	breq	.+2      	; 0x1227e <FMenuReprint+0x110>
   1227c:	a2 c0       	rjmp	.+324    	; 0x123c2 <FMenuReprint+0x254>
   1227e:	cc cf       	rjmp	.-104    	; 0x12218 <FMenuReprint+0xaa>

		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   12280:	9a 32       	cpi	r25, 0x2A	; 42
   12282:	09 f0       	breq	.+2      	; 0x12286 <FMenuReprint+0x118>
   12284:	9e c0       	rjmp	.+316    	; 0x123c2 <FMenuReprint+0x254>
   12286:	c8 cf       	rjmp	.-112    	; 0x12218 <FMenuReprint+0xaa>

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   12288:	83 e0       	ldi	r24, 0x03	; 3
   1228a:	61 e0       	ldi	r22, 0x01	; 1
   1228c:	45 ea       	ldi	r20, 0xA5	; 165
   1228e:	5a e1       	ldi	r21, 0x1A	; 26
   12290:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12294:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12296:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12298:	81 e0       	ldi	r24, 0x01	; 1
   1229a:	90 e0       	ldi	r25, 0x00	; 0
   1229c:	90 93 ed 01 	sts	0x01ED, r25
   122a0:	80 93 ec 01 	sts	0x01EC, r24

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   122a4:	10 92 bc 01 	sts	0x01BC, r1
		  stReprint=rtTimDisplayInvalid;
   122a8:	84 e0       	ldi	r24, 0x04	; 4
   122aa:	b7 cf       	rjmp	.-146    	; 0x1221a <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   122ac:	89 e6       	ldi	r24, 0x69	; 105
   122ae:	93 e0       	ldi	r25, 0x03	; 3
   122b0:	63 ec       	ldi	r22, 0xC3	; 195
   122b2:	79 e0       	ldi	r23, 0x09	; 9
   122b4:	0e 94 6a 65 	call	0xcad4	; 0xcad4 <menu_FIP>
		  if (FIPResult==FIP_DONE){
   122b8:	88 23       	and	r24, r24
   122ba:	11 f4       	brne	.+4      	; 0x122c0 <FMenuReprint+0x152>
		      stReprint=rtRFID;
   122bc:	88 e0       	ldi	r24, 0x08	; 8
   122be:	ad cf       	rjmp	.-166    	; 0x1221a <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   122c0:	82 30       	cpi	r24, 0x02	; 2
   122c2:	09 f0       	breq	.+2      	; 0x122c6 <FMenuReprint+0x158>
   122c4:	7e c0       	rjmp	.+252    	; 0x123c2 <FMenuReprint+0x254>
   122c6:	a8 cf       	rjmp	.-176    	; 0x12218 <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   122c8:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   122cc:	00 d0       	rcall	.+0      	; 0x122ce <FMenuReprint+0x160>
   122ce:	00 d0       	rcall	.+0      	; 0x122d0 <FMenuReprint+0x162>
   122d0:	00 d0       	rcall	.+0      	; 0x122d2 <FMenuReprint+0x164>
   122d2:	ed b7       	in	r30, 0x3d	; 61
   122d4:	fe b7       	in	r31, 0x3e	; 62
   122d6:	31 96       	adiw	r30, 0x01	; 1
   122d8:	8e 01       	movw	r16, r28
   122da:	0f 5f       	subi	r16, 0xFF	; 255
   122dc:	1f 4f       	sbci	r17, 0xFF	; 255
   122de:	ad b7       	in	r26, 0x3d	; 61
   122e0:	be b7       	in	r27, 0x3e	; 62
   122e2:	12 96       	adiw	r26, 0x02	; 2
   122e4:	1c 93       	st	X, r17
   122e6:	0e 93       	st	-X, r16
   122e8:	11 97       	sbiw	r26, 0x01	; 1
   122ea:	85 e9       	ldi	r24, 0x95	; 149
   122ec:	9a e1       	ldi	r25, 0x1A	; 26
   122ee:	93 83       	std	Z+3, r25	; 0x03
   122f0:	82 83       	std	Z+2, r24	; 0x02
   122f2:	83 ec       	ldi	r24, 0xC3	; 195
   122f4:	99 e0       	ldi	r25, 0x09	; 9
   122f6:	95 83       	std	Z+5, r25	; 0x05
   122f8:	84 83       	std	Z+4, r24	; 0x04
   122fa:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   122fe:	8d b7       	in	r24, 0x3d	; 61
   12300:	9e b7       	in	r25, 0x3e	; 62
   12302:	06 96       	adiw	r24, 0x06	; 6
   12304:	0f b6       	in	r0, 0x3f	; 63
   12306:	f8 94       	cli
   12308:	9e bf       	out	0x3e, r25	; 62
   1230a:	0f be       	out	0x3f, r0	; 63
   1230c:	8d bf       	out	0x3d, r24	; 61
   1230e:	81 e0       	ldi	r24, 0x01	; 1
   12310:	61 e0       	ldi	r22, 0x01	; 1
   12312:	a8 01       	movw	r20, r16
   12314:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   12318:	82 e0       	ldi	r24, 0x02	; 2
   1231a:	61 e0       	ldi	r22, 0x01	; 1
   1231c:	41 e8       	ldi	r20, 0x81	; 129
   1231e:	5a e1       	ldi	r21, 0x1A	; 26
   12320:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   12324:	84 e0       	ldi	r24, 0x04	; 4
   12326:	61 e0       	ldi	r22, 0x01	; 1
   12328:	4e e6       	ldi	r20, 0x6E	; 110
   1232a:	5a e1       	ldi	r21, 0x1A	; 26
   1232c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  IsRFIDDetected=False;
   12330:	10 92 c4 01 	sts	0x01C4, r1
		  stReprint=rtInputRFID;
   12334:	89 e0       	ldi	r24, 0x09	; 9
   12336:	71 cf       	rjmp	.-286    	; 0x1221a <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   12338:	80 91 c4 01 	lds	r24, 0x01C4
   1233c:	81 30       	cpi	r24, 0x01	; 1
   1233e:	29 f4       	brne	.+10     	; 0x1234a <FMenuReprint+0x1dc>
		      IsRFIDDetected=False;
   12340:	10 92 c4 01 	sts	0x01C4, r1
		      stReprint=rtSendMessage28;
   12344:	8a e0       	ldi	r24, 0x0A	; 10
   12346:	80 93 6b 03 	sts	0x036B, r24
		  }
	 	  KeyPressed=_key_scan(1);
   1234a:	81 e0       	ldi	r24, 0x01	; 1
   1234c:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   12350:	80 93 6a 03 	sts	0x036A, r24
		  if (KeyPressed==_KEY_CANCEL){
   12354:	87 3e       	cpi	r24, 0xE7	; 231
   12356:	11 f4       	brne	.+4      	; 0x1235c <FMenuReprint+0x1ee>
		      stReprint=rtFIP;
   12358:	87 e0       	ldi	r24, 0x07	; 7
   1235a:	5f cf       	rjmp	.-322    	; 0x1221a <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   1235c:	87 3b       	cpi	r24, 0xB7	; 183
   1235e:	89 f5       	brne	.+98     	; 0x123c2 <FMenuReprint+0x254>
   12360:	5b cf       	rjmp	.-330    	; 0x12218 <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   12362:	0e 94 e4 50 	call	0xa1c8	; 0xa1c8 <sendMessage28>
		  TimSend=0;
   12366:	10 92 be 01 	sts	0x01BE, r1
   1236a:	10 92 bd 01 	sts	0x01BD, r1
		  stReprint=rtWaitReply;
   1236e:	8b e0       	ldi	r24, 0x0B	; 11
   12370:	54 cf       	rjmp	.-344    	; 0x1221a <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   12372:	80 91 bd 01 	lds	r24, 0x01BD
   12376:	90 91 be 01 	lds	r25, 0x01BE
   1237a:	4f 97       	sbiw	r24, 0x1f	; 31
   1237c:	18 f0       	brcs	.+6      	; 0x12384 <FMenuReprint+0x216>
   1237e:	8c e0       	ldi	r24, 0x0C	; 12
   12380:	80 93 6b 03 	sts	0x036B, r24
	      if (IsMessage99==True){
   12384:	80 91 cc 01 	lds	r24, 0x01CC
   12388:	44 cf       	rjmp	.-376    	; 0x12212 <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   1238a:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   1238e:	82 e0       	ldi	r24, 0x02	; 2
   12390:	61 e0       	ldi	r22, 0x01	; 1
   12392:	40 e6       	ldi	r20, 0x60	; 96
   12394:	5a e1       	ldi	r21, 0x1A	; 26
   12396:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   1239a:	83 e0       	ldi	r24, 0x03	; 3
   1239c:	61 e0       	ldi	r22, 0x01	; 1
   1239e:	42 e5       	ldi	r20, 0x52	; 82
   123a0:	5a e1       	ldi	r21, 0x1A	; 26
   123a2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  TimDisplay=5;
   123a6:	85 e0       	ldi	r24, 0x05	; 5
   123a8:	80 93 bc 01 	sts	0x01BC, r24
		  stReprint=rtDelayExitReprint;
   123ac:	8d e0       	ldi	r24, 0x0D	; 13
   123ae:	35 cf       	rjmp	.-406    	; 0x1221a <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   123b0:	80 91 bc 01 	lds	r24, 0x01BC
   123b4:	8a 30       	cpi	r24, 0x0A	; 10
   123b6:	28 f0       	brcs	.+10     	; 0x123c2 <FMenuReprint+0x254>
   123b8:	2f cf       	rjmp	.-418    	; 0x12218 <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   123ba:	10 92 6b 03 	sts	0x036B, r1
   123be:	81 e0       	ldi	r24, 0x01	; 1
   123c0:	01 c0       	rjmp	.+2      	; 0x123c4 <FMenuReprint+0x256>
   123c2:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   123c4:	64 96       	adiw	r28, 0x14	; 20
   123c6:	0f b6       	in	r0, 0x3f	; 63
   123c8:	f8 94       	cli
   123ca:	de bf       	out	0x3e, r29	; 62
   123cc:	0f be       	out	0x3f, r0	; 63
   123ce:	cd bf       	out	0x3d, r28	; 61
   123d0:	cf 91       	pop	r28
   123d2:	df 91       	pop	r29
   123d4:	1f 91       	pop	r17
   123d6:	0f 91       	pop	r16
   123d8:	08 95       	ret

000123da <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   123da:	80 91 3b 03 	lds	r24, 0x033B
   123de:	83 30       	cpi	r24, 0x03	; 3
   123e0:	09 f4       	brne	.+2      	; 0x123e4 <FMenuAdmin+0xa>
   123e2:	66 c0       	rjmp	.+204    	; 0x124b0 <FMenuAdmin+0xd6>
   123e4:	84 30       	cpi	r24, 0x04	; 4
   123e6:	30 f4       	brcc	.+12     	; 0x123f4 <FMenuAdmin+0x1a>
   123e8:	81 30       	cpi	r24, 0x01	; 1
   123ea:	69 f1       	breq	.+90     	; 0x12446 <FMenuAdmin+0x6c>
   123ec:	82 30       	cpi	r24, 0x02	; 2
   123ee:	08 f0       	brcs	.+2      	; 0x123f2 <FMenuAdmin+0x18>
   123f0:	4d c0       	rjmp	.+154    	; 0x1248c <FMenuAdmin+0xb2>
   123f2:	0d c0       	rjmp	.+26     	; 0x1240e <FMenuAdmin+0x34>
   123f4:	85 30       	cpi	r24, 0x05	; 5
   123f6:	09 f4       	brne	.+2      	; 0x123fa <FMenuAdmin+0x20>
   123f8:	4e c0       	rjmp	.+156    	; 0x12496 <FMenuAdmin+0xbc>
   123fa:	85 30       	cpi	r24, 0x05	; 5
   123fc:	08 f4       	brcc	.+2      	; 0x12400 <FMenuAdmin+0x26>
   123fe:	49 c0       	rjmp	.+146    	; 0x12492 <FMenuAdmin+0xb8>
   12400:	86 30       	cpi	r24, 0x06	; 6
   12402:	09 f4       	brne	.+2      	; 0x12406 <FMenuAdmin+0x2c>
   12404:	51 c0       	rjmp	.+162    	; 0x124a8 <FMenuAdmin+0xce>
   12406:	87 30       	cpi	r24, 0x07	; 7
   12408:	09 f0       	breq	.+2      	; 0x1240c <FMenuAdmin+0x32>
   1240a:	5a c0       	rjmp	.+180    	; 0x124c0 <FMenuAdmin+0xe6>
   1240c:	55 c0       	rjmp	.+170    	; 0x124b8 <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   1240e:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   12412:	81 e0       	ldi	r24, 0x01	; 1
   12414:	61 e0       	ldi	r22, 0x01	; 1
   12416:	4e e3       	ldi	r20, 0x3E	; 62
   12418:	55 e1       	ldi	r21, 0x15	; 21
   1241a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   1241e:	82 e0       	ldi	r24, 0x02	; 2
   12420:	61 e0       	ldi	r22, 0x01	; 1
   12422:	49 e2       	ldi	r20, 0x29	; 41
   12424:	55 e1       	ldi	r21, 0x15	; 21
   12426:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   1242a:	83 e0       	ldi	r24, 0x03	; 3
   1242c:	61 e0       	ldi	r22, 0x01	; 1
   1242e:	44 e1       	ldi	r20, 0x14	; 20
   12430:	55 e1       	ldi	r21, 0x15	; 21
   12432:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   12436:	84 e0       	ldi	r24, 0x04	; 4
   12438:	61 e0       	ldi	r22, 0x01	; 1
   1243a:	4f ef       	ldi	r20, 0xFF	; 255
   1243c:	54 e1       	ldi	r21, 0x14	; 20
   1243e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   12442:	81 e0       	ldi	r24, 0x01	; 1
   12444:	2e c0       	rjmp	.+92     	; 0x124a2 <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   12446:	81 e0       	ldi	r24, 0x01	; 1
   12448:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1244c:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		  switch (KeyChar){
   12450:	82 33       	cpi	r24, 0x32	; 50
   12452:	71 f0       	breq	.+28     	; 0x12470 <FMenuAdmin+0x96>
   12454:	83 33       	cpi	r24, 0x33	; 51
   12456:	28 f4       	brcc	.+10     	; 0x12462 <FMenuAdmin+0x88>
   12458:	8a 32       	cpi	r24, 0x2A	; 42
   1245a:	11 f1       	breq	.+68     	; 0x124a0 <FMenuAdmin+0xc6>
   1245c:	81 33       	cpi	r24, 0x31	; 49
   1245e:	81 f5       	brne	.+96     	; 0x124c0 <FMenuAdmin+0xe6>
   12460:	05 c0       	rjmp	.+10     	; 0x1246c <FMenuAdmin+0x92>
   12462:	83 33       	cpi	r24, 0x33	; 51
   12464:	59 f0       	breq	.+22     	; 0x1247c <FMenuAdmin+0xa2>
   12466:	84 33       	cpi	r24, 0x34	; 52
   12468:	59 f5       	brne	.+86     	; 0x124c0 <FMenuAdmin+0xe6>
   1246a:	0e c0       	rjmp	.+28     	; 0x12488 <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   1246c:	82 e0       	ldi	r24, 0x02	; 2
   1246e:	19 c0       	rjmp	.+50     	; 0x124a2 <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   12470:	80 91 25 01 	lds	r24, 0x0125
   12474:	82 30       	cpi	r24, 0x02	; 2
   12476:	e1 f4       	brne	.+56     	; 0x124b0 <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   12478:	84 e0       	ldi	r24, 0x04	; 4
   1247a:	13 c0       	rjmp	.+38     	; 0x124a2 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   1247c:	80 91 25 01 	lds	r24, 0x0125
   12480:	82 30       	cpi	r24, 0x02	; 2
   12482:	b1 f4       	brne	.+44     	; 0x124b0 <FMenuAdmin+0xd6>
   12484:	85 e0       	ldi	r24, 0x05	; 5
   12486:	0d c0       	rjmp	.+26     	; 0x124a2 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   12488:	86 e0       	ldi	r24, 0x06	; 6
   1248a:	0b c0       	rjmp	.+22     	; 0x124a2 <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   1248c:	0e 94 b7 90 	call	0x1216e	; 0x1216e <FMenuReprint>
   12490:	05 c0       	rjmp	.+10     	; 0x1249c <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   12492:	82 e0       	ldi	r24, 0x02	; 2
   12494:	01 c0       	rjmp	.+2      	; 0x12498 <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   12496:	81 e0       	ldi	r24, 0x01	; 1
   12498:	0e 94 f1 5e 	call	0xbde2	; 0xbde2 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   1249c:	81 30       	cpi	r24, 0x01	; 1
   1249e:	81 f4       	brne	.+32     	; 0x124c0 <FMenuAdmin+0xe6>
   124a0:	87 e0       	ldi	r24, 0x07	; 7
   124a2:	80 93 3b 03 	sts	0x033B, r24
   124a6:	06 c0       	rjmp	.+12     	; 0x124b4 <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   124a8:	0e 94 53 8d 	call	0x11aa6	; 0x11aa6 <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   124ac:	81 30       	cpi	r24, 0x01	; 1
   124ae:	41 f4       	brne	.+16     	; 0x124c0 <FMenuAdmin+0xe6>
   124b0:	10 92 3b 03 	sts	0x033B, r1
   124b4:	80 e0       	ldi	r24, 0x00	; 0
   124b6:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   124b8:	10 92 3b 03 	sts	0x033B, r1
   124bc:	81 e0       	ldi	r24, 0x01	; 1
   124be:	08 95       	ret
   124c0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   124c2:	08 95       	ret

000124c4 <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   124c4:	af 92       	push	r10
   124c6:	bf 92       	push	r11
   124c8:	cf 92       	push	r12
   124ca:	df 92       	push	r13
   124cc:	ef 92       	push	r14
   124ce:	ff 92       	push	r15
   124d0:	0f 93       	push	r16
   124d2:	1f 93       	push	r17
   124d4:	df 93       	push	r29
   124d6:	cf 93       	push	r28
   124d8:	cd b7       	in	r28, 0x3d	; 61
   124da:	de b7       	in	r29, 0x3e	; 62
   124dc:	a3 97       	sbiw	r28, 0x23	; 35
   124de:	0f b6       	in	r0, 0x3f	; 63
   124e0:	f8 94       	cli
   124e2:	de bf       	out	0x3e, r29	; 62
   124e4:	0f be       	out	0x3f, r0	; 63
   124e6:	cd bf       	out	0x3d, r28	; 61
	   char strBankName[11],strSurcharge[4],Result;
static char BankIdx=0,Surcharge=0,uiResult;
     
Result=MENU_NONE; 

	 switch(stChangeMOP){
   124e8:	80 91 60 03 	lds	r24, 0x0360
   124ec:	e8 2f       	mov	r30, r24
   124ee:	f0 e0       	ldi	r31, 0x00	; 0
   124f0:	ee 31       	cpi	r30, 0x1E	; 30
   124f2:	f1 05       	cpc	r31, r1
   124f4:	08 f0       	brcs	.+2      	; 0x124f8 <FMenuChangeMOP+0x34>
   124f6:	0b c4       	rjmp	.+2070   	; 0x12d0e <FMenuChangeMOP+0x84a>
   124f8:	ec 53       	subi	r30, 0x3C	; 60
   124fa:	ff 4f       	sbci	r31, 0xFF	; 255
   124fc:	ee 0f       	add	r30, r30
   124fe:	ff 1f       	adc	r31, r31
   12500:	05 90       	lpm	r0, Z+
   12502:	f4 91       	lpm	r31, Z+
   12504:	e0 2d       	mov	r30, r0
   12506:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   12508:	85 e0       	ldi	r24, 0x05	; 5
   1250a:	80 93 e5 01 	sts	0x01E5, r24
   1250e:	4e c1       	rjmp	.+668    	; 0x127ac <FMenuChangeMOP+0x2e8>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   12510:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   12514:	81 e0       	ldi	r24, 0x01	; 1
   12516:	61 e0       	ldi	r22, 0x01	; 1
   12518:	44 ef       	ldi	r20, 0xF4	; 244
   1251a:	58 e1       	ldi	r21, 0x18	; 24
   1251c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   12520:	82 e0       	ldi	r24, 0x02	; 2
   12522:	61 e0       	ldi	r22, 0x01	; 1
   12524:	4f ed       	ldi	r20, 0xDF	; 223
   12526:	58 e1       	ldi	r21, 0x18	; 24
   12528:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   1252c:	83 e0       	ldi	r24, 0x03	; 3
   1252e:	61 e0       	ldi	r22, 0x01	; 1
   12530:	4a ec       	ldi	r20, 0xCA	; 202
   12532:	58 e1       	ldi	r21, 0x18	; 24
   12534:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   12538:	84 e0       	ldi	r24, 0x04	; 4
   1253a:	61 e0       	ldi	r22, 0x01	; 1
   1253c:	45 eb       	ldi	r20, 0xB5	; 181
   1253e:	58 e1       	ldi	r21, 0x18	; 24
   12540:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   12544:	82 e0       	ldi	r24, 0x02	; 2
   12546:	b5 c1       	rjmp	.+874    	; 0x128b2 <FMenuChangeMOP+0x3ee>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   12548:	81 e0       	ldi	r24, 0x01	; 1
   1254a:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   1254e:	80 93 5b 03 	sts	0x035B, r24
		  KeyChar=_key_btn(KeyPressed);
   12552:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   12556:	98 2f       	mov	r25, r24
   12558:	80 93 5c 03 	sts	0x035C, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1255c:	81 53       	subi	r24, 0x31	; 49
   1255e:	84 30       	cpi	r24, 0x04	; 4
   12560:	f0 f4       	brcc	.+60     	; 0x1259e <FMenuChangeMOP+0xda>
              switch(KeyChar){
   12562:	92 33       	cpi	r25, 0x32	; 50
   12564:	61 f0       	breq	.+24     	; 0x1257e <FMenuChangeMOP+0xba>
   12566:	93 33       	cpi	r25, 0x33	; 51
   12568:	18 f4       	brcc	.+6      	; 0x12570 <FMenuChangeMOP+0xac>
   1256a:	91 33       	cpi	r25, 0x31	; 49
   1256c:	c1 f4       	brne	.+48     	; 0x1259e <FMenuChangeMOP+0xda>
   1256e:	05 c0       	rjmp	.+10     	; 0x1257a <FMenuChangeMOP+0xb6>
   12570:	93 33       	cpi	r25, 0x33	; 51
   12572:	51 f0       	breq	.+20     	; 0x12588 <FMenuChangeMOP+0xc4>
   12574:	94 33       	cpi	r25, 0x34	; 52
   12576:	99 f4       	brne	.+38     	; 0x1259e <FMenuChangeMOP+0xda>
   12578:	0c c0       	rjmp	.+24     	; 0x12592 <FMenuChangeMOP+0xce>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   1257a:	81 e0       	ldi	r24, 0x01	; 1
   1257c:	0b c0       	rjmp	.+22     	; 0x12594 <FMenuChangeMOP+0xd0>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   1257e:	82 e0       	ldi	r24, 0x02	; 2
   12580:	80 93 e5 01 	sts	0x01E5, r24
   12584:	8b e0       	ldi	r24, 0x0B	; 11
   12586:	09 c0       	rjmp	.+18     	; 0x1259a <FMenuChangeMOP+0xd6>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   12588:	83 e0       	ldi	r24, 0x03	; 3
   1258a:	80 93 e5 01 	sts	0x01E5, r24
   1258e:	8f e0       	ldi	r24, 0x0F	; 15
   12590:	04 c0       	rjmp	.+8      	; 0x1259a <FMenuChangeMOP+0xd6>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   12592:	84 e0       	ldi	r24, 0x04	; 4
   12594:	80 93 e5 01 	sts	0x01E5, r24
   12598:	89 e0       	ldi	r24, 0x09	; 9
   1259a:	80 93 60 03 	sts	0x0360, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   1259e:	80 91 5b 03 	lds	r24, 0x035B
   125a2:	87 3e       	cpi	r24, 0xE7	; 231
   125a4:	09 f0       	breq	.+2      	; 0x125a8 <FMenuChangeMOP+0xe4>
   125a6:	b3 c3       	rjmp	.+1894   	; 0x12d0e <FMenuChangeMOP+0x84a>
   125a8:	aa c3       	rjmp	.+1876   	; 0x12cfe <FMenuChangeMOP+0x83a>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   125aa:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   125ae:	81 e0       	ldi	r24, 0x01	; 1
   125b0:	61 e0       	ldi	r22, 0x01	; 1
   125b2:	48 ea       	ldi	r20, 0xA8	; 168
   125b4:	58 e1       	ldi	r21, 0x18	; 24
   125b6:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   125ba:	82 e0       	ldi	r24, 0x02	; 2
   125bc:	61 e0       	ldi	r22, 0x01	; 1
   125be:	46 ea       	ldi	r20, 0xA6	; 166
   125c0:	58 e1       	ldi	r21, 0x18	; 24
   125c2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   125c6:	84 e0       	ldi	r24, 0x04	; 4
   125c8:	61 e0       	ldi	r22, 0x01	; 1
   125ca:	41 e9       	ldi	r20, 0x91	; 145
   125cc:	58 e1       	ldi	r21, 0x18	; 24
   125ce:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   125d2:	e2 e4       	ldi	r30, 0x42	; 66
   125d4:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   125d6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   125d8:	8e e0       	ldi	r24, 0x0E	; 14
   125da:	e7 35       	cpi	r30, 0x57	; 87
   125dc:	f8 07       	cpc	r31, r24
   125de:	d9 f7       	brne	.-10     	; 0x125d6 <FMenuChangeMOP+0x112>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;
   125e0:	87 e0       	ldi	r24, 0x07	; 7
   125e2:	80 93 60 03 	sts	0x0360, r24
		  uiResult=USER_NONE;
   125e6:	10 92 4c 03 	sts	0x034C, r1
   125ea:	91 c3       	rjmp	.+1826   	; 0x12d0e <FMenuChangeMOP+0x84a>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   125ec:	81 e0       	ldi	r24, 0x01	; 1
   125ee:	62 e0       	ldi	r22, 0x02	; 2
   125f0:	41 e0       	ldi	r20, 0x01	; 1
   125f2:	22 e4       	ldi	r18, 0x42	; 66
   125f4:	3e e0       	ldi	r19, 0x0E	; 14
   125f6:	00 e0       	ldi	r16, 0x00	; 0
   125f8:	10 e0       	ldi	r17, 0x00	; 0
   125fa:	5d e0       	ldi	r21, 0x0D	; 13
   125fc:	e5 2e       	mov	r14, r21
   125fe:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   12602:	80 93 4c 03 	sts	0x034C, r24
	      if (uiResult==USER_OK){
   12606:	83 30       	cpi	r24, 0x03	; 3
   12608:	11 f4       	brne	.+4      	; 0x1260e <FMenuChangeMOP+0x14a>
		     stChangeMOP=cmSelectFIP;
   1260a:	89 e0       	ldi	r24, 0x09	; 9
   1260c:	52 c1       	rjmp	.+676    	; 0x128b2 <FMenuChangeMOP+0x3ee>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   1260e:	81 30       	cpi	r24, 0x01	; 1
   12610:	09 f4       	brne	.+2      	; 0x12614 <FMenuChangeMOP+0x150>
   12612:	4f c1       	rjmp	.+670    	; 0x128b2 <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12614:	84 30       	cpi	r24, 0x04	; 4
   12616:	21 f4       	brne	.+8      	; 0x12620 <FMenuChangeMOP+0x15c>
   12618:	61 e0       	ldi	r22, 0x01	; 1
   1261a:	4c e7       	ldi	r20, 0x7C	; 124
   1261c:	58 e1       	ldi	r21, 0x18	; 24
   1261e:	31 c1       	rjmp	.+610    	; 0x12882 <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12620:	85 30       	cpi	r24, 0x05	; 5
   12622:	09 f0       	breq	.+2      	; 0x12626 <FMenuChangeMOP+0x162>
   12624:	74 c3       	rjmp	.+1768   	; 0x12d0e <FMenuChangeMOP+0x84a>
   12626:	84 e0       	ldi	r24, 0x04	; 4
   12628:	61 e0       	ldi	r22, 0x01	; 1
   1262a:	47 e6       	ldi	r20, 0x67	; 103
   1262c:	58 e1       	ldi	r21, 0x18	; 24
   1262e:	29 c1       	rjmp	.+594    	; 0x12882 <FMenuChangeMOP+0x3be>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12630:	8a e5       	ldi	r24, 0x5A	; 90
   12632:	93 e0       	ldi	r25, 0x03	; 3
   12634:	63 ec       	ldi	r22, 0xC3	; 195
   12636:	79 e0       	ldi	r23, 0x09	; 9
   12638:	0e 94 6a 65 	call	0xcad4	; 0xcad4 <menu_FIP>
   1263c:	80 93 5f 03 	sts	0x035F, r24
		  if (FIPResult==FIP_DONE){
   12640:	88 23       	and	r24, r24
   12642:	11 f4       	brne	.+4      	; 0x12648 <FMenuChangeMOP+0x184>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   12644:	8e e0       	ldi	r24, 0x0E	; 14
   12646:	35 c1       	rjmp	.+618    	; 0x128b2 <FMenuChangeMOP+0x3ee>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   12648:	82 30       	cpi	r24, 0x02	; 2
   1264a:	09 f0       	breq	.+2      	; 0x1264e <FMenuChangeMOP+0x18a>
   1264c:	60 c3       	rjmp	.+1728   	; 0x12d0e <FMenuChangeMOP+0x84a>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   1264e:	80 91 e5 01 	lds	r24, 0x01E5
   12652:	81 30       	cpi	r24, 0x01	; 1
   12654:	09 f4       	brne	.+2      	; 0x12658 <FMenuChangeMOP+0x194>
   12656:	2d c1       	rjmp	.+602    	; 0x128b2 <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   12658:	82 30       	cpi	r24, 0x02	; 2
   1265a:	09 f4       	brne	.+2      	; 0x1265e <FMenuChangeMOP+0x19a>
   1265c:	03 c1       	rjmp	.+518    	; 0x12864 <FMenuChangeMOP+0x3a0>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   1265e:	83 30       	cpi	r24, 0x03	; 3
   12660:	11 f4       	brne	.+4      	; 0x12666 <FMenuChangeMOP+0x1a2>
   12662:	8f e0       	ldi	r24, 0x0F	; 15
   12664:	26 c1       	rjmp	.+588    	; 0x128b2 <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   12666:	84 30       	cpi	r24, 0x04	; 4
   12668:	09 f4       	brne	.+2      	; 0x1266c <FMenuChangeMOP+0x1a8>
   1266a:	a0 c0       	rjmp	.+320    	; 0x127ac <FMenuChangeMOP+0x2e8>
   1266c:	50 c3       	rjmp	.+1696   	; 0x12d0e <FMenuChangeMOP+0x84a>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   1266e:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   12672:	81 e0       	ldi	r24, 0x01	; 1
   12674:	61 e0       	ldi	r22, 0x01	; 1
   12676:	4b e5       	ldi	r20, 0x5B	; 91
   12678:	58 e1       	ldi	r21, 0x18	; 24
   1267a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   1267e:	10 92 4f 03 	sts	0x034F, r1
   12682:	10 92 4e 03 	sts	0x034E, r1
   12686:	8e 01       	movw	r16, r28
   12688:	0b 5f       	subi	r16, 0xFB	; 251
   1268a:	1f 4f       	sbci	r17, 0xFF	; 255
   1268c:	9b e0       	ldi	r25, 0x0B	; 11
   1268e:	a9 2e       	mov	r10, r25
   12690:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12692:	80 e1       	ldi	r24, 0x10	; 16
   12694:	e8 2e       	mov	r14, r24
   12696:	f1 2c       	mov	r15, r1
   12698:	ec 0e       	add	r14, r28
   1269a:	fd 1e       	adc	r15, r29
   1269c:	b5 e5       	ldi	r27, 0x55	; 85
   1269e:	cb 2e       	mov	r12, r27
   126a0:	b8 e1       	ldi	r27, 0x18	; 24
   126a2:	db 2e       	mov	r13, r27
   126a4:	5d c0       	rjmp	.+186    	; 0x12760 <FMenuChangeMOP+0x29c>
   126a6:	8a 9d       	mul	r24, r10
   126a8:	b0 01       	movw	r22, r0
   126aa:	8b 9d       	mul	r24, r11
   126ac:	70 0d       	add	r23, r0
   126ae:	9a 9d       	mul	r25, r10
   126b0:	70 0d       	add	r23, r0
   126b2:	11 24       	eor	r1, r1
   126b4:	67 5c       	subi	r22, 0xC7	; 199
   126b6:	7e 4f       	sbci	r23, 0xFE	; 254
   126b8:	c8 01       	movw	r24, r16
   126ba:	4b e0       	ldi	r20, 0x0B	; 11
   126bc:	50 e0       	ldi	r21, 0x00	; 0
   126be:	27 e9       	ldi	r18, 0x97	; 151
   126c0:	32 e1       	ldi	r19, 0x12	; 18
   126c2:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   126c6:	e0 e0       	ldi	r30, 0x00	; 0
   126c8:	f0 e0       	ldi	r31, 0x00	; 0
   126ca:	0b 30       	cpi	r16, 0x0B	; 11
   126cc:	11 05       	cpc	r17, r1
   126ce:	10 f4       	brcc	.+4      	; 0x126d4 <FMenuChangeMOP+0x210>
   126d0:	e1 e0       	ldi	r30, 0x01	; 1
   126d2:	f0 e0       	ldi	r31, 0x00	; 0
   126d4:	80 81       	ld	r24, Z
   126d6:	88 23       	and	r24, r24
   126d8:	d1 f1       	breq	.+116    	; 0x1274e <FMenuChangeMOP+0x28a>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   126da:	ad b7       	in	r26, 0x3d	; 61
   126dc:	be b7       	in	r27, 0x3e	; 62
   126de:	18 97       	sbiw	r26, 0x08	; 8
   126e0:	0f b6       	in	r0, 0x3f	; 63
   126e2:	f8 94       	cli
   126e4:	be bf       	out	0x3e, r27	; 62
   126e6:	0f be       	out	0x3f, r0	; 63
   126e8:	ad bf       	out	0x3d, r26	; 61
   126ea:	ed b7       	in	r30, 0x3d	; 61
   126ec:	fe b7       	in	r31, 0x3e	; 62
   126ee:	31 96       	adiw	r30, 0x01	; 1
   126f0:	12 96       	adiw	r26, 0x02	; 2
   126f2:	fc 92       	st	X, r15
   126f4:	ee 92       	st	-X, r14
   126f6:	11 97       	sbiw	r26, 0x01	; 1
   126f8:	d3 82       	std	Z+3, r13	; 0x03
   126fa:	c2 82       	std	Z+2, r12	; 0x02
   126fc:	80 91 4e 03 	lds	r24, 0x034E
   12700:	90 91 4f 03 	lds	r25, 0x034F
   12704:	01 96       	adiw	r24, 0x01	; 1
   12706:	95 83       	std	Z+5, r25	; 0x05
   12708:	84 83       	std	Z+4, r24	; 0x04
   1270a:	17 83       	std	Z+7, r17	; 0x07
   1270c:	06 83       	std	Z+6, r16	; 0x06
   1270e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   12712:	20 91 4e 03 	lds	r18, 0x034E
   12716:	30 91 4f 03 	lds	r19, 0x034F
   1271a:	ed b7       	in	r30, 0x3d	; 61
   1271c:	fe b7       	in	r31, 0x3e	; 62
   1271e:	38 96       	adiw	r30, 0x08	; 8
   12720:	0f b6       	in	r0, 0x3f	; 63
   12722:	f8 94       	cli
   12724:	fe bf       	out	0x3e, r31	; 62
   12726:	0f be       	out	0x3f, r0	; 63
   12728:	ed bf       	out	0x3d, r30	; 61
   1272a:	82 2f       	mov	r24, r18
   1272c:	81 70       	andi	r24, 0x01	; 1
   1272e:	36 95       	lsr	r19
   12730:	27 95       	ror	r18
   12732:	b9 01       	movw	r22, r18
   12734:	66 0f       	add	r22, r22
   12736:	77 1f       	adc	r23, r23
   12738:	62 0f       	add	r22, r18
   1273a:	73 1f       	adc	r23, r19
   1273c:	66 0f       	add	r22, r22
   1273e:	77 1f       	adc	r23, r23
   12740:	66 0f       	add	r22, r22
   12742:	77 1f       	adc	r23, r23
   12744:	6f 5f       	subi	r22, 0xFF	; 255
   12746:	8e 5f       	subi	r24, 0xFE	; 254
   12748:	a7 01       	movw	r20, r14
   1274a:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   1274e:	80 91 4e 03 	lds	r24, 0x034E
   12752:	90 91 4f 03 	lds	r25, 0x034F
   12756:	01 96       	adiw	r24, 0x01	; 1
   12758:	90 93 4f 03 	sts	0x034F, r25
   1275c:	80 93 4e 03 	sts	0x034E, r24
   12760:	80 91 4e 03 	lds	r24, 0x034E
   12764:	90 91 4f 03 	lds	r25, 0x034F
   12768:	84 30       	cpi	r24, 0x04	; 4
   1276a:	91 05       	cpc	r25, r1
   1276c:	08 f4       	brcc	.+2      	; 0x12770 <FMenuChangeMOP+0x2ac>
   1276e:	9b cf       	rjmp	.-202    	; 0x126a6 <FMenuChangeMOP+0x1e2>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   12770:	84 e0       	ldi	r24, 0x04	; 4
   12772:	61 e0       	ldi	r22, 0x01	; 1
   12774:	4d e4       	ldi	r20, 0x4D	; 77
   12776:	58 e1       	ldi	r21, 0x18	; 24
   12778:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   1277c:	8c e0       	ldi	r24, 0x0C	; 12
   1277e:	99 c0       	rjmp	.+306    	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   12780:	81 e0       	ldi	r24, 0x01	; 1
   12782:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   12786:	80 93 5b 03 	sts	0x035B, r24
		  KeyChar=_key_btn(KeyPressed);
   1278a:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   1278e:	80 93 5c 03 	sts	0x035C, r24
          if ((KeyChar>='1')&&(KeyChar<='4')){
   12792:	81 53       	subi	r24, 0x31	; 49
   12794:	84 30       	cpi	r24, 0x04	; 4
   12796:	28 f4       	brcc	.+10     	; 0x127a2 <FMenuChangeMOP+0x2de>
		      BankIdx=KeyChar-'1';
   12798:	80 93 4d 03 	sts	0x034D, r24
			  stChangeMOP=cmSelectFIP;
   1279c:	89 e0       	ldi	r24, 0x09	; 9
   1279e:	80 93 60 03 	sts	0x0360, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   127a2:	80 91 5b 03 	lds	r24, 0x035B
   127a6:	87 3e       	cpi	r24, 0xE7	; 231
   127a8:	09 f0       	breq	.+2      	; 0x127ac <FMenuChangeMOP+0x2e8>
   127aa:	b1 c2       	rjmp	.+1378   	; 0x12d0e <FMenuChangeMOP+0x84a>
   127ac:	81 e0       	ldi	r24, 0x01	; 1
   127ae:	81 c0       	rjmp	.+258    	; 0x128b2 <FMenuChangeMOP+0x3ee>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   127b0:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   127b4:	65 e0       	ldi	r22, 0x05	; 5
   127b6:	e6 2e       	mov	r14, r22
   127b8:	f1 2c       	mov	r15, r1
   127ba:	ec 0e       	add	r14, r28
   127bc:	fd 1e       	adc	r15, r29
   127be:	60 91 4d 03 	lds	r22, 0x034D
   127c2:	8b e0       	ldi	r24, 0x0B	; 11
   127c4:	68 9f       	mul	r22, r24
   127c6:	b0 01       	movw	r22, r0
   127c8:	11 24       	eor	r1, r1
   127ca:	67 5c       	subi	r22, 0xC7	; 199
   127cc:	7e 4f       	sbci	r23, 0xFE	; 254
   127ce:	c7 01       	movw	r24, r14
   127d0:	4b e0       	ldi	r20, 0x0B	; 11
   127d2:	50 e0       	ldi	r21, 0x00	; 0
   127d4:	27 e9       	ldi	r18, 0x97	; 151
   127d6:	32 e1       	ldi	r19, 0x12	; 18
   127d8:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   127dc:	00 d0       	rcall	.+0      	; 0x127de <FMenuChangeMOP+0x31a>
   127de:	00 d0       	rcall	.+0      	; 0x127e0 <FMenuChangeMOP+0x31c>
   127e0:	00 d0       	rcall	.+0      	; 0x127e2 <FMenuChangeMOP+0x31e>
   127e2:	ed b7       	in	r30, 0x3d	; 61
   127e4:	fe b7       	in	r31, 0x3e	; 62
   127e6:	31 96       	adiw	r30, 0x01	; 1
   127e8:	8e 01       	movw	r16, r28
   127ea:	00 5f       	subi	r16, 0xF0	; 240
   127ec:	1f 4f       	sbci	r17, 0xFF	; 255
   127ee:	ad b7       	in	r26, 0x3d	; 61
   127f0:	be b7       	in	r27, 0x3e	; 62
   127f2:	12 96       	adiw	r26, 0x02	; 2
   127f4:	1c 93       	st	X, r17
   127f6:	0e 93       	st	-X, r16
   127f8:	11 97       	sbiw	r26, 0x01	; 1
   127fa:	8a e4       	ldi	r24, 0x4A	; 74
   127fc:	98 e1       	ldi	r25, 0x18	; 24
   127fe:	93 83       	std	Z+3, r25	; 0x03
   12800:	82 83       	std	Z+2, r24	; 0x02
   12802:	f5 82       	std	Z+5, r15	; 0x05
   12804:	e4 82       	std	Z+4, r14	; 0x04
   12806:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   1280a:	ed b7       	in	r30, 0x3d	; 61
   1280c:	fe b7       	in	r31, 0x3e	; 62
   1280e:	36 96       	adiw	r30, 0x06	; 6
   12810:	0f b6       	in	r0, 0x3f	; 63
   12812:	f8 94       	cli
   12814:	fe bf       	out	0x3e, r31	; 62
   12816:	0f be       	out	0x3f, r0	; 63
   12818:	ed bf       	out	0x3d, r30	; 61
   1281a:	81 e0       	ldi	r24, 0x01	; 1
   1281c:	61 e0       	ldi	r22, 0x01	; 1
   1281e:	a8 01       	movw	r20, r16
   12820:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   12824:	82 e0       	ldi	r24, 0x02	; 2
   12826:	61 e0       	ldi	r22, 0x01	; 1
   12828:	4a e3       	ldi	r20, 0x3A	; 58
   1282a:	58 e1       	ldi	r21, 0x18	; 24
   1282c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12830:	84 e0       	ldi	r24, 0x04	; 4
   12832:	61 e0       	ldi	r22, 0x01	; 1
   12834:	45 e2       	ldi	r20, 0x25	; 37
   12836:	58 e1       	ldi	r21, 0x18	; 24
   12838:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   1283c:	8d e0       	ldi	r24, 0x0D	; 13
   1283e:	39 c0       	rjmp	.+114    	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
	 case cmInputBankSurcharge:
	      uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
   12840:	82 e0       	ldi	r24, 0x02	; 2
   12842:	62 e0       	ldi	r22, 0x02	; 2
   12844:	4e e0       	ldi	r20, 0x0E	; 14
   12846:	20 e5       	ldi	r18, 0x50	; 80
   12848:	33 e0       	ldi	r19, 0x03	; 3
   1284a:	04 e6       	ldi	r16, 0x64	; 100
   1284c:	10 e0       	ldi	r17, 0x00	; 0
   1284e:	53 e0       	ldi	r21, 0x03	; 3
   12850:	e5 2e       	mov	r14, r21
   12852:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
   12856:	80 93 4c 03 	sts	0x034C, r24
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   1285a:	83 30       	cpi	r24, 0x03	; 3
   1285c:	09 f4       	brne	.+2      	; 0x12860 <FMenuChangeMOP+0x39c>
   1285e:	cb c0       	rjmp	.+406    	; 0x129f6 <FMenuChangeMOP+0x532>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   12860:	81 30       	cpi	r24, 0x01	; 1
   12862:	11 f4       	brne	.+4      	; 0x12868 <FMenuChangeMOP+0x3a4>
   12864:	8b e0       	ldi	r24, 0x0B	; 11
   12866:	25 c0       	rjmp	.+74     	; 0x128b2 <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12868:	84 30       	cpi	r24, 0x04	; 4
   1286a:	21 f4       	brne	.+8      	; 0x12874 <FMenuChangeMOP+0x3b0>
   1286c:	61 e0       	ldi	r22, 0x01	; 1
   1286e:	40 e1       	ldi	r20, 0x10	; 16
   12870:	58 e1       	ldi	r21, 0x18	; 24
   12872:	07 c0       	rjmp	.+14     	; 0x12882 <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12874:	85 30       	cpi	r24, 0x05	; 5
   12876:	09 f0       	breq	.+2      	; 0x1287a <FMenuChangeMOP+0x3b6>
   12878:	4a c2       	rjmp	.+1172   	; 0x12d0e <FMenuChangeMOP+0x84a>
   1287a:	84 e0       	ldi	r24, 0x04	; 4
   1287c:	61 e0       	ldi	r22, 0x01	; 1
   1287e:	4b ef       	ldi	r20, 0xFB	; 251
   12880:	57 e1       	ldi	r21, 0x17	; 23
   12882:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   12886:	43 c2       	rjmp	.+1158   	; 0x12d0e <FMenuChangeMOP+0x84a>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   12888:	80 91 e5 01 	lds	r24, 0x01E5
   1288c:	82 30       	cpi	r24, 0x02	; 2
   1288e:	61 f0       	breq	.+24     	; 0x128a8 <FMenuChangeMOP+0x3e4>
   12890:	83 30       	cpi	r24, 0x03	; 3
   12892:	20 f4       	brcc	.+8      	; 0x1289c <FMenuChangeMOP+0x3d8>
   12894:	81 30       	cpi	r24, 0x01	; 1
   12896:	09 f0       	breq	.+2      	; 0x1289a <FMenuChangeMOP+0x3d6>
   12898:	3a c2       	rjmp	.+1140   	; 0x12d0e <FMenuChangeMOP+0x84a>
   1289a:	0a c0       	rjmp	.+20     	; 0x128b0 <FMenuChangeMOP+0x3ec>
   1289c:	83 30       	cpi	r24, 0x03	; 3
   1289e:	31 f0       	breq	.+12     	; 0x128ac <FMenuChangeMOP+0x3e8>
   128a0:	84 30       	cpi	r24, 0x04	; 4
   128a2:	09 f0       	breq	.+2      	; 0x128a6 <FMenuChangeMOP+0x3e2>
   128a4:	34 c2       	rjmp	.+1128   	; 0x12d0e <FMenuChangeMOP+0x84a>
   128a6:	04 c0       	rjmp	.+8      	; 0x128b0 <FMenuChangeMOP+0x3ec>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   128a8:	81 e1       	ldi	r24, 0x11	; 17
   128aa:	03 c0       	rjmp	.+6      	; 0x128b2 <FMenuChangeMOP+0x3ee>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   128ac:	85 e1       	ldi	r24, 0x15	; 21
   128ae:	01 c0       	rjmp	.+2      	; 0x128b2 <FMenuChangeMOP+0x3ee>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   128b0:	82 e1       	ldi	r24, 0x12	; 18
   128b2:	80 93 60 03 	sts	0x0360, r24
   128b6:	2b c2       	rjmp	.+1110   	; 0x12d0e <FMenuChangeMOP+0x84a>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   128b8:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   128bc:	81 e0       	ldi	r24, 0x01	; 1
   128be:	61 e0       	ldi	r22, 0x01	; 1
   128c0:	4c ee       	ldi	r20, 0xEC	; 236
   128c2:	57 e1       	ldi	r21, 0x17	; 23
   128c4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   128c8:	00 d0       	rcall	.+0      	; 0x128ca <FMenuChangeMOP+0x406>
   128ca:	00 d0       	rcall	.+0      	; 0x128cc <FMenuChangeMOP+0x408>
   128cc:	00 d0       	rcall	.+0      	; 0x128ce <FMenuChangeMOP+0x40a>
   128ce:	ed b7       	in	r30, 0x3d	; 61
   128d0:	fe b7       	in	r31, 0x3e	; 62
   128d2:	31 96       	adiw	r30, 0x01	; 1
   128d4:	8e 01       	movw	r16, r28
   128d6:	00 5f       	subi	r16, 0xF0	; 240
   128d8:	1f 4f       	sbci	r17, 0xFF	; 255
   128da:	ad b7       	in	r26, 0x3d	; 61
   128dc:	be b7       	in	r27, 0x3e	; 62
   128de:	12 96       	adiw	r26, 0x02	; 2
   128e0:	1c 93       	st	X, r17
   128e2:	0e 93       	st	-X, r16
   128e4:	11 97       	sbiw	r26, 0x01	; 1
   128e6:	86 ee       	ldi	r24, 0xE6	; 230
   128e8:	97 e1       	ldi	r25, 0x17	; 23
   128ea:	93 83       	std	Z+3, r25	; 0x03
   128ec:	82 83       	std	Z+2, r24	; 0x02
   128ee:	83 ec       	ldi	r24, 0xC3	; 195
   128f0:	99 e0       	ldi	r25, 0x09	; 9
   128f2:	95 83       	std	Z+5, r25	; 0x05
   128f4:	84 83       	std	Z+4, r24	; 0x04
   128f6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   128fa:	ed b7       	in	r30, 0x3d	; 61
   128fc:	fe b7       	in	r31, 0x3e	; 62
   128fe:	36 96       	adiw	r30, 0x06	; 6
   12900:	0f b6       	in	r0, 0x3f	; 63
   12902:	f8 94       	cli
   12904:	fe bf       	out	0x3e, r31	; 62
   12906:	0f be       	out	0x3f, r0	; 63
   12908:	ed bf       	out	0x3d, r30	; 61
   1290a:	82 e0       	ldi	r24, 0x02	; 2
   1290c:	61 e0       	ldi	r22, 0x01	; 1
   1290e:	a8 01       	movw	r20, r16
   12910:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   12914:	84 e0       	ldi	r24, 0x04	; 4
   12916:	61 e0       	ldi	r22, 0x01	; 1
   12918:	43 ed       	ldi	r20, 0xD3	; 211
   1291a:	57 e1       	ldi	r21, 0x17	; 23
   1291c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  IsRFIDDetected=False;
   12920:	10 92 c4 01 	sts	0x01C4, r1
          stChangeMOP=cmRFIDCardInput;
   12924:	83 e1       	ldi	r24, 0x13	; 19
   12926:	c5 cf       	rjmp	.-118    	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   12928:	81 e0       	ldi	r24, 0x01	; 1
   1292a:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   1292e:	80 93 5b 03 	sts	0x035B, r24
		  KeyChar=_key_btn(KeyPressed);
   12932:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   12936:	80 93 5c 03 	sts	0x035C, r24
		  if (KeyPressed==_KEY_ENTER){
   1293a:	80 91 5b 03 	lds	r24, 0x035B
   1293e:	87 3b       	cpi	r24, 0xB7	; 183
   12940:	11 f4       	brne	.+4      	; 0x12946 <FMenuChangeMOP+0x482>
		      stChangeMOP=cmExitChangeMOP;
   12942:	8c e1       	ldi	r24, 0x1C	; 28
   12944:	03 c0       	rjmp	.+6      	; 0x1294c <FMenuChangeMOP+0x488>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   12946:	87 3e       	cpi	r24, 0xE7	; 231
   12948:	19 f4       	brne	.+6      	; 0x12950 <FMenuChangeMOP+0x48c>
   		      stChangeMOP=cmSelectFIP;
   1294a:	89 e0       	ldi	r24, 0x09	; 9
   1294c:	80 93 60 03 	sts	0x0360, r24
			 }
          if (IsRFIDDetected==True){
   12950:	80 91 c4 01 	lds	r24, 0x01C4
   12954:	81 30       	cpi	r24, 0x01	; 1
   12956:	09 f0       	breq	.+2      	; 0x1295a <FMenuChangeMOP+0x496>
   12958:	da c1       	rjmp	.+948    	; 0x12d0e <FMenuChangeMOP+0x84a>
		      IsRFIDDetected=False;
   1295a:	10 92 c4 01 	sts	0x01C4, r1
			   stChangeMOP=cmProsesRFID;
   1295e:	84 e1       	ldi	r24, 0x14	; 20
   12960:	a8 cf       	rjmp	.-176    	; 0x128b2 <FMenuChangeMOP+0x3ee>
   12962:	20 e0       	ldi	r18, 0x00	; 0
   12964:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12966:	f9 01       	movw	r30, r18
   12968:	e4 57       	subi	r30, 0x74	; 116
   1296a:	f2 4f       	sbci	r31, 0xF2	; 242
   1296c:	d9 01       	movw	r26, r18
   1296e:	a9 5a       	subi	r26, 0xA9	; 169
   12970:	b1 4f       	sbci	r27, 0xF1	; 241
   12972:	8c 91       	ld	r24, X
   12974:	80 83       	st	Z, r24
   12976:	2f 5f       	subi	r18, 0xFF	; 255
   12978:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   1297a:	28 30       	cpi	r18, 0x08	; 8
   1297c:	31 05       	cpc	r19, r1
   1297e:	99 f7       	brne	.-26     	; 0x12966 <FMenuChangeMOP+0x4a2>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   12980:	10 92 94 0d 	sts	0x0D94, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   12984:	00 d0       	rcall	.+0      	; 0x12986 <FMenuChangeMOP+0x4c2>
   12986:	00 d0       	rcall	.+0      	; 0x12988 <FMenuChangeMOP+0x4c4>
   12988:	00 d0       	rcall	.+0      	; 0x1298a <FMenuChangeMOP+0x4c6>
   1298a:	ed b7       	in	r30, 0x3d	; 61
   1298c:	fe b7       	in	r31, 0x3e	; 62
   1298e:	31 96       	adiw	r30, 0x01	; 1
   12990:	8e 01       	movw	r16, r28
   12992:	00 5f       	subi	r16, 0xF0	; 240
   12994:	1f 4f       	sbci	r17, 0xFF	; 255
   12996:	ad b7       	in	r26, 0x3d	; 61
   12998:	be b7       	in	r27, 0x3e	; 62
   1299a:	12 96       	adiw	r26, 0x02	; 2
   1299c:	1c 93       	st	X, r17
   1299e:	0e 93       	st	-X, r16
   129a0:	11 97       	sbiw	r26, 0x01	; 1
   129a2:	8d ec       	ldi	r24, 0xCD	; 205
   129a4:	97 e1       	ldi	r25, 0x17	; 23
   129a6:	93 83       	std	Z+3, r25	; 0x03
   129a8:	82 83       	std	Z+2, r24	; 0x02
   129aa:	8c e8       	ldi	r24, 0x8C	; 140
   129ac:	9d e0       	ldi	r25, 0x0D	; 13
   129ae:	95 83       	std	Z+5, r25	; 0x05
   129b0:	84 83       	std	Z+4, r24	; 0x04
   129b2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   129b6:	ed b7       	in	r30, 0x3d	; 61
   129b8:	fe b7       	in	r31, 0x3e	; 62
   129ba:	36 96       	adiw	r30, 0x06	; 6
   129bc:	0f b6       	in	r0, 0x3f	; 63
   129be:	f8 94       	cli
   129c0:	fe bf       	out	0x3e, r31	; 62
   129c2:	0f be       	out	0x3f, r0	; 63
   129c4:	ed bf       	out	0x3d, r30	; 61
   129c6:	82 e0       	ldi	r24, 0x02	; 2
   129c8:	61 e0       	ldi	r22, 0x01	; 1
   129ca:	a8 01       	movw	r20, r16
   129cc:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   129d0:	83 e0       	ldi	r24, 0x03	; 3
   129d2:	61 e0       	ldi	r22, 0x01	; 1
   129d4:	46 ec       	ldi	r20, 0xC6	; 198
   129d6:	57 e1       	ldi	r21, 0x17	; 23
   129d8:	0c c0       	rjmp	.+24     	; 0x129f2 <FMenuChangeMOP+0x52e>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   129da:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   129de:	81 e0       	ldi	r24, 0x01	; 1
   129e0:	61 e0       	ldi	r22, 0x01	; 1
   129e2:	48 eb       	ldi	r20, 0xB8	; 184
   129e4:	57 e1       	ldi	r21, 0x17	; 23
   129e6:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   129ea:	83 e0       	ldi	r24, 0x03	; 3
   129ec:	61 e0       	ldi	r22, 0x01	; 1
   129ee:	41 eb       	ldi	r20, 0xB1	; 177
   129f0:	57 e1       	ldi	r21, 0x17	; 23
   129f2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stChangeMOP=cmGenerateData;
   129f6:	86 e1       	ldi	r24, 0x16	; 22
   129f8:	5c cf       	rjmp	.-328    	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
   129fa:	e4 e9       	ldi	r30, 0x94	; 148
   129fc:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   129fe:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12a00:	8e e0       	ldi	r24, 0x0E	; 14
   12a02:	e9 3a       	cpi	r30, 0xA9	; 169
   12a04:	f8 07       	cpc	r31, r24
   12a06:	d9 f7       	brne	.-10     	; 0x129fe <FMenuChangeMOP+0x53a>
   12a08:	e1 ea       	ldi	r30, 0xA1	; 161
   12a0a:	fd e0       	ldi	r31, 0x0D	; 13
	     strMemory[i]=data;
   12a0c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12a0e:	9d e0       	ldi	r25, 0x0D	; 13
   12a10:	e6 3b       	cpi	r30, 0xB6	; 182
   12a12:	f9 07       	cpc	r31, r25
   12a14:	d9 f7       	brne	.-10     	; 0x12a0c <FMenuChangeMOP+0x548>
   12a16:	ed ea       	ldi	r30, 0xAD	; 173
   12a18:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
   12a1a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12a1c:	aa e0       	ldi	r26, 0x0A	; 10
   12a1e:	e2 3c       	cpi	r30, 0xC2	; 194
   12a20:	fa 07       	cpc	r31, r26
   12a22:	d9 f7       	brne	.-10     	; 0x12a1a <FMenuChangeMOP+0x556>
   12a24:	2a ea       	ldi	r18, 0xAA	; 170
   12a26:	e2 2e       	mov	r14, r18
   12a28:	25 e0       	ldi	r18, 0x05	; 5
   12a2a:	f2 2e       	mov	r15, r18
	     strMemory[i]=data;
   12a2c:	f7 01       	movw	r30, r14
   12a2e:	11 92       	st	Z+, r1
   12a30:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12a32:	ff eb       	ldi	r31, 0xBF	; 191
   12a34:	ef 16       	cp	r14, r31
   12a36:	f5 e0       	ldi	r31, 0x05	; 5
   12a38:	ff 06       	cpc	r15, r31
   12a3a:	c1 f7       	brne	.-16     	; 0x12a2c <FMenuChangeMOP+0x568>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   12a3c:	80 91 e5 01 	lds	r24, 0x01E5
   12a40:	82 30       	cpi	r24, 0x02	; 2
   12a42:	f1 f0       	breq	.+60     	; 0x12a80 <FMenuChangeMOP+0x5bc>
   12a44:	83 30       	cpi	r24, 0x03	; 3
   12a46:	20 f4       	brcc	.+8      	; 0x12a50 <FMenuChangeMOP+0x58c>
   12a48:	81 30       	cpi	r24, 0x01	; 1
   12a4a:	09 f0       	breq	.+2      	; 0x12a4e <FMenuChangeMOP+0x58a>
   12a4c:	ad c0       	rjmp	.+346    	; 0x12ba8 <FMenuChangeMOP+0x6e4>
   12a4e:	07 c0       	rjmp	.+14     	; 0x12a5e <FMenuChangeMOP+0x59a>
   12a50:	83 30       	cpi	r24, 0x03	; 3
   12a52:	09 f4       	brne	.+2      	; 0x12a56 <FMenuChangeMOP+0x592>
   12a54:	64 c0       	rjmp	.+200    	; 0x12b1e <FMenuChangeMOP+0x65a>
   12a56:	84 30       	cpi	r24, 0x04	; 4
   12a58:	09 f0       	breq	.+2      	; 0x12a5c <FMenuChangeMOP+0x598>
   12a5a:	a6 c0       	rjmp	.+332    	; 0x12ba8 <FMenuChangeMOP+0x6e4>
   12a5c:	75 c0       	rjmp	.+234    	; 0x12b48 <FMenuChangeMOP+0x684>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   12a5e:	00 d0       	rcall	.+0      	; 0x12a60 <FMenuChangeMOP+0x59c>
   12a60:	00 d0       	rcall	.+0      	; 0x12a62 <FMenuChangeMOP+0x59e>
   12a62:	00 d0       	rcall	.+0      	; 0x12a64 <FMenuChangeMOP+0x5a0>
   12a64:	ed b7       	in	r30, 0x3d	; 61
   12a66:	fe b7       	in	r31, 0x3e	; 62
   12a68:	31 96       	adiw	r30, 0x01	; 1
   12a6a:	84 e9       	ldi	r24, 0x94	; 148
   12a6c:	9e e0       	ldi	r25, 0x0E	; 14
   12a6e:	ad b7       	in	r26, 0x3d	; 61
   12a70:	be b7       	in	r27, 0x3e	; 62
   12a72:	12 96       	adiw	r26, 0x02	; 2
   12a74:	9c 93       	st	X, r25
   12a76:	8e 93       	st	-X, r24
   12a78:	11 97       	sbiw	r26, 0x01	; 1
   12a7a:	8e ea       	ldi	r24, 0xAE	; 174
   12a7c:	97 e1       	ldi	r25, 0x17	; 23
   12a7e:	84 c0       	rjmp	.+264    	; 0x12b88 <FMenuChangeMOP+0x6c4>
   12a80:	8e 01       	movw	r16, r28
   12a82:	0b 5f       	subi	r16, 0xFB	; 251
   12a84:	1f 4f       	sbci	r17, 0xFF	; 255
   12a86:	60 91 4d 03 	lds	r22, 0x034D
   12a8a:	8b e0       	ldi	r24, 0x0B	; 11
   12a8c:	68 9f       	mul	r22, r24
   12a8e:	b0 01       	movw	r22, r0
   12a90:	11 24       	eor	r1, r1
   12a92:	67 5c       	subi	r22, 0xC7	; 199
   12a94:	7e 4f       	sbci	r23, 0xFE	; 254
   12a96:	c8 01       	movw	r24, r16
   12a98:	4b e0       	ldi	r20, 0x0B	; 11
   12a9a:	50 e0       	ldi	r21, 0x00	; 0
   12a9c:	27 e9       	ldi	r18, 0x97	; 151
   12a9e:	32 e1       	ldi	r19, 0x12	; 18
   12aa0:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12aa4:	00 d0       	rcall	.+0      	; 0x12aa6 <FMenuChangeMOP+0x5e2>
   12aa6:	00 d0       	rcall	.+0      	; 0x12aa8 <FMenuChangeMOP+0x5e4>
   12aa8:	00 d0       	rcall	.+0      	; 0x12aaa <FMenuChangeMOP+0x5e6>
   12aaa:	ed b7       	in	r30, 0x3d	; 61
   12aac:	fe b7       	in	r31, 0x3e	; 62
   12aae:	31 96       	adiw	r30, 0x01	; 1
   12ab0:	ce 01       	movw	r24, r28
   12ab2:	40 96       	adiw	r24, 0x10	; 16
   12ab4:	ad b7       	in	r26, 0x3d	; 61
   12ab6:	be b7       	in	r27, 0x3e	; 62
   12ab8:	12 96       	adiw	r26, 0x02	; 2
   12aba:	9c 93       	st	X, r25
   12abc:	8e 93       	st	-X, r24
   12abe:	11 97       	sbiw	r26, 0x01	; 1
   12ac0:	8b ea       	ldi	r24, 0xAB	; 171
   12ac2:	97 e1       	ldi	r25, 0x17	; 23
   12ac4:	93 83       	std	Z+3, r25	; 0x03
   12ac6:	82 83       	std	Z+2, r24	; 0x02
   12ac8:	15 83       	std	Z+5, r17	; 0x05
   12aca:	04 83       	std	Z+4, r16	; 0x04
   12acc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   12ad0:	ed b7       	in	r30, 0x3d	; 61
   12ad2:	fe b7       	in	r31, 0x3e	; 62
   12ad4:	31 96       	adiw	r30, 0x01	; 1
   12ad6:	84 e9       	ldi	r24, 0x94	; 148
   12ad8:	9e e0       	ldi	r25, 0x0E	; 14
   12ada:	ad b7       	in	r26, 0x3d	; 61
   12adc:	be b7       	in	r27, 0x3e	; 62
   12ade:	12 96       	adiw	r26, 0x02	; 2
   12ae0:	9c 93       	st	X, r25
   12ae2:	8e 93       	st	-X, r24
   12ae4:	11 97       	sbiw	r26, 0x01	; 1
   12ae6:	88 ea       	ldi	r24, 0xA8	; 168
   12ae8:	97 e1       	ldi	r25, 0x17	; 23
   12aea:	93 83       	std	Z+3, r25	; 0x03
   12aec:	82 83       	std	Z+2, r24	; 0x02
   12aee:	15 83       	std	Z+5, r17	; 0x05
   12af0:	04 83       	std	Z+4, r16	; 0x04
   12af2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   12af6:	ed b7       	in	r30, 0x3d	; 61
   12af8:	fe b7       	in	r31, 0x3e	; 62
   12afa:	31 96       	adiw	r30, 0x01	; 1
   12afc:	8b ee       	ldi	r24, 0xEB	; 235
   12afe:	9f ef       	ldi	r25, 0xFF	; 255
   12b00:	e8 0e       	add	r14, r24
   12b02:	f9 1e       	adc	r15, r25
   12b04:	ad b7       	in	r26, 0x3d	; 61
   12b06:	be b7       	in	r27, 0x3e	; 62
   12b08:	12 96       	adiw	r26, 0x02	; 2
   12b0a:	fc 92       	st	X, r15
   12b0c:	ee 92       	st	-X, r14
   12b0e:	11 97       	sbiw	r26, 0x01	; 1
   12b10:	85 ea       	ldi	r24, 0xA5	; 165
   12b12:	97 e1       	ldi	r25, 0x17	; 23
   12b14:	93 83       	std	Z+3, r25	; 0x03
   12b16:	82 83       	std	Z+2, r24	; 0x02
   12b18:	ce 01       	movw	r24, r28
   12b1a:	01 96       	adiw	r24, 0x01	; 1
   12b1c:	39 c0       	rjmp	.+114    	; 0x12b90 <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   12b1e:	00 d0       	rcall	.+0      	; 0x12b20 <FMenuChangeMOP+0x65c>
   12b20:	00 d0       	rcall	.+0      	; 0x12b22 <FMenuChangeMOP+0x65e>
   12b22:	00 d0       	rcall	.+0      	; 0x12b24 <FMenuChangeMOP+0x660>
   12b24:	ed b7       	in	r30, 0x3d	; 61
   12b26:	fe b7       	in	r31, 0x3e	; 62
   12b28:	31 96       	adiw	r30, 0x01	; 1
   12b2a:	84 e9       	ldi	r24, 0x94	; 148
   12b2c:	9e e0       	ldi	r25, 0x0E	; 14
   12b2e:	ad b7       	in	r26, 0x3d	; 61
   12b30:	be b7       	in	r27, 0x3e	; 62
   12b32:	12 96       	adiw	r26, 0x02	; 2
   12b34:	9c 93       	st	X, r25
   12b36:	8e 93       	st	-X, r24
   12b38:	11 97       	sbiw	r26, 0x01	; 1
   12b3a:	82 ea       	ldi	r24, 0xA2	; 162
   12b3c:	97 e1       	ldi	r25, 0x17	; 23
   12b3e:	93 83       	std	Z+3, r25	; 0x03
   12b40:	82 83       	std	Z+2, r24	; 0x02
   12b42:	82 e4       	ldi	r24, 0x42	; 66
   12b44:	9e e0       	ldi	r25, 0x0E	; 14
   12b46:	24 c0       	rjmp	.+72     	; 0x12b90 <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   12b48:	00 d0       	rcall	.+0      	; 0x12b4a <FMenuChangeMOP+0x686>
   12b4a:	00 d0       	rcall	.+0      	; 0x12b4c <FMenuChangeMOP+0x688>
   12b4c:	84 e9       	ldi	r24, 0x94	; 148
   12b4e:	9e e0       	ldi	r25, 0x0E	; 14
   12b50:	ad b7       	in	r26, 0x3d	; 61
   12b52:	be b7       	in	r27, 0x3e	; 62
   12b54:	12 96       	adiw	r26, 0x02	; 2
   12b56:	9c 93       	st	X, r25
   12b58:	8e 93       	st	-X, r24
   12b5a:	11 97       	sbiw	r26, 0x01	; 1
   12b5c:	88 e9       	ldi	r24, 0x98	; 152
   12b5e:	97 e1       	ldi	r25, 0x17	; 23
   12b60:	14 96       	adiw	r26, 0x04	; 4
   12b62:	9c 93       	st	X, r25
   12b64:	8e 93       	st	-X, r24
   12b66:	13 97       	sbiw	r26, 0x03	; 3
   12b68:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   12b6c:	00 d0       	rcall	.+0      	; 0x12b6e <FMenuChangeMOP+0x6aa>
   12b6e:	ed b7       	in	r30, 0x3d	; 61
   12b70:	fe b7       	in	r31, 0x3e	; 62
   12b72:	31 96       	adiw	r30, 0x01	; 1
   12b74:	81 ea       	ldi	r24, 0xA1	; 161
   12b76:	9d e0       	ldi	r25, 0x0D	; 13
   12b78:	ad b7       	in	r26, 0x3d	; 61
   12b7a:	be b7       	in	r27, 0x3e	; 62
   12b7c:	12 96       	adiw	r26, 0x02	; 2
   12b7e:	9c 93       	st	X, r25
   12b80:	8e 93       	st	-X, r24
   12b82:	11 97       	sbiw	r26, 0x01	; 1
   12b84:	85 e9       	ldi	r24, 0x95	; 149
   12b86:	97 e1       	ldi	r25, 0x17	; 23
   12b88:	93 83       	std	Z+3, r25	; 0x03
   12b8a:	82 83       	std	Z+2, r24	; 0x02
   12b8c:	8c e8       	ldi	r24, 0x8C	; 140
   12b8e:	9d e0       	ldi	r25, 0x0D	; 13
   12b90:	95 83       	std	Z+5, r25	; 0x05
   12b92:	84 83       	std	Z+4, r24	; 0x04
   12b94:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   12b98:	ed b7       	in	r30, 0x3d	; 61
   12b9a:	fe b7       	in	r31, 0x3e	; 62
   12b9c:	36 96       	adiw	r30, 0x06	; 6
   12b9e:	0f b6       	in	r0, 0x3f	; 63
   12ba0:	f8 94       	cli
   12ba2:	fe bf       	out	0x3e, r31	; 62
   12ba4:	0f be       	out	0x3f, r0	; 63
   12ba6:	ed bf       	out	0x3d, r30	; 61
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
   12ba8:	80 91 e5 01 	lds	r24, 0x01E5
   12bac:	90 e0       	ldi	r25, 0x00	; 0
   12bae:	6a e5       	ldi	r22, 0x5A	; 90
   12bb0:	79 e0       	ldi	r23, 0x09	; 9
   12bb2:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <leadingZero>
		  AddSpaceLead(strRef1,20);
   12bb6:	84 e9       	ldi	r24, 0x94	; 148
   12bb8:	9e e0       	ldi	r25, 0x0E	; 14
   12bba:	64 e1       	ldi	r22, 0x14	; 20
   12bbc:	0e 94 19 2a 	call	0x5432	; 0x5432 <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   12bc0:	81 ea       	ldi	r24, 0xA1	; 161
   12bc2:	9d e0       	ldi	r25, 0x0D	; 13
   12bc4:	64 e1       	ldi	r22, 0x14	; 20
   12bc6:	0e 94 19 2a 	call	0x5432	; 0x5432 <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   12bca:	8d ea       	ldi	r24, 0xAD	; 173
   12bcc:	9a e0       	ldi	r25, 0x0A	; 10
   12bce:	64 e1       	ldi	r22, 0x14	; 20
   12bd0:	0e 94 19 2a 	call	0x5432	; 0x5432 <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   12bd4:	8a ea       	ldi	r24, 0xAA	; 170
   12bd6:	95 e0       	ldi	r25, 0x05	; 5
   12bd8:	64 e1       	ldi	r22, 0x14	; 20
   12bda:	0e 94 19 2a 	call	0x5432	; 0x5432 <AddSpaceLead>
		  iWait=0;
   12bde:	10 92 5d 03 	sts	0x035D, r1
		  IsMessage09=False;
   12be2:	10 92 d0 01 	sts	0x01D0, r1
		  stChangeMOP=cmSendMessage32;	      
   12be6:	87 e1       	ldi	r24, 0x17	; 23
   12be8:	64 ce       	rjmp	.-824    	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   12bea:	0e 94 09 50 	call	0xa012	; 0xa012 <sendMessage32>
		  iLoop=0;
   12bee:	10 92 4f 03 	sts	0x034F, r1
   12bf2:	10 92 4e 03 	sts	0x034E, r1
		  iPos=0;
   12bf6:	10 92 5e 03 	sts	0x035E, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   12bfa:	83 e0       	ldi	r24, 0x03	; 3
   12bfc:	61 e0       	ldi	r22, 0x01	; 1
   12bfe:	49 e8       	ldi	r20, 0x89	; 137
   12c00:	57 e1       	ldi	r21, 0x17	; 23
   12c02:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   12c06:	88 e1       	ldi	r24, 0x18	; 24
   12c08:	54 ce       	rjmp	.-856    	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   12c0a:	80 91 4e 03 	lds	r24, 0x034E
   12c0e:	90 91 4f 03 	lds	r25, 0x034F
   12c12:	01 96       	adiw	r24, 0x01	; 1
   12c14:	90 93 4f 03 	sts	0x034F, r25
   12c18:	80 93 4e 03 	sts	0x034E, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   12c1c:	68 e9       	ldi	r22, 0x98	; 152
   12c1e:	7a e3       	ldi	r23, 0x3A	; 58
   12c20:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
   12c24:	89 2b       	or	r24, r25
   12c26:	19 f5       	brne	.+70     	; 0x12c6e <FMenuChangeMOP+0x7aa>
			 if (iPos<5){
   12c28:	60 91 5e 03 	lds	r22, 0x035E
   12c2c:	65 30       	cpi	r22, 0x05	; 5
   12c2e:	68 f4       	brcc	.+26     	; 0x12c4a <FMenuChangeMOP+0x786>
				 lcd_xy(3,(13+iPos));_lcd('.');
   12c30:	63 5f       	subi	r22, 0xF3	; 243
   12c32:	83 e0       	ldi	r24, 0x03	; 3
   12c34:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   12c38:	8e e2       	ldi	r24, 0x2E	; 46
   12c3a:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
				 iPos++;
   12c3e:	80 91 5e 03 	lds	r24, 0x035E
   12c42:	8f 5f       	subi	r24, 0xFF	; 255
   12c44:	80 93 5e 03 	sts	0x035E, r24
   12c48:	12 c0       	rjmp	.+36     	; 0x12c6e <FMenuChangeMOP+0x7aa>
				}
			 else{
				 iPos=0;
   12c4a:	10 92 5e 03 	sts	0x035E, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   12c4e:	83 e0       	ldi	r24, 0x03	; 3
   12c50:	6d e0       	ldi	r22, 0x0D	; 13
   12c52:	41 e8       	ldi	r20, 0x81	; 129
   12c54:	57 e1       	ldi	r21, 0x17	; 23
   12c56:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   12c5a:	90 91 5d 03 	lds	r25, 0x035D
   12c5e:	95 30       	cpi	r25, 0x05	; 5
   12c60:	18 f4       	brcc	.+6      	; 0x12c68 <FMenuChangeMOP+0x7a4>
   12c62:	87 e1       	ldi	r24, 0x17	; 23
   12c64:	80 93 60 03 	sts	0x0360, r24
				iWait++;
   12c68:	9f 5f       	subi	r25, 0xFF	; 255
   12c6a:	90 93 5d 03 	sts	0x035D, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   12c6e:	80 91 5d 03 	lds	r24, 0x035D
   12c72:	86 30       	cpi	r24, 0x06	; 6
   12c74:	18 f0       	brcs	.+6      	; 0x12c7c <FMenuChangeMOP+0x7b8>
   12c76:	8a e1       	ldi	r24, 0x1A	; 26
   12c78:	80 93 60 03 	sts	0x0360, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   12c7c:	80 91 d0 01 	lds	r24, 0x01D0
   12c80:	81 30       	cpi	r24, 0x01	; 1
   12c82:	19 f4       	brne	.+6      	; 0x12c8a <FMenuChangeMOP+0x7c6>
   12c84:	89 e1       	ldi	r24, 0x19	; 25
   12c86:	80 93 60 03 	sts	0x0360, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   12c8a:	80 91 cc 01 	lds	r24, 0x01CC
   12c8e:	81 30       	cpi	r24, 0x01	; 1
   12c90:	f1 f5       	brne	.+124    	; 0x12d0e <FMenuChangeMOP+0x84a>
   12c92:	37 c0       	rjmp	.+110    	; 0x12d02 <FMenuChangeMOP+0x83e>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   12c94:	10 92 d0 01 	sts	0x01D0, r1
	      msgResult=procMessage09();
   12c98:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <procMessage09>
		  lcd_clear();
   12c9c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   12ca0:	81 e0       	ldi	r24, 0x01	; 1
   12ca2:	61 e0       	ldi	r22, 0x01	; 1
   12ca4:	42 ec       	ldi	r20, 0xC2	; 194
   12ca6:	5a e0       	ldi	r21, 0x0A	; 10
   12ca8:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   12cac:	82 e0       	ldi	r24, 0x02	; 2
   12cae:	61 e0       	ldi	r22, 0x01	; 1
   12cb0:	4d ea       	ldi	r20, 0xAD	; 173
   12cb2:	59 e0       	ldi	r21, 0x09	; 9
   12cb4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   12cb8:	83 e0       	ldi	r24, 0x03	; 3
   12cba:	61 e0       	ldi	r22, 0x01	; 1
   12cbc:	48 e4       	ldi	r20, 0x48	; 72
   12cbe:	5a e0       	ldi	r21, 0x0A	; 10
   12cc0:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   12cc4:	84 e0       	ldi	r24, 0x04	; 4
   12cc6:	61 e0       	ldi	r22, 0x01	; 1
   12cc8:	4c ed       	ldi	r20, 0xDC	; 220
   12cca:	5d e0       	ldi	r21, 0x0D	; 13
   12ccc:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
   12cd0:	0e c0       	rjmp	.+28     	; 0x12cee <FMenuChangeMOP+0x82a>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   12cd2:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   12cd6:	82 e0       	ldi	r24, 0x02	; 2
   12cd8:	61 e0       	ldi	r22, 0x01	; 1
   12cda:	44 e7       	ldi	r20, 0x74	; 116
   12cdc:	57 e1       	ldi	r21, 0x17	; 23
   12cde:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   12ce2:	83 e0       	ldi	r24, 0x03	; 3
   12ce4:	61 e0       	ldi	r22, 0x01	; 1
   12ce6:	47 e6       	ldi	r20, 0x67	; 103
   12ce8:	57 e1       	ldi	r21, 0x17	; 23
   12cea:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  TimDisplay=0;
   12cee:	10 92 bc 01 	sts	0x01BC, r1
          stChangeMOP=cmDelayMOP;
   12cf2:	8b e1       	ldi	r24, 0x1B	; 27
   12cf4:	de cd       	rjmp	.-1092   	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   12cf6:	80 91 bc 01 	lds	r24, 0x01BC
   12cfa:	8a 30       	cpi	r24, 0x0A	; 10
   12cfc:	40 f0       	brcs	.+16     	; 0x12d0e <FMenuChangeMOP+0x84a>
   12cfe:	8c e1       	ldi	r24, 0x1C	; 28
   12d00:	d8 cd       	rjmp	.-1104   	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   12d02:	8d e1       	ldi	r24, 0x1D	; 29
   12d04:	d6 cd       	rjmp	.-1108   	; 0x128b2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   12d06:	10 92 60 03 	sts	0x0360, r1
   12d0a:	81 e0       	ldi	r24, 0x01	; 1
   12d0c:	01 c0       	rjmp	.+2      	; 0x12d10 <FMenuChangeMOP+0x84c>
   12d0e:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   12d10:	a3 96       	adiw	r28, 0x23	; 35
   12d12:	0f b6       	in	r0, 0x3f	; 63
   12d14:	f8 94       	cli
   12d16:	de bf       	out	0x3e, r29	; 62
   12d18:	0f be       	out	0x3f, r0	; 63
   12d1a:	cd bf       	out	0x3d, r28	; 61
   12d1c:	cf 91       	pop	r28
   12d1e:	df 91       	pop	r29
   12d20:	1f 91       	pop	r17
   12d22:	0f 91       	pop	r16
   12d24:	ff 90       	pop	r15
   12d26:	ef 90       	pop	r14
   12d28:	df 90       	pop	r13
   12d2a:	cf 90       	pop	r12
   12d2c:	bf 90       	pop	r11
   12d2e:	af 90       	pop	r10
   12d30:	08 95       	ret

00012d32 <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
   12d32:	28 2f       	mov	r18, r24
   12d34:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
   12d36:	81 50       	subi	r24, 0x01	; 1
   12d38:	82 30       	cpi	r24, 0x02	; 2
   12d3a:	b8 f4       	brcc	.+46     	; 0x12d6a <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   12d3c:	62 30       	cpi	r22, 0x02	; 2
   12d3e:	59 f0       	breq	.+22     	; 0x12d56 <SetBaudRate+0x24>
   12d40:	62 30       	cpi	r22, 0x02	; 2
   12d42:	18 f0       	brcs	.+6      	; 0x12d4a <SetBaudRate+0x18>
   12d44:	63 30       	cpi	r22, 0x03	; 3
   12d46:	21 f4       	brne	.+8      	; 0x12d50 <SetBaudRate+0x1e>
   12d48:	09 c0       	rjmp	.+18     	; 0x12d5c <SetBaudRate+0x2a>
   12d4a:	40 e8       	ldi	r20, 0x80	; 128
   12d4c:	55 e2       	ldi	r21, 0x25	; 37
   12d4e:	08 c0       	rjmp	.+16     	; 0x12d60 <SetBaudRate+0x2e>
   12d50:	40 e0       	ldi	r20, 0x00	; 0
   12d52:	50 e0       	ldi	r21, 0x00	; 0
   12d54:	05 c0       	rjmp	.+10     	; 0x12d60 <SetBaudRate+0x2e>
   12d56:	40 e0       	ldi	r20, 0x00	; 0
   12d58:	5b e4       	ldi	r21, 0x4B	; 75
   12d5a:	02 c0       	rjmp	.+4      	; 0x12d60 <SetBaudRate+0x2e>
   12d5c:	4b e9       	ldi	r20, 0x9B	; 155
   12d5e:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      _uart_init((ComAddr-1),brValue);
   12d60:	60 e0       	ldi	r22, 0x00	; 0
   12d62:	70 e0       	ldi	r23, 0x00	; 0
   12d64:	0e 94 1c b4 	call	0x16838	; 0x16838 <_uart_init>
   12d68:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
   12d6a:	82 2f       	mov	r24, r18
   12d6c:	83 50       	subi	r24, 0x03	; 3
   12d6e:	82 30       	cpi	r24, 0x02	; 2
   12d70:	a8 f4       	brcc	.+42     	; 0x12d9c <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
   12d72:	9f 70       	andi	r25, 0x0F	; 15
   12d74:	62 2f       	mov	r22, r18
   12d76:	62 95       	swap	r22
   12d78:	60 7f       	andi	r22, 0xF0	; 240
   12d7a:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
   12d7c:	80 91 a9 01 	lds	r24, 0x01A9
   12d80:	88 23       	and	r24, r24
   12d82:	49 f0       	breq	.+18     	; 0x12d96 <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   12d84:	86 e0       	ldi	r24, 0x06	; 6
   12d86:	80 93 b1 07 	sts	0x07B1, r24
	 PoolMsg=plMsg;
   12d8a:	60 93 d9 0d 	sts	0x0DD9, r22
     IsControlPooling=True;
   12d8e:	81 e0       	ldi	r24, 0x01	; 1
   12d90:	80 93 ad 01 	sts	0x01AD, r24
   12d94:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
   12d96:	86 e0       	ldi	r24, 0x06	; 6
   12d98:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
   12d9c:	08 95       	ret

00012d9e <FSettingSystem>:
char FSettingOperator(){
     _menu_user();
     return MENU_DONE;
}

char FSettingSystem(){
   12d9e:	af 92       	push	r10
   12da0:	bf 92       	push	r11
   12da2:	cf 92       	push	r12
   12da4:	df 92       	push	r13
   12da6:	ef 92       	push	r14
   12da8:	ff 92       	push	r15
   12daa:	0f 93       	push	r16
   12dac:	1f 93       	push	r17
   12dae:	df 93       	push	r29
   12db0:	cf 93       	push	r28
   12db2:	cd b7       	in	r28, 0x3d	; 61
   12db4:	de b7       	in	r29, 0x3e	; 62
   12db6:	64 97       	sbiw	r28, 0x14	; 20
   12db8:	0f b6       	in	r0, 0x3f	; 63
   12dba:	f8 94       	cli
   12dbc:	de bf       	out	0x3e, r29	; 62
   12dbe:	0f be       	out	0x3f, r0	; 63
   12dc0:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
   12dc2:	80 91 fb 02 	lds	r24, 0x02FB
   12dc6:	82 30       	cpi	r24, 0x02	; 2
   12dc8:	09 f4       	brne	.+2      	; 0x12dcc <FSettingSystem+0x2e>
   12dca:	cf c0       	rjmp	.+414    	; 0x12f6a <FSettingSystem+0x1cc>
   12dcc:	83 30       	cpi	r24, 0x03	; 3
   12dce:	30 f4       	brcc	.+12     	; 0x12ddc <FSettingSystem+0x3e>
   12dd0:	88 23       	and	r24, r24
   12dd2:	71 f0       	breq	.+28     	; 0x12df0 <FSettingSystem+0x52>
   12dd4:	81 30       	cpi	r24, 0x01	; 1
   12dd6:	09 f0       	breq	.+2      	; 0x12dda <FSettingSystem+0x3c>
   12dd8:	6f c1       	rjmp	.+734    	; 0x130b8 <FSettingSystem+0x31a>
   12dda:	7f c0       	rjmp	.+254    	; 0x12eda <FSettingSystem+0x13c>
   12ddc:	84 30       	cpi	r24, 0x04	; 4
   12dde:	09 f4       	brne	.+2      	; 0x12de2 <FSettingSystem+0x44>
   12de0:	60 c1       	rjmp	.+704    	; 0x130a2 <FSettingSystem+0x304>
   12de2:	84 30       	cpi	r24, 0x04	; 4
   12de4:	08 f4       	brcc	.+2      	; 0x12de8 <FSettingSystem+0x4a>
   12de6:	2b c1       	rjmp	.+598    	; 0x1303e <FSettingSystem+0x2a0>
   12de8:	85 30       	cpi	r24, 0x05	; 5
   12dea:	09 f0       	breq	.+2      	; 0x12dee <FSettingSystem+0x50>
   12dec:	65 c1       	rjmp	.+714    	; 0x130b8 <FSettingSystem+0x31a>
   12dee:	60 c1       	rjmp	.+704    	; 0x130b0 <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12df0:	e1 99       	sbic	0x1c, 1	; 28
   12df2:	fe cf       	rjmp	.-4      	; 0x12df0 <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12df4:	86 e6       	ldi	r24, 0x66	; 102
   12df6:	91 e0       	ldi	r25, 0x01	; 1
   12df8:	9f bb       	out	0x1f, r25	; 31
   12dfa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12dfc:	e0 9a       	sbi	0x1c, 0	; 28
   12dfe:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
   12e00:	20 93 25 01 	sts	0x0125, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12e04:	e1 99       	sbic	0x1c, 1	; 28
   12e06:	fe cf       	rjmp	.-4      	; 0x12e04 <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12e08:	82 ef       	ldi	r24, 0xF2	; 242
   12e0a:	93 e0       	ldi	r25, 0x03	; 3
   12e0c:	9f bb       	out	0x1f, r25	; 31
   12e0e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12e10:	e0 9a       	sbi	0x1c, 0	; 28
   12e12:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
   12e14:	22 23       	and	r18, r18
   12e16:	69 f4       	brne	.+26     	; 0x12e32 <FSettingSystem+0x94>
   12e18:	00 d0       	rcall	.+0      	; 0x12e1a <FSettingSystem+0x7c>
   12e1a:	00 d0       	rcall	.+0      	; 0x12e1c <FSettingSystem+0x7e>
   12e1c:	ce 01       	movw	r24, r28
   12e1e:	01 96       	adiw	r24, 0x01	; 1
   12e20:	ad b7       	in	r26, 0x3d	; 61
   12e22:	be b7       	in	r27, 0x3e	; 62
   12e24:	12 96       	adiw	r26, 0x02	; 2
   12e26:	9c 93       	st	X, r25
   12e28:	8e 93       	st	-X, r24
   12e2a:	11 97       	sbiw	r26, 0x01	; 1
   12e2c:	8a e8       	ldi	r24, 0x8A	; 138
   12e2e:	9f e0       	ldi	r25, 0x0F	; 15
   12e30:	1d c0       	rjmp	.+58     	; 0x12e6c <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
   12e32:	21 30       	cpi	r18, 0x01	; 1
   12e34:	69 f4       	brne	.+26     	; 0x12e50 <FSettingSystem+0xb2>
   12e36:	00 d0       	rcall	.+0      	; 0x12e38 <FSettingSystem+0x9a>
   12e38:	00 d0       	rcall	.+0      	; 0x12e3a <FSettingSystem+0x9c>
   12e3a:	ce 01       	movw	r24, r28
   12e3c:	01 96       	adiw	r24, 0x01	; 1
   12e3e:	ed b7       	in	r30, 0x3d	; 61
   12e40:	fe b7       	in	r31, 0x3e	; 62
   12e42:	92 83       	std	Z+2, r25	; 0x02
   12e44:	81 83       	std	Z+1, r24	; 0x01
   12e46:	8d e7       	ldi	r24, 0x7D	; 125
   12e48:	9f e0       	ldi	r25, 0x0F	; 15
   12e4a:	94 83       	std	Z+4, r25	; 0x04
   12e4c:	83 83       	std	Z+3, r24	; 0x03
   12e4e:	12 c0       	rjmp	.+36     	; 0x12e74 <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
   12e50:	22 30       	cpi	r18, 0x02	; 2
   12e52:	b1 f4       	brne	.+44     	; 0x12e80 <FSettingSystem+0xe2>
   12e54:	00 d0       	rcall	.+0      	; 0x12e56 <FSettingSystem+0xb8>
   12e56:	00 d0       	rcall	.+0      	; 0x12e58 <FSettingSystem+0xba>
   12e58:	ce 01       	movw	r24, r28
   12e5a:	01 96       	adiw	r24, 0x01	; 1
   12e5c:	ad b7       	in	r26, 0x3d	; 61
   12e5e:	be b7       	in	r27, 0x3e	; 62
   12e60:	12 96       	adiw	r26, 0x02	; 2
   12e62:	9c 93       	st	X, r25
   12e64:	8e 93       	st	-X, r24
   12e66:	11 97       	sbiw	r26, 0x01	; 1
   12e68:	8b e6       	ldi	r24, 0x6B	; 107
   12e6a:	9f e0       	ldi	r25, 0x0F	; 15
   12e6c:	14 96       	adiw	r26, 0x04	; 4
   12e6e:	9c 93       	st	X, r25
   12e70:	8e 93       	st	-X, r24
   12e72:	13 97       	sbiw	r26, 0x03	; 3
   12e74:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   12e78:	0f 90       	pop	r0
   12e7a:	0f 90       	pop	r0
   12e7c:	0f 90       	pop	r0
   12e7e:	0f 90       	pop	r0

	      lcd_clear();
   12e80:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_print(1,1,lcdteks);
   12e84:	81 e0       	ldi	r24, 0x01	; 1
   12e86:	61 e0       	ldi	r22, 0x01	; 1
   12e88:	ae 01       	movw	r20, r28
   12e8a:	4f 5f       	subi	r20, 0xFF	; 255
   12e8c:	5f 4f       	sbci	r21, 0xFF	; 255
   12e8e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
   12e92:	82 e0       	ldi	r24, 0x02	; 2
   12e94:	61 e0       	ldi	r22, 0x01	; 1
   12e96:	40 e6       	ldi	r20, 0x60	; 96
   12e98:	5f e0       	ldi	r21, 0x0F	; 15
   12e9a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
   12e9e:	11 23       	and	r17, r17
   12ea0:	29 f4       	brne	.+10     	; 0x12eac <FSettingSystem+0x10e>
   12ea2:	83 e0       	ldi	r24, 0x03	; 3
   12ea4:	61 e0       	ldi	r22, 0x01	; 1
   12ea6:	45 e5       	ldi	r20, 0x55	; 85
   12ea8:	5f e0       	ldi	r21, 0x0F	; 15
   12eaa:	0d c0       	rjmp	.+26     	; 0x12ec6 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
   12eac:	11 30       	cpi	r17, 0x01	; 1
   12eae:	29 f4       	brne	.+10     	; 0x12eba <FSettingSystem+0x11c>
   12eb0:	83 e0       	ldi	r24, 0x03	; 3
   12eb2:	61 e0       	ldi	r22, 0x01	; 1
   12eb4:	4a e4       	ldi	r20, 0x4A	; 74
   12eb6:	5f e0       	ldi	r21, 0x0F	; 15
   12eb8:	06 c0       	rjmp	.+12     	; 0x12ec6 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
   12eba:	12 30       	cpi	r17, 0x02	; 2
   12ebc:	31 f4       	brne	.+12     	; 0x12eca <FSettingSystem+0x12c>
   12ebe:	83 e0       	ldi	r24, 0x03	; 3
   12ec0:	61 e0       	ldi	r22, 0x01	; 1
   12ec2:	4f e3       	ldi	r20, 0x3F	; 63
   12ec4:	5f e0       	ldi	r21, 0x0F	; 15
   12ec6:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
   12eca:	84 e0       	ldi	r24, 0x04	; 4
   12ecc:	61 e0       	ldi	r22, 0x01	; 1
   12ece:	41 e3       	ldi	r20, 0x31	; 49
   12ed0:	5f e0       	ldi	r21, 0x0F	; 15
   12ed2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stSettingSytem=ssMenuSelect;
   12ed6:	81 e0       	ldi	r24, 0x01	; 1
   12ed8:	e1 c0       	rjmp	.+450    	; 0x1309c <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
   12eda:	81 e0       	ldi	r24, 0x01	; 1
   12edc:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   12ee0:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
		  if (KeyChar=='1'){
   12ee4:	81 33       	cpi	r24, 0x31	; 49
   12ee6:	c1 f4       	brne	.+48     	; 0x12f18 <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
   12ee8:	80 91 25 01 	lds	r24, 0x0125
   12eec:	90 e0       	ldi	r25, 0x00	; 0
   12eee:	01 96       	adiw	r24, 0x01	; 1
   12ef0:	63 e0       	ldi	r22, 0x03	; 3
   12ef2:	70 e0       	ldi	r23, 0x00	; 0
   12ef4:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   12ef8:	80 93 25 01 	sts	0x0125, r24
			  SendSlaveCommand(IFType,DispenserBrand);
   12efc:	60 91 77 01 	lds	r22, 0x0177
   12f00:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
   12f04:	20 91 25 01 	lds	r18, 0x0125
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   12f08:	e1 99       	sbic	0x1c, 1	; 28
   12f0a:	fe cf       	rjmp	.-4      	; 0x12f08 <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12f0c:	86 e6       	ldi	r24, 0x66	; 102
   12f0e:	91 e0       	ldi	r25, 0x01	; 1
   12f10:	9f bb       	out	0x1f, r25	; 31
   12f12:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   12f14:	2d bb       	out	0x1d, r18	; 29
   12f16:	1f c0       	rjmp	.+62     	; 0x12f56 <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
   12f18:	82 33       	cpi	r24, 0x32	; 50
   12f1a:	09 f4       	brne	.+2      	; 0x12f1e <FSettingSystem+0x180>
   12f1c:	ba c0       	rjmp	.+372    	; 0x13092 <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
   12f1e:	83 33       	cpi	r24, 0x33	; 51
   12f20:	01 f5       	brne	.+64     	; 0x12f62 <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12f22:	e1 99       	sbic	0x1c, 1	; 28
   12f24:	fe cf       	rjmp	.-4      	; 0x12f22 <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12f26:	e2 ef       	ldi	r30, 0xF2	; 242
   12f28:	ee 2e       	mov	r14, r30
   12f2a:	e3 e0       	ldi	r30, 0x03	; 3
   12f2c:	fe 2e       	mov	r15, r30
   12f2e:	ff ba       	out	0x1f, r15	; 31
   12f30:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12f32:	e0 9a       	sbi	0x1c, 0	; 28
   12f34:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
   12f36:	90 e0       	ldi	r25, 0x00	; 0
   12f38:	01 96       	adiw	r24, 0x01	; 1
   12f3a:	63 e0       	ldi	r22, 0x03	; 3
   12f3c:	70 e0       	ldi	r23, 0x00	; 0
   12f3e:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   12f42:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
   12f44:	81 e2       	ldi	r24, 0x21	; 33
   12f46:	61 2f       	mov	r22, r17
   12f48:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   12f4c:	e1 99       	sbic	0x1c, 1	; 28
   12f4e:	fe cf       	rjmp	.-4      	; 0x12f4c <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12f50:	ff ba       	out	0x1f, r15	; 31
   12f52:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   12f54:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
   12f56:	0f b6       	in	r0, 0x3f	; 63
   12f58:	f8 94       	cli
   12f5a:	e2 9a       	sbi	0x1c, 2	; 28
   12f5c:	e1 9a       	sbi	0x1c, 1	; 28
   12f5e:	0f be       	out	0x3f, r0	; 63
   12f60:	a4 c0       	rjmp	.+328    	; 0x130aa <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
   12f62:	8a 32       	cpi	r24, 0x2A	; 42
   12f64:	09 f4       	brne	.+2      	; 0x12f68 <FSettingSystem+0x1ca>
   12f66:	99 c0       	rjmp	.+306    	; 0x1309a <FSettingSystem+0x2fc>
   12f68:	a7 c0       	rjmp	.+334    	; 0x130b8 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
   12f6a:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   12f6e:	81 e0       	ldi	r24, 0x01	; 1
   12f70:	61 e0       	ldi	r22, 0x01	; 1
   12f72:	4c e1       	ldi	r20, 0x1C	; 28
   12f74:	5f e0       	ldi	r21, 0x0F	; 15
   12f76:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   12f7a:	01 e0       	ldi	r16, 0x01	; 1
   12f7c:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   12f7e:	6e 01       	movw	r12, r28
   12f80:	08 94       	sec
   12f82:	c1 1c       	adc	r12, r1
   12f84:	d1 1c       	adc	r13, r1
   12f86:	73 e1       	ldi	r23, 0x13	; 19
   12f88:	a7 2e       	mov	r10, r23
   12f8a:	7f e0       	ldi	r23, 0x0F	; 15
   12f8c:	b7 2e       	mov	r11, r23
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   12f8e:	6b e0       	ldi	r22, 0x0B	; 11
   12f90:	e6 2e       	mov	r14, r22
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   12f92:	f0 2e       	mov	r15, r16
   12f94:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12f96:	e1 99       	sbic	0x1c, 1	; 28
   12f98:	fe cf       	rjmp	.-4      	; 0x12f96 <FSettingSystem+0x1f8>
   12f9a:	c8 01       	movw	r24, r16
   12f9c:	81 59       	subi	r24, 0x91	; 145
   12f9e:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12fa0:	9f bb       	out	0x1f, r25	; 31
   12fa2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12fa4:	e0 9a       	sbi	0x1c, 0	; 28
   12fa6:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   12fa8:	82 30       	cpi	r24, 0x02	; 2
   12faa:	69 f0       	breq	.+26     	; 0x12fc6 <FSettingSystem+0x228>
   12fac:	82 30       	cpi	r24, 0x02	; 2
   12fae:	28 f0       	brcs	.+10     	; 0x12fba <FSettingSystem+0x21c>
   12fb0:	83 30       	cpi	r24, 0x03	; 3
   12fb2:	31 f4       	brne	.+12     	; 0x12fc0 <FSettingSystem+0x222>
   12fb4:	85 eb       	ldi	r24, 0xB5	; 181
   12fb6:	9f e2       	ldi	r25, 0x2F	; 47
   12fb8:	08 c0       	rjmp	.+16     	; 0x12fca <FSettingSystem+0x22c>
   12fba:	80 e8       	ldi	r24, 0x80	; 128
   12fbc:	95 e2       	ldi	r25, 0x25	; 37
   12fbe:	05 c0       	rjmp	.+10     	; 0x12fca <FSettingSystem+0x22c>
   12fc0:	80 e0       	ldi	r24, 0x00	; 0
   12fc2:	90 e0       	ldi	r25, 0x00	; 0
   12fc4:	02 c0       	rjmp	.+4      	; 0x12fca <FSettingSystem+0x22c>
   12fc6:	80 e0       	ldi	r24, 0x00	; 0
   12fc8:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   12fca:	ed b7       	in	r30, 0x3d	; 61
   12fcc:	fe b7       	in	r31, 0x3e	; 62
   12fce:	38 97       	sbiw	r30, 0x08	; 8
   12fd0:	0f b6       	in	r0, 0x3f	; 63
   12fd2:	f8 94       	cli
   12fd4:	fe bf       	out	0x3e, r31	; 62
   12fd6:	0f be       	out	0x3f, r0	; 63
   12fd8:	ed bf       	out	0x3d, r30	; 61
   12fda:	31 96       	adiw	r30, 0x01	; 1
   12fdc:	ad b7       	in	r26, 0x3d	; 61
   12fde:	be b7       	in	r27, 0x3e	; 62
   12fe0:	12 96       	adiw	r26, 0x02	; 2
   12fe2:	dc 92       	st	X, r13
   12fe4:	ce 92       	st	-X, r12
   12fe6:	11 97       	sbiw	r26, 0x01	; 1
   12fe8:	b3 82       	std	Z+3, r11	; 0x03
   12fea:	a2 82       	std	Z+2, r10	; 0x02
   12fec:	15 83       	std	Z+5, r17	; 0x05
   12fee:	04 83       	std	Z+4, r16	; 0x04
   12ff0:	97 83       	std	Z+7, r25	; 0x07
   12ff2:	86 83       	std	Z+6, r24	; 0x06
   12ff4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   12ff8:	ed b7       	in	r30, 0x3d	; 61
   12ffa:	fe b7       	in	r31, 0x3e	; 62
   12ffc:	38 96       	adiw	r30, 0x08	; 8
   12ffe:	0f b6       	in	r0, 0x3f	; 63
   13000:	f8 94       	cli
   13002:	fe bf       	out	0x3e, r31	; 62
   13004:	0f be       	out	0x3f, r0	; 63
   13006:	ed bf       	out	0x3d, r30	; 61
   13008:	6f 2d       	mov	r22, r15
   1300a:	66 95       	lsr	r22
   1300c:	6e 9d       	mul	r22, r14
   1300e:	b0 01       	movw	r22, r0
   13010:	11 24       	eor	r1, r1
   13012:	6f 5f       	subi	r22, 0xFF	; 255
   13014:	f1 e0       	ldi	r31, 0x01	; 1
   13016:	ff 22       	and	r15, r31
   13018:	8f 2d       	mov	r24, r15
   1301a:	8e 5f       	subi	r24, 0xFE	; 254
   1301c:	a6 01       	movw	r20, r12
   1301e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
   13022:	0f 5f       	subi	r16, 0xFF	; 255
   13024:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
   13026:	05 30       	cpi	r16, 0x05	; 5
   13028:	11 05       	cpc	r17, r1
   1302a:	09 f0       	breq	.+2      	; 0x1302e <FSettingSystem+0x290>
   1302c:	b2 cf       	rjmp	.-156    	; 0x12f92 <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
   1302e:	84 e0       	ldi	r24, 0x04	; 4
   13030:	61 e0       	ldi	r22, 0x01	; 1
   13032:	46 e0       	ldi	r20, 0x06	; 6
   13034:	5f e0       	ldi	r21, 0x0F	; 15
   13036:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
   1303a:	83 e0       	ldi	r24, 0x03	; 3
   1303c:	2f c0       	rjmp	.+94     	; 0x1309c <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
   1303e:	81 e0       	ldi	r24, 0x01	; 1
   13040:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13044:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   13048:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1304a:	81 53       	subi	r24, 0x31	; 49
   1304c:	84 30       	cpi	r24, 0x04	; 4
   1304e:	18 f5       	brcc	.+70     	; 0x13096 <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13050:	e1 99       	sbic	0x1c, 1	; 28
   13052:	fe cf       	rjmp	.-4      	; 0x13050 <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13054:	02 2f       	mov	r16, r18
   13056:	10 e0       	ldi	r17, 0x00	; 0
   13058:	01 5c       	subi	r16, 0xC1	; 193
   1305a:	1e 4f       	sbci	r17, 0xFE	; 254
   1305c:	1f bb       	out	0x1f, r17	; 31
   1305e:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13060:	e0 9a       	sbi	0x1c, 0	; 28
   13062:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
   13064:	90 e0       	ldi	r25, 0x00	; 0
   13066:	01 96       	adiw	r24, 0x01	; 1
   13068:	63 e0       	ldi	r22, 0x03	; 3
   1306a:	70 e0       	ldi	r23, 0x00	; 0
   1306c:	0e 94 01 b9 	call	0x17202	; 0x17202 <__divmodhi4>
   13070:	f8 2e       	mov	r15, r24
   13072:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
   13074:	82 2f       	mov	r24, r18
   13076:	80 53       	subi	r24, 0x30	; 48
   13078:	6f 2d       	mov	r22, r15
   1307a:	0e 94 99 96 	call	0x12d32	; 0x12d32 <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1307e:	e1 99       	sbic	0x1c, 1	; 28
   13080:	fe cf       	rjmp	.-4      	; 0x1307e <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13082:	1f bb       	out	0x1f, r17	; 31
   13084:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   13086:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
   13088:	0f b6       	in	r0, 0x3f	; 63
   1308a:	f8 94       	cli
   1308c:	e2 9a       	sbi	0x1c, 2	; 28
   1308e:	e1 9a       	sbi	0x1c, 1	; 28
   13090:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
   13092:	82 e0       	ldi	r24, 0x02	; 2
   13094:	03 c0       	rjmp	.+6      	; 0x1309c <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
   13096:	2a 32       	cpi	r18, 0x2A	; 42
   13098:	79 f4       	brne	.+30     	; 0x130b8 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
   1309a:	85 e0       	ldi	r24, 0x05	; 5
   1309c:	80 93 fb 02 	sts	0x02FB, r24
   130a0:	0b c0       	rjmp	.+22     	; 0x130b8 <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
   130a2:	0e 94 6c 6f 	call	0xded8	; 0xded8 <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
   130a6:	81 30       	cpi	r24, 0x01	; 1
   130a8:	39 f4       	brne	.+14     	; 0x130b8 <FSettingSystem+0x31a>
   130aa:	10 92 fb 02 	sts	0x02FB, r1
   130ae:	04 c0       	rjmp	.+8      	; 0x130b8 <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
   130b0:	10 92 fb 02 	sts	0x02FB, r1
   130b4:	81 e0       	ldi	r24, 0x01	; 1
   130b6:	01 c0       	rjmp	.+2      	; 0x130ba <FSettingSystem+0x31c>
   130b8:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   130ba:	64 96       	adiw	r28, 0x14	; 20
   130bc:	0f b6       	in	r0, 0x3f	; 63
   130be:	f8 94       	cli
   130c0:	de bf       	out	0x3e, r29	; 62
   130c2:	0f be       	out	0x3f, r0	; 63
   130c4:	cd bf       	out	0x3d, r28	; 61
   130c6:	cf 91       	pop	r28
   130c8:	df 91       	pop	r29
   130ca:	1f 91       	pop	r17
   130cc:	0f 91       	pop	r16
   130ce:	ff 90       	pop	r15
   130d0:	ef 90       	pop	r14
   130d2:	df 90       	pop	r13
   130d4:	cf 90       	pop	r12
   130d6:	bf 90       	pop	r11
   130d8:	af 90       	pop	r10
   130da:	08 95       	ret

000130dc <FMenuSettings>:


char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1,KeyPressed,KeyChar,SubMenu;
     switch(stMenuSettings){
   130dc:	80 91 0c 03 	lds	r24, 0x030C
   130e0:	e8 2f       	mov	r30, r24
   130e2:	f0 e0       	ldi	r31, 0x00	; 0
   130e4:	e3 31       	cpi	r30, 0x13	; 19
   130e6:	f1 05       	cpc	r31, r1
   130e8:	08 f0       	brcs	.+2      	; 0x130ec <FMenuSettings+0x10>
   130ea:	cd c0       	rjmp	.+410    	; 0x13286 <FMenuSettings+0x1aa>
   130ec:	ee 51       	subi	r30, 0x1E	; 30
   130ee:	ff 4f       	sbci	r31, 0xFF	; 255
   130f0:	ee 0f       	add	r30, r30
   130f2:	ff 1f       	adc	r31, r31
   130f4:	05 90       	lpm	r0, Z+
   130f6:	f4 91       	lpm	r31, Z+
   130f8:	e0 2d       	mov	r30, r0
   130fa:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
   130fc:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		  PageSetting=1;
   13100:	81 e0       	ldi	r24, 0x01	; 1
   13102:	80 93 6c 01 	sts	0x016C, r24
   13106:	95 c0       	rjmp	.+298    	; 0x13232 <FMenuSettings+0x156>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
   13108:	80 91 6c 01 	lds	r24, 0x016C
   1310c:	8f 5f       	subi	r24, 0xFF	; 255
   1310e:	91 c0       	rjmp	.+290    	; 0x13232 <FMenuSettings+0x156>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
   13110:	81 e0       	ldi	r24, 0x01	; 1
   13112:	61 e0       	ldi	r22, 0x01	; 1
   13114:	44 e5       	ldi	r20, 0x54	; 84
   13116:	51 e1       	ldi	r21, 0x11	; 17
   13118:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
   1311c:	82 e0       	ldi	r24, 0x02	; 2
   1311e:	61 e0       	ldi	r22, 0x01	; 1
   13120:	4f e3       	ldi	r20, 0x3F	; 63
   13122:	51 e1       	ldi	r21, 0x11	; 17
   13124:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
   13128:	83 e0       	ldi	r24, 0x03	; 3
   1312a:	61 e0       	ldi	r22, 0x01	; 1
   1312c:	4a e2       	ldi	r20, 0x2A	; 42
   1312e:	51 e1       	ldi	r21, 0x11	; 17
   13130:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
   13134:	84 e0       	ldi	r24, 0x04	; 4
   13136:	61 e0       	ldi	r22, 0x01	; 1
   13138:	45 e1       	ldi	r20, 0x15	; 21
   1313a:	51 e1       	ldi	r21, 0x11	; 17
   1313c:	16 c0       	rjmp	.+44     	; 0x1316a <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
   1313e:	81 e0       	ldi	r24, 0x01	; 1
   13140:	61 e0       	ldi	r22, 0x01	; 1
   13142:	40 e0       	ldi	r20, 0x00	; 0
   13144:	51 e1       	ldi	r21, 0x11	; 17
   13146:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
   1314a:	82 e0       	ldi	r24, 0x02	; 2
   1314c:	61 e0       	ldi	r22, 0x01	; 1
   1314e:	4b ee       	ldi	r20, 0xEB	; 235
   13150:	50 e1       	ldi	r21, 0x10	; 16
   13152:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
   13156:	83 e0       	ldi	r24, 0x03	; 3
   13158:	61 e0       	ldi	r22, 0x01	; 1
   1315a:	46 ed       	ldi	r20, 0xD6	; 214
   1315c:	50 e1       	ldi	r21, 0x10	; 16
   1315e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
   13162:	84 e0       	ldi	r24, 0x04	; 4
   13164:	61 e0       	ldi	r22, 0x01	; 1
   13166:	41 ec       	ldi	r20, 0xC1	; 193
   13168:	50 e1       	ldi	r21, 0x10	; 16
   1316a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stMenuSettings=msSelection;
   1316e:	84 e0       	ldi	r24, 0x04	; 4
   13170:	60 c0       	rjmp	.+192    	; 0x13232 <FMenuSettings+0x156>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
   13172:	80 91 6c 01 	lds	r24, 0x016C
   13176:	8c 5f       	subi	r24, 0xFC	; 252
   13178:	5c c0       	rjmp	.+184    	; 0x13232 <FMenuSettings+0x156>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
   1317a:	81 e0       	ldi	r24, 0x01	; 1
   1317c:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   13180:	80 93 0b 03 	sts	0x030B, r24
		  KeyChar=_key_btn(KeyPressed);
   13184:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   13188:	80 93 0a 03 	sts	0x030A, r24
		  switch(KeyChar){
   1318c:	84 33       	cpi	r24, 0x34	; 52
   1318e:	d1 f0       	breq	.+52     	; 0x131c4 <FMenuSettings+0xe8>
   13190:	85 33       	cpi	r24, 0x35	; 53
   13192:	50 f4       	brcc	.+20     	; 0x131a8 <FMenuSettings+0xcc>
   13194:	82 33       	cpi	r24, 0x32	; 50
   13196:	91 f0       	breq	.+36     	; 0x131bc <FMenuSettings+0xe0>
   13198:	83 33       	cpi	r24, 0x33	; 51
   1319a:	90 f4       	brcc	.+36     	; 0x131c0 <FMenuSettings+0xe4>
   1319c:	8a 32       	cpi	r24, 0x2A	; 42
   1319e:	d1 f0       	breq	.+52     	; 0x131d4 <FMenuSettings+0xf8>
   131a0:	81 33       	cpi	r24, 0x31	; 49
   131a2:	09 f0       	breq	.+2      	; 0x131a6 <FMenuSettings+0xca>
   131a4:	70 c0       	rjmp	.+224    	; 0x13286 <FMenuSettings+0x1aa>
   131a6:	08 c0       	rjmp	.+16     	; 0x131b8 <FMenuSettings+0xdc>
   131a8:	86 33       	cpi	r24, 0x36	; 54
   131aa:	81 f0       	breq	.+32     	; 0x131cc <FMenuSettings+0xf0>
   131ac:	86 33       	cpi	r24, 0x36	; 54
   131ae:	60 f0       	brcs	.+24     	; 0x131c8 <FMenuSettings+0xec>
   131b0:	87 33       	cpi	r24, 0x37	; 55
   131b2:	09 f0       	breq	.+2      	; 0x131b6 <FMenuSettings+0xda>
   131b4:	68 c0       	rjmp	.+208    	; 0x13286 <FMenuSettings+0x1aa>
   131b6:	0c c0       	rjmp	.+24     	; 0x131d0 <FMenuSettings+0xf4>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
   131b8:	89 e0       	ldi	r24, 0x09	; 9
   131ba:	3b c0       	rjmp	.+118    	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
   131bc:	8a e0       	ldi	r24, 0x0A	; 10
   131be:	39 c0       	rjmp	.+114    	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
   131c0:	8b e0       	ldi	r24, 0x0B	; 11
   131c2:	37 c0       	rjmp	.+110    	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
   131c4:	8c e0       	ldi	r24, 0x0C	; 12
   131c6:	35 c0       	rjmp	.+106    	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
   131c8:	8d e0       	ldi	r24, 0x0D	; 13
   131ca:	33 c0       	rjmp	.+102    	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
   131cc:	8e e0       	ldi	r24, 0x0E	; 14
   131ce:	31 c0       	rjmp	.+98     	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
   131d0:	87 e0       	ldi	r24, 0x07	; 7
   131d2:	2f c0       	rjmp	.+94     	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
   131d4:	82 e1       	ldi	r24, 0x12	; 18
   131d6:	2d c0       	rjmp	.+90     	; 0x13232 <FMenuSettings+0x156>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
   131d8:	81 e0       	ldi	r24, 0x01	; 1
   131da:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   131de:	80 93 0b 03 	sts	0x030B, r24
		  KeyChar=_key_btn(KeyPressed);
   131e2:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   131e6:	80 93 0a 03 	sts	0x030A, r24
		  switch(KeyChar){
   131ea:	82 33       	cpi	r24, 0x32	; 50
   131ec:	71 f0       	breq	.+28     	; 0x1320a <FMenuSettings+0x12e>
   131ee:	83 33       	cpi	r24, 0x33	; 51
   131f0:	30 f4       	brcc	.+12     	; 0x131fe <FMenuSettings+0x122>
   131f2:	8a 32       	cpi	r24, 0x2A	; 42
   131f4:	71 f0       	breq	.+28     	; 0x13212 <FMenuSettings+0x136>
   131f6:	81 33       	cpi	r24, 0x31	; 49
   131f8:	09 f0       	breq	.+2      	; 0x131fc <FMenuSettings+0x120>
   131fa:	45 c0       	rjmp	.+138    	; 0x13286 <FMenuSettings+0x1aa>
   131fc:	04 c0       	rjmp	.+8      	; 0x13206 <FMenuSettings+0x12a>
   131fe:	83 33       	cpi	r24, 0x33	; 51
   13200:	09 f0       	breq	.+2      	; 0x13204 <FMenuSettings+0x128>
   13202:	41 c0       	rjmp	.+130    	; 0x13286 <FMenuSettings+0x1aa>
   13204:	04 c0       	rjmp	.+8      	; 0x1320e <FMenuSettings+0x132>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
   13206:	8f e0       	ldi	r24, 0x0F	; 15
   13208:	14 c0       	rjmp	.+40     	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
   1320a:	80 e1       	ldi	r24, 0x10	; 16
   1320c:	12 c0       	rjmp	.+36     	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
   1320e:	81 e1       	ldi	r24, 0x11	; 17
   13210:	10 c0       	rjmp	.+32     	; 0x13232 <FMenuSettings+0x156>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
   13212:	88 e0       	ldi	r24, 0x08	; 8
   13214:	0e c0       	rjmp	.+28     	; 0x13232 <FMenuSettings+0x156>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
   13216:	80 91 6c 01 	lds	r24, 0x016C
   1321a:	82 30       	cpi	r24, 0x02	; 2
   1321c:	48 f4       	brcc	.+18     	; 0x13230 <FMenuSettings+0x154>
   1321e:	8f 5f       	subi	r24, 0xFF	; 255
   13220:	05 c0       	rjmp	.+10     	; 0x1322c <FMenuSettings+0x150>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
   13222:	80 91 6c 01 	lds	r24, 0x016C
   13226:	82 30       	cpi	r24, 0x02	; 2
   13228:	18 f0       	brcs	.+6      	; 0x13230 <FMenuSettings+0x154>
   1322a:	81 50       	subi	r24, 0x01	; 1
   1322c:	80 93 6c 01 	sts	0x016C, r24
		  stMenuSettings=msDisplayPage;
   13230:	81 e0       	ldi	r24, 0x01	; 1
   13232:	80 93 0c 03 	sts	0x030C, r24
   13236:	80 e0       	ldi	r24, 0x00	; 0
   13238:	08 95       	ret
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
   1323a:	0e 94 eb 87 	call	0x10fd6	; 0x10fd6 <FSettingProduct>
   1323e:	1a c0       	rjmp	.+52     	; 0x13274 <FMenuSettings+0x198>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
   13240:	0e 94 56 78 	call	0xf0ac	; 0xf0ac <FSettingPump>
   13244:	17 c0       	rjmp	.+46     	; 0x13274 <FMenuSettings+0x198>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
   13246:	0e 94 8e 83 	call	0x1071c	; 0x1071c <FSettingDec>
   1324a:	14 c0       	rjmp	.+40     	; 0x13274 <FMenuSettings+0x198>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
   1324c:	0e 94 cb 63 	call	0xc796	; 0xc796 <_menu_datetime>
   13250:	08 c0       	rjmp	.+16     	; 0x13262 <FMenuSettings+0x186>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
   13252:	0e 94 4a 4a 	call	0x9494	; 0x9494 <_menu_printer>
   13256:	05 c0       	rjmp	.+10     	; 0x13262 <FMenuSettings+0x186>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
   13258:	0e 94 d7 42 	call	0x85ae	; 0x85ae <_menu_host>
   1325c:	02 c0       	rjmp	.+4      	; 0x13262 <FMenuSettings+0x186>
	 return MENU_DONE;
}
char FSettingOperator(){
     _menu_user();
   1325e:	0e 94 81 62 	call	0xc502	; 0xc502 <_menu_user>
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
   13262:	81 e0       	ldi	r24, 0x01	; 1
   13264:	80 93 09 03 	sts	0x0309, r24
   13268:	e4 cf       	rjmp	.-56     	; 0x13232 <FMenuSettings+0x156>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
   1326a:	0e 94 cf 96 	call	0x12d9e	; 0x12d9e <FSettingSystem>
   1326e:	02 c0       	rjmp	.+4      	; 0x13274 <FMenuSettings+0x198>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
   13270:	0e 94 6c 6f 	call	0xded8	; 0xded8 <FSettingPumpPooling>
   13274:	80 93 09 03 	sts	0x0309, r24
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   13278:	81 30       	cpi	r24, 0x01	; 1
   1327a:	29 f4       	brne	.+10     	; 0x13286 <FMenuSettings+0x1aa>
   1327c:	da cf       	rjmp	.-76     	; 0x13232 <FMenuSettings+0x156>
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
   1327e:	10 92 0c 03 	sts	0x030C, r1
   13282:	81 e0       	ldi	r24, 0x01	; 1
   13284:	08 95       	ret
   13286:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   13288:	08 95       	ret

0001328a <FMenuAuthorization>:
}

char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   1328a:	80 91 4b 03 	lds	r24, 0x034B
   1328e:	83 30       	cpi	r24, 0x03	; 3
   13290:	69 f1       	breq	.+90     	; 0x132ec <FMenuAuthorization+0x62>
   13292:	84 30       	cpi	r24, 0x04	; 4
   13294:	28 f4       	brcc	.+10     	; 0x132a0 <FMenuAuthorization+0x16>
   13296:	81 30       	cpi	r24, 0x01	; 1
   13298:	89 f0       	breq	.+34     	; 0x132bc <FMenuAuthorization+0x32>
   1329a:	82 30       	cpi	r24, 0x02	; 2
   1329c:	50 f5       	brcc	.+84     	; 0x132f2 <FMenuAuthorization+0x68>
   1329e:	0b c0       	rjmp	.+22     	; 0x132b6 <FMenuAuthorization+0x2c>
   132a0:	85 30       	cpi	r24, 0x05	; 5
   132a2:	79 f1       	breq	.+94     	; 0x13302 <FMenuAuthorization+0x78>
   132a4:	85 30       	cpi	r24, 0x05	; 5
   132a6:	40 f1       	brcs	.+80     	; 0x132f8 <FMenuAuthorization+0x6e>
   132a8:	86 30       	cpi	r24, 0x06	; 6
   132aa:	09 f4       	brne	.+2      	; 0x132ae <FMenuAuthorization+0x24>
   132ac:	41 c0       	rjmp	.+130    	; 0x13330 <FMenuAuthorization+0xa6>
   132ae:	87 30       	cpi	r24, 0x07	; 7
   132b0:	09 f0       	breq	.+2      	; 0x132b4 <FMenuAuthorization+0x2a>
   132b2:	51 c0       	rjmp	.+162    	; 0x13356 <FMenuAuthorization+0xcc>
   132b4:	4c c0       	rjmp	.+152    	; 0x1334e <FMenuAuthorization+0xc4>
	 case maInit:
	      PassTry=0;
   132b6:	10 92 4a 03 	sts	0x034A, r1
   132ba:	42 c0       	rjmp	.+132    	; 0x13340 <FMenuAuthorization+0xb6>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   132bc:	0e 94 f4 8f 	call	0x11fe8	; 0x11fe8 <FMenuPassword>
		  switch(PassResult){
   132c0:	83 30       	cpi	r24, 0x03	; 3
   132c2:	09 f4       	brne	.+2      	; 0x132c6 <FMenuAuthorization+0x3c>
   132c4:	40 c0       	rjmp	.+128    	; 0x13346 <FMenuAuthorization+0xbc>
   132c6:	84 30       	cpi	r24, 0x04	; 4
   132c8:	30 f4       	brcc	.+12     	; 0x132d6 <FMenuAuthorization+0x4c>
   132ca:	81 30       	cpi	r24, 0x01	; 1
   132cc:	d9 f1       	breq	.+118    	; 0x13344 <FMenuAuthorization+0xba>
   132ce:	82 30       	cpi	r24, 0x02	; 2
   132d0:	09 f0       	breq	.+2      	; 0x132d4 <FMenuAuthorization+0x4a>
   132d2:	41 c0       	rjmp	.+130    	; 0x13356 <FMenuAuthorization+0xcc>
   132d4:	09 c0       	rjmp	.+18     	; 0x132e8 <FMenuAuthorization+0x5e>
   132d6:	84 30       	cpi	r24, 0x04	; 4
   132d8:	19 f0       	breq	.+6      	; 0x132e0 <FMenuAuthorization+0x56>
   132da:	85 30       	cpi	r24, 0x05	; 5
   132dc:	e1 f5       	brne	.+120    	; 0x13356 <FMenuAuthorization+0xcc>
   132de:	02 c0       	rjmp	.+4      	; 0x132e4 <FMenuAuthorization+0x5a>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   132e0:	82 e0       	ldi	r24, 0x02	; 2
   132e2:	31 c0       	rjmp	.+98     	; 0x13346 <FMenuAuthorization+0xbc>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   132e4:	84 e0       	ldi	r24, 0x04	; 4
   132e6:	2f c0       	rjmp	.+94     	; 0x13346 <FMenuAuthorization+0xbc>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   132e8:	85 e0       	ldi	r24, 0x05	; 5
   132ea:	2d c0       	rjmp	.+90     	; 0x13346 <FMenuAuthorization+0xbc>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   132ec:	0e 94 dd 8d 	call	0x11bba	; 0x11bba <FMenuMaster>
   132f0:	05 c0       	rjmp	.+10     	; 0x132fc <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   132f2:	0e 94 ed 91 	call	0x123da	; 0x123da <FMenuAdmin>
   132f6:	02 c0       	rjmp	.+4      	; 0x132fc <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   132f8:	0e 94 6e 98 	call	0x130dc	; 0x130dc <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   132fc:	81 30       	cpi	r24, 0x01	; 1
   132fe:	59 f5       	brne	.+86     	; 0x13356 <FMenuAuthorization+0xcc>
   13300:	21 c0       	rjmp	.+66     	; 0x13344 <FMenuAuthorization+0xba>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   13302:	80 91 4a 03 	lds	r24, 0x034A
   13306:	8f 5f       	subi	r24, 0xFF	; 255
   13308:	80 93 4a 03 	sts	0x034A, r24
	      TimDisplay=0;
   1330c:	10 92 bc 01 	sts	0x01BC, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13310:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13312:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13314:	81 e0       	ldi	r24, 0x01	; 1
   13316:	90 e0       	ldi	r25, 0x00	; 0
   13318:	90 93 ed 01 	sts	0x01ED, r25
   1331c:	80 93 ec 01 	sts	0x01EC, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   13320:	83 e0       	ldi	r24, 0x03	; 3
   13322:	61 e0       	ldi	r22, 0x01	; 1
   13324:	4a e3       	ldi	r20, 0x3A	; 58
   13326:	57 e1       	ldi	r21, 0x17	; 23
   13328:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   1332c:	86 e0       	ldi	r24, 0x06	; 6
   1332e:	0b c0       	rjmp	.+22     	; 0x13346 <FMenuAuthorization+0xbc>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   13330:	80 91 bc 01 	lds	r24, 0x01BC
   13334:	83 30       	cpi	r24, 0x03	; 3
   13336:	78 f0       	brcs	.+30     	; 0x13356 <FMenuAuthorization+0xcc>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   13338:	80 91 4a 03 	lds	r24, 0x034A
   1333c:	83 30       	cpi	r24, 0x03	; 3
   1333e:	10 f4       	brcc	.+4      	; 0x13344 <FMenuAuthorization+0xba>
   13340:	81 e0       	ldi	r24, 0x01	; 1
   13342:	01 c0       	rjmp	.+2      	; 0x13346 <FMenuAuthorization+0xbc>
			  else stMenuAuthorization=maExitAuthorization;
   13344:	87 e0       	ldi	r24, 0x07	; 7
   13346:	80 93 4b 03 	sts	0x034B, r24
   1334a:	80 e0       	ldi	r24, 0x00	; 0
   1334c:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   1334e:	10 92 4b 03 	sts	0x034B, r1
   13352:	81 e0       	ldi	r24, 0x01	; 1
   13354:	08 95       	ret
   13356:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   13358:	08 95       	ret

0001335a <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
   1335a:	af 92       	push	r10
   1335c:	bf 92       	push	r11
   1335e:	cf 92       	push	r12
   13360:	df 92       	push	r13
   13362:	ff 92       	push	r15
   13364:	0f 93       	push	r16
   13366:	1f 93       	push	r17
   13368:	df 93       	push	r29
   1336a:	cf 93       	push	r28
   1336c:	cd b7       	in	r28, 0x3d	; 61
   1336e:	de b7       	in	r29, 0x3e	; 62
   13370:	64 97       	sbiw	r28, 0x14	; 20
   13372:	0f b6       	in	r0, 0x3f	; 63
   13374:	f8 94       	cli
   13376:	de bf       	out	0x3e, r29	; 62
   13378:	0f be       	out	0x3f, r0	; 63
   1337a:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
   1337c:	83 e0       	ldi	r24, 0x03	; 3
   1337e:	61 e0       	ldi	r22, 0x01	; 1
   13380:	4d ee       	ldi	r20, 0xED	; 237
   13382:	5b e1       	ldi	r21, 0x1B	; 27
   13384:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   13388:	01 e0       	ldi	r16, 0x01	; 1
   1338a:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   1338c:	6e 01       	movw	r12, r28
   1338e:	08 94       	sec
   13390:	c1 1c       	adc	r12, r1
   13392:	d1 1c       	adc	r13, r1
   13394:	f9 ed       	ldi	r31, 0xD9	; 217
   13396:	af 2e       	mov	r10, r31
   13398:	fb e1       	ldi	r31, 0x1B	; 27
   1339a:	bf 2e       	mov	r11, r31
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1339c:	e1 99       	sbic	0x1c, 1	; 28
   1339e:	fe cf       	rjmp	.-4      	; 0x1339c <InitComport+0x42>
   133a0:	c8 01       	movw	r24, r16
   133a2:	81 59       	subi	r24, 0x91	; 145
   133a4:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   133a6:	9f bb       	out	0x1f, r25	; 31
   133a8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   133aa:	e0 9a       	sbi	0x1c, 0	; 28
   133ac:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   133ae:	22 e0       	ldi	r18, 0x02	; 2
   133b0:	f2 16       	cp	r15, r18
   133b2:	71 f0       	breq	.+28     	; 0x133d0 <InitComport+0x76>
   133b4:	f2 16       	cp	r15, r18
   133b6:	30 f0       	brcs	.+12     	; 0x133c4 <InitComport+0x6a>
   133b8:	33 e0       	ldi	r19, 0x03	; 3
   133ba:	f3 16       	cp	r15, r19
   133bc:	31 f4       	brne	.+12     	; 0x133ca <InitComport+0x70>
   133be:	85 eb       	ldi	r24, 0xB5	; 181
   133c0:	9f e2       	ldi	r25, 0x2F	; 47
   133c2:	08 c0       	rjmp	.+16     	; 0x133d4 <InitComport+0x7a>
   133c4:	80 e8       	ldi	r24, 0x80	; 128
   133c6:	95 e2       	ldi	r25, 0x25	; 37
   133c8:	05 c0       	rjmp	.+10     	; 0x133d4 <InitComport+0x7a>
   133ca:	80 e0       	ldi	r24, 0x00	; 0
   133cc:	90 e0       	ldi	r25, 0x00	; 0
   133ce:	02 c0       	rjmp	.+4      	; 0x133d4 <InitComport+0x7a>
   133d0:	80 e0       	ldi	r24, 0x00	; 0
   133d2:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   133d4:	ad b7       	in	r26, 0x3d	; 61
   133d6:	be b7       	in	r27, 0x3e	; 62
   133d8:	18 97       	sbiw	r26, 0x08	; 8
   133da:	0f b6       	in	r0, 0x3f	; 63
   133dc:	f8 94       	cli
   133de:	be bf       	out	0x3e, r27	; 62
   133e0:	0f be       	out	0x3f, r0	; 63
   133e2:	ad bf       	out	0x3d, r26	; 61
   133e4:	ed b7       	in	r30, 0x3d	; 61
   133e6:	fe b7       	in	r31, 0x3e	; 62
   133e8:	31 96       	adiw	r30, 0x01	; 1
   133ea:	12 96       	adiw	r26, 0x02	; 2
   133ec:	dc 92       	st	X, r13
   133ee:	ce 92       	st	-X, r12
   133f0:	11 97       	sbiw	r26, 0x01	; 1
   133f2:	b3 82       	std	Z+3, r11	; 0x03
   133f4:	a2 82       	std	Z+2, r10	; 0x02
   133f6:	15 83       	std	Z+5, r17	; 0x05
   133f8:	04 83       	std	Z+4, r16	; 0x04
   133fa:	97 83       	std	Z+7, r25	; 0x07
   133fc:	86 83       	std	Z+6, r24	; 0x06
   133fe:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 lcd_print(4,1,lcdteks);
   13402:	2d b7       	in	r18, 0x3d	; 61
   13404:	3e b7       	in	r19, 0x3e	; 62
   13406:	28 5f       	subi	r18, 0xF8	; 248
   13408:	3f 4f       	sbci	r19, 0xFF	; 255
   1340a:	0f b6       	in	r0, 0x3f	; 63
   1340c:	f8 94       	cli
   1340e:	3e bf       	out	0x3e, r19	; 62
   13410:	0f be       	out	0x3f, r0	; 63
   13412:	2d bf       	out	0x3d, r18	; 61
   13414:	84 e0       	ldi	r24, 0x04	; 4
   13416:	61 e0       	ldi	r22, 0x01	; 1
   13418:	a6 01       	movw	r20, r12
   1341a:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		 SetBaudRate(i+1,brMap);
   1341e:	80 2f       	mov	r24, r16
   13420:	6f 2d       	mov	r22, r15
   13422:	0e 94 99 96 	call	0x12d32	; 0x12d32 <SetBaudRate>
 	     TimDisplay=0;
   13426:	10 92 bc 01 	sts	0x01BC, r1
   1342a:	04 c0       	rjmp	.+8      	; 0x13434 <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
   1342c:	80 91 bc 01 	lds	r24, 0x01BC
   13430:	83 30       	cpi	r24, 0x03	; 3
   13432:	20 f4       	brcc	.+8      	; 0x1343c <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
   13434:	80 91 bc 01 	lds	r24, 0x01BC
   13438:	82 30       	cpi	r24, 0x02	; 2
   1343a:	c0 f3       	brcs	.-16     	; 0x1342c <InitComport+0xd2>
   1343c:	0f 5f       	subi	r16, 0xFF	; 255
   1343e:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
   13440:	05 30       	cpi	r16, 0x05	; 5
   13442:	11 05       	cpc	r17, r1
   13444:	09 f0       	breq	.+2      	; 0x13448 <InitComport+0xee>
   13446:	aa cf       	rjmp	.-172    	; 0x1339c <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
		 };

	 }
}
   13448:	64 96       	adiw	r28, 0x14	; 20
   1344a:	0f b6       	in	r0, 0x3f	; 63
   1344c:	f8 94       	cli
   1344e:	de bf       	out	0x3e, r29	; 62
   13450:	0f be       	out	0x3f, r0	; 63
   13452:	cd bf       	out	0x3d, r28	; 61
   13454:	cf 91       	pop	r28
   13456:	df 91       	pop	r29
   13458:	1f 91       	pop	r17
   1345a:	0f 91       	pop	r16
   1345c:	ff 90       	pop	r15
   1345e:	df 90       	pop	r13
   13460:	cf 90       	pop	r12
   13462:	bf 90       	pop	r11
   13464:	af 90       	pop	r10
   13466:	08 95       	ret

00013468 <sendMessage56>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);

}

void sendMessage56(){
   13468:	0f 93       	push	r16
   1346a:	1f 93       	push	r17
   1346c:	df 93       	push	r29
   1346e:	cf 93       	push	r28
   13470:	cd b7       	in	r28, 0x3d	; 61
   13472:	de b7       	in	r29, 0x3e	; 62
   13474:	ec 97       	sbiw	r28, 0x3c	; 60
   13476:	0f b6       	in	r0, 0x3f	; 63
   13478:	f8 94       	cli
   1347a:	de bf       	out	0x3e, r29	; 62
   1347c:	0f be       	out	0x3f, r0	; 63
   1347e:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
   13480:	81 e0       	ldi	r24, 0x01	; 1
   13482:	61 e0       	ldi	r22, 0x01	; 1
   13484:	41 e0       	ldi	r20, 0x01	; 1
   13486:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
   1348a:	0e 94 0b 1b 	call	0x3616	; 0x3616 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
   1348e:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
   13492:	0e 94 df 1c 	call	0x39be	; 0x39be <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
   13496:	0e 94 77 1c 	call	0x38ee	; 0x38ee <UpdateServerIP>
	UpdateCardID();  //ReadCardID
   1349a:	0e 94 95 3c 	call	0x792a	; 0x792a <UpdateCardID>

	sprintf_P(strSend,PSTR("%s%s%s"),strIFT_ID,strSeqNum,strClientIP);
   1349e:	8d b7       	in	r24, 0x3d	; 61
   134a0:	9e b7       	in	r25, 0x3e	; 62
   134a2:	0a 97       	sbiw	r24, 0x0a	; 10
   134a4:	0f b6       	in	r0, 0x3f	; 63
   134a6:	f8 94       	cli
   134a8:	9e bf       	out	0x3e, r25	; 62
   134aa:	0f be       	out	0x3f, r0	; 63
   134ac:	8d bf       	out	0x3d, r24	; 61
   134ae:	ed b7       	in	r30, 0x3d	; 61
   134b0:	fe b7       	in	r31, 0x3e	; 62
   134b2:	31 96       	adiw	r30, 0x01	; 1
   134b4:	8e 01       	movw	r16, r28
   134b6:	0f 5f       	subi	r16, 0xFF	; 255
   134b8:	1f 4f       	sbci	r17, 0xFF	; 255
   134ba:	ad b7       	in	r26, 0x3d	; 61
   134bc:	be b7       	in	r27, 0x3e	; 62
   134be:	12 96       	adiw	r26, 0x02	; 2
   134c0:	1c 93       	st	X, r17
   134c2:	0e 93       	st	-X, r16
   134c4:	11 97       	sbiw	r26, 0x01	; 1
   134c6:	86 ea       	ldi	r24, 0xA6	; 166
   134c8:	90 e2       	ldi	r25, 0x20	; 32
   134ca:	93 83       	std	Z+3, r25	; 0x03
   134cc:	82 83       	std	Z+2, r24	; 0x02
   134ce:	81 ef       	ldi	r24, 0xF1	; 241
   134d0:	95 e0       	ldi	r25, 0x05	; 5
   134d2:	95 83       	std	Z+5, r25	; 0x05
   134d4:	84 83       	std	Z+4, r24	; 0x04
   134d6:	86 ed       	ldi	r24, 0xD6	; 214
   134d8:	9d e0       	ldi	r25, 0x0D	; 13
   134da:	97 83       	std	Z+7, r25	; 0x07
   134dc:	86 83       	std	Z+6, r24	; 0x06
   134de:	85 ee       	ldi	r24, 0xE5	; 229
   134e0:	99 e0       	ldi	r25, 0x09	; 9
   134e2:	91 87       	std	Z+9, r25	; 0x09
   134e4:	80 87       	std	Z+8, r24	; 0x08
   134e6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
   134ea:	8d b7       	in	r24, 0x3d	; 61
   134ec:	9e b7       	in	r25, 0x3e	; 62
   134ee:	0a 96       	adiw	r24, 0x0a	; 10
   134f0:	0f b6       	in	r0, 0x3f	; 63
   134f2:	f8 94       	cli
   134f4:	9e bf       	out	0x3e, r25	; 62
   134f6:	0f be       	out	0x3f, r0	; 63
   134f8:	8d bf       	out	0x3d, r24	; 61
   134fa:	81 e0       	ldi	r24, 0x01	; 1
   134fc:	60 e0       	ldi	r22, 0x00	; 0
   134fe:	a8 01       	movw	r20, r16
   13500:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
	sprintf_P(strSend,PSTR("%s56"),strServerIP);
   13504:	00 d0       	rcall	.+0      	; 0x13506 <sendMessage56+0x9e>
   13506:	00 d0       	rcall	.+0      	; 0x13508 <sendMessage56+0xa0>
   13508:	00 d0       	rcall	.+0      	; 0x1350a <sendMessage56+0xa2>
   1350a:	ed b7       	in	r30, 0x3d	; 61
   1350c:	fe b7       	in	r31, 0x3e	; 62
   1350e:	31 96       	adiw	r30, 0x01	; 1
   13510:	ad b7       	in	r26, 0x3d	; 61
   13512:	be b7       	in	r27, 0x3e	; 62
   13514:	12 96       	adiw	r26, 0x02	; 2
   13516:	1c 93       	st	X, r17
   13518:	0e 93       	st	-X, r16
   1351a:	11 97       	sbiw	r26, 0x01	; 1
   1351c:	81 ea       	ldi	r24, 0xA1	; 161
   1351e:	90 e2       	ldi	r25, 0x20	; 32
   13520:	93 83       	std	Z+3, r25	; 0x03
   13522:	82 83       	std	Z+2, r24	; 0x02
   13524:	82 e1       	ldi	r24, 0x12	; 18
   13526:	9a e0       	ldi	r25, 0x0A	; 10
   13528:	95 83       	std	Z+5, r25	; 0x05
   1352a:	84 83       	std	Z+4, r24	; 0x04
   1352c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);
   13530:	8d b7       	in	r24, 0x3d	; 61
   13532:	9e b7       	in	r25, 0x3e	; 62
   13534:	06 96       	adiw	r24, 0x06	; 6
   13536:	0f b6       	in	r0, 0x3f	; 63
   13538:	f8 94       	cli
   1353a:	9e bf       	out	0x3e, r25	; 62
   1353c:	0f be       	out	0x3f, r0	; 63
   1353e:	8d bf       	out	0x3d, r24	; 61
   13540:	81 e0       	ldi	r24, 0x01	; 1
   13542:	60 e0       	ldi	r22, 0x00	; 0
   13544:	a8 01       	movw	r20, r16
   13546:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
    sprintf_P(strSend,PSTR("%s"),strCardID);
   1354a:	00 d0       	rcall	.+0      	; 0x1354c <sendMessage56+0xe4>
   1354c:	00 d0       	rcall	.+0      	; 0x1354e <sendMessage56+0xe6>
   1354e:	00 d0       	rcall	.+0      	; 0x13550 <sendMessage56+0xe8>
   13550:	ed b7       	in	r30, 0x3d	; 61
   13552:	fe b7       	in	r31, 0x3e	; 62
   13554:	31 96       	adiw	r30, 0x01	; 1
   13556:	ad b7       	in	r26, 0x3d	; 61
   13558:	be b7       	in	r27, 0x3e	; 62
   1355a:	12 96       	adiw	r26, 0x02	; 2
   1355c:	1c 93       	st	X, r17
   1355e:	0e 93       	st	-X, r16
   13560:	11 97       	sbiw	r26, 0x01	; 1
   13562:	8e e9       	ldi	r24, 0x9E	; 158
   13564:	90 e2       	ldi	r25, 0x20	; 32
   13566:	93 83       	std	Z+3, r25	; 0x03
   13568:	82 83       	std	Z+2, r24	; 0x02
   1356a:	8c e8       	ldi	r24, 0x8C	; 140
   1356c:	9d e0       	ldi	r25, 0x0D	; 13
   1356e:	95 83       	std	Z+5, r25	; 0x05
   13570:	84 83       	std	Z+4, r24	; 0x04
   13572:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
    _uart_print(1, 0,strSend);	
   13576:	8d b7       	in	r24, 0x3d	; 61
   13578:	9e b7       	in	r25, 0x3e	; 62
   1357a:	06 96       	adiw	r24, 0x06	; 6
   1357c:	0f b6       	in	r0, 0x3f	; 63
   1357e:	f8 94       	cli
   13580:	9e bf       	out	0x3e, r25	; 62
   13582:	0f be       	out	0x3f, r0	; 63
   13584:	8d bf       	out	0x3d, r24	; 61
   13586:	81 e0       	ldi	r24, 0x01	; 1
   13588:	60 e0       	ldi	r22, 0x00	; 0
   1358a:	a8 01       	movw	r20, r16
   1358c:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

	_uart_printf(1,0,PSTR("AF968CFFB"));
   13590:	81 e0       	ldi	r24, 0x01	; 1
   13592:	60 e0       	ldi	r22, 0x00	; 0
   13594:	44 e9       	ldi	r20, 0x94	; 148
   13596:	50 e2       	ldi	r21, 0x20	; 32
   13598:	0e 94 74 b4 	call	0x168e8	; 0x168e8 <_uart_printf>
	_uart(1, 1,0x02);
   1359c:	81 e0       	ldi	r24, 0x01	; 1
   1359e:	61 e0       	ldi	r22, 0x01	; 1
   135a0:	42 e0       	ldi	r20, 0x02	; 2
   135a2:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
}
   135a6:	ec 96       	adiw	r28, 0x3c	; 60
   135a8:	0f b6       	in	r0, 0x3f	; 63
   135aa:	f8 94       	cli
   135ac:	de bf       	out	0x3e, r29	; 62
   135ae:	0f be       	out	0x3f, r0	; 63
   135b0:	cd bf       	out	0x3d, r28	; 61
   135b2:	cf 91       	pop	r28
   135b4:	df 91       	pop	r29
   135b6:	1f 91       	pop	r17
   135b8:	0f 91       	pop	r16
   135ba:	08 95       	ret

000135bc <FMenuLocalAccount>:
		 }
	 else PORTG=PORTG|0x02;
}


char FMenuLocalAccount(){
   135bc:	af 92       	push	r10
   135be:	bf 92       	push	r11
   135c0:	cf 92       	push	r12
   135c2:	df 92       	push	r13
   135c4:	ef 92       	push	r14
   135c6:	ff 92       	push	r15
   135c8:	0f 93       	push	r16
   135ca:	1f 93       	push	r17
   135cc:	df 93       	push	r29
   135ce:	cf 93       	push	r28
   135d0:	cd b7       	in	r28, 0x3d	; 61
   135d2:	de b7       	in	r29, 0x3e	; 62
   135d4:	a9 97       	sbiw	r28, 0x29	; 41
   135d6:	0f b6       	in	r0, 0x3f	; 63
   135d8:	f8 94       	cli
   135da:	de bf       	out	0x3e, r29	; 62
   135dc:	0f be       	out	0x3f, r0	; 63
   135de:	cd bf       	out	0x3d, r28	; 61
       char strName[21],strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   135e0:	80 91 71 01 	lds	r24, 0x0171
   135e4:	90 e0       	ldi	r25, 0x00	; 0
   135e6:	fc 01       	movw	r30, r24
   135e8:	31 97       	sbiw	r30, 0x01	; 1
   135ea:	ef 31       	cpi	r30, 0x1F	; 31
   135ec:	f1 05       	cpc	r31, r1
   135ee:	10 f0       	brcs	.+4      	; 0x135f4 <FMenuLocalAccount+0x38>
   135f0:	0c 94 0d a5 	jmp	0x14a1a	; 0x14a1a <FMenuLocalAccount+0x145e>
   135f4:	eb 50       	subi	r30, 0x0B	; 11
   135f6:	ff 4f       	sbci	r31, 0xFF	; 255
   135f8:	ee 0f       	add	r30, r30
   135fa:	ff 1f       	adc	r31, r31
   135fc:	05 90       	lpm	r0, Z+
   135fe:	f4 91       	lpm	r31, Z+
   13600:	e0 2d       	mov	r30, r0
   13602:	09 94       	ijmp
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
   13604:	81 e0       	ldi	r24, 0x01	; 1
   13606:	80 93 e1 03 	sts	0x03E1, r24
   1360a:	10 92 e2 03 	sts	0x03E2, r1
   1360e:	80 91 65 00 	lds	r24, 0x0065
   13612:	8d 7f       	andi	r24, 0xFD	; 253
   13614:	80 93 65 00 	sts	0x0065, r24
   13618:	20 e0       	ldi	r18, 0x00	; 0
   1361a:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   1361c:	f9 01       	movw	r30, r18
   1361e:	e4 57       	subi	r30, 0x74	; 116
   13620:	f2 4f       	sbci	r31, 0xF2	; 242
   13622:	d9 01       	movw	r26, r18
   13624:	a9 5a       	subi	r26, 0xA9	; 169
   13626:	b1 4f       	sbci	r27, 0xF1	; 241
   13628:	8c 91       	ld	r24, X
   1362a:	80 83       	st	Z, r24
   1362c:	2f 5f       	subi	r18, 0xFF	; 255
   1362e:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   13630:	28 30       	cpi	r18, 0x08	; 8
   13632:	31 05       	cpc	r19, r1
   13634:	99 f7       	brne	.-26     	; 0x1361c <FMenuLocalAccount+0x60>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   13636:	10 92 94 0d 	sts	0x0D94, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   1363a:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   1363e:	81 e0       	ldi	r24, 0x01	; 1
   13640:	61 e0       	ldi	r22, 0x01	; 1
   13642:	43 ef       	ldi	r20, 0xF3	; 243
   13644:	5f e1       	ldi	r21, 0x1F	; 31
   13646:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   1364a:	00 d0       	rcall	.+0      	; 0x1364c <FMenuLocalAccount+0x90>
   1364c:	00 d0       	rcall	.+0      	; 0x1364e <FMenuLocalAccount+0x92>
   1364e:	00 d0       	rcall	.+0      	; 0x13650 <FMenuLocalAccount+0x94>
   13650:	ed b7       	in	r30, 0x3d	; 61
   13652:	fe b7       	in	r31, 0x3e	; 62
   13654:	31 96       	adiw	r30, 0x01	; 1
   13656:	8e 01       	movw	r16, r28
   13658:	0f 5f       	subi	r16, 0xFF	; 255
   1365a:	1f 4f       	sbci	r17, 0xFF	; 255
   1365c:	ad b7       	in	r26, 0x3d	; 61
   1365e:	be b7       	in	r27, 0x3e	; 62
   13660:	12 96       	adiw	r26, 0x02	; 2
   13662:	1c 93       	st	X, r17
   13664:	0e 93       	st	-X, r16
   13666:	11 97       	sbiw	r26, 0x01	; 1
   13668:	8d ee       	ldi	r24, 0xED	; 237
   1366a:	9f e1       	ldi	r25, 0x1F	; 31
   1366c:	93 83       	std	Z+3, r25	; 0x03
   1366e:	82 83       	std	Z+2, r24	; 0x02
   13670:	8c e8       	ldi	r24, 0x8C	; 140
   13672:	9d e0       	ldi	r25, 0x0D	; 13
   13674:	95 83       	std	Z+5, r25	; 0x05
   13676:	84 83       	std	Z+4, r24	; 0x04
   13678:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   1367c:	ed b7       	in	r30, 0x3d	; 61
   1367e:	fe b7       	in	r31, 0x3e	; 62
   13680:	36 96       	adiw	r30, 0x06	; 6
   13682:	0f b6       	in	r0, 0x3f	; 63
   13684:	f8 94       	cli
   13686:	fe bf       	out	0x3e, r31	; 62
   13688:	0f be       	out	0x3f, r0	; 63
   1368a:	ed bf       	out	0x3d, r30	; 61
   1368c:	82 e0       	ldi	r24, 0x02	; 2
   1368e:	61 e0       	ldi	r22, 0x01	; 1
   13690:	a8 01       	movw	r20, r16
   13692:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   13696:	83 e0       	ldi	r24, 0x03	; 3
   13698:	61 e0       	ldi	r22, 0x01	; 1
   1369a:	46 ee       	ldi	r20, 0xE6	; 230
   1369c:	5f e1       	ldi	r21, 0x1F	; 31
   1369e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				iPos=0;iLoop=0;
   136a2:	10 92 bc 03 	sts	0x03BC, r1
   136a6:	10 92 8c 03 	sts	0x038C, r1
   136aa:	10 92 8b 03 	sts	0x038B, r1
				IsFullAuthorized=False;
   136ae:	10 92 8d 03 	sts	0x038D, r1
		        stLocalAccount=laSendID;
   136b2:	82 e0       	ldi	r24, 0x02	; 2
   136b4:	df c6       	rjmp	.+3518   	; 0x14474 <FMenuLocalAccount+0xeb8>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   136b6:	10 92 d2 01 	sts	0x01D2, r1
                sendMessage56();
   136ba:	0e 94 34 9a 	call	0x13468	; 0x13468 <sendMessage56>
				iWait=0;iLoop=0;iPos=0;
   136be:	10 92 bb 03 	sts	0x03BB, r1
   136c2:	10 92 8c 03 	sts	0x038C, r1
   136c6:	10 92 8b 03 	sts	0x038B, r1
   136ca:	10 92 bc 03 	sts	0x03BC, r1
				stLocalAccount=laWaitMessage57;
   136ce:	83 e0       	ldi	r24, 0x03	; 3
   136d0:	d1 c6       	rjmp	.+3490   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laWaitMessage57:
		        iLoop++;
   136d2:	80 91 8b 03 	lds	r24, 0x038B
   136d6:	90 91 8c 03 	lds	r25, 0x038C
   136da:	01 96       	adiw	r24, 0x01	; 1
   136dc:	90 93 8c 03 	sts	0x038C, r25
   136e0:	80 93 8b 03 	sts	0x038B, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   136e4:	68 e9       	ldi	r22, 0x98	; 152
   136e6:	7a e3       	ldi	r23, 0x3A	; 58
   136e8:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
   136ec:	89 2b       	or	r24, r25
   136ee:	e1 f4       	brne	.+56     	; 0x13728 <FMenuLocalAccount+0x16c>
				   if (iPos<5){
   136f0:	60 91 bc 03 	lds	r22, 0x03BC
   136f4:	65 30       	cpi	r22, 0x05	; 5
   136f6:	58 f4       	brcc	.+22     	; 0x1370e <FMenuLocalAccount+0x152>
					   lcd_put(3,(8+iPos),'.');
   136f8:	68 5f       	subi	r22, 0xF8	; 248
   136fa:	83 e0       	ldi	r24, 0x03	; 3
   136fc:	4e e2       	ldi	r20, 0x2E	; 46
   136fe:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
				       iPos++;
   13702:	80 91 bc 03 	lds	r24, 0x03BC
   13706:	8f 5f       	subi	r24, 0xFF	; 255
   13708:	80 93 bc 03 	sts	0x03BC, r24
   1370c:	0d c0       	rjmp	.+26     	; 0x13728 <FMenuLocalAccount+0x16c>
					   }
				   else{
				       iPos=0;
   1370e:	10 92 bc 03 	sts	0x03BC, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   13712:	83 e0       	ldi	r24, 0x03	; 3
   13714:	69 e0       	ldi	r22, 0x09	; 9
   13716:	4e ed       	ldi	r20, 0xDE	; 222
   13718:	5f e1       	ldi	r21, 0x1F	; 31
   1371a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					   iWait++;
   1371e:	80 91 bb 03 	lds	r24, 0x03BB
   13722:	8f 5f       	subi	r24, 0xFF	; 255
   13724:	80 93 bb 03 	sts	0x03BB, r24
					   }
				}
				if (iWait>3){
   13728:	80 91 bb 03 	lds	r24, 0x03BB
   1372c:	84 30       	cpi	r24, 0x04	; 4
   1372e:	78 f0       	brcs	.+30     	; 0x1374e <FMenuLocalAccount+0x192>
				    stLocalAccount=laConTimout;
   13730:	84 e0       	ldi	r24, 0x04	; 4
   13732:	80 93 71 01 	sts	0x0171, r24
					TimLocAcc=0;
   13736:	10 92 e9 01 	sts	0x01E9, r1
   1373a:	10 92 e8 01 	sts	0x01E8, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1373e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13740:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13742:	82 e0       	ldi	r24, 0x02	; 2
   13744:	90 e0       	ldi	r25, 0x00	; 0
   13746:	90 93 ed 01 	sts	0x01ED, r25
   1374a:	80 93 ec 01 	sts	0x01EC, r24
				if (iWait>3){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage57==True){
   1374e:	80 91 d2 01 	lds	r24, 0x01D2
   13752:	81 30       	cpi	r24, 0x01	; 1
   13754:	11 f0       	breq	.+4      	; 0x1375a <FMenuLocalAccount+0x19e>
   13756:	0c 94 0d a5 	jmp	0x14a1a	; 0x14a1a <FMenuLocalAccount+0x145e>
				    IsMessage57=False;
   1375a:	10 92 d2 01 	sts	0x01D2, r1
				    stLocalAccount=laProcMessage57;
   1375e:	85 e0       	ldi	r24, 0x05	; 5
   13760:	89 c6       	rjmp	.+3346   	; 0x14474 <FMenuLocalAccount+0xeb8>
					}
		        break;
           case laConTimout:
		        IsErrorTCPIP=True;
   13762:	81 e0       	ldi	r24, 0x01	; 1
   13764:	80 93 ca 01 	sts	0x01CA, r24
				lcd_printf(3,1,PSTR("Sending Failed      "));
   13768:	83 e0       	ldi	r24, 0x03	; 3
   1376a:	61 e0       	ldi	r22, 0x01	; 1
   1376c:	49 ec       	ldi	r20, 0xC9	; 201
   1376e:	5f e1       	ldi	r21, 0x1F	; 31
   13770:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   13774:	84 e0       	ldi	r24, 0x04	; 4
   13776:	61 e0       	ldi	r22, 0x01	; 1
   13778:	44 eb       	ldi	r20, 0xB4	; 180
   1377a:	5f e1       	ldi	r21, 0x1F	; 31
   1377c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   13780:	80 91 e8 01 	lds	r24, 0x01E8
   13784:	90 91 e9 01 	lds	r25, 0x01E9
   13788:	03 97       	sbiw	r24, 0x03	; 3
   1378a:	10 f4       	brcc	.+4      	; 0x13790 <FMenuLocalAccount+0x1d4>
   1378c:	0c 94 0d a5 	jmp	0x14a1a	; 0x14a1a <FMenuLocalAccount+0x145e>
   13790:	0c 94 04 a5 	jmp	0x14a08	; 0x14a08 <FMenuLocalAccount+0x144c>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   13794:	83 e0       	ldi	r24, 0x03	; 3
   13796:	61 e0       	ldi	r22, 0x01	; 1
   13798:	4f e9       	ldi	r20, 0x9F	; 159
   1379a:	5f e1       	ldi	r21, 0x1F	; 31
   1379c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   137a0:	0e 94 75 24 	call	0x48ea	; 0x48ea <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   137a4:	81 30       	cpi	r24, 0x01	; 1
   137a6:	29 f0       	breq	.+10     	; 0x137b2 <FMenuLocalAccount+0x1f6>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   137a8:	82 30       	cpi	r24, 0x02	; 2
   137aa:	19 f0       	breq	.+6      	; 0x137b2 <FMenuLocalAccount+0x1f6>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   137ac:	83 30       	cpi	r24, 0x03	; 3
   137ae:	09 f0       	breq	.+2      	; 0x137b2 <FMenuLocalAccount+0x1f6>
   137b0:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   137b2:	80 93 bd 03 	sts	0x03BD, r24
				TimLocAcc=0;
   137b6:	10 92 e9 01 	sts	0x01E9, r1
   137ba:	10 92 e8 01 	sts	0x01E8, r1
				stLocalAccount=laDispStatus;
   137be:	86 e0       	ldi	r24, 0x06	; 6
   137c0:	59 c6       	rjmp	.+3250   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   137c2:	80 91 bd 03 	lds	r24, 0x03BD
   137c6:	81 30       	cpi	r24, 0x01	; 1
   137c8:	29 f4       	brne	.+10     	; 0x137d4 <FMenuLocalAccount+0x218>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   137ca:	83 e0       	ldi	r24, 0x03	; 3
   137cc:	61 e0       	ldi	r22, 0x01	; 1
   137ce:	4a e8       	ldi	r20, 0x8A	; 138
   137d0:	5f e1       	ldi	r21, 0x1F	; 31
   137d2:	0d c0       	rjmp	.+26     	; 0x137ee <FMenuLocalAccount+0x232>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   137d4:	82 30       	cpi	r24, 0x02	; 2
   137d6:	31 f4       	brne	.+12     	; 0x137e4 <FMenuLocalAccount+0x228>
				    stLocalAccount=laDispValid; 
   137d8:	87 e0       	ldi	r24, 0x07	; 7
   137da:	80 93 71 01 	sts	0x0171, r24
					lcd_clear();
   137de:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   137e2:	0e c0       	rjmp	.+28     	; 0x13800 <FMenuLocalAccount+0x244>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   137e4:	83 30       	cpi	r24, 0x03	; 3
   137e6:	61 f4       	brne	.+24     	; 0x13800 <FMenuLocalAccount+0x244>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   137e8:	61 e0       	ldi	r22, 0x01	; 1
   137ea:	45 e7       	ldi	r20, 0x75	; 117
   137ec:	5f e1       	ldi	r21, 0x1F	; 31
   137ee:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					TimLocAcc=0;
   137f2:	10 92 e9 01 	sts	0x01E9, r1
   137f6:	10 92 e8 01 	sts	0x01E8, r1
				    stLocalAccount=laDelayExit;
   137fa:	8e e1       	ldi	r24, 0x1E	; 30
   137fc:	80 93 71 01 	sts	0x0171, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   13800:	80 91 e8 01 	lds	r24, 0x01E8
   13804:	90 91 e9 01 	lds	r25, 0x01E9
   13808:	06 97       	sbiw	r24, 0x06	; 6
   1380a:	10 f4       	brcc	.+4      	; 0x13810 <FMenuLocalAccount+0x254>
   1380c:	0c 94 0d a5 	jmp	0x14a1a	; 0x14a1a <FMenuLocalAccount+0x145e>
   13810:	0c 94 04 a5 	jmp	0x14a08	; 0x14a08 <FMenuLocalAccount+0x144c>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   13814:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   13818:	00 d0       	rcall	.+0      	; 0x1381a <FMenuLocalAccount+0x25e>
   1381a:	00 d0       	rcall	.+0      	; 0x1381c <FMenuLocalAccount+0x260>
   1381c:	00 d0       	rcall	.+0      	; 0x1381e <FMenuLocalAccount+0x262>
   1381e:	ed b7       	in	r30, 0x3d	; 61
   13820:	fe b7       	in	r31, 0x3e	; 62
   13822:	31 96       	adiw	r30, 0x01	; 1
   13824:	85 e2       	ldi	r24, 0x25	; 37
   13826:	9e e0       	ldi	r25, 0x0E	; 14
   13828:	ad b7       	in	r26, 0x3d	; 61
   1382a:	be b7       	in	r27, 0x3e	; 62
   1382c:	12 96       	adiw	r26, 0x02	; 2
   1382e:	9c 93       	st	X, r25
   13830:	8e 93       	st	-X, r24
   13832:	11 97       	sbiw	r26, 0x01	; 1
   13834:	82 e7       	ldi	r24, 0x72	; 114
   13836:	9f e1       	ldi	r25, 0x1F	; 31
   13838:	93 83       	std	Z+3, r25	; 0x03
   1383a:	82 83       	std	Z+2, r24	; 0x02
   1383c:	0e ef       	ldi	r16, 0xFE	; 254
   1383e:	1d e0       	ldi	r17, 0x0D	; 13
   13840:	15 83       	std	Z+5, r17	; 0x05
   13842:	04 83       	std	Z+4, r16	; 0x04
   13844:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				FormatCurrency(strBalance);
   13848:	ed b7       	in	r30, 0x3d	; 61
   1384a:	fe b7       	in	r31, 0x3e	; 62
   1384c:	36 96       	adiw	r30, 0x06	; 6
   1384e:	0f b6       	in	r0, 0x3f	; 63
   13850:	f8 94       	cli
   13852:	fe bf       	out	0x3e, r31	; 62
   13854:	0f be       	out	0x3f, r0	; 63
   13856:	ed bf       	out	0x3d, r30	; 61
   13858:	c8 01       	movw	r24, r16
   1385a:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <FormatCurrency>
   1385e:	20 e0       	ldi	r18, 0x00	; 0
   13860:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   13862:	65 e1       	ldi	r22, 0x15	; 21
   13864:	e6 2e       	mov	r14, r22
   13866:	f1 2c       	mov	r15, r1
   13868:	ec 0e       	add	r14, r28
   1386a:	fd 1e       	adc	r15, r29
   1386c:	f7 01       	movw	r30, r14
   1386e:	e2 0f       	add	r30, r18
   13870:	f3 1f       	adc	r31, r19
   13872:	d9 01       	movw	r26, r18
   13874:	a7 5d       	subi	r26, 0xD7	; 215
   13876:	ba 4f       	sbci	r27, 0xFA	; 250
   13878:	8c 91       	ld	r24, X
   1387a:	80 83       	st	Z, r24
   1387c:	2f 5f       	subi	r18, 0xFF	; 255
   1387e:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   13880:	24 31       	cpi	r18, 0x14	; 20
   13882:	31 05       	cpc	r19, r1
   13884:	99 f7       	brne	.-26     	; 0x1386c <FMenuLocalAccount+0x2b0>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   13886:	19 a6       	std	Y+41, r1	; 0x29
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   13888:	00 d0       	rcall	.+0      	; 0x1388a <FMenuLocalAccount+0x2ce>
   1388a:	00 d0       	rcall	.+0      	; 0x1388c <FMenuLocalAccount+0x2d0>
   1388c:	00 d0       	rcall	.+0      	; 0x1388e <FMenuLocalAccount+0x2d2>
   1388e:	ed b7       	in	r30, 0x3d	; 61
   13890:	fe b7       	in	r31, 0x3e	; 62
   13892:	31 96       	adiw	r30, 0x01	; 1
   13894:	8e 01       	movw	r16, r28
   13896:	0f 5f       	subi	r16, 0xFF	; 255
   13898:	1f 4f       	sbci	r17, 0xFF	; 255
   1389a:	ad b7       	in	r26, 0x3d	; 61
   1389c:	be b7       	in	r27, 0x3e	; 62
   1389e:	12 96       	adiw	r26, 0x02	; 2
   138a0:	1c 93       	st	X, r17
   138a2:	0e 93       	st	-X, r16
   138a4:	11 97       	sbiw	r26, 0x01	; 1
   138a6:	8f e6       	ldi	r24, 0x6F	; 111
   138a8:	9f e1       	ldi	r25, 0x1F	; 31
   138aa:	93 83       	std	Z+3, r25	; 0x03
   138ac:	82 83       	std	Z+2, r24	; 0x02
   138ae:	83 e8       	ldi	r24, 0x83	; 131
   138b0:	99 e0       	ldi	r25, 0x09	; 9
   138b2:	95 83       	std	Z+5, r25	; 0x05
   138b4:	84 83       	std	Z+4, r24	; 0x04
   138b6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   138ba:	ed b7       	in	r30, 0x3d	; 61
   138bc:	fe b7       	in	r31, 0x3e	; 62
   138be:	36 96       	adiw	r30, 0x06	; 6
   138c0:	0f b6       	in	r0, 0x3f	; 63
   138c2:	f8 94       	cli
   138c4:	fe bf       	out	0x3e, r31	; 62
   138c6:	0f be       	out	0x3f, r0	; 63
   138c8:	ed bf       	out	0x3d, r30	; 61
   138ca:	81 e0       	ldi	r24, 0x01	; 1
   138cc:	61 e0       	ldi	r22, 0x01	; 1
   138ce:	a8 01       	movw	r20, r16
   138d0:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   138d4:	00 d0       	rcall	.+0      	; 0x138d6 <FMenuLocalAccount+0x31a>
   138d6:	00 d0       	rcall	.+0      	; 0x138d8 <FMenuLocalAccount+0x31c>
   138d8:	00 d0       	rcall	.+0      	; 0x138da <FMenuLocalAccount+0x31e>
   138da:	ed b7       	in	r30, 0x3d	; 61
   138dc:	fe b7       	in	r31, 0x3e	; 62
   138de:	31 96       	adiw	r30, 0x01	; 1
   138e0:	ad b7       	in	r26, 0x3d	; 61
   138e2:	be b7       	in	r27, 0x3e	; 62
   138e4:	12 96       	adiw	r26, 0x02	; 2
   138e6:	1c 93       	st	X, r17
   138e8:	0e 93       	st	-X, r16
   138ea:	11 97       	sbiw	r26, 0x01	; 1
   138ec:	8c e6       	ldi	r24, 0x6C	; 108
   138ee:	9f e1       	ldi	r25, 0x1F	; 31
   138f0:	93 83       	std	Z+3, r25	; 0x03
   138f2:	82 83       	std	Z+2, r24	; 0x02
   138f4:	f5 82       	std	Z+5, r15	; 0x05
   138f6:	e4 82       	std	Z+4, r14	; 0x04
   138f8:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   138fc:	ed b7       	in	r30, 0x3d	; 61
   138fe:	fe b7       	in	r31, 0x3e	; 62
   13900:	36 96       	adiw	r30, 0x06	; 6
   13902:	0f b6       	in	r0, 0x3f	; 63
   13904:	f8 94       	cli
   13906:	fe bf       	out	0x3e, r31	; 62
   13908:	0f be       	out	0x3f, r0	; 63
   1390a:	ed bf       	out	0x3d, r30	; 61
   1390c:	82 e0       	ldi	r24, 0x02	; 2
   1390e:	61 e0       	ldi	r22, 0x01	; 1
   13910:	a8 01       	movw	r20, r16
   13912:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   13916:	2d b7       	in	r18, 0x3d	; 61
   13918:	3e b7       	in	r19, 0x3e	; 62
   1391a:	28 50       	subi	r18, 0x08	; 8
   1391c:	30 40       	sbci	r19, 0x00	; 0
   1391e:	0f b6       	in	r0, 0x3f	; 63
   13920:	f8 94       	cli
   13922:	3e bf       	out	0x3e, r19	; 62
   13924:	0f be       	out	0x3f, r0	; 63
   13926:	2d bf       	out	0x3d, r18	; 61
   13928:	ed b7       	in	r30, 0x3d	; 61
   1392a:	fe b7       	in	r31, 0x3e	; 62
   1392c:	31 96       	adiw	r30, 0x01	; 1
   1392e:	ad b7       	in	r26, 0x3d	; 61
   13930:	be b7       	in	r27, 0x3e	; 62
   13932:	12 96       	adiw	r26, 0x02	; 2
   13934:	1c 93       	st	X, r17
   13936:	0e 93       	st	-X, r16
   13938:	11 97       	sbiw	r26, 0x01	; 1
   1393a:	86 e6       	ldi	r24, 0x66	; 102
   1393c:	9f e1       	ldi	r25, 0x1F	; 31
   1393e:	93 83       	std	Z+3, r25	; 0x03
   13940:	82 83       	std	Z+2, r24	; 0x02
   13942:	8d ef       	ldi	r24, 0xFD	; 253
   13944:	9a e0       	ldi	r25, 0x0A	; 10
   13946:	95 83       	std	Z+5, r25	; 0x05
   13948:	84 83       	std	Z+4, r24	; 0x04
   1394a:	8e ef       	ldi	r24, 0xFE	; 254
   1394c:	9d e0       	ldi	r25, 0x0D	; 13
   1394e:	97 83       	std	Z+7, r25	; 0x07
   13950:	86 83       	std	Z+6, r24	; 0x06
   13952:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   13956:	ed b7       	in	r30, 0x3d	; 61
   13958:	fe b7       	in	r31, 0x3e	; 62
   1395a:	38 96       	adiw	r30, 0x08	; 8
   1395c:	0f b6       	in	r0, 0x3f	; 63
   1395e:	f8 94       	cli
   13960:	fe bf       	out	0x3e, r31	; 62
   13962:	0f be       	out	0x3f, r0	; 63
   13964:	ed bf       	out	0x3d, r30	; 61
   13966:	83 e0       	ldi	r24, 0x03	; 3
   13968:	61 e0       	ldi	r22, 0x01	; 1
   1396a:	a8 01       	movw	r20, r16
   1396c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   13970:	84 e0       	ldi	r24, 0x04	; 4
   13972:	61 e0       	ldi	r22, 0x01	; 1
   13974:	41 e5       	ldi	r20, 0x51	; 81
   13976:	5f e1       	ldi	r21, 0x1F	; 31
   13978:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				stLocalAccount=laDispValidInput;
   1397c:	88 e0       	ldi	r24, 0x08	; 8
   1397e:	7a c5       	rjmp	.+2804   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   13980:	81 e0       	ldi	r24, 0x01	; 1
   13982:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   13986:	80 93 b5 03 	sts	0x03B5, r24
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   1398a:	87 3b       	cpi	r24, 0xB7	; 183
   1398c:	09 f4       	brne	.+2      	; 0x13990 <FMenuLocalAccount+0x3d4>
   1398e:	84 c2       	rjmp	.+1288   	; 0x13e98 <FMenuLocalAccount+0x8dc>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   13990:	87 3e       	cpi	r24, 0xE7	; 231
   13992:	11 f0       	breq	.+4      	; 0x13998 <FMenuLocalAccount+0x3dc>
   13994:	0c 94 0d a5 	jmp	0x14a1a	; 0x14a1a <FMenuLocalAccount+0x145e>
   13998:	0c 94 04 a5 	jmp	0x14a08	; 0x14a08 <FMenuLocalAccount+0x144c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   1399c:	8b e9       	ldi	r24, 0x9B	; 155
   1399e:	93 e0       	ldi	r25, 0x03	; 3
   139a0:	65 e4       	ldi	r22, 0x45	; 69
   139a2:	70 e0       	ldi	r23, 0x00	; 0
   139a4:	48 e0       	ldi	r20, 0x08	; 8
   139a6:	50 e0       	ldi	r21, 0x00	; 0
   139a8:	27 e9       	ldi	r18, 0x97	; 151
   139aa:	32 e1       	ldi	r19, 0x12	; 18
   139ac:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
		        break;
           case laSelectFIP:       
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
   139b0:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   139b4:	10 92 8c 03 	sts	0x038C, r1
   139b8:	10 92 8b 03 	sts	0x038B, r1
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
   139bc:	8e 01       	movw	r16, r28
   139be:	0f 5f       	subi	r16, 0xFF	; 255
   139c0:	1f 4f       	sbci	r17, 0xFF	; 255
   139c2:	5d e3       	ldi	r21, 0x3D	; 61
   139c4:	e5 2e       	mov	r14, r21
   139c6:	5f e1       	ldi	r21, 0x1F	; 31
   139c8:	f5 2e       	mov	r15, r21
   139ca:	41 c0       	rjmp	.+130    	; 0x13a4e <FMenuLocalAccount+0x492>
   139cc:	8d b7       	in	r24, 0x3d	; 61
   139ce:	9e b7       	in	r25, 0x3e	; 62
   139d0:	0c 97       	sbiw	r24, 0x0c	; 12
   139d2:	0f b6       	in	r0, 0x3f	; 63
   139d4:	f8 94       	cli
   139d6:	9e bf       	out	0x3e, r25	; 62
   139d8:	0f be       	out	0x3f, r0	; 63
   139da:	8d bf       	out	0x3d, r24	; 61
   139dc:	ed b7       	in	r30, 0x3d	; 61
   139de:	fe b7       	in	r31, 0x3e	; 62
   139e0:	31 96       	adiw	r30, 0x01	; 1
   139e2:	ad b7       	in	r26, 0x3d	; 61
   139e4:	be b7       	in	r27, 0x3e	; 62
   139e6:	12 96       	adiw	r26, 0x02	; 2
   139e8:	1c 93       	st	X, r17
   139ea:	0e 93       	st	-X, r16
   139ec:	11 97       	sbiw	r26, 0x01	; 1
   139ee:	f3 82       	std	Z+3, r15	; 0x03
   139f0:	e2 82       	std	Z+2, r14	; 0x02
   139f2:	2f 5f       	subi	r18, 0xFF	; 255
   139f4:	3f 4f       	sbci	r19, 0xFF	; 255
   139f6:	35 83       	std	Z+5, r19	; 0x05
   139f8:	24 83       	std	Z+4, r18	; 0x04
   139fa:	21 50       	subi	r18, 0x01	; 1
   139fc:	30 40       	sbci	r19, 0x00	; 0
   139fe:	d9 01       	movw	r26, r18
   13a00:	a5 56       	subi	r26, 0x65	; 101
   13a02:	bc 4f       	sbci	r27, 0xFC	; 252
   13a04:	8c 91       	ld	r24, X
   13a06:	86 83       	std	Z+6, r24	; 0x06
   13a08:	17 82       	std	Z+7, r1	; 0x07
   13a0a:	2b 5f       	subi	r18, 0xFB	; 251
   13a0c:	3f 4f       	sbci	r19, 0xFF	; 255
   13a0e:	31 87       	std	Z+9, r19	; 0x09
   13a10:	20 87       	std	Z+8, r18	; 0x08
   13a12:	14 96       	adiw	r26, 0x04	; 4
   13a14:	8c 91       	ld	r24, X
   13a16:	82 87       	std	Z+10, r24	; 0x0a
   13a18:	13 86       	std	Z+11, r1	; 0x0b
   13a1a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
					 lcd_print((iLoop+1),1,lcdteks);
   13a1e:	ed b7       	in	r30, 0x3d	; 61
   13a20:	fe b7       	in	r31, 0x3e	; 62
   13a22:	3c 96       	adiw	r30, 0x0c	; 12
   13a24:	0f b6       	in	r0, 0x3f	; 63
   13a26:	f8 94       	cli
   13a28:	fe bf       	out	0x3e, r31	; 62
   13a2a:	0f be       	out	0x3f, r0	; 63
   13a2c:	ed bf       	out	0x3d, r30	; 61
   13a2e:	80 91 8b 03 	lds	r24, 0x038B
   13a32:	8f 5f       	subi	r24, 0xFF	; 255
   13a34:	61 e0       	ldi	r22, 0x01	; 1
   13a36:	a8 01       	movw	r20, r16
   13a38:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13a3c:	80 91 8b 03 	lds	r24, 0x038B
   13a40:	90 91 8c 03 	lds	r25, 0x038C
   13a44:	01 96       	adiw	r24, 0x01	; 1
   13a46:	90 93 8c 03 	sts	0x038C, r25
   13a4a:	80 93 8b 03 	sts	0x038B, r24
   13a4e:	20 91 8b 03 	lds	r18, 0x038B
   13a52:	30 91 8c 03 	lds	r19, 0x038C
   13a56:	24 30       	cpi	r18, 0x04	; 4
   13a58:	31 05       	cpc	r19, r1
   13a5a:	08 f4       	brcc	.+2      	; 0x13a5e <FMenuLocalAccount+0x4a2>
   13a5c:	b7 cf       	rjmp	.-146    	; 0x139cc <FMenuLocalAccount+0x410>
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
					 lcd_print((iLoop+1),1,lcdteks);
					 }
		        lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
   13a5e:	81 e0       	ldi	r24, 0x01	; 1
   13a60:	6f e0       	ldi	r22, 0x0F	; 15
   13a62:	47 e3       	ldi	r20, 0x37	; 55
   13a64:	5f e1       	ldi	r21, 0x1F	; 31
   13a66:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
   13a6a:	82 e0       	ldi	r24, 0x02	; 2
   13a6c:	6f e0       	ldi	r22, 0x0F	; 15
   13a6e:	41 e3       	ldi	r20, 0x31	; 49
   13a70:	5f e1       	ldi	r21, 0x1F	; 31
   13a72:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
   13a76:	83 e0       	ldi	r24, 0x03	; 3
   13a78:	6f e0       	ldi	r22, 0x0F	; 15
   13a7a:	4b e2       	ldi	r20, 0x2B	; 43
   13a7c:	5f e1       	ldi	r21, 0x1F	; 31
   13a7e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	            lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
   13a82:	84 e0       	ldi	r24, 0x04	; 4
   13a84:	6f e0       	ldi	r22, 0x0F	; 15
   13a86:	44 e2       	ldi	r20, 0x24	; 36
   13a88:	5f e1       	ldi	r21, 0x1F	; 31
   13a8a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				//eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				iLoop=0;
   13a8e:	10 92 8c 03 	sts	0x038C, r1
   13a92:	10 92 8b 03 	sts	0x038B, r1
				stLocalAccount=laSelectFIPInput;
   13a96:	8a e0       	ldi	r24, 0x0A	; 10
   13a98:	ed c4       	rjmp	.+2522   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break; 
           case laSelectFIPInput:
			    //Blinking 50% _ 
			    iLoop++;
   13a9a:	80 91 8b 03 	lds	r24, 0x038B
   13a9e:	90 91 8c 03 	lds	r25, 0x038C
   13aa2:	01 96       	adiw	r24, 0x01	; 1
   13aa4:	90 93 8c 03 	sts	0x038C, r25
   13aa8:	80 93 8b 03 	sts	0x038B, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   13aac:	81 e0       	ldi	r24, 0x01	; 1
   13aae:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   13ab2:	80 93 b5 03 	sts	0x03B5, r24
			    KeyChar=_key_btn(KeyPressed);
   13ab6:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   13aba:	98 2f       	mov	r25, r24
   13abc:	80 93 ba 03 	sts	0x03BA, r24
				if ((KeyChar>='1')&&(KeyChar<='8')){
   13ac0:	81 53       	subi	r24, 0x31	; 49
   13ac2:	88 30       	cpi	r24, 0x08	; 8
   13ac4:	60 f4       	brcc	.+24     	; 0x13ade <FMenuLocalAccount+0x522>
				    if (KeyCharLast!=KeyChar){
   13ac6:	80 91 70 01 	lds	r24, 0x0170
   13aca:	89 17       	cp	r24, r25
   13acc:	41 f0       	breq	.+16     	; 0x13ade <FMenuLocalAccount+0x522>
					    KeyCharLast=KeyChar;
   13ace:	90 93 70 01 	sts	0x0170, r25
						iLoop=1000;
   13ad2:	88 ee       	ldi	r24, 0xE8	; 232
   13ad4:	93 e0       	ldi	r25, 0x03	; 3
   13ad6:	90 93 8c 03 	sts	0x038C, r25
   13ada:	80 93 8b 03 	sts	0x038B, r24
                    }
				}

			    if ((iLoop%2000)==0){
   13ade:	80 91 8b 03 	lds	r24, 0x038B
   13ae2:	90 91 8c 03 	lds	r25, 0x038C
   13ae6:	60 ed       	ldi	r22, 0xD0	; 208
   13ae8:	77 e0       	ldi	r23, 0x07	; 7
   13aea:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
   13aee:	89 2b       	or	r24, r25
   13af0:	39 f4       	brne	.+14     	; 0x13b00 <FMenuLocalAccount+0x544>
			       lcd_xy(1,19);_lcd('_'); 
   13af2:	81 e0       	ldi	r24, 0x01	; 1
   13af4:	63 e1       	ldi	r22, 0x13	; 19
   13af6:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   13afa:	8f e5       	ldi	r24, 0x5F	; 95
   13afc:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   13b00:	80 91 8b 03 	lds	r24, 0x038B
   13b04:	90 91 8c 03 	lds	r25, 0x038C
   13b08:	60 ed       	ldi	r22, 0xD0	; 208
   13b0a:	77 e0       	ldi	r23, 0x07	; 7
   13b0c:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
   13b10:	88 5e       	subi	r24, 0xE8	; 232
   13b12:	93 40       	sbci	r25, 0x03	; 3
   13b14:	41 f4       	brne	.+16     	; 0x13b26 <FMenuLocalAccount+0x56a>
			       lcd_xy(1,19);_lcd(KeyCharLast); 
   13b16:	81 e0       	ldi	r24, 0x01	; 1
   13b18:	63 e1       	ldi	r22, 0x13	; 19
   13b1a:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   13b1e:	80 91 70 01 	lds	r24, 0x0170
   13b22:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			    }
				if (((KeyChar>='1')&&(KeyChar<='8'))||
   13b26:	80 91 ba 03 	lds	r24, 0x03BA
   13b2a:	81 53       	subi	r24, 0x31	; 49
   13b2c:	88 30       	cpi	r24, 0x08	; 8
   13b2e:	50 f0       	brcs	.+20     	; 0x13b44 <FMenuLocalAccount+0x588>
   13b30:	80 91 b5 03 	lds	r24, 0x03B5
   13b34:	87 3b       	cpi	r24, 0xB7	; 183
   13b36:	09 f0       	breq	.+2      	; 0x13b3a <FMenuLocalAccount+0x57e>
   13b38:	57 c0       	rjmp	.+174    	; 0x13be8 <FMenuLocalAccount+0x62c>
   13b3a:	80 91 70 01 	lds	r24, 0x0170
   13b3e:	80 32       	cpi	r24, 0x20	; 32
   13b40:	09 f4       	brne	.+2      	; 0x13b44 <FMenuLocalAccount+0x588>
   13b42:	6b c7       	rjmp	.+3798   	; 0x14a1a <FMenuLocalAccount+0x145e>
				    (KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')
					){
				    stLocalAccount=laSelectProduct;
   13b44:	8b e0       	ldi	r24, 0x0B	; 11
   13b46:	80 93 71 01 	sts	0x0171, r24
					FIP_Used=FIP[KeyCharLast-'1'];
   13b4a:	e0 91 70 01 	lds	r30, 0x0170
   13b4e:	f0 e0       	ldi	r31, 0x00	; 0
   13b50:	e6 59       	subi	r30, 0x96	; 150
   13b52:	fc 4f       	sbci	r31, 0xFC	; 252
   13b54:	20 81       	ld	r18, Z
   13b56:	20 93 8f 03 	sts	0x038F, r18
					if (FIP_Used<=99){
   13b5a:	24 36       	cpi	r18, 0x64	; 100
   13b5c:	08 f0       	brcs	.+2      	; 0x13b60 <FMenuLocalAccount+0x5a4>
   13b5e:	5d c7       	rjmp	.+3770   	; 0x14a1a <FMenuLocalAccount+0x145e>
					    //leadingZero(FIP_Used,strFIP);
						//leadingZero(FIP_Used,strFIP_ID);
						sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   13b60:	00 d0       	rcall	.+0      	; 0x13b62 <FMenuLocalAccount+0x5a6>
   13b62:	00 d0       	rcall	.+0      	; 0x13b64 <FMenuLocalAccount+0x5a8>
   13b64:	00 d0       	rcall	.+0      	; 0x13b66 <FMenuLocalAccount+0x5aa>
   13b66:	ed b7       	in	r30, 0x3d	; 61
   13b68:	fe b7       	in	r31, 0x3e	; 62
   13b6a:	31 96       	adiw	r30, 0x01	; 1
   13b6c:	86 eb       	ldi	r24, 0xB6	; 182
   13b6e:	93 e0       	ldi	r25, 0x03	; 3
   13b70:	ad b7       	in	r26, 0x3d	; 61
   13b72:	be b7       	in	r27, 0x3e	; 62
   13b74:	12 96       	adiw	r26, 0x02	; 2
   13b76:	9c 93       	st	X, r25
   13b78:	8e 93       	st	-X, r24
   13b7a:	11 97       	sbiw	r26, 0x01	; 1
   13b7c:	8f e1       	ldi	r24, 0x1F	; 31
   13b7e:	9f e1       	ldi	r25, 0x1F	; 31
   13b80:	93 83       	std	Z+3, r25	; 0x03
   13b82:	82 83       	std	Z+2, r24	; 0x02
   13b84:	24 83       	std	Z+4, r18	; 0x04
   13b86:	15 82       	std	Z+5, r1	; 0x05
   13b88:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
						sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   13b8c:	ed b7       	in	r30, 0x3d	; 61
   13b8e:	fe b7       	in	r31, 0x3e	; 62
   13b90:	31 96       	adiw	r30, 0x01	; 1
   13b92:	83 ec       	ldi	r24, 0xC3	; 195
   13b94:	99 e0       	ldi	r25, 0x09	; 9
   13b96:	ad b7       	in	r26, 0x3d	; 61
   13b98:	be b7       	in	r27, 0x3e	; 62
   13b9a:	12 96       	adiw	r26, 0x02	; 2
   13b9c:	9c 93       	st	X, r25
   13b9e:	8e 93       	st	-X, r24
   13ba0:	11 97       	sbiw	r26, 0x01	; 1
   13ba2:	8a e1       	ldi	r24, 0x1A	; 26
   13ba4:	9f e1       	ldi	r25, 0x1F	; 31
   13ba6:	93 83       	std	Z+3, r25	; 0x03
   13ba8:	82 83       	std	Z+2, r24	; 0x02
   13baa:	80 91 8f 03 	lds	r24, 0x038F
   13bae:	84 83       	std	Z+4, r24	; 0x04
   13bb0:	15 82       	std	Z+5, r1	; 0x05
   13bb2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   13bb6:	ed b7       	in	r30, 0x3d	; 61
   13bb8:	fe b7       	in	r31, 0x3e	; 62
   13bba:	36 96       	adiw	r30, 0x06	; 6
   13bbc:	0f b6       	in	r0, 0x3f	; 63
   13bbe:	f8 94       	cli
   13bc0:	fe bf       	out	0x3e, r31	; 62
   13bc2:	0f be       	out	0x3f, r0	; 63
   13bc4:	ed bf       	out	0x3d, r30	; 61
   13bc6:	60 91 70 01 	lds	r22, 0x0170
   13bca:	86 e0       	ldi	r24, 0x06	; 6
   13bcc:	68 9f       	mul	r22, r24
   13bce:	b0 01       	movw	r22, r0
   13bd0:	11 24       	eor	r1, r1
   13bd2:	61 5d       	subi	r22, 0xD1	; 209
   13bd4:	70 40       	sbci	r23, 0x00	; 0
   13bd6:	83 ea       	ldi	r24, 0xA3	; 163
   13bd8:	93 e0       	ldi	r25, 0x03	; 3
   13bda:	46 e0       	ldi	r20, 0x06	; 6
   13bdc:	50 e0       	ldi	r21, 0x00	; 0
   13bde:	27 e9       	ldi	r18, 0x97	; 151
   13be0:	32 e1       	ldi	r19, 0x12	; 18
   13be2:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
   13be6:	19 c7       	rjmp	.+3634   	; 0x14a1a <FMenuLocalAccount+0x145e>

						eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[(KeyCharLast-'1')], 6);
						}
					}
				else
				if (KeyPressed==_KEY_CANCEL){
   13be8:	87 3e       	cpi	r24, 0xE7	; 231
   13bea:	09 f0       	breq	.+2      	; 0x13bee <FMenuLocalAccount+0x632>
   13bec:	16 c7       	rjmp	.+3628   	; 0x14a1a <FMenuLocalAccount+0x145e>
				    stLocalAccount=laDispValid;
   13bee:	87 e0       	ldi	r24, 0x07	; 7
   13bf0:	41 c4       	rjmp	.+2178   	; 0x14474 <FMenuLocalAccount+0xeb8>
					}
		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   13bf2:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   13bf6:	00 d0       	rcall	.+0      	; 0x13bf8 <FMenuLocalAccount+0x63c>
   13bf8:	00 d0       	rcall	.+0      	; 0x13bfa <FMenuLocalAccount+0x63e>
   13bfa:	00 d0       	rcall	.+0      	; 0x13bfc <FMenuLocalAccount+0x640>
   13bfc:	ed b7       	in	r30, 0x3d	; 61
   13bfe:	fe b7       	in	r31, 0x3e	; 62
   13c00:	31 96       	adiw	r30, 0x01	; 1
   13c02:	8e 01       	movw	r16, r28
   13c04:	0f 5f       	subi	r16, 0xFF	; 255
   13c06:	1f 4f       	sbci	r17, 0xFF	; 255
   13c08:	ad b7       	in	r26, 0x3d	; 61
   13c0a:	be b7       	in	r27, 0x3e	; 62
   13c0c:	12 96       	adiw	r26, 0x02	; 2
   13c0e:	1c 93       	st	X, r17
   13c10:	0e 93       	st	-X, r16
   13c12:	11 97       	sbiw	r26, 0x01	; 1
   13c14:	81 e1       	ldi	r24, 0x11	; 17
   13c16:	9f e1       	ldi	r25, 0x1F	; 31
   13c18:	93 83       	std	Z+3, r25	; 0x03
   13c1a:	82 83       	std	Z+2, r24	; 0x02
   13c1c:	86 eb       	ldi	r24, 0xB6	; 182
   13c1e:	93 e0       	ldi	r25, 0x03	; 3
   13c20:	95 83       	std	Z+5, r25	; 0x05
   13c22:	84 83       	std	Z+4, r24	; 0x04
   13c24:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   13c28:	ed b7       	in	r30, 0x3d	; 61
   13c2a:	fe b7       	in	r31, 0x3e	; 62
   13c2c:	36 96       	adiw	r30, 0x06	; 6
   13c2e:	0f b6       	in	r0, 0x3f	; 63
   13c30:	f8 94       	cli
   13c32:	fe bf       	out	0x3e, r31	; 62
   13c34:	0f be       	out	0x3f, r0	; 63
   13c36:	ed bf       	out	0x3d, r30	; 61
   13c38:	81 e0       	ldi	r24, 0x01	; 1
   13c3a:	61 e0       	ldi	r22, 0x01	; 1
   13c3c:	a8 01       	movw	r20, r16
   13c3e:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   13c42:	90 91 a3 03 	lds	r25, 0x03A3
   13c46:	89 2f       	mov	r24, r25
   13c48:	81 50       	subi	r24, 0x01	; 1
   13c4a:	86 30       	cpi	r24, 0x06	; 6
   13c4c:	08 f0       	brcs	.+2      	; 0x13c50 <FMenuLocalAccount+0x694>
   13c4e:	4b c0       	rjmp	.+150    	; 0x13ce6 <FMenuLocalAccount+0x72a>
   13c50:	80 91 a4 03 	lds	r24, 0x03A4
   13c54:	88 23       	and	r24, r24
   13c56:	09 f0       	breq	.+2      	; 0x13c5a <FMenuLocalAccount+0x69e>
   13c58:	46 c0       	rjmp	.+140    	; 0x13ce6 <FMenuLocalAccount+0x72a>
   13c5a:	80 91 a5 03 	lds	r24, 0x03A5
   13c5e:	88 23       	and	r24, r24
   13c60:	09 f0       	breq	.+2      	; 0x13c64 <FMenuLocalAccount+0x6a8>
   13c62:	41 c0       	rjmp	.+130    	; 0x13ce6 <FMenuLocalAccount+0x72a>
   13c64:	80 91 a6 03 	lds	r24, 0x03A6
   13c68:	88 23       	and	r24, r24
   13c6a:	e9 f5       	brne	.+122    	; 0x13ce6 <FMenuLocalAccount+0x72a>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   13c6c:	90 93 8e 03 	sts	0x038E, r25
   13c70:	6d e0       	ldi	r22, 0x0D	; 13
   13c72:	96 9f       	mul	r25, r22
   13c74:	b0 01       	movw	r22, r0
   13c76:	11 24       	eor	r1, r1
   13c78:	62 52       	subi	r22, 0x22	; 34
   13c7a:	7f 4f       	sbci	r23, 0xFF	; 255
   13c7c:	80 e9       	ldi	r24, 0x90	; 144
   13c7e:	93 e0       	ldi	r25, 0x03	; 3
   13c80:	4a e0       	ldi	r20, 0x0A	; 10
   13c82:	50 e0       	ldi	r21, 0x00	; 0
   13c84:	27 e9       	ldi	r18, 0x97	; 151
   13c86:	32 e1       	ldi	r19, 0x12	; 18
   13c88:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
   13c8c:	a0 e9       	ldi	r26, 0x90	; 144
   13c8e:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13c90:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13c92:	f3 e0       	ldi	r31, 0x03	; 3
   13c94:	a8 39       	cpi	r26, 0x98	; 152
   13c96:	bf 07       	cpc	r27, r31
   13c98:	d9 f7       	brne	.-10     	; 0x13c90 <FMenuLocalAccount+0x6d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13c9a:	1c 92       	st	X, r1
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   13c9c:	00 d0       	rcall	.+0      	; 0x13c9e <FMenuLocalAccount+0x6e2>
   13c9e:	00 d0       	rcall	.+0      	; 0x13ca0 <FMenuLocalAccount+0x6e4>
   13ca0:	00 d0       	rcall	.+0      	; 0x13ca2 <FMenuLocalAccount+0x6e6>
   13ca2:	2d b7       	in	r18, 0x3d	; 61
   13ca4:	3e b7       	in	r19, 0x3e	; 62
   13ca6:	2f 5f       	subi	r18, 0xFF	; 255
   13ca8:	3f 4f       	sbci	r19, 0xFF	; 255
   13caa:	88 e6       	ldi	r24, 0x68	; 104
   13cac:	99 e0       	ldi	r25, 0x09	; 9
   13cae:	ed b7       	in	r30, 0x3d	; 61
   13cb0:	fe b7       	in	r31, 0x3e	; 62
   13cb2:	92 83       	std	Z+2, r25	; 0x02
   13cb4:	81 83       	std	Z+1, r24	; 0x01
   13cb6:	8e e0       	ldi	r24, 0x0E	; 14
   13cb8:	9f e1       	ldi	r25, 0x1F	; 31
   13cba:	f9 01       	movw	r30, r18
   13cbc:	93 83       	std	Z+3, r25	; 0x03
   13cbe:	82 83       	std	Z+2, r24	; 0x02
   13cc0:	18 97       	sbiw	r26, 0x08	; 8
   13cc2:	b5 83       	std	Z+5, r27	; 0x05
   13cc4:	a4 83       	std	Z+4, r26	; 0x04
   13cc6:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   13cca:	8d e0       	ldi	r24, 0x0D	; 13
   13ccc:	80 93 71 01 	sts	0x0171, r24
   13cd0:	80 e0       	ldi	r24, 0x00	; 0
   13cd2:	2d b7       	in	r18, 0x3d	; 61
   13cd4:	3e b7       	in	r19, 0x3e	; 62
   13cd6:	2a 5f       	subi	r18, 0xFA	; 250
   13cd8:	3f 4f       	sbci	r19, 0xFF	; 255
   13cda:	0f b6       	in	r0, 0x3f	; 63
   13cdc:	f8 94       	cli
   13cde:	3e bf       	out	0x3e, r19	; 62
   13ce0:	0f be       	out	0x3f, r0	; 63
   13ce2:	2d bf       	out	0x3d, r18	; 61
   13ce4:	9b c6       	rjmp	.+3382   	; 0x14a1c <FMenuLocalAccount+0x1460>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13ce6:	10 92 b3 03 	sts	0x03B3, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   13cea:	8e 01       	movw	r16, r28
   13cec:	0f 5f       	subi	r16, 0xFF	; 255
   13cee:	1f 4f       	sbci	r17, 0xFF	; 255
   13cf0:	42 e0       	ldi	r20, 0x02	; 2
   13cf2:	c4 2e       	mov	r12, r20
   13cf4:	4f e1       	ldi	r20, 0x1F	; 31
   13cf6:	d4 2e       	mov	r13, r20
   13cf8:	3d e0       	ldi	r19, 0x0D	; 13
   13cfa:	a3 2e       	mov	r10, r19
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13cfc:	28 e0       	ldi	r18, 0x08	; 8
   13cfe:	e2 2e       	mov	r14, r18
   13d00:	2f e1       	ldi	r18, 0x1F	; 31
   13d02:	f2 2e       	mov	r15, r18
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13d04:	9b e0       	ldi	r25, 0x0B	; 11
   13d06:	b9 2e       	mov	r11, r25
   13d08:	6b c0       	rjmp	.+214    	; 0x13de0 <FMenuLocalAccount+0x824>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   13d0a:	f0 e0       	ldi	r31, 0x00	; 0
   13d0c:	ed 55       	subi	r30, 0x5D	; 93
   13d0e:	fc 4f       	sbci	r31, 0xFC	; 252
   13d10:	e0 81       	ld	r30, Z
   13d12:	e0 93 8e 03 	sts	0x038E, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   13d16:	8e 2f       	mov	r24, r30
   13d18:	81 50       	subi	r24, 0x01	; 1
   13d1a:	86 30       	cpi	r24, 0x06	; 6
   13d1c:	e8 f5       	brcc	.+122    	; 0x13d98 <FMenuLocalAccount+0x7dc>
   13d1e:	ea 9d       	mul	r30, r10
   13d20:	b0 01       	movw	r22, r0
   13d22:	11 24       	eor	r1, r1
   13d24:	62 52       	subi	r22, 0x22	; 34
   13d26:	7f 4f       	sbci	r23, 0xFF	; 255
   13d28:	80 e9       	ldi	r24, 0x90	; 144
   13d2a:	93 e0       	ldi	r25, 0x03	; 3
   13d2c:	4a e0       	ldi	r20, 0x0A	; 10
   13d2e:	50 e0       	ldi	r21, 0x00	; 0
   13d30:	27 e9       	ldi	r18, 0x97	; 151
   13d32:	32 e1       	ldi	r19, 0x12	; 18
   13d34:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
   13d38:	a0 e9       	ldi	r26, 0x90	; 144
   13d3a:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13d3c:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13d3e:	33 e0       	ldi	r19, 0x03	; 3
   13d40:	a8 39       	cpi	r26, 0x98	; 152
   13d42:	b3 07       	cpc	r27, r19
   13d44:	d9 f7       	brne	.-10     	; 0x13d3c <FMenuLocalAccount+0x780>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13d46:	1c 92       	st	X, r1
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13d48:	8d b7       	in	r24, 0x3d	; 61
   13d4a:	9e b7       	in	r25, 0x3e	; 62
   13d4c:	08 97       	sbiw	r24, 0x08	; 8
   13d4e:	0f b6       	in	r0, 0x3f	; 63
   13d50:	f8 94       	cli
   13d52:	9e bf       	out	0x3e, r25	; 62
   13d54:	0f be       	out	0x3f, r0	; 63
   13d56:	8d bf       	out	0x3d, r24	; 61
   13d58:	2d b7       	in	r18, 0x3d	; 61
   13d5a:	3e b7       	in	r19, 0x3e	; 62
   13d5c:	2f 5f       	subi	r18, 0xFF	; 255
   13d5e:	3f 4f       	sbci	r19, 0xFF	; 255
   13d60:	ed b7       	in	r30, 0x3d	; 61
   13d62:	fe b7       	in	r31, 0x3e	; 62
   13d64:	12 83       	std	Z+2, r17	; 0x02
   13d66:	01 83       	std	Z+1, r16	; 0x01
   13d68:	f9 01       	movw	r30, r18
   13d6a:	f3 82       	std	Z+3, r15	; 0x03
   13d6c:	e2 82       	std	Z+2, r14	; 0x02
   13d6e:	80 91 b3 03 	lds	r24, 0x03B3
   13d72:	90 e0       	ldi	r25, 0x00	; 0
   13d74:	01 96       	adiw	r24, 0x01	; 1
   13d76:	95 83       	std	Z+5, r25	; 0x05
   13d78:	84 83       	std	Z+4, r24	; 0x04
   13d7a:	18 97       	sbiw	r26, 0x08	; 8
   13d7c:	b7 83       	std	Z+7, r27	; 0x07
   13d7e:	a6 83       	std	Z+6, r26	; 0x06
   13d80:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   13d84:	2d b7       	in	r18, 0x3d	; 61
   13d86:	3e b7       	in	r19, 0x3e	; 62
   13d88:	28 5f       	subi	r18, 0xF8	; 248
   13d8a:	3f 4f       	sbci	r19, 0xFF	; 255
   13d8c:	0f b6       	in	r0, 0x3f	; 63
   13d8e:	f8 94       	cli
   13d90:	3e bf       	out	0x3e, r19	; 62
   13d92:	0f be       	out	0x3f, r0	; 63
   13d94:	2d bf       	out	0x3d, r18	; 61
   13d96:	12 c0       	rjmp	.+36     	; 0x13dbc <FMenuLocalAccount+0x800>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   13d98:	00 d0       	rcall	.+0      	; 0x13d9a <FMenuLocalAccount+0x7de>
   13d9a:	00 d0       	rcall	.+0      	; 0x13d9c <FMenuLocalAccount+0x7e0>
   13d9c:	ad b7       	in	r26, 0x3d	; 61
   13d9e:	be b7       	in	r27, 0x3e	; 62
   13da0:	12 96       	adiw	r26, 0x02	; 2
   13da2:	1c 93       	st	X, r17
   13da4:	0e 93       	st	-X, r16
   13da6:	11 97       	sbiw	r26, 0x01	; 1
   13da8:	14 96       	adiw	r26, 0x04	; 4
   13daa:	dc 92       	st	X, r13
   13dac:	ce 92       	st	-X, r12
   13dae:	13 97       	sbiw	r26, 0x03	; 3
   13db0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   13db4:	0f 90       	pop	r0
   13db6:	0f 90       	pop	r0
   13db8:	0f 90       	pop	r0
   13dba:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13dbc:	80 91 b3 03 	lds	r24, 0x03B3
   13dc0:	68 2f       	mov	r22, r24
   13dc2:	66 95       	lsr	r22
   13dc4:	6b 9d       	mul	r22, r11
   13dc6:	b0 01       	movw	r22, r0
   13dc8:	11 24       	eor	r1, r1
   13dca:	6f 5f       	subi	r22, 0xFF	; 255
   13dcc:	81 70       	andi	r24, 0x01	; 1
   13dce:	8e 5f       	subi	r24, 0xFE	; 254
   13dd0:	a8 01       	movw	r20, r16
   13dd2:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13dd6:	80 91 b3 03 	lds	r24, 0x03B3
   13dda:	8f 5f       	subi	r24, 0xFF	; 255
   13ddc:	80 93 b3 03 	sts	0x03B3, r24
   13de0:	e0 91 b3 03 	lds	r30, 0x03B3
   13de4:	e4 30       	cpi	r30, 0x04	; 4
   13de6:	08 f4       	brcc	.+2      	; 0x13dea <FMenuLocalAccount+0x82e>
   13de8:	90 cf       	rjmp	.-224    	; 0x13d0a <FMenuLocalAccount+0x74e>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   13dea:	84 e0       	ldi	r24, 0x04	; 4
   13dec:	61 e0       	ldi	r22, 0x01	; 1
   13dee:	4d ee       	ldi	r20, 0xED	; 237
   13df0:	5e e1       	ldi	r21, 0x1E	; 30
   13df2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				stLocalAccount=laSelectProductInput;
   13df6:	8c e0       	ldi	r24, 0x0C	; 12
   13df8:	3d c3       	rjmp	.+1658   	; 0x14474 <FMenuLocalAccount+0xeb8>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   13dfa:	81 e0       	ldi	r24, 0x01	; 1
   13dfc:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   13e00:	80 93 b5 03 	sts	0x03B5, r24
			    KeyChar=_key_btn(KeyPressed);
   13e04:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   13e08:	80 93 ba 03 	sts	0x03BA, r24
				if ((KeyChar>='1')&&(KeyChar<='4')){
   13e0c:	81 53       	subi	r24, 0x31	; 49
   13e0e:	84 30       	cpi	r24, 0x04	; 4
   13e10:	f0 f5       	brcc	.+124    	; 0x13e8e <FMenuLocalAccount+0x8d2>
				    iNozzle=KeyChar-'1';
   13e12:	80 93 b3 03 	sts	0x03B3, r24
   13e16:	00 e9       	ldi	r16, 0x90	; 144
   13e18:	13 e0       	ldi	r17, 0x03	; 3
   13e1a:	e8 2f       	mov	r30, r24
   13e1c:	f0 e0       	ldi	r31, 0x00	; 0
   13e1e:	ed 55       	subi	r30, 0x5D	; 93
   13e20:	fc 4f       	sbci	r31, 0xFC	; 252
   13e22:	60 81       	ld	r22, Z
   13e24:	8d e0       	ldi	r24, 0x0D	; 13
   13e26:	f8 2e       	mov	r15, r24
   13e28:	6f 9d       	mul	r22, r15
   13e2a:	b0 01       	movw	r22, r0
   13e2c:	11 24       	eor	r1, r1
   13e2e:	62 52       	subi	r22, 0x22	; 34
   13e30:	7f 4f       	sbci	r23, 0xFF	; 255
   13e32:	c8 01       	movw	r24, r16
   13e34:	4a e0       	ldi	r20, 0x0A	; 10
   13e36:	50 e0       	ldi	r21, 0x00	; 0
   13e38:	27 e9       	ldi	r18, 0x97	; 151
   13e3a:	32 e1       	ldi	r19, 0x12	; 18
   13e3c:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   13e40:	00 d0       	rcall	.+0      	; 0x13e42 <FMenuLocalAccount+0x886>
   13e42:	00 d0       	rcall	.+0      	; 0x13e44 <FMenuLocalAccount+0x888>
   13e44:	00 d0       	rcall	.+0      	; 0x13e46 <FMenuLocalAccount+0x88a>
   13e46:	ed b7       	in	r30, 0x3d	; 61
   13e48:	fe b7       	in	r31, 0x3e	; 62
   13e4a:	31 96       	adiw	r30, 0x01	; 1
   13e4c:	88 e6       	ldi	r24, 0x68	; 104
   13e4e:	99 e0       	ldi	r25, 0x09	; 9
   13e50:	ad b7       	in	r26, 0x3d	; 61
   13e52:	be b7       	in	r27, 0x3e	; 62
   13e54:	12 96       	adiw	r26, 0x02	; 2
   13e56:	9c 93       	st	X, r25
   13e58:	8e 93       	st	-X, r24
   13e5a:	11 97       	sbiw	r26, 0x01	; 1
   13e5c:	8a ee       	ldi	r24, 0xEA	; 234
   13e5e:	9e e1       	ldi	r25, 0x1E	; 30
   13e60:	93 83       	std	Z+3, r25	; 0x03
   13e62:	82 83       	std	Z+2, r24	; 0x02
   13e64:	15 83       	std	Z+5, r17	; 0x05
   13e66:	04 83       	std	Z+4, r16	; 0x04
   13e68:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
					NozzleID=iNozzle+1;
   13e6c:	80 91 b3 03 	lds	r24, 0x03B3
   13e70:	8f 5f       	subi	r24, 0xFF	; 255
   13e72:	80 93 77 09 	sts	0x0977, r24
                    stLocalAccount=laSelectBalanceType;
   13e76:	f0 92 71 01 	sts	0x0171, r15
					lcd_clear();
   13e7a:	ed b7       	in	r30, 0x3d	; 61
   13e7c:	fe b7       	in	r31, 0x3e	; 62
   13e7e:	36 96       	adiw	r30, 0x06	; 6
   13e80:	0f b6       	in	r0, 0x3f	; 63
   13e82:	f8 94       	cli
   13e84:	fe bf       	out	0x3e, r31	; 62
   13e86:	0f be       	out	0x3f, r0	; 63
   13e88:	ed bf       	out	0x3d, r30	; 61
   13e8a:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   13e8e:	80 91 b5 03 	lds	r24, 0x03B5
   13e92:	87 3e       	cpi	r24, 0xE7	; 231
   13e94:	09 f0       	breq	.+2      	; 0x13e98 <FMenuLocalAccount+0x8dc>
   13e96:	c1 c5       	rjmp	.+2946   	; 0x14a1a <FMenuLocalAccount+0x145e>
   13e98:	89 e0       	ldi	r24, 0x09	; 9
   13e9a:	ec c2       	rjmp	.+1496   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   13e9c:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   13ea0:	2d b7       	in	r18, 0x3d	; 61
   13ea2:	3e b7       	in	r19, 0x3e	; 62
   13ea4:	28 50       	subi	r18, 0x08	; 8
   13ea6:	30 40       	sbci	r19, 0x00	; 0
   13ea8:	0f b6       	in	r0, 0x3f	; 63
   13eaa:	f8 94       	cli
   13eac:	3e bf       	out	0x3e, r19	; 62
   13eae:	0f be       	out	0x3f, r0	; 63
   13eb0:	2d bf       	out	0x3d, r18	; 61
   13eb2:	ed b7       	in	r30, 0x3d	; 61
   13eb4:	fe b7       	in	r31, 0x3e	; 62
   13eb6:	31 96       	adiw	r30, 0x01	; 1
   13eb8:	8e 01       	movw	r16, r28
   13eba:	0f 5f       	subi	r16, 0xFF	; 255
   13ebc:	1f 4f       	sbci	r17, 0xFF	; 255
   13ebe:	ad b7       	in	r26, 0x3d	; 61
   13ec0:	be b7       	in	r27, 0x3e	; 62
   13ec2:	12 96       	adiw	r26, 0x02	; 2
   13ec4:	1c 93       	st	X, r17
   13ec6:	0e 93       	st	-X, r16
   13ec8:	11 97       	sbiw	r26, 0x01	; 1
   13eca:	82 ee       	ldi	r24, 0xE2	; 226
   13ecc:	9e e1       	ldi	r25, 0x1E	; 30
   13ece:	93 83       	std	Z+3, r25	; 0x03
   13ed0:	82 83       	std	Z+2, r24	; 0x02
   13ed2:	86 eb       	ldi	r24, 0xB6	; 182
   13ed4:	93 e0       	ldi	r25, 0x03	; 3
   13ed6:	95 83       	std	Z+5, r25	; 0x05
   13ed8:	84 83       	std	Z+4, r24	; 0x04
   13eda:	88 e6       	ldi	r24, 0x68	; 104
   13edc:	99 e0       	ldi	r25, 0x09	; 9
   13ede:	97 83       	std	Z+7, r25	; 0x07
   13ee0:	86 83       	std	Z+6, r24	; 0x06
   13ee2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   13ee6:	ed b7       	in	r30, 0x3d	; 61
   13ee8:	fe b7       	in	r31, 0x3e	; 62
   13eea:	38 96       	adiw	r30, 0x08	; 8
   13eec:	0f b6       	in	r0, 0x3f	; 63
   13eee:	f8 94       	cli
   13ef0:	fe bf       	out	0x3e, r31	; 62
   13ef2:	0f be       	out	0x3f, r0	; 63
   13ef4:	ed bf       	out	0x3d, r30	; 61
   13ef6:	81 e0       	ldi	r24, 0x01	; 1
   13ef8:	61 e0       	ldi	r22, 0x01	; 1
   13efa:	a8 01       	movw	r20, r16
   13efc:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   13f00:	82 e0       	ldi	r24, 0x02	; 2
   13f02:	61 e0       	ldi	r22, 0x01	; 1
   13f04:	4d ec       	ldi	r20, 0xCD	; 205
   13f06:	5e e1       	ldi	r21, 0x1E	; 30
   13f08:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   13f0c:	83 e0       	ldi	r24, 0x03	; 3
   13f0e:	61 e0       	ldi	r22, 0x01	; 1
   13f10:	48 eb       	ldi	r20, 0xB8	; 184
   13f12:	5e e1       	ldi	r21, 0x1E	; 30
   13f14:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   13f18:	84 e0       	ldi	r24, 0x04	; 4
   13f1a:	61 e0       	ldi	r22, 0x01	; 1
   13f1c:	43 ea       	ldi	r20, 0xA3	; 163
   13f1e:	5e e1       	ldi	r21, 0x1E	; 30
   13f20:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   13f24:	8e e0       	ldi	r24, 0x0E	; 14
   13f26:	a6 c2       	rjmp	.+1356   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   13f28:	81 e0       	ldi	r24, 0x01	; 1
   13f2a:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   13f2e:	80 93 b5 03 	sts	0x03B5, r24
			    KeyChar=_key_btn(KeyPressed);
   13f32:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   13f36:	98 2f       	mov	r25, r24
   13f38:	80 93 ba 03 	sts	0x03BA, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   13f3c:	81 53       	subi	r24, 0x31	; 49
   13f3e:	82 30       	cpi	r24, 0x02	; 2
   13f40:	80 f5       	brcc	.+96     	; 0x13fa2 <FMenuLocalAccount+0x9e6>
                    if(KeyChar=='1'){
   13f42:	91 33       	cpi	r25, 0x31	; 49
   13f44:	a1 f4       	brne	.+40     	; 0x13f6e <FMenuLocalAccount+0x9b2>
					   BalanceType=1;
   13f46:	81 e0       	ldi	r24, 0x01	; 1
   13f48:	80 93 b9 03 	sts	0x03B9, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   13f4c:	00 d0       	rcall	.+0      	; 0x13f4e <FMenuLocalAccount+0x992>
   13f4e:	00 d0       	rcall	.+0      	; 0x13f50 <FMenuLocalAccount+0x994>
   13f50:	88 ea       	ldi	r24, 0xA8	; 168
   13f52:	95 e0       	ldi	r25, 0x05	; 5
   13f54:	ad b7       	in	r26, 0x3d	; 61
   13f56:	be b7       	in	r27, 0x3e	; 62
   13f58:	12 96       	adiw	r26, 0x02	; 2
   13f5a:	9c 93       	st	X, r25
   13f5c:	8e 93       	st	-X, r24
   13f5e:	11 97       	sbiw	r26, 0x01	; 1
   13f60:	81 ea       	ldi	r24, 0xA1	; 161
   13f62:	9e e1       	ldi	r25, 0x1E	; 30
   13f64:	14 96       	adiw	r26, 0x04	; 4
   13f66:	9c 93       	st	X, r25
   13f68:	8e 93       	st	-X, r24
   13f6a:	13 97       	sbiw	r26, 0x03	; 3
   13f6c:	11 c0       	rjmp	.+34     	; 0x13f90 <FMenuLocalAccount+0x9d4>
					   }
					else
                    if(KeyChar=='2'){
   13f6e:	92 33       	cpi	r25, 0x32	; 50
   13f70:	a9 f4       	brne	.+42     	; 0x13f9c <FMenuLocalAccount+0x9e0>
					   BalanceType=2;
   13f72:	82 e0       	ldi	r24, 0x02	; 2
   13f74:	80 93 b9 03 	sts	0x03B9, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   13f78:	00 d0       	rcall	.+0      	; 0x13f7a <FMenuLocalAccount+0x9be>
   13f7a:	00 d0       	rcall	.+0      	; 0x13f7c <FMenuLocalAccount+0x9c0>
   13f7c:	88 ea       	ldi	r24, 0xA8	; 168
   13f7e:	95 e0       	ldi	r25, 0x05	; 5
   13f80:	ed b7       	in	r30, 0x3d	; 61
   13f82:	fe b7       	in	r31, 0x3e	; 62
   13f84:	92 83       	std	Z+2, r25	; 0x02
   13f86:	81 83       	std	Z+1, r24	; 0x01
   13f88:	8f e9       	ldi	r24, 0x9F	; 159
   13f8a:	9e e1       	ldi	r25, 0x1E	; 30
   13f8c:	94 83       	std	Z+4, r25	; 0x04
   13f8e:	83 83       	std	Z+3, r24	; 0x03
   13f90:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   13f94:	0f 90       	pop	r0
   13f96:	0f 90       	pop	r0
   13f98:	0f 90       	pop	r0
   13f9a:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   13f9c:	8f e0       	ldi	r24, 0x0F	; 15
   13f9e:	80 93 71 01 	sts	0x0171, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   13fa2:	80 91 b5 03 	lds	r24, 0x03B5
   13fa6:	87 3e       	cpi	r24, 0xE7	; 231
   13fa8:	c9 f4       	brne	.+50     	; 0x13fdc <FMenuLocalAccount+0xa20>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   13faa:	80 91 a3 03 	lds	r24, 0x03A3
   13fae:	81 50       	subi	r24, 0x01	; 1
   13fb0:	86 30       	cpi	r24, 0x06	; 6
   13fb2:	70 f4       	brcc	.+28     	; 0x13fd0 <FMenuLocalAccount+0xa14>
   13fb4:	80 91 a4 03 	lds	r24, 0x03A4
   13fb8:	88 23       	and	r24, r24
   13fba:	51 f4       	brne	.+20     	; 0x13fd0 <FMenuLocalAccount+0xa14>
   13fbc:	80 91 a5 03 	lds	r24, 0x03A5
   13fc0:	88 23       	and	r24, r24
   13fc2:	31 f4       	brne	.+12     	; 0x13fd0 <FMenuLocalAccount+0xa14>
   13fc4:	80 91 a6 03 	lds	r24, 0x03A6
   13fc8:	88 23       	and	r24, r24
   13fca:	11 f4       	brne	.+4      	; 0x13fd0 <FMenuLocalAccount+0xa14>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   13fcc:	89 e0       	ldi	r24, 0x09	; 9
   13fce:	01 c0       	rjmp	.+2      	; 0x13fd2 <FMenuLocalAccount+0xa16>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   13fd0:	8b e0       	ldi	r24, 0x0B	; 11
   13fd2:	80 93 71 01 	sts	0x0171, r24
					lcd_clear();
   13fd6:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   13fda:	1f c5       	rjmp	.+2622   	; 0x14a1a <FMenuLocalAccount+0x145e>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   13fdc:	87 3b       	cpi	r24, 0xB7	; 183
   13fde:	09 f0       	breq	.+2      	; 0x13fe2 <FMenuLocalAccount+0xa26>
   13fe0:	1c c5       	rjmp	.+2616   	; 0x14a1a <FMenuLocalAccount+0x145e>
				    BalanceType=1;
   13fe2:	11 e0       	ldi	r17, 0x01	; 1
   13fe4:	10 93 b9 03 	sts	0x03B9, r17
					sprintf_P(strBalanceType,PSTR("A"));
   13fe8:	00 d0       	rcall	.+0      	; 0x13fea <FMenuLocalAccount+0xa2e>
   13fea:	00 d0       	rcall	.+0      	; 0x13fec <FMenuLocalAccount+0xa30>
   13fec:	88 ea       	ldi	r24, 0xA8	; 168
   13fee:	95 e0       	ldi	r25, 0x05	; 5
   13ff0:	ad b7       	in	r26, 0x3d	; 61
   13ff2:	be b7       	in	r27, 0x3e	; 62
   13ff4:	12 96       	adiw	r26, 0x02	; 2
   13ff6:	9c 93       	st	X, r25
   13ff8:	8e 93       	st	-X, r24
   13ffa:	11 97       	sbiw	r26, 0x01	; 1
   13ffc:	8d e9       	ldi	r24, 0x9D	; 157
   13ffe:	9e e1       	ldi	r25, 0x1E	; 30
   14000:	14 96       	adiw	r26, 0x04	; 4
   14002:	9c 93       	st	X, r25
   14004:	8e 93       	st	-X, r24
   14006:	13 97       	sbiw	r26, 0x03	; 3
   14008:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   1400c:	10 93 8d 03 	sts	0x038D, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   14010:	81 e1       	ldi	r24, 0x11	; 17
   14012:	80 93 71 01 	sts	0x0171, r24
   14016:	80 e0       	ldi	r24, 0x00	; 0
   14018:	0f 90       	pop	r0
   1401a:	0f 90       	pop	r0
   1401c:	0f 90       	pop	r0
   1401e:	0f 90       	pop	r0
   14020:	fd c4       	rjmp	.+2554   	; 0x14a1c <FMenuLocalAccount+0x1460>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   14022:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		        if(BalanceType==1){
   14026:	80 91 b9 03 	lds	r24, 0x03B9
   1402a:	81 30       	cpi	r24, 0x01	; 1
   1402c:	f1 f5       	brne	.+124    	; 0x140aa <FMenuLocalAccount+0xaee>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1402e:	ed b7       	in	r30, 0x3d	; 61
   14030:	fe b7       	in	r31, 0x3e	; 62
   14032:	38 97       	sbiw	r30, 0x08	; 8
   14034:	0f b6       	in	r0, 0x3f	; 63
   14036:	f8 94       	cli
   14038:	fe bf       	out	0x3e, r31	; 62
   1403a:	0f be       	out	0x3f, r0	; 63
   1403c:	ed bf       	out	0x3d, r30	; 61
   1403e:	31 96       	adiw	r30, 0x01	; 1
   14040:	8e 01       	movw	r16, r28
   14042:	0f 5f       	subi	r16, 0xFF	; 255
   14044:	1f 4f       	sbci	r17, 0xFF	; 255
   14046:	ad b7       	in	r26, 0x3d	; 61
   14048:	be b7       	in	r27, 0x3e	; 62
   1404a:	12 96       	adiw	r26, 0x02	; 2
   1404c:	1c 93       	st	X, r17
   1404e:	0e 93       	st	-X, r16
   14050:	11 97       	sbiw	r26, 0x01	; 1
   14052:	85 e9       	ldi	r24, 0x95	; 149
   14054:	9e e1       	ldi	r25, 0x1E	; 30
   14056:	93 83       	std	Z+3, r25	; 0x03
   14058:	82 83       	std	Z+2, r24	; 0x02
   1405a:	86 eb       	ldi	r24, 0xB6	; 182
   1405c:	93 e0       	ldi	r25, 0x03	; 3
   1405e:	95 83       	std	Z+5, r25	; 0x05
   14060:	84 83       	std	Z+4, r24	; 0x04
   14062:	88 e6       	ldi	r24, 0x68	; 104
   14064:	99 e0       	ldi	r25, 0x09	; 9
   14066:	97 83       	std	Z+7, r25	; 0x07
   14068:	86 83       	std	Z+6, r24	; 0x06
   1406a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   1406e:	ed b7       	in	r30, 0x3d	; 61
   14070:	fe b7       	in	r31, 0x3e	; 62
   14072:	38 96       	adiw	r30, 0x08	; 8
   14074:	0f b6       	in	r0, 0x3f	; 63
   14076:	f8 94       	cli
   14078:	fe bf       	out	0x3e, r31	; 62
   1407a:	0f be       	out	0x3f, r0	; 63
   1407c:	ed bf       	out	0x3d, r30	; 61
   1407e:	81 e0       	ldi	r24, 0x01	; 1
   14080:	61 e0       	ldi	r22, 0x01	; 1
   14082:	a8 01       	movw	r20, r16
   14084:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   14088:	82 e0       	ldi	r24, 0x02	; 2
   1408a:	61 e0       	ldi	r22, 0x01	; 1
   1408c:	40 e8       	ldi	r20, 0x80	; 128
   1408e:	5e e1       	ldi	r21, 0x1E	; 30
   14090:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   14094:	83 e0       	ldi	r24, 0x03	; 3
   14096:	61 e0       	ldi	r22, 0x01	; 1
   14098:	4b e6       	ldi	r20, 0x6B	; 107
   1409a:	5e e1       	ldi	r21, 0x1E	; 30
   1409c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   140a0:	84 e0       	ldi	r24, 0x04	; 4
   140a2:	61 e0       	ldi	r22, 0x01	; 1
   140a4:	46 e5       	ldi	r20, 0x56	; 86
   140a6:	5e e1       	ldi	r21, 0x1E	; 30
   140a8:	43 c0       	rjmp	.+134    	; 0x14130 <FMenuLocalAccount+0xb74>
				   }
                else
		        if(BalanceType==2){
   140aa:	82 30       	cpi	r24, 0x02	; 2
   140ac:	09 f0       	breq	.+2      	; 0x140b0 <FMenuLocalAccount+0xaf4>
   140ae:	42 c0       	rjmp	.+132    	; 0x14134 <FMenuLocalAccount+0xb78>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   140b0:	2d b7       	in	r18, 0x3d	; 61
   140b2:	3e b7       	in	r19, 0x3e	; 62
   140b4:	28 50       	subi	r18, 0x08	; 8
   140b6:	30 40       	sbci	r19, 0x00	; 0
   140b8:	0f b6       	in	r0, 0x3f	; 63
   140ba:	f8 94       	cli
   140bc:	3e bf       	out	0x3e, r19	; 62
   140be:	0f be       	out	0x3f, r0	; 63
   140c0:	2d bf       	out	0x3d, r18	; 61
   140c2:	ed b7       	in	r30, 0x3d	; 61
   140c4:	fe b7       	in	r31, 0x3e	; 62
   140c6:	31 96       	adiw	r30, 0x01	; 1
   140c8:	8e 01       	movw	r16, r28
   140ca:	0f 5f       	subi	r16, 0xFF	; 255
   140cc:	1f 4f       	sbci	r17, 0xFF	; 255
   140ce:	ad b7       	in	r26, 0x3d	; 61
   140d0:	be b7       	in	r27, 0x3e	; 62
   140d2:	12 96       	adiw	r26, 0x02	; 2
   140d4:	1c 93       	st	X, r17
   140d6:	0e 93       	st	-X, r16
   140d8:	11 97       	sbiw	r26, 0x01	; 1
   140da:	8e e4       	ldi	r24, 0x4E	; 78
   140dc:	9e e1       	ldi	r25, 0x1E	; 30
   140de:	93 83       	std	Z+3, r25	; 0x03
   140e0:	82 83       	std	Z+2, r24	; 0x02
   140e2:	86 eb       	ldi	r24, 0xB6	; 182
   140e4:	93 e0       	ldi	r25, 0x03	; 3
   140e6:	95 83       	std	Z+5, r25	; 0x05
   140e8:	84 83       	std	Z+4, r24	; 0x04
   140ea:	88 e6       	ldi	r24, 0x68	; 104
   140ec:	99 e0       	ldi	r25, 0x09	; 9
   140ee:	97 83       	std	Z+7, r25	; 0x07
   140f0:	86 83       	std	Z+6, r24	; 0x06
   140f2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   140f6:	ed b7       	in	r30, 0x3d	; 61
   140f8:	fe b7       	in	r31, 0x3e	; 62
   140fa:	38 96       	adiw	r30, 0x08	; 8
   140fc:	0f b6       	in	r0, 0x3f	; 63
   140fe:	f8 94       	cli
   14100:	fe bf       	out	0x3e, r31	; 62
   14102:	0f be       	out	0x3f, r0	; 63
   14104:	ed bf       	out	0x3d, r30	; 61
   14106:	81 e0       	ldi	r24, 0x01	; 1
   14108:	61 e0       	ldi	r22, 0x01	; 1
   1410a:	a8 01       	movw	r20, r16
   1410c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   14110:	82 e0       	ldi	r24, 0x02	; 2
   14112:	61 e0       	ldi	r22, 0x01	; 1
   14114:	49 e3       	ldi	r20, 0x39	; 57
   14116:	5e e1       	ldi	r21, 0x1E	; 30
   14118:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   1411c:	83 e0       	ldi	r24, 0x03	; 3
   1411e:	61 e0       	ldi	r22, 0x01	; 1
   14120:	44 e2       	ldi	r20, 0x24	; 36
   14122:	5e e1       	ldi	r21, 0x1E	; 30
   14124:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   14128:	84 e0       	ldi	r24, 0x04	; 4
   1412a:	61 e0       	ldi	r22, 0x01	; 1
   1412c:	4f e0       	ldi	r20, 0x0F	; 15
   1412e:	5e e1       	ldi	r21, 0x1E	; 30
   14130:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				   }
                iLoop=0;
   14134:	10 92 8c 03 	sts	0x038C, r1
   14138:	10 92 8b 03 	sts	0x038B, r1
				iValuePos=0;
   1413c:	10 92 b4 03 	sts	0x03B4, r1
				ValueChar[iValuePos]=' ';
   14140:	80 e2       	ldi	r24, 0x20	; 32
   14142:	80 93 a9 03 	sts	0x03A9, r24
		        stLocalAccount=laBalanceValueInput;  
   14146:	80 e1       	ldi	r24, 0x10	; 16
   14148:	95 c1       	rjmp	.+810    	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break; 
           case laBalanceValueInput:
			    //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    iLoop++;
   1414a:	80 91 8b 03 	lds	r24, 0x038B
   1414e:	90 91 8c 03 	lds	r25, 0x038C
   14152:	01 96       	adiw	r24, 0x01	; 1
   14154:	90 93 8c 03 	sts	0x038C, r25
   14158:	80 93 8b 03 	sts	0x038B, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   1415c:	81 e0       	ldi	r24, 0x01	; 1
   1415e:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   14162:	80 93 b5 03 	sts	0x03B5, r24
			    KeyChar=_key_btn(KeyPressed);
   14166:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   1416a:	98 2f       	mov	r25, r24
   1416c:	80 93 ba 03 	sts	0x03BA, r24
				if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<6)&&(BalanceType==2))||//Max Rp.999999
   14170:	80 53       	subi	r24, 0x30	; 48
   14172:	8a 30       	cpi	r24, 0x0A	; 10
   14174:	38 f5       	brcc	.+78     	; 0x141c4 <FMenuLocalAccount+0xc08>
   14176:	e0 91 b4 03 	lds	r30, 0x03B4
   1417a:	e6 30       	cpi	r30, 0x06	; 6
   1417c:	18 f5       	brcc	.+70     	; 0x141c4 <FMenuLocalAccount+0xc08>
   1417e:	80 91 b9 03 	lds	r24, 0x03B9
   14182:	82 30       	cpi	r24, 0x02	; 2
   14184:	21 f0       	breq	.+8      	; 0x1418e <FMenuLocalAccount+0xbd2>
   14186:	e3 30       	cpi	r30, 0x03	; 3
   14188:	e8 f4       	brcc	.+58     	; 0x141c4 <FMenuLocalAccount+0xc08>
   1418a:	81 30       	cpi	r24, 0x01	; 1
   1418c:	d9 f4       	brne	.+54     	; 0x141c4 <FMenuLocalAccount+0xc08>
				   ((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<3)&&(BalanceType==1))){ //Max       999L
				    ValueChar[iValuePos]=KeyChar;
   1418e:	f0 e0       	ldi	r31, 0x00	; 0
   14190:	e7 55       	subi	r30, 0x57	; 87
   14192:	fc 4f       	sbci	r31, 0xFC	; 252
   14194:	90 83       	st	Z, r25
					iValuePos++;
   14196:	60 91 b4 03 	lds	r22, 0x03B4
   1419a:	6f 5f       	subi	r22, 0xFF	; 255
   1419c:	60 93 b4 03 	sts	0x03B4, r22
					lcd_xy(1+BalanceType,(10+iValuePos));_lcd(ValueChar[iValuePos-1]); 
   141a0:	80 91 b9 03 	lds	r24, 0x03B9
   141a4:	66 5f       	subi	r22, 0xF6	; 246
   141a6:	8f 5f       	subi	r24, 0xFF	; 255
   141a8:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   141ac:	e0 91 b4 03 	lds	r30, 0x03B4
   141b0:	f0 e0       	ldi	r31, 0x00	; 0
   141b2:	e8 55       	subi	r30, 0x58	; 88
   141b4:	fc 4f       	sbci	r31, 0xFC	; 252
   141b6:	80 81       	ld	r24, Z
   141b8:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
   141bc:	80 e5       	ldi	r24, 0x50	; 80
   141be:	93 ec       	ldi	r25, 0xC3	; 195
   141c0:	01 97       	sbiw	r24, 0x01	; 1
   141c2:	f1 f7       	brne	.-4      	; 0x141c0 <FMenuLocalAccount+0xc04>
					_delay_ms(200);
					}
			    if ((iLoop%2000)==0){
   141c4:	80 91 8b 03 	lds	r24, 0x038B
   141c8:	90 91 8c 03 	lds	r25, 0x038C
   141cc:	60 ed       	ldi	r22, 0xD0	; 208
   141ce:	77 e0       	ldi	r23, 0x07	; 7
   141d0:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
   141d4:	89 2b       	or	r24, r25
   141d6:	59 f4       	brne	.+22     	; 0x141ee <FMenuLocalAccount+0xc32>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd('_'); 
   141d8:	80 91 b9 03 	lds	r24, 0x03B9
   141dc:	60 91 b4 03 	lds	r22, 0x03B4
   141e0:	65 5f       	subi	r22, 0xF5	; 245
   141e2:	8f 5f       	subi	r24, 0xFF	; 255
   141e4:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   141e8:	8f e5       	ldi	r24, 0x5F	; 95
   141ea:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   141ee:	80 91 8b 03 	lds	r24, 0x038B
   141f2:	90 91 8c 03 	lds	r25, 0x038C
   141f6:	60 ed       	ldi	r22, 0xD0	; 208
   141f8:	77 e0       	ldi	r23, 0x07	; 7
   141fa:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
   141fe:	88 5e       	subi	r24, 0xE8	; 232
   14200:	93 40       	sbci	r25, 0x03	; 3
   14202:	59 f4       	brne	.+22     	; 0x1421a <FMenuLocalAccount+0xc5e>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd(' '); 
   14204:	80 91 b9 03 	lds	r24, 0x03B9
   14208:	60 91 b4 03 	lds	r22, 0x03B4
   1420c:	65 5f       	subi	r22, 0xF5	; 245
   1420e:	8f 5f       	subi	r24, 0xFF	; 255
   14210:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   14214:	80 e2       	ldi	r24, 0x20	; 32
   14216:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
			    }
				if (KeyPressed==_KEY_CANCEL){
   1421a:	80 91 b5 03 	lds	r24, 0x03B5
   1421e:	87 3e       	cpi	r24, 0xE7	; 231
   14220:	39 f4       	brne	.+14     	; 0x14230 <FMenuLocalAccount+0xc74>
				    lcd_clear();
   14222:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   14226:	88 ea       	ldi	r24, 0xA8	; 168
   14228:	91 e6       	ldi	r25, 0x61	; 97
   1422a:	01 97       	sbiw	r24, 0x01	; 1
   1422c:	f1 f7       	brne	.-4      	; 0x1422a <FMenuLocalAccount+0xc6e>
   1422e:	1f c1       	rjmp	.+574    	; 0x1446e <FMenuLocalAccount+0xeb2>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (KeyPressed==_KEY_ENTER){				    
   14230:	87 3b       	cpi	r24, 0xB7	; 183
   14232:	09 f0       	breq	.+2      	; 0x14236 <FMenuLocalAccount+0xc7a>
   14234:	f2 c3       	rjmp	.+2020   	; 0x14a1a <FMenuLocalAccount+0x145e>
                    ValueChar[iValuePos]=0;
   14236:	e0 91 b4 03 	lds	r30, 0x03B4
   1423a:	f0 e0       	ldi	r31, 0x00	; 0
   1423c:	e7 55       	subi	r30, 0x57	; 87
   1423e:	fc 4f       	sbci	r31, 0xFC	; 252
   14240:	10 82       	st	Z, r1
					sprintf_P(strBalanceValue,PSTR("%s"),ValueChar);
   14242:	00 d0       	rcall	.+0      	; 0x14244 <FMenuLocalAccount+0xc88>
   14244:	00 d0       	rcall	.+0      	; 0x14246 <FMenuLocalAccount+0xc8a>
   14246:	00 d0       	rcall	.+0      	; 0x14248 <FMenuLocalAccount+0xc8c>
   14248:	ed b7       	in	r30, 0x3d	; 61
   1424a:	fe b7       	in	r31, 0x3e	; 62
   1424c:	31 96       	adiw	r30, 0x01	; 1
   1424e:	85 e2       	ldi	r24, 0x25	; 37
   14250:	9e e0       	ldi	r25, 0x0E	; 14
   14252:	ad b7       	in	r26, 0x3d	; 61
   14254:	be b7       	in	r27, 0x3e	; 62
   14256:	12 96       	adiw	r26, 0x02	; 2
   14258:	9c 93       	st	X, r25
   1425a:	8e 93       	st	-X, r24
   1425c:	11 97       	sbiw	r26, 0x01	; 1
   1425e:	8c e0       	ldi	r24, 0x0C	; 12
   14260:	9e e1       	ldi	r25, 0x1E	; 30
   14262:	93 83       	std	Z+3, r25	; 0x03
   14264:	82 83       	std	Z+2, r24	; 0x02
   14266:	89 ea       	ldi	r24, 0xA9	; 169
   14268:	93 e0       	ldi	r25, 0x03	; 3
   1426a:	95 83       	std	Z+5, r25	; 0x05
   1426c:	84 83       	std	Z+4, r24	; 0x04
   1426e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				    stLocalAccount=laOdometer;
   14272:	81 e1       	ldi	r24, 0x11	; 17
   14274:	80 93 71 01 	sts	0x0171, r24
					lcd_clear();
   14278:	ed b7       	in	r30, 0x3d	; 61
   1427a:	fe b7       	in	r31, 0x3e	; 62
   1427c:	36 96       	adiw	r30, 0x06	; 6
   1427e:	0f b6       	in	r0, 0x3f	; 63
   14280:	f8 94       	cli
   14282:	fe bf       	out	0x3e, r31	; 62
   14284:	0f be       	out	0x3f, r0	; 63
   14286:	ed bf       	out	0x3d, r30	; 61
   14288:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   1428c:	88 ea       	ldi	r24, 0xA8	; 168
   1428e:	91 e6       	ldi	r25, 0x61	; 97
   14290:	01 97       	sbiw	r24, 0x01	; 1
   14292:	f1 f7       	brne	.-4      	; 0x14290 <FMenuLocalAccount+0xcd4>
   14294:	c2 c3       	rjmp	.+1924   	; 0x14a1a <FMenuLocalAccount+0x145e>
					_delay_ms(100);		        
					}
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   14296:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
				if (IsFullAuthorized==True){
   1429a:	80 91 8d 03 	lds	r24, 0x038D
   1429e:	81 30       	cpi	r24, 0x01	; 1
   142a0:	09 f0       	breq	.+2      	; 0x142a4 <FMenuLocalAccount+0xce8>
   142a2:	4a c0       	rjmp	.+148    	; 0x14338 <FMenuLocalAccount+0xd7c>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   142a4:	61 e0       	ldi	r22, 0x01	; 1
   142a6:	48 ef       	ldi	r20, 0xF8	; 248
   142a8:	5d e1       	ldi	r21, 0x1D	; 29
   142aa:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   142ae:	2d b7       	in	r18, 0x3d	; 61
   142b0:	3e b7       	in	r19, 0x3e	; 62
   142b2:	28 50       	subi	r18, 0x08	; 8
   142b4:	30 40       	sbci	r19, 0x00	; 0
   142b6:	0f b6       	in	r0, 0x3f	; 63
   142b8:	f8 94       	cli
   142ba:	3e bf       	out	0x3e, r19	; 62
   142bc:	0f be       	out	0x3f, r0	; 63
   142be:	2d bf       	out	0x3d, r18	; 61
   142c0:	ed b7       	in	r30, 0x3d	; 61
   142c2:	fe b7       	in	r31, 0x3e	; 62
   142c4:	31 96       	adiw	r30, 0x01	; 1
   142c6:	8e 01       	movw	r16, r28
   142c8:	0f 5f       	subi	r16, 0xFF	; 255
   142ca:	1f 4f       	sbci	r17, 0xFF	; 255
   142cc:	ad b7       	in	r26, 0x3d	; 61
   142ce:	be b7       	in	r27, 0x3e	; 62
   142d0:	12 96       	adiw	r26, 0x02	; 2
   142d2:	1c 93       	st	X, r17
   142d4:	0e 93       	st	-X, r16
   142d6:	11 97       	sbiw	r26, 0x01	; 1
   142d8:	8f ee       	ldi	r24, 0xEF	; 239
   142da:	9d e1       	ldi	r25, 0x1D	; 29
   142dc:	93 83       	std	Z+3, r25	; 0x03
   142de:	82 83       	std	Z+2, r24	; 0x02
   142e0:	86 eb       	ldi	r24, 0xB6	; 182
   142e2:	93 e0       	ldi	r25, 0x03	; 3
   142e4:	95 83       	std	Z+5, r25	; 0x05
   142e6:	84 83       	std	Z+4, r24	; 0x04
   142e8:	88 e6       	ldi	r24, 0x68	; 104
   142ea:	99 e0       	ldi	r25, 0x09	; 9
   142ec:	97 83       	std	Z+7, r25	; 0x07
   142ee:	86 83       	std	Z+6, r24	; 0x06
   142f0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   142f4:	ed b7       	in	r30, 0x3d	; 61
   142f6:	fe b7       	in	r31, 0x3e	; 62
   142f8:	38 96       	adiw	r30, 0x08	; 8
   142fa:	0f b6       	in	r0, 0x3f	; 63
   142fc:	f8 94       	cli
   142fe:	fe bf       	out	0x3e, r31	; 62
   14300:	0f be       	out	0x3f, r0	; 63
   14302:	ed bf       	out	0x3d, r30	; 61
   14304:	82 e0       	ldi	r24, 0x02	; 2
   14306:	61 e0       	ldi	r22, 0x01	; 1
   14308:	a8 01       	movw	r20, r16
   1430a:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   1430e:	00 d0       	rcall	.+0      	; 0x14310 <FMenuLocalAccount+0xd54>
   14310:	00 d0       	rcall	.+0      	; 0x14312 <FMenuLocalAccount+0xd56>
   14312:	ad b7       	in	r26, 0x3d	; 61
   14314:	be b7       	in	r27, 0x3e	; 62
   14316:	12 96       	adiw	r26, 0x02	; 2
   14318:	1c 93       	st	X, r17
   1431a:	0e 93       	st	-X, r16
   1431c:	11 97       	sbiw	r26, 0x01	; 1
   1431e:	88 ee       	ldi	r24, 0xE8	; 232
   14320:	9d e1       	ldi	r25, 0x1D	; 29
   14322:	14 96       	adiw	r26, 0x04	; 4
   14324:	9c 93       	st	X, r25
   14326:	8e 93       	st	-X, r24
   14328:	13 97       	sbiw	r26, 0x03	; 3
   1432a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   1432e:	0f 90       	pop	r0
   14330:	0f 90       	pop	r0
   14332:	0f 90       	pop	r0
   14334:	0f 90       	pop	r0
   14336:	5e c0       	rjmp	.+188    	; 0x143f4 <FMenuLocalAccount+0xe38>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   14338:	80 91 b9 03 	lds	r24, 0x03B9
   1433c:	81 30       	cpi	r24, 0x01	; 1
   1433e:	29 f4       	brne	.+10     	; 0x1434a <FMenuLocalAccount+0xd8e>
   14340:	61 e0       	ldi	r22, 0x01	; 1
   14342:	44 ed       	ldi	r20, 0xD4	; 212
   14344:	5d e1       	ldi	r21, 0x1D	; 29
   14346:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   1434a:	80 91 b9 03 	lds	r24, 0x03B9
   1434e:	82 30       	cpi	r24, 0x02	; 2
   14350:	31 f4       	brne	.+12     	; 0x1435e <FMenuLocalAccount+0xda2>
   14352:	81 e0       	ldi	r24, 0x01	; 1
   14354:	61 e0       	ldi	r22, 0x01	; 1
   14356:	40 ec       	ldi	r20, 0xC0	; 192
   14358:	5d e1       	ldi	r21, 0x1D	; 29
   1435a:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   1435e:	ed b7       	in	r30, 0x3d	; 61
   14360:	fe b7       	in	r31, 0x3e	; 62
   14362:	38 97       	sbiw	r30, 0x08	; 8
   14364:	0f b6       	in	r0, 0x3f	; 63
   14366:	f8 94       	cli
   14368:	fe bf       	out	0x3e, r31	; 62
   1436a:	0f be       	out	0x3f, r0	; 63
   1436c:	ed bf       	out	0x3d, r30	; 61
   1436e:	31 96       	adiw	r30, 0x01	; 1
   14370:	8e 01       	movw	r16, r28
   14372:	0f 5f       	subi	r16, 0xFF	; 255
   14374:	1f 4f       	sbci	r17, 0xFF	; 255
   14376:	ad b7       	in	r26, 0x3d	; 61
   14378:	be b7       	in	r27, 0x3e	; 62
   1437a:	12 96       	adiw	r26, 0x02	; 2
   1437c:	1c 93       	st	X, r17
   1437e:	0e 93       	st	-X, r16
   14380:	11 97       	sbiw	r26, 0x01	; 1
   14382:	87 eb       	ldi	r24, 0xB7	; 183
   14384:	9d e1       	ldi	r25, 0x1D	; 29
   14386:	93 83       	std	Z+3, r25	; 0x03
   14388:	82 83       	std	Z+2, r24	; 0x02
   1438a:	86 eb       	ldi	r24, 0xB6	; 182
   1438c:	93 e0       	ldi	r25, 0x03	; 3
   1438e:	95 83       	std	Z+5, r25	; 0x05
   14390:	84 83       	std	Z+4, r24	; 0x04
   14392:	88 e6       	ldi	r24, 0x68	; 104
   14394:	99 e0       	ldi	r25, 0x09	; 9
   14396:	97 83       	std	Z+7, r25	; 0x07
   14398:	86 83       	std	Z+6, r24	; 0x06
   1439a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   1439e:	ed b7       	in	r30, 0x3d	; 61
   143a0:	fe b7       	in	r31, 0x3e	; 62
   143a2:	38 96       	adiw	r30, 0x08	; 8
   143a4:	0f b6       	in	r0, 0x3f	; 63
   143a6:	f8 94       	cli
   143a8:	fe bf       	out	0x3e, r31	; 62
   143aa:	0f be       	out	0x3f, r0	; 63
   143ac:	ed bf       	out	0x3d, r30	; 61
   143ae:	82 e0       	ldi	r24, 0x02	; 2
   143b0:	61 e0       	ldi	r22, 0x01	; 1
   143b2:	a8 01       	movw	r20, r16
   143b4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   143b8:	00 d0       	rcall	.+0      	; 0x143ba <FMenuLocalAccount+0xdfe>
   143ba:	00 d0       	rcall	.+0      	; 0x143bc <FMenuLocalAccount+0xe00>
   143bc:	00 d0       	rcall	.+0      	; 0x143be <FMenuLocalAccount+0xe02>
   143be:	ed b7       	in	r30, 0x3d	; 61
   143c0:	fe b7       	in	r31, 0x3e	; 62
   143c2:	31 96       	adiw	r30, 0x01	; 1
   143c4:	ad b7       	in	r26, 0x3d	; 61
   143c6:	be b7       	in	r27, 0x3e	; 62
   143c8:	12 96       	adiw	r26, 0x02	; 2
   143ca:	1c 93       	st	X, r17
   143cc:	0e 93       	st	-X, r16
   143ce:	11 97       	sbiw	r26, 0x01	; 1
   143d0:	83 eb       	ldi	r24, 0xB3	; 179
   143d2:	9d e1       	ldi	r25, 0x1D	; 29
   143d4:	93 83       	std	Z+3, r25	; 0x03
   143d6:	82 83       	std	Z+2, r24	; 0x02
   143d8:	85 e2       	ldi	r24, 0x25	; 37
   143da:	9e e0       	ldi	r25, 0x0E	; 14
   143dc:	95 83       	std	Z+5, r25	; 0x05
   143de:	84 83       	std	Z+4, r24	; 0x04
   143e0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   143e4:	ed b7       	in	r30, 0x3d	; 61
   143e6:	fe b7       	in	r31, 0x3e	; 62
   143e8:	36 96       	adiw	r30, 0x06	; 6
   143ea:	0f b6       	in	r0, 0x3f	; 63
   143ec:	f8 94       	cli
   143ee:	fe bf       	out	0x3e, r31	; 62
   143f0:	0f be       	out	0x3f, r0	; 63
   143f2:	ed bf       	out	0x3d, r30	; 61
   143f4:	82 e0       	ldi	r24, 0x02	; 2
   143f6:	6e e0       	ldi	r22, 0x0E	; 14
   143f8:	a8 01       	movw	r20, r16
   143fa:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   143fe:	83 e0       	ldi	r24, 0x03	; 3
   14400:	61 e0       	ldi	r22, 0x01	; 1
   14402:	41 ea       	ldi	r20, 0xA1	; 161
   14404:	5d e1       	ldi	r21, 0x1D	; 29
   14406:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   1440a:	84 e0       	ldi	r24, 0x04	; 4
   1440c:	61 e0       	ldi	r22, 0x01	; 1
   1440e:	4f e8       	ldi	r20, 0x8F	; 143
   14410:	5d e1       	ldi	r21, 0x1D	; 29
   14412:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
                //iLoop=0;
				//iValuePos=0;
				//ValueChar[iValuePos]=' ';        
				ClearMem(strOdometer);
   14416:	88 ec       	ldi	r24, 0xC8	; 200
   14418:	95 e0       	ldi	r25, 0x05	; 5
   1441a:	0e 94 5c ad 	call	0x15ab8	; 0x15ab8 <ClearMem>
		        stLocalAccount=laOdometerInput;
   1441e:	82 e1       	ldi	r24, 0x12	; 18
   14420:	29 c0       	rjmp	.+82     	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laOdometerInput:
		        //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    //iLoop++;
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   14422:	18 ec       	ldi	r17, 0xC8	; 200
   14424:	c1 2e       	mov	r12, r17
   14426:	15 e0       	ldi	r17, 0x05	; 5
   14428:	d1 2e       	mov	r13, r17
   1442a:	81 e0       	ldi	r24, 0x01	; 1
   1442c:	63 e0       	ldi	r22, 0x03	; 3
   1442e:	4a e0       	ldi	r20, 0x0A	; 10
   14430:	96 01       	movw	r18, r12
   14432:	00 e0       	ldi	r16, 0x00	; 0
   14434:	10 e0       	ldi	r17, 0x00	; 0
   14436:	ba e0       	ldi	r27, 0x0A	; 10
   14438:	eb 2e       	mov	r14, r27
   1443a:	0e 94 2d 7e 	call	0xfc5a	; 0xfc5a <UserInput>
				if (uiResult==USER_OK){
   1443e:	83 30       	cpi	r24, 0x03	; 3
   14440:	79 f4       	brne	.+30     	; 0x14460 <FMenuLocalAccount+0xea4>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   14442:	f6 01       	movw	r30, r12
   14444:	01 90       	ld	r0, Z+
   14446:	00 20       	and	r0, r0
   14448:	e9 f7       	brne	.-6      	; 0x14444 <FMenuLocalAccount+0xe88>
   1444a:	ea 5c       	subi	r30, 0xCA	; 202
   1444c:	f5 40       	sbci	r31, 0x05	; 5
   1444e:	31 f4       	brne	.+12     	; 0x1445c <FMenuLocalAccount+0xea0>
   14450:	80 91 c8 05 	lds	r24, 0x05C8
   14454:	80 33       	cpi	r24, 0x30	; 48
   14456:	11 f4       	brne	.+4      	; 0x1445c <FMenuLocalAccount+0xea0>
					    strOdometer[0]=0;
   14458:	10 92 c8 05 	sts	0x05C8, r1

				    stLocalAccount=laDataConfirm;
   1445c:	83 e1       	ldi	r24, 0x13	; 19
   1445e:	0a c0       	rjmp	.+20     	; 0x14474 <FMenuLocalAccount+0xeb8>
					}
			    else
			    if (uiResult==USER_CANCEL){
   14460:	81 30       	cpi	r24, 0x01	; 1
   14462:	09 f0       	breq	.+2      	; 0x14466 <FMenuLocalAccount+0xeaa>
   14464:	da c2       	rjmp	.+1460   	; 0x14a1a <FMenuLocalAccount+0x145e>
				    if (IsFullAuthorized==True)
   14466:	80 91 8d 03 	lds	r24, 0x038D
   1446a:	81 30       	cpi	r24, 0x01	; 1
   1446c:	11 f4       	brne	.+4      	; 0x14472 <FMenuLocalAccount+0xeb6>
					     stLocalAccount=laSelectBalanceType;
   1446e:	8d e0       	ldi	r24, 0x0D	; 13
   14470:	01 c0       	rjmp	.+2      	; 0x14474 <FMenuLocalAccount+0xeb8>
					else stLocalAccount=laBalanceValue;		        
   14472:	8f e0       	ldi	r24, 0x0F	; 15
   14474:	80 93 71 01 	sts	0x0171, r24
   14478:	d0 c2       	rjmp	.+1440   	; 0x14a1a <FMenuLocalAccount+0x145e>
					}
                */

		        break;
           case laDataConfirm: 
		        lcd_clear();
   1447a:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   1447e:	e2 e3       	ldi	r30, 0x32	; 50
   14480:	f5 e0       	ldi	r31, 0x05	; 5
   14482:	de 01       	movw	r26, r28
   14484:	55 96       	adiw	r26, 0x15	; 21
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   14486:	81 91       	ld	r24, Z+
   14488:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   1448a:	35 e0       	ldi	r19, 0x05	; 5
   1448c:	ec 33       	cpi	r30, 0x3C	; 60
   1448e:	f3 07       	cpc	r31, r19
   14490:	d1 f7       	brne	.-12     	; 0x14486 <FMenuLocalAccount+0xeca>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   14492:	1f 8e       	std	Y+31, r1	; 0x1f

		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   14494:	00 d0       	rcall	.+0      	; 0x14496 <FMenuLocalAccount+0xeda>
   14496:	00 d0       	rcall	.+0      	; 0x14498 <FMenuLocalAccount+0xedc>
   14498:	00 d0       	rcall	.+0      	; 0x1449a <FMenuLocalAccount+0xede>
   1449a:	ed b7       	in	r30, 0x3d	; 61
   1449c:	fe b7       	in	r31, 0x3e	; 62
   1449e:	31 96       	adiw	r30, 0x01	; 1
   144a0:	8e 01       	movw	r16, r28
   144a2:	0f 5f       	subi	r16, 0xFF	; 255
   144a4:	1f 4f       	sbci	r17, 0xFF	; 255
   144a6:	ad b7       	in	r26, 0x3d	; 61
   144a8:	be b7       	in	r27, 0x3e	; 62
   144aa:	12 96       	adiw	r26, 0x02	; 2
   144ac:	1c 93       	st	X, r17
   144ae:	0e 93       	st	-X, r16
   144b0:	11 97       	sbiw	r26, 0x01	; 1
   144b2:	8b e8       	ldi	r24, 0x8B	; 139
   144b4:	9d e1       	ldi	r25, 0x1D	; 29
   144b6:	93 83       	std	Z+3, r25	; 0x03
   144b8:	82 83       	std	Z+2, r24	; 0x02
   144ba:	ce 01       	movw	r24, r28
   144bc:	45 96       	adiw	r24, 0x15	; 21
   144be:	95 83       	std	Z+5, r25	; 0x05
   144c0:	84 83       	std	Z+4, r24	; 0x04
   144c2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   144c6:	ed b7       	in	r30, 0x3d	; 61
   144c8:	fe b7       	in	r31, 0x3e	; 62
   144ca:	36 96       	adiw	r30, 0x06	; 6
   144cc:	0f b6       	in	r0, 0x3f	; 63
   144ce:	f8 94       	cli
   144d0:	fe bf       	out	0x3e, r31	; 62
   144d2:	0f be       	out	0x3f, r0	; 63
   144d4:	ed bf       	out	0x3d, r30	; 61
   144d6:	81 e0       	ldi	r24, 0x01	; 1
   144d8:	61 e0       	ldi	r22, 0x01	; 1
   144da:	a8 01       	movw	r20, r16
   144dc:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   144e0:	00 d0       	rcall	.+0      	; 0x144e2 <FMenuLocalAccount+0xf26>
   144e2:	00 d0       	rcall	.+0      	; 0x144e4 <FMenuLocalAccount+0xf28>
   144e4:	00 d0       	rcall	.+0      	; 0x144e6 <FMenuLocalAccount+0xf2a>
   144e6:	ed b7       	in	r30, 0x3d	; 61
   144e8:	fe b7       	in	r31, 0x3e	; 62
   144ea:	31 96       	adiw	r30, 0x01	; 1
   144ec:	ad b7       	in	r26, 0x3d	; 61
   144ee:	be b7       	in	r27, 0x3e	; 62
   144f0:	12 96       	adiw	r26, 0x02	; 2
   144f2:	1c 93       	st	X, r17
   144f4:	0e 93       	st	-X, r16
   144f6:	11 97       	sbiw	r26, 0x01	; 1
   144f8:	84 e8       	ldi	r24, 0x84	; 132
   144fa:	9d e1       	ldi	r25, 0x1D	; 29
   144fc:	93 83       	std	Z+3, r25	; 0x03
   144fe:	82 83       	std	Z+2, r24	; 0x02
   14500:	8c e8       	ldi	r24, 0x8C	; 140
   14502:	9d e0       	ldi	r25, 0x0D	; 13
   14504:	95 83       	std	Z+5, r25	; 0x05
   14506:	84 83       	std	Z+4, r24	; 0x04
   14508:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   1450c:	ed b7       	in	r30, 0x3d	; 61
   1450e:	fe b7       	in	r31, 0x3e	; 62
   14510:	36 96       	adiw	r30, 0x06	; 6
   14512:	0f b6       	in	r0, 0x3f	; 63
   14514:	f8 94       	cli
   14516:	fe bf       	out	0x3e, r31	; 62
   14518:	0f be       	out	0x3f, r0	; 63
   1451a:	ed bf       	out	0x3d, r30	; 61
   1451c:	82 e0       	ldi	r24, 0x02	; 2
   1451e:	61 e0       	ldi	r22, 0x01	; 1
   14520:	a8 01       	movw	r20, r16
   14522:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   14526:	2d b7       	in	r18, 0x3d	; 61
   14528:	3e b7       	in	r19, 0x3e	; 62
   1452a:	28 50       	subi	r18, 0x08	; 8
   1452c:	30 40       	sbci	r19, 0x00	; 0
   1452e:	0f b6       	in	r0, 0x3f	; 63
   14530:	f8 94       	cli
   14532:	3e bf       	out	0x3e, r19	; 62
   14534:	0f be       	out	0x3f, r0	; 63
   14536:	2d bf       	out	0x3d, r18	; 61
   14538:	ed b7       	in	r30, 0x3d	; 61
   1453a:	fe b7       	in	r31, 0x3e	; 62
   1453c:	31 96       	adiw	r30, 0x01	; 1
   1453e:	ad b7       	in	r26, 0x3d	; 61
   14540:	be b7       	in	r27, 0x3e	; 62
   14542:	12 96       	adiw	r26, 0x02	; 2
   14544:	1c 93       	st	X, r17
   14546:	0e 93       	st	-X, r16
   14548:	11 97       	sbiw	r26, 0x01	; 1
   1454a:	8c e7       	ldi	r24, 0x7C	; 124
   1454c:	9d e1       	ldi	r25, 0x1D	; 29
   1454e:	93 83       	std	Z+3, r25	; 0x03
   14550:	82 83       	std	Z+2, r24	; 0x02
   14552:	86 eb       	ldi	r24, 0xB6	; 182
   14554:	93 e0       	ldi	r25, 0x03	; 3
   14556:	95 83       	std	Z+5, r25	; 0x05
   14558:	84 83       	std	Z+4, r24	; 0x04
   1455a:	88 e6       	ldi	r24, 0x68	; 104
   1455c:	99 e0       	ldi	r25, 0x09	; 9
   1455e:	97 83       	std	Z+7, r25	; 0x07
   14560:	86 83       	std	Z+6, r24	; 0x06
   14562:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   14566:	ed b7       	in	r30, 0x3d	; 61
   14568:	fe b7       	in	r31, 0x3e	; 62
   1456a:	38 96       	adiw	r30, 0x08	; 8
   1456c:	0f b6       	in	r0, 0x3f	; 63
   1456e:	f8 94       	cli
   14570:	fe bf       	out	0x3e, r31	; 62
   14572:	0f be       	out	0x3f, r0	; 63
   14574:	ed bf       	out	0x3d, r30	; 61
   14576:	83 e0       	ldi	r24, 0x03	; 3
   14578:	61 e0       	ldi	r22, 0x01	; 1
   1457a:	a8 01       	movw	r20, r16
   1457c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		        if (IsFullAuthorized==True){
   14580:	80 91 8d 03 	lds	r24, 0x038D
   14584:	81 30       	cpi	r24, 0x01	; 1
   14586:	39 f4       	brne	.+14     	; 0x14596 <FMenuLocalAccount+0xfda>
                    lcd_printf(3,15,PSTR(" Full"));
   14588:	83 e0       	ldi	r24, 0x03	; 3
   1458a:	6f e0       	ldi	r22, 0x0F	; 15
   1458c:	46 e7       	ldi	r20, 0x76	; 118
   1458e:	5d e1       	ldi	r21, 0x1D	; 29
   14590:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   14594:	23 c0       	rjmp	.+70     	; 0x145dc <FMenuLocalAccount+0x1020>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   14596:	00 d0       	rcall	.+0      	; 0x14598 <FMenuLocalAccount+0xfdc>
   14598:	00 d0       	rcall	.+0      	; 0x1459a <FMenuLocalAccount+0xfde>
   1459a:	00 d0       	rcall	.+0      	; 0x1459c <FMenuLocalAccount+0xfe0>
   1459c:	ed b7       	in	r30, 0x3d	; 61
   1459e:	fe b7       	in	r31, 0x3e	; 62
   145a0:	31 96       	adiw	r30, 0x01	; 1
   145a2:	ad b7       	in	r26, 0x3d	; 61
   145a4:	be b7       	in	r27, 0x3e	; 62
   145a6:	12 96       	adiw	r26, 0x02	; 2
   145a8:	1c 93       	st	X, r17
   145aa:	0e 93       	st	-X, r16
   145ac:	11 97       	sbiw	r26, 0x01	; 1
   145ae:	82 e7       	ldi	r24, 0x72	; 114
   145b0:	9d e1       	ldi	r25, 0x1D	; 29
   145b2:	93 83       	std	Z+3, r25	; 0x03
   145b4:	82 83       	std	Z+2, r24	; 0x02
   145b6:	85 e2       	ldi	r24, 0x25	; 37
   145b8:	9e e0       	ldi	r25, 0x0E	; 14
   145ba:	95 83       	std	Z+5, r25	; 0x05
   145bc:	84 83       	std	Z+4, r24	; 0x04
   145be:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   145c2:	ed b7       	in	r30, 0x3d	; 61
   145c4:	fe b7       	in	r31, 0x3e	; 62
   145c6:	36 96       	adiw	r30, 0x06	; 6
   145c8:	0f b6       	in	r0, 0x3f	; 63
   145ca:	f8 94       	cli
   145cc:	fe bf       	out	0x3e, r31	; 62
   145ce:	0f be       	out	0x3f, r0	; 63
   145d0:	ed bf       	out	0x3d, r30	; 61
   145d2:	83 e0       	ldi	r24, 0x03	; 3
   145d4:	6f e0       	ldi	r22, 0x0F	; 15
   145d6:	a8 01       	movw	r20, r16
   145d8:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   145dc:	84 e0       	ldi	r24, 0x04	; 4
   145de:	61 e0       	ldi	r22, 0x01	; 1
   145e0:	4d e5       	ldi	r20, 0x5D	; 93
   145e2:	5d e1       	ldi	r21, 0x1D	; 29
   145e4:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   145e8:	84 e1       	ldi	r24, 0x14	; 20
   145ea:	44 cf       	rjmp	.-376    	; 0x14474 <FMenuLocalAccount+0xeb8>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   145ec:	81 e0       	ldi	r24, 0x01	; 1
   145ee:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   145f2:	80 93 b5 03 	sts	0x03B5, r24
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   145f6:	87 3e       	cpi	r24, 0xE7	; 231
   145f8:	11 f4       	brne	.+4      	; 0x145fe <FMenuLocalAccount+0x1042>
   145fa:	81 e1       	ldi	r24, 0x11	; 17
   145fc:	3b cf       	rjmp	.-394    	; 0x14474 <FMenuLocalAccount+0xeb8>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   145fe:	87 3b       	cpi	r24, 0xB7	; 183
   14600:	11 f4       	brne	.+4      	; 0x14606 <FMenuLocalAccount+0x104a>
   14602:	85 e1       	ldi	r24, 0x15	; 21
   14604:	37 cf       	rjmp	.-402    	; 0x14474 <FMenuLocalAccount+0xeb8>
				else
				if (KeyPressed==_KEY_0){
   14606:	87 3d       	cpi	r24, 0xD7	; 215
   14608:	09 f0       	breq	.+2      	; 0x1460c <FMenuLocalAccount+0x1050>
   1460a:	07 c2       	rjmp	.+1038   	; 0x14a1a <FMenuLocalAccount+0x145e>
				   //ShowCancel
				   TimLocAcc=0;
   1460c:	10 92 e9 01 	sts	0x01E9, r1
   14610:	10 92 e8 01 	sts	0x01E8, r1
                   lcd_clear();
   14614:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   14618:	81 e0       	ldi	r24, 0x01	; 1
   1461a:	61 e0       	ldi	r22, 0x01	; 1
   1461c:	48 e4       	ldi	r20, 0x48	; 72
   1461e:	5d e1       	ldi	r21, 0x1D	; 29
   14620:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
   14624:	e9 c1       	rjmp	.+978    	; 0x149f8 <FMenuLocalAccount+0x143c>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   14626:	0e 94 31 4f 	call	0x9e62	; 0x9e62 <sendMessage58>
                RemZeroLead(strCardID);
   1462a:	8c e8       	ldi	r24, 0x8C	; 140
   1462c:	9d e0       	ldi	r25, 0x0D	; 13
   1462e:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
                RemZeroLead(strBalanceValue);
   14632:	a5 e2       	ldi	r26, 0x25	; 37
   14634:	ea 2e       	mov	r14, r26
   14636:	ae e0       	ldi	r26, 0x0E	; 14
   14638:	fa 2e       	mov	r15, r26
   1463a:	c7 01       	movw	r24, r14
   1463c:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14640:	2d b7       	in	r18, 0x3d	; 61
   14642:	3e b7       	in	r19, 0x3e	; 62
   14644:	28 50       	subi	r18, 0x08	; 8
   14646:	30 40       	sbci	r19, 0x00	; 0
   14648:	0f b6       	in	r0, 0x3f	; 63
   1464a:	f8 94       	cli
   1464c:	3e bf       	out	0x3e, r19	; 62
   1464e:	0f be       	out	0x3f, r0	; 63
   14650:	2d bf       	out	0x3d, r18	; 61
   14652:	ed b7       	in	r30, 0x3d	; 61
   14654:	fe b7       	in	r31, 0x3e	; 62
   14656:	31 96       	adiw	r30, 0x01	; 1
   14658:	8e 01       	movw	r16, r28
   1465a:	0f 5f       	subi	r16, 0xFF	; 255
   1465c:	1f 4f       	sbci	r17, 0xFF	; 255
   1465e:	ad b7       	in	r26, 0x3d	; 61
   14660:	be b7       	in	r27, 0x3e	; 62
   14662:	12 96       	adiw	r26, 0x02	; 2
   14664:	1c 93       	st	X, r17
   14666:	0e 93       	st	-X, r16
   14668:	11 97       	sbiw	r26, 0x01	; 1
   1466a:	80 e4       	ldi	r24, 0x40	; 64
   1466c:	9d e1       	ldi	r25, 0x1D	; 29
   1466e:	93 83       	std	Z+3, r25	; 0x03
   14670:	82 83       	std	Z+2, r24	; 0x02
   14672:	86 eb       	ldi	r24, 0xB6	; 182
   14674:	93 e0       	ldi	r25, 0x03	; 3
   14676:	95 83       	std	Z+5, r25	; 0x05
   14678:	84 83       	std	Z+4, r24	; 0x04
   1467a:	88 e6       	ldi	r24, 0x68	; 104
   1467c:	99 e0       	ldi	r25, 0x09	; 9
   1467e:	97 83       	std	Z+7, r25	; 0x07
   14680:	86 83       	std	Z+6, r24	; 0x06
   14682:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   14686:	ed b7       	in	r30, 0x3d	; 61
   14688:	fe b7       	in	r31, 0x3e	; 62
   1468a:	38 96       	adiw	r30, 0x08	; 8
   1468c:	0f b6       	in	r0, 0x3f	; 63
   1468e:	f8 94       	cli
   14690:	fe bf       	out	0x3e, r31	; 62
   14692:	0f be       	out	0x3f, r0	; 63
   14694:	ed bf       	out	0x3d, r30	; 61
   14696:	81 e0       	ldi	r24, 0x01	; 1
   14698:	61 e0       	ldi	r22, 0x01	; 1
   1469a:	a8 01       	movw	r20, r16
   1469c:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   146a0:	00 d0       	rcall	.+0      	; 0x146a2 <FMenuLocalAccount+0x10e6>
   146a2:	00 d0       	rcall	.+0      	; 0x146a4 <FMenuLocalAccount+0x10e8>
   146a4:	00 d0       	rcall	.+0      	; 0x146a6 <FMenuLocalAccount+0x10ea>
   146a6:	ed b7       	in	r30, 0x3d	; 61
   146a8:	fe b7       	in	r31, 0x3e	; 62
   146aa:	31 96       	adiw	r30, 0x01	; 1
   146ac:	ad b7       	in	r26, 0x3d	; 61
   146ae:	be b7       	in	r27, 0x3e	; 62
   146b0:	12 96       	adiw	r26, 0x02	; 2
   146b2:	1c 93       	st	X, r17
   146b4:	0e 93       	st	-X, r16
   146b6:	11 97       	sbiw	r26, 0x01	; 1
   146b8:	8d e3       	ldi	r24, 0x3D	; 61
   146ba:	9d e1       	ldi	r25, 0x1D	; 29
   146bc:	93 83       	std	Z+3, r25	; 0x03
   146be:	82 83       	std	Z+2, r24	; 0x02
   146c0:	f5 82       	std	Z+5, r15	; 0x05
   146c2:	e4 82       	std	Z+4, r14	; 0x04
   146c4:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   146c8:	ed b7       	in	r30, 0x3d	; 61
   146ca:	fe b7       	in	r31, 0x3e	; 62
   146cc:	36 96       	adiw	r30, 0x06	; 6
   146ce:	0f b6       	in	r0, 0x3f	; 63
   146d0:	f8 94       	cli
   146d2:	fe bf       	out	0x3e, r31	; 62
   146d4:	0f be       	out	0x3f, r0	; 63
   146d6:	ed bf       	out	0x3d, r30	; 61
   146d8:	81 e0       	ldi	r24, 0x01	; 1
   146da:	6f e0       	ldi	r22, 0x0F	; 15
   146dc:	a8 01       	movw	r20, r16
   146de:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   146e2:	83 e0       	ldi	r24, 0x03	; 3
   146e4:	61 e0       	ldi	r22, 0x01	; 1
   146e6:	48 e2       	ldi	r20, 0x28	; 40
   146e8:	5d e1       	ldi	r21, 0x1D	; 29
   146ea:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   146ee:	84 e0       	ldi	r24, 0x04	; 4
   146f0:	61 e0       	ldi	r22, 0x01	; 1
   146f2:	43 e1       	ldi	r20, 0x13	; 19
   146f4:	5d e1       	ldi	r21, 0x1D	; 29
   146f6:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				IsMessage00=False;
   146fa:	10 92 cb 01 	sts	0x01CB, r1
				TimLocAcc=0;
   146fe:	10 92 e9 01 	sts	0x01E9, r1
   14702:	10 92 e8 01 	sts	0x01E8, r1
				iLoop=0;iPos=0;iWait=0;
   14706:	10 92 8c 03 	sts	0x038C, r1
   1470a:	10 92 8b 03 	sts	0x038B, r1
   1470e:	10 92 bc 03 	sts	0x03BC, r1
   14712:	10 92 bb 03 	sts	0x03BB, r1
				stLocalAccount=laWaitMessage00;
   14716:	87 e1       	ldi	r24, 0x17	; 23
   14718:	ad ce       	rjmp	.-678    	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laWaitMessage00:
                iLoop++;
   1471a:	80 91 8b 03 	lds	r24, 0x038B
   1471e:	90 91 8c 03 	lds	r25, 0x038C
   14722:	01 96       	adiw	r24, 0x01	; 1
   14724:	90 93 8c 03 	sts	0x038C, r25
   14728:	80 93 8b 03 	sts	0x038B, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   1472c:	68 e9       	ldi	r22, 0x98	; 152
   1472e:	7a e3       	ldi	r23, 0x3A	; 58
   14730:	0e 94 ed b8 	call	0x171da	; 0x171da <__udivmodhi4>
   14734:	89 2b       	or	r24, r25
   14736:	e1 f4       	brne	.+56     	; 0x14770 <FMenuLocalAccount+0x11b4>
				   if (iPos<5){
   14738:	60 91 bc 03 	lds	r22, 0x03BC
   1473c:	65 30       	cpi	r22, 0x05	; 5
   1473e:	58 f4       	brcc	.+22     	; 0x14756 <FMenuLocalAccount+0x119a>
				       iPos++;
   14740:	6f 5f       	subi	r22, 0xFF	; 255
   14742:	60 93 bc 03 	sts	0x03BC, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   14746:	62 5f       	subi	r22, 0xF2	; 242
   14748:	83 e0       	ldi	r24, 0x03	; 3
   1474a:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   1474e:	8e e2       	ldi	r24, 0x2E	; 46
   14750:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
   14754:	0d c0       	rjmp	.+26     	; 0x14770 <FMenuLocalAccount+0x11b4>
					   }
				   else{
				       iPos=0;
   14756:	10 92 bc 03 	sts	0x03BC, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   1475a:	83 e0       	ldi	r24, 0x03	; 3
   1475c:	6e e0       	ldi	r22, 0x0E	; 14
   1475e:	4b e0       	ldi	r20, 0x0B	; 11
   14760:	5d e1       	ldi	r21, 0x1D	; 29
   14762:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
					   iWait++;
   14766:	80 91 bb 03 	lds	r24, 0x03BB
   1476a:	8f 5f       	subi	r24, 0xFF	; 255
   1476c:	80 93 bb 03 	sts	0x03BB, r24
					   }
				}
				if (iWait>5){
   14770:	80 91 bb 03 	lds	r24, 0x03BB
   14774:	86 30       	cpi	r24, 0x06	; 6
   14776:	78 f0       	brcs	.+30     	; 0x14796 <FMenuLocalAccount+0x11da>
				    stLocalAccount=laConTimout;
   14778:	84 e0       	ldi	r24, 0x04	; 4
   1477a:	80 93 71 01 	sts	0x0171, r24
					TimLocAcc=0;
   1477e:	10 92 e9 01 	sts	0x01E9, r1
   14782:	10 92 e8 01 	sts	0x01E8, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14786:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14788:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1478a:	82 e0       	ldi	r24, 0x02	; 2
   1478c:	90 e0       	ldi	r25, 0x00	; 0
   1478e:	90 93 ed 01 	sts	0x01ED, r25
   14792:	80 93 ec 01 	sts	0x01EC, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   14796:	80 91 cb 01 	lds	r24, 0x01CB
   1479a:	81 30       	cpi	r24, 0x01	; 1
   1479c:	09 f0       	breq	.+2      	; 0x147a0 <FMenuLocalAccount+0x11e4>
   1479e:	3d c1       	rjmp	.+634    	; 0x14a1a <FMenuLocalAccount+0x145e>
                    IsMessage00=False;
   147a0:	10 92 cb 01 	sts	0x01CB, r1
				    stLocalAccount=laProcMessage00;
   147a4:	88 e1       	ldi	r24, 0x18	; 24
   147a6:	66 ce       	rjmp	.-820    	; 0x14474 <FMenuLocalAccount+0xeb8>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   147a8:	80 91 20 0b 	lds	r24, 0x0B20
   147ac:	81 30       	cpi	r24, 0x01	; 1
   147ae:	51 f4       	brne	.+20     	; 0x147c4 <FMenuLocalAccount+0x1208>
   147b0:	80 91 b3 01 	lds	r24, 0x01B3
   147b4:	90 91 b4 01 	lds	r25, 0x01B4
   147b8:	8f 97       	sbiw	r24, 0x2f	; 47
   147ba:	21 f4       	brne	.+8      	; 0x147c4 <FMenuLocalAccount+0x1208>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   147bc:	80 91 45 0b 	lds	r24, 0x0B45
   147c0:	80 53       	subi	r24, 0x30	; 48
   147c2:	01 c0       	rjmp	.+2      	; 0x147c6 <FMenuLocalAccount+0x120a>
   147c4:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   147c6:	80 93 bd 03 	sts	0x03BD, r24
                lcd_clear();
   147ca:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
		        switch(LocAccStatus){
   147ce:	10 91 bd 03 	lds	r17, 0x03BD
   147d2:	11 30       	cpi	r17, 0x01	; 1
   147d4:	51 f0       	breq	.+20     	; 0x147ea <FMenuLocalAccount+0x122e>
   147d6:	11 30       	cpi	r17, 0x01	; 1
   147d8:	18 f0       	brcs	.+6      	; 0x147e0 <FMenuLocalAccount+0x1224>
   147da:	13 30       	cpi	r17, 0x03	; 3
   147dc:	69 f5       	brne	.+90     	; 0x14838 <FMenuLocalAccount+0x127c>
   147de:	1b c0       	rjmp	.+54     	; 0x14816 <FMenuLocalAccount+0x125a>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   147e0:	82 e0       	ldi	r24, 0x02	; 2
   147e2:	61 e0       	ldi	r22, 0x01	; 1
   147e4:	46 ef       	ldi	r20, 0xF6	; 246
   147e6:	5c e1       	ldi	r21, 0x1C	; 28
   147e8:	1a c0       	rjmp	.+52     	; 0x1481e <FMenuLocalAccount+0x1262>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   147ea:	82 e0       	ldi	r24, 0x02	; 2
   147ec:	61 e0       	ldi	r22, 0x01	; 1
   147ee:	41 ee       	ldi	r20, 0xE1	; 225
   147f0:	5c e1       	ldi	r21, 0x1C	; 28
   147f2:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   147f6:	90 91 b9 01 	lds	r25, 0x01B9
   147fa:	e9 2f       	mov	r30, r25
   147fc:	f0 e0       	ldi	r31, 0x00	; 0
   147fe:	e5 5a       	subi	r30, 0xA5	; 165
   14800:	fa 4f       	sbci	r31, 0xFA	; 250
   14802:	80 91 8f 03 	lds	r24, 0x038F
   14806:	80 83       	st	Z, r24
					 nLocalAccount++;
   14808:	9f 5f       	subi	r25, 0xFF	; 255
   1480a:	90 93 b9 01 	sts	0x01B9, r25
					 IsViewFillingFIP=True;
   1480e:	10 93 c2 01 	sts	0x01C2, r17
					 stLocalAccount=laViewStatus;
   14812:	86 e1       	ldi	r24, 0x16	; 22
   14814:	0f c0       	rjmp	.+30     	; 0x14834 <FMenuLocalAccount+0x1278>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   14816:	82 e0       	ldi	r24, 0x02	; 2
   14818:	61 e0       	ldi	r22, 0x01	; 1
   1481a:	4e ec       	ldi	r20, 0xCE	; 206
   1481c:	5c e1       	ldi	r21, 0x1C	; 28
   1481e:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14822:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14824:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14826:	82 e0       	ldi	r24, 0x02	; 2
   14828:	90 e0       	ldi	r25, 0x00	; 0
   1482a:	90 93 ed 01 	sts	0x01ED, r25
   1482e:	80 93 ec 01 	sts	0x01EC, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   14832:	8e e1       	ldi	r24, 0x1E	; 30
   14834:	80 93 71 01 	sts	0x0171, r24
				     break;
				}
				TimLocAcc=0;
   14838:	10 92 e9 01 	sts	0x01E9, r1
   1483c:	10 92 e8 01 	sts	0x01E8, r1
				ClearMem(strOdometer);
   14840:	88 ec       	ldi	r24, 0xC8	; 200
   14842:	95 e0       	ldi	r25, 0x05	; 5
   14844:	0e 94 5c ad 	call	0x15ab8	; 0x15ab8 <ClearMem>
	            ClearMem(strLicPlate);
   14848:	8d ef       	ldi	r24, 0xFD	; 253
   1484a:	9a e0       	ldi	r25, 0x0A	; 10
   1484c:	0e 94 5c ad 	call	0x15ab8	; 0x15ab8 <ClearMem>
   14850:	e4 c0       	rjmp	.+456    	; 0x14a1a <FMenuLocalAccount+0x145e>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   14852:	80 91 e8 01 	lds	r24, 0x01E8
   14856:	90 91 e9 01 	lds	r25, 0x01E9
   1485a:	45 97       	sbiw	r24, 0x15	; 21
   1485c:	08 f4       	brcc	.+2      	; 0x14860 <FMenuLocalAccount+0x12a4>
   1485e:	dd c0       	rjmp	.+442    	; 0x14a1a <FMenuLocalAccount+0x145e>
   14860:	d3 c0       	rjmp	.+422    	; 0x14a08 <FMenuLocalAccount+0x144c>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   14862:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14866:	2d b7       	in	r18, 0x3d	; 61
   14868:	3e b7       	in	r19, 0x3e	; 62
   1486a:	28 50       	subi	r18, 0x08	; 8
   1486c:	30 40       	sbci	r19, 0x00	; 0
   1486e:	0f b6       	in	r0, 0x3f	; 63
   14870:	f8 94       	cli
   14872:	3e bf       	out	0x3e, r19	; 62
   14874:	0f be       	out	0x3f, r0	; 63
   14876:	2d bf       	out	0x3d, r18	; 61
   14878:	ed b7       	in	r30, 0x3d	; 61
   1487a:	fe b7       	in	r31, 0x3e	; 62
   1487c:	31 96       	adiw	r30, 0x01	; 1
   1487e:	7e 01       	movw	r14, r28
   14880:	08 94       	sec
   14882:	e1 1c       	adc	r14, r1
   14884:	f1 1c       	adc	r15, r1
   14886:	ad b7       	in	r26, 0x3d	; 61
   14888:	be b7       	in	r27, 0x3e	; 62
   1488a:	12 96       	adiw	r26, 0x02	; 2
   1488c:	fc 92       	st	X, r15
   1488e:	ee 92       	st	-X, r14
   14890:	11 97       	sbiw	r26, 0x01	; 1
   14892:	86 ec       	ldi	r24, 0xC6	; 198
   14894:	9c e1       	ldi	r25, 0x1C	; 28
   14896:	93 83       	std	Z+3, r25	; 0x03
   14898:	82 83       	std	Z+2, r24	; 0x02
   1489a:	86 eb       	ldi	r24, 0xB6	; 182
   1489c:	93 e0       	ldi	r25, 0x03	; 3
   1489e:	95 83       	std	Z+5, r25	; 0x05
   148a0:	84 83       	std	Z+4, r24	; 0x04
   148a2:	88 e6       	ldi	r24, 0x68	; 104
   148a4:	99 e0       	ldi	r25, 0x09	; 9
   148a6:	97 83       	std	Z+7, r25	; 0x07
   148a8:	86 83       	std	Z+6, r24	; 0x06
   148aa:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   148ae:	ed b7       	in	r30, 0x3d	; 61
   148b0:	fe b7       	in	r31, 0x3e	; 62
   148b2:	38 96       	adiw	r30, 0x08	; 8
   148b4:	0f b6       	in	r0, 0x3f	; 63
   148b6:	f8 94       	cli
   148b8:	fe bf       	out	0x3e, r31	; 62
   148ba:	0f be       	out	0x3f, r0	; 63
   148bc:	ed bf       	out	0x3d, r30	; 61
   148be:	81 e0       	ldi	r24, 0x01	; 1
   148c0:	61 e0       	ldi	r22, 0x01	; 1
   148c2:	a7 01       	movw	r20, r14
   148c4:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   148c8:	00 d0       	rcall	.+0      	; 0x148ca <FMenuLocalAccount+0x130e>
   148ca:	00 d0       	rcall	.+0      	; 0x148cc <FMenuLocalAccount+0x1310>
   148cc:	00 d0       	rcall	.+0      	; 0x148ce <FMenuLocalAccount+0x1312>
   148ce:	ed b7       	in	r30, 0x3d	; 61
   148d0:	fe b7       	in	r31, 0x3e	; 62
   148d2:	31 96       	adiw	r30, 0x01	; 1
   148d4:	ad b7       	in	r26, 0x3d	; 61
   148d6:	be b7       	in	r27, 0x3e	; 62
   148d8:	12 96       	adiw	r26, 0x02	; 2
   148da:	fc 92       	st	X, r15
   148dc:	ee 92       	st	-X, r14
   148de:	11 97       	sbiw	r26, 0x01	; 1
   148e0:	83 ec       	ldi	r24, 0xC3	; 195
   148e2:	9c e1       	ldi	r25, 0x1C	; 28
   148e4:	93 83       	std	Z+3, r25	; 0x03
   148e6:	82 83       	std	Z+2, r24	; 0x02
   148e8:	85 e2       	ldi	r24, 0x25	; 37
   148ea:	9e e0       	ldi	r25, 0x0E	; 14
   148ec:	95 83       	std	Z+5, r25	; 0x05
   148ee:	84 83       	std	Z+4, r24	; 0x04
   148f0:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   148f4:	ed b7       	in	r30, 0x3d	; 61
   148f6:	fe b7       	in	r31, 0x3e	; 62
   148f8:	36 96       	adiw	r30, 0x06	; 6
   148fa:	0f b6       	in	r0, 0x3f	; 63
   148fc:	f8 94       	cli
   148fe:	fe bf       	out	0x3e, r31	; 62
   14900:	0f be       	out	0x3f, r0	; 63
   14902:	ed bf       	out	0x3d, r30	; 61
   14904:	81 e0       	ldi	r24, 0x01	; 1
   14906:	6f e0       	ldi	r22, 0x0F	; 15
   14908:	a7 01       	movw	r20, r14
   1490a:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
                RemSpaceLead(strCardID);
   1490e:	0c e8       	ldi	r16, 0x8C	; 140
   14910:	1d e0       	ldi	r17, 0x0D	; 13
   14912:	c8 01       	movw	r24, r16
   14914:	0e 94 e0 23 	call	0x47c0	; 0x47c0 <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   14918:	00 d0       	rcall	.+0      	; 0x1491a <FMenuLocalAccount+0x135e>
   1491a:	00 d0       	rcall	.+0      	; 0x1491c <FMenuLocalAccount+0x1360>
   1491c:	00 d0       	rcall	.+0      	; 0x1491e <FMenuLocalAccount+0x1362>
   1491e:	ed b7       	in	r30, 0x3d	; 61
   14920:	fe b7       	in	r31, 0x3e	; 62
   14922:	31 96       	adiw	r30, 0x01	; 1
   14924:	ad b7       	in	r26, 0x3d	; 61
   14926:	be b7       	in	r27, 0x3e	; 62
   14928:	12 96       	adiw	r26, 0x02	; 2
   1492a:	fc 92       	st	X, r15
   1492c:	ee 92       	st	-X, r14
   1492e:	11 97       	sbiw	r26, 0x01	; 1
   14930:	8c eb       	ldi	r24, 0xBC	; 188
   14932:	9c e1       	ldi	r25, 0x1C	; 28
   14934:	93 83       	std	Z+3, r25	; 0x03
   14936:	82 83       	std	Z+2, r24	; 0x02
   14938:	15 83       	std	Z+5, r17	; 0x05
   1493a:	04 83       	std	Z+4, r16	; 0x04
   1493c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   14940:	ed b7       	in	r30, 0x3d	; 61
   14942:	fe b7       	in	r31, 0x3e	; 62
   14944:	36 96       	adiw	r30, 0x06	; 6
   14946:	0f b6       	in	r0, 0x3f	; 63
   14948:	f8 94       	cli
   1494a:	fe bf       	out	0x3e, r31	; 62
   1494c:	0f be       	out	0x3f, r0	; 63
   1494e:	ed bf       	out	0x3d, r30	; 61
   14950:	82 e0       	ldi	r24, 0x02	; 2
   14952:	61 e0       	ldi	r22, 0x01	; 1
   14954:	a7 01       	movw	r20, r14
   14956:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>
				TimLocAcc=0;
   1495a:	10 92 e9 01 	sts	0x01E9, r1
   1495e:	10 92 e8 01 	sts	0x01E8, r1
		        IsCompleteFilling=False;
   14962:	10 92 d6 01 	sts	0x01D6, r1
				stLocalAccount=laWaitFilling;
   14966:	8d e1       	ldi	r24, 0x1D	; 29
   14968:	85 cd       	rjmp	.-1270   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   1496a:	80 91 d6 01 	lds	r24, 0x01D6
   1496e:	81 30       	cpi	r24, 0x01	; 1
   14970:	39 f0       	breq	.+14     	; 0x14980 <FMenuLocalAccount+0x13c4>
   14972:	80 91 e8 01 	lds	r24, 0x01E8
   14976:	90 91 e9 01 	lds	r25, 0x01E9
   1497a:	0b 97       	sbiw	r24, 0x0b	; 11
   1497c:	08 f4       	brcc	.+2      	; 0x14980 <FMenuLocalAccount+0x13c4>
   1497e:	4d c0       	rjmp	.+154    	; 0x14a1a <FMenuLocalAccount+0x145e>
				    IsCompleteFilling=False;
   14980:	10 92 d6 01 	sts	0x01D6, r1
				    stLocalAccount=laSuccessTransaction;
   14984:	89 e1       	ldi	r24, 0x19	; 25
   14986:	80 93 71 01 	sts	0x0171, r24
					TimLocAcc=0;
   1498a:	10 92 e9 01 	sts	0x01E9, r1
   1498e:	10 92 e8 01 	sts	0x01E8, r1
   14992:	43 c0       	rjmp	.+134    	; 0x14a1a <FMenuLocalAccount+0x145e>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   14994:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   14998:	82 e0       	ldi	r24, 0x02	; 2
   1499a:	61 e0       	ldi	r22, 0x01	; 1
   1499c:	4a ea       	ldi	r20, 0xAA	; 170
   1499e:	5c e1       	ldi	r21, 0x1C	; 28
   149a0:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   149a4:	00 d0       	rcall	.+0      	; 0x149a6 <FMenuLocalAccount+0x13ea>
   149a6:	00 d0       	rcall	.+0      	; 0x149a8 <FMenuLocalAccount+0x13ec>
   149a8:	00 d0       	rcall	.+0      	; 0x149aa <FMenuLocalAccount+0x13ee>
   149aa:	ed b7       	in	r30, 0x3d	; 61
   149ac:	fe b7       	in	r31, 0x3e	; 62
   149ae:	31 96       	adiw	r30, 0x01	; 1
   149b0:	8e 01       	movw	r16, r28
   149b2:	0f 5f       	subi	r16, 0xFF	; 255
   149b4:	1f 4f       	sbci	r17, 0xFF	; 255
   149b6:	ad b7       	in	r26, 0x3d	; 61
   149b8:	be b7       	in	r27, 0x3e	; 62
   149ba:	12 96       	adiw	r26, 0x02	; 2
   149bc:	1c 93       	st	X, r17
   149be:	0e 93       	st	-X, r16
   149c0:	11 97       	sbiw	r26, 0x01	; 1
   149c2:	89 e9       	ldi	r24, 0x99	; 153
   149c4:	9c e1       	ldi	r25, 0x1C	; 28
   149c6:	93 83       	std	Z+3, r25	; 0x03
   149c8:	82 83       	std	Z+2, r24	; 0x02
   149ca:	80 91 8f 03 	lds	r24, 0x038F
   149ce:	84 83       	std	Z+4, r24	; 0x04
   149d0:	15 82       	std	Z+5, r1	; 0x05
   149d2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
				lcd_print(3,1,lcdteks);
   149d6:	ed b7       	in	r30, 0x3d	; 61
   149d8:	fe b7       	in	r31, 0x3e	; 62
   149da:	36 96       	adiw	r30, 0x06	; 6
   149dc:	0f b6       	in	r0, 0x3f	; 63
   149de:	f8 94       	cli
   149e0:	fe bf       	out	0x3e, r31	; 62
   149e2:	0f be       	out	0x3f, r0	; 63
   149e4:	ed bf       	out	0x3d, r30	; 61
   149e6:	83 e0       	ldi	r24, 0x03	; 3
   149e8:	61 e0       	ldi	r22, 0x01	; 1
   149ea:	a8 01       	movw	r20, r16
   149ec:	0e 94 c3 ac 	call	0x15986	; 0x15986 <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   149f0:	10 92 e9 01 	sts	0x01E9, r1
   149f4:	10 92 e8 01 	sts	0x01E8, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   149f8:	8e e1       	ldi	r24, 0x1E	; 30
   149fa:	3c cd       	rjmp	.-1416   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   149fc:	80 91 e8 01 	lds	r24, 0x01E8
   14a00:	90 91 e9 01 	lds	r25, 0x01E9
   14a04:	40 97       	sbiw	r24, 0x10	; 16
   14a06:	48 f0       	brcs	.+18     	; 0x14a1a <FMenuLocalAccount+0x145e>
   14a08:	8f e1       	ldi	r24, 0x1F	; 31
   14a0a:	34 cd       	rjmp	.-1432   	; 0x14474 <FMenuLocalAccount+0xeb8>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   14a0c:	81 e0       	ldi	r24, 0x01	; 1
   14a0e:	80 93 71 01 	sts	0x0171, r24
				lcd_clear();
   14a12:	0e 94 1c ad 	call	0x15a38	; 0x15a38 <lcd_clear>
   14a16:	81 e0       	ldi	r24, 0x01	; 1
   14a18:	01 c0       	rjmp	.+2      	; 0x14a1c <FMenuLocalAccount+0x1460>
   14a1a:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   14a1c:	a9 96       	adiw	r28, 0x29	; 41
   14a1e:	0f b6       	in	r0, 0x3f	; 63
   14a20:	f8 94       	cli
   14a22:	de bf       	out	0x3e, r29	; 62
   14a24:	0f be       	out	0x3f, r0	; 63
   14a26:	cd bf       	out	0x3d, r28	; 61
   14a28:	cf 91       	pop	r28
   14a2a:	df 91       	pop	r29
   14a2c:	1f 91       	pop	r17
   14a2e:	0f 91       	pop	r16
   14a30:	ff 90       	pop	r15
   14a32:	ef 90       	pop	r14
   14a34:	df 90       	pop	r13
   14a36:	cf 90       	pop	r12
   14a38:	bf 90       	pop	r11
   14a3a:	af 90       	pop	r10
   14a3c:	08 95       	ret

00014a3e <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
   14a3e:	8f 92       	push	r8
   14a40:	9f 92       	push	r9
   14a42:	af 92       	push	r10
   14a44:	bf 92       	push	r11
   14a46:	cf 92       	push	r12
   14a48:	df 92       	push	r13
   14a4a:	ef 92       	push	r14
   14a4c:	ff 92       	push	r15
   14a4e:	0f 93       	push	r16
   14a50:	1f 93       	push	r17
   14a52:	df 93       	push	r29
   14a54:	cf 93       	push	r28
   14a56:	cd b7       	in	r28, 0x3d	; 61
   14a58:	de b7       	in	r29, 0x3e	; 62
   14a5a:	c5 56       	subi	r28, 0x65	; 101
   14a5c:	d0 40       	sbci	r29, 0x00	; 0
   14a5e:	0f b6       	in	r0, 0x3f	; 63
   14a60:	f8 94       	cli
   14a62:	de bf       	out	0x3e, r29	; 62
   14a64:	0f be       	out	0x3f, r0	; 63
   14a66:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
   14a68:	81 e0       	ldi	r24, 0x01	; 1
   14a6a:	60 e0       	ldi	r22, 0x00	; 0
   14a6c:	4f ec       	ldi	r20, 0xCF	; 207
   14a6e:	51 e2       	ldi	r21, 0x21	; 33
   14a70:	0e 94 74 b4 	call	0x168e8	; 0x168e8 <_uart_printf>
   14a74:	07 e5       	ldi	r16, 0x57	; 87
   14a76:	12 e0       	ldi	r17, 0x02	; 2
   14a78:	6e 01       	movw	r12, r28
   14a7a:	08 94       	sec
   14a7c:	c1 1c       	adc	r12, r1
   14a7e:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14a80:	7a e2       	ldi	r23, 0x2A	; 42
   14a82:	e7 2e       	mov	r14, r23
   14a84:	f1 2c       	mov	r15, r1
   14a86:	ec 0e       	add	r14, r28
   14a88:	fd 1e       	adc	r15, r29
   14a8a:	6c ec       	ldi	r22, 0xCC	; 204
   14a8c:	a6 2e       	mov	r10, r22
   14a8e:	61 e2       	ldi	r22, 0x21	; 33
   14a90:	b6 2e       	mov	r11, r22
   14a92:	c6 01       	movw	r24, r12
   14a94:	b8 01       	movw	r22, r16
   14a96:	49 e2       	ldi	r20, 0x29	; 41
   14a98:	50 e0       	ldi	r21, 0x00	; 0
   14a9a:	27 e9       	ldi	r18, 0x97	; 151
   14a9c:	32 e1       	ldi	r19, 0x12	; 18
   14a9e:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
   14aa2:	00 d0       	rcall	.+0      	; 0x14aa4 <SendConfigParamater+0x66>
   14aa4:	00 d0       	rcall	.+0      	; 0x14aa6 <SendConfigParamater+0x68>
   14aa6:	00 d0       	rcall	.+0      	; 0x14aa8 <SendConfigParamater+0x6a>
   14aa8:	ed b7       	in	r30, 0x3d	; 61
   14aaa:	fe b7       	in	r31, 0x3e	; 62
   14aac:	31 96       	adiw	r30, 0x01	; 1
   14aae:	ad b7       	in	r26, 0x3d	; 61
   14ab0:	be b7       	in	r27, 0x3e	; 62
   14ab2:	12 96       	adiw	r26, 0x02	; 2
   14ab4:	fc 92       	st	X, r15
   14ab6:	ee 92       	st	-X, r14
   14ab8:	11 97       	sbiw	r26, 0x01	; 1
   14aba:	b3 82       	std	Z+3, r11	; 0x03
   14abc:	a2 82       	std	Z+2, r10	; 0x02
   14abe:	d5 82       	std	Z+5, r13	; 0x05
   14ac0:	c4 82       	std	Z+4, r12	; 0x04
   14ac2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  AddSpaceLag(strSend,40);
   14ac6:	ed b7       	in	r30, 0x3d	; 61
   14ac8:	fe b7       	in	r31, 0x3e	; 62
   14aca:	36 96       	adiw	r30, 0x06	; 6
   14acc:	0f b6       	in	r0, 0x3f	; 63
   14ace:	f8 94       	cli
   14ad0:	fe bf       	out	0x3e, r31	; 62
   14ad2:	0f be       	out	0x3f, r0	; 63
   14ad4:	ed bf       	out	0x3d, r30	; 61
   14ad6:	c7 01       	movw	r24, r14
   14ad8:	68 e2       	ldi	r22, 0x28	; 40
   14ada:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
		  _uart_print(1,0,strSend);
   14ade:	81 e0       	ldi	r24, 0x01	; 1
   14ae0:	60 e0       	ldi	r22, 0x00	; 0
   14ae2:	a7 01       	movw	r20, r14
   14ae4:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
   14ae8:	07 5d       	subi	r16, 0xD7	; 215
   14aea:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   14aec:	f3 e0       	ldi	r31, 0x03	; 3
   14aee:	01 3f       	cpi	r16, 0xF1	; 241
   14af0:	1f 07       	cpc	r17, r31
   14af2:	79 f6       	brne	.-98     	; 0x14a92 <SendConfigParamater+0x54>
   14af4:	0b ee       	ldi	r16, 0xEB	; 235
   14af6:	10 e0       	ldi	r17, 0x00	; 0
   14af8:	6e 01       	movw	r12, r28
   14afa:	08 94       	sec
   14afc:	c1 1c       	adc	r12, r1
   14afe:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14b00:	5a e2       	ldi	r21, 0x2A	; 42
   14b02:	e5 2e       	mov	r14, r21
   14b04:	f1 2c       	mov	r15, r1
   14b06:	ec 0e       	add	r14, r28
   14b08:	fd 1e       	adc	r15, r29
   14b0a:	49 ec       	ldi	r20, 0xC9	; 201
   14b0c:	a4 2e       	mov	r10, r20
   14b0e:	41 e2       	ldi	r20, 0x21	; 33
   14b10:	b4 2e       	mov	r11, r20
   14b12:	c6 01       	movw	r24, r12
   14b14:	b8 01       	movw	r22, r16
   14b16:	4d e0       	ldi	r20, 0x0D	; 13
   14b18:	50 e0       	ldi	r21, 0x00	; 0
   14b1a:	27 e9       	ldi	r18, 0x97	; 151
   14b1c:	32 e1       	ldi	r19, 0x12	; 18
   14b1e:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
   14b22:	00 d0       	rcall	.+0      	; 0x14b24 <SendConfigParamater+0xe6>
   14b24:	00 d0       	rcall	.+0      	; 0x14b26 <SendConfigParamater+0xe8>
   14b26:	00 d0       	rcall	.+0      	; 0x14b28 <SendConfigParamater+0xea>
   14b28:	ed b7       	in	r30, 0x3d	; 61
   14b2a:	fe b7       	in	r31, 0x3e	; 62
   14b2c:	31 96       	adiw	r30, 0x01	; 1
   14b2e:	ad b7       	in	r26, 0x3d	; 61
   14b30:	be b7       	in	r27, 0x3e	; 62
   14b32:	12 96       	adiw	r26, 0x02	; 2
   14b34:	fc 92       	st	X, r15
   14b36:	ee 92       	st	-X, r14
   14b38:	11 97       	sbiw	r26, 0x01	; 1
   14b3a:	b3 82       	std	Z+3, r11	; 0x03
   14b3c:	a2 82       	std	Z+2, r10	; 0x02
   14b3e:	d5 82       	std	Z+5, r13	; 0x05
   14b40:	c4 82       	std	Z+4, r12	; 0x04
   14b42:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 AddSpaceLag(strSend,12);
   14b46:	ed b7       	in	r30, 0x3d	; 61
   14b48:	fe b7       	in	r31, 0x3e	; 62
   14b4a:	36 96       	adiw	r30, 0x06	; 6
   14b4c:	0f b6       	in	r0, 0x3f	; 63
   14b4e:	f8 94       	cli
   14b50:	fe bf       	out	0x3e, r31	; 62
   14b52:	0f be       	out	0x3f, r0	; 63
   14b54:	ed bf       	out	0x3d, r30	; 61
   14b56:	c7 01       	movw	r24, r14
   14b58:	6c e0       	ldi	r22, 0x0C	; 12
   14b5a:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14b5e:	81 e0       	ldi	r24, 0x01	; 1
   14b60:	60 e0       	ldi	r22, 0x00	; 0
   14b62:	a7 01       	movw	r20, r14
   14b64:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
   14b68:	03 5f       	subi	r16, 0xF3	; 243
   14b6a:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  _uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   14b6c:	f1 e0       	ldi	r31, 0x01	; 1
   14b6e:	09 33       	cpi	r16, 0x39	; 57
   14b70:	1f 07       	cpc	r17, r31
   14b72:	79 f6       	brne	.-98     	; 0x14b12 <SendConfigParamater+0xd4>
   14b74:	05 eb       	ldi	r16, 0xB5	; 181
   14b76:	10 e0       	ldi	r17, 0x00	; 0
   14b78:	6e 01       	movw	r12, r28
   14b7a:	08 94       	sec
   14b7c:	c1 1c       	adc	r12, r1
   14b7e:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14b80:	3a e2       	ldi	r19, 0x2A	; 42
   14b82:	e3 2e       	mov	r14, r19
   14b84:	f1 2c       	mov	r15, r1
   14b86:	ec 0e       	add	r14, r28
   14b88:	fd 1e       	adc	r15, r29
   14b8a:	26 ec       	ldi	r18, 0xC6	; 198
   14b8c:	a2 2e       	mov	r10, r18
   14b8e:	21 e2       	ldi	r18, 0x21	; 33
   14b90:	b2 2e       	mov	r11, r18
   14b92:	c6 01       	movw	r24, r12
   14b94:	b8 01       	movw	r22, r16
   14b96:	49 e0       	ldi	r20, 0x09	; 9
   14b98:	50 e0       	ldi	r21, 0x00	; 0
   14b9a:	27 e9       	ldi	r18, 0x97	; 151
   14b9c:	32 e1       	ldi	r19, 0x12	; 18
   14b9e:	0e 94 d4 b5 	call	0x16ba8	; 0x16ba8 <__eerd_block>
   14ba2:	00 d0       	rcall	.+0      	; 0x14ba4 <SendConfigParamater+0x166>
   14ba4:	00 d0       	rcall	.+0      	; 0x14ba6 <SendConfigParamater+0x168>
   14ba6:	00 d0       	rcall	.+0      	; 0x14ba8 <SendConfigParamater+0x16a>
   14ba8:	ed b7       	in	r30, 0x3d	; 61
   14baa:	fe b7       	in	r31, 0x3e	; 62
   14bac:	31 96       	adiw	r30, 0x01	; 1
   14bae:	ad b7       	in	r26, 0x3d	; 61
   14bb0:	be b7       	in	r27, 0x3e	; 62
   14bb2:	12 96       	adiw	r26, 0x02	; 2
   14bb4:	fc 92       	st	X, r15
   14bb6:	ee 92       	st	-X, r14
   14bb8:	11 97       	sbiw	r26, 0x01	; 1
   14bba:	b3 82       	std	Z+3, r11	; 0x03
   14bbc:	a2 82       	std	Z+2, r10	; 0x02
   14bbe:	d5 82       	std	Z+5, r13	; 0x05
   14bc0:	c4 82       	std	Z+4, r12	; 0x04
   14bc2:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		 AddSpaceLag(strSend,5);
   14bc6:	ed b7       	in	r30, 0x3d	; 61
   14bc8:	fe b7       	in	r31, 0x3e	; 62
   14bca:	36 96       	adiw	r30, 0x06	; 6
   14bcc:	0f b6       	in	r0, 0x3f	; 63
   14bce:	f8 94       	cli
   14bd0:	fe bf       	out	0x3e, r31	; 62
   14bd2:	0f be       	out	0x3f, r0	; 63
   14bd4:	ed bf       	out	0x3d, r30	; 61
   14bd6:	c7 01       	movw	r24, r14
   14bd8:	65 e0       	ldi	r22, 0x05	; 5
   14bda:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14bde:	81 e0       	ldi	r24, 0x01	; 1
   14be0:	60 e0       	ldi	r22, 0x00	; 0
   14be2:	a7 01       	movw	r20, r14
   14be4:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
   14be8:	07 5f       	subi	r16, 0xF7	; 247
   14bea:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 _uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   14bec:	f0 e0       	ldi	r31, 0x00	; 0
   14bee:	0b 3e       	cpi	r16, 0xEB	; 235
   14bf0:	1f 07       	cpc	r17, r31
   14bf2:	79 f6       	brne	.-98     	; 0x14b92 <SendConfigParamater+0x154>
   14bf4:	05 e4       	ldi	r16, 0x45	; 69
   14bf6:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14bf8:	9a e2       	ldi	r25, 0x2A	; 42
   14bfa:	e9 2e       	mov	r14, r25
   14bfc:	f1 2c       	mov	r15, r1
   14bfe:	ec 0e       	add	r14, r28
   14c00:	fd 1e       	adc	r15, r29
   14c02:	81 ec       	ldi	r24, 0xC1	; 193
   14c04:	c8 2e       	mov	r12, r24
   14c06:	81 e2       	ldi	r24, 0x21	; 33
   14c08:	d8 2e       	mov	r13, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14c0a:	e1 99       	sbic	0x1c, 1	; 28
   14c0c:	fe cf       	rjmp	.-4      	; 0x14c0a <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14c0e:	1f bb       	out	0x1f, r17	; 31
   14c10:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14c12:	e0 9a       	sbi	0x1c, 0	; 28
   14c14:	8d b3       	in	r24, 0x1d	; 29
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14c16:	84 36       	cpi	r24, 0x64	; 100
   14c18:	08 f0       	brcs	.+2      	; 0x14c1c <SendConfigParamater+0x1de>
   14c1a:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14c1c:	00 d0       	rcall	.+0      	; 0x14c1e <SendConfigParamater+0x1e0>
   14c1e:	00 d0       	rcall	.+0      	; 0x14c20 <SendConfigParamater+0x1e2>
   14c20:	00 d0       	rcall	.+0      	; 0x14c22 <SendConfigParamater+0x1e4>
   14c22:	ed b7       	in	r30, 0x3d	; 61
   14c24:	fe b7       	in	r31, 0x3e	; 62
   14c26:	31 96       	adiw	r30, 0x01	; 1
   14c28:	ad b7       	in	r26, 0x3d	; 61
   14c2a:	be b7       	in	r27, 0x3e	; 62
   14c2c:	12 96       	adiw	r26, 0x02	; 2
   14c2e:	fc 92       	st	X, r15
   14c30:	ee 92       	st	-X, r14
   14c32:	11 97       	sbiw	r26, 0x01	; 1
   14c34:	d3 82       	std	Z+3, r13	; 0x03
   14c36:	c2 82       	std	Z+2, r12	; 0x02
   14c38:	84 83       	std	Z+4, r24	; 0x04
   14c3a:	15 82       	std	Z+5, r1	; 0x05
   14c3c:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  AddSpaceLag(strSend,2);
   14c40:	ed b7       	in	r30, 0x3d	; 61
   14c42:	fe b7       	in	r31, 0x3e	; 62
   14c44:	36 96       	adiw	r30, 0x06	; 6
   14c46:	0f b6       	in	r0, 0x3f	; 63
   14c48:	f8 94       	cli
   14c4a:	fe bf       	out	0x3e, r31	; 62
   14c4c:	0f be       	out	0x3f, r0	; 63
   14c4e:	ed bf       	out	0x3d, r30	; 61
   14c50:	c7 01       	movw	r24, r14
   14c52:	62 e0       	ldi	r22, 0x02	; 2
   14c54:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14c58:	81 e0       	ldi	r24, 0x01	; 1
   14c5a:	60 e0       	ldi	r22, 0x00	; 0
   14c5c:	a7 01       	movw	r20, r14
   14c5e:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
   14c62:	0f 5f       	subi	r16, 0xFF	; 255
   14c64:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   14c66:	f0 e0       	ldi	r31, 0x00	; 0
   14c68:	0d 34       	cpi	r16, 0x4D	; 77
   14c6a:	1f 07       	cpc	r17, r31
   14c6c:	71 f6       	brne	.-100    	; 0x14c0a <SendConfigParamater+0x1cc>
   14c6e:	b5 e5       	ldi	r27, 0x55	; 85
   14c70:	eb 2e       	mov	r14, r27
   14c72:	b0 e0       	ldi	r27, 0x00	; 0
   14c74:	fb 2e       	mov	r15, r27
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14c76:	aa e2       	ldi	r26, 0x2A	; 42
   14c78:	aa 2e       	mov	r10, r26
   14c7a:	b1 2c       	mov	r11, r1
   14c7c:	ac 0e       	add	r10, r28
   14c7e:	bd 1e       	adc	r11, r29
   14c80:	fe eb       	ldi	r31, 0xBE	; 190
   14c82:	8f 2e       	mov	r8, r31
   14c84:	f1 e2       	ldi	r31, 0x21	; 33
   14c86:	9f 2e       	mov	r9, r31
   14c88:	37 c0       	rjmp	.+110    	; 0x14cf8 <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14c8a:	e1 99       	sbic	0x1c, 1	; 28
   14c8c:	fe cf       	rjmp	.-4      	; 0x14c8a <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14c8e:	1f bb       	out	0x1f, r17	; 31
   14c90:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14c92:	e0 9a       	sbi	0x1c, 0	; 28
   14c94:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   14c96:	8a 30       	cpi	r24, 0x0A	; 10
   14c98:	08 f0       	brcs	.+2      	; 0x14c9c <SendConfigParamater+0x25e>
   14c9a:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14c9c:	00 d0       	rcall	.+0      	; 0x14c9e <SendConfigParamater+0x260>
   14c9e:	00 d0       	rcall	.+0      	; 0x14ca0 <SendConfigParamater+0x262>
   14ca0:	00 d0       	rcall	.+0      	; 0x14ca2 <SendConfigParamater+0x264>
   14ca2:	ed b7       	in	r30, 0x3d	; 61
   14ca4:	fe b7       	in	r31, 0x3e	; 62
   14ca6:	31 96       	adiw	r30, 0x01	; 1
   14ca8:	ad b7       	in	r26, 0x3d	; 61
   14caa:	be b7       	in	r27, 0x3e	; 62
   14cac:	12 96       	adiw	r26, 0x02	; 2
   14cae:	bc 92       	st	X, r11
   14cb0:	ae 92       	st	-X, r10
   14cb2:	11 97       	sbiw	r26, 0x01	; 1
   14cb4:	93 82       	std	Z+3, r9	; 0x03
   14cb6:	82 82       	std	Z+2, r8	; 0x02
   14cb8:	84 83       	std	Z+4, r24	; 0x04
   14cba:	15 82       	std	Z+5, r1	; 0x05
   14cbc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
			   _uart_print(1,0,strSend);
   14cc0:	ed b7       	in	r30, 0x3d	; 61
   14cc2:	fe b7       	in	r31, 0x3e	; 62
   14cc4:	36 96       	adiw	r30, 0x06	; 6
   14cc6:	0f b6       	in	r0, 0x3f	; 63
   14cc8:	f8 94       	cli
   14cca:	fe bf       	out	0x3e, r31	; 62
   14ccc:	0f be       	out	0x3f, r0	; 63
   14cce:	ed bf       	out	0x3d, r30	; 61
   14cd0:	81 e0       	ldi	r24, 0x01	; 1
   14cd2:	60 e0       	ldi	r22, 0x00	; 0
   14cd4:	a5 01       	movw	r20, r10
   14cd6:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   14cda:	d3 94       	inc	r13
   14cdc:	0f 5f       	subi	r16, 0xFF	; 255
   14cde:	1f 4f       	sbci	r17, 0xFF	; 255
   14ce0:	f6 e0       	ldi	r31, 0x06	; 6
   14ce2:	df 16       	cp	r13, r31
   14ce4:	91 f6       	brne	.-92     	; 0x14c8a <SendConfigParamater+0x24c>
   14ce6:	86 e0       	ldi	r24, 0x06	; 6
   14ce8:	90 e0       	ldi	r25, 0x00	; 0
   14cea:	e8 0e       	add	r14, r24
   14cec:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   14cee:	95 e8       	ldi	r25, 0x85	; 133
   14cf0:	e9 16       	cp	r14, r25
   14cf2:	90 e0       	ldi	r25, 0x00	; 0
   14cf4:	f9 06       	cpc	r15, r25
   14cf6:	19 f0       	breq	.+6      	; 0x14cfe <SendConfigParamater+0x2c0>
   14cf8:	87 01       	movw	r16, r14
   14cfa:	dd 24       	eor	r13, r13
   14cfc:	c6 cf       	rjmp	.-116    	; 0x14c8a <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14cfe:	e1 99       	sbic	0x1c, 1	; 28
   14d00:	fe cf       	rjmp	.-4      	; 0x14cfe <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14d02:	81 ef       	ldi	r24, 0xF1	; 241
   14d04:	93 e0       	ldi	r25, 0x03	; 3
   14d06:	9f bb       	out	0x1f, r25	; 31
   14d08:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14d0a:	e0 9a       	sbi	0x1c, 0	; 28
   14d0c:	8d b3       	in	r24, 0x1d	; 29
   14d0e:	9e 01       	movw	r18, r28
   14d10:	26 5d       	subi	r18, 0xD6	; 214
   14d12:	3f 4f       	sbci	r19, 0xFF	; 255
			   _uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   14d14:	81 30       	cpi	r24, 0x01	; 1
   14d16:	79 f4       	brne	.+30     	; 0x14d36 <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   14d18:	00 d0       	rcall	.+0      	; 0x14d1a <SendConfigParamater+0x2dc>
   14d1a:	00 d0       	rcall	.+0      	; 0x14d1c <SendConfigParamater+0x2de>
   14d1c:	ad b7       	in	r26, 0x3d	; 61
   14d1e:	be b7       	in	r27, 0x3e	; 62
   14d20:	12 96       	adiw	r26, 0x02	; 2
   14d22:	3c 93       	st	X, r19
   14d24:	2e 93       	st	-X, r18
   14d26:	11 97       	sbiw	r26, 0x01	; 1
   14d28:	8c eb       	ldi	r24, 0xBC	; 188
   14d2a:	91 e2       	ldi	r25, 0x21	; 33
   14d2c:	14 96       	adiw	r26, 0x04	; 4
   14d2e:	9c 93       	st	X, r25
   14d30:	8e 93       	st	-X, r24
   14d32:	13 97       	sbiw	r26, 0x03	; 3
   14d34:	0a c0       	rjmp	.+20     	; 0x14d4a <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   14d36:	00 d0       	rcall	.+0      	; 0x14d38 <SendConfigParamater+0x2fa>
   14d38:	00 d0       	rcall	.+0      	; 0x14d3a <SendConfigParamater+0x2fc>
   14d3a:	ed b7       	in	r30, 0x3d	; 61
   14d3c:	fe b7       	in	r31, 0x3e	; 62
   14d3e:	32 83       	std	Z+2, r19	; 0x02
   14d40:	21 83       	std	Z+1, r18	; 0x01
   14d42:	8a eb       	ldi	r24, 0xBA	; 186
   14d44:	91 e2       	ldi	r25, 0x21	; 33
   14d46:	94 83       	std	Z+4, r25	; 0x04
   14d48:	83 83       	std	Z+3, r24	; 0x03
   14d4a:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   14d4e:	0f 90       	pop	r0
   14d50:	0f 90       	pop	r0
   14d52:	0f 90       	pop	r0
   14d54:	0f 90       	pop	r0
	 }_uart_print(1,0,strSend);
   14d56:	81 e0       	ldi	r24, 0x01	; 1
   14d58:	60 e0       	ldi	r22, 0x00	; 0
   14d5a:	ae 01       	movw	r20, r28
   14d5c:	46 5d       	subi	r20, 0xD6	; 214
   14d5e:	5f 4f       	sbci	r21, 0xFF	; 255
   14d60:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14d64:	e1 99       	sbic	0x1c, 1	; 28
   14d66:	fe cf       	rjmp	.-4      	; 0x14d64 <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14d68:	80 e0       	ldi	r24, 0x00	; 0
   14d6a:	90 e0       	ldi	r25, 0x00	; 0
   14d6c:	9f bb       	out	0x1f, r25	; 31
   14d6e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14d70:	e0 9a       	sbi	0x1c, 0	; 28
   14d72:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14d74:	00 d0       	rcall	.+0      	; 0x14d76 <SendConfigParamater+0x338>
   14d76:	00 d0       	rcall	.+0      	; 0x14d78 <SendConfigParamater+0x33a>
   14d78:	00 d0       	rcall	.+0      	; 0x14d7a <SendConfigParamater+0x33c>
   14d7a:	ed b7       	in	r30, 0x3d	; 61
   14d7c:	fe b7       	in	r31, 0x3e	; 62
   14d7e:	31 96       	adiw	r30, 0x01	; 1
   14d80:	8e 01       	movw	r16, r28
   14d82:	06 5d       	subi	r16, 0xD6	; 214
   14d84:	1f 4f       	sbci	r17, 0xFF	; 255
   14d86:	ad b7       	in	r26, 0x3d	; 61
   14d88:	be b7       	in	r27, 0x3e	; 62
   14d8a:	12 96       	adiw	r26, 0x02	; 2
   14d8c:	1c 93       	st	X, r17
   14d8e:	0e 93       	st	-X, r16
   14d90:	11 97       	sbiw	r26, 0x01	; 1
   14d92:	85 eb       	ldi	r24, 0xB5	; 181
   14d94:	91 e2       	ldi	r25, 0x21	; 33
   14d96:	93 83       	std	Z+3, r25	; 0x03
   14d98:	82 83       	std	Z+2, r24	; 0x02
   14d9a:	24 83       	std	Z+4, r18	; 0x04
   14d9c:	15 82       	std	Z+5, r1	; 0x05
   14d9e:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
     _uart_print(1,0,strSend);
   14da2:	ed b7       	in	r30, 0x3d	; 61
   14da4:	fe b7       	in	r31, 0x3e	; 62
   14da6:	36 96       	adiw	r30, 0x06	; 6
   14da8:	0f b6       	in	r0, 0x3f	; 63
   14daa:	f8 94       	cli
   14dac:	fe bf       	out	0x3e, r31	; 62
   14dae:	0f be       	out	0x3f, r0	; 63
   14db0:	ed bf       	out	0x3d, r30	; 61
   14db2:	81 e0       	ldi	r24, 0x01	; 1
   14db4:	60 e0       	ldi	r22, 0x00	; 0
   14db6:	a8 01       	movw	r20, r16
   14db8:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
   14dbc:	ed e4       	ldi	r30, 0x4D	; 77
   14dbe:	ee 2e       	mov	r14, r30
   14dc0:	e0 e0       	ldi	r30, 0x00	; 0
   14dc2:	fe 2e       	mov	r15, r30
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14dc4:	d0 2e       	mov	r13, r16
   14dc6:	01 2f       	mov	r16, r17
   14dc8:	70 eb       	ldi	r23, 0xB0	; 176
   14dca:	a7 2e       	mov	r10, r23
   14dcc:	71 e2       	ldi	r23, 0x21	; 33
   14dce:	b7 2e       	mov	r11, r23
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14dd0:	e1 99       	sbic	0x1c, 1	; 28
   14dd2:	fe cf       	rjmp	.-4      	; 0x14dd0 <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14dd4:	ff ba       	out	0x1f, r15	; 31
   14dd6:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14dd8:	e0 9a       	sbi	0x1c, 0	; 28
   14dda:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14ddc:	84 36       	cpi	r24, 0x64	; 100
   14dde:	08 f0       	brcs	.+2      	; 0x14de2 <SendConfigParamater+0x3a4>
   14de0:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14de2:	00 d0       	rcall	.+0      	; 0x14de4 <SendConfigParamater+0x3a6>
   14de4:	00 d0       	rcall	.+0      	; 0x14de6 <SendConfigParamater+0x3a8>
   14de6:	00 d0       	rcall	.+0      	; 0x14de8 <SendConfigParamater+0x3aa>
   14de8:	ed b7       	in	r30, 0x3d	; 61
   14dea:	fe b7       	in	r31, 0x3e	; 62
   14dec:	31 96       	adiw	r30, 0x01	; 1
   14dee:	ad b7       	in	r26, 0x3d	; 61
   14df0:	be b7       	in	r27, 0x3e	; 62
   14df2:	11 96       	adiw	r26, 0x01	; 1
   14df4:	dc 92       	st	X, r13
   14df6:	11 97       	sbiw	r26, 0x01	; 1
   14df8:	12 96       	adiw	r26, 0x02	; 2
   14dfa:	0c 93       	st	X, r16
   14dfc:	b3 82       	std	Z+3, r11	; 0x03
   14dfe:	a2 82       	std	Z+2, r10	; 0x02
   14e00:	84 83       	std	Z+4, r24	; 0x04
   14e02:	15 82       	std	Z+5, r1	; 0x05
   14e04:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
		  AddSpaceLag(strSend,2);
   14e08:	ed b7       	in	r30, 0x3d	; 61
   14e0a:	fe b7       	in	r31, 0x3e	; 62
   14e0c:	36 96       	adiw	r30, 0x06	; 6
   14e0e:	0f b6       	in	r0, 0x3f	; 63
   14e10:	f8 94       	cli
   14e12:	fe bf       	out	0x3e, r31	; 62
   14e14:	0f be       	out	0x3f, r0	; 63
   14e16:	ed bf       	out	0x3d, r30	; 61
   14e18:	8d 2d       	mov	r24, r13
   14e1a:	90 2f       	mov	r25, r16
   14e1c:	62 e0       	ldi	r22, 0x02	; 2
   14e1e:	0e 94 80 2a 	call	0x5500	; 0x5500 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14e22:	81 e0       	ldi	r24, 0x01	; 1
   14e24:	60 e0       	ldi	r22, 0x00	; 0
   14e26:	4d 2d       	mov	r20, r13
   14e28:	50 2f       	mov	r21, r16
   14e2a:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>
   14e2e:	08 94       	sec
   14e30:	e1 1c       	adc	r14, r1
   14e32:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   14e34:	f5 e5       	ldi	r31, 0x55	; 85
   14e36:	ef 16       	cp	r14, r31
   14e38:	f0 e0       	ldi	r31, 0x00	; 0
   14e3a:	ff 06       	cpc	r15, r31
   14e3c:	49 f6       	brne	.-110    	; 0x14dd0 <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 _uart_printf(1,1,PSTR(">"));
   14e3e:	81 e0       	ldi	r24, 0x01	; 1
   14e40:	61 e0       	ldi	r22, 0x01	; 1
   14e42:	4e ea       	ldi	r20, 0xAE	; 174
   14e44:	51 e2       	ldi	r21, 0x21	; 33
   14e46:	0e 94 74 b4 	call	0x168e8	; 0x168e8 <_uart_printf>
	 //End
}
   14e4a:	cb 59       	subi	r28, 0x9B	; 155
   14e4c:	df 4f       	sbci	r29, 0xFF	; 255
   14e4e:	0f b6       	in	r0, 0x3f	; 63
   14e50:	f8 94       	cli
   14e52:	de bf       	out	0x3e, r29	; 62
   14e54:	0f be       	out	0x3f, r0	; 63
   14e56:	cd bf       	out	0x3d, r28	; 61
   14e58:	cf 91       	pop	r28
   14e5a:	df 91       	pop	r29
   14e5c:	1f 91       	pop	r17
   14e5e:	0f 91       	pop	r16
   14e60:	ff 90       	pop	r15
   14e62:	ef 90       	pop	r14
   14e64:	df 90       	pop	r13
   14e66:	cf 90       	pop	r12
   14e68:	bf 90       	pop	r11
   14e6a:	af 90       	pop	r10
   14e6c:	9f 90       	pop	r9
   14e6e:	8f 90       	pop	r8
   14e70:	08 95       	ret

00014e72 <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   14e72:	8f 92       	push	r8
   14e74:	9f 92       	push	r9
   14e76:	af 92       	push	r10
   14e78:	bf 92       	push	r11
   14e7a:	cf 92       	push	r12
   14e7c:	df 92       	push	r13
   14e7e:	ef 92       	push	r14
   14e80:	ff 92       	push	r15
   14e82:	0f 93       	push	r16
   14e84:	1f 93       	push	r17
   14e86:	df 93       	push	r29
   14e88:	cf 93       	push	r28
   14e8a:	cd b7       	in	r28, 0x3d	; 61
   14e8c:	de b7       	in	r29, 0x3e	; 62
   14e8e:	c6 54       	subi	r28, 0x46	; 70
   14e90:	d0 40       	sbci	r29, 0x00	; 0
   14e92:	0f b6       	in	r0, 0x3f	; 63
   14e94:	f8 94       	cli
   14e96:	de bf       	out	0x3e, r29	; 62
   14e98:	0f be       	out	0x3f, r0	; 63
   14e9a:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
   14e9c:	00 d0       	rcall	.+0      	; 0x14e9e <SaveConfigParameter+0x2c>
   14e9e:	00 d0       	rcall	.+0      	; 0x14ea0 <SaveConfigParameter+0x2e>
   14ea0:	00 d0       	rcall	.+0      	; 0x14ea2 <SaveConfigParameter+0x30>
   14ea2:	ed b7       	in	r30, 0x3d	; 61
   14ea4:	fe b7       	in	r31, 0x3e	; 62
   14ea6:	31 96       	adiw	r30, 0x01	; 1
   14ea8:	8e 01       	movw	r16, r28
   14eaa:	0f 5f       	subi	r16, 0xFF	; 255
   14eac:	1f 4f       	sbci	r17, 0xFF	; 255
   14eae:	ad b7       	in	r26, 0x3d	; 61
   14eb0:	be b7       	in	r27, 0x3e	; 62
   14eb2:	12 96       	adiw	r26, 0x02	; 2
   14eb4:	1c 93       	st	X, r17
   14eb6:	0e 93       	st	-X, r16
   14eb8:	11 97       	sbiw	r26, 0x01	; 1
   14eba:	88 ee       	ldi	r24, 0xE8	; 232
   14ebc:	91 e2       	ldi	r25, 0x21	; 33
   14ebe:	93 83       	std	Z+3, r25	; 0x03
   14ec0:	82 83       	std	Z+2, r24	; 0x02
   14ec2:	80 91 b3 01 	lds	r24, 0x01B3
   14ec6:	90 91 b4 01 	lds	r25, 0x01B4
   14eca:	95 83       	std	Z+5, r25	; 0x05
   14ecc:	84 83       	std	Z+4, r24	; 0x04
   14ece:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	 _uart_print(1,1,strSend);
   14ed2:	ed b7       	in	r30, 0x3d	; 61
   14ed4:	fe b7       	in	r31, 0x3e	; 62
   14ed6:	36 96       	adiw	r30, 0x06	; 6
   14ed8:	0f b6       	in	r0, 0x3f	; 63
   14eda:	f8 94       	cli
   14edc:	fe bf       	out	0x3e, r31	; 62
   14ede:	0f be       	out	0x3f, r0	; 63
   14ee0:	ed bf       	out	0x3d, r30	; 61
   14ee2:	81 e0       	ldi	r24, 0x01	; 1
   14ee4:	61 e0       	ldi	r22, 0x01	; 1
   14ee6:	a8 01       	movw	r20, r16
   14ee8:	0e 94 4c b4 	call	0x16898	; 0x16898 <_uart_print>

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   14eec:	81 e0       	ldi	r24, 0x01	; 1
   14eee:	61 e0       	ldi	r22, 0x01	; 1
   14ef0:	4f ed       	ldi	r20, 0xDF	; 223
   14ef2:	51 e2       	ldi	r21, 0x21	; 33
   14ef4:	0e 94 74 b4 	call	0x168e8	; 0x168e8 <_uart_printf>
   14ef8:	07 e5       	ldi	r16, 0x57	; 87
   14efa:	12 e0       	ldi	r17, 0x02	; 2
   14efc:	a0 e2       	ldi	r26, 0x20	; 32
   14efe:	ea 2e       	mov	r14, r26
   14f00:	ab e0       	ldi	r26, 0x0B	; 11
   14f02:	fa 2e       	mov	r15, r26
   14f04:	f5 e1       	ldi	r31, 0x15	; 21
   14f06:	af 2e       	mov	r10, r31
   14f08:	b1 2c       	mov	r11, r1
   14f0a:	ac 0e       	add	r10, r28
   14f0c:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14f0e:	ed e3       	ldi	r30, 0x3D	; 61
   14f10:	ce 2e       	mov	r12, r30
   14f12:	d1 2c       	mov	r13, r1
   14f14:	cc 0e       	add	r12, r28
   14f16:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   14f18:	d7 01       	movw	r26, r14
   14f1a:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14f1c:	8d 91       	ld	r24, X+
   14f1e:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14f20:	ec 15       	cp	r30, r12
   14f22:	fd 05       	cpc	r31, r13
   14f24:	d9 f7       	brne	.-10     	; 0x14f1c <SaveConfigParameter+0xaa>
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   14f26:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   14f28:	c8 01       	movw	r24, r16
   14f2a:	b5 01       	movw	r22, r10
   14f2c:	49 e2       	ldi	r20, 0x29	; 41
   14f2e:	50 e0       	ldi	r21, 0x00	; 0
   14f30:	2f e9       	ldi	r18, 0x9F	; 159
   14f32:	32 e1       	ldi	r19, 0x12	; 18
   14f34:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
   14f38:	07 5d       	subi	r16, 0xD7	; 215
   14f3a:	1f 4f       	sbci	r17, 0xFF	; 255
   14f3c:	88 e2       	ldi	r24, 0x28	; 40
   14f3e:	90 e0       	ldi	r25, 0x00	; 0
   14f40:	e8 0e       	add	r14, r24
   14f42:	f9 1e       	adc	r15, r25
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   14f44:	93 e0       	ldi	r25, 0x03	; 3
   14f46:	01 3f       	cpi	r16, 0xF1	; 241
   14f48:	19 07       	cpc	r17, r25
   14f4a:	31 f7       	brne	.-52     	; 0x14f18 <SaveConfigParameter+0xa6>
   14f4c:	0b ee       	ldi	r16, 0xEB	; 235
   14f4e:	10 e0       	ldi	r17, 0x00	; 0
   14f50:	70 eb       	ldi	r23, 0xB0	; 176
   14f52:	e7 2e       	mov	r14, r23
   14f54:	7c e0       	ldi	r23, 0x0C	; 12
   14f56:	f7 2e       	mov	r15, r23
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14f58:	65 e1       	ldi	r22, 0x15	; 21
   14f5a:	c6 2e       	mov	r12, r22
   14f5c:	d1 2c       	mov	r13, r1
   14f5e:	cc 0e       	add	r12, r28
   14f60:	dd 1e       	adc	r13, r29
   14f62:	51 e2       	ldi	r21, 0x21	; 33
   14f64:	85 2e       	mov	r8, r21
   14f66:	91 2c       	mov	r9, r1
   14f68:	8c 0e       	add	r8, r28
   14f6a:	9d 1e       	adc	r9, r29
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   14f6c:	d7 01       	movw	r26, r14
   14f6e:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14f70:	8d 91       	ld	r24, X+
   14f72:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14f74:	e8 15       	cp	r30, r8
   14f76:	f9 05       	cpc	r31, r9
   14f78:	d9 f7       	brne	.-10     	; 0x14f70 <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   14f7a:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   14f7c:	c6 01       	movw	r24, r12
   14f7e:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   14f82:	f6 01       	movw	r30, r12
   14f84:	01 90       	ld	r0, Z+
   14f86:	00 20       	and	r0, r0
   14f88:	e9 f7       	brne	.-6      	; 0x14f84 <SaveConfigParameter+0x112>
   14f8a:	31 97       	sbiw	r30, 0x01	; 1
   14f8c:	10 82       	st	Z, r1
   14f8e:	c8 01       	movw	r24, r16
   14f90:	b6 01       	movw	r22, r12
   14f92:	4d e0       	ldi	r20, 0x0D	; 13
   14f94:	50 e0       	ldi	r21, 0x00	; 0
   14f96:	2f e9       	ldi	r18, 0x9F	; 159
   14f98:	32 e1       	ldi	r19, 0x12	; 18
   14f9a:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
   14f9e:	03 5f       	subi	r16, 0xF3	; 243
   14fa0:	1f 4f       	sbci	r17, 0xFF	; 255
   14fa2:	ac e0       	ldi	r26, 0x0C	; 12
   14fa4:	b0 e0       	ldi	r27, 0x00	; 0
   14fa6:	ea 0e       	add	r14, r26
   14fa8:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   14faa:	b1 e0       	ldi	r27, 0x01	; 1
   14fac:	09 33       	cpi	r16, 0x39	; 57
   14fae:	1b 07       	cpc	r17, r27
   14fb0:	e9 f6       	brne	.-70     	; 0x14f6c <SaveConfigParameter+0xfa>
   14fb2:	05 eb       	ldi	r16, 0xB5	; 181
   14fb4:	10 e0       	ldi	r17, 0x00	; 0
   14fb6:	48 ef       	ldi	r20, 0xF8	; 248
   14fb8:	e4 2e       	mov	r14, r20
   14fba:	4c e0       	ldi	r20, 0x0C	; 12
   14fbc:	f4 2e       	mov	r15, r20
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14fbe:	35 e1       	ldi	r19, 0x15	; 21
   14fc0:	c3 2e       	mov	r12, r19
   14fc2:	d1 2c       	mov	r13, r1
   14fc4:	cc 0e       	add	r12, r28
   14fc6:	dd 1e       	adc	r13, r29
   14fc8:	2a e1       	ldi	r18, 0x1A	; 26
   14fca:	82 2e       	mov	r8, r18
   14fcc:	91 2c       	mov	r9, r1
   14fce:	8c 0e       	add	r8, r28
   14fd0:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   14fd2:	d7 01       	movw	r26, r14
   14fd4:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14fd6:	8d 91       	ld	r24, X+
   14fd8:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14fda:	e8 15       	cp	r30, r8
   14fdc:	f9 05       	cpc	r31, r9
   14fde:	d9 f7       	brne	.-10     	; 0x14fd6 <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   14fe0:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   14fe2:	c6 01       	movw	r24, r12
   14fe4:	0e 94 2b 24 	call	0x4856	; 0x4856 <RemSpaceLag>
   14fe8:	c8 01       	movw	r24, r16
   14fea:	b6 01       	movw	r22, r12
   14fec:	49 e0       	ldi	r20, 0x09	; 9
   14fee:	50 e0       	ldi	r21, 0x00	; 0
   14ff0:	2f e9       	ldi	r18, 0x9F	; 159
   14ff2:	32 e1       	ldi	r19, 0x12	; 18
   14ff4:	0e 94 f0 b5 	call	0x16be0	; 0x16be0 <__eewr_block>
   14ff8:	07 5f       	subi	r16, 0xF7	; 247
   14ffa:	1f 4f       	sbci	r17, 0xFF	; 255
   14ffc:	e5 e0       	ldi	r30, 0x05	; 5
   14ffe:	f0 e0       	ldi	r31, 0x00	; 0
   15000:	ee 0e       	add	r14, r30
   15002:	ff 1e       	adc	r15, r31
		// _uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   15004:	f0 e0       	ldi	r31, 0x00	; 0
   15006:	0b 3e       	cpi	r16, 0xEB	; 235
   15008:	1f 07       	cpc	r17, r31
   1500a:	19 f7       	brne	.-58     	; 0x14fd2 <SaveConfigParameter+0x160>
   1500c:	06 e1       	ldi	r16, 0x16	; 22
   1500e:	1d e0       	ldi	r17, 0x0D	; 13
   15010:	95 e4       	ldi	r25, 0x45	; 69
   15012:	e9 2e       	mov	r14, r25
   15014:	90 e0       	ldi	r25, 0x00	; 0
   15016:	f9 2e       	mov	r15, r25
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15018:	85 e1       	ldi	r24, 0x15	; 21
   1501a:	c8 2e       	mov	r12, r24
   1501c:	d1 2c       	mov	r13, r1
   1501e:	cc 0e       	add	r12, r28
   15020:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15022:	4e 01       	movw	r8, r28
   15024:	08 94       	sec
   15026:	81 1c       	adc	r8, r1
   15028:	91 1c       	adc	r9, r1
   1502a:	bc ed       	ldi	r27, 0xDC	; 220
   1502c:	ab 2e       	mov	r10, r27
   1502e:	b1 e2       	ldi	r27, 0x21	; 33
   15030:	bb 2e       	mov	r11, r27
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15032:	d8 01       	movw	r26, r16
   15034:	8c 91       	ld	r24, X
   15036:	8d 8b       	std	Y+21, r24	; 0x15
   15038:	11 96       	adiw	r26, 0x01	; 1
   1503a:	8c 91       	ld	r24, X
   1503c:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1503e:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15040:	c6 01       	movw	r24, r12
   15042:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15046:	c6 01       	movw	r24, r12
   15048:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1504c:	e1 99       	sbic	0x1c, 1	; 28
   1504e:	fe cf       	rjmp	.-4      	; 0x1504c <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15050:	ff ba       	out	0x1f, r15	; 31
   15052:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   15054:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   15056:	0f b6       	in	r0, 0x3f	; 63
   15058:	f8 94       	cli
   1505a:	e2 9a       	sbi	0x1c, 2	; 28
   1505c:	e1 9a       	sbi	0x1c, 1	; 28
   1505e:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15060:	00 d0       	rcall	.+0      	; 0x15062 <SaveConfigParameter+0x1f0>
   15062:	00 d0       	rcall	.+0      	; 0x15064 <SaveConfigParameter+0x1f2>
   15064:	00 d0       	rcall	.+0      	; 0x15066 <SaveConfigParameter+0x1f4>
   15066:	ed b7       	in	r30, 0x3d	; 61
   15068:	fe b7       	in	r31, 0x3e	; 62
   1506a:	31 96       	adiw	r30, 0x01	; 1
   1506c:	ad b7       	in	r26, 0x3d	; 61
   1506e:	be b7       	in	r27, 0x3e	; 62
   15070:	12 96       	adiw	r26, 0x02	; 2
   15072:	9c 92       	st	X, r9
   15074:	8e 92       	st	-X, r8
   15076:	11 97       	sbiw	r26, 0x01	; 1
   15078:	b3 82       	std	Z+3, r11	; 0x03
   1507a:	a2 82       	std	Z+2, r10	; 0x02
   1507c:	84 83       	std	Z+4, r24	; 0x04
   1507e:	15 82       	std	Z+5, r1	; 0x05
   15080:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   15084:	0e 5f       	subi	r16, 0xFE	; 254
   15086:	1f 4f       	sbci	r17, 0xFF	; 255
   15088:	08 94       	sec
   1508a:	e1 1c       	adc	r14, r1
   1508c:	f1 1c       	adc	r15, r1
		// _uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   1508e:	ed b7       	in	r30, 0x3d	; 61
   15090:	fe b7       	in	r31, 0x3e	; 62
   15092:	36 96       	adiw	r30, 0x06	; 6
   15094:	0f b6       	in	r0, 0x3f	; 63
   15096:	f8 94       	cli
   15098:	fe bf       	out	0x3e, r31	; 62
   1509a:	0f be       	out	0x3f, r0	; 63
   1509c:	ed bf       	out	0x3d, r30	; 61
   1509e:	fd e0       	ldi	r31, 0x0D	; 13
   150a0:	06 32       	cpi	r16, 0x26	; 38
   150a2:	1f 07       	cpc	r17, r31
   150a4:	09 f0       	breq	.+2      	; 0x150a8 <SaveConfigParameter+0x236>
   150a6:	c5 cf       	rjmp	.-118    	; 0x15032 <SaveConfigParameter+0x1c0>
   150a8:	45 e5       	ldi	r20, 0x55	; 85
   150aa:	50 e0       	ldi	r21, 0x00	; 0
   150ac:	b8 01       	movw	r22, r16
   150ae:	1d c0       	rjmp	.+58     	; 0x150ea <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   150b0:	90 81       	ld	r25, Z
   150b2:	90 53       	subi	r25, 0x30	; 48
   150b4:	9a 30       	cpi	r25, 0x0A	; 10
   150b6:	08 f0       	brcs	.+2      	; 0x150ba <SaveConfigParameter+0x248>
   150b8:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   150ba:	e1 99       	sbic	0x1c, 1	; 28
   150bc:	fe cf       	rjmp	.-4      	; 0x150ba <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   150be:	3f bb       	out	0x1f, r19	; 31
   150c0:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   150c2:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   150c4:	0f b6       	in	r0, 0x3f	; 63
   150c6:	f8 94       	cli
   150c8:	e2 9a       	sbi	0x1c, 2	; 28
   150ca:	e1 9a       	sbi	0x1c, 1	; 28
   150cc:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   150ce:	8f 5f       	subi	r24, 0xFF	; 255
   150d0:	31 96       	adiw	r30, 0x01	; 1
   150d2:	2f 5f       	subi	r18, 0xFF	; 255
   150d4:	3f 4f       	sbci	r19, 0xFF	; 255
   150d6:	86 30       	cpi	r24, 0x06	; 6
   150d8:	59 f7       	brne	.-42     	; 0x150b0 <SaveConfigParameter+0x23e>
   150da:	4a 5f       	subi	r20, 0xFA	; 250
   150dc:	5f 4f       	sbci	r21, 0xFF	; 255
   150de:	6a 5f       	subi	r22, 0xFA	; 250
   150e0:	7f 4f       	sbci	r23, 0xFF	; 255
		// _uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   150e2:	80 e0       	ldi	r24, 0x00	; 0
   150e4:	45 38       	cpi	r20, 0x85	; 133
   150e6:	58 07       	cpc	r21, r24
   150e8:	21 f0       	breq	.+8      	; 0x150f2 <SaveConfigParameter+0x280>
   150ea:	fb 01       	movw	r30, r22
   150ec:	9a 01       	movw	r18, r20
   150ee:	80 e0       	ldi	r24, 0x00	; 0
   150f0:	df cf       	rjmp	.-66     	; 0x150b0 <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   150f2:	80 91 56 0d 	lds	r24, 0x0D56
   150f6:	80 53       	subi	r24, 0x30	; 48
   150f8:	8a 30       	cpi	r24, 0x0A	; 10
   150fa:	10 f0       	brcs	.+4      	; 0x15100 <SaveConfigParameter+0x28e>
   150fc:	20 e0       	ldi	r18, 0x00	; 0
   150fe:	03 c0       	rjmp	.+6      	; 0x15106 <SaveConfigParameter+0x294>
   15100:	81 11       	cpse	r24, r1
   15102:	81 e0       	ldi	r24, 0x01	; 1
   15104:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15106:	e1 99       	sbic	0x1c, 1	; 28
   15108:	fe cf       	rjmp	.-4      	; 0x15106 <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1510a:	81 ef       	ldi	r24, 0xF1	; 241
   1510c:	93 e0       	ldi	r25, 0x03	; 3
   1510e:	9f bb       	out	0x1f, r25	; 31
   15110:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   15112:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   15114:	0f b6       	in	r0, 0x3f	; 63
   15116:	f8 94       	cli
   15118:	e2 9a       	sbi	0x1c, 2	; 28
   1511a:	e1 9a       	sbi	0x1c, 1	; 28
   1511c:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1511e:	80 91 57 0d 	lds	r24, 0x0D57
   15122:	8d 8b       	std	Y+21, r24	; 0x15
   15124:	80 91 58 0d 	lds	r24, 0x0D58
   15128:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1512a:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   1512c:	8e 01       	movw	r16, r28
   1512e:	0b 5e       	subi	r16, 0xEB	; 235
   15130:	1f 4f       	sbci	r17, 0xFF	; 255
   15132:	c8 01       	movw	r24, r16
   15134:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   15138:	c8 01       	movw	r24, r16
   1513a:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
   1513e:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15140:	e1 99       	sbic	0x1c, 1	; 28
   15142:	fe cf       	rjmp	.-4      	; 0x15140 <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15144:	80 e0       	ldi	r24, 0x00	; 0
   15146:	90 e0       	ldi	r25, 0x00	; 0
   15148:	9f bb       	out	0x1f, r25	; 31
   1514a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   1514c:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   1514e:	0f b6       	in	r0, 0x3f	; 63
   15150:	f8 94       	cli
   15152:	e2 9a       	sbi	0x1c, 2	; 28
   15154:	e1 9a       	sbi	0x1c, 1	; 28
   15156:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15158:	00 d0       	rcall	.+0      	; 0x1515a <SaveConfigParameter+0x2e8>
   1515a:	00 d0       	rcall	.+0      	; 0x1515c <SaveConfigParameter+0x2ea>
   1515c:	00 d0       	rcall	.+0      	; 0x1515e <SaveConfigParameter+0x2ec>
   1515e:	ed b7       	in	r30, 0x3d	; 61
   15160:	fe b7       	in	r31, 0x3e	; 62
   15162:	31 96       	adiw	r30, 0x01	; 1
   15164:	8e 01       	movw	r16, r28
   15166:	0f 5f       	subi	r16, 0xFF	; 255
   15168:	1f 4f       	sbci	r17, 0xFF	; 255
   1516a:	ad b7       	in	r26, 0x3d	; 61
   1516c:	be b7       	in	r27, 0x3e	; 62
   1516e:	12 96       	adiw	r26, 0x02	; 2
   15170:	1c 93       	st	X, r17
   15172:	0e 93       	st	-X, r16
   15174:	11 97       	sbiw	r26, 0x01	; 1
   15176:	89 ed       	ldi	r24, 0xD9	; 217
   15178:	91 e2       	ldi	r25, 0x21	; 33
   1517a:	93 83       	std	Z+3, r25	; 0x03
   1517c:	82 83       	std	Z+2, r24	; 0x02
   1517e:	24 83       	std	Z+4, r18	; 0x04
   15180:	15 82       	std	Z+5, r1	; 0x05
   15182:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   15186:	a9 e5       	ldi	r26, 0x59	; 89
   15188:	ea 2e       	mov	r14, r26
   1518a:	ad e0       	ldi	r26, 0x0D	; 13
   1518c:	fa 2e       	mov	r15, r26
   1518e:	fd e4       	ldi	r31, 0x4D	; 77
   15190:	cf 2e       	mov	r12, r31
   15192:	f0 e0       	ldi	r31, 0x00	; 0
   15194:	df 2e       	mov	r13, r31
   15196:	ed b7       	in	r30, 0x3d	; 61
   15198:	fe b7       	in	r31, 0x3e	; 62
   1519a:	36 96       	adiw	r30, 0x06	; 6
   1519c:	0f b6       	in	r0, 0x3f	; 63
   1519e:	f8 94       	cli
   151a0:	fe bf       	out	0x3e, r31	; 62
   151a2:	0f be       	out	0x3f, r0	; 63
   151a4:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   151a6:	e5 e1       	ldi	r30, 0x15	; 21
   151a8:	ae 2e       	mov	r10, r30
   151aa:	b1 2c       	mov	r11, r1
   151ac:	ac 0e       	add	r10, r28
   151ae:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151b0:	48 01       	movw	r8, r16
   151b2:	06 ed       	ldi	r16, 0xD6	; 214
   151b4:	11 e2       	ldi	r17, 0x21	; 33
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   151b6:	d7 01       	movw	r26, r14
   151b8:	8c 91       	ld	r24, X
   151ba:	8d 8b       	std	Y+21, r24	; 0x15
   151bc:	11 96       	adiw	r26, 0x01	; 1
   151be:	8c 91       	ld	r24, X
   151c0:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   151c2:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   151c4:	c5 01       	movw	r24, r10
   151c6:	0e 94 bd 22 	call	0x457a	; 0x457a <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   151ca:	c5 01       	movw	r24, r10
   151cc:	0e 94 9f b5 	call	0x16b3e	; 0x16b3e <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   151d0:	e1 99       	sbic	0x1c, 1	; 28
   151d2:	fe cf       	rjmp	.-4      	; 0x151d0 <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   151d4:	df ba       	out	0x1f, r13	; 31
   151d6:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   151d8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   151da:	0f b6       	in	r0, 0x3f	; 63
   151dc:	f8 94       	cli
   151de:	e2 9a       	sbi	0x1c, 2	; 28
   151e0:	e1 9a       	sbi	0x1c, 1	; 28
   151e2:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151e4:	00 d0       	rcall	.+0      	; 0x151e6 <SaveConfigParameter+0x374>
   151e6:	00 d0       	rcall	.+0      	; 0x151e8 <SaveConfigParameter+0x376>
   151e8:	00 d0       	rcall	.+0      	; 0x151ea <SaveConfigParameter+0x378>
   151ea:	ed b7       	in	r30, 0x3d	; 61
   151ec:	fe b7       	in	r31, 0x3e	; 62
   151ee:	31 96       	adiw	r30, 0x01	; 1
   151f0:	ad b7       	in	r26, 0x3d	; 61
   151f2:	be b7       	in	r27, 0x3e	; 62
   151f4:	11 96       	adiw	r26, 0x01	; 1
   151f6:	8c 92       	st	X, r8
   151f8:	11 97       	sbiw	r26, 0x01	; 1
   151fa:	12 96       	adiw	r26, 0x02	; 2
   151fc:	9c 92       	st	X, r9
   151fe:	13 83       	std	Z+3, r17	; 0x03
   15200:	02 83       	std	Z+2, r16	; 0x02
   15202:	84 83       	std	Z+4, r24	; 0x04
   15204:	15 82       	std	Z+5, r1	; 0x05
   15206:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
   1520a:	e2 e0       	ldi	r30, 0x02	; 2
   1520c:	f0 e0       	ldi	r31, 0x00	; 0
   1520e:	ee 0e       	add	r14, r30
   15210:	ff 1e       	adc	r15, r31
   15212:	08 94       	sec
   15214:	c1 1c       	adc	r12, r1
   15216:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 _uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   15218:	8d b7       	in	r24, 0x3d	; 61
   1521a:	9e b7       	in	r25, 0x3e	; 62
   1521c:	06 96       	adiw	r24, 0x06	; 6
   1521e:	0f b6       	in	r0, 0x3f	; 63
   15220:	f8 94       	cli
   15222:	9e bf       	out	0x3e, r25	; 62
   15224:	0f be       	out	0x3f, r0	; 63
   15226:	8d bf       	out	0x3d, r24	; 61
   15228:	99 e6       	ldi	r25, 0x69	; 105
   1522a:	e9 16       	cp	r14, r25
   1522c:	9d e0       	ldi	r25, 0x0D	; 13
   1522e:	f9 06       	cpc	r15, r25
   15230:	09 f0       	breq	.+2      	; 0x15234 <SaveConfigParameter+0x3c2>
   15232:	c1 cf       	rjmp	.-126    	; 0x151b6 <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 _uart_print(1,1,strSend); 
	 }    
	 _uart_printf(1,1,PSTR("<OK>")); 
   15234:	81 e0       	ldi	r24, 0x01	; 1
   15236:	61 e0       	ldi	r22, 0x01	; 1
   15238:	41 ed       	ldi	r20, 0xD1	; 209
   1523a:	51 e2       	ldi	r21, 0x21	; 33
   1523c:	0e 94 74 b4 	call	0x168e8	; 0x168e8 <_uart_printf>
}
   15240:	ca 5b       	subi	r28, 0xBA	; 186
   15242:	df 4f       	sbci	r29, 0xFF	; 255
   15244:	0f b6       	in	r0, 0x3f	; 63
   15246:	f8 94       	cli
   15248:	de bf       	out	0x3e, r29	; 62
   1524a:	0f be       	out	0x3f, r0	; 63
   1524c:	cd bf       	out	0x3d, r28	; 61
   1524e:	cf 91       	pop	r28
   15250:	df 91       	pop	r29
   15252:	1f 91       	pop	r17
   15254:	0f 91       	pop	r16
   15256:	ff 90       	pop	r15
   15258:	ef 90       	pop	r14
   1525a:	df 90       	pop	r13
   1525c:	cf 90       	pop	r12
   1525e:	bf 90       	pop	r11
   15260:	af 90       	pop	r10
   15262:	9f 90       	pop	r9
   15264:	8f 90       	pop	r8
   15266:	08 95       	ret

00015268 <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
   15268:	80 91 c7 03 	lds	r24, 0x03C7
   1526c:	81 30       	cpi	r24, 0x01	; 1
   1526e:	c1 f0       	breq	.+48     	; 0x152a0 <systemConfigProtocol+0x38>
   15270:	81 30       	cpi	r24, 0x01	; 1
   15272:	18 f0       	brcs	.+6      	; 0x1527a <systemConfigProtocol+0x12>
   15274:	82 30       	cpi	r24, 0x02	; 2
   15276:	e9 f4       	brne	.+58     	; 0x152b2 <systemConfigProtocol+0x4a>
   15278:	18 c0       	rjmp	.+48     	; 0x152aa <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
   1527a:	80 91 dc 01 	lds	r24, 0x01DC
   1527e:	81 30       	cpi	r24, 0x01	; 1
   15280:	31 f0       	breq	.+12     	; 0x1528e <systemConfigProtocol+0x26>
   15282:	82 30       	cpi	r24, 0x02	; 2
   15284:	51 f4       	brne	.+20     	; 0x1529a <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
   15286:	10 92 dc 01 	sts	0x01DC, r1
			   stConfigProtocol=cpSendingParameter;
   1528a:	81 e0       	ldi	r24, 0x01	; 1
   1528c:	03 c0       	rjmp	.+6      	; 0x15294 <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
   1528e:	10 92 dc 01 	sts	0x01DC, r1
			   stConfigProtocol=cpSavingParameter;
   15292:	82 e0       	ldi	r24, 0x02	; 2
   15294:	80 93 c7 03 	sts	0x03C7, r24
   15298:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
   1529a:	10 92 dc 01 	sts	0x01DC, r1
   1529e:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
   152a0:	0e 94 1f a5 	call	0x14a3e	; 0x14a3e <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
   152a4:	10 92 c7 03 	sts	0x03C7, r1
   152a8:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
   152aa:	0e 94 39 a7 	call	0x14e72	; 0x14e72 <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
   152ae:	10 92 c7 03 	sts	0x03C7, r1
   152b2:	08 95       	ret

000152b4 <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   152b4:	1f 93       	push	r17
	static char stMenuIdle=miInit,KeyPressed=0,KeyChar=0,ButtonID=0,PrintStandaloneResult=PS_NONE;
    static unsigned int iLoopIdle=0;
	char lcdteks[20];

	switch(stMenuIdle){
   152b6:	80 91 d6 03 	lds	r24, 0x03D6
   152ba:	e8 2f       	mov	r30, r24
   152bc:	f0 e0       	ldi	r31, 0x00	; 0
   152be:	e9 31       	cpi	r30, 0x19	; 25
   152c0:	f1 05       	cpc	r31, r1
   152c2:	08 f0       	brcs	.+2      	; 0x152c6 <FMenuIdle+0x12>
   152c4:	7e c1       	rjmp	.+764    	; 0x155c2 <FMenuIdle+0x30e>
   152c6:	ec 5e       	subi	r30, 0xEC	; 236
   152c8:	fe 4f       	sbci	r31, 0xFE	; 254
   152ca:	ee 0f       	add	r30, r30
   152cc:	ff 1f       	adc	r31, r31
   152ce:	05 90       	lpm	r0, Z+
   152d0:	f4 91       	lpm	r31, Z+
   152d2:	e0 2d       	mov	r30, r0
   152d4:	09 94       	ijmp
	case miInit:
         _scr_idle();
   152d6:	0e 94 b6 41 	call	0x836c	; 0x836c <_scr_idle>
   152da:	3a c1       	rjmp	.+628    	; 0x15550 <FMenuIdle+0x29c>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   152dc:	81 e0       	ldi	r24, 0x01	; 1
   152de:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   152e2:	80 93 d5 03 	sts	0x03D5, r24
		 KeyChar= _key_btn(KeyPressed);       
   152e6:	0e 94 c2 ad 	call	0x15b84	; 0x15b84 <_key_btn>
   152ea:	80 93 d4 03 	sts	0x03D4, r24

		 switch(KeyPressed){
   152ee:	80 91 d5 03 	lds	r24, 0x03D5
   152f2:	8b 3b       	cpi	r24, 0xBB	; 187
   152f4:	09 f4       	brne	.+2      	; 0x152f8 <FMenuIdle+0x44>
   152f6:	70 c0       	rjmp	.+224    	; 0x153d8 <FMenuIdle+0x124>
   152f8:	8c 3b       	cpi	r24, 0xBC	; 188
   152fa:	70 f4       	brcc	.+28     	; 0x15318 <FMenuIdle+0x64>
   152fc:	8b 37       	cpi	r24, 0x7B	; 123
   152fe:	61 f1       	breq	.+88     	; 0x15358 <FMenuIdle+0xa4>
   15300:	8c 37       	cpi	r24, 0x7C	; 124
   15302:	20 f4       	brcc	.+8      	; 0x1530c <FMenuIdle+0x58>
   15304:	87 37       	cpi	r24, 0x77	; 119
   15306:	09 f0       	breq	.+2      	; 0x1530a <FMenuIdle+0x56>
   15308:	5c c1       	rjmp	.+696    	; 0x155c2 <FMenuIdle+0x30e>
   1530a:	2c c0       	rjmp	.+88     	; 0x15364 <FMenuIdle+0xb0>
   1530c:	8d 37       	cpi	r24, 0x7D	; 125
   1530e:	e1 f0       	breq	.+56     	; 0x15348 <FMenuIdle+0x94>
   15310:	8e 37       	cpi	r24, 0x7E	; 126
   15312:	09 f0       	breq	.+2      	; 0x15316 <FMenuIdle+0x62>
   15314:	56 c1       	rjmp	.+684    	; 0x155c2 <FMenuIdle+0x30e>
   15316:	12 c0       	rjmp	.+36     	; 0x1533c <FMenuIdle+0x88>
   15318:	8d 3d       	cpi	r24, 0xDD	; 221
   1531a:	09 f4       	brne	.+2      	; 0x1531e <FMenuIdle+0x6a>
   1531c:	47 c0       	rjmp	.+142    	; 0x153ac <FMenuIdle+0xf8>
   1531e:	8e 3d       	cpi	r24, 0xDE	; 222
   15320:	38 f4       	brcc	.+14     	; 0x15330 <FMenuIdle+0x7c>
   15322:	8d 3b       	cpi	r24, 0xBD	; 189
   15324:	09 f4       	brne	.+2      	; 0x15328 <FMenuIdle+0x74>
   15326:	4d c0       	rjmp	.+154    	; 0x153c2 <FMenuIdle+0x10e>
   15328:	87 3d       	cpi	r24, 0xD7	; 215
   1532a:	09 f0       	breq	.+2      	; 0x1532e <FMenuIdle+0x7a>
   1532c:	4a c1       	rjmp	.+660    	; 0x155c2 <FMenuIdle+0x30e>
   1532e:	22 c0       	rjmp	.+68     	; 0x15374 <FMenuIdle+0xc0>
   15330:	8e 3d       	cpi	r24, 0xDE	; 222
   15332:	31 f1       	breq	.+76     	; 0x15380 <FMenuIdle+0xcc>
   15334:	8d 3e       	cpi	r24, 0xED	; 237
   15336:	09 f0       	breq	.+2      	; 0x1533a <FMenuIdle+0x86>
   15338:	44 c1       	rjmp	.+648    	; 0x155c2 <FMenuIdle+0x30e>
   1533a:	2d c0       	rjmp	.+90     	; 0x15396 <FMenuIdle+0xe2>
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   1533c:	82 e0       	ldi	r24, 0x02	; 2
   1533e:	90 e0       	ldi	r25, 0x00	; 0
   15340:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   15344:	81 e0       	ldi	r24, 0x01	; 1
   15346:	13 c0       	rjmp	.+38     	; 0x1536e <FMenuIdle+0xba>
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   15348:	82 e0       	ldi	r24, 0x02	; 2
   1534a:	90 e0       	ldi	r25, 0x00	; 0
   1534c:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   15350:	82 e0       	ldi	r24, 0x02	; 2
   15352:	80 93 d3 03 	sts	0x03D3, r24
   15356:	33 c1       	rjmp	.+614    	; 0x155be <FMenuIdle+0x30a>
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   15358:	82 e0       	ldi	r24, 0x02	; 2
   1535a:	90 e0       	ldi	r25, 0x00	; 0
   1535c:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   15360:	83 e0       	ldi	r24, 0x03	; 3
   15362:	05 c0       	rjmp	.+10     	; 0x1536e <FMenuIdle+0xba>
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   15364:	82 e0       	ldi	r24, 0x02	; 2
   15366:	90 e0       	ldi	r25, 0x00	; 0
   15368:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   1536c:	84 e0       	ldi	r24, 0x04	; 4
   1536e:	80 93 d3 03 	sts	0x03D3, r24
   15372:	4c c0       	rjmp	.+152    	; 0x1540c <FMenuIdle+0x158>
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   15374:	82 e0       	ldi	r24, 0x02	; 2
   15376:	90 e0       	ldi	r25, 0x00	; 0
   15378:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   1537c:	8c e0       	ldi	r24, 0x0C	; 12
   1537e:	1f c1       	rjmp	.+574    	; 0x155be <FMenuIdle+0x30a>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   15380:	80 91 25 01 	lds	r24, 0x0125
   15384:	81 30       	cpi	r24, 0x01	; 1
   15386:	09 f0       	breq	.+2      	; 0x1538a <FMenuIdle+0xd6>
   15388:	1c c1       	rjmp	.+568    	; 0x155c2 <FMenuIdle+0x30e>
   1538a:	82 e0       	ldi	r24, 0x02	; 2
   1538c:	90 e0       	ldi	r25, 0x00	; 0
   1538e:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   15392:	80 e1       	ldi	r24, 0x10	; 16
   15394:	14 c1       	rjmp	.+552    	; 0x155be <FMenuIdle+0x30a>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   15396:	80 91 25 01 	lds	r24, 0x0125
   1539a:	81 30       	cpi	r24, 0x01	; 1
   1539c:	09 f0       	breq	.+2      	; 0x153a0 <FMenuIdle+0xec>
   1539e:	11 c1       	rjmp	.+546    	; 0x155c2 <FMenuIdle+0x30e>
   153a0:	82 e0       	ldi	r24, 0x02	; 2
   153a2:	90 e0       	ldi	r25, 0x00	; 0
   153a4:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   153a8:	82 e1       	ldi	r24, 0x12	; 18
   153aa:	09 c1       	rjmp	.+530    	; 0x155be <FMenuIdle+0x30a>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   153ac:	80 91 25 01 	lds	r24, 0x0125
   153b0:	81 30       	cpi	r24, 0x01	; 1
   153b2:	09 f0       	breq	.+2      	; 0x153b6 <FMenuIdle+0x102>
   153b4:	06 c1       	rjmp	.+524    	; 0x155c2 <FMenuIdle+0x30e>
   153b6:	82 e0       	ldi	r24, 0x02	; 2
   153b8:	90 e0       	ldi	r25, 0x00	; 0
   153ba:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   153be:	81 e1       	ldi	r24, 0x11	; 17
   153c0:	fe c0       	rjmp	.+508    	; 0x155be <FMenuIdle+0x30a>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   153c2:	80 91 25 01 	lds	r24, 0x0125
   153c6:	81 30       	cpi	r24, 0x01	; 1
   153c8:	09 f0       	breq	.+2      	; 0x153cc <FMenuIdle+0x118>
   153ca:	fb c0       	rjmp	.+502    	; 0x155c2 <FMenuIdle+0x30e>
   153cc:	82 e0       	ldi	r24, 0x02	; 2
   153ce:	90 e0       	ldi	r25, 0x00	; 0
   153d0:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   153d4:	8f e0       	ldi	r24, 0x0F	; 15
   153d6:	f3 c0       	rjmp	.+486    	; 0x155be <FMenuIdle+0x30a>
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   153d8:	82 e0       	ldi	r24, 0x02	; 2
   153da:	90 e0       	ldi	r25, 0x00	; 0
   153dc:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
   153e0:	8d e0       	ldi	r24, 0x0D	; 13
   153e2:	ed c0       	rjmp	.+474    	; 0x155be <FMenuIdle+0x30a>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   153e4:	00 d0       	rcall	.+0      	; 0x153e6 <FMenuIdle+0x132>
   153e6:	00 d0       	rcall	.+0      	; 0x153e8 <FMenuIdle+0x134>
   153e8:	8c e8       	ldi	r24, 0x8C	; 140
   153ea:	9d e0       	ldi	r25, 0x0D	; 13
   153ec:	ed b7       	in	r30, 0x3d	; 61
   153ee:	fe b7       	in	r31, 0x3e	; 62
   153f0:	92 83       	std	Z+2, r25	; 0x02
   153f2:	81 83       	std	Z+1, r24	; 0x01
   153f4:	8a ef       	ldi	r24, 0xFA	; 250
   153f6:	92 e2       	ldi	r25, 0x22	; 34
   153f8:	94 83       	std	Z+4, r25	; 0x04
   153fa:	83 83       	std	Z+3, r24	; 0x03
   153fc:	0e 94 14 b6 	call	0x16c28	; 0x16c28 <sprintf_P>
	     sendMessage56();
   15400:	0f 90       	pop	r0
   15402:	0f 90       	pop	r0
   15404:	0f 90       	pop	r0
   15406:	0f 90       	pop	r0
   15408:	0e 94 34 9a 	call	0x13468	; 0x13468 <sendMessage56>
         stMenuIdle=miDisplayProses;
   1540c:	82 e0       	ldi	r24, 0x02	; 2
   1540e:	d7 c0       	rjmp	.+430    	; 0x155be <FMenuIdle+0x30a>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   15410:	80 91 e0 01 	lds	r24, 0x01E0
   15414:	88 23       	and	r24, r24
   15416:	09 f0       	breq	.+2      	; 0x1541a <FMenuIdle+0x166>
   15418:	9b c0       	rjmp	.+310    	; 0x15550 <FMenuIdle+0x29c>
		     lcd_printf(3,1,PSTR("SedangProses"));
   1541a:	83 e0       	ldi	r24, 0x03	; 3
   1541c:	61 e0       	ldi	r22, 0x01	; 1
   1541e:	4d ee       	ldi	r20, 0xED	; 237
   15420:	52 e2       	ldi	r21, 0x22	; 34
   15422:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	         TimDisplay=0;
   15426:	10 92 bc 01 	sts	0x01BC, r1
			 stMenuIdle=miWaitProses;
   1542a:	83 e0       	ldi	r24, 0x03	; 3
   1542c:	c8 c0       	rjmp	.+400    	; 0x155be <FMenuIdle+0x30a>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   1542e:	80 91 bc 01 	lds	r24, 0x01BC
   15432:	82 30       	cpi	r24, 0x02	; 2
   15434:	08 f4       	brcc	.+2      	; 0x15438 <FMenuIdle+0x184>
   15436:	c5 c0       	rjmp	.+394    	; 0x155c2 <FMenuIdle+0x30e>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   15438:	80 91 25 01 	lds	r24, 0x0125
   1543c:	81 30       	cpi	r24, 0x01	; 1
   1543e:	11 f4       	brne	.+4      	; 0x15444 <FMenuIdle+0x190>
   15440:	84 e0       	ldi	r24, 0x04	; 4
   15442:	bd c0       	rjmp	.+378    	; 0x155be <FMenuIdle+0x30a>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   15444:	82 30       	cpi	r24, 0x02	; 2
   15446:	09 f0       	breq	.+2      	; 0x1544a <FMenuIdle+0x196>
   15448:	bc c0       	rjmp	.+376    	; 0x155c2 <FMenuIdle+0x30e>
   1544a:	87 e0       	ldi	r24, 0x07	; 7
   1544c:	b8 c0       	rjmp	.+368    	; 0x155be <FMenuIdle+0x30a>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   1544e:	80 91 d3 03 	lds	r24, 0x03D3
   15452:	60 e0       	ldi	r22, 0x00	; 0
   15454:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <PrintStandalone>
   15458:	80 93 72 01 	sts	0x0172, r24
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   1545c:	81 31       	cpi	r24, 0x11	; 17
   1545e:	09 f4       	brne	.+2      	; 0x15462 <FMenuIdle+0x1ae>
   15460:	ad c0       	rjmp	.+346    	; 0x155bc <FMenuIdle+0x308>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   15462:	82 31       	cpi	r24, 0x12	; 18
   15464:	09 f0       	breq	.+2      	; 0x15468 <FMenuIdle+0x1b4>
   15466:	ad c0       	rjmp	.+346    	; 0x155c2 <FMenuIdle+0x30e>
   15468:	88 e0       	ldi	r24, 0x08	; 8
   1546a:	a9 c0       	rjmp	.+338    	; 0x155be <FMenuIdle+0x30a>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   1546c:	83 e0       	ldi	r24, 0x03	; 3
   1546e:	61 e0       	ldi	r22, 0x01	; 1
   15470:	48 ed       	ldi	r20, 0xD8	; 216
   15472:	52 e2       	ldi	r21, 0x22	; 34
   15474:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
         TimDisplay=0;
   15478:	10 92 bc 01 	sts	0x01BC, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   1547c:	89 e0       	ldi	r24, 0x09	; 9
   1547e:	9f c0       	rjmp	.+318    	; 0x155be <FMenuIdle+0x30a>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   15480:	80 91 bc 01 	lds	r24, 0x01BC
   15484:	82 30       	cpi	r24, 0x02	; 2
   15486:	08 f4       	brcc	.+2      	; 0x1548a <FMenuIdle+0x1d6>
   15488:	9c c0       	rjmp	.+312    	; 0x155c2 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   1548a:	83 e0       	ldi	r24, 0x03	; 3
   1548c:	61 e0       	ldi	r22, 0x01	; 1
   1548e:	43 ec       	ldi	r20, 0xC3	; 195
   15490:	52 e2       	ldi	r21, 0x22	; 34
   15492:	36 c0       	rjmp	.+108    	; 0x15500 <FMenuIdle+0x24c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   15494:	83 e0       	ldi	r24, 0x03	; 3
   15496:	61 e0       	ldi	r22, 0x01	; 1
   15498:	4e ea       	ldi	r20, 0xAE	; 174
   1549a:	52 e2       	ldi	r21, 0x22	; 34
   1549c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	     sendMessage98(ButtonID);
   154a0:	80 91 d3 03 	lds	r24, 0x03D3
   154a4:	0e 94 83 4c 	call	0x9906	; 0x9906 <sendMessage98>
		 ProcTimeOut=0;
   154a8:	10 92 f3 01 	sts	0x01F3, r1
   154ac:	10 92 f2 01 	sts	0x01F2, r1
		 stMenuIdle=miWaitPlease;
   154b0:	85 e0       	ldi	r24, 0x05	; 5
   154b2:	85 c0       	rjmp	.+266    	; 0x155be <FMenuIdle+0x30a>
	     break;
    case miWaitPlease:
         if (ProcTimeOut>TIM_NO_RESPONSE){
   154b4:	80 91 f2 01 	lds	r24, 0x01F2
   154b8:	90 91 f3 01 	lds	r25, 0x01F3
   154bc:	0f 97       	sbiw	r24, 0x0f	; 15
   154be:	58 f0       	brcs	.+22     	; 0x154d6 <FMenuIdle+0x222>
	         lcd_printf(3,1,PSTR("No Response..       "));
   154c0:	83 e0       	ldi	r24, 0x03	; 3
   154c2:	61 e0       	ldi	r22, 0x01	; 1
   154c4:	49 e9       	ldi	r20, 0x99	; 153
   154c6:	52 e2       	ldi	r21, 0x22	; 34
   154c8:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		     stMenuIdle=miNoResponse;
   154cc:	86 e0       	ldi	r24, 0x06	; 6
   154ce:	80 93 d6 03 	sts	0x03D6, r24
			 TimDisplay=0;		 
   154d2:	10 92 bc 01 	sts	0x01BC, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   154d6:	80 91 cc 01 	lds	r24, 0x01CC
   154da:	81 30       	cpi	r24, 0x01	; 1
   154dc:	29 f0       	breq	.+10     	; 0x154e8 <FMenuIdle+0x234>
   154de:	80 91 cb 01 	lds	r24, 0x01CB
   154e2:	81 30       	cpi	r24, 0x01	; 1
   154e4:	09 f0       	breq	.+2      	; 0x154e8 <FMenuIdle+0x234>
   154e6:	6d c0       	rjmp	.+218    	; 0x155c2 <FMenuIdle+0x30e>
		     ClearMem(strOdometer);
   154e8:	88 ec       	ldi	r24, 0xC8	; 200
   154ea:	95 e0       	ldi	r25, 0x05	; 5
   154ec:	0e 94 5c ad 	call	0x15ab8	; 0x15ab8 <ClearMem>
		     ClearMem(strLicPlate);
   154f0:	8d ef       	ldi	r24, 0xFD	; 253
   154f2:	9a e0       	ldi	r25, 0x0A	; 10
   154f4:	0e 94 5c ad 	call	0x15ab8	; 0x15ab8 <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   154f8:	83 e0       	ldi	r24, 0x03	; 3
   154fa:	61 e0       	ldi	r22, 0x01	; 1
   154fc:	44 e8       	ldi	r20, 0x84	; 132
   154fe:	52 e2       	ldi	r21, 0x22	; 34
   15500:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		     stMenuIdle=miWaitReady;
   15504:	8a e0       	ldi	r24, 0x0A	; 10
   15506:	80 93 d6 03 	sts	0x03D6, r24
			 TimDisplay=0;
   1550a:	10 92 bc 01 	sts	0x01BC, r1
   1550e:	59 c0       	rjmp	.+178    	; 0x155c2 <FMenuIdle+0x30e>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   15510:	80 91 bc 01 	lds	r24, 0x01BC
   15514:	82 30       	cpi	r24, 0x02	; 2
   15516:	08 f4       	brcc	.+2      	; 0x1551a <FMenuIdle+0x266>
   15518:	54 c0       	rjmp	.+168    	; 0x155c2 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   1551a:	83 e0       	ldi	r24, 0x03	; 3
   1551c:	61 e0       	ldi	r22, 0x01	; 1
   1551e:	4f e6       	ldi	r20, 0x6F	; 111
   15520:	52 e2       	ldi	r21, 0x22	; 34
   15522:	ee cf       	rjmp	.-36     	; 0x15500 <FMenuIdle+0x24c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   15524:	80 91 bc 01 	lds	r24, 0x01BC
   15528:	82 30       	cpi	r24, 0x02	; 2
   1552a:	08 f4       	brcc	.+2      	; 0x1552e <FMenuIdle+0x27a>
   1552c:	4a c0       	rjmp	.+148    	; 0x155c2 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("                "));
   1552e:	83 e0       	ldi	r24, 0x03	; 3
   15530:	61 e0       	ldi	r22, 0x01	; 1
   15532:	4e e5       	ldi	r20, 0x5E	; 94
   15534:	52 e2       	ldi	r21, 0x22	; 34
   15536:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		     stMenuIdle=miReady;
   1553a:	8b e0       	ldi	r24, 0x0B	; 11
   1553c:	e4 cf       	rjmp	.-56     	; 0x15506 <FMenuIdle+0x252>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     _scr_idle();
   1553e:	0e 94 b6 41 	call	0x836c	; 0x836c <_scr_idle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   15542:	80 91 25 01 	lds	r24, 0x0125
   15546:	82 30       	cpi	r24, 0x02	; 2
   15548:	19 f4       	brne	.+6      	; 0x15550 <FMenuIdle+0x29c>
   1554a:	81 e0       	ldi	r24, 0x01	; 1
   1554c:	80 93 26 01 	sts	0x0126, r24
		 stMenuIdle=miScan;
   15550:	81 e0       	ldi	r24, 0x01	; 1
   15552:	35 c0       	rjmp	.+106    	; 0x155be <FMenuIdle+0x30a>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   15554:	0e 94 8d 86 	call	0x10d1a	; 0x10d1a <FMenuTicket>
   15558:	2f c0       	rjmp	.+94     	; 0x155b8 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   1555a:	0e 94 45 99 	call	0x1328a	; 0x1328a <FMenuAuthorization>
   1555e:	2c c0       	rjmp	.+88     	; 0x155b8 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   15560:	0e 94 de 9a 	call	0x135bc	; 0x135bc <FMenuLocalAccount>
   15564:	29 c0       	rjmp	.+82     	; 0x155b8 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   15566:	0e 94 62 92 	call	0x124c4	; 0x124c4 <FMenuChangeMOP>
   1556a:	26 c0       	rjmp	.+76     	; 0x155b8 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   1556c:	0e 94 c5 66 	call	0xcd8a	; 0xcd8a <FMenuEDCTransaction>
   15570:	23 c0       	rjmp	.+70     	; 0x155b8 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   15572:	0e 94 b9 67 	call	0xcf72	; 0xcf72 <FMenuLoyalty>
   15576:	20 c0       	rjmp	.+64     	; 0x155b8 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   15578:	0e 94 b7 90 	call	0x1216e	; 0x1216e <FMenuReprint>
   1557c:	1d c0       	rjmp	.+58     	; 0x155b8 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   1557e:	0e 94 7c 41 	call	0x82f8	; 0x82f8 <FViewFreeMessage>
   15582:	1a c0       	rjmp	.+52     	; 0x155b8 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   15584:	83 e0       	ldi	r24, 0x03	; 3
   15586:	61 e0       	ldi	r22, 0x01	; 1
   15588:	49 e4       	ldi	r20, 0x49	; 73
   1558a:	52 e2       	ldi	r21, 0x22	; 34
   1558c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   15590:	80 e0       	ldi	r24, 0x00	; 0
   15592:	0e 94 cc 45 	call	0x8b98	; 0x8b98 <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   15596:	81 e0       	ldi	r24, 0x01	; 1
   15598:	0e 94 cc 45 	call	0x8b98	; 0x8b98 <ResetTotalizer>
   1559c:	0f c0       	rjmp	.+30     	; 0x155bc <FMenuIdle+0x308>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   1559e:	83 e0       	ldi	r24, 0x03	; 3
   155a0:	61 e0       	ldi	r22, 0x01	; 1
   155a2:	47 e3       	ldi	r20, 0x37	; 55
   155a4:	52 e2       	ldi	r21, 0x22	; 34
   155a6:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   155aa:	85 e0       	ldi	r24, 0x05	; 5
   155ac:	62 e1       	ldi	r22, 0x12	; 18
   155ae:	0e 94 9f 74 	call	0xe93e	; 0xe93e <SendSlaveCommand>
   155b2:	04 c0       	rjmp	.+8      	; 0x155bc <FMenuIdle+0x308>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   155b4:	0e 94 bf 40 	call	0x817e	; 0x817e <FTestChar>
   155b8:	81 30       	cpi	r24, 0x01	; 1
   155ba:	19 f4       	brne	.+6      	; 0x155c2 <FMenuIdle+0x30e>
         stMenuIdle=miReady;
   155bc:	8b e0       	ldi	r24, 0x0B	; 11
   155be:	80 93 d6 03 	sts	0x03D6, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   155c2:	80 91 ce 01 	lds	r24, 0x01CE
   155c6:	81 30       	cpi	r24, 0x01	; 1
   155c8:	21 f4       	brne	.+8      	; 0x155d2 <FMenuIdle+0x31e>
		    IsMessage21=False;
   155ca:	10 92 ce 01 	sts	0x01CE, r1
			procMessage21();
   155ce:	0e 94 24 46 	call	0x8c48	; 0x8c48 <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   155d2:	80 91 cb 01 	lds	r24, 0x01CB
   155d6:	81 30       	cpi	r24, 0x01	; 1
   155d8:	91 f4       	brne	.+36     	; 0x155fe <FMenuIdle+0x34a>
		    IsMessage00=False;
   155da:	10 92 cb 01 	sts	0x01CB, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   155de:	20 91 20 0b 	lds	r18, 0x0B20
   155e2:	21 30       	cpi	r18, 0x01	; 1
   155e4:	61 f4       	brne	.+24     	; 0x155fe <FMenuIdle+0x34a>
   155e6:	80 91 b3 01 	lds	r24, 0x01B3
   155ea:	90 91 b4 01 	lds	r25, 0x01B4
   155ee:	8f 97       	sbiw	r24, 0x2f	; 47
   155f0:	31 f4       	brne	.+12     	; 0x155fe <FMenuIdle+0x34a>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   155f2:	80 91 45 0b 	lds	r24, 0x0B45
   155f6:	84 33       	cpi	r24, 0x34	; 52
   155f8:	11 f4       	brne	.+4      	; 0x155fe <FMenuIdle+0x34a>
			    IsNoTransaction=True;
   155fa:	20 93 d8 01 	sts	0x01D8, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   155fe:	80 91 c3 01 	lds	r24, 0x01C3
   15602:	81 30       	cpi	r24, 0x01	; 1
   15604:	21 f4       	brne	.+8      	; 0x1560e <FMenuIdle+0x35a>
		    IsSendMessageEDC=False;
   15606:	10 92 c3 01 	sts	0x01C3, r1
			SendEDCMessage();
   1560a:	0e 94 1a 74 	call	0xe834	; 0xe834 <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   1560e:	80 91 c5 01 	lds	r24, 0x01C5
   15612:	81 30       	cpi	r24, 0x01	; 1
   15614:	21 f4       	brne	.+8      	; 0x1561e <FMenuIdle+0x36a>
		    IsEDCApproved=False;
   15616:	10 92 c5 01 	sts	0x01C5, r1
            sendMessage92();
   1561a:	0e 94 ab 4d 	call	0x9b56	; 0x9b56 <sendMessage92>
		}
		if (IsVoidTransaction==True){
   1561e:	80 91 c7 01 	lds	r24, 0x01C7
   15622:	81 30       	cpi	r24, 0x01	; 1
   15624:	21 f4       	brne	.+8      	; 0x1562e <FMenuIdle+0x37a>
		    IsVoidTransaction=False;
   15626:	10 92 c7 01 	sts	0x01C7, r1
            sendMessage94();
   1562a:	0e 94 04 4d 	call	0x9a08	; 0x9a08 <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   1562e:	10 91 cc 01 	lds	r17, 0x01CC
   15632:	11 30       	cpi	r17, 0x01	; 1
   15634:	31 f4       	brne	.+12     	; 0x15642 <FMenuIdle+0x38e>
	        IsMessage99=False;
   15636:	10 92 cc 01 	sts	0x01CC, r1
		    procMessage99();
   1563a:	0e 94 67 3e 	call	0x7cce	; 0x7cce <procMessage99>
		    IsPrinting=True;
   1563e:	10 93 d9 01 	sts	0x01D9, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   15642:	80 91 d8 01 	lds	r24, 0x01D8
   15646:	81 30       	cpi	r24, 0x01	; 1
   15648:	41 f4       	brne	.+16     	; 0x1565a <FMenuIdle+0x3a6>
			IsNoTransaction=False;
   1564a:	10 92 d8 01 	sts	0x01D8, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   1564e:	83 e0       	ldi	r24, 0x03	; 3
   15650:	61 e0       	ldi	r22, 0x01	; 1
   15652:	42 e2       	ldi	r20, 0x22	; 34
   15654:	52 e2       	ldi	r21, 0x22	; 34
   15656:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   1565a:	80 91 d6 03 	lds	r24, 0x03D6
   1565e:	81 30       	cpi	r24, 0x01	; 1
   15660:	11 f4       	brne	.+4      	; 0x15666 <FMenuIdle+0x3b2>
		    DisplayIdle();			
   15662:	0e 94 d7 71 	call	0xe3ae	; 0xe3ae <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   15666:	80 91 d6 03 	lds	r24, 0x03D6
   1566a:	81 30       	cpi	r24, 0x01	; 1
   1566c:	59 f4       	brne	.+22     	; 0x15684 <FMenuIdle+0x3d0>
		    if (IsMessage09==True){
   1566e:	80 91 d0 01 	lds	r24, 0x01D0
   15672:	81 30       	cpi	r24, 0x01	; 1
   15674:	39 f4       	brne	.+14     	; 0x15684 <FMenuIdle+0x3d0>
			    IsMessage09=False;
   15676:	10 92 d0 01 	sts	0x01D0, r1
				procMessage09();
   1567a:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   1567e:	83 e1       	ldi	r24, 0x13	; 19
   15680:	80 93 d6 03 	sts	0x03D6, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   15684:	80 91 d6 03 	lds	r24, 0x03D6
   15688:	81 30       	cpi	r24, 0x01	; 1
   1568a:	69 f4       	brne	.+26     	; 0x156a6 <FMenuIdle+0x3f2>
   1568c:	80 91 c4 01 	lds	r24, 0x01C4
   15690:	81 30       	cpi	r24, 0x01	; 1
   15692:	49 f4       	brne	.+18     	; 0x156a6 <FMenuIdle+0x3f2>
		    IsRFIDDetected=False;
   15694:	10 92 c4 01 	sts	0x01C4, r1
		    system_beep(2);           
   15698:	82 e0       	ldi	r24, 0x02	; 2
   1569a:	90 e0       	ldi	r25, 0x00	; 0
   1569c:	0e 94 6f 14 	call	0x28de	; 0x28de <system_beep>
			stMenuIdle=miRunLocalAccount;
   156a0:	8e e0       	ldi	r24, 0x0E	; 14
   156a2:	80 93 d6 03 	sts	0x03D6, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   156a6:	10 91 d3 01 	lds	r17, 0x01D3
   156aa:	11 30       	cpi	r17, 0x01	; 1
   156ac:	41 f4       	brne	.+16     	; 0x156be <FMenuIdle+0x40a>
		    IsMessage81=False;
   156ae:	10 92 d3 01 	sts	0x01D3, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   156b2:	0e 94 49 17 	call	0x2e92	; 0x2e92 <procMessage81>
   156b6:	80 93 e1 01 	sts	0x01E1, r24
			IsFreePrinting=True;
   156ba:	10 93 d5 01 	sts	0x01D5, r17
         }

    //SystemService
      systemGenerateReport();
   156be:	0e 94 62 31 	call	0x62c4	; 0x62c4 <systemGenerateReport>
      systemPrinting();
   156c2:	0e 94 04 5d 	call	0xba08	; 0xba08 <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   156c6:	0e 94 34 a9 	call	0x15268	; 0x15268 <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   156ca:	1f 91       	pop	r17
   156cc:	08 95       	ret

000156ce <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
   156ce:	1f 92       	push	r1
   156d0:	0f 92       	push	r0
   156d2:	0f b6       	in	r0, 0x3f	; 63
   156d4:	0f 92       	push	r0
   156d6:	0b b6       	in	r0, 0x3b	; 59
   156d8:	0f 92       	push	r0
   156da:	11 24       	eor	r1, r1
   156dc:	2f 93       	push	r18
   156de:	3f 93       	push	r19
   156e0:	4f 93       	push	r20
   156e2:	5f 93       	push	r21
   156e4:	6f 93       	push	r22
   156e6:	7f 93       	push	r23
   156e8:	8f 93       	push	r24
   156ea:	9f 93       	push	r25
   156ec:	af 93       	push	r26
   156ee:	bf 93       	push	r27
   156f0:	ef 93       	push	r30
   156f2:	ff 93       	push	r31
static char __i_timer=0;
	if(__timer){
   156f4:	80 91 26 04 	lds	r24, 0x0426
   156f8:	88 23       	and	r24, r24
   156fa:	81 f0       	breq	.+32     	; 0x1571c <__vector_12+0x4e>
        _TIME_IN;
   156fc:	81 e0       	ldi	r24, 0x01	; 1
   156fe:	80 93 27 04 	sts	0x0427, r24
		__timercount++;
   15702:	80 91 eb 03 	lds	r24, 0x03EB
   15706:	8f 5f       	subi	r24, 0xFF	; 255
   15708:	80 93 eb 03 	sts	0x03EB, r24
		if(__timercount==24){
   1570c:	88 31       	cpi	r24, 0x18	; 24
   1570e:	31 f4       	brne	.+12     	; 0x1571c <__vector_12+0x4e>
            _TIMER_OFF;
   15710:	10 92 26 04 	sts	0x0426, r1
            _TIMER_RESET;
   15714:	10 92 eb 03 	sts	0x03EB, r1
            _TIME_OUT;
   15718:	10 92 27 04 	sts	0x0427, r1
		}
	}
	if(__sec_flag){
   1571c:	80 91 ec 03 	lds	r24, 0x03EC
   15720:	88 23       	and	r24, r24
   15722:	61 f0       	breq	.+24     	; 0x1573c <__vector_12+0x6e>
		_SEC_TICK;
   15724:	80 91 24 04 	lds	r24, 0x0424
   15728:	8f 5f       	subi	r24, 0xFF	; 255
   1572a:	80 93 24 04 	sts	0x0424, r24
		if(__sec_count == 250)
   1572e:	8a 3f       	cpi	r24, 0xFA	; 250
   15730:	29 f4       	brne	.+10     	; 0x1573c <__vector_12+0x6e>
			_SEC_OFF;
   15732:	10 92 ec 03 	sts	0x03EC, r1
   15736:	81 e0       	ldi	r24, 0x01	; 1
   15738:	80 93 ed 03 	sts	0x03ED, r24
	}

	_light_ticker();
   1573c:	0e 94 14 ae 	call	0x15c28	; 0x15c28 <_light_ticker>
	_shift_ticker();
   15740:	0e 94 0a b1 	call	0x16214	; 0x16214 <_shift_ticker>

	__i_timer++;
   15744:	80 91 d7 03 	lds	r24, 0x03D7
   15748:	8f 5f       	subi	r24, 0xFF	; 255
   1574a:	80 93 d7 03 	sts	0x03D7, r24
	if (__i_timer > 5){
   1574e:	86 30       	cpi	r24, 0x06	; 6
   15750:	30 f0       	brcs	.+12     	; 0x1575e <__vector_12+0x90>
		__i_timer = 0;
   15752:	10 92 d7 03 	sts	0x03D7, r1
		PORTE = PORTE^0x04;
   15756:	83 b1       	in	r24, 0x03	; 3
   15758:	94 e0       	ldi	r25, 0x04	; 4
   1575a:	89 27       	eor	r24, r25
   1575c:	83 b9       	out	0x03, r24	; 3
	}
	//Beep
	if (TimBeep>0){
   1575e:	80 91 ec 01 	lds	r24, 0x01EC
   15762:	90 91 ed 01 	lds	r25, 0x01ED
   15766:	00 97       	sbiw	r24, 0x00	; 0
   15768:	41 f0       	breq	.+16     	; 0x1577a <__vector_12+0xac>
	    TimBeep--;
   1576a:	01 97       	sbiw	r24, 0x01	; 1
   1576c:	90 93 ed 01 	sts	0x01ED, r25
   15770:	80 93 ec 01 	sts	0x01EC, r24
		DDRB=(DDRB|0b00100000);
   15774:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
   15776:	c5 98       	cbi	0x18, 5	; 24
   15778:	05 c0       	rjmp	.+10     	; 0x15784 <__vector_12+0xb6>
	    }
	else{PORTB=(PORTB|~PORTB);
   1577a:	98 b3       	in	r25, 0x18	; 24
   1577c:	88 b3       	in	r24, 0x18	; 24
   1577e:	80 95       	com	r24
   15780:	89 2b       	or	r24, r25
   15782:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
   15784:	80 91 e8 01 	lds	r24, 0x01E8
   15788:	90 91 e9 01 	lds	r25, 0x01E9
   1578c:	01 96       	adiw	r24, 0x01	; 1
   1578e:	90 93 e9 01 	sts	0x01E9, r25
   15792:	80 93 e8 01 	sts	0x01E8, r24
	//DisplaTicker
    TimTicker++;
   15796:	80 91 ba 01 	lds	r24, 0x01BA
   1579a:	8f 5f       	subi	r24, 0xFF	; 255
   1579c:	80 93 ba 01 	sts	0x01BA, r24
	TimPressed++;
   157a0:	20 91 bb 01 	lds	r18, 0x01BB
   157a4:	2f 5f       	subi	r18, 0xFF	; 255
   157a6:	20 93 bb 01 	sts	0x01BB, r18
	if ((TimPressed%5)==0){
   157aa:	82 2f       	mov	r24, r18
   157ac:	65 e0       	ldi	r22, 0x05	; 5
   157ae:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
   157b2:	99 23       	and	r25, r25
   157b4:	71 f4       	brne	.+28     	; 0x157d2 <__vector_12+0x104>
	    TimDisplay++;
   157b6:	80 91 bc 01 	lds	r24, 0x01BC
   157ba:	8f 5f       	subi	r24, 0xFF	; 255
   157bc:	80 93 bc 01 	sts	0x01BC, r24
		TimPrintBusy++;
   157c0:	80 91 e2 01 	lds	r24, 0x01E2
   157c4:	90 91 e3 01 	lds	r25, 0x01E3
   157c8:	01 96       	adiw	r24, 0x01	; 1
   157ca:	90 93 e3 01 	sts	0x01E3, r25
   157ce:	80 93 e2 01 	sts	0x01E2, r24
		//FBackLight();
	}
	if ((TimPressed%PRESSED_DELAY)==0){
   157d2:	82 2f       	mov	r24, r18
   157d4:	6a e0       	ldi	r22, 0x0A	; 10
   157d6:	0e 94 d4 b8 	call	0x171a8	; 0x171a8 <__udivmodqi4>
   157da:	99 23       	and	r25, r25
   157dc:	49 f4       	brne	.+18     	; 0x157f0 <__vector_12+0x122>
	     ProcTimeOut++;
   157de:	80 91 f2 01 	lds	r24, 0x01F2
   157e2:	90 91 f3 01 	lds	r25, 0x01F3
   157e6:	01 96       	adiw	r24, 0x01	; 1
   157e8:	90 93 f3 01 	sts	0x01F3, r25
   157ec:	80 93 f2 01 	sts	0x01F2, r24
	}
	TimSend++;
   157f0:	80 91 bd 01 	lds	r24, 0x01BD
   157f4:	90 91 be 01 	lds	r25, 0x01BE
   157f8:	01 96       	adiw	r24, 0x01	; 1
   157fa:	90 93 be 01 	sts	0x01BE, r25
   157fe:	80 93 bd 01 	sts	0x01BD, r24
}
   15802:	ff 91       	pop	r31
   15804:	ef 91       	pop	r30
   15806:	bf 91       	pop	r27
   15808:	af 91       	pop	r26
   1580a:	9f 91       	pop	r25
   1580c:	8f 91       	pop	r24
   1580e:	7f 91       	pop	r23
   15810:	6f 91       	pop	r22
   15812:	5f 91       	pop	r21
   15814:	4f 91       	pop	r20
   15816:	3f 91       	pop	r19
   15818:	2f 91       	pop	r18
   1581a:	0f 90       	pop	r0
   1581c:	0b be       	out	0x3b, r0	; 59
   1581e:	0f 90       	pop	r0
   15820:	0f be       	out	0x3f, r0	; 63
   15822:	0f 90       	pop	r0
   15824:	1f 90       	pop	r1
   15826:	18 95       	reti

00015828 <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   15828:	98 2f       	mov	r25, r24
   1582a:	90 7f       	andi	r25, 0xF0	; 240
   1582c:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   1582e:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15830:	a9 9a       	sbi	0x15, 1	; 21
   15832:	48 ee       	ldi	r20, 0xE8	; 232
   15834:	53 e0       	ldi	r21, 0x03	; 3
   15836:	fa 01       	movw	r30, r20
   15838:	31 97       	sbiw	r30, 0x01	; 1
   1583a:	f1 f7       	brne	.-4      	; 0x15838 <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1583c:	a9 98       	cbi	0x15, 1	; 21
   1583e:	fa 01       	movw	r30, r20
   15840:	31 97       	sbiw	r30, 0x01	; 1
   15842:	f1 f7       	brne	.-4      	; 0x15840 <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   15844:	28 2f       	mov	r18, r24
   15846:	30 e0       	ldi	r19, 0x00	; 0
   15848:	94 e0       	ldi	r25, 0x04	; 4
   1584a:	22 0f       	add	r18, r18
   1584c:	33 1f       	adc	r19, r19
   1584e:	9a 95       	dec	r25
   15850:	e1 f7       	brne	.-8      	; 0x1584a <lcd_command+0x22>
   15852:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   15854:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15856:	a9 9a       	sbi	0x15, 1	; 21
   15858:	fa 01       	movw	r30, r20
   1585a:	31 97       	sbiw	r30, 0x01	; 1
   1585c:	f1 f7       	brne	.-4      	; 0x1585a <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1585e:	a9 98       	cbi	0x15, 1	; 21
   15860:	fa 01       	movw	r30, r20
   15862:	31 97       	sbiw	r30, 0x01	; 1
   15864:	f1 f7       	brne	.-4      	; 0x15862 <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   15866:	fa 01       	movw	r30, r20
   15868:	31 97       	sbiw	r30, 0x01	; 1
   1586a:	f1 f7       	brne	.-4      	; 0x15868 <lcd_command+0x40>
   1586c:	81 30       	cpi	r24, 0x01	; 1
   1586e:	21 f4       	brne	.+8      	; 0x15878 <lcd_command+0x50>
   15870:	84 ed       	ldi	r24, 0xD4	; 212
   15872:	90 e3       	ldi	r25, 0x30	; 48
   15874:	01 97       	sbiw	r24, 0x01	; 1
   15876:	f1 f7       	brne	.-4      	; 0x15874 <lcd_command+0x4c>
   15878:	08 95       	ret

0001587a <lcd_init>:
   1587a:	86 ea       	ldi	r24, 0xA6	; 166
   1587c:	9e e0       	ldi	r25, 0x0E	; 14
   1587e:	01 97       	sbiw	r24, 0x01	; 1
   15880:	f1 f7       	brne	.-4      	; 0x1587e <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   15882:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   15884:	84 b3       	in	r24, 0x14	; 20
   15886:	80 6f       	ori	r24, 0xF0	; 240
   15888:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   1588a:	84 b3       	in	r24, 0x14	; 20
   1588c:	8e 60       	ori	r24, 0x0E	; 14
   1588e:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   15890:	20 e3       	ldi	r18, 0x30	; 48
   15892:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15894:	a9 9a       	sbi	0x15, 1	; 21
   15896:	88 ee       	ldi	r24, 0xE8	; 232
   15898:	93 e0       	ldi	r25, 0x03	; 3
   1589a:	fc 01       	movw	r30, r24
   1589c:	31 97       	sbiw	r30, 0x01	; 1
   1589e:	f1 f7       	brne	.-4      	; 0x1589c <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158a0:	a9 98       	cbi	0x15, 1	; 21
   158a2:	fc 01       	movw	r30, r24
   158a4:	31 97       	sbiw	r30, 0x01	; 1
   158a6:	f1 f7       	brne	.-4      	; 0x158a4 <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   158a8:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   158aa:	a9 9a       	sbi	0x15, 1	; 21
   158ac:	fc 01       	movw	r30, r24
   158ae:	31 97       	sbiw	r30, 0x01	; 1
   158b0:	f1 f7       	brne	.-4      	; 0x158ae <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158b2:	a9 98       	cbi	0x15, 1	; 21
   158b4:	fc 01       	movw	r30, r24
   158b6:	31 97       	sbiw	r30, 0x01	; 1
   158b8:	f1 f7       	brne	.-4      	; 0x158b6 <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   158ba:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   158bc:	a9 9a       	sbi	0x15, 1	; 21
   158be:	fc 01       	movw	r30, r24
   158c0:	31 97       	sbiw	r30, 0x01	; 1
   158c2:	f1 f7       	brne	.-4      	; 0x158c0 <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158c4:	a9 98       	cbi	0x15, 1	; 21
   158c6:	fc 01       	movw	r30, r24
   158c8:	31 97       	sbiw	r30, 0x01	; 1
   158ca:	f1 f7       	brne	.-4      	; 0x158c8 <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   158cc:	20 e2       	ldi	r18, 0x20	; 32
   158ce:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   158d0:	a9 9a       	sbi	0x15, 1	; 21
   158d2:	fc 01       	movw	r30, r24
   158d4:	31 97       	sbiw	r30, 0x01	; 1
   158d6:	f1 f7       	brne	.-4      	; 0x158d4 <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158d8:	a9 98       	cbi	0x15, 1	; 21
   158da:	01 97       	sbiw	r24, 0x01	; 1
   158dc:	f1 f7       	brne	.-4      	; 0x158da <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   158de:	81 e0       	ldi	r24, 0x01	; 1
   158e0:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   158e4:	e4 e6       	ldi	r30, 0x64	; 100
   158e6:	f0 e0       	ldi	r31, 0x00	; 0
   158e8:	80 81       	ld	r24, Z
   158ea:	82 60       	ori	r24, 0x02	; 2
   158ec:	80 83       	st	Z, r24

	lcd_command(0x28);
   158ee:	88 e2       	ldi	r24, 0x28	; 40
   158f0:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
	lcd_command(0x0c);
   158f4:	8c e0       	ldi	r24, 0x0C	; 12
   158f6:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
	lcd_command(0x06);
   158fa:	86 e0       	ldi	r24, 0x06	; 6
   158fc:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
}
   15900:	08 95       	ret

00015902 <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   15902:	28 2f       	mov	r18, r24
   15904:	20 7f       	andi	r18, 0xF0	; 240
   15906:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15908:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   1590a:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   1590c:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   1590e:	90 e0       	ldi	r25, 0x00	; 0
   15910:	24 e0       	ldi	r18, 0x04	; 4
   15912:	88 0f       	add	r24, r24
   15914:	99 1f       	adc	r25, r25
   15916:	2a 95       	dec	r18
   15918:	e1 f7       	brne	.-8      	; 0x15912 <_lcd+0x10>
   1591a:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   1591c:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   1591e:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   15920:	a9 98       	cbi	0x15, 1	; 21
   15922:	88 ee       	ldi	r24, 0xE8	; 232
   15924:	93 e0       	ldi	r25, 0x03	; 3
   15926:	01 97       	sbiw	r24, 0x01	; 1
   15928:	f1 f7       	brne	.-4      	; 0x15926 <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   1592a:	8a ef       	ldi	r24, 0xFA	; 250
   1592c:	90 e0       	ldi	r25, 0x00	; 0
   1592e:	01 97       	sbiw	r24, 0x01	; 1
   15930:	f1 f7       	brne	.-4      	; 0x1592e <_lcd+0x2c>
   15932:	08 95       	ret

00015934 <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   15934:	cf 93       	push	r28
   15936:	df 93       	push	r29
   15938:	ec 01       	movw	r28, r24
   1593a:	03 c0       	rjmp	.+6      	; 0x15942 <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   1593c:	21 96       	adiw	r28, 0x01	; 1
   1593e:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   15942:	88 81       	ld	r24, Y
   15944:	88 23       	and	r24, r24
   15946:	d1 f7       	brne	.-12     	; 0x1593c <lcd_string+0x8>
		_lcd(*__string++);
}
   15948:	df 91       	pop	r29
   1594a:	cf 91       	pop	r28
   1594c:	08 95       	ret

0001594e <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   1594e:	82 30       	cpi	r24, 0x02	; 2
   15950:	69 f0       	breq	.+26     	; 0x1596c <lcd_xy+0x1e>
   15952:	83 30       	cpi	r24, 0x03	; 3
   15954:	18 f4       	brcc	.+6      	; 0x1595c <lcd_xy+0xe>
   15956:	81 30       	cpi	r24, 0x01	; 1
   15958:	a9 f4       	brne	.+42     	; 0x15984 <lcd_xy+0x36>
   1595a:	05 c0       	rjmp	.+10     	; 0x15966 <lcd_xy+0x18>
   1595c:	83 30       	cpi	r24, 0x03	; 3
   1595e:	49 f0       	breq	.+18     	; 0x15972 <lcd_xy+0x24>
   15960:	84 30       	cpi	r24, 0x04	; 4
   15962:	81 f4       	brne	.+32     	; 0x15984 <lcd_xy+0x36>
   15964:	0b c0       	rjmp	.+22     	; 0x1597c <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   15966:	86 2f       	mov	r24, r22
   15968:	81 58       	subi	r24, 0x81	; 129
   1596a:	05 c0       	rjmp	.+10     	; 0x15976 <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   1596c:	86 2f       	mov	r24, r22
   1596e:	81 54       	subi	r24, 0x41	; 65
   15970:	02 c0       	rjmp	.+4      	; 0x15976 <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   15972:	86 2f       	mov	r24, r22
   15974:	8d 56       	subi	r24, 0x6D	; 109
   15976:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   1597a:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   1597c:	86 2f       	mov	r24, r22
   1597e:	8d 52       	subi	r24, 0x2D	; 45
   15980:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   15984:	08 95       	ret

00015986 <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   15986:	df 92       	push	r13
   15988:	ef 92       	push	r14
   1598a:	ff 92       	push	r15
   1598c:	0f 93       	push	r16
   1598e:	1f 93       	push	r17
   15990:	cf 93       	push	r28
   15992:	df 93       	push	r29
   15994:	06 2f       	mov	r16, r22
   15996:	d4 2e       	mov	r13, r20
   15998:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   1599a:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   1599e:	2d 2d       	mov	r18, r13
   159a0:	31 2f       	mov	r19, r17
   159a2:	c9 01       	movw	r24, r18
   159a4:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   159a6:	34 e1       	ldi	r19, 0x14	; 20
   159a8:	e3 2e       	mov	r14, r19
   159aa:	f1 2c       	mov	r15, r1
   159ac:	e0 1a       	sub	r14, r16
   159ae:	f1 08       	sbc	r15, r1
   159b0:	04 c0       	rjmp	.+8      	; 0x159ba <lcd_print+0x34>
		_lcd(*__string);__string++;
   159b2:	82 2f       	mov	r24, r18
   159b4:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
   159b8:	21 96       	adiw	r28, 0x01	; 1
   159ba:	9e 01       	movw	r18, r28
   159bc:	2d 19       	sub	r18, r13
   159be:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   159c0:	28 81       	ld	r18, Y
   159c2:	22 23       	and	r18, r18
   159c4:	21 f0       	breq	.+8      	; 0x159ce <lcd_print+0x48>
   159c6:	90 e0       	ldi	r25, 0x00	; 0
   159c8:	e8 16       	cp	r14, r24
   159ca:	f9 06       	cpc	r15, r25
   159cc:	94 f7       	brge	.-28     	; 0x159b2 <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   159ce:	df 91       	pop	r29
   159d0:	cf 91       	pop	r28
   159d2:	1f 91       	pop	r17
   159d4:	0f 91       	pop	r16
   159d6:	ff 90       	pop	r15
   159d8:	ef 90       	pop	r14
   159da:	df 90       	pop	r13
   159dc:	08 95       	ret

000159de <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   159de:	df 92       	push	r13
   159e0:	ef 92       	push	r14
   159e2:	ff 92       	push	r15
   159e4:	0f 93       	push	r16
   159e6:	1f 93       	push	r17
   159e8:	cf 93       	push	r28
   159ea:	df 93       	push	r29
   159ec:	06 2f       	mov	r16, r22
   159ee:	d4 2e       	mov	r13, r20
   159f0:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   159f2:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   159f6:	8d 2d       	mov	r24, r13
   159f8:	91 2f       	mov	r25, r17
   159fa:	fc 01       	movw	r30, r24
   159fc:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   159fe:	44 e1       	ldi	r20, 0x14	; 20
   15a00:	e4 2e       	mov	r14, r20
   15a02:	f1 2c       	mov	r15, r1
   15a04:	e0 1a       	sub	r14, r16
   15a06:	f1 08       	sbc	r15, r1
   15a08:	04 c0       	rjmp	.+8      	; 0x15a12 <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   15a0a:	82 2f       	mov	r24, r18
   15a0c:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
		__string++;
   15a10:	21 96       	adiw	r28, 0x01	; 1
   15a12:	9e 01       	movw	r18, r28
   15a14:	2d 19       	sub	r18, r13
   15a16:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15a18:	fe 01       	movw	r30, r28
   15a1a:	24 91       	lpm	r18, Z+
   15a1c:	22 23       	and	r18, r18
   15a1e:	21 f0       	breq	.+8      	; 0x15a28 <lcd_printf+0x4a>
   15a20:	90 e0       	ldi	r25, 0x00	; 0
   15a22:	e8 16       	cp	r14, r24
   15a24:	f9 06       	cpc	r15, r25
   15a26:	8c f7       	brge	.-30     	; 0x15a0a <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   15a28:	df 91       	pop	r29
   15a2a:	cf 91       	pop	r28
   15a2c:	1f 91       	pop	r17
   15a2e:	0f 91       	pop	r16
   15a30:	ff 90       	pop	r15
   15a32:	ef 90       	pop	r14
   15a34:	df 90       	pop	r13
   15a36:	08 95       	ret

00015a38 <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   15a38:	81 e0       	ldi	r24, 0x01	; 1
   15a3a:	61 e0       	ldi	r22, 0x01	; 1
   15a3c:	42 e4       	ldi	r20, 0x42	; 66
   15a3e:	53 e2       	ldi	r21, 0x23	; 35
   15a40:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   15a44:	82 e0       	ldi	r24, 0x02	; 2
   15a46:	61 e0       	ldi	r22, 0x01	; 1
   15a48:	4d e2       	ldi	r20, 0x2D	; 45
   15a4a:	53 e2       	ldi	r21, 0x23	; 35
   15a4c:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   15a50:	83 e0       	ldi	r24, 0x03	; 3
   15a52:	61 e0       	ldi	r22, 0x01	; 1
   15a54:	48 e1       	ldi	r20, 0x18	; 24
   15a56:	53 e2       	ldi	r21, 0x23	; 35
   15a58:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   15a5c:	84 e0       	ldi	r24, 0x04	; 4
   15a5e:	61 e0       	ldi	r22, 0x01	; 1
   15a60:	43 e0       	ldi	r20, 0x03	; 3
   15a62:	53 e2       	ldi	r21, 0x23	; 35
   15a64:	0e 94 ef ac 	call	0x159de	; 0x159de <lcd_printf>
}
   15a68:	08 95       	ret

00015a6a <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   15a6a:	1f 93       	push	r17
   15a6c:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   15a6e:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
	_lcd(__chr);
   15a72:	81 2f       	mov	r24, r17
   15a74:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
}
   15a78:	1f 91       	pop	r17
   15a7a:	08 95       	ret

00015a7c <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   15a7c:	0f 93       	push	r16
   15a7e:	1f 93       	push	r17
   15a80:	cf 93       	push	r28
   15a82:	df 93       	push	r29
   15a84:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   15a86:	88 30       	cpi	r24, 0x08	; 8
   15a88:	90 f4       	brcc	.+36     	; 0x15aae <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   15a8a:	88 0f       	add	r24, r24
   15a8c:	88 0f       	add	r24, r24
   15a8e:	88 0f       	add	r24, r24
   15a90:	80 5c       	subi	r24, 0xC0	; 192
   15a92:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   15a96:	c0 e0       	ldi	r28, 0x00	; 0
   15a98:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   15a9a:	f8 01       	movw	r30, r16
   15a9c:	ec 0f       	add	r30, r28
   15a9e:	fd 1f       	adc	r31, r29
   15aa0:	80 81       	ld	r24, Z
   15aa2:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
   15aa6:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   15aa8:	c8 30       	cpi	r28, 0x08	; 8
   15aaa:	d1 05       	cpc	r29, r1
   15aac:	b1 f7       	brne	.-20     	; 0x15a9a <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   15aae:	df 91       	pop	r29
   15ab0:	cf 91       	pop	r28
   15ab2:	1f 91       	pop	r17
   15ab4:	0f 91       	pop	r16
   15ab6:	08 95       	ret

00015ab8 <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   15ab8:	cf 93       	push	r28
   15aba:	df 93       	push	r29
   15abc:	20 e0       	ldi	r18, 0x00	; 0
   15abe:	04 c0       	rjmp	.+8      	; 0x15ac8 <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   15ac0:	c8 0f       	add	r28, r24
   15ac2:	d9 1f       	adc	r29, r25
   15ac4:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   15ac6:	2f 5f       	subi	r18, 0xFF	; 255
   15ac8:	c2 2f       	mov	r28, r18
   15aca:	d0 e0       	ldi	r29, 0x00	; 0
   15acc:	fc 01       	movw	r30, r24
   15ace:	01 90       	ld	r0, Z+
   15ad0:	00 20       	and	r0, r0
   15ad2:	e9 f7       	brne	.-6      	; 0x15ace <ClearMem+0x16>
   15ad4:	31 97       	sbiw	r30, 0x01	; 1
   15ad6:	e8 1b       	sub	r30, r24
   15ad8:	f9 0b       	sbc	r31, r25
   15ada:	ce 17       	cp	r28, r30
   15adc:	df 07       	cpc	r29, r31
   15ade:	80 f3       	brcs	.-32     	; 0x15ac0 <ClearMem+0x8>
          string[i]=0;
	 }     
}
   15ae0:	df 91       	pop	r29
   15ae2:	cf 91       	pop	r28
   15ae4:	08 95       	ret

00015ae6 <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   15ae6:	df 93       	push	r29
   15ae8:	cf 93       	push	r28
   15aea:	00 d0       	rcall	.+0      	; 0x15aec <_key_hit+0x6>
   15aec:	00 d0       	rcall	.+0      	; 0x15aee <_key_hit+0x8>
   15aee:	cd b7       	in	r28, 0x3d	; 61
   15af0:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15af2:	8f ee       	ldi	r24, 0xEF	; 239
   15af4:	89 83       	std	Y+1, r24	; 0x01
   15af6:	8f ed       	ldi	r24, 0xDF	; 223
   15af8:	8a 83       	std	Y+2, r24	; 0x02
   15afa:	8f eb       	ldi	r24, 0xBF	; 191
   15afc:	8b 83       	std	Y+3, r24	; 0x03
   15afe:	8f e7       	ldi	r24, 0x7F	; 127
   15b00:	8c 83       	std	Y+4, r24	; 0x04
   15b02:	de 01       	movw	r26, r28
   15b04:	11 96       	adiw	r26, 0x01	; 1
   15b06:	2a ef       	ldi	r18, 0xFA	; 250
   15b08:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15b0a:	ae 01       	movw	r20, r28
   15b0c:	4b 5f       	subi	r20, 0xFB	; 251
   15b0e:	5f 4f       	sbci	r21, 0xFF	; 255
   15b10:	c9 01       	movw	r24, r18
   15b12:	01 97       	sbiw	r24, 0x01	; 1
   15b14:	f1 f7       	brne	.-4      	; 0x15b12 <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15b16:	8c 91       	ld	r24, X
   15b18:	80 93 62 00 	sts	0x0062, r24
   15b1c:	f9 01       	movw	r30, r18
   15b1e:	31 97       	sbiw	r30, 0x01	; 1
   15b20:	f1 f7       	brne	.-4      	; 0x15b1e <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15b22:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) break;
   15b24:	98 17       	cp	r25, r24
   15b26:	21 f4       	brne	.+8      	; 0x15b30 <_key_hit+0x4a>
   15b28:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15b2a:	a4 17       	cp	r26, r20
   15b2c:	b5 07       	cpc	r27, r21
   15b2e:	81 f7       	brne	.-32     	; 0x15b10 <_key_hit+0x2a>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) break;
	}
	return keyhit;
}
   15b30:	89 2f       	mov	r24, r25
   15b32:	0f 90       	pop	r0
   15b34:	0f 90       	pop	r0
   15b36:	0f 90       	pop	r0
   15b38:	0f 90       	pop	r0
   15b3a:	cf 91       	pop	r28
   15b3c:	df 91       	pop	r29
   15b3e:	08 95       	ret

00015b40 <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   15b40:	8e 3e       	cpi	r24, 0xEE	; 238
   15b42:	f9 f0       	breq	.+62     	; 0x15b82 <_key_crr+0x42>
   15b44:	8e 3d       	cpi	r24, 0xDE	; 222
   15b46:	e9 f0       	breq	.+58     	; 0x15b82 <_key_crr+0x42>
   15b48:	8e 3b       	cpi	r24, 0xBE	; 190
   15b4a:	d9 f0       	breq	.+54     	; 0x15b82 <_key_crr+0x42>
   15b4c:	8d 3e       	cpi	r24, 0xED	; 237
   15b4e:	c9 f0       	breq	.+50     	; 0x15b82 <_key_crr+0x42>
   15b50:	8d 3d       	cpi	r24, 0xDD	; 221
   15b52:	b9 f0       	breq	.+46     	; 0x15b82 <_key_crr+0x42>
   15b54:	8d 3b       	cpi	r24, 0xBD	; 189
   15b56:	a9 f0       	breq	.+42     	; 0x15b82 <_key_crr+0x42>
   15b58:	8b 3e       	cpi	r24, 0xEB	; 235
   15b5a:	99 f0       	breq	.+38     	; 0x15b82 <_key_crr+0x42>
   15b5c:	8b 3d       	cpi	r24, 0xDB	; 219
   15b5e:	89 f0       	breq	.+34     	; 0x15b82 <_key_crr+0x42>
   15b60:	8b 3b       	cpi	r24, 0xBB	; 187
   15b62:	79 f0       	breq	.+30     	; 0x15b82 <_key_crr+0x42>
   15b64:	87 3d       	cpi	r24, 0xD7	; 215
   15b66:	69 f0       	breq	.+26     	; 0x15b82 <_key_crr+0x42>
   15b68:	87 3e       	cpi	r24, 0xE7	; 231
   15b6a:	59 f0       	breq	.+22     	; 0x15b82 <_key_crr+0x42>
   15b6c:	87 3b       	cpi	r24, 0xB7	; 183
   15b6e:	49 f0       	breq	.+18     	; 0x15b82 <_key_crr+0x42>
   15b70:	8e 37       	cpi	r24, 0x7E	; 126
   15b72:	39 f0       	breq	.+14     	; 0x15b82 <_key_crr+0x42>
   15b74:	8d 37       	cpi	r24, 0x7D	; 125
   15b76:	29 f0       	breq	.+10     	; 0x15b82 <_key_crr+0x42>
   15b78:	8b 37       	cpi	r24, 0x7B	; 123
   15b7a:	19 f0       	breq	.+6      	; 0x15b82 <_key_crr+0x42>
   15b7c:	87 37       	cpi	r24, 0x77	; 119
   15b7e:	09 f0       	breq	.+2      	; 0x15b82 <_key_crr+0x42>
   15b80:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   15b82:	08 95       	ret

00015b84 <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   15b84:	8e 3b       	cpi	r24, 0xBE	; 190
   15b86:	91 f1       	breq	.+100    	; 0x15bec <_key_btn+0x68>
   15b88:	8f 3b       	cpi	r24, 0xBF	; 191
   15b8a:	a8 f4       	brcc	.+42     	; 0x15bb6 <_key_btn+0x32>
   15b8c:	8e 37       	cpi	r24, 0x7E	; 126
   15b8e:	09 f4       	brne	.+2      	; 0x15b92 <_key_btn+0xe>
   15b90:	41 c0       	rjmp	.+130    	; 0x15c14 <_key_btn+0x90>
   15b92:	8f 37       	cpi	r24, 0x7F	; 127
   15b94:	48 f4       	brcc	.+18     	; 0x15ba8 <_key_btn+0x24>
   15b96:	8b 37       	cpi	r24, 0x7B	; 123
   15b98:	09 f4       	brne	.+2      	; 0x15b9c <_key_btn+0x18>
   15b9a:	40 c0       	rjmp	.+128    	; 0x15c1c <_key_btn+0x98>
   15b9c:	8d 37       	cpi	r24, 0x7D	; 125
   15b9e:	e1 f1       	breq	.+120    	; 0x15c18 <_key_btn+0x94>
   15ba0:	87 37       	cpi	r24, 0x77	; 119
   15ba2:	09 f0       	breq	.+2      	; 0x15ba6 <_key_btn+0x22>
   15ba4:	3f c0       	rjmp	.+126    	; 0x15c24 <_key_btn+0xa0>
   15ba6:	3c c0       	rjmp	.+120    	; 0x15c20 <_key_btn+0x9c>
   15ba8:	8b 3b       	cpi	r24, 0xBB	; 187
   15baa:	61 f1       	breq	.+88     	; 0x15c04 <_key_btn+0x80>
   15bac:	8d 3b       	cpi	r24, 0xBD	; 189
   15bae:	21 f1       	breq	.+72     	; 0x15bf8 <_key_btn+0x74>
   15bb0:	87 3b       	cpi	r24, 0xB7	; 183
   15bb2:	c1 f5       	brne	.+112    	; 0x15c24 <_key_btn+0xa0>
   15bb4:	2d c0       	rjmp	.+90     	; 0x15c10 <_key_btn+0x8c>
   15bb6:	8e 3d       	cpi	r24, 0xDE	; 222
   15bb8:	a9 f0       	breq	.+42     	; 0x15be4 <_key_btn+0x60>
   15bba:	8f 3d       	cpi	r24, 0xDF	; 223
   15bbc:	38 f4       	brcc	.+14     	; 0x15bcc <_key_btn+0x48>
   15bbe:	8b 3d       	cpi	r24, 0xDB	; 219
   15bc0:	f9 f0       	breq	.+62     	; 0x15c00 <_key_btn+0x7c>
   15bc2:	8d 3d       	cpi	r24, 0xDD	; 221
   15bc4:	b9 f0       	breq	.+46     	; 0x15bf4 <_key_btn+0x70>
   15bc6:	87 3d       	cpi	r24, 0xD7	; 215
   15bc8:	69 f5       	brne	.+90     	; 0x15c24 <_key_btn+0xa0>
   15bca:	1e c0       	rjmp	.+60     	; 0x15c08 <_key_btn+0x84>
   15bcc:	8b 3e       	cpi	r24, 0xEB	; 235
   15bce:	b1 f0       	breq	.+44     	; 0x15bfc <_key_btn+0x78>
   15bd0:	8c 3e       	cpi	r24, 0xEC	; 236
   15bd2:	18 f4       	brcc	.+6      	; 0x15bda <_key_btn+0x56>
   15bd4:	87 3e       	cpi	r24, 0xE7	; 231
   15bd6:	31 f5       	brne	.+76     	; 0x15c24 <_key_btn+0xa0>
   15bd8:	19 c0       	rjmp	.+50     	; 0x15c0c <_key_btn+0x88>
   15bda:	8d 3e       	cpi	r24, 0xED	; 237
   15bdc:	49 f0       	breq	.+18     	; 0x15bf0 <_key_btn+0x6c>
   15bde:	8e 3e       	cpi	r24, 0xEE	; 238
   15be0:	09 f5       	brne	.+66     	; 0x15c24 <_key_btn+0xa0>
   15be2:	02 c0       	rjmp	.+4      	; 0x15be8 <_key_btn+0x64>
   15be4:	82 e3       	ldi	r24, 0x32	; 50
   15be6:	08 95       	ret
   15be8:	81 e3       	ldi	r24, 0x31	; 49
   15bea:	08 95       	ret
   15bec:	83 e3       	ldi	r24, 0x33	; 51
   15bee:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   15bf0:	84 e3       	ldi	r24, 0x34	; 52
   15bf2:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   15bf4:	85 e3       	ldi	r24, 0x35	; 53
   15bf6:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   15bf8:	86 e3       	ldi	r24, 0x36	; 54
   15bfa:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   15bfc:	87 e3       	ldi	r24, 0x37	; 55
   15bfe:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   15c00:	88 e3       	ldi	r24, 0x38	; 56
   15c02:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   15c04:	89 e3       	ldi	r24, 0x39	; 57
   15c06:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   15c08:	80 e3       	ldi	r24, 0x30	; 48
   15c0a:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   15c0c:	8a e2       	ldi	r24, 0x2A	; 42
   15c0e:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   15c10:	83 e2       	ldi	r24, 0x23	; 35
   15c12:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   15c14:	81 ef       	ldi	r24, 0xF1	; 241
   15c16:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   15c18:	82 ef       	ldi	r24, 0xF2	; 242
   15c1a:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   15c1c:	83 ef       	ldi	r24, 0xF3	; 243
   15c1e:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   15c20:	84 ef       	ldi	r24, 0xF4	; 244
   15c22:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   15c24:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   15c26:	08 95       	ret

00015c28 <_light_ticker>:

void _light_ticker(void){
	if(__key_light == 1){
   15c28:	80 91 e1 03 	lds	r24, 0x03E1
   15c2c:	81 30       	cpi	r24, 0x01	; 1
   15c2e:	81 f4       	brne	.+32     	; 0x15c50 <_light_ticker+0x28>
		__key_lgtcnt++;
   15c30:	80 91 e2 03 	lds	r24, 0x03E2
   15c34:	8f 5f       	subi	r24, 0xFF	; 255
   15c36:	80 93 e2 03 	sts	0x03E2, r24
		if(__key_lgtcnt == 150){
   15c3a:	86 39       	cpi	r24, 0x96	; 150
   15c3c:	49 f4       	brne	.+18     	; 0x15c50 <_light_ticker+0x28>
		   __key_light = 0; __key_lgtcnt = 0; sbi(PORTG, 1);
   15c3e:	10 92 e1 03 	sts	0x03E1, r1
   15c42:	10 92 e2 03 	sts	0x03E2, r1
   15c46:	80 91 65 00 	lds	r24, 0x0065
   15c4a:	82 60       	ori	r24, 0x02	; 2
   15c4c:	80 93 65 00 	sts	0x0065, r24
   15c50:	08 95       	ret

00015c52 <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   15c52:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   15c54:	6d 3d       	cpi	r22, 0xDD	; 221
   15c56:	11 f1       	breq	.+68     	; 0x15c9c <_table_alphanum+0x4a>
   15c58:	6e 3d       	cpi	r22, 0xDE	; 222
   15c5a:	60 f4       	brcc	.+24     	; 0x15c74 <_table_alphanum+0x22>
   15c5c:	6d 3b       	cpi	r22, 0xBD	; 189
   15c5e:	01 f1       	breq	.+64     	; 0x15ca0 <_table_alphanum+0x4e>
   15c60:	6e 3b       	cpi	r22, 0xBE	; 190
   15c62:	18 f4       	brcc	.+6      	; 0x15c6a <_table_alphanum+0x18>
   15c64:	6b 3b       	cpi	r22, 0xBB	; 187
   15c66:	21 f5       	brne	.+72     	; 0x15cb0 <_table_alphanum+0x5e>
   15c68:	21 c0       	rjmp	.+66     	; 0x15cac <_table_alphanum+0x5a>
   15c6a:	6e 3b       	cpi	r22, 0xBE	; 190
   15c6c:	99 f0       	breq	.+38     	; 0x15c94 <_table_alphanum+0x42>
   15c6e:	6b 3d       	cpi	r22, 0xDB	; 219
   15c70:	f9 f4       	brne	.+62     	; 0x15cb0 <_table_alphanum+0x5e>
   15c72:	1a c0       	rjmp	.+52     	; 0x15ca8 <_table_alphanum+0x56>
   15c74:	6b 3e       	cpi	r22, 0xEB	; 235
   15c76:	b1 f0       	breq	.+44     	; 0x15ca4 <_table_alphanum+0x52>
   15c78:	6c 3e       	cpi	r22, 0xEC	; 236
   15c7a:	18 f4       	brcc	.+6      	; 0x15c82 <_table_alphanum+0x30>
   15c7c:	6e 3d       	cpi	r22, 0xDE	; 222
   15c7e:	c1 f4       	brne	.+48     	; 0x15cb0 <_table_alphanum+0x5e>
   15c80:	05 c0       	rjmp	.+10     	; 0x15c8c <_table_alphanum+0x3a>
   15c82:	6d 3e       	cpi	r22, 0xED	; 237
   15c84:	49 f0       	breq	.+18     	; 0x15c98 <_table_alphanum+0x46>
   15c86:	6e 3e       	cpi	r22, 0xEE	; 238
   15c88:	99 f4       	brne	.+38     	; 0x15cb0 <_table_alphanum+0x5e>
   15c8a:	02 c0       	rjmp	.+4      	; 0x15c90 <_table_alphanum+0x3e>
   15c8c:	82 e0       	ldi	r24, 0x02	; 2
   15c8e:	11 c0       	rjmp	.+34     	; 0x15cb2 <_table_alphanum+0x60>
   15c90:	81 e0       	ldi	r24, 0x01	; 1
   15c92:	0f c0       	rjmp	.+30     	; 0x15cb2 <_table_alphanum+0x60>
   15c94:	83 e0       	ldi	r24, 0x03	; 3
   15c96:	0d c0       	rjmp	.+26     	; 0x15cb2 <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   15c98:	84 e0       	ldi	r24, 0x04	; 4
   15c9a:	0b c0       	rjmp	.+22     	; 0x15cb2 <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   15c9c:	85 e0       	ldi	r24, 0x05	; 5
   15c9e:	09 c0       	rjmp	.+18     	; 0x15cb2 <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   15ca0:	86 e0       	ldi	r24, 0x06	; 6
   15ca2:	07 c0       	rjmp	.+14     	; 0x15cb2 <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   15ca4:	87 e0       	ldi	r24, 0x07	; 7
   15ca6:	05 c0       	rjmp	.+10     	; 0x15cb2 <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   15ca8:	88 e0       	ldi	r24, 0x08	; 8
   15caa:	03 c0       	rjmp	.+6      	; 0x15cb2 <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   15cac:	89 e0       	ldi	r24, 0x09	; 9
   15cae:	01 c0       	rjmp	.+2      	; 0x15cb2 <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   15cb0:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   15cb2:	28 2f       	mov	r18, r24
   15cb4:	30 e0       	ldi	r19, 0x00	; 0
   15cb6:	f9 01       	movw	r30, r18
   15cb8:	e1 53       	subi	r30, 0x31	; 49
   15cba:	fc 4d       	sbci	r31, 0xDC	; 220
   15cbc:	e4 91       	lpm	r30, Z+
   15cbe:	e4 17       	cp	r30, r20
   15cc0:	10 f4       	brcc	.+4      	; 0x15cc6 <_table_alphanum+0x74>
   15cc2:	80 e0       	ldi	r24, 0x00	; 0
   15cc4:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   15cc6:	ec e3       	ldi	r30, 0x3C	; 60
   15cc8:	9e 9f       	mul	r25, r30
   15cca:	f0 01       	movw	r30, r0
   15ccc:	11 24       	eor	r1, r1
   15cce:	e4 0f       	add	r30, r20
   15cd0:	f1 1d       	adc	r31, r1
   15cd2:	c9 01       	movw	r24, r18
   15cd4:	88 0f       	add	r24, r24
   15cd6:	99 1f       	adc	r25, r25
   15cd8:	82 0f       	add	r24, r18
   15cda:	93 1f       	adc	r25, r19
   15cdc:	88 0f       	add	r24, r24
   15cde:	99 1f       	adc	r25, r25
   15ce0:	e8 0f       	add	r30, r24
   15ce2:	f9 1f       	adc	r31, r25
   15ce4:	e9 5a       	subi	r30, 0xA9	; 169
   15ce6:	fc 4d       	sbci	r31, 0xDC	; 220
   15ce8:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   15cea:	08 95       	ret

00015cec <_key_scan>:
		if((_COUNTSHIFT & (__chr_count < __max_string)))
			_SHIFT_RST;
	}
}

char _key_scan(char __select){
   15cec:	8f 92       	push	r8
   15cee:	9f 92       	push	r9
   15cf0:	af 92       	push	r10
   15cf2:	bf 92       	push	r11
   15cf4:	cf 92       	push	r12
   15cf6:	df 92       	push	r13
   15cf8:	ef 92       	push	r14
   15cfa:	ff 92       	push	r15
   15cfc:	0f 93       	push	r16
   15cfe:	1f 93       	push	r17
   15d00:	df 93       	push	r29
   15d02:	cf 93       	push	r28
   15d04:	00 d0       	rcall	.+0      	; 0x15d06 <_key_scan+0x1a>
   15d06:	00 d0       	rcall	.+0      	; 0x15d08 <_key_scan+0x1c>
   15d08:	cd b7       	in	r28, 0x3d	; 61
   15d0a:	de b7       	in	r29, 0x3e	; 62
   15d0c:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   15d0e:	81 50       	subi	r24, 0x01	; 1
   15d10:	82 30       	cpi	r24, 0x02	; 2
   15d12:	08 f0       	brcs	.+2      	; 0x15d16 <_key_scan+0x2a>
   15d14:	aa c0       	rjmp	.+340    	; 0x15e6a <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15d16:	8f ee       	ldi	r24, 0xEF	; 239
   15d18:	89 83       	std	Y+1, r24	; 0x01
   15d1a:	8f ed       	ldi	r24, 0xDF	; 223
   15d1c:	8a 83       	std	Y+2, r24	; 0x02
   15d1e:	8f eb       	ldi	r24, 0xBF	; 191
   15d20:	8b 83       	std	Y+3, r24	; 0x03
   15d22:	8f e7       	ldi	r24, 0x7F	; 127
   15d24:	8c 83       	std	Y+4, r24	; 0x04
   15d26:	de 01       	movw	r26, r28
   15d28:	11 96       	adiw	r26, 0x01	; 1
   15d2a:	2a ef       	ldi	r18, 0xFA	; 250
   15d2c:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15d2e:	ae 01       	movw	r20, r28
   15d30:	4b 5f       	subi	r20, 0xFB	; 251
   15d32:	5f 4f       	sbci	r21, 0xFF	; 255
   15d34:	c9 01       	movw	r24, r18
   15d36:	01 97       	sbiw	r24, 0x01	; 1
   15d38:	f1 f7       	brne	.-4      	; 0x15d36 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15d3a:	8c 91       	ld	r24, X
   15d3c:	80 93 62 00 	sts	0x0062, r24
   15d40:	f9 01       	movw	r30, r18
   15d42:	31 97       	sbiw	r30, 0x01	; 1
   15d44:	f1 f7       	brne	.-4      	; 0x15d42 <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15d46:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) break;
   15d48:	98 17       	cp	r25, r24
   15d4a:	21 f4       	brne	.+8      	; 0x15d54 <_key_scan+0x68>
   15d4c:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15d4e:	a4 17       	cp	r26, r20
   15d50:	b5 07       	cpc	r27, r21
   15d52:	81 f7       	brne	.-32     	; 0x15d34 <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   15d54:	89 2f       	mov	r24, r25
   15d56:	0e 94 a0 ad 	call	0x15b40	; 0x15b40 <_key_crr>
   15d5a:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   15d5c:	88 23       	and	r24, r24
   15d5e:	09 f4       	brne	.+2      	; 0x15d62 <_key_scan+0x76>
   15d60:	85 c0       	rjmp	.+266    	; 0x15e6c <_key_scan+0x180>
			_LIGHT_SET;
   15d62:	91 e0       	ldi	r25, 0x01	; 1
   15d64:	90 93 e1 03 	sts	0x03E1, r25
   15d68:	10 92 e2 03 	sts	0x03E2, r1
   15d6c:	80 91 65 00 	lds	r24, 0x0065
   15d70:	8d 7f       	andi	r24, 0xFD	; 253
   15d72:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   15d76:	80 91 bf 04 	lds	r24, 0x04BF
   15d7a:	88 23       	and	r24, r24
   15d7c:	31 f0       	breq	.+12     	; 0x15d8a <_key_scan+0x9e>
				_SEC_ON;
   15d7e:	90 93 ec 03 	sts	0x03EC, r25
   15d82:	10 92 24 04 	sts	0x0424, r1
   15d86:	10 92 ed 03 	sts	0x03ED, r1

			if(_IS1st){
   15d8a:	80 91 e8 03 	lds	r24, 0x03E8
   15d8e:	88 23       	and	r24, r24
   15d90:	71 f4       	brne	.+28     	; 0x15dae <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   15d92:	27 3e       	cpi	r18, 0xE7	; 231
   15d94:	11 f0       	breq	.+4      	; 0x15d9a <_key_scan+0xae>
   15d96:	27 3b       	cpi	r18, 0xB7	; 183
   15d98:	31 f4       	brne	.+12     	; 0x15da6 <_key_scan+0xba>
					if(__lock_num)
   15d9a:	80 91 dd 03 	lds	r24, 0x03DD
   15d9e:	88 23       	and	r24, r24
   15da0:	11 f0       	breq	.+4      	; 0x15da6 <_key_scan+0xba>
						__lock_num = 0;
   15da2:	10 92 dd 03 	sts	0x03DD, r1
				_PAD_2nd;
   15da6:	81 e0       	ldi	r24, 0x01	; 1
   15da8:	80 93 e8 03 	sts	0x03E8, r24
   15dac:	59 c0       	rjmp	.+178    	; 0x15e60 <_key_scan+0x174>
				//_spi_tx(0x24, _SPI_SLAVE, "~");
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   15dae:	81 30       	cpi	r24, 0x01	; 1
   15db0:	09 f0       	breq	.+2      	; 0x15db4 <_key_scan+0xc8>
   15db2:	5c c0       	rjmp	.+184    	; 0x15e6c <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   15db4:	12 30       	cpi	r17, 0x02	; 2
   15db6:	21 f5       	brne	.+72     	; 0x15e00 <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   15db8:	27 3d       	cpi	r18, 0xD7	; 215
   15dba:	91 f0       	breq	.+36     	; 0x15de0 <_key_scan+0xf4>
   15dbc:	2e 3e       	cpi	r18, 0xEE	; 238
   15dbe:	81 f0       	breq	.+32     	; 0x15de0 <_key_scan+0xf4>
   15dc0:	2e 3d       	cpi	r18, 0xDE	; 222
   15dc2:	71 f0       	breq	.+28     	; 0x15de0 <_key_scan+0xf4>
   15dc4:	2e 3b       	cpi	r18, 0xBE	; 190
   15dc6:	61 f0       	breq	.+24     	; 0x15de0 <_key_scan+0xf4>
   15dc8:	2d 3e       	cpi	r18, 0xED	; 237
   15dca:	51 f0       	breq	.+20     	; 0x15de0 <_key_scan+0xf4>
   15dcc:	2d 3d       	cpi	r18, 0xDD	; 221
   15dce:	41 f0       	breq	.+16     	; 0x15de0 <_key_scan+0xf4>
   15dd0:	2d 3b       	cpi	r18, 0xBD	; 189
   15dd2:	31 f0       	breq	.+12     	; 0x15de0 <_key_scan+0xf4>
   15dd4:	2b 3e       	cpi	r18, 0xEB	; 235
   15dd6:	21 f0       	breq	.+8      	; 0x15de0 <_key_scan+0xf4>
   15dd8:	2b 3d       	cpi	r18, 0xDB	; 219
   15dda:	11 f0       	breq	.+4      	; 0x15de0 <_key_scan+0xf4>
   15ddc:	2b 3b       	cpi	r18, 0xBB	; 187
   15dde:	81 f4       	brne	.+32     	; 0x15e00 <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   15de0:	80 91 dd 03 	lds	r24, 0x03DD
   15de4:	88 23       	and	r24, r24
   15de6:	49 f0       	breq	.+18     	; 0x15dfa <_key_scan+0x10e>
							_SHIFT_SET;
   15de8:	81 e0       	ldi	r24, 0x01	; 1
   15dea:	80 93 de 03 	sts	0x03DE, r24
   15dee:	10 92 df 03 	sts	0x03DF, r1
							CURSOR_HIDE;
   15df2:	8c e0       	ldi	r24, 0x0C	; 12
   15df4:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   15df8:	03 c0       	rjmp	.+6      	; 0x15e00 <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   15dfa:	81 e0       	ldi	r24, 0x01	; 1
   15dfc:	80 93 dd 03 	sts	0x03DD, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e00:	ff ee       	ldi	r31, 0xEF	; 239
   15e02:	8f 2e       	mov	r8, r31
   15e04:	ef ed       	ldi	r30, 0xDF	; 223
   15e06:	9e 2e       	mov	r9, r30
   15e08:	7f eb       	ldi	r23, 0xBF	; 191
   15e0a:	a7 2e       	mov	r10, r23
   15e0c:	6f e7       	ldi	r22, 0x7F	; 127
   15e0e:	b6 2e       	mov	r11, r22
   15e10:	6e 01       	movw	r12, r28
   15e12:	08 94       	sec
   15e14:	c1 1c       	adc	r12, r1
   15e16:	d1 1c       	adc	r13, r1
   15e18:	0a ef       	ldi	r16, 0xFA	; 250
   15e1a:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   15e1c:	55 e0       	ldi	r21, 0x05	; 5
   15e1e:	e5 2e       	mov	r14, r21
   15e20:	f1 2c       	mov	r15, r1
   15e22:	ec 0e       	add	r14, r28
   15e24:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e26:	89 82       	std	Y+1, r8	; 0x01
   15e28:	9a 82       	std	Y+2, r9	; 0x02
   15e2a:	ab 82       	std	Y+3, r10	; 0x03
   15e2c:	bc 82       	std	Y+4, r11	; 0x04
   15e2e:	d6 01       	movw	r26, r12
   15e30:	c8 01       	movw	r24, r16
   15e32:	01 97       	sbiw	r24, 0x01	; 1
   15e34:	f1 f7       	brne	.-4      	; 0x15e32 <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15e36:	8c 91       	ld	r24, X
   15e38:	80 93 62 00 	sts	0x0062, r24
   15e3c:	f8 01       	movw	r30, r16
   15e3e:	31 97       	sbiw	r30, 0x01	; 1
   15e40:	f1 f7       	brne	.-4      	; 0x15e3e <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15e42:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) break;
   15e44:	98 17       	cp	r25, r24
   15e46:	21 f4       	brne	.+8      	; 0x15e50 <_key_scan+0x164>
   15e48:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15e4a:	ae 15       	cp	r26, r14
   15e4c:	bf 05       	cpc	r27, r15
   15e4e:	81 f7       	brne	.-32     	; 0x15e30 <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   15e50:	89 2f       	mov	r24, r25
   15e52:	0e 94 a0 ad 	call	0x15b40	; 0x15b40 <_key_crr>
   15e56:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   15e58:	88 23       	and	r24, r24
   15e5a:	29 f7       	brne	.-54     	; 0x15e26 <_key_scan+0x13a>
				_PAD_1st;
   15e5c:	10 92 e8 03 	sts	0x03E8, r1
   15e60:	82 ee       	ldi	r24, 0xE2	; 226
   15e62:	94 e0       	ldi	r25, 0x04	; 4
   15e64:	01 97       	sbiw	r24, 0x01	; 1
   15e66:	f1 f7       	brne	.-4      	; 0x15e64 <_key_scan+0x178>
   15e68:	03 c0       	rjmp	.+6      	; 0x15e70 <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   15e6a:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   15e6c:	10 92 e8 03 	sts	0x03E8, r1
	return __key;
}
   15e70:	82 2f       	mov	r24, r18
   15e72:	0f 90       	pop	r0
   15e74:	0f 90       	pop	r0
   15e76:	0f 90       	pop	r0
   15e78:	0f 90       	pop	r0
   15e7a:	cf 91       	pop	r28
   15e7c:	df 91       	pop	r29
   15e7e:	1f 91       	pop	r17
   15e80:	0f 91       	pop	r16
   15e82:	ff 90       	pop	r15
   15e84:	ef 90       	pop	r14
   15e86:	df 90       	pop	r13
   15e88:	cf 90       	pop	r12
   15e8a:	bf 90       	pop	r11
   15e8c:	af 90       	pop	r10
   15e8e:	9f 90       	pop	r9
   15e90:	8f 90       	pop	r8
   15e92:	08 95       	ret

00015e94 <_key_string>:
	else __retchar = '\0';

	return __retchar;
}

char _key_string(char __mode){
   15e94:	ef 92       	push	r14
   15e96:	ff 92       	push	r15
   15e98:	0f 93       	push	r16
   15e9a:	1f 93       	push	r17
   15e9c:	cf 93       	push	r28
   15e9e:	df 93       	push	r29
	unsigned char	 __chr = 0, __i = 0;
	uint8_t  __key = 0;

	if(__mode==0){
   15ea0:	88 23       	and	r24, r24
   15ea2:	09 f0       	breq	.+2      	; 0x15ea6 <_key_string+0x12>
   15ea4:	56 c0       	rjmp	.+172    	; 0x15f52 <_key_string+0xbe>
		CURSOR_SHOW;
   15ea6:	8f e0       	ldi	r24, 0x0F	; 15
   15ea8:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
		while(1){
			__key = _key_scan(_PAD_SINGLE);
   15eac:	81 e0       	ldi	r24, 0x01	; 1
   15eae:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   15eb2:	e8 2e       	mov	r14, r24
			if(__key==_KEY_NULL || __key==_KEY_TIKET || __key==_KEY_MENU || __key==_KEY_SHIFT);
   15eb4:	88 23       	and	r24, r24
   15eb6:	d1 f3       	breq	.-12     	; 0x15eac <_key_string+0x18>
   15eb8:	8e e7       	ldi	r24, 0x7E	; 126
   15eba:	e8 16       	cp	r14, r24
   15ebc:	b9 f3       	breq	.-18     	; 0x15eac <_key_string+0x18>
   15ebe:	9d e7       	ldi	r25, 0x7D	; 125
   15ec0:	e9 16       	cp	r14, r25
   15ec2:	a1 f3       	breq	.-24     	; 0x15eac <_key_string+0x18>
   15ec4:	eb e7       	ldi	r30, 0x7B	; 123
   15ec6:	ee 16       	cp	r14, r30
   15ec8:	89 f3       	breq	.-30     	; 0x15eac <_key_string+0x18>
			else if(__key==_KEY_CANCEL){
   15eca:	f7 ee       	ldi	r31, 0xE7	; 231
   15ecc:	ef 16       	cp	r14, r31
   15ece:	19 f4       	brne	.+6      	; 0x15ed6 <_key_string+0x42>
				__chr_count = 0;
   15ed0:	10 92 da 03 	sts	0x03DA, r1
   15ed4:	50 c0       	rjmp	.+160    	; 0x15f76 <_key_string+0xe2>
				CURSOR_HIDE;
				_SHIFT_OFF;//
				return 1;
			}
			else if(__key==_KEY_ENTER){
   15ed6:	87 eb       	ldi	r24, 0xB7	; 183
   15ed8:	e8 16       	cp	r14, r24
   15eda:	19 f4       	brne	.+6      	; 0x15ee2 <_key_string+0x4e>
				__chr_count = 0;
   15edc:	10 92 da 03 	sts	0x03DA, r1
   15ee0:	52 c0       	rjmp	.+164    	; 0x15f86 <_key_string+0xf2>
   15ee2:	90 91 da 03 	lds	r25, 0x03DA
				CURSOR_HIDE;
				_SHIFT_OFF;//
				return 0;
			}
			else if(__key==_KEY_CLEAR){
   15ee6:	e7 e7       	ldi	r30, 0x77	; 119
   15ee8:	ee 16       	cp	r14, r30
   15eea:	b1 f4       	brne	.+44     	; 0x15f18 <_key_string+0x84>
				if(__chr_count>0){
   15eec:	99 23       	and	r25, r25
   15eee:	f1 f2       	breq	.-68     	; 0x15eac <_key_string+0x18>
					_LCD_LEFT;
   15ef0:	80 e1       	ldi	r24, 0x10	; 16
   15ef2:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
					_lcd(0x10);
   15ef6:	80 e1       	ldi	r24, 0x10	; 16
   15ef8:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
					_LCD_LEFT;
   15efc:	80 e1       	ldi	r24, 0x10	; 16
   15efe:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
					__buf_string[__chr_count-1] = '\0';
   15f02:	80 91 da 03 	lds	r24, 0x03DA
   15f06:	e8 2f       	mov	r30, r24
   15f08:	f0 e0       	ldi	r31, 0x00	; 0
   15f0a:	e8 54       	subi	r30, 0x48	; 72
   15f0c:	f1 4f       	sbci	r31, 0xF1	; 241
   15f0e:	10 82       	st	Z, r1
					__chr_count--;
   15f10:	81 50       	subi	r24, 0x01	; 1
   15f12:	80 93 da 03 	sts	0x03DA, r24
   15f16:	ca cf       	rjmp	.-108    	; 0x15eac <_key_string+0x18>
				}
			}
			else{
				if(__chr_count<__max_string){
   15f18:	80 91 db 03 	lds	r24, 0x03DB
   15f1c:	98 17       	cp	r25, r24
   15f1e:	30 f6       	brcc	.-116    	; 0x15eac <_key_string+0x18>
					_lcd(_table_alphanum(0, __key, 0));
   15f20:	80 e0       	ldi	r24, 0x00	; 0
   15f22:	6e 2d       	mov	r22, r14
   15f24:	40 e0       	ldi	r20, 0x00	; 0
   15f26:	0e 94 29 ae 	call	0x15c52	; 0x15c52 <_table_alphanum>
   15f2a:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
					__buf_string[__chr_count] = _table_alphanum(0, __key, 0);
   15f2e:	f0 90 da 03 	lds	r15, 0x03DA
   15f32:	0f 2d       	mov	r16, r15
   15f34:	10 e0       	ldi	r17, 0x00	; 0
   15f36:	80 e0       	ldi	r24, 0x00	; 0
   15f38:	6e 2d       	mov	r22, r14
   15f3a:	40 e0       	ldi	r20, 0x00	; 0
   15f3c:	0e 94 29 ae 	call	0x15c52	; 0x15c52 <_table_alphanum>
   15f40:	07 54       	subi	r16, 0x47	; 71
   15f42:	11 4f       	sbci	r17, 0xF1	; 241
   15f44:	f8 01       	movw	r30, r16
   15f46:	80 83       	st	Z, r24
					__buf_string[__chr_count + 1] = '\0';
   15f48:	11 82       	std	Z+1, r1	; 0x01
					__chr_count++;
   15f4a:	f3 94       	inc	r15
   15f4c:	f0 92 da 03 	sts	0x03DA, r15
   15f50:	ad cf       	rjmp	.-166    	; 0x15eac <_key_string+0x18>
				}
			}
		}
	}
	if(__mode==_STRING_ALPHANUM){
   15f52:	81 30       	cpi	r24, 0x01	; 1
   15f54:	09 f0       	breq	.+2      	; 0x15f58 <_key_string+0xc4>
   15f56:	a0 c0       	rjmp	.+320    	; 0x16098 <_key_string+0x204>
		while(1){
		   CURSOR_SHOW; 
   15f58:	8f e0       	ldi	r24, 0x0F	; 15
   15f5a:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
			__key = _key_scan(_PAD_MULTI);
   15f5e:	82 e0       	ldi	r24, 0x02	; 2
   15f60:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   15f64:	08 2f       	mov	r16, r24
			if(__key == _KEY_NULL || __key == _KEY_TIKET || __key == _KEY_MENU);
   15f66:	88 23       	and	r24, r24
   15f68:	b9 f3       	breq	.-18     	; 0x15f58 <_key_string+0xc4>
   15f6a:	8e 37       	cpi	r24, 0x7E	; 126
   15f6c:	a9 f3       	breq	.-22     	; 0x15f58 <_key_string+0xc4>
   15f6e:	8d 37       	cpi	r24, 0x7D	; 125
   15f70:	99 f3       	breq	.-26     	; 0x15f58 <_key_string+0xc4>
			else if(__key == _KEY_CANCEL){
   15f72:	87 3e       	cpi	r24, 0xE7	; 231
   15f74:	31 f4       	brne	.+12     	; 0x15f82 <_key_string+0xee>
				CURSOR_HIDE;
   15f76:	8c e0       	ldi	r24, 0x0C	; 12
   15f78:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
				_SHIFT_OFF;
   15f7c:	10 92 de 03 	sts	0x03DE, r1
   15f80:	fe c0       	rjmp	.+508    	; 0x1617e <_key_string+0x2ea>
				return 1;
			}
			else if(__key == _KEY_ENTER){
   15f82:	87 3b       	cpi	r24, 0xB7	; 183
   15f84:	31 f4       	brne	.+12     	; 0x15f92 <_key_string+0xfe>
				CURSOR_HIDE;
   15f86:	8c e0       	ldi	r24, 0x0C	; 12
   15f88:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
				_SHIFT_OFF;
   15f8c:	10 92 de 03 	sts	0x03DE, r1
   15f90:	39 c1       	rjmp	.+626    	; 0x16204 <_key_string+0x370>
				return 0;
			}
			else if(__key == _KEY_SHIFT){
   15f92:	8b 37       	cpi	r24, 0x7B	; 123
   15f94:	39 f4       	brne	.+14     	; 0x15fa4 <_key_string+0x110>
				__caps_lock = __caps_lock ^ 1;
   15f96:	80 91 dc 03 	lds	r24, 0x03DC
   15f9a:	91 e0       	ldi	r25, 0x01	; 1
   15f9c:	89 27       	eor	r24, r25
   15f9e:	80 93 dc 03 	sts	0x03DC, r24
   15fa2:	da cf       	rjmp	.-76     	; 0x15f58 <_key_string+0xc4>
   15fa4:	90 91 da 03 	lds	r25, 0x03DA
			}
			else if(__key == _KEY_CLEAR){
   15fa8:	87 37       	cpi	r24, 0x77	; 119
   15faa:	39 f5       	brne	.+78     	; 0x15ffa <_key_string+0x166>
				if(__chr_count > 0){
   15fac:	99 23       	and	r25, r25
   15fae:	a1 f2       	breq	.-88     	; 0x15f58 <_key_string+0xc4>
				if(!__key_shift){
   15fb0:	80 91 de 03 	lds	r24, 0x03DE
   15fb4:	88 23       	and	r24, r24
   15fb6:	81 f6       	brne	.-96     	; 0x15f58 <_key_string+0xc4>
					_LCD_LEFT;
   15fb8:	80 e1       	ldi	r24, 0x10	; 16
   15fba:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
					_lcd(0x10);
   15fbe:	80 e1       	ldi	r24, 0x10	; 16
   15fc0:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
					_LCD_LEFT;
   15fc4:	80 e1       	ldi	r24, 0x10	; 16
   15fc6:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
					__buf_string[__chr_count - 1] = '\0';
   15fca:	80 91 da 03 	lds	r24, 0x03DA
   15fce:	e8 2f       	mov	r30, r24
   15fd0:	f0 e0       	ldi	r31, 0x00	; 0
   15fd2:	e8 54       	subi	r30, 0x48	; 72
   15fd4:	f1 4f       	sbci	r31, 0xF1	; 241
   15fd6:	10 82       	st	Z, r1
					__chr_count--;
   15fd8:	81 50       	subi	r24, 0x01	; 1
   15fda:	80 93 da 03 	sts	0x03DA, r24
					if(__chr_count == 19){
   15fde:	83 31       	cpi	r24, 0x13	; 19
   15fe0:	49 f4       	brne	.+18     	; 0x15ff4 <_key_string+0x160>
						lcd_put(2, 20, 0x10);
   15fe2:	82 e0       	ldi	r24, 0x02	; 2
   15fe4:	64 e1       	ldi	r22, 0x14	; 20
   15fe6:	40 e1       	ldi	r20, 0x10	; 16
   15fe8:	0e 94 35 ad 	call	0x15a6a	; 0x15a6a <lcd_put>
						lcd_xy(2, 20);
   15fec:	82 e0       	ldi	r24, 0x02	; 2
   15fee:	64 e1       	ldi	r22, 0x14	; 20
   15ff0:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
					}
					_SHIFT_OFF;
   15ff4:	10 92 de 03 	sts	0x03DE, r1
   15ff8:	4b c0       	rjmp	.+150    	; 0x16090 <_key_string+0x1fc>
					//_SHIFT_FREE;
				}
				}
			}
			else{
				if(__chr_count < __max_string){
   15ffa:	80 91 db 03 	lds	r24, 0x03DB
   15ffe:	98 17       	cp	r25, r24
   16000:	08 f0       	brcs	.+2      	; 0x16004 <_key_string+0x170>
   16002:	46 c0       	rjmp	.+140    	; 0x16090 <_key_string+0x1fc>
					if(__key != __buf_anum){
   16004:	80 91 d8 03 	lds	r24, 0x03D8
   16008:	08 17       	cp	r16, r24
   1600a:	b9 f0       	breq	.+46     	; 0x1603a <_key_string+0x1a6>
						__buf_anum = __key;
   1600c:	00 93 d8 03 	sts	0x03D8, r16
						__hit_count = 0;
   16010:	10 92 d9 03 	sts	0x03D9, r1
						if(__key_shift == 1 && __buf_anum != 0){
   16014:	80 91 de 03 	lds	r24, 0x03DE
   16018:	81 30       	cpi	r24, 0x01	; 1
   1601a:	a1 f4       	brne	.+40     	; 0x16044 <_key_string+0x1b0>
							_LCD_RIGHT;
   1601c:	84 e1       	ldi	r24, 0x14	; 20
   1601e:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
							__chr_count++;
   16022:	80 91 da 03 	lds	r24, 0x03DA
   16026:	8f 5f       	subi	r24, 0xFF	; 255
   16028:	80 93 da 03 	sts	0x03DA, r24
							if(__chr_count == 20)
   1602c:	84 31       	cpi	r24, 0x14	; 20
   1602e:	51 f4       	brne	.+20     	; 0x16044 <_key_string+0x1b0>
								lcd_xy(3, 1);
   16030:	83 e0       	ldi	r24, 0x03	; 3
   16032:	61 e0       	ldi	r22, 0x01	; 1
   16034:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   16038:	05 c0       	rjmp	.+10     	; 0x16044 <_key_string+0x1b0>
						}
					}
					else{
						__hit_count++;
   1603a:	80 91 d9 03 	lds	r24, 0x03D9
   1603e:	8f 5f       	subi	r24, 0xFF	; 255
   16040:	80 93 d9 03 	sts	0x03D9, r24
					}
					__chr = _table_alphanum(__caps_lock, __key, __hit_count);
   16044:	e0 90 dc 03 	lds	r14, 0x03DC
   16048:	8e 2d       	mov	r24, r14
   1604a:	60 2f       	mov	r22, r16
   1604c:	40 91 d9 03 	lds	r20, 0x03D9
   16050:	0e 94 29 ae 	call	0x15c52	; 0x15c52 <_table_alphanum>
   16054:	f8 2e       	mov	r15, r24
					if(__chr == '\0'){
   16056:	88 23       	and	r24, r24
   16058:	41 f4       	brne	.+16     	; 0x1606a <_key_string+0x1d6>
						__hit_count = 0;
   1605a:	10 92 d9 03 	sts	0x03D9, r1
						__chr = _table_alphanum(__caps_lock, __key, __hit_count);
   1605e:	8e 2d       	mov	r24, r14
   16060:	60 2f       	mov	r22, r16
   16062:	40 e0       	ldi	r20, 0x00	; 0
   16064:	0e 94 29 ae 	call	0x15c52	; 0x15c52 <_table_alphanum>
   16068:	f8 2e       	mov	r15, r24
					}
					if(__chr_count < __max_string){
   1606a:	90 91 da 03 	lds	r25, 0x03DA
   1606e:	80 91 db 03 	lds	r24, 0x03DB
   16072:	98 17       	cp	r25, r24
   16074:	68 f4       	brcc	.+26     	; 0x16090 <_key_string+0x1fc>
						_lcd(__chr);
   16076:	8f 2d       	mov	r24, r15
   16078:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
						_LCD_LEFT;
   1607c:	80 e1       	ldi	r24, 0x10	; 16
   1607e:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
						__buf_string[__chr_count] = __chr;
   16082:	e0 91 da 03 	lds	r30, 0x03DA
   16086:	f0 e0       	ldi	r31, 0x00	; 0
   16088:	e7 54       	subi	r30, 0x47	; 71
   1608a:	f1 4f       	sbci	r31, 0xF1	; 241
   1608c:	f0 82       	st	Z, r15
						__buf_string[__chr_count + 1] = '\0';
   1608e:	11 82       	std	Z+1, r1	; 0x01
					}
				}
				CURSOR_SHOW;
   16090:	8f e0       	ldi	r24, 0x0F	; 15
   16092:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   16096:	60 cf       	rjmp	.-320    	; 0x15f58 <_key_string+0xc4>
				//else _SHIFT_LOCK;
			}
		}
	}
	if(__mode==_STRING_PASSWORD){
   16098:	82 30       	cpi	r24, 0x02	; 2
   1609a:	09 f0       	breq	.+2      	; 0x1609e <_key_string+0x20a>
   1609c:	4e c0       	rjmp	.+156    	; 0x1613a <_key_string+0x2a6>
		CURSOR_SHOW;
   1609e:	8f e0       	ldi	r24, 0x0F	; 15
   160a0:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
		while(1){
			__key = _key_scan(_PAD_SINGLE);
   160a4:	81 e0       	ldi	r24, 0x01	; 1
   160a6:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   160aa:	e8 2e       	mov	r14, r24
			if(__key==_KEY_NULL || __key==_KEY_TIKET || __key==_KEY_MENU || __key==_KEY_SHIFT);
   160ac:	88 23       	and	r24, r24
   160ae:	d1 f3       	breq	.-12     	; 0x160a4 <_key_string+0x210>
   160b0:	fe e7       	ldi	r31, 0x7E	; 126
   160b2:	8f 17       	cp	r24, r31
   160b4:	b9 f3       	breq	.-18     	; 0x160a4 <_key_string+0x210>
   160b6:	8d e7       	ldi	r24, 0x7D	; 125
   160b8:	e8 16       	cp	r14, r24
   160ba:	a1 f3       	breq	.-24     	; 0x160a4 <_key_string+0x210>
   160bc:	9b e7       	ldi	r25, 0x7B	; 123
   160be:	e9 16       	cp	r14, r25
   160c0:	89 f3       	breq	.-30     	; 0x160a4 <_key_string+0x210>
			else if(__key==_KEY_CANCEL){
   160c2:	e7 ee       	ldi	r30, 0xE7	; 231
   160c4:	ee 16       	cp	r14, r30
   160c6:	09 f4       	brne	.+2      	; 0x160ca <_key_string+0x236>
   160c8:	55 c0       	rjmp	.+170    	; 0x16174 <_key_string+0x2e0>
				__chr_count = 0;
				CURSOR_HIDE;
				return 1;
			}
			else if(__key==_KEY_ENTER){
   160ca:	f7 eb       	ldi	r31, 0xB7	; 183
   160cc:	ef 16       	cp	r14, r31
   160ce:	09 f4       	brne	.+2      	; 0x160d2 <_key_string+0x23e>
   160d0:	62 c0       	rjmp	.+196    	; 0x16196 <_key_string+0x302>
   160d2:	90 91 da 03 	lds	r25, 0x03DA
				__chr_count = 0;
				CURSOR_HIDE;
				return 0;
			}
			else if(__key==_KEY_CLEAR){
   160d6:	87 e7       	ldi	r24, 0x77	; 119
   160d8:	e8 16       	cp	r14, r24
   160da:	b1 f4       	brne	.+44     	; 0x16108 <_key_string+0x274>
				if(__chr_count>0){
   160dc:	99 23       	and	r25, r25
   160de:	11 f3       	breq	.-60     	; 0x160a4 <_key_string+0x210>
					_LCD_LEFT;
   160e0:	80 e1       	ldi	r24, 0x10	; 16
   160e2:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
					_lcd(0x10);
   160e6:	80 e1       	ldi	r24, 0x10	; 16
   160e8:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
					_LCD_LEFT;
   160ec:	80 e1       	ldi	r24, 0x10	; 16
   160ee:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
					__buf_string[__chr_count-1] = '\0';
   160f2:	80 91 da 03 	lds	r24, 0x03DA
   160f6:	e8 2f       	mov	r30, r24
   160f8:	f0 e0       	ldi	r31, 0x00	; 0
   160fa:	e8 54       	subi	r30, 0x48	; 72
   160fc:	f1 4f       	sbci	r31, 0xF1	; 241
   160fe:	10 82       	st	Z, r1
					__chr_count--;
   16100:	81 50       	subi	r24, 0x01	; 1
   16102:	80 93 da 03 	sts	0x03DA, r24
   16106:	ce cf       	rjmp	.-100    	; 0x160a4 <_key_string+0x210>
				}
			}
			else{
				if(__chr_count<__max_string){
   16108:	80 91 db 03 	lds	r24, 0x03DB
   1610c:	98 17       	cp	r25, r24
   1610e:	50 f6       	brcc	.-108    	; 0x160a4 <_key_string+0x210>
					_lcd(0x2a);
   16110:	8a e2       	ldi	r24, 0x2A	; 42
   16112:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
					__buf_string[__chr_count] = _table_alphanum(0, __key, 0);
   16116:	f0 90 da 03 	lds	r15, 0x03DA
   1611a:	0f 2d       	mov	r16, r15
   1611c:	10 e0       	ldi	r17, 0x00	; 0
   1611e:	80 e0       	ldi	r24, 0x00	; 0
   16120:	6e 2d       	mov	r22, r14
   16122:	40 e0       	ldi	r20, 0x00	; 0
   16124:	0e 94 29 ae 	call	0x15c52	; 0x15c52 <_table_alphanum>
   16128:	07 54       	subi	r16, 0x47	; 71
   1612a:	11 4f       	sbci	r17, 0xF1	; 241
   1612c:	f8 01       	movw	r30, r16
   1612e:	80 83       	st	Z, r24
					__buf_string[__chr_count + 1] = '\0';
   16130:	11 82       	std	Z+1, r1	; 0x01
					__chr_count++;
   16132:	f3 94       	inc	r15
   16134:	f0 92 da 03 	sts	0x03DA, r15
   16138:	b5 cf       	rjmp	.-150    	; 0x160a4 <_key_string+0x210>
				}
			}
		}
	}
	if(__mode==_STRING_VALUE){
   1613a:	83 30       	cpi	r24, 0x03	; 3
   1613c:	09 f0       	breq	.+2      	; 0x16140 <_key_string+0x2ac>
   1613e:	62 c0       	rjmp	.+196    	; 0x16204 <_key_string+0x370>
   16140:	00 e0       	ldi	r16, 0x00	; 0
   16142:	04 c0       	rjmp	.+8      	; 0x1614c <_key_string+0x2b8>
		for(__i=0; __i<__max_string; __i++)
			_lcd('0');
   16144:	80 e3       	ldi	r24, 0x30	; 48
   16146:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
				}
			}
		}
	}
	if(__mode==_STRING_VALUE){
		for(__i=0; __i<__max_string; __i++)
   1614a:	0f 5f       	subi	r16, 0xFF	; 255
   1614c:	80 91 db 03 	lds	r24, 0x03DB
   16150:	08 17       	cp	r16, r24
   16152:	c0 f3       	brcs	.-16     	; 0x16144 <_key_string+0x2b0>
			_lcd('0');
		while(1){
			__key = _key_scan(_PAD_SINGLE);
   16154:	81 e0       	ldi	r24, 0x01	; 1
   16156:	0e 94 76 ae 	call	0x15cec	; 0x15cec <_key_scan>
   1615a:	68 2f       	mov	r22, r24
			if(__key==_KEY_NULL || __key==_KEY_TIKET || __key==_KEY_MENU || __key==_KEY_SHIFT || __key==_KEY_CLEAR);
   1615c:	88 23       	and	r24, r24
   1615e:	d1 f3       	breq	.-12     	; 0x16154 <_key_string+0x2c0>
   16160:	8e 37       	cpi	r24, 0x7E	; 126
   16162:	c1 f3       	breq	.-16     	; 0x16154 <_key_string+0x2c0>
   16164:	8d 37       	cpi	r24, 0x7D	; 125
   16166:	b1 f3       	breq	.-20     	; 0x16154 <_key_string+0x2c0>
   16168:	8b 37       	cpi	r24, 0x7B	; 123
   1616a:	a1 f3       	breq	.-24     	; 0x16154 <_key_string+0x2c0>
   1616c:	87 37       	cpi	r24, 0x77	; 119
   1616e:	91 f3       	breq	.-28     	; 0x16154 <_key_string+0x2c0>
			else if(__key==_KEY_CANCEL){
   16170:	87 3e       	cpi	r24, 0xE7	; 231
   16172:	39 f4       	brne	.+14     	; 0x16182 <_key_string+0x2ee>
				__chr_count = 0;
   16174:	10 92 da 03 	sts	0x03DA, r1
				CURSOR_HIDE;
   16178:	8c e0       	ldi	r24, 0x0C	; 12
   1617a:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   1617e:	81 e0       	ldi	r24, 0x01	; 1
   16180:	42 c0       	rjmp	.+132    	; 0x16206 <_key_string+0x372>
				return 1;
			}
			else if(__key==_KEY_ENTER){
   16182:	87 3b       	cpi	r24, 0xB7	; 183
   16184:	41 f0       	breq	.+16     	; 0x16196 <_key_string+0x302>
				__chr_count = 0;
				CURSOR_HIDE;
				return 0;
			}
			else{
				for(__i=0; __i<__max_string - 1; __i++)
   16186:	80 91 db 03 	lds	r24, 0x03DB
   1618a:	e8 2e       	mov	r14, r24
   1618c:	ff 24       	eor	r15, r15
   1618e:	e7 01       	movw	r28, r14
   16190:	21 97       	sbiw	r28, 0x01	; 1
   16192:	90 e0       	ldi	r25, 0x00	; 0
   16194:	0b c0       	rjmp	.+22     	; 0x161ac <_key_string+0x318>
				__chr_count = 0;
				CURSOR_HIDE;
				return 1;
			}
			else if(__key==_KEY_ENTER){
				__chr_count = 0;
   16196:	10 92 da 03 	sts	0x03DA, r1
				CURSOR_HIDE;
   1619a:	8c e0       	ldi	r24, 0x0C	; 12
   1619c:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   161a0:	31 c0       	rjmp	.+98     	; 0x16204 <_key_string+0x370>
				return 0;
			}
			else{
				for(__i=0; __i<__max_string - 1; __i++)
					__buf_string[__i] = __buf_string[__i + 1];
   161a2:	e7 54       	subi	r30, 0x47	; 71
   161a4:	f1 4f       	sbci	r31, 0xF1	; 241
   161a6:	81 81       	ldd	r24, Z+1	; 0x01
   161a8:	80 83       	st	Z, r24
				__chr_count = 0;
				CURSOR_HIDE;
				return 0;
			}
			else{
				for(__i=0; __i<__max_string - 1; __i++)
   161aa:	9f 5f       	subi	r25, 0xFF	; 255
   161ac:	e9 2f       	mov	r30, r25
   161ae:	f0 e0       	ldi	r31, 0x00	; 0
   161b0:	ec 17       	cp	r30, r28
   161b2:	fd 07       	cpc	r31, r29
   161b4:	b4 f3       	brlt	.-20     	; 0x161a2 <_key_string+0x30e>
					__buf_string[__i] = __buf_string[__i + 1];
				__buf_string[__max_string - 1] = _table_alphanum(0, __key, 0);
   161b6:	80 e0       	ldi	r24, 0x00	; 0
   161b8:	40 e0       	ldi	r20, 0x00	; 0
   161ba:	0e 94 29 ae 	call	0x15c52	; 0x15c52 <_table_alphanum>
   161be:	c7 54       	subi	r28, 0x47	; 71
   161c0:	d1 4f       	sbci	r29, 0xF1	; 241
   161c2:	88 83       	st	Y, r24
				__buf_string[__max_string] = '\0';
   161c4:	89 eb       	ldi	r24, 0xB9	; 185
   161c6:	9e e0       	ldi	r25, 0x0E	; 14
   161c8:	e8 0e       	add	r14, r24
   161ca:	f9 1e       	adc	r15, r25
   161cc:	f7 01       	movw	r30, r14
   161ce:	10 82       	st	Z, r1
   161d0:	00 e0       	ldi	r16, 0x00	; 0
   161d2:	04 c0       	rjmp	.+8      	; 0x161dc <_key_string+0x348>
				for(__i=0; __i<__max_string; __i++)
					_LCD_LEFT;
   161d4:	80 e1       	ldi	r24, 0x10	; 16
   161d6:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
			else{
				for(__i=0; __i<__max_string - 1; __i++)
					__buf_string[__i] = __buf_string[__i + 1];
				__buf_string[__max_string - 1] = _table_alphanum(0, __key, 0);
				__buf_string[__max_string] = '\0';
				for(__i=0; __i<__max_string; __i++)
   161da:	0f 5f       	subi	r16, 0xFF	; 255
   161dc:	80 91 db 03 	lds	r24, 0x03DB
   161e0:	08 17       	cp	r16, r24
   161e2:	c0 f3       	brcs	.-16     	; 0x161d4 <_key_string+0x340>
   161e4:	00 e0       	ldi	r16, 0x00	; 0
   161e6:	08 c0       	rjmp	.+16     	; 0x161f8 <_key_string+0x364>
					_LCD_LEFT;
				for(__i=0; __i<__max_string; __i++)
					_lcd(__buf_string[__i]);
   161e8:	e0 2f       	mov	r30, r16
   161ea:	f0 e0       	ldi	r31, 0x00	; 0
   161ec:	e7 54       	subi	r30, 0x47	; 71
   161ee:	f1 4f       	sbci	r31, 0xF1	; 241
   161f0:	80 81       	ld	r24, Z
   161f2:	0e 94 81 ac 	call	0x15902	; 0x15902 <_lcd>
					__buf_string[__i] = __buf_string[__i + 1];
				__buf_string[__max_string - 1] = _table_alphanum(0, __key, 0);
				__buf_string[__max_string] = '\0';
				for(__i=0; __i<__max_string; __i++)
					_LCD_LEFT;
				for(__i=0; __i<__max_string; __i++)
   161f6:	0f 5f       	subi	r16, 0xFF	; 255
   161f8:	80 91 db 03 	lds	r24, 0x03DB
   161fc:	08 17       	cp	r16, r24
   161fe:	08 f0       	brcs	.+2      	; 0x16202 <_key_string+0x36e>
   16200:	a9 cf       	rjmp	.-174    	; 0x16154 <_key_string+0x2c0>
   16202:	f2 cf       	rjmp	.-28     	; 0x161e8 <_key_string+0x354>
   16204:	80 e0       	ldi	r24, 0x00	; 0
					_lcd(__buf_string[__i]);
			}
		}
	}
	return 0;
}
   16206:	df 91       	pop	r29
   16208:	cf 91       	pop	r28
   1620a:	1f 91       	pop	r17
   1620c:	0f 91       	pop	r16
   1620e:	ff 90       	pop	r15
   16210:	ef 90       	pop	r14
   16212:	08 95       	ret

00016214 <_shift_ticker>:
		   }
	}
}

void _shift_ticker(void){
	if(_ISSHIFT){
   16214:	80 91 de 03 	lds	r24, 0x03DE
   16218:	81 30       	cpi	r24, 0x01	; 1
   1621a:	29 f5       	brne	.+74     	; 0x16266 <_shift_ticker+0x52>
        _SHIFT_TICK;
   1621c:	80 91 df 03 	lds	r24, 0x03DF
   16220:	8f 5f       	subi	r24, 0xFF	; 255
   16222:	80 93 df 03 	sts	0x03DF, r24
		if((_COUNTSHIFT & (__chr_count < __max_string)))
   16226:	90 91 da 03 	lds	r25, 0x03DA
   1622a:	84 31       	cpi	r24, 0x14	; 20
   1622c:	e1 f4       	brne	.+56     	; 0x16266 <_shift_ticker+0x52>
   1622e:	80 91 db 03 	lds	r24, 0x03DB
   16232:	98 17       	cp	r25, r24
   16234:	c0 f4       	brcc	.+48     	; 0x16266 <_shift_ticker+0x52>
			_SHIFT_RST;
   16236:	10 92 de 03 	sts	0x03DE, r1
   1623a:	10 92 df 03 	sts	0x03DF, r1
   1623e:	10 92 d8 03 	sts	0x03D8, r1
   16242:	10 92 d9 03 	sts	0x03D9, r1
   16246:	89 2f       	mov	r24, r25
   16248:	8f 5f       	subi	r24, 0xFF	; 255
   1624a:	80 93 da 03 	sts	0x03DA, r24
   1624e:	84 31       	cpi	r24, 0x14	; 20
   16250:	21 f4       	brne	.+8      	; 0x1625a <_shift_ticker+0x46>
   16252:	83 e0       	ldi	r24, 0x03	; 3
   16254:	61 e0       	ldi	r22, 0x01	; 1
   16256:	0e 94 a7 ac 	call	0x1594e	; 0x1594e <lcd_xy>
   1625a:	84 e1       	ldi	r24, 0x14	; 20
   1625c:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   16260:	8f e0       	ldi	r24, 0x0F	; 15
   16262:	0e 94 14 ac 	call	0x15828	; 0x15828 <lcd_command>
   16266:	08 95       	ret

00016268 <_spi_init>:
unsigned char	__spi_i;
unsigned char	__spi_isstart = 0;
unsigned char	__spi_ismessage = 0;

void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   16268:	88 23       	and	r24, r24
   1626a:	41 f0       	breq	.+16     	; 0x1627c <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   1626c:	86 e0       	ldi	r24, 0x06	; 6
   1626e:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   16270:	66 23       	and	r22, r22
   16272:	11 f0       	breq	.+4      	; 0x16278 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   16274:	82 ed       	ldi	r24, 0xD2	; 210
   16276:	09 c0       	rjmp	.+18     	; 0x1628a <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   16278:	82 e5       	ldi	r24, 0x52	; 82
   1627a:	07 c0       	rjmp	.+14     	; 0x1628a <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   1627c:	88 e0       	ldi	r24, 0x08	; 8
   1627e:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   16280:	66 23       	and	r22, r22
   16282:	11 f0       	breq	.+4      	; 0x16288 <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   16284:	80 ec       	ldi	r24, 0xC0	; 192
   16286:	01 c0       	rjmp	.+2      	; 0x1628a <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   16288:	80 e4       	ldi	r24, 0x40	; 64
   1628a:	8d b9       	out	0x0d, r24	; 13
   1628c:	08 95       	ret

0001628e <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   1628e:	88 23       	and	r24, r24
   16290:	19 f4       	brne	.+6      	; 0x16298 <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   16292:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   16294:	1b 9a       	sbi	0x03, 3	; 3
   16296:	08 95       	ret
	}
	if(__select == 1){
   16298:	81 30       	cpi	r24, 0x01	; 1
   1629a:	39 f4       	brne	.+14     	; 0x162aa <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   1629c:	1b 9a       	sbi	0x03, 3	; 3
   1629e:	82 ee       	ldi	r24, 0xE2	; 226
   162a0:	94 e0       	ldi	r25, 0x04	; 4
   162a2:	01 97       	sbiw	r24, 0x01	; 1
   162a4:	f1 f7       	brne	.-4      	; 0x162a2 <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   162a6:	db 98       	cbi	0x1b, 3	; 27
   162a8:	08 95       	ret
	}
	if(__select == 2){
   162aa:	82 30       	cpi	r24, 0x02	; 2
   162ac:	31 f4       	brne	.+12     	; 0x162ba <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   162ae:	db 9a       	sbi	0x1b, 3	; 27
   162b0:	82 ee       	ldi	r24, 0xE2	; 226
   162b2:	94 e0       	ldi	r25, 0x04	; 4
   162b4:	01 97       	sbiw	r24, 0x01	; 1
   162b6:	f1 f7       	brne	.-4      	; 0x162b4 <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   162b8:	1b 98       	cbi	0x03, 3	; 3
   162ba:	08 95       	ret

000162bc <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   162bc:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   162be:	77 9b       	sbis	0x0e, 7	; 14
   162c0:	fe cf       	rjmp	.-4      	; 0x162be <_spi+0x2>
	return SPDR;
   162c2:	8f b1       	in	r24, 0x0f	; 15
}
   162c4:	08 95       	ret

000162c6 <_spi_rx>:


unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);
   162c6:	0e 94 47 b1 	call	0x1628e	; 0x1628e <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   162ca:	81 e4       	ldi	r24, 0x41	; 65
   162cc:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   162ce:	77 9b       	sbis	0x0e, 7	; 14
   162d0:	fe cf       	rjmp	.-4      	; 0x162ce <_spi_rx+0x8>
	return SPDR;
   162d2:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);

		__spi_char = _spi(0x41);
   162d4:	80 93 ce 0e 	sts	0x0ECE, r24
		if(__spi_char==0xff) return 0;
   162d8:	8f 3f       	cpi	r24, 0xFF	; 255
   162da:	11 f4       	brne	.+4      	; 0x162e0 <_spi_rx+0x1a>
   162dc:	80 e0       	ldi	r24, 0x00	; 0
   162de:	08 95       	ret
		if(__spi_char==0x55) return 1;
   162e0:	85 35       	cpi	r24, 0x55	; 85
   162e2:	11 f4       	brne	.+4      	; 0x162e8 <_spi_rx+0x22>
   162e4:	81 e0       	ldi	r24, 0x01	; 1
   162e6:	08 95       	ret
		if(__spi_char==0x02) return 2;
   162e8:	82 30       	cpi	r24, 0x02	; 2
   162ea:	21 f0       	breq	.+8      	; 0x162f4 <_spi_rx+0x2e>
	_spi_enable(_SPI_NONE);
   162ec:	80 e0       	ldi	r24, 0x00	; 0
   162ee:	0e 94 47 b1 	call	0x1628e	; 0x1628e <_spi_enable>
   162f2:	85 e1       	ldi	r24, 0x15	; 21
	return 21;
}
   162f4:	08 95       	ret

000162f6 <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
   162f6:	1f 93       	push	r17
   162f8:	cf 93       	push	r28
   162fa:	df 93       	push	r29
   162fc:	18 2f       	mov	r17, r24
   162fe:	86 2f       	mov	r24, r22
   16300:	ea 01       	movw	r28, r20
	_spi_enable(__select);
   16302:	0e 94 47 b1 	call	0x1628e	; 0x1628e <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16306:	8b e7       	ldi	r24, 0x7B	; 123
   16308:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1630a:	77 9b       	sbis	0x0e, 7	; 14
   1630c:	fe cf       	rjmp	.-4      	; 0x1630a <_spi_tx+0x14>
	return SPDR;
   1630e:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16310:	1f b9       	out	0x0f, r17	; 15
	while(!(SPSR & (1 << SPIF)));
   16312:	77 9b       	sbis	0x0e, 7	; 14
   16314:	fe cf       	rjmp	.-4      	; 0x16312 <_spi_tx+0x1c>
	return SPDR;
   16316:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
	_spi_enable(__select);
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
   16318:	88 81       	ld	r24, Y
   1631a:	88 23       	and	r24, r24
   1631c:	91 f0       	breq	.+36     	; 0x16342 <_spi_tx+0x4c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1631e:	88 e2       	ldi	r24, 0x28	; 40
   16320:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16322:	77 9b       	sbis	0x0e, 7	; 14
   16324:	fe cf       	rjmp	.-4      	; 0x16322 <_spi_tx+0x2c>
   16326:	04 c0       	rjmp	.+8      	; 0x16330 <_spi_tx+0x3a>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16328:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1632a:	77 9b       	sbis	0x0e, 7	; 14
   1632c:	fe cf       	rjmp	.-4      	; 0x1632a <_spi_tx+0x34>
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
			_spi(*__message++);
   1632e:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
	while(!(SPSR & (1 << SPIF)));
	return SPDR;
   16330:	8f b1       	in	r24, 0x0f	; 15
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
   16332:	88 81       	ld	r24, Y
   16334:	88 23       	and	r24, r24
   16336:	c1 f7       	brne	.-16     	; 0x16328 <_spi_tx+0x32>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16338:	89 e2       	ldi	r24, 0x29	; 41
   1633a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1633c:	77 9b       	sbis	0x0e, 7	; 14
   1633e:	fe cf       	rjmp	.-4      	; 0x1633c <_spi_tx+0x46>
	return SPDR;
   16340:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16342:	8d e7       	ldi	r24, 0x7D	; 125
   16344:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16346:	77 9b       	sbis	0x0e, 7	; 14
   16348:	fe cf       	rjmp	.-4      	; 0x16346 <_spi_tx+0x50>
	return SPDR;
   1634a:	8f b1       	in	r24, 0x0f	; 15
			_spi(*__message++);
		_spi(0x29);
	}

	_spi(0x7D);
	_spi_enable(_SPI_NONE);
   1634c:	80 e0       	ldi	r24, 0x00	; 0
   1634e:	0e 94 47 b1 	call	0x1628e	; 0x1628e <_spi_enable>
	return 0;
}
   16352:	80 e0       	ldi	r24, 0x00	; 0
   16354:	df 91       	pop	r29
   16356:	cf 91       	pop	r28
   16358:	1f 91       	pop	r17
   1635a:	08 95       	ret

0001635c <_spi_txnum>:

unsigned char _spi_txnum(unsigned char __command, unsigned char __select, char* __message, unsigned char __num){
   1635c:	ff 92       	push	r15
   1635e:	0f 93       	push	r16
   16360:	1f 93       	push	r17
   16362:	86 2f       	mov	r24, r22
   16364:	14 2f       	mov	r17, r20
   16366:	05 2f       	mov	r16, r21
   16368:	f2 2e       	mov	r15, r18
	unsigned char	__i;

	_spi_enable(__select);
   1636a:	0e 94 47 b1 	call	0x1628e	; 0x1628e <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1636e:	82 e0       	ldi	r24, 0x02	; 2
   16370:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16372:	77 9b       	sbis	0x0e, 7	; 14
   16374:	fe cf       	rjmp	.-4      	; 0x16372 <_spi_txnum+0x16>
	return SPDR;
   16376:	8f b1       	in	r24, 0x0f	; 15
	unsigned char	__i;

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
   16378:	ff 20       	and	r15, r15
   1637a:	79 f0       	breq	.+30     	; 0x1639a <_spi_txnum+0x3e>
   1637c:	81 2f       	mov	r24, r17
   1637e:	90 2f       	mov	r25, r16
   16380:	9c 01       	movw	r18, r24
   16382:	f9 01       	movw	r30, r18
   16384:	90 e0       	ldi	r25, 0x00	; 0
   16386:	07 c0       	rjmp	.+14     	; 0x16396 <_spi_txnum+0x3a>
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   16388:	80 81       	ld	r24, Z
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1638a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1638c:	77 9b       	sbis	0x0e, 7	; 14
   1638e:	fe cf       	rjmp	.-4      	; 0x1638c <_spi_txnum+0x30>
	return SPDR;
   16390:	8f b1       	in	r24, 0x0f	; 15

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   16392:	9f 5f       	subi	r25, 0xFF	; 255
   16394:	31 96       	adiw	r30, 0x01	; 1
   16396:	9f 15       	cp	r25, r15
   16398:	b8 f3       	brcs	.-18     	; 0x16388 <_spi_txnum+0x2c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1639a:	83 e0       	ldi	r24, 0x03	; 3
   1639c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1639e:	77 9b       	sbis	0x0e, 7	; 14
   163a0:	fe cf       	rjmp	.-4      	; 0x1639e <_spi_txnum+0x42>
	return SPDR;
   163a2:	8f b1       	in	r24, 0x0f	; 15
	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
				}// for

	_spi(0x03);
	_spi_enable(_SPI_NONE);
   163a4:	80 e0       	ldi	r24, 0x00	; 0
   163a6:	0e 94 47 b1 	call	0x1628e	; 0x1628e <_spi_enable>
	return 0;
}
   163aa:	80 e0       	ldi	r24, 0x00	; 0
   163ac:	1f 91       	pop	r17
   163ae:	0f 91       	pop	r16
   163b0:	ff 90       	pop	r15
   163b2:	08 95       	ret

000163b4 <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	__spi_char = SPDR;
   163b4:	9f b1       	in	r25, 0x0f	; 15
   163b6:	90 93 ce 0e 	sts	0x0ECE, r25

	if(__spi_char == 0xFF){
   163ba:	9f 3f       	cpi	r25, 0xFF	; 255
   163bc:	e9 f4       	brne	.+58     	; 0x163f8 <_spi_interrupt+0x44>
		if(__spi_istransmit){
   163be:	80 91 20 04 	lds	r24, 0x0420
   163c2:	88 23       	and	r24, r24
   163c4:	b9 f0       	breq	.+46     	; 0x163f4 <_spi_interrupt+0x40>
			SPDR = __command[__spi_i];
   163c6:	90 91 cd 0e 	lds	r25, 0x0ECD
   163ca:	e9 2f       	mov	r30, r25
   163cc:	f0 e0       	ldi	r31, 0x00	; 0
   163ce:	e2 51       	subi	r30, 0x12	; 18
   163d0:	fc 4f       	sbci	r31, 0xFC	; 252
   163d2:	80 81       	ld	r24, Z
   163d4:	8f b9       	out	0x0f, r24	; 15
			if(__command[__spi_i] == 0x7D){
   163d6:	8d 37       	cpi	r24, 0x7D	; 125
   163d8:	19 f4       	brne	.+6      	; 0x163e0 <_spi_interrupt+0x2c>
				__spi_i = 0;
   163da:	10 92 cd 0e 	sts	0x0ECD, r1
   163de:	07 c0       	rjmp	.+14     	; 0x163ee <_spi_interrupt+0x3a>
				__spi_istransmit = 0;
			}
			else{
				__spi_i++;
   163e0:	89 2f       	mov	r24, r25
   163e2:	8f 5f       	subi	r24, 0xFF	; 255
   163e4:	80 93 cd 0e 	sts	0x0ECD, r24
				if(__spi_i == _MAX_COMMAND)
   163e8:	82 33       	cpi	r24, 0x32	; 50
   163ea:	09 f0       	breq	.+2      	; 0x163ee <_spi_interrupt+0x3a>
   163ec:	3f c0       	rjmp	.+126    	; 0x1646c <_spi_interrupt+0xb8>
					__spi_istransmit = 0;
   163ee:	10 92 20 04 	sts	0x0420, r1
   163f2:	3c c0       	rjmp	.+120    	; 0x1646c <_spi_interrupt+0xb8>
			}
		}
		else
			SPDR = 0xFF;
   163f4:	9f b9       	out	0x0f, r25	; 15
   163f6:	3a c0       	rjmp	.+116    	; 0x1646c <_spi_interrupt+0xb8>
	}
	else{
		if(__spi_char == 0x7D && __spi_isstart){
   163f8:	9d 37       	cpi	r25, 0x7D	; 125
   163fa:	69 f4       	brne	.+26     	; 0x16416 <_spi_interrupt+0x62>
   163fc:	80 91 e9 03 	lds	r24, 0x03E9
   16400:	88 23       	and	r24, r24
   16402:	49 f0       	breq	.+18     	; 0x16416 <_spi_interrupt+0x62>
			__spi_isstart = 0;
   16404:	10 92 e9 03 	sts	0x03E9, r1
			__spi_ismessage = 0;
   16408:	10 92 ea 03 	sts	0x03EA, r1
			__spi_i = 0;
   1640c:	10 92 cd 0e 	sts	0x0ECD, r1
			__command_flag = 1;
   16410:	81 e0       	ldi	r24, 0x01	; 1
   16412:	80 93 23 04 	sts	0x0423, r24
		}
		if(__spi_isstart && __spi_ismessage){
   16416:	20 91 e9 03 	lds	r18, 0x03E9
   1641a:	22 23       	and	r18, r18
   1641c:	f1 f0       	breq	.+60     	; 0x1645a <_spi_interrupt+0xa6>
   1641e:	80 91 ea 03 	lds	r24, 0x03EA
   16422:	88 23       	and	r24, r24
   16424:	29 f1       	breq	.+74     	; 0x16470 <_spi_interrupt+0xbc>
			if(__spi_char != 0x29){
   16426:	99 32       	cpi	r25, 0x29	; 41
   16428:	c1 f0       	breq	.+48     	; 0x1645a <_spi_interrupt+0xa6>
				__package[__spi_i] = __spi_char;
   1642a:	80 91 cd 0e 	lds	r24, 0x0ECD
   1642e:	e8 2f       	mov	r30, r24
   16430:	f0 e0       	ldi	r31, 0x00	; 0
   16432:	e7 5d       	subi	r30, 0xD7	; 215
   16434:	fb 4f       	sbci	r31, 0xFB	; 251
   16436:	90 83       	st	Z, r25
				__package[__spi_i + 1] = '\0';
   16438:	11 82       	std	Z+1, r1	; 0x01
				__spi_i++;
   1643a:	8f 5f       	subi	r24, 0xFF	; 255
   1643c:	80 93 cd 0e 	sts	0x0ECD, r24
				if(__spi_i == _MAX_PACKAGE)
   16440:	82 38       	cpi	r24, 0x82	; 130
   16442:	59 f4       	brne	.+22     	; 0x1645a <_spi_interrupt+0xa6>
					__spi_i = 0;
   16444:	10 92 cd 0e 	sts	0x0ECD, r1
   16448:	08 c0       	rjmp	.+16     	; 0x1645a <_spi_interrupt+0xa6>
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
				__spi_ismessage = 1;
   1644a:	81 e0       	ldi	r24, 0x01	; 1
   1644c:	80 93 ea 03 	sts	0x03EA, r24
				__spi_i = 0;
   16450:	10 92 cd 0e 	sts	0x0ECD, r1
   16454:	0b c0       	rjmp	.+22     	; 0x1646c <_spi_interrupt+0xb8>
			}
			else
				__command_set = __spi_char;
   16456:	90 93 25 04 	sts	0x0425, r25
		}
		if(__spi_char == 0x7B && !__spi_isstart){
   1645a:	9b 37       	cpi	r25, 0x7B	; 123
   1645c:	39 f4       	brne	.+14     	; 0x1646c <_spi_interrupt+0xb8>
   1645e:	22 23       	and	r18, r18
   16460:	29 f4       	brne	.+10     	; 0x1646c <_spi_interrupt+0xb8>
			__spi_isstart = 1;
   16462:	81 e0       	ldi	r24, 0x01	; 1
   16464:	80 93 e9 03 	sts	0x03E9, r24
			__spi_ismessage = 0;
   16468:	10 92 ea 03 	sts	0x03EA, r1
		}
	}

	return 0;
}
   1646c:	80 e0       	ldi	r24, 0x00	; 0
   1646e:	08 95       	ret
				if(__spi_i == _MAX_PACKAGE)
					__spi_i = 0;
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
   16470:	98 32       	cpi	r25, 0x28	; 40
   16472:	89 f7       	brne	.-30     	; 0x16456 <_spi_interrupt+0xa2>
   16474:	ea cf       	rjmp	.-44     	; 0x1644a <_spi_interrupt+0x96>

00016476 <_spi_command>:
	}

	return 0;
}

void _spi_command(unsigned char __cmd, char* __cell){
   16476:	fb 01       	movw	r30, r22
	unsigned char __i = 0;

	__command[__i++] = 0x7B;
   16478:	9b e7       	ldi	r25, 0x7B	; 123
   1647a:	90 93 ee 03 	sts	0x03EE, r25
	__command[__i++] = __cmd;
   1647e:	80 93 ef 03 	sts	0x03EF, r24

	if(strlen(__cell) > 0){
   16482:	80 81       	ld	r24, Z
   16484:	88 23       	and	r24, r24
   16486:	11 f4       	brne	.+4      	; 0x1648c <_spi_command+0x16>
   16488:	92 e0       	ldi	r25, 0x02	; 2
   1648a:	16 c0       	rjmp	.+44     	; 0x164b8 <_spi_command+0x42>
		__command[__i++] = 0x28;
   1648c:	88 e2       	ldi	r24, 0x28	; 40
   1648e:	80 93 f0 03 	sts	0x03F0, r24
   16492:	83 e0       	ldi	r24, 0x03	; 3
   16494:	05 c0       	rjmp	.+10     	; 0x164a0 <_spi_command+0x2a>

		while(*__cell)
			__command[__i++] = *__cell++;
   16496:	a2 51       	subi	r26, 0x12	; 18
   16498:	bc 4f       	sbci	r27, 0xFC	; 252
   1649a:	9c 93       	st	X, r25
   1649c:	82 2f       	mov	r24, r18
   1649e:	31 96       	adiw	r30, 0x01	; 1
	__command[__i++] = __cmd;

	if(strlen(__cell) > 0){
		__command[__i++] = 0x28;

		while(*__cell)
   164a0:	90 81       	ld	r25, Z
   164a2:	a8 2f       	mov	r26, r24
   164a4:	b0 e0       	ldi	r27, 0x00	; 0
   164a6:	28 2f       	mov	r18, r24
   164a8:	2f 5f       	subi	r18, 0xFF	; 255
   164aa:	99 23       	and	r25, r25
   164ac:	a1 f7       	brne	.-24     	; 0x16496 <_spi_command+0x20>
			__command[__i++] = *__cell++;

		__command[__i++] = 0x29;
   164ae:	a2 51       	subi	r26, 0x12	; 18
   164b0:	bc 4f       	sbci	r27, 0xFC	; 252
   164b2:	89 e2       	ldi	r24, 0x29	; 41
   164b4:	8c 93       	st	X, r24
   164b6:	92 2f       	mov	r25, r18
	}

	__command[__i++] = 0x7D;
   164b8:	e9 2f       	mov	r30, r25
   164ba:	f0 e0       	ldi	r31, 0x00	; 0
   164bc:	e2 51       	subi	r30, 0x12	; 18
   164be:	fc 4f       	sbci	r31, 0xFC	; 252
   164c0:	8d e7       	ldi	r24, 0x7D	; 125
   164c2:	80 83       	st	Z, r24
	__command[__i++] = '\0';
   164c4:	9f 5f       	subi	r25, 0xFF	; 255
   164c6:	e9 2f       	mov	r30, r25
   164c8:	f0 e0       	ldi	r31, 0x00	; 0
   164ca:	e2 51       	subi	r30, 0x12	; 18
   164cc:	fc 4f       	sbci	r31, 0xFC	; 252
   164ce:	10 82       	st	Z, r1
}
   164d0:	08 95       	ret

000164d2 <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   164d2:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   164d4:	22 23       	and	r18, r18
   164d6:	09 f4       	brne	.+2      	; 0x164da <_rtc+0x8>
   164d8:	49 c0       	rjmp	.+146    	; 0x1656c <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   164da:	84 ea       	ldi	r24, 0xA4	; 164
   164dc:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   164e0:	80 91 74 00 	lds	r24, 0x0074
   164e4:	87 ff       	sbrs	r24, 7
   164e6:	fc cf       	rjmp	.-8      	; 0x164e0 <_rtc+0xe>
		if(TW_STATUS != TW_START)
   164e8:	80 91 71 00 	lds	r24, 0x0071
   164ec:	88 7f       	andi	r24, 0xF8	; 248
   164ee:	88 30       	cpi	r24, 0x08	; 8
   164f0:	09 f0       	breq	.+2      	; 0x164f4 <_rtc+0x22>
   164f2:	af c0       	rjmp	.+350    	; 0x16652 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   164f4:	80 ed       	ldi	r24, 0xD0	; 208
   164f6:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   164fa:	84 e8       	ldi	r24, 0x84	; 132
   164fc:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16500:	80 91 74 00 	lds	r24, 0x0074
   16504:	87 ff       	sbrs	r24, 7
   16506:	fc cf       	rjmp	.-8      	; 0x16500 <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   16508:	80 91 71 00 	lds	r24, 0x0071
   1650c:	88 7f       	andi	r24, 0xF8	; 248
   1650e:	88 31       	cpi	r24, 0x18	; 24
   16510:	09 f0       	breq	.+2      	; 0x16514 <_rtc+0x42>
   16512:	9f c0       	rjmp	.+318    	; 0x16652 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   16514:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   16518:	84 e8       	ldi	r24, 0x84	; 132
   1651a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1651e:	80 91 74 00 	lds	r24, 0x0074
   16522:	87 ff       	sbrs	r24, 7
   16524:	fc cf       	rjmp	.-8      	; 0x1651e <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   16526:	80 91 71 00 	lds	r24, 0x0071
   1652a:	88 7f       	andi	r24, 0xF8	; 248
   1652c:	88 32       	cpi	r24, 0x28	; 40
   1652e:	09 f0       	breq	.+2      	; 0x16532 <_rtc+0x60>
   16530:	90 c0       	rjmp	.+288    	; 0x16652 <_rtc+0x180>
   16532:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   16534:	94 e8       	ldi	r25, 0x84	; 132
   16536:	14 c0       	rjmp	.+40     	; 0x16560 <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   16538:	fa 01       	movw	r30, r20
   1653a:	e8 0f       	add	r30, r24
   1653c:	f1 1d       	adc	r31, r1
   1653e:	80 81       	ld	r24, Z
   16540:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   16544:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   16548:	80 91 74 00 	lds	r24, 0x0074
   1654c:	87 ff       	sbrs	r24, 7
   1654e:	fc cf       	rjmp	.-8      	; 0x16548 <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   16550:	80 91 71 00 	lds	r24, 0x0071
   16554:	88 7f       	andi	r24, 0xF8	; 248
   16556:	80 33       	cpi	r24, 0x30	; 48
   16558:	09 f4       	brne	.+2      	; 0x1655c <_rtc+0x8a>
   1655a:	7b c0       	rjmp	.+246    	; 0x16652 <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   1655c:	21 50       	subi	r18, 0x01	; 1
   1655e:	30 40       	sbci	r19, 0x00	; 0
   16560:	86 2f       	mov	r24, r22
   16562:	82 1b       	sub	r24, r18
   16564:	12 16       	cp	r1, r18
   16566:	13 06       	cpc	r1, r19
   16568:	3c f3       	brlt	.-50     	; 0x16538 <_rtc+0x66>
   1656a:	6e c0       	rjmp	.+220    	; 0x16648 <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   1656c:	84 ea       	ldi	r24, 0xA4	; 164
   1656e:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16572:	80 91 74 00 	lds	r24, 0x0074
   16576:	87 ff       	sbrs	r24, 7
   16578:	fc cf       	rjmp	.-8      	; 0x16572 <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   1657a:	80 91 71 00 	lds	r24, 0x0071
   1657e:	88 7f       	andi	r24, 0xF8	; 248
   16580:	88 30       	cpi	r24, 0x08	; 8
   16582:	09 f0       	breq	.+2      	; 0x16586 <_rtc+0xb4>
   16584:	66 c0       	rjmp	.+204    	; 0x16652 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   16586:	80 ed       	ldi	r24, 0xD0	; 208
   16588:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   1658c:	84 e8       	ldi	r24, 0x84	; 132
   1658e:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16592:	80 91 74 00 	lds	r24, 0x0074
   16596:	87 ff       	sbrs	r24, 7
   16598:	fc cf       	rjmp	.-8      	; 0x16592 <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   1659a:	80 91 71 00 	lds	r24, 0x0071
   1659e:	88 7f       	andi	r24, 0xF8	; 248
   165a0:	88 31       	cpi	r24, 0x18	; 24
   165a2:	09 f0       	breq	.+2      	; 0x165a6 <_rtc+0xd4>
   165a4:	56 c0       	rjmp	.+172    	; 0x16652 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   165a6:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   165aa:	84 e8       	ldi	r24, 0x84	; 132
   165ac:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   165b0:	80 91 74 00 	lds	r24, 0x0074
   165b4:	87 ff       	sbrs	r24, 7
   165b6:	fc cf       	rjmp	.-8      	; 0x165b0 <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   165b8:	80 91 71 00 	lds	r24, 0x0071
   165bc:	88 7f       	andi	r24, 0xF8	; 248
   165be:	88 32       	cpi	r24, 0x28	; 40
   165c0:	09 f0       	breq	.+2      	; 0x165c4 <_rtc+0xf2>
   165c2:	47 c0       	rjmp	.+142    	; 0x16652 <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   165c4:	84 ea       	ldi	r24, 0xA4	; 164
   165c6:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   165ca:	80 91 74 00 	lds	r24, 0x0074
   165ce:	87 ff       	sbrs	r24, 7
   165d0:	fc cf       	rjmp	.-8      	; 0x165ca <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   165d2:	80 91 71 00 	lds	r24, 0x0071
   165d6:	88 7f       	andi	r24, 0xF8	; 248
   165d8:	80 31       	cpi	r24, 0x10	; 16
   165da:	d9 f5       	brne	.+118    	; 0x16652 <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   165dc:	81 ed       	ldi	r24, 0xD1	; 209
   165de:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   165e2:	84 e8       	ldi	r24, 0x84	; 132
   165e4:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   165e8:	80 91 74 00 	lds	r24, 0x0074
   165ec:	87 ff       	sbrs	r24, 7
   165ee:	fc cf       	rjmp	.-8      	; 0x165e8 <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   165f0:	80 91 71 00 	lds	r24, 0x0071
   165f4:	88 7f       	andi	r24, 0xF8	; 248
   165f6:	80 34       	cpi	r24, 0x40	; 64
   165f8:	61 f5       	brne	.+88     	; 0x16652 <_rtc+0x180>
   165fa:	24 ec       	ldi	r18, 0xC4	; 196
   165fc:	30 e0       	ldi	r19, 0x00	; 0
   165fe:	90 e0       	ldi	r25, 0x00	; 0
   16600:	20 c0       	rjmp	.+64     	; 0x16642 <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   16602:	61 30       	cpi	r22, 0x01	; 1
   16604:	71 05       	cpc	r23, r1
   16606:	11 f4       	brne	.+4      	; 0x1660c <_rtc+0x13a>
   16608:	24 e8       	ldi	r18, 0x84	; 132
   1660a:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   1660c:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   16610:	80 91 74 00 	lds	r24, 0x0074
   16614:	87 ff       	sbrs	r24, 7
   16616:	fc cf       	rjmp	.-8      	; 0x16610 <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   16618:	80 91 71 00 	lds	r24, 0x0071
   1661c:	88 7f       	andi	r24, 0xF8	; 248
   1661e:	88 35       	cpi	r24, 0x58	; 88
   16620:	11 f4       	brne	.+4      	; 0x16626 <_rtc+0x154>
   16622:	60 e0       	ldi	r22, 0x00	; 0
   16624:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   16626:	80 91 71 00 	lds	r24, 0x0071
   1662a:	88 7f       	andi	r24, 0xF8	; 248
   1662c:	80 35       	cpi	r24, 0x50	; 80
   1662e:	39 f4       	brne	.+14     	; 0x1663e <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   16630:	80 91 73 00 	lds	r24, 0x0073
   16634:	fa 01       	movw	r30, r20
   16636:	e9 0f       	add	r30, r25
   16638:	f1 1d       	adc	r31, r1
   1663a:	80 83       	st	Z, r24
   1663c:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   1663e:	61 50       	subi	r22, 0x01	; 1
   16640:	70 40       	sbci	r23, 0x00	; 0
   16642:	16 16       	cp	r1, r22
   16644:	17 06       	cpc	r1, r23
   16646:	ec f2       	brlt	.-70     	; 0x16602 <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   16648:	84 e9       	ldi	r24, 0x94	; 148
   1664a:	80 93 74 00 	sts	0x0074, r24
   1664e:	80 e0       	ldi	r24, 0x00	; 0
   16650:	08 95       	ret
   16652:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   16654:	08 95       	ret

00016656 <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   16656:	ef 92       	push	r14
   16658:	ff 92       	push	r15
   1665a:	0f 93       	push	r16
   1665c:	1f 93       	push	r17
   1665e:	df 93       	push	r29
   16660:	cf 93       	push	r28
   16662:	cd b7       	in	r28, 0x3d	; 61
   16664:	de b7       	in	r29, 0x3e	; 62
   16666:	64 97       	sbiw	r28, 0x14	; 20
   16668:	0f b6       	in	r0, 0x3f	; 63
   1666a:	f8 94       	cli
   1666c:	de bf       	out	0x3e, r29	; 62
   1666e:	0f be       	out	0x3f, r0	; 63
   16670:	cd bf       	out	0x3d, r28	; 61
   16672:	28 2f       	mov	r18, r24
   16674:	8b 01       	movw	r16, r22
   16676:	7a 01       	movw	r14, r20
   16678:	ae 01       	movw	r20, r28
   1667a:	4f 5f       	subi	r20, 0xFF	; 255
   1667c:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   1667e:	88 23       	and	r24, r24
   16680:	99 f1       	breq	.+102    	; 0x166e8 <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   16682:	fb 01       	movw	r30, r22
   16684:	90 81       	ld	r25, Z
   16686:	92 95       	swap	r25
   16688:	90 7f       	andi	r25, 0xF0	; 240
   1668a:	81 81       	ldd	r24, Z+1	; 0x01
   1668c:	8f 70       	andi	r24, 0x0F	; 15
   1668e:	98 0f       	add	r25, r24
   16690:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   16692:	93 81       	ldd	r25, Z+3	; 0x03
   16694:	92 95       	swap	r25
   16696:	90 7f       	andi	r25, 0xF0	; 240
   16698:	84 81       	ldd	r24, Z+4	; 0x04
   1669a:	8f 70       	andi	r24, 0x0F	; 15
   1669c:	98 0f       	add	r25, r24
   1669e:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   166a0:	96 81       	ldd	r25, Z+6	; 0x06
   166a2:	92 95       	swap	r25
   166a4:	90 7f       	andi	r25, 0xF0	; 240
   166a6:	87 81       	ldd	r24, Z+7	; 0x07
   166a8:	8f 70       	andi	r24, 0x0F	; 15
   166aa:	98 0f       	add	r25, r24
   166ac:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   166ae:	f7 01       	movw	r30, r14
   166b0:	90 81       	ld	r25, Z
   166b2:	92 95       	swap	r25
   166b4:	90 7f       	andi	r25, 0xF0	; 240
   166b6:	81 81       	ldd	r24, Z+1	; 0x01
   166b8:	8f 70       	andi	r24, 0x0F	; 15
   166ba:	98 0f       	add	r25, r24
   166bc:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   166be:	93 81       	ldd	r25, Z+3	; 0x03
   166c0:	92 95       	swap	r25
   166c2:	90 7f       	andi	r25, 0xF0	; 240
   166c4:	84 81       	ldd	r24, Z+4	; 0x04
   166c6:	8f 70       	andi	r24, 0x0F	; 15
   166c8:	98 0f       	add	r25, r24
   166ca:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   166cc:	96 81       	ldd	r25, Z+6	; 0x06
   166ce:	92 95       	swap	r25
   166d0:	90 7f       	andi	r25, 0xF0	; 240
   166d2:	87 81       	ldd	r24, Z+7	; 0x07
   166d4:	8f 70       	andi	r24, 0x0F	; 15
   166d6:	98 0f       	add	r25, r24
   166d8:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   166da:	80 e0       	ldi	r24, 0x00	; 0
   166dc:	90 e0       	ldi	r25, 0x00	; 0
   166de:	68 e0       	ldi	r22, 0x08	; 8
   166e0:	70 e0       	ldi	r23, 0x00	; 0
   166e2:	0e 94 69 b2 	call	0x164d2	; 0x164d2 <_rtc>
   166e6:	4a c0       	rjmp	.+148    	; 0x1677c <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   166e8:	80 e0       	ldi	r24, 0x00	; 0
   166ea:	90 e0       	ldi	r25, 0x00	; 0
   166ec:	68 e0       	ldi	r22, 0x08	; 8
   166ee:	70 e0       	ldi	r23, 0x00	; 0
   166f0:	20 e0       	ldi	r18, 0x00	; 0
   166f2:	0e 94 69 b2 	call	0x164d2	; 0x164d2 <_rtc>
   166f6:	81 30       	cpi	r24, 0x01	; 1
   166f8:	09 f4       	brne	.+2      	; 0x166fc <_datetime+0xa6>
   166fa:	40 c0       	rjmp	.+128    	; 0x1677c <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   166fc:	9d 81       	ldd	r25, Y+5	; 0x05
   166fe:	89 2f       	mov	r24, r25
   16700:	82 95       	swap	r24
   16702:	8f 70       	andi	r24, 0x0F	; 15
   16704:	80 5d       	subi	r24, 0xD0	; 208
   16706:	f8 01       	movw	r30, r16
   16708:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   1670a:	9f 70       	andi	r25, 0x0F	; 15
   1670c:	90 5d       	subi	r25, 0xD0	; 208
   1670e:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   16710:	2f e2       	ldi	r18, 0x2F	; 47
   16712:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   16714:	9e 81       	ldd	r25, Y+6	; 0x06
   16716:	89 2f       	mov	r24, r25
   16718:	82 95       	swap	r24
   1671a:	8f 70       	andi	r24, 0x0F	; 15
   1671c:	80 5d       	subi	r24, 0xD0	; 208
   1671e:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   16720:	9f 70       	andi	r25, 0x0F	; 15
   16722:	90 5d       	subi	r25, 0xD0	; 208
   16724:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   16726:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   16728:	9f 81       	ldd	r25, Y+7	; 0x07
   1672a:	89 2f       	mov	r24, r25
   1672c:	82 95       	swap	r24
   1672e:	8f 70       	andi	r24, 0x0F	; 15
   16730:	80 5d       	subi	r24, 0xD0	; 208
   16732:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   16734:	9f 70       	andi	r25, 0x0F	; 15
   16736:	90 5d       	subi	r25, 0xD0	; 208
   16738:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   1673a:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   1673c:	9b 81       	ldd	r25, Y+3	; 0x03
   1673e:	89 2f       	mov	r24, r25
   16740:	82 95       	swap	r24
   16742:	8f 70       	andi	r24, 0x0F	; 15
   16744:	80 5d       	subi	r24, 0xD0	; 208
   16746:	f7 01       	movw	r30, r14
   16748:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   1674a:	9f 70       	andi	r25, 0x0F	; 15
   1674c:	90 5d       	subi	r25, 0xD0	; 208
   1674e:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   16750:	2a e3       	ldi	r18, 0x3A	; 58
   16752:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   16754:	9a 81       	ldd	r25, Y+2	; 0x02
   16756:	89 2f       	mov	r24, r25
   16758:	82 95       	swap	r24
   1675a:	8f 70       	andi	r24, 0x0F	; 15
   1675c:	80 5d       	subi	r24, 0xD0	; 208
   1675e:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   16760:	9f 70       	andi	r25, 0x0F	; 15
   16762:	90 5d       	subi	r25, 0xD0	; 208
   16764:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   16766:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   16768:	99 81       	ldd	r25, Y+1	; 0x01
   1676a:	89 2f       	mov	r24, r25
   1676c:	82 95       	swap	r24
   1676e:	8f 70       	andi	r24, 0x0F	; 15
   16770:	80 5d       	subi	r24, 0xD0	; 208
   16772:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   16774:	9f 70       	andi	r25, 0x0F	; 15
   16776:	90 5d       	subi	r25, 0xD0	; 208
   16778:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   1677a:	10 86       	std	Z+8, r1	; 0x08
		}
}
   1677c:	64 96       	adiw	r28, 0x14	; 20
   1677e:	0f b6       	in	r0, 0x3f	; 63
   16780:	f8 94       	cli
   16782:	de bf       	out	0x3e, r29	; 62
   16784:	0f be       	out	0x3f, r0	; 63
   16786:	cd bf       	out	0x3d, r28	; 61
   16788:	cf 91       	pop	r28
   1678a:	df 91       	pop	r29
   1678c:	1f 91       	pop	r17
   1678e:	0f 91       	pop	r16
   16790:	ff 90       	pop	r15
   16792:	ef 90       	pop	r14
   16794:	08 95       	ret

00016796 <_day>:

unsigned char _day(void){
   16796:	df 93       	push	r29
   16798:	cf 93       	push	r28
   1679a:	cd b7       	in	r28, 0x3d	; 61
   1679c:	de b7       	in	r29, 0x3e	; 62
   1679e:	64 97       	sbiw	r28, 0x14	; 20
   167a0:	0f b6       	in	r0, 0x3f	; 63
   167a2:	f8 94       	cli
   167a4:	de bf       	out	0x3e, r29	; 62
   167a6:	0f be       	out	0x3f, r0	; 63
   167a8:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   167aa:	80 e0       	ldi	r24, 0x00	; 0
   167ac:	90 e0       	ldi	r25, 0x00	; 0
   167ae:	68 e0       	ldi	r22, 0x08	; 8
   167b0:	70 e0       	ldi	r23, 0x00	; 0
   167b2:	ae 01       	movw	r20, r28
   167b4:	4f 5f       	subi	r20, 0xFF	; 255
   167b6:	5f 4f       	sbci	r21, 0xFF	; 255
   167b8:	20 e0       	ldi	r18, 0x00	; 0
   167ba:	0e 94 69 b2 	call	0x164d2	; 0x164d2 <_rtc>
   167be:	81 30       	cpi	r24, 0x01	; 1
   167c0:	11 f4       	brne	.+4      	; 0x167c6 <_day+0x30>
   167c2:	80 e0       	ldi	r24, 0x00	; 0
   167c4:	02 c0       	rjmp	.+4      	; 0x167ca <_day+0x34>
		return __datetime[3] & 0x0F;
   167c6:	8c 81       	ldd	r24, Y+4	; 0x04
   167c8:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   167ca:	64 96       	adiw	r28, 0x14	; 20
   167cc:	0f b6       	in	r0, 0x3f	; 63
   167ce:	f8 94       	cli
   167d0:	de bf       	out	0x3e, r29	; 62
   167d2:	0f be       	out	0x3f, r0	; 63
   167d4:	cd bf       	out	0x3d, r28	; 61
   167d6:	cf 91       	pop	r28
   167d8:	df 91       	pop	r29
   167da:	08 95       	ret

000167dc <_uart_baudrate>:
	}

	_uart_baudrate(__com, __baudrate);
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
   167dc:	1f 93       	push	r17
   167de:	18 2f       	mov	r17, r24
   167e0:	9a 01       	movw	r18, r20
   167e2:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   167e4:	ca 01       	movw	r24, r20
   167e6:	b9 01       	movw	r22, r18
   167e8:	60 50       	subi	r22, 0x00	; 0
   167ea:	70 4e       	sbci	r23, 0xE0	; 224
   167ec:	83 4e       	sbci	r24, 0xE3	; 227
   167ee:	9f 4f       	sbci	r25, 0xFF	; 255
   167f0:	f3 e0       	ldi	r31, 0x03	; 3
   167f2:	66 0f       	add	r22, r22
   167f4:	77 1f       	adc	r23, r23
   167f6:	88 1f       	adc	r24, r24
   167f8:	99 1f       	adc	r25, r25
   167fa:	fa 95       	dec	r31
   167fc:	d1 f7       	brne	.-12     	; 0x167f2 <_uart_baudrate+0x16>
   167fe:	e4 e0       	ldi	r30, 0x04	; 4
   16800:	22 0f       	add	r18, r18
   16802:	33 1f       	adc	r19, r19
   16804:	44 1f       	adc	r20, r20
   16806:	55 1f       	adc	r21, r21
   16808:	ea 95       	dec	r30
   1680a:	d1 f7       	brne	.-12     	; 0x16800 <_uart_baudrate+0x24>
   1680c:	0e 94 14 b9 	call	0x17228	; 0x17228 <__udivmodsi4>
   16810:	21 50       	subi	r18, 0x01	; 1
   16812:	30 40       	sbci	r19, 0x00	; 0
   16814:	40 40       	sbci	r20, 0x00	; 0
   16816:	50 40       	sbci	r21, 0x00	; 0
   16818:	bb 27       	eor	r27, r27
   1681a:	a5 2f       	mov	r26, r21
   1681c:	94 2f       	mov	r25, r20
   1681e:	83 2f       	mov	r24, r19

	if(__com){
   16820:	11 23       	and	r17, r17
   16822:	29 f0       	breq	.+10     	; 0x1682e <_uart_baudrate+0x52>
		UBRR1L = __br;
   16824:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   16828:	80 93 98 00 	sts	0x0098, r24
   1682c:	03 c0       	rjmp	.+6      	; 0x16834 <_uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   1682e:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   16830:	80 93 90 00 	sts	0x0090, r24
	}
}
   16834:	1f 91       	pop	r17
   16836:	08 95       	ret

00016838 <_uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void _uart_init(unsigned char __com, unsigned long __baudrate){
   16838:	98 2f       	mov	r25, r24
	if(__com){
   1683a:	88 23       	and	r24, r24
   1683c:	39 f0       	breq	.+14     	; 0x1684c <_uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   1683e:	88 e9       	ldi	r24, 0x98	; 152
   16840:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   16844:	86 e0       	ldi	r24, 0x06	; 6
   16846:	80 93 9d 00 	sts	0x009D, r24
   1684a:	05 c0       	rjmp	.+10     	; 0x16856 <_uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   1684c:	88 e9       	ldi	r24, 0x98	; 152
   1684e:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   16850:	86 e0       	ldi	r24, 0x06	; 6
   16852:	80 93 95 00 	sts	0x0095, r24
	}

	_uart_baudrate(__com, __baudrate);
   16856:	89 2f       	mov	r24, r25
   16858:	0e 94 ee b3 	call	0x167dc	; 0x167dc <_uart_baudrate>
}
   1685c:	08 95       	ret

0001685e <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   1685e:	88 23       	and	r24, r24
   16860:	81 f0       	breq	.+32     	; 0x16882 <_uart+0x24>
		if(__dir){
   16862:	66 23       	and	r22, r22
   16864:	39 f0       	breq	.+14     	; 0x16874 <_uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   16866:	80 91 9b 00 	lds	r24, 0x009B
   1686a:	85 ff       	sbrs	r24, 5
   1686c:	fc cf       	rjmp	.-8      	; 0x16866 <_uart+0x8>
			UDR1 = __chr;
   1686e:	40 93 9c 00 	sts	0x009C, r20
   16872:	0c c0       	rjmp	.+24     	; 0x1688c <_uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   16874:	80 91 9b 00 	lds	r24, 0x009B
   16878:	87 ff       	sbrs	r24, 7
   1687a:	fc cf       	rjmp	.-8      	; 0x16874 <_uart+0x16>
			return UDR1;
   1687c:	80 91 9c 00 	lds	r24, 0x009C
   16880:	08 95       	ret
		}
	}
	else{
		if(__dir){
   16882:	66 23       	and	r22, r22
   16884:	29 f0       	breq	.+10     	; 0x16890 <_uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   16886:	5d 9b       	sbis	0x0b, 5	; 11
   16888:	fe cf       	rjmp	.-4      	; 0x16886 <_uart+0x28>
			UDR0 = __chr;
   1688a:	4c b9       	out	0x0c, r20	; 12
   1688c:	81 e0       	ldi	r24, 0x01	; 1
   1688e:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   16890:	5f 9b       	sbis	0x0b, 7	; 11
   16892:	fe cf       	rjmp	.-4      	; 0x16890 <_uart+0x32>
			return UDR0;
   16894:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   16896:	08 95       	ret

00016898 <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
   16898:	0f 93       	push	r16
   1689a:	1f 93       	push	r17
   1689c:	cf 93       	push	r28
   1689e:	df 93       	push	r29
   168a0:	18 2f       	mov	r17, r24
   168a2:	06 2f       	mov	r16, r22
   168a4:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   168a6:	88 81       	ld	r24, Y
   168a8:	88 23       	and	r24, r24
   168aa:	31 f4       	brne	.+12     	; 0x168b8 <_uart_print+0x20>
   168ac:	08 c0       	rjmp	.+16     	; 0x168be <_uart_print+0x26>
		while(*__str)
		     _uart(__com, 1, *__str++);
   168ae:	21 96       	adiw	r28, 0x01	; 1
   168b0:	81 2f       	mov	r24, r17
   168b2:	61 e0       	ldi	r22, 0x01	; 1
   168b4:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
	return 1;
}

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   168b8:	48 81       	ld	r20, Y
   168ba:	44 23       	and	r20, r20
   168bc:	c1 f7       	brne	.-16     	; 0x168ae <_uart_print+0x16>
		     _uart(__com, 1, *__str++);

	if(__ret){
   168be:	00 23       	and	r16, r16
   168c0:	51 f0       	breq	.+20     	; 0x168d6 <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
   168c2:	81 2f       	mov	r24, r17
   168c4:	61 e0       	ldi	r22, 0x01	; 1
   168c6:	4d e0       	ldi	r20, 0x0D	; 13
   168c8:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		_uart(__com, 1, 0x0A);
   168cc:	81 2f       	mov	r24, r17
   168ce:	61 e0       	ldi	r22, 0x01	; 1
   168d0:	4a e0       	ldi	r20, 0x0A	; 10
   168d2:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
   168d6:	82 ee       	ldi	r24, 0xE2	; 226
   168d8:	94 e0       	ldi	r25, 0x04	; 4
   168da:	01 97       	sbiw	r24, 0x01	; 1
   168dc:	f1 f7       	brne	.-4      	; 0x168da <_uart_print+0x42>
	}
	_delay_ms(5);
}
   168de:	df 91       	pop	r29
   168e0:	cf 91       	pop	r28
   168e2:	1f 91       	pop	r17
   168e4:	0f 91       	pop	r16
   168e6:	08 95       	ret

000168e8 <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   168e8:	0f 93       	push	r16
   168ea:	1f 93       	push	r17
   168ec:	cf 93       	push	r28
   168ee:	df 93       	push	r29
   168f0:	18 2f       	mov	r17, r24
   168f2:	06 2f       	mov	r16, r22
   168f4:	ea 01       	movw	r28, r20
   168f6:	07 c0       	rjmp	.+14     	; 0x16906 <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
   168f8:	21 96       	adiw	r28, 0x01	; 1
   168fa:	f9 01       	movw	r30, r18
   168fc:	44 91       	lpm	r20, Z+
   168fe:	81 2f       	mov	r24, r17
   16900:	61 e0       	ldi	r22, 0x01	; 1
   16902:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
   16906:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   16908:	fe 01       	movw	r30, r28
   1690a:	84 91       	lpm	r24, Z+
   1690c:	88 23       	and	r24, r24
   1690e:	a1 f7       	brne	.-24     	; 0x168f8 <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   16910:	00 23       	and	r16, r16
   16912:	51 f0       	breq	.+20     	; 0x16928 <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
   16914:	81 2f       	mov	r24, r17
   16916:	61 e0       	ldi	r22, 0x01	; 1
   16918:	4d e0       	ldi	r20, 0x0D	; 13
   1691a:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
		_uart(__com, 1, 0x0A);
   1691e:	81 2f       	mov	r24, r17
   16920:	61 e0       	ldi	r22, 0x01	; 1
   16922:	4a e0       	ldi	r20, 0x0A	; 10
   16924:	0e 94 2f b4 	call	0x1685e	; 0x1685e <_uart>
   16928:	86 ea       	ldi	r24, 0xA6	; 166
   1692a:	9e e0       	ldi	r25, 0x0E	; 14
   1692c:	01 97       	sbiw	r24, 0x01	; 1
   1692e:	f1 f7       	brne	.-4      	; 0x1692c <_uart_printf+0x44>
	}
	_delay_ms(15);
}
   16930:	df 91       	pop	r29
   16932:	cf 91       	pop	r28
   16934:	1f 91       	pop	r17
   16936:	0f 91       	pop	r16
   16938:	08 95       	ret

0001693a <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   1693a:	6f 92       	push	r6
   1693c:	7f 92       	push	r7
   1693e:	8f 92       	push	r8
   16940:	9f 92       	push	r9
   16942:	af 92       	push	r10
   16944:	bf 92       	push	r11
   16946:	cf 92       	push	r12
   16948:	df 92       	push	r13
   1694a:	ef 92       	push	r14
   1694c:	ff 92       	push	r15
   1694e:	0f 93       	push	r16
   16950:	1f 93       	push	r17
   16952:	cf 93       	push	r28
   16954:	df 93       	push	r29
   16956:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   16958:	41 15       	cp	r20, r1
   1695a:	51 05       	cpc	r21, r1
   1695c:	61 05       	cpc	r22, r1
   1695e:	71 05       	cpc	r23, r1
   16960:	21 f4       	brne	.+8      	; 0x1696a <Int2Str+0x30>
		__string[0] = '0';
   16962:	80 e3       	ldi	r24, 0x30	; 48
   16964:	88 83       	st	Y, r24
		__string[1] = '\0';
   16966:	19 82       	std	Y+1, r1	; 0x01
   16968:	48 c0       	rjmp	.+144    	; 0x169fa <Int2Str+0xc0>
		return;
   1696a:	4a 01       	movw	r8, r20
   1696c:	5b 01       	movw	r10, r22
   1696e:	10 e0       	ldi	r17, 0x00	; 0
   16970:	00 e0       	ldi	r16, 0x00	; 0
   16972:	77 24       	eor	r7, r7
   16974:	c1 2c       	mov	r12, r1
   16976:	ba ec       	ldi	r27, 0xCA	; 202
   16978:	db 2e       	mov	r13, r27
   1697a:	ba e9       	ldi	r27, 0x9A	; 154
   1697c:	eb 2e       	mov	r14, r27
   1697e:	bb e3       	ldi	r27, 0x3B	; 59
   16980:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   16982:	a0 e3       	ldi	r26, 0x30	; 48
   16984:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   16986:	8c 14       	cp	r8, r12
   16988:	9d 04       	cpc	r9, r13
   1698a:	ae 04       	cpc	r10, r14
   1698c:	bf 04       	cpc	r11, r15
   1698e:	d0 f0       	brcs	.+52     	; 0x169c4 <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   16990:	c5 01       	movw	r24, r10
   16992:	b4 01       	movw	r22, r8
   16994:	a7 01       	movw	r20, r14
   16996:	96 01       	movw	r18, r12
   16998:	0e 94 14 b9 	call	0x17228	; 0x17228 <__udivmodsi4>
   1699c:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   1699e:	c5 01       	movw	r24, r10
   169a0:	b4 01       	movw	r22, r8
   169a2:	a7 01       	movw	r20, r14
   169a4:	96 01       	movw	r18, r12
   169a6:	0e 94 14 b9 	call	0x17228	; 0x17228 <__udivmodsi4>
   169aa:	ac 01       	movw	r20, r24
   169ac:	cb 01       	movw	r24, r22
   169ae:	da 01       	movw	r26, r20
   169b0:	4c 01       	movw	r8, r24
   169b2:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   169b4:	fe 01       	movw	r30, r28
   169b6:	e0 0f       	add	r30, r16
   169b8:	f1 1d       	adc	r31, r1
   169ba:	10 5d       	subi	r17, 0xD0	; 208
   169bc:	10 83       	st	Z, r17
   169be:	0f 5f       	subi	r16, 0xFF	; 255
   169c0:	11 e0       	ldi	r17, 0x01	; 1
   169c2:	07 c0       	rjmp	.+14     	; 0x169d2 <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   169c4:	11 23       	and	r17, r17
   169c6:	29 f0       	breq	.+10     	; 0x169d2 <Int2Str+0x98>
				__string[__i++] = 0x30;
   169c8:	fe 01       	movw	r30, r28
   169ca:	e0 0f       	add	r30, r16
   169cc:	f1 1d       	adc	r31, r1
   169ce:	60 82       	st	Z, r6
   169d0:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   169d2:	73 94       	inc	r7
   169d4:	8a e0       	ldi	r24, 0x0A	; 10
   169d6:	78 16       	cp	r7, r24
   169d8:	69 f0       	breq	.+26     	; 0x169f4 <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   169da:	c7 01       	movw	r24, r14
   169dc:	b6 01       	movw	r22, r12
   169de:	2a e0       	ldi	r18, 0x0A	; 10
   169e0:	30 e0       	ldi	r19, 0x00	; 0
   169e2:	40 e0       	ldi	r20, 0x00	; 0
   169e4:	50 e0       	ldi	r21, 0x00	; 0
   169e6:	0e 94 14 b9 	call	0x17228	; 0x17228 <__udivmodsi4>
   169ea:	c9 01       	movw	r24, r18
   169ec:	da 01       	movw	r26, r20
   169ee:	6c 01       	movw	r12, r24
   169f0:	7d 01       	movw	r14, r26
   169f2:	c9 cf       	rjmp	.-110    	; 0x16986 <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   169f4:	c0 0f       	add	r28, r16
   169f6:	d1 1d       	adc	r29, r1
   169f8:	18 82       	st	Y, r1
}
   169fa:	df 91       	pop	r29
   169fc:	cf 91       	pop	r28
   169fe:	1f 91       	pop	r17
   16a00:	0f 91       	pop	r16
   16a02:	ff 90       	pop	r15
   16a04:	ef 90       	pop	r14
   16a06:	df 90       	pop	r13
   16a08:	cf 90       	pop	r12
   16a0a:	bf 90       	pop	r11
   16a0c:	af 90       	pop	r10
   16a0e:	9f 90       	pop	r9
   16a10:	8f 90       	pop	r8
   16a12:	7f 90       	pop	r7
   16a14:	6f 90       	pop	r6
   16a16:	08 95       	ret

00016a18 <Str2Int>:

unsigned long Str2Int(char* __string){
   16a18:	6f 92       	push	r6
   16a1a:	7f 92       	push	r7
   16a1c:	8f 92       	push	r8
   16a1e:	9f 92       	push	r9
   16a20:	af 92       	push	r10
   16a22:	bf 92       	push	r11
   16a24:	cf 92       	push	r12
   16a26:	df 92       	push	r13
   16a28:	ef 92       	push	r14
   16a2a:	ff 92       	push	r15
   16a2c:	0f 93       	push	r16
   16a2e:	1f 93       	push	r17
   16a30:	cf 93       	push	r28
   16a32:	df 93       	push	r29
   16a34:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   16a36:	dc 01       	movw	r26, r24
   16a38:	0d 90       	ld	r0, X+
   16a3a:	00 20       	and	r0, r0
   16a3c:	e9 f7       	brne	.-6      	; 0x16a38 <Str2Int+0x20>
   16a3e:	11 97       	sbiw	r26, 0x01	; 1
   16a40:	7a 2e       	mov	r7, r26
   16a42:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   16a44:	87 2d       	mov	r24, r7
   16a46:	81 50       	subi	r24, 0x01	; 1
   16a48:	8a 30       	cpi	r24, 0x0A	; 10
   16a4a:	08 f0       	brcs	.+2      	; 0x16a4e <Str2Int+0x36>
   16a4c:	64 c0       	rjmp	.+200    	; 0x16b16 <Str2Int+0xfe>
   16a4e:	4e 01       	movw	r8, r28
   16a50:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   16a52:	6c 2e       	mov	r6, r28
   16a54:	05 c0       	rjmp	.+10     	; 0x16a60 <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   16a56:	81 91       	ld	r24, Z+
   16a58:	80 53       	subi	r24, 0x30	; 48
   16a5a:	8a 30       	cpi	r24, 0x0A	; 10
   16a5c:	08 f0       	brcs	.+2      	; 0x16a60 <Str2Int+0x48>
   16a5e:	5b c0       	rjmp	.+182    	; 0x16b16 <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   16a60:	8e 2f       	mov	r24, r30
   16a62:	86 19       	sub	r24, r6
   16a64:	87 15       	cp	r24, r7
   16a66:	b8 f3       	brcs	.-18     	; 0x16a56 <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   16a68:	8a e0       	ldi	r24, 0x0A	; 10
   16a6a:	78 16       	cp	r7, r24
   16a6c:	f9 f4       	brne	.+62     	; 0x16aac <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   16a6e:	98 81       	ld	r25, Y
   16a70:	89 2f       	mov	r24, r25
   16a72:	80 53       	subi	r24, 0x30	; 48
   16a74:	83 30       	cpi	r24, 0x03	; 3
   16a76:	08 f0       	brcs	.+2      	; 0x16a7a <Str2Int+0x62>
   16a78:	4e c0       	rjmp	.+156    	; 0x16b16 <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   16a7a:	92 33       	cpi	r25, 0x32	; 50
   16a7c:	b9 f4       	brne	.+46     	; 0x16aac <Str2Int+0x94>
   16a7e:	fe 01       	movw	r30, r28
   16a80:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   16a82:	81 81       	ldd	r24, Z+1	; 0x01
   16a84:	80 33       	cpi	r24, 0x30	; 48
   16a86:	09 f0       	breq	.+2      	; 0x16a8a <Str2Int+0x72>
   16a88:	46 c0       	rjmp	.+140    	; 0x16b16 <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   16a8a:	9f 5f       	subi	r25, 0xFF	; 255
   16a8c:	31 96       	adiw	r30, 0x01	; 1
   16a8e:	9a 30       	cpi	r25, 0x0A	; 10
   16a90:	c1 f7       	brne	.-16     	; 0x16a82 <Str2Int+0x6a>
   16a92:	0c c0       	rjmp	.+24     	; 0x16aac <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   16a94:	c6 01       	movw	r24, r12
   16a96:	b5 01       	movw	r22, r10
   16a98:	2a e0       	ldi	r18, 0x0A	; 10
   16a9a:	30 e0       	ldi	r19, 0x00	; 0
   16a9c:	40 e0       	ldi	r20, 0x00	; 0
   16a9e:	50 e0       	ldi	r21, 0x00	; 0
   16aa0:	0e 94 b5 b8 	call	0x1716a	; 0x1716a <__mulsi3>
   16aa4:	5b 01       	movw	r10, r22
   16aa6:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   16aa8:	1f 5f       	subi	r17, 0xFF	; 255
   16aaa:	09 c0       	rjmp	.+18     	; 0x16abe <Str2Int+0xa6>
   16aac:	10 e0       	ldi	r17, 0x00	; 0
   16aae:	01 e0       	ldi	r16, 0x01	; 1
   16ab0:	a0 2e       	mov	r10, r16
   16ab2:	b1 2c       	mov	r11, r1
   16ab4:	c1 2c       	mov	r12, r1
   16ab6:	d1 2c       	mov	r13, r1
   16ab8:	c7 2d       	mov	r28, r7
   16aba:	d0 e0       	ldi	r29, 0x00	; 0
   16abc:	21 97       	sbiw	r28, 0x01	; 1
   16abe:	81 2f       	mov	r24, r17
   16ac0:	90 e0       	ldi	r25, 0x00	; 0
   16ac2:	8c 17       	cp	r24, r28
   16ac4:	9d 07       	cpc	r25, r29
   16ac6:	34 f3       	brlt	.-52     	; 0x16a94 <Str2Int+0x7c>
   16ac8:	ee 24       	eor	r14, r14
   16aca:	ff 24       	eor	r15, r15
   16acc:	87 01       	movw	r16, r14
   16ace:	1e c0       	rjmp	.+60     	; 0x16b0c <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   16ad0:	f4 01       	movw	r30, r8
   16ad2:	21 91       	ld	r18, Z+
   16ad4:	4f 01       	movw	r8, r30
   16ad6:	30 e0       	ldi	r19, 0x00	; 0
   16ad8:	20 53       	subi	r18, 0x30	; 48
   16ada:	30 40       	sbci	r19, 0x00	; 0
   16adc:	44 27       	eor	r20, r20
   16ade:	37 fd       	sbrc	r19, 7
   16ae0:	40 95       	com	r20
   16ae2:	54 2f       	mov	r21, r20
   16ae4:	c6 01       	movw	r24, r12
   16ae6:	b5 01       	movw	r22, r10
   16ae8:	0e 94 b5 b8 	call	0x1716a	; 0x1716a <__mulsi3>
   16aec:	e6 0e       	add	r14, r22
   16aee:	f7 1e       	adc	r15, r23
   16af0:	08 1f       	adc	r16, r24
   16af2:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   16af4:	c6 01       	movw	r24, r12
   16af6:	b5 01       	movw	r22, r10
   16af8:	2a e0       	ldi	r18, 0x0A	; 10
   16afa:	30 e0       	ldi	r19, 0x00	; 0
   16afc:	40 e0       	ldi	r20, 0x00	; 0
   16afe:	50 e0       	ldi	r21, 0x00	; 0
   16b00:	0e 94 14 b9 	call	0x17228	; 0x17228 <__udivmodsi4>
   16b04:	c9 01       	movw	r24, r18
   16b06:	da 01       	movw	r26, r20
   16b08:	5c 01       	movw	r10, r24
   16b0a:	6d 01       	movw	r12, r26
   16b0c:	88 2d       	mov	r24, r8
   16b0e:	86 19       	sub	r24, r6
   16b10:	87 15       	cp	r24, r7
   16b12:	f0 f2       	brcs	.-68     	; 0x16ad0 <Str2Int+0xb8>
   16b14:	03 c0       	rjmp	.+6      	; 0x16b1c <Str2Int+0x104>
   16b16:	ee 24       	eor	r14, r14
   16b18:	ff 24       	eor	r15, r15
   16b1a:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   16b1c:	b7 01       	movw	r22, r14
   16b1e:	c8 01       	movw	r24, r16
   16b20:	df 91       	pop	r29
   16b22:	cf 91       	pop	r28
   16b24:	1f 91       	pop	r17
   16b26:	0f 91       	pop	r16
   16b28:	ff 90       	pop	r15
   16b2a:	ef 90       	pop	r14
   16b2c:	df 90       	pop	r13
   16b2e:	cf 90       	pop	r12
   16b30:	bf 90       	pop	r11
   16b32:	af 90       	pop	r10
   16b34:	9f 90       	pop	r9
   16b36:	8f 90       	pop	r8
   16b38:	7f 90       	pop	r7
   16b3a:	6f 90       	pop	r6
   16b3c:	08 95       	ret

00016b3e <atoi>:
   16b3e:	fc 01       	movw	r30, r24
   16b40:	88 27       	eor	r24, r24
   16b42:	99 27       	eor	r25, r25
   16b44:	e8 94       	clt
   16b46:	21 91       	ld	r18, Z+
   16b48:	20 32       	cpi	r18, 0x20	; 32
   16b4a:	e9 f3       	breq	.-6      	; 0x16b46 <atoi+0x8>
   16b4c:	29 30       	cpi	r18, 0x09	; 9
   16b4e:	10 f0       	brcs	.+4      	; 0x16b54 <atoi+0x16>
   16b50:	2e 30       	cpi	r18, 0x0E	; 14
   16b52:	c8 f3       	brcs	.-14     	; 0x16b46 <atoi+0x8>
   16b54:	2b 32       	cpi	r18, 0x2B	; 43
   16b56:	41 f0       	breq	.+16     	; 0x16b68 <atoi+0x2a>
   16b58:	2d 32       	cpi	r18, 0x2D	; 45
   16b5a:	39 f4       	brne	.+14     	; 0x16b6a <atoi+0x2c>
   16b5c:	68 94       	set
   16b5e:	04 c0       	rjmp	.+8      	; 0x16b68 <atoi+0x2a>
   16b60:	0e 94 0c b6 	call	0x16c18	; 0x16c18 <__mulhi_const_10>
   16b64:	82 0f       	add	r24, r18
   16b66:	91 1d       	adc	r25, r1
   16b68:	21 91       	ld	r18, Z+
   16b6a:	20 53       	subi	r18, 0x30	; 48
   16b6c:	2a 30       	cpi	r18, 0x0A	; 10
   16b6e:	c0 f3       	brcs	.-16     	; 0x16b60 <atoi+0x22>
   16b70:	1e f4       	brtc	.+6      	; 0x16b78 <atoi+0x3a>
   16b72:	90 95       	com	r25
   16b74:	81 95       	neg	r24
   16b76:	9f 4f       	sbci	r25, 0xFF	; 255
   16b78:	08 95       	ret

00016b7a <strcpy_P>:
   16b7a:	fb 01       	movw	r30, r22
   16b7c:	dc 01       	movw	r26, r24
   16b7e:	05 90       	lpm	r0, Z+
   16b80:	0d 92       	st	X+, r0
   16b82:	00 20       	and	r0, r0
   16b84:	e1 f7       	brne	.-8      	; 0x16b7e <strcpy_P+0x4>
   16b86:	08 95       	ret

00016b88 <strcmp>:
   16b88:	fb 01       	movw	r30, r22
   16b8a:	dc 01       	movw	r26, r24
   16b8c:	8d 91       	ld	r24, X+
   16b8e:	01 90       	ld	r0, Z+
   16b90:	80 19       	sub	r24, r0
   16b92:	01 10       	cpse	r0, r1
   16b94:	d9 f3       	breq	.-10     	; 0x16b8c <strcmp+0x4>
   16b96:	99 0b       	sbc	r25, r25
   16b98:	08 95       	ret

00016b9a <strcpy>:
   16b9a:	fb 01       	movw	r30, r22
   16b9c:	dc 01       	movw	r26, r24
   16b9e:	01 90       	ld	r0, Z+
   16ba0:	0d 92       	st	X+, r0
   16ba2:	00 20       	and	r0, r0
   16ba4:	e1 f7       	brne	.-8      	; 0x16b9e <strcpy+0x4>
   16ba6:	08 95       	ret

00016ba8 <__eerd_block>:
   16ba8:	a0 e0       	ldi	r26, 0x00	; 0
   16baa:	b0 e0       	ldi	r27, 0x00	; 0
   16bac:	ea ed       	ldi	r30, 0xDA	; 218
   16bae:	f5 eb       	ldi	r31, 0xB5	; 181
   16bb0:	0c 94 40 b9 	jmp	0x17280	; 0x17280 <__prologue_saves__+0x14>
   16bb4:	7c 01       	movw	r14, r24
   16bb6:	eb 01       	movw	r28, r22
   16bb8:	8a 01       	movw	r16, r20
   16bba:	69 01       	movw	r12, r18
   16bbc:	09 c0       	rjmp	.+18     	; 0x16bd0 <__eerd_block+0x28>
   16bbe:	ce 01       	movw	r24, r28
   16bc0:	21 96       	adiw	r28, 0x01	; 1
   16bc2:	f6 01       	movw	r30, r12
   16bc4:	09 95       	icall
   16bc6:	f7 01       	movw	r30, r14
   16bc8:	81 93       	st	Z+, r24
   16bca:	7f 01       	movw	r14, r30
   16bcc:	01 50       	subi	r16, 0x01	; 1
   16bce:	10 40       	sbci	r17, 0x00	; 0
   16bd0:	01 15       	cp	r16, r1
   16bd2:	11 05       	cpc	r17, r1
   16bd4:	a1 f7       	brne	.-24     	; 0x16bbe <__eerd_block+0x16>
   16bd6:	cd b7       	in	r28, 0x3d	; 61
   16bd8:	de b7       	in	r29, 0x3e	; 62
   16bda:	e8 e0       	ldi	r30, 0x08	; 8
   16bdc:	0c 94 5c b9 	jmp	0x172b8	; 0x172b8 <__epilogue_restores__+0x14>

00016be0 <__eewr_block>:
   16be0:	a0 e0       	ldi	r26, 0x00	; 0
   16be2:	b0 e0       	ldi	r27, 0x00	; 0
   16be4:	e6 ef       	ldi	r30, 0xF6	; 246
   16be6:	f5 eb       	ldi	r31, 0xB5	; 181
   16be8:	0c 94 40 b9 	jmp	0x17280	; 0x17280 <__prologue_saves__+0x14>
   16bec:	ec 01       	movw	r28, r24
   16bee:	7b 01       	movw	r14, r22
   16bf0:	8a 01       	movw	r16, r20
   16bf2:	69 01       	movw	r12, r18
   16bf4:	09 c0       	rjmp	.+18     	; 0x16c08 <__eewr_block+0x28>
   16bf6:	ce 01       	movw	r24, r28
   16bf8:	21 96       	adiw	r28, 0x01	; 1
   16bfa:	f7 01       	movw	r30, r14
   16bfc:	61 91       	ld	r22, Z+
   16bfe:	7f 01       	movw	r14, r30
   16c00:	f6 01       	movw	r30, r12
   16c02:	09 95       	icall
   16c04:	01 50       	subi	r16, 0x01	; 1
   16c06:	10 40       	sbci	r17, 0x00	; 0
   16c08:	01 15       	cp	r16, r1
   16c0a:	11 05       	cpc	r17, r1
   16c0c:	a1 f7       	brne	.-24     	; 0x16bf6 <__eewr_block+0x16>
   16c0e:	cd b7       	in	r28, 0x3d	; 61
   16c10:	de b7       	in	r29, 0x3e	; 62
   16c12:	e8 e0       	ldi	r30, 0x08	; 8
   16c14:	0c 94 5c b9 	jmp	0x172b8	; 0x172b8 <__epilogue_restores__+0x14>

00016c18 <__mulhi_const_10>:
   16c18:	7a e0       	ldi	r23, 0x0A	; 10
   16c1a:	97 9f       	mul	r25, r23
   16c1c:	90 2d       	mov	r25, r0
   16c1e:	87 9f       	mul	r24, r23
   16c20:	80 2d       	mov	r24, r0
   16c22:	91 0d       	add	r25, r1
   16c24:	11 24       	eor	r1, r1
   16c26:	08 95       	ret

00016c28 <sprintf_P>:
   16c28:	ae e0       	ldi	r26, 0x0E	; 14
   16c2a:	b0 e0       	ldi	r27, 0x00	; 0
   16c2c:	ea e1       	ldi	r30, 0x1A	; 26
   16c2e:	f6 eb       	ldi	r31, 0xB6	; 182
   16c30:	0c 94 44 b9 	jmp	0x17288	; 0x17288 <__prologue_saves__+0x1c>
   16c34:	0d 89       	ldd	r16, Y+21	; 0x15
   16c36:	1e 89       	ldd	r17, Y+22	; 0x16
   16c38:	8e e0       	ldi	r24, 0x0E	; 14
   16c3a:	8c 83       	std	Y+4, r24	; 0x04
   16c3c:	1a 83       	std	Y+2, r17	; 0x02
   16c3e:	09 83       	std	Y+1, r16	; 0x01
   16c40:	8f ef       	ldi	r24, 0xFF	; 255
   16c42:	9f e7       	ldi	r25, 0x7F	; 127
   16c44:	9e 83       	std	Y+6, r25	; 0x06
   16c46:	8d 83       	std	Y+5, r24	; 0x05
   16c48:	9e 01       	movw	r18, r28
   16c4a:	27 5e       	subi	r18, 0xE7	; 231
   16c4c:	3f 4f       	sbci	r19, 0xFF	; 255
   16c4e:	ce 01       	movw	r24, r28
   16c50:	01 96       	adiw	r24, 0x01	; 1
   16c52:	6f 89       	ldd	r22, Y+23	; 0x17
   16c54:	78 8d       	ldd	r23, Y+24	; 0x18
   16c56:	a9 01       	movw	r20, r18
   16c58:	0e 94 38 b6 	call	0x16c70	; 0x16c70 <vfprintf>
   16c5c:	2f 81       	ldd	r18, Y+7	; 0x07
   16c5e:	38 85       	ldd	r19, Y+8	; 0x08
   16c60:	02 0f       	add	r16, r18
   16c62:	13 1f       	adc	r17, r19
   16c64:	f8 01       	movw	r30, r16
   16c66:	10 82       	st	Z, r1
   16c68:	2e 96       	adiw	r28, 0x0e	; 14
   16c6a:	e4 e0       	ldi	r30, 0x04	; 4
   16c6c:	0c 94 60 b9 	jmp	0x172c0	; 0x172c0 <__epilogue_restores__+0x1c>

00016c70 <vfprintf>:
   16c70:	ab e0       	ldi	r26, 0x0B	; 11
   16c72:	b0 e0       	ldi	r27, 0x00	; 0
   16c74:	ee e3       	ldi	r30, 0x3E	; 62
   16c76:	f6 eb       	ldi	r31, 0xB6	; 182
   16c78:	0c 94 36 b9 	jmp	0x1726c	; 0x1726c <__prologue_saves__>
   16c7c:	3c 01       	movw	r6, r24
   16c7e:	2b 01       	movw	r4, r22
   16c80:	5a 01       	movw	r10, r20
   16c82:	fc 01       	movw	r30, r24
   16c84:	17 82       	std	Z+7, r1	; 0x07
   16c86:	16 82       	std	Z+6, r1	; 0x06
   16c88:	83 81       	ldd	r24, Z+3	; 0x03
   16c8a:	81 fd       	sbrc	r24, 1
   16c8c:	03 c0       	rjmp	.+6      	; 0x16c94 <vfprintf+0x24>
   16c8e:	6f ef       	ldi	r22, 0xFF	; 255
   16c90:	7f ef       	ldi	r23, 0xFF	; 255
   16c92:	c6 c1       	rjmp	.+908    	; 0x17020 <vfprintf+0x3b0>
   16c94:	9a e0       	ldi	r25, 0x0A	; 10
   16c96:	89 2e       	mov	r8, r25
   16c98:	1e 01       	movw	r2, r28
   16c9a:	08 94       	sec
   16c9c:	21 1c       	adc	r2, r1
   16c9e:	31 1c       	adc	r3, r1
   16ca0:	f3 01       	movw	r30, r6
   16ca2:	23 81       	ldd	r18, Z+3	; 0x03
   16ca4:	f2 01       	movw	r30, r4
   16ca6:	23 fd       	sbrc	r18, 3
   16ca8:	85 91       	lpm	r24, Z+
   16caa:	23 ff       	sbrs	r18, 3
   16cac:	81 91       	ld	r24, Z+
   16cae:	2f 01       	movw	r4, r30
   16cb0:	88 23       	and	r24, r24
   16cb2:	09 f4       	brne	.+2      	; 0x16cb6 <vfprintf+0x46>
   16cb4:	b2 c1       	rjmp	.+868    	; 0x1701a <vfprintf+0x3aa>
   16cb6:	85 32       	cpi	r24, 0x25	; 37
   16cb8:	39 f4       	brne	.+14     	; 0x16cc8 <vfprintf+0x58>
   16cba:	23 fd       	sbrc	r18, 3
   16cbc:	85 91       	lpm	r24, Z+
   16cbe:	23 ff       	sbrs	r18, 3
   16cc0:	81 91       	ld	r24, Z+
   16cc2:	2f 01       	movw	r4, r30
   16cc4:	85 32       	cpi	r24, 0x25	; 37
   16cc6:	29 f4       	brne	.+10     	; 0x16cd2 <vfprintf+0x62>
   16cc8:	90 e0       	ldi	r25, 0x00	; 0
   16cca:	b3 01       	movw	r22, r6
   16ccc:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   16cd0:	e7 cf       	rjmp	.-50     	; 0x16ca0 <vfprintf+0x30>
   16cd2:	98 2f       	mov	r25, r24
   16cd4:	ff 24       	eor	r15, r15
   16cd6:	ee 24       	eor	r14, r14
   16cd8:	99 24       	eor	r9, r9
   16cda:	ff e1       	ldi	r31, 0x1F	; 31
   16cdc:	ff 15       	cp	r31, r15
   16cde:	d0 f0       	brcs	.+52     	; 0x16d14 <vfprintf+0xa4>
   16ce0:	9b 32       	cpi	r25, 0x2B	; 43
   16ce2:	69 f0       	breq	.+26     	; 0x16cfe <vfprintf+0x8e>
   16ce4:	9c 32       	cpi	r25, 0x2C	; 44
   16ce6:	28 f4       	brcc	.+10     	; 0x16cf2 <vfprintf+0x82>
   16ce8:	90 32       	cpi	r25, 0x20	; 32
   16cea:	59 f0       	breq	.+22     	; 0x16d02 <vfprintf+0x92>
   16cec:	93 32       	cpi	r25, 0x23	; 35
   16cee:	91 f4       	brne	.+36     	; 0x16d14 <vfprintf+0xa4>
   16cf0:	0e c0       	rjmp	.+28     	; 0x16d0e <vfprintf+0x9e>
   16cf2:	9d 32       	cpi	r25, 0x2D	; 45
   16cf4:	49 f0       	breq	.+18     	; 0x16d08 <vfprintf+0x98>
   16cf6:	90 33       	cpi	r25, 0x30	; 48
   16cf8:	69 f4       	brne	.+26     	; 0x16d14 <vfprintf+0xa4>
   16cfa:	41 e0       	ldi	r20, 0x01	; 1
   16cfc:	24 c0       	rjmp	.+72     	; 0x16d46 <vfprintf+0xd6>
   16cfe:	52 e0       	ldi	r21, 0x02	; 2
   16d00:	f5 2a       	or	r15, r21
   16d02:	84 e0       	ldi	r24, 0x04	; 4
   16d04:	f8 2a       	or	r15, r24
   16d06:	28 c0       	rjmp	.+80     	; 0x16d58 <vfprintf+0xe8>
   16d08:	98 e0       	ldi	r25, 0x08	; 8
   16d0a:	f9 2a       	or	r15, r25
   16d0c:	25 c0       	rjmp	.+74     	; 0x16d58 <vfprintf+0xe8>
   16d0e:	e0 e1       	ldi	r30, 0x10	; 16
   16d10:	fe 2a       	or	r15, r30
   16d12:	22 c0       	rjmp	.+68     	; 0x16d58 <vfprintf+0xe8>
   16d14:	f7 fc       	sbrc	r15, 7
   16d16:	29 c0       	rjmp	.+82     	; 0x16d6a <vfprintf+0xfa>
   16d18:	89 2f       	mov	r24, r25
   16d1a:	80 53       	subi	r24, 0x30	; 48
   16d1c:	8a 30       	cpi	r24, 0x0A	; 10
   16d1e:	70 f4       	brcc	.+28     	; 0x16d3c <vfprintf+0xcc>
   16d20:	f6 fe       	sbrs	r15, 6
   16d22:	05 c0       	rjmp	.+10     	; 0x16d2e <vfprintf+0xbe>
   16d24:	98 9c       	mul	r9, r8
   16d26:	90 2c       	mov	r9, r0
   16d28:	11 24       	eor	r1, r1
   16d2a:	98 0e       	add	r9, r24
   16d2c:	15 c0       	rjmp	.+42     	; 0x16d58 <vfprintf+0xe8>
   16d2e:	e8 9c       	mul	r14, r8
   16d30:	e0 2c       	mov	r14, r0
   16d32:	11 24       	eor	r1, r1
   16d34:	e8 0e       	add	r14, r24
   16d36:	f0 e2       	ldi	r31, 0x20	; 32
   16d38:	ff 2a       	or	r15, r31
   16d3a:	0e c0       	rjmp	.+28     	; 0x16d58 <vfprintf+0xe8>
   16d3c:	9e 32       	cpi	r25, 0x2E	; 46
   16d3e:	29 f4       	brne	.+10     	; 0x16d4a <vfprintf+0xda>
   16d40:	f6 fc       	sbrc	r15, 6
   16d42:	6b c1       	rjmp	.+726    	; 0x1701a <vfprintf+0x3aa>
   16d44:	40 e4       	ldi	r20, 0x40	; 64
   16d46:	f4 2a       	or	r15, r20
   16d48:	07 c0       	rjmp	.+14     	; 0x16d58 <vfprintf+0xe8>
   16d4a:	9c 36       	cpi	r25, 0x6C	; 108
   16d4c:	19 f4       	brne	.+6      	; 0x16d54 <vfprintf+0xe4>
   16d4e:	50 e8       	ldi	r21, 0x80	; 128
   16d50:	f5 2a       	or	r15, r21
   16d52:	02 c0       	rjmp	.+4      	; 0x16d58 <vfprintf+0xe8>
   16d54:	98 36       	cpi	r25, 0x68	; 104
   16d56:	49 f4       	brne	.+18     	; 0x16d6a <vfprintf+0xfa>
   16d58:	f2 01       	movw	r30, r4
   16d5a:	23 fd       	sbrc	r18, 3
   16d5c:	95 91       	lpm	r25, Z+
   16d5e:	23 ff       	sbrs	r18, 3
   16d60:	91 91       	ld	r25, Z+
   16d62:	2f 01       	movw	r4, r30
   16d64:	99 23       	and	r25, r25
   16d66:	09 f0       	breq	.+2      	; 0x16d6a <vfprintf+0xfa>
   16d68:	b8 cf       	rjmp	.-144    	; 0x16cda <vfprintf+0x6a>
   16d6a:	89 2f       	mov	r24, r25
   16d6c:	85 54       	subi	r24, 0x45	; 69
   16d6e:	83 30       	cpi	r24, 0x03	; 3
   16d70:	18 f0       	brcs	.+6      	; 0x16d78 <vfprintf+0x108>
   16d72:	80 52       	subi	r24, 0x20	; 32
   16d74:	83 30       	cpi	r24, 0x03	; 3
   16d76:	38 f4       	brcc	.+14     	; 0x16d86 <vfprintf+0x116>
   16d78:	44 e0       	ldi	r20, 0x04	; 4
   16d7a:	50 e0       	ldi	r21, 0x00	; 0
   16d7c:	a4 0e       	add	r10, r20
   16d7e:	b5 1e       	adc	r11, r21
   16d80:	5f e3       	ldi	r21, 0x3F	; 63
   16d82:	59 83       	std	Y+1, r21	; 0x01
   16d84:	0f c0       	rjmp	.+30     	; 0x16da4 <vfprintf+0x134>
   16d86:	93 36       	cpi	r25, 0x63	; 99
   16d88:	31 f0       	breq	.+12     	; 0x16d96 <vfprintf+0x126>
   16d8a:	93 37       	cpi	r25, 0x73	; 115
   16d8c:	79 f0       	breq	.+30     	; 0x16dac <vfprintf+0x13c>
   16d8e:	93 35       	cpi	r25, 0x53	; 83
   16d90:	09 f0       	breq	.+2      	; 0x16d94 <vfprintf+0x124>
   16d92:	56 c0       	rjmp	.+172    	; 0x16e40 <vfprintf+0x1d0>
   16d94:	20 c0       	rjmp	.+64     	; 0x16dd6 <vfprintf+0x166>
   16d96:	f5 01       	movw	r30, r10
   16d98:	80 81       	ld	r24, Z
   16d9a:	89 83       	std	Y+1, r24	; 0x01
   16d9c:	42 e0       	ldi	r20, 0x02	; 2
   16d9e:	50 e0       	ldi	r21, 0x00	; 0
   16da0:	a4 0e       	add	r10, r20
   16da2:	b5 1e       	adc	r11, r21
   16da4:	61 01       	movw	r12, r2
   16da6:	01 e0       	ldi	r16, 0x01	; 1
   16da8:	10 e0       	ldi	r17, 0x00	; 0
   16daa:	12 c0       	rjmp	.+36     	; 0x16dd0 <vfprintf+0x160>
   16dac:	f5 01       	movw	r30, r10
   16dae:	c0 80       	ld	r12, Z
   16db0:	d1 80       	ldd	r13, Z+1	; 0x01
   16db2:	f6 fc       	sbrc	r15, 6
   16db4:	03 c0       	rjmp	.+6      	; 0x16dbc <vfprintf+0x14c>
   16db6:	6f ef       	ldi	r22, 0xFF	; 255
   16db8:	7f ef       	ldi	r23, 0xFF	; 255
   16dba:	02 c0       	rjmp	.+4      	; 0x16dc0 <vfprintf+0x150>
   16dbc:	69 2d       	mov	r22, r9
   16dbe:	70 e0       	ldi	r23, 0x00	; 0
   16dc0:	42 e0       	ldi	r20, 0x02	; 2
   16dc2:	50 e0       	ldi	r21, 0x00	; 0
   16dc4:	a4 0e       	add	r10, r20
   16dc6:	b5 1e       	adc	r11, r21
   16dc8:	c6 01       	movw	r24, r12
   16dca:	0e 94 20 b8 	call	0x17040	; 0x17040 <strnlen>
   16dce:	8c 01       	movw	r16, r24
   16dd0:	5f e7       	ldi	r21, 0x7F	; 127
   16dd2:	f5 22       	and	r15, r21
   16dd4:	14 c0       	rjmp	.+40     	; 0x16dfe <vfprintf+0x18e>
   16dd6:	f5 01       	movw	r30, r10
   16dd8:	c0 80       	ld	r12, Z
   16dda:	d1 80       	ldd	r13, Z+1	; 0x01
   16ddc:	f6 fc       	sbrc	r15, 6
   16dde:	03 c0       	rjmp	.+6      	; 0x16de6 <vfprintf+0x176>
   16de0:	6f ef       	ldi	r22, 0xFF	; 255
   16de2:	7f ef       	ldi	r23, 0xFF	; 255
   16de4:	02 c0       	rjmp	.+4      	; 0x16dea <vfprintf+0x17a>
   16de6:	69 2d       	mov	r22, r9
   16de8:	70 e0       	ldi	r23, 0x00	; 0
   16dea:	42 e0       	ldi	r20, 0x02	; 2
   16dec:	50 e0       	ldi	r21, 0x00	; 0
   16dee:	a4 0e       	add	r10, r20
   16df0:	b5 1e       	adc	r11, r21
   16df2:	c6 01       	movw	r24, r12
   16df4:	0e 94 15 b8 	call	0x1702a	; 0x1702a <strnlen_P>
   16df8:	8c 01       	movw	r16, r24
   16dfa:	50 e8       	ldi	r21, 0x80	; 128
   16dfc:	f5 2a       	or	r15, r21
   16dfe:	f3 fe       	sbrs	r15, 3
   16e00:	07 c0       	rjmp	.+14     	; 0x16e10 <vfprintf+0x1a0>
   16e02:	1a c0       	rjmp	.+52     	; 0x16e38 <vfprintf+0x1c8>
   16e04:	80 e2       	ldi	r24, 0x20	; 32
   16e06:	90 e0       	ldi	r25, 0x00	; 0
   16e08:	b3 01       	movw	r22, r6
   16e0a:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   16e0e:	ea 94       	dec	r14
   16e10:	8e 2d       	mov	r24, r14
   16e12:	90 e0       	ldi	r25, 0x00	; 0
   16e14:	08 17       	cp	r16, r24
   16e16:	19 07       	cpc	r17, r25
   16e18:	a8 f3       	brcs	.-22     	; 0x16e04 <vfprintf+0x194>
   16e1a:	0e c0       	rjmp	.+28     	; 0x16e38 <vfprintf+0x1c8>
   16e1c:	f6 01       	movw	r30, r12
   16e1e:	f7 fc       	sbrc	r15, 7
   16e20:	85 91       	lpm	r24, Z+
   16e22:	f7 fe       	sbrs	r15, 7
   16e24:	81 91       	ld	r24, Z+
   16e26:	6f 01       	movw	r12, r30
   16e28:	90 e0       	ldi	r25, 0x00	; 0
   16e2a:	b3 01       	movw	r22, r6
   16e2c:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   16e30:	e1 10       	cpse	r14, r1
   16e32:	ea 94       	dec	r14
   16e34:	01 50       	subi	r16, 0x01	; 1
   16e36:	10 40       	sbci	r17, 0x00	; 0
   16e38:	01 15       	cp	r16, r1
   16e3a:	11 05       	cpc	r17, r1
   16e3c:	79 f7       	brne	.-34     	; 0x16e1c <vfprintf+0x1ac>
   16e3e:	ea c0       	rjmp	.+468    	; 0x17014 <vfprintf+0x3a4>
   16e40:	94 36       	cpi	r25, 0x64	; 100
   16e42:	11 f0       	breq	.+4      	; 0x16e48 <vfprintf+0x1d8>
   16e44:	99 36       	cpi	r25, 0x69	; 105
   16e46:	69 f5       	brne	.+90     	; 0x16ea2 <vfprintf+0x232>
   16e48:	f7 fe       	sbrs	r15, 7
   16e4a:	08 c0       	rjmp	.+16     	; 0x16e5c <vfprintf+0x1ec>
   16e4c:	f5 01       	movw	r30, r10
   16e4e:	20 81       	ld	r18, Z
   16e50:	31 81       	ldd	r19, Z+1	; 0x01
   16e52:	42 81       	ldd	r20, Z+2	; 0x02
   16e54:	53 81       	ldd	r21, Z+3	; 0x03
   16e56:	84 e0       	ldi	r24, 0x04	; 4
   16e58:	90 e0       	ldi	r25, 0x00	; 0
   16e5a:	0a c0       	rjmp	.+20     	; 0x16e70 <vfprintf+0x200>
   16e5c:	f5 01       	movw	r30, r10
   16e5e:	80 81       	ld	r24, Z
   16e60:	91 81       	ldd	r25, Z+1	; 0x01
   16e62:	9c 01       	movw	r18, r24
   16e64:	44 27       	eor	r20, r20
   16e66:	37 fd       	sbrc	r19, 7
   16e68:	40 95       	com	r20
   16e6a:	54 2f       	mov	r21, r20
   16e6c:	82 e0       	ldi	r24, 0x02	; 2
   16e6e:	90 e0       	ldi	r25, 0x00	; 0
   16e70:	a8 0e       	add	r10, r24
   16e72:	b9 1e       	adc	r11, r25
   16e74:	9f e6       	ldi	r25, 0x6F	; 111
   16e76:	f9 22       	and	r15, r25
   16e78:	57 ff       	sbrs	r21, 7
   16e7a:	09 c0       	rjmp	.+18     	; 0x16e8e <vfprintf+0x21e>
   16e7c:	50 95       	com	r21
   16e7e:	40 95       	com	r20
   16e80:	30 95       	com	r19
   16e82:	21 95       	neg	r18
   16e84:	3f 4f       	sbci	r19, 0xFF	; 255
   16e86:	4f 4f       	sbci	r20, 0xFF	; 255
   16e88:	5f 4f       	sbci	r21, 0xFF	; 255
   16e8a:	e0 e8       	ldi	r30, 0x80	; 128
   16e8c:	fe 2a       	or	r15, r30
   16e8e:	ca 01       	movw	r24, r20
   16e90:	b9 01       	movw	r22, r18
   16e92:	a1 01       	movw	r20, r2
   16e94:	2a e0       	ldi	r18, 0x0A	; 10
   16e96:	30 e0       	ldi	r19, 0x00	; 0
   16e98:	0e 94 57 b8 	call	0x170ae	; 0x170ae <__ultoa_invert>
   16e9c:	d8 2e       	mov	r13, r24
   16e9e:	d2 18       	sub	r13, r2
   16ea0:	40 c0       	rjmp	.+128    	; 0x16f22 <vfprintf+0x2b2>
   16ea2:	95 37       	cpi	r25, 0x75	; 117
   16ea4:	29 f4       	brne	.+10     	; 0x16eb0 <vfprintf+0x240>
   16ea6:	1f 2d       	mov	r17, r15
   16ea8:	1f 7e       	andi	r17, 0xEF	; 239
   16eaa:	2a e0       	ldi	r18, 0x0A	; 10
   16eac:	30 e0       	ldi	r19, 0x00	; 0
   16eae:	1d c0       	rjmp	.+58     	; 0x16eea <vfprintf+0x27a>
   16eb0:	1f 2d       	mov	r17, r15
   16eb2:	19 7f       	andi	r17, 0xF9	; 249
   16eb4:	9f 36       	cpi	r25, 0x6F	; 111
   16eb6:	61 f0       	breq	.+24     	; 0x16ed0 <vfprintf+0x260>
   16eb8:	90 37       	cpi	r25, 0x70	; 112
   16eba:	20 f4       	brcc	.+8      	; 0x16ec4 <vfprintf+0x254>
   16ebc:	98 35       	cpi	r25, 0x58	; 88
   16ebe:	09 f0       	breq	.+2      	; 0x16ec2 <vfprintf+0x252>
   16ec0:	ac c0       	rjmp	.+344    	; 0x1701a <vfprintf+0x3aa>
   16ec2:	0f c0       	rjmp	.+30     	; 0x16ee2 <vfprintf+0x272>
   16ec4:	90 37       	cpi	r25, 0x70	; 112
   16ec6:	39 f0       	breq	.+14     	; 0x16ed6 <vfprintf+0x266>
   16ec8:	98 37       	cpi	r25, 0x78	; 120
   16eca:	09 f0       	breq	.+2      	; 0x16ece <vfprintf+0x25e>
   16ecc:	a6 c0       	rjmp	.+332    	; 0x1701a <vfprintf+0x3aa>
   16ece:	04 c0       	rjmp	.+8      	; 0x16ed8 <vfprintf+0x268>
   16ed0:	28 e0       	ldi	r18, 0x08	; 8
   16ed2:	30 e0       	ldi	r19, 0x00	; 0
   16ed4:	0a c0       	rjmp	.+20     	; 0x16eea <vfprintf+0x27a>
   16ed6:	10 61       	ori	r17, 0x10	; 16
   16ed8:	14 fd       	sbrc	r17, 4
   16eda:	14 60       	ori	r17, 0x04	; 4
   16edc:	20 e1       	ldi	r18, 0x10	; 16
   16ede:	30 e0       	ldi	r19, 0x00	; 0
   16ee0:	04 c0       	rjmp	.+8      	; 0x16eea <vfprintf+0x27a>
   16ee2:	14 fd       	sbrc	r17, 4
   16ee4:	16 60       	ori	r17, 0x06	; 6
   16ee6:	20 e1       	ldi	r18, 0x10	; 16
   16ee8:	32 e0       	ldi	r19, 0x02	; 2
   16eea:	17 ff       	sbrs	r17, 7
   16eec:	08 c0       	rjmp	.+16     	; 0x16efe <vfprintf+0x28e>
   16eee:	f5 01       	movw	r30, r10
   16ef0:	60 81       	ld	r22, Z
   16ef2:	71 81       	ldd	r23, Z+1	; 0x01
   16ef4:	82 81       	ldd	r24, Z+2	; 0x02
   16ef6:	93 81       	ldd	r25, Z+3	; 0x03
   16ef8:	44 e0       	ldi	r20, 0x04	; 4
   16efa:	50 e0       	ldi	r21, 0x00	; 0
   16efc:	08 c0       	rjmp	.+16     	; 0x16f0e <vfprintf+0x29e>
   16efe:	f5 01       	movw	r30, r10
   16f00:	80 81       	ld	r24, Z
   16f02:	91 81       	ldd	r25, Z+1	; 0x01
   16f04:	bc 01       	movw	r22, r24
   16f06:	80 e0       	ldi	r24, 0x00	; 0
   16f08:	90 e0       	ldi	r25, 0x00	; 0
   16f0a:	42 e0       	ldi	r20, 0x02	; 2
   16f0c:	50 e0       	ldi	r21, 0x00	; 0
   16f0e:	a4 0e       	add	r10, r20
   16f10:	b5 1e       	adc	r11, r21
   16f12:	a1 01       	movw	r20, r2
   16f14:	0e 94 57 b8 	call	0x170ae	; 0x170ae <__ultoa_invert>
   16f18:	d8 2e       	mov	r13, r24
   16f1a:	d2 18       	sub	r13, r2
   16f1c:	8f e7       	ldi	r24, 0x7F	; 127
   16f1e:	f8 2e       	mov	r15, r24
   16f20:	f1 22       	and	r15, r17
   16f22:	f6 fe       	sbrs	r15, 6
   16f24:	0b c0       	rjmp	.+22     	; 0x16f3c <vfprintf+0x2cc>
   16f26:	5e ef       	ldi	r21, 0xFE	; 254
   16f28:	f5 22       	and	r15, r21
   16f2a:	d9 14       	cp	r13, r9
   16f2c:	38 f4       	brcc	.+14     	; 0x16f3c <vfprintf+0x2cc>
   16f2e:	f4 fe       	sbrs	r15, 4
   16f30:	07 c0       	rjmp	.+14     	; 0x16f40 <vfprintf+0x2d0>
   16f32:	f2 fc       	sbrc	r15, 2
   16f34:	05 c0       	rjmp	.+10     	; 0x16f40 <vfprintf+0x2d0>
   16f36:	8f ee       	ldi	r24, 0xEF	; 239
   16f38:	f8 22       	and	r15, r24
   16f3a:	02 c0       	rjmp	.+4      	; 0x16f40 <vfprintf+0x2d0>
   16f3c:	1d 2d       	mov	r17, r13
   16f3e:	01 c0       	rjmp	.+2      	; 0x16f42 <vfprintf+0x2d2>
   16f40:	19 2d       	mov	r17, r9
   16f42:	f4 fe       	sbrs	r15, 4
   16f44:	0d c0       	rjmp	.+26     	; 0x16f60 <vfprintf+0x2f0>
   16f46:	fe 01       	movw	r30, r28
   16f48:	ed 0d       	add	r30, r13
   16f4a:	f1 1d       	adc	r31, r1
   16f4c:	80 81       	ld	r24, Z
   16f4e:	80 33       	cpi	r24, 0x30	; 48
   16f50:	19 f4       	brne	.+6      	; 0x16f58 <vfprintf+0x2e8>
   16f52:	99 ee       	ldi	r25, 0xE9	; 233
   16f54:	f9 22       	and	r15, r25
   16f56:	08 c0       	rjmp	.+16     	; 0x16f68 <vfprintf+0x2f8>
   16f58:	1f 5f       	subi	r17, 0xFF	; 255
   16f5a:	f2 fe       	sbrs	r15, 2
   16f5c:	05 c0       	rjmp	.+10     	; 0x16f68 <vfprintf+0x2f8>
   16f5e:	03 c0       	rjmp	.+6      	; 0x16f66 <vfprintf+0x2f6>
   16f60:	8f 2d       	mov	r24, r15
   16f62:	86 78       	andi	r24, 0x86	; 134
   16f64:	09 f0       	breq	.+2      	; 0x16f68 <vfprintf+0x2f8>
   16f66:	1f 5f       	subi	r17, 0xFF	; 255
   16f68:	0f 2d       	mov	r16, r15
   16f6a:	f3 fc       	sbrc	r15, 3
   16f6c:	14 c0       	rjmp	.+40     	; 0x16f96 <vfprintf+0x326>
   16f6e:	f0 fe       	sbrs	r15, 0
   16f70:	0f c0       	rjmp	.+30     	; 0x16f90 <vfprintf+0x320>
   16f72:	1e 15       	cp	r17, r14
   16f74:	10 f0       	brcs	.+4      	; 0x16f7a <vfprintf+0x30a>
   16f76:	9d 2c       	mov	r9, r13
   16f78:	0b c0       	rjmp	.+22     	; 0x16f90 <vfprintf+0x320>
   16f7a:	9d 2c       	mov	r9, r13
   16f7c:	9e 0c       	add	r9, r14
   16f7e:	91 1a       	sub	r9, r17
   16f80:	1e 2d       	mov	r17, r14
   16f82:	06 c0       	rjmp	.+12     	; 0x16f90 <vfprintf+0x320>
   16f84:	80 e2       	ldi	r24, 0x20	; 32
   16f86:	90 e0       	ldi	r25, 0x00	; 0
   16f88:	b3 01       	movw	r22, r6
   16f8a:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   16f8e:	1f 5f       	subi	r17, 0xFF	; 255
   16f90:	1e 15       	cp	r17, r14
   16f92:	c0 f3       	brcs	.-16     	; 0x16f84 <vfprintf+0x314>
   16f94:	04 c0       	rjmp	.+8      	; 0x16f9e <vfprintf+0x32e>
   16f96:	1e 15       	cp	r17, r14
   16f98:	10 f4       	brcc	.+4      	; 0x16f9e <vfprintf+0x32e>
   16f9a:	e1 1a       	sub	r14, r17
   16f9c:	01 c0       	rjmp	.+2      	; 0x16fa0 <vfprintf+0x330>
   16f9e:	ee 24       	eor	r14, r14
   16fa0:	04 ff       	sbrs	r16, 4
   16fa2:	0f c0       	rjmp	.+30     	; 0x16fc2 <vfprintf+0x352>
   16fa4:	80 e3       	ldi	r24, 0x30	; 48
   16fa6:	90 e0       	ldi	r25, 0x00	; 0
   16fa8:	b3 01       	movw	r22, r6
   16faa:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   16fae:	02 ff       	sbrs	r16, 2
   16fb0:	1d c0       	rjmp	.+58     	; 0x16fec <vfprintf+0x37c>
   16fb2:	01 fd       	sbrc	r16, 1
   16fb4:	03 c0       	rjmp	.+6      	; 0x16fbc <vfprintf+0x34c>
   16fb6:	88 e7       	ldi	r24, 0x78	; 120
   16fb8:	90 e0       	ldi	r25, 0x00	; 0
   16fba:	0e c0       	rjmp	.+28     	; 0x16fd8 <vfprintf+0x368>
   16fbc:	88 e5       	ldi	r24, 0x58	; 88
   16fbe:	90 e0       	ldi	r25, 0x00	; 0
   16fc0:	0b c0       	rjmp	.+22     	; 0x16fd8 <vfprintf+0x368>
   16fc2:	80 2f       	mov	r24, r16
   16fc4:	86 78       	andi	r24, 0x86	; 134
   16fc6:	91 f0       	breq	.+36     	; 0x16fec <vfprintf+0x37c>
   16fc8:	01 ff       	sbrs	r16, 1
   16fca:	02 c0       	rjmp	.+4      	; 0x16fd0 <vfprintf+0x360>
   16fcc:	8b e2       	ldi	r24, 0x2B	; 43
   16fce:	01 c0       	rjmp	.+2      	; 0x16fd2 <vfprintf+0x362>
   16fd0:	80 e2       	ldi	r24, 0x20	; 32
   16fd2:	f7 fc       	sbrc	r15, 7
   16fd4:	8d e2       	ldi	r24, 0x2D	; 45
   16fd6:	90 e0       	ldi	r25, 0x00	; 0
   16fd8:	b3 01       	movw	r22, r6
   16fda:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   16fde:	06 c0       	rjmp	.+12     	; 0x16fec <vfprintf+0x37c>
   16fe0:	80 e3       	ldi	r24, 0x30	; 48
   16fe2:	90 e0       	ldi	r25, 0x00	; 0
   16fe4:	b3 01       	movw	r22, r6
   16fe6:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   16fea:	9a 94       	dec	r9
   16fec:	d9 14       	cp	r13, r9
   16fee:	c0 f3       	brcs	.-16     	; 0x16fe0 <vfprintf+0x370>
   16ff0:	da 94       	dec	r13
   16ff2:	f1 01       	movw	r30, r2
   16ff4:	ed 0d       	add	r30, r13
   16ff6:	f1 1d       	adc	r31, r1
   16ff8:	80 81       	ld	r24, Z
   16ffa:	90 e0       	ldi	r25, 0x00	; 0
   16ffc:	b3 01       	movw	r22, r6
   16ffe:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   17002:	dd 20       	and	r13, r13
   17004:	a9 f7       	brne	.-22     	; 0x16ff0 <vfprintf+0x380>
   17006:	06 c0       	rjmp	.+12     	; 0x17014 <vfprintf+0x3a4>
   17008:	80 e2       	ldi	r24, 0x20	; 32
   1700a:	90 e0       	ldi	r25, 0x00	; 0
   1700c:	b3 01       	movw	r22, r6
   1700e:	0e 94 2b b8 	call	0x17056	; 0x17056 <fputc>
   17012:	ea 94       	dec	r14
   17014:	ee 20       	and	r14, r14
   17016:	c1 f7       	brne	.-16     	; 0x17008 <vfprintf+0x398>
   17018:	43 ce       	rjmp	.-890    	; 0x16ca0 <vfprintf+0x30>
   1701a:	f3 01       	movw	r30, r6
   1701c:	66 81       	ldd	r22, Z+6	; 0x06
   1701e:	77 81       	ldd	r23, Z+7	; 0x07
   17020:	cb 01       	movw	r24, r22
   17022:	2b 96       	adiw	r28, 0x0b	; 11
   17024:	e2 e1       	ldi	r30, 0x12	; 18
   17026:	0c 94 52 b9 	jmp	0x172a4	; 0x172a4 <__epilogue_restores__>

0001702a <strnlen_P>:
   1702a:	fc 01       	movw	r30, r24
   1702c:	05 90       	lpm	r0, Z+
   1702e:	61 50       	subi	r22, 0x01	; 1
   17030:	70 40       	sbci	r23, 0x00	; 0
   17032:	01 10       	cpse	r0, r1
   17034:	d8 f7       	brcc	.-10     	; 0x1702c <strnlen_P+0x2>
   17036:	80 95       	com	r24
   17038:	90 95       	com	r25
   1703a:	8e 0f       	add	r24, r30
   1703c:	9f 1f       	adc	r25, r31
   1703e:	08 95       	ret

00017040 <strnlen>:
   17040:	fc 01       	movw	r30, r24
   17042:	61 50       	subi	r22, 0x01	; 1
   17044:	70 40       	sbci	r23, 0x00	; 0
   17046:	01 90       	ld	r0, Z+
   17048:	01 10       	cpse	r0, r1
   1704a:	d8 f7       	brcc	.-10     	; 0x17042 <strnlen+0x2>
   1704c:	80 95       	com	r24
   1704e:	90 95       	com	r25
   17050:	8e 0f       	add	r24, r30
   17052:	9f 1f       	adc	r25, r31
   17054:	08 95       	ret

00017056 <fputc>:
   17056:	0f 93       	push	r16
   17058:	1f 93       	push	r17
   1705a:	cf 93       	push	r28
   1705c:	df 93       	push	r29
   1705e:	8c 01       	movw	r16, r24
   17060:	eb 01       	movw	r28, r22
   17062:	8b 81       	ldd	r24, Y+3	; 0x03
   17064:	81 ff       	sbrs	r24, 1
   17066:	1b c0       	rjmp	.+54     	; 0x1709e <fputc+0x48>
   17068:	82 ff       	sbrs	r24, 2
   1706a:	0d c0       	rjmp	.+26     	; 0x17086 <fputc+0x30>
   1706c:	2e 81       	ldd	r18, Y+6	; 0x06
   1706e:	3f 81       	ldd	r19, Y+7	; 0x07
   17070:	8c 81       	ldd	r24, Y+4	; 0x04
   17072:	9d 81       	ldd	r25, Y+5	; 0x05
   17074:	28 17       	cp	r18, r24
   17076:	39 07       	cpc	r19, r25
   17078:	64 f4       	brge	.+24     	; 0x17092 <fputc+0x3c>
   1707a:	e8 81       	ld	r30, Y
   1707c:	f9 81       	ldd	r31, Y+1	; 0x01
   1707e:	01 93       	st	Z+, r16
   17080:	f9 83       	std	Y+1, r31	; 0x01
   17082:	e8 83       	st	Y, r30
   17084:	06 c0       	rjmp	.+12     	; 0x17092 <fputc+0x3c>
   17086:	e8 85       	ldd	r30, Y+8	; 0x08
   17088:	f9 85       	ldd	r31, Y+9	; 0x09
   1708a:	80 2f       	mov	r24, r16
   1708c:	09 95       	icall
   1708e:	89 2b       	or	r24, r25
   17090:	31 f4       	brne	.+12     	; 0x1709e <fputc+0x48>
   17092:	8e 81       	ldd	r24, Y+6	; 0x06
   17094:	9f 81       	ldd	r25, Y+7	; 0x07
   17096:	01 96       	adiw	r24, 0x01	; 1
   17098:	9f 83       	std	Y+7, r25	; 0x07
   1709a:	8e 83       	std	Y+6, r24	; 0x06
   1709c:	02 c0       	rjmp	.+4      	; 0x170a2 <fputc+0x4c>
   1709e:	0f ef       	ldi	r16, 0xFF	; 255
   170a0:	1f ef       	ldi	r17, 0xFF	; 255
   170a2:	c8 01       	movw	r24, r16
   170a4:	df 91       	pop	r29
   170a6:	cf 91       	pop	r28
   170a8:	1f 91       	pop	r17
   170aa:	0f 91       	pop	r16
   170ac:	08 95       	ret

000170ae <__ultoa_invert>:
   170ae:	fa 01       	movw	r30, r20
   170b0:	aa 27       	eor	r26, r26
   170b2:	28 30       	cpi	r18, 0x08	; 8
   170b4:	51 f1       	breq	.+84     	; 0x1710a <__ultoa_invert+0x5c>
   170b6:	20 31       	cpi	r18, 0x10	; 16
   170b8:	81 f1       	breq	.+96     	; 0x1711a <__ultoa_invert+0x6c>
   170ba:	e8 94       	clt
   170bc:	6f 93       	push	r22
   170be:	6e 7f       	andi	r22, 0xFE	; 254
   170c0:	6e 5f       	subi	r22, 0xFE	; 254
   170c2:	7f 4f       	sbci	r23, 0xFF	; 255
   170c4:	8f 4f       	sbci	r24, 0xFF	; 255
   170c6:	9f 4f       	sbci	r25, 0xFF	; 255
   170c8:	af 4f       	sbci	r26, 0xFF	; 255
   170ca:	b1 e0       	ldi	r27, 0x01	; 1
   170cc:	3e d0       	rcall	.+124    	; 0x1714a <__ultoa_invert+0x9c>
   170ce:	b4 e0       	ldi	r27, 0x04	; 4
   170d0:	3c d0       	rcall	.+120    	; 0x1714a <__ultoa_invert+0x9c>
   170d2:	67 0f       	add	r22, r23
   170d4:	78 1f       	adc	r23, r24
   170d6:	89 1f       	adc	r24, r25
   170d8:	9a 1f       	adc	r25, r26
   170da:	a1 1d       	adc	r26, r1
   170dc:	68 0f       	add	r22, r24
   170de:	79 1f       	adc	r23, r25
   170e0:	8a 1f       	adc	r24, r26
   170e2:	91 1d       	adc	r25, r1
   170e4:	a1 1d       	adc	r26, r1
   170e6:	6a 0f       	add	r22, r26
   170e8:	71 1d       	adc	r23, r1
   170ea:	81 1d       	adc	r24, r1
   170ec:	91 1d       	adc	r25, r1
   170ee:	a1 1d       	adc	r26, r1
   170f0:	20 d0       	rcall	.+64     	; 0x17132 <__ultoa_invert+0x84>
   170f2:	09 f4       	brne	.+2      	; 0x170f6 <__ultoa_invert+0x48>
   170f4:	68 94       	set
   170f6:	3f 91       	pop	r19
   170f8:	2a e0       	ldi	r18, 0x0A	; 10
   170fa:	26 9f       	mul	r18, r22
   170fc:	11 24       	eor	r1, r1
   170fe:	30 19       	sub	r19, r0
   17100:	30 5d       	subi	r19, 0xD0	; 208
   17102:	31 93       	st	Z+, r19
   17104:	de f6       	brtc	.-74     	; 0x170bc <__ultoa_invert+0xe>
   17106:	cf 01       	movw	r24, r30
   17108:	08 95       	ret
   1710a:	46 2f       	mov	r20, r22
   1710c:	47 70       	andi	r20, 0x07	; 7
   1710e:	40 5d       	subi	r20, 0xD0	; 208
   17110:	41 93       	st	Z+, r20
   17112:	b3 e0       	ldi	r27, 0x03	; 3
   17114:	0f d0       	rcall	.+30     	; 0x17134 <__ultoa_invert+0x86>
   17116:	c9 f7       	brne	.-14     	; 0x1710a <__ultoa_invert+0x5c>
   17118:	f6 cf       	rjmp	.-20     	; 0x17106 <__ultoa_invert+0x58>
   1711a:	46 2f       	mov	r20, r22
   1711c:	4f 70       	andi	r20, 0x0F	; 15
   1711e:	40 5d       	subi	r20, 0xD0	; 208
   17120:	4a 33       	cpi	r20, 0x3A	; 58
   17122:	18 f0       	brcs	.+6      	; 0x1712a <__ultoa_invert+0x7c>
   17124:	49 5d       	subi	r20, 0xD9	; 217
   17126:	31 fd       	sbrc	r19, 1
   17128:	40 52       	subi	r20, 0x20	; 32
   1712a:	41 93       	st	Z+, r20
   1712c:	02 d0       	rcall	.+4      	; 0x17132 <__ultoa_invert+0x84>
   1712e:	a9 f7       	brne	.-22     	; 0x1711a <__ultoa_invert+0x6c>
   17130:	ea cf       	rjmp	.-44     	; 0x17106 <__ultoa_invert+0x58>
   17132:	b4 e0       	ldi	r27, 0x04	; 4
   17134:	a6 95       	lsr	r26
   17136:	97 95       	ror	r25
   17138:	87 95       	ror	r24
   1713a:	77 95       	ror	r23
   1713c:	67 95       	ror	r22
   1713e:	ba 95       	dec	r27
   17140:	c9 f7       	brne	.-14     	; 0x17134 <__ultoa_invert+0x86>
   17142:	00 97       	sbiw	r24, 0x00	; 0
   17144:	61 05       	cpc	r22, r1
   17146:	71 05       	cpc	r23, r1
   17148:	08 95       	ret
   1714a:	9b 01       	movw	r18, r22
   1714c:	ac 01       	movw	r20, r24
   1714e:	0a 2e       	mov	r0, r26
   17150:	06 94       	lsr	r0
   17152:	57 95       	ror	r21
   17154:	47 95       	ror	r20
   17156:	37 95       	ror	r19
   17158:	27 95       	ror	r18
   1715a:	ba 95       	dec	r27
   1715c:	c9 f7       	brne	.-14     	; 0x17150 <__ultoa_invert+0xa2>
   1715e:	62 0f       	add	r22, r18
   17160:	73 1f       	adc	r23, r19
   17162:	84 1f       	adc	r24, r20
   17164:	95 1f       	adc	r25, r21
   17166:	a0 1d       	adc	r26, r0
   17168:	08 95       	ret

0001716a <__mulsi3>:
   1716a:	62 9f       	mul	r22, r18
   1716c:	d0 01       	movw	r26, r0
   1716e:	73 9f       	mul	r23, r19
   17170:	f0 01       	movw	r30, r0
   17172:	82 9f       	mul	r24, r18
   17174:	e0 0d       	add	r30, r0
   17176:	f1 1d       	adc	r31, r1
   17178:	64 9f       	mul	r22, r20
   1717a:	e0 0d       	add	r30, r0
   1717c:	f1 1d       	adc	r31, r1
   1717e:	92 9f       	mul	r25, r18
   17180:	f0 0d       	add	r31, r0
   17182:	83 9f       	mul	r24, r19
   17184:	f0 0d       	add	r31, r0
   17186:	74 9f       	mul	r23, r20
   17188:	f0 0d       	add	r31, r0
   1718a:	65 9f       	mul	r22, r21
   1718c:	f0 0d       	add	r31, r0
   1718e:	99 27       	eor	r25, r25
   17190:	72 9f       	mul	r23, r18
   17192:	b0 0d       	add	r27, r0
   17194:	e1 1d       	adc	r30, r1
   17196:	f9 1f       	adc	r31, r25
   17198:	63 9f       	mul	r22, r19
   1719a:	b0 0d       	add	r27, r0
   1719c:	e1 1d       	adc	r30, r1
   1719e:	f9 1f       	adc	r31, r25
   171a0:	bd 01       	movw	r22, r26
   171a2:	cf 01       	movw	r24, r30
   171a4:	11 24       	eor	r1, r1
   171a6:	08 95       	ret

000171a8 <__udivmodqi4>:
   171a8:	99 1b       	sub	r25, r25
   171aa:	79 e0       	ldi	r23, 0x09	; 9
   171ac:	04 c0       	rjmp	.+8      	; 0x171b6 <__udivmodqi4_ep>

000171ae <__udivmodqi4_loop>:
   171ae:	99 1f       	adc	r25, r25
   171b0:	96 17       	cp	r25, r22
   171b2:	08 f0       	brcs	.+2      	; 0x171b6 <__udivmodqi4_ep>
   171b4:	96 1b       	sub	r25, r22

000171b6 <__udivmodqi4_ep>:
   171b6:	88 1f       	adc	r24, r24
   171b8:	7a 95       	dec	r23
   171ba:	c9 f7       	brne	.-14     	; 0x171ae <__udivmodqi4_loop>
   171bc:	80 95       	com	r24
   171be:	08 95       	ret

000171c0 <__divmodqi4>:
   171c0:	87 fb       	bst	r24, 7
   171c2:	08 2e       	mov	r0, r24
   171c4:	06 26       	eor	r0, r22
   171c6:	87 fd       	sbrc	r24, 7
   171c8:	81 95       	neg	r24
   171ca:	67 fd       	sbrc	r22, 7
   171cc:	61 95       	neg	r22
   171ce:	ec df       	rcall	.-40     	; 0x171a8 <__udivmodqi4>
   171d0:	0e f4       	brtc	.+2      	; 0x171d4 <__divmodqi4_1>
   171d2:	91 95       	neg	r25

000171d4 <__divmodqi4_1>:
   171d4:	07 fc       	sbrc	r0, 7
   171d6:	81 95       	neg	r24

000171d8 <__divmodqi4_exit>:
   171d8:	08 95       	ret

000171da <__udivmodhi4>:
   171da:	aa 1b       	sub	r26, r26
   171dc:	bb 1b       	sub	r27, r27
   171de:	51 e1       	ldi	r21, 0x11	; 17
   171e0:	07 c0       	rjmp	.+14     	; 0x171f0 <__udivmodhi4_ep>

000171e2 <__udivmodhi4_loop>:
   171e2:	aa 1f       	adc	r26, r26
   171e4:	bb 1f       	adc	r27, r27
   171e6:	a6 17       	cp	r26, r22
   171e8:	b7 07       	cpc	r27, r23
   171ea:	10 f0       	brcs	.+4      	; 0x171f0 <__udivmodhi4_ep>
   171ec:	a6 1b       	sub	r26, r22
   171ee:	b7 0b       	sbc	r27, r23

000171f0 <__udivmodhi4_ep>:
   171f0:	88 1f       	adc	r24, r24
   171f2:	99 1f       	adc	r25, r25
   171f4:	5a 95       	dec	r21
   171f6:	a9 f7       	brne	.-22     	; 0x171e2 <__udivmodhi4_loop>
   171f8:	80 95       	com	r24
   171fa:	90 95       	com	r25
   171fc:	bc 01       	movw	r22, r24
   171fe:	cd 01       	movw	r24, r26
   17200:	08 95       	ret

00017202 <__divmodhi4>:
   17202:	97 fb       	bst	r25, 7
   17204:	09 2e       	mov	r0, r25
   17206:	07 26       	eor	r0, r23
   17208:	0a d0       	rcall	.+20     	; 0x1721e <__divmodhi4_neg1>
   1720a:	77 fd       	sbrc	r23, 7
   1720c:	04 d0       	rcall	.+8      	; 0x17216 <__divmodhi4_neg2>
   1720e:	e5 df       	rcall	.-54     	; 0x171da <__udivmodhi4>
   17210:	06 d0       	rcall	.+12     	; 0x1721e <__divmodhi4_neg1>
   17212:	00 20       	and	r0, r0
   17214:	1a f4       	brpl	.+6      	; 0x1721c <__divmodhi4_exit>

00017216 <__divmodhi4_neg2>:
   17216:	70 95       	com	r23
   17218:	61 95       	neg	r22
   1721a:	7f 4f       	sbci	r23, 0xFF	; 255

0001721c <__divmodhi4_exit>:
   1721c:	08 95       	ret

0001721e <__divmodhi4_neg1>:
   1721e:	f6 f7       	brtc	.-4      	; 0x1721c <__divmodhi4_exit>
   17220:	90 95       	com	r25
   17222:	81 95       	neg	r24
   17224:	9f 4f       	sbci	r25, 0xFF	; 255
   17226:	08 95       	ret

00017228 <__udivmodsi4>:
   17228:	a1 e2       	ldi	r26, 0x21	; 33
   1722a:	1a 2e       	mov	r1, r26
   1722c:	aa 1b       	sub	r26, r26
   1722e:	bb 1b       	sub	r27, r27
   17230:	fd 01       	movw	r30, r26
   17232:	0d c0       	rjmp	.+26     	; 0x1724e <__udivmodsi4_ep>

00017234 <__udivmodsi4_loop>:
   17234:	aa 1f       	adc	r26, r26
   17236:	bb 1f       	adc	r27, r27
   17238:	ee 1f       	adc	r30, r30
   1723a:	ff 1f       	adc	r31, r31
   1723c:	a2 17       	cp	r26, r18
   1723e:	b3 07       	cpc	r27, r19
   17240:	e4 07       	cpc	r30, r20
   17242:	f5 07       	cpc	r31, r21
   17244:	20 f0       	brcs	.+8      	; 0x1724e <__udivmodsi4_ep>
   17246:	a2 1b       	sub	r26, r18
   17248:	b3 0b       	sbc	r27, r19
   1724a:	e4 0b       	sbc	r30, r20
   1724c:	f5 0b       	sbc	r31, r21

0001724e <__udivmodsi4_ep>:
   1724e:	66 1f       	adc	r22, r22
   17250:	77 1f       	adc	r23, r23
   17252:	88 1f       	adc	r24, r24
   17254:	99 1f       	adc	r25, r25
   17256:	1a 94       	dec	r1
   17258:	69 f7       	brne	.-38     	; 0x17234 <__udivmodsi4_loop>
   1725a:	60 95       	com	r22
   1725c:	70 95       	com	r23
   1725e:	80 95       	com	r24
   17260:	90 95       	com	r25
   17262:	9b 01       	movw	r18, r22
   17264:	ac 01       	movw	r20, r24
   17266:	bd 01       	movw	r22, r26
   17268:	cf 01       	movw	r24, r30
   1726a:	08 95       	ret

0001726c <__prologue_saves__>:
   1726c:	2f 92       	push	r2
   1726e:	3f 92       	push	r3
   17270:	4f 92       	push	r4
   17272:	5f 92       	push	r5
   17274:	6f 92       	push	r6
   17276:	7f 92       	push	r7
   17278:	8f 92       	push	r8
   1727a:	9f 92       	push	r9
   1727c:	af 92       	push	r10
   1727e:	bf 92       	push	r11
   17280:	cf 92       	push	r12
   17282:	df 92       	push	r13
   17284:	ef 92       	push	r14
   17286:	ff 92       	push	r15
   17288:	0f 93       	push	r16
   1728a:	1f 93       	push	r17
   1728c:	cf 93       	push	r28
   1728e:	df 93       	push	r29
   17290:	cd b7       	in	r28, 0x3d	; 61
   17292:	de b7       	in	r29, 0x3e	; 62
   17294:	ca 1b       	sub	r28, r26
   17296:	db 0b       	sbc	r29, r27
   17298:	0f b6       	in	r0, 0x3f	; 63
   1729a:	f8 94       	cli
   1729c:	de bf       	out	0x3e, r29	; 62
   1729e:	0f be       	out	0x3f, r0	; 63
   172a0:	cd bf       	out	0x3d, r28	; 61
   172a2:	09 94       	ijmp

000172a4 <__epilogue_restores__>:
   172a4:	2a 88       	ldd	r2, Y+18	; 0x12
   172a6:	39 88       	ldd	r3, Y+17	; 0x11
   172a8:	48 88       	ldd	r4, Y+16	; 0x10
   172aa:	5f 84       	ldd	r5, Y+15	; 0x0f
   172ac:	6e 84       	ldd	r6, Y+14	; 0x0e
   172ae:	7d 84       	ldd	r7, Y+13	; 0x0d
   172b0:	8c 84       	ldd	r8, Y+12	; 0x0c
   172b2:	9b 84       	ldd	r9, Y+11	; 0x0b
   172b4:	aa 84       	ldd	r10, Y+10	; 0x0a
   172b6:	b9 84       	ldd	r11, Y+9	; 0x09
   172b8:	c8 84       	ldd	r12, Y+8	; 0x08
   172ba:	df 80       	ldd	r13, Y+7	; 0x07
   172bc:	ee 80       	ldd	r14, Y+6	; 0x06
   172be:	fd 80       	ldd	r15, Y+5	; 0x05
   172c0:	0c 81       	ldd	r16, Y+4	; 0x04
   172c2:	1b 81       	ldd	r17, Y+3	; 0x03
   172c4:	aa 81       	ldd	r26, Y+2	; 0x02
   172c6:	b9 81       	ldd	r27, Y+1	; 0x01
   172c8:	ce 0f       	add	r28, r30
   172ca:	d1 1d       	adc	r29, r1
   172cc:	0f b6       	in	r0, 0x3f	; 63
   172ce:	f8 94       	cli
   172d0:	de bf       	out	0x3e, r29	; 62
   172d2:	0f be       	out	0x3f, r0	; 63
   172d4:	cd bf       	out	0x3d, r28	; 61
   172d6:	ed 01       	movw	r28, r26
   172d8:	08 95       	ret

000172da <_exit>:
   172da:	f8 94       	cli

000172dc <__stop_program>:
   172dc:	ff cf       	rjmp	.-2      	; 0x172dc <__stop_program>
