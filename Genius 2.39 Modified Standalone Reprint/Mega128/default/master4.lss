
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005c  00800100  00015b0e  00015bc2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00015b0e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000b57  0080015c  0080015c  00015c1e  2**0
                  ALLOC
  3 .eeprom       00000857  00810000  00810000  00015c1e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  00016475  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000024d7  00000000  00000000  00016555  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012aa3  00000000  00000000  00018a2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b97  00000000  00000000  0002b4cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000d8d4  00000000  00000000  0002c066  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000011b0  00000000  00000000  0003993c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000051ee  00000000  00000000  0003aaec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007806  00000000  00000000  0003fcda  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006c0  00000000  00000000  000474e0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8f 11 	jmp	0x231e	; 0x231e <__ctors_end>
       4:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
       8:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
       c:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      10:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      14:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      18:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      1c:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      20:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      24:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      28:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      2c:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      30:	0c 94 58 12 	jmp	0x24b0	; 0x24b0 <__vector_12>
      34:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      38:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      3c:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      40:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      44:	0c 94 6d 66 	jmp	0xccda	; 0xccda <__vector_17>
      48:	0c 94 f2 13 	jmp	0x27e4	; 0x27e4 <__vector_18>
      4c:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      50:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      54:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      58:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      5c:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      60:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      64:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      68:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      6c:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      70:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      74:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      78:	0c 94 86 3f 	jmp	0x7f0c	; 0x7f0c <__vector_30>
      7c:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      80:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      84:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      88:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__bad_interrupt>
      8c:	d3 12       	cpse	r13, r19
      8e:	d1 12       	cpse	r13, r17
      90:	d5 12       	cpse	r13, r21
      92:	d7 12       	cpse	r13, r23
      94:	d9 12       	cpse	r13, r25
      96:	db 12       	cpse	r13, r27
      98:	dd 12       	cpse	r13, r29
      9a:	df 12       	cpse	r13, r31
      9c:	e1 12       	cpse	r14, r17
      9e:	e3 12       	cpse	r14, r19
      a0:	e5 12       	cpse	r14, r21
      a2:	e7 12       	cpse	r14, r23
      a4:	e9 12       	cpse	r14, r25
      a6:	f7 12       	cpse	r15, r23
      a8:	eb 12       	cpse	r14, r27
      aa:	f7 12       	cpse	r15, r23
      ac:	ed 12       	cpse	r14, r29
      ae:	ef 12       	cpse	r14, r31
      b0:	f7 12       	cpse	r15, r23
      b2:	f1 12       	cpse	r15, r17
      b4:	f3 12       	cpse	r15, r19
      b6:	f5 12       	cpse	r15, r21
      b8:	f7 12       	cpse	r15, r23
      ba:	f7 12       	cpse	r15, r23
      bc:	eb 12       	cpse	r14, r27
      be:	dd 12       	cpse	r13, r29
      c0:	f7 12       	cpse	r15, r23
      c2:	df 12       	cpse	r13, r31
      c4:	e3 12       	cpse	r14, r19
      c6:	e7 12       	cpse	r14, r23
      c8:	b4 72       	andi	r27, 0x24	; 36
      ca:	d0 72       	andi	r29, 0x20	; 32
      cc:	e3 72       	andi	r30, 0x23	; 35
      ce:	12 73       	andi	r17, 0x32	; 50
      d0:	3b 73       	andi	r19, 0x3B	; 59
      d2:	ae 73       	andi	r26, 0x3E	; 62
      d4:	bd 73       	andi	r27, 0x3D	; 61
      d6:	c6 73       	andi	r28, 0x36	; 54
      d8:	02 74       	andi	r16, 0x42	; 66
      da:	29 74       	andi	r18, 0x49	; 73
      dc:	70 74       	andi	r23, 0x40	; 64
      de:	7a 74       	andi	r23, 0x4A	; 74
      e0:	35 74       	andi	r19, 0x45	; 69
      e2:	80 74       	andi	r24, 0x40	; 64
      e4:	e0 72       	andi	r30, 0x20	; 32
      e6:	8f 74       	andi	r24, 0x4F	; 79
      e8:	95 74       	andi	r25, 0x45	; 69
      ea:	4c 77       	andi	r20, 0x7C	; 124
      ec:	52 77       	andi	r21, 0x72	; 114
      ee:	56 77       	andi	r21, 0x76	; 118
      f0:	6d 77       	andi	r22, 0x7D	; 125
      f2:	87 77       	andi	r24, 0x77	; 119
      f4:	8b 77       	andi	r24, 0x7B	; 123
      f6:	b6 77       	andi	r27, 0x76	; 118
      f8:	d0 77       	andi	r29, 0x70	; 112
      fa:	d6 77       	andi	r29, 0x76	; 118
      fc:	de 77       	andi	r29, 0x7E	; 126
      fe:	e1 77       	andi	r30, 0x71	; 113
     100:	e4 77       	andi	r30, 0x74	; 116
     102:	e7 77       	andi	r30, 0x77	; 119
     104:	ea 77       	andi	r30, 0x7A	; 122
     106:	ed 77       	andi	r30, 0x7D	; 125
     108:	f1 77       	andi	r31, 0x71	; 113
     10a:	f4 77       	andi	r31, 0x74	; 116
     10c:	f7 77       	andi	r31, 0x77	; 119
     10e:	ff 77       	andi	r31, 0x7F	; 127
     110:	6f 7e       	andi	r22, 0xEF	; 239
     112:	c4 7e       	andi	r28, 0xE4	; 228
     114:	d3 7e       	andi	r29, 0xE3	; 227
     116:	15 7f       	andi	r17, 0xF5	; 245
     118:	27 7f       	andi	r18, 0xF7	; 247
     11a:	3c 7f       	andi	r19, 0xFC	; 252
     11c:	5f 7f       	andi	r21, 0xFF	; 255
     11e:	15 80       	ldd	r1, Z+5	; 0x05
     120:	1f 80       	ldd	r1, Y+7	; 0x07
     122:	f3 86       	std	Z+11, r15	; 0x0b
     124:	7e 80       	ldd	r7, Y+6	; 0x06
     126:	8b 81       	ldd	r24, Y+3	; 0x03
     128:	da 81       	ldd	r29, Y+2	; 0x02
     12a:	20 82       	st	Z, r2
     12c:	98 82       	st	Y, r9
     12e:	29 83       	std	Y+1, r18	; 0x01
     130:	4c 83       	std	Y+4, r20	; 0x04
     132:	12 84       	ldd	r1, Z+10	; 0x0a
     134:	3c 84       	ldd	r3, Y+12	; 0x0c
     136:	f5 84       	ldd	r15, Z+13	; 0x0d
     138:	0e 85       	ldd	r16, Y+14	; 0x0e
     13a:	18 86       	std	Y+8, r1	; 0x08
     13c:	86 85       	ldd	r24, Z+14	; 0x0e
     13e:	c8 85       	ldd	r28, Y+8	; 0x08
     140:	b2 86       	std	Z+10, r11	; 0x0a
     142:	e0 86       	std	Z+8, r14	; 0x08
     144:	f3 86       	std	Z+11, r15	; 0x0b
     146:	1e 86       	std	Y+14, r1	; 0x0e
     148:	a1 86       	std	Z+9, r10	; 0x09
     14a:	e5 86       	std	Z+13, r14	; 0x0d
     14c:	ec 86       	std	Y+12, r14	; 0x0c
     14e:	2f 87       	std	Y+15, r18	; 0x0f
     150:	33 87       	std	Z+11, r19	; 0x0b
     152:	4f 87       	std	Y+15, r20	; 0x0f
     154:	33 8b       	std	Z+19, r19	; 0x13
     156:	33 8b       	std	Z+19, r19	; 0x13
     158:	33 8b       	std	Z+19, r19	; 0x13
     15a:	33 8b       	std	Z+19, r19	; 0x13
     15c:	98 87       	std	Y+8, r25	; 0x08
     15e:	33 8b       	std	Z+19, r19	; 0x13
     160:	b8 87       	std	Y+8, r27	; 0x08
     162:	33 8b       	std	Z+19, r19	; 0x13
     164:	d5 87       	std	Z+13, r29	; 0x0d
     166:	5e 88       	ldd	r5, Y+22	; 0x16
     168:	b9 88       	ldd	r11, Y+17	; 0x11
     16a:	dc 88       	ldd	r13, Y+20	; 0x14
     16c:	7b 87       	std	Y+11, r23	; 0x0b
     16e:	33 8b       	std	Z+19, r19	; 0x13
     170:	71 88       	ldd	r7, Z+17	; 0x11
     172:	f4 88       	ldd	r15, Z+20	; 0x14
     174:	2c 89       	ldd	r18, Y+20	; 0x14
     176:	44 89       	ldd	r20, Z+20	; 0x14
     178:	80 89       	ldd	r24, Z+16	; 0x10
     17a:	90 89       	ldd	r25, Z+16	; 0x10
     17c:	a1 8a       	std	Z+17, r10	; 0x11
     17e:	b1 8a       	std	Z+17, r11	; 0x11
     180:	f6 8a       	std	Z+22, r15	; 0x16
     182:	15 8b       	std	Z+21, r17	; 0x15
     184:	27 8b       	std	Z+23, r18	; 0x17
     186:	2d 8b       	std	Y+21, r18	; 0x15
     188:	2f 8b       	std	Y+23, r18	; 0x17
     18a:	9d 91       	ld	r25, X+
     18c:	b5 91       	lpm	r27, Z+
     18e:	c7 91       	elpm	r28, Z+
     190:	fe 91       	ld	r31, -X
     192:	2d 92       	st	X+, r2
     194:	43 92       	.word	0x9243	; ????
     196:	7e 92       	st	-X, r7
     198:	b6 92       	.word	0x92b6	; ????
     19a:	f8 92       	.word	0x92f8	; ????
     19c:	00 93 23 94 	sts	0x9423, r16
     1a0:	2f 94 61 94 	call	0xb28c2	; 0xb28c2 <__data_load_end+0x9cd58>
     1a4:	9e 94 bb 94 	call	0x252976	; 0x252976 <__data_load_end+0x23ce0c>
     1a8:	d5 94       	asr	r13
     1aa:	15 95       	asr	r17
     1ac:	13 92       	.word	0x9213	; ????
     1ae:	d0 92 7a 94 	sts	0x947A, r13
     1b2:	9c 92       	st	X, r9
     1b4:	18 93       	.word	0x9318	; ????
     1b6:	67 93       	.word	0x9367	; ????
     1b8:	83 93       	.word	0x9383	; ????
     1ba:	9d 93       	st	X+, r25
     1bc:	eb 93       	.word	0x93eb	; ????
     1be:	09 94       	ijmp
     1c0:	4f 95 65 95 	call	0x532aca	; 0x532aca <__data_load_end+0x51cf60>
     1c4:	6a 95       	dec	r22
     1c6:	a3 95       	inc	r26
     1c8:	d2 95       	swap	r29
     1ca:	17 96       	adiw	r26, 0x07	; 7
     1cc:	35 96       	adiw	r30, 0x05	; 5
     1ce:	53 96       	adiw	r26, 0x13	; 19
     1d0:	8d 96       	adiw	r24, 0x2d	; 45
     1d2:	f0 96       	adiw	r30, 0x30	; 48
     1d4:	34 9b       	sbis	0x06, 4	; 6
     1d6:	b8 95       	.word	0x95b8	; ????
     1d8:	5d 9b       	sbis	0x0b, 5	; 11
     1da:	4b 9c       	mul	r4, r11
     1dc:	07 9c       	mul	r0, r7
     1de:	32 9c       	mul	r3, r2
     1e0:	85 9c       	mul	r8, r5
     1e2:	65 9c       	mul	r6, r5
     1e4:	9c 9c       	mul	r9, r12
     1e6:	b5 9c       	mul	r11, r5
     1e8:	c7 9c       	mul	r12, r7
     1ea:	77 9b       	sbis	0x0e, 7	; 14
     1ec:	d0 9b       	sbis	0x1a, 0	; 26
     1ee:	ed 9b       	sbis	0x1d, 5	; 29
     1f0:	00 97       	sbiw	r24, 0x00	; 0
     1f2:	20 97       	sbiw	r28, 0x00	; 0
     1f4:	47 97       	sbiw	r24, 0x17	; 23
     1f6:	56 97       	sbiw	r26, 0x16	; 22
     1f8:	74 97       	sbiw	r30, 0x14	; 20
     1fa:	8b 97       	sbiw	r24, 0x2b	; 43
     1fc:	b7 97       	sbiw	r30, 0x27	; 39
     1fe:	ce 97       	sbiw	r24, 0x3e	; 62
     200:	fa 97       	sbiw	r30, 0x3a	; 58
     202:	1a 98       	cbi	0x03, 2	; 3
     204:	4b 98       	cbi	0x09, 3	; 9
     206:	5a 98       	cbi	0x0b, 2	; 11
     208:	b3 98       	cbi	0x16, 3	; 22
     20a:	2a 99       	sbic	0x05, 2	; 5
     20c:	3e 99       	sbic	0x07, 6	; 7
     20e:	19 9a       	sbi	0x03, 1	; 3
     210:	19 9a       	sbi	0x03, 1	; 3
     212:	52 99       	sbic	0x0a, 2	; 10
     214:	66 99       	sbic	0x0c, 6	; 12
     216:	6e 99       	sbic	0x0d, 6	; 13
     218:	8a 99       	sbic	0x11, 2	; 17
     21a:	9e 99       	sbic	0x13, 6	; 19
     21c:	ab 99       	sbic	0x15, 3	; 21
     21e:	c2 99       	sbic	0x18, 2	; 24
     220:	d9 99       	sbic	0x1b, 1	; 27
     222:	f7 99       	sbic	0x1e, 7	; 30
     224:	1c 9a       	sbi	0x03, 4	; 3
     226:	33 9a       	sbi	0x06, 3	; 6
     228:	4a 9a       	sbi	0x09, 2	; 9
     22a:	61 9a       	sbi	0x0c, 1	; 12
     22c:	78 9a       	sbi	0x0f, 0	; 15
     22e:	8f 9a       	sbi	0x11, 7	; 17
     230:	a6 9a       	sbi	0x14, 6	; 20
     232:	bd 9a       	sbi	0x17, 5	; 23
     234:	cc 9a       	sbi	0x19, 4	; 25
     236:	e3 9a       	sbi	0x1c, 3	; 28
     238:	06 9b       	sbis	0x00, 6	; 0
     23a:	3b a1       	ldd	r19, Y+35	; 0x23
     23c:	3e a1       	ldd	r19, Y+38	; 0x26
     23e:	de a1       	ldd	r29, Y+38	; 0x26
     240:	ed a1       	ldd	r30, Y+37	; 0x25
     242:	1e a2       	std	Y+38, r1	; 0x26
     244:	2c a2       	std	Y+36, r2	; 0x24
     246:	58 a2       	std	Y+32, r5	; 0x20
     248:	fd a1       	ldd	r31, Y+37	; 0x25
     24a:	0a a2       	std	Y+34, r0	; 0x22
     24c:	14 a2       	std	Z+36, r1	; 0x24
     24e:	62 a2       	std	Z+34, r6	; 0x22
     250:	6f a2       	std	Y+39, r6	; 0x27
     252:	7a a2       	std	Y+34, r7	; 0x22
     254:	7d a2       	std	Y+37, r7	; 0x25
     256:	80 a2       	std	Z+32, r8	; 0x20
     258:	83 a2       	std	Z+35, r8	; 0x23
     25a:	86 a2       	std	Z+38, r8	; 0x26
     25c:	89 a2       	std	Y+33, r8	; 0x21
     25e:	8c a2       	std	Y+36, r8	; 0x24
     260:	8f a2       	std	Y+39, r8	; 0x27
     262:	b1 a2       	std	Z+33, r11	; 0x21
     264:	9f a2       	std	Y+39, r9	; 0x27
     266:	92 a2       	std	Z+34, r9	; 0x22
     268:	aa a2       	std	Y+34, r10	; 0x22
     26a:	c8 a1       	ldd	r28, Y+32	; 0x20

0000026c <__c.2986>:
     26c:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

0000027b <__c.2970>:
     27b:	57 61 74 63 68 44 6f 67 00                          WatchDog.

00000284 <__c.2968>:
     284:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

0000028d <__c.2966>:
     28d:	45 78 74 65 72 6e 61 6c 00                          External.

00000296 <__c.2964>:
     296:	50 6f 77 65 72 4f 6e 00                             PowerOn.

0000029e <__prodloc>:
     29e:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

000002aa <__prntloc>:
     2aa:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

000002b6 <__prntlmt>:
     2b6:	02 03 04 02 0f 0f                                   ......

000002bc <__prntstr>:
     2bc:	01 01 00 00 00 00                                   ......

000002c2 <__hostloc>:
     2c2:	01 0a 02 0a 03 0a                                   ......

000002c8 <MaxKeyHit>:
     2c8:	02 04 03 03 03 03 03 04 03 04                       ..........

000002d2 <strDispenserName1>:
     2d2:	4e 2f 41 00                                         N/A.

000002d6 <strDispenserName2>:
     2d6:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

000002df <strDispenserName3>:
     2df:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

000002ea <strDispenserName4>:
     2ea:	54 61 74 73 75 6e 6f 00                             Tatsuno.

000002f2 <strDispenserName5>:
     2f2:	4c 47 00                                            LG.

000002f5 <DefListDispenserName>:
     2f5:	d2 02 d6 02 df 02 ea 02 f2 02                       ..........

000002ff <__c.9822>:
     2ff:	4d 72 2e 42 69 67 00                                Mr.Big.

00000306 <__c.9726>:
     306:	25 64 00                                            %d.

00000309 <__c.9724>:
     309:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     319:	73 25 73 25 73 3a 00                                s%s%s:.

00000320 <__c.9675>:
     320:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     330:	3a 25 73 00                                         :%s.

00000334 <__c.9647>:
     334:	25 73 00                                            %s.

00000337 <__c.9638>:
     337:	25 73 00                                            %s.

0000033a <__c.9587>:
     33a:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

00000342 <__c.9566>:
     342:	43 54 53 52 50 00                                   CTSRP.

00000348 <__c.9542>:
     348:	3a 00                                               :.

0000034a <__c.9388>:
     34a:	4e 2f 41 00                                         N/A.

0000034e <__c.9368>:
     34e:	25 73 00                                            %s.

00000351 <__c.9363>:
	...

00000352 <__c.9236>:
     352:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

0000035c <__c.9234>:
     35c:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

0000036a <__c.9226>:
     36a:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

00000375 <__c.9224>:
     375:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

00000384 <__c.9220>:
     384:	25 73 25 73 00                                      %s%s.

00000389 <__c.9218>:
     389:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00000392 <__c.9216>:
     392:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     3a2:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

000003b0 <__c.9214>:
     3b0:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     3c0:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

000003ce <__c.9212>:
     3ce:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

000003d9 <__c.9210>:
     3d9:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

000003e8 <__c.9208>:
     3e8:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

000003f3 <__c.9206>:
     3f3:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

00000402 <__c.9204>:
     402:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

0000040f <__c.9202>:
     40f:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     41f:	73 00                                               s.

00000421 <__c.9200>:
     421:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

0000042e <__c.9196>:
     42e:	4e 2f 41 00                                         N/A.

00000432 <__c.9192>:
     432:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     442:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     452:	20 20 20 20 20 20 00                                      .

00000459 <__c.9190>:
     459:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     469:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     479:	41 48 28 52 50 29 00                                AH(RP).

00000480 <__c.9186>:
     480:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     490:	20 00                                                .

00000492 <__c.9184>:
     492:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     4a2:	20 00                                                .

000004a4 <__c.9182>:
     4a4:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     4b4:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     4c4:	20 20 20 20 20 00                                        .

000004ca <__c.9180>:
     4ca:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     4da:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     4ea:	20 20 20 20 20 00                                        .

000004f0 <__c.9177>:
     4f0:	25 64 00                                            %d.

000004f3 <__c.9119>:
     4f3:	25 73 00                                            %s.

000004f6 <__c.9114>:
     4f6:	30 00                                               0.

000004f8 <__c.9112>:
     4f8:	30 00                                               0.

000004fa <__c.8948>:
     4fa:	25 73 00                                            %s.

000004fd <__c.8946>:
     4fd:	25 73 00                                            %s.

00000500 <__c.8944>:
     500:	25 73 00                                            %s.

00000503 <__c.8942>:
     503:	25 73 00                                            %s.

00000506 <__c.8940>:
     506:	25 73 00                                            %s.

00000509 <__c.8744>:
     509:	25 73 00                                            %s.

0000050c <__c.8656>:
     50c:	30 30 30 30 30 30 30 30 00                          00000000.

00000515 <__c.8575>:
     515:	4f 70 65 72 61 74 6f 72 3a 20 25 73 00              Operator: %s.

00000522 <__c.8570>:
     522:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     532:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     542:	2d 00                                               -.

00000544 <__c.8561>:
     544:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     554:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     564:	20 20 20 00                                            .

00000568 <__c.8559>:
     568:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     578:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     588:	20 20 20 00                                            .

0000058c <__c.8407>:
     58c:	20 20 20 20 20 4f 70 65 72 61 74 6f 72 3a 20 25          Operator: %
     59c:	73 00                                               s.

0000059e <__c.8402>:
     59e:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     5ae:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     5be:	2d 2d 00                                            --.

000005c1 <__c.8399>:
     5c1:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     5d1:	6d 74 3a 20 25 73 00                                mt: %s.

000005d8 <__c.8396>:
     5d8:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     5e8:	73 63 3a 20 25 73 00                                sc: %s.

000005ef <__c.8393>:
     5ef:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     5ff:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     60f:	2d 2d 00                                            --.

00000612 <__c.8390>:
     612:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     622:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

0000062c <__c.8387>:
     62c:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     63c:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

00000645 <__c.8384>:
     645:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     655:	6d 20 3a 20 25 73 00                                m : %s.

0000065c <__c.8381>:
     65c:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     66c:	20 20 3a 20 25 73 00                                  : %s.

00000673 <__c.8378>:
     673:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     683:	20 20 3a 20 25 73 00                                  : %s.

0000068a <__c.8375>:
     68a:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     69a:	20 20 3a 20 25 73 00                                  : %s.

000006a1 <__c.8372>:
     6a1:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     6b1:	20 20 3a 20 25 73 00                                  : %s.

000006b8 <__c.8369>:
     6b8:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     6c8:	20 20 3a 20 25 73 00                                  : %s.

000006cf <__c.8366>:
     6cf:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     6df:	20 20 3a 20 25 73 00                                  : %s.

000006e6 <__c.8363>:
     6e6:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     6f6:	20 20 3a 20 25 73 20 00                               : %s .

000006fe <__c.8360>:
     6fe:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     70e:	20 20 3a 20 25 73 00                                  : %s.

00000715 <__c.8357>:
     715:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     725:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     735:	20 20 00                                              .

00000738 <__c.8354>:
     738:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     748:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     758:	2d 2d 00                                            --.

0000075b <__c.8351>:
     75b:	20 20 20 20 2e 25 73 00                                 .%s.

00000763 <__c.8347>:
     763:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     773:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     783:	5f 29 00                                            _).

00000786 <__c.8342>:
     786:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     796:	20 20 20 20 20 20 00                                      .

0000079d <__c.8339>:
     79d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     7ad:	20 20 20 20 20 20 00                                      .

000007b4 <__c.8336>:
     7b4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     7c4:	20 00                                                .

000007c6 <__c.8334>:
     7c6:	20 20 00                                              .

000007c9 <__c.8332>:
     7c9:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     7d9:	73 00                                               s.

000007db <__c.8330>:
     7db:	25 73 20 20 00                                      %s  .

000007e0 <__c.8328>:
     7e0:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     7f0:	73 00                                               s.

000007f2 <__c.8325>:
     7f2:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     802:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     812:	20 20 00                                              .

00000815 <__c.8323>:
     815:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     825:	25 73 00                                            %s.

00000828 <__c.8321>:
     828:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     838:	73 00                                               s.

0000083a <__c.8318>:
     83a:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     84a:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     85a:	2d 2d 00                                            --.

0000085d <__c.8315>:
     85d:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     86d:	20 20 3a 20 25 73 00                                  : %s.

00000874 <__c.8312>:
     874:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     884:	20 20 3a 20 25 73 00                                  : %s.

0000088b <__c.8309>:
	...

0000088c <__c.8307>:
     88c:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     89c:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

000008a6 <__c.8304>:
     8a6:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     8b6:	20 20 3a 20 25 73 20 4c 00                            : %s L.

000008bf <__c.8301>:
	...

000008c0 <__c.8299>:
     8c0:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     8d0:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

000008da <__c.8296>:
     8da:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     8ea:	20 20 3a 20 25 73 00                                  : %s.

000008f1 <__c.8293>:
     8f1:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     901:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

0000090d <__c.8290>:
     90d:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     91d:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     92d:	2d 2d 00                                            --.

00000930 <__c.8287>:
     930:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     940:	25 73 20 00                                         %s .

00000944 <__c.8283>:
     944:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     954:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000963 <__c.8266>:
     963:	20 00                                                .

00000965 <__c.8264>:
     965:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     975:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     985:	20 20 20 00                                            .

00000989 <__c.7865>:
     989:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     999:	69 6f 6e 00                                         ion.

0000099d <__c.7859>:
     99d:	50 72 6f 73 65 73 00                                Proses.

000009a4 <__c.7857>:
     9a4:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

000009b1 <__c.7852>:
     9b1:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     9c1:	6e 74 65 72 00                                      nter.

000009c6 <__c.7850>:
     9c6:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     9d6:	6e 74 65 72 00                                      nter.

000009db <__c.7847>:
     9db:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     9eb:	74 65 72 20 00                                      ter .

000009f0 <__c.7845>:
     9f0:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

000009fc <__c.7843>:
     9fc:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000a09 <__c.7840>:
     a09:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     a19:	6e 74 65 72 00                                      nter.

00000a1e <__c.7838>:
     a1e:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     a2e:	6e 74 65 72 00                                      nter.

00000a33 <__c.7835>:
     a33:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     a43:	74 65 72 20 00                                      ter .

00000a48 <__c.7833>:
     a48:	5f 00                                               _.

00000a4a <__c.7831>:
     a4a:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000a5a <__c.7755>:
     a5a:	23 29 53 61 76 65 00                                #)Save.

00000a61 <__c.7753>:
     a61:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000a6e <__c.7751>:
     a6e:	25 64 00                                            %d.

00000a71 <__c.7739>:
     a71:	25 64 00                                            %d.

00000a74 <__c.7731>:
     a74:	23 29 53 61 76 65 00                                #)Save.

00000a7b <__c.7729>:
     a7b:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000a88 <__c.7727>:
     a88:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     a98:	45 78 69 74 00                                      Exit.

00000a9d <__c.7725>:
     a9d:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000aa7 <__c.7723>:
     aa7:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000ab1 <__c.7670>:
     ab1:	25 2e 32 64 00                                      %.2d.

00000ab6 <__c.7668>:
     ab6:	25 64 00                                            %d.

00000ab9 <__c.7651>:
     ab9:	25 2e 32 64 00                                      %.2d.

00000abe <__c.7649>:
     abe:	25 64 00                                            %d.

00000ac1 <__c.7641>:
     ac1:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000ad1 <__c.7639>:
     ad1:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000ae1 <__c.7637>:
     ae1:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     af1:	20 3a 00                                             :.

00000af4 <__c.7635>:
     af4:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     b04:	6c 3a 00                                            l:.

00000b07 <__c.7571>:
     b07:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     b17:	53 61 76 65 00                                      Save.

00000b1c <__c.7569>:
     b1c:	54 49 4d 45 20 3a 20 00                             TIME : .

00000b24 <__c.7567>:
     b24:	44 41 54 45 20 3a 20 00                             DATE : .

00000b2c <__c.7517>:
     b2c:	25 64 00                                            %d.

00000b2f <__c.7506>:
     b2f:	25 64 00                                            %d.

00000b32 <__c.7498>:
     b32:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     b42:	53 61 76 65 00                                      Save.

00000b47 <__c.7496>:
     b47:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     b57:	4e 36 3a 00                                         N6:.

00000b5b <__c.7494>:
     b5b:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     b6b:	4e 35 3a 00                                         N5:.

00000b6f <__c.7492>:
     b6f:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000b7f <__c.7408>:
     b7f:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000b89 <__c.7406>:
     b89:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000b95 <__c.7403>:
     b95:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000ba3 <__c.7400>:
     ba3:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000bac <__c.7398>:
     bac:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000bb5 <__c.7394>:
     bb5:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     bc5:	20 20 20 20 00                                          .

00000bca <__c.7392>:
     bca:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     bda:	49 44 20 20 00                                      ID  .

00000bdf <__c.7390>:
     bdf:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     bef:	20 20 20 20 00                                          .

00000bf4 <__c.7378>:
     bf4:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     c04:	2e 32 64 00                                         .2d.

00000c08 <__c.7372>:
     c08:	23 29 53 61 76 65 00                                #)Save.

00000c0f <__c.7370>:
     c0f:	2a 29 42 61 63 6b 00                                *)Back.

00000c16 <__c.7365>:
     c16:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     c26:	2e 32 64 00                                         .2d.

00000c2a <__c.7316>:
     c2a:	25 2e 32 64 00                                      %.2d.

00000c2f <__c.7310>:
     c2f:	25 2e 32 64 00                                      %.2d.

00000c34 <__c.7308>:
     c34:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     c44:	45 78 69 74 00                                      Exit.

00000c49 <__c.7306>:
     c49:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     c59:	53 61 76 65 00                                      Save.

00000c5e <__c.7304>:
     c5e:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000c6a <__c.7302>:
     c6a:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000c76 <__c.7268>:
     c76:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     c86:	67 65 20 00                                         ge .

00000c8a <__c.7266>:
     c8a:	25 64 2e 25 73 00                                   %d.%s.

00000c90 <__c.7261>:
     c90:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     ca0:	2d 00                                               -.

00000ca2 <__c.7245>:
     ca2:	2a 29 45 78 69 74 00                                *)Exit.

00000ca9 <__c.7243>:
     ca9:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000cb3 <__c.7241>:
     cb3:	31 29 49 44 00                                      1)ID.

00000cb8 <__c.7226>:
     cb8:	2a 29 45 78 69 74 00                                *)Exit.

00000cbf <__c.7221>:
     cbf:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     ccf:	2e 32 64 20 00                                      .2d .

00000cd4 <__c.7212>:
     cd4:	25 2e 32 64 00                                      %.2d.

00000cd9 <__c.7011>:
     cd9:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000ce1 <__c.7009>:
     ce1:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000cea <__c.7007>:
     cea:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000cf3 <__c.7005>:
     cf3:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000d00 <__c.7003>:
     d00:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000d0d <__c.7001>:
     d0d:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000d1a <__c.6999>:
     d1a:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000d27 <__c.6940>:
     d27:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000d34 <__c.6935>:
     d34:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000d3d <__c.6933>:
     d3d:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     d4d:	20 20 20 20 00                                          .

00000d52 <__c.6928>:
     d52:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000d60 <__c.6926>:
     d60:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000d6b <__c.6924>:
     d6b:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000d76 <__c.6922>:
     d76:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000d81 <__c.6920>:
     d81:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000d8c <__c.6918>:
     d8c:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     d9c:	65 00                                               e.

00000d9e <__c.6916>:
     d9e:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000dab <__c.6914>:
     dab:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000db7 <__c.6867>:
     db7:	49 6e 76 61 6c 69 64 20 4f 6c 64 20 50 61 73 73     Invalid Old Pass
     dc7:	77 6f 72 64 00                                      word.

00000dcc <__c.6865>:
     dcc:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     ddc:	20 20 20 20 00                                          .

00000de1 <__c.6863>:
     de1:	49 6e 76 61 6c 69 64 20 4e 65 77 20 50 61 73 73     Invalid New Pass
     df1:	77 6f 72 64 00                                      word.

00000df6 <__c.6861>:
     df6:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e06:	20 20 20 20 00                                          .

00000e0b <__c.6859>:
     e0b:	20 20 20 50 61 73 73 77 6f 72 64 20 53 61 76 65        Password Save
     e1b:	64 20 20 20 00                                      d   .

00000e20 <__c.6857>:
     e20:	20 20 20 20 20 43 6f 6d 70 6c 65 74 65 64 20 20          Completed  
     e30:	20 20 20 20 00                                          .

00000e35 <__c.6853>:
     e35:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     e45:	6e 74 65 72 00                                      nter.

00000e4a <__c.6850>:
     e4a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     e5a:	6e 74 65 72 00                                      nter.

00000e5f <__c.6847>:
     e5f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     e6f:	6e 74 65 72 00                                      nter.

00000e74 <__c.6845>:
     e74:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     e84:	20 20 20 20 00                                          .

00000e89 <__c.6841>:
     e89:	56 61 6c 69 64 61 74 69 6e 67 2e 2e 00              Validating...

00000e96 <__c.6837>:
     e96:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ea6:	6e 74 65 72 00                                      nter.

00000eab <__c.6834>:
     eab:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     ebb:	6e 74 65 72 00                                      nter.

00000ec0 <__c.6829>:
     ec0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ed0:	6e 74 65 72 00                                      nter.

00000ed5 <__c.6827>:
     ed5:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     ee5:	20 20 20 20 00                                          .

00000eea <__c.6823>:
     eea:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     efa:	6e 74 65 72 00                                      nter.

00000eff <__c.6820>:
     eff:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f0f:	6e 74 65 72 00                                      nter.

00000f14 <__c.6815>:
     f14:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f24:	6e 74 65 72 00                                      nter.

00000f29 <__c.6813>:
     f29:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f39:	20 20 20 20 00                                          .

00000f3e <__c.6809>:
     f3e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f4e:	6e 74 65 72 00                                      nter.

00000f53 <__c.6807>:
     f53:	4f 6c 64 3a 5f 00                                   Old:_.

00000f59 <__c.6805>:
     f59:	2d 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 2d 00     -Administrator-.

00000f69 <__c.6803>:
     f69:	2d 53 75 70 65 72 76 69 73 6f 72 2d 00              -Supervisor-.

00000f76 <__c.6795>:
     f76:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000f83 <__c.6793>:
     f83:	32 2e 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 00     2.Administrator.

00000f93 <__c.6791>:
     f93:	31 2e 53 75 70 65 72 76 69 73 6f 72 00              1.Supervisor.

00000fa0 <__c.6789>:
     fa0:	2d 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72 64     -Change Password
     fb0:	2d 00                                               -.

00000fb2 <__c.6786>:
     fb2:	53 61 76 65 64 20 00                                Saved .

00000fb9 <__c.6780>:
     fb9:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fc9:	6e 74 65 72 00                                      nter.

00000fce <__c.6777>:
     fce:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     fde:	6e 74 65 72 00                                      nter.

00000fe3 <__c.6772>:
     fe3:	5b 2a 5d 4e 6f 20 20 20 20 5b 23 5d 59 65 73 00     [*]No    [#]Yes.

00000ff3 <__c.6770>:
     ff3:	53 61 76 65 3f 00                                   Save?.

00000ff9 <__c.6768>:
     ff9:	4e 65 77 20 4f 70 65 72 61 74 6f 72 3a 00           New Operator:.

00001007 <__c.6766>:
    1007:	25 73 00                                            %s.

0000100a <__c.6762>:
    100a:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    101a:	6e 74 65 72 00                                      nter.

0000101f <__c.6760>:
    101f:	4e 65 77 20 3a 5f 20 20 20 20 20 20 20 20 20 20     New :_          
    102f:	20 20 20 20 00                                          .

00001034 <__c.6758>:
    1034:	4e 61 6d 65 3a 00                                   Name:.

0000103a <__c.6756>:
    103a:	25 73 00                                            %s.

0000103d <__c.6747>:
    103d:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    104d:	20 00                                                .

0000104f <__c.6745>:
    104f:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    105f:	64 00                                               d.

00001061 <__c.6743>:
    1061:	31 2e 43 68 61 6e 67 65 20 4f 70 65 72 61 74 6f     1.Change Operato
    1071:	72 00                                               r.

00001073 <__c.6661>:
    1073:	2a 29 42 61 63 6b 00                                *)Back.

0000107a <__c.6659>:
    107a:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

00001089 <__c.6657>:
    1089:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

00001098 <__c.6655>:
    1098:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

000010a7 <__c.6653>:
    10a7:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 00        1.T.Volume:%d .

000010b6 <__c.6648>:
    10b6:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

000010c7 <__c.6646>:
    10c7:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

000010d3 <__c.6644>:
    10d3:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

000010df <__c.6642>:
    10df:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

000010eb <__c.6625>:
    10eb:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

000010fb <__c.6623>:
    10fb:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

00001105 <__c.6621>:
    1105:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

0000110f <__c.6619>:
    110f:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

00001119 <__c.6579>:
    1119:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1129:	20 20 20 20 00                                          .

0000112e <__c.6577>:
    112e:	4e 65 77 3a 5f 00                                   New:_.

00001134 <__c.6575>:
    1134:	4f 6c 64 3a 25 73 00                                Old:%s.

0000113b <__c.6573>:
    113b:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    114b:	20 20 20 20 00                                          .

00001150 <__c.6571>:
    1150:	4e 65 77 3a 5f 00                                   New:_.

00001156 <__c.6569>:
    1156:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    1166:	65 20 20 20 00                                      e   .

0000116b <__c.6567>:
    116b:	4f 6c 64 3a 25 73 00                                Old:%s.

00001172 <__c.6564>:
    1172:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

00001180 <__c.6562>:
    1180:	32 29 25 73 00                                      2)%s.

00001185 <__c.6560>:
    1185:	31 29 25 73 00                                      1)%s.

0000118a <__c.6555>:
    118a:	2a 29 42 61 63 6b 00                                *)Back.

00001191 <__c.6550>:
    1191:	25 64 29 25 73 00                                   %d)%s.

00001197 <__c.6481>:
    1197:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    11a7:	20 20 20 20 00                                          .

000011ac <__c.6479>:
    11ac:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    11bc:	20 20 20 20 00                                          .

000011c1 <__c.6477>:
    11c1:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    11d1:	20 20 20 20 00                                          .

000011d6 <__c.6475>:
    11d6:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    11e6:	20 20 20 20 00                                          .

000011eb <__c.6472>:
    11eb:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    11fb:	74 20 20 20 00                                      t   .

00001200 <__c.6470>:
    1200:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    1210:	74 20 20 20 00                                      t   .

00001215 <__c.6468>:
    1215:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    1225:	74 20 20 20 00                                      t   .

0000122a <__c.6466>:
    122a:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    123a:	6e 74 65 72 00                                      nter.

0000123f <__c.6381>:
    123f:	2e 00                                               ..

00001241 <__c.6379>:
    1241:	25 64 00                                            %d.

00001244 <__c.6377>:
    1244:	20 20 20 00                                            .

00001248 <__c.6375>:
    1248:	2e 00                                               ..

0000124a <__c.6373>:
    124a:	25 64 00                                            %d.

0000124d <__c.6371>:
    124d:	20 20 20 00                                            .

00001251 <__c.6364>:
    1251:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    1261:	78 74 20 20 00                                      xt  .

00001266 <__c.6362>:
    1266:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    1276:	2e 20 20 20 00                                      .   .

0000127b <__c.6360>:
    127b:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

0000128c <__c.6358>:
    128c:	53 65 72 76 65 72 20 49 50 00                       Server IP.

00001296 <__c.6269>:
    1296:	2e 00                                               ..

00001298 <__c.6267>:
    1298:	25 64 00                                            %d.

0000129b <__c.6265>:
    129b:	20 20 20 00                                            .

0000129f <__c.6263>:
    129f:	2e 00                                               ..

000012a1 <__c.6261>:
    12a1:	25 64 00                                            %d.

000012a4 <__c.6259>:
    12a4:	20 20 20 00                                            .

000012a8 <__c.6252>:
    12a8:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    12b8:	78 74 20 20 00                                      xt  .

000012bd <__c.6250>:
    12bd:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    12cd:	2e 20 20 20 00                                      .   .

000012d2 <__c.6248>:
    12d2:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

000012e3 <__c.6246>:
    12e3:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

000012ed <__c.6204>:
    12ed:	25 73 25 73 00                                      %s%s.

000012f2 <__c.6200>:
    12f2:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

000012ff <__c.6198>:
    12ff:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

0000130f <__c.6194>:
    130f:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

0000131d <__c.6192>:
    131d:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

0000132b <__c.6189>:
    132b:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

0000133a <__c.6187>:
    133a:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

00001349 <__c.6183>:
    1349:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1359:	20 20 20 20 00                                          .

0000135e <__c.6181>:
    135e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    136e:	20 20 20 20 00                                          .

00001373 <__c.6179>:
    1373:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    1383:	74 65 72 34 00                                      ter4.

00001388 <__c.6177>:
    1388:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    1398:	74 65 72 33 00                                      ter3.

0000139d <__c.6146>:
    139d:	25 73 25 73 00                                      %s%s.

000013a2 <__c.6142>:
    13a2:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

000013af <__c.6140>:
    13af:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

000013bf <__c.6136>:
    13bf:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

000013cd <__c.6134>:
    13cd:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

000013db <__c.6131>:
    13db:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000013ea <__c.6129>:
    13ea:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

000013f9 <__c.6125>:
    13f9:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1409:	20 20 20 20 00                                          .

0000140e <__c.6123>:
    140e:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    141e:	64 65 72 36 00                                      der6.

00001423 <__c.6121>:
    1423:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    1433:	64 65 72 35 00                                      der5.

00001438 <__c.6119>:
    1438:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    1448:	64 65 72 34 00                                      der4.

0000144d <__c.6076>:
    144d:	2a 29 45 78 69 74 00                                *)Exit.

00001454 <__c.6074>:
    1454:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    1464:	20 20 20 20 00                                          .

00001469 <__c.6072>:
    1469:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    1479:	20 20 20 20 00                                          .

0000147e <__c.6070>:
    147e:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    148e:	20 20 20 20 00                                          .

00001493 <__c.6068>:
    1493:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    14a3:	72 76 65 72 00                                      rver.

000014a8 <__c.6066>:
    14a8:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    14b8:	69 65 6e 74 00                                      ient.

000014bd <__c.6012>:
    14bd:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    14cd:	2e 2e 20 00                                         .. .

000014d1 <__c.6007>:
    14d1:	25 73 20 25 73 00                                   %s %s.

000014d7 <__c.6005>:
    14d7:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    14e7:	65 72 00                                            er.

000014ea <__c.6001>:
    14ea:	43 61 6e 63 65 6c 00                                Cancel.

000014f1 <__c.5996>:
    14f1:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    1501:	25 64 20 00                                         %d .

00001505 <__c.5991>:
    1505:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

00001513 <__c.5987>:
    1513:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

00001521 <__c.5985>:
    1521:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

0000152d <__c.5913>:
    152d:	2a 29 45 78 69 74 00                                *)Exit.

00001534 <__c.5911>:
    1534:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

00001542 <__c.5909>:
    1542:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

00001550 <__c.5907>:
    1550:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

0000155e <__c.5865>:
    155e:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    156e:	78 69 74 20 00                                      xit .

00001573 <__c.5863>:
    1573:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    1583:	20 20 20 20 00                                          .

00001588 <__c.5861>:
    1588:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    1598:	20 20 20 20 00                                          .

0000159d <__c.5859>:
    159d:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    15ad:	20 20 20 20 00                                          .

000015b2 <__c.5829>:
    15b2:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    15c2:	64 00                                               d.

000015c4 <__c.5825>:
    15c4:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    15d4:	20 00                                                .

000015d6 <__c.5822>:
    15d6:	30 30 30 30 30 00                                   00000.

000015dc <__c.5820>:
    15dc:	31 31 31 31 31 00                                   11111.

000015e2 <__c.5816>:
    15e2:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    15f2:	6e 74 65 72 00                                      nter.

000015f7 <__c.5813>:
    15f7:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1607:	6e 74 65 72 00                                      nter.

0000160c <__c.5806>:
    160c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    161c:	6e 74 65 72 00                                      nter.

00001621 <__c.5804>:
    1621:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    1631:	20 20 20 20 00                                          .

00001636 <__c.5802>:
    1636:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    1646:	64 65 20 20 00                                      de  .

0000164b <__c.5800>:
    164b:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

00001659 <__c.5796>:
    1659:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    1669:	20 20 20 20 00                                          .

0000166e <__c.5793>:
	...

0000166f <__c.5791>:
    166f:	25 73 00                                            %s.

00001672 <__c.5789>:
    1672:	25 73 00                                            %s.

00001675 <__c.5786>:
    1675:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1685:	6e 74 65 72 00                                      nter.

0000168a <__c.5783>:
    168a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    169a:	6e 74 65 72 00                                      nter.

0000169f <__c.5776>:
	...

000016a0 <__c.5774>:
    16a0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    16b0:	6e 74 65 72 00                                      nter.

000016b5 <__c.5772>:
    16b5:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    16c5:	20 20 20 20 00                                          .

000016ca <__c.5770>:
    16ca:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    16da:	65 20 20 20 00                                      e   .

000016df <__c.5760>:
    16df:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    16ef:	20 20 20 20 00                                          .

000016f4 <__c.5758>:
    16f4:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    1704:	64 20 20 20 00                                      d   .

00001709 <__c.5756>:
    1709:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    1719:	72 64 20 20 00                                      rd  .

0000171e <__c.5754>:
    171e:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    172e:	76 65 6c 2d 00                                      vel-.

00001733 <__c.5695>:
    1733:	25 73 25 73 00                                      %s%s.

00001738 <__c.5667>:
    1738:	25 73 00                                            %s.

0000173b <__c.5634>:
    173b:	25 63 00                                            %c.

0000173e <__c.5632>:
    173e:	32 30 25 73 00                                      20%s.

00001743 <__c.5610>:
    1743:	25 73 00                                            %s.

00001746 <__c.5562>:
    1746:	34 32 36 34 36 33 36 00                             4264636.

0000174e <__c.5559>:
    174e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    175e:	6e 74 65 72 00                                      nter.

00001763 <__c.5557>:
    1763:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1773:	6e 74 65 72 00                                      nter.

00001778 <__c.5553>:
    1778:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1788:	6e 74 65 72 00                                      nter.

0000178d <__c.5551>:
    178d:	5f 00                                               _.

0000178f <__c.5549>:
    178f:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001799 <__c.5521>:
    1799:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

000017a7 <__c.5448>:
    17a7:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

000017b4 <__c.5446>:
    17b4:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

000017c1 <__c.5442>:
    17c1:	20 20 20 20 20 20 20 00                                    .

000017c9 <__c.5439>:
    17c9:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

000017d5 <__c.5436>:
    17d5:	25 73 00                                            %s.

000017d8 <__c.5434>:
    17d8:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

000017e2 <__c.5431>:
    17e2:	25 73 00                                            %s.

000017e5 <__c.5428>:
    17e5:	25 73 00                                            %s.

000017e8 <__c.5426>:
    17e8:	25 73 00                                            %s.

000017eb <__c.5424>:
    17eb:	25 73 00                                            %s.

000017ee <__c.5420>:
    17ee:	25 73 00                                            %s.

000017f1 <__c.5416>:
    17f1:	50 72 6f 73 65 73 00                                Proses.

000017f8 <__c.5414>:
    17f8:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

00001806 <__c.5411>:
    1806:	50 72 6f 73 65 73 00                                Proses.

0000180d <__c.5409>:
    180d:	49 44 3a 25 73 00                                   ID:%s.

00001813 <__c.5405>:
    1813:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1823:	69 74 00                                            it.

00001826 <__c.5403>:
    1826:	46 49 50 25 73 00                                   FIP%s.

0000182c <__c.5401>:
    182c:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

0000183b <__c.5392>:
    183b:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    184b:	6e 74 65 72 00                                      nter.

00001850 <__c.5390>:
    1850:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1860:	6e 74 65 72 00                                      nter.

00001865 <__c.5387>:
    1865:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1875:	6e 74 65 72 00                                      nter.

0000187a <__c.5385>:
    187a:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

0000188a <__c.5383>:
    188a:	25 73 00                                            %s.

0000188d <__c.5379>:
    188d:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

00001895 <__c.5374>:
    1895:	25 64 2e 25 73 00                                   %d.%s.

0000189b <__c.5372>:
    189b:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

000018a7 <__c.5367>:
    18a7:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18b7:	6e 74 65 72 00                                      nter.

000018bc <__c.5365>:
    18bc:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    18cc:	6e 74 65 72 00                                      nter.

000018d1 <__c.5362>:
    18d1:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18e1:	6e 74 65 72 00                                      nter.

000018e6 <__c.5360>:
    18e6:	5f 00                                               _.

000018e8 <__c.5358>:
    18e8:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

000018f5 <__c.5349>:
    18f5:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1905:	20 20 20 20 00                                          .

0000190a <__c.5347>:
    190a:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    191a:	54 65 73 74 00                                      Test.

0000191f <__c.5345>:
    191f:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    192f:	68 65 72 20 00                                      her .

00001934 <__c.5343>:
    1934:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    1944:	74 20 20 20 00                                      t   .

00001949 <__c.5294>:
    1949:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

00001954 <__c.5288>:
    1954:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1964:	20 20 20 20 00                                          .

00001969 <__c.5286>:
    1969:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    1979:	20 20 20 20 00                                          .

0000197e <__c.5284>:
    197e:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    198e:	72 64 20 20 00                                      rd  .

00001993 <__c.5282>:
    1993:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

000019a4 <__c.5249>:
    19a4:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

000019b2 <__c.5247>:
    19b2:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

000019c0 <__c.5240>:
    19c0:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

000019ce <__c.5238>:
    19ce:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

000019d8 <__c.5236>:
    19d8:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

000019e2 <__c.5234>:
    19e2:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

000019ec <__c.5232>:
    19ec:	25 73 3a 25 73 00                                   %s:%s.

000019f2 <__c.5225>:
    19f2:	50 72 6f 73 65 73 00                                Proses.

000019f9 <__c.5223>:
    19f9:	49 44 3a 25 73 00                                   ID:%s.

000019ff <__c.5219>:
    19ff:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a0f:	69 74 00                                            it.

00001a12 <__c.5217>:
    1a12:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a21 <__c.5214>:
    1a21:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a31:	69 74 00                                            it.

00001a34 <__c.5212>:
    1a34:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a43 <__c.5210>:
    1a43:	46 49 50 3a 25 73 00                                FIP:%s.

00001a4a <__c.5204>:
    1a4a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1a5a:	20 00                                                .

00001a5c <__c.5202>:
    1a5c:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1a6c:	20 00                                                .

00001a6e <__c.5200>:
    1a6e:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1a7e:	20 00                                                .

00001a80 <__c.5198>:
    1a80:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1a90:	20 00                                                .

00001a92 <__c.5161>:
    1a92:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001aa0 <__c.5159>:
    1aa0:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001aae <__c.5153>:
    1aae:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1abe:	69 74 00                                            it.

00001ac1 <__c.5151>:
    1ac1:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1ad1:	61 72 64 00                                         ard.

00001ad5 <__c.5149>:
    1ad5:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001ae5 <__c.5145>:
    1ae5:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1af5:	6b 73 69 20 00                                      ksi .

00001afa <__c.5136>:
    1afa:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001b08 <__c.5093>:
    1b08:	25 2e 32 64 00                                      %.2d.

00001b0d <__c.5089>:
    1b0d:	2a 29 45 78 69 74 00                                *)Exit.

00001b14 <__c.5087>:
    1b14:	23 29 4f 4b 20 00                                   #)OK .

00001b1a <__c.5085>:
    1b1a:	20 20 20 20 20 00                                        .

00001b20 <__c.5083>:
    1b20:	46 49 50 3a 5f 00                                   FIP:_.

00001b26 <__c.5078>:
    1b26:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001b36 <__c.5029>:
    1b36:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001b47 <__c.4886>:
    1b47:	30 00                                               0.

00001b49 <__c.4817>:
    1b49:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1b59:	20 20 20 20 00                                          .

00001b5e <__c.4812>:
    1b5e:	23 25 73 00                                         #%s.

00001b62 <__c.4810>:
    1b62:	25 2e 32 64 00                                      %.2d.

00001b67 <__c.4808>:
    1b67:	40 46 49 50 3a 00                                   @FIP:.

00001b6d <__c.4806>:
    1b6d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1b7d:	20 20 20 20 00                                          .

00001b82 <__c.4802>:
    1b82:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001b92 <__c.4778>:
    1b92:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001b9e <__c.4767>:
    1b9e:	25 73 20 25 73 00                                   %s %s.

00001ba4 <__c.4739>:
    1ba4:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001bb2 <__c.4737>:
    1bb2:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001bbf <__c.4735>:
    1bbf:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001bc9 <__c.4733>:
    1bc9:	43 6f 6e 6e 65 63 74 65 64 20 20 20 20 20 20 20     Connected       
    1bd9:	20 20 20 20 00                                          .

00001bde <__c.4728>:
    1bde:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bee:	20 20 20 00                                            .

00001bf2 <__c.4726>:
    1bf2:	25 73 00                                            %s.

00001bf5 <__c.4721>:
    1bf5:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001bff <__c.4716>:
    1bff:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c10 <__c.4714>:
    1c10:	43 6f 6e 6e 65 63 74 00                             Connect.

00001c18 <__c.4712>:
    1c18:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c29 <__c.4684>:
    1c29:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1c39:	20 20 20 00                                            .

00001c3d <__c.4682>:
    1c3d:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1c4d:	2e 2e 00                                            ...

00001c50 <__c.4643>:
    1c50:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1c60:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1c70:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1c80:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1c90:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1ca0:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1cb0:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1cc0:	0a 00                                               ..

00001cc2 <__c.4641>:
    1cc2:	32 34 2f 30 32 2f 32 30 31 31 00                    24/02/2011.

00001ccd <__c.4639>:
    1ccd:	32 2e 33 39 00                                      2.39.

00001cd2 <__c.4545>:
    1cd2:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001ce3 <__c.4543>:
    1ce3:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1cf3:	69 00                                               i.

00001cf5 <__c.4539>:
    1cf5:	49 44 3a 20 25 73 00                                ID: %s.

00001cfc <__c.4537>:
    1cfc:	25 73 00                                            %s.

00001cff <__c.4535>:
    1cff:	50 25 73 20 25 73 20 00                             P%s %s .

00001d07 <__c.4531>:
    1d07:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1d17:	20 20 00                                              .

00001d1a <__c.4528>:
    1d1a:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1d2a:	61 73 69 6c 00                                      asil.

00001d2f <__c.4524>:
    1d2f:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1d3f:	6c 20 20 20 00                                      l   .

00001d44 <__c.4520>:
    1d44:	20 20 20 20 20 20 20 00                                    .

00001d4c <__c.4517>:
    1d4c:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1d5c:	20 20 20 20 00                                          .

00001d61 <__c.4515>:
    1d61:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1d71:	20 20 20 20 00                                          .

00001d76 <__c.4513>:
    1d76:	25 73 00                                            %s.

00001d79 <__c.4511>:
    1d79:	50 25 73 20 25 73 20 00                             P%s %s .

00001d81 <__c.4508>:
    1d81:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1d91:	6f 6e 20 20 00                                      on  .

00001d96 <__c.4505>:
    1d96:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1da6:	23 5d 4f 4b 00                                      #]OK.

00001dab <__c.4503>:
    1dab:	25 73 20 00                                         %s .

00001daf <__c.4501>:
    1daf:	20 46 75 6c 6c 00                                    Full.

00001db5 <__c.4499>:
    1db5:	25 73 20 20 25 73 20 00                             %s  %s .

00001dbd <__c.4497>:
    1dbd:	49 44 3a 20 25 73 00                                ID: %s.

00001dc4 <__c.4495>:
    1dc4:	25 73 20 00                                         %s .

00001dc8 <__c.4491>:
    1dc8:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1dd8:	20 00                                                .

00001dda <__c.4489>:
    1dda:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1dea:	20 00                                                .

00001dec <__c.4487>:
    1dec:	25 73 20 00                                         %s .

00001df0 <__c.4485>:
    1df0:	20 20 25 73 20 25 73 20 00                            %s %s .

00001df9 <__c.4483>:
    1df9:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1e09:	75 6e 74 00                                         unt.

00001e0d <__c.4481>:
    1e0d:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1e1d:	75 6d 65 00                                         ume.

00001e21 <__c.4479>:
    1e21:	20 20 54 61 6e 6b 00                                  Tank.

00001e28 <__c.4477>:
    1e28:	20 20 25 73 20 25 73 20 00                            %s %s .

00001e31 <__c.4475>:
    1e31:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1e41:	75 6c 6c 00                                         ull.

00001e45 <__c.4471>:
    1e45:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e55:	20 20 20 20 00                                          .

00001e5a <__c.4469>:
    1e5a:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1e6a:	20 20 20 20 00                                          .

00001e6f <__c.4467>:
    1e6f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1e7f:	20 20 20 20 00                                          .

00001e84 <__c.4465>:
    1e84:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001e8c <__c.4463>:
    1e8c:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e9c:	20 20 20 20 00                                          .

00001ea1 <__c.4461>:
    1ea1:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1eb1:	20 20 20 20 00                                          .

00001eb6 <__c.4459>:
    1eb6:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    1ec6:	20 20 20 20 00                                          .

00001ecb <__c.4457>:
    1ecb:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001ed3 <__c.4454>:
    1ed3:	41 00                                               A.

00001ed5 <__c.4452>:
    1ed5:	41 00                                               A.

00001ed7 <__c.4450>:
    1ed7:	56 00                                               V.

00001ed9 <__c.4447>:
    1ed9:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    1ee9:	78 74 20 20 00                                      xt  .

00001eee <__c.4445>:
    1eee:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    1efe:	20 20 20 20 00                                          .

00001f03 <__c.4443>:
    1f03:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    1f13:	20 20 20 20 00                                          .

00001f18 <__c.4441>:
    1f18:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f20 <__c.4438>:
    1f20:	25 73 00                                            %s.

00001f23 <__c.4435>:
    1f23:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1f33:	20 20 20 20 00                                          .

00001f38 <__c.4430>:
    1f38:	20 20 20 20 20 00                                        .

00001f3e <__c.4428>:
    1f3e:	25 64 2e 25 73 00                                   %d.%s.

00001f44 <__c.4426>:
    1f44:	25 73 00                                            %s.

00001f47 <__c.4424>:
    1f47:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00001f50 <__c.4420>:
    1f50:	25 2e 32 64 00                                      %.2d.

00001f55 <__c.4418>:
    1f55:	25 2e 32 64 00                                      %.2d.

00001f5a <__c.4414>:
    1f5a:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    1f6a:	23 5d 4f 4b 00                                      #]OK.

00001f6f <__c.4412>:
    1f6f:	25 73 20 25 73 00                                   %s %s.

00001f75 <__c.4410>:
    1f75:	25 73 00                                            %s.

00001f78 <__c.4408>:
    1f78:	25 73 00                                            %s.

00001f7b <__c.4406>:
    1f7b:	25 73 00                                            %s.

00001f7e <__c.4403>:
    1f7e:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    1f8e:	20 20 20 20 00                                          .

00001f93 <__c.4401>:
    1f93:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    1fa3:	20 20 20 20 00                                          .

00001fa8 <__c.4398>:
    1fa8:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    1fb8:	20 20 20 20 00                                          .

00001fbd <__c.4395>:
    1fbd:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    1fcd:	20 20 20 20 00                                          .

00001fd2 <__c.4393>:
    1fd2:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    1fe2:	20 20 20 20 00                                          .

00001fe7 <__c.4390>:
    1fe7:	20 20 20 20 20 20 20 00                                    .

00001fef <__c.4385>:
    1fef:	50 72 6f 73 65 73 00                                Proses.

00001ff6 <__c.4383>:
    1ff6:	49 44 3a 25 73 00                                   ID:%s.

00001ffc <__c.4381>:
    1ffc:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    200c:	20 20 20 00                                            .

00002010 <__c.4217>:
    2010:	25 2e 32 64 00                                      %.2d.

00002015 <__c.4169>:
    2015:	46 39 36 38 43 46 46 42 00                          F968CFFB.

0000201e <__c.4167>:
    201e:	25 73 00                                            %s.

00002021 <__c.4164>:
    2021:	25 73 25 73 25 73 00                                %s%s%s.

00002028 <__c.4162>:
    2028:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00002031 <__c.4159>:
    2031:	25 73 25 73 00                                      %s%s.

00002036 <__c.4156>:
    2036:	25 73 00                                            %s.

00002039 <__c.4154>:
    2039:	46 30 30 30 30 30 30 30 45 31 32 33 34 35 36 46     F0000000E123456F
    2049:	46 46 46 46 00                                      FFFF.

0000204e <__c.4152>:
    204e:	25 73 25 73 25 64 00                                %s%s%d.

00002055 <__c.4150>:
    2055:	25 73 25 73 25 64 00                                %s%s%d.

0000205c <__c.4147>:
    205c:	25 73 00                                            %s.

0000205f <__c.4144>:
    205f:	25 73 25 73 00                                      %s%s.

00002064 <__c.4142>:
    2064:	25 73 25 73 00                                      %s%s.

00002069 <__c.4140>:
    2069:	25 73 25 73 00                                      %s%s.

0000206e <__c.4137>:
    206e:	25 73 25 73 00                                      %s%s.

00002073 <__c.4134>:
    2073:	25 73 25 73 00                                      %s%s.

00002078 <__c.4131>:
    2078:	25 73 00                                            %s.

0000207b <__c.4126>:
    207b:	25 73 00                                            %s.

0000207e <__c.4123>:
    207e:	25 2e 32 58 00                                      %.2X.

00002083 <__c.4121>:
    2083:	25 2e 33 64 2e 25 2e 33 64 2e 25 2e 33 64 2e 25     %.3d.%.3d.%.3d.%
    2093:	2e 33 64 00                                         .3d.

00002097 <__c.4119>:
    2097:	25 2e 33 64 2e 25 2e 33 64 2e 25 2e 33 64 2e 25     %.3d.%.3d.%.3d.%
    20a7:	2e 33 64 00                                         .3d.

000020ab <__c.4117>:
    20ab:	25 2e 32 64 00                                      %.2d.

000020b0 <__c.4115>:
    20b0:	25 2e 32 64 00                                      %.2d.

000020b5 <__c.4027>:
    20b5:	25 73 20 25 73 00                                   %s %s.

000020bb <__c.4025>:
    20bb:	32 2e 33 39 00                                      2.39.

000020c0 <__c.4023>:
    20c0:	47 65 4e 69 55 73 00                                GeNiUs.

000020c7 <__c.4009>:
    20c7:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    20d7:	20 20 20 20 00                                          .

000020dc <__c.3997>:
    20dc:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    20ec:	64 61 6c 6f 6e 65 00                                dalone.

000020f3 <__c.3917>:
    20f3:	3e 00                                               >.

000020f5 <__c.3912>:
    20f5:	25 2e 32 64 00                                      %.2d.

000020fa <__c.3910>:
    20fa:	25 2e 32 64 00                                      %.2d.

000020ff <__c.3908>:
    20ff:	30 00                                               0.

00002101 <__c.3906>:
    2101:	31 00                                               1.

00002103 <__c.3898>:
    2103:	25 64 00                                            %d.

00002106 <__c.3893>:
    2106:	25 2e 32 64 00                                      %.2d.

0000210b <__c.3888>:
    210b:	25 73 00                                            %s.

0000210e <__c.3883>:
    210e:	25 73 00                                            %s.

00002111 <__c.3878>:
    2111:	25 73 00                                            %s.

00002114 <__c.3876>:
    2114:	3c 00                                               <.

00002116 <__c.3808>:
    2116:	3c 4f 4b 3e 00                                      <OK>.

0000211b <__c.3803>:
    211b:	25 64 00                                            %d.

0000211e <__c.3801>:
    211e:	25 64 00                                            %d.

00002121 <__c.3790>:
    2121:	25 64 00                                            %d.

00002124 <__c.3779>:
    2124:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

0000212d <__c.3777>:
    212d:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

00002137 <__c.3593>:
    2137:	25 73 00                                            %s.

0000213a <__c.3535>:
    213a:	25 73 00                                            %s.

0000213d <__c.3533>:
    213d:	25 73 00                                            %s.

00002140 <__c.3531>:
    2140:	25 73 00                                            %s.

00002143 <__c.3529>:
    2143:	25 73 00                                            %s.

00002146 <__c.3527>:
    2146:	25 2e 32 64 00                                      %.2d.

0000214b <__c.3525>:
    214b:	25 64 00                                            %d.

0000214e <__c.3523>:
    214e:	25 73 00                                            %s.

00002151 <__c.3521>:
    2151:	25 73 00                                            %s.

00002154 <__c.3519>:
    2154:	25 73 00                                            %s.

00002157 <__c.3517>:
    2157:	25 64 00                                            %d.

0000215a <__c.3515>:
    215a:	4e 2f 41 00                                         N/A.

0000215e <__c.3416>:
    215e:	25 64 00                                            %d.

00002161 <__c.3414>:
    2161:	25 73 00                                            %s.

00002164 <__c.3412>:
    2164:	25 73 00                                            %s.

00002167 <__c.3329>:
    2167:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    2177:	6b 73 69 20 00                                      ksi .

0000217c <__c.3326>:
    217c:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    218c:	20 00                                                .

0000218e <__c.3323>:
    218e:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    219e:	69 7a 65 72 00                                      izer.

000021a3 <__c.3311>:
    21a3:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

000021b4 <__c.3308>:
    21b4:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    21c4:	20 20 20 20 00                                          .

000021c9 <__c.3305>:
    21c9:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    21d9:	20 20 20 20 00                                          .

000021de <__c.3303>:
    21de:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    21ee:	20 20 20 20 00                                          .

000021f3 <__c.3300>:
    21f3:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    2203:	20 20 20 20 00                                          .

00002208 <__c.3297>:
    2208:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2218:	20 20 20 20 00                                          .

0000221d <__c.3294>:
    221d:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    222d:	6b 73 69 20 00                                      ksi .

00002232 <__c.3289>:
    2232:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

0000223f <__c.3286>:
    223f:	34 33 35 36 41 33 31 41 00                          4356A31A.

00002248 <__c.1750>:
    2248:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2258:	20 20 20 20 00                                          .

0000225d <__c.1748>:
    225d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    226d:	20 20 20 20 00                                          .

00002272 <__c.1746>:
    2272:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2282:	20 20 20 20 00                                          .

00002287 <__c.1744>:
    2287:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2297:	20 20 20 20 00                                          .

0000229c <__alphanum>:
    229c:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    22ac:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    22bc:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    22cc:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    22dc:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    22ec:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    22fc:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    230c:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

00002314 <__maxchar>:
    2314:	02 04 03 03 03 03 03 04 03 04                       ..........

0000231e <__ctors_end>:
    231e:	11 24       	eor	r1, r1
    2320:	1f be       	out	0x3f, r1	; 63
    2322:	cf ef       	ldi	r28, 0xFF	; 255
    2324:	d0 e1       	ldi	r29, 0x10	; 16
    2326:	de bf       	out	0x3e, r29	; 62
    2328:	cd bf       	out	0x3d, r28	; 61

0000232a <__do_copy_data>:
    232a:	11 e0       	ldi	r17, 0x01	; 1
    232c:	a0 e0       	ldi	r26, 0x00	; 0
    232e:	b1 e0       	ldi	r27, 0x01	; 1
    2330:	ee e0       	ldi	r30, 0x0E	; 14
    2332:	fb e5       	ldi	r31, 0x5B	; 91
    2334:	01 e0       	ldi	r16, 0x01	; 1
    2336:	0b bf       	out	0x3b, r16	; 59
    2338:	02 c0       	rjmp	.+4      	; 0x233e <__do_copy_data+0x14>
    233a:	07 90       	elpm	r0, Z+
    233c:	0d 92       	st	X+, r0
    233e:	ac 35       	cpi	r26, 0x5C	; 92
    2340:	b1 07       	cpc	r27, r17
    2342:	d9 f7       	brne	.-10     	; 0x233a <__do_copy_data+0x10>

00002344 <__do_clear_bss>:
    2344:	1c e0       	ldi	r17, 0x0C	; 12
    2346:	ac e5       	ldi	r26, 0x5C	; 92
    2348:	b1 e0       	ldi	r27, 0x01	; 1
    234a:	01 c0       	rjmp	.+2      	; 0x234e <.do_clear_bss_start>

0000234c <.do_clear_bss_loop>:
    234c:	1d 92       	st	X+, r1

0000234e <.do_clear_bss_start>:
    234e:	a3 3b       	cpi	r26, 0xB3	; 179
    2350:	b1 07       	cpc	r27, r17
    2352:	e1 f7       	brne	.-8      	; 0x234c <.do_clear_bss_loop>
    2354:	0e 94 3f 12 	call	0x247e	; 0x247e <main>
    2358:	0c 94 85 ad 	jmp	0x15b0a	; 0x15b0a <_exit>

0000235c <__bad_interrupt>:
    235c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00002360 <systemOnReset>:
	};
}


void systemOnReset(){
     IsPowerOn=False;
    2360:	10 92 ba 02 	sts	0x02BA, r1
     if (MCUCSR & 1){   // Power-on Reset
    2364:	04 b6       	in	r0, 0x34	; 52
    2366:	00 fe       	sbrs	r0, 0
    2368:	0b c0       	rjmp	.+22     	; 0x2380 <systemOnReset+0x20>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));//Wiznet Blm Ready
    236a:	14 be       	out	0x34, r1	; 52
    236c:	81 e0       	ldi	r24, 0x01	; 1
    236e:	61 e0       	ldi	r22, 0x01	; 1
    2370:	46 e9       	ldi	r20, 0x96	; 150
    2372:	52 e0       	ldi	r21, 0x02	; 2
    2374:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		 IsPowerOn=True;
    2378:	81 e0       	ldi	r24, 0x01	; 1
    237a:	80 93 ba 02 	sts	0x02BA, r24
    237e:	18 c0       	rjmp	.+48     	; 0x23b0 <systemOnReset+0x50>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    2380:	04 b6       	in	r0, 0x34	; 52
    2382:	01 fe       	sbrs	r0, 1
    2384:	06 c0       	rjmp	.+12     	; 0x2392 <systemOnReset+0x32>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    2386:	14 be       	out	0x34, r1	; 52
    2388:	81 e0       	ldi	r24, 0x01	; 1
    238a:	61 e0       	ldi	r22, 0x01	; 1
    238c:	4d e8       	ldi	r20, 0x8D	; 141
    238e:	52 e0       	ldi	r21, 0x02	; 2
    2390:	0d c0       	rjmp	.+26     	; 0x23ac <systemOnReset+0x4c>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    2392:	04 b6       	in	r0, 0x34	; 52
    2394:	02 fe       	sbrs	r0, 2
    2396:	06 c0       	rjmp	.+12     	; 0x23a4 <systemOnReset+0x44>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    2398:	14 be       	out	0x34, r1	; 52
    239a:	81 e0       	ldi	r24, 0x01	; 1
    239c:	61 e0       	ldi	r22, 0x01	; 1
    239e:	44 e8       	ldi	r20, 0x84	; 132
    23a0:	52 e0       	ldi	r21, 0x02	; 2
    23a2:	04 c0       	rjmp	.+8      	; 0x23ac <systemOnReset+0x4c>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    23a4:	81 e0       	ldi	r24, 0x01	; 1
    23a6:	61 e0       	ldi	r22, 0x01	; 1
    23a8:	4b e7       	ldi	r20, 0x7B	; 123
    23aa:	52 e0       	ldi	r21, 0x02	; 2
    23ac:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
        };
     MCUCSR=0;		  
    23b0:	14 be       	out	0x34, r1	; 52
    23b2:	80 ee       	ldi	r24, 0xE0	; 224
    23b4:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    23b6:	20 e7       	ldi	r18, 0x70	; 112
    23b8:	31 e0       	ldi	r19, 0x01	; 1
    23ba:	f9 01       	movw	r30, r18
    23bc:	31 97       	sbiw	r30, 0x01	; 1
    23be:	f1 f7       	brne	.-4      	; 0x23bc <systemOnReset+0x5c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    23c0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    23c2:	d9 f7       	brne	.-10     	; 0x23ba <systemOnReset+0x5a>
	 _delay_ms(1200);
}
    23c4:	08 95       	ret

000023c6 <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    23c6:	0e 94 61 a3 	call	0x146c2	; 0x146c2 <lcd_init>
	lcd_clear();
    23ca:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	BackLightTrig();
    23ce:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <BackLightTrig>
	systemOnReset();
    23d2:	0e 94 b0 11 	call	0x2360	; 0x2360 <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    23d6:	84 e0       	ldi	r24, 0x04	; 4
    23d8:	61 e0       	ldi	r22, 0x01	; 1
    23da:	4c e6       	ldi	r20, 0x6C	; 108
    23dc:	52 e0       	ldi	r21, 0x02	; 2
    23de:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    23e2:	88 eb       	ldi	r24, 0xB8	; 184
    23e4:	9b e0       	ldi	r25, 0x0B	; 11
    23e6:	20 e7       	ldi	r18, 0x70	; 112
    23e8:	31 e0       	ldi	r19, 0x01	; 1
    23ea:	f9 01       	movw	r30, r18
    23ec:	31 97       	sbiw	r30, 0x01	; 1
    23ee:	f1 f7       	brne	.-4      	; 0x23ec <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    23f0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    23f2:	d9 f7       	brne	.-10     	; 0x23ea <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    23f4:	9f ef       	ldi	r25, 0xFF	; 255
    23f6:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    23f8:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    23fa:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    23fc:	98 bb       	out	0x18, r25	; 24
    23fe:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    2400:	8d e0       	ldi	r24, 0x0D	; 13
    2402:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    2404:	89 e0       	ldi	r24, 0x09	; 9
    2406:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    2408:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    240c:	8e e0       	ldi	r24, 0x0E	; 14
    240e:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    2410:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    2412:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    2414:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    2416:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    241a:	80 ef       	ldi	r24, 0xF0	; 240
    241c:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    2420:	80 e0       	ldi	r24, 0x00	; 0
    2422:	61 e0       	ldi	r22, 0x01	; 1
    2424:	0e 94 59 a6 	call	0x14cb2	; 0x14cb2 <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    2428:	bb 9a       	sbi	0x17, 3	; 23
    242a:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    242c:	ba 98       	cbi	0x17, 2	; 23
    242e:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    2430:	b9 98       	cbi	0x17, 1	; 23
    2432:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    2434:	8e b5       	in	r24, 0x2e	; 46
    2436:	88 60       	ori	r24, 0x08	; 8
    2438:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    243a:	87 b7       	in	r24, 0x37	; 55
    243c:	80 61       	ori	r24, 0x10	; 16
    243e:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    2440:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    2442:	88 e0       	ldi	r24, 0x08	; 8
    2444:	9d e3       	ldi	r25, 0x3D	; 61
    2446:	9b bd       	out	0x2b, r25	; 43
    2448:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    244a:	8e b5       	in	r24, 0x2e	; 46
    244c:	83 60       	ori	r24, 0x03	; 3
    244e:	8e bd       	out	0x2e, r24	; 46

	SendSlaveCommand(SC_SLAVE,ST_NONE);
    2450:	81 e0       	ldi	r24, 0x01	; 1
    2452:	60 e0       	ldi	r22, 0x00	; 0
    2454:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
	
	InitComport();
    2458:	0e 94 05 78 	call	0xf00a	; 0xf00a <InitComport>
	_LIGHT_SET;
    245c:	81 e0       	ldi	r24, 0x01	; 1
    245e:	80 93 ae 02 	sts	0x02AE, r24
    2462:	10 92 af 02 	sts	0x02AF, r1
    2466:	80 91 65 00 	lds	r24, 0x0065
    246a:	8d 7f       	andi	r24, 0xFD	; 253
    246c:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    2470:	0e 94 94 42 	call	0x8528	; 0x8528 <InitPrinter>
    InitializeConnection();
    2474:	0e 94 cd 8f 	call	0x11f9a	; 0x11f9a <InitializeConnection>
	lcd_clear(); 
    2478:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
}
    247c:	08 95       	ret

0000247e <main>:

//Master4 =1+20++2+1
void SystemInit();
//Program Utama
int main(){
	SystemInit();
    247e:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    2482:	0e 94 2a a1 	call	0x14254	; 0x14254 <FMenuIdle>
    2486:	fd cf       	rjmp	.-6      	; 0x2482 <main+0x4>

00002488 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    2488:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    248a:	e1 99       	sbic	0x1c, 1	; 28
    248c:	fe cf       	rjmp	.-4      	; 0x248a <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    248e:	3f bb       	out	0x1f, r19	; 31
    2490:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2492:	e0 9a       	sbi	0x1c, 0	; 28
    2494:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    2496:	08 95       	ret

00002498 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    2498:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    249a:	e1 99       	sbic	0x1c, 1	; 28
    249c:	fe cf       	rjmp	.-4      	; 0x249a <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    249e:	3f bb       	out	0x1f, r19	; 31
    24a0:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    24a2:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    24a4:	0f b6       	in	r0, 0x3f	; 63
    24a6:	f8 94       	cli
    24a8:	e2 9a       	sbi	0x1c, 2	; 28
    24aa:	e1 9a       	sbi	0x1c, 1	; 28
    24ac:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    24ae:	08 95       	ret

000024b0 <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
    24b0:	1f 92       	push	r1
    24b2:	0f 92       	push	r0
    24b4:	0f b6       	in	r0, 0x3f	; 63
    24b6:	0f 92       	push	r0
    24b8:	11 24       	eor	r1, r1
    24ba:	2f 93       	push	r18
    24bc:	6f 93       	push	r22
    24be:	7f 93       	push	r23
    24c0:	8f 93       	push	r24
    24c2:	9f 93       	push	r25
	if(__key_light == 1){
    24c4:	80 91 ae 02 	lds	r24, 0x02AE
    24c8:	81 30       	cpi	r24, 0x01	; 1
    24ca:	81 f4       	brne	.+32     	; 0x24ec <__vector_12+0x3c>
		__key_lgtcnt++;
    24cc:	80 91 af 02 	lds	r24, 0x02AF
    24d0:	8f 5f       	subi	r24, 0xFF	; 255
    24d2:	80 93 af 02 	sts	0x02AF, r24
		if(__key_lgtcnt == 150){
    24d6:	86 39       	cpi	r24, 0x96	; 150
    24d8:	49 f4       	brne	.+18     	; 0x24ec <__vector_12+0x3c>
		   __key_light = 0; 
    24da:	10 92 ae 02 	sts	0x02AE, r1
		   __key_lgtcnt = 0; 
    24de:	10 92 af 02 	sts	0x02AF, r1
		   sbi(PORTG, 1);
    24e2:	80 91 65 00 	lds	r24, 0x0065
    24e6:	82 60       	ori	r24, 0x02	; 2
    24e8:	80 93 65 00 	sts	0x0065, r24
		   }
	}

	//Beep
	if (TimBeep>0){
    24ec:	80 91 bc 01 	lds	r24, 0x01BC
    24f0:	88 23       	and	r24, r24
    24f2:	31 f0       	breq	.+12     	; 0x2500 <__vector_12+0x50>
	    TimBeep--;
    24f4:	81 50       	subi	r24, 0x01	; 1
    24f6:	80 93 bc 01 	sts	0x01BC, r24
		DDRB=(DDRB|0b00100000);
    24fa:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
    24fc:	c5 98       	cbi	0x18, 5	; 24
    24fe:	05 c0       	rjmp	.+10     	; 0x250a <__vector_12+0x5a>
	    }
	else{PORTB=(PORTB|~PORTB);
    2500:	98 b3       	in	r25, 0x18	; 24
    2502:	88 b3       	in	r24, 0x18	; 24
    2504:	80 95       	com	r24
    2506:	89 2b       	or	r24, r25
    2508:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
    250a:	80 91 ba 01 	lds	r24, 0x01BA
    250e:	8f 5f       	subi	r24, 0xFF	; 255
    2510:	80 93 ba 01 	sts	0x01BA, r24
	//DisplaTicker
    TimTicker++;
    2514:	80 91 90 01 	lds	r24, 0x0190
    2518:	8f 5f       	subi	r24, 0xFF	; 255
    251a:	80 93 90 01 	sts	0x0190, r24
	TimPressed++;
    251e:	20 91 91 01 	lds	r18, 0x0191
    2522:	2f 5f       	subi	r18, 0xFF	; 255
    2524:	20 93 91 01 	sts	0x0191, r18
	if ((TimPressed%5)==0){
    2528:	82 2f       	mov	r24, r18
    252a:	65 e0       	ldi	r22, 0x05	; 5
    252c:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    2530:	99 23       	and	r25, r25
    2532:	71 f4       	brne	.+28     	; 0x2550 <__vector_12+0xa0>
	    PORTE = PORTE^0x04;
    2534:	83 b1       	in	r24, 0x03	; 3
    2536:	94 e0       	ldi	r25, 0x04	; 4
    2538:	89 27       	eor	r24, r25
    253a:	83 b9       	out	0x03, r24	; 3
	    TimDisplay++;
    253c:	80 91 92 01 	lds	r24, 0x0192
    2540:	8f 5f       	subi	r24, 0xFF	; 255
    2542:	80 93 92 01 	sts	0x0192, r24
		TimPrintBusy++;
    2546:	80 91 b6 01 	lds	r24, 0x01B6
    254a:	8f 5f       	subi	r24, 0xFF	; 255
    254c:	80 93 b6 01 	sts	0x01B6, r24
	}
	if ((TimPressed%PRESSED_DELAY)==0){
    2550:	82 2f       	mov	r24, r18
    2552:	6a e0       	ldi	r22, 0x0A	; 10
    2554:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    2558:	99 23       	and	r25, r25
    255a:	29 f4       	brne	.+10     	; 0x2566 <__vector_12+0xb6>
	     ProcTimeOut++;
    255c:	80 91 bb 01 	lds	r24, 0x01BB
    2560:	8f 5f       	subi	r24, 0xFF	; 255
    2562:	80 93 bb 01 	sts	0x01BB, r24
	}
	TimSend++;
    2566:	80 91 78 0c 	lds	r24, 0x0C78
    256a:	8f 5f       	subi	r24, 0xFF	; 255
    256c:	80 93 78 0c 	sts	0x0C78, r24
}
    2570:	9f 91       	pop	r25
    2572:	8f 91       	pop	r24
    2574:	7f 91       	pop	r23
    2576:	6f 91       	pop	r22
    2578:	2f 91       	pop	r18
    257a:	0f 90       	pop	r0
    257c:	0f be       	out	0x3f, r0	; 63
    257e:	0f 90       	pop	r0
    2580:	1f 90       	pop	r1
    2582:	18 95       	reti

00002584 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    2584:	86 e1       	ldi	r24, 0x16	; 22
    2586:	08 95       	ret

00002588 <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    2588:	e8 2f       	mov	r30, r24
    258a:	f0 e0       	ldi	r31, 0x00	; 0
    258c:	ee 31       	cpi	r30, 0x1E	; 30
    258e:	f1 05       	cpc	r31, r1
    2590:	70 f5       	brcc	.+92     	; 0x25ee <GetPumpStatusLabel+0x66>
    2592:	ea 5b       	subi	r30, 0xBA	; 186
    2594:	ff 4f       	sbci	r31, 0xFF	; 255
    2596:	ee 0f       	add	r30, r30
    2598:	ff 1f       	adc	r31, r31
    259a:	05 90       	lpm	r0, Z+
    259c:	f4 91       	lpm	r31, Z+
    259e:	e0 2d       	mov	r30, r0
    25a0:	09 94       	ijmp
    25a2:	81 e3       	ldi	r24, 0x31	; 49
    25a4:	08 95       	ret
    25a6:	85 e4       	ldi	r24, 0x45	; 69
    25a8:	08 95       	ret
    25aa:	82 e3       	ldi	r24, 0x32	; 50
    25ac:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    25ae:	83 e3       	ldi	r24, 0x33	; 51
    25b0:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    25b2:	84 e3       	ldi	r24, 0x34	; 52
    25b4:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    25b6:	85 e3       	ldi	r24, 0x35	; 53
    25b8:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    25ba:	89 e6       	ldi	r24, 0x69	; 105
    25bc:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    25be:	8e e6       	ldi	r24, 0x6E	; 110
    25c0:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    25c2:	81 e6       	ldi	r24, 0x61	; 97
    25c4:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    25c6:	84 e6       	ldi	r24, 0x64	; 100
    25c8:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    25ca:	8f e4       	ldi	r24, 0x4F	; 79
    25cc:	08 95       	ret
	 case PUMP_PEOT: 
	 	  Result='O';
		  break;
    25ce:	86 e4       	ldi	r24, 0x46	; 70
    25d0:	08 95       	ret
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    25d2:	83 e5       	ldi	r24, 0x53	; 83
    25d4:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    25d6:	8d e2       	ldi	r24, 0x2D	; 45
    25d8:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    25da:	80 e5       	ldi	r24, 0x50	; 80
    25dc:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
    25de:	89 e4       	ldi	r24, 0x49	; 73
    25e0:	08 95       	ret
     case PS_PRINTED:
	      Result='I';
 	      break;
    25e2:	86 e5       	ldi	r24, 0x56	; 86
    25e4:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    25e6:	84 e5       	ldi	r24, 0x54	; 84
    25e8:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    25ea:	84 e7       	ldi	r24, 0x74	; 116
    25ec:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    25ee:	88 e7       	ldi	r24, 0x78	; 120
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    25f0:	08 95       	ret

000025f2 <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    25f2:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    25f6:	60 93 d3 0b 	sts	0x0BD3, r22
     IsControlPooling=True;
    25fa:	81 e0       	ldi	r24, 0x01	; 1
    25fc:	80 93 84 01 	sts	0x0184, r24
}
    2600:	08 95       	ret

00002602 <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    2602:	28 2f       	mov	r18, r24


	 //uart(0,1,data);

     //EDC-MSG
     if (data==0x02){
    2604:	82 30       	cpi	r24, 0x02	; 2
    2606:	39 f4       	brne	.+14     	; 0x2616 <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    2608:	81 e0       	ldi	r24, 0x01	; 1
    260a:	80 93 a3 02 	sts	0x02A3, r24
		 nFlow=0;
    260e:	10 92 a2 02 	sts	0x02A2, r1
    2612:	10 92 a1 02 	sts	0x02A1, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    2616:	80 91 a3 02 	lds	r24, 0x02A3
    261a:	81 30       	cpi	r24, 0x01	; 1
    261c:	69 f4       	brne	.+26     	; 0x2638 <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    261e:	80 91 a1 02 	lds	r24, 0x02A1
    2622:	90 91 a2 02 	lds	r25, 0x02A2
    2626:	fc 01       	movw	r30, r24
    2628:	e3 5e       	subi	r30, 0xE3	; 227
    262a:	f6 4f       	sbci	r31, 0xF6	; 246
    262c:	20 83       	st	Z, r18
		 nFlow++;
    262e:	01 96       	adiw	r24, 0x01	; 1
    2630:	90 93 a2 02 	sts	0x02A2, r25
    2634:	80 93 a1 02 	sts	0x02A1, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    2638:	23 30       	cpi	r18, 0x03	; 3
    263a:	41 f0       	breq	.+16     	; 0x264c <ScanEDCFlow+0x4a>
    263c:	80 91 a1 02 	lds	r24, 0x02A1
    2640:	90 91 a2 02 	lds	r25, 0x02A2
    2644:	8d 34       	cpi	r24, 0x4D	; 77
    2646:	91 05       	cpc	r25, r1
    2648:	08 f4       	brcc	.+2      	; 0x264c <ScanEDCFlow+0x4a>
    264a:	99 c0       	rjmp	.+306    	; 0x277e <ScanEDCFlow+0x17c>
	     //for(i=0;i<nFlow;i++){uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    264c:	10 92 a3 02 	sts	0x02A3, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    2650:	30 91 1f 09 	lds	r19, 0x091F
    2654:	30 51       	subi	r19, 0x10	; 16
    2656:	80 91 1e 09 	lds	r24, 0x091E
    265a:	2a e0       	ldi	r18, 0x0A	; 10
    265c:	82 9f       	mul	r24, r18
    265e:	c0 01       	movw	r24, r0
    2660:	11 24       	eor	r1, r1
    2662:	38 0f       	add	r19, r24

		 if (EDCMsgCode==0x03){
    2664:	33 30       	cpi	r19, 0x03	; 3
    2666:	09 f0       	breq	.+2      	; 0x266a <ScanEDCFlow+0x68>
    2668:	65 c0       	rjmp	.+202    	; 0x2734 <ScanEDCFlow+0x132>
    266a:	e0 e2       	ldi	r30, 0x20	; 32
    266c:	f9 e0       	ldi	r31, 0x09	; 9
    266e:	a7 e8       	ldi	r26, 0x87	; 135
    2670:	bc e0       	ldi	r27, 0x0C	; 12
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2672:	81 91       	ld	r24, Z+
    2674:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2676:	89 e0       	ldi	r24, 0x09	; 9
    2678:	e6 32       	cpi	r30, 0x26	; 38
    267a:	f8 07       	cpc	r31, r24
    267c:	d1 f7       	brne	.-12     	; 0x2672 <ScanEDCFlow+0x70>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    267e:	10 92 8d 0c 	sts	0x0C8D, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2682:	80 81       	ld	r24, Z
    2684:	80 93 b9 07 	sts	0x07B9, r24
    2688:	81 81       	ldd	r24, Z+1	; 0x01
    268a:	80 93 ba 07 	sts	0x07BA, r24
	 }Dest[Length]=0;
    268e:	10 92 bb 07 	sts	0x07BB, r1
    2692:	32 96       	adiw	r30, 0x02	; 2
    2694:	a3 ea       	ldi	r26, 0xA3	; 163
    2696:	bc e0       	ldi	r27, 0x0C	; 12
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2698:	81 91       	ld	r24, Z+
    269a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    269c:	89 e0       	ldi	r24, 0x09	; 9
    269e:	e7 33       	cpi	r30, 0x37	; 55
    26a0:	f8 07       	cpc	r31, r24
    26a2:	d1 f7       	brne	.-12     	; 0x2698 <ScanEDCFlow+0x96>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26a4:	10 92 b2 0c 	sts	0x0CB2, r1
    26a8:	a9 e8       	ldi	r26, 0x89	; 137
    26aa:	bb e0       	ldi	r27, 0x0B	; 11
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    26ac:	81 91       	ld	r24, Z+
    26ae:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26b0:	89 e0       	ldi	r24, 0x09	; 9
    26b2:	ea 34       	cpi	r30, 0x4A	; 74
    26b4:	f8 07       	cpc	r31, r24
    26b6:	d1 f7       	brne	.-12     	; 0x26ac <ScanEDCFlow+0xaa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26b8:	10 92 9c 0b 	sts	0x0B9C, r1
    26bc:	20 e0       	ldi	r18, 0x00	; 0
    26be:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    26c0:	f9 01       	movw	r30, r18
    26c2:	e0 51       	subi	r30, 0x10	; 16
    26c4:	f8 4f       	sbci	r31, 0xF8	; 248
    26c6:	d9 01       	movw	r26, r18
    26c8:	a3 5e       	subi	r26, 0xE3	; 227
    26ca:	b6 4f       	sbci	r27, 0xF6	; 246
    26cc:	9d 96       	adiw	r26, 0x2d	; 45
    26ce:	8c 91       	ld	r24, X
    26d0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26d2:	2f 5f       	subi	r18, 0xFF	; 255
    26d4:	3f 4f       	sbci	r19, 0xFF	; 255
    26d6:	26 30       	cpi	r18, 0x06	; 6
    26d8:	31 05       	cpc	r19, r1
    26da:	91 f7       	brne	.-28     	; 0x26c0 <ScanEDCFlow+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26dc:	10 92 f6 07 	sts	0x07F6, r1
    26e0:	20 e0       	ldi	r18, 0x00	; 0
    26e2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    26e4:	f9 01       	movw	r30, r18
    26e6:	ed 5a       	subi	r30, 0xAD	; 173
    26e8:	f8 4f       	sbci	r31, 0xF8	; 248
    26ea:	d9 01       	movw	r26, r18
    26ec:	a3 5e       	subi	r26, 0xE3	; 227
    26ee:	b6 4f       	sbci	r27, 0xF6	; 246
    26f0:	d3 96       	adiw	r26, 0x33	; 51
    26f2:	8c 91       	ld	r24, X
    26f4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26f6:	2f 5f       	subi	r18, 0xFF	; 255
    26f8:	3f 4f       	sbci	r19, 0xFF	; 255
    26fa:	2a 30       	cpi	r18, 0x0A	; 10
    26fc:	31 05       	cpc	r19, r1
    26fe:	91 f7       	brne	.-28     	; 0x26e4 <ScanEDCFlow+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2700:	10 92 5d 07 	sts	0x075D, r1
    2704:	20 e0       	ldi	r18, 0x00	; 0
    2706:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2708:	f9 01       	movw	r30, r18
    270a:	e1 54       	subi	r30, 0x41	; 65
    270c:	f4 4f       	sbci	r31, 0xF4	; 244
    270e:	d9 01       	movw	r26, r18
    2710:	a3 5e       	subi	r26, 0xE3	; 227
    2712:	b6 4f       	sbci	r27, 0xF6	; 246
    2714:	dd 96       	adiw	r26, 0x3d	; 61
    2716:	8c 91       	ld	r24, X
    2718:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    271a:	2f 5f       	subi	r18, 0xFF	; 255
    271c:	3f 4f       	sbci	r19, 0xFF	; 255
    271e:	2e 30       	cpi	r18, 0x0E	; 14
    2720:	31 05       	cpc	r19, r1
    2722:	91 f7       	brne	.-28     	; 0x2708 <ScanEDCFlow+0x106>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2724:	10 92 cd 0b 	sts	0x0BCD, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    2728:	81 e0       	ldi	r24, 0x01	; 1
    272a:	80 93 99 01 	sts	0x0199, r24
			 IsPrintApprovalCode=True;
    272e:	80 93 9a 01 	sts	0x019A, r24
    2732:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    2734:	34 30       	cpi	r19, 0x04	; 4
    2736:	19 f5       	brne	.+70     	; 0x277e <ScanEDCFlow+0x17c>
    2738:	e0 e2       	ldi	r30, 0x20	; 32
    273a:	f9 e0       	ldi	r31, 0x09	; 9
    273c:	a0 ef       	ldi	r26, 0xF0	; 240
    273e:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2740:	81 91       	ld	r24, Z+
    2742:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2744:	89 e0       	ldi	r24, 0x09	; 9
    2746:	e6 32       	cpi	r30, 0x26	; 38
    2748:	f8 07       	cpc	r31, r24
    274a:	d1 f7       	brne	.-12     	; 0x2740 <ScanEDCFlow+0x13e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    274c:	10 92 f6 07 	sts	0x07F6, r1
    2750:	a3 e5       	ldi	r26, 0x53	; 83
    2752:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2754:	81 91       	ld	r24, Z+
    2756:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2758:	89 e0       	ldi	r24, 0x09	; 9
    275a:	e0 33       	cpi	r30, 0x30	; 48
    275c:	f8 07       	cpc	r31, r24
    275e:	d1 f7       	brne	.-12     	; 0x2754 <ScanEDCFlow+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2760:	10 92 5d 07 	sts	0x075D, r1
    2764:	af eb       	ldi	r26, 0xBF	; 191
    2766:	bb e0       	ldi	r27, 0x0B	; 11
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2768:	81 91       	ld	r24, Z+
    276a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    276c:	89 e0       	ldi	r24, 0x09	; 9
    276e:	ee 33       	cpi	r30, 0x3E	; 62
    2770:	f8 07       	cpc	r31, r24
    2772:	d1 f7       	brne	.-12     	; 0x2768 <ScanEDCFlow+0x166>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2774:	10 92 cd 0b 	sts	0x0BCD, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    2778:	81 e0       	ldi	r24, 0x01	; 1
    277a:	80 93 9b 01 	sts	0x019B, r24
    277e:	08 95       	ret

00002780 <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    2780:	08 95       	ret

00002782 <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    2782:	98 2f       	mov	r25, r24
    2784:	ef e6       	ldi	r30, 0x6F	; 111
    2786:	f8 e0       	ldi	r31, 0x08	; 8
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    2788:	80 81       	ld	r24, Z
    278a:	81 83       	std	Z+1, r24	; 0x01
    278c:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    278e:	88 e0       	ldi	r24, 0x08	; 8
    2790:	ec 35       	cpi	r30, 0x5C	; 92
    2792:	f8 07       	cpc	r31, r24
    2794:	c9 f7       	brne	.-14     	; 0x2788 <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    2796:	9f 01       	movw	r18, r30
    2798:	2f 5f       	subi	r18, 0xFF	; 255
    279a:	3f 4f       	sbci	r19, 0xFF	; 255
    279c:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    279e:	84 85       	ldd	r24, Z+12	; 0x0c
    27a0:	82 30       	cpi	r24, 0x02	; 2
    27a2:	f9 f4       	brne	.+62     	; 0x27e2 <ScanRFIDFlow+0x60>
    27a4:	80 91 5e 08 	lds	r24, 0x085E
    27a8:	8a 30       	cpi	r24, 0x0A	; 10
    27aa:	d9 f4       	brne	.+54     	; 0x27e2 <ScanRFIDFlow+0x60>
    27ac:	93 30       	cpi	r25, 0x03	; 3
    27ae:	c9 f4       	brne	.+50     	; 0x27e2 <ScanRFIDFlow+0x60>
    27b0:	f9 01       	movw	r30, r18
    27b2:	3a 96       	adiw	r30, 0x0a	; 10
    27b4:	a1 e5       	ldi	r26, 0x51	; 81
    27b6:	bc e0       	ldi	r27, 0x0C	; 12
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    27b8:	80 81       	ld	r24, Z
    27ba:	8d 93       	st	X+, r24
    27bc:	31 97       	sbiw	r30, 0x01	; 1
    27be:	88 e0       	ldi	r24, 0x08	; 8
    27c0:	ef 35       	cpi	r30, 0x5F	; 95
    27c2:	f8 07       	cpc	r31, r24
    27c4:	c9 f7       	brne	.-14     	; 0x27b8 <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    27c6:	10 92 59 0c 	sts	0x0C59, r1
	    IsRFIDDetected=True;
    27ca:	81 e0       	ldi	r24, 0x01	; 1
    27cc:	80 93 98 01 	sts	0x0198, r24
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    27d0:	80 93 ae 02 	sts	0x02AE, r24
	 __key_lgtcnt = 0; 
    27d4:	10 92 af 02 	sts	0x02AF, r1
	 PORTG=PORTG&0b11111101;
    27d8:	80 91 65 00 	lds	r24, 0x0065
    27dc:	8d 7f       	andi	r24, 0xFD	; 253
    27de:	80 93 65 00 	sts	0x0065, r24
    27e2:	08 95       	ret

000027e4 <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    27e4:	1f 92       	push	r1
    27e6:	0f 92       	push	r0
    27e8:	0f b6       	in	r0, 0x3f	; 63
    27ea:	0f 92       	push	r0
    27ec:	11 24       	eor	r1, r1
    27ee:	8f 93       	push	r24
    27f0:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    27f2:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    27f4:	80 91 b2 01 	lds	r24, 0x01B2
    27f8:	81 30       	cpi	r24, 0x01	; 1
    27fa:	21 f0       	breq	.+8      	; 0x2804 <__vector_18+0x20>
    27fc:	80 91 b4 01 	lds	r24, 0x01B4
    2800:	81 30       	cpi	r24, 0x01	; 1
    2802:	51 f4       	brne	.+20     	; 0x2818 <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    2804:	93 31       	cpi	r25, 0x13	; 19
    2806:	21 f4       	brne	.+8      	; 0x2810 <__vector_18+0x2c>
    2808:	81 e0       	ldi	r24, 0x01	; 1
    280a:	80 93 b3 01 	sts	0x01B3, r24
    280e:	04 c0       	rjmp	.+8      	; 0x2818 <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    2810:	91 31       	cpi	r25, 0x11	; 17
    2812:	11 f4       	brne	.+4      	; 0x2818 <__vector_18+0x34>
    2814:	10 92 b3 01 	sts	0x01B3, r1
	}
}
    2818:	9f 91       	pop	r25
    281a:	8f 91       	pop	r24
    281c:	0f 90       	pop	r0
    281e:	0f be       	out	0x3f, r0	; 63
    2820:	0f 90       	pop	r0
    2822:	1f 90       	pop	r1
    2824:	18 95       	reti

00002826 <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    2826:	80 e0       	ldi	r24, 0x00	; 0
    2828:	08 95       	ret

0000282a <ConfigProtocol>:
	 }
	 uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    282a:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    282c:	80 91 9f 02 	lds	r24, 0x029F
    2830:	89 36       	cpi	r24, 0x69	; 105
    2832:	e9 f4       	brne	.+58     	; 0x286e <ConfigProtocol+0x44>
    2834:	80 91 9e 02 	lds	r24, 0x029E
    2838:	83 34       	cpi	r24, 0x43	; 67
    283a:	c9 f4       	brne	.+50     	; 0x286e <ConfigProtocol+0x44>
    283c:	80 91 9d 02 	lds	r24, 0x029D
    2840:	8f 36       	cpi	r24, 0x6F	; 111
    2842:	a9 f4       	brne	.+42     	; 0x286e <ConfigProtocol+0x44>
    2844:	80 91 9c 02 	lds	r24, 0x029C
    2848:	8e 36       	cpi	r24, 0x6E	; 110
    284a:	89 f4       	brne	.+34     	; 0x286e <ConfigProtocol+0x44>
    284c:	80 91 9b 02 	lds	r24, 0x029B
    2850:	86 36       	cpi	r24, 0x66	; 102
    2852:	69 f4       	brne	.+26     	; 0x286e <ConfigProtocol+0x44>
    2854:	80 91 9a 02 	lds	r24, 0x029A
    2858:	8f 33       	cpi	r24, 0x3F	; 63
    285a:	49 f4       	brne	.+18     	; 0x286e <ConfigProtocol+0x44>
    285c:	80 91 99 02 	lds	r24, 0x0299
    2860:	8d 30       	cpi	r24, 0x0D	; 13
    2862:	29 f4       	brne	.+10     	; 0x286e <ConfigProtocol+0x44>
    2864:	2a 30       	cpi	r18, 0x0A	; 10
    2866:	19 f4       	brne	.+6      	; 0x286e <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    2868:	82 e0       	ldi	r24, 0x02	; 2
    286a:	80 93 b0 01 	sts	0x01B0, r24
	}

	if (IsConfigFlow==True){        
    286e:	80 91 85 01 	lds	r24, 0x0185
    2872:	81 30       	cpi	r24, 0x01	; 1
    2874:	69 f4       	brne	.+26     	; 0x2890 <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    2876:	80 91 89 01 	lds	r24, 0x0189
    287a:	90 91 8a 01 	lds	r25, 0x018A
    287e:	fc 01       	movw	r30, r24
    2880:	e3 5e       	subi	r30, 0xE3	; 227
    2882:	f6 4f       	sbci	r31, 0xF6	; 246
    2884:	20 83       	st	Z, r18
	    char_count++; 
    2886:	01 96       	adiw	r24, 0x01	; 1
    2888:	90 93 8a 01 	sts	0x018A, r25
    288c:	80 93 89 01 	sts	0x0189, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    2890:	80 91 99 02 	lds	r24, 0x0299
    2894:	84 30       	cpi	r24, 0x04	; 4
    2896:	51 f4       	brne	.+20     	; 0x28ac <ConfigProtocol+0x82>
    2898:	20 34       	cpi	r18, 0x40	; 64
    289a:	e9 f4       	brne	.+58     	; 0x28d6 <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	80 93 85 01 	sts	0x0185, r24
		 char_count=0;
    28a2:	10 92 8a 01 	sts	0x018A, r1
    28a6:	10 92 89 01 	sts	0x0189, r1
    28aa:	15 c0       	rjmp	.+42     	; 0x28d6 <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    28ac:	85 30       	cpi	r24, 0x05	; 5
    28ae:	99 f4       	brne	.+38     	; 0x28d6 <ConfigProtocol+0xac>
    28b0:	20 35       	cpi	r18, 0x50	; 80
    28b2:	89 f4       	brne	.+34     	; 0x28d6 <ConfigProtocol+0xac>
	     transLength=char_count;
    28b4:	80 91 89 01 	lds	r24, 0x0189
    28b8:	90 91 8a 01 	lds	r25, 0x018A
    28bc:	90 93 8c 01 	sts	0x018C, r25
    28c0:	80 93 8b 01 	sts	0x018B, r24
		 char_count=0;
    28c4:	10 92 8a 01 	sts	0x018A, r1
    28c8:	10 92 89 01 	sts	0x0189, r1
	     IsConfigFlow=False;
    28cc:	10 92 85 01 	sts	0x0185, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    28d0:	81 e0       	ldi	r24, 0x01	; 1
    28d2:	80 93 b0 01 	sts	0x01B0, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    28d6:	80 91 9e 02 	lds	r24, 0x029E
    28da:	80 93 9f 02 	sts	0x029F, r24
	Conflow[5]=Conflow[4];
    28de:	80 91 9d 02 	lds	r24, 0x029D
    28e2:	80 93 9e 02 	sts	0x029E, r24
	Conflow[4]=Conflow[3];
    28e6:	80 91 9c 02 	lds	r24, 0x029C
    28ea:	80 93 9d 02 	sts	0x029D, r24
	Conflow[3]=Conflow[2];
    28ee:	80 91 9b 02 	lds	r24, 0x029B
    28f2:	80 93 9c 02 	sts	0x029C, r24
	Conflow[2]=Conflow[1];
    28f6:	80 91 9a 02 	lds	r24, 0x029A
    28fa:	80 93 9b 02 	sts	0x029B, r24
	Conflow[1]=Conflow[0];
    28fe:	80 91 99 02 	lds	r24, 0x0299
    2902:	80 93 9a 02 	sts	0x029A, r24
	Conflow[0]=dataIn;
    2906:	20 93 99 02 	sts	0x0299, r18

}
    290a:	08 95       	ret

0000290c <system_beep>:
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    290c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    290e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    2910:	80 93 bc 01 	sts	0x01BC, r24
}
    2914:	08 95       	ret

00002916 <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2916:	08 95       	ret

00002918 <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2918:	8f 70       	andi	r24, 0x0F	; 15
    291a:	08 95       	ret

0000291c <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    291c:	82 95       	swap	r24
    291e:	8f 70       	andi	r24, 0x0F	; 15
    2920:	08 95       	ret

00002922 <Str>:
char Str(char H){
    2922:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2924:	8a 30       	cpi	r24, 0x0A	; 10
    2926:	10 f4       	brcc	.+4      	; 0x292c <Str+0xa>
    2928:	80 5d       	subi	r24, 0xD0	; 208
    292a:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    292c:	8a 50       	subi	r24, 0x0A	; 10
    292e:	86 30       	cpi	r24, 0x06	; 6
    2930:	10 f0       	brcs	.+4      	; 0x2936 <Str+0x14>
    2932:	80 e0       	ldi	r24, 0x00	; 0
    2934:	08 95       	ret
    2936:	89 2f       	mov	r24, r25
    2938:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    293a:	08 95       	ret

0000293c <charToHex>:

void charToHex(char X, char *Result){
    293c:	28 2f       	mov	r18, r24
    293e:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2940:	98 2f       	mov	r25, r24
    2942:	92 95       	swap	r25
    2944:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2946:	9a 30       	cpi	r25, 0x0A	; 10
    2948:	18 f4       	brcc	.+6      	; 0x2950 <charToHex+0x14>
    294a:	89 2f       	mov	r24, r25
    294c:	80 5d       	subi	r24, 0xD0	; 208
    294e:	08 c0       	rjmp	.+16     	; 0x2960 <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2950:	89 2f       	mov	r24, r25
    2952:	8a 50       	subi	r24, 0x0A	; 10
    2954:	86 30       	cpi	r24, 0x06	; 6
    2956:	10 f0       	brcs	.+4      	; 0x295c <charToHex+0x20>
    2958:	80 e0       	ldi	r24, 0x00	; 0
    295a:	02 c0       	rjmp	.+4      	; 0x2960 <charToHex+0x24>
    295c:	89 2f       	mov	r24, r25
    295e:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2960:	80 83       	st	Z, r24
	lcd_print(1,1,lcdteks);
}

char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2962:	92 2f       	mov	r25, r18
    2964:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2966:	9a 30       	cpi	r25, 0x0A	; 10
    2968:	18 f4       	brcc	.+6      	; 0x2970 <charToHex+0x34>
    296a:	89 2f       	mov	r24, r25
    296c:	80 5d       	subi	r24, 0xD0	; 208
    296e:	08 c0       	rjmp	.+16     	; 0x2980 <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2970:	89 2f       	mov	r24, r25
    2972:	8a 50       	subi	r24, 0x0A	; 10
    2974:	86 30       	cpi	r24, 0x06	; 6
    2976:	10 f0       	brcs	.+4      	; 0x297c <charToHex+0x40>
    2978:	80 e0       	ldi	r24, 0x00	; 0
    297a:	02 c0       	rjmp	.+4      	; 0x2980 <charToHex+0x44>
    297c:	89 2f       	mov	r24, r25
    297e:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2980:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2982:	12 82       	std	Z+2, r1	; 0x02
	 
}
    2984:	08 95       	ret

00002986 <strToInt>:

char strToInt(char *str){
    2986:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    2988:	80 81       	ld	r24, Z
    298a:	2a e0       	ldi	r18, 0x0A	; 10
    298c:	82 9f       	mul	r24, r18
    298e:	90 01       	movw	r18, r0
    2990:	11 24       	eor	r1, r1
    2992:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    2994:	82 0f       	add	r24, r18
    2996:	08 95       	ret

00002998 <intToStr>:

void intToStr(char X, char *str){
    2998:	58 2f       	mov	r21, r24
    299a:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    299c:	64 e6       	ldi	r22, 0x64	; 100
    299e:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    29a2:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    29a4:	85 2f       	mov	r24, r21
    29a6:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    29aa:	89 2f       	mov	r24, r25
    29ac:	6a e0       	ldi	r22, 0x0A	; 10
    29ae:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    29b2:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    29b4:	8c e9       	ldi	r24, 0x9C	; 156
    29b6:	9f ef       	ldi	r25, 0xFF	; 255
    29b8:	a8 9f       	mul	r26, r24
    29ba:	80 2d       	mov	r24, r0
    29bc:	11 24       	eor	r1, r1
    29be:	85 0f       	add	r24, r21
    29c0:	26 ef       	ldi	r18, 0xF6	; 246
    29c2:	3f ef       	ldi	r19, 0xFF	; 255
    29c4:	42 9f       	mul	r20, r18
    29c6:	90 2d       	mov	r25, r0
    29c8:	11 24       	eor	r1, r1
    29ca:	98 0f       	add	r25, r24
	 if (X>=100){
    29cc:	54 36       	cpi	r21, 0x64	; 100
    29ce:	40 f0       	brcs	.+16     	; 0x29e0 <intToStr+0x48>
	     str[0]=('0'+R);
    29d0:	a0 5d       	subi	r26, 0xD0	; 208
    29d2:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    29d4:	40 5d       	subi	r20, 0xD0	; 208
    29d6:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    29d8:	90 5d       	subi	r25, 0xD0	; 208
    29da:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    29dc:	13 82       	std	Z+3, r1	; 0x03
    29de:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    29e0:	5b 30       	cpi	r21, 0x0B	; 11
    29e2:	18 f4       	brcc	.+6      	; 0x29ea <intToStr+0x52>
	     str[0]=('0'+S);
    29e4:	90 5d       	subi	r25, 0xD0	; 208
    29e6:	90 83       	st	Z, r25
	     str[1]=0;
    29e8:	11 82       	std	Z+1, r1	; 0x01
    29ea:	08 95       	ret

000029ec <UpdateClientIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
	 */
}
    29ec:	08 95       	ret

000029ee <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
		 */
}
    29ee:	08 95       	ret

000029f0 <UpdateIFT_ID>:
void UpdateIFT_ID(){
    /* char IdIFT;
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
	 */
}
    29f0:	08 95       	ret

000029f2 <UpdateSeqNum>:
/*
     if (SeqNum<100)SeqNum++;
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 
    29f2:	08 95       	ret

000029f4 <ViewCardID>:
}




void ViewCardID(){//+12345678 -->12345678
    29f4:	20 e0       	ldi	r18, 0x00	; 0
    29f6:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    29f8:	f9 01       	movw	r30, r18
    29fa:	e7 57       	subi	r30, 0x77	; 119
    29fc:	f4 4f       	sbci	r31, 0xF4	; 244
    29fe:	d9 01       	movw	r26, r18
    2a00:	af 5a       	subi	r26, 0xAF	; 175
    2a02:	b3 4f       	sbci	r27, 0xF3	; 243
    2a04:	8c 91       	ld	r24, X
    2a06:	80 83       	st	Z, r24
    2a08:	2f 5f       	subi	r18, 0xFF	; 255
    2a0a:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2a0c:	28 30       	cpi	r18, 0x08	; 8
    2a0e:	31 05       	cpc	r19, r1
    2a10:	99 f7       	brne	.-26     	; 0x29f8 <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2a12:	10 92 91 0b 	sts	0x0B91, r1
}
    2a16:	08 95       	ret

00002a18 <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    2a18:	cf 93       	push	r28
    2a1a:	df 93       	push	r29
    2a1c:	db 01       	movw	r26, r22
    2a1e:	ec 01       	movw	r28, r24
    2a20:	20 e0       	ldi	r18, 0x00	; 0
    2a22:	30 e0       	ldi	r19, 0x00	; 0
    2a24:	07 c0       	rjmp	.+14     	; 0x2a34 <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    2a26:	fd 01       	movw	r30, r26
    2a28:	e2 0f       	add	r30, r18
    2a2a:	f3 1f       	adc	r31, r19
    2a2c:	89 91       	ld	r24, Y+
    2a2e:	80 83       	st	Z, r24
    2a30:	2f 5f       	subi	r18, 0xFF	; 255
    2a32:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2a34:	24 17       	cp	r18, r20
    2a36:	b8 f3       	brcs	.-18     	; 0x2a26 <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2a38:	a4 0f       	add	r26, r20
    2a3a:	b1 1d       	adc	r27, r1
    2a3c:	1c 92       	st	X, r1
}
    2a3e:	df 91       	pop	r29
    2a40:	cf 91       	pop	r28
    2a42:	08 95       	ret

00002a44 <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2a44:	cf 93       	push	r28
    2a46:	df 93       	push	r29
    2a48:	db 01       	movw	r26, r22
    2a4a:	ec 01       	movw	r28, r24
    2a4c:	c4 0f       	add	r28, r20
    2a4e:	d1 1d       	adc	r29, r1
    2a50:	40 e0       	ldi	r20, 0x00	; 0
    2a52:	50 e0       	ldi	r21, 0x00	; 0
    2a54:	07 c0       	rjmp	.+14     	; 0x2a64 <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2a56:	fd 01       	movw	r30, r26
    2a58:	e4 0f       	add	r30, r20
    2a5a:	f5 1f       	adc	r31, r21
    2a5c:	89 91       	ld	r24, Y+
    2a5e:	80 83       	st	Z, r24
    2a60:	4f 5f       	subi	r20, 0xFF	; 255
    2a62:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2a64:	42 17       	cp	r20, r18
    2a66:	b8 f3       	brcs	.-18     	; 0x2a56 <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2a68:	a2 0f       	add	r26, r18
    2a6a:	b1 1d       	adc	r27, r1
    2a6c:	1c 92       	st	X, r1
}
    2a6e:	df 91       	pop	r29
    2a70:	cf 91       	pop	r28
    2a72:	08 95       	ret

00002a74 <TestLocalAccount>:

void TestLocalAccount(){

}
    2a74:	08 95       	ret

00002a76 <BackLightTrig>:
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	80 93 ae 02 	sts	0x02AE, r24
	 __key_lgtcnt = 0; 
    2a7c:	10 92 af 02 	sts	0x02AF, r1
	 PORTG=PORTG&0b11111101;
    2a80:	e5 e6       	ldi	r30, 0x65	; 101
    2a82:	f0 e0       	ldi	r31, 0x00	; 0
    2a84:	80 81       	ld	r24, Z
    2a86:	8d 7f       	andi	r24, 0xFD	; 253
    2a88:	80 83       	st	Z, r24
}
    2a8a:	08 95       	ret

00002a8c <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2a8c:	82 30       	cpi	r24, 0x02	; 2
    2a8e:	59 f0       	breq	.+22     	; 0x2aa6 <GetBaudrate+0x1a>
    2a90:	82 30       	cpi	r24, 0x02	; 2
    2a92:	18 f0       	brcs	.+6      	; 0x2a9a <GetBaudrate+0xe>
    2a94:	83 30       	cpi	r24, 0x03	; 3
    2a96:	21 f4       	brne	.+8      	; 0x2aa0 <GetBaudrate+0x14>
    2a98:	09 c0       	rjmp	.+18     	; 0x2aac <GetBaudrate+0x20>
    2a9a:	20 e8       	ldi	r18, 0x80	; 128
    2a9c:	35 e2       	ldi	r19, 0x25	; 37
    2a9e:	08 c0       	rjmp	.+16     	; 0x2ab0 <GetBaudrate+0x24>
    2aa0:	20 e0       	ldi	r18, 0x00	; 0
    2aa2:	30 e0       	ldi	r19, 0x00	; 0
    2aa4:	05 c0       	rjmp	.+10     	; 0x2ab0 <GetBaudrate+0x24>
    2aa6:	20 e0       	ldi	r18, 0x00	; 0
    2aa8:	3b e4       	ldi	r19, 0x4B	; 75
    2aaa:	02 c0       	rjmp	.+4      	; 0x2ab0 <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2aac:	2b e9       	ldi	r18, 0x9B	; 155
    2aae:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2ab0:	c9 01       	movw	r24, r18
    2ab2:	08 95       	ret

00002ab4 <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2ab4:	e1 99       	sbic	0x1c, 1	; 28
    2ab6:	fe cf       	rjmp	.-4      	; 0x2ab4 <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2ab8:	84 e4       	ldi	r24, 0x44	; 68
    2aba:	91 e0       	ldi	r25, 0x01	; 1
    2abc:	9f bb       	out	0x1f, r25	; 31
    2abe:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2ac0:	e0 9a       	sbi	0x1c, 0	; 28
    2ac2:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2ac4:	80 93 5c 01 	sts	0x015C, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2ac8:	e1 99       	sbic	0x1c, 1	; 28
    2aca:	fe cf       	rjmp	.-4      	; 0x2ac8 <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2acc:	89 e4       	ldi	r24, 0x49	; 73
    2ace:	91 e0       	ldi	r25, 0x01	; 1
    2ad0:	9f bb       	out	0x1f, r25	; 31
    2ad2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2ad4:	e0 9a       	sbi	0x1c, 0	; 28
    2ad6:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2ad8:	80 93 5d 01 	sts	0x015D, r24
}
    2adc:	08 95       	ret

00002ade <InitStandalone>:
	      RunInitStandalone=False;
	      break;
	 }
  }
  */
}
    2ade:	08 95       	ret

00002ae0 <DisplayQueueFIP>:


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2ae0:	08 95       	ret

00002ae2 <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2ae2:	08 95       	ret

00002ae4 <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2ae4:	86 27       	eor	r24, r22
    2ae6:	08 95       	ret

00002ae8 <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2ae8:	08 95       	ret

00002aea <GeniusCalc>:


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
	 Result=0;
     switch(cOption){
    2aea:	88 23       	and	r24, r24
    2aec:	19 f0       	breq	.+6      	; 0x2af4 <GeniusCalc+0xa>
    2aee:	81 30       	cpi	r24, 0x01	; 1
    2af0:	49 f5       	brne	.+82     	; 0x2b44 <GeniusCalc+0x5a>
    2af2:	11 c0       	rjmp	.+34     	; 0x2b16 <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2af4:	26 2f       	mov	r18, r22
    2af6:	30 e0       	ldi	r19, 0x00	; 0
    2af8:	24 0f       	add	r18, r20
    2afa:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2afc:	c9 01       	movw	r24, r18
    2afe:	6a e0       	ldi	r22, 0x0A	; 10
    2b00:	70 e0       	ldi	r23, 0x00	; 0
    2b02:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    2b06:	48 2f       	mov	r20, r24
    2b08:	c9 01       	movw	r24, r18
    2b0a:	6a e0       	ldi	r22, 0x0A	; 10
    2b0c:	70 e0       	ldi	r23, 0x00	; 0
    2b0e:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    2b12:	46 0f       	add	r20, r22
    2b14:	18 c0       	rjmp	.+48     	; 0x2b46 <GeniusCalc+0x5c>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2b16:	66 23       	and	r22, r22
    2b18:	09 f4       	brne	.+2      	; 0x2b1c <GeniusCalc+0x32>
    2b1a:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2b1c:	44 23       	and	r20, r20
    2b1e:	09 f4       	brne	.+2      	; 0x2b22 <GeniusCalc+0x38>
    2b20:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2b22:	46 9f       	mul	r20, r22
    2b24:	90 01       	movw	r18, r0
    2b26:	11 24       	eor	r1, r1
    2b28:	c9 01       	movw	r24, r18
    2b2a:	6a e0       	ldi	r22, 0x0A	; 10
    2b2c:	70 e0       	ldi	r23, 0x00	; 0
    2b2e:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    2b32:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2b34:	c9 01       	movw	r24, r18
    2b36:	6a e0       	ldi	r22, 0x0A	; 10
    2b38:	70 e0       	ldi	r23, 0x00	; 0
    2b3a:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    2b3e:	64 2f       	mov	r22, r20
    2b40:	48 2f       	mov	r20, r24
    2b42:	d8 cf       	rjmp	.-80     	; 0x2af4 <GeniusCalc+0xa>
    2b44:	40 e0       	ldi	r20, 0x00	; 0
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2b46:	84 2f       	mov	r24, r20
    2b48:	08 95       	ret

00002b4a <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2b4a:	81 e0       	ldi	r24, 0x01	; 1
    2b4c:	08 95       	ret

00002b4e <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2b4e:	ff 92       	push	r15
    2b50:	0f 93       	push	r16
    2b52:	1f 93       	push	r17
    2b54:	cf 93       	push	r28
    2b56:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2b58:	f0 90 5c 01 	lds	r15, 0x015C
    2b5c:	ec 01       	movw	r28, r24
    2b5e:	00 e0       	ldi	r16, 0x00	; 0
    2b60:	10 e0       	ldi	r17, 0x00	; 0
    2b62:	09 c0       	rjmp	.+18     	; 0x2b76 <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2b64:	8e e0       	ldi	r24, 0x0E	; 14
    2b66:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    2b6a:	98 81       	ld	r25, Y
    2b6c:	98 17       	cp	r25, r24
    2b6e:	09 f4       	brne	.+2      	; 0x2b72 <CountNoPumpSatus+0x24>
		      Result++;		  
    2b70:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2b72:	0f 5f       	subi	r16, 0xFF	; 255
    2b74:	21 96       	adiw	r28, 0x01	; 1
    2b76:	0f 15       	cp	r16, r15
    2b78:	a8 f3       	brcs	.-22     	; 0x2b64 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2b7a:	81 2f       	mov	r24, r17
    2b7c:	df 91       	pop	r29
    2b7e:	cf 91       	pop	r28
    2b80:	1f 91       	pop	r17
    2b82:	0f 91       	pop	r16
    2b84:	ff 90       	pop	r15
    2b86:	08 95       	ret

00002b88 <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2b88:	08 95       	ret

00002b8a <FLockPump>:
char FLockPump(){

}
    2b8a:	08 95       	ret

00002b8c <FMenuSettingPassword>:
char FMenuSettingPassword(){
     char Result;
   //_menu_password();
   Result=MENU_DONE;
   return Result;
}
    2b8c:	81 e0       	ldi	r24, 0x01	; 1
    2b8e:	08 95       	ret

00002b90 <menu_product>:
   return Result;
}

void menu_product(){

}
    2b90:	08 95       	ret

00002b92 <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2b92:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2b94:	80 81       	ld	r24, Z
    2b96:	84 17       	cp	r24, r20
    2b98:	18 f4       	brcc	.+6      	; 0x2ba0 <IncValue+0xe>
	     (*Value)++;
    2b9a:	8f 5f       	subi	r24, 0xFF	; 255
    2b9c:	80 83       	st	Z, r24
    2b9e:	08 95       	ret
	 }else *Value=MinValue;
    2ba0:	60 83       	st	Z, r22
    2ba2:	08 95       	ret

00002ba4 <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2ba4:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2ba6:	80 81       	ld	r24, Z
    2ba8:	68 17       	cp	r22, r24
    2baa:	18 f4       	brcc	.+6      	; 0x2bb2 <DecValue+0xe>
	     (*Value)--;
    2bac:	81 50       	subi	r24, 0x01	; 1
    2bae:	80 83       	st	Z, r24
    2bb0:	08 95       	ret
	 }else *Value=MaxValue;
    2bb2:	40 83       	st	Z, r20
    2bb4:	08 95       	ret

00002bb6 <zeroIP>:
		 
		}

	}
}
void zeroIP(unsigned char Val,char *StrResult){
    2bb6:	58 2f       	mov	r21, r24
    2bb8:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2bba:	84 36       	cpi	r24, 0x64	; 100
    2bbc:	00 f1       	brcs	.+64     	; 0x2bfe <zeroIP+0x48>
	    R=(Val/100);
    2bbe:	64 e6       	ldi	r22, 0x64	; 100
    2bc0:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    2bc4:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2bc6:	85 2f       	mov	r24, r21
    2bc8:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    2bcc:	89 2f       	mov	r24, r25
    2bce:	6a e0       	ldi	r22, 0x0A	; 10
    2bd0:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2bd4:	40 5d       	subi	r20, 0xD0	; 208
    2bd6:	40 83       	st	Z, r20
    2bd8:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2bda:	80 5d       	subi	r24, 0xD0	; 208
    2bdc:	81 83       	std	Z+1, r24	; 0x01
    2bde:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2be0:	50 5d       	subi	r21, 0xD0	; 208
    2be2:	2c e9       	ldi	r18, 0x9C	; 156
    2be4:	3f ef       	ldi	r19, 0xFF	; 255
    2be6:	42 9f       	mul	r20, r18
    2be8:	40 2d       	mov	r20, r0
    2bea:	11 24       	eor	r1, r1
    2bec:	45 0f       	add	r20, r21
    2bee:	26 ef       	ldi	r18, 0xF6	; 246
    2bf0:	3f ef       	ldi	r19, 0xFF	; 255
    2bf2:	82 9f       	mul	r24, r18
    2bf4:	80 2d       	mov	r24, r0
    2bf6:	11 24       	eor	r1, r1
    2bf8:	84 0f       	add	r24, r20
    2bfa:	82 83       	std	Z+2, r24	; 0x02
    2bfc:	10 c0       	rjmp	.+32     	; 0x2c1e <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2bfe:	8a 50       	subi	r24, 0x0A	; 10
    2c00:	8a 35       	cpi	r24, 0x5A	; 90
    2c02:	78 f4       	brcc	.+30     	; 0x2c22 <zeroIP+0x6c>
        StrResult[0]='0';
    2c04:	80 e3       	ldi	r24, 0x30	; 48
    2c06:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2c08:	85 2f       	mov	r24, r21
    2c0a:	6a e0       	ldi	r22, 0x0A	; 10
    2c0c:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    2c10:	80 5d       	subi	r24, 0xD0	; 208
    2c12:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2c14:	85 2f       	mov	r24, r21
    2c16:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    2c1a:	90 5d       	subi	r25, 0xD0	; 208
    2c1c:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2c1e:	13 82       	std	Z+3, r1	; 0x03
    2c20:	08 95       	ret
		}
     else
	 if (Val<10){
    2c22:	5a 30       	cpi	r21, 0x0A	; 10
    2c24:	30 f4       	brcc	.+12     	; 0x2c32 <zeroIP+0x7c>
	    StrResult[0]='0';
    2c26:	80 e3       	ldi	r24, 0x30	; 48
    2c28:	80 83       	st	Z, r24
		StrResult[1]='0';
    2c2a:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2c2c:	50 5d       	subi	r21, 0xD0	; 208
    2c2e:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2c30:	13 82       	std	Z+3, r1	; 0x03
    2c32:	08 95       	ret

00002c34 <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2c34:	81 30       	cpi	r24, 0x01	; 1
    2c36:	29 f0       	breq	.+10     	; 0x2c42 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2c38:	82 30       	cpi	r24, 0x02	; 2
    2c3a:	19 f0       	breq	.+6      	; 0x2c42 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2c3c:	83 30       	cpi	r24, 0x03	; 3
    2c3e:	09 f0       	breq	.+2      	; 0x2c42 <GetLocAccStatus+0xe>
    2c40:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2c42:	08 95       	ret

00002c44 <FTestRemZero>:
	     RemZeroLead(strTest);  
		 uart_print(0,1,strTest);

	while (1){};
  #endif
}
    2c44:	08 95       	ret

00002c46 <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2c46:	cf 93       	push	r28
    2c48:	df 93       	push	r29
    2c4a:	eb 01       	movw	r28, r22
    2c4c:	da 01       	movw	r26, r20
    2c4e:	a8 0f       	add	r26, r24
    2c50:	b9 1f       	adc	r27, r25
    2c52:	40 e0       	ldi	r20, 0x00	; 0
    2c54:	50 e0       	ldi	r21, 0x00	; 0
    2c56:	07 c0       	rjmp	.+14     	; 0x2c66 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2c58:	fe 01       	movw	r30, r28
    2c5a:	e4 0f       	add	r30, r20
    2c5c:	f5 1f       	adc	r31, r21
    2c5e:	8d 91       	ld	r24, X+
    2c60:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2c62:	4f 5f       	subi	r20, 0xFF	; 255
    2c64:	5f 4f       	sbci	r21, 0xFF	; 255
    2c66:	42 17       	cp	r20, r18
    2c68:	53 07       	cpc	r21, r19
    2c6a:	b0 f3       	brcs	.-20     	; 0x2c58 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2c6c:	c2 0f       	add	r28, r18
    2c6e:	d3 1f       	adc	r29, r19
    2c70:	18 82       	st	Y, r1
}
    2c72:	df 91       	pop	r29
    2c74:	cf 91       	pop	r28
    2c76:	08 95       	ret

00002c78 <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2c78:	0f 93       	push	r16
    2c7a:	1f 93       	push	r17
    2c7c:	cf 93       	push	r28
    2c7e:	df 93       	push	r29
    2c80:	8c 01       	movw	r16, r24
    2c82:	db 01       	movw	r26, r22
    2c84:	eb 01       	movw	r28, r22
    2c86:	c4 0f       	add	r28, r20
    2c88:	d5 1f       	adc	r29, r21
    2c8a:	60 e0       	ldi	r22, 0x00	; 0
    2c8c:	70 e0       	ldi	r23, 0x00	; 0
    2c8e:	07 c0       	rjmp	.+14     	; 0x2c9e <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2c90:	f8 01       	movw	r30, r16
    2c92:	e6 0f       	add	r30, r22
    2c94:	f7 1f       	adc	r31, r23
    2c96:	80 81       	ld	r24, Z
    2c98:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2c9a:	6f 5f       	subi	r22, 0xFF	; 255
    2c9c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c9e:	62 17       	cp	r22, r18
    2ca0:	73 07       	cpc	r23, r19
    2ca2:	b0 f3       	brcs	.-20     	; 0x2c90 <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2ca4:	a4 0f       	add	r26, r20
    2ca6:	b5 1f       	adc	r27, r21
    2ca8:	a2 0f       	add	r26, r18
    2caa:	b3 1f       	adc	r27, r19
    2cac:	1c 92       	st	X, r1
}
    2cae:	df 91       	pop	r29
    2cb0:	cf 91       	pop	r28
    2cb2:	1f 91       	pop	r17
    2cb4:	0f 91       	pop	r16
    2cb6:	08 95       	ret

00002cb8 <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2cb8:	fb 01       	movw	r30, r22
    2cba:	e8 0f       	add	r30, r24
    2cbc:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2cbe:	80 81       	ld	r24, Z
    2cc0:	08 95       	ret

00002cc2 <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2cc2:	80 91 1d 09 	lds	r24, 0x091D
    2cc6:	81 30       	cpi	r24, 0x01	; 1
    2cc8:	51 f4       	brne	.+20     	; 0x2cde <procMessage00+0x1c>
    2cca:	80 91 8b 01 	lds	r24, 0x018B
    2cce:	90 91 8c 01 	lds	r25, 0x018C
    2cd2:	8f 97       	sbiw	r24, 0x2f	; 47
    2cd4:	21 f4       	brne	.+8      	; 0x2cde <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2cd6:	80 91 42 09 	lds	r24, 0x0942
    2cda:	80 53       	subi	r24, 0x30	; 48
    2cdc:	08 95       	ret
    2cde:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2ce0:	08 95       	ret

00002ce2 <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2ce2:	90 91 44 09 	lds	r25, 0x0944
    2ce6:	20 e0       	ldi	r18, 0x00	; 0
    2ce8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2cea:	f9 01       	movw	r30, r18
    2cec:	ee 56       	subi	r30, 0x6E	; 110
    2cee:	f7 4f       	sbci	r31, 0xF7	; 247
    2cf0:	d9 01       	movw	r26, r18
    2cf2:	a3 5e       	subi	r26, 0xE3	; 227
    2cf4:	b6 4f       	sbci	r27, 0xF6	; 246
    2cf6:	97 96       	adiw	r26, 0x27	; 39
    2cf8:	8c 91       	ld	r24, X
    2cfa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2cfc:	2f 5f       	subi	r18, 0xFF	; 255
    2cfe:	3f 4f       	sbci	r19, 0xFF	; 255
    2d00:	24 31       	cpi	r18, 0x14	; 20
    2d02:	31 05       	cpc	r19, r1
    2d04:	91 f7       	brne	.-28     	; 0x2cea <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d06:	10 92 a6 08 	sts	0x08A6, r1
    2d0a:	20 e0       	ldi	r18, 0x00	; 0
    2d0c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d0e:	f9 01       	movw	r30, r18
    2d10:	ed 55       	subi	r30, 0x5D	; 93
    2d12:	f8 4f       	sbci	r31, 0xF8	; 248
    2d14:	d9 01       	movw	r26, r18
    2d16:	a3 5e       	subi	r26, 0xE3	; 227
    2d18:	b6 4f       	sbci	r27, 0xF6	; 246
    2d1a:	db 96       	adiw	r26, 0x3b	; 59
    2d1c:	8c 91       	ld	r24, X
    2d1e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d20:	2f 5f       	subi	r18, 0xFF	; 255
    2d22:	3f 4f       	sbci	r19, 0xFF	; 255
    2d24:	24 31       	cpi	r18, 0x14	; 20
    2d26:	31 05       	cpc	r19, r1
    2d28:	91 f7       	brne	.-28     	; 0x2d0e <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d2a:	10 92 b7 07 	sts	0x07B7, r1
    2d2e:	20 e0       	ldi	r18, 0x00	; 0
    2d30:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d32:	f9 01       	movw	r30, r18
    2d34:	e4 5e       	subi	r30, 0xE4	; 228
    2d36:	f7 4f       	sbci	r31, 0xF7	; 247
    2d38:	d9 01       	movw	r26, r18
    2d3a:	a4 59       	subi	r26, 0x94	; 148
    2d3c:	b6 4f       	sbci	r27, 0xF6	; 246
    2d3e:	8c 91       	ld	r24, X
    2d40:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d42:	2f 5f       	subi	r18, 0xFF	; 255
    2d44:	3f 4f       	sbci	r19, 0xFF	; 255
    2d46:	24 31       	cpi	r18, 0x14	; 20
    2d48:	31 05       	cpc	r19, r1
    2d4a:	99 f7       	brne	.-26     	; 0x2d32 <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d4c:	10 92 30 08 	sts	0x0830, r1
    2d50:	20 e0       	ldi	r18, 0x00	; 0
    2d52:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d54:	f9 01       	movw	r30, r18
    2d56:	ea 52       	subi	r30, 0x2A	; 42
    2d58:	f4 4f       	sbci	r31, 0xF4	; 244
    2d5a:	d9 01       	movw	r26, r18
    2d5c:	a0 58       	subi	r26, 0x80	; 128
    2d5e:	b6 4f       	sbci	r27, 0xF6	; 246
    2d60:	8c 91       	ld	r24, X
    2d62:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d64:	2f 5f       	subi	r18, 0xFF	; 255
    2d66:	3f 4f       	sbci	r19, 0xFF	; 255
    2d68:	24 31       	cpi	r18, 0x14	; 20
    2d6a:	31 05       	cpc	r19, r1
    2d6c:	99 f7       	brne	.-26     	; 0x2d54 <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d6e:	10 92 ea 0b 	sts	0x0BEA, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    2d72:	89 2f       	mov	r24, r25
    2d74:	80 53       	subi	r24, 0x30	; 48
    2d76:	08 95       	ret

00002d78 <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2d78:	20 e0       	ldi	r18, 0x00	; 0
    2d7a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d7c:	f9 01       	movw	r30, r18
    2d7e:	e7 57       	subi	r30, 0x77	; 119
    2d80:	f4 4f       	sbci	r31, 0xF4	; 244
    2d82:	d9 01       	movw	r26, r18
    2d84:	a3 5e       	subi	r26, 0xE3	; 227
    2d86:	b6 4f       	sbci	r27, 0xF6	; 246
    2d88:	95 96       	adiw	r26, 0x25	; 37
    2d8a:	8c 91       	ld	r24, X
    2d8c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d8e:	2f 5f       	subi	r18, 0xFF	; 255
    2d90:	3f 4f       	sbci	r19, 0xFF	; 255
    2d92:	24 31       	cpi	r18, 0x14	; 20
    2d94:	31 05       	cpc	r19, r1
    2d96:	91 f7       	brne	.-28     	; 0x2d7c <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d98:	10 92 9d 0b 	sts	0x0B9D, r1
    2d9c:	20 e0       	ldi	r18, 0x00	; 0
    2d9e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2da0:	f9 01       	movw	r30, r18
    2da2:	ec 5d       	subi	r30, 0xDC	; 220
    2da4:	fc 4f       	sbci	r31, 0xFC	; 252
    2da6:	d9 01       	movw	r26, r18
    2da8:	a3 5e       	subi	r26, 0xE3	; 227
    2daa:	b6 4f       	sbci	r27, 0xF6	; 246
    2dac:	d9 96       	adiw	r26, 0x39	; 57
    2dae:	8c 91       	ld	r24, X
    2db0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2db2:	2f 5f       	subi	r18, 0xFF	; 255
    2db4:	3f 4f       	sbci	r19, 0xFF	; 255
    2db6:	2e 31       	cpi	r18, 0x1E	; 30
    2db8:	31 05       	cpc	r19, r1
    2dba:	91 f7       	brne	.-28     	; 0x2da0 <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2dbc:	10 92 42 03 	sts	0x0342, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2dc0:	80 91 74 09 	lds	r24, 0x0974
    2dc4:	80 93 8a 03 	sts	0x038A, r24
	 }Dest[Length]=0;
    2dc8:	10 92 8b 03 	sts	0x038B, r1
    2dcc:	20 e0       	ldi	r18, 0x00	; 0
    2dce:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2dd0:	f9 01       	movw	r30, r18
    2dd2:	eb 5c       	subi	r30, 0xCB	; 203
    2dd4:	f7 4f       	sbci	r31, 0xF7	; 247
    2dd6:	d9 01       	movw	r26, r18
    2dd8:	ab 58       	subi	r26, 0x8B	; 139
    2dda:	b6 4f       	sbci	r27, 0xF6	; 246
    2ddc:	8c 91       	ld	r24, X
    2dde:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2de0:	2f 5f       	subi	r18, 0xFF	; 255
    2de2:	3f 4f       	sbci	r19, 0xFF	; 255
    2de4:	28 30       	cpi	r18, 0x08	; 8
    2de6:	31 05       	cpc	r19, r1
    2de8:	99 f7       	brne	.-26     	; 0x2dd0 <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2dea:	10 92 3d 08 	sts	0x083D, r1
    2dee:	20 e0       	ldi	r18, 0x00	; 0
    2df0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2df2:	f9 01       	movw	r30, r18
    2df4:	e2 58       	subi	r30, 0x82	; 130
    2df6:	fc 4f       	sbci	r31, 0xFC	; 252
    2df8:	d9 01       	movw	r26, r18
    2dfa:	a3 58       	subi	r26, 0x83	; 131
    2dfc:	b6 4f       	sbci	r27, 0xF6	; 246
    2dfe:	8c 91       	ld	r24, X
    2e00:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e02:	2f 5f       	subi	r18, 0xFF	; 255
    2e04:	3f 4f       	sbci	r19, 0xFF	; 255
    2e06:	2a 30       	cpi	r18, 0x0A	; 10
    2e08:	31 05       	cpc	r19, r1
    2e0a:	99 f7       	brne	.-26     	; 0x2df2 <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e0c:	10 92 88 03 	sts	0x0388, r1
    2e10:	20 e0       	ldi	r18, 0x00	; 0
    2e12:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e14:	f9 01       	movw	r30, r18
    2e16:	e3 51       	subi	r30, 0x13	; 19
    2e18:	f4 4f       	sbci	r31, 0xF4	; 244
    2e1a:	d9 01       	movw	r26, r18
    2e1c:	a9 57       	subi	r26, 0x79	; 121
    2e1e:	b6 4f       	sbci	r27, 0xF6	; 246
    2e20:	8c 91       	ld	r24, X
    2e22:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e24:	2f 5f       	subi	r18, 0xFF	; 255
    2e26:	3f 4f       	sbci	r19, 0xFF	; 255
    2e28:	2a 30       	cpi	r18, 0x0A	; 10
    2e2a:	31 05       	cpc	r19, r1
    2e2c:	99 f7       	brne	.-26     	; 0x2e14 <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e2e:	10 92 f7 0b 	sts	0x0BF7, r1
    2e32:	20 e0       	ldi	r18, 0x00	; 0
    2e34:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e36:	f9 01       	movw	r30, r18
    2e38:	e1 54       	subi	r30, 0x41	; 65
    2e3a:	f4 4f       	sbci	r31, 0xF4	; 244
    2e3c:	d9 01       	movw	r26, r18
    2e3e:	af 56       	subi	r26, 0x6F	; 111
    2e40:	b6 4f       	sbci	r27, 0xF6	; 246
    2e42:	8c 91       	ld	r24, X
    2e44:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e46:	2f 5f       	subi	r18, 0xFF	; 255
    2e48:	3f 4f       	sbci	r19, 0xFF	; 255
    2e4a:	23 31       	cpi	r18, 0x13	; 19
    2e4c:	31 05       	cpc	r19, r1
    2e4e:	99 f7       	brne	.-26     	; 0x2e36 <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e50:	10 92 d2 0b 	sts	0x0BD2, r1
    2e54:	20 e0       	ldi	r18, 0x00	; 0
    2e56:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e58:	f9 01       	movw	r30, r18
    2e5a:	ed 54       	subi	r30, 0x4D	; 77
    2e5c:	f4 4f       	sbci	r31, 0xF4	; 244
    2e5e:	d9 01       	movw	r26, r18
    2e60:	ac 55       	subi	r26, 0x5C	; 92
    2e62:	b6 4f       	sbci	r27, 0xF6	; 246
    2e64:	8c 91       	ld	r24, X
    2e66:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e68:	2f 5f       	subi	r18, 0xFF	; 255
    2e6a:	3f 4f       	sbci	r19, 0xFF	; 255
    2e6c:	27 30       	cpi	r18, 0x07	; 7
    2e6e:	31 05       	cpc	r19, r1
    2e70:	99 f7       	brne	.-26     	; 0x2e58 <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e72:	10 92 ba 0b 	sts	0x0BBA, r1
    2e76:	20 e0       	ldi	r18, 0x00	; 0
    2e78:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e7a:	f9 01       	movw	r30, r18
    2e7c:	e5 54       	subi	r30, 0x45	; 69
    2e7e:	fd 4f       	sbci	r31, 0xFD	; 253
    2e80:	d9 01       	movw	r26, r18
    2e82:	a5 55       	subi	r26, 0x55	; 85
    2e84:	b6 4f       	sbci	r27, 0xF6	; 246
    2e86:	8c 91       	ld	r24, X
    2e88:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e8a:	2f 5f       	subi	r18, 0xFF	; 255
    2e8c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e8e:	24 30       	cpi	r18, 0x04	; 4
    2e90:	31 05       	cpc	r19, r1
    2e92:	99 f7       	brne	.-26     	; 0x2e7a <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e94:	10 92 bf 02 	sts	0x02BF, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    2e98:	80 e0       	ldi	r24, 0x00	; 0
    2e9a:	08 95       	ret

00002e9c <procMessage81>:
uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    2e9c:	cf 93       	push	r28
    2e9e:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    2ea0:	80 91 42 09 	lds	r24, 0x0942
    2ea4:	89 35       	cpi	r24, 0x59	; 89
    2ea6:	11 f4       	brne	.+4      	; 0x2eac <procMessage81+0x10>
    2ea8:	90 e8       	ldi	r25, 0x80	; 128
    2eaa:	01 c0       	rjmp	.+2      	; 0x2eae <procMessage81+0x12>
    2eac:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    2eae:	80 91 43 09 	lds	r24, 0x0943
    2eb2:	89 35       	cpi	r24, 0x59	; 89
    2eb4:	09 f4       	brne	.+2      	; 0x2eb8 <procMessage81+0x1c>
    2eb6:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    2eb8:	80 91 44 09 	lds	r24, 0x0944
    2ebc:	89 35       	cpi	r24, 0x59	; 89
    2ebe:	09 f4       	brne	.+2      	; 0x2ec2 <procMessage81+0x26>
    2ec0:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    2ec2:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    2ec4:	80 91 45 09 	lds	r24, 0x0945
    2ec8:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    2eca:	81 31       	cpi	r24, 0x11	; 17
    2ecc:	08 f4       	brcc	.+2      	; 0x2ed0 <procMessage81+0x34>
    2ece:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    2ed0:	c0 91 8d 01 	lds	r28, 0x018D
    2ed4:	d0 91 8e 01 	lds	r29, 0x018E
    2ed8:	20 e0       	ldi	r18, 0x00	; 0
    2eda:	30 e0       	ldi	r19, 0x00	; 0
    2edc:	0b c0       	rjmp	.+22     	; 0x2ef4 <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ede:	f9 01       	movw	r30, r18
    2ee0:	e4 51       	subi	r30, 0x14	; 20
    2ee2:	fc 4f       	sbci	r31, 0xFC	; 252
    2ee4:	d9 01       	movw	r26, r18
    2ee6:	a3 5e       	subi	r26, 0xE3	; 227
    2ee8:	b6 4f       	sbci	r27, 0xF6	; 246
    2eea:	9c 96       	adiw	r26, 0x2c	; 44
    2eec:	8c 91       	ld	r24, X
    2eee:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ef0:	2f 5f       	subi	r18, 0xFF	; 255
    2ef2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef4:	2c 17       	cp	r18, r28
    2ef6:	3d 07       	cpc	r19, r29
    2ef8:	90 f3       	brcs	.-28     	; 0x2ede <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2efa:	c4 51       	subi	r28, 0x14	; 20
    2efc:	dc 4f       	sbci	r29, 0xFC	; 252
    2efe:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    2f00:	89 2f       	mov	r24, r25
    2f02:	df 91       	pop	r29
    2f04:	cf 91       	pop	r28
    2f06:	08 95       	ret

00002f08 <FillChar>:
	 if(CutType== 1) { uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    2f08:	20 e0       	ldi	r18, 0x00	; 0
    2f0a:	30 e0       	ldi	r19, 0x00	; 0
    2f0c:	06 c0       	rjmp	.+12     	; 0x2f1a <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    2f0e:	fc 01       	movw	r30, r24
    2f10:	e2 0f       	add	r30, r18
    2f12:	f3 1f       	adc	r31, r19
    2f14:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    2f16:	2f 5f       	subi	r18, 0xFF	; 255
    2f18:	3f 4f       	sbci	r19, 0xFF	; 255
    2f1a:	26 17       	cp	r18, r22
    2f1c:	37 07       	cpc	r19, r23
    2f1e:	b8 f3       	brcs	.-18     	; 0x2f0e <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    2f20:	08 95       	ret

00002f22 <ProcMessage91>:

void ProcMessage91(){
    2f22:	20 e0       	ldi	r18, 0x00	; 0
    2f24:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f26:	f9 01       	movw	r30, r18
    2f28:	e9 57       	subi	r30, 0x79	; 121
    2f2a:	f3 4f       	sbci	r31, 0xF3	; 243
    2f2c:	d9 01       	movw	r26, r18
    2f2e:	a3 5e       	subi	r26, 0xE3	; 227
    2f30:	b6 4f       	sbci	r27, 0xF6	; 246
    2f32:	95 96       	adiw	r26, 0x25	; 37
    2f34:	8c 91       	ld	r24, X
    2f36:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f38:	2f 5f       	subi	r18, 0xFF	; 255
    2f3a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f3c:	26 30       	cpi	r18, 0x06	; 6
    2f3e:	31 05       	cpc	r19, r1
    2f40:	91 f7       	brne	.-28     	; 0x2f26 <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f42:	10 92 8d 0c 	sts	0x0C8D, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f46:	80 91 48 09 	lds	r24, 0x0948
    2f4a:	80 93 b9 07 	sts	0x07B9, r24
    2f4e:	80 91 49 09 	lds	r24, 0x0949
    2f52:	80 93 ba 07 	sts	0x07BA, r24
	 }Dest[Length]=0;
    2f56:	10 92 bb 07 	sts	0x07BB, r1
    2f5a:	20 e0       	ldi	r18, 0x00	; 0
    2f5c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f5e:	f9 01       	movw	r30, r18
    2f60:	e4 5f       	subi	r30, 0xF4	; 244
    2f62:	f7 4f       	sbci	r31, 0xF7	; 247
    2f64:	d9 01       	movw	r26, r18
    2f66:	a3 5e       	subi	r26, 0xE3	; 227
    2f68:	b6 4f       	sbci	r27, 0xF6	; 246
    2f6a:	9d 96       	adiw	r26, 0x2d	; 45
    2f6c:	8c 91       	ld	r24, X
    2f6e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f70:	2f 5f       	subi	r18, 0xFF	; 255
    2f72:	3f 4f       	sbci	r19, 0xFF	; 255
    2f74:	2f 30       	cpi	r18, 0x0F	; 15
    2f76:	31 05       	cpc	r19, r1
    2f78:	91 f7       	brne	.-28     	; 0x2f5e <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f7a:	10 92 1b 08 	sts	0x081B, r1
    2f7e:	20 e0       	ldi	r18, 0x00	; 0
    2f80:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f82:	f9 01       	movw	r30, r18
    2f84:	e2 56       	subi	r30, 0x62	; 98
    2f86:	fa 4f       	sbci	r31, 0xFA	; 250
    2f88:	d9 01       	movw	r26, r18
    2f8a:	a3 5e       	subi	r26, 0xE3	; 227
    2f8c:	b6 4f       	sbci	r27, 0xF6	; 246
    2f8e:	dc 96       	adiw	r26, 0x3c	; 60
    2f90:	8c 91       	ld	r24, X
    2f92:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f94:	2f 5f       	subi	r18, 0xFF	; 255
    2f96:	3f 4f       	sbci	r19, 0xFF	; 255
    2f98:	26 30       	cpi	r18, 0x06	; 6
    2f9a:	31 05       	cpc	r19, r1
    2f9c:	91 f7       	brne	.-28     	; 0x2f82 <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f9e:	10 92 a4 05 	sts	0x05A4, r1
    2fa2:	20 e0       	ldi	r18, 0x00	; 0
    2fa4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fa6:	f9 01       	movw	r30, r18
    2fa8:	eb 58       	subi	r30, 0x8B	; 139
    2faa:	fc 4f       	sbci	r31, 0xFC	; 252
    2fac:	d9 01       	movw	r26, r18
    2fae:	a1 5a       	subi	r26, 0xA1	; 161
    2fb0:	b6 4f       	sbci	r27, 0xF6	; 246
    2fb2:	8c 91       	ld	r24, X
    2fb4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fb6:	2f 5f       	subi	r18, 0xFF	; 255
    2fb8:	3f 4f       	sbci	r19, 0xFF	; 255
    2fba:	28 30       	cpi	r18, 0x08	; 8
    2fbc:	31 05       	cpc	r19, r1
    2fbe:	99 f7       	brne	.-26     	; 0x2fa6 <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fc0:	10 92 7d 03 	sts	0x037D, r1
    2fc4:	20 e0       	ldi	r18, 0x00	; 0
    2fc6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fc8:	f9 01       	movw	r30, r18
    2fca:	ed 54       	subi	r30, 0x4D	; 77
    2fcc:	f4 4f       	sbci	r31, 0xF4	; 244
    2fce:	d9 01       	movw	r26, r18
    2fd0:	a9 59       	subi	r26, 0x99	; 153
    2fd2:	b6 4f       	sbci	r27, 0xF6	; 246
    2fd4:	8c 91       	ld	r24, X
    2fd6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fd8:	2f 5f       	subi	r18, 0xFF	; 255
    2fda:	3f 4f       	sbci	r19, 0xFF	; 255
    2fdc:	28 30       	cpi	r18, 0x08	; 8
    2fde:	31 05       	cpc	r19, r1
    2fe0:	99 f7       	brne	.-26     	; 0x2fc8 <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fe2:	10 92 bb 0b 	sts	0x0BBB, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fe6:	80 91 6f 09 	lds	r24, 0x096F
    2fea:	80 93 8a 03 	sts	0x038A, r24
	 }Dest[Length]=0;
    2fee:	10 92 8b 03 	sts	0x038B, r1
    2ff2:	20 e0       	ldi	r18, 0x00	; 0
    2ff4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ff6:	f9 01       	movw	r30, r18
    2ff8:	e4 50       	subi	r30, 0x04	; 4
    2ffa:	fd 4f       	sbci	r31, 0xFD	; 253
    2ffc:	d9 01       	movw	r26, r18
    2ffe:	a0 59       	subi	r26, 0x90	; 144
    3000:	b6 4f       	sbci	r27, 0xF6	; 246
    3002:	8c 91       	ld	r24, X
    3004:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3006:	2f 5f       	subi	r18, 0xFF	; 255
    3008:	3f 4f       	sbci	r19, 0xFF	; 255
    300a:	29 30       	cpi	r18, 0x09	; 9
    300c:	31 05       	cpc	r19, r1
    300e:	99 f7       	brne	.-26     	; 0x2ff6 <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3010:	10 92 05 03 	sts	0x0305, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    3014:	08 95       	ret

00003016 <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    3016:	1f 93       	push	r17
   if (STX==0x01){
    3018:	81 30       	cpi	r24, 0x01	; 1
    301a:	09 f0       	breq	.+2      	; 0x301e <IdentifyMessage+0x8>
    301c:	5f c0       	rjmp	.+190    	; 0x30dc <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    301e:	6f 32       	cpi	r22, 0x2F	; 47
    3020:	71 05       	cpc	r23, r1
    3022:	21 f0       	breq	.+8      	; 0x302c <IdentifyMessage+0x16>
    3024:	80 91 24 01 	lds	r24, 0x0124
    3028:	88 23       	and	r24, r24
    302a:	21 f4       	brne	.+8      	; 0x3034 <IdentifyMessage+0x1e>
    302c:	81 e0       	ldi	r24, 0x01	; 1
    302e:	80 93 9e 01 	sts	0x019E, r24
    3032:	4a c0       	rjmp	.+148    	; 0x30c8 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    3034:	6c 36       	cpi	r22, 0x6C	; 108
    3036:	71 05       	cpc	r23, r1
    3038:	11 f0       	breq	.+4      	; 0x303e <IdentifyMessage+0x28>
    303a:	89 30       	cpi	r24, 0x09	; 9
    303c:	21 f4       	brne	.+8      	; 0x3046 <IdentifyMessage+0x30>
    303e:	81 e0       	ldi	r24, 0x01	; 1
    3040:	80 93 a3 01 	sts	0x01A3, r24
    3044:	41 c0       	rjmp	.+130    	; 0x30c8 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    3046:	92 e0       	ldi	r25, 0x02	; 2
    3048:	67 36       	cpi	r22, 0x67	; 103
    304a:	79 07       	cpc	r23, r25
    304c:	11 f0       	breq	.+4      	; 0x3052 <IdentifyMessage+0x3c>
    304e:	8b 30       	cpi	r24, 0x0B	; 11
    3050:	21 f4       	brne	.+8      	; 0x305a <IdentifyMessage+0x44>
    3052:	81 e0       	ldi	r24, 0x01	; 1
    3054:	80 93 a0 01 	sts	0x01A0, r24
    3058:	37 c0       	rjmp	.+110    	; 0x30c8 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    305a:	61 39       	cpi	r22, 0x91	; 145
    305c:	71 05       	cpc	r23, r1
    305e:	11 f0       	breq	.+4      	; 0x3064 <IdentifyMessage+0x4e>
    3060:	87 31       	cpi	r24, 0x17	; 23
    3062:	21 f4       	brne	.+8      	; 0x306c <IdentifyMessage+0x56>
    3064:	81 e0       	ldi	r24, 0x01	; 1
    3066:	80 93 a2 01 	sts	0x01A2, r24
    306a:	2e c0       	rjmp	.+92     	; 0x30c8 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    306c:	66 3e       	cpi	r22, 0xE6	; 230
    306e:	71 05       	cpc	r23, r1
    3070:	11 f0       	breq	.+4      	; 0x3076 <IdentifyMessage+0x60>
    3072:	89 33       	cpi	r24, 0x39	; 57
    3074:	21 f4       	brne	.+8      	; 0x307e <IdentifyMessage+0x68>
    3076:	81 e0       	ldi	r24, 0x01	; 1
    3078:	80 93 a5 01 	sts	0x01A5, r24
    307c:	25 c0       	rjmp	.+74     	; 0x30c8 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    307e:	91 e0       	ldi	r25, 0x01	; 1
    3080:	68 39       	cpi	r22, 0x98	; 152
    3082:	79 07       	cpc	r23, r25
    3084:	11 f0       	breq	.+4      	; 0x308a <IdentifyMessage+0x74>
    3086:	83 36       	cpi	r24, 0x63	; 99
    3088:	21 f4       	brne	.+8      	; 0x3092 <IdentifyMessage+0x7c>
    308a:	81 e0       	ldi	r24, 0x01	; 1
    308c:	80 93 9f 01 	sts	0x019F, r24
    3090:	1b c0       	rjmp	.+54     	; 0x30c8 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    3092:	91 e0       	ldi	r25, 0x01	; 1
    3094:	66 3b       	cpi	r22, 0xB6	; 182
    3096:	79 07       	cpc	r23, r25
    3098:	11 f0       	breq	.+4      	; 0x309e <IdentifyMessage+0x88>
    309a:	81 35       	cpi	r24, 0x51	; 81
    309c:	21 f4       	brne	.+8      	; 0x30a6 <IdentifyMessage+0x90>
    309e:	81 e0       	ldi	r24, 0x01	; 1
    30a0:	80 93 a6 01 	sts	0x01A6, r24
    30a4:	11 c0       	rjmp	.+34     	; 0x30c8 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    30a6:	6c 35       	cpi	r22, 0x5C	; 92
    30a8:	71 05       	cpc	r23, r1
    30aa:	11 f0       	breq	.+4      	; 0x30b0 <IdentifyMessage+0x9a>
    30ac:	8b 35       	cpi	r24, 0x5B	; 91
    30ae:	21 f4       	brne	.+8      	; 0x30b8 <IdentifyMessage+0xa2>
    30b0:	81 e0       	ldi	r24, 0x01	; 1
    30b2:	80 93 a7 01 	sts	0x01A7, r24
    30b6:	08 c0       	rjmp	.+16     	; 0x30c8 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    30b8:	66 35       	cpi	r22, 0x56	; 86
    30ba:	71 05       	cpc	r23, r1
    30bc:	11 f0       	breq	.+4      	; 0x30c2 <IdentifyMessage+0xac>
    30be:	85 31       	cpi	r24, 0x15	; 21
    30c0:	19 f4       	brne	.+6      	; 0x30c8 <IdentifyMessage+0xb2>
    30c2:	81 e0       	ldi	r24, 0x01	; 1
    30c4:	80 93 a1 01 	sts	0x01A1, r24
        //EDC AdvanZ Respond
		if (IsMessage91==True){
    30c8:	10 91 a7 01 	lds	r17, 0x01A7
    30cc:	11 30       	cpi	r17, 0x01	; 1
    30ce:	31 f4       	brne	.+12     	; 0x30dc <IdentifyMessage+0xc6>
		    IsMessage91=False;
    30d0:	10 92 a7 01 	sts	0x01A7, r1
		    ProcMessage91();
    30d4:	0e 94 91 17 	call	0x2f22	; 0x2f22 <ProcMessage91>
			IsSendMessageEDC=True;
    30d8:	10 93 97 01 	sts	0x0197, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  uart_print(1,0,SerialSend);
	 }
}
    30dc:	1f 91       	pop	r17
    30de:	08 95       	ret

000030e0 <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    30e0:	fc 01       	movw	r30, r24
    30e2:	dc 01       	movw	r26, r24
    30e4:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    30e6:	90 e2       	ldi	r25, 0x20	; 32
    30e8:	02 c0       	rjmp	.+4      	; 0x30ee <Tab+0xe>
    30ea:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    30ec:	8f 5f       	subi	r24, 0xFF	; 255
    30ee:	86 17       	cp	r24, r22
    30f0:	e0 f3       	brcs	.-8      	; 0x30ea <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    30f2:	e6 0f       	add	r30, r22
    30f4:	f1 1d       	adc	r31, r1
    30f6:	10 82       	st	Z, r1
}
    30f8:	08 95       	ret

000030fa <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    30fa:	dc 01       	movw	r26, r24
    30fc:	20 e0       	ldi	r18, 0x00	; 0
    30fe:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    3100:	9c 91       	ld	r25, X
    3102:	90 53       	subi	r25, 0x30	; 48
    3104:	9a 30       	cpi	r25, 0x0A	; 10
    3106:	08 f0       	brcs	.+2      	; 0x310a <StrToRaw+0x10>
    3108:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    310a:	11 96       	adiw	r26, 0x01	; 1
    310c:	8c 91       	ld	r24, X
    310e:	11 97       	sbiw	r26, 0x01	; 1
    3110:	80 53       	subi	r24, 0x30	; 48
    3112:	8a 30       	cpi	r24, 0x0A	; 10
    3114:	08 f0       	brcs	.+2      	; 0x3118 <StrToRaw+0x1e>
    3116:	80 e0       	ldi	r24, 0x00	; 0
    3118:	fb 01       	movw	r30, r22
    311a:	e2 0f       	add	r30, r18
    311c:	f3 1f       	adc	r31, r19
    311e:	8f 70       	andi	r24, 0x0F	; 15
    3120:	92 95       	swap	r25
    3122:	90 7f       	andi	r25, 0xF0	; 240
    3124:	98 2b       	or	r25, r24
    3126:	90 83       	st	Z, r25
    3128:	2f 5f       	subi	r18, 0xFF	; 255
    312a:	3f 4f       	sbci	r19, 0xFF	; 255
    312c:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    312e:	26 30       	cpi	r18, 0x06	; 6
    3130:	31 05       	cpc	r19, r1
    3132:	31 f7       	brne	.-52     	; 0x3100 <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    3134:	08 95       	ret

00003136 <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    3136:	cf 93       	push	r28
    3138:	df 93       	push	r29
    313a:	eb 01       	movw	r28, r22
    313c:	db 01       	movw	r26, r22
    313e:	20 e0       	ldi	r18, 0x00	; 0
    3140:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    3142:	fc 01       	movw	r30, r24
    3144:	e2 0f       	add	r30, r18
    3146:	f3 1f       	adc	r31, r19
    3148:	e0 81       	ld	r30, Z
    314a:	4e 2f       	mov	r20, r30
    314c:	42 95       	swap	r20
    314e:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3150:	4a 30       	cpi	r20, 0x0A	; 10
    3152:	10 f0       	brcs	.+4      	; 0x3158 <RawToStr+0x22>
    3154:	40 e3       	ldi	r20, 0x30	; 48
    3156:	01 c0       	rjmp	.+2      	; 0x315a <RawToStr+0x24>
	    Result='0'+X;
    3158:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    315a:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    315c:	ea 30       	cpi	r30, 0x0A	; 10
    315e:	10 f0       	brcs	.+4      	; 0x3164 <RawToStr+0x2e>
    3160:	e0 e3       	ldi	r30, 0x30	; 48
    3162:	01 c0       	rjmp	.+2      	; 0x3166 <RawToStr+0x30>
	    Result='0'+X;
    3164:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    3166:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    3168:	11 96       	adiw	r26, 0x01	; 1
    316a:	ec 93       	st	X, r30
    316c:	11 97       	sbiw	r26, 0x01	; 1
    316e:	2f 5f       	subi	r18, 0xFF	; 255
    3170:	3f 4f       	sbci	r19, 0xFF	; 255
    3172:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    3174:	26 30       	cpi	r18, 0x06	; 6
    3176:	31 05       	cpc	r19, r1
    3178:	21 f7       	brne	.-56     	; 0x3142 <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    317a:	1c 86       	std	Y+12, r1	; 0x0c
}
    317c:	df 91       	pop	r29
    317e:	cf 91       	pop	r28
    3180:	08 95       	ret

00003182 <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xC;//,xA,xB;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    3182:	86 17       	cp	r24, r22
    3184:	08 f4       	brcc	.+2      	; 0x3188 <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    3186:	86 5f       	subi	r24, 0xF6	; 246
    3188:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    318a:	80 5d       	subi	r24, 0xD0	; 208
    318c:	08 95       	ret

0000318e <CalcPlus>:

char CalcPlus(char A, char B){
    318e:	80 56       	subi	r24, 0x60	; 96
    3190:	86 0f       	add	r24, r22
    3192:	6a e0       	ldi	r22, 0x0A	; 10
    3194:	0e 94 f8 ac 	call	0x159f0	; 0x159f0 <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    3198:	89 2f       	mov	r24, r25
    319a:	80 5d       	subi	r24, 0xD0	; 208
    319c:	08 95       	ret

0000319e <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    319e:	8a 30       	cpi	r24, 0x0A	; 10
    31a0:	10 f0       	brcs	.+4      	; 0x31a6 <Chr+0x8>
    31a2:	80 e3       	ldi	r24, 0x30	; 48
    31a4:	08 95       	ret
	    Result='0'+X;
    31a6:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    31a8:	08 95       	ret

000031aa <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    31aa:	80 53       	subi	r24, 0x30	; 48
    31ac:	8a 30       	cpi	r24, 0x0A	; 10
    31ae:	08 f0       	brcs	.+2      	; 0x31b2 <Ord+0x8>
    31b0:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    31b2:	08 95       	ret

000031b4 <FTestCalculation>:
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
*/
}
    31b4:	08 95       	ret

000031b6 <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    31b6:	48 2f       	mov	r20, r24
    31b8:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    31ba:	18 16       	cp	r1, r24
    31bc:	64 f4       	brge	.+24     	; 0x31d6 <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    31be:	56 2f       	mov	r21, r22
    31c0:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    31c2:	90 e2       	ldi	r25, 0x20	; 32
    31c4:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    31c6:	8a 2f       	mov	r24, r26
    31c8:	85 1b       	sub	r24, r21
    31ca:	84 17       	cp	r24, r20
    31cc:	d8 f3       	brcs	.-10     	; 0x31c4 <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    31ce:	e4 0f       	add	r30, r20
    31d0:	f1 1d       	adc	r31, r1
    31d2:	10 82       	st	Z, r1
    31d4:	08 95       	ret
     }else{
	 strTab[0]=' ';
    31d6:	80 e2       	ldi	r24, 0x20	; 32
    31d8:	80 83       	st	Z, r24
	 strTab[1]=0;
    31da:	11 82       	std	Z+1, r1	; 0x01
    31dc:	08 95       	ret

000031de <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    31de:	86 30       	cpi	r24, 0x06	; 6
    31e0:	51 f1       	breq	.+84     	; 0x3236 <GetBorderValue+0x58>
    31e2:	87 30       	cpi	r24, 0x07	; 7
    31e4:	70 f4       	brcc	.+28     	; 0x3202 <GetBorderValue+0x24>
    31e6:	83 30       	cpi	r24, 0x03	; 3
    31e8:	11 f1       	breq	.+68     	; 0x322e <GetBorderValue+0x50>
    31ea:	84 30       	cpi	r24, 0x04	; 4
    31ec:	28 f4       	brcc	.+10     	; 0x31f8 <GetBorderValue+0x1a>
    31ee:	81 30       	cpi	r24, 0x01	; 1
    31f0:	c1 f0       	breq	.+48     	; 0x3222 <GetBorderValue+0x44>
    31f2:	82 30       	cpi	r24, 0x02	; 2
    31f4:	c1 f4       	brne	.+48     	; 0x3226 <GetBorderValue+0x48>
    31f6:	19 c0       	rjmp	.+50     	; 0x322a <GetBorderValue+0x4c>
    31f8:	84 30       	cpi	r24, 0x04	; 4
    31fa:	d9 f0       	breq	.+54     	; 0x3232 <GetBorderValue+0x54>
    31fc:	85 30       	cpi	r24, 0x05	; 5
    31fe:	99 f4       	brne	.+38     	; 0x3226 <GetBorderValue+0x48>
    3200:	22 c0       	rjmp	.+68     	; 0x3246 <GetBorderValue+0x68>
    3202:	89 30       	cpi	r24, 0x09	; 9
    3204:	f1 f0       	breq	.+60     	; 0x3242 <GetBorderValue+0x64>
    3206:	8a 30       	cpi	r24, 0x0A	; 10
    3208:	28 f4       	brcc	.+10     	; 0x3214 <GetBorderValue+0x36>
    320a:	87 30       	cpi	r24, 0x07	; 7
    320c:	b1 f0       	breq	.+44     	; 0x323a <GetBorderValue+0x5c>
    320e:	88 30       	cpi	r24, 0x08	; 8
    3210:	51 f4       	brne	.+20     	; 0x3226 <GetBorderValue+0x48>
    3212:	15 c0       	rjmp	.+42     	; 0x323e <GetBorderValue+0x60>
    3214:	8b 30       	cpi	r24, 0x0B	; 11
    3216:	d9 f0       	breq	.+54     	; 0x324e <GetBorderValue+0x70>
    3218:	8b 30       	cpi	r24, 0x0B	; 11
    321a:	b8 f0       	brcs	.+46     	; 0x324a <GetBorderValue+0x6c>
    321c:	8c 30       	cpi	r24, 0x0C	; 12
    321e:	19 f4       	brne	.+6      	; 0x3226 <GetBorderValue+0x48>
    3220:	18 c0       	rjmp	.+48     	; 0x3252 <GetBorderValue+0x74>
    3222:	8a ed       	ldi	r24, 0xDA	; 218
    3224:	08 95       	ret
    3226:	80 e0       	ldi	r24, 0x00	; 0
    3228:	08 95       	ret
    322a:	82 ec       	ldi	r24, 0xC2	; 194
    322c:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    322e:	8f eb       	ldi	r24, 0xBF	; 191
    3230:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    3232:	83 ec       	ldi	r24, 0xC3	; 195
    3234:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    3236:	84 eb       	ldi	r24, 0xB4	; 180
    3238:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    323a:	80 ec       	ldi	r24, 0xC0	; 192
    323c:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    323e:	81 ec       	ldi	r24, 0xC1	; 193
    3240:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    3242:	89 ed       	ldi	r24, 0xD9	; 217
    3244:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    3246:	85 ec       	ldi	r24, 0xC5	; 197
    3248:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    324a:	83 eb       	ldi	r24, 0xB3	; 179
    324c:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    324e:	84 ec       	ldi	r24, 0xC4	; 196
    3250:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    3252:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    3254:	08 95       	ret

00003256 <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    3256:	bf 92       	push	r11
    3258:	cf 92       	push	r12
    325a:	df 92       	push	r13
    325c:	ef 92       	push	r14
    325e:	ff 92       	push	r15
    3260:	0f 93       	push	r16
    3262:	1f 93       	push	r17
    3264:	cf 93       	push	r28
    3266:	df 93       	push	r29
    3268:	b8 2e       	mov	r11, r24
    326a:	8b 01       	movw	r16, r22
    326c:	e4 2e       	mov	r14, r20
    326e:	69 01       	movw	r12, r18
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    3270:	f9 01       	movw	r30, r18
    3272:	c0 81       	ld	r28, Z
    3274:	d1 81       	ldd	r29, Z+1	; 0x01
    3276:	0c 0f       	add	r16, r28
    3278:	1d 1f       	adc	r17, r29
    327a:	ff 24       	eor	r15, r15
    327c:	07 c0       	rjmp	.+14     	; 0x328c <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    327e:	8b 2d       	mov	r24, r11
    3280:	0e 94 ef 18 	call	0x31de	; 0x31de <GetBorderValue>
    3284:	f8 01       	movw	r30, r16
    3286:	81 93       	st	Z+, r24
    3288:	8f 01       	movw	r16, r30
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    328a:	f3 94       	inc	r15
    328c:	fe 14       	cp	r15, r14
    328e:	b8 f3       	brcs	.-18     	; 0x327e <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    3290:	ce 0d       	add	r28, r14
    3292:	d1 1d       	adc	r29, r1
    3294:	f6 01       	movw	r30, r12
    3296:	d1 83       	std	Z+1, r29	; 0x01
    3298:	c0 83       	st	Z, r28
}
    329a:	df 91       	pop	r29
    329c:	cf 91       	pop	r28
    329e:	1f 91       	pop	r17
    32a0:	0f 91       	pop	r16
    32a2:	ff 90       	pop	r15
    32a4:	ef 90       	pop	r14
    32a6:	df 90       	pop	r13
    32a8:	cf 90       	pop	r12
    32aa:	bf 90       	pop	r11
    32ac:	08 95       	ret

000032ae <TestUserInput>:
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
  */
}
    32ae:	08 95       	ret

000032b0 <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    32b0:	08 95       	ret

000032b2 <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    32b2:	08 95       	ret

000032b4 <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    32b4:	08 95       	ret

000032b6 <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    32b6:	08 95       	ret

000032b8 <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    32b8:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    32ba:	28 2f       	mov	r18, r24
    32bc:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    32be:	82 2f       	mov	r24, r18
    32c0:	86 95       	lsr	r24
    32c2:	86 95       	lsr	r24
    32c4:	86 95       	lsr	r24
    32c6:	a8 2f       	mov	r26, r24
    32c8:	b0 e0       	ldi	r27, 0x00	; 0
    32ca:	ac 52       	subi	r26, 0x2C	; 44
    32cc:	b4 4f       	sbci	r27, 0xF4	; 244
    32ce:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    32d0:	62 30       	cpi	r22, 0x02	; 2
    32d2:	59 f4       	brne	.+22     	; 0x32ea <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    32d4:	27 70       	andi	r18, 0x07	; 7
    32d6:	81 e0       	ldi	r24, 0x01	; 1
    32d8:	90 e0       	ldi	r25, 0x00	; 0
    32da:	02 c0       	rjmp	.+4      	; 0x32e0 <SetIncomingTransStatus+0x28>
    32dc:	88 0f       	add	r24, r24
    32de:	99 1f       	adc	r25, r25
    32e0:	2a 95       	dec	r18
    32e2:	e2 f7       	brpl	.-8      	; 0x32dc <SetIncomingTransStatus+0x24>
    32e4:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    32e6:	4c 93       	st	X, r20
    32e8:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    32ea:	63 30       	cpi	r22, 0x03	; 3
    32ec:	b1 f4       	brne	.+44     	; 0x331a <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    32ee:	27 70       	andi	r18, 0x07	; 7
    32f0:	8e ef       	ldi	r24, 0xFE	; 254
    32f2:	90 e0       	ldi	r25, 0x00	; 0
    32f4:	01 c0       	rjmp	.+2      	; 0x32f8 <SetIncomingTransStatus+0x40>
    32f6:	88 0f       	add	r24, r24
    32f8:	2a 95       	dec	r18
    32fa:	ea f7       	brpl	.-6      	; 0x32f6 <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    32fc:	e6 95       	lsr	r30
    32fe:	e6 95       	lsr	r30
    3300:	e6 95       	lsr	r30
    3302:	f0 e0       	ldi	r31, 0x00	; 0
    3304:	ec 52       	subi	r30, 0x2C	; 44
    3306:	f4 4f       	sbci	r31, 0xF4	; 244
    3308:	28 2f       	mov	r18, r24
    330a:	30 e0       	ldi	r19, 0x00	; 0
    330c:	20 95       	com	r18
    330e:	30 95       	com	r19
    3310:	35 95       	asr	r19
    3312:	27 95       	ror	r18
    3314:	82 2b       	or	r24, r18
    3316:	84 23       	and	r24, r20
    3318:	80 83       	st	Z, r24
    331a:	08 95       	ret

0000331c <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    331c:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    331e:	e8 2f       	mov	r30, r24
    3320:	e6 95       	lsr	r30
    3322:	e6 95       	lsr	r30
    3324:	e6 95       	lsr	r30
    3326:	f0 e0       	ldi	r31, 0x00	; 0
    3328:	ec 52       	subi	r30, 0x2C	; 44
    332a:	f4 4f       	sbci	r31, 0xF4	; 244
    332c:	90 81       	ld	r25, Z
    332e:	29 2f       	mov	r18, r25
    3330:	30 e0       	ldi	r19, 0x00	; 0
    3332:	87 70       	andi	r24, 0x07	; 7
    3334:	02 c0       	rjmp	.+4      	; 0x333a <GetIncomingTransStatus+0x1e>
    3336:	35 95       	asr	r19
    3338:	27 95       	ror	r18
    333a:	8a 95       	dec	r24
    333c:	e2 f7       	brpl	.-8      	; 0x3336 <GetIncomingTransStatus+0x1a>
    333e:	21 30       	cpi	r18, 0x01	; 1
    3340:	31 05       	cpc	r19, r1
    3342:	11 f4       	brne	.+4      	; 0x3348 <GetIncomingTransStatus+0x2c>
    3344:	82 e0       	ldi	r24, 0x02	; 2
    3346:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    3348:	23 2b       	or	r18, r19
    334a:	11 f4       	brne	.+4      	; 0x3350 <GetIncomingTransStatus+0x34>
    334c:	83 e0       	ldi	r24, 0x03	; 3
    334e:	08 95       	ret
    3350:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    3352:	08 95       	ret

00003354 <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    3354:	df 93       	push	r29
    3356:	cf 93       	push	r28
    3358:	00 d0       	rcall	.+0      	; 0x335a <SetDispenser+0x6>
    335a:	00 d0       	rcall	.+0      	; 0x335c <SetDispenser+0x8>
    335c:	0f 92       	push	r0
    335e:	cd b7       	in	r28, 0x3d	; 61
    3360:	de b7       	in	r29, 0x3e	; 62
    3362:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3364:	e1 99       	sbic	0x1c, 1	; 28
    3366:	fe cf       	rjmp	.-4      	; 0x3364 <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3368:	27 e3       	ldi	r18, 0x37	; 55
    336a:	31 e0       	ldi	r19, 0x01	; 1
    336c:	3f bb       	out	0x1f, r19	; 31
    336e:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3370:	e0 9a       	sbi	0x1c, 0	; 28
    3372:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    3374:	89 17       	cp	r24, r25
    3376:	51 f0       	breq	.+20     	; 0x338c <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3378:	e1 99       	sbic	0x1c, 1	; 28
    337a:	fe cf       	rjmp	.-4      	; 0x3378 <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    337c:	3f bb       	out	0x1f, r19	; 31
    337e:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    3380:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3382:	0f b6       	in	r0, 0x3f	; 63
    3384:	f8 94       	cli
    3386:	e2 9a       	sbi	0x1c, 2	; 28
    3388:	e1 9a       	sbi	0x1c, 1	; 28
    338a:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    338c:	91 30       	cpi	r25, 0x01	; 1
    338e:	19 f0       	breq	.+6      	; 0x3396 <SetDispenser+0x42>
    3390:	92 30       	cpi	r25, 0x02	; 2
    3392:	71 f4       	brne	.+28     	; 0x33b0 <SetDispenser+0x5c>
    3394:	08 c0       	rjmp	.+16     	; 0x33a6 <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    3396:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    3398:	83 e0       	ldi	r24, 0x03	; 3
    339a:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    339c:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    339e:	82 e0       	ldi	r24, 0x02	; 2
    33a0:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    33a2:	1d 82       	std	Y+5, r1	; 0x05
    33a4:	05 c0       	rjmp	.+10     	; 0x33b0 <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    33a6:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    33a8:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    33aa:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    33ac:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    33ae:	9d 83       	std	Y+5, r25	; 0x05
    33b0:	29 e3       	ldi	r18, 0x39	; 57
    33b2:	30 e0       	ldi	r19, 0x00	; 0
    33b4:	fe 01       	movw	r30, r28
    33b6:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    33b8:	e1 99       	sbic	0x1c, 1	; 28
    33ba:	fe cf       	rjmp	.-4      	; 0x33b8 <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    33bc:	3f bb       	out	0x1f, r19	; 31
    33be:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    33c0:	e0 9a       	sbi	0x1c, 0	; 28
    33c2:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    33c4:	90 81       	ld	r25, Z
    33c6:	89 17       	cp	r24, r25
    33c8:	51 f0       	breq	.+20     	; 0x33de <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    33ca:	e1 99       	sbic	0x1c, 1	; 28
    33cc:	fe cf       	rjmp	.-4      	; 0x33ca <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    33ce:	3f bb       	out	0x1f, r19	; 31
    33d0:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    33d2:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    33d4:	0f b6       	in	r0, 0x3f	; 63
    33d6:	f8 94       	cli
    33d8:	e2 9a       	sbi	0x1c, 2	; 28
    33da:	e1 9a       	sbi	0x1c, 1	; 28
    33dc:	0f be       	out	0x3f, r0	; 63
    33de:	2f 5f       	subi	r18, 0xFF	; 255
    33e0:	3f 4f       	sbci	r19, 0xFF	; 255
    33e2:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    33e4:	80 e0       	ldi	r24, 0x00	; 0
    33e6:	2e 33       	cpi	r18, 0x3E	; 62
    33e8:	38 07       	cpc	r19, r24
    33ea:	31 f7       	brne	.-52     	; 0x33b8 <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    33ec:	0f 90       	pop	r0
    33ee:	0f 90       	pop	r0
    33f0:	0f 90       	pop	r0
    33f2:	0f 90       	pop	r0
    33f4:	0f 90       	pop	r0
    33f6:	cf 91       	pop	r28
    33f8:	df 91       	pop	r29
    33fa:	08 95       	ret

000033fc <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    33fc:	df 93       	push	r29
    33fe:	cf 93       	push	r28
    3400:	cd b7       	in	r28, 0x3d	; 61
    3402:	de b7       	in	r29, 0x3e	; 62
    3404:	62 97       	sbiw	r28, 0x12	; 18
    3406:	0f b6       	in	r0, 0x3f	; 63
    3408:	f8 94       	cli
    340a:	de bf       	out	0x3e, r29	; 62
    340c:	0f be       	out	0x3f, r0	; 63
    340e:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3410:	20 91 ba 03 	lds	r18, 0x03BA
    3414:	2f 83       	std	Y+7, r18	; 0x07
    3416:	20 91 bb 03 	lds	r18, 0x03BB
    341a:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    341c:	20 91 bd 03 	lds	r18, 0x03BD
    3420:	2c 83       	std	Y+4, r18	; 0x04
    3422:	20 91 be 03 	lds	r18, 0x03BE
    3426:	2d 83       	std	Y+5, r18	; 0x05
    3428:	20 91 c0 03 	lds	r18, 0x03C0
    342c:	29 83       	std	Y+1, r18	; 0x01
    342e:	20 91 c1 03 	lds	r18, 0x03C1
    3432:	2a 83       	std	Y+2, r18	; 0x02
    3434:	20 91 74 08 	lds	r18, 0x0874
    3438:	2a 87       	std	Y+10, r18	; 0x0a
    343a:	20 91 75 08 	lds	r18, 0x0875
    343e:	2b 87       	std	Y+11, r18	; 0x0b
    3440:	20 91 77 08 	lds	r18, 0x0877
    3444:	2d 87       	std	Y+13, r18	; 0x0d
    3446:	20 91 78 08 	lds	r18, 0x0878
    344a:	2e 87       	std	Y+14, r18	; 0x0e
    344c:	20 91 7a 08 	lds	r18, 0x087A
    3450:	28 8b       	std	Y+16, r18	; 0x10
    3452:	20 91 7b 08 	lds	r18, 0x087B
    3456:	29 8b       	std	Y+17, r18	; 0x11
    3458:	1a 8a       	std	Y+18, r1	; 0x12
    345a:	1f 86       	std	Y+15, r1	; 0x0f
    345c:	1c 86       	std	Y+12, r1	; 0x0c
    345e:	1b 82       	std	Y+3, r1	; 0x03
    3460:	1e 82       	std	Y+6, r1	; 0x06
    3462:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    3464:	2d b7       	in	r18, 0x3d	; 61
    3466:	3e b7       	in	r19, 0x3e	; 62
    3468:	20 51       	subi	r18, 0x10	; 16
    346a:	30 40       	sbci	r19, 0x00	; 0
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	f8 94       	cli
    3470:	3e bf       	out	0x3e, r19	; 62
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	2d bf       	out	0x3d, r18	; 61
    3476:	ed b7       	in	r30, 0x3d	; 61
    3478:	fe b7       	in	r31, 0x3e	; 62
    347a:	31 96       	adiw	r30, 0x01	; 1
    347c:	ad b7       	in	r26, 0x3d	; 61
    347e:	be b7       	in	r27, 0x3e	; 62
    3480:	12 96       	adiw	r26, 0x02	; 2
    3482:	9c 93       	st	X, r25
    3484:	8e 93       	st	-X, r24
    3486:	11 97       	sbiw	r26, 0x01	; 1
    3488:	80 e2       	ldi	r24, 0x20	; 32
    348a:	93 e0       	ldi	r25, 0x03	; 3
    348c:	93 83       	std	Z+3, r25	; 0x03
    348e:	82 83       	std	Z+2, r24	; 0x02
    3490:	ce 01       	movw	r24, r28
    3492:	01 96       	adiw	r24, 0x01	; 1
    3494:	95 83       	std	Z+5, r25	; 0x05
    3496:	84 83       	std	Z+4, r24	; 0x04
    3498:	ce 01       	movw	r24, r28
    349a:	04 96       	adiw	r24, 0x04	; 4
    349c:	97 83       	std	Z+7, r25	; 0x07
    349e:	86 83       	std	Z+6, r24	; 0x06
    34a0:	ce 01       	movw	r24, r28
    34a2:	07 96       	adiw	r24, 0x07	; 7
    34a4:	91 87       	std	Z+9, r25	; 0x09
    34a6:	80 87       	std	Z+8, r24	; 0x08
    34a8:	ce 01       	movw	r24, r28
    34aa:	0a 96       	adiw	r24, 0x0a	; 10
    34ac:	93 87       	std	Z+11, r25	; 0x0b
    34ae:	82 87       	std	Z+10, r24	; 0x0a
    34b0:	ce 01       	movw	r24, r28
    34b2:	0d 96       	adiw	r24, 0x0d	; 13
    34b4:	95 87       	std	Z+13, r25	; 0x0d
    34b6:	84 87       	std	Z+12, r24	; 0x0c
    34b8:	ce 01       	movw	r24, r28
    34ba:	40 96       	adiw	r24, 0x10	; 16
    34bc:	97 87       	std	Z+15, r25	; 0x0f
    34be:	86 87       	std	Z+14, r24	; 0x0e
    34c0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    34c4:	2d b7       	in	r18, 0x3d	; 61
    34c6:	3e b7       	in	r19, 0x3e	; 62
    34c8:	20 5f       	subi	r18, 0xF0	; 240
    34ca:	3f 4f       	sbci	r19, 0xFF	; 255
    34cc:	0f b6       	in	r0, 0x3f	; 63
    34ce:	f8 94       	cli
    34d0:	3e bf       	out	0x3e, r19	; 62
    34d2:	0f be       	out	0x3f, r0	; 63
    34d4:	2d bf       	out	0x3d, r18	; 61
}
    34d6:	62 96       	adiw	r28, 0x12	; 18
    34d8:	0f b6       	in	r0, 0x3f	; 63
    34da:	f8 94       	cli
    34dc:	de bf       	out	0x3e, r29	; 62
    34de:	0f be       	out	0x3f, r0	; 63
    34e0:	cd bf       	out	0x3d, r28	; 61
    34e2:	cf 91       	pop	r28
    34e4:	df 91       	pop	r29
    34e6:	08 95       	ret

000034e8 <leadingZero>:
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    34e8:	00 d0       	rcall	.+0      	; 0x34ea <leadingZero+0x2>
    34ea:	00 d0       	rcall	.+0      	; 0x34ec <leadingZero+0x4>
    34ec:	00 d0       	rcall	.+0      	; 0x34ee <leadingZero+0x6>
    34ee:	ed b7       	in	r30, 0x3d	; 61
    34f0:	fe b7       	in	r31, 0x3e	; 62
    34f2:	31 96       	adiw	r30, 0x01	; 1
    34f4:	ad b7       	in	r26, 0x3d	; 61
    34f6:	be b7       	in	r27, 0x3e	; 62
    34f8:	12 96       	adiw	r26, 0x02	; 2
    34fa:	7c 93       	st	X, r23
    34fc:	6e 93       	st	-X, r22
    34fe:	11 97       	sbiw	r26, 0x01	; 1
    3500:	24 ed       	ldi	r18, 0xD4	; 212
    3502:	3c e0       	ldi	r19, 0x0C	; 12
    3504:	33 83       	std	Z+3, r19	; 0x03
    3506:	22 83       	std	Z+2, r18	; 0x02
    3508:	84 83       	std	Z+4, r24	; 0x04
    350a:	15 82       	std	Z+5, r1	; 0x05
    350c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    3510:	8d b7       	in	r24, 0x3d	; 61
    3512:	9e b7       	in	r25, 0x3e	; 62
    3514:	06 96       	adiw	r24, 0x06	; 6
    3516:	0f b6       	in	r0, 0x3f	; 63
    3518:	f8 94       	cli
    351a:	9e bf       	out	0x3e, r25	; 62
    351c:	0f be       	out	0x3f, r0	; 63
    351e:	8d bf       	out	0x3d, r24	; 61

}
    3520:	08 95       	ret

00003522 <MasterReset>:
	 }
}

#define DEF_OPERATOR_NAME "Mr.Big"

void MasterReset(){
    3522:	df 92       	push	r13
    3524:	ef 92       	push	r14
    3526:	ff 92       	push	r15
    3528:	0f 93       	push	r16
    352a:	1f 93       	push	r17
    352c:	df 93       	push	r29
    352e:	cf 93       	push	r28
    3530:	cd b7       	in	r28, 0x3d	; 61
    3532:	de b7       	in	r29, 0x3e	; 62
    3534:	ec 97       	sbiw	r28, 0x3c	; 60
    3536:	0f b6       	in	r0, 0x3f	; 63
    3538:	f8 94       	cli
    353a:	de bf       	out	0x3e, r29	; 62
    353c:	0f be       	out	0x3f, r0	; 63
    353e:	cd bf       	out	0x3d, r28	; 61
     char strEEP[50];
	 char xArray[10];
     //Restore All Stored EEPROM data to the Default
     sprintf_P(strEEP,PSTR(DEF_OPERATOR_NAME));
    3540:	00 d0       	rcall	.+0      	; 0x3542 <MasterReset+0x20>
    3542:	00 d0       	rcall	.+0      	; 0x3544 <MasterReset+0x22>
    3544:	8e 01       	movw	r16, r28
    3546:	05 5f       	subi	r16, 0xF5	; 245
    3548:	1f 4f       	sbci	r17, 0xFF	; 255
    354a:	ed b7       	in	r30, 0x3d	; 61
    354c:	fe b7       	in	r31, 0x3e	; 62
    354e:	12 83       	std	Z+2, r17	; 0x02
    3550:	01 83       	std	Z+1, r16	; 0x01
    3552:	8f ef       	ldi	r24, 0xFF	; 255
    3554:	92 e0       	ldi	r25, 0x02	; 2
    3556:	94 83       	std	Z+4, r25	; 0x04
    3558:	83 83       	std	Z+3, r24	; 0x03
    355a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    355e:	0f 90       	pop	r0
    3560:	0f 90       	pop	r0
    3562:	0f 90       	pop	r0
    3564:	0f 90       	pop	r0
    3566:	85 e1       	ldi	r24, 0x15	; 21
    3568:	90 e0       	ldi	r25, 0x00	; 0
    356a:	b8 01       	movw	r22, r16
    356c:	43 e1       	ldi	r20, 0x13	; 19
    356e:	50 e0       	ldi	r21, 0x00	; 0
    3570:	2c e4       	ldi	r18, 0x4C	; 76
    3572:	32 e1       	ldi	r19, 0x12	; 18
    3574:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefOperatorName, sizeof(DefOperatorName));

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=70; 
    3578:	40 ec       	ldi	r20, 0xC0	; 192
    357a:	d4 2e       	mov	r13, r20
    357c:	d9 82       	std	Y+1, r13	; 0x01
    357e:	38 ea       	ldi	r19, 0xA8	; 168
    3580:	e3 2e       	mov	r14, r19
    3582:	ea 82       	std	Y+2, r14	; 0x02
    3584:	20 e1       	ldi	r18, 0x10	; 16
    3586:	f2 2e       	mov	r15, r18
    3588:	fb 82       	std	Y+3, r15	; 0x03
    358a:	86 e4       	ldi	r24, 0x46	; 70
    358c:	8c 83       	std	Y+4, r24	; 0x04
    358e:	88 e2       	ldi	r24, 0x28	; 40
    3590:	90 e0       	ldi	r25, 0x00	; 0
    3592:	8e 01       	movw	r16, r28
    3594:	0f 5f       	subi	r16, 0xFF	; 255
    3596:	1f 4f       	sbci	r17, 0xFF	; 255
    3598:	b8 01       	movw	r22, r16
    359a:	44 e0       	ldi	r20, 0x04	; 4
    359c:	50 e0       	ldi	r21, 0x00	; 0
    359e:	2c e4       	ldi	r18, 0x4C	; 76
    35a0:	32 e1       	ldi	r19, 0x12	; 18
    35a2:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefClientIP, 4);

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=180; 
    35a6:	d9 82       	std	Y+1, r13	; 0x01
    35a8:	ea 82       	std	Y+2, r14	; 0x02
    35aa:	fb 82       	std	Y+3, r15	; 0x03
    35ac:	84 eb       	ldi	r24, 0xB4	; 180
    35ae:	8c 83       	std	Y+4, r24	; 0x04
    35b0:	8c e2       	ldi	r24, 0x2C	; 44
    35b2:	90 e0       	ldi	r25, 0x00	; 0
    35b4:	b8 01       	movw	r22, r16
    35b6:	44 e0       	ldi	r20, 0x04	; 4
    35b8:	50 e0       	ldi	r21, 0x00	; 0
    35ba:	2c e4       	ldi	r18, 0x4C	; 76
    35bc:	32 e1       	ldi	r19, 0x12	; 18
    35be:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    35c2:	e1 99       	sbic	0x1c, 1	; 28
    35c4:	fe cf       	rjmp	.-4      	; 0x35c2 <MasterReset+0xa0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    35c6:	80 e3       	ldi	r24, 0x30	; 48
    35c8:	90 e0       	ldi	r25, 0x00	; 0
    35ca:	9f bb       	out	0x1f, r25	; 31
    35cc:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    35ce:	81 e0       	ldi	r24, 0x01	; 1
    35d0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    35d2:	0f b6       	in	r0, 0x3f	; 63
    35d4:	f8 94       	cli
    35d6:	e2 9a       	sbi	0x1c, 2	; 28
    35d8:	e1 9a       	sbi	0x1c, 1	; 28
    35da:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    35dc:	e1 99       	sbic	0x1c, 1	; 28
    35de:	fe cf       	rjmp	.-4      	; 0x35dc <MasterReset+0xba>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    35e0:	81 e3       	ldi	r24, 0x31	; 49
    35e2:	90 e0       	ldi	r25, 0x00	; 0
    35e4:	9f bb       	out	0x1f, r25	; 31
    35e6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    35e8:	87 e0       	ldi	r24, 0x07	; 7
    35ea:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    35ec:	0f b6       	in	r0, 0x3f	; 63
    35ee:	f8 94       	cli
    35f0:	e2 9a       	sbi	0x1c, 2	; 28
    35f2:	e1 9a       	sbi	0x1c, 1	; 28
    35f4:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    35f6:	e1 99       	sbic	0x1c, 1	; 28
    35f8:	fe cf       	rjmp	.-4      	; 0x35f6 <MasterReset+0xd4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    35fa:	82 e3       	ldi	r24, 0x32	; 50
    35fc:	90 e0       	ldi	r25, 0x00	; 0
    35fe:	9f bb       	out	0x1f, r25	; 31
    3600:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3602:	85 e0       	ldi	r24, 0x05	; 5
    3604:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3606:	0f b6       	in	r0, 0x3f	; 63
    3608:	f8 94       	cli
    360a:	e2 9a       	sbi	0x1c, 2	; 28
    360c:	e1 9a       	sbi	0x1c, 1	; 28
    360e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3610:	e1 99       	sbic	0x1c, 1	; 28
    3612:	fe cf       	rjmp	.-4      	; 0x3610 <MasterReset+0xee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3614:	83 e3       	ldi	r24, 0x33	; 51
    3616:	90 e0       	ldi	r25, 0x00	; 0
    3618:	9f bb       	out	0x1f, r25	; 31
    361a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    361c:	82 e0       	ldi	r24, 0x02	; 2
    361e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3620:	0f b6       	in	r0, 0x3f	; 63
    3622:	f8 94       	cli
    3624:	e2 9a       	sbi	0x1c, 2	; 28
    3626:	e1 9a       	sbi	0x1c, 1	; 28
    3628:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    362a:	e1 99       	sbic	0x1c, 1	; 28
    362c:	fe cf       	rjmp	.-4      	; 0x362a <MasterReset+0x108>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    362e:	84 e3       	ldi	r24, 0x34	; 52
    3630:	90 e0       	ldi	r25, 0x00	; 0
    3632:	9f bb       	out	0x1f, r25	; 31
    3634:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3636:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3638:	0f b6       	in	r0, 0x3f	; 63
    363a:	f8 94       	cli
    363c:	e2 9a       	sbi	0x1c, 2	; 28
    363e:	e1 9a       	sbi	0x1c, 1	; 28
    3640:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3642:	e1 99       	sbic	0x1c, 1	; 28
    3644:	fe cf       	rjmp	.-4      	; 0x3642 <MasterReset+0x120>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3646:	85 e3       	ldi	r24, 0x35	; 53
    3648:	90 e0       	ldi	r25, 0x00	; 0
    364a:	9f bb       	out	0x1f, r25	; 31
    364c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    364e:	83 e0       	ldi	r24, 0x03	; 3
    3650:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3652:	0f b6       	in	r0, 0x3f	; 63
    3654:	f8 94       	cli
    3656:	e2 9a       	sbi	0x1c, 2	; 28
    3658:	e1 9a       	sbi	0x1c, 1	; 28
    365a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    365c:	e1 99       	sbic	0x1c, 1	; 28
    365e:	fe cf       	rjmp	.-4      	; 0x365c <MasterReset+0x13a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3660:	86 e3       	ldi	r24, 0x36	; 54
    3662:	90 e0       	ldi	r25, 0x00	; 0
    3664:	9f bb       	out	0x1f, r25	; 31
    3666:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3668:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    366a:	0f b6       	in	r0, 0x3f	; 63
    366c:	f8 94       	cli
    366e:	e2 9a       	sbi	0x1c, 2	; 28
    3670:	e1 9a       	sbi	0x1c, 1	; 28
    3672:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3674:	e1 99       	sbic	0x1c, 1	; 28
    3676:	fe cf       	rjmp	.-4      	; 0x3674 <MasterReset+0x152>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3678:	87 e3       	ldi	r24, 0x37	; 55
    367a:	90 e0       	ldi	r25, 0x00	; 0
    367c:	9f bb       	out	0x1f, r25	; 31
    367e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3680:	81 e0       	ldi	r24, 0x01	; 1
    3682:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3684:	0f b6       	in	r0, 0x3f	; 63
    3686:	f8 94       	cli
    3688:	e2 9a       	sbi	0x1c, 2	; 28
    368a:	e1 9a       	sbi	0x1c, 1	; 28
    368c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    368e:	e1 99       	sbic	0x1c, 1	; 28
    3690:	fe cf       	rjmp	.-4      	; 0x368e <MasterReset+0x16c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3692:	88 e3       	ldi	r24, 0x38	; 56
    3694:	90 e0       	ldi	r25, 0x00	; 0
    3696:	9f bb       	out	0x1f, r25	; 31
    3698:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    369a:	81 e0       	ldi	r24, 0x01	; 1
    369c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    369e:	0f b6       	in	r0, 0x3f	; 63
    36a0:	f8 94       	cli
    36a2:	e2 9a       	sbi	0x1c, 2	; 28
    36a4:	e1 9a       	sbi	0x1c, 1	; 28
    36a6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    36a8:	e1 99       	sbic	0x1c, 1	; 28
    36aa:	fe cf       	rjmp	.-4      	; 0x36a8 <MasterReset+0x186>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    36ac:	89 e3       	ldi	r24, 0x39	; 57
    36ae:	90 e0       	ldi	r25, 0x00	; 0
    36b0:	9f bb       	out	0x1f, r25	; 31
    36b2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    36b4:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    36b6:	0f b6       	in	r0, 0x3f	; 63
    36b8:	f8 94       	cli
    36ba:	e2 9a       	sbi	0x1c, 2	; 28
    36bc:	e1 9a       	sbi	0x1c, 1	; 28
    36be:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    36c0:	e1 99       	sbic	0x1c, 1	; 28
    36c2:	fe cf       	rjmp	.-4      	; 0x36c0 <MasterReset+0x19e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    36c4:	8a e3       	ldi	r24, 0x3A	; 58
    36c6:	90 e0       	ldi	r25, 0x00	; 0
    36c8:	9f bb       	out	0x1f, r25	; 31
    36ca:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    36cc:	83 e0       	ldi	r24, 0x03	; 3
    36ce:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    36d0:	0f b6       	in	r0, 0x3f	; 63
    36d2:	f8 94       	cli
    36d4:	e2 9a       	sbi	0x1c, 2	; 28
    36d6:	e1 9a       	sbi	0x1c, 1	; 28
    36d8:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    36da:	e1 99       	sbic	0x1c, 1	; 28
    36dc:	fe cf       	rjmp	.-4      	; 0x36da <MasterReset+0x1b8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    36de:	8b e3       	ldi	r24, 0x3B	; 59
    36e0:	90 e0       	ldi	r25, 0x00	; 0
    36e2:	9f bb       	out	0x1f, r25	; 31
    36e4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    36e6:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    36e8:	0f b6       	in	r0, 0x3f	; 63
    36ea:	f8 94       	cli
    36ec:	e2 9a       	sbi	0x1c, 2	; 28
    36ee:	e1 9a       	sbi	0x1c, 1	; 28
    36f0:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    36f2:	e1 99       	sbic	0x1c, 1	; 28
    36f4:	fe cf       	rjmp	.-4      	; 0x36f2 <MasterReset+0x1d0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    36f6:	8c e3       	ldi	r24, 0x3C	; 60
    36f8:	90 e0       	ldi	r25, 0x00	; 0
    36fa:	9f bb       	out	0x1f, r25	; 31
    36fc:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    36fe:	82 e0       	ldi	r24, 0x02	; 2
    3700:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3702:	0f b6       	in	r0, 0x3f	; 63
    3704:	f8 94       	cli
    3706:	e2 9a       	sbi	0x1c, 2	; 28
    3708:	e1 9a       	sbi	0x1c, 1	; 28
    370a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    370c:	e1 99       	sbic	0x1c, 1	; 28
    370e:	fe cf       	rjmp	.-4      	; 0x370c <MasterReset+0x1ea>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3710:	8d e3       	ldi	r24, 0x3D	; 61
    3712:	90 e0       	ldi	r25, 0x00	; 0
    3714:	9f bb       	out	0x1f, r25	; 31
    3716:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3718:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    371a:	0f b6       	in	r0, 0x3f	; 63
    371c:	f8 94       	cli
    371e:	e2 9a       	sbi	0x1c, 2	; 28
    3720:	e1 9a       	sbi	0x1c, 1	; 28
    3722:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3724:	e1 99       	sbic	0x1c, 1	; 28
    3726:	fe cf       	rjmp	.-4      	; 0x3724 <MasterReset+0x202>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3728:	8e e3       	ldi	r24, 0x3E	; 62
    372a:	90 e0       	ldi	r25, 0x00	; 0
    372c:	9f bb       	out	0x1f, r25	; 31
    372e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3730:	8c e2       	ldi	r24, 0x2C	; 44
    3732:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3734:	0f b6       	in	r0, 0x3f	; 63
    3736:	f8 94       	cli
    3738:	e2 9a       	sbi	0x1c, 2	; 28
    373a:	e1 9a       	sbi	0x1c, 1	; 28
    373c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    373e:	e1 99       	sbic	0x1c, 1	; 28
    3740:	fe cf       	rjmp	.-4      	; 0x373e <MasterReset+0x21c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3742:	8f e3       	ldi	r24, 0x3F	; 63
    3744:	90 e0       	ldi	r25, 0x00	; 0
    3746:	9f bb       	out	0x1f, r25	; 31
    3748:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    374a:	9e e2       	ldi	r25, 0x2E	; 46
    374c:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    374e:	0f b6       	in	r0, 0x3f	; 63
    3750:	f8 94       	cli
    3752:	e2 9a       	sbi	0x1c, 2	; 28
    3754:	e1 9a       	sbi	0x1c, 1	; 28
    3756:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefDecimalTotalVolume,2);
	 eeprom_write_byte(&DefDecimalTotalMoney,0);
	 eeprom_write_byte(&DefDecimalMark,',');
	 eeprom_write_byte(&DefCurrencyMark,'.');

	 xArray[0]=',';	 xArray[1]='.'; 	 xArray[2]=' ';	 xArray[3]='/';  xArray[4]='-'; 
    3758:	8c e2       	ldi	r24, 0x2C	; 44
    375a:	89 83       	std	Y+1, r24	; 0x01
    375c:	9a 83       	std	Y+2, r25	; 0x02
    375e:	80 e2       	ldi	r24, 0x20	; 32
    3760:	8b 83       	std	Y+3, r24	; 0x03
    3762:	8f e2       	ldi	r24, 0x2F	; 47
    3764:	8c 83       	std	Y+4, r24	; 0x04
    3766:	8d e2       	ldi	r24, 0x2D	; 45
    3768:	8d 83       	std	Y+5, r24	; 0x05
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    376a:	80 e4       	ldi	r24, 0x40	; 64
    376c:	90 e0       	ldi	r25, 0x00	; 0
    376e:	8e 01       	movw	r16, r28
    3770:	0f 5f       	subi	r16, 0xFF	; 255
    3772:	1f 4f       	sbci	r17, 0xFF	; 255
    3774:	b8 01       	movw	r22, r16
    3776:	45 e0       	ldi	r20, 0x05	; 5
    3778:	50 e0       	ldi	r21, 0x00	; 0
    377a:	2c e4       	ldi	r18, 0x4C	; 76
    377c:	32 e1       	ldi	r19, 0x12	; 18
    377e:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefMarkMap, 5);

	 xArray[0]=1;	 xArray[1]=2; 	 xArray[2]=0;	 xArray[3]=0; xArray[4]=0;	 xArray[5]=0; xArray[6]=0;	 	 
    3782:	81 e0       	ldi	r24, 0x01	; 1
    3784:	89 83       	std	Y+1, r24	; 0x01
    3786:	82 e0       	ldi	r24, 0x02	; 2
    3788:	8a 83       	std	Y+2, r24	; 0x02
    378a:	1b 82       	std	Y+3, r1	; 0x03
    378c:	1c 82       	std	Y+4, r1	; 0x04
    378e:	1d 82       	std	Y+5, r1	; 0x05
    3790:	1e 82       	std	Y+6, r1	; 0x06
    3792:	1f 82       	std	Y+7, r1	; 0x07
    3794:	85 e4       	ldi	r24, 0x45	; 69
    3796:	90 e0       	ldi	r25, 0x00	; 0
    3798:	b8 01       	movw	r22, r16
    379a:	48 e0       	ldi	r20, 0x08	; 8
    379c:	50 e0       	ldi	r21, 0x00	; 0
    379e:	2c e4       	ldi	r18, 0x4C	; 76
    37a0:	32 e1       	ldi	r19, 0x12	; 18
    37a2:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpMap, 8);
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpLabel, 8);     
}
    37a6:	8d e4       	ldi	r24, 0x4D	; 77
    37a8:	90 e0       	ldi	r25, 0x00	; 0
    37aa:	b8 01       	movw	r22, r16
    37ac:	48 e0       	ldi	r20, 0x08	; 8
    37ae:	50 e0       	ldi	r21, 0x00	; 0
    37b0:	2c e4       	ldi	r18, 0x4C	; 76
    37b2:	32 e1       	ldi	r19, 0x12	; 18
    37b4:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    37b8:	ec 96       	adiw	r28, 0x3c	; 60
    37ba:	0f b6       	in	r0, 0x3f	; 63
    37bc:	f8 94       	cli
    37be:	de bf       	out	0x3e, r29	; 62
    37c0:	0f be       	out	0x3f, r0	; 63
    37c2:	cd bf       	out	0x3d, r28	; 61
    37c4:	cf 91       	pop	r28
    37c6:	df 91       	pop	r29
    37c8:	1f 91       	pop	r17
    37ca:	0f 91       	pop	r16
    37cc:	ff 90       	pop	r15
    37ce:	ef 90       	pop	r14
    37d0:	df 90       	pop	r13
    37d2:	08 95       	ret

000037d4 <procMessage21>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    37d4:	af 92       	push	r10
    37d6:	bf 92       	push	r11
    37d8:	cf 92       	push	r12
    37da:	df 92       	push	r13
    37dc:	ef 92       	push	r14
    37de:	ff 92       	push	r15
    37e0:	0f 93       	push	r16
    37e2:	1f 93       	push	r17
    37e4:	df 93       	push	r29
    37e6:	cf 93       	push	r28
    37e8:	cd b7       	in	r28, 0x3d	; 61
    37ea:	de b7       	in	r29, 0x3e	; 62
    37ec:	2b 97       	sbiw	r28, 0x0b	; 11
    37ee:	0f b6       	in	r0, 0x3f	; 63
    37f0:	f8 94       	cli
    37f2:	de bf       	out	0x3e, r29	; 62
    37f4:	0f be       	out	0x3f, r0	; 63
    37f6:	cd bf       	out	0x3d, r28	; 61
    37f8:	09 e0       	ldi	r16, 0x09	; 9
    37fa:	11 e0       	ldi	r17, 0x01	; 1
    37fc:	62 e4       	ldi	r22, 0x42	; 66
    37fe:	e6 2e       	mov	r14, r22
    3800:	69 e0       	ldi	r22, 0x09	; 9
    3802:	f6 2e       	mov	r15, r22
    3804:	6e 01       	movw	r12, r28
    3806:	08 94       	sec
    3808:	c1 1c       	adc	r12, r1
    380a:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    380c:	5b e0       	ldi	r21, 0x0B	; 11
    380e:	a5 2e       	mov	r10, r21
    3810:	b1 2c       	mov	r11, r1
    3812:	ac 0e       	add	r10, r28
    3814:	bd 1e       	adc	r11, r29
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    3816:	f6 01       	movw	r30, r12
    3818:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    381a:	8d 91       	ld	r24, X+
    381c:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    381e:	ea 15       	cp	r30, r10
    3820:	fb 05       	cpc	r31, r11
    3822:	d9 f7       	brne	.-10     	; 0x381a <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3824:	1b 86       	std	Y+11, r1	; 0x0b
    3826:	c8 01       	movw	r24, r16
    3828:	b6 01       	movw	r22, r12
    382a:	4b e0       	ldi	r20, 0x0B	; 11
    382c:	50 e0       	ldi	r21, 0x00	; 0
    382e:	2c e4       	ldi	r18, 0x4C	; 76
    3830:	32 e1       	ldi	r19, 0x12	; 18
    3832:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    3836:	05 5f       	subi	r16, 0xF5	; 245
    3838:	1f 4f       	sbci	r17, 0xFF	; 255
    383a:	8a e0       	ldi	r24, 0x0A	; 10
    383c:	90 e0       	ldi	r25, 0x00	; 0
    383e:	e8 0e       	add	r14, r24
    3840:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    3842:	91 e0       	ldi	r25, 0x01	; 1
    3844:	05 33       	cpi	r16, 0x35	; 53
    3846:	19 07       	cpc	r17, r25
    3848:	31 f7       	brne	.-52     	; 0x3816 <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    384a:	80 e0       	ldi	r24, 0x00	; 0
    384c:	2b 96       	adiw	r28, 0x0b	; 11
    384e:	0f b6       	in	r0, 0x3f	; 63
    3850:	f8 94       	cli
    3852:	de bf       	out	0x3e, r29	; 62
    3854:	0f be       	out	0x3f, r0	; 63
    3856:	cd bf       	out	0x3d, r28	; 61
    3858:	cf 91       	pop	r28
    385a:	df 91       	pop	r29
    385c:	1f 91       	pop	r17
    385e:	0f 91       	pop	r16
    3860:	ff 90       	pop	r15
    3862:	ef 90       	pop	r14
    3864:	df 90       	pop	r13
    3866:	cf 90       	pop	r12
    3868:	bf 90       	pop	r11
    386a:	af 90       	pop	r10
    386c:	08 95       	ret

0000386e <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){//Find FIP Addr based on PumpID respectively: 
    386e:	ff 92       	push	r15
    3870:	0f 93       	push	r16
    3872:	1f 93       	push	r17
    3874:	df 93       	push	r29
    3876:	cf 93       	push	r28
    3878:	cd b7       	in	r28, 0x3d	; 61
    387a:	de b7       	in	r29, 0x3e	; 62
    387c:	28 97       	sbiw	r28, 0x08	; 8
    387e:	0f b6       	in	r0, 0x3f	; 63
    3880:	f8 94       	cli
    3882:	de bf       	out	0x3e, r29	; 62
    3884:	0f be       	out	0x3f, r0	; 63
    3886:	cd bf       	out	0x3d, r28	; 61
    3888:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    388a:	8e 01       	movw	r16, r28
    388c:	0f 5f       	subi	r16, 0xFF	; 255
    388e:	1f 4f       	sbci	r17, 0xFF	; 255
    3890:	c8 01       	movw	r24, r16
    3892:	65 e4       	ldi	r22, 0x45	; 69
    3894:	70 e0       	ldi	r23, 0x00	; 0
    3896:	48 e0       	ldi	r20, 0x08	; 8
    3898:	50 e0       	ldi	r21, 0x00	; 0
    389a:	24 e4       	ldi	r18, 0x44	; 68
    389c:	32 e1       	ldi	r19, 0x12	; 18
    389e:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    38a2:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     //FIP1..FIP8
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    38a4:	9e 01       	movw	r18, r28
    38a6:	27 5f       	subi	r18, 0xF7	; 247
    38a8:	3f 4f       	sbci	r19, 0xFF	; 255
    38aa:	9e 2f       	mov	r25, r30
    38ac:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    38ae:	80 81       	ld	r24, Z
    38b0:	8f 15       	cp	r24, r15
    38b2:	19 f4       	brne	.+6      	; 0x38ba <GetFIPAddr+0x4c>
		     Result=i+1;
    38b4:	89 2f       	mov	r24, r25
    38b6:	8f 5f       	subi	r24, 0xFF	; 255
    38b8:	05 c0       	rjmp	.+10     	; 0x38c4 <GetFIPAddr+0x56>
			 break;
    38ba:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){//Find FIP Addr based on PumpID respectively: 
char i,PPumpID[8],Result;     //FIP1..FIP8
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    38bc:	e2 17       	cp	r30, r18
    38be:	f3 07       	cpc	r31, r19
    38c0:	a1 f7       	brne	.-24     	; 0x38aa <GetFIPAddr+0x3c>
    38c2:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    38c4:	28 96       	adiw	r28, 0x08	; 8
    38c6:	0f b6       	in	r0, 0x3f	; 63
    38c8:	f8 94       	cli
    38ca:	de bf       	out	0x3e, r29	; 62
    38cc:	0f be       	out	0x3f, r0	; 63
    38ce:	cd bf       	out	0x3d, r28	; 61
    38d0:	cf 91       	pop	r28
    38d2:	df 91       	pop	r29
    38d4:	1f 91       	pop	r17
    38d6:	0f 91       	pop	r16
    38d8:	ff 90       	pop	r15
    38da:	08 95       	ret

000038dc <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    38dc:	ff 92       	push	r15
    38de:	0f 93       	push	r16
    38e0:	1f 93       	push	r17
    38e2:	cf 93       	push	r28
    38e4:	df 93       	push	r29
    38e6:	28 2f       	mov	r18, r24
    38e8:	f6 2e       	mov	r15, r22
char strSend[20],iPumpID; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    38ea:	80 31       	cpi	r24, 0x10	; 16
    38ec:	08 f0       	brcs	.+2      	; 0x38f0 <UpdateStandaloneStatus+0x14>
    38ee:	4e c0       	rjmp	.+156    	; 0x398c <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    38f0:	e1 99       	sbic	0x1c, 1	; 28
    38f2:	fe cf       	rjmp	.-4      	; 0x38f0 <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38f4:	87 e3       	ldi	r24, 0x37	; 55
    38f6:	91 e0       	ldi	r25, 0x01	; 1
    38f8:	9f bb       	out	0x1f, r25	; 31
    38fa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    38fc:	e0 9a       	sbi	0x1c, 0	; 28
    38fe:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    3900:	80 93 5e 01 	sts	0x015E, r24
	     switch(DispenserBrand){
    3904:	81 50       	subi	r24, 0x01	; 1
    3906:	82 30       	cpi	r24, 0x02	; 2
    3908:	08 f4       	brcc	.+2      	; 0x390c <UpdateStandaloneStatus+0x30>
    390a:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    390c:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
		 if (iAddr>0){
    3910:	88 23       	and	r24, r24
    3912:	e1 f1       	breq	.+120    	; 0x398c <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    3914:	81 50       	subi	r24, 0x01	; 1
    3916:	c8 2f       	mov	r28, r24
    3918:	d0 e0       	ldi	r29, 0x00	; 0
    391a:	80 e1       	ldi	r24, 0x10	; 16
    391c:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    3920:	8e 01       	movw	r16, r28
    3922:	0e 5f       	subi	r16, 0xFE	; 254
    3924:	1e 4f       	sbci	r17, 0xFE	; 254
    3926:	f8 01       	movw	r30, r16
    3928:	90 81       	ld	r25, Z
    392a:	98 17       	cp	r25, r24
    392c:	b1 f0       	breq	.+44     	; 0x395a <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    392e:	f0 e1       	ldi	r31, 0x10	; 16
    3930:	ff 16       	cp	r15, r31
    3932:	21 f0       	breq	.+8      	; 0x393c <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    3934:	fe 01       	movw	r30, r28
    3936:	e1 5a       	subi	r30, 0xA1	; 161
    3938:	fe 4f       	sbci	r31, 0xFE	; 254
    393a:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    393c:	8f 2d       	mov	r24, r15
    393e:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    3942:	8e 01       	movw	r16, r28
    3944:	0e 5f       	subi	r16, 0xFE	; 254
    3946:	1e 4f       	sbci	r17, 0xFE	; 254
    3948:	f8 01       	movw	r30, r16
    394a:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    394c:	f5 e1       	ldi	r31, 0x15	; 21
    394e:	ff 16       	cp	r15, r31
    3950:	c1 f4       	brne	.+48     	; 0x3982 <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3952:	c1 5a       	subi	r28, 0xA1	; 161
    3954:	de 4f       	sbci	r29, 0xFE	; 254
    3956:	88 81       	ld	r24, Y
    3958:	10 c0       	rjmp	.+32     	; 0x397a <UpdateStandaloneStatus+0x9e>
    395a:	fe 01       	movw	r30, r28
    395c:	e1 5a       	subi	r30, 0xA1	; 161
    395e:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED){
    3960:	81 e1       	ldi	r24, 0x11	; 17
    3962:	f8 16       	cp	r15, r24
    3964:	11 f4       	brne	.+4      	; 0x396a <UpdateStandaloneStatus+0x8e>
				 //New

				     //if (CurrentPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY))
			             strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3966:	80 81       	ld	r24, Z
    3968:	08 c0       	rjmp	.+16     	; 0x397a <UpdateStandaloneStatus+0x9e>
					 //    CurrentPumpStatus[iAddr]=PUMP_OFF;
					 //    strPumpStatus[iAddr]=GetPumpStatusLabel(PUMP_OFF);
					 //}

				  }
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    396a:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    396c:	8b e0       	ldi	r24, 0x0B	; 11
    396e:	f8 16       	cp	r15, r24
    3970:	21 f0       	breq	.+8      	; 0x397a <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    3972:	f4 e1       	ldi	r31, 0x14	; 20
    3974:	ff 16       	cp	r15, r31
    3976:	29 f4       	brne	.+10     	; 0x3982 <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3978:	84 e1       	ldi	r24, 0x14	; 20
    397a:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    397e:	f8 01       	movw	r30, r16
    3980:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    3982:	10 92 12 01 	sts	0x0112, r1
	     IsNewPumpStatus=True;		 
    3986:	81 e0       	ldi	r24, 0x01	; 1
    3988:	80 93 01 01 	sts	0x0101, r24
		 }		 
	 }
}
    398c:	df 91       	pop	r29
    398e:	cf 91       	pop	r28
    3990:	1f 91       	pop	r17
    3992:	0f 91       	pop	r16
    3994:	ff 90       	pop	r15
    3996:	08 95       	ret

00003998 <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    3998:	1f 93       	push	r17
    399a:	df 93       	push	r29
    399c:	cf 93       	push	r28
    399e:	cd b7       	in	r28, 0x3d	; 61
    39a0:	de b7       	in	r29, 0x3e	; 62
    39a2:	28 97       	sbiw	r28, 0x08	; 8
    39a4:	0f b6       	in	r0, 0x3f	; 63
    39a6:	f8 94       	cli
    39a8:	de bf       	out	0x3e, r29	; 62
    39aa:	0f be       	out	0x3f, r0	; 63
    39ac:	cd bf       	out	0x3d, r28	; 61
    39ae:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    39b0:	ce 01       	movw	r24, r28
    39b2:	01 96       	adiw	r24, 0x01	; 1
    39b4:	65 e4       	ldi	r22, 0x45	; 69
    39b6:	70 e0       	ldi	r23, 0x00	; 0
    39b8:	48 e0       	ldi	r20, 0x08	; 8
    39ba:	50 e0       	ldi	r21, 0x00	; 0
    39bc:	24 e4       	ldi	r18, 0x44	; 68
    39be:	32 e1       	ldi	r19, 0x12	; 18
    39c0:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    39c4:	81 2f       	mov	r24, r17
    39c6:	81 50       	subi	r24, 0x01	; 1
    39c8:	87 30       	cpi	r24, 0x07	; 7
    39ca:	10 f0       	brcs	.+4      	; 0x39d0 <GetPumpID+0x38>
    39cc:	80 e0       	ldi	r24, 0x00	; 0
    39ce:	04 c0       	rjmp	.+8      	; 0x39d8 <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    39d0:	fe 01       	movw	r30, r28
    39d2:	e1 0f       	add	r30, r17
    39d4:	f1 1d       	adc	r31, r1
    39d6:	80 81       	ld	r24, Z
	 }
   return Result;
}
    39d8:	28 96       	adiw	r28, 0x08	; 8
    39da:	0f b6       	in	r0, 0x3f	; 63
    39dc:	f8 94       	cli
    39de:	de bf       	out	0x3e, r29	; 62
    39e0:	0f be       	out	0x3f, r0	; 63
    39e2:	cd bf       	out	0x3d, r28	; 61
    39e4:	cf 91       	pop	r28
    39e6:	df 91       	pop	r29
    39e8:	1f 91       	pop	r17
    39ea:	08 95       	ret

000039ec <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    39ec:	0f 93       	push	r16
    39ee:	1f 93       	push	r17
    39f0:	df 93       	push	r29
    39f2:	cf 93       	push	r28
    39f4:	00 d0       	rcall	.+0      	; 0x39f6 <GetTotalizerData+0xa>
    39f6:	00 d0       	rcall	.+0      	; 0x39f8 <GetTotalizerData+0xc>
    39f8:	00 d0       	rcall	.+0      	; 0x39fa <GetTotalizerData+0xe>
    39fa:	cd b7       	in	r28, 0x3d	; 61
    39fc:	de b7       	in	r29, 0x3e	; 62
    39fe:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    3a00:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    3a02:	21 50       	subi	r18, 0x01	; 1
    3a04:	26 30       	cpi	r18, 0x06	; 6
    3a06:	08 f4       	brcc	.+2      	; 0x3a0a <GetTotalizerData+0x1e>
    3a08:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3a0a:	88 23       	and	r24, r24
    3a0c:	d9 f4       	brne	.+54     	; 0x3a44 <GetTotalizerData+0x58>
    3a0e:	64 e2       	ldi	r22, 0x24	; 36
    3a10:	46 9f       	mul	r20, r22
    3a12:	b0 01       	movw	r22, r0
    3a14:	11 24       	eor	r1, r1
    3a16:	29 2f       	mov	r18, r25
    3a18:	30 e0       	ldi	r19, 0x00	; 0
    3a1a:	80 e2       	ldi	r24, 0x20	; 32
    3a1c:	91 e0       	ldi	r25, 0x01	; 1
    3a1e:	fc 01       	movw	r30, r24
    3a20:	2e 9f       	mul	r18, r30
    3a22:	c0 01       	movw	r24, r0
    3a24:	2f 9f       	mul	r18, r31
    3a26:	90 0d       	add	r25, r0
    3a28:	3e 9f       	mul	r19, r30
    3a2a:	90 0d       	add	r25, r0
    3a2c:	11 24       	eor	r1, r1
    3a2e:	68 0f       	add	r22, r24
    3a30:	79 1f       	adc	r23, r25
    3a32:	86 e0       	ldi	r24, 0x06	; 6
    3a34:	58 9f       	mul	r21, r24
    3a36:	c0 01       	movw	r24, r0
    3a38:	11 24       	eor	r1, r1
    3a3a:	68 0f       	add	r22, r24
    3a3c:	79 1f       	adc	r23, r25
    3a3e:	6d 53       	subi	r22, 0x3D	; 61
    3a40:	7c 4f       	sbci	r23, 0xFC	; 252
    3a42:	1c c0       	rjmp	.+56     	; 0x3a7c <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3a44:	81 30       	cpi	r24, 0x01	; 1
    3a46:	11 f5       	brne	.+68     	; 0x3a8c <GetTotalizerData+0xa0>
    3a48:	64 e2       	ldi	r22, 0x24	; 36
    3a4a:	46 9f       	mul	r20, r22
    3a4c:	b0 01       	movw	r22, r0
    3a4e:	11 24       	eor	r1, r1
    3a50:	29 2f       	mov	r18, r25
    3a52:	30 e0       	ldi	r19, 0x00	; 0
    3a54:	80 e2       	ldi	r24, 0x20	; 32
    3a56:	91 e0       	ldi	r25, 0x01	; 1
    3a58:	fc 01       	movw	r30, r24
    3a5a:	2e 9f       	mul	r18, r30
    3a5c:	c0 01       	movw	r24, r0
    3a5e:	2f 9f       	mul	r18, r31
    3a60:	90 0d       	add	r25, r0
    3a62:	3e 9f       	mul	r19, r30
    3a64:	90 0d       	add	r25, r0
    3a66:	11 24       	eor	r1, r1
    3a68:	68 0f       	add	r22, r24
    3a6a:	79 1f       	adc	r23, r25
    3a6c:	86 e0       	ldi	r24, 0x06	; 6
    3a6e:	58 9f       	mul	r21, r24
    3a70:	c0 01       	movw	r24, r0
    3a72:	11 24       	eor	r1, r1
    3a74:	68 0f       	add	r22, r24
    3a76:	79 1f       	adc	r23, r25
    3a78:	6d 5f       	subi	r22, 0xFD	; 253
    3a7a:	79 4f       	sbci	r23, 0xF9	; 249
    3a7c:	ce 01       	movw	r24, r28
    3a7e:	01 96       	adiw	r24, 0x01	; 1
    3a80:	46 e0       	ldi	r20, 0x06	; 6
    3a82:	50 e0       	ldi	r21, 0x00	; 0
    3a84:	24 e4       	ldi	r18, 0x44	; 68
    3a86:	32 e1       	ldi	r19, 0x12	; 18
    3a88:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    3a8c:	ce 01       	movw	r24, r28
    3a8e:	01 96       	adiw	r24, 0x01	; 1
    3a90:	b8 01       	movw	r22, r16
    3a92:	0e 94 9b 18 	call	0x3136	; 0x3136 <RawToStr>
}
    3a96:	26 96       	adiw	r28, 0x06	; 6
    3a98:	0f b6       	in	r0, 0x3f	; 63
    3a9a:	f8 94       	cli
    3a9c:	de bf       	out	0x3e, r29	; 62
    3a9e:	0f be       	out	0x3f, r0	; 63
    3aa0:	cd bf       	out	0x3d, r28	; 61
    3aa2:	cf 91       	pop	r28
    3aa4:	df 91       	pop	r29
    3aa6:	1f 91       	pop	r17
    3aa8:	0f 91       	pop	r16
    3aaa:	08 95       	ret

00003aac <SaveToEEPROM>:
     return Result;
}



char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    3aac:	ef 92       	push	r14
    3aae:	ff 92       	push	r15
    3ab0:	0f 93       	push	r16
    3ab2:	1f 93       	push	r17
    3ab4:	df 93       	push	r29
    3ab6:	cf 93       	push	r28
    3ab8:	cd b7       	in	r28, 0x3d	; 61
    3aba:	de b7       	in	r29, 0x3e	; 62
    3abc:	ac 97       	sbiw	r28, 0x2c	; 44
    3abe:	0f b6       	in	r0, 0x3f	; 63
    3ac0:	f8 94       	cli
    3ac2:	de bf       	out	0x3e, r29	; 62
    3ac4:	0f be       	out	0x3f, r0	; 63
    3ac6:	cd bf       	out	0x3d, r28	; 61
    3ac8:	9a a7       	std	Y+42, r25	; 0x2a
    3aca:	89 a7       	std	Y+41, r24	; 0x29
    3acc:	7c a7       	std	Y+44, r23	; 0x2c
    3ace:	6b a7       	std	Y+43, r22	; 0x2b
    3ad0:	7a 01       	movw	r14, r20
    3ad2:	8e 01       	movw	r16, r28
    3ad4:	05 5d       	subi	r16, 0xD5	; 213
    3ad6:	1f 4f       	sbci	r17, 0xFF	; 255
    3ad8:	c8 01       	movw	r24, r16
    3ada:	be 01       	movw	r22, r28
    3adc:	6f 5f       	subi	r22, 0xFF	; 255
    3ade:	7f 4f       	sbci	r23, 0xFF	; 255
    3ae0:	24 e4       	ldi	r18, 0x44	; 68
    3ae2:	32 e1       	ldi	r19, 0x12	; 18
    3ae4:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3ae8:	c8 01       	movw	r24, r16
    3aea:	be 01       	movw	r22, r28
    3aec:	67 5d       	subi	r22, 0xD7	; 215
    3aee:	7f 4f       	sbci	r23, 0xFF	; 255
    3af0:	a7 01       	movw	r20, r14
    3af2:	2c e4       	ldi	r18, 0x4C	; 76
    3af4:	32 e1       	ldi	r19, 0x12	; 18
    3af6:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    3afa:	ac 96       	adiw	r28, 0x2c	; 44
    3afc:	0f b6       	in	r0, 0x3f	; 63
    3afe:	f8 94       	cli
    3b00:	de bf       	out	0x3e, r29	; 62
    3b02:	0f be       	out	0x3f, r0	; 63
    3b04:	cd bf       	out	0x3d, r28	; 61
    3b06:	cf 91       	pop	r28
    3b08:	df 91       	pop	r29
    3b0a:	1f 91       	pop	r17
    3b0c:	0f 91       	pop	r16
    3b0e:	ff 90       	pop	r15
    3b10:	ef 90       	pop	r14
    3b12:	08 95       	ret

00003b14 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    3b14:	df 92       	push	r13
    3b16:	ef 92       	push	r14
    3b18:	ff 92       	push	r15
    3b1a:	0f 93       	push	r16
    3b1c:	1f 93       	push	r17
    3b1e:	df 93       	push	r29
    3b20:	cf 93       	push	r28
    3b22:	00 d0       	rcall	.+0      	; 0x3b24 <SelectMark+0x10>
    3b24:	00 d0       	rcall	.+0      	; 0x3b26 <SelectMark+0x12>
    3b26:	0f 92       	push	r0
    3b28:	cd b7       	in	r28, 0x3d	; 61
    3b2a:	de b7       	in	r29, 0x3e	; 62
    3b2c:	d8 2e       	mov	r13, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3b2e:	8e 01       	movw	r16, r28
    3b30:	0f 5f       	subi	r16, 0xFF	; 255
    3b32:	1f 4f       	sbci	r17, 0xFF	; 255
    3b34:	c8 01       	movw	r24, r16
    3b36:	60 e4       	ldi	r22, 0x40	; 64
    3b38:	70 e0       	ldi	r23, 0x00	; 0
    3b3a:	45 e0       	ldi	r20, 0x05	; 5
    3b3c:	50 e0       	ldi	r21, 0x00	; 0
    3b3e:	24 e4       	ldi	r18, 0x44	; 68
    3b40:	32 e1       	ldi	r19, 0x12	; 18
    3b42:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    3b46:	ed 2d       	mov	r30, r13
    3b48:	21 e0       	ldi	r18, 0x01	; 1
    3b4a:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    3b4c:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    3b4e:	d8 01       	movw	r26, r16
    3b50:	8c 91       	ld	r24, X
    3b52:	d8 16       	cp	r13, r24
    3b54:	49 f4       	brne	.+18     	; 0x3b68 <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    3b56:	c9 01       	movw	r24, r18
    3b58:	65 e0       	ldi	r22, 0x05	; 5
    3b5a:	70 e0       	ldi	r23, 0x00	; 0
    3b5c:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    3b60:	f7 01       	movw	r30, r14
    3b62:	e8 0f       	add	r30, r24
    3b64:	f9 1f       	adc	r31, r25
    3b66:	e0 81       	ld	r30, Z
    3b68:	0f 5f       	subi	r16, 0xFF	; 255
    3b6a:	1f 4f       	sbci	r17, 0xFF	; 255
    3b6c:	2f 5f       	subi	r18, 0xFF	; 255
    3b6e:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    3b70:	26 30       	cpi	r18, 0x06	; 6
    3b72:	31 05       	cpc	r19, r1
    3b74:	61 f7       	brne	.-40     	; 0x3b4e <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    3b76:	8e 2f       	mov	r24, r30
    3b78:	0f 90       	pop	r0
    3b7a:	0f 90       	pop	r0
    3b7c:	0f 90       	pop	r0
    3b7e:	0f 90       	pop	r0
    3b80:	0f 90       	pop	r0
    3b82:	cf 91       	pop	r28
    3b84:	df 91       	pop	r29
    3b86:	1f 91       	pop	r17
    3b88:	0f 91       	pop	r16
    3b8a:	ff 90       	pop	r15
    3b8c:	ef 90       	pop	r14
    3b8e:	df 90       	pop	r13
    3b90:	08 95       	ret

00003b92 <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    3b92:	cf 92       	push	r12
    3b94:	df 92       	push	r13
    3b96:	ef 92       	push	r14
    3b98:	ff 92       	push	r15
    3b9a:	0f 93       	push	r16
    3b9c:	1f 93       	push	r17
    3b9e:	df 93       	push	r29
    3ba0:	cf 93       	push	r28
    3ba2:	cd b7       	in	r28, 0x3d	; 61
    3ba4:	de b7       	in	r29, 0x3e	; 62
    3ba6:	2f 97       	sbiw	r28, 0x0f	; 15
    3ba8:	0f b6       	in	r0, 0x3f	; 63
    3baa:	f8 94       	cli
    3bac:	de bf       	out	0x3e, r29	; 62
    3bae:	0f be       	out	0x3f, r0	; 63
    3bb0:	cd bf       	out	0x3d, r28	; 61
    3bb2:	e8 2e       	mov	r14, r24
    3bb4:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    3bb6:	8f 70       	andi	r24, 0x0F	; 15
    3bb8:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
     if (FIPAddr>0){
    3bbc:	88 23       	and	r24, r24
    3bbe:	09 f4       	brne	.+2      	; 0x3bc2 <GenerateStandaloneTransData+0x30>
    3bc0:	2d c1       	rjmp	.+602    	; 0x3e1c <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    3bc2:	81 50       	subi	r24, 0x01	; 1
    3bc4:	c8 2e       	mov	r12, r24
    3bc6:	dd 24       	eor	r13, r13
    3bc8:	85 e3       	ldi	r24, 0x35	; 53
    3bca:	90 e0       	ldi	r25, 0x00	; 0
    3bcc:	c8 9e       	mul	r12, r24
    3bce:	f0 01       	movw	r30, r0
    3bd0:	c9 9e       	mul	r12, r25
    3bd2:	f0 0d       	add	r31, r0
    3bd4:	d8 9e       	mul	r13, r24
    3bd6:	f0 0d       	add	r31, r0
    3bd8:	11 24       	eor	r1, r1
    3bda:	e8 55       	subi	r30, 0x58	; 88
    3bdc:	fa 4f       	sbci	r31, 0xFA	; 250
    3bde:	80 81       	ld	r24, Z
    3be0:	08 0f       	add	r16, r24
    3be2:	11 1d       	adc	r17, r1
    3be4:	d8 01       	movw	r26, r16
    3be6:	2c 91       	ld	r18, X
    3be8:	ce 01       	movw	r24, r28
    3bea:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    3bec:	22 23       	and	r18, r18
    3bee:	69 f0       	breq	.+26     	; 0x3c0a <GenerateStandaloneTransData+0x78>
    3bf0:	6d e0       	ldi	r22, 0x0D	; 13
    3bf2:	26 9f       	mul	r18, r22
    3bf4:	b0 01       	movw	r22, r0
    3bf6:	11 24       	eor	r1, r1
    3bf8:	62 55       	subi	r22, 0x52	; 82
    3bfa:	7f 4f       	sbci	r23, 0xFF	; 255
    3bfc:	4d e0       	ldi	r20, 0x0D	; 13
    3bfe:	50 e0       	ldi	r21, 0x00	; 0
    3c00:	24 e4       	ldi	r18, 0x44	; 68
    3c02:	32 e1       	ldi	r19, 0x12	; 18
    3c04:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    3c08:	10 c0       	rjmp	.+32     	; 0x3c2a <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    3c0a:	00 d0       	rcall	.+0      	; 0x3c0c <GenerateStandaloneTransData+0x7a>
    3c0c:	00 d0       	rcall	.+0      	; 0x3c0e <GenerateStandaloneTransData+0x7c>
    3c0e:	ed b7       	in	r30, 0x3d	; 61
    3c10:	fe b7       	in	r31, 0x3e	; 62
    3c12:	92 83       	std	Z+2, r25	; 0x02
    3c14:	81 83       	std	Z+1, r24	; 0x01
    3c16:	8a e5       	ldi	r24, 0x5A	; 90
    3c18:	91 e2       	ldi	r25, 0x21	; 33
    3c1a:	94 83       	std	Z+4, r25	; 0x04
    3c1c:	83 83       	std	Z+3, r24	; 0x03
    3c1e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    3c22:	0f 90       	pop	r0
    3c24:	0f 90       	pop	r0
    3c26:	0f 90       	pop	r0
    3c28:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3c2a:	e1 99       	sbic	0x1c, 1	; 28
    3c2c:	fe cf       	rjmp	.-4      	; 0x3c2a <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3c2e:	80 e0       	ldi	r24, 0x00	; 0
    3c30:	90 e0       	ldi	r25, 0x00	; 0
    3c32:	9f bb       	out	0x1f, r25	; 31
    3c34:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3c36:	e0 9a       	sbi	0x1c, 0	; 28
    3c38:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    3c3a:	00 d0       	rcall	.+0      	; 0x3c3c <GenerateStandaloneTransData+0xaa>
    3c3c:	00 d0       	rcall	.+0      	; 0x3c3e <GenerateStandaloneTransData+0xac>
    3c3e:	00 d0       	rcall	.+0      	; 0x3c40 <GenerateStandaloneTransData+0xae>
    3c40:	ad b7       	in	r26, 0x3d	; 61
    3c42:	be b7       	in	r27, 0x3e	; 62
    3c44:	11 96       	adiw	r26, 0x01	; 1
    3c46:	88 e6       	ldi	r24, 0x68	; 104
    3c48:	9c e0       	ldi	r25, 0x0C	; 12
    3c4a:	ed b7       	in	r30, 0x3d	; 61
    3c4c:	fe b7       	in	r31, 0x3e	; 62
    3c4e:	92 83       	std	Z+2, r25	; 0x02
    3c50:	81 83       	std	Z+1, r24	; 0x01
    3c52:	87 e5       	ldi	r24, 0x57	; 87
    3c54:	91 e2       	ldi	r25, 0x21	; 33
    3c56:	13 96       	adiw	r26, 0x03	; 3
    3c58:	9c 93       	st	X, r25
    3c5a:	8e 93       	st	-X, r24
    3c5c:	12 97       	sbiw	r26, 0x02	; 2
    3c5e:	85 e3       	ldi	r24, 0x35	; 53
    3c60:	90 e0       	ldi	r25, 0x00	; 0
    3c62:	c8 9e       	mul	r12, r24
    3c64:	80 01       	movw	r16, r0
    3c66:	c9 9e       	mul	r12, r25
    3c68:	10 0d       	add	r17, r0
    3c6a:	d8 9e       	mul	r13, r24
    3c6c:	10 0d       	add	r17, r0
    3c6e:	11 24       	eor	r1, r1
    3c70:	f8 01       	movw	r30, r16
    3c72:	e8 55       	subi	r30, 0x58	; 88
    3c74:	fa 4f       	sbci	r31, 0xFA	; 250
    3c76:	82 81       	ldd	r24, Z+2	; 0x02
    3c78:	14 96       	adiw	r26, 0x04	; 4
    3c7a:	8c 93       	st	X, r24
    3c7c:	14 97       	sbiw	r26, 0x04	; 4
    3c7e:	15 96       	adiw	r26, 0x05	; 5
    3c80:	1c 92       	st	X, r1
    3c82:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    3c86:	ed b7       	in	r30, 0x3d	; 61
    3c88:	fe b7       	in	r31, 0x3e	; 62
    3c8a:	31 96       	adiw	r30, 0x01	; 1
    3c8c:	87 e8       	ldi	r24, 0x87	; 135
    3c8e:	9c e0       	ldi	r25, 0x0C	; 12
    3c90:	ad b7       	in	r26, 0x3d	; 61
    3c92:	be b7       	in	r27, 0x3e	; 62
    3c94:	12 96       	adiw	r26, 0x02	; 2
    3c96:	9c 93       	st	X, r25
    3c98:	8e 93       	st	-X, r24
    3c9a:	11 97       	sbiw	r26, 0x01	; 1
    3c9c:	84 e5       	ldi	r24, 0x54	; 84
    3c9e:	91 e2       	ldi	r25, 0x21	; 33
    3ca0:	93 83       	std	Z+3, r25	; 0x03
    3ca2:	82 83       	std	Z+2, r24	; 0x02
    3ca4:	c8 01       	movw	r24, r16
    3ca6:	85 55       	subi	r24, 0x55	; 85
    3ca8:	9a 4f       	sbci	r25, 0xFA	; 250
    3caa:	95 83       	std	Z+5, r25	; 0x05
    3cac:	84 83       	std	Z+4, r24	; 0x04
    3cae:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    3cb2:	ed b7       	in	r30, 0x3d	; 61
    3cb4:	fe b7       	in	r31, 0x3e	; 62
    3cb6:	31 96       	adiw	r30, 0x01	; 1
    3cb8:	8e e6       	ldi	r24, 0x6E	; 110
    3cba:	97 e0       	ldi	r25, 0x07	; 7
    3cbc:	ad b7       	in	r26, 0x3d	; 61
    3cbe:	be b7       	in	r27, 0x3e	; 62
    3cc0:	12 96       	adiw	r26, 0x02	; 2
    3cc2:	9c 93       	st	X, r25
    3cc4:	8e 93       	st	-X, r24
    3cc6:	11 97       	sbiw	r26, 0x01	; 1
    3cc8:	81 e5       	ldi	r24, 0x51	; 81
    3cca:	91 e2       	ldi	r25, 0x21	; 33
    3ccc:	93 83       	std	Z+3, r25	; 0x03
    3cce:	82 83       	std	Z+2, r24	; 0x02
    3cd0:	c8 01       	movw	r24, r16
    3cd2:	8e 54       	subi	r24, 0x4E	; 78
    3cd4:	9a 4f       	sbci	r25, 0xFA	; 250
    3cd6:	95 83       	std	Z+5, r25	; 0x05
    3cd8:	84 83       	std	Z+4, r24	; 0x04
    3cda:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    3cde:	ed b7       	in	r30, 0x3d	; 61
    3ce0:	fe b7       	in	r31, 0x3e	; 62
    3ce2:	31 96       	adiw	r30, 0x01	; 1
    3ce4:	8d e4       	ldi	r24, 0x4D	; 77
    3ce6:	93 e0       	ldi	r25, 0x03	; 3
    3ce8:	ad b7       	in	r26, 0x3d	; 61
    3cea:	be b7       	in	r27, 0x3e	; 62
    3cec:	12 96       	adiw	r26, 0x02	; 2
    3cee:	9c 93       	st	X, r25
    3cf0:	8e 93       	st	-X, r24
    3cf2:	11 97       	sbiw	r26, 0x01	; 1
    3cf4:	8e e4       	ldi	r24, 0x4E	; 78
    3cf6:	91 e2       	ldi	r25, 0x21	; 33
    3cf8:	93 83       	std	Z+3, r25	; 0x03
    3cfa:	82 83       	std	Z+2, r24	; 0x02
    3cfc:	c8 01       	movw	r24, r16
    3cfe:	85 54       	subi	r24, 0x45	; 69
    3d00:	9a 4f       	sbci	r25, 0xFA	; 250
    3d02:	95 83       	std	Z+5, r25	; 0x05
    3d04:	84 83       	std	Z+4, r24	; 0x04
    3d06:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    3d0a:	ed b7       	in	r30, 0x3d	; 61
    3d0c:	fe b7       	in	r31, 0x3e	; 62
    3d0e:	31 96       	adiw	r30, 0x01	; 1
    3d10:	87 ef       	ldi	r24, 0xF7	; 247
    3d12:	98 e0       	ldi	r25, 0x08	; 8
    3d14:	ad b7       	in	r26, 0x3d	; 61
    3d16:	be b7       	in	r27, 0x3e	; 62
    3d18:	12 96       	adiw	r26, 0x02	; 2
    3d1a:	9c 93       	st	X, r25
    3d1c:	8e 93       	st	-X, r24
    3d1e:	11 97       	sbiw	r26, 0x01	; 1
    3d20:	8b e4       	ldi	r24, 0x4B	; 75
    3d22:	91 e2       	ldi	r25, 0x21	; 33
    3d24:	93 83       	std	Z+3, r25	; 0x03
    3d26:	82 83       	std	Z+2, r24	; 0x02
    3d28:	f4 82       	std	Z+4, r15	; 0x04
    3d2a:	15 82       	std	Z+5, r1	; 0x05
    3d2c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    3d30:	ed b7       	in	r30, 0x3d	; 61
    3d32:	fe b7       	in	r31, 0x3e	; 62
    3d34:	31 96       	adiw	r30, 0x01	; 1
    3d36:	89 eb       	ldi	r24, 0xB9	; 185
    3d38:	97 e0       	ldi	r25, 0x07	; 7
    3d3a:	ad b7       	in	r26, 0x3d	; 61
    3d3c:	be b7       	in	r27, 0x3e	; 62
    3d3e:	12 96       	adiw	r26, 0x02	; 2
    3d40:	9c 93       	st	X, r25
    3d42:	8e 93       	st	-X, r24
    3d44:	11 97       	sbiw	r26, 0x01	; 1
    3d46:	86 e4       	ldi	r24, 0x46	; 70
    3d48:	91 e2       	ldi	r25, 0x21	; 33
    3d4a:	93 83       	std	Z+3, r25	; 0x03
    3d4c:	82 83       	std	Z+2, r24	; 0x02
    3d4e:	e4 82       	std	Z+4, r14	; 0x04
    3d50:	15 82       	std	Z+5, r1	; 0x05
    3d52:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    3d56:	ed b7       	in	r30, 0x3d	; 61
    3d58:	fe b7       	in	r31, 0x3e	; 62
    3d5a:	31 96       	adiw	r30, 0x01	; 1
    3d5c:	8c e0       	ldi	r24, 0x0C	; 12
    3d5e:	98 e0       	ldi	r25, 0x08	; 8
    3d60:	ad b7       	in	r26, 0x3d	; 61
    3d62:	be b7       	in	r27, 0x3e	; 62
    3d64:	12 96       	adiw	r26, 0x02	; 2
    3d66:	9c 93       	st	X, r25
    3d68:	8e 93       	st	-X, r24
    3d6a:	11 97       	sbiw	r26, 0x01	; 1
    3d6c:	83 e4       	ldi	r24, 0x43	; 67
    3d6e:	91 e2       	ldi	r25, 0x21	; 33
    3d70:	93 83       	std	Z+3, r25	; 0x03
    3d72:	82 83       	std	Z+2, r24	; 0x02
    3d74:	ce 01       	movw	r24, r28
    3d76:	01 96       	adiw	r24, 0x01	; 1
    3d78:	95 83       	std	Z+5, r25	; 0x05
    3d7a:	84 83       	std	Z+4, r24	; 0x04
    3d7c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    3d80:	ed b7       	in	r30, 0x3d	; 61
    3d82:	fe b7       	in	r31, 0x3e	; 62
    3d84:	31 96       	adiw	r30, 0x01	; 1
    3d86:	8e e9       	ldi	r24, 0x9E	; 158
    3d88:	95 e0       	ldi	r25, 0x05	; 5
    3d8a:	ad b7       	in	r26, 0x3d	; 61
    3d8c:	be b7       	in	r27, 0x3e	; 62
    3d8e:	12 96       	adiw	r26, 0x02	; 2
    3d90:	9c 93       	st	X, r25
    3d92:	8e 93       	st	-X, r24
    3d94:	11 97       	sbiw	r26, 0x01	; 1
    3d96:	80 e4       	ldi	r24, 0x40	; 64
    3d98:	91 e2       	ldi	r25, 0x21	; 33
    3d9a:	93 83       	std	Z+3, r25	; 0x03
    3d9c:	82 83       	std	Z+2, r24	; 0x02
    3d9e:	c8 01       	movw	r24, r16
    3da0:	8c 53       	subi	r24, 0x3C	; 60
    3da2:	9a 4f       	sbci	r25, 0xFA	; 250
    3da4:	95 83       	std	Z+5, r25	; 0x05
    3da6:	84 83       	std	Z+4, r24	; 0x04
    3da8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    3dac:	ed b7       	in	r30, 0x3d	; 61
    3dae:	fe b7       	in	r31, 0x3e	; 62
    3db0:	31 96       	adiw	r30, 0x01	; 1
    3db2:	85 e7       	ldi	r24, 0x75	; 117
    3db4:	93 e0       	ldi	r25, 0x03	; 3
    3db6:	ad b7       	in	r26, 0x3d	; 61
    3db8:	be b7       	in	r27, 0x3e	; 62
    3dba:	12 96       	adiw	r26, 0x02	; 2
    3dbc:	9c 93       	st	X, r25
    3dbe:	8e 93       	st	-X, r24
    3dc0:	11 97       	sbiw	r26, 0x01	; 1
    3dc2:	8d e3       	ldi	r24, 0x3D	; 61
    3dc4:	91 e2       	ldi	r25, 0x21	; 33
    3dc6:	93 83       	std	Z+3, r25	; 0x03
    3dc8:	82 83       	std	Z+2, r24	; 0x02
    3dca:	c8 01       	movw	r24, r16
    3dcc:	85 53       	subi	r24, 0x35	; 53
    3dce:	9a 4f       	sbci	r25, 0xFA	; 250
    3dd0:	95 83       	std	Z+5, r25	; 0x05
    3dd2:	84 83       	std	Z+4, r24	; 0x04
    3dd4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    3dd8:	ed b7       	in	r30, 0x3d	; 61
    3dda:	fe b7       	in	r31, 0x3e	; 62
    3ddc:	31 96       	adiw	r30, 0x01	; 1
    3dde:	83 eb       	ldi	r24, 0xB3	; 179
    3de0:	9b e0       	ldi	r25, 0x0B	; 11
    3de2:	ad b7       	in	r26, 0x3d	; 61
    3de4:	be b7       	in	r27, 0x3e	; 62
    3de6:	12 96       	adiw	r26, 0x02	; 2
    3de8:	9c 93       	st	X, r25
    3dea:	8e 93       	st	-X, r24
    3dec:	11 97       	sbiw	r26, 0x01	; 1
    3dee:	8a e3       	ldi	r24, 0x3A	; 58
    3df0:	91 e2       	ldi	r25, 0x21	; 33
    3df2:	93 83       	std	Z+3, r25	; 0x03
    3df4:	82 83       	std	Z+2, r24	; 0x02
    3df6:	0c 52       	subi	r16, 0x2C	; 44
    3df8:	1a 4f       	sbci	r17, 0xFA	; 250
    3dfa:	15 83       	std	Z+5, r17	; 0x05
    3dfc:	04 83       	std	Z+4, r16	; 0x04
    3dfe:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>

		 MOPType=MOP_CASH;
    3e02:	10 92 b8 01 	sts	0x01B8, r1
	     IsPrinting=True;	 
    3e06:	81 e0       	ldi	r24, 0x01	; 1
    3e08:	80 93 ac 01 	sts	0x01AC, r24
    3e0c:	ed b7       	in	r30, 0x3d	; 61
    3e0e:	fe b7       	in	r31, 0x3e	; 62
    3e10:	36 96       	adiw	r30, 0x06	; 6
    3e12:	0f b6       	in	r0, 0x3f	; 63
    3e14:	f8 94       	cli
    3e16:	fe bf       	out	0x3e, r31	; 62
    3e18:	0f be       	out	0x3f, r0	; 63
    3e1a:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    3e1c:	2f 96       	adiw	r28, 0x0f	; 15
    3e1e:	0f b6       	in	r0, 0x3f	; 63
    3e20:	f8 94       	cli
    3e22:	de bf       	out	0x3e, r29	; 62
    3e24:	0f be       	out	0x3f, r0	; 63
    3e26:	cd bf       	out	0x3d, r28	; 61
    3e28:	cf 91       	pop	r28
    3e2a:	df 91       	pop	r29
    3e2c:	1f 91       	pop	r17
    3e2e:	0f 91       	pop	r16
    3e30:	ff 90       	pop	r15
    3e32:	ef 90       	pop	r14
    3e34:	df 90       	pop	r13
    3e36:	cf 90       	pop	r12
    3e38:	08 95       	ret

00003e3a <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    3e3a:	ef 92       	push	r14
    3e3c:	ff 92       	push	r15
    3e3e:	0f 93       	push	r16
    3e40:	1f 93       	push	r17
    3e42:	df 93       	push	r29
    3e44:	cf 93       	push	r28
    3e46:	00 d0       	rcall	.+0      	; 0x3e48 <PrintStandalone+0xe>
    3e48:	00 d0       	rcall	.+0      	; 0x3e4a <PrintStandalone+0x10>
    3e4a:	00 d0       	rcall	.+0      	; 0x3e4c <PrintStandalone+0x12>
    3e4c:	cd b7       	in	r28, 0x3d	; 61
    3e4e:	de b7       	in	r29, 0x3e	; 62
    3e50:	f8 2e       	mov	r15, r24
    3e52:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    3e54:	0e 94 cc 1c 	call	0x3998	; 0x3998 <GetPumpID>
    3e58:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    3e5a:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
    3e5e:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    3e60:	88 23       	and	r24, r24
    3e62:	99 f1       	breq	.+102    	; 0x3eca <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    3e64:	01 30       	cpi	r16, 0x01	; 1
    3e66:	69 f0       	breq	.+26     	; 0x3e82 <PrintStandalone+0x48>
    3e68:	ee 20       	and	r14, r14
    3e6a:	79 f1       	breq	.+94     	; 0x3eca <PrintStandalone+0x90>
    3e6c:	80 e1       	ldi	r24, 0x10	; 16
    3e6e:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    3e72:	11 50       	subi	r17, 0x01	; 1
    3e74:	e1 2f       	mov	r30, r17
    3e76:	f0 e0       	ldi	r31, 0x00	; 0
    3e78:	ee 5f       	subi	r30, 0xFE	; 254
    3e7a:	fe 4f       	sbci	r31, 0xFE	; 254
    3e7c:	90 81       	ld	r25, Z
    3e7e:	98 17       	cp	r25, r24
    3e80:	21 f5       	brne	.+72     	; 0x3eca <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3e82:	66 e0       	ldi	r22, 0x06	; 6
    3e84:	f6 9e       	mul	r15, r22
    3e86:	b0 01       	movw	r22, r0
    3e88:	11 24       	eor	r1, r1
    3e8a:	61 5b       	subi	r22, 0xB1	; 177
    3e8c:	7f 4f       	sbci	r23, 0xFF	; 255
    3e8e:	ce 01       	movw	r24, r28
    3e90:	01 96       	adiw	r24, 0x01	; 1
    3e92:	46 e0       	ldi	r20, 0x06	; 6
    3e94:	50 e0       	ldi	r21, 0x00	; 0
    3e96:	24 e4       	ldi	r18, 0x44	; 68
    3e98:	32 e1       	ldi	r19, 0x12	; 18
    3e9a:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    3e9e:	ef 2d       	mov	r30, r15
    3ea0:	f0 e0       	ldi	r31, 0x00	; 0
    3ea2:	ee 5e       	subi	r30, 0xEE	; 238
    3ea4:	fe 4f       	sbci	r31, 0xFE	; 254
    3ea6:	80 81       	ld	r24, Z
    3ea8:	81 30       	cpi	r24, 0x01	; 1
    3eaa:	19 f0       	breq	.+6      	; 0x3eb2 <PrintStandalone+0x78>
    3eac:	00 23       	and	r16, r16
    3eae:	29 f0       	breq	.+10     	; 0x3eba <PrintStandalone+0x80>
    3eb0:	0c c0       	rjmp	.+24     	; 0x3eca <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    3eb2:	01 30       	cpi	r16, 0x01	; 1
    3eb4:	11 f4       	brne	.+4      	; 0x3eba <PrintStandalone+0x80>
    3eb6:	00 93 7f 01 	sts	0x017F, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    3eba:	8e 2d       	mov	r24, r14
    3ebc:	be 01       	movw	r22, r28
    3ebe:	6f 5f       	subi	r22, 0xFF	; 255
    3ec0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ec2:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <GenerateStandaloneTransData>
    3ec6:	81 e1       	ldi	r24, 0x11	; 17
    3ec8:	01 c0       	rjmp	.+2      	; 0x3ecc <PrintStandalone+0x92>
    3eca:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    3ecc:	26 96       	adiw	r28, 0x06	; 6
    3ece:	0f b6       	in	r0, 0x3f	; 63
    3ed0:	f8 94       	cli
    3ed2:	de bf       	out	0x3e, r29	; 62
    3ed4:	0f be       	out	0x3f, r0	; 63
    3ed6:	cd bf       	out	0x3d, r28	; 61
    3ed8:	cf 91       	pop	r28
    3eda:	df 91       	pop	r29
    3edc:	1f 91       	pop	r17
    3ede:	0f 91       	pop	r16
    3ee0:	ff 90       	pop	r15
    3ee2:	ef 90       	pop	r14
    3ee4:	08 95       	ret

00003ee6 <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    3ee6:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    3ee8:	dc 01       	movw	r26, r24
    3eea:	0d 90       	ld	r0, X+
    3eec:	00 20       	and	r0, r0
    3eee:	e9 f7       	brne	.-6      	; 0x3eea <SumChecksum+0x4>
    3ef0:	11 97       	sbiw	r26, 0x01	; 1
    3ef2:	a8 1b       	sub	r26, r24
    3ef4:	b9 0b       	sbc	r27, r25
    3ef6:	20 e0       	ldi	r18, 0x00	; 0
    3ef8:	30 e0       	ldi	r19, 0x00	; 0
    3efa:	90 e0       	ldi	r25, 0x00	; 0
    3efc:	06 c0       	rjmp	.+12     	; 0x3f0a <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    3efe:	e4 0f       	add	r30, r20
    3f00:	f5 1f       	adc	r31, r21
    3f02:	80 81       	ld	r24, Z
    3f04:	28 0f       	add	r18, r24
    3f06:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    3f08:	9f 5f       	subi	r25, 0xFF	; 255
    3f0a:	e9 2f       	mov	r30, r25
    3f0c:	f0 e0       	ldi	r31, 0x00	; 0
    3f0e:	ea 17       	cp	r30, r26
    3f10:	fb 07       	cpc	r31, r27
    3f12:	a8 f3       	brcs	.-22     	; 0x3efe <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    3f14:	c9 01       	movw	r24, r18
    3f16:	6f ef       	ldi	r22, 0xFF	; 255
    3f18:	70 e0       	ldi	r23, 0x00	; 0
    3f1a:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
	 if (Result==0)Result=255;
    3f1e:	88 23       	and	r24, r24
    3f20:	09 f4       	brne	.+2      	; 0x3f24 <SumChecksum+0x3e>
    3f22:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    3f24:	08 95       	ret

00003f26 <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    3f26:	ff 92       	push	r15
    3f28:	0f 93       	push	r16
    3f2a:	1f 93       	push	r17
    3f2c:	df 93       	push	r29
    3f2e:	cf 93       	push	r28
    3f30:	cd b7       	in	r28, 0x3d	; 61
    3f32:	de b7       	in	r29, 0x3e	; 62
    3f34:	2a 97       	sbiw	r28, 0x0a	; 10
    3f36:	0f b6       	in	r0, 0x3f	; 63
    3f38:	f8 94       	cli
    3f3a:	de bf       	out	0x3e, r29	; 62
    3f3c:	0f be       	out	0x3f, r0	; 63
    3f3e:	cd bf       	out	0x3d, r28	; 61
    3f40:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    3f42:	00 d0       	rcall	.+0      	; 0x3f44 <IsGeniusCommand+0x1e>
    3f44:	00 d0       	rcall	.+0      	; 0x3f46 <IsGeniusCommand+0x20>
    3f46:	8e 01       	movw	r16, r28
    3f48:	0f 5f       	subi	r16, 0xFF	; 255
    3f4a:	1f 4f       	sbci	r17, 0xFF	; 255
    3f4c:	ed b7       	in	r30, 0x3d	; 61
    3f4e:	fe b7       	in	r31, 0x3e	; 62
    3f50:	12 83       	std	Z+2, r17	; 0x02
    3f52:	01 83       	std	Z+1, r16	; 0x01
    3f54:	82 e4       	ldi	r24, 0x42	; 66
    3f56:	93 e0       	ldi	r25, 0x03	; 3
    3f58:	94 83       	std	Z+4, r25	; 0x04
    3f5a:	83 83       	std	Z+3, r24	; 0x03
    3f5c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    3f60:	d8 01       	movw	r26, r16
    3f62:	0d 90       	ld	r0, X+
    3f64:	00 20       	and	r0, r0
    3f66:	e9 f7       	brne	.-6      	; 0x3f62 <IsGeniusCommand+0x3c>
    3f68:	11 97       	sbiw	r26, 0x01	; 1
    3f6a:	a0 1b       	sub	r26, r16
    3f6c:	b1 0b       	sbc	r27, r17
    3f6e:	90 e0       	ldi	r25, 0x00	; 0
    3f70:	0f 90       	pop	r0
    3f72:	0f 90       	pop	r0
    3f74:	0f 90       	pop	r0
    3f76:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    3f78:	98 01       	movw	r18, r16
    3f7a:	08 c0       	rjmp	.+16     	; 0x3f8c <IsGeniusCommand+0x66>
    3f7c:	e2 0f       	add	r30, r18
    3f7e:	f3 1f       	adc	r31, r19
    3f80:	80 81       	ld	r24, Z
    3f82:	8f 15       	cp	r24, r15
    3f84:	11 f4       	brne	.+4      	; 0x3f8a <IsGeniusCommand+0x64>
    3f86:	81 e0       	ldi	r24, 0x01	; 1
    3f88:	07 c0       	rjmp	.+14     	; 0x3f98 <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    3f8a:	9f 5f       	subi	r25, 0xFF	; 255
    3f8c:	e9 2f       	mov	r30, r25
    3f8e:	f0 e0       	ldi	r31, 0x00	; 0
    3f90:	ea 17       	cp	r30, r26
    3f92:	fb 07       	cpc	r31, r27
    3f94:	98 f3       	brcs	.-26     	; 0x3f7c <IsGeniusCommand+0x56>
    3f96:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    3f98:	2a 96       	adiw	r28, 0x0a	; 10
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	de bf       	out	0x3e, r29	; 62
    3fa0:	0f be       	out	0x3f, r0	; 63
    3fa2:	cd bf       	out	0x3d, r28	; 61
    3fa4:	cf 91       	pop	r28
    3fa6:	df 91       	pop	r29
    3fa8:	1f 91       	pop	r17
    3faa:	0f 91       	pop	r16
    3fac:	ff 90       	pop	r15
    3fae:	08 95       	ret

00003fb0 <Pos>:
  */
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    3fb0:	0f 93       	push	r16
    3fb2:	1f 93       	push	r17
    3fb4:	cf 93       	push	r28
    3fb6:	df 93       	push	r29
    3fb8:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    3fba:	fb 01       	movw	r30, r22
    3fbc:	01 90       	ld	r0, Z+
    3fbe:	00 20       	and	r0, r0
    3fc0:	e9 f7       	brne	.-6      	; 0x3fbc <Pos+0xc>
    3fc2:	31 97       	sbiw	r30, 0x01	; 1
    3fc4:	1e 2f       	mov	r17, r30
    3fc6:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    3fc8:	fc 01       	movw	r30, r24
    3fca:	01 90       	ld	r0, Z+
    3fcc:	00 20       	and	r0, r0
    3fce:	e9 f7       	brne	.-6      	; 0x3fca <Pos+0x1a>
    3fd0:	31 97       	sbiw	r30, 0x01	; 1
    3fd2:	0e 2f       	mov	r16, r30
    3fd4:	08 1b       	sub	r16, r24
    3fd6:	db 01       	movw	r26, r22
    3fd8:	60 e0       	ldi	r22, 0x00	; 0
    3fda:	18 c0       	rjmp	.+48     	; 0x400c <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    3fdc:	9c 91       	ld	r25, X
    3fde:	fa 01       	movw	r30, r20
    3fe0:	80 81       	ld	r24, Z
    3fe2:	98 17       	cp	r25, r24
    3fe4:	89 f4       	brne	.+34     	; 0x4008 <Pos+0x58>
    3fe6:	ed 01       	movw	r28, r26
    3fe8:	20 e0       	ldi	r18, 0x00	; 0
    3fea:	30 e0       	ldi	r19, 0x00	; 0
    3fec:	09 c0       	rjmp	.+18     	; 0x4000 <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    3fee:	fa 01       	movw	r30, r20
    3ff0:	e2 0f       	add	r30, r18
    3ff2:	f3 1f       	adc	r31, r19
    3ff4:	90 81       	ld	r25, Z
    3ff6:	89 91       	ld	r24, Y+
    3ff8:	2f 5f       	subi	r18, 0xFF	; 255
    3ffa:	3f 4f       	sbci	r19, 0xFF	; 255
    3ffc:	98 17       	cp	r25, r24
    3ffe:	21 f4       	brne	.+8      	; 0x4008 <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    4000:	20 17       	cp	r18, r16
    4002:	a8 f3       	brcs	.-22     	; 0x3fee <Pos+0x3e>
    4004:	86 2f       	mov	r24, r22
    4006:	05 c0       	rjmp	.+10     	; 0x4012 <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    4008:	6f 5f       	subi	r22, 0xFF	; 255
    400a:	11 96       	adiw	r26, 0x01	; 1
    400c:	61 17       	cp	r22, r17
    400e:	30 f3       	brcs	.-52     	; 0x3fdc <Pos+0x2c>
    4010:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    4012:	90 e0       	ldi	r25, 0x00	; 0
    4014:	df 91       	pop	r29
    4016:	cf 91       	pop	r28
    4018:	1f 91       	pop	r17
    401a:	0f 91       	pop	r16
    401c:	08 95       	ret

0000401e <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    401e:	7f 92       	push	r7
    4020:	8f 92       	push	r8
    4022:	9f 92       	push	r9
    4024:	af 92       	push	r10
    4026:	bf 92       	push	r11
    4028:	cf 92       	push	r12
    402a:	df 92       	push	r13
    402c:	ef 92       	push	r14
    402e:	ff 92       	push	r15
    4030:	0f 93       	push	r16
    4032:	1f 93       	push	r17
    4034:	cf 93       	push	r28
    4036:	df 93       	push	r29
    4038:	5c 01       	movw	r10, r24
    403a:	6b 01       	movw	r12, r22
    403c:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    403e:	ec 01       	movw	r28, r24
    4040:	09 90       	ld	r0, Y+
    4042:	00 20       	and	r0, r0
    4044:	e9 f7       	brne	.-6      	; 0x4040 <CreateReport+0x22>
    4046:	21 97       	sbiw	r28, 0x01	; 1
    4048:	c8 1b       	sub	r28, r24
    404a:	d9 0b       	sbc	r29, r25
    404c:	cb 32       	cpi	r28, 0x2B	; 43
    404e:	d1 05       	cpc	r29, r1
    4050:	10 f0       	brcs	.+4      	; 0x4056 <CreateReport+0x38>
    4052:	ca e2       	ldi	r28, 0x2A	; 42
    4054:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    4056:	f4 01       	movw	r30, r8
    4058:	00 81       	ld	r16, Z
    405a:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    405c:	76 01       	movw	r14, r12
    405e:	e0 0e       	add	r14, r16
    4060:	f1 1e       	adc	r15, r17
    4062:	8a e0       	ldi	r24, 0x0A	; 10
    4064:	0e 94 ef 18 	call	0x31de	; 0x31de <GetBorderValue>
    4068:	78 2e       	mov	r7, r24
    406a:	f7 01       	movw	r30, r14
    406c:	80 83       	st	Z, r24
     iPos++;
    406e:	98 01       	movw	r18, r16
    4070:	2f 5f       	subi	r18, 0xFF	; 255
    4072:	3f 4f       	sbci	r19, 0xFF	; 255
    4074:	d7 01       	movw	r26, r14
    4076:	90 e0       	ldi	r25, 0x00	; 0
    4078:	07 c0       	rjmp	.+14     	; 0x4088 <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    407a:	ea 0d       	add	r30, r10
    407c:	fb 1d       	adc	r31, r11
    407e:	80 81       	ld	r24, Z
    4080:	8c 93       	st	X, r24
		  iPos++;
    4082:	2f 5f       	subi	r18, 0xFF	; 255
    4084:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    4086:	9f 5f       	subi	r25, 0xFF	; 255
    4088:	e9 2f       	mov	r30, r25
    408a:	f0 e0       	ldi	r31, 0x00	; 0
    408c:	11 96       	adiw	r26, 0x01	; 1
    408e:	ec 17       	cp	r30, r28
    4090:	fd 07       	cpc	r31, r29
    4092:	98 f3       	brcs	.-26     	; 0x407a <CreateReport+0x5c>
    4094:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    4096:	ca 32       	cpi	r28, 0x2A	; 42
    4098:	d1 05       	cpc	r29, r1
    409a:	91 f0       	breq	.+36     	; 0x40c0 <CreateReport+0xa2>
    409c:	f6 01       	movw	r30, r12
    409e:	e2 0f       	add	r30, r18
    40a0:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    40a2:	4a e2       	ldi	r20, 0x2A	; 42
    40a4:	50 e0       	ldi	r21, 0x00	; 0
    40a6:	4c 1b       	sub	r20, r28
    40a8:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    40aa:	70 e2       	ldi	r23, 0x20	; 32
    40ac:	03 c0       	rjmp	.+6      	; 0x40b4 <CreateReport+0x96>
    40ae:	71 93       	st	Z+, r23
		      iPos++;
    40b0:	2f 5f       	subi	r18, 0xFF	; 255
    40b2:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    40b4:	82 2f       	mov	r24, r18
    40b6:	86 1b       	sub	r24, r22
    40b8:	90 e0       	ldi	r25, 0x00	; 0
    40ba:	84 17       	cp	r24, r20
    40bc:	95 07       	cpc	r25, r21
    40be:	b8 f3       	brcs	.-18     	; 0x40ae <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    40c0:	f6 01       	movw	r30, r12
    40c2:	e2 0f       	add	r30, r18
    40c4:	f3 1f       	adc	r31, r19
    40c6:	70 82       	st	Z, r7
     iPos++;
    40c8:	c9 01       	movw	r24, r18
    40ca:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    40cc:	c8 0e       	add	r12, r24
    40ce:	d9 1e       	adc	r13, r25
    40d0:	2d e0       	ldi	r18, 0x0D	; 13
    40d2:	f6 01       	movw	r30, r12
    40d4:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    40d6:	01 96       	adiw	r24, 0x01	; 1
    40d8:	f4 01       	movw	r30, r8
    40da:	91 83       	std	Z+1, r25	; 0x01
    40dc:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//uart_print(0,1,strSend);
}
    40de:	df 91       	pop	r29
    40e0:	cf 91       	pop	r28
    40e2:	1f 91       	pop	r17
    40e4:	0f 91       	pop	r16
    40e6:	ff 90       	pop	r15
    40e8:	ef 90       	pop	r14
    40ea:	df 90       	pop	r13
    40ec:	cf 90       	pop	r12
    40ee:	bf 90       	pop	r11
    40f0:	af 90       	pop	r10
    40f2:	9f 90       	pop	r9
    40f4:	8f 90       	pop	r8
    40f6:	7f 90       	pop	r7
    40f8:	08 95       	ret

000040fa <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    40fa:	38 2f       	mov	r19, r24
    40fc:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    40fe:	81 50       	subi	r24, 0x01	; 1
    4100:	86 30       	cpi	r24, 0x06	; 6
    4102:	68 f5       	brcc	.+90     	; 0x415e <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    4104:	fb 01       	movw	r30, r22
    4106:	01 90       	ld	r0, Z+
    4108:	00 20       	and	r0, r0
    410a:	e9 f7       	brne	.-6      	; 0x4106 <AddList+0xc>
    410c:	31 97       	sbiw	r30, 0x01	; 1
    410e:	e6 1b       	sub	r30, r22
    4110:	f7 0b       	sbc	r31, r23
    4112:	7e 2f       	mov	r23, r30
	     if (Length>0){
    4114:	ee 23       	and	r30, r30
    4116:	11 f4       	brne	.+4      	; 0x411c <AddList+0x22>
    4118:	20 e0       	ldi	r18, 0x00	; 0
    411a:	14 c0       	rjmp	.+40     	; 0x4144 <AddList+0x4a>
    411c:	80 e0       	ldi	r24, 0x00	; 0
    411e:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    4120:	63 2f       	mov	r22, r19
    4122:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4124:	fa 01       	movw	r30, r20
    4126:	e8 0f       	add	r30, r24
    4128:	f9 1f       	adc	r31, r25
    412a:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    412c:	3a 30       	cpi	r19, 0x0A	; 10
    412e:	10 f0       	brcs	.+4      	; 0x4134 <AddList+0x3a>
    4130:	20 e3       	ldi	r18, 0x30	; 48
    4132:	01 c0       	rjmp	.+2      	; 0x4136 <AddList+0x3c>
	    Result='0'+X;
    4134:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4136:	e2 17       	cp	r30, r18
    4138:	91 f0       	breq	.+36     	; 0x415e <AddList+0x64>
    413a:	28 2f       	mov	r18, r24
    413c:	2f 5f       	subi	r18, 0xFF	; 255
    413e:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    4140:	87 17       	cp	r24, r23
    4142:	80 f3       	brcs	.-32     	; 0x4124 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4144:	62 2f       	mov	r22, r18
    4146:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4148:	3a 30       	cpi	r19, 0x0A	; 10
    414a:	10 f0       	brcs	.+4      	; 0x4150 <AddList+0x56>
    414c:	80 e3       	ldi	r24, 0x30	; 48
    414e:	02 c0       	rjmp	.+4      	; 0x4154 <AddList+0x5a>
	    Result='0'+X;
    4150:	83 2f       	mov	r24, r19
    4152:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4154:	fa 01       	movw	r30, r20
    4156:	e6 0f       	add	r30, r22
    4158:	f7 1f       	adc	r31, r23
    415a:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    415c:	11 82       	std	Z+1, r1	; 0x01
    415e:	08 95       	ret

00004160 <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    4160:	dc 01       	movw	r26, r24
    4162:	0d 90       	ld	r0, X+
    4164:	00 20       	and	r0, r0
    4166:	e9 f7       	brne	.-6      	; 0x4162 <ClearList+0x2>
    4168:	11 97       	sbiw	r26, 0x01	; 1
    416a:	a8 1b       	sub	r26, r24
    416c:	b9 0b       	sbc	r27, r25
    416e:	20 e0       	ldi	r18, 0x00	; 0
    4170:	30 e0       	ldi	r19, 0x00	; 0
    4172:	06 c0       	rjmp	.+12     	; 0x4180 <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4174:	fc 01       	movw	r30, r24
    4176:	e2 0f       	add	r30, r18
    4178:	f3 1f       	adc	r31, r19
    417a:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    417c:	2f 5f       	subi	r18, 0xFF	; 255
    417e:	3f 4f       	sbci	r19, 0xFF	; 255
    4180:	2a 17       	cp	r18, r26
    4182:	3b 07       	cpc	r19, r27
    4184:	b8 f3       	brcs	.-18     	; 0x4174 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    4186:	08 95       	ret

00004188 <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    4188:	6f 92       	push	r6
    418a:	7f 92       	push	r7
    418c:	8f 92       	push	r8
    418e:	9f 92       	push	r9
    4190:	bf 92       	push	r11
    4192:	cf 92       	push	r12
    4194:	df 92       	push	r13
    4196:	ef 92       	push	r14
    4198:	ff 92       	push	r15
    419a:	0f 93       	push	r16
    419c:	1f 93       	push	r17
    419e:	df 93       	push	r29
    41a0:	cf 93       	push	r28
    41a2:	cd b7       	in	r28, 0x3d	; 61
    41a4:	de b7       	in	r29, 0x3e	; 62
    41a6:	64 97       	sbiw	r28, 0x14	; 20
    41a8:	0f b6       	in	r0, 0x3f	; 63
    41aa:	f8 94       	cli
    41ac:	de bf       	out	0x3e, r29	; 62
    41ae:	0f be       	out	0x3f, r0	; 63
    41b0:	cd bf       	out	0x3d, r28	; 61
    41b2:	7c 01       	movw	r14, r24
    41b4:	6a 01       	movw	r12, r20
    41b6:	bb 24       	eor	r11, r11
    41b8:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    41ba:	06 2f       	mov	r16, r22
    41bc:	10 e0       	ldi	r17, 0x00	; 0
    41be:	00 53       	subi	r16, 0x30	; 48
    41c0:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    41c2:	3e 01       	movw	r6, r28
    41c4:	08 94       	sec
    41c6:	61 1c       	adc	r6, r1
    41c8:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    41ca:	72 e0       	ldi	r23, 0x02	; 2
    41cc:	87 2e       	mov	r8, r23
    41ce:	91 2c       	mov	r9, r1
    41d0:	8c 0e       	add	r8, r28
    41d2:	9d 1e       	adc	r9, r29
    41d4:	24 c0       	rjmp	.+72     	; 0x421e <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    41d6:	11 97       	sbiw	r26, 0x01	; 1
    41d8:	a4 1b       	sub	r26, r20
    41da:	b5 0b       	sbc	r27, r21
    41dc:	ae 0d       	add	r26, r14
    41de:	bf 1d       	adc	r27, r15
    41e0:	8c 91       	ld	r24, X
    41e2:	90 e0       	ldi	r25, 0x00	; 0
    41e4:	c0 97       	sbiw	r24, 0x30	; 48
    41e6:	bc 01       	movw	r22, r24
    41e8:	60 9f       	mul	r22, r16
    41ea:	c0 01       	movw	r24, r0
    41ec:	61 9f       	mul	r22, r17
    41ee:	90 0d       	add	r25, r0
    41f0:	70 9f       	mul	r23, r16
    41f2:	90 0d       	add	r25, r0
    41f4:	11 24       	eor	r1, r1
    41f6:	23 2f       	mov	r18, r19
    41f8:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    41fa:	82 2f       	mov	r24, r18
    41fc:	6a e0       	ldi	r22, 0x0A	; 10
    41fe:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    4202:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    4204:	f3 01       	movw	r30, r6
    4206:	e4 0f       	add	r30, r20
    4208:	f5 1f       	adc	r31, r21
    420a:	82 2f       	mov	r24, r18
    420c:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    4210:	90 5d       	subi	r25, 0xD0	; 208
    4212:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4214:	48 0d       	add	r20, r8
    4216:	59 1d       	adc	r21, r9
    4218:	fa 01       	movw	r30, r20
    421a:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    421c:	b3 94       	inc	r11
    421e:	4b 2d       	mov	r20, r11
    4220:	50 e0       	ldi	r21, 0x00	; 0
    4222:	d7 01       	movw	r26, r14
    4224:	0d 90       	ld	r0, X+
    4226:	00 20       	and	r0, r0
    4228:	e9 f7       	brne	.-6      	; 0x4224 <CalcSegmen+0x9c>
    422a:	11 97       	sbiw	r26, 0x01	; 1
    422c:	ae 19       	sub	r26, r14
    422e:	bf 09       	sbc	r27, r15
    4230:	4a 17       	cp	r20, r26
    4232:	5b 07       	cpc	r21, r27
    4234:	80 f2       	brcs	.-96     	; 0x41d6 <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    4236:	33 23       	and	r19, r19
    4238:	89 f0       	breq	.+34     	; 0x425c <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    423a:	fe 01       	movw	r30, r28
    423c:	31 96       	adiw	r30, 0x01	; 1
    423e:	df 01       	movw	r26, r30
    4240:	0d 90       	ld	r0, X+
    4242:	00 20       	and	r0, r0
    4244:	e9 f7       	brne	.-6      	; 0x4240 <CalcSegmen+0xb8>
    4246:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    4248:	ae 1b       	sub	r26, r30
    424a:	b0 e0       	ldi	r27, 0x00	; 0
    424c:	ea 0f       	add	r30, r26
    424e:	fb 1f       	adc	r31, r27
    4250:	30 5d       	subi	r19, 0xD0	; 208
    4252:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4254:	ac 0f       	add	r26, r28
    4256:	bd 1f       	adc	r27, r29
    4258:	12 96       	adiw	r26, 0x02	; 2
    425a:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    425c:	de 01       	movw	r26, r28
    425e:	11 96       	adiw	r26, 0x01	; 1
    4260:	fd 01       	movw	r30, r26
    4262:	01 90       	ld	r0, Z+
    4264:	00 20       	and	r0, r0
    4266:	e9 f7       	brne	.-6      	; 0x4262 <CalcSegmen+0xda>
    4268:	31 97       	sbiw	r30, 0x01	; 1
    426a:	9e 2f       	mov	r25, r30
    426c:	9a 1b       	sub	r25, r26
    426e:	a9 0f       	add	r26, r25
    4270:	b1 1d       	adc	r27, r1
    4272:	f6 01       	movw	r30, r12
    4274:	02 c0       	rjmp	.+4      	; 0x427a <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    4276:	8c 91       	ld	r24, X
    4278:	81 93       	st	Z+, r24
    427a:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    427c:	ac 17       	cp	r26, r28
    427e:	bd 07       	cpc	r27, r29
    4280:	d1 f7       	brne	.-12     	; 0x4276 <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    4282:	c9 0e       	add	r12, r25
    4284:	d1 1c       	adc	r13, r1
    4286:	f6 01       	movw	r30, r12
    4288:	10 82       	st	Z, r1
}
    428a:	64 96       	adiw	r28, 0x14	; 20
    428c:	0f b6       	in	r0, 0x3f	; 63
    428e:	f8 94       	cli
    4290:	de bf       	out	0x3e, r29	; 62
    4292:	0f be       	out	0x3f, r0	; 63
    4294:	cd bf       	out	0x3d, r28	; 61
    4296:	cf 91       	pop	r28
    4298:	df 91       	pop	r29
    429a:	1f 91       	pop	r17
    429c:	0f 91       	pop	r16
    429e:	ff 90       	pop	r15
    42a0:	ef 90       	pop	r14
    42a2:	df 90       	pop	r13
    42a4:	cf 90       	pop	r12
    42a6:	bf 90       	pop	r11
    42a8:	9f 90       	pop	r9
    42aa:	8f 90       	pop	r8
    42ac:	7f 90       	pop	r7
    42ae:	6f 90       	pop	r6
    42b0:	08 95       	ret

000042b2 <GetMinusPos>:
	      break;	 
	 }
*/
}

char GetMinusPos(char *strNumber){
    42b2:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    42b4:	dc 01       	movw	r26, r24
    42b6:	0d 90       	ld	r0, X+
    42b8:	00 20       	and	r0, r0
    42ba:	e9 f7       	brne	.-6      	; 0x42b6 <GetMinusPos+0x4>
    42bc:	11 97       	sbiw	r26, 0x01	; 1
    42be:	a8 1b       	sub	r26, r24
    42c0:	b9 0b       	sbc	r27, r25
    42c2:	20 e0       	ldi	r18, 0x00	; 0
    42c4:	0a c0       	rjmp	.+20     	; 0x42da <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    42c6:	e4 0f       	add	r30, r20
    42c8:	f5 1f       	adc	r31, r21
    42ca:	80 81       	ld	r24, Z
    42cc:	92 2f       	mov	r25, r18
    42ce:	9f 5f       	subi	r25, 0xFF	; 255
    42d0:	8d 32       	cpi	r24, 0x2D	; 45
    42d2:	11 f4       	brne	.+4      	; 0x42d8 <GetMinusPos+0x26>
		     Result=i+1;
    42d4:	89 2f       	mov	r24, r25
    42d6:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    42d8:	29 2f       	mov	r18, r25
    42da:	e2 2f       	mov	r30, r18
    42dc:	f0 e0       	ldi	r31, 0x00	; 0
    42de:	ea 17       	cp	r30, r26
    42e0:	fb 07       	cpc	r31, r27
    42e2:	88 f3       	brcs	.-30     	; 0x42c6 <GetMinusPos+0x14>
    42e4:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    42e6:	08 95       	ret

000042e8 <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    42e8:	0e 94 59 21 	call	0x42b2	; 0x42b2 <GetMinusPos>
    42ec:	81 11       	cpse	r24, r1
    42ee:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    42f0:	08 95       	ret

000042f2 <RemoveMinus>:

void RemoveMinus(char *strNumber){
    42f2:	cf 93       	push	r28
    42f4:	df 93       	push	r29
    42f6:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    42f8:	0e 94 74 21 	call	0x42e8	; 0x42e8 <IsMinus>
    42fc:	81 30       	cpi	r24, 0x01	; 1
    42fe:	19 f5       	brne	.+70     	; 0x4346 <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    4300:	ce 01       	movw	r24, r28
    4302:	0e 94 59 21 	call	0x42b2	; 0x42b2 <GetMinusPos>
		 Length=strlen(strNumber);
    4306:	de 01       	movw	r26, r28
    4308:	0d 90       	ld	r0, X+
    430a:	00 20       	and	r0, r0
    430c:	e9 f7       	brne	.-6      	; 0x4308 <RemoveMinus+0x16>
    430e:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    4310:	ac 1b       	sub	r26, r28
    4312:	b0 e0       	ldi	r27, 0x00	; 0
    4314:	90 e0       	ldi	r25, 0x00	; 0
    4316:	a8 1b       	sub	r26, r24
    4318:	b9 0b       	sbc	r27, r25
    431a:	ae 01       	movw	r20, r28
    431c:	48 0f       	add	r20, r24
    431e:	59 1f       	adc	r21, r25
    4320:	20 e0       	ldi	r18, 0x00	; 0
    4322:	30 e0       	ldi	r19, 0x00	; 0
    4324:	0a c0       	rjmp	.+20     	; 0x433a <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4326:	be 01       	movw	r22, r28
    4328:	62 0f       	add	r22, r18
    432a:	73 1f       	adc	r23, r19
    432c:	fa 01       	movw	r30, r20
    432e:	81 91       	ld	r24, Z+
    4330:	af 01       	movw	r20, r30
    4332:	fb 01       	movw	r30, r22
    4334:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4336:	2f 5f       	subi	r18, 0xFF	; 255
    4338:	3f 4f       	sbci	r19, 0xFF	; 255
    433a:	2a 17       	cp	r18, r26
    433c:	3b 07       	cpc	r19, r27
    433e:	98 f3       	brcs	.-26     	; 0x4326 <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4340:	ac 0f       	add	r26, r28
    4342:	bd 1f       	adc	r27, r29
    4344:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    4346:	df 91       	pop	r29
    4348:	cf 91       	pop	r28
    434a:	08 95       	ret

0000434c <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    434c:	ac 01       	movw	r20, r24
    434e:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    4350:	fc 01       	movw	r30, r24
    4352:	01 90       	ld	r0, Z+
    4354:	00 20       	and	r0, r0
    4356:	e9 f7       	brne	.-6      	; 0x4352 <IsMoreThan+0x6>
    4358:	31 97       	sbiw	r30, 0x01	; 1
    435a:	7e 2f       	mov	r23, r30
    435c:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    435e:	a6 2f       	mov	r26, r22
    4360:	b2 2f       	mov	r27, r18
    4362:	fd 01       	movw	r30, r26
    4364:	01 90       	ld	r0, Z+
    4366:	00 20       	and	r0, r0
    4368:	e9 f7       	brne	.-6      	; 0x4364 <IsMoreThan+0x18>
    436a:	31 97       	sbiw	r30, 0x01	; 1
    436c:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    436e:	e7 17       	cp	r30, r23
    4370:	48 f1       	brcs	.+82     	; 0x43c4 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    4372:	7e 17       	cp	r23, r30
    4374:	49 f5       	brne	.+82     	; 0x43c8 <IsMoreThan+0x7c>
    4376:	86 2f       	mov	r24, r22
    4378:	92 2f       	mov	r25, r18
    437a:	9c 01       	movw	r18, r24
    437c:	d9 01       	movw	r26, r18
    437e:	20 e0       	ldi	r18, 0x00	; 0
    4380:	30 e0       	ldi	r19, 0x00	; 0
    4382:	1d c0       	rjmp	.+58     	; 0x43be <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4384:	fa 01       	movw	r30, r20
    4386:	e2 0f       	add	r30, r18
    4388:	f3 1f       	adc	r31, r19
    438a:	e0 81       	ld	r30, Z
    438c:	e0 53       	subi	r30, 0x30	; 48
    438e:	ea 30       	cpi	r30, 0x0A	; 10
    4390:	10 f0       	brcs	.+4      	; 0x4396 <IsMoreThan+0x4a>
    4392:	60 e0       	ldi	r22, 0x00	; 0
    4394:	01 c0       	rjmp	.+2      	; 0x4398 <IsMoreThan+0x4c>
    4396:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    4398:	8c 91       	ld	r24, X
    439a:	80 53       	subi	r24, 0x30	; 48
    439c:	8a 30       	cpi	r24, 0x0A	; 10
    439e:	10 f0       	brcs	.+4      	; 0x43a4 <IsMoreThan+0x58>
    43a0:	90 e0       	ldi	r25, 0x00	; 0
    43a2:	01 c0       	rjmp	.+2      	; 0x43a6 <IsMoreThan+0x5a>
    43a4:	98 2f       	mov	r25, r24
    43a6:	96 17       	cp	r25, r22
    43a8:	68 f0       	brcs	.+26     	; 0x43c4 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    43aa:	ea 30       	cpi	r30, 0x0A	; 10
    43ac:	08 f0       	brcs	.+2      	; 0x43b0 <IsMoreThan+0x64>
    43ae:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    43b0:	8a 30       	cpi	r24, 0x0A	; 10
    43b2:	10 f4       	brcc	.+4      	; 0x43b8 <IsMoreThan+0x6c>
    43b4:	e8 17       	cp	r30, r24
    43b6:	40 f0       	brcs	.+16     	; 0x43c8 <IsMoreThan+0x7c>
    43b8:	2f 5f       	subi	r18, 0xFF	; 255
    43ba:	3f 4f       	sbci	r19, 0xFF	; 255
    43bc:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    43be:	27 17       	cp	r18, r23
    43c0:	08 f3       	brcs	.-62     	; 0x4384 <IsMoreThan+0x38>
    43c2:	02 c0       	rjmp	.+4      	; 0x43c8 <IsMoreThan+0x7c>
    43c4:	81 e0       	ldi	r24, 0x01	; 1
    43c6:	08 95       	ret
    43c8:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    43ca:	08 95       	ret

000043cc <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    43cc:	fc 01       	movw	r30, r24
    43ce:	01 90       	ld	r0, Z+
    43d0:	00 20       	and	r0, r0
    43d2:	e9 f7       	brne	.-6      	; 0x43ce <IsZerroAll+0x2>
    43d4:	31 97       	sbiw	r30, 0x01	; 1
    43d6:	e8 1b       	sub	r30, r24
    43d8:	dc 01       	movw	r26, r24
    43da:	ae 0f       	add	r26, r30
    43dc:	b1 1d       	adc	r27, r1
    43de:	90 e0       	ldi	r25, 0x00	; 0
    43e0:	20 e0       	ldi	r18, 0x00	; 0
    43e2:	06 c0       	rjmp	.+12     	; 0x43f0 <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    43e4:	8c 91       	ld	r24, X
    43e6:	80 33       	cpi	r24, 0x30	; 48
    43e8:	09 f4       	brne	.+2      	; 0x43ec <IsZerroAll+0x20>
    43ea:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    43ec:	9f 5f       	subi	r25, 0xFF	; 255
    43ee:	11 97       	sbiw	r26, 0x01	; 1
    43f0:	9e 17       	cp	r25, r30
    43f2:	c0 f3       	brcs	.-16     	; 0x43e4 <IsZerroAll+0x18>
    43f4:	80 e0       	ldi	r24, 0x00	; 0
    43f6:	2e 17       	cp	r18, r30
    43f8:	09 f4       	brne	.+2      	; 0x43fc <IsZerroAll+0x30>
    43fa:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    43fc:	08 95       	ret

000043fe <PstrCopy>:
void CarriegeReturn(){
     uart(_COM_PRINTER, 1, 0x0D);     
     uart(_COM_PRINTER, 1, 0x0A);
}

void PstrCopy(char *Dest,char *Source){
    43fe:	cf 93       	push	r28
    4400:	df 93       	push	r29
    4402:	20 e0       	ldi	r18, 0x00	; 0
    4404:	08 c0       	rjmp	.+16     	; 0x4416 <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    4406:	fb 01       	movw	r30, r22
    4408:	ec 0f       	add	r30, r28
    440a:	fd 1f       	adc	r31, r29
    440c:	e4 91       	lpm	r30, Z+
    440e:	c8 0f       	add	r28, r24
    4410:	d9 1f       	adc	r29, r25
    4412:	e8 83       	st	Y, r30
     uart(_COM_PRINTER, 1, 0x0A);
}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4414:	2f 5f       	subi	r18, 0xFF	; 255
    4416:	c2 2f       	mov	r28, r18
    4418:	d0 e0       	ldi	r29, 0x00	; 0
    441a:	fb 01       	movw	r30, r22
    441c:	01 90       	ld	r0, Z+
    441e:	00 20       	and	r0, r0
    4420:	e9 f7       	brne	.-6      	; 0x441c <PstrCopy+0x1e>
    4422:	31 97       	sbiw	r30, 0x01	; 1
    4424:	e6 1b       	sub	r30, r22
    4426:	f7 0b       	sbc	r31, r23
    4428:	ce 17       	cp	r28, r30
    442a:	df 07       	cpc	r29, r31
    442c:	60 f3       	brcs	.-40     	; 0x4406 <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    442e:	df 91       	pop	r29
    4430:	cf 91       	pop	r28
    4432:	08 95       	ret

00004434 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4434:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4436:	dc 01       	movw	r26, r24
    4438:	0d 90       	ld	r0, X+
    443a:	00 20       	and	r0, r0
    443c:	e9 f7       	brne	.-6      	; 0x4438 <SpaceOnly+0x4>
    443e:	11 97       	sbiw	r26, 0x01	; 1
    4440:	a8 1b       	sub	r26, r24
    4442:	b9 0b       	sbc	r27, r25
    4444:	90 e0       	ldi	r25, 0x00	; 0
    4446:	20 e0       	ldi	r18, 0x00	; 0
    4448:	30 e0       	ldi	r19, 0x00	; 0
    444a:	09 c0       	rjmp	.+18     	; 0x445e <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    444c:	fa 01       	movw	r30, r20
    444e:	e2 0f       	add	r30, r18
    4450:	f3 1f       	adc	r31, r19
    4452:	80 81       	ld	r24, Z
    4454:	80 32       	cpi	r24, 0x20	; 32
    4456:	09 f0       	breq	.+2      	; 0x445a <SpaceOnly+0x26>
    4458:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    445a:	2f 5f       	subi	r18, 0xFF	; 255
    445c:	3f 4f       	sbci	r19, 0xFF	; 255
    445e:	2a 17       	cp	r18, r26
    4460:	3b 07       	cpc	r19, r27
    4462:	a0 f3       	brcs	.-24     	; 0x444c <SpaceOnly+0x18>
    4464:	80 e0       	ldi	r24, 0x00	; 0
    4466:	99 23       	and	r25, r25
    4468:	09 f4       	brne	.+2      	; 0x446c <SpaceOnly+0x38>
    446a:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    446c:	08 95       	ret

0000446e <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    446e:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    4470:	e1 99       	sbic	0x1c, 1	; 28
    4472:	fe cf       	rjmp	.-4      	; 0x4470 <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4474:	8e e3       	ldi	r24, 0x3E	; 62
    4476:	90 e0       	ldi	r25, 0x00	; 0
    4478:	9f bb       	out	0x1f, r25	; 31
    447a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    447c:	e0 9a       	sbi	0x1c, 0	; 28
    447e:	5d b3       	in	r21, 0x1d	; 29
    4480:	40 e0       	ldi	r20, 0x00	; 0
    4482:	08 c0       	rjmp	.+16     	; 0x4494 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    4484:	f9 01       	movw	r30, r18
    4486:	e8 0f       	add	r30, r24
    4488:	f9 1f       	adc	r31, r25
    448a:	80 81       	ld	r24, Z
    448c:	85 17       	cp	r24, r21
    448e:	09 f4       	brne	.+2      	; 0x4492 <RemDecimal+0x24>
		     strDecimal[i]=0;
    4490:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    4492:	4f 5f       	subi	r20, 0xFF	; 255
    4494:	84 2f       	mov	r24, r20
    4496:	90 e0       	ldi	r25, 0x00	; 0
    4498:	f9 01       	movw	r30, r18
    449a:	01 90       	ld	r0, Z+
    449c:	00 20       	and	r0, r0
    449e:	e9 f7       	brne	.-6      	; 0x449a <RemDecimal+0x2c>
    44a0:	31 97       	sbiw	r30, 0x01	; 1
    44a2:	e2 1b       	sub	r30, r18
    44a4:	f3 0b       	sbc	r31, r19
    44a6:	8e 17       	cp	r24, r30
    44a8:	9f 07       	cpc	r25, r31
    44aa:	60 f3       	brcs	.-40     	; 0x4484 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    44ac:	08 95       	ret

000044ae <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    44ae:	cf 92       	push	r12
    44b0:	df 92       	push	r13
    44b2:	ef 92       	push	r14
    44b4:	ff 92       	push	r15
    44b6:	0f 93       	push	r16
    44b8:	1f 93       	push	r17
    44ba:	df 93       	push	r29
    44bc:	cf 93       	push	r28
    44be:	cd b7       	in	r28, 0x3d	; 61
    44c0:	de b7       	in	r29, 0x3e	; 62
    44c2:	67 97       	sbiw	r28, 0x17	; 23
    44c4:	0f b6       	in	r0, 0x3f	; 63
    44c6:	f8 94       	cli
    44c8:	de bf       	out	0x3e, r29	; 62
    44ca:	0f be       	out	0x3f, r0	; 63
    44cc:	cd bf       	out	0x3d, r28	; 61
    44ce:	7c 01       	movw	r14, r24
    44d0:	d6 2e       	mov	r13, r22
    44d2:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    44d4:	00 d0       	rcall	.+0      	; 0x44d6 <GetProductPrice+0x28>
    44d6:	00 d0       	rcall	.+0      	; 0x44d8 <GetProductPrice+0x2a>
    44d8:	ad b7       	in	r26, 0x3d	; 61
    44da:	be b7       	in	r27, 0x3e	; 62
    44dc:	12 96       	adiw	r26, 0x02	; 2
    44de:	9c 93       	st	X, r25
    44e0:	8e 93       	st	-X, r24
    44e2:	11 97       	sbiw	r26, 0x01	; 1
    44e4:	81 e5       	ldi	r24, 0x51	; 81
    44e6:	93 e0       	ldi	r25, 0x03	; 3
    44e8:	14 96       	adiw	r26, 0x04	; 4
    44ea:	9c 93       	st	X, r25
    44ec:	8e 93       	st	-X, r24
    44ee:	13 97       	sbiw	r26, 0x03	; 3
    44f0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    44f4:	0f 90       	pop	r0
    44f6:	0f 90       	pop	r0
    44f8:	0f 90       	pop	r0
    44fa:	0f 90       	pop	r0
    44fc:	8e 01       	movw	r16, r28
    44fe:	09 5f       	subi	r16, 0xF9	; 249
    4500:	1f 4f       	sbci	r17, 0xFF	; 255
    4502:	c8 01       	movw	r24, r16
    4504:	65 e4       	ldi	r22, 0x45	; 69
    4506:	70 e0       	ldi	r23, 0x00	; 0
    4508:	48 e0       	ldi	r20, 0x08	; 8
    450a:	50 e0       	ldi	r21, 0x00	; 0
    450c:	24 e4       	ldi	r18, 0x44	; 68
    450e:	32 e1       	ldi	r19, 0x12	; 18
    4510:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    4514:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4516:	9e 01       	movw	r18, r28
    4518:	21 5f       	subi	r18, 0xF1	; 241
    451a:	3f 4f       	sbci	r19, 0xFF	; 255
    451c:	9e 2f       	mov	r25, r30
    451e:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    4520:	80 81       	ld	r24, Z
    4522:	8d 15       	cp	r24, r13
    4524:	11 f4       	brne	.+4      	; 0x452a <GetProductPrice+0x7c>
    4526:	89 2f       	mov	r24, r25
    4528:	05 c0       	rjmp	.+10     	; 0x4534 <GetProductPrice+0x86>
    452a:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    452c:	e2 17       	cp	r30, r18
    452e:	f3 07       	cpc	r31, r19
    4530:	a9 f7       	brne	.-22     	; 0x451c <GetProductPrice+0x6e>
    4532:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4534:	b5 e0       	ldi	r27, 0x05	; 5
    4536:	bc 15       	cp	r27, r12
    4538:	08 f4       	brcc	.+2      	; 0x453c <GetProductPrice+0x8e>
    453a:	41 c0       	rjmp	.+130    	; 0x45be <GetProductPrice+0x110>
    453c:	66 e0       	ldi	r22, 0x06	; 6
    453e:	86 9f       	mul	r24, r22
    4540:	b0 01       	movw	r22, r0
    4542:	11 24       	eor	r1, r1
    4544:	6b 5a       	subi	r22, 0xAB	; 171
    4546:	7f 4f       	sbci	r23, 0xFF	; 255
    4548:	ce 01       	movw	r24, r28
    454a:	01 96       	adiw	r24, 0x01	; 1
    454c:	46 e0       	ldi	r20, 0x06	; 6
    454e:	50 e0       	ldi	r21, 0x00	; 0
    4550:	24 e4       	ldi	r18, 0x44	; 68
    4552:	32 e1       	ldi	r19, 0x12	; 18
    4554:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    4558:	8e 01       	movw	r16, r28
    455a:	01 5f       	subi	r16, 0xF1	; 241
    455c:	1f 4f       	sbci	r17, 0xFF	; 255
    455e:	fe 01       	movw	r30, r28
    4560:	ec 0d       	add	r30, r12
    4562:	f1 1d       	adc	r31, r1
    4564:	60 81       	ld	r22, Z
    4566:	89 e0       	ldi	r24, 0x09	; 9
    4568:	68 9f       	mul	r22, r24
    456a:	b0 01       	movw	r22, r0
    456c:	11 24       	eor	r1, r1
    456e:	64 58       	subi	r22, 0x84	; 132
    4570:	7f 4f       	sbci	r23, 0xFF	; 255
    4572:	c8 01       	movw	r24, r16
    4574:	49 e0       	ldi	r20, 0x09	; 9
    4576:	50 e0       	ldi	r21, 0x00	; 0
    4578:	24 e4       	ldi	r18, 0x44	; 68
    457a:	32 e1       	ldi	r19, 0x12	; 18
    457c:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    4580:	c8 01       	movw	r24, r16
    4582:	0e 94 37 22 	call	0x446e	; 0x446e <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    4586:	00 d0       	rcall	.+0      	; 0x4588 <GetProductPrice+0xda>
    4588:	00 d0       	rcall	.+0      	; 0x458a <GetProductPrice+0xdc>
    458a:	00 d0       	rcall	.+0      	; 0x458c <GetProductPrice+0xde>
    458c:	ed b7       	in	r30, 0x3d	; 61
    458e:	fe b7       	in	r31, 0x3e	; 62
    4590:	31 96       	adiw	r30, 0x01	; 1
    4592:	ad b7       	in	r26, 0x3d	; 61
    4594:	be b7       	in	r27, 0x3e	; 62
    4596:	12 96       	adiw	r26, 0x02	; 2
    4598:	fc 92       	st	X, r15
    459a:	ee 92       	st	-X, r14
    459c:	11 97       	sbiw	r26, 0x01	; 1
    459e:	8e e4       	ldi	r24, 0x4E	; 78
    45a0:	93 e0       	ldi	r25, 0x03	; 3
    45a2:	93 83       	std	Z+3, r25	; 0x03
    45a4:	82 83       	std	Z+2, r24	; 0x02
    45a6:	15 83       	std	Z+5, r17	; 0x05
    45a8:	04 83       	std	Z+4, r16	; 0x04
    45aa:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    45ae:	ed b7       	in	r30, 0x3d	; 61
    45b0:	fe b7       	in	r31, 0x3e	; 62
    45b2:	36 96       	adiw	r30, 0x06	; 6
    45b4:	0f b6       	in	r0, 0x3f	; 63
    45b6:	f8 94       	cli
    45b8:	fe bf       	out	0x3e, r31	; 62
    45ba:	0f be       	out	0x3f, r0	; 63
    45bc:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    45be:	67 96       	adiw	r28, 0x17	; 23
    45c0:	0f b6       	in	r0, 0x3f	; 63
    45c2:	f8 94       	cli
    45c4:	de bf       	out	0x3e, r29	; 62
    45c6:	0f be       	out	0x3f, r0	; 63
    45c8:	cd bf       	out	0x3d, r28	; 61
    45ca:	cf 91       	pop	r28
    45cc:	df 91       	pop	r29
    45ce:	1f 91       	pop	r17
    45d0:	0f 91       	pop	r16
    45d2:	ff 90       	pop	r15
    45d4:	ef 90       	pop	r14
    45d6:	df 90       	pop	r13
    45d8:	cf 90       	pop	r12
    45da:	08 95       	ret

000045dc <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    45dc:	df 93       	push	r29
    45de:	cf 93       	push	r28
    45e0:	cd b7       	in	r28, 0x3d	; 61
    45e2:	de b7       	in	r29, 0x3e	; 62
    45e4:	2b 97       	sbiw	r28, 0x0b	; 11
    45e6:	0f b6       	in	r0, 0x3f	; 63
    45e8:	f8 94       	cli
    45ea:	de bf       	out	0x3e, r29	; 62
    45ec:	0f be       	out	0x3f, r0	; 63
    45ee:	cd bf       	out	0x3d, r28	; 61
    45f0:	98 2f       	mov	r25, r24
    45f2:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    45f4:	fb 01       	movw	r30, r22
    45f6:	80 85       	ldd	r24, Z+8	; 0x08
    45f8:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    45fa:	81 85       	ldd	r24, Z+9	; 0x09
    45fc:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    45fe:	87 81       	ldd	r24, Z+7	; 0x07
    4600:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    4602:	85 81       	ldd	r24, Z+5	; 0x05
    4604:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    4606:	86 81       	ldd	r24, Z+6	; 0x06
    4608:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    460a:	84 81       	ldd	r24, Z+4	; 0x04
    460c:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    460e:	99 23       	and	r25, r25
    4610:	19 f0       	breq	.+6      	; 0x4618 <FormatDate+0x3c>
    4612:	91 30       	cpi	r25, 0x01	; 1
    4614:	59 f4       	brne	.+22     	; 0x462c <FormatDate+0x50>
    4616:	0f c0       	rjmp	.+30     	; 0x4636 <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    4618:	fb 01       	movw	r30, r22
    461a:	80 81       	ld	r24, Z
    461c:	8f 83       	std	Y+7, r24	; 0x07
    461e:	81 81       	ldd	r24, Z+1	; 0x01
    4620:	88 87       	std	Y+8, r24	; 0x08
    4622:	82 81       	ldd	r24, Z+2	; 0x02
    4624:	89 87       	std	Y+9, r24	; 0x09
    4626:	83 81       	ldd	r24, Z+3	; 0x03
    4628:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    462a:	1b 86       	std	Y+11, r1	; 0x0b
    462c:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    462e:	ae 01       	movw	r20, r28
    4630:	4f 5f       	subi	r20, 0xFF	; 255
    4632:	5f 4f       	sbci	r21, 0xFF	; 255
    4634:	0f c0       	rjmp	.+30     	; 0x4654 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    4636:	fb 01       	movw	r30, r22
    4638:	82 81       	ldd	r24, Z+2	; 0x02
    463a:	8f 83       	std	Y+7, r24	; 0x07
    463c:	83 81       	ldd	r24, Z+3	; 0x03
    463e:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    4640:	19 86       	std	Y+9, r1	; 0x09
    4642:	f4 cf       	rjmp	.-24     	; 0x462c <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4644:	f9 01       	movw	r30, r18
    4646:	ea 0f       	add	r30, r26
    4648:	fb 1f       	adc	r31, r27
    464a:	a4 0f       	add	r26, r20
    464c:	b5 1f       	adc	r27, r21
    464e:	8c 91       	ld	r24, X
    4650:	80 83       	st	Z, r24
    4652:	9f 5f       	subi	r25, 0xFF	; 255
    4654:	a9 2f       	mov	r26, r25
    4656:	b0 e0       	ldi	r27, 0x00	; 0
    4658:	fa 01       	movw	r30, r20
    465a:	01 90       	ld	r0, Z+
    465c:	00 20       	and	r0, r0
    465e:	e9 f7       	brne	.-6      	; 0x465a <FormatDate+0x7e>
    4660:	31 97       	sbiw	r30, 0x01	; 1
    4662:	e4 1b       	sub	r30, r20
    4664:	f5 0b       	sbc	r31, r21
    4666:	ae 17       	cp	r26, r30
    4668:	bf 07       	cpc	r27, r31
    466a:	60 f3       	brcs	.-40     	; 0x4644 <FormatDate+0x68>
}
    466c:	2b 96       	adiw	r28, 0x0b	; 11
    466e:	0f b6       	in	r0, 0x3f	; 63
    4670:	f8 94       	cli
    4672:	de bf       	out	0x3e, r29	; 62
    4674:	0f be       	out	0x3f, r0	; 63
    4676:	cd bf       	out	0x3d, r28	; 61
    4678:	cf 91       	pop	r28
    467a:	df 91       	pop	r29
    467c:	08 95       	ret

0000467e <RemZeroLead>:

	while (1){};
  #endif
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    467e:	cf 93       	push	r28
    4680:	df 93       	push	r29
    4682:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    4684:	fc 01       	movw	r30, r24
    4686:	01 90       	ld	r0, Z+
    4688:	00 20       	and	r0, r0
    468a:	e9 f7       	brne	.-6      	; 0x4686 <RemZeroLead+0x8>
    468c:	31 97       	sbiw	r30, 0x01	; 1
    468e:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    4690:	e2 30       	cpi	r30, 0x02	; 2
    4692:	d0 f1       	brcs	.+116    	; 0x4708 <RemZeroLead+0x8a>
    4694:	88 81       	ld	r24, Y
    4696:	80 33       	cpi	r24, 0x30	; 48
    4698:	b9 f5       	brne	.+110    	; 0x4708 <RemZeroLead+0x8a>
    469a:	4c 2f       	mov	r20, r28
    469c:	de 01       	movw	r26, r28
    469e:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    46a0:	8c 91       	ld	r24, X
    46a2:	80 33       	cpi	r24, 0x30	; 48
    46a4:	69 f4       	brne	.+26     	; 0x46c0 <RemZeroLead+0x42>
    46a6:	11 96       	adiw	r26, 0x01	; 1
    46a8:	8c 91       	ld	r24, X
    46aa:	11 97       	sbiw	r26, 0x01	; 1
    46ac:	80 33       	cpi	r24, 0x30	; 48
    46ae:	11 f4       	brne	.+4      	; 0x46b4 <RemZeroLead+0x36>
    46b0:	9f 5f       	subi	r25, 0xFF	; 255
    46b2:	06 c0       	rjmp	.+12     	; 0x46c0 <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    46b4:	8e 32       	cpi	r24, 0x2E	; 46
    46b6:	11 f0       	breq	.+4      	; 0x46bc <RemZeroLead+0x3e>
    46b8:	8c 32       	cpi	r24, 0x2C	; 44
    46ba:	41 f4       	brne	.+16     	; 0x46cc <RemZeroLead+0x4e>
    46bc:	91 50       	subi	r25, 0x01	; 1
    46be:	06 c0       	rjmp	.+12     	; 0x46cc <RemZeroLead+0x4e>
    46c0:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    46c2:	8a 2f       	mov	r24, r26
    46c4:	84 1b       	sub	r24, r20
    46c6:	8e 17       	cp	r24, r30
    46c8:	58 f3       	brcs	.-42     	; 0x46a0 <RemZeroLead+0x22>
    46ca:	01 c0       	rjmp	.+2      	; 0x46ce <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    46cc:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    46ce:	9e 17       	cp	r25, r30
    46d0:	10 f0       	brcs	.+4      	; 0x46d6 <RemZeroLead+0x58>
    46d2:	9e 2f       	mov	r25, r30
    46d4:	91 50       	subi	r25, 0x01	; 1
    46d6:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    46d8:	89 2f       	mov	r24, r25
    46da:	90 e0       	ldi	r25, 0x00	; 0
    46dc:	2e 2f       	mov	r18, r30
    46de:	30 e0       	ldi	r19, 0x00	; 0
    46e0:	28 1b       	sub	r18, r24
    46e2:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    46e4:	be 01       	movw	r22, r28
    46e6:	68 0f       	add	r22, r24
    46e8:	79 1f       	adc	r23, r25
    46ea:	09 c0       	rjmp	.+18     	; 0x46fe <RemZeroLead+0x80>
    46ec:	fe 01       	movw	r30, r28
    46ee:	ea 0f       	add	r30, r26
    46f0:	fb 1f       	adc	r31, r27
    46f2:	a6 0f       	add	r26, r22
    46f4:	b7 1f       	adc	r27, r23
    46f6:	8c 91       	ld	r24, X
    46f8:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    46fa:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    46fc:	4f 5f       	subi	r20, 0xFF	; 255
    46fe:	a4 2f       	mov	r26, r20
    4700:	b0 e0       	ldi	r27, 0x00	; 0
    4702:	a2 17       	cp	r26, r18
    4704:	b3 07       	cpc	r27, r19
    4706:	94 f3       	brlt	.-28     	; 0x46ec <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    4708:	df 91       	pop	r29
    470a:	cf 91       	pop	r28
    470c:	08 95       	ret

0000470e <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    470e:	cf 93       	push	r28
    4710:	df 93       	push	r29
    4712:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    4714:	fc 01       	movw	r30, r24
    4716:	01 90       	ld	r0, Z+
    4718:	00 20       	and	r0, r0
    471a:	e9 f7       	brne	.-6      	; 0x4716 <RemSpaceLead+0x8>
    471c:	31 97       	sbiw	r30, 0x01	; 1
    471e:	6e 2f       	mov	r22, r30
    4720:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    4722:	62 30       	cpi	r22, 0x02	; 2
    4724:	e0 f1       	brcs	.+120    	; 0x479e <RemSpaceLead+0x90>
    4726:	88 81       	ld	r24, Y
    4728:	80 32       	cpi	r24, 0x20	; 32
    472a:	c9 f5       	brne	.+114    	; 0x479e <RemSpaceLead+0x90>
    472c:	4c 2f       	mov	r20, r28
    472e:	fe 01       	movw	r30, r28
    4730:	90 e0       	ldi	r25, 0x00	; 0
    4732:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    4734:	80 81       	ld	r24, Z
    4736:	80 32       	cpi	r24, 0x20	; 32
    4738:	41 f4       	brne	.+16     	; 0x474a <RemSpaceLead+0x3c>
    473a:	81 81       	ldd	r24, Z+1	; 0x01
    473c:	80 32       	cpi	r24, 0x20	; 32
    473e:	21 f4       	brne	.+8      	; 0x4748 <RemSpaceLead+0x3a>
    4740:	22 23       	and	r18, r18
    4742:	19 f4       	brne	.+6      	; 0x474a <RemSpaceLead+0x3c>
    4744:	9f 5f       	subi	r25, 0xFF	; 255
    4746:	01 c0       	rjmp	.+2      	; 0x474a <RemSpaceLead+0x3c>
    4748:	21 e0       	ldi	r18, 0x01	; 1
    474a:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    474c:	8e 2f       	mov	r24, r30
    474e:	84 1b       	sub	r24, r20
    4750:	86 17       	cp	r24, r22
    4752:	80 f3       	brcs	.-32     	; 0x4734 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    4754:	39 2f       	mov	r19, r25
    4756:	3f 5f       	subi	r19, 0xFF	; 255
    4758:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    475a:	43 2f       	mov	r20, r19
    475c:	50 e0       	ldi	r21, 0x00	; 0
    475e:	09 c0       	rjmp	.+18     	; 0x4772 <RemSpaceLead+0x64>
    4760:	fe 01       	movw	r30, r28
    4762:	e8 0f       	add	r30, r24
    4764:	f9 1f       	adc	r31, r25
    4766:	df 01       	movw	r26, r30
    4768:	a4 0f       	add	r26, r20
    476a:	b5 1f       	adc	r27, r21
    476c:	8c 91       	ld	r24, X
    476e:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    4770:	2f 5f       	subi	r18, 0xFF	; 255
    4772:	82 2f       	mov	r24, r18
    4774:	90 e0       	ldi	r25, 0x00	; 0
    4776:	fe 01       	movw	r30, r28
    4778:	01 90       	ld	r0, Z+
    477a:	00 20       	and	r0, r0
    477c:	e9 f7       	brne	.-6      	; 0x4778 <RemSpaceLead+0x6a>
    477e:	31 97       	sbiw	r30, 0x01	; 1
    4780:	ec 1b       	sub	r30, r28
    4782:	fd 0b       	sbc	r31, r29
    4784:	8e 17       	cp	r24, r30
    4786:	9f 07       	cpc	r25, r31
    4788:	58 f3       	brcs	.-42     	; 0x4760 <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    478a:	86 2f       	mov	r24, r22
    478c:	83 1b       	sub	r24, r19
    478e:	05 c0       	rjmp	.+10     	; 0x479a <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    4790:	fe 01       	movw	r30, r28
    4792:	e8 0f       	add	r30, r24
    4794:	f1 1d       	adc	r31, r1
    4796:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4798:	8f 5f       	subi	r24, 0xFF	; 255
    479a:	86 17       	cp	r24, r22
    479c:	c8 f3       	brcs	.-14     	; 0x4790 <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    479e:	df 91       	pop	r29
    47a0:	cf 91       	pop	r28
    47a2:	08 95       	ret

000047a4 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    47a4:	0f 93       	push	r16
    47a6:	1f 93       	push	r17
    47a8:	cf 93       	push	r28
    47aa:	df 93       	push	r29
    47ac:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    47ae:	dc 01       	movw	r26, r24
    47b0:	0d 90       	ld	r0, X+
    47b2:	00 20       	and	r0, r0
    47b4:	e9 f7       	brne	.-6      	; 0x47b0 <RemSpaceLag+0xc>
    47b6:	11 97       	sbiw	r26, 0x01	; 1
    47b8:	a8 1b       	sub	r26, r24
    47ba:	b0 e0       	ldi	r27, 0x00	; 0
    47bc:	20 e0       	ldi	r18, 0x00	; 0
    47be:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    47c0:	6a 2f       	mov	r22, r26
    47c2:	70 e0       	ldi	r23, 0x00	; 0
    47c4:	8b 01       	movw	r16, r22
    47c6:	01 50       	subi	r16, 0x01	; 1
    47c8:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    47ca:	a1 50       	subi	r26, 0x01	; 1
    47cc:	16 c0       	rjmp	.+44     	; 0x47fa <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    47ce:	ab 01       	movw	r20, r22
    47d0:	48 1b       	sub	r20, r24
    47d2:	59 0b       	sbc	r21, r25
    47d4:	fe 01       	movw	r30, r28
    47d6:	e4 0f       	add	r30, r20
    47d8:	f5 1f       	adc	r31, r21
    47da:	32 97       	sbiw	r30, 0x02	; 2
    47dc:	80 81       	ld	r24, Z
    47de:	80 32       	cpi	r24, 0x20	; 32
    47e0:	89 f4       	brne	.+34     	; 0x4804 <RemSpaceLag+0x60>
    47e2:	fa 01       	movw	r30, r20
    47e4:	31 97       	sbiw	r30, 0x01	; 1
    47e6:	ec 0f       	add	r30, r28
    47e8:	fd 1f       	adc	r31, r29
    47ea:	2f 5f       	subi	r18, 0xFF	; 255
    47ec:	3f 4f       	sbci	r19, 0xFF	; 255
    47ee:	80 81       	ld	r24, Z
    47f0:	80 32       	cpi	r24, 0x20	; 32
    47f2:	41 f4       	brne	.+16     	; 0x4804 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    47f4:	10 82       	st	Z, r1
    47f6:	ba 2f       	mov	r27, r26
    47f8:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    47fa:	82 2f       	mov	r24, r18
    47fc:	90 e0       	ldi	r25, 0x00	; 0
    47fe:	80 17       	cp	r24, r16
    4800:	91 07       	cpc	r25, r17
    4802:	2c f3       	brlt	.-54     	; 0x47ce <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    4804:	fe 01       	movw	r30, r28
    4806:	eb 0f       	add	r30, r27
    4808:	f1 1d       	adc	r31, r1
    480a:	80 81       	ld	r24, Z
    480c:	80 32       	cpi	r24, 0x20	; 32
    480e:	09 f4       	brne	.+2      	; 0x4812 <RemSpaceLag+0x6e>
    4810:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    4812:	88 81       	ld	r24, Y
    4814:	80 32       	cpi	r24, 0x20	; 32
    4816:	09 f4       	brne	.+2      	; 0x481a <RemSpaceLag+0x76>
    4818:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    481a:	fe 01       	movw	r30, r28
    481c:	01 90       	ld	r0, Z+
    481e:	00 20       	and	r0, r0
    4820:	e9 f7       	brne	.-6      	; 0x481c <RemSpaceLag+0x78>
    4822:	31 97       	sbiw	r30, 0x01	; 1
    4824:	ec 1b       	sub	r30, r28
    4826:	fd 0b       	sbc	r31, r29
    4828:	ec 0f       	add	r30, r28
    482a:	fd 1f       	adc	r31, r29
    482c:	10 82       	st	Z, r1
}
    482e:	df 91       	pop	r29
    4830:	cf 91       	pop	r28
    4832:	1f 91       	pop	r17
    4834:	0f 91       	pop	r16
    4836:	08 95       	ret

00004838 <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    4838:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    483a:	10 91 56 09 	lds	r17, 0x0956
    483e:	20 e0       	ldi	r18, 0x00	; 0
    4840:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4842:	f9 01       	movw	r30, r18
    4844:	e3 5e       	subi	r30, 0xE3	; 227
    4846:	f6 4f       	sbci	r31, 0xF6	; 246
    4848:	d9 01       	movw	r26, r18
    484a:	a7 57       	subi	r26, 0x77	; 119
    484c:	b4 4f       	sbci	r27, 0xF4	; 244
    484e:	95 96       	adiw	r26, 0x25	; 37
    4850:	8c 91       	ld	r24, X
    4852:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4854:	2f 5f       	subi	r18, 0xFF	; 255
    4856:	3f 4f       	sbci	r19, 0xFF	; 255
    4858:	24 31       	cpi	r18, 0x14	; 20
    485a:	31 05       	cpc	r19, r1
    485c:	91 f7       	brne	.-28     	; 0x4842 <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    485e:	10 92 31 09 	sts	0x0931, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    4862:	89 e8       	ldi	r24, 0x89	; 137
    4864:	9b e0       	ldi	r25, 0x0B	; 11
    4866:	0e 94 87 23 	call	0x470e	; 0x470e <RemSpaceLead>
    486a:	20 e0       	ldi	r18, 0x00	; 0
    486c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    486e:	f9 01       	movw	r30, r18
    4870:	ec 5d       	subi	r30, 0xDC	; 220
    4872:	fc 4f       	sbci	r31, 0xFC	; 252
    4874:	d9 01       	movw	r26, r18
    4876:	a3 5e       	subi	r26, 0xE3	; 227
    4878:	b6 4f       	sbci	r27, 0xF6	; 246
    487a:	dc 96       	adiw	r26, 0x3c	; 60
    487c:	8c 91       	ld	r24, X
    487e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4880:	2f 5f       	subi	r18, 0xFF	; 255
    4882:	3f 4f       	sbci	r19, 0xFF	; 255
    4884:	28 32       	cpi	r18, 0x28	; 40
    4886:	31 05       	cpc	r19, r1
    4888:	91 f7       	brne	.-28     	; 0x486e <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    488a:	10 92 4c 03 	sts	0x034C, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    488e:	84 e2       	ldi	r24, 0x24	; 36
    4890:	93 e0       	ldi	r25, 0x03	; 3
    4892:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
    4896:	20 e0       	ldi	r18, 0x00	; 0
    4898:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    489a:	f9 01       	movw	r30, r18
    489c:	e5 5a       	subi	r30, 0xA5	; 165
    489e:	fc 4f       	sbci	r31, 0xFC	; 252
    48a0:	d9 01       	movw	r26, r18
    48a2:	ab 54       	subi	r26, 0x4B	; 75
    48a4:	b6 4f       	sbci	r27, 0xF6	; 246
    48a6:	8c 91       	ld	r24, X
    48a8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    48aa:	2f 5f       	subi	r18, 0xFF	; 255
    48ac:	3f 4f       	sbci	r19, 0xFF	; 255
    48ae:	29 31       	cpi	r18, 0x19	; 25
    48b0:	31 05       	cpc	r19, r1
    48b2:	99 f7       	brne	.-26     	; 0x489a <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    48b4:	10 92 74 03 	sts	0x0374, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    48b8:	8b e5       	ldi	r24, 0x5B	; 91
    48ba:	93 e0       	ldi	r25, 0x03	; 3
    48bc:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    48c0:	80 91 ce 09 	lds	r24, 0x09CE
    48c4:	80 93 e5 02 	sts	0x02E5, r24
	 }Dest[Length]=0;
    48c8:	10 92 e6 02 	sts	0x02E6, r1
    48cc:	20 e0       	ldi	r18, 0x00	; 0
    48ce:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    48d0:	f9 01       	movw	r30, r18
    48d2:	e8 50       	subi	r30, 0x08	; 8
    48d4:	f4 4f       	sbci	r31, 0xF4	; 244
    48d6:	d9 01       	movw	r26, r18
    48d8:	a1 53       	subi	r26, 0x31	; 49
    48da:	b6 4f       	sbci	r27, 0xF6	; 246
    48dc:	8c 91       	ld	r24, X
    48de:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    48e0:	2f 5f       	subi	r18, 0xFF	; 255
    48e2:	3f 4f       	sbci	r19, 0xFF	; 255
    48e4:	2d 30       	cpi	r18, 0x0D	; 13
    48e6:	31 05       	cpc	r19, r1
    48e8:	99 f7       	brne	.-26     	; 0x48d0 <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    48ea:	10 92 05 0c 	sts	0x0C05, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    48ee:	88 ef       	ldi	r24, 0xF8	; 248
    48f0:	9b e0       	ldi	r25, 0x0B	; 11
    48f2:	0e 94 87 23 	call	0x470e	; 0x470e <RemSpaceLead>
    48f6:	20 e0       	ldi	r18, 0x00	; 0
    48f8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    48fa:	f9 01       	movw	r30, r18
    48fc:	e6 50       	subi	r30, 0x06	; 6
    48fe:	f7 4f       	sbci	r31, 0xF7	; 247
    4900:	d9 01       	movw	r26, r18
    4902:	a4 52       	subi	r26, 0x24	; 36
    4904:	b6 4f       	sbci	r27, 0xF6	; 246
    4906:	8c 91       	ld	r24, X
    4908:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    490a:	2f 5f       	subi	r18, 0xFF	; 255
    490c:	3f 4f       	sbci	r19, 0xFF	; 255
    490e:	2a 30       	cpi	r18, 0x0A	; 10
    4910:	31 05       	cpc	r19, r1
    4912:	99 f7       	brne	.-26     	; 0x48fa <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4914:	10 92 04 09 	sts	0x0904, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    4918:	8a ef       	ldi	r24, 0xFA	; 250
    491a:	98 e0       	ldi	r25, 0x08	; 8
    491c:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
    4920:	20 e0       	ldi	r18, 0x00	; 0
    4922:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4924:	f9 01       	movw	r30, r18
    4926:	e7 58       	subi	r30, 0x87	; 135
    4928:	f8 4f       	sbci	r31, 0xF8	; 248
    492a:	d9 01       	movw	r26, r18
    492c:	aa 51       	subi	r26, 0x1A	; 26
    492e:	b6 4f       	sbci	r27, 0xF6	; 246
    4930:	8c 91       	ld	r24, X
    4932:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4934:	2f 5f       	subi	r18, 0xFF	; 255
    4936:	3f 4f       	sbci	r19, 0xFF	; 255
    4938:	24 31       	cpi	r18, 0x14	; 20
    493a:	31 05       	cpc	r19, r1
    493c:	99 f7       	brne	.-26     	; 0x4924 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    493e:	10 92 8d 07 	sts	0x078D, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    4942:	89 e7       	ldi	r24, 0x79	; 121
    4944:	97 e0       	ldi	r25, 0x07	; 7
    4946:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		 uart_print(0,1,strCompName);
		 
uart_print(0,1,strCardID);
*/	
     return Result;
}
    494a:	81 2f       	mov	r24, r17
    494c:	8f 52       	subi	r24, 0x2F	; 47
    494e:	1f 91       	pop	r17
    4950:	08 95       	ret

00004952 <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    4952:	20 e0       	ldi	r18, 0x00	; 0
    4954:	30 e0       	ldi	r19, 0x00	; 0
    4956:	06 c0       	rjmp	.+12     	; 0x4964 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    4958:	fc 01       	movw	r30, r24
    495a:	e2 0f       	add	r30, r18
    495c:	f3 1f       	adc	r31, r19
    495e:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    4960:	2f 5f       	subi	r18, 0xFF	; 255
    4962:	3f 4f       	sbci	r19, 0xFF	; 255
    4964:	fc 01       	movw	r30, r24
    4966:	01 90       	ld	r0, Z+
    4968:	00 20       	and	r0, r0
    496a:	e9 f7       	brne	.-6      	; 0x4966 <clearString+0x14>
    496c:	31 97       	sbiw	r30, 0x01	; 1
    496e:	e8 1b       	sub	r30, r24
    4970:	f9 0b       	sbc	r31, r25
    4972:	2e 17       	cp	r18, r30
    4974:	3f 07       	cpc	r19, r31
    4976:	80 f3       	brcs	.-32     	; 0x4958 <clearString+0x6>
	    str[i]=0;
	 }
}
    4978:	08 95       	ret

0000497a <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    497a:	bf 92       	push	r11
    497c:	cf 92       	push	r12
    497e:	df 92       	push	r13
    4980:	ef 92       	push	r14
    4982:	ff 92       	push	r15
    4984:	0f 93       	push	r16
    4986:	1f 93       	push	r17
    4988:	df 93       	push	r29
    498a:	cf 93       	push	r28
    498c:	cd b7       	in	r28, 0x3d	; 61
    498e:	de b7       	in	r29, 0x3e	; 62
    4990:	6e 97       	sbiw	r28, 0x1e	; 30
    4992:	0f b6       	in	r0, 0x3f	; 63
    4994:	f8 94       	cli
    4996:	de bf       	out	0x3e, r29	; 62
    4998:	0f be       	out	0x3f, r0	; 63
    499a:	cd bf       	out	0x3d, r28	; 61
    499c:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    499e:	fc 01       	movw	r30, r24
    49a0:	01 90       	ld	r0, Z+
    49a2:	00 20       	and	r0, r0
    49a4:	e9 f7       	brne	.-6      	; 0x49a0 <AddZeroLead+0x26>
    49a6:	31 97       	sbiw	r30, 0x01	; 1
    49a8:	2e 2f       	mov	r18, r30
    49aa:	28 1b       	sub	r18, r24

	 if (Size>Length){
    49ac:	26 17       	cp	r18, r22
    49ae:	e0 f5       	brcc	.+120    	; 0x4a28 <AddZeroLead+0xae>
    49b0:	7e 01       	movw	r14, r28
    49b2:	08 94       	sec
    49b4:	e1 1c       	adc	r14, r1
    49b6:	f1 1c       	adc	r15, r1
    49b8:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    49ba:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    49bc:	90 e3       	ldi	r25, 0x30	; 48
    49be:	01 c0       	rjmp	.+2      	; 0x49c2 <AddZeroLead+0x48>
    49c0:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    49c2:	8e 2f       	mov	r24, r30
    49c4:	8b 19       	sub	r24, r11
    49c6:	86 17       	cp	r24, r22
    49c8:	d8 f3       	brcs	.-10     	; 0x49c0 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    49ca:	46 2f       	mov	r20, r22
    49cc:	50 e0       	ldi	r21, 0x00	; 0
    49ce:	ce 01       	movw	r24, r28
    49d0:	01 96       	adiw	r24, 0x01	; 1
    49d2:	fc 01       	movw	r30, r24
    49d4:	e4 0f       	add	r30, r20
    49d6:	f5 1f       	adc	r31, r21
    49d8:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    49da:	76 2f       	mov	r23, r22
    49dc:	72 1b       	sub	r23, r18
    49de:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    49e0:	30 e0       	ldi	r19, 0x00	; 0
    49e2:	24 1b       	sub	r18, r20
    49e4:	35 0b       	sbc	r19, r21
    49e6:	0c c0       	rjmp	.+24     	; 0x4a00 <AddZeroLead+0x86>
    49e8:	e7 2f       	mov	r30, r23
    49ea:	f0 e0       	ldi	r31, 0x00	; 0
    49ec:	d6 01       	movw	r26, r12
    49ee:	ae 0f       	add	r26, r30
    49f0:	bf 1f       	adc	r27, r31
    49f2:	e0 0f       	add	r30, r16
    49f4:	f1 1f       	adc	r31, r17
    49f6:	e2 0f       	add	r30, r18
    49f8:	f3 1f       	adc	r31, r19
    49fa:	80 81       	ld	r24, Z
    49fc:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    49fe:	7f 5f       	subi	r23, 0xFF	; 255
    4a00:	76 17       	cp	r23, r22
    4a02:	90 f3       	brcs	.-28     	; 0x49e8 <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    4a04:	4c 0d       	add	r20, r12
    4a06:	5d 1d       	adc	r21, r13
    4a08:	da 01       	movw	r26, r20
    4a0a:	1c 92       	st	X, r1
    4a0c:	f8 01       	movw	r30, r16
    4a0e:	04 c0       	rjmp	.+8      	; 0x4a18 <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    4a10:	d7 01       	movw	r26, r14
    4a12:	8d 91       	ld	r24, X+
    4a14:	7d 01       	movw	r14, r26
    4a16:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    4a18:	8e 2d       	mov	r24, r14
    4a1a:	8b 19       	sub	r24, r11
    4a1c:	86 17       	cp	r24, r22
    4a1e:	c0 f3       	brcs	.-16     	; 0x4a10 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    4a20:	06 0f       	add	r16, r22
    4a22:	11 1d       	adc	r17, r1
    4a24:	f8 01       	movw	r30, r16
    4a26:	10 82       	st	Z, r1
	 }
}
    4a28:	6e 96       	adiw	r28, 0x1e	; 30
    4a2a:	0f b6       	in	r0, 0x3f	; 63
    4a2c:	f8 94       	cli
    4a2e:	de bf       	out	0x3e, r29	; 62
    4a30:	0f be       	out	0x3f, r0	; 63
    4a32:	cd bf       	out	0x3d, r28	; 61
    4a34:	cf 91       	pop	r28
    4a36:	df 91       	pop	r29
    4a38:	1f 91       	pop	r17
    4a3a:	0f 91       	pop	r16
    4a3c:	ff 90       	pop	r15
    4a3e:	ef 90       	pop	r14
    4a40:	df 90       	pop	r13
    4a42:	cf 90       	pop	r12
    4a44:	bf 90       	pop	r11
    4a46:	08 95       	ret

00004a48 <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    4a48:	0f 93       	push	r16
    4a4a:	1f 93       	push	r17
    4a4c:	cf 93       	push	r28
    4a4e:	df 93       	push	r29
    4a50:	18 2f       	mov	r17, r24
    4a52:	06 2f       	mov	r16, r22
    4a54:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    4a56:	ca 01       	movw	r24, r20
    4a58:	6d e0       	ldi	r22, 0x0D	; 13
    4a5a:	0e 94 bd 24 	call	0x497a	; 0x497a <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4a5e:	81 2f       	mov	r24, r17
    4a60:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
    4a64:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4a66:	88 23       	and	r24, r24
    4a68:	39 f0       	breq	.+14     	; 0x4a78 <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4a6a:	41 50       	subi	r20, 0x01	; 1
    4a6c:	81 e0       	ldi	r24, 0x01	; 1
    4a6e:	61 e0       	ldi	r22, 0x01	; 1
    4a70:	20 2f       	mov	r18, r16
    4a72:	8e 01       	movw	r16, r28
    4a74:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    4a78:	df 91       	pop	r29
    4a7a:	cf 91       	pop	r28
    4a7c:	1f 91       	pop	r17
    4a7e:	0f 91       	pop	r16
    4a80:	08 95       	ret

00004a82 <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    4a82:	0f 93       	push	r16
    4a84:	1f 93       	push	r17
    4a86:	cf 93       	push	r28
    4a88:	df 93       	push	r29
    4a8a:	18 2f       	mov	r17, r24
    4a8c:	06 2f       	mov	r16, r22
    4a8e:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    4a90:	ca 01       	movw	r24, r20
    4a92:	6b e0       	ldi	r22, 0x0B	; 11
    4a94:	0e 94 bd 24 	call	0x497a	; 0x497a <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4a98:	81 2f       	mov	r24, r17
    4a9a:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
    4a9e:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4aa0:	88 23       	and	r24, r24
    4aa2:	39 f0       	breq	.+14     	; 0x4ab2 <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4aa4:	41 50       	subi	r20, 0x01	; 1
    4aa6:	80 e0       	ldi	r24, 0x00	; 0
    4aa8:	61 e0       	ldi	r22, 0x01	; 1
    4aaa:	20 2f       	mov	r18, r16
    4aac:	8e 01       	movw	r16, r28
    4aae:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    4ab2:	df 91       	pop	r29
    4ab4:	cf 91       	pop	r28
    4ab6:	1f 91       	pop	r17
    4ab8:	0f 91       	pop	r16
    4aba:	08 95       	ret

00004abc <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    4abc:	ef 92       	push	r14
    4abe:	ff 92       	push	r15
    4ac0:	0f 93       	push	r16
    4ac2:	1f 93       	push	r17
    4ac4:	08 2f       	mov	r16, r24
    4ac6:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4ac8:	cb 01       	movw	r24, r22
    4aca:	6a e0       	ldi	r22, 0x0A	; 10
    4acc:	0e 94 bd 24 	call	0x497a	; 0x497a <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    4ad0:	00 d0       	rcall	.+0      	; 0x4ad2 <GetTransactionMoney+0x16>
    4ad2:	00 d0       	rcall	.+0      	; 0x4ad4 <GetTransactionMoney+0x18>
    4ad4:	00 d0       	rcall	.+0      	; 0x4ad6 <GetTransactionMoney+0x1a>
    4ad6:	ed b7       	in	r30, 0x3d	; 61
    4ad8:	fe b7       	in	r31, 0x3e	; 62
    4ada:	31 96       	adiw	r30, 0x01	; 1
    4adc:	ad b7       	in	r26, 0x3d	; 61
    4ade:	be b7       	in	r27, 0x3e	; 62
    4ae0:	12 96       	adiw	r26, 0x02	; 2
    4ae2:	fc 92       	st	X, r15
    4ae4:	ee 92       	st	-X, r14
    4ae6:	11 97       	sbiw	r26, 0x01	; 1
    4ae8:	84 e3       	ldi	r24, 0x34	; 52
    4aea:	93 e0       	ldi	r25, 0x03	; 3
    4aec:	93 83       	std	Z+3, r25	; 0x03
    4aee:	82 83       	std	Z+2, r24	; 0x02
    4af0:	10 e0       	ldi	r17, 0x00	; 0
    4af2:	0f 70       	andi	r16, 0x0F	; 15
    4af4:	10 70       	andi	r17, 0x00	; 0
    4af6:	85 e3       	ldi	r24, 0x35	; 53
    4af8:	90 e0       	ldi	r25, 0x00	; 0
    4afa:	9c 01       	movw	r18, r24
    4afc:	02 9f       	mul	r16, r18
    4afe:	c0 01       	movw	r24, r0
    4b00:	03 9f       	mul	r16, r19
    4b02:	90 0d       	add	r25, r0
    4b04:	12 9f       	mul	r17, r18
    4b06:	90 0d       	add	r25, r0
    4b08:	11 24       	eor	r1, r1
    4b0a:	8c 52       	subi	r24, 0x2C	; 44
    4b0c:	9a 4f       	sbci	r25, 0xFA	; 250
    4b0e:	95 83       	std	Z+5, r25	; 0x05
    4b10:	84 83       	std	Z+4, r24	; 0x04
    4b12:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    4b16:	8d b7       	in	r24, 0x3d	; 61
    4b18:	9e b7       	in	r25, 0x3e	; 62
    4b1a:	06 96       	adiw	r24, 0x06	; 6
    4b1c:	0f b6       	in	r0, 0x3f	; 63
    4b1e:	f8 94       	cli
    4b20:	9e bf       	out	0x3e, r25	; 62
    4b22:	0f be       	out	0x3f, r0	; 63
    4b24:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    4b26:	1f 91       	pop	r17
    4b28:	0f 91       	pop	r16
    4b2a:	ff 90       	pop	r15
    4b2c:	ef 90       	pop	r14
    4b2e:	08 95       	ret

00004b30 <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    4b30:	ef 92       	push	r14
    4b32:	ff 92       	push	r15
    4b34:	0f 93       	push	r16
    4b36:	1f 93       	push	r17
    4b38:	08 2f       	mov	r16, r24
    4b3a:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4b3c:	cb 01       	movw	r24, r22
    4b3e:	6a e0       	ldi	r22, 0x0A	; 10
    4b40:	0e 94 bd 24 	call	0x497a	; 0x497a <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    4b44:	00 d0       	rcall	.+0      	; 0x4b46 <GetTransactionVolume+0x16>
    4b46:	00 d0       	rcall	.+0      	; 0x4b48 <GetTransactionVolume+0x18>
    4b48:	00 d0       	rcall	.+0      	; 0x4b4a <GetTransactionVolume+0x1a>
    4b4a:	ed b7       	in	r30, 0x3d	; 61
    4b4c:	fe b7       	in	r31, 0x3e	; 62
    4b4e:	31 96       	adiw	r30, 0x01	; 1
    4b50:	ad b7       	in	r26, 0x3d	; 61
    4b52:	be b7       	in	r27, 0x3e	; 62
    4b54:	12 96       	adiw	r26, 0x02	; 2
    4b56:	fc 92       	st	X, r15
    4b58:	ee 92       	st	-X, r14
    4b5a:	11 97       	sbiw	r26, 0x01	; 1
    4b5c:	87 e3       	ldi	r24, 0x37	; 55
    4b5e:	93 e0       	ldi	r25, 0x03	; 3
    4b60:	93 83       	std	Z+3, r25	; 0x03
    4b62:	82 83       	std	Z+2, r24	; 0x02
    4b64:	10 e0       	ldi	r17, 0x00	; 0
    4b66:	0f 70       	andi	r16, 0x0F	; 15
    4b68:	10 70       	andi	r17, 0x00	; 0
    4b6a:	85 e3       	ldi	r24, 0x35	; 53
    4b6c:	90 e0       	ldi	r25, 0x00	; 0
    4b6e:	9c 01       	movw	r18, r24
    4b70:	02 9f       	mul	r16, r18
    4b72:	c0 01       	movw	r24, r0
    4b74:	03 9f       	mul	r16, r19
    4b76:	90 0d       	add	r25, r0
    4b78:	12 9f       	mul	r17, r18
    4b7a:	90 0d       	add	r25, r0
    4b7c:	11 24       	eor	r1, r1
    4b7e:	85 53       	subi	r24, 0x35	; 53
    4b80:	9a 4f       	sbci	r25, 0xFA	; 250
    4b82:	95 83       	std	Z+5, r25	; 0x05
    4b84:	84 83       	std	Z+4, r24	; 0x04
    4b86:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    4b8a:	8d b7       	in	r24, 0x3d	; 61
    4b8c:	9e b7       	in	r25, 0x3e	; 62
    4b8e:	06 96       	adiw	r24, 0x06	; 6
    4b90:	0f b6       	in	r0, 0x3f	; 63
    4b92:	f8 94       	cli
    4b94:	9e bf       	out	0x3e, r25	; 62
    4b96:	0f be       	out	0x3f, r0	; 63
    4b98:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    4b9a:	1f 91       	pop	r17
    4b9c:	0f 91       	pop	r16
    4b9e:	ff 90       	pop	r15
    4ba0:	ef 90       	pop	r14
    4ba2:	08 95       	ret

00004ba4 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    4ba4:	af 92       	push	r10
    4ba6:	bf 92       	push	r11
    4ba8:	cf 92       	push	r12
    4baa:	df 92       	push	r13
    4bac:	ef 92       	push	r14
    4bae:	ff 92       	push	r15
    4bb0:	0f 93       	push	r16
    4bb2:	1f 93       	push	r17
    4bb4:	df 93       	push	r29
    4bb6:	cf 93       	push	r28
    4bb8:	cd b7       	in	r28, 0x3d	; 61
    4bba:	de b7       	in	r29, 0x3e	; 62
    4bbc:	65 97       	sbiw	r28, 0x15	; 21
    4bbe:	0f b6       	in	r0, 0x3f	; 63
    4bc0:	f8 94       	cli
    4bc2:	de bf       	out	0x3e, r29	; 62
    4bc4:	0f be       	out	0x3f, r0	; 63
    4bc6:	cd bf       	out	0x3d, r28	; 61
    4bc8:	d8 2e       	mov	r13, r24
    4bca:	c6 2e       	mov	r12, r22
    4bcc:	b4 2e       	mov	r11, r20
    4bce:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    4bd0:	d8 01       	movw	r26, r16
    4bd2:	0d 90       	ld	r0, X+
    4bd4:	00 20       	and	r0, r0
    4bd6:	e9 f7       	brne	.-6      	; 0x4bd2 <SetTotalizerData+0x2e>
    4bd8:	11 97       	sbiw	r26, 0x01	; 1
    4bda:	a0 1b       	sub	r26, r16
    4bdc:	b1 0b       	sbc	r27, r17
    4bde:	e7 e0       	ldi	r30, 0x07	; 7
    4be0:	ee 2e       	mov	r14, r30
    4be2:	f1 2c       	mov	r15, r1
    4be4:	ec 0e       	add	r14, r28
    4be6:	fd 1e       	adc	r15, r29
    4be8:	ad 30       	cpi	r26, 0x0D	; 13
    4bea:	b1 05       	cpc	r27, r1
    4bec:	58 f5       	brcc	.+86     	; 0x4c44 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    4bee:	00 d0       	rcall	.+0      	; 0x4bf0 <SetTotalizerData+0x4c>
    4bf0:	00 d0       	rcall	.+0      	; 0x4bf2 <SetTotalizerData+0x4e>
    4bf2:	00 d0       	rcall	.+0      	; 0x4bf4 <SetTotalizerData+0x50>
    4bf4:	ed b7       	in	r30, 0x3d	; 61
    4bf6:	fe b7       	in	r31, 0x3e	; 62
    4bf8:	31 96       	adiw	r30, 0x01	; 1
    4bfa:	ad b7       	in	r26, 0x3d	; 61
    4bfc:	be b7       	in	r27, 0x3e	; 62
    4bfe:	12 96       	adiw	r26, 0x02	; 2
    4c00:	fc 92       	st	X, r15
    4c02:	ee 92       	st	-X, r14
    4c04:	11 97       	sbiw	r26, 0x01	; 1
    4c06:	89 e0       	ldi	r24, 0x09	; 9
    4c08:	95 e0       	ldi	r25, 0x05	; 5
    4c0a:	93 83       	std	Z+3, r25	; 0x03
    4c0c:	82 83       	std	Z+2, r24	; 0x02
    4c0e:	15 83       	std	Z+5, r17	; 0x05
    4c10:	04 83       	std	Z+4, r16	; 0x04
    4c12:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    4c16:	f7 01       	movw	r30, r14
    4c18:	01 90       	ld	r0, Z+
    4c1a:	00 20       	and	r0, r0
    4c1c:	e9 f7       	brne	.-6      	; 0x4c18 <SetTotalizerData+0x74>
    4c1e:	31 97       	sbiw	r30, 0x01	; 1
    4c20:	ee 19       	sub	r30, r14
    4c22:	ff 09       	sbc	r31, r15
    4c24:	6d b7       	in	r22, 0x3d	; 61
    4c26:	7e b7       	in	r23, 0x3e	; 62
    4c28:	6a 5f       	subi	r22, 0xFA	; 250
    4c2a:	7f 4f       	sbci	r23, 0xFF	; 255
    4c2c:	0f b6       	in	r0, 0x3f	; 63
    4c2e:	f8 94       	cli
    4c30:	7e bf       	out	0x3e, r23	; 62
    4c32:	0f be       	out	0x3f, r0	; 63
    4c34:	6d bf       	out	0x3d, r22	; 61
    4c36:	3c 97       	sbiw	r30, 0x0c	; 12
    4c38:	a0 f4       	brcc	.+40     	; 0x4c62 <SetTotalizerData+0xbe>
    4c3a:	c7 01       	movw	r24, r14
    4c3c:	6c e0       	ldi	r22, 0x0C	; 12
    4c3e:	0e 94 bd 24 	call	0x497a	; 0x497a <AddZeroLead>
    4c42:	0f c0       	rjmp	.+30     	; 0x4c62 <SetTotalizerData+0xbe>
    4c44:	8a 2f       	mov	r24, r26
    4c46:	8c 50       	subi	r24, 0x0C	; 12
    4c48:	f8 01       	movw	r30, r16
    4c4a:	e8 0f       	add	r30, r24
    4c4c:	f1 1d       	adc	r31, r1
    4c4e:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4c50:	9e 01       	movw	r18, r28
    4c52:	2d 5e       	subi	r18, 0xED	; 237
    4c54:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    4c56:	81 91       	ld	r24, Z+
    4c58:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4c5a:	a2 17       	cp	r26, r18
    4c5c:	b3 07       	cpc	r27, r19
    4c5e:	d9 f7       	brne	.-10     	; 0x4c56 <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4c60:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    4c62:	0b 2d       	mov	r16, r11
    4c64:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    4c66:	1a 2d       	mov	r17, r10
    4c68:	11 50       	subi	r17, 0x01	; 1
    4c6a:	16 30       	cpi	r17, 0x06	; 6
    4c6c:	08 f0       	brcs	.+2      	; 0x4c70 <SetTotalizerData+0xcc>
    4c6e:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    4c70:	ce 01       	movw	r24, r28
    4c72:	07 96       	adiw	r24, 0x07	; 7
    4c74:	7e 01       	movw	r14, r28
    4c76:	08 94       	sec
    4c78:	e1 1c       	adc	r14, r1
    4c7a:	f1 1c       	adc	r15, r1
    4c7c:	b7 01       	movw	r22, r14
    4c7e:	0e 94 7d 18 	call	0x30fa	; 0x30fa <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    4c82:	dd 20       	and	r13, r13
    4c84:	d9 f4       	brne	.+54     	; 0x4cbc <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    4c86:	84 e2       	ldi	r24, 0x24	; 36
    4c88:	08 9f       	mul	r16, r24
    4c8a:	c0 01       	movw	r24, r0
    4c8c:	11 24       	eor	r1, r1
    4c8e:	4c 2d       	mov	r20, r12
    4c90:	50 e0       	ldi	r21, 0x00	; 0
    4c92:	20 e2       	ldi	r18, 0x20	; 32
    4c94:	31 e0       	ldi	r19, 0x01	; 1
    4c96:	d9 01       	movw	r26, r18
    4c98:	4a 9f       	mul	r20, r26
    4c9a:	90 01       	movw	r18, r0
    4c9c:	4b 9f       	mul	r20, r27
    4c9e:	30 0d       	add	r19, r0
    4ca0:	5a 9f       	mul	r21, r26
    4ca2:	30 0d       	add	r19, r0
    4ca4:	11 24       	eor	r1, r1
    4ca6:	82 0f       	add	r24, r18
    4ca8:	93 1f       	adc	r25, r19
    4caa:	26 e0       	ldi	r18, 0x06	; 6
    4cac:	12 9f       	mul	r17, r18
    4cae:	90 01       	movw	r18, r0
    4cb0:	11 24       	eor	r1, r1
    4cb2:	82 0f       	add	r24, r18
    4cb4:	93 1f       	adc	r25, r19
    4cb6:	8d 53       	subi	r24, 0x3D	; 61
    4cb8:	9c 4f       	sbci	r25, 0xFC	; 252
    4cba:	1d c0       	rjmp	.+58     	; 0x4cf6 <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    4cbc:	b1 e0       	ldi	r27, 0x01	; 1
    4cbe:	db 16       	cp	r13, r27
    4cc0:	09 f5       	brne	.+66     	; 0x4d04 <SetTotalizerData+0x160>
    4cc2:	84 e2       	ldi	r24, 0x24	; 36
    4cc4:	08 9f       	mul	r16, r24
    4cc6:	c0 01       	movw	r24, r0
    4cc8:	11 24       	eor	r1, r1
    4cca:	4c 2d       	mov	r20, r12
    4ccc:	50 e0       	ldi	r21, 0x00	; 0
    4cce:	20 e2       	ldi	r18, 0x20	; 32
    4cd0:	31 e0       	ldi	r19, 0x01	; 1
    4cd2:	b9 01       	movw	r22, r18
    4cd4:	46 9f       	mul	r20, r22
    4cd6:	90 01       	movw	r18, r0
    4cd8:	47 9f       	mul	r20, r23
    4cda:	30 0d       	add	r19, r0
    4cdc:	56 9f       	mul	r21, r22
    4cde:	30 0d       	add	r19, r0
    4ce0:	11 24       	eor	r1, r1
    4ce2:	82 0f       	add	r24, r18
    4ce4:	93 1f       	adc	r25, r19
    4ce6:	26 e0       	ldi	r18, 0x06	; 6
    4ce8:	12 9f       	mul	r17, r18
    4cea:	90 01       	movw	r18, r0
    4cec:	11 24       	eor	r1, r1
    4cee:	82 0f       	add	r24, r18
    4cf0:	93 1f       	adc	r25, r19
    4cf2:	8d 5f       	subi	r24, 0xFD	; 253
    4cf4:	99 4f       	sbci	r25, 0xF9	; 249
    4cf6:	b7 01       	movw	r22, r14
    4cf8:	46 e0       	ldi	r20, 0x06	; 6
    4cfa:	50 e0       	ldi	r21, 0x00	; 0
    4cfc:	2c e4       	ldi	r18, 0x4C	; 76
    4cfe:	32 e1       	ldi	r19, 0x12	; 18
    4d00:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
}
    4d04:	65 96       	adiw	r28, 0x15	; 21
    4d06:	0f b6       	in	r0, 0x3f	; 63
    4d08:	f8 94       	cli
    4d0a:	de bf       	out	0x3e, r29	; 62
    4d0c:	0f be       	out	0x3f, r0	; 63
    4d0e:	cd bf       	out	0x3d, r28	; 61
    4d10:	cf 91       	pop	r28
    4d12:	df 91       	pop	r29
    4d14:	1f 91       	pop	r17
    4d16:	0f 91       	pop	r16
    4d18:	ff 90       	pop	r15
    4d1a:	ef 90       	pop	r14
    4d1c:	df 90       	pop	r13
    4d1e:	cf 90       	pop	r12
    4d20:	bf 90       	pop	r11
    4d22:	af 90       	pop	r10
    4d24:	08 95       	ret

00004d26 <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    4d26:	4f 92       	push	r4
    4d28:	5f 92       	push	r5
    4d2a:	7f 92       	push	r7
    4d2c:	8f 92       	push	r8
    4d2e:	9f 92       	push	r9
    4d30:	af 92       	push	r10
    4d32:	bf 92       	push	r11
    4d34:	cf 92       	push	r12
    4d36:	df 92       	push	r13
    4d38:	ef 92       	push	r14
    4d3a:	ff 92       	push	r15
    4d3c:	0f 93       	push	r16
    4d3e:	1f 93       	push	r17
    4d40:	df 93       	push	r29
    4d42:	cf 93       	push	r28
    4d44:	cd b7       	in	r28, 0x3d	; 61
    4d46:	de b7       	in	r29, 0x3e	; 62
    4d48:	2f 97       	sbiw	r28, 0x0f	; 15
    4d4a:	0f b6       	in	r0, 0x3f	; 63
    4d4c:	f8 94       	cli
    4d4e:	de bf       	out	0x3e, r29	; 62
    4d50:	0f be       	out	0x3f, r0	; 63
    4d52:	cd bf       	out	0x3d, r28	; 61
    4d54:	77 24       	eor	r7, r7
    4d56:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    4d58:	4e 01       	movw	r8, r28
    4d5a:	08 94       	sec
    4d5c:	81 1c       	adc	r8, r1
    4d5e:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d60:	f0 e1       	ldi	r31, 0x10	; 16
    4d62:	4f 2e       	mov	r4, r31
    4d64:	51 2c       	mov	r5, r1
    4d66:	4c 0e       	add	r4, r28
    4d68:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    4d6a:	87 2d       	mov	r24, r7
    4d6c:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
		  if (FIPAddr>0){
    4d70:	88 23       	and	r24, r24
    4d72:	91 f1       	breq	.+100    	; 0x4dd8 <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    4d74:	a8 2e       	mov	r10, r24
    4d76:	aa 94       	dec	r10
    4d78:	bb 24       	eor	r11, r11
    4d7a:	b3 94       	inc	r11
    4d7c:	2a c0       	rjmp	.+84     	; 0x4dd2 <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4d7e:	f7 01       	movw	r30, r14
    4d80:	11 92       	st	Z+, r1
    4d82:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d84:	e4 15       	cp	r30, r4
    4d86:	f5 05       	cpc	r31, r5
    4d88:	d1 f7       	brne	.-12     	; 0x4d7e <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    4d8a:	80 e0       	ldi	r24, 0x00	; 0
    4d8c:	61 e0       	ldi	r22, 0x01	; 1
    4d8e:	4a 2d       	mov	r20, r10
    4d90:	2b 2d       	mov	r18, r11
    4d92:	84 01       	movw	r16, r8
    4d94:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    4d98:	80 e0       	ldi	r24, 0x00	; 0
    4d9a:	60 e0       	ldi	r22, 0x00	; 0
    4d9c:	4a 2d       	mov	r20, r10
    4d9e:	2b 2d       	mov	r18, r11
    4da0:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4da4:	f6 01       	movw	r30, r12
    4da6:	11 92       	st	Z+, r1
    4da8:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4daa:	ee 15       	cp	r30, r14
    4dac:	ff 05       	cpc	r31, r15
    4dae:	d1 f7       	brne	.-12     	; 0x4da4 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    4db0:	81 e0       	ldi	r24, 0x01	; 1
    4db2:	61 e0       	ldi	r22, 0x01	; 1
    4db4:	4a 2d       	mov	r20, r10
    4db6:	2b 2d       	mov	r18, r11
    4db8:	84 01       	movw	r16, r8
    4dba:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    4dbe:	81 e0       	ldi	r24, 0x01	; 1
    4dc0:	60 e0       	ldi	r22, 0x00	; 0
    4dc2:	4a 2d       	mov	r20, r10
    4dc4:	2b 2d       	mov	r18, r11
    4dc6:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    4dca:	b3 94       	inc	r11
    4dcc:	f7 e0       	ldi	r31, 0x07	; 7
    4dce:	bf 16       	cp	r11, r31
    4dd0:	19 f0       	breq	.+6      	; 0x4dd8 <SaveTotalizerCurrentToLast+0xb2>
    4dd2:	64 01       	movw	r12, r8
    4dd4:	74 01       	movw	r14, r8
    4dd6:	d3 cf       	rjmp	.-90     	; 0x4d7e <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    4dd8:	73 94       	inc	r7
    4dda:	81 e1       	ldi	r24, 0x11	; 17
    4ddc:	78 16       	cp	r7, r24
    4dde:	29 f6       	brne	.-118    	; 0x4d6a <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    4de0:	2f 96       	adiw	r28, 0x0f	; 15
    4de2:	0f b6       	in	r0, 0x3f	; 63
    4de4:	f8 94       	cli
    4de6:	de bf       	out	0x3e, r29	; 62
    4de8:	0f be       	out	0x3f, r0	; 63
    4dea:	cd bf       	out	0x3d, r28	; 61
    4dec:	cf 91       	pop	r28
    4dee:	df 91       	pop	r29
    4df0:	1f 91       	pop	r17
    4df2:	0f 91       	pop	r16
    4df4:	ff 90       	pop	r15
    4df6:	ef 90       	pop	r14
    4df8:	df 90       	pop	r13
    4dfa:	cf 90       	pop	r12
    4dfc:	bf 90       	pop	r11
    4dfe:	af 90       	pop	r10
    4e00:	9f 90       	pop	r9
    4e02:	8f 90       	pop	r8
    4e04:	7f 90       	pop	r7
    4e06:	5f 90       	pop	r5
    4e08:	4f 90       	pop	r4
    4e0a:	08 95       	ret

00004e0c <ResetTotalizer>:
}

//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    4e0c:	af 92       	push	r10
    4e0e:	bf 92       	push	r11
    4e10:	cf 92       	push	r12
    4e12:	df 92       	push	r13
    4e14:	ef 92       	push	r14
    4e16:	ff 92       	push	r15
    4e18:	0f 93       	push	r16
    4e1a:	1f 93       	push	r17
    4e1c:	df 93       	push	r29
    4e1e:	cf 93       	push	r28
    4e20:	cd b7       	in	r28, 0x3d	; 61
    4e22:	de b7       	in	r29, 0x3e	; 62
    4e24:	29 97       	sbiw	r28, 0x09	; 9
    4e26:	0f b6       	in	r0, 0x3f	; 63
    4e28:	f8 94       	cli
    4e2a:	de bf       	out	0x3e, r29	; 62
    4e2c:	0f be       	out	0x3f, r0	; 63
    4e2e:	cd bf       	out	0x3d, r28	; 61
    4e30:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    4e32:	00 d0       	rcall	.+0      	; 0x4e34 <ResetTotalizer+0x28>
    4e34:	00 d0       	rcall	.+0      	; 0x4e36 <ResetTotalizer+0x2a>
    4e36:	6e 01       	movw	r12, r28
    4e38:	08 94       	sec
    4e3a:	c1 1c       	adc	r12, r1
    4e3c:	d1 1c       	adc	r13, r1
    4e3e:	ed b7       	in	r30, 0x3d	; 61
    4e40:	fe b7       	in	r31, 0x3e	; 62
    4e42:	d2 82       	std	Z+2, r13	; 0x02
    4e44:	c1 82       	std	Z+1, r12	; 0x01
    4e46:	8c e0       	ldi	r24, 0x0C	; 12
    4e48:	95 e0       	ldi	r25, 0x05	; 5
    4e4a:	94 83       	std	Z+4, r25	; 0x04
    4e4c:	83 83       	std	Z+3, r24	; 0x03
    4e4e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    4e52:	ee 24       	eor	r14, r14
    4e54:	e3 94       	inc	r14
    4e56:	0f 90       	pop	r0
    4e58:	0f 90       	pop	r0
    4e5a:	0f 90       	pop	r0
    4e5c:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    4e5e:	8e 2d       	mov	r24, r14
    4e60:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
		  if (FIPAddr>0){
    4e64:	88 23       	and	r24, r24
    4e66:	a9 f0       	breq	.+42     	; 0x4e92 <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    4e68:	b8 2e       	mov	r11, r24
    4e6a:	ba 94       	dec	r11
    4e6c:	ff 24       	eor	r15, r15
    4e6e:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    4e70:	80 e0       	ldi	r24, 0x00	; 0
    4e72:	6a 2d       	mov	r22, r10
    4e74:	4b 2d       	mov	r20, r11
    4e76:	2f 2d       	mov	r18, r15
    4e78:	86 01       	movw	r16, r12
    4e7a:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    4e7e:	81 e0       	ldi	r24, 0x01	; 1
    4e80:	6a 2d       	mov	r22, r10
    4e82:	4b 2d       	mov	r20, r11
    4e84:	2f 2d       	mov	r18, r15
    4e86:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    4e8a:	f3 94       	inc	r15
    4e8c:	f7 e0       	ldi	r31, 0x07	; 7
    4e8e:	ff 16       	cp	r15, r31
    4e90:	79 f7       	brne	.-34     	; 0x4e70 <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    4e92:	e3 94       	inc	r14
    4e94:	81 e1       	ldi	r24, 0x11	; 17
    4e96:	e8 16       	cp	r14, r24
    4e98:	11 f7       	brne	.-60     	; 0x4e5e <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    4e9a:	29 96       	adiw	r28, 0x09	; 9
    4e9c:	0f b6       	in	r0, 0x3f	; 63
    4e9e:	f8 94       	cli
    4ea0:	de bf       	out	0x3e, r29	; 62
    4ea2:	0f be       	out	0x3f, r0	; 63
    4ea4:	cd bf       	out	0x3d, r28	; 61
    4ea6:	cf 91       	pop	r28
    4ea8:	df 91       	pop	r29
    4eaa:	1f 91       	pop	r17
    4eac:	0f 91       	pop	r16
    4eae:	ff 90       	pop	r15
    4eb0:	ef 90       	pop	r14
    4eb2:	df 90       	pop	r13
    4eb4:	cf 90       	pop	r12
    4eb6:	bf 90       	pop	r11
    4eb8:	af 90       	pop	r10
    4eba:	08 95       	ret

00004ebc <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    4ebc:	cf 93       	push	r28
    4ebe:	df 93       	push	r29
    4ec0:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    4ec2:	dc 01       	movw	r26, r24
    4ec4:	0d 90       	ld	r0, X+
    4ec6:	00 20       	and	r0, r0
    4ec8:	e9 f7       	brne	.-6      	; 0x4ec4 <AddZeroLag+0x8>
    4eca:	11 97       	sbiw	r26, 0x01	; 1
    4ecc:	a8 1b       	sub	r26, r24
    4ece:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    4ed0:	a6 17       	cp	r26, r22
    4ed2:	60 f4       	brcc	.+24     	; 0x4eec <AddZeroLag+0x30>
    4ed4:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    4ed6:	90 e3       	ldi	r25, 0x30	; 48
    4ed8:	fe 01       	movw	r30, r28
    4eda:	e8 0f       	add	r30, r24
    4edc:	f1 1d       	adc	r31, r1
    4ede:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    4ee0:	8f 5f       	subi	r24, 0xFF	; 255
    4ee2:	86 17       	cp	r24, r22
    4ee4:	c8 f3       	brcs	.-14     	; 0x4ed8 <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    4ee6:	c6 0f       	add	r28, r22
    4ee8:	d1 1d       	adc	r29, r1
    4eea:	18 82       	st	Y, r1
  }
}
    4eec:	df 91       	pop	r29
    4eee:	cf 91       	pop	r28
    4ef0:	08 95       	ret

00004ef2 <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4ef2:	3f 92       	push	r3
    4ef4:	4f 92       	push	r4
    4ef6:	5f 92       	push	r5
    4ef8:	6f 92       	push	r6
    4efa:	7f 92       	push	r7
    4efc:	8f 92       	push	r8
    4efe:	9f 92       	push	r9
    4f00:	af 92       	push	r10
    4f02:	bf 92       	push	r11
    4f04:	cf 92       	push	r12
    4f06:	df 92       	push	r13
    4f08:	ef 92       	push	r14
    4f0a:	ff 92       	push	r15
    4f0c:	0f 93       	push	r16
    4f0e:	1f 93       	push	r17
    4f10:	df 93       	push	r29
    4f12:	cf 93       	push	r28
    4f14:	cd b7       	in	r28, 0x3d	; 61
    4f16:	de b7       	in	r29, 0x3e	; 62
    4f18:	c8 55       	subi	r28, 0x58	; 88
    4f1a:	d0 40       	sbci	r29, 0x00	; 0
    4f1c:	0f b6       	in	r0, 0x3f	; 63
    4f1e:	f8 94       	cli
    4f20:	de bf       	out	0x3e, r29	; 62
    4f22:	0f be       	out	0x3f, r0	; 63
    4f24:	cd bf       	out	0x3d, r28	; 61
    4f26:	68 2e       	mov	r6, r24
    4f28:	67 96       	adiw	r28, 0x17	; 23
    4f2a:	7f af       	std	Y+63, r23	; 0x3f
    4f2c:	6e af       	std	Y+62, r22	; 0x3e
    4f2e:	67 97       	sbiw	r28, 0x17	; 23
    4f30:	69 96       	adiw	r28, 0x19	; 25
    4f32:	5f af       	std	Y+63, r21	; 0x3f
    4f34:	4e af       	std	Y+62, r20	; 0x3e
    4f36:	69 97       	sbiw	r28, 0x19	; 25
    4f38:	59 01       	movw	r10, r18
    4f3a:	fe 01       	movw	r30, r28
    4f3c:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4f3e:	ce 01       	movw	r24, r28
    4f40:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    4f42:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4f44:	e8 17       	cp	r30, r24
    4f46:	f9 07       	cpc	r31, r25
    4f48:	e1 f7       	brne	.-8      	; 0x4f42 <StrCalc+0x50>
	     strMemory[i]=data;
    4f4a:	ce 01       	movw	r24, r28
    4f4c:	89 96       	adiw	r24, 0x29	; 41
    4f4e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4f50:	e8 17       	cp	r30, r24
    4f52:	f9 07       	cpc	r31, r25
    4f54:	e1 f7       	brne	.-8      	; 0x4f4e <StrCalc+0x5c>
    4f56:	fe 01       	movw	r30, r28
    4f58:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    4f5a:	cf 01       	movw	r24, r30
    4f5c:	44 96       	adiw	r24, 0x14	; 20
    4f5e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4f60:	e8 17       	cp	r30, r24
    4f62:	f9 07       	cpc	r31, r25
    4f64:	e1 f7       	brne	.-8      	; 0x4f5e <StrCalc+0x6c>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    4f66:	00 d0       	rcall	.+0      	; 0x4f68 <StrCalc+0x76>
    4f68:	00 d0       	rcall	.+0      	; 0x4f6a <StrCalc+0x78>
    4f6a:	00 d0       	rcall	.+0      	; 0x4f6c <StrCalc+0x7a>
    4f6c:	ed b7       	in	r30, 0x3d	; 61
    4f6e:	fe b7       	in	r31, 0x3e	; 62
    4f70:	31 96       	adiw	r30, 0x01	; 1
    4f72:	8e 01       	movw	r16, r28
    4f74:	0f 5f       	subi	r16, 0xFF	; 255
    4f76:	1f 4f       	sbci	r17, 0xFF	; 255
    4f78:	ad b7       	in	r26, 0x3d	; 61
    4f7a:	be b7       	in	r27, 0x3e	; 62
    4f7c:	12 96       	adiw	r26, 0x02	; 2
    4f7e:	1c 93       	st	X, r17
    4f80:	0e 93       	st	-X, r16
    4f82:	11 97       	sbiw	r26, 0x01	; 1
    4f84:	86 e0       	ldi	r24, 0x06	; 6
    4f86:	95 e0       	ldi	r25, 0x05	; 5
    4f88:	93 83       	std	Z+3, r25	; 0x03
    4f8a:	82 83       	std	Z+2, r24	; 0x02
    4f8c:	67 96       	adiw	r28, 0x17	; 23
    4f8e:	2e ad       	ldd	r18, Y+62	; 0x3e
    4f90:	3f ad       	ldd	r19, Y+63	; 0x3f
    4f92:	67 97       	sbiw	r28, 0x17	; 23
    4f94:	35 83       	std	Z+5, r19	; 0x05
    4f96:	24 83       	std	Z+4, r18	; 0x04
    4f98:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    4f9c:	ed b7       	in	r30, 0x3d	; 61
    4f9e:	fe b7       	in	r31, 0x3e	; 62
    4fa0:	31 96       	adiw	r30, 0x01	; 1
    4fa2:	ce 01       	movw	r24, r28
    4fa4:	45 96       	adiw	r24, 0x15	; 21
    4fa6:	ad b7       	in	r26, 0x3d	; 61
    4fa8:	be b7       	in	r27, 0x3e	; 62
    4faa:	12 96       	adiw	r26, 0x02	; 2
    4fac:	9c 93       	st	X, r25
    4fae:	8e 93       	st	-X, r24
    4fb0:	11 97       	sbiw	r26, 0x01	; 1
    4fb2:	83 e0       	ldi	r24, 0x03	; 3
    4fb4:	95 e0       	ldi	r25, 0x05	; 5
    4fb6:	93 83       	std	Z+3, r25	; 0x03
    4fb8:	82 83       	std	Z+2, r24	; 0x02
    4fba:	69 96       	adiw	r28, 0x19	; 25
    4fbc:	2e ad       	ldd	r18, Y+62	; 0x3e
    4fbe:	3f ad       	ldd	r19, Y+63	; 0x3f
    4fc0:	69 97       	sbiw	r28, 0x19	; 25
    4fc2:	35 83       	std	Z+5, r19	; 0x05
    4fc4:	24 83       	std	Z+4, r18	; 0x04
    4fc6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>

     if (IsMinus(tmpA)==True){
    4fca:	8d b7       	in	r24, 0x3d	; 61
    4fcc:	9e b7       	in	r25, 0x3e	; 62
    4fce:	06 96       	adiw	r24, 0x06	; 6
    4fd0:	0f b6       	in	r0, 0x3f	; 63
    4fd2:	f8 94       	cli
    4fd4:	9e bf       	out	0x3e, r25	; 62
    4fd6:	0f be       	out	0x3f, r0	; 63
    4fd8:	8d bf       	out	0x3d, r24	; 61
    4fda:	c8 01       	movw	r24, r16
    4fdc:	0e 94 74 21 	call	0x42e8	; 0x42e8 <IsMinus>
    4fe0:	81 30       	cpi	r24, 0x01	; 1
    4fe2:	21 f0       	breq	.+8      	; 0x4fec <StrCalc+0xfa>
    4fe4:	65 96       	adiw	r28, 0x15	; 21
    4fe6:	1f ae       	std	Y+63, r1	; 0x3f
    4fe8:	65 97       	sbiw	r28, 0x15	; 21
    4fea:	07 c0       	rjmp	.+14     	; 0x4ffa <StrCalc+0x108>
	     RemoveMinus(tmpA);
    4fec:	c8 01       	movw	r24, r16
    4fee:	0e 94 79 21 	call	0x42f2	; 0x42f2 <RemoveMinus>
    4ff2:	91 e0       	ldi	r25, 0x01	; 1
    4ff4:	65 96       	adiw	r28, 0x15	; 21
    4ff6:	9f af       	std	Y+63, r25	; 0x3f
    4ff8:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    4ffa:	8e 01       	movw	r16, r28
    4ffc:	0b 5e       	subi	r16, 0xEB	; 235
    4ffe:	1f 4f       	sbci	r17, 0xFF	; 255
    5000:	c8 01       	movw	r24, r16
    5002:	0e 94 74 21 	call	0x42e8	; 0x42e8 <IsMinus>
    5006:	81 30       	cpi	r24, 0x01	; 1
    5008:	21 f0       	breq	.+8      	; 0x5012 <StrCalc+0x120>
    500a:	64 96       	adiw	r28, 0x14	; 20
    500c:	1f ae       	std	Y+63, r1	; 0x3f
    500e:	64 97       	sbiw	r28, 0x14	; 20
    5010:	07 c0       	rjmp	.+14     	; 0x5020 <StrCalc+0x12e>
	     RemoveMinus(tmpB);
    5012:	c8 01       	movw	r24, r16
    5014:	0e 94 79 21 	call	0x42f2	; 0x42f2 <RemoveMinus>
    5018:	a1 e0       	ldi	r26, 0x01	; 1
    501a:	64 96       	adiw	r28, 0x14	; 20
    501c:	af af       	std	Y+63, r26	; 0x3f
    501e:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    5020:	fe 01       	movw	r30, r28
    5022:	31 96       	adiw	r30, 0x01	; 1
    5024:	df 01       	movw	r26, r30
    5026:	0d 90       	ld	r0, X+
    5028:	00 20       	and	r0, r0
    502a:	e9 f7       	brne	.-6      	; 0x5026 <StrCalc+0x134>
    502c:	cd 01       	movw	r24, r26
    502e:	01 97       	sbiw	r24, 0x01	; 1
    5030:	8e 1b       	sub	r24, r30
    5032:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    5034:	de 01       	movw	r26, r28
    5036:	55 96       	adiw	r26, 0x15	; 21
    5038:	fd 01       	movw	r30, r26
    503a:	01 90       	ld	r0, Z+
    503c:	00 20       	and	r0, r0
    503e:	e9 f7       	brne	.-6      	; 0x503a <StrCalc+0x148>
    5040:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    5042:	1e 2f       	mov	r17, r30
    5044:	1a 1b       	sub	r17, r26
    5046:	18 17       	cp	r17, r24
    5048:	08 f4       	brcc	.+2      	; 0x504c <StrCalc+0x15a>
    504a:	18 2f       	mov	r17, r24
    504c:	1f 5f       	subi	r17, 0xFF	; 255
    504e:	7e 01       	movw	r14, r28
    5050:	08 94       	sec
    5052:	e1 1c       	adc	r14, r1
    5054:	f1 1c       	adc	r15, r1
    5056:	c7 01       	movw	r24, r14
    5058:	61 2f       	mov	r22, r17
    505a:	0e 94 bd 24 	call	0x497a	; 0x497a <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    505e:	95 e1       	ldi	r25, 0x15	; 21
    5060:	c9 2e       	mov	r12, r25
    5062:	d1 2c       	mov	r13, r1
    5064:	cc 0e       	add	r12, r28
    5066:	dd 1e       	adc	r13, r29
    5068:	c6 01       	movw	r24, r12
    506a:	61 2f       	mov	r22, r17
    506c:	0e 94 bd 24 	call	0x497a	; 0x497a <AddZeroLead>
	 uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    5070:	f7 01       	movw	r30, r14
    5072:	01 90       	ld	r0, Z+
    5074:	00 20       	and	r0, r0
    5076:	e9 f7       	brne	.-6      	; 0x5072 <StrCalc+0x180>
    5078:	31 97       	sbiw	r30, 0x01	; 1
    507a:	7e 2e       	mov	r7, r30
    507c:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    507e:	f6 01       	movw	r30, r12
    5080:	01 90       	ld	r0, Z+
    5082:	00 20       	and	r0, r0
    5084:	e9 f7       	brne	.-6      	; 0x5080 <StrCalc+0x18e>
    5086:	31 97       	sbiw	r30, 0x01	; 1
    5088:	9e 2e       	mov	r9, r30
    508a:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    508c:	c6 01       	movw	r24, r12
    508e:	b7 01       	movw	r22, r14
    5090:	0e 94 a6 21 	call	0x434c	; 0x434c <IsMoreThan>
    5094:	81 30       	cpi	r24, 0x01	; 1
    5096:	11 f0       	breq	.+4      	; 0x509c <StrCalc+0x1aa>
    5098:	80 e0       	ldi	r24, 0x00	; 0
    509a:	42 c0       	rjmp	.+132    	; 0x5120 <StrCalc+0x22e>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    509c:	00 d0       	rcall	.+0      	; 0x509e <StrCalc+0x1ac>
    509e:	00 d0       	rcall	.+0      	; 0x50a0 <StrCalc+0x1ae>
    50a0:	00 d0       	rcall	.+0      	; 0x50a2 <StrCalc+0x1b0>
    50a2:	ed b7       	in	r30, 0x3d	; 61
    50a4:	fe b7       	in	r31, 0x3e	; 62
    50a6:	31 96       	adiw	r30, 0x01	; 1
    50a8:	8e 01       	movw	r16, r28
    50aa:	07 5d       	subi	r16, 0xD7	; 215
    50ac:	1f 4f       	sbci	r17, 0xFF	; 255
    50ae:	ad b7       	in	r26, 0x3d	; 61
    50b0:	be b7       	in	r27, 0x3e	; 62
    50b2:	12 96       	adiw	r26, 0x02	; 2
    50b4:	1c 93       	st	X, r17
    50b6:	0e 93       	st	-X, r16
    50b8:	11 97       	sbiw	r26, 0x01	; 1
    50ba:	80 e0       	ldi	r24, 0x00	; 0
    50bc:	95 e0       	ldi	r25, 0x05	; 5
    50be:	93 83       	std	Z+3, r25	; 0x03
    50c0:	82 83       	std	Z+2, r24	; 0x02
    50c2:	f5 82       	std	Z+5, r15	; 0x05
    50c4:	e4 82       	std	Z+4, r14	; 0x04
    50c6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    50ca:	ed b7       	in	r30, 0x3d	; 61
    50cc:	fe b7       	in	r31, 0x3e	; 62
    50ce:	31 96       	adiw	r30, 0x01	; 1
    50d0:	ad b7       	in	r26, 0x3d	; 61
    50d2:	be b7       	in	r27, 0x3e	; 62
    50d4:	12 96       	adiw	r26, 0x02	; 2
    50d6:	fc 92       	st	X, r15
    50d8:	ee 92       	st	-X, r14
    50da:	11 97       	sbiw	r26, 0x01	; 1
    50dc:	8d ef       	ldi	r24, 0xFD	; 253
    50de:	94 e0       	ldi	r25, 0x04	; 4
    50e0:	93 83       	std	Z+3, r25	; 0x03
    50e2:	82 83       	std	Z+2, r24	; 0x02
    50e4:	d5 82       	std	Z+5, r13	; 0x05
    50e6:	c4 82       	std	Z+4, r12	; 0x04
    50e8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    50ec:	ed b7       	in	r30, 0x3d	; 61
    50ee:	fe b7       	in	r31, 0x3e	; 62
    50f0:	31 96       	adiw	r30, 0x01	; 1
    50f2:	ad b7       	in	r26, 0x3d	; 61
    50f4:	be b7       	in	r27, 0x3e	; 62
    50f6:	12 96       	adiw	r26, 0x02	; 2
    50f8:	dc 92       	st	X, r13
    50fa:	ce 92       	st	-X, r12
    50fc:	11 97       	sbiw	r26, 0x01	; 1
    50fe:	8a ef       	ldi	r24, 0xFA	; 250
    5100:	94 e0       	ldi	r25, 0x04	; 4
    5102:	93 83       	std	Z+3, r25	; 0x03
    5104:	82 83       	std	Z+2, r24	; 0x02
    5106:	15 83       	std	Z+5, r17	; 0x05
    5108:	04 83       	std	Z+4, r16	; 0x04
    510a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    510e:	81 e0       	ldi	r24, 0x01	; 1
    5110:	ed b7       	in	r30, 0x3d	; 61
    5112:	fe b7       	in	r31, 0x3e	; 62
    5114:	36 96       	adiw	r30, 0x06	; 6
    5116:	0f b6       	in	r0, 0x3f	; 63
    5118:	f8 94       	cli
    511a:	fe bf       	out	0x3e, r31	; 62
    511c:	0f be       	out	0x3f, r0	; 63
    511e:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    5120:	66 20       	and	r6, r6
    5122:	39 f5       	brne	.+78     	; 0x5172 <StrCalc+0x280>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5124:	81 30       	cpi	r24, 0x01	; 1
    5126:	99 f4       	brne	.+38     	; 0x514e <StrCalc+0x25c>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    5128:	65 96       	adiw	r28, 0x15	; 21
    512a:	ff ad       	ldd	r31, Y+63	; 0x3f
    512c:	65 97       	sbiw	r28, 0x15	; 21
    512e:	f1 30       	cpi	r31, 0x01	; 1
    5130:	39 f4       	brne	.+14     	; 0x5140 <StrCalc+0x24e>
    5132:	64 96       	adiw	r28, 0x14	; 20
    5134:	2f ad       	ldd	r18, Y+63	; 0x3f
    5136:	64 97       	sbiw	r28, 0x14	; 20
    5138:	21 30       	cpi	r18, 0x01	; 1
    513a:	09 f0       	breq	.+2      	; 0x513e <StrCalc+0x24c>
    513c:	9e c1       	rjmp	.+828    	; 0x547a <StrCalc+0x588>
    513e:	42 c0       	rjmp	.+132    	; 0x51c4 <StrCalc+0x2d2>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    5140:	64 96       	adiw	r28, 0x14	; 20
    5142:	3f ad       	ldd	r19, Y+63	; 0x3f
    5144:	64 97       	sbiw	r28, 0x14	; 20
    5146:	31 30       	cpi	r19, 0x01	; 1
    5148:	09 f0       	breq	.+2      	; 0x514c <StrCalc+0x25a>
    514a:	8e c1       	rjmp	.+796    	; 0x5468 <StrCalc+0x576>
    514c:	92 c1       	rjmp	.+804    	; 0x5472 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    514e:	65 96       	adiw	r28, 0x15	; 21
    5150:	8f ad       	ldd	r24, Y+63	; 0x3f
    5152:	65 97       	sbiw	r28, 0x15	; 21
    5154:	81 30       	cpi	r24, 0x01	; 1
    5156:	39 f4       	brne	.+14     	; 0x5166 <StrCalc+0x274>
    5158:	64 96       	adiw	r28, 0x14	; 20
    515a:	9f ad       	ldd	r25, Y+63	; 0x3f
    515c:	64 97       	sbiw	r28, 0x14	; 20
    515e:	91 30       	cpi	r25, 0x01	; 1
    5160:	09 f0       	breq	.+2      	; 0x5164 <StrCalc+0x272>
    5162:	8b c1       	rjmp	.+790    	; 0x547a <StrCalc+0x588>
    5164:	81 c1       	rjmp	.+770    	; 0x5468 <StrCalc+0x576>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    5166:	64 96       	adiw	r28, 0x14	; 20
    5168:	af ad       	ldd	r26, Y+63	; 0x3f
    516a:	64 97       	sbiw	r28, 0x14	; 20
    516c:	a1 30       	cpi	r26, 0x01	; 1
    516e:	51 f5       	brne	.+84     	; 0x51c4 <StrCalc+0x2d2>
    5170:	80 c1       	rjmp	.+768    	; 0x5472 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    5172:	b1 e0       	ldi	r27, 0x01	; 1
    5174:	6b 16       	cp	r6, r27
    5176:	31 f5       	brne	.+76     	; 0x51c4 <StrCalc+0x2d2>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5178:	81 30       	cpi	r24, 0x01	; 1
    517a:	91 f4       	brne	.+36     	; 0x51a0 <StrCalc+0x2ae>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    517c:	65 96       	adiw	r28, 0x15	; 21
    517e:	ef ad       	ldd	r30, Y+63	; 0x3f
    5180:	65 97       	sbiw	r28, 0x15	; 21
    5182:	e1 30       	cpi	r30, 0x01	; 1
    5184:	31 f4       	brne	.+12     	; 0x5192 <StrCalc+0x2a0>
    5186:	64 96       	adiw	r28, 0x14	; 20
    5188:	ff ad       	ldd	r31, Y+63	; 0x3f
    518a:	64 97       	sbiw	r28, 0x14	; 20
    518c:	f1 30       	cpi	r31, 0x01	; 1
    518e:	d1 f4       	brne	.+52     	; 0x51c4 <StrCalc+0x2d2>
    5190:	74 c1       	rjmp	.+744    	; 0x547a <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5192:	64 96       	adiw	r28, 0x14	; 20
    5194:	2f ad       	ldd	r18, Y+63	; 0x3f
    5196:	64 97       	sbiw	r28, 0x14	; 20
    5198:	21 30       	cpi	r18, 0x01	; 1
    519a:	09 f0       	breq	.+2      	; 0x519e <StrCalc+0x2ac>
    519c:	6a c1       	rjmp	.+724    	; 0x5472 <StrCalc+0x580>
    519e:	64 c1       	rjmp	.+712    	; 0x5468 <StrCalc+0x576>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    51a0:	65 96       	adiw	r28, 0x15	; 21
    51a2:	3f ad       	ldd	r19, Y+63	; 0x3f
    51a4:	65 97       	sbiw	r28, 0x15	; 21
    51a6:	31 30       	cpi	r19, 0x01	; 1
    51a8:	39 f4       	brne	.+14     	; 0x51b8 <StrCalc+0x2c6>
    51aa:	64 96       	adiw	r28, 0x14	; 20
    51ac:	8f ad       	ldd	r24, Y+63	; 0x3f
    51ae:	64 97       	sbiw	r28, 0x14	; 20
    51b0:	81 30       	cpi	r24, 0x01	; 1
    51b2:	09 f0       	breq	.+2      	; 0x51b6 <StrCalc+0x2c4>
    51b4:	59 c1       	rjmp	.+690    	; 0x5468 <StrCalc+0x576>
    51b6:	61 c1       	rjmp	.+706    	; 0x547a <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    51b8:	64 96       	adiw	r28, 0x14	; 20
    51ba:	9f ad       	ldd	r25, Y+63	; 0x3f
    51bc:	64 97       	sbiw	r28, 0x14	; 20
    51be:	91 30       	cpi	r25, 0x01	; 1
    51c0:	09 f0       	breq	.+2      	; 0x51c4 <StrCalc+0x2d2>
    51c2:	57 c1       	rjmp	.+686    	; 0x5472 <StrCalc+0x580>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    51c4:	62 96       	adiw	r28, 0x12	; 18
    51c6:	1f ae       	std	Y+63, r1	; 0x3f
    51c8:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    51ca:	e7 2c       	mov	r14, r7
    51cc:	ff 24       	eor	r15, r15
    51ce:	67 01       	movw	r12, r14
    51d0:	08 94       	sec
    51d2:	c1 08       	sbc	r12, r1
    51d4:	d1 08       	sbc	r13, r1
    51d6:	ae 01       	movw	r20, r28
    51d8:	43 5c       	subi	r20, 0xC3	; 195
    51da:	5f 4f       	sbci	r21, 0xFF	; 255
    51dc:	4c 0d       	add	r20, r12
    51de:	5d 1d       	adc	r21, r13
    51e0:	ce 01       	movw	r24, r28
    51e2:	01 96       	adiw	r24, 0x01	; 1
    51e4:	8c 01       	movw	r16, r24
    51e6:	0c 0d       	add	r16, r12
    51e8:	1d 1d       	adc	r17, r13
    51ea:	be 01       	movw	r22, r28
    51ec:	69 0d       	add	r22, r9
    51ee:	71 1d       	adc	r23, r1
    51f0:	6c 5e       	subi	r22, 0xEC	; 236
    51f2:	7f 4f       	sbci	r23, 0xFF	; 255
    51f4:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    51f6:	2c 01       	movw	r4, r24
    51f8:	89 e3       	ldi	r24, 0x39	; 57
    51fa:	88 2e       	mov	r8, r24
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    51fc:	9a e0       	ldi	r25, 0x0A	; 10
    51fe:	52 c0       	rjmp	.+164    	; 0x52a4 <StrCalc+0x3b2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5200:	d8 01       	movw	r26, r16
    5202:	8c 91       	ld	r24, X
    5204:	80 53       	subi	r24, 0x30	; 48
    5206:	8a 30       	cpi	r24, 0x0A	; 10
    5208:	10 f0       	brcs	.+4      	; 0x520e <StrCalc+0x31c>
    520a:	20 e0       	ldi	r18, 0x00	; 0
    520c:	01 c0       	rjmp	.+2      	; 0x5210 <StrCalc+0x31e>
    520e:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    5210:	fb 01       	movw	r30, r22
    5212:	30 81       	ld	r19, Z
    5214:	30 53       	subi	r19, 0x30	; 48
    5216:	3a 30       	cpi	r19, 0x0A	; 10
    5218:	10 f4       	brcc	.+4      	; 0x521e <StrCalc+0x32c>
    521a:	23 17       	cp	r18, r19
    521c:	40 f0       	brcs	.+16     	; 0x522e <StrCalc+0x33c>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    521e:	8a 30       	cpi	r24, 0x0A	; 10
    5220:	08 f0       	brcs	.+2      	; 0x5224 <StrCalc+0x332>
    5222:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5224:	3a 30       	cpi	r19, 0x0A	; 10
    5226:	08 f0       	brcs	.+2      	; 0x522a <StrCalc+0x338>
    5228:	30 e0       	ldi	r19, 0x00	; 0
    522a:	83 1b       	sub	r24, r19
    522c:	2d c0       	rjmp	.+90     	; 0x5288 <StrCalc+0x396>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    522e:	8a 30       	cpi	r24, 0x0A	; 10
    5230:	10 f4       	brcc	.+4      	; 0x5236 <StrCalc+0x344>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    5232:	83 17       	cp	r24, r19
    5234:	80 f5       	brcc	.+96     	; 0x5296 <StrCalc+0x3a4>
    5236:	29 2d       	mov	r18, r9
    5238:	0a c0       	rjmp	.+20     	; 0x524e <StrCalc+0x35c>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    523a:	f6 01       	movw	r30, r12
    523c:	e2 1b       	sub	r30, r18
    523e:	f1 09       	sbc	r31, r1
    5240:	d2 01       	movw	r26, r4
    5242:	ae 0f       	add	r26, r30
    5244:	bf 1f       	adc	r27, r31
    5246:	8c 91       	ld	r24, X
    5248:	80 33       	cpi	r24, 0x30	; 48
    524a:	29 f4       	brne	.+10     	; 0x5256 <StrCalc+0x364>
    524c:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    524e:	2f 5f       	subi	r18, 0xFF	; 255
    5250:	27 15       	cp	r18, r7
    5252:	98 f3       	brcs	.-26     	; 0x523a <StrCalc+0x348>
    5254:	10 c0       	rjmp	.+32     	; 0x5276 <StrCalc+0x384>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5256:	28 2f       	mov	r18, r24
    5258:	20 53       	subi	r18, 0x30	; 48
    525a:	2a 30       	cpi	r18, 0x0A	; 10
    525c:	08 f0       	brcs	.+2      	; 0x5260 <StrCalc+0x36e>
    525e:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5260:	82 2f       	mov	r24, r18
    5262:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5264:	8a 30       	cpi	r24, 0x0A	; 10
    5266:	10 f0       	brcs	.+4      	; 0x526c <StrCalc+0x37a>
    5268:	80 e3       	ldi	r24, 0x30	; 48
    526a:	02 c0       	rjmp	.+4      	; 0x5270 <StrCalc+0x37e>
	    Result='0'+X;
    526c:	82 2f       	mov	r24, r18
    526e:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5270:	e4 0d       	add	r30, r4
    5272:	f5 1d       	adc	r31, r5
    5274:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5276:	f8 01       	movw	r30, r16
    5278:	20 81       	ld	r18, Z
    527a:	20 53       	subi	r18, 0x30	; 48
    527c:	2a 30       	cpi	r18, 0x0A	; 10
    527e:	08 f0       	brcs	.+2      	; 0x5282 <StrCalc+0x390>
    5280:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5282:	89 2f       	mov	r24, r25
    5284:	83 1b       	sub	r24, r19
    5286:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5288:	8a 30       	cpi	r24, 0x0A	; 10
    528a:	10 f0       	brcs	.+4      	; 0x5290 <StrCalc+0x39e>
    528c:	80 e3       	ldi	r24, 0x30	; 48
    528e:	01 c0       	rjmp	.+2      	; 0x5292 <StrCalc+0x3a0>
	    Result='0'+X;
    5290:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5292:	da 01       	movw	r26, r20
    5294:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    5296:	93 94       	inc	r9
    5298:	41 50       	subi	r20, 0x01	; 1
    529a:	50 40       	sbci	r21, 0x00	; 0
    529c:	01 50       	subi	r16, 0x01	; 1
    529e:	10 40       	sbci	r17, 0x00	; 0
    52a0:	61 50       	subi	r22, 0x01	; 1
    52a2:	70 40       	sbci	r23, 0x00	; 0
    52a4:	97 14       	cp	r9, r7
    52a6:	08 f4       	brcc	.+2      	; 0x52aa <StrCalc+0x3b8>
    52a8:	ab cf       	rjmp	.-170    	; 0x5200 <StrCalc+0x30e>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    52aa:	8e 01       	movw	r16, r28
    52ac:	03 5c       	subi	r16, 0xC3	; 195
    52ae:	1f 4f       	sbci	r17, 0xFF	; 255
    52b0:	e0 0e       	add	r14, r16
    52b2:	f1 1e       	adc	r15, r17
    52b4:	f7 01       	movw	r30, r14
    52b6:	10 82       	st	Z, r1
       RemZeroLead(Result);
    52b8:	c8 01       	movw	r24, r16
    52ba:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    52be:	f8 01       	movw	r30, r16
    52c0:	01 90       	ld	r0, Z+
    52c2:	00 20       	and	r0, r0
    52c4:	e9 f7       	brne	.-6      	; 0x52c0 <StrCalc+0x3ce>
    52c6:	31 97       	sbiw	r30, 0x01	; 1
    52c8:	3e 2f       	mov	r19, r30
    52ca:	30 1b       	sub	r19, r16
    52cc:	d8 01       	movw	r26, r16
    52ce:	20 e0       	ldi	r18, 0x00	; 0
    52d0:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    52d2:	4d e2       	ldi	r20, 0x2D	; 45
    52d4:	13 c0       	rjmp	.+38     	; 0x52fc <StrCalc+0x40a>
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    52d6:	22 23       	and	r18, r18
    52d8:	51 f4       	brne	.+20     	; 0x52ee <StrCalc+0x3fc>
    52da:	62 96       	adiw	r28, 0x12	; 18
    52dc:	ff ad       	ldd	r31, Y+63	; 0x3f
    52de:	62 97       	sbiw	r28, 0x12	; 18
    52e0:	f1 30       	cpi	r31, 0x01	; 1
    52e2:	29 f4       	brne	.+10     	; 0x52ee <StrCalc+0x3fc>
			     strC[iPos]='-';
    52e4:	f5 01       	movw	r30, r10
    52e6:	e9 0f       	add	r30, r25
    52e8:	f1 1d       	adc	r31, r1
    52ea:	40 83       	st	Z, r20
				 iPos++;
    52ec:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    52ee:	f5 01       	movw	r30, r10
    52f0:	e9 0f       	add	r30, r25
    52f2:	f1 1d       	adc	r31, r1
    52f4:	8d 91       	ld	r24, X+
    52f6:	80 83       	st	Z, r24
			 iPos++;
    52f8:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    52fa:	2f 5f       	subi	r18, 0xFF	; 255
    52fc:	23 17       	cp	r18, r19
    52fe:	58 f3       	brcs	.-42     	; 0x52d6 <StrCalc+0x3e4>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    5300:	f5 01       	movw	r30, r10
    5302:	e9 0f       	add	r30, r25
    5304:	f1 1d       	adc	r31, r1
    5306:	10 82       	st	Z, r1
    5308:	a0 c0       	rjmp	.+320    	; 0x544a <StrCalc+0x558>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    530a:	bd e3       	ldi	r27, 0x3D	; 61
    530c:	eb 2e       	mov	r14, r27
    530e:	f1 2c       	mov	r15, r1
    5310:	ec 0e       	add	r14, r28
    5312:	fd 1e       	adc	r15, r29
    5314:	ae 01       	movw	r20, r28
    5316:	49 0d       	add	r20, r9
    5318:	51 1d       	adc	r21, r1
    531a:	4c 5e       	subi	r20, 0xEC	; 236
    531c:	5f 4f       	sbci	r21, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    531e:	07 2d       	mov	r16, r7
    5320:	10 e0       	ldi	r17, 0x00	; 0
    5322:	48 01       	movw	r8, r16
    5324:	08 94       	sec
    5326:	81 08       	sbc	r8, r1
    5328:	91 08       	sbc	r9, r1
    532a:	ce 01       	movw	r24, r28
    532c:	01 96       	adiw	r24, 0x01	; 1
    532e:	6c 01       	movw	r12, r24
    5330:	c8 0c       	add	r12, r8
    5332:	d9 1c       	adc	r13, r9
    5334:	30 e0       	ldi	r19, 0x00	; 0
    5336:	20 e0       	ldi	r18, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5338:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    533a:	a0 e3       	ldi	r26, 0x30	; 48
    533c:	3a 2e       	mov	r3, r26
    533e:	47 c0       	rjmp	.+142    	; 0x53ce <StrCalc+0x4dc>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5340:	d6 01       	movw	r26, r12
    5342:	9c 91       	ld	r25, X
    5344:	90 53       	subi	r25, 0x30	; 48
    5346:	9a 30       	cpi	r25, 0x0A	; 10
    5348:	08 f0       	brcs	.+2      	; 0x534c <StrCalc+0x45a>
    534a:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    534c:	fa 01       	movw	r30, r20
    534e:	80 81       	ld	r24, Z
    5350:	80 53       	subi	r24, 0x30	; 48
    5352:	8a 30       	cpi	r24, 0x0A	; 10
    5354:	08 f0       	brcs	.+2      	; 0x5358 <StrCalc+0x466>
    5356:	80 e0       	ldi	r24, 0x00	; 0
    5358:	89 0f       	add	r24, r25
			 if (newC<10){
    535a:	8a 30       	cpi	r24, 0x0A	; 10
    535c:	18 f4       	brcc	.+6      	; 0x5364 <StrCalc+0x472>
			     Result[i]=Chr(newC);
    535e:	80 5d       	subi	r24, 0xD0	; 208
    5360:	d7 01       	movw	r26, r14
    5362:	28 c0       	rjmp	.+80     	; 0x53b4 <StrCalc+0x4c2>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5364:	6a e0       	ldi	r22, 0x0A	; 10
    5366:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    536a:	9a 30       	cpi	r25, 0x0A	; 10
    536c:	10 f0       	brcs	.+4      	; 0x5372 <StrCalc+0x480>
    536e:	90 e3       	ldi	r25, 0x30	; 48
    5370:	01 c0       	rjmp	.+2      	; 0x5374 <StrCalc+0x482>
	    Result='0'+X;
    5372:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5374:	f7 01       	movw	r30, r14
    5376:	90 83       	st	Z, r25
    5378:	83 2f       	mov	r24, r19
    537a:	0e c0       	rjmp	.+28     	; 0x5398 <StrCalc+0x4a6>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    537c:	d4 01       	movw	r26, r8
    537e:	a8 1b       	sub	r26, r24
    5380:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5382:	f2 01       	movw	r30, r4
    5384:	ea 0f       	add	r30, r26
    5386:	fb 1f       	adc	r31, r27
    5388:	90 81       	ld	r25, Z
    538a:	90 53       	subi	r25, 0x30	; 48
    538c:	9a 30       	cpi	r25, 0x0A	; 10
    538e:	08 f0       	brcs	.+2      	; 0x5392 <StrCalc+0x4a0>
    5390:	79 c0       	rjmp	.+242    	; 0x5484 <StrCalc+0x592>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5392:	99 30       	cpi	r25, 0x09	; 9
    5394:	29 f4       	brne	.+10     	; 0x53a0 <StrCalc+0x4ae>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5396:	30 82       	st	Z, r3
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    5398:	8f 5f       	subi	r24, 0xFF	; 255
    539a:	87 15       	cp	r24, r7
    539c:	78 f3       	brcs	.-34     	; 0x537c <StrCalc+0x48a>
    539e:	0d c0       	rjmp	.+26     	; 0x53ba <StrCalc+0x4c8>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    53a0:	89 2f       	mov	r24, r25
    53a2:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    53a4:	8a 30       	cpi	r24, 0x0A	; 10
    53a6:	10 f0       	brcs	.+4      	; 0x53ac <StrCalc+0x4ba>
    53a8:	80 e3       	ldi	r24, 0x30	; 48
    53aa:	02 c0       	rjmp	.+4      	; 0x53b0 <StrCalc+0x4be>
	    Result='0'+X;
    53ac:	89 2f       	mov	r24, r25
    53ae:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    53b0:	a4 0d       	add	r26, r4
    53b2:	b5 1d       	adc	r27, r5
    53b4:	8c 93       	st	X, r24
    53b6:	20 e0       	ldi	r18, 0x00	; 0
    53b8:	01 c0       	rjmp	.+2      	; 0x53bc <StrCalc+0x4ca>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    53ba:	21 e0       	ldi	r18, 0x01	; 1
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    53bc:	3f 5f       	subi	r19, 0xFF	; 255
    53be:	08 94       	sec
    53c0:	e1 1c       	adc	r14, r1
    53c2:	f1 1c       	adc	r15, r1
    53c4:	41 50       	subi	r20, 0x01	; 1
    53c6:	50 40       	sbci	r21, 0x00	; 0
    53c8:	08 94       	sec
    53ca:	c1 08       	sbc	r12, r1
    53cc:	d1 08       	sbc	r13, r1
    53ce:	37 15       	cp	r19, r7
    53d0:	08 f4       	brcc	.+2      	; 0x53d4 <StrCalc+0x4e2>
    53d2:	b6 cf       	rjmp	.-148    	; 0x5340 <StrCalc+0x44e>
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    53d4:	20 5d       	subi	r18, 0xD0	; 208
				 }//EndFor j                
			   }//End else
			 }//EndFor

		  //Result[lenA]==Chr(zMin); ???
		  Result[lenA]=Chr(zMin);
    53d6:	de 01       	movw	r26, r28
    53d8:	dd 96       	adiw	r26, 0x3d	; 61
    53da:	fd 01       	movw	r30, r26
    53dc:	e0 0f       	add	r30, r16
    53de:	f1 1f       	adc	r31, r17
    53e0:	20 83       	st	Z, r18
		  Result[lenA+1]=0;
    53e2:	0c 0f       	add	r16, r28
    53e4:	1d 1f       	adc	r17, r29
    53e6:	f8 01       	movw	r30, r16
    53e8:	16 ae       	std	Z+62, r1	; 0x3e
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    53ea:	fd 01       	movw	r30, r26
    53ec:	01 90       	ld	r0, Z+
    53ee:	00 20       	and	r0, r0
    53f0:	e9 f7       	brne	.-6      	; 0x53ec <StrCalc+0x4fa>
    53f2:	31 97       	sbiw	r30, 0x01	; 1
    53f4:	5e 2f       	mov	r21, r30
    53f6:	5a 1b       	sub	r21, r26
    53f8:	25 2f       	mov	r18, r21
    53fa:	30 e0       	ldi	r19, 0x00	; 0
    53fc:	21 50       	subi	r18, 0x01	; 1
    53fe:	30 40       	sbci	r19, 0x00	; 0
    5400:	2a 0f       	add	r18, r26
    5402:	3b 1f       	adc	r19, r27
    5404:	40 e0       	ldi	r20, 0x00	; 0
    5406:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    5408:	6d e2       	ldi	r22, 0x2D	; 45
    540a:	16 c0       	rjmp	.+44     	; 0x5438 <StrCalc+0x546>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    540c:	44 23       	and	r20, r20
    540e:	51 f4       	brne	.+20     	; 0x5424 <StrCalc+0x532>
    5410:	63 96       	adiw	r28, 0x13	; 19
    5412:	ff ad       	ldd	r31, Y+63	; 0x3f
    5414:	63 97       	sbiw	r28, 0x13	; 19
    5416:	f1 30       	cpi	r31, 0x01	; 1
    5418:	29 f4       	brne	.+10     	; 0x5424 <StrCalc+0x532>
			     strC[iPos]='-';
    541a:	f5 01       	movw	r30, r10
    541c:	e9 0f       	add	r30, r25
    541e:	f1 1d       	adc	r31, r1
    5420:	60 83       	st	Z, r22
				 iPos++;
    5422:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    5424:	f5 01       	movw	r30, r10
    5426:	e9 0f       	add	r30, r25
    5428:	f1 1d       	adc	r31, r1
    542a:	d9 01       	movw	r26, r18
    542c:	8c 91       	ld	r24, X
    542e:	80 83       	st	Z, r24
			 iPos++;
    5430:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5432:	4f 5f       	subi	r20, 0xFF	; 255
    5434:	21 50       	subi	r18, 0x01	; 1
    5436:	30 40       	sbci	r19, 0x00	; 0
    5438:	45 17       	cp	r20, r21
    543a:	40 f3       	brcs	.-48     	; 0x540c <StrCalc+0x51a>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    543c:	f5 01       	movw	r30, r10
    543e:	e9 0f       	add	r30, r25
    5440:	f1 1d       	adc	r31, r1
    5442:	10 82       	st	Z, r1

       RemZeroLead(strC);
    5444:	c5 01       	movw	r24, r10
    5446:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    544a:	b2 e0       	ldi	r27, 0x02	; 2
    544c:	6b 16       	cp	r6, r27
    544e:	e1 f4       	brne	.+56     	; 0x5488 <StrCalc+0x596>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    5450:	67 96       	adiw	r28, 0x17	; 23
    5452:	8e ad       	ldd	r24, Y+62	; 0x3e
    5454:	9f ad       	ldd	r25, Y+63	; 0x3f
    5456:	67 97       	sbiw	r28, 0x17	; 23
    5458:	69 96       	adiw	r28, 0x19	; 25
    545a:	6e ad       	ldd	r22, Y+62	; 0x3e
    545c:	7f ad       	ldd	r23, Y+63	; 0x3f
    545e:	69 97       	sbiw	r28, 0x19	; 25
    5460:	a5 01       	movw	r20, r10
    5462:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <CalcMultiply>
    5466:	10 c0       	rjmp	.+32     	; 0x5488 <StrCalc+0x596>
	 }
}
    5468:	e1 e0       	ldi	r30, 0x01	; 1
    546a:	62 96       	adiw	r28, 0x12	; 18
    546c:	ef af       	std	Y+63, r30	; 0x3f
    546e:	62 97       	sbiw	r28, 0x12	; 18
    5470:	ac ce       	rjmp	.-680    	; 0x51ca <StrCalc+0x2d8>
    5472:	63 96       	adiw	r28, 0x13	; 19
    5474:	1f ae       	std	Y+63, r1	; 0x3f
    5476:	63 97       	sbiw	r28, 0x13	; 19
    5478:	48 cf       	rjmp	.-368    	; 0x530a <StrCalc+0x418>
    547a:	f1 e0       	ldi	r31, 0x01	; 1
    547c:	63 96       	adiw	r28, 0x13	; 19
    547e:	ff af       	std	Y+63, r31	; 0x3f
    5480:	63 97       	sbiw	r28, 0x13	; 19
    5482:	43 cf       	rjmp	.-378    	; 0x530a <StrCalc+0x418>
    5484:	90 e0       	ldi	r25, 0x00	; 0
    5486:	8c cf       	rjmp	.-232    	; 0x53a0 <StrCalc+0x4ae>
    5488:	c8 5a       	subi	r28, 0xA8	; 168
    548a:	df 4f       	sbci	r29, 0xFF	; 255
    548c:	0f b6       	in	r0, 0x3f	; 63
    548e:	f8 94       	cli
    5490:	de bf       	out	0x3e, r29	; 62
    5492:	0f be       	out	0x3f, r0	; 63
    5494:	cd bf       	out	0x3d, r28	; 61
    5496:	cf 91       	pop	r28
    5498:	df 91       	pop	r29
    549a:	1f 91       	pop	r17
    549c:	0f 91       	pop	r16
    549e:	ff 90       	pop	r15
    54a0:	ef 90       	pop	r14
    54a2:	df 90       	pop	r13
    54a4:	cf 90       	pop	r12
    54a6:	bf 90       	pop	r11
    54a8:	af 90       	pop	r10
    54aa:	9f 90       	pop	r9
    54ac:	8f 90       	pop	r8
    54ae:	7f 90       	pop	r7
    54b0:	6f 90       	pop	r6
    54b2:	5f 90       	pop	r5
    54b4:	4f 90       	pop	r4
    54b6:	3f 90       	pop	r3
    54b8:	08 95       	ret

000054ba <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    54ba:	4f 92       	push	r4
    54bc:	5f 92       	push	r5
    54be:	6f 92       	push	r6
    54c0:	7f 92       	push	r7
    54c2:	8f 92       	push	r8
    54c4:	9f 92       	push	r9
    54c6:	af 92       	push	r10
    54c8:	bf 92       	push	r11
    54ca:	cf 92       	push	r12
    54cc:	df 92       	push	r13
    54ce:	ef 92       	push	r14
    54d0:	ff 92       	push	r15
    54d2:	0f 93       	push	r16
    54d4:	1f 93       	push	r17
    54d6:	df 93       	push	r29
    54d8:	cf 93       	push	r28
    54da:	cd b7       	in	r28, 0x3d	; 61
    54dc:	de b7       	in	r29, 0x3e	; 62
    54de:	a8 97       	sbiw	r28, 0x28	; 40
    54e0:	0f b6       	in	r0, 0x3f	; 63
    54e2:	f8 94       	cli
    54e4:	de bf       	out	0x3e, r29	; 62
    54e6:	0f be       	out	0x3f, r0	; 63
    54e8:	cd bf       	out	0x3d, r28	; 61
    54ea:	3c 01       	movw	r6, r24
    54ec:	6b 01       	movw	r12, r22
    54ee:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    54f0:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
     RemZeroLead(strB);
    54f4:	c6 01       	movw	r24, r12
    54f6:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
	 lenB=strlen(strB);
    54fa:	d6 01       	movw	r26, r12
    54fc:	0d 90       	ld	r0, X+
    54fe:	00 20       	and	r0, r0
    5500:	e9 f7       	brne	.-6      	; 0x54fc <CalcMultiply+0x42>
    5502:	11 97       	sbiw	r26, 0x01	; 1
    5504:	8a 2e       	mov	r8, r26
    5506:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    5508:	00 d0       	rcall	.+0      	; 0x550a <CalcMultiply+0x50>
    550a:	00 d0       	rcall	.+0      	; 0x550c <CalcMultiply+0x52>
    550c:	8e 01       	movw	r16, r28
    550e:	0f 5f       	subi	r16, 0xFF	; 255
    5510:	1f 4f       	sbci	r17, 0xFF	; 255
    5512:	ad b7       	in	r26, 0x3d	; 61
    5514:	be b7       	in	r27, 0x3e	; 62
    5516:	12 96       	adiw	r26, 0x02	; 2
    5518:	1c 93       	st	X, r17
    551a:	0e 93       	st	-X, r16
    551c:	11 97       	sbiw	r26, 0x01	; 1
    551e:	88 ef       	ldi	r24, 0xF8	; 248
    5520:	94 e0       	ldi	r25, 0x04	; 4
    5522:	14 96       	adiw	r26, 0x04	; 4
    5524:	9c 93       	st	X, r25
    5526:	8e 93       	st	-X, r24
    5528:	13 97       	sbiw	r26, 0x03	; 3
    552a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    552e:	25 e1       	ldi	r18, 0x15	; 21
    5530:	e2 2e       	mov	r14, r18
    5532:	f1 2c       	mov	r15, r1
    5534:	ec 0e       	add	r14, r28
    5536:	fd 1e       	adc	r15, r29
    5538:	ed b7       	in	r30, 0x3d	; 61
    553a:	fe b7       	in	r31, 0x3e	; 62
    553c:	f2 82       	std	Z+2, r15	; 0x02
    553e:	e1 82       	std	Z+1, r14	; 0x01
    5540:	86 ef       	ldi	r24, 0xF6	; 246
    5542:	94 e0       	ldi	r25, 0x04	; 4
    5544:	94 83       	std	Z+4, r25	; 0x04
    5546:	83 83       	std	Z+3, r24	; 0x03
    5548:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    554c:	bb 24       	eor	r11, r11
    554e:	0f 90       	pop	r0
    5550:	0f 90       	pop	r0
    5552:	0f 90       	pop	r0
    5554:	0f 90       	pop	r0
    5556:	a0 2e       	mov	r10, r16
    5558:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    555a:	08 2d       	mov	r16, r8
    555c:	10 e0       	ldi	r17, 0x00	; 0
    555e:	01 50       	subi	r16, 0x01	; 1
    5560:	10 40       	sbci	r17, 0x00	; 0
    5562:	1f c0       	rjmp	.+62     	; 0x55a2 <CalcMultiply+0xe8>
    5564:	f8 01       	movw	r30, r16
    5566:	e8 1b       	sub	r30, r24
    5568:	f9 0b       	sbc	r31, r25
    556a:	ec 0d       	add	r30, r12
    556c:	fd 1d       	adc	r31, r13
    556e:	c3 01       	movw	r24, r6
    5570:	60 81       	ld	r22, Z
    5572:	a7 01       	movw	r20, r14
    5574:	0e 94 c4 20 	call	0x4188	; 0x4188 <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    5578:	f7 01       	movw	r30, r14
    557a:	01 90       	ld	r0, Z+
    557c:	00 20       	and	r0, r0
    557e:	e9 f7       	brne	.-6      	; 0x557a <CalcMultiply+0xc0>
    5580:	31 97       	sbiw	r30, 0x01	; 1
    5582:	ee 19       	sub	r30, r14
    5584:	ff 09       	sbc	r31, r15
    5586:	6b 2d       	mov	r22, r11
    5588:	6e 0f       	add	r22, r30
    558a:	c7 01       	movw	r24, r14
    558c:	0e 94 5e 27 	call	0x4ebc	; 0x4ebc <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    5590:	81 e0       	ldi	r24, 0x01	; 1
    5592:	6a 2d       	mov	r22, r10
    5594:	79 2d       	mov	r23, r9
    5596:	a7 01       	movw	r20, r14
    5598:	2a 2d       	mov	r18, r10
    559a:	39 2d       	mov	r19, r9
    559c:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    55a0:	b3 94       	inc	r11
    55a2:	f6 01       	movw	r30, r12
    55a4:	01 90       	ld	r0, Z+
    55a6:	00 20       	and	r0, r0
    55a8:	e9 f7       	brne	.-6      	; 0x55a4 <CalcMultiply+0xea>
    55aa:	31 97       	sbiw	r30, 0x01	; 1
    55ac:	ec 19       	sub	r30, r12
    55ae:	fd 09       	sbc	r31, r13
    55b0:	8b 2d       	mov	r24, r11
    55b2:	90 e0       	ldi	r25, 0x00	; 0
    55b4:	8e 17       	cp	r24, r30
    55b6:	9f 07       	cpc	r25, r31
    55b8:	a8 f2       	brcs	.-86     	; 0x5564 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    55ba:	00 d0       	rcall	.+0      	; 0x55bc <CalcMultiply+0x102>
    55bc:	00 d0       	rcall	.+0      	; 0x55be <CalcMultiply+0x104>
    55be:	00 d0       	rcall	.+0      	; 0x55c0 <CalcMultiply+0x106>
    55c0:	ed b7       	in	r30, 0x3d	; 61
    55c2:	fe b7       	in	r31, 0x3e	; 62
    55c4:	31 96       	adiw	r30, 0x01	; 1
    55c6:	ad b7       	in	r26, 0x3d	; 61
    55c8:	be b7       	in	r27, 0x3e	; 62
    55ca:	12 96       	adiw	r26, 0x02	; 2
    55cc:	5c 92       	st	X, r5
    55ce:	4e 92       	st	-X, r4
    55d0:	11 97       	sbiw	r26, 0x01	; 1
    55d2:	83 ef       	ldi	r24, 0xF3	; 243
    55d4:	94 e0       	ldi	r25, 0x04	; 4
    55d6:	93 83       	std	Z+3, r25	; 0x03
    55d8:	82 83       	std	Z+2, r24	; 0x02
    55da:	a4 82       	std	Z+4, r10	; 0x04
    55dc:	95 82       	std	Z+5, r9	; 0x05
    55de:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    55e2:	ed b7       	in	r30, 0x3d	; 61
    55e4:	fe b7       	in	r31, 0x3e	; 62
    55e6:	36 96       	adiw	r30, 0x06	; 6
    55e8:	0f b6       	in	r0, 0x3f	; 63
    55ea:	f8 94       	cli
    55ec:	fe bf       	out	0x3e, r31	; 62
    55ee:	0f be       	out	0x3f, r0	; 63
    55f0:	ed bf       	out	0x3d, r30	; 61
}
    55f2:	a8 96       	adiw	r28, 0x28	; 40
    55f4:	0f b6       	in	r0, 0x3f	; 63
    55f6:	f8 94       	cli
    55f8:	de bf       	out	0x3e, r29	; 62
    55fa:	0f be       	out	0x3f, r0	; 63
    55fc:	cd bf       	out	0x3d, r28	; 61
    55fe:	cf 91       	pop	r28
    5600:	df 91       	pop	r29
    5602:	1f 91       	pop	r17
    5604:	0f 91       	pop	r16
    5606:	ff 90       	pop	r15
    5608:	ef 90       	pop	r14
    560a:	df 90       	pop	r13
    560c:	cf 90       	pop	r12
    560e:	bf 90       	pop	r11
    5610:	af 90       	pop	r10
    5612:	9f 90       	pop	r9
    5614:	8f 90       	pop	r8
    5616:	7f 90       	pop	r7
    5618:	6f 90       	pop	r6
    561a:	5f 90       	pop	r5
    561c:	4f 90       	pop	r4
    561e:	08 95       	ret

00005620 <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    5620:	cf 92       	push	r12
    5622:	df 92       	push	r13
    5624:	ef 92       	push	r14
    5626:	ff 92       	push	r15
    5628:	0f 93       	push	r16
    562a:	1f 93       	push	r17
    562c:	df 93       	push	r29
    562e:	cf 93       	push	r28
    5630:	cd b7       	in	r28, 0x3d	; 61
    5632:	de b7       	in	r29, 0x3e	; 62
    5634:	64 97       	sbiw	r28, 0x14	; 20
    5636:	0f b6       	in	r0, 0x3f	; 63
    5638:	f8 94       	cli
    563a:	de bf       	out	0x3e, r29	; 62
    563c:	0f be       	out	0x3f, r0	; 63
    563e:	cd bf       	out	0x3d, r28	; 61
    5640:	d8 2e       	mov	r13, r24
    5642:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    5644:	a8 2f       	mov	r26, r24
    5646:	b9 2f       	mov	r27, r25
    5648:	fd 01       	movw	r30, r26
    564a:	01 90       	ld	r0, Z+
    564c:	00 20       	and	r0, r0
    564e:	e9 f7       	brne	.-6      	; 0x564a <NormalizeOverflow+0x2a>
    5650:	31 97       	sbiw	r30, 0x01	; 1
    5652:	4e 2f       	mov	r20, r30
    5654:	48 1b       	sub	r20, r24
    5656:	20 e0       	ldi	r18, 0x00	; 0
    5658:	30 e0       	ldi	r19, 0x00	; 0
    565a:	7e 01       	movw	r14, r28
    565c:	08 94       	sec
    565e:	e1 1c       	adc	r14, r1
    5660:	f1 1c       	adc	r15, r1
    5662:	04 2f       	mov	r16, r20
    5664:	10 e0       	ldi	r17, 0x00	; 0
    5666:	0e c0       	rjmp	.+28     	; 0x5684 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    5668:	f7 01       	movw	r30, r14
    566a:	e2 0f       	add	r30, r18
    566c:	f3 1f       	adc	r31, r19
    566e:	c8 01       	movw	r24, r16
    5670:	82 1b       	sub	r24, r18
    5672:	93 0b       	sbc	r25, r19
    5674:	64 2f       	mov	r22, r20
    5676:	70 e0       	ldi	r23, 0x00	; 0
    5678:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    567c:	60 5d       	subi	r22, 0xD0	; 208
    567e:	60 83       	st	Z, r22
    5680:	2f 5f       	subi	r18, 0xFF	; 255
    5682:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    5684:	24 17       	cp	r18, r20
    5686:	80 f3       	brcs	.-32     	; 0x5668 <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    5688:	0e 0d       	add	r16, r14
    568a:	1f 1d       	adc	r17, r15
    568c:	f8 01       	movw	r30, r16
    568e:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    5690:	81 e0       	ldi	r24, 0x01	; 1
    5692:	b7 01       	movw	r22, r14
    5694:	4d 2d       	mov	r20, r13
    5696:	5c 2d       	mov	r21, r12
    5698:	2d 2d       	mov	r18, r13
    569a:	3c 2d       	mov	r19, r12
    569c:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>
}
    56a0:	64 96       	adiw	r28, 0x14	; 20
    56a2:	0f b6       	in	r0, 0x3f	; 63
    56a4:	f8 94       	cli
    56a6:	de bf       	out	0x3e, r29	; 62
    56a8:	0f be       	out	0x3f, r0	; 63
    56aa:	cd bf       	out	0x3d, r28	; 61
    56ac:	cf 91       	pop	r28
    56ae:	df 91       	pop	r29
    56b0:	1f 91       	pop	r17
    56b2:	0f 91       	pop	r16
    56b4:	ff 90       	pop	r15
    56b6:	ef 90       	pop	r14
    56b8:	df 90       	pop	r13
    56ba:	cf 90       	pop	r12
    56bc:	08 95       	ret

000056be <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    56be:	bf 92       	push	r11
    56c0:	cf 92       	push	r12
    56c2:	df 92       	push	r13
    56c4:	ef 92       	push	r14
    56c6:	ff 92       	push	r15
    56c8:	0f 93       	push	r16
    56ca:	1f 93       	push	r17
    56cc:	df 93       	push	r29
    56ce:	cf 93       	push	r28
    56d0:	cd b7       	in	r28, 0x3d	; 61
    56d2:	de b7       	in	r29, 0x3e	; 62
    56d4:	e2 97       	sbiw	r28, 0x32	; 50
    56d6:	0f b6       	in	r0, 0x3f	; 63
    56d8:	f8 94       	cli
    56da:	de bf       	out	0x3e, r29	; 62
    56dc:	0f be       	out	0x3f, r0	; 63
    56de:	cd bf       	out	0x3d, r28	; 61
    56e0:	8c 01       	movw	r16, r24
     char i,Length,strAdded[50];
     Length=strlen(String);
    56e2:	fc 01       	movw	r30, r24
    56e4:	01 90       	ld	r0, Z+
    56e6:	00 20       	and	r0, r0
    56e8:	e9 f7       	brne	.-6      	; 0x56e4 <AddSpaceLead+0x26>
    56ea:	31 97       	sbiw	r30, 0x01	; 1
    56ec:	2e 2f       	mov	r18, r30
    56ee:	28 1b       	sub	r18, r24

	 if (Size>Length){
    56f0:	26 17       	cp	r18, r22
    56f2:	e0 f5       	brcc	.+120    	; 0x576c <AddSpaceLead+0xae>
    56f4:	7e 01       	movw	r14, r28
    56f6:	08 94       	sec
    56f8:	e1 1c       	adc	r14, r1
    56fa:	f1 1c       	adc	r15, r1
    56fc:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    56fe:	be 2c       	mov	r11, r14
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    5700:	90 e2       	ldi	r25, 0x20	; 32
    5702:	01 c0       	rjmp	.+2      	; 0x5706 <AddSpaceLead+0x48>
    5704:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5706:	8e 2f       	mov	r24, r30
    5708:	8b 19       	sub	r24, r11
    570a:	86 17       	cp	r24, r22
    570c:	d8 f3       	brcs	.-10     	; 0x5704 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    570e:	46 2f       	mov	r20, r22
    5710:	50 e0       	ldi	r21, 0x00	; 0
    5712:	ce 01       	movw	r24, r28
    5714:	01 96       	adiw	r24, 0x01	; 1
    5716:	fc 01       	movw	r30, r24
    5718:	e4 0f       	add	r30, r20
    571a:	f5 1f       	adc	r31, r21
    571c:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    571e:	76 2f       	mov	r23, r22
    5720:	72 1b       	sub	r23, r18
    5722:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5724:	30 e0       	ldi	r19, 0x00	; 0
    5726:	24 1b       	sub	r18, r20
    5728:	35 0b       	sbc	r19, r21
    572a:	0c c0       	rjmp	.+24     	; 0x5744 <AddSpaceLead+0x86>
    572c:	e7 2f       	mov	r30, r23
    572e:	f0 e0       	ldi	r31, 0x00	; 0
    5730:	d6 01       	movw	r26, r12
    5732:	ae 0f       	add	r26, r30
    5734:	bf 1f       	adc	r27, r31
    5736:	e0 0f       	add	r30, r16
    5738:	f1 1f       	adc	r31, r17
    573a:	e2 0f       	add	r30, r18
    573c:	f3 1f       	adc	r31, r19
    573e:	80 81       	ld	r24, Z
    5740:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5742:	7f 5f       	subi	r23, 0xFF	; 255
    5744:	76 17       	cp	r23, r22
    5746:	90 f3       	brcs	.-28     	; 0x572c <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    5748:	4c 0d       	add	r20, r12
    574a:	5d 1d       	adc	r21, r13
    574c:	da 01       	movw	r26, r20
    574e:	1c 92       	st	X, r1
    5750:	f8 01       	movw	r30, r16
    5752:	04 c0       	rjmp	.+8      	; 0x575c <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5754:	d7 01       	movw	r26, r14
    5756:	8d 91       	ld	r24, X+
    5758:	7d 01       	movw	r14, r26
    575a:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    575c:	8e 2d       	mov	r24, r14
    575e:	8b 19       	sub	r24, r11
    5760:	86 17       	cp	r24, r22
    5762:	c0 f3       	brcs	.-16     	; 0x5754 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5764:	06 0f       	add	r16, r22
    5766:	11 1d       	adc	r17, r1
    5768:	f8 01       	movw	r30, r16
    576a:	10 82       	st	Z, r1
	 }
}
    576c:	e2 96       	adiw	r28, 0x32	; 50
    576e:	0f b6       	in	r0, 0x3f	; 63
    5770:	f8 94       	cli
    5772:	de bf       	out	0x3e, r29	; 62
    5774:	0f be       	out	0x3f, r0	; 63
    5776:	cd bf       	out	0x3d, r28	; 61
    5778:	cf 91       	pop	r28
    577a:	df 91       	pop	r29
    577c:	1f 91       	pop	r17
    577e:	0f 91       	pop	r16
    5780:	ff 90       	pop	r15
    5782:	ef 90       	pop	r14
    5784:	df 90       	pop	r13
    5786:	cf 90       	pop	r12
    5788:	bf 90       	pop	r11
    578a:	08 95       	ret

0000578c <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    578c:	cf 93       	push	r28
    578e:	df 93       	push	r29
    5790:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5792:	dc 01       	movw	r26, r24
    5794:	0d 90       	ld	r0, X+
    5796:	00 20       	and	r0, r0
    5798:	e9 f7       	brne	.-6      	; 0x5794 <AddSpaceLag+0x8>
    579a:	11 97       	sbiw	r26, 0x01	; 1
    579c:	a8 1b       	sub	r26, r24
    579e:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    57a0:	a6 17       	cp	r26, r22
    57a2:	60 f4       	brcc	.+24     	; 0x57bc <AddSpaceLag+0x30>
    57a4:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    57a6:	90 e2       	ldi	r25, 0x20	; 32
    57a8:	fe 01       	movw	r30, r28
    57aa:	e8 0f       	add	r30, r24
    57ac:	f1 1d       	adc	r31, r1
    57ae:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    57b0:	8f 5f       	subi	r24, 0xFF	; 255
    57b2:	86 17       	cp	r24, r22
    57b4:	c8 f3       	brcs	.-14     	; 0x57a8 <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    57b6:	c6 0f       	add	r28, r22
    57b8:	d1 1d       	adc	r29, r1
    57ba:	18 82       	st	Y, r1
  }
}
    57bc:	df 91       	pop	r29
    57be:	cf 91       	pop	r28
    57c0:	08 95       	ret

000057c2 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    57c2:	0f 93       	push	r16
    57c4:	1f 93       	push	r17
    57c6:	df 93       	push	r29
    57c8:	cf 93       	push	r28
    57ca:	cd b7       	in	r28, 0x3d	; 61
    57cc:	de b7       	in	r29, 0x3e	; 62
    57ce:	2c 97       	sbiw	r28, 0x0c	; 12
    57d0:	0f b6       	in	r0, 0x3f	; 63
    57d2:	f8 94       	cli
    57d4:	de bf       	out	0x3e, r29	; 62
    57d6:	0f be       	out	0x3f, r0	; 63
    57d8:	cd bf       	out	0x3d, r28	; 61
    57da:	48 2f       	mov	r20, r24
    57dc:	8b 01       	movw	r16, r22
    57de:	fe 01       	movw	r30, r28
    57e0:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    57e2:	9e 01       	movw	r18, r28
    57e4:	23 5f       	subi	r18, 0xF3	; 243
    57e6:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    57e8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    57ea:	e2 17       	cp	r30, r18
    57ec:	f3 07       	cpc	r31, r19
    57ee:	e1 f7       	brne	.-8      	; 0x57e8 <GetProductName+0x26>
    57f0:	ce 01       	movw	r24, r28
    57f2:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    57f4:	44 23       	and	r20, r20
    57f6:	69 f0       	breq	.+26     	; 0x5812 <GetProductName+0x50>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    57f8:	6d e0       	ldi	r22, 0x0D	; 13
    57fa:	46 9f       	mul	r20, r22
    57fc:	b0 01       	movw	r22, r0
    57fe:	11 24       	eor	r1, r1
    5800:	62 55       	subi	r22, 0x52	; 82
    5802:	7f 4f       	sbci	r23, 0xFF	; 255
    5804:	4a e0       	ldi	r20, 0x0A	; 10
    5806:	50 e0       	ldi	r21, 0x00	; 0
    5808:	24 e4       	ldi	r18, 0x44	; 68
    580a:	32 e1       	ldi	r19, 0x12	; 18
    580c:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    5810:	14 c0       	rjmp	.+40     	; 0x583a <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    5812:	00 d0       	rcall	.+0      	; 0x5814 <GetProductName+0x52>
    5814:	00 d0       	rcall	.+0      	; 0x5816 <GetProductName+0x54>
    5816:	ad b7       	in	r26, 0x3d	; 61
    5818:	be b7       	in	r27, 0x3e	; 62
    581a:	12 96       	adiw	r26, 0x02	; 2
    581c:	9c 93       	st	X, r25
    581e:	8e 93       	st	-X, r24
    5820:	11 97       	sbiw	r26, 0x01	; 1
    5822:	8a e4       	ldi	r24, 0x4A	; 74
    5824:	93 e0       	ldi	r25, 0x03	; 3
    5826:	14 96       	adiw	r26, 0x04	; 4
    5828:	9c 93       	st	X, r25
    582a:	8e 93       	st	-X, r24
    582c:	13 97       	sbiw	r26, 0x03	; 3
    582e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    5832:	0f 90       	pop	r0
    5834:	0f 90       	pop	r0
    5836:	0f 90       	pop	r0
    5838:	0f 90       	pop	r0

     Length=strlen(SProductName);
    583a:	de 01       	movw	r26, r28
    583c:	11 96       	adiw	r26, 0x01	; 1
    583e:	fd 01       	movw	r30, r26
    5840:	01 90       	ld	r0, Z+
    5842:	00 20       	and	r0, r0
    5844:	e9 f7       	brne	.-6      	; 0x5840 <GetProductName+0x7e>
    5846:	31 97       	sbiw	r30, 0x01	; 1
    5848:	ea 1b       	sub	r30, r26
    584a:	eb 30       	cpi	r30, 0x0B	; 11
    584c:	08 f0       	brcs	.+2      	; 0x5850 <GetProductName+0x8e>
    584e:	ea e0       	ldi	r30, 0x0A	; 10
    5850:	ae 01       	movw	r20, r28
    5852:	4f 5f       	subi	r20, 0xFF	; 255
    5854:	5f 4f       	sbci	r21, 0xFF	; 255
    5856:	98 01       	movw	r18, r16
    5858:	ba 01       	movw	r22, r20
    585a:	06 c0       	rjmp	.+12     	; 0x5868 <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    585c:	db 01       	movw	r26, r22
    585e:	8d 91       	ld	r24, X+
    5860:	bd 01       	movw	r22, r26
    5862:	d9 01       	movw	r26, r18
    5864:	8d 93       	st	X+, r24
    5866:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    5868:	86 2f       	mov	r24, r22
    586a:	84 1b       	sub	r24, r20
    586c:	8e 17       	cp	r24, r30
    586e:	b0 f3       	brcs	.-20     	; 0x585c <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    5870:	c8 01       	movw	r24, r16
    5872:	8e 0f       	add	r24, r30
    5874:	91 1d       	adc	r25, r1
    5876:	fc 01       	movw	r30, r24
    5878:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    587a:	c8 01       	movw	r24, r16
    587c:	6a e0       	ldi	r22, 0x0A	; 10
    587e:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
}
    5882:	2c 96       	adiw	r28, 0x0c	; 12
    5884:	0f b6       	in	r0, 0x3f	; 63
    5886:	f8 94       	cli
    5888:	de bf       	out	0x3e, r29	; 62
    588a:	0f be       	out	0x3f, r0	; 63
    588c:	cd bf       	out	0x3d, r28	; 61
    588e:	cf 91       	pop	r28
    5890:	df 91       	pop	r29
    5892:	1f 91       	pop	r17
    5894:	0f 91       	pop	r16
    5896:	08 95       	ret

00005898 <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    5898:	2f 92       	push	r2
    589a:	3f 92       	push	r3
    589c:	4f 92       	push	r4
    589e:	5f 92       	push	r5
    58a0:	6f 92       	push	r6
    58a2:	7f 92       	push	r7
    58a4:	8f 92       	push	r8
    58a6:	9f 92       	push	r9
    58a8:	af 92       	push	r10
    58aa:	bf 92       	push	r11
    58ac:	cf 92       	push	r12
    58ae:	df 92       	push	r13
    58b0:	ef 92       	push	r14
    58b2:	ff 92       	push	r15
    58b4:	0f 93       	push	r16
    58b6:	1f 93       	push	r17
    58b8:	df 93       	push	r29
    58ba:	cf 93       	push	r28
    58bc:	cd b7       	in	r28, 0x3d	; 61
    58be:	de b7       	in	r29, 0x3e	; 62
    58c0:	c0 5b       	subi	r28, 0xB0	; 176
    58c2:	d0 40       	sbci	r29, 0x00	; 0
    58c4:	0f b6       	in	r0, 0x3f	; 63
    58c6:	f8 94       	cli
    58c8:	de bf       	out	0x3e, r29	; 62
    58ca:	0f be       	out	0x3f, r0	; 63
    58cc:	cd bf       	out	0x3d, r28	; 61
    58ce:	e8 2e       	mov	r14, r24
    58d0:	fe 01       	movw	r30, r28
    58d2:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    58d4:	ce 01       	movw	r24, r28
    58d6:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    58d8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    58da:	e8 17       	cp	r30, r24
    58dc:	f9 07       	cpc	r31, r25
    58de:	e1 f7       	brne	.-8      	; 0x58d8 <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    58e0:	ce 01       	movw	r24, r28
    58e2:	85 96       	adiw	r24, 0x25	; 37
    58e4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    58e6:	e8 17       	cp	r30, r24
    58e8:	f9 07       	cpc	r31, r25
    58ea:	e1 f7       	brne	.-8      	; 0x58e4 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    58ec:	ce 01       	movw	r24, r28
    58ee:	c4 96       	adiw	r24, 0x34	; 52
    58f0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    58f2:	e8 17       	cp	r30, r24
    58f4:	f9 07       	cpc	r31, r25
    58f6:	e1 f7       	brne	.-8      	; 0x58f0 <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    58f8:	cf 01       	movw	r24, r30
    58fa:	3f 01       	movw	r6, r30
    58fc:	0f 96       	adiw	r24, 0x0f	; 15
    58fe:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5900:	e8 17       	cp	r30, r24
    5902:	f9 07       	cpc	r31, r25
    5904:	e1 f7       	brne	.-8      	; 0x58fe <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    5906:	8e 2d       	mov	r24, r14
    5908:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
    590c:	96 e0       	ldi	r25, 0x06	; 6
    590e:	89 9f       	mul	r24, r25
    5910:	b0 01       	movw	r22, r0
    5912:	11 24       	eor	r1, r1
    5914:	61 5b       	subi	r22, 0xB1	; 177
    5916:	7f 4f       	sbci	r23, 0xFF	; 255
    5918:	8e 01       	movw	r16, r28
    591a:	0f 5f       	subi	r16, 0xFF	; 255
    591c:	1f 4f       	sbci	r17, 0xFF	; 255
    591e:	c8 01       	movw	r24, r16
    5920:	46 e0       	ldi	r20, 0x06	; 6
    5922:	50 e0       	ldi	r21, 0x00	; 0
    5924:	24 e4       	ldi	r18, 0x44	; 68
    5926:	32 e1       	ldi	r19, 0x12	; 18
    5928:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    592c:	2e 2c       	mov	r2, r14
    592e:	33 24       	eor	r3, r3
    5930:	91 01       	movw	r18, r2
    5932:	2f 70       	andi	r18, 0x0F	; 15
    5934:	30 70       	andi	r19, 0x00	; 0
    5936:	85 e3       	ldi	r24, 0x35	; 53
    5938:	90 e0       	ldi	r25, 0x00	; 0
    593a:	28 9f       	mul	r18, r24
    593c:	f0 01       	movw	r30, r0
    593e:	29 9f       	mul	r18, r25
    5940:	f0 0d       	add	r31, r0
    5942:	38 9f       	mul	r19, r24
    5944:	f0 0d       	add	r31, r0
    5946:	11 24       	eor	r1, r1
    5948:	e8 55       	subi	r30, 0x58	; 88
    594a:	fa 4f       	sbci	r31, 0xFA	; 250
    594c:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    594e:	4f 2c       	mov	r4, r15
    5950:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    5952:	04 0d       	add	r16, r4
    5954:	15 1d       	adc	r17, r5
    5956:	d8 01       	movw	r26, r16
    5958:	8c 91       	ld	r24, X
    595a:	6e e5       	ldi	r22, 0x5E	; 94
    595c:	77 e0       	ldi	r23, 0x07	; 7
    595e:	0e 94 e1 2b 	call	0x57c2	; 0x57c2 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    5962:	67 e0       	ldi	r22, 0x07	; 7
    5964:	86 2e       	mov	r8, r22
    5966:	91 2c       	mov	r9, r1
    5968:	8c 0e       	add	r8, r28
    596a:	9d 1e       	adc	r9, r29
    596c:	8e 2d       	mov	r24, r14
    596e:	b4 01       	movw	r22, r8
    5970:	0e 94 98 25 	call	0x4b30	; 0x4b30 <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    5974:	56 e1       	ldi	r21, 0x16	; 22
    5976:	a5 2e       	mov	r10, r21
    5978:	b1 2c       	mov	r11, r1
    597a:	ac 0e       	add	r10, r28
    597c:	bd 1e       	adc	r11, r29
    597e:	8e 2d       	mov	r24, r14
    5980:	b5 01       	movw	r22, r10
    5982:	0e 94 5e 25 	call	0x4abc	; 0x4abc <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    5986:	45 e2       	ldi	r20, 0x25	; 37
    5988:	c4 2e       	mov	r12, r20
    598a:	d1 2c       	mov	r13, r1
    598c:	cc 0e       	add	r12, r28
    598e:	dd 1e       	adc	r13, r29
    5990:	8e 2d       	mov	r24, r14
    5992:	6f 2d       	mov	r22, r15
    5994:	a6 01       	movw	r20, r12
    5996:	0e 94 41 25 	call	0x4a82	; 0x4a82 <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    599a:	8e 2d       	mov	r24, r14
    599c:	6f 2d       	mov	r22, r15
    599e:	a3 01       	movw	r20, r6
    59a0:	0e 94 24 25 	call	0x4a48	; 0x4a48 <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    59a4:	33 e4       	ldi	r19, 0x43	; 67
    59a6:	e3 2e       	mov	r14, r19
    59a8:	f1 2c       	mov	r15, r1
    59aa:	ec 0e       	add	r14, r28
    59ac:	fd 1e       	adc	r15, r29
    59ae:	c7 01       	movw	r24, r14
    59b0:	0e 94 fe 19 	call	0x33fc	; 0x33fc <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    59b4:	ed b7       	in	r30, 0x3d	; 61
    59b6:	fe b7       	in	r31, 0x3e	; 62
    59b8:	74 97       	sbiw	r30, 0x14	; 20
    59ba:	0f b6       	in	r0, 0x3f	; 63
    59bc:	f8 94       	cli
    59be:	fe bf       	out	0x3e, r31	; 62
    59c0:	0f be       	out	0x3f, r0	; 63
    59c2:	ed bf       	out	0x3d, r30	; 61
    59c4:	31 96       	adiw	r30, 0x01	; 1
    59c6:	8e 01       	movw	r16, r28
    59c8:	09 5a       	subi	r16, 0xA9	; 169
    59ca:	1f 4f       	sbci	r17, 0xFF	; 255
    59cc:	ad b7       	in	r26, 0x3d	; 61
    59ce:	be b7       	in	r27, 0x3e	; 62
    59d0:	12 96       	adiw	r26, 0x02	; 2
    59d2:	1c 93       	st	X, r17
    59d4:	0e 93       	st	-X, r16
    59d6:	11 97       	sbiw	r26, 0x01	; 1
    59d8:	89 e0       	ldi	r24, 0x09	; 9
    59da:	93 e0       	ldi	r25, 0x03	; 3
    59dc:	93 83       	std	Z+3, r25	; 0x03
    59de:	82 83       	std	Z+2, r24	; 0x02
    59e0:	35 82       	std	Z+5, r3	; 0x05
    59e2:	24 82       	std	Z+4, r2	; 0x04
    59e4:	57 82       	std	Z+7, r5	; 0x07
    59e6:	46 82       	std	Z+6, r4	; 0x06
    59e8:	8e e5       	ldi	r24, 0x5E	; 94
    59ea:	97 e0       	ldi	r25, 0x07	; 7
    59ec:	91 87       	std	Z+9, r25	; 0x09
    59ee:	80 87       	std	Z+8, r24	; 0x08
    59f0:	f3 86       	std	Z+11, r15	; 0x0b
    59f2:	e2 86       	std	Z+10, r14	; 0x0a
    59f4:	95 86       	std	Z+13, r9	; 0x0d
    59f6:	84 86       	std	Z+12, r8	; 0x0c
    59f8:	b7 86       	std	Z+15, r11	; 0x0f
    59fa:	a6 86       	std	Z+14, r10	; 0x0e
    59fc:	d1 8a       	std	Z+17, r13	; 0x11
    59fe:	c0 8a       	std	Z+16, r12	; 0x10
    5a00:	62 8a       	std	Z+18, r6	; 0x12
    5a02:	73 8a       	std	Z+19, r7	; 0x13
    5a04:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 cSum=SumChecksum(strSend);
    5a08:	ad b7       	in	r26, 0x3d	; 61
    5a0a:	be b7       	in	r27, 0x3e	; 62
    5a0c:	54 96       	adiw	r26, 0x14	; 20
    5a0e:	0f b6       	in	r0, 0x3f	; 63
    5a10:	f8 94       	cli
    5a12:	be bf       	out	0x3e, r27	; 62
    5a14:	0f be       	out	0x3f, r0	; 63
    5a16:	ad bf       	out	0x3d, r26	; 61
    5a18:	c8 01       	movw	r24, r16
    5a1a:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <SumChecksum>
    5a1e:	e8 2e       	mov	r14, r24
	 uart_print(1,0,strSend);
    5a20:	81 e0       	ldi	r24, 0x01	; 1
    5a22:	60 e0       	ldi	r22, 0x00	; 0
    5a24:	a8 01       	movw	r20, r16
    5a26:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
    5a2a:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5a2c:	c8 01       	movw	r24, r16
    5a2e:	f9 2e       	mov	r15, r25
    5a30:	ce 01       	movw	r24, r28
    5a32:	8f 54       	subi	r24, 0x4F	; 79
    5a34:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    5a36:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5a38:	e8 17       	cp	r30, r24
    5a3a:	f9 07       	cpc	r31, r25
    5a3c:	e1 f7       	brne	.-8      	; 0x5a36 <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    5a3e:	00 d0       	rcall	.+0      	; 0x5a40 <GeniusSendLastTransaction+0x1a8>
    5a40:	00 d0       	rcall	.+0      	; 0x5a42 <GeniusSendLastTransaction+0x1aa>
    5a42:	00 d0       	rcall	.+0      	; 0x5a44 <GeniusSendLastTransaction+0x1ac>
    5a44:	ed b7       	in	r30, 0x3d	; 61
    5a46:	fe b7       	in	r31, 0x3e	; 62
    5a48:	31 96       	adiw	r30, 0x01	; 1
    5a4a:	ad b7       	in	r26, 0x3d	; 61
    5a4c:	be b7       	in	r27, 0x3e	; 62
    5a4e:	11 96       	adiw	r26, 0x01	; 1
    5a50:	0c 93       	st	X, r16
    5a52:	11 97       	sbiw	r26, 0x01	; 1
    5a54:	12 96       	adiw	r26, 0x02	; 2
    5a56:	fc 92       	st	X, r15
    5a58:	86 e0       	ldi	r24, 0x06	; 6
    5a5a:	93 e0       	ldi	r25, 0x03	; 3
    5a5c:	93 83       	std	Z+3, r25	; 0x03
    5a5e:	82 83       	std	Z+2, r24	; 0x02
    5a60:	e4 82       	std	Z+4, r14	; 0x04
    5a62:	15 82       	std	Z+5, r1	; 0x05
    5a64:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 uart_print(1,1,strSend);	 
    5a68:	ed b7       	in	r30, 0x3d	; 61
    5a6a:	fe b7       	in	r31, 0x3e	; 62
    5a6c:	36 96       	adiw	r30, 0x06	; 6
    5a6e:	0f b6       	in	r0, 0x3f	; 63
    5a70:	f8 94       	cli
    5a72:	fe bf       	out	0x3e, r31	; 62
    5a74:	0f be       	out	0x3f, r0	; 63
    5a76:	ed bf       	out	0x3d, r30	; 61
    5a78:	81 e0       	ldi	r24, 0x01	; 1
    5a7a:	61 e0       	ldi	r22, 0x01	; 1
    5a7c:	40 2f       	mov	r20, r16
    5a7e:	5f 2d       	mov	r21, r15
    5a80:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
}
    5a84:	c0 55       	subi	r28, 0x50	; 80
    5a86:	df 4f       	sbci	r29, 0xFF	; 255
    5a88:	0f b6       	in	r0, 0x3f	; 63
    5a8a:	f8 94       	cli
    5a8c:	de bf       	out	0x3e, r29	; 62
    5a8e:	0f be       	out	0x3f, r0	; 63
    5a90:	cd bf       	out	0x3d, r28	; 61
    5a92:	cf 91       	pop	r28
    5a94:	df 91       	pop	r29
    5a96:	1f 91       	pop	r17
    5a98:	0f 91       	pop	r16
    5a9a:	ff 90       	pop	r15
    5a9c:	ef 90       	pop	r14
    5a9e:	df 90       	pop	r13
    5aa0:	cf 90       	pop	r12
    5aa2:	bf 90       	pop	r11
    5aa4:	af 90       	pop	r10
    5aa6:	9f 90       	pop	r9
    5aa8:	8f 90       	pop	r8
    5aaa:	7f 90       	pop	r7
    5aac:	6f 90       	pop	r6
    5aae:	5f 90       	pop	r5
    5ab0:	4f 90       	pop	r4
    5ab2:	3f 90       	pop	r3
    5ab4:	2f 90       	pop	r2
    5ab6:	08 95       	ret

00005ab8 <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    5ab8:	80 91 bf 01 	lds	r24, 0x01BF
    5abc:	83 30       	cpi	r24, 0x03	; 3
    5abe:	61 f1       	breq	.+88     	; 0x5b18 <systemGeniusProtocol+0x60>
    5ac0:	84 30       	cpi	r24, 0x04	; 4
    5ac2:	28 f4       	brcc	.+10     	; 0x5ace <systemGeniusProtocol+0x16>
    5ac4:	81 30       	cpi	r24, 0x01	; 1
    5ac6:	81 f0       	breq	.+32     	; 0x5ae8 <systemGeniusProtocol+0x30>
    5ac8:	82 30       	cpi	r24, 0x02	; 2
    5aca:	c0 f4       	brcc	.+48     	; 0x5afc <systemGeniusProtocol+0x44>
    5acc:	09 c0       	rjmp	.+18     	; 0x5ae0 <systemGeniusProtocol+0x28>
    5ace:	85 30       	cpi	r24, 0x05	; 5
    5ad0:	09 f4       	brne	.+2      	; 0x5ad4 <systemGeniusProtocol+0x1c>
    5ad2:	43 c0       	rjmp	.+134    	; 0x5b5a <systemGeniusProtocol+0xa2>
    5ad4:	85 30       	cpi	r24, 0x05	; 5
    5ad6:	a0 f1       	brcs	.+104    	; 0x5b40 <systemGeniusProtocol+0x88>
    5ad8:	86 30       	cpi	r24, 0x06	; 6
    5ada:	09 f0       	breq	.+2      	; 0x5ade <systemGeniusProtocol+0x26>
    5adc:	58 c0       	rjmp	.+176    	; 0x5b8e <systemGeniusProtocol+0xd6>
    5ade:	45 c0       	rjmp	.+138    	; 0x5b6a <systemGeniusProtocol+0xb2>
	 case gpInitScan:
	      iPumpID=1;
    5ae0:	81 e0       	ldi	r24, 0x01	; 1
    5ae2:	80 93 be 01 	sts	0x01BE, r24
    5ae6:	3e c0       	rjmp	.+124    	; 0x5b64 <systemGeniusProtocol+0xac>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    5ae8:	80 91 bd 01 	lds	r24, 0x01BD
    5aec:	0e 94 8e 19 	call	0x331c	; 0x331c <GetIncomingTransStatus>
    5af0:	82 30       	cpi	r24, 0x02	; 2
    5af2:	09 f0       	breq	.+2      	; 0x5af6 <systemGeniusProtocol+0x3e>
    5af4:	4c c0       	rjmp	.+152    	; 0x5b8e <systemGeniusProtocol+0xd6>
		      IsTotalizerReceived=False;
    5af6:	10 92 af 01 	sts	0x01AF, r1
    5afa:	34 c0       	rjmp	.+104    	; 0x5b64 <systemGeniusProtocol+0xac>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    5afc:	90 91 be 01 	lds	r25, 0x01BE
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    5b00:	85 e0       	ldi	r24, 0x05	; 5
    5b02:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    5b06:	90 93 d3 0b 	sts	0x0BD3, r25
     IsControlPooling=True;
    5b0a:	81 e0       	ldi	r24, 0x01	; 1
    5b0c:	80 93 84 01 	sts	0x0184, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    5b10:	10 92 78 0c 	sts	0x0C78, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    5b14:	83 e0       	ldi	r24, 0x03	; 3
    5b16:	26 c0       	rjmp	.+76     	; 0x5b64 <systemGeniusProtocol+0xac>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    5b18:	80 91 af 01 	lds	r24, 0x01AF
    5b1c:	81 30       	cpi	r24, 0x01	; 1
    5b1e:	59 f4       	brne	.+22     	; 0x5b36 <systemGeniusProtocol+0x7e>
    5b20:	90 91 ec 0b 	lds	r25, 0x0BEC
    5b24:	80 91 be 01 	lds	r24, 0x01BE
    5b28:	98 17       	cp	r25, r24
    5b2a:	29 f4       	brne	.+10     	; 0x5b36 <systemGeniusProtocol+0x7e>
		      IsTotalizerReceived=False;
    5b2c:	10 92 af 01 	sts	0x01AF, r1
			  stGeniusProtocol=gpSendTransactionData;
    5b30:	84 e0       	ldi	r24, 0x04	; 4
    5b32:	80 93 bf 01 	sts	0x01BF, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    5b36:	80 91 78 0c 	lds	r24, 0x0C78
    5b3a:	85 31       	cpi	r24, 0x15	; 21
    5b3c:	40 f1       	brcs	.+80     	; 0x5b8e <systemGeniusProtocol+0xd6>
    5b3e:	11 c0       	rjmp	.+34     	; 0x5b62 <systemGeniusProtocol+0xaa>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    5b40:	80 91 be 01 	lds	r24, 0x01BE
    5b44:	0e 94 4c 2c 	call	0x5898	; 0x5898 <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    5b48:	80 91 be 01 	lds	r24, 0x01BE
    5b4c:	63 e0       	ldi	r22, 0x03	; 3
    5b4e:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <SetIncomingTransStatus>
		  
		  TimSend=0;
    5b52:	10 92 78 0c 	sts	0x0C78, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    5b56:	85 e0       	ldi	r24, 0x05	; 5
    5b58:	05 c0       	rjmp	.+10     	; 0x5b64 <systemGeniusProtocol+0xac>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    5b5a:	80 91 78 0c 	lds	r24, 0x0C78
    5b5e:	82 30       	cpi	r24, 0x02	; 2
    5b60:	b0 f0       	brcs	.+44     	; 0x5b8e <systemGeniusProtocol+0xd6>
    5b62:	86 e0       	ldi	r24, 0x06	; 6
    5b64:	80 93 bf 01 	sts	0x01BF, r24
    5b68:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    5b6a:	20 91 be 01 	lds	r18, 0x01BE
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    5b6e:	e1 99       	sbic	0x1c, 1	; 28
    5b70:	fe cf       	rjmp	.-4      	; 0x5b6e <systemGeniusProtocol+0xb6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    5b72:	84 e4       	ldi	r24, 0x44	; 68
    5b74:	91 e0       	ldi	r25, 0x01	; 1
    5b76:	9f bb       	out	0x1f, r25	; 31
    5b78:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    5b7a:	e0 9a       	sbi	0x1c, 0	; 28
    5b7c:	8d b3       	in	r24, 0x1d	; 29
    5b7e:	82 17       	cp	r24, r18
    5b80:	30 f0       	brcs	.+12     	; 0x5b8e <systemGeniusProtocol+0xd6>
		      iPumpID++;
    5b82:	2f 5f       	subi	r18, 0xFF	; 255
    5b84:	20 93 be 01 	sts	0x01BE, r18
              stGeniusProtocol=gpScanNewTransaction;
    5b88:	81 e0       	ldi	r24, 0x01	; 1
    5b8a:	80 93 bf 01 	sts	0x01BF, r24
    5b8e:	08 95       	ret

00005b90 <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    5b90:	ef 92       	push	r14
    5b92:	ff 92       	push	r15
    5b94:	0f 93       	push	r16
    5b96:	1f 93       	push	r17
    5b98:	18 2f       	mov	r17, r24
    5b9a:	09 2f       	mov	r16, r25
    5b9c:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    5b9e:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
	 RemSpaceLead(Source);
    5ba2:	81 2f       	mov	r24, r17
    5ba4:	90 2f       	mov	r25, r16
    5ba6:	0e 94 87 23 	call	0x470e	; 0x470e <RemSpaceLead>
	 srcLength=strlen(Source);
    5baa:	a1 2f       	mov	r26, r17
    5bac:	b0 2f       	mov	r27, r16
    5bae:	fd 01       	movw	r30, r26
    5bb0:	01 90       	ld	r0, Z+
    5bb2:	00 20       	and	r0, r0
    5bb4:	e9 f7       	brne	.-6      	; 0x5bb0 <StrAlignCenter+0x20>
    5bb6:	31 97       	sbiw	r30, 0x01	; 1
    5bb8:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    5bba:	c7 01       	movw	r24, r14
    5bbc:	8e 1b       	sub	r24, r30
    5bbe:	91 09       	sbc	r25, r1
    5bc0:	96 95       	lsr	r25
    5bc2:	87 95       	ror	r24
    5bc4:	e8 0f       	add	r30, r24
    5bc6:	81 2f       	mov	r24, r17
    5bc8:	90 2f       	mov	r25, r16
    5bca:	6e 2f       	mov	r22, r30
    5bcc:	0e 94 5f 2b 	call	0x56be	; 0x56be <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    5bd0:	81 2f       	mov	r24, r17
    5bd2:	90 2f       	mov	r25, r16
    5bd4:	6e 2d       	mov	r22, r14
    5bd6:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
}
    5bda:	1f 91       	pop	r17
    5bdc:	0f 91       	pop	r16
    5bde:	ff 90       	pop	r15
    5be0:	ef 90       	pop	r14
    5be2:	08 95       	ret

00005be4 <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    5be4:	bf 92       	push	r11
    5be6:	cf 92       	push	r12
    5be8:	df 92       	push	r13
    5bea:	ef 92       	push	r14
    5bec:	ff 92       	push	r15
    5bee:	0f 93       	push	r16
    5bf0:	1f 93       	push	r17
    5bf2:	df 93       	push	r29
    5bf4:	cf 93       	push	r28
    5bf6:	cd b7       	in	r28, 0x3d	; 61
    5bf8:	de b7       	in	r29, 0x3e	; 62
    5bfa:	6e 97       	sbiw	r28, 0x1e	; 30
    5bfc:	0f b6       	in	r0, 0x3f	; 63
    5bfe:	f8 94       	cli
    5c00:	de bf       	out	0x3e, r29	; 62
    5c02:	0f be       	out	0x3f, r0	; 63
    5c04:	cd bf       	out	0x3d, r28	; 61
    5c06:	8c 01       	movw	r16, r24
    5c08:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    5c0a:	fc 01       	movw	r30, r24
    5c0c:	01 90       	ld	r0, Z+
    5c0e:	00 20       	and	r0, r0
    5c10:	e9 f7       	brne	.-6      	; 0x5c0c <AddCharLead+0x28>
    5c12:	31 97       	sbiw	r30, 0x01	; 1
    5c14:	2e 2f       	mov	r18, r30
    5c16:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5c18:	24 17       	cp	r18, r20
    5c1a:	d0 f5       	brcc	.+116    	; 0x5c90 <AddCharLead+0xac>
    5c1c:	ae 01       	movw	r20, r28
    5c1e:	4f 5f       	subi	r20, 0xFF	; 255
    5c20:	5f 4f       	sbci	r21, 0xFF	; 255
    5c22:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    5c24:	b4 2e       	mov	r11, r20
    5c26:	01 c0       	rjmp	.+2      	; 0x5c2a <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    5c28:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5c2a:	8e 2f       	mov	r24, r30
    5c2c:	8b 19       	sub	r24, r11
    5c2e:	8e 15       	cp	r24, r14
    5c30:	d8 f3       	brcs	.-10     	; 0x5c28 <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    5c32:	6e 2d       	mov	r22, r14
    5c34:	70 e0       	ldi	r23, 0x00	; 0
    5c36:	ce 01       	movw	r24, r28
    5c38:	01 96       	adiw	r24, 0x01	; 1
    5c3a:	fc 01       	movw	r30, r24
    5c3c:	e6 0f       	add	r30, r22
    5c3e:	f7 1f       	adc	r31, r23
    5c40:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5c42:	fe 2c       	mov	r15, r14
    5c44:	f2 1a       	sub	r15, r18
    5c46:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5c48:	30 e0       	ldi	r19, 0x00	; 0
    5c4a:	26 1b       	sub	r18, r22
    5c4c:	37 0b       	sbc	r19, r23
    5c4e:	0c c0       	rjmp	.+24     	; 0x5c68 <AddCharLead+0x84>
    5c50:	ef 2d       	mov	r30, r15
    5c52:	f0 e0       	ldi	r31, 0x00	; 0
    5c54:	d6 01       	movw	r26, r12
    5c56:	ae 0f       	add	r26, r30
    5c58:	bf 1f       	adc	r27, r31
    5c5a:	e0 0f       	add	r30, r16
    5c5c:	f1 1f       	adc	r31, r17
    5c5e:	e2 0f       	add	r30, r18
    5c60:	f3 1f       	adc	r31, r19
    5c62:	80 81       	ld	r24, Z
    5c64:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5c66:	f3 94       	inc	r15
    5c68:	fe 14       	cp	r15, r14
    5c6a:	90 f3       	brcs	.-28     	; 0x5c50 <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    5c6c:	6c 0d       	add	r22, r12
    5c6e:	7d 1d       	adc	r23, r13
    5c70:	db 01       	movw	r26, r22
    5c72:	1c 92       	st	X, r1
    5c74:	f8 01       	movw	r30, r16
    5c76:	04 c0       	rjmp	.+8      	; 0x5c80 <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5c78:	da 01       	movw	r26, r20
    5c7a:	8d 91       	ld	r24, X+
    5c7c:	ad 01       	movw	r20, r26
    5c7e:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5c80:	84 2f       	mov	r24, r20
    5c82:	8b 19       	sub	r24, r11
    5c84:	8e 15       	cp	r24, r14
    5c86:	c0 f3       	brcs	.-16     	; 0x5c78 <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5c88:	0e 0d       	add	r16, r14
    5c8a:	11 1d       	adc	r17, r1
    5c8c:	f8 01       	movw	r30, r16
    5c8e:	10 82       	st	Z, r1
	 }
}
    5c90:	6e 96       	adiw	r28, 0x1e	; 30
    5c92:	0f b6       	in	r0, 0x3f	; 63
    5c94:	f8 94       	cli
    5c96:	de bf       	out	0x3e, r29	; 62
    5c98:	0f be       	out	0x3f, r0	; 63
    5c9a:	cd bf       	out	0x3d, r28	; 61
    5c9c:	cf 91       	pop	r28
    5c9e:	df 91       	pop	r29
    5ca0:	1f 91       	pop	r17
    5ca2:	0f 91       	pop	r16
    5ca4:	ff 90       	pop	r15
    5ca6:	ef 90       	pop	r14
    5ca8:	df 90       	pop	r13
    5caa:	cf 90       	pop	r12
    5cac:	bf 90       	pop	r11
    5cae:	08 95       	ret

00005cb0 <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    5cb0:	cf 93       	push	r28
    5cb2:	df 93       	push	r29
    5cb4:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5cb6:	dc 01       	movw	r26, r24
    5cb8:	0d 90       	ld	r0, X+
    5cba:	00 20       	and	r0, r0
    5cbc:	e9 f7       	brne	.-6      	; 0x5cb8 <AddCharLag+0x8>
    5cbe:	11 97       	sbiw	r26, 0x01	; 1
    5cc0:	a8 1b       	sub	r26, r24
    5cc2:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5cc4:	a4 17       	cp	r26, r20
    5cc6:	58 f4       	brcc	.+22     	; 0x5cde <AddCharLag+0x2e>
    5cc8:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    5cca:	fe 01       	movw	r30, r28
    5ccc:	e8 0f       	add	r30, r24
    5cce:	f1 1d       	adc	r31, r1
    5cd0:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5cd2:	8f 5f       	subi	r24, 0xFF	; 255
    5cd4:	84 17       	cp	r24, r20
    5cd6:	c8 f3       	brcs	.-14     	; 0x5cca <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    5cd8:	c4 0f       	add	r28, r20
    5cda:	d1 1d       	adc	r29, r1
    5cdc:	18 82       	st	Y, r1
  }

}
    5cde:	df 91       	pop	r29
    5ce0:	cf 91       	pop	r28
    5ce2:	08 95       	ret

00005ce4 <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    5ce4:	cf 92       	push	r12
    5ce6:	df 92       	push	r13
    5ce8:	ef 92       	push	r14
    5cea:	ff 92       	push	r15
    5cec:	0f 93       	push	r16
    5cee:	1f 93       	push	r17
    5cf0:	cf 93       	push	r28
    5cf2:	df 93       	push	r29
    5cf4:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5cf6:	dc 01       	movw	r26, r24
    5cf8:	0d 90       	ld	r0, X+
    5cfa:	00 20       	and	r0, r0
    5cfc:	e9 f7       	brne	.-6      	; 0x5cf8 <CountTotalizerSatus+0x14>
    5cfe:	8d 01       	movw	r16, r26
    5d00:	01 50       	subi	r16, 0x01	; 1
    5d02:	10 40       	sbci	r17, 0x00	; 0
    5d04:	08 1b       	sub	r16, r24
    5d06:	19 0b       	sbc	r17, r25
    5d08:	cc 24       	eor	r12, r12
    5d0a:	dd 24       	eor	r13, r13
    5d0c:	0a c0       	rjmp	.+20     	; 0x5d22 <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    5d0e:	84 e1       	ldi	r24, 0x14	; 20
    5d10:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    5d14:	ce 0d       	add	r28, r14
    5d16:	df 1d       	adc	r29, r15
    5d18:	98 81       	ld	r25, Y
    5d1a:	98 17       	cp	r25, r24
    5d1c:	09 f4       	brne	.+2      	; 0x5d20 <CountTotalizerSatus+0x3c>
		      Result++;		  
    5d1e:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5d20:	c3 94       	inc	r12
    5d22:	cc 2d       	mov	r28, r12
    5d24:	d0 e0       	ldi	r29, 0x00	; 0
    5d26:	c0 17       	cp	r28, r16
    5d28:	d1 07       	cpc	r29, r17
    5d2a:	88 f3       	brcs	.-30     	; 0x5d0e <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    5d2c:	8d 2d       	mov	r24, r13
    5d2e:	df 91       	pop	r29
    5d30:	cf 91       	pop	r28
    5d32:	1f 91       	pop	r17
    5d34:	0f 91       	pop	r16
    5d36:	ff 90       	pop	r15
    5d38:	ef 90       	pop	r14
    5d3a:	df 90       	pop	r13
    5d3c:	cf 90       	pop	r12
    5d3e:	08 95       	ret

00005d40 <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    5d40:	1f 93       	push	r17
    5d42:	df 93       	push	r29
    5d44:	cf 93       	push	r28
    5d46:	cd b7       	in	r28, 0x3d	; 61
    5d48:	de b7       	in	r29, 0x3e	; 62
    5d4a:	64 97       	sbiw	r28, 0x14	; 20
    5d4c:	0f b6       	in	r0, 0x3f	; 63
    5d4e:	f8 94       	cli
    5d50:	de bf       	out	0x3e, r29	; 62
    5d52:	0f be       	out	0x3f, r0	; 63
    5d54:	cd bf       	out	0x3d, r28	; 61
    5d56:	16 2f       	mov	r17, r22
    5d58:	50 e0       	ldi	r21, 0x00	; 0
    5d5a:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    5d5c:	be 01       	movw	r22, r28
    5d5e:	6f 5f       	subi	r22, 0xFF	; 255
    5d60:	7f 4f       	sbci	r23, 0xFF	; 255
    5d62:	0c c0       	rjmp	.+24     	; 0x5d7c <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    5d64:	28 0f       	add	r18, r24
    5d66:	39 1f       	adc	r19, r25
    5d68:	d9 01       	movw	r26, r18
    5d6a:	2c 91       	ld	r18, X
    5d6c:	21 17       	cp	r18, r17
    5d6e:	29 f0       	breq	.+10     	; 0x5d7a <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    5d70:	fb 01       	movw	r30, r22
    5d72:	e4 0f       	add	r30, r20
    5d74:	f1 1d       	adc	r31, r1
    5d76:	20 83       	st	Z, r18
			 iAdd++;
    5d78:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    5d7a:	5f 5f       	subi	r21, 0xFF	; 255
    5d7c:	25 2f       	mov	r18, r21
    5d7e:	30 e0       	ldi	r19, 0x00	; 0
    5d80:	fc 01       	movw	r30, r24
    5d82:	01 90       	ld	r0, Z+
    5d84:	00 20       	and	r0, r0
    5d86:	e9 f7       	brne	.-6      	; 0x5d82 <RemoveChar+0x42>
    5d88:	31 97       	sbiw	r30, 0x01	; 1
    5d8a:	e8 1b       	sub	r30, r24
    5d8c:	f9 0b       	sbc	r31, r25
    5d8e:	2e 17       	cp	r18, r30
    5d90:	3f 07       	cpc	r19, r31
    5d92:	40 f3       	brcs	.-48     	; 0x5d64 <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    5d94:	9e 01       	movw	r18, r28
    5d96:	2f 5f       	subi	r18, 0xFF	; 255
    5d98:	3f 4f       	sbci	r19, 0xFF	; 255
    5d9a:	f9 01       	movw	r30, r18
    5d9c:	e4 0f       	add	r30, r20
    5d9e:	f1 1d       	adc	r31, r1
    5da0:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    5da2:	00 d0       	rcall	.+0      	; 0x5da4 <RemoveChar+0x64>
    5da4:	00 d0       	rcall	.+0      	; 0x5da6 <RemoveChar+0x66>
    5da6:	00 d0       	rcall	.+0      	; 0x5da8 <RemoveChar+0x68>
    5da8:	ed b7       	in	r30, 0x3d	; 61
    5daa:	fe b7       	in	r31, 0x3e	; 62
    5dac:	31 96       	adiw	r30, 0x01	; 1
    5dae:	ad b7       	in	r26, 0x3d	; 61
    5db0:	be b7       	in	r27, 0x3e	; 62
    5db2:	12 96       	adiw	r26, 0x02	; 2
    5db4:	9c 93       	st	X, r25
    5db6:	8e 93       	st	-X, r24
    5db8:	11 97       	sbiw	r26, 0x01	; 1
    5dba:	88 e3       	ldi	r24, 0x38	; 56
    5dbc:	97 e1       	ldi	r25, 0x17	; 23
    5dbe:	93 83       	std	Z+3, r25	; 0x03
    5dc0:	82 83       	std	Z+2, r24	; 0x02
    5dc2:	35 83       	std	Z+5, r19	; 0x05
    5dc4:	24 83       	std	Z+4, r18	; 0x04
    5dc6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    5dca:	ed b7       	in	r30, 0x3d	; 61
    5dcc:	fe b7       	in	r31, 0x3e	; 62
    5dce:	36 96       	adiw	r30, 0x06	; 6
    5dd0:	0f b6       	in	r0, 0x3f	; 63
    5dd2:	f8 94       	cli
    5dd4:	fe bf       	out	0x3e, r31	; 62
    5dd6:	0f be       	out	0x3f, r0	; 63
    5dd8:	ed bf       	out	0x3d, r30	; 61
}
    5dda:	64 96       	adiw	r28, 0x14	; 20
    5ddc:	0f b6       	in	r0, 0x3f	; 63
    5dde:	f8 94       	cli
    5de0:	de bf       	out	0x3e, r29	; 62
    5de2:	0f be       	out	0x3f, r0	; 63
    5de4:	cd bf       	out	0x3d, r28	; 61
    5de6:	cf 91       	pop	r28
    5de8:	df 91       	pop	r29
    5dea:	1f 91       	pop	r17
    5dec:	08 95       	ret

00005dee <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    5dee:	8f 92       	push	r8
    5df0:	9f 92       	push	r9
    5df2:	bf 92       	push	r11
    5df4:	cf 92       	push	r12
    5df6:	df 92       	push	r13
    5df8:	ef 92       	push	r14
    5dfa:	ff 92       	push	r15
    5dfc:	0f 93       	push	r16
    5dfe:	1f 93       	push	r17
    5e00:	df 93       	push	r29
    5e02:	cf 93       	push	r28
    5e04:	cd b7       	in	r28, 0x3d	; 61
    5e06:	de b7       	in	r29, 0x3e	; 62
    5e08:	2f 97       	sbiw	r28, 0x0f	; 15
    5e0a:	0f b6       	in	r0, 0x3f	; 63
    5e0c:	f8 94       	cli
    5e0e:	de bf       	out	0x3e, r29	; 62
    5e10:	0f be       	out	0x3f, r0	; 63
    5e12:	cd bf       	out	0x3d, r28	; 61
    5e14:	6c 01       	movw	r12, r24
    5e16:	bb 24       	eor	r11, r11
    5e18:	40 e0       	ldi	r20, 0x00	; 0
    5e1a:	4e 01       	movw	r8, r28
    5e1c:	08 94       	sec
    5e1e:	81 1c       	adc	r8, r1
    5e20:	91 1c       	adc	r9, r1
    5e22:	12 c0       	rjmp	.+36     	; 0x5e48 <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    5e24:	86 01       	movw	r16, r12
    5e26:	0e 0d       	add	r16, r14
    5e28:	1f 1d       	adc	r17, r15
    5e2a:	d8 01       	movw	r26, r16
    5e2c:	6c 91       	ld	r22, X
    5e2e:	60 53       	subi	r22, 0x30	; 48
    5e30:	80 e0       	ldi	r24, 0x00	; 0
    5e32:	0e 94 75 15 	call	0x2aea	; 0x2aea <GeniusCalc>
    5e36:	e8 0c       	add	r14, r8
    5e38:	f9 1c       	adc	r15, r9
    5e3a:	80 5d       	subi	r24, 0xD0	; 208
    5e3c:	f7 01       	movw	r30, r14
    5e3e:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    5e40:	d8 01       	movw	r26, r16
    5e42:	4c 91       	ld	r20, X
    5e44:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    5e46:	b3 94       	inc	r11
    5e48:	eb 2c       	mov	r14, r11
    5e4a:	ff 24       	eor	r15, r15
    5e4c:	d6 01       	movw	r26, r12
    5e4e:	0d 90       	ld	r0, X+
    5e50:	00 20       	and	r0, r0
    5e52:	e9 f7       	brne	.-6      	; 0x5e4e <WrapCode+0x60>
    5e54:	11 97       	sbiw	r26, 0x01	; 1
    5e56:	ac 19       	sub	r26, r12
    5e58:	bd 09       	sbc	r27, r13
    5e5a:	ea 16       	cp	r14, r26
    5e5c:	fb 06       	cpc	r15, r27
    5e5e:	10 f3       	brcs	.-60     	; 0x5e24 <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    5e60:	a8 0d       	add	r26, r8
    5e62:	b9 1d       	adc	r27, r9
    5e64:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    5e66:	00 d0       	rcall	.+0      	; 0x5e68 <WrapCode+0x7a>
    5e68:	00 d0       	rcall	.+0      	; 0x5e6a <WrapCode+0x7c>
    5e6a:	00 d0       	rcall	.+0      	; 0x5e6c <WrapCode+0x7e>
    5e6c:	ed b7       	in	r30, 0x3d	; 61
    5e6e:	fe b7       	in	r31, 0x3e	; 62
    5e70:	31 96       	adiw	r30, 0x01	; 1
    5e72:	ad b7       	in	r26, 0x3d	; 61
    5e74:	be b7       	in	r27, 0x3e	; 62
    5e76:	12 96       	adiw	r26, 0x02	; 2
    5e78:	dc 92       	st	X, r13
    5e7a:	ce 92       	st	-X, r12
    5e7c:	11 97       	sbiw	r26, 0x01	; 1
    5e7e:	83 e4       	ldi	r24, 0x43	; 67
    5e80:	97 e1       	ldi	r25, 0x17	; 23
    5e82:	93 83       	std	Z+3, r25	; 0x03
    5e84:	82 83       	std	Z+2, r24	; 0x02
    5e86:	95 82       	std	Z+5, r9	; 0x05
    5e88:	84 82       	std	Z+4, r8	; 0x04
    5e8a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    5e8e:	ed b7       	in	r30, 0x3d	; 61
    5e90:	fe b7       	in	r31, 0x3e	; 62
    5e92:	36 96       	adiw	r30, 0x06	; 6
    5e94:	0f b6       	in	r0, 0x3f	; 63
    5e96:	f8 94       	cli
    5e98:	fe bf       	out	0x3e, r31	; 62
    5e9a:	0f be       	out	0x3f, r0	; 63
    5e9c:	ed bf       	out	0x3d, r30	; 61
}
    5e9e:	2f 96       	adiw	r28, 0x0f	; 15
    5ea0:	0f b6       	in	r0, 0x3f	; 63
    5ea2:	f8 94       	cli
    5ea4:	de bf       	out	0x3e, r29	; 62
    5ea6:	0f be       	out	0x3f, r0	; 63
    5ea8:	cd bf       	out	0x3d, r28	; 61
    5eaa:	cf 91       	pop	r28
    5eac:	df 91       	pop	r29
    5eae:	1f 91       	pop	r17
    5eb0:	0f 91       	pop	r16
    5eb2:	ff 90       	pop	r15
    5eb4:	ef 90       	pop	r14
    5eb6:	df 90       	pop	r13
    5eb8:	cf 90       	pop	r12
    5eba:	bf 90       	pop	r11
    5ebc:	9f 90       	pop	r9
    5ebe:	8f 90       	pop	r8
    5ec0:	08 95       	ret

00005ec2 <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    5ec2:	8f 92       	push	r8
    5ec4:	9f 92       	push	r9
    5ec6:	af 92       	push	r10
    5ec8:	bf 92       	push	r11
    5eca:	df 92       	push	r13
    5ecc:	ef 92       	push	r14
    5ece:	ff 92       	push	r15
    5ed0:	0f 93       	push	r16
    5ed2:	1f 93       	push	r17
    5ed4:	df 93       	push	r29
    5ed6:	cf 93       	push	r28
    5ed8:	cd b7       	in	r28, 0x3d	; 61
    5eda:	de b7       	in	r29, 0x3e	; 62
    5edc:	2d 97       	sbiw	r28, 0x0d	; 13
    5ede:	0f b6       	in	r0, 0x3f	; 63
    5ee0:	f8 94       	cli
    5ee2:	de bf       	out	0x3e, r29	; 62
    5ee4:	0f be       	out	0x3f, r0	; 63
    5ee6:	cd bf       	out	0x3d, r28	; 61
    5ee8:	9c 01       	movw	r18, r24
    5eea:	7b 01       	movw	r14, r22
    5eec:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    5eee:	dc 01       	movw	r26, r24
    5ef0:	15 96       	adiw	r26, 0x05	; 5
    5ef2:	8c 91       	ld	r24, X
    5ef4:	90 e0       	ldi	r25, 0x00	; 0
    5ef6:	c0 97       	sbiw	r24, 0x30	; 48
    5ef8:	68 e0       	ldi	r22, 0x08	; 8
    5efa:	70 e0       	ldi	r23, 0x00	; 0
    5efc:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    5f00:	f7 01       	movw	r30, r14
    5f02:	e8 0f       	add	r30, r24
    5f04:	f1 1d       	adc	r31, r1
    5f06:	80 81       	ld	r24, Z
    5f08:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    5f0a:	f9 01       	movw	r30, r18
    5f0c:	86 81       	ldd	r24, Z+6	; 0x06
    5f0e:	90 e0       	ldi	r25, 0x00	; 0
    5f10:	c0 97       	sbiw	r24, 0x30	; 48
    5f12:	68 e0       	ldi	r22, 0x08	; 8
    5f14:	70 e0       	ldi	r23, 0x00	; 0
    5f16:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    5f1a:	f7 01       	movw	r30, r14
    5f1c:	e8 0f       	add	r30, r24
    5f1e:	f1 1d       	adc	r31, r1
    5f20:	80 81       	ld	r24, Z
    5f22:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    5f24:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    5f26:	8d b7       	in	r24, 0x3d	; 61
    5f28:	9e b7       	in	r25, 0x3e	; 62
    5f2a:	08 97       	sbiw	r24, 0x08	; 8
    5f2c:	0f b6       	in	r0, 0x3f	; 63
    5f2e:	f8 94       	cli
    5f30:	9e bf       	out	0x3e, r25	; 62
    5f32:	0f be       	out	0x3f, r0	; 63
    5f34:	8d bf       	out	0x3d, r24	; 61
    5f36:	ed b7       	in	r30, 0x3d	; 61
    5f38:	fe b7       	in	r31, 0x3e	; 62
    5f3a:	31 96       	adiw	r30, 0x01	; 1
    5f3c:	8e 01       	movw	r16, r28
    5f3e:	0c 5f       	subi	r16, 0xFC	; 252
    5f40:	1f 4f       	sbci	r17, 0xFF	; 255
    5f42:	ad b7       	in	r26, 0x3d	; 61
    5f44:	be b7       	in	r27, 0x3e	; 62
    5f46:	12 96       	adiw	r26, 0x02	; 2
    5f48:	1c 93       	st	X, r17
    5f4a:	0e 93       	st	-X, r16
    5f4c:	11 97       	sbiw	r26, 0x01	; 1
    5f4e:	83 e3       	ldi	r24, 0x33	; 51
    5f50:	97 e1       	ldi	r25, 0x17	; 23
    5f52:	93 83       	std	Z+3, r25	; 0x03
    5f54:	82 83       	std	Z+2, r24	; 0x02
    5f56:	35 83       	std	Z+5, r19	; 0x05
    5f58:	24 83       	std	Z+4, r18	; 0x04
    5f5a:	ce 01       	movw	r24, r28
    5f5c:	01 96       	adiw	r24, 0x01	; 1
    5f5e:	97 83       	std	Z+7, r25	; 0x07
    5f60:	86 83       	std	Z+6, r24	; 0x06
    5f62:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    5f66:	dd 24       	eor	r13, r13
    5f68:	ed b7       	in	r30, 0x3d	; 61
    5f6a:	fe b7       	in	r31, 0x3e	; 62
    5f6c:	38 96       	adiw	r30, 0x08	; 8
    5f6e:	0f b6       	in	r0, 0x3f	; 63
    5f70:	f8 94       	cli
    5f72:	fe bf       	out	0x3e, r31	; 62
    5f74:	0f be       	out	0x3f, r0	; 63
    5f76:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    5f78:	48 01       	movw	r8, r16
    5f7a:	13 c0       	rjmp	.+38     	; 0x5fa2 <GenerateKeyStamp+0xe0>
    5f7c:	f4 01       	movw	r30, r8
    5f7e:	e0 0f       	add	r30, r16
    5f80:	f1 1f       	adc	r31, r17
    5f82:	60 81       	ld	r22, Z
    5f84:	60 53       	subi	r22, 0x30	; 48
    5f86:	f7 01       	movw	r30, r14
    5f88:	e0 0f       	add	r30, r16
    5f8a:	f1 1f       	adc	r31, r17
    5f8c:	40 81       	ld	r20, Z
    5f8e:	40 53       	subi	r20, 0x30	; 48
    5f90:	81 e0       	ldi	r24, 0x01	; 1
    5f92:	0e 94 75 15 	call	0x2aea	; 0x2aea <GeniusCalc>
    5f96:	0a 0d       	add	r16, r10
    5f98:	1b 1d       	adc	r17, r11
    5f9a:	80 5d       	subi	r24, 0xD0	; 208
    5f9c:	d8 01       	movw	r26, r16
    5f9e:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    5fa0:	d3 94       	inc	r13
    5fa2:	0d 2d       	mov	r16, r13
    5fa4:	10 e0       	ldi	r17, 0x00	; 0
    5fa6:	d7 01       	movw	r26, r14
    5fa8:	0d 90       	ld	r0, X+
    5faa:	00 20       	and	r0, r0
    5fac:	e9 f7       	brne	.-6      	; 0x5fa8 <GenerateKeyStamp+0xe6>
    5fae:	11 97       	sbiw	r26, 0x01	; 1
    5fb0:	ae 19       	sub	r26, r14
    5fb2:	bf 09       	sbc	r27, r15
    5fb4:	0a 17       	cp	r16, r26
    5fb6:	1b 07       	cpc	r17, r27
    5fb8:	08 f3       	brcs	.-62     	; 0x5f7c <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    5fba:	aa 0d       	add	r26, r10
    5fbc:	bb 1d       	adc	r27, r11
    5fbe:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    5fc0:	c5 01       	movw	r24, r10
    5fc2:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <WrapCode>
}
    5fc6:	2d 96       	adiw	r28, 0x0d	; 13
    5fc8:	0f b6       	in	r0, 0x3f	; 63
    5fca:	f8 94       	cli
    5fcc:	de bf       	out	0x3e, r29	; 62
    5fce:	0f be       	out	0x3f, r0	; 63
    5fd0:	cd bf       	out	0x3d, r28	; 61
    5fd2:	cf 91       	pop	r28
    5fd4:	df 91       	pop	r29
    5fd6:	1f 91       	pop	r17
    5fd8:	0f 91       	pop	r16
    5fda:	ff 90       	pop	r15
    5fdc:	ef 90       	pop	r14
    5fde:	df 90       	pop	r13
    5fe0:	bf 90       	pop	r11
    5fe2:	af 90       	pop	r10
    5fe4:	9f 90       	pop	r9
    5fe6:	8f 90       	pop	r8
    5fe8:	08 95       	ret

00005fea <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    5fea:	af 92       	push	r10
    5fec:	bf 92       	push	r11
    5fee:	cf 92       	push	r12
    5ff0:	df 92       	push	r13
    5ff2:	ef 92       	push	r14
    5ff4:	ff 92       	push	r15
    5ff6:	0f 93       	push	r16
    5ff8:	1f 93       	push	r17
    5ffa:	df 93       	push	r29
    5ffc:	cf 93       	push	r28
    5ffe:	cd b7       	in	r28, 0x3d	; 61
    6000:	de b7       	in	r29, 0x3e	; 62
    6002:	28 97       	sbiw	r28, 0x08	; 8
    6004:	0f b6       	in	r0, 0x3f	; 63
    6006:	f8 94       	cli
    6008:	de bf       	out	0x3e, r29	; 62
    600a:	0f be       	out	0x3f, r0	; 63
    600c:	cd bf       	out	0x3d, r28	; 61
    600e:	7c 01       	movw	r14, r24
    6010:	c6 2e       	mov	r12, r22
    6012:	5a 01       	movw	r10, r20
	    sprintf_P(strSend,PSTR("Date[%s]"),srcDate);
		uart_print(1,1,strSend);
     #endif
    

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-2,2);
    6014:	fc 01       	movw	r30, r24
    6016:	01 90       	ld	r0, Z+
    6018:	00 20       	and	r0, r0
    601a:	e9 f7       	brne	.-6      	; 0x6016 <GenerateGeniusCode+0x2c>
    601c:	e8 1b       	sub	r30, r24
    601e:	f9 0b       	sbc	r31, r25
    6020:	33 97       	sbiw	r30, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    6022:	e8 0f       	add	r30, r24
    6024:	f9 1f       	adc	r31, r25
    6026:	80 81       	ld	r24, Z
    6028:	89 83       	std	Y+1, r24	; 0x01
    602a:	81 81       	ldd	r24, Z+1	; 0x01
    602c:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    602e:	1b 82       	std	Y+3, r1	; 0x03
    #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("Year:[%s]"),AddYear);
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    6030:	00 d0       	rcall	.+0      	; 0x6032 <GenerateGeniusCode+0x48>
    6032:	00 d0       	rcall	.+0      	; 0x6034 <GenerateGeniusCode+0x4a>
    6034:	00 d0       	rcall	.+0      	; 0x6036 <GenerateGeniusCode+0x4c>
    6036:	ed b7       	in	r30, 0x3d	; 61
    6038:	fe b7       	in	r31, 0x3e	; 62
    603a:	31 96       	adiw	r30, 0x01	; 1
    603c:	8e 01       	movw	r16, r28
    603e:	0c 5f       	subi	r16, 0xFC	; 252
    6040:	1f 4f       	sbci	r17, 0xFF	; 255
    6042:	ad b7       	in	r26, 0x3d	; 61
    6044:	be b7       	in	r27, 0x3e	; 62
    6046:	12 96       	adiw	r26, 0x02	; 2
    6048:	1c 93       	st	X, r17
    604a:	0e 93       	st	-X, r16
    604c:	11 97       	sbiw	r26, 0x01	; 1
    604e:	8e e3       	ldi	r24, 0x3E	; 62
    6050:	97 e1       	ldi	r25, 0x17	; 23
    6052:	93 83       	std	Z+3, r25	; 0x03
    6054:	82 83       	std	Z+2, r24	; 0x02
    6056:	ce 01       	movw	r24, r28
    6058:	01 96       	adiw	r24, 0x01	; 1
    605a:	95 83       	std	Z+5, r25	; 0x05
    605c:	84 83       	std	Z+4, r24	; 0x04
    605e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    6062:	d7 01       	movw	r26, r14
    6064:	0d 90       	ld	r0, X+
    6066:	00 20       	and	r0, r0
    6068:	e9 f7       	brne	.-6      	; 0x6064 <GenerateGeniusCode+0x7a>
    606a:	9d 01       	movw	r18, r26
    606c:	21 50       	subi	r18, 0x01	; 1
    606e:	30 40       	sbci	r19, 0x00	; 0
    6070:	2e 19       	sub	r18, r14
    6072:	3f 09       	sbc	r19, r15
    6074:	d8 01       	movw	r26, r16
    6076:	0d 90       	ld	r0, X+
    6078:	00 20       	and	r0, r0
    607a:	e9 f7       	brne	.-6      	; 0x6076 <GenerateGeniusCode+0x8c>
    607c:	11 97       	sbiw	r26, 0x01	; 1
    607e:	a0 1b       	sub	r26, r16
    6080:	b1 0b       	sbc	r27, r17
    6082:	22 50       	subi	r18, 0x02	; 2
    6084:	30 40       	sbci	r19, 0x00	; 0
    6086:	b7 01       	movw	r22, r14
    6088:	62 0f       	add	r22, r18
    608a:	73 1f       	adc	r23, r19
    608c:	2e 5f       	subi	r18, 0xFE	; 254
    608e:	3f 4f       	sbci	r19, 0xFF	; 255
    6090:	40 e0       	ldi	r20, 0x00	; 0
    6092:	50 e0       	ldi	r21, 0x00	; 0
    6094:	ed b7       	in	r30, 0x3d	; 61
    6096:	fe b7       	in	r31, 0x3e	; 62
    6098:	36 96       	adiw	r30, 0x06	; 6
    609a:	0f b6       	in	r0, 0x3f	; 63
    609c:	f8 94       	cli
    609e:	fe bf       	out	0x3e, r31	; 62
    60a0:	0f be       	out	0x3f, r0	; 63
    60a2:	ed bf       	out	0x3d, r30	; 61
    60a4:	09 c0       	rjmp	.+18     	; 0x60b8 <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    60a6:	f8 01       	movw	r30, r16
    60a8:	e4 0f       	add	r30, r20
    60aa:	f5 1f       	adc	r31, r21
    60ac:	80 81       	ld	r24, Z
    60ae:	fb 01       	movw	r30, r22
    60b0:	81 93       	st	Z+, r24
    60b2:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    60b4:	4f 5f       	subi	r20, 0xFF	; 255
    60b6:	5f 4f       	sbci	r21, 0xFF	; 255
    60b8:	4a 17       	cp	r20, r26
    60ba:	5b 07       	cpc	r21, r27
    60bc:	a0 f3       	brcs	.-24     	; 0x60a6 <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    60be:	ae 0d       	add	r26, r14
    60c0:	bf 1d       	adc	r27, r15
    60c2:	a2 0f       	add	r26, r18
    60c4:	b3 1f       	adc	r27, r19
    60c6:	12 97       	sbiw	r26, 0x02	; 2
    60c8:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("NewDate[%s]"),srcDate);
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    60ca:	00 d0       	rcall	.+0      	; 0x60cc <GenerateGeniusCode+0xe2>
    60cc:	00 d0       	rcall	.+0      	; 0x60ce <GenerateGeniusCode+0xe4>
    60ce:	00 d0       	rcall	.+0      	; 0x60d0 <GenerateGeniusCode+0xe6>
    60d0:	ed b7       	in	r30, 0x3d	; 61
    60d2:	fe b7       	in	r31, 0x3e	; 62
    60d4:	31 96       	adiw	r30, 0x01	; 1
    60d6:	ad b7       	in	r26, 0x3d	; 61
    60d8:	be b7       	in	r27, 0x3e	; 62
    60da:	12 96       	adiw	r26, 0x02	; 2
    60dc:	bc 92       	st	X, r11
    60de:	ae 92       	st	-X, r10
    60e0:	11 97       	sbiw	r26, 0x01	; 1
    60e2:	8b e3       	ldi	r24, 0x3B	; 59
    60e4:	97 e1       	ldi	r25, 0x17	; 23
    60e6:	93 83       	std	Z+3, r25	; 0x03
    60e8:	82 83       	std	Z+2, r24	; 0x02
    60ea:	c4 82       	std	Z+4, r12	; 0x04
    60ec:	15 82       	std	Z+5, r1	; 0x05
    60ee:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    60f2:	dd 24       	eor	r13, r13
    60f4:	d3 94       	inc	r13
    60f6:	ed b7       	in	r30, 0x3d	; 61
    60f8:	fe b7       	in	r31, 0x3e	; 62
    60fa:	36 96       	adiw	r30, 0x06	; 6
    60fc:	0f b6       	in	r0, 0x3f	; 63
    60fe:	f8 94       	cli
    6100:	fe bf       	out	0x3e, r31	; 62
    6102:	0f be       	out	0x3f, r0	; 63
    6104:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    6106:	f0 ed       	ldi	r31, 0xD0	; 208
    6108:	cf 0e       	add	r12, r31
    610a:	0f c0       	rjmp	.+30     	; 0x612a <GenerateGeniusCode+0x140>
    610c:	f7 01       	movw	r30, r14
    610e:	e0 0f       	add	r30, r16
    6110:	f1 1f       	adc	r31, r17
    6112:	40 81       	ld	r20, Z
    6114:	40 53       	subi	r20, 0x30	; 48
    6116:	80 e0       	ldi	r24, 0x00	; 0
    6118:	6c 2d       	mov	r22, r12
    611a:	0e 94 75 15 	call	0x2aea	; 0x2aea <GeniusCalc>
    611e:	0a 0d       	add	r16, r10
    6120:	1b 1d       	adc	r17, r11
    6122:	80 5d       	subi	r24, 0xD0	; 208
    6124:	d8 01       	movw	r26, r16
    6126:	8c 93       	st	X, r24
		uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    6128:	d3 94       	inc	r13
    612a:	0d 2d       	mov	r16, r13
    612c:	10 e0       	ldi	r17, 0x00	; 0
    612e:	d7 01       	movw	r26, r14
    6130:	0d 90       	ld	r0, X+
    6132:	00 20       	and	r0, r0
    6134:	e9 f7       	brne	.-6      	; 0x6130 <GenerateGeniusCode+0x146>
    6136:	11 97       	sbiw	r26, 0x01	; 1
    6138:	ae 19       	sub	r26, r14
    613a:	bf 09       	sbc	r27, r15
    613c:	0a 17       	cp	r16, r26
    613e:	1b 07       	cpc	r17, r27
    6140:	28 f3       	brcs	.-54     	; 0x610c <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    6142:	aa 0d       	add	r26, r10
    6144:	bb 1d       	adc	r27, r11
    6146:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    6148:	c5 01       	movw	r24, r10
    614a:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   uart_print(1,1,strSend);     
	 #endif
}
    614e:	28 96       	adiw	r28, 0x08	; 8
    6150:	0f b6       	in	r0, 0x3f	; 63
    6152:	f8 94       	cli
    6154:	de bf       	out	0x3e, r29	; 62
    6156:	0f be       	out	0x3f, r0	; 63
    6158:	cd bf       	out	0x3d, r28	; 61
    615a:	cf 91       	pop	r28
    615c:	df 91       	pop	r29
    615e:	1f 91       	pop	r17
    6160:	0f 91       	pop	r16
    6162:	ff 90       	pop	r15
    6164:	ef 90       	pop	r14
    6166:	df 90       	pop	r13
    6168:	cf 90       	pop	r12
    616a:	bf 90       	pop	r11
    616c:	af 90       	pop	r10
    616e:	08 95       	ret

00006170 <GeneratePrintInit>:





void GeneratePrintInit(){//Create Initialize Print 
    6170:	cf 92       	push	r12
    6172:	df 92       	push	r13
    6174:	ef 92       	push	r14
    6176:	ff 92       	push	r15
    6178:	0f 93       	push	r16
    617a:	1f 93       	push	r17
    617c:	df 93       	push	r29
    617e:	cf 93       	push	r28
    6180:	cd b7       	in	r28, 0x3d	; 61
    6182:	de b7       	in	r29, 0x3e	; 62
    6184:	62 97       	sbiw	r28, 0x12	; 18
    6186:	0f b6       	in	r0, 0x3f	; 63
    6188:	f8 94       	cli
    618a:	de bf       	out	0x3e, r29	; 62
    618c:	0f be       	out	0x3f, r0	; 63
    618e:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    6190:	00 d0       	rcall	.+0      	; 0x6192 <GeneratePrintInit+0x22>
    6192:	00 d0       	rcall	.+0      	; 0x6194 <GeneratePrintInit+0x24>
    6194:	6e 01       	movw	r12, r28
    6196:	08 94       	sec
    6198:	c1 1c       	adc	r12, r1
    619a:	d1 1c       	adc	r13, r1
    619c:	ad b7       	in	r26, 0x3d	; 61
    619e:	be b7       	in	r27, 0x3e	; 62
    61a0:	12 96       	adiw	r26, 0x02	; 2
    61a2:	dc 92       	st	X, r13
    61a4:	ce 92       	st	-X, r12
    61a6:	11 97       	sbiw	r26, 0x01	; 1
    61a8:	8d ec       	ldi	r24, 0xCD	; 205
    61aa:	9c e1       	ldi	r25, 0x1C	; 28
    61ac:	14 96       	adiw	r26, 0x04	; 4
    61ae:	9c 93       	st	X, r25
    61b0:	8e 93       	st	-X, r24
    61b2:	13 97       	sbiw	r26, 0x03	; 3
    61b4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    61b8:	e7 e0       	ldi	r30, 0x07	; 7
    61ba:	ee 2e       	mov	r14, r30
    61bc:	f1 2c       	mov	r15, r1
    61be:	ec 0e       	add	r14, r28
    61c0:	fd 1e       	adc	r15, r29
    61c2:	ed b7       	in	r30, 0x3d	; 61
    61c4:	fe b7       	in	r31, 0x3e	; 62
    61c6:	f2 82       	std	Z+2, r15	; 0x02
    61c8:	e1 82       	std	Z+1, r14	; 0x01
    61ca:	82 ec       	ldi	r24, 0xC2	; 194
    61cc:	9c e1       	ldi	r25, 0x1C	; 28
    61ce:	94 83       	std	Z+4, r25	; 0x04
    61d0:	83 83       	std	Z+3, r24	; 0x03
    61d2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    61d6:	00 d0       	rcall	.+0      	; 0x61d8 <GeneratePrintInit+0x68>
    61d8:	00 d0       	rcall	.+0      	; 0x61da <GeneratePrintInit+0x6a>
    61da:	ed b7       	in	r30, 0x3d	; 61
    61dc:	fe b7       	in	r31, 0x3e	; 62
    61de:	31 96       	adiw	r30, 0x01	; 1
    61e0:	0c ee       	ldi	r16, 0xEC	; 236
    61e2:	13 e0       	ldi	r17, 0x03	; 3
    61e4:	ad b7       	in	r26, 0x3d	; 61
    61e6:	be b7       	in	r27, 0x3e	; 62
    61e8:	12 96       	adiw	r26, 0x02	; 2
    61ea:	1c 93       	st	X, r17
    61ec:	0e 93       	st	-X, r16
    61ee:	11 97       	sbiw	r26, 0x01	; 1
    61f0:	80 e5       	ldi	r24, 0x50	; 80
    61f2:	9c e1       	ldi	r25, 0x1C	; 28
    61f4:	93 83       	std	Z+3, r25	; 0x03
    61f6:	82 83       	std	Z+2, r24	; 0x02
    61f8:	d5 82       	std	Z+5, r13	; 0x05
    61fa:	c4 82       	std	Z+4, r12	; 0x04
    61fc:	f7 82       	std	Z+7, r15	; 0x07
    61fe:	e6 82       	std	Z+6, r14	; 0x06
    6200:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 uart_print(0,1,PrintBuffer);
    6204:	ed b7       	in	r30, 0x3d	; 61
    6206:	fe b7       	in	r31, 0x3e	; 62
    6208:	38 96       	adiw	r30, 0x08	; 8
    620a:	0f b6       	in	r0, 0x3f	; 63
    620c:	f8 94       	cli
    620e:	fe bf       	out	0x3e, r31	; 62
    6210:	0f be       	out	0x3f, r0	; 63
    6212:	ed bf       	out	0x3d, r30	; 61
    6214:	80 e0       	ldi	r24, 0x00	; 0
    6216:	61 e0       	ldi	r22, 0x01	; 1
    6218:	a8 01       	movw	r20, r16
    621a:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    621e:	f8 01       	movw	r30, r16
    6220:	01 90       	ld	r0, Z+
    6222:	00 20       	and	r0, r0
    6224:	e9 f7       	brne	.-6      	; 0x6220 <GeneratePrintInit+0xb0>
    6226:	31 97       	sbiw	r30, 0x01	; 1
    6228:	e0 1b       	sub	r30, r16
    622a:	f1 0b       	sbc	r31, r17
    622c:	f0 93 8e 01 	sts	0x018E, r31
    6230:	e0 93 8d 01 	sts	0x018D, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    6234:	80 e3       	ldi	r24, 0x30	; 48
    6236:	80 93 b5 01 	sts	0x01B5, r24
	 IsFreePrinting=True;
    623a:	81 e0       	ldi	r24, 0x01	; 1
    623c:	80 93 a8 01 	sts	0x01A8, r24
}
    6240:	62 96       	adiw	r28, 0x12	; 18
    6242:	0f b6       	in	r0, 0x3f	; 63
    6244:	f8 94       	cli
    6246:	de bf       	out	0x3e, r29	; 62
    6248:	0f be       	out	0x3f, r0	; 63
    624a:	cd bf       	out	0x3d, r28	; 61
    624c:	cf 91       	pop	r28
    624e:	df 91       	pop	r29
    6250:	1f 91       	pop	r17
    6252:	0f 91       	pop	r16
    6254:	ff 90       	pop	r15
    6256:	ef 90       	pop	r14
    6258:	df 90       	pop	r13
    625a:	cf 90       	pop	r12
    625c:	08 95       	ret

0000625e <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    625e:	9f 92       	push	r9
    6260:	af 92       	push	r10
    6262:	bf 92       	push	r11
    6264:	cf 92       	push	r12
    6266:	df 92       	push	r13
    6268:	ef 92       	push	r14
    626a:	ff 92       	push	r15
    626c:	0f 93       	push	r16
    626e:	1f 93       	push	r17
    6270:	df 93       	push	r29
    6272:	cf 93       	push	r28
    6274:	cd b7       	in	r28, 0x3d	; 61
    6276:	de b7       	in	r29, 0x3e	; 62
    6278:	64 97       	sbiw	r28, 0x14	; 20
    627a:	0f b6       	in	r0, 0x3f	; 63
    627c:	f8 94       	cli
    627e:	de bf       	out	0x3e, r29	; 62
    6280:	0f be       	out	0x3f, r0	; 63
    6282:	cd bf       	out	0x3d, r28	; 61
    6284:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6286:	e1 99       	sbic	0x1c, 1	; 28
    6288:	fe cf       	rjmp	.-4      	; 0x6286 <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    628a:	8f e3       	ldi	r24, 0x3F	; 63
    628c:	90 e0       	ldi	r25, 0x00	; 0
    628e:	9f bb       	out	0x1f, r25	; 31
    6290:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6292:	e0 9a       	sbi	0x1c, 0	; 28
    6294:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6296:	e1 99       	sbic	0x1c, 1	; 28
    6298:	fe cf       	rjmp	.-4      	; 0x6296 <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    629a:	8e e3       	ldi	r24, 0x3E	; 62
    629c:	90 e0       	ldi	r25, 0x00	; 0
    629e:	9f bb       	out	0x1f, r25	; 31
    62a0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    62a2:	e0 9a       	sbi	0x1c, 0	; 28
    62a4:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    62a6:	f6 01       	movw	r30, r12
    62a8:	01 90       	ld	r0, Z+
    62aa:	00 20       	and	r0, r0
    62ac:	e9 f7       	brne	.-6      	; 0x62a8 <FormatCurrency+0x4a>
    62ae:	31 97       	sbiw	r30, 0x01	; 1
    62b0:	ee 2e       	mov	r14, r30
    62b2:	ec 18       	sub	r14, r12
    62b4:	fe 01       	movw	r30, r28
    62b6:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    62b8:	ce 01       	movw	r24, r28
    62ba:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    62bc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    62be:	e8 17       	cp	r30, r24
    62c0:	f9 07       	cpc	r31, r25
    62c2:	e1 f7       	brne	.-8      	; 0x62bc <FormatCurrency+0x5e>
    62c4:	f6 01       	movw	r30, r12
    62c6:	fe 2c       	mov	r15, r14
    62c8:	80 e0       	ldi	r24, 0x00	; 0
    62ca:	20 e0       	ldi	r18, 0x00	; 0
    62cc:	09 c0       	rjmp	.+18     	; 0x62e0 <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    62ce:	90 81       	ld	r25, Z
    62d0:	93 17       	cp	r25, r19
    62d2:	09 f4       	brne	.+2      	; 0x62d6 <FormatCurrency+0x78>
    62d4:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    62d6:	99 15       	cp	r25, r9
    62d8:	09 f4       	brne	.+2      	; 0x62dc <FormatCurrency+0x7e>
    62da:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    62dc:	8f 5f       	subi	r24, 0xFF	; 255
    62de:	31 96       	adiw	r30, 0x01	; 1
    62e0:	8e 15       	cp	r24, r14
    62e2:	a8 f3       	brcs	.-22     	; 0x62ce <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    62e4:	22 23       	and	r18, r18
    62e6:	09 f0       	breq	.+2      	; 0x62ea <FormatCurrency+0x8c>
    62e8:	5e c0       	rjmp	.+188    	; 0x63a6 <FormatCurrency+0x148>
    62ea:	83 e0       	ldi	r24, 0x03	; 3
    62ec:	8f 15       	cp	r24, r15
    62ee:	08 f0       	brcs	.+2      	; 0x62f2 <FormatCurrency+0x94>
    62f0:	5a c0       	rjmp	.+180    	; 0x63a6 <FormatCurrency+0x148>
    62f2:	40 e0       	ldi	r20, 0x00	; 0
    62f4:	20 e0       	ldi	r18, 0x00	; 0
    62f6:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    62f8:	af 2c       	mov	r10, r15
    62fa:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    62fc:	8e 01       	movw	r16, r28
    62fe:	0f 5f       	subi	r16, 0xFF	; 255
    6300:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    6302:	c5 01       	movw	r24, r10
    6304:	82 1b       	sub	r24, r18
    6306:	93 0b       	sbc	r25, r19
    6308:	63 e0       	ldi	r22, 0x03	; 3
    630a:	70 e0       	ldi	r23, 0x00	; 0
    630c:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    6310:	89 2b       	or	r24, r25
    6312:	49 f4       	brne	.+18     	; 0x6326 <FormatCurrency+0xc8>
    6314:	2f 15       	cp	r18, r15
    6316:	38 f4       	brcc	.+14     	; 0x6326 <FormatCurrency+0xc8>
    6318:	22 23       	and	r18, r18
    631a:	29 f0       	breq	.+10     	; 0x6326 <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    631c:	f8 01       	movw	r30, r16
    631e:	e4 0f       	add	r30, r20
    6320:	f1 1d       	adc	r31, r1
    6322:	90 82       	st	Z, r9
		        iPos++;
    6324:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    6326:	d8 01       	movw	r26, r16
    6328:	a4 0f       	add	r26, r20
    632a:	b1 1d       	adc	r27, r1
    632c:	f6 01       	movw	r30, r12
    632e:	e2 0f       	add	r30, r18
    6330:	f3 1f       	adc	r31, r19
    6332:	80 81       	ld	r24, Z
    6334:	8c 93       	st	X, r24
			    iPos++;
    6336:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6338:	f8 01       	movw	r30, r16
    633a:	e4 0f       	add	r30, r20
    633c:	f1 1d       	adc	r31, r1
    633e:	10 82       	st	Z, r1
    6340:	2f 5f       	subi	r18, 0xFF	; 255
    6342:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    6344:	2f 15       	cp	r18, r15
    6346:	e8 f2       	brcs	.-70     	; 0x6302 <FormatCurrency+0xa4>
    6348:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    634a:	9e 01       	movw	r18, r28
    634c:	2f 5f       	subi	r18, 0xFF	; 255
    634e:	3f 4f       	sbci	r19, 0xFF	; 255
    6350:	0e c0       	rjmp	.+28     	; 0x636e <FormatCurrency+0x110>
    6352:	d9 01       	movw	r26, r18
    6354:	a4 0f       	add	r26, r20
    6356:	b1 1d       	adc	r27, r1
    6358:	f6 01       	movw	r30, r12
    635a:	e9 0f       	add	r30, r25
    635c:	f1 1d       	adc	r31, r1
    635e:	80 81       	ld	r24, Z
    6360:	8c 93       	st	X, r24
			    iPos++;
    6362:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6364:	f9 01       	movw	r30, r18
    6366:	e4 0f       	add	r30, r20
    6368:	f1 1d       	adc	r31, r1
    636a:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    636c:	9f 5f       	subi	r25, 0xFF	; 255
    636e:	9e 15       	cp	r25, r14
    6370:	80 f3       	brcs	.-32     	; 0x6352 <FormatCurrency+0xf4>
    6372:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6374:	9e 01       	movw	r18, r28
    6376:	2f 5f       	subi	r18, 0xFF	; 255
    6378:	3f 4f       	sbci	r19, 0xFF	; 255
    637a:	09 c0       	rjmp	.+18     	; 0x638e <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    637c:	f6 01       	movw	r30, r12
    637e:	ea 0f       	add	r30, r26
    6380:	fb 1f       	adc	r31, r27
    6382:	a2 0f       	add	r26, r18
    6384:	b3 1f       	adc	r27, r19
    6386:	8c 91       	ld	r24, X
    6388:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    638a:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    638c:	9f 5f       	subi	r25, 0xFF	; 255
    638e:	a9 2f       	mov	r26, r25
    6390:	b0 e0       	ldi	r27, 0x00	; 0
    6392:	f9 01       	movw	r30, r18
    6394:	01 90       	ld	r0, Z+
    6396:	00 20       	and	r0, r0
    6398:	e9 f7       	brne	.-6      	; 0x6394 <FormatCurrency+0x136>
    639a:	31 97       	sbiw	r30, 0x01	; 1
    639c:	e2 1b       	sub	r30, r18
    639e:	f3 0b       	sbc	r31, r19
    63a0:	ae 17       	cp	r26, r30
    63a2:	bf 07       	cpc	r27, r31
    63a4:	58 f3       	brcs	.-42     	; 0x637c <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    63a6:	64 96       	adiw	r28, 0x14	; 20
    63a8:	0f b6       	in	r0, 0x3f	; 63
    63aa:	f8 94       	cli
    63ac:	de bf       	out	0x3e, r29	; 62
    63ae:	0f be       	out	0x3f, r0	; 63
    63b0:	cd bf       	out	0x3d, r28	; 61
    63b2:	cf 91       	pop	r28
    63b4:	df 91       	pop	r29
    63b6:	1f 91       	pop	r17
    63b8:	0f 91       	pop	r16
    63ba:	ff 90       	pop	r15
    63bc:	ef 90       	pop	r14
    63be:	df 90       	pop	r13
    63c0:	cf 90       	pop	r12
    63c2:	bf 90       	pop	r11
    63c4:	af 90       	pop	r10
    63c6:	9f 90       	pop	r9
    63c8:	08 95       	ret

000063ca <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    63ca:	ef 92       	push	r14
    63cc:	ff 92       	push	r15
    63ce:	0f 93       	push	r16
    63d0:	1f 93       	push	r17
    63d2:	df 93       	push	r29
    63d4:	cf 93       	push	r28
    63d6:	cd b7       	in	r28, 0x3d	; 61
    63d8:	de b7       	in	r29, 0x3e	; 62
    63da:	64 97       	sbiw	r28, 0x14	; 20
    63dc:	0f b6       	in	r0, 0x3f	; 63
    63de:	f8 94       	cli
    63e0:	de bf       	out	0x3e, r29	; 62
    63e2:	0f be       	out	0x3f, r0	; 63
    63e4:	cd bf       	out	0x3d, r28	; 61
    63e6:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    63e8:	66 23       	and	r22, r22
    63ea:	09 f4       	brne	.+2      	; 0x63ee <FormatDecimal+0x24>
    63ec:	56 c0       	rjmp	.+172    	; 0x649a <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    63ee:	e1 99       	sbic	0x1c, 1	; 28
    63f0:	fe cf       	rjmp	.-4      	; 0x63ee <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    63f2:	8e e3       	ldi	r24, 0x3E	; 62
    63f4:	90 e0       	ldi	r25, 0x00	; 0
    63f6:	9f bb       	out	0x1f, r25	; 31
    63f8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    63fa:	e0 9a       	sbi	0x1c, 0	; 28
    63fc:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    63fe:	f8 01       	movw	r30, r16
    6400:	01 90       	ld	r0, Z+
    6402:	00 20       	and	r0, r0
    6404:	e9 f7       	brne	.-6      	; 0x6400 <FormatDecimal+0x36>
    6406:	31 97       	sbiw	r30, 0x01	; 1
    6408:	3e 2f       	mov	r19, r30
    640a:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    640c:	63 17       	cp	r22, r19
    640e:	b8 f5       	brcc	.+110    	; 0x647e <FormatDecimal+0xb4>
    6410:	f3 2e       	mov	r15, r19
    6412:	f6 1a       	sub	r15, r22
    6414:	b8 01       	movw	r22, r16
    6416:	d8 01       	movw	r26, r16
    6418:	20 e0       	ldi	r18, 0x00	; 0
    641a:	90 e0       	ldi	r25, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    641c:	ae 01       	movw	r20, r28
    641e:	4f 5f       	subi	r20, 0xFF	; 255
    6420:	5f 4f       	sbci	r21, 0xFF	; 255
    6422:	0e c0       	rjmp	.+28     	; 0x6440 <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    6424:	2f 15       	cp	r18, r15
    6426:	29 f4       	brne	.+10     	; 0x6432 <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    6428:	fa 01       	movw	r30, r20
    642a:	e9 0f       	add	r30, r25
    642c:	f1 1d       	adc	r31, r1
    642e:	e0 82       	st	Z, r14
				 iPos++;
    6430:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    6432:	fa 01       	movw	r30, r20
    6434:	e9 0f       	add	r30, r25
    6436:	f1 1d       	adc	r31, r1
    6438:	8d 91       	ld	r24, X+
    643a:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    643c:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    643e:	2f 5f       	subi	r18, 0xFF	; 255
    6440:	23 17       	cp	r18, r19
    6442:	80 f3       	brcs	.-32     	; 0x6424 <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    6444:	9e 01       	movw	r18, r28
    6446:	2f 5f       	subi	r18, 0xFF	; 255
    6448:	3f 4f       	sbci	r19, 0xFF	; 255
    644a:	f9 01       	movw	r30, r18
    644c:	e9 0f       	add	r30, r25
    644e:	f1 1d       	adc	r31, r1
    6450:	10 82       	st	Z, r1
		 
         //uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    6452:	f9 01       	movw	r30, r18
    6454:	01 90       	ld	r0, Z+
    6456:	00 20       	and	r0, r0
    6458:	e9 f7       	brne	.-6      	; 0x6454 <FormatDecimal+0x8a>
    645a:	31 97       	sbiw	r30, 0x01	; 1
    645c:	9e 2f       	mov	r25, r30
    645e:	92 1b       	sub	r25, r18
    6460:	d9 01       	movw	r26, r18
    6462:	04 c0       	rjmp	.+8      	; 0x646c <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    6464:	8d 91       	ld	r24, X+
    6466:	fb 01       	movw	r30, r22
    6468:	81 93       	st	Z+, r24
    646a:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    646c:	8a 2f       	mov	r24, r26
    646e:	82 1b       	sub	r24, r18
    6470:	89 17       	cp	r24, r25
    6472:	c0 f3       	brcs	.-16     	; 0x6464 <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    6474:	09 0f       	add	r16, r25
    6476:	11 1d       	adc	r17, r1
    6478:	f8 01       	movw	r30, r16
    647a:	10 82       	st	Z, r1
    647c:	0e c0       	rjmp	.+28     	; 0x649a <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    647e:	6f 5f       	subi	r22, 0xFF	; 255
    6480:	c8 01       	movw	r24, r16
    6482:	0e 94 bd 24 	call	0x497a	; 0x497a <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    6486:	f8 01       	movw	r30, r16
    6488:	01 90       	ld	r0, Z+
    648a:	00 20       	and	r0, r0
    648c:	e9 f7       	brne	.-6      	; 0x6488 <FormatDecimal+0xbe>
    648e:	31 97       	sbiw	r30, 0x01	; 1
    6490:	3e 2f       	mov	r19, r30
    6492:	30 1b       	sub	r19, r16
    6494:	ff 24       	eor	r15, r15
    6496:	f3 94       	inc	r15
    6498:	bd cf       	rjmp	.-134    	; 0x6414 <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //uart_print(1,1,strRawData); 
}
    649a:	64 96       	adiw	r28, 0x14	; 20
    649c:	0f b6       	in	r0, 0x3f	; 63
    649e:	f8 94       	cli
    64a0:	de bf       	out	0x3e, r29	; 62
    64a2:	0f be       	out	0x3f, r0	; 63
    64a4:	cd bf       	out	0x3d, r28	; 61
    64a6:	cf 91       	pop	r28
    64a8:	df 91       	pop	r29
    64aa:	1f 91       	pop	r17
    64ac:	0f 91       	pop	r16
    64ae:	ff 90       	pop	r15
    64b0:	ef 90       	pop	r14
    64b2:	08 95       	ret

000064b4 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    64b4:	68 2f       	mov	r22, r24
    64b6:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    64b8:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormatDecimal>
}
    64bc:	08 95       	ret

000064be <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    64be:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    64c0:	e1 99       	sbic	0x1c, 1	; 28
    64c2:	fe cf       	rjmp	.-4      	; 0x64c0 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    64c4:	8c e3       	ldi	r24, 0x3C	; 60
    64c6:	90 e0       	ldi	r25, 0x00	; 0
    64c8:	9f bb       	out	0x1f, r25	; 31
    64ca:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    64cc:	e0 9a       	sbi	0x1c, 0	; 28
    64ce:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    64d0:	c9 01       	movw	r24, r18
    64d2:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormatDecimal>
}
    64d6:	08 95       	ret

000064d8 <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    64d8:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    64da:	e1 99       	sbic	0x1c, 1	; 28
    64dc:	fe cf       	rjmp	.-4      	; 0x64da <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    64de:	8d e3       	ldi	r24, 0x3D	; 61
    64e0:	90 e0       	ldi	r25, 0x00	; 0
    64e2:	9f bb       	out	0x1f, r25	; 31
    64e4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    64e6:	e0 9a       	sbi	0x1c, 0	; 28
    64e8:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    64ea:	c9 01       	movw	r24, r18
    64ec:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormatDecimal>
}
    64f0:	08 95       	ret

000064f2 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    64f2:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    64f4:	e1 99       	sbic	0x1c, 1	; 28
    64f6:	fe cf       	rjmp	.-4      	; 0x64f4 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    64f8:	8a e3       	ldi	r24, 0x3A	; 58
    64fa:	90 e0       	ldi	r25, 0x00	; 0
    64fc:	9f bb       	out	0x1f, r25	; 31
    64fe:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6500:	e0 9a       	sbi	0x1c, 0	; 28
    6502:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6504:	c9 01       	movw	r24, r18
    6506:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormatDecimal>
}
    650a:	08 95       	ret

0000650c <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    650c:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    650e:	e1 99       	sbic	0x1c, 1	; 28
    6510:	fe cf       	rjmp	.-4      	; 0x650e <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6512:	8b e3       	ldi	r24, 0x3B	; 59
    6514:	90 e0       	ldi	r25, 0x00	; 0
    6516:	9f bb       	out	0x1f, r25	; 31
    6518:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    651a:	e0 9a       	sbi	0x1c, 0	; 28
    651c:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    651e:	c9 01       	movw	r24, r18
    6520:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormatDecimal>
}
    6524:	08 95       	ret

00006526 <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    6526:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6528:	e1 99       	sbic	0x1c, 1	; 28
    652a:	fe cf       	rjmp	.-4      	; 0x6528 <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    652c:	89 e3       	ldi	r24, 0x39	; 57
    652e:	90 e0       	ldi	r25, 0x00	; 0
    6530:	9f bb       	out	0x1f, r25	; 31
    6532:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6534:	e0 9a       	sbi	0x1c, 0	; 28
    6536:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    6538:	c9 01       	movw	r24, r18
    653a:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormatDecimal>
}
    653e:	08 95       	ret

00006540 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    6540:	2f 92       	push	r2
    6542:	3f 92       	push	r3
    6544:	4f 92       	push	r4
    6546:	5f 92       	push	r5
    6548:	6f 92       	push	r6
    654a:	7f 92       	push	r7
    654c:	8f 92       	push	r8
    654e:	9f 92       	push	r9
    6550:	af 92       	push	r10
    6552:	bf 92       	push	r11
    6554:	cf 92       	push	r12
    6556:	df 92       	push	r13
    6558:	ef 92       	push	r14
    655a:	ff 92       	push	r15
    655c:	0f 93       	push	r16
    655e:	1f 93       	push	r17
    6560:	df 93       	push	r29
    6562:	cf 93       	push	r28
    6564:	cd b7       	in	r28, 0x3d	; 61
    6566:	de b7       	in	r29, 0x3e	; 62
    6568:	c8 5f       	subi	r28, 0xF8	; 248
    656a:	d0 40       	sbci	r29, 0x00	; 0
    656c:	0f b6       	in	r0, 0x3f	; 63
    656e:	f8 94       	cli
    6570:	de bf       	out	0x3e, r29	; 62
    6572:	0f be       	out	0x3f, r0	; 63
    6574:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char iTotal;//,PadLength;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    6576:	10 91 e8 01 	lds	r17, 0x01E8
    657a:	16 30       	cpi	r17, 0x06	; 6
    657c:	09 f4       	brne	.+2      	; 0x6580 <systemGenerateReport+0x40>
    657e:	5d c2       	rjmp	.+1210   	; 0x6a3a <systemGenerateReport+0x4fa>
    6580:	17 30       	cpi	r17, 0x07	; 7
    6582:	98 f4       	brcc	.+38     	; 0x65aa <systemGenerateReport+0x6a>
    6584:	12 30       	cpi	r17, 0x02	; 2
    6586:	09 f4       	brne	.+2      	; 0x658a <systemGenerateReport+0x4a>
    6588:	a7 c0       	rjmp	.+334    	; 0x66d8 <systemGenerateReport+0x198>
    658a:	13 30       	cpi	r17, 0x03	; 3
    658c:	38 f4       	brcc	.+14     	; 0x659c <systemGenerateReport+0x5c>
    658e:	11 23       	and	r17, r17
    6590:	31 f1       	breq	.+76     	; 0x65de <systemGenerateReport+0x9e>
    6592:	11 30       	cpi	r17, 0x01	; 1
    6594:	11 f0       	breq	.+4      	; 0x659a <systemGenerateReport+0x5a>
    6596:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <systemGenerateReport+0x1632>
    659a:	2d c0       	rjmp	.+90     	; 0x65f6 <systemGenerateReport+0xb6>
    659c:	14 30       	cpi	r17, 0x04	; 4
    659e:	09 f4       	brne	.+2      	; 0x65a2 <systemGenerateReport+0x62>
    65a0:	c8 c1       	rjmp	.+912    	; 0x6932 <systemGenerateReport+0x3f2>
    65a2:	15 30       	cpi	r17, 0x05	; 5
    65a4:	08 f0       	brcs	.+2      	; 0x65a8 <systemGenerateReport+0x68>
    65a6:	4c c7       	rjmp	.+3736   	; 0x7440 <systemGenerateReport+0xf00>
    65a8:	bb c1       	rjmp	.+886    	; 0x6920 <systemGenerateReport+0x3e0>
    65aa:	19 30       	cpi	r17, 0x09	; 9
    65ac:	09 f4       	brne	.+2      	; 0x65b0 <systemGenerateReport+0x70>
    65ae:	48 c7       	rjmp	.+3728   	; 0x7440 <systemGenerateReport+0xf00>
    65b0:	1a 30       	cpi	r17, 0x0A	; 10
    65b2:	40 f4       	brcc	.+16     	; 0x65c4 <systemGenerateReport+0x84>
    65b4:	17 30       	cpi	r17, 0x07	; 7
    65b6:	09 f4       	brne	.+2      	; 0x65ba <systemGenerateReport+0x7a>
    65b8:	aa c2       	rjmp	.+1364   	; 0x6b0e <systemGenerateReport+0x5ce>
    65ba:	18 30       	cpi	r17, 0x08	; 8
    65bc:	11 f0       	breq	.+4      	; 0x65c2 <systemGenerateReport+0x82>
    65be:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <systemGenerateReport+0x1632>
    65c2:	b3 c2       	rjmp	.+1382   	; 0x6b2a <systemGenerateReport+0x5ea>
    65c4:	1b 30       	cpi	r17, 0x0B	; 11
    65c6:	11 f4       	brne	.+4      	; 0x65cc <systemGenerateReport+0x8c>
    65c8:	0c 94 ac 3d 	jmp	0x7b58	; 0x7b58 <systemGenerateReport+0x1618>
    65cc:	1b 30       	cpi	r17, 0x0B	; 11
    65ce:	08 f4       	brcc	.+2      	; 0x65d2 <systemGenerateReport+0x92>
    65d0:	3e c7       	rjmp	.+3708   	; 0x744e <systemGenerateReport+0xf0e>
    65d2:	1c 30       	cpi	r17, 0x0C	; 12
    65d4:	11 f0       	breq	.+4      	; 0x65da <systemGenerateReport+0x9a>
    65d6:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <systemGenerateReport+0x1632>
    65da:	0c 94 b4 3d 	jmp	0x7b68	; 0x7b68 <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    65de:	80 91 86 01 	lds	r24, 0x0186
    65e2:	81 30       	cpi	r24, 0x01	; 1
    65e4:	11 f0       	breq	.+4      	; 0x65ea <systemGenerateReport+0xaa>
    65e6:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    65ea:	10 92 86 01 	sts	0x0186, r1
			  IsFinishPrintingTotalizer=False;
    65ee:	10 92 87 01 	sts	0x0187, r1
    65f2:	0c 94 b1 3d 	jmp	0x7b62	; 0x7b62 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    65f6:	10 93 e7 01 	sts	0x01E7, r17
		  xNozzle=1;
    65fa:	10 93 e6 01 	sts	0x01E6, r17
		  RepPos=0;
    65fe:	10 92 d7 01 	sts	0x01D7, r1
    6602:	10 92 d6 01 	sts	0x01D6, r1
    6606:	ec ee       	ldi	r30, 0xEC	; 236
    6608:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    660a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    660c:	85 e0       	ldi	r24, 0x05	; 5
    660e:	ed 37       	cpi	r30, 0x7D	; 125
    6610:	f8 07       	cpc	r31, r24
    6612:	d9 f7       	brne	.-10     	; 0x660a <systemGenerateReport+0xca>
    6614:	fe 01       	movw	r30, r28
    6616:	eb 55       	subi	r30, 0x5B	; 91
    6618:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    661a:	ce 01       	movw	r24, r28
    661c:	8b 50       	subi	r24, 0x0B	; 11
    661e:	9f 4f       	sbci	r25, 0xFF	; 255
    6620:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6622:	e8 17       	cp	r30, r24
    6624:	f9 07       	cpc	r31, r25
    6626:	e1 f7       	brne	.-8      	; 0x6620 <systemGenerateReport+0xe0>
    6628:	fe 01       	movw	r30, r28
    662a:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    662c:	cf 01       	movw	r24, r30
    662e:	0f 96       	adiw	r24, 0x0f	; 15
    6630:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6632:	e8 17       	cp	r30, r24
    6634:	f9 07       	cpc	r31, r25
    6636:	e1 f7       	brne	.-8      	; 0x6630 <systemGenerateReport+0xf0>
    6638:	fe 01       	movw	r30, r28
    663a:	ea 5b       	subi	r30, 0xBA	; 186
    663c:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    663e:	cf 01       	movw	r24, r30
    6640:	0f 96       	adiw	r24, 0x0f	; 15
    6642:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6644:	e8 17       	cp	r30, r24
    6646:	f9 07       	cpc	r31, r25
    6648:	e1 f7       	brne	.-8      	; 0x6642 <systemGenerateReport+0x102>
    664a:	e7 ef       	ldi	r30, 0xF7	; 247
    664c:	f7 e0       	ldi	r31, 0x07	; 7
	     strMemory[i]=data;
    664e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6650:	98 e0       	ldi	r25, 0x08	; 8
    6652:	eb 30       	cpi	r30, 0x0B	; 11
    6654:	f9 07       	cpc	r31, r25
    6656:	d9 f7       	brne	.-10     	; 0x664e <systemGenerateReport+0x10e>
    6658:	e8 ea       	ldi	r30, 0xA8	; 168
    665a:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
    665c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    665e:	a8 e0       	ldi	r26, 0x08	; 8
    6660:	ec 3b       	cpi	r30, 0xBC	; 188
    6662:	fa 07       	cpc	r31, r26
    6664:	d9 f7       	brne	.-10     	; 0x665c <systemGenerateReport+0x11c>
    6666:	ed e2       	ldi	r30, 0x2D	; 45
    6668:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    666a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    666c:	bc e0       	ldi	r27, 0x0C	; 12
    666e:	ec 33       	cpi	r30, 0x3C	; 60
    6670:	fb 07       	cpc	r31, r27
    6672:	d9 f7       	brne	.-10     	; 0x666a <systemGenerateReport+0x12a>
    6674:	e5 e0       	ldi	r30, 0x05	; 5
    6676:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    6678:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    667a:	89 e0       	ldi	r24, 0x09	; 9
    667c:	e4 31       	cpi	r30, 0x14	; 20
    667e:	f8 07       	cpc	r31, r24
    6680:	d9 f7       	brne	.-10     	; 0x6678 <systemGenerateReport+0x138>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6682:	e1 99       	sbic	0x1c, 1	; 28
    6684:	fe cf       	rjmp	.-4      	; 0x6682 <systemGenerateReport+0x142>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6686:	8f e3       	ldi	r24, 0x3F	; 63
    6688:	91 e0       	ldi	r25, 0x01	; 1
    668a:	9f bb       	out	0x1f, r25	; 31
    668c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    668e:	e0 9a       	sbi	0x1c, 0	; 28
    6690:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    6692:	00 d0       	rcall	.+0      	; 0x6694 <systemGenerateReport+0x154>
    6694:	00 d0       	rcall	.+0      	; 0x6696 <systemGenerateReport+0x156>
    6696:	00 d0       	rcall	.+0      	; 0x6698 <systemGenerateReport+0x158>
    6698:	ed b7       	in	r30, 0x3d	; 61
    669a:	fe b7       	in	r31, 0x3e	; 62
    669c:	31 96       	adiw	r30, 0x01	; 1
    669e:	88 e6       	ldi	r24, 0x68	; 104
    66a0:	9c e0       	ldi	r25, 0x0C	; 12
    66a2:	ad b7       	in	r26, 0x3d	; 61
    66a4:	be b7       	in	r27, 0x3e	; 62
    66a6:	12 96       	adiw	r26, 0x02	; 2
    66a8:	9c 93       	st	X, r25
    66aa:	8e 93       	st	-X, r24
    66ac:	11 97       	sbiw	r26, 0x01	; 1
    66ae:	80 ef       	ldi	r24, 0xF0	; 240
    66b0:	94 e0       	ldi	r25, 0x04	; 4
    66b2:	93 83       	std	Z+3, r25	; 0x03
    66b4:	82 83       	std	Z+2, r24	; 0x02
    66b6:	24 83       	std	Z+4, r18	; 0x04
    66b8:	15 82       	std	Z+5, r1	; 0x05
    66ba:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    66be:	82 e0       	ldi	r24, 0x02	; 2
    66c0:	80 93 e8 01 	sts	0x01E8, r24
    66c4:	ed b7       	in	r30, 0x3d	; 61
    66c6:	fe b7       	in	r31, 0x3e	; 62
    66c8:	36 96       	adiw	r30, 0x06	; 6
    66ca:	0f b6       	in	r0, 0x3f	; 63
    66cc:	f8 94       	cli
    66ce:	fe bf       	out	0x3e, r31	; 62
    66d0:	0f be       	out	0x3f, r0	; 63
    66d2:	ed bf       	out	0x3d, r30	; 61
    66d4:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    66d8:	ce 01       	movw	r24, r28
    66da:	8b 5a       	subi	r24, 0xAB	; 171
    66dc:	9f 4f       	sbci	r25, 0xFF	; 255
    66de:	63 e4       	ldi	r22, 0x43	; 67
    66e0:	78 e0       	ldi	r23, 0x08	; 8
    66e2:	44 e1       	ldi	r20, 0x14	; 20
    66e4:	50 e0       	ldi	r21, 0x00	; 0
    66e6:	24 e4       	ldi	r18, 0x44	; 68
    66e8:	32 e1       	ldi	r19, 0x12	; 18
    66ea:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    66ee:	81 e0       	ldi	r24, 0x01	; 1
    66f0:	6c ee       	ldi	r22, 0xEC	; 236
    66f2:	73 e0       	ldi	r23, 0x03	; 3
    66f4:	41 e0       	ldi	r20, 0x01	; 1
    66f6:	26 ed       	ldi	r18, 0xD6	; 214
    66f8:	31 e0       	ldi	r19, 0x01	; 1
    66fa:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    66fe:	8b e0       	ldi	r24, 0x0B	; 11
    6700:	6c ee       	ldi	r22, 0xEC	; 236
    6702:	73 e0       	ldi	r23, 0x03	; 3
    6704:	4a e2       	ldi	r20, 0x2A	; 42
    6706:	26 ed       	ldi	r18, 0xD6	; 214
    6708:	31 e0       	ldi	r19, 0x01	; 1
    670a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    670e:	83 e0       	ldi	r24, 0x03	; 3
    6710:	6c ee       	ldi	r22, 0xEC	; 236
    6712:	73 e0       	ldi	r23, 0x03	; 3
    6714:	41 e0       	ldi	r20, 0x01	; 1
    6716:	26 ed       	ldi	r18, 0xD6	; 214
    6718:	31 e0       	ldi	r19, 0x01	; 1
    671a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    671e:	8c e0       	ldi	r24, 0x0C	; 12
    6720:	6c ee       	ldi	r22, 0xEC	; 236
    6722:	73 e0       	ldi	r23, 0x03	; 3
    6724:	41 e0       	ldi	r20, 0x01	; 1
    6726:	26 ed       	ldi	r18, 0xD6	; 214
    6728:	31 e0       	ldi	r19, 0x01	; 1
    672a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    672e:	00 d0       	rcall	.+0      	; 0x6730 <systemGenerateReport+0x1f0>
    6730:	00 d0       	rcall	.+0      	; 0x6732 <systemGenerateReport+0x1f2>
    6732:	00 d0       	rcall	.+0      	; 0x6734 <systemGenerateReport+0x1f4>
    6734:	ed b7       	in	r30, 0x3d	; 61
    6736:	fe b7       	in	r31, 0x3e	; 62
    6738:	31 96       	adiw	r30, 0x01	; 1
    673a:	8e 01       	movw	r16, r28
    673c:	0b 55       	subi	r16, 0x5B	; 91
    673e:	1f 4f       	sbci	r17, 0xFF	; 255
    6740:	ad b7       	in	r26, 0x3d	; 61
    6742:	be b7       	in	r27, 0x3e	; 62
    6744:	12 96       	adiw	r26, 0x02	; 2
    6746:	1c 93       	st	X, r17
    6748:	0e 93       	st	-X, r16
    674a:	11 97       	sbiw	r26, 0x01	; 1
    674c:	8a ec       	ldi	r24, 0xCA	; 202
    674e:	94 e0       	ldi	r25, 0x04	; 4
    6750:	93 83       	std	Z+3, r25	; 0x03
    6752:	82 83       	std	Z+2, r24	; 0x02
    6754:	88 e6       	ldi	r24, 0x68	; 104
    6756:	9c e0       	ldi	r25, 0x0C	; 12
    6758:	95 83       	std	Z+5, r25	; 0x05
    675a:	84 83       	std	Z+4, r24	; 0x04
    675c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    6760:	ed b7       	in	r30, 0x3d	; 61
    6762:	fe b7       	in	r31, 0x3e	; 62
    6764:	36 96       	adiw	r30, 0x06	; 6
    6766:	0f b6       	in	r0, 0x3f	; 63
    6768:	f8 94       	cli
    676a:	fe bf       	out	0x3e, r31	; 62
    676c:	0f be       	out	0x3f, r0	; 63
    676e:	ed bf       	out	0x3d, r30	; 61
    6770:	c8 01       	movw	r24, r16
    6772:	6c ee       	ldi	r22, 0xEC	; 236
    6774:	73 e0       	ldi	r23, 0x03	; 3
    6776:	46 ed       	ldi	r20, 0xD6	; 214
    6778:	51 e0       	ldi	r21, 0x01	; 1
    677a:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    677e:	84 e0       	ldi	r24, 0x04	; 4
    6780:	6c ee       	ldi	r22, 0xEC	; 236
    6782:	73 e0       	ldi	r23, 0x03	; 3
    6784:	41 e0       	ldi	r20, 0x01	; 1
    6786:	26 ed       	ldi	r18, 0xD6	; 214
    6788:	31 e0       	ldi	r19, 0x01	; 1
    678a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    678e:	8b e0       	ldi	r24, 0x0B	; 11
    6790:	6c ee       	ldi	r22, 0xEC	; 236
    6792:	73 e0       	ldi	r23, 0x03	; 3
    6794:	4a e2       	ldi	r20, 0x2A	; 42
    6796:	26 ed       	ldi	r18, 0xD6	; 214
    6798:	31 e0       	ldi	r19, 0x01	; 1
    679a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    679e:	86 e0       	ldi	r24, 0x06	; 6
    67a0:	6c ee       	ldi	r22, 0xEC	; 236
    67a2:	73 e0       	ldi	r23, 0x03	; 3
    67a4:	41 e0       	ldi	r20, 0x01	; 1
    67a6:	26 ed       	ldi	r18, 0xD6	; 214
    67a8:	31 e0       	ldi	r19, 0x01	; 1
    67aa:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    67ae:	8c e0       	ldi	r24, 0x0C	; 12
    67b0:	6c ee       	ldi	r22, 0xEC	; 236
    67b2:	73 e0       	ldi	r23, 0x03	; 3
    67b4:	41 e0       	ldi	r20, 0x01	; 1
    67b6:	26 ed       	ldi	r18, 0xD6	; 214
    67b8:	31 e0       	ldi	r19, 0x01	; 1
    67ba:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    67be:	e1 99       	sbic	0x1c, 1	; 28
    67c0:	fe cf       	rjmp	.-4      	; 0x67be <systemGenerateReport+0x27e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    67c2:	80 e0       	ldi	r24, 0x00	; 0
    67c4:	90 e0       	ldi	r25, 0x00	; 0
    67c6:	9f bb       	out	0x1f, r25	; 31
    67c8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    67ca:	e0 9a       	sbi	0x1c, 0	; 28
    67cc:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    67ce:	00 d0       	rcall	.+0      	; 0x67d0 <systemGenerateReport+0x290>
    67d0:	00 d0       	rcall	.+0      	; 0x67d2 <systemGenerateReport+0x292>
    67d2:	00 d0       	rcall	.+0      	; 0x67d4 <systemGenerateReport+0x294>
    67d4:	ed b7       	in	r30, 0x3d	; 61
    67d6:	fe b7       	in	r31, 0x3e	; 62
    67d8:	31 96       	adiw	r30, 0x01	; 1
    67da:	8e 01       	movw	r16, r28
    67dc:	0b 55       	subi	r16, 0x5B	; 91
    67de:	1f 4f       	sbci	r17, 0xFF	; 255
    67e0:	ad b7       	in	r26, 0x3d	; 61
    67e2:	be b7       	in	r27, 0x3e	; 62
    67e4:	12 96       	adiw	r26, 0x02	; 2
    67e6:	1c 93       	st	X, r17
    67e8:	0e 93       	st	-X, r16
    67ea:	11 97       	sbiw	r26, 0x01	; 1
    67ec:	84 ea       	ldi	r24, 0xA4	; 164
    67ee:	94 e0       	ldi	r25, 0x04	; 4
    67f0:	93 83       	std	Z+3, r25	; 0x03
    67f2:	82 83       	std	Z+2, r24	; 0x02
    67f4:	24 83       	std	Z+4, r18	; 0x04
    67f6:	15 82       	std	Z+5, r1	; 0x05
    67f8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    67fc:	ed b7       	in	r30, 0x3d	; 61
    67fe:	fe b7       	in	r31, 0x3e	; 62
    6800:	36 96       	adiw	r30, 0x06	; 6
    6802:	0f b6       	in	r0, 0x3f	; 63
    6804:	f8 94       	cli
    6806:	fe bf       	out	0x3e, r31	; 62
    6808:	0f be       	out	0x3f, r0	; 63
    680a:	ed bf       	out	0x3d, r30	; 61
    680c:	c8 01       	movw	r24, r16
    680e:	6c ee       	ldi	r22, 0xEC	; 236
    6810:	73 e0       	ldi	r23, 0x03	; 3
    6812:	46 ed       	ldi	r20, 0xD6	; 214
    6814:	51 e0       	ldi	r21, 0x01	; 1
    6816:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    681a:	00 d0       	rcall	.+0      	; 0x681c <systemGenerateReport+0x2dc>
    681c:	00 d0       	rcall	.+0      	; 0x681e <systemGenerateReport+0x2de>
    681e:	00 d0       	rcall	.+0      	; 0x6820 <systemGenerateReport+0x2e0>
    6820:	ed b7       	in	r30, 0x3d	; 61
    6822:	fe b7       	in	r31, 0x3e	; 62
    6824:	31 96       	adiw	r30, 0x01	; 1
    6826:	ad b7       	in	r26, 0x3d	; 61
    6828:	be b7       	in	r27, 0x3e	; 62
    682a:	12 96       	adiw	r26, 0x02	; 2
    682c:	1c 93       	st	X, r17
    682e:	0e 93       	st	-X, r16
    6830:	11 97       	sbiw	r26, 0x01	; 1
    6832:	82 e9       	ldi	r24, 0x92	; 146
    6834:	94 e0       	ldi	r25, 0x04	; 4
    6836:	93 83       	std	Z+3, r25	; 0x03
    6838:	82 83       	std	Z+2, r24	; 0x02
    683a:	ce 01       	movw	r24, r28
    683c:	8b 5a       	subi	r24, 0xAB	; 171
    683e:	9f 4f       	sbci	r25, 0xFF	; 255
    6840:	95 83       	std	Z+5, r25	; 0x05
    6842:	84 83       	std	Z+4, r24	; 0x04
    6844:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    6848:	ed b7       	in	r30, 0x3d	; 61
    684a:	fe b7       	in	r31, 0x3e	; 62
    684c:	36 96       	adiw	r30, 0x06	; 6
    684e:	0f b6       	in	r0, 0x3f	; 63
    6850:	f8 94       	cli
    6852:	fe bf       	out	0x3e, r31	; 62
    6854:	0f be       	out	0x3f, r0	; 63
    6856:	ed bf       	out	0x3d, r30	; 61
    6858:	c8 01       	movw	r24, r16
    685a:	6c ee       	ldi	r22, 0xEC	; 236
    685c:	73 e0       	ldi	r23, 0x03	; 3
    685e:	46 ed       	ldi	r20, 0xD6	; 214
    6860:	51 e0       	ldi	r21, 0x01	; 1
    6862:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    6866:	00 d0       	rcall	.+0      	; 0x6868 <systemGenerateReport+0x328>
    6868:	00 d0       	rcall	.+0      	; 0x686a <systemGenerateReport+0x32a>
    686a:	00 d0       	rcall	.+0      	; 0x686c <systemGenerateReport+0x32c>
    686c:	ed b7       	in	r30, 0x3d	; 61
    686e:	fe b7       	in	r31, 0x3e	; 62
    6870:	31 96       	adiw	r30, 0x01	; 1
    6872:	ad b7       	in	r26, 0x3d	; 61
    6874:	be b7       	in	r27, 0x3e	; 62
    6876:	12 96       	adiw	r26, 0x02	; 2
    6878:	1c 93       	st	X, r17
    687a:	0e 93       	st	-X, r16
    687c:	11 97       	sbiw	r26, 0x01	; 1
    687e:	80 e8       	ldi	r24, 0x80	; 128
    6880:	94 e0       	ldi	r25, 0x04	; 4
    6882:	93 83       	std	Z+3, r25	; 0x03
    6884:	82 83       	std	Z+2, r24	; 0x02
    6886:	8e e8       	ldi	r24, 0x8E	; 142
    6888:	97 e0       	ldi	r25, 0x07	; 7
    688a:	95 83       	std	Z+5, r25	; 0x05
    688c:	84 83       	std	Z+4, r24	; 0x04
    688e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    6892:	ed b7       	in	r30, 0x3d	; 61
    6894:	fe b7       	in	r31, 0x3e	; 62
    6896:	36 96       	adiw	r30, 0x06	; 6
    6898:	0f b6       	in	r0, 0x3f	; 63
    689a:	f8 94       	cli
    689c:	fe bf       	out	0x3e, r31	; 62
    689e:	0f be       	out	0x3f, r0	; 63
    68a0:	ed bf       	out	0x3d, r30	; 61
    68a2:	c8 01       	movw	r24, r16
    68a4:	6c ee       	ldi	r22, 0xEC	; 236
    68a6:	73 e0       	ldi	r23, 0x03	; 3
    68a8:	46 ed       	ldi	r20, 0xD6	; 214
    68aa:	51 e0       	ldi	r21, 0x01	; 1
    68ac:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    68b0:	87 e0       	ldi	r24, 0x07	; 7
    68b2:	6c ee       	ldi	r22, 0xEC	; 236
    68b4:	73 e0       	ldi	r23, 0x03	; 3
    68b6:	41 e0       	ldi	r20, 0x01	; 1
    68b8:	26 ed       	ldi	r18, 0xD6	; 214
    68ba:	31 e0       	ldi	r19, 0x01	; 1
    68bc:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    68c0:	8b e0       	ldi	r24, 0x0B	; 11
    68c2:	6c ee       	ldi	r22, 0xEC	; 236
    68c4:	73 e0       	ldi	r23, 0x03	; 3
    68c6:	4a e2       	ldi	r20, 0x2A	; 42
    68c8:	26 ed       	ldi	r18, 0xD6	; 214
    68ca:	31 e0       	ldi	r19, 0x01	; 1
    68cc:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    68d0:	89 e0       	ldi	r24, 0x09	; 9
    68d2:	6c ee       	ldi	r22, 0xEC	; 236
    68d4:	73 e0       	ldi	r23, 0x03	; 3
    68d6:	41 e0       	ldi	r20, 0x01	; 1
    68d8:	26 ed       	ldi	r18, 0xD6	; 214
    68da:	31 e0       	ldi	r19, 0x01	; 1
    68dc:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    68e0:	8c e0       	ldi	r24, 0x0C	; 12
    68e2:	6c ee       	ldi	r22, 0xEC	; 236
    68e4:	73 e0       	ldi	r23, 0x03	; 3
    68e6:	41 e0       	ldi	r20, 0x01	; 1
    68e8:	26 ed       	ldi	r18, 0xD6	; 214
    68ea:	31 e0       	ldi	r19, 0x01	; 1
    68ec:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    68f0:	88 ed       	ldi	r24, 0xD8	; 216
    68f2:	91 e0       	ldi	r25, 0x01	; 1
    68f4:	0e 94 b0 20 	call	0x4160	; 0x4160 <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    68f8:	80 e8       	ldi	r24, 0x80	; 128
    68fa:	80 93 b5 01 	sts	0x01B5, r24
		  LengthMessage81=RepPos+1;
    68fe:	80 91 d6 01 	lds	r24, 0x01D6
    6902:	90 91 d7 01 	lds	r25, 0x01D7
    6906:	01 96       	adiw	r24, 0x01	; 1
    6908:	90 93 8e 01 	sts	0x018E, r25
    690c:	80 93 8d 01 	sts	0x018D, r24
		  IsFreePrinting=True;
    6910:	81 e0       	ldi	r24, 0x01	; 1
    6912:	80 93 a8 01 	sts	0x01A8, r24
          IsBusyFreePrinting=True;
    6916:	80 93 b4 01 	sts	0x01B4, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    691a:	83 e0       	ldi	r24, 0x03	; 3
    691c:	0c 94 b1 3d 	jmp	0x7b62	; 0x7b62 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    6920:	80 91 b4 01 	lds	r24, 0x01B4
    6924:	88 23       	and	r24, r24
    6926:	11 f0       	breq	.+4      	; 0x692c <systemGenerateReport+0x3ec>
    6928:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    692c:	84 e0       	ldi	r24, 0x04	; 4
    692e:	0c 94 b1 3d 	jmp	0x7b62	; 0x7b62 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    6932:	10 92 d7 01 	sts	0x01D7, r1
    6936:	10 92 d6 01 	sts	0x01D6, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    693a:	81 e0       	ldi	r24, 0x01	; 1
    693c:	6c ee       	ldi	r22, 0xEC	; 236
    693e:	73 e0       	ldi	r23, 0x03	; 3
    6940:	41 e0       	ldi	r20, 0x01	; 1
    6942:	26 ed       	ldi	r18, 0xD6	; 214
    6944:	31 e0       	ldi	r19, 0x01	; 1
    6946:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    694a:	8b e0       	ldi	r24, 0x0B	; 11
    694c:	6c ee       	ldi	r22, 0xEC	; 236
    694e:	73 e0       	ldi	r23, 0x03	; 3
    6950:	4a e2       	ldi	r20, 0x2A	; 42
    6952:	26 ed       	ldi	r18, 0xD6	; 214
    6954:	31 e0       	ldi	r19, 0x01	; 1
    6956:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    695a:	83 e0       	ldi	r24, 0x03	; 3
    695c:	6c ee       	ldi	r22, 0xEC	; 236
    695e:	73 e0       	ldi	r23, 0x03	; 3
    6960:	41 e0       	ldi	r20, 0x01	; 1
    6962:	26 ed       	ldi	r18, 0xD6	; 214
    6964:	31 e0       	ldi	r19, 0x01	; 1
    6966:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    696a:	8c e0       	ldi	r24, 0x0C	; 12
    696c:	6c ee       	ldi	r22, 0xEC	; 236
    696e:	73 e0       	ldi	r23, 0x03	; 3
    6970:	41 e0       	ldi	r20, 0x01	; 1
    6972:	26 ed       	ldi	r18, 0xD6	; 214
    6974:	31 e0       	ldi	r19, 0x01	; 1
    6976:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    697a:	e1 99       	sbic	0x1c, 1	; 28
    697c:	fe cf       	rjmp	.-4      	; 0x697a <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    697e:	81 ec       	ldi	r24, 0xC1	; 193
    6980:	93 e0       	ldi	r25, 0x03	; 3
    6982:	9f bb       	out	0x1f, r25	; 31
    6984:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6986:	e0 9a       	sbi	0x1c, 0	; 28
    6988:	8d b3       	in	r24, 0x1d	; 29
    698a:	9e 01       	movw	r18, r28
    698c:	2b 55       	subi	r18, 0x5B	; 91
    698e:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    6990:	81 30       	cpi	r24, 0x01	; 1
    6992:	79 f4       	brne	.+30     	; 0x69b2 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    6994:	00 d0       	rcall	.+0      	; 0x6996 <systemGenerateReport+0x456>
    6996:	00 d0       	rcall	.+0      	; 0x6998 <systemGenerateReport+0x458>
    6998:	ad b7       	in	r26, 0x3d	; 61
    699a:	be b7       	in	r27, 0x3e	; 62
    699c:	12 96       	adiw	r26, 0x02	; 2
    699e:	3c 93       	st	X, r19
    69a0:	2e 93       	st	-X, r18
    69a2:	11 97       	sbiw	r26, 0x01	; 1
    69a4:	89 e5       	ldi	r24, 0x59	; 89
    69a6:	94 e0       	ldi	r25, 0x04	; 4
    69a8:	14 96       	adiw	r26, 0x04	; 4
    69aa:	9c 93       	st	X, r25
    69ac:	8e 93       	st	-X, r24
    69ae:	13 97       	sbiw	r26, 0x03	; 3
    69b0:	0a c0       	rjmp	.+20     	; 0x69c6 <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    69b2:	00 d0       	rcall	.+0      	; 0x69b4 <systemGenerateReport+0x474>
    69b4:	00 d0       	rcall	.+0      	; 0x69b6 <systemGenerateReport+0x476>
    69b6:	ed b7       	in	r30, 0x3d	; 61
    69b8:	fe b7       	in	r31, 0x3e	; 62
    69ba:	32 83       	std	Z+2, r19	; 0x02
    69bc:	21 83       	std	Z+1, r18	; 0x01
    69be:	82 e3       	ldi	r24, 0x32	; 50
    69c0:	94 e0       	ldi	r25, 0x04	; 4
    69c2:	94 83       	std	Z+4, r25	; 0x04
    69c4:	83 83       	std	Z+3, r24	; 0x03
    69c6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    69ca:	0f 90       	pop	r0
    69cc:	0f 90       	pop	r0
    69ce:	0f 90       	pop	r0
    69d0:	0f 90       	pop	r0
    69d2:	ce 01       	movw	r24, r28
    69d4:	8b 55       	subi	r24, 0x5B	; 91
    69d6:	9f 4f       	sbci	r25, 0xFF	; 255
    69d8:	6c ee       	ldi	r22, 0xEC	; 236
    69da:	73 e0       	ldi	r23, 0x03	; 3
    69dc:	46 ed       	ldi	r20, 0xD6	; 214
    69de:	51 e0       	ldi	r21, 0x01	; 1
    69e0:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    69e4:	87 e0       	ldi	r24, 0x07	; 7
    69e6:	6c ee       	ldi	r22, 0xEC	; 236
    69e8:	73 e0       	ldi	r23, 0x03	; 3
    69ea:	41 e0       	ldi	r20, 0x01	; 1
    69ec:	26 ed       	ldi	r18, 0xD6	; 214
    69ee:	31 e0       	ldi	r19, 0x01	; 1
    69f0:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    69f4:	8b e0       	ldi	r24, 0x0B	; 11
    69f6:	6c ee       	ldi	r22, 0xEC	; 236
    69f8:	73 e0       	ldi	r23, 0x03	; 3
    69fa:	4a e2       	ldi	r20, 0x2A	; 42
    69fc:	26 ed       	ldi	r18, 0xD6	; 214
    69fe:	31 e0       	ldi	r19, 0x01	; 1
    6a00:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    6a04:	89 e0       	ldi	r24, 0x09	; 9
    6a06:	6c ee       	ldi	r22, 0xEC	; 236
    6a08:	73 e0       	ldi	r23, 0x03	; 3
    6a0a:	41 e0       	ldi	r20, 0x01	; 1
    6a0c:	26 ed       	ldi	r18, 0xD6	; 214
    6a0e:	31 e0       	ldi	r19, 0x01	; 1
    6a10:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
          
		  cmdPrint=0b00000000;
    6a14:	10 92 b5 01 	sts	0x01B5, r1
		  LengthMessage81=RepPos+1;
    6a18:	80 91 d6 01 	lds	r24, 0x01D6
    6a1c:	90 91 d7 01 	lds	r25, 0x01D7
    6a20:	01 96       	adiw	r24, 0x01	; 1
    6a22:	90 93 8e 01 	sts	0x018E, r25
    6a26:	80 93 8d 01 	sts	0x018D, r24

		  IsFreePrinting=True;
    6a2a:	81 e0       	ldi	r24, 0x01	; 1
    6a2c:	80 93 a8 01 	sts	0x01A8, r24
	      IsBusyFreePrinting=True;
    6a30:	80 93 b4 01 	sts	0x01B4, r24

		  stGenerateReport=grWaitLabelPrinted;
    6a34:	85 e0       	ldi	r24, 0x05	; 5
    6a36:	0c 94 b1 3d 	jmp	0x7b62	; 0x7b62 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    6a3a:	80 91 e7 01 	lds	r24, 0x01E7
    6a3e:	81 50       	subi	r24, 0x01	; 1
    6a40:	88 30       	cpi	r24, 0x08	; 8
    6a42:	10 f0       	brcs	.+4      	; 0x6a48 <systemGenerateReport+0x508>
    6a44:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    6a48:	ce 01       	movw	r24, r28
    6a4a:	07 96       	adiw	r24, 0x07	; 7
    6a4c:	65 e4       	ldi	r22, 0x45	; 69
    6a4e:	70 e0       	ldi	r23, 0x00	; 0
    6a50:	48 e0       	ldi	r20, 0x08	; 8
    6a52:	50 e0       	ldi	r21, 0x00	; 0
    6a54:	24 e4       	ldi	r18, 0x44	; 68
    6a56:	32 e1       	ldi	r19, 0x12	; 18
    6a58:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    6a5c:	90 91 e7 01 	lds	r25, 0x01E7
    6a60:	fe 01       	movw	r30, r28
    6a62:	e9 0f       	add	r30, r25
    6a64:	f1 1d       	adc	r31, r1
    6a66:	86 81       	ldd	r24, Z+6	; 0x06
    6a68:	80 93 e4 01 	sts	0x01E4, r24
			  if (PumpNum>0){
    6a6c:	88 23       	and	r24, r24
    6a6e:	09 f4       	brne	.+2      	; 0x6a72 <systemGenerateReport+0x532>
    6a70:	4b c0       	rjmp	.+150    	; 0x6b08 <systemGenerateReport+0x5c8>
    6a72:	91 9f       	mul	r25, r17
    6a74:	b0 01       	movw	r22, r0
    6a76:	11 24       	eor	r1, r1
    6a78:	61 5b       	subi	r22, 0xB1	; 177
    6a7a:	7f 4f       	sbci	r23, 0xFF	; 255
    6a7c:	ce 01       	movw	r24, r28
    6a7e:	01 96       	adiw	r24, 0x01	; 1
    6a80:	46 e0       	ldi	r20, 0x06	; 6
    6a82:	50 e0       	ldi	r21, 0x00	; 0
    6a84:	24 e4       	ldi	r18, 0x44	; 68
    6a86:	32 e1       	ldi	r19, 0x12	; 18
    6a88:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    6a8c:	80 91 e6 01 	lds	r24, 0x01E6
    6a90:	fe 01       	movw	r30, r28
    6a92:	e8 0f       	add	r30, r24
    6a94:	f1 1d       	adc	r31, r1
    6a96:	80 81       	ld	r24, Z
    6a98:	80 93 e5 01 	sts	0x01E5, r24
    6a9c:	ee e5       	ldi	r30, 0x5E	; 94
    6a9e:	ce 2e       	mov	r12, r30
    6aa0:	e7 e0       	ldi	r30, 0x07	; 7
    6aa2:	de 2e       	mov	r13, r30

				  if (xGrade>0){
    6aa4:	88 23       	and	r24, r24
    6aa6:	99 f0       	breq	.+38     	; 0x6ace <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    6aa8:	b6 01       	movw	r22, r12
    6aaa:	0e 94 e1 2b 	call	0x57c2	; 0x57c2 <GetProductName>
                      GradeUsed=xGrade;
    6aae:	80 91 e5 01 	lds	r24, 0x01E5
    6ab2:	80 93 e2 01 	sts	0x01E2, r24
					  xGrade=xNozzle;//
    6ab6:	80 91 e6 01 	lds	r24, 0x01E6
    6aba:	80 93 e5 01 	sts	0x01E5, r24
					  PumpNozzle=xNozzle;
    6abe:	80 93 e3 01 	sts	0x01E3, r24
					  xNozzle++;
    6ac2:	8f 5f       	subi	r24, 0xFF	; 255
    6ac4:	80 93 e6 01 	sts	0x01E6, r24
					  stGenerateReport=grCreateReportTotalizer;
    6ac8:	88 e0       	ldi	r24, 0x08	; 8
    6aca:	0c 94 b1 3d 	jmp	0x7b62	; 0x7b62 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    6ace:	00 d0       	rcall	.+0      	; 0x6ad0 <systemGenerateReport+0x590>
    6ad0:	00 d0       	rcall	.+0      	; 0x6ad2 <systemGenerateReport+0x592>
    6ad2:	ad b7       	in	r26, 0x3d	; 61
    6ad4:	be b7       	in	r27, 0x3e	; 62
    6ad6:	12 96       	adiw	r26, 0x02	; 2
    6ad8:	dc 92       	st	X, r13
    6ada:	ce 92       	st	-X, r12
    6adc:	11 97       	sbiw	r26, 0x01	; 1
    6ade:	8e e2       	ldi	r24, 0x2E	; 46
    6ae0:	94 e0       	ldi	r25, 0x04	; 4
    6ae2:	14 96       	adiw	r26, 0x04	; 4
    6ae4:	9c 93       	st	X, r25
    6ae6:	8e 93       	st	-X, r24
    6ae8:	13 97       	sbiw	r26, 0x03	; 3
    6aea:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
					   xNozzle++;
    6aee:	80 91 e6 01 	lds	r24, 0x01E6
    6af2:	8f 5f       	subi	r24, 0xFF	; 255
    6af4:	80 93 e6 01 	sts	0x01E6, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    6af8:	0f 90       	pop	r0
    6afa:	0f 90       	pop	r0
    6afc:	0f 90       	pop	r0
    6afe:	0f 90       	pop	r0
    6b00:	87 30       	cpi	r24, 0x07	; 7
    6b02:	10 f4       	brcc	.+4      	; 0x6b08 <systemGenerateReport+0x5c8>
    6b04:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    6b08:	87 e0       	ldi	r24, 0x07	; 7
    6b0a:	0c 94 b1 3d 	jmp	0x7b62	; 0x7b62 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    6b0e:	81 e0       	ldi	r24, 0x01	; 1
    6b10:	80 93 e6 01 	sts	0x01E6, r24
	      xPump++;
    6b14:	80 91 e7 01 	lds	r24, 0x01E7
    6b18:	8f 5f       	subi	r24, 0xFF	; 255
    6b1a:	80 93 e7 01 	sts	0x01E7, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    6b1e:	89 30       	cpi	r24, 0x09	; 9
    6b20:	08 f4       	brcc	.+2      	; 0x6b24 <systemGenerateReport+0x5e4>
    6b22:	93 c4       	rjmp	.+2342   	; 0x744a <systemGenerateReport+0xf0a>
    6b24:	8a e0       	ldi	r24, 0x0A	; 10
    6b26:	0c 94 b1 3d 	jmp	0x7b62	; 0x7b62 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    6b2a:	10 92 d7 01 	sts	0x01D7, r1
    6b2e:	10 92 d6 01 	sts	0x01D6, r1
    6b32:	ec ee       	ldi	r30, 0xEC	; 236
    6b34:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    6b36:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b38:	b5 e0       	ldi	r27, 0x05	; 5
    6b3a:	ed 37       	cpi	r30, 0x7D	; 125
    6b3c:	fb 07       	cpc	r31, r27
    6b3e:	d9 f7       	brne	.-10     	; 0x6b36 <systemGenerateReport+0x5f6>
    6b40:	fe 01       	movw	r30, r28
    6b42:	eb 55       	subi	r30, 0x5B	; 91
    6b44:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6b46:	ce 01       	movw	r24, r28
    6b48:	8b 50       	subi	r24, 0x0B	; 11
    6b4a:	9f 4f       	sbci	r25, 0xFF	; 255
    6b4c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b4e:	e8 17       	cp	r30, r24
    6b50:	f9 07       	cpc	r31, r25
    6b52:	e1 f7       	brne	.-8      	; 0x6b4c <systemGenerateReport+0x60c>
    6b54:	ed e2       	ldi	r30, 0x2D	; 45
    6b56:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    6b58:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b5a:	8c e0       	ldi	r24, 0x0C	; 12
    6b5c:	ec 33       	cpi	r30, 0x3C	; 60
    6b5e:	f8 07       	cpc	r31, r24
    6b60:	d9 f7       	brne	.-10     	; 0x6b58 <systemGenerateReport+0x618>
    6b62:	e5 e0       	ldi	r30, 0x05	; 5
    6b64:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    6b66:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b68:	99 e0       	ldi	r25, 0x09	; 9
    6b6a:	e4 31       	cpi	r30, 0x14	; 20
    6b6c:	f9 07       	cpc	r31, r25
    6b6e:	d9 f7       	brne	.-10     	; 0x6b66 <systemGenerateReport+0x626>
    6b70:	fe 01       	movw	r30, r28
    6b72:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    6b74:	ce 01       	movw	r24, r28
    6b76:	88 96       	adiw	r24, 0x28	; 40
    6b78:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b7a:	e8 17       	cp	r30, r24
    6b7c:	f9 07       	cpc	r31, r25
    6b7e:	e1 f7       	brne	.-8      	; 0x6b78 <systemGenerateReport+0x638>
	     strMemory[i]=data;
    6b80:	ce 01       	movw	r24, r28
    6b82:	c7 96       	adiw	r24, 0x37	; 55
    6b84:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b86:	e8 17       	cp	r30, r24
    6b88:	f9 07       	cpc	r31, r25
    6b8a:	e1 f7       	brne	.-8      	; 0x6b84 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    6b8c:	cf 01       	movw	r24, r30
    6b8e:	0f 96       	adiw	r24, 0x0f	; 15
    6b90:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b92:	e8 17       	cp	r30, r24
    6b94:	f9 07       	cpc	r31, r25
    6b96:	e1 f7       	brne	.-8      	; 0x6b90 <systemGenerateReport+0x650>
    6b98:	fe 01       	movw	r30, r28
    6b9a:	ea 5b       	subi	r30, 0xBA	; 186
    6b9c:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6b9e:	cf 01       	movw	r24, r30
    6ba0:	ee 2e       	mov	r14, r30
    6ba2:	d9 2e       	mov	r13, r25
    6ba4:	0f 96       	adiw	r24, 0x0f	; 15
    6ba6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6ba8:	e8 17       	cp	r30, r24
    6baa:	f9 07       	cpc	r31, r25
    6bac:	e1 f7       	brne	.-8      	; 0x6ba6 <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    6bae:	80 91 e4 01 	lds	r24, 0x01E4
    6bb2:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
		  if (FIPAddr>0){
    6bb6:	88 23       	and	r24, r24
    6bb8:	49 f1       	breq	.+82     	; 0x6c0c <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    6bba:	f8 2e       	mov	r15, r24
    6bbc:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    6bbe:	80 e0       	ldi	r24, 0x00	; 0
    6bc0:	60 e0       	ldi	r22, 0x00	; 0
    6bc2:	4f 2d       	mov	r20, r15
    6bc4:	20 91 e3 01 	lds	r18, 0x01E3
    6bc8:	8e 01       	movw	r16, r28
    6bca:	07 5e       	subi	r16, 0xE7	; 231
    6bcc:	1f 4f       	sbci	r17, 0xFF	; 255
    6bce:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    6bd2:	81 e0       	ldi	r24, 0x01	; 1
    6bd4:	60 e0       	ldi	r22, 0x00	; 0
    6bd6:	4f 2d       	mov	r20, r15
    6bd8:	20 91 e3 01 	lds	r18, 0x01E3
    6bdc:	8e 01       	movw	r16, r28
    6bde:	08 5d       	subi	r16, 0xD8	; 216
    6be0:	1f 4f       	sbci	r17, 0xFF	; 255
    6be2:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    6be6:	80 e0       	ldi	r24, 0x00	; 0
    6be8:	61 e0       	ldi	r22, 0x01	; 1
    6bea:	4f 2d       	mov	r20, r15
    6bec:	20 91 e3 01 	lds	r18, 0x01E3
    6bf0:	8e 01       	movw	r16, r28
    6bf2:	09 5c       	subi	r16, 0xC9	; 201
    6bf4:	1f 4f       	sbci	r17, 0xFF	; 255
    6bf6:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    6bfa:	81 e0       	ldi	r24, 0x01	; 1
    6bfc:	61 e0       	ldi	r22, 0x01	; 1
    6bfe:	4f 2d       	mov	r20, r15
    6c00:	20 91 e3 01 	lds	r18, 0x01E3
    6c04:	0e 2d       	mov	r16, r14
    6c06:	1d 2d       	mov	r17, r13
    6c08:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    6c0c:	80 e0       	ldi	r24, 0x00	; 0
    6c0e:	be 01       	movw	r22, r28
    6c10:	69 5c       	subi	r22, 0xC9	; 201
    6c12:	7f 4f       	sbci	r23, 0xFF	; 255
    6c14:	ae 01       	movw	r20, r28
    6c16:	47 5e       	subi	r20, 0xE7	; 231
    6c18:	5f 4f       	sbci	r21, 0xFF	; 255
    6c1a:	25 e0       	ldi	r18, 0x05	; 5
    6c1c:	39 e0       	ldi	r19, 0x09	; 9
    6c1e:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    6c22:	85 e0       	ldi	r24, 0x05	; 5
    6c24:	99 e0       	ldi	r25, 0x09	; 9
    6c26:	0e 94 74 21 	call	0x42e8	; 0x42e8 <IsMinus>
    6c2a:	81 30       	cpi	r24, 0x01	; 1
    6c2c:	21 f4       	brne	.+8      	; 0x6c36 <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    6c2e:	85 e0       	ldi	r24, 0x05	; 5
    6c30:	99 e0       	ldi	r25, 0x09	; 9
    6c32:	0e 94 10 2b 	call	0x5620	; 0x5620 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6c36:	e1 99       	sbic	0x1c, 1	; 28
    6c38:	fe cf       	rjmp	.-4      	; 0x6c36 <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6c3a:	77 e3       	ldi	r23, 0x37	; 55
    6c3c:	87 2e       	mov	r8, r23
    6c3e:	71 e0       	ldi	r23, 0x01	; 1
    6c40:	97 2e       	mov	r9, r23
    6c42:	9f ba       	out	0x1f, r9	; 31
    6c44:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6c46:	e0 9a       	sbi	0x1c, 0	; 28
    6c48:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6c4a:	82 30       	cpi	r24, 0x02	; 2
    6c4c:	79 f4       	brne	.+30     	; 0x6c6c <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    6c4e:	8e 01       	movw	r16, r28
    6c50:	01 5f       	subi	r16, 0xF1	; 241
    6c52:	1f 4f       	sbci	r17, 0xFF	; 255
    6c54:	c8 01       	movw	r24, r16
    6c56:	60 91 e4 01 	lds	r22, 0x01E4
    6c5a:	40 91 e3 01 	lds	r20, 0x01E3
    6c5e:	0e 94 57 22 	call	0x44ae	; 0x44ae <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    6c62:	82 e0       	ldi	r24, 0x02	; 2
    6c64:	b8 01       	movw	r22, r16
    6c66:	45 e0       	ldi	r20, 0x05	; 5
    6c68:	59 e0       	ldi	r21, 0x09	; 9
    6c6a:	07 c0       	rjmp	.+14     	; 0x6c7a <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    6c6c:	80 e0       	ldi	r24, 0x00	; 0
    6c6e:	be 01       	movw	r22, r28
    6c70:	6a 5b       	subi	r22, 0xBA	; 186
    6c72:	7f 4f       	sbci	r23, 0xFF	; 255
    6c74:	ae 01       	movw	r20, r28
    6c76:	48 5d       	subi	r20, 0xD8	; 216
    6c78:	5f 4f       	sbci	r21, 0xFF	; 255
    6c7a:	2d e2       	ldi	r18, 0x2D	; 45
    6c7c:	3c e0       	ldi	r19, 0x0C	; 12
    6c7e:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    6c82:	8d e2       	ldi	r24, 0x2D	; 45
    6c84:	9c e0       	ldi	r25, 0x0C	; 12
    6c86:	0e 94 74 21 	call	0x42e8	; 0x42e8 <IsMinus>
    6c8a:	81 30       	cpi	r24, 0x01	; 1
    6c8c:	21 f4       	brne	.+8      	; 0x6c96 <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    6c8e:	8d e2       	ldi	r24, 0x2D	; 45
    6c90:	9c e0       	ldi	r25, 0x0C	; 12
    6c92:	0e 94 10 2b 	call	0x5620	; 0x5620 <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    6c96:	80 91 e2 01 	lds	r24, 0x01E2
    6c9a:	68 ed       	ldi	r22, 0xD8	; 216
    6c9c:	71 e0       	ldi	r23, 0x01	; 1
    6c9e:	0e 94 7d 20 	call	0x40fa	; 0x40fa <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    6ca2:	81 e0       	ldi	r24, 0x01	; 1
    6ca4:	67 ef       	ldi	r22, 0xF7	; 247
    6ca6:	77 e0       	ldi	r23, 0x07	; 7
    6ca8:	45 e0       	ldi	r20, 0x05	; 5
    6caa:	59 e0       	ldi	r21, 0x09	; 9
    6cac:	9b 01       	movw	r18, r22
    6cae:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    6cb2:	81 e0       	ldi	r24, 0x01	; 1
    6cb4:	68 ea       	ldi	r22, 0xA8	; 168
    6cb6:	78 e0       	ldi	r23, 0x08	; 8
    6cb8:	4d e2       	ldi	r20, 0x2D	; 45
    6cba:	5c e0       	ldi	r21, 0x0C	; 12
    6cbc:	9b 01       	movw	r18, r22
    6cbe:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>


		  RemZeroLead(strDeltaMoney);
    6cc2:	8d e2       	ldi	r24, 0x2D	; 45
    6cc4:	9c e0       	ldi	r25, 0x0C	; 12
    6cc6:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    6cca:	66 e4       	ldi	r22, 0x46	; 70
    6ccc:	c6 2e       	mov	r12, r22
    6cce:	d1 2c       	mov	r13, r1
    6cd0:	cc 0e       	add	r12, r28
    6cd2:	dd 1e       	adc	r13, r29
    6cd4:	c6 01       	movw	r24, r12
    6cd6:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		  RemZeroLead(strLastMoney);
    6cda:	58 e2       	ldi	r21, 0x28	; 40
    6cdc:	e5 2e       	mov	r14, r21
    6cde:	f1 2c       	mov	r15, r1
    6ce0:	ec 0e       	add	r14, r28
    6ce2:	fd 1e       	adc	r15, r29
    6ce4:	c7 01       	movw	r24, r14
    6ce6:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    6cea:	85 e0       	ldi	r24, 0x05	; 5
    6cec:	99 e0       	ldi	r25, 0x09	; 9
    6cee:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    6cf2:	47 e3       	ldi	r20, 0x37	; 55
    6cf4:	a4 2e       	mov	r10, r20
    6cf6:	b1 2c       	mov	r11, r1
    6cf8:	ac 0e       	add	r10, r28
    6cfa:	bd 1e       	adc	r11, r29
    6cfc:	c5 01       	movw	r24, r10
    6cfe:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
          RemZeroLead(strLastVolume);
    6d02:	8e 01       	movw	r16, r28
    6d04:	07 5e       	subi	r16, 0xE7	; 231
    6d06:	1f 4f       	sbci	r17, 0xFF	; 255
    6d08:	c8 01       	movw	r24, r16
    6d0a:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    6d0e:	8d e2       	ldi	r24, 0x2D	; 45
    6d10:	9c e0       	ldi	r25, 0x0C	; 12
    6d12:	0e 94 6c 32 	call	0x64d8	; 0x64d8 <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    6d16:	c6 01       	movw	r24, r12
    6d18:	0e 94 6c 32 	call	0x64d8	; 0x64d8 <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    6d1c:	c7 01       	movw	r24, r14
    6d1e:	0e 94 6c 32 	call	0x64d8	; 0x64d8 <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    6d22:	85 e0       	ldi	r24, 0x05	; 5
    6d24:	99 e0       	ldi	r25, 0x09	; 9
    6d26:	0e 94 5f 32 	call	0x64be	; 0x64be <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    6d2a:	c8 01       	movw	r24, r16
    6d2c:	0e 94 5f 32 	call	0x64be	; 0x64be <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    6d30:	c5 01       	movw	r24, r10
    6d32:	0e 94 5f 32 	call	0x64be	; 0x64be <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    6d36:	8d e2       	ldi	r24, 0x2D	; 45
    6d38:	9c e0       	ldi	r25, 0x0C	; 12
    6d3a:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    6d3e:	c6 01       	movw	r24, r12
    6d40:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
		  FormatCurrency(strLastMoney);
    6d44:	c7 01       	movw	r24, r14
    6d46:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    6d4a:	85 e0       	ldi	r24, 0x05	; 5
    6d4c:	99 e0       	ldi	r25, 0x09	; 9
    6d4e:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
		  FormatCurrency(strLastVolume);
    6d52:	c8 01       	movw	r24, r16
    6d54:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    6d58:	c5 01       	movw	r24, r10
    6d5a:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6d5e:	81 e0       	ldi	r24, 0x01	; 1
    6d60:	6c ee       	ldi	r22, 0xEC	; 236
    6d62:	73 e0       	ldi	r23, 0x03	; 3
    6d64:	41 e0       	ldi	r20, 0x01	; 1
    6d66:	26 ed       	ldi	r18, 0xD6	; 214
    6d68:	31 e0       	ldi	r19, 0x01	; 1
    6d6a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    6d6e:	8b e0       	ldi	r24, 0x0B	; 11
    6d70:	6c ee       	ldi	r22, 0xEC	; 236
    6d72:	73 e0       	ldi	r23, 0x03	; 3
    6d74:	4a e2       	ldi	r20, 0x2A	; 42
    6d76:	26 ed       	ldi	r18, 0xD6	; 214
    6d78:	31 e0       	ldi	r19, 0x01	; 1
    6d7a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    6d7e:	83 e0       	ldi	r24, 0x03	; 3
    6d80:	6c ee       	ldi	r22, 0xEC	; 236
    6d82:	73 e0       	ldi	r23, 0x03	; 3
    6d84:	41 e0       	ldi	r20, 0x01	; 1
    6d86:	26 ed       	ldi	r18, 0xD6	; 214
    6d88:	31 e0       	ldi	r19, 0x01	; 1
    6d8a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    6d8e:	8c e0       	ldi	r24, 0x0C	; 12
    6d90:	6c ee       	ldi	r22, 0xEC	; 236
    6d92:	73 e0       	ldi	r23, 0x03	; 3
    6d94:	41 e0       	ldi	r20, 0x01	; 1
    6d96:	26 ed       	ldi	r18, 0xD6	; 214
    6d98:	31 e0       	ldi	r19, 0x01	; 1
    6d9a:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6d9e:	e1 99       	sbic	0x1c, 1	; 28
    6da0:	fe cf       	rjmp	.-4      	; 0x6d9e <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6da2:	9f ba       	out	0x1f, r9	; 31
    6da4:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6da6:	e0 9a       	sbi	0x1c, 0	; 28
    6da8:	8d b3       	in	r24, 0x1d	; 29
    6daa:	3e e5       	ldi	r19, 0x5E	; 94
    6dac:	c3 2e       	mov	r12, r19
    6dae:	37 e0       	ldi	r19, 0x07	; 7
    6db0:	d3 2e       	mov	r13, r19
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6db2:	82 30       	cpi	r24, 0x02	; 2
    6db4:	09 f0       	breq	.+2      	; 0x6db8 <systemGenerateReport+0x878>
    6db6:	84 c0       	rjmp	.+264    	; 0x6ec0 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    6db8:	2f e0       	ldi	r18, 0x0F	; 15
    6dba:	e2 2e       	mov	r14, r18
    6dbc:	f1 2c       	mov	r15, r1
    6dbe:	ec 0e       	add	r14, r28
    6dc0:	fd 1e       	adc	r15, r29
    6dc2:	c7 01       	movw	r24, r14
    6dc4:	60 91 e4 01 	lds	r22, 0x01E4
    6dc8:	40 91 e3 01 	lds	r20, 0x01E3
    6dcc:	0e 94 57 22 	call	0x44ae	; 0x44ae <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    6dd0:	00 d0       	rcall	.+0      	; 0x6dd2 <systemGenerateReport+0x892>
    6dd2:	00 d0       	rcall	.+0      	; 0x6dd4 <systemGenerateReport+0x894>
    6dd4:	00 d0       	rcall	.+0      	; 0x6dd6 <systemGenerateReport+0x896>
    6dd6:	ed b7       	in	r30, 0x3d	; 61
    6dd8:	fe b7       	in	r31, 0x3e	; 62
    6dda:	31 96       	adiw	r30, 0x01	; 1
    6ddc:	8e 01       	movw	r16, r28
    6dde:	0f 56       	subi	r16, 0x6F	; 111
    6de0:	1f 4f       	sbci	r17, 0xFF	; 255
    6de2:	ad b7       	in	r26, 0x3d	; 61
    6de4:	be b7       	in	r27, 0x3e	; 62
    6de6:	12 96       	adiw	r26, 0x02	; 2
    6de8:	1c 93       	st	X, r17
    6dea:	0e 93       	st	-X, r16
    6dec:	11 97       	sbiw	r26, 0x01	; 1
    6dee:	81 e2       	ldi	r24, 0x21	; 33
    6df0:	94 e0       	ldi	r25, 0x04	; 4
    6df2:	93 83       	std	Z+3, r25	; 0x03
    6df4:	82 83       	std	Z+2, r24	; 0x02
    6df6:	f5 82       	std	Z+5, r15	; 0x05
    6df8:	e4 82       	std	Z+4, r14	; 0x04
    6dfa:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    6dfe:	d6 01       	movw	r26, r12
    6e00:	0d 90       	ld	r0, X+
    6e02:	00 20       	and	r0, r0
    6e04:	e9 f7       	brne	.-6      	; 0x6e00 <systemGenerateReport+0x8c0>
    6e06:	11 97       	sbiw	r26, 0x01	; 1
    6e08:	ac 19       	sub	r26, r12
    6e0a:	bd 09       	sbc	r27, r13
    6e0c:	f8 01       	movw	r30, r16
    6e0e:	01 90       	ld	r0, Z+
    6e10:	00 20       	and	r0, r0
    6e12:	e9 f7       	brne	.-6      	; 0x6e0e <systemGenerateReport+0x8ce>
    6e14:	31 97       	sbiw	r30, 0x01	; 1
    6e16:	0e 1b       	sub	r16, r30
    6e18:	0a 1b       	sub	r16, r26
    6e1a:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6e1c:	ed b7       	in	r30, 0x3d	; 61
    6e1e:	fe b7       	in	r31, 0x3e	; 62
    6e20:	36 96       	adiw	r30, 0x06	; 6
    6e22:	0f b6       	in	r0, 0x3f	; 63
    6e24:	f8 94       	cli
    6e26:	fe bf       	out	0x3e, r31	; 62
    6e28:	0f be       	out	0x3f, r0	; 63
    6e2a:	ed bf       	out	0x3d, r30	; 61
    6e2c:	fe 01       	movw	r30, r28
    6e2e:	e3 58       	subi	r30, 0x83	; 131
    6e30:	ff 4f       	sbci	r31, 0xFF	; 255
    6e32:	10 16       	cp	r1, r16
    6e34:	74 f4       	brge	.+28     	; 0x6e52 <systemGenerateReport+0x912>
    6e36:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6e38:	90 e2       	ldi	r25, 0x20	; 32
    6e3a:	02 c0       	rjmp	.+4      	; 0x6e40 <systemGenerateReport+0x900>
    6e3c:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6e3e:	8f 5f       	subi	r24, 0xFF	; 255
    6e40:	80 17       	cp	r24, r16
    6e42:	e0 f3       	brcs	.-8      	; 0x6e3c <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6e44:	fe 01       	movw	r30, r28
    6e46:	e3 58       	subi	r30, 0x83	; 131
    6e48:	ff 4f       	sbci	r31, 0xFF	; 255
    6e4a:	e0 0f       	add	r30, r16
    6e4c:	f1 1d       	adc	r31, r1
    6e4e:	10 82       	st	Z, r1
    6e50:	03 c0       	rjmp	.+6      	; 0x6e58 <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    6e52:	80 e2       	ldi	r24, 0x20	; 32
    6e54:	80 83       	st	Z, r24
	 strTab[1]=0;
    6e56:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    6e58:	8d b7       	in	r24, 0x3d	; 61
    6e5a:	9e b7       	in	r25, 0x3e	; 62
    6e5c:	0e 97       	sbiw	r24, 0x0e	; 14
    6e5e:	0f b6       	in	r0, 0x3f	; 63
    6e60:	f8 94       	cli
    6e62:	9e bf       	out	0x3e, r25	; 62
    6e64:	0f be       	out	0x3f, r0	; 63
    6e66:	8d bf       	out	0x3d, r24	; 61
    6e68:	ed b7       	in	r30, 0x3d	; 61
    6e6a:	fe b7       	in	r31, 0x3e	; 62
    6e6c:	31 96       	adiw	r30, 0x01	; 1
    6e6e:	ce 01       	movw	r24, r28
    6e70:	8b 55       	subi	r24, 0x5B	; 91
    6e72:	9f 4f       	sbci	r25, 0xFF	; 255
    6e74:	ad b7       	in	r26, 0x3d	; 61
    6e76:	be b7       	in	r27, 0x3e	; 62
    6e78:	12 96       	adiw	r26, 0x02	; 2
    6e7a:	9c 93       	st	X, r25
    6e7c:	8e 93       	st	-X, r24
    6e7e:	11 97       	sbiw	r26, 0x01	; 1
    6e80:	8f e0       	ldi	r24, 0x0F	; 15
    6e82:	94 e0       	ldi	r25, 0x04	; 4
    6e84:	93 83       	std	Z+3, r25	; 0x03
    6e86:	82 83       	std	Z+2, r24	; 0x02
    6e88:	80 91 e4 01 	lds	r24, 0x01E4
    6e8c:	84 83       	std	Z+4, r24	; 0x04
    6e8e:	15 82       	std	Z+5, r1	; 0x05
    6e90:	80 91 e3 01 	lds	r24, 0x01E3
    6e94:	86 83       	std	Z+6, r24	; 0x06
    6e96:	17 82       	std	Z+7, r1	; 0x07
    6e98:	8e e5       	ldi	r24, 0x5E	; 94
    6e9a:	97 e0       	ldi	r25, 0x07	; 7
    6e9c:	91 87       	std	Z+9, r25	; 0x09
    6e9e:	80 87       	std	Z+8, r24	; 0x08
    6ea0:	ce 01       	movw	r24, r28
    6ea2:	83 58       	subi	r24, 0x83	; 131
    6ea4:	9f 4f       	sbci	r25, 0xFF	; 255
    6ea6:	93 87       	std	Z+11, r25	; 0x0b
    6ea8:	82 87       	std	Z+10, r24	; 0x0a
    6eaa:	ce 01       	movw	r24, r28
    6eac:	8f 56       	subi	r24, 0x6F	; 111
    6eae:	9f 4f       	sbci	r25, 0xFF	; 255
    6eb0:	95 87       	std	Z+13, r25	; 0x0d
    6eb2:	84 87       	std	Z+12, r24	; 0x0c
    6eb4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    6eb8:	ed b7       	in	r30, 0x3d	; 61
    6eba:	fe b7       	in	r31, 0x3e	; 62
    6ebc:	3e 96       	adiw	r30, 0x0e	; 14
    6ebe:	27 c0       	rjmp	.+78     	; 0x6f0e <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    6ec0:	8d b7       	in	r24, 0x3d	; 61
    6ec2:	9e b7       	in	r25, 0x3e	; 62
    6ec4:	0a 97       	sbiw	r24, 0x0a	; 10
    6ec6:	0f b6       	in	r0, 0x3f	; 63
    6ec8:	f8 94       	cli
    6eca:	9e bf       	out	0x3e, r25	; 62
    6ecc:	0f be       	out	0x3f, r0	; 63
    6ece:	8d bf       	out	0x3d, r24	; 61
    6ed0:	ed b7       	in	r30, 0x3d	; 61
    6ed2:	fe b7       	in	r31, 0x3e	; 62
    6ed4:	31 96       	adiw	r30, 0x01	; 1
    6ed6:	ce 01       	movw	r24, r28
    6ed8:	8b 55       	subi	r24, 0x5B	; 91
    6eda:	9f 4f       	sbci	r25, 0xFF	; 255
    6edc:	ad b7       	in	r26, 0x3d	; 61
    6ede:	be b7       	in	r27, 0x3e	; 62
    6ee0:	12 96       	adiw	r26, 0x02	; 2
    6ee2:	9c 93       	st	X, r25
    6ee4:	8e 93       	st	-X, r24
    6ee6:	11 97       	sbiw	r26, 0x01	; 1
    6ee8:	82 e0       	ldi	r24, 0x02	; 2
    6eea:	94 e0       	ldi	r25, 0x04	; 4
    6eec:	93 83       	std	Z+3, r25	; 0x03
    6eee:	82 83       	std	Z+2, r24	; 0x02
    6ef0:	80 91 e4 01 	lds	r24, 0x01E4
    6ef4:	84 83       	std	Z+4, r24	; 0x04
    6ef6:	15 82       	std	Z+5, r1	; 0x05
    6ef8:	80 91 e3 01 	lds	r24, 0x01E3
    6efc:	86 83       	std	Z+6, r24	; 0x06
    6efe:	17 82       	std	Z+7, r1	; 0x07
    6f00:	d1 86       	std	Z+9, r13	; 0x09
    6f02:	c0 86       	std	Z+8, r12	; 0x08
    6f04:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    6f08:	ed b7       	in	r30, 0x3d	; 61
    6f0a:	fe b7       	in	r31, 0x3e	; 62
    6f0c:	3a 96       	adiw	r30, 0x0a	; 10
    6f0e:	0f b6       	in	r0, 0x3f	; 63
    6f10:	f8 94       	cli
    6f12:	fe bf       	out	0x3e, r31	; 62
    6f14:	0f be       	out	0x3f, r0	; 63
    6f16:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6f18:	ce 01       	movw	r24, r28
    6f1a:	8b 55       	subi	r24, 0x5B	; 91
    6f1c:	9f 4f       	sbci	r25, 0xFF	; 255
    6f1e:	6c ee       	ldi	r22, 0xEC	; 236
    6f20:	73 e0       	ldi	r23, 0x03	; 3
    6f22:	46 ed       	ldi	r20, 0xD6	; 214
    6f24:	51 e0       	ldi	r21, 0x01	; 1
    6f26:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6f2a:	84 e0       	ldi	r24, 0x04	; 4
    6f2c:	6c ee       	ldi	r22, 0xEC	; 236
    6f2e:	73 e0       	ldi	r23, 0x03	; 3
    6f30:	41 e0       	ldi	r20, 0x01	; 1
    6f32:	26 ed       	ldi	r18, 0xD6	; 214
    6f34:	31 e0       	ldi	r19, 0x01	; 1
    6f36:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    6f3a:	8b e0       	ldi	r24, 0x0B	; 11
    6f3c:	6c ee       	ldi	r22, 0xEC	; 236
    6f3e:	73 e0       	ldi	r23, 0x03	; 3
    6f40:	4a e2       	ldi	r20, 0x2A	; 42
    6f42:	26 ed       	ldi	r18, 0xD6	; 214
    6f44:	31 e0       	ldi	r19, 0x01	; 1
    6f46:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    6f4a:	86 e0       	ldi	r24, 0x06	; 6
    6f4c:	6c ee       	ldi	r22, 0xEC	; 236
    6f4e:	73 e0       	ldi	r23, 0x03	; 3
    6f50:	41 e0       	ldi	r20, 0x01	; 1
    6f52:	26 ed       	ldi	r18, 0xD6	; 214
    6f54:	31 e0       	ldi	r19, 0x01	; 1
    6f56:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    6f5a:	8c e0       	ldi	r24, 0x0C	; 12
    6f5c:	6c ee       	ldi	r22, 0xEC	; 236
    6f5e:	73 e0       	ldi	r23, 0x03	; 3
    6f60:	41 e0       	ldi	r20, 0x01	; 1
    6f62:	26 ed       	ldi	r18, 0xD6	; 214
    6f64:	31 e0       	ldi	r19, 0x01	; 1
    6f66:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    6f6a:	de 01       	movw	r26, r28
    6f6c:	d7 96       	adiw	r26, 0x37	; 55
    6f6e:	fd 01       	movw	r30, r26
    6f70:	01 90       	ld	r0, Z+
    6f72:	00 20       	and	r0, r0
    6f74:	e9 f7       	brne	.-6      	; 0x6f70 <systemGenerateReport+0xa30>
    6f76:	9a 2f       	mov	r25, r26
    6f78:	9e 1b       	sub	r25, r30
    6f7a:	9e 5e       	subi	r25, 0xEE	; 238
    6f7c:	de 01       	movw	r26, r28
    6f7e:	a7 59       	subi	r26, 0x97	; 151
    6f80:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6f82:	19 16       	cp	r1, r25
    6f84:	7c f4       	brge	.+30     	; 0x6fa4 <systemGenerateReport+0xa64>
    6f86:	fd 01       	movw	r30, r26
    6f88:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6f8a:	20 e2       	ldi	r18, 0x20	; 32
    6f8c:	02 c0       	rjmp	.+4      	; 0x6f92 <systemGenerateReport+0xa52>
    6f8e:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6f90:	8f 5f       	subi	r24, 0xFF	; 255
    6f92:	89 17       	cp	r24, r25
    6f94:	e0 f3       	brcs	.-8      	; 0x6f8e <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6f96:	fe 01       	movw	r30, r28
    6f98:	e7 59       	subi	r30, 0x97	; 151
    6f9a:	ff 4f       	sbci	r31, 0xFF	; 255
    6f9c:	e9 0f       	add	r30, r25
    6f9e:	f1 1d       	adc	r31, r1
    6fa0:	10 82       	st	Z, r1
    6fa2:	04 c0       	rjmp	.+8      	; 0x6fac <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    6fa4:	80 e2       	ldi	r24, 0x20	; 32
    6fa6:	8c 93       	st	X, r24
	 strTab[1]=0;
    6fa8:	11 96       	adiw	r26, 0x01	; 1
    6faa:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    6fac:	de 01       	movw	r26, r28
    6fae:	aa 5b       	subi	r26, 0xBA	; 186
    6fb0:	bf 4f       	sbci	r27, 0xFF	; 255
    6fb2:	fd 01       	movw	r30, r26
    6fb4:	01 90       	ld	r0, Z+
    6fb6:	00 20       	and	r0, r0
    6fb8:	e9 f7       	brne	.-6      	; 0x6fb4 <systemGenerateReport+0xa74>
    6fba:	ae 1b       	sub	r26, r30
    6fbc:	a0 5f       	subi	r26, 0xF0	; 240
    6fbe:	fe 01       	movw	r30, r28
    6fc0:	e3 58       	subi	r30, 0x83	; 131
    6fc2:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6fc4:	1a 16       	cp	r1, r26
    6fc6:	74 f4       	brge	.+28     	; 0x6fe4 <systemGenerateReport+0xaa4>
    6fc8:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6fca:	90 e2       	ldi	r25, 0x20	; 32
    6fcc:	02 c0       	rjmp	.+4      	; 0x6fd2 <systemGenerateReport+0xa92>
    6fce:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6fd0:	8f 5f       	subi	r24, 0xFF	; 255
    6fd2:	8a 17       	cp	r24, r26
    6fd4:	e0 f3       	brcs	.-8      	; 0x6fce <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6fd6:	fe 01       	movw	r30, r28
    6fd8:	e3 58       	subi	r30, 0x83	; 131
    6fda:	ff 4f       	sbci	r31, 0xFF	; 255
    6fdc:	ea 0f       	add	r30, r26
    6fde:	f1 1d       	adc	r31, r1
    6fe0:	10 82       	st	Z, r1
    6fe2:	03 c0       	rjmp	.+6      	; 0x6fea <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    6fe4:	80 e2       	ldi	r24, 0x20	; 32
    6fe6:	80 83       	st	Z, r24
	 strTab[1]=0;
    6fe8:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6fea:	e1 99       	sbic	0x1c, 1	; 28
    6fec:	fe cf       	rjmp	.-4      	; 0x6fea <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6fee:	91 ec       	ldi	r25, 0xC1	; 193
    6ff0:	e9 2e       	mov	r14, r25
    6ff2:	93 e0       	ldi	r25, 0x03	; 3
    6ff4:	f9 2e       	mov	r15, r25
    6ff6:	ff ba       	out	0x1f, r15	; 31
    6ff8:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6ffa:	e0 9a       	sbi	0x1c, 0	; 28
    6ffc:	8d b3       	in	r24, 0x1d	; 29
    6ffe:	9e 01       	movw	r18, r28
    7000:	2b 55       	subi	r18, 0x5B	; 91
    7002:	3f 4f       	sbci	r19, 0xFF	; 255
    7004:	ae 01       	movw	r20, r28
    7006:	49 5c       	subi	r20, 0xC9	; 201
    7008:	5f 4f       	sbci	r21, 0xFF	; 255
    700a:	de 01       	movw	r26, r28
    700c:	a7 59       	subi	r26, 0x97	; 151
    700e:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7010:	81 30       	cpi	r24, 0x01	; 1
    7012:	49 f5       	brne	.+82     	; 0x7066 <systemGenerateReport+0xb26>
    7014:	8d b7       	in	r24, 0x3d	; 61
    7016:	9e b7       	in	r25, 0x3e	; 62
    7018:	0c 97       	sbiw	r24, 0x0c	; 12
    701a:	0f b6       	in	r0, 0x3f	; 63
    701c:	f8 94       	cli
    701e:	9e bf       	out	0x3e, r25	; 62
    7020:	0f be       	out	0x3f, r0	; 63
    7022:	8d bf       	out	0x3d, r24	; 61
    7024:	6d b7       	in	r22, 0x3d	; 61
    7026:	7e b7       	in	r23, 0x3e	; 62
    7028:	6f 5f       	subi	r22, 0xFF	; 255
    702a:	7f 4f       	sbci	r23, 0xFF	; 255
    702c:	ed b7       	in	r30, 0x3d	; 61
    702e:	fe b7       	in	r31, 0x3e	; 62
    7030:	32 83       	std	Z+2, r19	; 0x02
    7032:	21 83       	std	Z+1, r18	; 0x01
    7034:	83 ef       	ldi	r24, 0xF3	; 243
    7036:	93 e0       	ldi	r25, 0x03	; 3
    7038:	fb 01       	movw	r30, r22
    703a:	93 83       	std	Z+3, r25	; 0x03
    703c:	82 83       	std	Z+2, r24	; 0x02
    703e:	b5 83       	std	Z+5, r27	; 0x05
    7040:	a4 83       	std	Z+4, r26	; 0x04
    7042:	57 83       	std	Z+7, r21	; 0x07
    7044:	46 83       	std	Z+6, r20	; 0x06
    7046:	ce 01       	movw	r24, r28
    7048:	83 58       	subi	r24, 0x83	; 131
    704a:	9f 4f       	sbci	r25, 0xFF	; 255
    704c:	91 87       	std	Z+9, r25	; 0x09
    704e:	80 87       	std	Z+8, r24	; 0x08
    7050:	ce 01       	movw	r24, r28
    7052:	8a 5b       	subi	r24, 0xBA	; 186
    7054:	9f 4f       	sbci	r25, 0xFF	; 255
    7056:	93 87       	std	Z+11, r25	; 0x0b
    7058:	82 87       	std	Z+10, r24	; 0x0a
    705a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    705e:	8d b7       	in	r24, 0x3d	; 61
    7060:	9e b7       	in	r25, 0x3e	; 62
    7062:	0c 96       	adiw	r24, 0x0c	; 12
    7064:	1c c0       	rjmp	.+56     	; 0x709e <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    7066:	ed b7       	in	r30, 0x3d	; 61
    7068:	fe b7       	in	r31, 0x3e	; 62
    706a:	38 97       	sbiw	r30, 0x08	; 8
    706c:	0f b6       	in	r0, 0x3f	; 63
    706e:	f8 94       	cli
    7070:	fe bf       	out	0x3e, r31	; 62
    7072:	0f be       	out	0x3f, r0	; 63
    7074:	ed bf       	out	0x3d, r30	; 61
    7076:	6d b7       	in	r22, 0x3d	; 61
    7078:	7e b7       	in	r23, 0x3e	; 62
    707a:	6f 5f       	subi	r22, 0xFF	; 255
    707c:	7f 4f       	sbci	r23, 0xFF	; 255
    707e:	32 83       	std	Z+2, r19	; 0x02
    7080:	21 83       	std	Z+1, r18	; 0x01
    7082:	88 ee       	ldi	r24, 0xE8	; 232
    7084:	93 e0       	ldi	r25, 0x03	; 3
    7086:	fb 01       	movw	r30, r22
    7088:	93 83       	std	Z+3, r25	; 0x03
    708a:	82 83       	std	Z+2, r24	; 0x02
    708c:	b5 83       	std	Z+5, r27	; 0x05
    708e:	a4 83       	std	Z+4, r26	; 0x04
    7090:	57 83       	std	Z+7, r21	; 0x07
    7092:	46 83       	std	Z+6, r20	; 0x06
    7094:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    7098:	8d b7       	in	r24, 0x3d	; 61
    709a:	9e b7       	in	r25, 0x3e	; 62
    709c:	08 96       	adiw	r24, 0x08	; 8
    709e:	0f b6       	in	r0, 0x3f	; 63
    70a0:	f8 94       	cli
    70a2:	9e bf       	out	0x3e, r25	; 62
    70a4:	0f be       	out	0x3f, r0	; 63
    70a6:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    70a8:	ce 01       	movw	r24, r28
    70aa:	8b 55       	subi	r24, 0x5B	; 91
    70ac:	9f 4f       	sbci	r25, 0xFF	; 255
    70ae:	6c ee       	ldi	r22, 0xEC	; 236
    70b0:	73 e0       	ldi	r23, 0x03	; 3
    70b2:	46 ed       	ldi	r20, 0xD6	; 214
    70b4:	51 e0       	ldi	r21, 0x01	; 1
    70b6:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    70ba:	de 01       	movw	r26, r28
    70bc:	59 96       	adiw	r26, 0x19	; 25
    70be:	fd 01       	movw	r30, r26
    70c0:	01 90       	ld	r0, Z+
    70c2:	00 20       	and	r0, r0
    70c4:	e9 f7       	brne	.-6      	; 0x70c0 <systemGenerateReport+0xb80>
    70c6:	9a 2f       	mov	r25, r26
    70c8:	9e 1b       	sub	r25, r30
    70ca:	9e 5e       	subi	r25, 0xEE	; 238
    70cc:	de 01       	movw	r26, r28
    70ce:	a7 59       	subi	r26, 0x97	; 151
    70d0:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    70d2:	19 16       	cp	r1, r25
    70d4:	7c f4       	brge	.+30     	; 0x70f4 <systemGenerateReport+0xbb4>
    70d6:	fd 01       	movw	r30, r26
    70d8:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    70da:	20 e2       	ldi	r18, 0x20	; 32
    70dc:	02 c0       	rjmp	.+4      	; 0x70e2 <systemGenerateReport+0xba2>
    70de:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    70e0:	8f 5f       	subi	r24, 0xFF	; 255
    70e2:	89 17       	cp	r24, r25
    70e4:	e0 f3       	brcs	.-8      	; 0x70de <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    70e6:	fe 01       	movw	r30, r28
    70e8:	e7 59       	subi	r30, 0x97	; 151
    70ea:	ff 4f       	sbci	r31, 0xFF	; 255
    70ec:	e9 0f       	add	r30, r25
    70ee:	f1 1d       	adc	r31, r1
    70f0:	10 82       	st	Z, r1
    70f2:	04 c0       	rjmp	.+8      	; 0x70fc <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    70f4:	80 e2       	ldi	r24, 0x20	; 32
    70f6:	8c 93       	st	X, r24
	 strTab[1]=0;
    70f8:	11 96       	adiw	r26, 0x01	; 1
    70fa:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    70fc:	de 01       	movw	r26, r28
    70fe:	98 96       	adiw	r26, 0x28	; 40
    7100:	fd 01       	movw	r30, r26
    7102:	01 90       	ld	r0, Z+
    7104:	00 20       	and	r0, r0
    7106:	e9 f7       	brne	.-6      	; 0x7102 <systemGenerateReport+0xbc2>
    7108:	ae 1b       	sub	r26, r30
    710a:	a0 5f       	subi	r26, 0xF0	; 240
    710c:	fe 01       	movw	r30, r28
    710e:	e3 58       	subi	r30, 0x83	; 131
    7110:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7112:	1a 16       	cp	r1, r26
    7114:	74 f4       	brge	.+28     	; 0x7132 <systemGenerateReport+0xbf2>
    7116:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7118:	90 e2       	ldi	r25, 0x20	; 32
    711a:	02 c0       	rjmp	.+4      	; 0x7120 <systemGenerateReport+0xbe0>
    711c:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    711e:	8f 5f       	subi	r24, 0xFF	; 255
    7120:	8a 17       	cp	r24, r26
    7122:	e0 f3       	brcs	.-8      	; 0x711c <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7124:	fe 01       	movw	r30, r28
    7126:	e3 58       	subi	r30, 0x83	; 131
    7128:	ff 4f       	sbci	r31, 0xFF	; 255
    712a:	ea 0f       	add	r30, r26
    712c:	f1 1d       	adc	r31, r1
    712e:	10 82       	st	Z, r1
    7130:	03 c0       	rjmp	.+6      	; 0x7138 <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    7132:	80 e2       	ldi	r24, 0x20	; 32
    7134:	80 83       	st	Z, r24
	 strTab[1]=0;
    7136:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7138:	e1 99       	sbic	0x1c, 1	; 28
    713a:	fe cf       	rjmp	.-4      	; 0x7138 <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    713c:	ff ba       	out	0x1f, r15	; 31
    713e:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7140:	e0 9a       	sbi	0x1c, 0	; 28
    7142:	8d b3       	in	r24, 0x1d	; 29
    7144:	9e 01       	movw	r18, r28
    7146:	2b 55       	subi	r18, 0x5B	; 91
    7148:	3f 4f       	sbci	r19, 0xFF	; 255
    714a:	ae 01       	movw	r20, r28
    714c:	47 5e       	subi	r20, 0xE7	; 231
    714e:	5f 4f       	sbci	r21, 0xFF	; 255
    7150:	de 01       	movw	r26, r28
    7152:	a7 59       	subi	r26, 0x97	; 151
    7154:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7156:	81 30       	cpi	r24, 0x01	; 1
    7158:	31 f5       	brne	.+76     	; 0x71a6 <systemGenerateReport+0xc66>
    715a:	ed b7       	in	r30, 0x3d	; 61
    715c:	fe b7       	in	r31, 0x3e	; 62
    715e:	3c 97       	sbiw	r30, 0x0c	; 12
    7160:	0f b6       	in	r0, 0x3f	; 63
    7162:	f8 94       	cli
    7164:	fe bf       	out	0x3e, r31	; 62
    7166:	0f be       	out	0x3f, r0	; 63
    7168:	ed bf       	out	0x3d, r30	; 61
    716a:	6d b7       	in	r22, 0x3d	; 61
    716c:	7e b7       	in	r23, 0x3e	; 62
    716e:	6f 5f       	subi	r22, 0xFF	; 255
    7170:	7f 4f       	sbci	r23, 0xFF	; 255
    7172:	32 83       	std	Z+2, r19	; 0x02
    7174:	21 83       	std	Z+1, r18	; 0x01
    7176:	89 ed       	ldi	r24, 0xD9	; 217
    7178:	93 e0       	ldi	r25, 0x03	; 3
    717a:	fb 01       	movw	r30, r22
    717c:	93 83       	std	Z+3, r25	; 0x03
    717e:	82 83       	std	Z+2, r24	; 0x02
    7180:	b5 83       	std	Z+5, r27	; 0x05
    7182:	a4 83       	std	Z+4, r26	; 0x04
    7184:	57 83       	std	Z+7, r21	; 0x07
    7186:	46 83       	std	Z+6, r20	; 0x06
    7188:	ce 01       	movw	r24, r28
    718a:	83 58       	subi	r24, 0x83	; 131
    718c:	9f 4f       	sbci	r25, 0xFF	; 255
    718e:	91 87       	std	Z+9, r25	; 0x09
    7190:	80 87       	std	Z+8, r24	; 0x08
    7192:	ce 01       	movw	r24, r28
    7194:	88 96       	adiw	r24, 0x28	; 40
    7196:	93 87       	std	Z+11, r25	; 0x0b
    7198:	82 87       	std	Z+10, r24	; 0x0a
    719a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    719e:	8d b7       	in	r24, 0x3d	; 61
    71a0:	9e b7       	in	r25, 0x3e	; 62
    71a2:	0c 96       	adiw	r24, 0x0c	; 12
    71a4:	1c c0       	rjmp	.+56     	; 0x71de <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    71a6:	ed b7       	in	r30, 0x3d	; 61
    71a8:	fe b7       	in	r31, 0x3e	; 62
    71aa:	38 97       	sbiw	r30, 0x08	; 8
    71ac:	0f b6       	in	r0, 0x3f	; 63
    71ae:	f8 94       	cli
    71b0:	fe bf       	out	0x3e, r31	; 62
    71b2:	0f be       	out	0x3f, r0	; 63
    71b4:	ed bf       	out	0x3d, r30	; 61
    71b6:	6d b7       	in	r22, 0x3d	; 61
    71b8:	7e b7       	in	r23, 0x3e	; 62
    71ba:	6f 5f       	subi	r22, 0xFF	; 255
    71bc:	7f 4f       	sbci	r23, 0xFF	; 255
    71be:	32 83       	std	Z+2, r19	; 0x02
    71c0:	21 83       	std	Z+1, r18	; 0x01
    71c2:	8e ec       	ldi	r24, 0xCE	; 206
    71c4:	93 e0       	ldi	r25, 0x03	; 3
    71c6:	fb 01       	movw	r30, r22
    71c8:	93 83       	std	Z+3, r25	; 0x03
    71ca:	82 83       	std	Z+2, r24	; 0x02
    71cc:	b5 83       	std	Z+5, r27	; 0x05
    71ce:	a4 83       	std	Z+4, r26	; 0x04
    71d0:	57 83       	std	Z+7, r21	; 0x07
    71d2:	46 83       	std	Z+6, r20	; 0x06
    71d4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    71d8:	8d b7       	in	r24, 0x3d	; 61
    71da:	9e b7       	in	r25, 0x3e	; 62
    71dc:	08 96       	adiw	r24, 0x08	; 8
    71de:	0f b6       	in	r0, 0x3f	; 63
    71e0:	f8 94       	cli
    71e2:	9e bf       	out	0x3e, r25	; 62
    71e4:	0f be       	out	0x3f, r0	; 63
    71e6:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    71e8:	ce 01       	movw	r24, r28
    71ea:	8b 55       	subi	r24, 0x5B	; 91
    71ec:	9f 4f       	sbci	r25, 0xFF	; 255
    71ee:	6c ee       	ldi	r22, 0xEC	; 236
    71f0:	73 e0       	ldi	r23, 0x03	; 3
    71f2:	46 ed       	ldi	r20, 0xD6	; 214
    71f4:	51 e0       	ldi	r21, 0x01	; 1
    71f6:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>
    71fa:	8e 01       	movw	r16, r28
    71fc:	07 59       	subi	r16, 0x97	; 151
    71fe:	1f 4f       	sbci	r17, 0xFF	; 255
    7200:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7202:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7204:	d8 01       	movw	r26, r16
    7206:	c8 01       	movw	r24, r16
    7208:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    720a:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    720c:	e8 17       	cp	r30, r24
    720e:	f9 07       	cpc	r31, r25
    7210:	e1 f7       	brne	.-8      	; 0x720a <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7212:	1c 96       	adiw	r26, 0x0c	; 12
    7214:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7216:	e1 99       	sbic	0x1c, 1	; 28
    7218:	fe cf       	rjmp	.-4      	; 0x7216 <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    721a:	ff ba       	out	0x1f, r15	; 31
    721c:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    721e:	e0 9a       	sbi	0x1c, 0	; 28
    7220:	8d b3       	in	r24, 0x1d	; 29
    7222:	9e 01       	movw	r18, r28
    7224:	2b 55       	subi	r18, 0x5B	; 91
    7226:	3f 4f       	sbci	r19, 0xFF	; 255
    7228:	de 01       	movw	r26, r28
    722a:	a7 59       	subi	r26, 0x97	; 151
    722c:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    722e:	81 30       	cpi	r24, 0x01	; 1
    7230:	71 f4       	brne	.+28     	; 0x724e <systemGenerateReport+0xd0e>
    7232:	00 d0       	rcall	.+0      	; 0x7234 <systemGenerateReport+0xcf4>
    7234:	00 d0       	rcall	.+0      	; 0x7236 <systemGenerateReport+0xcf6>
    7236:	00 d0       	rcall	.+0      	; 0x7238 <systemGenerateReport+0xcf8>
    7238:	4d b7       	in	r20, 0x3d	; 61
    723a:	5e b7       	in	r21, 0x3e	; 62
    723c:	4f 5f       	subi	r20, 0xFF	; 255
    723e:	5f 4f       	sbci	r21, 0xFF	; 255
    7240:	ed b7       	in	r30, 0x3d	; 61
    7242:	fe b7       	in	r31, 0x3e	; 62
    7244:	32 83       	std	Z+2, r19	; 0x02
    7246:	21 83       	std	Z+1, r18	; 0x01
    7248:	80 eb       	ldi	r24, 0xB0	; 176
    724a:	93 e0       	ldi	r25, 0x03	; 3
    724c:	0d c0       	rjmp	.+26     	; 0x7268 <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    724e:	00 d0       	rcall	.+0      	; 0x7250 <systemGenerateReport+0xd10>
    7250:	00 d0       	rcall	.+0      	; 0x7252 <systemGenerateReport+0xd12>
    7252:	00 d0       	rcall	.+0      	; 0x7254 <systemGenerateReport+0xd14>
    7254:	4d b7       	in	r20, 0x3d	; 61
    7256:	5e b7       	in	r21, 0x3e	; 62
    7258:	4f 5f       	subi	r20, 0xFF	; 255
    725a:	5f 4f       	sbci	r21, 0xFF	; 255
    725c:	ed b7       	in	r30, 0x3d	; 61
    725e:	fe b7       	in	r31, 0x3e	; 62
    7260:	32 83       	std	Z+2, r19	; 0x02
    7262:	21 83       	std	Z+1, r18	; 0x01
    7264:	82 e9       	ldi	r24, 0x92	; 146
    7266:	93 e0       	ldi	r25, 0x03	; 3
    7268:	fa 01       	movw	r30, r20
    726a:	93 83       	std	Z+3, r25	; 0x03
    726c:	82 83       	std	Z+2, r24	; 0x02
    726e:	b5 83       	std	Z+5, r27	; 0x05
    7270:	a4 83       	std	Z+4, r26	; 0x04
    7272:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    7276:	8d b7       	in	r24, 0x3d	; 61
    7278:	9e b7       	in	r25, 0x3e	; 62
    727a:	06 96       	adiw	r24, 0x06	; 6
    727c:	0f b6       	in	r0, 0x3f	; 63
    727e:	f8 94       	cli
    7280:	9e bf       	out	0x3e, r25	; 62
    7282:	0f be       	out	0x3f, r0	; 63
    7284:	8d bf       	out	0x3d, r24	; 61
    7286:	ce 01       	movw	r24, r28
    7288:	8b 55       	subi	r24, 0x5B	; 91
    728a:	9f 4f       	sbci	r25, 0xFF	; 255
    728c:	6c ee       	ldi	r22, 0xEC	; 236
    728e:	73 e0       	ldi	r23, 0x03	; 3
    7290:	46 ed       	ldi	r20, 0xD6	; 214
    7292:	51 e0       	ldi	r21, 0x01	; 1
    7294:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    7298:	e5 e0       	ldi	r30, 0x05	; 5
    729a:	f9 e0       	ldi	r31, 0x09	; 9
    729c:	01 90       	ld	r0, Z+
    729e:	00 20       	and	r0, r0
    72a0:	e9 f7       	brne	.-6      	; 0x729c <systemGenerateReport+0xd5c>
    72a2:	31 97       	sbiw	r30, 0x01	; 1
    72a4:	e5 50       	subi	r30, 0x05	; 5
    72a6:	f9 40       	sbci	r31, 0x09	; 9
    72a8:	97 e1       	ldi	r25, 0x17	; 23
    72aa:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    72ac:	19 16       	cp	r1, r25
    72ae:	84 f4       	brge	.+32     	; 0x72d0 <systemGenerateReport+0xd90>
    72b0:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    72b2:	20 e2       	ldi	r18, 0x20	; 32
    72b4:	04 c0       	rjmp	.+8      	; 0x72be <systemGenerateReport+0xd7e>
    72b6:	d8 01       	movw	r26, r16
    72b8:	2d 93       	st	X+, r18
    72ba:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    72bc:	8f 5f       	subi	r24, 0xFF	; 255
    72be:	89 17       	cp	r24, r25
    72c0:	d0 f3       	brcs	.-12     	; 0x72b6 <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    72c2:	fe 01       	movw	r30, r28
    72c4:	e7 59       	subi	r30, 0x97	; 151
    72c6:	ff 4f       	sbci	r31, 0xFF	; 255
    72c8:	e9 0f       	add	r30, r25
    72ca:	f1 1d       	adc	r31, r1
    72cc:	10 82       	st	Z, r1
    72ce:	06 c0       	rjmp	.+12     	; 0x72dc <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    72d0:	fe 01       	movw	r30, r28
    72d2:	e7 59       	subi	r30, 0x97	; 151
    72d4:	ff 4f       	sbci	r31, 0xFF	; 255
    72d6:	80 e2       	ldi	r24, 0x20	; 32
    72d8:	80 83       	st	Z, r24
	 strTab[1]=0;
    72da:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    72dc:	ed e2       	ldi	r30, 0x2D	; 45
    72de:	fc e0       	ldi	r31, 0x0C	; 12
    72e0:	01 90       	ld	r0, Z+
    72e2:	00 20       	and	r0, r0
    72e4:	e9 f7       	brne	.-6      	; 0x72e0 <systemGenerateReport+0xda0>
    72e6:	31 97       	sbiw	r30, 0x01	; 1
    72e8:	ed 52       	subi	r30, 0x2D	; 45
    72ea:	fc 40       	sbci	r31, 0x0C	; 12
    72ec:	9f e0       	ldi	r25, 0x0F	; 15
    72ee:	9e 1b       	sub	r25, r30
    72f0:	fe 01       	movw	r30, r28
    72f2:	e3 58       	subi	r30, 0x83	; 131
    72f4:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    72f6:	19 16       	cp	r1, r25
    72f8:	74 f4       	brge	.+28     	; 0x7316 <systemGenerateReport+0xdd6>
    72fa:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    72fc:	20 e2       	ldi	r18, 0x20	; 32
    72fe:	02 c0       	rjmp	.+4      	; 0x7304 <systemGenerateReport+0xdc4>
    7300:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7302:	8f 5f       	subi	r24, 0xFF	; 255
    7304:	89 17       	cp	r24, r25
    7306:	e0 f3       	brcs	.-8      	; 0x7300 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7308:	fe 01       	movw	r30, r28
    730a:	e3 58       	subi	r30, 0x83	; 131
    730c:	ff 4f       	sbci	r31, 0xFF	; 255
    730e:	e9 0f       	add	r30, r25
    7310:	f1 1d       	adc	r31, r1
    7312:	10 82       	st	Z, r1
    7314:	03 c0       	rjmp	.+6      	; 0x731c <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    7316:	80 e2       	ldi	r24, 0x20	; 32
    7318:	80 83       	st	Z, r24
	 strTab[1]=0;
    731a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    731c:	e1 99       	sbic	0x1c, 1	; 28
    731e:	fe cf       	rjmp	.-4      	; 0x731c <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7320:	ff ba       	out	0x1f, r15	; 31
    7322:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7324:	e0 9a       	sbi	0x1c, 0	; 28
    7326:	8d b3       	in	r24, 0x1d	; 29
    7328:	9e 01       	movw	r18, r28
    732a:	2b 55       	subi	r18, 0x5B	; 91
    732c:	3f 4f       	sbci	r19, 0xFF	; 255
    732e:	45 e0       	ldi	r20, 0x05	; 5
    7330:	59 e0       	ldi	r21, 0x09	; 9
    7332:	de 01       	movw	r26, r28
    7334:	a7 59       	subi	r26, 0x97	; 151
    7336:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7338:	81 30       	cpi	r24, 0x01	; 1
    733a:	31 f5       	brne	.+76     	; 0x7388 <systemGenerateReport+0xe48>
    733c:	ed b7       	in	r30, 0x3d	; 61
    733e:	fe b7       	in	r31, 0x3e	; 62
    7340:	3c 97       	sbiw	r30, 0x0c	; 12
    7342:	0f b6       	in	r0, 0x3f	; 63
    7344:	f8 94       	cli
    7346:	fe bf       	out	0x3e, r31	; 62
    7348:	0f be       	out	0x3f, r0	; 63
    734a:	ed bf       	out	0x3d, r30	; 61
    734c:	6d b7       	in	r22, 0x3d	; 61
    734e:	7e b7       	in	r23, 0x3e	; 62
    7350:	6f 5f       	subi	r22, 0xFF	; 255
    7352:	7f 4f       	sbci	r23, 0xFF	; 255
    7354:	32 83       	std	Z+2, r19	; 0x02
    7356:	21 83       	std	Z+1, r18	; 0x01
    7358:	89 e8       	ldi	r24, 0x89	; 137
    735a:	93 e0       	ldi	r25, 0x03	; 3
    735c:	fb 01       	movw	r30, r22
    735e:	93 83       	std	Z+3, r25	; 0x03
    7360:	82 83       	std	Z+2, r24	; 0x02
    7362:	b5 83       	std	Z+5, r27	; 0x05
    7364:	a4 83       	std	Z+4, r26	; 0x04
    7366:	57 83       	std	Z+7, r21	; 0x07
    7368:	46 83       	std	Z+6, r20	; 0x06
    736a:	ce 01       	movw	r24, r28
    736c:	83 58       	subi	r24, 0x83	; 131
    736e:	9f 4f       	sbci	r25, 0xFF	; 255
    7370:	91 87       	std	Z+9, r25	; 0x09
    7372:	80 87       	std	Z+8, r24	; 0x08
    7374:	8d e2       	ldi	r24, 0x2D	; 45
    7376:	9c e0       	ldi	r25, 0x0C	; 12
    7378:	93 87       	std	Z+11, r25	; 0x0b
    737a:	82 87       	std	Z+10, r24	; 0x0a
    737c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    7380:	8d b7       	in	r24, 0x3d	; 61
    7382:	9e b7       	in	r25, 0x3e	; 62
    7384:	0c 96       	adiw	r24, 0x0c	; 12
    7386:	1c c0       	rjmp	.+56     	; 0x73c0 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7388:	ed b7       	in	r30, 0x3d	; 61
    738a:	fe b7       	in	r31, 0x3e	; 62
    738c:	38 97       	sbiw	r30, 0x08	; 8
    738e:	0f b6       	in	r0, 0x3f	; 63
    7390:	f8 94       	cli
    7392:	fe bf       	out	0x3e, r31	; 62
    7394:	0f be       	out	0x3f, r0	; 63
    7396:	ed bf       	out	0x3d, r30	; 61
    7398:	6d b7       	in	r22, 0x3d	; 61
    739a:	7e b7       	in	r23, 0x3e	; 62
    739c:	6f 5f       	subi	r22, 0xFF	; 255
    739e:	7f 4f       	sbci	r23, 0xFF	; 255
    73a0:	32 83       	std	Z+2, r19	; 0x02
    73a2:	21 83       	std	Z+1, r18	; 0x01
    73a4:	84 e8       	ldi	r24, 0x84	; 132
    73a6:	93 e0       	ldi	r25, 0x03	; 3
    73a8:	fb 01       	movw	r30, r22
    73aa:	93 83       	std	Z+3, r25	; 0x03
    73ac:	82 83       	std	Z+2, r24	; 0x02
    73ae:	b5 83       	std	Z+5, r27	; 0x05
    73b0:	a4 83       	std	Z+4, r26	; 0x04
    73b2:	57 83       	std	Z+7, r21	; 0x07
    73b4:	46 83       	std	Z+6, r20	; 0x06
    73b6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    73ba:	8d b7       	in	r24, 0x3d	; 61
    73bc:	9e b7       	in	r25, 0x3e	; 62
    73be:	08 96       	adiw	r24, 0x08	; 8
    73c0:	0f b6       	in	r0, 0x3f	; 63
    73c2:	f8 94       	cli
    73c4:	9e bf       	out	0x3e, r25	; 62
    73c6:	0f be       	out	0x3f, r0	; 63
    73c8:	8d bf       	out	0x3d, r24	; 61
    73ca:	ce 01       	movw	r24, r28
    73cc:	8b 55       	subi	r24, 0x5B	; 91
    73ce:	9f 4f       	sbci	r25, 0xFF	; 255
    73d0:	6c ee       	ldi	r22, 0xEC	; 236
    73d2:	73 e0       	ldi	r23, 0x03	; 3
    73d4:	46 ed       	ldi	r20, 0xD6	; 214
    73d6:	51 e0       	ldi	r21, 0x01	; 1
    73d8:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    73dc:	87 e0       	ldi	r24, 0x07	; 7
    73de:	6c ee       	ldi	r22, 0xEC	; 236
    73e0:	73 e0       	ldi	r23, 0x03	; 3
    73e2:	41 e0       	ldi	r20, 0x01	; 1
    73e4:	26 ed       	ldi	r18, 0xD6	; 214
    73e6:	31 e0       	ldi	r19, 0x01	; 1
    73e8:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    73ec:	8b e0       	ldi	r24, 0x0B	; 11
    73ee:	6c ee       	ldi	r22, 0xEC	; 236
    73f0:	73 e0       	ldi	r23, 0x03	; 3
    73f2:	4a e2       	ldi	r20, 0x2A	; 42
    73f4:	26 ed       	ldi	r18, 0xD6	; 214
    73f6:	31 e0       	ldi	r19, 0x01	; 1
    73f8:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    73fc:	89 e0       	ldi	r24, 0x09	; 9
    73fe:	6c ee       	ldi	r22, 0xEC	; 236
    7400:	73 e0       	ldi	r23, 0x03	; 3
    7402:	41 e0       	ldi	r20, 0x01	; 1
    7404:	26 ed       	ldi	r18, 0xD6	; 214
    7406:	31 e0       	ldi	r19, 0x01	; 1
    7408:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    740c:	8c e0       	ldi	r24, 0x0C	; 12
    740e:	6c ee       	ldi	r22, 0xEC	; 236
    7410:	73 e0       	ldi	r23, 0x03	; 3
    7412:	41 e0       	ldi	r20, 0x01	; 1
    7414:	26 ed       	ldi	r18, 0xD6	; 214
    7416:	31 e0       	ldi	r19, 0x01	; 1
    7418:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>


          cmdPrint=0b00000000;
    741c:	10 92 b5 01 	sts	0x01B5, r1
		  LengthMessage81=RepPos+1;
    7420:	80 91 d6 01 	lds	r24, 0x01D6
    7424:	90 91 d7 01 	lds	r25, 0x01D7
    7428:	01 96       	adiw	r24, 0x01	; 1
    742a:	90 93 8e 01 	sts	0x018E, r25
    742e:	80 93 8d 01 	sts	0x018D, r24

		  IsFreePrinting=True;
    7432:	81 e0       	ldi	r24, 0x01	; 1
    7434:	80 93 a8 01 	sts	0x01A8, r24
	      IsBusyFreePrinting=True;
    7438:	80 93 b4 01 	sts	0x01B4, r24

	      stGenerateReport=grWaitPrinted2;
    743c:	89 e0       	ldi	r24, 0x09	; 9
    743e:	91 c3       	rjmp	.+1826   	; 0x7b62 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    7440:	80 91 b4 01 	lds	r24, 0x01B4
    7444:	88 23       	and	r24, r24
    7446:	09 f0       	breq	.+2      	; 0x744a <systemGenerateReport+0xf0a>
    7448:	94 c3       	rjmp	.+1832   	; 0x7b72 <systemGenerateReport+0x1632>
    744a:	86 e0       	ldi	r24, 0x06	; 6
    744c:	8a c3       	rjmp	.+1812   	; 0x7b62 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    744e:	10 92 d7 01 	sts	0x01D7, r1
    7452:	10 92 d6 01 	sts	0x01D6, r1
    7456:	ec ee       	ldi	r30, 0xEC	; 236
    7458:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    745a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    745c:	95 e0       	ldi	r25, 0x05	; 5
    745e:	ed 37       	cpi	r30, 0x7D	; 125
    7460:	f9 07       	cpc	r31, r25
    7462:	d9 f7       	brne	.-10     	; 0x745a <systemGenerateReport+0xf1a>
    7464:	fe 01       	movw	r30, r28
    7466:	eb 55       	subi	r30, 0x5B	; 91
    7468:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    746a:	ce 01       	movw	r24, r28
    746c:	8b 50       	subi	r24, 0x0B	; 11
    746e:	9f 4f       	sbci	r25, 0xFF	; 255
    7470:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7472:	e8 17       	cp	r30, r24
    7474:	f9 07       	cpc	r31, r25
    7476:	e1 f7       	brne	.-8      	; 0x7470 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    7478:	88 ea       	ldi	r24, 0xA8	; 168
    747a:	98 e0       	ldi	r25, 0x08	; 8
    747c:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    7480:	07 ef       	ldi	r16, 0xF7	; 247
    7482:	17 e0       	ldi	r17, 0x07	; 7
    7484:	c8 01       	movw	r24, r16
    7486:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    748a:	88 ea       	ldi	r24, 0xA8	; 168
    748c:	98 e0       	ldi	r25, 0x08	; 8
    748e:	0e 94 6c 32 	call	0x64d8	; 0x64d8 <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    7492:	88 ea       	ldi	r24, 0xA8	; 168
    7494:	98 e0       	ldi	r25, 0x08	; 8
    7496:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    749a:	c8 01       	movw	r24, r16
    749c:	0e 94 5f 32 	call	0x64be	; 0x64be <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    74a0:	c8 01       	movw	r24, r16
    74a2:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    74a6:	81 e0       	ldi	r24, 0x01	; 1
    74a8:	6c ee       	ldi	r22, 0xEC	; 236
    74aa:	73 e0       	ldi	r23, 0x03	; 3
    74ac:	41 e0       	ldi	r20, 0x01	; 1
    74ae:	26 ed       	ldi	r18, 0xD6	; 214
    74b0:	31 e0       	ldi	r19, 0x01	; 1
    74b2:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    74b6:	8b e0       	ldi	r24, 0x0B	; 11
    74b8:	6c ee       	ldi	r22, 0xEC	; 236
    74ba:	73 e0       	ldi	r23, 0x03	; 3
    74bc:	4a e2       	ldi	r20, 0x2A	; 42
    74be:	26 ed       	ldi	r18, 0xD6	; 214
    74c0:	31 e0       	ldi	r19, 0x01	; 1
    74c2:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    74c6:	83 e0       	ldi	r24, 0x03	; 3
    74c8:	6c ee       	ldi	r22, 0xEC	; 236
    74ca:	73 e0       	ldi	r23, 0x03	; 3
    74cc:	41 e0       	ldi	r20, 0x01	; 1
    74ce:	26 ed       	ldi	r18, 0xD6	; 214
    74d0:	31 e0       	ldi	r19, 0x01	; 1
    74d2:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    74d6:	8c e0       	ldi	r24, 0x0C	; 12
    74d8:	6c ee       	ldi	r22, 0xEC	; 236
    74da:	73 e0       	ldi	r23, 0x03	; 3
    74dc:	41 e0       	ldi	r20, 0x01	; 1
    74de:	26 ed       	ldi	r18, 0xD6	; 214
    74e0:	31 e0       	ldi	r19, 0x01	; 1
    74e2:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    74e6:	d8 01       	movw	r26, r16
    74e8:	0d 90       	ld	r0, X+
    74ea:	00 20       	and	r0, r0
    74ec:	e9 f7       	brne	.-6      	; 0x74e8 <systemGenerateReport+0xfa8>
    74ee:	8d 01       	movw	r16, r26
    74f0:	01 50       	subi	r16, 0x01	; 1
    74f2:	10 40       	sbci	r17, 0x00	; 0
    74f4:	07 5f       	subi	r16, 0xF7	; 247
    74f6:	17 40       	sbci	r17, 0x07	; 7
    74f8:	91 e1       	ldi	r25, 0x11	; 17
    74fa:	90 1b       	sub	r25, r16
    74fc:	de 01       	movw	r26, r28
    74fe:	a7 59       	subi	r26, 0x97	; 151
    7500:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7502:	19 16       	cp	r1, r25
    7504:	7c f4       	brge	.+30     	; 0x7524 <systemGenerateReport+0xfe4>
    7506:	fd 01       	movw	r30, r26
    7508:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    750a:	20 e2       	ldi	r18, 0x20	; 32
    750c:	02 c0       	rjmp	.+4      	; 0x7512 <systemGenerateReport+0xfd2>
    750e:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7510:	8f 5f       	subi	r24, 0xFF	; 255
    7512:	89 17       	cp	r24, r25
    7514:	e0 f3       	brcs	.-8      	; 0x750e <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7516:	fe 01       	movw	r30, r28
    7518:	e7 59       	subi	r30, 0x97	; 151
    751a:	ff 4f       	sbci	r31, 0xFF	; 255
    751c:	e9 0f       	add	r30, r25
    751e:	f1 1d       	adc	r31, r1
    7520:	10 82       	st	Z, r1
    7522:	04 c0       	rjmp	.+8      	; 0x752c <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    7524:	80 e2       	ldi	r24, 0x20	; 32
    7526:	8c 93       	st	X, r24
	 strTab[1]=0;
    7528:	11 96       	adiw	r26, 0x01	; 1
    752a:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    752c:	e8 ea       	ldi	r30, 0xA8	; 168
    752e:	f8 e0       	ldi	r31, 0x08	; 8
    7530:	01 90       	ld	r0, Z+
    7532:	00 20       	and	r0, r0
    7534:	e9 f7       	brne	.-6      	; 0x7530 <systemGenerateReport+0xff0>
    7536:	31 97       	sbiw	r30, 0x01	; 1
    7538:	e8 5a       	subi	r30, 0xA8	; 168
    753a:	f8 40       	sbci	r31, 0x08	; 8
    753c:	9f e0       	ldi	r25, 0x0F	; 15
    753e:	9e 1b       	sub	r25, r30
    7540:	fe 01       	movw	r30, r28
    7542:	e3 58       	subi	r30, 0x83	; 131
    7544:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7546:	19 16       	cp	r1, r25
    7548:	74 f4       	brge	.+28     	; 0x7566 <systemGenerateReport+0x1026>
    754a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    754c:	20 e2       	ldi	r18, 0x20	; 32
    754e:	02 c0       	rjmp	.+4      	; 0x7554 <systemGenerateReport+0x1014>
    7550:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7552:	8f 5f       	subi	r24, 0xFF	; 255
    7554:	89 17       	cp	r24, r25
    7556:	e0 f3       	brcs	.-8      	; 0x7550 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7558:	fe 01       	movw	r30, r28
    755a:	e3 58       	subi	r30, 0x83	; 131
    755c:	ff 4f       	sbci	r31, 0xFF	; 255
    755e:	e9 0f       	add	r30, r25
    7560:	f1 1d       	adc	r31, r1
    7562:	10 82       	st	Z, r1
    7564:	03 c0       	rjmp	.+6      	; 0x756c <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    7566:	80 e2       	ldi	r24, 0x20	; 32
    7568:	80 83       	st	Z, r24
	 strTab[1]=0;
    756a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    756c:	e1 99       	sbic	0x1c, 1	; 28
    756e:	fe cf       	rjmp	.-4      	; 0x756c <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7570:	e1 ec       	ldi	r30, 0xC1	; 193
    7572:	f3 e0       	ldi	r31, 0x03	; 3
    7574:	ff bb       	out	0x1f, r31	; 31
    7576:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7578:	e0 9a       	sbi	0x1c, 0	; 28
    757a:	8d b3       	in	r24, 0x1d	; 29
    757c:	9e 01       	movw	r18, r28
    757e:	2b 55       	subi	r18, 0x5B	; 91
    7580:	3f 4f       	sbci	r19, 0xFF	; 255
    7582:	47 ef       	ldi	r20, 0xF7	; 247
    7584:	57 e0       	ldi	r21, 0x07	; 7
    7586:	de 01       	movw	r26, r28
    7588:	a7 59       	subi	r26, 0x97	; 151
    758a:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    758c:	81 30       	cpi	r24, 0x01	; 1
    758e:	41 f5       	brne	.+80     	; 0x75e0 <systemGenerateReport+0x10a0>
    7590:	8d b7       	in	r24, 0x3d	; 61
    7592:	9e b7       	in	r25, 0x3e	; 62
    7594:	0c 97       	sbiw	r24, 0x0c	; 12
    7596:	0f b6       	in	r0, 0x3f	; 63
    7598:	f8 94       	cli
    759a:	9e bf       	out	0x3e, r25	; 62
    759c:	0f be       	out	0x3f, r0	; 63
    759e:	8d bf       	out	0x3d, r24	; 61
    75a0:	6d b7       	in	r22, 0x3d	; 61
    75a2:	7e b7       	in	r23, 0x3e	; 62
    75a4:	6f 5f       	subi	r22, 0xFF	; 255
    75a6:	7f 4f       	sbci	r23, 0xFF	; 255
    75a8:	ed b7       	in	r30, 0x3d	; 61
    75aa:	fe b7       	in	r31, 0x3e	; 62
    75ac:	32 83       	std	Z+2, r19	; 0x02
    75ae:	21 83       	std	Z+1, r18	; 0x01
    75b0:	85 e7       	ldi	r24, 0x75	; 117
    75b2:	93 e0       	ldi	r25, 0x03	; 3
    75b4:	fb 01       	movw	r30, r22
    75b6:	93 83       	std	Z+3, r25	; 0x03
    75b8:	82 83       	std	Z+2, r24	; 0x02
    75ba:	b5 83       	std	Z+5, r27	; 0x05
    75bc:	a4 83       	std	Z+4, r26	; 0x04
    75be:	57 83       	std	Z+7, r21	; 0x07
    75c0:	46 83       	std	Z+6, r20	; 0x06
    75c2:	ce 01       	movw	r24, r28
    75c4:	83 58       	subi	r24, 0x83	; 131
    75c6:	9f 4f       	sbci	r25, 0xFF	; 255
    75c8:	91 87       	std	Z+9, r25	; 0x09
    75ca:	80 87       	std	Z+8, r24	; 0x08
    75cc:	88 ea       	ldi	r24, 0xA8	; 168
    75ce:	98 e0       	ldi	r25, 0x08	; 8
    75d0:	93 87       	std	Z+11, r25	; 0x0b
    75d2:	82 87       	std	Z+10, r24	; 0x0a
    75d4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    75d8:	8d b7       	in	r24, 0x3d	; 61
    75da:	9e b7       	in	r25, 0x3e	; 62
    75dc:	0c 96       	adiw	r24, 0x0c	; 12
    75de:	1c c0       	rjmp	.+56     	; 0x7618 <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    75e0:	ed b7       	in	r30, 0x3d	; 61
    75e2:	fe b7       	in	r31, 0x3e	; 62
    75e4:	38 97       	sbiw	r30, 0x08	; 8
    75e6:	0f b6       	in	r0, 0x3f	; 63
    75e8:	f8 94       	cli
    75ea:	fe bf       	out	0x3e, r31	; 62
    75ec:	0f be       	out	0x3f, r0	; 63
    75ee:	ed bf       	out	0x3d, r30	; 61
    75f0:	6d b7       	in	r22, 0x3d	; 61
    75f2:	7e b7       	in	r23, 0x3e	; 62
    75f4:	6f 5f       	subi	r22, 0xFF	; 255
    75f6:	7f 4f       	sbci	r23, 0xFF	; 255
    75f8:	32 83       	std	Z+2, r19	; 0x02
    75fa:	21 83       	std	Z+1, r18	; 0x01
    75fc:	8a e6       	ldi	r24, 0x6A	; 106
    75fe:	93 e0       	ldi	r25, 0x03	; 3
    7600:	fb 01       	movw	r30, r22
    7602:	93 83       	std	Z+3, r25	; 0x03
    7604:	82 83       	std	Z+2, r24	; 0x02
    7606:	b5 83       	std	Z+5, r27	; 0x05
    7608:	a4 83       	std	Z+4, r26	; 0x04
    760a:	57 83       	std	Z+7, r21	; 0x07
    760c:	46 83       	std	Z+6, r20	; 0x06
    760e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    7612:	8d b7       	in	r24, 0x3d	; 61
    7614:	9e b7       	in	r25, 0x3e	; 62
    7616:	08 96       	adiw	r24, 0x08	; 8
    7618:	0f b6       	in	r0, 0x3f	; 63
    761a:	f8 94       	cli
    761c:	9e bf       	out	0x3e, r25	; 62
    761e:	0f be       	out	0x3f, r0	; 63
    7620:	8d bf       	out	0x3d, r24	; 61
    7622:	ce 01       	movw	r24, r28
    7624:	8b 55       	subi	r24, 0x5B	; 91
    7626:	9f 4f       	sbci	r25, 0xFF	; 255
    7628:	6c ee       	ldi	r22, 0xEC	; 236
    762a:	73 e0       	ldi	r23, 0x03	; 3
    762c:	46 ed       	ldi	r20, 0xD6	; 214
    762e:	51 e0       	ldi	r21, 0x01	; 1
    7630:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    7634:	84 e0       	ldi	r24, 0x04	; 4
    7636:	6c ee       	ldi	r22, 0xEC	; 236
    7638:	73 e0       	ldi	r23, 0x03	; 3
    763a:	41 e0       	ldi	r20, 0x01	; 1
    763c:	26 ed       	ldi	r18, 0xD6	; 214
    763e:	31 e0       	ldi	r19, 0x01	; 1
    7640:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7644:	8b e0       	ldi	r24, 0x0B	; 11
    7646:	6c ee       	ldi	r22, 0xEC	; 236
    7648:	73 e0       	ldi	r23, 0x03	; 3
    764a:	4a e2       	ldi	r20, 0x2A	; 42
    764c:	26 ed       	ldi	r18, 0xD6	; 214
    764e:	31 e0       	ldi	r19, 0x01	; 1
    7650:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7654:	86 e0       	ldi	r24, 0x06	; 6
    7656:	6c ee       	ldi	r22, 0xEC	; 236
    7658:	73 e0       	ldi	r23, 0x03	; 3
    765a:	41 e0       	ldi	r20, 0x01	; 1
    765c:	26 ed       	ldi	r18, 0xD6	; 214
    765e:	31 e0       	ldi	r19, 0x01	; 1
    7660:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7664:	8c e0       	ldi	r24, 0x0C	; 12
    7666:	6c ee       	ldi	r22, 0xEC	; 236
    7668:	73 e0       	ldi	r23, 0x03	; 3
    766a:	41 e0       	ldi	r20, 0x01	; 1
    766c:	26 ed       	ldi	r18, 0xD6	; 214
    766e:	31 e0       	ldi	r19, 0x01	; 1
    7670:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7674:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7676:	88 e2       	ldi	r24, 0x28	; 40
    7678:	28 2e       	mov	r2, r24
    767a:	31 2c       	mov	r3, r1
    767c:	2c 0e       	add	r2, r28
    767e:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    7680:	07 e3       	ldi	r16, 0x37	; 55
    7682:	60 2e       	mov	r6, r16
    7684:	71 2c       	mov	r7, r1
    7686:	6c 0e       	add	r6, r28
    7688:	7d 1e       	adc	r7, r29
    768a:	d3 01       	movw	r26, r6
    768c:	1f 96       	adiw	r26, 0x0f	; 15
    768e:	cb 50       	subi	r28, 0x0B	; 11
    7690:	df 4f       	sbci	r29, 0xFF	; 255
    7692:	b9 83       	std	Y+1, r27	; 0x01
    7694:	a8 83       	st	Y, r26
    7696:	c5 5f       	subi	r28, 0xF5	; 245
    7698:	d0 40       	sbci	r29, 0x00	; 0
    769a:	16 e4       	ldi	r17, 0x46	; 70
    769c:	41 2e       	mov	r4, r17
    769e:	51 2c       	mov	r5, r1
    76a0:	4c 0e       	add	r4, r28
    76a2:	5d 1e       	adc	r5, r29
    76a4:	f2 01       	movw	r30, r4
    76a6:	3f 96       	adiw	r30, 0x0f	; 15
    76a8:	c9 50       	subi	r28, 0x09	; 9
    76aa:	df 4f       	sbci	r29, 0xFF	; 255
    76ac:	f9 83       	std	Y+1, r31	; 0x01
    76ae:	e8 83       	st	Y, r30
    76b0:	c7 5f       	subi	r28, 0xF7	; 247
    76b2:	d0 40       	sbci	r29, 0x00	; 0
    76b4:	bd e7       	ldi	r27, 0x7D	; 125
    76b6:	8b 2e       	mov	r8, r27
    76b8:	91 2c       	mov	r9, r1
    76ba:	8c 0e       	add	r8, r28
    76bc:	9d 1e       	adc	r9, r29
    76be:	e3 c1       	rjmp	.+966    	; 0x7a86 <systemGenerateReport+0x1546>
    76c0:	f5 01       	movw	r30, r10
    76c2:	e8 52       	subi	r30, 0x28	; 40
    76c4:	fe 4f       	sbci	r31, 0xFE	; 254
    76c6:	80 81       	ld	r24, Z
    76c8:	80 53       	subi	r24, 0x30	; 48
    76ca:	8a 30       	cpi	r24, 0x0A	; 10
    76cc:	08 f0       	brcs	.+2      	; 0x76d0 <systemGenerateReport+0x1190>
    76ce:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    76d0:	80 93 e5 01 	sts	0x01E5, r24
			  if (xGrade>0){
    76d4:	88 23       	and	r24, r24
    76d6:	09 f4       	brne	.+2      	; 0x76da <systemGenerateReport+0x119a>
    76d8:	d5 c1       	rjmp	.+938    	; 0x7a84 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    76da:	6e e5       	ldi	r22, 0x5E	; 94
    76dc:	77 e0       	ldi	r23, 0x07	; 7
    76de:	0e 94 e1 2b 	call	0x57c2	; 0x57c2 <GetProductName>
    76e2:	e7 ef       	ldi	r30, 0xF7	; 247
    76e4:	f7 e0       	ldi	r31, 0x07	; 7
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    76e6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    76e8:	88 e0       	ldi	r24, 0x08	; 8
    76ea:	eb 30       	cpi	r30, 0x0B	; 11
    76ec:	f8 07       	cpc	r31, r24
    76ee:	d9 f7       	brne	.-10     	; 0x76e6 <systemGenerateReport+0x11a6>
    76f0:	e8 ea       	ldi	r30, 0xA8	; 168
    76f2:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
    76f4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    76f6:	98 e0       	ldi	r25, 0x08	; 8
    76f8:	ec 3b       	cpi	r30, 0xBC	; 188
    76fa:	f9 07       	cpc	r31, r25
    76fc:	d9 f7       	brne	.-10     	; 0x76f4 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    76fe:	81 e0       	ldi	r24, 0x01	; 1
    7700:	80 93 e7 01 	sts	0x01E7, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7704:	a9 e1       	ldi	r26, 0x19	; 25
    7706:	ca 2e       	mov	r12, r26
    7708:	d1 2c       	mov	r13, r1
    770a:	cc 0e       	add	r12, r28
    770c:	dd 1e       	adc	r13, r29
    770e:	e6 c0       	rjmp	.+460    	; 0x78dc <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7710:	ce 01       	movw	r24, r28
    7712:	07 96       	adiw	r24, 0x07	; 7
    7714:	65 e4       	ldi	r22, 0x45	; 69
    7716:	70 e0       	ldi	r23, 0x00	; 0
    7718:	48 e0       	ldi	r20, 0x08	; 8
    771a:	50 e0       	ldi	r21, 0x00	; 0
    771c:	24 e4       	ldi	r18, 0x44	; 68
    771e:	32 e1       	ldi	r19, 0x12	; 18
    7720:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    7724:	80 91 e7 01 	lds	r24, 0x01E7
    7728:	fe 01       	movw	r30, r28
    772a:	e8 0f       	add	r30, r24
    772c:	f1 1d       	adc	r31, r1
    772e:	86 81       	ldd	r24, Z+6	; 0x06
    7730:	80 93 e4 01 	sts	0x01E4, r24
					  if (PumpNum>0){
    7734:	88 23       	and	r24, r24
    7736:	09 f4       	brne	.+2      	; 0x773a <systemGenerateReport+0x11fa>
    7738:	cc c0       	rjmp	.+408    	; 0x78d2 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    773a:	81 e0       	ldi	r24, 0x01	; 1
    773c:	c3 c0       	rjmp	.+390    	; 0x78c4 <systemGenerateReport+0x1384>
    773e:	60 91 e7 01 	lds	r22, 0x01E7
    7742:	a6 e0       	ldi	r26, 0x06	; 6
    7744:	6a 9f       	mul	r22, r26
    7746:	b0 01       	movw	r22, r0
    7748:	11 24       	eor	r1, r1
    774a:	61 5b       	subi	r22, 0xB1	; 177
    774c:	7f 4f       	sbci	r23, 0xFF	; 255
    774e:	ce 01       	movw	r24, r28
    7750:	01 96       	adiw	r24, 0x01	; 1
    7752:	46 e0       	ldi	r20, 0x06	; 6
    7754:	50 e0       	ldi	r21, 0x00	; 0
    7756:	24 e4       	ldi	r18, 0x44	; 68
    7758:	32 e1       	ldi	r19, 0x12	; 18
    775a:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    775e:	80 91 e6 01 	lds	r24, 0x01E6
    7762:	fe 01       	movw	r30, r28
    7764:	e8 0f       	add	r30, r24
    7766:	f1 1d       	adc	r31, r1
    7768:	90 81       	ld	r25, Z
    776a:	80 91 e5 01 	lds	r24, 0x01E5
    776e:	98 17       	cp	r25, r24
    7770:	09 f0       	breq	.+2      	; 0x7774 <systemGenerateReport+0x1234>
    7772:	a5 c0       	rjmp	.+330    	; 0x78be <systemGenerateReport+0x137e>
    7774:	ed e2       	ldi	r30, 0x2D	; 45
    7776:	fc e0       	ldi	r31, 0x0C	; 12
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7778:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    777a:	bc e0       	ldi	r27, 0x0C	; 12
    777c:	ec 33       	cpi	r30, 0x3C	; 60
    777e:	fb 07       	cpc	r31, r27
    7780:	d9 f7       	brne	.-10     	; 0x7778 <systemGenerateReport+0x1238>
    7782:	e5 e0       	ldi	r30, 0x05	; 5
    7784:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    7786:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7788:	89 e0       	ldi	r24, 0x09	; 9
    778a:	e4 31       	cpi	r30, 0x14	; 20
    778c:	f8 07       	cpc	r31, r24
    778e:	d9 f7       	brne	.-10     	; 0x7786 <systemGenerateReport+0x1246>
    7790:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    7792:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7794:	e2 15       	cp	r30, r2
    7796:	f3 05       	cpc	r31, r3
    7798:	e1 f7       	brne	.-8      	; 0x7792 <systemGenerateReport+0x1252>
    779a:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    779c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    779e:	e6 15       	cp	r30, r6
    77a0:	f7 05       	cpc	r31, r7
    77a2:	e1 f7       	brne	.-8      	; 0x779c <systemGenerateReport+0x125c>
    77a4:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    77a6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    77a8:	cb 50       	subi	r28, 0x0B	; 11
    77aa:	df 4f       	sbci	r29, 0xFF	; 255
    77ac:	a8 81       	ld	r26, Y
    77ae:	b9 81       	ldd	r27, Y+1	; 0x01
    77b0:	c5 5f       	subi	r28, 0xF5	; 245
    77b2:	d0 40       	sbci	r29, 0x00	; 0
    77b4:	ea 17       	cp	r30, r26
    77b6:	fb 07       	cpc	r31, r27
    77b8:	b1 f7       	brne	.-20     	; 0x77a6 <systemGenerateReport+0x1266>
    77ba:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    77bc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    77be:	c9 50       	subi	r28, 0x09	; 9
    77c0:	df 4f       	sbci	r29, 0xFF	; 255
    77c2:	88 81       	ld	r24, Y
    77c4:	99 81       	ldd	r25, Y+1	; 0x01
    77c6:	c7 5f       	subi	r28, 0xF7	; 247
    77c8:	d0 40       	sbci	r29, 0x00	; 0
    77ca:	e8 17       	cp	r30, r24
    77cc:	f9 07       	cpc	r31, r25
    77ce:	b1 f7       	brne	.-20     	; 0x77bc <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    77d0:	80 91 e6 01 	lds	r24, 0x01E6
    77d4:	80 93 e3 01 	sts	0x01E3, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    77d8:	80 91 e4 01 	lds	r24, 0x01E4
    77dc:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
								  if (FIPAddr>0){
    77e0:	88 23       	and	r24, r24
    77e2:	11 f1       	breq	.+68     	; 0x7828 <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    77e4:	f8 2e       	mov	r15, r24
    77e6:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    77e8:	80 e0       	ldi	r24, 0x00	; 0
    77ea:	60 e0       	ldi	r22, 0x00	; 0
    77ec:	4f 2d       	mov	r20, r15
    77ee:	20 91 e3 01 	lds	r18, 0x01E3
    77f2:	86 01       	movw	r16, r12
    77f4:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    77f8:	81 e0       	ldi	r24, 0x01	; 1
    77fa:	60 e0       	ldi	r22, 0x00	; 0
    77fc:	4f 2d       	mov	r20, r15
    77fe:	20 91 e3 01 	lds	r18, 0x01E3
    7802:	81 01       	movw	r16, r2
    7804:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    7808:	80 e0       	ldi	r24, 0x00	; 0
    780a:	61 e0       	ldi	r22, 0x01	; 1
    780c:	4f 2d       	mov	r20, r15
    780e:	20 91 e3 01 	lds	r18, 0x01E3
    7812:	83 01       	movw	r16, r6
    7814:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    7818:	81 e0       	ldi	r24, 0x01	; 1
    781a:	61 e0       	ldi	r22, 0x01	; 1
    781c:	4f 2d       	mov	r20, r15
    781e:	20 91 e3 01 	lds	r18, 0x01E3
    7822:	82 01       	movw	r16, r4
    7824:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    7828:	80 e0       	ldi	r24, 0x00	; 0
    782a:	b3 01       	movw	r22, r6
    782c:	a6 01       	movw	r20, r12
    782e:	25 e0       	ldi	r18, 0x05	; 5
    7830:	39 e0       	ldi	r19, 0x09	; 9
    7832:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    7836:	85 e0       	ldi	r24, 0x05	; 5
    7838:	99 e0       	ldi	r25, 0x09	; 9
    783a:	0e 94 74 21 	call	0x42e8	; 0x42e8 <IsMinus>
    783e:	81 30       	cpi	r24, 0x01	; 1
    7840:	21 f4       	brne	.+8      	; 0x784a <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    7842:	85 e0       	ldi	r24, 0x05	; 5
    7844:	99 e0       	ldi	r25, 0x09	; 9
    7846:	0e 94 10 2b 	call	0x5620	; 0x5620 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    784a:	e1 99       	sbic	0x1c, 1	; 28
    784c:	fe cf       	rjmp	.-4      	; 0x784a <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    784e:	a7 e3       	ldi	r26, 0x37	; 55
    7850:	b1 e0       	ldi	r27, 0x01	; 1
    7852:	bf bb       	out	0x1f, r27	; 31
    7854:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7856:	e0 9a       	sbi	0x1c, 0	; 28
    7858:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    785a:	82 30       	cpi	r24, 0x02	; 2
    785c:	79 f4       	brne	.+30     	; 0x787c <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    785e:	ce 01       	movw	r24, r28
    7860:	0f 96       	adiw	r24, 0x0f	; 15
    7862:	60 91 e4 01 	lds	r22, 0x01E4
    7866:	40 91 e3 01 	lds	r20, 0x01E3
    786a:	0e 94 57 22 	call	0x44ae	; 0x44ae <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    786e:	82 e0       	ldi	r24, 0x02	; 2
    7870:	be 01       	movw	r22, r28
    7872:	61 5f       	subi	r22, 0xF1	; 241
    7874:	7f 4f       	sbci	r23, 0xFF	; 255
    7876:	45 e0       	ldi	r20, 0x05	; 5
    7878:	59 e0       	ldi	r21, 0x09	; 9
    787a:	03 c0       	rjmp	.+6      	; 0x7882 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    787c:	80 e0       	ldi	r24, 0x00	; 0
    787e:	b2 01       	movw	r22, r4
    7880:	a1 01       	movw	r20, r2
    7882:	2d e2       	ldi	r18, 0x2D	; 45
    7884:	3c e0       	ldi	r19, 0x0C	; 12
    7886:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    788a:	8d e2       	ldi	r24, 0x2D	; 45
    788c:	9c e0       	ldi	r25, 0x0C	; 12
    788e:	0e 94 74 21 	call	0x42e8	; 0x42e8 <IsMinus>
    7892:	81 30       	cpi	r24, 0x01	; 1
    7894:	21 f4       	brne	.+8      	; 0x789e <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    7896:	8d e2       	ldi	r24, 0x2D	; 45
    7898:	9c e0       	ldi	r25, 0x0C	; 12
    789a:	0e 94 10 2b 	call	0x5620	; 0x5620 <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    789e:	81 e0       	ldi	r24, 0x01	; 1
    78a0:	67 ef       	ldi	r22, 0xF7	; 247
    78a2:	77 e0       	ldi	r23, 0x07	; 7
    78a4:	45 e0       	ldi	r20, 0x05	; 5
    78a6:	59 e0       	ldi	r21, 0x09	; 9
    78a8:	9b 01       	movw	r18, r22
    78aa:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    78ae:	81 e0       	ldi	r24, 0x01	; 1
    78b0:	68 ea       	ldi	r22, 0xA8	; 168
    78b2:	78 e0       	ldi	r23, 0x08	; 8
    78b4:	4d e2       	ldi	r20, 0x2D	; 45
    78b6:	5c e0       	ldi	r21, 0x0C	; 12
    78b8:	9b 01       	movw	r18, r22
    78ba:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    78be:	80 91 e6 01 	lds	r24, 0x01E6
    78c2:	8f 5f       	subi	r24, 0xFF	; 255
    78c4:	80 93 e6 01 	sts	0x01E6, r24
    78c8:	80 91 e6 01 	lds	r24, 0x01E6
    78cc:	87 30       	cpi	r24, 0x07	; 7
    78ce:	08 f4       	brcc	.+2      	; 0x78d2 <systemGenerateReport+0x1392>
    78d0:	36 cf       	rjmp	.-404    	; 0x773e <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    78d2:	80 91 e7 01 	lds	r24, 0x01E7
    78d6:	8f 5f       	subi	r24, 0xFF	; 255
    78d8:	80 93 e7 01 	sts	0x01E7, r24
    78dc:	80 91 e7 01 	lds	r24, 0x01E7
    78e0:	89 30       	cpi	r24, 0x09	; 9
    78e2:	08 f4       	brcc	.+2      	; 0x78e6 <systemGenerateReport+0x13a6>
    78e4:	15 cf       	rjmp	.-470    	; 0x7710 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    78e6:	88 ea       	ldi	r24, 0xA8	; 168
    78e8:	98 e0       	ldi	r25, 0x08	; 8
    78ea:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    78ee:	07 ef       	ldi	r16, 0xF7	; 247
    78f0:	17 e0       	ldi	r17, 0x07	; 7
    78f2:	c8 01       	movw	r24, r16
    78f4:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    78f8:	88 ea       	ldi	r24, 0xA8	; 168
    78fa:	98 e0       	ldi	r25, 0x08	; 8
    78fc:	0e 94 6c 32 	call	0x64d8	; 0x64d8 <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    7900:	88 ea       	ldi	r24, 0xA8	; 168
    7902:	98 e0       	ldi	r25, 0x08	; 8
    7904:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    7908:	c8 01       	movw	r24, r16
    790a:	0e 94 5f 32 	call	0x64be	; 0x64be <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    790e:	c8 01       	movw	r24, r16
    7910:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    7914:	ee e5       	ldi	r30, 0x5E	; 94
    7916:	f7 e0       	ldi	r31, 0x07	; 7
    7918:	01 90       	ld	r0, Z+
    791a:	00 20       	and	r0, r0
    791c:	e9 f7       	brne	.-6      	; 0x7918 <systemGenerateReport+0x13d8>
    791e:	31 97       	sbiw	r30, 0x01	; 1
    7920:	ee 55       	subi	r30, 0x5E	; 94
    7922:	f7 40       	sbci	r31, 0x07	; 7
    7924:	d8 01       	movw	r26, r16
    7926:	0d 90       	ld	r0, X+
    7928:	00 20       	and	r0, r0
    792a:	e9 f7       	brne	.-6      	; 0x7926 <systemGenerateReport+0x13e6>
    792c:	8d 01       	movw	r16, r26
    792e:	01 50       	subi	r16, 0x01	; 1
    7930:	10 40       	sbci	r17, 0x00	; 0
    7932:	07 5f       	subi	r16, 0xF7	; 247
    7934:	17 40       	sbci	r17, 0x07	; 7
    7936:	8e 2f       	mov	r24, r30
    7938:	81 95       	neg	r24
    793a:	80 1b       	sub	r24, r16
    793c:	8b 5e       	subi	r24, 0xEB	; 235
    793e:	de 01       	movw	r26, r28
    7940:	a7 59       	subi	r26, 0x97	; 151
    7942:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7944:	18 16       	cp	r1, r24
    7946:	7c f4       	brge	.+30     	; 0x7966 <systemGenerateReport+0x1426>
    7948:	fd 01       	movw	r30, r26
    794a:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    794c:	20 e2       	ldi	r18, 0x20	; 32
    794e:	02 c0       	rjmp	.+4      	; 0x7954 <systemGenerateReport+0x1414>
    7950:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7952:	9f 5f       	subi	r25, 0xFF	; 255
    7954:	98 17       	cp	r25, r24
    7956:	e0 f3       	brcs	.-8      	; 0x7950 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7958:	fe 01       	movw	r30, r28
    795a:	e7 59       	subi	r30, 0x97	; 151
    795c:	ff 4f       	sbci	r31, 0xFF	; 255
    795e:	e8 0f       	add	r30, r24
    7960:	f1 1d       	adc	r31, r1
    7962:	10 82       	st	Z, r1
    7964:	04 c0       	rjmp	.+8      	; 0x796e <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    7966:	80 e2       	ldi	r24, 0x20	; 32
    7968:	8c 93       	st	X, r24
	 strTab[1]=0;
    796a:	11 96       	adiw	r26, 0x01	; 1
    796c:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    796e:	e8 ea       	ldi	r30, 0xA8	; 168
    7970:	f8 e0       	ldi	r31, 0x08	; 8
    7972:	01 90       	ld	r0, Z+
    7974:	00 20       	and	r0, r0
    7976:	e9 f7       	brne	.-6      	; 0x7972 <systemGenerateReport+0x1432>
    7978:	31 97       	sbiw	r30, 0x01	; 1
    797a:	e8 5a       	subi	r30, 0xA8	; 168
    797c:	f8 40       	sbci	r31, 0x08	; 8
    797e:	9f e0       	ldi	r25, 0x0F	; 15
    7980:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7982:	19 16       	cp	r1, r25
    7984:	6c f4       	brge	.+26     	; 0x79a0 <systemGenerateReport+0x1460>
    7986:	f4 01       	movw	r30, r8
    7988:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    798a:	20 e2       	ldi	r18, 0x20	; 32
    798c:	02 c0       	rjmp	.+4      	; 0x7992 <systemGenerateReport+0x1452>
    798e:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7990:	8f 5f       	subi	r24, 0xFF	; 255
    7992:	89 17       	cp	r24, r25
    7994:	e0 f3       	brcs	.-8      	; 0x798e <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7996:	f4 01       	movw	r30, r8
    7998:	e9 0f       	add	r30, r25
    799a:	f1 1d       	adc	r31, r1
    799c:	10 82       	st	Z, r1
    799e:	04 c0       	rjmp	.+8      	; 0x79a8 <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    79a0:	80 e2       	ldi	r24, 0x20	; 32
    79a2:	f4 01       	movw	r30, r8
    79a4:	80 83       	st	Z, r24
	 strTab[1]=0;
    79a6:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    79a8:	e1 99       	sbic	0x1c, 1	; 28
    79aa:	fe cf       	rjmp	.-4      	; 0x79a8 <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    79ac:	81 ec       	ldi	r24, 0xC1	; 193
    79ae:	93 e0       	ldi	r25, 0x03	; 3
    79b0:	9f bb       	out	0x1f, r25	; 31
    79b2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    79b4:	e0 9a       	sbi	0x1c, 0	; 28
    79b6:	8d b3       	in	r24, 0x1d	; 29
    79b8:	9e 01       	movw	r18, r28
    79ba:	2b 55       	subi	r18, 0x5B	; 91
    79bc:	3f 4f       	sbci	r19, 0xFF	; 255
    79be:	47 ef       	ldi	r20, 0xF7	; 247
    79c0:	57 e0       	ldi	r21, 0x07	; 7
    79c2:	fe e5       	ldi	r31, 0x5E	; 94
    79c4:	cf 2e       	mov	r12, r31
    79c6:	f7 e0       	ldi	r31, 0x07	; 7
    79c8:	df 2e       	mov	r13, r31
    79ca:	de 01       	movw	r26, r28
    79cc:	a7 59       	subi	r26, 0x97	; 151
    79ce:	bf 4f       	sbci	r27, 0xFF	; 255
    79d0:	b5 01       	movw	r22, r10
    79d2:	6f 5f       	subi	r22, 0xFF	; 255
    79d4:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    79d6:	81 30       	cpi	r24, 0x01	; 1
    79d8:	39 f5       	brne	.+78     	; 0x7a28 <systemGenerateReport+0x14e8>
    79da:	ed b7       	in	r30, 0x3d	; 61
    79dc:	fe b7       	in	r31, 0x3e	; 62
    79de:	70 97       	sbiw	r30, 0x10	; 16
    79e0:	0f b6       	in	r0, 0x3f	; 63
    79e2:	f8 94       	cli
    79e4:	fe bf       	out	0x3e, r31	; 62
    79e6:	0f be       	out	0x3f, r0	; 63
    79e8:	ed bf       	out	0x3d, r30	; 61
    79ea:	0d b7       	in	r16, 0x3d	; 61
    79ec:	1e b7       	in	r17, 0x3e	; 62
    79ee:	0f 5f       	subi	r16, 0xFF	; 255
    79f0:	1f 4f       	sbci	r17, 0xFF	; 255
    79f2:	32 83       	std	Z+2, r19	; 0x02
    79f4:	21 83       	std	Z+1, r18	; 0x01
    79f6:	8c e5       	ldi	r24, 0x5C	; 92
    79f8:	93 e0       	ldi	r25, 0x03	; 3
    79fa:	f8 01       	movw	r30, r16
    79fc:	93 83       	std	Z+3, r25	; 0x03
    79fe:	82 83       	std	Z+2, r24	; 0x02
    7a00:	75 83       	std	Z+5, r23	; 0x05
    7a02:	64 83       	std	Z+4, r22	; 0x04
    7a04:	d7 82       	std	Z+7, r13	; 0x07
    7a06:	c6 82       	std	Z+6, r12	; 0x06
    7a08:	b1 87       	std	Z+9, r27	; 0x09
    7a0a:	a0 87       	std	Z+8, r26	; 0x08
    7a0c:	53 87       	std	Z+11, r21	; 0x0b
    7a0e:	42 87       	std	Z+10, r20	; 0x0a
    7a10:	95 86       	std	Z+13, r9	; 0x0d
    7a12:	84 86       	std	Z+12, r8	; 0x0c
    7a14:	88 ea       	ldi	r24, 0xA8	; 168
    7a16:	98 e0       	ldi	r25, 0x08	; 8
    7a18:	97 87       	std	Z+15, r25	; 0x0f
    7a1a:	86 87       	std	Z+14, r24	; 0x0e
    7a1c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    7a20:	8d b7       	in	r24, 0x3d	; 61
    7a22:	9e b7       	in	r25, 0x3e	; 62
    7a24:	40 96       	adiw	r24, 0x10	; 16
    7a26:	20 c0       	rjmp	.+64     	; 0x7a68 <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    7a28:	ed b7       	in	r30, 0x3d	; 61
    7a2a:	fe b7       	in	r31, 0x3e	; 62
    7a2c:	3c 97       	sbiw	r30, 0x0c	; 12
    7a2e:	0f b6       	in	r0, 0x3f	; 63
    7a30:	f8 94       	cli
    7a32:	fe bf       	out	0x3e, r31	; 62
    7a34:	0f be       	out	0x3f, r0	; 63
    7a36:	ed bf       	out	0x3d, r30	; 61
    7a38:	0d b7       	in	r16, 0x3d	; 61
    7a3a:	1e b7       	in	r17, 0x3e	; 62
    7a3c:	0f 5f       	subi	r16, 0xFF	; 255
    7a3e:	1f 4f       	sbci	r17, 0xFF	; 255
    7a40:	32 83       	std	Z+2, r19	; 0x02
    7a42:	21 83       	std	Z+1, r18	; 0x01
    7a44:	82 e5       	ldi	r24, 0x52	; 82
    7a46:	93 e0       	ldi	r25, 0x03	; 3
    7a48:	f8 01       	movw	r30, r16
    7a4a:	93 83       	std	Z+3, r25	; 0x03
    7a4c:	82 83       	std	Z+2, r24	; 0x02
    7a4e:	75 83       	std	Z+5, r23	; 0x05
    7a50:	64 83       	std	Z+4, r22	; 0x04
    7a52:	d7 82       	std	Z+7, r13	; 0x07
    7a54:	c6 82       	std	Z+6, r12	; 0x06
    7a56:	b1 87       	std	Z+9, r27	; 0x09
    7a58:	a0 87       	std	Z+8, r26	; 0x08
    7a5a:	53 87       	std	Z+11, r21	; 0x0b
    7a5c:	42 87       	std	Z+10, r20	; 0x0a
    7a5e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    7a62:	8d b7       	in	r24, 0x3d	; 61
    7a64:	9e b7       	in	r25, 0x3e	; 62
    7a66:	0c 96       	adiw	r24, 0x0c	; 12
    7a68:	0f b6       	in	r0, 0x3f	; 63
    7a6a:	f8 94       	cli
    7a6c:	9e bf       	out	0x3e, r25	; 62
    7a6e:	0f be       	out	0x3f, r0	; 63
    7a70:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    7a72:	ce 01       	movw	r24, r28
    7a74:	8b 55       	subi	r24, 0x5B	; 91
    7a76:	9f 4f       	sbci	r25, 0xFF	; 255
    7a78:	6c ee       	ldi	r22, 0xEC	; 236
    7a7a:	73 e0       	ldi	r23, 0x03	; 3
    7a7c:	46 ed       	ldi	r20, 0xD6	; 214
    7a7e:	51 e0       	ldi	r21, 0x01	; 1
    7a80:	0e 94 0f 20 	call	0x401e	; 0x401e <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    7a84:	e3 94       	inc	r14
    7a86:	e8 ed       	ldi	r30, 0xD8	; 216
    7a88:	f1 e0       	ldi	r31, 0x01	; 1
    7a8a:	01 90       	ld	r0, Z+
    7a8c:	00 20       	and	r0, r0
    7a8e:	e9 f7       	brne	.-6      	; 0x7a8a <systemGenerateReport+0x154a>
    7a90:	31 97       	sbiw	r30, 0x01	; 1
    7a92:	e8 5d       	subi	r30, 0xD8	; 216
    7a94:	f1 40       	sbci	r31, 0x01	; 1
    7a96:	ae 2c       	mov	r10, r14
    7a98:	bb 24       	eor	r11, r11
    7a9a:	ae 16       	cp	r10, r30
    7a9c:	bf 06       	cpc	r11, r31
    7a9e:	08 f4       	brcc	.+2      	; 0x7aa2 <systemGenerateReport+0x1562>
    7aa0:	0f ce       	rjmp	.-994    	; 0x76c0 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7aa2:	87 e0       	ldi	r24, 0x07	; 7
    7aa4:	6c ee       	ldi	r22, 0xEC	; 236
    7aa6:	73 e0       	ldi	r23, 0x03	; 3
    7aa8:	41 e0       	ldi	r20, 0x01	; 1
    7aaa:	26 ed       	ldi	r18, 0xD6	; 214
    7aac:	31 e0       	ldi	r19, 0x01	; 1
    7aae:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7ab2:	8b e0       	ldi	r24, 0x0B	; 11
    7ab4:	6c ee       	ldi	r22, 0xEC	; 236
    7ab6:	73 e0       	ldi	r23, 0x03	; 3
    7ab8:	4a e2       	ldi	r20, 0x2A	; 42
    7aba:	26 ed       	ldi	r18, 0xD6	; 214
    7abc:	31 e0       	ldi	r19, 0x01	; 1
    7abe:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7ac2:	89 e0       	ldi	r24, 0x09	; 9
    7ac4:	6c ee       	ldi	r22, 0xEC	; 236
    7ac6:	73 e0       	ldi	r23, 0x03	; 3
    7ac8:	41 e0       	ldi	r20, 0x01	; 1
    7aca:	26 ed       	ldi	r18, 0xD6	; 214
    7acc:	31 e0       	ldi	r19, 0x01	; 1
    7ace:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7ad2:	8c e0       	ldi	r24, 0x0C	; 12
    7ad4:	6c ee       	ldi	r22, 0xEC	; 236
    7ad6:	73 e0       	ldi	r23, 0x03	; 3
    7ad8:	41 e0       	ldi	r20, 0x01	; 1
    7ada:	26 ed       	ldi	r18, 0xD6	; 214
    7adc:	31 e0       	ldi	r19, 0x01	; 1
    7ade:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7ae2:	8c e0       	ldi	r24, 0x0C	; 12
    7ae4:	6c ee       	ldi	r22, 0xEC	; 236
    7ae6:	73 e0       	ldi	r23, 0x03	; 3
    7ae8:	41 e0       	ldi	r20, 0x01	; 1
    7aea:	26 ed       	ldi	r18, 0xD6	; 214
    7aec:	31 e0       	ldi	r19, 0x01	; 1
    7aee:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7af2:	8c e0       	ldi	r24, 0x0C	; 12
    7af4:	6c ee       	ldi	r22, 0xEC	; 236
    7af6:	73 e0       	ldi	r23, 0x03	; 3
    7af8:	41 e0       	ldi	r20, 0x01	; 1
    7afa:	26 ed       	ldi	r18, 0xD6	; 214
    7afc:	31 e0       	ldi	r19, 0x01	; 1
    7afe:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7b02:	8c e0       	ldi	r24, 0x0C	; 12
    7b04:	6c ee       	ldi	r22, 0xEC	; 236
    7b06:	73 e0       	ldi	r23, 0x03	; 3
    7b08:	41 e0       	ldi	r20, 0x01	; 1
    7b0a:	26 ed       	ldi	r18, 0xD6	; 214
    7b0c:	31 e0       	ldi	r19, 0x01	; 1
    7b0e:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7b12:	8c e0       	ldi	r24, 0x0C	; 12
    7b14:	6c ee       	ldi	r22, 0xEC	; 236
    7b16:	73 e0       	ldi	r23, 0x03	; 3
    7b18:	41 e0       	ldi	r20, 0x01	; 1
    7b1a:	26 ed       	ldi	r18, 0xD6	; 214
    7b1c:	31 e0       	ldi	r19, 0x01	; 1
    7b1e:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>
    7b22:	8c e0       	ldi	r24, 0x0C	; 12
    7b24:	6c ee       	ldi	r22, 0xEC	; 236
    7b26:	73 e0       	ldi	r23, 0x03	; 3
    7b28:	41 e0       	ldi	r20, 0x01	; 1
    7b2a:	26 ed       	ldi	r18, 0xD6	; 214
    7b2c:	31 e0       	ldi	r19, 0x01	; 1
    7b2e:	0e 94 2b 19 	call	0x3256	; 0x3256 <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    7b32:	80 e3       	ldi	r24, 0x30	; 48
    7b34:	80 93 b5 01 	sts	0x01B5, r24
		  LengthMessage81=RepPos+1;
    7b38:	80 91 d6 01 	lds	r24, 0x01D6
    7b3c:	90 91 d7 01 	lds	r25, 0x01D7
    7b40:	01 96       	adiw	r24, 0x01	; 1
    7b42:	90 93 8e 01 	sts	0x018E, r25
    7b46:	80 93 8d 01 	sts	0x018D, r24
		  IsFreePrinting=True;
    7b4a:	81 e0       	ldi	r24, 0x01	; 1
    7b4c:	80 93 a8 01 	sts	0x01A8, r24
	      IsBusyFreePrinting=True; 
    7b50:	80 93 b4 01 	sts	0x01B4, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    7b54:	8b e0       	ldi	r24, 0x0B	; 11
    7b56:	05 c0       	rjmp	.+10     	; 0x7b62 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    7b58:	80 91 b4 01 	lds	r24, 0x01B4
    7b5c:	88 23       	and	r24, r24
    7b5e:	49 f4       	brne	.+18     	; 0x7b72 <systemGenerateReport+0x1632>
    7b60:	8c e0       	ldi	r24, 0x0C	; 12
    7b62:	80 93 e8 01 	sts	0x01E8, r24
    7b66:	05 c0       	rjmp	.+10     	; 0x7b72 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    7b68:	81 e0       	ldi	r24, 0x01	; 1
    7b6a:	80 93 87 01 	sts	0x0187, r24
          stGenerateReport=grScanAction;
    7b6e:	10 92 e8 01 	sts	0x01E8, r1
	      break;
	 }
}
    7b72:	c8 50       	subi	r28, 0x08	; 8
    7b74:	df 4f       	sbci	r29, 0xFF	; 255
    7b76:	0f b6       	in	r0, 0x3f	; 63
    7b78:	f8 94       	cli
    7b7a:	de bf       	out	0x3e, r29	; 62
    7b7c:	0f be       	out	0x3f, r0	; 63
    7b7e:	cd bf       	out	0x3d, r28	; 61
    7b80:	cf 91       	pop	r28
    7b82:	df 91       	pop	r29
    7b84:	1f 91       	pop	r17
    7b86:	0f 91       	pop	r16
    7b88:	ff 90       	pop	r15
    7b8a:	ef 90       	pop	r14
    7b8c:	df 90       	pop	r13
    7b8e:	cf 90       	pop	r12
    7b90:	bf 90       	pop	r11
    7b92:	af 90       	pop	r10
    7b94:	9f 90       	pop	r9
    7b96:	8f 90       	pop	r8
    7b98:	7f 90       	pop	r7
    7b9a:	6f 90       	pop	r6
    7b9c:	5f 90       	pop	r5
    7b9e:	4f 90       	pop	r4
    7ba0:	3f 90       	pop	r3
    7ba2:	2f 90       	pop	r2
    7ba4:	08 95       	ret

00007ba6 <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 

void UpdateCardID(){
    7ba6:	cf 93       	push	r28
    7ba8:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    7baa:	e1 e5       	ldi	r30, 0x51	; 81
    7bac:	fc e0       	ldi	r31, 0x0C	; 12
    7bae:	01 90       	ld	r0, Z+
    7bb0:	00 20       	and	r0, r0
    7bb2:	e9 f7       	brne	.-6      	; 0x7bae <UpdateCardID+0x8>
    7bb4:	31 97       	sbiw	r30, 0x01	; 1
    7bb6:	e1 55       	subi	r30, 0x51	; 81
    7bb8:	fc 40       	sbci	r31, 0x0C	; 12
    7bba:	a9 e8       	ldi	r26, 0x89	; 137
    7bbc:	bb e0       	ldi	r27, 0x0B	; 11
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
	 */
} 

void UpdateCardID(){
    7bbe:	f0 e0       	ldi	r31, 0x00	; 0
    7bc0:	ef 01       	movw	r28, r30
    7bc2:	c3 5c       	subi	r28, 0xC3	; 195
    7bc4:	d3 4f       	sbci	r29, 0xF3	; 243
    7bc6:	20 e0       	ldi	r18, 0x00	; 0
    7bc8:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    7bca:	44 e1       	ldi	r20, 0x14	; 20
    7bcc:	50 e0       	ldi	r21, 0x00	; 0
    7bce:	4e 1b       	sub	r20, r30
    7bd0:	5f 0b       	sbc	r21, r31
    7bd2:	90 e2       	ldi	r25, 0x20	; 32
    7bd4:	24 17       	cp	r18, r20
    7bd6:	35 07       	cpc	r19, r21
    7bd8:	14 f4       	brge	.+4      	; 0x7bde <UpdateCardID+0x38>
    7bda:	9c 93       	st	X, r25
    7bdc:	02 c0       	rjmp	.+4      	; 0x7be2 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    7bde:	88 81       	ld	r24, Y
    7be0:	8c 93       	st	X, r24
    7be2:	2f 5f       	subi	r18, 0xFF	; 255
    7be4:	3f 4f       	sbci	r19, 0xFF	; 255
    7be6:	11 96       	adiw	r26, 0x01	; 1
    7be8:	21 96       	adiw	r28, 0x01	; 1
} 

void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    7bea:	24 31       	cpi	r18, 0x14	; 20
    7bec:	31 05       	cpc	r19, r1
    7bee:	91 f7       	brne	.-28     	; 0x7bd4 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    7bf0:	10 92 9d 0b 	sts	0x0B9D, r1

}
    7bf4:	df 91       	pop	r29
    7bf6:	cf 91       	pop	r28
    7bf8:	08 95       	ret

00007bfa <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    7bfa:	cf 92       	push	r12
    7bfc:	df 92       	push	r13
    7bfe:	ef 92       	push	r14
    7c00:	ff 92       	push	r15
    7c02:	0f 93       	push	r16
    7c04:	1f 93       	push	r17
    7c06:	df 93       	push	r29
    7c08:	cf 93       	push	r28
    7c0a:	cd b7       	in	r28, 0x3d	; 61
    7c0c:	de b7       	in	r29, 0x3e	; 62
    7c0e:	27 97       	sbiw	r28, 0x07	; 7
    7c10:	0f b6       	in	r0, 0x3f	; 63
    7c12:	f8 94       	cli
    7c14:	de bf       	out	0x3e, r29	; 62
    7c16:	0f be       	out	0x3f, r0	; 63
    7c18:	cd bf       	out	0x3d, r28	; 61
    7c1a:	6c 01       	movw	r12, r24
    7c1c:	fe 01       	movw	r30, r28
    7c1e:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c20:	ce 01       	movw	r24, r28
    7c22:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    7c24:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c26:	e8 17       	cp	r30, r24
    7c28:	f9 07       	cpc	r31, r25
    7c2a:	e1 f7       	brne	.-8      	; 0x7c24 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7c2c:	8e 01       	movw	r16, r28
    7c2e:	0f 5f       	subi	r16, 0xFF	; 255
    7c30:	1f 4f       	sbci	r17, 0xFF	; 255
    7c32:	c8 01       	movw	r24, r16
    7c34:	68 e3       	ldi	r22, 0x38	; 56
    7c36:	71 e0       	ldi	r23, 0x01	; 1
    7c38:	47 e0       	ldi	r20, 0x07	; 7
    7c3a:	50 e0       	ldi	r21, 0x00	; 0
    7c3c:	24 e4       	ldi	r18, 0x44	; 68
    7c3e:	32 e1       	ldi	r19, 0x12	; 18
    7c40:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    7c44:	f8 01       	movw	r30, r16
    7c46:	01 90       	ld	r0, Z+
    7c48:	00 20       	and	r0, r0
    7c4a:	e9 f7       	brne	.-6      	; 0x7c46 <GenerateTransactionNum+0x4c>
    7c4c:	31 97       	sbiw	r30, 0x01	; 1
    7c4e:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    7c50:	f0 e0       	ldi	r31, 0x00	; 0
    7c52:	0e 0f       	add	r16, r30
    7c54:	1f 1f       	adc	r17, r31
    7c56:	31 97       	sbiw	r30, 0x01	; 1
    7c58:	76 01       	movw	r14, r12
    7c5a:	ee 0e       	add	r14, r30
    7c5c:	ff 1e       	adc	r15, r31
    7c5e:	31 96       	adiw	r30, 0x01	; 1
    7c60:	61 e0       	ldi	r22, 0x01	; 1
    7c62:	19 c0       	rjmp	.+50     	; 0x7c96 <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    7c64:	d8 01       	movw	r26, r16
    7c66:	2c 91       	ld	r18, X
    7c68:	20 53       	subi	r18, 0x30	; 48
    7c6a:	30 e0       	ldi	r19, 0x00	; 0
    7c6c:	26 0f       	add	r18, r22
    7c6e:	31 1d       	adc	r19, r1
    7c70:	c9 01       	movw	r24, r18
    7c72:	6a e0       	ldi	r22, 0x0A	; 10
    7c74:	70 e0       	ldi	r23, 0x00	; 0
    7c76:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    7c7a:	48 2f       	mov	r20, r24
    7c7c:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    7c7e:	c9 01       	movw	r24, r18
    7c80:	6a e0       	ldi	r22, 0x0A	; 10
    7c82:	70 e0       	ldi	r23, 0x00	; 0
    7c84:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    7c88:	d8 01       	movw	r26, r16
    7c8a:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    7c8c:	d7 01       	movw	r26, r14
    7c8e:	4c 93       	st	X, r20
    7c90:	08 94       	sec
    7c92:	e1 08       	sbc	r14, r1
    7c94:	f1 08       	sbc	r15, r1
    7c96:	01 50       	subi	r16, 0x01	; 1
    7c98:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    7c9a:	0c 17       	cp	r16, r28
    7c9c:	1d 07       	cpc	r17, r29
    7c9e:	11 f7       	brne	.-60     	; 0x7c64 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    7ca0:	ce 0e       	add	r12, r30
    7ca2:	df 1e       	adc	r13, r31
    7ca4:	d6 01       	movw	r26, r12
    7ca6:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    7ca8:	be 01       	movw	r22, r28
    7caa:	6f 5f       	subi	r22, 0xFF	; 255
    7cac:	7f 4f       	sbci	r23, 0xFF	; 255
    7cae:	e6 0f       	add	r30, r22
    7cb0:	f7 1f       	adc	r31, r23
    7cb2:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    7cb4:	88 e3       	ldi	r24, 0x38	; 56
    7cb6:	91 e0       	ldi	r25, 0x01	; 1
    7cb8:	47 e0       	ldi	r20, 0x07	; 7
    7cba:	50 e0       	ldi	r21, 0x00	; 0
    7cbc:	2c e4       	ldi	r18, 0x4C	; 76
    7cbe:	32 e1       	ldi	r19, 0x12	; 18
    7cc0:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    7cc4:	27 96       	adiw	r28, 0x07	; 7
    7cc6:	0f b6       	in	r0, 0x3f	; 63
    7cc8:	f8 94       	cli
    7cca:	de bf       	out	0x3e, r29	; 62
    7ccc:	0f be       	out	0x3f, r0	; 63
    7cce:	cd bf       	out	0x3d, r28	; 61
    7cd0:	cf 91       	pop	r28
    7cd2:	df 91       	pop	r29
    7cd4:	1f 91       	pop	r17
    7cd6:	0f 91       	pop	r16
    7cd8:	ff 90       	pop	r15
    7cda:	ef 90       	pop	r14
    7cdc:	df 90       	pop	r13
    7cde:	cf 90       	pop	r12
    7ce0:	08 95       	ret

00007ce2 <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    7ce2:	8f 92       	push	r8
    7ce4:	9f 92       	push	r9
    7ce6:	af 92       	push	r10
    7ce8:	bf 92       	push	r11
    7cea:	cf 92       	push	r12
    7cec:	df 92       	push	r13
    7cee:	ef 92       	push	r14
    7cf0:	ff 92       	push	r15
    7cf2:	0f 93       	push	r16
    7cf4:	1f 93       	push	r17
    7cf6:	df 93       	push	r29
    7cf8:	cf 93       	push	r28
    7cfa:	cd b7       	in	r28, 0x3d	; 61
    7cfc:	de b7       	in	r29, 0x3e	; 62
    7cfe:	a7 97       	sbiw	r28, 0x27	; 39
    7d00:	0f b6       	in	r0, 0x3f	; 63
    7d02:	f8 94       	cli
    7d04:	de bf       	out	0x3e, r29	; 62
    7d06:	0f be       	out	0x3f, r0	; 63
    7d08:	cd bf       	out	0x3d, r28	; 61
    7d0a:	79 01       	movw	r14, r18
    7d0c:	48 01       	movw	r8, r16
    7d0e:	e6 2f       	mov	r30, r22
    7d10:	f0 e0       	ldi	r31, 0x00	; 0
    7d12:	31 97       	sbiw	r30, 0x01	; 1
    7d14:	e8 0f       	add	r30, r24
    7d16:	f9 1f       	adc	r31, r25
    7d18:	9e 01       	movw	r18, r28
    7d1a:	26 5f       	subi	r18, 0xF6	; 246
    7d1c:	3f 4f       	sbci	r19, 0xFF	; 255
    7d1e:	d9 01       	movw	r26, r18
    7d20:	03 c0       	rjmp	.+6      	; 0x7d28 <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    7d22:	80 81       	ld	r24, Z
    7d24:	8d 93       	st	X+, r24
    7d26:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    7d28:	8a 2f       	mov	r24, r26
    7d2a:	82 1b       	sub	r24, r18
    7d2c:	86 17       	cp	r24, r22
    7d2e:	c8 f3       	brcs	.-14     	; 0x7d22 <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    7d30:	c6 2e       	mov	r12, r22
    7d32:	dd 24       	eor	r13, r13
    7d34:	aa e0       	ldi	r26, 0x0A	; 10
    7d36:	aa 2e       	mov	r10, r26
    7d38:	b1 2c       	mov	r11, r1
    7d3a:	ac 0e       	add	r10, r28
    7d3c:	bd 1e       	adc	r11, r29
    7d3e:	f5 01       	movw	r30, r10
    7d40:	ec 0d       	add	r30, r12
    7d42:	fd 1d       	adc	r31, r13
    7d44:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    7d46:	8a 85       	ldd	r24, Y+10	; 0x0a
    7d48:	fa 01       	movw	r30, r20
    7d4a:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d4c:	8b 85       	ldd	r24, Y+11	; 0x0b
    7d4e:	89 83       	std	Y+1, r24	; 0x01
    7d50:	8c 85       	ldd	r24, Y+12	; 0x0c
    7d52:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    7d54:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    7d56:	ce 01       	movw	r24, r28
    7d58:	01 96       	adiw	r24, 0x01	; 1
    7d5a:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
	 *GPumpID=xPumpID;
    7d5e:	f7 01       	movw	r30, r14
    7d60:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    7d62:	00 d0       	rcall	.+0      	; 0x7d64 <GetParameter+0x82>
    7d64:	00 d0       	rcall	.+0      	; 0x7d66 <GetParameter+0x84>
    7d66:	f7 e0       	ldi	r31, 0x07	; 7
    7d68:	ef 2e       	mov	r14, r31
    7d6a:	f1 2c       	mov	r15, r1
    7d6c:	ec 0e       	add	r14, r28
    7d6e:	fd 1e       	adc	r15, r29
    7d70:	ed b7       	in	r30, 0x3d	; 61
    7d72:	fe b7       	in	r31, 0x3e	; 62
    7d74:	f2 82       	std	Z+2, r15	; 0x02
    7d76:	e1 82       	std	Z+1, r14	; 0x01
    7d78:	88 e4       	ldi	r24, 0x48	; 72
    7d7a:	93 e0       	ldi	r25, 0x03	; 3
    7d7c:	94 83       	std	Z+4, r25	; 0x04
    7d7e:	83 83       	std	Z+3, r24	; 0x03
    7d80:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    7d84:	0f 90       	pop	r0
    7d86:	0f 90       	pop	r0
    7d88:	0f 90       	pop	r0
    7d8a:	0f 90       	pop	r0
    7d8c:	c7 01       	movw	r24, r14
    7d8e:	b5 01       	movw	r22, r10
    7d90:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <Pos>
    7d94:	8c 15       	cp	r24, r12
    7d96:	9d 05       	cpc	r25, r13
    7d98:	4c f5       	brge	.+82     	; 0x7dec <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    7d9a:	c7 01       	movw	r24, r14
    7d9c:	b5 01       	movw	r22, r10
    7d9e:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <Pos>
    7da2:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    7da4:	c7 01       	movw	r24, r14
    7da6:	b5 01       	movw	r22, r10
    7da8:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <Pos>
    7dac:	a6 01       	movw	r20, r12
    7dae:	40 1b       	sub	r20, r16
    7db0:	51 0b       	sbc	r21, r17
    7db2:	d5 01       	movw	r26, r10
    7db4:	a8 0f       	add	r26, r24
    7db6:	b9 1f       	adc	r27, r25
    7db8:	20 e0       	ldi	r18, 0x00	; 0
    7dba:	30 e0       	ldi	r19, 0x00	; 0
    7dbc:	be 01       	movw	r22, r28
    7dbe:	6c 5f       	subi	r22, 0xFC	; 252
    7dc0:	7f 4f       	sbci	r23, 0xFF	; 255
    7dc2:	07 c0       	rjmp	.+14     	; 0x7dd2 <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7dc4:	fb 01       	movw	r30, r22
    7dc6:	e2 0f       	add	r30, r18
    7dc8:	f3 1f       	adc	r31, r19
    7dca:	8c 91       	ld	r24, X
    7dcc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7dce:	2f 5f       	subi	r18, 0xFF	; 255
    7dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    7dd2:	11 96       	adiw	r26, 0x01	; 1
    7dd4:	24 17       	cp	r18, r20
    7dd6:	35 07       	cpc	r19, r21
    7dd8:	a8 f3       	brcs	.-22     	; 0x7dc4 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7dda:	46 0f       	add	r20, r22
    7ddc:	57 1f       	adc	r21, r23
    7dde:	fa 01       	movw	r30, r20
    7de0:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    7de2:	cb 01       	movw	r24, r22
    7de4:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
	     *GeniCSum=xCsum;
    7de8:	f4 01       	movw	r30, r8
    7dea:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 uart_print(1,1,strSend);
*/
}
    7dec:	a7 96       	adiw	r28, 0x27	; 39
    7dee:	0f b6       	in	r0, 0x3f	; 63
    7df0:	f8 94       	cli
    7df2:	de bf       	out	0x3e, r29	; 62
    7df4:	0f be       	out	0x3f, r0	; 63
    7df6:	cd bf       	out	0x3d, r28	; 61
    7df8:	cf 91       	pop	r28
    7dfa:	df 91       	pop	r29
    7dfc:	1f 91       	pop	r17
    7dfe:	0f 91       	pop	r16
    7e00:	ff 90       	pop	r15
    7e02:	ef 90       	pop	r14
    7e04:	df 90       	pop	r13
    7e06:	cf 90       	pop	r12
    7e08:	bf 90       	pop	r11
    7e0a:	af 90       	pop	r10
    7e0c:	9f 90       	pop	r9
    7e0e:	8f 90       	pop	r8
    7e10:	08 95       	ret

00007e12 <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    7e12:	ff 92       	push	r15
    7e14:	0f 93       	push	r16
    7e16:	1f 93       	push	r17
    7e18:	df 93       	push	r29
    7e1a:	cf 93       	push	r28
    7e1c:	cd b7       	in	r28, 0x3d	; 61
    7e1e:	de b7       	in	r29, 0x3e	; 62
    7e20:	67 97       	sbiw	r28, 0x17	; 23
    7e22:	0f b6       	in	r0, 0x3f	; 63
    7e24:	f8 94       	cli
    7e26:	de bf       	out	0x3e, r29	; 62
    7e28:	0f be       	out	0x3f, r0	; 63
    7e2a:	cd bf       	out	0x3d, r28	; 61
    7e2c:	f8 2e       	mov	r15, r24
	 char i,GeniCmd,GeniPumpID,GeniCSum;//,sCmd[7];
	 char strSend[20];

    //uart(1,1,dataIn);

	if (dataIn==0x0D){	
    7e2e:	8d e0       	ldi	r24, 0x0D	; 13
    7e30:	f8 16       	cp	r15, r24
    7e32:	09 f0       	breq	.+2      	; 0x7e36 <GeniusProtocol+0x24>
    7e34:	45 c0       	rjmp	.+138    	; 0x7ec0 <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    7e36:	82 ec       	ldi	r24, 0xC2	; 194
    7e38:	91 e0       	ldi	r25, 0x01	; 1
    7e3a:	60 91 c1 01 	lds	r22, 0x01C1
    7e3e:	ae 01       	movw	r20, r28
    7e40:	4f 5f       	subi	r20, 0xFF	; 255
    7e42:	5f 4f       	sbci	r21, 0xFF	; 255
    7e44:	9e 01       	movw	r18, r28
    7e46:	2e 5f       	subi	r18, 0xFE	; 254
    7e48:	3f 4f       	sbci	r19, 0xFF	; 255
    7e4a:	8e 01       	movw	r16, r28
    7e4c:	0d 5f       	subi	r16, 0xFD	; 253
    7e4e:	1f 4f       	sbci	r17, 0xFF	; 255
    7e50:	0e 94 71 3e 	call	0x7ce2	; 0x7ce2 <GetParameter>
		FlowLength=0;
    7e54:	10 92 c1 01 	sts	0x01C1, r1
		IsGeniusFlow=False;
    7e58:	10 92 c0 01 	sts	0x01C0, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    7e5c:	ad b7       	in	r26, 0x3d	; 61
    7e5e:	be b7       	in	r27, 0x3e	; 62
    7e60:	18 97       	sbiw	r26, 0x08	; 8
    7e62:	0f b6       	in	r0, 0x3f	; 63
    7e64:	f8 94       	cli
    7e66:	be bf       	out	0x3e, r27	; 62
    7e68:	0f be       	out	0x3f, r0	; 63
    7e6a:	ad bf       	out	0x3d, r26	; 61
    7e6c:	ed b7       	in	r30, 0x3d	; 61
    7e6e:	fe b7       	in	r31, 0x3e	; 62
    7e70:	31 96       	adiw	r30, 0x01	; 1
    7e72:	8e 01       	movw	r16, r28
    7e74:	0c 5f       	subi	r16, 0xFC	; 252
    7e76:	1f 4f       	sbci	r17, 0xFF	; 255
    7e78:	12 96       	adiw	r26, 0x02	; 2
    7e7a:	1c 93       	st	X, r17
    7e7c:	0e 93       	st	-X, r16
    7e7e:	11 97       	sbiw	r26, 0x01	; 1
    7e80:	8a e3       	ldi	r24, 0x3A	; 58
    7e82:	93 e0       	ldi	r25, 0x03	; 3
    7e84:	93 83       	std	Z+3, r25	; 0x03
    7e86:	82 83       	std	Z+2, r24	; 0x02
    7e88:	89 81       	ldd	r24, Y+1	; 0x01
    7e8a:	84 83       	std	Z+4, r24	; 0x04
    7e8c:	15 82       	std	Z+5, r1	; 0x05
    7e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    7e90:	86 83       	std	Z+6, r24	; 0x06
    7e92:	17 82       	std	Z+7, r1	; 0x07
    7e94:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		//uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    7e98:	8d b7       	in	r24, 0x3d	; 61
    7e9a:	9e b7       	in	r25, 0x3e	; 62
    7e9c:	08 96       	adiw	r24, 0x08	; 8
    7e9e:	0f b6       	in	r0, 0x3f	; 63
    7ea0:	f8 94       	cli
    7ea2:	9e bf       	out	0x3e, r25	; 62
    7ea4:	0f be       	out	0x3f, r0	; 63
    7ea6:	8d bf       	out	0x3d, r24	; 61
    7ea8:	c8 01       	movw	r24, r16
    7eaa:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <SumChecksum>
    7eae:	9b 81       	ldd	r25, Y+3	; 0x03
    7eb0:	89 17       	cp	r24, r25
    7eb2:	31 f4       	brne	.+12     	; 0x7ec0 <GeniusProtocol+0xae>
		     switch(GeniCmd){
    7eb4:	89 81       	ldd	r24, Y+1	; 0x01
    7eb6:	84 35       	cpi	r24, 0x54	; 84
    7eb8:	19 f4       	brne	.+6      	; 0x7ec0 <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    7eba:	8a 81       	ldd	r24, Y+2	; 0x02
    7ebc:	0e 94 4c 2c 	call	0x5898	; 0x5898 <GeniusSendLastTransaction>
    7ec0:	e4 ed       	ldi	r30, 0xD4	; 212
    7ec2:	f1 e0       	ldi	r31, 0x01	; 1
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    7ec4:	80 81       	ld	r24, Z
    7ec6:	81 83       	std	Z+1, r24	; 0x01
    7ec8:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    7eca:	91 e0       	ldi	r25, 0x01	; 1
    7ecc:	e1 3c       	cpi	r30, 0xC1	; 193
    7ece:	f9 07       	cpc	r31, r25
    7ed0:	c9 f7       	brne	.-14     	; 0x7ec4 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    7ed2:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    7ed4:	8f 2d       	mov	r24, r15
    7ed6:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <IsGeniusCommand>
    7eda:	81 30       	cpi	r24, 0x01	; 1
    7edc:	11 f4       	brne	.+4      	; 0x7ee2 <GeniusProtocol+0xd0>
    7ede:	80 93 c0 01 	sts	0x01C0, r24
	if (IsGeniusFlow==True)FlowLength++;
    7ee2:	80 91 c0 01 	lds	r24, 0x01C0
    7ee6:	81 30       	cpi	r24, 0x01	; 1
    7ee8:	29 f4       	brne	.+10     	; 0x7ef4 <GeniusProtocol+0xe2>
    7eea:	80 91 c1 01 	lds	r24, 0x01C1
    7eee:	8f 5f       	subi	r24, 0xFF	; 255
    7ef0:	80 93 c1 01 	sts	0x01C1, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    7ef4:	67 96       	adiw	r28, 0x17	; 23
    7ef6:	0f b6       	in	r0, 0x3f	; 63
    7ef8:	f8 94       	cli
    7efa:	de bf       	out	0x3e, r29	; 62
    7efc:	0f be       	out	0x3f, r0	; 63
    7efe:	cd bf       	out	0x3d, r28	; 61
    7f00:	cf 91       	pop	r28
    7f02:	df 91       	pop	r29
    7f04:	1f 91       	pop	r17
    7f06:	0f 91       	pop	r16
    7f08:	ff 90       	pop	r15
    7f0a:	08 95       	ret

00007f0c <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    7f0c:	1f 92       	push	r1
    7f0e:	0f 92       	push	r0
    7f10:	0f b6       	in	r0, 0x3f	; 63
    7f12:	0f 92       	push	r0
    7f14:	0b b6       	in	r0, 0x3b	; 59
    7f16:	0f 92       	push	r0
    7f18:	11 24       	eor	r1, r1
    7f1a:	1f 93       	push	r17
    7f1c:	2f 93       	push	r18
    7f1e:	3f 93       	push	r19
    7f20:	4f 93       	push	r20
    7f22:	5f 93       	push	r21
    7f24:	6f 93       	push	r22
    7f26:	7f 93       	push	r23
    7f28:	8f 93       	push	r24
    7f2a:	9f 93       	push	r25
    7f2c:	af 93       	push	r26
    7f2e:	bf 93       	push	r27
    7f30:	ef 93       	push	r30
    7f32:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    7f34:	10 91 9c 00 	lds	r17, 0x009C
    //Not Successfull!
	//NewPacket
	if (IsNewPacket==True){
    7f38:	80 91 88 01 	lds	r24, 0x0188
    7f3c:	81 30       	cpi	r24, 0x01	; 1
    7f3e:	51 f4       	brne	.+20     	; 0x7f54 <__vector_30+0x48>
	    if (dataTX1==0x01){
    7f40:	11 30       	cpi	r17, 0x01	; 1
    7f42:	41 f4       	brne	.+16     	; 0x7f54 <__vector_30+0x48>
		    char_count=0;
    7f44:	10 92 8a 01 	sts	0x018A, r1
    7f48:	10 92 89 01 	sts	0x0189, r1
            IsNewPacket=False;
    7f4c:	10 92 88 01 	sts	0x0188, r1
			IsAdvanZProtocol=True;
    7f50:	10 93 98 02 	sts	0x0298, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    7f54:	80 91 98 02 	lds	r24, 0x0298
    7f58:	81 30       	cpi	r24, 0x01	; 1
    7f5a:	69 f4       	brne	.+26     	; 0x7f76 <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
    7f5c:	80 91 89 01 	lds	r24, 0x0189
    7f60:	90 91 8a 01 	lds	r25, 0x018A
    7f64:	fc 01       	movw	r30, r24
    7f66:	e3 5e       	subi	r30, 0xE3	; 227
    7f68:	f6 4f       	sbci	r31, 0xF6	; 246
    7f6a:	10 83       	st	Z, r17
	    char_count++; 
    7f6c:	01 96       	adiw	r24, 0x01	; 1
    7f6e:	90 93 8a 01 	sts	0x018A, r25
    7f72:	80 93 89 01 	sts	0x0189, r24
	}

	if (dataTX1==0x02){
    7f76:	12 30       	cpi	r17, 0x02	; 2
    7f78:	b1 f5       	brne	.+108    	; 0x7fe6 <__vector_30+0xda>
		transLength=char_count;
    7f7a:	60 91 89 01 	lds	r22, 0x0189
    7f7e:	70 91 8a 01 	lds	r23, 0x018A
    7f82:	70 93 8c 01 	sts	0x018C, r23
    7f86:	60 93 8b 01 	sts	0x018B, r22
		char_count=0;
    7f8a:	10 92 8a 01 	sts	0x018A, r1
    7f8e:	10 92 89 01 	sts	0x0189, r1
		IsAdvanZProtocol=False;
    7f92:	10 92 98 02 	sts	0x0298, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    7f96:	20 91 41 09 	lds	r18, 0x0941
    7f9a:	20 51       	subi	r18, 0x10	; 16
    7f9c:	80 91 40 09 	lds	r24, 0x0940
    7fa0:	3a e0       	ldi	r19, 0x0A	; 10
    7fa2:	83 9f       	mul	r24, r19
    7fa4:	c0 01       	movw	r24, r0
    7fa6:	11 24       	eor	r1, r1
    7fa8:	28 0f       	add	r18, r24
    7faa:	20 93 24 01 	sts	0x0124, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    7fae:	80 91 1d 09 	lds	r24, 0x091D
    7fb2:	0e 94 0b 18 	call	0x3016	; 0x3016 <IdentifyMessage>
		IsNewPacket=True;
    7fb6:	21 e0       	ldi	r18, 0x01	; 1
    7fb8:	20 93 88 01 	sts	0x0188, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    7fbc:	80 91 40 09 	lds	r24, 0x0940
    7fc0:	88 33       	cpi	r24, 0x38	; 56
    7fc2:	89 f4       	brne	.+34     	; 0x7fe6 <__vector_30+0xda>
    7fc4:	80 91 41 09 	lds	r24, 0x0941
    7fc8:	81 33       	cpi	r24, 0x31	; 49
    7fca:	69 f4       	brne	.+26     	; 0x7fe6 <__vector_30+0xda>
		   LengthMessage81=transLength-12-44;
    7fcc:	80 91 8b 01 	lds	r24, 0x018B
    7fd0:	90 91 8c 01 	lds	r25, 0x018C
    7fd4:	c8 97       	sbiw	r24, 0x38	; 56
    7fd6:	90 93 8e 01 	sts	0x018E, r25
    7fda:	80 93 8d 01 	sts	0x018D, r24
		   IsMessage81=True;
    7fde:	20 93 a6 01 	sts	0x01A6, r18
		   IsCompleteFilling=True;
    7fe2:	20 93 a9 01 	sts	0x01A9, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)
    7fe6:	80 91 88 01 	lds	r24, 0x0188
    7fea:	81 30       	cpi	r24, 0x01	; 1
    7fec:	19 f0       	breq	.+6      	; 0x7ff4 <__vector_30+0xe8>
	    ConfigProtocol(dataTX1);
    7fee:	81 2f       	mov	r24, r17
    7ff0:	0e 94 15 14 	call	0x282a	; 0x282a <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))
    7ff4:	80 91 00 01 	lds	r24, 0x0100
    7ff8:	82 30       	cpi	r24, 0x02	; 2
    7ffa:	39 f4       	brne	.+14     	; 0x800a <__vector_30+0xfe>
    7ffc:	80 91 88 01 	lds	r24, 0x0188
    8000:	81 30       	cpi	r24, 0x01	; 1
    8002:	19 f0       	breq	.+6      	; 0x800a <__vector_30+0xfe>
	     GeniusProtocol(dataTX1);		
    8004:	81 2f       	mov	r24, r17
    8006:	0e 94 09 3f 	call	0x7e12	; 0x7e12 <GeniusProtocol>
    //uart(0,1,dataTX1);
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}
    800a:	ff 91       	pop	r31
    800c:	ef 91       	pop	r30
    800e:	bf 91       	pop	r27
    8010:	af 91       	pop	r26
    8012:	9f 91       	pop	r25
    8014:	8f 91       	pop	r24
    8016:	7f 91       	pop	r23
    8018:	6f 91       	pop	r22
    801a:	5f 91       	pop	r21
    801c:	4f 91       	pop	r20
    801e:	3f 91       	pop	r19
    8020:	2f 91       	pop	r18
    8022:	1f 91       	pop	r17
    8024:	0f 90       	pop	r0
    8026:	0b be       	out	0x3b, r0	; 59
    8028:	0f 90       	pop	r0
    802a:	0f be       	out	0x3f, r0	; 63
    802c:	0f 90       	pop	r0
    802e:	1f 90       	pop	r1
    8030:	18 95       	reti

00008032 <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    8032:	0f 93       	push	r16
    8034:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    8036:	80 91 1d 09 	lds	r24, 0x091D
    803a:	81 30       	cpi	r24, 0x01	; 1
    803c:	09 f0       	breq	.+2      	; 0x8040 <procMessage99+0xe>
    803e:	2e c2       	rjmp	.+1116   	; 0x849c <procMessage99+0x46a>
    8040:	80 91 8b 01 	lds	r24, 0x018B
    8044:	90 91 8c 01 	lds	r25, 0x018C
    8048:	8a 57       	subi	r24, 0x7A	; 122
    804a:	91 40       	sbci	r25, 0x01	; 1
    804c:	08 f4       	brcc	.+2      	; 0x8050 <procMessage99+0x1e>
    804e:	26 c2       	rjmp	.+1100   	; 0x849c <procMessage99+0x46a>
    8050:	20 e0       	ldi	r18, 0x00	; 0
    8052:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8054:	f9 01       	movw	r30, r18
    8056:	e9 57       	subi	r30, 0x79	; 121
    8058:	f3 4f       	sbci	r31, 0xF3	; 243
    805a:	d9 01       	movw	r26, r18
    805c:	a3 5e       	subi	r26, 0xE3	; 227
    805e:	b6 4f       	sbci	r27, 0xF6	; 246
    8060:	95 96       	adiw	r26, 0x25	; 37
    8062:	8c 91       	ld	r24, X
    8064:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8066:	2f 5f       	subi	r18, 0xFF	; 255
    8068:	3f 4f       	sbci	r19, 0xFF	; 255
    806a:	26 30       	cpi	r18, 0x06	; 6
    806c:	31 05       	cpc	r19, r1
    806e:	91 f7       	brne	.-28     	; 0x8054 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8070:	10 92 8d 0c 	sts	0x0C8D, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8074:	80 91 48 09 	lds	r24, 0x0948
    8078:	80 93 68 0c 	sts	0x0C68, r24
	 }Dest[Length]=0;
    807c:	10 92 69 0c 	sts	0x0C69, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    8080:	80 53       	subi	r24, 0x30	; 48
    8082:	80 93 b9 01 	sts	0x01B9, r24
    8086:	20 e0       	ldi	r18, 0x00	; 0
    8088:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    808a:	f9 01       	movw	r30, r18
    808c:	e2 59       	subi	r30, 0x92	; 146
    808e:	f8 4f       	sbci	r31, 0xF8	; 248
    8090:	d9 01       	movw	r26, r18
    8092:	a3 5e       	subi	r26, 0xE3	; 227
    8094:	b6 4f       	sbci	r27, 0xF6	; 246
    8096:	9c 96       	adiw	r26, 0x2c	; 44
    8098:	8c 91       	ld	r24, X
    809a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    809c:	2f 5f       	subi	r18, 0xFF	; 255
    809e:	3f 4f       	sbci	r19, 0xFF	; 255
    80a0:	2a 30       	cpi	r18, 0x0A	; 10
    80a2:	31 05       	cpc	r19, r1
    80a4:	91 f7       	brne	.-28     	; 0x808a <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80a6:	10 92 78 07 	sts	0x0778, r1
    80aa:	20 e0       	ldi	r18, 0x00	; 0
    80ac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80ae:	f9 01       	movw	r30, r18
    80b0:	e3 5b       	subi	r30, 0xB3	; 179
    80b2:	fc 4f       	sbci	r31, 0xFC	; 252
    80b4:	d9 01       	movw	r26, r18
    80b6:	a3 5e       	subi	r26, 0xE3	; 227
    80b8:	b6 4f       	sbci	r27, 0xF6	; 246
    80ba:	d6 96       	adiw	r26, 0x36	; 54
    80bc:	8c 91       	ld	r24, X
    80be:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80c0:	2f 5f       	subi	r18, 0xFF	; 255
    80c2:	3f 4f       	sbci	r19, 0xFF	; 255
    80c4:	28 30       	cpi	r18, 0x08	; 8
    80c6:	31 05       	cpc	r19, r1
    80c8:	91 f7       	brne	.-28     	; 0x80ae <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80ca:	10 92 55 03 	sts	0x0355, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80ce:	80 91 5b 09 	lds	r24, 0x095B
    80d2:	80 93 f7 08 	sts	0x08F7, r24
    80d6:	80 91 5c 09 	lds	r24, 0x095C
    80da:	80 93 f8 08 	sts	0x08F8, r24
	 }Dest[Length]=0;
    80de:	10 92 f9 08 	sts	0x08F9, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80e2:	80 91 5d 09 	lds	r24, 0x095D
    80e6:	80 93 b9 07 	sts	0x07B9, r24
    80ea:	80 91 5e 09 	lds	r24, 0x095E
    80ee:	80 93 ba 07 	sts	0x07BA, r24
	 }Dest[Length]=0;
    80f2:	10 92 bb 07 	sts	0x07BB, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80f6:	80 91 5f 09 	lds	r24, 0x095F
    80fa:	80 93 71 08 	sts	0x0871, r24
    80fe:	80 91 60 09 	lds	r24, 0x0960
    8102:	80 93 72 08 	sts	0x0872, r24
	 }Dest[Length]=0;
    8106:	10 92 73 08 	sts	0x0873, r1
    810a:	20 e0       	ldi	r18, 0x00	; 0
    810c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    810e:	f9 01       	movw	r30, r18
    8110:	e4 5f       	subi	r30, 0xF4	; 244
    8112:	f7 4f       	sbci	r31, 0xF7	; 247
    8114:	d9 01       	movw	r26, r18
    8116:	af 59       	subi	r26, 0x9F	; 159
    8118:	b6 4f       	sbci	r27, 0xF6	; 246
    811a:	8c 91       	ld	r24, X
    811c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    811e:	2f 5f       	subi	r18, 0xFF	; 255
    8120:	3f 4f       	sbci	r19, 0xFF	; 255
    8122:	2f 30       	cpi	r18, 0x0F	; 15
    8124:	31 05       	cpc	r19, r1
    8126:	99 f7       	brne	.-26     	; 0x810e <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8128:	10 92 1b 08 	sts	0x081B, r1
    812c:	20 e0       	ldi	r18, 0x00	; 0
    812e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8130:	f9 01       	movw	r30, r18
    8132:	e2 56       	subi	r30, 0x62	; 98
    8134:	fa 4f       	sbci	r31, 0xFA	; 250
    8136:	d9 01       	movw	r26, r18
    8138:	a0 59       	subi	r26, 0x90	; 144
    813a:	b6 4f       	sbci	r27, 0xF6	; 246
    813c:	8c 91       	ld	r24, X
    813e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8140:	2f 5f       	subi	r18, 0xFF	; 255
    8142:	3f 4f       	sbci	r19, 0xFF	; 255
    8144:	28 30       	cpi	r18, 0x08	; 8
    8146:	31 05       	cpc	r19, r1
    8148:	99 f7       	brne	.-26     	; 0x8130 <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    814a:	10 92 a6 05 	sts	0x05A6, r1
    814e:	20 e0       	ldi	r18, 0x00	; 0
    8150:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8152:	f9 01       	movw	r30, r18
    8154:	eb 58       	subi	r30, 0x8B	; 139
    8156:	fc 4f       	sbci	r31, 0xFC	; 252
    8158:	d9 01       	movw	r26, r18
    815a:	a8 58       	subi	r26, 0x88	; 136
    815c:	b6 4f       	sbci	r27, 0xF6	; 246
    815e:	8c 91       	ld	r24, X
    8160:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8162:	2f 5f       	subi	r18, 0xFF	; 255
    8164:	3f 4f       	sbci	r19, 0xFF	; 255
    8166:	28 30       	cpi	r18, 0x08	; 8
    8168:	31 05       	cpc	r19, r1
    816a:	99 f7       	brne	.-26     	; 0x8152 <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    816c:	10 92 7d 03 	sts	0x037D, r1
    8170:	20 e0       	ldi	r18, 0x00	; 0
    8172:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8174:	f9 01       	movw	r30, r18
    8176:	ed 54       	subi	r30, 0x4D	; 77
    8178:	f4 4f       	sbci	r31, 0xF4	; 244
    817a:	d9 01       	movw	r26, r18
    817c:	a0 58       	subi	r26, 0x80	; 128
    817e:	b6 4f       	sbci	r27, 0xF6	; 246
    8180:	8c 91       	ld	r24, X
    8182:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8184:	2f 5f       	subi	r18, 0xFF	; 255
    8186:	3f 4f       	sbci	r19, 0xFF	; 255
    8188:	2a 30       	cpi	r18, 0x0A	; 10
    818a:	31 05       	cpc	r19, r1
    818c:	99 f7       	brne	.-26     	; 0x8174 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    818e:	10 92 bd 0b 	sts	0x0BBD, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    8192:	80 91 8a 09 	lds	r24, 0x098A
    8196:	80 53       	subi	r24, 0x30	; 48
    8198:	80 93 b8 01 	sts	0x01B8, r24
    819c:	20 e0       	ldi	r18, 0x00	; 0
    819e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    81a0:	f9 01       	movw	r30, r18
    81a2:	e3 58       	subi	r30, 0x83	; 131
    81a4:	fa 4f       	sbci	r31, 0xFA	; 250
    81a6:	d9 01       	movw	r26, r18
    81a8:	a5 57       	subi	r26, 0x75	; 117
    81aa:	b6 4f       	sbci	r27, 0xF6	; 246
    81ac:	8c 91       	ld	r24, X
    81ae:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    81b0:	2f 5f       	subi	r18, 0xFF	; 255
    81b2:	3f 4f       	sbci	r19, 0xFF	; 255
    81b4:	24 31       	cpi	r18, 0x14	; 20
    81b6:	31 05       	cpc	r19, r1
    81b8:	99 f7       	brne	.-26     	; 0x81a0 <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    81ba:	10 92 91 05 	sts	0x0591, r1
    81be:	20 e0       	ldi	r18, 0x00	; 0
    81c0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    81c2:	f9 01       	movw	r30, r18
    81c4:	e7 57       	subi	r30, 0x77	; 119
    81c6:	f4 4f       	sbci	r31, 0xF4	; 244
    81c8:	d9 01       	movw	r26, r18
    81ca:	a1 56       	subi	r26, 0x61	; 97
    81cc:	b6 4f       	sbci	r27, 0xF6	; 246
    81ce:	8c 91       	ld	r24, X
    81d0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    81d2:	2f 5f       	subi	r18, 0xFF	; 255
    81d4:	3f 4f       	sbci	r19, 0xFF	; 255
    81d6:	24 31       	cpi	r18, 0x14	; 20
    81d8:	31 05       	cpc	r19, r1
    81da:	99 f7       	brne	.-26     	; 0x81c2 <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    81dc:	10 92 9d 0b 	sts	0x0B9D, r1
    81e0:	20 e0       	ldi	r18, 0x00	; 0
    81e2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    81e4:	f9 01       	movw	r30, r18
    81e6:	ec 5d       	subi	r30, 0xDC	; 220
    81e8:	fc 4f       	sbci	r31, 0xFC	; 252
    81ea:	d9 01       	movw	r26, r18
    81ec:	ad 54       	subi	r26, 0x4D	; 77
    81ee:	b6 4f       	sbci	r27, 0xF6	; 246
    81f0:	8c 91       	ld	r24, X
    81f2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    81f4:	2f 5f       	subi	r18, 0xFF	; 255
    81f6:	3f 4f       	sbci	r19, 0xFF	; 255
    81f8:	28 32       	cpi	r18, 0x28	; 40
    81fa:	31 05       	cpc	r19, r1
    81fc:	99 f7       	brne	.-26     	; 0x81e4 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    81fe:	10 92 4c 03 	sts	0x034C, r1
    8202:	20 e0       	ldi	r18, 0x00	; 0
    8204:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8206:	f9 01       	movw	r30, r18
    8208:	e5 5a       	subi	r30, 0xA5	; 165
    820a:	fc 4f       	sbci	r31, 0xFC	; 252
    820c:	d9 01       	movw	r26, r18
    820e:	a5 52       	subi	r26, 0x25	; 37
    8210:	b6 4f       	sbci	r27, 0xF6	; 246
    8212:	8c 91       	ld	r24, X
    8214:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8216:	2f 5f       	subi	r18, 0xFF	; 255
    8218:	3f 4f       	sbci	r19, 0xFF	; 255
    821a:	29 31       	cpi	r18, 0x19	; 25
    821c:	31 05       	cpc	r19, r1
    821e:	99 f7       	brne	.-26     	; 0x8206 <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8220:	10 92 74 03 	sts	0x0374, r1
    8224:	20 e0       	ldi	r18, 0x00	; 0
    8226:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8228:	f9 01       	movw	r30, r18
    822a:	e8 50       	subi	r30, 0x08	; 8
    822c:	f4 4f       	sbci	r31, 0xF4	; 244
    822e:	d9 01       	movw	r26, r18
    8230:	ac 50       	subi	r26, 0x0C	; 12
    8232:	b6 4f       	sbci	r27, 0xF6	; 246
    8234:	8c 91       	ld	r24, X
    8236:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8238:	2f 5f       	subi	r18, 0xFF	; 255
    823a:	3f 4f       	sbci	r19, 0xFF	; 255
    823c:	2d 30       	cpi	r18, 0x0D	; 13
    823e:	31 05       	cpc	r19, r1
    8240:	99 f7       	brne	.-26     	; 0x8228 <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8242:	10 92 05 0c 	sts	0x0C05, r1
    8246:	20 e0       	ldi	r18, 0x00	; 0
    8248:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    824a:	f9 01       	movw	r30, r18
    824c:	e4 57       	subi	r30, 0x74	; 116
    824e:	fc 4f       	sbci	r31, 0xFC	; 252
    8250:	d9 01       	movw	r26, r18
    8252:	af 5f       	subi	r26, 0xFF	; 255
    8254:	b5 4f       	sbci	r27, 0xF5	; 245
    8256:	8c 91       	ld	r24, X
    8258:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    825a:	2f 5f       	subi	r18, 0xFF	; 255
    825c:	3f 4f       	sbci	r19, 0xFF	; 255
    825e:	2d 30       	cpi	r18, 0x0D	; 13
    8260:	31 05       	cpc	r19, r1
    8262:	99 f7       	brne	.-26     	; 0x824a <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8264:	10 92 99 03 	sts	0x0399, r1
    8268:	20 e0       	ldi	r18, 0x00	; 0
    826a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    826c:	f9 01       	movw	r30, r18
    826e:	e7 51       	subi	r30, 0x17	; 23
    8270:	f7 4f       	sbci	r31, 0xF7	; 247
    8272:	d9 01       	movw	r26, r18
    8274:	a2 5f       	subi	r26, 0xF2	; 242
    8276:	b5 4f       	sbci	r27, 0xF5	; 245
    8278:	8c 91       	ld	r24, X
    827a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    827c:	2f 5f       	subi	r18, 0xFF	; 255
    827e:	3f 4f       	sbci	r19, 0xFF	; 255
    8280:	2d 30       	cpi	r18, 0x0D	; 13
    8282:	31 05       	cpc	r19, r1
    8284:	99 f7       	brne	.-26     	; 0x826c <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8286:	10 92 f6 08 	sts	0x08F6, r1
    828a:	20 e0       	ldi	r18, 0x00	; 0
    828c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    828e:	f9 01       	movw	r30, r18
    8290:	e4 54       	subi	r30, 0x44	; 68
    8292:	f8 4f       	sbci	r31, 0xF8	; 248
    8294:	d9 01       	movw	r26, r18
    8296:	a5 5e       	subi	r26, 0xE5	; 229
    8298:	b5 4f       	sbci	r27, 0xF5	; 245
    829a:	8c 91       	ld	r24, X
    829c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    829e:	2f 5f       	subi	r18, 0xFF	; 255
    82a0:	3f 4f       	sbci	r19, 0xFF	; 255
    82a2:	23 31       	cpi	r18, 0x13	; 19
    82a4:	31 05       	cpc	r19, r1
    82a6:	99 f7       	brne	.-26     	; 0x828e <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    82a8:	10 92 cf 07 	sts	0x07CF, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    82ac:	80 91 2e 0a 	lds	r24, 0x0A2E
    82b0:	80 93 84 0c 	sts	0x0C84, r24
    82b4:	80 91 2f 0a 	lds	r24, 0x0A2F
    82b8:	80 93 85 0c 	sts	0x0C85, r24
	 }Dest[Length]=0;
    82bc:	10 92 86 0c 	sts	0x0C86, r1
    82c0:	20 e0       	ldi	r18, 0x00	; 0
    82c2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    82c4:	f9 01       	movw	r30, r18
    82c6:	ec 5e       	subi	r30, 0xEC	; 236
    82c8:	f6 4f       	sbci	r31, 0xF6	; 246
    82ca:	d9 01       	movw	r26, r18
    82cc:	a0 5d       	subi	r26, 0xD0	; 208
    82ce:	b5 4f       	sbci	r27, 0xF5	; 245
    82d0:	8c 91       	ld	r24, X
    82d2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    82d4:	2f 5f       	subi	r18, 0xFF	; 255
    82d6:	3f 4f       	sbci	r19, 0xFF	; 255
    82d8:	28 30       	cpi	r18, 0x08	; 8
    82da:	31 05       	cpc	r19, r1
    82dc:	99 f7       	brne	.-26     	; 0x82c4 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    82de:	10 92 1c 09 	sts	0x091C, r1
    82e2:	20 e0       	ldi	r18, 0x00	; 0
    82e4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    82e6:	f9 01       	movw	r30, r18
    82e8:	e5 54       	subi	r30, 0x45	; 69
    82ea:	fd 4f       	sbci	r31, 0xFD	; 253
    82ec:	d9 01       	movw	r26, r18
    82ee:	a8 5c       	subi	r26, 0xC8	; 200
    82f0:	b5 4f       	sbci	r27, 0xF5	; 245
    82f2:	8c 91       	ld	r24, X
    82f4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    82f6:	2f 5f       	subi	r18, 0xFF	; 255
    82f8:	3f 4f       	sbci	r19, 0xFF	; 255
    82fa:	28 30       	cpi	r18, 0x08	; 8
    82fc:	31 05       	cpc	r19, r1
    82fe:	99 f7       	brne	.-26     	; 0x82e6 <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8300:	10 92 c3 02 	sts	0x02C3, r1
    8304:	20 e0       	ldi	r18, 0x00	; 0
    8306:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8308:	f9 01       	movw	r30, r18
    830a:	e9 51       	subi	r30, 0x19	; 25
    830c:	fd 4f       	sbci	r31, 0xFD	; 253
    830e:	d9 01       	movw	r26, r18
    8310:	a0 5c       	subi	r26, 0xC0	; 192
    8312:	b5 4f       	sbci	r27, 0xF5	; 245
    8314:	8c 91       	ld	r24, X
    8316:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8318:	2f 5f       	subi	r18, 0xFF	; 255
    831a:	3f 4f       	sbci	r19, 0xFF	; 255
    831c:	24 31       	cpi	r18, 0x14	; 20
    831e:	31 05       	cpc	r19, r1
    8320:	99 f7       	brne	.-26     	; 0x8308 <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8322:	10 92 fb 02 	sts	0x02FB, r1
    8326:	20 e0       	ldi	r18, 0x00	; 0
    8328:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    832a:	f9 01       	movw	r30, r18
    832c:	ec 53       	subi	r30, 0x3C	; 60
    832e:	fd 4f       	sbci	r31, 0xFD	; 253
    8330:	d9 01       	movw	r26, r18
    8332:	ac 5a       	subi	r26, 0xAC	; 172
    8334:	b5 4f       	sbci	r27, 0xF5	; 245
    8336:	8c 91       	ld	r24, X
    8338:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    833a:	2f 5f       	subi	r18, 0xFF	; 255
    833c:	3f 4f       	sbci	r19, 0xFF	; 255
    833e:	2e 31       	cpi	r18, 0x1E	; 30
    8340:	31 05       	cpc	r19, r1
    8342:	99 f7       	brne	.-26     	; 0x832a <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8344:	10 92 e2 02 	sts	0x02E2, r1
    8348:	20 e0       	ldi	r18, 0x00	; 0
    834a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    834c:	f9 01       	movw	r30, r18
    834e:	eb 5c       	subi	r30, 0xCB	; 203
    8350:	f7 4f       	sbci	r31, 0xF7	; 247
    8352:	d9 01       	movw	r26, r18
    8354:	ae 58       	subi	r26, 0x8E	; 142
    8356:	b5 4f       	sbci	r27, 0xF5	; 245
    8358:	8c 91       	ld	r24, X
    835a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    835c:	2f 5f       	subi	r18, 0xFF	; 255
    835e:	3f 4f       	sbci	r19, 0xFF	; 255
    8360:	28 30       	cpi	r18, 0x08	; 8
    8362:	31 05       	cpc	r19, r1
    8364:	99 f7       	brne	.-26     	; 0x834c <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8366:	10 92 3d 08 	sts	0x083D, r1
    836a:	20 e0       	ldi	r18, 0x00	; 0
    836c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    836e:	f9 01       	movw	r30, r18
    8370:	e2 58       	subi	r30, 0x82	; 130
    8372:	fc 4f       	sbci	r31, 0xFC	; 252
    8374:	d9 01       	movw	r26, r18
    8376:	a6 58       	subi	r26, 0x86	; 134
    8378:	b5 4f       	sbci	r27, 0xF5	; 245
    837a:	8c 91       	ld	r24, X
    837c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    837e:	2f 5f       	subi	r18, 0xFF	; 255
    8380:	3f 4f       	sbci	r19, 0xFF	; 255
    8382:	2a 30       	cpi	r18, 0x0A	; 10
    8384:	31 05       	cpc	r19, r1
    8386:	99 f7       	brne	.-26     	; 0x836e <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8388:	10 92 88 03 	sts	0x0388, r1
    838c:	20 e0       	ldi	r18, 0x00	; 0
    838e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8390:	f9 01       	movw	r30, r18
    8392:	e3 51       	subi	r30, 0x13	; 19
    8394:	f4 4f       	sbci	r31, 0xF4	; 244
    8396:	d9 01       	movw	r26, r18
    8398:	ac 57       	subi	r26, 0x7C	; 124
    839a:	b5 4f       	sbci	r27, 0xF5	; 245
    839c:	8c 91       	ld	r24, X
    839e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    83a0:	2f 5f       	subi	r18, 0xFF	; 255
    83a2:	3f 4f       	sbci	r19, 0xFF	; 255
    83a4:	2a 30       	cpi	r18, 0x0A	; 10
    83a6:	31 05       	cpc	r19, r1
    83a8:	99 f7       	brne	.-26     	; 0x8390 <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    83aa:	10 92 f7 0b 	sts	0x0BF7, r1
    83ae:	20 e0       	ldi	r18, 0x00	; 0
    83b0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    83b2:	f9 01       	movw	r30, r18
    83b4:	e5 52       	subi	r30, 0x25	; 37
    83b6:	f8 4f       	sbci	r31, 0xF8	; 248
    83b8:	d9 01       	movw	r26, r18
    83ba:	a2 57       	subi	r26, 0x72	; 114
    83bc:	b5 4f       	sbci	r27, 0xF5	; 245
    83be:	8c 91       	ld	r24, X
    83c0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    83c2:	2f 5f       	subi	r18, 0xFF	; 255
    83c4:	3f 4f       	sbci	r19, 0xFF	; 255
    83c6:	24 31       	cpi	r18, 0x14	; 20
    83c8:	31 05       	cpc	r19, r1
    83ca:	99 f7       	brne	.-26     	; 0x83b2 <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    83cc:	10 92 ef 07 	sts	0x07EF, r1
    83d0:	20 e0       	ldi	r18, 0x00	; 0
    83d2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    83d4:	f9 01       	movw	r30, r18
    83d6:	ee 5a       	subi	r30, 0xAE	; 174
    83d8:	f7 4f       	sbci	r31, 0xF7	; 247
    83da:	d9 01       	movw	r26, r18
    83dc:	ae 55       	subi	r26, 0x5E	; 94
    83de:	b5 4f       	sbci	r27, 0xF5	; 245
    83e0:	8c 91       	ld	r24, X
    83e2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    83e4:	2f 5f       	subi	r18, 0xFF	; 255
    83e6:	3f 4f       	sbci	r19, 0xFF	; 255
    83e8:	2a 30       	cpi	r18, 0x0A	; 10
    83ea:	31 05       	cpc	r19, r1
    83ec:	99 f7       	brne	.-26     	; 0x83d4 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    83ee:	10 92 5c 08 	sts	0x085C, r1
    83f2:	20 e0       	ldi	r18, 0x00	; 0
    83f4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    83f6:	f9 01       	movw	r30, r18
    83f8:	e6 56       	subi	r30, 0x66	; 102
    83fa:	fc 4f       	sbci	r31, 0xFC	; 252
    83fc:	d9 01       	movw	r26, r18
    83fe:	a4 55       	subi	r26, 0x54	; 84
    8400:	b5 4f       	sbci	r27, 0xF5	; 245
    8402:	8c 91       	ld	r24, X
    8404:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8406:	2f 5f       	subi	r18, 0xFF	; 255
    8408:	3f 4f       	sbci	r19, 0xFF	; 255
    840a:	28 30       	cpi	r18, 0x08	; 8
    840c:	31 05       	cpc	r19, r1
    840e:	99 f7       	brne	.-26     	; 0x83f6 <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8410:	10 92 a2 03 	sts	0x03A2, r1
    8414:	20 e0       	ldi	r18, 0x00	; 0
    8416:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8418:	f9 01       	movw	r30, r18
    841a:	e7 58       	subi	r30, 0x87	; 135
    841c:	f3 4f       	sbci	r31, 0xF3	; 243
    841e:	d9 01       	movw	r26, r18
    8420:	ac 54       	subi	r26, 0x4C	; 76
    8422:	b5 4f       	sbci	r27, 0xF5	; 245
    8424:	8c 91       	ld	r24, X
    8426:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8428:	2f 5f       	subi	r18, 0xFF	; 255
    842a:	3f 4f       	sbci	r19, 0xFF	; 255
    842c:	2a 30       	cpi	r18, 0x0A	; 10
    842e:	31 05       	cpc	r19, r1
    8430:	99 f7       	brne	.-26     	; 0x8418 <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8432:	10 92 83 0c 	sts	0x0C83, r1
    8436:	20 e0       	ldi	r18, 0x00	; 0
    8438:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    843a:	f9 01       	movw	r30, r18
    843c:	e6 5f       	subi	r30, 0xF6	; 246
    843e:	f3 4f       	sbci	r31, 0xF3	; 243
    8440:	d9 01       	movw	r26, r18
    8442:	a2 54       	subi	r26, 0x42	; 66
    8444:	b5 4f       	sbci	r27, 0xF5	; 245
    8446:	8c 91       	ld	r24, X
    8448:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    844a:	2f 5f       	subi	r18, 0xFF	; 255
    844c:	3f 4f       	sbci	r19, 0xFF	; 255
    844e:	24 31       	cpi	r18, 0x14	; 20
    8450:	31 05       	cpc	r19, r1
    8452:	99 f7       	brne	.-26     	; 0x843a <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8454:	10 92 1e 0c 	sts	0x0C1E, r1
    8458:	20 e0       	ldi	r18, 0x00	; 0
    845a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    845c:	f9 01       	movw	r30, r18
    845e:	e3 53       	subi	r30, 0x33	; 51
    8460:	fc 4f       	sbci	r31, 0xFC	; 252
    8462:	d9 01       	movw	r26, r18
    8464:	ae 52       	subi	r26, 0x2E	; 46
    8466:	b5 4f       	sbci	r27, 0xF5	; 245
    8468:	8c 91       	ld	r24, X
    846a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    846c:	2f 5f       	subi	r18, 0xFF	; 255
    846e:	3f 4f       	sbci	r19, 0xFF	; 255
    8470:	2e 31       	cpi	r18, 0x1E	; 30
    8472:	31 05       	cpc	r19, r1
    8474:	99 f7       	brne	.-26     	; 0x845c <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8476:	10 92 eb 03 	sts	0x03EB, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    847a:	80 91 8f 01 	lds	r24, 0x018F
    847e:	88 23       	and	r24, r24
    8480:	69 f0       	breq	.+26     	; 0x849c <procMessage99+0x46a>
    8482:	00 91 56 03 	lds	r16, 0x0356
    8486:	10 e0       	ldi	r17, 0x00	; 0
    8488:	89 eb       	ldi	r24, 0xB9	; 185
    848a:	97 e0       	ldi	r25, 0x07	; 7
    848c:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
    8490:	08 17       	cp	r16, r24
    8492:	19 07       	cpc	r17, r25
    8494:	19 f4       	brne	.+6      	; 0x849c <procMessage99+0x46a>
	        IsCompleteFilling=True;
    8496:	81 e0       	ldi	r24, 0x01	; 1
    8498:	80 93 a9 01 	sts	0x01A9, r24
	   }

	  }
     return Result;     
}
    849c:	80 e0       	ldi	r24, 0x00	; 0
    849e:	1f 91       	pop	r17
    84a0:	0f 91       	pop	r16
    84a2:	08 95       	ret

000084a4 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    84a4:	0f 93       	push	r16
    84a6:	1f 93       	push	r17
    84a8:	df 93       	push	r29
    84aa:	cf 93       	push	r28
    84ac:	00 d0       	rcall	.+0      	; 0x84ae <GetMessageID+0xa>
    84ae:	0f 92       	push	r0
    84b0:	cd b7       	in	r28, 0x3d	; 61
    84b2:	de b7       	in	r29, 0x3e	; 62
    84b4:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    84b6:	80 81       	ld	r24, Z
    84b8:	89 83       	std	Y+1, r24	; 0x01
    84ba:	81 81       	ldd	r24, Z+1	; 0x01
    84bc:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    84be:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    84c0:	8e 01       	movw	r16, r28
    84c2:	0f 5f       	subi	r16, 0xFF	; 255
    84c4:	1f 4f       	sbci	r17, 0xFF	; 255
    84c6:	c8 01       	movw	r24, r16
    84c8:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
	 Result=atoi(strMsgID);
    84cc:	c8 01       	movw	r24, r16
    84ce:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
  return Result;
}
    84d2:	0f 90       	pop	r0
    84d4:	0f 90       	pop	r0
    84d6:	0f 90       	pop	r0
    84d8:	cf 91       	pop	r28
    84da:	df 91       	pop	r29
    84dc:	1f 91       	pop	r17
    84de:	0f 91       	pop	r16
    84e0:	08 95       	ret

000084e2 <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    84e2:	1f 93       	push	r17
    84e4:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    84e6:	89 31       	cpi	r24, 0x19	; 25
    84e8:	59 f4       	brne	.+22     	; 0x8500 <SendPrint+0x1e>
	     if (zSend==xSendLead)uart(_COM_PRINTER,1,xSendLead);
    84ea:	40 91 f6 01 	lds	r20, 0x01F6
    84ee:	46 17       	cp	r20, r22
    84f0:	19 f4       	brne	.+6      	; 0x84f8 <SendPrint+0x16>
    84f2:	80 e0       	ldi	r24, 0x00	; 0
    84f4:	61 e0       	ldi	r22, 0x01	; 1
    84f6:	07 c0       	rjmp	.+14     	; 0x8506 <SendPrint+0x24>
		 else uart(_COM_PRINTER,1,' ');	 
    84f8:	80 e0       	ldi	r24, 0x00	; 0
    84fa:	61 e0       	ldi	r22, 0x01	; 1
    84fc:	40 e2       	ldi	r20, 0x20	; 32
    84fe:	03 c0       	rjmp	.+6      	; 0x8506 <SendPrint+0x24>
	 } 
	 else uart(_COM_PRINTER,1,xSend);
    8500:	80 e0       	ldi	r24, 0x00	; 0
    8502:	61 e0       	ldi	r22, 0x01	; 1
    8504:	41 2f       	mov	r20, r17
    8506:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
	 zSend=xSend;
    850a:	10 93 f6 01 	sts	0x01F6, r17
}
    850e:	1f 91       	pop	r17
    8510:	08 95       	ret

00008512 <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     uart(_COM_PRINTER, 1, 0x0D);     
    8512:	80 e0       	ldi	r24, 0x00	; 0
    8514:	61 e0       	ldi	r22, 0x01	; 1
    8516:	4d e0       	ldi	r20, 0x0D	; 13
    8518:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
     uart(_COM_PRINTER, 1, 0x0A);
    851c:	80 e0       	ldi	r24, 0x00	; 0
    851e:	61 e0       	ldi	r22, 0x01	; 1
    8520:	4a e0       	ldi	r20, 0x0A	; 10
    8522:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
}
    8526:	08 95       	ret

00008528 <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8528:	e1 99       	sbic	0x1c, 1	; 28
    852a:	fe cf       	rjmp	.-4      	; 0x8528 <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    852c:	80 e3       	ldi	r24, 0x30	; 48
    852e:	90 e0       	ldi	r25, 0x00	; 0
    8530:	9f bb       	out	0x1f, r25	; 31
    8532:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8534:	e0 9a       	sbi	0x1c, 0	; 28
    8536:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    8538:	81 30       	cpi	r24, 0x01	; 1
    853a:	71 f5       	brne	.+92     	; 0x8598 <InitPrinter+0x70>
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x7C);uart(_COM_PRINTER, 1, 0x00);
    853c:	80 e0       	ldi	r24, 0x00	; 0
    853e:	61 e0       	ldi	r22, 0x01	; 1
    8540:	4d e1       	ldi	r20, 0x1D	; 29
    8542:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    8546:	80 e0       	ldi	r24, 0x00	; 0
    8548:	61 e0       	ldi	r22, 0x01	; 1
    854a:	4c e7       	ldi	r20, 0x7C	; 124
    854c:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    8550:	80 e0       	ldi	r24, 0x00	; 0
    8552:	61 e0       	ldi	r22, 0x01	; 1
    8554:	40 e0       	ldi	r20, 0x00	; 0
    8556:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		//Double Strike ON : 1B 47 01
		uart(_COM_PRINTER, 1, 0x1B);uart(_COM_PRINTER, 1, 0x47);uart(_COM_PRINTER, 1, 0x01);
    855a:	80 e0       	ldi	r24, 0x00	; 0
    855c:	61 e0       	ldi	r22, 0x01	; 1
    855e:	4b e1       	ldi	r20, 0x1B	; 27
    8560:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    8564:	80 e0       	ldi	r24, 0x00	; 0
    8566:	61 e0       	ldi	r22, 0x01	; 1
    8568:	47 e4       	ldi	r20, 0x47	; 71
    856a:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    856e:	80 e0       	ldi	r24, 0x00	; 0
    8570:	61 e0       	ldi	r22, 0x01	; 1
    8572:	41 e0       	ldi	r20, 0x01	; 1
    8574:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x01);   
    8578:	80 e0       	ldi	r24, 0x00	; 0
    857a:	61 e0       	ldi	r22, 0x01	; 1
    857c:	4d e1       	ldi	r20, 0x1D	; 29
    857e:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    8582:	80 e0       	ldi	r24, 0x00	; 0
    8584:	61 e0       	ldi	r22, 0x01	; 1
    8586:	41 e2       	ldi	r20, 0x21	; 33
    8588:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    858c:	80 e0       	ldi	r24, 0x00	; 0
    858e:	61 e0       	ldi	r22, 0x01	; 1
    8590:	41 e0       	ldi	r20, 0x01	; 1
    8592:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    8596:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    8598:	82 30       	cpi	r24, 0x02	; 2
    859a:	69 f5       	brne	.+90     	; 0x85f6 <InitPrinter+0xce>
        //Print Density 0%
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x7C);uart(_COM_PRINTER, 1, 0x04);
    859c:	80 e0       	ldi	r24, 0x00	; 0
    859e:	61 e0       	ldi	r22, 0x01	; 1
    85a0:	4d e1       	ldi	r20, 0x1D	; 29
    85a2:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    85a6:	80 e0       	ldi	r24, 0x00	; 0
    85a8:	61 e0       	ldi	r22, 0x01	; 1
    85aa:	4c e7       	ldi	r20, 0x7C	; 124
    85ac:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    85b0:	80 e0       	ldi	r24, 0x00	; 0
    85b2:	61 e0       	ldi	r22, 0x01	; 1
    85b4:	44 e0       	ldi	r20, 0x04	; 4
    85b6:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		//Double Strike OFF : 1B 47 00
		uart(_COM_PRINTER, 1, 0x1B);uart(_COM_PRINTER, 1, 0x47);uart(_COM_PRINTER, 1, 0x00);
    85ba:	80 e0       	ldi	r24, 0x00	; 0
    85bc:	61 e0       	ldi	r22, 0x01	; 1
    85be:	4b e1       	ldi	r20, 0x1B	; 27
    85c0:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    85c4:	80 e0       	ldi	r24, 0x00	; 0
    85c6:	61 e0       	ldi	r22, 0x01	; 1
    85c8:	47 e4       	ldi	r20, 0x47	; 71
    85ca:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    85ce:	80 e0       	ldi	r24, 0x00	; 0
    85d0:	61 e0       	ldi	r22, 0x01	; 1
    85d2:	40 e0       	ldi	r20, 0x00	; 0
    85d4:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);   
    85d8:	80 e0       	ldi	r24, 0x00	; 0
    85da:	61 e0       	ldi	r22, 0x01	; 1
    85dc:	4d e1       	ldi	r20, 0x1D	; 29
    85de:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    85e2:	80 e0       	ldi	r24, 0x00	; 0
    85e4:	61 e0       	ldi	r22, 0x01	; 1
    85e6:	41 e2       	ldi	r20, 0x21	; 33
    85e8:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    85ec:	80 e0       	ldi	r24, 0x00	; 0
    85ee:	61 e0       	ldi	r22, 0x01	; 1
    85f0:	40 e0       	ldi	r20, 0x00	; 0
    85f2:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    85f6:	08 95       	ret

000085f8 <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    85f8:	e1 99       	sbic	0x1c, 1	; 28
    85fa:	fe cf       	rjmp	.-4      	; 0x85f8 <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    85fc:	80 e3       	ldi	r24, 0x30	; 48
    85fe:	90 e0       	ldi	r25, 0x00	; 0
    8600:	9f bb       	out	0x1f, r25	; 31
    8602:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8604:	e0 9a       	sbi	0x1c, 0	; 28
    8606:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    8608:	82 30       	cpi	r24, 0x02	; 2
    860a:	79 f4       	brne	.+30     	; 0x862a <PrintNormalHeight+0x32>
	     uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);
    860c:	80 e0       	ldi	r24, 0x00	; 0
    860e:	61 e0       	ldi	r22, 0x01	; 1
    8610:	4d e1       	ldi	r20, 0x1D	; 29
    8612:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    8616:	80 e0       	ldi	r24, 0x00	; 0
    8618:	61 e0       	ldi	r22, 0x01	; 1
    861a:	41 e2       	ldi	r20, 0x21	; 33
    861c:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    8620:	80 e0       	ldi	r24, 0x00	; 0
    8622:	61 e0       	ldi	r22, 0x01	; 1
    8624:	40 e0       	ldi	r20, 0x00	; 0
    8626:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    862a:	08 95       	ret

0000862c <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    862c:	e1 99       	sbic	0x1c, 1	; 28
    862e:	fe cf       	rjmp	.-4      	; 0x862c <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8630:	80 e3       	ldi	r24, 0x30	; 48
    8632:	90 e0       	ldi	r25, 0x00	; 0
    8634:	9f bb       	out	0x1f, r25	; 31
    8636:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8638:	e0 9a       	sbi	0x1c, 0	; 28
    863a:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    863c:	82 30       	cpi	r24, 0x02	; 2
    863e:	79 f4       	brne	.+30     	; 0x865e <PrintDoubleHeight+0x32>
	     uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x01);
    8640:	80 e0       	ldi	r24, 0x00	; 0
    8642:	61 e0       	ldi	r22, 0x01	; 1
    8644:	4d e1       	ldi	r20, 0x1D	; 29
    8646:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    864a:	80 e0       	ldi	r24, 0x00	; 0
    864c:	61 e0       	ldi	r22, 0x01	; 1
    864e:	41 e2       	ldi	r20, 0x21	; 33
    8650:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    8654:	80 e0       	ldi	r24, 0x00	; 0
    8656:	61 e0       	ldi	r22, 0x01	; 1
    8658:	41 e0       	ldi	r20, 0x01	; 1
    865a:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
    865e:	08 95       	ret

00008660 <PaperCut>:

	 return Result;
}


void PaperCut(){
    8660:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8662:	e1 99       	sbic	0x1c, 1	; 28
    8664:	fe cf       	rjmp	.-4      	; 0x8662 <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8666:	83 e3       	ldi	r24, 0x33	; 51
    8668:	90 e0       	ldi	r25, 0x00	; 0
    866a:	9f bb       	out	0x1f, r25	; 31
    866c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    866e:	e0 9a       	sbi	0x1c, 0	; 28
    8670:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&DefPrintAutoCut);
     uart(_COM_PRINTER, 1, 0x1B);
    8672:	80 e0       	ldi	r24, 0x00	; 0
    8674:	61 e0       	ldi	r22, 0x01	; 1
    8676:	4b e1       	ldi	r20, 0x1B	; 27
    8678:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
	 if(CutType== 1) { uart(_COM_PRINTER, 1, 0x6D);}
    867c:	11 30       	cpi	r17, 0x01	; 1
    867e:	21 f4       	brne	.+8      	; 0x8688 <PaperCut+0x28>
    8680:	80 e0       	ldi	r24, 0x00	; 0
    8682:	61 e0       	ldi	r22, 0x01	; 1
    8684:	4d e6       	ldi	r20, 0x6D	; 109
    8686:	05 c0       	rjmp	.+10     	; 0x8692 <PaperCut+0x32>
	 if(CutType== 2) {uart(_COM_PRINTER, 1, 0x69);}
    8688:	12 30       	cpi	r17, 0x02	; 2
    868a:	29 f4       	brne	.+10     	; 0x8696 <PaperCut+0x36>
    868c:	80 e0       	ldi	r24, 0x00	; 0
    868e:	61 e0       	ldi	r22, 0x01	; 1
    8690:	49 e6       	ldi	r20, 0x69	; 105
    8692:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>

}
    8696:	1f 91       	pop	r17
    8698:	08 95       	ret

0000869a <procMessage11>:
}




void procMessage11(){
    869a:	af 92       	push	r10
    869c:	bf 92       	push	r11
    869e:	cf 92       	push	r12
    86a0:	df 92       	push	r13
    86a2:	ef 92       	push	r14
    86a4:	ff 92       	push	r15
    86a6:	0f 93       	push	r16
    86a8:	1f 93       	push	r17
    86aa:	df 93       	push	r29
    86ac:	cf 93       	push	r28
    86ae:	cd b7       	in	r28, 0x3d	; 61
    86b0:	de b7       	in	r29, 0x3e	; 62
    86b2:	c5 55       	subi	r28, 0x55	; 85
    86b4:	d0 40       	sbci	r29, 0x00	; 0
    86b6:	0f b6       	in	r0, 0x3f	; 63
    86b8:	f8 94       	cli
    86ba:	de bf       	out	0x3e, r29	; 62
    86bc:	0f be       	out	0x3f, r0	; 63
    86be:	cd bf       	out	0x3d, r28	; 61
    86c0:	20 e0       	ldi	r18, 0x00	; 0
    86c2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86c4:	ae 01       	movw	r20, r28
    86c6:	46 5f       	subi	r20, 0xF6	; 246
    86c8:	5f 4f       	sbci	r21, 0xFF	; 255
    86ca:	fa 01       	movw	r30, r20
    86cc:	e2 0f       	add	r30, r18
    86ce:	f3 1f       	adc	r31, r19
    86d0:	d9 01       	movw	r26, r18
    86d2:	a3 5e       	subi	r26, 0xE3	; 227
    86d4:	b6 4f       	sbci	r27, 0xF6	; 246
    86d6:	9b 96       	adiw	r26, 0x2b	; 43
    86d8:	8c 91       	ld	r24, X
    86da:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86dc:	2f 5f       	subi	r18, 0xFF	; 255
    86de:	3f 4f       	sbci	r19, 0xFF	; 255
    86e0:	2a 30       	cpi	r18, 0x0A	; 10
    86e2:	31 05       	cpc	r19, r1
    86e4:	91 f7       	brne	.-28     	; 0x86ca <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86e6:	fa 01       	movw	r30, r20
    86e8:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    86ea:	81 e0       	ldi	r24, 0x01	; 1
    86ec:	ba 01       	movw	r22, r20
    86ee:	0e 94 ee 22 	call	0x45dc	; 0x45dc <FormatDate>
    86f2:	20 e0       	ldi	r18, 0x00	; 0
    86f4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86f6:	ae 01       	movw	r20, r28
    86f8:	4c 5e       	subi	r20, 0xEC	; 236
    86fa:	5f 4f       	sbci	r21, 0xFF	; 255
    86fc:	fa 01       	movw	r30, r20
    86fe:	e2 0f       	add	r30, r18
    8700:	f3 1f       	adc	r31, r19
    8702:	d9 01       	movw	r26, r18
    8704:	a3 5e       	subi	r26, 0xE3	; 227
    8706:	b6 4f       	sbci	r27, 0xF6	; 246
    8708:	d6 96       	adiw	r26, 0x36	; 54
    870a:	8c 91       	ld	r24, X
    870c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    870e:	2f 5f       	subi	r18, 0xFF	; 255
    8710:	3f 4f       	sbci	r19, 0xFF	; 255
    8712:	28 30       	cpi	r18, 0x08	; 8
    8714:	31 05       	cpc	r19, r1
    8716:	91 f7       	brne	.-28     	; 0x86fc <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8718:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    871a:	81 e0       	ldi	r24, 0x01	; 1
    871c:	be 01       	movw	r22, r28
    871e:	66 5f       	subi	r22, 0xF6	; 246
    8720:	7f 4f       	sbci	r23, 0xFF	; 255
    8722:	0e 94 4a a7 	call	0x14e94	; 0x14e94 <_datetime>
	  
     clearString(buffHeader);
    8726:	8e 01       	movw	r16, r28
    8728:	03 5d       	subi	r16, 0xD3	; 211
    872a:	1f 4f       	sbci	r17, 0xFF	; 255
    872c:	c8 01       	movw	r24, r16
    872e:	0e 94 a9 24 	call	0x4952	; 0x4952 <clearString>
    8732:	20 e0       	ldi	r18, 0x00	; 0
    8734:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8736:	f8 01       	movw	r30, r16
    8738:	e2 0f       	add	r30, r18
    873a:	f3 1f       	adc	r31, r19
    873c:	d9 01       	movw	r26, r18
    873e:	a3 5e       	subi	r26, 0xE3	; 227
    8740:	b6 4f       	sbci	r27, 0xF6	; 246
    8742:	de 96       	adiw	r26, 0x3e	; 62
    8744:	8c 91       	ld	r24, X
    8746:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8748:	2f 5f       	subi	r18, 0xFF	; 255
    874a:	3f 4f       	sbci	r19, 0xFF	; 255
    874c:	28 32       	cpi	r18, 0x28	; 40
    874e:	31 05       	cpc	r19, r1
    8750:	91 f7       	brne	.-28     	; 0x8736 <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8752:	fe 01       	movw	r30, r28
    8754:	eb 5a       	subi	r30, 0xAB	; 171
    8756:	ff 4f       	sbci	r31, 0xFF	; 255
    8758:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    875a:	87 e2       	ldi	r24, 0x27	; 39
    875c:	92 e0       	ldi	r25, 0x02	; 2
    875e:	b8 01       	movw	r22, r16
    8760:	48 e2       	ldi	r20, 0x28	; 40
    8762:	50 e0       	ldi	r21, 0x00	; 0
    8764:	2c e4       	ldi	r18, 0x4C	; 76
    8766:	32 e1       	ldi	r19, 0x12	; 18
    8768:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    876c:	20 e0       	ldi	r18, 0x00	; 0
    876e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8770:	be 01       	movw	r22, r28
    8772:	63 5d       	subi	r22, 0xD3	; 211
    8774:	7f 4f       	sbci	r23, 0xFF	; 255
    8776:	fb 01       	movw	r30, r22
    8778:	e2 0f       	add	r30, r18
    877a:	f3 1f       	adc	r31, r19
    877c:	d9 01       	movw	r26, r18
    877e:	ad 57       	subi	r26, 0x7D	; 125
    8780:	b6 4f       	sbci	r27, 0xF6	; 246
    8782:	8c 91       	ld	r24, X
    8784:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8786:	2f 5f       	subi	r18, 0xFF	; 255
    8788:	3f 4f       	sbci	r19, 0xFF	; 255
    878a:	28 32       	cpi	r18, 0x28	; 40
    878c:	31 05       	cpc	r19, r1
    878e:	99 f7       	brne	.-26     	; 0x8776 <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8790:	fe 01       	movw	r30, r28
    8792:	eb 5a       	subi	r30, 0xAB	; 171
    8794:	ff 4f       	sbci	r31, 0xFF	; 255
    8796:	10 82       	st	Z, r1
    8798:	80 e5       	ldi	r24, 0x50	; 80
    879a:	92 e0       	ldi	r25, 0x02	; 2
    879c:	48 e2       	ldi	r20, 0x28	; 40
    879e:	50 e0       	ldi	r21, 0x00	; 0
    87a0:	2c e4       	ldi	r18, 0x4C	; 76
    87a2:	32 e1       	ldi	r19, 0x12	; 18
    87a4:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    87a8:	20 e0       	ldi	r18, 0x00	; 0
    87aa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87ac:	be 01       	movw	r22, r28
    87ae:	63 5d       	subi	r22, 0xD3	; 211
    87b0:	7f 4f       	sbci	r23, 0xFF	; 255
    87b2:	fb 01       	movw	r30, r22
    87b4:	e2 0f       	add	r30, r18
    87b6:	f3 1f       	adc	r31, r19
    87b8:	d9 01       	movw	r26, r18
    87ba:	a5 55       	subi	r26, 0x55	; 85
    87bc:	b6 4f       	sbci	r27, 0xF6	; 246
    87be:	8c 91       	ld	r24, X
    87c0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87c2:	2f 5f       	subi	r18, 0xFF	; 255
    87c4:	3f 4f       	sbci	r19, 0xFF	; 255
    87c6:	28 32       	cpi	r18, 0x28	; 40
    87c8:	31 05       	cpc	r19, r1
    87ca:	99 f7       	brne	.-26     	; 0x87b2 <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87cc:	fe 01       	movw	r30, r28
    87ce:	eb 5a       	subi	r30, 0xAB	; 171
    87d0:	ff 4f       	sbci	r31, 0xFF	; 255
    87d2:	10 82       	st	Z, r1
    87d4:	89 e7       	ldi	r24, 0x79	; 121
    87d6:	92 e0       	ldi	r25, 0x02	; 2
    87d8:	48 e2       	ldi	r20, 0x28	; 40
    87da:	50 e0       	ldi	r21, 0x00	; 0
    87dc:	2c e4       	ldi	r18, 0x4C	; 76
    87de:	32 e1       	ldi	r19, 0x12	; 18
    87e0:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    87e4:	20 e0       	ldi	r18, 0x00	; 0
    87e6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87e8:	be 01       	movw	r22, r28
    87ea:	63 5d       	subi	r22, 0xD3	; 211
    87ec:	7f 4f       	sbci	r23, 0xFF	; 255
    87ee:	fb 01       	movw	r30, r22
    87f0:	e2 0f       	add	r30, r18
    87f2:	f3 1f       	adc	r31, r19
    87f4:	d9 01       	movw	r26, r18
    87f6:	ad 52       	subi	r26, 0x2D	; 45
    87f8:	b6 4f       	sbci	r27, 0xF6	; 246
    87fa:	8c 91       	ld	r24, X
    87fc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87fe:	2f 5f       	subi	r18, 0xFF	; 255
    8800:	3f 4f       	sbci	r19, 0xFF	; 255
    8802:	28 32       	cpi	r18, 0x28	; 40
    8804:	31 05       	cpc	r19, r1
    8806:	99 f7       	brne	.-26     	; 0x87ee <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8808:	fe 01       	movw	r30, r28
    880a:	eb 5a       	subi	r30, 0xAB	; 171
    880c:	ff 4f       	sbci	r31, 0xFF	; 255
    880e:	10 82       	st	Z, r1
    8810:	82 ea       	ldi	r24, 0xA2	; 162
    8812:	92 e0       	ldi	r25, 0x02	; 2
    8814:	48 e2       	ldi	r20, 0x28	; 40
    8816:	50 e0       	ldi	r21, 0x00	; 0
    8818:	2c e4       	ldi	r18, 0x4C	; 76
    881a:	32 e1       	ldi	r19, 0x12	; 18
    881c:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    8820:	20 e0       	ldi	r18, 0x00	; 0
    8822:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8824:	be 01       	movw	r22, r28
    8826:	63 5d       	subi	r22, 0xD3	; 211
    8828:	7f 4f       	sbci	r23, 0xFF	; 255
    882a:	fb 01       	movw	r30, r22
    882c:	e2 0f       	add	r30, r18
    882e:	f3 1f       	adc	r31, r19
    8830:	d9 01       	movw	r26, r18
    8832:	a5 50       	subi	r26, 0x05	; 5
    8834:	b6 4f       	sbci	r27, 0xF6	; 246
    8836:	8c 91       	ld	r24, X
    8838:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    883a:	2f 5f       	subi	r18, 0xFF	; 255
    883c:	3f 4f       	sbci	r19, 0xFF	; 255
    883e:	28 32       	cpi	r18, 0x28	; 40
    8840:	31 05       	cpc	r19, r1
    8842:	99 f7       	brne	.-26     	; 0x882a <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8844:	fe 01       	movw	r30, r28
    8846:	eb 5a       	subi	r30, 0xAB	; 171
    8848:	ff 4f       	sbci	r31, 0xFF	; 255
    884a:	10 82       	st	Z, r1
    884c:	8b ec       	ldi	r24, 0xCB	; 203
    884e:	92 e0       	ldi	r25, 0x02	; 2
    8850:	48 e2       	ldi	r20, 0x28	; 40
    8852:	50 e0       	ldi	r21, 0x00	; 0
    8854:	2c e4       	ldi	r18, 0x4C	; 76
    8856:	32 e1       	ldi	r19, 0x12	; 18
    8858:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    885c:	20 e0       	ldi	r18, 0x00	; 0
    885e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8860:	be 01       	movw	r22, r28
    8862:	63 5d       	subi	r22, 0xD3	; 211
    8864:	7f 4f       	sbci	r23, 0xFF	; 255
    8866:	fb 01       	movw	r30, r22
    8868:	e2 0f       	add	r30, r18
    886a:	f3 1f       	adc	r31, r19
    886c:	d9 01       	movw	r26, r18
    886e:	ad 5d       	subi	r26, 0xDD	; 221
    8870:	b5 4f       	sbci	r27, 0xF5	; 245
    8872:	8c 91       	ld	r24, X
    8874:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8876:	2f 5f       	subi	r18, 0xFF	; 255
    8878:	3f 4f       	sbci	r19, 0xFF	; 255
    887a:	28 32       	cpi	r18, 0x28	; 40
    887c:	31 05       	cpc	r19, r1
    887e:	99 f7       	brne	.-26     	; 0x8866 <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8880:	fe 01       	movw	r30, r28
    8882:	eb 5a       	subi	r30, 0xAB	; 171
    8884:	ff 4f       	sbci	r31, 0xFF	; 255
    8886:	10 82       	st	Z, r1
    8888:	84 ef       	ldi	r24, 0xF4	; 244
    888a:	92 e0       	ldi	r25, 0x02	; 2
    888c:	48 e2       	ldi	r20, 0x28	; 40
    888e:	50 e0       	ldi	r21, 0x00	; 0
    8890:	2c e4       	ldi	r18, 0x4C	; 76
    8892:	32 e1       	ldi	r19, 0x12	; 18
    8894:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    8898:	20 e0       	ldi	r18, 0x00	; 0
    889a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    889c:	be 01       	movw	r22, r28
    889e:	63 5d       	subi	r22, 0xD3	; 211
    88a0:	7f 4f       	sbci	r23, 0xFF	; 255
    88a2:	fb 01       	movw	r30, r22
    88a4:	e2 0f       	add	r30, r18
    88a6:	f3 1f       	adc	r31, r19
    88a8:	d9 01       	movw	r26, r18
    88aa:	a5 5b       	subi	r26, 0xB5	; 181
    88ac:	b5 4f       	sbci	r27, 0xF5	; 245
    88ae:	8c 91       	ld	r24, X
    88b0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    88b2:	2f 5f       	subi	r18, 0xFF	; 255
    88b4:	3f 4f       	sbci	r19, 0xFF	; 255
    88b6:	28 32       	cpi	r18, 0x28	; 40
    88b8:	31 05       	cpc	r19, r1
    88ba:	99 f7       	brne	.-26     	; 0x88a2 <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    88bc:	fe 01       	movw	r30, r28
    88be:	eb 5a       	subi	r30, 0xAB	; 171
    88c0:	ff 4f       	sbci	r31, 0xFF	; 255
    88c2:	10 82       	st	Z, r1
    88c4:	8d e1       	ldi	r24, 0x1D	; 29
    88c6:	93 e0       	ldi	r25, 0x03	; 3
    88c8:	48 e2       	ldi	r20, 0x28	; 40
    88ca:	50 e0       	ldi	r21, 0x00	; 0
    88cc:	2c e4       	ldi	r18, 0x4C	; 76
    88ce:	32 e1       	ldi	r19, 0x12	; 18
    88d0:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    88d4:	20 e0       	ldi	r18, 0x00	; 0
    88d6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    88d8:	be 01       	movw	r22, r28
    88da:	63 5d       	subi	r22, 0xD3	; 211
    88dc:	7f 4f       	sbci	r23, 0xFF	; 255
    88de:	fb 01       	movw	r30, r22
    88e0:	e2 0f       	add	r30, r18
    88e2:	f3 1f       	adc	r31, r19
    88e4:	d9 01       	movw	r26, r18
    88e6:	ad 58       	subi	r26, 0x8D	; 141
    88e8:	b5 4f       	sbci	r27, 0xF5	; 245
    88ea:	8c 91       	ld	r24, X
    88ec:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    88ee:	2f 5f       	subi	r18, 0xFF	; 255
    88f0:	3f 4f       	sbci	r19, 0xFF	; 255
    88f2:	28 32       	cpi	r18, 0x28	; 40
    88f4:	31 05       	cpc	r19, r1
    88f6:	99 f7       	brne	.-26     	; 0x88de <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    88f8:	fe 01       	movw	r30, r28
    88fa:	eb 5a       	subi	r30, 0xAB	; 171
    88fc:	ff 4f       	sbci	r31, 0xFF	; 255
    88fe:	10 82       	st	Z, r1
    8900:	86 e4       	ldi	r24, 0x46	; 70
    8902:	93 e0       	ldi	r25, 0x03	; 3
    8904:	48 e2       	ldi	r20, 0x28	; 40
    8906:	50 e0       	ldi	r21, 0x00	; 0
    8908:	2c e4       	ldi	r18, 0x4C	; 76
    890a:	32 e1       	ldi	r19, 0x12	; 18
    890c:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    8910:	20 e0       	ldi	r18, 0x00	; 0
    8912:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8914:	be 01       	movw	r22, r28
    8916:	63 5d       	subi	r22, 0xD3	; 211
    8918:	7f 4f       	sbci	r23, 0xFF	; 255
    891a:	fb 01       	movw	r30, r22
    891c:	e2 0f       	add	r30, r18
    891e:	f3 1f       	adc	r31, r19
    8920:	d9 01       	movw	r26, r18
    8922:	a5 56       	subi	r26, 0x65	; 101
    8924:	b5 4f       	sbci	r27, 0xF5	; 245
    8926:	8c 91       	ld	r24, X
    8928:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    892a:	2f 5f       	subi	r18, 0xFF	; 255
    892c:	3f 4f       	sbci	r19, 0xFF	; 255
    892e:	28 32       	cpi	r18, 0x28	; 40
    8930:	31 05       	cpc	r19, r1
    8932:	99 f7       	brne	.-26     	; 0x891a <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8934:	fe 01       	movw	r30, r28
    8936:	eb 5a       	subi	r30, 0xAB	; 171
    8938:	ff 4f       	sbci	r31, 0xFF	; 255
    893a:	10 82       	st	Z, r1
    893c:	8f e6       	ldi	r24, 0x6F	; 111
    893e:	93 e0       	ldi	r25, 0x03	; 3
    8940:	48 e2       	ldi	r20, 0x28	; 40
    8942:	50 e0       	ldi	r21, 0x00	; 0
    8944:	2c e4       	ldi	r18, 0x4C	; 76
    8946:	32 e1       	ldi	r19, 0x12	; 18
    8948:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    894c:	20 e0       	ldi	r18, 0x00	; 0
    894e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8950:	be 01       	movw	r22, r28
    8952:	63 5d       	subi	r22, 0xD3	; 211
    8954:	7f 4f       	sbci	r23, 0xFF	; 255
    8956:	fb 01       	movw	r30, r22
    8958:	e2 0f       	add	r30, r18
    895a:	f3 1f       	adc	r31, r19
    895c:	d9 01       	movw	r26, r18
    895e:	ad 53       	subi	r26, 0x3D	; 61
    8960:	b5 4f       	sbci	r27, 0xF5	; 245
    8962:	8c 91       	ld	r24, X
    8964:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8966:	2f 5f       	subi	r18, 0xFF	; 255
    8968:	3f 4f       	sbci	r19, 0xFF	; 255
    896a:	28 32       	cpi	r18, 0x28	; 40
    896c:	31 05       	cpc	r19, r1
    896e:	99 f7       	brne	.-26     	; 0x8956 <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8970:	fe 01       	movw	r30, r28
    8972:	eb 5a       	subi	r30, 0xAB	; 171
    8974:	ff 4f       	sbci	r31, 0xFF	; 255
    8976:	10 82       	st	Z, r1
    8978:	88 e9       	ldi	r24, 0x98	; 152
    897a:	93 e0       	ldi	r25, 0x03	; 3
    897c:	48 e2       	ldi	r20, 0x28	; 40
    897e:	50 e0       	ldi	r21, 0x00	; 0
    8980:	2c e4       	ldi	r18, 0x4C	; 76
    8982:	32 e1       	ldi	r19, 0x12	; 18
    8984:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    8988:	0b eb       	ldi	r16, 0xBB	; 187
    898a:	10 e0       	ldi	r17, 0x00	; 0
    898c:	33 e0       	ldi	r19, 0x03	; 3
    898e:	e3 2e       	mov	r14, r19
    8990:	3b e0       	ldi	r19, 0x0B	; 11
    8992:	f3 2e       	mov	r15, r19
    8994:	20 e2       	ldi	r18, 0x20	; 32
    8996:	c2 2e       	mov	r12, r18
    8998:	d1 2c       	mov	r13, r1
    899a:	cc 0e       	add	r12, r28
    899c:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    899e:	9c e2       	ldi	r25, 0x2C	; 44
    89a0:	a9 2e       	mov	r10, r25
    89a2:	b1 2c       	mov	r11, r1
    89a4:	ac 0e       	add	r10, r28
    89a6:	bd 1e       	adc	r11, r29
    89a8:	f6 01       	movw	r30, r12
    89aa:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    89ac:	8d 91       	ld	r24, X+
    89ae:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    89b0:	ea 15       	cp	r30, r10
    89b2:	fb 05       	cpc	r31, r11
    89b4:	d9 f7       	brne	.-10     	; 0x89ac <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    89b6:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    89b8:	c6 01       	movw	r24, r12
    89ba:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
    89be:	c8 01       	movw	r24, r16
    89c0:	b6 01       	movw	r22, r12
    89c2:	4c e0       	ldi	r20, 0x0C	; 12
    89c4:	50 e0       	ldi	r21, 0x00	; 0
    89c6:	2c e4       	ldi	r18, 0x4C	; 76
    89c8:	32 e1       	ldi	r19, 0x12	; 18
    89ca:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    89ce:	03 5f       	subi	r16, 0xF3	; 243
    89d0:	1f 4f       	sbci	r17, 0xFF	; 255
    89d2:	8c e0       	ldi	r24, 0x0C	; 12
    89d4:	90 e0       	ldi	r25, 0x00	; 0
    89d6:	e8 0e       	add	r14, r24
    89d8:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    89da:	91 e0       	ldi	r25, 0x01	; 1
    89dc:	09 30       	cpi	r16, 0x09	; 9
    89de:	19 07       	cpc	r17, r25
    89e0:	19 f7       	brne	.-58     	; 0x89a8 <procMessage11+0x30e>
    89e2:	05 e8       	ldi	r16, 0x85	; 133
    89e4:	10 e0       	ldi	r17, 0x00	; 0
    89e6:	8b e4       	ldi	r24, 0x4B	; 75
    89e8:	e8 2e       	mov	r14, r24
    89ea:	8b e0       	ldi	r24, 0x0B	; 11
    89ec:	f8 2e       	mov	r15, r24
    89ee:	6e 01       	movw	r12, r28
    89f0:	08 94       	sec
    89f2:	c1 1c       	adc	r12, r1
    89f4:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    89f6:	b9 e0       	ldi	r27, 0x09	; 9
    89f8:	ab 2e       	mov	r10, r27
    89fa:	b1 2c       	mov	r11, r1
    89fc:	ac 0e       	add	r10, r28
    89fe:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    8a00:	f6 01       	movw	r30, r12
    8a02:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8a04:	8d 91       	ld	r24, X+
    8a06:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8a08:	ea 15       	cp	r30, r10
    8a0a:	fb 05       	cpc	r31, r11
    8a0c:	d9 f7       	brne	.-10     	; 0x8a04 <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8a0e:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    8a10:	c6 01       	movw	r24, r12
    8a12:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    8a16:	c6 01       	movw	r24, r12
    8a18:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		RemDecimal(strProductPrice);
    8a1c:	c6 01       	movw	r24, r12
    8a1e:	0e 94 37 22 	call	0x446e	; 0x446e <RemDecimal>
    8a22:	c8 01       	movw	r24, r16
    8a24:	b6 01       	movw	r22, r12
    8a26:	48 e0       	ldi	r20, 0x08	; 8
    8a28:	50 e0       	ldi	r21, 0x00	; 0
    8a2a:	2c e4       	ldi	r18, 0x4C	; 76
    8a2c:	32 e1       	ldi	r19, 0x12	; 18
    8a2e:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    8a32:	07 5f       	subi	r16, 0xF7	; 247
    8a34:	1f 4f       	sbci	r17, 0xFF	; 255
    8a36:	e8 e0       	ldi	r30, 0x08	; 8
    8a38:	f0 e0       	ldi	r31, 0x00	; 0
    8a3a:	ee 0e       	add	r14, r30
    8a3c:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    8a3e:	f0 e0       	ldi	r31, 0x00	; 0
    8a40:	0b 3b       	cpi	r16, 0xBB	; 187
    8a42:	1f 07       	cpc	r17, r31
    8a44:	e9 f6       	brne	.-70     	; 0x8a00 <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    8a46:	cb 5a       	subi	r28, 0xAB	; 171
    8a48:	df 4f       	sbci	r29, 0xFF	; 255
    8a4a:	0f b6       	in	r0, 0x3f	; 63
    8a4c:	f8 94       	cli
    8a4e:	de bf       	out	0x3e, r29	; 62
    8a50:	0f be       	out	0x3f, r0	; 63
    8a52:	cd bf       	out	0x3d, r28	; 61
    8a54:	cf 91       	pop	r28
    8a56:	df 91       	pop	r29
    8a58:	1f 91       	pop	r17
    8a5a:	0f 91       	pop	r16
    8a5c:	ff 90       	pop	r15
    8a5e:	ef 90       	pop	r14
    8a60:	df 90       	pop	r13
    8a62:	cf 90       	pop	r12
    8a64:	bf 90       	pop	r11
    8a66:	af 90       	pop	r10
    8a68:	08 95       	ret

00008a6a <_scr_pump>:

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    8a6a:	8f 92       	push	r8
    8a6c:	9f 92       	push	r9
    8a6e:	af 92       	push	r10
    8a70:	bf 92       	push	r11
    8a72:	cf 92       	push	r12
    8a74:	df 92       	push	r13
    8a76:	ef 92       	push	r14
    8a78:	ff 92       	push	r15
    8a7a:	0f 93       	push	r16
    8a7c:	1f 93       	push	r17
    8a7e:	df 93       	push	r29
    8a80:	cf 93       	push	r28
    8a82:	cd b7       	in	r28, 0x3d	; 61
    8a84:	de b7       	in	r29, 0x3e	; 62
    8a86:	6c 97       	sbiw	r28, 0x1c	; 28
    8a88:	0f b6       	in	r0, 0x3f	; 63
    8a8a:	f8 94       	cli
    8a8c:	de bf       	out	0x3e, r29	; 62
    8a8e:	0f be       	out	0x3f, r0	; 63
    8a90:	cd bf       	out	0x3d, r28	; 61
	 //char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    8a92:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    8a96:	84 ec       	ldi	r24, 0xC4	; 196
    8a98:	99 e0       	ldi	r25, 0x09	; 9
    8a9a:	01 97       	sbiw	r24, 0x01	; 1
    8a9c:	f1 f7       	brne	.-4      	; 0x8a9a <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8a9e:	8e 01       	movw	r16, r28
    8aa0:	0f 5f       	subi	r16, 0xFF	; 255
    8aa2:	1f 4f       	sbci	r17, 0xFF	; 255
    8aa4:	c8 01       	movw	r24, r16
    8aa6:	65 e4       	ldi	r22, 0x45	; 69
    8aa8:	70 e0       	ldi	r23, 0x00	; 0
    8aaa:	48 e0       	ldi	r20, 0x08	; 8
    8aac:	50 e0       	ldi	r21, 0x00	; 0
    8aae:	24 e4       	ldi	r18, 0x44	; 68
    8ab0:	32 e1       	ldi	r19, 0x12	; 18
    8ab2:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    8ab6:	78 01       	movw	r14, r16
    8ab8:	01 e0       	ldi	r16, 0x01	; 1
    8aba:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8abc:	69 e0       	ldi	r22, 0x09	; 9
    8abe:	c6 2e       	mov	r12, r22
    8ac0:	d1 2c       	mov	r13, r1
    8ac2:	cc 0e       	add	r12, r28
    8ac4:	dd 1e       	adc	r13, r29
    8ac6:	5f eb       	ldi	r21, 0xBF	; 191
    8ac8:	85 2e       	mov	r8, r21
    8aca:	5c e0       	ldi	r21, 0x0C	; 12
    8acc:	95 2e       	mov	r9, r21
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8ace:	45 e0       	ldi	r20, 0x05	; 5
    8ad0:	a4 2e       	mov	r10, r20
    8ad2:	b1 2c       	mov	r11, r1
    8ad4:	ac 0e       	add	r10, r28
    8ad6:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8ad8:	8d b7       	in	r24, 0x3d	; 61
    8ada:	9e b7       	in	r25, 0x3e	; 62
    8adc:	0c 97       	sbiw	r24, 0x0c	; 12
    8ade:	0f b6       	in	r0, 0x3f	; 63
    8ae0:	f8 94       	cli
    8ae2:	9e bf       	out	0x3e, r25	; 62
    8ae4:	0f be       	out	0x3f, r0	; 63
    8ae6:	8d bf       	out	0x3d, r24	; 61
    8ae8:	ed b7       	in	r30, 0x3d	; 61
    8aea:	fe b7       	in	r31, 0x3e	; 62
    8aec:	31 96       	adiw	r30, 0x01	; 1
    8aee:	ad b7       	in	r26, 0x3d	; 61
    8af0:	be b7       	in	r27, 0x3e	; 62
    8af2:	12 96       	adiw	r26, 0x02	; 2
    8af4:	dc 92       	st	X, r13
    8af6:	ce 92       	st	-X, r12
    8af8:	11 97       	sbiw	r26, 0x01	; 1
    8afa:	93 82       	std	Z+3, r9	; 0x03
    8afc:	82 82       	std	Z+2, r8	; 0x02
    8afe:	15 83       	std	Z+5, r17	; 0x05
    8b00:	04 83       	std	Z+4, r16	; 0x04
    8b02:	d7 01       	movw	r26, r14
    8b04:	8c 91       	ld	r24, X
    8b06:	86 83       	std	Z+6, r24	; 0x06
    8b08:	17 82       	std	Z+7, r1	; 0x07
    8b0a:	0c 5f       	subi	r16, 0xFC	; 252
    8b0c:	1f 4f       	sbci	r17, 0xFF	; 255
    8b0e:	11 87       	std	Z+9, r17	; 0x09
    8b10:	00 87       	std	Z+8, r16	; 0x08
    8b12:	04 50       	subi	r16, 0x04	; 4
    8b14:	10 40       	sbci	r17, 0x00	; 0
    8b16:	14 96       	adiw	r26, 0x04	; 4
    8b18:	8c 91       	ld	r24, X
    8b1a:	82 87       	std	Z+10, r24	; 0x0a
    8b1c:	13 86       	std	Z+11, r1	; 0x0b
    8b1e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    8b22:	8d b7       	in	r24, 0x3d	; 61
    8b24:	9e b7       	in	r25, 0x3e	; 62
    8b26:	0c 96       	adiw	r24, 0x0c	; 12
    8b28:	0f b6       	in	r0, 0x3f	; 63
    8b2a:	f8 94       	cli
    8b2c:	9e bf       	out	0x3e, r25	; 62
    8b2e:	0f be       	out	0x3f, r0	; 63
    8b30:	8d bf       	out	0x3d, r24	; 61
    8b32:	80 2f       	mov	r24, r16
    8b34:	61 e0       	ldi	r22, 0x01	; 1
    8b36:	a6 01       	movw	r20, r12
    8b38:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    8b3c:	08 94       	sec
    8b3e:	e1 1c       	adc	r14, r1
    8b40:	f1 1c       	adc	r15, r1
    8b42:	0f 5f       	subi	r16, 0xFF	; 255
    8b44:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8b46:	ea 14       	cp	r14, r10
    8b48:	fb 04       	cpc	r15, r11
    8b4a:	31 f6       	brne	.-116    	; 0x8ad8 <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    8b4c:	84 e0       	ldi	r24, 0x04	; 4
    8b4e:	6f e0       	ldi	r22, 0x0F	; 15
    8b50:	48 eb       	ldi	r20, 0xB8	; 184
    8b52:	5c e0       	ldi	r21, 0x0C	; 12
    8b54:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
}
    8b58:	6c 96       	adiw	r28, 0x1c	; 28
    8b5a:	0f b6       	in	r0, 0x3f	; 63
    8b5c:	f8 94       	cli
    8b5e:	de bf       	out	0x3e, r29	; 62
    8b60:	0f be       	out	0x3f, r0	; 63
    8b62:	cd bf       	out	0x3d, r28	; 61
    8b64:	cf 91       	pop	r28
    8b66:	df 91       	pop	r29
    8b68:	1f 91       	pop	r17
    8b6a:	0f 91       	pop	r16
    8b6c:	ff 90       	pop	r15
    8b6e:	ef 90       	pop	r14
    8b70:	df 90       	pop	r13
    8b72:	cf 90       	pop	r12
    8b74:	bf 90       	pop	r11
    8b76:	af 90       	pop	r10
    8b78:	9f 90       	pop	r9
    8b7a:	8f 90       	pop	r8
    8b7c:	08 95       	ret

00008b7e <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    8b7e:	80 91 6d 02 	lds	r24, 0x026D
    8b82:	81 30       	cpi	r24, 0x01	; 1
    8b84:	49 f0       	breq	.+18     	; 0x8b98 <FViewFreeMessage+0x1a>
    8b86:	81 30       	cpi	r24, 0x01	; 1
    8b88:	28 f0       	brcs	.+10     	; 0x8b94 <FViewFreeMessage+0x16>
    8b8a:	82 30       	cpi	r24, 0x02	; 2
    8b8c:	19 f1       	breq	.+70     	; 0x8bd4 <FViewFreeMessage+0x56>
    8b8e:	83 30       	cpi	r24, 0x03	; 3
    8b90:	71 f5       	brne	.+92     	; 0x8bee <FViewFreeMessage+0x70>
    8b92:	29 c0       	rjmp	.+82     	; 0x8be6 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    8b94:	81 e0       	ldi	r24, 0x01	; 1
    8b96:	23 c0       	rjmp	.+70     	; 0x8bde <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    8b98:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    8b9c:	81 e0       	ldi	r24, 0x01	; 1
    8b9e:	61 e0       	ldi	r22, 0x01	; 1
    8ba0:	42 e9       	ldi	r20, 0x92	; 146
    8ba2:	58 e0       	ldi	r21, 0x08	; 8
    8ba4:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    8ba8:	82 e0       	ldi	r24, 0x02	; 2
    8baa:	61 e0       	ldi	r22, 0x01	; 1
    8bac:	43 ea       	ldi	r20, 0xA3	; 163
    8bae:	57 e0       	ldi	r21, 0x07	; 7
    8bb0:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    8bb4:	83 e0       	ldi	r24, 0x03	; 3
    8bb6:	61 e0       	ldi	r22, 0x01	; 1
    8bb8:	4c e1       	ldi	r20, 0x1C	; 28
    8bba:	58 e0       	ldi	r21, 0x08	; 8
    8bbc:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    8bc0:	84 e0       	ldi	r24, 0x04	; 4
    8bc2:	61 e0       	ldi	r22, 0x01	; 1
    8bc4:	46 ed       	ldi	r20, 0xD6	; 214
    8bc6:	5b e0       	ldi	r21, 0x0B	; 11
    8bc8:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	      TimDisplay=0;
    8bcc:	10 92 92 01 	sts	0x0192, r1
	      stFreeMessage=fmDelayViewMesage;
    8bd0:	82 e0       	ldi	r24, 0x02	; 2
    8bd2:	05 c0       	rjmp	.+10     	; 0x8bde <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    8bd4:	80 91 92 01 	lds	r24, 0x0192
    8bd8:	8b 30       	cpi	r24, 0x0B	; 11
    8bda:	48 f0       	brcs	.+18     	; 0x8bee <FViewFreeMessage+0x70>
    8bdc:	83 e0       	ldi	r24, 0x03	; 3
    8bde:	80 93 6d 02 	sts	0x026D, r24
    8be2:	80 e0       	ldi	r24, 0x00	; 0
    8be4:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    8be6:	10 92 6d 02 	sts	0x026D, r1
    8bea:	81 e0       	ldi	r24, 0x01	; 1
    8bec:	08 95       	ret
    8bee:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    8bf0:	08 95       	ret

00008bf2 <FTestChar>:
		TimTicker++;
	}

}

char FTestChar(){
    8bf2:	0f 93       	push	r16
    8bf4:	1f 93       	push	r17
    8bf6:	df 93       	push	r29
    8bf8:	cf 93       	push	r28
    8bfa:	cd b7       	in	r28, 0x3d	; 61
    8bfc:	de b7       	in	r29, 0x3e	; 62
    8bfe:	64 97       	sbiw	r28, 0x14	; 20
    8c00:	0f b6       	in	r0, 0x3f	; 63
    8c02:	f8 94       	cli
    8c04:	de bf       	out	0x3e, r29	; 62
    8c06:	0f be       	out	0x3f, r0	; 63
    8c08:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    8c0a:	8d b7       	in	r24, 0x3d	; 61
    8c0c:	9e b7       	in	r25, 0x3e	; 62
    8c0e:	08 97       	sbiw	r24, 0x08	; 8
    8c10:	0f b6       	in	r0, 0x3f	; 63
    8c12:	f8 94       	cli
    8c14:	9e bf       	out	0x3e, r25	; 62
    8c16:	0f be       	out	0x3f, r0	; 63
    8c18:	8d bf       	out	0x3d, r24	; 61
    8c1a:	ed b7       	in	r30, 0x3d	; 61
    8c1c:	fe b7       	in	r31, 0x3e	; 62
    8c1e:	31 96       	adiw	r30, 0x01	; 1
    8c20:	8e 01       	movw	r16, r28
    8c22:	0f 5f       	subi	r16, 0xFF	; 255
    8c24:	1f 4f       	sbci	r17, 0xFF	; 255
    8c26:	ad b7       	in	r26, 0x3d	; 61
    8c28:	be b7       	in	r27, 0x3e	; 62
    8c2a:	12 96       	adiw	r26, 0x02	; 2
    8c2c:	1c 93       	st	X, r17
    8c2e:	0e 93       	st	-X, r16
    8c30:	11 97       	sbiw	r26, 0x01	; 1
    8c32:	82 e9       	ldi	r24, 0x92	; 146
    8c34:	9b e1       	ldi	r25, 0x1B	; 27
    8c36:	93 83       	std	Z+3, r25	; 0x03
    8c38:	82 83       	std	Z+2, r24	; 0x02
    8c3a:	15 82       	std	Z+5, r1	; 0x05
    8c3c:	14 82       	std	Z+4, r1	; 0x04
    8c3e:	17 82       	std	Z+7, r1	; 0x07
    8c40:	16 82       	std	Z+6, r1	; 0x06
    8c42:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
     lcd_print(1,1,lcdteks);
    8c46:	8d b7       	in	r24, 0x3d	; 61
    8c48:	9e b7       	in	r25, 0x3e	; 62
    8c4a:	08 96       	adiw	r24, 0x08	; 8
    8c4c:	0f b6       	in	r0, 0x3f	; 63
    8c4e:	f8 94       	cli
    8c50:	9e bf       	out	0x3e, r25	; 62
    8c52:	0f be       	out	0x3f, r0	; 63
    8c54:	8d bf       	out	0x3d, r24	; 61
    8c56:	81 e0       	ldi	r24, 0x01	; 1
    8c58:	61 e0       	ldi	r22, 0x01	; 1
    8c5a:	a8 01       	movw	r20, r16
    8c5c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    8c60:	88 ee       	ldi	r24, 0xE8	; 232
    8c62:	9d ef       	ldi	r25, 0xFD	; 253
    8c64:	29 e1       	ldi	r18, 0x19	; 25
    8c66:	30 e0       	ldi	r19, 0x00	; 0
    8c68:	f9 01       	movw	r30, r18
    8c6a:	31 97       	sbiw	r30, 0x01	; 1
    8c6c:	f1 f7       	brne	.-4      	; 0x8c6a <FTestChar+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8c6e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8c70:	d9 f7       	brne	.-10     	; 0x8c68 <FTestChar+0x76>
	 if (i==0xFF)Result=MENU_DONE;
	 i++;
     _delay_ms(6500);
  return Result;
}
    8c72:	80 e0       	ldi	r24, 0x00	; 0
    8c74:	64 96       	adiw	r28, 0x14	; 20
    8c76:	0f b6       	in	r0, 0x3f	; 63
    8c78:	f8 94       	cli
    8c7a:	de bf       	out	0x3e, r29	; 62
    8c7c:	0f be       	out	0x3f, r0	; 63
    8c7e:	cd bf       	out	0x3d, r28	; 61
    8c80:	cf 91       	pop	r28
    8c82:	df 91       	pop	r29
    8c84:	1f 91       	pop	r17
    8c86:	0f 91       	pop	r16
    8c88:	08 95       	ret

00008c8a <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    8c8a:	cf 92       	push	r12
    8c8c:	df 92       	push	r13
    8c8e:	ef 92       	push	r14
    8c90:	ff 92       	push	r15
    8c92:	0f 93       	push	r16
    8c94:	1f 93       	push	r17
    8c96:	df 93       	push	r29
    8c98:	cf 93       	push	r28
    8c9a:	cd b7       	in	r28, 0x3d	; 61
    8c9c:	de b7       	in	r29, 0x3e	; 62
    8c9e:	64 97       	sbiw	r28, 0x14	; 20
    8ca0:	0f b6       	in	r0, 0x3f	; 63
    8ca2:	f8 94       	cli
    8ca4:	de bf       	out	0x3e, r29	; 62
    8ca6:	0f be       	out	0x3f, r0	; 63
    8ca8:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    8caa:	ea eb       	ldi	r30, 0xBA	; 186
    8cac:	ee 2e       	mov	r14, r30
    8cae:	e3 e0       	ldi	r30, 0x03	; 3
    8cb0:	fe 2e       	mov	r15, r30
    8cb2:	74 e7       	ldi	r23, 0x74	; 116
    8cb4:	c7 2e       	mov	r12, r23
    8cb6:	78 e0       	ldi	r23, 0x08	; 8
    8cb8:	d7 2e       	mov	r13, r23
    8cba:	80 e0       	ldi	r24, 0x00	; 0
    8cbc:	b7 01       	movw	r22, r14
    8cbe:	a6 01       	movw	r20, r12
    8cc0:	0e 94 4a a7 	call	0x14e94	; 0x14e94 <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    8cc4:	8d b7       	in	r24, 0x3d	; 61
    8cc6:	9e b7       	in	r25, 0x3e	; 62
    8cc8:	08 97       	sbiw	r24, 0x08	; 8
    8cca:	0f b6       	in	r0, 0x3f	; 63
    8ccc:	f8 94       	cli
    8cce:	9e bf       	out	0x3e, r25	; 62
    8cd0:	0f be       	out	0x3f, r0	; 63
    8cd2:	8d bf       	out	0x3d, r24	; 61
    8cd4:	ed b7       	in	r30, 0x3d	; 61
    8cd6:	fe b7       	in	r31, 0x3e	; 62
    8cd8:	31 96       	adiw	r30, 0x01	; 1
    8cda:	8e 01       	movw	r16, r28
    8cdc:	0f 5f       	subi	r16, 0xFF	; 255
    8cde:	1f 4f       	sbci	r17, 0xFF	; 255
    8ce0:	ad b7       	in	r26, 0x3d	; 61
    8ce2:	be b7       	in	r27, 0x3e	; 62
    8ce4:	12 96       	adiw	r26, 0x02	; 2
    8ce6:	1c 93       	st	X, r17
    8ce8:	0e 93       	st	-X, r16
    8cea:	11 97       	sbiw	r26, 0x01	; 1
    8cec:	8e e9       	ldi	r24, 0x9E	; 158
    8cee:	9b e1       	ldi	r25, 0x1B	; 27
    8cf0:	93 83       	std	Z+3, r25	; 0x03
    8cf2:	82 83       	std	Z+2, r24	; 0x02
    8cf4:	f5 82       	std	Z+5, r15	; 0x05
    8cf6:	e4 82       	std	Z+4, r14	; 0x04
    8cf8:	d7 82       	std	Z+7, r13	; 0x07
    8cfa:	c6 82       	std	Z+6, r12	; 0x06
    8cfc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    8d00:	8d b7       	in	r24, 0x3d	; 61
    8d02:	9e b7       	in	r25, 0x3e	; 62
    8d04:	08 96       	adiw	r24, 0x08	; 8
    8d06:	0f b6       	in	r0, 0x3f	; 63
    8d08:	f8 94       	cli
    8d0a:	9e bf       	out	0x3e, r25	; 62
    8d0c:	0f be       	out	0x3f, r0	; 63
    8d0e:	8d bf       	out	0x3d, r24	; 61
    8d10:	82 e0       	ldi	r24, 0x02	; 2
    8d12:	61 e0       	ldi	r22, 0x01	; 1
    8d14:	a8 01       	movw	r20, r16
    8d16:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
}
    8d1a:	64 96       	adiw	r28, 0x14	; 20
    8d1c:	0f b6       	in	r0, 0x3f	; 63
    8d1e:	f8 94       	cli
    8d20:	de bf       	out	0x3e, r29	; 62
    8d22:	0f be       	out	0x3f, r0	; 63
    8d24:	cd bf       	out	0x3d, r28	; 61
    8d26:	cf 91       	pop	r28
    8d28:	df 91       	pop	r29
    8d2a:	1f 91       	pop	r17
    8d2c:	0f 91       	pop	r16
    8d2e:	ff 90       	pop	r15
    8d30:	ef 90       	pop	r14
    8d32:	df 90       	pop	r13
    8d34:	cf 90       	pop	r12
    8d36:	08 95       	ret

00008d38 <DisplayScreenIdle>:
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
		break;
	 }
}

void DisplayScreenIdle(void){
    8d38:	cf 92       	push	r12
    8d3a:	df 92       	push	r13
    8d3c:	ef 92       	push	r14
    8d3e:	ff 92       	push	r15
    8d40:	0f 93       	push	r16
    8d42:	1f 93       	push	r17
    8d44:	df 93       	push	r29
    8d46:	cf 93       	push	r28
    8d48:	cd b7       	in	r28, 0x3d	; 61
    8d4a:	de b7       	in	r29, 0x3e	; 62
    8d4c:	a8 97       	sbiw	r28, 0x28	; 40
    8d4e:	0f b6       	in	r0, 0x3f	; 63
    8d50:	f8 94       	cli
    8d52:	de bf       	out	0x3e, r29	; 62
    8d54:	0f be       	out	0x3f, r0	; 63
    8d56:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    8d58:	00 d0       	rcall	.+0      	; 0x8d5a <DisplayScreenIdle+0x22>
    8d5a:	00 d0       	rcall	.+0      	; 0x8d5c <DisplayScreenIdle+0x24>
    8d5c:	6e 01       	movw	r12, r28
    8d5e:	08 94       	sec
    8d60:	c1 1c       	adc	r12, r1
    8d62:	d1 1c       	adc	r13, r1
    8d64:	ad b7       	in	r26, 0x3d	; 61
    8d66:	be b7       	in	r27, 0x3e	; 62
    8d68:	12 96       	adiw	r26, 0x02	; 2
    8d6a:	dc 92       	st	X, r13
    8d6c:	ce 92       	st	-X, r12
    8d6e:	11 97       	sbiw	r26, 0x01	; 1
    8d70:	80 ec       	ldi	r24, 0xC0	; 192
    8d72:	90 e2       	ldi	r25, 0x20	; 32
    8d74:	14 96       	adiw	r26, 0x04	; 4
    8d76:	9c 93       	st	X, r25
    8d78:	8e 93       	st	-X, r24
    8d7a:	13 97       	sbiw	r26, 0x03	; 3
    8d7c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    8d80:	fb e0       	ldi	r31, 0x0B	; 11
    8d82:	ef 2e       	mov	r14, r31
    8d84:	f1 2c       	mov	r15, r1
    8d86:	ec 0e       	add	r14, r28
    8d88:	fd 1e       	adc	r15, r29
    8d8a:	ed b7       	in	r30, 0x3d	; 61
    8d8c:	fe b7       	in	r31, 0x3e	; 62
    8d8e:	f2 82       	std	Z+2, r15	; 0x02
    8d90:	e1 82       	std	Z+1, r14	; 0x01
    8d92:	8b eb       	ldi	r24, 0xBB	; 187
    8d94:	90 e2       	ldi	r25, 0x20	; 32
    8d96:	94 83       	std	Z+4, r25	; 0x04
    8d98:	83 83       	std	Z+3, r24	; 0x03
    8d9a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    8d9e:	00 d0       	rcall	.+0      	; 0x8da0 <DisplayScreenIdle+0x68>
    8da0:	00 d0       	rcall	.+0      	; 0x8da2 <DisplayScreenIdle+0x6a>
    8da2:	ed b7       	in	r30, 0x3d	; 61
    8da4:	fe b7       	in	r31, 0x3e	; 62
    8da6:	31 96       	adiw	r30, 0x01	; 1
    8da8:	8e 01       	movw	r16, r28
    8daa:	0b 5e       	subi	r16, 0xEB	; 235
    8dac:	1f 4f       	sbci	r17, 0xFF	; 255
    8dae:	ad b7       	in	r26, 0x3d	; 61
    8db0:	be b7       	in	r27, 0x3e	; 62
    8db2:	12 96       	adiw	r26, 0x02	; 2
    8db4:	1c 93       	st	X, r17
    8db6:	0e 93       	st	-X, r16
    8db8:	11 97       	sbiw	r26, 0x01	; 1
    8dba:	85 eb       	ldi	r24, 0xB5	; 181
    8dbc:	90 e2       	ldi	r25, 0x20	; 32
    8dbe:	93 83       	std	Z+3, r25	; 0x03
    8dc0:	82 83       	std	Z+2, r24	; 0x02
    8dc2:	d5 82       	std	Z+5, r13	; 0x05
    8dc4:	c4 82       	std	Z+4, r12	; 0x04
    8dc6:	f7 82       	std	Z+7, r15	; 0x07
    8dc8:	e6 82       	std	Z+6, r14	; 0x06
    8dca:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	lcd_clear();
    8dce:	ed b7       	in	r30, 0x3d	; 61
    8dd0:	fe b7       	in	r31, 0x3e	; 62
    8dd2:	38 96       	adiw	r30, 0x08	; 8
    8dd4:	0f b6       	in	r0, 0x3f	; 63
    8dd6:	f8 94       	cli
    8dd8:	fe bf       	out	0x3e, r31	; 62
    8dda:	0f be       	out	0x3f, r0	; 63
    8ddc:	ed bf       	out	0x3d, r30	; 61
    8dde:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	lcd_print(1,1,lcdteks);
    8de2:	81 e0       	ldi	r24, 0x01	; 1
    8de4:	61 e0       	ldi	r22, 0x01	; 1
    8de6:	a8 01       	movw	r20, r16
    8de8:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
}
    8dec:	a8 96       	adiw	r28, 0x28	; 40
    8dee:	0f b6       	in	r0, 0x3f	; 63
    8df0:	f8 94       	cli
    8df2:	de bf       	out	0x3e, r29	; 62
    8df4:	0f be       	out	0x3f, r0	; 63
    8df6:	cd bf       	out	0x3d, r28	; 61
    8df8:	cf 91       	pop	r28
    8dfa:	df 91       	pop	r29
    8dfc:	1f 91       	pop	r17
    8dfe:	0f 91       	pop	r16
    8e00:	ff 90       	pop	r15
    8e02:	ef 90       	pop	r14
    8e04:	df 90       	pop	r13
    8e06:	cf 90       	pop	r12
    8e08:	08 95       	ret

00008e0a <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    8e0a:	0f 93       	push	r16
    8e0c:	1f 93       	push	r17
    8e0e:	df 93       	push	r29
    8e10:	cf 93       	push	r28
    8e12:	cd b7       	in	r28, 0x3d	; 61
    8e14:	de b7       	in	r29, 0x3e	; 62
    8e16:	a8 97       	sbiw	r28, 0x28	; 40
    8e18:	0f b6       	in	r0, 0x3f	; 63
    8e1a:	f8 94       	cli
    8e1c:	de bf       	out	0x3e, r29	; 62
    8e1e:	0f be       	out	0x3f, r0	; 63
    8e20:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    8e22:	80 91 01 01 	lds	r24, 0x0101
    8e26:	81 30       	cpi	r24, 0x01	; 1
    8e28:	09 f0       	breq	.+2      	; 0x8e2c <DisplayPumpStatus+0x22>
    8e2a:	4a c0       	rjmp	.+148    	; 0x8ec0 <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    8e2c:	10 92 01 01 	sts	0x0101, r1
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    8e30:	80 93 ae 02 	sts	0x02AE, r24
	 __key_lgtcnt = 0; 
    8e34:	10 92 af 02 	sts	0x02AF, r1
	 PORTG=PORTG&0b11111101;
    8e38:	80 91 65 00 	lds	r24, 0x0065
    8e3c:	8d 7f       	andi	r24, 0xFD	; 253
    8e3e:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    8e42:	80 91 5c 01 	lds	r24, 0x015C
    8e46:	48 2f       	mov	r20, r24
    8e48:	50 e0       	ldi	r21, 0x00	; 0
    8e4a:	20 e0       	ldi	r18, 0x00	; 0
    8e4c:	30 e0       	ldi	r19, 0x00	; 0
    8e4e:	be 01       	movw	r22, r28
    8e50:	6f 5f       	subi	r22, 0xFF	; 255
    8e52:	7f 4f       	sbci	r23, 0xFF	; 255
    8e54:	0a c0       	rjmp	.+20     	; 0x8e6a <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8e56:	fb 01       	movw	r30, r22
    8e58:	e2 0f       	add	r30, r18
    8e5a:	f3 1f       	adc	r31, r19
    8e5c:	d9 01       	movw	r26, r18
    8e5e:	ae 5f       	subi	r26, 0xFE	; 254
    8e60:	be 4f       	sbci	r27, 0xFE	; 254
    8e62:	8c 91       	ld	r24, X
    8e64:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8e66:	2f 5f       	subi	r18, 0xFF	; 255
    8e68:	3f 4f       	sbci	r19, 0xFF	; 255
    8e6a:	24 17       	cp	r18, r20
    8e6c:	35 07       	cpc	r19, r21
    8e6e:	98 f3       	brcs	.-26     	; 0x8e56 <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8e70:	46 0f       	add	r20, r22
    8e72:	57 1f       	adc	r21, r23
    8e74:	da 01       	movw	r26, r20
    8e76:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    8e78:	00 d0       	rcall	.+0      	; 0x8e7a <DisplayPumpStatus+0x70>
    8e7a:	00 d0       	rcall	.+0      	; 0x8e7c <DisplayPumpStatus+0x72>
    8e7c:	00 d0       	rcall	.+0      	; 0x8e7e <DisplayPumpStatus+0x74>
    8e7e:	ed b7       	in	r30, 0x3d	; 61
    8e80:	fe b7       	in	r31, 0x3e	; 62
    8e82:	31 96       	adiw	r30, 0x01	; 1
    8e84:	8e 01       	movw	r16, r28
    8e86:	0b 5e       	subi	r16, 0xEB	; 235
    8e88:	1f 4f       	sbci	r17, 0xFF	; 255
    8e8a:	ad b7       	in	r26, 0x3d	; 61
    8e8c:	be b7       	in	r27, 0x3e	; 62
    8e8e:	12 96       	adiw	r26, 0x02	; 2
    8e90:	1c 93       	st	X, r17
    8e92:	0e 93       	st	-X, r16
    8e94:	11 97       	sbiw	r26, 0x01	; 1
    8e96:	87 e3       	ldi	r24, 0x37	; 55
    8e98:	91 e2       	ldi	r25, 0x21	; 33
    8e9a:	93 83       	std	Z+3, r25	; 0x03
    8e9c:	82 83       	std	Z+2, r24	; 0x02
    8e9e:	75 83       	std	Z+5, r23	; 0x05
    8ea0:	64 83       	std	Z+4, r22	; 0x04
    8ea2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
         lcd_print(4,1,lcdteks);
    8ea6:	ed b7       	in	r30, 0x3d	; 61
    8ea8:	fe b7       	in	r31, 0x3e	; 62
    8eaa:	36 96       	adiw	r30, 0x06	; 6
    8eac:	0f b6       	in	r0, 0x3f	; 63
    8eae:	f8 94       	cli
    8eb0:	fe bf       	out	0x3e, r31	; 62
    8eb2:	0f be       	out	0x3f, r0	; 63
    8eb4:	ed bf       	out	0x3d, r30	; 61
    8eb6:	84 e0       	ldi	r24, 0x04	; 4
    8eb8:	61 e0       	ldi	r22, 0x01	; 1
    8eba:	a8 01       	movw	r20, r16
    8ebc:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
     	 }
}
    8ec0:	a8 96       	adiw	r28, 0x28	; 40
    8ec2:	0f b6       	in	r0, 0x3f	; 63
    8ec4:	f8 94       	cli
    8ec6:	de bf       	out	0x3e, r29	; 62
    8ec8:	0f be       	out	0x3f, r0	; 63
    8eca:	cd bf       	out	0x3d, r28	; 61
    8ecc:	cf 91       	pop	r28
    8ece:	df 91       	pop	r29
    8ed0:	1f 91       	pop	r17
    8ed2:	0f 91       	pop	r16
    8ed4:	08 95       	ret

00008ed6 <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    8ed6:	df 92       	push	r13
    8ed8:	ef 92       	push	r14
    8eda:	ff 92       	push	r15
    8edc:	0f 93       	push	r16
    8ede:	1f 93       	push	r17
    8ee0:	df 93       	push	r29
    8ee2:	cf 93       	push	r28
    8ee4:	cd b7       	in	r28, 0x3d	; 61
    8ee6:	de b7       	in	r29, 0x3e	; 62
    8ee8:	64 97       	sbiw	r28, 0x14	; 20
    8eea:	0f b6       	in	r0, 0x3f	; 63
    8eec:	f8 94       	cli
    8eee:	de bf       	out	0x3e, r29	; 62
    8ef0:	0f be       	out	0x3f, r0	; 63
    8ef2:	cd bf       	out	0x3d, r28	; 61
    8ef4:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    8ef6:	80 91 49 02 	lds	r24, 0x0249
    8efa:	87 30       	cpi	r24, 0x07	; 7
    8efc:	09 f4       	brne	.+2      	; 0x8f00 <FCloseShift+0x2a>
    8efe:	a0 c1       	rjmp	.+832    	; 0x9240 <FCloseShift+0x36a>
    8f00:	88 30       	cpi	r24, 0x08	; 8
    8f02:	78 f4       	brcc	.+30     	; 0x8f22 <FCloseShift+0x4c>
    8f04:	84 30       	cpi	r24, 0x04	; 4
    8f06:	09 f4       	brne	.+2      	; 0x8f0a <FCloseShift+0x34>
    8f08:	68 c0       	rjmp	.+208    	; 0x8fda <FCloseShift+0x104>
    8f0a:	85 30       	cpi	r24, 0x05	; 5
    8f0c:	18 f4       	brcc	.+6      	; 0x8f14 <FCloseShift+0x3e>
    8f0e:	88 23       	and	r24, r24
    8f10:	c1 f0       	breq	.+48     	; 0x8f42 <FCloseShift+0x6c>
    8f12:	1c c2       	rjmp	.+1080   	; 0x934c <FCloseShift+0x476>
    8f14:	85 30       	cpi	r24, 0x05	; 5
    8f16:	09 f4       	brne	.+2      	; 0x8f1a <FCloseShift+0x44>
    8f18:	a6 c0       	rjmp	.+332    	; 0x9066 <FCloseShift+0x190>
    8f1a:	86 30       	cpi	r24, 0x06	; 6
    8f1c:	09 f0       	breq	.+2      	; 0x8f20 <FCloseShift+0x4a>
    8f1e:	16 c2       	rjmp	.+1068   	; 0x934c <FCloseShift+0x476>
    8f20:	a8 c0       	rjmp	.+336    	; 0x9072 <FCloseShift+0x19c>
    8f22:	8a 30       	cpi	r24, 0x0A	; 10
    8f24:	09 f4       	brne	.+2      	; 0x8f28 <FCloseShift+0x52>
    8f26:	d0 c1       	rjmp	.+928    	; 0x92c8 <FCloseShift+0x3f2>
    8f28:	8b 30       	cpi	r24, 0x0B	; 11
    8f2a:	20 f4       	brcc	.+8      	; 0x8f34 <FCloseShift+0x5e>
    8f2c:	88 30       	cpi	r24, 0x08	; 8
    8f2e:	09 f0       	breq	.+2      	; 0x8f32 <FCloseShift+0x5c>
    8f30:	0d c2       	rjmp	.+1050   	; 0x934c <FCloseShift+0x476>
    8f32:	8c c1       	rjmp	.+792    	; 0x924c <FCloseShift+0x376>
    8f34:	8b 30       	cpi	r24, 0x0B	; 11
    8f36:	09 f4       	brne	.+2      	; 0x8f3a <FCloseShift+0x64>
    8f38:	05 c2       	rjmp	.+1034   	; 0x9344 <FCloseShift+0x46e>
    8f3a:	8c 30       	cpi	r24, 0x0C	; 12
    8f3c:	09 f0       	breq	.+2      	; 0x8f40 <FCloseShift+0x6a>
    8f3e:	06 c2       	rjmp	.+1036   	; 0x934c <FCloseShift+0x476>
    8f40:	cc c1       	rjmp	.+920    	; 0x92da <FCloseShift+0x404>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8f42:	e1 99       	sbic	0x1c, 1	; 28
    8f44:	fe cf       	rjmp	.-4      	; 0x8f42 <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8f46:	89 e4       	ldi	r24, 0x49	; 73
    8f48:	91 e0       	ldi	r25, 0x01	; 1
    8f4a:	9f bb       	out	0x1f, r25	; 31
    8f4c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8f4e:	e0 9a       	sbi	0x1c, 0	; 28
    8f50:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    8f52:	80 93 5d 01 	sts	0x015D, r24
		  IsPumpBusy=False;
    8f56:	10 92 48 02 	sts	0x0248, r1
    8f5a:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    8f5c:	dd 24       	eor	r13, r13
    8f5e:	d3 94       	inc	r13
    8f60:	36 c0       	rjmp	.+108    	; 0x8fce <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    8f62:	0f 2d       	mov	r16, r15
    8f64:	10 e0       	ldi	r17, 0x00	; 0
    8f66:	f8 01       	movw	r30, r16
    8f68:	ee 5f       	subi	r30, 0xFE	; 254
    8f6a:	fe 4f       	sbci	r31, 0xFE	; 254
    8f6c:	e0 80       	ld	r14, Z
    8f6e:	8e e0       	ldi	r24, 0x0E	; 14
    8f70:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    8f74:	e8 16       	cp	r14, r24
    8f76:	81 f0       	breq	.+32     	; 0x8f98 <FCloseShift+0xc2>
    8f78:	86 e0       	ldi	r24, 0x06	; 6
    8f7a:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    8f7e:	e8 16       	cp	r14, r24
    8f80:	59 f0       	breq	.+22     	; 0x8f98 <FCloseShift+0xc2>
    8f82:	89 e0       	ldi	r24, 0x09	; 9
    8f84:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    8f88:	e8 16       	cp	r14, r24
    8f8a:	31 f0       	breq	.+12     	; 0x8f98 <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    8f8c:	8f 2d       	mov	r24, r15
    8f8e:	0e 94 cc 1c 	call	0x3998	; 0x3998 <GetPumpID>
    8f92:	66 e0       	ldi	r22, 0x06	; 6
    8f94:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    8f98:	84 e1       	ldi	r24, 0x14	; 20
    8f9a:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    8f9e:	f8 01       	movw	r30, r16
    8fa0:	ee 5f       	subi	r30, 0xFE	; 254
    8fa2:	fe 4f       	sbci	r31, 0xFE	; 254
    8fa4:	90 81       	ld	r25, Z
    8fa6:	98 17       	cp	r25, r24
    8fa8:	31 f4       	brne	.+12     	; 0x8fb6 <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    8faa:	8f 2d       	mov	r24, r15
    8fac:	0e 94 cc 1c 	call	0x3998	; 0x3998 <GetPumpID>
    8fb0:	66 e0       	ldi	r22, 0x06	; 6
    8fb2:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    8fb6:	89 e0       	ldi	r24, 0x09	; 9
    8fb8:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    8fbc:	0e 5f       	subi	r16, 0xFE	; 254
    8fbe:	1e 4f       	sbci	r17, 0xFE	; 254
    8fc0:	d8 01       	movw	r26, r16
    8fc2:	9c 91       	ld	r25, X
    8fc4:	98 17       	cp	r25, r24
    8fc6:	11 f4       	brne	.+4      	; 0x8fcc <FCloseShift+0xf6>
			       IsPumpBusy=True;
    8fc8:	d0 92 48 02 	sts	0x0248, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    8fcc:	f3 94       	inc	r15
    8fce:	80 91 5d 01 	lds	r24, 0x015D
    8fd2:	f8 16       	cp	r15, r24
    8fd4:	30 f2       	brcs	.-116    	; 0x8f62 <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    8fd6:	84 e0       	ldi	r24, 0x04	; 4
    8fd8:	b2 c1       	rjmp	.+868    	; 0x933e <FCloseShift+0x468>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    8fda:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    8fde:	81 e0       	ldi	r24, 0x01	; 1
    8fe0:	61 e0       	ldi	r22, 0x01	; 1
    8fe2:	41 e2       	ldi	r20, 0x21	; 33
    8fe4:	55 e1       	ldi	r21, 0x15	; 21
    8fe6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    8fea:	00 91 5d 01 	lds	r16, 0x015D
    8fee:	10 e0       	ldi	r17, 0x00	; 0
    8ff0:	82 e0       	ldi	r24, 0x02	; 2
    8ff2:	91 e0       	ldi	r25, 0x01	; 1
    8ff4:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <CountTotalizerSatus>
    8ff8:	00 d0       	rcall	.+0      	; 0x8ffa <FCloseShift+0x124>
    8ffa:	00 d0       	rcall	.+0      	; 0x8ffc <FCloseShift+0x126>
    8ffc:	00 d0       	rcall	.+0      	; 0x8ffe <FCloseShift+0x128>
    8ffe:	ed b7       	in	r30, 0x3d	; 61
    9000:	fe b7       	in	r31, 0x3e	; 62
    9002:	31 96       	adiw	r30, 0x01	; 1
    9004:	7e 01       	movw	r14, r28
    9006:	08 94       	sec
    9008:	e1 1c       	adc	r14, r1
    900a:	f1 1c       	adc	r15, r1
    900c:	ad b7       	in	r26, 0x3d	; 61
    900e:	be b7       	in	r27, 0x3e	; 62
    9010:	12 96       	adiw	r26, 0x02	; 2
    9012:	fc 92       	st	X, r15
    9014:	ee 92       	st	-X, r14
    9016:	11 97       	sbiw	r26, 0x01	; 1
    9018:	23 e1       	ldi	r18, 0x13	; 19
    901a:	35 e1       	ldi	r19, 0x15	; 21
    901c:	33 83       	std	Z+3, r19	; 0x03
    901e:	22 83       	std	Z+2, r18	; 0x02
    9020:	08 1b       	sub	r16, r24
    9022:	11 09       	sbc	r17, r1
    9024:	15 83       	std	Z+5, r17	; 0x05
    9026:	04 83       	std	Z+4, r16	; 0x04
    9028:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    902c:	ed b7       	in	r30, 0x3d	; 61
    902e:	fe b7       	in	r31, 0x3e	; 62
    9030:	36 96       	adiw	r30, 0x06	; 6
    9032:	0f b6       	in	r0, 0x3f	; 63
    9034:	f8 94       	cli
    9036:	fe bf       	out	0x3e, r31	; 62
    9038:	0f be       	out	0x3f, r0	; 63
    903a:	ed bf       	out	0x3d, r30	; 61
    903c:	82 e0       	ldi	r24, 0x02	; 2
    903e:	61 e0       	ldi	r22, 0x01	; 1
    9040:	a7 01       	movw	r20, r14
    9042:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>


          IsNewPumpStatus=True;
    9046:	11 e0       	ldi	r17, 0x01	; 1
    9048:	10 93 01 01 	sts	0x0101, r17
		  DisplayPumpStatus(); 
    904c:	0e 94 05 47 	call	0x8e0a	; 0x8e0a <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    9050:	95 e0       	ldi	r25, 0x05	; 5
    9052:	90 93 a7 05 	sts	0x05A7, r25
	 PoolMsg=plMsg;
    9056:	82 e1       	ldi	r24, 0x12	; 18
    9058:	80 93 d3 0b 	sts	0x0BD3, r24
     IsControlPooling=True;
    905c:	10 93 84 01 	sts	0x0184, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    9060:	90 93 49 02 	sts	0x0249, r25
    9064:	73 c1       	rjmp	.+742    	; 0x934c <FCloseShift+0x476>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    9066:	0e 94 05 47 	call	0x8e0a	; 0x8e0a <DisplayPumpStatus>
		  TimDisplay=0;         
    906a:	10 92 92 01 	sts	0x0192, r1
          stCloseShift=csWaitTotalizerComplete;
    906e:	86 e0       	ldi	r24, 0x06	; 6
    9070:	66 c1       	rjmp	.+716    	; 0x933e <FCloseShift+0x468>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    9072:	81 e0       	ldi	r24, 0x01	; 1
    9074:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    9078:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    907a:	80 91 01 01 	lds	r24, 0x0101
    907e:	81 30       	cpi	r24, 0x01	; 1
    9080:	89 f5       	brne	.+98     	; 0x90e4 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    9082:	00 91 5d 01 	lds	r16, 0x015D
    9086:	10 e0       	ldi	r17, 0x00	; 0
    9088:	82 e0       	ldi	r24, 0x02	; 2
    908a:	91 e0       	ldi	r25, 0x01	; 1
    908c:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <CountTotalizerSatus>
    9090:	00 d0       	rcall	.+0      	; 0x9092 <FCloseShift+0x1bc>
    9092:	00 d0       	rcall	.+0      	; 0x9094 <FCloseShift+0x1be>
    9094:	00 d0       	rcall	.+0      	; 0x9096 <FCloseShift+0x1c0>
    9096:	ed b7       	in	r30, 0x3d	; 61
    9098:	fe b7       	in	r31, 0x3e	; 62
    909a:	31 96       	adiw	r30, 0x01	; 1
    909c:	7e 01       	movw	r14, r28
    909e:	08 94       	sec
    90a0:	e1 1c       	adc	r14, r1
    90a2:	f1 1c       	adc	r15, r1
    90a4:	ad b7       	in	r26, 0x3d	; 61
    90a6:	be b7       	in	r27, 0x3e	; 62
    90a8:	12 96       	adiw	r26, 0x02	; 2
    90aa:	fc 92       	st	X, r15
    90ac:	ee 92       	st	-X, r14
    90ae:	11 97       	sbiw	r26, 0x01	; 1
    90b0:	25 e0       	ldi	r18, 0x05	; 5
    90b2:	35 e1       	ldi	r19, 0x15	; 21
    90b4:	33 83       	std	Z+3, r19	; 0x03
    90b6:	22 83       	std	Z+2, r18	; 0x02
    90b8:	08 1b       	sub	r16, r24
    90ba:	11 09       	sbc	r17, r1
    90bc:	15 83       	std	Z+5, r17	; 0x05
    90be:	04 83       	std	Z+4, r16	; 0x04
    90c0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  lcd_print(2,1,lcdteks);
    90c4:	ed b7       	in	r30, 0x3d	; 61
    90c6:	fe b7       	in	r31, 0x3e	; 62
    90c8:	36 96       	adiw	r30, 0x06	; 6
    90ca:	0f b6       	in	r0, 0x3f	; 63
    90cc:	f8 94       	cli
    90ce:	fe bf       	out	0x3e, r31	; 62
    90d0:	0f be       	out	0x3f, r0	; 63
    90d2:	ed bf       	out	0x3d, r30	; 61
    90d4:	82 e0       	ldi	r24, 0x02	; 2
    90d6:	61 e0       	ldi	r22, 0x01	; 1
    90d8:	a7 01       	movw	r20, r14
    90da:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    90de:	85 e0       	ldi	r24, 0x05	; 5
    90e0:	80 93 49 02 	sts	0x0249, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    90e4:	82 e0       	ldi	r24, 0x02	; 2
    90e6:	91 e0       	ldi	r25, 0x01	; 1
    90e8:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <CountTotalizerSatus>
    90ec:	90 91 5d 01 	lds	r25, 0x015D
    90f0:	89 17       	cp	r24, r25
    90f2:	a0 f0       	brcs	.+40     	; 0x911c <FCloseShift+0x246>
    90f4:	80 91 92 01 	lds	r24, 0x0192
    90f8:	86 30       	cpi	r24, 0x06	; 6
    90fa:	80 f0       	brcs	.+32     	; 0x911c <FCloseShift+0x246>
    90fc:	10 e0       	ldi	r17, 0x00	; 0
    90fe:	07 c0       	rjmp	.+14     	; 0x910e <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    9100:	81 2f       	mov	r24, r17
    9102:	0e 94 cc 1c 	call	0x3998	; 0x3998 <GetPumpID>
    9106:	66 e0       	ldi	r22, 0x06	; 6
    9108:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    910c:	1f 5f       	subi	r17, 0xFF	; 255
    910e:	80 91 5d 01 	lds	r24, 0x015D
    9112:	18 17       	cp	r17, r24
    9114:	a8 f3       	brcs	.-22     	; 0x9100 <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    9116:	88 e0       	ldi	r24, 0x08	; 8
    9118:	80 93 49 02 	sts	0x0249, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    911c:	80 91 92 01 	lds	r24, 0x0192
    9120:	80 31       	cpi	r24, 0x10	; 16
    9122:	08 f4       	brcc	.+2      	; 0x9126 <FCloseShift+0x250>
    9124:	64 c0       	rjmp	.+200    	; 0x91ee <FCloseShift+0x318>
    9126:	80 91 48 02 	lds	r24, 0x0248
    912a:	81 30       	cpi	r24, 0x01	; 1
    912c:	09 f4       	brne	.+2      	; 0x9130 <FCloseShift+0x25a>
    912e:	5f c0       	rjmp	.+190    	; 0x91ee <FCloseShift+0x318>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    9130:	82 e0       	ldi	r24, 0x02	; 2
    9132:	91 e0       	ldi	r25, 0x01	; 1
    9134:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <CountNoPumpSatus>
    9138:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    913a:	e1 99       	sbic	0x1c, 1	; 28
    913c:	fe cf       	rjmp	.-4      	; 0x913a <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    913e:	89 e4       	ldi	r24, 0x49	; 73
    9140:	91 e0       	ldi	r25, 0x01	; 1
    9142:	9f bb       	out	0x1f, r25	; 31
    9144:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9146:	e0 9a       	sbi	0x1c, 0	; 28
    9148:	8d b3       	in	r24, 0x1d	; 29
    914a:	28 17       	cp	r18, r24
    914c:	08 f4       	brcc	.+2      	; 0x9150 <FCloseShift+0x27a>
    914e:	4f c0       	rjmp	.+158    	; 0x91ee <FCloseShift+0x318>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    9150:	00 91 5d 01 	lds	r16, 0x015D
    9154:	10 e0       	ldi	r17, 0x00	; 0
    9156:	82 e0       	ldi	r24, 0x02	; 2
    9158:	91 e0       	ldi	r25, 0x01	; 1
    915a:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <CountNoPumpSatus>
    915e:	00 d0       	rcall	.+0      	; 0x9160 <FCloseShift+0x28a>
    9160:	00 d0       	rcall	.+0      	; 0x9162 <FCloseShift+0x28c>
    9162:	00 d0       	rcall	.+0      	; 0x9164 <FCloseShift+0x28e>
    9164:	ed b7       	in	r30, 0x3d	; 61
    9166:	fe b7       	in	r31, 0x3e	; 62
    9168:	31 96       	adiw	r30, 0x01	; 1
    916a:	7e 01       	movw	r14, r28
    916c:	08 94       	sec
    916e:	e1 1c       	adc	r14, r1
    9170:	f1 1c       	adc	r15, r1
    9172:	ad b7       	in	r26, 0x3d	; 61
    9174:	be b7       	in	r27, 0x3e	; 62
    9176:	12 96       	adiw	r26, 0x02	; 2
    9178:	fc 92       	st	X, r15
    917a:	ee 92       	st	-X, r14
    917c:	11 97       	sbiw	r26, 0x01	; 1
    917e:	21 ef       	ldi	r18, 0xF1	; 241
    9180:	34 e1       	ldi	r19, 0x14	; 20
    9182:	33 83       	std	Z+3, r19	; 0x03
    9184:	22 83       	std	Z+2, r18	; 0x02
    9186:	08 1b       	sub	r16, r24
    9188:	11 09       	sbc	r17, r1
    918a:	15 83       	std	Z+5, r17	; 0x05
    918c:	04 83       	std	Z+4, r16	; 0x04
    918e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    9192:	ed b7       	in	r30, 0x3d	; 61
    9194:	fe b7       	in	r31, 0x3e	; 62
    9196:	36 96       	adiw	r30, 0x06	; 6
    9198:	0f b6       	in	r0, 0x3f	; 63
    919a:	f8 94       	cli
    919c:	fe bf       	out	0x3e, r31	; 62
    919e:	0f be       	out	0x3f, r0	; 63
    91a0:	ed bf       	out	0x3d, r30	; 61
    91a2:	83 e0       	ldi	r24, 0x03	; 3
    91a4:	61 e0       	ldi	r22, 0x01	; 1
    91a6:	a7 01       	movw	r20, r14
    91a8:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    91ac:	10 e0       	ldi	r17, 0x00	; 0
    91ae:	11 c0       	rjmp	.+34     	; 0x91d2 <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    91b0:	84 e1       	ldi	r24, 0x14	; 20
    91b2:	0e 94 c4 12 	call	0x2588	; 0x2588 <GetPumpStatusLabel>
    91b6:	e1 2f       	mov	r30, r17
    91b8:	f0 e0       	ldi	r31, 0x00	; 0
    91ba:	ee 5f       	subi	r30, 0xFE	; 254
    91bc:	fe 4f       	sbci	r31, 0xFE	; 254
    91be:	90 81       	ld	r25, Z
    91c0:	98 17       	cp	r25, r24
    91c2:	31 f4       	brne	.+12     	; 0x91d0 <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    91c4:	81 2f       	mov	r24, r17
    91c6:	0e 94 cc 1c 	call	0x3998	; 0x3998 <GetPumpID>
    91ca:	66 e0       	ldi	r22, 0x06	; 6
    91cc:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    91d0:	1f 5f       	subi	r17, 0xFF	; 255
    91d2:	80 91 5d 01 	lds	r24, 0x015D
    91d6:	18 17       	cp	r17, r24
    91d8:	58 f3       	brcs	.-42     	; 0x91b0 <FCloseShift+0x2da>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    91da:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    91dc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    91de:	81 e0       	ldi	r24, 0x01	; 1
    91e0:	80 93 bc 01 	sts	0x01BC, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    91e4:	10 92 92 01 	sts	0x0192, r1
			  stCloseShift=csNoPumpFound;		     
    91e8:	87 e0       	ldi	r24, 0x07	; 7
    91ea:	80 93 49 02 	sts	0x0249, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    91ee:	f7 ee       	ldi	r31, 0xE7	; 231
    91f0:	df 16       	cp	r13, r31
    91f2:	09 f0       	breq	.+2      	; 0x91f6 <FCloseShift+0x320>
    91f4:	ab c0       	rjmp	.+342    	; 0x934c <FCloseShift+0x476>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    91f6:	00 d0       	rcall	.+0      	; 0x91f8 <FCloseShift+0x322>
    91f8:	00 d0       	rcall	.+0      	; 0x91fa <FCloseShift+0x324>
    91fa:	8e 01       	movw	r16, r28
    91fc:	0f 5f       	subi	r16, 0xFF	; 255
    91fe:	1f 4f       	sbci	r17, 0xFF	; 255
    9200:	ad b7       	in	r26, 0x3d	; 61
    9202:	be b7       	in	r27, 0x3e	; 62
    9204:	12 96       	adiw	r26, 0x02	; 2
    9206:	1c 93       	st	X, r17
    9208:	0e 93       	st	-X, r16
    920a:	11 97       	sbiw	r26, 0x01	; 1
    920c:	8a ee       	ldi	r24, 0xEA	; 234
    920e:	94 e1       	ldi	r25, 0x14	; 20
    9210:	14 96       	adiw	r26, 0x04	; 4
    9212:	9c 93       	st	X, r25
    9214:	8e 93       	st	-X, r24
    9216:	13 97       	sbiw	r26, 0x03	; 3
    9218:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    921c:	0f 90       	pop	r0
    921e:	0f 90       	pop	r0
    9220:	0f 90       	pop	r0
    9222:	0f 90       	pop	r0
    9224:	83 e0       	ldi	r24, 0x03	; 3
    9226:	61 e0       	ldi	r22, 0x01	; 1
    9228:	a8 01       	movw	r20, r16
    922a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    922e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    9230:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    9232:	81 e0       	ldi	r24, 0x01	; 1
    9234:	80 93 bc 01 	sts	0x01BC, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    9238:	10 92 92 01 	sts	0x0192, r1
			  stCloseShift=csNoPumpFound;		     		  
    923c:	87 e0       	ldi	r24, 0x07	; 7
    923e:	7f c0       	rjmp	.+254    	; 0x933e <FCloseShift+0x468>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    9240:	80 91 92 01 	lds	r24, 0x0192
    9244:	8b 30       	cpi	r24, 0x0B	; 11
    9246:	08 f4       	brcc	.+2      	; 0x924a <FCloseShift+0x374>
    9248:	81 c0       	rjmp	.+258    	; 0x934c <FCloseShift+0x476>
    924a:	78 c0       	rjmp	.+240    	; 0x933c <FCloseShift+0x466>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    924c:	81 e0       	ldi	r24, 0x01	; 1
    924e:	61 e0       	ldi	r22, 0x01	; 1
    9250:	47 ed       	ldi	r20, 0xD7	; 215
    9252:	54 e1       	ldi	r21, 0x14	; 20
    9254:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    9258:	0a eb       	ldi	r16, 0xBA	; 186
    925a:	13 e0       	ldi	r17, 0x03	; 3
    925c:	a4 e7       	ldi	r26, 0x74	; 116
    925e:	ea 2e       	mov	r14, r26
    9260:	a8 e0       	ldi	r26, 0x08	; 8
    9262:	fa 2e       	mov	r15, r26
    9264:	80 e0       	ldi	r24, 0x00	; 0
    9266:	b8 01       	movw	r22, r16
    9268:	a7 01       	movw	r20, r14
    926a:	0e 94 4a a7 	call	0x14e94	; 0x14e94 <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    926e:	ed b7       	in	r30, 0x3d	; 61
    9270:	fe b7       	in	r31, 0x3e	; 62
    9272:	38 97       	sbiw	r30, 0x08	; 8
    9274:	0f b6       	in	r0, 0x3f	; 63
    9276:	f8 94       	cli
    9278:	fe bf       	out	0x3e, r31	; 62
    927a:	0f be       	out	0x3f, r0	; 63
    927c:	ed bf       	out	0x3d, r30	; 61
    927e:	31 96       	adiw	r30, 0x01	; 1
    9280:	8e e8       	ldi	r24, 0x8E	; 142
    9282:	97 e0       	ldi	r25, 0x07	; 7
    9284:	ad b7       	in	r26, 0x3d	; 61
    9286:	be b7       	in	r27, 0x3e	; 62
    9288:	12 96       	adiw	r26, 0x02	; 2
    928a:	9c 93       	st	X, r25
    928c:	8e 93       	st	-X, r24
    928e:	11 97       	sbiw	r26, 0x01	; 1
    9290:	81 ed       	ldi	r24, 0xD1	; 209
    9292:	94 e1       	ldi	r25, 0x14	; 20
    9294:	93 83       	std	Z+3, r25	; 0x03
    9296:	82 83       	std	Z+2, r24	; 0x02
    9298:	15 83       	std	Z+5, r17	; 0x05
    929a:	04 83       	std	Z+4, r16	; 0x04
    929c:	f7 82       	std	Z+7, r15	; 0x07
    929e:	e6 82       	std	Z+6, r14	; 0x06
    92a0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  IsGenerateReport=True;
    92a4:	81 e0       	ldi	r24, 0x01	; 1
    92a6:	80 93 86 01 	sts	0x0186, r24
		  IsFinishPrintingTotalizer=False;
    92aa:	10 92 87 01 	sts	0x0187, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    92ae:	8a e0       	ldi	r24, 0x0A	; 10
    92b0:	80 93 49 02 	sts	0x0249, r24
    92b4:	80 e0       	ldi	r24, 0x00	; 0
    92b6:	ed b7       	in	r30, 0x3d	; 61
    92b8:	fe b7       	in	r31, 0x3e	; 62
    92ba:	38 96       	adiw	r30, 0x08	; 8
    92bc:	0f b6       	in	r0, 0x3f	; 63
    92be:	f8 94       	cli
    92c0:	fe bf       	out	0x3e, r31	; 62
    92c2:	0f be       	out	0x3f, r0	; 63
    92c4:	ed bf       	out	0x3d, r30	; 61
    92c6:	43 c0       	rjmp	.+134    	; 0x934e <FCloseShift+0x478>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    92c8:	80 91 87 01 	lds	r24, 0x0187
    92cc:	81 30       	cpi	r24, 0x01	; 1
    92ce:	09 f0       	breq	.+2      	; 0x92d2 <FCloseShift+0x3fc>
    92d0:	3d c0       	rjmp	.+122    	; 0x934c <FCloseShift+0x476>
		      IsFinishPrintingTotalizer=False;
    92d2:	10 92 87 01 	sts	0x0187, r1
		      stCloseShift=csDumpShift;
    92d6:	8c e0       	ldi	r24, 0x0C	; 12
    92d8:	32 c0       	rjmp	.+100    	; 0x933e <FCloseShift+0x468>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    92da:	81 e0       	ldi	r24, 0x01	; 1
    92dc:	61 e0       	ldi	r22, 0x01	; 1
    92de:	4d eb       	ldi	r20, 0xBD	; 189
    92e0:	54 e1       	ldi	r21, 0x14	; 20
    92e2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    92e6:	12 30       	cpi	r17, 0x02	; 2
    92e8:	71 f4       	brne	.+28     	; 0x9306 <FCloseShift+0x430>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    92ea:	e1 99       	sbic	0x1c, 1	; 28
    92ec:	fe cf       	rjmp	.-4      	; 0x92ea <FCloseShift+0x414>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    92ee:	2f e3       	ldi	r18, 0x3F	; 63
    92f0:	31 e0       	ldi	r19, 0x01	; 1
    92f2:	3f bb       	out	0x1f, r19	; 31
    92f4:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    92f6:	e0 9a       	sbi	0x1c, 0	; 28
    92f8:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    92fa:	e1 99       	sbic	0x1c, 1	; 28
    92fc:	fe cf       	rjmp	.-4      	; 0x92fa <FCloseShift+0x424>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    92fe:	3f bb       	out	0x1f, r19	; 31
    9300:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    9302:	8f 5f       	subi	r24, 0xFF	; 255
    9304:	09 c0       	rjmp	.+18     	; 0x9318 <FCloseShift+0x442>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    9306:	11 30       	cpi	r17, 0x01	; 1
    9308:	69 f4       	brne	.+26     	; 0x9324 <FCloseShift+0x44e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    930a:	e1 99       	sbic	0x1c, 1	; 28
    930c:	fe cf       	rjmp	.-4      	; 0x930a <FCloseShift+0x434>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    930e:	8f e3       	ldi	r24, 0x3F	; 63
    9310:	91 e0       	ldi	r25, 0x01	; 1
    9312:	9f bb       	out	0x1f, r25	; 31
    9314:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9316:	81 e0       	ldi	r24, 0x01	; 1
    9318:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    931a:	0f b6       	in	r0, 0x3f	; 63
    931c:	f8 94       	cli
    931e:	e2 9a       	sbi	0x1c, 2	; 28
    9320:	e1 9a       	sbi	0x1c, 1	; 28
    9322:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    9324:	0e 94 93 26 	call	0x4d26	; 0x4d26 <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9328:	83 e4       	ldi	r24, 0x43	; 67
    932a:	98 e0       	ldi	r25, 0x08	; 8
    932c:	6e e8       	ldi	r22, 0x8E	; 142
    932e:	77 e0       	ldi	r23, 0x07	; 7
    9330:	44 e1       	ldi	r20, 0x14	; 20
    9332:	50 e0       	ldi	r21, 0x00	; 0
    9334:	2c e4       	ldi	r18, 0x4C	; 76
    9336:	32 e1       	ldi	r19, 0x12	; 18
    9338:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    933c:	8b e0       	ldi	r24, 0x0B	; 11
    933e:	80 93 49 02 	sts	0x0249, r24
    9342:	04 c0       	rjmp	.+8      	; 0x934c <FCloseShift+0x476>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    9344:	10 92 49 02 	sts	0x0249, r1
    9348:	81 e0       	ldi	r24, 0x01	; 1
    934a:	01 c0       	rjmp	.+2      	; 0x934e <FCloseShift+0x478>
    934c:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    934e:	64 96       	adiw	r28, 0x14	; 20
    9350:	0f b6       	in	r0, 0x3f	; 63
    9352:	f8 94       	cli
    9354:	de bf       	out	0x3e, r29	; 62
    9356:	0f be       	out	0x3f, r0	; 63
    9358:	cd bf       	out	0x3d, r28	; 61
    935a:	cf 91       	pop	r28
    935c:	df 91       	pop	r29
    935e:	1f 91       	pop	r17
    9360:	0f 91       	pop	r16
    9362:	ff 90       	pop	r15
    9364:	ef 90       	pop	r14
    9366:	df 90       	pop	r13
    9368:	08 95       	ret

0000936a <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    936a:	2f 92       	push	r2
    936c:	3f 92       	push	r3
    936e:	4f 92       	push	r4
    9370:	5f 92       	push	r5
    9372:	6f 92       	push	r6
    9374:	7f 92       	push	r7
    9376:	8f 92       	push	r8
    9378:	9f 92       	push	r9
    937a:	bf 92       	push	r11
    937c:	cf 92       	push	r12
    937e:	df 92       	push	r13
    9380:	ef 92       	push	r14
    9382:	ff 92       	push	r15
    9384:	0f 93       	push	r16
    9386:	1f 93       	push	r17
    9388:	df 93       	push	r29
    938a:	cf 93       	push	r28
    938c:	cd b7       	in	r28, 0x3d	; 61
    938e:	de b7       	in	r29, 0x3e	; 62
    9390:	6d 97       	sbiw	r28, 0x1d	; 29
    9392:	0f b6       	in	r0, 0x3f	; 63
    9394:	f8 94       	cli
    9396:	de bf       	out	0x3e, r29	; 62
    9398:	0f be       	out	0x3f, r0	; 63
    939a:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    939c:	e1 99       	sbic	0x1c, 1	; 28
    939e:	fe cf       	rjmp	.-4      	; 0x939c <_menu_host+0x32>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    93a0:	21 ec       	ldi	r18, 0xC1	; 193
    93a2:	33 e0       	ldi	r19, 0x03	; 3
    93a4:	3f bb       	out	0x1f, r19	; 31
    93a6:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    93a8:	e0 9a       	sbi	0x1c, 0	; 28
    93aa:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    93ac:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    93ae:	e1 99       	sbic	0x1c, 1	; 28
    93b0:	fe cf       	rjmp	.-4      	; 0x93ae <_menu_host+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    93b2:	87 e3       	ldi	r24, 0x37	; 55
    93b4:	90 e0       	ldi	r25, 0x00	; 0
    93b6:	9f bb       	out	0x1f, r25	; 31
    93b8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    93ba:	e0 9a       	sbi	0x1c, 0	; 28
    93bc:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&DefShowDateTime);
    93be:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    93c0:	e1 99       	sbic	0x1c, 1	; 28
    93c2:	fe cf       	rjmp	.-4      	; 0x93c0 <_menu_host+0x56>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    93c4:	a8 e3       	ldi	r26, 0x38	; 56
    93c6:	b0 e0       	ldi	r27, 0x00	; 0
    93c8:	bf bb       	out	0x1f, r27	; 31
    93ca:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    93cc:	e0 9a       	sbi	0x1c, 0	; 28
    93ce:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    93d0:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    93d2:	e1 99       	sbic	0x1c, 1	; 28
    93d4:	fe cf       	rjmp	.-4      	; 0x93d2 <_menu_host+0x68>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    93d6:	60 e0       	ldi	r22, 0x00	; 0
    93d8:	26 2e       	mov	r2, r22
    93da:	60 e0       	ldi	r22, 0x00	; 0
    93dc:	36 2e       	mov	r3, r22
    93de:	3f ba       	out	0x1f, r3	; 31
    93e0:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    93e2:	e0 9a       	sbi	0x1c, 0	; 28
    93e4:	bd b2       	in	r11, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);


	lcd_clear();_delay_ms(10);
    93e6:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    93ea:	84 ec       	ldi	r24, 0xC4	; 196
    93ec:	99 e0       	ldi	r25, 0x09	; 9
    93ee:	01 97       	sbiw	r24, 0x01	; 1
    93f0:	f1 f7       	brne	.-4      	; 0x93ee <_menu_host+0x84>
	lcd_printf(1, 1, PSTR("1)Money :"));
    93f2:	81 e0       	ldi	r24, 0x01	; 1
    93f4:	61 e0       	ldi	r22, 0x01	; 1
    93f6:	47 ea       	ldi	r20, 0xA7	; 167
    93f8:	5a e0       	ldi	r21, 0x0A	; 10
    93fa:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    93fe:	82 e0       	ldi	r24, 0x02	; 2
    9400:	61 e0       	ldi	r22, 0x01	; 1
    9402:	4d e9       	ldi	r20, 0x9D	; 157
    9404:	5a e0       	ldi	r21, 0x0A	; 10
    9406:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    940a:	83 e0       	ldi	r24, 0x03	; 3
    940c:	61 e0       	ldi	r22, 0x01	; 1
    940e:	48 e8       	ldi	r20, 0x88	; 136
    9410:	5a e0       	ldi	r21, 0x0A	; 10
    9412:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    9416:	00 d0       	rcall	.+0      	; 0x9418 <_menu_host+0xae>
    9418:	00 d0       	rcall	.+0      	; 0x941a <_menu_host+0xb0>
    941a:	00 d0       	rcall	.+0      	; 0x941c <_menu_host+0xb2>
    941c:	ed b7       	in	r30, 0x3d	; 61
    941e:	fe b7       	in	r31, 0x3e	; 62
    9420:	31 96       	adiw	r30, 0x01	; 1
    9422:	8e 01       	movw	r16, r28
    9424:	06 5f       	subi	r16, 0xF6	; 246
    9426:	1f 4f       	sbci	r17, 0xFF	; 255
    9428:	ad b7       	in	r26, 0x3d	; 61
    942a:	be b7       	in	r27, 0x3e	; 62
    942c:	12 96       	adiw	r26, 0x02	; 2
    942e:	1c 93       	st	X, r17
    9430:	0e 93       	st	-X, r16
    9432:	11 97       	sbiw	r26, 0x01	; 1
    9434:	8b e7       	ldi	r24, 0x7B	; 123
    9436:	9a e0       	ldi	r25, 0x0A	; 10
    9438:	93 83       	std	Z+3, r25	; 0x03
    943a:	82 83       	std	Z+2, r24	; 0x02
    943c:	b4 82       	std	Z+4, r11	; 0x04
    943e:	15 82       	std	Z+5, r1	; 0x05
    9440:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	lcd_print(4, 1,lcdteks);
    9444:	ed b7       	in	r30, 0x3d	; 61
    9446:	fe b7       	in	r31, 0x3e	; 62
    9448:	36 96       	adiw	r30, 0x06	; 6
    944a:	0f b6       	in	r0, 0x3f	; 63
    944c:	f8 94       	cli
    944e:	fe bf       	out	0x3e, r31	; 62
    9450:	0f be       	out	0x3f, r0	; 63
    9452:	ed bf       	out	0x3d, r30	; 61
    9454:	84 e0       	ldi	r24, 0x04	; 4
    9456:	61 e0       	ldi	r22, 0x01	; 1
    9458:	a8 01       	movw	r20, r16
    945a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    945e:	84 e0       	ldi	r24, 0x04	; 4
    9460:	6f e0       	ldi	r22, 0x0F	; 15
    9462:	44 e7       	ldi	r20, 0x74	; 116
    9464:	5a e0       	ldi	r21, 0x0A	; 10
    9466:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    946a:	52 ec       	ldi	r21, 0xC2	; 194
    946c:	e5 2e       	mov	r14, r21
    946e:	52 e0       	ldi	r21, 0x02	; 2
    9470:	f5 2e       	mov	r15, r21
    9472:	6e 01       	movw	r12, r28
    9474:	08 94       	sec
    9476:	c1 1c       	adc	r12, r1
    9478:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		sprintf_P(__buff,PSTR("%d"),__value[__i]);
    947a:	45 e0       	ldi	r20, 0x05	; 5
    947c:	84 2e       	mov	r8, r20
    947e:	91 2c       	mov	r9, r1
    9480:	8c 0e       	add	r8, r28
    9482:	9d 1e       	adc	r9, r29
    9484:	31 e7       	ldi	r19, 0x71	; 113
    9486:	63 2e       	mov	r6, r19
    9488:	3a e0       	ldi	r19, 0x0A	; 10
    948a:	73 2e       	mov	r7, r19
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
	lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    948c:	f7 01       	movw	r30, r14
    948e:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    9490:	08 94       	sec
    9492:	e1 1c       	adc	r14, r1
    9494:	f1 1c       	adc	r15, r1
    9496:	f7 01       	movw	r30, r14
    9498:	14 91       	lpm	r17, Z+
		sprintf_P(__buff,PSTR("%d"),__value[__i]);
    949a:	00 d0       	rcall	.+0      	; 0x949c <_menu_host+0x132>
    949c:	00 d0       	rcall	.+0      	; 0x949e <_menu_host+0x134>
    949e:	00 d0       	rcall	.+0      	; 0x94a0 <_menu_host+0x136>
    94a0:	ed b7       	in	r30, 0x3d	; 61
    94a2:	fe b7       	in	r31, 0x3e	; 62
    94a4:	31 96       	adiw	r30, 0x01	; 1
    94a6:	ad b7       	in	r26, 0x3d	; 61
    94a8:	be b7       	in	r27, 0x3e	; 62
    94aa:	12 96       	adiw	r26, 0x02	; 2
    94ac:	9c 92       	st	X, r9
    94ae:	8e 92       	st	-X, r8
    94b0:	11 97       	sbiw	r26, 0x01	; 1
    94b2:	73 82       	std	Z+3, r7	; 0x03
    94b4:	62 82       	std	Z+2, r6	; 0x02
    94b6:	d6 01       	movw	r26, r12
    94b8:	8d 91       	ld	r24, X+
    94ba:	6d 01       	movw	r12, r26
    94bc:	84 83       	std	Z+4, r24	; 0x04
    94be:	15 82       	std	Z+5, r1	; 0x05
    94c0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		//_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
    94c4:	ed b7       	in	r30, 0x3d	; 61
    94c6:	fe b7       	in	r31, 0x3e	; 62
    94c8:	36 96       	adiw	r30, 0x06	; 6
    94ca:	0f b6       	in	r0, 0x3f	; 63
    94cc:	f8 94       	cli
    94ce:	fe bf       	out	0x3e, r31	; 62
    94d0:	0f be       	out	0x3f, r0	; 63
    94d2:	ed bf       	out	0x3d, r30	; 61
    94d4:	80 2f       	mov	r24, r16
    94d6:	61 2f       	mov	r22, r17
    94d8:	a4 01       	movw	r20, r8
    94da:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    94de:	08 94       	sec
    94e0:	e1 1c       	adc	r14, r1
    94e2:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
	lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    94e4:	f8 ec       	ldi	r31, 0xC8	; 200
    94e6:	ef 16       	cp	r14, r31
    94e8:	f2 e0       	ldi	r31, 0x02	; 2
    94ea:	ff 06       	cpc	r15, r31
    94ec:	79 f6       	brne	.-98     	; 0x948c <_menu_host+0x122>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    94ee:	2a e0       	ldi	r18, 0x0A	; 10
    94f0:	82 2e       	mov	r8, r18
    94f2:	91 2c       	mov	r9, r1
    94f4:	8c 0e       	add	r8, r28
    94f6:	9d 1e       	adc	r9, r29
    94f8:	91 e6       	ldi	r25, 0x61	; 97
    94fa:	49 2e       	mov	r4, r25
    94fc:	9a e0       	ldi	r25, 0x0A	; 10
    94fe:	59 2e       	mov	r5, r25
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    9500:	6e 01       	movw	r12, r28
    9502:	08 94       	sec
    9504:	c1 1c       	adc	r12, r1
    9506:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    9508:	85 e0       	ldi	r24, 0x05	; 5
    950a:	e8 2e       	mov	r14, r24
    950c:	f1 2c       	mov	r15, r1
    950e:	ec 0e       	add	r14, r28
    9510:	fd 1e       	adc	r15, r29
    9512:	0e e6       	ldi	r16, 0x6E	; 110
    9514:	60 2e       	mov	r6, r16
    9516:	0a e0       	ldi	r16, 0x0A	; 10
    9518:	70 2e       	mov	r7, r16
		//_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    951a:	81 e0       	ldi	r24, 0x01	; 1
    951c:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    9520:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    9522:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    9526:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    9528:	17 3e       	cpi	r17, 0xE7	; 231
    952a:	09 f4       	brne	.+2      	; 0x952e <_menu_host+0x1c4>
    952c:	a9 c0       	rjmp	.+338    	; 0x9680 <_menu_host+0x316>
			return;
		if(__key==_KEY_ENTER){
    952e:	17 3b       	cpi	r17, 0xB7	; 183
    9530:	09 f0       	breq	.+2      	; 0x9534 <_menu_host+0x1ca>
    9532:	32 c0       	rjmp	.+100    	; 0x9598 <_menu_host+0x22e>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    9534:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9536:	e1 99       	sbic	0x1c, 1	; 28
    9538:	fe cf       	rjmp	.-4      	; 0x9536 <_menu_host+0x1cc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    953a:	21 ec       	ldi	r18, 0xC1	; 193
    953c:	33 e0       	ldi	r19, 0x03	; 3
    953e:	3f bb       	out	0x1f, r19	; 31
    9540:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    9542:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    9544:	0f b6       	in	r0, 0x3f	; 63
    9546:	f8 94       	cli
    9548:	e2 9a       	sbi	0x1c, 2	; 28
    954a:	e1 9a       	sbi	0x1c, 1	; 28
    954c:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefShowDateTime, __value[1]);
    954e:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9550:	e1 99       	sbic	0x1c, 1	; 28
    9552:	fe cf       	rjmp	.-4      	; 0x9550 <_menu_host+0x1e6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9554:	a7 e3       	ldi	r26, 0x37	; 55
    9556:	b0 e0       	ldi	r27, 0x00	; 0
    9558:	bf bb       	out	0x1f, r27	; 31
    955a:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    955c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    955e:	0f b6       	in	r0, 0x3f	; 63
    9560:	f8 94       	cli
    9562:	e2 9a       	sbi	0x1c, 2	; 28
    9564:	e1 9a       	sbi	0x1c, 1	; 28
    9566:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    9568:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    956a:	e1 99       	sbic	0x1c, 1	; 28
    956c:	fe cf       	rjmp	.-4      	; 0x956a <_menu_host+0x200>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    956e:	e8 e3       	ldi	r30, 0x38	; 56
    9570:	f0 e0       	ldi	r31, 0x00	; 0
    9572:	ff bb       	out	0x1f, r31	; 31
    9574:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    9576:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    9578:	0f b6       	in	r0, 0x3f	; 63
    957a:	f8 94       	cli
    957c:	e2 9a       	sbi	0x1c, 2	; 28
    957e:	e1 9a       	sbi	0x1c, 1	; 28
    9580:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9582:	e1 99       	sbic	0x1c, 1	; 28
    9584:	fe cf       	rjmp	.-4      	; 0x9582 <_menu_host+0x218>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9586:	3f ba       	out	0x1f, r3	; 31
    9588:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    958a:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    958c:	0f b6       	in	r0, 0x3f	; 63
    958e:	f8 94       	cli
    9590:	e2 9a       	sbi	0x1c, 2	; 28
    9592:	e1 9a       	sbi	0x1c, 1	; 28
    9594:	0f be       	out	0x3f, r0	; 63
    9596:	74 c0       	rjmp	.+232    	; 0x9680 <_menu_host+0x316>
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    9598:	81 53       	subi	r24, 0x31	; 49
    959a:	83 30       	cpi	r24, 0x03	; 3
    959c:	08 f0       	brcs	.+2      	; 0x95a0 <_menu_host+0x236>
    959e:	40 c0       	rjmp	.+128    	; 0x9620 <_menu_host+0x2b6>
			if(__value[__num - 0x31] == 1)
    95a0:	a9 2f       	mov	r26, r25
    95a2:	b0 e0       	ldi	r27, 0x00	; 0
    95a4:	d1 97       	sbiw	r26, 0x31	; 49
    95a6:	f6 01       	movw	r30, r12
    95a8:	ea 0f       	add	r30, r26
    95aa:	fb 1f       	adc	r31, r27
    95ac:	80 81       	ld	r24, Z
    95ae:	81 30       	cpi	r24, 0x01	; 1
    95b0:	11 f4       	brne	.+4      	; 0x95b6 <_menu_host+0x24c>
				__value[__num - 0x31] = 0;
    95b2:	10 82       	st	Z, r1
    95b4:	02 c0       	rjmp	.+4      	; 0x95ba <_menu_host+0x250>
			else
				__value[__num - 0x31]++;
    95b6:	8f 5f       	subi	r24, 0xFF	; 255
    95b8:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    95ba:	29 2f       	mov	r18, r25
    95bc:	30 e0       	ldi	r19, 0x00	; 0
    95be:	21 53       	subi	r18, 0x31	; 49
    95c0:	30 40       	sbci	r19, 0x00	; 0
    95c2:	22 0f       	add	r18, r18
    95c4:	33 1f       	adc	r19, r19
    95c6:	c9 01       	movw	r24, r18
    95c8:	8e 53       	subi	r24, 0x3E	; 62
    95ca:	9d 4f       	sbci	r25, 0xFD	; 253
    95cc:	fc 01       	movw	r30, r24
    95ce:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    95d0:	2d 53       	subi	r18, 0x3D	; 61
    95d2:	3d 4f       	sbci	r19, 0xFD	; 253
    95d4:	f9 01       	movw	r30, r18
    95d6:	14 91       	lpm	r17, Z+
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    95d8:	00 d0       	rcall	.+0      	; 0x95da <_menu_host+0x270>
    95da:	00 d0       	rcall	.+0      	; 0x95dc <_menu_host+0x272>
    95dc:	00 d0       	rcall	.+0      	; 0x95de <_menu_host+0x274>
    95de:	2d b7       	in	r18, 0x3d	; 61
    95e0:	3e b7       	in	r19, 0x3e	; 62
    95e2:	2f 5f       	subi	r18, 0xFF	; 255
    95e4:	3f 4f       	sbci	r19, 0xFF	; 255
    95e6:	ed b7       	in	r30, 0x3d	; 61
    95e8:	fe b7       	in	r31, 0x3e	; 62
    95ea:	f2 82       	std	Z+2, r15	; 0x02
    95ec:	e1 82       	std	Z+1, r14	; 0x01
    95ee:	f9 01       	movw	r30, r18
    95f0:	73 82       	std	Z+3, r7	; 0x03
    95f2:	62 82       	std	Z+2, r6	; 0x02
    95f4:	ac 0d       	add	r26, r12
    95f6:	bd 1d       	adc	r27, r13
    95f8:	8c 91       	ld	r24, X
    95fa:	84 83       	std	Z+4, r24	; 0x04
    95fc:	15 82       	std	Z+5, r1	; 0x05
    95fe:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			//_f_inttostr(__buff, __value[__num - 0x31]);
			lcd_print(__x, __y, __buff);
    9602:	2d b7       	in	r18, 0x3d	; 61
    9604:	3e b7       	in	r19, 0x3e	; 62
    9606:	2a 5f       	subi	r18, 0xFA	; 250
    9608:	3f 4f       	sbci	r19, 0xFF	; 255
    960a:	0f b6       	in	r0, 0x3f	; 63
    960c:	f8 94       	cli
    960e:	3e bf       	out	0x3e, r19	; 62
    9610:	0f be       	out	0x3f, r0	; 63
    9612:	2d bf       	out	0x3d, r18	; 61
    9614:	80 2f       	mov	r24, r16
    9616:	61 2f       	mov	r22, r17
    9618:	a7 01       	movw	r20, r14
    961a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    961e:	7d cf       	rjmp	.-262    	; 0x951a <_menu_host+0x1b0>
		}else
		if (__num=='4'){
    9620:	94 33       	cpi	r25, 0x34	; 52
    9622:	09 f0       	breq	.+2      	; 0x9626 <_menu_host+0x2bc>
    9624:	7a cf       	rjmp	.-268    	; 0x951a <_menu_host+0x1b0>
		    if (TermID<=99)TermID++;
    9626:	33 e6       	ldi	r19, 0x63	; 99
    9628:	3b 15       	cp	r19, r11
    962a:	18 f4       	brcc	.+6      	; 0x9632 <_menu_host+0x2c8>
    962c:	bb 24       	eor	r11, r11
    962e:	b3 94       	inc	r11
    9630:	01 c0       	rjmp	.+2      	; 0x9634 <_menu_host+0x2ca>
    9632:	b3 94       	inc	r11
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    9634:	00 d0       	rcall	.+0      	; 0x9636 <_menu_host+0x2cc>
    9636:	00 d0       	rcall	.+0      	; 0x9638 <_menu_host+0x2ce>
    9638:	00 d0       	rcall	.+0      	; 0x963a <_menu_host+0x2d0>
    963a:	ed b7       	in	r30, 0x3d	; 61
    963c:	fe b7       	in	r31, 0x3e	; 62
    963e:	31 96       	adiw	r30, 0x01	; 1
    9640:	ad b7       	in	r26, 0x3d	; 61
    9642:	be b7       	in	r27, 0x3e	; 62
    9644:	12 96       	adiw	r26, 0x02	; 2
    9646:	9c 92       	st	X, r9
    9648:	8e 92       	st	-X, r8
    964a:	11 97       	sbiw	r26, 0x01	; 1
    964c:	53 82       	std	Z+3, r5	; 0x03
    964e:	42 82       	std	Z+2, r4	; 0x02
    9650:	b4 82       	std	Z+4, r11	; 0x04
    9652:	15 82       	std	Z+5, r1	; 0x05
    9654:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    9658:	ed b7       	in	r30, 0x3d	; 61
    965a:	fe b7       	in	r31, 0x3e	; 62
    965c:	36 96       	adiw	r30, 0x06	; 6
    965e:	0f b6       	in	r0, 0x3f	; 63
    9660:	f8 94       	cli
    9662:	fe bf       	out	0x3e, r31	; 62
    9664:	0f be       	out	0x3f, r0	; 63
    9666:	ed bf       	out	0x3d, r30	; 61
    9668:	84 e0       	ldi	r24, 0x04	; 4
    966a:	61 e0       	ldi	r22, 0x01	; 1
    966c:	a4 01       	movw	r20, r8
    966e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    9672:	84 e0       	ldi	r24, 0x04	; 4
    9674:	6f e0       	ldi	r22, 0x0F	; 15
    9676:	4a e5       	ldi	r20, 0x5A	; 90
    9678:	5a e0       	ldi	r21, 0x0A	; 10
    967a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    967e:	4d cf       	rjmp	.-358    	; 0x951a <_menu_host+0x1b0>
		 
		}

	}
}
    9680:	6d 96       	adiw	r28, 0x1d	; 29
    9682:	0f b6       	in	r0, 0x3f	; 63
    9684:	f8 94       	cli
    9686:	de bf       	out	0x3e, r29	; 62
    9688:	0f be       	out	0x3f, r0	; 63
    968a:	cd bf       	out	0x3d, r28	; 61
    968c:	cf 91       	pop	r28
    968e:	df 91       	pop	r29
    9690:	1f 91       	pop	r17
    9692:	0f 91       	pop	r16
    9694:	ff 90       	pop	r15
    9696:	ef 90       	pop	r14
    9698:	df 90       	pop	r13
    969a:	cf 90       	pop	r12
    969c:	bf 90       	pop	r11
    969e:	9f 90       	pop	r9
    96a0:	8f 90       	pop	r8
    96a2:	7f 90       	pop	r7
    96a4:	6f 90       	pop	r6
    96a6:	5f 90       	pop	r5
    96a8:	4f 90       	pop	r4
    96aa:	3f 90       	pop	r3
    96ac:	2f 90       	pop	r2
    96ae:	08 95       	ret

000096b0 <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    96b0:	0e 94 b5 49 	call	0x936a	; 0x936a <_menu_host>
	 return MENU_DONE;
}
    96b4:	81 e0       	ldi	r24, 0x01	; 1
    96b6:	08 95       	ret

000096b8 <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    96b8:	2f 92       	push	r2
    96ba:	3f 92       	push	r3
    96bc:	4f 92       	push	r4
    96be:	5f 92       	push	r5
    96c0:	6f 92       	push	r6
    96c2:	7f 92       	push	r7
    96c4:	8f 92       	push	r8
    96c6:	9f 92       	push	r9
    96c8:	af 92       	push	r10
    96ca:	bf 92       	push	r11
    96cc:	cf 92       	push	r12
    96ce:	df 92       	push	r13
    96d0:	ef 92       	push	r14
    96d2:	ff 92       	push	r15
    96d4:	0f 93       	push	r16
    96d6:	1f 93       	push	r17
    96d8:	df 93       	push	r29
    96da:	cf 93       	push	r28
    96dc:	cd b7       	in	r28, 0x3d	; 61
    96de:	de b7       	in	r29, 0x3e	; 62
    96e0:	2c 97       	sbiw	r28, 0x0c	; 12
    96e2:	0f b6       	in	r0, 0x3f	; 63
    96e4:	f8 94       	cli
    96e6:	de bf       	out	0x3e, r29	; 62
    96e8:	0f be       	out	0x3f, r0	; 63
    96ea:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    96ec:	e1 99       	sbic	0x1c, 1	; 28
    96ee:	fe cf       	rjmp	.-4      	; 0x96ec <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    96f0:	20 e3       	ldi	r18, 0x30	; 48
    96f2:	30 e0       	ldi	r19, 0x00	; 0
    96f4:	3f bb       	out	0x1f, r19	; 31
    96f6:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    96f8:	e0 9a       	sbi	0x1c, 0	; 28
    96fa:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    96fc:	e1 99       	sbic	0x1c, 1	; 28
    96fe:	fe cf       	rjmp	.-4      	; 0x96fc <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9700:	65 e3       	ldi	r22, 0x35	; 53
    9702:	70 e0       	ldi	r23, 0x00	; 0
    9704:	7f bb       	out	0x1f, r23	; 31
    9706:	6e bb       	out	0x1e, r22	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9708:	e0 9a       	sbi	0x1c, 0	; 28
    970a:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    970c:	e1 99       	sbic	0x1c, 1	; 28
    970e:	fe cf       	rjmp	.-4      	; 0x970c <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9710:	84 e3       	ldi	r24, 0x34	; 52
    9712:	90 e0       	ldi	r25, 0x00	; 0
    9714:	9f bb       	out	0x1f, r25	; 31
    9716:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9718:	e0 9a       	sbi	0x1c, 0	; 28
    971a:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    971c:	e1 99       	sbic	0x1c, 1	; 28
    971e:	fe cf       	rjmp	.-4      	; 0x971c <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9720:	a3 e3       	ldi	r26, 0x33	; 51
    9722:	b0 e0       	ldi	r27, 0x00	; 0
    9724:	bf bb       	out	0x1f, r27	; 31
    9726:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9728:	e0 9a       	sbi	0x1c, 0	; 28
    972a:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    972c:	e1 99       	sbic	0x1c, 1	; 28
    972e:	fe cf       	rjmp	.-4      	; 0x972c <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9730:	e1 e3       	ldi	r30, 0x31	; 49
    9732:	f0 e0       	ldi	r31, 0x00	; 0
    9734:	ff bb       	out	0x1f, r31	; 31
    9736:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9738:	e0 9a       	sbi	0x1c, 0	; 28
    973a:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    973c:	e1 99       	sbic	0x1c, 1	; 28
    973e:	fe cf       	rjmp	.-4      	; 0x973c <_menu_printer+0x84>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9740:	62 e3       	ldi	r22, 0x32	; 50
    9742:	70 e0       	ldi	r23, 0x00	; 0
    9744:	7f bb       	out	0x1f, r23	; 31
    9746:	6e bb       	out	0x1e, r22	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9748:	e0 9a       	sbi	0x1c, 0	; 28
    974a:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    974c:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&DefPrintSize);
    974e:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&DefPrintLogo);
    9750:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&DefPrintAutoCut);
    9752:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    9754:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    9756:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    9758:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    975c:	81 e0       	ldi	r24, 0x01	; 1
    975e:	61 e0       	ldi	r22, 0x01	; 1
    9760:	44 ef       	ldi	r20, 0xF4	; 244
    9762:	5a e0       	ldi	r21, 0x0A	; 10
    9764:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    9768:	82 e0       	ldi	r24, 0x02	; 2
    976a:	61 e0       	ldi	r22, 0x01	; 1
    976c:	41 ee       	ldi	r20, 0xE1	; 225
    976e:	5a e0       	ldi	r21, 0x0A	; 10
    9770:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    9774:	83 e0       	ldi	r24, 0x03	; 3
    9776:	61 e0       	ldi	r22, 0x01	; 1
    9778:	41 ed       	ldi	r20, 0xD1	; 209
    977a:	5a e0       	ldi	r21, 0x0A	; 10
    977c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    9780:	84 e0       	ldi	r24, 0x04	; 4
    9782:	61 e0       	ldi	r22, 0x01	; 1
    9784:	41 ec       	ldi	r20, 0xC1	; 193
    9786:	5a e0       	ldi	r21, 0x0A	; 10
    9788:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    978c:	0a ea       	ldi	r16, 0xAA	; 170
    978e:	12 e0       	ldi	r17, 0x02	; 2
    9790:	4e 01       	movw	r8, r28
    9792:	08 94       	sec
    9794:	81 1c       	adc	r8, r1
    9796:	91 1c       	adc	r9, r1
    9798:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
        sprintf_P(__buff,PSTR("%d"),__value[__i]);
    979a:	97 e0       	ldi	r25, 0x07	; 7
    979c:	c9 2e       	mov	r12, r25
    979e:	d1 2c       	mov	r13, r1
    97a0:	cc 0e       	add	r12, r28
    97a2:	dd 1e       	adc	r13, r29
    97a4:	8e eb       	ldi	r24, 0xBE	; 190
    97a6:	28 2e       	mov	r2, r24
    97a8:	8a e0       	ldi	r24, 0x0A	; 10
    97aa:	38 2e       	mov	r3, r24
		//_f_inttostr(__buff, __value[__i]);
		if(__i == 4) sprintf_P(__buff,PSTR("%.2d"),__value[__i]);
    97ac:	b9 eb       	ldi	r27, 0xB9	; 185
    97ae:	4b 2e       	mov	r4, r27
    97b0:	ba e0       	ldi	r27, 0x0A	; 10
    97b2:	5b 2e       	mov	r5, r27
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    97b4:	f8 01       	movw	r30, r16
    97b6:	74 90       	lpm	r7, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    97b8:	0f 5f       	subi	r16, 0xFF	; 255
    97ba:	1f 4f       	sbci	r17, 0xFF	; 255
    97bc:	f8 01       	movw	r30, r16
    97be:	a4 90       	lpm	r10, Z+
    97c0:	01 50       	subi	r16, 0x01	; 1
    97c2:	10 40       	sbci	r17, 0x00	; 0
        sprintf_P(__buff,PSTR("%d"),__value[__i]);
    97c4:	d7 01       	movw	r26, r14
    97c6:	bc 90       	ld	r11, X
    97c8:	00 d0       	rcall	.+0      	; 0x97ca <_menu_printer+0x112>
    97ca:	00 d0       	rcall	.+0      	; 0x97cc <_menu_printer+0x114>
    97cc:	00 d0       	rcall	.+0      	; 0x97ce <_menu_printer+0x116>
    97ce:	ed b7       	in	r30, 0x3d	; 61
    97d0:	fe b7       	in	r31, 0x3e	; 62
    97d2:	31 96       	adiw	r30, 0x01	; 1
    97d4:	ad b7       	in	r26, 0x3d	; 61
    97d6:	be b7       	in	r27, 0x3e	; 62
    97d8:	12 96       	adiw	r26, 0x02	; 2
    97da:	dc 92       	st	X, r13
    97dc:	ce 92       	st	-X, r12
    97de:	11 97       	sbiw	r26, 0x01	; 1
    97e0:	33 82       	std	Z+3, r3	; 0x03
    97e2:	22 82       	std	Z+2, r2	; 0x02
    97e4:	b4 82       	std	Z+4, r11	; 0x04
    97e6:	15 82       	std	Z+5, r1	; 0x05
    97e8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		//_f_inttostr(__buff, __value[__i]);
		if(__i == 4) sprintf_P(__buff,PSTR("%.2d"),__value[__i]);
    97ec:	8e 2d       	mov	r24, r14
    97ee:	88 19       	sub	r24, r8
    97f0:	ed b7       	in	r30, 0x3d	; 61
    97f2:	fe b7       	in	r31, 0x3e	; 62
    97f4:	36 96       	adiw	r30, 0x06	; 6
    97f6:	0f b6       	in	r0, 0x3f	; 63
    97f8:	f8 94       	cli
    97fa:	fe bf       	out	0x3e, r31	; 62
    97fc:	0f be       	out	0x3f, r0	; 63
    97fe:	ed bf       	out	0x3d, r30	; 61
    9800:	84 30       	cpi	r24, 0x04	; 4
    9802:	d1 f4       	brne	.+52     	; 0x9838 <_menu_printer+0x180>
    9804:	00 d0       	rcall	.+0      	; 0x9806 <_menu_printer+0x14e>
    9806:	00 d0       	rcall	.+0      	; 0x9808 <_menu_printer+0x150>
    9808:	00 d0       	rcall	.+0      	; 0x980a <_menu_printer+0x152>
    980a:	ed b7       	in	r30, 0x3d	; 61
    980c:	fe b7       	in	r31, 0x3e	; 62
    980e:	31 96       	adiw	r30, 0x01	; 1
    9810:	ad b7       	in	r26, 0x3d	; 61
    9812:	be b7       	in	r27, 0x3e	; 62
    9814:	12 96       	adiw	r26, 0x02	; 2
    9816:	dc 92       	st	X, r13
    9818:	ce 92       	st	-X, r12
    981a:	11 97       	sbiw	r26, 0x01	; 1
    981c:	53 82       	std	Z+3, r5	; 0x03
    981e:	42 82       	std	Z+2, r4	; 0x02
    9820:	b4 82       	std	Z+4, r11	; 0x04
    9822:	15 82       	std	Z+5, r1	; 0x05
    9824:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    9828:	ed b7       	in	r30, 0x3d	; 61
    982a:	fe b7       	in	r31, 0x3e	; 62
    982c:	36 96       	adiw	r30, 0x06	; 6
    982e:	0f b6       	in	r0, 0x3f	; 63
    9830:	f8 94       	cli
    9832:	fe bf       	out	0x3e, r31	; 62
    9834:	0f be       	out	0x3f, r0	; 63
    9836:	ed bf       	out	0x3d, r30	; 61
		//_f_punctuation(__buff, 0, 2, 0);
		lcd_print(__x, __y, __buff);
    9838:	87 2d       	mov	r24, r7
    983a:	6a 2d       	mov	r22, r10
    983c:	a6 01       	movw	r20, r12
    983e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    9842:	0e 5f       	subi	r16, 0xFE	; 254
    9844:	1f 4f       	sbci	r17, 0xFF	; 255
    9846:	08 94       	sec
    9848:	e1 1c       	adc	r14, r1
    984a:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    984c:	f2 e0       	ldi	r31, 0x02	; 2
    984e:	06 3b       	cpi	r16, 0xB6	; 182
    9850:	1f 07       	cpc	r17, r31
    9852:	09 f0       	breq	.+2      	; 0x9856 <_menu_printer+0x19e>
    9854:	af cf       	rjmp	.-162    	; 0x97b4 <_menu_printer+0xfc>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    9856:	2e 01       	movw	r4, r28
    9858:	08 94       	sec
    985a:	41 1c       	adc	r4, r1
    985c:	51 1c       	adc	r5, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    985e:	a7 e0       	ldi	r26, 0x07	; 7
    9860:	ea 2e       	mov	r14, r26
    9862:	f1 2c       	mov	r15, r1
    9864:	ec 0e       	add	r14, r28
    9866:	fd 1e       	adc	r15, r29
    9868:	f6 eb       	ldi	r31, 0xB6	; 182
    986a:	6f 2e       	mov	r6, r31
    986c:	fa e0       	ldi	r31, 0x0A	; 10
    986e:	7f 2e       	mov	r7, r31
			//_f_inttostr(__buff, __value[__num - 0x31]);
			if((__num == 0x35)||(__num == 0x36))
			   sprintf_P(__buff,PSTR("%.2d"),__value[__num - 0x31]);
    9870:	e1 eb       	ldi	r30, 0xB1	; 177
    9872:	2e 2e       	mov	r2, r30
    9874:	ea e0       	ldi	r30, 0x0A	; 10
    9876:	3e 2e       	mov	r3, r30
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    9878:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&DefPrintSize, __value[1]);
    987a:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&DefPrintLogo, __value[2]);
    987c:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
    987e:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    9880:	cd 80       	ldd	r12, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    9882:	de 80       	ldd	r13, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    9884:	81 e0       	ldi	r24, 0x01	; 1
    9886:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    988a:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    988c:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    9890:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    9892:	17 3e       	cpi	r17, 0xE7	; 231
    9894:	09 f4       	brne	.+2      	; 0x9898 <_menu_printer+0x1e0>
    9896:	b1 c0       	rjmp	.+354    	; 0x99fa <_menu_printer+0x342>
			return;
		if(__key==_KEY_ENTER){
    9898:	17 3b       	cpi	r17, 0xB7	; 183
    989a:	09 f0       	breq	.+2      	; 0x989e <_menu_printer+0x1e6>
    989c:	48 c0       	rjmp	.+144    	; 0x992e <_menu_printer+0x276>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    989e:	e1 99       	sbic	0x1c, 1	; 28
    98a0:	fe cf       	rjmp	.-4      	; 0x989e <_menu_printer+0x1e6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98a2:	20 e3       	ldi	r18, 0x30	; 48
    98a4:	30 e0       	ldi	r19, 0x00	; 0
    98a6:	3f bb       	out	0x1f, r19	; 31
    98a8:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    98aa:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    98ac:	0f b6       	in	r0, 0x3f	; 63
    98ae:	f8 94       	cli
    98b0:	e2 9a       	sbi	0x1c, 2	; 28
    98b2:	e1 9a       	sbi	0x1c, 1	; 28
    98b4:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98b6:	e1 99       	sbic	0x1c, 1	; 28
    98b8:	fe cf       	rjmp	.-4      	; 0x98b6 <_menu_printer+0x1fe>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98ba:	65 e3       	ldi	r22, 0x35	; 53
    98bc:	70 e0       	ldi	r23, 0x00	; 0
    98be:	7f bb       	out	0x1f, r23	; 31
    98c0:	6e bb       	out	0x1e, r22	; 30
#endif
    EEDR = __value;
    98c2:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    98c4:	0f b6       	in	r0, 0x3f	; 63
    98c6:	f8 94       	cli
    98c8:	e2 9a       	sbi	0x1c, 2	; 28
    98ca:	e1 9a       	sbi	0x1c, 1	; 28
    98cc:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98ce:	e1 99       	sbic	0x1c, 1	; 28
    98d0:	fe cf       	rjmp	.-4      	; 0x98ce <_menu_printer+0x216>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98d2:	84 e3       	ldi	r24, 0x34	; 52
    98d4:	90 e0       	ldi	r25, 0x00	; 0
    98d6:	9f bb       	out	0x1f, r25	; 31
    98d8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    98da:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    98dc:	0f b6       	in	r0, 0x3f	; 63
    98de:	f8 94       	cli
    98e0:	e2 9a       	sbi	0x1c, 2	; 28
    98e2:	e1 9a       	sbi	0x1c, 1	; 28
    98e4:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98e6:	e1 99       	sbic	0x1c, 1	; 28
    98e8:	fe cf       	rjmp	.-4      	; 0x98e6 <_menu_printer+0x22e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98ea:	a3 e3       	ldi	r26, 0x33	; 51
    98ec:	b0 e0       	ldi	r27, 0x00	; 0
    98ee:	bf bb       	out	0x1f, r27	; 31
    98f0:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    98f2:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    98f4:	0f b6       	in	r0, 0x3f	; 63
    98f6:	f8 94       	cli
    98f8:	e2 9a       	sbi	0x1c, 2	; 28
    98fa:	e1 9a       	sbi	0x1c, 1	; 28
    98fc:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98fe:	e1 99       	sbic	0x1c, 1	; 28
    9900:	fe cf       	rjmp	.-4      	; 0x98fe <_menu_printer+0x246>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9902:	e1 e3       	ldi	r30, 0x31	; 49
    9904:	f0 e0       	ldi	r31, 0x00	; 0
    9906:	ff bb       	out	0x1f, r31	; 31
    9908:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    990a:	cd ba       	out	0x1d, r12	; 29

    __asm__ __volatile__ (
    990c:	0f b6       	in	r0, 0x3f	; 63
    990e:	f8 94       	cli
    9910:	e2 9a       	sbi	0x1c, 2	; 28
    9912:	e1 9a       	sbi	0x1c, 1	; 28
    9914:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9916:	e1 99       	sbic	0x1c, 1	; 28
    9918:	fe cf       	rjmp	.-4      	; 0x9916 <_menu_printer+0x25e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    991a:	22 e3       	ldi	r18, 0x32	; 50
    991c:	30 e0       	ldi	r19, 0x00	; 0
    991e:	3f bb       	out	0x1f, r19	; 31
    9920:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    9922:	dd ba       	out	0x1d, r13	; 29

    __asm__ __volatile__ (
    9924:	0f b6       	in	r0, 0x3f	; 63
    9926:	f8 94       	cli
    9928:	e2 9a       	sbi	0x1c, 2	; 28
    992a:	e1 9a       	sbi	0x1c, 1	; 28
    992c:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    992e:	80 2f       	mov	r24, r16
    9930:	81 53       	subi	r24, 0x31	; 49
    9932:	86 30       	cpi	r24, 0x06	; 6
    9934:	08 f0       	brcs	.+2      	; 0x9938 <_menu_printer+0x280>
    9936:	a6 cf       	rjmp	.-180    	; 0x9884 <_menu_printer+0x1cc>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    9938:	a0 2f       	mov	r26, r16
    993a:	b0 e0       	ldi	r27, 0x00	; 0
    993c:	d1 97       	sbiw	r26, 0x31	; 49
    993e:	fd 01       	movw	r30, r26
    9940:	ea 54       	subi	r30, 0x4A	; 74
    9942:	fd 4f       	sbci	r31, 0xFD	; 253
    9944:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    9946:	fd 01       	movw	r30, r26
    9948:	e4 54       	subi	r30, 0x44	; 68
    994a:	fd 4f       	sbci	r31, 0xFD	; 253
    994c:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    994e:	f2 01       	movw	r30, r4
    9950:	ea 0f       	add	r30, r26
    9952:	fb 1f       	adc	r31, r27
    9954:	80 81       	ld	r24, Z
    9956:	82 17       	cp	r24, r18
    9958:	11 f4       	brne	.+4      	; 0x995e <_menu_printer+0x2a6>
				__value[__num - 0x31] = __start;
    995a:	90 83       	st	Z, r25
    995c:	02 c0       	rjmp	.+4      	; 0x9962 <_menu_printer+0x2aa>
			else
				__value[__num - 0x31]++;
    995e:	8f 5f       	subi	r24, 0xFF	; 255
    9960:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    9962:	9d 01       	movw	r18, r26
    9964:	22 0f       	add	r18, r18
    9966:	33 1f       	adc	r19, r19
    9968:	c9 01       	movw	r24, r18
    996a:	86 55       	subi	r24, 0x56	; 86
    996c:	9d 4f       	sbci	r25, 0xFD	; 253
    996e:	fc 01       	movw	r30, r24
    9970:	c4 90       	lpm	r12, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    9972:	25 55       	subi	r18, 0x55	; 85
    9974:	3d 4f       	sbci	r19, 0xFD	; 253
    9976:	f9 01       	movw	r30, r18
    9978:	d4 90       	lpm	r13, Z+
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    997a:	a4 0d       	add	r26, r4
    997c:	b5 1d       	adc	r27, r5
    997e:	1c 91       	ld	r17, X
    9980:	00 d0       	rcall	.+0      	; 0x9982 <_menu_printer+0x2ca>
    9982:	00 d0       	rcall	.+0      	; 0x9984 <_menu_printer+0x2cc>
    9984:	00 d0       	rcall	.+0      	; 0x9986 <_menu_printer+0x2ce>
    9986:	ed b7       	in	r30, 0x3d	; 61
    9988:	fe b7       	in	r31, 0x3e	; 62
    998a:	31 96       	adiw	r30, 0x01	; 1
    998c:	ad b7       	in	r26, 0x3d	; 61
    998e:	be b7       	in	r27, 0x3e	; 62
    9990:	12 96       	adiw	r26, 0x02	; 2
    9992:	fc 92       	st	X, r15
    9994:	ee 92       	st	-X, r14
    9996:	11 97       	sbiw	r26, 0x01	; 1
    9998:	73 82       	std	Z+3, r7	; 0x03
    999a:	62 82       	std	Z+2, r6	; 0x02
    999c:	14 83       	std	Z+4, r17	; 0x04
    999e:	15 82       	std	Z+5, r1	; 0x05
    99a0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			//_f_inttostr(__buff, __value[__num - 0x31]);
			if((__num == 0x35)||(__num == 0x36))
    99a4:	05 53       	subi	r16, 0x35	; 53
    99a6:	ed b7       	in	r30, 0x3d	; 61
    99a8:	fe b7       	in	r31, 0x3e	; 62
    99aa:	36 96       	adiw	r30, 0x06	; 6
    99ac:	0f b6       	in	r0, 0x3f	; 63
    99ae:	f8 94       	cli
    99b0:	fe bf       	out	0x3e, r31	; 62
    99b2:	0f be       	out	0x3f, r0	; 63
    99b4:	ed bf       	out	0x3d, r30	; 61
    99b6:	02 30       	cpi	r16, 0x02	; 2
    99b8:	d0 f4       	brcc	.+52     	; 0x99ee <_menu_printer+0x336>
			   sprintf_P(__buff,PSTR("%.2d"),__value[__num - 0x31]);
    99ba:	00 d0       	rcall	.+0      	; 0x99bc <_menu_printer+0x304>
    99bc:	00 d0       	rcall	.+0      	; 0x99be <_menu_printer+0x306>
    99be:	00 d0       	rcall	.+0      	; 0x99c0 <_menu_printer+0x308>
    99c0:	ed b7       	in	r30, 0x3d	; 61
    99c2:	fe b7       	in	r31, 0x3e	; 62
    99c4:	31 96       	adiw	r30, 0x01	; 1
    99c6:	ad b7       	in	r26, 0x3d	; 61
    99c8:	be b7       	in	r27, 0x3e	; 62
    99ca:	12 96       	adiw	r26, 0x02	; 2
    99cc:	fc 92       	st	X, r15
    99ce:	ee 92       	st	-X, r14
    99d0:	11 97       	sbiw	r26, 0x01	; 1
    99d2:	33 82       	std	Z+3, r3	; 0x03
    99d4:	22 82       	std	Z+2, r2	; 0x02
    99d6:	14 83       	std	Z+4, r17	; 0x04
    99d8:	15 82       	std	Z+5, r1	; 0x05
    99da:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    99de:	ed b7       	in	r30, 0x3d	; 61
    99e0:	fe b7       	in	r31, 0x3e	; 62
    99e2:	36 96       	adiw	r30, 0x06	; 6
    99e4:	0f b6       	in	r0, 0x3f	; 63
    99e6:	f8 94       	cli
    99e8:	fe bf       	out	0x3e, r31	; 62
    99ea:	0f be       	out	0x3f, r0	; 63
    99ec:	ed bf       	out	0x3d, r30	; 61
				//_f_punctuation(__buff, 0, 2, 0);

			lcd_print(__x, __y, __buff);
    99ee:	8c 2d       	mov	r24, r12
    99f0:	6d 2d       	mov	r22, r13
    99f2:	a7 01       	movw	r20, r14
    99f4:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    99f8:	3f cf       	rjmp	.-386    	; 0x9878 <_menu_printer+0x1c0>
		}
	}
}
    99fa:	2c 96       	adiw	r28, 0x0c	; 12
    99fc:	0f b6       	in	r0, 0x3f	; 63
    99fe:	f8 94       	cli
    9a00:	de bf       	out	0x3e, r29	; 62
    9a02:	0f be       	out	0x3f, r0	; 63
    9a04:	cd bf       	out	0x3d, r28	; 61
    9a06:	cf 91       	pop	r28
    9a08:	df 91       	pop	r29
    9a0a:	1f 91       	pop	r17
    9a0c:	0f 91       	pop	r16
    9a0e:	ff 90       	pop	r15
    9a10:	ef 90       	pop	r14
    9a12:	df 90       	pop	r13
    9a14:	cf 90       	pop	r12
    9a16:	bf 90       	pop	r11
    9a18:	af 90       	pop	r10
    9a1a:	9f 90       	pop	r9
    9a1c:	8f 90       	pop	r8
    9a1e:	7f 90       	pop	r7
    9a20:	6f 90       	pop	r6
    9a22:	5f 90       	pop	r5
    9a24:	4f 90       	pop	r4
    9a26:	3f 90       	pop	r3
    9a28:	2f 90       	pop	r2
    9a2a:	08 95       	ret

00009a2c <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    9a2c:	0e 94 5c 4b 	call	0x96b8	; 0x96b8 <_menu_printer>
	 return MENU_DONE;
}
    9a30:	81 e0       	ldi	r24, 0x01	; 1
    9a32:	08 95       	ret

00009a34 <_menu_pumpprodinput>:
				*/
		}
	}
}

void _menu_pumpprodinput(unsigned char __select){
    9a34:	6f 92       	push	r6
    9a36:	7f 92       	push	r7
    9a38:	8f 92       	push	r8
    9a3a:	9f 92       	push	r9
    9a3c:	af 92       	push	r10
    9a3e:	bf 92       	push	r11
    9a40:	cf 92       	push	r12
    9a42:	df 92       	push	r13
    9a44:	ef 92       	push	r14
    9a46:	ff 92       	push	r15
    9a48:	0f 93       	push	r16
    9a4a:	1f 93       	push	r17
    9a4c:	df 93       	push	r29
    9a4e:	cf 93       	push	r28
    9a50:	cd b7       	in	r28, 0x3d	; 61
    9a52:	de b7       	in	r29, 0x3e	; 62
    9a54:	a7 97       	sbiw	r28, 0x27	; 39
    9a56:	0f b6       	in	r0, 0x3f	; 63
    9a58:	f8 94       	cli
    9a5a:	de bf       	out	0x3e, r29	; 62
    9a5c:	0f be       	out	0x3f, r0	; 63
    9a5e:	cd bf       	out	0x3d, r28	; 61
    9a60:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9a62:	8e 01       	movw	r16, r28
    9a64:	04 5f       	subi	r16, 0xF4	; 244
    9a66:	1f 4f       	sbci	r17, 0xFF	; 255
    9a68:	c8 01       	movw	r24, r16
    9a6a:	65 e4       	ldi	r22, 0x45	; 69
    9a6c:	70 e0       	ldi	r23, 0x00	; 0
    9a6e:	48 e0       	ldi	r20, 0x08	; 8
    9a70:	50 e0       	ldi	r21, 0x00	; 0
    9a72:	24 e4       	ldi	r18, 0x44	; 68
    9a74:	32 e1       	ldi	r19, 0x12	; 18
    9a76:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    9a7a:	86 e0       	ldi	r24, 0x06	; 6
    9a7c:	b8 9e       	mul	r11, r24
    9a7e:	40 01       	movw	r8, r0
    9a80:	11 24       	eor	r1, r1
    9a82:	85 e5       	ldi	r24, 0x55	; 85
    9a84:	90 e0       	ldi	r25, 0x00	; 0
    9a86:	88 0e       	add	r8, r24
    9a88:	99 1e       	adc	r9, r25
    9a8a:	b6 e0       	ldi	r27, 0x06	; 6
    9a8c:	cb 2e       	mov	r12, r27
    9a8e:	d1 2c       	mov	r13, r1
    9a90:	cc 0e       	add	r12, r28
    9a92:	dd 1e       	adc	r13, r29
    9a94:	c6 01       	movw	r24, r12
    9a96:	b4 01       	movw	r22, r8
    9a98:	46 e0       	ldi	r20, 0x06	; 6
    9a9a:	50 e0       	ldi	r21, 0x00	; 0
    9a9c:	24 e4       	ldi	r18, 0x44	; 68
    9a9e:	32 e1       	ldi	r19, 0x12	; 18
    9aa0:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>

	lcd_clear();_delay_ms(10);
    9aa4:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    9aa8:	84 ec       	ldi	r24, 0xC4	; 196
    9aaa:	99 e0       	ldi	r25, 0x09	; 9
    9aac:	01 97       	sbiw	r24, 0x01	; 1
    9aae:	f1 f7       	brne	.-4      	; 0x9aac <_menu_pumpprodinput+0x78>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    9ab0:	00 d0       	rcall	.+0      	; 0x9ab2 <_menu_pumpprodinput+0x7e>
    9ab2:	00 d0       	rcall	.+0      	; 0x9ab4 <_menu_pumpprodinput+0x80>
    9ab4:	00 d0       	rcall	.+0      	; 0x9ab6 <_menu_pumpprodinput+0x82>
    9ab6:	ed b7       	in	r30, 0x3d	; 61
    9ab8:	fe b7       	in	r31, 0x3e	; 62
    9aba:	31 96       	adiw	r30, 0x01	; 1
    9abc:	a4 e1       	ldi	r26, 0x14	; 20
    9abe:	ea 2e       	mov	r14, r26
    9ac0:	f1 2c       	mov	r15, r1
    9ac2:	ec 0e       	add	r14, r28
    9ac4:	fd 1e       	adc	r15, r29
    9ac6:	ad b7       	in	r26, 0x3d	; 61
    9ac8:	be b7       	in	r27, 0x3e	; 62
    9aca:	12 96       	adiw	r26, 0x02	; 2
    9acc:	fc 92       	st	X, r15
    9ace:	ee 92       	st	-X, r14
    9ad0:	11 97       	sbiw	r26, 0x01	; 1
    9ad2:	8f e6       	ldi	r24, 0x6F	; 111
    9ad4:	9b e0       	ldi	r25, 0x0B	; 11
    9ad6:	93 83       	std	Z+3, r25	; 0x03
    9ad8:	82 83       	std	Z+2, r24	; 0x02
    9ada:	0b 0d       	add	r16, r11
    9adc:	11 1d       	adc	r17, r1
    9ade:	d8 01       	movw	r26, r16
    9ae0:	8c 91       	ld	r24, X
    9ae2:	84 83       	std	Z+4, r24	; 0x04
    9ae4:	15 82       	std	Z+5, r1	; 0x05
    9ae6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    lcd_print(1, 1,lcdteks);
    9aea:	ed b7       	in	r30, 0x3d	; 61
    9aec:	fe b7       	in	r31, 0x3e	; 62
    9aee:	36 96       	adiw	r30, 0x06	; 6
    9af0:	0f b6       	in	r0, 0x3f	; 63
    9af2:	f8 94       	cli
    9af4:	fe bf       	out	0x3e, r31	; 62
    9af6:	0f be       	out	0x3f, r0	; 63
    9af8:	ed bf       	out	0x3d, r30	; 61
    9afa:	81 e0       	ldi	r24, 0x01	; 1
    9afc:	61 e0       	ldi	r22, 0x01	; 1
    9afe:	a7 01       	movw	r20, r14
    9b00:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    9b04:	82 e0       	ldi	r24, 0x02	; 2
    9b06:	61 e0       	ldi	r22, 0x01	; 1
    9b08:	4b e5       	ldi	r20, 0x5B	; 91
    9b0a:	5b e0       	ldi	r21, 0x0B	; 11
    9b0c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    9b10:	83 e0       	ldi	r24, 0x03	; 3
    9b12:	61 e0       	ldi	r22, 0x01	; 1
    9b14:	47 e4       	ldi	r20, 0x47	; 71
    9b16:	5b e0       	ldi	r21, 0x0B	; 11
    9b18:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    9b1c:	84 e0       	ldi	r24, 0x04	; 4
    9b1e:	61 e0       	ldi	r22, 0x01	; 1
    9b20:	42 e3       	ldi	r20, 0x32	; 50
    9b22:	5b e0       	ldi	r21, 0x0B	; 11
    9b24:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    9b28:	ee e9       	ldi	r30, 0x9E	; 158
    9b2a:	ee 2e       	mov	r14, r30
    9b2c:	e2 e0       	ldi	r30, 0x02	; 2
    9b2e:	fe 2e       	mov	r15, r30

	for(i=0;i<6;i++){
		__x = pgm_read_byte(&__prodloc[i][0]);
		__y = pgm_read_byte(&__prodloc[i][1]);

        sprintf_P(__buff,PSTR("%d"),__pump_prod[i]);
    9b30:	5e 01       	movw	r10, r28
    9b32:	08 94       	sec
    9b34:	a1 1c       	adc	r10, r1
    9b36:	b1 1c       	adc	r11, r1
    9b38:	7f e2       	ldi	r23, 0x2F	; 47
    9b3a:	67 2e       	mov	r6, r23
    9b3c:	7b e0       	ldi	r23, 0x0B	; 11
    9b3e:	77 2e       	mov	r7, r23
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(i=0;i<6;i++){
		__x = pgm_read_byte(&__prodloc[i][0]);
    9b40:	f7 01       	movw	r30, r14
    9b42:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[i][1]);
    9b44:	08 94       	sec
    9b46:	e1 1c       	adc	r14, r1
    9b48:	f1 1c       	adc	r15, r1
    9b4a:	f7 01       	movw	r30, r14
    9b4c:	14 91       	lpm	r17, Z+

        sprintf_P(__buff,PSTR("%d"),__pump_prod[i]);
    9b4e:	00 d0       	rcall	.+0      	; 0x9b50 <_menu_pumpprodinput+0x11c>
    9b50:	00 d0       	rcall	.+0      	; 0x9b52 <_menu_pumpprodinput+0x11e>
    9b52:	00 d0       	rcall	.+0      	; 0x9b54 <_menu_pumpprodinput+0x120>
    9b54:	ed b7       	in	r30, 0x3d	; 61
    9b56:	fe b7       	in	r31, 0x3e	; 62
    9b58:	31 96       	adiw	r30, 0x01	; 1
    9b5a:	ad b7       	in	r26, 0x3d	; 61
    9b5c:	be b7       	in	r27, 0x3e	; 62
    9b5e:	12 96       	adiw	r26, 0x02	; 2
    9b60:	bc 92       	st	X, r11
    9b62:	ae 92       	st	-X, r10
    9b64:	11 97       	sbiw	r26, 0x01	; 1
    9b66:	73 82       	std	Z+3, r7	; 0x03
    9b68:	62 82       	std	Z+2, r6	; 0x02
    9b6a:	d6 01       	movw	r26, r12
    9b6c:	8d 91       	ld	r24, X+
    9b6e:	6d 01       	movw	r12, r26
    9b70:	84 83       	std	Z+4, r24	; 0x04
    9b72:	15 82       	std	Z+5, r1	; 0x05
    9b74:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		lcd_print(__x+1, __y, __buff);
    9b78:	ed b7       	in	r30, 0x3d	; 61
    9b7a:	fe b7       	in	r31, 0x3e	; 62
    9b7c:	36 96       	adiw	r30, 0x06	; 6
    9b7e:	0f b6       	in	r0, 0x3f	; 63
    9b80:	f8 94       	cli
    9b82:	fe bf       	out	0x3e, r31	; 62
    9b84:	0f be       	out	0x3f, r0	; 63
    9b86:	ed bf       	out	0x3d, r30	; 61
    9b88:	80 2f       	mov	r24, r16
    9b8a:	8f 5f       	subi	r24, 0xFF	; 255
    9b8c:	61 2f       	mov	r22, r17
    9b8e:	a5 01       	movw	r20, r10
    9b90:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    9b94:	08 94       	sec
    9b96:	e1 1c       	adc	r14, r1
    9b98:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(i=0;i<6;i++){
    9b9a:	fa ea       	ldi	r31, 0xAA	; 170
    9b9c:	ef 16       	cp	r14, r31
    9b9e:	f2 e0       	ldi	r31, 0x02	; 2
    9ba0:	ff 06       	cpc	r15, r31
    9ba2:	71 f6       	brne	.-100    	; 0x9b40 <_menu_pumpprodinput+0x10c>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    9ba4:	66 e0       	ldi	r22, 0x06	; 6
    9ba6:	c6 2e       	mov	r12, r22
    9ba8:	d1 2c       	mov	r13, r1
    9baa:	cc 0e       	add	r12, r28
    9bac:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__pump_prod[__num - 0x31]);
    9bae:	7e 01       	movw	r14, r28
    9bb0:	08 94       	sec
    9bb2:	e1 1c       	adc	r14, r1
    9bb4:	f1 1c       	adc	r15, r1
    9bb6:	5c e2       	ldi	r21, 0x2C	; 44
    9bb8:	a5 2e       	mov	r10, r21
    9bba:	5b e0       	ldi	r21, 0x0B	; 11
    9bbc:	b5 2e       	mov	r11, r21
		//lcd_print(2+(i%2),(i/2)*6,lcdteks);
	}

	while(1){
		
		__key = _key_scan(1);
    9bbe:	81 e0       	ldi	r24, 0x01	; 1
    9bc0:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    9bc4:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    9bc6:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    9bca:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    9bcc:	17 3e       	cpi	r17, 0xE7	; 231
    9bce:	09 f4       	brne	.+2      	; 0x9bd2 <_menu_pumpprodinput+0x19e>
    9bd0:	50 c0       	rjmp	.+160    	; 0x9c72 <_menu_pumpprodinput+0x23e>
			return;
		if(__key == _KEY_ENTER){
    9bd2:	17 3b       	cpi	r17, 0xB7	; 183
    9bd4:	59 f4       	brne	.+22     	; 0x9bec <_menu_pumpprodinput+0x1b8>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9bd6:	c4 01       	movw	r24, r8
    9bd8:	be 01       	movw	r22, r28
    9bda:	6a 5f       	subi	r22, 0xFA	; 250
    9bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    9bde:	46 e0       	ldi	r20, 0x06	; 6
    9be0:	50 e0       	ldi	r21, 0x00	; 0
    9be2:	2c e4       	ldi	r18, 0x4C	; 76
    9be4:	32 e1       	ldi	r19, 0x12	; 18
    9be6:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    9bea:	43 c0       	rjmp	.+134    	; 0x9c72 <_menu_pumpprodinput+0x23e>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    9bec:	81 53       	subi	r24, 0x31	; 49
    9bee:	86 30       	cpi	r24, 0x06	; 6
    9bf0:	30 f7       	brcc	.-52     	; 0x9bbe <_menu_pumpprodinput+0x18a>
			if(__pump_prod[__num - '1'] == 6)
    9bf2:	a9 2f       	mov	r26, r25
    9bf4:	b0 e0       	ldi	r27, 0x00	; 0
    9bf6:	d1 97       	sbiw	r26, 0x31	; 49
    9bf8:	f6 01       	movw	r30, r12
    9bfa:	ea 0f       	add	r30, r26
    9bfc:	fb 1f       	adc	r31, r27
    9bfe:	80 81       	ld	r24, Z
    9c00:	86 30       	cpi	r24, 0x06	; 6
    9c02:	11 f4       	brne	.+4      	; 0x9c08 <_menu_pumpprodinput+0x1d4>
				__pump_prod[__num - '1'] = 0;
    9c04:	10 82       	st	Z, r1
    9c06:	02 c0       	rjmp	.+4      	; 0x9c0c <_menu_pumpprodinput+0x1d8>
			else
				__pump_prod[__num - '1']++;
    9c08:	8f 5f       	subi	r24, 0xFF	; 255
    9c0a:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    9c0c:	29 2f       	mov	r18, r25
    9c0e:	30 e0       	ldi	r19, 0x00	; 0
    9c10:	21 53       	subi	r18, 0x31	; 49
    9c12:	30 40       	sbci	r19, 0x00	; 0
    9c14:	22 0f       	add	r18, r18
    9c16:	33 1f       	adc	r19, r19
    9c18:	c9 01       	movw	r24, r18
    9c1a:	82 56       	subi	r24, 0x62	; 98
    9c1c:	9d 4f       	sbci	r25, 0xFD	; 253
    9c1e:	fc 01       	movw	r30, r24
    9c20:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    9c22:	21 56       	subi	r18, 0x61	; 97
    9c24:	3d 4f       	sbci	r19, 0xFD	; 253
    9c26:	f9 01       	movw	r30, r18
    9c28:	14 91       	lpm	r17, Z+
			sprintf_P(__buff,PSTR("%d"),__pump_prod[__num - 0x31]);
    9c2a:	00 d0       	rcall	.+0      	; 0x9c2c <_menu_pumpprodinput+0x1f8>
    9c2c:	00 d0       	rcall	.+0      	; 0x9c2e <_menu_pumpprodinput+0x1fa>
    9c2e:	00 d0       	rcall	.+0      	; 0x9c30 <_menu_pumpprodinput+0x1fc>
    9c30:	2d b7       	in	r18, 0x3d	; 61
    9c32:	3e b7       	in	r19, 0x3e	; 62
    9c34:	2f 5f       	subi	r18, 0xFF	; 255
    9c36:	3f 4f       	sbci	r19, 0xFF	; 255
    9c38:	ed b7       	in	r30, 0x3d	; 61
    9c3a:	fe b7       	in	r31, 0x3e	; 62
    9c3c:	f2 82       	std	Z+2, r15	; 0x02
    9c3e:	e1 82       	std	Z+1, r14	; 0x01
    9c40:	f9 01       	movw	r30, r18
    9c42:	b3 82       	std	Z+3, r11	; 0x03
    9c44:	a2 82       	std	Z+2, r10	; 0x02
    9c46:	ac 0d       	add	r26, r12
    9c48:	bd 1d       	adc	r27, r13
    9c4a:	8c 91       	ld	r24, X
    9c4c:	84 83       	std	Z+4, r24	; 0x04
    9c4e:	15 82       	std	Z+5, r1	; 0x05
    9c50:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			//_f_inttostr(__buff, __pump_prod[__num - 0x31]);
			lcd_print(__x+1, __y, __buff);
    9c54:	8d b7       	in	r24, 0x3d	; 61
    9c56:	9e b7       	in	r25, 0x3e	; 62
    9c58:	06 96       	adiw	r24, 0x06	; 6
    9c5a:	0f b6       	in	r0, 0x3f	; 63
    9c5c:	f8 94       	cli
    9c5e:	9e bf       	out	0x3e, r25	; 62
    9c60:	0f be       	out	0x3f, r0	; 63
    9c62:	8d bf       	out	0x3d, r24	; 61
    9c64:	80 2f       	mov	r24, r16
    9c66:	8f 5f       	subi	r24, 0xFF	; 255
    9c68:	61 2f       	mov	r22, r17
    9c6a:	a7 01       	movw	r20, r14
    9c6c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    9c70:	a6 cf       	rjmp	.-180    	; 0x9bbe <_menu_pumpprodinput+0x18a>
		}
	}
}
    9c72:	a7 96       	adiw	r28, 0x27	; 39
    9c74:	0f b6       	in	r0, 0x3f	; 63
    9c76:	f8 94       	cli
    9c78:	de bf       	out	0x3e, r29	; 62
    9c7a:	0f be       	out	0x3f, r0	; 63
    9c7c:	cd bf       	out	0x3d, r28	; 61
    9c7e:	cf 91       	pop	r28
    9c80:	df 91       	pop	r29
    9c82:	1f 91       	pop	r17
    9c84:	0f 91       	pop	r16
    9c86:	ff 90       	pop	r15
    9c88:	ef 90       	pop	r14
    9c8a:	df 90       	pop	r13
    9c8c:	cf 90       	pop	r12
    9c8e:	bf 90       	pop	r11
    9c90:	af 90       	pop	r10
    9c92:	9f 90       	pop	r9
    9c94:	8f 90       	pop	r8
    9c96:	7f 90       	pop	r7
    9c98:	6f 90       	pop	r6
    9c9a:	08 95       	ret

00009c9c <_menu_pumpprod>:
}

void _menu_pumpprod(void){
	char KeyPressed,KeyChar;
	while(1){
		lcd_clear();
    9c9c:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		_scr_pump();
    9ca0:	0e 94 35 45 	call	0x8a6a	; 0x8a6a <_scr_pump>
		while(1){
			KeyPressed=_key_scan(1);
    9ca4:	81 e0       	ldi	r24, 0x01	; 1
    9ca6:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		    KeyChar=_key_btn(KeyPressed);
    9caa:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    9cae:	98 2f       	mov	r25, r24

			if ((KeyChar>='1')&&(KeyChar<='8')){
    9cb0:	81 53       	subi	r24, 0x31	; 49
    9cb2:	88 30       	cpi	r24, 0x08	; 8
    9cb4:	18 f4       	brcc	.+6      	; 0x9cbc <_menu_pumpprod+0x20>
			     _menu_pumpprodinput(KeyChar-'1');
    9cb6:	0e 94 1a 4d 	call	0x9a34	; 0x9a34 <_menu_pumpprodinput>
    9cba:	f0 cf       	rjmp	.-32     	; 0x9c9c <_menu_pumpprod>
				break;
			}else if (KeyChar=='*'){
    9cbc:	9a 32       	cpi	r25, 0x2A	; 42
    9cbe:	91 f7       	brne	.-28     	; 0x9ca4 <_menu_pumpprod+0x8>
			if(__key == _KEY_CANCEL)
				return;
				*/
		}
	}
}
    9cc0:	08 95       	ret

00009cc2 <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    9cc2:	6f 92       	push	r6
    9cc4:	7f 92       	push	r7
    9cc6:	8f 92       	push	r8
    9cc8:	9f 92       	push	r9
    9cca:	af 92       	push	r10
    9ccc:	bf 92       	push	r11
    9cce:	cf 92       	push	r12
    9cd0:	df 92       	push	r13
    9cd2:	ef 92       	push	r14
    9cd4:	ff 92       	push	r15
    9cd6:	1f 93       	push	r17
    9cd8:	df 93       	push	r29
    9cda:	cf 93       	push	r28
    9cdc:	cd b7       	in	r28, 0x3d	; 61
    9cde:	de b7       	in	r29, 0x3e	; 62
    9ce0:	2d 97       	sbiw	r28, 0x0d	; 13
    9ce2:	0f b6       	in	r0, 0x3f	; 63
    9ce4:	f8 94       	cli
    9ce6:	de bf       	out	0x3e, r29	; 62
    9ce8:	0f be       	out	0x3f, r0	; 63
    9cea:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9cec:	36 e0       	ldi	r19, 0x06	; 6
    9cee:	c3 2e       	mov	r12, r19
    9cf0:	d1 2c       	mov	r13, r1
    9cf2:	cc 0e       	add	r12, r28
    9cf4:	dd 1e       	adc	r13, r29
    9cf6:	c6 01       	movw	r24, r12
    9cf8:	6d e4       	ldi	r22, 0x4D	; 77
    9cfa:	70 e0       	ldi	r23, 0x00	; 0
    9cfc:	48 e0       	ldi	r20, 0x08	; 8
    9cfe:	50 e0       	ldi	r21, 0x00	; 0
    9d00:	24 e4       	ldi	r18, 0x44	; 68
    9d02:	32 e1       	ldi	r19, 0x12	; 18
    9d04:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    9d08:	83 e6       	ldi	r24, 0x63	; 99
    9d0a:	80 93 56 01 	sts	0x0156, r24
	lcd_clear();_delay_ms(10);
    9d0e:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    9d12:	84 ec       	ldi	r24, 0xC4	; 196
    9d14:	99 e0       	ldi	r25, 0x09	; 9
    9d16:	01 97       	sbiw	r24, 0x01	; 1
    9d18:	f1 f7       	brne	.-4      	; 0x9d16 <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    9d1a:	81 e0       	ldi	r24, 0x01	; 1
    9d1c:	61 e0       	ldi	r22, 0x01	; 1
    9d1e:	4a e6       	ldi	r20, 0x6A	; 106
    9d20:	5c e0       	ldi	r21, 0x0C	; 12
    9d22:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    9d26:	82 e0       	ldi	r24, 0x02	; 2
    9d28:	61 e0       	ldi	r22, 0x01	; 1
    9d2a:	4e e5       	ldi	r20, 0x5E	; 94
    9d2c:	5c e0       	ldi	r21, 0x0C	; 12
    9d2e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    9d32:	83 e0       	ldi	r24, 0x03	; 3
    9d34:	61 e0       	ldi	r22, 0x01	; 1
    9d36:	49 e4       	ldi	r20, 0x49	; 73
    9d38:	5c e0       	ldi	r21, 0x0C	; 12
    9d3a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    9d3e:	84 e0       	ldi	r24, 0x04	; 4
    9d40:	61 e0       	ldi	r22, 0x01	; 1
    9d42:	44 e3       	ldi	r20, 0x34	; 52
    9d44:	5c e0       	ldi	r21, 0x0C	; 12
    9d46:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    9d4a:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9d4c:	5e 01       	movw	r10, r28
    9d4e:	08 94       	sec
    9d50:	a1 1c       	adc	r10, r1
    9d52:	b1 1c       	adc	r11, r1
    9d54:	2f e2       	ldi	r18, 0x2F	; 47
    9d56:	62 2e       	mov	r6, r18
    9d58:	2c e0       	ldi	r18, 0x0C	; 12
    9d5a:	72 2e       	mov	r7, r18
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    9d5c:	9e e0       	ldi	r25, 0x0E	; 14
    9d5e:	89 2e       	mov	r8, r25
    9d60:	91 2c       	mov	r9, r1
    9d62:	8c 0e       	add	r8, r28
    9d64:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    9d66:	1e 2d       	mov	r17, r14
    9d68:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9d6a:	00 d0       	rcall	.+0      	; 0x9d6c <FMenuPumpLabel+0xaa>
    9d6c:	00 d0       	rcall	.+0      	; 0x9d6e <FMenuPumpLabel+0xac>
    9d6e:	00 d0       	rcall	.+0      	; 0x9d70 <FMenuPumpLabel+0xae>
    9d70:	ed b7       	in	r30, 0x3d	; 61
    9d72:	fe b7       	in	r31, 0x3e	; 62
    9d74:	31 96       	adiw	r30, 0x01	; 1
    9d76:	ad b7       	in	r26, 0x3d	; 61
    9d78:	be b7       	in	r27, 0x3e	; 62
    9d7a:	12 96       	adiw	r26, 0x02	; 2
    9d7c:	bc 92       	st	X, r11
    9d7e:	ae 92       	st	-X, r10
    9d80:	11 97       	sbiw	r26, 0x01	; 1
    9d82:	73 82       	std	Z+3, r7	; 0x03
    9d84:	62 82       	std	Z+2, r6	; 0x02
    9d86:	d7 01       	movw	r26, r14
    9d88:	8d 91       	ld	r24, X+
    9d8a:	7d 01       	movw	r14, r26
    9d8c:	84 83       	std	Z+4, r24	; 0x04
    9d8e:	15 82       	std	Z+5, r1	; 0x05
    9d90:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    9d94:	ed b7       	in	r30, 0x3d	; 61
    9d96:	fe b7       	in	r31, 0x3e	; 62
    9d98:	36 96       	adiw	r30, 0x06	; 6
    9d9a:	0f b6       	in	r0, 0x3f	; 63
    9d9c:	f8 94       	cli
    9d9e:	fe bf       	out	0x3e, r31	; 62
    9da0:	0f be       	out	0x3f, r0	; 63
    9da2:	ed bf       	out	0x3d, r30	; 61
    9da4:	61 2f       	mov	r22, r17
    9da6:	66 95       	lsr	r22
    9da8:	66 95       	lsr	r22
    9daa:	66 0f       	add	r22, r22
    9dac:	66 0f       	add	r22, r22
    9dae:	66 0f       	add	r22, r22
    9db0:	6b 5f       	subi	r22, 0xFB	; 251
    9db2:	13 70       	andi	r17, 0x03	; 3
    9db4:	81 2f       	mov	r24, r17
    9db6:	8f 5f       	subi	r24, 0xFF	; 255
    9db8:	a5 01       	movw	r20, r10
    9dba:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    9dbe:	e8 14       	cp	r14, r8
    9dc0:	f9 04       	cpc	r15, r9
    9dc2:	89 f6       	brne	.-94     	; 0x9d66 <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9dc4:	86 e0       	ldi	r24, 0x06	; 6
    9dc6:	c8 2e       	mov	r12, r24
    9dc8:	d1 2c       	mov	r13, r1
    9dca:	cc 0e       	add	r12, r28
    9dcc:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9dce:	7e 01       	movw	r14, r28
    9dd0:	08 94       	sec
    9dd2:	e1 1c       	adc	r14, r1
    9dd4:	f1 1c       	adc	r15, r1
    9dd6:	1a e2       	ldi	r17, 0x2A	; 42
    9dd8:	a1 2e       	mov	r10, r17
    9dda:	1c e0       	ldi	r17, 0x0C	; 12
    9ddc:	b1 2e       	mov	r11, r17
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    9dde:	81 e0       	ldi	r24, 0x01	; 1
    9de0:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    9de4:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    9de6:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    9dea:	17 3e       	cpi	r17, 0xE7	; 231
    9dec:	09 f4       	brne	.+2      	; 0x9df0 <FMenuPumpLabel+0x12e>
    9dee:	4b c0       	rjmp	.+150    	; 0x9e86 <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    9df0:	17 3b       	cpi	r17, 0xB7	; 183
    9df2:	61 f4       	brne	.+24     	; 0x9e0c <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9df4:	8d e4       	ldi	r24, 0x4D	; 77
    9df6:	90 e0       	ldi	r25, 0x00	; 0
    9df8:	be 01       	movw	r22, r28
    9dfa:	6a 5f       	subi	r22, 0xFA	; 250
    9dfc:	7f 4f       	sbci	r23, 0xFF	; 255
    9dfe:	48 e0       	ldi	r20, 0x08	; 8
    9e00:	50 e0       	ldi	r21, 0x00	; 0
    9e02:	2c e4       	ldi	r18, 0x4C	; 76
    9e04:	32 e1       	ldi	r19, 0x12	; 18
    9e06:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
    9e0a:	3d c0       	rjmp	.+122    	; 0x9e86 <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    9e0c:	18 2f       	mov	r17, r24
    9e0e:	11 53       	subi	r17, 0x31	; 49
    9e10:	18 30       	cpi	r17, 0x08	; 8
    9e12:	28 f7       	brcc	.-54     	; 0x9dde <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9e14:	a1 2f       	mov	r26, r17
    9e16:	b0 e0       	ldi	r27, 0x00	; 0
    9e18:	f6 01       	movw	r30, r12
    9e1a:	ea 0f       	add	r30, r26
    9e1c:	fb 1f       	adc	r31, r27
    9e1e:	90 81       	ld	r25, Z
    9e20:	80 91 56 01 	lds	r24, 0x0156
    9e24:	98 17       	cp	r25, r24
    9e26:	11 f4       	brne	.+4      	; 0x9e2c <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    9e28:	10 82       	st	Z, r1
    9e2a:	02 c0       	rjmp	.+4      	; 0x9e30 <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    9e2c:	9f 5f       	subi	r25, 0xFF	; 255
    9e2e:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9e30:	00 d0       	rcall	.+0      	; 0x9e32 <FMenuPumpLabel+0x170>
    9e32:	00 d0       	rcall	.+0      	; 0x9e34 <FMenuPumpLabel+0x172>
    9e34:	00 d0       	rcall	.+0      	; 0x9e36 <FMenuPumpLabel+0x174>
    9e36:	2d b7       	in	r18, 0x3d	; 61
    9e38:	3e b7       	in	r19, 0x3e	; 62
    9e3a:	2f 5f       	subi	r18, 0xFF	; 255
    9e3c:	3f 4f       	sbci	r19, 0xFF	; 255
    9e3e:	ed b7       	in	r30, 0x3d	; 61
    9e40:	fe b7       	in	r31, 0x3e	; 62
    9e42:	f2 82       	std	Z+2, r15	; 0x02
    9e44:	e1 82       	std	Z+1, r14	; 0x01
    9e46:	f9 01       	movw	r30, r18
    9e48:	b3 82       	std	Z+3, r11	; 0x03
    9e4a:	a2 82       	std	Z+2, r10	; 0x02
    9e4c:	ac 0d       	add	r26, r12
    9e4e:	bd 1d       	adc	r27, r13
    9e50:	8c 91       	ld	r24, X
    9e52:	84 83       	std	Z+4, r24	; 0x04
    9e54:	15 82       	std	Z+5, r1	; 0x05
    9e56:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    9e5a:	8d b7       	in	r24, 0x3d	; 61
    9e5c:	9e b7       	in	r25, 0x3e	; 62
    9e5e:	06 96       	adiw	r24, 0x06	; 6
    9e60:	0f b6       	in	r0, 0x3f	; 63
    9e62:	f8 94       	cli
    9e64:	9e bf       	out	0x3e, r25	; 62
    9e66:	0f be       	out	0x3f, r0	; 63
    9e68:	8d bf       	out	0x3d, r24	; 61
    9e6a:	61 2f       	mov	r22, r17
    9e6c:	66 95       	lsr	r22
    9e6e:	66 95       	lsr	r22
    9e70:	66 0f       	add	r22, r22
    9e72:	66 0f       	add	r22, r22
    9e74:	66 0f       	add	r22, r22
    9e76:	6b 5f       	subi	r22, 0xFB	; 251
    9e78:	13 70       	andi	r17, 0x03	; 3
    9e7a:	81 2f       	mov	r24, r17
    9e7c:	8f 5f       	subi	r24, 0xFF	; 255
    9e7e:	a7 01       	movw	r20, r14
    9e80:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    9e84:	ac cf       	rjmp	.-168    	; 0x9dde <FMenuPumpLabel+0x11c>
		}
	}
}
    9e86:	2d 96       	adiw	r28, 0x0d	; 13
    9e88:	0f b6       	in	r0, 0x3f	; 63
    9e8a:	f8 94       	cli
    9e8c:	de bf       	out	0x3e, r29	; 62
    9e8e:	0f be       	out	0x3f, r0	; 63
    9e90:	cd bf       	out	0x3d, r28	; 61
    9e92:	cf 91       	pop	r28
    9e94:	df 91       	pop	r29
    9e96:	1f 91       	pop	r17
    9e98:	ff 90       	pop	r15
    9e9a:	ef 90       	pop	r14
    9e9c:	df 90       	pop	r13
    9e9e:	cf 90       	pop	r12
    9ea0:	bf 90       	pop	r11
    9ea2:	af 90       	pop	r10
    9ea4:	9f 90       	pop	r9
    9ea6:	8f 90       	pop	r8
    9ea8:	7f 90       	pop	r7
    9eaa:	6f 90       	pop	r6
    9eac:	08 95       	ret

00009eae <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
    9eae:	df 92       	push	r13
    9eb0:	ef 92       	push	r14
    9eb2:	ff 92       	push	r15
    9eb4:	0f 93       	push	r16
    9eb6:	1f 93       	push	r17
    9eb8:	df 93       	push	r29
    9eba:	cf 93       	push	r28
    9ebc:	cd b7       	in	r28, 0x3d	; 61
    9ebe:	de b7       	in	r29, 0x3e	; 62
    9ec0:	64 97       	sbiw	r28, 0x14	; 20
    9ec2:	0f b6       	in	r0, 0x3f	; 63
    9ec4:	f8 94       	cli
    9ec6:	de bf       	out	0x3e, r29	; 62
    9ec8:	0f be       	out	0x3f, r0	; 63
    9eca:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
    9ecc:	80 91 1f 02 	lds	r24, 0x021F
    9ed0:	82 30       	cpi	r24, 0x02	; 2
    9ed2:	09 f4       	brne	.+2      	; 0x9ed6 <FSettingDec+0x28>
    9ed4:	c7 c0       	rjmp	.+398    	; 0xa064 <FSettingDec+0x1b6>
    9ed6:	83 30       	cpi	r24, 0x03	; 3
    9ed8:	30 f4       	brcc	.+12     	; 0x9ee6 <FSettingDec+0x38>
    9eda:	88 23       	and	r24, r24
    9edc:	71 f0       	breq	.+28     	; 0x9efa <FSettingDec+0x4c>
    9ede:	81 30       	cpi	r24, 0x01	; 1
    9ee0:	09 f0       	breq	.+2      	; 0x9ee4 <FSettingDec+0x36>
    9ee2:	b9 c1       	rjmp	.+882    	; 0xa256 <FSettingDec+0x3a8>
    9ee4:	92 c0       	rjmp	.+292    	; 0xa00a <FSettingDec+0x15c>
    9ee6:	84 30       	cpi	r24, 0x04	; 4
    9ee8:	09 f4       	brne	.+2      	; 0x9eec <FSettingDec+0x3e>
    9eea:	ad c1       	rjmp	.+858    	; 0xa246 <FSettingDec+0x398>
    9eec:	84 30       	cpi	r24, 0x04	; 4
    9eee:	08 f4       	brcc	.+2      	; 0x9ef2 <FSettingDec+0x44>
    9ef0:	68 c1       	rjmp	.+720    	; 0xa1c2 <FSettingDec+0x314>
    9ef2:	85 30       	cpi	r24, 0x05	; 5
    9ef4:	09 f0       	breq	.+2      	; 0x9ef8 <FSettingDec+0x4a>
    9ef6:	af c1       	rjmp	.+862    	; 0xa256 <FSettingDec+0x3a8>
    9ef8:	aa c1       	rjmp	.+852    	; 0xa24e <FSettingDec+0x3a0>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
    9efa:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9efe:	e1 99       	sbic	0x1c, 1	; 28
    9f00:	fe cf       	rjmp	.-4      	; 0x9efe <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9f02:	89 e3       	ldi	r24, 0x39	; 57
    9f04:	90 e0       	ldi	r25, 0x00	; 0
    9f06:	9f bb       	out	0x1f, r25	; 31
    9f08:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9f0a:	e0 9a       	sbi	0x1c, 0	; 28
    9f0c:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9f0e:	e1 99       	sbic	0x1c, 1	; 28
    9f10:	fe cf       	rjmp	.-4      	; 0x9f0e <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9f12:	8a e3       	ldi	r24, 0x3A	; 58
    9f14:	90 e0       	ldi	r25, 0x00	; 0
    9f16:	9f bb       	out	0x1f, r25	; 31
    9f18:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9f1a:	e0 9a       	sbi	0x1c, 0	; 28
    9f1c:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9f1e:	e1 99       	sbic	0x1c, 1	; 28
    9f20:	fe cf       	rjmp	.-4      	; 0x9f1e <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9f22:	8b e3       	ldi	r24, 0x3B	; 59
    9f24:	90 e0       	ldi	r25, 0x00	; 0
    9f26:	9f bb       	out	0x1f, r25	; 31
    9f28:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9f2a:	e0 9a       	sbi	0x1c, 0	; 28
    9f2c:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
    9f2e:	00 d0       	rcall	.+0      	; 0x9f30 <FSettingDec+0x82>
    9f30:	00 d0       	rcall	.+0      	; 0x9f32 <FSettingDec+0x84>
    9f32:	00 d0       	rcall	.+0      	; 0x9f34 <FSettingDec+0x86>
    9f34:	ed b7       	in	r30, 0x3d	; 61
    9f36:	fe b7       	in	r31, 0x3e	; 62
    9f38:	31 96       	adiw	r30, 0x01	; 1
    9f3a:	8e 01       	movw	r16, r28
    9f3c:	0f 5f       	subi	r16, 0xFF	; 255
    9f3e:	1f 4f       	sbci	r17, 0xFF	; 255
    9f40:	ad b7       	in	r26, 0x3d	; 61
    9f42:	be b7       	in	r27, 0x3e	; 62
    9f44:	12 96       	adiw	r26, 0x02	; 2
    9f46:	1c 93       	st	X, r17
    9f48:	0e 93       	st	-X, r16
    9f4a:	11 97       	sbiw	r26, 0x01	; 1
    9f4c:	8f ed       	ldi	r24, 0xDF	; 223
    9f4e:	90 e1       	ldi	r25, 0x10	; 16
    9f50:	93 83       	std	Z+3, r25	; 0x03
    9f52:	82 83       	std	Z+2, r24	; 0x02
    9f54:	24 83       	std	Z+4, r18	; 0x04
    9f56:	15 82       	std	Z+5, r1	; 0x05
    9f58:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(1,1,lcdteks);
    9f5c:	8d b7       	in	r24, 0x3d	; 61
    9f5e:	9e b7       	in	r25, 0x3e	; 62
    9f60:	06 96       	adiw	r24, 0x06	; 6
    9f62:	0f b6       	in	r0, 0x3f	; 63
    9f64:	f8 94       	cli
    9f66:	9e bf       	out	0x3e, r25	; 62
    9f68:	0f be       	out	0x3f, r0	; 63
    9f6a:	8d bf       	out	0x3d, r24	; 61
    9f6c:	81 e0       	ldi	r24, 0x01	; 1
    9f6e:	61 e0       	ldi	r22, 0x01	; 1
    9f70:	a8 01       	movw	r20, r16
    9f72:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
    9f76:	00 d0       	rcall	.+0      	; 0x9f78 <FSettingDec+0xca>
    9f78:	00 d0       	rcall	.+0      	; 0x9f7a <FSettingDec+0xcc>
    9f7a:	00 d0       	rcall	.+0      	; 0x9f7c <FSettingDec+0xce>
    9f7c:	ed b7       	in	r30, 0x3d	; 61
    9f7e:	fe b7       	in	r31, 0x3e	; 62
    9f80:	31 96       	adiw	r30, 0x01	; 1
    9f82:	ad b7       	in	r26, 0x3d	; 61
    9f84:	be b7       	in	r27, 0x3e	; 62
    9f86:	12 96       	adiw	r26, 0x02	; 2
    9f88:	1c 93       	st	X, r17
    9f8a:	0e 93       	st	-X, r16
    9f8c:	11 97       	sbiw	r26, 0x01	; 1
    9f8e:	83 ed       	ldi	r24, 0xD3	; 211
    9f90:	90 e1       	ldi	r25, 0x10	; 16
    9f92:	93 83       	std	Z+3, r25	; 0x03
    9f94:	82 83       	std	Z+2, r24	; 0x02
    9f96:	e4 82       	std	Z+4, r14	; 0x04
    9f98:	15 82       	std	Z+5, r1	; 0x05
    9f9a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    9f9e:	8d b7       	in	r24, 0x3d	; 61
    9fa0:	9e b7       	in	r25, 0x3e	; 62
    9fa2:	06 96       	adiw	r24, 0x06	; 6
    9fa4:	0f b6       	in	r0, 0x3f	; 63
    9fa6:	f8 94       	cli
    9fa8:	9e bf       	out	0x3e, r25	; 62
    9faa:	0f be       	out	0x3f, r0	; 63
    9fac:	8d bf       	out	0x3d, r24	; 61
    9fae:	82 e0       	ldi	r24, 0x02	; 2
    9fb0:	61 e0       	ldi	r22, 0x01	; 1
    9fb2:	a8 01       	movw	r20, r16
    9fb4:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
    9fb8:	00 d0       	rcall	.+0      	; 0x9fba <FSettingDec+0x10c>
    9fba:	00 d0       	rcall	.+0      	; 0x9fbc <FSettingDec+0x10e>
    9fbc:	00 d0       	rcall	.+0      	; 0x9fbe <FSettingDec+0x110>
    9fbe:	ed b7       	in	r30, 0x3d	; 61
    9fc0:	fe b7       	in	r31, 0x3e	; 62
    9fc2:	31 96       	adiw	r30, 0x01	; 1
    9fc4:	ad b7       	in	r26, 0x3d	; 61
    9fc6:	be b7       	in	r27, 0x3e	; 62
    9fc8:	12 96       	adiw	r26, 0x02	; 2
    9fca:	1c 93       	st	X, r17
    9fcc:	0e 93       	st	-X, r16
    9fce:	11 97       	sbiw	r26, 0x01	; 1
    9fd0:	87 ec       	ldi	r24, 0xC7	; 199
    9fd2:	90 e1       	ldi	r25, 0x10	; 16
    9fd4:	93 83       	std	Z+3, r25	; 0x03
    9fd6:	82 83       	std	Z+2, r24	; 0x02
    9fd8:	f4 82       	std	Z+4, r15	; 0x04
    9fda:	15 82       	std	Z+5, r1	; 0x05
    9fdc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    9fe0:	8d b7       	in	r24, 0x3d	; 61
    9fe2:	9e b7       	in	r25, 0x3e	; 62
    9fe4:	06 96       	adiw	r24, 0x06	; 6
    9fe6:	0f b6       	in	r0, 0x3f	; 63
    9fe8:	f8 94       	cli
    9fea:	9e bf       	out	0x3e, r25	; 62
    9fec:	0f be       	out	0x3f, r0	; 63
    9fee:	8d bf       	out	0x3d, r24	; 61
    9ff0:	83 e0       	ldi	r24, 0x03	; 3
    9ff2:	61 e0       	ldi	r22, 0x01	; 1
    9ff4:	a8 01       	movw	r20, r16
    9ff6:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
    9ffa:	84 e0       	ldi	r24, 0x04	; 4
    9ffc:	61 e0       	ldi	r22, 0x01	; 1
    9ffe:	46 eb       	ldi	r20, 0xB6	; 182
    a000:	50 e1       	ldi	r21, 0x10	; 16
    a002:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
    a006:	81 e0       	ldi	r24, 0x01	; 1
    a008:	1f c1       	rjmp	.+574    	; 0xa248 <FSettingDec+0x39a>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
    a00a:	81 e0       	ldi	r24, 0x01	; 1
    a00c:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    a010:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
    a014:	98 2f       	mov	r25, r24
    a016:	91 53       	subi	r25, 0x31	; 49
    a018:	93 30       	cpi	r25, 0x03	; 3
    a01a:	e0 f4       	brcc	.+56     	; 0xa054 <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
    a01c:	29 2f       	mov	r18, r25
    a01e:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a020:	e1 99       	sbic	0x1c, 1	; 28
    a022:	fe cf       	rjmp	.-4      	; 0xa020 <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a024:	c9 01       	movw	r24, r18
    a026:	87 5c       	subi	r24, 0xC7	; 199
    a028:	9f 4f       	sbci	r25, 0xFF	; 255
    a02a:	9f bb       	out	0x1f, r25	; 31
    a02c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a02e:	e0 9a       	sbi	0x1c, 0	; 28
    a030:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a032:	e1 99       	sbic	0x1c, 1	; 28
    a034:	fe cf       	rjmp	.-4      	; 0xa032 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a036:	27 5c       	subi	r18, 0xC7	; 199
    a038:	3f 4f       	sbci	r19, 0xFF	; 255
    a03a:	3f bb       	out	0x1f, r19	; 31
    a03c:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
    a03e:	90 e0       	ldi	r25, 0x00	; 0
    a040:	01 96       	adiw	r24, 0x01	; 1
    a042:	83 70       	andi	r24, 0x03	; 3
    a044:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
    a046:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    a048:	0f b6       	in	r0, 0x3f	; 63
    a04a:	f8 94       	cli
    a04c:	e2 9a       	sbi	0x1c, 2	; 28
    a04e:	e1 9a       	sbi	0x1c, 1	; 28
    a050:	0f be       	out	0x3f, r0	; 63
    a052:	f6 c0       	rjmp	.+492    	; 0xa240 <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
    a054:	8a 32       	cpi	r24, 0x2A	; 42
    a056:	11 f4       	brne	.+4      	; 0xa05c <FSettingDec+0x1ae>
    a058:	85 e0       	ldi	r24, 0x05	; 5
    a05a:	f6 c0       	rjmp	.+492    	; 0xa248 <FSettingDec+0x39a>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
    a05c:	83 32       	cpi	r24, 0x23	; 35
    a05e:	09 f0       	breq	.+2      	; 0xa062 <FSettingDec+0x1b4>
    a060:	fa c0       	rjmp	.+500    	; 0xa256 <FSettingDec+0x3a8>
    a062:	f1 c0       	rjmp	.+482    	; 0xa246 <FSettingDec+0x398>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a064:	e1 99       	sbic	0x1c, 1	; 28
    a066:	fe cf       	rjmp	.-4      	; 0xa064 <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a068:	8c e3       	ldi	r24, 0x3C	; 60
    a06a:	90 e0       	ldi	r25, 0x00	; 0
    a06c:	9f bb       	out	0x1f, r25	; 31
    a06e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a070:	e0 9a       	sbi	0x1c, 0	; 28
    a072:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a074:	e1 99       	sbic	0x1c, 1	; 28
    a076:	fe cf       	rjmp	.-4      	; 0xa074 <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a078:	8d e3       	ldi	r24, 0x3D	; 61
    a07a:	90 e0       	ldi	r25, 0x00	; 0
    a07c:	9f bb       	out	0x1f, r25	; 31
    a07e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a080:	e0 9a       	sbi	0x1c, 0	; 28
    a082:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a084:	e1 99       	sbic	0x1c, 1	; 28
    a086:	fe cf       	rjmp	.-4      	; 0xa084 <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a088:	8e e3       	ldi	r24, 0x3E	; 62
    a08a:	90 e0       	ldi	r25, 0x00	; 0
    a08c:	9f bb       	out	0x1f, r25	; 31
    a08e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a090:	e0 9a       	sbi	0x1c, 0	; 28
    a092:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a094:	e1 99       	sbic	0x1c, 1	; 28
    a096:	fe cf       	rjmp	.-4      	; 0xa094 <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a098:	8f e3       	ldi	r24, 0x3F	; 63
    a09a:	90 e0       	ldi	r25, 0x00	; 0
    a09c:	9f bb       	out	0x1f, r25	; 31
    a09e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a0a0:	e0 9a       	sbi	0x1c, 0	; 28
    a0a2:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d "),PDecimalConfig[0]);
    a0a4:	00 d0       	rcall	.+0      	; 0xa0a6 <FSettingDec+0x1f8>
    a0a6:	00 d0       	rcall	.+0      	; 0xa0a8 <FSettingDec+0x1fa>
    a0a8:	00 d0       	rcall	.+0      	; 0xa0aa <FSettingDec+0x1fc>
    a0aa:	ed b7       	in	r30, 0x3d	; 61
    a0ac:	fe b7       	in	r31, 0x3e	; 62
    a0ae:	31 96       	adiw	r30, 0x01	; 1
    a0b0:	8e 01       	movw	r16, r28
    a0b2:	0f 5f       	subi	r16, 0xFF	; 255
    a0b4:	1f 4f       	sbci	r17, 0xFF	; 255
    a0b6:	ad b7       	in	r26, 0x3d	; 61
    a0b8:	be b7       	in	r27, 0x3e	; 62
    a0ba:	12 96       	adiw	r26, 0x02	; 2
    a0bc:	1c 93       	st	X, r17
    a0be:	0e 93       	st	-X, r16
    a0c0:	11 97       	sbiw	r26, 0x01	; 1
    a0c2:	87 ea       	ldi	r24, 0xA7	; 167
    a0c4:	90 e1       	ldi	r25, 0x10	; 16
    a0c6:	93 83       	std	Z+3, r25	; 0x03
    a0c8:	82 83       	std	Z+2, r24	; 0x02
    a0ca:	24 83       	std	Z+4, r18	; 0x04
    a0cc:	15 82       	std	Z+5, r1	; 0x05
    a0ce:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(1,1,lcdteks);
    a0d2:	8d b7       	in	r24, 0x3d	; 61
    a0d4:	9e b7       	in	r25, 0x3e	; 62
    a0d6:	06 96       	adiw	r24, 0x06	; 6
    a0d8:	0f b6       	in	r0, 0x3f	; 63
    a0da:	f8 94       	cli
    a0dc:	9e bf       	out	0x3e, r25	; 62
    a0de:	0f be       	out	0x3f, r0	; 63
    a0e0:	8d bf       	out	0x3d, r24	; 61
    a0e2:	81 e0       	ldi	r24, 0x01	; 1
    a0e4:	61 e0       	ldi	r22, 0x01	; 1
    a0e6:	a8 01       	movw	r20, r16
    a0e8:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
    a0ec:	00 d0       	rcall	.+0      	; 0xa0ee <FSettingDec+0x240>
    a0ee:	00 d0       	rcall	.+0      	; 0xa0f0 <FSettingDec+0x242>
    a0f0:	00 d0       	rcall	.+0      	; 0xa0f2 <FSettingDec+0x244>
    a0f2:	ed b7       	in	r30, 0x3d	; 61
    a0f4:	fe b7       	in	r31, 0x3e	; 62
    a0f6:	31 96       	adiw	r30, 0x01	; 1
    a0f8:	ad b7       	in	r26, 0x3d	; 61
    a0fa:	be b7       	in	r27, 0x3e	; 62
    a0fc:	12 96       	adiw	r26, 0x02	; 2
    a0fe:	1c 93       	st	X, r17
    a100:	0e 93       	st	-X, r16
    a102:	11 97       	sbiw	r26, 0x01	; 1
    a104:	88 e9       	ldi	r24, 0x98	; 152
    a106:	90 e1       	ldi	r25, 0x10	; 16
    a108:	93 83       	std	Z+3, r25	; 0x03
    a10a:	82 83       	std	Z+2, r24	; 0x02
    a10c:	e4 82       	std	Z+4, r14	; 0x04
    a10e:	15 82       	std	Z+5, r1	; 0x05
    a110:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    a114:	8d b7       	in	r24, 0x3d	; 61
    a116:	9e b7       	in	r25, 0x3e	; 62
    a118:	06 96       	adiw	r24, 0x06	; 6
    a11a:	0f b6       	in	r0, 0x3f	; 63
    a11c:	f8 94       	cli
    a11e:	9e bf       	out	0x3e, r25	; 62
    a120:	0f be       	out	0x3f, r0	; 63
    a122:	8d bf       	out	0x3d, r24	; 61
    a124:	82 e0       	ldi	r24, 0x02	; 2
    a126:	61 e0       	ldi	r22, 0x01	; 1
    a128:	a8 01       	movw	r20, r16
    a12a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
    a12e:	00 d0       	rcall	.+0      	; 0xa130 <FSettingDec+0x282>
    a130:	00 d0       	rcall	.+0      	; 0xa132 <FSettingDec+0x284>
    a132:	00 d0       	rcall	.+0      	; 0xa134 <FSettingDec+0x286>
    a134:	ed b7       	in	r30, 0x3d	; 61
    a136:	fe b7       	in	r31, 0x3e	; 62
    a138:	31 96       	adiw	r30, 0x01	; 1
    a13a:	ad b7       	in	r26, 0x3d	; 61
    a13c:	be b7       	in	r27, 0x3e	; 62
    a13e:	12 96       	adiw	r26, 0x02	; 2
    a140:	1c 93       	st	X, r17
    a142:	0e 93       	st	-X, r16
    a144:	11 97       	sbiw	r26, 0x01	; 1
    a146:	89 e8       	ldi	r24, 0x89	; 137
    a148:	90 e1       	ldi	r25, 0x10	; 16
    a14a:	93 83       	std	Z+3, r25	; 0x03
    a14c:	82 83       	std	Z+2, r24	; 0x02
    a14e:	d4 82       	std	Z+4, r13	; 0x04
    a150:	15 82       	std	Z+5, r1	; 0x05
    a152:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    a156:	8d b7       	in	r24, 0x3d	; 61
    a158:	9e b7       	in	r25, 0x3e	; 62
    a15a:	06 96       	adiw	r24, 0x06	; 6
    a15c:	0f b6       	in	r0, 0x3f	; 63
    a15e:	f8 94       	cli
    a160:	9e bf       	out	0x3e, r25	; 62
    a162:	0f be       	out	0x3f, r0	; 63
    a164:	8d bf       	out	0x3d, r24	; 61
    a166:	83 e0       	ldi	r24, 0x03	; 3
    a168:	61 e0       	ldi	r22, 0x01	; 1
    a16a:	a8 01       	movw	r20, r16
    a16c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
    a170:	00 d0       	rcall	.+0      	; 0xa172 <FSettingDec+0x2c4>
    a172:	00 d0       	rcall	.+0      	; 0xa174 <FSettingDec+0x2c6>
    a174:	00 d0       	rcall	.+0      	; 0xa176 <FSettingDec+0x2c8>
    a176:	ed b7       	in	r30, 0x3d	; 61
    a178:	fe b7       	in	r31, 0x3e	; 62
    a17a:	31 96       	adiw	r30, 0x01	; 1
    a17c:	ad b7       	in	r26, 0x3d	; 61
    a17e:	be b7       	in	r27, 0x3e	; 62
    a180:	12 96       	adiw	r26, 0x02	; 2
    a182:	1c 93       	st	X, r17
    a184:	0e 93       	st	-X, r16
    a186:	11 97       	sbiw	r26, 0x01	; 1
    a188:	8a e7       	ldi	r24, 0x7A	; 122
    a18a:	90 e1       	ldi	r25, 0x10	; 16
    a18c:	93 83       	std	Z+3, r25	; 0x03
    a18e:	82 83       	std	Z+2, r24	; 0x02
    a190:	f4 82       	std	Z+4, r15	; 0x04
    a192:	15 82       	std	Z+5, r1	; 0x05
    a194:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    a198:	8d b7       	in	r24, 0x3d	; 61
    a19a:	9e b7       	in	r25, 0x3e	; 62
    a19c:	06 96       	adiw	r24, 0x06	; 6
    a19e:	0f b6       	in	r0, 0x3f	; 63
    a1a0:	f8 94       	cli
    a1a2:	9e bf       	out	0x3e, r25	; 62
    a1a4:	0f be       	out	0x3f, r0	; 63
    a1a6:	8d bf       	out	0x3d, r24	; 61
    a1a8:	84 e0       	ldi	r24, 0x04	; 4
    a1aa:	61 e0       	ldi	r22, 0x01	; 1
    a1ac:	a8 01       	movw	r20, r16
    a1ae:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
    a1b2:	84 e0       	ldi	r24, 0x04	; 4
    a1b4:	6e e0       	ldi	r22, 0x0E	; 14
    a1b6:	43 e7       	ldi	r20, 0x73	; 115
    a1b8:	50 e1       	ldi	r21, 0x10	; 16
    a1ba:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
    a1be:	83 e0       	ldi	r24, 0x03	; 3
    a1c0:	43 c0       	rjmp	.+134    	; 0xa248 <FSettingDec+0x39a>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
    a1c2:	81 e0       	ldi	r24, 0x01	; 1
    a1c4:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    a1c8:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    a1cc:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    a1ce:	98 2f       	mov	r25, r24
    a1d0:	91 53       	subi	r25, 0x31	; 49
    a1d2:	92 30       	cpi	r25, 0x02	; 2
    a1d4:	b0 f4       	brcc	.+44     	; 0xa202 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
    a1d6:	29 2f       	mov	r18, r25
    a1d8:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a1da:	e1 99       	sbic	0x1c, 1	; 28
    a1dc:	fe cf       	rjmp	.-4      	; 0xa1da <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a1de:	c9 01       	movw	r24, r18
    a1e0:	84 5c       	subi	r24, 0xC4	; 196
    a1e2:	9f 4f       	sbci	r25, 0xFF	; 255
    a1e4:	9f bb       	out	0x1f, r25	; 31
    a1e6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a1e8:	e0 9a       	sbi	0x1c, 0	; 28
    a1ea:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a1ec:	e1 99       	sbic	0x1c, 1	; 28
    a1ee:	fe cf       	rjmp	.-4      	; 0xa1ec <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a1f0:	24 5c       	subi	r18, 0xC4	; 196
    a1f2:	3f 4f       	sbci	r19, 0xFF	; 255
    a1f4:	3f bb       	out	0x1f, r19	; 31
    a1f6:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
    a1f8:	90 e0       	ldi	r25, 0x00	; 0
    a1fa:	01 96       	adiw	r24, 0x01	; 1
    a1fc:	83 70       	andi	r24, 0x03	; 3
    a1fe:	90 70       	andi	r25, 0x00	; 0
    a200:	16 c0       	rjmp	.+44     	; 0xa22e <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
    a202:	83 53       	subi	r24, 0x33	; 51
    a204:	82 30       	cpi	r24, 0x02	; 2
    a206:	d0 f4       	brcc	.+52     	; 0xa23c <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
    a208:	09 2f       	mov	r16, r25
    a20a:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a20c:	e1 99       	sbic	0x1c, 1	; 28
    a20e:	fe cf       	rjmp	.-4      	; 0xa20c <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a210:	c8 01       	movw	r24, r16
    a212:	84 5c       	subi	r24, 0xC4	; 196
    a214:	9f 4f       	sbci	r25, 0xFF	; 255
    a216:	9f bb       	out	0x1f, r25	; 31
    a218:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a21a:	e0 9a       	sbi	0x1c, 0	; 28
    a21c:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
    a21e:	0e 94 8a 1d 	call	0x3b14	; 0x3b14 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a222:	e1 99       	sbic	0x1c, 1	; 28
    a224:	fe cf       	rjmp	.-4      	; 0xa222 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a226:	04 5c       	subi	r16, 0xC4	; 196
    a228:	1f 4f       	sbci	r17, 0xFF	; 255
    a22a:	1f bb       	out	0x1f, r17	; 31
    a22c:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    a22e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    a230:	0f b6       	in	r0, 0x3f	; 63
    a232:	f8 94       	cli
    a234:	e2 9a       	sbi	0x1c, 2	; 28
    a236:	e1 9a       	sbi	0x1c, 1	; 28
    a238:	0f be       	out	0x3f, r0	; 63
    a23a:	05 c0       	rjmp	.+10     	; 0xa246 <FSettingDec+0x398>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
    a23c:	2a 32       	cpi	r18, 0x2A	; 42
    a23e:	59 f4       	brne	.+22     	; 0xa256 <FSettingDec+0x3a8>
    a240:	10 92 1f 02 	sts	0x021F, r1
    a244:	08 c0       	rjmp	.+16     	; 0xa256 <FSettingDec+0x3a8>
		          stSettingDecimal=sdTestInput;
				  }*/
          break;
     case sdTestInput:
	      //if (TestUserInput()==MENU_DONE)
		  stSettingDecimal=sdInitDisplay2;
    a246:	82 e0       	ldi	r24, 0x02	; 2
    a248:	80 93 1f 02 	sts	0x021F, r24
    a24c:	04 c0       	rjmp	.+8      	; 0xa256 <FSettingDec+0x3a8>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
    a24e:	10 92 1f 02 	sts	0x021F, r1
    a252:	81 e0       	ldi	r24, 0x01	; 1
    a254:	01 c0       	rjmp	.+2      	; 0xa258 <FSettingDec+0x3aa>
    a256:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
    a258:	64 96       	adiw	r28, 0x14	; 20
    a25a:	0f b6       	in	r0, 0x3f	; 63
    a25c:	f8 94       	cli
    a25e:	de bf       	out	0x3e, r29	; 62
    a260:	0f be       	out	0x3f, r0	; 63
    a262:	cd bf       	out	0x3d, r28	; 61
    a264:	cf 91       	pop	r28
    a266:	df 91       	pop	r29
    a268:	1f 91       	pop	r17
    a26a:	0f 91       	pop	r16
    a26c:	ff 90       	pop	r15
    a26e:	ef 90       	pop	r14
    a270:	df 90       	pop	r13
    a272:	08 95       	ret

0000a274 <FMenuShift>:
static char stMenuShift=msInitMenuShift;
     char SubMenu,KeyChar,KeyPressed;
     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    a274:	80 91 4a 02 	lds	r24, 0x024A
    a278:	82 30       	cpi	r24, 0x02	; 2
    a27a:	09 f4       	brne	.+2      	; 0xa27e <FMenuShift+0xa>
    a27c:	48 c0       	rjmp	.+144    	; 0xa30e <FMenuShift+0x9a>
    a27e:	83 30       	cpi	r24, 0x03	; 3
    a280:	30 f4       	brcc	.+12     	; 0xa28e <FMenuShift+0x1a>
    a282:	88 23       	and	r24, r24
    a284:	69 f0       	breq	.+26     	; 0xa2a0 <FMenuShift+0x2c>
    a286:	81 30       	cpi	r24, 0x01	; 1
    a288:	09 f0       	breq	.+2      	; 0xa28c <FMenuShift+0x18>
    a28a:	50 c0       	rjmp	.+160    	; 0xa32c <FMenuShift+0xb8>
    a28c:	25 c0       	rjmp	.+74     	; 0xa2d8 <FMenuShift+0x64>
    a28e:	84 30       	cpi	r24, 0x04	; 4
    a290:	09 f4       	brne	.+2      	; 0xa294 <FMenuShift+0x20>
    a292:	4c c0       	rjmp	.+152    	; 0xa32c <FMenuShift+0xb8>
    a294:	84 30       	cpi	r24, 0x04	; 4
    a296:	e8 f1       	brcs	.+122    	; 0xa312 <FMenuShift+0x9e>
    a298:	85 30       	cpi	r24, 0x05	; 5
    a29a:	09 f0       	breq	.+2      	; 0xa29e <FMenuShift+0x2a>
    a29c:	47 c0       	rjmp	.+142    	; 0xa32c <FMenuShift+0xb8>
    a29e:	42 c0       	rjmp	.+132    	; 0xa324 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    a2a0:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    a2a4:	81 e0       	ldi	r24, 0x01	; 1
    a2a6:	61 e0       	ldi	r22, 0x01	; 1
    a2a8:	40 e5       	ldi	r20, 0x50	; 80
    a2aa:	55 e1       	ldi	r21, 0x15	; 21
    a2ac:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    a2b0:	82 e0       	ldi	r24, 0x02	; 2
    a2b2:	61 e0       	ldi	r22, 0x01	; 1
    a2b4:	42 e4       	ldi	r20, 0x42	; 66
    a2b6:	55 e1       	ldi	r21, 0x15	; 21
    a2b8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    a2bc:	83 e0       	ldi	r24, 0x03	; 3
    a2be:	61 e0       	ldi	r22, 0x01	; 1
    a2c0:	44 e3       	ldi	r20, 0x34	; 52
    a2c2:	55 e1       	ldi	r21, 0x15	; 21
    a2c4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    a2c8:	84 e0       	ldi	r24, 0x04	; 4
    a2ca:	61 e0       	ldi	r22, 0x01	; 1
    a2cc:	4d e2       	ldi	r20, 0x2D	; 45
    a2ce:	55 e1       	ldi	r21, 0x15	; 21
    a2d0:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stMenuShift=msSelectShift;
    a2d4:	81 e0       	ldi	r24, 0x01	; 1
    a2d6:	18 c0       	rjmp	.+48     	; 0xa308 <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    a2d8:	81 e0       	ldi	r24, 0x01	; 1
    a2da:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    a2de:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
          switch(KeyChar){
    a2e2:	82 33       	cpi	r24, 0x32	; 50
    a2e4:	61 f0       	breq	.+24     	; 0xa2fe <FMenuShift+0x8a>
    a2e6:	83 33       	cpi	r24, 0x33	; 51
    a2e8:	28 f4       	brcc	.+10     	; 0xa2f4 <FMenuShift+0x80>
    a2ea:	8a 32       	cpi	r24, 0x2A	; 42
    a2ec:	61 f0       	breq	.+24     	; 0xa306 <FMenuShift+0x92>
    a2ee:	81 33       	cpi	r24, 0x31	; 49
    a2f0:	e9 f4       	brne	.+58     	; 0xa32c <FMenuShift+0xb8>
    a2f2:	03 c0       	rjmp	.+6      	; 0xa2fa <FMenuShift+0x86>
    a2f4:	83 33       	cpi	r24, 0x33	; 51
    a2f6:	d1 f4       	brne	.+52     	; 0xa32c <FMenuShift+0xb8>
    a2f8:	04 c0       	rjmp	.+8      	; 0xa302 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    a2fa:	82 e0       	ldi	r24, 0x02	; 2
    a2fc:	05 c0       	rjmp	.+10     	; 0xa308 <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    a2fe:	83 e0       	ldi	r24, 0x03	; 3
    a300:	03 c0       	rjmp	.+6      	; 0xa308 <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    a302:	84 e0       	ldi	r24, 0x04	; 4
    a304:	01 c0       	rjmp	.+2      	; 0xa308 <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    a306:	85 e0       	ldi	r24, 0x05	; 5
    a308:	80 93 4a 02 	sts	0x024A, r24
    a30c:	09 c0       	rjmp	.+18     	; 0xa320 <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    a30e:	82 e0       	ldi	r24, 0x02	; 2
    a310:	01 c0       	rjmp	.+2      	; 0xa314 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    a312:	81 e0       	ldi	r24, 0x01	; 1
    a314:	0e 94 6b 47 	call	0x8ed6	; 0x8ed6 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    a318:	81 30       	cpi	r24, 0x01	; 1
    a31a:	41 f4       	brne	.+16     	; 0xa32c <FMenuShift+0xb8>
    a31c:	10 92 4a 02 	sts	0x024A, r1
    a320:	80 e0       	ldi	r24, 0x00	; 0
    a322:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    a324:	10 92 4a 02 	sts	0x024A, r1
    a328:	81 e0       	ldi	r24, 0x01	; 1
    a32a:	08 95       	ret
    a32c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    a32e:	08 95       	ret

0000a330 <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    a330:	84 e0       	ldi	r24, 0x04	; 4
    a332:	61 e0       	ldi	r22, 0x01	; 1
    a334:	47 ec       	ldi	r20, 0xC7	; 199
    a336:	50 e2       	ldi	r21, 0x20	; 32
    a338:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    a33c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    a33e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    a340:	85 e0       	ldi	r24, 0x05	; 5
    a342:	80 93 bc 01 	sts	0x01BC, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    a346:	81 e0       	ldi	r24, 0x01	; 1
    a348:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		__num = _key_btn(__key);
    a34c:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    a350:	80 53       	subi	r24, 0x30	; 48
    a352:	8a 30       	cpi	r24, 0x0A	; 10
    a354:	20 f0       	brcs	.+8      	; 0xa35e <system_stop+0x2e>
    a356:	80 91 9c 01 	lds	r24, 0x019C
    a35a:	81 30       	cpi	r24, 0x01	; 1
    a35c:	a1 f7       	brne	.-24     	; 0xa346 <system_stop+0x16>
    a35e:	08 95       	ret

0000a360 <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    a360:	84 e0       	ldi	r24, 0x04	; 4
    a362:	61 e0       	ldi	r22, 0x01	; 1
    a364:	4c ed       	ldi	r20, 0xDC	; 220
    a366:	50 e2       	ldi	r21, 0x20	; 32
    a368:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    a36c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    a36e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    a370:	81 e0       	ldi	r24, 0x01	; 1
    a372:	80 93 bc 01 	sts	0x01BC, r24
    a376:	80 e5       	ldi	r24, 0x50	; 80
    a378:	93 ec       	ldi	r25, 0xC3	; 195
    a37a:	01 97       	sbiw	r24, 0x01	; 1
    a37c:	f1 f7       	brne	.-4      	; 0xa37a <systemForceType+0x1a>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    a37e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    a380:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    a382:	82 e0       	ldi	r24, 0x02	; 2
    a384:	80 93 bc 01 	sts	0x01BC, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    a388:	81 e0       	ldi	r24, 0x01	; 1
    a38a:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    a38e:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    a392:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    a394:	81 53       	subi	r24, 0x31	; 49
    a396:	82 30       	cpi	r24, 0x02	; 2
    a398:	b8 f7       	brcc	.-18     	; 0xa388 <systemForceType+0x28>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    a39a:	89 2f       	mov	r24, r25
    a39c:	08 95       	ret

0000a39e <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    a39e:	8f 92       	push	r8
    a3a0:	9f 92       	push	r9
    a3a2:	af 92       	push	r10
    a3a4:	bf 92       	push	r11
    a3a6:	cf 92       	push	r12
    a3a8:	df 92       	push	r13
    a3aa:	ef 92       	push	r14
    a3ac:	ff 92       	push	r15
    a3ae:	0f 93       	push	r16
    a3b0:	1f 93       	push	r17
    a3b2:	df 93       	push	r29
    a3b4:	cf 93       	push	r28
    a3b6:	cd b7       	in	r28, 0x3d	; 61
    a3b8:	de b7       	in	r29, 0x3e	; 62
    a3ba:	c2 54       	subi	r28, 0x42	; 66
    a3bc:	d0 40       	sbci	r29, 0x00	; 0
    a3be:	0f b6       	in	r0, 0x3f	; 63
    a3c0:	f8 94       	cli
    a3c2:	de bf       	out	0x3e, r29	; 62
    a3c4:	0f be       	out	0x3f, r0	; 63
    a3c6:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    a3c8:	de 01       	movw	r26, r28
    a3ca:	53 96       	adiw	r26, 0x13	; 19
    a3cc:	e6 e2       	ldi	r30, 0x26	; 38
    a3ce:	f1 e0       	ldi	r31, 0x01	; 1
    a3d0:	80 e3       	ldi	r24, 0x30	; 48
    a3d2:	01 90       	ld	r0, Z+
    a3d4:	0d 92       	st	X+, r0
    a3d6:	81 50       	subi	r24, 0x01	; 1
    a3d8:	e1 f7       	brne	.-8      	; 0xa3d2 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    a3da:	8e 01       	movw	r16, r28
    a3dc:	0f 5f       	subi	r16, 0xFF	; 255
    a3de:	1f 4f       	sbci	r17, 0xFF	; 255
    a3e0:	b8 01       	movw	r22, r16
    a3e2:	ae 01       	movw	r20, r28
    a3e4:	46 5f       	subi	r20, 0xF6	; 246
    a3e6:	5f 4f       	sbci	r21, 0xFF	; 255
    a3e8:	0e 94 4a a7 	call	0x14e94	; 0x14e94 <_datetime>
    a3ec:	85 e1       	ldi	r24, 0x15	; 21
    a3ee:	88 2e       	mov	r8, r24
    a3f0:	91 2c       	mov	r9, r1
    a3f2:	8c 0e       	add	r8, r28
    a3f4:	9d 1e       	adc	r9, r29
    a3f6:	d4 01       	movw	r26, r8
    a3f8:	20 e0       	ldi	r18, 0x00	; 0
    a3fa:	30 e0       	ldi	r19, 0x00	; 0
    a3fc:	40 e0       	ldi	r20, 0x00	; 0
    a3fe:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    a400:	22 30       	cpi	r18, 0x02	; 2
    a402:	31 05       	cpc	r19, r1
    a404:	19 f0       	breq	.+6      	; 0xa40c <_menu_datetime+0x6e>
    a406:	24 30       	cpi	r18, 0x04	; 4
    a408:	31 05       	cpc	r19, r1
    a40a:	11 f4       	brne	.+4      	; 0xa410 <_menu_datetime+0x72>
			__ii++;
    a40c:	4f 5f       	subi	r20, 0xFF	; 255
    a40e:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    a410:	f8 01       	movw	r30, r16
    a412:	e4 0f       	add	r30, r20
    a414:	f5 1f       	adc	r31, r21
    a416:	80 81       	ld	r24, Z
    a418:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    a41a:	2f 5f       	subi	r18, 0xFF	; 255
    a41c:	3f 4f       	sbci	r19, 0xFF	; 255
    a41e:	14 96       	adiw	r26, 0x04	; 4
    a420:	26 30       	cpi	r18, 0x06	; 6
    a422:	31 05       	cpc	r19, r1
    a424:	19 f0       	breq	.+6      	; 0xa42c <_menu_datetime+0x8e>
    a426:	4f 5f       	subi	r20, 0xFF	; 255
    a428:	5f 4f       	sbci	r21, 0xFF	; 255
    a42a:	ea cf       	rjmp	.-44     	; 0xa400 <_menu_datetime+0x62>
    a42c:	0d e2       	ldi	r16, 0x2D	; 45
    a42e:	a0 2e       	mov	r10, r16
    a430:	b1 2c       	mov	r11, r1
    a432:	ac 0e       	add	r10, r28
    a434:	bd 1e       	adc	r11, r29
    a436:	d5 01       	movw	r26, r10
    a438:	40 e0       	ldi	r20, 0x00	; 0
    a43a:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    a43c:	1a e0       	ldi	r17, 0x0A	; 10
    a43e:	e1 2e       	mov	r14, r17
    a440:	f1 2c       	mov	r15, r1
    a442:	ec 0e       	add	r14, r28
    a444:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    a446:	28 30       	cpi	r18, 0x08	; 8
    a448:	31 05       	cpc	r19, r1
    a44a:	19 f0       	breq	.+6      	; 0xa452 <_menu_datetime+0xb4>
    a44c:	2a 30       	cpi	r18, 0x0A	; 10
    a44e:	31 05       	cpc	r19, r1
    a450:	11 f4       	brne	.+4      	; 0xa456 <_menu_datetime+0xb8>
			__ii++;
    a452:	4f 5f       	subi	r20, 0xFF	; 255
    a454:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    a456:	f7 01       	movw	r30, r14
    a458:	e4 0f       	add	r30, r20
    a45a:	f5 1f       	adc	r31, r21
    a45c:	80 81       	ld	r24, Z
    a45e:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    a460:	2f 5f       	subi	r18, 0xFF	; 255
    a462:	3f 4f       	sbci	r19, 0xFF	; 255
    a464:	14 96       	adiw	r26, 0x04	; 4
    a466:	2c 30       	cpi	r18, 0x0C	; 12
    a468:	31 05       	cpc	r19, r1
    a46a:	19 f0       	breq	.+6      	; 0xa472 <_menu_datetime+0xd4>
    a46c:	4f 5f       	subi	r20, 0xFF	; 255
    a46e:	5f 4f       	sbci	r21, 0xFF	; 255
    a470:	ea cf       	rjmp	.-44     	; 0xa446 <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    a472:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    a476:	84 ec       	ldi	r24, 0xC4	; 196
    a478:	99 e0       	ldi	r25, 0x09	; 9
    a47a:	01 97       	sbiw	r24, 0x01	; 1
    a47c:	f1 f7       	brne	.-4      	; 0xa47a <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    a47e:	81 e0       	ldi	r24, 0x01	; 1
    a480:	61 e0       	ldi	r22, 0x01	; 1
    a482:	44 e2       	ldi	r20, 0x24	; 36
    a484:	5b e0       	ldi	r21, 0x0B	; 11
    a486:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    a48a:	82 e0       	ldi	r24, 0x02	; 2
    a48c:	61 e0       	ldi	r22, 0x01	; 1
    a48e:	4c e1       	ldi	r20, 0x1C	; 28
    a490:	5b e0       	ldi	r21, 0x0B	; 11
    a492:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	lcd_print(1, 8, __date);
    a496:	81 e0       	ldi	r24, 0x01	; 1
    a498:	68 e0       	ldi	r22, 0x08	; 8
    a49a:	8e 01       	movw	r16, r28
    a49c:	0f 5f       	subi	r16, 0xFF	; 255
    a49e:	1f 4f       	sbci	r17, 0xFF	; 255
    a4a0:	a8 01       	movw	r20, r16
    a4a2:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	lcd_print(2, 8, __time);
    a4a6:	82 e0       	ldi	r24, 0x02	; 2
    a4a8:	68 e0       	ldi	r22, 0x08	; 8
    a4aa:	a7 01       	movw	r20, r14
    a4ac:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    a4b0:	84 e0       	ldi	r24, 0x04	; 4
    a4b2:	61 e0       	ldi	r22, 0x01	; 1
    a4b4:	47 e0       	ldi	r20, 0x07	; 7
    a4b6:	5b e0       	ldi	r21, 0x0B	; 11
    a4b8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    a4bc:	8b 89       	ldd	r24, Y+19	; 0x13
    a4be:	6c 89       	ldd	r22, Y+20	; 0x14
    a4c0:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
	CURSOR_SHOW;
    a4c4:	8f e0       	ldi	r24, 0x0F	; 15
    a4c6:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
    a4ca:	ee 24       	eor	r14, r14
    a4cc:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    a4ce:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    a4d0:	81 e0       	ldi	r24, 0x01	; 1
    a4d2:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    a4d6:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    a4d8:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    a4dc:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    a4de:	80 53       	subi	r24, 0x30	; 48
    a4e0:	8a 30       	cpi	r24, 0x0A	; 10
    a4e2:	08 f0       	brcs	.+2      	; 0xa4e6 <_menu_datetime+0x148>
    a4e4:	72 c0       	rjmp	.+228    	; 0xa5ca <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    a4e6:	e1 14       	cp	r14, r1
    a4e8:	f1 04       	cpc	r15, r1
    a4ea:	81 f0       	breq	.+32     	; 0xa50c <_menu_datetime+0x16e>
    a4ec:	82 e0       	ldi	r24, 0x02	; 2
    a4ee:	e8 16       	cp	r14, r24
    a4f0:	f1 04       	cpc	r15, r1
    a4f2:	61 f0       	breq	.+24     	; 0xa50c <_menu_datetime+0x16e>
    a4f4:	96 e0       	ldi	r25, 0x06	; 6
    a4f6:	e9 16       	cp	r14, r25
    a4f8:	f1 04       	cpc	r15, r1
    a4fa:	41 f0       	breq	.+16     	; 0xa50c <_menu_datetime+0x16e>
    a4fc:	a8 e0       	ldi	r26, 0x08	; 8
    a4fe:	ea 16       	cp	r14, r26
    a500:	f1 04       	cpc	r15, r1
    a502:	21 f0       	breq	.+8      	; 0xa50c <_menu_datetime+0x16e>
    a504:	ba e0       	ldi	r27, 0x0A	; 10
    a506:	eb 16       	cp	r14, r27
    a508:	f1 04       	cpc	r15, r1
    a50a:	81 f4       	brne	.+32     	; 0xa52c <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    a50c:	84 2f       	mov	r24, r20
    a50e:	90 e0       	ldi	r25, 0x00	; 0
    a510:	c0 97       	sbiw	r24, 0x30	; 48
    a512:	f7 01       	movw	r30, r14
    a514:	ee 0f       	add	r30, r30
    a516:	ff 1f       	adc	r31, r31
    a518:	ee 0f       	add	r30, r30
    a51a:	ff 1f       	adc	r31, r31
    a51c:	ec 0d       	add	r30, r12
    a51e:	fd 1d       	adc	r31, r13
    a520:	25 89       	ldd	r18, Z+21	; 0x15
    a522:	30 e0       	ldi	r19, 0x00	; 0
    a524:	28 17       	cp	r18, r24
    a526:	39 07       	cpc	r19, r25
    a528:	84 f5       	brge	.+96     	; 0xa58a <_menu_datetime+0x1ec>
    a52a:	4f c0       	rjmp	.+158    	; 0xa5ca <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    a52c:	81 e0       	ldi	r24, 0x01	; 1
    a52e:	e8 16       	cp	r14, r24
    a530:	f1 04       	cpc	r15, r1
    a532:	61 f4       	brne	.+24     	; 0xa54c <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    a534:	2d 89       	ldd	r18, Y+21	; 0x15
    a536:	30 e0       	ldi	r19, 0x00	; 0
    a538:	2f 52       	subi	r18, 0x2F	; 47
    a53a:	30 40       	sbci	r19, 0x00	; 0
    a53c:	8e 89       	ldd	r24, Y+22	; 0x16
    a53e:	90 e0       	ldi	r25, 0x00	; 0
    a540:	82 17       	cp	r24, r18
    a542:	93 07       	cpc	r25, r19
    a544:	14 f5       	brge	.+68     	; 0xa58a <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    a546:	42 33       	cpi	r20, 0x32	; 50
    a548:	00 f1       	brcs	.+64     	; 0xa58a <_menu_datetime+0x1ec>
    a54a:	3f c0       	rjmp	.+126    	; 0xa5ca <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    a54c:	93 e0       	ldi	r25, 0x03	; 3
    a54e:	e9 16       	cp	r14, r25
    a550:	f1 04       	cpc	r15, r1
    a552:	61 f4       	brne	.+24     	; 0xa56c <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    a554:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a556:	30 e0       	ldi	r19, 0x00	; 0
    a558:	2f 52       	subi	r18, 0x2F	; 47
    a55a:	30 40       	sbci	r19, 0x00	; 0
    a55c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    a55e:	90 e0       	ldi	r25, 0x00	; 0
    a560:	82 17       	cp	r24, r18
    a562:	93 07       	cpc	r25, r19
    a564:	94 f4       	brge	.+36     	; 0xa58a <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    a566:	43 33       	cpi	r20, 0x33	; 51
    a568:	80 f0       	brcs	.+32     	; 0xa58a <_menu_datetime+0x1ec>
    a56a:	2f c0       	rjmp	.+94     	; 0xa5ca <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    a56c:	a7 e0       	ldi	r26, 0x07	; 7
    a56e:	ea 16       	cp	r14, r26
    a570:	f1 04       	cpc	r15, r1
    a572:	59 f4       	brne	.+22     	; 0xa58a <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    a574:	2d a5       	ldd	r18, Y+45	; 0x2d
    a576:	30 e0       	ldi	r19, 0x00	; 0
    a578:	2f 52       	subi	r18, 0x2F	; 47
    a57a:	30 40       	sbci	r19, 0x00	; 0
    a57c:	8e a5       	ldd	r24, Y+46	; 0x2e
    a57e:	90 e0       	ldi	r25, 0x00	; 0
    a580:	82 17       	cp	r24, r18
    a582:	93 07       	cpc	r25, r19
    a584:	14 f4       	brge	.+4      	; 0xa58a <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    a586:	44 33       	cpi	r20, 0x34	; 52
    a588:	00 f5       	brcc	.+64     	; 0xa5ca <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    a58a:	f7 01       	movw	r30, r14
    a58c:	ee 0f       	add	r30, r30
    a58e:	ff 1f       	adc	r31, r31
    a590:	ee 0f       	add	r30, r30
    a592:	ff 1f       	adc	r31, r31
    a594:	ec 0d       	add	r30, r12
    a596:	fd 1d       	adc	r31, r13
    a598:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    a59a:	84 2f       	mov	r24, r20
    a59c:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
			__i++;
    a5a0:	08 94       	sec
    a5a2:	e1 1c       	adc	r14, r1
    a5a4:	f1 1c       	adc	r15, r1
    a5a6:	bc e0       	ldi	r27, 0x0C	; 12
    a5a8:	eb 16       	cp	r14, r27
    a5aa:	f1 04       	cpc	r15, r1
    a5ac:	1c f0       	brlt	.+6      	; 0xa5b4 <_menu_datetime+0x216>
    a5ae:	7b e0       	ldi	r23, 0x0B	; 11
    a5b0:	e7 2e       	mov	r14, r23
    a5b2:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    a5b4:	f7 01       	movw	r30, r14
    a5b6:	ee 0f       	add	r30, r30
    a5b8:	ff 1f       	adc	r31, r31
    a5ba:	ee 0f       	add	r30, r30
    a5bc:	ff 1f       	adc	r31, r31
    a5be:	ec 0d       	add	r30, r12
    a5c0:	fd 1d       	adc	r31, r13
    a5c2:	82 89       	ldd	r24, Z+18	; 0x12
    a5c4:	63 89       	ldd	r22, Z+19	; 0x13
    a5c6:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    a5ca:	1b 37       	cpi	r17, 0x7B	; 123
    a5cc:	59 f4       	brne	.+22     	; 0xa5e4 <_menu_datetime+0x246>
			__i++;
    a5ce:	08 94       	sec
    a5d0:	e1 1c       	adc	r14, r1
    a5d2:	f1 1c       	adc	r15, r1
    a5d4:	8c e0       	ldi	r24, 0x0C	; 12
    a5d6:	e8 16       	cp	r14, r24
    a5d8:	f1 04       	cpc	r15, r1
    a5da:	6c f0       	brlt	.+26     	; 0xa5f6 <_menu_datetime+0x258>
    a5dc:	5b e0       	ldi	r21, 0x0B	; 11
    a5de:	e5 2e       	mov	r14, r21
    a5e0:	f1 2c       	mov	r15, r1
    a5e2:	09 c0       	rjmp	.+18     	; 0xa5f6 <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    a5e4:	17 37       	cpi	r17, 0x77	; 119
    a5e6:	99 f4       	brne	.+38     	; 0xa60e <_menu_datetime+0x270>
			__i--;
    a5e8:	08 94       	sec
    a5ea:	e1 08       	sbc	r14, r1
    a5ec:	f1 08       	sbc	r15, r1
    a5ee:	f7 fe       	sbrs	r15, 7
    a5f0:	02 c0       	rjmp	.+4      	; 0xa5f6 <_menu_datetime+0x258>
    a5f2:	ee 24       	eor	r14, r14
    a5f4:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    a5f6:	f7 01       	movw	r30, r14
    a5f8:	ee 0f       	add	r30, r30
    a5fa:	ff 1f       	adc	r31, r31
    a5fc:	ee 0f       	add	r30, r30
    a5fe:	ff 1f       	adc	r31, r31
    a600:	ec 0d       	add	r30, r12
    a602:	fd 1d       	adc	r31, r13
    a604:	82 89       	ldd	r24, Z+18	; 0x12
    a606:	63 89       	ldd	r22, Z+19	; 0x13
    a608:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
    a60c:	61 cf       	rjmp	.-318    	; 0xa4d0 <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    a60e:	17 3e       	cpi	r17, 0xE7	; 231
    a610:	09 f4       	brne	.+2      	; 0xa614 <_menu_datetime+0x276>
    a612:	49 c0       	rjmp	.+146    	; 0xa6a6 <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    a614:	17 3b       	cpi	r17, 0xB7	; 183
    a616:	09 f0       	breq	.+2      	; 0xa61a <_menu_datetime+0x27c>
    a618:	5b cf       	rjmp	.-330    	; 0xa4d0 <_menu_datetime+0x132>
    a61a:	20 e0       	ldi	r18, 0x00	; 0
    a61c:	30 e0       	ldi	r19, 0x00	; 0
    a61e:	40 e0       	ldi	r20, 0x00	; 0
    a620:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    a622:	be 01       	movw	r22, r28
    a624:	6f 5f       	subi	r22, 0xFF	; 255
    a626:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    a628:	22 30       	cpi	r18, 0x02	; 2
    a62a:	31 05       	cpc	r19, r1
    a62c:	19 f0       	breq	.+6      	; 0xa634 <_menu_datetime+0x296>
    a62e:	24 30       	cpi	r18, 0x04	; 4
    a630:	31 05       	cpc	r19, r1
    a632:	11 f4       	brne	.+4      	; 0xa638 <_menu_datetime+0x29a>
					__ii++;
    a634:	4f 5f       	subi	r20, 0xFF	; 255
    a636:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    a638:	fb 01       	movw	r30, r22
    a63a:	e4 0f       	add	r30, r20
    a63c:	f5 1f       	adc	r31, r21
    a63e:	d4 01       	movw	r26, r8
    a640:	8c 91       	ld	r24, X
    a642:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    a644:	2f 5f       	subi	r18, 0xFF	; 255
    a646:	3f 4f       	sbci	r19, 0xFF	; 255
    a648:	84 e0       	ldi	r24, 0x04	; 4
    a64a:	90 e0       	ldi	r25, 0x00	; 0
    a64c:	88 0e       	add	r8, r24
    a64e:	99 1e       	adc	r9, r25
    a650:	26 30       	cpi	r18, 0x06	; 6
    a652:	31 05       	cpc	r19, r1
    a654:	19 f0       	breq	.+6      	; 0xa65c <_menu_datetime+0x2be>
    a656:	4f 5f       	subi	r20, 0xFF	; 255
    a658:	5f 4f       	sbci	r21, 0xFF	; 255
    a65a:	e6 cf       	rjmp	.-52     	; 0xa628 <_menu_datetime+0x28a>
    a65c:	60 e0       	ldi	r22, 0x00	; 0
    a65e:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    a660:	ae 01       	movw	r20, r28
    a662:	46 5f       	subi	r20, 0xF6	; 246
    a664:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    a666:	28 30       	cpi	r18, 0x08	; 8
    a668:	31 05       	cpc	r19, r1
    a66a:	19 f0       	breq	.+6      	; 0xa672 <_menu_datetime+0x2d4>
    a66c:	2a 30       	cpi	r18, 0x0A	; 10
    a66e:	31 05       	cpc	r19, r1
    a670:	11 f4       	brne	.+4      	; 0xa676 <_menu_datetime+0x2d8>
					__ii++;
    a672:	6f 5f       	subi	r22, 0xFF	; 255
    a674:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    a676:	fa 01       	movw	r30, r20
    a678:	e6 0f       	add	r30, r22
    a67a:	f7 1f       	adc	r31, r23
    a67c:	d5 01       	movw	r26, r10
    a67e:	8c 91       	ld	r24, X
    a680:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    a682:	2f 5f       	subi	r18, 0xFF	; 255
    a684:	3f 4f       	sbci	r19, 0xFF	; 255
    a686:	84 e0       	ldi	r24, 0x04	; 4
    a688:	90 e0       	ldi	r25, 0x00	; 0
    a68a:	a8 0e       	add	r10, r24
    a68c:	b9 1e       	adc	r11, r25
    a68e:	2c 30       	cpi	r18, 0x0C	; 12
    a690:	31 05       	cpc	r19, r1
    a692:	19 f0       	breq	.+6      	; 0xa69a <_menu_datetime+0x2fc>
    a694:	6f 5f       	subi	r22, 0xFF	; 255
    a696:	7f 4f       	sbci	r23, 0xFF	; 255
    a698:	e6 cf       	rjmp	.-52     	; 0xa666 <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    a69a:	81 e0       	ldi	r24, 0x01	; 1
    a69c:	be 01       	movw	r22, r28
    a69e:	6f 5f       	subi	r22, 0xFF	; 255
    a6a0:	7f 4f       	sbci	r23, 0xFF	; 255
    a6a2:	0e 94 4a a7 	call	0x14e94	; 0x14e94 <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    a6a6:	8c e0       	ldi	r24, 0x0C	; 12
    a6a8:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
}
    a6ac:	ce 5b       	subi	r28, 0xBE	; 190
    a6ae:	df 4f       	sbci	r29, 0xFF	; 255
    a6b0:	0f b6       	in	r0, 0x3f	; 63
    a6b2:	f8 94       	cli
    a6b4:	de bf       	out	0x3e, r29	; 62
    a6b6:	0f be       	out	0x3f, r0	; 63
    a6b8:	cd bf       	out	0x3d, r28	; 61
    a6ba:	cf 91       	pop	r28
    a6bc:	df 91       	pop	r29
    a6be:	1f 91       	pop	r17
    a6c0:	0f 91       	pop	r16
    a6c2:	ff 90       	pop	r15
    a6c4:	ef 90       	pop	r14
    a6c6:	df 90       	pop	r13
    a6c8:	cf 90       	pop	r12
    a6ca:	bf 90       	pop	r11
    a6cc:	af 90       	pop	r10
    a6ce:	9f 90       	pop	r9
    a6d0:	8f 90       	pop	r8
    a6d2:	08 95       	ret

0000a6d4 <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    a6d4:	0e 94 cf 51 	call	0xa39e	; 0xa39e <_menu_datetime>
     return MENU_DONE;
}
    a6d8:	81 e0       	ldi	r24, 0x01	; 1
    a6da:	08 95       	ret

0000a6dc <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    a6dc:	4f 92       	push	r4
    a6de:	5f 92       	push	r5
    a6e0:	6f 92       	push	r6
    a6e2:	7f 92       	push	r7
    a6e4:	8f 92       	push	r8
    a6e6:	9f 92       	push	r9
    a6e8:	af 92       	push	r10
    a6ea:	bf 92       	push	r11
    a6ec:	cf 92       	push	r12
    a6ee:	df 92       	push	r13
    a6f0:	ef 92       	push	r14
    a6f2:	ff 92       	push	r15
    a6f4:	0f 93       	push	r16
    a6f6:	1f 93       	push	r17
    a6f8:	df 93       	push	r29
    a6fa:	cf 93       	push	r28
    a6fc:	cd b7       	in	r28, 0x3d	; 61
    a6fe:	de b7       	in	r29, 0x3e	; 62
    a700:	a2 97       	sbiw	r28, 0x22	; 34
    a702:	0f b6       	in	r0, 0x3f	; 63
    a704:	f8 94       	cli
    a706:	de bf       	out	0x3e, r29	; 62
    a708:	0f be       	out	0x3f, r0	; 63
    a70a:	cd bf       	out	0x3d, r28	; 61
    a70c:	7c 01       	movw	r14, r24
    a70e:	6b 01       	movw	r12, r22

       char KeyPressed=0,KeyChar;
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];

       switch(stEnterFIP){
    a710:	80 91 6c 02 	lds	r24, 0x026C
    a714:	81 30       	cpi	r24, 0x01	; 1
    a716:	09 f4       	brne	.+2      	; 0xa71a <menu_FIP+0x3e>
    a718:	cf c0       	rjmp	.+414    	; 0xa8b8 <menu_FIP+0x1dc>
    a71a:	81 30       	cpi	r24, 0x01	; 1
    a71c:	20 f0       	brcs	.+8      	; 0xa726 <menu_FIP+0x4a>
    a71e:	82 30       	cpi	r24, 0x02	; 2
    a720:	09 f0       	breq	.+2      	; 0xa724 <menu_FIP+0x48>
    a722:	4c c1       	rjmp	.+664    	; 0xa9bc <menu_FIP+0x2e0>
    a724:	49 c1       	rjmp	.+658    	; 0xa9b8 <menu_FIP+0x2dc>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    a726:	8e 01       	movw	r16, r28
    a728:	09 5f       	subi	r16, 0xF9	; 249
    a72a:	1f 4f       	sbci	r17, 0xFF	; 255
    a72c:	c8 01       	movw	r24, r16
    a72e:	65 e4       	ldi	r22, 0x45	; 69
    a730:	70 e0       	ldi	r23, 0x00	; 0
    a732:	48 e0       	ldi	r20, 0x08	; 8
    a734:	50 e0       	ldi	r21, 0x00	; 0
    a736:	24 e4       	ldi	r18, 0x44	; 68
    a738:	32 e1       	ldi	r19, 0x12	; 18
    a73a:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    a73e:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    a742:	f8 01       	movw	r30, r16
    a744:	20 e0       	ldi	r18, 0x00	; 0
    a746:	30 e0       	ldi	r19, 0x00	; 0
    a748:	07 c0       	rjmp	.+14     	; 0xa758 <menu_FIP+0x7c>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    a74a:	80 81       	ld	r24, Z
    a74c:	84 36       	cpi	r24, 0x64	; 100
    a74e:	08 f0       	brcs	.+2      	; 0xa752 <menu_FIP+0x76>
    a750:	10 82       	st	Z, r1
    a752:	2f 5f       	subi	r18, 0xFF	; 255
    a754:	3f 4f       	sbci	r19, 0xFF	; 255
    a756:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    a758:	28 30       	cpi	r18, 0x08	; 8
    a75a:	31 05       	cpc	r19, r1
    a75c:	b0 f3       	brcs	.-20     	; 0xa74a <menu_FIP+0x6e>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    a75e:	10 92 6a 02 	sts	0x026A, r1
    a762:	10 92 69 02 	sts	0x0269, r1
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    a766:	5e 01       	movw	r10, r28
    a768:	08 94       	sec
    a76a:	a1 1c       	adc	r10, r1
    a76c:	b1 1c       	adc	r11, r1
    a76e:	54 ed       	ldi	r21, 0xD4	; 212
    a770:	c5 2e       	mov	r12, r21
    a772:	5c e0       	ldi	r21, 0x0C	; 12
    a774:	d5 2e       	mov	r13, r21
    a776:	47 e0       	ldi	r20, 0x07	; 7
    a778:	44 2e       	mov	r4, r20
    a77a:	51 2c       	mov	r5, r1
    a77c:	4c 0e       	add	r4, r28
    a77e:	5d 1e       	adc	r5, r29
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    a780:	34 e0       	ldi	r19, 0x04	; 4
    a782:	e3 2e       	mov	r14, r19
    a784:	f1 2c       	mov	r15, r1
    a786:	ec 0e       	add	r14, r28
    a788:	fd 1e       	adc	r15, r29
    a78a:	2b e0       	ldi	r18, 0x0B	; 11
    a78c:	62 2e       	mov	r6, r18
    a78e:	71 2c       	mov	r7, r1
    a790:	6c 0e       	add	r6, r28
    a792:	7d 1e       	adc	r7, r29
    a794:	8e 01       	movw	r16, r28
    a796:	01 5f       	subi	r16, 0xF1	; 241
    a798:	1f 4f       	sbci	r17, 0xFF	; 255
    a79a:	96 e2       	ldi	r25, 0x26	; 38
    a79c:	89 2e       	mov	r8, r25
    a79e:	9b e1       	ldi	r25, 0x1B	; 27
    a7a0:	99 2e       	mov	r9, r25
    a7a2:	64 c0       	rjmp	.+200    	; 0xa86c <menu_FIP+0x190>
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    a7a4:	00 d0       	rcall	.+0      	; 0xa7a6 <menu_FIP+0xca>
    a7a6:	00 d0       	rcall	.+0      	; 0xa7a8 <menu_FIP+0xcc>
    a7a8:	00 d0       	rcall	.+0      	; 0xa7aa <menu_FIP+0xce>
    a7aa:	2d b7       	in	r18, 0x3d	; 61
    a7ac:	3e b7       	in	r19, 0x3e	; 62
    a7ae:	2f 5f       	subi	r18, 0xFF	; 255
    a7b0:	3f 4f       	sbci	r19, 0xFF	; 255
    a7b2:	ed b7       	in	r30, 0x3d	; 61
    a7b4:	fe b7       	in	r31, 0x3e	; 62
    a7b6:	b2 82       	std	Z+2, r11	; 0x02
    a7b8:	a1 82       	std	Z+1, r10	; 0x01
    a7ba:	f9 01       	movw	r30, r18
    a7bc:	d3 82       	std	Z+3, r13	; 0x03
    a7be:	c2 82       	std	Z+2, r12	; 0x02
    a7c0:	a4 0d       	add	r26, r4
    a7c2:	b5 1d       	adc	r27, r5
    a7c4:	8c 91       	ld	r24, X
    a7c6:	84 83       	std	Z+4, r24	; 0x04
    a7c8:	15 82       	std	Z+5, r1	; 0x05
    a7ca:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    a7ce:	ad b7       	in	r26, 0x3d	; 61
    a7d0:	be b7       	in	r27, 0x3e	; 62
    a7d2:	11 96       	adiw	r26, 0x01	; 1
    a7d4:	ed b7       	in	r30, 0x3d	; 61
    a7d6:	fe b7       	in	r31, 0x3e	; 62
    a7d8:	f2 82       	std	Z+2, r15	; 0x02
    a7da:	e1 82       	std	Z+1, r14	; 0x01
    a7dc:	13 96       	adiw	r26, 0x03	; 3
    a7de:	dc 92       	st	X, r13
    a7e0:	ce 92       	st	-X, r12
    a7e2:	12 97       	sbiw	r26, 0x02	; 2
    a7e4:	e0 91 69 02 	lds	r30, 0x0269
    a7e8:	f0 91 6a 02 	lds	r31, 0x026A
    a7ec:	e6 0d       	add	r30, r6
    a7ee:	f7 1d       	adc	r31, r7
    a7f0:	80 81       	ld	r24, Z
    a7f2:	14 96       	adiw	r26, 0x04	; 4
    a7f4:	8c 93       	st	X, r24
    a7f6:	14 97       	sbiw	r26, 0x04	; 4
    a7f8:	15 96       	adiw	r26, 0x05	; 5
    a7fa:	1c 92       	st	X, r1
    a7fc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    a800:	80 91 69 02 	lds	r24, 0x0269
    a804:	90 91 6a 02 	lds	r25, 0x026A
    a808:	00 d0       	rcall	.+0      	; 0xa80a <menu_FIP+0x12e>
    a80a:	00 d0       	rcall	.+0      	; 0xa80c <menu_FIP+0x130>
    a80c:	00 d0       	rcall	.+0      	; 0xa80e <menu_FIP+0x132>
    a80e:	ed b7       	in	r30, 0x3d	; 61
    a810:	fe b7       	in	r31, 0x3e	; 62
    a812:	31 96       	adiw	r30, 0x01	; 1
    a814:	ad b7       	in	r26, 0x3d	; 61
    a816:	be b7       	in	r27, 0x3e	; 62
    a818:	12 96       	adiw	r26, 0x02	; 2
    a81a:	1c 93       	st	X, r17
    a81c:	0e 93       	st	-X, r16
    a81e:	11 97       	sbiw	r26, 0x01	; 1
    a820:	93 82       	std	Z+3, r9	; 0x03
    a822:	82 82       	std	Z+2, r8	; 0x02
    a824:	01 96       	adiw	r24, 0x01	; 1
    a826:	95 83       	std	Z+5, r25	; 0x05
    a828:	84 83       	std	Z+4, r24	; 0x04
    a82a:	b7 82       	std	Z+7, r11	; 0x07
    a82c:	a6 82       	std	Z+6, r10	; 0x06
    a82e:	04 96       	adiw	r24, 0x04	; 4
    a830:	91 87       	std	Z+9, r25	; 0x09
    a832:	80 87       	std	Z+8, r24	; 0x08
    a834:	f3 86       	std	Z+11, r15	; 0x0b
    a836:	e2 86       	std	Z+10, r14	; 0x0a
    a838:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			    lcd_print((iLoop+1),1,lcdteks);
    a83c:	ed b7       	in	r30, 0x3d	; 61
    a83e:	fe b7       	in	r31, 0x3e	; 62
    a840:	3c 96       	adiw	r30, 0x0c	; 12
    a842:	0f b6       	in	r0, 0x3f	; 63
    a844:	f8 94       	cli
    a846:	fe bf       	out	0x3e, r31	; 62
    a848:	0f be       	out	0x3f, r0	; 63
    a84a:	ed bf       	out	0x3d, r30	; 61
    a84c:	80 91 69 02 	lds	r24, 0x0269
    a850:	8f 5f       	subi	r24, 0xFF	; 255
    a852:	61 e0       	ldi	r22, 0x01	; 1
    a854:	a8 01       	movw	r20, r16
    a856:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    a85a:	80 91 69 02 	lds	r24, 0x0269
    a85e:	90 91 6a 02 	lds	r25, 0x026A
    a862:	01 96       	adiw	r24, 0x01	; 1
    a864:	90 93 6a 02 	sts	0x026A, r25
    a868:	80 93 69 02 	sts	0x0269, r24
    a86c:	a0 91 69 02 	lds	r26, 0x0269
    a870:	b0 91 6a 02 	lds	r27, 0x026A
    a874:	a4 30       	cpi	r26, 0x04	; 4
    a876:	b1 05       	cpc	r27, r1
    a878:	08 f4       	brcc	.+2      	; 0xa87c <menu_FIP+0x1a0>
    a87a:	94 cf       	rjmp	.-216    	; 0xa7a4 <menu_FIP+0xc8>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    a87c:	81 e0       	ldi	r24, 0x01	; 1
    a87e:	6f e0       	ldi	r22, 0x0F	; 15
    a880:	40 e2       	ldi	r20, 0x20	; 32
    a882:	5b e1       	ldi	r21, 0x1B	; 27
    a884:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    a888:	82 e0       	ldi	r24, 0x02	; 2
    a88a:	6f e0       	ldi	r22, 0x0F	; 15
    a88c:	4a e1       	ldi	r20, 0x1A	; 26
    a88e:	5b e1       	ldi	r21, 0x1B	; 27
    a890:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    a894:	83 e0       	ldi	r24, 0x03	; 3
    a896:	6f e0       	ldi	r22, 0x0F	; 15
    a898:	44 e1       	ldi	r20, 0x14	; 20
    a89a:	5b e1       	ldi	r21, 0x1B	; 27
    a89c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    a8a0:	84 e0       	ldi	r24, 0x04	; 4
    a8a2:	6f e0       	ldi	r22, 0x0F	; 15
    a8a4:	4d e0       	ldi	r20, 0x0D	; 13
    a8a6:	5b e1       	ldi	r21, 0x1B	; 27
    a8a8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		    iLoop=0;
    a8ac:	10 92 6a 02 	sts	0x026A, r1
    a8b0:	10 92 69 02 	sts	0x0269, r1
		    stEnterFIP=efFIPInput;
    a8b4:	81 e0       	ldi	r24, 0x01	; 1
    a8b6:	7d c0       	rjmp	.+250    	; 0xa9b2 <menu_FIP+0x2d6>
	        break;
	   case efFIPInput:
		    iLoop++;
    a8b8:	80 91 69 02 	lds	r24, 0x0269
    a8bc:	90 91 6a 02 	lds	r25, 0x026A
    a8c0:	01 96       	adiw	r24, 0x01	; 1
    a8c2:	90 93 6a 02 	sts	0x026A, r25
    a8c6:	80 93 69 02 	sts	0x0269, r24
		    KeyPressed=_key_scan(1);
    a8ca:	81 e0       	ldi	r24, 0x01	; 1
    a8cc:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    a8d0:	08 2f       	mov	r16, r24
		    KeyChar=_key_btn(KeyPressed);
    a8d2:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    a8d6:	98 2f       	mov	r25, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    a8d8:	18 2f       	mov	r17, r24
    a8da:	11 53       	subi	r17, 0x31	; 49
    a8dc:	18 30       	cpi	r17, 0x08	; 8
    a8de:	60 f4       	brcc	.+24     	; 0xa8f8 <menu_FIP+0x21c>
		 	     if (KeyCharLast!=KeyChar){
    a8e0:	80 91 5a 01 	lds	r24, 0x015A
    a8e4:	89 17       	cp	r24, r25
    a8e6:	41 f0       	breq	.+16     	; 0xa8f8 <menu_FIP+0x21c>
				     KeyCharLast=KeyChar;
    a8e8:	90 93 5a 01 	sts	0x015A, r25
				     iLoop=1000;
    a8ec:	88 ee       	ldi	r24, 0xE8	; 232
    a8ee:	93 e0       	ldi	r25, 0x03	; 3
    a8f0:	90 93 6a 02 	sts	0x026A, r25
    a8f4:	80 93 69 02 	sts	0x0269, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    a8f8:	80 91 69 02 	lds	r24, 0x0269
    a8fc:	90 91 6a 02 	lds	r25, 0x026A
    a900:	60 ed       	ldi	r22, 0xD0	; 208
    a902:	77 e0       	ldi	r23, 0x07	; 7
    a904:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    a908:	89 2b       	or	r24, r25
    a90a:	39 f4       	brne	.+14     	; 0xa91a <menu_FIP+0x23e>
		        lcd_xy(1,19);_lcd('_'); 
    a90c:	81 e0       	ldi	r24, 0x01	; 1
    a90e:	63 e1       	ldi	r22, 0x13	; 19
    a910:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
    a914:	8f e5       	ldi	r24, 0x5F	; 95
    a916:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
			   }
           if ((iLoop%2000)==1000){
    a91a:	80 91 69 02 	lds	r24, 0x0269
    a91e:	90 91 6a 02 	lds	r25, 0x026A
    a922:	60 ed       	ldi	r22, 0xD0	; 208
    a924:	77 e0       	ldi	r23, 0x07	; 7
    a926:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    a92a:	88 5e       	subi	r24, 0xE8	; 232
    a92c:	93 40       	sbci	r25, 0x03	; 3
    a92e:	41 f4       	brne	.+16     	; 0xa940 <menu_FIP+0x264>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    a930:	81 e0       	ldi	r24, 0x01	; 1
    a932:	63 e1       	ldi	r22, 0x13	; 19
    a934:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
    a938:	80 91 5a 01 	lds	r24, 0x015A
    a93c:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    a940:	18 30       	cpi	r17, 0x08	; 8
    a942:	30 f0       	brcs	.+12     	; 0xa950 <menu_FIP+0x274>
    a944:	07 3b       	cpi	r16, 0xB7	; 183
    a946:	91 f5       	brne	.+100    	; 0xa9ac <menu_FIP+0x2d0>
    a948:	80 91 5a 01 	lds	r24, 0x015A
    a94c:	80 32       	cpi	r24, 0x20	; 32
    a94e:	b1 f1       	breq	.+108    	; 0xa9bc <menu_FIP+0x2e0>
		         FIP_Used=FIP[KeyCharLast-'1'];
    a950:	80 91 5a 01 	lds	r24, 0x015A
    a954:	fe 01       	movw	r30, r28
    a956:	ba 97       	sbiw	r30, 0x2a	; 42
    a958:	e8 0f       	add	r30, r24
    a95a:	f1 1d       	adc	r31, r1
    a95c:	20 81       	ld	r18, Z
    a95e:	20 93 6b 02 	sts	0x026B, r18
				 if (FIP_Used<=99){
    a962:	24 36       	cpi	r18, 0x64	; 100
    a964:	f0 f4       	brcc	.+60     	; 0xa9a2 <menu_FIP+0x2c6>
                     //leadingZero(FIP_Used,sFIPUsed);
					 //xFIP[0]=FIP_Used;
					 *xFIP=FIP_Used;
    a966:	d7 01       	movw	r26, r14
    a968:	2c 93       	st	X, r18
					 sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
    a96a:	00 d0       	rcall	.+0      	; 0xa96c <menu_FIP+0x290>
    a96c:	00 d0       	rcall	.+0      	; 0xa96e <menu_FIP+0x292>
    a96e:	00 d0       	rcall	.+0      	; 0xa970 <menu_FIP+0x294>
    a970:	ed b7       	in	r30, 0x3d	; 61
    a972:	fe b7       	in	r31, 0x3e	; 62
    a974:	31 96       	adiw	r30, 0x01	; 1
    a976:	ad b7       	in	r26, 0x3d	; 61
    a978:	be b7       	in	r27, 0x3e	; 62
    a97a:	12 96       	adiw	r26, 0x02	; 2
    a97c:	dc 92       	st	X, r13
    a97e:	ce 92       	st	-X, r12
    a980:	11 97       	sbiw	r26, 0x01	; 1
    a982:	88 e0       	ldi	r24, 0x08	; 8
    a984:	9b e1       	ldi	r25, 0x1B	; 27
    a986:	93 83       	std	Z+3, r25	; 0x03
    a988:	82 83       	std	Z+2, r24	; 0x02
    a98a:	24 83       	std	Z+4, r18	; 0x04
    a98c:	15 82       	std	Z+5, r1	; 0x05
    a98e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    a992:	ed b7       	in	r30, 0x3d	; 61
    a994:	fe b7       	in	r31, 0x3e	; 62
    a996:	36 96       	adiw	r30, 0x06	; 6
    a998:	0f b6       	in	r0, 0x3f	; 63
    a99a:	f8 94       	cli
    a99c:	fe bf       	out	0x3e, r31	; 62
    a99e:	0f be       	out	0x3f, r0	; 63
    a9a0:	ed bf       	out	0x3d, r30	; 61

					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    a9a2:	82 e0       	ldi	r24, 0x02	; 2
    a9a4:	80 93 6c 02 	sts	0x026C, r24
    a9a8:	80 e0       	ldi	r24, 0x00	; 0
    a9aa:	09 c0       	rjmp	.+18     	; 0xa9be <menu_FIP+0x2e2>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    a9ac:	07 3e       	cpi	r16, 0xE7	; 231
    a9ae:	31 f4       	brne	.+12     	; 0xa9bc <menu_FIP+0x2e0>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    a9b0:	82 e0       	ldi	r24, 0x02	; 2
    a9b2:	80 93 6c 02 	sts	0x026C, r24
    a9b6:	03 c0       	rjmp	.+6      	; 0xa9be <menu_FIP+0x2e2>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    a9b8:	10 92 6c 02 	sts	0x026C, r1
    a9bc:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    a9be:	a2 96       	adiw	r28, 0x22	; 34
    a9c0:	0f b6       	in	r0, 0x3f	; 63
    a9c2:	f8 94       	cli
    a9c4:	de bf       	out	0x3e, r29	; 62
    a9c6:	0f be       	out	0x3f, r0	; 63
    a9c8:	cd bf       	out	0x3d, r28	; 61
    a9ca:	cf 91       	pop	r28
    a9cc:	df 91       	pop	r29
    a9ce:	1f 91       	pop	r17
    a9d0:	0f 91       	pop	r16
    a9d2:	ff 90       	pop	r15
    a9d4:	ef 90       	pop	r14
    a9d6:	df 90       	pop	r13
    a9d8:	cf 90       	pop	r12
    a9da:	bf 90       	pop	r11
    a9dc:	af 90       	pop	r10
    a9de:	9f 90       	pop	r9
    a9e0:	8f 90       	pop	r8
    a9e2:	7f 90       	pop	r7
    a9e4:	6f 90       	pop	r6
    a9e6:	5f 90       	pop	r5
    a9e8:	4f 90       	pop	r4
    a9ea:	08 95       	ret

0000a9ec <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    a9ec:	ef 92       	push	r14
    a9ee:	ff 92       	push	r15
    a9f0:	0f 93       	push	r16
    a9f2:	1f 93       	push	r17
    a9f4:	cf 93       	push	r28
    a9f6:	df 93       	push	r29
    a9f8:	ec 01       	movw	r28, r24
    a9fa:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    a9fc:	08 81       	ld	r16, Y
    a9fe:	00 53       	subi	r16, 0x30	; 48
    aa00:	10 e0       	ldi	r17, 0x00	; 0
    aa02:	04 c0       	rjmp	.+8      	; 0xaa0c <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    aa04:	ce 01       	movw	r24, r28
    aa06:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    aa0a:	1f 5f       	subi	r17, 0xFF	; 255
    aa0c:	10 17       	cp	r17, r16
    aa0e:	d0 f3       	brcs	.-12     	; 0xaa04 <ValidateRestoreCode+0x18>
	 //uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    aa10:	ce 01       	movw	r24, r28
    aa12:	b7 01       	movw	r22, r14
    aa14:	0e 94 e3 a9 	call	0x153c6	; 0x153c6 <strcmp>
    aa18:	00 97       	sbiw	r24, 0x00	; 0
    aa1a:	11 f0       	breq	.+4      	; 0xaa20 <ValidateRestoreCode+0x34>
    aa1c:	82 e0       	ldi	r24, 0x02	; 2
    aa1e:	01 c0       	rjmp	.+2      	; 0xaa22 <ValidateRestoreCode+0x36>
    aa20:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    aa22:	df 91       	pop	r29
    aa24:	cf 91       	pop	r28
    aa26:	1f 91       	pop	r17
    aa28:	0f 91       	pop	r16
    aa2a:	ff 90       	pop	r15
    aa2c:	ef 90       	pop	r14
    aa2e:	08 95       	ret

0000aa30 <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    aa30:	ef 92       	push	r14
    aa32:	ff 92       	push	r15
    aa34:	0f 93       	push	r16
    aa36:	1f 93       	push	r17
    aa38:	df 93       	push	r29
    aa3a:	cf 93       	push	r28
    aa3c:	cd b7       	in	r28, 0x3d	; 61
    aa3e:	de b7       	in	r29, 0x3e	; 62
    aa40:	2a 97       	sbiw	r28, 0x0a	; 10
    aa42:	0f b6       	in	r0, 0x3f	; 63
    aa44:	f8 94       	cli
    aa46:	de bf       	out	0x3e, r29	; 62
    aa48:	0f be       	out	0x3f, r0	; 63
    aa4a:	cd bf       	out	0x3d, r28	; 61
    aa4c:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    aa4e:	fb 01       	movw	r30, r22
    aa50:	01 90       	ld	r0, Z+
    aa52:	00 20       	and	r0, r0
    aa54:	e9 f7       	brne	.-6      	; 0xaa50 <ValidateGeniusCode+0x20>
    aa56:	39 97       	sbiw	r30, 0x09	; 9
    aa58:	e6 17       	cp	r30, r22
    aa5a:	f7 07       	cpc	r31, r23
    aa5c:	11 f0       	breq	.+4      	; 0xaa62 <ValidateGeniusCode+0x32>
    aa5e:	80 e0       	ldi	r24, 0x00	; 0
    aa60:	11 c0       	rjmp	.+34     	; 0xaa84 <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    aa62:	fb 01       	movw	r30, r22
    aa64:	60 81       	ld	r22, Z
    aa66:	8e 01       	movw	r16, r28
    aa68:	0f 5f       	subi	r16, 0xFF	; 255
    aa6a:	1f 4f       	sbci	r17, 0xFF	; 255
    aa6c:	a8 01       	movw	r20, r16
    aa6e:	0e 94 f5 2f 	call	0x5fea	; 0x5fea <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    aa72:	c8 01       	movw	r24, r16
    aa74:	b7 01       	movw	r22, r14
    aa76:	0e 94 e3 a9 	call	0x153c6	; 0x153c6 <strcmp>
    aa7a:	00 97       	sbiw	r24, 0x00	; 0
    aa7c:	11 f0       	breq	.+4      	; 0xaa82 <ValidateGeniusCode+0x52>
    aa7e:	82 e0       	ldi	r24, 0x02	; 2
    aa80:	01 c0       	rjmp	.+2      	; 0xaa84 <ValidateGeniusCode+0x54>
    aa82:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    aa84:	2a 96       	adiw	r28, 0x0a	; 10
    aa86:	0f b6       	in	r0, 0x3f	; 63
    aa88:	f8 94       	cli
    aa8a:	de bf       	out	0x3e, r29	; 62
    aa8c:	0f be       	out	0x3f, r0	; 63
    aa8e:	cd bf       	out	0x3d, r28	; 61
    aa90:	cf 91       	pop	r28
    aa92:	df 91       	pop	r29
    aa94:	1f 91       	pop	r17
    aa96:	0f 91       	pop	r16
    aa98:	ff 90       	pop	r15
    aa9a:	ef 90       	pop	r14
    aa9c:	08 95       	ret

0000aa9e <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    aa9e:	ff 92       	push	r15
    aaa0:	0f 93       	push	r16
    aaa2:	1f 93       	push	r17
    aaa4:	df 93       	push	r29
    aaa6:	cf 93       	push	r28
    aaa8:	cd b7       	in	r28, 0x3d	; 61
    aaaa:	de b7       	in	r29, 0x3e	; 62
    aaac:	64 97       	sbiw	r28, 0x14	; 20
    aaae:	0f b6       	in	r0, 0x3f	; 63
    aab0:	f8 94       	cli
    aab2:	de bf       	out	0x3e, r29	; 62
    aab4:	0f be       	out	0x3f, r0	; 63
    aab6:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    aab8:	10 92 2e 02 	sts	0x022E, r1
     switch(stClientIP){
    aabc:	80 91 58 01 	lds	r24, 0x0158
    aac0:	82 30       	cpi	r24, 0x02	; 2
    aac2:	09 f4       	brne	.+2      	; 0xaac6 <FMenuSettingServerIP+0x28>
    aac4:	7b c0       	rjmp	.+246    	; 0xabbc <FMenuSettingServerIP+0x11e>
    aac6:	83 30       	cpi	r24, 0x03	; 3
    aac8:	20 f4       	brcc	.+8      	; 0xaad2 <FMenuSettingServerIP+0x34>
    aaca:	81 30       	cpi	r24, 0x01	; 1
    aacc:	09 f0       	breq	.+2      	; 0xaad0 <FMenuSettingServerIP+0x32>
    aace:	62 c2       	rjmp	.+1220   	; 0xaf94 <FMenuSettingServerIP+0x4f6>
    aad0:	07 c0       	rjmp	.+14     	; 0xaae0 <FMenuSettingServerIP+0x42>
    aad2:	83 30       	cpi	r24, 0x03	; 3
    aad4:	09 f4       	brne	.+2      	; 0xaad8 <FMenuSettingServerIP+0x3a>
    aad6:	59 c2       	rjmp	.+1202   	; 0xaf8a <FMenuSettingServerIP+0x4ec>
    aad8:	84 30       	cpi	r24, 0x04	; 4
    aada:	09 f0       	breq	.+2      	; 0xaade <FMenuSettingServerIP+0x40>
    aadc:	5b c2       	rjmp	.+1206   	; 0xaf94 <FMenuSettingServerIP+0x4f6>
    aade:	47 c2       	rjmp	.+1166   	; 0xaf6e <FMenuSettingServerIP+0x4d0>
		  case cipInit:
			   lcd_clear();
    aae0:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    aae4:	81 e0       	ldi	r24, 0x01	; 1
    aae6:	61 e0       	ldi	r22, 0x01	; 1
    aae8:	4c e8       	ldi	r20, 0x8C	; 140
    aaea:	52 e1       	ldi	r21, 0x12	; 18
    aaec:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    aaf0:	87 e2       	ldi	r24, 0x27	; 39
    aaf2:	92 e0       	ldi	r25, 0x02	; 2
    aaf4:	6c e2       	ldi	r22, 0x2C	; 44
    aaf6:	70 e0       	ldi	r23, 0x00	; 0
    aaf8:	44 e0       	ldi	r20, 0x04	; 4
    aafa:	50 e0       	ldi	r21, 0x00	; 0
    aafc:	24 e4       	ldi	r18, 0x44	; 68
    aafe:	32 e1       	ldi	r19, 0x12	; 18
    ab00:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    ab04:	8d b7       	in	r24, 0x3d	; 61
    ab06:	9e b7       	in	r25, 0x3e	; 62
    ab08:	0c 97       	sbiw	r24, 0x0c	; 12
    ab0a:	0f b6       	in	r0, 0x3f	; 63
    ab0c:	f8 94       	cli
    ab0e:	9e bf       	out	0x3e, r25	; 62
    ab10:	0f be       	out	0x3f, r0	; 63
    ab12:	8d bf       	out	0x3d, r24	; 61
    ab14:	ed b7       	in	r30, 0x3d	; 61
    ab16:	fe b7       	in	r31, 0x3e	; 62
    ab18:	31 96       	adiw	r30, 0x01	; 1
    ab1a:	8e 01       	movw	r16, r28
    ab1c:	0f 5f       	subi	r16, 0xFF	; 255
    ab1e:	1f 4f       	sbci	r17, 0xFF	; 255
    ab20:	ad b7       	in	r26, 0x3d	; 61
    ab22:	be b7       	in	r27, 0x3e	; 62
    ab24:	12 96       	adiw	r26, 0x02	; 2
    ab26:	1c 93       	st	X, r17
    ab28:	0e 93       	st	-X, r16
    ab2a:	11 97       	sbiw	r26, 0x01	; 1
    ab2c:	8b e7       	ldi	r24, 0x7B	; 123
    ab2e:	92 e1       	ldi	r25, 0x12	; 18
    ab30:	93 83       	std	Z+3, r25	; 0x03
    ab32:	82 83       	std	Z+2, r24	; 0x02
    ab34:	80 91 27 02 	lds	r24, 0x0227
    ab38:	84 83       	std	Z+4, r24	; 0x04
    ab3a:	15 82       	std	Z+5, r1	; 0x05
    ab3c:	80 91 28 02 	lds	r24, 0x0228
    ab40:	86 83       	std	Z+6, r24	; 0x06
    ab42:	17 82       	std	Z+7, r1	; 0x07
    ab44:	80 91 29 02 	lds	r24, 0x0229
    ab48:	80 87       	std	Z+8, r24	; 0x08
    ab4a:	11 86       	std	Z+9, r1	; 0x09
    ab4c:	80 91 2a 02 	lds	r24, 0x022A
    ab50:	82 87       	std	Z+10, r24	; 0x0a
    ab52:	13 86       	std	Z+11, r1	; 0x0b
    ab54:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    ab58:	ed b7       	in	r30, 0x3d	; 61
    ab5a:	fe b7       	in	r31, 0x3e	; 62
    ab5c:	3c 96       	adiw	r30, 0x0c	; 12
    ab5e:	0f b6       	in	r0, 0x3f	; 63
    ab60:	f8 94       	cli
    ab62:	fe bf       	out	0x3e, r31	; 62
    ab64:	0f be       	out	0x3f, r0	; 63
    ab66:	ed bf       	out	0x3d, r30	; 61
    ab68:	82 e0       	ldi	r24, 0x02	; 2
    ab6a:	61 e0       	ldi	r22, 0x01	; 1
    ab6c:	a8 01       	movw	r20, r16
    ab6e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    ab72:	83 e0       	ldi	r24, 0x03	; 3
    ab74:	61 e0       	ldi	r22, 0x01	; 1
    ab76:	46 e6       	ldi	r20, 0x66	; 102
    ab78:	52 e1       	ldi	r21, 0x12	; 18
    ab7a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    ab7e:	84 e0       	ldi	r24, 0x04	; 4
    ab80:	61 e0       	ldi	r22, 0x01	; 1
    ab82:	41 e5       	ldi	r20, 0x51	; 81
    ab84:	52 e1       	ldi	r21, 0x12	; 18
    ab86:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
               iLoop=0;
    ab8a:	10 92 26 02 	sts	0x0226, r1
    ab8e:	10 92 25 02 	sts	0x0225, r1
			   y=3,x=8;
    ab92:	83 e0       	ldi	r24, 0x03	; 3
    ab94:	80 93 2c 02 	sts	0x022C, r24
    ab98:	88 e0       	ldi	r24, 0x08	; 8
    ab9a:	80 93 2d 02 	sts	0x022D, r24
			   iInput=0; iBlok=0;
    ab9e:	10 92 2b 02 	sts	0x022B, r1
    aba2:	10 92 24 02 	sts	0x0224, r1
    aba6:	10 92 23 02 	sts	0x0223, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    abaa:	80 e3       	ldi	r24, 0x30	; 48
    abac:	80 93 30 02 	sts	0x0230, r24
    abb0:	80 93 31 02 	sts	0x0231, r24
    abb4:	80 93 32 02 	sts	0x0232, r24
			   stClientIP=cipInputIP; 
    abb8:	82 e0       	ldi	r24, 0x02	; 2
    abba:	e4 c1       	rjmp	.+968    	; 0xaf84 <FMenuSettingServerIP+0x4e6>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    abbc:	80 91 25 02 	lds	r24, 0x0225
    abc0:	90 91 26 02 	lds	r25, 0x0226
    abc4:	01 96       	adiw	r24, 0x01	; 1
    abc6:	90 93 26 02 	sts	0x0226, r25
    abca:	80 93 25 02 	sts	0x0225, r24
			   if ((iLoop%2000)==0){
    abce:	60 ed       	ldi	r22, 0xD0	; 208
    abd0:	77 e0       	ldi	r23, 0x07	; 7
    abd2:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    abd6:	89 2b       	or	r24, r25
    abd8:	81 f4       	brne	.+32     	; 0xabfa <FMenuSettingServerIP+0x15c>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    abda:	80 91 23 02 	lds	r24, 0x0223
    abde:	90 91 24 02 	lds	r25, 0x0224
    abe2:	88 0f       	add	r24, r24
    abe4:	99 1f       	adc	r25, r25
    abe6:	88 0f       	add	r24, r24
    abe8:	99 1f       	adc	r25, r25
    abea:	60 91 2d 02 	lds	r22, 0x022D
    abee:	68 0f       	add	r22, r24
    abf0:	80 91 2c 02 	lds	r24, 0x022C
    abf4:	4f e5       	ldi	r20, 0x5F	; 95
    abf6:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    abfa:	80 91 25 02 	lds	r24, 0x0225
    abfe:	90 91 26 02 	lds	r25, 0x0226
    ac02:	60 ed       	ldi	r22, 0xD0	; 208
    ac04:	77 e0       	ldi	r23, 0x07	; 7
    ac06:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    ac0a:	88 5e       	subi	r24, 0xE8	; 232
    ac0c:	93 40       	sbci	r25, 0x03	; 3
    ac0e:	81 f4       	brne	.+32     	; 0xac30 <FMenuSettingServerIP+0x192>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    ac10:	80 91 23 02 	lds	r24, 0x0223
    ac14:	90 91 24 02 	lds	r25, 0x0224
    ac18:	88 0f       	add	r24, r24
    ac1a:	99 1f       	adc	r25, r25
    ac1c:	88 0f       	add	r24, r24
    ac1e:	99 1f       	adc	r25, r25
    ac20:	60 91 2d 02 	lds	r22, 0x022D
    ac24:	68 0f       	add	r22, r24
    ac26:	80 91 2c 02 	lds	r24, 0x022C
    ac2a:	40 e2       	ldi	r20, 0x20	; 32
    ac2c:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    ac30:	81 e0       	ldi	r24, 0x01	; 1
    ac32:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    ac36:	f8 2e       	mov	r15, r24
			   keyChar=_key_btn(keyPressed);
    ac38:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    ac3c:	28 2f       	mov	r18, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    ac3e:	80 53       	subi	r24, 0x30	; 48
    ac40:	8a 30       	cpi	r24, 0x0A	; 10
    ac42:	08 f0       	brcs	.+2      	; 0xac46 <FMenuSettingServerIP+0x1a8>
    ac44:	d6 c0       	rjmp	.+428    	; 0xadf2 <FMenuSettingServerIP+0x354>
    ac46:	80 e5       	ldi	r24, 0x50	; 80
    ac48:	93 ec       	ldi	r25, 0xC3	; 195
    ac4a:	01 97       	sbiw	r24, 0x01	; 1
    ac4c:	f1 f7       	brne	.-4      	; 0xac4a <FMenuSettingServerIP+0x1ac>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    ac4e:	80 91 2b 02 	lds	r24, 0x022B
    ac52:	e8 2f       	mov	r30, r24
    ac54:	f0 e0       	ldi	r31, 0x00	; 0
    ac56:	e0 5d       	subi	r30, 0xD0	; 208
    ac58:	fd 4f       	sbci	r31, 0xFD	; 253
    ac5a:	20 83       	st	Z, r18
				   iInput++;                    
    ac5c:	8f 5f       	subi	r24, 0xFF	; 255
    ac5e:	80 93 2b 02 	sts	0x022B, r24
				   for (i=1;i<(iInput+1);i++){
    ac62:	81 e0       	ldi	r24, 0x01	; 1
    ac64:	1c c0       	rjmp	.+56     	; 0xac9e <FMenuSettingServerIP+0x200>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    ac66:	80 91 2d 02 	lds	r24, 0x022D
    ac6a:	68 0f       	add	r22, r24
    ac6c:	63 50       	subi	r22, 0x03	; 3
    ac6e:	80 91 23 02 	lds	r24, 0x0223
    ac72:	90 91 24 02 	lds	r25, 0x0224
    ac76:	88 0f       	add	r24, r24
    ac78:	99 1f       	adc	r25, r25
    ac7a:	88 0f       	add	r24, r24
    ac7c:	99 1f       	adc	r25, r25
    ac7e:	68 0f       	add	r22, r24
    ac80:	80 91 2c 02 	lds	r24, 0x022C
    ac84:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
    ac88:	e0 91 2f 02 	lds	r30, 0x022F
    ac8c:	f0 e0       	ldi	r31, 0x00	; 0
    ac8e:	e1 5d       	subi	r30, 0xD1	; 209
    ac90:	fd 4f       	sbci	r31, 0xFD	; 253
    ac92:	80 81       	ld	r24, Z
    ac94:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    ac98:	80 91 2f 02 	lds	r24, 0x022F
    ac9c:	8f 5f       	subi	r24, 0xFF	; 255
    ac9e:	80 93 2f 02 	sts	0x022F, r24
    aca2:	70 91 2b 02 	lds	r23, 0x022B
    aca6:	60 91 2f 02 	lds	r22, 0x022F
    acaa:	27 2f       	mov	r18, r23
    acac:	30 e0       	ldi	r19, 0x00	; 0
    acae:	86 2f       	mov	r24, r22
    acb0:	90 e0       	ldi	r25, 0x00	; 0
    acb2:	28 17       	cp	r18, r24
    acb4:	39 07       	cpc	r19, r25
    acb6:	bc f6       	brge	.-82     	; 0xac66 <FMenuSettingServerIP+0x1c8>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    acb8:	73 30       	cpi	r23, 0x03	; 3
    acba:	08 f4       	brcc	.+2      	; 0xacbe <FMenuSettingServerIP+0x220>
    acbc:	91 c0       	rjmp	.+290    	; 0xade0 <FMenuSettingServerIP+0x342>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    acbe:	40 91 23 02 	lds	r20, 0x0223
    acc2:	50 91 24 02 	lds	r21, 0x0224
    acc6:	fa 01       	movw	r30, r20
    acc8:	e9 5d       	subi	r30, 0xD9	; 217
    acca:	fd 4f       	sbci	r31, 0xFD	; 253
    accc:	20 91 32 02 	lds	r18, 0x0232
    acd0:	20 5d       	subi	r18, 0xD0	; 208
    acd2:	80 91 30 02 	lds	r24, 0x0230
    acd6:	34 e6       	ldi	r19, 0x64	; 100
    acd8:	83 9f       	mul	r24, r19
    acda:	c0 01       	movw	r24, r0
    acdc:	11 24       	eor	r1, r1
    acde:	28 0f       	add	r18, r24
    ace0:	80 91 31 02 	lds	r24, 0x0231
    ace4:	3a e0       	ldi	r19, 0x0A	; 10
    ace6:	83 9f       	mul	r24, r19
    ace8:	c0 01       	movw	r24, r0
    acea:	11 24       	eor	r1, r1
    acec:	28 0f       	add	r18, r24
    acee:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    acf0:	80 e3       	ldi	r24, 0x30	; 48
    acf2:	80 93 30 02 	sts	0x0230, r24
    acf6:	80 93 31 02 	sts	0x0231, r24
    acfa:	80 93 32 02 	sts	0x0232, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    acfe:	44 0f       	add	r20, r20
    ad00:	55 1f       	adc	r21, r21
    ad02:	44 0f       	add	r20, r20
    ad04:	55 1f       	adc	r21, r21
    ad06:	60 91 2d 02 	lds	r22, 0x022D
    ad0a:	64 0f       	add	r22, r20
    ad0c:	67 1b       	sub	r22, r23
    ad0e:	80 91 2c 02 	lds	r24, 0x022C
    ad12:	4d e4       	ldi	r20, 0x4D	; 77
    ad14:	52 e1       	ldi	r21, 0x12	; 18
    ad16:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    ad1a:	00 d0       	rcall	.+0      	; 0xad1c <FMenuSettingServerIP+0x27e>
    ad1c:	00 d0       	rcall	.+0      	; 0xad1e <FMenuSettingServerIP+0x280>
    ad1e:	00 d0       	rcall	.+0      	; 0xad20 <FMenuSettingServerIP+0x282>
    ad20:	ad b7       	in	r26, 0x3d	; 61
    ad22:	be b7       	in	r27, 0x3e	; 62
    ad24:	11 96       	adiw	r26, 0x01	; 1
    ad26:	8e 01       	movw	r16, r28
    ad28:	0f 5f       	subi	r16, 0xFF	; 255
    ad2a:	1f 4f       	sbci	r17, 0xFF	; 255
    ad2c:	ed b7       	in	r30, 0x3d	; 61
    ad2e:	fe b7       	in	r31, 0x3e	; 62
    ad30:	12 83       	std	Z+2, r17	; 0x02
    ad32:	01 83       	std	Z+1, r16	; 0x01
    ad34:	8a e4       	ldi	r24, 0x4A	; 74
    ad36:	92 e1       	ldi	r25, 0x12	; 18
    ad38:	13 96       	adiw	r26, 0x03	; 3
    ad3a:	9c 93       	st	X, r25
    ad3c:	8e 93       	st	-X, r24
    ad3e:	12 97       	sbiw	r26, 0x02	; 2
    ad40:	e0 91 23 02 	lds	r30, 0x0223
    ad44:	f0 91 24 02 	lds	r31, 0x0224
    ad48:	e9 5d       	subi	r30, 0xD9	; 217
    ad4a:	fd 4f       	sbci	r31, 0xFD	; 253
    ad4c:	80 81       	ld	r24, Z
    ad4e:	14 96       	adiw	r26, 0x04	; 4
    ad50:	8c 93       	st	X, r24
    ad52:	14 97       	sbiw	r26, 0x04	; 4
    ad54:	15 96       	adiw	r26, 0x05	; 5
    ad56:	1c 92       	st	X, r1
    ad58:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    ad5c:	f8 01       	movw	r30, r16
    ad5e:	01 90       	ld	r0, Z+
    ad60:	00 20       	and	r0, r0
    ad62:	e9 f7       	brne	.-6      	; 0xad5e <FMenuSettingServerIP+0x2c0>
    ad64:	31 97       	sbiw	r30, 0x01	; 1
    ad66:	e0 1b       	sub	r30, r16
    ad68:	f1 0b       	sbc	r31, r17
    ad6a:	8d b7       	in	r24, 0x3d	; 61
    ad6c:	9e b7       	in	r25, 0x3e	; 62
    ad6e:	06 96       	adiw	r24, 0x06	; 6
    ad70:	0f b6       	in	r0, 0x3f	; 63
    ad72:	f8 94       	cli
    ad74:	9e bf       	out	0x3e, r25	; 62
    ad76:	0f be       	out	0x3f, r0	; 63
    ad78:	8d bf       	out	0x3d, r24	; 61
    ad7a:	60 91 2d 02 	lds	r22, 0x022D
    ad7e:	6f 5f       	subi	r22, 0xFF	; 255
    ad80:	80 91 23 02 	lds	r24, 0x0223
    ad84:	90 91 24 02 	lds	r25, 0x0224
    ad88:	88 0f       	add	r24, r24
    ad8a:	99 1f       	adc	r25, r25
    ad8c:	88 0f       	add	r24, r24
    ad8e:	99 1f       	adc	r25, r25
    ad90:	68 0f       	add	r22, r24
    ad92:	6e 1b       	sub	r22, r30
    ad94:	80 91 2c 02 	lds	r24, 0x022C
    ad98:	a8 01       	movw	r20, r16
    ad9a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    ad9e:	80 91 23 02 	lds	r24, 0x0223
    ada2:	90 91 24 02 	lds	r25, 0x0224
    ada6:	00 97       	sbiw	r24, 0x00	; 0
    ada8:	81 f0       	breq	.+32     	; 0xadca <FMenuSettingServerIP+0x32c>
    adaa:	60 91 2d 02 	lds	r22, 0x022D
    adae:	6f 5f       	subi	r22, 0xFF	; 255
    adb0:	81 50       	subi	r24, 0x01	; 1
    adb2:	90 4c       	sbci	r25, 0xC0	; 192
    adb4:	88 0f       	add	r24, r24
    adb6:	99 1f       	adc	r25, r25
    adb8:	88 0f       	add	r24, r24
    adba:	99 1f       	adc	r25, r25
    adbc:	68 0f       	add	r22, r24
    adbe:	80 91 2c 02 	lds	r24, 0x022C
    adc2:	48 e4       	ldi	r20, 0x48	; 72
    adc4:	52 e1       	ldi	r21, 0x12	; 18
    adc6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					   iInput=0;
    adca:	10 92 2b 02 	sts	0x022B, r1
					   iBlok++;
    adce:	80 91 23 02 	lds	r24, 0x0223
    add2:	90 91 24 02 	lds	r25, 0x0224
    add6:	01 96       	adiw	r24, 0x01	; 1
    add8:	90 93 24 02 	sts	0x0224, r25
    addc:	80 93 23 02 	sts	0x0223, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    ade0:	80 91 23 02 	lds	r24, 0x0223
    ade4:	90 91 24 02 	lds	r25, 0x0224
    ade8:	04 97       	sbiw	r24, 0x04	; 4
    adea:	18 f0       	brcs	.+6      	; 0xadf2 <FMenuSettingServerIP+0x354>
    adec:	84 e0       	ldi	r24, 0x04	; 4
    adee:	80 93 58 01 	sts	0x0158, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    adf2:	97 ee       	ldi	r25, 0xE7	; 231
    adf4:	f9 16       	cp	r15, r25
    adf6:	09 f4       	brne	.+2      	; 0xadfa <FMenuSettingServerIP+0x35c>
    adf8:	c4 c0       	rjmp	.+392    	; 0xaf82 <FMenuSettingServerIP+0x4e4>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    adfa:	a7 eb       	ldi	r26, 0xB7	; 183
    adfc:	fa 16       	cp	r15, r26
    adfe:	09 f0       	breq	.+2      	; 0xae02 <FMenuSettingServerIP+0x364>
    ae00:	c9 c0       	rjmp	.+402    	; 0xaf94 <FMenuSettingServerIP+0x4f6>
			       //NextInput
			       if (iBlok<4){
    ae02:	40 91 23 02 	lds	r20, 0x0223
    ae06:	50 91 24 02 	lds	r21, 0x0224
    ae0a:	44 30       	cpi	r20, 0x04	; 4
    ae0c:	51 05       	cpc	r21, r1
    ae0e:	08 f0       	brcs	.+2      	; 0xae12 <FMenuSettingServerIP+0x374>
    ae10:	a6 c0       	rjmp	.+332    	; 0xaf5e <FMenuSettingServerIP+0x4c0>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    ae12:	80 91 2b 02 	lds	r24, 0x022B
    ae16:	81 30       	cpi	r24, 0x01	; 1
    ae18:	41 f4       	brne	.+16     	; 0xae2a <FMenuSettingServerIP+0x38c>
    ae1a:	fa 01       	movw	r30, r20
    ae1c:	e9 5d       	subi	r30, 0xD9	; 217
    ae1e:	fd 4f       	sbci	r31, 0xFD	; 253
    ae20:	80 91 30 02 	lds	r24, 0x0230
    ae24:	80 53       	subi	r24, 0x30	; 48
    ae26:	80 83       	st	Z, r24
    ae28:	22 c0       	rjmp	.+68     	; 0xae6e <FMenuSettingServerIP+0x3d0>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    ae2a:	82 30       	cpi	r24, 0x02	; 2
    ae2c:	49 f4       	brne	.+18     	; 0xae40 <FMenuSettingServerIP+0x3a2>
    ae2e:	fa 01       	movw	r30, r20
    ae30:	e9 5d       	subi	r30, 0xD9	; 217
    ae32:	fd 4f       	sbci	r31, 0xFD	; 253
    ae34:	20 91 31 02 	lds	r18, 0x0231
    ae38:	20 51       	subi	r18, 0x10	; 16
    ae3a:	80 91 30 02 	lds	r24, 0x0230
    ae3e:	11 c0       	rjmp	.+34     	; 0xae62 <FMenuSettingServerIP+0x3c4>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    ae40:	83 30       	cpi	r24, 0x03	; 3
    ae42:	a9 f4       	brne	.+42     	; 0xae6e <FMenuSettingServerIP+0x3d0>
    ae44:	fa 01       	movw	r30, r20
    ae46:	e9 5d       	subi	r30, 0xD9	; 217
    ae48:	fd 4f       	sbci	r31, 0xFD	; 253
    ae4a:	20 91 32 02 	lds	r18, 0x0232
    ae4e:	20 5d       	subi	r18, 0xD0	; 208
    ae50:	80 91 30 02 	lds	r24, 0x0230
    ae54:	34 e6       	ldi	r19, 0x64	; 100
    ae56:	83 9f       	mul	r24, r19
    ae58:	c0 01       	movw	r24, r0
    ae5a:	11 24       	eor	r1, r1
    ae5c:	28 0f       	add	r18, r24
    ae5e:	80 91 31 02 	lds	r24, 0x0231
    ae62:	3a e0       	ldi	r19, 0x0A	; 10
    ae64:	83 9f       	mul	r24, r19
    ae66:	c0 01       	movw	r24, r0
    ae68:	11 24       	eor	r1, r1
    ae6a:	28 0f       	add	r18, r24
    ae6c:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    ae6e:	80 e3       	ldi	r24, 0x30	; 48
    ae70:	80 93 30 02 	sts	0x0230, r24
    ae74:	80 93 31 02 	sts	0x0231, r24
    ae78:	80 93 32 02 	sts	0x0232, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    ae7c:	60 91 2d 02 	lds	r22, 0x022D
    ae80:	63 50       	subi	r22, 0x03	; 3
    ae82:	44 0f       	add	r20, r20
    ae84:	55 1f       	adc	r21, r21
    ae86:	44 0f       	add	r20, r20
    ae88:	55 1f       	adc	r21, r21
    ae8a:	64 0f       	add	r22, r20
    ae8c:	80 91 2c 02 	lds	r24, 0x022C
    ae90:	44 e4       	ldi	r20, 0x44	; 68
    ae92:	52 e1       	ldi	r21, 0x12	; 18
    ae94:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    ae98:	00 d0       	rcall	.+0      	; 0xae9a <FMenuSettingServerIP+0x3fc>
    ae9a:	00 d0       	rcall	.+0      	; 0xae9c <FMenuSettingServerIP+0x3fe>
    ae9c:	00 d0       	rcall	.+0      	; 0xae9e <FMenuSettingServerIP+0x400>
    ae9e:	ad b7       	in	r26, 0x3d	; 61
    aea0:	be b7       	in	r27, 0x3e	; 62
    aea2:	11 96       	adiw	r26, 0x01	; 1
    aea4:	8e 01       	movw	r16, r28
    aea6:	0f 5f       	subi	r16, 0xFF	; 255
    aea8:	1f 4f       	sbci	r17, 0xFF	; 255
    aeaa:	ed b7       	in	r30, 0x3d	; 61
    aeac:	fe b7       	in	r31, 0x3e	; 62
    aeae:	12 83       	std	Z+2, r17	; 0x02
    aeb0:	01 83       	std	Z+1, r16	; 0x01
    aeb2:	81 e4       	ldi	r24, 0x41	; 65
    aeb4:	92 e1       	ldi	r25, 0x12	; 18
    aeb6:	13 96       	adiw	r26, 0x03	; 3
    aeb8:	9c 93       	st	X, r25
    aeba:	8e 93       	st	-X, r24
    aebc:	12 97       	sbiw	r26, 0x02	; 2
    aebe:	e0 91 23 02 	lds	r30, 0x0223
    aec2:	f0 91 24 02 	lds	r31, 0x0224
    aec6:	e9 5d       	subi	r30, 0xD9	; 217
    aec8:	fd 4f       	sbci	r31, 0xFD	; 253
    aeca:	80 81       	ld	r24, Z
    aecc:	14 96       	adiw	r26, 0x04	; 4
    aece:	8c 93       	st	X, r24
    aed0:	14 97       	sbiw	r26, 0x04	; 4
    aed2:	15 96       	adiw	r26, 0x05	; 5
    aed4:	1c 92       	st	X, r1
    aed6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    aeda:	f8 01       	movw	r30, r16
    aedc:	01 90       	ld	r0, Z+
    aede:	00 20       	and	r0, r0
    aee0:	e9 f7       	brne	.-6      	; 0xaedc <FMenuSettingServerIP+0x43e>
    aee2:	31 97       	sbiw	r30, 0x01	; 1
    aee4:	e0 1b       	sub	r30, r16
    aee6:	f1 0b       	sbc	r31, r17
    aee8:	8d b7       	in	r24, 0x3d	; 61
    aeea:	9e b7       	in	r25, 0x3e	; 62
    aeec:	06 96       	adiw	r24, 0x06	; 6
    aeee:	0f b6       	in	r0, 0x3f	; 63
    aef0:	f8 94       	cli
    aef2:	9e bf       	out	0x3e, r25	; 62
    aef4:	0f be       	out	0x3f, r0	; 63
    aef6:	8d bf       	out	0x3d, r24	; 61
    aef8:	60 91 2d 02 	lds	r22, 0x022D
    aefc:	6f 5f       	subi	r22, 0xFF	; 255
    aefe:	80 91 23 02 	lds	r24, 0x0223
    af02:	90 91 24 02 	lds	r25, 0x0224
    af06:	88 0f       	add	r24, r24
    af08:	99 1f       	adc	r25, r25
    af0a:	88 0f       	add	r24, r24
    af0c:	99 1f       	adc	r25, r25
    af0e:	68 0f       	add	r22, r24
    af10:	6e 1b       	sub	r22, r30
    af12:	80 91 2c 02 	lds	r24, 0x022C
    af16:	a8 01       	movw	r20, r16
    af18:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    af1c:	80 91 23 02 	lds	r24, 0x0223
    af20:	90 91 24 02 	lds	r25, 0x0224
    af24:	00 97       	sbiw	r24, 0x00	; 0
    af26:	81 f0       	breq	.+32     	; 0xaf48 <FMenuSettingServerIP+0x4aa>
    af28:	60 91 2d 02 	lds	r22, 0x022D
    af2c:	6f 5f       	subi	r22, 0xFF	; 255
    af2e:	81 50       	subi	r24, 0x01	; 1
    af30:	90 4c       	sbci	r25, 0xC0	; 192
    af32:	88 0f       	add	r24, r24
    af34:	99 1f       	adc	r25, r25
    af36:	88 0f       	add	r24, r24
    af38:	99 1f       	adc	r25, r25
    af3a:	68 0f       	add	r22, r24
    af3c:	80 91 2c 02 	lds	r24, 0x022C
    af40:	4f e3       	ldi	r20, 0x3F	; 63
    af42:	52 e1       	ldi	r21, 0x12	; 18
    af44:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				       iInput=0;
    af48:	10 92 2b 02 	sts	0x022B, r1
					   iBlok++;	   
    af4c:	80 91 23 02 	lds	r24, 0x0223
    af50:	90 91 24 02 	lds	r25, 0x0224
    af54:	01 96       	adiw	r24, 0x01	; 1
    af56:	90 93 24 02 	sts	0x0224, r25
    af5a:	80 93 23 02 	sts	0x0223, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    af5e:	80 91 23 02 	lds	r24, 0x0223
    af62:	90 91 24 02 	lds	r25, 0x0224
    af66:	04 97       	sbiw	r24, 0x04	; 4
    af68:	a8 f0       	brcs	.+42     	; 0xaf94 <FMenuSettingServerIP+0x4f6>
    af6a:	84 e0       	ldi	r24, 0x04	; 4
    af6c:	0b c0       	rjmp	.+22     	; 0xaf84 <FMenuSettingServerIP+0x4e6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    af6e:	8c e2       	ldi	r24, 0x2C	; 44
    af70:	90 e0       	ldi	r25, 0x00	; 0
    af72:	67 e2       	ldi	r22, 0x27	; 39
    af74:	72 e0       	ldi	r23, 0x02	; 2
    af76:	44 e0       	ldi	r20, 0x04	; 4
    af78:	50 e0       	ldi	r21, 0x00	; 0
    af7a:	2c e4       	ldi	r18, 0x4C	; 76
    af7c:	32 e1       	ldi	r19, 0x12	; 18
    af7e:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    af82:	83 e0       	ldi	r24, 0x03	; 3
    af84:	80 93 58 01 	sts	0x0158, r24
    af88:	05 c0       	rjmp	.+10     	; 0xaf94 <FMenuSettingServerIP+0x4f6>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    af8a:	81 e0       	ldi	r24, 0x01	; 1
    af8c:	80 93 58 01 	sts	0x0158, r24
			   Result=MENU_DONE;
    af90:	80 93 2e 02 	sts	0x022E, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    af94:	80 91 2e 02 	lds	r24, 0x022E
    af98:	64 96       	adiw	r28, 0x14	; 20
    af9a:	0f b6       	in	r0, 0x3f	; 63
    af9c:	f8 94       	cli
    af9e:	de bf       	out	0x3e, r29	; 62
    afa0:	0f be       	out	0x3f, r0	; 63
    afa2:	cd bf       	out	0x3d, r28	; 61
    afa4:	cf 91       	pop	r28
    afa6:	df 91       	pop	r29
    afa8:	1f 91       	pop	r17
    afaa:	0f 91       	pop	r16
    afac:	ff 90       	pop	r15
    afae:	08 95       	ret

0000afb0 <FMenuSettingClientIP>:





char FMenuSettingClientIP(){
    afb0:	ff 92       	push	r15
    afb2:	0f 93       	push	r16
    afb4:	1f 93       	push	r17
    afb6:	df 93       	push	r29
    afb8:	cf 93       	push	r28
    afba:	cd b7       	in	r28, 0x3d	; 61
    afbc:	de b7       	in	r29, 0x3e	; 62
    afbe:	64 97       	sbiw	r28, 0x14	; 20
    afc0:	0f b6       	in	r0, 0x3f	; 63
    afc2:	f8 94       	cli
    afc4:	de bf       	out	0x3e, r29	; 62
    afc6:	0f be       	out	0x3f, r0	; 63
    afc8:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    afca:	10 92 3e 02 	sts	0x023E, r1
	 switch(stClientIP){
    afce:	80 91 59 01 	lds	r24, 0x0159
    afd2:	82 30       	cpi	r24, 0x02	; 2
    afd4:	09 f4       	brne	.+2      	; 0xafd8 <FMenuSettingClientIP+0x28>
    afd6:	7b c0       	rjmp	.+246    	; 0xb0ce <FMenuSettingClientIP+0x11e>
    afd8:	83 30       	cpi	r24, 0x03	; 3
    afda:	20 f4       	brcc	.+8      	; 0xafe4 <FMenuSettingClientIP+0x34>
    afdc:	81 30       	cpi	r24, 0x01	; 1
    afde:	09 f0       	breq	.+2      	; 0xafe2 <FMenuSettingClientIP+0x32>
    afe0:	62 c2       	rjmp	.+1220   	; 0xb4a6 <FMenuSettingClientIP+0x4f6>
    afe2:	07 c0       	rjmp	.+14     	; 0xaff2 <FMenuSettingClientIP+0x42>
    afe4:	83 30       	cpi	r24, 0x03	; 3
    afe6:	09 f4       	brne	.+2      	; 0xafea <FMenuSettingClientIP+0x3a>
    afe8:	59 c2       	rjmp	.+1202   	; 0xb49c <FMenuSettingClientIP+0x4ec>
    afea:	84 30       	cpi	r24, 0x04	; 4
    afec:	09 f0       	breq	.+2      	; 0xaff0 <FMenuSettingClientIP+0x40>
    afee:	5b c2       	rjmp	.+1206   	; 0xb4a6 <FMenuSettingClientIP+0x4f6>
    aff0:	47 c2       	rjmp	.+1166   	; 0xb480 <FMenuSettingClientIP+0x4d0>
		  case cipInit:
			   lcd_clear();
    aff2:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    aff6:	81 e0       	ldi	r24, 0x01	; 1
    aff8:	61 e0       	ldi	r22, 0x01	; 1
    affa:	43 ee       	ldi	r20, 0xE3	; 227
    affc:	52 e1       	ldi	r21, 0x12	; 18
    affe:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    b002:	87 e3       	ldi	r24, 0x37	; 55
    b004:	92 e0       	ldi	r25, 0x02	; 2
    b006:	68 e2       	ldi	r22, 0x28	; 40
    b008:	70 e0       	ldi	r23, 0x00	; 0
    b00a:	44 e0       	ldi	r20, 0x04	; 4
    b00c:	50 e0       	ldi	r21, 0x00	; 0
    b00e:	24 e4       	ldi	r18, 0x44	; 68
    b010:	32 e1       	ldi	r19, 0x12	; 18
    b012:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    b016:	8d b7       	in	r24, 0x3d	; 61
    b018:	9e b7       	in	r25, 0x3e	; 62
    b01a:	0c 97       	sbiw	r24, 0x0c	; 12
    b01c:	0f b6       	in	r0, 0x3f	; 63
    b01e:	f8 94       	cli
    b020:	9e bf       	out	0x3e, r25	; 62
    b022:	0f be       	out	0x3f, r0	; 63
    b024:	8d bf       	out	0x3d, r24	; 61
    b026:	ed b7       	in	r30, 0x3d	; 61
    b028:	fe b7       	in	r31, 0x3e	; 62
    b02a:	31 96       	adiw	r30, 0x01	; 1
    b02c:	8e 01       	movw	r16, r28
    b02e:	0f 5f       	subi	r16, 0xFF	; 255
    b030:	1f 4f       	sbci	r17, 0xFF	; 255
    b032:	ad b7       	in	r26, 0x3d	; 61
    b034:	be b7       	in	r27, 0x3e	; 62
    b036:	12 96       	adiw	r26, 0x02	; 2
    b038:	1c 93       	st	X, r17
    b03a:	0e 93       	st	-X, r16
    b03c:	11 97       	sbiw	r26, 0x01	; 1
    b03e:	82 ed       	ldi	r24, 0xD2	; 210
    b040:	92 e1       	ldi	r25, 0x12	; 18
    b042:	93 83       	std	Z+3, r25	; 0x03
    b044:	82 83       	std	Z+2, r24	; 0x02
    b046:	80 91 37 02 	lds	r24, 0x0237
    b04a:	84 83       	std	Z+4, r24	; 0x04
    b04c:	15 82       	std	Z+5, r1	; 0x05
    b04e:	80 91 38 02 	lds	r24, 0x0238
    b052:	86 83       	std	Z+6, r24	; 0x06
    b054:	17 82       	std	Z+7, r1	; 0x07
    b056:	80 91 39 02 	lds	r24, 0x0239
    b05a:	80 87       	std	Z+8, r24	; 0x08
    b05c:	11 86       	std	Z+9, r1	; 0x09
    b05e:	80 91 3a 02 	lds	r24, 0x023A
    b062:	82 87       	std	Z+10, r24	; 0x0a
    b064:	13 86       	std	Z+11, r1	; 0x0b
    b066:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    b06a:	ed b7       	in	r30, 0x3d	; 61
    b06c:	fe b7       	in	r31, 0x3e	; 62
    b06e:	3c 96       	adiw	r30, 0x0c	; 12
    b070:	0f b6       	in	r0, 0x3f	; 63
    b072:	f8 94       	cli
    b074:	fe bf       	out	0x3e, r31	; 62
    b076:	0f be       	out	0x3f, r0	; 63
    b078:	ed bf       	out	0x3d, r30	; 61
    b07a:	82 e0       	ldi	r24, 0x02	; 2
    b07c:	61 e0       	ldi	r22, 0x01	; 1
    b07e:	a8 01       	movw	r20, r16
    b080:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    b084:	83 e0       	ldi	r24, 0x03	; 3
    b086:	61 e0       	ldi	r22, 0x01	; 1
    b088:	4d eb       	ldi	r20, 0xBD	; 189
    b08a:	52 e1       	ldi	r21, 0x12	; 18
    b08c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    b090:	84 e0       	ldi	r24, 0x04	; 4
    b092:	61 e0       	ldi	r22, 0x01	; 1
    b094:	48 ea       	ldi	r20, 0xA8	; 168
    b096:	52 e1       	ldi	r21, 0x12	; 18
    b098:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
               iLoop=0;
    b09c:	10 92 36 02 	sts	0x0236, r1
    b0a0:	10 92 35 02 	sts	0x0235, r1
			   y=3,x=8;
    b0a4:	83 e0       	ldi	r24, 0x03	; 3
    b0a6:	80 93 3c 02 	sts	0x023C, r24
    b0aa:	88 e0       	ldi	r24, 0x08	; 8
    b0ac:	80 93 3d 02 	sts	0x023D, r24
			   iInput=0; iBlok=0;
    b0b0:	10 92 3b 02 	sts	0x023B, r1
    b0b4:	10 92 34 02 	sts	0x0234, r1
    b0b8:	10 92 33 02 	sts	0x0233, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    b0bc:	80 e3       	ldi	r24, 0x30	; 48
    b0be:	80 93 40 02 	sts	0x0240, r24
    b0c2:	80 93 41 02 	sts	0x0241, r24
    b0c6:	80 93 42 02 	sts	0x0242, r24
			   stClientIP=cipInputIP; 
    b0ca:	82 e0       	ldi	r24, 0x02	; 2
    b0cc:	e4 c1       	rjmp	.+968    	; 0xb496 <FMenuSettingClientIP+0x4e6>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    b0ce:	80 91 35 02 	lds	r24, 0x0235
    b0d2:	90 91 36 02 	lds	r25, 0x0236
    b0d6:	01 96       	adiw	r24, 0x01	; 1
    b0d8:	90 93 36 02 	sts	0x0236, r25
    b0dc:	80 93 35 02 	sts	0x0235, r24
			   if ((iLoop%2000)==0){
    b0e0:	60 ed       	ldi	r22, 0xD0	; 208
    b0e2:	77 e0       	ldi	r23, 0x07	; 7
    b0e4:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    b0e8:	89 2b       	or	r24, r25
    b0ea:	81 f4       	brne	.+32     	; 0xb10c <FMenuSettingClientIP+0x15c>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    b0ec:	80 91 33 02 	lds	r24, 0x0233
    b0f0:	90 91 34 02 	lds	r25, 0x0234
    b0f4:	88 0f       	add	r24, r24
    b0f6:	99 1f       	adc	r25, r25
    b0f8:	88 0f       	add	r24, r24
    b0fa:	99 1f       	adc	r25, r25
    b0fc:	60 91 3d 02 	lds	r22, 0x023D
    b100:	68 0f       	add	r22, r24
    b102:	80 91 3c 02 	lds	r24, 0x023C
    b106:	4f e5       	ldi	r20, 0x5F	; 95
    b108:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    b10c:	80 91 35 02 	lds	r24, 0x0235
    b110:	90 91 36 02 	lds	r25, 0x0236
    b114:	60 ed       	ldi	r22, 0xD0	; 208
    b116:	77 e0       	ldi	r23, 0x07	; 7
    b118:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    b11c:	88 5e       	subi	r24, 0xE8	; 232
    b11e:	93 40       	sbci	r25, 0x03	; 3
    b120:	81 f4       	brne	.+32     	; 0xb142 <FMenuSettingClientIP+0x192>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    b122:	80 91 33 02 	lds	r24, 0x0233
    b126:	90 91 34 02 	lds	r25, 0x0234
    b12a:	88 0f       	add	r24, r24
    b12c:	99 1f       	adc	r25, r25
    b12e:	88 0f       	add	r24, r24
    b130:	99 1f       	adc	r25, r25
    b132:	60 91 3d 02 	lds	r22, 0x023D
    b136:	68 0f       	add	r22, r24
    b138:	80 91 3c 02 	lds	r24, 0x023C
    b13c:	40 e2       	ldi	r20, 0x20	; 32
    b13e:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    b142:	81 e0       	ldi	r24, 0x01	; 1
    b144:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    b148:	f8 2e       	mov	r15, r24
			   keyChar=_key_btn(keyPressed);
    b14a:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    b14e:	28 2f       	mov	r18, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    b150:	80 53       	subi	r24, 0x30	; 48
    b152:	8a 30       	cpi	r24, 0x0A	; 10
    b154:	08 f0       	brcs	.+2      	; 0xb158 <FMenuSettingClientIP+0x1a8>
    b156:	d6 c0       	rjmp	.+428    	; 0xb304 <FMenuSettingClientIP+0x354>
    b158:	80 e5       	ldi	r24, 0x50	; 80
    b15a:	93 ec       	ldi	r25, 0xC3	; 195
    b15c:	01 97       	sbiw	r24, 0x01	; 1
    b15e:	f1 f7       	brne	.-4      	; 0xb15c <FMenuSettingClientIP+0x1ac>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    b160:	80 91 3b 02 	lds	r24, 0x023B
    b164:	e8 2f       	mov	r30, r24
    b166:	f0 e0       	ldi	r31, 0x00	; 0
    b168:	e0 5c       	subi	r30, 0xC0	; 192
    b16a:	fd 4f       	sbci	r31, 0xFD	; 253
    b16c:	20 83       	st	Z, r18
				   iInput++;                    
    b16e:	8f 5f       	subi	r24, 0xFF	; 255
    b170:	80 93 3b 02 	sts	0x023B, r24
				   for (i=1;i<(iInput+1);i++){
    b174:	81 e0       	ldi	r24, 0x01	; 1
    b176:	1c c0       	rjmp	.+56     	; 0xb1b0 <FMenuSettingClientIP+0x200>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    b178:	80 91 3d 02 	lds	r24, 0x023D
    b17c:	68 0f       	add	r22, r24
    b17e:	63 50       	subi	r22, 0x03	; 3
    b180:	80 91 33 02 	lds	r24, 0x0233
    b184:	90 91 34 02 	lds	r25, 0x0234
    b188:	88 0f       	add	r24, r24
    b18a:	99 1f       	adc	r25, r25
    b18c:	88 0f       	add	r24, r24
    b18e:	99 1f       	adc	r25, r25
    b190:	68 0f       	add	r22, r24
    b192:	80 91 3c 02 	lds	r24, 0x023C
    b196:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
    b19a:	e0 91 3f 02 	lds	r30, 0x023F
    b19e:	f0 e0       	ldi	r31, 0x00	; 0
    b1a0:	e1 5c       	subi	r30, 0xC1	; 193
    b1a2:	fd 4f       	sbci	r31, 0xFD	; 253
    b1a4:	80 81       	ld	r24, Z
    b1a6:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    b1aa:	80 91 3f 02 	lds	r24, 0x023F
    b1ae:	8f 5f       	subi	r24, 0xFF	; 255
    b1b0:	80 93 3f 02 	sts	0x023F, r24
    b1b4:	70 91 3b 02 	lds	r23, 0x023B
    b1b8:	60 91 3f 02 	lds	r22, 0x023F
    b1bc:	27 2f       	mov	r18, r23
    b1be:	30 e0       	ldi	r19, 0x00	; 0
    b1c0:	86 2f       	mov	r24, r22
    b1c2:	90 e0       	ldi	r25, 0x00	; 0
    b1c4:	28 17       	cp	r18, r24
    b1c6:	39 07       	cpc	r19, r25
    b1c8:	bc f6       	brge	.-82     	; 0xb178 <FMenuSettingClientIP+0x1c8>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    b1ca:	73 30       	cpi	r23, 0x03	; 3
    b1cc:	08 f4       	brcc	.+2      	; 0xb1d0 <FMenuSettingClientIP+0x220>
    b1ce:	91 c0       	rjmp	.+290    	; 0xb2f2 <FMenuSettingClientIP+0x342>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    b1d0:	40 91 33 02 	lds	r20, 0x0233
    b1d4:	50 91 34 02 	lds	r21, 0x0234
    b1d8:	fa 01       	movw	r30, r20
    b1da:	e9 5c       	subi	r30, 0xC9	; 201
    b1dc:	fd 4f       	sbci	r31, 0xFD	; 253
    b1de:	20 91 42 02 	lds	r18, 0x0242
    b1e2:	20 5d       	subi	r18, 0xD0	; 208
    b1e4:	80 91 40 02 	lds	r24, 0x0240
    b1e8:	34 e6       	ldi	r19, 0x64	; 100
    b1ea:	83 9f       	mul	r24, r19
    b1ec:	c0 01       	movw	r24, r0
    b1ee:	11 24       	eor	r1, r1
    b1f0:	28 0f       	add	r18, r24
    b1f2:	80 91 41 02 	lds	r24, 0x0241
    b1f6:	3a e0       	ldi	r19, 0x0A	; 10
    b1f8:	83 9f       	mul	r24, r19
    b1fa:	c0 01       	movw	r24, r0
    b1fc:	11 24       	eor	r1, r1
    b1fe:	28 0f       	add	r18, r24
    b200:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    b202:	80 e3       	ldi	r24, 0x30	; 48
    b204:	80 93 40 02 	sts	0x0240, r24
    b208:	80 93 41 02 	sts	0x0241, r24
    b20c:	80 93 42 02 	sts	0x0242, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    b210:	44 0f       	add	r20, r20
    b212:	55 1f       	adc	r21, r21
    b214:	44 0f       	add	r20, r20
    b216:	55 1f       	adc	r21, r21
    b218:	60 91 3d 02 	lds	r22, 0x023D
    b21c:	64 0f       	add	r22, r20
    b21e:	67 1b       	sub	r22, r23
    b220:	80 91 3c 02 	lds	r24, 0x023C
    b224:	44 ea       	ldi	r20, 0xA4	; 164
    b226:	52 e1       	ldi	r21, 0x12	; 18
    b228:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    b22c:	00 d0       	rcall	.+0      	; 0xb22e <FMenuSettingClientIP+0x27e>
    b22e:	00 d0       	rcall	.+0      	; 0xb230 <FMenuSettingClientIP+0x280>
    b230:	00 d0       	rcall	.+0      	; 0xb232 <FMenuSettingClientIP+0x282>
    b232:	ad b7       	in	r26, 0x3d	; 61
    b234:	be b7       	in	r27, 0x3e	; 62
    b236:	11 96       	adiw	r26, 0x01	; 1
    b238:	8e 01       	movw	r16, r28
    b23a:	0f 5f       	subi	r16, 0xFF	; 255
    b23c:	1f 4f       	sbci	r17, 0xFF	; 255
    b23e:	ed b7       	in	r30, 0x3d	; 61
    b240:	fe b7       	in	r31, 0x3e	; 62
    b242:	12 83       	std	Z+2, r17	; 0x02
    b244:	01 83       	std	Z+1, r16	; 0x01
    b246:	81 ea       	ldi	r24, 0xA1	; 161
    b248:	92 e1       	ldi	r25, 0x12	; 18
    b24a:	13 96       	adiw	r26, 0x03	; 3
    b24c:	9c 93       	st	X, r25
    b24e:	8e 93       	st	-X, r24
    b250:	12 97       	sbiw	r26, 0x02	; 2
    b252:	e0 91 33 02 	lds	r30, 0x0233
    b256:	f0 91 34 02 	lds	r31, 0x0234
    b25a:	e9 5c       	subi	r30, 0xC9	; 201
    b25c:	fd 4f       	sbci	r31, 0xFD	; 253
    b25e:	80 81       	ld	r24, Z
    b260:	14 96       	adiw	r26, 0x04	; 4
    b262:	8c 93       	st	X, r24
    b264:	14 97       	sbiw	r26, 0x04	; 4
    b266:	15 96       	adiw	r26, 0x05	; 5
    b268:	1c 92       	st	X, r1
    b26a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    b26e:	f8 01       	movw	r30, r16
    b270:	01 90       	ld	r0, Z+
    b272:	00 20       	and	r0, r0
    b274:	e9 f7       	brne	.-6      	; 0xb270 <FMenuSettingClientIP+0x2c0>
    b276:	31 97       	sbiw	r30, 0x01	; 1
    b278:	e0 1b       	sub	r30, r16
    b27a:	f1 0b       	sbc	r31, r17
    b27c:	8d b7       	in	r24, 0x3d	; 61
    b27e:	9e b7       	in	r25, 0x3e	; 62
    b280:	06 96       	adiw	r24, 0x06	; 6
    b282:	0f b6       	in	r0, 0x3f	; 63
    b284:	f8 94       	cli
    b286:	9e bf       	out	0x3e, r25	; 62
    b288:	0f be       	out	0x3f, r0	; 63
    b28a:	8d bf       	out	0x3d, r24	; 61
    b28c:	60 91 3d 02 	lds	r22, 0x023D
    b290:	6f 5f       	subi	r22, 0xFF	; 255
    b292:	80 91 33 02 	lds	r24, 0x0233
    b296:	90 91 34 02 	lds	r25, 0x0234
    b29a:	88 0f       	add	r24, r24
    b29c:	99 1f       	adc	r25, r25
    b29e:	88 0f       	add	r24, r24
    b2a0:	99 1f       	adc	r25, r25
    b2a2:	68 0f       	add	r22, r24
    b2a4:	6e 1b       	sub	r22, r30
    b2a6:	80 91 3c 02 	lds	r24, 0x023C
    b2aa:	a8 01       	movw	r20, r16
    b2ac:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    b2b0:	80 91 33 02 	lds	r24, 0x0233
    b2b4:	90 91 34 02 	lds	r25, 0x0234
    b2b8:	00 97       	sbiw	r24, 0x00	; 0
    b2ba:	81 f0       	breq	.+32     	; 0xb2dc <FMenuSettingClientIP+0x32c>
    b2bc:	60 91 3d 02 	lds	r22, 0x023D
    b2c0:	6f 5f       	subi	r22, 0xFF	; 255
    b2c2:	81 50       	subi	r24, 0x01	; 1
    b2c4:	90 4c       	sbci	r25, 0xC0	; 192
    b2c6:	88 0f       	add	r24, r24
    b2c8:	99 1f       	adc	r25, r25
    b2ca:	88 0f       	add	r24, r24
    b2cc:	99 1f       	adc	r25, r25
    b2ce:	68 0f       	add	r22, r24
    b2d0:	80 91 3c 02 	lds	r24, 0x023C
    b2d4:	4f e9       	ldi	r20, 0x9F	; 159
    b2d6:	52 e1       	ldi	r21, 0x12	; 18
    b2d8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					   iInput=0;
    b2dc:	10 92 3b 02 	sts	0x023B, r1
					   iBlok++;
    b2e0:	80 91 33 02 	lds	r24, 0x0233
    b2e4:	90 91 34 02 	lds	r25, 0x0234
    b2e8:	01 96       	adiw	r24, 0x01	; 1
    b2ea:	90 93 34 02 	sts	0x0234, r25
    b2ee:	80 93 33 02 	sts	0x0233, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    b2f2:	80 91 33 02 	lds	r24, 0x0233
    b2f6:	90 91 34 02 	lds	r25, 0x0234
    b2fa:	04 97       	sbiw	r24, 0x04	; 4
    b2fc:	18 f0       	brcs	.+6      	; 0xb304 <FMenuSettingClientIP+0x354>
    b2fe:	84 e0       	ldi	r24, 0x04	; 4
    b300:	80 93 59 01 	sts	0x0159, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    b304:	97 ee       	ldi	r25, 0xE7	; 231
    b306:	f9 16       	cp	r15, r25
    b308:	09 f4       	brne	.+2      	; 0xb30c <FMenuSettingClientIP+0x35c>
    b30a:	c4 c0       	rjmp	.+392    	; 0xb494 <FMenuSettingClientIP+0x4e4>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    b30c:	a7 eb       	ldi	r26, 0xB7	; 183
    b30e:	fa 16       	cp	r15, r26
    b310:	09 f0       	breq	.+2      	; 0xb314 <FMenuSettingClientIP+0x364>
    b312:	c9 c0       	rjmp	.+402    	; 0xb4a6 <FMenuSettingClientIP+0x4f6>
			       //NextInput
			       if (iBlok<4){
    b314:	40 91 33 02 	lds	r20, 0x0233
    b318:	50 91 34 02 	lds	r21, 0x0234
    b31c:	44 30       	cpi	r20, 0x04	; 4
    b31e:	51 05       	cpc	r21, r1
    b320:	08 f0       	brcs	.+2      	; 0xb324 <FMenuSettingClientIP+0x374>
    b322:	a6 c0       	rjmp	.+332    	; 0xb470 <FMenuSettingClientIP+0x4c0>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    b324:	80 91 3b 02 	lds	r24, 0x023B
    b328:	81 30       	cpi	r24, 0x01	; 1
    b32a:	41 f4       	brne	.+16     	; 0xb33c <FMenuSettingClientIP+0x38c>
    b32c:	fa 01       	movw	r30, r20
    b32e:	e9 5c       	subi	r30, 0xC9	; 201
    b330:	fd 4f       	sbci	r31, 0xFD	; 253
    b332:	80 91 40 02 	lds	r24, 0x0240
    b336:	80 53       	subi	r24, 0x30	; 48
    b338:	80 83       	st	Z, r24
    b33a:	22 c0       	rjmp	.+68     	; 0xb380 <FMenuSettingClientIP+0x3d0>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    b33c:	82 30       	cpi	r24, 0x02	; 2
    b33e:	49 f4       	brne	.+18     	; 0xb352 <FMenuSettingClientIP+0x3a2>
    b340:	fa 01       	movw	r30, r20
    b342:	e9 5c       	subi	r30, 0xC9	; 201
    b344:	fd 4f       	sbci	r31, 0xFD	; 253
    b346:	20 91 41 02 	lds	r18, 0x0241
    b34a:	20 51       	subi	r18, 0x10	; 16
    b34c:	80 91 40 02 	lds	r24, 0x0240
    b350:	11 c0       	rjmp	.+34     	; 0xb374 <FMenuSettingClientIP+0x3c4>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    b352:	83 30       	cpi	r24, 0x03	; 3
    b354:	a9 f4       	brne	.+42     	; 0xb380 <FMenuSettingClientIP+0x3d0>
    b356:	fa 01       	movw	r30, r20
    b358:	e9 5c       	subi	r30, 0xC9	; 201
    b35a:	fd 4f       	sbci	r31, 0xFD	; 253
    b35c:	20 91 42 02 	lds	r18, 0x0242
    b360:	20 5d       	subi	r18, 0xD0	; 208
    b362:	80 91 40 02 	lds	r24, 0x0240
    b366:	34 e6       	ldi	r19, 0x64	; 100
    b368:	83 9f       	mul	r24, r19
    b36a:	c0 01       	movw	r24, r0
    b36c:	11 24       	eor	r1, r1
    b36e:	28 0f       	add	r18, r24
    b370:	80 91 41 02 	lds	r24, 0x0241
    b374:	3a e0       	ldi	r19, 0x0A	; 10
    b376:	83 9f       	mul	r24, r19
    b378:	c0 01       	movw	r24, r0
    b37a:	11 24       	eor	r1, r1
    b37c:	28 0f       	add	r18, r24
    b37e:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    b380:	80 e3       	ldi	r24, 0x30	; 48
    b382:	80 93 40 02 	sts	0x0240, r24
    b386:	80 93 41 02 	sts	0x0241, r24
    b38a:	80 93 42 02 	sts	0x0242, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    b38e:	60 91 3d 02 	lds	r22, 0x023D
    b392:	63 50       	subi	r22, 0x03	; 3
    b394:	44 0f       	add	r20, r20
    b396:	55 1f       	adc	r21, r21
    b398:	44 0f       	add	r20, r20
    b39a:	55 1f       	adc	r21, r21
    b39c:	64 0f       	add	r22, r20
    b39e:	80 91 3c 02 	lds	r24, 0x023C
    b3a2:	4b e9       	ldi	r20, 0x9B	; 155
    b3a4:	52 e1       	ldi	r21, 0x12	; 18
    b3a6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    b3aa:	00 d0       	rcall	.+0      	; 0xb3ac <FMenuSettingClientIP+0x3fc>
    b3ac:	00 d0       	rcall	.+0      	; 0xb3ae <FMenuSettingClientIP+0x3fe>
    b3ae:	00 d0       	rcall	.+0      	; 0xb3b0 <FMenuSettingClientIP+0x400>
    b3b0:	ad b7       	in	r26, 0x3d	; 61
    b3b2:	be b7       	in	r27, 0x3e	; 62
    b3b4:	11 96       	adiw	r26, 0x01	; 1
    b3b6:	8e 01       	movw	r16, r28
    b3b8:	0f 5f       	subi	r16, 0xFF	; 255
    b3ba:	1f 4f       	sbci	r17, 0xFF	; 255
    b3bc:	ed b7       	in	r30, 0x3d	; 61
    b3be:	fe b7       	in	r31, 0x3e	; 62
    b3c0:	12 83       	std	Z+2, r17	; 0x02
    b3c2:	01 83       	std	Z+1, r16	; 0x01
    b3c4:	88 e9       	ldi	r24, 0x98	; 152
    b3c6:	92 e1       	ldi	r25, 0x12	; 18
    b3c8:	13 96       	adiw	r26, 0x03	; 3
    b3ca:	9c 93       	st	X, r25
    b3cc:	8e 93       	st	-X, r24
    b3ce:	12 97       	sbiw	r26, 0x02	; 2
    b3d0:	e0 91 33 02 	lds	r30, 0x0233
    b3d4:	f0 91 34 02 	lds	r31, 0x0234
    b3d8:	e9 5c       	subi	r30, 0xC9	; 201
    b3da:	fd 4f       	sbci	r31, 0xFD	; 253
    b3dc:	80 81       	ld	r24, Z
    b3de:	14 96       	adiw	r26, 0x04	; 4
    b3e0:	8c 93       	st	X, r24
    b3e2:	14 97       	sbiw	r26, 0x04	; 4
    b3e4:	15 96       	adiw	r26, 0x05	; 5
    b3e6:	1c 92       	st	X, r1
    b3e8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    b3ec:	f8 01       	movw	r30, r16
    b3ee:	01 90       	ld	r0, Z+
    b3f0:	00 20       	and	r0, r0
    b3f2:	e9 f7       	brne	.-6      	; 0xb3ee <FMenuSettingClientIP+0x43e>
    b3f4:	31 97       	sbiw	r30, 0x01	; 1
    b3f6:	e0 1b       	sub	r30, r16
    b3f8:	f1 0b       	sbc	r31, r17
    b3fa:	8d b7       	in	r24, 0x3d	; 61
    b3fc:	9e b7       	in	r25, 0x3e	; 62
    b3fe:	06 96       	adiw	r24, 0x06	; 6
    b400:	0f b6       	in	r0, 0x3f	; 63
    b402:	f8 94       	cli
    b404:	9e bf       	out	0x3e, r25	; 62
    b406:	0f be       	out	0x3f, r0	; 63
    b408:	8d bf       	out	0x3d, r24	; 61
    b40a:	60 91 3d 02 	lds	r22, 0x023D
    b40e:	6f 5f       	subi	r22, 0xFF	; 255
    b410:	80 91 33 02 	lds	r24, 0x0233
    b414:	90 91 34 02 	lds	r25, 0x0234
    b418:	88 0f       	add	r24, r24
    b41a:	99 1f       	adc	r25, r25
    b41c:	88 0f       	add	r24, r24
    b41e:	99 1f       	adc	r25, r25
    b420:	68 0f       	add	r22, r24
    b422:	6e 1b       	sub	r22, r30
    b424:	80 91 3c 02 	lds	r24, 0x023C
    b428:	a8 01       	movw	r20, r16
    b42a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    b42e:	80 91 33 02 	lds	r24, 0x0233
    b432:	90 91 34 02 	lds	r25, 0x0234
    b436:	00 97       	sbiw	r24, 0x00	; 0
    b438:	81 f0       	breq	.+32     	; 0xb45a <FMenuSettingClientIP+0x4aa>
    b43a:	60 91 3d 02 	lds	r22, 0x023D
    b43e:	6f 5f       	subi	r22, 0xFF	; 255
    b440:	81 50       	subi	r24, 0x01	; 1
    b442:	90 4c       	sbci	r25, 0xC0	; 192
    b444:	88 0f       	add	r24, r24
    b446:	99 1f       	adc	r25, r25
    b448:	88 0f       	add	r24, r24
    b44a:	99 1f       	adc	r25, r25
    b44c:	68 0f       	add	r22, r24
    b44e:	80 91 3c 02 	lds	r24, 0x023C
    b452:	46 e9       	ldi	r20, 0x96	; 150
    b454:	52 e1       	ldi	r21, 0x12	; 18
    b456:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				       iInput=0;
    b45a:	10 92 3b 02 	sts	0x023B, r1
					   iBlok++;	   
    b45e:	80 91 33 02 	lds	r24, 0x0233
    b462:	90 91 34 02 	lds	r25, 0x0234
    b466:	01 96       	adiw	r24, 0x01	; 1
    b468:	90 93 34 02 	sts	0x0234, r25
    b46c:	80 93 33 02 	sts	0x0233, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    b470:	80 91 33 02 	lds	r24, 0x0233
    b474:	90 91 34 02 	lds	r25, 0x0234
    b478:	04 97       	sbiw	r24, 0x04	; 4
    b47a:	a8 f0       	brcs	.+42     	; 0xb4a6 <FMenuSettingClientIP+0x4f6>
    b47c:	84 e0       	ldi	r24, 0x04	; 4
    b47e:	0b c0       	rjmp	.+22     	; 0xb496 <FMenuSettingClientIP+0x4e6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    b480:	88 e2       	ldi	r24, 0x28	; 40
    b482:	90 e0       	ldi	r25, 0x00	; 0
    b484:	67 e3       	ldi	r22, 0x37	; 55
    b486:	72 e0       	ldi	r23, 0x02	; 2
    b488:	44 e0       	ldi	r20, 0x04	; 4
    b48a:	50 e0       	ldi	r21, 0x00	; 0
    b48c:	2c e4       	ldi	r18, 0x4C	; 76
    b48e:	32 e1       	ldi	r19, 0x12	; 18
    b490:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    b494:	83 e0       	ldi	r24, 0x03	; 3
    b496:	80 93 59 01 	sts	0x0159, r24
    b49a:	05 c0       	rjmp	.+10     	; 0xb4a6 <FMenuSettingClientIP+0x4f6>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    b49c:	81 e0       	ldi	r24, 0x01	; 1
    b49e:	80 93 59 01 	sts	0x0159, r24
		       Result=MENU_DONE;
    b4a2:	80 93 3e 02 	sts	0x023E, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    b4a6:	80 91 3e 02 	lds	r24, 0x023E
    b4aa:	64 96       	adiw	r28, 0x14	; 20
    b4ac:	0f b6       	in	r0, 0x3f	; 63
    b4ae:	f8 94       	cli
    b4b0:	de bf       	out	0x3e, r29	; 62
    b4b2:	0f be       	out	0x3f, r0	; 63
    b4b4:	cd bf       	out	0x3d, r28	; 61
    b4b6:	cf 91       	pop	r28
    b4b8:	df 91       	pop	r29
    b4ba:	1f 91       	pop	r17
    b4bc:	0f 91       	pop	r16
    b4be:	ff 90       	pop	r15
    b4c0:	08 95       	ret

0000b4c2 <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    b4c2:	df 93       	push	r29
    b4c4:	cf 93       	push	r28
    b4c6:	cd b7       	in	r28, 0x3d	; 61
    b4c8:	de b7       	in	r29, 0x3e	; 62
    b4ca:	28 97       	sbiw	r28, 0x08	; 8
    b4cc:	0f b6       	in	r0, 0x3f	; 63
    b4ce:	f8 94       	cli
    b4d0:	de bf       	out	0x3e, r29	; 62
    b4d2:	0f be       	out	0x3f, r0	; 63
    b4d4:	cd bf       	out	0x3d, r28	; 61
    b4d6:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    b4d8:	80 91 83 01 	lds	r24, 0x0183
    b4dc:	88 23       	and	r24, r24
    b4de:	a1 f4       	brne	.+40     	; 0xb508 <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    b4e0:	3d e2       	ldi	r19, 0x2D	; 45
    b4e2:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    b4e4:	80 e6       	ldi	r24, 0x60	; 96
    b4e6:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    b4e8:	2c e7       	ldi	r18, 0x7C	; 124
    b4ea:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    b4ec:	9f e2       	ldi	r25, 0x2F	; 47
    b4ee:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    b4f0:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    b4f2:	84 ea       	ldi	r24, 0xA4	; 164
    b4f4:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    b4f6:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    b4f8:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    b4fa:	47 70       	andi	r20, 0x07	; 7
    b4fc:	fe 01       	movw	r30, r28
    b4fe:	e4 0f       	add	r30, r20
    b500:	f1 1d       	adc	r31, r1
    b502:	85 2f       	mov	r24, r21
    b504:	41 81       	ldd	r20, Z+1	; 0x01
    b506:	08 c0       	rjmp	.+16     	; 0xb518 <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    b508:	80 91 83 01 	lds	r24, 0x0183
    b50c:	81 30       	cpi	r24, 0x01	; 1
    b50e:	31 f4       	brne	.+12     	; 0xb51c <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    b510:	10 92 83 01 	sts	0x0183, r1
	          lcd_put(x,y,'X');     
    b514:	85 2f       	mov	r24, r21
    b516:	48 e5       	ldi	r20, 0x58	; 88
    b518:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			  }

}
    b51c:	28 96       	adiw	r28, 0x08	; 8
    b51e:	0f b6       	in	r0, 0x3f	; 63
    b520:	f8 94       	cli
    b522:	de bf       	out	0x3e, r29	; 62
    b524:	0f be       	out	0x3f, r0	; 63
    b526:	cd bf       	out	0x3d, r28	; 61
    b528:	cf 91       	pop	r28
    b52a:	df 91       	pop	r29
    b52c:	08 95       	ret

0000b52e <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    b52e:	0f 93       	push	r16
    b530:	1f 93       	push	r17
    b532:	df 93       	push	r29
    b534:	cf 93       	push	r28
    b536:	cd b7       	in	r28, 0x3d	; 61
    b538:	de b7       	in	r29, 0x3e	; 62
    b53a:	6a 97       	sbiw	r28, 0x1a	; 26
    b53c:	0f b6       	in	r0, 0x3f	; 63
    b53e:	f8 94       	cli
    b540:	de bf       	out	0x3e, r29	; 62
    b542:	0f be       	out	0x3f, r0	; 63
    b544:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
	   char i,lcdteks[20];
	   char KeyChar,Addr=0,PPoolingSetting[6];
     
	 Result=MENU_NONE;
     switch(stPumpPooling){
    b546:	80 91 1b 02 	lds	r24, 0x021B
    b54a:	82 30       	cpi	r24, 0x02	; 2
    b54c:	09 f4       	brne	.+2      	; 0xb550 <FSettingPumpPooling+0x22>
    b54e:	1b c1       	rjmp	.+566    	; 0xb786 <FSettingPumpPooling+0x258>
    b550:	83 30       	cpi	r24, 0x03	; 3
    b552:	30 f4       	brcc	.+12     	; 0xb560 <FSettingPumpPooling+0x32>
    b554:	88 23       	and	r24, r24
    b556:	59 f0       	breq	.+22     	; 0xb56e <FSettingPumpPooling+0x40>
    b558:	81 30       	cpi	r24, 0x01	; 1
    b55a:	09 f0       	breq	.+2      	; 0xb55e <FSettingPumpPooling+0x30>
    b55c:	17 c2       	rjmp	.+1070   	; 0xb98c <FSettingPumpPooling+0x45e>
    b55e:	09 c1       	rjmp	.+530    	; 0xb772 <FSettingPumpPooling+0x244>
    b560:	83 30       	cpi	r24, 0x03	; 3
    b562:	09 f4       	brne	.+2      	; 0xb566 <FSettingPumpPooling+0x38>
    b564:	04 c2       	rjmp	.+1032   	; 0xb96e <FSettingPumpPooling+0x440>
    b566:	84 30       	cpi	r24, 0x04	; 4
    b568:	09 f0       	breq	.+2      	; 0xb56c <FSettingPumpPooling+0x3e>
    b56a:	10 c2       	rjmp	.+1056   	; 0xb98c <FSettingPumpPooling+0x45e>
    b56c:	0b c2       	rjmp	.+1046   	; 0xb984 <FSettingPumpPooling+0x456>
	 case ppInitMenu:
          lcd_clear();
    b56e:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    b572:	20 e0       	ldi	r18, 0x00	; 0
    b574:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    b576:	ae 01       	movw	r20, r28
    b578:	4f 5f       	subi	r20, 0xFF	; 255
    b57a:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b57c:	e1 99       	sbic	0x1c, 1	; 28
    b57e:	fe cf       	rjmp	.-4      	; 0xb57c <FSettingPumpPooling+0x4e>
    b580:	c9 01       	movw	r24, r18
    b582:	8c 5b       	subi	r24, 0xBC	; 188
    b584:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b586:	9f bb       	out	0x1f, r25	; 31
    b588:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b58a:	e0 9a       	sbi	0x1c, 0	; 28
    b58c:	8d b3       	in	r24, 0x1d	; 29
    b58e:	fa 01       	movw	r30, r20
    b590:	e2 0f       	add	r30, r18
    b592:	f3 1f       	adc	r31, r19
    b594:	80 83       	st	Z, r24
    b596:	2f 5f       	subi	r18, 0xFF	; 255
    b598:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 Result=MENU_NONE;
     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    b59a:	26 30       	cpi	r18, 0x06	; 6
    b59c:	31 05       	cpc	r19, r1
    b59e:	71 f7       	brne	.-36     	; 0xb57c <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    b5a0:	00 d0       	rcall	.+0      	; 0xb5a2 <FSettingPumpPooling+0x74>
    b5a2:	00 d0       	rcall	.+0      	; 0xb5a4 <FSettingPumpPooling+0x76>
    b5a4:	00 d0       	rcall	.+0      	; 0xb5a6 <FSettingPumpPooling+0x78>
    b5a6:	ed b7       	in	r30, 0x3d	; 61
    b5a8:	fe b7       	in	r31, 0x3e	; 62
    b5aa:	31 96       	adiw	r30, 0x01	; 1
    b5ac:	8e 01       	movw	r16, r28
    b5ae:	09 5f       	subi	r16, 0xF9	; 249
    b5b0:	1f 4f       	sbci	r17, 0xFF	; 255
    b5b2:	ad b7       	in	r26, 0x3d	; 61
    b5b4:	be b7       	in	r27, 0x3e	; 62
    b5b6:	12 96       	adiw	r26, 0x02	; 2
    b5b8:	1c 93       	st	X, r17
    b5ba:	0e 93       	st	-X, r16
    b5bc:	11 97       	sbiw	r26, 0x01	; 1
    b5be:	8a e1       	ldi	r24, 0x1A	; 26
    b5c0:	9d e0       	ldi	r25, 0x0D	; 13
    b5c2:	93 83       	std	Z+3, r25	; 0x03
    b5c4:	82 83       	std	Z+2, r24	; 0x02
    b5c6:	89 81       	ldd	r24, Y+1	; 0x01
    b5c8:	84 83       	std	Z+4, r24	; 0x04
    b5ca:	15 82       	std	Z+5, r1	; 0x05
    b5cc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    b5d0:	ed b7       	in	r30, 0x3d	; 61
    b5d2:	fe b7       	in	r31, 0x3e	; 62
    b5d4:	36 96       	adiw	r30, 0x06	; 6
    b5d6:	0f b6       	in	r0, 0x3f	; 63
    b5d8:	f8 94       	cli
    b5da:	fe bf       	out	0x3e, r31	; 62
    b5dc:	0f be       	out	0x3f, r0	; 63
    b5de:	ed bf       	out	0x3d, r30	; 61
    b5e0:	81 e0       	ldi	r24, 0x01	; 1
    b5e2:	61 e0       	ldi	r22, 0x01	; 1
    b5e4:	a8 01       	movw	r20, r16
    b5e6:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    b5ea:	00 d0       	rcall	.+0      	; 0xb5ec <FSettingPumpPooling+0xbe>
    b5ec:	00 d0       	rcall	.+0      	; 0xb5ee <FSettingPumpPooling+0xc0>
    b5ee:	00 d0       	rcall	.+0      	; 0xb5f0 <FSettingPumpPooling+0xc2>
    b5f0:	ed b7       	in	r30, 0x3d	; 61
    b5f2:	fe b7       	in	r31, 0x3e	; 62
    b5f4:	31 96       	adiw	r30, 0x01	; 1
    b5f6:	ad b7       	in	r26, 0x3d	; 61
    b5f8:	be b7       	in	r27, 0x3e	; 62
    b5fa:	12 96       	adiw	r26, 0x02	; 2
    b5fc:	1c 93       	st	X, r17
    b5fe:	0e 93       	st	-X, r16
    b600:	11 97       	sbiw	r26, 0x01	; 1
    b602:	8d e0       	ldi	r24, 0x0D	; 13
    b604:	9d e0       	ldi	r25, 0x0D	; 13
    b606:	93 83       	std	Z+3, r25	; 0x03
    b608:	82 83       	std	Z+2, r24	; 0x02
    b60a:	8a 81       	ldd	r24, Y+2	; 0x02
    b60c:	84 83       	std	Z+4, r24	; 0x04
    b60e:	15 82       	std	Z+5, r1	; 0x05
    b610:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    b614:	ed b7       	in	r30, 0x3d	; 61
    b616:	fe b7       	in	r31, 0x3e	; 62
    b618:	36 96       	adiw	r30, 0x06	; 6
    b61a:	0f b6       	in	r0, 0x3f	; 63
    b61c:	f8 94       	cli
    b61e:	fe bf       	out	0x3e, r31	; 62
    b620:	0f be       	out	0x3f, r0	; 63
    b622:	ed bf       	out	0x3d, r30	; 61
    b624:	82 e0       	ldi	r24, 0x02	; 2
    b626:	61 e0       	ldi	r22, 0x01	; 1
    b628:	a8 01       	movw	r20, r16
    b62a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    b62e:	00 d0       	rcall	.+0      	; 0xb630 <FSettingPumpPooling+0x102>
    b630:	00 d0       	rcall	.+0      	; 0xb632 <FSettingPumpPooling+0x104>
    b632:	00 d0       	rcall	.+0      	; 0xb634 <FSettingPumpPooling+0x106>
    b634:	ed b7       	in	r30, 0x3d	; 61
    b636:	fe b7       	in	r31, 0x3e	; 62
    b638:	31 96       	adiw	r30, 0x01	; 1
    b63a:	ad b7       	in	r26, 0x3d	; 61
    b63c:	be b7       	in	r27, 0x3e	; 62
    b63e:	12 96       	adiw	r26, 0x02	; 2
    b640:	1c 93       	st	X, r17
    b642:	0e 93       	st	-X, r16
    b644:	11 97       	sbiw	r26, 0x01	; 1
    b646:	80 e0       	ldi	r24, 0x00	; 0
    b648:	9d e0       	ldi	r25, 0x0D	; 13
    b64a:	93 83       	std	Z+3, r25	; 0x03
    b64c:	82 83       	std	Z+2, r24	; 0x02
    b64e:	8b 81       	ldd	r24, Y+3	; 0x03
    b650:	84 83       	std	Z+4, r24	; 0x04
    b652:	15 82       	std	Z+5, r1	; 0x05
    b654:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    b658:	ed b7       	in	r30, 0x3d	; 61
    b65a:	fe b7       	in	r31, 0x3e	; 62
    b65c:	36 96       	adiw	r30, 0x06	; 6
    b65e:	0f b6       	in	r0, 0x3f	; 63
    b660:	f8 94       	cli
    b662:	fe bf       	out	0x3e, r31	; 62
    b664:	0f be       	out	0x3f, r0	; 63
    b666:	ed bf       	out	0x3d, r30	; 61
    b668:	83 e0       	ldi	r24, 0x03	; 3
    b66a:	61 e0       	ldi	r22, 0x01	; 1
    b66c:	a8 01       	movw	r20, r16
    b66e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    b672:	00 d0       	rcall	.+0      	; 0xb674 <FSettingPumpPooling+0x146>
    b674:	00 d0       	rcall	.+0      	; 0xb676 <FSettingPumpPooling+0x148>
    b676:	00 d0       	rcall	.+0      	; 0xb678 <FSettingPumpPooling+0x14a>
    b678:	ed b7       	in	r30, 0x3d	; 61
    b67a:	fe b7       	in	r31, 0x3e	; 62
    b67c:	31 96       	adiw	r30, 0x01	; 1
    b67e:	ad b7       	in	r26, 0x3d	; 61
    b680:	be b7       	in	r27, 0x3e	; 62
    b682:	12 96       	adiw	r26, 0x02	; 2
    b684:	1c 93       	st	X, r17
    b686:	0e 93       	st	-X, r16
    b688:	11 97       	sbiw	r26, 0x01	; 1
    b68a:	83 ef       	ldi	r24, 0xF3	; 243
    b68c:	9c e0       	ldi	r25, 0x0C	; 12
    b68e:	93 83       	std	Z+3, r25	; 0x03
    b690:	82 83       	std	Z+2, r24	; 0x02
    b692:	8c 81       	ldd	r24, Y+4	; 0x04
    b694:	84 83       	std	Z+4, r24	; 0x04
    b696:	15 82       	std	Z+5, r1	; 0x05
    b698:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    b69c:	ed b7       	in	r30, 0x3d	; 61
    b69e:	fe b7       	in	r31, 0x3e	; 62
    b6a0:	36 96       	adiw	r30, 0x06	; 6
    b6a2:	0f b6       	in	r0, 0x3f	; 63
    b6a4:	f8 94       	cli
    b6a6:	fe bf       	out	0x3e, r31	; 62
    b6a8:	0f be       	out	0x3f, r0	; 63
    b6aa:	ed bf       	out	0x3d, r30	; 61
    b6ac:	84 e0       	ldi	r24, 0x04	; 4
    b6ae:	61 e0       	ldi	r22, 0x01	; 1
    b6b0:	a8 01       	movw	r20, r16
    b6b2:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    b6b6:	00 d0       	rcall	.+0      	; 0xb6b8 <FSettingPumpPooling+0x18a>
    b6b8:	00 d0       	rcall	.+0      	; 0xb6ba <FSettingPumpPooling+0x18c>
    b6ba:	00 d0       	rcall	.+0      	; 0xb6bc <FSettingPumpPooling+0x18e>
    b6bc:	ed b7       	in	r30, 0x3d	; 61
    b6be:	fe b7       	in	r31, 0x3e	; 62
    b6c0:	31 96       	adiw	r30, 0x01	; 1
    b6c2:	ad b7       	in	r26, 0x3d	; 61
    b6c4:	be b7       	in	r27, 0x3e	; 62
    b6c6:	12 96       	adiw	r26, 0x02	; 2
    b6c8:	1c 93       	st	X, r17
    b6ca:	0e 93       	st	-X, r16
    b6cc:	11 97       	sbiw	r26, 0x01	; 1
    b6ce:	8a ee       	ldi	r24, 0xEA	; 234
    b6d0:	9c e0       	ldi	r25, 0x0C	; 12
    b6d2:	93 83       	std	Z+3, r25	; 0x03
    b6d4:	82 83       	std	Z+2, r24	; 0x02
    b6d6:	8d 81       	ldd	r24, Y+5	; 0x05
    b6d8:	84 83       	std	Z+4, r24	; 0x04
    b6da:	15 82       	std	Z+5, r1	; 0x05
    b6dc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    b6e0:	ed b7       	in	r30, 0x3d	; 61
    b6e2:	fe b7       	in	r31, 0x3e	; 62
    b6e4:	36 96       	adiw	r30, 0x06	; 6
    b6e6:	0f b6       	in	r0, 0x3f	; 63
    b6e8:	f8 94       	cli
    b6ea:	fe bf       	out	0x3e, r31	; 62
    b6ec:	0f be       	out	0x3f, r0	; 63
    b6ee:	ed bf       	out	0x3d, r30	; 61
    b6f0:	81 e0       	ldi	r24, 0x01	; 1
    b6f2:	6d e0       	ldi	r22, 0x0D	; 13
    b6f4:	a8 01       	movw	r20, r16
    b6f6:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    b6fa:	00 d0       	rcall	.+0      	; 0xb6fc <FSettingPumpPooling+0x1ce>
    b6fc:	00 d0       	rcall	.+0      	; 0xb6fe <FSettingPumpPooling+0x1d0>
    b6fe:	00 d0       	rcall	.+0      	; 0xb700 <FSettingPumpPooling+0x1d2>
    b700:	ed b7       	in	r30, 0x3d	; 61
    b702:	fe b7       	in	r31, 0x3e	; 62
    b704:	31 96       	adiw	r30, 0x01	; 1
    b706:	ad b7       	in	r26, 0x3d	; 61
    b708:	be b7       	in	r27, 0x3e	; 62
    b70a:	12 96       	adiw	r26, 0x02	; 2
    b70c:	1c 93       	st	X, r17
    b70e:	0e 93       	st	-X, r16
    b710:	11 97       	sbiw	r26, 0x01	; 1
    b712:	81 ee       	ldi	r24, 0xE1	; 225
    b714:	9c e0       	ldi	r25, 0x0C	; 12
    b716:	93 83       	std	Z+3, r25	; 0x03
    b718:	82 83       	std	Z+2, r24	; 0x02
    b71a:	8e 81       	ldd	r24, Y+6	; 0x06
    b71c:	84 83       	std	Z+4, r24	; 0x04
    b71e:	15 82       	std	Z+5, r1	; 0x05
    b720:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    b724:	ed b7       	in	r30, 0x3d	; 61
    b726:	fe b7       	in	r31, 0x3e	; 62
    b728:	36 96       	adiw	r30, 0x06	; 6
    b72a:	0f b6       	in	r0, 0x3f	; 63
    b72c:	f8 94       	cli
    b72e:	fe bf       	out	0x3e, r31	; 62
    b730:	0f be       	out	0x3f, r0	; 63
    b732:	ed bf       	out	0x3d, r30	; 61
    b734:	82 e0       	ldi	r24, 0x02	; 2
    b736:	6d e0       	ldi	r22, 0x0D	; 13
    b738:	a8 01       	movw	r20, r16
    b73a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    b73e:	00 d0       	rcall	.+0      	; 0xb740 <FSettingPumpPooling+0x212>
    b740:	00 d0       	rcall	.+0      	; 0xb742 <FSettingPumpPooling+0x214>
    b742:	ad b7       	in	r26, 0x3d	; 61
    b744:	be b7       	in	r27, 0x3e	; 62
    b746:	12 96       	adiw	r26, 0x02	; 2
    b748:	1c 93       	st	X, r17
    b74a:	0e 93       	st	-X, r16
    b74c:	11 97       	sbiw	r26, 0x01	; 1
    b74e:	89 ed       	ldi	r24, 0xD9	; 217
    b750:	9c e0       	ldi	r25, 0x0C	; 12
    b752:	14 96       	adiw	r26, 0x04	; 4
    b754:	9c 93       	st	X, r25
    b756:	8e 93       	st	-X, r24
    b758:	13 97       	sbiw	r26, 0x03	; 3
    b75a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    b75e:	0f 90       	pop	r0
    b760:	0f 90       	pop	r0
    b762:	0f 90       	pop	r0
    b764:	0f 90       	pop	r0
    b766:	84 e0       	ldi	r24, 0x04	; 4
    b768:	6d e0       	ldi	r22, 0x0D	; 13
    b76a:	a8 01       	movw	r20, r16
    b76c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    b770:	08 c0       	rjmp	.+16     	; 0xb782 <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    b772:	10 92 81 01 	sts	0x0181, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    b776:	83 e0       	ldi	r24, 0x03	; 3
    b778:	6e e0       	ldi	r22, 0x0E	; 14
    b77a:	40 91 80 01 	lds	r20, 0x0180
    b77e:	0e 94 61 5a 	call	0xb4c2	; 0xb4c2 <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    b782:	82 e0       	ldi	r24, 0x02	; 2
    b784:	f1 c0       	rjmp	.+482    	; 0xb968 <FSettingPumpPooling+0x43a>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    b786:	80 91 81 01 	lds	r24, 0x0181
    b78a:	81 30       	cpi	r24, 0x01	; 1
    b78c:	11 f4       	brne	.+4      	; 0xb792 <FSettingPumpPooling+0x264>
    b78e:	80 93 1b 02 	sts	0x021B, r24

          KeyChar=_key_btn(_key_scan(1));
    b792:	81 e0       	ldi	r24, 0x01	; 1
    b794:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    b798:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    b79c:	48 2f       	mov	r20, r24
    b79e:	41 53       	subi	r20, 0x31	; 49
    b7a0:	46 30       	cpi	r20, 0x06	; 6
    b7a2:	10 f0       	brcs	.+4      	; 0xb7a8 <FSettingPumpPooling+0x27a>
    b7a4:	40 e0       	ldi	r20, 0x00	; 0
    b7a6:	04 c0       	rjmp	.+8      	; 0xb7b0 <FSettingPumpPooling+0x282>
		      Addr=KeyChar-'1';
			  TimSend=0;
    b7a8:	10 92 78 0c 	sts	0x0C78, r1
			  IsStandaloneAcknoledge=False;
    b7ac:	10 92 82 01 	sts	0x0182, r1
          }
		  switch(KeyChar){
    b7b0:	83 33       	cpi	r24, 0x33	; 51
    b7b2:	09 f4       	brne	.+2      	; 0xb7b6 <FSettingPumpPooling+0x288>
    b7b4:	67 c0       	rjmp	.+206    	; 0xb884 <FSettingPumpPooling+0x356>
    b7b6:	84 33       	cpi	r24, 0x34	; 52
    b7b8:	48 f4       	brcc	.+18     	; 0xb7cc <FSettingPumpPooling+0x29e>
    b7ba:	81 33       	cpi	r24, 0x31	; 49
    b7bc:	89 f0       	breq	.+34     	; 0xb7e0 <FSettingPumpPooling+0x2b2>
    b7be:	82 33       	cpi	r24, 0x32	; 50
    b7c0:	08 f0       	brcs	.+2      	; 0xb7c4 <FSettingPumpPooling+0x296>
    b7c2:	3d c0       	rjmp	.+122    	; 0xb83e <FSettingPumpPooling+0x310>
    b7c4:	8a 32       	cpi	r24, 0x2A	; 42
    b7c6:	09 f0       	breq	.+2      	; 0xb7ca <FSettingPumpPooling+0x29c>
    b7c8:	e1 c0       	rjmp	.+450    	; 0xb98c <FSettingPumpPooling+0x45e>
    b7ca:	cd c0       	rjmp	.+410    	; 0xb966 <FSettingPumpPooling+0x438>
    b7cc:	85 33       	cpi	r24, 0x35	; 53
    b7ce:	09 f4       	brne	.+2      	; 0xb7d2 <FSettingPumpPooling+0x2a4>
    b7d0:	91 c0       	rjmp	.+290    	; 0xb8f4 <FSettingPumpPooling+0x3c6>
    b7d2:	85 33       	cpi	r24, 0x35	; 53
    b7d4:	08 f4       	brcc	.+2      	; 0xb7d8 <FSettingPumpPooling+0x2aa>
    b7d6:	78 c0       	rjmp	.+240    	; 0xb8c8 <FSettingPumpPooling+0x39a>
    b7d8:	86 33       	cpi	r24, 0x36	; 54
    b7da:	09 f0       	breq	.+2      	; 0xb7de <FSettingPumpPooling+0x2b0>
    b7dc:	d7 c0       	rjmp	.+430    	; 0xb98c <FSettingPumpPooling+0x45e>
    b7de:	a0 c0       	rjmp	.+320    	; 0xb920 <FSettingPumpPooling+0x3f2>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    b7e0:	24 2f       	mov	r18, r20
    b7e2:	30 e0       	ldi	r19, 0x00	; 0
    b7e4:	fe 01       	movw	r30, r28
    b7e6:	31 96       	adiw	r30, 0x01	; 1
    b7e8:	e2 0f       	add	r30, r18
    b7ea:	f3 1f       	adc	r31, r19
    b7ec:	80 81       	ld	r24, Z
    b7ee:	90 e0       	ldi	r25, 0x00	; 0
    b7f0:	01 96       	adiw	r24, 0x01	; 1
    b7f2:	61 e1       	ldi	r22, 0x11	; 17
    b7f4:	70 e0       	ldi	r23, 0x00	; 0
    b7f6:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    b7fa:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    b7fc:	88 23       	and	r24, r24
    b7fe:	11 f4       	brne	.+4      	; 0xb804 <FSettingPumpPooling+0x2d6>
    b800:	81 e0       	ldi	r24, 0x01	; 1
    b802:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    b804:	2c 0f       	add	r18, r28
    b806:	3d 1f       	adc	r19, r29
    b808:	f9 01       	movw	r30, r18
    b80a:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    b80c:	85 e1       	ldi	r24, 0x15	; 21
    b80e:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    b812:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    b816:	81 e0       	ldi	r24, 0x01	; 1
    b818:	80 93 84 01 	sts	0x0184, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    b81c:	e1 99       	sbic	0x1c, 1	; 28
    b81e:	fe cf       	rjmp	.-4      	; 0xb81c <FSettingPumpPooling+0x2ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b820:	84 2f       	mov	r24, r20
    b822:	90 e0       	ldi	r25, 0x00	; 0
    b824:	8c 5b       	subi	r24, 0xBC	; 188
    b826:	9e 4f       	sbci	r25, 0xFE	; 254
    b828:	9f bb       	out	0x1f, r25	; 31
    b82a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    b82c:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    b82e:	0f b6       	in	r0, 0x3f	; 63
    b830:	f8 94       	cli
    b832:	e2 9a       	sbi	0x1c, 2	; 28
    b834:	e1 9a       	sbi	0x1c, 1	; 28
    b836:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    b838:	20 93 5c 01 	sts	0x015C, r18
    b83c:	21 c0       	rjmp	.+66     	; 0xb880 <FSettingPumpPooling+0x352>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    b83e:	fe 01       	movw	r30, r28
    b840:	e4 0f       	add	r30, r20
    b842:	f1 1d       	adc	r31, r1
    b844:	81 81       	ldd	r24, Z+1	; 0x01
    b846:	90 e0       	ldi	r25, 0x00	; 0
    b848:	01 96       	adiw	r24, 0x01	; 1
    b84a:	65 e1       	ldi	r22, 0x15	; 21
    b84c:	70 e0       	ldi	r23, 0x00	; 0
    b84e:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    b852:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    b854:	84 e1       	ldi	r24, 0x14	; 20
    b856:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    b85a:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    b85e:	81 e0       	ldi	r24, 0x01	; 1
    b860:	80 93 84 01 	sts	0x0184, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    b864:	e1 99       	sbic	0x1c, 1	; 28
    b866:	fe cf       	rjmp	.-4      	; 0xb864 <FSettingPumpPooling+0x336>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b868:	84 2f       	mov	r24, r20
    b86a:	90 e0       	ldi	r25, 0x00	; 0
    b86c:	8c 5b       	subi	r24, 0xBC	; 188
    b86e:	9e 4f       	sbci	r25, 0xFE	; 254
    b870:	9f bb       	out	0x1f, r25	; 31
    b872:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    b874:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    b876:	0f b6       	in	r0, 0x3f	; 63
    b878:	f8 94       	cli
    b87a:	e2 9a       	sbi	0x1c, 2	; 28
    b87c:	e1 9a       	sbi	0x1c, 1	; 28
    b87e:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    b880:	83 e0       	ldi	r24, 0x03	; 3
    b882:	72 c0       	rjmp	.+228    	; 0xb968 <FSettingPumpPooling+0x43a>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    b884:	24 2f       	mov	r18, r20
    b886:	30 e0       	ldi	r19, 0x00	; 0
    b888:	fe 01       	movw	r30, r28
    b88a:	31 96       	adiw	r30, 0x01	; 1
    b88c:	e2 0f       	add	r30, r18
    b88e:	f3 1f       	adc	r31, r19
    b890:	80 81       	ld	r24, Z
    b892:	90 e0       	ldi	r25, 0x00	; 0
    b894:	01 96       	adiw	r24, 0x01	; 1
    b896:	65 e1       	ldi	r22, 0x15	; 21
    b898:	70 e0       	ldi	r23, 0x00	; 0
    b89a:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    b89e:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    b8a0:	88 23       	and	r24, r24
    b8a2:	11 f4       	brne	.+4      	; 0xb8a8 <FSettingPumpPooling+0x37a>
    b8a4:	81 e0       	ldi	r24, 0x01	; 1
    b8a6:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    b8a8:	2c 0f       	add	r18, r28
    b8aa:	3d 1f       	adc	r19, r29
    b8ac:	d9 01       	movw	r26, r18
    b8ae:	11 96       	adiw	r26, 0x01	; 1
    b8b0:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    b8b2:	86 e1       	ldi	r24, 0x16	; 22
    b8b4:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    b8b8:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    b8bc:	81 e0       	ldi	r24, 0x01	; 1
    b8be:	80 93 84 01 	sts	0x0184, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    b8c2:	e1 99       	sbic	0x1c, 1	; 28
    b8c4:	fe cf       	rjmp	.-4      	; 0xb8c2 <FSettingPumpPooling+0x394>
    b8c6:	d0 cf       	rjmp	.-96     	; 0xb868 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    b8c8:	fe 01       	movw	r30, r28
    b8ca:	e4 0f       	add	r30, r20
    b8cc:	f1 1d       	adc	r31, r1
    b8ce:	81 81       	ldd	r24, Z+1	; 0x01
    b8d0:	90 e0       	ldi	r25, 0x00	; 0
    b8d2:	01 96       	adiw	r24, 0x01	; 1
    b8d4:	65 e1       	ldi	r22, 0x15	; 21
    b8d6:	70 e0       	ldi	r23, 0x00	; 0
    b8d8:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    b8dc:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    b8de:	87 e1       	ldi	r24, 0x17	; 23
    b8e0:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    b8e4:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    b8e8:	81 e0       	ldi	r24, 0x01	; 1
    b8ea:	80 93 84 01 	sts	0x0184, r24
    b8ee:	e1 99       	sbic	0x1c, 1	; 28
    b8f0:	fe cf       	rjmp	.-4      	; 0xb8ee <FSettingPumpPooling+0x3c0>
    b8f2:	ba cf       	rjmp	.-140    	; 0xb868 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    b8f4:	fe 01       	movw	r30, r28
    b8f6:	e4 0f       	add	r30, r20
    b8f8:	f1 1d       	adc	r31, r1
    b8fa:	81 81       	ldd	r24, Z+1	; 0x01
    b8fc:	90 e0       	ldi	r25, 0x00	; 0
    b8fe:	01 96       	adiw	r24, 0x01	; 1
    b900:	69 e2       	ldi	r22, 0x29	; 41
    b902:	70 e0       	ldi	r23, 0x00	; 0
    b904:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    b908:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    b90a:	88 e1       	ldi	r24, 0x18	; 24
    b90c:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    b910:	20 93 d3 0b 	sts	0x0BD3, r18
     IsControlPooling=True;
    b914:	81 e0       	ldi	r24, 0x01	; 1
    b916:	80 93 84 01 	sts	0x0184, r24
    b91a:	e1 99       	sbic	0x1c, 1	; 28
    b91c:	fe cf       	rjmp	.-4      	; 0xb91a <FSettingPumpPooling+0x3ec>
    b91e:	a4 cf       	rjmp	.-184    	; 0xb868 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    b920:	fe 01       	movw	r30, r28
    b922:	e4 0f       	add	r30, r20
    b924:	f1 1d       	adc	r31, r1
    b926:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b928:	e1 99       	sbic	0x1c, 1	; 28
    b92a:	fe cf       	rjmp	.-4      	; 0xb928 <FSettingPumpPooling+0x3fa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b92c:	84 e4       	ldi	r24, 0x44	; 68
    b92e:	91 e0       	ldi	r25, 0x01	; 1
    b930:	9f bb       	out	0x1f, r25	; 31
    b932:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b934:	e0 9a       	sbi	0x1c, 0	; 28
    b936:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    b938:	e1 99       	sbic	0x1c, 1	; 28
    b93a:	fe cf       	rjmp	.-4      	; 0xb938 <FSettingPumpPooling+0x40a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b93c:	84 2f       	mov	r24, r20
    b93e:	90 e0       	ldi	r25, 0x00	; 0
    b940:	8c 5b       	subi	r24, 0xBC	; 188
    b942:	9e 4f       	sbci	r25, 0xFE	; 254
    b944:	9f bb       	out	0x1f, r25	; 31
    b946:	8e bb       	out	0x1e, r24	; 30
    b948:	82 2f       	mov	r24, r18
    b94a:	90 e0       	ldi	r25, 0x00	; 0
    b94c:	70 e0       	ldi	r23, 0x00	; 0
    b94e:	6f 5f       	subi	r22, 0xFF	; 255
    b950:	7f 4f       	sbci	r23, 0xFF	; 255
    b952:	01 96       	adiw	r24, 0x01	; 1
    b954:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
#endif
    EEDR = __value;
    b958:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    b95a:	0f b6       	in	r0, 0x3f	; 63
    b95c:	f8 94       	cli
    b95e:	e2 9a       	sbi	0x1c, 2	; 28
    b960:	e1 9a       	sbi	0x1c, 1	; 28
    b962:	0f be       	out	0x3f, r0	; 63
    b964:	0c c0       	rjmp	.+24     	; 0xb97e <FSettingPumpPooling+0x450>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    b966:	84 e0       	ldi	r24, 0x04	; 4
    b968:	80 93 1b 02 	sts	0x021B, r24
    b96c:	0f c0       	rjmp	.+30     	; 0xb98c <FSettingPumpPooling+0x45e>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    b96e:	80 91 82 01 	lds	r24, 0x0182
    b972:	81 30       	cpi	r24, 0x01	; 1
    b974:	21 f0       	breq	.+8      	; 0xb97e <FSettingPumpPooling+0x450>
    b976:	80 91 78 0c 	lds	r24, 0x0C78
    b97a:	86 30       	cpi	r24, 0x06	; 6
    b97c:	38 f0       	brcs	.+14     	; 0xb98c <FSettingPumpPooling+0x45e>
    b97e:	10 92 1b 02 	sts	0x021B, r1
    b982:	04 c0       	rjmp	.+8      	; 0xb98c <FSettingPumpPooling+0x45e>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    b984:	10 92 1b 02 	sts	0x021B, r1
    b988:	81 e0       	ldi	r24, 0x01	; 1
    b98a:	01 c0       	rjmp	.+2      	; 0xb98e <FSettingPumpPooling+0x460>
    b98c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    b98e:	6a 96       	adiw	r28, 0x1a	; 26
    b990:	0f b6       	in	r0, 0x3f	; 63
    b992:	f8 94       	cli
    b994:	de bf       	out	0x3e, r29	; 62
    b996:	0f be       	out	0x3f, r0	; 63
    b998:	cd bf       	out	0x3d, r28	; 61
    b99a:	cf 91       	pop	r28
    b99c:	df 91       	pop	r29
    b99e:	1f 91       	pop	r17
    b9a0:	0f 91       	pop	r16
    b9a2:	08 95       	ret

0000b9a4 <DisplayTicker>:
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
*/
    if (TimTicker>(TICKER_DELAY*2+1)){
    b9a4:	80 91 90 01 	lds	r24, 0x0190
    b9a8:	86 31       	cpi	r24, 0x16	; 22
    b9aa:	38 f0       	brcs	.+14     	; 0xb9ba <DisplayTicker+0x16>
	    lcd_put(4, 1, '>');
    b9ac:	84 e0       	ldi	r24, 0x04	; 4
    b9ae:	61 e0       	ldi	r22, 0x01	; 1
    b9b0:	4e e3       	ldi	r20, 0x3E	; 62
    b9b2:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
		TimTicker=0;
    b9b6:	10 92 90 01 	sts	0x0190, r1
	}
    if (TimTicker==TICKER_DELAY){
    b9ba:	80 91 90 01 	lds	r24, 0x0190
    b9be:	8a 30       	cpi	r24, 0x0A	; 10
    b9c0:	51 f4       	brne	.+20     	; 0xb9d6 <DisplayTicker+0x32>
	    lcd_put(4, 1, '<');
    b9c2:	84 e0       	ldi	r24, 0x04	; 4
    b9c4:	61 e0       	ldi	r22, 0x01	; 1
    b9c6:	4c e3       	ldi	r20, 0x3C	; 60
    b9c8:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
		TimTicker++;
    b9cc:	80 91 90 01 	lds	r24, 0x0190
    b9d0:	8f 5f       	subi	r24, 0xFF	; 255
    b9d2:	80 93 90 01 	sts	0x0190, r24
    b9d6:	08 95       	ret

0000b9d8 <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    b9d8:	6f 92       	push	r6
    b9da:	7f 92       	push	r7
    b9dc:	8f 92       	push	r8
    b9de:	9f 92       	push	r9
    b9e0:	af 92       	push	r10
    b9e2:	bf 92       	push	r11
    b9e4:	cf 92       	push	r12
    b9e6:	df 92       	push	r13
    b9e8:	ff 92       	push	r15
    b9ea:	0f 93       	push	r16
    b9ec:	1f 93       	push	r17
    b9ee:	df 93       	push	r29
    b9f0:	cf 93       	push	r28
    b9f2:	cd b7       	in	r28, 0x3d	; 61
    b9f4:	de b7       	in	r29, 0x3e	; 62
    b9f6:	67 97       	sbiw	r28, 0x17	; 23
    b9f8:	0f b6       	in	r0, 0x3f	; 63
    b9fa:	f8 94       	cli
    b9fc:	de bf       	out	0x3e, r29	; 62
    b9fe:	0f be       	out	0x3f, r0	; 63
    ba00:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    ba02:	80 91 82 02 	lds	r24, 0x0282
    ba06:	90 91 83 02 	lds	r25, 0x0283
    ba0a:	01 96       	adiw	r24, 0x01	; 1
    ba0c:	90 93 83 02 	sts	0x0283, r25
    ba10:	80 93 82 02 	sts	0x0282, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    ba14:	62 e3       	ldi	r22, 0x32	; 50
    ba16:	70 e0       	ldi	r23, 0x00	; 0
    ba18:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    ba1c:	89 2b       	or	r24, r25
    ba1e:	29 f5       	brne	.+74     	; 0xba6a <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    ba20:	80 91 00 01 	lds	r24, 0x0100
    ba24:	82 30       	cpi	r24, 0x02	; 2
    ba26:	11 f4       	brne	.+4      	; 0xba2c <DisplayIdle+0x54>
    ba28:	0e 94 05 47 	call	0x8e0a	; 0x8e0a <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ba2c:	e1 99       	sbic	0x1c, 1	; 28
    ba2e:	fe cf       	rjmp	.-4      	; 0xba2c <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ba30:	87 e3       	ldi	r24, 0x37	; 55
    ba32:	90 e0       	ldi	r25, 0x00	; 0
    ba34:	9f bb       	out	0x1f, r25	; 31
    ba36:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ba38:	e0 9a       	sbi	0x1c, 0	; 28
    ba3a:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&DefShowDateTime)) DisplayDateTime();
    ba3c:	88 23       	and	r24, r24
    ba3e:	19 f0       	breq	.+6      	; 0xba46 <DisplayIdle+0x6e>
    ba40:	0e 94 45 46 	call	0x8c8a	; 0x8c8a <DisplayDateTime>
    ba44:	02 c0       	rjmp	.+4      	; 0xba4a <DisplayIdle+0x72>
       else DisplayTicker();
    ba46:	0e 94 d2 5c 	call	0xb9a4	; 0xb9a4 <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    ba4a:	80 91 00 01 	lds	r24, 0x0100
    ba4e:	82 30       	cpi	r24, 0x02	; 2
    ba50:	61 f4       	brne	.+24     	; 0xba6a <DisplayIdle+0x92>
    ba52:	80 91 81 01 	lds	r24, 0x0181
    ba56:	81 30       	cpi	r24, 0x01	; 1
    ba58:	41 f4       	brne	.+16     	; 0xba6a <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    ba5a:	10 92 81 01 	sts	0x0181, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    ba5e:	84 e0       	ldi	r24, 0x04	; 4
    ba60:	62 e1       	ldi	r22, 0x12	; 18
    ba62:	40 91 80 01 	lds	r20, 0x0180
    ba66:	0e 94 61 5a 	call	0xb4c2	; 0xb4c2 <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    ba6a:	f0 90 81 02 	lds	r15, 0x0281
    ba6e:	ff 20       	and	r15, r15
    ba70:	29 f0       	breq	.+10     	; 0xba7c <DisplayIdle+0xa4>
    ba72:	81 e0       	ldi	r24, 0x01	; 1
    ba74:	f8 16       	cp	r15, r24
    ba76:	09 f0       	breq	.+2      	; 0xba7a <DisplayIdle+0xa2>
    ba78:	58 c0       	rjmp	.+176    	; 0xbb2a <DisplayIdle+0x152>
    ba7a:	2f c0       	rjmp	.+94     	; 0xbada <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    ba7c:	f0 90 b2 01 	lds	r15, 0x01B2
    ba80:	91 e0       	ldi	r25, 0x01	; 1
    ba82:	f9 16       	cp	r15, r25
    ba84:	09 f0       	breq	.+2      	; 0xba88 <DisplayIdle+0xb0>
    ba86:	51 c0       	rjmp	.+162    	; 0xbb2a <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    ba88:	00 d0       	rcall	.+0      	; 0xba8a <DisplayIdle+0xb2>
    ba8a:	00 d0       	rcall	.+0      	; 0xba8c <DisplayIdle+0xb4>
    ba8c:	00 d0       	rcall	.+0      	; 0xba8e <DisplayIdle+0xb6>
    ba8e:	ed b7       	in	r30, 0x3d	; 61
    ba90:	fe b7       	in	r31, 0x3e	; 62
    ba92:	31 96       	adiw	r30, 0x01	; 1
    ba94:	8e 01       	movw	r16, r28
    ba96:	0c 5f       	subi	r16, 0xFC	; 252
    ba98:	1f 4f       	sbci	r17, 0xFF	; 255
    ba9a:	ad b7       	in	r26, 0x3d	; 61
    ba9c:	be b7       	in	r27, 0x3e	; 62
    ba9e:	12 96       	adiw	r26, 0x02	; 2
    baa0:	1c 93       	st	X, r17
    baa2:	0e 93       	st	-X, r16
    baa4:	11 97       	sbiw	r26, 0x01	; 1
    baa6:	82 e8       	ldi	r24, 0x82	; 130
    baa8:	9b e1       	ldi	r25, 0x1B	; 27
    baaa:	93 83       	std	Z+3, r25	; 0x03
    baac:	82 83       	std	Z+2, r24	; 0x02
    baae:	89 eb       	ldi	r24, 0xB9	; 185
    bab0:	97 e0       	ldi	r25, 0x07	; 7
    bab2:	95 83       	std	Z+5, r25	; 0x05
    bab4:	84 83       	std	Z+4, r24	; 0x04
    bab6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    baba:	ed b7       	in	r30, 0x3d	; 61
    babc:	fe b7       	in	r31, 0x3e	; 62
    babe:	36 96       	adiw	r30, 0x06	; 6
    bac0:	0f b6       	in	r0, 0x3f	; 63
    bac2:	f8 94       	cli
    bac4:	fe bf       	out	0x3e, r31	; 62
    bac6:	0f be       	out	0x3f, r0	; 63
    bac8:	ed bf       	out	0x3d, r30	; 61
    baca:	83 e0       	ldi	r24, 0x03	; 3
    bacc:	61 e0       	ldi	r22, 0x01	; 1
    bace:	a8 01       	movw	r20, r16
    bad0:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			   stDispIdle=diWaitNoBusy;
    bad4:	f0 92 81 02 	sts	0x0281, r15
    bad8:	28 c0       	rjmp	.+80     	; 0xbb2a <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    bada:	80 91 b2 01 	lds	r24, 0x01B2
    bade:	88 23       	and	r24, r24
    bae0:	21 f5       	brne	.+72     	; 0xbb2a <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    bae2:	00 d0       	rcall	.+0      	; 0xbae4 <DisplayIdle+0x10c>
    bae4:	00 d0       	rcall	.+0      	; 0xbae6 <DisplayIdle+0x10e>
    bae6:	8e 01       	movw	r16, r28
    bae8:	0c 5f       	subi	r16, 0xFC	; 252
    baea:	1f 4f       	sbci	r17, 0xFF	; 255
    baec:	ad b7       	in	r26, 0x3d	; 61
    baee:	be b7       	in	r27, 0x3e	; 62
    baf0:	12 96       	adiw	r26, 0x02	; 2
    baf2:	1c 93       	st	X, r17
    baf4:	0e 93       	st	-X, r16
    baf6:	11 97       	sbiw	r26, 0x01	; 1
    baf8:	8d e6       	ldi	r24, 0x6D	; 109
    bafa:	9b e1       	ldi	r25, 0x1B	; 27
    bafc:	14 96       	adiw	r26, 0x04	; 4
    bafe:	9c 93       	st	X, r25
    bb00:	8e 93       	st	-X, r24
    bb02:	13 97       	sbiw	r26, 0x03	; 3
    bb04:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    bb08:	0f 90       	pop	r0
    bb0a:	0f 90       	pop	r0
    bb0c:	0f 90       	pop	r0
    bb0e:	0f 90       	pop	r0
    bb10:	83 e0       	ldi	r24, 0x03	; 3
    bb12:	61 e0       	ldi	r22, 0x01	; 1
    bb14:	a8 01       	movw	r20, r16
    bb16:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			   stDispIdle=diScan;
    bb1a:	10 92 81 02 	sts	0x0281, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    bb1e:	80 91 8f 01 	lds	r24, 0x018F
    bb22:	88 23       	and	r24, r24
    bb24:	11 f0       	breq	.+4      	; 0xbb2a <DisplayIdle+0x152>
    bb26:	f0 92 96 01 	sts	0x0196, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    bb2a:	80 91 96 01 	lds	r24, 0x0196
    bb2e:	81 30       	cpi	r24, 0x01	; 1
    bb30:	09 f0       	breq	.+2      	; 0xbb34 <DisplayIdle+0x15c>
    bb32:	69 c0       	rjmp	.+210    	; 0xbc06 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    bb34:	10 92 96 01 	sts	0x0196, r1
		 if (nLocalAccount>0){
    bb38:	80 91 8f 01 	lds	r24, 0x018F
    bb3c:	88 23       	and	r24, r24
    bb3e:	09 f4       	brne	.+2      	; 0xbb42 <DisplayIdle+0x16a>
    bb40:	5c c0       	rjmp	.+184    	; 0xbbfa <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    bb42:	83 e0       	ldi	r24, 0x03	; 3
    bb44:	61 e0       	ldi	r22, 0x01	; 1
    bb46:	47 e6       	ldi	r20, 0x67	; 103
    bb48:	5b e1       	ldi	r21, 0x1B	; 27
    bb4a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    bb4e:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    bb50:	5e 01       	movw	r10, r28
    bb52:	08 94       	sec
    bb54:	a1 1c       	adc	r10, r1
    bb56:	b1 1c       	adc	r11, r1
    bb58:	b2 e6       	ldi	r27, 0x62	; 98
    bb5a:	6b 2e       	mov	r6, r27
    bb5c:	bb e1       	ldi	r27, 0x1B	; 27
    bb5e:	7b 2e       	mov	r7, r27
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    bb60:	a4 e0       	ldi	r26, 0x04	; 4
    bb62:	ca 2e       	mov	r12, r26
    bb64:	d1 2c       	mov	r13, r1
    bb66:	cc 0e       	add	r12, r28
    bb68:	dd 1e       	adc	r13, r29
    bb6a:	fe e5       	ldi	r31, 0x5E	; 94
    bb6c:	8f 2e       	mov	r8, r31
    bb6e:	fb e1       	ldi	r31, 0x1B	; 27
    bb70:	9f 2e       	mov	r9, r31
    bb72:	3d c0       	rjmp	.+122    	; 0xbbee <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    bb74:	0f 2d       	mov	r16, r15
    bb76:	10 e0       	ldi	r17, 0x00	; 0
    bb78:	00 d0       	rcall	.+0      	; 0xbb7a <DisplayIdle+0x1a2>
    bb7a:	00 d0       	rcall	.+0      	; 0xbb7c <DisplayIdle+0x1a4>
    bb7c:	00 d0       	rcall	.+0      	; 0xbb7e <DisplayIdle+0x1a6>
    bb7e:	ad b7       	in	r26, 0x3d	; 61
    bb80:	be b7       	in	r27, 0x3e	; 62
    bb82:	11 96       	adiw	r26, 0x01	; 1
    bb84:	ed b7       	in	r30, 0x3d	; 61
    bb86:	fe b7       	in	r31, 0x3e	; 62
    bb88:	b2 82       	std	Z+2, r11	; 0x02
    bb8a:	a1 82       	std	Z+1, r10	; 0x01
    bb8c:	13 96       	adiw	r26, 0x03	; 3
    bb8e:	7c 92       	st	X, r7
    bb90:	6e 92       	st	-X, r6
    bb92:	12 97       	sbiw	r26, 0x02	; 2
    bb94:	f8 01       	movw	r30, r16
    bb96:	ea 5a       	subi	r30, 0xAA	; 170
    bb98:	fc 4f       	sbci	r31, 0xFC	; 252
    bb9a:	80 81       	ld	r24, Z
    bb9c:	14 96       	adiw	r26, 0x04	; 4
    bb9e:	8c 93       	st	X, r24
    bba0:	14 97       	sbiw	r26, 0x04	; 4
    bba2:	15 96       	adiw	r26, 0x05	; 5
    bba4:	1c 92       	st	X, r1
    bba6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    bbaa:	ed b7       	in	r30, 0x3d	; 61
    bbac:	fe b7       	in	r31, 0x3e	; 62
    bbae:	31 96       	adiw	r30, 0x01	; 1
    bbb0:	ad b7       	in	r26, 0x3d	; 61
    bbb2:	be b7       	in	r27, 0x3e	; 62
    bbb4:	12 96       	adiw	r26, 0x02	; 2
    bbb6:	dc 92       	st	X, r13
    bbb8:	ce 92       	st	-X, r12
    bbba:	11 97       	sbiw	r26, 0x01	; 1
    bbbc:	93 82       	std	Z+3, r9	; 0x03
    bbbe:	82 82       	std	Z+2, r8	; 0x02
    bbc0:	b5 82       	std	Z+5, r11	; 0x05
    bbc2:	a4 82       	std	Z+4, r10	; 0x04
    bbc4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    bbc8:	ed b7       	in	r30, 0x3d	; 61
    bbca:	fe b7       	in	r31, 0x3e	; 62
    bbcc:	36 96       	adiw	r30, 0x06	; 6
    bbce:	0f b6       	in	r0, 0x3f	; 63
    bbd0:	f8 94       	cli
    bbd2:	fe bf       	out	0x3e, r31	; 62
    bbd4:	0f be       	out	0x3f, r0	; 63
    bbd6:	ed bf       	out	0x3d, r30	; 61
    bbd8:	b8 01       	movw	r22, r16
    bbda:	66 0f       	add	r22, r22
    bbdc:	77 1f       	adc	r23, r23
    bbde:	60 0f       	add	r22, r16
    bbe0:	71 1f       	adc	r23, r17
    bbe2:	6a 5f       	subi	r22, 0xFA	; 250
    bbe4:	83 e0       	ldi	r24, 0x03	; 3
    bbe6:	a6 01       	movw	r20, r12
    bbe8:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    bbec:	f3 94       	inc	r15
    bbee:	80 91 8f 01 	lds	r24, 0x018F
    bbf2:	f8 16       	cp	r15, r24
    bbf4:	08 f4       	brcc	.+2      	; 0xbbf8 <DisplayIdle+0x220>
    bbf6:	be cf       	rjmp	.-132    	; 0xbb74 <DisplayIdle+0x19c>
    bbf8:	06 c0       	rjmp	.+12     	; 0xbc06 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    bbfa:	83 e0       	ldi	r24, 0x03	; 3
    bbfc:	61 e0       	ldi	r22, 0x01	; 1
    bbfe:	49 e4       	ldi	r20, 0x49	; 73
    bc00:	5b e1       	ldi	r21, 0x1B	; 27
    bc02:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    bc06:	80 91 a9 01 	lds	r24, 0x01A9
    bc0a:	81 30       	cpi	r24, 0x01	; 1
    bc0c:	c1 f4       	brne	.+48     	; 0xbc3e <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    bc0e:	10 92 a9 01 	sts	0x01A9, r1
	     if (nLocalAccount>0){
    bc12:	90 91 8f 01 	lds	r25, 0x018F
    bc16:	99 23       	and	r25, r25
    bc18:	91 f0       	breq	.+36     	; 0xbc3e <DisplayIdle+0x266>
    bc1a:	e6 e5       	ldi	r30, 0x56	; 86
    bc1c:	f3 e0       	ldi	r31, 0x03	; 3
			 for(i=0;i<nLocalAccount;i++){//Shift data
    bc1e:	29 2f       	mov	r18, r25
    bc20:	30 e0       	ldi	r19, 0x00	; 0
    bc22:	2e 0f       	add	r18, r30
    bc24:	3f 1f       	adc	r19, r31
    bc26:	02 c0       	rjmp	.+4      	; 0xbc2c <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    bc28:	81 81       	ldd	r24, Z+1	; 0x01
    bc2a:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    bc2c:	e2 17       	cp	r30, r18
    bc2e:	f3 07       	cpc	r31, r19
    bc30:	d9 f7       	brne	.-10     	; 0xbc28 <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    bc32:	91 50       	subi	r25, 0x01	; 1
    bc34:	90 93 8f 01 	sts	0x018F, r25
             IsViewFillingFIP=True; 
    bc38:	81 e0       	ldi	r24, 0x01	; 1
    bc3a:	80 93 96 01 	sts	0x0196, r24
		 }
	 }
}
    bc3e:	67 96       	adiw	r28, 0x17	; 23
    bc40:	0f b6       	in	r0, 0x3f	; 63
    bc42:	f8 94       	cli
    bc44:	de bf       	out	0x3e, r29	; 62
    bc46:	0f be       	out	0x3f, r0	; 63
    bc48:	cd bf       	out	0x3d, r28	; 61
    bc4a:	cf 91       	pop	r28
    bc4c:	df 91       	pop	r29
    bc4e:	1f 91       	pop	r17
    bc50:	0f 91       	pop	r16
    bc52:	ff 90       	pop	r15
    bc54:	df 90       	pop	r13
    bc56:	cf 90       	pop	r12
    bc58:	bf 90       	pop	r11
    bc5a:	af 90       	pop	r10
    bc5c:	9f 90       	pop	r9
    bc5e:	8f 90       	pop	r8
    bc60:	7f 90       	pop	r7
    bc62:	6f 90       	pop	r6
    bc64:	08 95       	ret

0000bc66 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    bc66:	81 e0       	ldi	r24, 0x01	; 1
    bc68:	60 e0       	ldi	r22, 0x00	; 0
    bc6a:	0e 94 59 a6 	call	0x14cb2	; 0x14cb2 <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    bc6e:	81 e0       	ldi	r24, 0x01	; 1
    bc70:	0e 94 6c a6 	call	0x14cd8	; 0x14cd8 <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    bc74:	bb 98       	cbi	0x17, 3	; 23
    bc76:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    bc78:	ba 9a       	sbi	0x17, 2	; 23
}
    bc7a:	08 95       	ret

0000bc7c <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    bc7c:	80 e0       	ldi	r24, 0x00	; 0
    bc7e:	0e 94 6c a6 	call	0x14cd8	; 0x14cd8 <_spi_enable>
  	_spi_init(0, 1);         //Slave
    bc82:	80 e0       	ldi	r24, 0x00	; 0
    bc84:	61 e0       	ldi	r22, 0x01	; 1
    bc86:	0e 94 59 a6 	call	0x14cb2	; 0x14cb2 <_spi_init>
	sbi(DDRB,3);             //MISO Output
    bc8a:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    bc8c:	bb 9a       	sbi	0x17, 3	; 23
    bc8e:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    bc90:	ba 98       	cbi	0x17, 2	; 23
    bc92:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    bc94:	b9 98       	cbi	0x17, 1	; 23
    bc96:	c1 9a       	sbi	0x18, 1	; 24
}
    bc98:	08 95       	ret

0000bc9a <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    bc9a:	1f 93       	push	r17
    bc9c:	18 2f       	mov	r17, r24
     systemMaster();	 
    bc9e:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <systemMaster>
     _spi(EDCData);
    bca2:	81 2f       	mov	r24, r17
    bca4:	0e 94 83 a6 	call	0x14d06	; 0x14d06 <_spi>
     systemSlave();
    bca8:	0e 94 3e 5e 	call	0xbc7c	; 0xbc7c <systemSlave>
}
    bcac:	1f 91       	pop	r17
    bcae:	08 95       	ret

0000bcb0 <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    bcb0:	cf 92       	push	r12
    bcb2:	df 92       	push	r13
    bcb4:	ef 92       	push	r14
    bcb6:	ff 92       	push	r15
    bcb8:	0f 93       	push	r16
    bcba:	1f 93       	push	r17
    bcbc:	df 93       	push	r29
    bcbe:	cf 93       	push	r28
    bcc0:	cd b7       	in	r28, 0x3d	; 61
    bcc2:	de b7       	in	r29, 0x3e	; 62
    bcc4:	ec 97       	sbiw	r28, 0x3c	; 60
    bcc6:	0f b6       	in	r0, 0x3f	; 63
    bcc8:	f8 94       	cli
    bcca:	de bf       	out	0x3e, r29	; 62
    bccc:	0f be       	out	0x3f, r0	; 63
    bcce:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //uart_printf(0,0,PSTR("StrStatus:"));uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    bcd0:	8d b7       	in	r24, 0x3d	; 61
    bcd2:	9e b7       	in	r25, 0x3e	; 62
    bcd4:	42 97       	sbiw	r24, 0x12	; 18
    bcd6:	0f b6       	in	r0, 0x3f	; 63
    bcd8:	f8 94       	cli
    bcda:	9e bf       	out	0x3e, r25	; 62
    bcdc:	0f be       	out	0x3f, r0	; 63
    bcde:	8d bf       	out	0x3d, r24	; 61
    bce0:	ed b7       	in	r30, 0x3d	; 61
    bce2:	fe b7       	in	r31, 0x3e	; 62
    bce4:	31 96       	adiw	r30, 0x01	; 1
    bce6:	8e 01       	movw	r16, r28
    bce8:	0f 5f       	subi	r16, 0xFF	; 255
    bcea:	1f 4f       	sbci	r17, 0xFF	; 255
    bcec:	ad b7       	in	r26, 0x3d	; 61
    bcee:	be b7       	in	r27, 0x3e	; 62
    bcf0:	12 96       	adiw	r26, 0x02	; 2
    bcf2:	1c 93       	st	X, r17
    bcf4:	0e 93       	st	-X, r16
    bcf6:	11 97       	sbiw	r26, 0x01	; 1
    bcf8:	86 e3       	ldi	r24, 0x36	; 54
    bcfa:	9b e1       	ldi	r25, 0x1B	; 27
    bcfc:	93 83       	std	Z+3, r25	; 0x03
    bcfe:	82 83       	std	Z+2, r24	; 0x02
    bd00:	87 e8       	ldi	r24, 0x87	; 135
    bd02:	9c e0       	ldi	r25, 0x0C	; 12
    bd04:	95 83       	std	Z+5, r25	; 0x05
    bd06:	84 83       	std	Z+4, r24	; 0x04
    bd08:	89 eb       	ldi	r24, 0xB9	; 185
    bd0a:	97 e0       	ldi	r25, 0x07	; 7
    bd0c:	97 83       	std	Z+7, r25	; 0x07
    bd0e:	86 83       	std	Z+6, r24	; 0x06
    bd10:	8c e0       	ldi	r24, 0x0C	; 12
    bd12:	98 e0       	ldi	r25, 0x08	; 8
    bd14:	91 87       	std	Z+9, r25	; 0x09
    bd16:	80 87       	std	Z+8, r24	; 0x08
    bd18:	8e e9       	ldi	r24, 0x9E	; 158
    bd1a:	95 e0       	ldi	r25, 0x05	; 5
    bd1c:	93 87       	std	Z+11, r25	; 0x0b
    bd1e:	82 87       	std	Z+10, r24	; 0x0a
    bd20:	85 e7       	ldi	r24, 0x75	; 117
    bd22:	93 e0       	ldi	r25, 0x03	; 3
    bd24:	95 87       	std	Z+13, r25	; 0x0d
    bd26:	84 87       	std	Z+12, r24	; 0x0c
    bd28:	83 eb       	ldi	r24, 0xB3	; 179
    bd2a:	9b e0       	ldi	r25, 0x0B	; 11
    bd2c:	97 87       	std	Z+15, r25	; 0x0f
    bd2e:	86 87       	std	Z+14, r24	; 0x0e
    bd30:	8a e8       	ldi	r24, 0x8A	; 138
    bd32:	93 e0       	ldi	r25, 0x03	; 3
    bd34:	91 8b       	std	Z+17, r25	; 0x11
    bd36:	80 8b       	std	Z+16, r24	; 0x10
    bd38:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    bd3c:	8d b7       	in	r24, 0x3d	; 61
    bd3e:	9e b7       	in	r25, 0x3e	; 62
    bd40:	42 96       	adiw	r24, 0x12	; 18
    bd42:	0f b6       	in	r0, 0x3f	; 63
    bd44:	f8 94       	cli
    bd46:	9e bf       	out	0x3e, r25	; 62
    bd48:	0f be       	out	0x3f, r0	; 63
    bd4a:	8d bf       	out	0x3d, r24	; 61
    bd4c:	82 e0       	ldi	r24, 0x02	; 2
    bd4e:	0e 94 4d 5e 	call	0xbc9a	; 0xbc9a <EDCSendByte>
    bd52:	ff 24       	eor	r15, r15
    bd54:	92 e0       	ldi	r25, 0x02	; 2
    bd56:	e9 2e       	mov	r14, r25
    bd58:	84 ed       	ldi	r24, 0xD4	; 212
    bd5a:	c8 2e       	mov	r12, r24
    bd5c:	80 e3       	ldi	r24, 0x30	; 48
    bd5e:	d8 2e       	mov	r13, r24
    bd60:	0a c0       	rjmp	.+20     	; 0xbd76 <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    bd62:	a0 0f       	add	r26, r16
    bd64:	b1 1f       	adc	r27, r17
    bd66:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    bd68:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    bd6a:	0e 94 4d 5e 	call	0xbc9a	; 0xbc9a <EDCSendByte>
    bd6e:	c6 01       	movw	r24, r12
    bd70:	01 97       	sbiw	r24, 0x01	; 1
    bd72:	f1 f7       	brne	.-4      	; 0xbd70 <SendEDCMessage+0xc0>
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    bd74:	f3 94       	inc	r15
    bd76:	f8 01       	movw	r30, r16
    bd78:	01 90       	ld	r0, Z+
    bd7a:	00 20       	and	r0, r0
    bd7c:	e9 f7       	brne	.-6      	; 0xbd78 <SendEDCMessage+0xc8>
    bd7e:	31 97       	sbiw	r30, 0x01	; 1
    bd80:	e0 1b       	sub	r30, r16
    bd82:	f1 0b       	sbc	r31, r17
    bd84:	af 2d       	mov	r26, r15
    bd86:	b0 e0       	ldi	r27, 0x00	; 0
    bd88:	ae 17       	cp	r26, r30
    bd8a:	bf 07       	cpc	r27, r31
    bd8c:	50 f3       	brcs	.-44     	; 0xbd62 <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //uart(0,1,SerialEDC[i]);
		  _delay_ms(SPI_EDC_DELAY);//min:8
	 }
     EDCSendByte(0x03);
    bd8e:	83 e0       	ldi	r24, 0x03	; 3
    bd90:	0e 94 4d 5e 	call	0xbc9a	; 0xbc9a <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    bd94:	83 e0       	ldi	r24, 0x03	; 3
    bd96:	8e 25       	eor	r24, r14
    bd98:	0e 94 4d 5e 	call	0xbc9a	; 0xbc9a <EDCSendByte>
}
    bd9c:	ec 96       	adiw	r28, 0x3c	; 60
    bd9e:	0f b6       	in	r0, 0x3f	; 63
    bda0:	f8 94       	cli
    bda2:	de bf       	out	0x3e, r29	; 62
    bda4:	0f be       	out	0x3f, r0	; 63
    bda6:	cd bf       	out	0x3d, r28	; 61
    bda8:	cf 91       	pop	r28
    bdaa:	df 91       	pop	r29
    bdac:	1f 91       	pop	r17
    bdae:	0f 91       	pop	r16
    bdb0:	ff 90       	pop	r15
    bdb2:	ef 90       	pop	r14
    bdb4:	df 90       	pop	r13
    bdb6:	cf 90       	pop	r12
    bdb8:	08 95       	ret

0000bdba <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    bdba:	0f 93       	push	r16
    bdbc:	1f 93       	push	r17
    bdbe:	18 2f       	mov	r17, r24
    bdc0:	06 2f       	mov	r16, r22
	 systemMaster();
    bdc2:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <systemMaster>
	 _spi(0x05);
    bdc6:	85 e0       	ldi	r24, 0x05	; 5
    bdc8:	0e 94 83 a6 	call	0x14d06	; 0x14d06 <_spi>
	 _spi(SlaveCommand);
    bdcc:	81 2f       	mov	r24, r17
    bdce:	0e 94 83 a6 	call	0x14d06	; 0x14d06 <_spi>
	 _spi(SlaveMessage);
    bdd2:	80 2f       	mov	r24, r16
    bdd4:	0e 94 83 a6 	call	0x14d06	; 0x14d06 <_spi>
	 _spi(0x06);
    bdd8:	86 e0       	ldi	r24, 0x06	; 6
    bdda:	0e 94 83 a6 	call	0x14d06	; 0x14d06 <_spi>
	 systemSlave();
    bdde:	0e 94 3e 5e 	call	0xbc7c	; 0xbc7c <systemSlave>
}
    bde2:	1f 91       	pop	r17
    bde4:	0f 91       	pop	r16
    bde6:	08 95       	ret

0000bde8 <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    bde8:	9f 92       	push	r9
    bdea:	af 92       	push	r10
    bdec:	bf 92       	push	r11
    bdee:	cf 92       	push	r12
    bdf0:	df 92       	push	r13
    bdf2:	ef 92       	push	r14
    bdf4:	ff 92       	push	r15
    bdf6:	0f 93       	push	r16
    bdf8:	1f 93       	push	r17
    bdfa:	df 93       	push	r29
    bdfc:	cf 93       	push	r28
    bdfe:	cd b7       	in	r28, 0x3d	; 61
    be00:	de b7       	in	r29, 0x3e	; 62
    be02:	64 97       	sbiw	r28, 0x14	; 20
    be04:	0f b6       	in	r0, 0x3f	; 63
    be06:	f8 94       	cli
    be08:	de bf       	out	0x3e, r29	; 62
    be0a:	0f be       	out	0x3f, r0	; 63
    be0c:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    be0e:	80 91 1a 02 	lds	r24, 0x021A
    be12:	85 30       	cpi	r24, 0x05	; 5
    be14:	09 f4       	brne	.+2      	; 0xbe18 <FSettingPumpID+0x30>
    be16:	85 c1       	rjmp	.+778    	; 0xc122 <FSettingPumpID+0x33a>
    be18:	86 30       	cpi	r24, 0x06	; 6
    be1a:	90 f4       	brcc	.+36     	; 0xbe40 <FSettingPumpID+0x58>
    be1c:	82 30       	cpi	r24, 0x02	; 2
    be1e:	09 f4       	brne	.+2      	; 0xbe22 <FSettingPumpID+0x3a>
    be20:	8f c0       	rjmp	.+286    	; 0xbf40 <FSettingPumpID+0x158>
    be22:	83 30       	cpi	r24, 0x03	; 3
    be24:	30 f4       	brcc	.+12     	; 0xbe32 <FSettingPumpID+0x4a>
    be26:	88 23       	and	r24, r24
    be28:	f1 f0       	breq	.+60     	; 0xbe66 <FSettingPumpID+0x7e>
    be2a:	81 30       	cpi	r24, 0x01	; 1
    be2c:	09 f0       	breq	.+2      	; 0xbe30 <FSettingPumpID+0x48>
    be2e:	6c c2       	rjmp	.+1240   	; 0xc308 <FSettingPumpID+0x520>
    be30:	2d c0       	rjmp	.+90     	; 0xbe8c <FSettingPumpID+0xa4>
    be32:	83 30       	cpi	r24, 0x03	; 3
    be34:	09 f4       	brne	.+2      	; 0xbe38 <FSettingPumpID+0x50>
    be36:	51 c1       	rjmp	.+674    	; 0xc0da <FSettingPumpID+0x2f2>
    be38:	84 30       	cpi	r24, 0x04	; 4
    be3a:	09 f0       	breq	.+2      	; 0xbe3e <FSettingPumpID+0x56>
    be3c:	65 c2       	rjmp	.+1226   	; 0xc308 <FSettingPumpID+0x520>
    be3e:	6a c1       	rjmp	.+724    	; 0xc114 <FSettingPumpID+0x32c>
    be40:	88 30       	cpi	r24, 0x08	; 8
    be42:	09 f4       	brne	.+2      	; 0xbe46 <FSettingPumpID+0x5e>
    be44:	f9 c1       	rjmp	.+1010   	; 0xc238 <FSettingPumpID+0x450>
    be46:	89 30       	cpi	r24, 0x09	; 9
    be48:	38 f4       	brcc	.+14     	; 0xbe58 <FSettingPumpID+0x70>
    be4a:	86 30       	cpi	r24, 0x06	; 6
    be4c:	09 f4       	brne	.+2      	; 0xbe50 <FSettingPumpID+0x68>
    be4e:	98 c1       	rjmp	.+816    	; 0xc180 <FSettingPumpID+0x398>
    be50:	87 30       	cpi	r24, 0x07	; 7
    be52:	09 f0       	breq	.+2      	; 0xbe56 <FSettingPumpID+0x6e>
    be54:	59 c2       	rjmp	.+1202   	; 0xc308 <FSettingPumpID+0x520>
    be56:	3e c2       	rjmp	.+1148   	; 0xc2d4 <FSettingPumpID+0x4ec>
    be58:	89 30       	cpi	r24, 0x09	; 9
    be5a:	09 f4       	brne	.+2      	; 0xbe5e <FSettingPumpID+0x76>
    be5c:	43 c2       	rjmp	.+1158   	; 0xc2e4 <FSettingPumpID+0x4fc>
    be5e:	8a 30       	cpi	r24, 0x0A	; 10
    be60:	09 f0       	breq	.+2      	; 0xbe64 <FSettingPumpID+0x7c>
    be62:	52 c2       	rjmp	.+1188   	; 0xc308 <FSettingPumpID+0x520>
    be64:	45 c2       	rjmp	.+1162   	; 0xc2f0 <FSettingPumpID+0x508>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    be66:	80 91 00 01 	lds	r24, 0x0100
    be6a:	82 30       	cpi	r24, 0x02	; 2
    be6c:	21 f4       	brne	.+8      	; 0xbe76 <FSettingPumpID+0x8e>
    be6e:	8f e1       	ldi	r24, 0x1F	; 31
    be70:	60 e0       	ldi	r22, 0x00	; 0
    be72:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    be76:	80 e1       	ldi	r24, 0x10	; 16
    be78:	92 e0       	ldi	r25, 0x02	; 2
    be7a:	65 e4       	ldi	r22, 0x45	; 69
    be7c:	70 e0       	ldi	r23, 0x00	; 0
    be7e:	48 e0       	ldi	r20, 0x08	; 8
    be80:	50 e0       	ldi	r21, 0x00	; 0
    be82:	24 e4       	ldi	r18, 0x44	; 68
    be84:	32 e1       	ldi	r19, 0x12	; 18
    be86:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    be8a:	49 c1       	rjmp	.+658    	; 0xc11e <FSettingPumpID+0x336>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    be8c:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    be90:	e0 e1       	ldi	r30, 0x10	; 16
    be92:	ee 2e       	mov	r14, r30
    be94:	e2 e0       	ldi	r30, 0x02	; 2
    be96:	fe 2e       	mov	r15, r30
    be98:	01 e0       	ldi	r16, 0x01	; 1
    be9a:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    be9c:	6e 01       	movw	r12, r28
    be9e:	08 94       	sec
    bea0:	c1 1c       	adc	r12, r1
    bea2:	d1 1c       	adc	r13, r1
    bea4:	76 e1       	ldi	r23, 0x16	; 22
    bea6:	a7 2e       	mov	r10, r23
    bea8:	7c e0       	ldi	r23, 0x0C	; 12
    beaa:	b7 2e       	mov	r11, r23
    beac:	8d b7       	in	r24, 0x3d	; 61
    beae:	9e b7       	in	r25, 0x3e	; 62
    beb0:	0c 97       	sbiw	r24, 0x0c	; 12
    beb2:	0f b6       	in	r0, 0x3f	; 63
    beb4:	f8 94       	cli
    beb6:	9e bf       	out	0x3e, r25	; 62
    beb8:	0f be       	out	0x3f, r0	; 63
    beba:	8d bf       	out	0x3d, r24	; 61
    bebc:	ed b7       	in	r30, 0x3d	; 61
    bebe:	fe b7       	in	r31, 0x3e	; 62
    bec0:	31 96       	adiw	r30, 0x01	; 1
    bec2:	ad b7       	in	r26, 0x3d	; 61
    bec4:	be b7       	in	r27, 0x3e	; 62
    bec6:	12 96       	adiw	r26, 0x02	; 2
    bec8:	dc 92       	st	X, r13
    beca:	ce 92       	st	-X, r12
    becc:	11 97       	sbiw	r26, 0x01	; 1
    bece:	b3 82       	std	Z+3, r11	; 0x03
    bed0:	a2 82       	std	Z+2, r10	; 0x02
    bed2:	15 83       	std	Z+5, r17	; 0x05
    bed4:	04 83       	std	Z+4, r16	; 0x04
    bed6:	d7 01       	movw	r26, r14
    bed8:	8c 91       	ld	r24, X
    beda:	86 83       	std	Z+6, r24	; 0x06
    bedc:	17 82       	std	Z+7, r1	; 0x07
    bede:	0c 5f       	subi	r16, 0xFC	; 252
    bee0:	1f 4f       	sbci	r17, 0xFF	; 255
    bee2:	11 87       	std	Z+9, r17	; 0x09
    bee4:	00 87       	std	Z+8, r16	; 0x08
    bee6:	04 50       	subi	r16, 0x04	; 4
    bee8:	10 40       	sbci	r17, 0x00	; 0
    beea:	14 96       	adiw	r26, 0x04	; 4
    beec:	8c 91       	ld	r24, X
    beee:	82 87       	std	Z+10, r24	; 0x0a
    bef0:	13 86       	std	Z+11, r1	; 0x0b
    bef2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    bef6:	ed b7       	in	r30, 0x3d	; 61
    bef8:	fe b7       	in	r31, 0x3e	; 62
    befa:	3c 96       	adiw	r30, 0x0c	; 12
    befc:	0f b6       	in	r0, 0x3f	; 63
    befe:	f8 94       	cli
    bf00:	fe bf       	out	0x3e, r31	; 62
    bf02:	0f be       	out	0x3f, r0	; 63
    bf04:	ed bf       	out	0x3d, r30	; 61
    bf06:	80 2f       	mov	r24, r16
    bf08:	61 e0       	ldi	r22, 0x01	; 1
    bf0a:	a6 01       	movw	r20, r12
    bf0c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    bf10:	08 94       	sec
    bf12:	e1 1c       	adc	r14, r1
    bf14:	f1 1c       	adc	r15, r1
    bf16:	0f 5f       	subi	r16, 0xFF	; 255
    bf18:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    bf1a:	f4 e1       	ldi	r31, 0x14	; 20
    bf1c:	ef 16       	cp	r14, r31
    bf1e:	f2 e0       	ldi	r31, 0x02	; 2
    bf20:	ff 06       	cpc	r15, r31
    bf22:	21 f6       	brne	.-120    	; 0xbeac <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    bf24:	83 e0       	ldi	r24, 0x03	; 3
    bf26:	6f e0       	ldi	r22, 0x0F	; 15
    bf28:	4f e0       	ldi	r20, 0x0F	; 15
    bf2a:	5c e0       	ldi	r21, 0x0C	; 12
    bf2c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    bf30:	84 e0       	ldi	r24, 0x04	; 4
    bf32:	6f e0       	ldi	r22, 0x0F	; 15
    bf34:	48 e0       	ldi	r20, 0x08	; 8
    bf36:	5c e0       	ldi	r21, 0x0C	; 12
    bf38:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          stMenuPumpID=mpSelectInput;
    bf3c:	82 e0       	ldi	r24, 0x02	; 2
    bf3e:	cf c1       	rjmp	.+926    	; 0xc2de <FSettingPumpID+0x4f6>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    bf40:	81 e0       	ldi	r24, 0x01	; 1
    bf42:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    bf46:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    bf48:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    bf4c:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    bf4e:	81 53       	subi	r24, 0x31	; 49
    bf50:	88 30       	cpi	r24, 0x08	; 8
    bf52:	08 f0       	brcs	.+2      	; 0xbf56 <FSettingPumpID+0x16e>
    bf54:	85 c0       	rjmp	.+266    	; 0xc060 <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    bf56:	80 91 00 01 	lds	r24, 0x0100
    bf5a:	81 30       	cpi	r24, 0x01	; 1
    bf5c:	19 f0       	breq	.+6      	; 0xbf64 <FSettingPumpID+0x17c>
    bf5e:	82 30       	cpi	r24, 0x02	; 2
    bf60:	a1 f5       	brne	.+104    	; 0xbfca <FSettingPumpID+0x1e2>
    bf62:	17 c0       	rjmp	.+46     	; 0xbf92 <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    bf64:	80 91 19 02 	lds	r24, 0x0219
    bf68:	88 23       	and	r24, r24
    bf6a:	41 f4       	brne	.+16     	; 0xbf7c <FSettingPumpID+0x194>
    bf6c:	e9 2f       	mov	r30, r25
    bf6e:	f0 e0       	ldi	r31, 0x00	; 0
    bf70:	e1 52       	subi	r30, 0x21	; 33
    bf72:	fe 4f       	sbci	r31, 0xFE	; 254
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    bf74:	80 81       	ld	r24, Z
    bf76:	83 36       	cpi	r24, 0x63	; 99
    bf78:	c8 f4       	brcc	.+50     	; 0xbfac <FSettingPumpID+0x1c4>
    bf7a:	16 c0       	rjmp	.+44     	; 0xbfa8 <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    bf7c:	81 30       	cpi	r24, 0x01	; 1
    bf7e:	29 f5       	brne	.+74     	; 0xbfca <FSettingPumpID+0x1e2>
    bf80:	e9 2f       	mov	r30, r25
    bf82:	f0 e0       	ldi	r31, 0x00	; 0
    bf84:	e1 52       	subi	r30, 0x21	; 33
    bf86:	fe 4f       	sbci	r31, 0xFE	; 254
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    bf88:	80 81       	ld	r24, Z
    bf8a:	88 23       	and	r24, r24
    bf8c:	d1 f4       	brne	.+52     	; 0xbfc2 <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    bf8e:	83 e6       	ldi	r24, 0x63	; 99
    bf90:	1b c0       	rjmp	.+54     	; 0xbfc8 <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    bf92:	80 91 19 02 	lds	r24, 0x0219
    bf96:	88 23       	and	r24, r24
    bf98:	59 f4       	brne	.+22     	; 0xbfb0 <FSettingPumpID+0x1c8>
    bf9a:	e9 2f       	mov	r30, r25
    bf9c:	f0 e0       	ldi	r31, 0x00	; 0
    bf9e:	e1 52       	subi	r30, 0x21	; 33
    bfa0:	fe 4f       	sbci	r31, 0xFE	; 254
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    bfa2:	80 81       	ld	r24, Z
    bfa4:	80 31       	cpi	r24, 0x10	; 16
    bfa6:	10 f4       	brcc	.+4      	; 0xbfac <FSettingPumpID+0x1c4>
	     (*Value)++;
    bfa8:	8f 5f       	subi	r24, 0xFF	; 255
    bfaa:	0e c0       	rjmp	.+28     	; 0xbfc8 <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    bfac:	10 82       	st	Z, r1
    bfae:	0d c0       	rjmp	.+26     	; 0xbfca <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    bfb0:	81 30       	cpi	r24, 0x01	; 1
    bfb2:	59 f4       	brne	.+22     	; 0xbfca <FSettingPumpID+0x1e2>
    bfb4:	e9 2f       	mov	r30, r25
    bfb6:	f0 e0       	ldi	r31, 0x00	; 0
    bfb8:	e1 52       	subi	r30, 0x21	; 33
    bfba:	fe 4f       	sbci	r31, 0xFE	; 254
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    bfbc:	80 81       	ld	r24, Z
    bfbe:	88 23       	and	r24, r24
    bfc0:	11 f0       	breq	.+4      	; 0xbfc6 <FSettingPumpID+0x1de>
	     (*Value)--;
    bfc2:	81 50       	subi	r24, 0x01	; 1
    bfc4:	01 c0       	rjmp	.+2      	; 0xbfc8 <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    bfc6:	80 e1       	ldi	r24, 0x10	; 16
    bfc8:	80 83       	st	Z, r24
    bfca:	60 e1       	ldi	r22, 0x10	; 16
    bfcc:	e6 2e       	mov	r14, r22
    bfce:	62 e0       	ldi	r22, 0x02	; 2
    bfd0:	f6 2e       	mov	r15, r22
    bfd2:	01 e0       	ldi	r16, 0x01	; 1
    bfd4:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    bfd6:	6e 01       	movw	r12, r28
    bfd8:	08 94       	sec
    bfda:	c1 1c       	adc	r12, r1
    bfdc:	d1 1c       	adc	r13, r1
    bfde:	54 ef       	ldi	r21, 0xF4	; 244
    bfe0:	a5 2e       	mov	r10, r21
    bfe2:	5b e0       	ldi	r21, 0x0B	; 11
    bfe4:	b5 2e       	mov	r11, r21
    bfe6:	8d b7       	in	r24, 0x3d	; 61
    bfe8:	9e b7       	in	r25, 0x3e	; 62
    bfea:	0c 97       	sbiw	r24, 0x0c	; 12
    bfec:	0f b6       	in	r0, 0x3f	; 63
    bfee:	f8 94       	cli
    bff0:	9e bf       	out	0x3e, r25	; 62
    bff2:	0f be       	out	0x3f, r0	; 63
    bff4:	8d bf       	out	0x3d, r24	; 61
    bff6:	ed b7       	in	r30, 0x3d	; 61
    bff8:	fe b7       	in	r31, 0x3e	; 62
    bffa:	31 96       	adiw	r30, 0x01	; 1
    bffc:	ad b7       	in	r26, 0x3d	; 61
    bffe:	be b7       	in	r27, 0x3e	; 62
    c000:	12 96       	adiw	r26, 0x02	; 2
    c002:	dc 92       	st	X, r13
    c004:	ce 92       	st	-X, r12
    c006:	11 97       	sbiw	r26, 0x01	; 1
    c008:	b3 82       	std	Z+3, r11	; 0x03
    c00a:	a2 82       	std	Z+2, r10	; 0x02
    c00c:	15 83       	std	Z+5, r17	; 0x05
    c00e:	04 83       	std	Z+4, r16	; 0x04
    c010:	d7 01       	movw	r26, r14
    c012:	8c 91       	ld	r24, X
    c014:	86 83       	std	Z+6, r24	; 0x06
    c016:	17 82       	std	Z+7, r1	; 0x07
    c018:	0c 5f       	subi	r16, 0xFC	; 252
    c01a:	1f 4f       	sbci	r17, 0xFF	; 255
    c01c:	11 87       	std	Z+9, r17	; 0x09
    c01e:	00 87       	std	Z+8, r16	; 0x08
    c020:	04 50       	subi	r16, 0x04	; 4
    c022:	10 40       	sbci	r17, 0x00	; 0
    c024:	14 96       	adiw	r26, 0x04	; 4
    c026:	8c 91       	ld	r24, X
    c028:	82 87       	std	Z+10, r24	; 0x0a
    c02a:	13 86       	std	Z+11, r1	; 0x0b
    c02c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    c030:	ed b7       	in	r30, 0x3d	; 61
    c032:	fe b7       	in	r31, 0x3e	; 62
    c034:	3c 96       	adiw	r30, 0x0c	; 12
    c036:	0f b6       	in	r0, 0x3f	; 63
    c038:	f8 94       	cli
    c03a:	fe bf       	out	0x3e, r31	; 62
    c03c:	0f be       	out	0x3f, r0	; 63
    c03e:	ed bf       	out	0x3d, r30	; 61
    c040:	80 2f       	mov	r24, r16
    c042:	61 e0       	ldi	r22, 0x01	; 1
    c044:	a6 01       	movw	r20, r12
    c046:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    c04a:	08 94       	sec
    c04c:	e1 1c       	adc	r14, r1
    c04e:	f1 1c       	adc	r15, r1
    c050:	0f 5f       	subi	r16, 0xFF	; 255
    c052:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    c054:	f4 e1       	ldi	r31, 0x14	; 20
    c056:	ef 16       	cp	r14, r31
    c058:	f2 e0       	ldi	r31, 0x02	; 2
    c05a:	ff 06       	cpc	r15, r31
    c05c:	21 f6       	brne	.-120    	; 0xbfe6 <FSettingPumpID+0x1fe>
    c05e:	2b c0       	rjmp	.+86     	; 0xc0b6 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    c060:	93 32       	cpi	r25, 0x23	; 35
    c062:	21 f5       	brne	.+72     	; 0xc0ac <FSettingPumpID+0x2c4>
    c064:	40 e0       	ldi	r20, 0x00	; 0
    c066:	20 e0       	ldi	r18, 0x00	; 0
    c068:	30 e0       	ldi	r19, 0x00	; 0
    c06a:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    c06c:	f9 01       	movw	r30, r18
    c06e:	e0 5f       	subi	r30, 0xF0	; 240
    c070:	fd 4f       	sbci	r31, 0xFD	; 253
    c072:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    c074:	ee 23       	and	r30, r30
    c076:	69 f0       	breq	.+26     	; 0xc092 <FSettingPumpID+0x2aa>
    c078:	a0 e1       	ldi	r26, 0x10	; 16
    c07a:	b2 e0       	ldi	r27, 0x02	; 2
    c07c:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    c07e:	59 17       	cp	r21, r25
    c080:	21 f0       	breq	.+8      	; 0xc08a <FSettingPumpID+0x2a2>
    c082:	8c 91       	ld	r24, X
    c084:	e8 17       	cp	r30, r24
    c086:	09 f4       	brne	.+2      	; 0xc08a <FSettingPumpID+0x2a2>
						       PumpCount++;
    c088:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    c08a:	9f 5f       	subi	r25, 0xFF	; 255
    c08c:	11 96       	adiw	r26, 0x01	; 1
    c08e:	98 30       	cpi	r25, 0x08	; 8
    c090:	b1 f7       	brne	.-20     	; 0xc07e <FSettingPumpID+0x296>
    c092:	2f 5f       	subi	r18, 0xFF	; 255
    c094:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    c096:	28 30       	cpi	r18, 0x08	; 8
    c098:	31 05       	cpc	r19, r1
    c09a:	39 f7       	brne	.-50     	; 0xc06a <FSettingPumpID+0x282>
    c09c:	40 93 0e 02 	sts	0x020E, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    c0a0:	44 23       	and	r20, r20
    c0a2:	11 f0       	breq	.+4      	; 0xc0a8 <FSettingPumpID+0x2c0>
    c0a4:	83 e0       	ldi	r24, 0x03	; 3
    c0a6:	05 c0       	rjmp	.+10     	; 0xc0b2 <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    c0a8:	85 e0       	ldi	r24, 0x05	; 5
    c0aa:	03 c0       	rjmp	.+6      	; 0xc0b2 <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    c0ac:	9a 32       	cpi	r25, 0x2A	; 42
    c0ae:	19 f4       	brne	.+6      	; 0xc0b6 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    c0b0:	8a e0       	ldi	r24, 0x0A	; 10
    c0b2:	80 93 1a 02 	sts	0x021A, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    c0b6:	8b e7       	ldi	r24, 0x7B	; 123
    c0b8:	98 16       	cp	r9, r24
    c0ba:	09 f0       	breq	.+2      	; 0xc0be <FSettingPumpID+0x2d6>
    c0bc:	25 c1       	rjmp	.+586    	; 0xc308 <FSettingPumpID+0x520>
		      if (IsShift==False)IsShift=True;
    c0be:	80 91 19 02 	lds	r24, 0x0219
    c0c2:	88 23       	and	r24, r24
    c0c4:	21 f4       	brne	.+8      	; 0xc0ce <FSettingPumpID+0x2e6>
    c0c6:	81 e0       	ldi	r24, 0x01	; 1
    c0c8:	80 93 19 02 	sts	0x0219, r24
    c0cc:	1d c1       	rjmp	.+570    	; 0xc308 <FSettingPumpID+0x520>
			  else
			  if (IsShift==True)IsShift=False;
    c0ce:	81 30       	cpi	r24, 0x01	; 1
    c0d0:	09 f0       	breq	.+2      	; 0xc0d4 <FSettingPumpID+0x2ec>
    c0d2:	1a c1       	rjmp	.+564    	; 0xc308 <FSettingPumpID+0x520>
    c0d4:	10 92 19 02 	sts	0x0219, r1
    c0d8:	17 c1       	rjmp	.+558    	; 0xc308 <FSettingPumpID+0x520>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    c0da:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    c0de:	81 e0       	ldi	r24, 0x01	; 1
    c0e0:	61 e0       	ldi	r22, 0x01	; 1
    c0e2:	4f ed       	ldi	r20, 0xDF	; 223
    c0e4:	5b e0       	ldi	r21, 0x0B	; 11
    c0e6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    c0ea:	82 e0       	ldi	r24, 0x02	; 2
    c0ec:	61 e0       	ldi	r22, 0x01	; 1
    c0ee:	4a ec       	ldi	r20, 0xCA	; 202
    c0f0:	5b e0       	ldi	r21, 0x0B	; 11
    c0f2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    c0f6:	83 e0       	ldi	r24, 0x03	; 3
    c0f8:	61 e0       	ldi	r22, 0x01	; 1
    c0fa:	45 eb       	ldi	r20, 0xB5	; 181
    c0fc:	5b e0       	ldi	r21, 0x0B	; 11
    c0fe:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c102:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c104:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c106:	82 e0       	ldi	r24, 0x02	; 2
    c108:	80 93 bc 01 	sts	0x01BC, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    c10c:	10 92 92 01 	sts	0x0192, r1
	      stMenuPumpID=mpDisplayFailed;
    c110:	84 e0       	ldi	r24, 0x04	; 4
    c112:	e5 c0       	rjmp	.+458    	; 0xc2de <FSettingPumpID+0x4f6>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    c114:	80 91 92 01 	lds	r24, 0x0192
    c118:	87 30       	cpi	r24, 0x07	; 7
    c11a:	08 f4       	brcc	.+2      	; 0xc11e <FSettingPumpID+0x336>
    c11c:	f5 c0       	rjmp	.+490    	; 0xc308 <FSettingPumpID+0x520>
    c11e:	81 e0       	ldi	r24, 0x01	; 1
    c120:	de c0       	rjmp	.+444    	; 0xc2de <FSettingPumpID+0x4f6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c122:	85 e4       	ldi	r24, 0x45	; 69
    c124:	90 e0       	ldi	r25, 0x00	; 0
    c126:	60 e1       	ldi	r22, 0x10	; 16
    c128:	72 e0       	ldi	r23, 0x02	; 2
    c12a:	48 e0       	ldi	r20, 0x08	; 8
    c12c:	50 e0       	ldi	r21, 0x00	; 0
    c12e:	2c e4       	ldi	r18, 0x4C	; 76
    c130:	32 e1       	ldi	r19, 0x12	; 18
    c132:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    c136:	80 91 00 01 	lds	r24, 0x0100
    c13a:	82 30       	cpi	r24, 0x02	; 2
    c13c:	e9 f4       	brne	.+58     	; 0xc178 <FSettingPumpID+0x390>
		      //SendConfig to Slave
			  lcd_clear();
    c13e:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    c142:	81 e0       	ldi	r24, 0x01	; 1
    c144:	61 e0       	ldi	r22, 0x01	; 1
    c146:	4c ea       	ldi	r20, 0xAC	; 172
    c148:	5b e0       	ldi	r21, 0x0B	; 11
    c14a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    c14e:	82 e0       	ldi	r24, 0x02	; 2
    c150:	61 e0       	ldi	r22, 0x01	; 1
    c152:	43 ea       	ldi	r20, 0xA3	; 163
    c154:	5b e0       	ldi	r21, 0x0B	; 11
    c156:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			  Idx=0;
    c15a:	10 92 18 02 	sts	0x0218, r1
			  PumpCount=0;
    c15e:	10 92 0e 02 	sts	0x020E, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    c162:	80 e1       	ldi	r24, 0x10	; 16
    c164:	92 e0       	ldi	r25, 0x02	; 2
    c166:	65 e4       	ldi	r22, 0x45	; 69
    c168:	70 e0       	ldi	r23, 0x00	; 0
    c16a:	48 e0       	ldi	r20, 0x08	; 8
    c16c:	50 e0       	ldi	r21, 0x00	; 0
    c16e:	24 e4       	ldi	r18, 0x44	; 68
    c170:	32 e1       	ldi	r19, 0x12	; 18
    c172:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    c176:	b2 c0       	rjmp	.+356    	; 0xc2dc <FSettingPumpID+0x4f4>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    c178:	81 30       	cpi	r24, 0x01	; 1
    c17a:	09 f0       	breq	.+2      	; 0xc17e <FSettingPumpID+0x396>
    c17c:	c5 c0       	rjmp	.+394    	; 0xc308 <FSettingPumpID+0x520>
    c17e:	b6 c0       	rjmp	.+364    	; 0xc2ec <FSettingPumpID+0x504>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    c180:	10 92 82 01 	sts	0x0182, r1
	      if (PPumpId[Idx]!=0){
    c184:	90 91 18 02 	lds	r25, 0x0218
    c188:	29 2f       	mov	r18, r25
    c18a:	30 e0       	ldi	r19, 0x00	; 0
    c18c:	f9 01       	movw	r30, r18
    c18e:	e0 5f       	subi	r30, 0xF0	; 240
    c190:	fd 4f       	sbci	r31, 0xFD	; 253
    c192:	60 81       	ld	r22, Z
    c194:	66 23       	and	r22, r22
    c196:	81 f0       	breq	.+32     	; 0xc1b8 <FSettingPumpID+0x3d0>
		      PumpCount++;
    c198:	80 91 0e 02 	lds	r24, 0x020E
    c19c:	8f 5f       	subi	r24, 0xFF	; 255
    c19e:	80 93 0e 02 	sts	0x020E, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    c1a2:	6f 70       	andi	r22, 0x0F	; 15
    c1a4:	44 e0       	ldi	r20, 0x04	; 4
    c1a6:	22 0f       	add	r18, r18
    c1a8:	33 1f       	adc	r19, r19
    c1aa:	4a 95       	dec	r20
    c1ac:	e1 f7       	brne	.-8      	; 0xc1a6 <FSettingPumpID+0x3be>
    c1ae:	62 2b       	or	r22, r18
    c1b0:	60 93 0f 02 	sts	0x020F, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    c1b4:	8d e1       	ldi	r24, 0x1D	; 29
    c1b6:	02 c0       	rjmp	.+4      	; 0xc1bc <FSettingPumpID+0x3d4>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    c1b8:	8e e1       	ldi	r24, 0x1E	; 30
    c1ba:	69 2f       	mov	r22, r25
    c1bc:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    c1c0:	e0 91 18 02 	lds	r30, 0x0218
    c1c4:	f0 e0       	ldi	r31, 0x00	; 0
    c1c6:	ad b7       	in	r26, 0x3d	; 61
    c1c8:	be b7       	in	r27, 0x3e	; 62
    c1ca:	18 97       	sbiw	r26, 0x08	; 8
    c1cc:	0f b6       	in	r0, 0x3f	; 63
    c1ce:	f8 94       	cli
    c1d0:	be bf       	out	0x3e, r27	; 62
    c1d2:	0f be       	out	0x3f, r0	; 63
    c1d4:	ad bf       	out	0x3d, r26	; 61
    c1d6:	2d b7       	in	r18, 0x3d	; 61
    c1d8:	3e b7       	in	r19, 0x3e	; 62
    c1da:	2f 5f       	subi	r18, 0xFF	; 255
    c1dc:	3f 4f       	sbci	r19, 0xFF	; 255
    c1de:	8e 01       	movw	r16, r28
    c1e0:	0f 5f       	subi	r16, 0xFF	; 255
    c1e2:	1f 4f       	sbci	r17, 0xFF	; 255
    c1e4:	12 96       	adiw	r26, 0x02	; 2
    c1e6:	1c 93       	st	X, r17
    c1e8:	0e 93       	st	-X, r16
    c1ea:	11 97       	sbiw	r26, 0x01	; 1
    c1ec:	85 e9       	ldi	r24, 0x95	; 149
    c1ee:	9b e0       	ldi	r25, 0x0B	; 11
    c1f0:	d9 01       	movw	r26, r18
    c1f2:	13 96       	adiw	r26, 0x03	; 3
    c1f4:	9c 93       	st	X, r25
    c1f6:	8e 93       	st	-X, r24
    c1f8:	12 97       	sbiw	r26, 0x02	; 2
    c1fa:	31 96       	adiw	r30, 0x01	; 1
    c1fc:	15 96       	adiw	r26, 0x05	; 5
    c1fe:	fc 93       	st	X, r31
    c200:	ee 93       	st	-X, r30
    c202:	14 97       	sbiw	r26, 0x04	; 4
    c204:	31 97       	sbiw	r30, 0x01	; 1
    c206:	e0 5f       	subi	r30, 0xF0	; 240
    c208:	fd 4f       	sbci	r31, 0xFD	; 253
    c20a:	80 81       	ld	r24, Z
    c20c:	16 96       	adiw	r26, 0x06	; 6
    c20e:	8c 93       	st	X, r24
    c210:	16 97       	sbiw	r26, 0x06	; 6
    c212:	17 96       	adiw	r26, 0x07	; 7
    c214:	1c 92       	st	X, r1
    c216:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    c21a:	ed b7       	in	r30, 0x3d	; 61
    c21c:	fe b7       	in	r31, 0x3e	; 62
    c21e:	38 96       	adiw	r30, 0x08	; 8
    c220:	0f b6       	in	r0, 0x3f	; 63
    c222:	f8 94       	cli
    c224:	fe bf       	out	0x3e, r31	; 62
    c226:	0f be       	out	0x3f, r0	; 63
    c228:	ed bf       	out	0x3d, r30	; 61
    c22a:	83 e0       	ldi	r24, 0x03	; 3
    c22c:	61 e0       	ldi	r22, 0x01	; 1
    c22e:	a8 01       	movw	r20, r16
    c230:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    c234:	88 e0       	ldi	r24, 0x08	; 8
    c236:	53 c0       	rjmp	.+166    	; 0xc2de <FSettingPumpID+0x4f6>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    c238:	81 e0       	ldi	r24, 0x01	; 1
    c23a:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    c23e:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  if (KeyChar=='*'){
    c242:	8a 32       	cpi	r24, 0x2A	; 42
    c244:	79 f4       	brne	.+30     	; 0xc264 <FSettingPumpID+0x47c>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c246:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c248:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c24a:	82 e0       	ldi	r24, 0x02	; 2
    c24c:	80 93 bc 01 	sts	0x01BC, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    c250:	61 e0       	ldi	r22, 0x01	; 1
    c252:	49 e8       	ldi	r20, 0x89	; 137
    c254:	5b e0       	ldi	r21, 0x0B	; 11
    c256:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			  TimDisplay=0;
    c25a:	10 92 92 01 	sts	0x0192, r1
		      stMenuPumpID=mpDelayExitPumpId;
    c25e:	89 e0       	ldi	r24, 0x09	; 9
    c260:	80 93 1a 02 	sts	0x021A, r24
			  }
          if (IsStandaloneAcknoledge==True){
    c264:	80 91 82 01 	lds	r24, 0x0182
    c268:	81 30       	cpi	r24, 0x01	; 1
    c26a:	09 f0       	breq	.+2      	; 0xc26e <FSettingPumpID+0x486>
    c26c:	4d c0       	rjmp	.+154    	; 0xc308 <FSettingPumpID+0x520>
		      Idx++;
    c26e:	80 91 18 02 	lds	r24, 0x0218
    c272:	8f 5f       	subi	r24, 0xFF	; 255
    c274:	80 93 18 02 	sts	0x0218, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    c278:	88 30       	cpi	r24, 0x08	; 8
    c27a:	10 f5       	brcc	.+68     	; 0xc2c0 <FSettingPumpID+0x4d8>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    c27c:	20 91 0e 02 	lds	r18, 0x020E
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c280:	e1 99       	sbic	0x1c, 1	; 28
    c282:	fe cf       	rjmp	.-4      	; 0xc280 <FSettingPumpID+0x498>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c284:	84 e4       	ldi	r24, 0x44	; 68
    c286:	91 e0       	ldi	r25, 0x01	; 1
    c288:	9f bb       	out	0x1f, r25	; 31
    c28a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c28c:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    c28e:	0f b6       	in	r0, 0x3f	; 63
    c290:	f8 94       	cli
    c292:	e2 9a       	sbi	0x1c, 2	; 28
    c294:	e1 9a       	sbi	0x1c, 1	; 28
    c296:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c298:	e1 99       	sbic	0x1c, 1	; 28
    c29a:	fe cf       	rjmp	.-4      	; 0xc298 <FSettingPumpID+0x4b0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c29c:	9f bb       	out	0x1f, r25	; 31
    c29e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c2a0:	e0 9a       	sbi	0x1c, 0	; 28
    c2a2:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    c2a4:	90 93 5c 01 	sts	0x015C, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c2a8:	85 e1       	ldi	r24, 0x15	; 21
    c2aa:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    c2ae:	90 93 d3 0b 	sts	0x0BD3, r25
     IsControlPooling=True;
    c2b2:	81 e0       	ldi	r24, 0x01	; 1
    c2b4:	80 93 84 01 	sts	0x0184, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    c2b8:	10 92 92 01 	sts	0x0192, r1
				  stMenuPumpID=mpDelaySaveConfig;
    c2bc:	87 e0       	ldi	r24, 0x07	; 7
    c2be:	0f c0       	rjmp	.+30     	; 0xc2de <FSettingPumpID+0x4f6>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    c2c0:	82 e0       	ldi	r24, 0x02	; 2
    c2c2:	61 e0       	ldi	r22, 0x01	; 1
    c2c4:	4f e7       	ldi	r20, 0x7F	; 127
    c2c6:	5b e0       	ldi	r21, 0x0B	; 11
    c2c8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					TimDisplay=0;
    c2cc:	10 92 92 01 	sts	0x0192, r1
				    stMenuPumpID=mpDelayExitPumpId;
    c2d0:	89 e0       	ldi	r24, 0x09	; 9
    c2d2:	05 c0       	rjmp	.+10     	; 0xc2de <FSettingPumpID+0x4f6>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    c2d4:	80 91 92 01 	lds	r24, 0x0192
    c2d8:	83 30       	cpi	r24, 0x03	; 3
    c2da:	b0 f0       	brcs	.+44     	; 0xc308 <FSettingPumpID+0x520>
    c2dc:	86 e0       	ldi	r24, 0x06	; 6
    c2de:	80 93 1a 02 	sts	0x021A, r24
    c2e2:	12 c0       	rjmp	.+36     	; 0xc308 <FSettingPumpID+0x520>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    c2e4:	80 91 92 01 	lds	r24, 0x0192
    c2e8:	89 30       	cpi	r24, 0x09	; 9
    c2ea:	70 f0       	brcs	.+28     	; 0xc308 <FSettingPumpID+0x520>
    c2ec:	8a e0       	ldi	r24, 0x0A	; 10
    c2ee:	f7 cf       	rjmp	.-18     	; 0xc2de <FSettingPumpID+0x4f6>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    c2f0:	80 91 00 01 	lds	r24, 0x0100
    c2f4:	82 30       	cpi	r24, 0x02	; 2
    c2f6:	21 f4       	brne	.+8      	; 0xc300 <FSettingPumpID+0x518>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    c2f8:	80 e2       	ldi	r24, 0x20	; 32
    c2fa:	60 e0       	ldi	r22, 0x00	; 0
    c2fc:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    c300:	10 92 1a 02 	sts	0x021A, r1
    c304:	81 e0       	ldi	r24, 0x01	; 1
    c306:	01 c0       	rjmp	.+2      	; 0xc30a <FSettingPumpID+0x522>
    c308:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    c30a:	64 96       	adiw	r28, 0x14	; 20
    c30c:	0f b6       	in	r0, 0x3f	; 63
    c30e:	f8 94       	cli
    c310:	de bf       	out	0x3e, r29	; 62
    c312:	0f be       	out	0x3f, r0	; 63
    c314:	cd bf       	out	0x3d, r28	; 61
    c316:	cf 91       	pop	r28
    c318:	df 91       	pop	r29
    c31a:	1f 91       	pop	r17
    c31c:	0f 91       	pop	r16
    c31e:	ff 90       	pop	r15
    c320:	ef 90       	pop	r14
    c322:	df 90       	pop	r13
    c324:	cf 90       	pop	r12
    c326:	bf 90       	pop	r11
    c328:	af 90       	pop	r10
    c32a:	9f 90       	pop	r9
    c32c:	08 95       	ret

0000c32e <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    c32e:	0e 94 f4 5e 	call	0xbde8	; 0xbde8 <FSettingPumpID>
    c332:	81 30       	cpi	r24, 0x01	; 1
    c334:	e1 f7       	brne	.-8      	; 0xc32e <_menu_pumpid>
	       break;
	   }	   
	}
}
    c336:	08 95       	ret

0000c338 <_menu_pump>:
        lcd_printf(4,15,PSTR("*)Exit"));
}



void _menu_pump(void){
    c338:	cf 93       	push	r28
    c33a:	df 93       	push	r29
    c33c:	c4 ec       	ldi	r28, 0xC4	; 196
    c33e:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    c340:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    c344:	ce 01       	movw	r24, r28
    c346:	01 97       	sbiw	r24, 0x01	; 1
    c348:	f1 f7       	brne	.-4      	; 0xc346 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    c34a:	81 e0       	ldi	r24, 0x01	; 1
    c34c:	61 e0       	ldi	r22, 0x01	; 1
    c34e:	43 eb       	ldi	r20, 0xB3	; 179
    c350:	5c e0       	ldi	r21, 0x0C	; 12
    c352:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    c356:	82 e0       	ldi	r24, 0x02	; 2
    c358:	61 e0       	ldi	r22, 0x01	; 1
    c35a:	49 ea       	ldi	r20, 0xA9	; 169
    c35c:	5c e0       	ldi	r21, 0x0C	; 12
    c35e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    c362:	84 e0       	ldi	r24, 0x04	; 4
    c364:	61 e0       	ldi	r22, 0x01	; 1
    c366:	42 ea       	ldi	r20, 0xA2	; 162
    c368:	5c e0       	ldi	r21, 0x0C	; 12
    c36a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>

		while(1){
			__key = _key_scan(1);
    c36e:	81 e0       	ldi	r24, 0x01	; 1
    c370:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
			if(__key == _KEY_CANCEL)
    c374:	87 3e       	cpi	r24, 0xE7	; 231
    c376:	51 f0       	breq	.+20     	; 0xc38c <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    c378:	8e 3e       	cpi	r24, 0xEE	; 238
    c37a:	19 f4       	brne	.+6      	; 0xc382 <_menu_pump+0x4a>
				_menu_pumpid();
    c37c:	0e 94 97 61 	call	0xc32e	; 0xc32e <_menu_pumpid>
    c380:	df cf       	rjmp	.-66     	; 0xc340 <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    c382:	8e 3d       	cpi	r24, 0xDE	; 222
    c384:	a1 f7       	brne	.-24     	; 0xc36e <_menu_pump+0x36>
				_menu_pumpprod();
    c386:	0e 94 4e 4e 	call	0x9c9c	; 0x9c9c <_menu_pumpprod>
    c38a:	da cf       	rjmp	.-76     	; 0xc340 <_menu_pump+0x8>
				break;
			}
		}
	}
}
    c38c:	df 91       	pop	r29
    c38e:	cf 91       	pop	r28
    c390:	08 95       	ret

0000c392 <FMenuPumpType>:





void FMenuPumpType(){
    c392:	cf 92       	push	r12
    c394:	df 92       	push	r13
    c396:	ef 92       	push	r14
    c398:	ff 92       	push	r15
    c39a:	0f 93       	push	r16
    c39c:	1f 93       	push	r17
    c39e:	df 93       	push	r29
    c3a0:	cf 93       	push	r28
    c3a2:	cd b7       	in	r28, 0x3d	; 61
    c3a4:	de b7       	in	r29, 0x3e	; 62
    c3a6:	a8 97       	sbiw	r28, 0x28	; 40
    c3a8:	0f b6       	in	r0, 0x3f	; 63
    c3aa:	f8 94       	cli
    c3ac:	de bf       	out	0x3e, r29	; 62
    c3ae:	0f be       	out	0x3f, r0	; 63
    c3b0:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    c3b2:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    c3b6:	81 e0       	ldi	r24, 0x01	; 1
    c3b8:	61 e0       	ldi	r22, 0x01	; 1
    c3ba:	40 e9       	ldi	r20, 0x90	; 144
    c3bc:	5c e0       	ldi	r21, 0x0C	; 12
    c3be:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c3c2:	e1 99       	sbic	0x1c, 1	; 28
    c3c4:	fe cf       	rjmp	.-4      	; 0xc3c2 <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c3c6:	87 e3       	ldi	r24, 0x37	; 55
    c3c8:	91 e0       	ldi	r25, 0x01	; 1
    c3ca:	9f bb       	out	0x1f, r25	; 31
    c3cc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c3ce:	e0 9a       	sbi	0x1c, 0	; 28
    c3d0:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    c3d2:	03 30       	cpi	r16, 0x03	; 3
    c3d4:	08 f0       	brcs	.+2      	; 0xc3d8 <FMenuPumpType+0x46>
    c3d6:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    c3d8:	10 e0       	ldi	r17, 0x00	; 0
    c3da:	f8 01       	movw	r30, r16
    c3dc:	ee 0f       	add	r30, r30
    c3de:	ff 1f       	adc	r31, r31
    c3e0:	eb 50       	subi	r30, 0x0B	; 11
    c3e2:	fd 4f       	sbci	r31, 0xFD	; 253
    c3e4:	65 91       	lpm	r22, Z+
    c3e6:	74 91       	lpm	r23, Z+
    c3e8:	f5 e1       	ldi	r31, 0x15	; 21
    c3ea:	cf 2e       	mov	r12, r31
    c3ec:	d1 2c       	mov	r13, r1
    c3ee:	cc 0e       	add	r12, r28
    c3f0:	dd 1e       	adc	r13, r29
    c3f2:	c6 01       	movw	r24, r12
    c3f4:	0e 94 dc a9 	call	0x153b8	; 0x153b8 <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    c3f8:	8d b7       	in	r24, 0x3d	; 61
    c3fa:	9e b7       	in	r25, 0x3e	; 62
    c3fc:	08 97       	sbiw	r24, 0x08	; 8
    c3fe:	0f b6       	in	r0, 0x3f	; 63
    c400:	f8 94       	cli
    c402:	9e bf       	out	0x3e, r25	; 62
    c404:	0f be       	out	0x3f, r0	; 63
    c406:	8d bf       	out	0x3d, r24	; 61
    c408:	ed b7       	in	r30, 0x3d	; 61
    c40a:	fe b7       	in	r31, 0x3e	; 62
    c40c:	31 96       	adiw	r30, 0x01	; 1
    c40e:	7e 01       	movw	r14, r28
    c410:	08 94       	sec
    c412:	e1 1c       	adc	r14, r1
    c414:	f1 1c       	adc	r15, r1
    c416:	ad b7       	in	r26, 0x3d	; 61
    c418:	be b7       	in	r27, 0x3e	; 62
    c41a:	12 96       	adiw	r26, 0x02	; 2
    c41c:	fc 92       	st	X, r15
    c41e:	ee 92       	st	-X, r14
    c420:	11 97       	sbiw	r26, 0x01	; 1
    c422:	8a e8       	ldi	r24, 0x8A	; 138
    c424:	9c e0       	ldi	r25, 0x0C	; 12
    c426:	93 83       	std	Z+3, r25	; 0x03
    c428:	82 83       	std	Z+2, r24	; 0x02
    c42a:	0f 5f       	subi	r16, 0xFF	; 255
    c42c:	1f 4f       	sbci	r17, 0xFF	; 255
    c42e:	15 83       	std	Z+5, r17	; 0x05
    c430:	04 83       	std	Z+4, r16	; 0x04
    c432:	d7 82       	std	Z+7, r13	; 0x07
    c434:	c6 82       	std	Z+6, r12	; 0x06
    c436:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			   lcd_print(2,1,lcdteks);
    c43a:	8d b7       	in	r24, 0x3d	; 61
    c43c:	9e b7       	in	r25, 0x3e	; 62
    c43e:	08 96       	adiw	r24, 0x08	; 8
    c440:	0f b6       	in	r0, 0x3f	; 63
    c442:	f8 94       	cli
    c444:	9e bf       	out	0x3e, r25	; 62
    c446:	0f be       	out	0x3f, r0	; 63
    c448:	8d bf       	out	0x3d, r24	; 61
    c44a:	82 e0       	ldi	r24, 0x02	; 2
    c44c:	61 e0       	ldi	r22, 0x01	; 1
    c44e:	a7 01       	movw	r20, r14
    c450:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    c454:	84 e0       	ldi	r24, 0x04	; 4
    c456:	61 e0       	ldi	r22, 0x01	; 1
    c458:	46 e7       	ldi	r20, 0x76	; 118
    c45a:	5c e0       	ldi	r21, 0x0C	; 12
    c45c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   if (IFType==IT_STANDALONE)
    c460:	80 91 00 01 	lds	r24, 0x0100
    c464:	82 30       	cpi	r24, 0x02	; 2
    c466:	21 f4       	brne	.+8      	; 0xc470 <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    c468:	8f e1       	ldi	r24, 0x1F	; 31
    c46a:	60 e0       	ldi	r22, 0x00	; 0
    c46c:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    c470:	81 e0       	ldi	r24, 0x01	; 1
    c472:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    c476:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>

			   if (KeyChar=='#'){
    c47a:	83 32       	cpi	r24, 0x23	; 35
    c47c:	09 f0       	breq	.+2      	; 0xc480 <FMenuPumpType+0xee>
    c47e:	2d c0       	rjmp	.+90     	; 0xc4da <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c480:	e1 99       	sbic	0x1c, 1	; 28
    c482:	fe cf       	rjmp	.-4      	; 0xc480 <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c484:	07 e3       	ldi	r16, 0x37	; 55
    c486:	11 e0       	ldi	r17, 0x01	; 1
    c488:	1f bb       	out	0x1f, r17	; 31
    c48a:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c48c:	e0 9a       	sbi	0x1c, 0	; 28
    c48e:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    c490:	82 30       	cpi	r24, 0x02	; 2
    c492:	20 f4       	brcc	.+8      	; 0xc49c <FMenuPumpType+0x10a>
				        DispenserBrand++;
    c494:	8f 5f       	subi	r24, 0xFF	; 255
    c496:	80 93 5e 01 	sts	0x015E, r24
    c49a:	02 c0       	rjmp	.+4      	; 0xc4a0 <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    c49c:	10 92 5e 01 	sts	0x015E, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    c4a0:	80 91 5e 01 	lds	r24, 0x015E
    c4a4:	0e 94 aa 19 	call	0x3354	; 0x3354 <SetDispenser>
			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    c4a8:	80 91 5e 01 	lds	r24, 0x015E
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c4ac:	e1 99       	sbic	0x1c, 1	; 28
    c4ae:	fe cf       	rjmp	.-4      	; 0xc4ac <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4b0:	1f bb       	out	0x1f, r17	; 31
    c4b2:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    c4b4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c4b6:	0f b6       	in	r0, 0x3f	; 63
    c4b8:	f8 94       	cli
    c4ba:	e2 9a       	sbi	0x1c, 2	; 28
    c4bc:	e1 9a       	sbi	0x1c, 1	; 28
    c4be:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c4c0:	e1 99       	sbic	0x1c, 1	; 28
    c4c2:	fe cf       	rjmp	.-4      	; 0xc4c0 <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4c4:	1f bb       	out	0x1f, r17	; 31
    c4c6:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c4c8:	e0 9a       	sbi	0x1c, 0	; 28
    c4ca:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    c4cc:	8c e1       	ldi	r24, 0x1C	; 28
    c4ce:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    c4d2:	81 e0       	ldi	r24, 0x01	; 1
    c4d4:	80 93 23 01 	sts	0x0123, r24
    c4d8:	0c c0       	rjmp	.+24     	; 0xc4f2 <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    c4da:	8a 32       	cpi	r24, 0x2A	; 42
    c4dc:	09 f0       	breq	.+2      	; 0xc4e0 <FMenuPumpType+0x14e>
    c4de:	c8 cf       	rjmp	.-112    	; 0xc470 <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    c4e0:	80 91 00 01 	lds	r24, 0x0100
    c4e4:	82 30       	cpi	r24, 0x02	; 2
    c4e6:	51 f4       	brne	.+20     	; 0xc4fc <FMenuPumpType+0x16a>
    c4e8:	80 e2       	ldi	r24, 0x20	; 32
    c4ea:	60 e0       	ldi	r22, 0x00	; 0
    c4ec:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
    c4f0:	05 c0       	rjmp	.+10     	; 0xc4fc <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    c4f2:	80 91 23 01 	lds	r24, 0x0123
    c4f6:	81 30       	cpi	r24, 0x01	; 1
    c4f8:	e1 f7       	brne	.-8      	; 0xc4f2 <FMenuPumpType+0x160>
    c4fa:	5b cf       	rjmp	.-330    	; 0xc3b2 <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    c4fc:	a8 96       	adiw	r28, 0x28	; 40
    c4fe:	0f b6       	in	r0, 0x3f	; 63
    c500:	f8 94       	cli
    c502:	de bf       	out	0x3e, r29	; 62
    c504:	0f be       	out	0x3f, r0	; 63
    c506:	cd bf       	out	0x3d, r28	; 61
    c508:	cf 91       	pop	r28
    c50a:	df 91       	pop	r29
    c50c:	1f 91       	pop	r17
    c50e:	0f 91       	pop	r16
    c510:	ff 90       	pop	r15
    c512:	ef 90       	pop	r14
    c514:	df 90       	pop	r13
    c516:	cf 90       	pop	r12
    c518:	08 95       	ret

0000c51a <FSettingPump>:
	      break;
	 
	 }
*/
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    c51a:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    c51e:	84 ec       	ldi	r24, 0xC4	; 196
    c520:	99 e0       	ldi	r25, 0x09	; 9
    c522:	01 97       	sbiw	r24, 0x01	; 1
    c524:	f1 f7       	brne	.-4      	; 0xc522 <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    c526:	81 e0       	ldi	r24, 0x01	; 1
    c528:	61 e0       	ldi	r22, 0x01	; 1
    c52a:	4f e0       	ldi	r20, 0x0F	; 15
    c52c:	51 e1       	ldi	r21, 0x11	; 17
    c52e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    c532:	82 e0       	ldi	r24, 0x02	; 2
    c534:	61 e0       	ldi	r22, 0x01	; 1
    c536:	45 e0       	ldi	r20, 0x05	; 5
    c538:	51 e1       	ldi	r21, 0x11	; 17
    c53a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		if (IFType==IT_STANDALONE){
    c53e:	80 91 00 01 	lds	r24, 0x0100
    c542:	82 30       	cpi	r24, 0x02	; 2
    c544:	61 f4       	brne	.+24     	; 0xc55e <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    c546:	83 e0       	ldi	r24, 0x03	; 3
    c548:	61 e0       	ldi	r22, 0x01	; 1
    c54a:	4b ef       	ldi	r20, 0xFB	; 251
    c54c:	50 e1       	ldi	r21, 0x10	; 16
    c54e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    c552:	84 e0       	ldi	r24, 0x04	; 4
    c554:	61 e0       	ldi	r22, 0x01	; 1
    c556:	4b ee       	ldi	r20, 0xEB	; 235
    c558:	50 e1       	ldi	r21, 0x10	; 16
    c55a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    c55e:	81 e0       	ldi	r24, 0x01	; 1
    c560:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
			if(__key == _KEY_CANCEL)
    c564:	87 3e       	cpi	r24, 0xE7	; 231
    c566:	d9 f0       	breq	.+54     	; 0xc59e <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    c568:	8e 3e       	cpi	r24, 0xEE	; 238
    c56a:	19 f4       	brne	.+6      	; 0xc572 <FSettingPump+0x58>
				_menu_pumpid();
    c56c:	0e 94 97 61 	call	0xc32e	; 0xc32e <_menu_pumpid>
    c570:	16 c0       	rjmp	.+44     	; 0xc59e <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    c572:	8e 3d       	cpi	r24, 0xDE	; 222
    c574:	19 f4       	brne	.+6      	; 0xc57c <FSettingPump+0x62>
				_menu_pumpprod();
    c576:	0e 94 4e 4e 	call	0x9c9c	; 0x9c9c <_menu_pumpprod>
    c57a:	11 c0       	rjmp	.+34     	; 0xc59e <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    c57c:	8e 3b       	cpi	r24, 0xBE	; 190
    c57e:	39 f4       	brne	.+14     	; 0xc58e <FSettingPump+0x74>
    c580:	80 91 00 01 	lds	r24, 0x0100
    c584:	82 30       	cpi	r24, 0x02	; 2
    c586:	59 f7       	brne	.-42     	; 0xc55e <FSettingPump+0x44>
			    FMenuPumpLabel();
    c588:	0e 94 61 4e 	call	0x9cc2	; 0x9cc2 <FMenuPumpLabel>
    c58c:	08 c0       	rjmp	.+16     	; 0xc59e <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    c58e:	8d 3e       	cpi	r24, 0xED	; 237
    c590:	31 f7       	brne	.-52     	; 0xc55e <FSettingPump+0x44>
    c592:	80 91 00 01 	lds	r24, 0x0100
    c596:	82 30       	cpi	r24, 0x02	; 2
    c598:	11 f7       	brne	.-60     	; 0xc55e <FSettingPump+0x44>
			    FMenuPumpType();
    c59a:	0e 94 c9 61 	call	0xc392	; 0xc392 <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    c59e:	81 e0       	ldi	r24, 0x01	; 1
    c5a0:	08 95       	ret

0000c5a2 <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    c5a2:	2f 92       	push	r2
    c5a4:	3f 92       	push	r3
    c5a6:	4f 92       	push	r4
    c5a8:	5f 92       	push	r5
    c5aa:	6f 92       	push	r6
    c5ac:	7f 92       	push	r7
    c5ae:	8f 92       	push	r8
    c5b0:	9f 92       	push	r9
    c5b2:	af 92       	push	r10
    c5b4:	bf 92       	push	r11
    c5b6:	cf 92       	push	r12
    c5b8:	df 92       	push	r13
    c5ba:	ef 92       	push	r14
    c5bc:	ff 92       	push	r15
    c5be:	0f 93       	push	r16
    c5c0:	1f 93       	push	r17
    c5c2:	df 93       	push	r29
    c5c4:	cf 93       	push	r28
    c5c6:	cd b7       	in	r28, 0x3d	; 61
    c5c8:	de b7       	in	r29, 0x3e	; 62
    c5ca:	e1 97       	sbiw	r28, 0x31	; 49
    c5cc:	0f b6       	in	r0, 0x3f	; 63
    c5ce:	f8 94       	cli
    c5d0:	de bf       	out	0x3e, r29	; 62
    c5d2:	0f be       	out	0x3f, r0	; 63
    c5d4:	cd bf       	out	0x3d, r28	; 61
    c5d6:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c5d8:	dc 01       	movw	r26, r24
    c5da:	12 96       	adiw	r26, 0x02	; 2
    c5dc:	8c 91       	ld	r24, X
    c5de:	12 97       	sbiw	r26, 0x02	; 2
    c5e0:	89 83       	std	Y+1, r24	; 0x01
    c5e2:	13 96       	adiw	r26, 0x03	; 3
    c5e4:	8c 91       	ld	r24, X
    c5e6:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    c5e8:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    c5ea:	8e 01       	movw	r16, r28
    c5ec:	0f 5f       	subi	r16, 0xFF	; 255
    c5ee:	1f 4f       	sbci	r17, 0xFF	; 255
    c5f0:	c8 01       	movw	r24, r16
    c5f2:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    c5f6:	c8 01       	movw	r24, r16
    c5f8:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
    c5fc:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    c5fe:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
    c602:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    c604:	88 23       	and	r24, r24
    c606:	09 f4       	brne	.+2      	; 0xc60a <StoreStandaloneTransData+0x68>
    c608:	1a c2       	rjmp	.+1076   	; 0xca3e <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    c60a:	f7 01       	movw	r30, r14
    c60c:	f4 81       	ldd	r31, Z+4	; 0x04
    c60e:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    c610:	d7 01       	movw	r26, r14
    c612:	15 96       	adiw	r26, 0x05	; 5
    c614:	2c 90       	ld	r2, X
    c616:	84 e0       	ldi	r24, 0x04	; 4
    c618:	88 2e       	mov	r8, r24
    c61a:	91 2c       	mov	r9, r1
    c61c:	8c 0e       	add	r8, r28
    c61e:	9d 1e       	adc	r9, r29
    c620:	f4 01       	movw	r30, r8
    c622:	ce 01       	movw	r24, r28
    c624:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    c626:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    c628:	e8 17       	cp	r30, r24
    c62a:	f9 07       	cpc	r31, r25
    c62c:	e1 f7       	brne	.-8      	; 0xc626 <StoreStandaloneTransData+0x84>
    c62e:	0d e1       	ldi	r16, 0x1D	; 29
    c630:	60 2e       	mov	r6, r16
    c632:	71 2c       	mov	r7, r1
    c634:	6c 0e       	add	r6, r28
    c636:	7d 1e       	adc	r7, r29
    c638:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    c63a:	ce 01       	movw	r24, r28
    c63c:	87 96       	adiw	r24, 0x27	; 39
    c63e:	f9 01       	movw	r30, r18
    c640:	11 92       	st	Z+, r1
    c642:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    c644:	e8 17       	cp	r30, r24
    c646:	f9 07       	cpc	r31, r25
    c648:	d1 f7       	brne	.-12     	; 0xc63e <StoreStandaloneTransData+0x9c>
    c64a:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    c64c:	ce 01       	movw	r24, r28
    c64e:	c1 96       	adiw	r24, 0x31	; 49
    c650:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    c652:	e8 17       	cp	r30, r24
    c654:	f9 07       	cpc	r31, r25
    c656:	e1 f7       	brne	.-8      	; 0xc650 <StoreStandaloneTransData+0xae>
    c658:	a7 01       	movw	r20, r14
    c65a:	d7 01       	movw	r26, r14
    c65c:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c65e:	be 01       	movw	r22, r28
    c660:	66 5f       	subi	r22, 0xF6	; 246
    c662:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    c664:	16 96       	adiw	r26, 0x06	; 6
    c666:	8c 91       	ld	r24, X
    c668:	16 97       	sbiw	r26, 0x06	; 6
    c66a:	81 93       	st	Z+, r24
    c66c:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c66e:	e6 17       	cp	r30, r22
    c670:	f7 07       	cpc	r31, r23
    c672:	c1 f7       	brne	.-16     	; 0xc664 <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c674:	1a 86       	std	Y+10, r1	; 0x0a
    c676:	d7 01       	movw	r26, r14
    c678:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c67a:	be 01       	movw	r22, r28
    c67c:	6b 5d       	subi	r22, 0xDB	; 219
    c67e:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    c680:	1c 96       	adiw	r26, 0x0c	; 12
    c682:	8c 91       	ld	r24, X
    c684:	1c 97       	sbiw	r26, 0x0c	; 12
    c686:	81 93       	st	Z+, r24
    c688:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c68a:	e6 17       	cp	r30, r22
    c68c:	f7 07       	cpc	r31, r23
    c68e:	c1 f7       	brne	.-16     	; 0xc680 <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c690:	1d a2       	std	Y+37, r1	; 0x25
    c692:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c694:	be 01       	movw	r22, r28
    c696:	69 5d       	subi	r22, 0xD9	; 217
    c698:	7f 4f       	sbci	r23, 0xFF	; 255
    c69a:	9e 01       	movw	r18, r28
    c69c:	21 5d       	subi	r18, 0xD1	; 209
    c69e:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    c6a0:	da 01       	movw	r26, r20
    c6a2:	54 96       	adiw	r26, 0x14	; 20
    c6a4:	8c 91       	ld	r24, X
    c6a6:	81 93       	st	Z+, r24
    c6a8:	4f 5f       	subi	r20, 0xFF	; 255
    c6aa:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c6ac:	e2 17       	cp	r30, r18
    c6ae:	f3 07       	cpc	r31, r19
    c6b0:	b9 f7       	brne	.-18     	; 0xc6a0 <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c6b2:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    c6b4:	f7 01       	movw	r30, r14
    c6b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    c6b8:	80 53       	subi	r24, 0x30	; 48
    c6ba:	8a 30       	cpi	r24, 0x0A	; 10
    c6bc:	98 f4       	brcc	.+38     	; 0xc6e4 <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //uart_print(1,1,strSend);
		 if  (TransDigit==8){
    c6be:	88 30       	cpi	r24, 0x08	; 8
    c6c0:	89 f4       	brne	.+34     	; 0xc6e4 <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    c6c2:	fb 01       	movw	r30, r22
    c6c4:	01 90       	ld	r0, Z+
    c6c6:	00 20       	and	r0, r0
    c6c8:	e9 f7       	brne	.-6      	; 0xc6c4 <StoreStandaloneTransData+0x122>
    c6ca:	e6 1b       	sub	r30, r22
    c6cc:	f7 0b       	sbc	r31, r23
    c6ce:	32 97       	sbiw	r30, 0x02	; 2
    c6d0:	80 e0       	ldi	r24, 0x00	; 0
    c6d2:	90 e0       	ldi	r25, 0x00	; 0
    c6d4:	01 c0       	rjmp	.+2      	; 0xc6d8 <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c6d6:	01 96       	adiw	r24, 0x01	; 1
    c6d8:	8e 17       	cp	r24, r30
    c6da:	9f 07       	cpc	r25, r31
    c6dc:	e0 f3       	brcs	.-8      	; 0xc6d6 <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c6de:	ec 0f       	add	r30, r28
    c6e0:	fd 1f       	adc	r31, r29
    c6e2:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    c6e4:	14 e0       	ldi	r17, 0x04	; 4
    c6e6:	e1 2e       	mov	r14, r17
    c6e8:	f1 2c       	mov	r15, r1
    c6ea:	ec 0e       	add	r14, r28
    c6ec:	fd 1e       	adc	r15, r29
    c6ee:	c7 01       	movw	r24, r14
    c6f0:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		 RemZeroLead(strPVolume);
    c6f4:	bd e1       	ldi	r27, 0x1D	; 29
    c6f6:	ab 2e       	mov	r10, r27
    c6f8:	b1 2c       	mov	r11, r1
    c6fa:	ac 0e       	add	r10, r28
    c6fc:	bd 1e       	adc	r11, r29
    c6fe:	c5 01       	movw	r24, r10
    c700:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		 RemZeroLead(strPMoney);
    c704:	8e 01       	movw	r16, r28
    c706:	09 5d       	subi	r16, 0xD9	; 217
    c708:	1f 4f       	sbci	r17, 0xFF	; 255
    c70a:	c8 01       	movw	r24, r16
    c70c:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    c710:	c8 01       	movw	r24, r16
    c712:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
    c716:	89 2b       	or	r24, r25
    c718:	09 f0       	breq	.+2      	; 0xc71c <StoreStandaloneTransData+0x17a>
    c71a:	46 c1       	rjmp	.+652    	; 0xc9a8 <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    c71c:	83 2d       	mov	r24, r3
    c71e:	8f 70       	andi	r24, 0x0F	; 15
    c720:	63 e1       	ldi	r22, 0x13	; 19
    c722:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
    c726:	8b c1       	rjmp	.+790    	; 0xca3e <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c728:	e1 99       	sbic	0x1c, 1	; 28
    c72a:	fe cf       	rjmp	.-4      	; 0xc728 <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c72c:	8f e3       	ldi	r24, 0x3F	; 63
    c72e:	91 e0       	ldi	r25, 0x01	; 1
    c730:	9f bb       	out	0x1f, r25	; 31
    c732:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c734:	e0 9a       	sbi	0x1c, 0	; 28
    c736:	2d b3       	in	r18, 0x1d	; 29
			 //uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    c738:	00 d0       	rcall	.+0      	; 0xc73a <StoreStandaloneTransData+0x198>
    c73a:	00 d0       	rcall	.+0      	; 0xc73c <StoreStandaloneTransData+0x19a>
    c73c:	00 d0       	rcall	.+0      	; 0xc73e <StoreStandaloneTransData+0x19c>
    c73e:	ed b7       	in	r30, 0x3d	; 61
    c740:	fe b7       	in	r31, 0x3e	; 62
    c742:	31 96       	adiw	r30, 0x01	; 1
    c744:	88 e6       	ldi	r24, 0x68	; 104
    c746:	9c e0       	ldi	r25, 0x0C	; 12
    c748:	ad b7       	in	r26, 0x3d	; 61
    c74a:	be b7       	in	r27, 0x3e	; 62
    c74c:	12 96       	adiw	r26, 0x02	; 2
    c74e:	9c 93       	st	X, r25
    c750:	8e 93       	st	-X, r24
    c752:	11 97       	sbiw	r26, 0x01	; 1
    c754:	8e e5       	ldi	r24, 0x5E	; 94
    c756:	91 e2       	ldi	r25, 0x21	; 33
    c758:	93 83       	std	Z+3, r25	; 0x03
    c75a:	82 83       	std	Z+2, r24	; 0x02
    c75c:	24 83       	std	Z+4, r18	; 0x04
    c75e:	15 82       	std	Z+5, r1	; 0x05
    c760:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    c764:	e7 e8       	ldi	r30, 0x87	; 135
    c766:	fc e0       	ldi	r31, 0x0C	; 12
    c768:	df 01       	movw	r26, r30
    c76a:	0d 90       	ld	r0, X+
    c76c:	00 20       	and	r0, r0
    c76e:	e9 f7       	brne	.-6      	; 0xc76a <StoreStandaloneTransData+0x1c8>
    c770:	9d 01       	movw	r18, r26
    c772:	21 50       	subi	r18, 0x01	; 1
    c774:	30 40       	sbci	r19, 0x00	; 0
    c776:	2e 1b       	sub	r18, r30
    c778:	3f 0b       	sbc	r19, r31
    c77a:	85 e3       	ldi	r24, 0x35	; 53
    c77c:	90 e0       	ldi	r25, 0x00	; 0
    c77e:	c8 9e       	mul	r12, r24
    c780:	d0 01       	movw	r26, r0
    c782:	c9 9e       	mul	r12, r25
    c784:	b0 0d       	add	r27, r0
    c786:	d8 9e       	mul	r13, r24
    c788:	b0 0d       	add	r27, r0
    c78a:	11 24       	eor	r1, r1
    c78c:	a5 55       	subi	r26, 0x55	; 85
    c78e:	ba 4f       	sbci	r27, 0xFA	; 250
    c790:	4d b7       	in	r20, 0x3d	; 61
    c792:	5e b7       	in	r21, 0x3e	; 62
    c794:	4a 5f       	subi	r20, 0xFA	; 250
    c796:	5f 4f       	sbci	r21, 0xFF	; 255
    c798:	0f b6       	in	r0, 0x3f	; 63
    c79a:	f8 94       	cli
    c79c:	5e bf       	out	0x3e, r21	; 62
    c79e:	0f be       	out	0x3f, r0	; 63
    c7a0:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c7a2:	a9 01       	movw	r20, r18
    c7a4:	4e 0f       	add	r20, r30
    c7a6:	5f 1f       	adc	r21, r31
    c7a8:	02 c0       	rjmp	.+4      	; 0xc7ae <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    c7aa:	81 91       	ld	r24, Z+
    c7ac:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c7ae:	e4 17       	cp	r30, r20
    c7b0:	f5 07       	cpc	r31, r21
    c7b2:	d9 f7       	brne	.-10     	; 0xc7aa <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c7b4:	85 e3       	ldi	r24, 0x35	; 53
    c7b6:	90 e0       	ldi	r25, 0x00	; 0
    c7b8:	dc 01       	movw	r26, r24
    c7ba:	ca 9e       	mul	r12, r26
    c7bc:	c0 01       	movw	r24, r0
    c7be:	cb 9e       	mul	r12, r27
    c7c0:	90 0d       	add	r25, r0
    c7c2:	da 9e       	mul	r13, r26
    c7c4:	90 0d       	add	r25, r0
    c7c6:	11 24       	eor	r1, r1
    c7c8:	fc 01       	movw	r30, r24
    c7ca:	e8 55       	subi	r30, 0x58	; 88
    c7cc:	fa 4f       	sbci	r31, 0xFA	; 250
    c7ce:	e2 0f       	add	r30, r18
    c7d0:	f3 1f       	adc	r31, r19
    c7d2:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    c7d4:	fe 01       	movw	r30, r28
    c7d6:	3b 96       	adiw	r30, 0x0b	; 11
    c7d8:	df 01       	movw	r26, r30
    c7da:	0d 90       	ld	r0, X+
    c7dc:	00 20       	and	r0, r0
    c7de:	e9 f7       	brne	.-6      	; 0xc7da <StoreStandaloneTransData+0x238>
    c7e0:	11 97       	sbiw	r26, 0x01	; 1
    c7e2:	ae 1b       	sub	r26, r30
    c7e4:	bf 0b       	sbc	r27, r31
    c7e6:	bf 01       	movw	r22, r30
    c7e8:	9c 01       	movw	r18, r24
    c7ea:	2e 54       	subi	r18, 0x4E	; 78
    c7ec:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c7ee:	af 01       	movw	r20, r30
    c7f0:	4a 0f       	add	r20, r26
    c7f2:	5b 1f       	adc	r21, r27
    c7f4:	06 c0       	rjmp	.+12     	; 0xc802 <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    c7f6:	fb 01       	movw	r30, r22
    c7f8:	81 91       	ld	r24, Z+
    c7fa:	bf 01       	movw	r22, r30
    c7fc:	f9 01       	movw	r30, r18
    c7fe:	81 93       	st	Z+, r24
    c800:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c802:	64 17       	cp	r22, r20
    c804:	75 07       	cpc	r23, r21
    c806:	b9 f7       	brne	.-18     	; 0xc7f6 <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c808:	85 e3       	ldi	r24, 0x35	; 53
    c80a:	90 e0       	ldi	r25, 0x00	; 0
    c80c:	9c 01       	movw	r18, r24
    c80e:	c2 9e       	mul	r12, r18
    c810:	c0 01       	movw	r24, r0
    c812:	c3 9e       	mul	r12, r19
    c814:	90 0d       	add	r25, r0
    c816:	d2 9e       	mul	r13, r18
    c818:	90 0d       	add	r25, r0
    c81a:	11 24       	eor	r1, r1
    c81c:	fc 01       	movw	r30, r24
    c81e:	e8 55       	subi	r30, 0x58	; 88
    c820:	fa 4f       	sbci	r31, 0xFA	; 250
    c822:	ea 0f       	add	r30, r26
    c824:	fb 1f       	adc	r31, r27
    c826:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    c828:	fe 01       	movw	r30, r28
    c82a:	74 96       	adiw	r30, 0x14	; 20
    c82c:	df 01       	movw	r26, r30
    c82e:	0d 90       	ld	r0, X+
    c830:	00 20       	and	r0, r0
    c832:	e9 f7       	brne	.-6      	; 0xc82e <StoreStandaloneTransData+0x28c>
    c834:	11 97       	sbiw	r26, 0x01	; 1
    c836:	ae 1b       	sub	r26, r30
    c838:	bf 0b       	sbc	r27, r31
    c83a:	bf 01       	movw	r22, r30
    c83c:	9c 01       	movw	r18, r24
    c83e:	25 54       	subi	r18, 0x45	; 69
    c840:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c842:	af 01       	movw	r20, r30
    c844:	4a 0f       	add	r20, r26
    c846:	5b 1f       	adc	r21, r27
    c848:	06 c0       	rjmp	.+12     	; 0xc856 <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    c84a:	fb 01       	movw	r30, r22
    c84c:	81 91       	ld	r24, Z+
    c84e:	bf 01       	movw	r22, r30
    c850:	f9 01       	movw	r30, r18
    c852:	81 93       	st	Z+, r24
    c854:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c856:	64 17       	cp	r22, r20
    c858:	75 07       	cpc	r23, r21
    c85a:	b9 f7       	brne	.-18     	; 0xc84a <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c85c:	85 e3       	ldi	r24, 0x35	; 53
    c85e:	90 e0       	ldi	r25, 0x00	; 0
    c860:	c8 9e       	mul	r12, r24
    c862:	70 01       	movw	r14, r0
    c864:	c9 9e       	mul	r12, r25
    c866:	f0 0c       	add	r15, r0
    c868:	d8 9e       	mul	r13, r24
    c86a:	f0 0c       	add	r15, r0
    c86c:	11 24       	eor	r1, r1
    c86e:	87 01       	movw	r16, r14
    c870:	08 55       	subi	r16, 0x58	; 88
    c872:	1a 4f       	sbci	r17, 0xFA	; 250
    c874:	a0 0f       	add	r26, r16
    c876:	b1 1f       	adc	r27, r17
    c878:	53 96       	adiw	r26, 0x13	; 19
    c87a:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    c87c:	f0 ed       	ldi	r31, 0xD0	; 208
    c87e:	2f 0e       	add	r2, r31
    c880:	d8 01       	movw	r26, r16
    c882:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    c884:	b9 a9       	ldd	r27, Y+49	; 0x31
    c886:	b0 53       	subi	r27, 0x30	; 48
    c888:	f8 01       	movw	r30, r16
    c88a:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    c88c:	88 e6       	ldi	r24, 0x68	; 104
    c88e:	9c e0       	ldi	r25, 0x0C	; 12
    c890:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
    c894:	d8 01       	movw	r26, r16
    c896:	12 96       	adiw	r26, 0x02	; 2
    c898:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    c89a:	fe 01       	movw	r30, r28
    c89c:	34 96       	adiw	r30, 0x04	; 4
    c89e:	df 01       	movw	r26, r30
    c8a0:	0d 90       	ld	r0, X+
    c8a2:	00 20       	and	r0, r0
    c8a4:	e9 f7       	brne	.-6      	; 0xc8a0 <StoreStandaloneTransData+0x2fe>
    c8a6:	11 97       	sbiw	r26, 0x01	; 1
    c8a8:	ae 1b       	sub	r26, r30
    c8aa:	bf 0b       	sbc	r27, r31
    c8ac:	97 01       	movw	r18, r14
    c8ae:	2c 53       	subi	r18, 0x3C	; 60
    c8b0:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c8b2:	af 01       	movw	r20, r30
    c8b4:	4a 0f       	add	r20, r26
    c8b6:	5b 1f       	adc	r21, r27
    c8b8:	06 c0       	rjmp	.+12     	; 0xc8c6 <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    c8ba:	f4 01       	movw	r30, r8
    c8bc:	81 91       	ld	r24, Z+
    c8be:	4f 01       	movw	r8, r30
    c8c0:	f9 01       	movw	r30, r18
    c8c2:	81 93       	st	Z+, r24
    c8c4:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c8c6:	84 16       	cp	r8, r20
    c8c8:	95 06       	cpc	r9, r21
    c8ca:	b9 f7       	brne	.-18     	; 0xc8ba <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c8cc:	85 e3       	ldi	r24, 0x35	; 53
    c8ce:	90 e0       	ldi	r25, 0x00	; 0
    c8d0:	9c 01       	movw	r18, r24
    c8d2:	c2 9e       	mul	r12, r18
    c8d4:	c0 01       	movw	r24, r0
    c8d6:	c3 9e       	mul	r12, r19
    c8d8:	90 0d       	add	r25, r0
    c8da:	d2 9e       	mul	r13, r18
    c8dc:	90 0d       	add	r25, r0
    c8de:	11 24       	eor	r1, r1
    c8e0:	fc 01       	movw	r30, r24
    c8e2:	e8 55       	subi	r30, 0x58	; 88
    c8e4:	fa 4f       	sbci	r31, 0xFA	; 250
    c8e6:	ea 0f       	add	r30, r26
    c8e8:	fb 1f       	adc	r31, r27
    c8ea:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    c8ec:	fe 01       	movw	r30, r28
    c8ee:	7d 96       	adiw	r30, 0x1d	; 29
    c8f0:	df 01       	movw	r26, r30
    c8f2:	0d 90       	ld	r0, X+
    c8f4:	00 20       	and	r0, r0
    c8f6:	e9 f7       	brne	.-6      	; 0xc8f2 <StoreStandaloneTransData+0x350>
    c8f8:	11 97       	sbiw	r26, 0x01	; 1
    c8fa:	ae 1b       	sub	r26, r30
    c8fc:	bf 0b       	sbc	r27, r31
    c8fe:	9c 01       	movw	r18, r24
    c900:	25 53       	subi	r18, 0x35	; 53
    c902:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c904:	af 01       	movw	r20, r30
    c906:	4a 0f       	add	r20, r26
    c908:	5b 1f       	adc	r21, r27
    c90a:	06 c0       	rjmp	.+12     	; 0xc918 <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    c90c:	f3 01       	movw	r30, r6
    c90e:	81 91       	ld	r24, Z+
    c910:	3f 01       	movw	r6, r30
    c912:	f9 01       	movw	r30, r18
    c914:	81 93       	st	Z+, r24
    c916:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c918:	64 16       	cp	r6, r20
    c91a:	75 06       	cpc	r7, r21
    c91c:	b9 f7       	brne	.-18     	; 0xc90c <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c91e:	85 e3       	ldi	r24, 0x35	; 53
    c920:	90 e0       	ldi	r25, 0x00	; 0
    c922:	9c 01       	movw	r18, r24
    c924:	c2 9e       	mul	r12, r18
    c926:	c0 01       	movw	r24, r0
    c928:	c3 9e       	mul	r12, r19
    c92a:	90 0d       	add	r25, r0
    c92c:	d2 9e       	mul	r13, r18
    c92e:	90 0d       	add	r25, r0
    c930:	11 24       	eor	r1, r1
    c932:	fc 01       	movw	r30, r24
    c934:	e8 55       	subi	r30, 0x58	; 88
    c936:	fa 4f       	sbci	r31, 0xFA	; 250
    c938:	ea 0f       	add	r30, r26
    c93a:	fb 1f       	adc	r31, r27
    c93c:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    c93e:	fe 01       	movw	r30, r28
    c940:	b7 96       	adiw	r30, 0x27	; 39
    c942:	df 01       	movw	r26, r30
    c944:	0d 90       	ld	r0, X+
    c946:	00 20       	and	r0, r0
    c948:	e9 f7       	brne	.-6      	; 0xc944 <StoreStandaloneTransData+0x3a2>
    c94a:	11 97       	sbiw	r26, 0x01	; 1
    c94c:	ae 1b       	sub	r26, r30
    c94e:	bf 0b       	sbc	r27, r31
    c950:	9c 01       	movw	r18, r24
    c952:	2c 52       	subi	r18, 0x2C	; 44
    c954:	3a 4f       	sbci	r19, 0xFA	; 250
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c956:	af 01       	movw	r20, r30
    c958:	4a 0f       	add	r20, r26
    c95a:	5b 1f       	adc	r21, r27
    c95c:	06 c0       	rjmp	.+12     	; 0xc96a <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    c95e:	f2 01       	movw	r30, r4
    c960:	81 91       	ld	r24, Z+
    c962:	2f 01       	movw	r4, r30
    c964:	f9 01       	movw	r30, r18
    c966:	81 93       	st	Z+, r24
    c968:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c96a:	44 16       	cp	r4, r20
    c96c:	55 06       	cpc	r5, r21
    c96e:	b9 f7       	brne	.-18     	; 0xc95e <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c970:	85 e3       	ldi	r24, 0x35	; 53
    c972:	90 e0       	ldi	r25, 0x00	; 0
    c974:	c8 9e       	mul	r12, r24
    c976:	f0 01       	movw	r30, r0
    c978:	c9 9e       	mul	r12, r25
    c97a:	f0 0d       	add	r31, r0
    c97c:	d8 9e       	mul	r13, r24
    c97e:	f0 0d       	add	r31, r0
    c980:	11 24       	eor	r1, r1
    c982:	e8 55       	subi	r30, 0x58	; 88
    c984:	fa 4f       	sbci	r31, 0xFA	; 250
    c986:	ea 0f       	add	r30, r26
    c988:	fb 1f       	adc	r31, r27
    c98a:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    c98c:	83 2d       	mov	r24, r3
    c98e:	8f 70       	andi	r24, 0x0F	; 15
    c990:	60 e1       	ldi	r22, 0x10	; 16
    c992:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    c996:	83 2d       	mov	r24, r3
    c998:	62 e0       	ldi	r22, 0x02	; 2
    c99a:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    c99e:	8b e0       	ldi	r24, 0x0B	; 11
    c9a0:	63 2d       	mov	r22, r3
    c9a2:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
    c9a6:	4b c0       	rjmp	.+150    	; 0xca3e <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    c9a8:	da 94       	dec	r13
    c9aa:	cd 2c       	mov	r12, r13
    c9ac:	dd 24       	eor	r13, r13
    c9ae:	f6 01       	movw	r30, r12
    c9b0:	ed 5e       	subi	r30, 0xED	; 237
    c9b2:	fe 4f       	sbci	r31, 0xFE	; 254
    c9b4:	81 e0       	ldi	r24, 0x01	; 1
    c9b6:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    c9b8:	c7 01       	movw	r24, r14
    c9ba:	0e 94 93 32 	call	0x6526	; 0x6526 <FormatPrice>
			 FormatMoney(strPMoney);
    c9be:	c8 01       	movw	r24, r16
    c9c0:	0e 94 86 32 	call	0x650c	; 0x650c <FormatMoney>
			 FormatVolume(strPVolume);
    c9c4:	c5 01       	movw	r24, r10
    c9c6:	0e 94 79 32 	call	0x64f2	; 0x64f2 <FormatVolume>

			 //uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    c9ca:	87 e8       	ldi	r24, 0x87	; 135
    c9cc:	9c e0       	ldi	r25, 0x0C	; 12
    c9ce:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    c9d2:	00 d0       	rcall	.+0      	; 0xc9d4 <StoreStandaloneTransData+0x432>
    c9d4:	00 d0       	rcall	.+0      	; 0xc9d6 <StoreStandaloneTransData+0x434>
    c9d6:	00 d0       	rcall	.+0      	; 0xc9d8 <StoreStandaloneTransData+0x436>
    c9d8:	ed b7       	in	r30, 0x3d	; 61
    c9da:	fe b7       	in	r31, 0x3e	; 62
    c9dc:	31 96       	adiw	r30, 0x01	; 1
    c9de:	ce 01       	movw	r24, r28
    c9e0:	0b 96       	adiw	r24, 0x0b	; 11
    c9e2:	ad b7       	in	r26, 0x3d	; 61
    c9e4:	be b7       	in	r27, 0x3e	; 62
    c9e6:	12 96       	adiw	r26, 0x02	; 2
    c9e8:	9c 93       	st	X, r25
    c9ea:	8e 93       	st	-X, r24
    c9ec:	11 97       	sbiw	r26, 0x01	; 1
    c9ee:	84 e6       	ldi	r24, 0x64	; 100
    c9f0:	91 e2       	ldi	r25, 0x21	; 33
    c9f2:	93 83       	std	Z+3, r25	; 0x03
    c9f4:	82 83       	std	Z+2, r24	; 0x02
    c9f6:	8a eb       	ldi	r24, 0xBA	; 186
    c9f8:	93 e0       	ldi	r25, 0x03	; 3
    c9fa:	95 83       	std	Z+5, r25	; 0x05
    c9fc:	84 83       	std	Z+4, r24	; 0x04
    c9fe:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    ca02:	ed b7       	in	r30, 0x3d	; 61
    ca04:	fe b7       	in	r31, 0x3e	; 62
    ca06:	31 96       	adiw	r30, 0x01	; 1
    ca08:	ce 01       	movw	r24, r28
    ca0a:	44 96       	adiw	r24, 0x14	; 20
    ca0c:	ad b7       	in	r26, 0x3d	; 61
    ca0e:	be b7       	in	r27, 0x3e	; 62
    ca10:	12 96       	adiw	r26, 0x02	; 2
    ca12:	9c 93       	st	X, r25
    ca14:	8e 93       	st	-X, r24
    ca16:	11 97       	sbiw	r26, 0x01	; 1
    ca18:	81 e6       	ldi	r24, 0x61	; 97
    ca1a:	91 e2       	ldi	r25, 0x21	; 33
    ca1c:	93 83       	std	Z+3, r25	; 0x03
    ca1e:	82 83       	std	Z+2, r24	; 0x02
    ca20:	84 e7       	ldi	r24, 0x74	; 116
    ca22:	98 e0       	ldi	r25, 0x08	; 8
    ca24:	95 83       	std	Z+5, r25	; 0x05
    ca26:	84 83       	std	Z+4, r24	; 0x04
    ca28:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    ca2c:	ed b7       	in	r30, 0x3d	; 61
    ca2e:	fe b7       	in	r31, 0x3e	; 62
    ca30:	36 96       	adiw	r30, 0x06	; 6
    ca32:	0f b6       	in	r0, 0x3f	; 63
    ca34:	f8 94       	cli
    ca36:	fe bf       	out	0x3e, r31	; 62
    ca38:	0f be       	out	0x3f, r0	; 63
    ca3a:	ed bf       	out	0x3d, r30	; 61
    ca3c:	75 ce       	rjmp	.-790    	; 0xc728 <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //uart_print(0,1,strRawTransData);
}
    ca3e:	e1 96       	adiw	r28, 0x31	; 49
    ca40:	0f b6       	in	r0, 0x3f	; 63
    ca42:	f8 94       	cli
    ca44:	de bf       	out	0x3e, r29	; 62
    ca46:	0f be       	out	0x3f, r0	; 63
    ca48:	cd bf       	out	0x3d, r28	; 61
    ca4a:	cf 91       	pop	r28
    ca4c:	df 91       	pop	r29
    ca4e:	1f 91       	pop	r17
    ca50:	0f 91       	pop	r16
    ca52:	ff 90       	pop	r15
    ca54:	ef 90       	pop	r14
    ca56:	df 90       	pop	r13
    ca58:	cf 90       	pop	r12
    ca5a:	bf 90       	pop	r11
    ca5c:	af 90       	pop	r10
    ca5e:	9f 90       	pop	r9
    ca60:	8f 90       	pop	r8
    ca62:	7f 90       	pop	r7
    ca64:	6f 90       	pop	r6
    ca66:	5f 90       	pop	r5
    ca68:	4f 90       	pop	r4
    ca6a:	3f 90       	pop	r3
    ca6c:	2f 90       	pop	r2
    ca6e:	08 95       	ret

0000ca70 <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    ca70:	2f 92       	push	r2
    ca72:	3f 92       	push	r3
    ca74:	4f 92       	push	r4
    ca76:	5f 92       	push	r5
    ca78:	7f 92       	push	r7
    ca7a:	8f 92       	push	r8
    ca7c:	9f 92       	push	r9
    ca7e:	af 92       	push	r10
    ca80:	bf 92       	push	r11
    ca82:	cf 92       	push	r12
    ca84:	df 92       	push	r13
    ca86:	ef 92       	push	r14
    ca88:	ff 92       	push	r15
    ca8a:	0f 93       	push	r16
    ca8c:	1f 93       	push	r17
    ca8e:	df 93       	push	r29
    ca90:	cf 93       	push	r28
    ca92:	cd b7       	in	r28, 0x3d	; 61
    ca94:	de b7       	in	r29, 0x3e	; 62
    ca96:	a1 97       	sbiw	r28, 0x21	; 33
    ca98:	0f b6       	in	r0, 0x3f	; 63
    ca9a:	f8 94       	cli
    ca9c:	de bf       	out	0x3e, r29	; 62
    ca9e:	0f be       	out	0x3f, r0	; 63
    caa0:	cd bf       	out	0x3d, r28	; 61
    caa2:	8c 01       	movw	r16, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    caa4:	fc 01       	movw	r30, r24
    caa6:	82 81       	ldd	r24, Z+2	; 0x02
    caa8:	89 83       	std	Y+1, r24	; 0x01
    caaa:	83 81       	ldd	r24, Z+3	; 0x03
    caac:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    caae:	1b 82       	std	Y+3, r1	; 0x03
	 //    uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
    cab0:	ce 01       	movw	r24, r28
    cab2:	01 96       	adiw	r24, 0x01	; 1
    cab4:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
    cab8:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    caba:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
	 if (FIPAddr>0){
    cabe:	88 23       	and	r24, r24
    cac0:	09 f4       	brne	.+2      	; 0xcac4 <StoreStandaloneTotalizerData+0x54>
    cac2:	44 c0       	rjmp	.+136    	; 0xcb4c <StoreStandaloneTotalizerData+0xdc>
	     FIPAddr=FIPAddr-1;
    cac4:	78 2e       	mov	r7, r24
    cac6:	7a 94       	dec	r7
    cac8:	50 e1       	ldi	r21, 0x10	; 16
    caca:	e5 2e       	mov	r14, r21
    cacc:	f1 2c       	mov	r15, r1
    cace:	e0 0e       	add	r14, r16
    cad0:	f1 1e       	adc	r15, r17
    cad2:	dd 24       	eor	r13, r13
    cad4:	d3 94       	inc	r13
    cad6:	44 e0       	ldi	r20, 0x04	; 4
    cad8:	84 2e       	mov	r8, r20
    cada:	91 2c       	mov	r9, r1
    cadc:	8c 0e       	add	r8, r28
    cade:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cae0:	30 e1       	ldi	r19, 0x10	; 16
    cae2:	23 2e       	mov	r2, r19
    cae4:	31 2c       	mov	r3, r1
    cae6:	2c 0e       	add	r2, r28
    cae8:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    caea:	23 e1       	ldi	r18, 0x13	; 19
    caec:	a2 2e       	mov	r10, r18
    caee:	b1 2c       	mov	r11, r1
    caf0:	ac 0e       	add	r10, r28
    caf2:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    caf4:	9f e1       	ldi	r25, 0x1F	; 31
    caf6:	49 2e       	mov	r4, r25
    caf8:	51 2c       	mov	r5, r1
    cafa:	4c 0e       	add	r4, r28
    cafc:	5d 1e       	adc	r5, r29
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    cafe:	d7 01       	movw	r26, r14
    cb00:	1c 97       	sbiw	r26, 0x0c	; 12
    cb02:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    cb04:	8d 91       	ld	r24, X+
    cb06:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cb08:	e2 15       	cp	r30, r2
    cb0a:	f3 05       	cpc	r31, r3
    cb0c:	d9 f7       	brne	.-10     	; 0xcb04 <StoreStandaloneTotalizerData+0x94>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    cb0e:	18 8a       	std	Y+16, r1	; 0x10
    cb10:	f5 01       	movw	r30, r10
    cb12:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    cb14:	8d 91       	ld	r24, X+
    cb16:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    cb18:	e4 15       	cp	r30, r4
    cb1a:	f5 05       	cpc	r31, r5
    cb1c:	d9 f7       	brne	.-10     	; 0xcb14 <StoreStandaloneTotalizerData+0xa4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    cb1e:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    cb20:	80 e0       	ldi	r24, 0x00	; 0
    cb22:	61 e0       	ldi	r22, 0x01	; 1
    cb24:	47 2d       	mov	r20, r7
    cb26:	2d 2d       	mov	r18, r13
    cb28:	84 01       	movw	r16, r8
    cb2a:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    cb2e:	81 e0       	ldi	r24, 0x01	; 1
    cb30:	61 e0       	ldi	r22, 0x01	; 1
    cb32:	47 2d       	mov	r20, r7
    cb34:	2d 2d       	mov	r18, r13
    cb36:	85 01       	movw	r16, r10
    cb38:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    cb3c:	d3 94       	inc	r13
    cb3e:	88 e1       	ldi	r24, 0x18	; 24
    cb40:	90 e0       	ldi	r25, 0x00	; 0
    cb42:	e8 0e       	add	r14, r24
    cb44:	f9 1e       	adc	r15, r25
    cb46:	97 e0       	ldi	r25, 0x07	; 7
    cb48:	d9 16       	cp	r13, r25
    cb4a:	c9 f6       	brne	.-78     	; 0xcafe <StoreStandaloneTotalizerData+0x8e>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    cb4c:	8d e0       	ldi	r24, 0x0D	; 13
    cb4e:	6c 2d       	mov	r22, r12
    cb50:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    cb54:	8c 2d       	mov	r24, r12
    cb56:	8f 70       	andi	r24, 0x0F	; 15
    cb58:	64 e1       	ldi	r22, 0x14	; 20
    cb5a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
}
    cb5e:	a1 96       	adiw	r28, 0x21	; 33
    cb60:	0f b6       	in	r0, 0x3f	; 63
    cb62:	f8 94       	cli
    cb64:	de bf       	out	0x3e, r29	; 62
    cb66:	0f be       	out	0x3f, r0	; 63
    cb68:	cd bf       	out	0x3d, r28	; 61
    cb6a:	cf 91       	pop	r28
    cb6c:	df 91       	pop	r29
    cb6e:	1f 91       	pop	r17
    cb70:	0f 91       	pop	r16
    cb72:	ff 90       	pop	r15
    cb74:	ef 90       	pop	r14
    cb76:	df 90       	pop	r13
    cb78:	cf 90       	pop	r12
    cb7a:	bf 90       	pop	r11
    cb7c:	af 90       	pop	r10
    cb7e:	9f 90       	pop	r9
    cb80:	8f 90       	pop	r8
    cb82:	7f 90       	pop	r7
    cb84:	5f 90       	pop	r5
    cb86:	4f 90       	pop	r4
    cb88:	3f 90       	pop	r3
    cb8a:	2f 90       	pop	r2
    cb8c:	08 95       	ret

0000cb8e <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    cb8e:	0f 93       	push	r16
    cb90:	1f 93       	push	r17
    cb92:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    cb94:	80 91 a9 02 	lds	r24, 0x02A9
    cb98:	80 93 aa 02 	sts	0x02AA, r24
	  zDataFlow[3]=zDataFlow[2];
    cb9c:	80 91 a8 02 	lds	r24, 0x02A8
    cba0:	80 93 a9 02 	sts	0x02A9, r24
	  zDataFlow[2]=zDataFlow[1];
    cba4:	80 91 a7 02 	lds	r24, 0x02A7
    cba8:	80 93 a8 02 	sts	0x02A8, r24
      zDataFlow[1]=zDataFlow[0];
    cbac:	90 91 a6 02 	lds	r25, 0x02A6
    cbb0:	90 93 a7 02 	sts	0x02A7, r25
      zDataFlow[0]=data;
    cbb4:	00 93 a6 02 	sts	0x02A6, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    cbb8:	87 30       	cpi	r24, 0x07	; 7
    cbba:	79 f4       	brne	.+30     	; 0xcbda <ScanStandaloneFlow+0x4c>
    cbbc:	08 30       	cpi	r16, 0x08	; 8
    cbbe:	69 f4       	brne	.+26     	; 0xcbda <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    cbc0:	19 2f       	mov	r17, r25
    cbc2:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    cbc4:	89 2f       	mov	r24, r25
    cbc6:	82 95       	swap	r24
    cbc8:	8f 70       	andi	r24, 0x0F	; 15
    cbca:	61 2f       	mov	r22, r17
    cbcc:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    cbd0:	1e 30       	cpi	r17, 0x0E	; 14
    cbd2:	19 f0       	breq	.+6      	; 0xcbda <ScanStandaloneFlow+0x4c>
    cbd4:	81 e0       	ldi	r24, 0x01	; 1
    cbd6:	80 93 9c 01 	sts	0x019C, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    cbda:	80 91 9d 01 	lds	r24, 0x019D
    cbde:	81 30       	cpi	r24, 0x01	; 1
    cbe0:	69 f4       	brne	.+26     	; 0xcbfc <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    cbe2:	80 91 a4 02 	lds	r24, 0x02A4
    cbe6:	90 91 a5 02 	lds	r25, 0x02A5
    cbea:	fc 01       	movw	r30, r24
    cbec:	ea 5f       	subi	r30, 0xFA	; 250
    cbee:	fc 4f       	sbci	r31, 0xFC	; 252
    cbf0:	00 83       	st	Z, r16
		  iFlow++;
    cbf2:	01 96       	adiw	r24, 0x01	; 1
    cbf4:	90 93 a5 02 	sts	0x02A5, r25
    cbf8:	80 93 a4 02 	sts	0x02A4, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    cbfc:	80 91 a7 02 	lds	r24, 0x02A7
    cc00:	85 30       	cpi	r24, 0x05	; 5
    cc02:	61 f4       	brne	.+24     	; 0xcc1c <ScanStandaloneFlow+0x8e>
    cc04:	80 91 a6 02 	lds	r24, 0x02A6
    cc08:	80 35       	cpi	r24, 0x50	; 80
    cc0a:	41 f5       	brne	.+80     	; 0xcc5c <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    cc0c:	81 e0       	ldi	r24, 0x01	; 1
    cc0e:	80 93 9d 01 	sts	0x019D, r24
		  iFlow=0;
    cc12:	10 92 a5 02 	sts	0x02A5, r1
    cc16:	10 92 a4 02 	sts	0x02A4, r1
    cc1a:	20 c0       	rjmp	.+64     	; 0xcc5c <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    cc1c:	86 30       	cpi	r24, 0x06	; 6
    cc1e:	f1 f4       	brne	.+60     	; 0xcc5c <ScanStandaloneFlow+0xce>
    cc20:	80 91 a6 02 	lds	r24, 0x02A6
    cc24:	80 36       	cpi	r24, 0x60	; 96
    cc26:	d1 f4       	brne	.+52     	; 0xcc5c <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    cc28:	10 92 9d 01 	sts	0x019D, r1
	      strStandReceived[iFlow]=0;
    cc2c:	e0 91 a4 02 	lds	r30, 0x02A4
    cc30:	f0 91 a5 02 	lds	r31, 0x02A5
    cc34:	ea 5f       	subi	r30, 0xFA	; 250
    cc36:	fc 4f       	sbci	r31, 0xFC	; 252
    cc38:	10 82       	st	Z, r1

		  //uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    cc3a:	86 e0       	ldi	r24, 0x06	; 6
    cc3c:	93 e0       	ldi	r25, 0x03	; 3
    cc3e:	0e 94 52 42 	call	0x84a4	; 0x84a4 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    cc42:	81 30       	cpi	r24, 0x01	; 1
    cc44:	29 f4       	brne	.+10     	; 0xcc50 <ScanStandaloneFlow+0xc2>
    cc46:	86 e0       	ldi	r24, 0x06	; 6
    cc48:	93 e0       	ldi	r25, 0x03	; 3
    cc4a:	0e 94 d1 62 	call	0xc5a2	; 0xc5a2 <StoreStandaloneTransData>
    cc4e:	06 c0       	rjmp	.+12     	; 0xcc5c <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    cc50:	82 30       	cpi	r24, 0x02	; 2
    cc52:	21 f4       	brne	.+8      	; 0xcc5c <ScanStandaloneFlow+0xce>
    cc54:	86 e0       	ldi	r24, 0x06	; 6
    cc56:	93 e0       	ldi	r25, 0x03	; 3
    cc58:	0e 94 38 65 	call	0xca70	; 0xca70 <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    cc5c:	80 91 a9 02 	lds	r24, 0x02A9
    cc60:	89 30       	cpi	r24, 0x09	; 9
    cc62:	c1 f5       	brne	.+112    	; 0xccd4 <ScanStandaloneFlow+0x146>
    cc64:	80 91 a6 02 	lds	r24, 0x02A6
    cc68:	8a 30       	cpi	r24, 0x0A	; 10
    cc6a:	a1 f5       	brne	.+104    	; 0xccd4 <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    cc6c:	90 91 a7 02 	lds	r25, 0x02A7
    cc70:	90 93 ec 0b 	sts	0x0BEC, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    cc74:	80 91 a8 02 	lds	r24, 0x02A8
    cc78:	80 93 9d 05 	sts	0x059D, r24
		  switch(AcknoledgeCommand){
    cc7c:	89 31       	cpi	r24, 0x19	; 25
    cc7e:	51 f0       	breq	.+20     	; 0xcc94 <ScanStandaloneFlow+0x106>
    cc80:	8a 31       	cpi	r24, 0x1A	; 26
    cc82:	18 f4       	brcc	.+6      	; 0xcc8a <ScanStandaloneFlow+0xfc>
    cc84:	85 30       	cpi	r24, 0x05	; 5
    cc86:	19 f5       	brne	.+70     	; 0xccce <ScanStandaloneFlow+0x140>
    cc88:	17 c0       	rjmp	.+46     	; 0xccb8 <ScanStandaloneFlow+0x12a>
    cc8a:	8a 31       	cpi	r24, 0x1A	; 26
    cc8c:	c9 f0       	breq	.+50     	; 0xccc0 <ScanStandaloneFlow+0x132>
    cc8e:	8c 31       	cpi	r24, 0x1C	; 28
    cc90:	f1 f4       	brne	.+60     	; 0xccce <ScanStandaloneFlow+0x140>
    cc92:	1a c0       	rjmp	.+52     	; 0xccc8 <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    cc94:	90 93 80 01 	sts	0x0180, r25
			   IsNewPoolingSequence=True;
    cc98:	81 e0       	ldi	r24, 0x01	; 1
    cc9a:	80 93 81 01 	sts	0x0181, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    cc9e:	80 91 84 01 	lds	r24, 0x0184
    cca2:	81 30       	cpi	r24, 0x01	; 1
    cca4:	a1 f4       	brne	.+40     	; 0xccce <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    cca6:	10 92 84 01 	sts	0x0184, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    ccaa:	80 91 a7 05 	lds	r24, 0x05A7
    ccae:	60 91 d3 0b 	lds	r22, 0x0BD3
    ccb2:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
    ccb6:	0b c0       	rjmp	.+22     	; 0xccce <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    ccb8:	81 e0       	ldi	r24, 0x01	; 1
    ccba:	80 93 af 01 	sts	0x01AF, r24
    ccbe:	07 c0       	rjmp	.+14     	; 0xccce <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    ccc0:	81 e0       	ldi	r24, 0x01	; 1
    ccc2:	80 93 83 01 	sts	0x0183, r24
    ccc6:	03 c0       	rjmp	.+6      	; 0xccce <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    ccc8:	81 e0       	ldi	r24, 0x01	; 1
    ccca:	80 93 23 01 	sts	0x0123, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    ccce:	81 e0       	ldi	r24, 0x01	; 1
    ccd0:	80 93 82 01 	sts	0x0182, r24
	  }
}
    ccd4:	1f 91       	pop	r17
    ccd6:	0f 91       	pop	r16
    ccd8:	08 95       	ret

0000ccda <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    ccda:	1f 92       	push	r1
    ccdc:	0f 92       	push	r0
    ccde:	0f b6       	in	r0, 0x3f	; 63
    cce0:	0f 92       	push	r0
    cce2:	0b b6       	in	r0, 0x3b	; 59
    cce4:	0f 92       	push	r0
    cce6:	11 24       	eor	r1, r1
    cce8:	1f 93       	push	r17
    ccea:	2f 93       	push	r18
    ccec:	3f 93       	push	r19
    ccee:	4f 93       	push	r20
    ccf0:	5f 93       	push	r21
    ccf2:	6f 93       	push	r22
    ccf4:	7f 93       	push	r23
    ccf6:	8f 93       	push	r24
    ccf8:	9f 93       	push	r25
    ccfa:	af 93       	push	r26
    ccfc:	bf 93       	push	r27
    ccfe:	ef 93       	push	r30
    cd00:	ff 93       	push	r31
char dataSPI;
//char Reply=0;
    //uart(0,1,SPDR);
	dataSPI=SPDR;
    cd02:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    cd04:	81 2f       	mov	r24, r17
    cd06:	0e 94 c1 13 	call	0x2782	; 0x2782 <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    cd0a:	80 91 00 01 	lds	r24, 0x0100
    cd0e:	81 30       	cpi	r24, 0x01	; 1
    cd10:	21 f4       	brne	.+8      	; 0xcd1a <__vector_17+0x40>
    cd12:	81 2f       	mov	r24, r17
    cd14:	0e 94 01 13 	call	0x2602	; 0x2602 <ScanEDCFlow>
    cd18:	05 c0       	rjmp	.+10     	; 0xcd24 <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    cd1a:	82 30       	cpi	r24, 0x02	; 2
    cd1c:	19 f4       	brne	.+6      	; 0xcd24 <__vector_17+0x4a>
    cd1e:	81 2f       	mov	r24, r17
    cd20:	0e 94 c7 65 	call	0xcb8e	; 0xcb8e <ScanStandaloneFlow>
}
    cd24:	ff 91       	pop	r31
    cd26:	ef 91       	pop	r30
    cd28:	bf 91       	pop	r27
    cd2a:	af 91       	pop	r26
    cd2c:	9f 91       	pop	r25
    cd2e:	8f 91       	pop	r24
    cd30:	7f 91       	pop	r23
    cd32:	6f 91       	pop	r22
    cd34:	5f 91       	pop	r21
    cd36:	4f 91       	pop	r20
    cd38:	3f 91       	pop	r19
    cd3a:	2f 91       	pop	r18
    cd3c:	1f 91       	pop	r17
    cd3e:	0f 90       	pop	r0
    cd40:	0b be       	out	0x3b, r0	; 59
    cd42:	0f 90       	pop	r0
    cd44:	0f be       	out	0x3f, r0	; 63
    cd46:	0f 90       	pop	r0
    cd48:	1f 90       	pop	r1
    cd4a:	18 95       	reti

0000cd4c <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    cd4c:	8f 92       	push	r8
    cd4e:	9f 92       	push	r9
    cd50:	af 92       	push	r10
    cd52:	bf 92       	push	r11
    cd54:	cf 92       	push	r12
    cd56:	df 92       	push	r13
    cd58:	ef 92       	push	r14
    cd5a:	ff 92       	push	r15
    cd5c:	0f 93       	push	r16
    cd5e:	1f 93       	push	r17
    cd60:	cf 93       	push	r28
    cd62:	df 93       	push	r29
    cd64:	f8 2e       	mov	r15, r24
    cd66:	96 2e       	mov	r9, r22
    cd68:	d4 2e       	mov	r13, r20
    cd6a:	e9 01       	movw	r28, r18
    cd6c:	58 01       	movw	r10, r16
    cd6e:	8e 2c       	mov	r8, r14
	 static char iHit=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;//,KeyByte=0;
	 static unsigned int iLoop=0,KeyTimeout;//,TimerPressed=0,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    cd70:	10 91 7f 02 	lds	r17, 0x027F
    cd74:	12 30       	cpi	r17, 0x02	; 2
    cd76:	09 f4       	brne	.+2      	; 0xcd7a <UserInput+0x2e>
    cd78:	29 c2       	rjmp	.+1106   	; 0xd1cc <UserInput+0x480>
    cd7a:	13 30       	cpi	r17, 0x03	; 3
    cd7c:	30 f4       	brcc	.+12     	; 0xcd8a <UserInput+0x3e>
    cd7e:	11 23       	and	r17, r17
    cd80:	59 f0       	breq	.+22     	; 0xcd98 <UserInput+0x4c>
    cd82:	11 30       	cpi	r17, 0x01	; 1
    cd84:	09 f0       	breq	.+2      	; 0xcd88 <UserInput+0x3c>
    cd86:	f2 c2       	rjmp	.+1508   	; 0xd36c <UserInput+0x620>
    cd88:	2c c0       	rjmp	.+88     	; 0xcde2 <UserInput+0x96>
    cd8a:	13 30       	cpi	r17, 0x03	; 3
    cd8c:	09 f4       	brne	.+2      	; 0xcd90 <UserInput+0x44>
    cd8e:	73 c2       	rjmp	.+1254   	; 0xd276 <UserInput+0x52a>
    cd90:	14 30       	cpi	r17, 0x04	; 4
    cd92:	09 f0       	breq	.+2      	; 0xcd96 <UserInput+0x4a>
    cd94:	eb c2       	rjmp	.+1494   	; 0xd36c <UserInput+0x620>
    cd96:	ec c2       	rjmp	.+1496   	; 0xd370 <UserInput+0x624>
	 case uiInit:
	      iLoop=0;
    cd98:	10 92 71 02 	sts	0x0271, r1
    cd9c:	10 92 70 02 	sts	0x0270, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    cda0:	60 93 7e 02 	sts	0x027E, r22
    cda4:	40 93 7d 02 	sts	0x027D, r20
          iValuePos=0;
    cda8:	10 92 7c 02 	sts	0x027C, r1
		  KeyTimeout=0;
    cdac:	10 92 6f 02 	sts	0x026F, r1
    cdb0:	10 92 6e 02 	sts	0x026E, r1
		  IsSameKey=False;
    cdb4:	10 92 75 02 	sts	0x0275, r1
		  IsNextKey=False;
    cdb8:	10 92 74 02 	sts	0x0274, r1
		  IsNewKey=False;
    cdbc:	10 92 73 02 	sts	0x0273, r1
		  IsShifted=True;
    cdc0:	91 e0       	ldi	r25, 0x01	; 1
    cdc2:	90 93 76 02 	sts	0x0276, r25
		  zKeyChar=' ';
    cdc6:	80 e2       	ldi	r24, 0x20	; 32
    cdc8:	80 93 7b 02 	sts	0x027B, r24
		  iHit=0;
    cdcc:	10 92 77 02 	sts	0x0277, r1
		  IsFirst=False;
    cdd0:	10 92 72 02 	sts	0x0272, r1
		  IsDelete=False;
    cdd4:	10 92 78 02 	sts	0x0278, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    cdd8:	90 93 7f 02 	sts	0x027F, r25
    cddc:	e5 e0       	ldi	r30, 0x05	; 5
    cdde:	ee 2e       	mov	r14, r30
    cde0:	cb c2       	rjmp	.+1430   	; 0xd378 <UserInput+0x62c>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    cde2:	81 e0       	ldi	r24, 0x01	; 1
    cde4:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    cde8:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    cdea:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    cdee:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    cdf0:	2b e7       	ldi	r18, 0x7B	; 123
    cdf2:	c2 16       	cp	r12, r18
    cdf4:	59 f4       	brne	.+22     	; 0xce0c <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
    cdf6:	80 91 76 02 	lds	r24, 0x0276
    cdfa:	88 23       	and	r24, r24
    cdfc:	19 f4       	brne	.+6      	; 0xce04 <UserInput+0xb8>
    cdfe:	10 93 76 02 	sts	0x0276, r17
    ce02:	04 c0       	rjmp	.+8      	; 0xce0c <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
    ce04:	81 30       	cpi	r24, 0x01	; 1
    ce06:	11 f4       	brne	.+4      	; 0xce0c <UserInput+0xc0>
    ce08:	10 92 76 02 	sts	0x0276, r1
			  }
          
		  if (IsSameKey==True){
    ce0c:	80 91 75 02 	lds	r24, 0x0275
    ce10:	81 30       	cpi	r24, 0x01	; 1
    ce12:	e9 f4       	brne	.+58     	; 0xce4e <UserInput+0x102>
		      KeyTimeout++;
    ce14:	80 91 6e 02 	lds	r24, 0x026E
    ce18:	90 91 6f 02 	lds	r25, 0x026F
    ce1c:	01 96       	adiw	r24, 0x01	; 1
    ce1e:	90 93 6f 02 	sts	0x026F, r25
    ce22:	80 93 6e 02 	sts	0x026E, r24
              if (KeyTimeout>1000){
    ce26:	89 5e       	subi	r24, 0xE9	; 233
    ce28:	93 40       	sbci	r25, 0x03	; 3
    ce2a:	88 f0       	brcs	.+34     	; 0xce4e <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    ce2c:	f5 e0       	ldi	r31, 0x05	; 5
    ce2e:	ff 16       	cp	r15, r31
    ce30:	39 f4       	brne	.+14     	; 0xce40 <UserInput+0xf4>
    ce32:	80 91 7e 02 	lds	r24, 0x027E
    ce36:	60 91 7d 02 	lds	r22, 0x027D
    ce3a:	4a e2       	ldi	r20, 0x2A	; 42
    ce3c:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>

		          IsNextKey=True;
    ce40:	81 e0       	ldi	r24, 0x01	; 1
    ce42:	80 93 74 02 	sts	0x0274, r24
				  iLoop=0;
    ce46:	10 92 71 02 	sts	0x0271, r1
    ce4a:	10 92 70 02 	sts	0x0270, r1
			     }
              }
            
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
    ce4e:	8e 2d       	mov	r24, r14
    ce50:	80 53       	subi	r24, 0x30	; 48
    ce52:	8a 30       	cpi	r24, 0x0A	; 10
    ce54:	20 f4       	brcc	.+8      	; 0xce5e <UserInput+0x112>
    ce56:	80 91 7c 02 	lds	r24, 0x027C
    ce5a:	88 15       	cp	r24, r8
    ce5c:	40 f0       	brcs	.+16     	; 0xce6e <UserInput+0x122>
    ce5e:	80 91 74 02 	lds	r24, 0x0274
    ce62:	81 30       	cpi	r24, 0x01	; 1
    ce64:	21 f0       	breq	.+8      	; 0xce6e <UserInput+0x122>
    ce66:	ee 24       	eor	r14, r14
    ce68:	00 e0       	ldi	r16, 0x00	; 0
    ce6a:	10 e0       	ldi	r17, 0x00	; 0
    ce6c:	be c0       	rjmp	.+380    	; 0xcfea <UserInput+0x29e>
    ce6e:	84 e2       	ldi	r24, 0x24	; 36
    ce70:	94 ef       	ldi	r25, 0xF4	; 244
    ce72:	01 97       	sbiw	r24, 0x01	; 1
    ce74:	f1 f7       	brne	.-4      	; 0xce72 <UserInput+0x126>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    ce76:	80 91 7c 02 	lds	r24, 0x027C
    ce7a:	fe 01       	movw	r30, r28
    ce7c:	e8 0f       	add	r30, r24
    ce7e:	f1 1d       	adc	r31, r1
    ce80:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    ce82:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    ce84:	8f 2d       	mov	r24, r15
    ce86:	81 50       	subi	r24, 0x01	; 1
    ce88:	82 30       	cpi	r24, 0x02	; 2
    ce8a:	30 f0       	brcs	.+12     	; 0xce98 <UserInput+0x14c>
    ce8c:	24 e0       	ldi	r18, 0x04	; 4
    ce8e:	f2 16       	cp	r15, r18
    ce90:	19 f0       	breq	.+6      	; 0xce98 <UserInput+0x14c>
    ce92:	00 e0       	ldi	r16, 0x00	; 0
    ce94:	10 e0       	ldi	r17, 0x00	; 0
    ce96:	04 c0       	rjmp	.+8      	; 0xcea0 <UserInput+0x154>
			        NumbValue=atoi(strResult);
    ce98:	ce 01       	movw	r24, r28
    ce9a:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
    ce9e:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    cea0:	83 e0       	ldi	r24, 0x03	; 3
    cea2:	f8 16       	cp	r15, r24
    cea4:	21 f0       	breq	.+8      	; 0xceae <UserInput+0x162>
    cea6:	e5 e0       	ldi	r30, 0x05	; 5
    cea8:	fe 16       	cp	r15, r30
    ceaa:	09 f0       	breq	.+2      	; 0xceae <UserInput+0x162>
    ceac:	63 c0       	rjmp	.+198    	; 0xcf74 <UserInput+0x228>
			       if (KeyChar!=zKeyChar){
    ceae:	80 91 7b 02 	lds	r24, 0x027B
    ceb2:	e8 16       	cp	r14, r24
    ceb4:	71 f0       	breq	.+28     	; 0xced2 <UserInput+0x186>
					   IsSameKey=False;
    ceb6:	10 92 75 02 	sts	0x0275, r1
					   IsNewKey=True;
    ceba:	81 e0       	ldi	r24, 0x01	; 1
    cebc:	80 93 73 02 	sts	0x0273, r24
				       iHit=0;
    cec0:	10 92 77 02 	sts	0x0277, r1
					   iLoop=1000;
    cec4:	88 ee       	ldi	r24, 0xE8	; 232
    cec6:	93 e0       	ldi	r25, 0x03	; 3
    cec8:	90 93 71 02 	sts	0x0271, r25
    cecc:	80 93 70 02 	sts	0x0270, r24
    ced0:	51 c0       	rjmp	.+162    	; 0xcf74 <UserInput+0x228>
				   }
                   else{
				   if (IsNewKey==True){
    ced2:	80 91 73 02 	lds	r24, 0x0273
    ced6:	81 30       	cpi	r24, 0x01	; 1
    ced8:	71 f4       	brne	.+28     	; 0xcef6 <UserInput+0x1aa>
					   IsNewKey=False;
    ceda:	10 92 73 02 	sts	0x0273, r1
					   yChar--;
    cede:	80 91 7d 02 	lds	r24, 0x027D
    cee2:	81 50       	subi	r24, 0x01	; 1
    cee4:	80 93 7d 02 	sts	0x027D, r24
					   if (iValuePos>0) iValuePos--;
    cee8:	80 91 7c 02 	lds	r24, 0x027C
    ceec:	88 23       	and	r24, r24
    ceee:	19 f0       	breq	.+6      	; 0xcef6 <UserInput+0x1aa>
    cef0:	81 50       	subi	r24, 0x01	; 1
    cef2:	80 93 7c 02 	sts	0x027C, r24
					   }
				   KeyTimeout=0;
    cef6:	10 92 6f 02 	sts	0x026F, r1
    cefa:	10 92 6e 02 	sts	0x026E, r1
				   IsSameKey=True;
    cefe:	81 e0       	ldi	r24, 0x01	; 1
    cf00:	80 93 75 02 	sts	0x0275, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) 
    cf04:	80 91 77 02 	lds	r24, 0x0277
    cf08:	e0 91 7b 02 	lds	r30, 0x027B
    cf0c:	f0 e0       	ldi	r31, 0x00	; 0
    cf0e:	e8 56       	subi	r30, 0x68	; 104
    cf10:	fd 4f       	sbci	r31, 0xFD	; 253
    cf12:	e4 91       	lpm	r30, Z+
    cf14:	8e 17       	cp	r24, r30
    cf16:	20 f4       	brcc	.+8      	; 0xcf20 <UserInput+0x1d4>
				        iHit++;
    cf18:	8f 5f       	subi	r24, 0xFF	; 255
    cf1a:	80 93 77 02 	sts	0x0277, r24
    cf1e:	02 c0       	rjmp	.+4      	; 0xcf24 <UserInput+0x1d8>
                   else iHit=0;
    cf20:	10 92 77 02 	sts	0x0277, r1
				   iLoop=1000;
    cf24:	88 ee       	ldi	r24, 0xE8	; 232
    cf26:	93 e0       	ldi	r25, 0x03	; 3
    cf28:	90 93 71 02 	sts	0x0271, r25
    cf2c:	80 93 70 02 	sts	0x0270, r24

                   zAlphaChar=AlphaChar;
    cf30:	80 91 79 02 	lds	r24, 0x0279
    cf34:	80 93 7a 02 	sts	0x027A, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    cf38:	80 91 76 02 	lds	r24, 0x0276
    cf3c:	6c 2d       	mov	r22, r12
    cf3e:	40 91 77 02 	lds	r20, 0x0277
    cf42:	0e 94 38 a5 	call	0x14a70	; 0x14a70 <_table_alphanum>
    cf46:	80 93 79 02 	sts	0x0279, r24
                   
				   if (IsNextKey==True){
    cf4a:	80 91 74 02 	lds	r24, 0x0274
    cf4e:	81 30       	cpi	r24, 0x01	; 1
    cf50:	41 f4       	brne	.+16     	; 0xcf62 <UserInput+0x216>
                       AlphaChar=zAlphaChar;       
    cf52:	80 91 7a 02 	lds	r24, 0x027A
    cf56:	80 93 79 02 	sts	0x0279, r24
					   IsNextKey=False;
    cf5a:	10 92 74 02 	sts	0x0274, r1
					   IsSameKey=False;
    cf5e:	10 92 75 02 	sts	0x0275, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    cf62:	80 91 7c 02 	lds	r24, 0x027C
    cf66:	fe 01       	movw	r30, r28
    cf68:	e8 0f       	add	r30, r24
    cf6a:	f1 1d       	adc	r31, r1
    cf6c:	80 91 79 02 	lds	r24, 0x0279
    cf70:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    cf72:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    cf74:	f2 e0       	ldi	r31, 0x02	; 2
    cf76:	ff 16       	cp	r15, r31
    cf78:	71 f4       	brne	.+28     	; 0xcf96 <UserInput+0x24a>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    cf7a:	a0 16       	cp	r10, r16
    cf7c:	b1 06       	cpc	r11, r17
    cf7e:	18 f4       	brcc	.+6      	; 0xcf86 <UserInput+0x23a>
    cf80:	a1 14       	cp	r10, r1
    cf82:	b1 04       	cpc	r11, r1
    cf84:	71 f5       	brne	.+92     	; 0xcfe2 <UserInput+0x296>
				     iValuePos++;
    cf86:	80 91 7c 02 	lds	r24, 0x027C
    cf8a:	8f 5f       	subi	r24, 0xFF	; 255
    cf8c:	80 93 7c 02 	sts	0x027C, r24
					 stUserInput=uiInputDisp;
    cf90:	83 e0       	ldi	r24, 0x03	; 3
    cf92:	80 93 7f 02 	sts	0x027F, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    cf96:	a0 16       	cp	r10, r16
    cf98:	b1 06       	cpc	r11, r17
    cf9a:	18 f4       	brcc	.+6      	; 0xcfa2 <UserInput+0x256>
    cf9c:	a1 14       	cp	r10, r1
    cf9e:	b1 04       	cpc	r11, r1
    cfa0:	01 f5       	brne	.+64     	; 0xcfe2 <UserInput+0x296>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    cfa2:	21 e0       	ldi	r18, 0x01	; 1
    cfa4:	f2 16       	cp	r15, r18
    cfa6:	49 f0       	breq	.+18     	; 0xcfba <UserInput+0x26e>
    cfa8:	83 e0       	ldi	r24, 0x03	; 3
    cfaa:	f8 16       	cp	r15, r24
    cfac:	31 f0       	breq	.+12     	; 0xcfba <UserInput+0x26e>
    cfae:	e4 e0       	ldi	r30, 0x04	; 4
    cfb0:	fe 16       	cp	r15, r30
    cfb2:	19 f0       	breq	.+6      	; 0xcfba <UserInput+0x26e>
    cfb4:	f5 e0       	ldi	r31, 0x05	; 5
    cfb6:	ff 16       	cp	r15, r31
    cfb8:	a1 f4       	brne	.+40     	; 0xcfe2 <UserInput+0x296>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    cfba:	80 91 75 02 	lds	r24, 0x0275
    cfbe:	88 23       	and	r24, r24
    cfc0:	69 f4       	brne	.+26     	; 0xcfdc <UserInput+0x290>
					      IsFirst=True;
    cfc2:	81 e0       	ldi	r24, 0x01	; 1
    cfc4:	80 93 72 02 	sts	0x0272, r24
					      iValuePos++;
    cfc8:	80 91 7c 02 	lds	r24, 0x027C
    cfcc:	8f 5f       	subi	r24, 0xFF	; 255
    cfce:	80 93 7c 02 	sts	0x027C, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
    cfd2:	80 91 7d 02 	lds	r24, 0x027D
    cfd6:	8f 5f       	subi	r24, 0xFF	; 255
    cfd8:	80 93 7d 02 	sts	0x027D, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
    cfdc:	83 e0       	ldi	r24, 0x03	; 3
    cfde:	80 93 7f 02 	sts	0x027F, r24
				  }
			   }
              zKeyChar=KeyChar;
    cfe2:	e0 92 7b 02 	sts	0x027B, r14
    cfe6:	74 e0       	ldi	r23, 0x04	; 4
    cfe8:	e7 2e       	mov	r14, r23
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    cfea:	9f 2d       	mov	r25, r15
    cfec:	91 50       	subi	r25, 0x01	; 1
    cfee:	92 30       	cpi	r25, 0x02	; 2
    cff0:	18 f0       	brcs	.+6      	; 0xcff8 <UserInput+0x2ac>
    cff2:	24 e0       	ldi	r18, 0x04	; 4
    cff4:	f2 16       	cp	r15, r18
    cff6:	71 f4       	brne	.+28     	; 0xd014 <UserInput+0x2c8>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    cff8:	a0 16       	cp	r10, r16
    cffa:	b1 06       	cpc	r11, r17
    cffc:	20 f0       	brcs	.+8      	; 0xd006 <UserInput+0x2ba>
    cffe:	80 91 7c 02 	lds	r24, 0x027C
    d002:	88 15       	cp	r24, r8
    d004:	39 f4       	brne	.+14     	; 0xd014 <UserInput+0x2c8>
			           if (MaxValue>0)system_beep(1);
    d006:	ab 28       	or	r10, r11
    d008:	29 f0       	breq	.+10     	; 0xd014 <UserInput+0x2c8>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d00a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d00c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d00e:	81 e0       	ldi	r24, 0x01	; 1
    d010:	80 93 bc 01 	sts	0x01BC, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    d014:	87 ee       	ldi	r24, 0xE7	; 231
    d016:	c8 16       	cp	r12, r24
    d018:	71 f4       	brne	.+28     	; 0xd036 <UserInput+0x2ea>
		      if (iValuePos>0){
    d01a:	80 91 7c 02 	lds	r24, 0x027C
    d01e:	88 23       	and	r24, r24
    d020:	41 f0       	breq	.+16     	; 0xd032 <UserInput+0x2e6>
			      iLoop=1999;
    d022:	8f ec       	ldi	r24, 0xCF	; 207
    d024:	97 e0       	ldi	r25, 0x07	; 7
    d026:	90 93 71 02 	sts	0x0271, r25
    d02a:	80 93 70 02 	sts	0x0270, r24
				  stUserInput=uiClearDisplay;
    d02e:	82 e0       	ldi	r24, 0x02	; 2
    d030:	26 c0       	rjmp	.+76     	; 0xd07e <UserInput+0x332>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    d032:	81 e0       	ldi	r24, 0x01	; 1
    d034:	21 c0       	rjmp	.+66     	; 0xd078 <UserInput+0x32c>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    d036:	e7 eb       	ldi	r30, 0xB7	; 183
    d038:	ce 16       	cp	r12, r30
    d03a:	19 f5       	brne	.+70     	; 0xd082 <UserInput+0x336>
		      strResult[iValuePos]=0;
    d03c:	80 91 7c 02 	lds	r24, 0x027C
    d040:	fe 01       	movw	r30, r28
    d042:	e8 0f       	add	r30, r24
    d044:	f1 1d       	adc	r31, r1
    d046:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    d048:	92 30       	cpi	r25, 0x02	; 2
    d04a:	a8 f4       	brcc	.+42     	; 0xd076 <UserInput+0x32a>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    d04c:	88 23       	and	r24, r24
    d04e:	81 f4       	brne	.+32     	; 0xd070 <UserInput+0x324>
    d050:	00 d0       	rcall	.+0      	; 0xd052 <UserInput+0x306>
    d052:	00 d0       	rcall	.+0      	; 0xd054 <UserInput+0x308>
    d054:	ed b7       	in	r30, 0x3d	; 61
    d056:	fe b7       	in	r31, 0x3e	; 62
    d058:	d2 83       	std	Z+2, r29	; 0x02
    d05a:	c1 83       	std	Z+1, r28	; 0x01
    d05c:	87 e4       	ldi	r24, 0x47	; 71
    d05e:	9b e1       	ldi	r25, 0x1B	; 27
    d060:	94 83       	std	Z+4, r25	; 0x04
    d062:	83 83       	std	Z+3, r24	; 0x03
    d064:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    d068:	0f 90       	pop	r0
    d06a:	0f 90       	pop	r0
    d06c:	0f 90       	pop	r0
    d06e:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    d070:	ce 01       	movw	r24, r28
    d072:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    d076:	83 e0       	ldi	r24, 0x03	; 3
    d078:	80 93 80 02 	sts	0x0280, r24
		      stUserInput=uiFinished;
    d07c:	84 e0       	ldi	r24, 0x04	; 4
    d07e:	80 93 7f 02 	sts	0x027F, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    d082:	80 91 70 02 	lds	r24, 0x0270
    d086:	90 91 71 02 	lds	r25, 0x0271
    d08a:	60 ed       	ldi	r22, 0xD0	; 208
    d08c:	77 e0       	ldi	r23, 0x07	; 7
    d08e:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    d092:	89 2b       	or	r24, r25
    d094:	09 f0       	breq	.+2      	; 0xd098 <UserInput+0x34c>
    d096:	4b c0       	rjmp	.+150    	; 0xd12e <UserInput+0x3e2>
		      if (IsSameKey==True)
    d098:	80 91 75 02 	lds	r24, 0x0275
    d09c:	81 30       	cpi	r24, 0x01	; 1
    d09e:	c9 f4       	brne	.+50     	; 0xd0d2 <UserInput+0x386>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
    d0a0:	20 91 7c 02 	lds	r18, 0x027C
    d0a4:	82 2f       	mov	r24, r18
    d0a6:	90 e0       	ldi	r25, 0x00	; 0
    d0a8:	01 97       	sbiw	r24, 0x01	; 1
    d0aa:	8d 0d       	add	r24, r13
    d0ac:	91 1d       	adc	r25, r1
    d0ae:	64 e1       	ldi	r22, 0x14	; 20
    d0b0:	70 e0       	ldi	r23, 0x00	; 0
    d0b2:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    d0b6:	36 2f       	mov	r19, r22
    d0b8:	82 2f       	mov	r24, r18
    d0ba:	64 e1       	ldi	r22, 0x14	; 20
    d0bc:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    d0c0:	6d 2d       	mov	r22, r13
    d0c2:	69 0f       	add	r22, r25
    d0c4:	89 2d       	mov	r24, r9
    d0c6:	83 0f       	add	r24, r19
    d0c8:	40 91 79 02 	lds	r20, 0x0279
    d0cc:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
    d0d0:	2e c0       	rjmp	.+92     	; 0xd12e <UserInput+0x3e2>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    d0d2:	f5 e0       	ldi	r31, 0x05	; 5
    d0d4:	ff 16       	cp	r15, r31
    d0d6:	61 f4       	brne	.+24     	; 0xd0f0 <UserInput+0x3a4>
    d0d8:	80 91 7c 02 	lds	r24, 0x027C
    d0dc:	88 23       	and	r24, r24
    d0de:	41 f0       	breq	.+16     	; 0xd0f0 <UserInput+0x3a4>
    d0e0:	60 91 7d 02 	lds	r22, 0x027D
    d0e4:	61 50       	subi	r22, 0x01	; 1
    d0e6:	80 91 7e 02 	lds	r24, 0x027E
    d0ea:	4a e2       	ldi	r20, 0x2A	; 42
    d0ec:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
    d0f0:	20 91 7c 02 	lds	r18, 0x027C
    d0f4:	82 2f       	mov	r24, r18
    d0f6:	90 e0       	ldi	r25, 0x00	; 0
    d0f8:	01 97       	sbiw	r24, 0x01	; 1
    d0fa:	8d 0d       	add	r24, r13
    d0fc:	91 1d       	adc	r25, r1
    d0fe:	64 e1       	ldi	r22, 0x14	; 20
    d100:	70 e0       	ldi	r23, 0x00	; 0
    d102:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    d106:	36 2f       	mov	r19, r22
    d108:	82 2f       	mov	r24, r18
    d10a:	64 e1       	ldi	r22, 0x14	; 20
    d10c:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    d110:	6d 2d       	mov	r22, r13
    d112:	69 0f       	add	r22, r25
    d114:	89 2d       	mov	r24, r9
    d116:	83 0f       	add	r24, r19
    d118:	4f e5       	ldi	r20, 0x5F	; 95
    d11a:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>

				  if (IsFirst==True){
    d11e:	80 91 72 02 	lds	r24, 0x0272
    d122:	81 30       	cpi	r24, 0x01	; 1
    d124:	21 f4       	brne	.+8      	; 0xd12e <UserInput+0x3e2>
				      IsFirst=False;
    d126:	10 92 72 02 	sts	0x0272, r1
				      zKeyChar=0;
    d12a:	10 92 7b 02 	sts	0x027B, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
    d12e:	80 91 70 02 	lds	r24, 0x0270
    d132:	90 91 71 02 	lds	r25, 0x0271
    d136:	60 ed       	ldi	r22, 0xD0	; 208
    d138:	77 e0       	ldi	r23, 0x07	; 7
    d13a:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    d13e:	88 5e       	subi	r24, 0xE8	; 232
    d140:	93 40       	sbci	r25, 0x03	; 3
    d142:	d1 f5       	brne	.+116    	; 0xd1b8 <UserInput+0x46c>
		      if (IsSameKey==True){
    d144:	80 91 75 02 	lds	r24, 0x0275
    d148:	81 30       	cpi	r24, 0x01	; 1
    d14a:	f9 f4       	brne	.+62     	; 0xd18a <UserInput+0x43e>
			      if (TypeUI!=UI_NUM_PASSWORD)
    d14c:	84 e0       	ldi	r24, 0x04	; 4
    d14e:	f8 16       	cp	r15, r24
    d150:	b1 f0       	breq	.+44     	; 0xd17e <UserInput+0x432>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
    d152:	80 91 7c 02 	lds	r24, 0x027C
    d156:	90 e0       	ldi	r25, 0x00	; 0
    d158:	01 97       	sbiw	r24, 0x01	; 1
    d15a:	8d 0d       	add	r24, r13
    d15c:	91 1d       	adc	r25, r1
    d15e:	64 e1       	ldi	r22, 0x14	; 20
    d160:	70 e0       	ldi	r23, 0x00	; 0
    d162:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    d166:	26 2f       	mov	r18, r22
    d168:	80 91 7d 02 	lds	r24, 0x027D
    d16c:	65 e1       	ldi	r22, 0x15	; 21
    d16e:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    d172:	89 2d       	mov	r24, r9
    d174:	82 0f       	add	r24, r18
    d176:	69 2f       	mov	r22, r25
    d178:	40 91 79 02 	lds	r20, 0x0279
    d17c:	1b c0       	rjmp	.+54     	; 0xd1b4 <UserInput+0x468>
					   
				  else lcd_put(xChar,yChar,'*'); 
    d17e:	80 91 7e 02 	lds	r24, 0x027E
    d182:	60 91 7d 02 	lds	r22, 0x027D
    d186:	4a e2       	ldi	r20, 0x2A	; 42
    d188:	15 c0       	rjmp	.+42     	; 0xd1b4 <UserInput+0x468>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
    d18a:	20 91 7c 02 	lds	r18, 0x027C
    d18e:	82 2f       	mov	r24, r18
    d190:	90 e0       	ldi	r25, 0x00	; 0
    d192:	01 97       	sbiw	r24, 0x01	; 1
    d194:	8d 0d       	add	r24, r13
    d196:	91 1d       	adc	r25, r1
    d198:	64 e1       	ldi	r22, 0x14	; 20
    d19a:	70 e0       	ldi	r23, 0x00	; 0
    d19c:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    d1a0:	36 2f       	mov	r19, r22
    d1a2:	82 2f       	mov	r24, r18
    d1a4:	64 e1       	ldi	r22, 0x14	; 20
    d1a6:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    d1aa:	d9 0e       	add	r13, r25
    d1ac:	89 2d       	mov	r24, r9
    d1ae:	83 0f       	add	r24, r19
    d1b0:	6d 2d       	mov	r22, r13
    d1b2:	40 e2       	ldi	r20, 0x20	; 32
    d1b4:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			  }
          iLoop++;
    d1b8:	80 91 70 02 	lds	r24, 0x0270
    d1bc:	90 91 71 02 	lds	r25, 0x0271
    d1c0:	01 96       	adiw	r24, 0x01	; 1
    d1c2:	90 93 71 02 	sts	0x0271, r25
    d1c6:	80 93 70 02 	sts	0x0270, r24
    d1ca:	d6 c0       	rjmp	.+428    	; 0xd378 <UserInput+0x62c>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
    d1cc:	e2 e0       	ldi	r30, 0x02	; 2
    d1ce:	8e 17       	cp	r24, r30
    d1d0:	99 f4       	brne	.+38     	; 0xd1f8 <UserInput+0x4ac>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
    d1d2:	60 91 7d 02 	lds	r22, 0x027D
    d1d6:	80 91 7c 02 	lds	r24, 0x027C
    d1da:	68 1b       	sub	r22, r24
    d1dc:	80 91 7e 02 	lds	r24, 0x027E
    d1e0:	40 e2       	ldi	r20, 0x20	; 32
    d1e2:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
		      strResult[iValuePos]=0;
    d1e6:	80 91 7c 02 	lds	r24, 0x027C
    d1ea:	c8 0f       	add	r28, r24
    d1ec:	d1 1d       	adc	r29, r1
    d1ee:	18 82       	st	Y, r1
		      iValuePos--;
    d1f0:	81 50       	subi	r24, 0x01	; 1
    d1f2:	80 93 7c 02 	sts	0x027C, r24
    d1f6:	33 c0       	rjmp	.+102    	; 0xd25e <UserInput+0x512>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    d1f8:	f1 e0       	ldi	r31, 0x01	; 1
    d1fa:	8f 17       	cp	r24, r31
    d1fc:	49 f0       	breq	.+18     	; 0xd210 <UserInput+0x4c4>
    d1fe:	23 e0       	ldi	r18, 0x03	; 3
    d200:	82 17       	cp	r24, r18
    d202:	31 f0       	breq	.+12     	; 0xd210 <UserInput+0x4c4>
    d204:	84 e0       	ldi	r24, 0x04	; 4
    d206:	f8 16       	cp	r15, r24
    d208:	19 f0       	breq	.+6      	; 0xd210 <UserInput+0x4c4>
    d20a:	e5 e0       	ldi	r30, 0x05	; 5
    d20c:	fe 16       	cp	r15, r30
    d20e:	39 f5       	brne	.+78     	; 0xd25e <UserInput+0x512>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
    d210:	20 91 7c 02 	lds	r18, 0x027C
    d214:	82 2f       	mov	r24, r18
    d216:	90 e0       	ldi	r25, 0x00	; 0
    d218:	01 97       	sbiw	r24, 0x01	; 1
    d21a:	8d 0d       	add	r24, r13
    d21c:	91 1d       	adc	r25, r1
    d21e:	64 e1       	ldi	r22, 0x14	; 20
    d220:	70 e0       	ldi	r23, 0x00	; 0
    d222:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    d226:	36 2f       	mov	r19, r22
    d228:	82 2f       	mov	r24, r18
    d22a:	64 e1       	ldi	r22, 0x14	; 20
    d22c:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    d230:	d9 0e       	add	r13, r25
    d232:	89 2d       	mov	r24, r9
    d234:	83 0f       	add	r24, r19
    d236:	6d 2d       	mov	r22, r13
    d238:	40 e2       	ldi	r20, 0x20	; 32
    d23a:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			  
		      strResult[iValuePos]=0;
    d23e:	80 91 7c 02 	lds	r24, 0x027C
    d242:	c8 0f       	add	r28, r24
    d244:	d1 1d       	adc	r29, r1
    d246:	18 82       	st	Y, r1
		      iValuePos--;
    d248:	81 50       	subi	r24, 0x01	; 1
    d24a:	80 93 7c 02 	sts	0x027C, r24
			  yChar--;
    d24e:	80 91 7d 02 	lds	r24, 0x027D
    d252:	81 50       	subi	r24, 0x01	; 1
    d254:	80 93 7d 02 	sts	0x027D, r24
			  IsDelete=True;
    d258:	81 e0       	ldi	r24, 0x01	; 1
    d25a:	80 93 78 02 	sts	0x0278, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
    d25e:	80 91 7c 02 	lds	r24, 0x027C
    d262:	88 23       	and	r24, r24
    d264:	19 f4       	brne	.+6      	; 0xd26c <UserInput+0x520>
    d266:	65 e0       	ldi	r22, 0x05	; 5
    d268:	e6 2e       	mov	r14, r22
    d26a:	01 c0       	rjmp	.+2      	; 0xd26e <UserInput+0x522>
    d26c:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
    d26e:	83 e0       	ldi	r24, 0x03	; 3
    d270:	80 93 7f 02 	sts	0x027F, r24
    d274:	81 c0       	rjmp	.+258    	; 0xd378 <UserInput+0x62c>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
    d276:	f5 e0       	ldi	r31, 0x05	; 5
    d278:	8f 17       	cp	r24, r31
    d27a:	19 f5       	brne	.+70     	; 0xd2c2 <UserInput+0x576>
			  if (iValuePos>0){
    d27c:	80 91 7c 02 	lds	r24, 0x027C
    d280:	88 23       	and	r24, r24
    d282:	a9 f0       	breq	.+42     	; 0xd2ae <UserInput+0x562>
                  lcd_put(xChar,(yChar-2),'*');
    d284:	60 91 7d 02 	lds	r22, 0x027D
    d288:	62 50       	subi	r22, 0x02	; 2
    d28a:	80 91 7e 02 	lds	r24, 0x027E
    d28e:	4a e2       	ldi	r20, 0x2A	; 42
    d290:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			      if (IsDelete==True){
    d294:	80 91 78 02 	lds	r24, 0x0278
    d298:	60 91 7d 02 	lds	r22, 0x027D
    d29c:	81 30       	cpi	r24, 0x01	; 1
    d29e:	71 f0       	breq	.+28     	; 0xd2bc <UserInput+0x570>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
    d2a0:	61 50       	subi	r22, 0x01	; 1
    d2a2:	80 91 7c 02 	lds	r24, 0x027C
    d2a6:	c8 0f       	add	r28, r24
    d2a8:	d1 1d       	adc	r29, r1
    d2aa:	21 97       	sbiw	r28, 0x01	; 1
    d2ac:	4d c0       	rjmp	.+154    	; 0xd348 <UserInput+0x5fc>
			      }
			  else{ if(IsDelete==True){
    d2ae:	80 91 78 02 	lds	r24, 0x0278
    d2b2:	60 91 7d 02 	lds	r22, 0x027D
    d2b6:	81 30       	cpi	r24, 0x01	; 1
    d2b8:	09 f0       	breq	.+2      	; 0xd2bc <UserInput+0x570>
    d2ba:	45 c0       	rjmp	.+138    	; 0xd346 <UserInput+0x5fa>
			           IsDelete=False;
    d2bc:	10 92 78 02 	sts	0x0278, r1
    d2c0:	4c c0       	rjmp	.+152    	; 0xd35a <UserInput+0x60e>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
    d2c2:	22 e0       	ldi	r18, 0x02	; 2
    d2c4:	82 17       	cp	r24, r18
    d2c6:	a1 f4       	brne	.+40     	; 0xd2f0 <UserInput+0x5a4>
    d2c8:	10 e0       	ldi	r17, 0x00	; 0
    d2ca:	0d c0       	rjmp	.+26     	; 0xd2e6 <UserInput+0x59a>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
    d2cc:	60 91 7d 02 	lds	r22, 0x027D
    d2d0:	68 1b       	sub	r22, r24
    d2d2:	61 0f       	add	r22, r17
    d2d4:	fe 01       	movw	r30, r28
    d2d6:	e1 0f       	add	r30, r17
    d2d8:	f1 1d       	adc	r31, r1
    d2da:	80 91 7e 02 	lds	r24, 0x027E
    d2de:	40 81       	ld	r20, Z
    d2e0:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
    d2e4:	1f 5f       	subi	r17, 0xFF	; 255
    d2e6:	80 91 7c 02 	lds	r24, 0x027C
    d2ea:	18 17       	cp	r17, r24
    d2ec:	78 f3       	brcs	.-34     	; 0xd2cc <UserInput+0x580>
    d2ee:	3b c0       	rjmp	.+118    	; 0xd366 <UserInput+0x61a>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
    d2f0:	81 e0       	ldi	r24, 0x01	; 1
    d2f2:	f8 16       	cp	r15, r24
    d2f4:	19 f0       	breq	.+6      	; 0xd2fc <UserInput+0x5b0>
    d2f6:	e3 e0       	ldi	r30, 0x03	; 3
    d2f8:	fe 16       	cp	r15, r30
    d2fa:	51 f5       	brne	.+84     	; 0xd350 <UserInput+0x604>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
    d2fc:	20 91 7c 02 	lds	r18, 0x027C
    d300:	4d 2d       	mov	r20, r13
    d302:	50 e0       	ldi	r21, 0x00	; 0
    d304:	22 23       	and	r18, r18
    d306:	c1 f0       	breq	.+48     	; 0xd338 <UserInput+0x5ec>
    d308:	30 e0       	ldi	r19, 0x00	; 0
    d30a:	f9 01       	movw	r30, r18
    d30c:	31 97       	sbiw	r30, 0x01	; 1
    d30e:	cf 01       	movw	r24, r30
    d310:	84 0f       	add	r24, r20
    d312:	95 1f       	adc	r25, r21
    d314:	65 e1       	ldi	r22, 0x15	; 21
    d316:	70 e0       	ldi	r23, 0x00	; 0
    d318:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    d31c:	46 2f       	mov	r20, r22
    d31e:	cf 01       	movw	r24, r30
    d320:	64 e1       	ldi	r22, 0x14	; 20
    d322:	70 e0       	ldi	r23, 0x00	; 0
    d324:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    d328:	d8 0e       	add	r13, r24
    d32a:	c2 0f       	add	r28, r18
    d32c:	d3 1f       	adc	r29, r19
    d32e:	21 97       	sbiw	r28, 0x01	; 1
    d330:	89 2d       	mov	r24, r9
    d332:	84 0f       	add	r24, r20
    d334:	6d 2d       	mov	r22, r13
    d336:	0a c0       	rjmp	.+20     	; 0xd34c <UserInput+0x600>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
    d338:	60 91 7d 02 	lds	r22, 0x027D
    d33c:	86 2f       	mov	r24, r22
    d33e:	90 e0       	ldi	r25, 0x00	; 0
    d340:	48 17       	cp	r20, r24
    d342:	59 07       	cpc	r21, r25
    d344:	84 f4       	brge	.+32     	; 0xd366 <UserInput+0x61a>
    d346:	61 50       	subi	r22, 0x01	; 1
    d348:	80 91 7e 02 	lds	r24, 0x027E
    d34c:	48 81       	ld	r20, Y
    d34e:	09 c0       	rjmp	.+18     	; 0xd362 <UserInput+0x616>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
    d350:	f4 e0       	ldi	r31, 0x04	; 4
    d352:	ff 16       	cp	r15, r31
    d354:	41 f4       	brne	.+16     	; 0xd366 <UserInput+0x61a>
		      lcd_put(xChar,(yChar-1),'*');
    d356:	60 91 7d 02 	lds	r22, 0x027D
    d35a:	61 50       	subi	r22, 0x01	; 1
    d35c:	80 91 7e 02 	lds	r24, 0x027E
    d360:	4a e2       	ldi	r20, 0x2A	; 42
    d362:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
		  }

          stUserInput=uiInput;
    d366:	81 e0       	ldi	r24, 0x01	; 1
    d368:	80 93 7f 02 	sts	0x027F, r24
    d36c:	ee 24       	eor	r14, r14
    d36e:	04 c0       	rjmp	.+8      	; 0xd378 <UserInput+0x62c>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
    d370:	e0 90 80 02 	lds	r14, 0x0280
	      stUserInput=uiInit;
    d374:	10 92 7f 02 	sts	0x027F, r1
	      break;
	 }
	 return Result;
}
    d378:	8e 2d       	mov	r24, r14
    d37a:	df 91       	pop	r29
    d37c:	cf 91       	pop	r28
    d37e:	1f 91       	pop	r17
    d380:	0f 91       	pop	r16
    d382:	ff 90       	pop	r15
    d384:	ef 90       	pop	r14
    d386:	df 90       	pop	r13
    d388:	cf 90       	pop	r12
    d38a:	bf 90       	pop	r11
    d38c:	af 90       	pop	r10
    d38e:	9f 90       	pop	r9
    d390:	8f 90       	pop	r8
    d392:	08 95       	ret

0000d394 <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}

char FSettingOperator(){//Change Active Operator, Change Password
    d394:	ef 92       	push	r14
    d396:	0f 93       	push	r16
    d398:	1f 93       	push	r17
    d39a:	df 93       	push	r29
    d39c:	cf 93       	push	r28
    d39e:	cd b7       	in	r28, 0x3d	; 61
    d3a0:	de b7       	in	r29, 0x3e	; 62
    d3a2:	e5 97       	sbiw	r28, 0x35	; 53
    d3a4:	0f b6       	in	r0, 0x3f	; 63
    d3a6:	f8 94       	cli
    d3a8:	de bf       	out	0x3e, r29	; 62
    d3aa:	0f be       	out	0x3f, r0	; 63
    d3ac:	cd bf       	out	0x3d, r28	; 61
	        char KeyPressed,KeyChar,lcdteks[20],strPassword[15];
			char strOperatorName[18];
			char uiResult=USER_NONE,Result=MENU_NONE;

	 Result=MENU_NONE;
	 switch(stSettingOperator){
    d3ae:	80 91 1e 02 	lds	r24, 0x021E
    d3b2:	87 30       	cpi	r24, 0x07	; 7
    d3b4:	09 f4       	brne	.+2      	; 0xd3b8 <FSettingOperator+0x24>
    d3b6:	78 c1       	rjmp	.+752    	; 0xd6a8 <FSettingOperator+0x314>
    d3b8:	88 30       	cpi	r24, 0x08	; 8
    d3ba:	90 f4       	brcc	.+36     	; 0xd3e0 <FSettingOperator+0x4c>
    d3bc:	83 30       	cpi	r24, 0x03	; 3
    d3be:	09 f4       	brne	.+2      	; 0xd3c2 <FSettingOperator+0x2e>
    d3c0:	a0 c0       	rjmp	.+320    	; 0xd502 <FSettingOperator+0x16e>
    d3c2:	84 30       	cpi	r24, 0x04	; 4
    d3c4:	30 f4       	brcc	.+12     	; 0xd3d2 <FSettingOperator+0x3e>
    d3c6:	81 30       	cpi	r24, 0x01	; 1
    d3c8:	d1 f1       	breq	.+116    	; 0xd43e <FSettingOperator+0xaa>
    d3ca:	82 30       	cpi	r24, 0x02	; 2
    d3cc:	08 f0       	brcs	.+2      	; 0xd3d0 <FSettingOperator+0x3c>
    d3ce:	4a c0       	rjmp	.+148    	; 0xd464 <FSettingOperator+0xd0>
    d3d0:	20 c0       	rjmp	.+64     	; 0xd412 <FSettingOperator+0x7e>
    d3d2:	85 30       	cpi	r24, 0x05	; 5
    d3d4:	09 f4       	brne	.+2      	; 0xd3d8 <FSettingOperator+0x44>
    d3d6:	39 c1       	rjmp	.+626    	; 0xd64a <FSettingOperator+0x2b6>
    d3d8:	86 30       	cpi	r24, 0x06	; 6
    d3da:	08 f0       	brcs	.+2      	; 0xd3de <FSettingOperator+0x4a>
    d3dc:	52 c1       	rjmp	.+676    	; 0xd682 <FSettingOperator+0x2ee>
    d3de:	ff c0       	rjmp	.+510    	; 0xd5de <FSettingOperator+0x24a>
    d3e0:	8b 30       	cpi	r24, 0x0B	; 11
    d3e2:	09 f4       	brne	.+2      	; 0xd3e6 <FSettingOperator+0x52>
    d3e4:	23 c2       	rjmp	.+1094   	; 0xd82c <FSettingOperator+0x498>
    d3e6:	8c 30       	cpi	r24, 0x0C	; 12
    d3e8:	38 f4       	brcc	.+14     	; 0xd3f8 <FSettingOperator+0x64>
    d3ea:	89 30       	cpi	r24, 0x09	; 9
    d3ec:	09 f4       	brne	.+2      	; 0xd3f0 <FSettingOperator+0x5c>
    d3ee:	aa c1       	rjmp	.+852    	; 0xd744 <FSettingOperator+0x3b0>
    d3f0:	8a 30       	cpi	r24, 0x0A	; 10
    d3f2:	08 f0       	brcs	.+2      	; 0xd3f6 <FSettingOperator+0x62>
    d3f4:	da c1       	rjmp	.+948    	; 0xd7aa <FSettingOperator+0x416>
    d3f6:	78 c1       	rjmp	.+752    	; 0xd6e8 <FSettingOperator+0x354>
    d3f8:	8d 30       	cpi	r24, 0x0D	; 13
    d3fa:	09 f4       	brne	.+2      	; 0xd3fe <FSettingOperator+0x6a>
    d3fc:	9b c2       	rjmp	.+1334   	; 0xd934 <FSettingOperator+0x5a0>
    d3fe:	8d 30       	cpi	r24, 0x0D	; 13
    d400:	08 f4       	brcc	.+2      	; 0xd404 <FSettingOperator+0x70>
    d402:	1b c2       	rjmp	.+1078   	; 0xd83a <FSettingOperator+0x4a6>
    d404:	8e 30       	cpi	r24, 0x0E	; 14
    d406:	09 f4       	brne	.+2      	; 0xd40a <FSettingOperator+0x76>
    d408:	9a c2       	rjmp	.+1332   	; 0xd93e <FSettingOperator+0x5aa>
    d40a:	8f 30       	cpi	r24, 0x0F	; 15
    d40c:	09 f0       	breq	.+2      	; 0xd410 <FSettingOperator+0x7c>
    d40e:	a2 c2       	rjmp	.+1348   	; 0xd954 <FSettingOperator+0x5c0>
    d410:	9d c2       	rjmp	.+1338   	; 0xd94c <FSettingOperator+0x5b8>
	 case soMenuOption:
	      lcd_clear();
    d412:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Change Operator"));
    d416:	81 e0       	ldi	r24, 0x01	; 1
    d418:	61 e0       	ldi	r22, 0x01	; 1
    d41a:	41 e6       	ldi	r20, 0x61	; 97
    d41c:	50 e1       	ldi	r21, 0x10	; 16
    d41e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Change Password"));
    d422:	82 e0       	ldi	r24, 0x02	; 2
    d424:	61 e0       	ldi	r22, 0x01	; 1
    d426:	4f e4       	ldi	r20, 0x4F	; 79
    d428:	50 e1       	ldi	r21, 0x10	; 16
    d42a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back          "));
    d42e:	84 e0       	ldi	r24, 0x04	; 4
    d430:	61 e0       	ldi	r22, 0x01	; 1
    d432:	4d e3       	ldi	r20, 0x3D	; 61
    d434:	50 e1       	ldi	r21, 0x10	; 16
    d436:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          stSettingOperator=soMenuOptionInput;
    d43a:	81 e0       	ldi	r24, 0x01	; 1
    d43c:	64 c2       	rjmp	.+1224   	; 0xd906 <FSettingOperator+0x572>
	      break;
     case soMenuOptionInput:
	      KeyPressed=_key_scan(1);
    d43e:	81 e0       	ldi	r24, 0x01	; 1
    d440:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    d444:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  switch(KeyChar){
    d448:	81 33       	cpi	r24, 0x31	; 49
    d44a:	31 f0       	breq	.+12     	; 0xd458 <FSettingOperator+0xc4>
    d44c:	82 33       	cpi	r24, 0x32	; 50
    d44e:	31 f0       	breq	.+12     	; 0xd45c <FSettingOperator+0xc8>
    d450:	8a 32       	cpi	r24, 0x2A	; 42
    d452:	09 f0       	breq	.+2      	; 0xd456 <FSettingOperator+0xc2>
    d454:	7f c2       	rjmp	.+1278   	; 0xd954 <FSettingOperator+0x5c0>
    d456:	04 c0       	rjmp	.+8      	; 0xd460 <FSettingOperator+0xcc>
		  case '1':
		       stSettingOperator=soChangeOperatorInit;
    d458:	82 e0       	ldi	r24, 0x02	; 2
    d45a:	55 c2       	rjmp	.+1194   	; 0xd906 <FSettingOperator+0x572>
		       break;
          case '2':
		       stSettingOperator=soChangePasswordInit;
    d45c:	85 e0       	ldi	r24, 0x05	; 5
    d45e:	53 c2       	rjmp	.+1190   	; 0xd906 <FSettingOperator+0x572>
		       break;
          case '*':
		       stSettingOperator=soExitSettingOperator;
    d460:	8f e0       	ldi	r24, 0x0F	; 15
    d462:	51 c2       	rjmp	.+1186   	; 0xd906 <FSettingOperator+0x572>
		       break;
		  }
	      break;
     case soChangeOperatorInit:
	      lcd_clear();		  
    d464:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d468:	8e 01       	movw	r16, r28
    d46a:	00 5f       	subi	r16, 0xF0	; 240
    d46c:	1f 4f       	sbci	r17, 0xFF	; 255
    d46e:	c8 01       	movw	r24, r16
    d470:	65 e1       	ldi	r22, 0x15	; 21
    d472:	70 e0       	ldi	r23, 0x00	; 0
    d474:	42 e1       	ldi	r20, 0x12	; 18
    d476:	50 e0       	ldi	r21, 0x00	; 0
    d478:	24 e4       	ldi	r18, 0x44	; 68
    d47a:	32 e1       	ldi	r19, 0x12	; 18
    d47c:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d480:	98 01       	movw	r18, r16
    d482:	ce 01       	movw	r24, r28
    d484:	4f 96       	adiw	r24, 0x1f	; 31
	    Dest[i]=Source[IdxSource+i];
    d486:	0f 5f       	subi	r16, 0xFF	; 255
    d488:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d48a:	08 17       	cp	r16, r24
    d48c:	19 07       	cpc	r17, r25
    d48e:	d9 f7       	brne	.-10     	; 0xd486 <FSettingOperator+0xf2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d490:	1f 8e       	std	Y+31, r1	; 0x1f
     case soChangeOperatorInit:
	      lcd_clear();		  
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);

		  sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
    d492:	00 d0       	rcall	.+0      	; 0xd494 <FSettingOperator+0x100>
    d494:	00 d0       	rcall	.+0      	; 0xd496 <FSettingOperator+0x102>
    d496:	00 d0       	rcall	.+0      	; 0xd498 <FSettingOperator+0x104>
    d498:	ed b7       	in	r30, 0x3d	; 61
    d49a:	fe b7       	in	r31, 0x3e	; 62
    d49c:	31 96       	adiw	r30, 0x01	; 1
    d49e:	8e 01       	movw	r16, r28
    d4a0:	0e 5d       	subi	r16, 0xDE	; 222
    d4a2:	1f 4f       	sbci	r17, 0xFF	; 255
    d4a4:	ad b7       	in	r26, 0x3d	; 61
    d4a6:	be b7       	in	r27, 0x3e	; 62
    d4a8:	12 96       	adiw	r26, 0x02	; 2
    d4aa:	1c 93       	st	X, r17
    d4ac:	0e 93       	st	-X, r16
    d4ae:	11 97       	sbiw	r26, 0x01	; 1
    d4b0:	8a e3       	ldi	r24, 0x3A	; 58
    d4b2:	90 e1       	ldi	r25, 0x10	; 16
    d4b4:	93 83       	std	Z+3, r25	; 0x03
    d4b6:	82 83       	std	Z+2, r24	; 0x02
    d4b8:	24 83       	std	Z+4, r18	; 0x04
    d4ba:	35 83       	std	Z+5, r19	; 0x05
    d4bc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_printf(1,1,PSTR("Name:"));
    d4c0:	8d b7       	in	r24, 0x3d	; 61
    d4c2:	9e b7       	in	r25, 0x3e	; 62
    d4c4:	06 96       	adiw	r24, 0x06	; 6
    d4c6:	0f b6       	in	r0, 0x3f	; 63
    d4c8:	f8 94       	cli
    d4ca:	9e bf       	out	0x3e, r25	; 62
    d4cc:	0f be       	out	0x3f, r0	; 63
    d4ce:	8d bf       	out	0x3d, r24	; 61
    d4d0:	81 e0       	ldi	r24, 0x01	; 1
    d4d2:	61 e0       	ldi	r22, 0x01	; 1
    d4d4:	44 e3       	ldi	r20, 0x34	; 52
    d4d6:	50 e1       	ldi	r21, 0x10	; 16
    d4d8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_print (1,6,lcdteks);
    d4dc:	81 e0       	ldi	r24, 0x01	; 1
    d4de:	66 e0       	ldi	r22, 0x06	; 6
    d4e0:	a8 01       	movw	r20, r16
    d4e2:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(2,1,PSTR("New :_              "));
    d4e6:	82 e0       	ldi	r24, 0x02	; 2
    d4e8:	61 e0       	ldi	r22, 0x01	; 1
    d4ea:	4f e1       	ldi	r20, 0x1F	; 31
    d4ec:	50 e1       	ldi	r21, 0x10	; 16
    d4ee:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d4f2:	84 e0       	ldi	r24, 0x04	; 4
    d4f4:	61 e0       	ldi	r22, 0x01	; 1
    d4f6:	4a e0       	ldi	r20, 0x0A	; 10
    d4f8:	50 e1       	ldi	r21, 0x10	; 16
    d4fa:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          stSettingOperator=soOperatorNameInput;
    d4fe:	83 e0       	ldi	r24, 0x03	; 3
    d500:	02 c2       	rjmp	.+1028   	; 0xd906 <FSettingOperator+0x572>
	      break;
     case soOperatorNameInput:
          uiResult=USER_NONE;
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
    d502:	83 e0       	ldi	r24, 0x03	; 3
    d504:	62 e0       	ldi	r22, 0x02	; 2
    d506:	46 e0       	ldi	r20, 0x06	; 6
    d508:	22 e9       	ldi	r18, 0x92	; 146
    d50a:	38 e0       	ldi	r19, 0x08	; 8
    d50c:	00 e0       	ldi	r16, 0x00	; 0
    d50e:	10 e0       	ldi	r17, 0x00	; 0
    d510:	90 e1       	ldi	r25, 0x10	; 16
    d512:	e9 2e       	mov	r14, r25
    d514:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  switch(uiResult){
    d518:	83 30       	cpi	r24, 0x03	; 3
    d51a:	51 f0       	breq	.+20     	; 0xd530 <FSettingOperator+0x19c>
    d51c:	84 30       	cpi	r24, 0x04	; 4
    d51e:	08 f4       	brcc	.+2      	; 0xd522 <FSettingOperator+0x18e>
    d520:	f2 c0       	rjmp	.+484    	; 0xd706 <FSettingOperator+0x372>
    d522:	84 30       	cpi	r24, 0x04	; 4
    d524:	09 f4       	brne	.+2      	; 0xd528 <FSettingOperator+0x194>
    d526:	51 c0       	rjmp	.+162    	; 0xd5ca <FSettingOperator+0x236>
    d528:	85 30       	cpi	r24, 0x05	; 5
    d52a:	09 f0       	breq	.+2      	; 0xd52e <FSettingOperator+0x19a>
    d52c:	13 c2       	rjmp	.+1062   	; 0xd954 <FSettingOperator+0x5c0>
    d52e:	52 c0       	rjmp	.+164    	; 0xd5d4 <FSettingOperator+0x240>
		  case USER_OK:
		       lcd_clear();
    d530:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    d534:	20 e0       	ldi	r18, 0x00	; 0
    d536:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    d538:	ae 01       	movw	r20, r28
    d53a:	40 5f       	subi	r20, 0xF0	; 240
    d53c:	5f 4f       	sbci	r21, 0xFF	; 255
    d53e:	fa 01       	movw	r30, r20
    d540:	e2 0f       	add	r30, r18
    d542:	f3 1f       	adc	r31, r19
    d544:	d9 01       	movw	r26, r18
    d546:	ae 56       	subi	r26, 0x6E	; 110
    d548:	b7 4f       	sbci	r27, 0xF7	; 247
    d54a:	8c 91       	ld	r24, X
    d54c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d54e:	2f 5f       	subi	r18, 0xFF	; 255
    d550:	3f 4f       	sbci	r19, 0xFF	; 255
    d552:	2f 30       	cpi	r18, 0x0F	; 15
    d554:	31 05       	cpc	r19, r1
    d556:	99 f7       	brne	.-26     	; 0xd53e <FSettingOperator+0x1aa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d558:	1f 8e       	std	Y+31, r1	; 0x1f
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
		  switch(uiResult){
		  case USER_OK:
		       lcd_clear();
			   StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
		       sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
    d55a:	00 d0       	rcall	.+0      	; 0xd55c <FSettingOperator+0x1c8>
    d55c:	00 d0       	rcall	.+0      	; 0xd55e <FSettingOperator+0x1ca>
    d55e:	00 d0       	rcall	.+0      	; 0xd560 <FSettingOperator+0x1cc>
    d560:	ed b7       	in	r30, 0x3d	; 61
    d562:	fe b7       	in	r31, 0x3e	; 62
    d564:	31 96       	adiw	r30, 0x01	; 1
    d566:	8e 01       	movw	r16, r28
    d568:	0e 5d       	subi	r16, 0xDE	; 222
    d56a:	1f 4f       	sbci	r17, 0xFF	; 255
    d56c:	ad b7       	in	r26, 0x3d	; 61
    d56e:	be b7       	in	r27, 0x3e	; 62
    d570:	12 96       	adiw	r26, 0x02	; 2
    d572:	1c 93       	st	X, r17
    d574:	0e 93       	st	-X, r16
    d576:	11 97       	sbiw	r26, 0x01	; 1
    d578:	87 e0       	ldi	r24, 0x07	; 7
    d57a:	90 e1       	ldi	r25, 0x10	; 16
    d57c:	93 83       	std	Z+3, r25	; 0x03
    d57e:	82 83       	std	Z+2, r24	; 0x02
    d580:	55 83       	std	Z+5, r21	; 0x05
    d582:	44 83       	std	Z+4, r20	; 0x04
    d584:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			   lcd_printf(1,1,PSTR("New Operator:"));
    d588:	8d b7       	in	r24, 0x3d	; 61
    d58a:	9e b7       	in	r25, 0x3e	; 62
    d58c:	06 96       	adiw	r24, 0x06	; 6
    d58e:	0f b6       	in	r0, 0x3f	; 63
    d590:	f8 94       	cli
    d592:	9e bf       	out	0x3e, r25	; 62
    d594:	0f be       	out	0x3f, r0	; 63
    d596:	8d bf       	out	0x3d, r24	; 61
    d598:	81 e0       	ldi	r24, 0x01	; 1
    d59a:	61 e0       	ldi	r22, 0x01	; 1
    d59c:	49 ef       	ldi	r20, 0xF9	; 249
    d59e:	5f e0       	ldi	r21, 0x0F	; 15
    d5a0:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   lcd_print (2,1,lcdteks);
    d5a4:	82 e0       	ldi	r24, 0x02	; 2
    d5a6:	61 e0       	ldi	r22, 0x01	; 1
    d5a8:	a8 01       	movw	r20, r16
    d5aa:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			   lcd_printf(3,1,PSTR("Save?"));
    d5ae:	83 e0       	ldi	r24, 0x03	; 3
    d5b0:	61 e0       	ldi	r22, 0x01	; 1
    d5b2:	43 ef       	ldi	r20, 0xF3	; 243
    d5b4:	5f e0       	ldi	r21, 0x0F	; 15
    d5b6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]No    [#]Yes"));
    d5ba:	84 e0       	ldi	r24, 0x04	; 4
    d5bc:	61 e0       	ldi	r22, 0x01	; 1
    d5be:	43 ee       	ldi	r20, 0xE3	; 227
    d5c0:	5f e0       	ldi	r21, 0x0F	; 15
    d5c2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
               stSettingOperator=soIsSaveOperatorName;
    d5c6:	84 e0       	ldi	r24, 0x04	; 4
    d5c8:	9e c1       	rjmp	.+828    	; 0xd906 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    d5ca:	84 e0       	ldi	r24, 0x04	; 4
    d5cc:	61 e0       	ldi	r22, 0x01	; 1
    d5ce:	4e ec       	ldi	r20, 0xCE	; 206
    d5d0:	5f e0       	ldi	r21, 0x0F	; 15
    d5d2:	29 c1       	rjmp	.+594    	; 0xd826 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d5d4:	84 e0       	ldi	r24, 0x04	; 4
    d5d6:	61 e0       	ldi	r22, 0x01	; 1
    d5d8:	49 eb       	ldi	r20, 0xB9	; 185
    d5da:	5f e0       	ldi	r21, 0x0F	; 15
    d5dc:	24 c1       	rjmp	.+584    	; 0xd826 <FSettingOperator+0x492>
		       break;
		  }
	      break;
     case soIsSaveOperatorName:
          KeyPressed=_key_scan(1);
    d5de:	81 e0       	ldi	r24, 0x01	; 1
    d5e0:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    d5e4:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  switch(KeyChar){
    d5e8:	83 32       	cpi	r24, 0x23	; 35
    d5ea:	09 f0       	breq	.+2      	; 0xd5ee <FSettingOperator+0x25a>
    d5ec:	53 c0       	rjmp	.+166    	; 0xd694 <FSettingOperator+0x300>
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
    d5ee:	20 e0       	ldi	r18, 0x00	; 0
    d5f0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    d5f2:	8e 01       	movw	r16, r28
    d5f4:	00 5f       	subi	r16, 0xF0	; 240
    d5f6:	1f 4f       	sbci	r17, 0xFF	; 255
    d5f8:	f8 01       	movw	r30, r16
    d5fa:	e2 0f       	add	r30, r18
    d5fc:	f3 1f       	adc	r31, r19
    d5fe:	d9 01       	movw	r26, r18
    d600:	ae 56       	subi	r26, 0x6E	; 110
    d602:	b7 4f       	sbci	r27, 0xF7	; 247
    d604:	8c 91       	ld	r24, X
    d606:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    d608:	2f 5f       	subi	r18, 0xFF	; 255
    d60a:	3f 4f       	sbci	r19, 0xFF	; 255
    d60c:	2f 30       	cpi	r18, 0x0F	; 15
    d60e:	31 05       	cpc	r19, r1
    d610:	99 f7       	brne	.-26     	; 0xd5f8 <FSettingOperator+0x264>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    d612:	1f 8e       	std	Y+31, r1	; 0x1f
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
          case '#':
		       StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
               AddSpaceLag(strOperatorName,18); 
    d614:	c8 01       	movw	r24, r16
    d616:	62 e1       	ldi	r22, 0x12	; 18
    d618:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    d61c:	85 e1       	ldi	r24, 0x15	; 21
    d61e:	90 e0       	ldi	r25, 0x00	; 0
    d620:	b8 01       	movw	r22, r16
    d622:	42 e1       	ldi	r20, 0x12	; 18
    d624:	50 e0       	ldi	r21, 0x00	; 0
    d626:	2c e4       	ldi	r18, 0x4C	; 76
    d628:	32 e1       	ldi	r19, 0x12	; 18
    d62a:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
		       eeprom_write_block((const void*) &strOperatorName, (void*) &DefOperatorName,18);
		       lcd_printf(3,1,PSTR("Saved "));
    d62e:	83 e0       	ldi	r24, 0x03	; 3
    d630:	61 e0       	ldi	r22, 0x01	; 1
    d632:	42 eb       	ldi	r20, 0xB2	; 178
    d634:	5f e0       	ldi	r21, 0x0F	; 15
    d636:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   TimDisplay=0;
    d63a:	10 92 92 01 	sts	0x0192, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d63e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d640:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d642:	81 e0       	ldi	r24, 0x01	; 1
    d644:	80 93 bc 01 	sts	0x01BC, r24
    d648:	46 c1       	rjmp	.+652    	; 0xd8d6 <FSettingOperator+0x542>
		       stSettingOperator=soDelayDisplaySaved;
		       break;
		  }	      
		  break;
     case soChangePasswordInit:
	      lcd_clear();
    d64a:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("-Change Password-"));
    d64e:	81 e0       	ldi	r24, 0x01	; 1
    d650:	61 e0       	ldi	r22, 0x01	; 1
    d652:	40 ea       	ldi	r20, 0xA0	; 160
    d654:	5f e0       	ldi	r21, 0x0F	; 15
    d656:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Supervisor"));
    d65a:	82 e0       	ldi	r24, 0x02	; 2
    d65c:	61 e0       	ldi	r22, 0x01	; 1
    d65e:	43 e9       	ldi	r20, 0x93	; 147
    d660:	5f e0       	ldi	r21, 0x0F	; 15
    d662:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Administrator"));
    d666:	83 e0       	ldi	r24, 0x03	; 3
    d668:	61 e0       	ldi	r22, 0x01	; 1
    d66a:	43 e8       	ldi	r20, 0x83	; 131
    d66c:	5f e0       	ldi	r21, 0x0F	; 15
    d66e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back     "));
    d672:	84 e0       	ldi	r24, 0x04	; 4
    d674:	61 e0       	ldi	r22, 0x01	; 1
    d676:	46 e7       	ldi	r20, 0x76	; 118
    d678:	5f e0       	ldi	r21, 0x0F	; 15
    d67a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          stSettingOperator=soChangePasswordInput; 
    d67e:	86 e0       	ldi	r24, 0x06	; 6
    d680:	42 c1       	rjmp	.+644    	; 0xd906 <FSettingOperator+0x572>
	      break;
     case soChangePasswordInput:
          KeyPressed=_key_scan(1);
    d682:	81 e0       	ldi	r24, 0x01	; 1
    d684:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    d688:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  switch(KeyChar){
    d68c:	81 33       	cpi	r24, 0x31	; 49
    d68e:	31 f0       	breq	.+12     	; 0xd69c <FSettingOperator+0x308>
    d690:	82 33       	cpi	r24, 0x32	; 50
    d692:	31 f0       	breq	.+12     	; 0xd6a0 <FSettingOperator+0x30c>
    d694:	8a 32       	cpi	r24, 0x2A	; 42
    d696:	09 f0       	breq	.+2      	; 0xd69a <FSettingOperator+0x306>
    d698:	5d c1       	rjmp	.+698    	; 0xd954 <FSettingOperator+0x5c0>
    d69a:	55 c1       	rjmp	.+682    	; 0xd946 <FSettingOperator+0x5b2>
		  case '1':		 
		       PassType=PT_SUPERVISOR;
    d69c:	81 e0       	ldi	r24, 0x01	; 1
    d69e:	01 c0       	rjmp	.+2      	; 0xd6a2 <FSettingOperator+0x30e>
		       stSettingOperator=soOldPasswordDisplay;
		       break;
          case '2':		       
		       PassType=PT_ADMINISTRATOR;
    d6a0:	82 e0       	ldi	r24, 0x02	; 2
    d6a2:	80 93 1d 02 	sts	0x021D, r24
    d6a6:	75 c0       	rjmp	.+234    	; 0xd792 <FSettingOperator+0x3fe>
		       stSettingOperator=soMenuOption;
		       break;
		  }	      
	      break;
     case soOldPasswordDisplay:
	 	  lcd_clear();
    d6a8:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	      if (PassType==PT_SUPERVISOR){
    d6ac:	80 91 1d 02 	lds	r24, 0x021D
    d6b0:	81 30       	cpi	r24, 0x01	; 1
    d6b2:	21 f4       	brne	.+8      	; 0xd6bc <FSettingOperator+0x328>
		      lcd_printf(1,1,PSTR("-Supervisor-"));              
    d6b4:	61 e0       	ldi	r22, 0x01	; 1
    d6b6:	49 e6       	ldi	r20, 0x69	; 105
    d6b8:	5f e0       	ldi	r21, 0x0F	; 15
    d6ba:	06 c0       	rjmp	.+12     	; 0xd6c8 <FSettingOperator+0x334>
		  }else if (PassType==PT_ADMINISTRATOR){		       
    d6bc:	82 30       	cpi	r24, 0x02	; 2
    d6be:	31 f4       	brne	.+12     	; 0xd6cc <FSettingOperator+0x338>
		       lcd_printf(1,1,PSTR("-Administrator-"));			   
    d6c0:	81 e0       	ldi	r24, 0x01	; 1
    d6c2:	61 e0       	ldi	r22, 0x01	; 1
    d6c4:	49 e5       	ldi	r20, 0x59	; 89
    d6c6:	5f e0       	ldi	r21, 0x0F	; 15
    d6c8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  }
		      lcd_printf(2,1,PSTR("Old:_"));
    d6cc:	82 e0       	ldi	r24, 0x02	; 2
    d6ce:	61 e0       	ldi	r22, 0x01	; 1
    d6d0:	43 e5       	ldi	r20, 0x53	; 83
    d6d2:	5f e0       	ldi	r21, 0x0F	; 15
    d6d4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d6d8:	84 e0       	ldi	r24, 0x04	; 4
    d6da:	61 e0       	ldi	r22, 0x01	; 1
    d6dc:	4e e3       	ldi	r20, 0x3E	; 62
    d6de:	5f e0       	ldi	r21, 0x0F	; 15
    d6e0:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>

          stSettingOperator=soOldPasswordEntry;
    d6e4:	88 e0       	ldi	r24, 0x08	; 8
    d6e6:	0f c1       	rjmp	.+542    	; 0xd906 <FSettingOperator+0x572>
	      break;
     case soOldPasswordEntry:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine1,0,8);           
    d6e8:	84 e0       	ldi	r24, 0x04	; 4
    d6ea:	62 e0       	ldi	r22, 0x02	; 2
    d6ec:	45 e0       	ldi	r20, 0x05	; 5
    d6ee:	22 e9       	ldi	r18, 0x92	; 146
    d6f0:	38 e0       	ldi	r19, 0x08	; 8
    d6f2:	00 e0       	ldi	r16, 0x00	; 0
    d6f4:	10 e0       	ldi	r17, 0x00	; 0
    d6f6:	b8 e0       	ldi	r27, 0x08	; 8
    d6f8:	eb 2e       	mov	r14, r27
    d6fa:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  switch(uiResult){
    d6fe:	83 30       	cpi	r24, 0x03	; 3
    d700:	61 f0       	breq	.+24     	; 0xd71a <FSettingOperator+0x386>
    d702:	84 30       	cpi	r24, 0x04	; 4
    d704:	20 f4       	brcc	.+8      	; 0xd70e <FSettingOperator+0x37a>
    d706:	81 30       	cpi	r24, 0x01	; 1
    d708:	09 f0       	breq	.+2      	; 0xd70c <FSettingOperator+0x378>
    d70a:	24 c1       	rjmp	.+584    	; 0xd954 <FSettingOperator+0x5c0>
    d70c:	1c c1       	rjmp	.+568    	; 0xd946 <FSettingOperator+0x5b2>
    d70e:	84 30       	cpi	r24, 0x04	; 4
    d710:	79 f0       	breq	.+30     	; 0xd730 <FSettingOperator+0x39c>
    d712:	85 30       	cpi	r24, 0x05	; 5
    d714:	09 f0       	breq	.+2      	; 0xd718 <FSettingOperator+0x384>
    d716:	1e c1       	rjmp	.+572    	; 0xd954 <FSettingOperator+0x5c0>
    d718:	10 c0       	rjmp	.+32     	; 0xd73a <FSettingOperator+0x3a6>
		  case USER_OK:
		       lcd_printf(2,1,PSTR("New:_               "));
    d71a:	82 e0       	ldi	r24, 0x02	; 2
    d71c:	61 e0       	ldi	r22, 0x01	; 1
    d71e:	49 e2       	ldi	r20, 0x29	; 41
    d720:	5f e0       	ldi	r21, 0x0F	; 15
    d722:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d726:	84 e0       	ldi	r24, 0x04	; 4
    d728:	61 e0       	ldi	r22, 0x01	; 1
    d72a:	44 e1       	ldi	r20, 0x14	; 20
    d72c:	5f e0       	ldi	r21, 0x0F	; 15
    d72e:	6e c0       	rjmp	.+220    	; 0xd80c <FSettingOperator+0x478>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    d730:	84 e0       	ldi	r24, 0x04	; 4
    d732:	61 e0       	ldi	r22, 0x01	; 1
    d734:	4f ef       	ldi	r20, 0xFF	; 255
    d736:	5e e0       	ldi	r21, 0x0E	; 14
    d738:	76 c0       	rjmp	.+236    	; 0xd826 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d73a:	84 e0       	ldi	r24, 0x04	; 4
    d73c:	61 e0       	ldi	r22, 0x01	; 1
    d73e:	4a ee       	ldi	r20, 0xEA	; 234
    d740:	5e e0       	ldi	r21, 0x0E	; 14
    d742:	71 c0       	rjmp	.+226    	; 0xd826 <FSettingOperator+0x492>
		       break;
		  }
	      break;
     case soNewPasswordEntry1:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine2,0,8);           
    d744:	84 e0       	ldi	r24, 0x04	; 4
    d746:	62 e0       	ldi	r22, 0x02	; 2
    d748:	45 e0       	ldi	r20, 0x05	; 5
    d74a:	23 ea       	ldi	r18, 0xA3	; 163
    d74c:	37 e0       	ldi	r19, 0x07	; 7
    d74e:	00 e0       	ldi	r16, 0x00	; 0
    d750:	10 e0       	ldi	r17, 0x00	; 0
    d752:	a8 e0       	ldi	r26, 0x08	; 8
    d754:	ea 2e       	mov	r14, r26
    d756:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  switch(uiResult){
    d75a:	83 30       	cpi	r24, 0x03	; 3
    d75c:	61 f0       	breq	.+24     	; 0xd776 <FSettingOperator+0x3e2>
    d75e:	84 30       	cpi	r24, 0x04	; 4
    d760:	20 f4       	brcc	.+8      	; 0xd76a <FSettingOperator+0x3d6>
    d762:	81 30       	cpi	r24, 0x01	; 1
    d764:	09 f0       	breq	.+2      	; 0xd768 <FSettingOperator+0x3d4>
    d766:	f6 c0       	rjmp	.+492    	; 0xd954 <FSettingOperator+0x5c0>
    d768:	14 c0       	rjmp	.+40     	; 0xd792 <FSettingOperator+0x3fe>
    d76a:	84 30       	cpi	r24, 0x04	; 4
    d76c:	a1 f0       	breq	.+40     	; 0xd796 <FSettingOperator+0x402>
    d76e:	85 30       	cpi	r24, 0x05	; 5
    d770:	09 f0       	breq	.+2      	; 0xd774 <FSettingOperator+0x3e0>
    d772:	f0 c0       	rjmp	.+480    	; 0xd954 <FSettingOperator+0x5c0>
    d774:	15 c0       	rjmp	.+42     	; 0xd7a0 <FSettingOperator+0x40c>
		  case USER_OK:
		       lcd_printf(3,1,PSTR("New:_               "));
    d776:	83 e0       	ldi	r24, 0x03	; 3
    d778:	61 e0       	ldi	r22, 0x01	; 1
    d77a:	45 ed       	ldi	r20, 0xD5	; 213
    d77c:	5e e0       	ldi	r21, 0x0E	; 14
    d77e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d782:	84 e0       	ldi	r24, 0x04	; 4
    d784:	61 e0       	ldi	r22, 0x01	; 1
    d786:	40 ec       	ldi	r20, 0xC0	; 192
    d788:	5e e0       	ldi	r21, 0x0E	; 14
    d78a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry2;
    d78e:	8a e0       	ldi	r24, 0x0A	; 10
    d790:	ba c0       	rjmp	.+372    	; 0xd906 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:		       
			   stSettingOperator=soOldPasswordDisplay;
    d792:	87 e0       	ldi	r24, 0x07	; 7
    d794:	b8 c0       	rjmp	.+368    	; 0xd906 <FSettingOperator+0x572>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    d796:	84 e0       	ldi	r24, 0x04	; 4
    d798:	61 e0       	ldi	r22, 0x01	; 1
    d79a:	4b ea       	ldi	r20, 0xAB	; 171
    d79c:	5e e0       	ldi	r21, 0x0E	; 14
    d79e:	43 c0       	rjmp	.+134    	; 0xd826 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d7a0:	84 e0       	ldi	r24, 0x04	; 4
    d7a2:	61 e0       	ldi	r22, 0x01	; 1
    d7a4:	46 e9       	ldi	r20, 0x96	; 150
    d7a6:	5e e0       	ldi	r21, 0x0E	; 14
    d7a8:	3e c0       	rjmp	.+124    	; 0xd826 <FSettingOperator+0x492>
		       break;
		  }	      
	      break;
     case soNewPasswordEntry2:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,3,5,strFreeMessageLine3,0,8);           
    d7aa:	84 e0       	ldi	r24, 0x04	; 4
    d7ac:	63 e0       	ldi	r22, 0x03	; 3
    d7ae:	45 e0       	ldi	r20, 0x05	; 5
    d7b0:	2c e1       	ldi	r18, 0x1C	; 28
    d7b2:	38 e0       	ldi	r19, 0x08	; 8
    d7b4:	00 e0       	ldi	r16, 0x00	; 0
    d7b6:	10 e0       	ldi	r17, 0x00	; 0
    d7b8:	f8 e0       	ldi	r31, 0x08	; 8
    d7ba:	ef 2e       	mov	r14, r31
    d7bc:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  switch(uiResult){
    d7c0:	83 30       	cpi	r24, 0x03	; 3
    d7c2:	61 f0       	breq	.+24     	; 0xd7dc <FSettingOperator+0x448>
    d7c4:	84 30       	cpi	r24, 0x04	; 4
    d7c6:	20 f4       	brcc	.+8      	; 0xd7d0 <FSettingOperator+0x43c>
    d7c8:	81 30       	cpi	r24, 0x01	; 1
    d7ca:	09 f0       	breq	.+2      	; 0xd7ce <FSettingOperator+0x43a>
    d7cc:	c3 c0       	rjmp	.+390    	; 0xd954 <FSettingOperator+0x5c0>
    d7ce:	12 c0       	rjmp	.+36     	; 0xd7f4 <FSettingOperator+0x460>
    d7d0:	84 30       	cpi	r24, 0x04	; 4
    d7d2:	01 f1       	breq	.+64     	; 0xd814 <FSettingOperator+0x480>
    d7d4:	85 30       	cpi	r24, 0x05	; 5
    d7d6:	09 f0       	breq	.+2      	; 0xd7da <FSettingOperator+0x446>
    d7d8:	bd c0       	rjmp	.+378    	; 0xd954 <FSettingOperator+0x5c0>
    d7da:	21 c0       	rjmp	.+66     	; 0xd81e <FSettingOperator+0x48a>
		  case USER_OK:
		       lcd_clear();
    d7dc:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
               lcd_printf(2,1,PSTR("Validating.."));
    d7e0:	82 e0       	ldi	r24, 0x02	; 2
    d7e2:	61 e0       	ldi	r22, 0x01	; 1
    d7e4:	49 e8       	ldi	r20, 0x89	; 137
    d7e6:	5e e0       	ldi	r21, 0x0E	; 14
    d7e8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   TimDisplay=0;
    d7ec:	10 92 92 01 	sts	0x0192, r1
		       stSettingOperator=soDispValidatePassword;
    d7f0:	8b e0       	ldi	r24, 0x0B	; 11
    d7f2:	89 c0       	rjmp	.+274    	; 0xd906 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:
               lcd_clear();
    d7f4:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
               lcd_printf(2,1,PSTR("New:_               "));
    d7f8:	82 e0       	ldi	r24, 0x02	; 2
    d7fa:	61 e0       	ldi	r22, 0x01	; 1
    d7fc:	44 e7       	ldi	r20, 0x74	; 116
    d7fe:	5e e0       	ldi	r21, 0x0E	; 14
    d800:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d804:	84 e0       	ldi	r24, 0x04	; 4
    d806:	61 e0       	ldi	r22, 0x01	; 1
    d808:	4f e5       	ldi	r20, 0x5F	; 95
    d80a:	5e e0       	ldi	r21, 0x0E	; 14
    d80c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry1;
    d810:	89 e0       	ldi	r24, 0x09	; 9
    d812:	79 c0       	rjmp	.+242    	; 0xd906 <FSettingOperator+0x572>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    d814:	84 e0       	ldi	r24, 0x04	; 4
    d816:	61 e0       	ldi	r22, 0x01	; 1
    d818:	4a e4       	ldi	r20, 0x4A	; 74
    d81a:	5e e0       	ldi	r21, 0x0E	; 14
    d81c:	04 c0       	rjmp	.+8      	; 0xd826 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    d81e:	84 e0       	ldi	r24, 0x04	; 4
    d820:	61 e0       	ldi	r22, 0x01	; 1
    d822:	45 e3       	ldi	r20, 0x35	; 53
    d824:	5e e0       	ldi	r21, 0x0E	; 14
    d826:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    d82a:	94 c0       	rjmp	.+296    	; 0xd954 <FSettingOperator+0x5c0>
		       break;
		  }	      
	      break;
     case soDispValidatePassword:
	      if (TimDisplay>3)stSettingOperator=soValidatePassword;
    d82c:	80 91 92 01 	lds	r24, 0x0192
    d830:	84 30       	cpi	r24, 0x04	; 4
    d832:	08 f4       	brcc	.+2      	; 0xd836 <FSettingOperator+0x4a2>
    d834:	8f c0       	rjmp	.+286    	; 0xd954 <FSettingOperator+0x5c0>
    d836:	8c e0       	ldi	r24, 0x0C	; 12
    d838:	66 c0       	rjmp	.+204    	; 0xd906 <FSettingOperator+0x572>
	      break;
     case soValidatePassword:
          if (PassType==PT_SUPERVISOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSysPassword, 10);		      			   
    d83a:	80 91 1d 02 	lds	r24, 0x021D
    d83e:	81 30       	cpi	r24, 0x01	; 1
    d840:	29 f4       	brne	.+10     	; 0xd84c <FSettingOperator+0x4b8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d842:	ce 01       	movw	r24, r28
    d844:	01 96       	adiw	r24, 0x01	; 1
    d846:	6b e0       	ldi	r22, 0x0B	; 11
    d848:	70 e0       	ldi	r23, 0x00	; 0
    d84a:	06 c0       	rjmp	.+12     	; 0xd858 <FSettingOperator+0x4c4>
		  else 
		  if (PassType==PT_ADMINISTRATOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSpvPassword, 10);    
    d84c:	82 30       	cpi	r24, 0x02	; 2
    d84e:	51 f4       	brne	.+20     	; 0xd864 <FSettingOperator+0x4d0>
    d850:	ce 01       	movw	r24, r28
    d852:	01 96       	adiw	r24, 0x01	; 1
    d854:	61 e0       	ldi	r22, 0x01	; 1
    d856:	70 e0       	ldi	r23, 0x00	; 0
    d858:	4a e0       	ldi	r20, 0x0A	; 10
    d85a:	50 e0       	ldi	r21, 0x00	; 0
    d85c:	24 e4       	ldi	r18, 0x44	; 68
    d85e:	32 e1       	ldi	r19, 0x12	; 18
    d860:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		  
		  //Check Old Validity
		  if (strcmp(strPassword,strFreeMessageLine1)==0){//OldMessage Valid
    d864:	ce 01       	movw	r24, r28
    d866:	01 96       	adiw	r24, 0x01	; 1
    d868:	62 e9       	ldi	r22, 0x92	; 146
    d86a:	78 e0       	ldi	r23, 0x08	; 8
    d86c:	0e 94 e3 a9 	call	0x153c6	; 0x153c6 <strcmp>
    d870:	00 97       	sbiw	r24, 0x00	; 0
    d872:	09 f0       	breq	.+2      	; 0xd876 <FSettingOperator+0x4e2>
    d874:	4b c0       	rjmp	.+150    	; 0xd90c <FSettingOperator+0x578>
              if (strcmp(strFreeMessageLine2,strFreeMessageLine3)==0){
    d876:	83 ea       	ldi	r24, 0xA3	; 163
    d878:	97 e0       	ldi	r25, 0x07	; 7
    d87a:	6c e1       	ldi	r22, 0x1C	; 28
    d87c:	78 e0       	ldi	r23, 0x08	; 8
    d87e:	0e 94 e3 a9 	call	0x153c6	; 0x153c6 <strcmp>
    d882:	00 97       	sbiw	r24, 0x00	; 0
    d884:	51 f5       	brne	.+84     	; 0xd8da <FSettingOperator+0x546>
                  
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
    d886:	80 91 1d 02 	lds	r24, 0x021D
    d88a:	81 30       	cpi	r24, 0x01	; 1
    d88c:	19 f4       	brne	.+6      	; 0xd894 <FSettingOperator+0x500>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    d88e:	8b e0       	ldi	r24, 0x0B	; 11
    d890:	90 e0       	ldi	r25, 0x00	; 0
    d892:	04 c0       	rjmp	.+8      	; 0xd89c <FSettingOperator+0x508>
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    
    d894:	82 30       	cpi	r24, 0x02	; 2
    d896:	51 f4       	brne	.+20     	; 0xd8ac <FSettingOperator+0x518>
    d898:	81 e0       	ldi	r24, 0x01	; 1
    d89a:	90 e0       	ldi	r25, 0x00	; 0
    d89c:	63 ea       	ldi	r22, 0xA3	; 163
    d89e:	77 e0       	ldi	r23, 0x07	; 7
    d8a0:	4a e0       	ldi	r20, 0x0A	; 10
    d8a2:	50 e0       	ldi	r21, 0x00	; 0
    d8a4:	2c e4       	ldi	r18, 0x4C	; 76
    d8a6:	32 e1       	ldi	r19, 0x12	; 18
    d8a8:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d8ac:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d8ae:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d8b0:	81 e0       	ldi	r24, 0x01	; 1
    d8b2:	80 93 bc 01 	sts	0x01BC, r24
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    

			      system_beep(1);
				  lcd_clear();
    d8b6:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
			      lcd_printf(2,1,PSTR("     Completed      "));
    d8ba:	82 e0       	ldi	r24, 0x02	; 2
    d8bc:	61 e0       	ldi	r22, 0x01	; 1
    d8be:	40 e2       	ldi	r20, 0x20	; 32
    d8c0:	5e e0       	ldi	r21, 0x0E	; 14
    d8c2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
    d8c6:	83 e0       	ldi	r24, 0x03	; 3
    d8c8:	61 e0       	ldi	r22, 0x01	; 1
    d8ca:	4b e0       	ldi	r20, 0x0B	; 11
    d8cc:	5e e0       	ldi	r21, 0x0E	; 14
    d8ce:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				  TimDisplay=0;
    d8d2:	10 92 92 01 	sts	0x0192, r1
				  stSettingOperator=soDelayDisplaySaved;
    d8d6:	8e e0       	ldi	r24, 0x0E	; 14
    d8d8:	16 c0       	rjmp	.+44     	; 0xd906 <FSettingOperator+0x572>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d8da:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d8dc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d8de:	82 e0       	ldi	r24, 0x02	; 2
    d8e0:	80 93 bc 01 	sts	0x01BC, r24
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
				  TimDisplay=0;
				  stSettingOperator=soDelayDisplaySaved;
			  }else {
			  system_beep(2);
		      TimDisplay=0;
    d8e4:	10 92 92 01 	sts	0x0192, r1
		      lcd_clear();
    d8e8:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		      lcd_printf(2,1,PSTR("      ERROR         "));
    d8ec:	82 e0       	ldi	r24, 0x02	; 2
    d8ee:	61 e0       	ldi	r22, 0x01	; 1
    d8f0:	46 ef       	ldi	r20, 0xF6	; 246
    d8f2:	5d e0       	ldi	r21, 0x0D	; 13
    d8f4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      lcd_printf(3,1,PSTR("Invalid New Password"));
    d8f8:	83 e0       	ldi	r24, 0x03	; 3
    d8fa:	61 e0       	ldi	r22, 0x01	; 1
    d8fc:	41 ee       	ldi	r20, 0xE1	; 225
    d8fe:	5d e0       	ldi	r21, 0x0D	; 13
    d900:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      stSettingOperator=soDisplayInvalidPassword;
    d904:	8d e0       	ldi	r24, 0x0D	; 13
    d906:	80 93 1e 02 	sts	0x021E, r24
    d90a:	24 c0       	rjmp	.+72     	; 0xd954 <FSettingOperator+0x5c0>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    d90c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    d90e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    d910:	82 e0       	ldi	r24, 0x02	; 2
    d912:	80 93 bc 01 	sts	0x01BC, r24
		      stSettingOperator=soDisplayInvalidPassword;
			  }
		  }else {
		   //InvalidOld Password
		   system_beep(2);
		   TimDisplay=0;
    d916:	10 92 92 01 	sts	0x0192, r1
		   lcd_clear();
    d91a:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		   lcd_printf(2,1,PSTR("      ERROR         "));
    d91e:	82 e0       	ldi	r24, 0x02	; 2
    d920:	61 e0       	ldi	r22, 0x01	; 1
    d922:	4c ec       	ldi	r20, 0xCC	; 204
    d924:	5d e0       	ldi	r21, 0x0D	; 13
    d926:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		   lcd_printf(3,1,PSTR("Invalid Old Password"));
    d92a:	83 e0       	ldi	r24, 0x03	; 3
    d92c:	61 e0       	ldi	r22, 0x01	; 1
    d92e:	47 eb       	ldi	r20, 0xB7	; 183
    d930:	5d e0       	ldi	r21, 0x0D	; 13
    d932:	e6 cf       	rjmp	.-52     	; 0xd900 <FSettingOperator+0x56c>
		   stSettingOperator=soDisplayInvalidPassword;
		   }
	      break;
     case soDisplayInvalidPassword:
	      if (TimDisplay>6)stSettingOperator=soMenuOption;
    d934:	80 91 92 01 	lds	r24, 0x0192
    d938:	87 30       	cpi	r24, 0x07	; 7
    d93a:	60 f0       	brcs	.+24     	; 0xd954 <FSettingOperator+0x5c0>
    d93c:	04 c0       	rjmp	.+8      	; 0xd946 <FSettingOperator+0x5b2>
	      break;
     case soDelayDisplaySaved:
	      if (TimDisplay>4)stSettingOperator=soMenuOption;
    d93e:	80 91 92 01 	lds	r24, 0x0192
    d942:	85 30       	cpi	r24, 0x05	; 5
    d944:	38 f0       	brcs	.+14     	; 0xd954 <FSettingOperator+0x5c0>
    d946:	10 92 1e 02 	sts	0x021E, r1
    d94a:	04 c0       	rjmp	.+8      	; 0xd954 <FSettingOperator+0x5c0>
	      break;
	 case soExitSettingOperator:
	      stSettingOperator=soMenuOption;
    d94c:	10 92 1e 02 	sts	0x021E, r1
    d950:	81 e0       	ldi	r24, 0x01	; 1
    d952:	01 c0       	rjmp	.+2      	; 0xd956 <FSettingOperator+0x5c2>
    d954:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
    d956:	e5 96       	adiw	r28, 0x35	; 53
    d958:	0f b6       	in	r0, 0x3f	; 63
    d95a:	f8 94       	cli
    d95c:	de bf       	out	0x3e, r29	; 62
    d95e:	0f be       	out	0x3f, r0	; 63
    d960:	cd bf       	out	0x3d, r28	; 61
    d962:	cf 91       	pop	r28
    d964:	df 91       	pop	r29
    d966:	1f 91       	pop	r17
    d968:	0f 91       	pop	r16
    d96a:	ef 90       	pop	r14
    d96c:	08 95       	ret

0000d96e <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
    d96e:	6f 92       	push	r6
    d970:	7f 92       	push	r7
    d972:	8f 92       	push	r8
    d974:	9f 92       	push	r9
    d976:	af 92       	push	r10
    d978:	bf 92       	push	r11
    d97a:	cf 92       	push	r12
    d97c:	df 92       	push	r13
    d97e:	ef 92       	push	r14
    d980:	ff 92       	push	r15
    d982:	0f 93       	push	r16
    d984:	1f 93       	push	r17
    d986:	df 93       	push	r29
    d988:	cf 93       	push	r28
    d98a:	cd b7       	in	r28, 0x3d	; 61
    d98c:	de b7       	in	r29, 0x3e	; 62
    d98e:	a1 97       	sbiw	r28, 0x21	; 33
    d990:	0f b6       	in	r0, 0x3f	; 63
    d992:	f8 94       	cli
    d994:	de bf       	out	0x3e, r29	; 62
    d996:	0f be       	out	0x3f, r0	; 63
    d998:	cd bf       	out	0x3d, r28	; 61
     char i;//,x,y;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
    d99a:	80 91 21 02 	lds	r24, 0x0221
    d99e:	83 30       	cpi	r24, 0x03	; 3
    d9a0:	09 f4       	brne	.+2      	; 0xd9a4 <FSettingProduct+0x36>
    d9a2:	ff c0       	rjmp	.+510    	; 0xdba2 <FSettingProduct+0x234>
    d9a4:	84 30       	cpi	r24, 0x04	; 4
    d9a6:	38 f4       	brcc	.+14     	; 0xd9b6 <FSettingProduct+0x48>
    d9a8:	81 30       	cpi	r24, 0x01	; 1
    d9aa:	09 f4       	brne	.+2      	; 0xd9ae <FSettingProduct+0x40>
    d9ac:	72 c0       	rjmp	.+228    	; 0xda92 <FSettingProduct+0x124>
    d9ae:	82 30       	cpi	r24, 0x02	; 2
    d9b0:	08 f0       	brcs	.+2      	; 0xd9b4 <FSettingProduct+0x46>
    d9b2:	82 c0       	rjmp	.+260    	; 0xdab8 <FSettingProduct+0x14a>
    d9b4:	0a c0       	rjmp	.+20     	; 0xd9ca <FSettingProduct+0x5c>
    d9b6:	85 30       	cpi	r24, 0x05	; 5
    d9b8:	09 f4       	brne	.+2      	; 0xd9bc <FSettingProduct+0x4e>
    d9ba:	81 c1       	rjmp	.+770    	; 0xdcbe <FSettingProduct+0x350>
    d9bc:	85 30       	cpi	r24, 0x05	; 5
    d9be:	08 f4       	brcc	.+2      	; 0xd9c2 <FSettingProduct+0x54>
    d9c0:	9e c1       	rjmp	.+828    	; 0xdcfe <FSettingProduct+0x390>
    d9c2:	86 30       	cpi	r24, 0x06	; 6
    d9c4:	09 f0       	breq	.+2      	; 0xd9c8 <FSettingProduct+0x5a>
    d9c6:	c3 c1       	rjmp	.+902    	; 0xdd4e <FSettingProduct+0x3e0>
    d9c8:	be c1       	rjmp	.+892    	; 0xdd46 <FSettingProduct+0x3d8>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
    d9ca:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    d9ce:	9b eb       	ldi	r25, 0xBB	; 187
    d9d0:	c9 2e       	mov	r12, r25
    d9d2:	90 e0       	ldi	r25, 0x00	; 0
    d9d4:	d9 2e       	mov	r13, r25
    d9d6:	81 e0       	ldi	r24, 0x01	; 1
    d9d8:	e8 2e       	mov	r14, r24
    d9da:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d9dc:	4e 01       	movw	r8, r28
    d9de:	08 94       	sec
    d9e0:	81 1c       	adc	r8, r1
    d9e2:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
    d9e4:	0e e0       	ldi	r16, 0x0E	; 14
    d9e6:	a0 2e       	mov	r10, r16
    d9e8:	b1 2c       	mov	r11, r1
    d9ea:	ac 0e       	add	r10, r28
    d9ec:	bd 1e       	adc	r11, r29
    d9ee:	11 e9       	ldi	r17, 0x91	; 145
    d9f0:	61 2e       	mov	r6, r17
    d9f2:	11 e1       	ldi	r17, 0x11	; 17
    d9f4:	71 2e       	mov	r7, r17
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
    d9f6:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
    d9f8:	1e 2d       	mov	r17, r14
    d9fa:	11 50       	subi	r17, 0x01	; 1
    d9fc:	c4 01       	movw	r24, r8
    d9fe:	b6 01       	movw	r22, r12
    da00:	4d e0       	ldi	r20, 0x0D	; 13
    da02:	50 e0       	ldi	r21, 0x00	; 0
    da04:	24 e4       	ldi	r18, 0x44	; 68
    da06:	32 e1       	ldi	r19, 0x12	; 18
    da08:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
    da0c:	8d b7       	in	r24, 0x3d	; 61
    da0e:	9e b7       	in	r25, 0x3e	; 62
    da10:	08 97       	sbiw	r24, 0x08	; 8
    da12:	0f b6       	in	r0, 0x3f	; 63
    da14:	f8 94       	cli
    da16:	9e bf       	out	0x3e, r25	; 62
    da18:	0f be       	out	0x3f, r0	; 63
    da1a:	8d bf       	out	0x3d, r24	; 61
    da1c:	ed b7       	in	r30, 0x3d	; 61
    da1e:	fe b7       	in	r31, 0x3e	; 62
    da20:	31 96       	adiw	r30, 0x01	; 1
    da22:	ad b7       	in	r26, 0x3d	; 61
    da24:	be b7       	in	r27, 0x3e	; 62
    da26:	12 96       	adiw	r26, 0x02	; 2
    da28:	bc 92       	st	X, r11
    da2a:	ae 92       	st	-X, r10
    da2c:	11 97       	sbiw	r26, 0x01	; 1
    da2e:	73 82       	std	Z+3, r7	; 0x03
    da30:	62 82       	std	Z+2, r6	; 0x02
    da32:	f5 82       	std	Z+5, r15	; 0x05
    da34:	e4 82       	std	Z+4, r14	; 0x04
    da36:	97 82       	std	Z+7, r9	; 0x07
    da38:	86 82       	std	Z+6, r8	; 0x06
    da3a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
    da3e:	8d b7       	in	r24, 0x3d	; 61
    da40:	9e b7       	in	r25, 0x3e	; 62
    da42:	08 96       	adiw	r24, 0x08	; 8
    da44:	0f b6       	in	r0, 0x3f	; 63
    da46:	f8 94       	cli
    da48:	9e bf       	out	0x3e, r25	; 62
    da4a:	0f be       	out	0x3f, r0	; 63
    da4c:	8d bf       	out	0x3d, r24	; 61
    da4e:	61 2f       	mov	r22, r17
    da50:	66 95       	lsr	r22
    da52:	66 95       	lsr	r22
    da54:	60 9f       	mul	r22, r16
    da56:	b0 01       	movw	r22, r0
    da58:	11 24       	eor	r1, r1
    da5a:	6f 5f       	subi	r22, 0xFF	; 255
    da5c:	13 70       	andi	r17, 0x03	; 3
    da5e:	81 2f       	mov	r24, r17
    da60:	8f 5f       	subi	r24, 0xFF	; 255
    da62:	a5 01       	movw	r20, r10
    da64:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    da68:	ad e0       	ldi	r26, 0x0D	; 13
    da6a:	b0 e0       	ldi	r27, 0x00	; 0
    da6c:	ca 0e       	add	r12, r26
    da6e:	db 1e       	adc	r13, r27
    da70:	08 94       	sec
    da72:	e1 1c       	adc	r14, r1
    da74:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
    da76:	b9 e0       	ldi	r27, 0x09	; 9
    da78:	cb 16       	cp	r12, r27
    da7a:	b1 e0       	ldi	r27, 0x01	; 1
    da7c:	db 06       	cpc	r13, r27
    da7e:	09 f0       	breq	.+2      	; 0xda82 <FSettingProduct+0x114>
    da80:	bb cf       	rjmp	.-138    	; 0xd9f8 <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
    da82:	84 e0       	ldi	r24, 0x04	; 4
    da84:	6b e0       	ldi	r22, 0x0B	; 11
    da86:	4a e8       	ldi	r20, 0x8A	; 138
    da88:	51 e1       	ldi	r21, 0x11	; 17
    da8a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          stMenuProduct=mpChangeProduct;
    da8e:	81 e0       	ldi	r24, 0x01	; 1
    da90:	54 c1       	rjmp	.+680    	; 0xdd3a <FSettingProduct+0x3cc>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
    da92:	81 e0       	ldi	r24, 0x01	; 1
    da94:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    da98:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
    da9a:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    da9e:	81 53       	subi	r24, 0x31	; 49
    daa0:	86 30       	cpi	r24, 0x06	; 6
    daa2:	28 f4       	brcc	.+10     	; 0xdaae <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
    daa4:	80 93 20 02 	sts	0x0220, r24
			  stMenuProduct=mpDispPrice;
    daa8:	82 e0       	ldi	r24, 0x02	; 2
    daaa:	80 93 21 02 	sts	0x0221, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
    daae:	17 3e       	cpi	r17, 0xE7	; 231
    dab0:	09 f0       	breq	.+2      	; 0xdab4 <FSettingProduct+0x146>
    dab2:	4d c1       	rjmp	.+666    	; 0xdd4e <FSettingProduct+0x3e0>
		      stMenuProduct=mpExitMenuProduct;
    dab4:	86 e0       	ldi	r24, 0x06	; 6
    dab6:	41 c1       	rjmp	.+642    	; 0xdd3a <FSettingProduct+0x3cc>
    dab8:	60 91 20 02 	lds	r22, 0x0220
    dabc:	8d e0       	ldi	r24, 0x0D	; 13
    dabe:	68 9f       	mul	r22, r24
    dac0:	b0 01       	movw	r22, r0
    dac2:	11 24       	eor	r1, r1
    dac4:	65 54       	subi	r22, 0x45	; 69
    dac6:	7f 4f       	sbci	r23, 0xFF	; 255
    dac8:	7e 01       	movw	r14, r28
    daca:	08 94       	sec
    dacc:	e1 1c       	adc	r14, r1
    dace:	f1 1c       	adc	r15, r1
    dad0:	c7 01       	movw	r24, r14
    dad2:	4d e0       	ldi	r20, 0x0D	; 13
    dad4:	50 e0       	ldi	r21, 0x00	; 0
    dad6:	24 e4       	ldi	r18, 0x44	; 68
    dad8:	32 e1       	ldi	r19, 0x12	; 18
    dada:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
    dade:	be e9       	ldi	r27, 0x9E	; 158
    dae0:	cb 2e       	mov	r12, r27
    dae2:	b5 e0       	ldi	r27, 0x05	; 5
    dae4:	db 2e       	mov	r13, r27
    dae6:	60 91 20 02 	lds	r22, 0x0220
    daea:	89 e0       	ldi	r24, 0x09	; 9
    daec:	68 9f       	mul	r22, r24
    daee:	b0 01       	movw	r22, r0
    daf0:	11 24       	eor	r1, r1
    daf2:	6b 57       	subi	r22, 0x7B	; 123
    daf4:	7f 4f       	sbci	r23, 0xFF	; 255
    daf6:	c6 01       	movw	r24, r12
    daf8:	49 e0       	ldi	r20, 0x09	; 9
    dafa:	50 e0       	ldi	r21, 0x00	; 0
    dafc:	24 e4       	ldi	r18, 0x44	; 68
    dafe:	32 e1       	ldi	r19, 0x12	; 18
    db00:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    db04:	00 d0       	rcall	.+0      	; 0xdb06 <FSettingProduct+0x198>
    db06:	00 d0       	rcall	.+0      	; 0xdb08 <FSettingProduct+0x19a>
    db08:	00 d0       	rcall	.+0      	; 0xdb0a <FSettingProduct+0x19c>
    db0a:	ed b7       	in	r30, 0x3d	; 61
    db0c:	fe b7       	in	r31, 0x3e	; 62
    db0e:	31 96       	adiw	r30, 0x01	; 1
    db10:	8e 01       	movw	r16, r28
    db12:	02 5f       	subi	r16, 0xF2	; 242
    db14:	1f 4f       	sbci	r17, 0xFF	; 255
    db16:	ad b7       	in	r26, 0x3d	; 61
    db18:	be b7       	in	r27, 0x3e	; 62
    db1a:	12 96       	adiw	r26, 0x02	; 2
    db1c:	1c 93       	st	X, r17
    db1e:	0e 93       	st	-X, r16
    db20:	11 97       	sbiw	r26, 0x01	; 1
    db22:	85 e8       	ldi	r24, 0x85	; 133
    db24:	91 e1       	ldi	r25, 0x11	; 17
    db26:	93 83       	std	Z+3, r25	; 0x03
    db28:	82 83       	std	Z+2, r24	; 0x02
    db2a:	f5 82       	std	Z+5, r15	; 0x05
    db2c:	e4 82       	std	Z+4, r14	; 0x04
    db2e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
    db32:	8d b7       	in	r24, 0x3d	; 61
    db34:	9e b7       	in	r25, 0x3e	; 62
    db36:	06 96       	adiw	r24, 0x06	; 6
    db38:	0f b6       	in	r0, 0x3f	; 63
    db3a:	f8 94       	cli
    db3c:	9e bf       	out	0x3e, r25	; 62
    db3e:	0f be       	out	0x3f, r0	; 63
    db40:	8d bf       	out	0x3d, r24	; 61
    db42:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    db46:	81 e0       	ldi	r24, 0x01	; 1
    db48:	61 e0       	ldi	r22, 0x01	; 1
    db4a:	a8 01       	movw	r20, r16
    db4c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
    db50:	00 d0       	rcall	.+0      	; 0xdb52 <FSettingProduct+0x1e4>
    db52:	00 d0       	rcall	.+0      	; 0xdb54 <FSettingProduct+0x1e6>
    db54:	00 d0       	rcall	.+0      	; 0xdb56 <FSettingProduct+0x1e8>
    db56:	ed b7       	in	r30, 0x3d	; 61
    db58:	fe b7       	in	r31, 0x3e	; 62
    db5a:	31 96       	adiw	r30, 0x01	; 1
    db5c:	ad b7       	in	r26, 0x3d	; 61
    db5e:	be b7       	in	r27, 0x3e	; 62
    db60:	12 96       	adiw	r26, 0x02	; 2
    db62:	1c 93       	st	X, r17
    db64:	0e 93       	st	-X, r16
    db66:	11 97       	sbiw	r26, 0x01	; 1
    db68:	80 e8       	ldi	r24, 0x80	; 128
    db6a:	91 e1       	ldi	r25, 0x11	; 17
    db6c:	93 83       	std	Z+3, r25	; 0x03
    db6e:	82 83       	std	Z+2, r24	; 0x02
    db70:	d5 82       	std	Z+5, r13	; 0x05
    db72:	c4 82       	std	Z+4, r12	; 0x04
    db74:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    db78:	8d b7       	in	r24, 0x3d	; 61
    db7a:	9e b7       	in	r25, 0x3e	; 62
    db7c:	06 96       	adiw	r24, 0x06	; 6
    db7e:	0f b6       	in	r0, 0x3f	; 63
    db80:	f8 94       	cli
    db82:	9e bf       	out	0x3e, r25	; 62
    db84:	0f be       	out	0x3f, r0	; 63
    db86:	8d bf       	out	0x3d, r24	; 61
    db88:	82 e0       	ldi	r24, 0x02	; 2
    db8a:	61 e0       	ldi	r22, 0x01	; 1
    db8c:	a8 01       	movw	r20, r16
    db8e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
    db92:	84 e0       	ldi	r24, 0x04	; 4
    db94:	61 e0       	ldi	r22, 0x01	; 1
    db96:	42 e7       	ldi	r20, 0x72	; 114
    db98:	51 e1       	ldi	r21, 0x11	; 17
    db9a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stMenuProduct=mpIsEdit;
    db9e:	83 e0       	ldi	r24, 0x03	; 3
    dba0:	cc c0       	rjmp	.+408    	; 0xdd3a <FSettingProduct+0x3cc>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
    dba2:	81 e0       	ldi	r24, 0x01	; 1
    dba4:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    dba8:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  if (KeyChar=='*'){
    dbac:	8a 32       	cpi	r24, 0x2A	; 42
    dbae:	09 f4       	brne	.+2      	; 0xdbb2 <FSettingProduct+0x244>
    dbb0:	a3 c0       	rjmp	.+326    	; 0xdcf8 <FSettingProduct+0x38a>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
    dbb2:	81 33       	cpi	r24, 0x31	; 49
    dbb4:	09 f0       	breq	.+2      	; 0xdbb8 <FSettingProduct+0x24a>
    dbb6:	4c c0       	rjmp	.+152    	; 0xdc50 <FSettingProduct+0x2e2>
    dbb8:	60 91 20 02 	lds	r22, 0x0220
    dbbc:	8d e0       	ldi	r24, 0x0D	; 13
    dbbe:	68 9f       	mul	r22, r24
    dbc0:	b0 01       	movw	r22, r0
    dbc2:	11 24       	eor	r1, r1
    dbc4:	65 54       	subi	r22, 0x45	; 69
    dbc6:	7f 4f       	sbci	r23, 0xFF	; 255
    dbc8:	8e 01       	movw	r16, r28
    dbca:	0f 5f       	subi	r16, 0xFF	; 255
    dbcc:	1f 4f       	sbci	r17, 0xFF	; 255
    dbce:	c8 01       	movw	r24, r16
    dbd0:	4d e0       	ldi	r20, 0x0D	; 13
    dbd2:	50 e0       	ldi	r21, 0x00	; 0
    dbd4:	24 e4       	ldi	r18, 0x44	; 68
    dbd6:	32 e1       	ldi	r19, 0x12	; 18
    dbd8:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
    dbdc:	00 d0       	rcall	.+0      	; 0xdbde <FSettingProduct+0x270>
    dbde:	00 d0       	rcall	.+0      	; 0xdbe0 <FSettingProduct+0x272>
    dbe0:	00 d0       	rcall	.+0      	; 0xdbe2 <FSettingProduct+0x274>
    dbe2:	ed b7       	in	r30, 0x3d	; 61
    dbe4:	fe b7       	in	r31, 0x3e	; 62
    dbe6:	31 96       	adiw	r30, 0x01	; 1
    dbe8:	ae e0       	ldi	r26, 0x0E	; 14
    dbea:	ea 2e       	mov	r14, r26
    dbec:	f1 2c       	mov	r15, r1
    dbee:	ec 0e       	add	r14, r28
    dbf0:	fd 1e       	adc	r15, r29
    dbf2:	ad b7       	in	r26, 0x3d	; 61
    dbf4:	be b7       	in	r27, 0x3e	; 62
    dbf6:	12 96       	adiw	r26, 0x02	; 2
    dbf8:	fc 92       	st	X, r15
    dbfa:	ee 92       	st	-X, r14
    dbfc:	11 97       	sbiw	r26, 0x01	; 1
    dbfe:	8b e6       	ldi	r24, 0x6B	; 107
    dc00:	91 e1       	ldi	r25, 0x11	; 17
    dc02:	93 83       	std	Z+3, r25	; 0x03
    dc04:	82 83       	std	Z+2, r24	; 0x02
    dc06:	15 83       	std	Z+5, r17	; 0x05
    dc08:	04 83       	std	Z+4, r16	; 0x04
    dc0a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
    dc0e:	8d b7       	in	r24, 0x3d	; 61
    dc10:	9e b7       	in	r25, 0x3e	; 62
    dc12:	06 96       	adiw	r24, 0x06	; 6
    dc14:	0f b6       	in	r0, 0x3f	; 63
    dc16:	f8 94       	cli
    dc18:	9e bf       	out	0x3e, r25	; 62
    dc1a:	0f be       	out	0x3f, r0	; 63
    dc1c:	8d bf       	out	0x3d, r24	; 61
    dc1e:	81 e0       	ldi	r24, 0x01	; 1
    dc20:	61 e0       	ldi	r22, 0x01	; 1
    dc22:	46 e5       	ldi	r20, 0x56	; 86
    dc24:	51 e1       	ldi	r21, 0x11	; 17
    dc26:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		       lcd_print(2,1,lcdteks);
    dc2a:	82 e0       	ldi	r24, 0x02	; 2
    dc2c:	61 e0       	ldi	r22, 0x01	; 1
    dc2e:	a7 01       	movw	r20, r14
    dc30:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
    dc34:	83 e0       	ldi	r24, 0x03	; 3
    dc36:	61 e0       	ldi	r22, 0x01	; 1
    dc38:	40 e5       	ldi	r20, 0x50	; 80
    dc3a:	51 e1       	ldi	r21, 0x11	; 17
    dc3c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
    dc40:	84 e0       	ldi	r24, 0x04	; 4
    dc42:	61 e0       	ldi	r22, 0x01	; 1
    dc44:	4b e3       	ldi	r20, 0x3B	; 59
    dc46:	51 e1       	ldi	r21, 0x11	; 17
    dc48:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      stMenuProduct=mpEditProductName;
    dc4c:	85 e0       	ldi	r24, 0x05	; 5
    dc4e:	75 c0       	rjmp	.+234    	; 0xdd3a <FSettingProduct+0x3cc>
		  }else
		  if (KeyChar=='2'){
    dc50:	82 33       	cpi	r24, 0x32	; 50
    dc52:	09 f0       	breq	.+2      	; 0xdc56 <FSettingProduct+0x2e8>
    dc54:	7c c0       	rjmp	.+248    	; 0xdd4e <FSettingProduct+0x3e0>
		      uiResult=USER_NONE;
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
    dc56:	00 d0       	rcall	.+0      	; 0xdc58 <FSettingProduct+0x2ea>
    dc58:	00 d0       	rcall	.+0      	; 0xdc5a <FSettingProduct+0x2ec>
    dc5a:	00 d0       	rcall	.+0      	; 0xdc5c <FSettingProduct+0x2ee>
    dc5c:	ed b7       	in	r30, 0x3d	; 61
    dc5e:	fe b7       	in	r31, 0x3e	; 62
    dc60:	31 96       	adiw	r30, 0x01	; 1
    dc62:	8e 01       	movw	r16, r28
    dc64:	02 5f       	subi	r16, 0xF2	; 242
    dc66:	1f 4f       	sbci	r17, 0xFF	; 255
    dc68:	ad b7       	in	r26, 0x3d	; 61
    dc6a:	be b7       	in	r27, 0x3e	; 62
    dc6c:	12 96       	adiw	r26, 0x02	; 2
    dc6e:	1c 93       	st	X, r17
    dc70:	0e 93       	st	-X, r16
    dc72:	11 97       	sbiw	r26, 0x01	; 1
    dc74:	84 e3       	ldi	r24, 0x34	; 52
    dc76:	91 e1       	ldi	r25, 0x11	; 17
    dc78:	93 83       	std	Z+3, r25	; 0x03
    dc7a:	82 83       	std	Z+2, r24	; 0x02
    dc7c:	8e e9       	ldi	r24, 0x9E	; 158
    dc7e:	95 e0       	ldi	r25, 0x05	; 5
    dc80:	95 83       	std	Z+5, r25	; 0x05
    dc82:	84 83       	std	Z+4, r24	; 0x04
    dc84:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		       lcd_print(2,1,lcdteks);
    dc88:	8d b7       	in	r24, 0x3d	; 61
    dc8a:	9e b7       	in	r25, 0x3e	; 62
    dc8c:	06 96       	adiw	r24, 0x06	; 6
    dc8e:	0f b6       	in	r0, 0x3f	; 63
    dc90:	f8 94       	cli
    dc92:	9e bf       	out	0x3e, r25	; 62
    dc94:	0f be       	out	0x3f, r0	; 63
    dc96:	8d bf       	out	0x3d, r24	; 61
    dc98:	82 e0       	ldi	r24, 0x02	; 2
    dc9a:	61 e0       	ldi	r22, 0x01	; 1
    dc9c:	a8 01       	movw	r20, r16
    dc9e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
    dca2:	83 e0       	ldi	r24, 0x03	; 3
    dca4:	61 e0       	ldi	r22, 0x01	; 1
    dca6:	4e e2       	ldi	r20, 0x2E	; 46
    dca8:	51 e1       	ldi	r21, 0x11	; 17
    dcaa:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
    dcae:	84 e0       	ldi	r24, 0x04	; 4
    dcb0:	61 e0       	ldi	r22, 0x01	; 1
    dcb2:	49 e1       	ldi	r20, 0x19	; 25
    dcb4:	51 e1       	ldi	r21, 0x11	; 17
    dcb6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      stMenuProduct=mpEditPrice;
    dcba:	84 e0       	ldi	r24, 0x04	; 4
    dcbc:	3e c0       	rjmp	.+124    	; 0xdd3a <FSettingProduct+0x3cc>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
    dcbe:	83 e0       	ldi	r24, 0x03	; 3
    dcc0:	63 e0       	ldi	r22, 0x03	; 3
    dcc2:	45 e0       	ldi	r20, 0x05	; 5
    dcc4:	2c e0       	ldi	r18, 0x0C	; 12
    dcc6:	38 e0       	ldi	r19, 0x08	; 8
    dcc8:	00 e0       	ldi	r16, 0x00	; 0
    dcca:	10 e0       	ldi	r17, 0x00	; 0
    dccc:	7a e0       	ldi	r23, 0x0A	; 10
    dcce:	e7 2e       	mov	r14, r23
    dcd0:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  if (uiResult==USER_OK){
    dcd4:	83 30       	cpi	r24, 0x03	; 3
    dcd6:	a1 f5       	brne	.+104    	; 0xdd40 <FSettingProduct+0x3d2>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    dcd8:	80 91 20 02 	lds	r24, 0x0220
    dcdc:	2d e0       	ldi	r18, 0x0D	; 13
    dcde:	82 9f       	mul	r24, r18
    dce0:	c0 01       	movw	r24, r0
    dce2:	11 24       	eor	r1, r1
    dce4:	85 54       	subi	r24, 0x45	; 69
    dce6:	9f 4f       	sbci	r25, 0xFF	; 255
    dce8:	6c e0       	ldi	r22, 0x0C	; 12
    dcea:	78 e0       	ldi	r23, 0x08	; 8
    dcec:	4d e0       	ldi	r20, 0x0D	; 13
    dcee:	50 e0       	ldi	r21, 0x00	; 0
    dcf0:	2c e4       	ldi	r18, 0x4C	; 76
    dcf2:	32 e1       	ldi	r19, 0x12	; 18
    dcf4:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
    dcf8:	10 92 21 02 	sts	0x0221, r1
    dcfc:	28 c0       	rjmp	.+80     	; 0xdd4e <FSettingProduct+0x3e0>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
    dcfe:	81 e0       	ldi	r24, 0x01	; 1
    dd00:	63 e0       	ldi	r22, 0x03	; 3
    dd02:	45 e0       	ldi	r20, 0x05	; 5
    dd04:	2e e9       	ldi	r18, 0x9E	; 158
    dd06:	35 e0       	ldi	r19, 0x05	; 5
    dd08:	00 e0       	ldi	r16, 0x00	; 0
    dd0a:	10 e0       	ldi	r17, 0x00	; 0
    dd0c:	57 e0       	ldi	r21, 0x07	; 7
    dd0e:	e5 2e       	mov	r14, r21
    dd10:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  if (uiResult==USER_OK){
    dd14:	83 30       	cpi	r24, 0x03	; 3
    dd16:	a1 f4       	brne	.+40     	; 0xdd40 <FSettingProduct+0x3d2>
    dd18:	80 91 20 02 	lds	r24, 0x0220
    dd1c:	29 e0       	ldi	r18, 0x09	; 9
    dd1e:	82 9f       	mul	r24, r18
    dd20:	c0 01       	movw	r24, r0
    dd22:	11 24       	eor	r1, r1
    dd24:	8b 57       	subi	r24, 0x7B	; 123
    dd26:	9f 4f       	sbci	r25, 0xFF	; 255
    dd28:	6e e9       	ldi	r22, 0x9E	; 158
    dd2a:	75 e0       	ldi	r23, 0x05	; 5
    dd2c:	49 e0       	ldi	r20, 0x09	; 9
    dd2e:	50 e0       	ldi	r21, 0x00	; 0
    dd30:	2c e4       	ldi	r18, 0x4C	; 76
    dd32:	32 e1       	ldi	r19, 0x12	; 18
    dd34:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
    dd38:	82 e0       	ldi	r24, 0x02	; 2
    dd3a:	80 93 21 02 	sts	0x0221, r24
    dd3e:	07 c0       	rjmp	.+14     	; 0xdd4e <FSettingProduct+0x3e0>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
    dd40:	81 30       	cpi	r24, 0x01	; 1
    dd42:	29 f4       	brne	.+10     	; 0xdd4e <FSettingProduct+0x3e0>
    dd44:	f9 cf       	rjmp	.-14     	; 0xdd38 <FSettingProduct+0x3ca>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
    dd46:	10 92 21 02 	sts	0x0221, r1
    dd4a:	81 e0       	ldi	r24, 0x01	; 1
    dd4c:	01 c0       	rjmp	.+2      	; 0xdd50 <FSettingProduct+0x3e2>
    dd4e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    dd50:	a1 96       	adiw	r28, 0x21	; 33
    dd52:	0f b6       	in	r0, 0x3f	; 63
    dd54:	f8 94       	cli
    dd56:	de bf       	out	0x3e, r29	; 62
    dd58:	0f be       	out	0x3f, r0	; 63
    dd5a:	cd bf       	out	0x3d, r28	; 61
    dd5c:	cf 91       	pop	r28
    dd5e:	df 91       	pop	r29
    dd60:	1f 91       	pop	r17
    dd62:	0f 91       	pop	r16
    dd64:	ff 90       	pop	r15
    dd66:	ef 90       	pop	r14
    dd68:	df 90       	pop	r13
    dd6a:	cf 90       	pop	r12
    dd6c:	bf 90       	pop	r11
    dd6e:	af 90       	pop	r10
    dd70:	9f 90       	pop	r9
    dd72:	8f 90       	pop	r8
    dd74:	7f 90       	pop	r7
    dd76:	6f 90       	pop	r6
    dd78:	08 95       	ret

0000dd7a <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
    dd7a:	ef 92       	push	r14
    dd7c:	0f 93       	push	r16
    dd7e:	1f 93       	push	r17
    dd80:	df 93       	push	r29
    dd82:	cf 93       	push	r28
    dd84:	cd b7       	in	r28, 0x3d	; 61
    dd86:	de b7       	in	r29, 0x3e	; 62
    dd88:	c6 54       	subi	r28, 0x46	; 70
    dd8a:	d0 40       	sbci	r29, 0x00	; 0
    dd8c:	0f b6       	in	r0, 0x3f	; 63
    dd8e:	f8 94       	cli
    dd90:	de bf       	out	0x3e, r29	; 62
    dd92:	0f be       	out	0x3f, r0	; 63
    dd94:	cd bf       	out	0x3d, r28	; 61
	 char strHeaderFooter[50];
	 char KeyChar;
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
    dd96:	80 91 44 02 	lds	r24, 0x0244
    dd9a:	84 30       	cpi	r24, 0x04	; 4
    dd9c:	09 f4       	brne	.+2      	; 0xdda0 <FMenuSettingFooter+0x26>
    dd9e:	3b c1       	rjmp	.+630    	; 0xe016 <FMenuSettingFooter+0x29c>
    dda0:	85 30       	cpi	r24, 0x05	; 5
    dda2:	40 f4       	brcc	.+16     	; 0xddb4 <FMenuSettingFooter+0x3a>
    dda4:	81 30       	cpi	r24, 0x01	; 1
    dda6:	79 f1       	breq	.+94     	; 0xde06 <FMenuSettingFooter+0x8c>
    dda8:	81 30       	cpi	r24, 0x01	; 1
    ddaa:	88 f0       	brcs	.+34     	; 0xddce <FMenuSettingFooter+0x54>
    ddac:	82 30       	cpi	r24, 0x02	; 2
    ddae:	09 f0       	breq	.+2      	; 0xddb2 <FMenuSettingFooter+0x38>
    ddb0:	7f c1       	rjmp	.+766    	; 0xe0b0 <FMenuSettingFooter+0x336>
    ddb2:	74 c0       	rjmp	.+232    	; 0xde9c <FMenuSettingFooter+0x122>
    ddb4:	86 30       	cpi	r24, 0x06	; 6
    ddb6:	09 f4       	brne	.+2      	; 0xddba <FMenuSettingFooter+0x40>
    ddb8:	d3 c0       	rjmp	.+422    	; 0xdf60 <FMenuSettingFooter+0x1e6>
    ddba:	86 30       	cpi	r24, 0x06	; 6
    ddbc:	08 f4       	brcc	.+2      	; 0xddc0 <FMenuSettingFooter+0x46>
    ddbe:	bd c0       	rjmp	.+378    	; 0xdf3a <FMenuSettingFooter+0x1c0>
    ddc0:	87 30       	cpi	r24, 0x07	; 7
    ddc2:	09 f4       	brne	.+2      	; 0xddc6 <FMenuSettingFooter+0x4c>
    ddc4:	37 c1       	rjmp	.+622    	; 0xe034 <FMenuSettingFooter+0x2ba>
    ddc6:	88 30       	cpi	r24, 0x08	; 8
    ddc8:	09 f0       	breq	.+2      	; 0xddcc <FMenuSettingFooter+0x52>
    ddca:	72 c1       	rjmp	.+740    	; 0xe0b0 <FMenuSettingFooter+0x336>
    ddcc:	6d c1       	rjmp	.+730    	; 0xe0a8 <FMenuSettingFooter+0x32e>
	 case shInitHeader:
	      lcd_clear();
    ddce:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
    ddd2:	81 e0       	ldi	r24, 0x01	; 1
    ddd4:	61 e0       	ldi	r22, 0x01	; 1
    ddd6:	48 e8       	ldi	r20, 0x88	; 136
    ddd8:	53 e1       	ldi	r21, 0x13	; 19
    ddda:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
    ddde:	82 e0       	ldi	r24, 0x02	; 2
    dde0:	61 e0       	ldi	r22, 0x01	; 1
    dde2:	43 e7       	ldi	r20, 0x73	; 115
    dde4:	53 e1       	ldi	r21, 0x13	; 19
    dde6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
    ddea:	83 e0       	ldi	r24, 0x03	; 3
    ddec:	61 e0       	ldi	r22, 0x01	; 1
    ddee:	4e e5       	ldi	r20, 0x5E	; 94
    ddf0:	53 e1       	ldi	r21, 0x13	; 19
    ddf2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
    ddf6:	84 e0       	ldi	r24, 0x04	; 4
    ddf8:	61 e0       	ldi	r22, 0x01	; 1
    ddfa:	49 e4       	ldi	r20, 0x49	; 73
    ddfc:	53 e1       	ldi	r21, 0x13	; 19
    ddfe:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
    de02:	81 e0       	ldi	r24, 0x01	; 1
    de04:	10 c1       	rjmp	.+544    	; 0xe026 <FMenuSettingFooter+0x2ac>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
    de06:	81 e0       	ldi	r24, 0x01	; 1
    de08:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    de0c:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    de10:	e8 2e       	mov	r14, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    de12:	81 53       	subi	r24, 0x31	; 49
    de14:	86 30       	cpi	r24, 0x06	; 6
    de16:	e0 f5       	brcc	.+120    	; 0xde90 <FMenuSettingFooter+0x116>
		       HeaderIdx=KeyChar-'1';//
    de18:	80 93 43 02 	sts	0x0243, r24
			   lcd_clear();
    de1c:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
    de20:	00 d0       	rcall	.+0      	; 0xde22 <FMenuSettingFooter+0xa8>
    de22:	00 d0       	rcall	.+0      	; 0xde24 <FMenuSettingFooter+0xaa>
    de24:	00 d0       	rcall	.+0      	; 0xde26 <FMenuSettingFooter+0xac>
    de26:	ed b7       	in	r30, 0x3d	; 61
    de28:	fe b7       	in	r31, 0x3e	; 62
    de2a:	31 96       	adiw	r30, 0x01	; 1
    de2c:	8e 01       	movw	r16, r28
    de2e:	0f 5f       	subi	r16, 0xFF	; 255
    de30:	1f 4f       	sbci	r17, 0xFF	; 255
    de32:	ad b7       	in	r26, 0x3d	; 61
    de34:	be b7       	in	r27, 0x3e	; 62
    de36:	12 96       	adiw	r26, 0x02	; 2
    de38:	1c 93       	st	X, r17
    de3a:	0e 93       	st	-X, r16
    de3c:	11 97       	sbiw	r26, 0x01	; 1
    de3e:	8a e3       	ldi	r24, 0x3A	; 58
    de40:	93 e1       	ldi	r25, 0x13	; 19
    de42:	93 83       	std	Z+3, r25	; 0x03
    de44:	82 83       	std	Z+2, r24	; 0x02
    de46:	80 91 43 02 	lds	r24, 0x0243
    de4a:	90 e0       	ldi	r25, 0x00	; 0
    de4c:	01 96       	adiw	r24, 0x01	; 1
    de4e:	95 83       	std	Z+5, r25	; 0x05
    de50:	84 83       	std	Z+4, r24	; 0x04
    de52:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			   lcd_print(1,1,lcdteks);
    de56:	8d b7       	in	r24, 0x3d	; 61
    de58:	9e b7       	in	r25, 0x3e	; 62
    de5a:	06 96       	adiw	r24, 0x06	; 6
    de5c:	0f b6       	in	r0, 0x3f	; 63
    de5e:	f8 94       	cli
    de60:	9e bf       	out	0x3e, r25	; 62
    de62:	0f be       	out	0x3f, r0	; 63
    de64:	8d bf       	out	0x3d, r24	; 61
    de66:	81 e0       	ldi	r24, 0x01	; 1
    de68:	61 e0       	ldi	r22, 0x01	; 1
    de6a:	a8 01       	movw	r20, r16
    de6c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
    de70:	84 e0       	ldi	r24, 0x04	; 4
    de72:	61 e0       	ldi	r22, 0x01	; 1
    de74:	4b e2       	ldi	r20, 0x2B	; 43
    de76:	53 e1       	ldi	r21, 0x13	; 19
    de78:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    de7c:	ec ee       	ldi	r30, 0xEC	; 236
    de7e:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    de80:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    de82:	95 e0       	ldi	r25, 0x05	; 5
    de84:	ed 37       	cpi	r30, 0x7D	; 125
    de86:	f9 07       	cpc	r31, r25
    de88:	d9 f7       	brne	.-10     	; 0xde80 <FMenuSettingFooter+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
    de8a:	82 e0       	ldi	r24, 0x02	; 2
    de8c:	80 93 44 02 	sts	0x0244, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
    de90:	aa e2       	ldi	r26, 0x2A	; 42
    de92:	ea 16       	cp	r14, r26
    de94:	09 f0       	breq	.+2      	; 0xde98 <FMenuSettingFooter+0x11e>
    de96:	0c c1       	rjmp	.+536    	; 0xe0b0 <FMenuSettingFooter+0x336>
    de98:	88 e0       	ldi	r24, 0x08	; 8
    de9a:	c5 c0       	rjmp	.+394    	; 0xe026 <FMenuSettingFooter+0x2ac>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
    de9c:	83 e0       	ldi	r24, 0x03	; 3
    de9e:	62 e0       	ldi	r22, 0x02	; 2
    dea0:	41 e0       	ldi	r20, 0x01	; 1
    dea2:	2c ee       	ldi	r18, 0xEC	; 236
    dea4:	33 e0       	ldi	r19, 0x03	; 3
    dea6:	00 e0       	ldi	r16, 0x00	; 0
    dea8:	10 e0       	ldi	r17, 0x00	; 0
    deaa:	58 e2       	ldi	r21, 0x28	; 40
    deac:	e5 2e       	mov	r14, r21
    deae:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  if (uiResult==USER_OK){
    deb2:	83 30       	cpi	r24, 0x03	; 3
    deb4:	f1 f5       	brne	.+124    	; 0xdf32 <FMenuSettingFooter+0x1b8>
			  lcd_clear();
    deb6:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
    deba:	8c ee       	ldi	r24, 0xEC	; 236
    debc:	93 e0       	ldi	r25, 0x03	; 3
    debe:	68 e2       	ldi	r22, 0x28	; 40
    dec0:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
    dec4:	20 e0       	ldi	r18, 0x00	; 0
    dec6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    dec8:	f9 01       	movw	r30, r18
    deca:	ee 56       	subi	r30, 0x6E	; 110
    decc:	f7 4f       	sbci	r31, 0xF7	; 247
    dece:	d9 01       	movw	r26, r18
    ded0:	a4 51       	subi	r26, 0x14	; 20
    ded2:	bc 4f       	sbci	r27, 0xFC	; 252
    ded4:	8c 91       	ld	r24, X
    ded6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ded8:	2f 5f       	subi	r18, 0xFF	; 255
    deda:	3f 4f       	sbci	r19, 0xFF	; 255
    dedc:	24 31       	cpi	r18, 0x14	; 20
    dede:	31 05       	cpc	r19, r1
    dee0:	99 f7       	brne	.-26     	; 0xdec8 <FMenuSettingFooter+0x14e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    dee2:	10 92 a6 08 	sts	0x08A6, r1
    dee6:	e0 e0       	ldi	r30, 0x00	; 0
    dee8:	f4 e0       	ldi	r31, 0x04	; 4
    deea:	a3 ea       	ldi	r26, 0xA3	; 163
    deec:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    deee:	81 91       	ld	r24, Z+
    def0:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    def2:	84 e0       	ldi	r24, 0x04	; 4
    def4:	e4 31       	cpi	r30, 0x14	; 20
    def6:	f8 07       	cpc	r31, r24
    def8:	d1 f7       	brne	.-12     	; 0xdeee <FMenuSettingFooter+0x174>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    defa:	10 92 b7 07 	sts	0x07B7, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
    defe:	81 e0       	ldi	r24, 0x01	; 1
    df00:	61 e0       	ldi	r22, 0x01	; 1
    df02:	42 e9       	ldi	r20, 0x92	; 146
    df04:	58 e0       	ldi	r21, 0x08	; 8
    df06:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
    df0a:	82 e0       	ldi	r24, 0x02	; 2
    df0c:	61 e0       	ldi	r22, 0x01	; 1
    df0e:	43 ea       	ldi	r20, 0xA3	; 163
    df10:	57 e0       	ldi	r21, 0x07	; 7
    df12:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
    df16:	83 e0       	ldi	r24, 0x03	; 3
    df18:	61 e0       	ldi	r22, 0x01	; 1
    df1a:	4d e1       	ldi	r20, 0x1D	; 29
    df1c:	53 e1       	ldi	r21, 0x13	; 19
    df1e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
    df22:	84 e0       	ldi	r24, 0x04	; 4
    df24:	61 e0       	ldi	r22, 0x01	; 1
    df26:	4f e0       	ldi	r20, 0x0F	; 15
    df28:	53 e1       	ldi	r21, 0x13	; 19
    df2a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
    df2e:	85 e0       	ldi	r24, 0x05	; 5
    df30:	7a c0       	rjmp	.+244    	; 0xe026 <FMenuSettingFooter+0x2ac>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
    df32:	81 30       	cpi	r24, 0x01	; 1
    df34:	09 f0       	breq	.+2      	; 0xdf38 <FMenuSettingFooter+0x1be>
    df36:	bc c0       	rjmp	.+376    	; 0xe0b0 <FMenuSettingFooter+0x336>
    df38:	b4 c0       	rjmp	.+360    	; 0xe0a2 <FMenuSettingFooter+0x328>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
    df3a:	81 e0       	ldi	r24, 0x01	; 1
    df3c:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    df40:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
          if(KeyChar=='#'){
    df44:	83 32       	cpi	r24, 0x23	; 35
    df46:	39 f4       	brne	.+14     	; 0xdf56 <FMenuSettingFooter+0x1dc>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
    df48:	8c ee       	ldi	r24, 0xEC	; 236
    df4a:	93 e0       	ldi	r25, 0x03	; 3
    df4c:	68 e2       	ldi	r22, 0x28	; 40
    df4e:	70 e0       	ldi	r23, 0x00	; 0
    df50:	0e 94 c8 2d 	call	0x5b90	; 0x5b90 <StrAlignCenter>
    df54:	03 c0       	rjmp	.+6      	; 0xdf5c <FMenuSettingFooter+0x1e2>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
    df56:	8a 32       	cpi	r24, 0x2A	; 42
    df58:	09 f0       	breq	.+2      	; 0xdf5c <FMenuSettingFooter+0x1e2>
    df5a:	aa c0       	rjmp	.+340    	; 0xe0b0 <FMenuSettingFooter+0x336>
    df5c:	86 e0       	ldi	r24, 0x06	; 6
    df5e:	63 c0       	rjmp	.+198    	; 0xe026 <FMenuSettingFooter+0x2ac>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
    df60:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    df64:	20 e0       	ldi	r18, 0x00	; 0
    df66:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    df68:	f9 01       	movw	r30, r18
    df6a:	ee 56       	subi	r30, 0x6E	; 110
    df6c:	f7 4f       	sbci	r31, 0xF7	; 247
    df6e:	d9 01       	movw	r26, r18
    df70:	a4 51       	subi	r26, 0x14	; 20
    df72:	bc 4f       	sbci	r27, 0xFC	; 252
    df74:	8c 91       	ld	r24, X
    df76:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    df78:	2f 5f       	subi	r18, 0xFF	; 255
    df7a:	3f 4f       	sbci	r19, 0xFF	; 255
    df7c:	24 31       	cpi	r18, 0x14	; 20
    df7e:	31 05       	cpc	r19, r1
    df80:	99 f7       	brne	.-26     	; 0xdf68 <FMenuSettingFooter+0x1ee>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    df82:	10 92 a6 08 	sts	0x08A6, r1
    df86:	e0 e0       	ldi	r30, 0x00	; 0
    df88:	f4 e0       	ldi	r31, 0x04	; 4
    df8a:	a3 ea       	ldi	r26, 0xA3	; 163
    df8c:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    df8e:	81 91       	ld	r24, Z+
    df90:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    df92:	94 e0       	ldi	r25, 0x04	; 4
    df94:	e4 31       	cpi	r30, 0x14	; 20
    df96:	f9 07       	cpc	r31, r25
    df98:	d1 f7       	brne	.-12     	; 0xdf8e <FMenuSettingFooter+0x214>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    df9a:	10 92 b7 07 	sts	0x07B7, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
    df9e:	81 e0       	ldi	r24, 0x01	; 1
    dfa0:	61 e0       	ldi	r22, 0x01	; 1
    dfa2:	42 e9       	ldi	r20, 0x92	; 146
    dfa4:	58 e0       	ldi	r21, 0x08	; 8
    dfa6:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    dfaa:	82 e0       	ldi	r24, 0x02	; 2
    dfac:	61 e0       	ldi	r22, 0x01	; 1
    dfae:	43 ea       	ldi	r20, 0xA3	; 163
    dfb0:	57 e0       	ldi	r21, 0x07	; 7
    dfb2:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
    dfb6:	00 d0       	rcall	.+0      	; 0xdfb8 <FMenuSettingFooter+0x23e>
    dfb8:	00 d0       	rcall	.+0      	; 0xdfba <FMenuSettingFooter+0x240>
    dfba:	00 d0       	rcall	.+0      	; 0xdfbc <FMenuSettingFooter+0x242>
    dfbc:	ed b7       	in	r30, 0x3d	; 61
    dfbe:	fe b7       	in	r31, 0x3e	; 62
    dfc0:	31 96       	adiw	r30, 0x01	; 1
    dfc2:	8e 01       	movw	r16, r28
    dfc4:	0f 5f       	subi	r16, 0xFF	; 255
    dfc6:	1f 4f       	sbci	r17, 0xFF	; 255
    dfc8:	ad b7       	in	r26, 0x3d	; 61
    dfca:	be b7       	in	r27, 0x3e	; 62
    dfcc:	12 96       	adiw	r26, 0x02	; 2
    dfce:	1c 93       	st	X, r17
    dfd0:	0e 93       	st	-X, r16
    dfd2:	11 97       	sbiw	r26, 0x01	; 1
    dfd4:	8f ef       	ldi	r24, 0xFF	; 255
    dfd6:	92 e1       	ldi	r25, 0x12	; 18
    dfd8:	93 83       	std	Z+3, r25	; 0x03
    dfda:	82 83       	std	Z+2, r24	; 0x02
    dfdc:	80 91 43 02 	lds	r24, 0x0243
    dfe0:	90 e0       	ldi	r25, 0x00	; 0
    dfe2:	01 96       	adiw	r24, 0x01	; 1
    dfe4:	95 83       	std	Z+5, r25	; 0x05
    dfe6:	84 83       	std	Z+4, r24	; 0x04
    dfe8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    dfec:	8d b7       	in	r24, 0x3d	; 61
    dfee:	9e b7       	in	r25, 0x3e	; 62
    dff0:	06 96       	adiw	r24, 0x06	; 6
    dff2:	0f b6       	in	r0, 0x3f	; 63
    dff4:	f8 94       	cli
    dff6:	9e bf       	out	0x3e, r25	; 62
    dff8:	0f be       	out	0x3f, r0	; 63
    dffa:	8d bf       	out	0x3d, r24	; 61
    dffc:	83 e0       	ldi	r24, 0x03	; 3
    dffe:	61 e0       	ldi	r22, 0x01	; 1
    e000:	a8 01       	movw	r20, r16
    e002:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
    e006:	84 e0       	ldi	r24, 0x04	; 4
    e008:	61 e0       	ldi	r22, 0x01	; 1
    e00a:	42 ef       	ldi	r20, 0xF2	; 242
    e00c:	52 e1       	ldi	r21, 0x12	; 18
    e00e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
    e012:	84 e0       	ldi	r24, 0x04	; 4
    e014:	08 c0       	rjmp	.+16     	; 0xe026 <FMenuSettingFooter+0x2ac>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
    e016:	81 e0       	ldi	r24, 0x01	; 1
    e018:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    e01c:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
    e020:	83 32       	cpi	r24, 0x23	; 35
    e022:	21 f4       	brne	.+8      	; 0xe02c <FMenuSettingFooter+0x2b2>
    e024:	87 e0       	ldi	r24, 0x07	; 7
    e026:	80 93 44 02 	sts	0x0244, r24
    e02a:	42 c0       	rjmp	.+132    	; 0xe0b0 <FMenuSettingFooter+0x336>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
    e02c:	8a 32       	cpi	r24, 0x2A	; 42
    e02e:	09 f0       	breq	.+2      	; 0xe032 <FMenuSettingFooter+0x2b8>
    e030:	3f c0       	rjmp	.+126    	; 0xe0b0 <FMenuSettingFooter+0x336>
    e032:	37 c0       	rjmp	.+110    	; 0xe0a2 <FMenuSettingFooter+0x328>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
    e034:	ad b7       	in	r26, 0x3d	; 61
    e036:	be b7       	in	r27, 0x3e	; 62
    e038:	18 97       	sbiw	r26, 0x08	; 8
    e03a:	0f b6       	in	r0, 0x3f	; 63
    e03c:	f8 94       	cli
    e03e:	be bf       	out	0x3e, r27	; 62
    e040:	0f be       	out	0x3f, r0	; 63
    e042:	ad bf       	out	0x3d, r26	; 61
    e044:	ed b7       	in	r30, 0x3d	; 61
    e046:	fe b7       	in	r31, 0x3e	; 62
    e048:	31 96       	adiw	r30, 0x01	; 1
    e04a:	8e 01       	movw	r16, r28
    e04c:	0b 5e       	subi	r16, 0xEB	; 235
    e04e:	1f 4f       	sbci	r17, 0xFF	; 255
    e050:	12 96       	adiw	r26, 0x02	; 2
    e052:	1c 93       	st	X, r17
    e054:	0e 93       	st	-X, r16
    e056:	11 97       	sbiw	r26, 0x01	; 1
    e058:	8d ee       	ldi	r24, 0xED	; 237
    e05a:	92 e1       	ldi	r25, 0x12	; 18
    e05c:	93 83       	std	Z+3, r25	; 0x03
    e05e:	82 83       	std	Z+2, r24	; 0x02
    e060:	82 e9       	ldi	r24, 0x92	; 146
    e062:	98 e0       	ldi	r25, 0x08	; 8
    e064:	95 83       	std	Z+5, r25	; 0x05
    e066:	84 83       	std	Z+4, r24	; 0x04
    e068:	83 ea       	ldi	r24, 0xA3	; 163
    e06a:	97 e0       	ldi	r25, 0x07	; 7
    e06c:	97 83       	std	Z+7, r25	; 0x07
    e06e:	86 83       	std	Z+6, r24	; 0x06
    e070:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    e074:	8d b7       	in	r24, 0x3d	; 61
    e076:	9e b7       	in	r25, 0x3e	; 62
    e078:	08 96       	adiw	r24, 0x08	; 8
    e07a:	0f b6       	in	r0, 0x3f	; 63
    e07c:	f8 94       	cli
    e07e:	9e bf       	out	0x3e, r25	; 62
    e080:	0f be       	out	0x3f, r0	; 63
    e082:	8d bf       	out	0x3d, r24	; 61
    e084:	80 91 43 02 	lds	r24, 0x0243
    e088:	29 e2       	ldi	r18, 0x29	; 41
    e08a:	82 9f       	mul	r24, r18
    e08c:	c0 01       	movw	r24, r0
    e08e:	11 24       	eor	r1, r1
    e090:	83 5e       	subi	r24, 0xE3	; 227
    e092:	9c 4f       	sbci	r25, 0xFC	; 252
    e094:	b8 01       	movw	r22, r16
    e096:	48 e2       	ldi	r20, 0x28	; 40
    e098:	50 e0       	ldi	r21, 0x00	; 0
    e09a:	2c e4       	ldi	r18, 0x4C	; 76
    e09c:	32 e1       	ldi	r19, 0x12	; 18
    e09e:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx+6],40);

          stSettingHeader=shInitHeader;
    e0a2:	10 92 44 02 	sts	0x0244, r1
    e0a6:	04 c0       	rjmp	.+8      	; 0xe0b0 <FMenuSettingFooter+0x336>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
    e0a8:	10 92 44 02 	sts	0x0244, r1
    e0ac:	81 e0       	ldi	r24, 0x01	; 1
    e0ae:	01 c0       	rjmp	.+2      	; 0xe0b2 <FMenuSettingFooter+0x338>
    e0b0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
    e0b2:	ca 5b       	subi	r28, 0xBA	; 186
    e0b4:	df 4f       	sbci	r29, 0xFF	; 255
    e0b6:	0f b6       	in	r0, 0x3f	; 63
    e0b8:	f8 94       	cli
    e0ba:	de bf       	out	0x3e, r29	; 62
    e0bc:	0f be       	out	0x3f, r0	; 63
    e0be:	cd bf       	out	0x3d, r28	; 61
    e0c0:	cf 91       	pop	r28
    e0c2:	df 91       	pop	r29
    e0c4:	1f 91       	pop	r17
    e0c6:	0f 91       	pop	r16
    e0c8:	ef 90       	pop	r14
    e0ca:	08 95       	ret

0000e0cc <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
    e0cc:	ef 92       	push	r14
    e0ce:	0f 93       	push	r16
    e0d0:	1f 93       	push	r17
    e0d2:	df 93       	push	r29
    e0d4:	cf 93       	push	r28
    e0d6:	cd b7       	in	r28, 0x3d	; 61
    e0d8:	de b7       	in	r29, 0x3e	; 62
    e0da:	c6 54       	subi	r28, 0x46	; 70
    e0dc:	d0 40       	sbci	r29, 0x00	; 0
    e0de:	0f b6       	in	r0, 0x3f	; 63
    e0e0:	f8 94       	cli
    e0e2:	de bf       	out	0x3e, r29	; 62
    e0e4:	0f be       	out	0x3f, r0	; 63
    e0e6:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
    e0e8:	80 91 46 02 	lds	r24, 0x0246
    e0ec:	84 30       	cpi	r24, 0x04	; 4
    e0ee:	09 f4       	brne	.+2      	; 0xe0f2 <FMenuSettingHeader+0x26>
    e0f0:	3b c1       	rjmp	.+630    	; 0xe368 <FMenuSettingHeader+0x29c>
    e0f2:	85 30       	cpi	r24, 0x05	; 5
    e0f4:	40 f4       	brcc	.+16     	; 0xe106 <FMenuSettingHeader+0x3a>
    e0f6:	81 30       	cpi	r24, 0x01	; 1
    e0f8:	79 f1       	breq	.+94     	; 0xe158 <FMenuSettingHeader+0x8c>
    e0fa:	81 30       	cpi	r24, 0x01	; 1
    e0fc:	88 f0       	brcs	.+34     	; 0xe120 <FMenuSettingHeader+0x54>
    e0fe:	82 30       	cpi	r24, 0x02	; 2
    e100:	09 f0       	breq	.+2      	; 0xe104 <FMenuSettingHeader+0x38>
    e102:	7f c1       	rjmp	.+766    	; 0xe402 <FMenuSettingHeader+0x336>
    e104:	74 c0       	rjmp	.+232    	; 0xe1ee <FMenuSettingHeader+0x122>
    e106:	86 30       	cpi	r24, 0x06	; 6
    e108:	09 f4       	brne	.+2      	; 0xe10c <FMenuSettingHeader+0x40>
    e10a:	d3 c0       	rjmp	.+422    	; 0xe2b2 <FMenuSettingHeader+0x1e6>
    e10c:	86 30       	cpi	r24, 0x06	; 6
    e10e:	08 f4       	brcc	.+2      	; 0xe112 <FMenuSettingHeader+0x46>
    e110:	bd c0       	rjmp	.+378    	; 0xe28c <FMenuSettingHeader+0x1c0>
    e112:	87 30       	cpi	r24, 0x07	; 7
    e114:	09 f4       	brne	.+2      	; 0xe118 <FMenuSettingHeader+0x4c>
    e116:	37 c1       	rjmp	.+622    	; 0xe386 <FMenuSettingHeader+0x2ba>
    e118:	88 30       	cpi	r24, 0x08	; 8
    e11a:	09 f0       	breq	.+2      	; 0xe11e <FMenuSettingHeader+0x52>
    e11c:	72 c1       	rjmp	.+740    	; 0xe402 <FMenuSettingHeader+0x336>
    e11e:	6d c1       	rjmp	.+730    	; 0xe3fa <FMenuSettingHeader+0x32e>
	 case shInitHeader:
	      lcd_clear();
    e120:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
    e124:	81 e0       	ldi	r24, 0x01	; 1
    e126:	61 e0       	ldi	r22, 0x01	; 1
    e128:	48 e3       	ldi	r20, 0x38	; 56
    e12a:	54 e1       	ldi	r21, 0x14	; 20
    e12c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
    e130:	82 e0       	ldi	r24, 0x02	; 2
    e132:	61 e0       	ldi	r22, 0x01	; 1
    e134:	43 e2       	ldi	r20, 0x23	; 35
    e136:	54 e1       	ldi	r21, 0x14	; 20
    e138:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
    e13c:	83 e0       	ldi	r24, 0x03	; 3
    e13e:	61 e0       	ldi	r22, 0x01	; 1
    e140:	4e e0       	ldi	r20, 0x0E	; 14
    e142:	54 e1       	ldi	r21, 0x14	; 20
    e144:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
    e148:	84 e0       	ldi	r24, 0x04	; 4
    e14a:	61 e0       	ldi	r22, 0x01	; 1
    e14c:	49 ef       	ldi	r20, 0xF9	; 249
    e14e:	53 e1       	ldi	r21, 0x13	; 19
    e150:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
    e154:	81 e0       	ldi	r24, 0x01	; 1
    e156:	10 c1       	rjmp	.+544    	; 0xe378 <FMenuSettingHeader+0x2ac>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
    e158:	81 e0       	ldi	r24, 0x01	; 1
    e15a:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    e15e:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    e162:	e8 2e       	mov	r14, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    e164:	81 53       	subi	r24, 0x31	; 49
    e166:	86 30       	cpi	r24, 0x06	; 6
    e168:	e0 f5       	brcc	.+120    	; 0xe1e2 <FMenuSettingHeader+0x116>
		       HeaderIdx=KeyChar-'1';//
    e16a:	80 93 45 02 	sts	0x0245, r24
			   lcd_clear();
    e16e:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
    e172:	00 d0       	rcall	.+0      	; 0xe174 <FMenuSettingHeader+0xa8>
    e174:	00 d0       	rcall	.+0      	; 0xe176 <FMenuSettingHeader+0xaa>
    e176:	00 d0       	rcall	.+0      	; 0xe178 <FMenuSettingHeader+0xac>
    e178:	ed b7       	in	r30, 0x3d	; 61
    e17a:	fe b7       	in	r31, 0x3e	; 62
    e17c:	31 96       	adiw	r30, 0x01	; 1
    e17e:	8e 01       	movw	r16, r28
    e180:	0f 5f       	subi	r16, 0xFF	; 255
    e182:	1f 4f       	sbci	r17, 0xFF	; 255
    e184:	ad b7       	in	r26, 0x3d	; 61
    e186:	be b7       	in	r27, 0x3e	; 62
    e188:	12 96       	adiw	r26, 0x02	; 2
    e18a:	1c 93       	st	X, r17
    e18c:	0e 93       	st	-X, r16
    e18e:	11 97       	sbiw	r26, 0x01	; 1
    e190:	8a ee       	ldi	r24, 0xEA	; 234
    e192:	93 e1       	ldi	r25, 0x13	; 19
    e194:	93 83       	std	Z+3, r25	; 0x03
    e196:	82 83       	std	Z+2, r24	; 0x02
    e198:	80 91 45 02 	lds	r24, 0x0245
    e19c:	90 e0       	ldi	r25, 0x00	; 0
    e19e:	01 96       	adiw	r24, 0x01	; 1
    e1a0:	95 83       	std	Z+5, r25	; 0x05
    e1a2:	84 83       	std	Z+4, r24	; 0x04
    e1a4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			   lcd_print(1,1,lcdteks);
    e1a8:	8d b7       	in	r24, 0x3d	; 61
    e1aa:	9e b7       	in	r25, 0x3e	; 62
    e1ac:	06 96       	adiw	r24, 0x06	; 6
    e1ae:	0f b6       	in	r0, 0x3f	; 63
    e1b0:	f8 94       	cli
    e1b2:	9e bf       	out	0x3e, r25	; 62
    e1b4:	0f be       	out	0x3f, r0	; 63
    e1b6:	8d bf       	out	0x3d, r24	; 61
    e1b8:	81 e0       	ldi	r24, 0x01	; 1
    e1ba:	61 e0       	ldi	r22, 0x01	; 1
    e1bc:	a8 01       	movw	r20, r16
    e1be:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
    e1c2:	84 e0       	ldi	r24, 0x04	; 4
    e1c4:	61 e0       	ldi	r22, 0x01	; 1
    e1c6:	4b ed       	ldi	r20, 0xDB	; 219
    e1c8:	53 e1       	ldi	r21, 0x13	; 19
    e1ca:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    e1ce:	ec ee       	ldi	r30, 0xEC	; 236
    e1d0:	f3 e0       	ldi	r31, 0x03	; 3
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    e1d2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    e1d4:	95 e0       	ldi	r25, 0x05	; 5
    e1d6:	ed 37       	cpi	r30, 0x7D	; 125
    e1d8:	f9 07       	cpc	r31, r25
    e1da:	d9 f7       	brne	.-10     	; 0xe1d2 <FMenuSettingHeader+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
    e1dc:	82 e0       	ldi	r24, 0x02	; 2
    e1de:	80 93 46 02 	sts	0x0246, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
    e1e2:	aa e2       	ldi	r26, 0x2A	; 42
    e1e4:	ea 16       	cp	r14, r26
    e1e6:	09 f0       	breq	.+2      	; 0xe1ea <FMenuSettingHeader+0x11e>
    e1e8:	0c c1       	rjmp	.+536    	; 0xe402 <FMenuSettingHeader+0x336>
    e1ea:	88 e0       	ldi	r24, 0x08	; 8
    e1ec:	c5 c0       	rjmp	.+394    	; 0xe378 <FMenuSettingHeader+0x2ac>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
    e1ee:	83 e0       	ldi	r24, 0x03	; 3
    e1f0:	62 e0       	ldi	r22, 0x02	; 2
    e1f2:	41 e0       	ldi	r20, 0x01	; 1
    e1f4:	2c ee       	ldi	r18, 0xEC	; 236
    e1f6:	33 e0       	ldi	r19, 0x03	; 3
    e1f8:	00 e0       	ldi	r16, 0x00	; 0
    e1fa:	10 e0       	ldi	r17, 0x00	; 0
    e1fc:	78 e2       	ldi	r23, 0x28	; 40
    e1fe:	e7 2e       	mov	r14, r23
    e200:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  if (uiResult==USER_OK){
    e204:	83 30       	cpi	r24, 0x03	; 3
    e206:	f1 f5       	brne	.+124    	; 0xe284 <FMenuSettingHeader+0x1b8>
			  lcd_clear();
    e208:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
    e20c:	8c ee       	ldi	r24, 0xEC	; 236
    e20e:	93 e0       	ldi	r25, 0x03	; 3
    e210:	68 e2       	ldi	r22, 0x28	; 40
    e212:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
    e216:	20 e0       	ldi	r18, 0x00	; 0
    e218:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    e21a:	f9 01       	movw	r30, r18
    e21c:	ee 56       	subi	r30, 0x6E	; 110
    e21e:	f7 4f       	sbci	r31, 0xF7	; 247
    e220:	d9 01       	movw	r26, r18
    e222:	a4 51       	subi	r26, 0x14	; 20
    e224:	bc 4f       	sbci	r27, 0xFC	; 252
    e226:	8c 91       	ld	r24, X
    e228:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    e22a:	2f 5f       	subi	r18, 0xFF	; 255
    e22c:	3f 4f       	sbci	r19, 0xFF	; 255
    e22e:	24 31       	cpi	r18, 0x14	; 20
    e230:	31 05       	cpc	r19, r1
    e232:	99 f7       	brne	.-26     	; 0xe21a <FMenuSettingHeader+0x14e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    e234:	10 92 a6 08 	sts	0x08A6, r1
    e238:	e0 e0       	ldi	r30, 0x00	; 0
    e23a:	f4 e0       	ldi	r31, 0x04	; 4
    e23c:	a3 ea       	ldi	r26, 0xA3	; 163
    e23e:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    e240:	81 91       	ld	r24, Z+
    e242:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    e244:	84 e0       	ldi	r24, 0x04	; 4
    e246:	e4 31       	cpi	r30, 0x14	; 20
    e248:	f8 07       	cpc	r31, r24
    e24a:	d1 f7       	brne	.-12     	; 0xe240 <FMenuSettingHeader+0x174>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    e24c:	10 92 b7 07 	sts	0x07B7, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
    e250:	81 e0       	ldi	r24, 0x01	; 1
    e252:	61 e0       	ldi	r22, 0x01	; 1
    e254:	42 e9       	ldi	r20, 0x92	; 146
    e256:	58 e0       	ldi	r21, 0x08	; 8
    e258:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
    e25c:	82 e0       	ldi	r24, 0x02	; 2
    e25e:	61 e0       	ldi	r22, 0x01	; 1
    e260:	43 ea       	ldi	r20, 0xA3	; 163
    e262:	57 e0       	ldi	r21, 0x07	; 7
    e264:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
    e268:	83 e0       	ldi	r24, 0x03	; 3
    e26a:	61 e0       	ldi	r22, 0x01	; 1
    e26c:	4d ec       	ldi	r20, 0xCD	; 205
    e26e:	53 e1       	ldi	r21, 0x13	; 19
    e270:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
    e274:	84 e0       	ldi	r24, 0x04	; 4
    e276:	61 e0       	ldi	r22, 0x01	; 1
    e278:	4f eb       	ldi	r20, 0xBF	; 191
    e27a:	53 e1       	ldi	r21, 0x13	; 19
    e27c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
    e280:	85 e0       	ldi	r24, 0x05	; 5
    e282:	7a c0       	rjmp	.+244    	; 0xe378 <FMenuSettingHeader+0x2ac>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
    e284:	81 30       	cpi	r24, 0x01	; 1
    e286:	09 f0       	breq	.+2      	; 0xe28a <FMenuSettingHeader+0x1be>
    e288:	bc c0       	rjmp	.+376    	; 0xe402 <FMenuSettingHeader+0x336>
    e28a:	b4 c0       	rjmp	.+360    	; 0xe3f4 <FMenuSettingHeader+0x328>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
    e28c:	81 e0       	ldi	r24, 0x01	; 1
    e28e:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    e292:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
          if(KeyChar=='#'){
    e296:	83 32       	cpi	r24, 0x23	; 35
    e298:	39 f4       	brne	.+14     	; 0xe2a8 <FMenuSettingHeader+0x1dc>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
    e29a:	8c ee       	ldi	r24, 0xEC	; 236
    e29c:	93 e0       	ldi	r25, 0x03	; 3
    e29e:	68 e2       	ldi	r22, 0x28	; 40
    e2a0:	70 e0       	ldi	r23, 0x00	; 0
    e2a2:	0e 94 c8 2d 	call	0x5b90	; 0x5b90 <StrAlignCenter>
    e2a6:	03 c0       	rjmp	.+6      	; 0xe2ae <FMenuSettingHeader+0x1e2>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
    e2a8:	8a 32       	cpi	r24, 0x2A	; 42
    e2aa:	09 f0       	breq	.+2      	; 0xe2ae <FMenuSettingHeader+0x1e2>
    e2ac:	aa c0       	rjmp	.+340    	; 0xe402 <FMenuSettingHeader+0x336>
    e2ae:	86 e0       	ldi	r24, 0x06	; 6
    e2b0:	63 c0       	rjmp	.+198    	; 0xe378 <FMenuSettingHeader+0x2ac>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
    e2b2:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    e2b6:	20 e0       	ldi	r18, 0x00	; 0
    e2b8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    e2ba:	f9 01       	movw	r30, r18
    e2bc:	ee 56       	subi	r30, 0x6E	; 110
    e2be:	f7 4f       	sbci	r31, 0xF7	; 247
    e2c0:	d9 01       	movw	r26, r18
    e2c2:	a4 51       	subi	r26, 0x14	; 20
    e2c4:	bc 4f       	sbci	r27, 0xFC	; 252
    e2c6:	8c 91       	ld	r24, X
    e2c8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    e2ca:	2f 5f       	subi	r18, 0xFF	; 255
    e2cc:	3f 4f       	sbci	r19, 0xFF	; 255
    e2ce:	24 31       	cpi	r18, 0x14	; 20
    e2d0:	31 05       	cpc	r19, r1
    e2d2:	99 f7       	brne	.-26     	; 0xe2ba <FMenuSettingHeader+0x1ee>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    e2d4:	10 92 a6 08 	sts	0x08A6, r1
    e2d8:	e0 e0       	ldi	r30, 0x00	; 0
    e2da:	f4 e0       	ldi	r31, 0x04	; 4
    e2dc:	a3 ea       	ldi	r26, 0xA3	; 163
    e2de:	b7 e0       	ldi	r27, 0x07	; 7
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    e2e0:	81 91       	ld	r24, Z+
    e2e2:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    e2e4:	94 e0       	ldi	r25, 0x04	; 4
    e2e6:	e4 31       	cpi	r30, 0x14	; 20
    e2e8:	f9 07       	cpc	r31, r25
    e2ea:	d1 f7       	brne	.-12     	; 0xe2e0 <FMenuSettingHeader+0x214>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    e2ec:	10 92 b7 07 	sts	0x07B7, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
    e2f0:	81 e0       	ldi	r24, 0x01	; 1
    e2f2:	61 e0       	ldi	r22, 0x01	; 1
    e2f4:	42 e9       	ldi	r20, 0x92	; 146
    e2f6:	58 e0       	ldi	r21, 0x08	; 8
    e2f8:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    e2fc:	82 e0       	ldi	r24, 0x02	; 2
    e2fe:	61 e0       	ldi	r22, 0x01	; 1
    e300:	43 ea       	ldi	r20, 0xA3	; 163
    e302:	57 e0       	ldi	r21, 0x07	; 7
    e304:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
    e308:	00 d0       	rcall	.+0      	; 0xe30a <FMenuSettingHeader+0x23e>
    e30a:	00 d0       	rcall	.+0      	; 0xe30c <FMenuSettingHeader+0x240>
    e30c:	00 d0       	rcall	.+0      	; 0xe30e <FMenuSettingHeader+0x242>
    e30e:	ed b7       	in	r30, 0x3d	; 61
    e310:	fe b7       	in	r31, 0x3e	; 62
    e312:	31 96       	adiw	r30, 0x01	; 1
    e314:	8e 01       	movw	r16, r28
    e316:	0f 5f       	subi	r16, 0xFF	; 255
    e318:	1f 4f       	sbci	r17, 0xFF	; 255
    e31a:	ad b7       	in	r26, 0x3d	; 61
    e31c:	be b7       	in	r27, 0x3e	; 62
    e31e:	12 96       	adiw	r26, 0x02	; 2
    e320:	1c 93       	st	X, r17
    e322:	0e 93       	st	-X, r16
    e324:	11 97       	sbiw	r26, 0x01	; 1
    e326:	8f ea       	ldi	r24, 0xAF	; 175
    e328:	93 e1       	ldi	r25, 0x13	; 19
    e32a:	93 83       	std	Z+3, r25	; 0x03
    e32c:	82 83       	std	Z+2, r24	; 0x02
    e32e:	80 91 45 02 	lds	r24, 0x0245
    e332:	90 e0       	ldi	r25, 0x00	; 0
    e334:	01 96       	adiw	r24, 0x01	; 1
    e336:	95 83       	std	Z+5, r25	; 0x05
    e338:	84 83       	std	Z+4, r24	; 0x04
    e33a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    e33e:	8d b7       	in	r24, 0x3d	; 61
    e340:	9e b7       	in	r25, 0x3e	; 62
    e342:	06 96       	adiw	r24, 0x06	; 6
    e344:	0f b6       	in	r0, 0x3f	; 63
    e346:	f8 94       	cli
    e348:	9e bf       	out	0x3e, r25	; 62
    e34a:	0f be       	out	0x3f, r0	; 63
    e34c:	8d bf       	out	0x3d, r24	; 61
    e34e:	83 e0       	ldi	r24, 0x03	; 3
    e350:	61 e0       	ldi	r22, 0x01	; 1
    e352:	a8 01       	movw	r20, r16
    e354:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
    e358:	84 e0       	ldi	r24, 0x04	; 4
    e35a:	61 e0       	ldi	r22, 0x01	; 1
    e35c:	42 ea       	ldi	r20, 0xA2	; 162
    e35e:	53 e1       	ldi	r21, 0x13	; 19
    e360:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
    e364:	84 e0       	ldi	r24, 0x04	; 4
    e366:	08 c0       	rjmp	.+16     	; 0xe378 <FMenuSettingHeader+0x2ac>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
    e368:	81 e0       	ldi	r24, 0x01	; 1
    e36a:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    e36e:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
    e372:	83 32       	cpi	r24, 0x23	; 35
    e374:	21 f4       	brne	.+8      	; 0xe37e <FMenuSettingHeader+0x2b2>
    e376:	87 e0       	ldi	r24, 0x07	; 7
    e378:	80 93 46 02 	sts	0x0246, r24
    e37c:	42 c0       	rjmp	.+132    	; 0xe402 <FMenuSettingHeader+0x336>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
    e37e:	8a 32       	cpi	r24, 0x2A	; 42
    e380:	09 f0       	breq	.+2      	; 0xe384 <FMenuSettingHeader+0x2b8>
    e382:	3f c0       	rjmp	.+126    	; 0xe402 <FMenuSettingHeader+0x336>
    e384:	37 c0       	rjmp	.+110    	; 0xe3f4 <FMenuSettingHeader+0x328>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
    e386:	ad b7       	in	r26, 0x3d	; 61
    e388:	be b7       	in	r27, 0x3e	; 62
    e38a:	18 97       	sbiw	r26, 0x08	; 8
    e38c:	0f b6       	in	r0, 0x3f	; 63
    e38e:	f8 94       	cli
    e390:	be bf       	out	0x3e, r27	; 62
    e392:	0f be       	out	0x3f, r0	; 63
    e394:	ad bf       	out	0x3d, r26	; 61
    e396:	ed b7       	in	r30, 0x3d	; 61
    e398:	fe b7       	in	r31, 0x3e	; 62
    e39a:	31 96       	adiw	r30, 0x01	; 1
    e39c:	8e 01       	movw	r16, r28
    e39e:	0b 5e       	subi	r16, 0xEB	; 235
    e3a0:	1f 4f       	sbci	r17, 0xFF	; 255
    e3a2:	12 96       	adiw	r26, 0x02	; 2
    e3a4:	1c 93       	st	X, r17
    e3a6:	0e 93       	st	-X, r16
    e3a8:	11 97       	sbiw	r26, 0x01	; 1
    e3aa:	8d e9       	ldi	r24, 0x9D	; 157
    e3ac:	93 e1       	ldi	r25, 0x13	; 19
    e3ae:	93 83       	std	Z+3, r25	; 0x03
    e3b0:	82 83       	std	Z+2, r24	; 0x02
    e3b2:	82 e9       	ldi	r24, 0x92	; 146
    e3b4:	98 e0       	ldi	r25, 0x08	; 8
    e3b6:	95 83       	std	Z+5, r25	; 0x05
    e3b8:	84 83       	std	Z+4, r24	; 0x04
    e3ba:	83 ea       	ldi	r24, 0xA3	; 163
    e3bc:	97 e0       	ldi	r25, 0x07	; 7
    e3be:	97 83       	std	Z+7, r25	; 0x07
    e3c0:	86 83       	std	Z+6, r24	; 0x06
    e3c2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    e3c6:	8d b7       	in	r24, 0x3d	; 61
    e3c8:	9e b7       	in	r25, 0x3e	; 62
    e3ca:	08 96       	adiw	r24, 0x08	; 8
    e3cc:	0f b6       	in	r0, 0x3f	; 63
    e3ce:	f8 94       	cli
    e3d0:	9e bf       	out	0x3e, r25	; 62
    e3d2:	0f be       	out	0x3f, r0	; 63
    e3d4:	8d bf       	out	0x3d, r24	; 61
    e3d6:	80 91 45 02 	lds	r24, 0x0245
    e3da:	29 e2       	ldi	r18, 0x29	; 41
    e3dc:	82 9f       	mul	r24, r18
    e3de:	c0 01       	movw	r24, r0
    e3e0:	11 24       	eor	r1, r1
    e3e2:	89 5d       	subi	r24, 0xD9	; 217
    e3e4:	9d 4f       	sbci	r25, 0xFD	; 253
    e3e6:	b8 01       	movw	r22, r16
    e3e8:	48 e2       	ldi	r20, 0x28	; 40
    e3ea:	50 e0       	ldi	r21, 0x00	; 0
    e3ec:	2c e4       	ldi	r18, 0x4C	; 76
    e3ee:	32 e1       	ldi	r19, 0x12	; 18
    e3f0:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
    e3f4:	10 92 46 02 	sts	0x0246, r1
    e3f8:	04 c0       	rjmp	.+8      	; 0xe402 <FMenuSettingHeader+0x336>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
    e3fa:	10 92 46 02 	sts	0x0246, r1
    e3fe:	81 e0       	ldi	r24, 0x01	; 1
    e400:	01 c0       	rjmp	.+2      	; 0xe404 <FMenuSettingHeader+0x338>
    e402:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
    e404:	ca 5b       	subi	r28, 0xBA	; 186
    e406:	df 4f       	sbci	r29, 0xFF	; 255
    e408:	0f b6       	in	r0, 0x3f	; 63
    e40a:	f8 94       	cli
    e40c:	de bf       	out	0x3e, r29	; 62
    e40e:	0f be       	out	0x3f, r0	; 63
    e410:	cd bf       	out	0x3d, r28	; 61
    e412:	cf 91       	pop	r28
    e414:	df 91       	pop	r29
    e416:	1f 91       	pop	r17
    e418:	0f 91       	pop	r16
    e41a:	ef 90       	pop	r14
    e41c:	08 95       	ret

0000e41e <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
    e41e:	80 91 47 02 	lds	r24, 0x0247
    e422:	83 30       	cpi	r24, 0x03	; 3
    e424:	09 f4       	brne	.+2      	; 0xe428 <FMenuAdminSettings+0xa>
    e426:	6e c0       	rjmp	.+220    	; 0xe504 <FMenuAdminSettings+0xe6>
    e428:	84 30       	cpi	r24, 0x04	; 4
    e42a:	30 f4       	brcc	.+12     	; 0xe438 <FMenuAdminSettings+0x1a>
    e42c:	81 30       	cpi	r24, 0x01	; 1
    e42e:	e9 f1       	breq	.+122    	; 0xe4aa <FMenuAdminSettings+0x8c>
    e430:	82 30       	cpi	r24, 0x02	; 2
    e432:	08 f0       	brcs	.+2      	; 0xe436 <FMenuAdminSettings+0x18>
    e434:	64 c0       	rjmp	.+200    	; 0xe4fe <FMenuAdminSettings+0xe0>
    e436:	0d c0       	rjmp	.+26     	; 0xe452 <FMenuAdminSettings+0x34>
    e438:	85 30       	cpi	r24, 0x05	; 5
    e43a:	09 f4       	brne	.+2      	; 0xe43e <FMenuAdminSettings+0x20>
    e43c:	66 c0       	rjmp	.+204    	; 0xe50a <FMenuAdminSettings+0xec>
    e43e:	85 30       	cpi	r24, 0x05	; 5
    e440:	08 f4       	brcc	.+2      	; 0xe444 <FMenuAdminSettings+0x26>
    e442:	6a c0       	rjmp	.+212    	; 0xe518 <FMenuAdminSettings+0xfa>
    e444:	86 30       	cpi	r24, 0x06	; 6
    e446:	09 f4       	brne	.+2      	; 0xe44a <FMenuAdminSettings+0x2c>
    e448:	63 c0       	rjmp	.+198    	; 0xe510 <FMenuAdminSettings+0xf2>
    e44a:	87 30       	cpi	r24, 0x07	; 7
    e44c:	09 f0       	breq	.+2      	; 0xe450 <FMenuAdminSettings+0x32>
    e44e:	6c c0       	rjmp	.+216    	; 0xe528 <FMenuAdminSettings+0x10a>
    e450:	67 c0       	rjmp	.+206    	; 0xe520 <FMenuAdminSettings+0x102>
	 case asInitMenu:
          lcd_clear();
    e452:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  if (IFType==IT_SLAVE){
    e456:	80 91 00 01 	lds	r24, 0x0100
    e45a:	81 30       	cpi	r24, 0x01	; 1
    e45c:	51 f4       	brne	.+20     	; 0xe472 <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
    e45e:	61 e0       	ldi	r22, 0x01	; 1
    e460:	48 ea       	ldi	r20, 0xA8	; 168
    e462:	54 e1       	ldi	r21, 0x14	; 20
    e464:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
    e468:	82 e0       	ldi	r24, 0x02	; 2
    e46a:	61 e0       	ldi	r22, 0x01	; 1
    e46c:	43 e9       	ldi	r20, 0x93	; 147
    e46e:	54 e1       	ldi	r21, 0x14	; 20
    e470:	0c c0       	rjmp	.+24     	; 0xe48a <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
    e472:	82 30       	cpi	r24, 0x02	; 2
    e474:	61 f4       	brne	.+24     	; 0xe48e <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
    e476:	81 e0       	ldi	r24, 0x01	; 1
    e478:	61 e0       	ldi	r22, 0x01	; 1
    e47a:	4e e7       	ldi	r20, 0x7E	; 126
    e47c:	54 e1       	ldi	r21, 0x14	; 20
    e47e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
    e482:	82 e0       	ldi	r24, 0x02	; 2
    e484:	61 e0       	ldi	r22, 0x01	; 1
    e486:	49 e6       	ldi	r20, 0x69	; 105
    e488:	54 e1       	ldi	r21, 0x14	; 20
    e48a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
    e48e:	83 e0       	ldi	r24, 0x03	; 3
    e490:	61 e0       	ldi	r22, 0x01	; 1
    e492:	44 e5       	ldi	r20, 0x54	; 84
    e494:	54 e1       	ldi	r21, 0x14	; 20
    e496:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
    e49a:	84 e0       	ldi	r24, 0x04	; 4
    e49c:	61 e0       	ldi	r22, 0x01	; 1
    e49e:	4d e4       	ldi	r20, 0x4D	; 77
    e4a0:	54 e1       	ldi	r21, 0x14	; 20
    e4a2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
    e4a6:	81 e0       	ldi	r24, 0x01	; 1
    e4a8:	27 c0       	rjmp	.+78     	; 0xe4f8 <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
    e4aa:	81 e0       	ldi	r24, 0x01	; 1
    e4ac:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    e4b0:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    e4b4:	98 2f       	mov	r25, r24
		  switch(KeyChar){
    e4b6:	82 33       	cpi	r24, 0x32	; 50
    e4b8:	61 f0       	breq	.+24     	; 0xe4d2 <FMenuAdminSettings+0xb4>
    e4ba:	83 33       	cpi	r24, 0x33	; 51
    e4bc:	28 f4       	brcc	.+10     	; 0xe4c8 <FMenuAdminSettings+0xaa>
    e4be:	8a 32       	cpi	r24, 0x2A	; 42
    e4c0:	61 f0       	breq	.+24     	; 0xe4da <FMenuAdminSettings+0xbc>
    e4c2:	81 33       	cpi	r24, 0x31	; 49
    e4c4:	69 f4       	brne	.+26     	; 0xe4e0 <FMenuAdminSettings+0xc2>
    e4c6:	03 c0       	rjmp	.+6      	; 0xe4ce <FMenuAdminSettings+0xb0>
    e4c8:	83 33       	cpi	r24, 0x33	; 51
    e4ca:	51 f4       	brne	.+20     	; 0xe4e0 <FMenuAdminSettings+0xc2>
    e4cc:	04 c0       	rjmp	.+8      	; 0xe4d6 <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
    e4ce:	82 e0       	ldi	r24, 0x02	; 2
    e4d0:	05 c0       	rjmp	.+10     	; 0xe4dc <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
    e4d2:	83 e0       	ldi	r24, 0x03	; 3
    e4d4:	03 c0       	rjmp	.+6      	; 0xe4dc <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
    e4d6:	84 e0       	ldi	r24, 0x04	; 4
    e4d8:	01 c0       	rjmp	.+2      	; 0xe4dc <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
    e4da:	87 e0       	ldi	r24, 0x07	; 7
    e4dc:	80 93 47 02 	sts	0x0247, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
    e4e0:	80 91 00 01 	lds	r24, 0x0100
    e4e4:	81 30       	cpi	r24, 0x01	; 1
    e4e6:	01 f5       	brne	.+64     	; 0xe528 <FMenuAdminSettings+0x10a>
			  switch(KeyChar){
    e4e8:	94 33       	cpi	r25, 0x34	; 52
    e4ea:	19 f0       	breq	.+6      	; 0xe4f2 <FMenuAdminSettings+0xd4>
    e4ec:	95 33       	cpi	r25, 0x35	; 53
    e4ee:	e1 f4       	brne	.+56     	; 0xe528 <FMenuAdminSettings+0x10a>
    e4f0:	02 c0       	rjmp	.+4      	; 0xe4f6 <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
    e4f2:	85 e0       	ldi	r24, 0x05	; 5
    e4f4:	01 c0       	rjmp	.+2      	; 0xe4f8 <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
    e4f6:	86 e0       	ldi	r24, 0x06	; 6
    e4f8:	80 93 47 02 	sts	0x0247, r24
    e4fc:	0f c0       	rjmp	.+30     	; 0xe51c <FMenuAdminSettings+0xfe>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
    e4fe:	0e 94 66 70 	call	0xe0cc	; 0xe0cc <FMenuSettingHeader>
    e502:	08 c0       	rjmp	.+16     	; 0xe514 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
    e504:	0e 94 bd 6e 	call	0xdd7a	; 0xdd7a <FMenuSettingFooter>
    e508:	05 c0       	rjmp	.+10     	; 0xe514 <FMenuAdminSettings+0xf6>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
    e50a:	0e 94 d8 57 	call	0xafb0	; 0xafb0 <FMenuSettingClientIP>
    e50e:	02 c0       	rjmp	.+4      	; 0xe514 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
    e510:	0e 94 4f 55 	call	0xaa9e	; 0xaa9e <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
    e514:	81 30       	cpi	r24, 0x01	; 1
    e516:	41 f4       	brne	.+16     	; 0xe528 <FMenuAdminSettings+0x10a>
    e518:	10 92 47 02 	sts	0x0247, r1
    e51c:	80 e0       	ldi	r24, 0x00	; 0
    e51e:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
    e520:	10 92 47 02 	sts	0x0247, r1
    e524:	81 e0       	ldi	r24, 0x01	; 1
    e526:	08 95       	ret
    e528:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    e52a:	08 95       	ret

0000e52c <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
    e52c:	ef 92       	push	r14
    e52e:	ff 92       	push	r15
    e530:	0f 93       	push	r16
    e532:	1f 93       	push	r17
    e534:	df 93       	push	r29
    e536:	cf 93       	push	r28
    e538:	cd b7       	in	r28, 0x3d	; 61
    e53a:	de b7       	in	r29, 0x3e	; 62
    e53c:	e2 97       	sbiw	r28, 0x32	; 50
    e53e:	0f b6       	in	r0, 0x3f	; 63
    e540:	f8 94       	cli
    e542:	de bf       	out	0x3e, r29	; 62
    e544:	0f be       	out	0x3f, r0	; 63
    e546:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
    e548:	80 91 4c 02 	lds	r24, 0x024C
    e54c:	e8 2f       	mov	r30, r24
    e54e:	f0 e0       	ldi	r31, 0x00	; 0
    e550:	e1 31       	cpi	r30, 0x11	; 17
    e552:	f1 05       	cpc	r31, r1
    e554:	08 f0       	brcs	.+2      	; 0xe558 <FMenuMaster+0x2c>
    e556:	ed c1       	rjmp	.+986    	; 0xe932 <FMenuMaster+0x406>
    e558:	ec 59       	subi	r30, 0x9C	; 156
    e55a:	ff 4f       	sbci	r31, 0xFF	; 255
    e55c:	ee 0f       	add	r30, r30
    e55e:	ff 1f       	adc	r31, r31
    e560:	05 90       	lpm	r0, Z+
    e562:	f4 91       	lpm	r31, Z+
    e564:	e0 2d       	mov	r30, r0
    e566:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
    e568:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
    e56c:	81 e0       	ldi	r24, 0x01	; 1
    e56e:	61 e0       	ldi	r22, 0x01	; 1
    e570:	4e e1       	ldi	r20, 0x1E	; 30
    e572:	57 e1       	ldi	r21, 0x17	; 23
    e574:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
    e578:	82 e0       	ldi	r24, 0x02	; 2
    e57a:	61 e0       	ldi	r22, 0x01	; 1
    e57c:	49 e0       	ldi	r20, 0x09	; 9
    e57e:	57 e1       	ldi	r21, 0x17	; 23
    e580:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
    e584:	83 e0       	ldi	r24, 0x03	; 3
    e586:	61 e0       	ldi	r22, 0x01	; 1
    e588:	44 ef       	ldi	r20, 0xF4	; 244
    e58a:	56 e1       	ldi	r21, 0x16	; 22
    e58c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
    e590:	84 e0       	ldi	r24, 0x04	; 4
    e592:	61 e0       	ldi	r22, 0x01	; 1
    e594:	4f ed       	ldi	r20, 0xDF	; 223
    e596:	56 e1       	ldi	r21, 0x16	; 22
    e598:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>

		  //uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
    e59c:	81 e0       	ldi	r24, 0x01	; 1
    e59e:	f3 c0       	rjmp	.+486    	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
    e5a0:	81 e0       	ldi	r24, 0x01	; 1
    e5a2:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    e5a6:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
          switch(KeyChar){
    e5aa:	81 33       	cpi	r24, 0x31	; 49
    e5ac:	09 f4       	brne	.+2      	; 0xe5b0 <FMenuMaster+0x84>
    e5ae:	ea c0       	rjmp	.+468    	; 0xe784 <FMenuMaster+0x258>
    e5b0:	82 33       	cpi	r24, 0x32	; 50
    e5b2:	21 f0       	breq	.+8      	; 0xe5bc <FMenuMaster+0x90>
    e5b4:	8a 32       	cpi	r24, 0x2A	; 42
    e5b6:	09 f0       	breq	.+2      	; 0xe5ba <FMenuMaster+0x8e>
    e5b8:	bc c1       	rjmp	.+888    	; 0xe932 <FMenuMaster+0x406>
    e5ba:	b5 c1       	rjmp	.+874    	; 0xe926 <FMenuMaster+0x3fa>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
    e5bc:	8e e0       	ldi	r24, 0x0E	; 14
    e5be:	e3 c0       	rjmp	.+454    	; 0xe786 <FMenuMaster+0x25a>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
    e5c0:	10 92 4c 02 	sts	0x024C, r1
    e5c4:	b6 c1       	rjmp	.+876    	; 0xe932 <FMenuMaster+0x406>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
    e5c6:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
    e5ca:	81 e0       	ldi	r24, 0x01	; 1
    e5cc:	61 e0       	ldi	r22, 0x01	; 1
    e5ce:	4a ec       	ldi	r20, 0xCA	; 202
    e5d0:	56 e1       	ldi	r21, 0x16	; 22
    e5d2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
    e5d6:	82 e0       	ldi	r24, 0x02	; 2
    e5d8:	61 e0       	ldi	r22, 0x01	; 1
    e5da:	45 eb       	ldi	r20, 0xB5	; 181
    e5dc:	56 e1       	ldi	r21, 0x16	; 22
    e5de:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
    e5e2:	84 e0       	ldi	r24, 0x04	; 4
    e5e4:	64 e0       	ldi	r22, 0x04	; 4
    e5e6:	40 ea       	ldi	r20, 0xA0	; 160
    e5e8:	56 e1       	ldi	r21, 0x16	; 22
    e5ea:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
    e5ee:	00 d0       	rcall	.+0      	; 0xe5f0 <FMenuMaster+0xc4>
    e5f0:	00 d0       	rcall	.+0      	; 0xe5f2 <FMenuMaster+0xc6>
    e5f2:	82 e9       	ldi	r24, 0x92	; 146
    e5f4:	95 e0       	ldi	r25, 0x05	; 5
    e5f6:	ad b7       	in	r26, 0x3d	; 61
    e5f8:	be b7       	in	r27, 0x3e	; 62
    e5fa:	12 96       	adiw	r26, 0x02	; 2
    e5fc:	9c 93       	st	X, r25
    e5fe:	8e 93       	st	-X, r24
    e600:	11 97       	sbiw	r26, 0x01	; 1
    e602:	8f e9       	ldi	r24, 0x9F	; 159
    e604:	96 e1       	ldi	r25, 0x16	; 22
    e606:	14 96       	adiw	r26, 0x04	; 4
    e608:	9c 93       	st	X, r25
    e60a:	8e 93       	st	-X, r24
    e60c:	13 97       	sbiw	r26, 0x03	; 3
    e60e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
    e612:	83 e0       	ldi	r24, 0x03	; 3
    e614:	80 93 4c 02 	sts	0x024C, r24
    e618:	80 e0       	ldi	r24, 0x00	; 0
    e61a:	0f 90       	pop	r0
    e61c:	0f 90       	pop	r0
    e61e:	0f 90       	pop	r0
    e620:	0f 90       	pop	r0
    e622:	88 c1       	rjmp	.+784    	; 0xe934 <FMenuMaster+0x408>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
    e624:	81 e0       	ldi	r24, 0x01	; 1
    e626:	62 e0       	ldi	r22, 0x02	; 2
    e628:	41 e0       	ldi	r20, 0x01	; 1
    e62a:	22 e9       	ldi	r18, 0x92	; 146
    e62c:	35 e0       	ldi	r19, 0x05	; 5
    e62e:	00 e0       	ldi	r16, 0x00	; 0
    e630:	10 e0       	ldi	r17, 0x00	; 0
    e632:	aa e0       	ldi	r26, 0x0A	; 10
    e634:	ea 2e       	mov	r14, r26
    e636:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  switch(uiResult){
    e63a:	83 30       	cpi	r24, 0x03	; 3
    e63c:	49 f0       	breq	.+18     	; 0xe650 <FMenuMaster+0x124>
    e63e:	84 30       	cpi	r24, 0x04	; 4
    e640:	08 f4       	brcc	.+2      	; 0xe644 <FMenuMaster+0x118>
    e642:	ef c0       	rjmp	.+478    	; 0xe822 <FMenuMaster+0x2f6>
    e644:	84 30       	cpi	r24, 0x04	; 4
    e646:	69 f0       	breq	.+26     	; 0xe662 <FMenuMaster+0x136>
    e648:	85 30       	cpi	r24, 0x05	; 5
    e64a:	09 f0       	breq	.+2      	; 0xe64e <FMenuMaster+0x122>
    e64c:	72 c1       	rjmp	.+740    	; 0xe932 <FMenuMaster+0x406>
    e64e:	0e c0       	rjmp	.+28     	; 0xe66c <FMenuMaster+0x140>
		  case USER_OK:
               
			   //uart_printf(1,0,PSTR("GeniusCode: "));
			   //uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
    e650:	80 e0       	ldi	r24, 0x00	; 0
    e652:	6a eb       	ldi	r22, 0xBA	; 186
    e654:	73 e0       	ldi	r23, 0x03	; 3
    e656:	44 e7       	ldi	r20, 0x74	; 116
    e658:	58 e0       	ldi	r21, 0x08	; 8
    e65a:	0e 94 4a a7 	call	0x14e94	; 0x14e94 <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
    e65e:	84 e0       	ldi	r24, 0x04	; 4
    e660:	92 c0       	rjmp	.+292    	; 0xe786 <FMenuMaster+0x25a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    e662:	84 e0       	ldi	r24, 0x04	; 4
    e664:	61 e0       	ldi	r22, 0x01	; 1
    e666:	4a e8       	ldi	r20, 0x8A	; 138
    e668:	56 e1       	ldi	r21, 0x16	; 22
    e66a:	f0 c0       	rjmp	.+480    	; 0xe84c <FMenuMaster+0x320>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e66c:	84 e0       	ldi	r24, 0x04	; 4
    e66e:	61 e0       	ldi	r22, 0x01	; 1
    e670:	45 e7       	ldi	r20, 0x75	; 117
    e672:	56 e1       	ldi	r21, 0x16	; 22
    e674:	eb c0       	rjmp	.+470    	; 0xe84c <FMenuMaster+0x320>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
    e676:	00 d0       	rcall	.+0      	; 0xe678 <FMenuMaster+0x14c>
    e678:	00 d0       	rcall	.+0      	; 0xe67a <FMenuMaster+0x14e>
    e67a:	00 d0       	rcall	.+0      	; 0xe67c <FMenuMaster+0x150>
    e67c:	ed b7       	in	r30, 0x3d	; 61
    e67e:	fe b7       	in	r31, 0x3e	; 62
    e680:	31 96       	adiw	r30, 0x01	; 1
    e682:	8e 01       	movw	r16, r28
    e684:	05 5f       	subi	r16, 0xF5	; 245
    e686:	1f 4f       	sbci	r17, 0xFF	; 255
    e688:	ad b7       	in	r26, 0x3d	; 61
    e68a:	be b7       	in	r27, 0x3e	; 62
    e68c:	12 96       	adiw	r26, 0x02	; 2
    e68e:	1c 93       	st	X, r17
    e690:	0e 93       	st	-X, r16
    e692:	11 97       	sbiw	r26, 0x01	; 1
    e694:	82 e7       	ldi	r24, 0x72	; 114
    e696:	96 e1       	ldi	r25, 0x16	; 22
    e698:	93 83       	std	Z+3, r25	; 0x03
    e69a:	82 83       	std	Z+2, r24	; 0x02
    e69c:	8a eb       	ldi	r24, 0xBA	; 186
    e69e:	93 e0       	ldi	r25, 0x03	; 3
    e6a0:	95 83       	std	Z+5, r25	; 0x05
    e6a2:	84 83       	std	Z+4, r24	; 0x04
    e6a4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  RemoveChar(PDate,'/');
    e6a8:	ed b7       	in	r30, 0x3d	; 61
    e6aa:	fe b7       	in	r31, 0x3e	; 62
    e6ac:	36 96       	adiw	r30, 0x06	; 6
    e6ae:	0f b6       	in	r0, 0x3f	; 63
    e6b0:	f8 94       	cli
    e6b2:	fe bf       	out	0x3e, r31	; 62
    e6b4:	0f be       	out	0x3f, r0	; 63
    e6b6:	ed bf       	out	0x3d, r30	; 61
    e6b8:	c8 01       	movw	r24, r16
    e6ba:	6f e2       	ldi	r22, 0x2F	; 47
    e6bc:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
    e6c0:	c8 01       	movw	r24, r16
    e6c2:	62 e9       	ldi	r22, 0x92	; 146
    e6c4:	75 e0       	ldi	r23, 0x05	; 5
    e6c6:	0e 94 18 55 	call	0xaa30	; 0xaa30 <ValidateGeniusCode>
    e6ca:	81 30       	cpi	r24, 0x01	; 1
    e6cc:	09 f0       	breq	.+2      	; 0xe6d0 <FMenuMaster+0x1a4>
    e6ce:	44 c0       	rjmp	.+136    	; 0xe758 <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
    e6d0:	00 d0       	rcall	.+0      	; 0xe6d2 <FMenuMaster+0x1a6>
    e6d2:	00 d0       	rcall	.+0      	; 0xe6d4 <FMenuMaster+0x1a8>
    e6d4:	00 d0       	rcall	.+0      	; 0xe6d6 <FMenuMaster+0x1aa>
    e6d6:	ed b7       	in	r30, 0x3d	; 61
    e6d8:	fe b7       	in	r31, 0x3e	; 62
    e6da:	31 96       	adiw	r30, 0x01	; 1
    e6dc:	8e 01       	movw	r16, r28
    e6de:	0f 5f       	subi	r16, 0xFF	; 255
    e6e0:	1f 4f       	sbci	r17, 0xFF	; 255
    e6e2:	ad b7       	in	r26, 0x3d	; 61
    e6e4:	be b7       	in	r27, 0x3e	; 62
    e6e6:	12 96       	adiw	r26, 0x02	; 2
    e6e8:	1c 93       	st	X, r17
    e6ea:	0e 93       	st	-X, r16
    e6ec:	11 97       	sbiw	r26, 0x01	; 1
    e6ee:	8f e6       	ldi	r24, 0x6F	; 111
    e6f0:	96 e1       	ldi	r25, 0x16	; 22
    e6f2:	93 83       	std	Z+3, r25	; 0x03
    e6f4:	82 83       	std	Z+2, r24	; 0x02
    e6f6:	84 e7       	ldi	r24, 0x74	; 116
    e6f8:	98 e0       	ldi	r25, 0x08	; 8
    e6fa:	95 83       	std	Z+5, r25	; 0x05
    e6fc:	84 83       	std	Z+4, r24	; 0x04
    e6fe:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
    e702:	ed b7       	in	r30, 0x3d	; 61
    e704:	fe b7       	in	r31, 0x3e	; 62
    e706:	36 96       	adiw	r30, 0x06	; 6
    e708:	0f b6       	in	r0, 0x3f	; 63
    e70a:	f8 94       	cli
    e70c:	fe bf       	out	0x3e, r31	; 62
    e70e:	0f be       	out	0x3f, r0	; 63
    e710:	ed bf       	out	0x3d, r30	; 61
    e712:	c8 01       	movw	r24, r16
    e714:	6a e3       	ldi	r22, 0x3A	; 58
    e716:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <RemoveChar>
    e71a:	00 d0       	rcall	.+0      	; 0xe71c <FMenuMaster+0x1f0>
    e71c:	00 d0       	rcall	.+0      	; 0xe71e <FMenuMaster+0x1f2>
    e71e:	f0 ed       	ldi	r31, 0xD0	; 208
    e720:	ef 2e       	mov	r14, r31
    e722:	f7 e0       	ldi	r31, 0x07	; 7
    e724:	ff 2e       	mov	r15, r31
    e726:	ad b7       	in	r26, 0x3d	; 61
    e728:	be b7       	in	r27, 0x3e	; 62
    e72a:	12 96       	adiw	r26, 0x02	; 2
    e72c:	fc 92       	st	X, r15
    e72e:	ee 92       	st	-X, r14
    e730:	11 97       	sbiw	r26, 0x01	; 1
    e732:	8e e6       	ldi	r24, 0x6E	; 110
    e734:	96 e1       	ldi	r25, 0x16	; 22
    e736:	14 96       	adiw	r26, 0x04	; 4
    e738:	9c 93       	st	X, r25
    e73a:	8e 93       	st	-X, r24
    e73c:	13 97       	sbiw	r26, 0x03	; 3
    e73e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
    e742:	0f 90       	pop	r0
    e744:	0f 90       	pop	r0
    e746:	0f 90       	pop	r0
    e748:	0f 90       	pop	r0
    e74a:	c8 01       	movw	r24, r16
    e74c:	62 e9       	ldi	r22, 0x92	; 146
    e74e:	75 e0       	ldi	r23, 0x05	; 5
    e750:	a7 01       	movw	r20, r14
    e752:	0e 94 61 2f 	call	0x5ec2	; 0x5ec2 <GenerateKeyStamp>
    e756:	d2 c0       	rjmp	.+420    	; 0xe8fc <FMenuMaster+0x3d0>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
    e758:	85 e0       	ldi	r24, 0x05	; 5
    e75a:	15 c0       	rjmp	.+42     	; 0xe786 <FMenuMaster+0x25a>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e75c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e75e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e760:	81 e0       	ldi	r24, 0x01	; 1
    e762:	80 93 bc 01 	sts	0x01BC, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
    e766:	83 e0       	ldi	r24, 0x03	; 3
    e768:	61 e0       	ldi	r22, 0x01	; 1
    e76a:	49 e5       	ldi	r20, 0x59	; 89
    e76c:	56 e1       	ldi	r21, 0x16	; 22
    e76e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          TimDisplay=0; 
    e772:	10 92 92 01 	sts	0x0192, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
    e776:	86 e0       	ldi	r24, 0x06	; 6
    e778:	06 c0       	rjmp	.+12     	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
    e77a:	80 91 92 01 	lds	r24, 0x0192
    e77e:	86 30       	cpi	r24, 0x06	; 6
    e780:	08 f4       	brcc	.+2      	; 0xe784 <FMenuMaster+0x258>
    e782:	d7 c0       	rjmp	.+430    	; 0xe932 <FMenuMaster+0x406>
    e784:	82 e0       	ldi	r24, 0x02	; 2
    e786:	80 93 4c 02 	sts	0x024C, r24
    e78a:	d3 c0       	rjmp	.+422    	; 0xe932 <FMenuMaster+0x406>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
    e78c:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
    e790:	00 d0       	rcall	.+0      	; 0xe792 <FMenuMaster+0x266>
    e792:	00 d0       	rcall	.+0      	; 0xe794 <FMenuMaster+0x268>
    e794:	00 d0       	rcall	.+0      	; 0xe796 <FMenuMaster+0x26a>
    e796:	ed b7       	in	r30, 0x3d	; 61
    e798:	fe b7       	in	r31, 0x3e	; 62
    e79a:	31 96       	adiw	r30, 0x01	; 1
    e79c:	8e 01       	movw	r16, r28
    e79e:	01 5e       	subi	r16, 0xE1	; 225
    e7a0:	1f 4f       	sbci	r17, 0xFF	; 255
    e7a2:	ad b7       	in	r26, 0x3d	; 61
    e7a4:	be b7       	in	r27, 0x3e	; 62
    e7a6:	12 96       	adiw	r26, 0x02	; 2
    e7a8:	1c 93       	st	X, r17
    e7aa:	0e 93       	st	-X, r16
    e7ac:	11 97       	sbiw	r26, 0x01	; 1
    e7ae:	8b e4       	ldi	r24, 0x4B	; 75
    e7b0:	96 e1       	ldi	r25, 0x16	; 22
    e7b2:	93 83       	std	Z+3, r25	; 0x03
    e7b4:	82 83       	std	Z+2, r24	; 0x02
    e7b6:	80 ed       	ldi	r24, 0xD0	; 208
    e7b8:	97 e0       	ldi	r25, 0x07	; 7
    e7ba:	95 83       	std	Z+5, r25	; 0x05
    e7bc:	84 83       	std	Z+4, r24	; 0x04
    e7be:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(1,1,lcdteks);
    e7c2:	ed b7       	in	r30, 0x3d	; 61
    e7c4:	fe b7       	in	r31, 0x3e	; 62
    e7c6:	36 96       	adiw	r30, 0x06	; 6
    e7c8:	0f b6       	in	r0, 0x3f	; 63
    e7ca:	f8 94       	cli
    e7cc:	fe bf       	out	0x3e, r31	; 62
    e7ce:	0f be       	out	0x3f, r0	; 63
    e7d0:	ed bf       	out	0x3d, r30	; 61
    e7d2:	81 e0       	ldi	r24, 0x01	; 1
    e7d4:	61 e0       	ldi	r22, 0x01	; 1
    e7d6:	a8 01       	movw	r20, r16
    e7d8:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
    e7dc:	82 e0       	ldi	r24, 0x02	; 2
    e7de:	61 e0       	ldi	r22, 0x01	; 1
    e7e0:	46 e3       	ldi	r20, 0x36	; 54
    e7e2:	56 e1       	ldi	r21, 0x16	; 22
    e7e4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
    e7e8:	83 e0       	ldi	r24, 0x03	; 3
    e7ea:	61 e0       	ldi	r22, 0x01	; 1
    e7ec:	41 e2       	ldi	r20, 0x21	; 33
    e7ee:	56 e1       	ldi	r21, 0x16	; 22
    e7f0:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e7f4:	84 e0       	ldi	r24, 0x04	; 4
    e7f6:	61 e0       	ldi	r22, 0x01	; 1
    e7f8:	4c e0       	ldi	r20, 0x0C	; 12
    e7fa:	56 e1       	ldi	r21, 0x16	; 22
    e7fc:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
    e800:	88 e0       	ldi	r24, 0x08	; 8
    e802:	c1 cf       	rjmp	.-126    	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
    e804:	81 e0       	ldi	r24, 0x01	; 1
    e806:	63 e0       	ldi	r22, 0x03	; 3
    e808:	41 e0       	ldi	r20, 0x01	; 1
    e80a:	2b e5       	ldi	r18, 0x5B	; 91
    e80c:	3c e0       	ldi	r19, 0x0C	; 12
    e80e:	00 e0       	ldi	r16, 0x00	; 0
    e810:	10 e0       	ldi	r17, 0x00	; 0
    e812:	ea e0       	ldi	r30, 0x0A	; 10
    e814:	ee 2e       	mov	r14, r30
    e816:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  switch(uiResult){
    e81a:	83 30       	cpi	r24, 0x03	; 3
    e81c:	61 f0       	breq	.+24     	; 0xe836 <FMenuMaster+0x30a>
    e81e:	84 30       	cpi	r24, 0x04	; 4
    e820:	20 f4       	brcc	.+8      	; 0xe82a <FMenuMaster+0x2fe>
    e822:	81 30       	cpi	r24, 0x01	; 1
    e824:	09 f0       	breq	.+2      	; 0xe828 <FMenuMaster+0x2fc>
    e826:	85 c0       	rjmp	.+266    	; 0xe932 <FMenuMaster+0x406>
    e828:	7e c0       	rjmp	.+252    	; 0xe926 <FMenuMaster+0x3fa>
    e82a:	84 30       	cpi	r24, 0x04	; 4
    e82c:	31 f0       	breq	.+12     	; 0xe83a <FMenuMaster+0x30e>
    e82e:	85 30       	cpi	r24, 0x05	; 5
    e830:	09 f0       	breq	.+2      	; 0xe834 <FMenuMaster+0x308>
    e832:	7f c0       	rjmp	.+254    	; 0xe932 <FMenuMaster+0x406>
    e834:	07 c0       	rjmp	.+14     	; 0xe844 <FMenuMaster+0x318>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
    e836:	89 e0       	ldi	r24, 0x09	; 9
    e838:	a6 cf       	rjmp	.-180    	; 0xe786 <FMenuMaster+0x25a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    e83a:	84 e0       	ldi	r24, 0x04	; 4
    e83c:	61 e0       	ldi	r22, 0x01	; 1
    e83e:	47 ef       	ldi	r20, 0xF7	; 247
    e840:	55 e1       	ldi	r21, 0x15	; 21
    e842:	04 c0       	rjmp	.+8      	; 0xe84c <FMenuMaster+0x320>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e844:	84 e0       	ldi	r24, 0x04	; 4
    e846:	61 e0       	ldi	r22, 0x01	; 1
    e848:	42 ee       	ldi	r20, 0xE2	; 226
    e84a:	55 e1       	ldi	r21, 0x15	; 21
    e84c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    e850:	70 c0       	rjmp	.+224    	; 0xe932 <FMenuMaster+0x406>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
    e852:	80 ed       	ldi	r24, 0xD0	; 208
    e854:	97 e0       	ldi	r25, 0x07	; 7
    e856:	6b e5       	ldi	r22, 0x5B	; 91
    e858:	7c e0       	ldi	r23, 0x0C	; 12
    e85a:	0e 94 f6 54 	call	0xa9ec	; 0xa9ec <ValidateRestoreCode>
    e85e:	81 30       	cpi	r24, 0x01	; 1
    e860:	11 f4       	brne	.+4      	; 0xe866 <FMenuMaster+0x33a>
		      stMenuMaster=mmRestorePassword;
    e862:	8c e0       	ldi	r24, 0x0C	; 12
    e864:	90 cf       	rjmp	.-224    	; 0xe786 <FMenuMaster+0x25a>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
    e866:	8a e0       	ldi	r24, 0x0A	; 10
    e868:	8e cf       	rjmp	.-228    	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
    e86a:	00 d0       	rcall	.+0      	; 0xe86c <FMenuMaster+0x340>
    e86c:	00 d0       	rcall	.+0      	; 0xe86e <FMenuMaster+0x342>
    e86e:	8e 01       	movw	r16, r28
    e870:	0b 5e       	subi	r16, 0xEB	; 235
    e872:	1f 4f       	sbci	r17, 0xFF	; 255
    e874:	ad b7       	in	r26, 0x3d	; 61
    e876:	be b7       	in	r27, 0x3e	; 62
    e878:	12 96       	adiw	r26, 0x02	; 2
    e87a:	1c 93       	st	X, r17
    e87c:	0e 93       	st	-X, r16
    e87e:	11 97       	sbiw	r26, 0x01	; 1
    e880:	8c ed       	ldi	r24, 0xDC	; 220
    e882:	95 e1       	ldi	r25, 0x15	; 21
    e884:	14 96       	adiw	r26, 0x04	; 4
    e886:	9c 93       	st	X, r25
    e888:	8e 93       	st	-X, r24
    e88a:	13 97       	sbiw	r26, 0x03	; 3
    e88c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    e890:	0f 90       	pop	r0
    e892:	0f 90       	pop	r0
    e894:	0f 90       	pop	r0
    e896:	0f 90       	pop	r0
    e898:	81 e0       	ldi	r24, 0x01	; 1
    e89a:	90 e0       	ldi	r25, 0x00	; 0
    e89c:	b8 01       	movw	r22, r16
    e89e:	4a e0       	ldi	r20, 0x0A	; 10
    e8a0:	50 e0       	ldi	r21, 0x00	; 0
    e8a2:	2c e4       	ldi	r18, 0x4C	; 76
    e8a4:	32 e1       	ldi	r19, 0x12	; 18
    e8a6:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
    e8aa:	00 d0       	rcall	.+0      	; 0xe8ac <FMenuMaster+0x380>
    e8ac:	00 d0       	rcall	.+0      	; 0xe8ae <FMenuMaster+0x382>
    e8ae:	ed b7       	in	r30, 0x3d	; 61
    e8b0:	fe b7       	in	r31, 0x3e	; 62
    e8b2:	12 83       	std	Z+2, r17	; 0x02
    e8b4:	01 83       	std	Z+1, r16	; 0x01
    e8b6:	86 ed       	ldi	r24, 0xD6	; 214
    e8b8:	95 e1       	ldi	r25, 0x15	; 21
    e8ba:	94 83       	std	Z+4, r25	; 0x04
    e8bc:	83 83       	std	Z+3, r24	; 0x03
    e8be:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    e8c2:	0f 90       	pop	r0
    e8c4:	0f 90       	pop	r0
    e8c6:	0f 90       	pop	r0
    e8c8:	0f 90       	pop	r0
    e8ca:	8b e0       	ldi	r24, 0x0B	; 11
    e8cc:	90 e0       	ldi	r25, 0x00	; 0
    e8ce:	b8 01       	movw	r22, r16
    e8d0:	4a e0       	ldi	r20, 0x0A	; 10
    e8d2:	50 e0       	ldi	r21, 0x00	; 0
    e8d4:	2c e4       	ldi	r18, 0x4C	; 76
    e8d6:	32 e1       	ldi	r19, 0x12	; 18
    e8d8:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
    e8dc:	8d e0       	ldi	r24, 0x0D	; 13
    e8de:	53 cf       	rjmp	.-346    	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
    e8e0:	83 e0       	ldi	r24, 0x03	; 3
    e8e2:	61 e0       	ldi	r22, 0x01	; 1
    e8e4:	44 ec       	ldi	r20, 0xC4	; 196
    e8e6:	55 e1       	ldi	r21, 0x15	; 21
    e8e8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  TimDisplay=0;
    e8ec:	10 92 92 01 	sts	0x0192, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
    e8f0:	8b e0       	ldi	r24, 0x0B	; 11
    e8f2:	49 cf       	rjmp	.-366    	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
    e8f4:	80 91 92 01 	lds	r24, 0x0192
    e8f8:	86 30       	cpi	r24, 0x06	; 6
    e8fa:	d8 f0       	brcs	.+54     	; 0xe932 <FMenuMaster+0x406>
    e8fc:	87 e0       	ldi	r24, 0x07	; 7
    e8fe:	43 cf       	rjmp	.-378    	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
    e900:	83 e0       	ldi	r24, 0x03	; 3
    e902:	61 e0       	ldi	r22, 0x01	; 1
    e904:	42 eb       	ldi	r20, 0xB2	; 178
    e906:	55 e1       	ldi	r21, 0x15	; 21
    e908:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e90c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e90e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e910:	81 e0       	ldi	r24, 0x01	; 1
    e912:	80 93 bc 01 	sts	0x01BC, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
    e916:	10 92 92 01 	sts	0x0192, r1
          stMenuMaster=mmDelayExit;
    e91a:	8f e0       	ldi	r24, 0x0F	; 15
    e91c:	34 cf       	rjmp	.-408    	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
    e91e:	80 91 92 01 	lds	r24, 0x0192
    e922:	85 30       	cpi	r24, 0x05	; 5
    e924:	30 f0       	brcs	.+12     	; 0xe932 <FMenuMaster+0x406>
    e926:	80 e1       	ldi	r24, 0x10	; 16
    e928:	2e cf       	rjmp	.-420    	; 0xe786 <FMenuMaster+0x25a>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
    e92a:	10 92 4c 02 	sts	0x024C, r1
    e92e:	81 e0       	ldi	r24, 0x01	; 1
    e930:	01 c0       	rjmp	.+2      	; 0xe934 <FMenuMaster+0x408>
    e932:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
    e934:	e2 96       	adiw	r28, 0x32	; 50
    e936:	0f b6       	in	r0, 0x3f	; 63
    e938:	f8 94       	cli
    e93a:	de bf       	out	0x3e, r29	; 62
    e93c:	0f be       	out	0x3f, r0	; 63
    e93e:	cd bf       	out	0x3d, r28	; 61
    e940:	cf 91       	pop	r28
    e942:	df 91       	pop	r29
    e944:	1f 91       	pop	r17
    e946:	0f 91       	pop	r16
    e948:	ff 90       	pop	r15
    e94a:	ef 90       	pop	r14
    e94c:	08 95       	ret

0000e94e <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
    e94e:	af 92       	push	r10
    e950:	bf 92       	push	r11
    e952:	cf 92       	push	r12
    e954:	df 92       	push	r13
    e956:	ef 92       	push	r14
    e958:	0f 93       	push	r16
    e95a:	1f 93       	push	r17
    e95c:	df 93       	push	r29
    e95e:	cf 93       	push	r28
    e960:	cd b7       	in	r28, 0x3d	; 61
    e962:	de b7       	in	r29, 0x3e	; 62
    e964:	6e 97       	sbiw	r28, 0x1e	; 30
    e966:	0f b6       	in	r0, 0x3f	; 63
    e968:	f8 94       	cli
    e96a:	de bf       	out	0x3e, r29	; 62
    e96c:	0f be       	out	0x3f, r0	; 63
    e96e:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,strPassword[10],PassStatus=MP_NONE;;
       char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];
       char uiResult;

     Result=MP_NONE;
     switch(stMenuPasword){
    e970:	e0 90 58 02 	lds	r14, 0x0258
    e974:	81 e0       	ldi	r24, 0x01	; 1
    e976:	e8 16       	cp	r14, r24
    e978:	01 f1       	breq	.+64     	; 0xe9ba <FMenuPassword+0x6c>
    e97a:	e8 16       	cp	r14, r24
    e97c:	40 f0       	brcs	.+16     	; 0xe98e <FMenuPassword+0x40>
    e97e:	e2 e0       	ldi	r30, 0x02	; 2
    e980:	ee 16       	cp	r14, r30
    e982:	e9 f1       	breq	.+122    	; 0xe9fe <FMenuPassword+0xb0>
    e984:	f3 e0       	ldi	r31, 0x03	; 3
    e986:	ef 16       	cp	r14, r31
    e988:	09 f0       	breq	.+2      	; 0xe98c <FMenuPassword+0x3e>
    e98a:	90 c0       	rjmp	.+288    	; 0xeaac <FMenuPassword+0x15e>
    e98c:	8a c0       	rjmp	.+276    	; 0xeaa2 <FMenuPassword+0x154>
	 case mpInitPassword:
	      lcd_clear();
    e98e:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
    e992:	81 e0       	ldi	r24, 0x01	; 1
    e994:	61 e0       	ldi	r22, 0x01	; 1
    e996:	4f e8       	ldi	r20, 0x8F	; 143
    e998:	57 e1       	ldi	r21, 0x17	; 23
    e99a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
    e99e:	82 e0       	ldi	r24, 0x02	; 2
    e9a0:	61 e0       	ldi	r22, 0x01	; 1
    e9a2:	4d e8       	ldi	r20, 0x8D	; 141
    e9a4:	57 e1       	ldi	r21, 0x17	; 23
    e9a6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e9aa:	84 e0       	ldi	r24, 0x04	; 4
    e9ac:	61 e0       	ldi	r22, 0x01	; 1
    e9ae:	48 e7       	ldi	r20, 0x78	; 120
    e9b0:	57 e1       	ldi	r21, 0x17	; 23
    e9b2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
    e9b6:	81 e0       	ldi	r24, 0x01	; 1
    e9b8:	71 c0       	rjmp	.+226    	; 0xea9c <FMenuPassword+0x14e>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
    e9ba:	84 e0       	ldi	r24, 0x04	; 4
    e9bc:	62 e0       	ldi	r22, 0x02	; 2
    e9be:	41 e0       	ldi	r20, 0x01	; 1
    e9c0:	2e e4       	ldi	r18, 0x4E	; 78
    e9c2:	32 e0       	ldi	r19, 0x02	; 2
    e9c4:	00 e0       	ldi	r16, 0x00	; 0
    e9c6:	10 e0       	ldi	r17, 0x00	; 0
    e9c8:	98 e0       	ldi	r25, 0x08	; 8
    e9ca:	e9 2e       	mov	r14, r25
    e9cc:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		  if (uiResult==USER_OK){
    e9d0:	83 30       	cpi	r24, 0x03	; 3
    e9d2:	11 f4       	brne	.+4      	; 0xe9d8 <FMenuPassword+0x8a>
		      stMenuPasword=mpProcessPassword;
    e9d4:	82 e0       	ldi	r24, 0x02	; 2
    e9d6:	62 c0       	rjmp	.+196    	; 0xea9c <FMenuPassword+0x14e>
			  }
		  else
		  if (uiResult==USER_CANCEL){
    e9d8:	81 30       	cpi	r24, 0x01	; 1
    e9da:	09 f4       	brne	.+2      	; 0xe9de <FMenuPassword+0x90>
    e9dc:	50 c0       	rjmp	.+160    	; 0xea7e <FMenuPassword+0x130>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    e9de:	84 30       	cpi	r24, 0x04	; 4
    e9e0:	21 f4       	brne	.+8      	; 0xe9ea <FMenuPassword+0x9c>
    e9e2:	61 e0       	ldi	r22, 0x01	; 1
    e9e4:	43 e6       	ldi	r20, 0x63	; 99
    e9e6:	57 e1       	ldi	r21, 0x17	; 23
    e9e8:	07 c0       	rjmp	.+14     	; 0xe9f8 <FMenuPassword+0xaa>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    e9ea:	85 30       	cpi	r24, 0x05	; 5
    e9ec:	09 f0       	breq	.+2      	; 0xe9f0 <FMenuPassword+0xa2>
    e9ee:	5e c0       	rjmp	.+188    	; 0xeaac <FMenuPassword+0x15e>
    e9f0:	84 e0       	ldi	r24, 0x04	; 4
    e9f2:	61 e0       	ldi	r22, 0x01	; 1
    e9f4:	4e e4       	ldi	r20, 0x4E	; 78
    e9f6:	57 e1       	ldi	r21, 0x17	; 23
    e9f8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    e9fc:	57 c0       	rjmp	.+174    	; 0xeaac <FMenuPassword+0x15e>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
    e9fe:	00 d0       	rcall	.+0      	; 0xea00 <FMenuPassword+0xb2>
    ea00:	00 d0       	rcall	.+0      	; 0xea02 <FMenuPassword+0xb4>
    ea02:	8e 01       	movw	r16, r28
    ea04:	0f 5f       	subi	r16, 0xFF	; 255
    ea06:	1f 4f       	sbci	r17, 0xFF	; 255
    ea08:	ed b7       	in	r30, 0x3d	; 61
    ea0a:	fe b7       	in	r31, 0x3e	; 62
    ea0c:	12 83       	std	Z+2, r17	; 0x02
    ea0e:	01 83       	std	Z+1, r16	; 0x01
    ea10:	86 e4       	ldi	r24, 0x46	; 70
    ea12:	97 e1       	ldi	r25, 0x17	; 23
    ea14:	94 83       	std	Z+4, r25	; 0x04
    ea16:	83 83       	std	Z+3, r24	; 0x03
    ea18:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ea1c:	0f 90       	pop	r0
    ea1e:	0f 90       	pop	r0
    ea20:	0f 90       	pop	r0
    ea22:	0f 90       	pop	r0
    ea24:	85 e1       	ldi	r24, 0x15	; 21
    ea26:	c8 2e       	mov	r12, r24
    ea28:	d1 2c       	mov	r13, r1
    ea2a:	cc 0e       	add	r12, r28
    ea2c:	dd 1e       	adc	r13, r29
    ea2e:	c6 01       	movw	r24, r12
    ea30:	61 e0       	ldi	r22, 0x01	; 1
    ea32:	70 e0       	ldi	r23, 0x00	; 0
    ea34:	4a e0       	ldi	r20, 0x0A	; 10
    ea36:	50 e0       	ldi	r21, 0x00	; 0
    ea38:	24 e4       	ldi	r18, 0x44	; 68
    ea3a:	32 e1       	ldi	r19, 0x12	; 18
    ea3c:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
    ea40:	bb e0       	ldi	r27, 0x0B	; 11
    ea42:	ab 2e       	mov	r10, r27
    ea44:	b1 2c       	mov	r11, r1
    ea46:	ac 0e       	add	r10, r28
    ea48:	bd 1e       	adc	r11, r29
    ea4a:	c5 01       	movw	r24, r10
    ea4c:	6b e0       	ldi	r22, 0x0B	; 11
    ea4e:	70 e0       	ldi	r23, 0x00	; 0
    ea50:	4a e0       	ldi	r20, 0x0A	; 10
    ea52:	50 e0       	ldi	r21, 0x00	; 0
    ea54:	24 e4       	ldi	r18, 0x44	; 68
    ea56:	32 e1       	ldi	r19, 0x12	; 18
    ea58:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
    ea5c:	c8 01       	movw	r24, r16
    ea5e:	6e e4       	ldi	r22, 0x4E	; 78
    ea60:	72 e0       	ldi	r23, 0x02	; 2
    ea62:	0e 94 e3 a9 	call	0x153c6	; 0x153c6 <strcmp>
    ea66:	00 97       	sbiw	r24, 0x00	; 0
    ea68:	11 f4       	brne	.+4      	; 0xea6e <FMenuPassword+0x120>
		       PassStatus=MP_VALID_MASTER;
    ea6a:	83 e0       	ldi	r24, 0x03	; 3
    ea6c:	08 c0       	rjmp	.+16     	; 0xea7e <FMenuPassword+0x130>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
    ea6e:	c6 01       	movw	r24, r12
    ea70:	6e e4       	ldi	r22, 0x4E	; 78
    ea72:	72 e0       	ldi	r23, 0x02	; 2
    ea74:	0e 94 e3 a9 	call	0x153c6	; 0x153c6 <strcmp>
    ea78:	00 97       	sbiw	r24, 0x00	; 0
    ea7a:	21 f4       	brne	.+8      	; 0xea84 <FMenuPassword+0x136>
		       PassStatus=MP_VALID_ADMIN;
    ea7c:	84 e0       	ldi	r24, 0x04	; 4
    ea7e:	80 93 4d 02 	sts	0x024D, r24
    ea82:	0b c0       	rjmp	.+22     	; 0xea9a <FMenuPassword+0x14c>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
    ea84:	c5 01       	movw	r24, r10
    ea86:	6e e4       	ldi	r22, 0x4E	; 78
    ea88:	72 e0       	ldi	r23, 0x02	; 2
    ea8a:	0e 94 e3 a9 	call	0x153c6	; 0x153c6 <strcmp>
    ea8e:	00 97       	sbiw	r24, 0x00	; 0
    ea90:	11 f4       	brne	.+4      	; 0xea96 <FMenuPassword+0x148>
		       PassStatus=MP_VALID_SYSTEM;
    ea92:	85 e0       	ldi	r24, 0x05	; 5
    ea94:	f4 cf       	rjmp	.-24     	; 0xea7e <FMenuPassword+0x130>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
    ea96:	e0 92 4d 02 	sts	0x024D, r14
		  stMenuPasword=mpExit;
    ea9a:	83 e0       	ldi	r24, 0x03	; 3
    ea9c:	80 93 58 02 	sts	0x0258, r24
    eaa0:	05 c0       	rjmp	.+10     	; 0xeaac <FMenuPassword+0x15e>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
    eaa2:	10 92 58 02 	sts	0x0258, r1
	      Result=PassStatus;
    eaa6:	80 91 4d 02 	lds	r24, 0x024D
    eaaa:	01 c0       	rjmp	.+2      	; 0xeaae <FMenuPassword+0x160>
    eaac:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    eaae:	6e 96       	adiw	r28, 0x1e	; 30
    eab0:	0f b6       	in	r0, 0x3f	; 63
    eab2:	f8 94       	cli
    eab4:	de bf       	out	0x3e, r29	; 62
    eab6:	0f be       	out	0x3f, r0	; 63
    eab8:	cd bf       	out	0x3d, r28	; 61
    eaba:	cf 91       	pop	r28
    eabc:	df 91       	pop	r29
    eabe:	1f 91       	pop	r17
    eac0:	0f 91       	pop	r16
    eac2:	ef 90       	pop	r14
    eac4:	df 90       	pop	r13
    eac6:	cf 90       	pop	r12
    eac8:	bf 90       	pop	r11
    eaca:	af 90       	pop	r10
    eacc:	08 95       	ret

0000eace <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
    eace:	28 2f       	mov	r18, r24
    ead0:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
    ead2:	81 50       	subi	r24, 0x01	; 1
    ead4:	82 30       	cpi	r24, 0x02	; 2
    ead6:	b8 f4       	brcc	.+46     	; 0xeb06 <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    ead8:	62 30       	cpi	r22, 0x02	; 2
    eada:	59 f0       	breq	.+22     	; 0xeaf2 <SetBaudRate+0x24>
    eadc:	62 30       	cpi	r22, 0x02	; 2
    eade:	18 f0       	brcs	.+6      	; 0xeae6 <SetBaudRate+0x18>
    eae0:	63 30       	cpi	r22, 0x03	; 3
    eae2:	21 f4       	brne	.+8      	; 0xeaec <SetBaudRate+0x1e>
    eae4:	09 c0       	rjmp	.+18     	; 0xeaf8 <SetBaudRate+0x2a>
    eae6:	40 e8       	ldi	r20, 0x80	; 128
    eae8:	55 e2       	ldi	r21, 0x25	; 37
    eaea:	08 c0       	rjmp	.+16     	; 0xeafc <SetBaudRate+0x2e>
    eaec:	40 e0       	ldi	r20, 0x00	; 0
    eaee:	50 e0       	ldi	r21, 0x00	; 0
    eaf0:	05 c0       	rjmp	.+10     	; 0xeafc <SetBaudRate+0x2e>
    eaf2:	40 e0       	ldi	r20, 0x00	; 0
    eaf4:	5b e4       	ldi	r21, 0x4B	; 75
    eaf6:	02 c0       	rjmp	.+4      	; 0xeafc <SetBaudRate+0x2e>
    eaf8:	4b e9       	ldi	r20, 0x9B	; 155
    eafa:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      uart_init((ComAddr-1),brValue);
    eafc:	60 e0       	ldi	r22, 0x00	; 0
    eafe:	70 e0       	ldi	r23, 0x00	; 0
    eb00:	0e 94 3b a8 	call	0x15076	; 0x15076 <uart_init>
    eb04:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
    eb06:	82 2f       	mov	r24, r18
    eb08:	83 50       	subi	r24, 0x03	; 3
    eb0a:	82 30       	cpi	r24, 0x02	; 2
    eb0c:	a8 f4       	brcc	.+42     	; 0xeb38 <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
    eb0e:	9f 70       	andi	r25, 0x0F	; 15
    eb10:	62 2f       	mov	r22, r18
    eb12:	62 95       	swap	r22
    eb14:	60 7f       	andi	r22, 0xF0	; 240
    eb16:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
    eb18:	80 91 80 01 	lds	r24, 0x0180
    eb1c:	88 23       	and	r24, r24
    eb1e:	49 f0       	breq	.+18     	; 0xeb32 <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    eb20:	86 e0       	ldi	r24, 0x06	; 6
    eb22:	80 93 a7 05 	sts	0x05A7, r24
	 PoolMsg=plMsg;
    eb26:	60 93 d3 0b 	sts	0x0BD3, r22
     IsControlPooling=True;
    eb2a:	81 e0       	ldi	r24, 0x01	; 1
    eb2c:	80 93 84 01 	sts	0x0184, r24
    eb30:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
    eb32:	86 e0       	ldi	r24, 0x06	; 6
    eb34:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
    eb38:	08 95       	ret

0000eb3a <FSettingSystem>:
	      break;
	 }
     return Result;
}

char FSettingSystem(){
    eb3a:	af 92       	push	r10
    eb3c:	bf 92       	push	r11
    eb3e:	cf 92       	push	r12
    eb40:	df 92       	push	r13
    eb42:	ef 92       	push	r14
    eb44:	ff 92       	push	r15
    eb46:	0f 93       	push	r16
    eb48:	1f 93       	push	r17
    eb4a:	df 93       	push	r29
    eb4c:	cf 93       	push	r28
    eb4e:	cd b7       	in	r28, 0x3d	; 61
    eb50:	de b7       	in	r29, 0x3e	; 62
    eb52:	64 97       	sbiw	r28, 0x14	; 20
    eb54:	0f b6       	in	r0, 0x3f	; 63
    eb56:	f8 94       	cli
    eb58:	de bf       	out	0x3e, r29	; 62
    eb5a:	0f be       	out	0x3f, r0	; 63
    eb5c:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
    eb5e:	80 91 1c 02 	lds	r24, 0x021C
    eb62:	82 30       	cpi	r24, 0x02	; 2
    eb64:	09 f4       	brne	.+2      	; 0xeb68 <FSettingSystem+0x2e>
    eb66:	cf c0       	rjmp	.+414    	; 0xed06 <FSettingSystem+0x1cc>
    eb68:	83 30       	cpi	r24, 0x03	; 3
    eb6a:	30 f4       	brcc	.+12     	; 0xeb78 <FSettingSystem+0x3e>
    eb6c:	88 23       	and	r24, r24
    eb6e:	71 f0       	breq	.+28     	; 0xeb8c <FSettingSystem+0x52>
    eb70:	81 30       	cpi	r24, 0x01	; 1
    eb72:	09 f0       	breq	.+2      	; 0xeb76 <FSettingSystem+0x3c>
    eb74:	6f c1       	rjmp	.+734    	; 0xee54 <FSettingSystem+0x31a>
    eb76:	7f c0       	rjmp	.+254    	; 0xec76 <FSettingSystem+0x13c>
    eb78:	84 30       	cpi	r24, 0x04	; 4
    eb7a:	09 f4       	brne	.+2      	; 0xeb7e <FSettingSystem+0x44>
    eb7c:	60 c1       	rjmp	.+704    	; 0xee3e <FSettingSystem+0x304>
    eb7e:	84 30       	cpi	r24, 0x04	; 4
    eb80:	08 f4       	brcc	.+2      	; 0xeb84 <FSettingSystem+0x4a>
    eb82:	2b c1       	rjmp	.+598    	; 0xedda <FSettingSystem+0x2a0>
    eb84:	85 30       	cpi	r24, 0x05	; 5
    eb86:	09 f0       	breq	.+2      	; 0xeb8a <FSettingSystem+0x50>
    eb88:	65 c1       	rjmp	.+714    	; 0xee54 <FSettingSystem+0x31a>
    eb8a:	60 c1       	rjmp	.+704    	; 0xee4c <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eb8c:	e1 99       	sbic	0x1c, 1	; 28
    eb8e:	fe cf       	rjmp	.-4      	; 0xeb8c <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eb90:	86 e3       	ldi	r24, 0x36	; 54
    eb92:	91 e0       	ldi	r25, 0x01	; 1
    eb94:	9f bb       	out	0x1f, r25	; 31
    eb96:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eb98:	e0 9a       	sbi	0x1c, 0	; 28
    eb9a:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
    eb9c:	20 93 00 01 	sts	0x0100, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eba0:	e1 99       	sbic	0x1c, 1	; 28
    eba2:	fe cf       	rjmp	.-4      	; 0xeba0 <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eba4:	82 ec       	ldi	r24, 0xC2	; 194
    eba6:	93 e0       	ldi	r25, 0x03	; 3
    eba8:	9f bb       	out	0x1f, r25	; 31
    ebaa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ebac:	e0 9a       	sbi	0x1c, 0	; 28
    ebae:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
    ebb0:	22 23       	and	r18, r18
    ebb2:	69 f4       	brne	.+26     	; 0xebce <FSettingSystem+0x94>
    ebb4:	00 d0       	rcall	.+0      	; 0xebb6 <FSettingSystem+0x7c>
    ebb6:	00 d0       	rcall	.+0      	; 0xebb8 <FSettingSystem+0x7e>
    ebb8:	ce 01       	movw	r24, r28
    ebba:	01 96       	adiw	r24, 0x01	; 1
    ebbc:	ad b7       	in	r26, 0x3d	; 61
    ebbe:	be b7       	in	r27, 0x3e	; 62
    ebc0:	12 96       	adiw	r26, 0x02	; 2
    ebc2:	9c 93       	st	X, r25
    ebc4:	8e 93       	st	-X, r24
    ebc6:	11 97       	sbiw	r26, 0x01	; 1
    ebc8:	8b ea       	ldi	r24, 0xAB	; 171
    ebca:	9d e0       	ldi	r25, 0x0D	; 13
    ebcc:	1d c0       	rjmp	.+58     	; 0xec08 <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
    ebce:	21 30       	cpi	r18, 0x01	; 1
    ebd0:	69 f4       	brne	.+26     	; 0xebec <FSettingSystem+0xb2>
    ebd2:	00 d0       	rcall	.+0      	; 0xebd4 <FSettingSystem+0x9a>
    ebd4:	00 d0       	rcall	.+0      	; 0xebd6 <FSettingSystem+0x9c>
    ebd6:	ce 01       	movw	r24, r28
    ebd8:	01 96       	adiw	r24, 0x01	; 1
    ebda:	ed b7       	in	r30, 0x3d	; 61
    ebdc:	fe b7       	in	r31, 0x3e	; 62
    ebde:	92 83       	std	Z+2, r25	; 0x02
    ebe0:	81 83       	std	Z+1, r24	; 0x01
    ebe2:	8e e9       	ldi	r24, 0x9E	; 158
    ebe4:	9d e0       	ldi	r25, 0x0D	; 13
    ebe6:	94 83       	std	Z+4, r25	; 0x04
    ebe8:	83 83       	std	Z+3, r24	; 0x03
    ebea:	12 c0       	rjmp	.+36     	; 0xec10 <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
    ebec:	22 30       	cpi	r18, 0x02	; 2
    ebee:	b1 f4       	brne	.+44     	; 0xec1c <FSettingSystem+0xe2>
    ebf0:	00 d0       	rcall	.+0      	; 0xebf2 <FSettingSystem+0xb8>
    ebf2:	00 d0       	rcall	.+0      	; 0xebf4 <FSettingSystem+0xba>
    ebf4:	ce 01       	movw	r24, r28
    ebf6:	01 96       	adiw	r24, 0x01	; 1
    ebf8:	ad b7       	in	r26, 0x3d	; 61
    ebfa:	be b7       	in	r27, 0x3e	; 62
    ebfc:	12 96       	adiw	r26, 0x02	; 2
    ebfe:	9c 93       	st	X, r25
    ec00:	8e 93       	st	-X, r24
    ec02:	11 97       	sbiw	r26, 0x01	; 1
    ec04:	8c e8       	ldi	r24, 0x8C	; 140
    ec06:	9d e0       	ldi	r25, 0x0D	; 13
    ec08:	14 96       	adiw	r26, 0x04	; 4
    ec0a:	9c 93       	st	X, r25
    ec0c:	8e 93       	st	-X, r24
    ec0e:	13 97       	sbiw	r26, 0x03	; 3
    ec10:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    ec14:	0f 90       	pop	r0
    ec16:	0f 90       	pop	r0
    ec18:	0f 90       	pop	r0
    ec1a:	0f 90       	pop	r0

	      lcd_clear();
    ec1c:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_print(1,1,lcdteks);
    ec20:	81 e0       	ldi	r24, 0x01	; 1
    ec22:	61 e0       	ldi	r22, 0x01	; 1
    ec24:	ae 01       	movw	r20, r28
    ec26:	4f 5f       	subi	r20, 0xFF	; 255
    ec28:	5f 4f       	sbci	r21, 0xFF	; 255
    ec2a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
    ec2e:	82 e0       	ldi	r24, 0x02	; 2
    ec30:	61 e0       	ldi	r22, 0x01	; 1
    ec32:	41 e8       	ldi	r20, 0x81	; 129
    ec34:	5d e0       	ldi	r21, 0x0D	; 13
    ec36:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
    ec3a:	11 23       	and	r17, r17
    ec3c:	29 f4       	brne	.+10     	; 0xec48 <FSettingSystem+0x10e>
    ec3e:	83 e0       	ldi	r24, 0x03	; 3
    ec40:	61 e0       	ldi	r22, 0x01	; 1
    ec42:	46 e7       	ldi	r20, 0x76	; 118
    ec44:	5d e0       	ldi	r21, 0x0D	; 13
    ec46:	0d c0       	rjmp	.+26     	; 0xec62 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
    ec48:	11 30       	cpi	r17, 0x01	; 1
    ec4a:	29 f4       	brne	.+10     	; 0xec56 <FSettingSystem+0x11c>
    ec4c:	83 e0       	ldi	r24, 0x03	; 3
    ec4e:	61 e0       	ldi	r22, 0x01	; 1
    ec50:	4b e6       	ldi	r20, 0x6B	; 107
    ec52:	5d e0       	ldi	r21, 0x0D	; 13
    ec54:	06 c0       	rjmp	.+12     	; 0xec62 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
    ec56:	12 30       	cpi	r17, 0x02	; 2
    ec58:	31 f4       	brne	.+12     	; 0xec66 <FSettingSystem+0x12c>
    ec5a:	83 e0       	ldi	r24, 0x03	; 3
    ec5c:	61 e0       	ldi	r22, 0x01	; 1
    ec5e:	40 e6       	ldi	r20, 0x60	; 96
    ec60:	5d e0       	ldi	r21, 0x0D	; 13
    ec62:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
    ec66:	84 e0       	ldi	r24, 0x04	; 4
    ec68:	61 e0       	ldi	r22, 0x01	; 1
    ec6a:	42 e5       	ldi	r20, 0x52	; 82
    ec6c:	5d e0       	ldi	r21, 0x0D	; 13
    ec6e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stSettingSytem=ssMenuSelect;
    ec72:	81 e0       	ldi	r24, 0x01	; 1
    ec74:	e1 c0       	rjmp	.+450    	; 0xee38 <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
    ec76:	81 e0       	ldi	r24, 0x01	; 1
    ec78:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    ec7c:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  if (KeyChar=='1'){
    ec80:	81 33       	cpi	r24, 0x31	; 49
    ec82:	c1 f4       	brne	.+48     	; 0xecb4 <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
    ec84:	80 91 00 01 	lds	r24, 0x0100
    ec88:	90 e0       	ldi	r25, 0x00	; 0
    ec8a:	01 96       	adiw	r24, 0x01	; 1
    ec8c:	63 e0       	ldi	r22, 0x03	; 3
    ec8e:	70 e0       	ldi	r23, 0x00	; 0
    ec90:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    ec94:	80 93 00 01 	sts	0x0100, r24
			  SendSlaveCommand(IFType,DispenserBrand);
    ec98:	60 91 5e 01 	lds	r22, 0x015E
    ec9c:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
    eca0:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    eca4:	e1 99       	sbic	0x1c, 1	; 28
    eca6:	fe cf       	rjmp	.-4      	; 0xeca4 <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eca8:	86 e3       	ldi	r24, 0x36	; 54
    ecaa:	91 e0       	ldi	r25, 0x01	; 1
    ecac:	9f bb       	out	0x1f, r25	; 31
    ecae:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    ecb0:	2d bb       	out	0x1d, r18	; 29
    ecb2:	1f c0       	rjmp	.+62     	; 0xecf2 <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
    ecb4:	82 33       	cpi	r24, 0x32	; 50
    ecb6:	09 f4       	brne	.+2      	; 0xecba <FSettingSystem+0x180>
    ecb8:	ba c0       	rjmp	.+372    	; 0xee2e <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
    ecba:	83 33       	cpi	r24, 0x33	; 51
    ecbc:	01 f5       	brne	.+64     	; 0xecfe <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ecbe:	e1 99       	sbic	0x1c, 1	; 28
    ecc0:	fe cf       	rjmp	.-4      	; 0xecbe <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ecc2:	42 ec       	ldi	r20, 0xC2	; 194
    ecc4:	e4 2e       	mov	r14, r20
    ecc6:	43 e0       	ldi	r20, 0x03	; 3
    ecc8:	f4 2e       	mov	r15, r20
    ecca:	ff ba       	out	0x1f, r15	; 31
    eccc:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ecce:	e0 9a       	sbi	0x1c, 0	; 28
    ecd0:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
    ecd2:	90 e0       	ldi	r25, 0x00	; 0
    ecd4:	01 96       	adiw	r24, 0x01	; 1
    ecd6:	63 e0       	ldi	r22, 0x03	; 3
    ecd8:	70 e0       	ldi	r23, 0x00	; 0
    ecda:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    ecde:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
    ece0:	81 e2       	ldi	r24, 0x21	; 33
    ece2:	61 2f       	mov	r22, r17
    ece4:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ece8:	e1 99       	sbic	0x1c, 1	; 28
    ecea:	fe cf       	rjmp	.-4      	; 0xece8 <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ecec:	ff ba       	out	0x1f, r15	; 31
    ecee:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
    ecf0:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    ecf2:	0f b6       	in	r0, 0x3f	; 63
    ecf4:	f8 94       	cli
    ecf6:	e2 9a       	sbi	0x1c, 2	; 28
    ecf8:	e1 9a       	sbi	0x1c, 1	; 28
    ecfa:	0f be       	out	0x3f, r0	; 63
    ecfc:	a4 c0       	rjmp	.+328    	; 0xee46 <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
    ecfe:	8a 32       	cpi	r24, 0x2A	; 42
    ed00:	09 f4       	brne	.+2      	; 0xed04 <FSettingSystem+0x1ca>
    ed02:	99 c0       	rjmp	.+306    	; 0xee36 <FSettingSystem+0x2fc>
    ed04:	a7 c0       	rjmp	.+334    	; 0xee54 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
    ed06:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
    ed0a:	81 e0       	ldi	r24, 0x01	; 1
    ed0c:	61 e0       	ldi	r22, 0x01	; 1
    ed0e:	4d e3       	ldi	r20, 0x3D	; 61
    ed10:	5d e0       	ldi	r21, 0x0D	; 13
    ed12:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    ed16:	01 e0       	ldi	r16, 0x01	; 1
    ed18:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
    ed1a:	6e 01       	movw	r12, r28
    ed1c:	08 94       	sec
    ed1e:	c1 1c       	adc	r12, r1
    ed20:	d1 1c       	adc	r13, r1
    ed22:	34 e3       	ldi	r19, 0x34	; 52
    ed24:	a3 2e       	mov	r10, r19
    ed26:	3d e0       	ldi	r19, 0x0D	; 13
    ed28:	b3 2e       	mov	r11, r19
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
    ed2a:	2b e0       	ldi	r18, 0x0B	; 11
    ed2c:	e2 2e       	mov	r14, r18
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
    ed2e:	f0 2e       	mov	r15, r16
    ed30:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ed32:	e1 99       	sbic	0x1c, 1	; 28
    ed34:	fe cf       	rjmp	.-4      	; 0xed32 <FSettingSystem+0x1f8>
    ed36:	c8 01       	movw	r24, r16
    ed38:	81 5c       	subi	r24, 0xC1	; 193
    ed3a:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ed3c:	9f bb       	out	0x1f, r25	; 31
    ed3e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ed40:	e0 9a       	sbi	0x1c, 0	; 28
    ed42:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    ed44:	82 30       	cpi	r24, 0x02	; 2
    ed46:	69 f0       	breq	.+26     	; 0xed62 <FSettingSystem+0x228>
    ed48:	82 30       	cpi	r24, 0x02	; 2
    ed4a:	28 f0       	brcs	.+10     	; 0xed56 <FSettingSystem+0x21c>
    ed4c:	83 30       	cpi	r24, 0x03	; 3
    ed4e:	31 f4       	brne	.+12     	; 0xed5c <FSettingSystem+0x222>
    ed50:	85 eb       	ldi	r24, 0xB5	; 181
    ed52:	9f e2       	ldi	r25, 0x2F	; 47
    ed54:	08 c0       	rjmp	.+16     	; 0xed66 <FSettingSystem+0x22c>
    ed56:	80 e8       	ldi	r24, 0x80	; 128
    ed58:	95 e2       	ldi	r25, 0x25	; 37
    ed5a:	05 c0       	rjmp	.+10     	; 0xed66 <FSettingSystem+0x22c>
    ed5c:	80 e0       	ldi	r24, 0x00	; 0
    ed5e:	90 e0       	ldi	r25, 0x00	; 0
    ed60:	02 c0       	rjmp	.+4      	; 0xed66 <FSettingSystem+0x22c>
    ed62:	80 e0       	ldi	r24, 0x00	; 0
    ed64:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
    ed66:	ed b7       	in	r30, 0x3d	; 61
    ed68:	fe b7       	in	r31, 0x3e	; 62
    ed6a:	38 97       	sbiw	r30, 0x08	; 8
    ed6c:	0f b6       	in	r0, 0x3f	; 63
    ed6e:	f8 94       	cli
    ed70:	fe bf       	out	0x3e, r31	; 62
    ed72:	0f be       	out	0x3f, r0	; 63
    ed74:	ed bf       	out	0x3d, r30	; 61
    ed76:	31 96       	adiw	r30, 0x01	; 1
    ed78:	ad b7       	in	r26, 0x3d	; 61
    ed7a:	be b7       	in	r27, 0x3e	; 62
    ed7c:	12 96       	adiw	r26, 0x02	; 2
    ed7e:	dc 92       	st	X, r13
    ed80:	ce 92       	st	-X, r12
    ed82:	11 97       	sbiw	r26, 0x01	; 1
    ed84:	b3 82       	std	Z+3, r11	; 0x03
    ed86:	a2 82       	std	Z+2, r10	; 0x02
    ed88:	15 83       	std	Z+5, r17	; 0x05
    ed8a:	04 83       	std	Z+4, r16	; 0x04
    ed8c:	97 83       	std	Z+7, r25	; 0x07
    ed8e:	86 83       	std	Z+6, r24	; 0x06
    ed90:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
    ed94:	ed b7       	in	r30, 0x3d	; 61
    ed96:	fe b7       	in	r31, 0x3e	; 62
    ed98:	38 96       	adiw	r30, 0x08	; 8
    ed9a:	0f b6       	in	r0, 0x3f	; 63
    ed9c:	f8 94       	cli
    ed9e:	fe bf       	out	0x3e, r31	; 62
    eda0:	0f be       	out	0x3f, r0	; 63
    eda2:	ed bf       	out	0x3d, r30	; 61
    eda4:	6f 2d       	mov	r22, r15
    eda6:	66 95       	lsr	r22
    eda8:	6e 9d       	mul	r22, r14
    edaa:	b0 01       	movw	r22, r0
    edac:	11 24       	eor	r1, r1
    edae:	6f 5f       	subi	r22, 0xFF	; 255
    edb0:	f1 e0       	ldi	r31, 0x01	; 1
    edb2:	ff 22       	and	r15, r31
    edb4:	8f 2d       	mov	r24, r15
    edb6:	8e 5f       	subi	r24, 0xFE	; 254
    edb8:	a6 01       	movw	r20, r12
    edba:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    edbe:	0f 5f       	subi	r16, 0xFF	; 255
    edc0:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
    edc2:	05 30       	cpi	r16, 0x05	; 5
    edc4:	11 05       	cpc	r17, r1
    edc6:	09 f0       	breq	.+2      	; 0xedca <FSettingSystem+0x290>
    edc8:	b2 cf       	rjmp	.-156    	; 0xed2e <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
    edca:	84 e0       	ldi	r24, 0x04	; 4
    edcc:	61 e0       	ldi	r22, 0x01	; 1
    edce:	47 e2       	ldi	r20, 0x27	; 39
    edd0:	5d e0       	ldi	r21, 0x0D	; 13
    edd2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
    edd6:	83 e0       	ldi	r24, 0x03	; 3
    edd8:	2f c0       	rjmp	.+94     	; 0xee38 <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
    edda:	81 e0       	ldi	r24, 0x01	; 1
    eddc:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    ede0:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    ede4:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
    ede6:	81 53       	subi	r24, 0x31	; 49
    ede8:	84 30       	cpi	r24, 0x04	; 4
    edea:	18 f5       	brcc	.+70     	; 0xee32 <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    edec:	e1 99       	sbic	0x1c, 1	; 28
    edee:	fe cf       	rjmp	.-4      	; 0xedec <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    edf0:	02 2f       	mov	r16, r18
    edf2:	10 e0       	ldi	r17, 0x00	; 0
    edf4:	01 5f       	subi	r16, 0xF1	; 241
    edf6:	1e 4f       	sbci	r17, 0xFE	; 254
    edf8:	1f bb       	out	0x1f, r17	; 31
    edfa:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    edfc:	e0 9a       	sbi	0x1c, 0	; 28
    edfe:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
    ee00:	90 e0       	ldi	r25, 0x00	; 0
    ee02:	01 96       	adiw	r24, 0x01	; 1
    ee04:	63 e0       	ldi	r22, 0x03	; 3
    ee06:	70 e0       	ldi	r23, 0x00	; 0
    ee08:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    ee0c:	f8 2e       	mov	r15, r24
    ee0e:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
    ee10:	82 2f       	mov	r24, r18
    ee12:	80 53       	subi	r24, 0x30	; 48
    ee14:	6f 2d       	mov	r22, r15
    ee16:	0e 94 67 75 	call	0xeace	; 0xeace <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ee1a:	e1 99       	sbic	0x1c, 1	; 28
    ee1c:	fe cf       	rjmp	.-4      	; 0xee1a <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ee1e:	1f bb       	out	0x1f, r17	; 31
    ee20:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    ee22:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
    ee24:	0f b6       	in	r0, 0x3f	; 63
    ee26:	f8 94       	cli
    ee28:	e2 9a       	sbi	0x1c, 2	; 28
    ee2a:	e1 9a       	sbi	0x1c, 1	; 28
    ee2c:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
    ee2e:	82 e0       	ldi	r24, 0x02	; 2
    ee30:	03 c0       	rjmp	.+6      	; 0xee38 <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
    ee32:	2a 32       	cpi	r18, 0x2A	; 42
    ee34:	79 f4       	brne	.+30     	; 0xee54 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
    ee36:	85 e0       	ldi	r24, 0x05	; 5
    ee38:	80 93 1c 02 	sts	0x021C, r24
    ee3c:	0b c0       	rjmp	.+22     	; 0xee54 <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
    ee3e:	0e 94 97 5a 	call	0xb52e	; 0xb52e <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
    ee42:	81 30       	cpi	r24, 0x01	; 1
    ee44:	39 f4       	brne	.+14     	; 0xee54 <FSettingSystem+0x31a>
    ee46:	10 92 1c 02 	sts	0x021C, r1
    ee4a:	04 c0       	rjmp	.+8      	; 0xee54 <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
    ee4c:	10 92 1c 02 	sts	0x021C, r1
    ee50:	81 e0       	ldi	r24, 0x01	; 1
    ee52:	01 c0       	rjmp	.+2      	; 0xee56 <FSettingSystem+0x31c>
    ee54:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
    ee56:	64 96       	adiw	r28, 0x14	; 20
    ee58:	0f b6       	in	r0, 0x3f	; 63
    ee5a:	f8 94       	cli
    ee5c:	de bf       	out	0x3e, r29	; 62
    ee5e:	0f be       	out	0x3f, r0	; 63
    ee60:	cd bf       	out	0x3d, r28	; 61
    ee62:	cf 91       	pop	r28
    ee64:	df 91       	pop	r29
    ee66:	1f 91       	pop	r17
    ee68:	0f 91       	pop	r16
    ee6a:	ff 90       	pop	r15
    ee6c:	ef 90       	pop	r14
    ee6e:	df 90       	pop	r13
    ee70:	cf 90       	pop	r12
    ee72:	bf 90       	pop	r11
    ee74:	af 90       	pop	r10
    ee76:	08 95       	ret

0000ee78 <FMenuSettings>:
char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1;
     char KeyPressed,KeyChar,SubMenu;

     switch(stMenuSettings){
    ee78:	80 91 22 02 	lds	r24, 0x0222
    ee7c:	e8 2f       	mov	r30, r24
    ee7e:	f0 e0       	ldi	r31, 0x00	; 0
    ee80:	e3 31       	cpi	r30, 0x13	; 19
    ee82:	f1 05       	cpc	r31, r1
    ee84:	08 f0       	brcs	.+2      	; 0xee88 <FMenuSettings+0x10>
    ee86:	bf c0       	rjmp	.+382    	; 0xf006 <FMenuSettings+0x18e>
    ee88:	eb 58       	subi	r30, 0x8B	; 139
    ee8a:	ff 4f       	sbci	r31, 0xFF	; 255
    ee8c:	ee 0f       	add	r30, r30
    ee8e:	ff 1f       	adc	r31, r31
    ee90:	05 90       	lpm	r0, Z+
    ee92:	f4 91       	lpm	r31, Z+
    ee94:	e0 2d       	mov	r30, r0
    ee96:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
    ee98:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  PageSetting=1;
    ee9c:	81 e0       	ldi	r24, 0x01	; 1
    ee9e:	80 93 57 01 	sts	0x0157, r24
    eea2:	a9 c0       	rjmp	.+338    	; 0xeff6 <FMenuSettings+0x17e>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
    eea4:	80 91 57 01 	lds	r24, 0x0157
    eea8:	8f 5f       	subi	r24, 0xFF	; 255
    eeaa:	a5 c0       	rjmp	.+330    	; 0xeff6 <FMenuSettings+0x17e>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
    eeac:	81 e0       	ldi	r24, 0x01	; 1
    eeae:	61 e0       	ldi	r22, 0x01	; 1
    eeb0:	4a e2       	ldi	r20, 0x2A	; 42
    eeb2:	52 e1       	ldi	r21, 0x12	; 18
    eeb4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
    eeb8:	82 e0       	ldi	r24, 0x02	; 2
    eeba:	61 e0       	ldi	r22, 0x01	; 1
    eebc:	45 e1       	ldi	r20, 0x15	; 21
    eebe:	52 e1       	ldi	r21, 0x12	; 18
    eec0:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
    eec4:	83 e0       	ldi	r24, 0x03	; 3
    eec6:	61 e0       	ldi	r22, 0x01	; 1
    eec8:	40 e0       	ldi	r20, 0x00	; 0
    eeca:	52 e1       	ldi	r21, 0x12	; 18
    eecc:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
    eed0:	84 e0       	ldi	r24, 0x04	; 4
    eed2:	61 e0       	ldi	r22, 0x01	; 1
    eed4:	4b ee       	ldi	r20, 0xEB	; 235
    eed6:	51 e1       	ldi	r21, 0x11	; 17
    eed8:	16 c0       	rjmp	.+44     	; 0xef06 <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
    eeda:	81 e0       	ldi	r24, 0x01	; 1
    eedc:	61 e0       	ldi	r22, 0x01	; 1
    eede:	46 ed       	ldi	r20, 0xD6	; 214
    eee0:	51 e1       	ldi	r21, 0x11	; 17
    eee2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
    eee6:	82 e0       	ldi	r24, 0x02	; 2
    eee8:	61 e0       	ldi	r22, 0x01	; 1
    eeea:	41 ec       	ldi	r20, 0xC1	; 193
    eeec:	51 e1       	ldi	r21, 0x11	; 17
    eeee:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
    eef2:	83 e0       	ldi	r24, 0x03	; 3
    eef4:	61 e0       	ldi	r22, 0x01	; 1
    eef6:	4c ea       	ldi	r20, 0xAC	; 172
    eef8:	51 e1       	ldi	r21, 0x11	; 17
    eefa:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
    eefe:	84 e0       	ldi	r24, 0x04	; 4
    ef00:	61 e0       	ldi	r22, 0x01	; 1
    ef02:	47 e9       	ldi	r20, 0x97	; 151
    ef04:	51 e1       	ldi	r21, 0x11	; 17
    ef06:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stMenuSettings=msSelection;
    ef0a:	84 e0       	ldi	r24, 0x04	; 4
    ef0c:	74 c0       	rjmp	.+232    	; 0xeff6 <FMenuSettings+0x17e>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
    ef0e:	80 91 57 01 	lds	r24, 0x0157
    ef12:	8c 5f       	subi	r24, 0xFC	; 252
    ef14:	70 c0       	rjmp	.+224    	; 0xeff6 <FMenuSettings+0x17e>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
    ef16:	81 e0       	ldi	r24, 0x01	; 1
    ef18:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    ef1c:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  switch(KeyChar){
    ef20:	84 33       	cpi	r24, 0x34	; 52
    ef22:	d1 f0       	breq	.+52     	; 0xef58 <FMenuSettings+0xe0>
    ef24:	85 33       	cpi	r24, 0x35	; 53
    ef26:	50 f4       	brcc	.+20     	; 0xef3c <FMenuSettings+0xc4>
    ef28:	82 33       	cpi	r24, 0x32	; 50
    ef2a:	91 f0       	breq	.+36     	; 0xef50 <FMenuSettings+0xd8>
    ef2c:	83 33       	cpi	r24, 0x33	; 51
    ef2e:	90 f4       	brcc	.+36     	; 0xef54 <FMenuSettings+0xdc>
    ef30:	8a 32       	cpi	r24, 0x2A	; 42
    ef32:	d1 f0       	breq	.+52     	; 0xef68 <FMenuSettings+0xf0>
    ef34:	81 33       	cpi	r24, 0x31	; 49
    ef36:	09 f0       	breq	.+2      	; 0xef3a <FMenuSettings+0xc2>
    ef38:	66 c0       	rjmp	.+204    	; 0xf006 <FMenuSettings+0x18e>
    ef3a:	08 c0       	rjmp	.+16     	; 0xef4c <FMenuSettings+0xd4>
    ef3c:	86 33       	cpi	r24, 0x36	; 54
    ef3e:	81 f0       	breq	.+32     	; 0xef60 <FMenuSettings+0xe8>
    ef40:	86 33       	cpi	r24, 0x36	; 54
    ef42:	60 f0       	brcs	.+24     	; 0xef5c <FMenuSettings+0xe4>
    ef44:	87 33       	cpi	r24, 0x37	; 55
    ef46:	09 f0       	breq	.+2      	; 0xef4a <FMenuSettings+0xd2>
    ef48:	5e c0       	rjmp	.+188    	; 0xf006 <FMenuSettings+0x18e>
    ef4a:	0c c0       	rjmp	.+24     	; 0xef64 <FMenuSettings+0xec>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
    ef4c:	89 e0       	ldi	r24, 0x09	; 9
    ef4e:	53 c0       	rjmp	.+166    	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
    ef50:	8a e0       	ldi	r24, 0x0A	; 10
    ef52:	51 c0       	rjmp	.+162    	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
    ef54:	8b e0       	ldi	r24, 0x0B	; 11
    ef56:	4f c0       	rjmp	.+158    	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
    ef58:	8c e0       	ldi	r24, 0x0C	; 12
    ef5a:	4d c0       	rjmp	.+154    	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
    ef5c:	8d e0       	ldi	r24, 0x0D	; 13
    ef5e:	4b c0       	rjmp	.+150    	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
    ef60:	8e e0       	ldi	r24, 0x0E	; 14
    ef62:	49 c0       	rjmp	.+146    	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
    ef64:	87 e0       	ldi	r24, 0x07	; 7
    ef66:	47 c0       	rjmp	.+142    	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
    ef68:	82 e1       	ldi	r24, 0x12	; 18
    ef6a:	45 c0       	rjmp	.+138    	; 0xeff6 <FMenuSettings+0x17e>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
    ef6c:	81 e0       	ldi	r24, 0x01	; 1
    ef6e:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    ef72:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  switch(KeyChar){
    ef76:	82 33       	cpi	r24, 0x32	; 50
    ef78:	69 f0       	breq	.+26     	; 0xef94 <FMenuSettings+0x11c>
    ef7a:	83 33       	cpi	r24, 0x33	; 51
    ef7c:	30 f4       	brcc	.+12     	; 0xef8a <FMenuSettings+0x112>
    ef7e:	8a 32       	cpi	r24, 0x2A	; 42
    ef80:	69 f0       	breq	.+26     	; 0xef9c <FMenuSettings+0x124>
    ef82:	81 33       	cpi	r24, 0x31	; 49
    ef84:	09 f0       	breq	.+2      	; 0xef88 <FMenuSettings+0x110>
    ef86:	3f c0       	rjmp	.+126    	; 0xf006 <FMenuSettings+0x18e>
    ef88:	03 c0       	rjmp	.+6      	; 0xef90 <FMenuSettings+0x118>
    ef8a:	83 33       	cpi	r24, 0x33	; 51
    ef8c:	e1 f5       	brne	.+120    	; 0xf006 <FMenuSettings+0x18e>
    ef8e:	04 c0       	rjmp	.+8      	; 0xef98 <FMenuSettings+0x120>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
    ef90:	8f e0       	ldi	r24, 0x0F	; 15
    ef92:	31 c0       	rjmp	.+98     	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
    ef94:	80 e1       	ldi	r24, 0x10	; 16
    ef96:	2f c0       	rjmp	.+94     	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
    ef98:	81 e1       	ldi	r24, 0x11	; 17
    ef9a:	2d c0       	rjmp	.+90     	; 0xeff6 <FMenuSettings+0x17e>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
    ef9c:	88 e0       	ldi	r24, 0x08	; 8
    ef9e:	2b c0       	rjmp	.+86     	; 0xeff6 <FMenuSettings+0x17e>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
    efa0:	80 91 57 01 	lds	r24, 0x0157
    efa4:	82 30       	cpi	r24, 0x02	; 2
    efa6:	d8 f4       	brcc	.+54     	; 0xefde <FMenuSettings+0x166>
    efa8:	8f 5f       	subi	r24, 0xFF	; 255
    efaa:	05 c0       	rjmp	.+10     	; 0xefb6 <FMenuSettings+0x13e>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
    efac:	80 91 57 01 	lds	r24, 0x0157
    efb0:	82 30       	cpi	r24, 0x02	; 2
    efb2:	a8 f0       	brcs	.+42     	; 0xefde <FMenuSettings+0x166>
    efb4:	81 50       	subi	r24, 0x01	; 1
    efb6:	80 93 57 01 	sts	0x0157, r24
    efba:	11 c0       	rjmp	.+34     	; 0xefde <FMenuSettings+0x166>
		  stMenuSettings=msDisplayPage;
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
    efbc:	0e 94 b7 6c 	call	0xd96e	; 0xd96e <FSettingProduct>
    efc0:	18 c0       	rjmp	.+48     	; 0xeff2 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
    efc2:	0e 94 8d 62 	call	0xc51a	; 0xc51a <FSettingPump>
    efc6:	15 c0       	rjmp	.+42     	; 0xeff2 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
    efc8:	0e 94 57 4f 	call	0x9eae	; 0x9eae <FSettingDec>
    efcc:	12 c0       	rjmp	.+36     	; 0xeff2 <FMenuSettings+0x17a>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    efce:	0e 94 cf 51 	call	0xa39e	; 0xa39e <_menu_datetime>
    efd2:	05 c0       	rjmp	.+10     	; 0xefde <FMenuSettings+0x166>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    efd4:	0e 94 5c 4b 	call	0x96b8	; 0x96b8 <_menu_printer>
    efd8:	02 c0       	rjmp	.+4      	; 0xefde <FMenuSettings+0x166>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    efda:	0e 94 b5 49 	call	0x936a	; 0x936a <_menu_host>
	      SubMenu=FSettingPrinter();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
    efde:	81 e0       	ldi	r24, 0x01	; 1
    efe0:	0a c0       	rjmp	.+20     	; 0xeff6 <FMenuSettings+0x17e>
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
    efe2:	0e 94 ca 69 	call	0xd394	; 0xd394 <FSettingOperator>
    efe6:	05 c0       	rjmp	.+10     	; 0xeff2 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
    efe8:	0e 94 9d 75 	call	0xeb3a	; 0xeb3a <FSettingSystem>
    efec:	02 c0       	rjmp	.+4      	; 0xeff2 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
    efee:	0e 94 97 5a 	call	0xb52e	; 0xb52e <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
    eff2:	81 30       	cpi	r24, 0x01	; 1
    eff4:	41 f4       	brne	.+16     	; 0xf006 <FMenuSettings+0x18e>
    eff6:	80 93 22 02 	sts	0x0222, r24
    effa:	80 e0       	ldi	r24, 0x00	; 0
    effc:	08 95       	ret
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
    effe:	10 92 22 02 	sts	0x0222, r1
    f002:	81 e0       	ldi	r24, 0x01	; 1
    f004:	08 95       	ret
    f006:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    f008:	08 95       	ret

0000f00a <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
    f00a:	af 92       	push	r10
    f00c:	bf 92       	push	r11
    f00e:	cf 92       	push	r12
    f010:	df 92       	push	r13
    f012:	ff 92       	push	r15
    f014:	0f 93       	push	r16
    f016:	1f 93       	push	r17
    f018:	df 93       	push	r29
    f01a:	cf 93       	push	r28
    f01c:	cd b7       	in	r28, 0x3d	; 61
    f01e:	de b7       	in	r29, 0x3e	; 62
    f020:	64 97       	sbiw	r28, 0x14	; 20
    f022:	0f b6       	in	r0, 0x3f	; 63
    f024:	f8 94       	cli
    f026:	de bf       	out	0x3e, r29	; 62
    f028:	0f be       	out	0x3f, r0	; 63
    f02a:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
    f02c:	83 e0       	ldi	r24, 0x03	; 3
    f02e:	61 e0       	ldi	r22, 0x01	; 1
    f030:	4d e3       	ldi	r20, 0x3D	; 61
    f032:	5c e1       	ldi	r21, 0x1C	; 28
    f034:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    f038:	01 e0       	ldi	r16, 0x01	; 1
    f03a:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
    f03c:	6e 01       	movw	r12, r28
    f03e:	08 94       	sec
    f040:	c1 1c       	adc	r12, r1
    f042:	d1 1c       	adc	r13, r1
    f044:	59 e2       	ldi	r21, 0x29	; 41
    f046:	a5 2e       	mov	r10, r21
    f048:	5c e1       	ldi	r21, 0x1C	; 28
    f04a:	b5 2e       	mov	r11, r21
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f04c:	e1 99       	sbic	0x1c, 1	; 28
    f04e:	fe cf       	rjmp	.-4      	; 0xf04c <InitComport+0x42>
    f050:	c8 01       	movw	r24, r16
    f052:	81 5c       	subi	r24, 0xC1	; 193
    f054:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f056:	9f bb       	out	0x1f, r25	; 31
    f058:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f05a:	e0 9a       	sbi	0x1c, 0	; 28
    f05c:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    f05e:	22 e0       	ldi	r18, 0x02	; 2
    f060:	f2 16       	cp	r15, r18
    f062:	71 f0       	breq	.+28     	; 0xf080 <InitComport+0x76>
    f064:	f2 16       	cp	r15, r18
    f066:	30 f0       	brcs	.+12     	; 0xf074 <InitComport+0x6a>
    f068:	33 e0       	ldi	r19, 0x03	; 3
    f06a:	f3 16       	cp	r15, r19
    f06c:	31 f4       	brne	.+12     	; 0xf07a <InitComport+0x70>
    f06e:	85 eb       	ldi	r24, 0xB5	; 181
    f070:	9f e2       	ldi	r25, 0x2F	; 47
    f072:	08 c0       	rjmp	.+16     	; 0xf084 <InitComport+0x7a>
    f074:	80 e8       	ldi	r24, 0x80	; 128
    f076:	95 e2       	ldi	r25, 0x25	; 37
    f078:	05 c0       	rjmp	.+10     	; 0xf084 <InitComport+0x7a>
    f07a:	80 e0       	ldi	r24, 0x00	; 0
    f07c:	90 e0       	ldi	r25, 0x00	; 0
    f07e:	02 c0       	rjmp	.+4      	; 0xf084 <InitComport+0x7a>
    f080:	80 e0       	ldi	r24, 0x00	; 0
    f082:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
    f084:	ad b7       	in	r26, 0x3d	; 61
    f086:	be b7       	in	r27, 0x3e	; 62
    f088:	18 97       	sbiw	r26, 0x08	; 8
    f08a:	0f b6       	in	r0, 0x3f	; 63
    f08c:	f8 94       	cli
    f08e:	be bf       	out	0x3e, r27	; 62
    f090:	0f be       	out	0x3f, r0	; 63
    f092:	ad bf       	out	0x3d, r26	; 61
    f094:	ed b7       	in	r30, 0x3d	; 61
    f096:	fe b7       	in	r31, 0x3e	; 62
    f098:	31 96       	adiw	r30, 0x01	; 1
    f09a:	12 96       	adiw	r26, 0x02	; 2
    f09c:	dc 92       	st	X, r13
    f09e:	ce 92       	st	-X, r12
    f0a0:	11 97       	sbiw	r26, 0x01	; 1
    f0a2:	b3 82       	std	Z+3, r11	; 0x03
    f0a4:	a2 82       	std	Z+2, r10	; 0x02
    f0a6:	15 83       	std	Z+5, r17	; 0x05
    f0a8:	04 83       	std	Z+4, r16	; 0x04
    f0aa:	97 83       	std	Z+7, r25	; 0x07
    f0ac:	86 83       	std	Z+6, r24	; 0x06
    f0ae:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 lcd_print(4,1,lcdteks);
    f0b2:	2d b7       	in	r18, 0x3d	; 61
    f0b4:	3e b7       	in	r19, 0x3e	; 62
    f0b6:	28 5f       	subi	r18, 0xF8	; 248
    f0b8:	3f 4f       	sbci	r19, 0xFF	; 255
    f0ba:	0f b6       	in	r0, 0x3f	; 63
    f0bc:	f8 94       	cli
    f0be:	3e bf       	out	0x3e, r19	; 62
    f0c0:	0f be       	out	0x3f, r0	; 63
    f0c2:	2d bf       	out	0x3d, r18	; 61
    f0c4:	84 e0       	ldi	r24, 0x04	; 4
    f0c6:	61 e0       	ldi	r22, 0x01	; 1
    f0c8:	a6 01       	movw	r20, r12
    f0ca:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		 SetBaudRate(i+1,brMap);
    f0ce:	80 2f       	mov	r24, r16
    f0d0:	6f 2d       	mov	r22, r15
    f0d2:	0e 94 67 75 	call	0xeace	; 0xeace <SetBaudRate>
 	     TimDisplay=0;
    f0d6:	10 92 92 01 	sts	0x0192, r1
    f0da:	04 c0       	rjmp	.+8      	; 0xf0e4 <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>1)break;
    f0dc:	80 91 92 01 	lds	r24, 0x0192
    f0e0:	82 30       	cpi	r24, 0x02	; 2
    f0e2:	20 f4       	brcc	.+8      	; 0xf0ec <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
    f0e4:	80 91 92 01 	lds	r24, 0x0192
    f0e8:	82 30       	cpi	r24, 0x02	; 2
    f0ea:	c0 f3       	brcs	.-16     	; 0xf0dc <InitComport+0xd2>
    f0ec:	0f 5f       	subi	r16, 0xFF	; 255
    f0ee:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
    f0f0:	05 30       	cpi	r16, 0x05	; 5
    f0f2:	11 05       	cpc	r17, r1
    f0f4:	09 f0       	breq	.+2      	; 0xf0f8 <InitComport+0xee>
    f0f6:	aa cf       	rjmp	.-172    	; 0xf04c <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>1)break;
		 };

	 }
}
    f0f8:	64 96       	adiw	r28, 0x14	; 20
    f0fa:	0f b6       	in	r0, 0x3f	; 63
    f0fc:	f8 94       	cli
    f0fe:	de bf       	out	0x3e, r29	; 62
    f100:	0f be       	out	0x3f, r0	; 63
    f102:	cd bf       	out	0x3d, r28	; 61
    f104:	cf 91       	pop	r28
    f106:	df 91       	pop	r29
    f108:	1f 91       	pop	r17
    f10a:	0f 91       	pop	r16
    f10c:	ff 90       	pop	r15
    f10e:	df 90       	pop	r13
    f110:	cf 90       	pop	r12
    f112:	bf 90       	pop	r11
    f114:	af 90       	pop	r10
    f116:	08 95       	ret

0000f118 <IFTSendMessage>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void IFTSendMessage(char MsgCode){//<STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode]
    f118:	af 92       	push	r10
    f11a:	bf 92       	push	r11
    f11c:	cf 92       	push	r12
    f11e:	df 92       	push	r13
    f120:	ef 92       	push	r14
    f122:	ff 92       	push	r15
    f124:	0f 93       	push	r16
    f126:	df 93       	push	r29
    f128:	cf 93       	push	r28
    f12a:	cd b7       	in	r28, 0x3d	; 61
    f12c:	de b7       	in	r29, 0x3e	; 62
    f12e:	c0 54       	subi	r28, 0x40	; 64
    f130:	d0 40       	sbci	r29, 0x00	; 0
    f132:	0f b6       	in	r0, 0x3f	; 63
    f134:	f8 94       	cli
    f136:	de bf       	out	0x3e, r29	; 62
    f138:	0f be       	out	0x3f, r0	; 63
    f13a:	cd bf       	out	0x3d, r28	; 61
    f13c:	08 2f       	mov	r16, r24
	 char strSeqNum[3];
	 char ReadIP[4];
	 char strSend[60];

     //STX
     uart(1, 1,0x01);
    f13e:	81 e0       	ldi	r24, 0x01	; 1
    f140:	61 e0       	ldi	r22, 0x01	; 1
    f142:	41 e0       	ldi	r20, 0x01	; 1
    f144:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f148:	e1 99       	sbic	0x1c, 1	; 28
    f14a:	fe cf       	rjmp	.-4      	; 0xf148 <IFTSendMessage+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f14c:	80 e0       	ldi	r24, 0x00	; 0
    f14e:	90 e0       	ldi	r25, 0x00	; 0
    f150:	9f bb       	out	0x1f, r25	; 31
    f152:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f154:	e0 9a       	sbi	0x1c, 0	; 28
    f156:	8d b3       	in	r24, 0x1d	; 29
	 //[IFTID]
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strSend,PSTR("%.2d"),IdIFT);
    f158:	00 d0       	rcall	.+0      	; 0xf15a <IFTSendMessage+0x42>
    f15a:	00 d0       	rcall	.+0      	; 0xf15c <IFTSendMessage+0x44>
    f15c:	00 d0       	rcall	.+0      	; 0xf15e <IFTSendMessage+0x46>
    f15e:	ed b7       	in	r30, 0x3d	; 61
    f160:	fe b7       	in	r31, 0x3e	; 62
    f162:	31 96       	adiw	r30, 0x01	; 1
    f164:	a5 e0       	ldi	r26, 0x05	; 5
    f166:	ca 2e       	mov	r12, r26
    f168:	d1 2c       	mov	r13, r1
    f16a:	cc 0e       	add	r12, r28
    f16c:	dd 1e       	adc	r13, r29
    f16e:	ad b7       	in	r26, 0x3d	; 61
    f170:	be b7       	in	r27, 0x3e	; 62
    f172:	12 96       	adiw	r26, 0x02	; 2
    f174:	dc 92       	st	X, r13
    f176:	ce 92       	st	-X, r12
    f178:	11 97       	sbiw	r26, 0x01	; 1
    f17a:	20 eb       	ldi	r18, 0xB0	; 176
    f17c:	30 e2       	ldi	r19, 0x20	; 32
    f17e:	33 83       	std	Z+3, r19	; 0x03
    f180:	22 83       	std	Z+2, r18	; 0x02
    f182:	64 e6       	ldi	r22, 0x64	; 100
    f184:	0e 94 ec ac 	call	0x159d8	; 0x159d8 <__udivmodqi4>
    f188:	94 83       	std	Z+4, r25	; 0x04
    f18a:	15 82       	std	Z+5, r1	; 0x05
    f18c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 uart_print(1, 0,strSend);
    f190:	8d b7       	in	r24, 0x3d	; 61
    f192:	9e b7       	in	r25, 0x3e	; 62
    f194:	06 96       	adiw	r24, 0x06	; 6
    f196:	0f b6       	in	r0, 0x3f	; 63
    f198:	f8 94       	cli
    f19a:	9e bf       	out	0x3e, r25	; 62
    f19c:	0f be       	out	0x3f, r0	; 63
    f19e:	8d bf       	out	0x3d, r24	; 61
    f1a0:	81 e0       	ldi	r24, 0x01	; 1
    f1a2:	60 e0       	ldi	r22, 0x00	; 0
    f1a4:	a6 01       	movw	r20, r12
    f1a6:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
     //[Seq]
	 SeqNum=((SeqNum+1)%100);
    f1aa:	80 91 ae 01 	lds	r24, 0x01AE
    f1ae:	90 e0       	ldi	r25, 0x00	; 0
    f1b0:	01 96       	adiw	r24, 0x01	; 1
    f1b2:	64 e6       	ldi	r22, 0x64	; 100
    f1b4:	70 e0       	ldi	r23, 0x00	; 0
    f1b6:	0e 94 19 ad 	call	0x15a32	; 0x15a32 <__divmodhi4>
    f1ba:	80 93 ae 01 	sts	0x01AE, r24
	 sprintf_P(strSend,PSTR("%.2d"),SeqNum);	 
    f1be:	00 d0       	rcall	.+0      	; 0xf1c0 <IFTSendMessage+0xa8>
    f1c0:	00 d0       	rcall	.+0      	; 0xf1c2 <IFTSendMessage+0xaa>
    f1c2:	00 d0       	rcall	.+0      	; 0xf1c4 <IFTSendMessage+0xac>
    f1c4:	ed b7       	in	r30, 0x3d	; 61
    f1c6:	fe b7       	in	r31, 0x3e	; 62
    f1c8:	31 96       	adiw	r30, 0x01	; 1
    f1ca:	ad b7       	in	r26, 0x3d	; 61
    f1cc:	be b7       	in	r27, 0x3e	; 62
    f1ce:	12 96       	adiw	r26, 0x02	; 2
    f1d0:	dc 92       	st	X, r13
    f1d2:	ce 92       	st	-X, r12
    f1d4:	11 97       	sbiw	r26, 0x01	; 1
    f1d6:	2b ea       	ldi	r18, 0xAB	; 171
    f1d8:	30 e2       	ldi	r19, 0x20	; 32
    f1da:	33 83       	std	Z+3, r19	; 0x03
    f1dc:	22 83       	std	Z+2, r18	; 0x02
    f1de:	84 83       	std	Z+4, r24	; 0x04
    f1e0:	15 82       	std	Z+5, r1	; 0x05
    f1e2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 uart_print(1, 0,strSend);
    f1e6:	8d b7       	in	r24, 0x3d	; 61
    f1e8:	9e b7       	in	r25, 0x3e	; 62
    f1ea:	06 96       	adiw	r24, 0x06	; 6
    f1ec:	0f b6       	in	r0, 0x3f	; 63
    f1ee:	f8 94       	cli
    f1f0:	9e bf       	out	0x3e, r25	; 62
    f1f2:	0f be       	out	0x3f, r0	; 63
    f1f4:	8d bf       	out	0x3d, r24	; 61
    f1f6:	81 e0       	ldi	r24, 0x01	; 1
    f1f8:	60 e0       	ldi	r22, 0x00	; 0
    f1fa:	a6 01       	movw	r20, r12
    f1fc:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    f200:	7e 01       	movw	r14, r28
    f202:	08 94       	sec
    f204:	e1 1c       	adc	r14, r1
    f206:	f1 1c       	adc	r15, r1
    f208:	c7 01       	movw	r24, r14
    f20a:	68 e2       	ldi	r22, 0x28	; 40
    f20c:	70 e0       	ldi	r23, 0x00	; 0
    f20e:	44 e0       	ldi	r20, 0x04	; 4
    f210:	50 e0       	ldi	r21, 0x00	; 0
    f212:	24 e4       	ldi	r18, 0x44	; 68
    f214:	32 e1       	ldi	r19, 0x12	; 18
    f216:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	 //[ClientIP]
     eeprom_read_block((void*)&ReadIP,(const void*)&DefClientIP,4);
	 sprintf_P(strSend,PSTR("%.3d.%.3d.%.3d.%.3d"),ReadIP[0],ReadIP[1],ReadIP[2],ReadIP[3]);
    f21a:	ad b7       	in	r26, 0x3d	; 61
    f21c:	be b7       	in	r27, 0x3e	; 62
    f21e:	1c 97       	sbiw	r26, 0x0c	; 12
    f220:	0f b6       	in	r0, 0x3f	; 63
    f222:	f8 94       	cli
    f224:	be bf       	out	0x3e, r27	; 62
    f226:	0f be       	out	0x3f, r0	; 63
    f228:	ad bf       	out	0x3d, r26	; 61
    f22a:	ed b7       	in	r30, 0x3d	; 61
    f22c:	fe b7       	in	r31, 0x3e	; 62
    f22e:	31 96       	adiw	r30, 0x01	; 1
    f230:	12 96       	adiw	r26, 0x02	; 2
    f232:	dc 92       	st	X, r13
    f234:	ce 92       	st	-X, r12
    f236:	11 97       	sbiw	r26, 0x01	; 1
    f238:	87 e9       	ldi	r24, 0x97	; 151
    f23a:	90 e2       	ldi	r25, 0x20	; 32
    f23c:	93 83       	std	Z+3, r25	; 0x03
    f23e:	82 83       	std	Z+2, r24	; 0x02
    f240:	89 81       	ldd	r24, Y+1	; 0x01
    f242:	84 83       	std	Z+4, r24	; 0x04
    f244:	15 82       	std	Z+5, r1	; 0x05
    f246:	8a 81       	ldd	r24, Y+2	; 0x02
    f248:	86 83       	std	Z+6, r24	; 0x06
    f24a:	17 82       	std	Z+7, r1	; 0x07
    f24c:	8b 81       	ldd	r24, Y+3	; 0x03
    f24e:	80 87       	std	Z+8, r24	; 0x08
    f250:	11 86       	std	Z+9, r1	; 0x09
    f252:	8c 81       	ldd	r24, Y+4	; 0x04
    f254:	82 87       	std	Z+10, r24	; 0x0a
    f256:	13 86       	std	Z+11, r1	; 0x0b
    f258:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 uart_print(1, 0,strSend);
    f25c:	8d b7       	in	r24, 0x3d	; 61
    f25e:	9e b7       	in	r25, 0x3e	; 62
    f260:	0c 96       	adiw	r24, 0x0c	; 12
    f262:	0f b6       	in	r0, 0x3f	; 63
    f264:	f8 94       	cli
    f266:	9e bf       	out	0x3e, r25	; 62
    f268:	0f be       	out	0x3f, r0	; 63
    f26a:	8d bf       	out	0x3d, r24	; 61
    f26c:	81 e0       	ldi	r24, 0x01	; 1
    f26e:	60 e0       	ldi	r22, 0x00	; 0
    f270:	a6 01       	movw	r20, r12
    f272:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
    f276:	c7 01       	movw	r24, r14
    f278:	6c e2       	ldi	r22, 0x2C	; 44
    f27a:	70 e0       	ldi	r23, 0x00	; 0
    f27c:	44 e0       	ldi	r20, 0x04	; 4
    f27e:	50 e0       	ldi	r21, 0x00	; 0
    f280:	24 e4       	ldi	r18, 0x44	; 68
    f282:	32 e1       	ldi	r19, 0x12	; 18
    f284:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	 //[ServerIP]
     eeprom_read_block((void*)&ReadIP,(const void*)&DefServerIP,4);
	 sprintf_P(strSend,PSTR("%.3d.%.3d.%.3d.%.3d"),ReadIP[0],ReadIP[1],ReadIP[2],ReadIP[3]);
    f288:	ad b7       	in	r26, 0x3d	; 61
    f28a:	be b7       	in	r27, 0x3e	; 62
    f28c:	1c 97       	sbiw	r26, 0x0c	; 12
    f28e:	0f b6       	in	r0, 0x3f	; 63
    f290:	f8 94       	cli
    f292:	be bf       	out	0x3e, r27	; 62
    f294:	0f be       	out	0x3f, r0	; 63
    f296:	ad bf       	out	0x3d, r26	; 61
    f298:	ed b7       	in	r30, 0x3d	; 61
    f29a:	fe b7       	in	r31, 0x3e	; 62
    f29c:	31 96       	adiw	r30, 0x01	; 1
    f29e:	12 96       	adiw	r26, 0x02	; 2
    f2a0:	dc 92       	st	X, r13
    f2a2:	ce 92       	st	-X, r12
    f2a4:	11 97       	sbiw	r26, 0x01	; 1
    f2a6:	83 e8       	ldi	r24, 0x83	; 131
    f2a8:	90 e2       	ldi	r25, 0x20	; 32
    f2aa:	93 83       	std	Z+3, r25	; 0x03
    f2ac:	82 83       	std	Z+2, r24	; 0x02
    f2ae:	89 81       	ldd	r24, Y+1	; 0x01
    f2b0:	84 83       	std	Z+4, r24	; 0x04
    f2b2:	15 82       	std	Z+5, r1	; 0x05
    f2b4:	8a 81       	ldd	r24, Y+2	; 0x02
    f2b6:	86 83       	std	Z+6, r24	; 0x06
    f2b8:	17 82       	std	Z+7, r1	; 0x07
    f2ba:	8b 81       	ldd	r24, Y+3	; 0x03
    f2bc:	80 87       	std	Z+8, r24	; 0x08
    f2be:	11 86       	std	Z+9, r1	; 0x09
    f2c0:	8c 81       	ldd	r24, Y+4	; 0x04
    f2c2:	82 87       	std	Z+10, r24	; 0x0a
    f2c4:	13 86       	std	Z+11, r1	; 0x0b
    f2c6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 uart_print(1, 0,strSend);
    f2ca:	8d b7       	in	r24, 0x3d	; 61
    f2cc:	9e b7       	in	r25, 0x3e	; 62
    f2ce:	0c 96       	adiw	r24, 0x0c	; 12
    f2d0:	0f b6       	in	r0, 0x3f	; 63
    f2d2:	f8 94       	cli
    f2d4:	9e bf       	out	0x3e, r25	; 62
    f2d6:	0f be       	out	0x3f, r0	; 63
    f2d8:	8d bf       	out	0x3d, r24	; 61
    f2da:	81 e0       	ldi	r24, 0x01	; 1
    f2dc:	60 e0       	ldi	r22, 0x00	; 0
    f2de:	a6 01       	movw	r20, r12
    f2e0:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
	 //[MsgCode]
	 sprintf_P(strSend,PSTR("%.2X"),MsgCode);	 
    f2e4:	00 d0       	rcall	.+0      	; 0xf2e6 <IFTSendMessage+0x1ce>
    f2e6:	00 d0       	rcall	.+0      	; 0xf2e8 <IFTSendMessage+0x1d0>
    f2e8:	00 d0       	rcall	.+0      	; 0xf2ea <IFTSendMessage+0x1d2>
    f2ea:	ed b7       	in	r30, 0x3d	; 61
    f2ec:	fe b7       	in	r31, 0x3e	; 62
    f2ee:	31 96       	adiw	r30, 0x01	; 1
    f2f0:	ad b7       	in	r26, 0x3d	; 61
    f2f2:	be b7       	in	r27, 0x3e	; 62
    f2f4:	12 96       	adiw	r26, 0x02	; 2
    f2f6:	dc 92       	st	X, r13
    f2f8:	ce 92       	st	-X, r12
    f2fa:	11 97       	sbiw	r26, 0x01	; 1
    f2fc:	8e e7       	ldi	r24, 0x7E	; 126
    f2fe:	90 e2       	ldi	r25, 0x20	; 32
    f300:	93 83       	std	Z+3, r25	; 0x03
    f302:	82 83       	std	Z+2, r24	; 0x02
    f304:	04 83       	std	Z+4, r16	; 0x04
    f306:	15 82       	std	Z+5, r1	; 0x05
    f308:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 uart_print(1, 0,strSend);
    f30c:	8d b7       	in	r24, 0x3d	; 61
    f30e:	9e b7       	in	r25, 0x3e	; 62
    f310:	06 96       	adiw	r24, 0x06	; 6
    f312:	0f b6       	in	r0, 0x3f	; 63
    f314:	f8 94       	cli
    f316:	9e bf       	out	0x3e, r25	; 62
    f318:	0f be       	out	0x3f, r0	; 63
    f31a:	8d bf       	out	0x3d, r24	; 61
    f31c:	81 e0       	ldi	r24, 0x01	; 1
    f31e:	60 e0       	ldi	r22, 0x00	; 0
    f320:	a6 01       	movw	r20, r12
    f322:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>

     switch(MsgCode){
    f326:	02 33       	cpi	r16, 0x32	; 50
    f328:	09 f4       	brne	.+2      	; 0xf32c <IFTSendMessage+0x214>
    f32a:	7f c0       	rjmp	.+254    	; 0xf42a <IFTSendMessage+0x312>
    f32c:	03 33       	cpi	r16, 0x33	; 51
    f32e:	70 f4       	brcc	.+28     	; 0xf34c <IFTSendMessage+0x234>
    f330:	02 32       	cpi	r16, 0x22	; 34
    f332:	91 f1       	breq	.+100    	; 0xf398 <IFTSendMessage+0x280>
    f334:	03 32       	cpi	r16, 0x23	; 35
    f336:	20 f4       	brcc	.+8      	; 0xf340 <IFTSendMessage+0x228>
    f338:	04 30       	cpi	r16, 0x04	; 4
    f33a:	09 f0       	breq	.+2      	; 0xf33e <IFTSendMessage+0x226>
    f33c:	1d c2       	rjmp	.+1082   	; 0xf778 <IFTSendMessage+0x660>
    f33e:	19 c0       	rjmp	.+50     	; 0xf372 <IFTSendMessage+0x25a>
    f340:	04 32       	cpi	r16, 0x24	; 36
    f342:	d9 f1       	breq	.+118    	; 0xf3ba <IFTSendMessage+0x2a2>
    f344:	08 32       	cpi	r16, 0x28	; 40
    f346:	09 f0       	breq	.+2      	; 0xf34a <IFTSendMessage+0x232>
    f348:	17 c2       	rjmp	.+1070   	; 0xf778 <IFTSendMessage+0x660>
    f34a:	53 c0       	rjmp	.+166    	; 0xf3f2 <IFTSendMessage+0x2da>
    f34c:	00 39       	cpi	r16, 0x90	; 144
    f34e:	09 f4       	brne	.+2      	; 0xf352 <IFTSendMessage+0x23a>
    f350:	78 c1       	rjmp	.+752    	; 0xf642 <IFTSendMessage+0x52a>
    f352:	01 39       	cpi	r16, 0x91	; 145
    f354:	38 f4       	brcc	.+14     	; 0xf364 <IFTSendMessage+0x24c>
    f356:	06 35       	cpi	r16, 0x56	; 86
    f358:	09 f4       	brne	.+2      	; 0xf35c <IFTSendMessage+0x244>
    f35a:	d7 c0       	rjmp	.+430    	; 0xf50a <IFTSendMessage+0x3f2>
    f35c:	08 35       	cpi	r16, 0x58	; 88
    f35e:	09 f0       	breq	.+2      	; 0xf362 <IFTSendMessage+0x24a>
    f360:	0b c2       	rjmp	.+1046   	; 0xf778 <IFTSendMessage+0x660>
    f362:	e8 c0       	rjmp	.+464    	; 0xf534 <IFTSendMessage+0x41c>
    f364:	02 39       	cpi	r16, 0x92	; 146
    f366:	09 f4       	brne	.+2      	; 0xf36a <IFTSendMessage+0x252>
    f368:	8d c1       	rjmp	.+794    	; 0xf684 <IFTSendMessage+0x56c>
    f36a:	08 39       	cpi	r16, 0x98	; 152
    f36c:	09 f0       	breq	.+2      	; 0xf370 <IFTSendMessage+0x258>
    f36e:	04 c2       	rjmp	.+1032   	; 0xf778 <IFTSendMessage+0x660>
    f370:	e0 c1       	rjmp	.+960    	; 0xf732 <IFTSendMessage+0x61a>
	 case MSG_04://Transaction Number
	      sprintf_P(strSend,PSTR("%s"),strTranNo);
    f372:	00 d0       	rcall	.+0      	; 0xf374 <IFTSendMessage+0x25c>
    f374:	00 d0       	rcall	.+0      	; 0xf376 <IFTSendMessage+0x25e>
    f376:	00 d0       	rcall	.+0      	; 0xf378 <IFTSendMessage+0x260>
    f378:	ed b7       	in	r30, 0x3d	; 61
    f37a:	fe b7       	in	r31, 0x3e	; 62
    f37c:	31 96       	adiw	r30, 0x01	; 1
    f37e:	ad b7       	in	r26, 0x3d	; 61
    f380:	be b7       	in	r27, 0x3e	; 62
    f382:	12 96       	adiw	r26, 0x02	; 2
    f384:	dc 92       	st	X, r13
    f386:	ce 92       	st	-X, r12
    f388:	11 97       	sbiw	r26, 0x01	; 1
    f38a:	8b e7       	ldi	r24, 0x7B	; 123
    f38c:	90 e2       	ldi	r25, 0x20	; 32
    f38e:	93 83       	std	Z+3, r25	; 0x03
    f390:	82 83       	std	Z+2, r24	; 0x02
    f392:	87 e8       	ldi	r24, 0x87	; 135
    f394:	9c e0       	ldi	r25, 0x0C	; 12
    f396:	df c1       	rjmp	.+958    	; 0xf756 <IFTSendMessage+0x63e>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_10://No Additional Parameter
	      break;
	 case MSG_22://strCardID
	      UpdateCardID();
    f398:	0e 94 d3 3d 	call	0x7ba6	; 0x7ba6 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s"),strCardID);
    f39c:	00 d0       	rcall	.+0      	; 0xf39e <IFTSendMessage+0x286>
    f39e:	00 d0       	rcall	.+0      	; 0xf3a0 <IFTSendMessage+0x288>
    f3a0:	00 d0       	rcall	.+0      	; 0xf3a2 <IFTSendMessage+0x28a>
    f3a2:	ed b7       	in	r30, 0x3d	; 61
    f3a4:	fe b7       	in	r31, 0x3e	; 62
    f3a6:	31 96       	adiw	r30, 0x01	; 1
    f3a8:	ad b7       	in	r26, 0x3d	; 61
    f3aa:	be b7       	in	r27, 0x3e	; 62
    f3ac:	12 96       	adiw	r26, 0x02	; 2
    f3ae:	dc 92       	st	X, r13
    f3b0:	ce 92       	st	-X, r12
    f3b2:	11 97       	sbiw	r26, 0x01	; 1
    f3b4:	88 e7       	ldi	r24, 0x78	; 120
    f3b6:	90 e2       	ldi	r25, 0x20	; 32
    f3b8:	b8 c0       	rjmp	.+368    	; 0xf52a <IFTSendMessage+0x412>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_24://strCardID, FIP_ID
	      UpdateCardID();
    f3ba:	0e 94 d3 3d 	call	0x7ba6	; 0x7ba6 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strCardID,strFIP_ID);
    f3be:	ad b7       	in	r26, 0x3d	; 61
    f3c0:	be b7       	in	r27, 0x3e	; 62
    f3c2:	18 97       	sbiw	r26, 0x08	; 8
    f3c4:	0f b6       	in	r0, 0x3f	; 63
    f3c6:	f8 94       	cli
    f3c8:	be bf       	out	0x3e, r27	; 62
    f3ca:	0f be       	out	0x3f, r0	; 63
    f3cc:	ad bf       	out	0x3d, r26	; 61
    f3ce:	ed b7       	in	r30, 0x3d	; 61
    f3d0:	fe b7       	in	r31, 0x3e	; 62
    f3d2:	31 96       	adiw	r30, 0x01	; 1
    f3d4:	12 96       	adiw	r26, 0x02	; 2
    f3d6:	dc 92       	st	X, r13
    f3d8:	ce 92       	st	-X, r12
    f3da:	11 97       	sbiw	r26, 0x01	; 1
    f3dc:	83 e7       	ldi	r24, 0x73	; 115
    f3de:	90 e2       	ldi	r25, 0x20	; 32
    f3e0:	93 83       	std	Z+3, r25	; 0x03
    f3e2:	82 83       	std	Z+2, r24	; 0x02
    f3e4:	89 e8       	ldi	r24, 0x89	; 137
    f3e6:	9b e0       	ldi	r25, 0x0B	; 11
    f3e8:	95 83       	std	Z+5, r25	; 0x05
    f3ea:	84 83       	std	Z+4, r24	; 0x04
    f3ec:	89 eb       	ldi	r24, 0xB9	; 185
    f3ee:	97 e0       	ldi	r25, 0x07	; 7
    f3f0:	41 c1       	rjmp	.+642    	; 0xf674 <IFTSendMessage+0x55c>
	      uart_print(1, 0,strSend);
	      break;

	 case MSG_28://strCardID, FIP_ID
	      UpdateCardID();
    f3f2:	0e 94 d3 3d 	call	0x7ba6	; 0x7ba6 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strCardID);
    f3f6:	ad b7       	in	r26, 0x3d	; 61
    f3f8:	be b7       	in	r27, 0x3e	; 62
    f3fa:	18 97       	sbiw	r26, 0x08	; 8
    f3fc:	0f b6       	in	r0, 0x3f	; 63
    f3fe:	f8 94       	cli
    f400:	be bf       	out	0x3e, r27	; 62
    f402:	0f be       	out	0x3f, r0	; 63
    f404:	ad bf       	out	0x3d, r26	; 61
    f406:	ed b7       	in	r30, 0x3d	; 61
    f408:	fe b7       	in	r31, 0x3e	; 62
    f40a:	31 96       	adiw	r30, 0x01	; 1
    f40c:	12 96       	adiw	r26, 0x02	; 2
    f40e:	dc 92       	st	X, r13
    f410:	ce 92       	st	-X, r12
    f412:	11 97       	sbiw	r26, 0x01	; 1
    f414:	8e e6       	ldi	r24, 0x6E	; 110
    f416:	90 e2       	ldi	r25, 0x20	; 32
    f418:	93 83       	std	Z+3, r25	; 0x03
    f41a:	82 83       	std	Z+2, r24	; 0x02
    f41c:	89 eb       	ldi	r24, 0xB9	; 185
    f41e:	97 e0       	ldi	r25, 0x07	; 7
    f420:	95 83       	std	Z+5, r25	; 0x05
    f422:	84 83       	std	Z+4, r24	; 0x04
    f424:	89 e8       	ldi	r24, 0x89	; 137
    f426:	9b e0       	ldi	r25, 0x0B	; 11
    f428:	25 c1       	rjmp	.+586    	; 0xf674 <IFTSendMessage+0x55c>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_32://Change MOP
	      UpdateCardID();
    f42a:	0e 94 d3 3d 	call	0x7ba6	; 0x7ba6 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strPaymentType);
    f42e:	ad b7       	in	r26, 0x3d	; 61
    f430:	be b7       	in	r27, 0x3e	; 62
    f432:	18 97       	sbiw	r26, 0x08	; 8
    f434:	0f b6       	in	r0, 0x3f	; 63
    f436:	f8 94       	cli
    f438:	be bf       	out	0x3e, r27	; 62
    f43a:	0f be       	out	0x3f, r0	; 63
    f43c:	ad bf       	out	0x3d, r26	; 61
    f43e:	ed b7       	in	r30, 0x3d	; 61
    f440:	fe b7       	in	r31, 0x3e	; 62
    f442:	31 96       	adiw	r30, 0x01	; 1
    f444:	12 96       	adiw	r26, 0x02	; 2
    f446:	dc 92       	st	X, r13
    f448:	ce 92       	st	-X, r12
    f44a:	11 97       	sbiw	r26, 0x01	; 1
    f44c:	89 e6       	ldi	r24, 0x69	; 105
    f44e:	90 e2       	ldi	r25, 0x20	; 32
    f450:	93 83       	std	Z+3, r25	; 0x03
    f452:	82 83       	std	Z+2, r24	; 0x02
    f454:	89 eb       	ldi	r24, 0xB9	; 185
    f456:	97 e0       	ldi	r25, 0x07	; 7
    f458:	95 83       	std	Z+5, r25	; 0x05
    f45a:	84 83       	std	Z+4, r24	; 0x04
    f45c:	80 e5       	ldi	r24, 0x50	; 80
    f45e:	97 e0       	ldi	r25, 0x07	; 7
    f460:	97 83       	std	Z+7, r25	; 0x07
    f462:	86 83       	std	Z+6, r24	; 0x06
    f464:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	      uart_print(1,0,strSend);
    f468:	8d b7       	in	r24, 0x3d	; 61
    f46a:	9e b7       	in	r25, 0x3e	; 62
    f46c:	08 96       	adiw	r24, 0x08	; 8
    f46e:	0f b6       	in	r0, 0x3f	; 63
    f470:	f8 94       	cli
    f472:	9e bf       	out	0x3e, r25	; 62
    f474:	0f be       	out	0x3f, r0	; 63
    f476:	8d bf       	out	0x3d, r24	; 61
    f478:	81 e0       	ldi	r24, 0x01	; 1
    f47a:	60 e0       	ldi	r22, 0x00	; 0
    f47c:	a6 01       	movw	r20, r12
    f47e:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
		  sprintf_P(strSend,PSTR("%s%s"),strRef1,strRef2);
    f482:	ad b7       	in	r26, 0x3d	; 61
    f484:	be b7       	in	r27, 0x3e	; 62
    f486:	18 97       	sbiw	r26, 0x08	; 8
    f488:	0f b6       	in	r0, 0x3f	; 63
    f48a:	f8 94       	cli
    f48c:	be bf       	out	0x3e, r27	; 62
    f48e:	0f be       	out	0x3f, r0	; 63
    f490:	ad bf       	out	0x3d, r26	; 61
    f492:	ed b7       	in	r30, 0x3d	; 61
    f494:	fe b7       	in	r31, 0x3e	; 62
    f496:	31 96       	adiw	r30, 0x01	; 1
    f498:	12 96       	adiw	r26, 0x02	; 2
    f49a:	dc 92       	st	X, r13
    f49c:	ce 92       	st	-X, r12
    f49e:	11 97       	sbiw	r26, 0x01	; 1
    f4a0:	84 e6       	ldi	r24, 0x64	; 100
    f4a2:	90 e2       	ldi	r25, 0x20	; 32
    f4a4:	93 83       	std	Z+3, r25	; 0x03
    f4a6:	82 83       	std	Z+2, r24	; 0x02
    f4a8:	8e e8       	ldi	r24, 0x8E	; 142
    f4aa:	9c e0       	ldi	r25, 0x0C	; 12
    f4ac:	95 83       	std	Z+5, r25	; 0x05
    f4ae:	84 83       	std	Z+4, r24	; 0x04
    f4b0:	8e e9       	ldi	r24, 0x9E	; 158
    f4b2:	9b e0       	ldi	r25, 0x0B	; 11
    f4b4:	97 83       	std	Z+7, r25	; 0x07
    f4b6:	86 83       	std	Z+6, r24	; 0x06
    f4b8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  uart_print(1,0,strSend);
    f4bc:	8d b7       	in	r24, 0x3d	; 61
    f4be:	9e b7       	in	r25, 0x3e	; 62
    f4c0:	08 96       	adiw	r24, 0x08	; 8
    f4c2:	0f b6       	in	r0, 0x3f	; 63
    f4c4:	f8 94       	cli
    f4c6:	9e bf       	out	0x3e, r25	; 62
    f4c8:	0f be       	out	0x3f, r0	; 63
    f4ca:	8d bf       	out	0x3d, r24	; 61
    f4cc:	81 e0       	ldi	r24, 0x01	; 1
    f4ce:	60 e0       	ldi	r22, 0x00	; 0
    f4d0:	a6 01       	movw	r20, r12
    f4d2:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
		  sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    f4d6:	ad b7       	in	r26, 0x3d	; 61
    f4d8:	be b7       	in	r27, 0x3e	; 62
    f4da:	18 97       	sbiw	r26, 0x08	; 8
    f4dc:	0f b6       	in	r0, 0x3f	; 63
    f4de:	f8 94       	cli
    f4e0:	be bf       	out	0x3e, r27	; 62
    f4e2:	0f be       	out	0x3f, r0	; 63
    f4e4:	ad bf       	out	0x3d, r26	; 61
    f4e6:	ed b7       	in	r30, 0x3d	; 61
    f4e8:	fe b7       	in	r31, 0x3e	; 62
    f4ea:	31 96       	adiw	r30, 0x01	; 1
    f4ec:	12 96       	adiw	r26, 0x02	; 2
    f4ee:	dc 92       	st	X, r13
    f4f0:	ce 92       	st	-X, r12
    f4f2:	11 97       	sbiw	r26, 0x01	; 1
    f4f4:	8f e5       	ldi	r24, 0x5F	; 95
    f4f6:	90 e2       	ldi	r25, 0x20	; 32
    f4f8:	93 83       	std	Z+3, r25	; 0x03
    f4fa:	82 83       	std	Z+2, r24	; 0x02
    f4fc:	8d e7       	ldi	r24, 0x7D	; 125
    f4fe:	98 e0       	ldi	r25, 0x08	; 8
    f500:	95 83       	std	Z+5, r25	; 0x05
    f502:	84 83       	std	Z+4, r24	; 0x04
    f504:	85 ea       	ldi	r24, 0xA5	; 165
    f506:	93 e0       	ldi	r25, 0x03	; 3
    f508:	b5 c0       	rjmp	.+362    	; 0xf674 <IFTSendMessage+0x55c>
		  uart_print(1,0,strSend);
	      break;

	 case MSG_56://strCardID, FIP_ID
	      UpdateCardID();
    f50a:	0e 94 d3 3d 	call	0x7ba6	; 0x7ba6 <UpdateCardID>
	      sprintf_P(strSend,PSTR("%s"),strCardID);
    f50e:	00 d0       	rcall	.+0      	; 0xf510 <IFTSendMessage+0x3f8>
    f510:	00 d0       	rcall	.+0      	; 0xf512 <IFTSendMessage+0x3fa>
    f512:	00 d0       	rcall	.+0      	; 0xf514 <IFTSendMessage+0x3fc>
    f514:	ed b7       	in	r30, 0x3d	; 61
    f516:	fe b7       	in	r31, 0x3e	; 62
    f518:	31 96       	adiw	r30, 0x01	; 1
    f51a:	ad b7       	in	r26, 0x3d	; 61
    f51c:	be b7       	in	r27, 0x3e	; 62
    f51e:	12 96       	adiw	r26, 0x02	; 2
    f520:	dc 92       	st	X, r13
    f522:	ce 92       	st	-X, r12
    f524:	11 97       	sbiw	r26, 0x01	; 1
    f526:	8c e5       	ldi	r24, 0x5C	; 92
    f528:	90 e2       	ldi	r25, 0x20	; 32
    f52a:	93 83       	std	Z+3, r25	; 0x03
    f52c:	82 83       	std	Z+2, r24	; 0x02
    f52e:	89 e8       	ldi	r24, 0x89	; 137
    f530:	9b e0       	ldi	r25, 0x0B	; 11
    f532:	11 c1       	rjmp	.+546    	; 0xf756 <IFTSendMessage+0x63e>
	      uart_print(1, 0,strSend);
	      break;
	 case MSG_58://Request Local Account Transaction
	      UpdateCardID();
    f534:	0e 94 d3 3d 	call	0x7ba6	; 0x7ba6 <UpdateCardID>
		  AddSpaceLead(strBalanceValue,13);
    f538:	7f e1       	ldi	r23, 0x1F	; 31
    f53a:	a7 2e       	mov	r10, r23
    f53c:	7c e0       	ldi	r23, 0x0C	; 12
    f53e:	b7 2e       	mov	r11, r23
    f540:	c5 01       	movw	r24, r10
    f542:	6d e0       	ldi	r22, 0x0D	; 13
    f544:	0e 94 5f 2b 	call	0x56be	; 0x56be <AddSpaceLead>
		  AddSpaceLead(strOdometer,10);
    f548:	63 ec       	ldi	r22, 0xC3	; 195
    f54a:	e6 2e       	mov	r14, r22
    f54c:	63 e0       	ldi	r22, 0x03	; 3
    f54e:	f6 2e       	mov	r15, r22
    f550:	c7 01       	movw	r24, r14
    f552:	6a e0       	ldi	r22, 0x0A	; 10
    f554:	0e 94 5f 2b 	call	0x56be	; 0x56be <AddSpaceLead>
		  CardType=0;
    f558:	10 92 89 03 	sts	0x0389, r1
		  sprintf_P(strSend,PSTR("%s%s%d"),strCardID,strFIP_ID,NozzleID);
    f55c:	ad b7       	in	r26, 0x3d	; 61
    f55e:	be b7       	in	r27, 0x3e	; 62
    f560:	1a 97       	sbiw	r26, 0x0a	; 10
    f562:	0f b6       	in	r0, 0x3f	; 63
    f564:	f8 94       	cli
    f566:	be bf       	out	0x3e, r27	; 62
    f568:	0f be       	out	0x3f, r0	; 63
    f56a:	ad bf       	out	0x3d, r26	; 61
    f56c:	ed b7       	in	r30, 0x3d	; 61
    f56e:	fe b7       	in	r31, 0x3e	; 62
    f570:	31 96       	adiw	r30, 0x01	; 1
    f572:	12 96       	adiw	r26, 0x02	; 2
    f574:	dc 92       	st	X, r13
    f576:	ce 92       	st	-X, r12
    f578:	11 97       	sbiw	r26, 0x01	; 1
    f57a:	85 e5       	ldi	r24, 0x55	; 85
    f57c:	90 e2       	ldi	r25, 0x20	; 32
    f57e:	93 83       	std	Z+3, r25	; 0x03
    f580:	82 83       	std	Z+2, r24	; 0x02
    f582:	89 e8       	ldi	r24, 0x89	; 137
    f584:	9b e0       	ldi	r25, 0x0B	; 11
    f586:	95 83       	std	Z+5, r25	; 0x05
    f588:	84 83       	std	Z+4, r24	; 0x04
    f58a:	89 eb       	ldi	r24, 0xB9	; 185
    f58c:	97 e0       	ldi	r25, 0x07	; 7
    f58e:	97 83       	std	Z+7, r25	; 0x07
    f590:	86 83       	std	Z+6, r24	; 0x06
    f592:	80 91 6d 07 	lds	r24, 0x076D
    f596:	80 87       	std	Z+8, r24	; 0x08
    f598:	11 86       	std	Z+9, r1	; 0x09
    f59a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  uart_print(1,0,strSend);
    f59e:	8d b7       	in	r24, 0x3d	; 61
    f5a0:	9e b7       	in	r25, 0x3e	; 62
    f5a2:	0a 96       	adiw	r24, 0x0a	; 10
    f5a4:	0f b6       	in	r0, 0x3f	; 63
    f5a6:	f8 94       	cli
    f5a8:	9e bf       	out	0x3e, r25	; 62
    f5aa:	0f be       	out	0x3f, r0	; 63
    f5ac:	8d bf       	out	0x3d, r24	; 61
    f5ae:	81 e0       	ldi	r24, 0x01	; 1
    f5b0:	60 e0       	ldi	r22, 0x00	; 0
    f5b2:	a6 01       	movw	r20, r12
    f5b4:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
		  sprintf_P(strSend,PSTR("%s%s%d"),strBalanceType,strBalanceValue,CardType);
    f5b8:	ad b7       	in	r26, 0x3d	; 61
    f5ba:	be b7       	in	r27, 0x3e	; 62
    f5bc:	1a 97       	sbiw	r26, 0x0a	; 10
    f5be:	0f b6       	in	r0, 0x3f	; 63
    f5c0:	f8 94       	cli
    f5c2:	be bf       	out	0x3e, r27	; 62
    f5c4:	0f be       	out	0x3f, r0	; 63
    f5c6:	ad bf       	out	0x3d, r26	; 61
    f5c8:	ed b7       	in	r30, 0x3d	; 61
    f5ca:	fe b7       	in	r31, 0x3e	; 62
    f5cc:	31 96       	adiw	r30, 0x01	; 1
    f5ce:	12 96       	adiw	r26, 0x02	; 2
    f5d0:	dc 92       	st	X, r13
    f5d2:	ce 92       	st	-X, r12
    f5d4:	11 97       	sbiw	r26, 0x01	; 1
    f5d6:	8e e4       	ldi	r24, 0x4E	; 78
    f5d8:	90 e2       	ldi	r25, 0x20	; 32
    f5da:	93 83       	std	Z+3, r25	; 0x03
    f5dc:	82 83       	std	Z+2, r24	; 0x02
    f5de:	83 ea       	ldi	r24, 0xA3	; 163
    f5e0:	93 e0       	ldi	r25, 0x03	; 3
    f5e2:	95 83       	std	Z+5, r25	; 0x05
    f5e4:	84 83       	std	Z+4, r24	; 0x04
    f5e6:	b7 82       	std	Z+7, r11	; 0x07
    f5e8:	a6 82       	std	Z+6, r10	; 0x06
    f5ea:	80 91 89 03 	lds	r24, 0x0389
    f5ee:	80 87       	std	Z+8, r24	; 0x08
    f5f0:	11 86       	std	Z+9, r1	; 0x09
    f5f2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  uart_print(1,0,strSend);
    f5f6:	8d b7       	in	r24, 0x3d	; 61
    f5f8:	9e b7       	in	r25, 0x3e	; 62
    f5fa:	0a 96       	adiw	r24, 0x0a	; 10
    f5fc:	0f b6       	in	r0, 0x3f	; 63
    f5fe:	f8 94       	cli
    f600:	9e bf       	out	0x3e, r25	; 62
    f602:	0f be       	out	0x3f, r0	; 63
    f604:	8d bf       	out	0x3d, r24	; 61
    f606:	81 e0       	ldi	r24, 0x01	; 1
    f608:	60 e0       	ldi	r22, 0x00	; 0
    f60a:	a6 01       	movw	r20, r12
    f60c:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
		  uart_printf(1,0,PSTR("F0000000E123456FFFFF"));
    f610:	81 e0       	ldi	r24, 0x01	; 1
    f612:	60 e0       	ldi	r22, 0x00	; 0
    f614:	49 e3       	ldi	r20, 0x39	; 57
    f616:	50 e2       	ldi	r21, 0x20	; 32
    f618:	0e 94 93 a8 	call	0x15126	; 0x15126 <uart_printf>
		  sprintf_P(strSend,PSTR("%s"),strOdometer);
    f61c:	00 d0       	rcall	.+0      	; 0xf61e <IFTSendMessage+0x506>
    f61e:	00 d0       	rcall	.+0      	; 0xf620 <IFTSendMessage+0x508>
    f620:	00 d0       	rcall	.+0      	; 0xf622 <IFTSendMessage+0x50a>
    f622:	ed b7       	in	r30, 0x3d	; 61
    f624:	fe b7       	in	r31, 0x3e	; 62
    f626:	31 96       	adiw	r30, 0x01	; 1
    f628:	ad b7       	in	r26, 0x3d	; 61
    f62a:	be b7       	in	r27, 0x3e	; 62
    f62c:	12 96       	adiw	r26, 0x02	; 2
    f62e:	dc 92       	st	X, r13
    f630:	ce 92       	st	-X, r12
    f632:	11 97       	sbiw	r26, 0x01	; 1
    f634:	86 e3       	ldi	r24, 0x36	; 54
    f636:	90 e2       	ldi	r25, 0x20	; 32
    f638:	93 83       	std	Z+3, r25	; 0x03
    f63a:	82 83       	std	Z+2, r24	; 0x02
    f63c:	f5 82       	std	Z+5, r15	; 0x05
    f63e:	e4 82       	std	Z+4, r14	; 0x04
    f640:	8c c0       	rjmp	.+280    	; 0xf75a <IFTSendMessage+0x642>
		  uart_print(1,0,strSend);
		  break;
	 case MSG_90://Request EDC
	      sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    f642:	ad b7       	in	r26, 0x3d	; 61
    f644:	be b7       	in	r27, 0x3e	; 62
    f646:	18 97       	sbiw	r26, 0x08	; 8
    f648:	0f b6       	in	r0, 0x3f	; 63
    f64a:	f8 94       	cli
    f64c:	be bf       	out	0x3e, r27	; 62
    f64e:	0f be       	out	0x3f, r0	; 63
    f650:	ad bf       	out	0x3d, r26	; 61
    f652:	ed b7       	in	r30, 0x3d	; 61
    f654:	fe b7       	in	r31, 0x3e	; 62
    f656:	31 96       	adiw	r30, 0x01	; 1
    f658:	12 96       	adiw	r26, 0x02	; 2
    f65a:	dc 92       	st	X, r13
    f65c:	ce 92       	st	-X, r12
    f65e:	11 97       	sbiw	r26, 0x01	; 1
    f660:	81 e3       	ldi	r24, 0x31	; 49
    f662:	90 e2       	ldi	r25, 0x20	; 32
    f664:	93 83       	std	Z+3, r25	; 0x03
    f666:	82 83       	std	Z+2, r24	; 0x02
    f668:	89 eb       	ldi	r24, 0xB9	; 185
    f66a:	97 e0       	ldi	r25, 0x07	; 7
    f66c:	95 83       	std	Z+5, r25	; 0x05
    f66e:	84 83       	std	Z+4, r24	; 0x04
    f670:	8e e8       	ldi	r24, 0x8E	; 142
    f672:	9c e0       	ldi	r25, 0x0C	; 12
    f674:	97 83       	std	Z+7, r25	; 0x07
    f676:	86 83       	std	Z+6, r24	; 0x06
    f678:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	      uart_print(1, 0,strSend);
    f67c:	8d b7       	in	r24, 0x3d	; 61
    f67e:	9e b7       	in	r25, 0x3e	; 62
    f680:	08 96       	adiw	r24, 0x08	; 8
    f682:	70 c0       	rjmp	.+224    	; 0xf764 <IFTSendMessage+0x64c>
	      break;
	 case MSG_92://EDC Approval
		  sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    f684:	ad b7       	in	r26, 0x3d	; 61
    f686:	be b7       	in	r27, 0x3e	; 62
    f688:	1c 97       	sbiw	r26, 0x0c	; 12
    f68a:	0f b6       	in	r0, 0x3f	; 63
    f68c:	f8 94       	cli
    f68e:	be bf       	out	0x3e, r27	; 62
    f690:	0f be       	out	0x3f, r0	; 63
    f692:	ad bf       	out	0x3d, r26	; 61
    f694:	ed b7       	in	r30, 0x3d	; 61
    f696:	fe b7       	in	r31, 0x3e	; 62
    f698:	31 96       	adiw	r30, 0x01	; 1
    f69a:	12 96       	adiw	r26, 0x02	; 2
    f69c:	dc 92       	st	X, r13
    f69e:	ce 92       	st	-X, r12
    f6a0:	11 97       	sbiw	r26, 0x01	; 1
    f6a2:	88 e2       	ldi	r24, 0x28	; 40
    f6a4:	90 e2       	ldi	r25, 0x20	; 32
    f6a6:	93 83       	std	Z+3, r25	; 0x03
    f6a8:	82 83       	std	Z+2, r24	; 0x02
    f6aa:	87 e8       	ldi	r24, 0x87	; 135
    f6ac:	9c e0       	ldi	r25, 0x0C	; 12
    f6ae:	95 83       	std	Z+5, r25	; 0x05
    f6b0:	84 83       	std	Z+4, r24	; 0x04
    f6b2:	89 eb       	ldi	r24, 0xB9	; 185
    f6b4:	97 e0       	ldi	r25, 0x07	; 7
    f6b6:	97 83       	std	Z+7, r25	; 0x07
    f6b8:	86 83       	std	Z+6, r24	; 0x06
    f6ba:	83 ea       	ldi	r24, 0xA3	; 163
    f6bc:	9c e0       	ldi	r25, 0x0C	; 12
    f6be:	91 87       	std	Z+9, r25	; 0x09
    f6c0:	80 87       	std	Z+8, r24	; 0x08
    f6c2:	89 e8       	ldi	r24, 0x89	; 137
    f6c4:	9b e0       	ldi	r25, 0x0B	; 11
    f6c6:	93 87       	std	Z+11, r25	; 0x0b
    f6c8:	82 87       	std	Z+10, r24	; 0x0a
    f6ca:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	      uart_print(1,0,strSend);	    
    f6ce:	8d b7       	in	r24, 0x3d	; 61
    f6d0:	9e b7       	in	r25, 0x3e	; 62
    f6d2:	0c 96       	adiw	r24, 0x0c	; 12
    f6d4:	0f b6       	in	r0, 0x3f	; 63
    f6d6:	f8 94       	cli
    f6d8:	9e bf       	out	0x3e, r25	; 62
    f6da:	0f be       	out	0x3f, r0	; 63
    f6dc:	8d bf       	out	0x3d, r24	; 61
    f6de:	81 e0       	ldi	r24, 0x01	; 1
    f6e0:	60 e0       	ldi	r22, 0x00	; 0
    f6e2:	a6 01       	movw	r20, r12
    f6e4:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
		  sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    f6e8:	ad b7       	in	r26, 0x3d	; 61
    f6ea:	be b7       	in	r27, 0x3e	; 62
    f6ec:	1a 97       	sbiw	r26, 0x0a	; 10
    f6ee:	0f b6       	in	r0, 0x3f	; 63
    f6f0:	f8 94       	cli
    f6f2:	be bf       	out	0x3e, r27	; 62
    f6f4:	0f be       	out	0x3f, r0	; 63
    f6f6:	ad bf       	out	0x3d, r26	; 61
    f6f8:	ed b7       	in	r30, 0x3d	; 61
    f6fa:	fe b7       	in	r31, 0x3e	; 62
    f6fc:	31 96       	adiw	r30, 0x01	; 1
    f6fe:	12 96       	adiw	r26, 0x02	; 2
    f700:	dc 92       	st	X, r13
    f702:	ce 92       	st	-X, r12
    f704:	11 97       	sbiw	r26, 0x01	; 1
    f706:	81 e2       	ldi	r24, 0x21	; 33
    f708:	90 e2       	ldi	r25, 0x20	; 32
    f70a:	93 83       	std	Z+3, r25	; 0x03
    f70c:	82 83       	std	Z+2, r24	; 0x02
    f70e:	80 ef       	ldi	r24, 0xF0	; 240
    f710:	97 e0       	ldi	r25, 0x07	; 7
    f712:	95 83       	std	Z+5, r25	; 0x05
    f714:	84 83       	std	Z+4, r24	; 0x04
    f716:	83 e5       	ldi	r24, 0x53	; 83
    f718:	97 e0       	ldi	r25, 0x07	; 7
    f71a:	97 83       	std	Z+7, r25	; 0x07
    f71c:	86 83       	std	Z+6, r24	; 0x06
    f71e:	8f eb       	ldi	r24, 0xBF	; 191
    f720:	9b e0       	ldi	r25, 0x0B	; 11
    f722:	91 87       	std	Z+9, r25	; 0x09
    f724:	80 87       	std	Z+8, r24	; 0x08
    f726:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	      uart_print(1,0,strSend);
    f72a:	8d b7       	in	r24, 0x3d	; 61
    f72c:	9e b7       	in	r25, 0x3e	; 62
    f72e:	0a 96       	adiw	r24, 0x0a	; 10
    f730:	19 c0       	rjmp	.+50     	; 0xf764 <IFTSendMessage+0x64c>
	      break;	 
	 case MSG_98://Request Transaction Info
	      sprintf_P(strSend,PSTR("%s"),strFIP_ID);
    f732:	00 d0       	rcall	.+0      	; 0xf734 <IFTSendMessage+0x61c>
    f734:	00 d0       	rcall	.+0      	; 0xf736 <IFTSendMessage+0x61e>
    f736:	00 d0       	rcall	.+0      	; 0xf738 <IFTSendMessage+0x620>
    f738:	ed b7       	in	r30, 0x3d	; 61
    f73a:	fe b7       	in	r31, 0x3e	; 62
    f73c:	31 96       	adiw	r30, 0x01	; 1
    f73e:	ad b7       	in	r26, 0x3d	; 61
    f740:	be b7       	in	r27, 0x3e	; 62
    f742:	12 96       	adiw	r26, 0x02	; 2
    f744:	dc 92       	st	X, r13
    f746:	ce 92       	st	-X, r12
    f748:	11 97       	sbiw	r26, 0x01	; 1
    f74a:	8e e1       	ldi	r24, 0x1E	; 30
    f74c:	90 e2       	ldi	r25, 0x20	; 32
    f74e:	93 83       	std	Z+3, r25	; 0x03
    f750:	82 83       	std	Z+2, r24	; 0x02
    f752:	89 eb       	ldi	r24, 0xB9	; 185
    f754:	97 e0       	ldi	r25, 0x07	; 7
    f756:	95 83       	std	Z+5, r25	; 0x05
    f758:	84 83       	std	Z+4, r24	; 0x04
    f75a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	      uart_print(1, 0,strSend);
    f75e:	8d b7       	in	r24, 0x3d	; 61
    f760:	9e b7       	in	r25, 0x3e	; 62
    f762:	06 96       	adiw	r24, 0x06	; 6
    f764:	0f b6       	in	r0, 0x3f	; 63
    f766:	f8 94       	cli
    f768:	9e bf       	out	0x3e, r25	; 62
    f76a:	0f be       	out	0x3f, r0	; 63
    f76c:	8d bf       	out	0x3d, r24	; 61
    f76e:	81 e0       	ldi	r24, 0x01	; 1
    f770:	60 e0       	ldi	r22, 0x00	; 0
    f772:	a6 01       	movw	r20, r12
    f774:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
	      break;

	 }     
     //[Checksum]
	 uart_printf(1,0,PSTR("F968CFFB"));
    f778:	81 e0       	ldi	r24, 0x01	; 1
    f77a:	60 e0       	ldi	r22, 0x00	; 0
    f77c:	45 e1       	ldi	r20, 0x15	; 21
    f77e:	50 e2       	ldi	r21, 0x20	; 32
    f780:	0e 94 93 a8 	call	0x15126	; 0x15126 <uart_printf>
	 //ETX
	 uart(1, 1,0x02);
    f784:	81 e0       	ldi	r24, 0x01	; 1
    f786:	61 e0       	ldi	r22, 0x01	; 1
    f788:	42 e0       	ldi	r20, 0x02	; 2
    f78a:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
}
    f78e:	c0 5c       	subi	r28, 0xC0	; 192
    f790:	df 4f       	sbci	r29, 0xFF	; 255
    f792:	0f b6       	in	r0, 0x3f	; 63
    f794:	f8 94       	cli
    f796:	de bf       	out	0x3e, r29	; 62
    f798:	0f be       	out	0x3f, r0	; 63
    f79a:	cd bf       	out	0x3d, r28	; 61
    f79c:	cf 91       	pop	r28
    f79e:	df 91       	pop	r29
    f7a0:	0f 91       	pop	r16
    f7a2:	ff 90       	pop	r15
    f7a4:	ef 90       	pop	r14
    f7a6:	df 90       	pop	r13
    f7a8:	cf 90       	pop	r12
    f7aa:	bf 90       	pop	r11
    f7ac:	af 90       	pop	r10
    f7ae:	08 95       	ret

0000f7b0 <sendMessage98>:
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
	uart_print(1, 0,strSend);
	uart(1, 1,0x02);
*/
    sprintf_P(strFIP_ID,PSTR("%.2d"),GetPumpID(FIPAddr));
    f7b0:	0e 94 cc 1c 	call	0x3998	; 0x3998 <GetPumpID>
    f7b4:	00 d0       	rcall	.+0      	; 0xf7b6 <sendMessage98+0x6>
    f7b6:	00 d0       	rcall	.+0      	; 0xf7b8 <sendMessage98+0x8>
    f7b8:	00 d0       	rcall	.+0      	; 0xf7ba <sendMessage98+0xa>
    f7ba:	ed b7       	in	r30, 0x3d	; 61
    f7bc:	fe b7       	in	r31, 0x3e	; 62
    f7be:	31 96       	adiw	r30, 0x01	; 1
    f7c0:	29 eb       	ldi	r18, 0xB9	; 185
    f7c2:	37 e0       	ldi	r19, 0x07	; 7
    f7c4:	ad b7       	in	r26, 0x3d	; 61
    f7c6:	be b7       	in	r27, 0x3e	; 62
    f7c8:	12 96       	adiw	r26, 0x02	; 2
    f7ca:	3c 93       	st	X, r19
    f7cc:	2e 93       	st	-X, r18
    f7ce:	11 97       	sbiw	r26, 0x01	; 1
    f7d0:	20 e1       	ldi	r18, 0x10	; 16
    f7d2:	30 e2       	ldi	r19, 0x20	; 32
    f7d4:	33 83       	std	Z+3, r19	; 0x03
    f7d6:	22 83       	std	Z+2, r18	; 0x02
    f7d8:	84 83       	std	Z+4, r24	; 0x04
    f7da:	15 82       	std	Z+5, r1	; 0x05
    f7dc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	IFTSendMessage(MSG_98);
    f7e0:	8d b7       	in	r24, 0x3d	; 61
    f7e2:	9e b7       	in	r25, 0x3e	; 62
    f7e4:	06 96       	adiw	r24, 0x06	; 6
    f7e6:	0f b6       	in	r0, 0x3f	; 63
    f7e8:	f8 94       	cli
    f7ea:	9e bf       	out	0x3e, r25	; 62
    f7ec:	0f be       	out	0x3f, r0	; 63
    f7ee:	8d bf       	out	0x3d, r24	; 61
    f7f0:	88 e9       	ldi	r24, 0x98	; 152
    f7f2:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
	IsBusyMsg11=True;
    f7f6:	81 e0       	ldi	r24, 0x01	; 1
    f7f8:	80 93 ad 01 	sts	0x01AD, r24
}
    f7fc:	08 95       	ret

0000f7fe <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
    f7fe:	ef 92       	push	r14
    f800:	0f 93       	push	r16
    f802:	1f 93       	push	r17
    f804:	df 93       	push	r29
    f806:	cf 93       	push	r28
    f808:	cd b7       	in	r28, 0x3d	; 61
    f80a:	de b7       	in	r29, 0x3e	; 62
    f80c:	64 97       	sbiw	r28, 0x14	; 20
    f80e:	0f b6       	in	r0, 0x3f	; 63
    f810:	f8 94       	cli
    f812:	de bf       	out	0x3e, r29	; 62
    f814:	0f be       	out	0x3f, r0	; 63
    f816:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoop=0;
     char uiResult=USER_NONE,KeyPressed,KeyChar;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
    f818:	80 91 0d 02 	lds	r24, 0x020D
    f81c:	86 30       	cpi	r24, 0x06	; 6
    f81e:	09 f4       	brne	.+2      	; 0xf822 <FMenuTicket+0x24>
    f820:	bf c0       	rjmp	.+382    	; 0xf9a0 <FMenuTicket+0x1a2>
    f822:	87 30       	cpi	r24, 0x07	; 7
    f824:	88 f4       	brcc	.+34     	; 0xf848 <FMenuTicket+0x4a>
    f826:	82 30       	cpi	r24, 0x02	; 2
    f828:	e9 f1       	breq	.+122    	; 0xf8a4 <FMenuTicket+0xa6>
    f82a:	83 30       	cpi	r24, 0x03	; 3
    f82c:	30 f4       	brcc	.+12     	; 0xf83a <FMenuTicket+0x3c>
    f82e:	88 23       	and	r24, r24
    f830:	09 f1       	breq	.+66     	; 0xf874 <FMenuTicket+0x76>
    f832:	81 30       	cpi	r24, 0x01	; 1
    f834:	09 f0       	breq	.+2      	; 0xf838 <FMenuTicket+0x3a>
    f836:	21 c1       	rjmp	.+578    	; 0xfa7a <FMenuTicket+0x27c>
    f838:	1f c0       	rjmp	.+62     	; 0xf878 <FMenuTicket+0x7a>
    f83a:	84 30       	cpi	r24, 0x04	; 4
    f83c:	09 f4       	brne	.+2      	; 0xf840 <FMenuTicket+0x42>
    f83e:	87 c0       	rjmp	.+270    	; 0xf94e <FMenuTicket+0x150>
    f840:	85 30       	cpi	r24, 0x05	; 5
    f842:	08 f0       	brcs	.+2      	; 0xf846 <FMenuTicket+0x48>
    f844:	a7 c0       	rjmp	.+334    	; 0xf994 <FMenuTicket+0x196>
    f846:	4d c0       	rjmp	.+154    	; 0xf8e2 <FMenuTicket+0xe4>
    f848:	89 30       	cpi	r24, 0x09	; 9
    f84a:	09 f4       	brne	.+2      	; 0xf84e <FMenuTicket+0x50>
    f84c:	f4 c0       	rjmp	.+488    	; 0xfa36 <FMenuTicket+0x238>
    f84e:	8a 30       	cpi	r24, 0x0A	; 10
    f850:	38 f4       	brcc	.+14     	; 0xf860 <FMenuTicket+0x62>
    f852:	87 30       	cpi	r24, 0x07	; 7
    f854:	09 f4       	brne	.+2      	; 0xf858 <FMenuTicket+0x5a>
    f856:	d2 c0       	rjmp	.+420    	; 0xf9fc <FMenuTicket+0x1fe>
    f858:	88 30       	cpi	r24, 0x08	; 8
    f85a:	09 f0       	breq	.+2      	; 0xf85e <FMenuTicket+0x60>
    f85c:	0e c1       	rjmp	.+540    	; 0xfa7a <FMenuTicket+0x27c>
    f85e:	be c0       	rjmp	.+380    	; 0xf9dc <FMenuTicket+0x1de>
    f860:	8b 30       	cpi	r24, 0x0B	; 11
    f862:	09 f4       	brne	.+2      	; 0xf866 <FMenuTicket+0x68>
    f864:	ee c0       	rjmp	.+476    	; 0xfa42 <FMenuTicket+0x244>
    f866:	8b 30       	cpi	r24, 0x0B	; 11
    f868:	08 f4       	brcc	.+2      	; 0xf86c <FMenuTicket+0x6e>
    f86a:	01 c1       	rjmp	.+514    	; 0xfa6e <FMenuTicket+0x270>
    f86c:	8c 30       	cpi	r24, 0x0C	; 12
    f86e:	09 f0       	breq	.+2      	; 0xf872 <FMenuTicket+0x74>
    f870:	04 c1       	rjmp	.+520    	; 0xfa7a <FMenuTicket+0x27c>
    f872:	ff c0       	rjmp	.+510    	; 0xfa72 <FMenuTicket+0x274>
	case mtInit:
		 stMenuTicket=mtPlatNo;
    f874:	81 e0       	ldi	r24, 0x01	; 1
    f876:	79 c0       	rjmp	.+242    	; 0xf96a <FMenuTicket+0x16c>
	     break;
    case mtPlatNo:
	     lcd_clear();
    f878:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
    f87c:	81 e0       	ldi	r24, 0x01	; 1
    f87e:	61 e0       	ldi	r22, 0x01	; 1
    f880:	4a e4       	ldi	r20, 0x4A	; 74
    f882:	5a e0       	ldi	r21, 0x0A	; 10
    f884:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
    f888:	82 e0       	ldi	r24, 0x02	; 2
    f88a:	61 e0       	ldi	r22, 0x01	; 1
    f88c:	48 e4       	ldi	r20, 0x48	; 72
    f88e:	5a e0       	ldi	r21, 0x0A	; 10
    f890:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
    f894:	84 e0       	ldi	r24, 0x04	; 4
    f896:	61 e0       	ldi	r22, 0x01	; 1
    f898:	43 e3       	ldi	r20, 0x33	; 51
    f89a:	5a e0       	ldi	r21, 0x0A	; 10
    f89c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		 uiResult=USER_NONE;
		 stMenuTicket=mtInputPlatNo;
    f8a0:	82 e0       	ldi	r24, 0x02	; 2
    f8a2:	63 c0       	rjmp	.+198    	; 0xf96a <FMenuTicket+0x16c>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
    f8a4:	83 e0       	ldi	r24, 0x03	; 3
    f8a6:	62 e0       	ldi	r22, 0x02	; 2
    f8a8:	41 e0       	ldi	r20, 0x01	; 1
    f8aa:	2a ef       	ldi	r18, 0xFA	; 250
    f8ac:	38 e0       	ldi	r19, 0x08	; 8
    f8ae:	00 e0       	ldi	r16, 0x00	; 0
    f8b0:	10 e0       	ldi	r17, 0x00	; 0
    f8b2:	9a e0       	ldi	r25, 0x0A	; 10
    f8b4:	e9 2e       	mov	r14, r25
    f8b6:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
    f8ba:	83 30       	cpi	r24, 0x03	; 3
    f8bc:	09 f4       	brne	.+2      	; 0xf8c0 <FMenuTicket+0xc2>
    f8be:	55 c0       	rjmp	.+170    	; 0xf96a <FMenuTicket+0x16c>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
    f8c0:	81 30       	cpi	r24, 0x01	; 1
    f8c2:	09 f4       	brne	.+2      	; 0xf8c6 <FMenuTicket+0xc8>
    f8c4:	d4 c0       	rjmp	.+424    	; 0xfa6e <FMenuTicket+0x270>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    f8c6:	84 30       	cpi	r24, 0x04	; 4
    f8c8:	21 f4       	brne	.+8      	; 0xf8d2 <FMenuTicket+0xd4>
    f8ca:	61 e0       	ldi	r22, 0x01	; 1
    f8cc:	4e e1       	ldi	r20, 0x1E	; 30
    f8ce:	5a e0       	ldi	r21, 0x0A	; 10
    f8d0:	5e c0       	rjmp	.+188    	; 0xf98e <FMenuTicket+0x190>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    f8d2:	85 30       	cpi	r24, 0x05	; 5
    f8d4:	09 f0       	breq	.+2      	; 0xf8d8 <FMenuTicket+0xda>
    f8d6:	d1 c0       	rjmp	.+418    	; 0xfa7a <FMenuTicket+0x27c>
    f8d8:	84 e0       	ldi	r24, 0x04	; 4
    f8da:	61 e0       	ldi	r22, 0x01	; 1
    f8dc:	49 e0       	ldi	r20, 0x09	; 9
    f8de:	5a e0       	ldi	r21, 0x0A	; 10
    f8e0:	56 c0       	rjmp	.+172    	; 0xf98e <FMenuTicket+0x190>
	     break;
    case mtOdometer:
	     lcd_clear();
    f8e2:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
    f8e6:	00 d0       	rcall	.+0      	; 0xf8e8 <FMenuTicket+0xea>
    f8e8:	00 d0       	rcall	.+0      	; 0xf8ea <FMenuTicket+0xec>
    f8ea:	00 d0       	rcall	.+0      	; 0xf8ec <FMenuTicket+0xee>
    f8ec:	ed b7       	in	r30, 0x3d	; 61
    f8ee:	fe b7       	in	r31, 0x3e	; 62
    f8f0:	31 96       	adiw	r30, 0x01	; 1
    f8f2:	8e 01       	movw	r16, r28
    f8f4:	0f 5f       	subi	r16, 0xFF	; 255
    f8f6:	1f 4f       	sbci	r17, 0xFF	; 255
    f8f8:	ad b7       	in	r26, 0x3d	; 61
    f8fa:	be b7       	in	r27, 0x3e	; 62
    f8fc:	12 96       	adiw	r26, 0x02	; 2
    f8fe:	1c 93       	st	X, r17
    f900:	0e 93       	st	-X, r16
    f902:	11 97       	sbiw	r26, 0x01	; 1
    f904:	8c ef       	ldi	r24, 0xFC	; 252
    f906:	99 e0       	ldi	r25, 0x09	; 9
    f908:	93 83       	std	Z+3, r25	; 0x03
    f90a:	82 83       	std	Z+2, r24	; 0x02
    f90c:	8a ef       	ldi	r24, 0xFA	; 250
    f90e:	98 e0       	ldi	r25, 0x08	; 8
    f910:	95 83       	std	Z+5, r25	; 0x05
    f912:	84 83       	std	Z+4, r24	; 0x04
    f914:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	     lcd_print(1,1,lcdteks);
    f918:	8d b7       	in	r24, 0x3d	; 61
    f91a:	9e b7       	in	r25, 0x3e	; 62
    f91c:	06 96       	adiw	r24, 0x06	; 6
    f91e:	0f b6       	in	r0, 0x3f	; 63
    f920:	f8 94       	cli
    f922:	9e bf       	out	0x3e, r25	; 62
    f924:	0f be       	out	0x3f, r0	; 63
    f926:	8d bf       	out	0x3d, r24	; 61
    f928:	81 e0       	ldi	r24, 0x01	; 1
    f92a:	61 e0       	ldi	r22, 0x01	; 1
    f92c:	a8 01       	movw	r20, r16
    f92e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
    f932:	82 e0       	ldi	r24, 0x02	; 2
    f934:	61 e0       	ldi	r22, 0x01	; 1
    f936:	40 ef       	ldi	r20, 0xF0	; 240
    f938:	59 e0       	ldi	r21, 0x09	; 9
    f93a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
    f93e:	84 e0       	ldi	r24, 0x04	; 4
    f940:	61 e0       	ldi	r22, 0x01	; 1
    f942:	4b ed       	ldi	r20, 0xDB	; 219
    f944:	59 e0       	ldi	r21, 0x09	; 9
    f946:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		 uiResult=USER_NONE;
		 stMenuTicket=mtInputOdometer;
    f94a:	84 e0       	ldi	r24, 0x04	; 4
    f94c:	0e c0       	rjmp	.+28     	; 0xf96a <FMenuTicket+0x16c>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
    f94e:	81 e0       	ldi	r24, 0x01	; 1
    f950:	62 e0       	ldi	r22, 0x02	; 2
    f952:	4a e0       	ldi	r20, 0x0A	; 10
    f954:	23 ec       	ldi	r18, 0xC3	; 195
    f956:	33 e0       	ldi	r19, 0x03	; 3
    f958:	00 e0       	ldi	r16, 0x00	; 0
    f95a:	10 e0       	ldi	r17, 0x00	; 0
    f95c:	ba e0       	ldi	r27, 0x0A	; 10
    f95e:	eb 2e       	mov	r14, r27
    f960:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
    f964:	83 30       	cpi	r24, 0x03	; 3
    f966:	21 f4       	brne	.+8      	; 0xf970 <FMenuTicket+0x172>
    f968:	85 e0       	ldi	r24, 0x05	; 5
    f96a:	80 93 0d 02 	sts	0x020D, r24
    f96e:	85 c0       	rjmp	.+266    	; 0xfa7a <FMenuTicket+0x27c>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
    f970:	81 30       	cpi	r24, 0x01	; 1
    f972:	d9 f3       	breq	.-10     	; 0xf96a <FMenuTicket+0x16c>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
    f974:	84 30       	cpi	r24, 0x04	; 4
    f976:	21 f4       	brne	.+8      	; 0xf980 <FMenuTicket+0x182>
    f978:	61 e0       	ldi	r22, 0x01	; 1
    f97a:	46 ec       	ldi	r20, 0xC6	; 198
    f97c:	59 e0       	ldi	r21, 0x09	; 9
    f97e:	07 c0       	rjmp	.+14     	; 0xf98e <FMenuTicket+0x190>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
    f980:	85 30       	cpi	r24, 0x05	; 5
    f982:	09 f0       	breq	.+2      	; 0xf986 <FMenuTicket+0x188>
    f984:	7a c0       	rjmp	.+244    	; 0xfa7a <FMenuTicket+0x27c>
    f986:	84 e0       	ldi	r24, 0x04	; 4
    f988:	61 e0       	ldi	r22, 0x01	; 1
    f98a:	41 eb       	ldi	r20, 0xB1	; 177
    f98c:	59 e0       	ldi	r21, 0x09	; 9
    f98e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
    f992:	73 c0       	rjmp	.+230    	; 0xfa7a <FMenuTicket+0x27c>
	     break;
    case mtFIP:
	     lcd_clear();
    f994:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		 _scr_pump();
    f998:	0e 94 35 45 	call	0x8a6a	; 0x8a6a <_scr_pump>
		 stMenuTicket=mtInputFIP;
    f99c:	86 e0       	ldi	r24, 0x06	; 6
    f99e:	e5 cf       	rjmp	.-54     	; 0xf96a <FMenuTicket+0x16c>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
    f9a0:	81 e0       	ldi	r24, 0x01	; 1
    f9a2:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    f9a6:	18 2f       	mov	r17, r24
		 KeyChar=_key_btn(KeyPressed);
    f9a8:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		 if ((KeyChar>='1')&&(KeyChar<='8')){
    f9ac:	81 53       	subi	r24, 0x31	; 49
    f9ae:	88 30       	cpi	r24, 0x08	; 8
    f9b0:	40 f4       	brcc	.+16     	; 0xf9c2 <FMenuTicket+0x1c4>
		     FIP_Used=KeyChar-'0';
    f9b2:	8f 5f       	subi	r24, 0xFF	; 255
    f9b4:	80 93 0a 02 	sts	0x020A, r24
			 zFIP_Used=FIP_Used;
    f9b8:	80 93 09 02 	sts	0x0209, r24
		     stMenuTicket=mtSendMsg98;
    f9bc:	87 e0       	ldi	r24, 0x07	; 7
    f9be:	80 93 0d 02 	sts	0x020D, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
    f9c2:	17 3e       	cpi	r17, 0xE7	; 231
    f9c4:	11 f4       	brne	.+4      	; 0xf9ca <FMenuTicket+0x1cc>
             stMenuTicket=mtOdometer;
    f9c6:	83 e0       	ldi	r24, 0x03	; 3
    f9c8:	d0 cf       	rjmp	.-96     	; 0xf96a <FMenuTicket+0x16c>
		 }else
		 if (KeyPressed==_KEY_ENTER){
    f9ca:	17 3b       	cpi	r17, 0xB7	; 183
    f9cc:	09 f0       	breq	.+2      	; 0xf9d0 <FMenuTicket+0x1d2>
    f9ce:	55 c0       	rjmp	.+170    	; 0xfa7a <FMenuTicket+0x27c>
		     FIP_Used=zFIP_Used;
    f9d0:	80 91 09 02 	lds	r24, 0x0209
    f9d4:	80 93 0a 02 	sts	0x020A, r24
             stMenuTicket=mtInitWaitMessage99;
    f9d8:	88 e0       	ldi	r24, 0x08	; 8
    f9da:	c7 cf       	rjmp	.-114    	; 0xf96a <FMenuTicket+0x16c>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
    f9dc:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
    f9e0:	82 e0       	ldi	r24, 0x02	; 2
    f9e2:	61 e0       	ldi	r22, 0x01	; 1
    f9e4:	44 ea       	ldi	r20, 0xA4	; 164
    f9e6:	59 e0       	ldi	r21, 0x09	; 9
    f9e8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
    f9ec:	83 e0       	ldi	r24, 0x03	; 3
    f9ee:	61 e0       	ldi	r22, 0x01	; 1
    f9f0:	4d e9       	ldi	r20, 0x9D	; 157
    f9f2:	59 e0       	ldi	r21, 0x09	; 9
    f9f4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
         stMenuTicket=mtSendMsg98;
    f9f8:	87 e0       	ldi	r24, 0x07	; 7
    f9fa:	b7 cf       	rjmp	.-146    	; 0xf96a <FMenuTicket+0x16c>
	     break;
    case mtSendMsg98:
	     iPos=0;
    f9fc:	10 92 0c 02 	sts	0x020C, r1
		 iSend=0;
    fa00:	10 92 0b 02 	sts	0x020B, r1
		 IsMessage99=False;
    fa04:	10 92 9f 01 	sts	0x019F, r1
		 TimSend=0;
    fa08:	10 92 78 0c 	sts	0x0C78, r1
		 iLoop=0;
    fa0c:	10 92 08 02 	sts	0x0208, r1
    fa10:	10 92 07 02 	sts	0x0207, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
    fa14:	80 91 00 01 	lds	r24, 0x0100
    fa18:	81 30       	cpi	r24, 0x01	; 1
    fa1a:	29 f4       	brne	.+10     	; 0xfa26 <FMenuTicket+0x228>
    fa1c:	80 91 0a 02 	lds	r24, 0x020A
    fa20:	0e 94 d8 7b 	call	0xf7b0	; 0xf7b0 <sendMessage98>
    fa24:	24 c0       	rjmp	.+72     	; 0xfa6e <FMenuTicket+0x270>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
    fa26:	82 30       	cpi	r24, 0x02	; 2
    fa28:	11 f5       	brne	.+68     	; 0xfa6e <FMenuTicket+0x270>
    fa2a:	80 91 0a 02 	lds	r24, 0x020A
    fa2e:	60 e0       	ldi	r22, 0x00	; 0
    fa30:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <PrintStandalone>
    fa34:	1c c0       	rjmp	.+56     	; 0xfa6e <FMenuTicket+0x270>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
    fa36:	80 91 9f 01 	lds	r24, 0x019F
    fa3a:	81 30       	cpi	r24, 0x01	; 1
    fa3c:	f1 f4       	brne	.+60     	; 0xfa7a <FMenuTicket+0x27c>
		    stMenuTicket=mtMessage99Received;
    fa3e:	8a e0       	ldi	r24, 0x0A	; 10
    fa40:	94 cf       	rjmp	.-216    	; 0xf96a <FMenuTicket+0x16c>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
    fa42:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
    fa46:	82 e0       	ldi	r24, 0x02	; 2
    fa48:	61 e0       	ldi	r22, 0x01	; 1
    fa4a:	49 e8       	ldi	r20, 0x89	; 137
    fa4c:	59 e0       	ldi	r21, 0x09	; 9
    fa4e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    fa52:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    fa54:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    fa56:	82 e0       	ldi	r24, 0x02	; 2
    fa58:	80 93 bc 01 	sts	0x01BC, r24
    fa5c:	80 e2       	ldi	r24, 0x20	; 32
    fa5e:	9e e4       	ldi	r25, 0x4E	; 78
    fa60:	29 e1       	ldi	r18, 0x19	; 25
    fa62:	30 e0       	ldi	r19, 0x00	; 0
    fa64:	f9 01       	movw	r30, r18
    fa66:	31 97       	sbiw	r30, 0x01	; 1
    fa68:	f1 f7       	brne	.-4      	; 0xfa66 <FMenuTicket+0x268>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    fa6a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    fa6c:	d9 f7       	brne	.-10     	; 0xfa64 <FMenuTicket+0x266>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
    fa6e:	8c e0       	ldi	r24, 0x0C	; 12
    fa70:	7c cf       	rjmp	.-264    	; 0xf96a <FMenuTicket+0x16c>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
    fa72:	10 92 0d 02 	sts	0x020D, r1
    fa76:	81 e0       	ldi	r24, 0x01	; 1
    fa78:	01 c0       	rjmp	.+2      	; 0xfa7c <FMenuTicket+0x27e>
    fa7a:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
    fa7c:	64 96       	adiw	r28, 0x14	; 20
    fa7e:	0f b6       	in	r0, 0x3f	; 63
    fa80:	f8 94       	cli
    fa82:	de bf       	out	0x3e, r29	; 62
    fa84:	0f be       	out	0x3f, r0	; 63
    fa86:	cd bf       	out	0x3d, r28	; 61
    fa88:	cf 91       	pop	r28
    fa8a:	df 91       	pop	r29
    fa8c:	1f 91       	pop	r17
    fa8e:	0f 91       	pop	r16
    fa90:	ef 90       	pop	r14
    fa92:	08 95       	ret

0000fa94 <sendMessage94>:
	sprintf_P(strSend,PSTR("E9445512"));
    //uart_print(0, 0,strSend);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_94);
    fa94:	84 e9       	ldi	r24, 0x94	; 148
    fa96:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
    fa9a:	08 95       	ret

0000fa9c <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    //uart_print(0, 0,strSend);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_92);
    fa9c:	82 e9       	ldi	r24, 0x92	; 146
    fa9e:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
    faa2:	08 95       	ret

0000faa4 <sendMessage90>:
    uart_print(1, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_90);
    faa4:	80 e9       	ldi	r24, 0x90	; 144
    faa6:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
    faaa:	08 95       	ret

0000faac <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    faac:	0f 93       	push	r16
    faae:	1f 93       	push	r17
static char FIP_Used=0;
       char lcdteks[20],Result=MENU_NONE;
       char KeyPressed=0,KeyChar,FIPResult;

     Result=MENU_NONE;
	 switch(stEtransaction){
    fab0:	80 91 62 02 	lds	r24, 0x0262
    fab4:	85 30       	cpi	r24, 0x05	; 5
    fab6:	09 f4       	brne	.+2      	; 0xfaba <FMenuEDCTransaction+0xe>
    fab8:	96 c0       	rjmp	.+300    	; 0xfbe6 <FMenuEDCTransaction+0x13a>
    faba:	86 30       	cpi	r24, 0x06	; 6
    fabc:	90 f4       	brcc	.+36     	; 0xfae2 <FMenuEDCTransaction+0x36>
    fabe:	82 30       	cpi	r24, 0x02	; 2
    fac0:	09 f4       	brne	.+2      	; 0xfac4 <FMenuEDCTransaction+0x18>
    fac2:	52 c0       	rjmp	.+164    	; 0xfb68 <FMenuEDCTransaction+0xbc>
    fac4:	83 30       	cpi	r24, 0x03	; 3
    fac6:	30 f4       	brcc	.+12     	; 0xfad4 <FMenuEDCTransaction+0x28>
    fac8:	88 23       	and	r24, r24
    faca:	f1 f0       	breq	.+60     	; 0xfb08 <FMenuEDCTransaction+0x5c>
    facc:	81 30       	cpi	r24, 0x01	; 1
    face:	09 f0       	breq	.+2      	; 0xfad2 <FMenuEDCTransaction+0x26>
    fad0:	d2 c0       	rjmp	.+420    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
    fad2:	36 c0       	rjmp	.+108    	; 0xfb40 <FMenuEDCTransaction+0x94>
    fad4:	83 30       	cpi	r24, 0x03	; 3
    fad6:	09 f4       	brne	.+2      	; 0xfada <FMenuEDCTransaction+0x2e>
    fad8:	57 c0       	rjmp	.+174    	; 0xfb88 <FMenuEDCTransaction+0xdc>
    fada:	84 30       	cpi	r24, 0x04	; 4
    fadc:	09 f0       	breq	.+2      	; 0xfae0 <FMenuEDCTransaction+0x34>
    fade:	cb c0       	rjmp	.+406    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
    fae0:	7c c0       	rjmp	.+248    	; 0xfbda <FMenuEDCTransaction+0x12e>
    fae2:	88 30       	cpi	r24, 0x08	; 8
    fae4:	09 f4       	brne	.+2      	; 0xfae8 <FMenuEDCTransaction+0x3c>
    fae6:	b7 c0       	rjmp	.+366    	; 0xfc56 <FMenuEDCTransaction+0x1aa>
    fae8:	89 30       	cpi	r24, 0x09	; 9
    faea:	38 f4       	brcc	.+14     	; 0xfafa <FMenuEDCTransaction+0x4e>
    faec:	86 30       	cpi	r24, 0x06	; 6
    faee:	09 f4       	brne	.+2      	; 0xfaf2 <FMenuEDCTransaction+0x46>
    faf0:	8d c0       	rjmp	.+282    	; 0xfc0c <FMenuEDCTransaction+0x160>
    faf2:	87 30       	cpi	r24, 0x07	; 7
    faf4:	09 f0       	breq	.+2      	; 0xfaf8 <FMenuEDCTransaction+0x4c>
    faf6:	bf c0       	rjmp	.+382    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
    faf8:	8b c0       	rjmp	.+278    	; 0xfc10 <FMenuEDCTransaction+0x164>
    fafa:	89 30       	cpi	r24, 0x09	; 9
    fafc:	09 f4       	brne	.+2      	; 0xfb00 <FMenuEDCTransaction+0x54>
    fafe:	b1 c0       	rjmp	.+354    	; 0xfc62 <FMenuEDCTransaction+0x1b6>
    fb00:	8a 30       	cpi	r24, 0x0A	; 10
    fb02:	09 f0       	breq	.+2      	; 0xfb06 <FMenuEDCTransaction+0x5a>
    fb04:	b8 c0       	rjmp	.+368    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
    fb06:	b3 c0       	rjmp	.+358    	; 0xfc6e <FMenuEDCTransaction+0x1c2>
	 case etInit:
	      lcd_clear();
    fb08:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    fb0c:	81 e0       	ldi	r24, 0x01	; 1
    fb0e:	61 e0       	ldi	r22, 0x01	; 1
    fb10:	43 e9       	ldi	r20, 0x93	; 147
    fb12:	59 e1       	ldi	r21, 0x19	; 25
    fb14:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    fb18:	81 e0       	ldi	r24, 0x01	; 1
    fb1a:	61 e0       	ldi	r22, 0x01	; 1
    fb1c:	4e e7       	ldi	r20, 0x7E	; 126
    fb1e:	59 e1       	ldi	r21, 0x19	; 25
    fb20:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    fb24:	82 e0       	ldi	r24, 0x02	; 2
    fb26:	61 e0       	ldi	r22, 0x01	; 1
    fb28:	49 e6       	ldi	r20, 0x69	; 105
    fb2a:	59 e1       	ldi	r21, 0x19	; 25
    fb2c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    fb30:	84 e0       	ldi	r24, 0x04	; 4
    fb32:	61 e0       	ldi	r22, 0x01	; 1
    fb34:	44 e5       	ldi	r20, 0x54	; 84
    fb36:	59 e1       	ldi	r21, 0x19	; 25
    fb38:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stEtransaction=etInputEDC;
    fb3c:	81 e0       	ldi	r24, 0x01	; 1
    fb3e:	63 c0       	rjmp	.+198    	; 0xfc06 <FMenuEDCTransaction+0x15a>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    fb40:	81 e0       	ldi	r24, 0x01	; 1
    fb42:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
    fb46:	08 2f       	mov	r16, r24
		  KeyChar=_key_btn(KeyPressed);
    fb48:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
    fb4c:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    fb4e:	81 53       	subi	r24, 0x31	; 49
    fb50:	82 30       	cpi	r24, 0x02	; 2
    fb52:	30 f4       	brcc	.+12     	; 0xfb60 <FMenuEDCTransaction+0xb4>
		       EDCType=KeyChar-'0';
    fb54:	90 53       	subi	r25, 0x30	; 48
    fb56:	90 93 0b 08 	sts	0x080B, r25
		       stEtransaction=etSelectFIP;
    fb5a:	82 e0       	ldi	r24, 0x02	; 2
    fb5c:	80 93 62 02 	sts	0x0262, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    fb60:	07 3e       	cpi	r16, 0xE7	; 231
    fb62:	09 f0       	breq	.+2      	; 0xfb66 <FMenuEDCTransaction+0xba>
    fb64:	88 c0       	rjmp	.+272    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
    fb66:	81 c0       	rjmp	.+258    	; 0xfc6a <FMenuEDCTransaction+0x1be>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    fb68:	80 e0       	ldi	r24, 0x00	; 0
    fb6a:	90 e0       	ldi	r25, 0x00	; 0
    fb6c:	69 eb       	ldi	r22, 0xB9	; 185
    fb6e:	77 e0       	ldi	r23, 0x07	; 7
    fb70:	0e 94 6e 53 	call	0xa6dc	; 0xa6dc <menu_FIP>
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    fb74:	88 23       	and	r24, r24
    fb76:	11 f4       	brne	.+4      	; 0xfb7c <FMenuEDCTransaction+0xd0>
    fb78:	83 e0       	ldi	r24, 0x03	; 3
    fb7a:	45 c0       	rjmp	.+138    	; 0xfc06 <FMenuEDCTransaction+0x15a>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    fb7c:	82 30       	cpi	r24, 0x02	; 2
    fb7e:	09 f0       	breq	.+2      	; 0xfb82 <FMenuEDCTransaction+0xd6>
    fb80:	7a c0       	rjmp	.+244    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
    fb82:	10 92 62 02 	sts	0x0262, r1
    fb86:	77 c0       	rjmp	.+238    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
    fb88:	ee e8       	ldi	r30, 0x8E	; 142
    fb8a:	fc e0       	ldi	r31, 0x0C	; 12
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    fb8c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    fb8e:	8c e0       	ldi	r24, 0x0C	; 12
    fb90:	e3 3a       	cpi	r30, 0xA3	; 163
    fb92:	f8 07       	cpc	r31, r24
    fb94:	d9 f7       	brne	.-10     	; 0xfb8c <FMenuEDCTransaction+0xe0>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    fb96:	80 91 0b 08 	lds	r24, 0x080B
    fb9a:	81 30       	cpi	r24, 0x01	; 1
    fb9c:	19 f4       	brne	.+6      	; 0xfba4 <FMenuEDCTransaction+0xf8>
		      AddSpaceLag(strRef1,20);
    fb9e:	cf 01       	movw	r24, r30
    fba0:	45 97       	sbiw	r24, 0x15	; 21
    fba2:	16 c0       	rjmp	.+44     	; 0xfbd0 <FMenuEDCTransaction+0x124>
          }
		  else
	      if (EDCType==2){
    fba4:	82 30       	cpi	r24, 0x02	; 2
    fba6:	b9 f4       	brne	.+46     	; 0xfbd6 <FMenuEDCTransaction+0x12a>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    fba8:	00 d0       	rcall	.+0      	; 0xfbaa <FMenuEDCTransaction+0xfe>
    fbaa:	00 d0       	rcall	.+0      	; 0xfbac <FMenuEDCTransaction+0x100>
    fbac:	8f 01       	movw	r16, r30
    fbae:	05 51       	subi	r16, 0x15	; 21
    fbb0:	10 40       	sbci	r17, 0x00	; 0
    fbb2:	ed b7       	in	r30, 0x3d	; 61
    fbb4:	fe b7       	in	r31, 0x3e	; 62
    fbb6:	12 83       	std	Z+2, r17	; 0x02
    fbb8:	01 83       	std	Z+1, r16	; 0x01
    fbba:	89 e4       	ldi	r24, 0x49	; 73
    fbbc:	99 e1       	ldi	r25, 0x19	; 25
    fbbe:	94 83       	std	Z+4, r25	; 0x04
    fbc0:	83 83       	std	Z+3, r24	; 0x03
    fbc2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			  AddSpaceLag(strRef1,20);
    fbc6:	0f 90       	pop	r0
    fbc8:	0f 90       	pop	r0
    fbca:	0f 90       	pop	r0
    fbcc:	0f 90       	pop	r0
    fbce:	c8 01       	movw	r24, r16
    fbd0:	64 e1       	ldi	r22, 0x14	; 20
    fbd2:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    fbd6:	84 e0       	ldi	r24, 0x04	; 4
    fbd8:	16 c0       	rjmp	.+44     	; 0xfc06 <FMenuEDCTransaction+0x15a>
	      break;
     case etSendingMessage90:
          sendMessage90();
    fbda:	0e 94 52 7d 	call	0xfaa4	; 0xfaa4 <sendMessage90>
		  TimSend=0;
    fbde:	10 92 78 0c 	sts	0x0C78, r1
          stEtransaction=etWaitReply;
    fbe2:	85 e0       	ldi	r24, 0x05	; 5
    fbe4:	10 c0       	rjmp	.+32     	; 0xfc06 <FMenuEDCTransaction+0x15a>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
    fbe6:	80 91 78 0c 	lds	r24, 0x0C78
    fbea:	85 31       	cpi	r24, 0x15	; 21
    fbec:	18 f0       	brcs	.+6      	; 0xfbf4 <FMenuEDCTransaction+0x148>
    fbee:	88 e0       	ldi	r24, 0x08	; 8
    fbf0:	80 93 62 02 	sts	0x0262, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    fbf4:	80 91 a7 01 	lds	r24, 0x01A7
    fbf8:	81 30       	cpi	r24, 0x01	; 1
    fbfa:	21 f0       	breq	.+8      	; 0xfc04 <FMenuEDCTransaction+0x158>
    fbfc:	80 91 a3 01 	lds	r24, 0x01A3
    fc00:	81 30       	cpi	r24, 0x01	; 1
    fc02:	c9 f5       	brne	.+114    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
		       stEtransaction=etSuccesEDC;
    fc04:	86 e0       	ldi	r24, 0x06	; 6
    fc06:	80 93 62 02 	sts	0x0262, r24
    fc0a:	35 c0       	rjmp	.+106    	; 0xfc76 <FMenuEDCTransaction+0x1ca>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    fc0c:	87 e0       	ldi	r24, 0x07	; 7
    fc0e:	fb cf       	rjmp	.-10     	; 0xfc06 <FMenuEDCTransaction+0x15a>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    fc10:	80 91 a3 01 	lds	r24, 0x01A3
    fc14:	81 30       	cpi	r24, 0x01	; 1
    fc16:	19 f5       	brne	.+70     	; 0xfc5e <FMenuEDCTransaction+0x1b2>
		      IsMessage09=False;
    fc18:	10 92 a3 01 	sts	0x01A3, r1
	          procMessage09();
    fc1c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <procMessage09>
		      lcd_clear();
    fc20:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
    fc24:	81 e0       	ldi	r24, 0x01	; 1
    fc26:	61 e0       	ldi	r22, 0x01	; 1
    fc28:	42 e9       	ldi	r20, 0x92	; 146
    fc2a:	58 e0       	ldi	r21, 0x08	; 8
    fc2c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
    fc30:	82 e0       	ldi	r24, 0x02	; 2
    fc32:	61 e0       	ldi	r22, 0x01	; 1
    fc34:	43 ea       	ldi	r20, 0xA3	; 163
    fc36:	57 e0       	ldi	r21, 0x07	; 7
    fc38:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
    fc3c:	83 e0       	ldi	r24, 0x03	; 3
    fc3e:	61 e0       	ldi	r22, 0x01	; 1
    fc40:	4c e1       	ldi	r20, 0x1C	; 28
    fc42:	58 e0       	ldi	r21, 0x08	; 8
    fc44:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
    fc48:	84 e0       	ldi	r24, 0x04	; 4
    fc4a:	61 e0       	ldi	r22, 0x01	; 1
    fc4c:	46 ed       	ldi	r20, 0xD6	; 214
    fc4e:	5b e0       	ldi	r21, 0x0B	; 11
    fc50:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
    fc54:	02 c0       	rjmp	.+4      	; 0xfc5a <FMenuEDCTransaction+0x1ae>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    fc56:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  TimDisplay=0;
    fc5a:	10 92 92 01 	sts	0x0192, r1
		  stEtransaction=etDelayExit;
    fc5e:	89 e0       	ldi	r24, 0x09	; 9
    fc60:	d2 cf       	rjmp	.-92     	; 0xfc06 <FMenuEDCTransaction+0x15a>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    fc62:	80 91 92 01 	lds	r24, 0x0192
    fc66:	89 30       	cpi	r24, 0x09	; 9
    fc68:	30 f0       	brcs	.+12     	; 0xfc76 <FMenuEDCTransaction+0x1ca>
    fc6a:	8a e0       	ldi	r24, 0x0A	; 10
    fc6c:	cc cf       	rjmp	.-104    	; 0xfc06 <FMenuEDCTransaction+0x15a>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    fc6e:	10 92 62 02 	sts	0x0262, r1
    fc72:	81 e0       	ldi	r24, 0x01	; 1
    fc74:	01 c0       	rjmp	.+2      	; 0xfc78 <FMenuEDCTransaction+0x1cc>
    fc76:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    fc78:	1f 91       	pop	r17
    fc7a:	0f 91       	pop	r16
    fc7c:	08 95       	ret

0000fc7e <sendMessage58>:
	CardType=0;
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_58);
    fc7e:	88 e5       	ldi	r24, 0x58	; 88
    fc80:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
    fc84:	08 95       	ret

0000fc86 <sendMessage56>:
    uart_print(1, 0,strSend);	

	uart_printf(1,0,PSTR("AF968CFFB"));
	uart(1, 1,0x02);
	*/
	IFTSendMessage(MSG_56);
    fc86:	86 e5       	ldi	r24, 0x56	; 86
    fc88:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
    fc8c:	08 95       	ret

0000fc8e <FMenuLocalAccount>:
	 __key_lgtcnt = 0; 
	 PORTG=PORTG&0b11111101;
}


char FMenuLocalAccount(){
    fc8e:	6f 92       	push	r6
    fc90:	7f 92       	push	r7
    fc92:	8f 92       	push	r8
    fc94:	9f 92       	push	r9
    fc96:	af 92       	push	r10
    fc98:	bf 92       	push	r11
    fc9a:	cf 92       	push	r12
    fc9c:	df 92       	push	r13
    fc9e:	ef 92       	push	r14
    fca0:	ff 92       	push	r15
    fca2:	0f 93       	push	r16
    fca4:	1f 93       	push	r17
    fca6:	df 93       	push	r29
    fca8:	cf 93       	push	r28
    fcaa:	cd b7       	in	r28, 0x3d	; 61
    fcac:	de b7       	in	r29, 0x3e	; 62
    fcae:	e4 97       	sbiw	r28, 0x34	; 52
    fcb0:	0f b6       	in	r0, 0x3f	; 63
    fcb2:	f8 94       	cli
    fcb4:	de bf       	out	0x3e, r29	; 62
    fcb6:	0f be       	out	0x3f, r0	; 63
    fcb8:	cd bf       	out	0x3d, r28	; 61
       char ProductName[11],strName[21];//,strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
    fcba:	80 91 5b 01 	lds	r24, 0x015B
    fcbe:	90 e0       	ldi	r25, 0x00	; 0
    fcc0:	fc 01       	movw	r30, r24
    fcc2:	31 97       	sbiw	r30, 0x01	; 1
    fcc4:	ef 31       	cpi	r30, 0x1F	; 31
    fcc6:	f1 05       	cpc	r31, r1
    fcc8:	10 f0       	brcs	.+4      	; 0xfcce <FMenuLocalAccount+0x40>
    fcca:	0c 94 f3 86 	jmp	0x10de6	; 0x10de6 <FMenuLocalAccount+0x1158>
    fcce:	e8 57       	subi	r30, 0x78	; 120
    fcd0:	ff 4f       	sbci	r31, 0xFF	; 255
    fcd2:	ee 0f       	add	r30, r30
    fcd4:	ff 1f       	adc	r31, r31
    fcd6:	05 90       	lpm	r0, Z+
    fcd8:	f4 91       	lpm	r31, Z+
    fcda:	e0 2d       	mov	r30, r0
    fcdc:	09 94       	ijmp
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    fcde:	81 e0       	ldi	r24, 0x01	; 1
    fce0:	80 93 ae 02 	sts	0x02AE, r24
	 __key_lgtcnt = 0; 
    fce4:	10 92 af 02 	sts	0x02AF, r1
	 PORTG=PORTG&0b11111101;
    fce8:	80 91 65 00 	lds	r24, 0x0065
    fcec:	8d 7f       	andi	r24, 0xFD	; 253
    fcee:	80 93 65 00 	sts	0x0065, r24
    fcf2:	20 e0       	ldi	r18, 0x00	; 0
    fcf4:	30 e0       	ldi	r19, 0x00	; 0


void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    fcf6:	f9 01       	movw	r30, r18
    fcf8:	e7 57       	subi	r30, 0x77	; 119
    fcfa:	f4 4f       	sbci	r31, 0xF4	; 244
    fcfc:	d9 01       	movw	r26, r18
    fcfe:	af 5a       	subi	r26, 0xAF	; 175
    fd00:	b3 4f       	sbci	r27, 0xF3	; 243
    fd02:	8c 91       	ld	r24, X
    fd04:	80 83       	st	Z, r24
    fd06:	2f 5f       	subi	r18, 0xFF	; 255
    fd08:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    fd0a:	28 30       	cpi	r18, 0x08	; 8
    fd0c:	31 05       	cpc	r19, r1
    fd0e:	99 f7       	brne	.-26     	; 0xfcf6 <FMenuLocalAccount+0x68>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    fd10:	10 92 91 0b 	sts	0x0B91, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
    fd14:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
    fd18:	81 e0       	ldi	r24, 0x01	; 1
    fd1a:	61 e0       	ldi	r22, 0x01	; 1
    fd1c:	4c ef       	ldi	r20, 0xFC	; 252
    fd1e:	5f e1       	ldi	r21, 0x1F	; 31
    fd20:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
    fd24:	00 d0       	rcall	.+0      	; 0xfd26 <FMenuLocalAccount+0x98>
    fd26:	00 d0       	rcall	.+0      	; 0xfd28 <FMenuLocalAccount+0x9a>
    fd28:	00 d0       	rcall	.+0      	; 0xfd2a <FMenuLocalAccount+0x9c>
    fd2a:	ed b7       	in	r30, 0x3d	; 61
    fd2c:	fe b7       	in	r31, 0x3e	; 62
    fd2e:	31 96       	adiw	r30, 0x01	; 1
    fd30:	8e 01       	movw	r16, r28
    fd32:	04 5f       	subi	r16, 0xF4	; 244
    fd34:	1f 4f       	sbci	r17, 0xFF	; 255
    fd36:	ad b7       	in	r26, 0x3d	; 61
    fd38:	be b7       	in	r27, 0x3e	; 62
    fd3a:	12 96       	adiw	r26, 0x02	; 2
    fd3c:	1c 93       	st	X, r17
    fd3e:	0e 93       	st	-X, r16
    fd40:	11 97       	sbiw	r26, 0x01	; 1
    fd42:	86 ef       	ldi	r24, 0xF6	; 246
    fd44:	9f e1       	ldi	r25, 0x1F	; 31
    fd46:	93 83       	std	Z+3, r25	; 0x03
    fd48:	82 83       	std	Z+2, r24	; 0x02
    fd4a:	89 e8       	ldi	r24, 0x89	; 137
    fd4c:	9b e0       	ldi	r25, 0x0B	; 11
    fd4e:	95 83       	std	Z+5, r25	; 0x05
    fd50:	84 83       	std	Z+4, r24	; 0x04
    fd52:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    fd56:	ed b7       	in	r30, 0x3d	; 61
    fd58:	fe b7       	in	r31, 0x3e	; 62
    fd5a:	36 96       	adiw	r30, 0x06	; 6
    fd5c:	0f b6       	in	r0, 0x3f	; 63
    fd5e:	f8 94       	cli
    fd60:	fe bf       	out	0x3e, r31	; 62
    fd62:	0f be       	out	0x3f, r0	; 63
    fd64:	ed bf       	out	0x3d, r30	; 61
    fd66:	82 e0       	ldi	r24, 0x02	; 2
    fd68:	61 e0       	ldi	r22, 0x01	; 1
    fd6a:	a8 01       	movw	r20, r16
    fd6c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
    fd70:	83 e0       	ldi	r24, 0x03	; 3
    fd72:	61 e0       	ldi	r22, 0x01	; 1
    fd74:	4f ee       	ldi	r20, 0xEF	; 239
    fd76:	5f e1       	ldi	r21, 0x1F	; 31
    fd78:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				iPos=0;//iLoop=0;
    fd7c:	10 92 96 02 	sts	0x0296, r1
				IsFullAuthorized=False;
    fd80:	10 92 86 02 	sts	0x0286, r1
		        stLocalAccount=laSendID;
    fd84:	82 e0       	ldi	r24, 0x02	; 2
    fd86:	0b c0       	rjmp	.+22     	; 0xfd9e <FMenuLocalAccount+0x110>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
    fd88:	10 92 a5 01 	sts	0x01A5, r1
                sendMessage56();
    fd8c:	0e 94 43 7e 	call	0xfc86	; 0xfc86 <sendMessage56>
				iWait=0;iPos=0;
    fd90:	10 92 95 02 	sts	0x0295, r1
    fd94:	10 92 96 02 	sts	0x0296, r1
				//iLoop=0;
				TimSend=0;
    fd98:	10 92 78 0c 	sts	0x0C78, r1
				stLocalAccount=laWaitMessage57;
    fd9c:	83 e0       	ldi	r24, 0x03	; 3
    fd9e:	80 93 5b 01 	sts	0x015B, r24
    fda2:	0c 94 f3 86 	jmp	0x10de6	; 0x10de6 <FMenuLocalAccount+0x1158>
						 system_beep(2);
						 stLocalAccount=laConTimout;
				}
				*/
				
		        iLoop++;
    fda6:	80 91 84 02 	lds	r24, 0x0284
    fdaa:	90 91 85 02 	lds	r25, 0x0285
    fdae:	01 96       	adiw	r24, 0x01	; 1
    fdb0:	90 93 85 02 	sts	0x0285, r25
    fdb4:	80 93 84 02 	sts	0x0284, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
    fdb8:	68 e9       	ldi	r22, 0x98	; 152
    fdba:	7a e3       	ldi	r23, 0x3A	; 58
    fdbc:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
    fdc0:	89 2b       	or	r24, r25
    fdc2:	e1 f4       	brne	.+56     	; 0xfdfc <FMenuLocalAccount+0x16e>
				   if (iPos<5){
    fdc4:	60 91 96 02 	lds	r22, 0x0296
    fdc8:	65 30       	cpi	r22, 0x05	; 5
    fdca:	58 f4       	brcc	.+22     	; 0xfde2 <FMenuLocalAccount+0x154>
					   lcd_put(3,(8+iPos),'.');
    fdcc:	68 5f       	subi	r22, 0xF8	; 248
    fdce:	83 e0       	ldi	r24, 0x03	; 3
    fdd0:	4e e2       	ldi	r20, 0x2E	; 46
    fdd2:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
				       iPos++;
    fdd6:	80 91 96 02 	lds	r24, 0x0296
    fdda:	8f 5f       	subi	r24, 0xFF	; 255
    fddc:	80 93 96 02 	sts	0x0296, r24
    fde0:	0d c0       	rjmp	.+26     	; 0xfdfc <FMenuLocalAccount+0x16e>
					   }
				   else{
				       iPos=0;
    fde2:	10 92 96 02 	sts	0x0296, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
    fde6:	83 e0       	ldi	r24, 0x03	; 3
    fde8:	69 e0       	ldi	r22, 0x09	; 9
    fdea:	47 ee       	ldi	r20, 0xE7	; 231
    fdec:	5f e1       	ldi	r21, 0x1F	; 31
    fdee:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					   iWait++;
    fdf2:	80 91 95 02 	lds	r24, 0x0295
    fdf6:	8f 5f       	subi	r24, 0xFF	; 255
    fdf8:	80 93 95 02 	sts	0x0295, r24
					   }
				}
				if (iWait>3){
    fdfc:	80 91 95 02 	lds	r24, 0x0295
    fe00:	84 30       	cpi	r24, 0x04	; 4
    fe02:	50 f0       	brcs	.+20     	; 0xfe18 <FMenuLocalAccount+0x18a>
				    stLocalAccount=laConTimout;
    fe04:	84 e0       	ldi	r24, 0x04	; 4
    fe06:	80 93 5b 01 	sts	0x015B, r24
					TimLocAcc=0;
    fe0a:	10 92 ba 01 	sts	0x01BA, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    fe0e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    fe10:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    fe12:	82 e0       	ldi	r24, 0x02	; 2
    fe14:	80 93 bc 01 	sts	0x01BC, r24
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
                 
				if (IsMessage57==True){
    fe18:	80 91 a5 01 	lds	r24, 0x01A5
    fe1c:	81 30       	cpi	r24, 0x01	; 1
    fe1e:	09 f0       	breq	.+2      	; 0xfe22 <FMenuLocalAccount+0x194>
    fe20:	e2 c7       	rjmp	.+4036   	; 0x10de6 <FMenuLocalAccount+0x1158>
				    IsMessage57=False;
    fe22:	10 92 a5 01 	sts	0x01A5, r1
				    stLocalAccount=laProcMessage57;
    fe26:	85 e0       	ldi	r24, 0x05	; 5
    fe28:	ba cf       	rjmp	.-140    	; 0xfd9e <FMenuLocalAccount+0x110>
					}
		        break;
           case laConTimout:
		        //IsErrorTCPIP=True;
				lcd_printf(3,1,PSTR("Sending Failed      "));
    fe2a:	83 e0       	ldi	r24, 0x03	; 3
    fe2c:	61 e0       	ldi	r22, 0x01	; 1
    fe2e:	42 ed       	ldi	r20, 0xD2	; 210
    fe30:	5f e1       	ldi	r21, 0x1F	; 31
    fe32:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
    fe36:	84 e0       	ldi	r24, 0x04	; 4
    fe38:	61 e0       	ldi	r22, 0x01	; 1
    fe3a:	4d eb       	ldi	r20, 0xBD	; 189
    fe3c:	5f e1       	ldi	r21, 0x1F	; 31
    fe3e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
    fe42:	80 91 ba 01 	lds	r24, 0x01BA
    fe46:	83 30       	cpi	r24, 0x03	; 3
    fe48:	08 f4       	brcc	.+2      	; 0xfe4c <FMenuLocalAccount+0x1be>
    fe4a:	cd c7       	rjmp	.+3994   	; 0x10de6 <FMenuLocalAccount+0x1158>
    fe4c:	c2 c7       	rjmp	.+3972   	; 0x10dd2 <FMenuLocalAccount+0x1144>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
    fe4e:	83 e0       	ldi	r24, 0x03	; 3
    fe50:	61 e0       	ldi	r22, 0x01	; 1
    fe52:	48 ea       	ldi	r20, 0xA8	; 168
    fe54:	5f e1       	ldi	r21, 0x1F	; 31
    fe56:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
    fe5a:	0e 94 1c 24 	call	0x4838	; 0x4838 <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    fe5e:	81 30       	cpi	r24, 0x01	; 1
    fe60:	29 f0       	breq	.+10     	; 0xfe6c <FMenuLocalAccount+0x1de>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    fe62:	82 30       	cpi	r24, 0x02	; 2
    fe64:	19 f0       	breq	.+6      	; 0xfe6c <FMenuLocalAccount+0x1de>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    fe66:	83 30       	cpi	r24, 0x03	; 3
    fe68:	09 f0       	breq	.+2      	; 0xfe6c <FMenuLocalAccount+0x1de>
    fe6a:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
    fe6c:	80 93 97 02 	sts	0x0297, r24
				TimLocAcc=0;
    fe70:	10 92 ba 01 	sts	0x01BA, r1
				stLocalAccount=laDispStatus;
    fe74:	86 e0       	ldi	r24, 0x06	; 6
    fe76:	93 cf       	rjmp	.-218    	; 0xfd9e <FMenuLocalAccount+0x110>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
    fe78:	80 91 97 02 	lds	r24, 0x0297
    fe7c:	81 30       	cpi	r24, 0x01	; 1
    fe7e:	29 f4       	brne	.+10     	; 0xfe8a <FMenuLocalAccount+0x1fc>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
    fe80:	83 e0       	ldi	r24, 0x03	; 3
    fe82:	61 e0       	ldi	r22, 0x01	; 1
    fe84:	43 e9       	ldi	r20, 0x93	; 147
    fe86:	5f e1       	ldi	r21, 0x1F	; 31
    fe88:	0d c0       	rjmp	.+26     	; 0xfea4 <FMenuLocalAccount+0x216>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
    fe8a:	82 30       	cpi	r24, 0x02	; 2
    fe8c:	31 f4       	brne	.+12     	; 0xfe9a <FMenuLocalAccount+0x20c>
				    stLocalAccount=laDispValid; 
    fe8e:	87 e0       	ldi	r24, 0x07	; 7
    fe90:	80 93 5b 01 	sts	0x015B, r24
					lcd_clear();
    fe94:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
    fe98:	0c c0       	rjmp	.+24     	; 0xfeb2 <FMenuLocalAccount+0x224>
					}
				else
                if (LocAccStatus==LA_LIMITED){
    fe9a:	83 30       	cpi	r24, 0x03	; 3
    fe9c:	51 f4       	brne	.+20     	; 0xfeb2 <FMenuLocalAccount+0x224>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
    fe9e:	61 e0       	ldi	r22, 0x01	; 1
    fea0:	4e e7       	ldi	r20, 0x7E	; 126
    fea2:	5f e1       	ldi	r21, 0x1F	; 31
    fea4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					TimLocAcc=0;
    fea8:	10 92 ba 01 	sts	0x01BA, r1
				    stLocalAccount=laDelayExit;
    feac:	8e e1       	ldi	r24, 0x1E	; 30
    feae:	80 93 5b 01 	sts	0x015B, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
    feb2:	80 91 ba 01 	lds	r24, 0x01BA
    feb6:	86 30       	cpi	r24, 0x06	; 6
    feb8:	08 f4       	brcc	.+2      	; 0xfebc <FMenuLocalAccount+0x22e>
    feba:	95 c7       	rjmp	.+3882   	; 0x10de6 <FMenuLocalAccount+0x1158>
    febc:	8a c7       	rjmp	.+3860   	; 0x10dd2 <FMenuLocalAccount+0x1144>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
    febe:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
    fec2:	00 d0       	rcall	.+0      	; 0xfec4 <FMenuLocalAccount+0x236>
    fec4:	00 d0       	rcall	.+0      	; 0xfec6 <FMenuLocalAccount+0x238>
    fec6:	00 d0       	rcall	.+0      	; 0xfec8 <FMenuLocalAccount+0x23a>
    fec8:	ed b7       	in	r30, 0x3d	; 61
    feca:	fe b7       	in	r31, 0x3e	; 62
    fecc:	31 96       	adiw	r30, 0x01	; 1
    fece:	8f e1       	ldi	r24, 0x1F	; 31
    fed0:	9c e0       	ldi	r25, 0x0C	; 12
    fed2:	ad b7       	in	r26, 0x3d	; 61
    fed4:	be b7       	in	r27, 0x3e	; 62
    fed6:	12 96       	adiw	r26, 0x02	; 2
    fed8:	9c 93       	st	X, r25
    feda:	8e 93       	st	-X, r24
    fedc:	11 97       	sbiw	r26, 0x01	; 1
    fede:	8b e7       	ldi	r24, 0x7B	; 123
    fee0:	9f e1       	ldi	r25, 0x1F	; 31
    fee2:	93 83       	std	Z+3, r25	; 0x03
    fee4:	82 83       	std	Z+2, r24	; 0x02
    fee6:	08 ef       	ldi	r16, 0xF8	; 248
    fee8:	1b e0       	ldi	r17, 0x0B	; 11
    feea:	15 83       	std	Z+5, r17	; 0x05
    feec:	04 83       	std	Z+4, r16	; 0x04
    feee:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				FormatCurrency(strBalance);
    fef2:	ed b7       	in	r30, 0x3d	; 61
    fef4:	fe b7       	in	r31, 0x3e	; 62
    fef6:	36 96       	adiw	r30, 0x06	; 6
    fef8:	0f b6       	in	r0, 0x3f	; 63
    fefa:	f8 94       	cli
    fefc:	fe bf       	out	0x3e, r31	; 62
    fefe:	0f be       	out	0x3f, r0	; 63
    ff00:	ed bf       	out	0x3d, r30	; 61
    ff02:	c8 01       	movw	r24, r16
    ff04:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
    ff08:	20 e0       	ldi	r18, 0x00	; 0
    ff0a:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    ff0c:	90 e2       	ldi	r25, 0x20	; 32
    ff0e:	e9 2e       	mov	r14, r25
    ff10:	f1 2c       	mov	r15, r1
    ff12:	ec 0e       	add	r14, r28
    ff14:	fd 1e       	adc	r15, r29
    ff16:	f7 01       	movw	r30, r14
    ff18:	e2 0f       	add	r30, r18
    ff1a:	f3 1f       	adc	r31, r19
    ff1c:	d9 01       	movw	r26, r18
    ff1e:	ac 5d       	subi	r26, 0xDC	; 220
    ff20:	bc 4f       	sbci	r27, 0xFC	; 252
    ff22:	8c 91       	ld	r24, X
    ff24:	80 83       	st	Z, r24
    ff26:	2f 5f       	subi	r18, 0xFF	; 255
    ff28:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    ff2a:	24 31       	cpi	r18, 0x14	; 20
    ff2c:	31 05       	cpc	r19, r1
    ff2e:	99 f7       	brne	.-26     	; 0xff16 <FMenuLocalAccount+0x288>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    ff30:	1c aa       	std	Y+52, r1	; 0x34
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
    ff32:	00 d0       	rcall	.+0      	; 0xff34 <FMenuLocalAccount+0x2a6>
    ff34:	00 d0       	rcall	.+0      	; 0xff36 <FMenuLocalAccount+0x2a8>
    ff36:	00 d0       	rcall	.+0      	; 0xff38 <FMenuLocalAccount+0x2aa>
    ff38:	ed b7       	in	r30, 0x3d	; 61
    ff3a:	fe b7       	in	r31, 0x3e	; 62
    ff3c:	31 96       	adiw	r30, 0x01	; 1
    ff3e:	8e 01       	movw	r16, r28
    ff40:	04 5f       	subi	r16, 0xF4	; 244
    ff42:	1f 4f       	sbci	r17, 0xFF	; 255
    ff44:	ad b7       	in	r26, 0x3d	; 61
    ff46:	be b7       	in	r27, 0x3e	; 62
    ff48:	12 96       	adiw	r26, 0x02	; 2
    ff4a:	1c 93       	st	X, r17
    ff4c:	0e 93       	st	-X, r16
    ff4e:	11 97       	sbiw	r26, 0x01	; 1
    ff50:	88 e7       	ldi	r24, 0x78	; 120
    ff52:	9f e1       	ldi	r25, 0x1F	; 31
    ff54:	93 83       	std	Z+3, r25	; 0x03
    ff56:	82 83       	std	Z+2, r24	; 0x02
    ff58:	89 e7       	ldi	r24, 0x79	; 121
    ff5a:	97 e0       	ldi	r25, 0x07	; 7
    ff5c:	95 83       	std	Z+5, r25	; 0x05
    ff5e:	84 83       	std	Z+4, r24	; 0x04
    ff60:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    ff64:	ed b7       	in	r30, 0x3d	; 61
    ff66:	fe b7       	in	r31, 0x3e	; 62
    ff68:	36 96       	adiw	r30, 0x06	; 6
    ff6a:	0f b6       	in	r0, 0x3f	; 63
    ff6c:	f8 94       	cli
    ff6e:	fe bf       	out	0x3e, r31	; 62
    ff70:	0f be       	out	0x3f, r0	; 63
    ff72:	ed bf       	out	0x3d, r30	; 61
    ff74:	81 e0       	ldi	r24, 0x01	; 1
    ff76:	61 e0       	ldi	r22, 0x01	; 1
    ff78:	a8 01       	movw	r20, r16
    ff7a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
    ff7e:	00 d0       	rcall	.+0      	; 0xff80 <FMenuLocalAccount+0x2f2>
    ff80:	00 d0       	rcall	.+0      	; 0xff82 <FMenuLocalAccount+0x2f4>
    ff82:	00 d0       	rcall	.+0      	; 0xff84 <FMenuLocalAccount+0x2f6>
    ff84:	ed b7       	in	r30, 0x3d	; 61
    ff86:	fe b7       	in	r31, 0x3e	; 62
    ff88:	31 96       	adiw	r30, 0x01	; 1
    ff8a:	ad b7       	in	r26, 0x3d	; 61
    ff8c:	be b7       	in	r27, 0x3e	; 62
    ff8e:	12 96       	adiw	r26, 0x02	; 2
    ff90:	1c 93       	st	X, r17
    ff92:	0e 93       	st	-X, r16
    ff94:	11 97       	sbiw	r26, 0x01	; 1
    ff96:	85 e7       	ldi	r24, 0x75	; 117
    ff98:	9f e1       	ldi	r25, 0x1F	; 31
    ff9a:	93 83       	std	Z+3, r25	; 0x03
    ff9c:	82 83       	std	Z+2, r24	; 0x02
    ff9e:	f5 82       	std	Z+5, r15	; 0x05
    ffa0:	e4 82       	std	Z+4, r14	; 0x04
    ffa2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
    ffa6:	ed b7       	in	r30, 0x3d	; 61
    ffa8:	fe b7       	in	r31, 0x3e	; 62
    ffaa:	36 96       	adiw	r30, 0x06	; 6
    ffac:	0f b6       	in	r0, 0x3f	; 63
    ffae:	f8 94       	cli
    ffb0:	fe bf       	out	0x3e, r31	; 62
    ffb2:	0f be       	out	0x3f, r0	; 63
    ffb4:	ed bf       	out	0x3d, r30	; 61
    ffb6:	82 e0       	ldi	r24, 0x02	; 2
    ffb8:	61 e0       	ldi	r22, 0x01	; 1
    ffba:	a8 01       	movw	r20, r16
    ffbc:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
    ffc0:	2d b7       	in	r18, 0x3d	; 61
    ffc2:	3e b7       	in	r19, 0x3e	; 62
    ffc4:	28 50       	subi	r18, 0x08	; 8
    ffc6:	30 40       	sbci	r19, 0x00	; 0
    ffc8:	0f b6       	in	r0, 0x3f	; 63
    ffca:	f8 94       	cli
    ffcc:	3e bf       	out	0x3e, r19	; 62
    ffce:	0f be       	out	0x3f, r0	; 63
    ffd0:	2d bf       	out	0x3d, r18	; 61
    ffd2:	ed b7       	in	r30, 0x3d	; 61
    ffd4:	fe b7       	in	r31, 0x3e	; 62
    ffd6:	31 96       	adiw	r30, 0x01	; 1
    ffd8:	ad b7       	in	r26, 0x3d	; 61
    ffda:	be b7       	in	r27, 0x3e	; 62
    ffdc:	12 96       	adiw	r26, 0x02	; 2
    ffde:	1c 93       	st	X, r17
    ffe0:	0e 93       	st	-X, r16
    ffe2:	11 97       	sbiw	r26, 0x01	; 1
    ffe4:	8f e6       	ldi	r24, 0x6F	; 111
    ffe6:	9f e1       	ldi	r25, 0x1F	; 31
    ffe8:	93 83       	std	Z+3, r25	; 0x03
    ffea:	82 83       	std	Z+2, r24	; 0x02
    ffec:	8a ef       	ldi	r24, 0xFA	; 250
    ffee:	98 e0       	ldi	r25, 0x08	; 8
    fff0:	95 83       	std	Z+5, r25	; 0x05
    fff2:	84 83       	std	Z+4, r24	; 0x04
    fff4:	88 ef       	ldi	r24, 0xF8	; 248
    fff6:	9b e0       	ldi	r25, 0x0B	; 11
    fff8:	97 83       	std	Z+7, r25	; 0x07
    fffa:	86 83       	std	Z+6, r24	; 0x06
    fffc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10000:	ed b7       	in	r30, 0x3d	; 61
   10002:	fe b7       	in	r31, 0x3e	; 62
   10004:	38 96       	adiw	r30, 0x08	; 8
   10006:	0f b6       	in	r0, 0x3f	; 63
   10008:	f8 94       	cli
   1000a:	fe bf       	out	0x3e, r31	; 62
   1000c:	0f be       	out	0x3f, r0	; 63
   1000e:	ed bf       	out	0x3d, r30	; 61
   10010:	83 e0       	ldi	r24, 0x03	; 3
   10012:	61 e0       	ldi	r22, 0x01	; 1
   10014:	a8 01       	movw	r20, r16
   10016:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   1001a:	84 e0       	ldi	r24, 0x04	; 4
   1001c:	61 e0       	ldi	r22, 0x01	; 1
   1001e:	4a e5       	ldi	r20, 0x5A	; 90
   10020:	5f e1       	ldi	r21, 0x1F	; 31
   10022:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				stLocalAccount=laDispValidInput;
   10026:	88 e0       	ldi	r24, 0x08	; 8
   10028:	ba ce       	rjmp	.-652    	; 0xfd9e <FMenuLocalAccount+0x110>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   1002a:	81 e0       	ldi	r24, 0x01	; 1
   1002c:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   10030:	87 3b       	cpi	r24, 0xB7	; 183
   10032:	09 f4       	brne	.+2      	; 0x10036 <FMenuLocalAccount+0x3a8>
   10034:	bd c1       	rjmp	.+890    	; 0x103b0 <FMenuLocalAccount+0x722>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   10036:	87 3e       	cpi	r24, 0xE7	; 231
   10038:	09 f0       	breq	.+2      	; 0x1003c <FMenuLocalAccount+0x3ae>
   1003a:	d5 c6       	rjmp	.+3498   	; 0x10de6 <FMenuLocalAccount+0x1158>
   1003c:	ca c6       	rjmp	.+3476   	; 0x10dd2 <FMenuLocalAccount+0x1144>
		        break;
           case laSelectFIP:      
			    FIPResult=menu_FIP(&FIP_Used,strFIP);
   1003e:	01 e9       	ldi	r16, 0x91	; 145
   10040:	12 e0       	ldi	r17, 0x02	; 2
   10042:	88 e8       	ldi	r24, 0x88	; 136
   10044:	92 e0       	ldi	r25, 0x02	; 2
   10046:	b8 01       	movw	r22, r16
   10048:	0e 94 6e 53 	call	0xa6dc	; 0xa6dc <menu_FIP>

			    if ((FIPResult==FIP_DONE)&&(FIP_Used>0)){
   1004c:	88 23       	and	r24, r24
   1004e:	09 f0       	breq	.+2      	; 0x10052 <FMenuLocalAccount+0x3c4>
   10050:	50 c0       	rjmp	.+160    	; 0x100f2 <FMenuLocalAccount+0x464>
   10052:	20 91 88 02 	lds	r18, 0x0288
   10056:	22 23       	and	r18, r18
   10058:	09 f4       	brne	.+2      	; 0x1005c <FMenuLocalAccount+0x3ce>
   1005a:	c5 c6       	rjmp	.+3466   	; 0x10de6 <FMenuLocalAccount+0x1158>
                    sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   1005c:	00 d0       	rcall	.+0      	; 0x1005e <FMenuLocalAccount+0x3d0>
   1005e:	00 d0       	rcall	.+0      	; 0x10060 <FMenuLocalAccount+0x3d2>
   10060:	00 d0       	rcall	.+0      	; 0x10062 <FMenuLocalAccount+0x3d4>
   10062:	ed b7       	in	r30, 0x3d	; 61
   10064:	fe b7       	in	r31, 0x3e	; 62
   10066:	31 96       	adiw	r30, 0x01	; 1
   10068:	ad b7       	in	r26, 0x3d	; 61
   1006a:	be b7       	in	r27, 0x3e	; 62
   1006c:	12 96       	adiw	r26, 0x02	; 2
   1006e:	1c 93       	st	X, r17
   10070:	0e 93       	st	-X, r16
   10072:	11 97       	sbiw	r26, 0x01	; 1
   10074:	85 e5       	ldi	r24, 0x55	; 85
   10076:	9f e1       	ldi	r25, 0x1F	; 31
   10078:	93 83       	std	Z+3, r25	; 0x03
   1007a:	82 83       	std	Z+2, r24	; 0x02
   1007c:	24 83       	std	Z+4, r18	; 0x04
   1007e:	15 82       	std	Z+5, r1	; 0x05
   10080:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
					sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   10084:	ed b7       	in	r30, 0x3d	; 61
   10086:	fe b7       	in	r31, 0x3e	; 62
   10088:	31 96       	adiw	r30, 0x01	; 1
   1008a:	89 eb       	ldi	r24, 0xB9	; 185
   1008c:	97 e0       	ldi	r25, 0x07	; 7
   1008e:	ad b7       	in	r26, 0x3d	; 61
   10090:	be b7       	in	r27, 0x3e	; 62
   10092:	12 96       	adiw	r26, 0x02	; 2
   10094:	9c 93       	st	X, r25
   10096:	8e 93       	st	-X, r24
   10098:	11 97       	sbiw	r26, 0x01	; 1
   1009a:	80 e5       	ldi	r24, 0x50	; 80
   1009c:	9f e1       	ldi	r25, 0x1F	; 31
   1009e:	93 83       	std	Z+3, r25	; 0x03
   100a0:	82 83       	std	Z+2, r24	; 0x02
   100a2:	80 91 88 02 	lds	r24, 0x0288
   100a6:	84 83       	std	Z+4, r24	; 0x04
   100a8:	15 82       	std	Z+5, r1	; 0x05
   100aa:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
                    //Load Product Info
					if (GetFIPAddr(FIP_Used)>0) 
   100ae:	ed b7       	in	r30, 0x3d	; 61
   100b0:	fe b7       	in	r31, 0x3e	; 62
   100b2:	36 96       	adiw	r30, 0x06	; 6
   100b4:	0f b6       	in	r0, 0x3f	; 63
   100b6:	f8 94       	cli
   100b8:	fe bf       	out	0x3e, r31	; 62
   100ba:	0f be       	out	0x3f, r0	; 63
   100bc:	ed bf       	out	0x3d, r30	; 61
   100be:	80 91 88 02 	lds	r24, 0x0288
   100c2:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
   100c6:	88 23       	and	r24, r24
   100c8:	91 f0       	breq	.+36     	; 0x100ee <FMenuLocalAccount+0x460>
					    eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[GetFIPAddr(FIP_Used)-1], 6);
   100ca:	80 91 88 02 	lds	r24, 0x0288
   100ce:	0e 94 37 1c 	call	0x386e	; 0x386e <GetFIPAddr>
   100d2:	96 e0       	ldi	r25, 0x06	; 6
   100d4:	89 9f       	mul	r24, r25
   100d6:	b0 01       	movw	r22, r0
   100d8:	11 24       	eor	r1, r1
   100da:	61 5b       	subi	r22, 0xB1	; 177
   100dc:	7f 4f       	sbci	r23, 0xFF	; 255
   100de:	89 e8       	ldi	r24, 0x89	; 137
   100e0:	92 e0       	ldi	r25, 0x02	; 2
   100e2:	46 e0       	ldi	r20, 0x06	; 6
   100e4:	50 e0       	ldi	r21, 0x00	; 0
   100e6:	24 e4       	ldi	r18, 0x44	; 68
   100e8:	32 e1       	ldi	r19, 0x12	; 18
   100ea:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
				    stLocalAccount=laSelectProduct;
   100ee:	8b e0       	ldi	r24, 0x0B	; 11
   100f0:	56 ce       	rjmp	.-852    	; 0xfd9e <FMenuLocalAccount+0x110>
				}
			    else if (FIPResult==FIP_CANCEL){
   100f2:	82 30       	cpi	r24, 0x02	; 2
   100f4:	09 f0       	breq	.+2      	; 0x100f8 <FMenuLocalAccount+0x46a>
   100f6:	77 c6       	rjmp	.+3310   	; 0x10de6 <FMenuLocalAccount+0x1158>
				    stLocalAccount=laDispValid;
   100f8:	87 e0       	ldi	r24, 0x07	; 7
   100fa:	51 ce       	rjmp	.-862    	; 0xfd9e <FMenuLocalAccount+0x110>
		        break; 
           case laSelectFIPInput:

		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   100fc:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   10100:	00 d0       	rcall	.+0      	; 0x10102 <FMenuLocalAccount+0x474>
   10102:	00 d0       	rcall	.+0      	; 0x10104 <FMenuLocalAccount+0x476>
   10104:	00 d0       	rcall	.+0      	; 0x10106 <FMenuLocalAccount+0x478>
   10106:	ed b7       	in	r30, 0x3d	; 61
   10108:	fe b7       	in	r31, 0x3e	; 62
   1010a:	31 96       	adiw	r30, 0x01	; 1
   1010c:	8e 01       	movw	r16, r28
   1010e:	04 5f       	subi	r16, 0xF4	; 244
   10110:	1f 4f       	sbci	r17, 0xFF	; 255
   10112:	ad b7       	in	r26, 0x3d	; 61
   10114:	be b7       	in	r27, 0x3e	; 62
   10116:	12 96       	adiw	r26, 0x02	; 2
   10118:	1c 93       	st	X, r17
   1011a:	0e 93       	st	-X, r16
   1011c:	11 97       	sbiw	r26, 0x01	; 1
   1011e:	87 e4       	ldi	r24, 0x47	; 71
   10120:	9f e1       	ldi	r25, 0x1F	; 31
   10122:	93 83       	std	Z+3, r25	; 0x03
   10124:	82 83       	std	Z+2, r24	; 0x02
   10126:	81 e9       	ldi	r24, 0x91	; 145
   10128:	92 e0       	ldi	r25, 0x02	; 2
   1012a:	95 83       	std	Z+5, r25	; 0x05
   1012c:	84 83       	std	Z+4, r24	; 0x04
   1012e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10132:	ed b7       	in	r30, 0x3d	; 61
   10134:	fe b7       	in	r31, 0x3e	; 62
   10136:	36 96       	adiw	r30, 0x06	; 6
   10138:	0f b6       	in	r0, 0x3f	; 63
   1013a:	f8 94       	cli
   1013c:	fe bf       	out	0x3e, r31	; 62
   1013e:	0f be       	out	0x3f, r0	; 63
   10140:	ed bf       	out	0x3d, r30	; 61
   10142:	81 e0       	ldi	r24, 0x01	; 1
   10144:	61 e0       	ldi	r22, 0x01	; 1
   10146:	a8 01       	movw	r20, r16
   10148:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   1014c:	90 91 89 02 	lds	r25, 0x0289
   10150:	89 2f       	mov	r24, r25
   10152:	81 50       	subi	r24, 0x01	; 1
   10154:	86 30       	cpi	r24, 0x06	; 6
   10156:	08 f0       	brcs	.+2      	; 0x1015a <FMenuLocalAccount+0x4cc>
   10158:	4e c0       	rjmp	.+156    	; 0x101f6 <FMenuLocalAccount+0x568>
   1015a:	80 91 8a 02 	lds	r24, 0x028A
   1015e:	88 23       	and	r24, r24
   10160:	09 f0       	breq	.+2      	; 0x10164 <FMenuLocalAccount+0x4d6>
   10162:	49 c0       	rjmp	.+146    	; 0x101f6 <FMenuLocalAccount+0x568>
   10164:	80 91 8b 02 	lds	r24, 0x028B
   10168:	88 23       	and	r24, r24
   1016a:	09 f0       	breq	.+2      	; 0x1016e <FMenuLocalAccount+0x4e0>
   1016c:	44 c0       	rjmp	.+136    	; 0x101f6 <FMenuLocalAccount+0x568>
   1016e:	80 91 8c 02 	lds	r24, 0x028C
   10172:	88 23       	and	r24, r24
   10174:	09 f0       	breq	.+2      	; 0x10178 <FMenuLocalAccount+0x4ea>
   10176:	3f c0       	rjmp	.+126    	; 0x101f6 <FMenuLocalAccount+0x568>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   10178:	90 93 87 02 	sts	0x0287, r25
   1017c:	6d e0       	ldi	r22, 0x0D	; 13
   1017e:	96 9f       	mul	r25, r22
   10180:	b0 01       	movw	r22, r0
   10182:	11 24       	eor	r1, r1
   10184:	62 55       	subi	r22, 0x52	; 82
   10186:	7f 4f       	sbci	r23, 0xFF	; 255
   10188:	8e 01       	movw	r16, r28
   1018a:	0f 5f       	subi	r16, 0xFF	; 255
   1018c:	1f 4f       	sbci	r17, 0xFF	; 255
   1018e:	c8 01       	movw	r24, r16
   10190:	4a e0       	ldi	r20, 0x0A	; 10
   10192:	50 e0       	ldi	r21, 0x00	; 0
   10194:	24 e4       	ldi	r18, 0x44	; 68
   10196:	32 e1       	ldi	r19, 0x12	; 18
   10198:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1019c:	ce 01       	movw	r24, r28
   1019e:	09 96       	adiw	r24, 0x09	; 9
	    Dest[i]=Source[IdxSource+i];
   101a0:	0f 5f       	subi	r16, 0xFF	; 255
   101a2:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   101a4:	08 17       	cp	r16, r24
   101a6:	19 07       	cpc	r17, r25
   101a8:	d9 f7       	brne	.-10     	; 0x101a0 <FMenuLocalAccount+0x512>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   101aa:	19 86       	std	Y+9, r1	; 0x09
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   101ac:	00 d0       	rcall	.+0      	; 0x101ae <FMenuLocalAccount+0x520>
   101ae:	00 d0       	rcall	.+0      	; 0x101b0 <FMenuLocalAccount+0x522>
   101b0:	00 d0       	rcall	.+0      	; 0x101b2 <FMenuLocalAccount+0x524>
   101b2:	ed b7       	in	r30, 0x3d	; 61
   101b4:	fe b7       	in	r31, 0x3e	; 62
   101b6:	31 96       	adiw	r30, 0x01	; 1
   101b8:	8e e5       	ldi	r24, 0x5E	; 94
   101ba:	97 e0       	ldi	r25, 0x07	; 7
   101bc:	ad b7       	in	r26, 0x3d	; 61
   101be:	be b7       	in	r27, 0x3e	; 62
   101c0:	12 96       	adiw	r26, 0x02	; 2
   101c2:	9c 93       	st	X, r25
   101c4:	8e 93       	st	-X, r24
   101c6:	11 97       	sbiw	r26, 0x01	; 1
   101c8:	84 e4       	ldi	r24, 0x44	; 68
   101ca:	9f e1       	ldi	r25, 0x1F	; 31
   101cc:	93 83       	std	Z+3, r25	; 0x03
   101ce:	82 83       	std	Z+2, r24	; 0x02
   101d0:	ce 01       	movw	r24, r28
   101d2:	01 96       	adiw	r24, 0x01	; 1
   101d4:	95 83       	std	Z+5, r25	; 0x05
   101d6:	84 83       	std	Z+4, r24	; 0x04
   101d8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   101dc:	8d e0       	ldi	r24, 0x0D	; 13
   101de:	80 93 5b 01 	sts	0x015B, r24
   101e2:	80 e0       	ldi	r24, 0x00	; 0
   101e4:	ed b7       	in	r30, 0x3d	; 61
   101e6:	fe b7       	in	r31, 0x3e	; 62
   101e8:	36 96       	adiw	r30, 0x06	; 6
   101ea:	0f b6       	in	r0, 0x3f	; 63
   101ec:	f8 94       	cli
   101ee:	fe bf       	out	0x3e, r31	; 62
   101f0:	0f be       	out	0x3f, r0	; 63
   101f2:	ed bf       	out	0x3d, r30	; 61
   101f4:	f9 c5       	rjmp	.+3058   	; 0x10de8 <FMenuLocalAccount+0x115a>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   101f6:	10 92 8f 02 	sts	0x028F, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   101fa:	8c e0       	ldi	r24, 0x0C	; 12
   101fc:	e8 2e       	mov	r14, r24
   101fe:	f1 2c       	mov	r15, r1
   10200:	ec 0e       	add	r14, r28
   10202:	fd 1e       	adc	r15, r29
   10204:	08 e3       	ldi	r16, 0x38	; 56
   10206:	80 2e       	mov	r8, r16
   10208:	0f e1       	ldi	r16, 0x1F	; 31
   1020a:	90 2e       	mov	r9, r16
   1020c:	1d e0       	ldi	r17, 0x0D	; 13
   1020e:	61 2e       	mov	r6, r17
   10210:	8e 01       	movw	r16, r28
   10212:	0f 5f       	subi	r16, 0xFF	; 255
   10214:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10216:	b9 e0       	ldi	r27, 0x09	; 9
   10218:	ab 2e       	mov	r10, r27
   1021a:	b1 2c       	mov	r11, r1
   1021c:	ac 0e       	add	r10, r28
   1021e:	bd 1e       	adc	r11, r29
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   10220:	ae e3       	ldi	r26, 0x3E	; 62
   10222:	ca 2e       	mov	r12, r26
   10224:	af e1       	ldi	r26, 0x1F	; 31
   10226:	da 2e       	mov	r13, r26
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   10228:	fb e0       	ldi	r31, 0x0B	; 11
   1022a:	7f 2e       	mov	r7, r31
   1022c:	67 c0       	rjmp	.+206    	; 0x102fc <FMenuLocalAccount+0x66e>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   1022e:	f0 e0       	ldi	r31, 0x00	; 0
   10230:	e7 57       	subi	r30, 0x77	; 119
   10232:	fd 4f       	sbci	r31, 0xFD	; 253
   10234:	e0 81       	ld	r30, Z
   10236:	e0 93 87 02 	sts	0x0287, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   1023a:	8e 2f       	mov	r24, r30
   1023c:	81 50       	subi	r24, 0x01	; 1
   1023e:	86 30       	cpi	r24, 0x06	; 6
   10240:	c8 f5       	brcc	.+114    	; 0x102b4 <FMenuLocalAccount+0x626>
   10242:	e6 9d       	mul	r30, r6
   10244:	b0 01       	movw	r22, r0
   10246:	11 24       	eor	r1, r1
   10248:	62 55       	subi	r22, 0x52	; 82
   1024a:	7f 4f       	sbci	r23, 0xFF	; 255
   1024c:	c8 01       	movw	r24, r16
   1024e:	4a e0       	ldi	r20, 0x0A	; 10
   10250:	50 e0       	ldi	r21, 0x00	; 0
   10252:	24 e4       	ldi	r18, 0x44	; 68
   10254:	32 e1       	ldi	r19, 0x12	; 18
   10256:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
   1025a:	c8 01       	movw	r24, r16
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1025c:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1025e:	8a 15       	cp	r24, r10
   10260:	9b 05       	cpc	r25, r11
   10262:	e1 f7       	brne	.-8      	; 0x1025c <FMenuLocalAccount+0x5ce>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10264:	19 86       	std	Y+9, r1	; 0x09
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   10266:	2d b7       	in	r18, 0x3d	; 61
   10268:	3e b7       	in	r19, 0x3e	; 62
   1026a:	28 50       	subi	r18, 0x08	; 8
   1026c:	30 40       	sbci	r19, 0x00	; 0
   1026e:	0f b6       	in	r0, 0x3f	; 63
   10270:	f8 94       	cli
   10272:	3e bf       	out	0x3e, r19	; 62
   10274:	0f be       	out	0x3f, r0	; 63
   10276:	2d bf       	out	0x3d, r18	; 61
   10278:	ed b7       	in	r30, 0x3d	; 61
   1027a:	fe b7       	in	r31, 0x3e	; 62
   1027c:	31 96       	adiw	r30, 0x01	; 1
   1027e:	ad b7       	in	r26, 0x3d	; 61
   10280:	be b7       	in	r27, 0x3e	; 62
   10282:	12 96       	adiw	r26, 0x02	; 2
   10284:	fc 92       	st	X, r15
   10286:	ee 92       	st	-X, r14
   10288:	11 97       	sbiw	r26, 0x01	; 1
   1028a:	d3 82       	std	Z+3, r13	; 0x03
   1028c:	c2 82       	std	Z+2, r12	; 0x02
   1028e:	80 91 8f 02 	lds	r24, 0x028F
   10292:	90 e0       	ldi	r25, 0x00	; 0
   10294:	01 96       	adiw	r24, 0x01	; 1
   10296:	95 83       	std	Z+5, r25	; 0x05
   10298:	84 83       	std	Z+4, r24	; 0x04
   1029a:	17 83       	std	Z+7, r17	; 0x07
   1029c:	06 83       	std	Z+6, r16	; 0x06
   1029e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   102a2:	ed b7       	in	r30, 0x3d	; 61
   102a4:	fe b7       	in	r31, 0x3e	; 62
   102a6:	38 96       	adiw	r30, 0x08	; 8
   102a8:	0f b6       	in	r0, 0x3f	; 63
   102aa:	f8 94       	cli
   102ac:	fe bf       	out	0x3e, r31	; 62
   102ae:	0f be       	out	0x3f, r0	; 63
   102b0:	ed bf       	out	0x3d, r30	; 61
   102b2:	12 c0       	rjmp	.+36     	; 0x102d8 <FMenuLocalAccount+0x64a>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   102b4:	00 d0       	rcall	.+0      	; 0x102b6 <FMenuLocalAccount+0x628>
   102b6:	00 d0       	rcall	.+0      	; 0x102b8 <FMenuLocalAccount+0x62a>
   102b8:	ad b7       	in	r26, 0x3d	; 61
   102ba:	be b7       	in	r27, 0x3e	; 62
   102bc:	12 96       	adiw	r26, 0x02	; 2
   102be:	fc 92       	st	X, r15
   102c0:	ee 92       	st	-X, r14
   102c2:	11 97       	sbiw	r26, 0x01	; 1
   102c4:	14 96       	adiw	r26, 0x04	; 4
   102c6:	9c 92       	st	X, r9
   102c8:	8e 92       	st	-X, r8
   102ca:	13 97       	sbiw	r26, 0x03	; 3
   102cc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   102d0:	0f 90       	pop	r0
   102d2:	0f 90       	pop	r0
   102d4:	0f 90       	pop	r0
   102d6:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   102d8:	80 91 8f 02 	lds	r24, 0x028F
   102dc:	68 2f       	mov	r22, r24
   102de:	66 95       	lsr	r22
   102e0:	67 9d       	mul	r22, r7
   102e2:	b0 01       	movw	r22, r0
   102e4:	11 24       	eor	r1, r1
   102e6:	6f 5f       	subi	r22, 0xFF	; 255
   102e8:	81 70       	andi	r24, 0x01	; 1
   102ea:	8e 5f       	subi	r24, 0xFE	; 254
   102ec:	a7 01       	movw	r20, r14
   102ee:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   102f2:	80 91 8f 02 	lds	r24, 0x028F
   102f6:	8f 5f       	subi	r24, 0xFF	; 255
   102f8:	80 93 8f 02 	sts	0x028F, r24
   102fc:	e0 91 8f 02 	lds	r30, 0x028F
   10300:	e4 30       	cpi	r30, 0x04	; 4
   10302:	08 f4       	brcc	.+2      	; 0x10306 <FMenuLocalAccount+0x678>
   10304:	94 cf       	rjmp	.-216    	; 0x1022e <FMenuLocalAccount+0x5a0>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   10306:	84 e0       	ldi	r24, 0x04	; 4
   10308:	61 e0       	ldi	r22, 0x01	; 1
   1030a:	43 e2       	ldi	r20, 0x23	; 35
   1030c:	5f e1       	ldi	r21, 0x1F	; 31
   1030e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				stLocalAccount=laSelectProductInput;
   10312:	8c e0       	ldi	r24, 0x0C	; 12
   10314:	44 cd       	rjmp	.-1400   	; 0xfd9e <FMenuLocalAccount+0x110>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   10316:	81 e0       	ldi	r24, 0x01	; 1
   10318:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
   1031c:	e8 2e       	mov	r14, r24
			    KeyChar=_key_btn(KeyPressed);
   1031e:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
				if ((KeyChar>='1')&&(KeyChar<='4')){
   10322:	81 53       	subi	r24, 0x31	; 49
   10324:	84 30       	cpi	r24, 0x04	; 4
   10326:	08 f0       	brcs	.+2      	; 0x1032a <FMenuLocalAccount+0x69c>
   10328:	3f c0       	rjmp	.+126    	; 0x103a8 <FMenuLocalAccount+0x71a>
				    iNozzle=KeyChar-'1';
   1032a:	80 93 8f 02 	sts	0x028F, r24
   1032e:	e8 2f       	mov	r30, r24
   10330:	f0 e0       	ldi	r31, 0x00	; 0
   10332:	e7 57       	subi	r30, 0x77	; 119
   10334:	fd 4f       	sbci	r31, 0xFD	; 253
   10336:	60 81       	ld	r22, Z
   10338:	ed e0       	ldi	r30, 0x0D	; 13
   1033a:	fe 2e       	mov	r15, r30
   1033c:	6f 9d       	mul	r22, r15
   1033e:	b0 01       	movw	r22, r0
   10340:	11 24       	eor	r1, r1
   10342:	62 55       	subi	r22, 0x52	; 82
   10344:	7f 4f       	sbci	r23, 0xFF	; 255
   10346:	8e 01       	movw	r16, r28
   10348:	0f 5f       	subi	r16, 0xFF	; 255
   1034a:	1f 4f       	sbci	r17, 0xFF	; 255
   1034c:	c8 01       	movw	r24, r16
   1034e:	4a e0       	ldi	r20, 0x0A	; 10
   10350:	50 e0       	ldi	r21, 0x00	; 0
   10352:	24 e4       	ldi	r18, 0x44	; 68
   10354:	32 e1       	ldi	r19, 0x12	; 18
   10356:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   1035a:	00 d0       	rcall	.+0      	; 0x1035c <FMenuLocalAccount+0x6ce>
   1035c:	00 d0       	rcall	.+0      	; 0x1035e <FMenuLocalAccount+0x6d0>
   1035e:	00 d0       	rcall	.+0      	; 0x10360 <FMenuLocalAccount+0x6d2>
   10360:	ed b7       	in	r30, 0x3d	; 61
   10362:	fe b7       	in	r31, 0x3e	; 62
   10364:	31 96       	adiw	r30, 0x01	; 1
   10366:	8e e5       	ldi	r24, 0x5E	; 94
   10368:	97 e0       	ldi	r25, 0x07	; 7
   1036a:	ad b7       	in	r26, 0x3d	; 61
   1036c:	be b7       	in	r27, 0x3e	; 62
   1036e:	12 96       	adiw	r26, 0x02	; 2
   10370:	9c 93       	st	X, r25
   10372:	8e 93       	st	-X, r24
   10374:	11 97       	sbiw	r26, 0x01	; 1
   10376:	80 e2       	ldi	r24, 0x20	; 32
   10378:	9f e1       	ldi	r25, 0x1F	; 31
   1037a:	93 83       	std	Z+3, r25	; 0x03
   1037c:	82 83       	std	Z+2, r24	; 0x02
   1037e:	15 83       	std	Z+5, r17	; 0x05
   10380:	04 83       	std	Z+4, r16	; 0x04
   10382:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
					NozzleID=iNozzle+1;
   10386:	80 91 8f 02 	lds	r24, 0x028F
   1038a:	8f 5f       	subi	r24, 0xFF	; 255
   1038c:	80 93 6d 07 	sts	0x076D, r24
                    stLocalAccount=laSelectBalanceType;
   10390:	f0 92 5b 01 	sts	0x015B, r15
					lcd_clear();
   10394:	ed b7       	in	r30, 0x3d	; 61
   10396:	fe b7       	in	r31, 0x3e	; 62
   10398:	36 96       	adiw	r30, 0x06	; 6
   1039a:	0f b6       	in	r0, 0x3f	; 63
   1039c:	f8 94       	cli
   1039e:	fe bf       	out	0x3e, r31	; 62
   103a0:	0f be       	out	0x3f, r0	; 63
   103a2:	ed bf       	out	0x3d, r30	; 61
   103a4:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   103a8:	f7 ee       	ldi	r31, 0xE7	; 231
   103aa:	ef 16       	cp	r14, r31
   103ac:	09 f0       	breq	.+2      	; 0x103b0 <FMenuLocalAccount+0x722>
   103ae:	1b c5       	rjmp	.+2614   	; 0x10de6 <FMenuLocalAccount+0x1158>
   103b0:	89 e0       	ldi	r24, 0x09	; 9
   103b2:	f5 cc       	rjmp	.-1558   	; 0xfd9e <FMenuLocalAccount+0x110>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   103b4:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   103b8:	2d b7       	in	r18, 0x3d	; 61
   103ba:	3e b7       	in	r19, 0x3e	; 62
   103bc:	28 50       	subi	r18, 0x08	; 8
   103be:	30 40       	sbci	r19, 0x00	; 0
   103c0:	0f b6       	in	r0, 0x3f	; 63
   103c2:	f8 94       	cli
   103c4:	3e bf       	out	0x3e, r19	; 62
   103c6:	0f be       	out	0x3f, r0	; 63
   103c8:	2d bf       	out	0x3d, r18	; 61
   103ca:	ed b7       	in	r30, 0x3d	; 61
   103cc:	fe b7       	in	r31, 0x3e	; 62
   103ce:	31 96       	adiw	r30, 0x01	; 1
   103d0:	8e 01       	movw	r16, r28
   103d2:	04 5f       	subi	r16, 0xF4	; 244
   103d4:	1f 4f       	sbci	r17, 0xFF	; 255
   103d6:	ad b7       	in	r26, 0x3d	; 61
   103d8:	be b7       	in	r27, 0x3e	; 62
   103da:	12 96       	adiw	r26, 0x02	; 2
   103dc:	1c 93       	st	X, r17
   103de:	0e 93       	st	-X, r16
   103e0:	11 97       	sbiw	r26, 0x01	; 1
   103e2:	88 e1       	ldi	r24, 0x18	; 24
   103e4:	9f e1       	ldi	r25, 0x1F	; 31
   103e6:	93 83       	std	Z+3, r25	; 0x03
   103e8:	82 83       	std	Z+2, r24	; 0x02
   103ea:	81 e9       	ldi	r24, 0x91	; 145
   103ec:	92 e0       	ldi	r25, 0x02	; 2
   103ee:	95 83       	std	Z+5, r25	; 0x05
   103f0:	84 83       	std	Z+4, r24	; 0x04
   103f2:	8e e5       	ldi	r24, 0x5E	; 94
   103f4:	97 e0       	ldi	r25, 0x07	; 7
   103f6:	97 83       	std	Z+7, r25	; 0x07
   103f8:	86 83       	std	Z+6, r24	; 0x06
   103fa:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   103fe:	ed b7       	in	r30, 0x3d	; 61
   10400:	fe b7       	in	r31, 0x3e	; 62
   10402:	38 96       	adiw	r30, 0x08	; 8
   10404:	0f b6       	in	r0, 0x3f	; 63
   10406:	f8 94       	cli
   10408:	fe bf       	out	0x3e, r31	; 62
   1040a:	0f be       	out	0x3f, r0	; 63
   1040c:	ed bf       	out	0x3d, r30	; 61
   1040e:	81 e0       	ldi	r24, 0x01	; 1
   10410:	61 e0       	ldi	r22, 0x01	; 1
   10412:	a8 01       	movw	r20, r16
   10414:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   10418:	82 e0       	ldi	r24, 0x02	; 2
   1041a:	61 e0       	ldi	r22, 0x01	; 1
   1041c:	43 e0       	ldi	r20, 0x03	; 3
   1041e:	5f e1       	ldi	r21, 0x1F	; 31
   10420:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   10424:	83 e0       	ldi	r24, 0x03	; 3
   10426:	61 e0       	ldi	r22, 0x01	; 1
   10428:	4e ee       	ldi	r20, 0xEE	; 238
   1042a:	5e e1       	ldi	r21, 0x1E	; 30
   1042c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   10430:	84 e0       	ldi	r24, 0x04	; 4
   10432:	61 e0       	ldi	r22, 0x01	; 1
   10434:	49 ed       	ldi	r20, 0xD9	; 217
   10436:	5e e1       	ldi	r21, 0x1E	; 30
   10438:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   1043c:	8e e0       	ldi	r24, 0x0E	; 14
   1043e:	af cc       	rjmp	.-1698   	; 0xfd9e <FMenuLocalAccount+0x110>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   10440:	81 e0       	ldi	r24, 0x01	; 1
   10442:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
   10446:	18 2f       	mov	r17, r24
			    KeyChar=_key_btn(KeyPressed);
   10448:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
   1044c:	98 2f       	mov	r25, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   1044e:	81 53       	subi	r24, 0x31	; 49
   10450:	82 30       	cpi	r24, 0x02	; 2
   10452:	80 f5       	brcc	.+96     	; 0x104b4 <FMenuLocalAccount+0x826>
                    if(KeyChar=='1'){
   10454:	91 33       	cpi	r25, 0x31	; 49
   10456:	a1 f4       	brne	.+40     	; 0x10480 <FMenuLocalAccount+0x7f2>
					   BalanceType=1;
   10458:	81 e0       	ldi	r24, 0x01	; 1
   1045a:	80 93 94 02 	sts	0x0294, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   1045e:	00 d0       	rcall	.+0      	; 0x10460 <FMenuLocalAccount+0x7d2>
   10460:	00 d0       	rcall	.+0      	; 0x10462 <FMenuLocalAccount+0x7d4>
   10462:	83 ea       	ldi	r24, 0xA3	; 163
   10464:	93 e0       	ldi	r25, 0x03	; 3
   10466:	ad b7       	in	r26, 0x3d	; 61
   10468:	be b7       	in	r27, 0x3e	; 62
   1046a:	12 96       	adiw	r26, 0x02	; 2
   1046c:	9c 93       	st	X, r25
   1046e:	8e 93       	st	-X, r24
   10470:	11 97       	sbiw	r26, 0x01	; 1
   10472:	87 ed       	ldi	r24, 0xD7	; 215
   10474:	9e e1       	ldi	r25, 0x1E	; 30
   10476:	14 96       	adiw	r26, 0x04	; 4
   10478:	9c 93       	st	X, r25
   1047a:	8e 93       	st	-X, r24
   1047c:	13 97       	sbiw	r26, 0x03	; 3
   1047e:	11 c0       	rjmp	.+34     	; 0x104a2 <FMenuLocalAccount+0x814>
					   }
					else
                    if(KeyChar=='2'){
   10480:	92 33       	cpi	r25, 0x32	; 50
   10482:	a9 f4       	brne	.+42     	; 0x104ae <FMenuLocalAccount+0x820>
					   BalanceType=2;
   10484:	82 e0       	ldi	r24, 0x02	; 2
   10486:	80 93 94 02 	sts	0x0294, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   1048a:	00 d0       	rcall	.+0      	; 0x1048c <FMenuLocalAccount+0x7fe>
   1048c:	00 d0       	rcall	.+0      	; 0x1048e <FMenuLocalAccount+0x800>
   1048e:	83 ea       	ldi	r24, 0xA3	; 163
   10490:	93 e0       	ldi	r25, 0x03	; 3
   10492:	ed b7       	in	r30, 0x3d	; 61
   10494:	fe b7       	in	r31, 0x3e	; 62
   10496:	92 83       	std	Z+2, r25	; 0x02
   10498:	81 83       	std	Z+1, r24	; 0x01
   1049a:	85 ed       	ldi	r24, 0xD5	; 213
   1049c:	9e e1       	ldi	r25, 0x1E	; 30
   1049e:	94 83       	std	Z+4, r25	; 0x04
   104a0:	83 83       	std	Z+3, r24	; 0x03
   104a2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   104a6:	0f 90       	pop	r0
   104a8:	0f 90       	pop	r0
   104aa:	0f 90       	pop	r0
   104ac:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   104ae:	8f e0       	ldi	r24, 0x0F	; 15
   104b0:	80 93 5b 01 	sts	0x015B, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   104b4:	17 3e       	cpi	r17, 0xE7	; 231
   104b6:	c9 f4       	brne	.+50     	; 0x104ea <FMenuLocalAccount+0x85c>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   104b8:	80 91 89 02 	lds	r24, 0x0289
   104bc:	81 50       	subi	r24, 0x01	; 1
   104be:	86 30       	cpi	r24, 0x06	; 6
   104c0:	70 f4       	brcc	.+28     	; 0x104de <FMenuLocalAccount+0x850>
   104c2:	80 91 8a 02 	lds	r24, 0x028A
   104c6:	88 23       	and	r24, r24
   104c8:	51 f4       	brne	.+20     	; 0x104de <FMenuLocalAccount+0x850>
   104ca:	80 91 8b 02 	lds	r24, 0x028B
   104ce:	88 23       	and	r24, r24
   104d0:	31 f4       	brne	.+12     	; 0x104de <FMenuLocalAccount+0x850>
   104d2:	80 91 8c 02 	lds	r24, 0x028C
   104d6:	88 23       	and	r24, r24
   104d8:	11 f4       	brne	.+4      	; 0x104de <FMenuLocalAccount+0x850>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   104da:	89 e0       	ldi	r24, 0x09	; 9
   104dc:	01 c0       	rjmp	.+2      	; 0x104e0 <FMenuLocalAccount+0x852>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   104de:	8b e0       	ldi	r24, 0x0B	; 11
   104e0:	80 93 5b 01 	sts	0x015B, r24
					lcd_clear();
   104e4:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
   104e8:	7e c4       	rjmp	.+2300   	; 0x10de6 <FMenuLocalAccount+0x1158>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   104ea:	17 3b       	cpi	r17, 0xB7	; 183
   104ec:	09 f0       	breq	.+2      	; 0x104f0 <FMenuLocalAccount+0x862>
   104ee:	7b c4       	rjmp	.+2294   	; 0x10de6 <FMenuLocalAccount+0x1158>
				    BalanceType=1;
   104f0:	11 e0       	ldi	r17, 0x01	; 1
   104f2:	10 93 94 02 	sts	0x0294, r17
					sprintf_P(strBalanceType,PSTR("A"));
   104f6:	00 d0       	rcall	.+0      	; 0x104f8 <FMenuLocalAccount+0x86a>
   104f8:	00 d0       	rcall	.+0      	; 0x104fa <FMenuLocalAccount+0x86c>
   104fa:	83 ea       	ldi	r24, 0xA3	; 163
   104fc:	93 e0       	ldi	r25, 0x03	; 3
   104fe:	ad b7       	in	r26, 0x3d	; 61
   10500:	be b7       	in	r27, 0x3e	; 62
   10502:	12 96       	adiw	r26, 0x02	; 2
   10504:	9c 93       	st	X, r25
   10506:	8e 93       	st	-X, r24
   10508:	11 97       	sbiw	r26, 0x01	; 1
   1050a:	83 ed       	ldi	r24, 0xD3	; 211
   1050c:	9e e1       	ldi	r25, 0x1E	; 30
   1050e:	14 96       	adiw	r26, 0x04	; 4
   10510:	9c 93       	st	X, r25
   10512:	8e 93       	st	-X, r24
   10514:	13 97       	sbiw	r26, 0x03	; 3
   10516:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   1051a:	10 93 86 02 	sts	0x0286, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   1051e:	81 e1       	ldi	r24, 0x11	; 17
   10520:	80 93 5b 01 	sts	0x015B, r24
   10524:	80 e0       	ldi	r24, 0x00	; 0
   10526:	0f 90       	pop	r0
   10528:	0f 90       	pop	r0
   1052a:	0f 90       	pop	r0
   1052c:	0f 90       	pop	r0
   1052e:	5c c4       	rjmp	.+2232   	; 0x10de8 <FMenuLocalAccount+0x115a>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   10530:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		        if(BalanceType==1){
   10534:	80 91 94 02 	lds	r24, 0x0294
   10538:	81 30       	cpi	r24, 0x01	; 1
   1053a:	f1 f5       	brne	.+124    	; 0x105b8 <FMenuLocalAccount+0x92a>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1053c:	ed b7       	in	r30, 0x3d	; 61
   1053e:	fe b7       	in	r31, 0x3e	; 62
   10540:	38 97       	sbiw	r30, 0x08	; 8
   10542:	0f b6       	in	r0, 0x3f	; 63
   10544:	f8 94       	cli
   10546:	fe bf       	out	0x3e, r31	; 62
   10548:	0f be       	out	0x3f, r0	; 63
   1054a:	ed bf       	out	0x3d, r30	; 61
   1054c:	31 96       	adiw	r30, 0x01	; 1
   1054e:	8e 01       	movw	r16, r28
   10550:	04 5f       	subi	r16, 0xF4	; 244
   10552:	1f 4f       	sbci	r17, 0xFF	; 255
   10554:	ad b7       	in	r26, 0x3d	; 61
   10556:	be b7       	in	r27, 0x3e	; 62
   10558:	12 96       	adiw	r26, 0x02	; 2
   1055a:	1c 93       	st	X, r17
   1055c:	0e 93       	st	-X, r16
   1055e:	11 97       	sbiw	r26, 0x01	; 1
   10560:	8b ec       	ldi	r24, 0xCB	; 203
   10562:	9e e1       	ldi	r25, 0x1E	; 30
   10564:	93 83       	std	Z+3, r25	; 0x03
   10566:	82 83       	std	Z+2, r24	; 0x02
   10568:	81 e9       	ldi	r24, 0x91	; 145
   1056a:	92 e0       	ldi	r25, 0x02	; 2
   1056c:	95 83       	std	Z+5, r25	; 0x05
   1056e:	84 83       	std	Z+4, r24	; 0x04
   10570:	8e e5       	ldi	r24, 0x5E	; 94
   10572:	97 e0       	ldi	r25, 0x07	; 7
   10574:	97 83       	std	Z+7, r25	; 0x07
   10576:	86 83       	std	Z+6, r24	; 0x06
   10578:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   1057c:	ed b7       	in	r30, 0x3d	; 61
   1057e:	fe b7       	in	r31, 0x3e	; 62
   10580:	38 96       	adiw	r30, 0x08	; 8
   10582:	0f b6       	in	r0, 0x3f	; 63
   10584:	f8 94       	cli
   10586:	fe bf       	out	0x3e, r31	; 62
   10588:	0f be       	out	0x3f, r0	; 63
   1058a:	ed bf       	out	0x3d, r30	; 61
   1058c:	81 e0       	ldi	r24, 0x01	; 1
   1058e:	61 e0       	ldi	r22, 0x01	; 1
   10590:	a8 01       	movw	r20, r16
   10592:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   10596:	82 e0       	ldi	r24, 0x02	; 2
   10598:	61 e0       	ldi	r22, 0x01	; 1
   1059a:	46 eb       	ldi	r20, 0xB6	; 182
   1059c:	5e e1       	ldi	r21, 0x1E	; 30
   1059e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   105a2:	83 e0       	ldi	r24, 0x03	; 3
   105a4:	61 e0       	ldi	r22, 0x01	; 1
   105a6:	41 ea       	ldi	r20, 0xA1	; 161
   105a8:	5e e1       	ldi	r21, 0x1E	; 30
   105aa:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   105ae:	84 e0       	ldi	r24, 0x04	; 4
   105b0:	61 e0       	ldi	r22, 0x01	; 1
   105b2:	4c e8       	ldi	r20, 0x8C	; 140
   105b4:	5e e1       	ldi	r21, 0x1E	; 30
   105b6:	43 c0       	rjmp	.+134    	; 0x1063e <FMenuLocalAccount+0x9b0>
				   }
                else
		        if(BalanceType==2){
   105b8:	82 30       	cpi	r24, 0x02	; 2
   105ba:	09 f0       	breq	.+2      	; 0x105be <FMenuLocalAccount+0x930>
   105bc:	42 c0       	rjmp	.+132    	; 0x10642 <FMenuLocalAccount+0x9b4>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   105be:	2d b7       	in	r18, 0x3d	; 61
   105c0:	3e b7       	in	r19, 0x3e	; 62
   105c2:	28 50       	subi	r18, 0x08	; 8
   105c4:	30 40       	sbci	r19, 0x00	; 0
   105c6:	0f b6       	in	r0, 0x3f	; 63
   105c8:	f8 94       	cli
   105ca:	3e bf       	out	0x3e, r19	; 62
   105cc:	0f be       	out	0x3f, r0	; 63
   105ce:	2d bf       	out	0x3d, r18	; 61
   105d0:	ed b7       	in	r30, 0x3d	; 61
   105d2:	fe b7       	in	r31, 0x3e	; 62
   105d4:	31 96       	adiw	r30, 0x01	; 1
   105d6:	8e 01       	movw	r16, r28
   105d8:	04 5f       	subi	r16, 0xF4	; 244
   105da:	1f 4f       	sbci	r17, 0xFF	; 255
   105dc:	ad b7       	in	r26, 0x3d	; 61
   105de:	be b7       	in	r27, 0x3e	; 62
   105e0:	12 96       	adiw	r26, 0x02	; 2
   105e2:	1c 93       	st	X, r17
   105e4:	0e 93       	st	-X, r16
   105e6:	11 97       	sbiw	r26, 0x01	; 1
   105e8:	84 e8       	ldi	r24, 0x84	; 132
   105ea:	9e e1       	ldi	r25, 0x1E	; 30
   105ec:	93 83       	std	Z+3, r25	; 0x03
   105ee:	82 83       	std	Z+2, r24	; 0x02
   105f0:	81 e9       	ldi	r24, 0x91	; 145
   105f2:	92 e0       	ldi	r25, 0x02	; 2
   105f4:	95 83       	std	Z+5, r25	; 0x05
   105f6:	84 83       	std	Z+4, r24	; 0x04
   105f8:	8e e5       	ldi	r24, 0x5E	; 94
   105fa:	97 e0       	ldi	r25, 0x07	; 7
   105fc:	97 83       	std	Z+7, r25	; 0x07
   105fe:	86 83       	std	Z+6, r24	; 0x06
   10600:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   10604:	ed b7       	in	r30, 0x3d	; 61
   10606:	fe b7       	in	r31, 0x3e	; 62
   10608:	38 96       	adiw	r30, 0x08	; 8
   1060a:	0f b6       	in	r0, 0x3f	; 63
   1060c:	f8 94       	cli
   1060e:	fe bf       	out	0x3e, r31	; 62
   10610:	0f be       	out	0x3f, r0	; 63
   10612:	ed bf       	out	0x3d, r30	; 61
   10614:	81 e0       	ldi	r24, 0x01	; 1
   10616:	61 e0       	ldi	r22, 0x01	; 1
   10618:	a8 01       	movw	r20, r16
   1061a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   1061e:	82 e0       	ldi	r24, 0x02	; 2
   10620:	61 e0       	ldi	r22, 0x01	; 1
   10622:	4f e6       	ldi	r20, 0x6F	; 111
   10624:	5e e1       	ldi	r21, 0x1E	; 30
   10626:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   1062a:	83 e0       	ldi	r24, 0x03	; 3
   1062c:	61 e0       	ldi	r22, 0x01	; 1
   1062e:	4a e5       	ldi	r20, 0x5A	; 90
   10630:	5e e1       	ldi	r21, 0x1E	; 30
   10632:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   10636:	84 e0       	ldi	r24, 0x04	; 4
   10638:	61 e0       	ldi	r22, 0x01	; 1
   1063a:	45 e4       	ldi	r20, 0x45	; 69
   1063c:	5e e1       	ldi	r21, 0x1E	; 30
   1063e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				   }
                iLoop=0;
   10642:	10 92 85 02 	sts	0x0285, r1
   10646:	10 92 84 02 	sts	0x0284, r1
				iValuePos=0;
   1064a:	10 92 90 02 	sts	0x0290, r1
				//ValueChar[iValuePos]=' ';
		        stLocalAccount=laBalanceValueInput;  
   1064e:	80 e1       	ldi	r24, 0x10	; 16
   10650:	a6 cb       	rjmp	.-2228   	; 0xfd9e <FMenuLocalAccount+0x110>
		        break; 
           case laBalanceValueInput:
		        uiResult=UserInput(UI_NUMBER_R,(1+BalanceType),11,strBalanceValue,0,10); 
   10652:	60 91 94 02 	lds	r22, 0x0294
   10656:	6f 5f       	subi	r22, 0xFF	; 255
   10658:	81 e0       	ldi	r24, 0x01	; 1
   1065a:	4b e0       	ldi	r20, 0x0B	; 11
   1065c:	2f e1       	ldi	r18, 0x1F	; 31
   1065e:	3c e0       	ldi	r19, 0x0C	; 12
   10660:	00 e0       	ldi	r16, 0x00	; 0
   10662:	10 e0       	ldi	r17, 0x00	; 0
   10664:	7a e0       	ldi	r23, 0x0A	; 10
   10666:	e7 2e       	mov	r14, r23
   10668:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
				if (uiResult==USER_CANCEL){
   1066c:	81 30       	cpi	r24, 0x01	; 1
   1066e:	39 f4       	brne	.+14     	; 0x1067e <FMenuLocalAccount+0x9f0>
				    lcd_clear();
   10670:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
   10674:	88 ea       	ldi	r24, 0xA8	; 168
   10676:	91 e6       	ldi	r25, 0x61	; 97
   10678:	01 97       	sbiw	r24, 0x01	; 1
   1067a:	f1 f7       	brne	.-4      	; 0x10678 <FMenuLocalAccount+0x9ea>
   1067c:	f9 c0       	rjmp	.+498    	; 0x10870 <FMenuLocalAccount+0xbe2>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (uiResult==USER_OK){				    
   1067e:	83 30       	cpi	r24, 0x03	; 3
   10680:	09 f0       	breq	.+2      	; 0x10684 <FMenuLocalAccount+0x9f6>
   10682:	b1 c3       	rjmp	.+1890   	; 0x10de6 <FMenuLocalAccount+0x1158>
				    stLocalAccount=laOdometer;
   10684:	81 e1       	ldi	r24, 0x11	; 17
   10686:	80 93 5b 01 	sts	0x015B, r24
					lcd_clear();
   1068a:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
   1068e:	88 ea       	ldi	r24, 0xA8	; 168
   10690:	91 e6       	ldi	r25, 0x61	; 97
   10692:	01 97       	sbiw	r24, 0x01	; 1
   10694:	f1 f7       	brne	.-4      	; 0x10692 <FMenuLocalAccount+0xa04>
   10696:	a7 c3       	rjmp	.+1870   	; 0x10de6 <FMenuLocalAccount+0x1158>
					_delay_ms(100);		        
					}
*/
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   10698:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
				if (IsFullAuthorized==True){
   1069c:	80 91 86 02 	lds	r24, 0x0286
   106a0:	81 30       	cpi	r24, 0x01	; 1
   106a2:	09 f0       	breq	.+2      	; 0x106a6 <FMenuLocalAccount+0xa18>
   106a4:	4a c0       	rjmp	.+148    	; 0x1073a <FMenuLocalAccount+0xaac>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   106a6:	61 e0       	ldi	r22, 0x01	; 1
   106a8:	41 e3       	ldi	r20, 0x31	; 49
   106aa:	5e e1       	ldi	r21, 0x1E	; 30
   106ac:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   106b0:	2d b7       	in	r18, 0x3d	; 61
   106b2:	3e b7       	in	r19, 0x3e	; 62
   106b4:	28 50       	subi	r18, 0x08	; 8
   106b6:	30 40       	sbci	r19, 0x00	; 0
   106b8:	0f b6       	in	r0, 0x3f	; 63
   106ba:	f8 94       	cli
   106bc:	3e bf       	out	0x3e, r19	; 62
   106be:	0f be       	out	0x3f, r0	; 63
   106c0:	2d bf       	out	0x3d, r18	; 61
   106c2:	ed b7       	in	r30, 0x3d	; 61
   106c4:	fe b7       	in	r31, 0x3e	; 62
   106c6:	31 96       	adiw	r30, 0x01	; 1
   106c8:	8e 01       	movw	r16, r28
   106ca:	04 5f       	subi	r16, 0xF4	; 244
   106cc:	1f 4f       	sbci	r17, 0xFF	; 255
   106ce:	ad b7       	in	r26, 0x3d	; 61
   106d0:	be b7       	in	r27, 0x3e	; 62
   106d2:	12 96       	adiw	r26, 0x02	; 2
   106d4:	1c 93       	st	X, r17
   106d6:	0e 93       	st	-X, r16
   106d8:	11 97       	sbiw	r26, 0x01	; 1
   106da:	88 e2       	ldi	r24, 0x28	; 40
   106dc:	9e e1       	ldi	r25, 0x1E	; 30
   106de:	93 83       	std	Z+3, r25	; 0x03
   106e0:	82 83       	std	Z+2, r24	; 0x02
   106e2:	81 e9       	ldi	r24, 0x91	; 145
   106e4:	92 e0       	ldi	r25, 0x02	; 2
   106e6:	95 83       	std	Z+5, r25	; 0x05
   106e8:	84 83       	std	Z+4, r24	; 0x04
   106ea:	8e e5       	ldi	r24, 0x5E	; 94
   106ec:	97 e0       	ldi	r25, 0x07	; 7
   106ee:	97 83       	std	Z+7, r25	; 0x07
   106f0:	86 83       	std	Z+6, r24	; 0x06
   106f2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   106f6:	ed b7       	in	r30, 0x3d	; 61
   106f8:	fe b7       	in	r31, 0x3e	; 62
   106fa:	38 96       	adiw	r30, 0x08	; 8
   106fc:	0f b6       	in	r0, 0x3f	; 63
   106fe:	f8 94       	cli
   10700:	fe bf       	out	0x3e, r31	; 62
   10702:	0f be       	out	0x3f, r0	; 63
   10704:	ed bf       	out	0x3d, r30	; 61
   10706:	82 e0       	ldi	r24, 0x02	; 2
   10708:	61 e0       	ldi	r22, 0x01	; 1
   1070a:	a8 01       	movw	r20, r16
   1070c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   10710:	00 d0       	rcall	.+0      	; 0x10712 <FMenuLocalAccount+0xa84>
   10712:	00 d0       	rcall	.+0      	; 0x10714 <FMenuLocalAccount+0xa86>
   10714:	ad b7       	in	r26, 0x3d	; 61
   10716:	be b7       	in	r27, 0x3e	; 62
   10718:	12 96       	adiw	r26, 0x02	; 2
   1071a:	1c 93       	st	X, r17
   1071c:	0e 93       	st	-X, r16
   1071e:	11 97       	sbiw	r26, 0x01	; 1
   10720:	81 e2       	ldi	r24, 0x21	; 33
   10722:	9e e1       	ldi	r25, 0x1E	; 30
   10724:	14 96       	adiw	r26, 0x04	; 4
   10726:	9c 93       	st	X, r25
   10728:	8e 93       	st	-X, r24
   1072a:	13 97       	sbiw	r26, 0x03	; 3
   1072c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10730:	0f 90       	pop	r0
   10732:	0f 90       	pop	r0
   10734:	0f 90       	pop	r0
   10736:	0f 90       	pop	r0
   10738:	5e c0       	rjmp	.+188    	; 0x107f6 <FMenuLocalAccount+0xb68>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   1073a:	80 91 94 02 	lds	r24, 0x0294
   1073e:	81 30       	cpi	r24, 0x01	; 1
   10740:	29 f4       	brne	.+10     	; 0x1074c <FMenuLocalAccount+0xabe>
   10742:	61 e0       	ldi	r22, 0x01	; 1
   10744:	4d e0       	ldi	r20, 0x0D	; 13
   10746:	5e e1       	ldi	r21, 0x1E	; 30
   10748:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   1074c:	80 91 94 02 	lds	r24, 0x0294
   10750:	82 30       	cpi	r24, 0x02	; 2
   10752:	31 f4       	brne	.+12     	; 0x10760 <FMenuLocalAccount+0xad2>
   10754:	81 e0       	ldi	r24, 0x01	; 1
   10756:	61 e0       	ldi	r22, 0x01	; 1
   10758:	49 ef       	ldi	r20, 0xF9	; 249
   1075a:	5d e1       	ldi	r21, 0x1D	; 29
   1075c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   10760:	ed b7       	in	r30, 0x3d	; 61
   10762:	fe b7       	in	r31, 0x3e	; 62
   10764:	38 97       	sbiw	r30, 0x08	; 8
   10766:	0f b6       	in	r0, 0x3f	; 63
   10768:	f8 94       	cli
   1076a:	fe bf       	out	0x3e, r31	; 62
   1076c:	0f be       	out	0x3f, r0	; 63
   1076e:	ed bf       	out	0x3d, r30	; 61
   10770:	31 96       	adiw	r30, 0x01	; 1
   10772:	8e 01       	movw	r16, r28
   10774:	04 5f       	subi	r16, 0xF4	; 244
   10776:	1f 4f       	sbci	r17, 0xFF	; 255
   10778:	ad b7       	in	r26, 0x3d	; 61
   1077a:	be b7       	in	r27, 0x3e	; 62
   1077c:	12 96       	adiw	r26, 0x02	; 2
   1077e:	1c 93       	st	X, r17
   10780:	0e 93       	st	-X, r16
   10782:	11 97       	sbiw	r26, 0x01	; 1
   10784:	80 ef       	ldi	r24, 0xF0	; 240
   10786:	9d e1       	ldi	r25, 0x1D	; 29
   10788:	93 83       	std	Z+3, r25	; 0x03
   1078a:	82 83       	std	Z+2, r24	; 0x02
   1078c:	81 e9       	ldi	r24, 0x91	; 145
   1078e:	92 e0       	ldi	r25, 0x02	; 2
   10790:	95 83       	std	Z+5, r25	; 0x05
   10792:	84 83       	std	Z+4, r24	; 0x04
   10794:	8e e5       	ldi	r24, 0x5E	; 94
   10796:	97 e0       	ldi	r25, 0x07	; 7
   10798:	97 83       	std	Z+7, r25	; 0x07
   1079a:	86 83       	std	Z+6, r24	; 0x06
   1079c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   107a0:	ed b7       	in	r30, 0x3d	; 61
   107a2:	fe b7       	in	r31, 0x3e	; 62
   107a4:	38 96       	adiw	r30, 0x08	; 8
   107a6:	0f b6       	in	r0, 0x3f	; 63
   107a8:	f8 94       	cli
   107aa:	fe bf       	out	0x3e, r31	; 62
   107ac:	0f be       	out	0x3f, r0	; 63
   107ae:	ed bf       	out	0x3d, r30	; 61
   107b0:	82 e0       	ldi	r24, 0x02	; 2
   107b2:	61 e0       	ldi	r22, 0x01	; 1
   107b4:	a8 01       	movw	r20, r16
   107b6:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   107ba:	00 d0       	rcall	.+0      	; 0x107bc <FMenuLocalAccount+0xb2e>
   107bc:	00 d0       	rcall	.+0      	; 0x107be <FMenuLocalAccount+0xb30>
   107be:	00 d0       	rcall	.+0      	; 0x107c0 <FMenuLocalAccount+0xb32>
   107c0:	ed b7       	in	r30, 0x3d	; 61
   107c2:	fe b7       	in	r31, 0x3e	; 62
   107c4:	31 96       	adiw	r30, 0x01	; 1
   107c6:	ad b7       	in	r26, 0x3d	; 61
   107c8:	be b7       	in	r27, 0x3e	; 62
   107ca:	12 96       	adiw	r26, 0x02	; 2
   107cc:	1c 93       	st	X, r17
   107ce:	0e 93       	st	-X, r16
   107d0:	11 97       	sbiw	r26, 0x01	; 1
   107d2:	8c ee       	ldi	r24, 0xEC	; 236
   107d4:	9d e1       	ldi	r25, 0x1D	; 29
   107d6:	93 83       	std	Z+3, r25	; 0x03
   107d8:	82 83       	std	Z+2, r24	; 0x02
   107da:	8f e1       	ldi	r24, 0x1F	; 31
   107dc:	9c e0       	ldi	r25, 0x0C	; 12
   107de:	95 83       	std	Z+5, r25	; 0x05
   107e0:	84 83       	std	Z+4, r24	; 0x04
   107e2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   107e6:	ed b7       	in	r30, 0x3d	; 61
   107e8:	fe b7       	in	r31, 0x3e	; 62
   107ea:	36 96       	adiw	r30, 0x06	; 6
   107ec:	0f b6       	in	r0, 0x3f	; 63
   107ee:	f8 94       	cli
   107f0:	fe bf       	out	0x3e, r31	; 62
   107f2:	0f be       	out	0x3f, r0	; 63
   107f4:	ed bf       	out	0x3d, r30	; 61
   107f6:	82 e0       	ldi	r24, 0x02	; 2
   107f8:	6e e0       	ldi	r22, 0x0E	; 14
   107fa:	a8 01       	movw	r20, r16
   107fc:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   10800:	83 e0       	ldi	r24, 0x03	; 3
   10802:	61 e0       	ldi	r22, 0x01	; 1
   10804:	4a ed       	ldi	r20, 0xDA	; 218
   10806:	5d e1       	ldi	r21, 0x1D	; 29
   10808:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   1080c:	84 e0       	ldi	r24, 0x04	; 4
   1080e:	61 e0       	ldi	r22, 0x01	; 1
   10810:	48 ec       	ldi	r20, 0xC8	; 200
   10812:	5d e1       	ldi	r21, 0x1D	; 29
   10814:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				ClearMem(strOdometer);
   10818:	83 ec       	ldi	r24, 0xC3	; 195
   1081a:	93 e0       	ldi	r25, 0x03	; 3
   1081c:	0e 94 80 a4 	call	0x14900	; 0x14900 <ClearMem>
		        stLocalAccount=laOdometerInput;
   10820:	82 e1       	ldi	r24, 0x12	; 18
   10822:	bd ca       	rjmp	.-2694   	; 0xfd9e <FMenuLocalAccount+0x110>
		        break;
           case laOdometerInput:
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   10824:	63 ec       	ldi	r22, 0xC3	; 195
   10826:	c6 2e       	mov	r12, r22
   10828:	63 e0       	ldi	r22, 0x03	; 3
   1082a:	d6 2e       	mov	r13, r22
   1082c:	81 e0       	ldi	r24, 0x01	; 1
   1082e:	63 e0       	ldi	r22, 0x03	; 3
   10830:	4a e0       	ldi	r20, 0x0A	; 10
   10832:	96 01       	movw	r18, r12
   10834:	00 e0       	ldi	r16, 0x00	; 0
   10836:	10 e0       	ldi	r17, 0x00	; 0
   10838:	5a e0       	ldi	r21, 0x0A	; 10
   1083a:	e5 2e       	mov	r14, r21
   1083c:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
				if (uiResult==USER_OK){
   10840:	83 30       	cpi	r24, 0x03	; 3
   10842:	79 f4       	brne	.+30     	; 0x10862 <FMenuLocalAccount+0xbd4>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   10844:	f6 01       	movw	r30, r12
   10846:	01 90       	ld	r0, Z+
   10848:	00 20       	and	r0, r0
   1084a:	e9 f7       	brne	.-6      	; 0x10846 <FMenuLocalAccount+0xbb8>
   1084c:	e5 5c       	subi	r30, 0xC5	; 197
   1084e:	f3 40       	sbci	r31, 0x03	; 3
   10850:	31 f4       	brne	.+12     	; 0x1085e <FMenuLocalAccount+0xbd0>
   10852:	80 91 c3 03 	lds	r24, 0x03C3
   10856:	80 33       	cpi	r24, 0x30	; 48
   10858:	11 f4       	brne	.+4      	; 0x1085e <FMenuLocalAccount+0xbd0>
					    strOdometer[0]=0;
   1085a:	10 92 c3 03 	sts	0x03C3, r1
				    stLocalAccount=laDataConfirm;
   1085e:	83 e1       	ldi	r24, 0x13	; 19
   10860:	9e ca       	rjmp	.-2756   	; 0xfd9e <FMenuLocalAccount+0x110>
					}
			    else
			    if (uiResult==USER_CANCEL){
   10862:	81 30       	cpi	r24, 0x01	; 1
   10864:	09 f0       	breq	.+2      	; 0x10868 <FMenuLocalAccount+0xbda>
   10866:	bf c2       	rjmp	.+1406   	; 0x10de6 <FMenuLocalAccount+0x1158>
				    if (IsFullAuthorized==True)
   10868:	80 91 86 02 	lds	r24, 0x0286
   1086c:	81 30       	cpi	r24, 0x01	; 1
   1086e:	11 f4       	brne	.+4      	; 0x10874 <FMenuLocalAccount+0xbe6>
					     stLocalAccount=laSelectBalanceType;
   10870:	8d e0       	ldi	r24, 0x0D	; 13
   10872:	95 ca       	rjmp	.-2774   	; 0xfd9e <FMenuLocalAccount+0x110>
					else stLocalAccount=laBalanceValue;		        
   10874:	8f e0       	ldi	r24, 0x0F	; 15
   10876:	93 ca       	rjmp	.-2778   	; 0xfd9e <FMenuLocalAccount+0x110>
				 }
		        break;
           case laDataConfirm: 
		        lcd_clear();
   10878:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
   1087c:	ed e2       	ldi	r30, 0x2D	; 45
   1087e:	f3 e0       	ldi	r31, 0x03	; 3
   10880:	de 01       	movw	r26, r28
   10882:	90 96       	adiw	r26, 0x20	; 32
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   10884:	81 91       	ld	r24, Z+
   10886:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   10888:	33 e0       	ldi	r19, 0x03	; 3
   1088a:	e7 33       	cpi	r30, 0x37	; 55
   1088c:	f3 07       	cpc	r31, r19
   1088e:	d1 f7       	brne	.-12     	; 0x10884 <FMenuLocalAccount+0xbf6>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   10890:	1a a6       	std	Y+42, r1	; 0x2a
				 }
		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   10892:	00 d0       	rcall	.+0      	; 0x10894 <FMenuLocalAccount+0xc06>
   10894:	00 d0       	rcall	.+0      	; 0x10896 <FMenuLocalAccount+0xc08>
   10896:	00 d0       	rcall	.+0      	; 0x10898 <FMenuLocalAccount+0xc0a>
   10898:	ed b7       	in	r30, 0x3d	; 61
   1089a:	fe b7       	in	r31, 0x3e	; 62
   1089c:	31 96       	adiw	r30, 0x01	; 1
   1089e:	8e 01       	movw	r16, r28
   108a0:	04 5f       	subi	r16, 0xF4	; 244
   108a2:	1f 4f       	sbci	r17, 0xFF	; 255
   108a4:	ad b7       	in	r26, 0x3d	; 61
   108a6:	be b7       	in	r27, 0x3e	; 62
   108a8:	12 96       	adiw	r26, 0x02	; 2
   108aa:	1c 93       	st	X, r17
   108ac:	0e 93       	st	-X, r16
   108ae:	11 97       	sbiw	r26, 0x01	; 1
   108b0:	84 ec       	ldi	r24, 0xC4	; 196
   108b2:	9d e1       	ldi	r25, 0x1D	; 29
   108b4:	93 83       	std	Z+3, r25	; 0x03
   108b6:	82 83       	std	Z+2, r24	; 0x02
   108b8:	ce 01       	movw	r24, r28
   108ba:	80 96       	adiw	r24, 0x20	; 32
   108bc:	95 83       	std	Z+5, r25	; 0x05
   108be:	84 83       	std	Z+4, r24	; 0x04
   108c0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   108c4:	ed b7       	in	r30, 0x3d	; 61
   108c6:	fe b7       	in	r31, 0x3e	; 62
   108c8:	36 96       	adiw	r30, 0x06	; 6
   108ca:	0f b6       	in	r0, 0x3f	; 63
   108cc:	f8 94       	cli
   108ce:	fe bf       	out	0x3e, r31	; 62
   108d0:	0f be       	out	0x3f, r0	; 63
   108d2:	ed bf       	out	0x3d, r30	; 61
   108d4:	81 e0       	ldi	r24, 0x01	; 1
   108d6:	61 e0       	ldi	r22, 0x01	; 1
   108d8:	a8 01       	movw	r20, r16
   108da:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   108de:	00 d0       	rcall	.+0      	; 0x108e0 <FMenuLocalAccount+0xc52>
   108e0:	00 d0       	rcall	.+0      	; 0x108e2 <FMenuLocalAccount+0xc54>
   108e2:	00 d0       	rcall	.+0      	; 0x108e4 <FMenuLocalAccount+0xc56>
   108e4:	ed b7       	in	r30, 0x3d	; 61
   108e6:	fe b7       	in	r31, 0x3e	; 62
   108e8:	31 96       	adiw	r30, 0x01	; 1
   108ea:	ad b7       	in	r26, 0x3d	; 61
   108ec:	be b7       	in	r27, 0x3e	; 62
   108ee:	12 96       	adiw	r26, 0x02	; 2
   108f0:	1c 93       	st	X, r17
   108f2:	0e 93       	st	-X, r16
   108f4:	11 97       	sbiw	r26, 0x01	; 1
   108f6:	8d eb       	ldi	r24, 0xBD	; 189
   108f8:	9d e1       	ldi	r25, 0x1D	; 29
   108fa:	93 83       	std	Z+3, r25	; 0x03
   108fc:	82 83       	std	Z+2, r24	; 0x02
   108fe:	89 e8       	ldi	r24, 0x89	; 137
   10900:	9b e0       	ldi	r25, 0x0B	; 11
   10902:	95 83       	std	Z+5, r25	; 0x05
   10904:	84 83       	std	Z+4, r24	; 0x04
   10906:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   1090a:	ed b7       	in	r30, 0x3d	; 61
   1090c:	fe b7       	in	r31, 0x3e	; 62
   1090e:	36 96       	adiw	r30, 0x06	; 6
   10910:	0f b6       	in	r0, 0x3f	; 63
   10912:	f8 94       	cli
   10914:	fe bf       	out	0x3e, r31	; 62
   10916:	0f be       	out	0x3f, r0	; 63
   10918:	ed bf       	out	0x3d, r30	; 61
   1091a:	82 e0       	ldi	r24, 0x02	; 2
   1091c:	61 e0       	ldi	r22, 0x01	; 1
   1091e:	a8 01       	movw	r20, r16
   10920:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   10924:	2d b7       	in	r18, 0x3d	; 61
   10926:	3e b7       	in	r19, 0x3e	; 62
   10928:	28 50       	subi	r18, 0x08	; 8
   1092a:	30 40       	sbci	r19, 0x00	; 0
   1092c:	0f b6       	in	r0, 0x3f	; 63
   1092e:	f8 94       	cli
   10930:	3e bf       	out	0x3e, r19	; 62
   10932:	0f be       	out	0x3f, r0	; 63
   10934:	2d bf       	out	0x3d, r18	; 61
   10936:	ed b7       	in	r30, 0x3d	; 61
   10938:	fe b7       	in	r31, 0x3e	; 62
   1093a:	31 96       	adiw	r30, 0x01	; 1
   1093c:	ad b7       	in	r26, 0x3d	; 61
   1093e:	be b7       	in	r27, 0x3e	; 62
   10940:	12 96       	adiw	r26, 0x02	; 2
   10942:	1c 93       	st	X, r17
   10944:	0e 93       	st	-X, r16
   10946:	11 97       	sbiw	r26, 0x01	; 1
   10948:	85 eb       	ldi	r24, 0xB5	; 181
   1094a:	9d e1       	ldi	r25, 0x1D	; 29
   1094c:	93 83       	std	Z+3, r25	; 0x03
   1094e:	82 83       	std	Z+2, r24	; 0x02
   10950:	81 e9       	ldi	r24, 0x91	; 145
   10952:	92 e0       	ldi	r25, 0x02	; 2
   10954:	95 83       	std	Z+5, r25	; 0x05
   10956:	84 83       	std	Z+4, r24	; 0x04
   10958:	8e e5       	ldi	r24, 0x5E	; 94
   1095a:	97 e0       	ldi	r25, 0x07	; 7
   1095c:	97 83       	std	Z+7, r25	; 0x07
   1095e:	86 83       	std	Z+6, r24	; 0x06
   10960:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10964:	ed b7       	in	r30, 0x3d	; 61
   10966:	fe b7       	in	r31, 0x3e	; 62
   10968:	38 96       	adiw	r30, 0x08	; 8
   1096a:	0f b6       	in	r0, 0x3f	; 63
   1096c:	f8 94       	cli
   1096e:	fe bf       	out	0x3e, r31	; 62
   10970:	0f be       	out	0x3f, r0	; 63
   10972:	ed bf       	out	0x3d, r30	; 61
   10974:	83 e0       	ldi	r24, 0x03	; 3
   10976:	61 e0       	ldi	r22, 0x01	; 1
   10978:	a8 01       	movw	r20, r16
   1097a:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		        if (IsFullAuthorized==True){
   1097e:	80 91 86 02 	lds	r24, 0x0286
   10982:	81 30       	cpi	r24, 0x01	; 1
   10984:	39 f4       	brne	.+14     	; 0x10994 <FMenuLocalAccount+0xd06>
                    lcd_printf(3,15,PSTR(" Full"));
   10986:	83 e0       	ldi	r24, 0x03	; 3
   10988:	6f e0       	ldi	r22, 0x0F	; 15
   1098a:	4f ea       	ldi	r20, 0xAF	; 175
   1098c:	5d e1       	ldi	r21, 0x1D	; 29
   1098e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
   10992:	23 c0       	rjmp	.+70     	; 0x109da <FMenuLocalAccount+0xd4c>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   10994:	00 d0       	rcall	.+0      	; 0x10996 <FMenuLocalAccount+0xd08>
   10996:	00 d0       	rcall	.+0      	; 0x10998 <FMenuLocalAccount+0xd0a>
   10998:	00 d0       	rcall	.+0      	; 0x1099a <FMenuLocalAccount+0xd0c>
   1099a:	ed b7       	in	r30, 0x3d	; 61
   1099c:	fe b7       	in	r31, 0x3e	; 62
   1099e:	31 96       	adiw	r30, 0x01	; 1
   109a0:	ad b7       	in	r26, 0x3d	; 61
   109a2:	be b7       	in	r27, 0x3e	; 62
   109a4:	12 96       	adiw	r26, 0x02	; 2
   109a6:	1c 93       	st	X, r17
   109a8:	0e 93       	st	-X, r16
   109aa:	11 97       	sbiw	r26, 0x01	; 1
   109ac:	8b ea       	ldi	r24, 0xAB	; 171
   109ae:	9d e1       	ldi	r25, 0x1D	; 29
   109b0:	93 83       	std	Z+3, r25	; 0x03
   109b2:	82 83       	std	Z+2, r24	; 0x02
   109b4:	8f e1       	ldi	r24, 0x1F	; 31
   109b6:	9c e0       	ldi	r25, 0x0C	; 12
   109b8:	95 83       	std	Z+5, r25	; 0x05
   109ba:	84 83       	std	Z+4, r24	; 0x04
   109bc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   109c0:	ed b7       	in	r30, 0x3d	; 61
   109c2:	fe b7       	in	r31, 0x3e	; 62
   109c4:	36 96       	adiw	r30, 0x06	; 6
   109c6:	0f b6       	in	r0, 0x3f	; 63
   109c8:	f8 94       	cli
   109ca:	fe bf       	out	0x3e, r31	; 62
   109cc:	0f be       	out	0x3f, r0	; 63
   109ce:	ed bf       	out	0x3d, r30	; 61
   109d0:	83 e0       	ldi	r24, 0x03	; 3
   109d2:	6f e0       	ldi	r22, 0x0F	; 15
   109d4:	a8 01       	movw	r20, r16
   109d6:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   109da:	84 e0       	ldi	r24, 0x04	; 4
   109dc:	61 e0       	ldi	r22, 0x01	; 1
   109de:	46 e9       	ldi	r20, 0x96	; 150
   109e0:	5d e1       	ldi	r21, 0x1D	; 29
   109e2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   109e6:	84 e1       	ldi	r24, 0x14	; 20
   109e8:	da c9       	rjmp	.-3148   	; 0xfd9e <FMenuLocalAccount+0x110>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   109ea:	81 e0       	ldi	r24, 0x01	; 1
   109ec:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   109f0:	87 3e       	cpi	r24, 0xE7	; 231
   109f2:	11 f4       	brne	.+4      	; 0x109f8 <FMenuLocalAccount+0xd6a>
   109f4:	81 e1       	ldi	r24, 0x11	; 17
   109f6:	d3 c9       	rjmp	.-3162   	; 0xfd9e <FMenuLocalAccount+0x110>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   109f8:	87 3b       	cpi	r24, 0xB7	; 183
   109fa:	11 f4       	brne	.+4      	; 0x10a00 <FMenuLocalAccount+0xd72>
   109fc:	85 e1       	ldi	r24, 0x15	; 21
   109fe:	cf c9       	rjmp	.-3170   	; 0xfd9e <FMenuLocalAccount+0x110>
				else
				if (KeyPressed==_KEY_0){
   10a00:	87 3d       	cpi	r24, 0xD7	; 215
   10a02:	09 f0       	breq	.+2      	; 0x10a06 <FMenuLocalAccount+0xd78>
   10a04:	f0 c1       	rjmp	.+992    	; 0x10de6 <FMenuLocalAccount+0x1158>
				   //ShowCancel
				   TimLocAcc=0;
   10a06:	10 92 ba 01 	sts	0x01BA, r1
                   lcd_clear();
   10a0a:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   10a0e:	81 e0       	ldi	r24, 0x01	; 1
   10a10:	61 e0       	ldi	r22, 0x01	; 1
   10a12:	41 e8       	ldi	r20, 0x81	; 129
   10a14:	5d e1       	ldi	r21, 0x1D	; 29
   10a16:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
   10a1a:	d4 c1       	rjmp	.+936    	; 0x10dc4 <FMenuLocalAccount+0x1136>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   10a1c:	0e 94 3f 7e 	call	0xfc7e	; 0xfc7e <sendMessage58>
                RemZeroLead(strCardID);
   10a20:	89 e8       	ldi	r24, 0x89	; 137
   10a22:	9b e0       	ldi	r25, 0x0B	; 11
   10a24:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
                RemZeroLead(strBalanceValue);
   10a28:	3f e1       	ldi	r19, 0x1F	; 31
   10a2a:	e3 2e       	mov	r14, r19
   10a2c:	3c e0       	ldi	r19, 0x0C	; 12
   10a2e:	f3 2e       	mov	r15, r19
   10a30:	c7 01       	movw	r24, r14
   10a32:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   10a36:	2d b7       	in	r18, 0x3d	; 61
   10a38:	3e b7       	in	r19, 0x3e	; 62
   10a3a:	28 50       	subi	r18, 0x08	; 8
   10a3c:	30 40       	sbci	r19, 0x00	; 0
   10a3e:	0f b6       	in	r0, 0x3f	; 63
   10a40:	f8 94       	cli
   10a42:	3e bf       	out	0x3e, r19	; 62
   10a44:	0f be       	out	0x3f, r0	; 63
   10a46:	2d bf       	out	0x3d, r18	; 61
   10a48:	ed b7       	in	r30, 0x3d	; 61
   10a4a:	fe b7       	in	r31, 0x3e	; 62
   10a4c:	31 96       	adiw	r30, 0x01	; 1
   10a4e:	8e 01       	movw	r16, r28
   10a50:	04 5f       	subi	r16, 0xF4	; 244
   10a52:	1f 4f       	sbci	r17, 0xFF	; 255
   10a54:	ad b7       	in	r26, 0x3d	; 61
   10a56:	be b7       	in	r27, 0x3e	; 62
   10a58:	12 96       	adiw	r26, 0x02	; 2
   10a5a:	1c 93       	st	X, r17
   10a5c:	0e 93       	st	-X, r16
   10a5e:	11 97       	sbiw	r26, 0x01	; 1
   10a60:	89 e7       	ldi	r24, 0x79	; 121
   10a62:	9d e1       	ldi	r25, 0x1D	; 29
   10a64:	93 83       	std	Z+3, r25	; 0x03
   10a66:	82 83       	std	Z+2, r24	; 0x02
   10a68:	81 e9       	ldi	r24, 0x91	; 145
   10a6a:	92 e0       	ldi	r25, 0x02	; 2
   10a6c:	95 83       	std	Z+5, r25	; 0x05
   10a6e:	84 83       	std	Z+4, r24	; 0x04
   10a70:	8e e5       	ldi	r24, 0x5E	; 94
   10a72:	97 e0       	ldi	r25, 0x07	; 7
   10a74:	97 83       	std	Z+7, r25	; 0x07
   10a76:	86 83       	std	Z+6, r24	; 0x06
   10a78:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10a7c:	ed b7       	in	r30, 0x3d	; 61
   10a7e:	fe b7       	in	r31, 0x3e	; 62
   10a80:	38 96       	adiw	r30, 0x08	; 8
   10a82:	0f b6       	in	r0, 0x3f	; 63
   10a84:	f8 94       	cli
   10a86:	fe bf       	out	0x3e, r31	; 62
   10a88:	0f be       	out	0x3f, r0	; 63
   10a8a:	ed bf       	out	0x3d, r30	; 61
   10a8c:	81 e0       	ldi	r24, 0x01	; 1
   10a8e:	61 e0       	ldi	r22, 0x01	; 1
   10a90:	a8 01       	movw	r20, r16
   10a92:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   10a96:	00 d0       	rcall	.+0      	; 0x10a98 <FMenuLocalAccount+0xe0a>
   10a98:	00 d0       	rcall	.+0      	; 0x10a9a <FMenuLocalAccount+0xe0c>
   10a9a:	00 d0       	rcall	.+0      	; 0x10a9c <FMenuLocalAccount+0xe0e>
   10a9c:	ed b7       	in	r30, 0x3d	; 61
   10a9e:	fe b7       	in	r31, 0x3e	; 62
   10aa0:	31 96       	adiw	r30, 0x01	; 1
   10aa2:	ad b7       	in	r26, 0x3d	; 61
   10aa4:	be b7       	in	r27, 0x3e	; 62
   10aa6:	12 96       	adiw	r26, 0x02	; 2
   10aa8:	1c 93       	st	X, r17
   10aaa:	0e 93       	st	-X, r16
   10aac:	11 97       	sbiw	r26, 0x01	; 1
   10aae:	86 e7       	ldi	r24, 0x76	; 118
   10ab0:	9d e1       	ldi	r25, 0x1D	; 29
   10ab2:	93 83       	std	Z+3, r25	; 0x03
   10ab4:	82 83       	std	Z+2, r24	; 0x02
   10ab6:	f5 82       	std	Z+5, r15	; 0x05
   10ab8:	e4 82       	std	Z+4, r14	; 0x04
   10aba:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10abe:	ed b7       	in	r30, 0x3d	; 61
   10ac0:	fe b7       	in	r31, 0x3e	; 62
   10ac2:	36 96       	adiw	r30, 0x06	; 6
   10ac4:	0f b6       	in	r0, 0x3f	; 63
   10ac6:	f8 94       	cli
   10ac8:	fe bf       	out	0x3e, r31	; 62
   10aca:	0f be       	out	0x3f, r0	; 63
   10acc:	ed bf       	out	0x3d, r30	; 61
   10ace:	81 e0       	ldi	r24, 0x01	; 1
   10ad0:	6f e0       	ldi	r22, 0x0F	; 15
   10ad2:	a8 01       	movw	r20, r16
   10ad4:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   10ad8:	83 e0       	ldi	r24, 0x03	; 3
   10ada:	61 e0       	ldi	r22, 0x01	; 1
   10adc:	41 e6       	ldi	r20, 0x61	; 97
   10ade:	5d e1       	ldi	r21, 0x1D	; 29
   10ae0:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   10ae4:	84 e0       	ldi	r24, 0x04	; 4
   10ae6:	61 e0       	ldi	r22, 0x01	; 1
   10ae8:	4c e4       	ldi	r20, 0x4C	; 76
   10aea:	5d e1       	ldi	r21, 0x1D	; 29
   10aec:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				IsMessage00=False;
   10af0:	10 92 9e 01 	sts	0x019E, r1
				TimLocAcc=0;
   10af4:	10 92 ba 01 	sts	0x01BA, r1
				iLoop=0;iPos=0;iWait=0;
   10af8:	10 92 85 02 	sts	0x0285, r1
   10afc:	10 92 84 02 	sts	0x0284, r1
   10b00:	10 92 96 02 	sts	0x0296, r1
   10b04:	10 92 95 02 	sts	0x0295, r1
				stLocalAccount=laWaitMessage00;
   10b08:	87 e1       	ldi	r24, 0x17	; 23
   10b0a:	49 c9       	rjmp	.-3438   	; 0xfd9e <FMenuLocalAccount+0x110>
		        break;
           case laWaitMessage00:
                iLoop++;
   10b0c:	80 91 84 02 	lds	r24, 0x0284
   10b10:	90 91 85 02 	lds	r25, 0x0285
   10b14:	01 96       	adiw	r24, 0x01	; 1
   10b16:	90 93 85 02 	sts	0x0285, r25
   10b1a:	80 93 84 02 	sts	0x0284, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   10b1e:	68 e9       	ldi	r22, 0x98	; 152
   10b20:	7a e3       	ldi	r23, 0x3A	; 58
   10b22:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
   10b26:	89 2b       	or	r24, r25
   10b28:	e1 f4       	brne	.+56     	; 0x10b62 <FMenuLocalAccount+0xed4>
				   if (iPos<5){
   10b2a:	60 91 96 02 	lds	r22, 0x0296
   10b2e:	65 30       	cpi	r22, 0x05	; 5
   10b30:	58 f4       	brcc	.+22     	; 0x10b48 <FMenuLocalAccount+0xeba>
				       iPos++;
   10b32:	6f 5f       	subi	r22, 0xFF	; 255
   10b34:	60 93 96 02 	sts	0x0296, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   10b38:	62 5f       	subi	r22, 0xF2	; 242
   10b3a:	83 e0       	ldi	r24, 0x03	; 3
   10b3c:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
   10b40:	8e e2       	ldi	r24, 0x2E	; 46
   10b42:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
   10b46:	0d c0       	rjmp	.+26     	; 0x10b62 <FMenuLocalAccount+0xed4>
					   }
				   else{
				       iPos=0;
   10b48:	10 92 96 02 	sts	0x0296, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   10b4c:	83 e0       	ldi	r24, 0x03	; 3
   10b4e:	6e e0       	ldi	r22, 0x0E	; 14
   10b50:	44 e4       	ldi	r20, 0x44	; 68
   10b52:	5d e1       	ldi	r21, 0x1D	; 29
   10b54:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					   iWait++;
   10b58:	80 91 95 02 	lds	r24, 0x0295
   10b5c:	8f 5f       	subi	r24, 0xFF	; 255
   10b5e:	80 93 95 02 	sts	0x0295, r24
					   }
				}
				if (iWait>5){
   10b62:	80 91 95 02 	lds	r24, 0x0295
   10b66:	86 30       	cpi	r24, 0x06	; 6
   10b68:	50 f0       	brcs	.+20     	; 0x10b7e <FMenuLocalAccount+0xef0>
				    stLocalAccount=laConTimout;
   10b6a:	84 e0       	ldi	r24, 0x04	; 4
   10b6c:	80 93 5b 01 	sts	0x015B, r24
					TimLocAcc=0;
   10b70:	10 92 ba 01 	sts	0x01BA, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10b74:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10b76:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10b78:	82 e0       	ldi	r24, 0x02	; 2
   10b7a:	80 93 bc 01 	sts	0x01BC, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   10b7e:	80 91 9e 01 	lds	r24, 0x019E
   10b82:	81 30       	cpi	r24, 0x01	; 1
   10b84:	09 f0       	breq	.+2      	; 0x10b88 <FMenuLocalAccount+0xefa>
   10b86:	2f c1       	rjmp	.+606    	; 0x10de6 <FMenuLocalAccount+0x1158>
                    IsMessage00=False;
   10b88:	10 92 9e 01 	sts	0x019E, r1
				    stLocalAccount=laProcMessage00;
   10b8c:	88 e1       	ldi	r24, 0x18	; 24
   10b8e:	07 c9       	rjmp	.-3570   	; 0xfd9e <FMenuLocalAccount+0x110>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   10b90:	80 91 1d 09 	lds	r24, 0x091D
   10b94:	81 30       	cpi	r24, 0x01	; 1
   10b96:	51 f4       	brne	.+20     	; 0x10bac <FMenuLocalAccount+0xf1e>
   10b98:	80 91 8b 01 	lds	r24, 0x018B
   10b9c:	90 91 8c 01 	lds	r25, 0x018C
   10ba0:	8f 97       	sbiw	r24, 0x2f	; 47
   10ba2:	21 f4       	brne	.+8      	; 0x10bac <FMenuLocalAccount+0xf1e>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   10ba4:	80 91 42 09 	lds	r24, 0x0942
   10ba8:	80 53       	subi	r24, 0x30	; 48
   10baa:	01 c0       	rjmp	.+2      	; 0x10bae <FMenuLocalAccount+0xf20>
   10bac:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   10bae:	80 93 97 02 	sts	0x0297, r24
                lcd_clear();
   10bb2:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		        switch(LocAccStatus){
   10bb6:	10 91 97 02 	lds	r17, 0x0297
   10bba:	11 30       	cpi	r17, 0x01	; 1
   10bbc:	51 f0       	breq	.+20     	; 0x10bd2 <FMenuLocalAccount+0xf44>
   10bbe:	11 30       	cpi	r17, 0x01	; 1
   10bc0:	18 f0       	brcs	.+6      	; 0x10bc8 <FMenuLocalAccount+0xf3a>
   10bc2:	13 30       	cpi	r17, 0x03	; 3
   10bc4:	51 f5       	brne	.+84     	; 0x10c1a <FMenuLocalAccount+0xf8c>
   10bc6:	1b c0       	rjmp	.+54     	; 0x10bfe <FMenuLocalAccount+0xf70>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   10bc8:	82 e0       	ldi	r24, 0x02	; 2
   10bca:	61 e0       	ldi	r22, 0x01	; 1
   10bcc:	4f e2       	ldi	r20, 0x2F	; 47
   10bce:	5d e1       	ldi	r21, 0x1D	; 29
   10bd0:	1a c0       	rjmp	.+52     	; 0x10c06 <FMenuLocalAccount+0xf78>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   10bd2:	82 e0       	ldi	r24, 0x02	; 2
   10bd4:	61 e0       	ldi	r22, 0x01	; 1
   10bd6:	4a e1       	ldi	r20, 0x1A	; 26
   10bd8:	5d e1       	ldi	r21, 0x1D	; 29
   10bda:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   10bde:	90 91 8f 01 	lds	r25, 0x018F
   10be2:	e9 2f       	mov	r30, r25
   10be4:	f0 e0       	ldi	r31, 0x00	; 0
   10be6:	ea 5a       	subi	r30, 0xAA	; 170
   10be8:	fc 4f       	sbci	r31, 0xFC	; 252
   10bea:	80 91 88 02 	lds	r24, 0x0288
   10bee:	80 83       	st	Z, r24
					 nLocalAccount++;
   10bf0:	9f 5f       	subi	r25, 0xFF	; 255
   10bf2:	90 93 8f 01 	sts	0x018F, r25
					 IsViewFillingFIP=True;
   10bf6:	10 93 96 01 	sts	0x0196, r17
					 stLocalAccount=laViewStatus;
   10bfa:	86 e1       	ldi	r24, 0x16	; 22
   10bfc:	0c c0       	rjmp	.+24     	; 0x10c16 <FMenuLocalAccount+0xf88>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   10bfe:	82 e0       	ldi	r24, 0x02	; 2
   10c00:	61 e0       	ldi	r22, 0x01	; 1
   10c02:	47 e0       	ldi	r20, 0x07	; 7
   10c04:	5d e1       	ldi	r21, 0x1D	; 29
   10c06:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10c0a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10c0c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10c0e:	82 e0       	ldi	r24, 0x02	; 2
   10c10:	80 93 bc 01 	sts	0x01BC, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   10c14:	8e e1       	ldi	r24, 0x1E	; 30
   10c16:	80 93 5b 01 	sts	0x015B, r24
				     break;
				}
				TimLocAcc=0;
   10c1a:	10 92 ba 01 	sts	0x01BA, r1
				ClearMem(strOdometer);
   10c1e:	83 ec       	ldi	r24, 0xC3	; 195
   10c20:	93 e0       	ldi	r25, 0x03	; 3
   10c22:	0e 94 80 a4 	call	0x14900	; 0x14900 <ClearMem>
	            ClearMem(strLicPlate);
   10c26:	8a ef       	ldi	r24, 0xFA	; 250
   10c28:	98 e0       	ldi	r25, 0x08	; 8
   10c2a:	0e 94 80 a4 	call	0x14900	; 0x14900 <ClearMem>
   10c2e:	db c0       	rjmp	.+438    	; 0x10de6 <FMenuLocalAccount+0x1158>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   10c30:	80 91 ba 01 	lds	r24, 0x01BA
   10c34:	85 31       	cpi	r24, 0x15	; 21
   10c36:	08 f4       	brcc	.+2      	; 0x10c3a <FMenuLocalAccount+0xfac>
   10c38:	d6 c0       	rjmp	.+428    	; 0x10de6 <FMenuLocalAccount+0x1158>
   10c3a:	cb c0       	rjmp	.+406    	; 0x10dd2 <FMenuLocalAccount+0x1144>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   10c3c:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   10c40:	2d b7       	in	r18, 0x3d	; 61
   10c42:	3e b7       	in	r19, 0x3e	; 62
   10c44:	28 50       	subi	r18, 0x08	; 8
   10c46:	30 40       	sbci	r19, 0x00	; 0
   10c48:	0f b6       	in	r0, 0x3f	; 63
   10c4a:	f8 94       	cli
   10c4c:	3e bf       	out	0x3e, r19	; 62
   10c4e:	0f be       	out	0x3f, r0	; 63
   10c50:	2d bf       	out	0x3d, r18	; 61
   10c52:	ed b7       	in	r30, 0x3d	; 61
   10c54:	fe b7       	in	r31, 0x3e	; 62
   10c56:	31 96       	adiw	r30, 0x01	; 1
   10c58:	2c e0       	ldi	r18, 0x0C	; 12
   10c5a:	e2 2e       	mov	r14, r18
   10c5c:	f1 2c       	mov	r15, r1
   10c5e:	ec 0e       	add	r14, r28
   10c60:	fd 1e       	adc	r15, r29
   10c62:	ad b7       	in	r26, 0x3d	; 61
   10c64:	be b7       	in	r27, 0x3e	; 62
   10c66:	12 96       	adiw	r26, 0x02	; 2
   10c68:	fc 92       	st	X, r15
   10c6a:	ee 92       	st	-X, r14
   10c6c:	11 97       	sbiw	r26, 0x01	; 1
   10c6e:	8f ef       	ldi	r24, 0xFF	; 255
   10c70:	9c e1       	ldi	r25, 0x1C	; 28
   10c72:	93 83       	std	Z+3, r25	; 0x03
   10c74:	82 83       	std	Z+2, r24	; 0x02
   10c76:	81 e9       	ldi	r24, 0x91	; 145
   10c78:	92 e0       	ldi	r25, 0x02	; 2
   10c7a:	95 83       	std	Z+5, r25	; 0x05
   10c7c:	84 83       	std	Z+4, r24	; 0x04
   10c7e:	8e e5       	ldi	r24, 0x5E	; 94
   10c80:	97 e0       	ldi	r25, 0x07	; 7
   10c82:	97 83       	std	Z+7, r25	; 0x07
   10c84:	86 83       	std	Z+6, r24	; 0x06
   10c86:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10c8a:	ed b7       	in	r30, 0x3d	; 61
   10c8c:	fe b7       	in	r31, 0x3e	; 62
   10c8e:	38 96       	adiw	r30, 0x08	; 8
   10c90:	0f b6       	in	r0, 0x3f	; 63
   10c92:	f8 94       	cli
   10c94:	fe bf       	out	0x3e, r31	; 62
   10c96:	0f be       	out	0x3f, r0	; 63
   10c98:	ed bf       	out	0x3d, r30	; 61
   10c9a:	81 e0       	ldi	r24, 0x01	; 1
   10c9c:	61 e0       	ldi	r22, 0x01	; 1
   10c9e:	a7 01       	movw	r20, r14
   10ca0:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   10ca4:	00 d0       	rcall	.+0      	; 0x10ca6 <FMenuLocalAccount+0x1018>
   10ca6:	00 d0       	rcall	.+0      	; 0x10ca8 <FMenuLocalAccount+0x101a>
   10ca8:	00 d0       	rcall	.+0      	; 0x10caa <FMenuLocalAccount+0x101c>
   10caa:	ed b7       	in	r30, 0x3d	; 61
   10cac:	fe b7       	in	r31, 0x3e	; 62
   10cae:	31 96       	adiw	r30, 0x01	; 1
   10cb0:	ad b7       	in	r26, 0x3d	; 61
   10cb2:	be b7       	in	r27, 0x3e	; 62
   10cb4:	12 96       	adiw	r26, 0x02	; 2
   10cb6:	fc 92       	st	X, r15
   10cb8:	ee 92       	st	-X, r14
   10cba:	11 97       	sbiw	r26, 0x01	; 1
   10cbc:	8c ef       	ldi	r24, 0xFC	; 252
   10cbe:	9c e1       	ldi	r25, 0x1C	; 28
   10cc0:	93 83       	std	Z+3, r25	; 0x03
   10cc2:	82 83       	std	Z+2, r24	; 0x02
   10cc4:	8f e1       	ldi	r24, 0x1F	; 31
   10cc6:	9c e0       	ldi	r25, 0x0C	; 12
   10cc8:	95 83       	std	Z+5, r25	; 0x05
   10cca:	84 83       	std	Z+4, r24	; 0x04
   10ccc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10cd0:	ed b7       	in	r30, 0x3d	; 61
   10cd2:	fe b7       	in	r31, 0x3e	; 62
   10cd4:	36 96       	adiw	r30, 0x06	; 6
   10cd6:	0f b6       	in	r0, 0x3f	; 63
   10cd8:	f8 94       	cli
   10cda:	fe bf       	out	0x3e, r31	; 62
   10cdc:	0f be       	out	0x3f, r0	; 63
   10cde:	ed bf       	out	0x3d, r30	; 61
   10ce0:	81 e0       	ldi	r24, 0x01	; 1
   10ce2:	6f e0       	ldi	r22, 0x0F	; 15
   10ce4:	a7 01       	movw	r20, r14
   10ce6:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
                RemSpaceLead(strCardID);
   10cea:	09 e8       	ldi	r16, 0x89	; 137
   10cec:	1b e0       	ldi	r17, 0x0B	; 11
   10cee:	c8 01       	movw	r24, r16
   10cf0:	0e 94 87 23 	call	0x470e	; 0x470e <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   10cf4:	00 d0       	rcall	.+0      	; 0x10cf6 <FMenuLocalAccount+0x1068>
   10cf6:	00 d0       	rcall	.+0      	; 0x10cf8 <FMenuLocalAccount+0x106a>
   10cf8:	00 d0       	rcall	.+0      	; 0x10cfa <FMenuLocalAccount+0x106c>
   10cfa:	ed b7       	in	r30, 0x3d	; 61
   10cfc:	fe b7       	in	r31, 0x3e	; 62
   10cfe:	31 96       	adiw	r30, 0x01	; 1
   10d00:	ad b7       	in	r26, 0x3d	; 61
   10d02:	be b7       	in	r27, 0x3e	; 62
   10d04:	12 96       	adiw	r26, 0x02	; 2
   10d06:	fc 92       	st	X, r15
   10d08:	ee 92       	st	-X, r14
   10d0a:	11 97       	sbiw	r26, 0x01	; 1
   10d0c:	85 ef       	ldi	r24, 0xF5	; 245
   10d0e:	9c e1       	ldi	r25, 0x1C	; 28
   10d10:	93 83       	std	Z+3, r25	; 0x03
   10d12:	82 83       	std	Z+2, r24	; 0x02
   10d14:	15 83       	std	Z+5, r17	; 0x05
   10d16:	04 83       	std	Z+4, r16	; 0x04
   10d18:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   10d1c:	ed b7       	in	r30, 0x3d	; 61
   10d1e:	fe b7       	in	r31, 0x3e	; 62
   10d20:	36 96       	adiw	r30, 0x06	; 6
   10d22:	0f b6       	in	r0, 0x3f	; 63
   10d24:	f8 94       	cli
   10d26:	fe bf       	out	0x3e, r31	; 62
   10d28:	0f be       	out	0x3f, r0	; 63
   10d2a:	ed bf       	out	0x3d, r30	; 61
   10d2c:	82 e0       	ldi	r24, 0x02	; 2
   10d2e:	61 e0       	ldi	r22, 0x01	; 1
   10d30:	a7 01       	movw	r20, r14
   10d32:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
				TimLocAcc=0;
   10d36:	10 92 ba 01 	sts	0x01BA, r1
		        IsCompleteFilling=False;
   10d3a:	10 92 a9 01 	sts	0x01A9, r1
				stLocalAccount=laWaitFilling;
   10d3e:	8d e1       	ldi	r24, 0x1D	; 29
   10d40:	2e c8       	rjmp	.-4004   	; 0xfd9e <FMenuLocalAccount+0x110>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   10d42:	80 91 a9 01 	lds	r24, 0x01A9
   10d46:	81 30       	cpi	r24, 0x01	; 1
   10d48:	29 f0       	breq	.+10     	; 0x10d54 <FMenuLocalAccount+0x10c6>
   10d4a:	80 91 ba 01 	lds	r24, 0x01BA
   10d4e:	8b 30       	cpi	r24, 0x0B	; 11
   10d50:	08 f4       	brcc	.+2      	; 0x10d54 <FMenuLocalAccount+0x10c6>
   10d52:	49 c0       	rjmp	.+146    	; 0x10de6 <FMenuLocalAccount+0x1158>
				    IsCompleteFilling=False;
   10d54:	10 92 a9 01 	sts	0x01A9, r1
				    stLocalAccount=laSuccessTransaction;
   10d58:	89 e1       	ldi	r24, 0x19	; 25
   10d5a:	80 93 5b 01 	sts	0x015B, r24
					TimLocAcc=0;
   10d5e:	10 92 ba 01 	sts	0x01BA, r1
   10d62:	41 c0       	rjmp	.+130    	; 0x10de6 <FMenuLocalAccount+0x1158>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   10d64:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
   10d68:	82 e0       	ldi	r24, 0x02	; 2
   10d6a:	61 e0       	ldi	r22, 0x01	; 1
   10d6c:	43 ee       	ldi	r20, 0xE3	; 227
   10d6e:	5c e1       	ldi	r21, 0x1C	; 28
   10d70:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   10d74:	00 d0       	rcall	.+0      	; 0x10d76 <FMenuLocalAccount+0x10e8>
   10d76:	00 d0       	rcall	.+0      	; 0x10d78 <FMenuLocalAccount+0x10ea>
   10d78:	00 d0       	rcall	.+0      	; 0x10d7a <FMenuLocalAccount+0x10ec>
   10d7a:	ed b7       	in	r30, 0x3d	; 61
   10d7c:	fe b7       	in	r31, 0x3e	; 62
   10d7e:	31 96       	adiw	r30, 0x01	; 1
   10d80:	8e 01       	movw	r16, r28
   10d82:	04 5f       	subi	r16, 0xF4	; 244
   10d84:	1f 4f       	sbci	r17, 0xFF	; 255
   10d86:	ad b7       	in	r26, 0x3d	; 61
   10d88:	be b7       	in	r27, 0x3e	; 62
   10d8a:	12 96       	adiw	r26, 0x02	; 2
   10d8c:	1c 93       	st	X, r17
   10d8e:	0e 93       	st	-X, r16
   10d90:	11 97       	sbiw	r26, 0x01	; 1
   10d92:	82 ed       	ldi	r24, 0xD2	; 210
   10d94:	9c e1       	ldi	r25, 0x1C	; 28
   10d96:	93 83       	std	Z+3, r25	; 0x03
   10d98:	82 83       	std	Z+2, r24	; 0x02
   10d9a:	80 91 88 02 	lds	r24, 0x0288
   10d9e:	84 83       	std	Z+4, r24	; 0x04
   10da0:	15 82       	std	Z+5, r1	; 0x05
   10da2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				lcd_print(3,1,lcdteks);
   10da6:	ed b7       	in	r30, 0x3d	; 61
   10da8:	fe b7       	in	r31, 0x3e	; 62
   10daa:	36 96       	adiw	r30, 0x06	; 6
   10dac:	0f b6       	in	r0, 0x3f	; 63
   10dae:	f8 94       	cli
   10db0:	fe bf       	out	0x3e, r31	; 62
   10db2:	0f be       	out	0x3f, r0	; 63
   10db4:	ed bf       	out	0x3d, r30	; 61
   10db6:	83 e0       	ldi	r24, 0x03	; 3
   10db8:	61 e0       	ldi	r22, 0x01	; 1
   10dba:	a8 01       	movw	r20, r16
   10dbc:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   10dc0:	10 92 ba 01 	sts	0x01BA, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   10dc4:	8e e1       	ldi	r24, 0x1E	; 30
   10dc6:	0c 94 cf 7e 	jmp	0xfd9e	; 0xfd9e <FMenuLocalAccount+0x110>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   10dca:	80 91 ba 01 	lds	r24, 0x01BA
   10dce:	80 31       	cpi	r24, 0x10	; 16
   10dd0:	50 f0       	brcs	.+20     	; 0x10de6 <FMenuLocalAccount+0x1158>
   10dd2:	8f e1       	ldi	r24, 0x1F	; 31
   10dd4:	0c 94 cf 7e 	jmp	0xfd9e	; 0xfd9e <FMenuLocalAccount+0x110>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   10dd8:	81 e0       	ldi	r24, 0x01	; 1
   10dda:	80 93 5b 01 	sts	0x015B, r24
				lcd_clear();
   10dde:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
   10de2:	81 e0       	ldi	r24, 0x01	; 1
   10de4:	01 c0       	rjmp	.+2      	; 0x10de8 <FMenuLocalAccount+0x115a>
   10de6:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   10de8:	e4 96       	adiw	r28, 0x34	; 52
   10dea:	0f b6       	in	r0, 0x3f	; 63
   10dec:	f8 94       	cli
   10dee:	de bf       	out	0x3e, r29	; 62
   10df0:	0f be       	out	0x3f, r0	; 63
   10df2:	cd bf       	out	0x3d, r28	; 61
   10df4:	cf 91       	pop	r28
   10df6:	df 91       	pop	r29
   10df8:	1f 91       	pop	r17
   10dfa:	0f 91       	pop	r16
   10dfc:	ff 90       	pop	r15
   10dfe:	ef 90       	pop	r14
   10e00:	df 90       	pop	r13
   10e02:	cf 90       	pop	r12
   10e04:	bf 90       	pop	r11
   10e06:	af 90       	pop	r10
   10e08:	9f 90       	pop	r9
   10e0a:	8f 90       	pop	r8
   10e0c:	7f 90       	pop	r7
   10e0e:	6f 90       	pop	r6
   10e10:	08 95       	ret

00010e12 <sendMessage32>:
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    uart_print(1, 0,strSend);
	sprintf_P(strSend,PSTR("F968CFFB"));
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
*/IFTSendMessage(MSG_32);
   10e12:	82 e3       	ldi	r24, 0x32	; 50
   10e14:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
   10e18:	08 95       	ret

00010e1a <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   10e1a:	af 92       	push	r10
   10e1c:	bf 92       	push	r11
   10e1e:	cf 92       	push	r12
   10e20:	df 92       	push	r13
   10e22:	ef 92       	push	r14
   10e24:	ff 92       	push	r15
   10e26:	0f 93       	push	r16
   10e28:	1f 93       	push	r17
   10e2a:	df 93       	push	r29
   10e2c:	cf 93       	push	r28
   10e2e:	cd b7       	in	r28, 0x3d	; 61
   10e30:	de b7       	in	r29, 0x3e	; 62
   10e32:	a3 97       	sbiw	r28, 0x23	; 35
   10e34:	0f b6       	in	r0, 0x3f	; 63
   10e36:	f8 94       	cli
   10e38:	de bf       	out	0x3e, r29	; 62
   10e3a:	0f be       	out	0x3f, r0	; 63
   10e3c:	cd bf       	out	0x3d, r28	; 61
       char lcdteks[20],i,msgResult;       
	   char strBankName[11],strSurcharge[4],Result;
       char uiResult,KeyPressed=0,KeyChar,FIPResult;

     Result=MENU_NONE; 
	 switch(stChangeMOP){
   10e3e:	80 91 61 02 	lds	r24, 0x0261
   10e42:	e8 2f       	mov	r30, r24
   10e44:	f0 e0       	ldi	r31, 0x00	; 0
   10e46:	ee 31       	cpi	r30, 0x1E	; 30
   10e48:	f1 05       	cpc	r31, r1
   10e4a:	08 f0       	brcs	.+2      	; 0x10e4e <FMenuChangeMOP+0x34>
   10e4c:	0c c4       	rjmp	.+2072   	; 0x11666 <FMenuChangeMOP+0x84c>
   10e4e:	e9 55       	subi	r30, 0x59	; 89
   10e50:	ff 4f       	sbci	r31, 0xFF	; 255
   10e52:	ee 0f       	add	r30, r30
   10e54:	ff 1f       	adc	r31, r31
   10e56:	05 90       	lpm	r0, Z+
   10e58:	f4 91       	lpm	r31, Z+
   10e5a:	e0 2d       	mov	r30, r0
   10e5c:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   10e5e:	85 e0       	ldi	r24, 0x05	; 5
   10e60:	80 93 b8 01 	sts	0x01B8, r24
   10e64:	3c c1       	rjmp	.+632    	; 0x110de <FMenuChangeMOP+0x2c4>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   10e66:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   10e6a:	81 e0       	ldi	r24, 0x01	; 1
   10e6c:	61 e0       	ldi	r22, 0x01	; 1
   10e6e:	44 e3       	ldi	r20, 0x34	; 52
   10e70:	59 e1       	ldi	r21, 0x19	; 25
   10e72:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   10e76:	82 e0       	ldi	r24, 0x02	; 2
   10e78:	61 e0       	ldi	r22, 0x01	; 1
   10e7a:	4f e1       	ldi	r20, 0x1F	; 31
   10e7c:	59 e1       	ldi	r21, 0x19	; 25
   10e7e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   10e82:	83 e0       	ldi	r24, 0x03	; 3
   10e84:	61 e0       	ldi	r22, 0x01	; 1
   10e86:	4a e0       	ldi	r20, 0x0A	; 10
   10e88:	59 e1       	ldi	r21, 0x19	; 25
   10e8a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   10e8e:	84 e0       	ldi	r24, 0x04	; 4
   10e90:	61 e0       	ldi	r22, 0x01	; 1
   10e92:	45 ef       	ldi	r20, 0xF5	; 245
   10e94:	58 e1       	ldi	r21, 0x18	; 24
   10e96:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   10e9a:	82 e0       	ldi	r24, 0x02	; 2
   10e9c:	a2 c1       	rjmp	.+836    	; 0x111e2 <FMenuChangeMOP+0x3c8>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   10e9e:	81 e0       	ldi	r24, 0x01	; 1
   10ea0:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
   10ea4:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   10ea6:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
   10eaa:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   10eac:	81 53       	subi	r24, 0x31	; 49
   10eae:	84 30       	cpi	r24, 0x04	; 4
   10eb0:	f0 f4       	brcc	.+60     	; 0x10eee <FMenuChangeMOP+0xd4>
              switch(KeyChar){
   10eb2:	92 33       	cpi	r25, 0x32	; 50
   10eb4:	61 f0       	breq	.+24     	; 0x10ece <FMenuChangeMOP+0xb4>
   10eb6:	93 33       	cpi	r25, 0x33	; 51
   10eb8:	18 f4       	brcc	.+6      	; 0x10ec0 <FMenuChangeMOP+0xa6>
   10eba:	91 33       	cpi	r25, 0x31	; 49
   10ebc:	c1 f4       	brne	.+48     	; 0x10eee <FMenuChangeMOP+0xd4>
   10ebe:	05 c0       	rjmp	.+10     	; 0x10eca <FMenuChangeMOP+0xb0>
   10ec0:	93 33       	cpi	r25, 0x33	; 51
   10ec2:	51 f0       	breq	.+20     	; 0x10ed8 <FMenuChangeMOP+0xbe>
   10ec4:	94 33       	cpi	r25, 0x34	; 52
   10ec6:	99 f4       	brne	.+38     	; 0x10eee <FMenuChangeMOP+0xd4>
   10ec8:	0c c0       	rjmp	.+24     	; 0x10ee2 <FMenuChangeMOP+0xc8>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   10eca:	81 e0       	ldi	r24, 0x01	; 1
   10ecc:	0b c0       	rjmp	.+22     	; 0x10ee4 <FMenuChangeMOP+0xca>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   10ece:	82 e0       	ldi	r24, 0x02	; 2
   10ed0:	80 93 b8 01 	sts	0x01B8, r24
   10ed4:	8b e0       	ldi	r24, 0x0B	; 11
   10ed6:	09 c0       	rjmp	.+18     	; 0x10eea <FMenuChangeMOP+0xd0>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   10ed8:	83 e0       	ldi	r24, 0x03	; 3
   10eda:	80 93 b8 01 	sts	0x01B8, r24
   10ede:	8f e0       	ldi	r24, 0x0F	; 15
   10ee0:	04 c0       	rjmp	.+8      	; 0x10eea <FMenuChangeMOP+0xd0>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   10ee2:	84 e0       	ldi	r24, 0x04	; 4
   10ee4:	80 93 b8 01 	sts	0x01B8, r24
   10ee8:	89 e0       	ldi	r24, 0x09	; 9
   10eea:	80 93 61 02 	sts	0x0261, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   10eee:	17 3e       	cpi	r17, 0xE7	; 231
   10ef0:	09 f0       	breq	.+2      	; 0x10ef4 <FMenuChangeMOP+0xda>
   10ef2:	b9 c3       	rjmp	.+1906   	; 0x11666 <FMenuChangeMOP+0x84c>
   10ef4:	b0 c3       	rjmp	.+1888   	; 0x11656 <FMenuChangeMOP+0x83c>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   10ef6:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   10efa:	81 e0       	ldi	r24, 0x01	; 1
   10efc:	61 e0       	ldi	r22, 0x01	; 1
   10efe:	48 ee       	ldi	r20, 0xE8	; 232
   10f00:	58 e1       	ldi	r21, 0x18	; 24
   10f02:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   10f06:	82 e0       	ldi	r24, 0x02	; 2
   10f08:	61 e0       	ldi	r22, 0x01	; 1
   10f0a:	46 ee       	ldi	r20, 0xE6	; 230
   10f0c:	58 e1       	ldi	r21, 0x18	; 24
   10f0e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f12:	84 e0       	ldi	r24, 0x04	; 4
   10f14:	61 e0       	ldi	r22, 0x01	; 1
   10f16:	41 ed       	ldi	r20, 0xD1	; 209
   10f18:	58 e1       	ldi	r21, 0x18	; 24
   10f1a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
   10f1e:	ec e3       	ldi	r30, 0x3C	; 60
   10f20:	fc e0       	ldi	r31, 0x0C	; 12
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   10f22:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10f24:	8c e0       	ldi	r24, 0x0C	; 12
   10f26:	e1 35       	cpi	r30, 0x51	; 81
   10f28:	f8 07       	cpc	r31, r24
   10f2a:	d9 f7       	brne	.-10     	; 0x10f22 <FMenuChangeMOP+0x108>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;		  
   10f2c:	87 e0       	ldi	r24, 0x07	; 7
   10f2e:	59 c1       	rjmp	.+690    	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   10f30:	81 e0       	ldi	r24, 0x01	; 1
   10f32:	62 e0       	ldi	r22, 0x02	; 2
   10f34:	41 e0       	ldi	r20, 0x01	; 1
   10f36:	2c e3       	ldi	r18, 0x3C	; 60
   10f38:	3c e0       	ldi	r19, 0x0C	; 12
   10f3a:	00 e0       	ldi	r16, 0x00	; 0
   10f3c:	10 e0       	ldi	r17, 0x00	; 0
   10f3e:	5d e0       	ldi	r21, 0x0D	; 13
   10f40:	e5 2e       	mov	r14, r21
   10f42:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
	      if (uiResult==USER_OK){
   10f46:	83 30       	cpi	r24, 0x03	; 3
   10f48:	11 f4       	brne	.+4      	; 0x10f4e <FMenuChangeMOP+0x134>
		     stChangeMOP=cmSelectFIP;
   10f4a:	89 e0       	ldi	r24, 0x09	; 9
   10f4c:	4a c1       	rjmp	.+660    	; 0x111e2 <FMenuChangeMOP+0x3c8>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   10f4e:	81 30       	cpi	r24, 0x01	; 1
   10f50:	09 f4       	brne	.+2      	; 0x10f54 <FMenuChangeMOP+0x13a>
   10f52:	47 c1       	rjmp	.+654    	; 0x111e2 <FMenuChangeMOP+0x3c8>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10f54:	84 30       	cpi	r24, 0x04	; 4
   10f56:	21 f4       	brne	.+8      	; 0x10f60 <FMenuChangeMOP+0x146>
   10f58:	61 e0       	ldi	r22, 0x01	; 1
   10f5a:	4c eb       	ldi	r20, 0xBC	; 188
   10f5c:	58 e1       	ldi	r21, 0x18	; 24
   10f5e:	29 c1       	rjmp	.+594    	; 0x111b2 <FMenuChangeMOP+0x398>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f60:	85 30       	cpi	r24, 0x05	; 5
   10f62:	09 f0       	breq	.+2      	; 0x10f66 <FMenuChangeMOP+0x14c>
   10f64:	80 c3       	rjmp	.+1792   	; 0x11666 <FMenuChangeMOP+0x84c>
   10f66:	84 e0       	ldi	r24, 0x04	; 4
   10f68:	61 e0       	ldi	r22, 0x01	; 1
   10f6a:	47 ea       	ldi	r20, 0xA7	; 167
   10f6c:	58 e1       	ldi	r21, 0x18	; 24
   10f6e:	21 c1       	rjmp	.+578    	; 0x111b2 <FMenuChangeMOP+0x398>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   10f70:	80 e6       	ldi	r24, 0x60	; 96
   10f72:	92 e0       	ldi	r25, 0x02	; 2
   10f74:	69 eb       	ldi	r22, 0xB9	; 185
   10f76:	77 e0       	ldi	r23, 0x07	; 7
   10f78:	0e 94 6e 53 	call	0xa6dc	; 0xa6dc <menu_FIP>
		  if (FIPResult==FIP_DONE){
   10f7c:	88 23       	and	r24, r24
   10f7e:	11 f4       	brne	.+4      	; 0x10f84 <FMenuChangeMOP+0x16a>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   10f80:	8e e0       	ldi	r24, 0x0E	; 14
   10f82:	2f c1       	rjmp	.+606    	; 0x111e2 <FMenuChangeMOP+0x3c8>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   10f84:	82 30       	cpi	r24, 0x02	; 2
   10f86:	09 f0       	breq	.+2      	; 0x10f8a <FMenuChangeMOP+0x170>
   10f88:	6e c3       	rjmp	.+1756   	; 0x11666 <FMenuChangeMOP+0x84c>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   10f8a:	80 91 b8 01 	lds	r24, 0x01B8
   10f8e:	81 30       	cpi	r24, 0x01	; 1
   10f90:	09 f4       	brne	.+2      	; 0x10f94 <FMenuChangeMOP+0x17a>
   10f92:	27 c1       	rjmp	.+590    	; 0x111e2 <FMenuChangeMOP+0x3c8>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   10f94:	82 30       	cpi	r24, 0x02	; 2
   10f96:	09 f4       	brne	.+2      	; 0x10f9a <FMenuChangeMOP+0x180>
   10f98:	fd c0       	rjmp	.+506    	; 0x11194 <FMenuChangeMOP+0x37a>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   10f9a:	83 30       	cpi	r24, 0x03	; 3
   10f9c:	11 f4       	brne	.+4      	; 0x10fa2 <FMenuChangeMOP+0x188>
   10f9e:	8f e0       	ldi	r24, 0x0F	; 15
   10fa0:	20 c1       	rjmp	.+576    	; 0x111e2 <FMenuChangeMOP+0x3c8>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   10fa2:	84 30       	cpi	r24, 0x04	; 4
   10fa4:	09 f4       	brne	.+2      	; 0x10fa8 <FMenuChangeMOP+0x18e>
   10fa6:	9b c0       	rjmp	.+310    	; 0x110de <FMenuChangeMOP+0x2c4>
   10fa8:	5e c3       	rjmp	.+1724   	; 0x11666 <FMenuChangeMOP+0x84c>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   10faa:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   10fae:	81 e0       	ldi	r24, 0x01	; 1
   10fb0:	61 e0       	ldi	r22, 0x01	; 1
   10fb2:	4b e9       	ldi	r20, 0x9B	; 155
   10fb4:	58 e1       	ldi	r21, 0x18	; 24
   10fb6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   10fba:	10 92 5c 02 	sts	0x025C, r1
   10fbe:	10 92 5b 02 	sts	0x025B, r1
   10fc2:	8e 01       	movw	r16, r28
   10fc4:	0b 5f       	subi	r16, 0xFB	; 251
   10fc6:	1f 4f       	sbci	r17, 0xFF	; 255
   10fc8:	9b e0       	ldi	r25, 0x0B	; 11
   10fca:	a9 2e       	mov	r10, r25
   10fcc:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   10fce:	80 e1       	ldi	r24, 0x10	; 16
   10fd0:	e8 2e       	mov	r14, r24
   10fd2:	f1 2c       	mov	r15, r1
   10fd4:	ec 0e       	add	r14, r28
   10fd6:	fd 1e       	adc	r15, r29
   10fd8:	b5 e9       	ldi	r27, 0x95	; 149
   10fda:	cb 2e       	mov	r12, r27
   10fdc:	b8 e1       	ldi	r27, 0x18	; 24
   10fde:	db 2e       	mov	r13, r27
   10fe0:	5d c0       	rjmp	.+186    	; 0x1109c <FMenuChangeMOP+0x282>
   10fe2:	8a 9d       	mul	r24, r10
   10fe4:	b0 01       	movw	r22, r0
   10fe6:	8b 9d       	mul	r24, r11
   10fe8:	70 0d       	add	r23, r0
   10fea:	9a 9d       	mul	r25, r10
   10fec:	70 0d       	add	r23, r0
   10fee:	11 24       	eor	r1, r1
   10ff0:	67 5f       	subi	r22, 0xF7	; 247
   10ff2:	7e 4f       	sbci	r23, 0xFE	; 254
   10ff4:	c8 01       	movw	r24, r16
   10ff6:	4b e0       	ldi	r20, 0x0B	; 11
   10ff8:	50 e0       	ldi	r21, 0x00	; 0
   10ffa:	24 e4       	ldi	r18, 0x44	; 68
   10ffc:	32 e1       	ldi	r19, 0x12	; 18
   10ffe:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   11002:	e0 e0       	ldi	r30, 0x00	; 0
   11004:	f0 e0       	ldi	r31, 0x00	; 0
   11006:	0b 30       	cpi	r16, 0x0B	; 11
   11008:	11 05       	cpc	r17, r1
   1100a:	10 f4       	brcc	.+4      	; 0x11010 <FMenuChangeMOP+0x1f6>
   1100c:	e1 e0       	ldi	r30, 0x01	; 1
   1100e:	f0 e0       	ldi	r31, 0x00	; 0
   11010:	80 81       	ld	r24, Z
   11012:	88 23       	and	r24, r24
   11014:	d1 f1       	breq	.+116    	; 0x1108a <FMenuChangeMOP+0x270>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   11016:	ad b7       	in	r26, 0x3d	; 61
   11018:	be b7       	in	r27, 0x3e	; 62
   1101a:	18 97       	sbiw	r26, 0x08	; 8
   1101c:	0f b6       	in	r0, 0x3f	; 63
   1101e:	f8 94       	cli
   11020:	be bf       	out	0x3e, r27	; 62
   11022:	0f be       	out	0x3f, r0	; 63
   11024:	ad bf       	out	0x3d, r26	; 61
   11026:	ed b7       	in	r30, 0x3d	; 61
   11028:	fe b7       	in	r31, 0x3e	; 62
   1102a:	31 96       	adiw	r30, 0x01	; 1
   1102c:	12 96       	adiw	r26, 0x02	; 2
   1102e:	fc 92       	st	X, r15
   11030:	ee 92       	st	-X, r14
   11032:	11 97       	sbiw	r26, 0x01	; 1
   11034:	d3 82       	std	Z+3, r13	; 0x03
   11036:	c2 82       	std	Z+2, r12	; 0x02
   11038:	80 91 5b 02 	lds	r24, 0x025B
   1103c:	90 91 5c 02 	lds	r25, 0x025C
   11040:	01 96       	adiw	r24, 0x01	; 1
   11042:	95 83       	std	Z+5, r25	; 0x05
   11044:	84 83       	std	Z+4, r24	; 0x04
   11046:	17 83       	std	Z+7, r17	; 0x07
   11048:	06 83       	std	Z+6, r16	; 0x06
   1104a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   1104e:	20 91 5b 02 	lds	r18, 0x025B
   11052:	30 91 5c 02 	lds	r19, 0x025C
   11056:	ed b7       	in	r30, 0x3d	; 61
   11058:	fe b7       	in	r31, 0x3e	; 62
   1105a:	38 96       	adiw	r30, 0x08	; 8
   1105c:	0f b6       	in	r0, 0x3f	; 63
   1105e:	f8 94       	cli
   11060:	fe bf       	out	0x3e, r31	; 62
   11062:	0f be       	out	0x3f, r0	; 63
   11064:	ed bf       	out	0x3d, r30	; 61
   11066:	82 2f       	mov	r24, r18
   11068:	81 70       	andi	r24, 0x01	; 1
   1106a:	36 95       	lsr	r19
   1106c:	27 95       	ror	r18
   1106e:	b9 01       	movw	r22, r18
   11070:	66 0f       	add	r22, r22
   11072:	77 1f       	adc	r23, r23
   11074:	62 0f       	add	r22, r18
   11076:	73 1f       	adc	r23, r19
   11078:	66 0f       	add	r22, r22
   1107a:	77 1f       	adc	r23, r23
   1107c:	66 0f       	add	r22, r22
   1107e:	77 1f       	adc	r23, r23
   11080:	6f 5f       	subi	r22, 0xFF	; 255
   11082:	8e 5f       	subi	r24, 0xFE	; 254
   11084:	a7 01       	movw	r20, r14
   11086:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   1108a:	80 91 5b 02 	lds	r24, 0x025B
   1108e:	90 91 5c 02 	lds	r25, 0x025C
   11092:	01 96       	adiw	r24, 0x01	; 1
   11094:	90 93 5c 02 	sts	0x025C, r25
   11098:	80 93 5b 02 	sts	0x025B, r24
   1109c:	80 91 5b 02 	lds	r24, 0x025B
   110a0:	90 91 5c 02 	lds	r25, 0x025C
   110a4:	84 30       	cpi	r24, 0x04	; 4
   110a6:	91 05       	cpc	r25, r1
   110a8:	08 f4       	brcc	.+2      	; 0x110ac <FMenuChangeMOP+0x292>
   110aa:	9b cf       	rjmp	.-202    	; 0x10fe2 <FMenuChangeMOP+0x1c8>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   110ac:	84 e0       	ldi	r24, 0x04	; 4
   110ae:	61 e0       	ldi	r22, 0x01	; 1
   110b0:	4d e8       	ldi	r20, 0x8D	; 141
   110b2:	58 e1       	ldi	r21, 0x18	; 24
   110b4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   110b8:	8c e0       	ldi	r24, 0x0C	; 12
   110ba:	93 c0       	rjmp	.+294    	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   110bc:	81 e0       	ldi	r24, 0x01	; 1
   110be:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
   110c2:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   110c4:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
          if ((KeyChar>='1')&&(KeyChar<='4')){
   110c8:	81 53       	subi	r24, 0x31	; 49
   110ca:	84 30       	cpi	r24, 0x04	; 4
   110cc:	28 f4       	brcc	.+10     	; 0x110d8 <FMenuChangeMOP+0x2be>
		      BankIdx=KeyChar-'1';
   110ce:	80 93 5f 02 	sts	0x025F, r24
			  stChangeMOP=cmSelectFIP;
   110d2:	89 e0       	ldi	r24, 0x09	; 9
   110d4:	80 93 61 02 	sts	0x0261, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   110d8:	17 3e       	cpi	r17, 0xE7	; 231
   110da:	09 f0       	breq	.+2      	; 0x110de <FMenuChangeMOP+0x2c4>
   110dc:	c4 c2       	rjmp	.+1416   	; 0x11666 <FMenuChangeMOP+0x84c>
   110de:	81 e0       	ldi	r24, 0x01	; 1
   110e0:	80 c0       	rjmp	.+256    	; 0x111e2 <FMenuChangeMOP+0x3c8>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   110e2:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
   110e6:	65 e0       	ldi	r22, 0x05	; 5
   110e8:	e6 2e       	mov	r14, r22
   110ea:	f1 2c       	mov	r15, r1
   110ec:	ec 0e       	add	r14, r28
   110ee:	fd 1e       	adc	r15, r29
   110f0:	60 91 5f 02 	lds	r22, 0x025F
   110f4:	8b e0       	ldi	r24, 0x0B	; 11
   110f6:	68 9f       	mul	r22, r24
   110f8:	b0 01       	movw	r22, r0
   110fa:	11 24       	eor	r1, r1
   110fc:	67 5f       	subi	r22, 0xF7	; 247
   110fe:	7e 4f       	sbci	r23, 0xFE	; 254
   11100:	c7 01       	movw	r24, r14
   11102:	4b e0       	ldi	r20, 0x0B	; 11
   11104:	50 e0       	ldi	r21, 0x00	; 0
   11106:	24 e4       	ldi	r18, 0x44	; 68
   11108:	32 e1       	ldi	r19, 0x12	; 18
   1110a:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   1110e:	00 d0       	rcall	.+0      	; 0x11110 <FMenuChangeMOP+0x2f6>
   11110:	00 d0       	rcall	.+0      	; 0x11112 <FMenuChangeMOP+0x2f8>
   11112:	00 d0       	rcall	.+0      	; 0x11114 <FMenuChangeMOP+0x2fa>
   11114:	ed b7       	in	r30, 0x3d	; 61
   11116:	fe b7       	in	r31, 0x3e	; 62
   11118:	31 96       	adiw	r30, 0x01	; 1
   1111a:	8e 01       	movw	r16, r28
   1111c:	00 5f       	subi	r16, 0xF0	; 240
   1111e:	1f 4f       	sbci	r17, 0xFF	; 255
   11120:	ad b7       	in	r26, 0x3d	; 61
   11122:	be b7       	in	r27, 0x3e	; 62
   11124:	12 96       	adiw	r26, 0x02	; 2
   11126:	1c 93       	st	X, r17
   11128:	0e 93       	st	-X, r16
   1112a:	11 97       	sbiw	r26, 0x01	; 1
   1112c:	8a e8       	ldi	r24, 0x8A	; 138
   1112e:	98 e1       	ldi	r25, 0x18	; 24
   11130:	93 83       	std	Z+3, r25	; 0x03
   11132:	82 83       	std	Z+2, r24	; 0x02
   11134:	f5 82       	std	Z+5, r15	; 0x05
   11136:	e4 82       	std	Z+4, r14	; 0x04
   11138:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   1113c:	ed b7       	in	r30, 0x3d	; 61
   1113e:	fe b7       	in	r31, 0x3e	; 62
   11140:	36 96       	adiw	r30, 0x06	; 6
   11142:	0f b6       	in	r0, 0x3f	; 63
   11144:	f8 94       	cli
   11146:	fe bf       	out	0x3e, r31	; 62
   11148:	0f be       	out	0x3f, r0	; 63
   1114a:	ed bf       	out	0x3d, r30	; 61
   1114c:	81 e0       	ldi	r24, 0x01	; 1
   1114e:	61 e0       	ldi	r22, 0x01	; 1
   11150:	a8 01       	movw	r20, r16
   11152:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   11156:	82 e0       	ldi	r24, 0x02	; 2
   11158:	61 e0       	ldi	r22, 0x01	; 1
   1115a:	4a e7       	ldi	r20, 0x7A	; 122
   1115c:	58 e1       	ldi	r21, 0x18	; 24
   1115e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11162:	84 e0       	ldi	r24, 0x04	; 4
   11164:	61 e0       	ldi	r22, 0x01	; 1
   11166:	45 e6       	ldi	r20, 0x65	; 101
   11168:	58 e1       	ldi	r21, 0x18	; 24
   1116a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   1116e:	8d e0       	ldi	r24, 0x0D	; 13
   11170:	38 c0       	rjmp	.+112    	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
	 case cmInputBankSurcharge:
	      //uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
		  uiResult=UserInput(UI_NUMBER_L,2,14,strSurcharge,100,3);
   11172:	82 e0       	ldi	r24, 0x02	; 2
   11174:	62 e0       	ldi	r22, 0x02	; 2
   11176:	4e e0       	ldi	r20, 0x0E	; 14
   11178:	9e 01       	movw	r18, r28
   1117a:	2f 5f       	subi	r18, 0xFF	; 255
   1117c:	3f 4f       	sbci	r19, 0xFF	; 255
   1117e:	04 e6       	ldi	r16, 0x64	; 100
   11180:	10 e0       	ldi	r17, 0x00	; 0
   11182:	53 e0       	ldi	r21, 0x03	; 3
   11184:	e5 2e       	mov	r14, r21
   11186:	0e 94 a6 66 	call	0xcd4c	; 0xcd4c <UserInput>
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   1118a:	83 30       	cpi	r24, 0x03	; 3
   1118c:	09 f4       	brne	.+2      	; 0x11190 <FMenuChangeMOP+0x376>
   1118e:	c6 c0       	rjmp	.+396    	; 0x1131c <FMenuChangeMOP+0x502>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   11190:	81 30       	cpi	r24, 0x01	; 1
   11192:	11 f4       	brne	.+4      	; 0x11198 <FMenuChangeMOP+0x37e>
   11194:	8b e0       	ldi	r24, 0x0B	; 11
   11196:	25 c0       	rjmp	.+74     	; 0x111e2 <FMenuChangeMOP+0x3c8>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11198:	84 30       	cpi	r24, 0x04	; 4
   1119a:	21 f4       	brne	.+8      	; 0x111a4 <FMenuChangeMOP+0x38a>
   1119c:	61 e0       	ldi	r22, 0x01	; 1
   1119e:	40 e5       	ldi	r20, 0x50	; 80
   111a0:	58 e1       	ldi	r21, 0x18	; 24
   111a2:	07 c0       	rjmp	.+14     	; 0x111b2 <FMenuChangeMOP+0x398>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   111a4:	85 30       	cpi	r24, 0x05	; 5
   111a6:	09 f0       	breq	.+2      	; 0x111aa <FMenuChangeMOP+0x390>
   111a8:	5e c2       	rjmp	.+1212   	; 0x11666 <FMenuChangeMOP+0x84c>
   111aa:	84 e0       	ldi	r24, 0x04	; 4
   111ac:	61 e0       	ldi	r22, 0x01	; 1
   111ae:	4b e3       	ldi	r20, 0x3B	; 59
   111b0:	58 e1       	ldi	r21, 0x18	; 24
   111b2:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
   111b6:	57 c2       	rjmp	.+1198   	; 0x11666 <FMenuChangeMOP+0x84c>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   111b8:	80 91 b8 01 	lds	r24, 0x01B8
   111bc:	82 30       	cpi	r24, 0x02	; 2
   111be:	61 f0       	breq	.+24     	; 0x111d8 <FMenuChangeMOP+0x3be>
   111c0:	83 30       	cpi	r24, 0x03	; 3
   111c2:	20 f4       	brcc	.+8      	; 0x111cc <FMenuChangeMOP+0x3b2>
   111c4:	81 30       	cpi	r24, 0x01	; 1
   111c6:	09 f0       	breq	.+2      	; 0x111ca <FMenuChangeMOP+0x3b0>
   111c8:	4e c2       	rjmp	.+1180   	; 0x11666 <FMenuChangeMOP+0x84c>
   111ca:	0a c0       	rjmp	.+20     	; 0x111e0 <FMenuChangeMOP+0x3c6>
   111cc:	83 30       	cpi	r24, 0x03	; 3
   111ce:	31 f0       	breq	.+12     	; 0x111dc <FMenuChangeMOP+0x3c2>
   111d0:	84 30       	cpi	r24, 0x04	; 4
   111d2:	09 f0       	breq	.+2      	; 0x111d6 <FMenuChangeMOP+0x3bc>
   111d4:	48 c2       	rjmp	.+1168   	; 0x11666 <FMenuChangeMOP+0x84c>
   111d6:	04 c0       	rjmp	.+8      	; 0x111e0 <FMenuChangeMOP+0x3c6>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   111d8:	81 e1       	ldi	r24, 0x11	; 17
   111da:	03 c0       	rjmp	.+6      	; 0x111e2 <FMenuChangeMOP+0x3c8>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   111dc:	85 e1       	ldi	r24, 0x15	; 21
   111de:	01 c0       	rjmp	.+2      	; 0x111e2 <FMenuChangeMOP+0x3c8>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   111e0:	82 e1       	ldi	r24, 0x12	; 18
   111e2:	80 93 61 02 	sts	0x0261, r24
   111e6:	3f c2       	rjmp	.+1150   	; 0x11666 <FMenuChangeMOP+0x84c>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   111e8:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   111ec:	81 e0       	ldi	r24, 0x01	; 1
   111ee:	61 e0       	ldi	r22, 0x01	; 1
   111f0:	4c e2       	ldi	r20, 0x2C	; 44
   111f2:	58 e1       	ldi	r21, 0x18	; 24
   111f4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   111f8:	00 d0       	rcall	.+0      	; 0x111fa <FMenuChangeMOP+0x3e0>
   111fa:	00 d0       	rcall	.+0      	; 0x111fc <FMenuChangeMOP+0x3e2>
   111fc:	00 d0       	rcall	.+0      	; 0x111fe <FMenuChangeMOP+0x3e4>
   111fe:	ed b7       	in	r30, 0x3d	; 61
   11200:	fe b7       	in	r31, 0x3e	; 62
   11202:	31 96       	adiw	r30, 0x01	; 1
   11204:	8e 01       	movw	r16, r28
   11206:	00 5f       	subi	r16, 0xF0	; 240
   11208:	1f 4f       	sbci	r17, 0xFF	; 255
   1120a:	ad b7       	in	r26, 0x3d	; 61
   1120c:	be b7       	in	r27, 0x3e	; 62
   1120e:	12 96       	adiw	r26, 0x02	; 2
   11210:	1c 93       	st	X, r17
   11212:	0e 93       	st	-X, r16
   11214:	11 97       	sbiw	r26, 0x01	; 1
   11216:	86 e2       	ldi	r24, 0x26	; 38
   11218:	98 e1       	ldi	r25, 0x18	; 24
   1121a:	93 83       	std	Z+3, r25	; 0x03
   1121c:	82 83       	std	Z+2, r24	; 0x02
   1121e:	89 eb       	ldi	r24, 0xB9	; 185
   11220:	97 e0       	ldi	r25, 0x07	; 7
   11222:	95 83       	std	Z+5, r25	; 0x05
   11224:	84 83       	std	Z+4, r24	; 0x04
   11226:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   1122a:	ed b7       	in	r30, 0x3d	; 61
   1122c:	fe b7       	in	r31, 0x3e	; 62
   1122e:	36 96       	adiw	r30, 0x06	; 6
   11230:	0f b6       	in	r0, 0x3f	; 63
   11232:	f8 94       	cli
   11234:	fe bf       	out	0x3e, r31	; 62
   11236:	0f be       	out	0x3f, r0	; 63
   11238:	ed bf       	out	0x3d, r30	; 61
   1123a:	82 e0       	ldi	r24, 0x02	; 2
   1123c:	61 e0       	ldi	r22, 0x01	; 1
   1123e:	a8 01       	movw	r20, r16
   11240:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   11244:	84 e0       	ldi	r24, 0x04	; 4
   11246:	61 e0       	ldi	r22, 0x01	; 1
   11248:	43 e1       	ldi	r20, 0x13	; 19
   1124a:	58 e1       	ldi	r21, 0x18	; 24
   1124c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  IsRFIDDetected=False;
   11250:	10 92 98 01 	sts	0x0198, r1
          stChangeMOP=cmRFIDCardInput;
   11254:	83 e1       	ldi	r24, 0x13	; 19
   11256:	c5 cf       	rjmp	.-118    	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   11258:	81 e0       	ldi	r24, 0x01	; 1
   1125a:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
   1125e:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   11260:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  if (KeyPressed==_KEY_ENTER){
   11264:	17 3b       	cpi	r17, 0xB7	; 183
   11266:	11 f4       	brne	.+4      	; 0x1126c <FMenuChangeMOP+0x452>
		      stChangeMOP=cmExitChangeMOP;
   11268:	8c e1       	ldi	r24, 0x1C	; 28
   1126a:	03 c0       	rjmp	.+6      	; 0x11272 <FMenuChangeMOP+0x458>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   1126c:	17 3e       	cpi	r17, 0xE7	; 231
   1126e:	19 f4       	brne	.+6      	; 0x11276 <FMenuChangeMOP+0x45c>
   		      stChangeMOP=cmSelectFIP;
   11270:	89 e0       	ldi	r24, 0x09	; 9
   11272:	80 93 61 02 	sts	0x0261, r24
			 }
          if (IsRFIDDetected==True){
   11276:	80 91 98 01 	lds	r24, 0x0198
   1127a:	81 30       	cpi	r24, 0x01	; 1
   1127c:	09 f0       	breq	.+2      	; 0x11280 <FMenuChangeMOP+0x466>
   1127e:	f3 c1       	rjmp	.+998    	; 0x11666 <FMenuChangeMOP+0x84c>
		      IsRFIDDetected=False;
   11280:	10 92 98 01 	sts	0x0198, r1
			   stChangeMOP=cmProsesRFID;
   11284:	84 e1       	ldi	r24, 0x14	; 20
   11286:	ad cf       	rjmp	.-166    	; 0x111e2 <FMenuChangeMOP+0x3c8>
   11288:	20 e0       	ldi	r18, 0x00	; 0
   1128a:	30 e0       	ldi	r19, 0x00	; 0


void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   1128c:	f9 01       	movw	r30, r18
   1128e:	e7 57       	subi	r30, 0x77	; 119
   11290:	f4 4f       	sbci	r31, 0xF4	; 244
   11292:	d9 01       	movw	r26, r18
   11294:	af 5a       	subi	r26, 0xAF	; 175
   11296:	b3 4f       	sbci	r27, 0xF3	; 243
   11298:	8c 91       	ld	r24, X
   1129a:	80 83       	st	Z, r24
   1129c:	2f 5f       	subi	r18, 0xFF	; 255
   1129e:	3f 4f       	sbci	r19, 0xFF	; 255



void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   112a0:	28 30       	cpi	r18, 0x08	; 8
   112a2:	31 05       	cpc	r19, r1
   112a4:	99 f7       	brne	.-26     	; 0x1128c <FMenuChangeMOP+0x472>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   112a6:	10 92 91 0b 	sts	0x0B91, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   112aa:	00 d0       	rcall	.+0      	; 0x112ac <FMenuChangeMOP+0x492>
   112ac:	00 d0       	rcall	.+0      	; 0x112ae <FMenuChangeMOP+0x494>
   112ae:	00 d0       	rcall	.+0      	; 0x112b0 <FMenuChangeMOP+0x496>
   112b0:	ed b7       	in	r30, 0x3d	; 61
   112b2:	fe b7       	in	r31, 0x3e	; 62
   112b4:	31 96       	adiw	r30, 0x01	; 1
   112b6:	8e 01       	movw	r16, r28
   112b8:	00 5f       	subi	r16, 0xF0	; 240
   112ba:	1f 4f       	sbci	r17, 0xFF	; 255
   112bc:	ad b7       	in	r26, 0x3d	; 61
   112be:	be b7       	in	r27, 0x3e	; 62
   112c0:	12 96       	adiw	r26, 0x02	; 2
   112c2:	1c 93       	st	X, r17
   112c4:	0e 93       	st	-X, r16
   112c6:	11 97       	sbiw	r26, 0x01	; 1
   112c8:	8d e0       	ldi	r24, 0x0D	; 13
   112ca:	98 e1       	ldi	r25, 0x18	; 24
   112cc:	93 83       	std	Z+3, r25	; 0x03
   112ce:	82 83       	std	Z+2, r24	; 0x02
   112d0:	89 e8       	ldi	r24, 0x89	; 137
   112d2:	9b e0       	ldi	r25, 0x0B	; 11
   112d4:	95 83       	std	Z+5, r25	; 0x05
   112d6:	84 83       	std	Z+4, r24	; 0x04
   112d8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   112dc:	ed b7       	in	r30, 0x3d	; 61
   112de:	fe b7       	in	r31, 0x3e	; 62
   112e0:	36 96       	adiw	r30, 0x06	; 6
   112e2:	0f b6       	in	r0, 0x3f	; 63
   112e4:	f8 94       	cli
   112e6:	fe bf       	out	0x3e, r31	; 62
   112e8:	0f be       	out	0x3f, r0	; 63
   112ea:	ed bf       	out	0x3d, r30	; 61
   112ec:	82 e0       	ldi	r24, 0x02	; 2
   112ee:	61 e0       	ldi	r22, 0x01	; 1
   112f0:	a8 01       	movw	r20, r16
   112f2:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   112f6:	83 e0       	ldi	r24, 0x03	; 3
   112f8:	61 e0       	ldi	r22, 0x01	; 1
   112fa:	46 e0       	ldi	r20, 0x06	; 6
   112fc:	58 e1       	ldi	r21, 0x18	; 24
   112fe:	0c c0       	rjmp	.+24     	; 0x11318 <FMenuChangeMOP+0x4fe>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   11300:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   11304:	81 e0       	ldi	r24, 0x01	; 1
   11306:	61 e0       	ldi	r22, 0x01	; 1
   11308:	48 ef       	ldi	r20, 0xF8	; 248
   1130a:	57 e1       	ldi	r21, 0x17	; 23
   1130c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   11310:	83 e0       	ldi	r24, 0x03	; 3
   11312:	61 e0       	ldi	r22, 0x01	; 1
   11314:	41 ef       	ldi	r20, 0xF1	; 241
   11316:	57 e1       	ldi	r21, 0x17	; 23
   11318:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stChangeMOP=cmGenerateData;
   1131c:	86 e1       	ldi	r24, 0x16	; 22
   1131e:	61 cf       	rjmp	.-318    	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
   11320:	ee e8       	ldi	r30, 0x8E	; 142
   11322:	fc e0       	ldi	r31, 0x0C	; 12
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11324:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11326:	8c e0       	ldi	r24, 0x0C	; 12
   11328:	e3 3a       	cpi	r30, 0xA3	; 163
   1132a:	f8 07       	cpc	r31, r24
   1132c:	d9 f7       	brne	.-10     	; 0x11324 <FMenuChangeMOP+0x50a>
   1132e:	ee e9       	ldi	r30, 0x9E	; 158
   11330:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
   11332:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11334:	9b e0       	ldi	r25, 0x0B	; 11
   11336:	e3 3b       	cpi	r30, 0xB3	; 179
   11338:	f9 07       	cpc	r31, r25
   1133a:	d9 f7       	brne	.-10     	; 0x11332 <FMenuChangeMOP+0x518>
   1133c:	ed e7       	ldi	r30, 0x7D	; 125
   1133e:	f8 e0       	ldi	r31, 0x08	; 8
	     strMemory[i]=data;
   11340:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11342:	a8 e0       	ldi	r26, 0x08	; 8
   11344:	e2 39       	cpi	r30, 0x92	; 146
   11346:	fa 07       	cpc	r31, r26
   11348:	d9 f7       	brne	.-10     	; 0x11340 <FMenuChangeMOP+0x526>
   1134a:	25 ea       	ldi	r18, 0xA5	; 165
   1134c:	e2 2e       	mov	r14, r18
   1134e:	23 e0       	ldi	r18, 0x03	; 3
   11350:	f2 2e       	mov	r15, r18
	     strMemory[i]=data;
   11352:	f7 01       	movw	r30, r14
   11354:	11 92       	st	Z+, r1
   11356:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11358:	fa eb       	ldi	r31, 0xBA	; 186
   1135a:	ef 16       	cp	r14, r31
   1135c:	f3 e0       	ldi	r31, 0x03	; 3
   1135e:	ff 06       	cpc	r15, r31
   11360:	c1 f7       	brne	.-16     	; 0x11352 <FMenuChangeMOP+0x538>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   11362:	80 91 b8 01 	lds	r24, 0x01B8
   11366:	82 30       	cpi	r24, 0x02	; 2
   11368:	f1 f0       	breq	.+60     	; 0x113a6 <FMenuChangeMOP+0x58c>
   1136a:	83 30       	cpi	r24, 0x03	; 3
   1136c:	20 f4       	brcc	.+8      	; 0x11376 <FMenuChangeMOP+0x55c>
   1136e:	81 30       	cpi	r24, 0x01	; 1
   11370:	09 f0       	breq	.+2      	; 0x11374 <FMenuChangeMOP+0x55a>
   11372:	ad c0       	rjmp	.+346    	; 0x114ce <FMenuChangeMOP+0x6b4>
   11374:	07 c0       	rjmp	.+14     	; 0x11384 <FMenuChangeMOP+0x56a>
   11376:	83 30       	cpi	r24, 0x03	; 3
   11378:	09 f4       	brne	.+2      	; 0x1137c <FMenuChangeMOP+0x562>
   1137a:	64 c0       	rjmp	.+200    	; 0x11444 <FMenuChangeMOP+0x62a>
   1137c:	84 30       	cpi	r24, 0x04	; 4
   1137e:	09 f0       	breq	.+2      	; 0x11382 <FMenuChangeMOP+0x568>
   11380:	a6 c0       	rjmp	.+332    	; 0x114ce <FMenuChangeMOP+0x6b4>
   11382:	75 c0       	rjmp	.+234    	; 0x1146e <FMenuChangeMOP+0x654>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   11384:	00 d0       	rcall	.+0      	; 0x11386 <FMenuChangeMOP+0x56c>
   11386:	00 d0       	rcall	.+0      	; 0x11388 <FMenuChangeMOP+0x56e>
   11388:	00 d0       	rcall	.+0      	; 0x1138a <FMenuChangeMOP+0x570>
   1138a:	ed b7       	in	r30, 0x3d	; 61
   1138c:	fe b7       	in	r31, 0x3e	; 62
   1138e:	31 96       	adiw	r30, 0x01	; 1
   11390:	8e e8       	ldi	r24, 0x8E	; 142
   11392:	9c e0       	ldi	r25, 0x0C	; 12
   11394:	ad b7       	in	r26, 0x3d	; 61
   11396:	be b7       	in	r27, 0x3e	; 62
   11398:	12 96       	adiw	r26, 0x02	; 2
   1139a:	9c 93       	st	X, r25
   1139c:	8e 93       	st	-X, r24
   1139e:	11 97       	sbiw	r26, 0x01	; 1
   113a0:	8e ee       	ldi	r24, 0xEE	; 238
   113a2:	97 e1       	ldi	r25, 0x17	; 23
   113a4:	84 c0       	rjmp	.+264    	; 0x114ae <FMenuChangeMOP+0x694>
   113a6:	8e 01       	movw	r16, r28
   113a8:	0b 5f       	subi	r16, 0xFB	; 251
   113aa:	1f 4f       	sbci	r17, 0xFF	; 255
   113ac:	60 91 5f 02 	lds	r22, 0x025F
   113b0:	8b e0       	ldi	r24, 0x0B	; 11
   113b2:	68 9f       	mul	r22, r24
   113b4:	b0 01       	movw	r22, r0
   113b6:	11 24       	eor	r1, r1
   113b8:	67 5f       	subi	r22, 0xF7	; 247
   113ba:	7e 4f       	sbci	r23, 0xFE	; 254
   113bc:	c8 01       	movw	r24, r16
   113be:	4b e0       	ldi	r20, 0x0B	; 11
   113c0:	50 e0       	ldi	r21, 0x00	; 0
   113c2:	24 e4       	ldi	r18, 0x44	; 68
   113c4:	32 e1       	ldi	r19, 0x12	; 18
   113c6:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   113ca:	00 d0       	rcall	.+0      	; 0x113cc <FMenuChangeMOP+0x5b2>
   113cc:	00 d0       	rcall	.+0      	; 0x113ce <FMenuChangeMOP+0x5b4>
   113ce:	00 d0       	rcall	.+0      	; 0x113d0 <FMenuChangeMOP+0x5b6>
   113d0:	ed b7       	in	r30, 0x3d	; 61
   113d2:	fe b7       	in	r31, 0x3e	; 62
   113d4:	31 96       	adiw	r30, 0x01	; 1
   113d6:	ce 01       	movw	r24, r28
   113d8:	40 96       	adiw	r24, 0x10	; 16
   113da:	ad b7       	in	r26, 0x3d	; 61
   113dc:	be b7       	in	r27, 0x3e	; 62
   113de:	12 96       	adiw	r26, 0x02	; 2
   113e0:	9c 93       	st	X, r25
   113e2:	8e 93       	st	-X, r24
   113e4:	11 97       	sbiw	r26, 0x01	; 1
   113e6:	8b ee       	ldi	r24, 0xEB	; 235
   113e8:	97 e1       	ldi	r25, 0x17	; 23
   113ea:	93 83       	std	Z+3, r25	; 0x03
   113ec:	82 83       	std	Z+2, r24	; 0x02
   113ee:	15 83       	std	Z+5, r17	; 0x05
   113f0:	04 83       	std	Z+4, r16	; 0x04
   113f2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   113f6:	ed b7       	in	r30, 0x3d	; 61
   113f8:	fe b7       	in	r31, 0x3e	; 62
   113fa:	31 96       	adiw	r30, 0x01	; 1
   113fc:	8e e8       	ldi	r24, 0x8E	; 142
   113fe:	9c e0       	ldi	r25, 0x0C	; 12
   11400:	ad b7       	in	r26, 0x3d	; 61
   11402:	be b7       	in	r27, 0x3e	; 62
   11404:	12 96       	adiw	r26, 0x02	; 2
   11406:	9c 93       	st	X, r25
   11408:	8e 93       	st	-X, r24
   1140a:	11 97       	sbiw	r26, 0x01	; 1
   1140c:	88 ee       	ldi	r24, 0xE8	; 232
   1140e:	97 e1       	ldi	r25, 0x17	; 23
   11410:	93 83       	std	Z+3, r25	; 0x03
   11412:	82 83       	std	Z+2, r24	; 0x02
   11414:	15 83       	std	Z+5, r17	; 0x05
   11416:	04 83       	std	Z+4, r16	; 0x04
   11418:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   1141c:	ed b7       	in	r30, 0x3d	; 61
   1141e:	fe b7       	in	r31, 0x3e	; 62
   11420:	31 96       	adiw	r30, 0x01	; 1
   11422:	8b ee       	ldi	r24, 0xEB	; 235
   11424:	9f ef       	ldi	r25, 0xFF	; 255
   11426:	e8 0e       	add	r14, r24
   11428:	f9 1e       	adc	r15, r25
   1142a:	ad b7       	in	r26, 0x3d	; 61
   1142c:	be b7       	in	r27, 0x3e	; 62
   1142e:	12 96       	adiw	r26, 0x02	; 2
   11430:	fc 92       	st	X, r15
   11432:	ee 92       	st	-X, r14
   11434:	11 97       	sbiw	r26, 0x01	; 1
   11436:	85 ee       	ldi	r24, 0xE5	; 229
   11438:	97 e1       	ldi	r25, 0x17	; 23
   1143a:	93 83       	std	Z+3, r25	; 0x03
   1143c:	82 83       	std	Z+2, r24	; 0x02
   1143e:	ce 01       	movw	r24, r28
   11440:	01 96       	adiw	r24, 0x01	; 1
   11442:	39 c0       	rjmp	.+114    	; 0x114b6 <FMenuChangeMOP+0x69c>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   11444:	00 d0       	rcall	.+0      	; 0x11446 <FMenuChangeMOP+0x62c>
   11446:	00 d0       	rcall	.+0      	; 0x11448 <FMenuChangeMOP+0x62e>
   11448:	00 d0       	rcall	.+0      	; 0x1144a <FMenuChangeMOP+0x630>
   1144a:	ed b7       	in	r30, 0x3d	; 61
   1144c:	fe b7       	in	r31, 0x3e	; 62
   1144e:	31 96       	adiw	r30, 0x01	; 1
   11450:	8e e8       	ldi	r24, 0x8E	; 142
   11452:	9c e0       	ldi	r25, 0x0C	; 12
   11454:	ad b7       	in	r26, 0x3d	; 61
   11456:	be b7       	in	r27, 0x3e	; 62
   11458:	12 96       	adiw	r26, 0x02	; 2
   1145a:	9c 93       	st	X, r25
   1145c:	8e 93       	st	-X, r24
   1145e:	11 97       	sbiw	r26, 0x01	; 1
   11460:	82 ee       	ldi	r24, 0xE2	; 226
   11462:	97 e1       	ldi	r25, 0x17	; 23
   11464:	93 83       	std	Z+3, r25	; 0x03
   11466:	82 83       	std	Z+2, r24	; 0x02
   11468:	8c e3       	ldi	r24, 0x3C	; 60
   1146a:	9c e0       	ldi	r25, 0x0C	; 12
   1146c:	24 c0       	rjmp	.+72     	; 0x114b6 <FMenuChangeMOP+0x69c>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   1146e:	00 d0       	rcall	.+0      	; 0x11470 <FMenuChangeMOP+0x656>
   11470:	00 d0       	rcall	.+0      	; 0x11472 <FMenuChangeMOP+0x658>
   11472:	8e e8       	ldi	r24, 0x8E	; 142
   11474:	9c e0       	ldi	r25, 0x0C	; 12
   11476:	ad b7       	in	r26, 0x3d	; 61
   11478:	be b7       	in	r27, 0x3e	; 62
   1147a:	12 96       	adiw	r26, 0x02	; 2
   1147c:	9c 93       	st	X, r25
   1147e:	8e 93       	st	-X, r24
   11480:	11 97       	sbiw	r26, 0x01	; 1
   11482:	88 ed       	ldi	r24, 0xD8	; 216
   11484:	97 e1       	ldi	r25, 0x17	; 23
   11486:	14 96       	adiw	r26, 0x04	; 4
   11488:	9c 93       	st	X, r25
   1148a:	8e 93       	st	-X, r24
   1148c:	13 97       	sbiw	r26, 0x03	; 3
   1148e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   11492:	00 d0       	rcall	.+0      	; 0x11494 <FMenuChangeMOP+0x67a>
   11494:	ed b7       	in	r30, 0x3d	; 61
   11496:	fe b7       	in	r31, 0x3e	; 62
   11498:	31 96       	adiw	r30, 0x01	; 1
   1149a:	8e e9       	ldi	r24, 0x9E	; 158
   1149c:	9b e0       	ldi	r25, 0x0B	; 11
   1149e:	ad b7       	in	r26, 0x3d	; 61
   114a0:	be b7       	in	r27, 0x3e	; 62
   114a2:	12 96       	adiw	r26, 0x02	; 2
   114a4:	9c 93       	st	X, r25
   114a6:	8e 93       	st	-X, r24
   114a8:	11 97       	sbiw	r26, 0x01	; 1
   114aa:	85 ed       	ldi	r24, 0xD5	; 213
   114ac:	97 e1       	ldi	r25, 0x17	; 23
   114ae:	93 83       	std	Z+3, r25	; 0x03
   114b0:	82 83       	std	Z+2, r24	; 0x02
   114b2:	89 e8       	ldi	r24, 0x89	; 137
   114b4:	9b e0       	ldi	r25, 0x0B	; 11
   114b6:	95 83       	std	Z+5, r25	; 0x05
   114b8:	84 83       	std	Z+4, r24	; 0x04
   114ba:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   114be:	ed b7       	in	r30, 0x3d	; 61
   114c0:	fe b7       	in	r31, 0x3e	; 62
   114c2:	36 96       	adiw	r30, 0x06	; 6
   114c4:	0f b6       	in	r0, 0x3f	; 63
   114c6:	f8 94       	cli
   114c8:	fe bf       	out	0x3e, r31	; 62
   114ca:	0f be       	out	0x3f, r0	; 63
   114cc:	ed bf       	out	0x3d, r30	; 61
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
   114ce:	00 d0       	rcall	.+0      	; 0x114d0 <FMenuChangeMOP+0x6b6>
   114d0:	00 d0       	rcall	.+0      	; 0x114d2 <FMenuChangeMOP+0x6b8>
   114d2:	00 d0       	rcall	.+0      	; 0x114d4 <FMenuChangeMOP+0x6ba>
   114d4:	ed b7       	in	r30, 0x3d	; 61
   114d6:	fe b7       	in	r31, 0x3e	; 62
   114d8:	31 96       	adiw	r30, 0x01	; 1
   114da:	80 e5       	ldi	r24, 0x50	; 80
   114dc:	97 e0       	ldi	r25, 0x07	; 7
   114de:	ad b7       	in	r26, 0x3d	; 61
   114e0:	be b7       	in	r27, 0x3e	; 62
   114e2:	12 96       	adiw	r26, 0x02	; 2
   114e4:	9c 93       	st	X, r25
   114e6:	8e 93       	st	-X, r24
   114e8:	11 97       	sbiw	r26, 0x01	; 1
   114ea:	84 ed       	ldi	r24, 0xD4	; 212
   114ec:	9c e0       	ldi	r25, 0x0C	; 12
   114ee:	93 83       	std	Z+3, r25	; 0x03
   114f0:	82 83       	std	Z+2, r24	; 0x02
   114f2:	80 91 b8 01 	lds	r24, 0x01B8
   114f6:	84 83       	std	Z+4, r24	; 0x04
   114f8:	15 82       	std	Z+5, r1	; 0x05
   114fa:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
		  AddSpaceLead(strRef1,20);
   114fe:	ed b7       	in	r30, 0x3d	; 61
   11500:	fe b7       	in	r31, 0x3e	; 62
   11502:	36 96       	adiw	r30, 0x06	; 6
   11504:	0f b6       	in	r0, 0x3f	; 63
   11506:	f8 94       	cli
   11508:	fe bf       	out	0x3e, r31	; 62
   1150a:	0f be       	out	0x3f, r0	; 63
   1150c:	ed bf       	out	0x3d, r30	; 61
   1150e:	8e e8       	ldi	r24, 0x8E	; 142
   11510:	9c e0       	ldi	r25, 0x0C	; 12
   11512:	64 e1       	ldi	r22, 0x14	; 20
   11514:	0e 94 5f 2b 	call	0x56be	; 0x56be <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   11518:	8e e9       	ldi	r24, 0x9E	; 158
   1151a:	9b e0       	ldi	r25, 0x0B	; 11
   1151c:	64 e1       	ldi	r22, 0x14	; 20
   1151e:	0e 94 5f 2b 	call	0x56be	; 0x56be <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   11522:	8d e7       	ldi	r24, 0x7D	; 125
   11524:	98 e0       	ldi	r25, 0x08	; 8
   11526:	64 e1       	ldi	r22, 0x14	; 20
   11528:	0e 94 5f 2b 	call	0x56be	; 0x56be <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   1152c:	85 ea       	ldi	r24, 0xA5	; 165
   1152e:	93 e0       	ldi	r25, 0x03	; 3
   11530:	64 e1       	ldi	r22, 0x14	; 20
   11532:	0e 94 5f 2b 	call	0x56be	; 0x56be <AddSpaceLead>
		  iWait=0;
   11536:	10 92 5d 02 	sts	0x025D, r1
		  IsMessage09=False;
   1153a:	10 92 a3 01 	sts	0x01A3, r1
		  stChangeMOP=cmSendMessage32;	      
   1153e:	87 e1       	ldi	r24, 0x17	; 23
   11540:	50 ce       	rjmp	.-864    	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   11542:	0e 94 09 87 	call	0x10e12	; 0x10e12 <sendMessage32>
		  iLoop=0;
   11546:	10 92 5c 02 	sts	0x025C, r1
   1154a:	10 92 5b 02 	sts	0x025B, r1
		  iPos=0;
   1154e:	10 92 5e 02 	sts	0x025E, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   11552:	83 e0       	ldi	r24, 0x03	; 3
   11554:	61 e0       	ldi	r22, 0x01	; 1
   11556:	49 ec       	ldi	r20, 0xC9	; 201
   11558:	57 e1       	ldi	r21, 0x17	; 23
   1155a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   1155e:	88 e1       	ldi	r24, 0x18	; 24
   11560:	40 ce       	rjmp	.-896    	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   11562:	80 91 5b 02 	lds	r24, 0x025B
   11566:	90 91 5c 02 	lds	r25, 0x025C
   1156a:	01 96       	adiw	r24, 0x01	; 1
   1156c:	90 93 5c 02 	sts	0x025C, r25
   11570:	80 93 5b 02 	sts	0x025B, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   11574:	68 e9       	ldi	r22, 0x98	; 152
   11576:	7a e3       	ldi	r23, 0x3A	; 58
   11578:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
   1157c:	89 2b       	or	r24, r25
   1157e:	19 f5       	brne	.+70     	; 0x115c6 <FMenuChangeMOP+0x7ac>
			 if (iPos<5){
   11580:	60 91 5e 02 	lds	r22, 0x025E
   11584:	65 30       	cpi	r22, 0x05	; 5
   11586:	68 f4       	brcc	.+26     	; 0x115a2 <FMenuChangeMOP+0x788>
				 lcd_xy(3,(13+iPos));_lcd('.');
   11588:	63 5f       	subi	r22, 0xF3	; 243
   1158a:	83 e0       	ldi	r24, 0x03	; 3
   1158c:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
   11590:	8e e2       	ldi	r24, 0x2E	; 46
   11592:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
				 iPos++;
   11596:	80 91 5e 02 	lds	r24, 0x025E
   1159a:	8f 5f       	subi	r24, 0xFF	; 255
   1159c:	80 93 5e 02 	sts	0x025E, r24
   115a0:	12 c0       	rjmp	.+36     	; 0x115c6 <FMenuChangeMOP+0x7ac>
				}
			 else{
				 iPos=0;
   115a2:	10 92 5e 02 	sts	0x025E, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   115a6:	83 e0       	ldi	r24, 0x03	; 3
   115a8:	6d e0       	ldi	r22, 0x0D	; 13
   115aa:	41 ec       	ldi	r20, 0xC1	; 193
   115ac:	57 e1       	ldi	r21, 0x17	; 23
   115ae:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   115b2:	90 91 5d 02 	lds	r25, 0x025D
   115b6:	95 30       	cpi	r25, 0x05	; 5
   115b8:	18 f4       	brcc	.+6      	; 0x115c0 <FMenuChangeMOP+0x7a6>
   115ba:	87 e1       	ldi	r24, 0x17	; 23
   115bc:	80 93 61 02 	sts	0x0261, r24
				iWait++;
   115c0:	9f 5f       	subi	r25, 0xFF	; 255
   115c2:	90 93 5d 02 	sts	0x025D, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   115c6:	80 91 5d 02 	lds	r24, 0x025D
   115ca:	86 30       	cpi	r24, 0x06	; 6
   115cc:	18 f0       	brcs	.+6      	; 0x115d4 <FMenuChangeMOP+0x7ba>
   115ce:	8a e1       	ldi	r24, 0x1A	; 26
   115d0:	80 93 61 02 	sts	0x0261, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   115d4:	80 91 a3 01 	lds	r24, 0x01A3
   115d8:	81 30       	cpi	r24, 0x01	; 1
   115da:	19 f4       	brne	.+6      	; 0x115e2 <FMenuChangeMOP+0x7c8>
   115dc:	89 e1       	ldi	r24, 0x19	; 25
   115de:	80 93 61 02 	sts	0x0261, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   115e2:	80 91 9f 01 	lds	r24, 0x019F
   115e6:	81 30       	cpi	r24, 0x01	; 1
   115e8:	f1 f5       	brne	.+124    	; 0x11666 <FMenuChangeMOP+0x84c>
   115ea:	37 c0       	rjmp	.+110    	; 0x1165a <FMenuChangeMOP+0x840>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   115ec:	10 92 a3 01 	sts	0x01A3, r1
	      msgResult=procMessage09();
   115f0:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <procMessage09>
		  lcd_clear();
   115f4:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   115f8:	81 e0       	ldi	r24, 0x01	; 1
   115fa:	61 e0       	ldi	r22, 0x01	; 1
   115fc:	42 e9       	ldi	r20, 0x92	; 146
   115fe:	58 e0       	ldi	r21, 0x08	; 8
   11600:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11604:	82 e0       	ldi	r24, 0x02	; 2
   11606:	61 e0       	ldi	r22, 0x01	; 1
   11608:	43 ea       	ldi	r20, 0xA3	; 163
   1160a:	57 e0       	ldi	r21, 0x07	; 7
   1160c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   11610:	83 e0       	ldi	r24, 0x03	; 3
   11612:	61 e0       	ldi	r22, 0x01	; 1
   11614:	4c e1       	ldi	r20, 0x1C	; 28
   11616:	58 e0       	ldi	r21, 0x08	; 8
   11618:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   1161c:	84 e0       	ldi	r24, 0x04	; 4
   1161e:	61 e0       	ldi	r22, 0x01	; 1
   11620:	46 ed       	ldi	r20, 0xD6	; 214
   11622:	5b e0       	ldi	r21, 0x0B	; 11
   11624:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
   11628:	0e c0       	rjmp	.+28     	; 0x11646 <FMenuChangeMOP+0x82c>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   1162a:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   1162e:	82 e0       	ldi	r24, 0x02	; 2
   11630:	61 e0       	ldi	r22, 0x01	; 1
   11632:	44 eb       	ldi	r20, 0xB4	; 180
   11634:	57 e1       	ldi	r21, 0x17	; 23
   11636:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   1163a:	83 e0       	ldi	r24, 0x03	; 3
   1163c:	61 e0       	ldi	r22, 0x01	; 1
   1163e:	47 ea       	ldi	r20, 0xA7	; 167
   11640:	57 e1       	ldi	r21, 0x17	; 23
   11642:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  TimDisplay=0;
   11646:	10 92 92 01 	sts	0x0192, r1
          stChangeMOP=cmDelayMOP;
   1164a:	8b e1       	ldi	r24, 0x1B	; 27
   1164c:	ca cd       	rjmp	.-1132   	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   1164e:	80 91 92 01 	lds	r24, 0x0192
   11652:	8a 30       	cpi	r24, 0x0A	; 10
   11654:	40 f0       	brcs	.+16     	; 0x11666 <FMenuChangeMOP+0x84c>
   11656:	8c e1       	ldi	r24, 0x1C	; 28
   11658:	c4 cd       	rjmp	.-1144   	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   1165a:	8d e1       	ldi	r24, 0x1D	; 29
   1165c:	c2 cd       	rjmp	.-1148   	; 0x111e2 <FMenuChangeMOP+0x3c8>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   1165e:	10 92 61 02 	sts	0x0261, r1
   11662:	81 e0       	ldi	r24, 0x01	; 1
   11664:	01 c0       	rjmp	.+2      	; 0x11668 <FMenuChangeMOP+0x84e>
   11666:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   11668:	a3 96       	adiw	r28, 0x23	; 35
   1166a:	0f b6       	in	r0, 0x3f	; 63
   1166c:	f8 94       	cli
   1166e:	de bf       	out	0x3e, r29	; 62
   11670:	0f be       	out	0x3f, r0	; 63
   11672:	cd bf       	out	0x3d, r28	; 61
   11674:	cf 91       	pop	r28
   11676:	df 91       	pop	r29
   11678:	1f 91       	pop	r17
   1167a:	0f 91       	pop	r16
   1167c:	ff 90       	pop	r15
   1167e:	ef 90       	pop	r14
   11680:	df 90       	pop	r13
   11682:	cf 90       	pop	r12
   11684:	bf 90       	pop	r11
   11686:	af 90       	pop	r10
   11688:	08 95       	ret

0001168a <sendMessage28>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_28);
   1168a:	88 e2       	ldi	r24, 0x28	; 40
   1168c:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
   11690:	08 95       	ret

00011692 <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   11692:	0f 93       	push	r16
   11694:	1f 93       	push	r17
   11696:	df 93       	push	r29
   11698:	cf 93       	push	r28
   1169a:	cd b7       	in	r28, 0x3d	; 61
   1169c:	de b7       	in	r29, 0x3e	; 62
   1169e:	64 97       	sbiw	r28, 0x14	; 20
   116a0:	0f b6       	in	r0, 0x3f	; 63
   116a2:	f8 94       	cli
   116a4:	de bf       	out	0x3e, r29	; 62
   116a6:	0f be       	out	0x3f, r0	; 63
   116a8:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,KeyChar;//,FIP_USED;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   116aa:	80 91 68 02 	lds	r24, 0x0268
   116ae:	87 30       	cpi	r24, 0x07	; 7
   116b0:	09 f4       	brne	.+2      	; 0x116b4 <FMenuReprint+0x22>
   116b2:	9b c0       	rjmp	.+310    	; 0x117ea <FMenuReprint+0x158>
   116b4:	88 30       	cpi	r24, 0x08	; 8
   116b6:	90 f4       	brcc	.+36     	; 0x116dc <FMenuReprint+0x4a>
   116b8:	83 30       	cpi	r24, 0x03	; 3
   116ba:	09 f4       	brne	.+2      	; 0x116be <FMenuReprint+0x2c>
   116bc:	43 c0       	rjmp	.+134    	; 0x11744 <FMenuReprint+0xb2>
   116be:	84 30       	cpi	r24, 0x04	; 4
   116c0:	30 f4       	brcc	.+12     	; 0x116ce <FMenuReprint+0x3c>
   116c2:	81 30       	cpi	r24, 0x01	; 1
   116c4:	09 f4       	brne	.+2      	; 0x116c8 <FMenuReprint+0x36>
   116c6:	52 c0       	rjmp	.+164    	; 0x1176c <FMenuReprint+0xda>
   116c8:	82 30       	cpi	r24, 0x02	; 2
   116ca:	48 f5       	brcc	.+82     	; 0x1171e <FMenuReprint+0x8c>
   116cc:	1d c0       	rjmp	.+58     	; 0x11708 <FMenuReprint+0x76>
   116ce:	85 30       	cpi	r24, 0x05	; 5
   116d0:	09 f4       	brne	.+2      	; 0x116d4 <FMenuReprint+0x42>
   116d2:	7c c0       	rjmp	.+248    	; 0x117cc <FMenuReprint+0x13a>
   116d4:	86 30       	cpi	r24, 0x06	; 6
   116d6:	08 f0       	brcs	.+2      	; 0x116da <FMenuReprint+0x48>
   116d8:	4d c0       	rjmp	.+154    	; 0x11774 <FMenuReprint+0xe2>
   116da:	42 c0       	rjmp	.+132    	; 0x11760 <FMenuReprint+0xce>
   116dc:	8b 30       	cpi	r24, 0x0B	; 11
   116de:	09 f4       	brne	.+2      	; 0x116e2 <FMenuReprint+0x50>
   116e0:	e5 c0       	rjmp	.+458    	; 0x118ac <FMenuReprint+0x21a>
   116e2:	8c 30       	cpi	r24, 0x0C	; 12
   116e4:	38 f4       	brcc	.+14     	; 0x116f4 <FMenuReprint+0x62>
   116e6:	89 30       	cpi	r24, 0x09	; 9
   116e8:	09 f4       	brne	.+2      	; 0x116ec <FMenuReprint+0x5a>
   116ea:	c5 c0       	rjmp	.+394    	; 0x11876 <FMenuReprint+0x1e4>
   116ec:	8a 30       	cpi	r24, 0x0A	; 10
   116ee:	08 f0       	brcs	.+2      	; 0x116f2 <FMenuReprint+0x60>
   116f0:	d7 c0       	rjmp	.+430    	; 0x118a0 <FMenuReprint+0x20e>
   116f2:	89 c0       	rjmp	.+274    	; 0x11806 <FMenuReprint+0x174>
   116f4:	8d 30       	cpi	r24, 0x0D	; 13
   116f6:	09 f4       	brne	.+2      	; 0x116fa <FMenuReprint+0x68>
   116f8:	f6 c0       	rjmp	.+492    	; 0x118e6 <FMenuReprint+0x254>
   116fa:	8d 30       	cpi	r24, 0x0D	; 13
   116fc:	08 f4       	brcc	.+2      	; 0x11700 <FMenuReprint+0x6e>
   116fe:	e0 c0       	rjmp	.+448    	; 0x118c0 <FMenuReprint+0x22e>
   11700:	8e 30       	cpi	r24, 0x0E	; 14
   11702:	09 f0       	breq	.+2      	; 0x11706 <FMenuReprint+0x74>
   11704:	f9 c0       	rjmp	.+498    	; 0x118f8 <FMenuReprint+0x266>
   11706:	f4 c0       	rjmp	.+488    	; 0x118f0 <FMenuReprint+0x25e>
	 case rtInit:
	      lcd_clear();
   11708:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   1170c:	80 91 00 01 	lds	r24, 0x0100
   11710:	81 30       	cpi	r24, 0x01	; 1
   11712:	09 f4       	brne	.+2      	; 0x11716 <FMenuReprint+0x84>
   11714:	c0 c0       	rjmp	.+384    	; 0x11896 <FMenuReprint+0x204>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   11716:	82 30       	cpi	r24, 0x02	; 2
   11718:	09 f0       	breq	.+2      	; 0x1171c <FMenuReprint+0x8a>
   1171a:	ee c0       	rjmp	.+476    	; 0x118f8 <FMenuReprint+0x266>
   1171c:	04 c0       	rjmp	.+8      	; 0x11726 <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   1171e:	0e 94 a7 74 	call	0xe94e	; 0xe94e <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   11722:	84 30       	cpi	r24, 0x04	; 4
   11724:	11 f4       	brne	.+4      	; 0x1172a <FMenuReprint+0x98>
   11726:	81 e0       	ldi	r24, 0x01	; 1
   11728:	0a c0       	rjmp	.+20     	; 0x1173e <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   1172a:	85 30       	cpi	r24, 0x05	; 5
   1172c:	11 f0       	breq	.+4      	; 0x11732 <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   1172e:	82 30       	cpi	r24, 0x02	; 2
   11730:	11 f4       	brne	.+4      	; 0x11736 <FMenuReprint+0xa4>
   11732:	83 e0       	ldi	r24, 0x03	; 3
   11734:	04 c0       	rjmp	.+8      	; 0x1173e <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   11736:	81 30       	cpi	r24, 0x01	; 1
   11738:	09 f0       	breq	.+2      	; 0x1173c <FMenuReprint+0xaa>
   1173a:	de c0       	rjmp	.+444    	; 0x118f8 <FMenuReprint+0x266>
   1173c:	8e e0       	ldi	r24, 0x0E	; 14
   1173e:	80 93 68 02 	sts	0x0268, r24
   11742:	da c0       	rjmp	.+436    	; 0x118f8 <FMenuReprint+0x266>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   11744:	10 92 92 01 	sts	0x0192, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11748:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1174a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1174c:	81 e0       	ldi	r24, 0x01	; 1
   1174e:	80 93 bc 01 	sts	0x01BC, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   11752:	83 e0       	ldi	r24, 0x03	; 3
   11754:	61 e0       	ldi	r22, 0x01	; 1
   11756:	4a ef       	ldi	r20, 0xFA	; 250
   11758:	5a e1       	ldi	r21, 0x1A	; 26
   1175a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
   1175e:	43 c0       	rjmp	.+134    	; 0x117e6 <FMenuReprint+0x154>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   11760:	80 91 92 01 	lds	r24, 0x0192
   11764:	83 30       	cpi	r24, 0x03	; 3
   11766:	08 f4       	brcc	.+2      	; 0x1176a <FMenuReprint+0xd8>
   11768:	c7 c0       	rjmp	.+398    	; 0x118f8 <FMenuReprint+0x266>
   1176a:	e8 cf       	rjmp	.-48     	; 0x1173c <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   1176c:	0e 94 35 45 	call	0x8a6a	; 0x8a6a <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   11770:	86 e0       	ldi	r24, 0x06	; 6
   11772:	e5 cf       	rjmp	.-54     	; 0x1173e <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   11774:	81 e0       	ldi	r24, 0x01	; 1
   11776:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
   1177a:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
   1177e:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   11780:	81 53       	subi	r24, 0x31	; 49
   11782:	88 30       	cpi	r24, 0x08	; 8
   11784:	f8 f4       	brcc	.+62     	; 0x117c4 <FMenuReprint+0x132>
		       SendPoolingCommand(SC_TRANSACTION,GetPumpID(KeyChar-'0'));
   11786:	09 2f       	mov	r16, r25
   11788:	00 53       	subi	r16, 0x30	; 48
   1178a:	80 2f       	mov	r24, r16
   1178c:	0e 94 cc 1c 	call	0x3998	; 0x3998 <GetPumpID>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   11790:	94 e0       	ldi	r25, 0x04	; 4
   11792:	90 93 a7 05 	sts	0x05A7, r25
	 PoolMsg=plMsg;
   11796:	80 93 d3 0b 	sts	0x0BD3, r24
     IsControlPooling=True;
   1179a:	81 e0       	ldi	r24, 0x01	; 1
   1179c:	80 93 84 01 	sts	0x0184, r24
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
		  if ((KeyChar>='1')&&(KeyChar<='8')){
		       SendPoolingCommand(SC_TRANSACTION,GetPumpID(KeyChar-'0'));
			   TimSend=0;
   117a0:	10 92 78 0c 	sts	0x0C78, r1
			   while(TimSend<6){};
   117a4:	80 91 78 0c 	lds	r24, 0x0C78
   117a8:	86 30       	cpi	r24, 0x06	; 6
   117aa:	e0 f3       	brcs	.-8      	; 0x117a4 <FMenuReprint+0x112>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   117ac:	80 2f       	mov	r24, r16
   117ae:	61 e0       	ldi	r22, 0x01	; 1
   117b0:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   117b4:	82 31       	cpi	r24, 0x12	; 18
   117b6:	11 f4       	brne	.+4      	; 0x117bc <FMenuReprint+0x12a>
   117b8:	85 e0       	ldi	r24, 0x05	; 5
   117ba:	c1 cf       	rjmp	.-126    	; 0x1173e <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;               
   117bc:	81 31       	cpi	r24, 0x11	; 17
   117be:	09 f0       	breq	.+2      	; 0x117c2 <FMenuReprint+0x130>
   117c0:	9b c0       	rjmp	.+310    	; 0x118f8 <FMenuReprint+0x266>
   117c2:	bc cf       	rjmp	.-136    	; 0x1173c <FMenuReprint+0xaa>
			   //stReprint=rtExitReprint;
		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   117c4:	9a 32       	cpi	r25, 0x2A	; 42
   117c6:	09 f0       	breq	.+2      	; 0x117ca <FMenuReprint+0x138>
   117c8:	97 c0       	rjmp	.+302    	; 0x118f8 <FMenuReprint+0x266>
   117ca:	b8 cf       	rjmp	.-144    	; 0x1173c <FMenuReprint+0xaa>
	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   117cc:	83 e0       	ldi	r24, 0x03	; 3
   117ce:	61 e0       	ldi	r22, 0x01	; 1
   117d0:	45 ee       	ldi	r20, 0xE5	; 229
   117d2:	5a e1       	ldi	r21, 0x1A	; 26
   117d4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   117d8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   117da:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   117dc:	81 e0       	ldi	r24, 0x01	; 1
   117de:	80 93 bc 01 	sts	0x01BC, r24
		  }else if (KeyChar=='*')stReprint=rtExitReprint;
	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   117e2:	10 92 92 01 	sts	0x0192, r1
		  stReprint=rtTimDisplayInvalid;
   117e6:	84 e0       	ldi	r24, 0x04	; 4
   117e8:	aa cf       	rjmp	.-172    	; 0x1173e <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   117ea:	86 e6       	ldi	r24, 0x66	; 102
   117ec:	92 e0       	ldi	r25, 0x02	; 2
   117ee:	69 eb       	ldi	r22, 0xB9	; 185
   117f0:	77 e0       	ldi	r23, 0x07	; 7
   117f2:	0e 94 6e 53 	call	0xa6dc	; 0xa6dc <menu_FIP>
		  if (FIPResult==FIP_DONE){
   117f6:	88 23       	and	r24, r24
   117f8:	11 f4       	brne	.+4      	; 0x117fe <FMenuReprint+0x16c>
		      stReprint=rtRFID;
   117fa:	88 e0       	ldi	r24, 0x08	; 8
   117fc:	a0 cf       	rjmp	.-192    	; 0x1173e <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   117fe:	82 30       	cpi	r24, 0x02	; 2
   11800:	09 f0       	breq	.+2      	; 0x11804 <FMenuReprint+0x172>
   11802:	7a c0       	rjmp	.+244    	; 0x118f8 <FMenuReprint+0x266>
   11804:	9b cf       	rjmp	.-202    	; 0x1173c <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   11806:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   1180a:	00 d0       	rcall	.+0      	; 0x1180c <FMenuReprint+0x17a>
   1180c:	00 d0       	rcall	.+0      	; 0x1180e <FMenuReprint+0x17c>
   1180e:	00 d0       	rcall	.+0      	; 0x11810 <FMenuReprint+0x17e>
   11810:	ed b7       	in	r30, 0x3d	; 61
   11812:	fe b7       	in	r31, 0x3e	; 62
   11814:	31 96       	adiw	r30, 0x01	; 1
   11816:	8e 01       	movw	r16, r28
   11818:	0f 5f       	subi	r16, 0xFF	; 255
   1181a:	1f 4f       	sbci	r17, 0xFF	; 255
   1181c:	ad b7       	in	r26, 0x3d	; 61
   1181e:	be b7       	in	r27, 0x3e	; 62
   11820:	12 96       	adiw	r26, 0x02	; 2
   11822:	1c 93       	st	X, r17
   11824:	0e 93       	st	-X, r16
   11826:	11 97       	sbiw	r26, 0x01	; 1
   11828:	85 ed       	ldi	r24, 0xD5	; 213
   1182a:	9a e1       	ldi	r25, 0x1A	; 26
   1182c:	93 83       	std	Z+3, r25	; 0x03
   1182e:	82 83       	std	Z+2, r24	; 0x02
   11830:	89 eb       	ldi	r24, 0xB9	; 185
   11832:	97 e0       	ldi	r25, 0x07	; 7
   11834:	95 83       	std	Z+5, r25	; 0x05
   11836:	84 83       	std	Z+4, r24	; 0x04
   11838:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   1183c:	8d b7       	in	r24, 0x3d	; 61
   1183e:	9e b7       	in	r25, 0x3e	; 62
   11840:	06 96       	adiw	r24, 0x06	; 6
   11842:	0f b6       	in	r0, 0x3f	; 63
   11844:	f8 94       	cli
   11846:	9e bf       	out	0x3e, r25	; 62
   11848:	0f be       	out	0x3f, r0	; 63
   1184a:	8d bf       	out	0x3d, r24	; 61
   1184c:	81 e0       	ldi	r24, 0x01	; 1
   1184e:	61 e0       	ldi	r22, 0x01	; 1
   11850:	a8 01       	movw	r20, r16
   11852:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   11856:	82 e0       	ldi	r24, 0x02	; 2
   11858:	61 e0       	ldi	r22, 0x01	; 1
   1185a:	41 ec       	ldi	r20, 0xC1	; 193
   1185c:	5a e1       	ldi	r21, 0x1A	; 26
   1185e:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   11862:	84 e0       	ldi	r24, 0x04	; 4
   11864:	61 e0       	ldi	r22, 0x01	; 1
   11866:	4e ea       	ldi	r20, 0xAE	; 174
   11868:	5a e1       	ldi	r21, 0x1A	; 26
   1186a:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  IsRFIDDetected=False;
   1186e:	10 92 98 01 	sts	0x0198, r1
		  stReprint=rtInputRFID;
   11872:	89 e0       	ldi	r24, 0x09	; 9
   11874:	64 cf       	rjmp	.-312    	; 0x1173e <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   11876:	80 91 98 01 	lds	r24, 0x0198
   1187a:	81 30       	cpi	r24, 0x01	; 1
   1187c:	29 f4       	brne	.+10     	; 0x11888 <FMenuReprint+0x1f6>
		      IsRFIDDetected=False;
   1187e:	10 92 98 01 	sts	0x0198, r1
		      stReprint=rtSendMessage28;
   11882:	8a e0       	ldi	r24, 0x0A	; 10
   11884:	80 93 68 02 	sts	0x0268, r24
		  }
	 	  KeyPressed=_key_scan(1);
   11888:	81 e0       	ldi	r24, 0x01	; 1
   1188a:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
   1188e:	80 93 67 02 	sts	0x0267, r24
		  if (KeyPressed==_KEY_CANCEL){
   11892:	87 3e       	cpi	r24, 0xE7	; 231
   11894:	11 f4       	brne	.+4      	; 0x1189a <FMenuReprint+0x208>
		      stReprint=rtFIP;
   11896:	87 e0       	ldi	r24, 0x07	; 7
   11898:	52 cf       	rjmp	.-348    	; 0x1173e <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   1189a:	87 3b       	cpi	r24, 0xB7	; 183
   1189c:	69 f5       	brne	.+90     	; 0x118f8 <FMenuReprint+0x266>
   1189e:	4e cf       	rjmp	.-356    	; 0x1173c <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   118a0:	0e 94 45 8b 	call	0x1168a	; 0x1168a <sendMessage28>
		  TimSend=0;
   118a4:	10 92 78 0c 	sts	0x0C78, r1
		  stReprint=rtWaitReply;
   118a8:	8b e0       	ldi	r24, 0x0B	; 11
   118aa:	49 cf       	rjmp	.-366    	; 0x1173e <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   118ac:	80 91 78 0c 	lds	r24, 0x0C78
   118b0:	8f 31       	cpi	r24, 0x1F	; 31
   118b2:	18 f0       	brcs	.+6      	; 0x118ba <FMenuReprint+0x228>
   118b4:	8c e0       	ldi	r24, 0x0C	; 12
   118b6:	80 93 68 02 	sts	0x0268, r24
	      if (IsMessage99==True){
   118ba:	80 91 9f 01 	lds	r24, 0x019F
   118be:	3b cf       	rjmp	.-394    	; 0x11736 <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   118c0:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   118c4:	82 e0       	ldi	r24, 0x02	; 2
   118c6:	61 e0       	ldi	r22, 0x01	; 1
   118c8:	40 ea       	ldi	r20, 0xA0	; 160
   118ca:	5a e1       	ldi	r21, 0x1A	; 26
   118cc:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   118d0:	83 e0       	ldi	r24, 0x03	; 3
   118d2:	61 e0       	ldi	r22, 0x01	; 1
   118d4:	42 e9       	ldi	r20, 0x92	; 146
   118d6:	5a e1       	ldi	r21, 0x1A	; 26
   118d8:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  TimDisplay=5;
   118dc:	85 e0       	ldi	r24, 0x05	; 5
   118de:	80 93 92 01 	sts	0x0192, r24
		  stReprint=rtDelayExitReprint;
   118e2:	8d e0       	ldi	r24, 0x0D	; 13
   118e4:	2c cf       	rjmp	.-424    	; 0x1173e <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   118e6:	80 91 92 01 	lds	r24, 0x0192
   118ea:	8a 30       	cpi	r24, 0x0A	; 10
   118ec:	28 f0       	brcs	.+10     	; 0x118f8 <FMenuReprint+0x266>
   118ee:	26 cf       	rjmp	.-436    	; 0x1173c <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   118f0:	10 92 68 02 	sts	0x0268, r1
   118f4:	81 e0       	ldi	r24, 0x01	; 1
   118f6:	01 c0       	rjmp	.+2      	; 0x118fa <FMenuReprint+0x268>
   118f8:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   118fa:	64 96       	adiw	r28, 0x14	; 20
   118fc:	0f b6       	in	r0, 0x3f	; 63
   118fe:	f8 94       	cli
   11900:	de bf       	out	0x3e, r29	; 62
   11902:	0f be       	out	0x3f, r0	; 63
   11904:	cd bf       	out	0x3d, r28	; 61
   11906:	cf 91       	pop	r28
   11908:	df 91       	pop	r29
   1190a:	1f 91       	pop	r17
   1190c:	0f 91       	pop	r16
   1190e:	08 95       	ret

00011910 <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   11910:	80 91 4b 02 	lds	r24, 0x024B
   11914:	83 30       	cpi	r24, 0x03	; 3
   11916:	09 f4       	brne	.+2      	; 0x1191a <FMenuAdmin+0xa>
   11918:	66 c0       	rjmp	.+204    	; 0x119e6 <FMenuAdmin+0xd6>
   1191a:	84 30       	cpi	r24, 0x04	; 4
   1191c:	30 f4       	brcc	.+12     	; 0x1192a <FMenuAdmin+0x1a>
   1191e:	81 30       	cpi	r24, 0x01	; 1
   11920:	69 f1       	breq	.+90     	; 0x1197c <FMenuAdmin+0x6c>
   11922:	82 30       	cpi	r24, 0x02	; 2
   11924:	08 f0       	brcs	.+2      	; 0x11928 <FMenuAdmin+0x18>
   11926:	4d c0       	rjmp	.+154    	; 0x119c2 <FMenuAdmin+0xb2>
   11928:	0d c0       	rjmp	.+26     	; 0x11944 <FMenuAdmin+0x34>
   1192a:	85 30       	cpi	r24, 0x05	; 5
   1192c:	09 f4       	brne	.+2      	; 0x11930 <FMenuAdmin+0x20>
   1192e:	4e c0       	rjmp	.+156    	; 0x119cc <FMenuAdmin+0xbc>
   11930:	85 30       	cpi	r24, 0x05	; 5
   11932:	08 f4       	brcc	.+2      	; 0x11936 <FMenuAdmin+0x26>
   11934:	49 c0       	rjmp	.+146    	; 0x119c8 <FMenuAdmin+0xb8>
   11936:	86 30       	cpi	r24, 0x06	; 6
   11938:	09 f4       	brne	.+2      	; 0x1193c <FMenuAdmin+0x2c>
   1193a:	51 c0       	rjmp	.+162    	; 0x119de <FMenuAdmin+0xce>
   1193c:	87 30       	cpi	r24, 0x07	; 7
   1193e:	09 f0       	breq	.+2      	; 0x11942 <FMenuAdmin+0x32>
   11940:	5a c0       	rjmp	.+180    	; 0x119f6 <FMenuAdmin+0xe6>
   11942:	55 c0       	rjmp	.+170    	; 0x119ee <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   11944:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   11948:	81 e0       	ldi	r24, 0x01	; 1
   1194a:	61 e0       	ldi	r22, 0x01	; 1
   1194c:	4d e9       	ldi	r20, 0x9D	; 157
   1194e:	55 e1       	ldi	r21, 0x15	; 21
   11950:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   11954:	82 e0       	ldi	r24, 0x02	; 2
   11956:	61 e0       	ldi	r22, 0x01	; 1
   11958:	48 e8       	ldi	r20, 0x88	; 136
   1195a:	55 e1       	ldi	r21, 0x15	; 21
   1195c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   11960:	83 e0       	ldi	r24, 0x03	; 3
   11962:	61 e0       	ldi	r22, 0x01	; 1
   11964:	43 e7       	ldi	r20, 0x73	; 115
   11966:	55 e1       	ldi	r21, 0x15	; 21
   11968:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   1196c:	84 e0       	ldi	r24, 0x04	; 4
   1196e:	61 e0       	ldi	r22, 0x01	; 1
   11970:	4e e5       	ldi	r20, 0x5E	; 94
   11972:	55 e1       	ldi	r21, 0x15	; 21
   11974:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   11978:	81 e0       	ldi	r24, 0x01	; 1
   1197a:	2e c0       	rjmp	.+92     	; 0x119d8 <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   1197c:	81 e0       	ldi	r24, 0x01	; 1
   1197e:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11982:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
		  switch (KeyChar){
   11986:	82 33       	cpi	r24, 0x32	; 50
   11988:	71 f0       	breq	.+28     	; 0x119a6 <FMenuAdmin+0x96>
   1198a:	83 33       	cpi	r24, 0x33	; 51
   1198c:	28 f4       	brcc	.+10     	; 0x11998 <FMenuAdmin+0x88>
   1198e:	8a 32       	cpi	r24, 0x2A	; 42
   11990:	11 f1       	breq	.+68     	; 0x119d6 <FMenuAdmin+0xc6>
   11992:	81 33       	cpi	r24, 0x31	; 49
   11994:	81 f5       	brne	.+96     	; 0x119f6 <FMenuAdmin+0xe6>
   11996:	05 c0       	rjmp	.+10     	; 0x119a2 <FMenuAdmin+0x92>
   11998:	83 33       	cpi	r24, 0x33	; 51
   1199a:	59 f0       	breq	.+22     	; 0x119b2 <FMenuAdmin+0xa2>
   1199c:	84 33       	cpi	r24, 0x34	; 52
   1199e:	59 f5       	brne	.+86     	; 0x119f6 <FMenuAdmin+0xe6>
   119a0:	0e c0       	rjmp	.+28     	; 0x119be <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   119a2:	82 e0       	ldi	r24, 0x02	; 2
   119a4:	19 c0       	rjmp	.+50     	; 0x119d8 <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   119a6:	80 91 00 01 	lds	r24, 0x0100
   119aa:	82 30       	cpi	r24, 0x02	; 2
   119ac:	e1 f4       	brne	.+56     	; 0x119e6 <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   119ae:	84 e0       	ldi	r24, 0x04	; 4
   119b0:	13 c0       	rjmp	.+38     	; 0x119d8 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   119b2:	80 91 00 01 	lds	r24, 0x0100
   119b6:	82 30       	cpi	r24, 0x02	; 2
   119b8:	b1 f4       	brne	.+44     	; 0x119e6 <FMenuAdmin+0xd6>
   119ba:	85 e0       	ldi	r24, 0x05	; 5
   119bc:	0d c0       	rjmp	.+26     	; 0x119d8 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   119be:	86 e0       	ldi	r24, 0x06	; 6
   119c0:	0b c0       	rjmp	.+22     	; 0x119d8 <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   119c2:	0e 94 49 8b 	call	0x11692	; 0x11692 <FMenuReprint>
   119c6:	05 c0       	rjmp	.+10     	; 0x119d2 <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   119c8:	82 e0       	ldi	r24, 0x02	; 2
   119ca:	01 c0       	rjmp	.+2      	; 0x119ce <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   119cc:	81 e0       	ldi	r24, 0x01	; 1
   119ce:	0e 94 6b 47 	call	0x8ed6	; 0x8ed6 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   119d2:	81 30       	cpi	r24, 0x01	; 1
   119d4:	81 f4       	brne	.+32     	; 0x119f6 <FMenuAdmin+0xe6>
   119d6:	87 e0       	ldi	r24, 0x07	; 7
   119d8:	80 93 4b 02 	sts	0x024B, r24
   119dc:	06 c0       	rjmp	.+12     	; 0x119ea <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   119de:	0e 94 0f 72 	call	0xe41e	; 0xe41e <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   119e2:	81 30       	cpi	r24, 0x01	; 1
   119e4:	41 f4       	brne	.+16     	; 0x119f6 <FMenuAdmin+0xe6>
   119e6:	10 92 4b 02 	sts	0x024B, r1
   119ea:	80 e0       	ldi	r24, 0x00	; 0
   119ec:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   119ee:	10 92 4b 02 	sts	0x024B, r1
   119f2:	81 e0       	ldi	r24, 0x01	; 1
   119f4:	08 95       	ret
   119f6:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   119f8:	08 95       	ret

000119fa <FMenuAuthorization>:


char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   119fa:	80 91 5a 02 	lds	r24, 0x025A
   119fe:	83 30       	cpi	r24, 0x03	; 3
   11a00:	51 f1       	breq	.+84     	; 0x11a56 <FMenuAuthorization+0x5c>
   11a02:	84 30       	cpi	r24, 0x04	; 4
   11a04:	28 f4       	brcc	.+10     	; 0x11a10 <FMenuAuthorization+0x16>
   11a06:	81 30       	cpi	r24, 0x01	; 1
   11a08:	81 f0       	breq	.+32     	; 0x11a2a <FMenuAuthorization+0x30>
   11a0a:	82 30       	cpi	r24, 0x02	; 2
   11a0c:	38 f5       	brcc	.+78     	; 0x11a5c <FMenuAuthorization+0x62>
   11a0e:	0a c0       	rjmp	.+20     	; 0x11a24 <FMenuAuthorization+0x2a>
   11a10:	85 30       	cpi	r24, 0x05	; 5
   11a12:	61 f1       	breq	.+88     	; 0x11a6c <FMenuAuthorization+0x72>
   11a14:	85 30       	cpi	r24, 0x05	; 5
   11a16:	28 f1       	brcs	.+74     	; 0x11a62 <FMenuAuthorization+0x68>
   11a18:	86 30       	cpi	r24, 0x06	; 6
   11a1a:	e1 f1       	breq	.+120    	; 0x11a94 <FMenuAuthorization+0x9a>
   11a1c:	87 30       	cpi	r24, 0x07	; 7
   11a1e:	09 f0       	breq	.+2      	; 0x11a22 <FMenuAuthorization+0x28>
   11a20:	4c c0       	rjmp	.+152    	; 0x11aba <FMenuAuthorization+0xc0>
   11a22:	47 c0       	rjmp	.+142    	; 0x11ab2 <FMenuAuthorization+0xb8>
	 case maInit:
	      PassTry=0;
   11a24:	10 92 59 02 	sts	0x0259, r1
   11a28:	3d c0       	rjmp	.+122    	; 0x11aa4 <FMenuAuthorization+0xaa>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   11a2a:	0e 94 a7 74 	call	0xe94e	; 0xe94e <FMenuPassword>
		  switch(PassResult){
   11a2e:	83 30       	cpi	r24, 0x03	; 3
   11a30:	e1 f1       	breq	.+120    	; 0x11aaa <FMenuAuthorization+0xb0>
   11a32:	84 30       	cpi	r24, 0x04	; 4
   11a34:	28 f4       	brcc	.+10     	; 0x11a40 <FMenuAuthorization+0x46>
   11a36:	81 30       	cpi	r24, 0x01	; 1
   11a38:	b9 f1       	breq	.+110    	; 0x11aa8 <FMenuAuthorization+0xae>
   11a3a:	82 30       	cpi	r24, 0x02	; 2
   11a3c:	f1 f5       	brne	.+124    	; 0x11aba <FMenuAuthorization+0xc0>
   11a3e:	09 c0       	rjmp	.+18     	; 0x11a52 <FMenuAuthorization+0x58>
   11a40:	84 30       	cpi	r24, 0x04	; 4
   11a42:	19 f0       	breq	.+6      	; 0x11a4a <FMenuAuthorization+0x50>
   11a44:	85 30       	cpi	r24, 0x05	; 5
   11a46:	c9 f5       	brne	.+114    	; 0x11aba <FMenuAuthorization+0xc0>
   11a48:	02 c0       	rjmp	.+4      	; 0x11a4e <FMenuAuthorization+0x54>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   11a4a:	82 e0       	ldi	r24, 0x02	; 2
   11a4c:	2e c0       	rjmp	.+92     	; 0x11aaa <FMenuAuthorization+0xb0>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   11a4e:	84 e0       	ldi	r24, 0x04	; 4
   11a50:	2c c0       	rjmp	.+88     	; 0x11aaa <FMenuAuthorization+0xb0>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   11a52:	85 e0       	ldi	r24, 0x05	; 5
   11a54:	2a c0       	rjmp	.+84     	; 0x11aaa <FMenuAuthorization+0xb0>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   11a56:	0e 94 96 72 	call	0xe52c	; 0xe52c <FMenuMaster>
   11a5a:	05 c0       	rjmp	.+10     	; 0x11a66 <FMenuAuthorization+0x6c>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   11a5c:	0e 94 88 8c 	call	0x11910	; 0x11910 <FMenuAdmin>
   11a60:	02 c0       	rjmp	.+4      	; 0x11a66 <FMenuAuthorization+0x6c>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   11a62:	0e 94 3c 77 	call	0xee78	; 0xee78 <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   11a66:	81 30       	cpi	r24, 0x01	; 1
   11a68:	41 f5       	brne	.+80     	; 0x11aba <FMenuAuthorization+0xc0>
   11a6a:	1e c0       	rjmp	.+60     	; 0x11aa8 <FMenuAuthorization+0xae>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   11a6c:	80 91 59 02 	lds	r24, 0x0259
   11a70:	8f 5f       	subi	r24, 0xFF	; 255
   11a72:	80 93 59 02 	sts	0x0259, r24
	      TimDisplay=0;
   11a76:	10 92 92 01 	sts	0x0192, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11a7a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11a7c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11a7e:	81 e0       	ldi	r24, 0x01	; 1
   11a80:	80 93 bc 01 	sts	0x01BC, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   11a84:	83 e0       	ldi	r24, 0x03	; 3
   11a86:	61 e0       	ldi	r22, 0x01	; 1
   11a88:	49 e9       	ldi	r20, 0x99	; 153
   11a8a:	57 e1       	ldi	r21, 0x17	; 23
   11a8c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   11a90:	86 e0       	ldi	r24, 0x06	; 6
   11a92:	0b c0       	rjmp	.+22     	; 0x11aaa <FMenuAuthorization+0xb0>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   11a94:	80 91 92 01 	lds	r24, 0x0192
   11a98:	83 30       	cpi	r24, 0x03	; 3
   11a9a:	78 f0       	brcs	.+30     	; 0x11aba <FMenuAuthorization+0xc0>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   11a9c:	80 91 59 02 	lds	r24, 0x0259
   11aa0:	83 30       	cpi	r24, 0x03	; 3
   11aa2:	10 f4       	brcc	.+4      	; 0x11aa8 <FMenuAuthorization+0xae>
   11aa4:	81 e0       	ldi	r24, 0x01	; 1
   11aa6:	01 c0       	rjmp	.+2      	; 0x11aaa <FMenuAuthorization+0xb0>
			  else stMenuAuthorization=maExitAuthorization;
   11aa8:	87 e0       	ldi	r24, 0x07	; 7
   11aaa:	80 93 5a 02 	sts	0x025A, r24
   11aae:	80 e0       	ldi	r24, 0x00	; 0
   11ab0:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   11ab2:	10 92 5a 02 	sts	0x025A, r1
   11ab6:	81 e0       	ldi	r24, 0x01	; 1
   11ab8:	08 95       	ret
   11aba:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   11abc:	08 95       	ret

00011abe <sendMessage24>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_24);
   11abe:	84 e2       	ldi	r24, 0x24	; 36
   11ac0:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
   11ac4:	08 95       	ret

00011ac6 <sendMessage22>:
    uart_print(1, 0,strSend);
	UpdateCardID();
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	*/IFTSendMessage(MSG_22);
   11ac6:	82 e2       	ldi	r24, 0x22	; 34
   11ac8:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
   11acc:	08 95       	ret

00011ace <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
   11ace:	cf 92       	push	r12
   11ad0:	df 92       	push	r13
   11ad2:	ef 92       	push	r14
   11ad4:	ff 92       	push	r15
   11ad6:	0f 93       	push	r16
   11ad8:	1f 93       	push	r17
   11ada:	df 93       	push	r29
   11adc:	cf 93       	push	r28
   11ade:	cd b7       	in	r28, 0x3d	; 61
   11ae0:	de b7       	in	r29, 0x3e	; 62
   11ae2:	64 97       	sbiw	r28, 0x14	; 20
   11ae4:	0f b6       	in	r0, 0x3f	; 63
   11ae6:	f8 94       	cli
   11ae8:	de bf       	out	0x3e, r29	; 62
   11aea:	0f be       	out	0x3f, r0	; 63
   11aec:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyPressed=0,KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
   11aee:	00 91 65 02 	lds	r16, 0x0265
   11af2:	07 30       	cpi	r16, 0x07	; 7
   11af4:	09 f4       	brne	.+2      	; 0x11af8 <FMenuLoyalty+0x2a>
   11af6:	04 c1       	rjmp	.+520    	; 0x11d00 <FMenuLoyalty+0x232>
   11af8:	08 30       	cpi	r16, 0x08	; 8
   11afa:	98 f4       	brcc	.+38     	; 0x11b22 <FMenuLoyalty+0x54>
   11afc:	03 30       	cpi	r16, 0x03	; 3
   11afe:	09 f4       	brne	.+2      	; 0x11b02 <FMenuLoyalty+0x34>
   11b00:	5b c0       	rjmp	.+182    	; 0x11bb8 <FMenuLoyalty+0xea>
   11b02:	04 30       	cpi	r16, 0x04	; 4
   11b04:	38 f4       	brcc	.+14     	; 0x11b14 <FMenuLoyalty+0x46>
   11b06:	01 30       	cpi	r16, 0x01	; 1
   11b08:	09 f4       	brne	.+2      	; 0x11b0c <FMenuLoyalty+0x3e>
   11b0a:	42 c0       	rjmp	.+132    	; 0x11b90 <FMenuLoyalty+0xc2>
   11b0c:	02 30       	cpi	r16, 0x02	; 2
   11b0e:	08 f0       	brcs	.+2      	; 0x11b12 <FMenuLoyalty+0x44>
   11b10:	61 c0       	rjmp	.+194    	; 0x11bd4 <FMenuLoyalty+0x106>
   11b12:	20 c0       	rjmp	.+64     	; 0x11b54 <FMenuLoyalty+0x86>
   11b14:	05 30       	cpi	r16, 0x05	; 5
   11b16:	09 f4       	brne	.+2      	; 0x11b1a <FMenuLoyalty+0x4c>
   11b18:	a2 c0       	rjmp	.+324    	; 0x11c5e <FMenuLoyalty+0x190>
   11b1a:	06 30       	cpi	r16, 0x06	; 6
   11b1c:	08 f0       	brcs	.+2      	; 0x11b20 <FMenuLoyalty+0x52>
   11b1e:	ba c0       	rjmp	.+372    	; 0x11c94 <FMenuLoyalty+0x1c6>
   11b20:	8c c0       	rjmp	.+280    	; 0x11c3a <FMenuLoyalty+0x16c>
   11b22:	0b 30       	cpi	r16, 0x0B	; 11
   11b24:	09 f4       	brne	.+2      	; 0x11b28 <FMenuLoyalty+0x5a>
   11b26:	36 c1       	rjmp	.+620    	; 0x11d94 <FMenuLoyalty+0x2c6>
   11b28:	0c 30       	cpi	r16, 0x0C	; 12
   11b2a:	38 f4       	brcc	.+14     	; 0x11b3a <FMenuLoyalty+0x6c>
   11b2c:	09 30       	cpi	r16, 0x09	; 9
   11b2e:	09 f4       	brne	.+2      	; 0x11b32 <FMenuLoyalty+0x64>
   11b30:	f0 c0       	rjmp	.+480    	; 0x11d12 <FMenuLoyalty+0x244>
   11b32:	0a 30       	cpi	r16, 0x0A	; 10
   11b34:	08 f0       	brcs	.+2      	; 0x11b38 <FMenuLoyalty+0x6a>
   11b36:	10 c1       	rjmp	.+544    	; 0x11d58 <FMenuLoyalty+0x28a>
   11b38:	e6 c0       	rjmp	.+460    	; 0x11d06 <FMenuLoyalty+0x238>
   11b3a:	0d 30       	cpi	r16, 0x0D	; 13
   11b3c:	09 f4       	brne	.+2      	; 0x11b40 <FMenuLoyalty+0x72>
   11b3e:	ee c1       	rjmp	.+988    	; 0x11f1c <FMenuLoyalty+0x44e>
   11b40:	0d 30       	cpi	r16, 0x0D	; 13
   11b42:	08 f4       	brcc	.+2      	; 0x11b46 <FMenuLoyalty+0x78>
   11b44:	f5 c1       	rjmp	.+1002   	; 0x11f30 <FMenuLoyalty+0x462>
   11b46:	0e 30       	cpi	r16, 0x0E	; 14
   11b48:	09 f4       	brne	.+2      	; 0x11b4c <FMenuLoyalty+0x7e>
   11b4a:	04 c2       	rjmp	.+1032   	; 0x11f54 <FMenuLoyalty+0x486>
   11b4c:	0f 30       	cpi	r16, 0x0F	; 15
   11b4e:	09 f0       	breq	.+2      	; 0x11b52 <FMenuLoyalty+0x84>
   11b50:	0d c2       	rjmp	.+1050   	; 0x11f6c <FMenuLoyalty+0x49e>
   11b52:	06 c2       	rjmp	.+1036   	; 0x11f60 <FMenuLoyalty+0x492>
	 case mlInit:
	      lcd_clear();
   11b54:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
   11b58:	81 e0       	ldi	r24, 0x01	; 1
   11b5a:	61 e0       	ldi	r22, 0x01	; 1
   11b5c:	40 e8       	ldi	r20, 0x80	; 128
   11b5e:	5a e1       	ldi	r21, 0x1A	; 26
   11b60:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
   11b64:	81 e0       	ldi	r24, 0x01	; 1
   11b66:	61 e0       	ldi	r22, 0x01	; 1
   11b68:	4e e6       	ldi	r20, 0x6E	; 110
   11b6a:	5a e1       	ldi	r21, 0x1A	; 26
   11b6c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
   11b70:	82 e0       	ldi	r24, 0x02	; 2
   11b72:	61 e0       	ldi	r22, 0x01	; 1
   11b74:	4c e5       	ldi	r20, 0x5C	; 92
   11b76:	5a e1       	ldi	r21, 0x1A	; 26
   11b78:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
   11b7c:	84 e0       	ldi	r24, 0x04	; 4
   11b7e:	61 e0       	ldi	r22, 0x01	; 1
   11b80:	4a e4       	ldi	r20, 0x4A	; 74
   11b82:	5a e1       	ldi	r21, 0x1A	; 26
   11b84:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  IsLoyaltyUpdate=False;
   11b88:	10 92 63 02 	sts	0x0263, r1
		  stLoyalty=mlLoyaltySelect;
   11b8c:	81 e0       	ldi	r24, 0x01	; 1
   11b8e:	08 c0       	rjmp	.+16     	; 0x11ba0 <FMenuLoyalty+0xd2>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
   11b90:	81 e0       	ldi	r24, 0x01	; 1
   11b92:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  if (KeyPressed==_KEY_1){
   11b96:	8e 3e       	cpi	r24, 0xEE	; 238
   11b98:	31 f4       	brne	.+12     	; 0x11ba6 <FMenuLoyalty+0xd8>
		      IsLoyaltyUpdate=False;
   11b9a:	10 92 63 02 	sts	0x0263, r1
		      stLoyalty=mlShowEnquiry;
   11b9e:	84 e0       	ldi	r24, 0x04	; 4
   11ba0:	80 93 65 02 	sts	0x0265, r24
   11ba4:	e3 c1       	rjmp	.+966    	; 0x11f6c <FMenuLoyalty+0x49e>
			  }
		  else
		  if (KeyPressed==_KEY_2){
   11ba6:	8e 3d       	cpi	r24, 0xDE	; 222
   11ba8:	19 f4       	brne	.+6      	; 0x11bb0 <FMenuLoyalty+0xe2>
		      IsLoyaltyUpdate=True;
   11baa:	00 93 63 02 	sts	0x0263, r16
   11bae:	69 c0       	rjmp	.+210    	; 0x11c82 <FMenuLoyalty+0x1b4>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
   11bb0:	87 3e       	cpi	r24, 0xE7	; 231
   11bb2:	09 f4       	brne	.+2      	; 0x11bb6 <FMenuLoyalty+0xe8>
   11bb4:	d3 c1       	rjmp	.+934    	; 0x11f5c <FMenuLoyalty+0x48e>
   11bb6:	da c1       	rjmp	.+948    	; 0x11f6c <FMenuLoyalty+0x49e>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   11bb8:	84 e6       	ldi	r24, 0x64	; 100
   11bba:	92 e0       	ldi	r25, 0x02	; 2
   11bbc:	69 eb       	ldi	r22, 0xB9	; 185
   11bbe:	77 e0       	ldi	r23, 0x07	; 7
   11bc0:	0e 94 6e 53 	call	0xa6dc	; 0xa6dc <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
   11bc4:	88 23       	and	r24, r24
   11bc6:	11 f4       	brne	.+4      	; 0x11bcc <FMenuLoyalty+0xfe>
   11bc8:	82 e0       	ldi	r24, 0x02	; 2
   11bca:	ea cf       	rjmp	.-44     	; 0x11ba0 <FMenuLoyalty+0xd2>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
   11bcc:	82 30       	cpi	r24, 0x02	; 2
   11bce:	09 f0       	breq	.+2      	; 0x11bd2 <FMenuLoyalty+0x104>
   11bd0:	cd c1       	rjmp	.+922    	; 0x11f6c <FMenuLoyalty+0x49e>
   11bd2:	59 c0       	rjmp	.+178    	; 0x11c86 <FMenuLoyalty+0x1b8>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
   11bd4:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
   11bd8:	00 d0       	rcall	.+0      	; 0x11bda <FMenuLoyalty+0x10c>
   11bda:	00 d0       	rcall	.+0      	; 0x11bdc <FMenuLoyalty+0x10e>
   11bdc:	00 d0       	rcall	.+0      	; 0x11bde <FMenuLoyalty+0x110>
   11bde:	ed b7       	in	r30, 0x3d	; 61
   11be0:	fe b7       	in	r31, 0x3e	; 62
   11be2:	31 96       	adiw	r30, 0x01	; 1
   11be4:	8e 01       	movw	r16, r28
   11be6:	0f 5f       	subi	r16, 0xFF	; 255
   11be8:	1f 4f       	sbci	r17, 0xFF	; 255
   11bea:	ad b7       	in	r26, 0x3d	; 61
   11bec:	be b7       	in	r27, 0x3e	; 62
   11bee:	12 96       	adiw	r26, 0x02	; 2
   11bf0:	1c 93       	st	X, r17
   11bf2:	0e 93       	st	-X, r16
   11bf4:	11 97       	sbiw	r26, 0x01	; 1
   11bf6:	83 e4       	ldi	r24, 0x43	; 67
   11bf8:	9a e1       	ldi	r25, 0x1A	; 26
   11bfa:	93 83       	std	Z+3, r25	; 0x03
   11bfc:	82 83       	std	Z+2, r24	; 0x02
   11bfe:	89 eb       	ldi	r24, 0xB9	; 185
   11c00:	97 e0       	ldi	r25, 0x07	; 7
   11c02:	95 83       	std	Z+5, r25	; 0x05
   11c04:	84 83       	std	Z+4, r24	; 0x04
   11c06:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   11c0a:	8d b7       	in	r24, 0x3d	; 61
   11c0c:	9e b7       	in	r25, 0x3e	; 62
   11c0e:	06 96       	adiw	r24, 0x06	; 6
   11c10:	0f b6       	in	r0, 0x3f	; 63
   11c12:	f8 94       	cli
   11c14:	9e bf       	out	0x3e, r25	; 62
   11c16:	0f be       	out	0x3f, r0	; 63
   11c18:	8d bf       	out	0x3d, r24	; 61
   11c1a:	81 e0       	ldi	r24, 0x01	; 1
   11c1c:	61 e0       	ldi	r22, 0x01	; 1
   11c1e:	44 e3       	ldi	r20, 0x34	; 52
   11c20:	5a e1       	ldi	r21, 0x1A	; 26
   11c22:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_print(2,1,lcdteks);
   11c26:	82 e0       	ldi	r24, 0x02	; 2
   11c28:	61 e0       	ldi	r22, 0x01	; 1
   11c2a:	a8 01       	movw	r20, r16
   11c2c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   11c30:	84 e0       	ldi	r24, 0x04	; 4
   11c32:	61 e0       	ldi	r22, 0x01	; 1
   11c34:	41 e2       	ldi	r20, 0x21	; 33
   11c36:	5a e1       	ldi	r21, 0x1A	; 26
   11c38:	0c c0       	rjmp	.+24     	; 0x11c52 <FMenuLoyalty+0x184>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
   11c3a:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   11c3e:	81 e0       	ldi	r24, 0x01	; 1
   11c40:	61 e0       	ldi	r22, 0x01	; 1
   11c42:	42 e1       	ldi	r20, 0x12	; 18
   11c44:	5a e1       	ldi	r21, 0x1A	; 26
   11c46:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   11c4a:	84 e0       	ldi	r24, 0x04	; 4
   11c4c:	61 e0       	ldi	r22, 0x01	; 1
   11c4e:	4f ef       	ldi	r20, 0xFF	; 255
   11c50:	59 e1       	ldi	r21, 0x19	; 25
   11c52:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  IsRFIDDetected=False;
   11c56:	10 92 98 01 	sts	0x0198, r1
		  stLoyalty=mlInputRFID;
   11c5a:	85 e0       	ldi	r24, 0x05	; 5
   11c5c:	a1 cf       	rjmp	.-190    	; 0x11ba0 <FMenuLoyalty+0xd2>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
   11c5e:	80 91 98 01 	lds	r24, 0x0198
   11c62:	81 30       	cpi	r24, 0x01	; 1
   11c64:	29 f4       	brne	.+10     	; 0x11c70 <FMenuLoyalty+0x1a2>
		      IsRFIDDetected=False;
   11c66:	10 92 98 01 	sts	0x0198, r1
		      stLoyalty=mlShowProsesRFID;
   11c6a:	86 e0       	ldi	r24, 0x06	; 6
   11c6c:	80 93 65 02 	sts	0x0265, r24
		  }
	 	  KeyPressed=_key_scan(1);
   11c70:	81 e0       	ldi	r24, 0x01	; 1
   11c72:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
		  if (KeyPressed==_KEY_CANCEL){
   11c76:	87 3e       	cpi	r24, 0xE7	; 231
   11c78:	49 f4       	brne	.+18     	; 0x11c8c <FMenuLoyalty+0x1be>
		      if (IsLoyaltyUpdate==True)
   11c7a:	80 91 63 02 	lds	r24, 0x0263
   11c7e:	81 30       	cpi	r24, 0x01	; 1
   11c80:	11 f4       	brne	.+4      	; 0x11c86 <FMenuLoyalty+0x1b8>
			       stLoyalty=mlSelectFIP;
   11c82:	83 e0       	ldi	r24, 0x03	; 3
   11c84:	8d cf       	rjmp	.-230    	; 0x11ba0 <FMenuLoyalty+0xd2>
			  else stLoyalty=mlInit;
   11c86:	10 92 65 02 	sts	0x0265, r1
   11c8a:	70 c1       	rjmp	.+736    	; 0x11f6c <FMenuLoyalty+0x49e>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
   11c8c:	87 3b       	cpi	r24, 0xB7	; 183
   11c8e:	09 f0       	breq	.+2      	; 0x11c92 <FMenuLoyalty+0x1c4>
   11c90:	6d c1       	rjmp	.+730    	; 0x11f6c <FMenuLoyalty+0x49e>
   11c92:	64 c1       	rjmp	.+712    	; 0x11f5c <FMenuLoyalty+0x48e>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
   11c94:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
   11c98:	00 d0       	rcall	.+0      	; 0x11c9a <FMenuLoyalty+0x1cc>
   11c9a:	00 d0       	rcall	.+0      	; 0x11c9c <FMenuLoyalty+0x1ce>
   11c9c:	00 d0       	rcall	.+0      	; 0x11c9e <FMenuLoyalty+0x1d0>
   11c9e:	ed b7       	in	r30, 0x3d	; 61
   11ca0:	fe b7       	in	r31, 0x3e	; 62
   11ca2:	31 96       	adiw	r30, 0x01	; 1
   11ca4:	8e 01       	movw	r16, r28
   11ca6:	0f 5f       	subi	r16, 0xFF	; 255
   11ca8:	1f 4f       	sbci	r17, 0xFF	; 255
   11caa:	ad b7       	in	r26, 0x3d	; 61
   11cac:	be b7       	in	r27, 0x3e	; 62
   11cae:	12 96       	adiw	r26, 0x02	; 2
   11cb0:	1c 93       	st	X, r17
   11cb2:	0e 93       	st	-X, r16
   11cb4:	11 97       	sbiw	r26, 0x01	; 1
   11cb6:	89 ef       	ldi	r24, 0xF9	; 249
   11cb8:	99 e1       	ldi	r25, 0x19	; 25
   11cba:	93 83       	std	Z+3, r25	; 0x03
   11cbc:	82 83       	std	Z+2, r24	; 0x02
   11cbe:	81 e5       	ldi	r24, 0x51	; 81
   11cc0:	9c e0       	ldi	r25, 0x0C	; 12
   11cc2:	95 83       	std	Z+5, r25	; 0x05
   11cc4:	84 83       	std	Z+4, r24	; 0x04
   11cc6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
   11cca:	8d b7       	in	r24, 0x3d	; 61
   11ccc:	9e b7       	in	r25, 0x3e	; 62
   11cce:	06 96       	adiw	r24, 0x06	; 6
   11cd0:	0f b6       	in	r0, 0x3f	; 63
   11cd2:	f8 94       	cli
   11cd4:	9e bf       	out	0x3e, r25	; 62
   11cd6:	0f be       	out	0x3f, r0	; 63
   11cd8:	8d bf       	out	0x3d, r24	; 61
   11cda:	81 e0       	ldi	r24, 0x01	; 1
   11cdc:	61 e0       	ldi	r22, 0x01	; 1
   11cde:	a8 01       	movw	r20, r16
   11ce0:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
   11ce4:	82 e0       	ldi	r24, 0x02	; 2
   11ce6:	61 e0       	ldi	r22, 0x01	; 1
   11ce8:	42 ef       	ldi	r20, 0xF2	; 242
   11cea:	59 e1       	ldi	r21, 0x19	; 25
   11cec:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
   11cf0:	80 91 63 02 	lds	r24, 0x0263
   11cf4:	81 30       	cpi	r24, 0x01	; 1
   11cf6:	11 f4       	brne	.+4      	; 0x11cfc <FMenuLoyalty+0x22e>
   11cf8:	88 e0       	ldi	r24, 0x08	; 8
   11cfa:	52 cf       	rjmp	.-348    	; 0x11ba0 <FMenuLoyalty+0xd2>
		  else stLoyalty=mlSendMessage22;
   11cfc:	87 e0       	ldi	r24, 0x07	; 7
   11cfe:	50 cf       	rjmp	.-352    	; 0x11ba0 <FMenuLoyalty+0xd2>
	      break;
     case mlSendMessage22:
	      sendMessage22();
   11d00:	0e 94 63 8d 	call	0x11ac6	; 0x11ac6 <sendMessage22>
   11d04:	02 c0       	rjmp	.+4      	; 0x11d0a <FMenuLoyalty+0x23c>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
   11d06:	0e 94 5f 8d 	call	0x11abe	; 0x11abe <sendMessage24>
		  TimSend=0;		  
   11d0a:	10 92 78 0c 	sts	0x0C78, r1
          stLoyalty=mlWaitReply;
   11d0e:	89 e0       	ldi	r24, 0x09	; 9
   11d10:	47 cf       	rjmp	.-370    	; 0x11ba0 <FMenuLoyalty+0xd2>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
   11d12:	80 91 78 0c 	lds	r24, 0x0C78
   11d16:	8f 31       	cpi	r24, 0x1F	; 31
   11d18:	18 f0       	brcs	.+6      	; 0x11d20 <FMenuLoyalty+0x252>
		      stLoyalty=mlNoConnection;
   11d1a:	8c e0       	ldi	r24, 0x0C	; 12
   11d1c:	80 93 65 02 	sts	0x0265, r24
	      if (IsMessage23==True){
   11d20:	80 91 a2 01 	lds	r24, 0x01A2
   11d24:	81 30       	cpi	r24, 0x01	; 1
   11d26:	39 f4       	brne	.+14     	; 0x11d36 <FMenuLoyalty+0x268>
		      IsMessage23=False;
   11d28:	10 92 a2 01 	sts	0x01A2, r1
			  procMessage23();
   11d2c:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <procMessage23>
			  stLoyalty=mlDispEnquiry;
   11d30:	8b e0       	ldi	r24, 0x0B	; 11
   11d32:	80 93 65 02 	sts	0x0265, r24
		  }
	      if (IsMessage09==True){
   11d36:	80 91 a3 01 	lds	r24, 0x01A3
   11d3a:	81 30       	cpi	r24, 0x01	; 1
   11d3c:	39 f4       	brne	.+14     	; 0x11d4c <FMenuLoyalty+0x27e>
		      IsMessage09=False;
   11d3e:	10 92 a3 01 	sts	0x01A3, r1
	          procMessage09();
   11d42:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
   11d46:	8a e0       	ldi	r24, 0x0A	; 10
   11d48:	80 93 65 02 	sts	0x0265, r24
		  }
	      if (IsMessage99==True){
   11d4c:	80 91 9f 01 	lds	r24, 0x019F
   11d50:	81 30       	cpi	r24, 0x01	; 1
   11d52:	09 f0       	breq	.+2      	; 0x11d56 <FMenuLoyalty+0x288>
   11d54:	0b c1       	rjmp	.+534    	; 0x11f6c <FMenuLoyalty+0x49e>
   11d56:	1c c0       	rjmp	.+56     	; 0x11d90 <FMenuLoyalty+0x2c2>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
   11d58:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   11d5c:	81 e0       	ldi	r24, 0x01	; 1
   11d5e:	61 e0       	ldi	r22, 0x01	; 1
   11d60:	42 e9       	ldi	r20, 0x92	; 146
   11d62:	58 e0       	ldi	r21, 0x08	; 8
   11d64:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11d68:	82 e0       	ldi	r24, 0x02	; 2
   11d6a:	61 e0       	ldi	r22, 0x01	; 1
   11d6c:	43 ea       	ldi	r20, 0xA3	; 163
   11d6e:	57 e0       	ldi	r21, 0x07	; 7
   11d70:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   11d74:	83 e0       	ldi	r24, 0x03	; 3
   11d76:	61 e0       	ldi	r22, 0x01	; 1
   11d78:	4c e1       	ldi	r20, 0x1C	; 28
   11d7a:	58 e0       	ldi	r21, 0x08	; 8
   11d7c:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   11d80:	84 e0       	ldi	r24, 0x04	; 4
   11d82:	61 e0       	ldi	r22, 0x01	; 1
   11d84:	46 ed       	ldi	r20, 0xD6	; 214
   11d86:	5b e0       	ldi	r21, 0x0B	; 11
   11d88:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  TimDisplay=0;
   11d8c:	10 92 92 01 	sts	0x0192, r1
		  stLoyalty=mlDelayExitLoyalty;
   11d90:	8e e0       	ldi	r24, 0x0E	; 14
   11d92:	06 cf       	rjmp	.-500    	; 0x11ba0 <FMenuLoyalty+0xd2>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
   11d94:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
   11d98:	e9 e8       	ldi	r30, 0x89	; 137
   11d9a:	ce 2e       	mov	r12, r30
   11d9c:	eb e0       	ldi	r30, 0x0B	; 11
   11d9e:	de 2e       	mov	r13, r30
   11da0:	c6 01       	movw	r24, r12
   11da2:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
   11da6:	74 e2       	ldi	r23, 0x24	; 36
   11da8:	e7 2e       	mov	r14, r23
   11daa:	73 e0       	ldi	r23, 0x03	; 3
   11dac:	f7 2e       	mov	r15, r23
   11dae:	c7 01       	movw	r24, r14
   11db0:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
   11db4:	ad b7       	in	r26, 0x3d	; 61
   11db6:	be b7       	in	r27, 0x3e	; 62
   11db8:	18 97       	sbiw	r26, 0x08	; 8
   11dba:	0f b6       	in	r0, 0x3f	; 63
   11dbc:	f8 94       	cli
   11dbe:	be bf       	out	0x3e, r27	; 62
   11dc0:	0f be       	out	0x3f, r0	; 63
   11dc2:	ad bf       	out	0x3d, r26	; 61
   11dc4:	ed b7       	in	r30, 0x3d	; 61
   11dc6:	fe b7       	in	r31, 0x3e	; 62
   11dc8:	31 96       	adiw	r30, 0x01	; 1
   11dca:	8e 01       	movw	r16, r28
   11dcc:	0f 5f       	subi	r16, 0xFF	; 255
   11dce:	1f 4f       	sbci	r17, 0xFF	; 255
   11dd0:	12 96       	adiw	r26, 0x02	; 2
   11dd2:	1c 93       	st	X, r17
   11dd4:	0e 93       	st	-X, r16
   11dd6:	11 97       	sbiw	r26, 0x01	; 1
   11dd8:	8c ee       	ldi	r24, 0xEC	; 236
   11dda:	99 e1       	ldi	r25, 0x19	; 25
   11ddc:	93 83       	std	Z+3, r25	; 0x03
   11dde:	82 83       	std	Z+2, r24	; 0x02
   11de0:	d5 82       	std	Z+5, r13	; 0x05
   11de2:	c4 82       	std	Z+4, r12	; 0x04
   11de4:	f7 82       	std	Z+7, r15	; 0x07
   11de6:	e6 82       	std	Z+6, r14	; 0x06
   11de8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
   11dec:	8d b7       	in	r24, 0x3d	; 61
   11dee:	9e b7       	in	r25, 0x3e	; 62
   11df0:	08 96       	adiw	r24, 0x08	; 8
   11df2:	0f b6       	in	r0, 0x3f	; 63
   11df4:	f8 94       	cli
   11df6:	9e bf       	out	0x3e, r25	; 62
   11df8:	0f be       	out	0x3f, r0	; 63
   11dfa:	8d bf       	out	0x3d, r24	; 61
   11dfc:	81 e0       	ldi	r24, 0x01	; 1
   11dfe:	61 e0       	ldi	r22, 0x01	; 1
   11e00:	a8 01       	movw	r20, r16
   11e02:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
   11e06:	65 e3       	ldi	r22, 0x35	; 53
   11e08:	e6 2e       	mov	r14, r22
   11e0a:	68 e0       	ldi	r22, 0x08	; 8
   11e0c:	f6 2e       	mov	r15, r22
   11e0e:	c7 01       	movw	r24, r14
   11e10:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
   11e14:	00 d0       	rcall	.+0      	; 0x11e16 <FMenuLoyalty+0x348>
   11e16:	00 d0       	rcall	.+0      	; 0x11e18 <FMenuLoyalty+0x34a>
   11e18:	00 d0       	rcall	.+0      	; 0x11e1a <FMenuLoyalty+0x34c>
   11e1a:	ed b7       	in	r30, 0x3d	; 61
   11e1c:	fe b7       	in	r31, 0x3e	; 62
   11e1e:	31 96       	adiw	r30, 0x01	; 1
   11e20:	ad b7       	in	r26, 0x3d	; 61
   11e22:	be b7       	in	r27, 0x3e	; 62
   11e24:	12 96       	adiw	r26, 0x02	; 2
   11e26:	1c 93       	st	X, r17
   11e28:	0e 93       	st	-X, r16
   11e2a:	11 97       	sbiw	r26, 0x01	; 1
   11e2c:	82 ee       	ldi	r24, 0xE2	; 226
   11e2e:	99 e1       	ldi	r25, 0x19	; 25
   11e30:	93 83       	std	Z+3, r25	; 0x03
   11e32:	82 83       	std	Z+2, r24	; 0x02
   11e34:	f5 82       	std	Z+5, r15	; 0x05
   11e36:	e4 82       	std	Z+4, r14	; 0x04
   11e38:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
   11e3c:	8d b7       	in	r24, 0x3d	; 61
   11e3e:	9e b7       	in	r25, 0x3e	; 62
   11e40:	06 96       	adiw	r24, 0x06	; 6
   11e42:	0f b6       	in	r0, 0x3f	; 63
   11e44:	f8 94       	cli
   11e46:	9e bf       	out	0x3e, r25	; 62
   11e48:	0f be       	out	0x3f, r0	; 63
   11e4a:	8d bf       	out	0x3d, r24	; 61
   11e4c:	82 e0       	ldi	r24, 0x02	; 2
   11e4e:	61 e0       	ldi	r22, 0x01	; 1
   11e50:	a8 01       	movw	r20, r16
   11e52:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
   11e56:	c7 01       	movw	r24, r14
   11e58:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
   11e5c:	00 d0       	rcall	.+0      	; 0x11e5e <FMenuLoyalty+0x390>
   11e5e:	00 d0       	rcall	.+0      	; 0x11e60 <FMenuLoyalty+0x392>
   11e60:	00 d0       	rcall	.+0      	; 0x11e62 <FMenuLoyalty+0x394>
   11e62:	ed b7       	in	r30, 0x3d	; 61
   11e64:	fe b7       	in	r31, 0x3e	; 62
   11e66:	31 96       	adiw	r30, 0x01	; 1
   11e68:	ad b7       	in	r26, 0x3d	; 61
   11e6a:	be b7       	in	r27, 0x3e	; 62
   11e6c:	12 96       	adiw	r26, 0x02	; 2
   11e6e:	1c 93       	st	X, r17
   11e70:	0e 93       	st	-X, r16
   11e72:	11 97       	sbiw	r26, 0x01	; 1
   11e74:	88 ed       	ldi	r24, 0xD8	; 216
   11e76:	99 e1       	ldi	r25, 0x19	; 25
   11e78:	93 83       	std	Z+3, r25	; 0x03
   11e7a:	82 83       	std	Z+2, r24	; 0x02
   11e7c:	8e e7       	ldi	r24, 0x7E	; 126
   11e7e:	93 e0       	ldi	r25, 0x03	; 3
   11e80:	95 83       	std	Z+5, r25	; 0x05
   11e82:	84 83       	std	Z+4, r24	; 0x04
   11e84:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
   11e88:	8d b7       	in	r24, 0x3d	; 61
   11e8a:	9e b7       	in	r25, 0x3e	; 62
   11e8c:	06 96       	adiw	r24, 0x06	; 6
   11e8e:	0f b6       	in	r0, 0x3f	; 63
   11e90:	f8 94       	cli
   11e92:	9e bf       	out	0x3e, r25	; 62
   11e94:	0f be       	out	0x3f, r0	; 63
   11e96:	8d bf       	out	0x3d, r24	; 61
   11e98:	83 e0       	ldi	r24, 0x03	; 3
   11e9a:	61 e0       	ldi	r22, 0x01	; 1
   11e9c:	a8 01       	movw	r20, r16
   11e9e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
   11ea2:	c7 01       	movw	r24, r14
   11ea4:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
   11ea8:	00 d0       	rcall	.+0      	; 0x11eaa <FMenuLoyalty+0x3dc>
   11eaa:	00 d0       	rcall	.+0      	; 0x11eac <FMenuLoyalty+0x3de>
   11eac:	00 d0       	rcall	.+0      	; 0x11eae <FMenuLoyalty+0x3e0>
   11eae:	ed b7       	in	r30, 0x3d	; 61
   11eb0:	fe b7       	in	r31, 0x3e	; 62
   11eb2:	31 96       	adiw	r30, 0x01	; 1
   11eb4:	ad b7       	in	r26, 0x3d	; 61
   11eb6:	be b7       	in	r27, 0x3e	; 62
   11eb8:	12 96       	adiw	r26, 0x02	; 2
   11eba:	1c 93       	st	X, r17
   11ebc:	0e 93       	st	-X, r16
   11ebe:	11 97       	sbiw	r26, 0x01	; 1
   11ec0:	8e ec       	ldi	r24, 0xCE	; 206
   11ec2:	99 e1       	ldi	r25, 0x19	; 25
   11ec4:	93 83       	std	Z+3, r25	; 0x03
   11ec6:	82 83       	std	Z+2, r24	; 0x02
   11ec8:	8d ee       	ldi	r24, 0xED	; 237
   11eca:	9b e0       	ldi	r25, 0x0B	; 11
   11ecc:	95 83       	std	Z+5, r25	; 0x05
   11ece:	84 83       	std	Z+4, r24	; 0x04
   11ed0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   11ed4:	8d b7       	in	r24, 0x3d	; 61
   11ed6:	9e b7       	in	r25, 0x3e	; 62
   11ed8:	06 96       	adiw	r24, 0x06	; 6
   11eda:	0f b6       	in	r0, 0x3f	; 63
   11edc:	f8 94       	cli
   11ede:	9e bf       	out	0x3e, r25	; 62
   11ee0:	0f be       	out	0x3f, r0	; 63
   11ee2:	8d bf       	out	0x3d, r24	; 61
   11ee4:	84 e0       	ldi	r24, 0x04	; 4
   11ee6:	61 e0       	ldi	r22, 0x01	; 1
   11ee8:	a8 01       	movw	r20, r16
   11eea:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
		  TimDisplay=0;
   11eee:	10 92 92 01 	sts	0x0192, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   11ef2:	e1 99       	sbic	0x1c, 1	; 28
   11ef4:	fe cf       	rjmp	.-4      	; 0x11ef2 <FMenuLoyalty+0x424>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   11ef6:	88 e3       	ldi	r24, 0x38	; 56
   11ef8:	90 e0       	ldi	r25, 0x00	; 0
   11efa:	9f bb       	out	0x1f, r25	; 31
   11efc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   11efe:	e0 9a       	sbi	0x1c, 0	; 28
   11f00:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
   11f02:	81 30       	cpi	r24, 0x01	; 1
   11f04:	09 f0       	breq	.+2      	; 0x11f08 <FMenuLoyalty+0x43a>
   11f06:	44 cf       	rjmp	.-376    	; 0x11d90 <FMenuLoyalty+0x2c2>
		      stLoyalty=mlPressAnyKey;
   11f08:	8d e0       	ldi	r24, 0x0D	; 13
   11f0a:	80 93 65 02 	sts	0x0265, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
   11f0e:	82 e0       	ldi	r24, 0x02	; 2
   11f10:	61 e0       	ldi	r22, 0x01	; 1
   11f12:	40 ec       	ldi	r20, 0xC0	; 192
   11f14:	59 e1       	ldi	r21, 0x19	; 25
   11f16:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
   11f1a:	28 c0       	rjmp	.+80     	; 0x11f6c <FMenuLoyalty+0x49e>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
   11f1c:	81 e0       	ldi	r24, 0x01	; 1
   11f1e:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
   11f22:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>
	      switch(KeyChar){		  
   11f26:	83 32       	cpi	r24, 0x23	; 35
   11f28:	c9 f0       	breq	.+50     	; 0x11f5c <FMenuLoyalty+0x48e>
   11f2a:	8a 32       	cpi	r24, 0x2A	; 42
   11f2c:	f9 f4       	brne	.+62     	; 0x11f6c <FMenuLoyalty+0x49e>
   11f2e:	16 c0       	rjmp	.+44     	; 0x11f5c <FMenuLoyalty+0x48e>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
   11f30:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   11f34:	82 e0       	ldi	r24, 0x02	; 2
   11f36:	61 e0       	ldi	r22, 0x01	; 1
   11f38:	42 eb       	ldi	r20, 0xB2	; 178
   11f3a:	59 e1       	ldi	r21, 0x19	; 25
   11f3c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   11f40:	83 e0       	ldi	r24, 0x03	; 3
   11f42:	61 e0       	ldi	r22, 0x01	; 1
   11f44:	44 ea       	ldi	r20, 0xA4	; 164
   11f46:	59 e1       	ldi	r21, 0x19	; 25
   11f48:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		  TimDisplay=5;
   11f4c:	85 e0       	ldi	r24, 0x05	; 5
   11f4e:	80 93 92 01 	sts	0x0192, r24
   11f52:	1e cf       	rjmp	.-452    	; 0x11d90 <FMenuLoyalty+0x2c2>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
   11f54:	80 91 92 01 	lds	r24, 0x0192
   11f58:	8a 30       	cpi	r24, 0x0A	; 10
   11f5a:	40 f0       	brcs	.+16     	; 0x11f6c <FMenuLoyalty+0x49e>
   11f5c:	8f e0       	ldi	r24, 0x0F	; 15
   11f5e:	20 ce       	rjmp	.-960    	; 0x11ba0 <FMenuLoyalty+0xd2>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
   11f60:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	      stLoyalty=mlInit;
   11f64:	10 92 65 02 	sts	0x0265, r1
   11f68:	81 e0       	ldi	r24, 0x01	; 1
   11f6a:	01 c0       	rjmp	.+2      	; 0x11f6e <FMenuLoyalty+0x4a0>
   11f6c:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
   11f6e:	64 96       	adiw	r28, 0x14	; 20
   11f70:	0f b6       	in	r0, 0x3f	; 63
   11f72:	f8 94       	cli
   11f74:	de bf       	out	0x3e, r29	; 62
   11f76:	0f be       	out	0x3f, r0	; 63
   11f78:	cd bf       	out	0x3d, r28	; 61
   11f7a:	cf 91       	pop	r28
   11f7c:	df 91       	pop	r29
   11f7e:	1f 91       	pop	r17
   11f80:	0f 91       	pop	r16
   11f82:	ff 90       	pop	r15
   11f84:	ef 90       	pop	r14
   11f86:	df 90       	pop	r13
   11f88:	cf 90       	pop	r12
   11f8a:	08 95       	ret

00011f8c <sendMessage10>:
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    uart_print(1, 0,strSend);
	uart(1, 1,0x02);
	IsNewPacket=True;
	*/
	IsNewPacket=True;
   11f8c:	81 e0       	ldi	r24, 0x01	; 1
   11f8e:	80 93 88 01 	sts	0x0188, r24
	IFTSendMessage(MSG_10);
   11f92:	80 e1       	ldi	r24, 0x10	; 16
   11f94:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
   11f98:	08 95       	ret

00011f9a <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
   11f9a:	af 92       	push	r10
   11f9c:	bf 92       	push	r11
   11f9e:	cf 92       	push	r12
   11fa0:	df 92       	push	r13
   11fa2:	ef 92       	push	r14
   11fa4:	ff 92       	push	r15
   11fa6:	0f 93       	push	r16
   11fa8:	1f 93       	push	r17
   11faa:	df 93       	push	r29
   11fac:	cf 93       	push	r28
   11fae:	cd b7       	in	r28, 0x3d	; 61
   11fb0:	de b7       	in	r29, 0x3e	; 62
   11fb2:	64 97       	sbiw	r28, 0x14	; 20
   11fb4:	0f b6       	in	r0, 0x3f	; 63
   11fb6:	f8 94       	cli
   11fb8:	de bf       	out	0x3e, r29	; 62
   11fba:	0f be       	out	0x3f, r0	; 63
   11fbc:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   11fbe:	e1 99       	sbic	0x1c, 1	; 28
   11fc0:	fe cf       	rjmp	.-4      	; 0x11fbe <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   11fc2:	16 e3       	ldi	r17, 0x36	; 54
   11fc4:	a1 2e       	mov	r10, r17
   11fc6:	11 e0       	ldi	r17, 0x01	; 1
   11fc8:	b1 2e       	mov	r11, r17
   11fca:	bf ba       	out	0x1f, r11	; 31
   11fcc:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   11fce:	e0 9a       	sbi	0x1c, 0	; 28
   11fd0:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0,KeyPressed;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
   11fd2:	90 93 00 01 	sts	0x0100, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   11fd6:	e1 99       	sbic	0x1c, 1	; 28
   11fd8:	fe cf       	rjmp	.-4      	; 0x11fd6 <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   11fda:	b7 e3       	ldi	r27, 0x37	; 55
   11fdc:	cb 2e       	mov	r12, r27
   11fde:	b1 e0       	ldi	r27, 0x01	; 1
   11fe0:	db 2e       	mov	r13, r27
   11fe2:	df ba       	out	0x1f, r13	; 31
   11fe4:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   11fe6:	e0 9a       	sbi	0x1c, 0	; 28
   11fe8:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
   11fea:	80 93 5e 01 	sts	0x015E, r24

	//SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);

    //Send Msg10
	if  (IFType==IT_SLAVE){
   11fee:	91 30       	cpi	r25, 0x01	; 1
   11ff0:	09 f0       	breq	.+2      	; 0x11ff4 <InitializeConnection+0x5a>
   11ff2:	5f c0       	rjmp	.+190    	; 0x120b2 <InitializeConnection+0x118>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
   11ff4:	81 e0       	ldi	r24, 0x01	; 1
   11ff6:	60 e0       	ldi	r22, 0x00	; 0
   11ff8:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
		 char_count=0;
   11ffc:	10 92 8a 01 	sts	0x018A, r1
   12000:	10 92 89 01 	sts	0x0189, r1
		 if (IsPowerOn==True){
   12004:	80 91 ba 02 	lds	r24, 0x02BA
   12008:	81 30       	cpi	r24, 0x01	; 1
   1200a:	59 f4       	brne	.+22     	; 0x12022 <InitializeConnection+0x88>
		     IsPowerOn=False;
   1200c:	10 92 ba 02 	sts	0x02BA, r1
   12010:	8f ef       	ldi	r24, 0xFF	; 255
   12012:	9f ef       	ldi	r25, 0xFF	; 255
   12014:	29 e1       	ldi	r18, 0x19	; 25
   12016:	30 e0       	ldi	r19, 0x00	; 0
   12018:	f9 01       	movw	r30, r18
   1201a:	31 97       	sbiw	r30, 0x01	; 1
   1201c:	f1 f7       	brne	.-4      	; 0x1201a <InitializeConnection+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   1201e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   12020:	d9 f7       	brne	.-10     	; 0x12018 <InitializeConnection+0x7e>
		     _delay_ms(8000);
			 }
         sendMessage10();
   12022:	0e 94 c6 8f 	call	0x11f8c	; 0x11f8c <sendMessage10>
         sendMessage10();
   12026:	0e 94 c6 8f 	call	0x11f8c	; 0x11f8c <sendMessage10>
         sendMessage10();
   1202a:	0e 94 c6 8f 	call	0x11f8c	; 0x11f8c <sendMessage10>
         

         lcd_printf(4,1,PSTR("Connect         "));
   1202e:	84 e0       	ldi	r24, 0x04	; 4
   12030:	61 e0       	ldi	r22, 0x01	; 1
   12032:	48 e1       	ldi	r20, 0x18	; 24
   12034:	5c e1       	ldi	r21, 0x1C	; 28
   12036:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
   1203a:	84 e0       	ldi	r24, 0x04	; 4
   1203c:	61 e0       	ldi	r22, 0x01	; 1
   1203e:	40 e1       	ldi	r20, 0x10	; 16
   12040:	5c e1       	ldi	r21, 0x1C	; 28
   12042:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
   12046:	10 92 a0 01 	sts	0x01A0, r1
   1204a:	ee 24       	eor	r14, r14
   1204c:	ff 24       	eor	r15, r15
   1204e:	10 e0       	ldi	r17, 0x00	; 0
   12050:	00 e0       	ldi	r16, 0x00	; 0
   12052:	2b c0       	rjmp	.+86     	; 0x120aa <InitializeConnection+0x110>
		  //SlaveIdentification		  
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
   12054:	61 2f       	mov	r22, r17
   12056:	68 5f       	subi	r22, 0xF8	; 248
   12058:	84 e0       	ldi	r24, 0x04	; 4
   1205a:	4e e2       	ldi	r20, 0x2E	; 46
   1205c:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
                tConnect++;
   12060:	08 94       	sec
   12062:	e1 1c       	adc	r14, r1
   12064:	f1 1c       	adc	r15, r1
				__key_lgtcnt=0;
   12066:	10 92 af 02 	sts	0x02AF, r1
			    if ((tConnect%200)==0)iCon++;
   1206a:	c7 01       	movw	r24, r14
   1206c:	68 ec       	ldi	r22, 0xC8	; 200
   1206e:	70 e0       	ldi	r23, 0x00	; 0
   12070:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
   12074:	89 2b       	or	r24, r25
   12076:	09 f4       	brne	.+2      	; 0x1207a <InitializeConnection+0xe0>
   12078:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>8){
   1207a:	19 30       	cpi	r17, 0x09	; 9
   1207c:	70 f0       	brcs	.+28     	; 0x1209a <InitializeConnection+0x100>
			        lcd_printf(4,1,PSTR("Connect         "));
   1207e:	84 e0       	ldi	r24, 0x04	; 4
   12080:	61 e0       	ldi	r22, 0x01	; 1
   12082:	4f ef       	ldi	r20, 0xFF	; 255
   12084:	5b e1       	ldi	r21, 0x1B	; 27
   12086:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
					
				    sendMessage10();
   1208a:	0e 94 c6 8f 	call	0x11f8c	; 0x11f8c <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
   1208e:	81 e0       	ldi	r24, 0x01	; 1
   12090:	60 e0       	ldi	r22, 0x00	; 0
   12092:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
   12096:	0f 5f       	subi	r16, 0xFF	; 255
   12098:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
   1209a:	04 30       	cpi	r16, 0x04	; 4
   1209c:	30 f0       	brcs	.+12     	; 0x120aa <InitializeConnection+0x110>
			        //IsErrorTCPIP=True;
				    IsAdvanzStartupInfo=False;		
   1209e:	10 92 aa 01 	sts	0x01AA, r1
					IFType=IT_STANDALONE;
   120a2:	82 e0       	ldi	r24, 0x02	; 2
   120a4:	80 93 00 01 	sts	0x0100, r24
   120a8:	04 c0       	rjmp	.+8      	; 0x120b2 <InitializeConnection+0x118>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification		  
		 while (IsMessage11==False){
   120aa:	80 91 a0 01 	lds	r24, 0x01A0
   120ae:	88 23       	and	r24, r24
   120b0:	89 f2       	breq	.-94     	; 0x12054 <InitializeConnection+0xba>

			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
   120b2:	80 91 00 01 	lds	r24, 0x0100
   120b6:	82 30       	cpi	r24, 0x02	; 2
   120b8:	09 f0       	breq	.+2      	; 0x120bc <InitializeConnection+0x122>
   120ba:	74 c0       	rjmp	.+232    	; 0x121a4 <InitializeConnection+0x20a>
        IsStandAloneDetected=False;		
   120bc:	10 92 9c 01 	sts	0x019C, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
   120c0:	60 91 5e 01 	lds	r22, 0x015E
   120c4:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
   120c8:	0e 94 40 a4 	call	0x14880	; 0x14880 <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
   120cc:	81 e0       	ldi	r24, 0x01	; 1
   120ce:	61 e0       	ldi	r22, 0x01	; 1
   120d0:	45 ef       	ldi	r20, 0xF5	; 245
   120d2:	5b e1       	ldi	r21, 0x1B	; 27
   120d4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   120d8:	e1 99       	sbic	0x1c, 1	; 28
   120da:	fe cf       	rjmp	.-4      	; 0x120d8 <InitializeConnection+0x13e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   120dc:	df ba       	out	0x1f, r13	; 31
   120de:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   120e0:	e0 9a       	sbi	0x1c, 0	; 28
   120e2:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
   120e4:	e8 2f       	mov	r30, r24
   120e6:	f0 e0       	ldi	r31, 0x00	; 0
   120e8:	ee 0f       	add	r30, r30
   120ea:	ff 1f       	adc	r31, r31
   120ec:	eb 50       	subi	r30, 0x0B	; 11
   120ee:	fd 4f       	sbci	r31, 0xFD	; 253
   120f0:	65 91       	lpm	r22, Z+
   120f2:	74 91       	lpm	r23, Z+
   120f4:	8e 01       	movw	r16, r28
   120f6:	0f 5f       	subi	r16, 0xFF	; 255
   120f8:	1f 4f       	sbci	r17, 0xFF	; 255
   120fa:	c8 01       	movw	r24, r16
   120fc:	0e 94 dc a9 	call	0x153b8	; 0x153b8 <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
   12100:	00 d0       	rcall	.+0      	; 0x12102 <InitializeConnection+0x168>
   12102:	00 d0       	rcall	.+0      	; 0x12104 <InitializeConnection+0x16a>
   12104:	00 d0       	rcall	.+0      	; 0x12106 <InitializeConnection+0x16c>
   12106:	ed b7       	in	r30, 0x3d	; 61
   12108:	fe b7       	in	r31, 0x3e	; 62
   1210a:	31 96       	adiw	r30, 0x01	; 1
   1210c:	ad b7       	in	r26, 0x3d	; 61
   1210e:	be b7       	in	r27, 0x3e	; 62
   12110:	12 96       	adiw	r26, 0x02	; 2
   12112:	1c 93       	st	X, r17
   12114:	0e 93       	st	-X, r16
   12116:	11 97       	sbiw	r26, 0x01	; 1
   12118:	82 ef       	ldi	r24, 0xF2	; 242
   1211a:	9b e1       	ldi	r25, 0x1B	; 27
   1211c:	93 83       	std	Z+3, r25	; 0x03
   1211e:	82 83       	std	Z+2, r24	; 0x02
   12120:	15 83       	std	Z+5, r17	; 0x05
   12122:	04 83       	std	Z+4, r16	; 0x04
   12124:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	    lcd_print(2,1,lcdteks);
   12128:	8d b7       	in	r24, 0x3d	; 61
   1212a:	9e b7       	in	r25, 0x3e	; 62
   1212c:	06 96       	adiw	r24, 0x06	; 6
   1212e:	0f b6       	in	r0, 0x3f	; 63
   12130:	f8 94       	cli
   12132:	9e bf       	out	0x3e, r25	; 62
   12134:	0f be       	out	0x3f, r0	; 63
   12136:	8d bf       	out	0x3d, r24	; 61
   12138:	82 e0       	ldi	r24, 0x02	; 2
   1213a:	61 e0       	ldi	r22, 0x01	; 1
   1213c:	a8 01       	movw	r20, r16
   1213e:	0e 94 e7 a3 	call	0x147ce	; 0x147ce <lcd_print>
   12142:	00 e0       	ldi	r16, 0x00	; 0
   12144:	10 e0       	ldi	r17, 0x00	; 0
   12146:	ff 24       	eor	r15, r15
   12148:	dd 24       	eor	r13, r13
   1214a:	28 c0       	rjmp	.+80     	; 0x1219c <InitializeConnection+0x202>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
   1214c:	ef 2c       	mov	r14, r15
   1214e:	e3 94       	inc	r14
   12150:	84 e0       	ldi	r24, 0x04	; 4
   12152:	6e 2d       	mov	r22, r14
   12154:	4e e2       	ldi	r20, 0x2E	; 46
   12156:	0e 94 59 a4 	call	0x148b2	; 0x148b2 <lcd_put>
		       tConnect++;
   1215a:	0f 5f       	subi	r16, 0xFF	; 255
   1215c:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
   1215e:	c8 01       	movw	r24, r16
   12160:	64 e6       	ldi	r22, 0x64	; 100
   12162:	70 e0       	ldi	r23, 0x00	; 0
   12164:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <__udivmodhi4>
   12168:	89 2b       	or	r24, r25
   1216a:	09 f4       	brne	.+2      	; 0x1216e <InitializeConnection+0x1d4>
   1216c:	fe 2c       	mov	r15, r14
		       if (iCon>16){
   1216e:	90 e1       	ldi	r25, 0x10	; 16
   12170:	9f 15       	cp	r25, r15
   12172:	88 f4       	brcc	.+34     	; 0x12196 <InitializeConnection+0x1fc>
			       __key_lgtcnt=0;
   12174:	10 92 af 02 	sts	0x02AF, r1
			       lcd_printf(4,1,PSTR("                   "));
   12178:	84 e0       	ldi	r24, 0x04	; 4
   1217a:	61 e0       	ldi	r22, 0x01	; 1
   1217c:	4e ed       	ldi	r20, 0xDE	; 222
   1217e:	5b e1       	ldi	r21, 0x1B	; 27
   12180:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
   12184:	82 e0       	ldi	r24, 0x02	; 2
   12186:	60 91 5e 01 	lds	r22, 0x015E
   1218a:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
   1218e:	0e 94 05 47 	call	0x8e0a	; 0x8e0a <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
   12192:	d3 94       	inc	r13
   12194:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
   12196:	a3 e0       	ldi	r26, 0x03	; 3
   12198:	ad 15       	cp	r26, r13
   1219a:	20 f0       	brcs	.+8      	; 0x121a4 <InitializeConnection+0x20a>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
   1219c:	80 91 9c 01 	lds	r24, 0x019C
   121a0:	88 23       	and	r24, r24
   121a2:	a1 f2       	breq	.-88     	; 0x1214c <InitializeConnection+0x1b2>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
   121a4:	80 91 a0 01 	lds	r24, 0x01A0
   121a8:	81 30       	cpi	r24, 0x01	; 1
   121aa:	b9 f4       	brne	.+46     	; 0x121da <InitializeConnection+0x240>
	   lcd_printf(4,1,PSTR("Connected           "));
   121ac:	84 e0       	ldi	r24, 0x04	; 4
   121ae:	61 e0       	ldi	r22, 0x01	; 1
   121b0:	49 ec       	ldi	r20, 0xC9	; 201
   121b2:	5b e1       	ldi	r21, 0x1B	; 27
   121b4:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   121b8:	e1 99       	sbic	0x1c, 1	; 28
   121ba:	fe cf       	rjmp	.-4      	; 0x121b8 <InitializeConnection+0x21e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   121bc:	bf ba       	out	0x1f, r11	; 31
   121be:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
   121c0:	11 e0       	ldi	r17, 0x01	; 1
   121c2:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
   121c4:	0f b6       	in	r0, 0x3f	; 63
   121c6:	f8 94       	cli
   121c8:	e2 9a       	sbi	0x1c, 2	; 28
   121ca:	e1 9a       	sbi	0x1c, 1	; 28
   121cc:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
   121ce:	10 93 00 01 	sts	0x0100, r17
	   //IsErrorTCPIP=False;
	   procMessage11();
   121d2:	0e 94 4d 43 	call	0x869a	; 0x869a <procMessage11>
	   IsAdvanzStartupInfo=True;
   121d6:	10 93 aa 01 	sts	0x01AA, r17
	}
	if(IsStandAloneDetected==True){
   121da:	80 91 9c 01 	lds	r24, 0x019C
   121de:	81 30       	cpi	r24, 0x01	; 1
   121e0:	99 f4       	brne	.+38     	; 0x12208 <InitializeConnection+0x26e>
	   lcd_printf(4,1,PSTR("PumpFound"));
   121e2:	84 e0       	ldi	r24, 0x04	; 4
   121e4:	61 e0       	ldi	r22, 0x01	; 1
   121e6:	4f eb       	ldi	r20, 0xBF	; 191
   121e8:	5b e1       	ldi	r21, 0x1B	; 27
   121ea:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   121ee:	e1 99       	sbic	0x1c, 1	; 28
   121f0:	fe cf       	rjmp	.-4      	; 0x121ee <InitializeConnection+0x254>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   121f2:	bf ba       	out	0x1f, r11	; 31
   121f4:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
   121f6:	82 e0       	ldi	r24, 0x02	; 2
   121f8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   121fa:	0f b6       	in	r0, 0x3f	; 63
   121fc:	f8 94       	cli
   121fe:	e2 9a       	sbi	0x1c, 2	; 28
   12200:	e1 9a       	sbi	0x1c, 1	; 28
   12202:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
   12204:	80 93 00 01 	sts	0x0100, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12208:	e1 99       	sbic	0x1c, 1	; 28
   1220a:	fe cf       	rjmp	.-4      	; 0x12208 <InitializeConnection+0x26e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1220c:	85 e3       	ldi	r24, 0x35	; 53
   1220e:	91 e0       	ldi	r25, 0x01	; 1
   12210:	9f bb       	out	0x1f, r25	; 31
   12212:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12214:	e0 9a       	sbi	0x1c, 0	; 28
   12216:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
   12218:	81 30       	cpi	r24, 0x01	; 1
   1221a:	11 f4       	brne	.+4      	; 0x12220 <InitializeConnection+0x286>
   1221c:	0e 94 b8 30 	call	0x6170	; 0x6170 <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
   12220:	80 91 9c 01 	lds	r24, 0x019C
   12224:	88 23       	and	r24, r24
   12226:	09 f0       	breq	.+2      	; 0x1222a <InitializeConnection+0x290>
   12228:	38 c0       	rjmp	.+112    	; 0x1229a <InitializeConnection+0x300>
   1222a:	80 91 a0 01 	lds	r24, 0x01A0
   1222e:	88 23       	and	r24, r24
   12230:	09 f0       	breq	.+2      	; 0x12234 <InitializeConnection+0x29a>
   12232:	33 c0       	rjmp	.+102    	; 0x1229a <InitializeConnection+0x300>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
   12234:	82 e0       	ldi	r24, 0x02	; 2
   12236:	61 e0       	ldi	r22, 0x01	; 1
   12238:	42 eb       	ldi	r20, 0xB2	; 178
   1223a:	5b e1       	ldi	r21, 0x1B	; 27
   1223c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
   12240:	83 e0       	ldi	r24, 0x03	; 3
   12242:	61 e0       	ldi	r22, 0x01	; 1
   12244:	44 ea       	ldi	r20, 0xA4	; 164
   12246:	5b e1       	ldi	r21, 0x1B	; 27
   12248:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
   1224c:	80 e2       	ldi	r24, 0x20	; 32
   1224e:	9e e4       	ldi	r25, 0x4E	; 78
   12250:	29 e1       	ldi	r18, 0x19	; 25
   12252:	30 e0       	ldi	r19, 0x00	; 0
   12254:	f9 01       	movw	r30, r18
   12256:	31 97       	sbiw	r30, 0x01	; 1
   12258:	f1 f7       	brne	.-4      	; 0x12256 <InitializeConnection+0x2bc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   1225a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   1225c:	d9 f7       	brne	.-10     	; 0x12254 <InitializeConnection+0x2ba>
		 _delay_ms(2000);
		 ForceType=systemForceType();
   1225e:	0e 94 b0 51 	call	0xa360	; 0xa360 <systemForceType>
		 if (ForceType=='1'){
   12262:	81 33       	cpi	r24, 0x31	; 49
   12264:	29 f4       	brne	.+10     	; 0x12270 <InitializeConnection+0x2d6>
		     IFType=IT_SLAVE;
   12266:	81 e0       	ldi	r24, 0x01	; 1
   12268:	80 93 00 01 	sts	0x0100, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
   1226c:	60 e0       	ldi	r22, 0x00	; 0
   1226e:	07 c0       	rjmp	.+14     	; 0x1227e <InitializeConnection+0x2e4>
         }
		 else
		 if (ForceType=='2'){
   12270:	82 33       	cpi	r24, 0x32	; 50
   12272:	39 f4       	brne	.+14     	; 0x12282 <InitializeConnection+0x2e8>
		     IFType=IT_STANDALONE;
   12274:	82 e0       	ldi	r24, 0x02	; 2
   12276:	80 93 00 01 	sts	0x0100, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
   1227a:	60 91 5e 01 	lds	r22, 0x015E
   1227e:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
   12282:	80 91 00 01 	lds	r24, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   12286:	e1 99       	sbic	0x1c, 1	; 28
   12288:	fe cf       	rjmp	.-4      	; 0x12286 <InitializeConnection+0x2ec>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1228a:	bf ba       	out	0x1f, r11	; 31
   1228c:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
   1228e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   12290:	0f b6       	in	r0, 0x3f	; 63
   12292:	f8 94       	cli
   12294:	e2 9a       	sbi	0x1c, 2	; 28
   12296:	e1 9a       	sbi	0x1c, 1	; 28
   12298:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1229a:	e1 99       	sbic	0x1c, 1	; 28
   1229c:	fe cf       	rjmp	.-4      	; 0x1229a <InitializeConnection+0x300>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1229e:	84 e4       	ldi	r24, 0x44	; 68
   122a0:	91 e0       	ldi	r25, 0x01	; 1
   122a2:	9f bb       	out	0x1f, r25	; 31
   122a4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   122a6:	e0 9a       	sbi	0x1c, 0	; 28
   122a8:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
   122aa:	80 93 5c 01 	sts	0x015C, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   122ae:	e1 99       	sbic	0x1c, 1	; 28
   122b0:	fe cf       	rjmp	.-4      	; 0x122ae <InitializeConnection+0x314>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   122b2:	89 e4       	ldi	r24, 0x49	; 73
   122b4:	91 e0       	ldi	r25, 0x01	; 1
   122b6:	9f bb       	out	0x1f, r25	; 31
   122b8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   122ba:	e0 9a       	sbi	0x1c, 0	; 28
   122bc:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
   122be:	80 93 5d 01 	sts	0x015D, r24
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
	//SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
}
   122c2:	64 96       	adiw	r28, 0x14	; 20
   122c4:	0f b6       	in	r0, 0x3f	; 63
   122c6:	f8 94       	cli
   122c8:	de bf       	out	0x3e, r29	; 62
   122ca:	0f be       	out	0x3f, r0	; 63
   122cc:	cd bf       	out	0x3d, r28	; 61
   122ce:	cf 91       	pop	r28
   122d0:	df 91       	pop	r29
   122d2:	1f 91       	pop	r17
   122d4:	0f 91       	pop	r16
   122d6:	ff 90       	pop	r15
   122d8:	ef 90       	pop	r14
   122da:	df 90       	pop	r13
   122dc:	cf 90       	pop	r12
   122de:	bf 90       	pop	r11
   122e0:	af 90       	pop	r10
   122e2:	08 95       	ret

000122e4 <sendMessage04>:
	 UpdateServerIP();//ReadDestIP
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
     uart_print(1, 0,strSend);
	 uart(1, 1,0x02);
	 */IFTSendMessage(MSG_04);
   122e4:	84 e0       	ldi	r24, 0x04	; 4
   122e6:	0e 94 8c 78 	call	0xf118	; 0xf118 <IFTSendMessage>
}
   122ea:	08 95       	ret

000122ec <FreePrinting>:
	 } 
	 else uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
   122ec:	0f 93       	push	r16
   122ee:	1f 93       	push	r17
   122f0:	df 93       	push	r29
   122f2:	cf 93       	push	r28
   122f4:	cd b7       	in	r28, 0x3d	; 61
   122f6:	de b7       	in	r29, 0x3e	; 62
   122f8:	64 97       	sbiw	r28, 0x14	; 20
   122fa:	0f b6       	in	r0, 0x3f	; 63
   122fc:	f8 94       	cli
   122fe:	de bf       	out	0x3e, r29	; 62
   12300:	0f be       	out	0x3f, r0	; 63
   12302:	cd bf       	out	0x3d, r28	; 61
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static unsigned int iSend=0,LSend=0,iLoop=0;
       char strOperatorName[20];

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
   12304:	20 91 a8 01 	lds	r18, 0x01A8
   12308:	21 30       	cpi	r18, 0x01	; 1
   1230a:	31 f4       	brne	.+12     	; 0x12318 <FreePrinting+0x2c>
   1230c:	80 91 25 01 	lds	r24, 0x0125
   12310:	81 30       	cpi	r24, 0x01	; 1
   12312:	11 f0       	breq	.+4      	; 0x12318 <FreePrinting+0x2c>
	     stFreePrinting=fpInit;
   12314:	20 93 25 01 	sts	0x0125, r18
	 }
	 switch (stFreePrinting){
   12318:	80 91 25 01 	lds	r24, 0x0125
   1231c:	90 e0       	ldi	r25, 0x00	; 0
   1231e:	fc 01       	movw	r30, r24
   12320:	31 97       	sbiw	r30, 0x01	; 1
   12322:	eb 31       	cpi	r30, 0x1B	; 27
   12324:	f1 05       	cpc	r31, r1
   12326:	08 f0       	brcs	.+2      	; 0x1232a <FreePrinting+0x3e>
   12328:	87 c3       	rjmp	.+1806   	; 0x12a38 <FreePrinting+0x74c>
   1232a:	eb 53       	subi	r30, 0x3B	; 59
   1232c:	ff 4f       	sbci	r31, 0xFF	; 255
   1232e:	ee 0f       	add	r30, r30
   12330:	ff 1f       	adc	r31, r31
   12332:	05 90       	lpm	r0, Z+
   12334:	f4 91       	lpm	r31, Z+
   12336:	e0 2d       	mov	r30, r0
   12338:	09 94       	ijmp
     case fpInit:
	      //uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
   1233a:	21 30       	cpi	r18, 0x01	; 1
   1233c:	09 f0       	breq	.+2      	; 0x12340 <FreePrinting+0x54>
   1233e:	7c c3       	rjmp	.+1784   	; 0x12a38 <FreePrinting+0x74c>
		      IsFreePrinting=False;
   12340:	10 92 a8 01 	sts	0x01A8, r1
			  IsBusyFreePrinting=True;
   12344:	20 93 b4 01 	sts	0x01B4, r18
			  IsBusyPrint=False;
   12348:	10 92 b3 01 	sts	0x01B3, r1
			  iPrinted=0,iFooter=0;
   1234c:	10 92 f5 01 	sts	0x01F5, r1
   12350:	10 92 f3 01 	sts	0x01F3, r1

			  PrintCopy=(cmdPrint&0x0F);
   12354:	80 91 b5 01 	lds	r24, 0x01B5
   12358:	8f 70       	andi	r24, 0x0F	; 15
   1235a:	80 93 f2 01 	sts	0x01F2, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
   1235e:	82 e0       	ldi	r24, 0x02	; 2
   12360:	80 93 25 01 	sts	0x0125, r24
			  InitPrinter();
   12364:	0e 94 94 42 	call	0x8528	; 0x8528 <InitPrinter>
   12368:	67 c3       	rjmp	.+1742   	; 0x12a38 <FreePrinting+0x74c>
			  }
	      break;
     case fpInitHeader:
	      //uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
   1236a:	10 92 f4 01 	sts	0x01F4, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
   1236e:	80 91 b5 01 	lds	r24, 0x01B5
   12372:	88 1f       	adc	r24, r24
   12374:	88 27       	eor	r24, r24
   12376:	88 1f       	adc	r24, r24
   12378:	90 e0       	ldi	r25, 0x00	; 0
   1237a:	81 30       	cpi	r24, 0x01	; 1
   1237c:	91 05       	cpc	r25, r1
   1237e:	21 f1       	breq	.+72     	; 0x123c8 <FreePrinting+0xdc>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
   12380:	89 2b       	or	r24, r25
   12382:	09 f0       	breq	.+2      	; 0x12386 <FreePrinting+0x9a>
   12384:	59 c3       	rjmp	.+1714   	; 0x12a38 <FreePrinting+0x74c>
   12386:	85 e0       	ldi	r24, 0x05	; 5
   12388:	80 93 25 01 	sts	0x0125, r24
   1238c:	55 c3       	rjmp	.+1706   	; 0x12a38 <FreePrinting+0x74c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   1238e:	60 91 f4 01 	lds	r22, 0x01F4
   12392:	89 e2       	ldi	r24, 0x29	; 41
   12394:	68 9f       	mul	r22, r24
   12396:	b0 01       	movw	r22, r0
   12398:	11 24       	eor	r1, r1
   1239a:	69 5d       	subi	r22, 0xD9	; 217
   1239c:	7d 4f       	sbci	r23, 0xFD	; 253
   1239e:	8c eb       	ldi	r24, 0xBC	; 188
   123a0:	98 e0       	ldi	r25, 0x08	; 8
   123a2:	48 e2       	ldi	r20, 0x28	; 40
   123a4:	50 e0       	ldi	r21, 0x00	; 0
   123a6:	24 e4       	ldi	r18, 0x44	; 68
   123a8:	32 e1       	ldi	r19, 0x12	; 18
   123aa:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	      break;
     case fpLoadHeader:
	      //uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
   123ae:	80 91 f4 01 	lds	r24, 0x01F4
   123b2:	8f 5f       	subi	r24, 0xFF	; 255
   123b4:	80 93 f4 01 	sts	0x01F4, r24
		  if (iHeader<6){
   123b8:	86 30       	cpi	r24, 0x06	; 6
   123ba:	28 f7       	brcc	.-54     	; 0x12386 <FreePrinting+0x9a>
		      if (SpaceOnly(strPrint)==True){
   123bc:	8c eb       	ldi	r24, 0xBC	; 188
   123be:	98 e0       	ldi	r25, 0x08	; 8
   123c0:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   123c4:	81 30       	cpi	r24, 0x01	; 1
   123c6:	11 f4       	brne	.+4      	; 0x123cc <FreePrinting+0xe0>
			      stFreePrinting=fpLoadHeader;
   123c8:	83 e0       	ldi	r24, 0x03	; 3
   123ca:	de cf       	rjmp	.-68     	; 0x12388 <FreePrinting+0x9c>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
   123cc:	84 e0       	ldi	r24, 0x04	; 4
   123ce:	80 93 25 01 	sts	0x0125, r24
			      iSend=0;
   123d2:	10 92 ee 01 	sts	0x01EE, r1
   123d6:	10 92 ed 01 	sts	0x01ED, r1
				  iLoop=0;
   123da:	10 92 ea 01 	sts	0x01EA, r1
   123de:	10 92 e9 01 	sts	0x01E9, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
   123e2:	80 91 f4 01 	lds	r24, 0x01F4
   123e6:	81 30       	cpi	r24, 0x01	; 1
   123e8:	19 f4       	brne	.+6      	; 0x123f0 <FreePrinting+0x104>
   123ea:	0e 94 16 43 	call	0x862c	; 0x862c <PrintDoubleHeight>
   123ee:	24 c3       	rjmp	.+1608   	; 0x12a38 <FreePrinting+0x74c>
				  else 
				  if (iHeader==2) PrintNormalHeight();
   123f0:	82 30       	cpi	r24, 0x02	; 2
   123f2:	09 f0       	breq	.+2      	; 0x123f6 <FreePrinting+0x10a>
   123f4:	21 c3       	rjmp	.+1602   	; 0x12a38 <FreePrinting+0x74c>
   123f6:	0e 94 fc 42 	call	0x85f8	; 0x85f8 <PrintNormalHeight>
   123fa:	1e c3       	rjmp	.+1596   	; 0x12a38 <FreePrinting+0x74c>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
   123fc:	80 91 ed 01 	lds	r24, 0x01ED
   12400:	90 91 ee 01 	lds	r25, 0x01EE
   12404:	88 97       	sbiw	r24, 0x28	; 40
   12406:	68 f4       	brcc	.+26     	; 0x12422 <FreePrinting+0x136>
		      iLoop++;
   12408:	80 91 e9 01 	lds	r24, 0x01E9
   1240c:	90 91 ea 01 	lds	r25, 0x01EA
   12410:	01 96       	adiw	r24, 0x01	; 1
   12412:	90 93 ea 01 	sts	0x01EA, r25
   12416:	80 93 e9 01 	sts	0x01E9, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //uart(_COM_PRINTER,1,strPrint[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
   1241a:	10 92 b6 01 	sts	0x01B6, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
   1241e:	82 e1       	ldi	r24, 0x12	; 18
   12420:	b3 cf       	rjmp	.-154    	; 0x12388 <FreePrinting+0x9c>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
   12422:	83 e0       	ldi	r24, 0x03	; 3
   12424:	62 c2       	rjmp	.+1220   	; 0x128ea <FreePrinting+0x5fe>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
   12426:	80 91 b3 01 	lds	r24, 0x01B3
   1242a:	88 23       	and	r24, r24
   1242c:	09 f0       	breq	.+2      	; 0x12430 <FreePrinting+0x144>
   1242e:	7c c2       	rjmp	.+1272   	; 0x12928 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   12430:	e0 91 ed 01 	lds	r30, 0x01ED
   12434:	f0 91 ee 01 	lds	r31, 0x01EE
   12438:	e4 54       	subi	r30, 0x44	; 68
   1243a:	f7 4f       	sbci	r31, 0xF7	; 247
   1243c:	61 e0       	ldi	r22, 0x01	; 1
   1243e:	40 81       	ld	r20, Z
   12440:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   12444:	80 91 ed 01 	lds	r24, 0x01ED
   12448:	90 91 ee 01 	lds	r25, 0x01EE
   1244c:	01 96       	adiw	r24, 0x01	; 1
   1244e:	90 93 ee 01 	sts	0x01EE, r25
   12452:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintHeader;
   12456:	84 e0       	ldi	r24, 0x04	; 4
   12458:	65 c2       	rjmp	.+1226   	; 0x12924 <FreePrinting+0x638>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     case fpInitMessage:
	      //uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
   1245a:	10 92 ee 01 	sts	0x01EE, r1
   1245e:	10 92 ed 01 	sts	0x01ED, r1
   12462:	10 92 ea 01 	sts	0x01EA, r1
   12466:	10 92 e9 01 	sts	0x01E9, r1
          stFreePrinting=fpPrintMessage; 
   1246a:	08 e0       	ldi	r16, 0x08	; 8
   1246c:	00 93 25 01 	sts	0x0125, r16
		  CarriegeReturn();
   12470:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
   12474:	80 91 f5 01 	lds	r24, 0x01F5
   12478:	88 23       	and	r24, r24
   1247a:	11 f0       	breq	.+4      	; 0x12480 <FreePrinting+0x194>
   1247c:	86 e0       	ldi	r24, 0x06	; 6
   1247e:	84 cf       	rjmp	.-248    	; 0x12388 <FreePrinting+0x9c>
		  else stFreePrinting=fpPrintMessage; 
   12480:	00 93 25 01 	sts	0x0125, r16
   12484:	d9 c2       	rjmp	.+1458   	; 0x12a38 <FreePrinting+0x74c>
	      break;
     case fpInitDuplicate:
	      //uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
   12486:	80 91 f5 01 	lds	r24, 0x01F5
   1248a:	2c eb       	ldi	r18, 0xBC	; 188
   1248c:	38 e0       	ldi	r19, 0x08	; 8
   1248e:	88 23       	and	r24, r24
   12490:	79 f0       	breq	.+30     	; 0x124b0 <FreePrinting+0x1c4>
   12492:	00 d0       	rcall	.+0      	; 0x12494 <FreePrinting+0x1a8>
   12494:	00 d0       	rcall	.+0      	; 0x12496 <FreePrinting+0x1aa>
   12496:	ad b7       	in	r26, 0x3d	; 61
   12498:	be b7       	in	r27, 0x3e	; 62
   1249a:	12 96       	adiw	r26, 0x02	; 2
   1249c:	3c 93       	st	X, r19
   1249e:	2e 93       	st	-X, r18
   124a0:	11 97       	sbiw	r26, 0x01	; 1
   124a2:	88 e6       	ldi	r24, 0x68	; 104
   124a4:	95 e0       	ldi	r25, 0x05	; 5
   124a6:	14 96       	adiw	r26, 0x04	; 4
   124a8:	9c 93       	st	X, r25
   124aa:	8e 93       	st	-X, r24
   124ac:	13 97       	sbiw	r26, 0x03	; 3
   124ae:	0a c0       	rjmp	.+20     	; 0x124c4 <FreePrinting+0x1d8>
          else           sprintf_P(strPrint,PSTR("                                   "));
   124b0:	00 d0       	rcall	.+0      	; 0x124b2 <FreePrinting+0x1c6>
   124b2:	00 d0       	rcall	.+0      	; 0x124b4 <FreePrinting+0x1c8>
   124b4:	ed b7       	in	r30, 0x3d	; 61
   124b6:	fe b7       	in	r31, 0x3e	; 62
   124b8:	32 83       	std	Z+2, r19	; 0x02
   124ba:	21 83       	std	Z+1, r18	; 0x01
   124bc:	84 e4       	ldi	r24, 0x44	; 68
   124be:	95 e0       	ldi	r25, 0x05	; 5
   124c0:	94 83       	std	Z+4, r25	; 0x04
   124c2:	83 83       	std	Z+3, r24	; 0x03
   124c4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   124c8:	0f 90       	pop	r0
   124ca:	0f 90       	pop	r0
   124cc:	0f 90       	pop	r0
   124ce:	0f 90       	pop	r0
		  iSend=0;
   124d0:	10 92 ee 01 	sts	0x01EE, r1
   124d4:	10 92 ed 01 	sts	0x01ED, r1
		  iLoop=0;
   124d8:	10 92 ea 01 	sts	0x01EA, r1
   124dc:	10 92 e9 01 	sts	0x01E9, r1
		  LSend=strlen(strPrint);
   124e0:	ec eb       	ldi	r30, 0xBC	; 188
   124e2:	f8 e0       	ldi	r31, 0x08	; 8
   124e4:	01 90       	ld	r0, Z+
   124e6:	00 20       	and	r0, r0
   124e8:	e9 f7       	brne	.-6      	; 0x124e4 <FreePrinting+0x1f8>
   124ea:	31 97       	sbiw	r30, 0x01	; 1
   124ec:	ec 5b       	subi	r30, 0xBC	; 188
   124ee:	f8 40       	sbci	r31, 0x08	; 8
   124f0:	f0 93 ec 01 	sts	0x01EC, r31
   124f4:	e0 93 eb 01 	sts	0x01EB, r30
          stFreePrinting=fpPrintDuplicate; 
   124f8:	87 e0       	ldi	r24, 0x07	; 7
   124fa:	46 cf       	rjmp	.-372    	; 0x12388 <FreePrinting+0x9c>
	      break;
     case fpPrintDuplicate:
	      //uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
   124fc:	20 91 ed 01 	lds	r18, 0x01ED
   12500:	30 91 ee 01 	lds	r19, 0x01EE
   12504:	80 91 eb 01 	lds	r24, 0x01EB
   12508:	90 91 ec 01 	lds	r25, 0x01EC
   1250c:	28 17       	cp	r18, r24
   1250e:	39 07       	cpc	r19, r25
   12510:	68 f4       	brcc	.+26     	; 0x1252c <FreePrinting+0x240>
		      iLoop++;
   12512:	80 91 e9 01 	lds	r24, 0x01E9
   12516:	90 91 ea 01 	lds	r25, 0x01EA
   1251a:	01 96       	adiw	r24, 0x01	; 1
   1251c:	90 93 ea 01 	sts	0x01EA, r25
   12520:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //uart(_COM_PRINTER,1,strPrint[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
   12524:	10 92 b6 01 	sts	0x01B6, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
   12528:	85 e1       	ldi	r24, 0x15	; 21
   1252a:	2e cf       	rjmp	.-420    	; 0x12388 <FreePrinting+0x9c>
				 }
			  }
          else {
		     iSend=0;
   1252c:	10 92 ee 01 	sts	0x01EE, r1
   12530:	10 92 ed 01 	sts	0x01ED, r1
		     stFreePrinting=fpPrintMessage;
   12534:	88 e0       	ldi	r24, 0x08	; 8
   12536:	d9 c1       	rjmp	.+946    	; 0x128ea <FreePrinting+0x5fe>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
   12538:	80 91 b3 01 	lds	r24, 0x01B3
   1253c:	88 23       	and	r24, r24
   1253e:	09 f0       	breq	.+2      	; 0x12542 <FreePrinting+0x256>
   12540:	f3 c1       	rjmp	.+998    	; 0x12928 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   12542:	e0 91 ed 01 	lds	r30, 0x01ED
   12546:	f0 91 ee 01 	lds	r31, 0x01EE
   1254a:	e4 54       	subi	r30, 0x44	; 68
   1254c:	f7 4f       	sbci	r31, 0xF7	; 247
   1254e:	61 e0       	ldi	r22, 0x01	; 1
   12550:	40 81       	ld	r20, Z
   12552:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   12556:	80 91 ed 01 	lds	r24, 0x01ED
   1255a:	90 91 ee 01 	lds	r25, 0x01EE
   1255e:	01 96       	adiw	r24, 0x01	; 1
   12560:	90 93 ee 01 	sts	0x01EE, r25
   12564:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintDuplicate;
   12568:	87 e0       	ldi	r24, 0x07	; 7
   1256a:	dc c1       	rjmp	.+952    	; 0x12924 <FreePrinting+0x638>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
   1256c:	20 91 ed 01 	lds	r18, 0x01ED
   12570:	30 91 ee 01 	lds	r19, 0x01EE
   12574:	80 91 8d 01 	lds	r24, 0x018D
   12578:	90 91 8e 01 	lds	r25, 0x018E
   1257c:	28 17       	cp	r18, r24
   1257e:	39 07       	cpc	r19, r25
   12580:	68 f4       	brcc	.+26     	; 0x1259c <FreePrinting+0x2b0>
		      iLoop++;
   12582:	80 91 e9 01 	lds	r24, 0x01E9
   12586:	90 91 ea 01 	lds	r25, 0x01EA
   1258a:	01 96       	adiw	r24, 0x01	; 1
   1258c:	90 93 ea 01 	sts	0x01EA, r25
   12590:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
   12594:	10 92 b6 01 	sts	0x01B6, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
   12598:	83 e1       	ldi	r24, 0x13	; 19
   1259a:	f6 ce       	rjmp	.-532    	; 0x12388 <FreePrinting+0x9c>
				 }
			  }
          else stFreePrinting=fpLoadEndLine;//fpInitFooter;
   1259c:	86 e1       	ldi	r24, 0x16	; 22
   1259e:	f4 ce       	rjmp	.-536    	; 0x12388 <FreePrinting+0x9c>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
   125a0:	80 91 b3 01 	lds	r24, 0x01B3
   125a4:	88 23       	and	r24, r24
   125a6:	09 f0       	breq	.+2      	; 0x125aa <FreePrinting+0x2be>
   125a8:	bf c1       	rjmp	.+894    	; 0x12928 <FreePrinting+0x63c>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
   125aa:	e0 91 ed 01 	lds	r30, 0x01ED
   125ae:	f0 91 ee 01 	lds	r31, 0x01EE
   125b2:	e4 51       	subi	r30, 0x14	; 20
   125b4:	fc 4f       	sbci	r31, 0xFC	; 252
   125b6:	80 81       	ld	r24, Z
   125b8:	61 81       	ldd	r22, Z+1	; 0x01
   125ba:	0e 94 71 42 	call	0x84e2	; 0x84e2 <SendPrint>
			     // uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
   125be:	e0 91 ed 01 	lds	r30, 0x01ED
   125c2:	f0 91 ee 01 	lds	r31, 0x01EE
   125c6:	e4 51       	subi	r30, 0x14	; 20
   125c8:	fc 4f       	sbci	r31, 0xFC	; 252
   125ca:	80 81       	ld	r24, Z
   125cc:	8d 30       	cpi	r24, 0x0D	; 13
   125ce:	19 f0       	breq	.+6      	; 0x125d6 <FreePrinting+0x2ea>
   125d0:	81 81       	ldd	r24, Z+1	; 0x01
   125d2:	8a 30       	cpi	r24, 0x0A	; 10
   125d4:	11 f4       	brne	.+4      	; 0x125da <FreePrinting+0x2ee>
			     CarriegeReturn();
   125d6:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
             iSend++;
   125da:	80 91 ed 01 	lds	r24, 0x01ED
   125de:	90 91 ee 01 	lds	r25, 0x01EE
   125e2:	01 96       	adiw	r24, 0x01	; 1
   125e4:	90 93 ee 01 	sts	0x01EE, r25
   125e8:	80 93 ed 01 	sts	0x01ED, r24
		     stFreePrinting=fpPrintMessage;
   125ec:	88 e0       	ldi	r24, 0x08	; 8
   125ee:	9a c1       	rjmp	.+820    	; 0x12924 <FreePrinting+0x638>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
   125f0:	10 92 ea 01 	sts	0x01EA, r1
   125f4:	10 92 e9 01 	sts	0x01E9, r1
		  iMargin=0;
   125f8:	10 92 f1 01 	sts	0x01F1, r1
		  stFreePrinting=fpPrintMargin;
   125fc:	8a e0       	ldi	r24, 0x0A	; 10
   125fe:	c4 ce       	rjmp	.-632    	; 0x12388 <FreePrinting+0x9c>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
   12600:	80 91 f1 01 	lds	r24, 0x01F1
   12604:	85 30       	cpi	r24, 0x05	; 5
   12606:	90 f4       	brcc	.+36     	; 0x1262c <FreePrinting+0x340>
		      iMargin++;
   12608:	8f 5f       	subi	r24, 0xFF	; 255
   1260a:	80 93 f1 01 	sts	0x01F1, r24
		      iLoop++;
   1260e:	80 91 e9 01 	lds	r24, 0x01E9
   12612:	90 91 ea 01 	lds	r25, 0x01EA
   12616:	01 96       	adiw	r24, 0x01	; 1
   12618:	90 93 ea 01 	sts	0x01EA, r25
   1261c:	80 93 e9 01 	sts	0x01E9, r24
	          if ((iLoop%PRINT_DELAY)==0)uart(_COM_PRINTER,1,' ');
   12620:	80 e0       	ldi	r24, 0x00	; 0
   12622:	61 e0       	ldi	r22, 0x01	; 1
   12624:	40 e2       	ldi	r20, 0x20	; 32
   12626:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
   1262a:	06 c2       	rjmp	.+1036   	; 0x12a38 <FreePrinting+0x74c>
			 }
          else stFreePrinting=fpPrintMessage;
   1262c:	88 e0       	ldi	r24, 0x08	; 8
   1262e:	ac ce       	rjmp	.-680    	; 0x12388 <FreePrinting+0x9c>
   12630:	8e 01       	movw	r16, r28
   12632:	0f 5f       	subi	r16, 0xFF	; 255
   12634:	1f 4f       	sbci	r17, 0xFF	; 255
   12636:	c8 01       	movw	r24, r16
   12638:	65 e1       	ldi	r22, 0x15	; 21
   1263a:	70 e0       	ldi	r23, 0x00	; 0
   1263c:	42 e1       	ldi	r20, 0x12	; 18
   1263e:	50 e0       	ldi	r21, 0x00	; 0
   12640:	24 e4       	ldi	r18, 0x44	; 68
   12642:	32 e1       	ldi	r19, 0x12	; 18
   12644:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
   12648:	c8 01       	movw	r24, r16
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1264a:	9e 01       	movw	r18, r28
   1264c:	20 5f       	subi	r18, 0xF0	; 240
   1264e:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
   12650:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   12652:	82 17       	cp	r24, r18
   12654:	93 07       	cpc	r25, r19
   12656:	e1 f7       	brne	.-8      	; 0x12650 <FreePrinting+0x364>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   12658:	18 8a       	std	Y+16, r1	; 0x10
     
     //Added Operator Name:
	 case fpLoadEndLine:
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
          StrPosCopy(strOperatorName,strOperatorName,0,15);
          if (strlen(strOperatorName)>0){
   1265a:	89 81       	ldd	r24, Y+1	; 0x01
   1265c:	88 23       	and	r24, r24
   1265e:	09 f4       	brne	.+2      	; 0x12662 <FreePrinting+0x376>
   12660:	d6 c0       	rjmp	.+428    	; 0x1280e <FreePrinting+0x522>
		  	  if (SpaceOnly(strOperatorName)!=True){
   12662:	ce 01       	movw	r24, r28
   12664:	01 96       	adiw	r24, 0x01	; 1
   12666:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   1266a:	81 30       	cpi	r24, 0x01	; 1
   1266c:	09 f4       	brne	.+2      	; 0x12670 <FreePrinting+0x384>
   1266e:	cf c0       	rjmp	.+414    	; 0x1280e <FreePrinting+0x522>
			      sprintf_P(strPrint,PSTR("---------------------------------"));
   12670:	00 d0       	rcall	.+0      	; 0x12672 <FreePrinting+0x386>
   12672:	00 d0       	rcall	.+0      	; 0x12674 <FreePrinting+0x388>
   12674:	0c eb       	ldi	r16, 0xBC	; 188
   12676:	18 e0       	ldi	r17, 0x08	; 8
   12678:	ad b7       	in	r26, 0x3d	; 61
   1267a:	be b7       	in	r27, 0x3e	; 62
   1267c:	12 96       	adiw	r26, 0x02	; 2
   1267e:	1c 93       	st	X, r17
   12680:	0e 93       	st	-X, r16
   12682:	11 97       	sbiw	r26, 0x01	; 1
   12684:	82 e2       	ldi	r24, 0x22	; 34
   12686:	95 e0       	ldi	r25, 0x05	; 5
   12688:	14 96       	adiw	r26, 0x04	; 4
   1268a:	9c 93       	st	X, r25
   1268c:	8e 93       	st	-X, r24
   1268e:	13 97       	sbiw	r26, 0x03	; 3
   12690:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			      //AddSpaceLead(strPrint,(strlen(strPrint)+PRINT_MARGIN));
			      iSend=0;
   12694:	10 92 ee 01 	sts	0x01EE, r1
   12698:	10 92 ed 01 	sts	0x01ED, r1
				  iLoop=0;
   1269c:	10 92 ea 01 	sts	0x01EA, r1
   126a0:	10 92 e9 01 	sts	0x01E9, r1
				  LSend=strlen(strPrint);
   126a4:	f8 01       	movw	r30, r16
   126a6:	01 90       	ld	r0, Z+
   126a8:	00 20       	and	r0, r0
   126aa:	e9 f7       	brne	.-6      	; 0x126a6 <FreePrinting+0x3ba>
   126ac:	8f 01       	movw	r16, r30
   126ae:	01 50       	subi	r16, 0x01	; 1
   126b0:	10 40       	sbci	r17, 0x00	; 0
   126b2:	0c 5b       	subi	r16, 0xBC	; 188
   126b4:	18 40       	sbci	r17, 0x08	; 8
   126b6:	10 93 ec 01 	sts	0x01EC, r17
   126ba:	00 93 eb 01 	sts	0x01EB, r16
				  stFreePrinting=fpPrintEndLine;	
   126be:	87 e1       	ldi	r24, 0x17	; 23
   126c0:	80 93 25 01 	sts	0x0125, r24
   126c4:	0f 90       	pop	r0
   126c6:	0f 90       	pop	r0
   126c8:	0f 90       	pop	r0
   126ca:	0f 90       	pop	r0
   126cc:	b5 c1       	rjmp	.+874    	; 0x12a38 <FreePrinting+0x74c>
			   }else stFreePrinting=fpInitFooter;
		  }else stFreePrinting=fpInitFooter;
	      break;

	 case fpPrintEndLine:
		  if (iSend<LSend){
   126ce:	20 91 ed 01 	lds	r18, 0x01ED
   126d2:	30 91 ee 01 	lds	r19, 0x01EE
   126d6:	80 91 eb 01 	lds	r24, 0x01EB
   126da:	90 91 ec 01 	lds	r25, 0x01EC
   126de:	28 17       	cp	r18, r24
   126e0:	39 07       	cpc	r19, r25
   126e2:	68 f4       	brcc	.+26     	; 0x126fe <FreePrinting+0x412>
		      iLoop++;
   126e4:	80 91 e9 01 	lds	r24, 0x01E9
   126e8:	90 91 ea 01 	lds	r25, 0x01EA
   126ec:	01 96       	adiw	r24, 0x01	; 1
   126ee:	90 93 ea 01 	sts	0x01EA, r25
   126f2:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
   126f6:	10 92 b6 01 	sts	0x01B6, r1
				  stFreePrinting=fpCheckPrintEndLine;
   126fa:	88 e1       	ldi	r24, 0x18	; 24
   126fc:	45 ce       	rjmp	.-886    	; 0x12388 <FreePrinting+0x9c>
				}
			  }
          else {
			  CarriegeReturn();
   126fe:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			  stFreePrinting=fpLoadOperatorName;
   12702:	89 e1       	ldi	r24, 0x19	; 25
   12704:	41 ce       	rjmp	.-894    	; 0x12388 <FreePrinting+0x9c>
			  }
	      break;
	 case fpCheckPrintEndLine:
	      if (IsBusyPrint==False){
   12706:	80 91 b3 01 	lds	r24, 0x01B3
   1270a:	88 23       	and	r24, r24
   1270c:	09 f0       	breq	.+2      	; 0x12710 <FreePrinting+0x424>
   1270e:	0c c1       	rjmp	.+536    	; 0x12928 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   12710:	e0 91 ed 01 	lds	r30, 0x01ED
   12714:	f0 91 ee 01 	lds	r31, 0x01EE
   12718:	e4 54       	subi	r30, 0x44	; 68
   1271a:	f7 4f       	sbci	r31, 0xF7	; 247
   1271c:	61 e0       	ldi	r22, 0x01	; 1
   1271e:	40 81       	ld	r20, Z
   12720:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   12724:	80 91 ed 01 	lds	r24, 0x01ED
   12728:	90 91 ee 01 	lds	r25, 0x01EE
   1272c:	01 96       	adiw	r24, 0x01	; 1
   1272e:	90 93 ee 01 	sts	0x01EE, r25
   12732:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintEndLine;
   12736:	87 e1       	ldi	r24, 0x17	; 23
   12738:	f5 c0       	rjmp	.+490    	; 0x12924 <FreePrinting+0x638>
   1273a:	8e 01       	movw	r16, r28
   1273c:	0f 5f       	subi	r16, 0xFF	; 255
   1273e:	1f 4f       	sbci	r17, 0xFF	; 255
   12740:	c8 01       	movw	r24, r16
   12742:	65 e1       	ldi	r22, 0x15	; 21
   12744:	70 e0       	ldi	r23, 0x00	; 0
   12746:	42 e1       	ldi	r20, 0x12	; 18
   12748:	50 e0       	ldi	r21, 0x00	; 0
   1274a:	24 e4       	ldi	r18, 0x44	; 68
   1274c:	32 e1       	ldi	r19, 0x12	; 18
   1274e:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
   12752:	c8 01       	movw	r24, r16
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   12754:	9e 01       	movw	r18, r28
   12756:	20 5f       	subi	r18, 0xF0	; 240
   12758:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
   1275a:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1275c:	82 17       	cp	r24, r18
   1275e:	93 07       	cpc	r25, r19
   12760:	e1 f7       	brne	.-8      	; 0x1275a <FreePrinting+0x46e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   12762:	18 8a       	std	Y+16, r1	; 0x10
	      break;

	 case fpLoadOperatorName:
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);
		  sprintf_P(strPrint,PSTR("Operator: %s"),strOperatorName);
   12764:	00 d0       	rcall	.+0      	; 0x12766 <FreePrinting+0x47a>
   12766:	00 d0       	rcall	.+0      	; 0x12768 <FreePrinting+0x47c>
   12768:	00 d0       	rcall	.+0      	; 0x1276a <FreePrinting+0x47e>
   1276a:	ed b7       	in	r30, 0x3d	; 61
   1276c:	fe b7       	in	r31, 0x3e	; 62
   1276e:	31 96       	adiw	r30, 0x01	; 1
   12770:	0c eb       	ldi	r16, 0xBC	; 188
   12772:	18 e0       	ldi	r17, 0x08	; 8
   12774:	ad b7       	in	r26, 0x3d	; 61
   12776:	be b7       	in	r27, 0x3e	; 62
   12778:	12 96       	adiw	r26, 0x02	; 2
   1277a:	1c 93       	st	X, r17
   1277c:	0e 93       	st	-X, r16
   1277e:	11 97       	sbiw	r26, 0x01	; 1
   12780:	85 e1       	ldi	r24, 0x15	; 21
   12782:	95 e0       	ldi	r25, 0x05	; 5
   12784:	93 83       	std	Z+3, r25	; 0x03
   12786:	82 83       	std	Z+2, r24	; 0x02
   12788:	ce 01       	movw	r24, r28
   1278a:	01 96       	adiw	r24, 0x01	; 1
   1278c:	95 83       	std	Z+5, r25	; 0x05
   1278e:	84 83       	std	Z+4, r24	; 0x04
   12790:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	      iSend=0;
   12794:	10 92 ee 01 	sts	0x01EE, r1
   12798:	10 92 ed 01 	sts	0x01ED, r1
		  iLoop=0;
   1279c:	10 92 ea 01 	sts	0x01EA, r1
   127a0:	10 92 e9 01 	sts	0x01E9, r1
		  LSend=strlen(strPrint);
   127a4:	f8 01       	movw	r30, r16
   127a6:	01 90       	ld	r0, Z+
   127a8:	00 20       	and	r0, r0
   127aa:	e9 f7       	brne	.-6      	; 0x127a6 <FreePrinting+0x4ba>
   127ac:	8f 01       	movw	r16, r30
   127ae:	01 50       	subi	r16, 0x01	; 1
   127b0:	10 40       	sbci	r17, 0x00	; 0
   127b2:	0c 5b       	subi	r16, 0xBC	; 188
   127b4:	18 40       	sbci	r17, 0x08	; 8
   127b6:	10 93 ec 01 	sts	0x01EC, r17
   127ba:	00 93 eb 01 	sts	0x01EB, r16
		  stFreePrinting=fpPrintOperatorName;	
   127be:	8a e1       	ldi	r24, 0x1A	; 26
   127c0:	80 93 25 01 	sts	0x0125, r24
   127c4:	8d b7       	in	r24, 0x3d	; 61
   127c6:	9e b7       	in	r25, 0x3e	; 62
   127c8:	06 96       	adiw	r24, 0x06	; 6
   127ca:	0f b6       	in	r0, 0x3f	; 63
   127cc:	f8 94       	cli
   127ce:	9e bf       	out	0x3e, r25	; 62
   127d0:	0f be       	out	0x3f, r0	; 63
   127d2:	8d bf       	out	0x3d, r24	; 61
   127d4:	31 c1       	rjmp	.+610    	; 0x12a38 <FreePrinting+0x74c>
	      break;
	 case fpPrintOperatorName:
		  if (iSend<LSend){
   127d6:	20 91 ed 01 	lds	r18, 0x01ED
   127da:	30 91 ee 01 	lds	r19, 0x01EE
   127de:	80 91 eb 01 	lds	r24, 0x01EB
   127e2:	90 91 ec 01 	lds	r25, 0x01EC
   127e6:	28 17       	cp	r18, r24
   127e8:	39 07       	cpc	r19, r25
   127ea:	68 f4       	brcc	.+26     	; 0x12806 <FreePrinting+0x51a>
		      iLoop++;
   127ec:	80 91 e9 01 	lds	r24, 0x01E9
   127f0:	90 91 ea 01 	lds	r25, 0x01EA
   127f4:	01 96       	adiw	r24, 0x01	; 1
   127f6:	90 93 ea 01 	sts	0x01EA, r25
   127fa:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
   127fe:	10 92 b6 01 	sts	0x01B6, r1
				  stFreePrinting=fpCheckPrintOperatorName;
   12802:	8b e1       	ldi	r24, 0x1B	; 27
   12804:	c1 cd       	rjmp	.-1150   	; 0x12388 <FreePrinting+0x9c>
				}
			  }
          else {
			  CarriegeReturn();
   12806:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			  CarriegeReturn();
   1280a:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			  stFreePrinting=fpInitFooter;
   1280e:	8b e0       	ldi	r24, 0x0B	; 11
   12810:	bb cd       	rjmp	.-1162   	; 0x12388 <FreePrinting+0x9c>
			  }
	      break;
	 case fpCheckPrintOperatorName:
	      if (IsBusyPrint==False){
   12812:	80 91 b3 01 	lds	r24, 0x01B3
   12816:	88 23       	and	r24, r24
   12818:	09 f0       	breq	.+2      	; 0x1281c <FreePrinting+0x530>
   1281a:	86 c0       	rjmp	.+268    	; 0x12928 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   1281c:	e0 91 ed 01 	lds	r30, 0x01ED
   12820:	f0 91 ee 01 	lds	r31, 0x01EE
   12824:	e4 54       	subi	r30, 0x44	; 68
   12826:	f7 4f       	sbci	r31, 0xF7	; 247
   12828:	61 e0       	ldi	r22, 0x01	; 1
   1282a:	40 81       	ld	r20, Z
   1282c:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   12830:	80 91 ed 01 	lds	r24, 0x01ED
   12834:	90 91 ee 01 	lds	r25, 0x01EE
   12838:	01 96       	adiw	r24, 0x01	; 1
   1283a:	90 93 ee 01 	sts	0x01EE, r25
   1283e:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintOperatorName;
   12842:	8a e1       	ldi	r24, 0x1A	; 26
   12844:	6f c0       	rjmp	.+222    	; 0x12924 <FreePrinting+0x638>
			  }
	      break;

     case fpInitFooter:
	      //uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
   12846:	80 91 b5 01 	lds	r24, 0x01B5
   1284a:	86 ff       	sbrs	r24, 6
   1284c:	06 c0       	rjmp	.+12     	; 0x1285a <FreePrinting+0x56e>
		      stFreePrinting=fpLoadFooter;
   1284e:	8c e0       	ldi	r24, 0x0C	; 12
   12850:	80 93 25 01 	sts	0x0125, r24
			  iFooter=0;
   12854:	10 92 f3 01 	sts	0x01F3, r1
   12858:	ef c0       	rjmp	.+478    	; 0x12a38 <FreePrinting+0x74c>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
   1285a:	80 e1       	ldi	r24, 0x10	; 16
   1285c:	95 cd       	rjmp	.-1238   	; 0x12388 <FreePrinting+0x9c>
   1285e:	60 91 f3 01 	lds	r22, 0x01F3
   12862:	89 e2       	ldi	r24, 0x29	; 41
   12864:	68 9f       	mul	r22, r24
   12866:	b0 01       	movw	r22, r0
   12868:	11 24       	eor	r1, r1
   1286a:	63 5e       	subi	r22, 0xE3	; 227
   1286c:	7c 4f       	sbci	r23, 0xFC	; 252
   1286e:	8c eb       	ldi	r24, 0xBC	; 188
   12870:	98 e0       	ldi	r25, 0x08	; 8
   12872:	48 e2       	ldi	r20, 0x28	; 40
   12874:	50 e0       	ldi	r21, 0x00	; 0
   12876:	24 e4       	ldi	r18, 0x44	; 68
   12878:	32 e1       	ldi	r19, 0x12	; 18
   1287a:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
   1287e:	80 91 f3 01 	lds	r24, 0x01F3
   12882:	8f 5f       	subi	r24, 0xFF	; 255
   12884:	80 93 f3 01 	sts	0x01F3, r24
		  if (iFooter<4){
   12888:	84 30       	cpi	r24, 0x04	; 4
   1288a:	90 f4       	brcc	.+36     	; 0x128b0 <FreePrinting+0x5c4>
		      if (SpaceOnly(strPrint)==True){
   1288c:	8c eb       	ldi	r24, 0xBC	; 188
   1288e:	98 e0       	ldi	r25, 0x08	; 8
   12890:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   12894:	81 30       	cpi	r24, 0x01	; 1
   12896:	11 f4       	brne	.+4      	; 0x1289c <FreePrinting+0x5b0>
			      stFreePrinting=fpLoadFooter;
   12898:	8c e0       	ldi	r24, 0x0C	; 12
   1289a:	76 cd       	rjmp	.-1300   	; 0x12388 <FreePrinting+0x9c>
				  }
			  else{
			      iSend=0;
   1289c:	10 92 ee 01 	sts	0x01EE, r1
   128a0:	10 92 ed 01 	sts	0x01ED, r1
				  iLoop=0;
   128a4:	10 92 ea 01 	sts	0x01EA, r1
   128a8:	10 92 e9 01 	sts	0x01E9, r1
				  stFreePrinting=fpPrintFooter;
   128ac:	8d e0       	ldi	r24, 0x0D	; 13
   128ae:	6c cd       	rjmp	.-1320   	; 0x12388 <FreePrinting+0x9c>
			      }
		  }else{
		    CarriegeReturn();
   128b0:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			iPrinted++;
   128b4:	80 91 f5 01 	lds	r24, 0x01F5
   128b8:	8f 5f       	subi	r24, 0xFF	; 255
   128ba:	80 93 f5 01 	sts	0x01F5, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
   128be:	8e e0       	ldi	r24, 0x0E	; 14
   128c0:	63 cd       	rjmp	.-1338   	; 0x12388 <FreePrinting+0x9c>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
   128c2:	80 91 ed 01 	lds	r24, 0x01ED
   128c6:	90 91 ee 01 	lds	r25, 0x01EE
   128ca:	88 97       	sbiw	r24, 0x28	; 40
   128cc:	68 f4       	brcc	.+26     	; 0x128e8 <FreePrinting+0x5fc>
		      iLoop++;
   128ce:	80 91 e9 01 	lds	r24, 0x01E9
   128d2:	90 91 ea 01 	lds	r25, 0x01EA
   128d6:	01 96       	adiw	r24, 0x01	; 1
   128d8:	90 93 ea 01 	sts	0x01EA, r25
   128dc:	80 93 e9 01 	sts	0x01E9, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //uart(_COM_PRINTER,1,strPrint[iSend]);
		        //iSend++;
				TimPrintBusy=0;
   128e0:	10 92 b6 01 	sts	0x01B6, r1
				stFreePrinting=fpCheckPrintStatusFooter;
   128e4:	84 e1       	ldi	r24, 0x14	; 20
   128e6:	50 cd       	rjmp	.-1376   	; 0x12388 <FreePrinting+0x9c>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
   128e8:	8c e0       	ldi	r24, 0x0C	; 12
   128ea:	80 93 25 01 	sts	0x0125, r24
			  CarriegeReturn();
   128ee:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   128f2:	a2 c0       	rjmp	.+324    	; 0x12a38 <FreePrinting+0x74c>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
   128f4:	80 91 b3 01 	lds	r24, 0x01B3
   128f8:	88 23       	and	r24, r24
   128fa:	b1 f4       	brne	.+44     	; 0x12928 <FreePrinting+0x63c>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   128fc:	e0 91 ed 01 	lds	r30, 0x01ED
   12900:	f0 91 ee 01 	lds	r31, 0x01EE
   12904:	e4 54       	subi	r30, 0x44	; 68
   12906:	f7 4f       	sbci	r31, 0xF7	; 247
   12908:	61 e0       	ldi	r22, 0x01	; 1
   1290a:	40 81       	ld	r20, Z
   1290c:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   12910:	80 91 ed 01 	lds	r24, 0x01ED
   12914:	90 91 ee 01 	lds	r25, 0x01EE
   12918:	01 96       	adiw	r24, 0x01	; 1
   1291a:	90 93 ee 01 	sts	0x01EE, r25
   1291e:	80 93 ed 01 	sts	0x01ED, r24
		      stFreePrinting=fpPrintFooter;
   12922:	8d e0       	ldi	r24, 0x0D	; 13
   12924:	80 93 25 01 	sts	0x0125, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
   12928:	80 91 b6 01 	lds	r24, 0x01B6
   1292c:	8b 30       	cpi	r24, 0x0B	; 11
   1292e:	08 f4       	brcc	.+2      	; 0x12932 <FreePrinting+0x646>
   12930:	83 c0       	rjmp	.+262    	; 0x12a38 <FreePrinting+0x74c>
		      IsPrintERROR=True;
   12932:	81 e0       	ldi	r24, 0x01	; 1
   12934:	80 93 b1 01 	sts	0x01B1, r24
		      stFreePrinting=fpFinishFreePrinting;
   12938:	81 e1       	ldi	r24, 0x11	; 17
   1293a:	26 cd       	rjmp	.-1460   	; 0x12388 <FreePrinting+0x9c>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
   1293c:	10 92 f0 01 	sts	0x01F0, r1
		  iSend=0;
   12940:	10 92 ee 01 	sts	0x01EE, r1
   12944:	10 92 ed 01 	sts	0x01ED, r1
		  if (iPrinted<PrintCopy)
   12948:	90 91 f5 01 	lds	r25, 0x01F5
   1294c:	80 91 f2 01 	lds	r24, 0x01F2
   12950:	98 17       	cp	r25, r24
   12952:	28 f4       	brcc	.+10     	; 0x1295e <FreePrinting+0x672>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12954:	e1 99       	sbic	0x1c, 1	; 28
   12956:	fe cf       	rjmp	.-4      	; 0x12954 <FreePrinting+0x668>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12958:	82 e3       	ldi	r24, 0x32	; 50
   1295a:	90 e0       	ldi	r25, 0x00	; 0
   1295c:	04 c0       	rjmp	.+8      	; 0x12966 <FreePrinting+0x67a>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1295e:	e1 99       	sbic	0x1c, 1	; 28
   12960:	fe cf       	rjmp	.-4      	; 0x1295e <FreePrinting+0x672>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12962:	81 e3       	ldi	r24, 0x31	; 49
   12964:	90 e0       	ldi	r25, 0x00	; 0
   12966:	9f bb       	out	0x1f, r25	; 31
   12968:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1296a:	e0 9a       	sbi	0x1c, 0	; 28
   1296c:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
   1296e:	80 93 ef 01 	sts	0x01EF, r24

          stFreePrinting=fpScrollPaper;
   12972:	8f e0       	ldi	r24, 0x0F	; 15
   12974:	09 cd       	rjmp	.-1518   	; 0x12388 <FreePrinting+0x9c>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
   12976:	90 91 f0 01 	lds	r25, 0x01F0
   1297a:	80 91 ef 01 	lds	r24, 0x01EF
   1297e:	89 17       	cp	r24, r25
   12980:	18 f4       	brcc	.+6      	; 0x12988 <FreePrinting+0x69c>
   12982:	80 e1       	ldi	r24, 0x10	; 16
   12984:	80 93 25 01 	sts	0x0125, r24
		  iSend++;
   12988:	80 91 ed 01 	lds	r24, 0x01ED
   1298c:	90 91 ee 01 	lds	r25, 0x01EE
   12990:	01 96       	adiw	r24, 0x01	; 1
   12992:	90 93 ee 01 	sts	0x01EE, r25
   12996:	80 93 ed 01 	sts	0x01ED, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
   1299a:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			  iScroll++;
   1299e:	80 91 f0 01 	lds	r24, 0x01F0
   129a2:	8f 5f       	subi	r24, 0xFF	; 255
   129a4:	80 93 f0 01 	sts	0x01F0, r24
   129a8:	47 c0       	rjmp	.+142    	; 0x12a38 <FreePrinting+0x74c>
			  }
	      break;
     case fpPaperCut:
		  //uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
   129aa:	90 91 f5 01 	lds	r25, 0x01F5
   129ae:	80 91 f2 01 	lds	r24, 0x01F2
   129b2:	98 17       	cp	r25, r24
   129b4:	20 f4       	brcc	.+8      	; 0x129be <FreePrinting+0x6d2>
		      CarriegeReturn();
   129b6:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
              stFreePrinting=fpInitHeader;
   129ba:	82 e0       	ldi	r24, 0x02	; 2
   129bc:	07 c0       	rjmp	.+14     	; 0x129cc <FreePrinting+0x6e0>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
   129be:	80 91 00 01 	lds	r24, 0x0100
   129c2:	81 30       	cpi	r24, 0x01	; 1
   129c4:	11 f4       	brne	.+4      	; 0x129ca <FreePrinting+0x6de>
   129c6:	0e 94 72 91 	call	0x122e4	; 0x122e4 <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
   129ca:	81 e1       	ldi	r24, 0x11	; 17
   129cc:	80 93 25 01 	sts	0x0125, r24
			  }
          
		  if (((cmdPrint&0b00100000)>>5)==1){
   129d0:	80 91 b5 01 	lds	r24, 0x01B5
   129d4:	85 ff       	sbrs	r24, 5
   129d6:	30 c0       	rjmp	.+96     	; 0x12a38 <FreePrinting+0x74c>
		      if (iPrinted==0){
   129d8:	80 91 f5 01 	lds	r24, 0x01F5
   129dc:	88 23       	and	r24, r24
   129de:	31 f4       	brne	.+12     	; 0x129ec <FreePrinting+0x700>
			      CarriegeReturn();_delay_ms(50);
   129e0:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   129e4:	84 ed       	ldi	r24, 0xD4	; 212
   129e6:	90 e3       	ldi	r25, 0x30	; 48
   129e8:	01 97       	sbiw	r24, 0x01	; 1
   129ea:	f1 f7       	brne	.-4      	; 0x129e8 <FreePrinting+0x6fc>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
   129ec:	90 91 f5 01 	lds	r25, 0x01F5
   129f0:	80 91 f2 01 	lds	r24, 0x01F2
   129f4:	98 17       	cp	r25, r24
   129f6:	b1 f4       	brne	.+44     	; 0x12a24 <FreePrinting+0x738>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				  CarriegeReturn();_delay_ms(50);
   129f8:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   129fc:	04 ed       	ldi	r16, 0xD4	; 212
   129fe:	10 e3       	ldi	r17, 0x30	; 48
   12a00:	c8 01       	movw	r24, r16
   12a02:	01 97       	sbiw	r24, 0x01	; 1
   12a04:	f1 f7       	brne	.-4      	; 0x12a02 <FreePrinting+0x716>
				  CarriegeReturn();_delay_ms(50);
   12a06:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   12a0a:	c8 01       	movw	r24, r16
   12a0c:	01 97       	sbiw	r24, 0x01	; 1
   12a0e:	f1 f7       	brne	.-4      	; 0x12a0c <FreePrinting+0x720>
				  CarriegeReturn();_delay_ms(50);
   12a10:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   12a14:	c8 01       	movw	r24, r16
   12a16:	01 97       	sbiw	r24, 0x01	; 1
   12a18:	f1 f7       	brne	.-4      	; 0x12a16 <FreePrinting+0x72a>
				  CarriegeReturn();_delay_ms(50);
   12a1a:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   12a1e:	c8 01       	movw	r24, r16
   12a20:	01 97       	sbiw	r24, 0x01	; 1
   12a22:	f1 f7       	brne	.-4      	; 0x12a20 <FreePrinting+0x734>
				   //}
				 }
		      PaperCut();
   12a24:	0e 94 30 43 	call	0x8660	; 0x8660 <PaperCut>
   12a28:	07 c0       	rjmp	.+14     	; 0x12a38 <FreePrinting+0x74c>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
   12a2a:	10 92 b4 01 	sts	0x01B4, r1
	      stFreePrinting=fpInit;
   12a2e:	81 e0       	ldi	r24, 0x01	; 1
   12a30:	80 93 25 01 	sts	0x0125, r24
		  iPrinted=0;
   12a34:	10 92 f5 01 	sts	0x01F5, r1
	      break;
	 }//EndCase
}
   12a38:	64 96       	adiw	r28, 0x14	; 20
   12a3a:	0f b6       	in	r0, 0x3f	; 63
   12a3c:	f8 94       	cli
   12a3e:	de bf       	out	0x3e, r29	; 62
   12a40:	0f be       	out	0x3f, r0	; 63
   12a42:	cd bf       	out	0x3d, r28	; 61
   12a44:	cf 91       	pop	r28
   12a46:	df 91       	pop	r29
   12a48:	1f 91       	pop	r17
   12a4a:	0f 91       	pop	r16
   12a4c:	08 95       	ret

00012a4e <PrintIdle>:
		//Font Setting: 1D 21 01
		uart(_COM_PRINTER, 1, 0x1D);uart(_COM_PRINTER, 1, 0x21);uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
   12a4e:	ef 92       	push	r14
   12a50:	ff 92       	push	r15
   12a52:	0f 93       	push	r16
   12a54:	1f 93       	push	r17
   12a56:	df 93       	push	r29
   12a58:	cf 93       	push	r28
   12a5a:	cd b7       	in	r28, 0x3d	; 61
   12a5c:	de b7       	in	r29, 0x3e	; 62
   12a5e:	64 97       	sbiw	r28, 0x14	; 20
   12a60:	0f b6       	in	r0, 0x3f	; 63
   12a62:	f8 94       	cli
   12a64:	de bf       	out	0x3e, r29	; 62
   12a66:	0f be       	out	0x3f, r0	; 63
   12a68:	cd bf       	out	0x3d, r28	; 61
		uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
   12a6a:	80 91 ac 01 	lds	r24, 0x01AC
   12a6e:	81 30       	cpi	r24, 0x01	; 1
   12a70:	31 f4       	brne	.+12     	; 0x12a7e <PrintIdle+0x30>
   12a72:	80 91 06 02 	lds	r24, 0x0206
   12a76:	88 23       	and	r24, r24
   12a78:	11 f0       	breq	.+4      	; 0x12a7e <PrintIdle+0x30>
	     stPrintIdle=piIdle;
   12a7a:	10 92 06 02 	sts	0x0206, r1
	 }

     switch(stPrintIdle){
   12a7e:	80 91 06 02 	lds	r24, 0x0206
   12a82:	e8 2f       	mov	r30, r24
   12a84:	f0 e0       	ldi	r31, 0x00	; 0
   12a86:	e8 31       	cpi	r30, 0x18	; 24
   12a88:	f1 05       	cpc	r31, r1
   12a8a:	08 f0       	brcs	.+2      	; 0x12a8e <PrintIdle+0x40>
   12a8c:	96 c7       	rjmp	.+3884   	; 0x139ba <PrintIdle+0xf6c>
   12a8e:	e0 52       	subi	r30, 0x20	; 32
   12a90:	ff 4f       	sbci	r31, 0xFF	; 255
   12a92:	ee 0f       	add	r30, r30
   12a94:	ff 1f       	adc	r31, r31
   12a96:	05 90       	lpm	r0, Z+
   12a98:	f4 91       	lpm	r31, Z+
   12a9a:	e0 2d       	mov	r30, r0
   12a9c:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
   12a9e:	80 91 ac 01 	lds	r24, 0x01AC
   12aa2:	81 30       	cpi	r24, 0x01	; 1
   12aa4:	09 f0       	breq	.+2      	; 0x12aa8 <PrintIdle+0x5a>
   12aa6:	89 c7       	rjmp	.+3858   	; 0x139ba <PrintIdle+0xf6c>
		      IsPrinting=False;
   12aa8:	10 92 ac 01 	sts	0x01AC, r1
			  IsBusyIdlePrinting=True;
   12aac:	80 93 b2 01 	sts	0x01B2, r24
			  IsBusyPrint=False;
   12ab0:	10 92 b3 01 	sts	0x01B3, r1
			  iPrinted=0;
   12ab4:	10 92 f8 01 	sts	0x01F8, r1
			  PrintCopy=0;
   12ab8:	10 92 f7 01 	sts	0x01F7, r1
		      stPrintIdle=piInit;
   12abc:	80 93 06 02 	sts	0x0206, r24
			  InitPrinter();
   12ac0:	0e 94 94 42 	call	0x8528	; 0x8528 <InitPrinter>
			  IsSignedField=False;
   12ac4:	10 92 ff 01 	sts	0x01FF, r1
   12ac8:	78 c7       	rjmp	.+3824   	; 0x139ba <PrintIdle+0xf6c>
			  }
	      break;
	 case piInit:
	      iHeader=0;
   12aca:	10 92 05 02 	sts	0x0205, r1
		  CarriegeReturn();
   12ace:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   12ad2:	1d c0       	rjmp	.+58     	; 0x12b0e <PrintIdle+0xc0>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   12ad4:	60 91 05 02 	lds	r22, 0x0205
   12ad8:	89 e2       	ldi	r24, 0x29	; 41
   12ada:	68 9f       	mul	r22, r24
   12adc:	b0 01       	movw	r22, r0
   12ade:	11 24       	eor	r1, r1
   12ae0:	69 5d       	subi	r22, 0xD9	; 217
   12ae2:	7d 4f       	sbci	r23, 0xFD	; 253
   12ae4:	8c eb       	ldi	r24, 0xBC	; 188
   12ae6:	98 e0       	ldi	r25, 0x08	; 8
   12ae8:	49 e2       	ldi	r20, 0x29	; 41
   12aea:	50 e0       	ldi	r21, 0x00	; 0
   12aec:	24 e4       	ldi	r18, 0x44	; 68
   12aee:	32 e1       	ldi	r19, 0x12	; 18
   12af0:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
   12af4:	80 91 05 02 	lds	r24, 0x0205
   12af8:	8f 5f       	subi	r24, 0xFF	; 255
   12afa:	80 93 05 02 	sts	0x0205, r24
		  if (iHeader<6){
   12afe:	86 30       	cpi	r24, 0x06	; 6
   12b00:	00 f5       	brcc	.+64     	; 0x12b42 <PrintIdle+0xf4>
		      if (SpaceOnly(strPrint)==True){
   12b02:	8c eb       	ldi	r24, 0xBC	; 188
   12b04:	98 e0       	ldi	r25, 0x08	; 8
   12b06:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   12b0a:	81 30       	cpi	r24, 0x01	; 1
   12b0c:	11 f4       	brne	.+4      	; 0x12b12 <PrintIdle+0xc4>
			      stPrintIdle=piLoadHeader;
   12b0e:	82 e0       	ldi	r24, 0x02	; 2
   12b10:	29 c7       	rjmp	.+3666   	; 0x13964 <PrintIdle+0xf16>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
   12b12:	83 e0       	ldi	r24, 0x03	; 3
   12b14:	80 93 06 02 	sts	0x0206, r24
			      iSend=0;
   12b18:	10 92 fe 01 	sts	0x01FE, r1
   12b1c:	10 92 fd 01 	sts	0x01FD, r1
				  iLoop=0;
   12b20:	10 92 fa 01 	sts	0x01FA, r1
   12b24:	10 92 f9 01 	sts	0x01F9, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
   12b28:	80 91 05 02 	lds	r24, 0x0205
   12b2c:	81 30       	cpi	r24, 0x01	; 1
   12b2e:	19 f4       	brne	.+6      	; 0x12b36 <PrintIdle+0xe8>
   12b30:	0e 94 16 43 	call	0x862c	; 0x862c <PrintDoubleHeight>
   12b34:	42 c7       	rjmp	.+3716   	; 0x139ba <PrintIdle+0xf6c>
				  else 
				  if (iHeader==2) PrintNormalHeight();
   12b36:	82 30       	cpi	r24, 0x02	; 2
   12b38:	09 f0       	breq	.+2      	; 0x12b3c <PrintIdle+0xee>
   12b3a:	3f c7       	rjmp	.+3710   	; 0x139ba <PrintIdle+0xf6c>
   12b3c:	0e 94 fc 42 	call	0x85f8	; 0x85f8 <PrintNormalHeight>
   12b40:	3c c7       	rjmp	.+3704   	; 0x139ba <PrintIdle+0xf6c>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
   12b42:	84 e0       	ldi	r24, 0x04	; 4
   12b44:	0f c7       	rjmp	.+3614   	; 0x13964 <PrintIdle+0xf16>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
   12b46:	80 91 fd 01 	lds	r24, 0x01FD
   12b4a:	90 91 fe 01 	lds	r25, 0x01FE
   12b4e:	88 97       	sbiw	r24, 0x28	; 40
   12b50:	68 f4       	brcc	.+26     	; 0x12b6c <PrintIdle+0x11e>
		      iLoop++;
   12b52:	80 91 f9 01 	lds	r24, 0x01F9
   12b56:	90 91 fa 01 	lds	r25, 0x01FA
   12b5a:	01 96       	adiw	r24, 0x01	; 1
   12b5c:	90 93 fa 01 	sts	0x01FA, r25
   12b60:	80 93 f9 01 	sts	0x01F9, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
   12b64:	10 92 b6 01 	sts	0x01B6, r1
				 stPrintIdle=piCheckPrintStatusHeader;
   12b68:	8b e0       	ldi	r24, 0x0B	; 11
   12b6a:	fc c6       	rjmp	.+3576   	; 0x13964 <PrintIdle+0xf16>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
   12b6c:	82 e0       	ldi	r24, 0x02	; 2
   12b6e:	8e c6       	rjmp	.+3356   	; 0x1388c <PrintIdle+0xe3e>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
   12b70:	80 91 b3 01 	lds	r24, 0x01B3
   12b74:	88 23       	and	r24, r24
   12b76:	09 f0       	breq	.+2      	; 0x12b7a <PrintIdle+0x12c>
   12b78:	ed c6       	rjmp	.+3546   	; 0x13954 <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   12b7a:	e0 91 fd 01 	lds	r30, 0x01FD
   12b7e:	f0 91 fe 01 	lds	r31, 0x01FE
   12b82:	e4 54       	subi	r30, 0x44	; 68
   12b84:	f7 4f       	sbci	r31, 0xF7	; 247
   12b86:	61 e0       	ldi	r22, 0x01	; 1
   12b88:	40 81       	ld	r20, Z
   12b8a:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   12b8e:	80 91 fd 01 	lds	r24, 0x01FD
   12b92:	90 91 fe 01 	lds	r25, 0x01FE
   12b96:	01 96       	adiw	r24, 0x01	; 1
   12b98:	90 93 fe 01 	sts	0x01FE, r25
   12b9c:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintHeader;
   12ba0:	83 e0       	ldi	r24, 0x03	; 3
   12ba2:	d6 c6       	rjmp	.+3500   	; 0x13950 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
   12ba4:	80 91 f8 01 	lds	r24, 0x01F8
   12ba8:	88 23       	and	r24, r24
   12baa:	21 f4       	brne	.+8      	; 0x12bb4 <PrintIdle+0x166>
   12bac:	80 91 7f 01 	lds	r24, 0x017F
   12bb0:	81 30       	cpi	r24, 0x01	; 1
   12bb2:	a9 f4       	brne	.+42     	; 0x12bde <PrintIdle+0x190>
		      IsReprintTicket=False;
   12bb4:	10 92 7f 01 	sts	0x017F, r1
		      CarriegeReturn(); 
   12bb8:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
   12bbc:	00 d0       	rcall	.+0      	; 0x12bbe <PrintIdle+0x170>
   12bbe:	00 d0       	rcall	.+0      	; 0x12bc0 <PrintIdle+0x172>
   12bc0:	8c eb       	ldi	r24, 0xBC	; 188
   12bc2:	98 e0       	ldi	r25, 0x08	; 8
   12bc4:	ad b7       	in	r26, 0x3d	; 61
   12bc6:	be b7       	in	r27, 0x3e	; 62
   12bc8:	12 96       	adiw	r26, 0x02	; 2
   12bca:	9c 93       	st	X, r25
   12bcc:	8e 93       	st	-X, r24
   12bce:	11 97       	sbiw	r26, 0x01	; 1
   12bd0:	85 e6       	ldi	r24, 0x65	; 101
   12bd2:	99 e0       	ldi	r25, 0x09	; 9
   12bd4:	14 96       	adiw	r26, 0x04	; 4
   12bd6:	9c 93       	st	X, r25
   12bd8:	8e 93       	st	-X, r24
   12bda:	13 97       	sbiw	r26, 0x03	; 3
   12bdc:	0c c0       	rjmp	.+24     	; 0x12bf6 <PrintIdle+0x1a8>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
   12bde:	00 d0       	rcall	.+0      	; 0x12be0 <PrintIdle+0x192>
   12be0:	00 d0       	rcall	.+0      	; 0x12be2 <PrintIdle+0x194>
   12be2:	8c eb       	ldi	r24, 0xBC	; 188
   12be4:	98 e0       	ldi	r25, 0x08	; 8
   12be6:	ed b7       	in	r30, 0x3d	; 61
   12be8:	fe b7       	in	r31, 0x3e	; 62
   12bea:	92 83       	std	Z+2, r25	; 0x02
   12bec:	81 83       	std	Z+1, r24	; 0x01
   12bee:	83 e6       	ldi	r24, 0x63	; 99
   12bf0:	99 e0       	ldi	r25, 0x09	; 9
   12bf2:	94 83       	std	Z+4, r25	; 0x04
   12bf4:	83 83       	std	Z+3, r24	; 0x03
   12bf6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   12bfa:	0f 90       	pop	r0
   12bfc:	0f 90       	pop	r0
   12bfe:	0f 90       	pop	r0
   12c00:	0f 90       	pop	r0
		      }
		  iSend=0;
   12c02:	10 92 fe 01 	sts	0x01FE, r1
   12c06:	10 92 fd 01 	sts	0x01FD, r1
		  iLoop=0;
   12c0a:	10 92 fa 01 	sts	0x01FA, r1
   12c0e:	10 92 f9 01 	sts	0x01F9, r1
		  LSend=strlen(strPrint);
   12c12:	ec eb       	ldi	r30, 0xBC	; 188
   12c14:	f8 e0       	ldi	r31, 0x08	; 8
   12c16:	01 90       	ld	r0, Z+
   12c18:	00 20       	and	r0, r0
   12c1a:	e9 f7       	brne	.-6      	; 0x12c16 <PrintIdle+0x1c8>
   12c1c:	31 97       	sbiw	r30, 0x01	; 1
   12c1e:	ec 5b       	subi	r30, 0xBC	; 188
   12c20:	f8 40       	sbci	r31, 0x08	; 8
   12c22:	f0 93 fc 01 	sts	0x01FC, r31
   12c26:	e0 93 fb 01 	sts	0x01FB, r30
          stPrintIdle=piPrintDuplicate; 
   12c2a:	85 e0       	ldi	r24, 0x05	; 5
   12c2c:	9b c6       	rjmp	.+3382   	; 0x13964 <PrintIdle+0xf16>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
   12c2e:	20 91 fd 01 	lds	r18, 0x01FD
   12c32:	30 91 fe 01 	lds	r19, 0x01FE
   12c36:	80 91 fb 01 	lds	r24, 0x01FB
   12c3a:	90 91 fc 01 	lds	r25, 0x01FC
   12c3e:	28 17       	cp	r18, r24
   12c40:	39 07       	cpc	r19, r25
   12c42:	68 f4       	brcc	.+26     	; 0x12c5e <PrintIdle+0x210>
		      iLoop++;
   12c44:	80 91 f9 01 	lds	r24, 0x01F9
   12c48:	90 91 fa 01 	lds	r25, 0x01FA
   12c4c:	01 96       	adiw	r24, 0x01	; 1
   12c4e:	90 93 fa 01 	sts	0x01FA, r25
   12c52:	80 93 f9 01 	sts	0x01F9, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
   12c56:	10 92 b6 01 	sts	0x01B6, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
   12c5a:	86 e0       	ldi	r24, 0x06	; 6
   12c5c:	83 c6       	rjmp	.+3334   	; 0x13964 <PrintIdle+0xf16>
				 }
			  }
          else {
		     iSend=0;
   12c5e:	10 92 fe 01 	sts	0x01FE, r1
   12c62:	10 92 fd 01 	sts	0x01FD, r1
		     stPrintIdle=piInitMessage;
   12c66:	87 e0       	ldi	r24, 0x07	; 7
   12c68:	7d c6       	rjmp	.+3322   	; 0x13964 <PrintIdle+0xf16>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
   12c6a:	80 91 b3 01 	lds	r24, 0x01B3
   12c6e:	88 23       	and	r24, r24
   12c70:	09 f0       	breq	.+2      	; 0x12c74 <PrintIdle+0x226>
   12c72:	70 c6       	rjmp	.+3296   	; 0x13954 <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   12c74:	e0 91 fd 01 	lds	r30, 0x01FD
   12c78:	f0 91 fe 01 	lds	r31, 0x01FE
   12c7c:	e4 54       	subi	r30, 0x44	; 68
   12c7e:	f7 4f       	sbci	r31, 0xF7	; 247
   12c80:	61 e0       	ldi	r22, 0x01	; 1
   12c82:	40 81       	ld	r20, Z
   12c84:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
   12c88:	84 ec       	ldi	r24, 0xC4	; 196
   12c8a:	99 e0       	ldi	r25, 0x09	; 9
   12c8c:	01 97       	sbiw	r24, 0x01	; 1
   12c8e:	f1 f7       	brne	.-4      	; 0x12c8c <PrintIdle+0x23e>
			  _delay_ms(10);
		      iSend++;
   12c90:	80 91 fd 01 	lds	r24, 0x01FD
   12c94:	90 91 fe 01 	lds	r25, 0x01FE
   12c98:	01 96       	adiw	r24, 0x01	; 1
   12c9a:	90 93 fe 01 	sts	0x01FE, r25
   12c9e:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintDuplicate;
   12ca2:	85 e0       	ldi	r24, 0x05	; 5
   12ca4:	55 c6       	rjmp	.+3242   	; 0x13950 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
   12ca6:	10 92 fe 01 	sts	0x01FE, r1
   12caa:	10 92 fd 01 	sts	0x01FD, r1
   12cae:	10 92 fa 01 	sts	0x01FA, r1
   12cb2:	10 92 f9 01 	sts	0x01F9, r1
		  iMessage=0;
   12cb6:	10 92 01 02 	sts	0x0201, r1
		  switch(MOPType){
   12cba:	80 91 b8 01 	lds	r24, 0x01B8
   12cbe:	83 30       	cpi	r24, 0x03	; 3
   12cc0:	81 f0       	breq	.+32     	; 0x12ce2 <PrintIdle+0x294>
   12cc2:	84 30       	cpi	r24, 0x04	; 4
   12cc4:	28 f4       	brcc	.+10     	; 0x12cd0 <PrintIdle+0x282>
   12cc6:	81 30       	cpi	r24, 0x01	; 1
   12cc8:	61 f0       	breq	.+24     	; 0x12ce2 <PrintIdle+0x294>
   12cca:	82 30       	cpi	r24, 0x02	; 2
   12ccc:	40 f4       	brcc	.+16     	; 0x12cde <PrintIdle+0x290>
   12cce:	10 c0       	rjmp	.+32     	; 0x12cf0 <PrintIdle+0x2a2>
   12cd0:	88 30       	cpi	r24, 0x08	; 8
   12cd2:	49 f0       	breq	.+18     	; 0x12ce6 <PrintIdle+0x298>
   12cd4:	89 30       	cpi	r24, 0x09	; 9
   12cd6:	61 f0       	breq	.+24     	; 0x12cf0 <PrintIdle+0x2a2>
   12cd8:	87 30       	cpi	r24, 0x07	; 7
   12cda:	51 f4       	brne	.+20     	; 0x12cf0 <PrintIdle+0x2a2>
   12cdc:	02 c0       	rjmp	.+4      	; 0x12ce2 <PrintIdle+0x294>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
   12cde:	8a e0       	ldi	r24, 0x0A	; 10
   12ce0:	03 c0       	rjmp	.+6      	; 0x12ce8 <PrintIdle+0x29a>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
   12ce2:	84 e1       	ldi	r24, 0x14	; 20
   12ce4:	01 c0       	rjmp	.+2      	; 0x12ce8 <PrintIdle+0x29a>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
   12ce6:	8c e0       	ldi	r24, 0x0C	; 12
   12ce8:	80 93 00 02 	sts	0x0200, r24
			   PrintCopy=2;
   12cec:	82 e0       	ldi	r24, 0x02	; 2
   12cee:	04 c0       	rjmp	.+8      	; 0x12cf8 <PrintIdle+0x2aa>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
   12cf0:	8a e0       	ldi	r24, 0x0A	; 10
   12cf2:	80 93 00 02 	sts	0x0200, r24
			   PrintCopy=1;
   12cf6:	81 e0       	ldi	r24, 0x01	; 1
   12cf8:	80 93 f7 01 	sts	0x01F7, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
   12cfc:	80 91 e7 02 	lds	r24, 0x02E7
   12d00:	88 23       	and	r24, r24
   12d02:	49 f0       	breq	.+18     	; 0x12d16 <PrintIdle+0x2c8>
   12d04:	87 ee       	ldi	r24, 0xE7	; 231
   12d06:	92 e0       	ldi	r25, 0x02	; 2
   12d08:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   12d0c:	88 23       	and	r24, r24
   12d0e:	19 f4       	brne	.+6      	; 0x12d16 <PrintIdle+0x2c8>
		       MessageLine=33;
   12d10:	81 e2       	ldi	r24, 0x21	; 33
   12d12:	80 93 00 02 	sts	0x0200, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
   12d16:	88 e0       	ldi	r24, 0x08	; 8
   12d18:	25 c6       	rjmp	.+3146   	; 0x13964 <PrintIdle+0xf16>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
   12d1a:	80 91 f8 01 	lds	r24, 0x01F8
   12d1e:	88 23       	and	r24, r24
   12d20:	09 f0       	breq	.+2      	; 0x12d24 <PrintIdle+0x2d6>
   12d22:	c9 c4       	rjmp	.+2450   	; 0x136b6 <PrintIdle+0xc68>

		      FormatDate(DATE_LONG_YEAR,strDate);
   12d24:	6e e6       	ldi	r22, 0x6E	; 110
   12d26:	77 e0       	ldi	r23, 0x07	; 7
   12d28:	0e 94 ee 22 	call	0x45dc	; 0x45dc <FormatDate>
              RemZeroLead(strIslandID);
   12d2c:	87 ef       	ldi	r24, 0xF7	; 247
   12d2e:	98 e0       	ldi	r25, 0x08	; 8
   12d30:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
			  RemZeroLead(strFIP_ID);
   12d34:	89 eb       	ldi	r24, 0xB9	; 185
   12d36:	97 e0       	ldi	r25, 0x07	; 7
   12d38:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		      RemZeroLead(strPrice);              
   12d3c:	8e e9       	ldi	r24, 0x9E	; 158
   12d3e:	95 e0       	ldi	r25, 0x05	; 5
   12d40:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
              if (IFType==IT_SLAVE)
   12d44:	80 91 00 01 	lds	r24, 0x0100
   12d48:	81 30       	cpi	r24, 0x01	; 1
   12d4a:	21 f4       	brne	.+8      	; 0x12d54 <PrintIdle+0x306>
			      RemZeroLead(strVolume);
   12d4c:	85 e7       	ldi	r24, 0x75	; 117
   12d4e:	93 e0       	ldi	r25, 0x03	; 3
   12d50:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
              RemZeroLead(strAmount);
   12d54:	83 eb       	ldi	r24, 0xB3	; 179
   12d56:	9b e0       	ldi	r25, 0x0B	; 11
   12d58:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>

			  RemDecimal(strPrice);
   12d5c:	8e e9       	ldi	r24, 0x9E	; 158
   12d5e:	95 e0       	ldi	r25, 0x05	; 5
   12d60:	0e 94 37 22 	call	0x446e	; 0x446e <RemDecimal>
			  RemDecimal(strAmount);
   12d64:	83 eb       	ldi	r24, 0xB3	; 179
   12d66:	9b e0       	ldi	r25, 0x0B	; 11
   12d68:	0e 94 37 22 	call	0x446e	; 0x446e <RemDecimal>
	  
			  FormatCurrency(strPrice);
   12d6c:	8e e9       	ldi	r24, 0x9E	; 158
   12d6e:	95 e0       	ldi	r25, 0x05	; 5
   12d70:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
			  FormatCurrency(strAmount);
   12d74:	83 eb       	ldi	r24, 0xB3	; 179
   12d76:	9b e0       	ldi	r25, 0x0B	; 11
   12d78:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
              if (IFType==IT_SLAVE){
   12d7c:	80 91 00 01 	lds	r24, 0x0100
   12d80:	81 30       	cpi	r24, 0x01	; 1
   12d82:	09 f0       	breq	.+2      	; 0x12d86 <PrintIdle+0x338>
   12d84:	98 c4       	rjmp	.+2352   	; 0x136b6 <PrintIdle+0xc68>
		          RemSpaceLag(strCardID);
   12d86:	89 e8       	ldi	r24, 0x89	; 137
   12d88:	9b e0       	ldi	r25, 0x0B	; 11
   12d8a:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
   12d8e:	84 e2       	ldi	r24, 0x24	; 36
   12d90:	93 e0       	ldi	r25, 0x03	; 3
   12d92:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
   12d96:	8d e7       	ldi	r24, 0x7D	; 125
   12d98:	95 e0       	ldi	r25, 0x05	; 5
   12d9a:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
   12d9e:	84 ec       	ldi	r24, 0xC4	; 196
   12da0:	92 e0       	ldi	r25, 0x02	; 2
   12da2:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
   12da6:	8a e0       	ldi	r24, 0x0A	; 10
   12da8:	9c e0       	ldi	r25, 0x0C	; 12
   12daa:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
   12dae:	8d ec       	ldi	r24, 0xCD	; 205
   12db0:	93 e0       	ldi	r25, 0x03	; 3
   12db2:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
   12db6:	8a e9       	ldi	r24, 0x9A	; 154
   12db8:	93 e0       	ldi	r25, 0x03	; 3
   12dba:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
   12dbe:	8d ee       	ldi	r24, 0xED	; 237
   12dc0:	9b e0       	ldi	r25, 0x0B	; 11
   12dc2:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
   12dc6:	8e e7       	ldi	r24, 0x7E	; 126
   12dc8:	93 e0       	ldi	r25, 0x03	; 3
   12dca:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
   12dce:	8d ee       	ldi	r24, 0xED	; 237
   12dd0:	9b e0       	ldi	r25, 0x0B	; 11
   12dd2:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
   12dd6:	8e e7       	ldi	r24, 0x7E	; 126
   12dd8:	93 e0       	ldi	r25, 0x03	; 3
   12dda:	0e 94 2f 31 	call	0x625e	; 0x625e <FormatCurrency>
   12dde:	6b c4       	rjmp	.+2262   	; 0x136b6 <PrintIdle+0xc68>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
   12de0:	80 91 01 02 	lds	r24, 0x0201
   12de4:	e8 2f       	mov	r30, r24
   12de6:	f0 e0       	ldi	r31, 0x00	; 0
   12de8:	e5 32       	cpi	r30, 0x25	; 37
   12dea:	f1 05       	cpc	r31, r1
   12dec:	08 f0       	brcs	.+2      	; 0x12df0 <PrintIdle+0x3a2>
   12dee:	26 c4       	rjmp	.+2124   	; 0x1363c <PrintIdle+0xbee>
   12df0:	e8 50       	subi	r30, 0x08	; 8
   12df2:	ff 4f       	sbci	r31, 0xFF	; 255
   12df4:	ee 0f       	add	r30, r30
   12df6:	ff 1f       	adc	r31, r31
   12df8:	05 90       	lpm	r0, Z+
   12dfa:	f4 91       	lpm	r31, Z+
   12dfc:	e0 2d       	mov	r30, r0
   12dfe:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
   12e00:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
   12e04:	8d b7       	in	r24, 0x3d	; 61
   12e06:	9e b7       	in	r25, 0x3e	; 62
   12e08:	08 97       	sbiw	r24, 0x08	; 8
   12e0a:	0f b6       	in	r0, 0x3f	; 63
   12e0c:	f8 94       	cli
   12e0e:	9e bf       	out	0x3e, r25	; 62
   12e10:	0f be       	out	0x3f, r0	; 63
   12e12:	8d bf       	out	0x3d, r24	; 61
   12e14:	ed b7       	in	r30, 0x3d	; 61
   12e16:	fe b7       	in	r31, 0x3e	; 62
   12e18:	31 96       	adiw	r30, 0x01	; 1
   12e1a:	8c eb       	ldi	r24, 0xBC	; 188
   12e1c:	98 e0       	ldi	r25, 0x08	; 8
   12e1e:	ad b7       	in	r26, 0x3d	; 61
   12e20:	be b7       	in	r27, 0x3e	; 62
   12e22:	12 96       	adiw	r26, 0x02	; 2
   12e24:	9c 93       	st	X, r25
   12e26:	8e 93       	st	-X, r24
   12e28:	11 97       	sbiw	r26, 0x01	; 1
   12e2a:	84 e4       	ldi	r24, 0x44	; 68
   12e2c:	99 e0       	ldi	r25, 0x09	; 9
   12e2e:	93 83       	std	Z+3, r25	; 0x03
   12e30:	82 83       	std	Z+2, r24	; 0x02
   12e32:	88 e6       	ldi	r24, 0x68	; 104
   12e34:	9c e0       	ldi	r25, 0x0C	; 12
   12e36:	95 83       	std	Z+5, r25	; 0x05
   12e38:	84 83       	std	Z+4, r24	; 0x04
   12e3a:	87 e8       	ldi	r24, 0x87	; 135
   12e3c:	9c e0       	ldi	r25, 0x0C	; 12
   12e3e:	1f c0       	rjmp	.+62     	; 0x12e7e <PrintIdle+0x430>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
   12e40:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
   12e44:	8d b7       	in	r24, 0x3d	; 61
   12e46:	9e b7       	in	r25, 0x3e	; 62
   12e48:	08 97       	sbiw	r24, 0x08	; 8
   12e4a:	0f b6       	in	r0, 0x3f	; 63
   12e4c:	f8 94       	cli
   12e4e:	9e bf       	out	0x3e, r25	; 62
   12e50:	0f be       	out	0x3f, r0	; 63
   12e52:	8d bf       	out	0x3d, r24	; 61
   12e54:	ed b7       	in	r30, 0x3d	; 61
   12e56:	fe b7       	in	r31, 0x3e	; 62
   12e58:	31 96       	adiw	r30, 0x01	; 1
   12e5a:	8c eb       	ldi	r24, 0xBC	; 188
   12e5c:	98 e0       	ldi	r25, 0x08	; 8
   12e5e:	ad b7       	in	r26, 0x3d	; 61
   12e60:	be b7       	in	r27, 0x3e	; 62
   12e62:	12 96       	adiw	r26, 0x02	; 2
   12e64:	9c 93       	st	X, r25
   12e66:	8e 93       	st	-X, r24
   12e68:	11 97       	sbiw	r26, 0x01	; 1
   12e6a:	80 e3       	ldi	r24, 0x30	; 48
   12e6c:	99 e0       	ldi	r25, 0x09	; 9
   12e6e:	93 83       	std	Z+3, r25	; 0x03
   12e70:	82 83       	std	Z+2, r24	; 0x02
   12e72:	8e e6       	ldi	r24, 0x6E	; 110
   12e74:	97 e0       	ldi	r25, 0x07	; 7
   12e76:	95 83       	std	Z+5, r25	; 0x05
   12e78:	84 83       	std	Z+4, r24	; 0x04
   12e7a:	8d e4       	ldi	r24, 0x4D	; 77
   12e7c:	93 e0       	ldi	r25, 0x03	; 3
   12e7e:	97 83       	std	Z+7, r25	; 0x07
   12e80:	86 83       	std	Z+6, r24	; 0x06
   12e82:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   12e86:	ed b7       	in	r30, 0x3d	; 61
   12e88:	fe b7       	in	r31, 0x3e	; 62
   12e8a:	38 96       	adiw	r30, 0x08	; 8
   12e8c:	b9 c3       	rjmp	.+1906   	; 0x13600 <PrintIdle+0xbb2>
		       break;
		  case 2:
		       CarriegeReturn();
   12e8e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
   12e92:	00 d0       	rcall	.+0      	; 0x12e94 <PrintIdle+0x446>
   12e94:	00 d0       	rcall	.+0      	; 0x12e96 <PrintIdle+0x448>
   12e96:	8c eb       	ldi	r24, 0xBC	; 188
   12e98:	98 e0       	ldi	r25, 0x08	; 8
   12e9a:	ad b7       	in	r26, 0x3d	; 61
   12e9c:	be b7       	in	r27, 0x3e	; 62
   12e9e:	12 96       	adiw	r26, 0x02	; 2
   12ea0:	9c 93       	st	X, r25
   12ea2:	8e 93       	st	-X, r24
   12ea4:	11 97       	sbiw	r26, 0x01	; 1
   12ea6:	8d e0       	ldi	r24, 0x0D	; 13
   12ea8:	99 e0       	ldi	r25, 0x09	; 9
   12eaa:	be c3       	rjmp	.+1916   	; 0x13628 <PrintIdle+0xbda>
		       break;
		  case 3:
		       CarriegeReturn();
   12eac:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
   12eb0:	ed b7       	in	r30, 0x3d	; 61
   12eb2:	fe b7       	in	r31, 0x3e	; 62
   12eb4:	38 97       	sbiw	r30, 0x08	; 8
   12eb6:	0f b6       	in	r0, 0x3f	; 63
   12eb8:	f8 94       	cli
   12eba:	fe bf       	out	0x3e, r31	; 62
   12ebc:	0f be       	out	0x3f, r0	; 63
   12ebe:	ed bf       	out	0x3d, r30	; 61
   12ec0:	31 96       	adiw	r30, 0x01	; 1
   12ec2:	8c eb       	ldi	r24, 0xBC	; 188
   12ec4:	98 e0       	ldi	r25, 0x08	; 8
   12ec6:	ad b7       	in	r26, 0x3d	; 61
   12ec8:	be b7       	in	r27, 0x3e	; 62
   12eca:	12 96       	adiw	r26, 0x02	; 2
   12ecc:	9c 93       	st	X, r25
   12ece:	8e 93       	st	-X, r24
   12ed0:	11 97       	sbiw	r26, 0x01	; 1
   12ed2:	81 ef       	ldi	r24, 0xF1	; 241
   12ed4:	98 e0       	ldi	r25, 0x08	; 8
   12ed6:	93 83       	std	Z+3, r25	; 0x03
   12ed8:	82 83       	std	Z+2, r24	; 0x02
   12eda:	87 ef       	ldi	r24, 0xF7	; 247
   12edc:	98 e0       	ldi	r25, 0x08	; 8
   12ede:	95 83       	std	Z+5, r25	; 0x05
   12ee0:	84 83       	std	Z+4, r24	; 0x04
   12ee2:	89 eb       	ldi	r24, 0xB9	; 185
   12ee4:	97 e0       	ldi	r25, 0x07	; 7
   12ee6:	cb cf       	rjmp	.-106    	; 0x12e7e <PrintIdle+0x430>
		       break;
		  case 4:
		       CarriegeReturn();
   12ee8:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
   12eec:	00 d0       	rcall	.+0      	; 0x12eee <PrintIdle+0x4a0>
   12eee:	00 d0       	rcall	.+0      	; 0x12ef0 <PrintIdle+0x4a2>
   12ef0:	00 d0       	rcall	.+0      	; 0x12ef2 <PrintIdle+0x4a4>
   12ef2:	ed b7       	in	r30, 0x3d	; 61
   12ef4:	fe b7       	in	r31, 0x3e	; 62
   12ef6:	31 96       	adiw	r30, 0x01	; 1
   12ef8:	8c eb       	ldi	r24, 0xBC	; 188
   12efa:	98 e0       	ldi	r25, 0x08	; 8
   12efc:	ad b7       	in	r26, 0x3d	; 61
   12efe:	be b7       	in	r27, 0x3e	; 62
   12f00:	12 96       	adiw	r26, 0x02	; 2
   12f02:	9c 93       	st	X, r25
   12f04:	8e 93       	st	-X, r24
   12f06:	11 97       	sbiw	r26, 0x01	; 1
   12f08:	8a ed       	ldi	r24, 0xDA	; 218
   12f0a:	98 e0       	ldi	r25, 0x08	; 8
   12f0c:	93 83       	std	Z+3, r25	; 0x03
   12f0e:	82 83       	std	Z+2, r24	; 0x02
   12f10:	8c e0       	ldi	r24, 0x0C	; 12
   12f12:	98 e0       	ldi	r25, 0x08	; 8
   12f14:	6e c3       	rjmp	.+1756   	; 0x135f2 <PrintIdle+0xba4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12f16:	e1 99       	sbic	0x1c, 1	; 28
   12f18:	fe cf       	rjmp	.-4      	; 0x12f16 <PrintIdle+0x4c8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12f1a:	81 ec       	ldi	r24, 0xC1	; 193
   12f1c:	93 e0       	ldi	r25, 0x03	; 3
   12f1e:	9f bb       	out	0x1f, r25	; 31
   12f20:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12f22:	e0 9a       	sbi	0x1c, 0	; 28
   12f24:	8d b3       	in	r24, 0x1d	; 29
   12f26:	0c eb       	ldi	r16, 0xBC	; 188
   12f28:	18 e0       	ldi	r17, 0x08	; 8
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
   12f2a:	81 30       	cpi	r24, 0x01	; 1
   12f2c:	a9 f4       	brne	.+42     	; 0x12f58 <PrintIdle+0x50a>
			   	   CarriegeReturn();
   12f2e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
   12f32:	00 d0       	rcall	.+0      	; 0x12f34 <PrintIdle+0x4e6>
   12f34:	00 d0       	rcall	.+0      	; 0x12f36 <PrintIdle+0x4e8>
   12f36:	00 d0       	rcall	.+0      	; 0x12f38 <PrintIdle+0x4ea>
   12f38:	ed b7       	in	r30, 0x3d	; 61
   12f3a:	fe b7       	in	r31, 0x3e	; 62
   12f3c:	31 96       	adiw	r30, 0x01	; 1
   12f3e:	ad b7       	in	r26, 0x3d	; 61
   12f40:	be b7       	in	r27, 0x3e	; 62
   12f42:	12 96       	adiw	r26, 0x02	; 2
   12f44:	1c 93       	st	X, r17
   12f46:	0e 93       	st	-X, r16
   12f48:	11 97       	sbiw	r26, 0x01	; 1
   12f4a:	80 ec       	ldi	r24, 0xC0	; 192
   12f4c:	98 e0       	ldi	r25, 0x08	; 8
   12f4e:	93 83       	std	Z+3, r25	; 0x03
   12f50:	82 83       	std	Z+2, r24	; 0x02
   12f52:	8e e9       	ldi	r24, 0x9E	; 158
   12f54:	95 e0       	ldi	r25, 0x05	; 5
   12f56:	4d c3       	rjmp	.+1690   	; 0x135f2 <PrintIdle+0xba4>
			   }else sprintf_P(strPrint,PSTR(""));
   12f58:	00 d0       	rcall	.+0      	; 0x12f5a <PrintIdle+0x50c>
   12f5a:	00 d0       	rcall	.+0      	; 0x12f5c <PrintIdle+0x50e>
   12f5c:	ad b7       	in	r26, 0x3d	; 61
   12f5e:	be b7       	in	r27, 0x3e	; 62
   12f60:	12 96       	adiw	r26, 0x02	; 2
   12f62:	1c 93       	st	X, r17
   12f64:	0e 93       	st	-X, r16
   12f66:	11 97       	sbiw	r26, 0x01	; 1
   12f68:	8f eb       	ldi	r24, 0xBF	; 191
   12f6a:	98 e0       	ldi	r25, 0x08	; 8
   12f6c:	5d c3       	rjmp	.+1722   	; 0x13628 <PrintIdle+0xbda>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
   12f6e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
   12f72:	00 d0       	rcall	.+0      	; 0x12f74 <PrintIdle+0x526>
   12f74:	00 d0       	rcall	.+0      	; 0x12f76 <PrintIdle+0x528>
   12f76:	00 d0       	rcall	.+0      	; 0x12f78 <PrintIdle+0x52a>
   12f78:	ed b7       	in	r30, 0x3d	; 61
   12f7a:	fe b7       	in	r31, 0x3e	; 62
   12f7c:	31 96       	adiw	r30, 0x01	; 1
   12f7e:	8c eb       	ldi	r24, 0xBC	; 188
   12f80:	98 e0       	ldi	r25, 0x08	; 8
   12f82:	ad b7       	in	r26, 0x3d	; 61
   12f84:	be b7       	in	r27, 0x3e	; 62
   12f86:	12 96       	adiw	r26, 0x02	; 2
   12f88:	9c 93       	st	X, r25
   12f8a:	8e 93       	st	-X, r24
   12f8c:	11 97       	sbiw	r26, 0x01	; 1
   12f8e:	86 ea       	ldi	r24, 0xA6	; 166
   12f90:	98 e0       	ldi	r25, 0x08	; 8
   12f92:	93 83       	std	Z+3, r25	; 0x03
   12f94:	82 83       	std	Z+2, r24	; 0x02
   12f96:	85 e7       	ldi	r24, 0x75	; 117
   12f98:	93 e0       	ldi	r25, 0x03	; 3
   12f9a:	2b c3       	rjmp	.+1622   	; 0x135f2 <PrintIdle+0xba4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12f9c:	e1 99       	sbic	0x1c, 1	; 28
   12f9e:	fe cf       	rjmp	.-4      	; 0x12f9c <PrintIdle+0x54e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12fa0:	81 ec       	ldi	r24, 0xC1	; 193
   12fa2:	93 e0       	ldi	r25, 0x03	; 3
   12fa4:	9f bb       	out	0x1f, r25	; 31
   12fa6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12fa8:	e0 9a       	sbi	0x1c, 0	; 28
   12faa:	8d b3       	in	r24, 0x1d	; 29
   12fac:	0c eb       	ldi	r16, 0xBC	; 188
   12fae:	18 e0       	ldi	r17, 0x08	; 8
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
   12fb0:	81 30       	cpi	r24, 0x01	; 1
   12fb2:	a9 f4       	brne	.+42     	; 0x12fde <PrintIdle+0x590>
			   	   CarriegeReturn();
   12fb4:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
   12fb8:	00 d0       	rcall	.+0      	; 0x12fba <PrintIdle+0x56c>
   12fba:	00 d0       	rcall	.+0      	; 0x12fbc <PrintIdle+0x56e>
   12fbc:	00 d0       	rcall	.+0      	; 0x12fbe <PrintIdle+0x570>
   12fbe:	ed b7       	in	r30, 0x3d	; 61
   12fc0:	fe b7       	in	r31, 0x3e	; 62
   12fc2:	31 96       	adiw	r30, 0x01	; 1
   12fc4:	ad b7       	in	r26, 0x3d	; 61
   12fc6:	be b7       	in	r27, 0x3e	; 62
   12fc8:	12 96       	adiw	r26, 0x02	; 2
   12fca:	1c 93       	st	X, r17
   12fcc:	0e 93       	st	-X, r16
   12fce:	11 97       	sbiw	r26, 0x01	; 1
   12fd0:	8c e8       	ldi	r24, 0x8C	; 140
   12fd2:	98 e0       	ldi	r25, 0x08	; 8
   12fd4:	93 83       	std	Z+3, r25	; 0x03
   12fd6:	82 83       	std	Z+2, r24	; 0x02
   12fd8:	83 eb       	ldi	r24, 0xB3	; 179
   12fda:	9b e0       	ldi	r25, 0x0B	; 11
   12fdc:	0a c3       	rjmp	.+1556   	; 0x135f2 <PrintIdle+0xba4>
			   }else sprintf_P(strPrint,PSTR(""));
   12fde:	00 d0       	rcall	.+0      	; 0x12fe0 <PrintIdle+0x592>
   12fe0:	00 d0       	rcall	.+0      	; 0x12fe2 <PrintIdle+0x594>
   12fe2:	ad b7       	in	r26, 0x3d	; 61
   12fe4:	be b7       	in	r27, 0x3e	; 62
   12fe6:	12 96       	adiw	r26, 0x02	; 2
   12fe8:	1c 93       	st	X, r17
   12fea:	0e 93       	st	-X, r16
   12fec:	11 97       	sbiw	r26, 0x01	; 1
   12fee:	8b e8       	ldi	r24, 0x8B	; 139
   12ff0:	98 e0       	ldi	r25, 0x08	; 8
   12ff2:	1a c3       	rjmp	.+1588   	; 0x13628 <PrintIdle+0xbda>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
   12ff4:	0a ef       	ldi	r16, 0xFA	; 250
   12ff6:	18 e0       	ldi	r17, 0x08	; 8
   12ff8:	80 91 fa 08 	lds	r24, 0x08FA
   12ffc:	88 23       	and	r24, r24
   12ffe:	09 f4       	brne	.+2      	; 0x13002 <PrintIdle+0x5b4>
   13000:	18 c2       	rjmp	.+1072   	; 0x13432 <PrintIdle+0x9e4>
   13002:	c8 01       	movw	r24, r16
   13004:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   13008:	88 23       	and	r24, r24
   1300a:	09 f0       	breq	.+2      	; 0x1300e <PrintIdle+0x5c0>
   1300c:	12 c2       	rjmp	.+1060   	; 0x13432 <PrintIdle+0x9e4>
			       CarriegeReturn();
   1300e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
   13012:	00 d0       	rcall	.+0      	; 0x13014 <PrintIdle+0x5c6>
   13014:	00 d0       	rcall	.+0      	; 0x13016 <PrintIdle+0x5c8>
   13016:	00 d0       	rcall	.+0      	; 0x13018 <PrintIdle+0x5ca>
   13018:	ed b7       	in	r30, 0x3d	; 61
   1301a:	fe b7       	in	r31, 0x3e	; 62
   1301c:	31 96       	adiw	r30, 0x01	; 1
   1301e:	8c eb       	ldi	r24, 0xBC	; 188
   13020:	98 e0       	ldi	r25, 0x08	; 8
   13022:	ad b7       	in	r26, 0x3d	; 61
   13024:	be b7       	in	r27, 0x3e	; 62
   13026:	12 96       	adiw	r26, 0x02	; 2
   13028:	9c 93       	st	X, r25
   1302a:	8e 93       	st	-X, r24
   1302c:	11 97       	sbiw	r26, 0x01	; 1
   1302e:	84 e7       	ldi	r24, 0x74	; 116
   13030:	98 e0       	ldi	r25, 0x08	; 8
   13032:	1f c0       	rjmp	.+62     	; 0x13072 <PrintIdle+0x624>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
   13034:	03 ec       	ldi	r16, 0xC3	; 195
   13036:	13 e0       	ldi	r17, 0x03	; 3
   13038:	80 91 c3 03 	lds	r24, 0x03C3
   1303c:	88 23       	and	r24, r24
   1303e:	09 f4       	brne	.+2      	; 0x13042 <PrintIdle+0x5f4>
   13040:	f8 c1       	rjmp	.+1008   	; 0x13432 <PrintIdle+0x9e4>
   13042:	c8 01       	movw	r24, r16
   13044:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   13048:	88 23       	and	r24, r24
   1304a:	09 f0       	breq	.+2      	; 0x1304e <PrintIdle+0x600>
   1304c:	f2 c1       	rjmp	.+996    	; 0x13432 <PrintIdle+0x9e4>
			       CarriegeReturn();
   1304e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
   13052:	00 d0       	rcall	.+0      	; 0x13054 <PrintIdle+0x606>
   13054:	00 d0       	rcall	.+0      	; 0x13056 <PrintIdle+0x608>
   13056:	00 d0       	rcall	.+0      	; 0x13058 <PrintIdle+0x60a>
   13058:	ed b7       	in	r30, 0x3d	; 61
   1305a:	fe b7       	in	r31, 0x3e	; 62
   1305c:	31 96       	adiw	r30, 0x01	; 1
   1305e:	8c eb       	ldi	r24, 0xBC	; 188
   13060:	98 e0       	ldi	r25, 0x08	; 8
   13062:	ad b7       	in	r26, 0x3d	; 61
   13064:	be b7       	in	r27, 0x3e	; 62
   13066:	12 96       	adiw	r26, 0x02	; 2
   13068:	9c 93       	st	X, r25
   1306a:	8e 93       	st	-X, r24
   1306c:	11 97       	sbiw	r26, 0x01	; 1
   1306e:	8d e5       	ldi	r24, 0x5D	; 93
   13070:	98 e0       	ldi	r25, 0x08	; 8
   13072:	93 83       	std	Z+3, r25	; 0x03
   13074:	82 83       	std	Z+2, r24	; 0x02
   13076:	15 83       	std	Z+5, r17	; 0x05
   13078:	04 83       	std	Z+4, r16	; 0x04
   1307a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				   ClearMem(strOdometer);
   1307e:	ed b7       	in	r30, 0x3d	; 61
   13080:	fe b7       	in	r31, 0x3e	; 62
   13082:	36 96       	adiw	r30, 0x06	; 6
   13084:	0f b6       	in	r0, 0x3f	; 63
   13086:	f8 94       	cli
   13088:	fe bf       	out	0x3e, r31	; 62
   1308a:	0f be       	out	0x3f, r0	; 63
   1308c:	ed bf       	out	0x3d, r30	; 61
   1308e:	c8 01       	movw	r24, r16
   13090:	0e 94 80 a4 	call	0x14900	; 0x14900 <ClearMem>
   13094:	d3 c2       	rjmp	.+1446   	; 0x1363c <PrintIdle+0xbee>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
   13096:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
   1309a:	00 d0       	rcall	.+0      	; 0x1309c <PrintIdle+0x64e>
   1309c:	00 d0       	rcall	.+0      	; 0x1309e <PrintIdle+0x650>
   1309e:	8c eb       	ldi	r24, 0xBC	; 188
   130a0:	98 e0       	ldi	r25, 0x08	; 8
   130a2:	ad b7       	in	r26, 0x3d	; 61
   130a4:	be b7       	in	r27, 0x3e	; 62
   130a6:	12 96       	adiw	r26, 0x02	; 2
   130a8:	9c 93       	st	X, r25
   130aa:	8e 93       	st	-X, r24
   130ac:	11 97       	sbiw	r26, 0x01	; 1
   130ae:	8a e3       	ldi	r24, 0x3A	; 58
   130b0:	98 e0       	ldi	r25, 0x08	; 8
   130b2:	ba c2       	rjmp	.+1396   	; 0x13628 <PrintIdle+0xbda>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
   130b4:	80 91 b8 01 	lds	r24, 0x01B8
   130b8:	81 30       	cpi	r24, 0x01	; 1
   130ba:	21 f0       	breq	.+8      	; 0x130c4 <PrintIdle+0x676>
   130bc:	83 30       	cpi	r24, 0x03	; 3
   130be:	11 f0       	breq	.+4      	; 0x130c4 <PrintIdle+0x676>
   130c0:	86 30       	cpi	r24, 0x06	; 6
   130c2:	b9 f4       	brne	.+46     	; 0x130f2 <PrintIdle+0x6a4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
   130c4:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
   130c8:	00 d0       	rcall	.+0      	; 0x130ca <PrintIdle+0x67c>
   130ca:	00 d0       	rcall	.+0      	; 0x130cc <PrintIdle+0x67e>
   130cc:	00 d0       	rcall	.+0      	; 0x130ce <PrintIdle+0x680>
   130ce:	ed b7       	in	r30, 0x3d	; 61
   130d0:	fe b7       	in	r31, 0x3e	; 62
   130d2:	31 96       	adiw	r30, 0x01	; 1
   130d4:	8c eb       	ldi	r24, 0xBC	; 188
   130d6:	98 e0       	ldi	r25, 0x08	; 8
   130d8:	ad b7       	in	r26, 0x3d	; 61
   130da:	be b7       	in	r27, 0x3e	; 62
   130dc:	12 96       	adiw	r26, 0x02	; 2
   130de:	9c 93       	st	X, r25
   130e0:	8e 93       	st	-X, r24
   130e2:	11 97       	sbiw	r26, 0x01	; 1
   130e4:	88 e2       	ldi	r24, 0x28	; 40
   130e6:	98 e0       	ldi	r25, 0x08	; 8
   130e8:	93 83       	std	Z+3, r25	; 0x03
   130ea:	82 83       	std	Z+2, r24	; 0x02
   130ec:	89 e8       	ldi	r24, 0x89	; 137
   130ee:	9b e0       	ldi	r25, 0x0B	; 11
   130f0:	18 c0       	rjmp	.+48     	; 0x13122 <PrintIdle+0x6d4>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
   130f2:	87 30       	cpi	r24, 0x07	; 7
   130f4:	f1 f4       	brne	.+60     	; 0x13132 <PrintIdle+0x6e4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
   130f6:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
   130fa:	00 d0       	rcall	.+0      	; 0x130fc <PrintIdle+0x6ae>
   130fc:	00 d0       	rcall	.+0      	; 0x130fe <PrintIdle+0x6b0>
   130fe:	00 d0       	rcall	.+0      	; 0x13100 <PrintIdle+0x6b2>
   13100:	ed b7       	in	r30, 0x3d	; 61
   13102:	fe b7       	in	r31, 0x3e	; 62
   13104:	31 96       	adiw	r30, 0x01	; 1
   13106:	8c eb       	ldi	r24, 0xBC	; 188
   13108:	98 e0       	ldi	r25, 0x08	; 8
   1310a:	ad b7       	in	r26, 0x3d	; 61
   1310c:	be b7       	in	r27, 0x3e	; 62
   1310e:	12 96       	adiw	r26, 0x02	; 2
   13110:	9c 93       	st	X, r25
   13112:	8e 93       	st	-X, r24
   13114:	11 97       	sbiw	r26, 0x01	; 1
   13116:	85 e1       	ldi	r24, 0x15	; 21
   13118:	98 e0       	ldi	r25, 0x08	; 8
   1311a:	93 83       	std	Z+3, r25	; 0x03
   1311c:	82 83       	std	Z+2, r24	; 0x02
   1311e:	8c e3       	ldi	r24, 0x3C	; 60
   13120:	9c e0       	ldi	r25, 0x0C	; 12
   13122:	95 83       	std	Z+5, r25	; 0x05
   13124:	84 83       	std	Z+4, r24	; 0x04
   13126:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				   IsSignedField=True;
   1312a:	81 e0       	ldi	r24, 0x01	; 1
   1312c:	80 93 ff 01 	sts	0x01FF, r24
   13130:	64 c2       	rjmp	.+1224   	; 0x135fa <PrintIdle+0xbac>
   13132:	0c eb       	ldi	r16, 0xBC	; 188
   13134:	18 e0       	ldi	r17, 0x08	; 8
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
   13136:	88 30       	cpi	r24, 0x08	; 8
   13138:	09 f0       	breq	.+2      	; 0x1313c <PrintIdle+0x6ee>
   1313a:	a9 cf       	rjmp	.-174    	; 0x1308e <PrintIdle+0x640>
			       CarriegeReturn();
   1313c:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
   13140:	00 d0       	rcall	.+0      	; 0x13142 <PrintIdle+0x6f4>
   13142:	00 d0       	rcall	.+0      	; 0x13144 <PrintIdle+0x6f6>
   13144:	ad b7       	in	r26, 0x3d	; 61
   13146:	be b7       	in	r27, 0x3e	; 62
   13148:	12 96       	adiw	r26, 0x02	; 2
   1314a:	1c 93       	st	X, r17
   1314c:	0e 93       	st	-X, r16
   1314e:	11 97       	sbiw	r26, 0x01	; 1
   13150:	82 ef       	ldi	r24, 0xF2	; 242
   13152:	97 e0       	ldi	r25, 0x07	; 7
   13154:	14 96       	adiw	r26, 0x04	; 4
   13156:	9c 93       	st	X, r25
   13158:	8e 93       	st	-X, r24
   1315a:	13 97       	sbiw	r26, 0x03	; 3
   1315c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
				   IsSignedField=False;
   13160:	10 92 ff 01 	sts	0x01FF, r1
   13164:	67 c2       	rjmp	.+1230   	; 0x13634 <PrintIdle+0xbe6>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
   13166:	80 91 b8 01 	lds	r24, 0x01B8
   1316a:	81 30       	cpi	r24, 0x01	; 1
   1316c:	99 f4       	brne	.+38     	; 0x13194 <PrintIdle+0x746>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
   1316e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
   13172:	00 d0       	rcall	.+0      	; 0x13174 <PrintIdle+0x726>
   13174:	00 d0       	rcall	.+0      	; 0x13176 <PrintIdle+0x728>
   13176:	00 d0       	rcall	.+0      	; 0x13178 <PrintIdle+0x72a>
   13178:	ed b7       	in	r30, 0x3d	; 61
   1317a:	fe b7       	in	r31, 0x3e	; 62
   1317c:	31 96       	adiw	r30, 0x01	; 1
   1317e:	8c eb       	ldi	r24, 0xBC	; 188
   13180:	98 e0       	ldi	r25, 0x08	; 8
   13182:	ad b7       	in	r26, 0x3d	; 61
   13184:	be b7       	in	r27, 0x3e	; 62
   13186:	12 96       	adiw	r26, 0x02	; 2
   13188:	9c 93       	st	X, r25
   1318a:	8e 93       	st	-X, r24
   1318c:	11 97       	sbiw	r26, 0x01	; 1
   1318e:	80 ee       	ldi	r24, 0xE0	; 224
   13190:	97 e0       	ldi	r25, 0x07	; 7
   13192:	3a c0       	rjmp	.+116    	; 0x13208 <PrintIdle+0x7ba>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
   13194:	83 30       	cpi	r24, 0x03	; 3
   13196:	e9 f5       	brne	.+122    	; 0x13212 <PrintIdle+0x7c4>
			       if (IsPrintApprovalCode==True){
   13198:	80 91 9a 01 	lds	r24, 0x019A
   1319c:	81 30       	cpi	r24, 0x01	; 1
   1319e:	11 f5       	brne	.+68     	; 0x131e4 <PrintIdle+0x796>
				       IsPrintApprovalCode=False;
   131a0:	10 92 9a 01 	sts	0x019A, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
   131a4:	00 d0       	rcall	.+0      	; 0x131a6 <PrintIdle+0x758>
   131a6:	00 d0       	rcall	.+0      	; 0x131a8 <PrintIdle+0x75a>
   131a8:	00 d0       	rcall	.+0      	; 0x131aa <PrintIdle+0x75c>
   131aa:	ed b7       	in	r30, 0x3d	; 61
   131ac:	fe b7       	in	r31, 0x3e	; 62
   131ae:	31 96       	adiw	r30, 0x01	; 1
   131b0:	84 e2       	ldi	r24, 0x24	; 36
   131b2:	93 e0       	ldi	r25, 0x03	; 3
   131b4:	ad b7       	in	r26, 0x3d	; 61
   131b6:	be b7       	in	r27, 0x3e	; 62
   131b8:	12 96       	adiw	r26, 0x02	; 2
   131ba:	9c 93       	st	X, r25
   131bc:	8e 93       	st	-X, r24
   131be:	11 97       	sbiw	r26, 0x01	; 1
   131c0:	8b ed       	ldi	r24, 0xDB	; 219
   131c2:	97 e0       	ldi	r25, 0x07	; 7
   131c4:	93 83       	std	Z+3, r25	; 0x03
   131c6:	82 83       	std	Z+2, r24	; 0x02
   131c8:	80 ef       	ldi	r24, 0xF0	; 240
   131ca:	97 e0       	ldi	r25, 0x07	; 7
   131cc:	95 83       	std	Z+5, r25	; 0x05
   131ce:	84 83       	std	Z+4, r24	; 0x04
   131d0:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   131d4:	ed b7       	in	r30, 0x3d	; 61
   131d6:	fe b7       	in	r31, 0x3e	; 62
   131d8:	36 96       	adiw	r30, 0x06	; 6
   131da:	0f b6       	in	r0, 0x3f	; 63
   131dc:	f8 94       	cli
   131de:	fe bf       	out	0x3e, r31	; 62
   131e0:	0f be       	out	0x3f, r0	; 63
   131e2:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
   131e4:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
   131e8:	00 d0       	rcall	.+0      	; 0x131ea <PrintIdle+0x79c>
   131ea:	00 d0       	rcall	.+0      	; 0x131ec <PrintIdle+0x79e>
   131ec:	00 d0       	rcall	.+0      	; 0x131ee <PrintIdle+0x7a0>
   131ee:	ed b7       	in	r30, 0x3d	; 61
   131f0:	fe b7       	in	r31, 0x3e	; 62
   131f2:	31 96       	adiw	r30, 0x01	; 1
   131f4:	8c eb       	ldi	r24, 0xBC	; 188
   131f6:	98 e0       	ldi	r25, 0x08	; 8
   131f8:	ad b7       	in	r26, 0x3d	; 61
   131fa:	be b7       	in	r27, 0x3e	; 62
   131fc:	12 96       	adiw	r26, 0x02	; 2
   131fe:	9c 93       	st	X, r25
   13200:	8e 93       	st	-X, r24
   13202:	11 97       	sbiw	r26, 0x01	; 1
   13204:	89 ec       	ldi	r24, 0xC9	; 201
   13206:	97 e0       	ldi	r25, 0x07	; 7
   13208:	93 83       	std	Z+3, r25	; 0x03
   1320a:	82 83       	std	Z+2, r24	; 0x02
   1320c:	84 e2       	ldi	r24, 0x24	; 36
   1320e:	93 e0       	ldi	r25, 0x03	; 3
   13210:	f0 c1       	rjmp	.+992    	; 0x135f2 <PrintIdle+0xba4>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
   13212:	87 30       	cpi	r24, 0x07	; 7
   13214:	79 f4       	brne	.+30     	; 0x13234 <PrintIdle+0x7e6>
			       CarriegeReturn();
   13216:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
   1321a:	00 d0       	rcall	.+0      	; 0x1321c <PrintIdle+0x7ce>
   1321c:	00 d0       	rcall	.+0      	; 0x1321e <PrintIdle+0x7d0>
   1321e:	8c eb       	ldi	r24, 0xBC	; 188
   13220:	98 e0       	ldi	r25, 0x08	; 8
   13222:	ad b7       	in	r26, 0x3d	; 61
   13224:	be b7       	in	r27, 0x3e	; 62
   13226:	12 96       	adiw	r26, 0x02	; 2
   13228:	9c 93       	st	X, r25
   1322a:	8e 93       	st	-X, r24
   1322c:	11 97       	sbiw	r26, 0x01	; 1
   1322e:	86 ec       	ldi	r24, 0xC6	; 198
   13230:	97 e0       	ldi	r25, 0x07	; 7
   13232:	fa c1       	rjmp	.+1012   	; 0x13628 <PrintIdle+0xbda>
   13234:	0c eb       	ldi	r16, 0xBC	; 188
   13236:	18 e0       	ldi	r17, 0x08	; 8
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
   13238:	88 30       	cpi	r24, 0x08	; 8
   1323a:	09 f0       	breq	.+2      	; 0x1323e <PrintIdle+0x7f0>
   1323c:	28 cf       	rjmp	.-432    	; 0x1308e <PrintIdle+0x640>
			       CarriegeReturn();
   1323e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
   13242:	00 d0       	rcall	.+0      	; 0x13244 <PrintIdle+0x7f6>
   13244:	00 d0       	rcall	.+0      	; 0x13246 <PrintIdle+0x7f8>
   13246:	ed b7       	in	r30, 0x3d	; 61
   13248:	fe b7       	in	r31, 0x3e	; 62
   1324a:	12 83       	std	Z+2, r17	; 0x02
   1324c:	01 83       	std	Z+1, r16	; 0x01
   1324e:	84 eb       	ldi	r24, 0xB4	; 180
   13250:	97 e0       	ldi	r25, 0x07	; 7
   13252:	25 c0       	rjmp	.+74     	; 0x1329e <PrintIdle+0x850>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
   13254:	80 91 ff 01 	lds	r24, 0x01FF
   13258:	0c eb       	ldi	r16, 0xBC	; 188
   1325a:	18 e0       	ldi	r17, 0x08	; 8
   1325c:	81 30       	cpi	r24, 0x01	; 1
   1325e:	09 f0       	breq	.+2      	; 0x13262 <PrintIdle+0x814>
   13260:	16 cf       	rjmp	.-468    	; 0x1308e <PrintIdle+0x640>
			       CarriegeReturn();
   13262:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
   13266:	00 d0       	rcall	.+0      	; 0x13268 <PrintIdle+0x81a>
   13268:	00 d0       	rcall	.+0      	; 0x1326a <PrintIdle+0x81c>
   1326a:	ad b7       	in	r26, 0x3d	; 61
   1326c:	be b7       	in	r27, 0x3e	; 62
   1326e:	12 96       	adiw	r26, 0x02	; 2
   13270:	1c 93       	st	X, r17
   13272:	0e 93       	st	-X, r16
   13274:	11 97       	sbiw	r26, 0x01	; 1
   13276:	8d e9       	ldi	r24, 0x9D	; 157
   13278:	97 e0       	ldi	r25, 0x07	; 7
   1327a:	d6 c1       	rjmp	.+940    	; 0x13628 <PrintIdle+0xbda>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
   1327c:	80 91 ff 01 	lds	r24, 0x01FF
   13280:	0c eb       	ldi	r16, 0xBC	; 188
   13282:	18 e0       	ldi	r17, 0x08	; 8
   13284:	81 30       	cpi	r24, 0x01	; 1
   13286:	09 f0       	breq	.+2      	; 0x1328a <PrintIdle+0x83c>
   13288:	02 cf       	rjmp	.-508    	; 0x1308e <PrintIdle+0x640>
			       CarriegeReturn();
   1328a:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
   1328e:	00 d0       	rcall	.+0      	; 0x13290 <PrintIdle+0x842>
   13290:	00 d0       	rcall	.+0      	; 0x13292 <PrintIdle+0x844>
   13292:	ed b7       	in	r30, 0x3d	; 61
   13294:	fe b7       	in	r31, 0x3e	; 62
   13296:	12 83       	std	Z+2, r17	; 0x02
   13298:	01 83       	std	Z+1, r16	; 0x01
   1329a:	86 e8       	ldi	r24, 0x86	; 134
   1329c:	97 e0       	ldi	r25, 0x07	; 7
   1329e:	94 83       	std	Z+4, r25	; 0x04
   132a0:	83 83       	std	Z+3, r24	; 0x03
   132a2:	c6 c1       	rjmp	.+908    	; 0x13630 <PrintIdle+0xbe2>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
   132a4:	80 91 ff 01 	lds	r24, 0x01FF
   132a8:	0c eb       	ldi	r16, 0xBC	; 188
   132aa:	18 e0       	ldi	r17, 0x08	; 8
   132ac:	81 30       	cpi	r24, 0x01	; 1
   132ae:	09 f0       	breq	.+2      	; 0x132b2 <PrintIdle+0x864>
   132b0:	ee ce       	rjmp	.-548    	; 0x1308e <PrintIdle+0x640>
			       CarriegeReturn();
   132b2:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
   132b6:	00 d0       	rcall	.+0      	; 0x132b8 <PrintIdle+0x86a>
   132b8:	00 d0       	rcall	.+0      	; 0x132ba <PrintIdle+0x86c>
   132ba:	ad b7       	in	r26, 0x3d	; 61
   132bc:	be b7       	in	r27, 0x3e	; 62
   132be:	12 96       	adiw	r26, 0x02	; 2
   132c0:	1c 93       	st	X, r17
   132c2:	0e 93       	st	-X, r16
   132c4:	11 97       	sbiw	r26, 0x01	; 1
   132c6:	83 e6       	ldi	r24, 0x63	; 99
   132c8:	97 e0       	ldi	r25, 0x07	; 7
   132ca:	ae c1       	rjmp	.+860    	; 0x13628 <PrintIdle+0xbda>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
   132cc:	80 91 ff 01 	lds	r24, 0x01FF
   132d0:	81 30       	cpi	r24, 0x01	; 1
   132d2:	09 f0       	breq	.+2      	; 0x132d6 <PrintIdle+0x888>
   132d4:	ae c0       	rjmp	.+348    	; 0x13432 <PrintIdle+0x9e4>
			       IsSignedField=False;
   132d6:	10 92 ff 01 	sts	0x01FF, r1
   132da:	ab c0       	rjmp	.+342    	; 0x13432 <PrintIdle+0x9e4>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
   132dc:	80 91 b8 01 	lds	r24, 0x01B8
   132e0:	0c eb       	ldi	r16, 0xBC	; 188
   132e2:	18 e0       	ldi	r17, 0x08	; 8
   132e4:	88 23       	and	r24, r24
   132e6:	09 f4       	brne	.+2      	; 0x132ea <PrintIdle+0x89c>
   132e8:	d2 ce       	rjmp	.-604    	; 0x1308e <PrintIdle+0x640>
			       CarriegeReturn();
   132ea:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
   132ee:	00 d0       	rcall	.+0      	; 0x132f0 <PrintIdle+0x8a2>
   132f0:	00 d0       	rcall	.+0      	; 0x132f2 <PrintIdle+0x8a4>
   132f2:	00 d0       	rcall	.+0      	; 0x132f4 <PrintIdle+0x8a6>
   132f4:	ed b7       	in	r30, 0x3d	; 61
   132f6:	fe b7       	in	r31, 0x3e	; 62
   132f8:	31 96       	adiw	r30, 0x01	; 1
   132fa:	ad b7       	in	r26, 0x3d	; 61
   132fc:	be b7       	in	r27, 0x3e	; 62
   132fe:	12 96       	adiw	r26, 0x02	; 2
   13300:	1c 93       	st	X, r17
   13302:	0e 93       	st	-X, r16
   13304:	11 97       	sbiw	r26, 0x01	; 1
   13306:	8b e5       	ldi	r24, 0x5B	; 91
   13308:	97 e0       	ldi	r25, 0x07	; 7
   1330a:	93 83       	std	Z+3, r25	; 0x03
   1330c:	82 83       	std	Z+2, r24	; 0x02
   1330e:	8d e7       	ldi	r24, 0x7D	; 125
   13310:	95 e0       	ldi	r25, 0x05	; 5
   13312:	6f c1       	rjmp	.+734    	; 0x135f2 <PrintIdle+0xba4>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
   13314:	80 91 b8 01 	lds	r24, 0x01B8
   13318:	0c eb       	ldi	r16, 0xBC	; 188
   1331a:	18 e0       	ldi	r17, 0x08	; 8
   1331c:	88 23       	and	r24, r24
   1331e:	09 f4       	brne	.+2      	; 0x13322 <PrintIdle+0x8d4>
   13320:	b6 ce       	rjmp	.-660    	; 0x1308e <PrintIdle+0x640>
			       CarriegeReturn();
   13322:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
   13326:	00 d0       	rcall	.+0      	; 0x13328 <PrintIdle+0x8da>
   13328:	00 d0       	rcall	.+0      	; 0x1332a <PrintIdle+0x8dc>
   1332a:	ad b7       	in	r26, 0x3d	; 61
   1332c:	be b7       	in	r27, 0x3e	; 62
   1332e:	12 96       	adiw	r26, 0x02	; 2
   13330:	1c 93       	st	X, r17
   13332:	0e 93       	st	-X, r16
   13334:	11 97       	sbiw	r26, 0x01	; 1
   13336:	88 e3       	ldi	r24, 0x38	; 56
   13338:	97 e0       	ldi	r25, 0x07	; 7
   1333a:	76 c1       	rjmp	.+748    	; 0x13628 <PrintIdle+0xbda>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
   1333c:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
   13340:	00 d0       	rcall	.+0      	; 0x13342 <PrintIdle+0x8f4>
   13342:	00 d0       	rcall	.+0      	; 0x13344 <PrintIdle+0x8f6>
   13344:	8c eb       	ldi	r24, 0xBC	; 188
   13346:	98 e0       	ldi	r25, 0x08	; 8
   13348:	ed b7       	in	r30, 0x3d	; 61
   1334a:	fe b7       	in	r31, 0x3e	; 62
   1334c:	92 83       	std	Z+2, r25	; 0x02
   1334e:	81 83       	std	Z+1, r24	; 0x01
   13350:	85 e1       	ldi	r24, 0x15	; 21
   13352:	97 e0       	ldi	r25, 0x07	; 7
   13354:	a4 cf       	rjmp	.-184    	; 0x1329e <PrintIdle+0x850>
		       break; 			            
		  case 22:
		       CarriegeReturn();
   13356:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
   1335a:	00 d0       	rcall	.+0      	; 0x1335c <PrintIdle+0x90e>
   1335c:	00 d0       	rcall	.+0      	; 0x1335e <PrintIdle+0x910>
   1335e:	00 d0       	rcall	.+0      	; 0x13360 <PrintIdle+0x912>
   13360:	ed b7       	in	r30, 0x3d	; 61
   13362:	fe b7       	in	r31, 0x3e	; 62
   13364:	31 96       	adiw	r30, 0x01	; 1
   13366:	8c eb       	ldi	r24, 0xBC	; 188
   13368:	98 e0       	ldi	r25, 0x08	; 8
   1336a:	ad b7       	in	r26, 0x3d	; 61
   1336c:	be b7       	in	r27, 0x3e	; 62
   1336e:	12 96       	adiw	r26, 0x02	; 2
   13370:	9c 93       	st	X, r25
   13372:	8e 93       	st	-X, r24
   13374:	11 97       	sbiw	r26, 0x01	; 1
   13376:	8e ef       	ldi	r24, 0xFE	; 254
   13378:	96 e0       	ldi	r25, 0x06	; 6
   1337a:	93 83       	std	Z+3, r25	; 0x03
   1337c:	82 83       	std	Z+2, r24	; 0x02
   1337e:	87 ee       	ldi	r24, 0xE7	; 231
   13380:	92 e0       	ldi	r25, 0x02	; 2
   13382:	37 c1       	rjmp	.+622    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 23:
		       CarriegeReturn();
   13384:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
   13388:	00 d0       	rcall	.+0      	; 0x1338a <PrintIdle+0x93c>
   1338a:	00 d0       	rcall	.+0      	; 0x1338c <PrintIdle+0x93e>
   1338c:	00 d0       	rcall	.+0      	; 0x1338e <PrintIdle+0x940>
   1338e:	ed b7       	in	r30, 0x3d	; 61
   13390:	fe b7       	in	r31, 0x3e	; 62
   13392:	31 96       	adiw	r30, 0x01	; 1
   13394:	8c eb       	ldi	r24, 0xBC	; 188
   13396:	98 e0       	ldi	r25, 0x08	; 8
   13398:	ad b7       	in	r26, 0x3d	; 61
   1339a:	be b7       	in	r27, 0x3e	; 62
   1339c:	12 96       	adiw	r26, 0x02	; 2
   1339e:	9c 93       	st	X, r25
   133a0:	8e 93       	st	-X, r24
   133a2:	11 97       	sbiw	r26, 0x01	; 1
   133a4:	86 ee       	ldi	r24, 0xE6	; 230
   133a6:	96 e0       	ldi	r25, 0x06	; 6
   133a8:	93 83       	std	Z+3, r25	; 0x03
   133aa:	82 83       	std	Z+2, r24	; 0x02
   133ac:	84 ec       	ldi	r24, 0xC4	; 196
   133ae:	92 e0       	ldi	r25, 0x02	; 2
   133b0:	20 c1       	rjmp	.+576    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
   133b2:	0a e0       	ldi	r16, 0x0A	; 10
   133b4:	1c e0       	ldi	r17, 0x0C	; 12
   133b6:	80 91 0a 0c 	lds	r24, 0x0C0A
   133ba:	88 23       	and	r24, r24
   133bc:	d1 f1       	breq	.+116    	; 0x13432 <PrintIdle+0x9e4>
   133be:	c8 01       	movw	r24, r16
   133c0:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   133c4:	88 23       	and	r24, r24
   133c6:	a9 f5       	brne	.+106    	; 0x13432 <PrintIdle+0x9e4>
		           CarriegeReturn();
   133c8:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
   133cc:	00 d0       	rcall	.+0      	; 0x133ce <PrintIdle+0x980>
   133ce:	00 d0       	rcall	.+0      	; 0x133d0 <PrintIdle+0x982>
   133d0:	00 d0       	rcall	.+0      	; 0x133d2 <PrintIdle+0x984>
   133d2:	ed b7       	in	r30, 0x3d	; 61
   133d4:	fe b7       	in	r31, 0x3e	; 62
   133d6:	31 96       	adiw	r30, 0x01	; 1
   133d8:	8c eb       	ldi	r24, 0xBC	; 188
   133da:	98 e0       	ldi	r25, 0x08	; 8
   133dc:	ad b7       	in	r26, 0x3d	; 61
   133de:	be b7       	in	r27, 0x3e	; 62
   133e0:	12 96       	adiw	r26, 0x02	; 2
   133e2:	9c 93       	st	X, r25
   133e4:	8e 93       	st	-X, r24
   133e6:	11 97       	sbiw	r26, 0x01	; 1
   133e8:	8f ec       	ldi	r24, 0xCF	; 207
   133ea:	96 e0       	ldi	r25, 0x06	; 6
   133ec:	1d c0       	rjmp	.+58     	; 0x13428 <PrintIdle+0x9da>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
   133ee:	0d ec       	ldi	r16, 0xCD	; 205
   133f0:	13 e0       	ldi	r17, 0x03	; 3
   133f2:	80 91 cd 03 	lds	r24, 0x03CD
   133f6:	88 23       	and	r24, r24
   133f8:	e1 f0       	breq	.+56     	; 0x13432 <PrintIdle+0x9e4>
   133fa:	c8 01       	movw	r24, r16
   133fc:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   13400:	88 23       	and	r24, r24
   13402:	b9 f4       	brne	.+46     	; 0x13432 <PrintIdle+0x9e4>
		           CarriegeReturn();
   13404:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
   13408:	00 d0       	rcall	.+0      	; 0x1340a <PrintIdle+0x9bc>
   1340a:	00 d0       	rcall	.+0      	; 0x1340c <PrintIdle+0x9be>
   1340c:	00 d0       	rcall	.+0      	; 0x1340e <PrintIdle+0x9c0>
   1340e:	ed b7       	in	r30, 0x3d	; 61
   13410:	fe b7       	in	r31, 0x3e	; 62
   13412:	31 96       	adiw	r30, 0x01	; 1
   13414:	8c eb       	ldi	r24, 0xBC	; 188
   13416:	98 e0       	ldi	r25, 0x08	; 8
   13418:	ad b7       	in	r26, 0x3d	; 61
   1341a:	be b7       	in	r27, 0x3e	; 62
   1341c:	12 96       	adiw	r26, 0x02	; 2
   1341e:	9c 93       	st	X, r25
   13420:	8e 93       	st	-X, r24
   13422:	11 97       	sbiw	r26, 0x01	; 1
   13424:	88 eb       	ldi	r24, 0xB8	; 184
   13426:	96 e0       	ldi	r25, 0x06	; 6
   13428:	93 83       	std	Z+3, r25	; 0x03
   1342a:	82 83       	std	Z+2, r24	; 0x02
   1342c:	15 83       	std	Z+5, r17	; 0x05
   1342e:	04 83       	std	Z+4, r16	; 0x04
   13430:	e2 c0       	rjmp	.+452    	; 0x135f6 <PrintIdle+0xba8>
			   }else ClearMem(strPrint);
   13432:	8c eb       	ldi	r24, 0xBC	; 188
   13434:	98 e0       	ldi	r25, 0x08	; 8
   13436:	2c ce       	rjmp	.-936    	; 0x13090 <PrintIdle+0x642>
		       break;
		  case 26:
		       CarriegeReturn();
   13438:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
   1343c:	00 d0       	rcall	.+0      	; 0x1343e <PrintIdle+0x9f0>
   1343e:	00 d0       	rcall	.+0      	; 0x13440 <PrintIdle+0x9f2>
   13440:	00 d0       	rcall	.+0      	; 0x13442 <PrintIdle+0x9f4>
   13442:	ed b7       	in	r30, 0x3d	; 61
   13444:	fe b7       	in	r31, 0x3e	; 62
   13446:	31 96       	adiw	r30, 0x01	; 1
   13448:	8c eb       	ldi	r24, 0xBC	; 188
   1344a:	98 e0       	ldi	r25, 0x08	; 8
   1344c:	ad b7       	in	r26, 0x3d	; 61
   1344e:	be b7       	in	r27, 0x3e	; 62
   13450:	12 96       	adiw	r26, 0x02	; 2
   13452:	9c 93       	st	X, r25
   13454:	8e 93       	st	-X, r24
   13456:	11 97       	sbiw	r26, 0x01	; 1
   13458:	81 ea       	ldi	r24, 0xA1	; 161
   1345a:	96 e0       	ldi	r25, 0x06	; 6
   1345c:	93 83       	std	Z+3, r25	; 0x03
   1345e:	82 83       	std	Z+2, r24	; 0x02
   13460:	8b eb       	ldi	r24, 0xBB	; 187
   13462:	92 e0       	ldi	r25, 0x02	; 2
   13464:	c6 c0       	rjmp	.+396    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 27:
		       CarriegeReturn();
   13466:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
   1346a:	00 d0       	rcall	.+0      	; 0x1346c <PrintIdle+0xa1e>
   1346c:	00 d0       	rcall	.+0      	; 0x1346e <PrintIdle+0xa20>
   1346e:	00 d0       	rcall	.+0      	; 0x13470 <PrintIdle+0xa22>
   13470:	ed b7       	in	r30, 0x3d	; 61
   13472:	fe b7       	in	r31, 0x3e	; 62
   13474:	31 96       	adiw	r30, 0x01	; 1
   13476:	8c eb       	ldi	r24, 0xBC	; 188
   13478:	98 e0       	ldi	r25, 0x08	; 8
   1347a:	ad b7       	in	r26, 0x3d	; 61
   1347c:	be b7       	in	r27, 0x3e	; 62
   1347e:	12 96       	adiw	r26, 0x02	; 2
   13480:	9c 93       	st	X, r25
   13482:	8e 93       	st	-X, r24
   13484:	11 97       	sbiw	r26, 0x01	; 1
   13486:	8a e8       	ldi	r24, 0x8A	; 138
   13488:	96 e0       	ldi	r25, 0x06	; 6
   1348a:	93 83       	std	Z+3, r25	; 0x03
   1348c:	82 83       	std	Z+2, r24	; 0x02
   1348e:	84 e1       	ldi	r24, 0x14	; 20
   13490:	99 e0       	ldi	r25, 0x09	; 9
   13492:	af c0       	rjmp	.+350    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 28:
		       CarriegeReturn();
   13494:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
   13498:	00 d0       	rcall	.+0      	; 0x1349a <PrintIdle+0xa4c>
   1349a:	00 d0       	rcall	.+0      	; 0x1349c <PrintIdle+0xa4e>
   1349c:	00 d0       	rcall	.+0      	; 0x1349e <PrintIdle+0xa50>
   1349e:	ed b7       	in	r30, 0x3d	; 61
   134a0:	fe b7       	in	r31, 0x3e	; 62
   134a2:	31 96       	adiw	r30, 0x01	; 1
   134a4:	8c eb       	ldi	r24, 0xBC	; 188
   134a6:	98 e0       	ldi	r25, 0x08	; 8
   134a8:	ad b7       	in	r26, 0x3d	; 61
   134aa:	be b7       	in	r27, 0x3e	; 62
   134ac:	12 96       	adiw	r26, 0x02	; 2
   134ae:	9c 93       	st	X, r25
   134b0:	8e 93       	st	-X, r24
   134b2:	11 97       	sbiw	r26, 0x01	; 1
   134b4:	83 e7       	ldi	r24, 0x73	; 115
   134b6:	96 e0       	ldi	r25, 0x06	; 6
   134b8:	93 83       	std	Z+3, r25	; 0x03
   134ba:	82 83       	std	Z+2, r24	; 0x02
   134bc:	85 e3       	ldi	r24, 0x35	; 53
   134be:	98 e0       	ldi	r25, 0x08	; 8
   134c0:	98 c0       	rjmp	.+304    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 29:
		       CarriegeReturn();
   134c2:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
   134c6:	00 d0       	rcall	.+0      	; 0x134c8 <PrintIdle+0xa7a>
   134c8:	00 d0       	rcall	.+0      	; 0x134ca <PrintIdle+0xa7c>
   134ca:	00 d0       	rcall	.+0      	; 0x134cc <PrintIdle+0xa7e>
   134cc:	ed b7       	in	r30, 0x3d	; 61
   134ce:	fe b7       	in	r31, 0x3e	; 62
   134d0:	31 96       	adiw	r30, 0x01	; 1
   134d2:	8c eb       	ldi	r24, 0xBC	; 188
   134d4:	98 e0       	ldi	r25, 0x08	; 8
   134d6:	ad b7       	in	r26, 0x3d	; 61
   134d8:	be b7       	in	r27, 0x3e	; 62
   134da:	12 96       	adiw	r26, 0x02	; 2
   134dc:	9c 93       	st	X, r25
   134de:	8e 93       	st	-X, r24
   134e0:	11 97       	sbiw	r26, 0x01	; 1
   134e2:	8c e5       	ldi	r24, 0x5C	; 92
   134e4:	96 e0       	ldi	r25, 0x06	; 6
   134e6:	93 83       	std	Z+3, r25	; 0x03
   134e8:	82 83       	std	Z+2, r24	; 0x02
   134ea:	89 e7       	ldi	r24, 0x79	; 121
   134ec:	9c e0       	ldi	r25, 0x0C	; 12
   134ee:	81 c0       	rjmp	.+258    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 30:
		       CarriegeReturn();
   134f0:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
   134f4:	00 d0       	rcall	.+0      	; 0x134f6 <PrintIdle+0xaa8>
   134f6:	00 d0       	rcall	.+0      	; 0x134f8 <PrintIdle+0xaaa>
   134f8:	00 d0       	rcall	.+0      	; 0x134fa <PrintIdle+0xaac>
   134fa:	ed b7       	in	r30, 0x3d	; 61
   134fc:	fe b7       	in	r31, 0x3e	; 62
   134fe:	31 96       	adiw	r30, 0x01	; 1
   13500:	8c eb       	ldi	r24, 0xBC	; 188
   13502:	98 e0       	ldi	r25, 0x08	; 8
   13504:	ad b7       	in	r26, 0x3d	; 61
   13506:	be b7       	in	r27, 0x3e	; 62
   13508:	12 96       	adiw	r26, 0x02	; 2
   1350a:	9c 93       	st	X, r25
   1350c:	8e 93       	st	-X, r24
   1350e:	11 97       	sbiw	r26, 0x01	; 1
   13510:	85 e4       	ldi	r24, 0x45	; 69
   13512:	96 e0       	ldi	r25, 0x06	; 6
   13514:	93 83       	std	Z+3, r25	; 0x03
   13516:	82 83       	std	Z+2, r24	; 0x02
   13518:	8a e9       	ldi	r24, 0x9A	; 154
   1351a:	93 e0       	ldi	r25, 0x03	; 3
   1351c:	6a c0       	rjmp	.+212    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 31:
		       CarriegeReturn();
   1351e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
   13522:	00 d0       	rcall	.+0      	; 0x13524 <PrintIdle+0xad6>
   13524:	00 d0       	rcall	.+0      	; 0x13526 <PrintIdle+0xad8>
   13526:	00 d0       	rcall	.+0      	; 0x13528 <PrintIdle+0xada>
   13528:	ed b7       	in	r30, 0x3d	; 61
   1352a:	fe b7       	in	r31, 0x3e	; 62
   1352c:	31 96       	adiw	r30, 0x01	; 1
   1352e:	8c eb       	ldi	r24, 0xBC	; 188
   13530:	98 e0       	ldi	r25, 0x08	; 8
   13532:	ad b7       	in	r26, 0x3d	; 61
   13534:	be b7       	in	r27, 0x3e	; 62
   13536:	12 96       	adiw	r26, 0x02	; 2
   13538:	9c 93       	st	X, r25
   1353a:	8e 93       	st	-X, r24
   1353c:	11 97       	sbiw	r26, 0x01	; 1
   1353e:	8c e2       	ldi	r24, 0x2C	; 44
   13540:	96 e0       	ldi	r25, 0x06	; 6
   13542:	93 83       	std	Z+3, r25	; 0x03
   13544:	82 83       	std	Z+2, r24	; 0x02
   13546:	8d ee       	ldi	r24, 0xED	; 237
   13548:	9b e0       	ldi	r25, 0x0B	; 11
   1354a:	53 c0       	rjmp	.+166    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 32:
		       CarriegeReturn();
   1354c:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
   13550:	00 d0       	rcall	.+0      	; 0x13552 <PrintIdle+0xb04>
   13552:	00 d0       	rcall	.+0      	; 0x13554 <PrintIdle+0xb06>
   13554:	00 d0       	rcall	.+0      	; 0x13556 <PrintIdle+0xb08>
   13556:	ed b7       	in	r30, 0x3d	; 61
   13558:	fe b7       	in	r31, 0x3e	; 62
   1355a:	31 96       	adiw	r30, 0x01	; 1
   1355c:	8c eb       	ldi	r24, 0xBC	; 188
   1355e:	98 e0       	ldi	r25, 0x08	; 8
   13560:	ad b7       	in	r26, 0x3d	; 61
   13562:	be b7       	in	r27, 0x3e	; 62
   13564:	12 96       	adiw	r26, 0x02	; 2
   13566:	9c 93       	st	X, r25
   13568:	8e 93       	st	-X, r24
   1356a:	11 97       	sbiw	r26, 0x01	; 1
   1356c:	82 e1       	ldi	r24, 0x12	; 18
   1356e:	96 e0       	ldi	r25, 0x06	; 6
   13570:	93 83       	std	Z+3, r25	; 0x03
   13572:	82 83       	std	Z+2, r24	; 0x02
   13574:	8e e7       	ldi	r24, 0x7E	; 126
   13576:	93 e0       	ldi	r25, 0x03	; 3
   13578:	3c c0       	rjmp	.+120    	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
   1357a:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
   1357e:	00 d0       	rcall	.+0      	; 0x13580 <PrintIdle+0xb32>
   13580:	00 d0       	rcall	.+0      	; 0x13582 <PrintIdle+0xb34>
   13582:	8c eb       	ldi	r24, 0xBC	; 188
   13584:	98 e0       	ldi	r25, 0x08	; 8
   13586:	ad b7       	in	r26, 0x3d	; 61
   13588:	be b7       	in	r27, 0x3e	; 62
   1358a:	12 96       	adiw	r26, 0x02	; 2
   1358c:	9c 93       	st	X, r25
   1358e:	8e 93       	st	-X, r24
   13590:	11 97       	sbiw	r26, 0x01	; 1
   13592:	8f ee       	ldi	r24, 0xEF	; 239
   13594:	95 e0       	ldi	r25, 0x05	; 5
   13596:	48 c0       	rjmp	.+144    	; 0x13628 <PrintIdle+0xbda>
		       break;
		  case 34:
		       CarriegeReturn();
   13598:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
   1359c:	00 d0       	rcall	.+0      	; 0x1359e <PrintIdle+0xb50>
   1359e:	00 d0       	rcall	.+0      	; 0x135a0 <PrintIdle+0xb52>
   135a0:	00 d0       	rcall	.+0      	; 0x135a2 <PrintIdle+0xb54>
   135a2:	ed b7       	in	r30, 0x3d	; 61
   135a4:	fe b7       	in	r31, 0x3e	; 62
   135a6:	31 96       	adiw	r30, 0x01	; 1
   135a8:	8c eb       	ldi	r24, 0xBC	; 188
   135aa:	98 e0       	ldi	r25, 0x08	; 8
   135ac:	ad b7       	in	r26, 0x3d	; 61
   135ae:	be b7       	in	r27, 0x3e	; 62
   135b0:	12 96       	adiw	r26, 0x02	; 2
   135b2:	9c 93       	st	X, r25
   135b4:	8e 93       	st	-X, r24
   135b6:	11 97       	sbiw	r26, 0x01	; 1
   135b8:	88 ed       	ldi	r24, 0xD8	; 216
   135ba:	95 e0       	ldi	r25, 0x05	; 5
   135bc:	93 83       	std	Z+3, r25	; 0x03
   135be:	82 83       	std	Z+2, r24	; 0x02
   135c0:	8b ed       	ldi	r24, 0xDB	; 219
   135c2:	97 e0       	ldi	r25, 0x07	; 7
   135c4:	16 c0       	rjmp	.+44     	; 0x135f2 <PrintIdle+0xba4>
		       break;
		  case 35:
		       CarriegeReturn();
   135c6:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
   135ca:	00 d0       	rcall	.+0      	; 0x135cc <PrintIdle+0xb7e>
   135cc:	00 d0       	rcall	.+0      	; 0x135ce <PrintIdle+0xb80>
   135ce:	00 d0       	rcall	.+0      	; 0x135d0 <PrintIdle+0xb82>
   135d0:	ed b7       	in	r30, 0x3d	; 61
   135d2:	fe b7       	in	r31, 0x3e	; 62
   135d4:	31 96       	adiw	r30, 0x01	; 1
   135d6:	8c eb       	ldi	r24, 0xBC	; 188
   135d8:	98 e0       	ldi	r25, 0x08	; 8
   135da:	ad b7       	in	r26, 0x3d	; 61
   135dc:	be b7       	in	r27, 0x3e	; 62
   135de:	12 96       	adiw	r26, 0x02	; 2
   135e0:	9c 93       	st	X, r25
   135e2:	8e 93       	st	-X, r24
   135e4:	11 97       	sbiw	r26, 0x01	; 1
   135e6:	81 ec       	ldi	r24, 0xC1	; 193
   135e8:	95 e0       	ldi	r25, 0x05	; 5
   135ea:	93 83       	std	Z+3, r25	; 0x03
   135ec:	82 83       	std	Z+2, r24	; 0x02
   135ee:	82 e5       	ldi	r24, 0x52	; 82
   135f0:	98 e0       	ldi	r25, 0x08	; 8
   135f2:	95 83       	std	Z+5, r25	; 0x05
   135f4:	84 83       	std	Z+4, r24	; 0x04
   135f6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   135fa:	ed b7       	in	r30, 0x3d	; 61
   135fc:	fe b7       	in	r31, 0x3e	; 62
   135fe:	36 96       	adiw	r30, 0x06	; 6
   13600:	0f b6       	in	r0, 0x3f	; 63
   13602:	f8 94       	cli
   13604:	fe bf       	out	0x3e, r31	; 62
   13606:	0f be       	out	0x3f, r0	; 63
   13608:	ed bf       	out	0x3d, r30	; 61
   1360a:	18 c0       	rjmp	.+48     	; 0x1363c <PrintIdle+0xbee>
		       break;
		  case 36:
		       CarriegeReturn();
   1360c:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
   13610:	00 d0       	rcall	.+0      	; 0x13612 <PrintIdle+0xbc4>
   13612:	00 d0       	rcall	.+0      	; 0x13614 <PrintIdle+0xbc6>
   13614:	8c eb       	ldi	r24, 0xBC	; 188
   13616:	98 e0       	ldi	r25, 0x08	; 8
   13618:	ad b7       	in	r26, 0x3d	; 61
   1361a:	be b7       	in	r27, 0x3e	; 62
   1361c:	12 96       	adiw	r26, 0x02	; 2
   1361e:	9c 93       	st	X, r25
   13620:	8e 93       	st	-X, r24
   13622:	11 97       	sbiw	r26, 0x01	; 1
   13624:	8e e9       	ldi	r24, 0x9E	; 158
   13626:	95 e0       	ldi	r25, 0x05	; 5
   13628:	14 96       	adiw	r26, 0x04	; 4
   1362a:	9c 93       	st	X, r25
   1362c:	8e 93       	st	-X, r24
   1362e:	13 97       	sbiw	r26, 0x03	; 3
   13630:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   13634:	0f 90       	pop	r0
   13636:	0f 90       	pop	r0
   13638:	0f 90       	pop	r0
   1363a:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
   1363c:	10 92 fa 01 	sts	0x01FA, r1
   13640:	10 92 f9 01 	sts	0x01F9, r1
   13644:	10 92 fe 01 	sts	0x01FE, r1
   13648:	10 92 fd 01 	sts	0x01FD, r1
   1364c:	ec eb       	ldi	r30, 0xBC	; 188
   1364e:	f8 e0       	ldi	r31, 0x08	; 8
   13650:	01 90       	ld	r0, Z+
   13652:	00 20       	and	r0, r0
   13654:	e9 f7       	brne	.-6      	; 0x13650 <PrintIdle+0xc02>
   13656:	31 97       	sbiw	r30, 0x01	; 1
   13658:	ec 5b       	subi	r30, 0xBC	; 188
   1365a:	f8 40       	sbci	r31, 0x08	; 8
   1365c:	f0 93 fc 01 	sts	0x01FC, r31
   13660:	e0 93 fb 01 	sts	0x01FB, r30
          stPrintIdle=piPrintMessage;
   13664:	8a e0       	ldi	r24, 0x0A	; 10
   13666:	7e c1       	rjmp	.+764    	; 0x13964 <PrintIdle+0xf16>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
   13668:	20 91 fd 01 	lds	r18, 0x01FD
   1366c:	30 91 fe 01 	lds	r19, 0x01FE
   13670:	80 91 fb 01 	lds	r24, 0x01FB
   13674:	90 91 fc 01 	lds	r25, 0x01FC
   13678:	28 17       	cp	r18, r24
   1367a:	39 07       	cpc	r19, r25
   1367c:	68 f4       	brcc	.+26     	; 0x13698 <PrintIdle+0xc4a>
		      iLoop++;
   1367e:	80 91 f9 01 	lds	r24, 0x01F9
   13682:	90 91 fa 01 	lds	r25, 0x01FA
   13686:	01 96       	adiw	r24, 0x01	; 1
   13688:	90 93 fa 01 	sts	0x01FA, r25
   1368c:	80 93 f9 01 	sts	0x01F9, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
   13690:	10 92 b6 01 	sts	0x01B6, r1
				 stPrintIdle=piCheckPrintStatusMessage;
   13694:	8c e0       	ldi	r24, 0x0C	; 12
   13696:	66 c1       	rjmp	.+716    	; 0x13964 <PrintIdle+0xf16>
				 }
			  }
          else{iMessage++;
   13698:	80 91 01 02 	lds	r24, 0x0201
   1369c:	8f 5f       	subi	r24, 0xFF	; 255
   1369e:	80 93 01 02 	sts	0x0201, r24
		      if (iMessage>MessageLine){
   136a2:	90 91 00 02 	lds	r25, 0x0200
   136a6:	98 17       	cp	r25, r24
   136a8:	30 f4       	brcc	.+12     	; 0x136b6 <PrintIdle+0xc68>
			      iFooter=0;				  
   136aa:	10 92 04 02 	sts	0x0204, r1
				  CarriegeReturn();
   136ae:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
				  stPrintIdle=piLoadOperatorName;//piLoadFooter;
   136b2:	85 e1       	ldi	r24, 0x15	; 21
   136b4:	57 c1       	rjmp	.+686    	; 0x13964 <PrintIdle+0xf16>
			  }
			  else stPrintIdle=piLoadMessage;
   136b6:	89 e0       	ldi	r24, 0x09	; 9
   136b8:	55 c1       	rjmp	.+682    	; 0x13964 <PrintIdle+0xf16>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
   136ba:	80 91 b3 01 	lds	r24, 0x01B3
   136be:	88 23       	and	r24, r24
   136c0:	09 f0       	breq	.+2      	; 0x136c4 <PrintIdle+0xc76>
   136c2:	48 c1       	rjmp	.+656    	; 0x13954 <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   136c4:	e0 91 fd 01 	lds	r30, 0x01FD
   136c8:	f0 91 fe 01 	lds	r31, 0x01FE
   136cc:	e4 54       	subi	r30, 0x44	; 68
   136ce:	f7 4f       	sbci	r31, 0xF7	; 247
   136d0:	61 e0       	ldi	r22, 0x01	; 1
   136d2:	40 81       	ld	r20, Z
   136d4:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   136d8:	80 91 fd 01 	lds	r24, 0x01FD
   136dc:	90 91 fe 01 	lds	r25, 0x01FE
   136e0:	01 96       	adiw	r24, 0x01	; 1
   136e2:	90 93 fe 01 	sts	0x01FE, r25
   136e6:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintMessage;
   136ea:	8a e0       	ldi	r24, 0x0A	; 10
   136ec:	31 c1       	rjmp	.+610    	; 0x13950 <PrintIdle+0xf02>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   136ee:	8e 01       	movw	r16, r28
   136f0:	0f 5f       	subi	r16, 0xFF	; 255
   136f2:	1f 4f       	sbci	r17, 0xFF	; 255
   136f4:	c8 01       	movw	r24, r16
   136f6:	65 e1       	ldi	r22, 0x15	; 21
   136f8:	70 e0       	ldi	r23, 0x00	; 0
   136fa:	42 e1       	ldi	r20, 0x12	; 18
   136fc:	50 e0       	ldi	r21, 0x00	; 0
   136fe:	24 e4       	ldi	r18, 0x44	; 68
   13700:	32 e1       	ldi	r19, 0x12	; 18
   13702:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13706:	ce 01       	movw	r24, r28
   13708:	40 96       	adiw	r24, 0x10	; 16
	    Dest[i]=Source[IdxSource+i];
   1370a:	0f 5f       	subi	r16, 0xFF	; 255
   1370c:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1370e:	08 17       	cp	r16, r24
   13710:	19 07       	cpc	r17, r25
   13712:	d9 f7       	brne	.-10     	; 0x1370a <PrintIdle+0xcbc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13714:	18 8a       	std	Y+16, r1	; 0x10
	//Added Operator Name:
	 case piLoadOperatorName:
	      //CheckEmpty
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);
		  if (strlen(strOperatorName)>0){
   13716:	89 81       	ldd	r24, Y+1	; 0x01
   13718:	88 23       	and	r24, r24
   1371a:	09 f4       	brne	.+2      	; 0x1371e <PrintIdle+0xcd0>
   1371c:	95 c0       	rjmp	.+298    	; 0x13848 <PrintIdle+0xdfa>
			  if (SpaceOnly(strOperatorName)!=True){		      				  
   1371e:	7e 01       	movw	r14, r28
   13720:	08 94       	sec
   13722:	e1 1c       	adc	r14, r1
   13724:	f1 1c       	adc	r15, r1
   13726:	c7 01       	movw	r24, r14
   13728:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   1372c:	81 30       	cpi	r24, 0x01	; 1
   1372e:	09 f4       	brne	.+2      	; 0x13732 <PrintIdle+0xce4>
   13730:	8b c0       	rjmp	.+278    	; 0x13848 <PrintIdle+0xdfa>
				  sprintf_P(strPrint,PSTR("     Operator: %s"),strOperatorName);			   
   13732:	00 d0       	rcall	.+0      	; 0x13734 <PrintIdle+0xce6>
   13734:	00 d0       	rcall	.+0      	; 0x13736 <PrintIdle+0xce8>
   13736:	00 d0       	rcall	.+0      	; 0x13738 <PrintIdle+0xcea>
   13738:	ed b7       	in	r30, 0x3d	; 61
   1373a:	fe b7       	in	r31, 0x3e	; 62
   1373c:	31 96       	adiw	r30, 0x01	; 1
   1373e:	0c eb       	ldi	r16, 0xBC	; 188
   13740:	18 e0       	ldi	r17, 0x08	; 8
   13742:	ad b7       	in	r26, 0x3d	; 61
   13744:	be b7       	in	r27, 0x3e	; 62
   13746:	12 96       	adiw	r26, 0x02	; 2
   13748:	1c 93       	st	X, r17
   1374a:	0e 93       	st	-X, r16
   1374c:	11 97       	sbiw	r26, 0x01	; 1
   1374e:	8c e8       	ldi	r24, 0x8C	; 140
   13750:	95 e0       	ldi	r25, 0x05	; 5
   13752:	93 83       	std	Z+3, r25	; 0x03
   13754:	82 83       	std	Z+2, r24	; 0x02
   13756:	f5 82       	std	Z+5, r15	; 0x05
   13758:	e4 82       	std	Z+4, r14	; 0x04
   1375a:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			      iSend=0;iLoop=0;
   1375e:	10 92 fe 01 	sts	0x01FE, r1
   13762:	10 92 fd 01 	sts	0x01FD, r1
   13766:	10 92 fa 01 	sts	0x01FA, r1
   1376a:	10 92 f9 01 	sts	0x01F9, r1
				  LSend=strlen(strPrint);
   1376e:	f8 01       	movw	r30, r16
   13770:	01 90       	ld	r0, Z+
   13772:	00 20       	and	r0, r0
   13774:	e9 f7       	brne	.-6      	; 0x13770 <PrintIdle+0xd22>
   13776:	8f 01       	movw	r16, r30
   13778:	01 50       	subi	r16, 0x01	; 1
   1377a:	10 40       	sbci	r17, 0x00	; 0
   1377c:	0c 5b       	subi	r16, 0xBC	; 188
   1377e:	18 40       	sbci	r17, 0x08	; 8
   13780:	10 93 fc 01 	sts	0x01FC, r17
   13784:	00 93 fb 01 	sts	0x01FB, r16
				  stPrintIdle=piPrintOperatorName;
   13788:	86 e1       	ldi	r24, 0x16	; 22
   1378a:	80 93 06 02 	sts	0x0206, r24
   1378e:	8d b7       	in	r24, 0x3d	; 61
   13790:	9e b7       	in	r25, 0x3e	; 62
   13792:	06 96       	adiw	r24, 0x06	; 6
   13794:	0f b6       	in	r0, 0x3f	; 63
   13796:	f8 94       	cli
   13798:	9e bf       	out	0x3e, r25	; 62
   1379a:	0f be       	out	0x3f, r0	; 63
   1379c:	8d bf       	out	0x3d, r24	; 61
   1379e:	0d c1       	rjmp	.+538    	; 0x139ba <PrintIdle+0xf6c>
			  }else stPrintIdle=piLoadFooter;
          }  
          else stPrintIdle=piLoadFooter;
	      break;
	 case piPrintOperatorName:
		  if (iSend<LSend){
   137a0:	20 91 fd 01 	lds	r18, 0x01FD
   137a4:	30 91 fe 01 	lds	r19, 0x01FE
   137a8:	80 91 fb 01 	lds	r24, 0x01FB
   137ac:	90 91 fc 01 	lds	r25, 0x01FC
   137b0:	28 17       	cp	r18, r24
   137b2:	39 07       	cpc	r19, r25
   137b4:	68 f4       	brcc	.+26     	; 0x137d0 <PrintIdle+0xd82>
		      iLoop++;
   137b6:	80 91 f9 01 	lds	r24, 0x01F9
   137ba:	90 91 fa 01 	lds	r25, 0x01FA
   137be:	01 96       	adiw	r24, 0x01	; 1
   137c0:	90 93 fa 01 	sts	0x01FA, r25
   137c4:	80 93 f9 01 	sts	0x01F9, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
   137c8:	10 92 b6 01 	sts	0x01B6, r1
				  stPrintIdle=piCheckPrintOperatorName;
   137cc:	87 e1       	ldi	r24, 0x17	; 23
   137ce:	ca c0       	rjmp	.+404    	; 0x13964 <PrintIdle+0xf16>
				}
			  }
          else {
			  CarriegeReturn();
   137d0:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
			  CarriegeReturn();
   137d4:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   137d8:	37 c0       	rjmp	.+110    	; 0x13848 <PrintIdle+0xdfa>
			  stPrintIdle=piLoadFooter;
			  }
	      break;
	 case piCheckPrintOperatorName:
	      if (IsBusyPrint==False){
   137da:	80 91 b3 01 	lds	r24, 0x01B3
   137de:	88 23       	and	r24, r24
   137e0:	09 f0       	breq	.+2      	; 0x137e4 <PrintIdle+0xd96>
   137e2:	b8 c0       	rjmp	.+368    	; 0x13954 <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   137e4:	e0 91 fd 01 	lds	r30, 0x01FD
   137e8:	f0 91 fe 01 	lds	r31, 0x01FE
   137ec:	e4 54       	subi	r30, 0x44	; 68
   137ee:	f7 4f       	sbci	r31, 0xF7	; 247
   137f0:	61 e0       	ldi	r22, 0x01	; 1
   137f2:	40 81       	ld	r20, Z
   137f4:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   137f8:	80 91 fd 01 	lds	r24, 0x01FD
   137fc:	90 91 fe 01 	lds	r25, 0x01FE
   13800:	01 96       	adiw	r24, 0x01	; 1
   13802:	90 93 fe 01 	sts	0x01FE, r25
   13806:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintOperatorName;
   1380a:	86 e1       	ldi	r24, 0x16	; 22
   1380c:	a1 c0       	rjmp	.+322    	; 0x13950 <PrintIdle+0xf02>
   1380e:	60 91 04 02 	lds	r22, 0x0204
   13812:	89 e2       	ldi	r24, 0x29	; 41
   13814:	68 9f       	mul	r22, r24
   13816:	b0 01       	movw	r22, r0
   13818:	11 24       	eor	r1, r1
   1381a:	63 5e       	subi	r22, 0xE3	; 227
   1381c:	7c 4f       	sbci	r23, 0xFC	; 252
   1381e:	8c eb       	ldi	r24, 0xBC	; 188
   13820:	98 e0       	ldi	r25, 0x08	; 8
   13822:	48 e2       	ldi	r20, 0x28	; 40
   13824:	50 e0       	ldi	r21, 0x00	; 0
   13826:	24 e4       	ldi	r18, 0x44	; 68
   13828:	32 e1       	ldi	r19, 0x12	; 18
   1382a:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>

	 	       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
   1382e:	80 91 04 02 	lds	r24, 0x0204
   13832:	8f 5f       	subi	r24, 0xFF	; 255
   13834:	80 93 04 02 	sts	0x0204, r24
		  if (iFooter<=4){
   13838:	85 30       	cpi	r24, 0x05	; 5
   1383a:	90 f4       	brcc	.+36     	; 0x13860 <PrintIdle+0xe12>
		      if (SpaceOnly(strPrint)==True){
   1383c:	8c eb       	ldi	r24, 0xBC	; 188
   1383e:	98 e0       	ldi	r25, 0x08	; 8
   13840:	0e 94 1a 22 	call	0x4434	; 0x4434 <SpaceOnly>
   13844:	81 30       	cpi	r24, 0x01	; 1
   13846:	11 f4       	brne	.+4      	; 0x1384c <PrintIdle+0xdfe>
			      stPrintIdle=piLoadFooter;
   13848:	8e e0       	ldi	r24, 0x0E	; 14
   1384a:	8c c0       	rjmp	.+280    	; 0x13964 <PrintIdle+0xf16>
				  }
			  else{
			      iSend=0;
   1384c:	10 92 fe 01 	sts	0x01FE, r1
   13850:	10 92 fd 01 	sts	0x01FD, r1
				  iLoop=0;
   13854:	10 92 fa 01 	sts	0x01FA, r1
   13858:	10 92 f9 01 	sts	0x01F9, r1
				  stPrintIdle=piPrintFooter;
   1385c:	8f e0       	ldi	r24, 0x0F	; 15
   1385e:	82 c0       	rjmp	.+260    	; 0x13964 <PrintIdle+0xf16>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
   13860:	81 e1       	ldi	r24, 0x11	; 17
   13862:	80 c0       	rjmp	.+256    	; 0x13964 <PrintIdle+0xf16>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
   13864:	80 91 fd 01 	lds	r24, 0x01FD
   13868:	90 91 fe 01 	lds	r25, 0x01FE
   1386c:	88 97       	sbiw	r24, 0x28	; 40
   1386e:	68 f4       	brcc	.+26     	; 0x1388a <PrintIdle+0xe3c>
		      iLoop++;
   13870:	80 91 f9 01 	lds	r24, 0x01F9
   13874:	90 91 fa 01 	lds	r25, 0x01FA
   13878:	01 96       	adiw	r24, 0x01	; 1
   1387a:	90 93 fa 01 	sts	0x01FA, r25
   1387e:	80 93 f9 01 	sts	0x01F9, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
   13882:	10 92 b6 01 	sts	0x01B6, r1
				stPrintIdle=piCheckPrintStatusFooter;
   13886:	8d e0       	ldi	r24, 0x0D	; 13
   13888:	6d c0       	rjmp	.+218    	; 0x13964 <PrintIdle+0xf16>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
   1388a:	8e e0       	ldi	r24, 0x0E	; 14
   1388c:	80 93 06 02 	sts	0x0206, r24
			  CarriegeReturn();
   13890:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
   13894:	92 c0       	rjmp	.+292    	; 0x139ba <PrintIdle+0xf6c>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
   13896:	80 91 b3 01 	lds	r24, 0x01B3
   1389a:	88 23       	and	r24, r24
   1389c:	09 f0       	breq	.+2      	; 0x138a0 <PrintIdle+0xe52>
   1389e:	5a c0       	rjmp	.+180    	; 0x13954 <PrintIdle+0xf06>
		      uart(_COM_PRINTER,1,strPrint[iSend]);
   138a0:	e0 91 fd 01 	lds	r30, 0x01FD
   138a4:	f0 91 fe 01 	lds	r31, 0x01FE
   138a8:	e4 54       	subi	r30, 0x44	; 68
   138aa:	f7 4f       	sbci	r31, 0xF7	; 247
   138ac:	61 e0       	ldi	r22, 0x01	; 1
   138ae:	40 81       	ld	r20, Z
   138b0:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		      iSend++;
   138b4:	80 91 fd 01 	lds	r24, 0x01FD
   138b8:	90 91 fe 01 	lds	r25, 0x01FE
   138bc:	01 96       	adiw	r24, 0x01	; 1
   138be:	90 93 fe 01 	sts	0x01FE, r25
   138c2:	80 93 fd 01 	sts	0x01FD, r24
		      stPrintIdle=piPrintFooter;
   138c6:	8f e0       	ldi	r24, 0x0F	; 15
   138c8:	43 c0       	rjmp	.+134    	; 0x13950 <PrintIdle+0xf02>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
   138ca:	90 91 f8 01 	lds	r25, 0x01F8
   138ce:	9f 5f       	subi	r25, 0xFF	; 255
   138d0:	90 93 f8 01 	sts	0x01F8, r25
		  iScroll=0;
   138d4:	10 92 03 02 	sts	0x0203, r1
		  iLoop=0;
   138d8:	10 92 fa 01 	sts	0x01FA, r1
   138dc:	10 92 f9 01 	sts	0x01F9, r1
		  if (iPrinted<PrintCopy){
   138e0:	80 91 f7 01 	lds	r24, 0x01F7
   138e4:	98 17       	cp	r25, r24
   138e6:	28 f4       	brcc	.+10     	; 0x138f2 <PrintIdle+0xea4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   138e8:	e1 99       	sbic	0x1c, 1	; 28
   138ea:	fe cf       	rjmp	.-4      	; 0x138e8 <PrintIdle+0xe9a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   138ec:	82 e3       	ldi	r24, 0x32	; 50
   138ee:	90 e0       	ldi	r25, 0x00	; 0
   138f0:	04 c0       	rjmp	.+8      	; 0x138fa <PrintIdle+0xeac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   138f2:	e1 99       	sbic	0x1c, 1	; 28
   138f4:	fe cf       	rjmp	.-4      	; 0x138f2 <PrintIdle+0xea4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   138f6:	81 e3       	ldi	r24, 0x31	; 49
   138f8:	90 e0       	ldi	r25, 0x00	; 0
   138fa:	9f bb       	out	0x1f, r25	; 31
   138fc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   138fe:	e0 9a       	sbi	0x1c, 0	; 28
   13900:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
   13902:	80 93 02 02 	sts	0x0202, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
   13906:	80 e1       	ldi	r24, 0x10	; 16
   13908:	2d c0       	rjmp	.+90     	; 0x13964 <PrintIdle+0xf16>
	      break;
     case piScrollPaper:
	      iLoop++;
   1390a:	80 91 f9 01 	lds	r24, 0x01F9
   1390e:	90 91 fa 01 	lds	r25, 0x01FA
   13912:	01 96       	adiw	r24, 0x01	; 1
   13914:	90 93 fa 01 	sts	0x01FA, r25
   13918:	80 93 f9 01 	sts	0x01F9, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
   1391c:	10 92 b6 01 	sts	0x01B6, r1
			  stPrintIdle=piCheckPrintStatusScroll;
   13920:	82 e1       	ldi	r24, 0x12	; 18
   13922:	80 93 06 02 	sts	0x0206, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
   13926:	90 91 03 02 	lds	r25, 0x0203
   1392a:	80 91 02 02 	lds	r24, 0x0202
   1392e:	89 17       	cp	r24, r25
   13930:	08 f0       	brcs	.+2      	; 0x13934 <PrintIdle+0xee6>
   13932:	43 c0       	rjmp	.+134    	; 0x139ba <PrintIdle+0xf6c>
   13934:	83 e1       	ldi	r24, 0x13	; 19
   13936:	16 c0       	rjmp	.+44     	; 0x13964 <PrintIdle+0xf16>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
   13938:	80 91 b3 01 	lds	r24, 0x01B3
   1393c:	88 23       	and	r24, r24
   1393e:	51 f4       	brne	.+20     	; 0x13954 <PrintIdle+0xf06>
		      iScroll++;
   13940:	80 91 03 02 	lds	r24, 0x0203
   13944:	8f 5f       	subi	r24, 0xFF	; 255
   13946:	80 93 03 02 	sts	0x0203, r24
		      CarriegeReturn();
   1394a:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
   1394e:	80 e1       	ldi	r24, 0x10	; 16
   13950:	80 93 06 02 	sts	0x0206, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
   13954:	80 91 b6 01 	lds	r24, 0x01B6
   13958:	8b 30       	cpi	r24, 0x0B	; 11
   1395a:	78 f1       	brcs	.+94     	; 0x139ba <PrintIdle+0xf6c>
		      IsPrintERROR=True;
   1395c:	81 e0       	ldi	r24, 0x01	; 1
   1395e:	80 93 b1 01 	sts	0x01B1, r24
		      stPrintIdle=piFinishPrintIdle;
   13962:	84 e1       	ldi	r24, 0x14	; 20
   13964:	80 93 06 02 	sts	0x0206, r24
   13968:	28 c0       	rjmp	.+80     	; 0x139ba <PrintIdle+0xf6c>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
   1396a:	90 91 f8 01 	lds	r25, 0x01F8
   1396e:	80 91 f7 01 	lds	r24, 0x01F7
   13972:	98 17       	cp	r25, r24
   13974:	10 f0       	brcs	.+4      	; 0x1397a <PrintIdle+0xf2c>
		      stPrintIdle=piFinishPrintIdle;
   13976:	84 e1       	ldi	r24, 0x14	; 20
   13978:	05 c0       	rjmp	.+10     	; 0x13984 <PrintIdle+0xf36>
			  }
		  else {CarriegeReturn();
   1397a:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		        CarriegeReturn();
   1397e:	0e 94 89 42 	call	0x8512	; 0x8512 <CarriegeReturn>
		        stPrintIdle=piInit;
   13982:	81 e0       	ldi	r24, 0x01	; 1
   13984:	80 93 06 02 	sts	0x0206, r24
		       }
		  PaperCut();
   13988:	0e 94 30 43 	call	0x8660	; 0x8660 <PaperCut>
   1398c:	16 c0       	rjmp	.+44     	; 0x139ba <PrintIdle+0xf6c>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
   1398e:	80 91 00 01 	lds	r24, 0x0100
   13992:	81 30       	cpi	r24, 0x01	; 1
   13994:	19 f0       	breq	.+6      	; 0x1399c <PrintIdle+0xf4e>
   13996:	82 30       	cpi	r24, 0x02	; 2
   13998:	61 f4       	brne	.+24     	; 0x139b2 <PrintIdle+0xf64>
   1399a:	03 c0       	rjmp	.+6      	; 0x139a2 <PrintIdle+0xf54>
		  case IT_SLAVE:
		       sendMessage04();
   1399c:	0e 94 72 91 	call	0x122e4	; 0x122e4 <sendMessage04>
   139a0:	08 c0       	rjmp	.+16     	; 0x139b2 <PrintIdle+0xf64>
		       break;
		  case IT_STANDALONE:		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
   139a2:	89 eb       	ldi	r24, 0xB9	; 185
   139a4:	97 e0       	ldi	r25, 0x07	; 7
   139a6:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
   139aa:	8f 70       	andi	r24, 0x0F	; 15
   139ac:	61 e1       	ldi	r22, 0x11	; 17
   139ae:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <UpdateStandaloneStatus>
			   //CurrentPumpStatus[FIPAddr]=PUMP_OFF;
			   //strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);			   
			   //IsNewPumpStatus=True;//UpdateDisplay
		       break;
		  }
		  IsBusyIdlePrinting=False;
   139b2:	10 92 b2 01 	sts	0x01B2, r1
          stPrintIdle=piIdle;
   139b6:	10 92 06 02 	sts	0x0206, r1
	      break;	 
	 }
}
   139ba:	64 96       	adiw	r28, 0x14	; 20
   139bc:	0f b6       	in	r0, 0x3f	; 63
   139be:	f8 94       	cli
   139c0:	de bf       	out	0x3e, r29	; 62
   139c2:	0f be       	out	0x3f, r0	; 63
   139c4:	cd bf       	out	0x3d, r28	; 61
   139c6:	cf 91       	pop	r28
   139c8:	df 91       	pop	r29
   139ca:	1f 91       	pop	r17
   139cc:	0f 91       	pop	r16
   139ce:	ff 90       	pop	r15
   139d0:	ef 90       	pop	r14
   139d2:	08 95       	ret

000139d4 <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
   139d4:	0e 94 76 91 	call	0x122ec	; 0x122ec <FreePrinting>
	 PrintIdle();
   139d8:	0e 94 27 95 	call	0x12a4e	; 0x12a4e <PrintIdle>
}
   139dc:	08 95       	ret

000139de <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
   139de:	8f 92       	push	r8
   139e0:	9f 92       	push	r9
   139e2:	af 92       	push	r10
   139e4:	bf 92       	push	r11
   139e6:	cf 92       	push	r12
   139e8:	df 92       	push	r13
   139ea:	ef 92       	push	r14
   139ec:	ff 92       	push	r15
   139ee:	0f 93       	push	r16
   139f0:	1f 93       	push	r17
   139f2:	df 93       	push	r29
   139f4:	cf 93       	push	r28
   139f6:	cd b7       	in	r28, 0x3d	; 61
   139f8:	de b7       	in	r29, 0x3e	; 62
   139fa:	c5 56       	subi	r28, 0x65	; 101
   139fc:	d0 40       	sbci	r29, 0x00	; 0
   139fe:	0f b6       	in	r0, 0x3f	; 63
   13a00:	f8 94       	cli
   13a02:	de bf       	out	0x3e, r29	; 62
   13a04:	0f be       	out	0x3f, r0	; 63
   13a06:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 uart_printf(1,0,PSTR("<"));
   13a08:	81 e0       	ldi	r24, 0x01	; 1
   13a0a:	60 e0       	ldi	r22, 0x00	; 0
   13a0c:	44 e1       	ldi	r20, 0x14	; 20
   13a0e:	51 e2       	ldi	r21, 0x21	; 33
   13a10:	0e 94 93 a8 	call	0x15126	; 0x15126 <uart_printf>
   13a14:	07 e2       	ldi	r16, 0x27	; 39
   13a16:	12 e0       	ldi	r17, 0x02	; 2
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   13a18:	6e 01       	movw	r12, r28
   13a1a:	08 94       	sec
   13a1c:	c1 1c       	adc	r12, r1
   13a1e:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   13a20:	8a e2       	ldi	r24, 0x2A	; 42
   13a22:	e8 2e       	mov	r14, r24
   13a24:	f1 2c       	mov	r15, r1
   13a26:	ec 0e       	add	r14, r28
   13a28:	fd 1e       	adc	r15, r29
   13a2a:	b1 e1       	ldi	r27, 0x11	; 17
   13a2c:	ab 2e       	mov	r10, r27
   13a2e:	b1 e2       	ldi	r27, 0x21	; 33
   13a30:	bb 2e       	mov	r11, r27
   13a32:	c6 01       	movw	r24, r12
   13a34:	b8 01       	movw	r22, r16
   13a36:	49 e2       	ldi	r20, 0x29	; 41
   13a38:	50 e0       	ldi	r21, 0x00	; 0
   13a3a:	24 e4       	ldi	r18, 0x44	; 68
   13a3c:	32 e1       	ldi	r19, 0x12	; 18
   13a3e:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
   13a42:	00 d0       	rcall	.+0      	; 0x13a44 <SendConfigParamater+0x66>
   13a44:	00 d0       	rcall	.+0      	; 0x13a46 <SendConfigParamater+0x68>
   13a46:	00 d0       	rcall	.+0      	; 0x13a48 <SendConfigParamater+0x6a>
   13a48:	ed b7       	in	r30, 0x3d	; 61
   13a4a:	fe b7       	in	r31, 0x3e	; 62
   13a4c:	31 96       	adiw	r30, 0x01	; 1
   13a4e:	ad b7       	in	r26, 0x3d	; 61
   13a50:	be b7       	in	r27, 0x3e	; 62
   13a52:	12 96       	adiw	r26, 0x02	; 2
   13a54:	fc 92       	st	X, r15
   13a56:	ee 92       	st	-X, r14
   13a58:	11 97       	sbiw	r26, 0x01	; 1
   13a5a:	b3 82       	std	Z+3, r11	; 0x03
   13a5c:	a2 82       	std	Z+2, r10	; 0x02
   13a5e:	d5 82       	std	Z+5, r13	; 0x05
   13a60:	c4 82       	std	Z+4, r12	; 0x04
   13a62:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  AddSpaceLag(strSend,40);
   13a66:	ed b7       	in	r30, 0x3d	; 61
   13a68:	fe b7       	in	r31, 0x3e	; 62
   13a6a:	36 96       	adiw	r30, 0x06	; 6
   13a6c:	0f b6       	in	r0, 0x3f	; 63
   13a6e:	f8 94       	cli
   13a70:	fe bf       	out	0x3e, r31	; 62
   13a72:	0f be       	out	0x3f, r0	; 63
   13a74:	ed bf       	out	0x3d, r30	; 61
   13a76:	c7 01       	movw	r24, r14
   13a78:	68 e2       	ldi	r22, 0x28	; 40
   13a7a:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
		  uart_print(1,0,strSend);
   13a7e:	81 e0       	ldi	r24, 0x01	; 1
   13a80:	60 e0       	ldi	r22, 0x00	; 0
   13a82:	a7 01       	movw	r20, r14
   13a84:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
   13a88:	07 5d       	subi	r16, 0xD7	; 215
   13a8a:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   13a8c:	f3 e0       	ldi	r31, 0x03	; 3
   13a8e:	01 3c       	cpi	r16, 0xC1	; 193
   13a90:	1f 07       	cpc	r17, r31
   13a92:	79 f6       	brne	.-98     	; 0x13a32 <SendConfigParamater+0x54>
   13a94:	0b eb       	ldi	r16, 0xBB	; 187
   13a96:	10 e0       	ldi	r17, 0x00	; 0
   13a98:	6e 01       	movw	r12, r28
   13a9a:	08 94       	sec
   13a9c:	c1 1c       	adc	r12, r1
   13a9e:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   13aa0:	aa e2       	ldi	r26, 0x2A	; 42
   13aa2:	ea 2e       	mov	r14, r26
   13aa4:	f1 2c       	mov	r15, r1
   13aa6:	ec 0e       	add	r14, r28
   13aa8:	fd 1e       	adc	r15, r29
   13aaa:	fe e0       	ldi	r31, 0x0E	; 14
   13aac:	af 2e       	mov	r10, r31
   13aae:	f1 e2       	ldi	r31, 0x21	; 33
   13ab0:	bf 2e       	mov	r11, r31
   13ab2:	c6 01       	movw	r24, r12
   13ab4:	b8 01       	movw	r22, r16
   13ab6:	4d e0       	ldi	r20, 0x0D	; 13
   13ab8:	50 e0       	ldi	r21, 0x00	; 0
   13aba:	24 e4       	ldi	r18, 0x44	; 68
   13abc:	32 e1       	ldi	r19, 0x12	; 18
   13abe:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
   13ac2:	00 d0       	rcall	.+0      	; 0x13ac4 <SendConfigParamater+0xe6>
   13ac4:	00 d0       	rcall	.+0      	; 0x13ac6 <SendConfigParamater+0xe8>
   13ac6:	00 d0       	rcall	.+0      	; 0x13ac8 <SendConfigParamater+0xea>
   13ac8:	ed b7       	in	r30, 0x3d	; 61
   13aca:	fe b7       	in	r31, 0x3e	; 62
   13acc:	31 96       	adiw	r30, 0x01	; 1
   13ace:	ad b7       	in	r26, 0x3d	; 61
   13ad0:	be b7       	in	r27, 0x3e	; 62
   13ad2:	12 96       	adiw	r26, 0x02	; 2
   13ad4:	fc 92       	st	X, r15
   13ad6:	ee 92       	st	-X, r14
   13ad8:	11 97       	sbiw	r26, 0x01	; 1
   13ada:	b3 82       	std	Z+3, r11	; 0x03
   13adc:	a2 82       	std	Z+2, r10	; 0x02
   13ade:	d5 82       	std	Z+5, r13	; 0x05
   13ae0:	c4 82       	std	Z+4, r12	; 0x04
   13ae2:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 AddSpaceLag(strSend,12);
   13ae6:	ed b7       	in	r30, 0x3d	; 61
   13ae8:	fe b7       	in	r31, 0x3e	; 62
   13aea:	36 96       	adiw	r30, 0x06	; 6
   13aec:	0f b6       	in	r0, 0x3f	; 63
   13aee:	f8 94       	cli
   13af0:	fe bf       	out	0x3e, r31	; 62
   13af2:	0f be       	out	0x3f, r0	; 63
   13af4:	ed bf       	out	0x3d, r30	; 61
   13af6:	c7 01       	movw	r24, r14
   13af8:	6c e0       	ldi	r22, 0x0C	; 12
   13afa:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
		 uart_print(1,0,strSend);
   13afe:	81 e0       	ldi	r24, 0x01	; 1
   13b00:	60 e0       	ldi	r22, 0x00	; 0
   13b02:	a7 01       	movw	r20, r14
   13b04:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
   13b08:	03 5f       	subi	r16, 0xF3	; 243
   13b0a:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   13b0c:	f1 e0       	ldi	r31, 0x01	; 1
   13b0e:	09 30       	cpi	r16, 0x09	; 9
   13b10:	1f 07       	cpc	r17, r31
   13b12:	79 f6       	brne	.-98     	; 0x13ab2 <SendConfigParamater+0xd4>
   13b14:	05 e8       	ldi	r16, 0x85	; 133
   13b16:	10 e0       	ldi	r17, 0x00	; 0
   13b18:	6e 01       	movw	r12, r28
   13b1a:	08 94       	sec
   13b1c:	c1 1c       	adc	r12, r1
   13b1e:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   13b20:	ea e2       	ldi	r30, 0x2A	; 42
   13b22:	ee 2e       	mov	r14, r30
   13b24:	f1 2c       	mov	r15, r1
   13b26:	ec 0e       	add	r14, r28
   13b28:	fd 1e       	adc	r15, r29
   13b2a:	7b e0       	ldi	r23, 0x0B	; 11
   13b2c:	a7 2e       	mov	r10, r23
   13b2e:	71 e2       	ldi	r23, 0x21	; 33
   13b30:	b7 2e       	mov	r11, r23
   13b32:	c6 01       	movw	r24, r12
   13b34:	b8 01       	movw	r22, r16
   13b36:	49 e0       	ldi	r20, 0x09	; 9
   13b38:	50 e0       	ldi	r21, 0x00	; 0
   13b3a:	24 e4       	ldi	r18, 0x44	; 68
   13b3c:	32 e1       	ldi	r19, 0x12	; 18
   13b3e:	0e 94 ec a9 	call	0x153d8	; 0x153d8 <__eerd_block>
   13b42:	00 d0       	rcall	.+0      	; 0x13b44 <SendConfigParamater+0x166>
   13b44:	00 d0       	rcall	.+0      	; 0x13b46 <SendConfigParamater+0x168>
   13b46:	00 d0       	rcall	.+0      	; 0x13b48 <SendConfigParamater+0x16a>
   13b48:	ed b7       	in	r30, 0x3d	; 61
   13b4a:	fe b7       	in	r31, 0x3e	; 62
   13b4c:	31 96       	adiw	r30, 0x01	; 1
   13b4e:	ad b7       	in	r26, 0x3d	; 61
   13b50:	be b7       	in	r27, 0x3e	; 62
   13b52:	12 96       	adiw	r26, 0x02	; 2
   13b54:	fc 92       	st	X, r15
   13b56:	ee 92       	st	-X, r14
   13b58:	11 97       	sbiw	r26, 0x01	; 1
   13b5a:	b3 82       	std	Z+3, r11	; 0x03
   13b5c:	a2 82       	std	Z+2, r10	; 0x02
   13b5e:	d5 82       	std	Z+5, r13	; 0x05
   13b60:	c4 82       	std	Z+4, r12	; 0x04
   13b62:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		 AddSpaceLag(strSend,5);
   13b66:	ed b7       	in	r30, 0x3d	; 61
   13b68:	fe b7       	in	r31, 0x3e	; 62
   13b6a:	36 96       	adiw	r30, 0x06	; 6
   13b6c:	0f b6       	in	r0, 0x3f	; 63
   13b6e:	f8 94       	cli
   13b70:	fe bf       	out	0x3e, r31	; 62
   13b72:	0f be       	out	0x3f, r0	; 63
   13b74:	ed bf       	out	0x3d, r30	; 61
   13b76:	c7 01       	movw	r24, r14
   13b78:	65 e0       	ldi	r22, 0x05	; 5
   13b7a:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
		 uart_print(1,0,strSend);
   13b7e:	81 e0       	ldi	r24, 0x01	; 1
   13b80:	60 e0       	ldi	r22, 0x00	; 0
   13b82:	a7 01       	movw	r20, r14
   13b84:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
   13b88:	07 5f       	subi	r16, 0xF7	; 247
   13b8a:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   13b8c:	f0 e0       	ldi	r31, 0x00	; 0
   13b8e:	0b 3b       	cpi	r16, 0xBB	; 187
   13b90:	1f 07       	cpc	r17, r31
   13b92:	79 f6       	brne	.-98     	; 0x13b32 <SendConfigParamater+0x154>
   13b94:	05 e4       	ldi	r16, 0x45	; 69
   13b96:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   13b98:	6a e2       	ldi	r22, 0x2A	; 42
   13b9a:	e6 2e       	mov	r14, r22
   13b9c:	f1 2c       	mov	r15, r1
   13b9e:	ec 0e       	add	r14, r28
   13ba0:	fd 1e       	adc	r15, r29
   13ba2:	56 e0       	ldi	r21, 0x06	; 6
   13ba4:	c5 2e       	mov	r12, r21
   13ba6:	51 e2       	ldi	r21, 0x21	; 33
   13ba8:	d5 2e       	mov	r13, r21
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13baa:	e1 99       	sbic	0x1c, 1	; 28
   13bac:	fe cf       	rjmp	.-4      	; 0x13baa <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13bae:	1f bb       	out	0x1f, r17	; 31
   13bb0:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13bb2:	e0 9a       	sbi	0x1c, 0	; 28
   13bb4:	8d b3       	in	r24, 0x1d	; 29
		 uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   13bb6:	84 36       	cpi	r24, 0x64	; 100
   13bb8:	08 f0       	brcs	.+2      	; 0x13bbc <SendConfigParamater+0x1de>
   13bba:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   13bbc:	00 d0       	rcall	.+0      	; 0x13bbe <SendConfigParamater+0x1e0>
   13bbe:	00 d0       	rcall	.+0      	; 0x13bc0 <SendConfigParamater+0x1e2>
   13bc0:	00 d0       	rcall	.+0      	; 0x13bc2 <SendConfigParamater+0x1e4>
   13bc2:	ed b7       	in	r30, 0x3d	; 61
   13bc4:	fe b7       	in	r31, 0x3e	; 62
   13bc6:	31 96       	adiw	r30, 0x01	; 1
   13bc8:	ad b7       	in	r26, 0x3d	; 61
   13bca:	be b7       	in	r27, 0x3e	; 62
   13bcc:	12 96       	adiw	r26, 0x02	; 2
   13bce:	fc 92       	st	X, r15
   13bd0:	ee 92       	st	-X, r14
   13bd2:	11 97       	sbiw	r26, 0x01	; 1
   13bd4:	d3 82       	std	Z+3, r13	; 0x03
   13bd6:	c2 82       	std	Z+2, r12	; 0x02
   13bd8:	84 83       	std	Z+4, r24	; 0x04
   13bda:	15 82       	std	Z+5, r1	; 0x05
   13bdc:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  AddSpaceLag(strSend,2);
   13be0:	ed b7       	in	r30, 0x3d	; 61
   13be2:	fe b7       	in	r31, 0x3e	; 62
   13be4:	36 96       	adiw	r30, 0x06	; 6
   13be6:	0f b6       	in	r0, 0x3f	; 63
   13be8:	f8 94       	cli
   13bea:	fe bf       	out	0x3e, r31	; 62
   13bec:	0f be       	out	0x3f, r0	; 63
   13bee:	ed bf       	out	0x3d, r30	; 61
   13bf0:	c7 01       	movw	r24, r14
   13bf2:	62 e0       	ldi	r22, 0x02	; 2
   13bf4:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
		 uart_print(1,0,strSend);
   13bf8:	81 e0       	ldi	r24, 0x01	; 1
   13bfa:	60 e0       	ldi	r22, 0x00	; 0
   13bfc:	a7 01       	movw	r20, r14
   13bfe:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
   13c02:	0f 5f       	subi	r16, 0xFF	; 255
   13c04:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   13c06:	f0 e0       	ldi	r31, 0x00	; 0
   13c08:	0d 34       	cpi	r16, 0x4D	; 77
   13c0a:	1f 07       	cpc	r17, r31
   13c0c:	71 f6       	brne	.-100    	; 0x13baa <SendConfigParamater+0x1cc>
   13c0e:	45 e5       	ldi	r20, 0x55	; 85
   13c10:	e4 2e       	mov	r14, r20
   13c12:	40 e0       	ldi	r20, 0x00	; 0
   13c14:	f4 2e       	mov	r15, r20
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   13c16:	3a e2       	ldi	r19, 0x2A	; 42
   13c18:	a3 2e       	mov	r10, r19
   13c1a:	b1 2c       	mov	r11, r1
   13c1c:	ac 0e       	add	r10, r28
   13c1e:	bd 1e       	adc	r11, r29
   13c20:	23 e0       	ldi	r18, 0x03	; 3
   13c22:	82 2e       	mov	r8, r18
   13c24:	21 e2       	ldi	r18, 0x21	; 33
   13c26:	92 2e       	mov	r9, r18
   13c28:	37 c0       	rjmp	.+110    	; 0x13c98 <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13c2a:	e1 99       	sbic	0x1c, 1	; 28
   13c2c:	fe cf       	rjmp	.-4      	; 0x13c2a <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13c2e:	1f bb       	out	0x1f, r17	; 31
   13c30:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13c32:	e0 9a       	sbi	0x1c, 0	; 28
   13c34:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   13c36:	8a 30       	cpi	r24, 0x0A	; 10
   13c38:	08 f0       	brcs	.+2      	; 0x13c3c <SendConfigParamater+0x25e>
   13c3a:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   13c3c:	00 d0       	rcall	.+0      	; 0x13c3e <SendConfigParamater+0x260>
   13c3e:	00 d0       	rcall	.+0      	; 0x13c40 <SendConfigParamater+0x262>
   13c40:	00 d0       	rcall	.+0      	; 0x13c42 <SendConfigParamater+0x264>
   13c42:	ed b7       	in	r30, 0x3d	; 61
   13c44:	fe b7       	in	r31, 0x3e	; 62
   13c46:	31 96       	adiw	r30, 0x01	; 1
   13c48:	ad b7       	in	r26, 0x3d	; 61
   13c4a:	be b7       	in	r27, 0x3e	; 62
   13c4c:	12 96       	adiw	r26, 0x02	; 2
   13c4e:	bc 92       	st	X, r11
   13c50:	ae 92       	st	-X, r10
   13c52:	11 97       	sbiw	r26, 0x01	; 1
   13c54:	93 82       	std	Z+3, r9	; 0x03
   13c56:	82 82       	std	Z+2, r8	; 0x02
   13c58:	84 83       	std	Z+4, r24	; 0x04
   13c5a:	15 82       	std	Z+5, r1	; 0x05
   13c5c:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
			   uart_print(1,0,strSend);
   13c60:	ed b7       	in	r30, 0x3d	; 61
   13c62:	fe b7       	in	r31, 0x3e	; 62
   13c64:	36 96       	adiw	r30, 0x06	; 6
   13c66:	0f b6       	in	r0, 0x3f	; 63
   13c68:	f8 94       	cli
   13c6a:	fe bf       	out	0x3e, r31	; 62
   13c6c:	0f be       	out	0x3f, r0	; 63
   13c6e:	ed bf       	out	0x3d, r30	; 61
   13c70:	81 e0       	ldi	r24, 0x01	; 1
   13c72:	60 e0       	ldi	r22, 0x00	; 0
   13c74:	a5 01       	movw	r20, r10
   13c76:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   13c7a:	d3 94       	inc	r13
   13c7c:	0f 5f       	subi	r16, 0xFF	; 255
   13c7e:	1f 4f       	sbci	r17, 0xFF	; 255
   13c80:	f6 e0       	ldi	r31, 0x06	; 6
   13c82:	df 16       	cp	r13, r31
   13c84:	91 f6       	brne	.-92     	; 0x13c2a <SendConfigParamater+0x24c>
   13c86:	86 e0       	ldi	r24, 0x06	; 6
   13c88:	90 e0       	ldi	r25, 0x00	; 0
   13c8a:	e8 0e       	add	r14, r24
   13c8c:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   13c8e:	95 e8       	ldi	r25, 0x85	; 133
   13c90:	e9 16       	cp	r14, r25
   13c92:	90 e0       	ldi	r25, 0x00	; 0
   13c94:	f9 06       	cpc	r15, r25
   13c96:	19 f0       	breq	.+6      	; 0x13c9e <SendConfigParamater+0x2c0>
   13c98:	87 01       	movw	r16, r14
   13c9a:	dd 24       	eor	r13, r13
   13c9c:	c6 cf       	rjmp	.-116    	; 0x13c2a <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13c9e:	e1 99       	sbic	0x1c, 1	; 28
   13ca0:	fe cf       	rjmp	.-4      	; 0x13c9e <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13ca2:	81 ec       	ldi	r24, 0xC1	; 193
   13ca4:	93 e0       	ldi	r25, 0x03	; 3
   13ca6:	9f bb       	out	0x1f, r25	; 31
   13ca8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13caa:	e0 9a       	sbi	0x1c, 0	; 28
   13cac:	8d b3       	in	r24, 0x1d	; 29
   13cae:	9e 01       	movw	r18, r28
   13cb0:	26 5d       	subi	r18, 0xD6	; 214
   13cb2:	3f 4f       	sbci	r19, 0xFF	; 255
			   uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   13cb4:	81 30       	cpi	r24, 0x01	; 1
   13cb6:	79 f4       	brne	.+30     	; 0x13cd6 <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   13cb8:	00 d0       	rcall	.+0      	; 0x13cba <SendConfigParamater+0x2dc>
   13cba:	00 d0       	rcall	.+0      	; 0x13cbc <SendConfigParamater+0x2de>
   13cbc:	ad b7       	in	r26, 0x3d	; 61
   13cbe:	be b7       	in	r27, 0x3e	; 62
   13cc0:	12 96       	adiw	r26, 0x02	; 2
   13cc2:	3c 93       	st	X, r19
   13cc4:	2e 93       	st	-X, r18
   13cc6:	11 97       	sbiw	r26, 0x01	; 1
   13cc8:	81 e0       	ldi	r24, 0x01	; 1
   13cca:	91 e2       	ldi	r25, 0x21	; 33
   13ccc:	14 96       	adiw	r26, 0x04	; 4
   13cce:	9c 93       	st	X, r25
   13cd0:	8e 93       	st	-X, r24
   13cd2:	13 97       	sbiw	r26, 0x03	; 3
   13cd4:	0a c0       	rjmp	.+20     	; 0x13cea <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   13cd6:	00 d0       	rcall	.+0      	; 0x13cd8 <SendConfigParamater+0x2fa>
   13cd8:	00 d0       	rcall	.+0      	; 0x13cda <SendConfigParamater+0x2fc>
   13cda:	ed b7       	in	r30, 0x3d	; 61
   13cdc:	fe b7       	in	r31, 0x3e	; 62
   13cde:	32 83       	std	Z+2, r19	; 0x02
   13ce0:	21 83       	std	Z+1, r18	; 0x01
   13ce2:	8f ef       	ldi	r24, 0xFF	; 255
   13ce4:	90 e2       	ldi	r25, 0x20	; 32
   13ce6:	94 83       	std	Z+4, r25	; 0x04
   13ce8:	83 83       	std	Z+3, r24	; 0x03
   13cea:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   13cee:	0f 90       	pop	r0
   13cf0:	0f 90       	pop	r0
   13cf2:	0f 90       	pop	r0
   13cf4:	0f 90       	pop	r0
	 }uart_print(1,0,strSend);
   13cf6:	81 e0       	ldi	r24, 0x01	; 1
   13cf8:	60 e0       	ldi	r22, 0x00	; 0
   13cfa:	ae 01       	movw	r20, r28
   13cfc:	46 5d       	subi	r20, 0xD6	; 214
   13cfe:	5f 4f       	sbci	r21, 0xFF	; 255
   13d00:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13d04:	e1 99       	sbic	0x1c, 1	; 28
   13d06:	fe cf       	rjmp	.-4      	; 0x13d04 <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13d08:	80 e0       	ldi	r24, 0x00	; 0
   13d0a:	90 e0       	ldi	r25, 0x00	; 0
   13d0c:	9f bb       	out	0x1f, r25	; 31
   13d0e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13d10:	e0 9a       	sbi	0x1c, 0	; 28
   13d12:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   13d14:	00 d0       	rcall	.+0      	; 0x13d16 <SendConfigParamater+0x338>
   13d16:	00 d0       	rcall	.+0      	; 0x13d18 <SendConfigParamater+0x33a>
   13d18:	00 d0       	rcall	.+0      	; 0x13d1a <SendConfigParamater+0x33c>
   13d1a:	ed b7       	in	r30, 0x3d	; 61
   13d1c:	fe b7       	in	r31, 0x3e	; 62
   13d1e:	31 96       	adiw	r30, 0x01	; 1
   13d20:	8e 01       	movw	r16, r28
   13d22:	06 5d       	subi	r16, 0xD6	; 214
   13d24:	1f 4f       	sbci	r17, 0xFF	; 255
   13d26:	ad b7       	in	r26, 0x3d	; 61
   13d28:	be b7       	in	r27, 0x3e	; 62
   13d2a:	12 96       	adiw	r26, 0x02	; 2
   13d2c:	1c 93       	st	X, r17
   13d2e:	0e 93       	st	-X, r16
   13d30:	11 97       	sbiw	r26, 0x01	; 1
   13d32:	8a ef       	ldi	r24, 0xFA	; 250
   13d34:	90 e2       	ldi	r25, 0x20	; 32
   13d36:	93 83       	std	Z+3, r25	; 0x03
   13d38:	82 83       	std	Z+2, r24	; 0x02
   13d3a:	24 83       	std	Z+4, r18	; 0x04
   13d3c:	15 82       	std	Z+5, r1	; 0x05
   13d3e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
     uart_print(1,0,strSend);
   13d42:	ed b7       	in	r30, 0x3d	; 61
   13d44:	fe b7       	in	r31, 0x3e	; 62
   13d46:	36 96       	adiw	r30, 0x06	; 6
   13d48:	0f b6       	in	r0, 0x3f	; 63
   13d4a:	f8 94       	cli
   13d4c:	fe bf       	out	0x3e, r31	; 62
   13d4e:	0f be       	out	0x3f, r0	; 63
   13d50:	ed bf       	out	0x3d, r30	; 61
   13d52:	81 e0       	ldi	r24, 0x01	; 1
   13d54:	60 e0       	ldi	r22, 0x00	; 0
   13d56:	a8 01       	movw	r20, r16
   13d58:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
   13d5c:	9d e4       	ldi	r25, 0x4D	; 77
   13d5e:	e9 2e       	mov	r14, r25
   13d60:	90 e0       	ldi	r25, 0x00	; 0
   13d62:	f9 2e       	mov	r15, r25
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   13d64:	d0 2e       	mov	r13, r16
   13d66:	01 2f       	mov	r16, r17
   13d68:	85 ef       	ldi	r24, 0xF5	; 245
   13d6a:	a8 2e       	mov	r10, r24
   13d6c:	80 e2       	ldi	r24, 0x20	; 32
   13d6e:	b8 2e       	mov	r11, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13d70:	e1 99       	sbic	0x1c, 1	; 28
   13d72:	fe cf       	rjmp	.-4      	; 0x13d70 <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13d74:	ff ba       	out	0x1f, r15	; 31
   13d76:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13d78:	e0 9a       	sbi	0x1c, 0	; 28
   13d7a:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   13d7c:	84 36       	cpi	r24, 0x64	; 100
   13d7e:	08 f0       	brcs	.+2      	; 0x13d82 <SendConfigParamater+0x3a4>
   13d80:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   13d82:	00 d0       	rcall	.+0      	; 0x13d84 <SendConfigParamater+0x3a6>
   13d84:	00 d0       	rcall	.+0      	; 0x13d86 <SendConfigParamater+0x3a8>
   13d86:	00 d0       	rcall	.+0      	; 0x13d88 <SendConfigParamater+0x3aa>
   13d88:	ed b7       	in	r30, 0x3d	; 61
   13d8a:	fe b7       	in	r31, 0x3e	; 62
   13d8c:	31 96       	adiw	r30, 0x01	; 1
   13d8e:	ad b7       	in	r26, 0x3d	; 61
   13d90:	be b7       	in	r27, 0x3e	; 62
   13d92:	11 96       	adiw	r26, 0x01	; 1
   13d94:	dc 92       	st	X, r13
   13d96:	11 97       	sbiw	r26, 0x01	; 1
   13d98:	12 96       	adiw	r26, 0x02	; 2
   13d9a:	0c 93       	st	X, r16
   13d9c:	b3 82       	std	Z+3, r11	; 0x03
   13d9e:	a2 82       	std	Z+2, r10	; 0x02
   13da0:	84 83       	std	Z+4, r24	; 0x04
   13da2:	15 82       	std	Z+5, r1	; 0x05
   13da4:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
		  AddSpaceLag(strSend,2);
   13da8:	ed b7       	in	r30, 0x3d	; 61
   13daa:	fe b7       	in	r31, 0x3e	; 62
   13dac:	36 96       	adiw	r30, 0x06	; 6
   13dae:	0f b6       	in	r0, 0x3f	; 63
   13db0:	f8 94       	cli
   13db2:	fe bf       	out	0x3e, r31	; 62
   13db4:	0f be       	out	0x3f, r0	; 63
   13db6:	ed bf       	out	0x3d, r30	; 61
   13db8:	8d 2d       	mov	r24, r13
   13dba:	90 2f       	mov	r25, r16
   13dbc:	62 e0       	ldi	r22, 0x02	; 2
   13dbe:	0e 94 c6 2b 	call	0x578c	; 0x578c <AddSpaceLag>
		 uart_print(1,0,strSend);
   13dc2:	81 e0       	ldi	r24, 0x01	; 1
   13dc4:	60 e0       	ldi	r22, 0x00	; 0
   13dc6:	4d 2d       	mov	r20, r13
   13dc8:	50 2f       	mov	r21, r16
   13dca:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>
   13dce:	08 94       	sec
   13dd0:	e1 1c       	adc	r14, r1
   13dd2:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   13dd4:	f5 e5       	ldi	r31, 0x55	; 85
   13dd6:	ef 16       	cp	r14, r31
   13dd8:	f0 e0       	ldi	r31, 0x00	; 0
   13dda:	ff 06       	cpc	r15, r31
   13ddc:	49 f6       	brne	.-110    	; 0x13d70 <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 uart_print(1,0,strSend);
	 }
	 uart_printf(1,1,PSTR(">"));
   13dde:	81 e0       	ldi	r24, 0x01	; 1
   13de0:	61 e0       	ldi	r22, 0x01	; 1
   13de2:	43 ef       	ldi	r20, 0xF3	; 243
   13de4:	50 e2       	ldi	r21, 0x20	; 32
   13de6:	0e 94 93 a8 	call	0x15126	; 0x15126 <uart_printf>
	 //End
}
   13dea:	cb 59       	subi	r28, 0x9B	; 155
   13dec:	df 4f       	sbci	r29, 0xFF	; 255
   13dee:	0f b6       	in	r0, 0x3f	; 63
   13df0:	f8 94       	cli
   13df2:	de bf       	out	0x3e, r29	; 62
   13df4:	0f be       	out	0x3f, r0	; 63
   13df6:	cd bf       	out	0x3d, r28	; 61
   13df8:	cf 91       	pop	r28
   13dfa:	df 91       	pop	r29
   13dfc:	1f 91       	pop	r17
   13dfe:	0f 91       	pop	r16
   13e00:	ff 90       	pop	r15
   13e02:	ef 90       	pop	r14
   13e04:	df 90       	pop	r13
   13e06:	cf 90       	pop	r12
   13e08:	bf 90       	pop	r11
   13e0a:	af 90       	pop	r10
   13e0c:	9f 90       	pop	r9
   13e0e:	8f 90       	pop	r8
   13e10:	08 95       	ret

00013e12 <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   13e12:	8f 92       	push	r8
   13e14:	9f 92       	push	r9
   13e16:	af 92       	push	r10
   13e18:	bf 92       	push	r11
   13e1a:	cf 92       	push	r12
   13e1c:	df 92       	push	r13
   13e1e:	ef 92       	push	r14
   13e20:	ff 92       	push	r15
   13e22:	0f 93       	push	r16
   13e24:	1f 93       	push	r17
   13e26:	df 93       	push	r29
   13e28:	cf 93       	push	r28
   13e2a:	cd b7       	in	r28, 0x3d	; 61
   13e2c:	de b7       	in	r29, 0x3e	; 62
   13e2e:	c6 54       	subi	r28, 0x46	; 70
   13e30:	d0 40       	sbci	r29, 0x00	; 0
   13e32:	0f b6       	in	r0, 0x3f	; 63
   13e34:	f8 94       	cli
   13e36:	de bf       	out	0x3e, r29	; 62
   13e38:	0f be       	out	0x3f, r0	; 63
   13e3a:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
   13e3c:	00 d0       	rcall	.+0      	; 0x13e3e <SaveConfigParameter+0x2c>
   13e3e:	00 d0       	rcall	.+0      	; 0x13e40 <SaveConfigParameter+0x2e>
   13e40:	00 d0       	rcall	.+0      	; 0x13e42 <SaveConfigParameter+0x30>
   13e42:	ed b7       	in	r30, 0x3d	; 61
   13e44:	fe b7       	in	r31, 0x3e	; 62
   13e46:	31 96       	adiw	r30, 0x01	; 1
   13e48:	8e 01       	movw	r16, r28
   13e4a:	0f 5f       	subi	r16, 0xFF	; 255
   13e4c:	1f 4f       	sbci	r17, 0xFF	; 255
   13e4e:	ad b7       	in	r26, 0x3d	; 61
   13e50:	be b7       	in	r27, 0x3e	; 62
   13e52:	12 96       	adiw	r26, 0x02	; 2
   13e54:	1c 93       	st	X, r17
   13e56:	0e 93       	st	-X, r16
   13e58:	11 97       	sbiw	r26, 0x01	; 1
   13e5a:	8d e2       	ldi	r24, 0x2D	; 45
   13e5c:	91 e2       	ldi	r25, 0x21	; 33
   13e5e:	93 83       	std	Z+3, r25	; 0x03
   13e60:	82 83       	std	Z+2, r24	; 0x02
   13e62:	80 91 8b 01 	lds	r24, 0x018B
   13e66:	90 91 8c 01 	lds	r25, 0x018C
   13e6a:	95 83       	std	Z+5, r25	; 0x05
   13e6c:	84 83       	std	Z+4, r24	; 0x04
   13e6e:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	 uart_print(1,1,strSend);
   13e72:	ed b7       	in	r30, 0x3d	; 61
   13e74:	fe b7       	in	r31, 0x3e	; 62
   13e76:	36 96       	adiw	r30, 0x06	; 6
   13e78:	0f b6       	in	r0, 0x3f	; 63
   13e7a:	f8 94       	cli
   13e7c:	fe bf       	out	0x3e, r31	; 62
   13e7e:	0f be       	out	0x3f, r0	; 63
   13e80:	ed bf       	out	0x3d, r30	; 61
   13e82:	81 e0       	ldi	r24, 0x01	; 1
   13e84:	61 e0       	ldi	r22, 0x01	; 1
   13e86:	a8 01       	movw	r20, r16
   13e88:	0e 94 6b a8 	call	0x150d6	; 0x150d6 <uart_print>

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
   13e8c:	81 e0       	ldi	r24, 0x01	; 1
   13e8e:	61 e0       	ldi	r22, 0x01	; 1
   13e90:	44 e2       	ldi	r20, 0x24	; 36
   13e92:	51 e2       	ldi	r21, 0x21	; 33
   13e94:	0e 94 93 a8 	call	0x15126	; 0x15126 <uart_printf>
   13e98:	07 e2       	ldi	r16, 0x27	; 39
   13e9a:	12 e0       	ldi	r17, 0x02	; 2
   13e9c:	3d e1       	ldi	r19, 0x1D	; 29
   13e9e:	e3 2e       	mov	r14, r19
   13ea0:	39 e0       	ldi	r19, 0x09	; 9
   13ea2:	f3 2e       	mov	r15, r19
   13ea4:	25 e1       	ldi	r18, 0x15	; 21
   13ea6:	a2 2e       	mov	r10, r18
   13ea8:	b1 2c       	mov	r11, r1
   13eaa:	ac 0e       	add	r10, r28
   13eac:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13eae:	9d e3       	ldi	r25, 0x3D	; 61
   13eb0:	c9 2e       	mov	r12, r25
   13eb2:	d1 2c       	mov	r13, r1
   13eb4:	cc 0e       	add	r12, r28
   13eb6:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
   13eb8:	d7 01       	movw	r26, r14
   13eba:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13ebc:	8d 91       	ld	r24, X+
   13ebe:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13ec0:	ec 15       	cp	r30, r12
   13ec2:	fd 05       	cpc	r31, r13
   13ec4:	d9 f7       	brne	.-10     	; 0x13ebc <SaveConfigParameter+0xaa>
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   13ec6:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   13ec8:	c8 01       	movw	r24, r16
   13eca:	b5 01       	movw	r22, r10
   13ecc:	49 e2       	ldi	r20, 0x29	; 41
   13ece:	50 e0       	ldi	r21, 0x00	; 0
   13ed0:	2c e4       	ldi	r18, 0x4C	; 76
   13ed2:	32 e1       	ldi	r19, 0x12	; 18
   13ed4:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
   13ed8:	07 5d       	subi	r16, 0xD7	; 215
   13eda:	1f 4f       	sbci	r17, 0xFF	; 255
   13edc:	88 e2       	ldi	r24, 0x28	; 40
   13ede:	90 e0       	ldi	r25, 0x00	; 0
   13ee0:	e8 0e       	add	r14, r24
   13ee2:	f9 1e       	adc	r15, r25
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   13ee4:	93 e0       	ldi	r25, 0x03	; 3
   13ee6:	01 3c       	cpi	r16, 0xC1	; 193
   13ee8:	19 07       	cpc	r17, r25
   13eea:	31 f7       	brne	.-52     	; 0x13eb8 <SaveConfigParameter+0xa6>
   13eec:	0b eb       	ldi	r16, 0xBB	; 187
   13eee:	10 e0       	ldi	r17, 0x00	; 0
   13ef0:	8d ea       	ldi	r24, 0xAD	; 173
   13ef2:	e8 2e       	mov	r14, r24
   13ef4:	8a e0       	ldi	r24, 0x0A	; 10
   13ef6:	f8 2e       	mov	r15, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13ef8:	b5 e1       	ldi	r27, 0x15	; 21
   13efa:	cb 2e       	mov	r12, r27
   13efc:	d1 2c       	mov	r13, r1
   13efe:	cc 0e       	add	r12, r28
   13f00:	dd 1e       	adc	r13, r29
   13f02:	a1 e2       	ldi	r26, 0x21	; 33
   13f04:	8a 2e       	mov	r8, r26
   13f06:	91 2c       	mov	r9, r1
   13f08:	8c 0e       	add	r8, r28
   13f0a:	9d 1e       	adc	r9, r29
	 uart_print(1,1,strSend);

     StrPos=0;
	 uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   13f0c:	d7 01       	movw	r26, r14
   13f0e:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13f10:	8d 91       	ld	r24, X+
   13f12:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13f14:	e8 15       	cp	r30, r8
   13f16:	f9 05       	cpc	r31, r9
   13f18:	d9 f7       	brne	.-10     	; 0x13f10 <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13f1a:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   13f1c:	c6 01       	movw	r24, r12
   13f1e:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   13f22:	f6 01       	movw	r30, r12
   13f24:	01 90       	ld	r0, Z+
   13f26:	00 20       	and	r0, r0
   13f28:	e9 f7       	brne	.-6      	; 0x13f24 <SaveConfigParameter+0x112>
   13f2a:	31 97       	sbiw	r30, 0x01	; 1
   13f2c:	10 82       	st	Z, r1
   13f2e:	c8 01       	movw	r24, r16
   13f30:	b6 01       	movw	r22, r12
   13f32:	4d e0       	ldi	r20, 0x0D	; 13
   13f34:	50 e0       	ldi	r21, 0x00	; 0
   13f36:	2c e4       	ldi	r18, 0x4C	; 76
   13f38:	32 e1       	ldi	r19, 0x12	; 18
   13f3a:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
   13f3e:	03 5f       	subi	r16, 0xF3	; 243
   13f40:	1f 4f       	sbci	r17, 0xFF	; 255
   13f42:	ac e0       	ldi	r26, 0x0C	; 12
   13f44:	b0 e0       	ldi	r27, 0x00	; 0
   13f46:	ea 0e       	add	r14, r26
   13f48:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   13f4a:	b1 e0       	ldi	r27, 0x01	; 1
   13f4c:	09 30       	cpi	r16, 0x09	; 9
   13f4e:	1b 07       	cpc	r17, r27
   13f50:	e9 f6       	brne	.-70     	; 0x13f0c <SaveConfigParameter+0xfa>
   13f52:	05 e8       	ldi	r16, 0x85	; 133
   13f54:	10 e0       	ldi	r17, 0x00	; 0
   13f56:	f5 ef       	ldi	r31, 0xF5	; 245
   13f58:	ef 2e       	mov	r14, r31
   13f5a:	fa e0       	ldi	r31, 0x0A	; 10
   13f5c:	ff 2e       	mov	r15, r31
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13f5e:	e5 e1       	ldi	r30, 0x15	; 21
   13f60:	ce 2e       	mov	r12, r30
   13f62:	d1 2c       	mov	r13, r1
   13f64:	cc 0e       	add	r12, r28
   13f66:	dd 1e       	adc	r13, r29
   13f68:	7a e1       	ldi	r23, 0x1A	; 26
   13f6a:	87 2e       	mov	r8, r23
   13f6c:	91 2c       	mov	r9, r1
   13f6e:	8c 0e       	add	r8, r28
   13f70:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   13f72:	d7 01       	movw	r26, r14
   13f74:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13f76:	8d 91       	ld	r24, X+
   13f78:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13f7a:	e8 15       	cp	r30, r8
   13f7c:	f9 05       	cpc	r31, r9
   13f7e:	d9 f7       	brne	.-10     	; 0x13f76 <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13f80:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   13f82:	c6 01       	movw	r24, r12
   13f84:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <RemSpaceLag>
   13f88:	c8 01       	movw	r24, r16
   13f8a:	b6 01       	movw	r22, r12
   13f8c:	49 e0       	ldi	r20, 0x09	; 9
   13f8e:	50 e0       	ldi	r21, 0x00	; 0
   13f90:	2c e4       	ldi	r18, 0x4C	; 76
   13f92:	32 e1       	ldi	r19, 0x12	; 18
   13f94:	0e 94 08 aa 	call	0x15410	; 0x15410 <__eewr_block>
   13f98:	07 5f       	subi	r16, 0xF7	; 247
   13f9a:	1f 4f       	sbci	r17, 0xFF	; 255
   13f9c:	e5 e0       	ldi	r30, 0x05	; 5
   13f9e:	f0 e0       	ldi	r31, 0x00	; 0
   13fa0:	ee 0e       	add	r14, r30
   13fa2:	ff 1e       	adc	r15, r31
		// uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   13fa4:	f0 e0       	ldi	r31, 0x00	; 0
   13fa6:	0b 3b       	cpi	r16, 0xBB	; 187
   13fa8:	1f 07       	cpc	r17, r31
   13faa:	19 f7       	brne	.-58     	; 0x13f72 <SaveConfigParameter+0x160>
   13fac:	03 e1       	ldi	r16, 0x13	; 19
   13fae:	1b e0       	ldi	r17, 0x0B	; 11
   13fb0:	65 e4       	ldi	r22, 0x45	; 69
   13fb2:	e6 2e       	mov	r14, r22
   13fb4:	60 e0       	ldi	r22, 0x00	; 0
   13fb6:	f6 2e       	mov	r15, r22
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   13fb8:	55 e1       	ldi	r21, 0x15	; 21
   13fba:	c5 2e       	mov	r12, r21
   13fbc:	d1 2c       	mov	r13, r1
   13fbe:	cc 0e       	add	r12, r28
   13fc0:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   13fc2:	4e 01       	movw	r8, r28
   13fc4:	08 94       	sec
   13fc6:	81 1c       	adc	r8, r1
   13fc8:	91 1c       	adc	r9, r1
   13fca:	41 e2       	ldi	r20, 0x21	; 33
   13fcc:	a4 2e       	mov	r10, r20
   13fce:	41 e2       	ldi	r20, 0x21	; 33
   13fd0:	b4 2e       	mov	r11, r20
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13fd2:	d8 01       	movw	r26, r16
   13fd4:	8c 91       	ld	r24, X
   13fd6:	8d 8b       	std	Y+21, r24	; 0x15
   13fd8:	11 96       	adiw	r26, 0x01	; 1
   13fda:	8c 91       	ld	r24, X
   13fdc:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   13fde:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   13fe0:	c6 01       	movw	r24, r12
   13fe2:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   13fe6:	c6 01       	movw	r24, r12
   13fe8:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   13fec:	e1 99       	sbic	0x1c, 1	; 28
   13fee:	fe cf       	rjmp	.-4      	; 0x13fec <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13ff0:	ff ba       	out	0x1f, r15	; 31
   13ff2:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   13ff4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   13ff6:	0f b6       	in	r0, 0x3f	; 63
   13ff8:	f8 94       	cli
   13ffa:	e2 9a       	sbi	0x1c, 2	; 28
   13ffc:	e1 9a       	sbi	0x1c, 1	; 28
   13ffe:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14000:	00 d0       	rcall	.+0      	; 0x14002 <SaveConfigParameter+0x1f0>
   14002:	00 d0       	rcall	.+0      	; 0x14004 <SaveConfigParameter+0x1f2>
   14004:	00 d0       	rcall	.+0      	; 0x14006 <SaveConfigParameter+0x1f4>
   14006:	ed b7       	in	r30, 0x3d	; 61
   14008:	fe b7       	in	r31, 0x3e	; 62
   1400a:	31 96       	adiw	r30, 0x01	; 1
   1400c:	ad b7       	in	r26, 0x3d	; 61
   1400e:	be b7       	in	r27, 0x3e	; 62
   14010:	12 96       	adiw	r26, 0x02	; 2
   14012:	9c 92       	st	X, r9
   14014:	8e 92       	st	-X, r8
   14016:	11 97       	sbiw	r26, 0x01	; 1
   14018:	b3 82       	std	Z+3, r11	; 0x03
   1401a:	a2 82       	std	Z+2, r10	; 0x02
   1401c:	84 83       	std	Z+4, r24	; 0x04
   1401e:	15 82       	std	Z+5, r1	; 0x05
   14020:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   14024:	0e 5f       	subi	r16, 0xFE	; 254
   14026:	1f 4f       	sbci	r17, 0xFF	; 255
   14028:	08 94       	sec
   1402a:	e1 1c       	adc	r14, r1
   1402c:	f1 1c       	adc	r15, r1
		// uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   1402e:	ed b7       	in	r30, 0x3d	; 61
   14030:	fe b7       	in	r31, 0x3e	; 62
   14032:	36 96       	adiw	r30, 0x06	; 6
   14034:	0f b6       	in	r0, 0x3f	; 63
   14036:	f8 94       	cli
   14038:	fe bf       	out	0x3e, r31	; 62
   1403a:	0f be       	out	0x3f, r0	; 63
   1403c:	ed bf       	out	0x3d, r30	; 61
   1403e:	fb e0       	ldi	r31, 0x0B	; 11
   14040:	03 32       	cpi	r16, 0x23	; 35
   14042:	1f 07       	cpc	r17, r31
   14044:	09 f0       	breq	.+2      	; 0x14048 <SaveConfigParameter+0x236>
   14046:	c5 cf       	rjmp	.-118    	; 0x13fd2 <SaveConfigParameter+0x1c0>
   14048:	45 e5       	ldi	r20, 0x55	; 85
   1404a:	50 e0       	ldi	r21, 0x00	; 0
   1404c:	b8 01       	movw	r22, r16
   1404e:	1d c0       	rjmp	.+58     	; 0x1408a <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   14050:	90 81       	ld	r25, Z
   14052:	90 53       	subi	r25, 0x30	; 48
   14054:	9a 30       	cpi	r25, 0x0A	; 10
   14056:	08 f0       	brcs	.+2      	; 0x1405a <SaveConfigParameter+0x248>
   14058:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1405a:	e1 99       	sbic	0x1c, 1	; 28
   1405c:	fe cf       	rjmp	.-4      	; 0x1405a <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1405e:	3f bb       	out	0x1f, r19	; 31
   14060:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   14062:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   14064:	0f b6       	in	r0, 0x3f	; 63
   14066:	f8 94       	cli
   14068:	e2 9a       	sbi	0x1c, 2	; 28
   1406a:	e1 9a       	sbi	0x1c, 1	; 28
   1406c:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   1406e:	8f 5f       	subi	r24, 0xFF	; 255
   14070:	31 96       	adiw	r30, 0x01	; 1
   14072:	2f 5f       	subi	r18, 0xFF	; 255
   14074:	3f 4f       	sbci	r19, 0xFF	; 255
   14076:	86 30       	cpi	r24, 0x06	; 6
   14078:	59 f7       	brne	.-42     	; 0x14050 <SaveConfigParameter+0x23e>
   1407a:	4a 5f       	subi	r20, 0xFA	; 250
   1407c:	5f 4f       	sbci	r21, 0xFF	; 255
   1407e:	6a 5f       	subi	r22, 0xFA	; 250
   14080:	7f 4f       	sbci	r23, 0xFF	; 255
		// uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   14082:	80 e0       	ldi	r24, 0x00	; 0
   14084:	45 38       	cpi	r20, 0x85	; 133
   14086:	58 07       	cpc	r21, r24
   14088:	21 f0       	breq	.+8      	; 0x14092 <SaveConfigParameter+0x280>
   1408a:	fb 01       	movw	r30, r22
   1408c:	9a 01       	movw	r18, r20
   1408e:	80 e0       	ldi	r24, 0x00	; 0
   14090:	df cf       	rjmp	.-66     	; 0x14050 <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   14092:	80 91 53 0b 	lds	r24, 0x0B53
   14096:	80 53       	subi	r24, 0x30	; 48
   14098:	8a 30       	cpi	r24, 0x0A	; 10
   1409a:	10 f0       	brcs	.+4      	; 0x140a0 <SaveConfigParameter+0x28e>
   1409c:	20 e0       	ldi	r18, 0x00	; 0
   1409e:	03 c0       	rjmp	.+6      	; 0x140a6 <SaveConfigParameter+0x294>
   140a0:	81 11       	cpse	r24, r1
   140a2:	81 e0       	ldi	r24, 0x01	; 1
   140a4:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   140a6:	e1 99       	sbic	0x1c, 1	; 28
   140a8:	fe cf       	rjmp	.-4      	; 0x140a6 <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   140aa:	81 ec       	ldi	r24, 0xC1	; 193
   140ac:	93 e0       	ldi	r25, 0x03	; 3
   140ae:	9f bb       	out	0x1f, r25	; 31
   140b0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   140b2:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   140b4:	0f b6       	in	r0, 0x3f	; 63
   140b6:	f8 94       	cli
   140b8:	e2 9a       	sbi	0x1c, 2	; 28
   140ba:	e1 9a       	sbi	0x1c, 1	; 28
   140bc:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   140be:	80 91 54 0b 	lds	r24, 0x0B54
   140c2:	8d 8b       	std	Y+21, r24	; 0x15
   140c4:	80 91 55 0b 	lds	r24, 0x0B55
   140c8:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   140ca:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   140cc:	8e 01       	movw	r16, r28
   140ce:	0b 5e       	subi	r16, 0xEB	; 235
   140d0:	1f 4f       	sbci	r17, 0xFF	; 255
   140d2:	c8 01       	movw	r24, r16
   140d4:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   140d8:	c8 01       	movw	r24, r16
   140da:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
   140de:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   140e0:	e1 99       	sbic	0x1c, 1	; 28
   140e2:	fe cf       	rjmp	.-4      	; 0x140e0 <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   140e4:	80 e0       	ldi	r24, 0x00	; 0
   140e6:	90 e0       	ldi	r25, 0x00	; 0
   140e8:	9f bb       	out	0x1f, r25	; 31
   140ea:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   140ec:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   140ee:	0f b6       	in	r0, 0x3f	; 63
   140f0:	f8 94       	cli
   140f2:	e2 9a       	sbi	0x1c, 2	; 28
   140f4:	e1 9a       	sbi	0x1c, 1	; 28
   140f6:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   140f8:	00 d0       	rcall	.+0      	; 0x140fa <SaveConfigParameter+0x2e8>
   140fa:	00 d0       	rcall	.+0      	; 0x140fc <SaveConfigParameter+0x2ea>
   140fc:	00 d0       	rcall	.+0      	; 0x140fe <SaveConfigParameter+0x2ec>
   140fe:	ed b7       	in	r30, 0x3d	; 61
   14100:	fe b7       	in	r31, 0x3e	; 62
   14102:	31 96       	adiw	r30, 0x01	; 1
   14104:	8e 01       	movw	r16, r28
   14106:	0f 5f       	subi	r16, 0xFF	; 255
   14108:	1f 4f       	sbci	r17, 0xFF	; 255
   1410a:	ad b7       	in	r26, 0x3d	; 61
   1410c:	be b7       	in	r27, 0x3e	; 62
   1410e:	12 96       	adiw	r26, 0x02	; 2
   14110:	1c 93       	st	X, r17
   14112:	0e 93       	st	-X, r16
   14114:	11 97       	sbiw	r26, 0x01	; 1
   14116:	8e e1       	ldi	r24, 0x1E	; 30
   14118:	91 e2       	ldi	r25, 0x21	; 33
   1411a:	93 83       	std	Z+3, r25	; 0x03
   1411c:	82 83       	std	Z+2, r24	; 0x02
   1411e:	24 83       	std	Z+4, r18	; 0x04
   14120:	15 82       	std	Z+5, r1	; 0x05
   14122:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   14126:	36 e5       	ldi	r19, 0x56	; 86
   14128:	e3 2e       	mov	r14, r19
   1412a:	3b e0       	ldi	r19, 0x0B	; 11
   1412c:	f3 2e       	mov	r15, r19
   1412e:	2d e4       	ldi	r18, 0x4D	; 77
   14130:	c2 2e       	mov	r12, r18
   14132:	20 e0       	ldi	r18, 0x00	; 0
   14134:	d2 2e       	mov	r13, r18
   14136:	ed b7       	in	r30, 0x3d	; 61
   14138:	fe b7       	in	r31, 0x3e	; 62
   1413a:	36 96       	adiw	r30, 0x06	; 6
   1413c:	0f b6       	in	r0, 0x3f	; 63
   1413e:	f8 94       	cli
   14140:	fe bf       	out	0x3e, r31	; 62
   14142:	0f be       	out	0x3f, r0	; 63
   14144:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   14146:	95 e1       	ldi	r25, 0x15	; 21
   14148:	a9 2e       	mov	r10, r25
   1414a:	b1 2c       	mov	r11, r1
   1414c:	ac 0e       	add	r10, r28
   1414e:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14150:	48 01       	movw	r8, r16
   14152:	0b e1       	ldi	r16, 0x1B	; 27
   14154:	11 e2       	ldi	r17, 0x21	; 33
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14156:	d7 01       	movw	r26, r14
   14158:	8c 91       	ld	r24, X
   1415a:	8d 8b       	std	Y+21, r24	; 0x15
   1415c:	11 96       	adiw	r26, 0x01	; 1
   1415e:	8c 91       	ld	r24, X
   14160:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   14162:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   14164:	c5 01       	movw	r24, r10
   14166:	0e 94 3f 23 	call	0x467e	; 0x467e <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   1416a:	c5 01       	movw	r24, r10
   1416c:	0e 94 be a9 	call	0x1537c	; 0x1537c <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   14170:	e1 99       	sbic	0x1c, 1	; 28
   14172:	fe cf       	rjmp	.-4      	; 0x14170 <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14174:	df ba       	out	0x1f, r13	; 31
   14176:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   14178:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   1417a:	0f b6       	in	r0, 0x3f	; 63
   1417c:	f8 94       	cli
   1417e:	e2 9a       	sbi	0x1c, 2	; 28
   14180:	e1 9a       	sbi	0x1c, 1	; 28
   14182:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14184:	00 d0       	rcall	.+0      	; 0x14186 <SaveConfigParameter+0x374>
   14186:	00 d0       	rcall	.+0      	; 0x14188 <SaveConfigParameter+0x376>
   14188:	00 d0       	rcall	.+0      	; 0x1418a <SaveConfigParameter+0x378>
   1418a:	ed b7       	in	r30, 0x3d	; 61
   1418c:	fe b7       	in	r31, 0x3e	; 62
   1418e:	31 96       	adiw	r30, 0x01	; 1
   14190:	ad b7       	in	r26, 0x3d	; 61
   14192:	be b7       	in	r27, 0x3e	; 62
   14194:	11 96       	adiw	r26, 0x01	; 1
   14196:	8c 92       	st	X, r8
   14198:	11 97       	sbiw	r26, 0x01	; 1
   1419a:	12 96       	adiw	r26, 0x02	; 2
   1419c:	9c 92       	st	X, r9
   1419e:	13 83       	std	Z+3, r17	; 0x03
   141a0:	02 83       	std	Z+2, r16	; 0x02
   141a2:	84 83       	std	Z+4, r24	; 0x04
   141a4:	15 82       	std	Z+5, r1	; 0x05
   141a6:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
   141aa:	e2 e0       	ldi	r30, 0x02	; 2
   141ac:	f0 e0       	ldi	r31, 0x00	; 0
   141ae:	ee 0e       	add	r14, r30
   141b0:	ff 1e       	adc	r15, r31
   141b2:	08 94       	sec
   141b4:	c1 1c       	adc	r12, r1
   141b6:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   141b8:	8d b7       	in	r24, 0x3d	; 61
   141ba:	9e b7       	in	r25, 0x3e	; 62
   141bc:	06 96       	adiw	r24, 0x06	; 6
   141be:	0f b6       	in	r0, 0x3f	; 63
   141c0:	f8 94       	cli
   141c2:	9e bf       	out	0x3e, r25	; 62
   141c4:	0f be       	out	0x3f, r0	; 63
   141c6:	8d bf       	out	0x3d, r24	; 61
   141c8:	96 e6       	ldi	r25, 0x66	; 102
   141ca:	e9 16       	cp	r14, r25
   141cc:	9b e0       	ldi	r25, 0x0B	; 11
   141ce:	f9 06       	cpc	r15, r25
   141d0:	09 f0       	breq	.+2      	; 0x141d4 <SaveConfigParameter+0x3c2>
   141d2:	c1 cf       	rjmp	.-126    	; 0x14156 <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 uart_print(1,1,strSend); 
	 }    
	 uart_printf(1,1,PSTR("<OK>")); 
   141d4:	81 e0       	ldi	r24, 0x01	; 1
   141d6:	61 e0       	ldi	r22, 0x01	; 1
   141d8:	46 e1       	ldi	r20, 0x16	; 22
   141da:	51 e2       	ldi	r21, 0x21	; 33
   141dc:	0e 94 93 a8 	call	0x15126	; 0x15126 <uart_printf>
}
   141e0:	ca 5b       	subi	r28, 0xBA	; 186
   141e2:	df 4f       	sbci	r29, 0xFF	; 255
   141e4:	0f b6       	in	r0, 0x3f	; 63
   141e6:	f8 94       	cli
   141e8:	de bf       	out	0x3e, r29	; 62
   141ea:	0f be       	out	0x3f, r0	; 63
   141ec:	cd bf       	out	0x3d, r28	; 61
   141ee:	cf 91       	pop	r28
   141f0:	df 91       	pop	r29
   141f2:	1f 91       	pop	r17
   141f4:	0f 91       	pop	r16
   141f6:	ff 90       	pop	r15
   141f8:	ef 90       	pop	r14
   141fa:	df 90       	pop	r13
   141fc:	cf 90       	pop	r12
   141fe:	bf 90       	pop	r11
   14200:	af 90       	pop	r10
   14202:	9f 90       	pop	r9
   14204:	8f 90       	pop	r8
   14206:	08 95       	ret

00014208 <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
   14208:	80 91 a0 02 	lds	r24, 0x02A0
   1420c:	81 30       	cpi	r24, 0x01	; 1
   1420e:	c1 f0       	breq	.+48     	; 0x14240 <systemConfigProtocol+0x38>
   14210:	81 30       	cpi	r24, 0x01	; 1
   14212:	18 f0       	brcs	.+6      	; 0x1421a <systemConfigProtocol+0x12>
   14214:	82 30       	cpi	r24, 0x02	; 2
   14216:	e9 f4       	brne	.+58     	; 0x14252 <systemConfigProtocol+0x4a>
   14218:	18 c0       	rjmp	.+48     	; 0x1424a <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
   1421a:	80 91 b0 01 	lds	r24, 0x01B0
   1421e:	81 30       	cpi	r24, 0x01	; 1
   14220:	31 f0       	breq	.+12     	; 0x1422e <systemConfigProtocol+0x26>
   14222:	82 30       	cpi	r24, 0x02	; 2
   14224:	51 f4       	brne	.+20     	; 0x1423a <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
   14226:	10 92 b0 01 	sts	0x01B0, r1
			   stConfigProtocol=cpSendingParameter;
   1422a:	81 e0       	ldi	r24, 0x01	; 1
   1422c:	03 c0       	rjmp	.+6      	; 0x14234 <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
   1422e:	10 92 b0 01 	sts	0x01B0, r1
			   stConfigProtocol=cpSavingParameter;
   14232:	82 e0       	ldi	r24, 0x02	; 2
   14234:	80 93 a0 02 	sts	0x02A0, r24
   14238:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
   1423a:	10 92 b0 01 	sts	0x01B0, r1
   1423e:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
   14240:	0e 94 ef 9c 	call	0x139de	; 0x139de <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
   14244:	10 92 a0 02 	sts	0x02A0, r1
   14248:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
   1424a:	0e 94 09 9f 	call	0x13e12	; 0x13e12 <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
   1424e:	10 92 a0 02 	sts	0x02A0, r1
   14252:	08 95       	ret

00014254 <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   14254:	1f 93       	push	r17
	static char stMenuIdle=miInit,ButtonID=0;
	       char PrintStandaloneResult=PS_NONE;
	       char KeyPressed=0,KeyChar=0;
	       char lcdteks[20];

	switch(stMenuIdle){
   14256:	80 91 ac 02 	lds	r24, 0x02AC
   1425a:	e8 2f       	mov	r30, r24
   1425c:	f0 e0       	ldi	r31, 0x00	; 0
   1425e:	e9 31       	cpi	r30, 0x19	; 25
   14260:	f1 05       	cpc	r31, r1
   14262:	08 f0       	brcs	.+2      	; 0x14266 <FMenuIdle+0x12>
   14264:	7e c1       	rjmp	.+764    	; 0x14562 <FMenuIdle+0x30e>
   14266:	e3 5e       	subi	r30, 0xE3	; 227
   14268:	fe 4f       	sbci	r31, 0xFE	; 254
   1426a:	ee 0f       	add	r30, r30
   1426c:	ff 1f       	adc	r31, r31
   1426e:	05 90       	lpm	r0, Z+
   14270:	f4 91       	lpm	r31, Z+
   14272:	e0 2d       	mov	r30, r0
   14274:	09 94       	ijmp
	case miInit:
         DisplayScreenIdle();
   14276:	0e 94 9c 46 	call	0x8d38	; 0x8d38 <DisplayScreenIdle>
   1427a:	3a c1       	rjmp	.+628    	; 0x144f0 <FMenuIdle+0x29c>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   1427c:	81 e0       	ldi	r24, 0x01	; 1
   1427e:	0e 94 85 a5 	call	0x14b0a	; 0x14b0a <_key_scan>
   14282:	18 2f       	mov	r17, r24
		 KeyChar= _key_btn(KeyPressed);       
   14284:	0e 94 e6 a4 	call	0x149cc	; 0x149cc <_key_btn>

		 switch(KeyPressed){
   14288:	1b 3b       	cpi	r17, 0xBB	; 187
   1428a:	09 f4       	brne	.+2      	; 0x1428e <FMenuIdle+0x3a>
   1428c:	7a c0       	rjmp	.+244    	; 0x14382 <FMenuIdle+0x12e>
   1428e:	1c 3b       	cpi	r17, 0xBC	; 188
   14290:	70 f4       	brcc	.+28     	; 0x142ae <FMenuIdle+0x5a>
   14292:	1b 37       	cpi	r17, 0x7B	; 123
   14294:	69 f1       	breq	.+90     	; 0x142f0 <FMenuIdle+0x9c>
   14296:	1c 37       	cpi	r17, 0x7C	; 124
   14298:	20 f4       	brcc	.+8      	; 0x142a2 <FMenuIdle+0x4e>
   1429a:	17 37       	cpi	r17, 0x77	; 119
   1429c:	09 f0       	breq	.+2      	; 0x142a0 <FMenuIdle+0x4c>
   1429e:	61 c1       	rjmp	.+706    	; 0x14562 <FMenuIdle+0x30e>
   142a0:	2e c0       	rjmp	.+92     	; 0x142fe <FMenuIdle+0xaa>
   142a2:	1d 37       	cpi	r17, 0x7D	; 125
   142a4:	e9 f0       	breq	.+58     	; 0x142e0 <FMenuIdle+0x8c>
   142a6:	1e 37       	cpi	r17, 0x7E	; 126
   142a8:	09 f0       	breq	.+2      	; 0x142ac <FMenuIdle+0x58>
   142aa:	5b c1       	rjmp	.+694    	; 0x14562 <FMenuIdle+0x30e>
   142ac:	12 c0       	rjmp	.+36     	; 0x142d2 <FMenuIdle+0x7e>
   142ae:	1d 3d       	cpi	r17, 0xDD	; 221
   142b0:	09 f4       	brne	.+2      	; 0x142b4 <FMenuIdle+0x60>
   142b2:	4f c0       	rjmp	.+158    	; 0x14352 <FMenuIdle+0xfe>
   142b4:	1e 3d       	cpi	r17, 0xDE	; 222
   142b6:	38 f4       	brcc	.+14     	; 0x142c6 <FMenuIdle+0x72>
   142b8:	1d 3b       	cpi	r17, 0xBD	; 189
   142ba:	09 f4       	brne	.+2      	; 0x142be <FMenuIdle+0x6a>
   142bc:	56 c0       	rjmp	.+172    	; 0x1436a <FMenuIdle+0x116>
   142be:	17 3d       	cpi	r17, 0xD7	; 215
   142c0:	09 f0       	breq	.+2      	; 0x142c4 <FMenuIdle+0x70>
   142c2:	4f c1       	rjmp	.+670    	; 0x14562 <FMenuIdle+0x30e>
   142c4:	27 c0       	rjmp	.+78     	; 0x14314 <FMenuIdle+0xc0>
   142c6:	1e 3d       	cpi	r17, 0xDE	; 222
   142c8:	61 f1       	breq	.+88     	; 0x14322 <FMenuIdle+0xce>
   142ca:	1d 3e       	cpi	r17, 0xED	; 237
   142cc:	09 f0       	breq	.+2      	; 0x142d0 <FMenuIdle+0x7c>
   142ce:	49 c1       	rjmp	.+658    	; 0x14562 <FMenuIdle+0x30e>
   142d0:	34 c0       	rjmp	.+104    	; 0x1433a <FMenuIdle+0xe6>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   142d2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   142d4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   142d6:	92 e0       	ldi	r25, 0x02	; 2
   142d8:	90 93 bc 01 	sts	0x01BC, r25
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   142dc:	81 e0       	ldi	r24, 0x01	; 1
   142de:	15 c0       	rjmp	.+42     	; 0x1430a <FMenuIdle+0xb6>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   142e0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   142e2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   142e4:	82 e0       	ldi	r24, 0x02	; 2
   142e6:	80 93 bc 01 	sts	0x01BC, r24
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   142ea:	80 93 ab 02 	sts	0x02AB, r24
   142ee:	37 c1       	rjmp	.+622    	; 0x1455e <FMenuIdle+0x30a>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   142f0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   142f2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   142f4:	92 e0       	ldi	r25, 0x02	; 2
   142f6:	90 93 bc 01 	sts	0x01BC, r25
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   142fa:	83 e0       	ldi	r24, 0x03	; 3
   142fc:	06 c0       	rjmp	.+12     	; 0x1430a <FMenuIdle+0xb6>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   142fe:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14300:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14302:	92 e0       	ldi	r25, 0x02	; 2
   14304:	90 93 bc 01 	sts	0x01BC, r25

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   14308:	84 e0       	ldi	r24, 0x04	; 4
   1430a:	80 93 ab 02 	sts	0x02AB, r24
   1430e:	90 93 ac 02 	sts	0x02AC, r25
   14312:	27 c1       	rjmp	.+590    	; 0x14562 <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14314:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14316:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14318:	82 e0       	ldi	r24, 0x02	; 2
   1431a:	80 93 bc 01 	sts	0x01BC, r24
		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   1431e:	8c e0       	ldi	r24, 0x0C	; 12
   14320:	1e c1       	rjmp	.+572    	; 0x1455e <FMenuIdle+0x30a>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   14322:	80 91 00 01 	lds	r24, 0x0100
   14326:	81 30       	cpi	r24, 0x01	; 1
   14328:	09 f0       	breq	.+2      	; 0x1432c <FMenuIdle+0xd8>
   1432a:	1b c1       	rjmp	.+566    	; 0x14562 <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1432c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1432e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14330:	82 e0       	ldi	r24, 0x02	; 2
   14332:	80 93 bc 01 	sts	0x01BC, r24
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   14336:	80 e1       	ldi	r24, 0x10	; 16
   14338:	12 c1       	rjmp	.+548    	; 0x1455e <FMenuIdle+0x30a>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   1433a:	80 91 00 01 	lds	r24, 0x0100
   1433e:	81 30       	cpi	r24, 0x01	; 1
   14340:	09 f0       	breq	.+2      	; 0x14344 <FMenuIdle+0xf0>
   14342:	0f c1       	rjmp	.+542    	; 0x14562 <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14344:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14346:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14348:	82 e0       	ldi	r24, 0x02	; 2
   1434a:	80 93 bc 01 	sts	0x01BC, r24
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   1434e:	82 e1       	ldi	r24, 0x12	; 18
   14350:	06 c1       	rjmp	.+524    	; 0x1455e <FMenuIdle+0x30a>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   14352:	80 91 00 01 	lds	r24, 0x0100
   14356:	81 30       	cpi	r24, 0x01	; 1
   14358:	09 f0       	breq	.+2      	; 0x1435c <FMenuIdle+0x108>
   1435a:	03 c1       	rjmp	.+518    	; 0x14562 <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1435c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1435e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14360:	82 e0       	ldi	r24, 0x02	; 2
   14362:	80 93 bc 01 	sts	0x01BC, r24
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   14366:	81 e1       	ldi	r24, 0x11	; 17
   14368:	fa c0       	rjmp	.+500    	; 0x1455e <FMenuIdle+0x30a>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   1436a:	80 91 00 01 	lds	r24, 0x0100
   1436e:	81 30       	cpi	r24, 0x01	; 1
   14370:	09 f0       	breq	.+2      	; 0x14374 <FMenuIdle+0x120>
   14372:	f7 c0       	rjmp	.+494    	; 0x14562 <FMenuIdle+0x30e>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14374:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14376:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14378:	82 e0       	ldi	r24, 0x02	; 2
   1437a:	80 93 bc 01 	sts	0x01BC, r24
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   1437e:	8f e0       	ldi	r24, 0x0F	; 15
   14380:	ee c0       	rjmp	.+476    	; 0x1455e <FMenuIdle+0x30a>
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14382:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14384:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14386:	82 e0       	ldi	r24, 0x02	; 2
   14388:	80 93 bc 01 	sts	0x01BC, r24
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   1438c:	8d e0       	ldi	r24, 0x0D	; 13
   1438e:	e7 c0       	rjmp	.+462    	; 0x1455e <FMenuIdle+0x30a>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   14390:	00 d0       	rcall	.+0      	; 0x14392 <FMenuIdle+0x13e>
   14392:	00 d0       	rcall	.+0      	; 0x14394 <FMenuIdle+0x140>
   14394:	89 e8       	ldi	r24, 0x89	; 137
   14396:	9b e0       	ldi	r25, 0x0B	; 11
   14398:	ed b7       	in	r30, 0x3d	; 61
   1439a:	fe b7       	in	r31, 0x3e	; 62
   1439c:	92 83       	std	Z+2, r25	; 0x02
   1439e:	81 83       	std	Z+1, r24	; 0x01
   143a0:	8f e3       	ldi	r24, 0x3F	; 63
   143a2:	92 e2       	ldi	r25, 0x22	; 34
   143a4:	94 83       	std	Z+4, r25	; 0x04
   143a6:	83 83       	std	Z+3, r24	; 0x03
   143a8:	0e 94 2c aa 	call	0x15458	; 0x15458 <sprintf_P>
	     sendMessage56();
   143ac:	0f 90       	pop	r0
   143ae:	0f 90       	pop	r0
   143b0:	0f 90       	pop	r0
   143b2:	0f 90       	pop	r0
   143b4:	0e 94 43 7e 	call	0xfc86	; 0xfc86 <sendMessage56>
         stMenuIdle=miDisplayProses;
   143b8:	82 e0       	ldi	r24, 0x02	; 2
   143ba:	d1 c0       	rjmp	.+418    	; 0x1455e <FMenuIdle+0x30a>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   143bc:	80 91 b2 01 	lds	r24, 0x01B2
   143c0:	88 23       	and	r24, r24
   143c2:	09 f0       	breq	.+2      	; 0x143c6 <FMenuIdle+0x172>
   143c4:	95 c0       	rjmp	.+298    	; 0x144f0 <FMenuIdle+0x29c>
		     lcd_printf(3,1,PSTR("SedangProses"));
   143c6:	83 e0       	ldi	r24, 0x03	; 3
   143c8:	61 e0       	ldi	r22, 0x01	; 1
   143ca:	42 e3       	ldi	r20, 0x32	; 50
   143cc:	52 e2       	ldi	r21, 0x22	; 34
   143ce:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	         TimDisplay=0;
   143d2:	10 92 92 01 	sts	0x0192, r1
			 stMenuIdle=miWaitProses;
   143d6:	83 e0       	ldi	r24, 0x03	; 3
   143d8:	c2 c0       	rjmp	.+388    	; 0x1455e <FMenuIdle+0x30a>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   143da:	80 91 92 01 	lds	r24, 0x0192
   143de:	82 30       	cpi	r24, 0x02	; 2
   143e0:	08 f4       	brcc	.+2      	; 0x143e4 <FMenuIdle+0x190>
   143e2:	bf c0       	rjmp	.+382    	; 0x14562 <FMenuIdle+0x30e>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   143e4:	80 91 00 01 	lds	r24, 0x0100
   143e8:	81 30       	cpi	r24, 0x01	; 1
   143ea:	11 f4       	brne	.+4      	; 0x143f0 <FMenuIdle+0x19c>
   143ec:	84 e0       	ldi	r24, 0x04	; 4
   143ee:	b7 c0       	rjmp	.+366    	; 0x1455e <FMenuIdle+0x30a>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   143f0:	82 30       	cpi	r24, 0x02	; 2
   143f2:	09 f0       	breq	.+2      	; 0x143f6 <FMenuIdle+0x1a2>
   143f4:	b6 c0       	rjmp	.+364    	; 0x14562 <FMenuIdle+0x30e>
   143f6:	87 e0       	ldi	r24, 0x07	; 7
   143f8:	b2 c0       	rjmp	.+356    	; 0x1455e <FMenuIdle+0x30a>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   143fa:	80 91 ab 02 	lds	r24, 0x02AB
   143fe:	60 e0       	ldi	r22, 0x00	; 0
   14400:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <PrintStandalone>
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   14404:	81 31       	cpi	r24, 0x11	; 17
   14406:	09 f4       	brne	.+2      	; 0x1440a <FMenuIdle+0x1b6>
   14408:	a9 c0       	rjmp	.+338    	; 0x1455c <FMenuIdle+0x308>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   1440a:	82 31       	cpi	r24, 0x12	; 18
   1440c:	09 f0       	breq	.+2      	; 0x14410 <FMenuIdle+0x1bc>
   1440e:	a9 c0       	rjmp	.+338    	; 0x14562 <FMenuIdle+0x30e>
   14410:	88 e0       	ldi	r24, 0x08	; 8
   14412:	a5 c0       	rjmp	.+330    	; 0x1455e <FMenuIdle+0x30a>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   14414:	83 e0       	ldi	r24, 0x03	; 3
   14416:	61 e0       	ldi	r22, 0x01	; 1
   14418:	4d e1       	ldi	r20, 0x1D	; 29
   1441a:	52 e2       	ldi	r21, 0x22	; 34
   1441c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
         TimDisplay=0;
   14420:	10 92 92 01 	sts	0x0192, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   14424:	89 e0       	ldi	r24, 0x09	; 9
   14426:	9b c0       	rjmp	.+310    	; 0x1455e <FMenuIdle+0x30a>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   14428:	80 91 92 01 	lds	r24, 0x0192
   1442c:	82 30       	cpi	r24, 0x02	; 2
   1442e:	08 f4       	brcc	.+2      	; 0x14432 <FMenuIdle+0x1de>
   14430:	98 c0       	rjmp	.+304    	; 0x14562 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   14432:	83 e0       	ldi	r24, 0x03	; 3
   14434:	61 e0       	ldi	r22, 0x01	; 1
   14436:	48 e0       	ldi	r20, 0x08	; 8
   14438:	52 e2       	ldi	r21, 0x22	; 34
   1443a:	32 c0       	rjmp	.+100    	; 0x144a0 <FMenuIdle+0x24c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   1443c:	83 e0       	ldi	r24, 0x03	; 3
   1443e:	61 e0       	ldi	r22, 0x01	; 1
   14440:	43 ef       	ldi	r20, 0xF3	; 243
   14442:	51 e2       	ldi	r21, 0x21	; 33
   14444:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	     sendMessage98(ButtonID);
   14448:	80 91 ab 02 	lds	r24, 0x02AB
   1444c:	0e 94 d8 7b 	call	0xf7b0	; 0xf7b0 <sendMessage98>
		 ProcTimeOut=0;
   14450:	10 92 bb 01 	sts	0x01BB, r1
		 stMenuIdle=miWaitPlease;
   14454:	85 e0       	ldi	r24, 0x05	; 5
   14456:	83 c0       	rjmp	.+262    	; 0x1455e <FMenuIdle+0x30a>
	     break;
    case miWaitPlease:	     
         if (ProcTimeOut>TIM_NO_RESPONSE){
   14458:	80 91 bb 01 	lds	r24, 0x01BB
   1445c:	8f 30       	cpi	r24, 0x0F	; 15
   1445e:	58 f0       	brcs	.+22     	; 0x14476 <FMenuIdle+0x222>
	         lcd_printf(3,1,PSTR("No Response..       "));
   14460:	83 e0       	ldi	r24, 0x03	; 3
   14462:	61 e0       	ldi	r22, 0x01	; 1
   14464:	4e ed       	ldi	r20, 0xDE	; 222
   14466:	51 e2       	ldi	r21, 0x21	; 33
   14468:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		     stMenuIdle=miNoResponse;
   1446c:	86 e0       	ldi	r24, 0x06	; 6
   1446e:	80 93 ac 02 	sts	0x02AC, r24
			 TimDisplay=0;		 
   14472:	10 92 92 01 	sts	0x0192, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   14476:	80 91 9f 01 	lds	r24, 0x019F
   1447a:	81 30       	cpi	r24, 0x01	; 1
   1447c:	29 f0       	breq	.+10     	; 0x14488 <FMenuIdle+0x234>
   1447e:	80 91 9e 01 	lds	r24, 0x019E
   14482:	81 30       	cpi	r24, 0x01	; 1
   14484:	09 f0       	breq	.+2      	; 0x14488 <FMenuIdle+0x234>
   14486:	6d c0       	rjmp	.+218    	; 0x14562 <FMenuIdle+0x30e>
		     ClearMem(strOdometer);
   14488:	83 ec       	ldi	r24, 0xC3	; 195
   1448a:	93 e0       	ldi	r25, 0x03	; 3
   1448c:	0e 94 80 a4 	call	0x14900	; 0x14900 <ClearMem>
		     ClearMem(strLicPlate);
   14490:	8a ef       	ldi	r24, 0xFA	; 250
   14492:	98 e0       	ldi	r25, 0x08	; 8
   14494:	0e 94 80 a4 	call	0x14900	; 0x14900 <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   14498:	83 e0       	ldi	r24, 0x03	; 3
   1449a:	61 e0       	ldi	r22, 0x01	; 1
   1449c:	49 ec       	ldi	r20, 0xC9	; 201
   1449e:	51 e2       	ldi	r21, 0x21	; 33
   144a0:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		     stMenuIdle=miWaitReady;
   144a4:	8a e0       	ldi	r24, 0x0A	; 10
   144a6:	80 93 ac 02 	sts	0x02AC, r24
			 TimDisplay=0;
   144aa:	10 92 92 01 	sts	0x0192, r1
   144ae:	59 c0       	rjmp	.+178    	; 0x14562 <FMenuIdle+0x30e>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   144b0:	80 91 92 01 	lds	r24, 0x0192
   144b4:	82 30       	cpi	r24, 0x02	; 2
   144b6:	08 f4       	brcc	.+2      	; 0x144ba <FMenuIdle+0x266>
   144b8:	54 c0       	rjmp	.+168    	; 0x14562 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   144ba:	83 e0       	ldi	r24, 0x03	; 3
   144bc:	61 e0       	ldi	r22, 0x01	; 1
   144be:	44 eb       	ldi	r20, 0xB4	; 180
   144c0:	51 e2       	ldi	r21, 0x21	; 33
   144c2:	ee cf       	rjmp	.-36     	; 0x144a0 <FMenuIdle+0x24c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   144c4:	80 91 92 01 	lds	r24, 0x0192
   144c8:	82 30       	cpi	r24, 0x02	; 2
   144ca:	08 f4       	brcc	.+2      	; 0x144ce <FMenuIdle+0x27a>
   144cc:	4a c0       	rjmp	.+148    	; 0x14562 <FMenuIdle+0x30e>
	         lcd_printf(3,1,PSTR("                "));
   144ce:	83 e0       	ldi	r24, 0x03	; 3
   144d0:	61 e0       	ldi	r22, 0x01	; 1
   144d2:	43 ea       	ldi	r20, 0xA3	; 163
   144d4:	51 e2       	ldi	r21, 0x21	; 33
   144d6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		     stMenuIdle=miReady;
   144da:	8b e0       	ldi	r24, 0x0B	; 11
   144dc:	e4 cf       	rjmp	.-56     	; 0x144a6 <FMenuIdle+0x252>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     DisplayScreenIdle();
   144de:	0e 94 9c 46 	call	0x8d38	; 0x8d38 <DisplayScreenIdle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   144e2:	80 91 00 01 	lds	r24, 0x0100
   144e6:	82 30       	cpi	r24, 0x02	; 2
   144e8:	19 f4       	brne	.+6      	; 0x144f0 <FMenuIdle+0x29c>
   144ea:	81 e0       	ldi	r24, 0x01	; 1
   144ec:	80 93 01 01 	sts	0x0101, r24
		 stMenuIdle=miScan;
   144f0:	81 e0       	ldi	r24, 0x01	; 1
   144f2:	35 c0       	rjmp	.+106    	; 0x1455e <FMenuIdle+0x30a>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   144f4:	0e 94 ff 7b 	call	0xf7fe	; 0xf7fe <FMenuTicket>
   144f8:	2f c0       	rjmp	.+94     	; 0x14558 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   144fa:	0e 94 fd 8c 	call	0x119fa	; 0x119fa <FMenuAuthorization>
   144fe:	2c c0       	rjmp	.+88     	; 0x14558 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   14500:	0e 94 47 7e 	call	0xfc8e	; 0xfc8e <FMenuLocalAccount>
   14504:	29 c0       	rjmp	.+82     	; 0x14558 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   14506:	0e 94 0d 87 	call	0x10e1a	; 0x10e1a <FMenuChangeMOP>
   1450a:	26 c0       	rjmp	.+76     	; 0x14558 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   1450c:	0e 94 56 7d 	call	0xfaac	; 0xfaac <FMenuEDCTransaction>
   14510:	23 c0       	rjmp	.+70     	; 0x14558 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   14512:	0e 94 67 8d 	call	0x11ace	; 0x11ace <FMenuLoyalty>
   14516:	20 c0       	rjmp	.+64     	; 0x14558 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   14518:	0e 94 49 8b 	call	0x11692	; 0x11692 <FMenuReprint>
   1451c:	1d c0       	rjmp	.+58     	; 0x14558 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   1451e:	0e 94 bf 45 	call	0x8b7e	; 0x8b7e <FViewFreeMessage>
   14522:	1a c0       	rjmp	.+52     	; 0x14558 <FMenuIdle+0x304>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   14524:	83 e0       	ldi	r24, 0x03	; 3
   14526:	61 e0       	ldi	r22, 0x01	; 1
   14528:	4e e8       	ldi	r20, 0x8E	; 142
   1452a:	51 e2       	ldi	r21, 0x21	; 33
   1452c:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   14530:	80 e0       	ldi	r24, 0x00	; 0
   14532:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   14536:	81 e0       	ldi	r24, 0x01	; 1
   14538:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <ResetTotalizer>
   1453c:	0f c0       	rjmp	.+30     	; 0x1455c <FMenuIdle+0x308>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   1453e:	83 e0       	ldi	r24, 0x03	; 3
   14540:	61 e0       	ldi	r22, 0x01	; 1
   14542:	4c e7       	ldi	r20, 0x7C	; 124
   14544:	51 e2       	ldi	r21, 0x21	; 33
   14546:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   1454a:	85 e0       	ldi	r24, 0x05	; 5
   1454c:	62 e1       	ldi	r22, 0x12	; 18
   1454e:	0e 94 dd 5e 	call	0xbdba	; 0xbdba <SendSlaveCommand>
   14552:	04 c0       	rjmp	.+8      	; 0x1455c <FMenuIdle+0x308>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   14554:	0e 94 f9 45 	call	0x8bf2	; 0x8bf2 <FTestChar>
   14558:	81 30       	cpi	r24, 0x01	; 1
   1455a:	19 f4       	brne	.+6      	; 0x14562 <FMenuIdle+0x30e>
         stMenuIdle=miReady;
   1455c:	8b e0       	ldi	r24, 0x0B	; 11
   1455e:	80 93 ac 02 	sts	0x02AC, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   14562:	80 91 a1 01 	lds	r24, 0x01A1
   14566:	81 30       	cpi	r24, 0x01	; 1
   14568:	21 f4       	brne	.+8      	; 0x14572 <FMenuIdle+0x31e>
		    IsMessage21=False;
   1456a:	10 92 a1 01 	sts	0x01A1, r1
			procMessage21();
   1456e:	0e 94 ea 1b 	call	0x37d4	; 0x37d4 <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   14572:	80 91 9e 01 	lds	r24, 0x019E
   14576:	81 30       	cpi	r24, 0x01	; 1
   14578:	91 f4       	brne	.+36     	; 0x1459e <FMenuIdle+0x34a>
		    IsMessage00=False;
   1457a:	10 92 9e 01 	sts	0x019E, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   1457e:	20 91 1d 09 	lds	r18, 0x091D
   14582:	21 30       	cpi	r18, 0x01	; 1
   14584:	61 f4       	brne	.+24     	; 0x1459e <FMenuIdle+0x34a>
   14586:	80 91 8b 01 	lds	r24, 0x018B
   1458a:	90 91 8c 01 	lds	r25, 0x018C
   1458e:	8f 97       	sbiw	r24, 0x2f	; 47
   14590:	31 f4       	brne	.+12     	; 0x1459e <FMenuIdle+0x34a>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   14592:	80 91 42 09 	lds	r24, 0x0942
   14596:	84 33       	cpi	r24, 0x34	; 52
   14598:	11 f4       	brne	.+4      	; 0x1459e <FMenuIdle+0x34a>
			    IsNoTransaction=True;
   1459a:	20 93 ab 01 	sts	0x01AB, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   1459e:	80 91 97 01 	lds	r24, 0x0197
   145a2:	81 30       	cpi	r24, 0x01	; 1
   145a4:	21 f4       	brne	.+8      	; 0x145ae <FMenuIdle+0x35a>
		    IsSendMessageEDC=False;
   145a6:	10 92 97 01 	sts	0x0197, r1
			SendEDCMessage();
   145aa:	0e 94 58 5e 	call	0xbcb0	; 0xbcb0 <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   145ae:	80 91 99 01 	lds	r24, 0x0199
   145b2:	81 30       	cpi	r24, 0x01	; 1
   145b4:	21 f4       	brne	.+8      	; 0x145be <FMenuIdle+0x36a>
		    IsEDCApproved=False;
   145b6:	10 92 99 01 	sts	0x0199, r1
            sendMessage92();
   145ba:	0e 94 4e 7d 	call	0xfa9c	; 0xfa9c <sendMessage92>
		}
		if (IsVoidTransaction==True){
   145be:	80 91 9b 01 	lds	r24, 0x019B
   145c2:	81 30       	cpi	r24, 0x01	; 1
   145c4:	21 f4       	brne	.+8      	; 0x145ce <FMenuIdle+0x37a>
		    IsVoidTransaction=False;
   145c6:	10 92 9b 01 	sts	0x019B, r1
            sendMessage94();
   145ca:	0e 94 4a 7d 	call	0xfa94	; 0xfa94 <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   145ce:	10 91 9f 01 	lds	r17, 0x019F
   145d2:	11 30       	cpi	r17, 0x01	; 1
   145d4:	31 f4       	brne	.+12     	; 0x145e2 <FMenuIdle+0x38e>
	        IsMessage99=False;
   145d6:	10 92 9f 01 	sts	0x019F, r1
		    procMessage99();
   145da:	0e 94 19 40 	call	0x8032	; 0x8032 <procMessage99>
		    IsPrinting=True;
   145de:	10 93 ac 01 	sts	0x01AC, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   145e2:	80 91 ab 01 	lds	r24, 0x01AB
   145e6:	81 30       	cpi	r24, 0x01	; 1
   145e8:	41 f4       	brne	.+16     	; 0x145fa <FMenuIdle+0x3a6>
			IsNoTransaction=False;
   145ea:	10 92 ab 01 	sts	0x01AB, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   145ee:	83 e0       	ldi	r24, 0x03	; 3
   145f0:	61 e0       	ldi	r22, 0x01	; 1
   145f2:	47 e6       	ldi	r20, 0x67	; 103
   145f4:	51 e2       	ldi	r21, 0x21	; 33
   145f6:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   145fa:	80 91 ac 02 	lds	r24, 0x02AC
   145fe:	81 30       	cpi	r24, 0x01	; 1
   14600:	11 f4       	brne	.+4      	; 0x14606 <FMenuIdle+0x3b2>
		    DisplayIdle();			
   14602:	0e 94 ec 5c 	call	0xb9d8	; 0xb9d8 <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   14606:	80 91 ac 02 	lds	r24, 0x02AC
   1460a:	81 30       	cpi	r24, 0x01	; 1
   1460c:	59 f4       	brne	.+22     	; 0x14624 <FMenuIdle+0x3d0>
		    if (IsMessage09==True){
   1460e:	80 91 a3 01 	lds	r24, 0x01A3
   14612:	81 30       	cpi	r24, 0x01	; 1
   14614:	39 f4       	brne	.+14     	; 0x14624 <FMenuIdle+0x3d0>
			    IsMessage09=False;
   14616:	10 92 a3 01 	sts	0x01A3, r1
				procMessage09();
   1461a:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   1461e:	83 e1       	ldi	r24, 0x13	; 19
   14620:	80 93 ac 02 	sts	0x02AC, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   14624:	80 91 ac 02 	lds	r24, 0x02AC
   14628:	81 30       	cpi	r24, 0x01	; 1
   1462a:	71 f4       	brne	.+28     	; 0x14648 <FMenuIdle+0x3f4>
   1462c:	80 91 98 01 	lds	r24, 0x0198
   14630:	81 30       	cpi	r24, 0x01	; 1
   14632:	51 f4       	brne	.+20     	; 0x14648 <FMenuIdle+0x3f4>
		    IsRFIDDetected=False;
   14634:	10 92 98 01 	sts	0x0198, r1
	//uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14638:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1463a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1463c:	82 e0       	ldi	r24, 0x02	; 2
   1463e:	80 93 bc 01 	sts	0x01BC, r24

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
		    IsRFIDDetected=False;
		    system_beep(2);           
			stMenuIdle=miRunLocalAccount;
   14642:	8e e0       	ldi	r24, 0x0E	; 14
   14644:	80 93 ac 02 	sts	0x02AC, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   14648:	10 91 a6 01 	lds	r17, 0x01A6
   1464c:	11 30       	cpi	r17, 0x01	; 1
   1464e:	41 f4       	brne	.+16     	; 0x14660 <FMenuIdle+0x40c>
		    IsMessage81=False;
   14650:	10 92 a6 01 	sts	0x01A6, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   14654:	0e 94 4e 17 	call	0x2e9c	; 0x2e9c <procMessage81>
   14658:	80 93 b5 01 	sts	0x01B5, r24
			IsFreePrinting=True;
   1465c:	10 93 a8 01 	sts	0x01A8, r17
         }

    //SystemService
      systemGenerateReport();
   14660:	0e 94 a0 32 	call	0x6540	; 0x6540 <systemGenerateReport>
      systemPrinting();
   14664:	0e 94 ea 9c 	call	0x139d4	; 0x139d4 <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   14668:	0e 94 04 a1 	call	0x14208	; 0x14208 <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   1466c:	1f 91       	pop	r17
   1466e:	08 95       	ret

00014670 <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   14670:	98 2f       	mov	r25, r24
   14672:	90 7f       	andi	r25, 0xF0	; 240
   14674:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   14676:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   14678:	a9 9a       	sbi	0x15, 1	; 21
   1467a:	48 ee       	ldi	r20, 0xE8	; 232
   1467c:	53 e0       	ldi	r21, 0x03	; 3
   1467e:	fa 01       	movw	r30, r20
   14680:	31 97       	sbiw	r30, 0x01	; 1
   14682:	f1 f7       	brne	.-4      	; 0x14680 <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   14684:	a9 98       	cbi	0x15, 1	; 21
   14686:	fa 01       	movw	r30, r20
   14688:	31 97       	sbiw	r30, 0x01	; 1
   1468a:	f1 f7       	brne	.-4      	; 0x14688 <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   1468c:	28 2f       	mov	r18, r24
   1468e:	30 e0       	ldi	r19, 0x00	; 0
   14690:	94 e0       	ldi	r25, 0x04	; 4
   14692:	22 0f       	add	r18, r18
   14694:	33 1f       	adc	r19, r19
   14696:	9a 95       	dec	r25
   14698:	e1 f7       	brne	.-8      	; 0x14692 <lcd_command+0x22>
   1469a:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   1469c:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   1469e:	a9 9a       	sbi	0x15, 1	; 21
   146a0:	fa 01       	movw	r30, r20
   146a2:	31 97       	sbiw	r30, 0x01	; 1
   146a4:	f1 f7       	brne	.-4      	; 0x146a2 <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   146a6:	a9 98       	cbi	0x15, 1	; 21
   146a8:	fa 01       	movw	r30, r20
   146aa:	31 97       	sbiw	r30, 0x01	; 1
   146ac:	f1 f7       	brne	.-4      	; 0x146aa <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   146ae:	fa 01       	movw	r30, r20
   146b0:	31 97       	sbiw	r30, 0x01	; 1
   146b2:	f1 f7       	brne	.-4      	; 0x146b0 <lcd_command+0x40>
   146b4:	81 30       	cpi	r24, 0x01	; 1
   146b6:	21 f4       	brne	.+8      	; 0x146c0 <lcd_command+0x50>
   146b8:	84 ed       	ldi	r24, 0xD4	; 212
   146ba:	90 e3       	ldi	r25, 0x30	; 48
   146bc:	01 97       	sbiw	r24, 0x01	; 1
   146be:	f1 f7       	brne	.-4      	; 0x146bc <lcd_command+0x4c>
   146c0:	08 95       	ret

000146c2 <lcd_init>:
   146c2:	86 ea       	ldi	r24, 0xA6	; 166
   146c4:	9e e0       	ldi	r25, 0x0E	; 14
   146c6:	01 97       	sbiw	r24, 0x01	; 1
   146c8:	f1 f7       	brne	.-4      	; 0x146c6 <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   146ca:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   146cc:	84 b3       	in	r24, 0x14	; 20
   146ce:	80 6f       	ori	r24, 0xF0	; 240
   146d0:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   146d2:	84 b3       	in	r24, 0x14	; 20
   146d4:	8e 60       	ori	r24, 0x0E	; 14
   146d6:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   146d8:	20 e3       	ldi	r18, 0x30	; 48
   146da:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   146dc:	a9 9a       	sbi	0x15, 1	; 21
   146de:	88 ee       	ldi	r24, 0xE8	; 232
   146e0:	93 e0       	ldi	r25, 0x03	; 3
   146e2:	fc 01       	movw	r30, r24
   146e4:	31 97       	sbiw	r30, 0x01	; 1
   146e6:	f1 f7       	brne	.-4      	; 0x146e4 <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   146e8:	a9 98       	cbi	0x15, 1	; 21
   146ea:	fc 01       	movw	r30, r24
   146ec:	31 97       	sbiw	r30, 0x01	; 1
   146ee:	f1 f7       	brne	.-4      	; 0x146ec <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   146f0:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   146f2:	a9 9a       	sbi	0x15, 1	; 21
   146f4:	fc 01       	movw	r30, r24
   146f6:	31 97       	sbiw	r30, 0x01	; 1
   146f8:	f1 f7       	brne	.-4      	; 0x146f6 <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   146fa:	a9 98       	cbi	0x15, 1	; 21
   146fc:	fc 01       	movw	r30, r24
   146fe:	31 97       	sbiw	r30, 0x01	; 1
   14700:	f1 f7       	brne	.-4      	; 0x146fe <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   14702:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   14704:	a9 9a       	sbi	0x15, 1	; 21
   14706:	fc 01       	movw	r30, r24
   14708:	31 97       	sbiw	r30, 0x01	; 1
   1470a:	f1 f7       	brne	.-4      	; 0x14708 <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1470c:	a9 98       	cbi	0x15, 1	; 21
   1470e:	fc 01       	movw	r30, r24
   14710:	31 97       	sbiw	r30, 0x01	; 1
   14712:	f1 f7       	brne	.-4      	; 0x14710 <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   14714:	20 e2       	ldi	r18, 0x20	; 32
   14716:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   14718:	a9 9a       	sbi	0x15, 1	; 21
   1471a:	fc 01       	movw	r30, r24
   1471c:	31 97       	sbiw	r30, 0x01	; 1
   1471e:	f1 f7       	brne	.-4      	; 0x1471c <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   14720:	a9 98       	cbi	0x15, 1	; 21
   14722:	01 97       	sbiw	r24, 0x01	; 1
   14724:	f1 f7       	brne	.-4      	; 0x14722 <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   14726:	81 e0       	ldi	r24, 0x01	; 1
   14728:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   1472c:	e4 e6       	ldi	r30, 0x64	; 100
   1472e:	f0 e0       	ldi	r31, 0x00	; 0
   14730:	80 81       	ld	r24, Z
   14732:	82 60       	ori	r24, 0x02	; 2
   14734:	80 83       	st	Z, r24

	lcd_command(0x28);
   14736:	88 e2       	ldi	r24, 0x28	; 40
   14738:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
	lcd_command(0x0c);
   1473c:	8c e0       	ldi	r24, 0x0C	; 12
   1473e:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
	lcd_command(0x06);
   14742:	86 e0       	ldi	r24, 0x06	; 6
   14744:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
}
   14748:	08 95       	ret

0001474a <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   1474a:	28 2f       	mov	r18, r24
   1474c:	20 7f       	andi	r18, 0xF0	; 240
   1474e:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   14750:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   14752:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   14754:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   14756:	90 e0       	ldi	r25, 0x00	; 0
   14758:	24 e0       	ldi	r18, 0x04	; 4
   1475a:	88 0f       	add	r24, r24
   1475c:	99 1f       	adc	r25, r25
   1475e:	2a 95       	dec	r18
   14760:	e1 f7       	brne	.-8      	; 0x1475a <_lcd+0x10>
   14762:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   14764:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   14766:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   14768:	a9 98       	cbi	0x15, 1	; 21
   1476a:	88 ee       	ldi	r24, 0xE8	; 232
   1476c:	93 e0       	ldi	r25, 0x03	; 3
   1476e:	01 97       	sbiw	r24, 0x01	; 1
   14770:	f1 f7       	brne	.-4      	; 0x1476e <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   14772:	8a ef       	ldi	r24, 0xFA	; 250
   14774:	90 e0       	ldi	r25, 0x00	; 0
   14776:	01 97       	sbiw	r24, 0x01	; 1
   14778:	f1 f7       	brne	.-4      	; 0x14776 <_lcd+0x2c>
   1477a:	08 95       	ret

0001477c <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   1477c:	cf 93       	push	r28
   1477e:	df 93       	push	r29
   14780:	ec 01       	movw	r28, r24
   14782:	03 c0       	rjmp	.+6      	; 0x1478a <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   14784:	21 96       	adiw	r28, 0x01	; 1
   14786:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   1478a:	88 81       	ld	r24, Y
   1478c:	88 23       	and	r24, r24
   1478e:	d1 f7       	brne	.-12     	; 0x14784 <lcd_string+0x8>
		_lcd(*__string++);
}
   14790:	df 91       	pop	r29
   14792:	cf 91       	pop	r28
   14794:	08 95       	ret

00014796 <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   14796:	82 30       	cpi	r24, 0x02	; 2
   14798:	69 f0       	breq	.+26     	; 0x147b4 <lcd_xy+0x1e>
   1479a:	83 30       	cpi	r24, 0x03	; 3
   1479c:	18 f4       	brcc	.+6      	; 0x147a4 <lcd_xy+0xe>
   1479e:	81 30       	cpi	r24, 0x01	; 1
   147a0:	a9 f4       	brne	.+42     	; 0x147cc <lcd_xy+0x36>
   147a2:	05 c0       	rjmp	.+10     	; 0x147ae <lcd_xy+0x18>
   147a4:	83 30       	cpi	r24, 0x03	; 3
   147a6:	49 f0       	breq	.+18     	; 0x147ba <lcd_xy+0x24>
   147a8:	84 30       	cpi	r24, 0x04	; 4
   147aa:	81 f4       	brne	.+32     	; 0x147cc <lcd_xy+0x36>
   147ac:	0b c0       	rjmp	.+22     	; 0x147c4 <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   147ae:	86 2f       	mov	r24, r22
   147b0:	81 58       	subi	r24, 0x81	; 129
   147b2:	05 c0       	rjmp	.+10     	; 0x147be <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   147b4:	86 2f       	mov	r24, r22
   147b6:	81 54       	subi	r24, 0x41	; 65
   147b8:	02 c0       	rjmp	.+4      	; 0x147be <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   147ba:	86 2f       	mov	r24, r22
   147bc:	8d 56       	subi	r24, 0x6D	; 109
   147be:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
   147c2:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   147c4:	86 2f       	mov	r24, r22
   147c6:	8d 52       	subi	r24, 0x2D	; 45
   147c8:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
   147cc:	08 95       	ret

000147ce <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   147ce:	df 92       	push	r13
   147d0:	ef 92       	push	r14
   147d2:	ff 92       	push	r15
   147d4:	0f 93       	push	r16
   147d6:	1f 93       	push	r17
   147d8:	cf 93       	push	r28
   147da:	df 93       	push	r29
   147dc:	06 2f       	mov	r16, r22
   147de:	d4 2e       	mov	r13, r20
   147e0:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   147e2:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
   147e6:	2d 2d       	mov	r18, r13
   147e8:	31 2f       	mov	r19, r17
   147ea:	c9 01       	movw	r24, r18
   147ec:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   147ee:	34 e1       	ldi	r19, 0x14	; 20
   147f0:	e3 2e       	mov	r14, r19
   147f2:	f1 2c       	mov	r15, r1
   147f4:	e0 1a       	sub	r14, r16
   147f6:	f1 08       	sbc	r15, r1
   147f8:	04 c0       	rjmp	.+8      	; 0x14802 <lcd_print+0x34>
		_lcd(*__string);__string++;
   147fa:	82 2f       	mov	r24, r18
   147fc:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
   14800:	21 96       	adiw	r28, 0x01	; 1
   14802:	9e 01       	movw	r18, r28
   14804:	2d 19       	sub	r18, r13
   14806:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   14808:	28 81       	ld	r18, Y
   1480a:	22 23       	and	r18, r18
   1480c:	21 f0       	breq	.+8      	; 0x14816 <lcd_print+0x48>
   1480e:	90 e0       	ldi	r25, 0x00	; 0
   14810:	e8 16       	cp	r14, r24
   14812:	f9 06       	cpc	r15, r25
   14814:	94 f7       	brge	.-28     	; 0x147fa <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   14816:	df 91       	pop	r29
   14818:	cf 91       	pop	r28
   1481a:	1f 91       	pop	r17
   1481c:	0f 91       	pop	r16
   1481e:	ff 90       	pop	r15
   14820:	ef 90       	pop	r14
   14822:	df 90       	pop	r13
   14824:	08 95       	ret

00014826 <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   14826:	df 92       	push	r13
   14828:	ef 92       	push	r14
   1482a:	ff 92       	push	r15
   1482c:	0f 93       	push	r16
   1482e:	1f 93       	push	r17
   14830:	cf 93       	push	r28
   14832:	df 93       	push	r29
   14834:	06 2f       	mov	r16, r22
   14836:	d4 2e       	mov	r13, r20
   14838:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   1483a:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
   1483e:	8d 2d       	mov	r24, r13
   14840:	91 2f       	mov	r25, r17
   14842:	fc 01       	movw	r30, r24
   14844:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   14846:	44 e1       	ldi	r20, 0x14	; 20
   14848:	e4 2e       	mov	r14, r20
   1484a:	f1 2c       	mov	r15, r1
   1484c:	e0 1a       	sub	r14, r16
   1484e:	f1 08       	sbc	r15, r1
   14850:	04 c0       	rjmp	.+8      	; 0x1485a <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   14852:	82 2f       	mov	r24, r18
   14854:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
		__string++;
   14858:	21 96       	adiw	r28, 0x01	; 1
   1485a:	9e 01       	movw	r18, r28
   1485c:	2d 19       	sub	r18, r13
   1485e:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   14860:	fe 01       	movw	r30, r28
   14862:	24 91       	lpm	r18, Z+
   14864:	22 23       	and	r18, r18
   14866:	21 f0       	breq	.+8      	; 0x14870 <lcd_printf+0x4a>
   14868:	90 e0       	ldi	r25, 0x00	; 0
   1486a:	e8 16       	cp	r14, r24
   1486c:	f9 06       	cpc	r15, r25
   1486e:	8c f7       	brge	.-30     	; 0x14852 <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   14870:	df 91       	pop	r29
   14872:	cf 91       	pop	r28
   14874:	1f 91       	pop	r17
   14876:	0f 91       	pop	r16
   14878:	ff 90       	pop	r15
   1487a:	ef 90       	pop	r14
   1487c:	df 90       	pop	r13
   1487e:	08 95       	ret

00014880 <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   14880:	81 e0       	ldi	r24, 0x01	; 1
   14882:	61 e0       	ldi	r22, 0x01	; 1
   14884:	47 e8       	ldi	r20, 0x87	; 135
   14886:	52 e2       	ldi	r21, 0x22	; 34
   14888:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   1488c:	82 e0       	ldi	r24, 0x02	; 2
   1488e:	61 e0       	ldi	r22, 0x01	; 1
   14890:	42 e7       	ldi	r20, 0x72	; 114
   14892:	52 e2       	ldi	r21, 0x22	; 34
   14894:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   14898:	83 e0       	ldi	r24, 0x03	; 3
   1489a:	61 e0       	ldi	r22, 0x01	; 1
   1489c:	4d e5       	ldi	r20, 0x5D	; 93
   1489e:	52 e2       	ldi	r21, 0x22	; 34
   148a0:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   148a4:	84 e0       	ldi	r24, 0x04	; 4
   148a6:	61 e0       	ldi	r22, 0x01	; 1
   148a8:	48 e4       	ldi	r20, 0x48	; 72
   148aa:	52 e2       	ldi	r21, 0x22	; 34
   148ac:	0e 94 13 a4 	call	0x14826	; 0x14826 <lcd_printf>
}
   148b0:	08 95       	ret

000148b2 <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   148b2:	1f 93       	push	r17
   148b4:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   148b6:	0e 94 cb a3 	call	0x14796	; 0x14796 <lcd_xy>
	_lcd(__chr);
   148ba:	81 2f       	mov	r24, r17
   148bc:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
}
   148c0:	1f 91       	pop	r17
   148c2:	08 95       	ret

000148c4 <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   148c4:	0f 93       	push	r16
   148c6:	1f 93       	push	r17
   148c8:	cf 93       	push	r28
   148ca:	df 93       	push	r29
   148cc:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   148ce:	88 30       	cpi	r24, 0x08	; 8
   148d0:	90 f4       	brcc	.+36     	; 0x148f6 <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   148d2:	88 0f       	add	r24, r24
   148d4:	88 0f       	add	r24, r24
   148d6:	88 0f       	add	r24, r24
   148d8:	80 5c       	subi	r24, 0xC0	; 192
   148da:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
   148de:	c0 e0       	ldi	r28, 0x00	; 0
   148e0:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   148e2:	f8 01       	movw	r30, r16
   148e4:	ec 0f       	add	r30, r28
   148e6:	fd 1f       	adc	r31, r29
   148e8:	80 81       	ld	r24, Z
   148ea:	0e 94 a5 a3 	call	0x1474a	; 0x1474a <_lcd>
   148ee:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   148f0:	c8 30       	cpi	r28, 0x08	; 8
   148f2:	d1 05       	cpc	r29, r1
   148f4:	b1 f7       	brne	.-20     	; 0x148e2 <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   148f6:	df 91       	pop	r29
   148f8:	cf 91       	pop	r28
   148fa:	1f 91       	pop	r17
   148fc:	0f 91       	pop	r16
   148fe:	08 95       	ret

00014900 <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   14900:	cf 93       	push	r28
   14902:	df 93       	push	r29
   14904:	20 e0       	ldi	r18, 0x00	; 0
   14906:	04 c0       	rjmp	.+8      	; 0x14910 <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   14908:	c8 0f       	add	r28, r24
   1490a:	d9 1f       	adc	r29, r25
   1490c:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   1490e:	2f 5f       	subi	r18, 0xFF	; 255
   14910:	c2 2f       	mov	r28, r18
   14912:	d0 e0       	ldi	r29, 0x00	; 0
   14914:	fc 01       	movw	r30, r24
   14916:	01 90       	ld	r0, Z+
   14918:	00 20       	and	r0, r0
   1491a:	e9 f7       	brne	.-6      	; 0x14916 <ClearMem+0x16>
   1491c:	31 97       	sbiw	r30, 0x01	; 1
   1491e:	e8 1b       	sub	r30, r24
   14920:	f9 0b       	sbc	r31, r25
   14922:	ce 17       	cp	r28, r30
   14924:	df 07       	cpc	r29, r31
   14926:	80 f3       	brcs	.-32     	; 0x14908 <ClearMem+0x8>
          string[i]=0;
	 }     
}
   14928:	df 91       	pop	r29
   1492a:	cf 91       	pop	r28
   1492c:	08 95       	ret

0001492e <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   1492e:	df 93       	push	r29
   14930:	cf 93       	push	r28
   14932:	00 d0       	rcall	.+0      	; 0x14934 <_key_hit+0x6>
   14934:	00 d0       	rcall	.+0      	; 0x14936 <_key_hit+0x8>
   14936:	cd b7       	in	r28, 0x3d	; 61
   14938:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   1493a:	8f ee       	ldi	r24, 0xEF	; 239
   1493c:	89 83       	std	Y+1, r24	; 0x01
   1493e:	8f ed       	ldi	r24, 0xDF	; 223
   14940:	8a 83       	std	Y+2, r24	; 0x02
   14942:	8f eb       	ldi	r24, 0xBF	; 191
   14944:	8b 83       	std	Y+3, r24	; 0x03
   14946:	8f e7       	ldi	r24, 0x7F	; 127
   14948:	8c 83       	std	Y+4, r24	; 0x04
   1494a:	de 01       	movw	r26, r28
   1494c:	11 96       	adiw	r26, 0x01	; 1
   1494e:	2a ef       	ldi	r18, 0xFA	; 250
   14950:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   14952:	ae 01       	movw	r20, r28
   14954:	4b 5f       	subi	r20, 0xFB	; 251
   14956:	5f 4f       	sbci	r21, 0xFF	; 255
   14958:	c9 01       	movw	r24, r18
   1495a:	01 97       	sbiw	r24, 0x01	; 1
   1495c:	f1 f7       	brne	.-4      	; 0x1495a <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   1495e:	8c 91       	ld	r24, X
   14960:	80 93 62 00 	sts	0x0062, r24
   14964:	f9 01       	movw	r30, r18
   14966:	31 97       	sbiw	r30, 0x01	; 1
   14968:	f1 f7       	brne	.-4      	; 0x14966 <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   1496a:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   1496c:	98 17       	cp	r25, r24
   1496e:	21 f4       	brne	.+8      	; 0x14978 <_key_hit+0x4a>
		    break;
   14970:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   14972:	a4 17       	cp	r26, r20
   14974:	b5 07       	cpc	r27, r21
   14976:	81 f7       	brne	.-32     	; 0x14958 <_key_hit+0x2a>
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) 
		    break;
	}
	return keyhit;
}
   14978:	89 2f       	mov	r24, r25
   1497a:	0f 90       	pop	r0
   1497c:	0f 90       	pop	r0
   1497e:	0f 90       	pop	r0
   14980:	0f 90       	pop	r0
   14982:	cf 91       	pop	r28
   14984:	df 91       	pop	r29
   14986:	08 95       	ret

00014988 <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   14988:	8e 3e       	cpi	r24, 0xEE	; 238
   1498a:	f9 f0       	breq	.+62     	; 0x149ca <_key_crr+0x42>
   1498c:	8e 3d       	cpi	r24, 0xDE	; 222
   1498e:	e9 f0       	breq	.+58     	; 0x149ca <_key_crr+0x42>
   14990:	8e 3b       	cpi	r24, 0xBE	; 190
   14992:	d9 f0       	breq	.+54     	; 0x149ca <_key_crr+0x42>
   14994:	8d 3e       	cpi	r24, 0xED	; 237
   14996:	c9 f0       	breq	.+50     	; 0x149ca <_key_crr+0x42>
   14998:	8d 3d       	cpi	r24, 0xDD	; 221
   1499a:	b9 f0       	breq	.+46     	; 0x149ca <_key_crr+0x42>
   1499c:	8d 3b       	cpi	r24, 0xBD	; 189
   1499e:	a9 f0       	breq	.+42     	; 0x149ca <_key_crr+0x42>
   149a0:	8b 3e       	cpi	r24, 0xEB	; 235
   149a2:	99 f0       	breq	.+38     	; 0x149ca <_key_crr+0x42>
   149a4:	8b 3d       	cpi	r24, 0xDB	; 219
   149a6:	89 f0       	breq	.+34     	; 0x149ca <_key_crr+0x42>
   149a8:	8b 3b       	cpi	r24, 0xBB	; 187
   149aa:	79 f0       	breq	.+30     	; 0x149ca <_key_crr+0x42>
   149ac:	87 3d       	cpi	r24, 0xD7	; 215
   149ae:	69 f0       	breq	.+26     	; 0x149ca <_key_crr+0x42>
   149b0:	87 3e       	cpi	r24, 0xE7	; 231
   149b2:	59 f0       	breq	.+22     	; 0x149ca <_key_crr+0x42>
   149b4:	87 3b       	cpi	r24, 0xB7	; 183
   149b6:	49 f0       	breq	.+18     	; 0x149ca <_key_crr+0x42>
   149b8:	8e 37       	cpi	r24, 0x7E	; 126
   149ba:	39 f0       	breq	.+14     	; 0x149ca <_key_crr+0x42>
   149bc:	8d 37       	cpi	r24, 0x7D	; 125
   149be:	29 f0       	breq	.+10     	; 0x149ca <_key_crr+0x42>
   149c0:	8b 37       	cpi	r24, 0x7B	; 123
   149c2:	19 f0       	breq	.+6      	; 0x149ca <_key_crr+0x42>
   149c4:	87 37       	cpi	r24, 0x77	; 119
   149c6:	09 f0       	breq	.+2      	; 0x149ca <_key_crr+0x42>
   149c8:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   149ca:	08 95       	ret

000149cc <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   149cc:	8e 3b       	cpi	r24, 0xBE	; 190
   149ce:	91 f1       	breq	.+100    	; 0x14a34 <_key_btn+0x68>
   149d0:	8f 3b       	cpi	r24, 0xBF	; 191
   149d2:	a8 f4       	brcc	.+42     	; 0x149fe <_key_btn+0x32>
   149d4:	8e 37       	cpi	r24, 0x7E	; 126
   149d6:	09 f4       	brne	.+2      	; 0x149da <_key_btn+0xe>
   149d8:	41 c0       	rjmp	.+130    	; 0x14a5c <_key_btn+0x90>
   149da:	8f 37       	cpi	r24, 0x7F	; 127
   149dc:	48 f4       	brcc	.+18     	; 0x149f0 <_key_btn+0x24>
   149de:	8b 37       	cpi	r24, 0x7B	; 123
   149e0:	09 f4       	brne	.+2      	; 0x149e4 <_key_btn+0x18>
   149e2:	40 c0       	rjmp	.+128    	; 0x14a64 <_key_btn+0x98>
   149e4:	8d 37       	cpi	r24, 0x7D	; 125
   149e6:	e1 f1       	breq	.+120    	; 0x14a60 <_key_btn+0x94>
   149e8:	87 37       	cpi	r24, 0x77	; 119
   149ea:	09 f0       	breq	.+2      	; 0x149ee <_key_btn+0x22>
   149ec:	3f c0       	rjmp	.+126    	; 0x14a6c <_key_btn+0xa0>
   149ee:	3c c0       	rjmp	.+120    	; 0x14a68 <_key_btn+0x9c>
   149f0:	8b 3b       	cpi	r24, 0xBB	; 187
   149f2:	61 f1       	breq	.+88     	; 0x14a4c <_key_btn+0x80>
   149f4:	8d 3b       	cpi	r24, 0xBD	; 189
   149f6:	21 f1       	breq	.+72     	; 0x14a40 <_key_btn+0x74>
   149f8:	87 3b       	cpi	r24, 0xB7	; 183
   149fa:	c1 f5       	brne	.+112    	; 0x14a6c <_key_btn+0xa0>
   149fc:	2d c0       	rjmp	.+90     	; 0x14a58 <_key_btn+0x8c>
   149fe:	8e 3d       	cpi	r24, 0xDE	; 222
   14a00:	a9 f0       	breq	.+42     	; 0x14a2c <_key_btn+0x60>
   14a02:	8f 3d       	cpi	r24, 0xDF	; 223
   14a04:	38 f4       	brcc	.+14     	; 0x14a14 <_key_btn+0x48>
   14a06:	8b 3d       	cpi	r24, 0xDB	; 219
   14a08:	f9 f0       	breq	.+62     	; 0x14a48 <_key_btn+0x7c>
   14a0a:	8d 3d       	cpi	r24, 0xDD	; 221
   14a0c:	b9 f0       	breq	.+46     	; 0x14a3c <_key_btn+0x70>
   14a0e:	87 3d       	cpi	r24, 0xD7	; 215
   14a10:	69 f5       	brne	.+90     	; 0x14a6c <_key_btn+0xa0>
   14a12:	1e c0       	rjmp	.+60     	; 0x14a50 <_key_btn+0x84>
   14a14:	8b 3e       	cpi	r24, 0xEB	; 235
   14a16:	b1 f0       	breq	.+44     	; 0x14a44 <_key_btn+0x78>
   14a18:	8c 3e       	cpi	r24, 0xEC	; 236
   14a1a:	18 f4       	brcc	.+6      	; 0x14a22 <_key_btn+0x56>
   14a1c:	87 3e       	cpi	r24, 0xE7	; 231
   14a1e:	31 f5       	brne	.+76     	; 0x14a6c <_key_btn+0xa0>
   14a20:	19 c0       	rjmp	.+50     	; 0x14a54 <_key_btn+0x88>
   14a22:	8d 3e       	cpi	r24, 0xED	; 237
   14a24:	49 f0       	breq	.+18     	; 0x14a38 <_key_btn+0x6c>
   14a26:	8e 3e       	cpi	r24, 0xEE	; 238
   14a28:	09 f5       	brne	.+66     	; 0x14a6c <_key_btn+0xa0>
   14a2a:	02 c0       	rjmp	.+4      	; 0x14a30 <_key_btn+0x64>
   14a2c:	82 e3       	ldi	r24, 0x32	; 50
   14a2e:	08 95       	ret
   14a30:	81 e3       	ldi	r24, 0x31	; 49
   14a32:	08 95       	ret
   14a34:	83 e3       	ldi	r24, 0x33	; 51
   14a36:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   14a38:	84 e3       	ldi	r24, 0x34	; 52
   14a3a:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   14a3c:	85 e3       	ldi	r24, 0x35	; 53
   14a3e:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   14a40:	86 e3       	ldi	r24, 0x36	; 54
   14a42:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   14a44:	87 e3       	ldi	r24, 0x37	; 55
   14a46:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   14a48:	88 e3       	ldi	r24, 0x38	; 56
   14a4a:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   14a4c:	89 e3       	ldi	r24, 0x39	; 57
   14a4e:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   14a50:	80 e3       	ldi	r24, 0x30	; 48
   14a52:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   14a54:	8a e2       	ldi	r24, 0x2A	; 42
   14a56:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   14a58:	83 e2       	ldi	r24, 0x23	; 35
   14a5a:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   14a5c:	81 ef       	ldi	r24, 0xF1	; 241
   14a5e:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   14a60:	82 ef       	ldi	r24, 0xF2	; 242
   14a62:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   14a64:	83 ef       	ldi	r24, 0xF3	; 243
   14a66:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   14a68:	84 ef       	ldi	r24, 0xF4	; 244
   14a6a:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   14a6c:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   14a6e:	08 95       	ret

00014a70 <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   14a70:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   14a72:	6d 3d       	cpi	r22, 0xDD	; 221
   14a74:	11 f1       	breq	.+68     	; 0x14aba <_table_alphanum+0x4a>
   14a76:	6e 3d       	cpi	r22, 0xDE	; 222
   14a78:	60 f4       	brcc	.+24     	; 0x14a92 <_table_alphanum+0x22>
   14a7a:	6d 3b       	cpi	r22, 0xBD	; 189
   14a7c:	01 f1       	breq	.+64     	; 0x14abe <_table_alphanum+0x4e>
   14a7e:	6e 3b       	cpi	r22, 0xBE	; 190
   14a80:	18 f4       	brcc	.+6      	; 0x14a88 <_table_alphanum+0x18>
   14a82:	6b 3b       	cpi	r22, 0xBB	; 187
   14a84:	21 f5       	brne	.+72     	; 0x14ace <_table_alphanum+0x5e>
   14a86:	21 c0       	rjmp	.+66     	; 0x14aca <_table_alphanum+0x5a>
   14a88:	6e 3b       	cpi	r22, 0xBE	; 190
   14a8a:	99 f0       	breq	.+38     	; 0x14ab2 <_table_alphanum+0x42>
   14a8c:	6b 3d       	cpi	r22, 0xDB	; 219
   14a8e:	f9 f4       	brne	.+62     	; 0x14ace <_table_alphanum+0x5e>
   14a90:	1a c0       	rjmp	.+52     	; 0x14ac6 <_table_alphanum+0x56>
   14a92:	6b 3e       	cpi	r22, 0xEB	; 235
   14a94:	b1 f0       	breq	.+44     	; 0x14ac2 <_table_alphanum+0x52>
   14a96:	6c 3e       	cpi	r22, 0xEC	; 236
   14a98:	18 f4       	brcc	.+6      	; 0x14aa0 <_table_alphanum+0x30>
   14a9a:	6e 3d       	cpi	r22, 0xDE	; 222
   14a9c:	c1 f4       	brne	.+48     	; 0x14ace <_table_alphanum+0x5e>
   14a9e:	05 c0       	rjmp	.+10     	; 0x14aaa <_table_alphanum+0x3a>
   14aa0:	6d 3e       	cpi	r22, 0xED	; 237
   14aa2:	49 f0       	breq	.+18     	; 0x14ab6 <_table_alphanum+0x46>
   14aa4:	6e 3e       	cpi	r22, 0xEE	; 238
   14aa6:	99 f4       	brne	.+38     	; 0x14ace <_table_alphanum+0x5e>
   14aa8:	02 c0       	rjmp	.+4      	; 0x14aae <_table_alphanum+0x3e>
   14aaa:	82 e0       	ldi	r24, 0x02	; 2
   14aac:	11 c0       	rjmp	.+34     	; 0x14ad0 <_table_alphanum+0x60>
   14aae:	81 e0       	ldi	r24, 0x01	; 1
   14ab0:	0f c0       	rjmp	.+30     	; 0x14ad0 <_table_alphanum+0x60>
   14ab2:	83 e0       	ldi	r24, 0x03	; 3
   14ab4:	0d c0       	rjmp	.+26     	; 0x14ad0 <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   14ab6:	84 e0       	ldi	r24, 0x04	; 4
   14ab8:	0b c0       	rjmp	.+22     	; 0x14ad0 <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   14aba:	85 e0       	ldi	r24, 0x05	; 5
   14abc:	09 c0       	rjmp	.+18     	; 0x14ad0 <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   14abe:	86 e0       	ldi	r24, 0x06	; 6
   14ac0:	07 c0       	rjmp	.+14     	; 0x14ad0 <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   14ac2:	87 e0       	ldi	r24, 0x07	; 7
   14ac4:	05 c0       	rjmp	.+10     	; 0x14ad0 <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   14ac6:	88 e0       	ldi	r24, 0x08	; 8
   14ac8:	03 c0       	rjmp	.+6      	; 0x14ad0 <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   14aca:	89 e0       	ldi	r24, 0x09	; 9
   14acc:	01 c0       	rjmp	.+2      	; 0x14ad0 <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   14ace:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   14ad0:	28 2f       	mov	r18, r24
   14ad2:	30 e0       	ldi	r19, 0x00	; 0
   14ad4:	f9 01       	movw	r30, r18
   14ad6:	ec 5e       	subi	r30, 0xEC	; 236
   14ad8:	fc 4d       	sbci	r31, 0xDC	; 220
   14ada:	e4 91       	lpm	r30, Z+
   14adc:	e4 17       	cp	r30, r20
   14ade:	10 f4       	brcc	.+4      	; 0x14ae4 <_table_alphanum+0x74>
   14ae0:	80 e0       	ldi	r24, 0x00	; 0
   14ae2:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   14ae4:	ec e3       	ldi	r30, 0x3C	; 60
   14ae6:	9e 9f       	mul	r25, r30
   14ae8:	f0 01       	movw	r30, r0
   14aea:	11 24       	eor	r1, r1
   14aec:	e4 0f       	add	r30, r20
   14aee:	f1 1d       	adc	r31, r1
   14af0:	c9 01       	movw	r24, r18
   14af2:	88 0f       	add	r24, r24
   14af4:	99 1f       	adc	r25, r25
   14af6:	82 0f       	add	r24, r18
   14af8:	93 1f       	adc	r25, r19
   14afa:	88 0f       	add	r24, r24
   14afc:	99 1f       	adc	r25, r25
   14afe:	e8 0f       	add	r30, r24
   14b00:	f9 1f       	adc	r31, r25
   14b02:	e4 56       	subi	r30, 0x64	; 100
   14b04:	fd 4d       	sbci	r31, 0xDD	; 221
   14b06:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   14b08:	08 95       	ret

00014b0a <_key_scan>:





char _key_scan(char __select){
   14b0a:	8f 92       	push	r8
   14b0c:	9f 92       	push	r9
   14b0e:	af 92       	push	r10
   14b10:	bf 92       	push	r11
   14b12:	cf 92       	push	r12
   14b14:	df 92       	push	r13
   14b16:	ef 92       	push	r14
   14b18:	ff 92       	push	r15
   14b1a:	0f 93       	push	r16
   14b1c:	1f 93       	push	r17
   14b1e:	df 93       	push	r29
   14b20:	cf 93       	push	r28
   14b22:	00 d0       	rcall	.+0      	; 0x14b24 <_key_scan+0x1a>
   14b24:	00 d0       	rcall	.+0      	; 0x14b26 <_key_scan+0x1c>
   14b26:	cd b7       	in	r28, 0x3d	; 61
   14b28:	de b7       	in	r29, 0x3e	; 62
   14b2a:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   14b2c:	81 50       	subi	r24, 0x01	; 1
   14b2e:	82 30       	cpi	r24, 0x02	; 2
   14b30:	08 f0       	brcs	.+2      	; 0x14b34 <_key_scan+0x2a>
   14b32:	aa c0       	rjmp	.+340    	; 0x14c88 <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   14b34:	8f ee       	ldi	r24, 0xEF	; 239
   14b36:	89 83       	std	Y+1, r24	; 0x01
   14b38:	8f ed       	ldi	r24, 0xDF	; 223
   14b3a:	8a 83       	std	Y+2, r24	; 0x02
   14b3c:	8f eb       	ldi	r24, 0xBF	; 191
   14b3e:	8b 83       	std	Y+3, r24	; 0x03
   14b40:	8f e7       	ldi	r24, 0x7F	; 127
   14b42:	8c 83       	std	Y+4, r24	; 0x04
   14b44:	de 01       	movw	r26, r28
   14b46:	11 96       	adiw	r26, 0x01	; 1
   14b48:	2a ef       	ldi	r18, 0xFA	; 250
   14b4a:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   14b4c:	ae 01       	movw	r20, r28
   14b4e:	4b 5f       	subi	r20, 0xFB	; 251
   14b50:	5f 4f       	sbci	r21, 0xFF	; 255
   14b52:	c9 01       	movw	r24, r18
   14b54:	01 97       	sbiw	r24, 0x01	; 1
   14b56:	f1 f7       	brne	.-4      	; 0x14b54 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   14b58:	8c 91       	ld	r24, X
   14b5a:	80 93 62 00 	sts	0x0062, r24
   14b5e:	f9 01       	movw	r30, r18
   14b60:	31 97       	sbiw	r30, 0x01	; 1
   14b62:	f1 f7       	brne	.-4      	; 0x14b60 <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   14b64:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   14b66:	98 17       	cp	r25, r24
   14b68:	21 f4       	brne	.+8      	; 0x14b72 <_key_scan+0x68>
   14b6a:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   14b6c:	a4 17       	cp	r26, r20
   14b6e:	b5 07       	cpc	r27, r21
   14b70:	81 f7       	brne	.-32     	; 0x14b52 <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   14b72:	89 2f       	mov	r24, r25
   14b74:	0e 94 c4 a4 	call	0x14988	; 0x14988 <_key_crr>
   14b78:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   14b7a:	88 23       	and	r24, r24
   14b7c:	09 f4       	brne	.+2      	; 0x14b80 <_key_scan+0x76>
   14b7e:	85 c0       	rjmp	.+266    	; 0x14c8a <_key_scan+0x180>
			_LIGHT_SET;
   14b80:	91 e0       	ldi	r25, 0x01	; 1
   14b82:	90 93 ae 02 	sts	0x02AE, r25
   14b86:	10 92 af 02 	sts	0x02AF, r1
   14b8a:	80 91 65 00 	lds	r24, 0x0065
   14b8e:	8d 7f       	andi	r24, 0xFD	; 253
   14b90:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   14b94:	80 91 b9 02 	lds	r24, 0x02B9
   14b98:	88 23       	and	r24, r24
   14b9a:	31 f0       	breq	.+12     	; 0x14ba8 <_key_scan+0x9e>
				_SEC_ON;
   14b9c:	90 93 b4 02 	sts	0x02B4, r25
   14ba0:	10 92 b6 02 	sts	0x02B6, r1
   14ba4:	10 92 b5 02 	sts	0x02B5, r1

			if(_IS1st){
   14ba8:	80 91 b0 02 	lds	r24, 0x02B0
   14bac:	88 23       	and	r24, r24
   14bae:	71 f4       	brne	.+28     	; 0x14bcc <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   14bb0:	27 3e       	cpi	r18, 0xE7	; 231
   14bb2:	11 f0       	breq	.+4      	; 0x14bb8 <_key_scan+0xae>
   14bb4:	27 3b       	cpi	r18, 0xB7	; 183
   14bb6:	31 f4       	brne	.+12     	; 0x14bc4 <_key_scan+0xba>
					if(__lock_num)
   14bb8:	80 91 ad 02 	lds	r24, 0x02AD
   14bbc:	88 23       	and	r24, r24
   14bbe:	11 f0       	breq	.+4      	; 0x14bc4 <_key_scan+0xba>
						__lock_num = 0;
   14bc0:	10 92 ad 02 	sts	0x02AD, r1
				_PAD_2nd;
   14bc4:	81 e0       	ldi	r24, 0x01	; 1
   14bc6:	80 93 b0 02 	sts	0x02B0, r24
   14bca:	59 c0       	rjmp	.+178    	; 0x14c7e <_key_scan+0x174>
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   14bcc:	81 30       	cpi	r24, 0x01	; 1
   14bce:	09 f0       	breq	.+2      	; 0x14bd2 <_key_scan+0xc8>
   14bd0:	5c c0       	rjmp	.+184    	; 0x14c8a <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   14bd2:	12 30       	cpi	r17, 0x02	; 2
   14bd4:	21 f5       	brne	.+72     	; 0x14c1e <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   14bd6:	27 3d       	cpi	r18, 0xD7	; 215
   14bd8:	91 f0       	breq	.+36     	; 0x14bfe <_key_scan+0xf4>
   14bda:	2e 3e       	cpi	r18, 0xEE	; 238
   14bdc:	81 f0       	breq	.+32     	; 0x14bfe <_key_scan+0xf4>
   14bde:	2e 3d       	cpi	r18, 0xDE	; 222
   14be0:	71 f0       	breq	.+28     	; 0x14bfe <_key_scan+0xf4>
   14be2:	2e 3b       	cpi	r18, 0xBE	; 190
   14be4:	61 f0       	breq	.+24     	; 0x14bfe <_key_scan+0xf4>
   14be6:	2d 3e       	cpi	r18, 0xED	; 237
   14be8:	51 f0       	breq	.+20     	; 0x14bfe <_key_scan+0xf4>
   14bea:	2d 3d       	cpi	r18, 0xDD	; 221
   14bec:	41 f0       	breq	.+16     	; 0x14bfe <_key_scan+0xf4>
   14bee:	2d 3b       	cpi	r18, 0xBD	; 189
   14bf0:	31 f0       	breq	.+12     	; 0x14bfe <_key_scan+0xf4>
   14bf2:	2b 3e       	cpi	r18, 0xEB	; 235
   14bf4:	21 f0       	breq	.+8      	; 0x14bfe <_key_scan+0xf4>
   14bf6:	2b 3d       	cpi	r18, 0xDB	; 219
   14bf8:	11 f0       	breq	.+4      	; 0x14bfe <_key_scan+0xf4>
   14bfa:	2b 3b       	cpi	r18, 0xBB	; 187
   14bfc:	81 f4       	brne	.+32     	; 0x14c1e <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   14bfe:	80 91 ad 02 	lds	r24, 0x02AD
   14c02:	88 23       	and	r24, r24
   14c04:	49 f0       	breq	.+18     	; 0x14c18 <_key_scan+0x10e>
							_SHIFT_SET;
   14c06:	81 e0       	ldi	r24, 0x01	; 1
   14c08:	80 93 b1 02 	sts	0x02B1, r24
   14c0c:	10 92 b2 02 	sts	0x02B2, r1
							CURSOR_HIDE;
   14c10:	8c e0       	ldi	r24, 0x0C	; 12
   14c12:	0e 94 38 a3 	call	0x14670	; 0x14670 <lcd_command>
   14c16:	03 c0       	rjmp	.+6      	; 0x14c1e <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   14c18:	81 e0       	ldi	r24, 0x01	; 1
   14c1a:	80 93 ad 02 	sts	0x02AD, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   14c1e:	ff ee       	ldi	r31, 0xEF	; 239
   14c20:	8f 2e       	mov	r8, r31
   14c22:	ef ed       	ldi	r30, 0xDF	; 223
   14c24:	9e 2e       	mov	r9, r30
   14c26:	7f eb       	ldi	r23, 0xBF	; 191
   14c28:	a7 2e       	mov	r10, r23
   14c2a:	6f e7       	ldi	r22, 0x7F	; 127
   14c2c:	b6 2e       	mov	r11, r22
   14c2e:	6e 01       	movw	r12, r28
   14c30:	08 94       	sec
   14c32:	c1 1c       	adc	r12, r1
   14c34:	d1 1c       	adc	r13, r1
   14c36:	0a ef       	ldi	r16, 0xFA	; 250
   14c38:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   14c3a:	55 e0       	ldi	r21, 0x05	; 5
   14c3c:	e5 2e       	mov	r14, r21
   14c3e:	f1 2c       	mov	r15, r1
   14c40:	ec 0e       	add	r14, r28
   14c42:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   14c44:	89 82       	std	Y+1, r8	; 0x01
   14c46:	9a 82       	std	Y+2, r9	; 0x02
   14c48:	ab 82       	std	Y+3, r10	; 0x03
   14c4a:	bc 82       	std	Y+4, r11	; 0x04
   14c4c:	d6 01       	movw	r26, r12
   14c4e:	c8 01       	movw	r24, r16
   14c50:	01 97       	sbiw	r24, 0x01	; 1
   14c52:	f1 f7       	brne	.-4      	; 0x14c50 <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   14c54:	8c 91       	ld	r24, X
   14c56:	80 93 62 00 	sts	0x0062, r24
   14c5a:	f8 01       	movw	r30, r16
   14c5c:	31 97       	sbiw	r30, 0x01	; 1
   14c5e:	f1 f7       	brne	.-4      	; 0x14c5c <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   14c60:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   14c62:	98 17       	cp	r25, r24
   14c64:	21 f4       	brne	.+8      	; 0x14c6e <_key_scan+0x164>
   14c66:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   14c68:	ae 15       	cp	r26, r14
   14c6a:	bf 05       	cpc	r27, r15
   14c6c:	81 f7       	brne	.-32     	; 0x14c4e <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   14c6e:	89 2f       	mov	r24, r25
   14c70:	0e 94 c4 a4 	call	0x14988	; 0x14988 <_key_crr>
   14c74:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   14c76:	88 23       	and	r24, r24
   14c78:	29 f7       	brne	.-54     	; 0x14c44 <_key_scan+0x13a>
				_PAD_1st;
   14c7a:	10 92 b0 02 	sts	0x02B0, r1
   14c7e:	82 ee       	ldi	r24, 0xE2	; 226
   14c80:	94 e0       	ldi	r25, 0x04	; 4
   14c82:	01 97       	sbiw	r24, 0x01	; 1
   14c84:	f1 f7       	brne	.-4      	; 0x14c82 <_key_scan+0x178>
   14c86:	03 c0       	rjmp	.+6      	; 0x14c8e <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   14c88:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   14c8a:	10 92 b0 02 	sts	0x02B0, r1
	return __key;
}
   14c8e:	82 2f       	mov	r24, r18
   14c90:	0f 90       	pop	r0
   14c92:	0f 90       	pop	r0
   14c94:	0f 90       	pop	r0
   14c96:	0f 90       	pop	r0
   14c98:	cf 91       	pop	r28
   14c9a:	df 91       	pop	r29
   14c9c:	1f 91       	pop	r17
   14c9e:	0f 91       	pop	r16
   14ca0:	ff 90       	pop	r15
   14ca2:	ef 90       	pop	r14
   14ca4:	df 90       	pop	r13
   14ca6:	cf 90       	pop	r12
   14ca8:	bf 90       	pop	r11
   14caa:	af 90       	pop	r10
   14cac:	9f 90       	pop	r9
   14cae:	8f 90       	pop	r8
   14cb0:	08 95       	ret

00014cb2 <_spi_init>:
#include <util/delay.h>
#include <compat/deprecated.h>

#include "SPI.h"
void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   14cb2:	88 23       	and	r24, r24
   14cb4:	41 f0       	breq	.+16     	; 0x14cc6 <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   14cb6:	86 e0       	ldi	r24, 0x06	; 6
   14cb8:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   14cba:	66 23       	and	r22, r22
   14cbc:	11 f0       	breq	.+4      	; 0x14cc2 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   14cbe:	82 ed       	ldi	r24, 0xD2	; 210
   14cc0:	09 c0       	rjmp	.+18     	; 0x14cd4 <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   14cc2:	82 e5       	ldi	r24, 0x52	; 82
   14cc4:	07 c0       	rjmp	.+14     	; 0x14cd4 <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   14cc6:	88 e0       	ldi	r24, 0x08	; 8
   14cc8:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   14cca:	66 23       	and	r22, r22
   14ccc:	11 f0       	breq	.+4      	; 0x14cd2 <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   14cce:	80 ec       	ldi	r24, 0xC0	; 192
   14cd0:	01 c0       	rjmp	.+2      	; 0x14cd4 <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   14cd2:	80 e4       	ldi	r24, 0x40	; 64
   14cd4:	8d b9       	out	0x0d, r24	; 13
   14cd6:	08 95       	ret

00014cd8 <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   14cd8:	88 23       	and	r24, r24
   14cda:	19 f4       	brne	.+6      	; 0x14ce2 <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   14cdc:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   14cde:	1b 9a       	sbi	0x03, 3	; 3
   14ce0:	08 95       	ret
	}
	if(__select == 1){
   14ce2:	81 30       	cpi	r24, 0x01	; 1
   14ce4:	39 f4       	brne	.+14     	; 0x14cf4 <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   14ce6:	1b 9a       	sbi	0x03, 3	; 3
   14ce8:	82 ee       	ldi	r24, 0xE2	; 226
   14cea:	94 e0       	ldi	r25, 0x04	; 4
   14cec:	01 97       	sbiw	r24, 0x01	; 1
   14cee:	f1 f7       	brne	.-4      	; 0x14cec <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   14cf0:	db 98       	cbi	0x1b, 3	; 27
   14cf2:	08 95       	ret
	}
	if(__select == 2){
   14cf4:	82 30       	cpi	r24, 0x02	; 2
   14cf6:	31 f4       	brne	.+12     	; 0x14d04 <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   14cf8:	db 9a       	sbi	0x1b, 3	; 27
   14cfa:	82 ee       	ldi	r24, 0xE2	; 226
   14cfc:	94 e0       	ldi	r25, 0x04	; 4
   14cfe:	01 97       	sbiw	r24, 0x01	; 1
   14d00:	f1 f7       	brne	.-4      	; 0x14cfe <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   14d02:	1b 98       	cbi	0x03, 3	; 3
   14d04:	08 95       	ret

00014d06 <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   14d06:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   14d08:	77 9b       	sbis	0x0e, 7	; 14
   14d0a:	fe cf       	rjmp	.-4      	; 0x14d08 <_spi+0x2>
	return SPDR;
   14d0c:	8f b1       	in	r24, 0x0f	; 15
}
   14d0e:	08 95       	ret

00014d10 <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   14d10:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   14d12:	22 23       	and	r18, r18
   14d14:	09 f4       	brne	.+2      	; 0x14d18 <_rtc+0x8>
   14d16:	49 c0       	rjmp	.+146    	; 0x14daa <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   14d18:	84 ea       	ldi	r24, 0xA4	; 164
   14d1a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   14d1e:	80 91 74 00 	lds	r24, 0x0074
   14d22:	87 ff       	sbrs	r24, 7
   14d24:	fc cf       	rjmp	.-8      	; 0x14d1e <_rtc+0xe>
		if(TW_STATUS != TW_START)
   14d26:	80 91 71 00 	lds	r24, 0x0071
   14d2a:	88 7f       	andi	r24, 0xF8	; 248
   14d2c:	88 30       	cpi	r24, 0x08	; 8
   14d2e:	09 f0       	breq	.+2      	; 0x14d32 <_rtc+0x22>
   14d30:	af c0       	rjmp	.+350    	; 0x14e90 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   14d32:	80 ed       	ldi	r24, 0xD0	; 208
   14d34:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   14d38:	84 e8       	ldi	r24, 0x84	; 132
   14d3a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   14d3e:	80 91 74 00 	lds	r24, 0x0074
   14d42:	87 ff       	sbrs	r24, 7
   14d44:	fc cf       	rjmp	.-8      	; 0x14d3e <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   14d46:	80 91 71 00 	lds	r24, 0x0071
   14d4a:	88 7f       	andi	r24, 0xF8	; 248
   14d4c:	88 31       	cpi	r24, 0x18	; 24
   14d4e:	09 f0       	breq	.+2      	; 0x14d52 <_rtc+0x42>
   14d50:	9f c0       	rjmp	.+318    	; 0x14e90 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   14d52:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   14d56:	84 e8       	ldi	r24, 0x84	; 132
   14d58:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   14d5c:	80 91 74 00 	lds	r24, 0x0074
   14d60:	87 ff       	sbrs	r24, 7
   14d62:	fc cf       	rjmp	.-8      	; 0x14d5c <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   14d64:	80 91 71 00 	lds	r24, 0x0071
   14d68:	88 7f       	andi	r24, 0xF8	; 248
   14d6a:	88 32       	cpi	r24, 0x28	; 40
   14d6c:	09 f0       	breq	.+2      	; 0x14d70 <_rtc+0x60>
   14d6e:	90 c0       	rjmp	.+288    	; 0x14e90 <_rtc+0x180>
   14d70:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   14d72:	94 e8       	ldi	r25, 0x84	; 132
   14d74:	14 c0       	rjmp	.+40     	; 0x14d9e <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   14d76:	fa 01       	movw	r30, r20
   14d78:	e8 0f       	add	r30, r24
   14d7a:	f1 1d       	adc	r31, r1
   14d7c:	80 81       	ld	r24, Z
   14d7e:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   14d82:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   14d86:	80 91 74 00 	lds	r24, 0x0074
   14d8a:	87 ff       	sbrs	r24, 7
   14d8c:	fc cf       	rjmp	.-8      	; 0x14d86 <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   14d8e:	80 91 71 00 	lds	r24, 0x0071
   14d92:	88 7f       	andi	r24, 0xF8	; 248
   14d94:	80 33       	cpi	r24, 0x30	; 48
   14d96:	09 f4       	brne	.+2      	; 0x14d9a <_rtc+0x8a>
   14d98:	7b c0       	rjmp	.+246    	; 0x14e90 <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   14d9a:	21 50       	subi	r18, 0x01	; 1
   14d9c:	30 40       	sbci	r19, 0x00	; 0
   14d9e:	86 2f       	mov	r24, r22
   14da0:	82 1b       	sub	r24, r18
   14da2:	12 16       	cp	r1, r18
   14da4:	13 06       	cpc	r1, r19
   14da6:	3c f3       	brlt	.-50     	; 0x14d76 <_rtc+0x66>
   14da8:	6e c0       	rjmp	.+220    	; 0x14e86 <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   14daa:	84 ea       	ldi	r24, 0xA4	; 164
   14dac:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   14db0:	80 91 74 00 	lds	r24, 0x0074
   14db4:	87 ff       	sbrs	r24, 7
   14db6:	fc cf       	rjmp	.-8      	; 0x14db0 <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   14db8:	80 91 71 00 	lds	r24, 0x0071
   14dbc:	88 7f       	andi	r24, 0xF8	; 248
   14dbe:	88 30       	cpi	r24, 0x08	; 8
   14dc0:	09 f0       	breq	.+2      	; 0x14dc4 <_rtc+0xb4>
   14dc2:	66 c0       	rjmp	.+204    	; 0x14e90 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   14dc4:	80 ed       	ldi	r24, 0xD0	; 208
   14dc6:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   14dca:	84 e8       	ldi	r24, 0x84	; 132
   14dcc:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   14dd0:	80 91 74 00 	lds	r24, 0x0074
   14dd4:	87 ff       	sbrs	r24, 7
   14dd6:	fc cf       	rjmp	.-8      	; 0x14dd0 <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   14dd8:	80 91 71 00 	lds	r24, 0x0071
   14ddc:	88 7f       	andi	r24, 0xF8	; 248
   14dde:	88 31       	cpi	r24, 0x18	; 24
   14de0:	09 f0       	breq	.+2      	; 0x14de4 <_rtc+0xd4>
   14de2:	56 c0       	rjmp	.+172    	; 0x14e90 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   14de4:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   14de8:	84 e8       	ldi	r24, 0x84	; 132
   14dea:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   14dee:	80 91 74 00 	lds	r24, 0x0074
   14df2:	87 ff       	sbrs	r24, 7
   14df4:	fc cf       	rjmp	.-8      	; 0x14dee <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   14df6:	80 91 71 00 	lds	r24, 0x0071
   14dfa:	88 7f       	andi	r24, 0xF8	; 248
   14dfc:	88 32       	cpi	r24, 0x28	; 40
   14dfe:	09 f0       	breq	.+2      	; 0x14e02 <_rtc+0xf2>
   14e00:	47 c0       	rjmp	.+142    	; 0x14e90 <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   14e02:	84 ea       	ldi	r24, 0xA4	; 164
   14e04:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   14e08:	80 91 74 00 	lds	r24, 0x0074
   14e0c:	87 ff       	sbrs	r24, 7
   14e0e:	fc cf       	rjmp	.-8      	; 0x14e08 <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   14e10:	80 91 71 00 	lds	r24, 0x0071
   14e14:	88 7f       	andi	r24, 0xF8	; 248
   14e16:	80 31       	cpi	r24, 0x10	; 16
   14e18:	d9 f5       	brne	.+118    	; 0x14e90 <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   14e1a:	81 ed       	ldi	r24, 0xD1	; 209
   14e1c:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   14e20:	84 e8       	ldi	r24, 0x84	; 132
   14e22:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   14e26:	80 91 74 00 	lds	r24, 0x0074
   14e2a:	87 ff       	sbrs	r24, 7
   14e2c:	fc cf       	rjmp	.-8      	; 0x14e26 <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   14e2e:	80 91 71 00 	lds	r24, 0x0071
   14e32:	88 7f       	andi	r24, 0xF8	; 248
   14e34:	80 34       	cpi	r24, 0x40	; 64
   14e36:	61 f5       	brne	.+88     	; 0x14e90 <_rtc+0x180>
   14e38:	24 ec       	ldi	r18, 0xC4	; 196
   14e3a:	30 e0       	ldi	r19, 0x00	; 0
   14e3c:	90 e0       	ldi	r25, 0x00	; 0
   14e3e:	20 c0       	rjmp	.+64     	; 0x14e80 <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   14e40:	61 30       	cpi	r22, 0x01	; 1
   14e42:	71 05       	cpc	r23, r1
   14e44:	11 f4       	brne	.+4      	; 0x14e4a <_rtc+0x13a>
   14e46:	24 e8       	ldi	r18, 0x84	; 132
   14e48:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   14e4a:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   14e4e:	80 91 74 00 	lds	r24, 0x0074
   14e52:	87 ff       	sbrs	r24, 7
   14e54:	fc cf       	rjmp	.-8      	; 0x14e4e <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   14e56:	80 91 71 00 	lds	r24, 0x0071
   14e5a:	88 7f       	andi	r24, 0xF8	; 248
   14e5c:	88 35       	cpi	r24, 0x58	; 88
   14e5e:	11 f4       	brne	.+4      	; 0x14e64 <_rtc+0x154>
   14e60:	60 e0       	ldi	r22, 0x00	; 0
   14e62:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   14e64:	80 91 71 00 	lds	r24, 0x0071
   14e68:	88 7f       	andi	r24, 0xF8	; 248
   14e6a:	80 35       	cpi	r24, 0x50	; 80
   14e6c:	39 f4       	brne	.+14     	; 0x14e7c <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   14e6e:	80 91 73 00 	lds	r24, 0x0073
   14e72:	fa 01       	movw	r30, r20
   14e74:	e9 0f       	add	r30, r25
   14e76:	f1 1d       	adc	r31, r1
   14e78:	80 83       	st	Z, r24
   14e7a:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   14e7c:	61 50       	subi	r22, 0x01	; 1
   14e7e:	70 40       	sbci	r23, 0x00	; 0
   14e80:	16 16       	cp	r1, r22
   14e82:	17 06       	cpc	r1, r23
   14e84:	ec f2       	brlt	.-70     	; 0x14e40 <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   14e86:	84 e9       	ldi	r24, 0x94	; 148
   14e88:	80 93 74 00 	sts	0x0074, r24
   14e8c:	80 e0       	ldi	r24, 0x00	; 0
   14e8e:	08 95       	ret
   14e90:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   14e92:	08 95       	ret

00014e94 <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   14e94:	ef 92       	push	r14
   14e96:	ff 92       	push	r15
   14e98:	0f 93       	push	r16
   14e9a:	1f 93       	push	r17
   14e9c:	df 93       	push	r29
   14e9e:	cf 93       	push	r28
   14ea0:	cd b7       	in	r28, 0x3d	; 61
   14ea2:	de b7       	in	r29, 0x3e	; 62
   14ea4:	64 97       	sbiw	r28, 0x14	; 20
   14ea6:	0f b6       	in	r0, 0x3f	; 63
   14ea8:	f8 94       	cli
   14eaa:	de bf       	out	0x3e, r29	; 62
   14eac:	0f be       	out	0x3f, r0	; 63
   14eae:	cd bf       	out	0x3d, r28	; 61
   14eb0:	28 2f       	mov	r18, r24
   14eb2:	8b 01       	movw	r16, r22
   14eb4:	7a 01       	movw	r14, r20
   14eb6:	ae 01       	movw	r20, r28
   14eb8:	4f 5f       	subi	r20, 0xFF	; 255
   14eba:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   14ebc:	88 23       	and	r24, r24
   14ebe:	99 f1       	breq	.+102    	; 0x14f26 <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   14ec0:	fb 01       	movw	r30, r22
   14ec2:	90 81       	ld	r25, Z
   14ec4:	92 95       	swap	r25
   14ec6:	90 7f       	andi	r25, 0xF0	; 240
   14ec8:	81 81       	ldd	r24, Z+1	; 0x01
   14eca:	8f 70       	andi	r24, 0x0F	; 15
   14ecc:	98 0f       	add	r25, r24
   14ece:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   14ed0:	93 81       	ldd	r25, Z+3	; 0x03
   14ed2:	92 95       	swap	r25
   14ed4:	90 7f       	andi	r25, 0xF0	; 240
   14ed6:	84 81       	ldd	r24, Z+4	; 0x04
   14ed8:	8f 70       	andi	r24, 0x0F	; 15
   14eda:	98 0f       	add	r25, r24
   14edc:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   14ede:	96 81       	ldd	r25, Z+6	; 0x06
   14ee0:	92 95       	swap	r25
   14ee2:	90 7f       	andi	r25, 0xF0	; 240
   14ee4:	87 81       	ldd	r24, Z+7	; 0x07
   14ee6:	8f 70       	andi	r24, 0x0F	; 15
   14ee8:	98 0f       	add	r25, r24
   14eea:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   14eec:	f7 01       	movw	r30, r14
   14eee:	90 81       	ld	r25, Z
   14ef0:	92 95       	swap	r25
   14ef2:	90 7f       	andi	r25, 0xF0	; 240
   14ef4:	81 81       	ldd	r24, Z+1	; 0x01
   14ef6:	8f 70       	andi	r24, 0x0F	; 15
   14ef8:	98 0f       	add	r25, r24
   14efa:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   14efc:	93 81       	ldd	r25, Z+3	; 0x03
   14efe:	92 95       	swap	r25
   14f00:	90 7f       	andi	r25, 0xF0	; 240
   14f02:	84 81       	ldd	r24, Z+4	; 0x04
   14f04:	8f 70       	andi	r24, 0x0F	; 15
   14f06:	98 0f       	add	r25, r24
   14f08:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   14f0a:	96 81       	ldd	r25, Z+6	; 0x06
   14f0c:	92 95       	swap	r25
   14f0e:	90 7f       	andi	r25, 0xF0	; 240
   14f10:	87 81       	ldd	r24, Z+7	; 0x07
   14f12:	8f 70       	andi	r24, 0x0F	; 15
   14f14:	98 0f       	add	r25, r24
   14f16:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   14f18:	80 e0       	ldi	r24, 0x00	; 0
   14f1a:	90 e0       	ldi	r25, 0x00	; 0
   14f1c:	68 e0       	ldi	r22, 0x08	; 8
   14f1e:	70 e0       	ldi	r23, 0x00	; 0
   14f20:	0e 94 88 a6 	call	0x14d10	; 0x14d10 <_rtc>
   14f24:	4a c0       	rjmp	.+148    	; 0x14fba <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   14f26:	80 e0       	ldi	r24, 0x00	; 0
   14f28:	90 e0       	ldi	r25, 0x00	; 0
   14f2a:	68 e0       	ldi	r22, 0x08	; 8
   14f2c:	70 e0       	ldi	r23, 0x00	; 0
   14f2e:	20 e0       	ldi	r18, 0x00	; 0
   14f30:	0e 94 88 a6 	call	0x14d10	; 0x14d10 <_rtc>
   14f34:	81 30       	cpi	r24, 0x01	; 1
   14f36:	09 f4       	brne	.+2      	; 0x14f3a <_datetime+0xa6>
   14f38:	40 c0       	rjmp	.+128    	; 0x14fba <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   14f3a:	9d 81       	ldd	r25, Y+5	; 0x05
   14f3c:	89 2f       	mov	r24, r25
   14f3e:	82 95       	swap	r24
   14f40:	8f 70       	andi	r24, 0x0F	; 15
   14f42:	80 5d       	subi	r24, 0xD0	; 208
   14f44:	f8 01       	movw	r30, r16
   14f46:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   14f48:	9f 70       	andi	r25, 0x0F	; 15
   14f4a:	90 5d       	subi	r25, 0xD0	; 208
   14f4c:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   14f4e:	2f e2       	ldi	r18, 0x2F	; 47
   14f50:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   14f52:	9e 81       	ldd	r25, Y+6	; 0x06
   14f54:	89 2f       	mov	r24, r25
   14f56:	82 95       	swap	r24
   14f58:	8f 70       	andi	r24, 0x0F	; 15
   14f5a:	80 5d       	subi	r24, 0xD0	; 208
   14f5c:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   14f5e:	9f 70       	andi	r25, 0x0F	; 15
   14f60:	90 5d       	subi	r25, 0xD0	; 208
   14f62:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   14f64:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   14f66:	9f 81       	ldd	r25, Y+7	; 0x07
   14f68:	89 2f       	mov	r24, r25
   14f6a:	82 95       	swap	r24
   14f6c:	8f 70       	andi	r24, 0x0F	; 15
   14f6e:	80 5d       	subi	r24, 0xD0	; 208
   14f70:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   14f72:	9f 70       	andi	r25, 0x0F	; 15
   14f74:	90 5d       	subi	r25, 0xD0	; 208
   14f76:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   14f78:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   14f7a:	9b 81       	ldd	r25, Y+3	; 0x03
   14f7c:	89 2f       	mov	r24, r25
   14f7e:	82 95       	swap	r24
   14f80:	8f 70       	andi	r24, 0x0F	; 15
   14f82:	80 5d       	subi	r24, 0xD0	; 208
   14f84:	f7 01       	movw	r30, r14
   14f86:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   14f88:	9f 70       	andi	r25, 0x0F	; 15
   14f8a:	90 5d       	subi	r25, 0xD0	; 208
   14f8c:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   14f8e:	2a e3       	ldi	r18, 0x3A	; 58
   14f90:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   14f92:	9a 81       	ldd	r25, Y+2	; 0x02
   14f94:	89 2f       	mov	r24, r25
   14f96:	82 95       	swap	r24
   14f98:	8f 70       	andi	r24, 0x0F	; 15
   14f9a:	80 5d       	subi	r24, 0xD0	; 208
   14f9c:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   14f9e:	9f 70       	andi	r25, 0x0F	; 15
   14fa0:	90 5d       	subi	r25, 0xD0	; 208
   14fa2:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   14fa4:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   14fa6:	99 81       	ldd	r25, Y+1	; 0x01
   14fa8:	89 2f       	mov	r24, r25
   14faa:	82 95       	swap	r24
   14fac:	8f 70       	andi	r24, 0x0F	; 15
   14fae:	80 5d       	subi	r24, 0xD0	; 208
   14fb0:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   14fb2:	9f 70       	andi	r25, 0x0F	; 15
   14fb4:	90 5d       	subi	r25, 0xD0	; 208
   14fb6:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   14fb8:	10 86       	std	Z+8, r1	; 0x08
		}
}
   14fba:	64 96       	adiw	r28, 0x14	; 20
   14fbc:	0f b6       	in	r0, 0x3f	; 63
   14fbe:	f8 94       	cli
   14fc0:	de bf       	out	0x3e, r29	; 62
   14fc2:	0f be       	out	0x3f, r0	; 63
   14fc4:	cd bf       	out	0x3d, r28	; 61
   14fc6:	cf 91       	pop	r28
   14fc8:	df 91       	pop	r29
   14fca:	1f 91       	pop	r17
   14fcc:	0f 91       	pop	r16
   14fce:	ff 90       	pop	r15
   14fd0:	ef 90       	pop	r14
   14fd2:	08 95       	ret

00014fd4 <_day>:

unsigned char _day(void){
   14fd4:	df 93       	push	r29
   14fd6:	cf 93       	push	r28
   14fd8:	cd b7       	in	r28, 0x3d	; 61
   14fda:	de b7       	in	r29, 0x3e	; 62
   14fdc:	64 97       	sbiw	r28, 0x14	; 20
   14fde:	0f b6       	in	r0, 0x3f	; 63
   14fe0:	f8 94       	cli
   14fe2:	de bf       	out	0x3e, r29	; 62
   14fe4:	0f be       	out	0x3f, r0	; 63
   14fe6:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   14fe8:	80 e0       	ldi	r24, 0x00	; 0
   14fea:	90 e0       	ldi	r25, 0x00	; 0
   14fec:	68 e0       	ldi	r22, 0x08	; 8
   14fee:	70 e0       	ldi	r23, 0x00	; 0
   14ff0:	ae 01       	movw	r20, r28
   14ff2:	4f 5f       	subi	r20, 0xFF	; 255
   14ff4:	5f 4f       	sbci	r21, 0xFF	; 255
   14ff6:	20 e0       	ldi	r18, 0x00	; 0
   14ff8:	0e 94 88 a6 	call	0x14d10	; 0x14d10 <_rtc>
   14ffc:	81 30       	cpi	r24, 0x01	; 1
   14ffe:	11 f4       	brne	.+4      	; 0x15004 <_day+0x30>
   15000:	80 e0       	ldi	r24, 0x00	; 0
   15002:	02 c0       	rjmp	.+4      	; 0x15008 <_day+0x34>
		return __datetime[3] & 0x0F;
   15004:	8c 81       	ldd	r24, Y+4	; 0x04
   15006:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   15008:	64 96       	adiw	r28, 0x14	; 20
   1500a:	0f b6       	in	r0, 0x3f	; 63
   1500c:	f8 94       	cli
   1500e:	de bf       	out	0x3e, r29	; 62
   15010:	0f be       	out	0x3f, r0	; 63
   15012:	cd bf       	out	0x3d, r28	; 61
   15014:	cf 91       	pop	r28
   15016:	df 91       	pop	r29
   15018:	08 95       	ret

0001501a <uart_baudrate>:
	}

	uart_baudrate(__com, __baudrate);
}

void uart_baudrate(unsigned char __com, unsigned long __baudrate){
   1501a:	1f 93       	push	r17
   1501c:	18 2f       	mov	r17, r24
   1501e:	9a 01       	movw	r18, r20
   15020:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   15022:	ca 01       	movw	r24, r20
   15024:	b9 01       	movw	r22, r18
   15026:	60 50       	subi	r22, 0x00	; 0
   15028:	70 4e       	sbci	r23, 0xE0	; 224
   1502a:	83 4e       	sbci	r24, 0xE3	; 227
   1502c:	9f 4f       	sbci	r25, 0xFF	; 255
   1502e:	f3 e0       	ldi	r31, 0x03	; 3
   15030:	66 0f       	add	r22, r22
   15032:	77 1f       	adc	r23, r23
   15034:	88 1f       	adc	r24, r24
   15036:	99 1f       	adc	r25, r25
   15038:	fa 95       	dec	r31
   1503a:	d1 f7       	brne	.-12     	; 0x15030 <uart_baudrate+0x16>
   1503c:	e4 e0       	ldi	r30, 0x04	; 4
   1503e:	22 0f       	add	r18, r18
   15040:	33 1f       	adc	r19, r19
   15042:	44 1f       	adc	r20, r20
   15044:	55 1f       	adc	r21, r21
   15046:	ea 95       	dec	r30
   15048:	d1 f7       	brne	.-12     	; 0x1503e <uart_baudrate+0x24>
   1504a:	0e 94 2c ad 	call	0x15a58	; 0x15a58 <__udivmodsi4>
   1504e:	21 50       	subi	r18, 0x01	; 1
   15050:	30 40       	sbci	r19, 0x00	; 0
   15052:	40 40       	sbci	r20, 0x00	; 0
   15054:	50 40       	sbci	r21, 0x00	; 0
   15056:	bb 27       	eor	r27, r27
   15058:	a5 2f       	mov	r26, r21
   1505a:	94 2f       	mov	r25, r20
   1505c:	83 2f       	mov	r24, r19

	if(__com){
   1505e:	11 23       	and	r17, r17
   15060:	29 f0       	breq	.+10     	; 0x1506c <uart_baudrate+0x52>
		UBRR1L = __br;
   15062:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   15066:	80 93 98 00 	sts	0x0098, r24
   1506a:	03 c0       	rjmp	.+6      	; 0x15072 <uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   1506c:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   1506e:	80 93 90 00 	sts	0x0090, r24
	}
}
   15072:	1f 91       	pop	r17
   15074:	08 95       	ret

00015076 <uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void uart_init(unsigned char __com, unsigned long __baudrate){
   15076:	98 2f       	mov	r25, r24
	if(__com){
   15078:	88 23       	and	r24, r24
   1507a:	39 f0       	breq	.+14     	; 0x1508a <uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   1507c:	88 e9       	ldi	r24, 0x98	; 152
   1507e:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   15082:	86 e0       	ldi	r24, 0x06	; 6
   15084:	80 93 9d 00 	sts	0x009D, r24
   15088:	05 c0       	rjmp	.+10     	; 0x15094 <uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   1508a:	88 e9       	ldi	r24, 0x98	; 152
   1508c:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   1508e:	86 e0       	ldi	r24, 0x06	; 6
   15090:	80 93 95 00 	sts	0x0095, r24
	}

	uart_baudrate(__com, __baudrate);
   15094:	89 2f       	mov	r24, r25
   15096:	0e 94 0d a8 	call	0x1501a	; 0x1501a <uart_baudrate>
}
   1509a:	08 95       	ret

0001509c <uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   1509c:	88 23       	and	r24, r24
   1509e:	81 f0       	breq	.+32     	; 0x150c0 <uart+0x24>
		if(__dir){
   150a0:	66 23       	and	r22, r22
   150a2:	39 f0       	breq	.+14     	; 0x150b2 <uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   150a4:	80 91 9b 00 	lds	r24, 0x009B
   150a8:	85 ff       	sbrs	r24, 5
   150aa:	fc cf       	rjmp	.-8      	; 0x150a4 <uart+0x8>
			UDR1 = __chr;
   150ac:	40 93 9c 00 	sts	0x009C, r20
   150b0:	0c c0       	rjmp	.+24     	; 0x150ca <uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   150b2:	80 91 9b 00 	lds	r24, 0x009B
   150b6:	87 ff       	sbrs	r24, 7
   150b8:	fc cf       	rjmp	.-8      	; 0x150b2 <uart+0x16>
			return UDR1;
   150ba:	80 91 9c 00 	lds	r24, 0x009C
   150be:	08 95       	ret
		}
	}
	else{
		if(__dir){
   150c0:	66 23       	and	r22, r22
   150c2:	29 f0       	breq	.+10     	; 0x150ce <uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   150c4:	5d 9b       	sbis	0x0b, 5	; 11
   150c6:	fe cf       	rjmp	.-4      	; 0x150c4 <uart+0x28>
			UDR0 = __chr;
   150c8:	4c b9       	out	0x0c, r20	; 12
   150ca:	81 e0       	ldi	r24, 0x01	; 1
   150cc:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   150ce:	5f 9b       	sbis	0x0b, 7	; 11
   150d0:	fe cf       	rjmp	.-4      	; 0x150ce <uart+0x32>
			return UDR0;
   150d2:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   150d4:	08 95       	ret

000150d6 <uart_print>:

void uart_print(unsigned char __com, unsigned char __ret, char *__str){
   150d6:	0f 93       	push	r16
   150d8:	1f 93       	push	r17
   150da:	cf 93       	push	r28
   150dc:	df 93       	push	r29
   150de:	18 2f       	mov	r17, r24
   150e0:	06 2f       	mov	r16, r22
   150e2:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   150e4:	88 81       	ld	r24, Y
   150e6:	88 23       	and	r24, r24
   150e8:	31 f4       	brne	.+12     	; 0x150f6 <uart_print+0x20>
   150ea:	08 c0       	rjmp	.+16     	; 0x150fc <uart_print+0x26>
		while(*__str)
		     uart(__com, 1, *__str++);
   150ec:	21 96       	adiw	r28, 0x01	; 1
   150ee:	81 2f       	mov	r24, r17
   150f0:	61 e0       	ldi	r22, 0x01	; 1
   150f2:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
	return 1;
}

void uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   150f6:	48 81       	ld	r20, Y
   150f8:	44 23       	and	r20, r20
   150fa:	c1 f7       	brne	.-16     	; 0x150ec <uart_print+0x16>
		     uart(__com, 1, *__str++);

	if(__ret){
   150fc:	00 23       	and	r16, r16
   150fe:	51 f0       	breq	.+20     	; 0x15114 <uart_print+0x3e>
		uart(__com, 1, 0x0D);
   15100:	81 2f       	mov	r24, r17
   15102:	61 e0       	ldi	r22, 0x01	; 1
   15104:	4d e0       	ldi	r20, 0x0D	; 13
   15106:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		uart(__com, 1, 0x0A);
   1510a:	81 2f       	mov	r24, r17
   1510c:	61 e0       	ldi	r22, 0x01	; 1
   1510e:	4a e0       	ldi	r20, 0x0A	; 10
   15110:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
   15114:	82 ee       	ldi	r24, 0xE2	; 226
   15116:	94 e0       	ldi	r25, 0x04	; 4
   15118:	01 97       	sbiw	r24, 0x01	; 1
   1511a:	f1 f7       	brne	.-4      	; 0x15118 <uart_print+0x42>
	}
	_delay_ms(5);
}
   1511c:	df 91       	pop	r29
   1511e:	cf 91       	pop	r28
   15120:	1f 91       	pop	r17
   15122:	0f 91       	pop	r16
   15124:	08 95       	ret

00015126 <uart_printf>:

void uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   15126:	0f 93       	push	r16
   15128:	1f 93       	push	r17
   1512a:	cf 93       	push	r28
   1512c:	df 93       	push	r29
   1512e:	18 2f       	mov	r17, r24
   15130:	06 2f       	mov	r16, r22
   15132:	ea 01       	movw	r28, r20
   15134:	07 c0       	rjmp	.+14     	; 0x15144 <uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		uart(__com, 1, pgm_read_byte(&(*__str++)));
   15136:	21 96       	adiw	r28, 0x01	; 1
   15138:	f9 01       	movw	r30, r18
   1513a:	44 91       	lpm	r20, Z+
   1513c:	81 2f       	mov	r24, r17
   1513e:	61 e0       	ldi	r22, 0x01	; 1
   15140:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
   15144:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   15146:	fe 01       	movw	r30, r28
   15148:	84 91       	lpm	r24, Z+
   1514a:	88 23       	and	r24, r24
   1514c:	a1 f7       	brne	.-24     	; 0x15136 <uart_printf+0x10>
		uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   1514e:	00 23       	and	r16, r16
   15150:	51 f0       	breq	.+20     	; 0x15166 <uart_printf+0x40>
		uart(__com, 1, 0x0D);
   15152:	81 2f       	mov	r24, r17
   15154:	61 e0       	ldi	r22, 0x01	; 1
   15156:	4d e0       	ldi	r20, 0x0D	; 13
   15158:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
		uart(__com, 1, 0x0A);
   1515c:	81 2f       	mov	r24, r17
   1515e:	61 e0       	ldi	r22, 0x01	; 1
   15160:	4a e0       	ldi	r20, 0x0A	; 10
   15162:	0e 94 4e a8 	call	0x1509c	; 0x1509c <uart>
   15166:	86 ea       	ldi	r24, 0xA6	; 166
   15168:	9e e0       	ldi	r25, 0x0E	; 14
   1516a:	01 97       	sbiw	r24, 0x01	; 1
   1516c:	f1 f7       	brne	.-4      	; 0x1516a <uart_printf+0x44>
	}
	_delay_ms(15);
}
   1516e:	df 91       	pop	r29
   15170:	cf 91       	pop	r28
   15172:	1f 91       	pop	r17
   15174:	0f 91       	pop	r16
   15176:	08 95       	ret

00015178 <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   15178:	6f 92       	push	r6
   1517a:	7f 92       	push	r7
   1517c:	8f 92       	push	r8
   1517e:	9f 92       	push	r9
   15180:	af 92       	push	r10
   15182:	bf 92       	push	r11
   15184:	cf 92       	push	r12
   15186:	df 92       	push	r13
   15188:	ef 92       	push	r14
   1518a:	ff 92       	push	r15
   1518c:	0f 93       	push	r16
   1518e:	1f 93       	push	r17
   15190:	cf 93       	push	r28
   15192:	df 93       	push	r29
   15194:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   15196:	41 15       	cp	r20, r1
   15198:	51 05       	cpc	r21, r1
   1519a:	61 05       	cpc	r22, r1
   1519c:	71 05       	cpc	r23, r1
   1519e:	21 f4       	brne	.+8      	; 0x151a8 <Int2Str+0x30>
		__string[0] = '0';
   151a0:	80 e3       	ldi	r24, 0x30	; 48
   151a2:	88 83       	st	Y, r24
		__string[1] = '\0';
   151a4:	19 82       	std	Y+1, r1	; 0x01
   151a6:	48 c0       	rjmp	.+144    	; 0x15238 <Int2Str+0xc0>
		return;
   151a8:	4a 01       	movw	r8, r20
   151aa:	5b 01       	movw	r10, r22
   151ac:	10 e0       	ldi	r17, 0x00	; 0
   151ae:	00 e0       	ldi	r16, 0x00	; 0
   151b0:	77 24       	eor	r7, r7
   151b2:	c1 2c       	mov	r12, r1
   151b4:	ba ec       	ldi	r27, 0xCA	; 202
   151b6:	db 2e       	mov	r13, r27
   151b8:	ba e9       	ldi	r27, 0x9A	; 154
   151ba:	eb 2e       	mov	r14, r27
   151bc:	bb e3       	ldi	r27, 0x3B	; 59
   151be:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   151c0:	a0 e3       	ldi	r26, 0x30	; 48
   151c2:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   151c4:	8c 14       	cp	r8, r12
   151c6:	9d 04       	cpc	r9, r13
   151c8:	ae 04       	cpc	r10, r14
   151ca:	bf 04       	cpc	r11, r15
   151cc:	d0 f0       	brcs	.+52     	; 0x15202 <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   151ce:	c5 01       	movw	r24, r10
   151d0:	b4 01       	movw	r22, r8
   151d2:	a7 01       	movw	r20, r14
   151d4:	96 01       	movw	r18, r12
   151d6:	0e 94 2c ad 	call	0x15a58	; 0x15a58 <__udivmodsi4>
   151da:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   151dc:	c5 01       	movw	r24, r10
   151de:	b4 01       	movw	r22, r8
   151e0:	a7 01       	movw	r20, r14
   151e2:	96 01       	movw	r18, r12
   151e4:	0e 94 2c ad 	call	0x15a58	; 0x15a58 <__udivmodsi4>
   151e8:	ac 01       	movw	r20, r24
   151ea:	cb 01       	movw	r24, r22
   151ec:	da 01       	movw	r26, r20
   151ee:	4c 01       	movw	r8, r24
   151f0:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   151f2:	fe 01       	movw	r30, r28
   151f4:	e0 0f       	add	r30, r16
   151f6:	f1 1d       	adc	r31, r1
   151f8:	10 5d       	subi	r17, 0xD0	; 208
   151fa:	10 83       	st	Z, r17
   151fc:	0f 5f       	subi	r16, 0xFF	; 255
   151fe:	11 e0       	ldi	r17, 0x01	; 1
   15200:	07 c0       	rjmp	.+14     	; 0x15210 <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   15202:	11 23       	and	r17, r17
   15204:	29 f0       	breq	.+10     	; 0x15210 <Int2Str+0x98>
				__string[__i++] = 0x30;
   15206:	fe 01       	movw	r30, r28
   15208:	e0 0f       	add	r30, r16
   1520a:	f1 1d       	adc	r31, r1
   1520c:	60 82       	st	Z, r6
   1520e:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   15210:	73 94       	inc	r7
   15212:	8a e0       	ldi	r24, 0x0A	; 10
   15214:	78 16       	cp	r7, r24
   15216:	69 f0       	breq	.+26     	; 0x15232 <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   15218:	c7 01       	movw	r24, r14
   1521a:	b6 01       	movw	r22, r12
   1521c:	2a e0       	ldi	r18, 0x0A	; 10
   1521e:	30 e0       	ldi	r19, 0x00	; 0
   15220:	40 e0       	ldi	r20, 0x00	; 0
   15222:	50 e0       	ldi	r21, 0x00	; 0
   15224:	0e 94 2c ad 	call	0x15a58	; 0x15a58 <__udivmodsi4>
   15228:	c9 01       	movw	r24, r18
   1522a:	da 01       	movw	r26, r20
   1522c:	6c 01       	movw	r12, r24
   1522e:	7d 01       	movw	r14, r26
   15230:	c9 cf       	rjmp	.-110    	; 0x151c4 <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   15232:	c0 0f       	add	r28, r16
   15234:	d1 1d       	adc	r29, r1
   15236:	18 82       	st	Y, r1
}
   15238:	df 91       	pop	r29
   1523a:	cf 91       	pop	r28
   1523c:	1f 91       	pop	r17
   1523e:	0f 91       	pop	r16
   15240:	ff 90       	pop	r15
   15242:	ef 90       	pop	r14
   15244:	df 90       	pop	r13
   15246:	cf 90       	pop	r12
   15248:	bf 90       	pop	r11
   1524a:	af 90       	pop	r10
   1524c:	9f 90       	pop	r9
   1524e:	8f 90       	pop	r8
   15250:	7f 90       	pop	r7
   15252:	6f 90       	pop	r6
   15254:	08 95       	ret

00015256 <Str2Int>:

unsigned long Str2Int(char* __string){
   15256:	6f 92       	push	r6
   15258:	7f 92       	push	r7
   1525a:	8f 92       	push	r8
   1525c:	9f 92       	push	r9
   1525e:	af 92       	push	r10
   15260:	bf 92       	push	r11
   15262:	cf 92       	push	r12
   15264:	df 92       	push	r13
   15266:	ef 92       	push	r14
   15268:	ff 92       	push	r15
   1526a:	0f 93       	push	r16
   1526c:	1f 93       	push	r17
   1526e:	cf 93       	push	r28
   15270:	df 93       	push	r29
   15272:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   15274:	dc 01       	movw	r26, r24
   15276:	0d 90       	ld	r0, X+
   15278:	00 20       	and	r0, r0
   1527a:	e9 f7       	brne	.-6      	; 0x15276 <Str2Int+0x20>
   1527c:	11 97       	sbiw	r26, 0x01	; 1
   1527e:	7a 2e       	mov	r7, r26
   15280:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   15282:	87 2d       	mov	r24, r7
   15284:	81 50       	subi	r24, 0x01	; 1
   15286:	8a 30       	cpi	r24, 0x0A	; 10
   15288:	08 f0       	brcs	.+2      	; 0x1528c <Str2Int+0x36>
   1528a:	64 c0       	rjmp	.+200    	; 0x15354 <Str2Int+0xfe>
   1528c:	4e 01       	movw	r8, r28
   1528e:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   15290:	6c 2e       	mov	r6, r28
   15292:	05 c0       	rjmp	.+10     	; 0x1529e <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   15294:	81 91       	ld	r24, Z+
   15296:	80 53       	subi	r24, 0x30	; 48
   15298:	8a 30       	cpi	r24, 0x0A	; 10
   1529a:	08 f0       	brcs	.+2      	; 0x1529e <Str2Int+0x48>
   1529c:	5b c0       	rjmp	.+182    	; 0x15354 <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   1529e:	8e 2f       	mov	r24, r30
   152a0:	86 19       	sub	r24, r6
   152a2:	87 15       	cp	r24, r7
   152a4:	b8 f3       	brcs	.-18     	; 0x15294 <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   152a6:	8a e0       	ldi	r24, 0x0A	; 10
   152a8:	78 16       	cp	r7, r24
   152aa:	f9 f4       	brne	.+62     	; 0x152ea <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   152ac:	98 81       	ld	r25, Y
   152ae:	89 2f       	mov	r24, r25
   152b0:	80 53       	subi	r24, 0x30	; 48
   152b2:	83 30       	cpi	r24, 0x03	; 3
   152b4:	08 f0       	brcs	.+2      	; 0x152b8 <Str2Int+0x62>
   152b6:	4e c0       	rjmp	.+156    	; 0x15354 <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   152b8:	92 33       	cpi	r25, 0x32	; 50
   152ba:	b9 f4       	brne	.+46     	; 0x152ea <Str2Int+0x94>
   152bc:	fe 01       	movw	r30, r28
   152be:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   152c0:	81 81       	ldd	r24, Z+1	; 0x01
   152c2:	80 33       	cpi	r24, 0x30	; 48
   152c4:	09 f0       	breq	.+2      	; 0x152c8 <Str2Int+0x72>
   152c6:	46 c0       	rjmp	.+140    	; 0x15354 <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   152c8:	9f 5f       	subi	r25, 0xFF	; 255
   152ca:	31 96       	adiw	r30, 0x01	; 1
   152cc:	9a 30       	cpi	r25, 0x0A	; 10
   152ce:	c1 f7       	brne	.-16     	; 0x152c0 <Str2Int+0x6a>
   152d0:	0c c0       	rjmp	.+24     	; 0x152ea <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   152d2:	c6 01       	movw	r24, r12
   152d4:	b5 01       	movw	r22, r10
   152d6:	2a e0       	ldi	r18, 0x0A	; 10
   152d8:	30 e0       	ldi	r19, 0x00	; 0
   152da:	40 e0       	ldi	r20, 0x00	; 0
   152dc:	50 e0       	ldi	r21, 0x00	; 0
   152de:	0e 94 cd ac 	call	0x1599a	; 0x1599a <__mulsi3>
   152e2:	5b 01       	movw	r10, r22
   152e4:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   152e6:	1f 5f       	subi	r17, 0xFF	; 255
   152e8:	09 c0       	rjmp	.+18     	; 0x152fc <Str2Int+0xa6>
   152ea:	10 e0       	ldi	r17, 0x00	; 0
   152ec:	01 e0       	ldi	r16, 0x01	; 1
   152ee:	a0 2e       	mov	r10, r16
   152f0:	b1 2c       	mov	r11, r1
   152f2:	c1 2c       	mov	r12, r1
   152f4:	d1 2c       	mov	r13, r1
   152f6:	c7 2d       	mov	r28, r7
   152f8:	d0 e0       	ldi	r29, 0x00	; 0
   152fa:	21 97       	sbiw	r28, 0x01	; 1
   152fc:	81 2f       	mov	r24, r17
   152fe:	90 e0       	ldi	r25, 0x00	; 0
   15300:	8c 17       	cp	r24, r28
   15302:	9d 07       	cpc	r25, r29
   15304:	34 f3       	brlt	.-52     	; 0x152d2 <Str2Int+0x7c>
   15306:	ee 24       	eor	r14, r14
   15308:	ff 24       	eor	r15, r15
   1530a:	87 01       	movw	r16, r14
   1530c:	1e c0       	rjmp	.+60     	; 0x1534a <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   1530e:	f4 01       	movw	r30, r8
   15310:	21 91       	ld	r18, Z+
   15312:	4f 01       	movw	r8, r30
   15314:	30 e0       	ldi	r19, 0x00	; 0
   15316:	20 53       	subi	r18, 0x30	; 48
   15318:	30 40       	sbci	r19, 0x00	; 0
   1531a:	44 27       	eor	r20, r20
   1531c:	37 fd       	sbrc	r19, 7
   1531e:	40 95       	com	r20
   15320:	54 2f       	mov	r21, r20
   15322:	c6 01       	movw	r24, r12
   15324:	b5 01       	movw	r22, r10
   15326:	0e 94 cd ac 	call	0x1599a	; 0x1599a <__mulsi3>
   1532a:	e6 0e       	add	r14, r22
   1532c:	f7 1e       	adc	r15, r23
   1532e:	08 1f       	adc	r16, r24
   15330:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   15332:	c6 01       	movw	r24, r12
   15334:	b5 01       	movw	r22, r10
   15336:	2a e0       	ldi	r18, 0x0A	; 10
   15338:	30 e0       	ldi	r19, 0x00	; 0
   1533a:	40 e0       	ldi	r20, 0x00	; 0
   1533c:	50 e0       	ldi	r21, 0x00	; 0
   1533e:	0e 94 2c ad 	call	0x15a58	; 0x15a58 <__udivmodsi4>
   15342:	c9 01       	movw	r24, r18
   15344:	da 01       	movw	r26, r20
   15346:	5c 01       	movw	r10, r24
   15348:	6d 01       	movw	r12, r26
   1534a:	88 2d       	mov	r24, r8
   1534c:	86 19       	sub	r24, r6
   1534e:	87 15       	cp	r24, r7
   15350:	f0 f2       	brcs	.-68     	; 0x1530e <Str2Int+0xb8>
   15352:	03 c0       	rjmp	.+6      	; 0x1535a <Str2Int+0x104>
   15354:	ee 24       	eor	r14, r14
   15356:	ff 24       	eor	r15, r15
   15358:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   1535a:	b7 01       	movw	r22, r14
   1535c:	c8 01       	movw	r24, r16
   1535e:	df 91       	pop	r29
   15360:	cf 91       	pop	r28
   15362:	1f 91       	pop	r17
   15364:	0f 91       	pop	r16
   15366:	ff 90       	pop	r15
   15368:	ef 90       	pop	r14
   1536a:	df 90       	pop	r13
   1536c:	cf 90       	pop	r12
   1536e:	bf 90       	pop	r11
   15370:	af 90       	pop	r10
   15372:	9f 90       	pop	r9
   15374:	8f 90       	pop	r8
   15376:	7f 90       	pop	r7
   15378:	6f 90       	pop	r6
   1537a:	08 95       	ret

0001537c <atoi>:
   1537c:	fc 01       	movw	r30, r24
   1537e:	88 27       	eor	r24, r24
   15380:	99 27       	eor	r25, r25
   15382:	e8 94       	clt
   15384:	21 91       	ld	r18, Z+
   15386:	20 32       	cpi	r18, 0x20	; 32
   15388:	e9 f3       	breq	.-6      	; 0x15384 <atoi+0x8>
   1538a:	29 30       	cpi	r18, 0x09	; 9
   1538c:	10 f0       	brcs	.+4      	; 0x15392 <atoi+0x16>
   1538e:	2e 30       	cpi	r18, 0x0E	; 14
   15390:	c8 f3       	brcs	.-14     	; 0x15384 <atoi+0x8>
   15392:	2b 32       	cpi	r18, 0x2B	; 43
   15394:	41 f0       	breq	.+16     	; 0x153a6 <atoi+0x2a>
   15396:	2d 32       	cpi	r18, 0x2D	; 45
   15398:	39 f4       	brne	.+14     	; 0x153a8 <atoi+0x2c>
   1539a:	68 94       	set
   1539c:	04 c0       	rjmp	.+8      	; 0x153a6 <atoi+0x2a>
   1539e:	0e 94 24 aa 	call	0x15448	; 0x15448 <__mulhi_const_10>
   153a2:	82 0f       	add	r24, r18
   153a4:	91 1d       	adc	r25, r1
   153a6:	21 91       	ld	r18, Z+
   153a8:	20 53       	subi	r18, 0x30	; 48
   153aa:	2a 30       	cpi	r18, 0x0A	; 10
   153ac:	c0 f3       	brcs	.-16     	; 0x1539e <atoi+0x22>
   153ae:	1e f4       	brtc	.+6      	; 0x153b6 <atoi+0x3a>
   153b0:	90 95       	com	r25
   153b2:	81 95       	neg	r24
   153b4:	9f 4f       	sbci	r25, 0xFF	; 255
   153b6:	08 95       	ret

000153b8 <strcpy_P>:
   153b8:	fb 01       	movw	r30, r22
   153ba:	dc 01       	movw	r26, r24
   153bc:	05 90       	lpm	r0, Z+
   153be:	0d 92       	st	X+, r0
   153c0:	00 20       	and	r0, r0
   153c2:	e1 f7       	brne	.-8      	; 0x153bc <strcpy_P+0x4>
   153c4:	08 95       	ret

000153c6 <strcmp>:
   153c6:	fb 01       	movw	r30, r22
   153c8:	dc 01       	movw	r26, r24
   153ca:	8d 91       	ld	r24, X+
   153cc:	01 90       	ld	r0, Z+
   153ce:	80 19       	sub	r24, r0
   153d0:	01 10       	cpse	r0, r1
   153d2:	d9 f3       	breq	.-10     	; 0x153ca <strcmp+0x4>
   153d4:	99 0b       	sbc	r25, r25
   153d6:	08 95       	ret

000153d8 <__eerd_block>:
   153d8:	a0 e0       	ldi	r26, 0x00	; 0
   153da:	b0 e0       	ldi	r27, 0x00	; 0
   153dc:	e2 ef       	ldi	r30, 0xF2	; 242
   153de:	f9 ea       	ldi	r31, 0xA9	; 169
   153e0:	0c 94 58 ad 	jmp	0x15ab0	; 0x15ab0 <__prologue_saves__+0x14>
   153e4:	7c 01       	movw	r14, r24
   153e6:	eb 01       	movw	r28, r22
   153e8:	8a 01       	movw	r16, r20
   153ea:	69 01       	movw	r12, r18
   153ec:	09 c0       	rjmp	.+18     	; 0x15400 <__eerd_block+0x28>
   153ee:	ce 01       	movw	r24, r28
   153f0:	21 96       	adiw	r28, 0x01	; 1
   153f2:	f6 01       	movw	r30, r12
   153f4:	09 95       	icall
   153f6:	f7 01       	movw	r30, r14
   153f8:	81 93       	st	Z+, r24
   153fa:	7f 01       	movw	r14, r30
   153fc:	01 50       	subi	r16, 0x01	; 1
   153fe:	10 40       	sbci	r17, 0x00	; 0
   15400:	01 15       	cp	r16, r1
   15402:	11 05       	cpc	r17, r1
   15404:	a1 f7       	brne	.-24     	; 0x153ee <__eerd_block+0x16>
   15406:	cd b7       	in	r28, 0x3d	; 61
   15408:	de b7       	in	r29, 0x3e	; 62
   1540a:	e8 e0       	ldi	r30, 0x08	; 8
   1540c:	0c 94 74 ad 	jmp	0x15ae8	; 0x15ae8 <__epilogue_restores__+0x14>

00015410 <__eewr_block>:
   15410:	a0 e0       	ldi	r26, 0x00	; 0
   15412:	b0 e0       	ldi	r27, 0x00	; 0
   15414:	ee e0       	ldi	r30, 0x0E	; 14
   15416:	fa ea       	ldi	r31, 0xAA	; 170
   15418:	0c 94 58 ad 	jmp	0x15ab0	; 0x15ab0 <__prologue_saves__+0x14>
   1541c:	ec 01       	movw	r28, r24
   1541e:	7b 01       	movw	r14, r22
   15420:	8a 01       	movw	r16, r20
   15422:	69 01       	movw	r12, r18
   15424:	09 c0       	rjmp	.+18     	; 0x15438 <__eewr_block+0x28>
   15426:	ce 01       	movw	r24, r28
   15428:	21 96       	adiw	r28, 0x01	; 1
   1542a:	f7 01       	movw	r30, r14
   1542c:	61 91       	ld	r22, Z+
   1542e:	7f 01       	movw	r14, r30
   15430:	f6 01       	movw	r30, r12
   15432:	09 95       	icall
   15434:	01 50       	subi	r16, 0x01	; 1
   15436:	10 40       	sbci	r17, 0x00	; 0
   15438:	01 15       	cp	r16, r1
   1543a:	11 05       	cpc	r17, r1
   1543c:	a1 f7       	brne	.-24     	; 0x15426 <__eewr_block+0x16>
   1543e:	cd b7       	in	r28, 0x3d	; 61
   15440:	de b7       	in	r29, 0x3e	; 62
   15442:	e8 e0       	ldi	r30, 0x08	; 8
   15444:	0c 94 74 ad 	jmp	0x15ae8	; 0x15ae8 <__epilogue_restores__+0x14>

00015448 <__mulhi_const_10>:
   15448:	7a e0       	ldi	r23, 0x0A	; 10
   1544a:	97 9f       	mul	r25, r23
   1544c:	90 2d       	mov	r25, r0
   1544e:	87 9f       	mul	r24, r23
   15450:	80 2d       	mov	r24, r0
   15452:	91 0d       	add	r25, r1
   15454:	11 24       	eor	r1, r1
   15456:	08 95       	ret

00015458 <sprintf_P>:
   15458:	ae e0       	ldi	r26, 0x0E	; 14
   1545a:	b0 e0       	ldi	r27, 0x00	; 0
   1545c:	e2 e3       	ldi	r30, 0x32	; 50
   1545e:	fa ea       	ldi	r31, 0xAA	; 170
   15460:	0c 94 5c ad 	jmp	0x15ab8	; 0x15ab8 <__prologue_saves__+0x1c>
   15464:	0d 89       	ldd	r16, Y+21	; 0x15
   15466:	1e 89       	ldd	r17, Y+22	; 0x16
   15468:	8e e0       	ldi	r24, 0x0E	; 14
   1546a:	8c 83       	std	Y+4, r24	; 0x04
   1546c:	1a 83       	std	Y+2, r17	; 0x02
   1546e:	09 83       	std	Y+1, r16	; 0x01
   15470:	8f ef       	ldi	r24, 0xFF	; 255
   15472:	9f e7       	ldi	r25, 0x7F	; 127
   15474:	9e 83       	std	Y+6, r25	; 0x06
   15476:	8d 83       	std	Y+5, r24	; 0x05
   15478:	9e 01       	movw	r18, r28
   1547a:	27 5e       	subi	r18, 0xE7	; 231
   1547c:	3f 4f       	sbci	r19, 0xFF	; 255
   1547e:	ce 01       	movw	r24, r28
   15480:	01 96       	adiw	r24, 0x01	; 1
   15482:	6f 89       	ldd	r22, Y+23	; 0x17
   15484:	78 8d       	ldd	r23, Y+24	; 0x18
   15486:	a9 01       	movw	r20, r18
   15488:	0e 94 50 aa 	call	0x154a0	; 0x154a0 <vfprintf>
   1548c:	2f 81       	ldd	r18, Y+7	; 0x07
   1548e:	38 85       	ldd	r19, Y+8	; 0x08
   15490:	02 0f       	add	r16, r18
   15492:	13 1f       	adc	r17, r19
   15494:	f8 01       	movw	r30, r16
   15496:	10 82       	st	Z, r1
   15498:	2e 96       	adiw	r28, 0x0e	; 14
   1549a:	e4 e0       	ldi	r30, 0x04	; 4
   1549c:	0c 94 78 ad 	jmp	0x15af0	; 0x15af0 <__epilogue_restores__+0x1c>

000154a0 <vfprintf>:
   154a0:	ab e0       	ldi	r26, 0x0B	; 11
   154a2:	b0 e0       	ldi	r27, 0x00	; 0
   154a4:	e6 e5       	ldi	r30, 0x56	; 86
   154a6:	fa ea       	ldi	r31, 0xAA	; 170
   154a8:	0c 94 4e ad 	jmp	0x15a9c	; 0x15a9c <__prologue_saves__>
   154ac:	3c 01       	movw	r6, r24
   154ae:	2b 01       	movw	r4, r22
   154b0:	5a 01       	movw	r10, r20
   154b2:	fc 01       	movw	r30, r24
   154b4:	17 82       	std	Z+7, r1	; 0x07
   154b6:	16 82       	std	Z+6, r1	; 0x06
   154b8:	83 81       	ldd	r24, Z+3	; 0x03
   154ba:	81 fd       	sbrc	r24, 1
   154bc:	03 c0       	rjmp	.+6      	; 0x154c4 <vfprintf+0x24>
   154be:	6f ef       	ldi	r22, 0xFF	; 255
   154c0:	7f ef       	ldi	r23, 0xFF	; 255
   154c2:	c6 c1       	rjmp	.+908    	; 0x15850 <vfprintf+0x3b0>
   154c4:	9a e0       	ldi	r25, 0x0A	; 10
   154c6:	89 2e       	mov	r8, r25
   154c8:	1e 01       	movw	r2, r28
   154ca:	08 94       	sec
   154cc:	21 1c       	adc	r2, r1
   154ce:	31 1c       	adc	r3, r1
   154d0:	f3 01       	movw	r30, r6
   154d2:	23 81       	ldd	r18, Z+3	; 0x03
   154d4:	f2 01       	movw	r30, r4
   154d6:	23 fd       	sbrc	r18, 3
   154d8:	85 91       	lpm	r24, Z+
   154da:	23 ff       	sbrs	r18, 3
   154dc:	81 91       	ld	r24, Z+
   154de:	2f 01       	movw	r4, r30
   154e0:	88 23       	and	r24, r24
   154e2:	09 f4       	brne	.+2      	; 0x154e6 <vfprintf+0x46>
   154e4:	b2 c1       	rjmp	.+868    	; 0x1584a <vfprintf+0x3aa>
   154e6:	85 32       	cpi	r24, 0x25	; 37
   154e8:	39 f4       	brne	.+14     	; 0x154f8 <vfprintf+0x58>
   154ea:	23 fd       	sbrc	r18, 3
   154ec:	85 91       	lpm	r24, Z+
   154ee:	23 ff       	sbrs	r18, 3
   154f0:	81 91       	ld	r24, Z+
   154f2:	2f 01       	movw	r4, r30
   154f4:	85 32       	cpi	r24, 0x25	; 37
   154f6:	29 f4       	brne	.+10     	; 0x15502 <vfprintf+0x62>
   154f8:	90 e0       	ldi	r25, 0x00	; 0
   154fa:	b3 01       	movw	r22, r6
   154fc:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   15500:	e7 cf       	rjmp	.-50     	; 0x154d0 <vfprintf+0x30>
   15502:	98 2f       	mov	r25, r24
   15504:	ff 24       	eor	r15, r15
   15506:	ee 24       	eor	r14, r14
   15508:	99 24       	eor	r9, r9
   1550a:	ff e1       	ldi	r31, 0x1F	; 31
   1550c:	ff 15       	cp	r31, r15
   1550e:	d0 f0       	brcs	.+52     	; 0x15544 <vfprintf+0xa4>
   15510:	9b 32       	cpi	r25, 0x2B	; 43
   15512:	69 f0       	breq	.+26     	; 0x1552e <vfprintf+0x8e>
   15514:	9c 32       	cpi	r25, 0x2C	; 44
   15516:	28 f4       	brcc	.+10     	; 0x15522 <vfprintf+0x82>
   15518:	90 32       	cpi	r25, 0x20	; 32
   1551a:	59 f0       	breq	.+22     	; 0x15532 <vfprintf+0x92>
   1551c:	93 32       	cpi	r25, 0x23	; 35
   1551e:	91 f4       	brne	.+36     	; 0x15544 <vfprintf+0xa4>
   15520:	0e c0       	rjmp	.+28     	; 0x1553e <vfprintf+0x9e>
   15522:	9d 32       	cpi	r25, 0x2D	; 45
   15524:	49 f0       	breq	.+18     	; 0x15538 <vfprintf+0x98>
   15526:	90 33       	cpi	r25, 0x30	; 48
   15528:	69 f4       	brne	.+26     	; 0x15544 <vfprintf+0xa4>
   1552a:	41 e0       	ldi	r20, 0x01	; 1
   1552c:	24 c0       	rjmp	.+72     	; 0x15576 <vfprintf+0xd6>
   1552e:	52 e0       	ldi	r21, 0x02	; 2
   15530:	f5 2a       	or	r15, r21
   15532:	84 e0       	ldi	r24, 0x04	; 4
   15534:	f8 2a       	or	r15, r24
   15536:	28 c0       	rjmp	.+80     	; 0x15588 <vfprintf+0xe8>
   15538:	98 e0       	ldi	r25, 0x08	; 8
   1553a:	f9 2a       	or	r15, r25
   1553c:	25 c0       	rjmp	.+74     	; 0x15588 <vfprintf+0xe8>
   1553e:	e0 e1       	ldi	r30, 0x10	; 16
   15540:	fe 2a       	or	r15, r30
   15542:	22 c0       	rjmp	.+68     	; 0x15588 <vfprintf+0xe8>
   15544:	f7 fc       	sbrc	r15, 7
   15546:	29 c0       	rjmp	.+82     	; 0x1559a <vfprintf+0xfa>
   15548:	89 2f       	mov	r24, r25
   1554a:	80 53       	subi	r24, 0x30	; 48
   1554c:	8a 30       	cpi	r24, 0x0A	; 10
   1554e:	70 f4       	brcc	.+28     	; 0x1556c <vfprintf+0xcc>
   15550:	f6 fe       	sbrs	r15, 6
   15552:	05 c0       	rjmp	.+10     	; 0x1555e <vfprintf+0xbe>
   15554:	98 9c       	mul	r9, r8
   15556:	90 2c       	mov	r9, r0
   15558:	11 24       	eor	r1, r1
   1555a:	98 0e       	add	r9, r24
   1555c:	15 c0       	rjmp	.+42     	; 0x15588 <vfprintf+0xe8>
   1555e:	e8 9c       	mul	r14, r8
   15560:	e0 2c       	mov	r14, r0
   15562:	11 24       	eor	r1, r1
   15564:	e8 0e       	add	r14, r24
   15566:	f0 e2       	ldi	r31, 0x20	; 32
   15568:	ff 2a       	or	r15, r31
   1556a:	0e c0       	rjmp	.+28     	; 0x15588 <vfprintf+0xe8>
   1556c:	9e 32       	cpi	r25, 0x2E	; 46
   1556e:	29 f4       	brne	.+10     	; 0x1557a <vfprintf+0xda>
   15570:	f6 fc       	sbrc	r15, 6
   15572:	6b c1       	rjmp	.+726    	; 0x1584a <vfprintf+0x3aa>
   15574:	40 e4       	ldi	r20, 0x40	; 64
   15576:	f4 2a       	or	r15, r20
   15578:	07 c0       	rjmp	.+14     	; 0x15588 <vfprintf+0xe8>
   1557a:	9c 36       	cpi	r25, 0x6C	; 108
   1557c:	19 f4       	brne	.+6      	; 0x15584 <vfprintf+0xe4>
   1557e:	50 e8       	ldi	r21, 0x80	; 128
   15580:	f5 2a       	or	r15, r21
   15582:	02 c0       	rjmp	.+4      	; 0x15588 <vfprintf+0xe8>
   15584:	98 36       	cpi	r25, 0x68	; 104
   15586:	49 f4       	brne	.+18     	; 0x1559a <vfprintf+0xfa>
   15588:	f2 01       	movw	r30, r4
   1558a:	23 fd       	sbrc	r18, 3
   1558c:	95 91       	lpm	r25, Z+
   1558e:	23 ff       	sbrs	r18, 3
   15590:	91 91       	ld	r25, Z+
   15592:	2f 01       	movw	r4, r30
   15594:	99 23       	and	r25, r25
   15596:	09 f0       	breq	.+2      	; 0x1559a <vfprintf+0xfa>
   15598:	b8 cf       	rjmp	.-144    	; 0x1550a <vfprintf+0x6a>
   1559a:	89 2f       	mov	r24, r25
   1559c:	85 54       	subi	r24, 0x45	; 69
   1559e:	83 30       	cpi	r24, 0x03	; 3
   155a0:	18 f0       	brcs	.+6      	; 0x155a8 <vfprintf+0x108>
   155a2:	80 52       	subi	r24, 0x20	; 32
   155a4:	83 30       	cpi	r24, 0x03	; 3
   155a6:	38 f4       	brcc	.+14     	; 0x155b6 <vfprintf+0x116>
   155a8:	44 e0       	ldi	r20, 0x04	; 4
   155aa:	50 e0       	ldi	r21, 0x00	; 0
   155ac:	a4 0e       	add	r10, r20
   155ae:	b5 1e       	adc	r11, r21
   155b0:	5f e3       	ldi	r21, 0x3F	; 63
   155b2:	59 83       	std	Y+1, r21	; 0x01
   155b4:	0f c0       	rjmp	.+30     	; 0x155d4 <vfprintf+0x134>
   155b6:	93 36       	cpi	r25, 0x63	; 99
   155b8:	31 f0       	breq	.+12     	; 0x155c6 <vfprintf+0x126>
   155ba:	93 37       	cpi	r25, 0x73	; 115
   155bc:	79 f0       	breq	.+30     	; 0x155dc <vfprintf+0x13c>
   155be:	93 35       	cpi	r25, 0x53	; 83
   155c0:	09 f0       	breq	.+2      	; 0x155c4 <vfprintf+0x124>
   155c2:	56 c0       	rjmp	.+172    	; 0x15670 <vfprintf+0x1d0>
   155c4:	20 c0       	rjmp	.+64     	; 0x15606 <vfprintf+0x166>
   155c6:	f5 01       	movw	r30, r10
   155c8:	80 81       	ld	r24, Z
   155ca:	89 83       	std	Y+1, r24	; 0x01
   155cc:	42 e0       	ldi	r20, 0x02	; 2
   155ce:	50 e0       	ldi	r21, 0x00	; 0
   155d0:	a4 0e       	add	r10, r20
   155d2:	b5 1e       	adc	r11, r21
   155d4:	61 01       	movw	r12, r2
   155d6:	01 e0       	ldi	r16, 0x01	; 1
   155d8:	10 e0       	ldi	r17, 0x00	; 0
   155da:	12 c0       	rjmp	.+36     	; 0x15600 <vfprintf+0x160>
   155dc:	f5 01       	movw	r30, r10
   155de:	c0 80       	ld	r12, Z
   155e0:	d1 80       	ldd	r13, Z+1	; 0x01
   155e2:	f6 fc       	sbrc	r15, 6
   155e4:	03 c0       	rjmp	.+6      	; 0x155ec <vfprintf+0x14c>
   155e6:	6f ef       	ldi	r22, 0xFF	; 255
   155e8:	7f ef       	ldi	r23, 0xFF	; 255
   155ea:	02 c0       	rjmp	.+4      	; 0x155f0 <vfprintf+0x150>
   155ec:	69 2d       	mov	r22, r9
   155ee:	70 e0       	ldi	r23, 0x00	; 0
   155f0:	42 e0       	ldi	r20, 0x02	; 2
   155f2:	50 e0       	ldi	r21, 0x00	; 0
   155f4:	a4 0e       	add	r10, r20
   155f6:	b5 1e       	adc	r11, r21
   155f8:	c6 01       	movw	r24, r12
   155fa:	0e 94 38 ac 	call	0x15870	; 0x15870 <strnlen>
   155fe:	8c 01       	movw	r16, r24
   15600:	5f e7       	ldi	r21, 0x7F	; 127
   15602:	f5 22       	and	r15, r21
   15604:	14 c0       	rjmp	.+40     	; 0x1562e <vfprintf+0x18e>
   15606:	f5 01       	movw	r30, r10
   15608:	c0 80       	ld	r12, Z
   1560a:	d1 80       	ldd	r13, Z+1	; 0x01
   1560c:	f6 fc       	sbrc	r15, 6
   1560e:	03 c0       	rjmp	.+6      	; 0x15616 <vfprintf+0x176>
   15610:	6f ef       	ldi	r22, 0xFF	; 255
   15612:	7f ef       	ldi	r23, 0xFF	; 255
   15614:	02 c0       	rjmp	.+4      	; 0x1561a <vfprintf+0x17a>
   15616:	69 2d       	mov	r22, r9
   15618:	70 e0       	ldi	r23, 0x00	; 0
   1561a:	42 e0       	ldi	r20, 0x02	; 2
   1561c:	50 e0       	ldi	r21, 0x00	; 0
   1561e:	a4 0e       	add	r10, r20
   15620:	b5 1e       	adc	r11, r21
   15622:	c6 01       	movw	r24, r12
   15624:	0e 94 2d ac 	call	0x1585a	; 0x1585a <strnlen_P>
   15628:	8c 01       	movw	r16, r24
   1562a:	50 e8       	ldi	r21, 0x80	; 128
   1562c:	f5 2a       	or	r15, r21
   1562e:	f3 fe       	sbrs	r15, 3
   15630:	07 c0       	rjmp	.+14     	; 0x15640 <vfprintf+0x1a0>
   15632:	1a c0       	rjmp	.+52     	; 0x15668 <vfprintf+0x1c8>
   15634:	80 e2       	ldi	r24, 0x20	; 32
   15636:	90 e0       	ldi	r25, 0x00	; 0
   15638:	b3 01       	movw	r22, r6
   1563a:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   1563e:	ea 94       	dec	r14
   15640:	8e 2d       	mov	r24, r14
   15642:	90 e0       	ldi	r25, 0x00	; 0
   15644:	08 17       	cp	r16, r24
   15646:	19 07       	cpc	r17, r25
   15648:	a8 f3       	brcs	.-22     	; 0x15634 <vfprintf+0x194>
   1564a:	0e c0       	rjmp	.+28     	; 0x15668 <vfprintf+0x1c8>
   1564c:	f6 01       	movw	r30, r12
   1564e:	f7 fc       	sbrc	r15, 7
   15650:	85 91       	lpm	r24, Z+
   15652:	f7 fe       	sbrs	r15, 7
   15654:	81 91       	ld	r24, Z+
   15656:	6f 01       	movw	r12, r30
   15658:	90 e0       	ldi	r25, 0x00	; 0
   1565a:	b3 01       	movw	r22, r6
   1565c:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   15660:	e1 10       	cpse	r14, r1
   15662:	ea 94       	dec	r14
   15664:	01 50       	subi	r16, 0x01	; 1
   15666:	10 40       	sbci	r17, 0x00	; 0
   15668:	01 15       	cp	r16, r1
   1566a:	11 05       	cpc	r17, r1
   1566c:	79 f7       	brne	.-34     	; 0x1564c <vfprintf+0x1ac>
   1566e:	ea c0       	rjmp	.+468    	; 0x15844 <vfprintf+0x3a4>
   15670:	94 36       	cpi	r25, 0x64	; 100
   15672:	11 f0       	breq	.+4      	; 0x15678 <vfprintf+0x1d8>
   15674:	99 36       	cpi	r25, 0x69	; 105
   15676:	69 f5       	brne	.+90     	; 0x156d2 <vfprintf+0x232>
   15678:	f7 fe       	sbrs	r15, 7
   1567a:	08 c0       	rjmp	.+16     	; 0x1568c <vfprintf+0x1ec>
   1567c:	f5 01       	movw	r30, r10
   1567e:	20 81       	ld	r18, Z
   15680:	31 81       	ldd	r19, Z+1	; 0x01
   15682:	42 81       	ldd	r20, Z+2	; 0x02
   15684:	53 81       	ldd	r21, Z+3	; 0x03
   15686:	84 e0       	ldi	r24, 0x04	; 4
   15688:	90 e0       	ldi	r25, 0x00	; 0
   1568a:	0a c0       	rjmp	.+20     	; 0x156a0 <vfprintf+0x200>
   1568c:	f5 01       	movw	r30, r10
   1568e:	80 81       	ld	r24, Z
   15690:	91 81       	ldd	r25, Z+1	; 0x01
   15692:	9c 01       	movw	r18, r24
   15694:	44 27       	eor	r20, r20
   15696:	37 fd       	sbrc	r19, 7
   15698:	40 95       	com	r20
   1569a:	54 2f       	mov	r21, r20
   1569c:	82 e0       	ldi	r24, 0x02	; 2
   1569e:	90 e0       	ldi	r25, 0x00	; 0
   156a0:	a8 0e       	add	r10, r24
   156a2:	b9 1e       	adc	r11, r25
   156a4:	9f e6       	ldi	r25, 0x6F	; 111
   156a6:	f9 22       	and	r15, r25
   156a8:	57 ff       	sbrs	r21, 7
   156aa:	09 c0       	rjmp	.+18     	; 0x156be <vfprintf+0x21e>
   156ac:	50 95       	com	r21
   156ae:	40 95       	com	r20
   156b0:	30 95       	com	r19
   156b2:	21 95       	neg	r18
   156b4:	3f 4f       	sbci	r19, 0xFF	; 255
   156b6:	4f 4f       	sbci	r20, 0xFF	; 255
   156b8:	5f 4f       	sbci	r21, 0xFF	; 255
   156ba:	e0 e8       	ldi	r30, 0x80	; 128
   156bc:	fe 2a       	or	r15, r30
   156be:	ca 01       	movw	r24, r20
   156c0:	b9 01       	movw	r22, r18
   156c2:	a1 01       	movw	r20, r2
   156c4:	2a e0       	ldi	r18, 0x0A	; 10
   156c6:	30 e0       	ldi	r19, 0x00	; 0
   156c8:	0e 94 6f ac 	call	0x158de	; 0x158de <__ultoa_invert>
   156cc:	d8 2e       	mov	r13, r24
   156ce:	d2 18       	sub	r13, r2
   156d0:	40 c0       	rjmp	.+128    	; 0x15752 <vfprintf+0x2b2>
   156d2:	95 37       	cpi	r25, 0x75	; 117
   156d4:	29 f4       	brne	.+10     	; 0x156e0 <vfprintf+0x240>
   156d6:	1f 2d       	mov	r17, r15
   156d8:	1f 7e       	andi	r17, 0xEF	; 239
   156da:	2a e0       	ldi	r18, 0x0A	; 10
   156dc:	30 e0       	ldi	r19, 0x00	; 0
   156de:	1d c0       	rjmp	.+58     	; 0x1571a <vfprintf+0x27a>
   156e0:	1f 2d       	mov	r17, r15
   156e2:	19 7f       	andi	r17, 0xF9	; 249
   156e4:	9f 36       	cpi	r25, 0x6F	; 111
   156e6:	61 f0       	breq	.+24     	; 0x15700 <vfprintf+0x260>
   156e8:	90 37       	cpi	r25, 0x70	; 112
   156ea:	20 f4       	brcc	.+8      	; 0x156f4 <vfprintf+0x254>
   156ec:	98 35       	cpi	r25, 0x58	; 88
   156ee:	09 f0       	breq	.+2      	; 0x156f2 <vfprintf+0x252>
   156f0:	ac c0       	rjmp	.+344    	; 0x1584a <vfprintf+0x3aa>
   156f2:	0f c0       	rjmp	.+30     	; 0x15712 <vfprintf+0x272>
   156f4:	90 37       	cpi	r25, 0x70	; 112
   156f6:	39 f0       	breq	.+14     	; 0x15706 <vfprintf+0x266>
   156f8:	98 37       	cpi	r25, 0x78	; 120
   156fa:	09 f0       	breq	.+2      	; 0x156fe <vfprintf+0x25e>
   156fc:	a6 c0       	rjmp	.+332    	; 0x1584a <vfprintf+0x3aa>
   156fe:	04 c0       	rjmp	.+8      	; 0x15708 <vfprintf+0x268>
   15700:	28 e0       	ldi	r18, 0x08	; 8
   15702:	30 e0       	ldi	r19, 0x00	; 0
   15704:	0a c0       	rjmp	.+20     	; 0x1571a <vfprintf+0x27a>
   15706:	10 61       	ori	r17, 0x10	; 16
   15708:	14 fd       	sbrc	r17, 4
   1570a:	14 60       	ori	r17, 0x04	; 4
   1570c:	20 e1       	ldi	r18, 0x10	; 16
   1570e:	30 e0       	ldi	r19, 0x00	; 0
   15710:	04 c0       	rjmp	.+8      	; 0x1571a <vfprintf+0x27a>
   15712:	14 fd       	sbrc	r17, 4
   15714:	16 60       	ori	r17, 0x06	; 6
   15716:	20 e1       	ldi	r18, 0x10	; 16
   15718:	32 e0       	ldi	r19, 0x02	; 2
   1571a:	17 ff       	sbrs	r17, 7
   1571c:	08 c0       	rjmp	.+16     	; 0x1572e <vfprintf+0x28e>
   1571e:	f5 01       	movw	r30, r10
   15720:	60 81       	ld	r22, Z
   15722:	71 81       	ldd	r23, Z+1	; 0x01
   15724:	82 81       	ldd	r24, Z+2	; 0x02
   15726:	93 81       	ldd	r25, Z+3	; 0x03
   15728:	44 e0       	ldi	r20, 0x04	; 4
   1572a:	50 e0       	ldi	r21, 0x00	; 0
   1572c:	08 c0       	rjmp	.+16     	; 0x1573e <vfprintf+0x29e>
   1572e:	f5 01       	movw	r30, r10
   15730:	80 81       	ld	r24, Z
   15732:	91 81       	ldd	r25, Z+1	; 0x01
   15734:	bc 01       	movw	r22, r24
   15736:	80 e0       	ldi	r24, 0x00	; 0
   15738:	90 e0       	ldi	r25, 0x00	; 0
   1573a:	42 e0       	ldi	r20, 0x02	; 2
   1573c:	50 e0       	ldi	r21, 0x00	; 0
   1573e:	a4 0e       	add	r10, r20
   15740:	b5 1e       	adc	r11, r21
   15742:	a1 01       	movw	r20, r2
   15744:	0e 94 6f ac 	call	0x158de	; 0x158de <__ultoa_invert>
   15748:	d8 2e       	mov	r13, r24
   1574a:	d2 18       	sub	r13, r2
   1574c:	8f e7       	ldi	r24, 0x7F	; 127
   1574e:	f8 2e       	mov	r15, r24
   15750:	f1 22       	and	r15, r17
   15752:	f6 fe       	sbrs	r15, 6
   15754:	0b c0       	rjmp	.+22     	; 0x1576c <vfprintf+0x2cc>
   15756:	5e ef       	ldi	r21, 0xFE	; 254
   15758:	f5 22       	and	r15, r21
   1575a:	d9 14       	cp	r13, r9
   1575c:	38 f4       	brcc	.+14     	; 0x1576c <vfprintf+0x2cc>
   1575e:	f4 fe       	sbrs	r15, 4
   15760:	07 c0       	rjmp	.+14     	; 0x15770 <vfprintf+0x2d0>
   15762:	f2 fc       	sbrc	r15, 2
   15764:	05 c0       	rjmp	.+10     	; 0x15770 <vfprintf+0x2d0>
   15766:	8f ee       	ldi	r24, 0xEF	; 239
   15768:	f8 22       	and	r15, r24
   1576a:	02 c0       	rjmp	.+4      	; 0x15770 <vfprintf+0x2d0>
   1576c:	1d 2d       	mov	r17, r13
   1576e:	01 c0       	rjmp	.+2      	; 0x15772 <vfprintf+0x2d2>
   15770:	19 2d       	mov	r17, r9
   15772:	f4 fe       	sbrs	r15, 4
   15774:	0d c0       	rjmp	.+26     	; 0x15790 <vfprintf+0x2f0>
   15776:	fe 01       	movw	r30, r28
   15778:	ed 0d       	add	r30, r13
   1577a:	f1 1d       	adc	r31, r1
   1577c:	80 81       	ld	r24, Z
   1577e:	80 33       	cpi	r24, 0x30	; 48
   15780:	19 f4       	brne	.+6      	; 0x15788 <vfprintf+0x2e8>
   15782:	99 ee       	ldi	r25, 0xE9	; 233
   15784:	f9 22       	and	r15, r25
   15786:	08 c0       	rjmp	.+16     	; 0x15798 <vfprintf+0x2f8>
   15788:	1f 5f       	subi	r17, 0xFF	; 255
   1578a:	f2 fe       	sbrs	r15, 2
   1578c:	05 c0       	rjmp	.+10     	; 0x15798 <vfprintf+0x2f8>
   1578e:	03 c0       	rjmp	.+6      	; 0x15796 <vfprintf+0x2f6>
   15790:	8f 2d       	mov	r24, r15
   15792:	86 78       	andi	r24, 0x86	; 134
   15794:	09 f0       	breq	.+2      	; 0x15798 <vfprintf+0x2f8>
   15796:	1f 5f       	subi	r17, 0xFF	; 255
   15798:	0f 2d       	mov	r16, r15
   1579a:	f3 fc       	sbrc	r15, 3
   1579c:	14 c0       	rjmp	.+40     	; 0x157c6 <vfprintf+0x326>
   1579e:	f0 fe       	sbrs	r15, 0
   157a0:	0f c0       	rjmp	.+30     	; 0x157c0 <vfprintf+0x320>
   157a2:	1e 15       	cp	r17, r14
   157a4:	10 f0       	brcs	.+4      	; 0x157aa <vfprintf+0x30a>
   157a6:	9d 2c       	mov	r9, r13
   157a8:	0b c0       	rjmp	.+22     	; 0x157c0 <vfprintf+0x320>
   157aa:	9d 2c       	mov	r9, r13
   157ac:	9e 0c       	add	r9, r14
   157ae:	91 1a       	sub	r9, r17
   157b0:	1e 2d       	mov	r17, r14
   157b2:	06 c0       	rjmp	.+12     	; 0x157c0 <vfprintf+0x320>
   157b4:	80 e2       	ldi	r24, 0x20	; 32
   157b6:	90 e0       	ldi	r25, 0x00	; 0
   157b8:	b3 01       	movw	r22, r6
   157ba:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   157be:	1f 5f       	subi	r17, 0xFF	; 255
   157c0:	1e 15       	cp	r17, r14
   157c2:	c0 f3       	brcs	.-16     	; 0x157b4 <vfprintf+0x314>
   157c4:	04 c0       	rjmp	.+8      	; 0x157ce <vfprintf+0x32e>
   157c6:	1e 15       	cp	r17, r14
   157c8:	10 f4       	brcc	.+4      	; 0x157ce <vfprintf+0x32e>
   157ca:	e1 1a       	sub	r14, r17
   157cc:	01 c0       	rjmp	.+2      	; 0x157d0 <vfprintf+0x330>
   157ce:	ee 24       	eor	r14, r14
   157d0:	04 ff       	sbrs	r16, 4
   157d2:	0f c0       	rjmp	.+30     	; 0x157f2 <vfprintf+0x352>
   157d4:	80 e3       	ldi	r24, 0x30	; 48
   157d6:	90 e0       	ldi	r25, 0x00	; 0
   157d8:	b3 01       	movw	r22, r6
   157da:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   157de:	02 ff       	sbrs	r16, 2
   157e0:	1d c0       	rjmp	.+58     	; 0x1581c <vfprintf+0x37c>
   157e2:	01 fd       	sbrc	r16, 1
   157e4:	03 c0       	rjmp	.+6      	; 0x157ec <vfprintf+0x34c>
   157e6:	88 e7       	ldi	r24, 0x78	; 120
   157e8:	90 e0       	ldi	r25, 0x00	; 0
   157ea:	0e c0       	rjmp	.+28     	; 0x15808 <vfprintf+0x368>
   157ec:	88 e5       	ldi	r24, 0x58	; 88
   157ee:	90 e0       	ldi	r25, 0x00	; 0
   157f0:	0b c0       	rjmp	.+22     	; 0x15808 <vfprintf+0x368>
   157f2:	80 2f       	mov	r24, r16
   157f4:	86 78       	andi	r24, 0x86	; 134
   157f6:	91 f0       	breq	.+36     	; 0x1581c <vfprintf+0x37c>
   157f8:	01 ff       	sbrs	r16, 1
   157fa:	02 c0       	rjmp	.+4      	; 0x15800 <vfprintf+0x360>
   157fc:	8b e2       	ldi	r24, 0x2B	; 43
   157fe:	01 c0       	rjmp	.+2      	; 0x15802 <vfprintf+0x362>
   15800:	80 e2       	ldi	r24, 0x20	; 32
   15802:	f7 fc       	sbrc	r15, 7
   15804:	8d e2       	ldi	r24, 0x2D	; 45
   15806:	90 e0       	ldi	r25, 0x00	; 0
   15808:	b3 01       	movw	r22, r6
   1580a:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   1580e:	06 c0       	rjmp	.+12     	; 0x1581c <vfprintf+0x37c>
   15810:	80 e3       	ldi	r24, 0x30	; 48
   15812:	90 e0       	ldi	r25, 0x00	; 0
   15814:	b3 01       	movw	r22, r6
   15816:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   1581a:	9a 94       	dec	r9
   1581c:	d9 14       	cp	r13, r9
   1581e:	c0 f3       	brcs	.-16     	; 0x15810 <vfprintf+0x370>
   15820:	da 94       	dec	r13
   15822:	f1 01       	movw	r30, r2
   15824:	ed 0d       	add	r30, r13
   15826:	f1 1d       	adc	r31, r1
   15828:	80 81       	ld	r24, Z
   1582a:	90 e0       	ldi	r25, 0x00	; 0
   1582c:	b3 01       	movw	r22, r6
   1582e:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   15832:	dd 20       	and	r13, r13
   15834:	a9 f7       	brne	.-22     	; 0x15820 <vfprintf+0x380>
   15836:	06 c0       	rjmp	.+12     	; 0x15844 <vfprintf+0x3a4>
   15838:	80 e2       	ldi	r24, 0x20	; 32
   1583a:	90 e0       	ldi	r25, 0x00	; 0
   1583c:	b3 01       	movw	r22, r6
   1583e:	0e 94 43 ac 	call	0x15886	; 0x15886 <fputc>
   15842:	ea 94       	dec	r14
   15844:	ee 20       	and	r14, r14
   15846:	c1 f7       	brne	.-16     	; 0x15838 <vfprintf+0x398>
   15848:	43 ce       	rjmp	.-890    	; 0x154d0 <vfprintf+0x30>
   1584a:	f3 01       	movw	r30, r6
   1584c:	66 81       	ldd	r22, Z+6	; 0x06
   1584e:	77 81       	ldd	r23, Z+7	; 0x07
   15850:	cb 01       	movw	r24, r22
   15852:	2b 96       	adiw	r28, 0x0b	; 11
   15854:	e2 e1       	ldi	r30, 0x12	; 18
   15856:	0c 94 6a ad 	jmp	0x15ad4	; 0x15ad4 <__epilogue_restores__>

0001585a <strnlen_P>:
   1585a:	fc 01       	movw	r30, r24
   1585c:	05 90       	lpm	r0, Z+
   1585e:	61 50       	subi	r22, 0x01	; 1
   15860:	70 40       	sbci	r23, 0x00	; 0
   15862:	01 10       	cpse	r0, r1
   15864:	d8 f7       	brcc	.-10     	; 0x1585c <strnlen_P+0x2>
   15866:	80 95       	com	r24
   15868:	90 95       	com	r25
   1586a:	8e 0f       	add	r24, r30
   1586c:	9f 1f       	adc	r25, r31
   1586e:	08 95       	ret

00015870 <strnlen>:
   15870:	fc 01       	movw	r30, r24
   15872:	61 50       	subi	r22, 0x01	; 1
   15874:	70 40       	sbci	r23, 0x00	; 0
   15876:	01 90       	ld	r0, Z+
   15878:	01 10       	cpse	r0, r1
   1587a:	d8 f7       	brcc	.-10     	; 0x15872 <strnlen+0x2>
   1587c:	80 95       	com	r24
   1587e:	90 95       	com	r25
   15880:	8e 0f       	add	r24, r30
   15882:	9f 1f       	adc	r25, r31
   15884:	08 95       	ret

00015886 <fputc>:
   15886:	0f 93       	push	r16
   15888:	1f 93       	push	r17
   1588a:	cf 93       	push	r28
   1588c:	df 93       	push	r29
   1588e:	8c 01       	movw	r16, r24
   15890:	eb 01       	movw	r28, r22
   15892:	8b 81       	ldd	r24, Y+3	; 0x03
   15894:	81 ff       	sbrs	r24, 1
   15896:	1b c0       	rjmp	.+54     	; 0x158ce <fputc+0x48>
   15898:	82 ff       	sbrs	r24, 2
   1589a:	0d c0       	rjmp	.+26     	; 0x158b6 <fputc+0x30>
   1589c:	2e 81       	ldd	r18, Y+6	; 0x06
   1589e:	3f 81       	ldd	r19, Y+7	; 0x07
   158a0:	8c 81       	ldd	r24, Y+4	; 0x04
   158a2:	9d 81       	ldd	r25, Y+5	; 0x05
   158a4:	28 17       	cp	r18, r24
   158a6:	39 07       	cpc	r19, r25
   158a8:	64 f4       	brge	.+24     	; 0x158c2 <fputc+0x3c>
   158aa:	e8 81       	ld	r30, Y
   158ac:	f9 81       	ldd	r31, Y+1	; 0x01
   158ae:	01 93       	st	Z+, r16
   158b0:	f9 83       	std	Y+1, r31	; 0x01
   158b2:	e8 83       	st	Y, r30
   158b4:	06 c0       	rjmp	.+12     	; 0x158c2 <fputc+0x3c>
   158b6:	e8 85       	ldd	r30, Y+8	; 0x08
   158b8:	f9 85       	ldd	r31, Y+9	; 0x09
   158ba:	80 2f       	mov	r24, r16
   158bc:	09 95       	icall
   158be:	89 2b       	or	r24, r25
   158c0:	31 f4       	brne	.+12     	; 0x158ce <fputc+0x48>
   158c2:	8e 81       	ldd	r24, Y+6	; 0x06
   158c4:	9f 81       	ldd	r25, Y+7	; 0x07
   158c6:	01 96       	adiw	r24, 0x01	; 1
   158c8:	9f 83       	std	Y+7, r25	; 0x07
   158ca:	8e 83       	std	Y+6, r24	; 0x06
   158cc:	02 c0       	rjmp	.+4      	; 0x158d2 <fputc+0x4c>
   158ce:	0f ef       	ldi	r16, 0xFF	; 255
   158d0:	1f ef       	ldi	r17, 0xFF	; 255
   158d2:	c8 01       	movw	r24, r16
   158d4:	df 91       	pop	r29
   158d6:	cf 91       	pop	r28
   158d8:	1f 91       	pop	r17
   158da:	0f 91       	pop	r16
   158dc:	08 95       	ret

000158de <__ultoa_invert>:
   158de:	fa 01       	movw	r30, r20
   158e0:	aa 27       	eor	r26, r26
   158e2:	28 30       	cpi	r18, 0x08	; 8
   158e4:	51 f1       	breq	.+84     	; 0x1593a <__ultoa_invert+0x5c>
   158e6:	20 31       	cpi	r18, 0x10	; 16
   158e8:	81 f1       	breq	.+96     	; 0x1594a <__ultoa_invert+0x6c>
   158ea:	e8 94       	clt
   158ec:	6f 93       	push	r22
   158ee:	6e 7f       	andi	r22, 0xFE	; 254
   158f0:	6e 5f       	subi	r22, 0xFE	; 254
   158f2:	7f 4f       	sbci	r23, 0xFF	; 255
   158f4:	8f 4f       	sbci	r24, 0xFF	; 255
   158f6:	9f 4f       	sbci	r25, 0xFF	; 255
   158f8:	af 4f       	sbci	r26, 0xFF	; 255
   158fa:	b1 e0       	ldi	r27, 0x01	; 1
   158fc:	3e d0       	rcall	.+124    	; 0x1597a <__ultoa_invert+0x9c>
   158fe:	b4 e0       	ldi	r27, 0x04	; 4
   15900:	3c d0       	rcall	.+120    	; 0x1597a <__ultoa_invert+0x9c>
   15902:	67 0f       	add	r22, r23
   15904:	78 1f       	adc	r23, r24
   15906:	89 1f       	adc	r24, r25
   15908:	9a 1f       	adc	r25, r26
   1590a:	a1 1d       	adc	r26, r1
   1590c:	68 0f       	add	r22, r24
   1590e:	79 1f       	adc	r23, r25
   15910:	8a 1f       	adc	r24, r26
   15912:	91 1d       	adc	r25, r1
   15914:	a1 1d       	adc	r26, r1
   15916:	6a 0f       	add	r22, r26
   15918:	71 1d       	adc	r23, r1
   1591a:	81 1d       	adc	r24, r1
   1591c:	91 1d       	adc	r25, r1
   1591e:	a1 1d       	adc	r26, r1
   15920:	20 d0       	rcall	.+64     	; 0x15962 <__ultoa_invert+0x84>
   15922:	09 f4       	brne	.+2      	; 0x15926 <__ultoa_invert+0x48>
   15924:	68 94       	set
   15926:	3f 91       	pop	r19
   15928:	2a e0       	ldi	r18, 0x0A	; 10
   1592a:	26 9f       	mul	r18, r22
   1592c:	11 24       	eor	r1, r1
   1592e:	30 19       	sub	r19, r0
   15930:	30 5d       	subi	r19, 0xD0	; 208
   15932:	31 93       	st	Z+, r19
   15934:	de f6       	brtc	.-74     	; 0x158ec <__ultoa_invert+0xe>
   15936:	cf 01       	movw	r24, r30
   15938:	08 95       	ret
   1593a:	46 2f       	mov	r20, r22
   1593c:	47 70       	andi	r20, 0x07	; 7
   1593e:	40 5d       	subi	r20, 0xD0	; 208
   15940:	41 93       	st	Z+, r20
   15942:	b3 e0       	ldi	r27, 0x03	; 3
   15944:	0f d0       	rcall	.+30     	; 0x15964 <__ultoa_invert+0x86>
   15946:	c9 f7       	brne	.-14     	; 0x1593a <__ultoa_invert+0x5c>
   15948:	f6 cf       	rjmp	.-20     	; 0x15936 <__ultoa_invert+0x58>
   1594a:	46 2f       	mov	r20, r22
   1594c:	4f 70       	andi	r20, 0x0F	; 15
   1594e:	40 5d       	subi	r20, 0xD0	; 208
   15950:	4a 33       	cpi	r20, 0x3A	; 58
   15952:	18 f0       	brcs	.+6      	; 0x1595a <__ultoa_invert+0x7c>
   15954:	49 5d       	subi	r20, 0xD9	; 217
   15956:	31 fd       	sbrc	r19, 1
   15958:	40 52       	subi	r20, 0x20	; 32
   1595a:	41 93       	st	Z+, r20
   1595c:	02 d0       	rcall	.+4      	; 0x15962 <__ultoa_invert+0x84>
   1595e:	a9 f7       	brne	.-22     	; 0x1594a <__ultoa_invert+0x6c>
   15960:	ea cf       	rjmp	.-44     	; 0x15936 <__ultoa_invert+0x58>
   15962:	b4 e0       	ldi	r27, 0x04	; 4
   15964:	a6 95       	lsr	r26
   15966:	97 95       	ror	r25
   15968:	87 95       	ror	r24
   1596a:	77 95       	ror	r23
   1596c:	67 95       	ror	r22
   1596e:	ba 95       	dec	r27
   15970:	c9 f7       	brne	.-14     	; 0x15964 <__ultoa_invert+0x86>
   15972:	00 97       	sbiw	r24, 0x00	; 0
   15974:	61 05       	cpc	r22, r1
   15976:	71 05       	cpc	r23, r1
   15978:	08 95       	ret
   1597a:	9b 01       	movw	r18, r22
   1597c:	ac 01       	movw	r20, r24
   1597e:	0a 2e       	mov	r0, r26
   15980:	06 94       	lsr	r0
   15982:	57 95       	ror	r21
   15984:	47 95       	ror	r20
   15986:	37 95       	ror	r19
   15988:	27 95       	ror	r18
   1598a:	ba 95       	dec	r27
   1598c:	c9 f7       	brne	.-14     	; 0x15980 <__ultoa_invert+0xa2>
   1598e:	62 0f       	add	r22, r18
   15990:	73 1f       	adc	r23, r19
   15992:	84 1f       	adc	r24, r20
   15994:	95 1f       	adc	r25, r21
   15996:	a0 1d       	adc	r26, r0
   15998:	08 95       	ret

0001599a <__mulsi3>:
   1599a:	62 9f       	mul	r22, r18
   1599c:	d0 01       	movw	r26, r0
   1599e:	73 9f       	mul	r23, r19
   159a0:	f0 01       	movw	r30, r0
   159a2:	82 9f       	mul	r24, r18
   159a4:	e0 0d       	add	r30, r0
   159a6:	f1 1d       	adc	r31, r1
   159a8:	64 9f       	mul	r22, r20
   159aa:	e0 0d       	add	r30, r0
   159ac:	f1 1d       	adc	r31, r1
   159ae:	92 9f       	mul	r25, r18
   159b0:	f0 0d       	add	r31, r0
   159b2:	83 9f       	mul	r24, r19
   159b4:	f0 0d       	add	r31, r0
   159b6:	74 9f       	mul	r23, r20
   159b8:	f0 0d       	add	r31, r0
   159ba:	65 9f       	mul	r22, r21
   159bc:	f0 0d       	add	r31, r0
   159be:	99 27       	eor	r25, r25
   159c0:	72 9f       	mul	r23, r18
   159c2:	b0 0d       	add	r27, r0
   159c4:	e1 1d       	adc	r30, r1
   159c6:	f9 1f       	adc	r31, r25
   159c8:	63 9f       	mul	r22, r19
   159ca:	b0 0d       	add	r27, r0
   159cc:	e1 1d       	adc	r30, r1
   159ce:	f9 1f       	adc	r31, r25
   159d0:	bd 01       	movw	r22, r26
   159d2:	cf 01       	movw	r24, r30
   159d4:	11 24       	eor	r1, r1
   159d6:	08 95       	ret

000159d8 <__udivmodqi4>:
   159d8:	99 1b       	sub	r25, r25
   159da:	79 e0       	ldi	r23, 0x09	; 9
   159dc:	04 c0       	rjmp	.+8      	; 0x159e6 <__udivmodqi4_ep>

000159de <__udivmodqi4_loop>:
   159de:	99 1f       	adc	r25, r25
   159e0:	96 17       	cp	r25, r22
   159e2:	08 f0       	brcs	.+2      	; 0x159e6 <__udivmodqi4_ep>
   159e4:	96 1b       	sub	r25, r22

000159e6 <__udivmodqi4_ep>:
   159e6:	88 1f       	adc	r24, r24
   159e8:	7a 95       	dec	r23
   159ea:	c9 f7       	brne	.-14     	; 0x159de <__udivmodqi4_loop>
   159ec:	80 95       	com	r24
   159ee:	08 95       	ret

000159f0 <__divmodqi4>:
   159f0:	87 fb       	bst	r24, 7
   159f2:	08 2e       	mov	r0, r24
   159f4:	06 26       	eor	r0, r22
   159f6:	87 fd       	sbrc	r24, 7
   159f8:	81 95       	neg	r24
   159fa:	67 fd       	sbrc	r22, 7
   159fc:	61 95       	neg	r22
   159fe:	ec df       	rcall	.-40     	; 0x159d8 <__udivmodqi4>
   15a00:	0e f4       	brtc	.+2      	; 0x15a04 <__divmodqi4_1>
   15a02:	91 95       	neg	r25

00015a04 <__divmodqi4_1>:
   15a04:	07 fc       	sbrc	r0, 7
   15a06:	81 95       	neg	r24

00015a08 <__divmodqi4_exit>:
   15a08:	08 95       	ret

00015a0a <__udivmodhi4>:
   15a0a:	aa 1b       	sub	r26, r26
   15a0c:	bb 1b       	sub	r27, r27
   15a0e:	51 e1       	ldi	r21, 0x11	; 17
   15a10:	07 c0       	rjmp	.+14     	; 0x15a20 <__udivmodhi4_ep>

00015a12 <__udivmodhi4_loop>:
   15a12:	aa 1f       	adc	r26, r26
   15a14:	bb 1f       	adc	r27, r27
   15a16:	a6 17       	cp	r26, r22
   15a18:	b7 07       	cpc	r27, r23
   15a1a:	10 f0       	brcs	.+4      	; 0x15a20 <__udivmodhi4_ep>
   15a1c:	a6 1b       	sub	r26, r22
   15a1e:	b7 0b       	sbc	r27, r23

00015a20 <__udivmodhi4_ep>:
   15a20:	88 1f       	adc	r24, r24
   15a22:	99 1f       	adc	r25, r25
   15a24:	5a 95       	dec	r21
   15a26:	a9 f7       	brne	.-22     	; 0x15a12 <__udivmodhi4_loop>
   15a28:	80 95       	com	r24
   15a2a:	90 95       	com	r25
   15a2c:	bc 01       	movw	r22, r24
   15a2e:	cd 01       	movw	r24, r26
   15a30:	08 95       	ret

00015a32 <__divmodhi4>:
   15a32:	97 fb       	bst	r25, 7
   15a34:	09 2e       	mov	r0, r25
   15a36:	07 26       	eor	r0, r23
   15a38:	0a d0       	rcall	.+20     	; 0x15a4e <__divmodhi4_neg1>
   15a3a:	77 fd       	sbrc	r23, 7
   15a3c:	04 d0       	rcall	.+8      	; 0x15a46 <__divmodhi4_neg2>
   15a3e:	e5 df       	rcall	.-54     	; 0x15a0a <__udivmodhi4>
   15a40:	06 d0       	rcall	.+12     	; 0x15a4e <__divmodhi4_neg1>
   15a42:	00 20       	and	r0, r0
   15a44:	1a f4       	brpl	.+6      	; 0x15a4c <__divmodhi4_exit>

00015a46 <__divmodhi4_neg2>:
   15a46:	70 95       	com	r23
   15a48:	61 95       	neg	r22
   15a4a:	7f 4f       	sbci	r23, 0xFF	; 255

00015a4c <__divmodhi4_exit>:
   15a4c:	08 95       	ret

00015a4e <__divmodhi4_neg1>:
   15a4e:	f6 f7       	brtc	.-4      	; 0x15a4c <__divmodhi4_exit>
   15a50:	90 95       	com	r25
   15a52:	81 95       	neg	r24
   15a54:	9f 4f       	sbci	r25, 0xFF	; 255
   15a56:	08 95       	ret

00015a58 <__udivmodsi4>:
   15a58:	a1 e2       	ldi	r26, 0x21	; 33
   15a5a:	1a 2e       	mov	r1, r26
   15a5c:	aa 1b       	sub	r26, r26
   15a5e:	bb 1b       	sub	r27, r27
   15a60:	fd 01       	movw	r30, r26
   15a62:	0d c0       	rjmp	.+26     	; 0x15a7e <__udivmodsi4_ep>

00015a64 <__udivmodsi4_loop>:
   15a64:	aa 1f       	adc	r26, r26
   15a66:	bb 1f       	adc	r27, r27
   15a68:	ee 1f       	adc	r30, r30
   15a6a:	ff 1f       	adc	r31, r31
   15a6c:	a2 17       	cp	r26, r18
   15a6e:	b3 07       	cpc	r27, r19
   15a70:	e4 07       	cpc	r30, r20
   15a72:	f5 07       	cpc	r31, r21
   15a74:	20 f0       	brcs	.+8      	; 0x15a7e <__udivmodsi4_ep>
   15a76:	a2 1b       	sub	r26, r18
   15a78:	b3 0b       	sbc	r27, r19
   15a7a:	e4 0b       	sbc	r30, r20
   15a7c:	f5 0b       	sbc	r31, r21

00015a7e <__udivmodsi4_ep>:
   15a7e:	66 1f       	adc	r22, r22
   15a80:	77 1f       	adc	r23, r23
   15a82:	88 1f       	adc	r24, r24
   15a84:	99 1f       	adc	r25, r25
   15a86:	1a 94       	dec	r1
   15a88:	69 f7       	brne	.-38     	; 0x15a64 <__udivmodsi4_loop>
   15a8a:	60 95       	com	r22
   15a8c:	70 95       	com	r23
   15a8e:	80 95       	com	r24
   15a90:	90 95       	com	r25
   15a92:	9b 01       	movw	r18, r22
   15a94:	ac 01       	movw	r20, r24
   15a96:	bd 01       	movw	r22, r26
   15a98:	cf 01       	movw	r24, r30
   15a9a:	08 95       	ret

00015a9c <__prologue_saves__>:
   15a9c:	2f 92       	push	r2
   15a9e:	3f 92       	push	r3
   15aa0:	4f 92       	push	r4
   15aa2:	5f 92       	push	r5
   15aa4:	6f 92       	push	r6
   15aa6:	7f 92       	push	r7
   15aa8:	8f 92       	push	r8
   15aaa:	9f 92       	push	r9
   15aac:	af 92       	push	r10
   15aae:	bf 92       	push	r11
   15ab0:	cf 92       	push	r12
   15ab2:	df 92       	push	r13
   15ab4:	ef 92       	push	r14
   15ab6:	ff 92       	push	r15
   15ab8:	0f 93       	push	r16
   15aba:	1f 93       	push	r17
   15abc:	cf 93       	push	r28
   15abe:	df 93       	push	r29
   15ac0:	cd b7       	in	r28, 0x3d	; 61
   15ac2:	de b7       	in	r29, 0x3e	; 62
   15ac4:	ca 1b       	sub	r28, r26
   15ac6:	db 0b       	sbc	r29, r27
   15ac8:	0f b6       	in	r0, 0x3f	; 63
   15aca:	f8 94       	cli
   15acc:	de bf       	out	0x3e, r29	; 62
   15ace:	0f be       	out	0x3f, r0	; 63
   15ad0:	cd bf       	out	0x3d, r28	; 61
   15ad2:	09 94       	ijmp

00015ad4 <__epilogue_restores__>:
   15ad4:	2a 88       	ldd	r2, Y+18	; 0x12
   15ad6:	39 88       	ldd	r3, Y+17	; 0x11
   15ad8:	48 88       	ldd	r4, Y+16	; 0x10
   15ada:	5f 84       	ldd	r5, Y+15	; 0x0f
   15adc:	6e 84       	ldd	r6, Y+14	; 0x0e
   15ade:	7d 84       	ldd	r7, Y+13	; 0x0d
   15ae0:	8c 84       	ldd	r8, Y+12	; 0x0c
   15ae2:	9b 84       	ldd	r9, Y+11	; 0x0b
   15ae4:	aa 84       	ldd	r10, Y+10	; 0x0a
   15ae6:	b9 84       	ldd	r11, Y+9	; 0x09
   15ae8:	c8 84       	ldd	r12, Y+8	; 0x08
   15aea:	df 80       	ldd	r13, Y+7	; 0x07
   15aec:	ee 80       	ldd	r14, Y+6	; 0x06
   15aee:	fd 80       	ldd	r15, Y+5	; 0x05
   15af0:	0c 81       	ldd	r16, Y+4	; 0x04
   15af2:	1b 81       	ldd	r17, Y+3	; 0x03
   15af4:	aa 81       	ldd	r26, Y+2	; 0x02
   15af6:	b9 81       	ldd	r27, Y+1	; 0x01
   15af8:	ce 0f       	add	r28, r30
   15afa:	d1 1d       	adc	r29, r1
   15afc:	0f b6       	in	r0, 0x3f	; 63
   15afe:	f8 94       	cli
   15b00:	de bf       	out	0x3e, r29	; 62
   15b02:	0f be       	out	0x3f, r0	; 63
   15b04:	cd bf       	out	0x3d, r28	; 61
   15b06:	ed 01       	movw	r28, r26
   15b08:	08 95       	ret

00015b0a <_exit>:
   15b0a:	f8 94       	cli

00015b0c <__stop_program>:
   15b0c:	ff cf       	rjmp	.-2      	; 0x15b0c <__stop_program>
